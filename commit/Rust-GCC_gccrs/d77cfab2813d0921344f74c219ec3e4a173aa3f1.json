{"sha": "d77cfab2813d0921344f74c219ec3e4a173aa3f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc3Y2ZhYjI4MTNkMDkyMTM0NGY3NGMyMTllYzNlNGExNzNhYTNmMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-01T08:58:50Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-01T08:58:50Z"}, "message": "[multiple changes]\n\n2014-08-01  Gary Dismukes  <dismukes@adacore.com>\n\n\t* makeutl.ads, opt.ads: Minor grammar fixes.\n\t* makeutl.adb: Minor code reorganization.\n\n2014-08-01  Arnaud Charlet  <charlet@adacore.com>\n\n\t* gcc-interface/Makefile.in, gcc-interface/Make-lang.in,\n\tgnatsym.adb: Remove gnatsym (VMS only tool).\n\n2014-08-01  Ben Brosgol  <brosgol@adacore.com>\n\n\t* gnat_ugn.texi, projects.texi, xgnatugn.adb: Removed all VMS\n\tconditionalization from gnat_ugn.texi and projects.texi, and updated\n\t(considerably simplified) xgnatugn.adb, to be removed soon.\n\nFrom-SVN: r213427", "tree": {"sha": "1142a04682934a8780528bde27cb0ae6f0707e7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1142a04682934a8780528bde27cb0ae6f0707e7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d77cfab2813d0921344f74c219ec3e4a173aa3f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d77cfab2813d0921344f74c219ec3e4a173aa3f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d77cfab2813d0921344f74c219ec3e4a173aa3f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d77cfab2813d0921344f74c219ec3e4a173aa3f1/comments", "author": null, "committer": null, "parents": [{"sha": "c84495c0e1f09b876c4db803a9436632eed74cb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c84495c0e1f09b876c4db803a9436632eed74cb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c84495c0e1f09b876c4db803a9436632eed74cb1"}], "stats": {"total": 10562, "additions": 3067, "deletions": 7495}, "files": [{"sha": "29fe77fb361c2d9c6570752b95254d3fa7b7a53c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77cfab2813d0921344f74c219ec3e4a173aa3f1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77cfab2813d0921344f74c219ec3e4a173aa3f1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d77cfab2813d0921344f74c219ec3e4a173aa3f1", "patch": "@@ -1,3 +1,19 @@\n+2014-08-01  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* makeutl.ads, opt.ads: Minor grammar fixes.\n+\t* makeutl.adb: Minor code reorganization.\n+\n+2014-08-01  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* gcc-interface/Makefile.in, gcc-interface/Make-lang.in,\n+\tgnatsym.adb: Remove gnatsym (VMS only tool).\n+\n+2014-08-01  Ben Brosgol  <brosgol@adacore.com>\n+\n+\t* gnat_ugn.texi, projects.texi, xgnatugn.adb: Removed all VMS\n+\tconditionalization from gnat_ugn.texi and projects.texi, and updated\n+\t(considerably simplified) xgnatugn.adb, to be removed soon.\n+\n 2014-08-01  Vincent Celier  <celier@adacore.com>\n \n \t* debug.adb: Remove doc for gnatmake/gprbuild switch -ds."}, {"sha": "4b87997e23397e9b24e89880c2c9de0e6b8813f8", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77cfab2813d0921344f74c219ec3e4a173aa3f1/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77cfab2813d0921344f74c219ec3e4a173aa3f1/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=d77cfab2813d0921344f74c219ec3e4a173aa3f1", "patch": "@@ -89,7 +89,7 @@ ADA_FLAGS_TO_PASS = \\\n \n # List of Ada tools to build and install\n ADA_TOOLS=gnatbind gnatchop gnat gnatkr gnatlink gnatls gnatmake \\\n-          gnatname gnatprep gnatxref gnatfind gnatclean gnatsym\n+          gnatname gnatprep gnatxref gnatfind gnatclean\n \n # Say how to compile Ada programs.\n .SUFFIXES: .ada .adb .ads\n@@ -763,8 +763,7 @@ doc/gnat-style.pdf: ada/gnat-style.texi $(gcc_docdir)/include/fdl.texi\n # or from the --target option if the former is not specified.\n # Do the same for the rest of the Ada tools (gnatchop, gnat, gnatkr,\n # gnatlink, gnatls, gnatmake, gnatname, gnatprep, gnatxref, gnatfind,\n-# gnatclean, gnatsym).\n-# gnatsym is only built on some platforms, including VMS.\n+# gnatclean).\n # gnatdll is only used on Windows.\n # vxaddr2line is only used for cross VxWorks ports (it calls the underlying\n # cross addr2line).\n@@ -840,7 +839,6 @@ ada.distclean:\n \t-$(RM) gnatfind$(exeext)\n \t-$(RM) gnatxref$(exeext)\n \t-$(RM) gnatclean$(exeext)\n-\t-$(RM) gnatsym$(exeext)\n \t-$(RM) ada/rts/*\n \t-$(RMDIR) ada/rts\n \t-$(RM) ada/tools/*"}, {"sha": "892119b58feebde7d05119735713288192e8f4b4", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77cfab2813d0921344f74c219ec3e4a173aa3f1/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77cfab2813d0921344f74c219ec3e4a173aa3f1/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=d77cfab2813d0921344f74c219ec3e4a173aa3f1", "patch": "@@ -2544,11 +2544,6 @@ common-tools: ../stamp-tools\n \t$(GNATLINK) -v gnatclean -o ../../gnatclean$(exeext) \\\n \t\t--GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n \n-../../gnatsym$(exeext): ../stamp-tools\n-\t$(GNATMAKE) -c $(ADA_INCLUDES) gnatsym --GCC=\"$(CC) $(ALL_ADAFLAGS)\"\n-\t$(GNATBIND) $(ADA_INCLUDES) $(GNATBIND_FLAGS) gnatsym\n-\t$(GNATLINK) -v gnatsym -o $@ --GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n-\n ../../gnatdll$(exeext): ../stamp-tools\n \t$(GNATMAKE) -c $(ADA_INCLUDES) gnatdll --GCC=\"$(CC) $(ALL_ADAFLAGS)\"\n \t$(GNATBIND) $(ADA_INCLUDES) $(GNATBIND_FLAGS) gnatdll"}, {"sha": "83be0023138235da19d62ec1d0ff31c8808dcec9", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 2694, "deletions": 5719, "changes": 8413, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77cfab2813d0921344f74c219ec3e4a173aa3f1/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77cfab2813d0921344f74c219ec3e4a173aa3f1/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=d77cfab2813d0921344f74c219ec3e4a173aa3f1"}, {"sha": "5a88994a4c4496ef9e96011aebae4ec87d2c1c1f", "filename": "gcc/ada/gnatsym.adb", "status": "removed", "additions": 0, "deletions": 359, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c84495c0e1f09b876c4db803a9436632eed74cb1/gcc%2Fada%2Fgnatsym.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c84495c0e1f09b876c4db803a9436632eed74cb1/gcc%2Fada%2Fgnatsym.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatsym.adb?ref=c84495c0e1f09b876c4db803a9436632eed74cb1", "patch": "@@ -1,359 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                              G N A T S Y M                               --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2003-2010, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This utility application creates symbol files in a format that is\n---  platform-dependent.\n-\n---  A symbol file is a text file that lists the symbols to be exported from\n---  a shared library. The format of a symbol file depends on the platform;\n---  it may be a simple enumeration of the symbol (one per line) or a more\n---  elaborate format (on VMS, for example). A symbol file may be used as an\n---  input to the platform linker when building a shared library.\n-\n---  This utility is not available on all platforms. It is currently supported\n---  only on OpenVMS.\n-\n---  gnatsym takes as parameters:\n---    - the name of the symbol file to create\n---    - (optional) the policy to create the symbol file\n---    - (optional) the name of the reference symbol file\n---    - the names of one or more object files where the symbols are found\n-\n-with Gnatvsn; use Gnatvsn;\n-with Osint;   use Osint;\n-with Output;  use Output;\n-with Symbols; use Symbols;\n-with Table;\n-\n-with Ada.Exceptions; use Ada.Exceptions;\n-with Ada.Text_IO;    use Ada.Text_IO;\n-\n-with GNAT.Command_Line;         use GNAT.Command_Line;\n-with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n-with GNAT.OS_Lib;               use GNAT.OS_Lib;\n-\n-procedure Gnatsym is\n-\n-   Empty_String : aliased String := \"\";\n-   Empty        : constant String_Access := Empty_String'Unchecked_Access;\n-   --  To initialize variables Reference and Version_String\n-\n-   Copyright_Displayed : Boolean := False;\n-   --  A flag to prevent multiple display of the Copyright notice\n-\n-   Success : Boolean := True;\n-\n-   Symbol_Policy : Policy := Autonomous;\n-\n-   Verbose : Boolean := False;\n-   --  True when -v switch is used\n-\n-   Quiet : Boolean := False;\n-   --  True when -q switch is used\n-\n-   Symbol_File_Name : String_Access := null;\n-   --  The name of the symbol file\n-\n-   Reference_Symbol_File_Name : String_Access := Empty;\n-   --  The name of the reference symbol file\n-\n-   Version_String : String_Access := Empty;\n-   --  The version of the library (used on VMS)\n-\n-   type Object_File_Data is record\n-      Path : String_Access;\n-      Name : String_Access;\n-   end record;\n-\n-   package Object_Files is new Table.Table\n-     (Table_Component_Type => Object_File_Data,\n-      Table_Index_Type     => Natural,\n-      Table_Low_Bound      => 0,\n-      Table_Initial        => 10,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Gnatsymb.Object_Files\");\n-   --  A table to store the object file names\n-\n-   Object_File : Natural := 0;\n-   --  An index to traverse the Object_Files table\n-\n-   procedure Display_Copyright;\n-   --  Display Copyright notice\n-\n-   procedure Parse_Cmd_Line;\n-   --  Parse the command line switches and file names\n-\n-   procedure Usage;\n-   --  Display the usage\n-\n-   -----------------------\n-   -- Display_Copyright --\n-   -----------------------\n-\n-   procedure Display_Copyright is\n-   begin\n-      if not Copyright_Displayed then\n-         Write_Eol;\n-         Write_Str (\"GNATSYMB \");\n-         Write_Str (Gnat_Version_String);\n-         Write_Eol;\n-         Write_Str (\"Copyright 2003-2004 Free Software Foundation, Inc\");\n-         Write_Eol;\n-         Copyright_Displayed := True;\n-      end if;\n-   end Display_Copyright;\n-\n-   --------------------\n-   -- Parse_Cmd_Line --\n-   --------------------\n-\n-   procedure Parse_Cmd_Line is\n-   begin\n-      loop\n-         case GNAT.Command_Line.Getopt (\"c C D q r: R s: v V:\") is\n-            when ASCII.NUL =>\n-               exit;\n-\n-            when 'c' =>\n-               Symbol_Policy := Compliant;\n-\n-            when 'C' =>\n-               Symbol_Policy := Controlled;\n-\n-            when 'D' =>\n-               Symbol_Policy := Direct;\n-\n-            when 'q' =>\n-               Quiet := True;\n-\n-            when 'r' =>\n-               Reference_Symbol_File_Name :=\n-                 new String'(GNAT.Command_Line.Parameter);\n-\n-            when 'R' =>\n-               Symbol_Policy := Restricted;\n-\n-            when 's' =>\n-               Symbol_File_Name := new String'(GNAT.Command_Line.Parameter);\n-\n-            when 'v' =>\n-               Verbose := True;\n-\n-            when 'V' =>\n-               Version_String := new String'(GNAT.Command_Line.Parameter);\n-\n-            when others =>\n-               Fail (\"invalid switch: \" & Full_Switch);\n-         end case;\n-      end loop;\n-\n-      --  Get the object file names and put them in the table in alphabetical\n-      --  order of base names.\n-\n-      loop\n-         declare\n-            S : constant String_Access :=\n-                           new String'(GNAT.Command_Line.Get_Argument);\n-\n-         begin\n-            exit when S'Length = 0;\n-\n-            Object_Files.Increment_Last;\n-\n-            declare\n-               Base : constant String := Base_Name (S.all);\n-               Last : constant Positive := Object_Files.Last;\n-               J    : Positive;\n-\n-            begin\n-               J := 1;\n-               while J < Last loop\n-                  if Object_Files.Table (J).Name.all > Base then\n-                     Object_Files.Table (J + 1 .. Last) :=\n-                       Object_Files.Table (J .. Last - 1);\n-                     exit;\n-                  end if;\n-\n-                  J := J + 1;\n-               end loop;\n-\n-               Object_Files.Table (J) := (S, new String'(Base));\n-            end;\n-         end;\n-      end loop;\n-   exception\n-      when Invalid_Switch =>\n-         Usage;\n-         Fail (\"invalid switch : \" & Full_Switch);\n-   end Parse_Cmd_Line;\n-\n-   -----------\n-   -- Usage --\n-   -----------\n-\n-   procedure Usage is\n-   begin\n-      Write_Line (\"gnatsym [options] object_file {object_file}\");\n-      Write_Eol;\n-      Write_Line (\"   -c       Compliant symbol policy\");\n-      Write_Line (\"   -C       Controlled symbol policy\");\n-      Write_Line (\"   -q       Quiet mode\");\n-      Write_Line (\"   -r<ref>  Reference symbol file name\");\n-      Write_Line (\"   -R       Restricted symbol policy\");\n-      Write_Line (\"   -s<sym>  Symbol file name\");\n-      Write_Line (\"   -v       Verbose mode\");\n-      Write_Line (\"   -V<ver>  Version\");\n-      Write_Eol;\n-      Write_Line (\"Specifying a symbol file with -s<sym> is compulsory\");\n-      Write_Eol;\n-   end Usage;\n-\n---  Start of processing of Gnatsym\n-\n-begin\n-   --  Initialize Object_Files table\n-\n-   Object_Files.Set_Last (0);\n-\n-   --  Parse the command line\n-\n-   Parse_Cmd_Line;\n-\n-   if Verbose then\n-      Display_Copyright;\n-   end if;\n-\n-   --  If there is no symbol file or no object files on the command line,\n-   --  display the usage and exit with an error status.\n-\n-   if Symbol_File_Name = null or else Object_Files.Last = 0 then\n-      Usage;\n-      OS_Exit (1);\n-\n-   --  When symbol policy is direct, simply copy the reference symbol file to\n-   --  the symbol file.\n-\n-   elsif Symbol_Policy = Direct then\n-      declare\n-         File_In  : Ada.Text_IO.File_Type;\n-         File_Out : Ada.Text_IO.File_Type;\n-         Line     : String (1 .. 1_000);\n-         Last     : Natural;\n-\n-      begin\n-         begin\n-            Open (File_In, In_File, Reference_Symbol_File_Name.all);\n-\n-         exception\n-            when X : others =>\n-               if not Quiet then\n-                  Put_Line\n-                    (\"could not open \"\"\" &\n-                     Reference_Symbol_File_Name.all\n-                     & \"\"\"\");\n-                  Put_Line (Exception_Message (X));\n-               end if;\n-\n-               OS_Exit (1);\n-         end;\n-\n-         begin\n-            Create (File_Out, Out_File, Symbol_File_Name.all);\n-\n-         exception\n-            when X : others =>\n-               if not Quiet then\n-                  Put_Line\n-                    (\"could not create \"\"\" & Symbol_File_Name.all & \"\"\"\");\n-                  Put_Line (Exception_Message (X));\n-               end if;\n-\n-               OS_Exit (1);\n-         end;\n-\n-         while not End_Of_File (File_In) loop\n-            Get_Line (File_In, Line, Last);\n-            Put_Line (File_Out, Line (1 .. Last));\n-         end loop;\n-\n-         Close (File_In);\n-         Close (File_Out);\n-      end;\n-\n-   else\n-      if Verbose then\n-         Write_Str (\"Initializing symbol file \"\"\");\n-         Write_Str (Symbol_File_Name.all);\n-         Write_Line (\"\"\"\");\n-      end if;\n-\n-      --  Initialize symbol file and, if specified, read reference file\n-\n-      Symbols.Initialize\n-        (Symbol_File   => Symbol_File_Name.all,\n-         Reference     => Reference_Symbol_File_Name.all,\n-         Symbol_Policy => Symbol_Policy,\n-         Quiet         => Quiet,\n-         Version       => Version_String.all,\n-         Success       => Success);\n-\n-      --  Process the object files in order. Stop as soon as there is\n-      --  something wrong.\n-\n-      Object_File := 0;\n-\n-      while Success and then Object_File < Object_Files.Last loop\n-         Object_File := Object_File + 1;\n-\n-         if Verbose then\n-            Write_Str (\"Processing object file \"\"\");\n-            Write_Str (Object_Files.Table (Object_File).Path.all);\n-            Write_Line (\"\"\"\");\n-         end if;\n-\n-         Processing.Process\n-           (Object_Files.Table (Object_File).Path.all,\n-            Success);\n-      end loop;\n-\n-      --  Finalize the symbol file\n-\n-      if Success then\n-         if Verbose then\n-            Write_Str (\"Finalizing \"\"\");\n-            Write_Str (Symbol_File_Name.all);\n-            Write_Line (\"\"\"\");\n-         end if;\n-\n-         Finalize (Quiet, Success);\n-      end if;\n-\n-      --  Fail if there was anything wrong\n-\n-      if not Success then\n-         Fail (\"unable to build symbol file\");\n-      end if;\n-   end if;\n-end Gnatsym;"}, {"sha": "cbfd01e49d3c7262e30eae8f6137bade97c4a16e", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77cfab2813d0921344f74c219ec3e4a173aa3f1/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77cfab2813d0921344f74c219ec3e4a173aa3f1/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=d77cfab2813d0921344f74c219ec3e4a173aa3f1", "patch": "@@ -777,7 +777,7 @@ package body Makeutl is\n       Flush_Messages : Boolean := True)\n    is\n    begin\n-      if Flush_Messages and then not No_Exit_Message then\n+      if Flush_Messages and not No_Exit_Message then\n          if Total_Errors_Detected /= 0 or else Warnings_Detected /= 0 then\n             Errutil.Finalize;\n          end if;"}, {"sha": "e946df6f759f6ac6ea8416f956eccc6271a49b31", "filename": "gcc/ada/makeutl.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77cfab2813d0921344f74c219ec3e4a173aa3f1/gcc%2Fada%2Fmakeutl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77cfab2813d0921344f74c219ec3e4a173aa3f1/gcc%2Fada%2Fmakeutl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.ads?ref=d77cfab2813d0921344f74c219ec3e4a173aa3f1", "patch": "@@ -81,8 +81,8 @@ package Makeutl is\n \n    No_Exit_Message_Option : constant String := \"--no-exit-message\";\n    --  Switch to suppress exit error message when there are compilation\n-   --  failures. This is useful when a tool, such as gnatprove, call silently\n-   --  the builder and do not want to pollute its output with error messages\n+   --  failures. This is useful when a tool, such as gnatprove, silently calls\n+   --  the builder and does not want to pollute its output with error messages\n    --  coming from the builder. This is an internal switch.\n \n    Load_Standard_Base : Boolean := True;"}, {"sha": "e2cc76a428fa36459d372b098cedaca8fafcbb8a", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77cfab2813d0921344f74c219ec3e4a173aa3f1/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77cfab2813d0921344f74c219ec3e4a173aa3f1/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=d77cfab2813d0921344f74c219ec3e4a173aa3f1", "patch": "@@ -1941,7 +1941,7 @@ package Opt is\n    No_Exit_Message : Boolean := False;\n    --  GNATMAKE, GPRBUILD\n    --  Set with switch --no-exit-message. When True, if there are compilation\n-   --  failure, the builder does not issue an exit error message.\n+   --  failures, the builder does not issue an exit error message.\n \n    Optimize_Alignment_Config : Character;\n    --  GNAT"}, {"sha": "65939c06b9e4f2b51f57815c274c9bc589f3ccc2", "filename": "gcc/ada/projects.texi", "status": "modified", "additions": 331, "deletions": 353, "changes": 684, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77cfab2813d0921344f74c219ec3e4a173aa3f1/gcc%2Fada%2Fprojects.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77cfab2813d0921344f74c219ec3e4a173aa3f1/gcc%2Fada%2Fprojects.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprojects.texi?ref=d77cfab2813d0921344f74c219ec3e4a173aa3f1", "patch": "@@ -41,7 +41,7 @@ project files allow you to specify:\n @item The directory in which the compiler's output\n   (@file{ALI} files, object files, tree files, etc.) is to be placed\n @item The directory in which the executable programs are to be placed\n-@item ^Switch^Switch^ settings for any of the project-enabled tools;\n+@item Switch settings for any of the project-enabled tools;\n   you can apply these settings either globally or to individual compilation units.\n @item The source files containing the main subprogram(s) to be built\n @item The source programming language(s)\n@@ -68,7 +68,7 @@ Subsystems}).\n   More generally, the Project Manager lets you structure large development\n   efforts into hierarchical subsystems, where build decisions are delegated\n   to the subsystem level, and thus different compilation environments\n-  (^switch^switch^ settings) used for different subsystems.\n+  (switch settings) used for different subsystems.\n @item You can organize GNAT projects in a hierarchy: a child project\n   can extend a parent project, inheriting the parent's source files and\n   optionally overriding any of them with alternative versions\n@@ -80,16 +80,16 @@ Subsystems}).\n Several tools support project files, generally in addition to specifying\n the information on the command line itself). They share common switches\n to control the loading of the project (in particular\n-@option{^-P^/PROJECT_FILE=^@emph{projectfile}} and\n-@option{^-X^/EXTERNAL_REFERENCE=^@emph{vbl}=@emph{value}}).\n+@option{-P@emph{projectfile}} and\n+@option{-X@emph{vbl}=@emph{value}}).\n \n The Project Manager supports a wide range of development strategies,\n for systems of all sizes.  Here are some typical practices that are\n easily handled:\n \n @itemize @bullet\n @item Using a common set of source files and generating object files in different\n-  directories via different ^switch^switch^ settings. It can be used for instance, for\n+  directories via different switch settings. It can be used for instance, for\n   generating separate sets of object files for debugging and for production.\n @item Using a mostly-shared set of source files with different versions of\n   some units or subunits. It can be used for instance, for grouping and hiding\n@@ -185,19 +185,19 @@ following examples.\n The Ada source files @file{pack.ads}, @file{pack.adb}, and @file{proc.adb} are in\n the @file{common/} directory. The file @file{proc.adb} contains an Ada main\n subprogram @code{Proc} that @code{with}s package @code{Pack}. We want to compile\n-these source files with the ^switch^switch^\n-@option{^-O2^-O2^}, and put the resulting files in\n+these source files with the switch\n+@option{-O2}, and put the resulting files in\n the directory @file{obj/}.\n \n @smallexample\n @group\n-^common/^[COMMON]^\n+common/\n   pack.ads\n   pack.adb\n   proc.adb\n @end group\n @group\n-^common/release/^[COMMON.RELEASE]^\n+common/release/\n   proc.ali, proc.o pack.ali, pack.o\n @end group\n @end smallexample\n@@ -450,7 +450,7 @@ Its value is the path to the object directory, either absolute or\n relative to the directory containing the project file. This\n directory must already exist and be readable and writable, although\n some tools have a switch to create the directory if needed (See\n-the switch @code{^-p^/CREATE_MISSING_DIRS^} for @command{gnatmake}\n+the switch @code{-p} for @command{gnatmake}\n and @command{gprbuild}).\n \n If the attribute @code{Object_Dir} is not specified, it defaults to\n@@ -540,7 +540,7 @@ If this attribute is defined in the project, then spawning the builder\n with a command such as\n \n @smallexample\n-   gnatmake ^-Pbuild^/PROJECT_FILE=build^\n+   gnatmake -Pbuild\n @end smallexample\n \n @noindent\n@@ -617,13 +617,13 @@ packages would be involved in the build process.\n \n @noindent\n Let's first examine the compiler switches. As stated in the initial description\n-of the example, we want to compile all files with @option{^-O2^-O2^}. This is a\n+of the example, we want to compile all files with @option{-O2}. This is a\n compiler switch, although it is usual, on the command line, to pass it to the\n builder which then passes it to the compiler. It is recommended to use directly\n the right package, which will make the setup easier to understand for other\n people.\n \n-Several attributes can be used to specify the ^switches^switches^:\n+Several attributes can be used to specify the switches:\n \n @table @asis\n @item @b{Default_Switches}:\n@@ -636,53 +636,53 @@ Several attributes can be used to specify the ^switches^switches^:\n   likely be used for each language, and each compiler has its own set of\n   switches). The value of the attribute is a list of switches.\n \n-  In this example, we want to compile all Ada source files with the ^switch^switch^\n-  @option{^-O2^-O2^}, and the resulting project file is as follows\n+  In this example, we want to compile all Ada source files with the switch\n+  @option{-O2}, and the resulting project file is as follows\n   (only the @code{Compiler} package is shown):\n \n   @smallexample\n   @b{package} Compiler @b{is}\n-    @b{for} Default_Switches (\"Ada\") @b{use} (\"^-O2^-O2^\");\n+    @b{for} Default_Switches (\"Ada\") @b{use} (\"-O2\");\n   @b{end} Compiler;\n   @end smallexample\n \n-@item @b{^Switches^Switches^}:\n-@cindex @code{^Switches^Switches^}\n-  in some cases, we might want to use specific ^switches^switches^\n+@item @b{Switches}:\n+@cindex @code{Switches}\n+  in some cases, we might want to use specific switches\n   for one or more files. For instance, compiling @file{proc.adb} might not be\n   possible at high level of optimization because of a compiler issue.\n-  In such a case, the @emph{^Switches^Switches^}\n+  In such a case, the @emph{Switches}\n   attribute (indexed on the file name) can be used and will override the\n   switches defined by @emph{Default_Switches}. Our project file would\n   become:\n \n   @smallexample\n   package Compiler is\n      for Default_Switches (\"Ada\")\n-         use (\"^-O2^-O2^\");\n-     for ^Switches^Switches^ (\"proc.adb\")\n-         use (\"^-O0^-O0^\");\n+         use (\"-O2\");\n+     for Switches (\"proc.adb\")\n+         use (\"-O0\");\n   end Compiler;\n   @end smallexample\n \n   @noindent\n-  @code{^Switches^Switches^} may take a pattern as an index, such as in:\n+  @code{Switches} may take a pattern as an index, such as in:\n \n   @smallexample\n   package Compiler is\n     for Default_Switches (\"Ada\")\n-        use (\"^-O2^-O2^\");\n-    for ^Switches^Switches^ (\"pkg*\")\n-        use (\"^-O0^-O0^\");\n+        use (\"-O2\");\n+    for Switches (\"pkg*\")\n+        use (\"-O0\");\n   end Compiler;\n   @end smallexample\n \n   @noindent\n-  Sources @file{pkg.adb} and @file{pkg-child.adb} would be compiled with ^-O0^-O0^,\n-  not ^-O2^-O2^.\n+  Sources @file{pkg.adb} and @file{pkg-child.adb} would be compiled with -O0,\n+  not -O2.\n \n   @noindent\n-  @code{^Switches^Switches^} can also be given a language name as index instead of a file\n+  @code{Switches} can also be given a language name as index instead of a file\n   name in which case it has the same semantics as @emph{Default_Switches}.\n   However, indexes with wild cards are never valid for language name.\n \n@@ -696,7 +696,7 @@ Several attributes can be used to specify the ^switches^switches^:\n @end table\n \n The switches for the other tools are defined in a similar manner through the\n-@b{Default_Switches} and @b{^Switches^Switches^} attributes, respectively in the\n+@b{Default_Switches} and @b{Switches} attributes, respectively in the\n @emph{Builder} package (for @command{gnatmake} and @command{gprbuild}),\n the @emph{Binder} package (binding Ada executables) and the @emph{Linker}\n package (for linking executables).\n@@ -711,7 +711,7 @@ Now that our project files are written, let's build our executable.\n Here is the command we would use from the command line:\n \n @smallexample\n-   gnatmake ^-Pbuild^/PROJECT_FILE=build^\n+   gnatmake -Pbuild\n @end smallexample\n \n @noindent\n@@ -727,7 +727,7 @@ same way: create the file @file{utils.c} in the @file{common} directory,\n set the attribute @emph{Languages} to @code{\"(Ada, C)\"}, and run\n \n @smallexample\n-   gprbuild ^-Pbuild^/PROJECT_FILE=build^\n+   gprbuild -Pbuild\n @end smallexample\n \n @noindent\n@@ -784,12 +784,12 @@ on Windows), we could configure our project file to build \"proc1\"\n (resp proc1.exe) with the following addition:\n \n @smallexample @c projectfile\n-   project Build is\n-      ...  --  same as before\n-      package Builder is\n-         for Executable (\"proc.adb\") use \"proc1\";\n-      end Builder\n-   end Build;\n+   @b{project} Build @b{is}\n+      ...  --@i{  same as before}\n+      @b{package} Builder @b{is}\n+         @b{for} Executable (\"proc.adb\") @b{use} \"proc1\";\n+      @b{end} Builder\n+   @b{end} Build;\n @end smallexample\n \n @noindent\n@@ -815,18 +815,18 @@ To illustrate some other project capabilities, here is a slightly more complex\n project using similar sources and a main program in C:\n \n @smallexample @c projectfile\n-project C_Main is\n-   for Languages    use (\"Ada\", \"C\");\n-   for Source_Dirs  use (\"common\");\n-   for Object_Dir   use  \"obj\";\n-   for Main         use (\"main.c\");\n-   package Compiler is\n+@b{project} C_Main @b{is}\n+   @b{for} Languages    @b{use} (\"Ada\", \"C\");\n+   @b{for} Source_Dirs  @b{use} (\"common\");\n+   @b{for} Object_Dir   @b{use}  \"obj\";\n+   @b{for} Main         @b{use} (\"main.c\");\n+   @b{package} Compiler @b{is}\n       C_Switches := (\"-pedantic\");\n-      for Default_Switches (\"C\")   use C_Switches;\n-      for Default_Switches (\"Ada\") use (\"^-gnaty^-gnaty^\");\n-      for ^Switches^Switches^ (\"main.c\") use C_Switches & (\"-g\");\n-   end Compiler;\n-end C_Main;\n+      @b{for} Default_Switches (\"C\")   @b{use} C_Switches;\n+      @b{for} Default_Switches (\"Ada\") @b{use} (\"-gnaty\");\n+      @b{for} Switches (\"main.c\") @b{use} C_Switches & (\"-g\");\n+   @b{end} Compiler;\n+@b{end} C_Main;\n @end smallexample\n \n @noindent\n@@ -848,7 +848,7 @@ In this specific situation the use of a variable could have been\n replaced by a reference to the @code{Default_Switches} attribute:\n \n @smallexample @c projectfile\n-   for ^Switches^Switches^ (\"c_main.c\") use Compiler'Default_Switches (\"C\") & (\"-g\");\n+   @b{for} Switches (\"c_main.c\") @b{use} Compiler'Default_Switches (\"C\") & (\"-g\");\n @end smallexample\n \n @noindent\n@@ -940,7 +940,7 @@ The following attributes can be defined in package @code{Naming}:\n   @code{Specification_Exceptions}.\n \n   If @code{Spec_Suffix (\"Ada\")} is not specified, then the default is\n-  @code{\"^.ads^.ADS^\"}.\n+  @code{\".ads\"}.\n \n   A non empty value must satisfy the following requirements:\n \n@@ -969,7 +969,7 @@ The following attributes can be defined in package @code{Naming}:\n   In addition, they must be different from any of the values in\n   @code{Spec_Suffix}.\n   If @code{Body_Suffix (\"Ada\")} is not specified, then the default is\n-  @code{\"^.adb^.ADB^\"}.\n+  @code{\".adb\"}.\n \n   If @code{Body_Suffix (\"Ada\")} and @code{Spec_Suffix (\"Ada\")} end with the\n   same string, then a file name that ends with the longest of these two\n@@ -1029,39 +1029,20 @@ The following attributes can be defined in package @code{Naming}:\n \n @end table\n \n-@ifclear vms\n+@set unw\n For example, the following package models the Apex file naming rules:\n \n @smallexample @c projectfile\n @group\n-  package Naming is\n-    for Casing               use \"lowercase\";\n-    for Dot_Replacement      use \".\";\n-    for Spec_Suffix (\"Ada\")  use \".1.ada\";\n-    for Body_Suffix (\"Ada\")  use \".2.ada\";\n-  end Naming;\n+  @b{package} Naming @b{is}\n+    @b{for} Casing               @b{use} \"lowercase\";\n+    @b{for} Dot_Replacement      @b{use} \".\";\n+    @b{for} Spec_Suffix (\"Ada\")  @b{use} \".1.ada\";\n+    @b{for} Body_Suffix (\"Ada\")  @b{use} \".2.ada\";\n+  @b{end} Naming;\n @end group\n @end smallexample\n-@end ifclear\n \n-@ifset vms\n-For example, the following package models the DEC Ada file naming rules:\n-\n-@smallexample @c projectfile\n-@group\n-  package Naming is\n-    for Casing               use \"lowercase\";\n-    for Dot_Replacement      use \"__\";\n-    for Spec_Suffix (\"Ada\")  use \"_.ada\";\n-    for Body_Suffix (\"Ada\")  use \".ada\";\n-  end Naming;\n-@end group\n-@end smallexample\n-\n-@noindent\n-(Note that @code{Casing} is @code{\"lowercase\"} because GNAT gets the file\n-names in lower case)\n-@end ifset\n \n @c ---------------------------------------------\n @node Installation\n@@ -1186,11 +1167,11 @@ This is easily solved by adding the following @b{with} clauses at the beginning\n of our project:\n \n @smallexample @c projectfile\n-  with \"gtkada.gpr\";\n-  with \"a/b/logging.gpr\";\n-  project Build is\n-     ...  --  as before\n-  end Build;\n+  @b{with} \"gtkada.gpr\";\n+  @b{with} \"a/b/logging.gpr\";\n+  @b{project} Build @b{is}\n+     ...  --@i{  as before}\n+  @b{end} Build;\n @end smallexample\n \n @noindent\n@@ -1219,7 +1200,7 @@ project files rather than packages.\n Each literal string after @code{with} is the path\n (absolute or relative) to a project file. The @code{.gpr} extension is\n optional, although we recommend adding it. If no extension is specified,\n-and no project file with the @file{^.gpr^.GPR^} extension is found, then\n+and no project file with the @file{.gpr} extension is found, then\n the file is searched for exactly as written in the @code{with} clause,\n that is with no extension.\n \n@@ -1245,7 +1226,7 @@ the search stops:\n @cindex @code{GPR_PROJECT_PATH}\n @cindex @code{ADA_PROJECT_PATH}\n   Then it is searched relative to all the directories specified in the\n-  ^environment variables^logical names^ @b{GPR_PROJECT_PATH_FILE},\n+  environment variables @b{GPR_PROJECT_PATH_FILE},\n   @b{GPR_PROJECT_PATH} and @b{ADA_PROJECT_PATH} (in that order) if they exist.\n   The value of @b{GPR_PROJECT_PATH_FILE}, when defined, is the path name of\n   a text file that contains project directory path names, one per line.\n@@ -1371,11 +1352,11 @@ There are two main approaches to avoiding this duplication:\n   @smallexample @c projectfile\n   project Logging is\n      package Compiler is\n-        for ^Switches^Switches^ (\"Ada\")\n-            use (\"^-O2^-O2^\");\n+        for Switches (\"Ada\")\n+            use (\"-O2\");\n      end Compiler;\n      package Binder is\n-        for ^Switches^Switches^ (\"Ada\")\n+        for Switches (\"Ada\")\n             use (\"-E\");\n      end Binder;\n   end Logging;\n@@ -1384,7 +1365,7 @@ There are two main approaches to avoiding this duplication:\n   project Build is\n      package Compiler renames Logging.Compiler;\n      package Binder is\n-        for ^Switches^Switches^ (\"Ada\") use Logging.Binder'Switches (\"Ada\");\n+        for Switches (\"Ada\") use Logging.Binder'Switches (\"Ada\");\n      end Binder;\n   end Build;\n   @end smallexample\n@@ -1416,8 +1397,8 @@ There are two main approaches to avoiding this duplication:\n   abstract project Shared is\n      for Source_Files use ();   --  no sources\n      package Compiler is\n-        for ^Switches^Switches^ (\"Ada\")\n-            use (\"^-O2^-O2^\");\n+        for Switches (\"Ada\")\n+            use (\"-O2\");\n      end Compiler;\n   end Shared;\n \n@@ -1503,7 +1484,7 @@ information, when the second will focus on improving code optimization).\n \n Let's enhance our example to support a debug and a release modes.The issue is to\n let the user choose what kind of system he is building:\n-use @option{-g} as compiler switches in debug mode and @option{^-O2^-O2^}\n+use @option{-g} as compiler switches in debug mode and @option{-O2}\n in release mode. We will also setup the projects so that we do not share the\n same object directory in both modes, otherwise switching from one to the other\n might trigger more recompilations than needed or mix objects from the 2 modes.\n@@ -1532,10 +1513,10 @@ order of priority):\n    or  gnatmake -Pbuild.gpr -Xmode=release\n   @end smallexample\n \n-@item @b{^Environment variables^Logical names^}:\n+@item @b{Environment variables}:\n   When the external value does not come from the command line, it can come from\n-  the value of ^environment variables^logical names^ of the appropriate name.\n-  In our case, if ^an environment variable^a logical name^ called \"mode\"\n+  the value of environment variables of the appropriate name.\n+  In our case, if an environment variable called \"mode\"\n   exist, its value will be taken into account.\n \n @item @b{External function second parameter}\n@@ -1549,10 +1530,10 @@ the external. For instance, we could setup the object directory to point to\n either @file{obj/debug} or @file{obj/release} by changing our project to\n \n @smallexample @c projectfile\n-   project Build is\n-       for Object_Dir use \"obj/\" & external (\"mode\", \"debug\");\n-       ... --  as before\n-   end Build;\n+   @b{project} Build @b{is}\n+       @b{for} Object_Dir @b{use} \"obj/\" & @b{external} (\"mode\", \"debug\");\n+       ... --@i{  as before}\n+   @b{end} Build;\n @end smallexample\n \n @noindent\n@@ -1570,21 +1551,21 @@ Such a variable can then be used in a @b{case construction} and create condition\n sections in the project. The following example shows how this can be done:\n \n @smallexample @c projectfile\n-   project Build is\n-      type Mode_Type is (\"debug\", \"release\");  --  all possible values\n-      Mode : Mode_Type := external (\"mode\", \"debug\"); -- a typed variable\n-\n-      package Compiler is\n-         case Mode is\n-            when \"debug\" =>\n-               for ^Switches^Switches^ (\"Ada\")\n-                   use (\"-g\");\n-            when \"release\" =>\n-               for ^Switches^Switches^ (\"Ada\")\n-                   use (\"^-O2^-O2^\");\n-         end case;\n-      end Compiler;\n-   end Build;\n+   @b{project} Build @b{is}\n+      @b{type} Mode_Type @b{is} (\"debug\", \"release\");  --@i{  all possible values}\n+      Mode : Mode_Type := @b{external} (\"mode\", \"debug\"); --@i{ a typed variable}\n+\n+      @b{package} Compiler @b{is}\n+         @b{case} Mode @b{is}\n+            @b{when} \"debug\" =>\n+               @b{for} Switches (\"Ada\")\n+                   @b{use} (\"-g\");\n+            @b{when} \"release\" =>\n+               @b{for} Switches (\"Ada\")\n+                   @b{use} (\"-O2\");\n+         @b{end} @b{case};\n+      @b{end} Compiler;\n+   @b{end} Build;\n @end smallexample\n \n @noindent\n@@ -1684,11 +1665,11 @@ front of the @code{project} keyword.\n Here is the new version of @file{logging.gpr} that makes it a library:\n \n @smallexample @c projectfile\n-library project Logging is          --  \"library\" is optional\n-   for Library_Name use \"logging\";  --  will create \"liblogging.a\" on Unix\n-   for Object_Dir   use \"obj\";\n-   for Library_Dir  use \"lib\";      --  different from object_dir\n-end Logging;\n+library @b{project} Logging @b{is}          --@i{  \"library\" is optional}\n+   @b{for} Library_Name @b{use} \"logging\";  --@i{  will create \"liblogging.a\" on Unix}\n+   @b{for} Object_Dir   @b{use} \"obj\";\n+   @b{for} Library_Dir  @b{use} \"lib\";      --@i{  different from object_dir}\n+@b{end} Logging;\n @end smallexample\n \n @noindent\n@@ -1740,13 +1721,13 @@ Other library-related attributes can be used to change the defaults:\n \n @smallexample @c projectfile\n @group\n-  project Logging is\n+  @b{project} Logging @b{is}\n      Version := \"1\";\n-     for Library_Dir use \"lib\";\n-     for Library_Name use \"logging\";\n-     for Library_Kind use \"dynamic\";\n-     for Library_Version use \"liblogging.so.\" & Version;\n-  end Logging;\n+     @b{for} Library_Dir @b{use} \"lib\";\n+     @b{for} Library_Name @b{use} \"logging\";\n+     @b{for} Library_Kind @b{use} \"dynamic\";\n+     @b{for} Library_Version @b{use} \"liblogging.so.\" & Version;\n+  @b{end} Logging;\n @end group\n @end smallexample\n \n@@ -1840,21 +1821,20 @@ All @file{ALI} files will also be copied from the object directory to the\n library directory. To build executables, @command{gnatmake} will use the\n library rather than the individual object files.\n \n-@ifclear vms\n Library projects can also be useful to describe a library that need to be used\n but, for some reason, cannot be rebuilt. For instance, it is the case when some\n of the library sources are not available. Such library projects need simply to\n use the @code{Externally_Built} attribute as in the example below:\n \n @smallexample @c projectfile\n-library project Extern_Lib is\n-   for Languages    use (\"Ada\", \"C\");\n-   for Source_Dirs  use (\"lib_src\");\n-   for Library_Dir  use \"lib2\";\n-   for Library_Kind use \"dynamic\";\n-   for Library_Name use \"l2\";\n-   for Externally_Built use \"true\";  --  <<<<\n-end Extern_Lib;\n+library @b{project} Extern_Lib @b{is}\n+   @b{for} Languages    @b{use} (\"Ada\", \"C\");\n+   @b{for} Source_Dirs  @b{use} (\"lib_src\");\n+   @b{for} Library_Dir  @b{use} \"lib2\";\n+   @b{for} Library_Kind @b{use} \"dynamic\";\n+   @b{for} Library_Name @b{use} \"l2\";\n+   @b{for} Externally_Built @b{use} \"true\";  --@i{  <<<<}\n+@b{end} Extern_Lib;\n @end smallexample\n \n @noindent\n@@ -1874,7 +1854,6 @@ In such a situation, it is better to use the externally built library project\n so that all other subsystems depending on it can declare this dependency thanks\n to a project @code{with} clause, which in turn will trigger the builder to find\n the proper order of libraries in the final link command.\n-@end ifclear\n \n @c ---------------------------------------------\n @node Stand-alone Library Projects\n@@ -1914,9 +1893,9 @@ language and takes a list of sources as parameter.\n \n @smallexample @c projectfile\n @group\n-     for Library_Dir use \"lib\";\n-     for Library_Name use \"loggin\";\n-     for Library_Interface use (\"lib1\", \"lib2\");  --  unit names\n+     @b{for} Library_Dir @b{use} \"lib\";\n+     @b{for} Library_Name @b{use} \"loggin\";\n+     @b{for} Library_Interface @b{use} (\"lib1\", \"lib2\");  --@i{  unit names}\n @end group\n @end smallexample\n \n@@ -1944,19 +1923,19 @@ language and takes a list of sources as parameter.\n \n @smallexample @c projectfile\n @group\n-     for Library_Dir use \"lib\";\n-     for Library_Name use \"loggin\";\n-     for Library_Kind use \"dynamic\";\n-     for Library_Interface use (\"lib1\", \"lib2\");  --  unit names\n-     for Library_Standalone use \"encapsulated\";\n+     @b{for} Library_Dir @b{use} \"lib\";\n+     @b{for} Library_Name @b{use} \"loggin\";\n+     @b{for} Library_Kind @b{use} \"dynamic\";\n+     @b{for} Library_Interface @b{use} (\"lib1\", \"lib2\");  --@i{  unit names}\n+     @b{for} Library_Standalone @b{use} \"encapsulated\";\n @end group\n @end smallexample\n \n @end table\n \n In order to include the elaboration code in the stand-alone library, the binder\n is invoked on the closure of the library units creating a package whose name\n-depends on the library name (^b~logging.ads/b^B$LOGGING.ADS/B^ in the example).\n+depends on the library name (b~logging.ads/b in the example).\n This binder-generated package includes @b{initialization} and @b{finalization}\n procedures whose names depend on the library name (@code{logginginit} and\n @code{loggingfinal} in the example). The object corresponding to this package is\n@@ -2125,8 +2104,8 @@ ones is also possible. Here is an example on how to extend the project\n @code{Build} from previous examples:\n \n @smallexample @c projectfile\n-   project Work extends \"../bld/build.gpr\" is\n-   end Work;\n+   @b{project} Work @b{extends} \"../bld/build.gpr\" @b{is}\n+   @b{end} Work;\n @end smallexample\n \n @noindent\n@@ -2240,18 +2219,18 @@ create several extending projects:\n \n @noindent\n @smallexample @c projectfile\n-   project A_Ext extends \"a.gpr\" is\n-      for Source_Files use (\"a1.adb\", \"a1.ads\");\n-   end A_Ext;\n-\n-   with \"a_ext.gpr\";\n-   project B_Ext extends \"b.gpr\" is\n-   end B_Ext;\n-\n-   with \"b_ext.gpr\";\n-   project C_Ext extends \"c.gpr\" is\n-      for Source_Files use (\"c1.adb\");\n-   end C_Ext;\n+   @b{project} A_Ext @b{extends} \"a.gpr\" @b{is}\n+      @b{for} Source_Files @b{use} (\"a1.adb\", \"a1.ads\");\n+   @b{end} A_Ext;\n+\n+   @b{with} \"a_ext.gpr\";\n+   @b{project} B_Ext @b{extends} \"b.gpr\" @b{is}\n+   @b{end} B_Ext;\n+\n+   @b{with} \"b_ext.gpr\";\n+   @b{project} C_Ext @b{extends} \"c.gpr\" @b{is}\n+      @b{for} Source_Files @b{use} (\"c1.adb\");\n+   @b{end} C_Ext;\n @end smallexample\n \n @noindent\n@@ -2292,14 +2271,14 @@ Thus, in our example we could create the following projects instead:\n \n @noindent\n @smallexample @c projectfile\n-   project A_Ext extends \"a.gpr\" is\n-      for Source_Files use (\"a1.adb\", \"a1.ads\");\n-   end A_Ext;\n-\n-   with \"a_ext.gpr\";\n-   project C_Ext extends all \"c.gpr\" is\n-     for Source_Files use (\"c1.adb\");\n-   end C_Ext;\n+   @b{project} A_Ext @b{extends} \"a.gpr\" @b{is}\n+      @b{for} Source_Files @b{use} (\"a1.adb\", \"a1.ads\");\n+   @b{end} A_Ext;\n+\n+   @b{with} \"a_ext.gpr\";\n+   @b{project} C_Ext @b{extends} @b{all} \"c.gpr\" @b{is}\n+     @b{for} Source_Files @b{use} (\"c1.adb\");\n+   @b{end} C_Ext;\n @end smallexample\n \n @noindent\n@@ -2369,9 +2348,9 @@ and C. Then, when you build with\n this will build all mains from A, B and C.\n \n @smallexample @c projectfile\n-   aggregate project Agg is\n-      for Project_Files use (\"a.gpr\", \"b.gpr\", \"c.gpr\");\n-   end Agg;\n+   aggregate @b{project} Agg @b{is}\n+      @b{for} Project_Files @b{use} (\"a.gpr\", \"b.gpr\", \"c.gpr\");\n+   @b{end} Agg;\n @end smallexample\n \n If B or C do not define any main program (through their Main\n@@ -2442,41 +2421,41 @@ make sure all your user have a consistent environment when\n building. The syntax looks like\n \n @smallexample @c projectfile\n-   aggregate project Agg is\n-      for Project_Files use (\"A.gpr\", \"B.gpr\");\n-      for Project_Path use (\"../dir1\", \"../dir1/dir2\");\n-      for External (\"BUILD\") use \"PRODUCTION\";\n-\n-      package Builder is\n-         for ^Switches^Switches^ (\"Ada\") use (\"-q\");\n-      end Builder;\n-   end Agg;\n+   aggregate @b{project} Agg @b{is}\n+      @b{for} Project_Files @b{use} (\"A.gpr\", \"B.gpr\");\n+      @b{for} Project_Path @b{use} (\"../dir1\", \"../dir1/dir2\");\n+      @b{for} External (\"BUILD\") @b{use} \"PRODUCTION\";\n+\n+      @b{package} Builder @b{is}\n+         @b{for} Switches (\"Ada\") @b{use} (\"-q\");\n+      @b{end} Builder;\n+   @b{end} Agg;\n @end smallexample\n \n One of the often requested features in projects is to be able to\n reference external variables in @code{with} statements, as in\n \n @smallexample @c projectfile\n-  with external(\"SETUP\") & \"path/prj.gpr\";   --  ILLEGAL\n-  project MyProject is\n+  @b{with} @b{external}(\"SETUP\") & \"path/prj.gpr\";   --@i{  ILLEGAL}\n+  @b{project} MyProject @b{is}\n      ...\n-  end MyProject;\n+  @b{end} MyProject;\n @end smallexample\n \n For various reasons, this isn't authorized. But using aggregate\n projects provide an elegant solution. For instance, you could\n use a project file like:\n \n @smallexample @c projectfile\n-aggregate project Agg is\n-    for Project_Path use (external(\"SETUP\") & \"path\");\n-    for Project_Files use (\"myproject.gpr\");\n-end Agg;\n+aggregate @b{project} Agg @b{is}\n+    @b{for} Project_Path @b{use} (@b{external}(\"SETUP\") & \"path\");\n+    @b{for} Project_Files @b{use} (\"myproject.gpr\");\n+@b{end} Agg;\n \n-with \"prj.gpr\";  --  searched on Agg'Project_Path\n-project MyProject is\n+@b{with} \"prj.gpr\";  --@i{  searched on Agg'Project_Path}\n+@b{project} MyProject @b{is}\n    ...\n-end MyProject;\n+@b{end} MyProject;\n @end smallexample\n \n @c --------------------------------------------\n@@ -2586,11 +2565,11 @@ number of system calls that are needed.\n Here are a few valid examples:\n \n @smallexample @c projectfile\n-    for Project_Files use (\"a.gpr\", \"subdir/b.gpr\");\n-    --  two specific projects relative to the directory of agg.gpr\n+    @b{for} Project_Files @b{use} (\"a.gpr\", \"subdir/b.gpr\");\n+    --@i{  two specific projects relative to the directory of agg.gpr}\n \n-    for Project_Files use (\"**/*.gpr\");\n-    --  all projects recursively\n+    @b{for} Project_Files @b{use} (\"**/*.gpr\");\n+    --@i{  all projects recursively}\n @end smallexample\n \n @item @b{Project_Path}:\n@@ -2660,7 +2639,7 @@ Directories are relative to the location of the aggregate project file.\n Here are a few valid examples:\n \n @smallexample @c projectfile\n-   for Project_Path use (\"/usr/local/gpr\", \"gpr/\");\n+   @b{for} Project_Path @b{use} (\"/usr/local/gpr\", \"gpr/\");\n @end smallexample\n \n @item @b{External}:\n@@ -2718,8 +2697,8 @@ an aggregate project. In this package, only the following attributes\n are valid:\n \n @table @asis\n-@item @b{^Switches^Switches^}:\n-@cindex @code{^Switches^Switches^}\n+@item @b{Switches}:\n+@cindex @code{Switches}\n This attribute gives the list of switches to use for @command{gprbuild}.\n Because no mains can be specified for aggregate projects, the only possible\n index for attribute @code{Switches} is @code{others}. All other indexes will\n@@ -2728,7 +2707,7 @@ be ignored.\n Example:\n \n @smallexample @c projectfile\n-for ^Switches^Switches^ (others) use (\"-v\", \"-k\", \"-j8\");\n+@b{for} Switches (@b{others}) @b{use} (\"-v\", \"-k\", \"-j8\");\n @end smallexample\n \n These switches are only read from the main aggregate project (the\n@@ -2744,8 +2723,8 @@ This attribute gives the list of compiler switches for the various\n languages. For instance,\n \n @smallexample @c projectfile\n-for Global_Compilation_Switches (\"Ada\") use (\"^O1^-O1^\", \"-g\");\n-for Global_Compilation_Switches (\"C\")   use (\"^-O2^-O2^\");\n+@b{for} Global_Compilation_Switches (\"Ada\") @b{use} (\"O1\", \"-g\");\n+@b{for} Global_Compilation_Switches (\"C\")   @b{use} (\"-O2\");\n @end smallexample\n \n This attribute is only taken into account in the aggregate project\n@@ -2764,57 +2743,57 @@ instance, aggregate project Agg groups the projects A and B, that\n both depend on C. Here is an extra for all of these projects:\n \n @smallexample @c projectfile\n-      aggregate project Agg is\n-          for Project_Files use (\"a.gpr\", \"b.gpr\");\n-          package Builder is\n-             for Global_Compilation_Switches (\"Ada\") use (\"^-O2^-O2^\");\n-          end Builder;\n-      end Agg;\n-\n-      with \"c.gpr\";\n-      project A is\n-          package Builder is\n-             for Global_Compilation_Switches (\"Ada\") use (\"^-O1^-O1^\");\n-             --  ignored\n-          end Builder;\n-\n-          package Compiler is\n-             for Default_Switches (\"Ada\")\n-                 use (\"^-O1^-O1^\", \"-g\");\n-             for ^Switches^Switches^ (\"a_file1.adb\")\n-                 use (\"^-O0^-O0^\");\n-          end Compiler;\n-      end A;\n-\n-      with \"c.gpr\";\n-      project B is\n-          package Compiler is\n-             for Default_Switches (\"Ada\") use (\"^-O0^-O0^\");\n-          end Compiler;\n-      end B;\n-\n-      project C is\n-          package Compiler is\n-             for Default_Switches (\"Ada\")\n-                 use (\"^-O3^-O3^\",\n-                      \"^-gnatn^-gnatn^\");\n-             for ^Switches^Switches^ (\"c_file1.adb\")\n-                 use (\"^-O0^-O0^\", \"-g\");\n-          end Compiler;\n-      end C;\n+      aggregate @b{project} Agg @b{is}\n+          @b{for} Project_Files @b{use} (\"a.gpr\", \"b.gpr\");\n+          @b{package} Builder @b{is}\n+             @b{for} Global_Compilation_Switches (\"Ada\") @b{use} (\"-O2\");\n+          @b{end} Builder;\n+      @b{end} Agg;\n+\n+      @b{with} \"c.gpr\";\n+      @b{project} A @b{is}\n+          @b{package} Builder @b{is}\n+             @b{for} Global_Compilation_Switches (\"Ada\") @b{use} (\"-O1\");\n+             --@i{  ignored}\n+          @b{end} Builder;\n+\n+          @b{package} Compiler @b{is}\n+             @b{for} Default_Switches (\"Ada\")\n+                 @b{use} (\"-O1\", \"-g\");\n+             @b{for} Switches (\"a_file1.adb\")\n+                 @b{use} (\"-O0\");\n+          @b{end} Compiler;\n+      @b{end} A;\n+\n+      @b{with} \"c.gpr\";\n+      @b{project} B @b{is}\n+          @b{package} Compiler @b{is}\n+             @b{for} Default_Switches (\"Ada\") @b{use} (\"-O0\");\n+          @b{end} Compiler;\n+      @b{end} B;\n+\n+      @b{project} C @b{is}\n+          @b{package} Compiler @b{is}\n+             @b{for} Default_Switches (\"Ada\")\n+                 @b{use} (\"-O3\",\n+                      \"-gnatn\");\n+             @b{for} Switches (\"c_file1.adb\")\n+                 @b{use} (\"-O0\", \"-g\");\n+          @b{end} Compiler;\n+      @b{end} C;\n @end smallexample\n \n then the following switches are used:\n \n @itemize @bullet\n @item all files from project A except a_file1.adb are compiled\n-      with \"^-O2^-O2^ -g\", since the aggregate project has priority.\n+      with \"-O2 -g\", since the aggregate project has priority.\n @item the file a_file1.adb is compiled with\n-      \"^-O0^-O0^\", since the Compiler.Switches has priority\n+      \"-O0\", since the Compiler.Switches has priority\n @item all files from project B are compiled with\n-      \"^-O2^-O2^\", since the aggregate project has priority\n-@item all files from C are compiled with \"^-O2^-O2^ -gnatn\", except for\n-      c_file1.adb which is compiled with \"^-O0^-O0^ -g\"\n+      \"-O2\", since the aggregate project has priority\n+@item all files from C are compiled with \"-O2 -gnatn\", except for\n+      c_file1.adb which is compiled with \"-O0 -g\"\n @end itemize\n \n Even though C is seen through two paths (through A and through\n@@ -2875,11 +2854,11 @@ For example, we can define an aggregate project Agg that groups A, B\n and C:\n \n @smallexample @c projectfile\n-   aggregate library project Agg is\n-      for Project_Files use (\"a.gpr\", \"b.gpr\", \"c.gpr\");\n-      for Library_Name use (\"agg\");\n-      for Library_Dir use (\"lagg\");\n-   end Agg;\n+   aggregate library @b{project} Agg @b{is}\n+      @b{for} Project_Files @b{use} (\"a.gpr\", \"b.gpr\", \"c.gpr\");\n+      @b{for} Library_Name @b{use} (\"agg\");\n+      @b{for} Library_Dir @b{use} (\"lagg\");\n+   @b{end} Agg;\n @end smallexample\n \n Then, when you build with:\n@@ -2899,16 +2878,16 @@ required to create relocatable object files, a Builder package in the\n aggregate library project may be used:\n \n @smallexample @c projectfile\n-   aggregate library project Agg is\n-      for Project_Files use (\"a.gpr\", \"b.gpr\", \"c.gpr\");\n-      for Library_Name use (\"agg\");\n-      for Library_Dir use (\"lagg\");\n-      for Library_Kind use \"relocatable\";\n-\n-      package Builder is\n-         for Global_Compilation_Switches (\"Ada\") use (\"-fPIC\");\n-      end Builder;\n-   end Agg;\n+   aggregate library @b{project} Agg @b{is}\n+      @b{for} Project_Files @b{use} (\"a.gpr\", \"b.gpr\", \"c.gpr\");\n+      @b{for} Library_Name @b{use} (\"agg\");\n+      @b{for} Library_Dir @b{use} (\"lagg\");\n+      @b{for} Library_Kind @b{use} \"relocatable\";\n+\n+      @b{package} Builder @b{is}\n+         @b{for} Global_Compilation_Switches (\"Ada\") @b{use} (\"-fPIC\");\n+      @b{end} Builder;\n+   @b{end} Agg;\n @end smallexample\n \n With the above aggregate library Builder package, the @code{-fPIC}\n@@ -2991,8 +2970,8 @@ Project files have an Ada-like syntax. The minimal project file is:\n \n @smallexample @c projectfile\n @group\n-project Empty is\n-end Empty;\n+@b{project} Empty @b{is}\n+@b{end} Empty;\n @end group\n @end smallexample\n \n@@ -3059,9 +3038,9 @@ in the cycle is a @b{limited with}.\n @c ??? Need more details here\n \n @smallexample @c projectfile\n-with \"other_project.gpr\";\n-project My_Project extends \"extended.gpr\" is\n-end My_Project;\n+@b{with} \"other_project.gpr\";\n+@b{project} My_Project @b{extends} \"extended.gpr\" @b{is}\n+@b{end} My_Project;\n @end smallexample\n \n @noindent\n@@ -3196,28 +3175,28 @@ The following packages are currently supported in project files\n @item Cross_Reference\n   This package specifies the options used when calling the library tool\n   @command{gnatxref} via the @command{gnat} driver. Its attributes\n-  @b{Default_Switches} and @b{^Switches^Switches^} have the same semantics as for the\n+  @b{Default_Switches} and @b{Switches} have the same semantics as for the\n   package @code{Builder}.\n @ifclear FSFEDITION\n @item Eliminate\n   This package specifies the options used when calling the tool\n   @command{gnatelim} via the @command{gnat} driver. Its attributes\n-  @b{Default_Switches} and @b{^Switches^Switches^} have the same semantics as for the\n+  @b{Default_Switches} and @b{Switches} have the same semantics as for the\n   package @code{Builder}.\n @end ifclear\n @item Finder\n   This package specifies the options used when calling the search tool\n   @command{gnatfind} via the @command{gnat} driver. Its attributes\n-  @b{Default_Switches} and @b{^Switches^Switches^} have the same semantics as for the\n+  @b{Default_Switches} and @b{Switches} have the same semantics as for the\n   package @code{Builder}.\n-@item ^Gnatls^Gnatls^\n+@item Gnatls\n   This package specifies the options to use when invoking @command{gnatls}\n   via the @command{gnat} driver.\n @ifclear FSFEDITION\n-@item ^Gnatstub^Gnatstub^\n+@item Gnatstub\n   This package specifies the options used when calling the tool\n   @command{gnatstub} via the @command{gnat} driver. Its attributes\n-  @b{Default_Switches} and @b{^Switches^Switches^} have the same semantics as for the\n+  @b{Default_Switches} and @b{Switches} have the same semantics as for the\n   package @code{Builder}.\n @end ifclear\n @item IDE\n@@ -3233,7 +3212,7 @@ The following packages are currently supported in project files\n @item Metrics\n   This package specifies the options used when calling the tool\n   @command{gnatmetric} via the @command{gnat} driver. Its attributes\n-  @b{Default_Switches} and @b{^Switches^Switches^} have the same semantics as for the\n+  @b{Default_Switches} and @b{Switches} have the same semantics as for the\n   package @code{Builder}.\n @end ifclear\n @item Naming\n@@ -3246,7 +3225,7 @@ The following packages are currently supported in project files\n @item Pretty_Printer\n   This package specifies the options used when calling the formatting tool\n   @command{gnatpp} via the @command{gnat} driver. Its attributes\n-  @b{Default_Switches} and @b{^Switches^Switches^} have the same semantics as for the\n+  @b{Default_Switches} and @b{Switches} have the same semantics as for the\n   package @code{Builder}.\n @end ifclear\n @item Remote\n@@ -3255,7 +3234,7 @@ The following packages are currently supported in project files\n @item Stack\n   This package specifies the options used when calling the tool\n   @command{gnatstack} via the @command{gnat} driver. Its attributes\n-  @b{Default_Switches} and @b{^Switches^Switches^} have the same semantics as for the\n+  @b{Default_Switches} and @b{Switches} have the same semantics as for the\n   package @code{Builder}.\n @item Synchronize\n   This package specifies the options used when calling the tool\n@@ -3267,10 +3246,10 @@ In its simplest form, a package may be empty:\n \n @smallexample @c projectfile\n @group\n-project Simple is\n-  package Builder is\n-  end Builder;\n-end Simple;\n+@b{project} Simple @b{is}\n+  @b{package} Builder @b{is}\n+  @b{end} Builder;\n+@b{end} Simple;\n @end group\n @end smallexample\n \n@@ -3376,20 +3355,20 @@ strings is involved, the result of the concatenation is a list of strings. The\n following Ada declarations show the existing operators:\n \n @smallexample @c ada\n-  function \"&\" (X : String;      Y : String)      return String;\n-  function \"&\" (X : String_List; Y : String)      return String_List;\n-  function \"&\" (X : String_List; Y : String_List) return String_List;\n+  @b{function} \"&\" (X : String;      Y : String)      @b{return} String;\n+  @b{function} \"&\" (X : String_List; Y : String)      @b{return} String_List;\n+  @b{function} \"&\" (X : String_List; Y : String_List) @b{return} String_List;\n @end smallexample\n \n @noindent\n Here are some specific examples:\n \n @smallexample @c projectfile\n @group\n-   List := () & File_Name; --  One string in this list\n-   List2 := List & (File_Name & \".orig\"); -- Two strings\n-   Big_List := List & Lists2;  --  Three strings\n-   Illegal := \"gnat.adc\" & List2;  --  Illegal, must start with list\n+   List := () & File_Name; --@i{  One string in this list}\n+   List2 := List & (File_Name & \".orig\"); --@i{ Two strings}\n+   Big_List := List & Lists2;  --@i{  Three strings}\n+   Illegal := \"gnat.adc\" & List2;  --@i{  Illegal, must start with list}\n @end group\n @end smallexample\n \n@@ -3419,9 +3398,9 @@ if present, is the default to use if there is no specification for this\n external value either on the command line or in the environment.\n \n Typically, the external value will either exist in the\n-^environment variables^logical name^\n+environment variables\n or be specified on the command line through the\n-@option{^-X^/EXTERNAL_REFERENCE=^@emph{vbl}=@emph{value}} switch. If both\n+@option{-X@emph{vbl}=@emph{value}} switch. If both\n are specified, then the command line value is used, so that a user can more\n easily override the value.\n \n@@ -3464,14 +3443,14 @@ last separator and the end are components of the string list.\n @end smallexample\n \n @noindent\n-If the external value is \"^-O2^-O2^,-g\",\n-the result is (\"^-O2^-O2^\", \"-g\").\n+If the external value is \"-O2,-g\",\n+the result is (\"-O2\", \"-g\").\n \n-If the external value is \",^-O2^-O2^,-g,\",\n-the result is also (\"^-O2^-O2^\", \"-g\").\n+If the external value is \",-O2,-g,\",\n+the result is also (\"-O2\", \"-g\").\n \n-if the external value is \"^-gnatv^-gnatv^\",\n-the result is (\"^-gnatv^-gnatv^\").\n+if the external value is \"-gnatv\",\n+the result is (\"-gnatv\").\n \n If the external value is \",,\", the result is (\"\").\n \n@@ -3500,7 +3479,7 @@ They may include any graphic characters allowed in Ada, including spaces.\n Here is an example of a string type declaration:\n \n @smallexample @c projectfile\n-   type OS is (\"NT\", \"nt\", \"Unix\", \"GNU/Linux\", \"other OS\");\n+   @b{type} OS @b{is} (\"NT\", \"nt\", \"Unix\", \"GNU/Linux\", \"other OS\");\n @end smallexample\n \n @noindent\n@@ -3555,8 +3534,8 @@ Here are some examples of variable declarations:\n \n @smallexample @c projectfile\n @group\n-   This_OS : OS := external (\"OS\"); --  a typed variable declaration\n-   That_OS := \"GNU/Linux\";          --  an untyped variable declaration\n+   This_OS : OS := @b{external} (\"OS\"); --@i{  a typed variable declaration}\n+   That_OS := \"GNU/Linux\";          --@i{  an untyped variable declaration}\n \n    Name      := \"readme.txt\";\n    Save_Name := Name & \".saved\";\n@@ -3641,23 +3620,23 @@ Here is a typical example:\n \n @smallexample @c projectfile\n @group\n-project MyProj is\n-   type OS_Type is (\"GNU/Linux\", \"Unix\", \"NT\", \"VMS\");\n-   OS : OS_Type := external (\"OS\", \"GNU/Linux\");\n-\n-   package Compiler is\n-     case OS is\n-       when \"GNU/Linux\" | \"Unix\" =>\n-         for ^Switches^Switches^ (\"Ada\")\n-             use (\"-gnath\");\n-       when \"NT\" =>\n-         for ^Switches^Switches^ (\"Ada\")\n-             use (\"^-gnatP^-gnatP^\");\n-       when others =>\n-         null;\n-     end case;\n-   end Compiler;\n-end MyProj;\n+@b{project} MyProj @b{is}\n+   @b{type} OS_Type @b{is} (\"GNU/Linux\", \"Unix\", \"NT\", \"VMS\");\n+   OS : OS_Type := @b{external} (\"OS\", \"GNU/Linux\");\n+\n+   @b{package} Compiler @b{is}\n+     @b{case} OS @b{is}\n+       @b{when} \"GNU/Linux\" | \"Unix\" =>\n+         @b{for} Switches (\"Ada\")\n+             @b{use} (\"-gnath\");\n+       @b{when} \"NT\" =>\n+         @b{for} Switches (\"Ada\")\n+             @b{use} (\"-gnatP\");\n+       @b{when} @b{others} =>\n+         @b{null};\n+     @b{end} @b{case};\n+   @b{end} Compiler;\n+@b{end} MyProj;\n @end group\n @end smallexample\n \n@@ -3680,9 +3659,9 @@ end MyProj;\n * Package Eliminate Attributes::\n @end ifclear\n * Package Finder Attributes::\n-* Package ^gnatls^gnatls^ Attributes::\n+* Package gnatls Attributes::\n @ifclear FSFEDITION\n-* Package ^gnatstub^gnatstub^ Attributes::\n+* Package gnatstub Attributes::\n @end ifclear\n * Package IDE Attributes::\n * Package Install Attributes::\n@@ -3735,20 +3714,20 @@ attribute, and replaces the previous setting.\n Here are some examples of attribute declarations:\n \n @smallexample @c projectfile\n-   --  simple attributes\n-   for Object_Dir use \"objects\";\n-   for Source_Dirs use (\"units\", \"test/drivers\");\n-\n-   --  indexed attributes\n-   for Body (\"main\") use \"Main.ada\";\n-   for ^Switches^Switches^ (\"main.ada\")\n-       use (\"-v\", \"^-gnatv^-gnatv^\");\n-   for ^Switches^Switches^ (\"main.ada\") use Builder'Switches (\"main.ada\") & \"-g\";\n-\n-   --  indexed attributes copy (from package Builder in project Default)\n-   --  The package name must always be specified, even if it is the current\n-   --  package.\n-   for Default_Switches use Default.Builder'Default_Switches;\n+   --@i{  simple attributes}\n+   @b{for} Object_Dir @b{use} \"objects\";\n+   @b{for} Source_Dirs @b{use} (\"units\", \"test/drivers\");\n+\n+   --@i{  indexed attributes}\n+   @b{for} Body (\"main\") @b{use} \"Main.ada\";\n+   @b{for} Switches (\"main.ada\")\n+       @b{use} (\"-v\", \"-gnatv\");\n+   @b{for} Switches (\"main.ada\") @b{use} Builder'Switches (\"main.ada\") & \"-g\";\n+\n+   --@i{  indexed attributes copy (from package Builder in project Default)}\n+   --@i{  The package name must always be specified, even if it is the current}\n+   --@i{  package.}\n+   @b{for} Default_Switches @b{use} Default.Builder'Default_Switches;\n @end smallexample\n \n @noindent\n@@ -3769,7 +3748,7 @@ attribute_prefix ::= @i{project}\n Examples are:\n \n @smallexample @c projectfile\n-  project'Object_Dir\n+  @b{project}'Object_Dir\n   Naming'Dot_Replacement\n   Imported_Project'Source_Dirs\n   Imported_Project.Naming'Casing\n@@ -4248,9 +4227,9 @@ sources of runtime libraries are located.\n @item @b{Default_Switches}: list, indexed, case-insensitive index\n \n Index is a language name. Value is the list of switches to be used when binding\n-code of the language, if there is no applicable attribute ^Switches^Switches^.\n+code of the language, if there is no applicable attribute Switches.\n \n-@item @b{^Switches^Switches^}: list, optional index, indexed,\n+@item @b{Switches}: list, optional index, indexed,\n                     case-insensitive index, others allowed\n \n Index is either a language name or a source file name. Value is the list of\n@@ -4305,7 +4284,7 @@ Index is a language name. Value is the list of builder switches to be used when\n building an executable of the language, if there is no applicable attribute\n Switches.\n \n-@item @b{^Switches^Switches^}: list, optional index, indexed, case-insensitive index,\n+@item @b{Switches}: list, optional index, indexed, case-insensitive index,\n                     others allowed\n \n Index is either a language name or a source file name. Value is the list of\n@@ -4352,9 +4331,9 @@ project tree.\n \n Index is a language name. Value is a list of switches to be used when invoking\n @code{gnatcheck} for a source of the language, if there is no applicable\n-attribute ^Switches^Switches^.\n+attribute Switches.\n \n-@item @b{^Switches^Switches^}: list, optional index, indexed, case-insensitive index,\n+@item @b{Switches}: list, optional index, indexed, case-insensitive index,\n                     others allowed\n \n Index is a source file name. Value is the list of switches to be used when\n@@ -4368,7 +4347,7 @@ invoking @code{gnatcheck} for the source.\n \n @itemize @bullet\n \n-@item @b{^Switches^Switches^}: list\n+@item @b{Switches}: list\n \n Value is a list of switches to be used by the cleaning application.\n \n@@ -4411,7 +4390,7 @@ Index is a language name. Value is a list of switches to be used when invoking\n the compiler for the language for a source of the project, if there is no\n applicable attribute Switches.\n \n-@item @b{^Switches^Switches^}: list, optional index, indexed, case-insensitive index,\n+@item @b{Switches}: list, optional index, indexed, case-insensitive index,\n                     others allowed\n \n Index is a source file name or a language name. Value is the list of switches\n@@ -4645,7 +4624,7 @@ Index is a language name. Value is a list of switches to be used when invoking\n @code{gnatxref} for a source of the language, if there is no applicable\n attribute Switches.\n \n-@item @b{^Switches^Switches^}: list, optional index, indexed, case-insensitive index,\n+@item @b{Switches}: list, optional index, indexed, case-insensitive index,\n                     others allowed\n \n Index is a source file name. Value is the list of switches to be used when\n@@ -4665,7 +4644,7 @@ Index is a language name. Value is a list of switches to be used when invoking\n @code{gnatelim} for a source of the language, if there is no applicable\n attribute Switches.\n \n-@item @b{^Switches^Switches^}: list, optional index, indexed, case-insensitive index,\n+@item @b{Switches}: list, optional index, indexed, case-insensitive index,\n                     others allowed\n \n Index is a source file name. Value is the list of switches to be used when\n@@ -4685,38 +4664,38 @@ Index is a language name. Value is a list of switches to be used when invoking\n @code{gnatfind} for a source of the language, if there is no applicable\n attribute Switches.\n \n-@item @b{^Switches^Switches^}: list, optional index, indexed, case-insensitive index,\n+@item @b{Switches}: list, optional index, indexed, case-insensitive index,\n                     others allowed\n \n Index is a source file name. Value is the list of switches to be used when\n invoking @code{gnatfind} for the source.\n \n @end itemize\n \n-@node Package ^gnatls^gnatls^ Attributes\n-@subsubsection Package ^gnatls^gnatls^ Attributes\n+@node Package gnatls Attributes\n+@subsubsection Package gnatls Attributes\n \n @itemize @bullet\n \n-@item @b{^Switches^Switches^}: list\n+@item @b{Switches}: list\n \n Value is a list of switches to be used when invoking @code{gnatls}.\n \n @end itemize\n \n @ifclear FSFEDITION\n-@node Package ^gnatstub^gnatstub^ Attributes\n-@subsubsection Package ^gnatstub^gnatstub^ Attributes\n+@node Package gnatstub Attributes\n+@subsubsection Package gnatstub Attributes\n \n @itemize @bullet\n \n @item @b{Default_Switches}: list, indexed, case-insensitive index\n \n Index is a language name. Value is a list of switches to be used when invoking\n @code{gnatstub} for a source of the language, if there is no applicable\n-attribute ^Switches^Switches^.\n+attribute Switches.\n \n-@item @b{^Switches^Switches^}: list, optional index, indexed, case-insensitive index,\n+@item @b{Switches}: list, optional index, indexed, case-insensitive index,\n                     others allowed\n \n Index is a source file name. Value is the list of switches to be used when\n@@ -4764,11 +4743,11 @@ the handling of switches.\n Value is a string that specifies the name of the debugger to be used, such as\n gdb, powerpc-wrs-vxworks-gdb or gdb-4.\n \n-@item @b{^gnatlist^gnatlist^}: single\n+@item @b{gnatlist}: single\n \n-Value is a string that specifies the name of the @command{^gnatls^gnatls^} utility\n+Value is a string that specifies the name of the @command{gnatls} utility\n to be used to retrieve information about the predefined path; for example,\n-@code{\"^gnatls^gnatls^\"}, @code{\"powerpc-wrs-vxworks-gnatls\"}.\n+@code{\"gnatls\"}, @code{\"powerpc-wrs-vxworks-gnatls\"}.\n \n @item @b{VCS_Kind}: single\n \n@@ -4854,7 +4833,7 @@ Index is a source file name or a language name. Value is the list of switches\n to be used at the beginning of the command line when invoking the linker to\n build an executable for the source or for its language.\n \n-@item @b{^Switches^Switches^}: list, optional index, indexed, case-insensitive index,\n+@item @b{Switches}: list, optional index, indexed, case-insensitive index,\n                     others allowed\n \n Index is a source file name or a language name. Value is the list of switches\n@@ -4928,7 +4907,7 @@ Index is a language name. Value is a list of switches to be used when invoking\n @code{gnatmetric} for a source of the language, if there is no applicable\n attribute Switches.\n \n-@item @b{^Switches^Switches^}: list, optional index, indexed, case-insensitive index,\n+@item @b{Switches}: list, optional index, indexed, case-insensitive index,\n                     others allowed\n \n Index is a source file name. Value is the list of switches to be used when\n@@ -5018,7 +4997,7 @@ Index is a language name. Value is a list of switches to be used when invoking\n @code{gnatpp} for a source of the language, if there is no applicable\n attribute Switches.\n \n-@item @b{^Switches^Switches^}: list, optional index, indexed, case-insensitive index,\n+@item @b{Switches}: list, optional index, indexed, case-insensitive index,\n                     others allowed\n \n Index is a source file name. Value is the list of switches to be used when\n@@ -5063,7 +5042,7 @@ Value is the root directory used by the slave machines.\n \n @itemize @bullet\n \n-@item @b{^Switches^Switches^}: list\n+@item @b{Switches}: list\n \n Value is the list of switches to be used when invoking @code{gnatstack}.\n \n@@ -5080,11 +5059,10 @@ Index is a language name. Value is a list of switches to be used when invoking\n @code{gnatsync} for a source of the language, if there is no applicable\n attribute Switches.\n \n-@item @b{^Switches^Switches^}: list, optional index, indexed, case-insensitive index,\n+@item @b{Switches}: list, optional index, indexed, case-insensitive index,\n                     others allowed\n \n Index is a source file name. Value is the list of switches to be used when\n invoking @code{gnatsync} for the source.\n \n @end itemize\n-"}, {"sha": "496ebb3c289b61d4527e2e30ae84665ffdfa0515", "filename": "gcc/ada/xgnatugn.adb", "status": "modified", "additions": 20, "deletions": 1051, "changes": 1071, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77cfab2813d0921344f74c219ec3e4a173aa3f1/gcc%2Fada%2Fxgnatugn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77cfab2813d0921344f74c219ec3e4a173aa3f1/gcc%2Fada%2Fxgnatugn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxgnatugn.adb?ref=d77cfab2813d0921344f74c219ec3e4a173aa3f1", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2003-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2003-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -20,1067 +20,36 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This utility is used to process the source of gnat_ugn.texi to make a\n---  version suitable for running through standard Texinfo processor. It is\n---  invoked as follows:\n+--  This is a temporary version whose only purpose is to work with\n+--  Makefile.gnat6\n+--  Its main previous purpose (to handle VMS-specific wording in\n+--  gnat_ugn.texi and projects.texi) is not applicable, since there is\n+--  no longer a VMS-specific version of the User's Guide.\n \n---  xgnatugn <target> <in-file> <word-list> [ <out-file> [ <warnings> ] ]\n+--  The program is invoked as follows:\n \n---  1. <target> is the target type of the manual, which is one of:\n+--  xgnatugn <target> <in-file> <word-list> <out-file>\n \n---     unw       Unix and Windows platforms\n---     vms       OpenVMS\n-\n---  2. <in-file> is the file name of the Texinfo file to be\n---  preprocessed.\n-\n---  3. <word-list> is the name of the word list file. This file is used for\n---  rewriting the VMS edition. Each line contains a word mapping: The source\n---  word in the first column, the target word in the second column. The\n---  columns are separated by a '^' character. When preprocessing for VMS, the\n---  first word is replaced with the second. (Words consist of letters,\n---  digits, and the four characters \"?-_~\". A sequence of multiple words can\n---  be replaced if they are listed in the first column, separated by a single\n---  space character. If multiple words are to be replaced, there must be a\n---  replacement for each prefix.)\n-\n---  4. <out-file> (optional) is the name of the output file. It defaults to\n---  gnat_ugn_unw.texi or gnat_ugn_vms.texi, depending on the target.\n-\n---  5. <warnings> (optional, and allowed only if <out-file> is explicit)\n---  can be any string. If present, it indicates that warning messages are\n---  to be output to Standard_Error. If absent, no warning messages are\n---  generated.\n-\n---  The following steps are performed:\n-\n---     In VMS mode\n-\n---       Any occurrences of ^alpha^beta^ are replaced by beta. The sequence\n---       must fit on a single line, and there can only be one occurrence on a\n---       line.\n-\n---       Any occurrences of a word in the Ug_Words list are replaced by the\n---       appropriate vms equivalents. Note that replacements do not occur\n---       within ^alpha^beta^ sequences.\n-\n---       Any occurrence of [filename].extension, where extension one of the\n---       following:\n-\n---           \"o\", \"ads\", \"adb\", \"ali\", \"ada\", \"atb\", \"ats\", \"adc\", \"c\"\n-\n---       replaced by the appropriate VMS names (all upper case with .o\n---       replaced .OBJ). Note that replacements do not occur within\n---       ^alpha^beta^ sequences.\n-\n---     In UNW mode\n-\n---       Any occurrences of ^alpha^beta^ are replaced by alpha. The sequence\n---       must fit on a single line.\n-\n---     In both modes\n-\n---       The sequence ^^^ is replaced by a single ^. This escape sequence\n---       must be used if the literal character ^ is to appear in the\n---       output. A line containing this escape sequence may not also contain\n---       a ^alpha^beta^ sequence.\n+--  In this temporary version, the program simply copies <in-file>\n+--  to <out-file> and ignores the <target> and <word-list> arguments\n \n with Ada.Command_Line;           use Ada.Command_Line;\n-with Ada.Strings;                use Ada.Strings;\n-with Ada.Strings.Fixed;          use Ada.Strings.Fixed;\n-with Ada.Strings.Unbounded;      use Ada.Strings.Unbounded;\n-with Ada.Strings.Maps;           use Ada.Strings.Maps;\n-with Ada.Strings.Maps.Constants; use Ada.Strings.Maps.Constants;\n-with Ada.Streams.Stream_IO;      use Ada.Streams.Stream_IO;\n with Ada.Text_IO;                use Ada.Text_IO;\n \n-with GNAT.Spitbol;               use GNAT.Spitbol;\n-with GNAT.Spitbol.Table_VString; use GNAT.Spitbol.Table_VString;\n-\n procedure Xgnatugn is\n \n-   procedure Usage;\n-   --  Print usage information. Invoked if an invalid command line is\n-   --  encountered.\n-\n-   subtype Sfile is Ada.Streams.Stream_IO.File_Type;\n-\n-   Output_File : Sfile;\n-   --  The preprocessed output is written to this file\n-\n-   type Input_File is record\n-      Name : VString;\n-      Data : Ada.Text_IO.File_Type;\n-      Line : Natural := 0;\n-   end record;\n-   --  Records information on an input file. Name and Line are used\n-   --  in error messages, Line is updated automatically by Get_Line.\n-\n-   function Get_Line (Input : access Input_File) return String;\n-   --  Returns a line from Input and performs the necessary\n-   --  line-oriented checks (length, character set, trailing spaces).\n-\n-   procedure Put_Line (F : Sfile; S : String);\n-   --  Local version of Put_Line ensures Unix style line endings\n-\n-   First_Time         : Boolean := True;\n-   Number_Of_Warnings : Natural := 0;\n-   Number_Of_Errors   : Natural := 0;\n-   Warnings_Enabled   : Boolean;\n-\n-   procedure Error\n-     (Input        : Input_File;\n-      At_Character : Natural;\n-      Message      : String);\n-   procedure Error\n-     (Input        : Input_File;\n-      Message      : String);\n-   --  Prints a message reporting an error on line Input.Line. If\n-   --  At_Character is not 0, indicate the exact character at which\n-   --  the error occurs.\n-\n-   procedure Warning\n-     (Input        : Input_File;\n-      At_Character : Natural;\n-      Message      : String);\n-\n-   Dictionary_File : aliased Input_File;\n-   procedure Read_Dictionary_File;\n-   --  Dictionary_File is opened using the name given on the command\n-   --  line. It contains the replacements for the Ug_Words list.\n-   --  Read_Dictionary_File reads Dictionary_File and fills the\n-   --  Ug_Words table.\n-\n-   Source_File : aliased Input_File;\n-   procedure Process_Source_File;\n-   --  Source_File is opened using the name given on the command line.\n-   --  It contains the Texinfo source code. Process_Source_File\n-   --  performs the necessary replacements.\n-\n-   type Flag_Type is (UNW, VMS, FSFEDITION, PROEDITION, GPLEDITION);\n-   --  The flags permitted in @ifset or @ifclear commands:\n-   --\n-   --  Targets for preprocessing\n-   --    UNW (Unix and Windows) or VMS\n-   --\n-   --  Editions of the manual\n-   --    FSFEDITION, PROEDITION, or GPLEDITION\n-   --\n-   --  Conditional commands for target are processed by xgnatugn\n-   --\n-   --  Conditional commands for edition are passed through unchanged\n-\n-   subtype Target_Type is Flag_Type range UNW .. VMS;\n-\n-   Target : Target_Type;\n-   --  The Target variable is initialized using the command line\n-\n-   Valid_Characters : constant Character_Set := To_Set (Span => (' ',  '~'));\n-   --  This array controls which characters are permitted in the input\n-   --  file (after line breaks have been removed). Valid characters\n-   --  are all printable ASCII characters and the space character.\n-\n-   Word_Characters : constant Character_Set :=\n-                       (To_Set (Ranges =>\n-                                  (('0', '9'), ('a', 'z'), ('A', 'Z')))\n-                         or To_Set (\"?-_~\"));\n-   --  The characters which are permitted in words. Other (valid)\n-   --  characters are assumed to be delimiters between words. Note that\n-   --  this set has to include all characters of the source words of the\n-   --  Ug_Words dictionary.\n-\n-   Reject_Trailing_Spaces : constant Boolean := True;\n-   --  Controls whether Xgnatug rejects superfluous space characters\n-   --  at the end of lines.\n-\n-   Maximum_Line_Length     : constant Positive := 79;\n-   Fatal_Line_Length_Limit : constant Positive := 5000;\n-   Fatal_Line_Length       : exception;\n-   --  If Maximum_Line_Length is exceeded in an input file, an error\n-   --  message is printed. If Fatal_Line_Length is exceeded,\n-   --  execution terminates with a Fatal_Line_Length exception.\n-\n-   VMS_Escape_Character : constant Character := '^';\n-   --  The character used to mark VMS alternatives (^alpha^beta^)\n-\n-   Extensions : GNAT.Spitbol.Table_VString.Table (20);\n-   procedure Initialize_Extensions;\n-   --  This table records extensions and their replacement for\n-   --  rewriting filenames in the VMS version of the manual.\n-\n-   function Is_Extension (Extension : String) return Boolean;\n-   function Get_Replacement_Extension (Extension : String) return String;\n-   --  These functions query the replacement table. Is_Extension\n-   --  checks if the given string is a known extension.\n-   --  Get_Replacement returns the replacement extension.\n-\n-   Ug_Words : GNAT.Spitbol.Table_VString.Table (200);\n-   function Is_Known_Word (Word : String) return Boolean;\n-   function Get_Replacement_Word (Word : String) return String;\n-   --  The Ug_Words table lists replacement words for the VMS version\n-   --  of the manual. Is_Known_Word and Get_Replacement_Word query\n-   --  this table. The table is filled using Read_Dictionary_File.\n-\n-   function Rewrite_Source_Line (Line : String) return String;\n-   --  This subprogram takes a line and rewrites it according to Target.\n-   --  It relies on information in Source_File to generate error messages.\n-\n-   -----------\n-   -- Usage --\n-   -----------\n-\n-   procedure Usage is\n-   begin\n-      Put_Line (Standard_Error,\n-            \"usage: xgnatugn TARGET SOURCE DICTIONARY [OUTFILE [WARNINGS]]\");\n-      New_Line;\n-      Put_Line (Standard_Error, \"TARGET is one of:\");\n-\n-      for T in Target_Type'Range loop\n-         Put_Line (Standard_Error, \"  \" & Target_Type'Image (T));\n-      end loop;\n-\n-      New_Line;\n-      Put_Line (Standard_Error, \"SOURCE is the source file to process.\");\n-      New_Line;\n-      Put_Line (Standard_Error, \"DICTIONARY is the name of a file \"\n-                & \"that contains word replacements\");\n-      Put_Line (Standard_Error, \"for the VMS version.\");\n-      New_Line;\n-      Put_Line (Standard_Error,\n-                \"OUT-FILE, if present, is the output file to be created;\");\n-      Put_Line (Standard_Error,\n-                \"If OUT-FILE is absent, the output file is either \" &\n-                \"gnat_ugn_unw.texi, \");\n-      Put_Line (Standard_Error,\n-                \"or gnat_ugn_vms.texi, depending on TARGET.\");\n-      New_Line;\n-      Put_Line (Standard_Error,\n-                \"WARNINGS, if present, is any string;\");\n-      Put_Line (Standard_Error,\n-                \"it will result in warning messages (e.g., line too long))\");\n-      Put_Line (Standard_Error,\n-                \"being output to Standard_Error.\");\n-   end Usage;\n-\n-   --------------\n-   -- Get_Line --\n-   --------------\n-\n-   function Get_Line (Input : access Input_File) return String is\n-      Line_Buffer : String (1 .. Fatal_Line_Length_Limit);\n-      Last        : Natural;\n-\n-   begin\n-      Input.Line := Input.Line + 1;\n-      Get_Line (Input.Data, Line_Buffer, Last);\n-\n-      if Last = Line_Buffer'Last then\n-         Error (Input.all, \"line exceeds fatal line length limit\");\n-         raise Fatal_Line_Length;\n-      end if;\n-\n-      declare\n-         Line : String renames Line_Buffer (Line_Buffer'First .. Last);\n-\n-      begin\n-         for J in Line'Range loop\n-            if not Is_In (Line (J), Valid_Characters) then\n-               Error (Input.all, J, \"invalid character\");\n-               exit;\n-            end if;\n-         end loop;\n-\n-         if Line'Length > Maximum_Line_Length then\n-            Warning (Input.all, Maximum_Line_Length + 1, \"line too long\");\n-         end if;\n-\n-         if Reject_Trailing_Spaces\n-           and then Line'Length > 0\n-           and then Line (Line'Last) = ' '\n-         then\n-            Error (Input.all, Line'Last, \"trailing space character\");\n-         end if;\n-\n-         return Trim (Line, Right);\n-      end;\n-   end Get_Line;\n-\n-   --------------\n-   -- Put_Line --\n-   --------------\n-\n-   procedure Put_Line (F : Sfile; S : String) is\n-   begin\n-      String'Write (Stream (F), S);\n-      Character'Write (Stream (F), ASCII.LF);\n-   end Put_Line;\n-\n-   -----------\n-   -- Error --\n-   -----------\n-\n-   procedure Error\n-     (Input   : Input_File;\n-      Message : String)\n-   is\n-   begin\n-      Error (Input, 0, Message);\n-   end Error;\n-\n-   procedure Error\n-     (Input        : Input_File;\n-      At_Character : Natural;\n-      Message      : String)\n-   is\n-      Line_Image         : constant String := Integer'Image (Input.Line);\n-      At_Character_Image : constant String := Integer'Image (At_Character);\n-      --  These variables are required because we have to drop the leading\n-      --  space character.\n-\n-   begin\n-      Number_Of_Errors := Number_Of_Errors + 1;\n-\n-      if At_Character > 0 then\n-         Put_Line (Standard_Error,\n-                   S (Input.Name) & ':'\n-                   & Line_Image (Line_Image'First + 1 .. Line_Image'Last) & ':'\n-                   & At_Character_Image (At_Character_Image'First + 1\n-                                         .. At_Character_Image'Last)\n-                   & \": \"\n-                   & Message);\n-      else\n-         Put_Line (Standard_Error,\n-                   S (Input.Name) & ':'\n-                   & Line_Image (Line_Image'First + 1 .. Line_Image'Last)\n-                   & \": \"\n-                   & Message);\n-      end if;\n-   end Error;\n-\n-   -------------\n-   -- Warning --\n-   -------------\n-\n-   procedure Warning\n-     (Input        : Input_File;\n-      At_Character : Natural;\n-      Message      : String)\n-   is\n-      Line_Image         : constant String := Integer'Image (Input.Line);\n-      At_Character_Image : constant String := Integer'Image (At_Character);\n-      --  These variables are required because we have to drop the leading\n-      --  space character.\n-\n-   begin\n-      if not Warnings_Enabled then\n-         return;\n-      end if;\n-\n-      Number_Of_Warnings := Number_Of_Warnings + 1;\n-\n-      if At_Character > 0 then\n-         Put_Line (Standard_Error,\n-                   S (Input.Name) & ':'\n-                   & Line_Image (Line_Image'First + 1 .. Line_Image'Last) & ':'\n-                   & At_Character_Image (At_Character_Image'First + 1\n-                                         .. At_Character_Image'Last)\n-                   & \": warning: \"\n-                   & Message);\n-      else\n-         Put_Line (Standard_Error,\n-                   S (Input.Name) & ':'\n-                   & Line_Image (Line_Image'First + 1 .. Line_Image'Last)\n-                   & \": warning: \"\n-                   & Message);\n-      end if;\n-   end Warning;\n-\n-   --------------------------\n-   -- Read_Dictionary_File --\n-   --------------------------\n-\n-   procedure Read_Dictionary_File is\n-   begin\n-      while not End_Of_File (Dictionary_File.Data) loop\n-         declare\n-            Line  : constant String :=\n-                      Get_Line (Dictionary_File'Access);\n-            Split : constant Natural :=\n-                      Index (Line, (1 => VMS_Escape_Character));\n-\n-         begin\n-            if Line'Length = 0 then\n-               Error (Dictionary_File, \"empty line in dictionary file\");\n-\n-            elsif Line (Line'First) = ' ' then\n-               Error (Dictionary_File, 1, \"line starts with space character\");\n-\n-            elsif Split = 0 then\n-               Error (Dictionary_File, \"line does not contain \"\n-                      & VMS_Escape_Character & \" character\");\n-            else\n-               declare\n-                  Source : constant String :=\n-                             Trim (Line (1 .. Split - 1), Both);\n-                  Target : constant String :=\n-                             Trim (Line (Split + 1 .. Line'Last), Both);\n-\n-                  Two_Spaces : constant Natural := Index (Source, \"  \");\n-\n-                  Non_Word_Character : constant Natural :=\n-                                         Index (Source,\n-                                                Word_Characters or\n-                                                  To_Set (\" .\"),\n-                                                Outside);\n-\n-               begin\n-                  if Two_Spaces /= 0 then\n-                     Error (Dictionary_File, Two_Spaces,\n-                            \"multiple space characters in source word\");\n-                  end if;\n-\n-                  if Non_Word_Character /= 0 then\n-                     Error (Dictionary_File, Non_Word_Character,\n-                            \"illegal character in source word\");\n-                  end if;\n-\n-                  if Source'Length = 0 then\n-                     Error (Dictionary_File, \"source is empty\");\n-\n-                  elsif Target'Length = 0 then\n-                     Error (Dictionary_File, \"target is empty\");\n-\n-                  else\n-                     Set (Ug_Words, Source, V (Target));\n-\n-                     --  Ensure that if Source is a sequence of words\n-                     --  \"WORD1 WORD2 ...\", we already have a mapping for\n-                     --  \"WORD1\".\n-\n-                     for J in Source'Range loop\n-                        if Source (J) = ' ' then\n-                           declare\n-                              Prefix : String renames\n-                                         Source (Source'First .. J - 1);\n-                           begin\n-                              if not Is_Known_Word (Prefix) then\n-                                 Error (Dictionary_File,\n-                                        \"prefix '\" & Prefix\n-                                        & \"' not known at this point\");\n-                              end if;\n-                           end;\n-                        end if;\n-                     end loop;\n-                  end if;\n-               end;\n-            end if;\n-         end;\n-      end loop;\n-   end Read_Dictionary_File;\n-\n-   -------------------------\n-   -- Rewrite_Source_Line --\n-   -------------------------\n-\n-   function Rewrite_Source_Line (Line : String) return String is\n-\n-      --  We use a simple lexer to split the line into tokens:\n-\n-      --    Word             consisting entirely of Word_Characters\n-      --    VMS_Alternative  ^alpha^beta^ replacement (but not ^^^)\n-      --    Space            a space character\n-      --    Other            everything else (sequence of non-word characters)\n-      --    VMS_Error        incomplete VMS alternative\n-      --    End_Of_Line      no more characters on this line\n-\n-      --   A sequence of three VMS_Escape_Characters is automatically\n-      --   collapsed to an Other token.\n-\n-      type Token_Span is record\n-         First, Last : Positive;\n-      end record;\n-      --  The character range covered by a token in Line\n-\n-      type Token_Kind is (End_Of_Line, Word, Other,\n-                          VMS_Alternative, VMS_Error);\n-      type Token_Record (Kind : Token_Kind := End_Of_Line) is record\n-         First : Positive;\n-         case Kind is\n-            when Word | Other =>\n-               Span : Token_Span;\n-            when VMS_Alternative =>\n-               Non_VMS, VMS : Token_Span;\n-            when VMS_Error | End_Of_Line =>\n-               null;\n-         end case;\n-      end record;\n-\n-      Input_Position : Positive := Line'First;\n-      Token : Token_Record;\n-      --  The position of the next character to be processed by Next_Token\n-\n-      procedure Next_Token;\n-      --  Returns the next token in Line, starting at Input_Position\n-\n-      Rewritten_Line : VString;\n-      --  Collects the line as it is rewritten\n-\n-      procedure Rewrite_Word;\n-      --  The current token is assumed to be a Word. When processing the VMS\n-      --  version of the manual, additional tokens are gathered to check if\n-      --  we have a file name or a sequence of known words.\n-\n-      procedure Maybe_Rewrite_Extension;\n-      --  The current token is assumed to be Other. When processing the VMS\n-      --  version of the manual and the token represents a single dot \".\",\n-      --  the following word is rewritten according to the rules for\n-      --  extensions.\n-\n-      VMS_Token_Seen : Boolean := False;\n-      --  This is set to true if a VMS_Alternative has been encountered, or a\n-      --  ^^^ token.\n-\n-      ----------------\n-      -- Next_Token --\n-      ----------------\n-\n-      procedure Next_Token is\n-         Remaining_Line : String renames Line (Input_Position .. Line'Last);\n-         Last_Character : Natural;\n-\n-      begin\n-         if Remaining_Line'Length = 0 then\n-            Token := (End_Of_Line, Remaining_Line'First);\n-            return;\n-         end if;\n-\n-         --  ^alpha^beta^, the VMS_Alternative case\n-\n-         if Remaining_Line (Remaining_Line'First) = VMS_Escape_Character then\n-            declare\n-               VMS_Second_Character, VMS_Third_Character : Natural;\n-\n-            begin\n-               if VMS_Token_Seen then\n-                  Error (Source_File, Remaining_Line'First,\n-                         \"multiple \" & VMS_Escape_Character\n-                         & \" characters on a single line\");\n-               else\n-                  VMS_Token_Seen := True;\n-               end if;\n-\n-               --  Find the second and third escape character. If one of\n-               --  them is not present, generate an error token.\n-\n-               VMS_Second_Character :=\n-                 Index (Remaining_Line (Remaining_Line'First + 1\n-                                           .. Remaining_Line'Last),\n-                        (1 => VMS_Escape_Character));\n-\n-               if VMS_Second_Character = 0 then\n-                  Input_Position := Remaining_Line'Last + 1;\n-                  Token := (VMS_Error, Remaining_Line'First);\n-                  return;\n-               end if;\n-\n-               VMS_Third_Character :=\n-                 Index (Remaining_Line (VMS_Second_Character + 1\n-                                           .. Remaining_Line'Last),\n-                        (1 => VMS_Escape_Character));\n-\n-               if VMS_Third_Character = 0 then\n-                  Input_Position := Remaining_Line'Last + 1;\n-                  Token := (VMS_Error, Remaining_Line'First);\n-                  return;\n-               end if;\n-\n-               --  Consume all the characters we are about to include in\n-               --  the token.\n-\n-               Input_Position := VMS_Third_Character + 1;\n-\n-               --  Check if we are in a ^^^ situation, and return an Other\n-               --  token in this case.\n-\n-               if Remaining_Line'First + 1 = VMS_Second_Character\n-                 and then Remaining_Line'First + 2 = VMS_Third_Character\n-               then\n-                  Token := (Other, Remaining_Line'First,\n-                            (Remaining_Line'First, Remaining_Line'First));\n-                  return;\n-               end if;\n-\n-               Token := (VMS_Alternative, Remaining_Line'First,\n-                         (Remaining_Line'First + 1, VMS_Second_Character - 1),\n-                         (VMS_Second_Character + 1, VMS_Third_Character - 1));\n-               return;\n-            end;\n-         end if;\n-\n-         --  The Word case. Search for characters not in Word_Characters.\n-         --  We have found a word if the first non-word character is not\n-         --  the first character in Remaining_Line, i.e. if Remaining_Line\n-         --  starts with a word character.\n-\n-         Last_Character := Index (Remaining_Line, Word_Characters, Outside);\n-         if Last_Character /= Remaining_Line'First then\n-\n-            --  If we haven't found a character which is not in\n-            --  Word_Characters, all remaining characters are part of the\n-            --  current Word token.\n-\n-            if Last_Character = 0 then\n-               Last_Character := Remaining_Line'Last + 1;\n-            end if;\n-\n-            Input_Position := Last_Character;\n-            Token := (Word, Remaining_Line'First,\n-                      (Remaining_Line'First, Last_Character - 1));\n-            return;\n-         end if;\n-\n-         --  Remaining characters are in the Other category. To speed\n-         --  up processing, we collect them together if there are several\n-         --  of them.\n-\n-         Input_Position := Last_Character + 1;\n-         Token := (Other,\n-                   Remaining_Line'First,\n-                   (Remaining_Line'First, Last_Character));\n-      end Next_Token;\n-\n-      ------------------\n-      -- Rewrite_Word --\n-      ------------------\n-\n-      procedure Rewrite_Word is\n-         First_Word : String\n-                        renames Line (Token.Span.First .. Token.Span.Last);\n-\n-      begin\n-         --  We do not perform any error checking below, so we can just skip\n-         --  all processing for the non-VMS version.\n-\n-         if Target /= VMS then\n-            Append (Rewritten_Line, First_Word);\n-            Next_Token;\n-            return;\n-         end if;\n-\n-         if Is_Known_Word (First_Word) then\n-\n-            --  If we have a word from the dictionary, we look for the\n-            --  longest possible sequence we can rewrite.\n-\n-            declare\n-               Seq        : Token_Span := Token.Span;\n-               Lost_Space : Boolean := False;\n-\n-            begin\n-               Next_Token;\n-               loop\n-                  if Token.Kind = Other\n-                    and then Line (Token.Span.First .. Token.Span.Last) = \" \"\n-                  then\n-                     Next_Token;\n-\n-                     if Token.Kind /= Word\n-                       or else not Is_Known_Word (Line (Seq.First\n-                                                        .. Token.Span.Last))\n-                     then\n-                        --  When we reach this point, the following conditions\n-                        --  are true:\n-\n-                        --    Seq is a known word\n-\n-                        --    The previous token was a space character\n-\n-                        --    Seq extended to the current token is not a\n-                        --    known word.\n-\n-                        Lost_Space := True;\n-                        exit;\n-\n-                     else\n-                        --  Extend Seq to cover the current (known) word\n-\n-                        Seq.Last := Token.Span.Last;\n-                        Next_Token;\n-                     end if;\n-\n-                  else\n-                     --  When we reach this point, the following conditions\n-                     --  are true:\n-\n-                     --    Seq is a known word\n-\n-                     --    The previous token was a word\n-\n-                     --    The current token is not a space character.\n-\n-                     exit;\n-                  end if;\n-               end loop;\n-\n-               --  Rewrite Seq, and add the lost space if necessary\n-\n-               Append (Rewritten_Line,\n-                       Get_Replacement_Word (Line (Seq.First .. Seq.Last)));\n-               if Lost_Space then\n-                  Append (Rewritten_Line, ' ');\n-               end if;\n-\n-               --  The unknown token will be processed during the\n-               --  next iteration of the main loop.\n-               return;\n-            end;\n-         end if;\n-\n-         Next_Token;\n-\n-         if Token.Kind = Other\n-           and then Line (Token.Span.First .. Token.Span.Last) = \".\"\n-         then\n-            --  Deal with extensions\n-\n-            Next_Token;\n-            if Token.Kind = Word\n-              and then\n-                Is_Extension (Line (Token.Span.First .. Token.Span.Last))\n-            then\n-               --  We have discovered a file extension. Convert the file\n-               --  name to upper case.\n-\n-               Append (Rewritten_Line,\n-                       Translate (First_Word, Upper_Case_Map) & '.');\n-               Append (Rewritten_Line,\n-                       Get_Replacement_Extension\n-                       (Line (Token.Span.First .. Token.Span.Last)));\n-               Next_Token;\n-            else\n-               --  We already have: Word \".\", followed by an unknown token\n-\n-               Append (Rewritten_Line, First_Word & '.');\n-\n-               --  The unknown token will be processed during the next\n-               --  iteration of the main loop.\n-            end if;\n-\n-         else\n-            --  We have an unknown Word, followed by an unknown token.\n-            --  The unknown token will be processed by the outer loop.\n-\n-            Append (Rewritten_Line, First_Word);\n-         end if;\n-      end Rewrite_Word;\n-\n-      -----------------------------\n-      -- Maybe_Rewrite_Extension --\n-      -----------------------------\n-\n-      procedure Maybe_Rewrite_Extension is\n-      begin\n-         --  Again, we need no special processing in the non-VMS case\n-\n-         if Target = VMS\n-           and then Line (Token.Span.First .. Token.Span.Last) = \".\"\n-         then\n-            --  This extension is not preceded by a word, otherwise\n-            --  Rewrite_Word would have handled it.\n-\n-            Next_Token;\n-\n-            if Token.Kind = Word\n-              and then Is_Extension (Line (Token.Span.First\n-                                           .. Token.Span.Last))\n-            then\n-               Append (Rewritten_Line, '.' & Get_Replacement_Extension\n-                       (Line (Token.Span.First .. Token.Span.Last)));\n-               Next_Token;\n-            else\n-               Append (Rewritten_Line, '.');\n-            end if;\n-\n-         else\n-            Append (Rewritten_Line, Line (Token.Span.First\n-                                          .. Token.Span.Last));\n-            Next_Token;\n-         end if;\n-      end Maybe_Rewrite_Extension;\n-\n-   --  Start of processing for Process_Source_Line\n-\n-   begin\n-      --  The following parser recognizes the following special token\n-      --  sequences:\n-\n-      --     Word \".\" Word    rewrite as file name if second word is extension\n-      --     Word \" \" Word    rewrite as a single word using Ug_Words table\n-\n-      Next_Token;\n-      loop\n-         case Token.Kind is\n-            when End_Of_Line =>\n-               exit;\n-\n-            when Word  =>\n-               Rewrite_Word;\n-\n-            when Other =>\n-               Maybe_Rewrite_Extension;\n-\n-            when VMS_Alternative =>\n-               if Target = VMS then\n-                  Append (Rewritten_Line, Line (Token.VMS.First\n-                                                .. Token.VMS.Last));\n-               else\n-                  Append (Rewritten_Line, Line (Token.Non_VMS.First\n-                                                .. Token.Non_VMS.Last));\n-               end if;\n-\n-               Next_Token;\n-\n-            when VMS_Error =>\n-               Error (Source_File, Token.First, \"invalid VMS alternative\");\n-               Next_Token;\n-         end case;\n-      end loop;\n-\n-      return S (Rewritten_Line);\n-   end Rewrite_Source_Line;\n-\n-   -------------------------\n-   -- Process_Source_File --\n-   -------------------------\n-\n-   procedure Process_Source_File is\n-   begin\n-      while not End_Of_File (Source_File.Data) loop\n-         declare\n-            Line      : constant String := Get_Line (Source_File'Access);\n-\n-            Rewritten : constant String := Rewrite_Source_Line (Line);\n-            --  We unconditionally rewrite the line so that we can check the\n-            --  syntax of all lines, and not only those which are actually\n-            --  included in the output.\n-\n-         begin\n-            if First_Time\n-              and then Line'Length > 3 and then Line (1 .. 3) = \"@if\"\n-            then\n-               Put_Line (Output_File, \"@set \" & Argument (1));\n-               First_Time := False;\n-            end if;\n-\n-            Put_Line (Output_File, Rewritten);\n-         end;\n-      end loop;\n-   end Process_Source_File;\n-\n-   ---------------------------\n-   -- Initialize_Extensions --\n-   ---------------------------\n-\n-   procedure Initialize_Extensions is\n-\n-      procedure Add (Extension : String);\n-      --  Adds an extension which is replaced with itself (in upper case)\n-\n-      procedure Add (Extension, Replacement : String);\n-      --  Adds an extension with a custom replacement\n-\n-      ---------\n-      -- Add --\n-      ---------\n-\n-      procedure Add (Extension : String) is\n-      begin\n-         Add (Extension, Translate (Extension, Upper_Case_Map));\n-      end Add;\n-\n-      procedure Add (Extension, Replacement : String) is\n-      begin\n-         Set (Extensions, Extension, V (Replacement));\n-      end Add;\n-\n-   --  Start of processing for Initialize_Extensions\n-\n-   begin\n-      --  To avoid performance degradation, increase the constant in the\n-      --  definition of Extensions above if you add more extensions here.\n-\n-      Add (\"o\", \"OBJ\");\n-      Add (\"ads\");\n-      Add (\"adb\");\n-      Add (\"ali\");\n-      Add (\"ada\");\n-      Add (\"atb\");\n-      Add (\"ats\");\n-      Add (\"adc\");\n-      Add (\"c\");\n-   end Initialize_Extensions;\n-\n-   ------------------\n-   -- Is_Extension --\n-   ------------------\n-\n-   function Is_Extension (Extension : String) return Boolean is\n-   begin\n-      return Present (Extensions, Extension);\n-   end Is_Extension;\n-\n-   -------------------------------\n-   -- Get_Replacement_Extension --\n-   -------------------------------\n-\n-   function Get_Replacement_Extension (Extension : String) return String is\n-   begin\n-      return S (Get (Extensions, Extension));\n-   end Get_Replacement_Extension;\n-\n-   -------------------\n-   -- Is_Known_Word --\n-   -------------------\n-\n-   function Is_Known_Word (Word : String) return Boolean is\n-   begin\n-      return Present (Ug_Words, Word);\n-   end Is_Known_Word;\n-\n-   --------------------------\n-   -- Get_Replacement_Word --\n-   --------------------------\n-\n-   function Get_Replacement_Word (Word : String) return String is\n-   begin\n-      return S (Get (Ug_Words, Word));\n-   end Get_Replacement_Word;\n-\n---  Start of processing for Xgnatugn\n-\n-   Valid_Command_Line : Boolean;\n-   Output_File_Name   : VString;\n+   Max_Line_Length : constant := 5000;\n+   Line            : String (1 .. Max_Line_Length);\n+   Last            : Natural;\n+   File1, File2    : File_Type;\n \n begin\n-   Initialize_Extensions;\n-   Valid_Command_Line := Argument_Count in 3 .. 5;\n-\n-   --  First argument: Target\n-\n-   if Valid_Command_Line then\n-      begin\n-         Target := Flag_Type'Value (Argument (1));\n-\n-         if not Target'Valid then\n-            Valid_Command_Line := False;\n-         end if;\n-\n-      exception\n-         when Constraint_Error =>\n-            Valid_Command_Line := False;\n-      end;\n-   end if;\n-\n-   --  Second argument: Source_File\n-\n-   if Valid_Command_Line then\n-      begin\n-         Source_File.Name := V (Argument (2));\n-         Open (Source_File.Data, In_File, Argument (2));\n-\n-      exception\n-         when Ada.Text_IO.Name_Error =>\n-            Valid_Command_Line := False;\n-      end;\n-   end if;\n-\n-   --  Third argument: Dictionary_File\n-\n-   if Valid_Command_Line then\n-      begin\n-         Dictionary_File.Name := V (Argument (3));\n-         Open (Dictionary_File.Data, In_File, Argument (3));\n-\n-      exception\n-         when Ada.Text_IO.Name_Error =>\n-            Valid_Command_Line := False;\n-      end;\n-   end if;\n-\n-   --  Fourth argument: Output_File\n-\n-   if Valid_Command_Line then\n-      if Argument_Count in 4 .. 5 then\n-         Output_File_Name := V (Argument (4));\n-      else\n-         case Target is\n-            when UNW =>\n-               Output_File_Name := V (\"gnat_ugn_unw.texi\");\n-            when VMS =>\n-               Output_File_Name := V (\"gnat_ugn_vms.texi\");\n-         end case;\n-      end if;\n-\n-      Warnings_Enabled := Argument_Count = 5;\n-\n-      begin\n-         Create (Output_File, Out_File, S (Output_File_Name));\n-\n-      exception\n-         when Ada.Text_IO.Name_Error | Ada.Text_IO.Use_Error =>\n-            Valid_Command_Line := False;\n-      end;\n-   end if;\n-\n-   if not Valid_Command_Line then\n-      Usage;\n-      Set_Exit_Status (Failure);\n-\n-   else\n-      Read_Dictionary_File;\n-      Close (Dictionary_File.Data);\n-\n-      --  Main processing starts here\n-\n-      Process_Source_File;\n-      Close (Output_File);\n-      Close (Source_File.Data);\n-\n-      New_Line (Standard_Error);\n-\n-      if Number_Of_Warnings = 0 then\n-         Put_Line (Standard_Error, \" NO Warnings\");\n-\n-      else\n-         Put (Standard_Error, Integer'Image (Number_Of_Warnings));\n-         Put (Standard_Error, \" Warning\");\n-\n-         if Number_Of_Warnings > 1 then\n-            Put (Standard_Error, \"s\");\n-         end if;\n-\n-         New_Line (Standard_Error);\n-      end if;\n-\n-      if Number_Of_Errors = 0 then\n-         Put_Line (Standard_Error, \" NO Errors\");\n-\n-      else\n-         Put (Standard_Error, Integer'Image (Number_Of_Errors));\n-         Put (Standard_Error, \" Error\");\n-\n-         if Number_Of_Errors > 1 then\n-            Put (Standard_Error, \"s\");\n-         end if;\n \n-         New_Line (Standard_Error);\n-      end if;\n+   Open (File1, Mode => In_File, Name => Argument (2));\n+   Create (File2, Mode => Out_File, Name => Argument (4));\n \n-      if Number_Of_Errors /= 0  then\n-         Set_Exit_Status (Failure);\n-      else\n-         Set_Exit_Status (Success);\n-      end if;\n-   end if;\n+   while not End_Of_File (File1) loop\n+      Get_Line (File1, Line, Last);\n+      Put_Line (File2, Line (1 .. Last));\n+   end loop;\n end Xgnatugn;"}]}