{"sha": "9c9a11f60d910689e387ce91a78a798e02166df3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWM5YTExZjYwZDkxMDY4OWUzODdjZTkxYTc4YTc5OGUwMjE2NmRmMw==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2017-01-15T18:42:29Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2017-01-15T18:42:29Z"}, "message": "i386.c (ix86_legitimate_combined_insn): Do not call recog here.\n\n\t* config/i386/i386.c (ix86_legitimate_combined_insn): Do not\n\tcall recog here.  Assert that INSN_CODE (insn) is non-negative.\n\nFrom-SVN: r244478", "tree": {"sha": "61ab25c5a2cc881941a0c070a66aa7278f6993d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61ab25c5a2cc881941a0c070a66aa7278f6993d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c9a11f60d910689e387ce91a78a798e02166df3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c9a11f60d910689e387ce91a78a798e02166df3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c9a11f60d910689e387ce91a78a798e02166df3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c9a11f60d910689e387ce91a78a798e02166df3/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "81e63b637aef0fc61e85de64b2be62517723e606", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81e63b637aef0fc61e85de64b2be62517723e606", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81e63b637aef0fc61e85de64b2be62517723e606"}], "stats": {"total": 109, "additions": 57, "deletions": 52}, "files": [{"sha": "6f7d48bae6ed5e059004582e63050d4c46817d63", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c9a11f60d910689e387ce91a78a798e02166df3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c9a11f60d910689e387ce91a78a798e02166df3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9c9a11f60d910689e387ce91a78a798e02166df3", "patch": "@@ -1,3 +1,8 @@\n+2017-01-15  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.c (ix86_legitimate_combined_insn): Do not\n+\tcall recog here.  Assert that INSN_CODE (insn) is non-negative.\n+\n 2017-01-15  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR target/72749"}, {"sha": "3327036573cdda27f7d7fa686f879f4b2025f696", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c9a11f60d910689e387ce91a78a798e02166df3/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c9a11f60d910689e387ce91a78a798e02166df3/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=9c9a11f60d910689e387ce91a78a798e02166df3", "patch": "@@ -8125,73 +8125,73 @@ ix86_return_pops_args (tree fundecl, tree funtype, int size)\n static bool\n ix86_legitimate_combined_insn (rtx_insn *insn)\n {\n+  int i;\n+\n   /* Check operand constraints in case hard registers were propagated\n      into insn pattern.  This check prevents combine pass from\n      generating insn patterns with invalid hard register operands.\n      These invalid insns can eventually confuse reload to error out\n      with a spill failure.  See also PRs 46829 and 46843.  */\n-  if ((INSN_CODE (insn) = recog (PATTERN (insn), insn, 0)) >= 0)\n-    {\n-      int i;\n \n-      extract_insn (insn);\n-      preprocess_constraints (insn);\n+  gcc_assert (INSN_CODE (insn) >= 0);\n \n-      int n_operands = recog_data.n_operands;\n-      int n_alternatives = recog_data.n_alternatives;\n-      for (i = 0; i < n_operands; i++)\n-\t{\n-\t  rtx op = recog_data.operand[i];\n-\t  machine_mode mode = GET_MODE (op);\n-\t  const operand_alternative *op_alt;\n-\t  int offset = 0;\n-\t  bool win;\n-\t  int j;\n+  extract_insn (insn);\n+  preprocess_constraints (insn);\n \n-\t  /* A unary operator may be accepted by the predicate, but it\n-\t     is irrelevant for matching constraints.  */\n-\t  if (UNARY_P (op))\n-\t    op = XEXP (op, 0);\n+  int n_operands = recog_data.n_operands;\n+  int n_alternatives = recog_data.n_alternatives;\n+  for (i = 0; i < n_operands; i++)\n+    {\n+      rtx op = recog_data.operand[i];\n+      machine_mode mode = GET_MODE (op);\n+      const operand_alternative *op_alt;\n+      int offset = 0;\n+      bool win;\n+      int j;\n \n-\t  if (SUBREG_P (op))\n-\t    {\n-\t      if (REG_P (SUBREG_REG (op))\n-\t\t  && REGNO (SUBREG_REG (op)) < FIRST_PSEUDO_REGISTER)\n-\t\toffset = subreg_regno_offset (REGNO (SUBREG_REG (op)),\n-\t\t\t\t\t      GET_MODE (SUBREG_REG (op)),\n-\t\t\t\t\t      SUBREG_BYTE (op),\n-\t\t\t\t\t      GET_MODE (op));\n-\t      op = SUBREG_REG (op);\n-\t    }\n+      /* A unary operator may be accepted by the predicate, but it\n+\t is irrelevant for matching constraints.  */\n+      if (UNARY_P (op))\n+\top = XEXP (op, 0);\n \n-\t  if (!(REG_P (op) && HARD_REGISTER_P (op)))\n-\t    continue;\n+      if (SUBREG_P (op))\n+\t{\n+\t  if (REG_P (SUBREG_REG (op))\n+\t      && REGNO (SUBREG_REG (op)) < FIRST_PSEUDO_REGISTER)\n+\t    offset = subreg_regno_offset (REGNO (SUBREG_REG (op)),\n+\t\t\t\t\t  GET_MODE (SUBREG_REG (op)),\n+\t\t\t\t\t  SUBREG_BYTE (op),\n+\t\t\t\t\t  GET_MODE (op));\n+\t  op = SUBREG_REG (op);\n+\t}\n \n-\t  op_alt = recog_op_alt;\n+      if (!(REG_P (op) && HARD_REGISTER_P (op)))\n+\tcontinue;\n \n-\t  /* Operand has no constraints, anything is OK.  */\n- \t  win = !n_alternatives;\n+      op_alt = recog_op_alt;\n \n-\t  alternative_mask preferred = get_preferred_alternatives (insn);\n-\t  for (j = 0; j < n_alternatives; j++, op_alt += n_operands)\n-\t    {\n-\t      if (!TEST_BIT (preferred, j))\n-\t\tcontinue;\n-\t      if (op_alt[i].anything_ok\n-\t\t  || (op_alt[i].matches != -1\n-\t\t      && operands_match_p\n-\t\t\t  (recog_data.operand[i],\n-\t\t\t   recog_data.operand[op_alt[i].matches]))\n-\t\t  || reg_fits_class_p (op, op_alt[i].cl, offset, mode))\n-\t\t{\n-\t\t  win = true;\n-\t\t  break;\n-\t\t}\n-\t    }\n+      /* Operand has no constraints, anything is OK.  */\n+      win = !n_alternatives;\n \n-\t  if (!win)\n-\t    return false;\n+      alternative_mask preferred = get_preferred_alternatives (insn);\n+      for (j = 0; j < n_alternatives; j++, op_alt += n_operands)\n+\t{\n+\t  if (!TEST_BIT (preferred, j))\n+\t    continue;\n+\t  if (op_alt[i].anything_ok\n+\t      || (op_alt[i].matches != -1\n+\t\t  && operands_match_p\n+\t\t  (recog_data.operand[i],\n+\t\t   recog_data.operand[op_alt[i].matches]))\n+\t      || reg_fits_class_p (op, op_alt[i].cl, offset, mode))\n+\t    {\n+\t      win = true;\n+\t      break;\n+\t    }\n \t}\n+\n+      if (!win)\n+\treturn false;\n     }\n \n   return true;"}]}