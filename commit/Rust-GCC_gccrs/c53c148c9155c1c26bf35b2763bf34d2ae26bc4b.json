{"sha": "c53c148c9155c1c26bf35b2763bf34d2ae26bc4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzUzYzE0OGM5MTU1YzFjMjZiZjM1YjI3NjNiZjM0ZDJhZTI2YmM0Yg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-10-15T22:10:22Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-10-15T22:10:22Z"}, "message": "i386.c (ix86_vec_cost): New function.\n\n\t* i386.c (ix86_vec_cost): New function.\n\t(ix86_rtx_costs): Handle vector operations better.\n\t* i386.h (struct processor_costs): Add sse_op, fmasd, fmass.\n\t* x86-tune-costs.h: Add new costs to all tables.\n\nFrom-SVN: r253771", "tree": {"sha": "704870d5abd2ce4d85bbbed2032cc882d8275688", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/704870d5abd2ce4d85bbbed2032cc882d8275688"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c53c148c9155c1c26bf35b2763bf34d2ae26bc4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c53c148c9155c1c26bf35b2763bf34d2ae26bc4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c53c148c9155c1c26bf35b2763bf34d2ae26bc4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c53c148c9155c1c26bf35b2763bf34d2ae26bc4b/comments", "author": null, "committer": null, "parents": [{"sha": "6065f4446c9019840d15e1a5429415f8a0a0d9d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6065f4446c9019840d15e1a5429415f8a0a0d9d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6065f4446c9019840d15e1a5429415f8a0a0d9d4"}], "stats": {"total": 191, "additions": 155, "deletions": 36}, "files": [{"sha": "5bbd24fdac01ccd5e274597d28c305386dd77943", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c53c148c9155c1c26bf35b2763bf34d2ae26bc4b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c53c148c9155c1c26bf35b2763bf34d2ae26bc4b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c53c148c9155c1c26bf35b2763bf34d2ae26bc4b", "patch": "@@ -1,3 +1,10 @@\n+2017-10-14  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* i386.c (ix86_vec_cost): New function.\n+\t(ix86_rtx_costs): Handle vector operations better.\n+\t* i386.h (struct processor_costs): Add sse_op, fmasd, fmass.\n+\t* x86-tune-costs.h: Add new costs to all tables.\n+\n 2017-10-14  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* i386.c (ix86_rtx_costs): Make difference between x87 and SSE"}, {"sha": "26b22d6d7aac88c3be856c233bc66c86e4e547f1", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 70, "deletions": 36, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c53c148c9155c1c26bf35b2763bf34d2ae26bc4b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c53c148c9155c1c26bf35b2763bf34d2ae26bc4b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c53c148c9155c1c26bf35b2763bf34d2ae26bc4b", "patch": "@@ -38799,6 +38799,27 @@ ix86_set_reg_reg_cost (machine_mode mode)\n   return COSTS_N_INSNS (CEIL (GET_MODE_SIZE (mode), units));\n }\n \n+/* Return cost of vector operation in MODE given that scalar version has\n+   COST.  If PARALLEL is true assume that CPU has more than one unit\n+   performing the operation.  */\n+\n+static int\n+ix86_vec_cost (machine_mode mode, int cost, bool parallel)\n+{\n+  if (!VECTOR_MODE_P (mode))\n+    return cost;\n+ \n+  if (!parallel)\n+    return cost * GET_MODE_NUNITS (mode);\n+  if (GET_MODE_BITSIZE (mode) == 128\n+      && TARGET_SSE_SPLIT_REGS)\n+    return cost * 2;\n+  if (GET_MODE_BITSIZE (mode) > 128\n+      && TARGET_AVX128_OPTIMAL)\n+    return cost * GET_MODE_BITSIZE (mode) / 128;\n+  return cost;\n+}\n+\n /* Compute a (partial) cost for rtx X.  Return true if the complete\n    cost has been computed, and false if subexpressions should be\n    scanned.  In either case, *TOTAL contains the cost result.  */\n@@ -38959,19 +38980,20 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n \t\t     shift with one insn set the cost to prefer paddb.  */\n \t\t  if (CONSTANT_P (XEXP (x, 1)))\n \t\t    {\n-\t\t      *total = (cost->fabs\n+\t\t      *total = ix86_vec_cost (mode,\n+\t\t\t\tcost->sse_op\n \t\t\t\t+ rtx_cost (XEXP (x, 0), mode, code, 0, speed)\n-\t\t\t\t+ (speed ? 2 : COSTS_N_BYTES (16)));\n+\t\t\t\t+ (speed ? 2 : COSTS_N_BYTES (16)), true);\n \t\t      return true;\n \t\t    }\n \t\t  count = 3;\n \t\t}\n \t      else if (TARGET_SSSE3)\n \t\tcount = 7;\n-\t      *total = cost->fabs * count;\n+\t      *total = ix86_vec_cost (mode, cost->sse_op * count, true);\n \t    }\n \t  else\n-\t    *total = cost->fabs;\n+\t    *total = ix86_vec_cost (mode, cost->sse_op, true);\n \t}\n       else if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n \t{\n@@ -39013,9 +39035,9 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n         gcc_assert (FLOAT_MODE_P (mode));\n         gcc_assert (TARGET_FMA || TARGET_FMA4 || TARGET_AVX512F);\n \n-        /* ??? SSE scalar/vector cost should be used here.  */\n-        /* ??? Bald assumption that fma has the same cost as fmul.  */\n-        *total = mode == SFmode ? cost->mulss : cost->mulsd;\n+        *total = ix86_vec_cost (mode,\n+\t\t\t\tmode == SFmode ? cost->fmass : cost->fmasd,\n+\t\t\t\ttrue);\n \t*total += rtx_cost (XEXP (x, 1), mode, FMA, 1, speed);\n \n         /* Negate in op0 or op2 is free: FMS, FNMA, FNMS.  */\n@@ -39044,8 +39066,9 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n \t}\n       else if (FLOAT_MODE_P (mode))\n \t{\n-\t  /* ??? SSE vector cost should be used here.  */\n-\t  *total = inner_mode == DFmode ? cost->mulsd : cost->mulss;\n+\t  *total = ix86_vec_cost (mode,\n+\t\t\t\t  inner_mode == DFmode\n+\t\t\t\t  ? cost->mulsd : cost->mulss, true);\n \t  return false;\n \t}\n       else if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n@@ -39058,22 +39081,29 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n \t\textra = 5;\n \t      else if (TARGET_SSSE3)\n \t\textra = 6;\n-\t      *total = cost->fmul * 2 + cost->fabs * extra;\n+\t      *total = ix86_vec_cost (mode,\n+\t\t\t\t      cost->mulss * 2 + cost->sse_op * extra,\n+\t\t\t\t      true);\n \t    }\n \t  /* V*DImode is emulated with 5-8 insns.  */\n \t  else if (mode == V2DImode || mode == V4DImode)\n \t    {\n \t      if (TARGET_XOP && mode == V2DImode)\n-\t\t*total = cost->fmul * 2 + cost->fabs * 3;\n+\t\t*total = ix86_vec_cost (mode,\n+\t\t\t\t\tcost->mulss * 2 + cost->sse_op * 3,\n+\t\t\t\t\ttrue);\n \t      else\n-\t\t*total = cost->fmul * 3 + cost->fabs * 5;\n+\t\t*total = ix86_vec_cost (mode,\n+\t\t\t\t\tcost->mulss * 3 + cost->sse_op * 5,\n+\t\t\t\t\ttrue);\n \t    }\n \t  /* Without sse4.1, we don't have PMULLD; it's emulated with 7\n \t     insns, including two PMULUDQ.  */\n \t  else if (mode == V4SImode && !(TARGET_SSE4_1 || TARGET_AVX))\n-\t    *total = cost->fmul * 2 + cost->fabs * 5;\n+\t    *total = ix86_vec_cost (mode, cost->mulss * 2 + cost->sse_op * 5,\n+\t\t\t\t    true);\n \t  else\n-\t    *total = inner_mode == DFmode ? cost->mulsd : cost->mulss;\n+\t    *total = ix86_vec_cost (mode, cost->mulss, true);\n \t  return false;\n \t}\n       else\n@@ -39131,8 +39161,9 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n       else if (X87_FLOAT_MODE_P (mode))\n \t*total = cost->fdiv;\n       else if (FLOAT_MODE_P (mode))\n-\t/* ??? SSE vector cost should be used here.  */\n-\t*total = inner_mode == DFmode ? cost->divsd : cost->divss;\n+\t*total = ix86_vec_cost (mode,\n+\t\t\t        inner_mode == DFmode ? cost->divsd : cost->divss,\n+\t\t\t\ttrue);\n       else\n \t*total = cost->divide[MODE_INDEX (mode)];\n       return false;\n@@ -39221,8 +39252,7 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n \t}\n       else if (FLOAT_MODE_P (mode))\n \t{\n-\t  /* We should account if registers are split.  */\n-\t  *total = cost->addss;\n+\t  *total = ix86_vec_cost (mode, cost->addss, true);\n \t  return false;\n \t}\n       /* FALLTHRU */\n@@ -39245,8 +39275,7 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n     case NEG:\n       if (SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH)\n \t{\n-\t  /* ??? SSE cost should be used here.  */\n-\t  *total = cost->fchs;\n+\t  *total = cost->sse_op;\n \t  return false;\n \t}\n       else if (X87_FLOAT_MODE_P (mode))\n@@ -39256,20 +39285,14 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n \t}\n       else if (FLOAT_MODE_P (mode))\n \t{\n-\t  /* ??? SSE vector cost should be used here.  */\n-\t  *total = cost->fchs;\n+\t  *total = ix86_vec_cost (mode, cost->sse_op, true);\n \t  return false;\n \t}\n       /* FALLTHRU */\n \n     case NOT:\n       if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n-\t{\n-\t  /* ??? Should be SSE vector operation cost.  */\n-\t  /* At least for published AMD latencies, this really is the same\n-\t     as the latency for a simple fpu operation like fabs.  */\n-\t  *total = cost->fabs;\n-\t}\n+\t*total = ix86_vec_cost (mode, cost->sse_op, true);\n       else if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n \t*total = cost->add * 2;\n       else\n@@ -39302,17 +39325,27 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n     case FLOAT_EXTEND:\n       if (!(SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH))\n \t*total = 0;\n+      else\n+        *total = ix86_vec_cost (mode, cost->addss, true);\n+      return false;\n+\n+    case FLOAT_TRUNCATE:\n+      if (!(SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH))\n+\t*total = cost->fadd;\n+      else\n+        *total = ix86_vec_cost (mode, cost->addss, true);\n       return false;\n \n     case ABS:\n+      /* SSE requires memory load for the constant operand. It may make\n+\t sense to account for this.  Of course the constant operand may or\n+\t may not be reused. */\n       if (SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH)\n-\t/* ??? SSE cost should be used here.  */\n-\t*total = cost->fabs;\n+\t*total = cost->sse_op;\n       else if (X87_FLOAT_MODE_P (mode))\n \t*total = cost->fabs;\n       else if (FLOAT_MODE_P (mode))\n-\t/* ??? SSE vector cost should be used here.  */\n-\t*total = cost->fabs;\n+\t*total = ix86_vec_cost (mode, cost->sse_op, true);\n       return false;\n \n     case SQRT:\n@@ -39321,8 +39354,9 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n       else if (X87_FLOAT_MODE_P (mode))\n \t*total = cost->fsqrt;\n       else if (FLOAT_MODE_P (mode))\n-\t/* ??? SSE vector cost should be used here.  */\n-\t*total = mode == SFmode ? cost->sqrtss : cost->sqrtsd;\n+\t*total = ix86_vec_cost (mode,\n+\t\t\t\tmode == SFmode ? cost->sqrtss : cost->sqrtsd,\n+\t\t\t\ttrue);\n       return false;\n \n     case UNSPEC:\n@@ -39336,7 +39370,7 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n       /* ??? Assume all of these vector manipulation patterns are\n \t recognizable.  In which case they all pretty much have the\n \t same cost.  */\n-     *total = cost->fabs;\n+     *total = cost->sse_op;\n      return true;\n     case VEC_MERGE:\n       mask = XEXP (x, 2);\n@@ -39345,7 +39379,7 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n       if (TARGET_AVX512F && register_operand (mask, GET_MODE (mask)))\n \t*total = rtx_cost (XEXP (x, 0), mode, outer_code, opno, speed);\n       else\n-\t*total = cost->fabs;\n+\t*total = cost->sse_op;\n       return true;\n \n     default:"}, {"sha": "1196ed9b503934f33abd7999347637637e4f1580", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c53c148c9155c1c26bf35b2763bf34d2ae26bc4b/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c53c148c9155c1c26bf35b2763bf34d2ae26bc4b/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=c53c148c9155c1c26bf35b2763bf34d2ae26bc4b", "patch": "@@ -257,9 +257,12 @@ struct processor_costs {\n   const int fsqrt;\t\t/* cost of FSQRT instruction.  */\n \t\t\t\t/* Specify what algorithm\n \t\t\t\t   to use for stringops on unknown size.  */\n+  const int sse_op;\t\t/* cost of cheap SSE instruction.  */\n   const int addss;\t\t/* cost of ADDSS/SD SUBSS/SD instructions.  */\n   const int mulss;\t\t/* cost of MULSS instructions.  */\n   const int mulsd;\t\t/* cost of MULSD instructions.  */\n+  const int fmass;\t\t/* cost of FMASS instructions.  */\n+  const int fmasd;\t\t/* cost of FMASD instructions.  */\n   const int divss;\t\t/* cost of DIVSS instructions.  */\n   const int divsd;\t\t/* cost of DIVSD instructions.  */\n   const int sqrtss;\t\t/* cost of SQRTSS instructions.  */"}, {"sha": "c5ded939237379e762849943481efc981f3a9f51", "filename": "gcc/config/i386/x86-tune-costs.h", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c53c148c9155c1c26bf35b2763bf34d2ae26bc4b/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c53c148c9155c1c26bf35b2763bf34d2ae26bc4b/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h?ref=c53c148c9155c1c26bf35b2763bf34d2ae26bc4b", "patch": "@@ -66,9 +66,12 @@ struct processor_costs ix86_size_cost = {/* costs for tuning for size */\n   COSTS_N_BYTES (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_BYTES (2),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_BYTES (2),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_BYTES (2),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_BYTES (2),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_BYTES (2),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_BYTES (2),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_BYTES (2),\t\t\t/* cost of FMA SD instruction.  */\n   COSTS_N_BYTES (2),\t\t\t/* cost of DIVSS instruction.  */\n   COSTS_N_BYTES (2),\t\t\t/* cost of DIVSD instruction.  */\n   COSTS_N_BYTES (2),\t\t\t/* cost of SQRTSS instruction.  */\n@@ -151,9 +154,12 @@ struct processor_costs i386_cost = {\t/* 386 specific costs */\n   COSTS_N_INSNS (24),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (122),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (1),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (23),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (27),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (27),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (27),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (27),\t\t\t/* cost of FMA SD instruction.  */\n   COSTS_N_INSNS (88),\t\t\t/* cost of DIVSS instruction.  */\n   COSTS_N_INSNS (88),\t\t\t/* cost of DIVSD instruction.  */\n   COSTS_N_INSNS (122),\t\t\t/* cost of SQRTSS instruction.  */\n@@ -237,9 +243,12 @@ struct processor_costs i486_cost = {\t/* 486 specific costs */\n   COSTS_N_INSNS (3),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (83),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (1),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (16),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (16),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (16),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (16),\t\t\t/* cost of FMA SD instruction.  */\n   COSTS_N_INSNS (73),\t\t\t/* cost of DIVSS instruction.  */\n   COSTS_N_INSNS (74),\t\t\t/* cost of DIVSD instruction.  */\n   COSTS_N_INSNS (83),\t\t\t/* cost of SQRTSS instruction.  */\n@@ -321,9 +330,12 @@ struct processor_costs pentium_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (70),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (1),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SD instruction.  */\n   COSTS_N_INSNS (39),\t\t\t/* cost of DIVSS instruction.  */\n   COSTS_N_INSNS (39),\t\t\t/* cost of DIVSD instruction.  */\n   COSTS_N_INSNS (70),\t\t\t/* cost of SQRTSS instruction.  */\n@@ -398,9 +410,12 @@ struct processor_costs lakemont_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (70),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (1),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (5),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (5),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (5),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (10),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (10),\t\t\t/* cost of FMA SD instruction.  */\n   COSTS_N_INSNS (31),\t\t\t/* cost of DIVSS instruction.  */\n   COSTS_N_INSNS (60),\t\t\t/* cost of DIVSD instruction.  */\n   COSTS_N_INSNS (31),\t\t\t/* cost of SQRTSS instruction.  */\n@@ -490,9 +505,12 @@ struct processor_costs pentiumpro_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (56),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (1),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (4),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (4),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (7),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (7),\t\t\t/* cost of FMA SD instruction.  */\n   COSTS_N_INSNS (18),\t\t\t/* cost of DIVSS instruction.  */\n   COSTS_N_INSNS (18),\t\t\t/* cost of DIVSD instruction.  */\n   COSTS_N_INSNS (31),\t\t\t/* cost of SQRTSS instruction.  */\n@@ -574,9 +592,12 @@ struct processor_costs geode_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (54),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (1),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (6),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (11),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (11),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (17),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (17),\t\t\t/* cost of FMA SD instruction.  */\n   COSTS_N_INSNS (47),\t\t\t/* cost of DIVSS instruction.  */\n   COSTS_N_INSNS (47),\t\t\t/* cost of DIVSD instruction.  */\n   COSTS_N_INSNS (54),\t\t\t/* cost of SQRTSS instruction.  */\n@@ -660,9 +681,12 @@ struct processor_costs k6_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (56),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (1),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (4),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (4),\t\t\t/* cost of FMA SD instruction.  */\n   COSTS_N_INSNS (56),\t\t\t/* cost of DIVSS instruction.  */\n   COSTS_N_INSNS (56),\t\t\t/* cost of DIVSD instruction.  */\n   COSTS_N_INSNS (56),\t\t\t/* cost of SQRTSS instruction.  */\n@@ -746,9 +770,12 @@ struct processor_costs athlon_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (35),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (2),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (4),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (4),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (4),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (8),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (8),\t\t\t/* cost of FMA SD instruction.  */\n   /* 11-16  */\n   COSTS_N_INSNS (16),\t\t\t/* cost of DIVSS instruction.  */\n   COSTS_N_INSNS (24),\t\t\t/* cost of DIVSD instruction.  */\n@@ -842,9 +869,12 @@ struct processor_costs k8_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (35),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (2),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (4),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (4),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (4),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (8),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (8),\t\t\t/* cost of FMA SD instruction.  */\n   /* 11-16  */\n   COSTS_N_INSNS (16),\t\t\t/* cost of DIVSS instruction.  */\n   COSTS_N_INSNS (20),\t\t\t/* cost of DIVSD instruction.  */\n@@ -945,9 +975,12 @@ struct processor_costs amdfam10_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (35),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (2),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (4),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (4),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (4),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (8),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (8),\t\t\t/* cost of FMA SD instruction.  */\n   /* 11-16  */\n   COSTS_N_INSNS (16),\t\t\t/* cost of DIVSS instruction.  */\n   COSTS_N_INSNS (20),\t\t\t/* cost of DIVSD instruction.  */\n@@ -1049,9 +1082,12 @@ const struct processor_costs bdver1_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (52),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (2),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (6),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (6),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (6),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SD instruction.  */\n   /* 9-24  */\n   COSTS_N_INSNS (24),\t\t\t/* cost of DIVSS instruction.  */\n   /* 9-27  */\n@@ -1155,9 +1191,12 @@ const struct processor_costs bdver2_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (52),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (2),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (6),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (6),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (6),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SD instruction.  */\n   /* 9-24  */\n   COSTS_N_INSNS (24),\t\t\t/* cost of DIVSS instruction.  */\n   /* 9-27  */\n@@ -1252,9 +1291,12 @@ struct processor_costs bdver3_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (52),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (2),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (6),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (6),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (6),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SD instruction.  */\n   /* 9-24  */\n   COSTS_N_INSNS (24),\t\t\t/* cost of DIVSS instruction.  */\n   /* 9-27  */\n@@ -1348,9 +1390,12 @@ struct processor_costs bdver4_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (52),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (2),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (6),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (6),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (6),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SD instruction.  */\n   /* 9-24  */\n   COSTS_N_INSNS (24),\t\t\t/* cost of DIVSS instruction.  */\n   /* 9-27  */\n@@ -1452,9 +1497,12 @@ struct processor_costs znver1_cost = {\n   /* Latency of fsqrt is 4-10.  */\n   COSTS_N_INSNS (10),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (1),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (4),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (5),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (5),\t\t\t/* cost of FMA SD instruction.  */\n   COSTS_N_INSNS (10),\t\t\t/* cost of DIVSS instruction.  */\n   /* 9-13  */\n   COSTS_N_INSNS (13),\t\t\t/* cost of DIVSD instruction.  */\n@@ -1558,9 +1606,12 @@ const struct processor_costs btver1_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (35),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (1),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (4),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (5),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (5),\t\t\t/* cost of FMA SD instruction.  */\n   COSTS_N_INSNS (13),\t\t\t/* cost of DIVSS instruction.  */\n   COSTS_N_INSNS (17),\t\t\t/* cost of DIVSD instruction.  */\n   COSTS_N_INSNS (14),\t\t\t/* cost of SQRTSS instruction.  */\n@@ -1652,9 +1703,12 @@ const struct processor_costs btver2_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (35),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (1),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (4),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (5),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (5),\t\t\t/* cost of FMA SD instruction.  */\n   COSTS_N_INSNS (13),\t\t\t/* cost of DIVSS instruction.  */\n   COSTS_N_INSNS (19),\t\t\t/* cost of DIVSD instruction.  */\n   COSTS_N_INSNS (16),\t\t\t/* cost of SQRTSS instruction.  */\n@@ -1737,9 +1791,12 @@ struct processor_costs pentium4_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (43),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (2),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (4),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (6),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (6),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SD instruction.  */\n   COSTS_N_INSNS (23),\t\t\t/* cost of DIVSS instruction.  */\n   COSTS_N_INSNS (38),\t\t\t/* cost of DIVSD instruction.  */\n   COSTS_N_INSNS (23),\t\t\t/* cost of SQRTSS instruction.  */\n@@ -1825,9 +1882,12 @@ struct processor_costs nocona_cost = {\n   COSTS_N_INSNS (3),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (44),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (2),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (5),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (7),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (7),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (7),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (7),\t\t\t/* cost of FMA SD instruction.  */\n   COSTS_N_INSNS (32),\t\t\t/* cost of DIVSS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of DIVSD instruction.  */\n   COSTS_N_INSNS (32),\t\t\t/* cost of SQRTSS instruction.  */\n@@ -1911,9 +1971,12 @@ struct processor_costs atom_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (1),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (5),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (4),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (5),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SD instruction.  */\n   COSTS_N_INSNS (31),\t\t\t/* cost of DIVSS instruction.  */\n   COSTS_N_INSNS (60),\t\t\t/* cost of DIVSD instruction.  */\n   COSTS_N_INSNS (31),\t\t\t/* cost of SQRTSS instruction.  */\n@@ -1997,9 +2060,12 @@ struct processor_costs slm_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (1),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (4),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (5),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SD instruction.  */\n   COSTS_N_INSNS (39),\t\t\t/* cost of DIVSS instruction.  */\n   COSTS_N_INSNS (69),\t\t\t/* cost of DIVSD instruction.  */\n   COSTS_N_INSNS (20),\t\t\t/* cost of SQRTSS instruction.  */\n@@ -2083,9 +2149,12 @@ struct processor_costs intel_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (8),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SD instruction.  */\n   COSTS_N_INSNS (20),\t\t\t/* cost of DIVSS instruction.  */\n   COSTS_N_INSNS (20),\t\t\t/* cost of DIVSD instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of SQRTSS instruction.  */\n@@ -2179,9 +2248,12 @@ struct processor_costs generic_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (8),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (8),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (8),\t\t\t/* cost of FMA SD instruction.  */\n   COSTS_N_INSNS (20),\t\t\t/* cost of DIVSS instruction.  */\n   COSTS_N_INSNS (20),\t\t\t/* cost of DIVSD instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of SQRTSS instruction.  */\n@@ -2274,9 +2346,12 @@ struct processor_costs core_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n \n+  COSTS_N_INSNS (1),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (4),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (5),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (5),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (5),\t\t\t/* cost of FMA SD instruction.  */\n   COSTS_N_INSNS (18),\t\t\t/* cost of DIVSS instruction.  */\n   COSTS_N_INSNS (32),\t\t\t/* cost of DIVSD instruction.  */\n   COSTS_N_INSNS (30),\t\t\t/* cost of SQRTSS instruction.  */"}]}