{"sha": "80906567f4c44f9127300aa3832b64a4ae77282f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA5MDY1NjdmNGM0NGY5MTI3MzAwYWEzODMyYjY0YTRhZTc3MjgyZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-11-15T17:48:28Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-11-15T17:48:28Z"}, "message": "(operand_equal_p): Do real comparison with REAL_VALUES_EQUAL.\n\n(make_range): Properly decide when to get TREE_TYPE of arg0.\nHandle EXP being an INTEGER_CST at end.\n(fold_range_test): Handle return of 0 from make_range.\n(fold, case TRUTH_AND_EXPR): Handle first arg of 0.\n(fold, case TRUTH_OR_EXPR): Handle first arg of 1.\n\nFrom-SVN: r13163", "tree": {"sha": "89b4801e57ae152185d142595ec116832f71eb91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89b4801e57ae152185d142595ec116832f71eb91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80906567f4c44f9127300aa3832b64a4ae77282f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80906567f4c44f9127300aa3832b64a4ae77282f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80906567f4c44f9127300aa3832b64a4ae77282f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80906567f4c44f9127300aa3832b64a4ae77282f/comments", "author": null, "committer": null, "parents": [{"sha": "5d9dd5a55ae713b6411311e08921955553146eac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d9dd5a55ae713b6411311e08921955553146eac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d9dd5a55ae713b6411311e08921955553146eac"}], "stats": {"total": 36, "additions": 29, "deletions": 7}, "files": [{"sha": "506edb0d4b05900bd7051e4f5871c1beb24aa8a7", "filename": "gcc/fold-const.c", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80906567f4c44f9127300aa3832b64a4ae77282f/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80906567f4c44f9127300aa3832b64a4ae77282f/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=80906567f4c44f9127300aa3832b64a4ae77282f", "patch": "@@ -1769,9 +1769,7 @@ operand_equal_p (arg0, arg1, only_const)\n   /* Detect when real constants are equal.  */\n   if (TREE_CODE (arg0) == TREE_CODE (arg1)\n       && TREE_CODE (arg0) == REAL_CST)\n-    return !bcmp ((char *) &TREE_REAL_CST (arg0),\n-\t\t  (char *) &TREE_REAL_CST (arg1),\n-\t\t  sizeof (REAL_VALUE_TYPE));\n+    return REAL_VALUES_EQUAL (TREE_REAL_CST (arg0), TREE_REAL_CST (arg1));\n \n   if (only_const)\n     return 0;\n@@ -2715,7 +2713,8 @@ make_range (exp, pin_p, plow, phigh)\n     {\n       code = TREE_CODE (exp);\n       arg0 = TREE_OPERAND (exp, 0), arg1 = TREE_OPERAND (exp, 1);\n-      if (arg0 != 0 && tree_code_length[(int) code] > 0)\n+      if (TREE_CODE_CLASS (code) == '<' || TREE_CODE_CLASS (code) == '1'\n+\t  || TREE_CODE_CLASS (code) == '2')\n \ttype = TREE_TYPE (arg0);\n \n       switch (code)\n@@ -2852,6 +2851,17 @@ make_range (exp, pin_p, plow, phigh)\n       break;\n     }\n \n+  /* If EXP is a constant, we can evaluate whether this is true or false.  */\n+  if (TREE_CODE (exp) == INTEGER_CST)\n+    {\n+      in_p = in_p == (integer_onep (range_binop (GE_EXPR, integer_type_node,\n+\t\t\t\t\t\t exp, 0, low, 0))\n+\t\t      && integer_onep (range_binop (LE_EXPR, integer_type_node,\n+\t\t\t\t\t\t    exp, 1, high, 1)));\n+      low = high = 0;\n+      exp = 0;\n+    }\n+\n   *pin_p = in_p, *plow = low, *phigh = high;\n   return exp;\n }\n@@ -3053,11 +3063,15 @@ fold_range_test (exp)\n     in0_p = ! in0_p, in1_p = ! in1_p;\n \n   /* If both expressions are the same, if we can merge the ranges, and we\n-     can build the range test, return it or it inverted.  */\n-  if (operand_equal_p (lhs, rhs, 0)\n+     can build the range test, return it or it inverted.  If one of the\n+     ranges is always true or always false, consider it to be the same\n+     expression as the other.  */\n+  if ((lhs == 0 || rhs == 0 || operand_equal_p (lhs, rhs, 0))\n       && merge_ranges (&in_p, &low, &high, in0_p, low0, high0,\n \t\t       in1_p, low1, high1)\n-      && 0 != (tem = (build_range_check (TREE_TYPE (exp), lhs,\n+      && 0 != (tem = (build_range_check (TREE_TYPE (exp),\n+\t\t\t\t\t lhs != 0 ? lhs\n+\t\t\t\t\t : rhs != 0 ? rhs : integer_zero_node,\n \t\t\t\t\t in_p, low, high))))\n     return or_op ? invert_truthvalue (tem) : tem;\n \n@@ -4733,6 +4747,10 @@ fold (expr)\n \t must be evaluated.  */\n       if (integer_zerop (arg1))\n \treturn omit_one_operand (type, arg1, arg0);\n+      /* Likewise for first arg, but note that only the TRUTH_AND_EXPR\n+\t case will be handled here.  */\n+      if (integer_zerop (arg0))\n+\treturn omit_one_operand (type, arg0, arg1);\n \n     truth_andor:\n       /* We only do these simplifications if we are optimizing.  */\n@@ -4813,6 +4831,10 @@ fold (expr)\n \t evaluate first arg.  */\n       if (TREE_CODE (arg1) == INTEGER_CST && ! integer_zerop (arg1))\n \treturn omit_one_operand (type, arg1, arg0);\n+      /* Likewise for first arg, but note this only occurs here for\n+\t TRUTH_OR_EXPR.  */\n+      if (TREE_CODE (arg0) == INTEGER_CST && ! integer_zerop (arg0))\n+\treturn omit_one_operand (type, arg0, arg1);\n       goto truth_andor;\n \n     case TRUTH_XOR_EXPR:"}]}