{"sha": "d6a2d36ee72dd89c72dbd05720fd4bc81e4b20e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZhMmQzNmVlNzJkZDg5YzcyZGJkMDU3MjBmZDRiYzgxZTRiMjBlMg==", "commit": {"author": {"name": "Ranjit Mathew", "email": "rmathew@hotmail.com", "date": "2003-02-10T23:52:56Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-02-10T23:52:56Z"}, "message": "Win32Process.java (destroy): Declare as native.\n\n2003-02-10  Ranjit Mathew  <rmathew@hotmail.com>\n\n\t* java/lang/Win32Process.java (destroy): Declare as native.\n\t(hasExited): New native method.\n\t(exitValue): Define.\n\t(getErrorStream): Likewise.\n\t(getInputStream): Likewise.\n\t(getOutputStream): Likewise.\n\t(waitFor): Declare as native.\n\t(startProcess): New native method.\n\t(cleanup): Likewise.\n\t(ConcreteProcess): Define.\n\t(outputStream, inputStream, errorStream): New members.\n\t(procHandle, exitCode): Likewise.\n\n\t* java/lang/natWin32Process.cc\n\t(java::lang::ConcreteProcess::cleanup): Define.\n\t(java::lang::ConcreteProcess::destroy): Likewise.\n\t(java::lang::ConcreteProcess::hasExited): Likewise.\n\t(java::lang::ConcreteProcess::waitFor): Likewise.\n\t(new_string): Likewise.\n\t(java::lang::ConcreteProcess::startProcess): Likewise.\n\nFrom-SVN: r62657", "tree": {"sha": "d76d0682ab2c7f55130f40b4332a102e90d49551", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d76d0682ab2c7f55130f40b4332a102e90d49551"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6a2d36ee72dd89c72dbd05720fd4bc81e4b20e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6a2d36ee72dd89c72dbd05720fd4bc81e4b20e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6a2d36ee72dd89c72dbd05720fd4bc81e4b20e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6a2d36ee72dd89c72dbd05720fd4bc81e4b20e2/comments", "author": null, "committer": null, "parents": [{"sha": "17e39e5c61a230520688ee9b5173e89aa3b772aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17e39e5c61a230520688ee9b5173e89aa3b772aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17e39e5c61a230520688ee9b5173e89aa3b772aa"}], "stats": {"total": 369, "additions": 349, "deletions": 20}, "files": [{"sha": "f5ec059558f5044ec8e92878d4b54b541ae1ac2e", "filename": "libjava/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a2d36ee72dd89c72dbd05720fd4bc81e4b20e2/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a2d36ee72dd89c72dbd05720fd4bc81e4b20e2/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=d6a2d36ee72dd89c72dbd05720fd4bc81e4b20e2", "patch": "@@ -1,3 +1,26 @@\n+2003-02-10  Ranjit Mathew  <rmathew@hotmail.com>\n+\n+\t* java/lang/Win32Process.java (destroy): Declare as native.\n+\t(hasExited): New native method.\n+\t(exitValue): Define.\n+\t(getErrorStream): Likewise.\n+\t(getInputStream): Likewise.\n+\t(getOutputStream): Likewise.\n+\t(waitFor): Declare as native.\n+\t(startProcess): New native method.\n+\t(cleanup): Likewise.\n+\t(ConcreteProcess): Define.\n+\t(outputStream, inputStream, errorStream): New members.\n+\t(procHandle, exitCode): Likewise.\n+\n+\t* java/lang/natWin32Process.cc\n+\t(java::lang::ConcreteProcess::cleanup): Define.\n+\t(java::lang::ConcreteProcess::destroy): Likewise.\n+\t(java::lang::ConcreteProcess::hasExited): Likewise.\n+\t(java::lang::ConcreteProcess::waitFor): Likewise.\n+\t(new_string): Likewise.\n+\t(java::lang::ConcreteProcess::startProcess): Likewise.\n+\n 2003-02-10  Raif S. Naffah <raif@fl.net.au>\n \n \t* java/math/BigInteger.java:"}, {"sha": "b1c7e0273797af0731f913d5690f49cc68bb00e2", "filename": "libjava/java/lang/Win32Process.java", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a2d36ee72dd89c72dbd05720fd4bc81e4b20e2/libjava%2Fjava%2Flang%2FWin32Process.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a2d36ee72dd89c72dbd05720fd4bc81e4b20e2/libjava%2Fjava%2Flang%2FWin32Process.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FWin32Process.java?ref=d6a2d36ee72dd89c72dbd05720fd4bc81e4b20e2", "patch": "@@ -1,6 +1,6 @@\n // Win32Process.java - Subclass of Process for Win32 systems.\n \n-/* Copyright (C) 2002  Free Software Foundation\n+/* Copyright (C) 2002, 2003  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -22,51 +22,63 @@\n \n // This is entirely internal to our implementation.\n \n-// NOTE: when this is implemented, we'll need to add\n-// HANDLE_FLAG_INHERIT in FileDescriptor and other places, to make\n-// sure that file descriptors aren't inherited by the child process.\n-// See _Jv_platform_close_on_exec.\n-\n // This file is copied to `ConcreteProcess.java' before compilation.\n // Hence the class name apparently does not match the file name.\n final class ConcreteProcess extends Process\n {\n-  public void destroy ()\n-  {\n-    throw new Error(\"not implemented\");\n-  }\n-  \n+  public native void destroy ();\n+\n+  public native boolean hasExited ();\n+\n   public int exitValue ()\n   {\n-    throw new Error(\"not implemented\");\n+    if (! hasExited ())\n+      throw new IllegalThreadStateException (\"Process has not exited\");\n+\n+    return exitCode;\n   }\n \n   public InputStream getErrorStream ()\n   {\n-    throw new Error(\"not implemented\");\n+    return errorStream;\n   }\n \n   public InputStream getInputStream ()\n   {\n-    throw new Error(\"not implemented\");\n+    return inputStream;\n   }\n \n   public OutputStream getOutputStream ()\n   {\n-    throw new Error(\"not implemented\");\n+    return outputStream;\n   }\n \n-  public int waitFor () throws InterruptedException\n-  {\n-    throw new Error(\"not implemented\");\n-  }\n+  public native int waitFor () throws InterruptedException;\n+\n+  public native void startProcess (String[] progarray,\n+\t\t\t\t   String[] envp,\n+\t\t\t\t   File dir)\n+    throws IOException;\n+\n+  public native void cleanup ();\n \n   public ConcreteProcess (String[] progarray,\n                           String[] envp,\n                           File dir)\n     throws IOException\n   {\n-    throw new IOException(\"not implemented\");\n+    startProcess (progarray, envp, dir);\n   }\n \n+  // The standard streams (stdin, stdout and stderr, respectively)\n+  // of the child as seen by the parent process.\n+  private OutputStream outputStream;\n+  private InputStream inputStream;\n+  private InputStream errorStream;\n+\n+  // Handle to the child process - cast to HANDLE before use.\n+  private int procHandle;\n+\n+  // Exit code of the child if it has exited.\n+  private int exitCode;\n }"}, {"sha": "38e6f9191742fadf18ff366f1e51ca1e81622661", "filename": "libjava/java/lang/natWin32Process.cc", "status": "modified", "additions": 294, "deletions": 0, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a2d36ee72dd89c72dbd05720fd4bc81e4b20e2/libjava%2Fjava%2Flang%2FnatWin32Process.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a2d36ee72dd89c72dbd05720fd4bc81e4b20e2/libjava%2Fjava%2Flang%2FnatWin32Process.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatWin32Process.cc?ref=d6a2d36ee72dd89c72dbd05720fd4bc81e4b20e2", "patch": "@@ -0,0 +1,294 @@\n+// natWin32Process.cc - Native side of Win32 process code.\n+\n+/* Copyright (C) 2003  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+\n+#include <stdio.h>\n+\n+#define WIN32_LEAN_AND_MEAN\n+#include <windows.h>\n+\n+// Conflicts with the definition in \"java/lang/reflect/Modifier.h\"\n+#undef STRICT\n+\n+#include <gcj/cni.h>\n+#include <jvm.h>\n+\n+#include <java/lang/ConcreteProcess.h>\n+#include <java/lang/IllegalThreadStateException.h>\n+#include <java/lang/InterruptedException.h>\n+#include <java/lang/NullPointerException.h>\n+#include <java/lang/Thread.h>\n+#include <java/io/File.h>\n+#include <java/io/FileDescriptor.h>\n+#include <java/io/FileInputStream.h>\n+#include <java/io/FileOutputStream.h>\n+#include <java/io/IOException.h>\n+#include <java/lang/OutOfMemoryError.h>\n+\n+void\n+java::lang::ConcreteProcess::cleanup (void)\n+{\n+  if (inputStream != NULL)\n+    {\n+      inputStream->close ();\n+      inputStream = NULL;\n+    }\n+\n+  if (outputStream != NULL)\n+    {\n+      outputStream->close ();\n+      outputStream = NULL;\n+    }\n+\n+  if (errorStream != NULL)\n+    {\n+      errorStream->close ();\n+      errorStream = NULL;\n+    }\n+}\n+\n+void\n+java::lang::ConcreteProcess::destroy (void)\n+{\n+  if (! hasExited ())\n+    {\n+      // Kill it forcibly and assign an (arbitrary) exit code of 0.\n+      TerminateProcess ((HANDLE) procHandle, 0);\n+      exitCode = 0;\n+\n+      cleanup ();\n+    }\n+}\n+\n+jboolean\n+java::lang::ConcreteProcess::hasExited (void)\n+{\n+  DWORD exitStatus;\n+\n+  if (GetExitCodeProcess ((HANDLE) procHandle, &exitStatus) != 0)\n+    {\n+      // NOTE: STILL_ACTIVE is defined as \"259\" by Win32 - if the\n+      // child actually exits with this return code, we have a\n+      // problem here. See MSDN documentation on GetExitCodeProcess( ).\n+\n+      if (exitStatus == STILL_ACTIVE)\n+        return false;\n+      else\n+        {\n+          cleanup ();\n+          exitCode = exitStatus;\n+          return true;\n+        }\n+    }\n+  else\n+    return true;\n+}\n+\n+jint\n+java::lang::ConcreteProcess::waitFor (void)\n+{\n+  if (! hasExited ())\n+    {\n+      DWORD exitStatus = 0UL;\n+\n+      // FIXME: The wait should be interruptible.\n+      WaitForSingleObject ((HANDLE) procHandle, INFINITE);\n+\n+      GetExitCodeProcess ((HANDLE) procHandle, &exitStatus);\n+      exitCode = exitStatus;\n+\n+      cleanup ();\n+    }\n+\n+  return exitCode;\n+}\n+\n+static char *\n+new_string (jstring string)\n+{\n+  jsize s = _Jv_GetStringUTFLength (string);\n+  char *buf = (char *) _Jv_Malloc (s + 1);\n+  _Jv_GetStringUTFRegion (string, 0, s, buf);\n+  buf[s] = '\\0';\n+  return buf;\n+}\n+\n+void\n+java::lang::ConcreteProcess::startProcess (jstringArray progarray,\n+                                           jstringArray envp,\n+                                           java::io::File *dir)\n+{\n+  using namespace java::io;\n+\n+  procHandle = (jint) INVALID_HANDLE_VALUE;\n+\n+  // Reconstruct the command line.\n+  jstring *elts = elements (progarray);\n+\n+  int cmdLineLen = 0;\n+\n+  for (int i = 0; i < progarray->length; ++i)\n+    cmdLineLen += (_Jv_GetStringUTFLength (elts[i]) + 1);\n+\n+  char *cmdLine = (char *) _Jv_Malloc (cmdLineLen + 1);\n+\n+  int j = 0;\n+  for (int i = 0; i < progarray->length; ++i)\n+    {\n+      jsize s = _Jv_GetStringUTFLength (elts[i]);\n+      _Jv_GetStringUTFRegion (elts[i], 0, s, (cmdLine + j));\n+\n+      j += s;\n+      *(cmdLine + j) = ' ';\n+      j++;\n+    }\n+  *(cmdLine + j) = '\\0';\n+\n+  // Get the environment, if any.\n+  char *env = NULL;\n+  if (envp)\n+    {\n+      elts = elements (envp);\n+\n+      int envLen = 0;\n+      for (int i = 0; i < envp->length; ++i)\n+        envLen += (_Jv_GetStringUTFLength (elts[i]) + 1);\n+\n+      env = (char *) _Jv_Malloc (envLen + 1);\n+\n+      int j = 0;\n+      for (int i = 0; i < envp->length; ++i)\n+        {\n+          jsize s = _Jv_GetStringUTFLength (elts[i]);\n+          _Jv_GetStringUTFRegion (elts[i], 0, s, (env + j));\n+\n+          j += s;\n+          *(env + j) = '\\0';\n+          j++;\n+        }\n+      *(env + j) = '\\0';\n+    }\n+\n+  // Get the working directory path, if specified.\n+  char *wdir = NULL;\n+  if (dir != NULL)\n+    wdir = new_string (dir->getPath ());\n+\n+  errorStream = NULL;\n+  inputStream = NULL;\n+  outputStream = NULL;\n+\n+  java::lang::Throwable *exc = NULL;\n+\n+  try\n+    {\n+      // We create anonymous pipes to communicate with the child\n+      // on each of standard streams.\n+\n+      HANDLE cldStdInRd, cldStdInWr;\n+      HANDLE cldStdOutRd, cldStdOutWr;\n+      HANDLE cldStdErrRd, cldStdErrWr;\n+\n+      SECURITY_ATTRIBUTES sAttrs;\n+\n+      // Explicitly allow the handles to the pipes to be inherited.\n+      sAttrs.nLength = sizeof (SECURITY_ATTRIBUTES);\n+      sAttrs.bInheritHandle = 1;\n+      sAttrs.lpSecurityDescriptor = NULL;\n+\n+\n+      char tmpBuff[64];\n+      if (CreatePipe (&cldStdInRd, &cldStdInWr, &sAttrs, 0) == 0)\n+        {\n+          sprintf (tmpBuff,\n+                   \"Error creating stdin pipe (Win32 Error Code: %lu)\",\n+                   GetLastError ());\n+          throw new IOException (JvNewStringLatin1 (tmpBuff));\n+        }\n+\n+      if (CreatePipe (&cldStdOutRd, &cldStdOutWr, &sAttrs, 0) == 0)\n+        {\n+          sprintf (tmpBuff,\n+                   \"Error creating stdout pipe (Win32 Error Code: %lu)\",\n+                   GetLastError ());\n+          throw new IOException (JvNewStringLatin1 (tmpBuff));\n+        }\n+\n+      if (CreatePipe (&cldStdErrRd, &cldStdErrWr, &sAttrs, 0) == 0)\n+        {\n+          sprintf (tmpBuff,\n+                   \"Error creating stderr pipe (Win32 Error Code: %lu)\",\n+                   GetLastError ());\n+          throw new IOException (JvNewStringLatin1 (tmpBuff));\n+        }\n+\n+      outputStream = new FileOutputStream\n+                         (new FileDescriptor ((jint) cldStdInWr));\n+      inputStream = new FileInputStream\n+                        (new FileDescriptor ((jint) cldStdOutRd));\n+      errorStream = new FileInputStream\n+                        (new FileDescriptor ((jint) cldStdErrRd));\n+\n+      // Now create the child process.\n+      PROCESS_INFORMATION pi;\n+      STARTUPINFO si;\n+\n+      ZeroMemory (&pi, sizeof (PROCESS_INFORMATION));\n+\n+      ZeroMemory (&si, sizeof (STARTUPINFO));\n+      si.cb = sizeof (STARTUPINFO);\n+\n+      // Explicitly specify the handles to the standard streams.\n+      si.dwFlags |= STARTF_USESTDHANDLES;\n+\n+      si.hStdInput = cldStdInRd;\n+      si.hStdOutput = cldStdOutWr;\n+      si.hStdError = cldStdErrWr;\n+\n+      if (CreateProcess (NULL,\n+                         cmdLine,\n+                         NULL,\n+                         NULL,\n+                         1,\n+                         0,\n+                         env,\n+                         wdir,\n+                         &si,\n+                         &pi) == 0)\n+        {\n+          sprintf (tmpBuff,\n+                   \"Error creating child process (Win32 Error Code: %lu)\",\n+                   GetLastError ());\n+          throw new IOException (JvNewStringLatin1 (tmpBuff));\n+        }\n+\n+      procHandle = (jint ) pi.hProcess;\n+\n+      // Close the wrong ends (for the parent) of the pipes.\n+      CloseHandle (cldStdInRd);\n+      CloseHandle (cldStdOutWr);\n+      CloseHandle (cldStdErrWr);\n+\n+      _Jv_Free (cmdLine);\n+      if (env != NULL)\n+        _Jv_Free (env);\n+      if (wdir != NULL)\n+        _Jv_Free (wdir);\n+    }\n+  catch (java::lang::Throwable *thrown)\n+    {\n+      cleanup ();\n+      exc = thrown;\n+    }\n+\n+  if (exc != NULL)\n+    throw exc;\n+}"}]}