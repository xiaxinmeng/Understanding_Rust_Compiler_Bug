{"sha": "927734cfafbc115c51401621f37d17b56b162d2a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI3NzM0Y2ZhZmJjMTE1YzUxNDAxNjIxZjM3ZDE3YjU2YjE2MmQyYQ==", "commit": {"author": {"name": "Xinliang David Li", "email": "davidxl@google.com", "date": "2014-01-03T00:40:57Z"}, "committer": {"name": "Xinliang David Li", "email": "davidxl@gcc.gnu.org", "date": "2014-01-03T00:40:57Z"}, "message": "Fix PR/59303 -- uninit analysis enhancement\n\nFrom-SVN: r206309", "tree": {"sha": "5d32571e3c899e125d23b49c58f5cd5e6465e978", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d32571e3c899e125d23b49c58f5cd5e6465e978"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/927734cfafbc115c51401621f37d17b56b162d2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/927734cfafbc115c51401621f37d17b56b162d2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/927734cfafbc115c51401621f37d17b56b162d2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/927734cfafbc115c51401621f37d17b56b162d2a/comments", "author": {"login": "vns-mn", "id": 57157229, "node_id": "MDQ6VXNlcjU3MTU3MjI5", "avatar_url": "https://avatars.githubusercontent.com/u/57157229?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vns-mn", "html_url": "https://github.com/vns-mn", "followers_url": "https://api.github.com/users/vns-mn/followers", "following_url": "https://api.github.com/users/vns-mn/following{/other_user}", "gists_url": "https://api.github.com/users/vns-mn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vns-mn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vns-mn/subscriptions", "organizations_url": "https://api.github.com/users/vns-mn/orgs", "repos_url": "https://api.github.com/users/vns-mn/repos", "events_url": "https://api.github.com/users/vns-mn/events{/privacy}", "received_events_url": "https://api.github.com/users/vns-mn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c8ee48b8f96cbba05b2ddf124eb73bf90786b666", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8ee48b8f96cbba05b2ddf124eb73bf90786b666", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8ee48b8f96cbba05b2ddf124eb73bf90786b666"}], "stats": {"total": 1520, "additions": 868, "deletions": 652}, "files": [{"sha": "bfe89d486bdf0e0944c9305cc1ec05e3443e5969", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/927734cfafbc115c51401621f37d17b56b162d2a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/927734cfafbc115c51401621f37d17b56b162d2a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=927734cfafbc115c51401621f37d17b56b162d2a", "patch": "@@ -1,3 +1,46 @@\n+2014-01-02  Xinliang David Li  <davidxl@google.com>\n+\n+\tPR tree-optimization/59303\n+\t* tree-ssa-uninit.c (is_use_properly_guarded):\n+\tMain cleanup.\n+\t(dump_predicates): Better output format.\n+\t(pred_equal_p): New function.\n+\t(is_neq_relop_p): Ditto.\n+\t(is_neq_zero_form_p): Ditto.\n+\t(pred_expr_equal_p): Ditto.\n+\t(pred_neg_p): Ditto.\n+\t(simplify_pred): Ditto.\n+\t(simplify_preds_2): Ditto.\n+\t(simplify_preds_3): Ditto.\n+\t(simplify_preds_4): Ditto.\n+\t(simplify_preds): Ditto.\n+\t(push_pred): Ditto.\n+\t(push_to_worklist): Ditto.\n+\t(get_pred_info_from_cmp): Ditto.\n+\t(is_degenerated_phi): Ditto.\n+\t(normalize_one_pred_1): Ditto.\n+\t(normalize_one_pred): Ditto.\n+\t(normalize_one_pred_chain): Ditto.\n+\t(normalize_preds): Ditto.\n+\t(normalize_cond_1): Remove function.\n+\t(normalize_cond): Ditto.\n+\t(is_gcond_subset_of): Ditto.\n+\t(is_subset_of_any): Ditto.\n+\t(is_or_set_subset_of): Ditto.\n+\t(is_and_set_subset_of): Ditto.\n+\t(is_norm_cond_subset_of): Ditto.\n+\t(pred_chain_length_cmp): Ditto.\n+\t(convert_control_dep_chain_into_preds): Type change.\n+\t(find_predicates): Ditto.\n+\t(find_def_preds): Ditto.\n+\t(destroy_predicates_vecs): Ditto.\n+\t(find_matching_predicates_in_rest_chains): Ditto.\n+\t(use_pred_not_overlap_with_undef_path_pred): Ditto.\n+\t(is_pred_expr_subset): Ditto.\n+\t(is_pred_chain_subset_of): Ditto.\n+\t(is_included_in): Ditto.\n+\t(is_superset_of): Ditto.\n+\n 2014-01-02  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \tUpdate copyright years"}, {"sha": "2b55e1077af272c62203854258fb96c4880a80ac", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 825, "deletions": 652, "changes": 1477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/927734cfafbc115c51401621f37d17b56b162d2a/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/927734cfafbc115c51401621f37d17b56b162d2a/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=927734cfafbc115c51401621f37d17b56b162d2a", "patch": "@@ -59,7 +59,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Pointer set of potentially undefined ssa names, i.e.,\n    ssa names that are defined by phi with operands that\n    are not defined or potentially undefined.  */\n-static struct pointer_set_t *possibly_undefined_names = 0;\n+static pointer_set_t *possibly_undefined_names = 0;\n \n /* Bit mask handling macros.  */\n #define MASK_SET_BIT(mask, pos) mask |= (1 << pos)\n@@ -233,7 +233,7 @@ warn_uninitialized_vars (bool warn_possibly_uninitialized)\n \t\tcontinue;\n \n \t      if (always_executed)\n-\t\twarn_uninit (OPT_Wuninitialized, use, \n+\t\twarn_uninit (OPT_Wuninitialized, use,\n \t\t\t     gimple_assign_rhs1 (stmt), base,\n \t\t\t     \"%qE is used uninitialized in this function\",\n \t\t\t     stmt);\n@@ -249,9 +249,9 @@ warn_uninitialized_vars (bool warn_possibly_uninitialized)\n   return 0;\n }\n \n-/* Checks if the operand OPND of PHI is defined by \n-   another phi with one operand defined by this PHI, \n-   but the rest operands are all defined. If yes, \n+/* Checks if the operand OPND of PHI is defined by\n+   another phi with one operand defined by this PHI,\n+   but the rest operands are all defined. If yes,\n    returns true to skip this this operand as being\n    redundant. Can be enhanced to be more general.  */\n \n@@ -411,15 +411,15 @@ compute_control_dep_chain (basic_block bb, basic_block dep_bb,\n   if (EDGE_COUNT (bb->succs) < 2)\n     return false;\n \n-  /* Could  use a set instead.  */\n+  /* Could use a set instead.  */\n   cur_chain_len = cur_cd_chain->length ();\n   if (cur_chain_len > MAX_CHAIN_LEN)\n     return false;\n \n   for (i = 0; i < cur_chain_len; i++)\n     {\n       edge e = (*cur_cd_chain)[i];\n-      /* cycle detected. */\n+      /* Cycle detected. */\n       if (e->src == bb)\n         return false;\n     }\n@@ -444,7 +444,7 @@ compute_control_dep_chain (basic_block bb, basic_block dep_bb,\n                   (*num_chains)++;\n                 }\n               found_cd_chain = true;\n-              /* check path from next edge.  */\n+              /* Check path from next edge.  */\n               break;\n             }\n \n@@ -470,30 +470,41 @@ compute_control_dep_chain (basic_block bb, basic_block dep_bb,\n   return found_cd_chain;\n }\n \n-typedef struct use_pred_info\n+/* The type to represent a simple predicate  */\n+\n+typedef struct use_def_pred_info\n {\n-  gimple cond;\n+  tree pred_lhs;\n+  tree pred_rhs;\n+  enum tree_code cond_code;\n   bool invert;\n-} *use_pred_info_t;\n+} pred_info;\n+\n+/* The type to represent a sequence of predicates grouped\n+  with .AND. operation.  */\n \n+typedef vec<pred_info, va_heap, vl_ptr> pred_chain;\n \n+/* The type to represent a sequence of pred_chains grouped\n+  with .OR. operation.  */\n+\n+typedef vec<pred_chain, va_heap, vl_ptr> pred_chain_union;\n \n /* Converts the chains of control dependence edges into a set of\n    predicates. A control dependence chain is represented by a vector\n    edges. DEP_CHAINS points to an array of dependence chains.\n    NUM_CHAINS is the size of the chain array. One edge in a dependence\n-   chain is mapped to predicate expression represented by use_pred_info_t\n+   chain is mapped to predicate expression represented by pred_info\n    type. One dependence chain is converted to a composite predicate that\n-   is the result of AND operation of use_pred_info_t mapped to each edge.\n-   A composite predicate is presented by a vector of use_pred_info_t. On\n+   is the result of AND operation of pred_info mapped to each edge.\n+   A composite predicate is presented by a vector of pred_info. On\n    return, *PREDS points to the resulting array of composite predicates.\n    *NUM_PREDS is the number of composite predictes.  */\n \n static bool\n convert_control_dep_chain_into_preds (vec<edge> *dep_chains,\n                                       size_t num_chains,\n-                                      vec<use_pred_info_t> **preds,\n-                                      size_t *num_preds)\n+                                      pred_chain_union *preds)\n {\n   bool has_valid_pred = false;\n   size_t i, j;\n@@ -502,21 +513,20 @@ convert_control_dep_chain_into_preds (vec<edge> *dep_chains,\n \n   /* Now convert the control dep chain into a set\n      of predicates.  */\n-  typedef vec<use_pred_info_t> vec_use_pred_info_t_heap;\n-  *preds = XCNEWVEC (vec_use_pred_info_t_heap, num_chains);\n-  *num_preds = num_chains;\n+  preds->reserve (num_chains);\n \n   for (i = 0; i < num_chains; i++)\n     {\n       vec<edge> one_cd_chain = dep_chains[i];\n \n       has_valid_pred = false;\n+      pred_chain t_chain = vNULL;\n       for (j = 0; j < one_cd_chain.length (); j++)\n         {\n           gimple cond_stmt;\n           gimple_stmt_iterator gsi;\n           basic_block guard_bb;\n-          use_pred_info_t one_pred;\n+          pred_info one_pred;\n           edge e;\n \n           e = one_cd_chain[j];\n@@ -528,7 +538,7 @@ convert_control_dep_chain_into_preds (vec<edge> *dep_chains,\n               break;\n             }\n           cond_stmt = gsi_stmt (gsi);\n-          if (gimple_code (cond_stmt) == GIMPLE_CALL\n+          if (is_gimple_call (cond_stmt)\n               && EDGE_COUNT (e->src->succs) >= 2)\n             {\n               /* Ignore EH edge. Can add assertion\n@@ -558,15 +568,18 @@ convert_control_dep_chain_into_preds (vec<edge> *dep_chains,\n               has_valid_pred = false;\n               break;\n             }\n-          one_pred = XNEW (struct use_pred_info);\n-          one_pred->cond = cond_stmt;\n-          one_pred->invert = !!(e->flags & EDGE_FALSE_VALUE);\n-          (*preds)[i].safe_push (one_pred);\n+          one_pred.pred_lhs = gimple_cond_lhs (cond_stmt);\n+          one_pred.pred_rhs = gimple_cond_rhs (cond_stmt);\n+          one_pred.cond_code = gimple_cond_code (cond_stmt);\n+          one_pred.invert = !!(e->flags & EDGE_FALSE_VALUE);\n+          t_chain.safe_push (one_pred);\n \t  has_valid_pred = true;\n         }\n \n       if (!has_valid_pred)\n         break;\n+      else\n+        preds->safe_push (t_chain);\n     }\n   return has_valid_pred;\n }\n@@ -577,8 +590,7 @@ convert_control_dep_chain_into_preds (vec<edge> *dep_chains,\n    the phi whose result is used in USE_BB.  */\n \n static bool\n-find_predicates (vec<use_pred_info_t> **preds,\n-                 size_t *num_preds,\n+find_predicates (pred_chain_union *preds,\n                  basic_block phi_bb,\n                  basic_block use_bb)\n {\n@@ -610,8 +622,7 @@ find_predicates (vec<use_pred_info_t> **preds,\n   has_valid_pred\n       = convert_control_dep_chain_into_preds (dep_chains,\n                                               num_chains,\n-                                              preds,\n-                                              num_preds);\n+                                              preds);\n   /* Free individual chain  */\n   cur_chain.release ();\n   for (i = 0; i < num_chains; i++)\n@@ -629,7 +640,7 @@ find_predicates (vec<use_pred_info_t> **preds,\n static void\n collect_phi_def_edges (gimple phi, basic_block cd_root,\n                        vec<edge> *edges,\n-                       struct pointer_set_t *visited_phis)\n+                       pointer_set_t *visited_phis)\n {\n   size_t i, n;\n   edge opnd_edge;\n@@ -680,16 +691,15 @@ collect_phi_def_edges (gimple phi, basic_block cd_root,\n    composite predicates pointed to by PREDS.  */\n \n static bool\n-find_def_preds (vec<use_pred_info_t> **preds,\n-                size_t *num_preds, gimple phi)\n+find_def_preds (pred_chain_union *preds, gimple phi)\n {\n   size_t num_chains = 0, i, n;\n   vec<edge> *dep_chains = 0;\n   vec<edge> cur_chain = vNULL;\n   vec<edge> def_edges = vNULL;\n   bool has_valid_pred = false;\n   basic_block phi_bb, cd_root = 0;\n-  struct pointer_set_t *visited_phis;\n+  pointer_set_t *visited_phis;\n \n   typedef vec<edge> vec_edge_heap;\n   dep_chains = XCNEWVEC (vec_edge_heap, MAX_NUM_CHAINS);\n@@ -739,8 +749,7 @@ find_def_preds (vec<use_pred_info_t> **preds,\n   has_valid_pred\n       = convert_control_dep_chain_into_preds (dep_chains,\n                                               num_chains,\n-                                              preds,\n-                                              num_preds);\n+                                              preds);\n   for (i = 0; i < num_chains; i++)\n     dep_chains[i].release ();\n   free (dep_chains);\n@@ -750,16 +759,16 @@ find_def_preds (vec<use_pred_info_t> **preds,\n /* Dumps the predicates (PREDS) for USESTMT.  */\n \n static void\n-dump_predicates (gimple usestmt, size_t num_preds,\n-                 vec<use_pred_info_t> *preds,\n+dump_predicates (gimple usestmt, pred_chain_union preds,\n                  const char* msg)\n {\n   size_t i, j;\n-  vec<use_pred_info_t> one_pred_chain;\n+  pred_chain one_pred_chain = vNULL;\n   fprintf (dump_file, msg);\n   print_gimple_stmt (dump_file, usestmt, 0, 0);\n-  fprintf (dump_file, \"is guarded by :\\n\");\n-  /* do some dumping here:  */\n+  fprintf (dump_file, \"is guarded by :\\n\\n\");\n+  size_t num_preds = preds.length ();\n+  /* Do some dumping here:  */\n   for (i = 0; i < num_preds; i++)\n     {\n       size_t np;\n@@ -769,37 +778,39 @@ dump_predicates (gimple usestmt, size_t num_preds,\n \n       for (j = 0; j < np; j++)\n         {\n-          use_pred_info_t one_pred\n-              = one_pred_chain[j];\n-          if (one_pred->invert)\n+          pred_info one_pred = one_pred_chain[j];\n+          if (one_pred.invert)\n             fprintf (dump_file, \" (.NOT.) \");\n-          print_gimple_stmt (dump_file, one_pred->cond, 0, 0);\n+          print_generic_expr (dump_file, one_pred.pred_lhs, 0);\n+          fprintf (dump_file, \" %s \", op_symbol_code (one_pred.cond_code));\n+          print_generic_expr (dump_file, one_pred.pred_rhs, 0);\n           if (j < np - 1)\n-            fprintf (dump_file, \"(.AND.)\\n\");\n+            fprintf (dump_file, \" (.AND.) \");\n+          else\n+            fprintf (dump_file, \"\\n\");\n         }\n       if (i < num_preds - 1)\n         fprintf (dump_file, \"(.OR.)\\n\");\n+      else\n+        fprintf (dump_file, \"\\n\\n\");\n     }\n }\n \n /* Destroys the predicate set *PREDS.  */\n \n static void\n-destroy_predicate_vecs (size_t n,\n-                        vec<use_pred_info_t> * preds)\n+destroy_predicate_vecs (pred_chain_union preds)\n {\n-  size_t i, j;\n+  size_t i;\n+\n+  size_t n = preds.length ();\n   for (i = 0; i < n; i++)\n-    {\n-      for (j = 0; j < preds[i].length (); j++)\n-        free (preds[i][j]);\n-      preds[i].release ();\n-    }\n-  free (preds);\n+    preds[i].release ();\n+  preds.release ();\n }\n \n \n-/* Computes the 'normalized' conditional code with operand \n+/* Computes the 'normalized' conditional code with operand\n    swapping and condition inversion.  */\n \n static enum tree_code\n@@ -890,33 +901,33 @@ is_value_included_in (tree val, tree boundary, enum tree_code cmpc)\n    NUM_PRED_CHAIN is the size of array PREDS.  */\n \n static bool\n-find_matching_predicate_in_rest_chains (use_pred_info_t pred,\n-                                        vec<use_pred_info_t> *preds,\n+find_matching_predicate_in_rest_chains (pred_info pred,\n+                                        pred_chain_union preds,\n                                         size_t num_pred_chains)\n {\n   size_t i, j, n;\n \n-  /* trival case  */\n+  /* Trival case.  */\n   if (num_pred_chains == 1)\n     return true;\n \n   for (i = 1; i < num_pred_chains; i++)\n     {\n       bool found = false;\n-      vec<use_pred_info_t> one_chain = preds[i];\n+      pred_chain one_chain = preds[i];\n       n = one_chain.length ();\n       for (j = 0; j < n; j++)\n         {\n-          use_pred_info_t pred2\n-              = one_chain[j];\n-          /* can relax the condition comparison to not\n+          pred_info pred2 = one_chain[j];\n+          /* Can relax the condition comparison to not\n              use address comparison. However, the most common\n              case is that multiple control dependent paths share\n              a common path prefix, so address comparison should\n              be ok.  */\n \n-          if (pred2->cond == pred->cond\n-              && pred2->invert == pred->invert)\n+          if (operand_equal_p (pred2.pred_lhs, pred.pred_lhs, 0)\n+              && operand_equal_p (pred2.pred_rhs, pred.pred_rhs, 0)\n+              && pred2.invert == pred.invert)\n             {\n               found = true;\n               break;\n@@ -934,7 +945,7 @@ is_use_properly_guarded (gimple use_stmt,\n                          basic_block use_bb,\n                          gimple phi,\n                          unsigned uninit_opnds,\n-                         struct pointer_set_t *visited_phis);\n+                         pointer_set_t *visited_phis);\n \n /* Returns true if all uninitialized opnds are pruned. Returns false\n    otherwise. PHI is the phi node with uninitialized operands,\n@@ -971,12 +982,13 @@ is_use_properly_guarded (gimple use_stmt,\n */\n \n static bool\n-prune_uninit_phi_opnds_in_unrealizable_paths (\n-    gimple phi, unsigned uninit_opnds,\n-    gimple flag_def, tree boundary_cst,\n-    enum tree_code cmp_code,\n-    struct pointer_set_t *visited_phis,\n-    bitmap *visited_flag_phis)\n+prune_uninit_phi_opnds_in_unrealizable_paths (gimple phi,\n+\t\t\t\t\t      unsigned uninit_opnds,\n+\t\t\t\t\t      gimple flag_def,\n+\t\t\t\t\t      tree boundary_cst,\n+\t\t\t\t\t      enum tree_code cmp_code,\n+\t\t\t\t\t      pointer_set_t *visited_phis,\n+\t\t\t\t\t      bitmap *visited_flag_phis)\n {\n   unsigned i;\n \n@@ -1023,10 +1035,9 @@ prune_uninit_phi_opnds_in_unrealizable_paths (\n \n           /* Now recursively prune the uninitialized phi args.  */\n           uninit_opnds_arg_phi = compute_uninit_opnds_pos (phi_arg_def);\n-          if (!prune_uninit_phi_opnds_in_unrealizable_paths (\n-                  phi_arg_def, uninit_opnds_arg_phi,\n-                  flag_arg_def, boundary_cst, cmp_code,\n-                  visited_phis, visited_flag_phis))\n+          if (!prune_uninit_phi_opnds_in_unrealizable_paths\n+\t\t (phi_arg_def, uninit_opnds_arg_phi, flag_arg_def,\n+\t\t  boundary_cst, cmp_code, visited_phis, visited_flag_phis))\n             return false;\n \n           bitmap_clear_bit (*visited_flag_phis,\n@@ -1144,21 +1155,20 @@ prune_uninit_phi_opnds_in_unrealizable_paths (\n \n \n static bool\n-use_pred_not_overlap_with_undef_path_pred (\n-    size_t num_preds,\n-    vec<use_pred_info_t> *preds,\n-    gimple phi, unsigned uninit_opnds,\n-    struct pointer_set_t *visited_phis)\n+use_pred_not_overlap_with_undef_path_pred (pred_chain_union preds,\n+\t\t\t\t           gimple phi, unsigned uninit_opnds,\n+\t\t\t\t\t   pointer_set_t *visited_phis)\n {\n   unsigned int i, n;\n   gimple flag_def = 0;\n   tree  boundary_cst = 0;\n   enum tree_code cmp_code;\n   bool swap_cond = false;\n   bool invert = false;\n-  vec<use_pred_info_t> the_pred_chain;\n+  pred_chain the_pred_chain = vNULL;\n   bitmap visited_flag_phis = NULL;\n   bool all_pruned = false;\n+  size_t num_preds = preds.length ();\n \n   gcc_assert (num_preds > 0);\n   /* Find within the common prefix of multiple predicate chains\n@@ -1168,17 +1178,14 @@ use_pred_not_overlap_with_undef_path_pred (\n   n = the_pred_chain.length ();\n   for (i = 0; i < n; i++)\n     {\n-      gimple cond;\n       tree cond_lhs, cond_rhs, flag = 0;\n \n-      use_pred_info_t the_pred\n-          = the_pred_chain[i];\n+      pred_info the_pred = the_pred_chain[i];\n \n-      cond = the_pred->cond;\n-      invert = the_pred->invert;\n-      cond_lhs = gimple_cond_lhs (cond);\n-      cond_rhs = gimple_cond_rhs (cond);\n-      cmp_code = gimple_cond_code (cond);\n+      invert = the_pred.invert;\n+      cond_lhs = the_pred.pred_lhs;\n+      cond_rhs = the_pred.pred_rhs;\n+      cmp_code = the_pred.cond_code;\n \n       if (cond_lhs != NULL_TREE && TREE_CODE (cond_lhs) == SSA_NAME\n           && cond_rhs != NULL_TREE && is_gimple_constant (cond_rhs))\n@@ -1204,8 +1211,8 @@ use_pred_not_overlap_with_undef_path_pred (\n \n       if ((gimple_code (flag_def) == GIMPLE_PHI)\n           && (gimple_bb (flag_def) == gimple_bb (phi))\n-          && find_matching_predicate_in_rest_chains (\n-              the_pred, preds, num_preds))\n+          && find_matching_predicate_in_rest_chains (the_pred, preds,\n+\t\t\t\t\t\t     num_preds))\n         break;\n \n       flag_def = 0;\n@@ -1235,668 +1242,847 @@ use_pred_not_overlap_with_undef_path_pred (\n   return all_pruned;\n }\n \n-/* Returns true if TC is AND or OR */\n+/* The helper function returns true if two predicates X1 and X2\n+   are equivalent. It assumes the expressions have already\n+   properly re-associated.  */\n \n static inline bool\n-is_and_or_or (enum tree_code tc, tree typ)\n+pred_equal_p (pred_info x1, pred_info x2)\n {\n-  return (tc == BIT_IOR_EXPR\n-          || (tc == BIT_AND_EXPR\n-              && (typ == 0 || TREE_CODE (typ) == BOOLEAN_TYPE)));\n-}\n+  enum tree_code c1, c2;\n+  if (!operand_equal_p (x1.pred_lhs, x2.pred_lhs, 0)\n+      || !operand_equal_p (x1.pred_rhs, x2.pred_rhs, 0))\n+    return false;\n \n-typedef struct norm_cond\n-{\n-  vec<gimple> conds;\n-  enum tree_code cond_code;\n-  bool invert;\n-} *norm_cond_t;\n+  c1 = x1.cond_code;\n+  if (x1.invert != x2.invert)\n+    c2 = invert_tree_comparison (x2.cond_code, false);\n+  else\n+    c2 = x2.cond_code;\n \n+  return c1 == c2;\n+}\n \n-/* Normalizes gimple condition COND. The normalization follows\n-   UD chains to form larger condition expression trees. NORM_COND\n-   holds the normalized result. COND_CODE is the logical opcode\n-   (AND or OR) of the normalized tree.  */\n+/* Returns true if the predication is testing !=.  */\n \n-static void\n-normalize_cond_1 (gimple cond,\n-                  norm_cond_t norm_cond,\n-                  enum tree_code cond_code)\n+static inline bool\n+is_neq_relop_p (pred_info pred)\n {\n-  enum gimple_code gc;\n-  enum tree_code cur_cond_code;\n-  tree rhs1, rhs2;\n-\n-  gc = gimple_code (cond);\n-  if (gc != GIMPLE_ASSIGN)\n-    {\n-      norm_cond->conds.safe_push (cond);\n-      return;\n-    }\n \n-  cur_cond_code = gimple_assign_rhs_code (cond);\n-  rhs1 = gimple_assign_rhs1 (cond);\n-  rhs2 = gimple_assign_rhs2 (cond);\n-  if (cur_cond_code == NE_EXPR)\n-    {\n-      if (integer_zerop (rhs2)\n-          && (TREE_CODE (rhs1) == SSA_NAME))\n-        normalize_cond_1 (\n-            SSA_NAME_DEF_STMT (rhs1),\n-            norm_cond, cond_code);\n-      else if (integer_zerop (rhs1)\n-               && (TREE_CODE (rhs2) == SSA_NAME))\n-        normalize_cond_1 (\n-            SSA_NAME_DEF_STMT (rhs2),\n-            norm_cond, cond_code);\n-      else\n-        norm_cond->conds.safe_push (cond);\n-\n-      return;\n-    }\n-\n-  if (is_and_or_or (cur_cond_code, TREE_TYPE (rhs1))\n-      && (cond_code == cur_cond_code || cond_code == ERROR_MARK)\n-      && (TREE_CODE (rhs1) == SSA_NAME && TREE_CODE (rhs2) == SSA_NAME))\n-    {\n-      normalize_cond_1 (SSA_NAME_DEF_STMT (rhs1),\n-                        norm_cond, cur_cond_code);\n-      normalize_cond_1 (SSA_NAME_DEF_STMT (rhs2),\n-                        norm_cond, cur_cond_code);\n-      norm_cond->cond_code = cur_cond_code;\n-    }\n-  else\n-    norm_cond->conds.safe_push (cond);\n+  return (pred.cond_code == NE_EXPR && !pred.invert) \n+          || (pred.cond_code == EQ_EXPR && pred.invert);\n }\n \n-/* See normalize_cond_1 for details. INVERT is a flag to indicate\n-   if COND needs to be inverted or not.  */\n+/* Returns true if pred is of the form X != 0.  */\n \n-static void\n-normalize_cond (gimple cond, norm_cond_t norm_cond, bool invert)\n+static inline bool \n+is_neq_zero_form_p (pred_info pred)\n {\n-  enum tree_code cond_code;\n+  if (!is_neq_relop_p (pred) || !integer_zerop (pred.pred_rhs)\n+      || TREE_CODE (pred.pred_lhs) != SSA_NAME)\n+    return false;\n+  return true;\n+}\n \n-  norm_cond->cond_code = ERROR_MARK;\n-  norm_cond->invert = false;\n-  norm_cond->conds.create (0);\n-  gcc_assert (gimple_code (cond) == GIMPLE_COND);\n-  cond_code = gimple_cond_code (cond);\n-  if (invert)\n-    cond_code = invert_tree_comparison (cond_code, false);\n+/* The helper function returns true if two predicates X1\n+   is equivalent to X2 != 0.  */\n \n-  if (cond_code == NE_EXPR)\n-    {\n-      if (integer_zerop (gimple_cond_rhs (cond))\n-          && (TREE_CODE (gimple_cond_lhs (cond)) == SSA_NAME))\n-        normalize_cond_1 (\n-            SSA_NAME_DEF_STMT (gimple_cond_lhs (cond)),\n-            norm_cond, ERROR_MARK);\n-      else if (integer_zerop (gimple_cond_lhs (cond))\n-               && (TREE_CODE (gimple_cond_rhs (cond)) == SSA_NAME))\n-        normalize_cond_1 (\n-            SSA_NAME_DEF_STMT (gimple_cond_rhs (cond)),\n-            norm_cond, ERROR_MARK);\n-      else\n-        {\n-          norm_cond->conds.safe_push (cond);\n-          norm_cond->invert = invert;\n-        }\n-    }\n-  else\n-    {\n-      norm_cond->conds.safe_push (cond);\n-      norm_cond->invert = invert;\n-    }\n+static inline bool\n+pred_expr_equal_p (pred_info x1, tree x2)\n+{\n+  if (!is_neq_zero_form_p (x1))\n+    return false;\n \n-  gcc_assert (norm_cond->conds.length () == 1\n-              || is_and_or_or (norm_cond->cond_code, NULL));\n+  return operand_equal_p (x1.pred_lhs, x2, 0);\n }\n \n-/* Returns true if the domain for condition COND1 is a subset of\n-   COND2. REVERSE is a flag. when it is true the function checks\n-   if COND1 is a superset of COND2. INVERT1 and INVERT2 are flags\n-   to indicate if COND1 and COND2 need to be inverted or not.  */\n+/* Returns true of the domain of single predicate expression\n+   EXPR1 is a subset of that of EXPR2. Returns false if it\n+   can not be proved.  */\n \n static bool\n-is_gcond_subset_of (gimple cond1, bool invert1,\n-                    gimple cond2, bool invert2,\n-                    bool reverse)\n+is_pred_expr_subset_of (pred_info expr1, pred_info expr2)\n {\n-  enum gimple_code gc1, gc2;\n-  enum tree_code cond1_code, cond2_code;\n-  gimple tmp;\n-  tree cond1_lhs, cond1_rhs, cond2_lhs, cond2_rhs;\n+  enum tree_code code1, code2;\n \n-  /* Take the short cut.  */\n-  if (cond1 == cond2)\n+  if (pred_equal_p (expr1, expr2))\n     return true;\n \n-  if (reverse)\n-    {\n-      tmp = cond1;\n-      cond1 = cond2;\n-      cond2 = tmp;\n-    }\n+  if ((TREE_CODE (expr1.pred_rhs) != INTEGER_CST)\n+      || (TREE_CODE (expr2.pred_rhs) != INTEGER_CST))\n+    return false;\n \n-  gc1 = gimple_code (cond1);\n-  gc2 = gimple_code (cond2);\n+  if (!operand_equal_p (expr1.pred_lhs, expr2.pred_lhs, 0))\n+    return false;\n \n-  if ((gc1 != GIMPLE_ASSIGN && gc1 != GIMPLE_COND)\n-      || (gc2 != GIMPLE_ASSIGN && gc2 != GIMPLE_COND))\n-    return cond1 == cond2;\n+  code1 = expr1.cond_code;\n+  if (expr1.invert)\n+    code1 = invert_tree_comparison (code1, false);\n+  code2 = expr2.cond_code;\n+  if (expr2.invert)\n+    code2 = invert_tree_comparison (code2, false);\n \n-  cond1_code = ((gc1 == GIMPLE_ASSIGN)\n-                ? gimple_assign_rhs_code (cond1)\n-                : gimple_cond_code (cond1));\n+  if (code1 != code2 && code2 != NE_EXPR)\n+    return false;\n \n-  cond2_code = ((gc2 == GIMPLE_ASSIGN)\n-                ? gimple_assign_rhs_code (cond2)\n-                : gimple_cond_code (cond2));\n+  if (is_value_included_in (expr1.pred_rhs, expr2.pred_rhs, code2))\n+    return true;\n \n-  if (TREE_CODE_CLASS (cond1_code) != tcc_comparison\n-      || TREE_CODE_CLASS (cond2_code) != tcc_comparison)\n-    return false;\n+  return false;\n+}\n \n-  if (invert1)\n-    cond1_code = invert_tree_comparison (cond1_code, false);\n-  if (invert2)\n-    cond2_code = invert_tree_comparison (cond2_code, false);\n-\n-  cond1_lhs = ((gc1 == GIMPLE_ASSIGN)\n-               ? gimple_assign_rhs1 (cond1)\n-               : gimple_cond_lhs (cond1));\n-  cond1_rhs = ((gc1 == GIMPLE_ASSIGN)\n-               ? gimple_assign_rhs2 (cond1)\n-               : gimple_cond_rhs (cond1));\n-  cond2_lhs = ((gc2 == GIMPLE_ASSIGN)\n-               ? gimple_assign_rhs1 (cond2)\n-               : gimple_cond_lhs (cond2));\n-  cond2_rhs = ((gc2 == GIMPLE_ASSIGN)\n-               ? gimple_assign_rhs2 (cond2)\n-               : gimple_cond_rhs (cond2));\n-\n-  /* Assuming const operands have been swapped to the\n-     rhs at this point of the analysis.  */\n-\n-  if (cond1_lhs != cond2_lhs)\n-    return false;\n+/* Returns true if the domain of PRED1 is a subset\n+   of that of PRED2. Returns false if it can not be proved so.  */\n \n-  if (!is_gimple_constant (cond1_rhs)\n-      || TREE_CODE (cond1_rhs) != INTEGER_CST)\n-    return (cond1_rhs == cond2_rhs);\n-\n-  if (!is_gimple_constant (cond2_rhs)\n-      || TREE_CODE (cond2_rhs) != INTEGER_CST)\n-    return (cond1_rhs == cond2_rhs);\n-\n-  if (cond1_code == EQ_EXPR)\n-    return is_value_included_in (cond1_rhs,\n-                                 cond2_rhs, cond2_code);\n-  if (cond1_code == NE_EXPR || cond2_code == EQ_EXPR)\n-    return ((cond2_code == cond1_code)\n-            && tree_int_cst_equal (cond1_rhs, cond2_rhs));\n-\n-  if (((cond1_code == GE_EXPR || cond1_code == GT_EXPR)\n-       && (cond2_code == LE_EXPR || cond2_code == LT_EXPR))\n-      || ((cond1_code == LE_EXPR || cond1_code == LT_EXPR)\n-          && (cond2_code == GE_EXPR || cond2_code == GT_EXPR)))\n-    return false;\n+static bool\n+is_pred_chain_subset_of (pred_chain pred1,\n+                         pred_chain pred2)\n+{\n+  size_t np1, np2, i1, i2;\n \n-  if (cond1_code != GE_EXPR && cond1_code != GT_EXPR\n-      && cond1_code != LE_EXPR && cond1_code != LT_EXPR)\n-    return false;\n+  np1 = pred1.length ();\n+  np2 = pred2.length ();\n \n-  if (cond1_code == GT_EXPR)\n-    {\n-      cond1_code = GE_EXPR;\n-      cond1_rhs = fold_binary (PLUS_EXPR, TREE_TYPE (cond1_rhs),\n-                               cond1_rhs,\n-                               fold_convert (TREE_TYPE (cond1_rhs),\n-                                             integer_one_node));\n-    }\n-  else if (cond1_code == LT_EXPR)\n+  for (i2 = 0; i2 < np2; i2++)\n     {\n-      cond1_code = LE_EXPR;\n-      cond1_rhs = fold_binary (MINUS_EXPR, TREE_TYPE (cond1_rhs),\n-                               cond1_rhs,\n-                               fold_convert (TREE_TYPE (cond1_rhs),\n-                                             integer_one_node));\n+      bool found = false;\n+      pred_info info2 = pred2[i2];\n+      for (i1 = 0; i1 < np1; i1++)\n+        {\n+          pred_info info1 = pred1[i1];\n+          if (is_pred_expr_subset_of (info1, info2))\n+            {\n+              found = true;\n+              break;\n+            }\n+        }\n+      if (!found)\n+        return false;\n     }\n-\n-  if (!cond1_rhs)\n-    return false;\n-\n-  gcc_assert (cond1_code == GE_EXPR || cond1_code == LE_EXPR);\n-\n-  if (cond2_code == GE_EXPR || cond2_code == GT_EXPR ||\n-      cond2_code == LE_EXPR || cond2_code == LT_EXPR)\n-    return is_value_included_in (cond1_rhs,\n-                                 cond2_rhs, cond2_code);\n-  else if (cond2_code == NE_EXPR)\n-    return\n-        (is_value_included_in (cond1_rhs,\n-                               cond2_rhs, cond2_code)\n-         && !is_value_included_in (cond2_rhs,\n-                                   cond1_rhs, cond1_code));\n-  return false;\n+  return true;\n }\n \n-/* Returns true if the domain of the condition expression \n-   in COND is a subset of any of the sub-conditions\n-   of the normalized condtion NORM_COND.  INVERT is a flag\n-   to indicate of the COND needs to be inverted.\n-   REVERSE is a flag. When it is true, the check is reversed --\n-   it returns true if COND is a superset of any of the subconditions\n-   of NORM_COND.  */\n+/* Returns true if the domain defined by\n+   one pred chain ONE_PRED is a subset of the domain\n+   of *PREDS. It returns false if ONE_PRED's domain is\n+   not a subset of any of the sub-domains of PREDS\n+   (corresponding to each individual chains in it), even\n+   though it may be still be a subset of whole domain\n+   of PREDS which is the union (ORed) of all its subdomains.\n+   In other words, the result is conservative.  */\n \n static bool\n-is_subset_of_any (gimple cond, bool invert,\n-                  norm_cond_t norm_cond, bool reverse)\n+is_included_in (pred_chain one_pred, pred_chain_union preds)\n {\n   size_t i;\n-  size_t len = norm_cond->conds.length ();\n+  size_t n = preds.length ();\n \n-  for (i = 0; i < len; i++)\n+  for (i = 0; i < n; i++)\n     {\n-      if (is_gcond_subset_of (cond, invert,\n-                              norm_cond->conds[i],\n-                              false, reverse))\n+      if (is_pred_chain_subset_of (one_pred, preds[i]))\n         return true;\n     }\n+\n   return false;\n }\n \n-/* NORM_COND1 and NORM_COND2 are normalized logical/BIT OR\n-   expressions (formed by following UD chains not control\n-   dependence chains). The function returns true of domain\n-   of and expression NORM_COND1 is a subset of NORM_COND2's.\n-   The implementation is conservative, and it returns false if\n-   it the inclusion relationship may not hold.  */\n+/* Compares two predicate sets PREDS1 and PREDS2 and returns\n+   true if the domain defined by PREDS1 is a superset\n+   of PREDS2's domain. N1 and N2 are array sizes of PREDS1 and\n+   PREDS2 respectively. The implementation chooses not to build\n+   generic trees (and relying on the folding capability of the\n+   compiler), but instead performs brute force comparison of\n+   individual predicate chains (won't be a compile time problem\n+   as the chains are pretty short). When the function returns\n+   false, it does not necessarily mean *PREDS1 is not a superset\n+   of *PREDS2, but mean it may not be so since the analysis can\n+   not prove it. In such cases, false warnings may still be\n+   emitted.  */\n \n static bool\n-is_or_set_subset_of (norm_cond_t norm_cond1,\n-                     norm_cond_t norm_cond2)\n+is_superset_of (pred_chain_union preds1, pred_chain_union preds2)\n {\n-  size_t i;\n-  size_t len = norm_cond1->conds.length ();\n+  size_t i, n2;\n+  pred_chain one_pred_chain = vNULL;\n \n-  for (i = 0; i < len; i++)\n+  n2 = preds2.length ();\n+\n+  for (i = 0; i < n2; i++)\n     {\n-      if (!is_subset_of_any (norm_cond1->conds[i],\n-                             false, norm_cond2, false))\n+      one_pred_chain = preds2[i];\n+      if (!is_included_in (one_pred_chain, preds1))\n         return false;\n     }\n+\n   return true;\n }\n \n-/* NORM_COND1 and NORM_COND2 are normalized logical AND\n-   expressions (formed by following UD chains not control\n-   dependence chains). The function returns true of domain\n-   of and expression NORM_COND1 is a subset of NORM_COND2's.  */\n+/* Returns true if TC is AND or OR.  */\n \n-static bool\n-is_and_set_subset_of (norm_cond_t norm_cond1,\n-                      norm_cond_t norm_cond2)\n+static inline bool\n+is_and_or_or_p (enum tree_code tc, tree type)\n {\n-  size_t i;\n-  size_t len = norm_cond2->conds.length ();\n+  return (tc == BIT_IOR_EXPR\n+          || (tc == BIT_AND_EXPR\n+              && (type == 0 || TREE_CODE (type) == BOOLEAN_TYPE)));\n+}\n \n-  for (i = 0; i < len; i++)\n-    {\n-      if (!is_subset_of_any (norm_cond2->conds[i],\n-                             false, norm_cond1, true))\n-        return false;\n-    }\n-  return true;\n+/* Returns true if X1 is the negate of X2.  */\n+\n+static inline bool\n+pred_neg_p (pred_info x1, pred_info x2)\n+{\n+  enum tree_code c1, c2;\n+  if (!operand_equal_p (x1.pred_lhs, x2.pred_lhs, 0)\n+      || !operand_equal_p (x1.pred_rhs, x2.pred_rhs, 0))\n+    return false;\n+      \n+  c1 = x1.cond_code;\n+  if (x1.invert == x2.invert)\n+    c2 = invert_tree_comparison (x2.cond_code, false);\n+  else\n+    c2 = x2.cond_code;\n+\n+  return c1 == c2;\n }\n \n-/* Returns true of the domain if NORM_COND1 is a subset \n-   of that of NORM_COND2. Returns false if it can not be \n-   proved to be so.  */\n+/* 1) ((x IOR y) != 0) AND (x != 0) is equivalent to (x != 0);\n+   2) (X AND Y) OR (!X AND Y) is equivalent to Y;\n+   3) X OR (!X AND Y) is equivalent to (X OR Y);\n+   4) ((x IAND y) != 0) || (x != 0 AND y != 0)) is equivalent to\n+      (x != 0 AND y != 0)\n+   5) (X AND Y) OR (!X AND Z) OR (!Y AND Z) is equivalent to\n+      (X AND Y) OR Z \n \n-static bool\n-is_norm_cond_subset_of (norm_cond_t norm_cond1,\n-                        norm_cond_t norm_cond2)\n+   PREDS is the predicate chains, and N is the number of chains.  */\n+\n+/* Helper function to implement rule 1 above.  ONE_CHAIN is\n+   the AND predication to be simplified.  */\n+\n+static void\n+simplify_pred (pred_chain *one_chain)\n {\n-  size_t i;\n-  enum tree_code code1, code2;\n+  size_t i, j, n;\n+  bool simplified = false;\n+  pred_chain s_chain = vNULL;\n \n-  code1 = norm_cond1->cond_code;\n-  code2 = norm_cond2->cond_code;\n+  n = one_chain->length ();\n \n-  if (code1 == BIT_AND_EXPR)\n+  for (i = 0; i < n; i++)\n     {\n-      /* Both conditions are AND expressions.  */\n-      if (code2 == BIT_AND_EXPR)\n-        return is_and_set_subset_of (norm_cond1, norm_cond2);\n-      /* NORM_COND1 is an AND expression, and NORM_COND2 is an OR\n-         expression. In this case, returns true if any subexpression\n-         of NORM_COND1 is a subset of any subexpression of NORM_COND2.  */\n-      else if (code2 == BIT_IOR_EXPR)\n+      pred_info *a_pred = &(*one_chain)[i];\n+\n+      if (!a_pred->pred_lhs)\n+        continue;\n+      if (!is_neq_zero_form_p (*a_pred))\n+        continue;\n+\n+      gimple def_stmt = SSA_NAME_DEF_STMT (a_pred->pred_lhs);\n+      if (gimple_code (def_stmt) != GIMPLE_ASSIGN)\n+        continue;\n+      if (gimple_assign_rhs_code (def_stmt) == BIT_IOR_EXPR)\n         {\n-          size_t len1;\n-          len1 = norm_cond1->conds.length ();\n-          for (i = 0; i < len1; i++)\n+          for (j = 0; j < n; j++)\n             {\n-              gimple cond1 = norm_cond1->conds[i];\n-              if (is_subset_of_any (cond1, false, norm_cond2, false))\n-                return true;\n+              pred_info *b_pred = &(*one_chain)[j];\n+\n+              if (!b_pred->pred_lhs)\n+                continue;\n+              if (!is_neq_zero_form_p (*b_pred))\n+                continue;\n+\n+              if (pred_expr_equal_p (*b_pred, gimple_assign_rhs1 (def_stmt))\n+                  || pred_expr_equal_p (*b_pred, gimple_assign_rhs2 (def_stmt)))\n+                 {\n+                   /* Mark a_pred for removal.  */\n+                   a_pred->pred_lhs = NULL;\n+                   a_pred->pred_rhs = NULL;\n+                   simplified = true;\n+                   break;\n+                 }\n             }\n-          return false;\n-        }\n-      else\n-        {\n-          gcc_assert (code2 == ERROR_MARK);\n-          gcc_assert (norm_cond2->conds.length () == 1);\n-          return is_subset_of_any (norm_cond2->conds[0],\n-                                   norm_cond2->invert, norm_cond1, true);\n         }\n     }\n-  /* NORM_COND1 is an OR expression  */\n-  else if (code1 == BIT_IOR_EXPR)\n-    {\n-      if (code2 != code1)\n-        return false;\n \n-      return is_or_set_subset_of (norm_cond1, norm_cond2);\n-    }\n-  else\n-    {\n-      gcc_assert (code1 == ERROR_MARK);\n-      gcc_assert (norm_cond1->conds.length () == 1);\n-      /* Conservatively returns false if NORM_COND1 is non-decomposible\n-         and NORM_COND2 is an AND expression.  */\n-      if (code2 == BIT_AND_EXPR)\n-        return false;\n-\n-      if (code2 == BIT_IOR_EXPR)\n-        return is_subset_of_any (norm_cond1->conds[0],\n-                                 norm_cond1->invert, norm_cond2, false);\n+  if (!simplified)\n+     return;\n \n-      gcc_assert (code2 == ERROR_MARK);\n-      gcc_assert (norm_cond2->conds.length () == 1);\n-      return is_gcond_subset_of (norm_cond1->conds[0],\n-                                 norm_cond1->invert,\n-                                 norm_cond2->conds[0],\n-                                 norm_cond2->invert, false);\n+  for (i = 0; i < n; i++)\n+    {\n+      pred_info *a_pred = &(*one_chain)[i];\n+      if (!a_pred->pred_lhs)\n+        continue;\n+      s_chain.safe_push (*a_pred);\n     }\n+\n+   one_chain->release ();\n+   *one_chain = s_chain;\n }\n \n-/* Returns true of the domain of single predicate expression\n-   EXPR1 is a subset of that of EXPR2. Returns false if it\n-   can not be proved.  */\n+/* The helper function implements the rule 2 for the\n+   OR predicate PREDS.\n+\n+   2) (X AND Y) OR (!X AND Y) is equivalent to Y.  */\n \n static bool\n-is_pred_expr_subset_of (use_pred_info_t expr1,\n-                        use_pred_info_t expr2)\n+simplify_preds_2 (pred_chain_union *preds)\n {\n-  gimple cond1, cond2;\n-  enum tree_code code1, code2;\n-  struct norm_cond norm_cond1, norm_cond2;\n-  bool is_subset = false;\n+  size_t i, j, n;\n+  bool simplified = false;\n+  pred_chain_union s_preds = vNULL;\n \n-  cond1 = expr1->cond;\n-  cond2 = expr2->cond;\n-  code1 = gimple_cond_code (cond1);\n-  code2 = gimple_cond_code (cond2);\n+  /* (X AND Y) OR (!X AND Y) is equivalent to Y.  \n+     (X AND Y) OR (X AND !Y) is equivalent to X.  */\n \n-  if (expr1->invert)\n-    code1 = invert_tree_comparison (code1, false);\n-  if (expr2->invert)\n-    code2 = invert_tree_comparison (code2, false);\n+  n = preds->length ();\n+  for (i = 0; i < n; i++)\n+    {\n+      pred_info x, y;\n+      pred_chain *a_chain = &(*preds)[i];\n \n-  /* Fast path -- match exactly  */\n-  if ((gimple_cond_lhs (cond1) == gimple_cond_lhs (cond2))\n-      && (gimple_cond_rhs (cond1) == gimple_cond_rhs (cond2))\n-      && (code1 == code2))\n-    return true;\n+      if (a_chain->length () != 2)\n+        continue;\n+\n+      x = (*a_chain)[0];\n+      y = (*a_chain)[1];\n+\n+      for (j = 0; j < n; j++)\n+        {\n+          pred_chain *b_chain;\n+          pred_info x2, y2;\n+\n+          if (j == i)\n+            continue;\n+\n+          b_chain = &(*preds)[j];\n+          if (b_chain->length () != 2)\n+            continue;\n \n-  /* Normalize conditions. To keep NE_EXPR, do not invert\n-     with both need inversion.  */\n-  normalize_cond (cond1, &norm_cond1, (expr1->invert));\n-  normalize_cond (cond2, &norm_cond2, (expr2->invert));\n+          x2 = (*b_chain)[0];\n+          y2 = (*b_chain)[1];\n \n-  is_subset = is_norm_cond_subset_of (&norm_cond1, &norm_cond2);\n+          if (pred_equal_p (x, x2) && pred_neg_p (y, y2))\n+            {\n+              /* Kill a_chain.  */\n+              a_chain->release ();\n+              b_chain->release ();\n+              b_chain->safe_push (x);\n+              simplified = true;\n+              break;\n+            }\n+          if (pred_neg_p (x, x2) && pred_equal_p (y, y2))\n+            {\n+              /* Kill a_chain.  */\n+              a_chain->release ();\n+              b_chain->release ();\n+              b_chain->safe_push (y);\n+              simplified = true;\n+              break;\n+            }\n+        }\n+    }\n+  /* Now clean up the chain.  */\n+  if (simplified)\n+    {\n+      for (i = 0; i < n; i++)\n+        {\n+          if ((*preds)[i].is_empty ())\n+            continue;\n+          s_preds.safe_push ((*preds)[i]);\n+        }\n+      preds->release ();\n+      (*preds) = s_preds;\n+      s_preds = vNULL;\n+    }\n \n-  /* Free memory  */\n-  norm_cond1.conds.release ();\n-  norm_cond2.conds.release ();\n-  return is_subset ;\n+  return simplified;\n }\n \n-/* Returns true if the domain of PRED1 is a subset\n-   of that of PRED2. Returns false if it can not be proved so.  */\n+/* The helper function implements the rule 2 for the\n+   OR predicate PREDS.\n+\n+   3) x OR (!x AND y) is equivalent to x OR y.  */\n \n static bool\n-is_pred_chain_subset_of (vec<use_pred_info_t> pred1,\n-                         vec<use_pred_info_t> pred2)\n+simplify_preds_3 (pred_chain_union *preds)\n {\n-  size_t np1, np2, i1, i2;\n+  size_t i, j, n;\n+  bool simplified = false;\n \n-  np1 = pred1.length ();\n-  np2 = pred2.length ();\n+  /* Now iteratively simplify X OR (!X AND Z ..)\n+       into X OR (Z ...).  */\n \n-  for (i2 = 0; i2 < np2; i2++)\n+  n = preds->length ();\n+  if (n < 2)\n+    return false;\n+\n+  for (i = 0; i < n; i++)\n     {\n-      bool found = false;\n-      use_pred_info_t info2\n-          = pred2[i2];\n-      for (i1 = 0; i1 < np1; i1++)\n+      pred_info x;\n+      pred_chain *a_chain = &(*preds)[i];\n+\n+      if (a_chain->length () != 1)\n+        continue;\n+\n+      x = (*a_chain)[0];\n+\n+      for (j = 0; j < n; j++)\n         {\n-          use_pred_info_t info1\n-              = pred1[i1];\n-          if (is_pred_expr_subset_of (info1, info2))\n+          pred_chain *b_chain;\n+          pred_info x2;\n+          size_t k;\n+\n+          if (j == i)\n+            continue;\n+\n+          b_chain = &(*preds)[j];\n+          if (b_chain->length () < 2)\n+            continue;\n+\n+          for (k = 0; k < b_chain->length (); k++)\n             {\n-              found = true;\n-              break;\n+              x2 = (*b_chain)[k];\n+              if (pred_neg_p (x, x2))\n+                {\n+                  b_chain->unordered_remove (k);\n+                  simplified = true;\n+                  break;\n+                }\n             }\n         }\n-      if (!found)\n-        return false;\n     }\n-  return true;\n+  return simplified;\n }\n \n-/* Returns true if the domain defined by\n-   one pred chain ONE_PRED is a subset of the domain\n-   of *PREDS. It returns false if ONE_PRED's domain is\n-   not a subset of any of the sub-domains of PREDS (\n-   corresponding to each individual chains in it), even\n-   though it may be still be a subset of whole domain\n-   of PREDS which is the union (ORed) of all its subdomains.\n-   In other words, the result is conservative.  */\n+/* The helper function implements the rule 4 for the\n+   OR predicate PREDS.\n+\n+   2) ((x AND y) != 0) OR (x != 0 AND y != 0) is equivalent to\n+       (x != 0 ANd y != 0).   */\n \n static bool\n-is_included_in (vec<use_pred_info_t> one_pred,\n-                vec<use_pred_info_t> *preds,\n-                size_t n)\n+simplify_preds_4 (pred_chain_union *preds)\n {\n-  size_t i;\n+  size_t i, j, n;\n+  bool simplified = false;\n+  pred_chain_union s_preds = vNULL;\n+  gimple def_stmt;\n \n+  n = preds->length ();\n   for (i = 0; i < n; i++)\n     {\n-      if (is_pred_chain_subset_of (one_pred, preds[i]))\n-        return true;\n+      pred_info z;\n+      pred_chain *a_chain = &(*preds)[i];\n+\n+      if (a_chain->length () != 1)\n+        continue;\n+\n+      z = (*a_chain)[0];\n+\n+      if (!is_neq_zero_form_p (z))\n+        continue;\n+\n+      def_stmt = SSA_NAME_DEF_STMT (z.pred_lhs);\n+      if (gimple_code (def_stmt) != GIMPLE_ASSIGN)\n+        continue;\n+\n+      if (gimple_assign_rhs_code (def_stmt) != BIT_AND_EXPR)\n+        continue;\n+\n+      for (j = 0; j < n; j++)\n+        {\n+          pred_chain *b_chain;\n+          pred_info x2, y2;\n+\n+          if (j == i)\n+            continue;\n+\n+          b_chain = &(*preds)[j];\n+          if (b_chain->length () != 2)\n+            continue;\n+\n+          x2 = (*b_chain)[0];\n+          y2 = (*b_chain)[1];\n+          if (!is_neq_zero_form_p (x2)\n+              || !is_neq_zero_form_p (y2))\n+            continue;\n+\n+          if ((pred_expr_equal_p (x2, gimple_assign_rhs1 (def_stmt))\n+               && pred_expr_equal_p (y2, gimple_assign_rhs2 (def_stmt)))\n+              || (pred_expr_equal_p (x2, gimple_assign_rhs2 (def_stmt))\n+                  && pred_expr_equal_p (y2, gimple_assign_rhs1 (def_stmt))))\n+            {\n+              /* Kill a_chain.  */\n+              a_chain->release ();\n+              simplified = true;\n+              break;\n+            }\n+        }\n+    }\n+  /* Now clean up the chain.  */\n+  if (simplified)\n+    {\n+      for (i = 0; i < n; i++)\n+        {\n+          if ((*preds)[i].is_empty ())\n+            continue;\n+          s_preds.safe_push ((*preds)[i]);\n+        }\n+      preds->release ();\n+      (*preds) = s_preds;\n+      s_preds = vNULL;\n     }\n \n-  return false;\n+  return simplified;\n }\n \n-/* compares two predicate sets PREDS1 and PREDS2 and returns\n-   true if the domain defined by PREDS1 is a superset\n-   of PREDS2's domain. N1 and N2 are array sizes of PREDS1 and\n-   PREDS2 respectively. The implementation chooses not to build\n-   generic trees (and relying on the folding capability of the\n-   compiler), but instead performs brute force comparison of\n-   individual predicate chains (won't be a compile time problem\n-   as the chains are pretty short). When the function returns\n-   false, it does not necessarily mean *PREDS1 is not a superset\n-   of *PREDS2, but mean it may not be so since the analysis can\n-   not prove it. In such cases, false warnings may still be\n-   emitted.  */\n \n-static bool\n-is_superset_of (vec<use_pred_info_t> *preds1,\n-                size_t n1,\n-                vec<use_pred_info_t> *preds2,\n-                size_t n2)\n+/* This function simplifies predicates in PREDS.  */\n+\n+static void\n+simplify_preds (pred_chain_union *preds, gimple use_or_def, bool is_use)\n {\n-  size_t i;\n-  vec<use_pred_info_t> one_pred_chain;\n+  size_t i, n;\n+  bool changed = false;\n \n-  for (i = 0; i < n2; i++)\n+  if (dump_file && dump_flags & TDF_DETAILS)\n     {\n-      one_pred_chain = preds2[i];\n-      if (!is_included_in (one_pred_chain, preds1, n1))\n-        return false;\n+      fprintf (dump_file, \"[BEFORE SIMPLICATION -- \");\n+      dump_predicates (use_or_def, *preds, is_use ? \"[USE]:\\n\" : \"[DEF]:\\n\");\n     }\n \n-  return true;\n+  for (i = 0; i < preds->length (); i++)\n+    simplify_pred (&(*preds)[i]);\n+\n+  n = preds->length ();\n+  if (n < 2)\n+    return;\n+\n+  do\n+    {\n+      changed = false;\n+      if (simplify_preds_2 (preds))\n+        changed = true;\n+\n+      /* Now iteratively simplify X OR (!X AND Z ..)\n+       into X OR (Z ...).  */\n+      if (simplify_preds_3 (preds))\n+        changed = true;\n+\n+      if (simplify_preds_4 (preds))\n+        changed = true;\n+\n+    } while (changed);\n+\n+  return;\n }\n \n-/* Comparison function used by qsort. It is used to\n-   sort predicate chains to allow predicate\n-   simplification.  */\n+/* This is a helper function which attempts to normalize predicate chains\n+  by following UD chains. It basically builds up a big tree of either IOR\n+  operations or AND operations, and convert the IOR tree into a \n+  pred_chain_union or BIT_AND tree into a pred_chain.\n+  Example:\n \n-static int\n-pred_chain_length_cmp (const void *p1, const void *p2)\n+  _3 = _2 RELOP1 _1;\n+  _6 = _5 RELOP2 _4;\n+  _9 = _8 RELOP3 _7;\n+  _10 = _3 | _6;\n+  _12 = _9 | _0;\n+  _t = _10 | _12;\n+\n+ then _t != 0 will be normalized into a pred_chain_union\n+\n+   (_2 RELOP1 _1) OR (_5 RELOP2 _4) OR (_8 RELOP3 _7) OR (_0 != 0)\n+\n+ Similarly given,\n+\n+  _3 = _2 RELOP1 _1;\n+  _6 = _5 RELOP2 _4;\n+  _9 = _8 RELOP3 _7;\n+  _10 = _3 & _6;\n+  _12 = _9 & _0;\n+\n+ then _t != 0 will be normalized into a pred_chain:\n+   (_2 RELOP1 _1) AND (_5 RELOP2 _4) AND (_8 RELOP3 _7) AND (_0 != 0)\n+   \n+  */\n+\n+/* This is a helper function that stores a PRED into NORM_PREDS.  */\n+\n+inline static void\n+push_pred (pred_chain_union *norm_preds, pred_info pred)\n {\n-  use_pred_info_t i1, i2;\n-  vec<use_pred_info_t>  const *chain1\n-      = (vec<use_pred_info_t>  const *)p1;\n-  vec<use_pred_info_t>  const *chain2\n-      = (vec<use_pred_info_t>  const *)p2;\n+  pred_chain pred_chain = vNULL;\n+  pred_chain.safe_push (pred);\n+  norm_preds->safe_push (pred_chain);\n+}\n \n-  if (chain1->length () != chain2->length ())\n-    return (chain1->length () - chain2->length ());\n+/* A helper function that creates a predicate of the form\n+   OP != 0 and push it WORK_LIST.  */\n \n-  i1 = (*chain1)[0];\n-  i2 = (*chain2)[0];\n+inline static void\n+push_to_worklist (tree op, vec<pred_info, va_heap, vl_ptr> *work_list)\n+{\n+  pred_info arg_pred;\n+  arg_pred.pred_lhs = op;\n+  arg_pred.pred_rhs = integer_zero_node;\n+  arg_pred.cond_code = NE_EXPR;\n+  arg_pred.invert = false;\n+  work_list->safe_push (arg_pred);\n+}\n \n-  /* Allow predicates with similar prefix come together.  */\n-  if (!i1->invert && i2->invert)\n-    return -1;\n-  else if (i1->invert && !i2->invert)\n-    return 1;\n+/* A helper that generates a pred_info from a gimple assignment\n+   CMP_ASSIGN with comparison rhs.  */\n \n-  return gimple_uid (i1->cond) - gimple_uid (i2->cond);\n+static pred_info\n+get_pred_info_from_cmp (gimple cmp_assign)\n+{\n+  pred_info n_pred;\n+  n_pred.pred_lhs = gimple_assign_rhs1 (cmp_assign);\n+  n_pred.pred_rhs = gimple_assign_rhs2 (cmp_assign);\n+  n_pred.cond_code = gimple_assign_rhs_code (cmp_assign);\n+  n_pred.invert = false;\n+  return n_pred;\n }\n \n-/* x OR (!x AND y) is equivalent to x OR y.\n-   This function normalizes x1 OR (!x1 AND x2) OR (!x1 AND !x2 AND x3)\n-   into x1 OR x2 OR x3.  PREDS is the predicate chains, and N is\n-   the number of chains. Returns true if normalization happens.  */\n+/* Returns true if the PHI is a degenerated phi with\n+   all args with the same value (relop). In that case, *PRED\n+   will be updated to that value.  */\n \n static bool\n-normalize_preds (vec<use_pred_info_t> *preds, size_t *n)\n+is_degenerated_phi (gimple phi, pred_info *pred_p)\n {\n-  size_t i, j, ll;\n-  vec<use_pred_info_t> pred_chain;\n-  vec<use_pred_info_t> x = vNULL;\n-  use_pred_info_t xj = 0, nxj = 0;\n+  int i, n;\n+  tree op0;\n+  gimple def0;\n+  pred_info pred0;\n \n-  if (*n < 2)\n+  n = gimple_phi_num_args (phi);\n+  op0 = gimple_phi_arg_def (phi, 0);\n+\n+  if (TREE_CODE (op0) != SSA_NAME)\n     return false;\n \n-  /* First sort the chains in ascending order of lengths.  */\n-  qsort (preds, *n, sizeof (void *), pred_chain_length_cmp);\n-  pred_chain = preds[0];\n-  ll = pred_chain.length ();\n-  if (ll != 1)\n-   {\n-     if (ll == 2)\n-       {\n-         use_pred_info_t xx, yy, xx2, nyy;\n-         vec<use_pred_info_t> pred_chain2 = preds[1];\n-         if (pred_chain2.length () != 2)\n-           return false;\n-\n-         /* See if simplification x AND y OR x AND !y is possible.  */\n-         xx = pred_chain[0];\n-         yy = pred_chain[1];\n-         xx2 = pred_chain2[0];\n-         nyy = pred_chain2[1];\n-         if (gimple_cond_lhs (xx->cond) != gimple_cond_lhs (xx2->cond)\n-             || gimple_cond_rhs (xx->cond) != gimple_cond_rhs (xx2->cond)\n-             || gimple_cond_code (xx->cond) != gimple_cond_code (xx2->cond)\n-             || (xx->invert != xx2->invert))\n-           return false;\n-         if (gimple_cond_lhs (yy->cond) != gimple_cond_lhs (nyy->cond)\n-             || gimple_cond_rhs (yy->cond) != gimple_cond_rhs (nyy->cond)\n-             || gimple_cond_code (yy->cond) != gimple_cond_code (nyy->cond)\n-             || (yy->invert == nyy->invert))\n-           return false;\n-\n-         /* Now merge the first two chains.  */\n-         free (yy);\n-         free (nyy);\n-         free (xx2);\n-         pred_chain.release ();\n-         pred_chain2.release ();\n-         pred_chain.safe_push (xx);\n-         preds[0] = pred_chain;\n-         for (i = 1; i < *n - 1; i++)\n-           preds[i] = preds[i + 1];\n-\n-         preds[*n - 1].create (0);\n-         *n = *n - 1;\n-       }\n-     else\n-       return false;\n-   }\n-\n-  x.safe_push (pred_chain[0]);\n-\n-  /* The loop extracts x1, x2, x3, etc from chains\n-     x1 OR (!x1 AND x2) OR (!x1 AND !x2 AND x3) OR ...  */\n-  for (i = 1; i < *n; i++)\n+  def0 = SSA_NAME_DEF_STMT (op0);\n+  if (gimple_code (def0) != GIMPLE_ASSIGN)\n+    return false;\n+  if (TREE_CODE_CLASS (gimple_assign_rhs_code (def0))\n+      != tcc_comparison)\n+    return false;\n+  pred0 = get_pred_info_from_cmp (def0);\n+\n+  for (i = 1; i < n; ++i)\n     {\n-      pred_chain = preds[i];\n-      if (pred_chain.length () != i + 1)\n+      gimple def;\n+      pred_info pred;\n+      tree op = gimple_phi_arg_def (phi, i);\n+\n+      if (TREE_CODE (op) != SSA_NAME)\n         return false;\n \n-      for (j = 0; j < i; j++)\n+      def = SSA_NAME_DEF_STMT (op);\n+      if (gimple_code (def) != GIMPLE_ASSIGN)\n+        return false;\n+      if (TREE_CODE_CLASS (gimple_assign_rhs_code (def))\n+          != tcc_comparison)\n+        return false;\n+      pred = get_pred_info_from_cmp (def);\n+      if (!pred_equal_p (pred, pred0))\n+        return false;\n+    }\n+\n+  *pred_p = pred0;\n+  return true;\n+}\n+\n+/* Normalize one predicate PRED  \n+   1) if PRED can no longer be normlized, put it into NORM_PREDS.\n+   2) otherwise if PRED is of the form x != 0, follow x's definition\n+      and put normalized predicates into WORK_LIST.  */\n+ \n+static void\n+normalize_one_pred_1 (pred_chain_union *norm_preds, \n+                      pred_chain *norm_chain,\n+                      pred_info pred,\n+                      enum tree_code and_or_code,\n+                      vec<pred_info, va_heap, vl_ptr> *work_list)\n+{\n+  if (!is_neq_zero_form_p (pred))\n+    {\n+      if (and_or_code == BIT_IOR_EXPR)\n+        push_pred (norm_preds, pred);\n+      else\n+        norm_chain->safe_push (pred);\n+      return;\n+    }\n+\n+  gimple def_stmt = SSA_NAME_DEF_STMT (pred.pred_lhs);\n+ \n+  if (gimple_code (def_stmt) == GIMPLE_PHI\n+      && is_degenerated_phi (def_stmt, &pred))\n+    work_list->safe_push (pred);\n+  else if (gimple_code (def_stmt) == GIMPLE_PHI\n+           && and_or_code == BIT_IOR_EXPR)\n+    {\n+      int i, n;\n+      n = gimple_phi_num_args (def_stmt);\n+\n+      /* If we see non zero constant, we should punt. The predicate\n+       * should be one guarding the phi edge.  */\n+      for (i = 0; i < n; ++i)\n         {\n-          xj = x[j];\n-          nxj = pred_chain[j];\n-\n-          /* Check if nxj is !xj  */\n-          if (gimple_cond_lhs (xj->cond) != gimple_cond_lhs (nxj->cond)\n-              || gimple_cond_rhs (xj->cond) != gimple_cond_rhs (nxj->cond)\n-              || gimple_cond_code (xj->cond) != gimple_cond_code (nxj->cond)\n-              || (xj->invert == nxj->invert))\n-            return false;\n+          tree op = gimple_phi_arg_def (def_stmt, i);\n+          if (TREE_CODE (op) == INTEGER_CST && !integer_zerop (op))\n+            {\n+              push_pred (norm_preds, pred);\n+              return;\n+            }\n         }\n \n-      x.safe_push (pred_chain[i]);\n-    }\n+      for (i = 0; i < n; ++i)\n+        {\n+          tree op = gimple_phi_arg_def (def_stmt, i);\n+          if (integer_zerop (op))\n+            continue;\n+\n+          push_to_worklist (op, work_list);\n+        }\n+     }\n+   else if (gimple_code (def_stmt) != GIMPLE_ASSIGN)\n+     {\n+       if (and_or_code == BIT_IOR_EXPR)\n+         push_pred (norm_preds, pred);\n+       else\n+         norm_chain->safe_push (pred);\n+     }\n+   else if (gimple_assign_rhs_code (def_stmt) == and_or_code)\n+     {\n+        push_to_worklist (gimple_assign_rhs1 (def_stmt),\n+                          work_list);\n+        push_to_worklist (gimple_assign_rhs2 (def_stmt),\n+                          work_list);\n+     }\n+   else if (TREE_CODE_CLASS (gimple_assign_rhs_code (def_stmt))\n+            == tcc_comparison)\n+     {\n+       pred_info n_pred = get_pred_info_from_cmp (def_stmt);\n+       if (and_or_code == BIT_IOR_EXPR)\n+         push_pred (norm_preds, n_pred);\n+       else\n+         norm_chain->safe_push (n_pred);\n+     }\n+   else\n+     {\n+       if (and_or_code == BIT_IOR_EXPR)\n+         push_pred (norm_preds, pred);\n+       else\n+         norm_chain->safe_push (pred);\n+     }\n+}\n+\n+/* Normalize PRED and store the normalized predicates into NORM_PREDS.  */\n+\n+static void\n+normalize_one_pred (pred_chain_union *norm_preds,\n+                    pred_info pred)\n+{\n+  vec<pred_info, va_heap, vl_ptr> work_list = vNULL;\n+  enum tree_code and_or_code = ERROR_MARK;\n+  pred_chain norm_chain = vNULL;\n \n-  /* Now normalize the pred chains using the extraced x1, x2, x3 etc.  */\n-  for (j = 0; j < *n; j++)\n+  if (!is_neq_zero_form_p (pred))\n     {\n-      use_pred_info_t t;\n-      xj = x[j];\n+      push_pred (norm_preds, pred);\n+      return;\n+    }\n \n-      t = XNEW (struct use_pred_info);\n-      *t = *xj;\n+  gimple def_stmt = SSA_NAME_DEF_STMT (pred.pred_lhs);\n+  if (gimple_code (def_stmt) == GIMPLE_ASSIGN)\n+    and_or_code = gimple_assign_rhs_code (def_stmt);\n+  if (and_or_code != BIT_IOR_EXPR\n+      && and_or_code != BIT_AND_EXPR)\n+    {\n+      if (TREE_CODE_CLASS (and_or_code)\n+          == tcc_comparison)\n+        {\n+          pred_info n_pred = get_pred_info_from_cmp (def_stmt);\n+          push_pred (norm_preds, n_pred);\n+        } \n+       else\n+          push_pred (norm_preds, pred);\n+      return;\n+    }\n \n-      x[j] = t;\n+  work_list.safe_push (pred);\n+  while (!work_list.is_empty ())\n+    {\n+      pred_info a_pred = work_list.pop ();\n+      normalize_one_pred_1 (norm_preds, &norm_chain, a_pred,\n+                            and_or_code, &work_list);\n     }\n+  if (and_or_code == BIT_AND_EXPR)\n+    norm_preds->safe_push (norm_chain);\n+\n+  work_list.release ();\n+}\n \n-  for (i = 0; i < *n; i++)\n+static void\n+normalize_one_pred_chain (pred_chain_union *norm_preds,\n+                          pred_chain one_chain)\n+{\n+  vec<pred_info, va_heap, vl_ptr> work_list = vNULL;\n+  pred_chain norm_chain = vNULL;\n+  size_t i;\n+\n+  for (i = 0; i < one_chain.length (); i++)\n+    work_list.safe_push (one_chain[i]);\n+\n+  while (!work_list.is_empty ())\n     {\n-      pred_chain = preds[i];\n-      for (j = 0; j < pred_chain.length (); j++)\n-        free (pred_chain[j]);\n-      pred_chain.release ();\n-      /* A new chain.  */\n-      pred_chain.safe_push (x[i]);\n-      preds[i] = pred_chain;\n+      pred_info a_pred = work_list.pop ();\n+      normalize_one_pred_1 (0, &norm_chain, a_pred,\n+                            BIT_AND_EXPR, &work_list);\n     }\n-  return true;\n+\n+  norm_preds->safe_push (norm_chain);\n+  work_list.release ();\n }\n \n+/* Normalize predicate chains PREDS and returns the normalized one.  */\n+\n+static pred_chain_union\n+normalize_preds (pred_chain_union preds, gimple use_or_def, bool is_use)\n+{\n+  pred_chain_union norm_preds = vNULL;\n+  size_t n = preds.length ();\n+  size_t i;\n+\n+  if (dump_file && dump_flags & TDF_DETAILS)\n+    {\n+      fprintf (dump_file, \"[BEFORE NORMALIZATION --\");\n+      dump_predicates (use_or_def, preds, is_use ? \"[USE]:\\n\" : \"[DEF]:\\n\");\n+    }\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      if (preds[i].length () != 1)\n+        normalize_one_pred_chain (&norm_preds, preds[i]);\n+      else\n+        {\n+          normalize_one_pred (&norm_preds, preds[i][0]);\n+          preds[i].release ();\n+        }\n+    }\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"[AFTER NORMALIZATION -- \");\n+      dump_predicates (use_or_def, norm_preds, is_use ? \"[USE]:\\n\" : \"[DEF]:\\n\");\n+    }\n+\n+  preds.release ();\n+  return norm_preds;\n+}\n \n \n /* Computes the predicates that guard the use and checks\n@@ -1917,12 +2103,11 @@ is_use_properly_guarded (gimple use_stmt,\n                          basic_block use_bb,\n                          gimple phi,\n                          unsigned uninit_opnds,\n-                         struct pointer_set_t *visited_phis)\n+                         pointer_set_t *visited_phis)\n {\n   basic_block phi_bb;\n-  vec<use_pred_info_t> *preds = 0;\n-  vec<use_pred_info_t> *def_preds = 0;\n-  size_t num_preds = 0, num_def_preds = 0;\n+  pred_chain_union preds = vNULL;\n+  pred_chain_union def_preds = vNULL;\n   bool has_valid_preds = false;\n   bool is_properly_guarded = false;\n \n@@ -1934,49 +2119,44 @@ is_use_properly_guarded (gimple use_stmt,\n   if (is_non_loop_exit_postdominating (use_bb, phi_bb))\n     return false;\n \n-  has_valid_preds = find_predicates (&preds, &num_preds,\n-                                     phi_bb, use_bb);\n+  has_valid_preds = find_predicates (&preds, phi_bb, use_bb);\n \n   if (!has_valid_preds)\n     {\n-      destroy_predicate_vecs (num_preds, preds);\n+      destroy_predicate_vecs (preds);\n       return false;\n     }\n \n-  if (dump_file)\n-    dump_predicates (use_stmt, num_preds, preds,\n-                     \"\\nUse in stmt \");\n-\n-  has_valid_preds = find_def_preds (&def_preds,\n-                                    &num_def_preds, phi);\n+  /* Try to prune the dead incoming phi edges. */\n+  is_properly_guarded\n+    = use_pred_not_overlap_with_undef_path_pred (preds, phi, uninit_opnds,\n+\t\t\t\t\t\t visited_phis);\n \n-  if (has_valid_preds)\n+  if (is_properly_guarded)\n     {\n-      bool normed;\n-      if (dump_file)\n-        dump_predicates (phi, num_def_preds, def_preds,\n-                         \"Operand defs of phi \");\n+      destroy_predicate_vecs (preds);\n+      return true;\n+    }\n \n-      normed = normalize_preds (def_preds, &num_def_preds);\n-      if (normed && dump_file)\n-        {\n-          fprintf (dump_file, \"\\nNormalized to\\n\");\n-          dump_predicates (phi, num_def_preds, def_preds,\n-                           \"Operand defs of phi \");\n-        }\n-      is_properly_guarded =\n-          is_superset_of (def_preds, num_def_preds,\n-                          preds, num_preds);\n+  has_valid_preds = find_def_preds (&def_preds, phi);\n+\n+  if (!has_valid_preds)\n+    {\n+      destroy_predicate_vecs (preds);\n+      destroy_predicate_vecs (def_preds);\n+      return false;\n     }\n \n-  /* further prune the dead incoming phi edges. */\n-  if (!is_properly_guarded)\n-    is_properly_guarded\n-        = use_pred_not_overlap_with_undef_path_pred (\n-            num_preds, preds, phi, uninit_opnds, visited_phis);\n+  simplify_preds (&preds, use_stmt, true);\n+  preds = normalize_preds (preds, use_stmt, true);\n+\n+  simplify_preds (&def_preds, phi, false);\n+  def_preds = normalize_preds (def_preds, phi, false);\n+\n+  is_properly_guarded = is_superset_of (def_preds, preds);\n \n-  destroy_predicate_vecs (num_preds, preds);\n-  destroy_predicate_vecs (num_def_preds, def_preds);\n+  destroy_predicate_vecs (preds);\n+  destroy_predicate_vecs (def_preds);\n   return is_properly_guarded;\n }\n \n@@ -1992,7 +2172,7 @@ is_use_properly_guarded (gimple use_stmt,\n static gimple\n find_uninit_use (gimple phi, unsigned uninit_opnds,\n                  vec<gimple> *worklist,\n-\t\t struct pointer_set_t *added_to_worklist)\n+\t\t pointer_set_t *added_to_worklist)\n {\n   tree phi_result;\n   use_operand_p use_p;\n@@ -2003,7 +2183,7 @@ find_uninit_use (gimple phi, unsigned uninit_opnds,\n \n   FOR_EACH_IMM_USE_FAST (use_p, iter, phi_result)\n     {\n-      struct pointer_set_t *visited_phis;\n+      pointer_set_t *visited_phis;\n       basic_block use_bb;\n \n       use_stmt = USE_STMT (use_p);\n@@ -2018,10 +2198,7 @@ find_uninit_use (gimple phi, unsigned uninit_opnds,\n       else\n \tuse_bb = gimple_bb (use_stmt);\n \n-      if (is_use_properly_guarded (use_stmt,\n-                                   use_bb, \n-                                   phi,\n-                                   uninit_opnds,\n+      if (is_use_properly_guarded (use_stmt, use_bb, phi, uninit_opnds,\n                                    visited_phis))\n         {\n           pointer_set_destroy (visited_phis);\n@@ -2040,8 +2217,7 @@ find_uninit_use (gimple phi, unsigned uninit_opnds,\n \n       /* Found a phi use that is not guarded,\n          add the phi to the worklist.  */\n-      if (!pointer_set_insert (added_to_worklist,\n-                               use_stmt))\n+      if (!pointer_set_insert (added_to_worklist, use_stmt))\n         {\n           if (dump_file && (dump_flags & TDF_DETAILS))\n             {\n@@ -2067,7 +2243,7 @@ find_uninit_use (gimple phi, unsigned uninit_opnds,\n \n static void\n warn_uninitialized_phi (gimple phi, vec<gimple> *worklist,\n-                        struct pointer_set_t *added_to_worklist)\n+                        pointer_set_t *added_to_worklist)\n {\n   unsigned uninit_opnds;\n   gimple uninit_use_stmt = 0;\n@@ -2115,7 +2291,7 @@ execute_late_warn_uninitialized (void)\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n   vec<gimple> worklist = vNULL;\n-  struct pointer_set_t *added_to_worklist;\n+  pointer_set_t *added_to_worklist;\n \n   calculate_dominance_info (CDI_DOMINATORS);\n   calculate_dominance_info (CDI_POST_DOMINATORS);\n@@ -2229,8 +2405,7 @@ execute_early_warn_uninitialized (void)\n      execute_late_warn_uninitialized only runs with optimization. With\n      optimization we want to warn about possible uninitialized as late\n      as possible, thus don't do it here.  However, without\n-     optimization we need to warn here about \"may be uninitialized\".\n-  */\n+     optimization we need to warn here about \"may be uninitialized\".  */\n   calculate_dominance_info (CDI_POST_DOMINATORS);\n \n   warn_uninitialized_vars (/*warn_possibly_uninitialized=*/!optimize);\n@@ -2280,5 +2455,3 @@ make_pass_early_warn_uninitialized (gcc::context *ctxt)\n {\n   return new pass_early_warn_uninitialized (ctxt);\n }\n-\n-"}]}