{"sha": "72a4ddf2b5f8167dd49a483888f14d34c3da582f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJhNGRkZjJiNWY4MTY3ZGQ0OWE0ODM4ODhmMTRkMzRjM2RhNTgyZg==", "commit": {"author": {"name": "Andreas Krebbel", "email": "Andreas.Krebbel@de.ibm.com", "date": "2014-03-24T17:38:09Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2014-03-24T17:38:09Z"}, "message": "re PR rtl-optimization/60501 (LRA emits add patterns which might clobber cc)\n\n2014-03-24  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n\n\tPR rtl-optimization/60501\n\t* optabs.def (addptr3_optab): New optab.\n\t* optabs.c (gen_addptr3_insn, have_addptr3_insn): New function.\n\t* doc/md.texi (\"addptrm3\"): Document new RTL standard expander.\n\t* expr.h (gen_addptr3_insn, have_addptr3_insn): Add prototypes.\n\n\t* lra.c (emit_add3_insn): Use the addptr pattern if available.\n\n\t* config/s390/s390.md (\"addptrdi3\", \"addptrsi3\"): New expanders.\n\nFrom-SVN: r208796", "tree": {"sha": "aeae7ffed74971f9fea144af390f17c819a9157c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aeae7ffed74971f9fea144af390f17c819a9157c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72a4ddf2b5f8167dd49a483888f14d34c3da582f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72a4ddf2b5f8167dd49a483888f14d34c3da582f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72a4ddf2b5f8167dd49a483888f14d34c3da582f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72a4ddf2b5f8167dd49a483888f14d34c3da582f/comments", "author": null, "committer": null, "parents": [{"sha": "2b2384e8c11ac54f8add062584ada9480079a25b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b2384e8c11ac54f8add062584ada9480079a25b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b2384e8c11ac54f8add062584ada9480079a25b"}], "stats": {"total": 127, "additions": 127, "deletions": 0}, "files": [{"sha": "d904fc022a932dcb32a132fa85ee2005c58c6713", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a4ddf2b5f8167dd49a483888f14d34c3da582f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a4ddf2b5f8167dd49a483888f14d34c3da582f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=72a4ddf2b5f8167dd49a483888f14d34c3da582f", "patch": "@@ -1,3 +1,15 @@\n+2014-03-24  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n+\n+\tPR rtl-optimization/60501\n+\t* optabs.def (addptr3_optab): New optab.\n+\t* optabs.c (gen_addptr3_insn, have_addptr3_insn): New function.\n+\t* doc/md.texi (\"addptrm3\"): Document new RTL standard expander.\n+\t* expr.h (gen_addptr3_insn, have_addptr3_insn): Add prototypes.\n+\n+\t* lra.c (emit_add3_insn): Use the addptr pattern if available.\n+\n+\t* config/s390/s390.md (\"addptrdi3\", \"addptrsi3\"): New expanders.\n+\n 2014-03-24  Ulrich Drepper  <drepper@gmail.com>\n \n \t* config/i386/avx512fintrin.h: Define _mm512_set1_ps and"}, {"sha": "7d9d1ad7ecd3a81da667df53fdb98232c952f379", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a4ddf2b5f8167dd49a483888f14d34c3da582f/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a4ddf2b5f8167dd49a483888f14d34c3da582f/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=72a4ddf2b5f8167dd49a483888f14d34c3da582f", "patch": "@@ -5034,6 +5034,57 @@\n   [(set_attr \"op_type\"  \"<RRer>,RXE\")\n    (set_attr \"type\"     \"fsimp<mode>\")])\n \n+;\n+; Pointer add instruction patterns\n+;\n+\n+; This will match \"*la_64\"\n+(define_expand \"addptrdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+        (plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (match_operand:DI 2 \"nonmemory_operand\" \"\")))]\n+  \"TARGET_64BIT\"\n+{\n+  HOST_WIDE_INT c = INTVAL (operands[2]);\n+\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      if (!CONST_OK_FOR_CONSTRAINT_P (c, 'K', \"K\")\n+\t  && !CONST_OK_FOR_CONSTRAINT_P (c, 'O', \"Os\"))\n+        {\n+\t  operands[2] = force_const_mem (DImode, operands[2]);\n+\t  operands[2] = force_reg (DImode, operands[2]);\n+        }\n+      else if (!DISP_IN_RANGE (INTVAL (operands[2])))\n+        operands[2] = force_reg (DImode, operands[2]);\n+    }\n+})\n+\n+; For 31 bit we have to prevent the generated pattern from matching\n+; normal ADDs since la only does a 31 bit add.  This is supposed to\n+; match \"force_la_31\".\n+(define_expand \"addptrsi3\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t  (plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n+\t\t   (use (const_int 0))])]\n+  \"!TARGET_64BIT\"\n+{\n+  HOST_WIDE_INT c = INTVAL (operands[2]);\n+\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      if (!CONST_OK_FOR_CONSTRAINT_P (c, 'K', \"K\")\n+\t  && !CONST_OK_FOR_CONSTRAINT_P (c, 'O', \"Os\"))\n+        {\n+\t  operands[2] = force_const_mem (SImode, operands[2]);\n+\t  operands[2] = force_reg (SImode, operands[2]);\n+        }\n+      else if (!DISP_IN_RANGE (INTVAL (operands[2])))\n+        operands[2] = force_reg (SImode, operands[2]);\n+    }\n+})\n \n ;;\n ;;- Subtract instructions."}, {"sha": "85fd4b90f427189a16506b0f94146f26b494e2a7", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a4ddf2b5f8167dd49a483888f14d34c3da582f/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a4ddf2b5f8167dd49a483888f14d34c3da582f/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=72a4ddf2b5f8167dd49a483888f14d34c3da582f", "patch": "@@ -4720,6 +4720,17 @@ Add operand 2 and operand 1, storing the result in operand 0.  All operands\n must have mode @var{m}.  This can be used even on two-address machines, by\n means of constraints requiring operands 1 and 0 to be the same location.\n \n+@cindex @code{addptr@var{m}3} instruction pattern\n+@item @samp{addptr@var{m}3}\n+Like @code{add@var{m}3} but is guaranteed to only be used for address\n+calculations.  The expanded code is not allowed to clobber the\n+condition code.  It only needs to be defined if @code{add@var{m}3}\n+sets the condition code.  If adds used for address calculations and\n+normal adds are not compatible it is required to expand a distinct\n+pattern (e.g. using an unspec).  The pattern is used by LRA to emit\n+address calculations.  @code{add@var{m}3} is used if\n+@code{addptr@var{m}3} is not defined.\n+\n @cindex @code{ssadd@var{m}3} instruction pattern\n @cindex @code{usadd@var{m}3} instruction pattern\n @cindex @code{sub@var{m}3} instruction pattern"}, {"sha": "524da6731a9771b20aed1482798875238d5b8526", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a4ddf2b5f8167dd49a483888f14d34c3da582f/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a4ddf2b5f8167dd49a483888f14d34c3da582f/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=72a4ddf2b5f8167dd49a483888f14d34c3da582f", "patch": "@@ -180,10 +180,12 @@ extern void emit_libcall_block (rtx, rtx, rtx, rtx);\n    Likewise for subtraction and for just copying.  */\n extern rtx gen_add2_insn (rtx, rtx);\n extern rtx gen_add3_insn (rtx, rtx, rtx);\n+extern rtx gen_addptr3_insn (rtx, rtx, rtx);\n extern rtx gen_sub2_insn (rtx, rtx);\n extern rtx gen_sub3_insn (rtx, rtx, rtx);\n extern rtx gen_move_insn (rtx, rtx);\n extern int have_add2_insn (rtx, rtx);\n+extern int have_addptr3_insn (rtx, rtx, rtx);\n extern int have_sub2_insn (rtx, rtx);\n \n /* Emit a pair of rtl insns to compare two rtx's and to jump"}, {"sha": "c1b92d8eee463e15542a5d889f4115fdb1bc8483", "filename": "gcc/lra.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a4ddf2b5f8167dd49a483888f14d34c3da582f/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a4ddf2b5f8167dd49a483888f14d34c3da582f/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=72a4ddf2b5f8167dd49a483888f14d34c3da582f", "patch": "@@ -254,6 +254,19 @@ emit_add3_insn (rtx x, rtx y, rtx z)\n   rtx insn, last;\n \n   last = get_last_insn ();\n+\n+  if (have_addptr3_insn (x, y, z))\n+    {\n+      insn = gen_addptr3_insn (x, y, z);\n+\n+      /* If the target provides an \"addptr\" pattern it hopefully does\n+\t for a reason.  So falling back to the normal add would be\n+\t a bug.  */\n+      lra_assert (insn != NULL_RTX);\n+      emit_insn (insn);\n+      return insn;\n+    }\n+\n   insn = emit_insn (gen_rtx_SET (VOIDmode, x,\n \t\t\t\t gen_rtx_PLUS (GET_MODE (y), y, z)));\n   if (recog_memoized (insn) < 0)"}, {"sha": "c4540f8856ceff75b21e5617dbc4cad1aeec4848", "filename": "gcc/optabs.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a4ddf2b5f8167dd49a483888f14d34c3da582f/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a4ddf2b5f8167dd49a483888f14d34c3da582f/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=72a4ddf2b5f8167dd49a483888f14d34c3da582f", "patch": "@@ -4755,6 +4755,43 @@ have_add2_insn (rtx x, rtx y)\n   return 1;\n }\n \n+/* Generate and return an insn body to add Y to X.  */\n+\n+rtx\n+gen_addptr3_insn (rtx x, rtx y, rtx z)\n+{\n+  enum insn_code icode = optab_handler (addptr3_optab, GET_MODE (x));\n+\n+  gcc_assert (insn_operand_matches (icode, 0, x));\n+  gcc_assert (insn_operand_matches (icode, 1, y));\n+  gcc_assert (insn_operand_matches (icode, 2, z));\n+\n+  return GEN_FCN (icode) (x, y, z);\n+}\n+\n+/* Return true if the target implements an addptr pattern and X, Y,\n+   and Z are valid for the pattern predicates.  */\n+\n+int\n+have_addptr3_insn (rtx x, rtx y, rtx z)\n+{\n+  enum insn_code icode;\n+\n+  gcc_assert (GET_MODE (x) != VOIDmode);\n+\n+  icode = optab_handler (addptr3_optab, GET_MODE (x));\n+\n+  if (icode == CODE_FOR_nothing)\n+    return 0;\n+\n+  if (!insn_operand_matches (icode, 0, x)\n+      || !insn_operand_matches (icode, 1, y)\n+      || !insn_operand_matches (icode, 2, z))\n+    return 0;\n+\n+  return 1;\n+}\n+\n /* Generate and return an insn body to subtract Y from X.  */\n \n rtx"}, {"sha": "9b8974080357a446878d0942444ef935ad71dbd5", "filename": "gcc/optabs.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a4ddf2b5f8167dd49a483888f14d34c3da582f/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a4ddf2b5f8167dd49a483888f14d34c3da582f/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=72a4ddf2b5f8167dd49a483888f14d34c3da582f", "patch": "@@ -191,6 +191,7 @@ OPTAB_D (addv4_optab, \"addv$I$a4\")\n OPTAB_D (subv4_optab, \"subv$I$a4\")\n OPTAB_D (mulv4_optab, \"mulv$I$a4\")\n OPTAB_D (negv3_optab, \"negv$I$a3\")\n+OPTAB_D (addptr3_optab, \"addptr$a3\")\n \n OPTAB_D (smul_highpart_optab, \"smul$a3_highpart\")\n OPTAB_D (umul_highpart_optab, \"umul$a3_highpart\")"}]}