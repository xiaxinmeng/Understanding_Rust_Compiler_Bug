{"sha": "d4d4c5a87dcb900b9ec6d1abdcc656122b4c4d8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRkNGM1YTg3ZGNiOTAwYjllYzZkMWFiZGNjNjU2MTIyYjRjNGQ4YQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-08T22:37:48Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-08T22:37:48Z"}, "message": "(output_inlined_enumeration_type_die): New function.\n\n(output_inlined_structure_type_die, output_inlined_union_type_die):\nNew functions added.\n(output_entry_point_die, output_formal_parameter_die,\noutput_global_subroutine_die, output_global_variable_die,\noutput_label_die, output_lexical_block_die,\noutput_inlined_subroutine_die, output_local_variable_die,\noutput_local_subroutine_die):\nFixed to handle inline abstract & concrete (i.e. inlined) instances.\n(output_inlined_subroutine_die): Deleted.\n(output_label_die):  Don't permit the rtx associated with a named\nuser-declared label to be marked as INSN_DELETED_P.\n(output_tagged_type_instantiation):  New function added.\n(output_decl):  Call `output_tagged_type_instantiation'.\nDon't generate a pubnames label for anything marked as DECL_ABSTRACT.\n(output_die):  Generate the proper kind fo DIE for each of the four\npossible combination of {normal, inlined} {variable, parameter}.\n(dwarfout_file_scope_decl):  Don't generate pubnames entries if\nstrictly abstract.\n\n(ordering_attribute):  Only def if USE_ORDERING_ATTRIBUTE\nis defined.\n(output_array_type_die): Only call ordering_attribute if it is defined.\n(name_and_src_coords_attributes):  Don't make it inline.\nDo make it static linkage.\n(const_value_attribute):  Catch invalid kinds of rtx nodes\nby aborting for the default case in switch.\n\n(output_ptr_to_mbr_type_die):  Make it static linkage.\n(output_formal_types):  Make sure that `formal_type' is initialized.\n(output_type):  Add a default case for switch.\n(output_decl):  Don't suppress DIEs for the initial (artificial)\narguments for C++ static member functions.\n\n(ceiling, field_type, simple_type_align_in_bits,\nsimple_type_size_in_bits, field_byte_offset):  New functions added.\n(data_member_location_attribute):  Use new routine `field_byte_offset'\nto calculate the offset value for the AT_location attribute.\n(byte_size_attribute):  Use new routine `field_type' to get the\nactual type for any FIELD_DECL.  Also, use `simple_type_size_in_bits'\nto avoid potential problems with ERROR_MARKs when computing the size\nof a FIELD_DECL.\n(bit_offset_attribute):  Rewritten to use `field_byte_offset' when\ndetermining the start of the \"containing object\".\n\nFrom-SVN: r1531", "tree": {"sha": "c8b74232cb7a79251db97b2e79f0fd03d5b86f75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8b74232cb7a79251db97b2e79f0fd03d5b86f75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4d4c5a87dcb900b9ec6d1abdcc656122b4c4d8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4d4c5a87dcb900b9ec6d1abdcc656122b4c4d8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4d4c5a87dcb900b9ec6d1abdcc656122b4c4d8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4d4c5a87dcb900b9ec6d1abdcc656122b4c4d8a/comments", "author": null, "committer": null, "parents": [{"sha": "ef03bc85d59cbba3ff75de814490f4d60be1ffd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef03bc85d59cbba3ff75de814490f4d60be1ffd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef03bc85d59cbba3ff75de814490f4d60be1ffd1"}], "stats": {"total": 925, "additions": 567, "deletions": 358}, "files": [{"sha": "9dc675b851d910ae192d4a4fb8798bcfca4a6cb3", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 567, "deletions": 358, "changes": 925, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4d4c5a87dcb900b9ec6d1abdcc656122b4c4d8a/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4d4c5a87dcb900b9ec6d1abdcc656122b4c4d8a/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=d4d4c5a87dcb900b9ec6d1abdcc656122b4c4d8a", "patch": "@@ -1610,6 +1610,188 @@ output_enumeral_list (link)\n     }\n }\n \n+/* Given an unsigned value, round it up to the lowest multiple of `boundary'\n+   which is not less than the value itself.  */\n+\n+inline unsigned\n+ceiling (value, boundary)\n+     register unsigned value;\n+     register unsigned boundary;\n+{\n+  return (((value + boundary - 1) / boundary) * boundary);\n+}\n+\n+/* Given a pointer to what is assumed to be a FIELD_DECL node, return a\n+   pointer to the declared type for the relevant field variable, or return\n+   `integer_type_node' if the given node turns out to be an ERROR_MARK node.  */\n+\n+inline tree\n+field_type (decl)\n+     register tree decl;\n+{\n+  register tree type;\n+\n+  if (TREE_CODE (decl) == ERROR_MARK)\n+    return integer_type_node;\n+\n+  type = DECL_BIT_FIELD_TYPE (decl);\n+  if (type == NULL)\n+    type = TREE_TYPE (decl);\n+  return type;\n+}\n+\n+/* Given a pointer to a tree node, assumed to be some kind of a ..._TYPE\n+   node, return the alignment in bits for the type, or else return\n+   BITS_PER_WORD if the node actually turns out to be an ERROR_MARK node.  */\n+\n+inline unsigned\n+simple_type_align_in_bits (type)\n+     register tree type;\n+{\n+  return (TREE_CODE (type) != ERROR_MARK) ? TYPE_ALIGN (type) : BITS_PER_WORD;\n+}\n+\n+/* Given a pointer to a tree node, assumed to be some kind of a ..._TYPE\n+   node, return the size in bits for the type if it is a constant, or\n+   else return the alignment for the type if the type's size is not\n+   constant, or else return BITS_PER_WORD if the type actually turns out\n+   to be an ERROR_MARK node.  */\n+\n+inline unsigned\n+simple_type_size_in_bits (type)\n+     register tree type;\n+{\n+  if (TREE_CODE (type) == ERROR_MARK)\n+    return BITS_PER_WORD;\n+  else\n+    {\n+      register tree type_size_tree = TYPE_SIZE (type);\n+\n+      if (TREE_CODE (type_size_tree) != INTEGER_CST)\n+\treturn TYPE_ALIGN (type);\n+\n+      return (unsigned) TREE_INT_CST_LOW (type_size_tree);\n+    }\n+}\n+\n+/* Given a pointer to what is assumed to be a FIELD_DECL node, compute and\n+   return the byte offset of the lowest addressed byte of the \"containing\n+   object\" for the given FIELD_DECL, or return 0 if we are unable to deter-\n+   mine what that offset is, either because the argument turns out to be a\n+   pointer to an ERROR_MARK node, or because the offset is actually variable.\n+   (We can't handle the latter case just yet.)  */\n+\n+static unsigned\n+field_byte_offset (decl)\n+     register tree decl;\n+{\n+  register unsigned type_align_in_bytes;\n+  register unsigned type_align_in_bits;\n+  register unsigned type_size_in_bits;\n+  register unsigned object_offset_in_align_units;\n+  register unsigned object_offset_in_bits;\n+  register unsigned object_offset_in_bytes;\n+  register tree type;\n+  register tree bitpos_tree;\n+  register tree field_size_tree;\n+  register unsigned bitpos_int;\n+  register unsigned deepest_bitpos;\n+  register unsigned field_size_in_bits;\n+\n+  if (TREE_CODE (decl) == ERROR_MARK)\n+    return 0;\n+\n+  if (TREE_CODE (decl) != FIELD_DECL)\n+    abort ();\n+\n+  type = field_type (decl);\n+\n+  bitpos_tree = DECL_FIELD_BITPOS (decl);\n+  field_size_tree = DECL_SIZE (decl);\n+\n+  /* We cannot yet cope with fields whose positions or sizes are variable,\n+     so for now, when we see such things, we simply return 0.  Someday,\n+     we may be able to handle such cases, but it will be damn difficult.  */\n+\n+  if (TREE_CODE (bitpos_tree) != INTEGER_CST)\n+    return 0;\n+  bitpos_int = (unsigned) TREE_INT_CST_LOW (bitpos_tree);\n+\n+  if (TREE_CODE (field_size_tree) != INTEGER_CST)\n+    return 0;\n+  field_size_in_bits = (unsigned) TREE_INT_CST_LOW (field_size_tree);\n+\n+  type_size_in_bits = simple_type_size_in_bits (type);\n+\n+  type_align_in_bits = simple_type_align_in_bits (type);\n+  type_align_in_bytes = type_align_in_bits / BITS_PER_UNIT;\n+\n+  /* Note that the GCC front-end doesn't make any attempt to keep track\n+     of the starting bit offset (relative to the start of the containing\n+     structure type) of the hypothetical \"containing object\" for a bit-\n+     field.  Thus, when computing the byte offset value for the start of\n+     the \"containing object\" of a bit-field, we must deduce this infor-\n+     mation on our own.\n+\n+     This can be rather tricky to do in some cases.  For example, handling\n+     the following structure type definition when compiling for an i386/i486\n+     target (which only aligns long long's to 32-bit boundaries) can be very\n+     tricky:\n+\n+\t\tstruct S {\n+\t\t\tint\t\tfield1;\n+\t\t\tlong long\tfield2:31;\n+\t\t};\n+\n+     Fortunately, there is a simple rule-of-thumb which can be used in such\n+     cases.  When compiling for an i386/i486, GCC will allocate 8 bytes for\n+     the structure shown above.  It decides to do this based upon one simple\n+     rule for bit-field allocation.  Quite simply, GCC allocates each \"con-\n+     taining object\" for each bit-field at the first (i.e. lowest addressed)\n+     legitimate alignment boundary (based upon the required minimum alignment\n+     for the declared type of the field) which it can possibly use, subject\n+     to the condition that there is still enough available space remaining\n+     in the containing object (when allocated at the selected point) to\n+     fully accomodate all of the bits of the bit-field itself.\n+\n+     This simple rule makes it obvious why GCC allocates 8 bytes for each\n+     object of the structure type shown above.  When looking for a place to\n+     allocate the \"containing object\" for `field2', the compiler simply tries\n+     to allocate a 64-bit \"containing object\" at each successive 32-bit\n+     boundary (starting at zero) until it finds a place to allocate that 64-\n+     bit field such that at least 31 contiguous (and previously unallocated)\n+     bits remain within that selected 64 bit field.  (As it turns out, for\n+     the example above, the compiler finds that it is OK to allocate the\n+     \"containing object\" 64-bit field at bit-offset zero within the\n+     structure type.)\n+\n+     Here we attempt to work backwards from the limited set of facts we're\n+     given, and we try to deduce from those facts, where GCC must have\n+     believed that the containing object started (within the structure type).\n+\n+     The value we deduce is then used (by the callers of this routine) to\n+     generate AT_location and AT_bit_offset attributes for fields (both\n+     bit-fields and, in the case of AT_location, regular fields as well).\n+  */\n+\n+  /* Figure out the bit-distance from the start of the structure to the\n+     \"deepest\" bit of the bit-field.  */\n+  deepest_bitpos = bitpos_int + field_size_in_bits;\n+\n+  /* This is the tricky part.  Use some fancy footwork to deduce where the\n+     lowest addressed bit of the containing object must be.  */\n+  object_offset_in_bits\n+    = ceiling (deepest_bitpos, type_align_in_bits) - type_size_in_bits;\n+\n+  /* Compute the offset of the containing object in \"alignment units\".  */\n+  object_offset_in_align_units = object_offset_in_bits / type_align_in_bits;\n+\n+  /* Compute the offset of the containing object in bytes.  */\n+  object_offset_in_bytes = object_offset_in_align_units * type_align_in_bytes;\n+\n+  return object_offset_in_bytes;\n+}\n+\n /****************************** attributes *********************************/\n \n /* The following routines are responsible for writing out the various types\n@@ -1662,164 +1844,42 @@ location_attribute (rtl)\n }\n \n /* Output the specialized form of location attribute used for data members\n-   of struct types.\n+   of struct and union types.\n \n    In the special case of a FIELD_DECL node which represents a bit-field,\n    the \"offset\" part of this special location descriptor must indicate the\n    distance in bytes from the lowest-addressed byte of the containing\n    struct or union type to the lowest-addressed byte of the \"containing\n-   object\" for the bit-field.\n+   object\" for the bit-field.  (See the `field_byte_offset' function above.)\n \n    For any given bit-field, the \"containing object\" is a hypothetical\n    object (of some integral or enum type) within which the given bit-field\n    lives.  The type of this hypothetical \"containing object\" is always the\n-   same as the declared type of the individual bit-field itself.\n+   same as the declared type of the individual bit-field itself (for GCC\n+   anyway... the DWARF spec doesn't actually mandate this).\n \n    Note that it is the size (in bytes) of the hypothetical \"containing\n    object\" which will be given in the AT_byte_size attribute for this\n-   bit-field.  (See the `byte_size_attribute' function below.)\n+   bit-field.  (See the `byte_size_attribute' function below.)  It is\n+   also used when calculating the value of the AT_bit_offset attribute.\n+   (See the `bit_offset_attribute' function below.)\n */\n \n-\n static void\n data_member_location_attribute (decl)\n      register tree decl;\n {\n+  register unsigned object_offset_in_bytes = field_byte_offset (decl);\n   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n-  register unsigned type_align_in_bytes;\n-  register unsigned type_align_in_bits;\n-  register unsigned offset_in_align_units;\n-  register unsigned offset_in_bytes;\n-  register tree type;\n-  register tree bitpos_tree = DECL_FIELD_BITPOS (decl);\n-  register unsigned bitpos_int;\n-\n-  if (TREE_CODE (decl) == ERROR_MARK)\n-    return;\n-\n-  if (TREE_CODE (decl) != FIELD_DECL)\n-    abort ();\n-\n-  /* The bit position given by DECL_FIELD_BITPOS could be non-constant\n-     in the case where one or more variable sized members preceded this\n-     member in the containing struct type.  We could probably correctly\n-     handle this case someday, by it's too complicated to deal with at\n-     the moment (and probably too rare to worry about), so just punt on\n-     the whole AT_location attribute for now.  Eventually, we'll have\n-     to analyze the expression given as the DECL_FIELD_BITPOS and turn\n-     it into a member-style AT_location descriptor, but that'll be\n-     tough to do.  -- rfg  */\n-\n-  if (TREE_CODE (bitpos_tree) != INTEGER_CST)\n-    return;\n-  bitpos_int = (unsigned) TREE_INT_CST_LOW (bitpos_tree);\n \n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_location);\n   sprintf (begin_label, LOC_BEGIN_LABEL_FMT, current_dienum);\n   sprintf (end_label, LOC_END_LABEL_FMT, current_dienum);\n   ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, end_label, begin_label);\n   ASM_OUTPUT_LABEL (asm_out_file, begin_label);\n   ASM_OUTPUT_DWARF_STACK_OP (asm_out_file, OP_CONST);\n-\n-  type = DECL_BIT_FIELD_TYPE (decl);\n-  if (type == NULL)\n-    type = TREE_TYPE (decl);\n-\n-  type_align_in_bits = TYPE_ALIGN (type);\n-  type_align_in_bytes = type_align_in_bits / BITS_PER_UNIT;\n-\n-  /* WARNING!  Note that the GCC front-end doesn't make any attempt to\n-     keep track of the starting bit offset (relative to the start of\n-     the containing structure type) of the hypothetical \"containing\n-     object\" for a bit-field.  (See the comments at the start of this\n-     function.)  Thus, when computing the byte offset value for a\n-     bit-field, all we can do is to divide the starting bit offset of\n-     the bit-field by the alignment of the hypothetical \"containing\n-     object\" (which we can easily find) and then multiply by the number\n-     of bytes of that alignment.\n-\n-     This solution only yields an unambiguously correct result when\n-     the size of the bit-field is strictly larger than the size of the\n-     declared type minus the alignment of the declared type.  When this\n-     condition is not satisfied, it means that there is at least an\n-     \"alignment unit's\" worth of other slop which co-resides within the\n-     hypothetical \"containing object\" with the bit field, and this other\n-     slop could be either to the left of the bit-field or to the right\n-     of the bit-field. (We have no way of knowing which.)\n-\n-     It also means that we cannot unambiguously tell exactly where the\n-     hypothetical \"containing object\" begins within the containing struct\n-     type.  We only know the precise position of the bit-field which is\n-     contained therein, and that the hypothetical containing object must\n-     be aligned as required for its type.  But when there is at least an\n-     alignment unit's worth of slop co-resident in the containing object\n-     with the actual bit-field, the actual start of the containing object\n-     is ambiguous and thus, we cannot unambiguously determine the \"correct\"\n-     byte offset to put into the AT_location attribute for the bit-field\n-     itself.\n-\n-     This whole thing is a non-issue for the majority of targets, because\n-     (for most GCC targets) the alignment of each supported integral type\n-     is the same as the size of that type, and thus (size - alignment) for\n-     the declared type of any bit-field yields zero, and the size (in bits)\n-     of any bit-field must be bigger than zero, so there is never any\n-     ambiguity about the starting positions of the containing objects of\n-     bit-fields for most GCC targets.\n-\n-     An exception arises however for some machines (e.g. i386) which have\n-     BIGGEST_ALIGNMENT set to something less than the size of type `long\n-     long' (i.e. 64) and when we are confronted with something like:\n-\n-\t\tstruct S {\n-\t\t\tint\t\tfield1;\n-\t\t\tlong long\tfield2:31;\n-\t\t};\n-\n-     Here it is ambiguous (going by DWARF rules anyway) whether the con-\n-     taining `long long' object for `field2' should be said to occupy the\n-     first and second (32-bit) words of the containing struct type, or\n-     whether it should be said to occupy the second and third words of\n-     the struct type.\n-\n-     Currently, GCC allocates 8 bytes (for an i386 target) for each object\n-     of the above type.  This is probably a bug however, and GCC should\n-     probably be allocating 12 bytes for each such structure (for the i386\n-     target).\n-\n-     Assuming this bug gets fixed, one would have a strong case for saying\n-     that the containing `long long' object for `field2' occupies the second\n-     and third words of the above structure type, and that `field2' itself\n-     occupies the first 31 bits of that containing object.  However consider:\n-\n-\t\tstruct S {\n-\t\t\tint\t\tfield1;\n-\t\t\tlong long\tfield2:31;\n-\t\t\tlong long\tfield3:2;\n-\t\t\tlong long\tfield4:31;\n-\t\t};\n-\n-     Even if the current \"member allocation\" bug in GCC is fixed, this ex-\n-     ample would still illustrate a case in which the starting point of the\n-     containing `long long' object for `field4' would be ambiguous, even\n-     though we know the exact starting bit offset (within the structure) of\n-     the `field4' bit-field itself.\n-\n-     We essentially just ignore this whole issue here and always act as if\n-     most of the slop which co-resides in a containing object along with a\n-     bit-field appears in that containing object *AFTER* the bit field.\n-     Thus, for the above example, we say that the containing object for\n-     `field4' occupies the third and fourth words of the structure type,\n-     even though objects of the type only occupy three words.  As long\n-     as the debugger understands that the compiler uses this disambiguation\n-     rule, the debugger should easily be able to do the Right Thing in all\n-     cases.\n-  */\n-\n-  offset_in_align_units = bitpos_int / type_align_in_bits;\n-  offset_in_bytes = offset_in_align_units * type_align_in_bytes;\n-\n-  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, offset_in_bytes);\n+  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, object_offset_in_bytes);\n   ASM_OUTPUT_DWARF_STACK_OP (asm_out_file, OP_ADD);\n   ASM_OUTPUT_LABEL (asm_out_file, end_label);\n }\n@@ -1895,6 +1955,9 @@ const_value_attribute (rtl)\n \t   we just punt and generate an AT_const_value attribute with form\n \t   FORM_BLOCK4 and a length of zero.  */\n \tbreak;\n+\n+      default:\n+\tabort ();  /* No other kinds of rtx should be possible here.  */\n     }\n \n   ASM_OUTPUT_LABEL (asm_out_file, end_label);\n@@ -2083,13 +2146,15 @@ mod_u_d_type_attribute (type, decl_const, decl_volatile)\n   ASM_OUTPUT_LABEL (asm_out_file, end_label);\n }\n \n+#ifdef USE_ORDERING_ATTRIBUTE\n inline void\n ordering_attribute (ordering)\n      register unsigned ordering;\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_ordering);\n   ASM_OUTPUT_DWARF_DATA2 (asm_out_file, ordering);\n }\n+#endif /* defined(USE_ORDERING_ATTRIBUTE) */\n \n /* Note that the block of subscript information for an array type also\n    includes information about the element type of type given array type.  */\n@@ -2217,12 +2282,11 @@ byte_size_attribute (tree_node)\n \n       case FIELD_DECL:\n \t/* For a data member of a struct or union, the AT_byte_size is\n-\t   always given as the number of bytes normally allocated for\n+\t   generally given as the number of bytes normally allocated for\n \t   an object of the *declared* type of the member itself.  This\n \t   is true even for bit-fields.  */\n-\tsize = int_size_in_bytes (DECL_BIT_FIELD_TYPE (tree_node)\n-\t\t\t\t  ? DECL_BIT_FIELD_TYPE (tree_node)\n-\t\t\t\t  : TREE_TYPE (tree_node));\n+\tsize = simple_type_size_in_bits (field_type (tree_node))\n+\t       / BITS_PER_UNIT;\n \tbreak;\n \n       default:\n@@ -2247,6 +2311,10 @@ byte_size_attribute (tree_node)\n    lives.  The type of this hypothetical \"containing object\" is always the\n    same as the declared type of the individual bit-field itself.\n \n+   The determination of the exact location of the \"containing object\" for\n+   a bit-field is rather complicated.  It's handled by the `field_byte_offset'\n+   function (above).\n+\n    Note that it is the size (in bytes) of the hypothetical \"containing\n    object\" which will be given in the AT_byte_size attribute for this\n    bit-field.  (See `byte_size_attribute' above.)\n@@ -2256,51 +2324,50 @@ inline void\n bit_offset_attribute (decl)\n     register tree decl;\n {\n+  register unsigned object_offset_in_bytes = field_byte_offset (decl);\n   register tree type = DECL_BIT_FIELD_TYPE (decl);\n-  register unsigned dwarf_bit_offset;\n   register tree bitpos_tree = DECL_FIELD_BITPOS (decl);\n   register unsigned bitpos_int;\n+  register unsigned highest_order_object_bit_offset;\n+  register unsigned highest_order_field_bit_offset;\n+  register unsigned bit_offset;\n \n   assert (TREE_CODE (decl) == FIELD_DECL);\t/* Must be a field.  */\n   assert (type);\t\t\t\t/* Must be a bit field.\t */\n \n-  /* The bit position given by DECL_FIELD_BITPOS could be non-constant\n-     in the case where one or more variable sized members preceded this\n-     member in the containing struct type.  We could probably correctly\n-     handle this case someday, by it's too complicated to deal with at\n-     the moment, so just punt on the whole AT_bit_offset attribute for\n-     now.  Eventually, we'll have to analyze the (variable) expression\n-     given as the DECL_FIELD_BITPOS and see if we can factor out just\n-     the (constant) bit offset part of that expression.  -- rfg  */\n+  /* We can't yet handle bit-fields whose offsets are variable, so if we\n+     encounter such things, just return without generating any attribute\n+     whatsoever.  */\n \n   if (TREE_CODE (bitpos_tree) != INTEGER_CST)\n     return;\n   bitpos_int = (unsigned) TREE_INT_CST_LOW (bitpos_tree);\n \n-  /* For a detailed description of how the AT_bit_offset attribute value\n-     is calculated, see the comments in `data_member_location_attribute'\n-     above.  */\n+  /* Note that the bit offset is always the distance (in bits) from the\n+     highest-order bit of the \"containing object\" to the highest-order\n+     bit of the bit-field itself.  Since the \"high-order end\" of any\n+     object or field is different on big-endian and little-endian machines,\n+     the computation below must take account of these differences.  */\n \n-#if (BYTES_BIG_ENDIAN == 1)\n-  dwarf_bit_offset = bitpos_int % TYPE_ALIGN (type);\n-#else\n-  {\n-    register unsigned high_order_bitpos\n-      = bitpos_int + (unsigned) TREE_INT_CST_LOW (DECL_SIZE (decl));\n-    register tree type_size_tree = TYPE_SIZE (type);\n-    register unsigned type_size_in_bits;\n+  highest_order_object_bit_offset = object_offset_in_bytes * BITS_PER_UNIT;\n+  highest_order_field_bit_offset = bitpos_int;\n \n-    if (TREE_CODE (type_size_tree) != INTEGER_CST)\n-      abort ();\n-    type_size_in_bits = (unsigned) TREE_INT_CST_LOW (type_size_tree);\n+#if (BYTES_BIG_ENDIAN == 0)\n+  highest_order_field_bit_offset\n+    += (unsigned) TREE_INT_CST_LOW (DECL_SIZE (decl));\n \n-    dwarf_bit_offset = type_size_in_bits\n-\t\t\t- (high_order_bitpos % TYPE_ALIGN (type));\n-  }\n-#endif\n+  highest_order_object_bit_offset += simple_type_size_in_bits (type);\n+#endif /* (BYTES_BIG_ENDIAN == 0) */\n+\n+  bit_offset =\n+#if (BYTES_BIG_ENDIAN == 0)\n+\t  highest_order_object_bit_offset - highest_order_field_bit_offset;\n+#else /* (BYTES_BIG_ENDIAN != 0) */\n+\t  highest_order_field_bit_offset - highest_order_object_bit_offset;\n+#endif /* (BYTES_BIG_ENDIAN != 0) */\n \n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_bit_offset);\n-  ASM_OUTPUT_DWARF_DATA2 (asm_out_file, dwarf_bit_offset);\n+  ASM_OUTPUT_DWARF_DATA2 (asm_out_file, bit_offset);\n }\n \n /* For a FIELD_DECL node which represents a bit field, output an attribute\n@@ -2559,7 +2626,7 @@ pure_or_virtual_attribute (func_decl)\n /* Output an AT_name attribute and an AT_src_coords attribute for the\n    given decl, but only if it actually has a name.  */\n \n-inline void\n+static void\n name_and_src_coords_attributes (decl)\n     register tree decl;\n {\n@@ -2588,7 +2655,7 @@ name_and_src_coords_attributes (decl)\n \n         src_coords_attribute (file_index, DECL_SOURCE_LINE (decl));\n       }\n-#endif\n+#endif /* defined(DWARF_DECL_COORDINATES) */\n     }\n }\n \n@@ -2736,9 +2803,9 @@ output_array_type_die (arg)\n      we will only do so for multidimensional arrays.  After all, we don't\n      want to waste space in the .debug section now do we?)  */\n \n-#if 0\n+#ifdef USE_ORDERING_ATTRIBUTE\n   ordering_attribute (ORD_row_major);\n-#endif\n+#endif /* defined(USE_ORDERING_ATTRIBUTE) */\n \n   subscript_data_attribute (type);\n }\n@@ -2763,18 +2830,68 @@ output_entry_point_die (arg)\n      register void *arg;\n {\n   register tree decl = arg;\n-  register tree type = TREE_TYPE (decl);\n-  register tree return_type = TREE_TYPE (type);\n+  register tree origin = decl_ultimate_origin (decl);\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_entry_point);\n   sibling_attribute ();\n   dienum_push ();\n-  name_and_src_coords_attributes (decl);\n-  member_attribute (DECL_CONTEXT (decl));\n-  type_attribute (return_type, 0, 0);\n+  if (origin != NULL)\n+    abstract_origin_attribute (origin);\n+  else\n+    {\n+      name_and_src_coords_attributes (decl);\n+      member_attribute (DECL_CONTEXT (decl));\n+      type_attribute (TREE_TYPE (TREE_TYPE (decl)), 0, 0);\n+    }\n+  if (DECL_ABSTRACT (decl))\n+    equate_decl_number_to_die_number (decl);\n+  else\n+    low_pc_attribute (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n }\n #endif\n \n+/* Output a DIE to represent an inlined instance of an enumeration type.  */\n+\n+static void\n+output_inlined_enumeration_type_die (arg)\n+     register void *arg;\n+{\n+  register tree type = arg;\n+\n+  ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_enumeration_type);\n+  sibling_attribute ();\n+  assert (TREE_ASM_WRITTEN (type));\n+  abstract_origin_attribute (type);\n+}\n+\n+/* Output a DIE to represent an inlined instance of a structure type.  */\n+\n+static void\n+output_inlined_structure_type_die (arg)\n+     register void *arg;\n+{\n+  register tree type = arg;\n+\n+  ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_structure_type);\n+  sibling_attribute ();\n+  assert (TREE_ASM_WRITTEN (type));\n+  abstract_origin_attribute (type);\n+}\n+\n+/* Output a DIE to represent an inlined instance of a union type.  */\n+\n+static void\n+output_inlined_union_type_die (arg)\n+     register void *arg;\n+{\n+  register tree type = arg;\n+\n+  ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_union_type);\n+  sibling_attribute ();\n+  assert (TREE_ASM_WRITTEN (type));\n+  abstract_origin_attribute (type);\n+}\n+\n /* Output a DIE to represent an enumeration type.  Note that these DIEs\n    include all of the information about the enumeration values also.\n    This information is encoded into the element_list attribute.\t */\n@@ -2807,37 +2924,51 @@ output_enumeration_type_die (arg)\n    function type.\n \n    Note that this routine is a bit unusual because its argument may be\n-   either a PARM_DECL node or else some sort of a ..._TYPE node.  If it's\n-   the formar then this function is being called to output a real live\n-   formal parameter declaration.  If it's the latter, then this function\n-   is only being called to output a TAG_formal_parameter DIE to stand as\n-   a placeholder for some formal argument type of some subprogram type.  */\n+   a ..._DECL node (i.e. either a PARM_DECL or perhaps a VAR_DECL which\n+   represents an inlining of some PARM_DECL) or else some sort of a\n+   ..._TYPE node.  If it's the former then this function is being called\n+   to output a DIE to represent a formal parameter object (or some inlining\n+   thereof).  If it's the latter, then this function is only being called\n+   to output a TAG_formal_parameter DIE to stand as a placeholder for some\n+   formal argument type of some subprogram type.  */\n \n static void\n output_formal_parameter_die (arg)\n      register void *arg;\n {\n-  register tree decl = arg;\n-  register tree type;\n-\n-  if (TREE_CODE (decl) == PARM_DECL)\n-    type = TREE_TYPE (decl);\n-  else\n-    {\n-      type = decl;\t/* we were called with a type, not a decl */\n-      decl = NULL;\n-    }\n+  register tree node = arg;\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_formal_parameter);\n   sibling_attribute ();\n-  if (decl)\n+\n+  switch (TREE_CODE_CLASS (TREE_CODE (node)))\n     {\n-      name_and_src_coords_attributes (decl);\n-      type_attribute (type, TREE_READONLY (decl), TREE_THIS_VOLATILE (decl));\n-      location_or_const_value_attribute (decl);\n+    case 'd':\t/* We were called with some kind of a ..._DECL node.  */\n+      {\n+\tregister tree origin = decl_ultimate_origin (node);\n+\n+\tif (origin != NULL)\n+\t  abstract_origin_attribute (origin);\n+\telse\n+\t  {\n+\t    name_and_src_coords_attributes (node);\n+\t    type_attribute (TREE_TYPE (node),\n+\t\t\t    TREE_READONLY (node), TREE_THIS_VOLATILE (node));\n+\t  }\n+\tif (DECL_ABSTRACT (node))\n+\t  equate_decl_number_to_die_number (node);\n+\telse\n+\t  location_or_const_value_attribute (node);\n+      }\n+      break;\n+\n+    case 't':\t/* We were called with some kind of a ..._TYPE node.  */\n+      type_attribute (node, 0, 0);\n+      break;\n+\n+    default:\n+      abort ();\t/* Should never happen.  */\n     }\n-  else\n-    type_attribute (type, 0, 0);\n }\n \n /* Output a DIE to represent a declared function (either file-scope\n@@ -2848,24 +2979,36 @@ output_global_subroutine_die (arg)\n      register void *arg;\n {\n   register tree decl = arg;\n-  register tree type = TREE_TYPE (decl);\n-  register tree return_type = TREE_TYPE (type);\n+  register tree origin = decl_ultimate_origin (decl);\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_global_subroutine);\n   sibling_attribute ();\n   dienum_push ();\n-  name_and_src_coords_attributes (decl);\n-  inline_attribute (decl);\n-  prototyped_attribute (type);\n-  member_attribute (DECL_CONTEXT (decl));\n-  type_attribute (return_type, 0, 0);\n-  if (!TREE_EXTERNAL (decl))\n+  if (origin != NULL)\n+    abstract_origin_attribute (origin);\n+  else\n     {\n-      char func_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+      register tree type = TREE_TYPE (decl);\n \n-      low_pc_attribute (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n-      sprintf (func_end_label, FUNC_END_LABEL_FMT, current_funcdef_number);\n-      high_pc_attribute (func_end_label);\n+      name_and_src_coords_attributes (decl);\n+      inline_attribute (decl);\n+      prototyped_attribute (type);\n+      member_attribute (DECL_CONTEXT (decl));\n+      type_attribute (TREE_TYPE (type), 0, 0);\n+      pure_or_virtual_attribute (decl);\n+    }\n+  if (DECL_ABSTRACT (decl))\n+    equate_decl_number_to_die_number (decl);\n+  else\n+    {\n+      if (! TREE_EXTERNAL (decl))\n+\t{\n+\t  char func_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+\n+\t  low_pc_attribute (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n+\t  sprintf (func_end_label, FUNC_END_LABEL_FMT, current_funcdef_number);\n+\t  high_pc_attribute (func_end_label);\n+\t}\n     }\n }\n \n@@ -2877,103 +3020,64 @@ output_global_variable_die (arg)\n      register void *arg;\n {\n   register tree decl = arg;\n-  register tree type = TREE_TYPE (decl);\n+  register tree origin = decl_ultimate_origin (decl);\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_global_variable);\n   sibling_attribute ();\n-  name_and_src_coords_attributes (decl);\n-  member_attribute (DECL_CONTEXT (decl));\n-  type_attribute (type, TREE_READONLY (decl), TREE_THIS_VOLATILE (decl));\n-  if (!TREE_EXTERNAL (decl))\n-    location_or_const_value_attribute (decl);\n-}\n-\n-#if 0\n-/* TAG_inline_subroutine has been retired by the UI/PLSIG.  We're\n-   now supposed to use either TAG_subroutine or TAG_global_subroutine\n-   (depending on whether or not the function in question has internal\n-   or external linkage) and we're supposed to just put in an AT_inline\n-   attribute.  */\n-static void\n-output_inline_subroutine_die (arg)\n-     register void *arg;\n-{\n-  register tree decl = arg;\n-  register tree type = TREE_TYPE (decl);\n-  register tree return_type = TREE_TYPE (type);\n-\n-  ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_inline_subroutine);\n-  sibling_attribute ();\n-  dienum_push ();\n-  name_and_src_coords_attributes (decl);\n-  prototyped_attribute (type);\n-  member_attribute (DECL_CONTEXT (decl));\n-  type_attribute (return_type, 0, 0);\n-\n-  /* Note:  For each inline function which gets an out-of-line body\n-     generated for it, we want to generate AT_low_pc and AT_high_pc\n-     attributes here for the function's out-of-line body.\n-\n-     Unfortunately, the decision as to whether or not to generate an\n-     out-of-line body for any given inline function may not be made\n-     until we reach the end of the containing scope for the given\n-     inline function (because only then will it be known if the\n-     function was ever even called).\n-\n-     For this reason, the output of DIEs representing file-scope inline\n-     functions gets delayed until a special post-pass which happens only\n-     after we have reached the end of the compilation unit.  Because of\n-     this mechanism, we can always be sure (by the time we reach here)\n-     that TREE_ASM_WRITTEN(decl) will correctly indicate whether or not\n-     there was an out-of-line body generated for this inline function.\n-  */\n-\n-  if (!TREE_EXTERNAL (decl))\n+  if (origin != NULL)\n+    abstract_origin_attribute (origin);\n+  else\n     {\n-      if (TREE_ASM_WRITTEN (decl))\n-        {\n-          char func_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n-\n-          low_pc_attribute (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n-          sprintf (func_end_label, FUNC_END_LABEL_FMT, current_funcdef_number);\n-          high_pc_attribute (func_end_label);\n-        }\n+      name_and_src_coords_attributes (decl);\n+      member_attribute (DECL_CONTEXT (decl));\n+      type_attribute (TREE_TYPE (decl),\n+\t\t      TREE_READONLY (decl), TREE_THIS_VOLATILE (decl));\n+    }\n+  if (DECL_ABSTRACT (decl))\n+    equate_decl_number_to_die_number (decl);\n+  else\n+    {\n+      if (!TREE_EXTERNAL (decl))\n+\tlocation_or_const_value_attribute (decl);\n     }\n }\n-#endif\n \n static void\n output_label_die (arg)\n      register void *arg;\n {\n   register tree decl = arg;\n-  register rtx insn = DECL_RTL (decl);\n+  register tree origin = decl_ultimate_origin (decl);\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_label);\n   sibling_attribute ();\n-  name_and_src_coords_attributes (decl);\n+  if (origin != NULL)\n+    abstract_origin_attribute (origin);\n+  else\n+    name_and_src_coords_attributes (decl);\n+  if (DECL_ABSTRACT (decl))\n+    equate_decl_number_to_die_number (decl);\n+  else\n+    {\n+      register rtx insn = DECL_RTL (decl);\n \n-  /* When optimization is enabled (with -O) the code in jump.c and in flow.c\n-     may cause insns representing one of more of the user's own labels to\n-     be deleted.  This happens whenever it is determined that a given label\n-     is unreachable.\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\t{\n+\t  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n-     In such cases, we here generate an abbreviated form of a label DIE.\n-     This abbreviated version does *not* have a low_pc attribute.  This\n-     should signify to the debugger that the label has been optimized away.\n+\t  /* When optimization is enabled (via -O) some parts of the compiler\n+\t     (e.g. jump.c and cse.c) may try to delete CODE_LABEL insns which\n+\t     represent source-level labels which were explicitly declared by\n+\t     the user.  This really shouldn't be happening though, so catch\n+\t     it if it ever does happen.  */\n \n-     Note that a CODE_LABEL can get deleted either by begin converted into\n-     a NOTE_INSN_DELETED note, or by simply having its INSN_DELETED_P flag\n-     set to true.  We handle both cases here.\n-  */\n+\t  if (INSN_DELETED_P (insn))\n+\t    abort ();\t/* Should never happen.  */\n \n-  if (GET_CODE (insn) == CODE_LABEL && ! INSN_DELETED_P (insn))\n-    {\n-      char label[MAX_ARTIFICIAL_LABEL_BYTES];\n-\n-      sprintf (label, INSN_LABEL_FMT, current_funcdef_number,\n-\t\t\t\t      (unsigned) INSN_UID (insn));\n-      low_pc_attribute (label);\n+\t  sprintf (label, INSN_LABEL_FMT, current_funcdef_number,\n+\t\t\t\t          (unsigned) INSN_UID (insn));\n+\t  low_pc_attribute (label);\n+\t}\n     }\n }\n \n@@ -2982,33 +3086,42 @@ output_lexical_block_die (arg)\n      register void *arg;\n {\n   register tree stmt = arg;\n-  char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n-  char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_lexical_block);\n   sibling_attribute ();\n   dienum_push ();\n-  sprintf (begin_label, BLOCK_BEGIN_LABEL_FMT, next_block_number);\n-  low_pc_attribute (begin_label);\n-  sprintf (end_label, BLOCK_END_LABEL_FMT, next_block_number);\n-  high_pc_attribute (end_label);\n+  if (! BLOCK_ABSTRACT (stmt))\n+    {\n+      char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+      char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+\n+      sprintf (begin_label, BLOCK_BEGIN_LABEL_FMT, next_block_number);\n+      low_pc_attribute (begin_label);\n+      sprintf (end_label, BLOCK_END_LABEL_FMT, next_block_number);\n+      high_pc_attribute (end_label);\n+    }\n }\n \n static void\n output_inlined_subroutine_die (arg)\n      register void *arg;\n {\n   register tree stmt = arg;\n-  char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n-  char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_inlined_subroutine);\n   sibling_attribute ();\n   dienum_push ();\n-  sprintf (begin_label, BLOCK_BEGIN_LABEL_FMT, next_block_number);\n-  low_pc_attribute (begin_label);\n-  sprintf (end_label, BLOCK_END_LABEL_FMT, next_block_number);\n-  high_pc_attribute (end_label);\n+  abstract_origin_attribute (block_ultimate_origin (stmt));\n+  if (! BLOCK_ABSTRACT (stmt))\n+    {\n+      char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+      char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+\n+      sprintf (begin_label, BLOCK_BEGIN_LABEL_FMT, next_block_number);\n+      low_pc_attribute (begin_label);\n+      sprintf (end_label, BLOCK_END_LABEL_FMT, next_block_number);\n+      high_pc_attribute (end_label);\n+    }\n }\n \n /* Output a DIE to represent a declared data object (either file-scope\n@@ -3019,14 +3132,23 @@ output_local_variable_die (arg)\n      register void *arg;\n {\n   register tree decl = arg;\n-  register tree type = TREE_TYPE (decl);\n+  register tree origin = decl_ultimate_origin (decl);\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_local_variable);\n   sibling_attribute ();\n-  name_and_src_coords_attributes (decl);\n-  member_attribute (DECL_CONTEXT (decl));\n-  type_attribute (type, TREE_READONLY (decl), TREE_THIS_VOLATILE (decl));\n-  location_or_const_value_attribute (decl);\n+  if (origin != NULL)\n+    abstract_origin_attribute (origin);\n+  else\n+    {\n+      name_and_src_coords_attributes (decl);\n+      member_attribute (DECL_CONTEXT (decl));\n+      type_attribute (TREE_TYPE (decl),\n+\t\t      TREE_READONLY (decl), TREE_THIS_VOLATILE (decl));\n+    }\n+  if (DECL_ABSTRACT (decl))\n+    equate_decl_number_to_die_number (decl);\n+  else\n+    location_or_const_value_attribute (decl);\n }\n \n static void\n@@ -3051,13 +3173,8 @@ output_member_die (arg)\n }\n \n #if 0\n-/* Don't generate either pointer_type DIEs or reference_type DIEs.  According\n-   to the 4-4-90 Dwarf draft spec (just after requirement #47):\n-\n-\tThese two type entries are not currently generated by any compiler.\n-\tSince the only way to name a pointer (or reference) type is C or C++\n-\tis via a \"typedef\", an entry with the \"typedef\" tag is generated\n-\tinstead.\n+/* Don't generate either pointer_type DIEs or reference_type DIEs.  Use\n+   modified types instead.\n \n    We keep this code here just in case these types of DIEs may be needed\n    to represent certain things in other languages (e.g. Pascal) someday.\n@@ -3090,6 +3207,7 @@ output_reference_type_die (arg)\n }\n #endif\n \n+static void\n output_ptr_to_mbr_type_die (arg)\n      register void *arg;\n {\n@@ -3160,8 +3278,7 @@ output_string_type_die (arg)\n \n   /* Fudge the string length attribute for now.  */\n \n-  string_length_attribute (\n-\tTYPE_MAX_VALUE (TYPE_DOMAIN (type)));\n+  string_length_attribute (TYPE_MAX_VALUE (TYPE_DOMAIN (type)));\n }\n \n static void\n@@ -3197,27 +3314,39 @@ output_local_subroutine_die (arg)\n      register void *arg;\n {\n   register tree decl = arg;\n-  register tree type = TREE_TYPE (decl);\n-  register tree return_type = TREE_TYPE (type);\n-  char func_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+  register tree origin = decl_ultimate_origin (decl);\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_subroutine);\n   sibling_attribute ();\n   dienum_push ();\n-  name_and_src_coords_attributes (decl);\n-  inline_attribute (decl);\n-  prototyped_attribute (type);\n-  member_attribute (DECL_CONTEXT (decl));\n-  type_attribute (return_type, 0, 0);\n-\n-  /* Avoid getting screwed up in cases where a function was declared static\n-     but where no definition was ever given for it.  */\n+  if (origin != NULL)\n+    abstract_origin_attribute (origin);\n+  else\n+    {\n+      register tree type = TREE_TYPE (decl);\n \n-  if (TREE_ASM_WRITTEN (decl))\n+      name_and_src_coords_attributes (decl);\n+      inline_attribute (decl);\n+      prototyped_attribute (type);\n+      member_attribute (DECL_CONTEXT (decl));\n+      type_attribute (TREE_TYPE (type), 0, 0);\n+      pure_or_virtual_attribute (decl);\n+    }\n+  if (DECL_ABSTRACT (decl))\n+    equate_decl_number_to_die_number (decl);\n+  else\n     {\n-      low_pc_attribute (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n-      sprintf (func_end_label, FUNC_END_LABEL_FMT, current_funcdef_number);\n-      high_pc_attribute (func_end_label);\n+      /* Avoid getting screwed up in cases where a function was declared\n+\t static but where no definition was ever given for it.  */\n+\n+      if (TREE_ASM_WRITTEN (decl))\n+\t{\n+\t  char func_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+\n+\t  low_pc_attribute (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n+\t  sprintf (func_end_label, FUNC_END_LABEL_FMT, current_funcdef_number);\n+\t  high_pc_attribute (func_end_label);\n+\t}\n     }\n }\n \n@@ -3242,13 +3371,21 @@ output_typedef_die (arg)\n      register void *arg;\n {\n   register tree decl = arg;\n-  register tree type = TREE_TYPE (decl);\n+  register tree origin = decl_ultimate_origin (decl);\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_typedef);\n   sibling_attribute ();\n-  name_and_src_coords_attributes (decl);\n-  member_attribute (DECL_CONTEXT (decl));\n-  type_attribute (type, TREE_READONLY (decl), TREE_THIS_VOLATILE (decl));\n+  if (origin != NULL)\n+    abstract_origin_attribute (origin);\n+  else\n+    {\n+      name_and_src_coords_attributes (decl);\n+      member_attribute (DECL_CONTEXT (decl));\n+      type_attribute (TREE_TYPE (decl),\n+\t\t      TREE_READONLY (decl), TREE_THIS_VOLATILE (decl));\n+    }\n+  if (DECL_ABSTRACT (decl))\n+    equate_decl_number_to_die_number (decl);\n }\n \n static void\n@@ -3389,7 +3526,7 @@ output_formal_types (function_or_method_type)\n      register tree function_or_method_type;\n {\n   register tree link;\n-  register tree formal_type;\n+  register tree formal_type = NULL;\n   register tree first_parm_type = TYPE_ARG_TYPES (function_or_method_type);\n \n   /* In the case where we are generating a formal types list for a C++\n@@ -3718,6 +3855,9 @@ output_type (type, containing_scope)\n \t  case UNION_TYPE:\n \t    output_die (output_union_type_die, type);\n \t    break;\n+\n+\t  default:\n+\t    abort ();\t/* Should never happen.  */\n \t  }\n \n \t/* If this is not an incomplete type, output descriptions of\n@@ -3799,6 +3939,44 @@ output_type (type, containing_scope)\n \n   TREE_ASM_WRITTEN (type) = 1;\n }\n+\n+static void\n+output_tagged_type_instantiation (type)\n+     register tree type;\n+{\n+  if (type == 0 || type == error_mark_node)\n+    return;\n+\n+  /* We are going to output a DIE to represent the unqualified version of\n+     of this type (i.e. without any const or volatile qualifiers) so make\n+     sure that we have the main variant (i.e. the unqualified version) of\n+     this type now.  */\n+\n+  assert (type == TYPE_MAIN_VARIANT (type));\n+\n+  assert (TREE_ASM_WRITTEN (type));\n+\n+  switch (TREE_CODE (type))\n+    {\n+      case ERROR_MARK:\n+\tbreak;\n+\n+      case ENUMERAL_TYPE:\n+\toutput_die (output_inlined_enumeration_type_die, type);\n+\tbreak;\n+\n+      case RECORD_TYPE:\n+\toutput_die (output_inlined_structure_type_die, type);\n+\tbreak;\n+\n+      case UNION_TYPE:\n+\toutput_die (output_inlined_union_type_die, type);\n+\tbreak;\n+\n+      default:\n+\tabort ();\t/* Should never happen.  */\n+    }\n+}\n \f\n /* Output a TAG_lexical_block DIE followed by DIEs to represent all of\n    the things which are local to the given block.  */\n@@ -3981,18 +4159,6 @@ output_decl (decl, containing_scope)\n \t{\n \t  register tree arg_decls = DECL_ARGUMENTS (decl);\n \n-\t  /* In the case where the FUNCTION_DECL represents a C++ non-static\n-\t     member function, skip over the first thing on the DECL_ARGUMENTS\n-\t     chain.  It only represents the hidden `this pointer' parameter\n-\t     and the debugger should know implicitly that non-static member\n-\t     functions have such a thing, and should be able to figure out\n-\t     exactly what the type of each `this pointer' is (from the\n-\t     AT_member attribute of the parent TAG_subroutine DIE)  without\n-\t     being explicitly told.  */\n-\n-\t  if (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n-\t    arg_decls = TREE_CHAIN (arg_decls);\n-\n \t  {\n \t    register tree last_arg;\n \n@@ -4115,19 +4281,25 @@ output_decl (decl, containing_scope)\n \tif (outer_scope && TREE_CODE (outer_scope) != ERROR_MARK)\n \t  {\n \t    /* Note that here, `outer_scope' is a pointer to the outermost\n-\t       BLOCK node created to represent the body of a function.\n+\t       BLOCK node created to represent a function.\n \t       This outermost BLOCK actually represents the outermost\n \t       binding contour for the function, i.e. the contour in which\n-\t       the function's formal parameters get declared.  Just within\n-\t       this contour, there will be another (nested) BLOCK which\n-\t       represents the function's outermost block.  We don't want\n-\t       to generate a lexical_block DIE to represent the outermost\n-\t       block of a function body, because that is not really an\n+\t       the function's formal parameters and labels get declared.\n+\n+\t       Curiously, it appears that the front end doesn't actually\n+\t       put the PARM_DECL nodes for the current function onto the\n+\t       BLOCK_VARS list for this outer scope.  (They are strung\n+\t       off of the DECL_ARGUMENTS list for the function instead.)\n+\t       The BLOCK_VARS list for the `outer_scope' does provide us\n+\t       with a list of the LABEL_DECL nodes for the function however,\n+\t       and we output DWARF info for those here.\n+\n+\t       Just within the `outer_scope' there will be another BLOCK\n+\t       node representing the function's outermost pair of curly\n+\t       braces.  We musn't generate a lexical_block DIE for this\n+\t       outermost pair of curly braces because that is not really an\n \t       independent scope according to ANSI C rules.  Rather, it is\n-\t       the same scope in which the parameters were declared and\n-\t       for Dwarf, we do not generate a TAG_lexical_block DIE for\n-\t       that scope.  We must however see to it that the LABEL_DECLs\n-\t       associated with `outer_scope' get DIEs generated for them.  */\n+\t       the same scope in which the parameters were declared.  */\n \n \t    {\n \t      register tree label;\n@@ -4138,6 +4310,11 @@ output_decl (decl, containing_scope)\n \t\toutput_decl (label, outer_scope);\n \t    }\n \n+\t    /* Note here that `BLOCK_SUBBLOCKS (outer_scope)' points to a\n+\t       list of BLOCK nodes which is always only one element long.\n+\t       That one element represents the outermost pair of curley\n+\t       braces for the function body.  */\n+\n \t    output_decls_for_scope (BLOCK_SUBBLOCKS (outer_scope));\n \n \t    /* Finally, force out any pending types which are local to the\n@@ -4168,6 +4345,20 @@ output_decl (decl, containing_scope)\n \t    || ! TYPE_USED_FOR_FUNCTION (TREE_TYPE (decl)))\n           return;\n \n+      /* In the special case of a null-named TYPE_DECL node (representing\n+\t the declaration of some type tag), if the given TYPE_DECL is\n+\t marked as having been instantiated from some other (original)\n+\t TYPE_DECL node (e.g. one which was generated within the original\n+\t definition of an inline function) we have to generate a special\n+\t (abbreviated) TAG_structure_type, TAG_union_type, or\n+\t TAG_enumeration-type DIE here.  */\n+\n+      if (! DECL_NAME (decl) && DECL_ABSTRACT_ORIGIN (decl))\n+\t{\n+\t  output_tagged_type_instantiation (TREE_TYPE (decl));\n+\t  return;\n+\t}\n+\n       output_type (TREE_TYPE (decl), containing_scope);\n \n       /* Note that unlike the gcc front end (which generates a NULL named\n@@ -4215,19 +4406,34 @@ output_decl (decl, containing_scope)\n \t was already generated in the .debug_pubnames section sub-entry\n \t for this data object definition.  */\n \n-      if (TREE_PUBLIC (decl))\n+      if (TREE_PUBLIC (decl) && ! DECL_ABSTRACT (decl))\n \t{\n \t  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n \t  sprintf (label, PUB_DIE_LABEL_FMT, next_pubname_number++);\n \t  ASM_OUTPUT_LABEL (asm_out_file, label);\n \t}\n \n-      /* Now output the DIE to represent the data object itself.  */\n+      /* Now output the DIE to represent the data object itself.  This gets\n+\t complicated because of the possibility that the VAR_DECL really\n+\t represents an inlined instance of a formal parameter for an inline\n+\t function.  */\n \n-      output_die (TREE_PUBLIC (decl) || TREE_EXTERNAL (decl)\n-\t\t   ? output_global_variable_die : output_local_variable_die,\n-\t\t  decl);\n+      {\n+        register void (*func) ();\n+\tregister tree origin = decl_ultimate_origin (decl);\n+\n+\tif (origin != NULL && TREE_CODE (origin) == PARM_DECL)\n+\t  func = output_formal_parameter_die;\n+\telse\n+\t  {\n+\t    if (TREE_PUBLIC (decl) || TREE_EXTERNAL (decl))\n+\t      func = output_global_variable_die;\n+\t    else\n+\t      func = output_local_variable_die;\n+\t  }\n+\toutput_die (func, decl);\n+      }\n       break;\n \n     case FIELD_DECL:\n@@ -4301,7 +4507,9 @@ dwarfout_file_scope_decl (decl, set_finalizing)\n       if (TREE_EXTERNAL (decl) && !TREE_USED (decl))\n \treturn;\n \n-      if (TREE_PUBLIC (decl) && ! TREE_EXTERNAL (decl))\n+      if (TREE_PUBLIC (decl)\n+\t  && ! TREE_EXTERNAL (decl)\n+\t  && ! DECL_ABSTRACT (decl))\n \t{\n \t  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -4336,7 +4544,8 @@ dwarfout_file_scope_decl (decl, set_finalizing)\n \n       if (TREE_PUBLIC (decl)\n \t  && ! TREE_EXTERNAL (decl)\n-\t  && GET_CODE (DECL_RTL (decl)) == MEM)\n+\t  && GET_CODE (DECL_RTL (decl)) == MEM\n+\t  && ! DECL_ABSTRACT (decl))\n \t{\n \t  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n "}]}