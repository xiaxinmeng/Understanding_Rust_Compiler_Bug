{"sha": "5d727a4b20257275df59182b00f3bf240772cd0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ3MjdhNGIyMDI1NzI3NWRmNTkxODJiMDBmM2JmMjQwNzcyY2QwZA==", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@st.com", "date": "2019-09-10T07:47:49Z"}, "committer": {"name": "Christophe Lyon", "email": "clyon@gcc.gnu.org", "date": "2019-09-10T07:47:49Z"}, "message": "[ARM/FDPIC v6 06/24] [ARM] FDPIC: Add support for c++ exceptions\n\nThe main difference with existing support is that function addresses\nare function descriptor addresses instead. This means that all code\ndealing with function pointers now has to cope with function\ndescriptors instead.\n\nFor the same reason, Linux kernel helpers can no longer be called by\ndereferencing their address, so we implement wrappers that directly\ncall the kernel helpers.\n\nWhen restoring a function address, we also have to restore the FDPIC\nregister value (r9).\n\n2019-09-10  Christophe Lyon  <christophe.lyon@st.com>\n\tMicka\u00ebl Gu\u00ean\u00e9 <mickael.guene@st.com>\n\n\tgcc/\n\t* ginclude/unwind-arm-common.h (unwinder_cache): Add reserved5\n\tfield.\n\n\tlibgcc/\n\t* config/arm/linux-atomic.c (__kernel_cmpxchg): Add FDPIC support.\n\t(__kernel_dmb): Likewise.\n\t(__fdpic_cmpxchg): New function.\n\t(__fdpic_dmb): New function.\n\t* config/arm/unwind-arm.h (FDPIC_REGNUM): New define.\n\t(gnu_Unwind_Find_got): New function.\n\t(_Unwind_decode_typeinfo_ptr): Add FDPIC support.\n\t* unwind-arm-common.inc (UCB_PR_GOT): New.\n\t(funcdesc_t): New struct.\n\t(get_eit_entry): Add FDPIC support.\n\t(unwind_phase2): Likewise.\n\t(unwind_phase2_forced): Likewise.\n\t(__gnu_Unwind_RaiseException): Likewise.\n\t(__gnu_Unwind_Resume): Likewise.\n\t(__gnu_Unwind_Backtrace): Likewise.\n\t* unwind-pe.h (read_encoded_value_with_base): Likewise.\n\n\tlibstdc++/\n\t* libsupc++/eh_personality.cc (get_ttype_entry): Add FDPIC\n\tsupport.\n\n\nCo-Authored-By: Micka\u00ebl Gu\u00ean\u00e9 <mickael.guene@st.com>\n\nFrom-SVN: r275568", "tree": {"sha": "5fa39e7a145e9c36ae2c34ec78e3360e97f99b56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fa39e7a145e9c36ae2c34ec78e3360e97f99b56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d727a4b20257275df59182b00f3bf240772cd0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d727a4b20257275df59182b00f3bf240772cd0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d727a4b20257275df59182b00f3bf240772cd0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d727a4b20257275df59182b00f3bf240772cd0d/comments", "author": null, "committer": null, "parents": [{"sha": "11189793b6ef60645d5d1126d0bd9d0dd83e6583", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11189793b6ef60645d5d1126d0bd9d0dd83e6583", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11189793b6ef60645d5d1126d0bd9d0dd83e6583"}], "stats": {"total": 241, "additions": 236, "deletions": 5}, "files": [{"sha": "a212eb3ce52bf1a3d4328890f1d7d06841138c27", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d727a4b20257275df59182b00f3bf240772cd0d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d727a4b20257275df59182b00f3bf240772cd0d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d727a4b20257275df59182b00f3bf240772cd0d", "patch": "@@ -1,3 +1,9 @@\n+2019-09-10  Christophe Lyon  <christophe.lyon@st.com>\n+\tMicka\u00ebl Gu\u00ean\u00e9 <mickael.guene@st.com>\n+\n+\t* ginclude/unwind-arm-common.h (unwinder_cache): Add reserved5\n+\tfield.\n+\n 2019-09-10  Christophe Lyon  <christophe.lyon@st.com>\n \tMicka\u00ebl Gu\u00ean\u00e9 <mickael.guene@st.com>\n "}, {"sha": "d4eb03e7a98acff79ef902ec7c5b0138a093c711", "filename": "gcc/ginclude/unwind-arm-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d727a4b20257275df59182b00f3bf240772cd0d/gcc%2Fginclude%2Funwind-arm-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d727a4b20257275df59182b00f3bf240772cd0d/gcc%2Fginclude%2Funwind-arm-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Funwind-arm-common.h?ref=5d727a4b20257275df59182b00f3bf240772cd0d", "patch": "@@ -91,7 +91,7 @@ extern \"C\" {\n \t  _uw reserved2;  /* Personality routine address */\n \t  _uw reserved3;  /* Saved callsite address */\n \t  _uw reserved4;  /* Forced unwind stop arg */\n-\t  _uw reserved5;\n+\t  _uw reserved5;  /* Personality routine GOT value in FDPIC mode.  */\n \t}\n       unwinder_cache;\n       /* Propagation barrier cache (valid after phase 1): */"}, {"sha": "8f29b5ed6080041269b3ae32f059f1b23720c723", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d727a4b20257275df59182b00f3bf240772cd0d/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d727a4b20257275df59182b00f3bf240772cd0d/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=5d727a4b20257275df59182b00f3bf240772cd0d", "patch": "@@ -1,3 +1,23 @@\n+2019-09-10  Christophe Lyon  <christophe.lyon@st.com>\n+\tMicka\u00ebl Gu\u00ean\u00e9 <mickael.guene@st.com>\n+\n+\t* config/arm/linux-atomic.c (__kernel_cmpxchg): Add FDPIC support.\n+\t(__kernel_dmb): Likewise.\n+\t(__fdpic_cmpxchg): New function.\n+\t(__fdpic_dmb): New function.\n+\t* config/arm/unwind-arm.h (FDPIC_REGNUM): New define.\n+\t(gnu_Unwind_Find_got): New function.\n+\t(_Unwind_decode_typeinfo_ptr): Add FDPIC support.\n+\t* unwind-arm-common.inc (UCB_PR_GOT): New.\n+\t(funcdesc_t): New struct.\n+\t(get_eit_entry): Add FDPIC support.\n+\t(unwind_phase2): Likewise.\n+\t(unwind_phase2_forced): Likewise.\n+\t(__gnu_Unwind_RaiseException): Likewise.\n+\t(__gnu_Unwind_Resume): Likewise.\n+\t(__gnu_Unwind_Backtrace): Likewise.\n+\t* unwind-pe.h (read_encoded_value_with_base): Likewise.\n+\n 2019-09-10  Christophe Lyon  <christophe.lyon@st.com>\n \tMicka\u00ebl Gu\u00ean\u00e9 <mickael.guene@st.com>\n "}, {"sha": "565f829c5c0373c240ce1752d4db4ab2fe008599", "filename": "libgcc/config/arm/linux-atomic.c", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d727a4b20257275df59182b00f3bf240772cd0d/libgcc%2Fconfig%2Farm%2Flinux-atomic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d727a4b20257275df59182b00f3bf240772cd0d/libgcc%2Fconfig%2Farm%2Flinux-atomic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Farm%2Flinux-atomic.c?ref=5d727a4b20257275df59182b00f3bf240772cd0d", "patch": "@@ -25,11 +25,62 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n /* Kernel helper for compare-and-exchange.  */\n typedef int (__kernel_cmpxchg_t) (int oldval, int newval, int *ptr);\n-#define __kernel_cmpxchg (*(__kernel_cmpxchg_t *) 0xffff0fc0)\n+\n+#define STR(X) #X\n+#define XSTR(X) STR(X)\n+\n+#define KERNEL_CMPXCHG 0xffff0fc0\n+\n+#if __FDPIC__\n+/* Non-FDPIC ABIs call __kernel_cmpxchg directly by dereferencing its\n+   address, but under FDPIC we would generate a broken call\n+   sequence. That's why we have to implement __kernel_cmpxchg and\n+   __kernel_dmb here: this way, the FDPIC call sequence works.  */\n+#define __kernel_cmpxchg __fdpic_cmpxchg\n+#else\n+#define __kernel_cmpxchg (*(__kernel_cmpxchg_t *) KERNEL_CMPXCHG)\n+#endif\n \n /* Kernel helper for memory barrier.  */\n typedef void (__kernel_dmb_t) (void);\n-#define __kernel_dmb (*(__kernel_dmb_t *) 0xffff0fa0)\n+\n+#define KERNEL_DMB 0xffff0fa0\n+\n+#if __FDPIC__\n+#define __kernel_dmb __fdpic_dmb\n+#else\n+#define __kernel_dmb (*(__kernel_dmb_t *) KERNEL_DMB)\n+#endif\n+\n+#if __FDPIC__\n+static int __fdpic_cmpxchg (int oldval, int newval, int *ptr)\n+{\n+  int result;\n+\n+  asm volatile (\n+\t\t\"ldr    ip, 1f\\n\\t\"\n+\t\t\"bx     ip\\n\\t\"\n+\t\t\"1:\\n\\t\"\n+\t\t\".word \" XSTR(KERNEL_CMPXCHG) \"\\n\\t\"\n+\t\t: \"=r\" (result)\n+\t\t: \"r\" (oldval) , \"r\" (newval), \"r\" (ptr)\n+\t\t: \"r3\", \"memory\");\n+  /* The result is actually returned by the kernel helper, we need\n+     this to avoid a warning.  */\n+  return result;\n+}\n+\n+static void __fdpic_dmb (void)\n+{\n+  asm volatile (\n+\t\t\"ldr    ip, 1f\\n\\t\"\n+\t\t\"bx     ip\\n\\t\"\n+\t\t\"1:\\n\\t\"\n+\t\t\".word \" XSTR(KERNEL_DMB) \"\\n\\t\"\n+\t\t);\n+}\n+\n+#endif\n \n /* Note: we implement byte, short and int versions of atomic operations using\n    the above kernel helpers; see linux-atomic-64bit.c for \"long long\" (64-bit)"}, {"sha": "2bf320ab85830fe9f74214e89bf1f7331f4697b0", "filename": "libgcc/config/arm/unwind-arm.h", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d727a4b20257275df59182b00f3bf240772cd0d/libgcc%2Fconfig%2Farm%2Funwind-arm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d727a4b20257275df59182b00f3bf240772cd0d/libgcc%2Fconfig%2Farm%2Funwind-arm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Farm%2Funwind-arm.h?ref=5d727a4b20257275df59182b00f3bf240772cd0d", "patch": "@@ -33,9 +33,33 @@\n /* Use IP as a scratch register within the personality routine.  */\n #define UNWIND_POINTER_REG 12\n \n+#define FDPIC_REGNUM 9\n+\n+#define STR(x) #x\n+#define XSTR(x) STR(x)\n+\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n+_Unwind_Ptr __attribute__((weak)) __gnu_Unwind_Find_got (_Unwind_Ptr);\n+\n+static inline _Unwind_Ptr gnu_Unwind_Find_got (_Unwind_Ptr ptr)\n+{\n+    _Unwind_Ptr res;\n+\n+    if (__gnu_Unwind_Find_got)\n+\tres =  __gnu_Unwind_Find_got (ptr);\n+    else\n+      {\n+\tasm volatile (\"mov %[result], r\" XSTR(FDPIC_REGNUM)\n+\t\t      : [result]\"=r\" (res)\n+\t\t      :\n+\t\t      :);\n+      }\n+\n+    return res;\n+}\n+\n   /* Decode an R_ARM_TARGET2 relocation.  */\n   static inline _Unwind_Word\n   _Unwind_decode_typeinfo_ptr (_Unwind_Word base __attribute__ ((unused)),\n@@ -48,7 +72,12 @@ extern \"C\" {\n       if (!tmp)\n \treturn 0;\n \n-#if (defined(linux) && !defined(__uClinux__)) || defined(__NetBSD__) \\\n+#if __FDPIC__\n+      /* For FDPIC, we store the offset of the GOT entry.  */\n+      /* So, first get GOT from dynamic linker and then use indirect access.  */\n+      tmp += gnu_Unwind_Find_got (ptr);\n+      tmp = *(_Unwind_Word *) tmp;\n+#elif (defined(linux) && !defined(__uClinux__)) || defined(__NetBSD__) \\\n     || defined(__FreeBSD__) || defined(__fuchsia__)\n       /* Pc-relative indirect.  */\n #define _GLIBCXX_OVERRIDE_TTYPE_ENCODING (DW_EH_PE_pcrel | DW_EH_PE_indirect)"}, {"sha": "0bacc11ef1a75ad6d0ba35cb296527c648c38b17", "filename": "libgcc/unwind-arm-common.inc", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d727a4b20257275df59182b00f3bf240772cd0d/libgcc%2Funwind-arm-common.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d727a4b20257275df59182b00f3bf240772cd0d/libgcc%2Funwind-arm-common.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Funwind-arm-common.inc?ref=5d727a4b20257275df59182b00f3bf240772cd0d", "patch": "@@ -62,6 +62,7 @@ __gnu_Unwind_Find_exidx (_Unwind_Ptr, int *);\n #define UCB_PR_ADDR(ucbp) ((ucbp)->unwinder_cache.reserved2)\n #define UCB_SAVED_CALLSITE_ADDR(ucbp) ((ucbp)->unwinder_cache.reserved3)\n #define UCB_FORCED_STOP_ARG(ucbp) ((ucbp)->unwinder_cache.reserved4)\n+#define UCB_PR_GOT(ucbp) ((ucbp)->unwinder_cache.reserved5)\n \n /* Unwind descriptors.  */\n \n@@ -85,6 +86,16 @@ typedef struct __EIT_entry\n   _uw content;\n } __EIT_entry;\n \n+#ifdef __FDPIC__\n+\n+/* Only used in FDPIC case.  */\n+struct funcdesc_t\n+{\n+  unsigned int ptr;\n+  unsigned int got;\n+};\n+#endif\n+\n /* Assembly helper functions.  */\n \n /* Restore core register state.  Never returns.  */\n@@ -259,7 +270,21 @@ get_eit_entry (_Unwind_Control_Block *ucbp, _uw return_address)\n     {\n       /* One of the predefined standard routines.  */\n       _uw idx = (*(_uw *) ucbp->pr_cache.ehtp >> 24) & 0xf;\n+#if __FDPIC__\n+      {\n+\tstruct funcdesc_t *funcdesc\n+\t  = (struct funcdesc_t *) __gnu_unwind_get_pr_addr (idx);\n+\tif (funcdesc)\n+\t  {\n+\t    UCB_PR_ADDR (ucbp) = funcdesc->ptr;\n+\t    UCB_PR_GOT (ucbp) = funcdesc->got;\n+\t  }\n+\telse\n+\t  UCB_PR_ADDR (ucbp) = 0;\n+      }\n+#else\n       UCB_PR_ADDR (ucbp) = __gnu_unwind_get_pr_addr (idx);\n+#endif\n       if (UCB_PR_ADDR (ucbp) == 0)\n \t{\n \t  /* Failed */\n@@ -270,6 +295,10 @@ get_eit_entry (_Unwind_Control_Block *ucbp, _uw return_address)\n     {\n       /* Execute region offset to PR */\n       UCB_PR_ADDR (ucbp) = selfrel_offset31 (ucbp->pr_cache.ehtp);\n+#if __FDPIC__\n+      UCB_PR_GOT (ucbp)\n+\t= (unsigned int) gnu_Unwind_Find_got ((_Unwind_Ptr) UCB_PR_ADDR (ucbp));\n+#endif\n     }\n   return _URC_OK;\n }\n@@ -291,14 +320,29 @@ unwind_phase2 (_Unwind_Control_Block * ucbp, phase2_vrs * vrs)\n       UCB_SAVED_CALLSITE_ADDR (ucbp) = VRS_PC(vrs);\n \n       /* Call the pr to decide what to do.  */\n+#if __FDPIC__\n+      {\n+\tvolatile struct funcdesc_t funcdesc;\n+\tfuncdesc.ptr = UCB_PR_ADDR (ucbp);\n+\tfuncdesc.got = UCB_PR_GOT (ucbp);\n+\tpr_result = ((personality_routine) &funcdesc)\n+\t  (_US_UNWIND_FRAME_STARTING, ucbp, (_Unwind_Context *) vrs);\n+      }\n+#else\n       pr_result = ((personality_routine) UCB_PR_ADDR (ucbp))\n \t(_US_UNWIND_FRAME_STARTING, ucbp, (_Unwind_Context *) vrs);\n+#endif\n     }\n   while (pr_result == _URC_CONTINUE_UNWIND);\n   \n   if (pr_result != _URC_INSTALL_CONTEXT)\n     abort();\n \n+#if __FDPIC__\n+  /* r9 could have been lost due to PLT jump.  Restore correct value.  */\n+  vrs->core.r[FDPIC_REGNUM] = gnu_Unwind_Find_got (VRS_PC (vrs));\n+#endif\n+\n   uw_restore_core_regs (vrs, &vrs->core);\n }\n \n@@ -346,8 +390,18 @@ unwind_phase2_forced (_Unwind_Control_Block *ucbp, phase2_vrs *entry_vrs,\n \t  next_vrs = saved_vrs;\n \n \t  /* Call the pr to decide what to do.  */\n+#if __FDPIC__\n+\t  {\n+\t    volatile struct funcdesc_t funcdesc;\n+\t    funcdesc.ptr = UCB_PR_ADDR (ucbp);\n+\t    funcdesc.got = UCB_PR_GOT (ucbp);\n+\t    pr_result = ((personality_routine) &funcdesc)\n+\t      (action, ucbp, (void *) &next_vrs);\n+\t  }\n+#else\n \t  pr_result = ((personality_routine) UCB_PR_ADDR (ucbp))\n \t    (action, ucbp, (void *) &next_vrs);\n+#endif\n \n \t  saved_vrs.prev_sp = VRS_SP (&next_vrs);\n \t}\n@@ -384,6 +438,11 @@ unwind_phase2_forced (_Unwind_Control_Block *ucbp, phase2_vrs *entry_vrs,\n       return _URC_FAILURE;\n     }\n \n+#if __FDPIC__\n+  /* r9 could have been lost due to PLT jump.  Restore correct value.  */\n+  saved_vrs.core.r[FDPIC_REGNUM] = gnu_Unwind_Find_got (VRS_PC (&saved_vrs));\n+#endif\n+\n   uw_restore_core_regs (&saved_vrs, &saved_vrs.core);\n }\n \n@@ -429,8 +488,18 @@ __gnu_Unwind_RaiseException (_Unwind_Control_Block * ucbp,\n \treturn _URC_FAILURE;\n \n       /* Call the pr to decide what to do.  */\n+#if __FDPIC__\n+      {\n+\tvolatile struct funcdesc_t funcdesc;\n+\tfuncdesc.ptr = UCB_PR_ADDR (ucbp);\n+\tfuncdesc.got = UCB_PR_GOT (ucbp);\n+\tpr_result = ((personality_routine) &funcdesc)\n+\t  (_US_VIRTUAL_UNWIND_FRAME, ucbp, (void *) &saved_vrs);\n+      }\n+#else\n       pr_result = ((personality_routine) UCB_PR_ADDR (ucbp))\n \t(_US_VIRTUAL_UNWIND_FRAME, ucbp, (void *) &saved_vrs);\n+#endif\n     }\n   while (pr_result == _URC_CONTINUE_UNWIND);\n \n@@ -488,13 +557,27 @@ __gnu_Unwind_Resume (_Unwind_Control_Block * ucbp, phase2_vrs * entry_vrs)\n     }\n \n   /* Call the cached PR.  */\n+#if __FDPIC__\n+  {\n+    volatile struct funcdesc_t funcdesc;\n+    funcdesc.ptr = UCB_PR_ADDR (ucbp);\n+    funcdesc.got = UCB_PR_GOT (ucbp);\n+    pr_result = ((personality_routine) &funcdesc)\n+      (_US_UNWIND_FRAME_RESUME, ucbp, (_Unwind_Context *) entry_vrs);\n+  }\n+#else\n   pr_result = ((personality_routine) UCB_PR_ADDR (ucbp))\n \t(_US_UNWIND_FRAME_RESUME, ucbp, (_Unwind_Context *) entry_vrs);\n+#endif\n \n   switch (pr_result)\n     {\n     case _URC_INSTALL_CONTEXT:\n       /* Upload the registers to enter the landing pad.  */\n+#if __FDPIC__\n+      /* r9 could have been lost due to PLT jump.  Restore correct value.  */\n+      entry_vrs->core.r[FDPIC_REGNUM] = gnu_Unwind_Find_got (VRS_PC (entry_vrs));\n+#endif\n       uw_restore_core_regs (entry_vrs, &entry_vrs->core);\n \n     case _URC_CONTINUE_UNWIND:\n@@ -586,9 +669,20 @@ __gnu_Unwind_Backtrace(_Unwind_Trace_Fn trace, void * trace_argument,\n \t}\n \n       /* Call the pr to decide what to do.  */\n+#if __FDPIC__\n+      {\n+\tvolatile struct funcdesc_t funcdesc;\n+\tfuncdesc.ptr = UCB_PR_ADDR (ucbp);\n+\tfuncdesc.got = UCB_PR_GOT (ucbp);\n+\tcode = ((personality_routine) &funcdesc)\n+\t  (_US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND,\n+\t   ucbp, (void *) &saved_vrs);\n+      }\n+#else\n       code = ((personality_routine) UCB_PR_ADDR (ucbp))\n \t(_US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND, \n \t ucbp, (void *) &saved_vrs);\n+#endif\n     }\n   while (code != _URC_END_OF_STACK\n \t && code != _URC_FAILURE);"}, {"sha": "1c9dae54de6a243b7790b667a6cdda5bc78de183", "filename": "libgcc/unwind-pe.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d727a4b20257275df59182b00f3bf240772cd0d/libgcc%2Funwind-pe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d727a4b20257275df59182b00f3bf240772cd0d/libgcc%2Funwind-pe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Funwind-pe.h?ref=5d727a4b20257275df59182b00f3bf240772cd0d", "patch": "@@ -262,10 +262,27 @@ read_encoded_value_with_base (unsigned char encoding, _Unwind_Ptr base,\n \n       if (result != 0)\n \t{\n+#if __FDPIC__\n+\t  /* FDPIC relative addresses imply taking the GOT address\n+\t     into account.  */\n+\t  if ((encoding & DW_EH_PE_pcrel) && (encoding & DW_EH_PE_indirect))\n+\t    {\n+\t      result += gnu_Unwind_Find_got ((_Unwind_Ptr) u);\n+\t      result = *(_Unwind_Internal_Ptr *) result;\n+\t    }\n+\t  else\n+\t    {\n+\t      result += ((encoding & 0x70) == DW_EH_PE_pcrel\n+\t\t\t ? (_Unwind_Internal_Ptr) u : base);\n+\t      if (encoding & DW_EH_PE_indirect)\n+\t\tresult = *(_Unwind_Internal_Ptr *) result;\n+\t    }\n+#else\n \t  result += ((encoding & 0x70) == DW_EH_PE_pcrel\n \t\t     ? (_Unwind_Internal_Ptr) u : base);\n \t  if (encoding & DW_EH_PE_indirect)\n \t    result = *(_Unwind_Internal_Ptr *) result;\n+#endif\n \t}\n     }\n "}, {"sha": "1c115a74cb5df531b6baa8fce6886f1bf2418969", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d727a4b20257275df59182b00f3bf240772cd0d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d727a4b20257275df59182b00f3bf240772cd0d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5d727a4b20257275df59182b00f3bf240772cd0d", "patch": "@@ -1,3 +1,9 @@\n+2019-09-10  Christophe Lyon  <christophe.lyon@st.com>\n+\tMicka\u00ebl Gu\u00ean\u00e9 <mickael.guene@st.com>\n+\n+\t* libsupc++/eh_personality.cc (get_ttype_entry): Add FDPIC\n+\tsupport.\n+\n 2019-09-10  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/91711"}, {"sha": "1528ab9b5debba8ade79be10b508b942f4e17e0d", "filename": "libstdc++-v3/libsupc++/eh_personality.cc", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d727a4b20257275df59182b00f3bf240772cd0d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d727a4b20257275df59182b00f3bf240772cd0d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc?ref=5d727a4b20257275df59182b00f3bf240772cd0d", "patch": "@@ -93,7 +93,15 @@ get_ttype_entry (lsda_header_info *info, _uleb128_t i)\n   _Unwind_Ptr ptr;\n \n   i *= size_of_encoded_value (info->ttype_encoding);\n-  read_encoded_value_with_base (info->ttype_encoding, info->ttype_base,\n+  read_encoded_value_with_base (\n+#if __FDPIC__\n+\t\t\t\t/* Force these flags to nake sure to\n+\t\t\t\t   take the GOT into account.  */\n+\t\t\t\t(DW_EH_PE_pcrel | DW_EH_PE_indirect),\n+#else\n+\t\t\t\tinfo->ttype_encoding,\n+#endif\n+\t\t\t\tinfo->ttype_base,\n \t\t\t\tinfo->TType - i, &ptr);\n \n   return reinterpret_cast<const std::type_info *>(ptr);"}]}