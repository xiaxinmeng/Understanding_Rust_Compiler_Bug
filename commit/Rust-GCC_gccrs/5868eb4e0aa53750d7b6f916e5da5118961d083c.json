{"sha": "5868eb4e0aa53750d7b6f916e5da5118961d083c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg2OGViNGUwYWE1Mzc1MGQ3YjZmOTE2ZTVkYTUxMTg5NjFkMDgzYw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-12T02:45:30Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-12T02:45:30Z"}, "message": "decl.c (add_decl_to_level): Remove TREE_PERMANENT assertion.\n\n\t* decl.c (add_decl_to_level): Remove TREE_PERMANENT assertion.\n\t(init_decl_processing): Don't set TREE_PERMANENT for the\n\terror_mark_node.\n\t(start_decl): Don't rebuild non-permanent ARRAY_TYPEs.\n\t(grokdeclarator): Likewise.\n\t(grokparms): Don't check TREE_PERMANENT when building up lists.\n\t* decl2.c (grokfield): Don't assert TREE_PERMANENT.\n\t(mark_inline_for_output): Likewise.\n\t* expr.c (cplus_expand_expr): Don't check TREE_PERMANENT.\n\t* init.c (build_offset_ref): Don't check TREE_PERMANENT.\n\t* lex.c (check_newline): Don't check ggc_p; it is always one.\n\t* pt.c (process_template_parm): Don't check TREE_PERMANENT.\n\t* spew.c (yylex): Don't copy_node or probe_obstacks for\n\tnon-permanent CONSTANTs and STRINGs.\n\t* tree.c (build_cplus_array_type_1): Don't fuss with\n\tTREE_PERMANENT on ARRAY_TYPEs.\n\nFrom-SVN: r29350", "tree": {"sha": "28184da20863a95f115b04d3f240978e07f36f9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28184da20863a95f115b04d3f240978e07f36f9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5868eb4e0aa53750d7b6f916e5da5118961d083c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5868eb4e0aa53750d7b6f916e5da5118961d083c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5868eb4e0aa53750d7b6f916e5da5118961d083c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5868eb4e0aa53750d7b6f916e5da5118961d083c/comments", "author": null, "committer": null, "parents": [{"sha": "1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd"}], "stats": {"total": 110, "additions": 7, "deletions": 103}, "files": [{"sha": "22e61f0766bc45c65f4b0b0963e633367c3611e7", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 48, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5868eb4e0aa53750d7b6f916e5da5118961d083c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5868eb4e0aa53750d7b6f916e5da5118961d083c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5868eb4e0aa53750d7b6f916e5da5118961d083c", "patch": "@@ -969,12 +969,6 @@ add_decl_to_level (decl, b)\n      tree decl;\n      struct binding_level *b;\n {\n-  /* Only things that will live forever should go in the global\n-     binding level.  */\n-  my_friendly_assert (!(b == global_binding_level \n-\t\t\t&& !TREE_PERMANENT (decl)),\n-\t\t      19990817);\n-\n   /* We build up the list in reverse order, and reverse it later if\n      necessary.  */\n   TREE_CHAIN (decl) = b->names;\n@@ -6039,7 +6033,6 @@ init_decl_processing ()\n \n   build_common_tree_nodes (flag_signed_char);\n \n-  TREE_PERMANENT (error_mark_node) = 1;\n   error_mark_list = build_tree_list (error_mark_node, error_mark_node);\n   TREE_TYPE (error_mark_list) = error_mark_node;\n \n@@ -6694,26 +6687,6 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n   if (type == error_mark_node)\n     return NULL_TREE;\n \n-  /* Don't lose if destructors must be executed at file-level.  */\n-  if (! processing_template_decl && TREE_STATIC (decl)\n-      && TYPE_NEEDS_DESTRUCTOR (complete_type (type))\n-      && !TREE_PERMANENT (decl))\n-    {\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n-      decl = copy_node (decl);\n-      if (TREE_CODE (type) == ARRAY_TYPE)\n-\t{\n-\t  tree itype = TYPE_DOMAIN (type);\n-\t  if (itype && ! TREE_PERMANENT (itype))\n-\t    {\n-\t      itype = build_index_type (TYPE_MAX_VALUE (itype));\n-\t      type = build_cplus_array_type (TREE_TYPE (type), itype);\n-\t      TREE_TYPE (decl) = type;\n-\t    }\n-\t}\n-      pop_obstacks ();\n-    }\n-\n   context\n     = (TREE_CODE (decl) == FUNCTION_DECL && DECL_VIRTUAL_P (decl))\n       ? DECL_CLASS_CONTEXT (decl)\n@@ -9959,19 +9932,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t    TREE_OVERFLOW (itype) = 0;\n \t\t  }\n \n-\t\t/* If we're a parm, we need to have a permanent type so\n-                   mangling checks for re-use will work right.  If both the\n-                   element and index types are permanent, the array type\n-                   will be, too.  */\n-\t\tif (decl_context == PARM\n-\t\t    && allocation_temporary_p () && TREE_PERMANENT (type))\n-\t\t  {\n-\t\t    push_obstacks (&permanent_obstack, &permanent_obstack);\n-\t\t    itype = build_index_type (itype);\n-\t\t    pop_obstacks ();\n-\t\t  }\n-\t\telse\n-\t\t  itype = build_index_type (itype);\n+\t\titype = build_index_type (itype);\n \n \t      dont_grok_size:\n \t\tresume_momentary (yes);\n@@ -11486,14 +11447,7 @@ grokparms (first_parm, funcdef_flag)\n \t\t  TREE_CHAIN (last_decl) = decl;\n \t\t  last_decl = decl;\n \t\t}\n-\t      if (! current_function_decl && TREE_PERMANENT (list_node))\n-\t\t{\n-\t\t  TREE_PURPOSE (list_node) = init;\n-\t\t  TREE_VALUE (list_node) = type;\n-\t\t  TREE_CHAIN (list_node) = NULL_TREE;\n-\t\t}\n-\t      else\n-\t\tlist_node = tree_cons (init, type, NULL_TREE);\n+\t      list_node = tree_cons (init, type, NULL_TREE);\n \t      if (result == NULL_TREE)\n \t\t{\n \t\t  result = list_node;"}, {"sha": "14dc7411137b9c01177c684f1e0d75eb24aff5f6", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5868eb4e0aa53750d7b6f916e5da5118961d083c/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5868eb4e0aa53750d7b6f916e5da5118961d083c/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=5868eb4e0aa53750d7b6f916e5da5118961d083c", "patch": "@@ -1685,7 +1685,6 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \t    init = decl_constant_value (init);\n \t  else if (TREE_CODE (init) == CONSTRUCTOR)\n \t    init = digest_init (TREE_TYPE (value), init, (tree *)0);\n-\t  my_friendly_assert (TREE_PERMANENT (init), 192);\n \t  if (init == error_mark_node)\n \t    /* We must make this look different than `error_mark_node'\n \t       because `decl_const_value' would mis-interpret it\n@@ -2006,7 +2005,6 @@ mark_inline_for_output (decl)\n   decl = DECL_MAIN_VARIANT (decl);\n   if (DECL_SAVED_INLINE (decl))\n     return;\n-  my_friendly_assert (TREE_PERMANENT (decl), 363);\n   DECL_SAVED_INLINE (decl) = 1;\n   if (!saved_inlines)\n     VARRAY_TREE_INIT (saved_inlines, 32, \"saved_inlines\");"}, {"sha": "a7b823fa347ba4b28bcdc3a5c9cc53fef179de93", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5868eb4e0aa53750d7b6f916e5da5118961d083c/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5868eb4e0aa53750d7b6f916e5da5118961d083c/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=5868eb4e0aa53750d7b6f916e5da5118961d083c", "patch": "@@ -157,14 +157,10 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \tif (AGGR_INIT_VIA_CTOR_P (exp))\n \t  {\n \t    type = build_pointer_type (type);\n-\t    /* Don't clobber a value that might be part of a default\n-\t       parameter value.  */\n \t    mark_addressable (slot);\n-\t    if (TREE_PERMANENT (args))\n-\t      args = tree_cons (0, build1 (ADDR_EXPR, type, slot),\n-\t\t\t\tTREE_CHAIN (args));\n-\t    else\n-\t      TREE_VALUE (args) = build1 (ADDR_EXPR, type, slot);\n+\t    args = tree_cons (NULL_TREE, \n+\t\t\t      build1 (ADDR_EXPR, type, slot),\n+\t\t\t      TREE_CHAIN (args));\n \t    call_target = 0;\n \t  }\n \telse"}, {"sha": "764bb131d2cbe9a6d8eef5d47bd1314d3cd6cc39", "filename": "gcc/cp/init.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5868eb4e0aa53750d7b6f916e5da5118961d083c/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5868eb4e0aa53750d7b6f916e5da5118961d083c/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=5868eb4e0aa53750d7b6f916e5da5118961d083c", "patch": "@@ -1652,17 +1652,6 @@ build_offset_ref (type, name)\n \t  return build (OFFSET_REF, TREE_TYPE (t), decl, t);\n \t}\n \n-      /* FNFIELDS is most likely allocated on the search_obstack,\n-\t which will go away after this class scope.  If we need\n-\t to save this value for later (i.e. for use as an initializer\n-\t for a static variable), then do so here.\n-\n-\t ??? The smart thing to do for the case of saving initializers\n-\t is to resolve them before we're done with this scope.  */\n-      if (!TREE_PERMANENT (fnfields)\n-\t  && ! allocation_temporary_p ())\n-\tfnfields = copy_list (fnfields);\n-\n       TREE_TYPE (fnfields) = unknown_type_node;\n       return build (OFFSET_REF, unknown_type_node, decl, fnfields);\n     }"}, {"sha": "49dd728ba5ca264a9a94fac043335eb195e0ffa2", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5868eb4e0aa53750d7b6f916e5da5118961d083c/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5868eb4e0aa53750d7b6f916e5da5118961d083c/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=5868eb4e0aa53750d7b6f916e5da5118961d083c", "patch": "@@ -2552,14 +2552,7 @@ check_newline ()\n       body_time = this_time;\n     }\n \n-  if (! ggc_p && !TREE_PERMANENT (yylval.ttype))\n-    {\n-      input_filename\n-\t= (char *) permalloc (TREE_STRING_LENGTH (yylval.ttype) + 1);\n-      strcpy (input_filename, TREE_STRING_POINTER (yylval.ttype));\n-    }\n-  else\n-    input_filename = TREE_STRING_POINTER (yylval.ttype);\n+  input_filename = TREE_STRING_POINTER (yylval.ttype);\n \n   GNU_xref_file (input_filename);\n       "}, {"sha": "704ac44ae4e5b0d8417e57968c06770eb58f8a44", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5868eb4e0aa53750d7b6f916e5da5118961d083c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5868eb4e0aa53750d7b6f916e5da5118961d083c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5868eb4e0aa53750d7b6f916e5da5118961d083c", "patch": "@@ -1840,11 +1840,6 @@ process_template_parm (list, next)\n \t\t   || TREE_CODE (TREE_TYPE (parm)) == COMPLEX_TYPE))\n \tcp_pedwarn (\"`%T' is not a valid type for a template constant parameter\",\n \t\t    TREE_TYPE (parm));\n-      if (TREE_PERMANENT (parm) == 0)\n-        {\n-\t  parm = copy_node (parm);\n-\t  TREE_PERMANENT (parm) = 1;\n-        }\n       decl = build_decl (CONST_DECL, DECL_NAME (parm), TREE_TYPE (parm));\n       DECL_INITIAL (parm) = DECL_INITIAL (decl) \n \t= build_template_parm_index (idx, processing_template_decl,"}, {"sha": "8f853a89435d8a906c4616684c281f992172fa6f", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5868eb4e0aa53750d7b6f916e5da5118961d083c/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5868eb4e0aa53750d7b6f916e5da5118961d083c/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=5868eb4e0aa53750d7b6f916e5da5118961d083c", "patch": "@@ -269,19 +269,7 @@ yylex ()\n \n   /* if we've got tokens, send them */\n   else if (num_tokens ())\n-    {\n-      tmp_token= *nth_token (0);\n-\n-      /* TMP_TOKEN.YYLVAL.TTYPE may have been allocated on the wrong obstack.\n-\t If we don't find it in CURRENT_OBSTACK's current or immediately\n-\t previous chunk, assume it was and copy it to the current obstack.  */\n-      if ((tmp_token.yychar == CONSTANT\n-\t   || tmp_token.yychar == STRING)\n-\t  && ! TREE_PERMANENT (tmp_token.yylval.ttype)\n-\t  && ! probe_obstack (current_obstack, tmp_token.yylval.ttype, 2)\n-\t  && ! probe_obstack (saveable_obstack, tmp_token.yylval.ttype, 2))\n-\ttmp_token.yylval.ttype = copy_node (tmp_token.yylval.ttype);\n-    }\n+    tmp_token= *nth_token (0);\n   else\n     {\n       /* if not, grab the next one and think about it */"}, {"sha": "d9db3b0fd97ef75bcb6aafec180ad6cec0f352ff", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5868eb4e0aa53750d7b6f916e5da5118961d083c/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5868eb4e0aa53750d7b6f916e5da5118961d083c/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=5868eb4e0aa53750d7b6f916e5da5118961d083c", "patch": "@@ -459,14 +459,6 @@ build_cplus_array_type_1 (elt_type, index_type)\n   if (elt_type == error_mark_node || index_type == error_mark_node)\n     return error_mark_node;\n \n-  push_obstacks_nochange ();\n-\n-  /* If both ELT_TYPE and INDEX_TYPE are permanent,\n-     make this permanent too.  */\n-  if (TREE_PERMANENT (elt_type)\n-      && (index_type == 0 || TREE_PERMANENT (index_type)))\n-    end_temporary_allocation ();\n-\n   if (processing_template_decl \n       || uses_template_parms (elt_type) \n       || uses_template_parms (index_type))\n@@ -484,7 +476,6 @@ build_cplus_array_type_1 (elt_type, index_type)\n     = TYPE_NEEDS_CONSTRUCTING (TYPE_MAIN_VARIANT (elt_type));\n   TYPE_NEEDS_DESTRUCTOR (t) \n     = TYPE_NEEDS_DESTRUCTOR (TYPE_MAIN_VARIANT (elt_type));\n-  pop_obstacks ();\n   return t;\n }\n "}]}