{"sha": "2da8c1adcf5cefd0274f26077fadbfaeb0216344", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRhOGMxYWRjZjVjZWZkMDI3NGYyNjA3N2ZhZGJmYWViMDIxNjM0NA==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2012-02-15T13:15:56Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2012-02-15T13:15:56Z"}, "message": "re PR target/52261 ([avr] Add support for AVR Xmega cores)\n\nlibgcc/\n\tPR target/52261\n\t* config/avr/lib1funcs.S (__prologue_saves__): Handle AVR_XMEGA\n\t(__epilogue_restores__): Ditto.\n\ngcc/\n\tPR target/52261\n\t* config/avr/avr-devices.c (avr_arch_types): Add avrxmega2,\n\tavrxmega4, avrxmega5, avrxmega6, avrxmega7.\n\tRewrite initializers for .macro.\n\t* config/avr/avr-mcus.def (AVR_MCU): Add known MCUs:\n\tavrxmega2: atxmega16a4, atxmega16d4, atxmega16x1, atxmega32a4\n\tatxmega32d4, atxmega32x1.\n\tavrxmega4: atxmega64a3, atxmega64d3.\n\tavrxmega5: atxmega64a1, atxmega64a1u.\n\tavrxmega6: atxmega128a3, atxmega128d3, atxmega192a3, atxmega192d3,\n\tatxmega256a3, atxmega256a3b, atxmega256a3bu, atxmega256d3.\n\tavrxmega7: atxmega128a1, atxmega128a1u.\n\n\t* config/avr/multilib.h: Regenerate.\n\t* config/avr/t-multilib: Regenerate.\n\t* config/avr/avr-tables.opt: Regenerate.\n\n\t* config/avr/avr.h (enum avr_arch): Add: ARCH_AVRXMEGA2,\n\tARCH_AVRXMEGA4,\tARCH_AVRXMEGA5, ARCH_AVRXMEGA6, ARCH_AVRXMEGA7.\n\t(struct base_arch_s): Rename reserved to xmega_p.\n\tRename reserved2 to have_rampd.\n\t(AVR_XMEGA): New define.\n\t(AVR_HAVE_RAMPD, AVR_HAVE_RAMPX, AVR_HAVE_RAMPY): New defines.\n\t(AVR_HAVE_RAMPZ): Change definition to fit xmega.\n\n\t* config/avr/predicates.md (io_address_operand): Take into\n\taccount SFR offset.\n\t(low_io_address_operand): Ditto.\n\t(high_io_address_operand): Ditto.\n\t\n\t* config/avr/avr.md (isa): Add alternatives no_xmega, xmega.\n\t(enabled, movhi_sp_r): Use them.\n\n\t* config/avr/avr-c.c (avr_cpu_cpp_builtins): Use\n\tcpp_define_formatted to built-in define __AVR_ARCH__.\n\t(__AVR_XMEGA__): New built-in define.\n\t(__AVR_HAVE_RAMPD__): New built-in define.\n\t(__AVR_HAVE_RAMPX__): New built-in define.\n\t(__AVR_HAVE_RAMPY__): New built-in define.\n\t(__AVR_HAVE_RAMPZ__): Change condition when to built-in define it.\n\n\t* config/avr/avr.c (avr_addr_t): Add ccp, rampd, rampx, rampy.\n\t(avr_option_override): Initialize them.\n\t(sreg_rtx, rampd_rtx, rampx_rtx, rampy_rtx): New GTY rtx.\n\t(avr_init_expanders): Initialize them. No more block several calls.\n\t(emit_push_sfr): New static function.\n\t(avr_prologue_setup_frame): Use it to push SREG, RAMPD/X/Y/Z as needed.\n\tHandle AVR_XMEGA.\n\t(expand_epilogue): Handle AVR_XMEGA. Pop RAMPD/X/Y/Z as needed.\n\t(avr_print_operand): Print addreeses as symbols for\n\tRAMPX, RAMPY, RAMPD, CCP.\n\t(output_movhi): Handle AVR_XMEGA when writing to SP.\n\t(avr_out_movhi_mr_r_xmega): New static function.\n\t(out_movhi_mr_r): Forward to avr_out_movhi_mr_r_xmega for AVR_XMEGA.\n\t(avr_file_start): Print symbol defines for __RAMPX__,  __RAMPY__,\n\t__RAMPD__,  __CCP__ as needed.\n\n\nCo-Authored-By: Anatoly Sokolov <aesok@post.ru>\nCo-Authored-By: Eric Weddington <eric.weddington@atmel.com>\n\nFrom-SVN: r184269", "tree": {"sha": "a4151173e9e16b606e0e6fa3862aa8300e82d656", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4151173e9e16b606e0e6fa3862aa8300e82d656"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2da8c1adcf5cefd0274f26077fadbfaeb0216344", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2da8c1adcf5cefd0274f26077fadbfaeb0216344", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2da8c1adcf5cefd0274f26077fadbfaeb0216344", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2da8c1adcf5cefd0274f26077fadbfaeb0216344/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28db21ee45c94316cb9e7b2b4e0f908053fc98ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28db21ee45c94316cb9e7b2b4e0f908053fc98ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28db21ee45c94316cb9e7b2b4e0f908053fc98ce"}], "stats": {"total": 675, "additions": 575, "deletions": 100}, "files": [{"sha": "3cbbf18ecb997e912e355a652f84c249ff10d15d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da8c1adcf5cefd0274f26077fadbfaeb0216344/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da8c1adcf5cefd0274f26077fadbfaeb0216344/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2da8c1adcf5cefd0274f26077fadbfaeb0216344", "patch": "@@ -1,3 +1,60 @@\n+2012-01-15  Georg-Johann Lay  <avr@gjlay.de>\n+\t    Anatoly Sokolov <aesok@post.ru>\n+\t    Eric Weddington <eric.weddington@atmel.com>\n+\n+\tPR target/52261\n+\t* config/avr/avr-devices.c (avr_arch_types): Add avrxmega2,\n+\tavrxmega4, avrxmega5, avrxmega6, avrxmega7.\n+\tRewrite initializers for .macro.\n+\t* config/avr/avr-mcus.def (AVR_MCU): Add known MCUs:\n+\tavrxmega2: atxmega16a4, atxmega16d4, atxmega16x1, atxmega32a4\n+\tatxmega32d4, atxmega32x1.\n+\tavrxmega4: atxmega64a3, atxmega64d3.\n+\tavrxmega5: atxmega64a1, atxmega64a1u.\n+\tavrxmega6: atxmega128a3, atxmega128d3, atxmega192a3, atxmega192d3,\n+\tatxmega256a3, atxmega256a3b, atxmega256a3bu, atxmega256d3.\n+\tavrxmega7: atxmega128a1, atxmega128a1u.\n+\t* config/avr/avr.h (enum avr_arch): Add: ARCH_AVRXMEGA2,\n+\tARCH_AVRXMEGA4,\tARCH_AVRXMEGA5, ARCH_AVRXMEGA6, ARCH_AVRXMEGA7.\n+\t(struct base_arch_s): Rename reserved to xmega_p.\n+\tRename reserved2 to have_rampd.\n+\t(AVR_XMEGA): New define.\n+\t(AVR_HAVE_RAMPD, AVR_HAVE_RAMPX, AVR_HAVE_RAMPY): New defines.\n+\t(AVR_HAVE_RAMPZ): Change definition to fit xmega.\n+\t* config/avr/predicates.md (io_address_operand): Take into\n+\taccount SFR offset.\n+\t(low_io_address_operand): Ditto.\n+\t(high_io_address_operand): Ditto.\n+\t* config/avr/avr.md (isa): Add alternatives no_xmega, xmega.\n+\t(enabled, movhi_sp_r): Use them.\n+\t* config/avr/avr-c.c (avr_cpu_cpp_builtins): Use\n+\tcpp_define_formatted to built-in define __AVR_ARCH__.\n+\t(__AVR_XMEGA__): New built-in define.\n+\t(__AVR_HAVE_RAMPD__): New built-in define.\n+\t(__AVR_HAVE_RAMPX__): New built-in define.\n+\t(__AVR_HAVE_RAMPY__): New built-in define.\n+\t(__AVR_HAVE_RAMPZ__): Change condition when to built-in define it.\n+\n+\t* config/avr/avr.c (avr_addr_t): Add ccp, rampd, rampx, rampy.\n+\t(avr_option_override): Initialize them.\n+\t(sreg_rtx, rampd_rtx, rampx_rtx, rampy_rtx): New GTY rtx.\n+\t(avr_init_expanders): Initialize them. No more block several calls.\n+\t(emit_push_sfr): New static function.\n+\t(avr_prologue_setup_frame): Use it to push SREG, RAMPD/X/Y/Z as needed.\n+\tHandle AVR_XMEGA.\n+\t(expand_epilogue): Handle AVR_XMEGA. Pop RAMPD/X/Y/Z as needed.\n+\t(avr_print_operand): Print addreeses as symbols for\n+\tRAMPX, RAMPY, RAMPD, CCP.\n+\t(output_movhi): Handle AVR_XMEGA when writing to SP.\n+\t(avr_out_movhi_mr_r_xmega): New static function.\n+\t(out_movhi_mr_r): Forward to avr_out_movhi_mr_r_xmega for AVR_XMEGA.\n+\t(avr_file_start): Print symbol defines for __RAMPX__,  __RAMPY__,\n+\t__RAMPD__,  __CCP__ as needed.\n+\n+\t* config/avr/multilib.h: Regenerate.\n+\t* config/avr/t-multilib: Regenerate.\n+\t* config/avr/avr-tables.opt: Regenerate.\n+\n 2012-02-15  Tobias Grosser <grosser@fim.uni-passau.de>\n \n \tPR tree-optimization/50561"}, {"sha": "aabeb2177a1852be1a82e9a38e2142674166307e", "filename": "gcc/config/avr/avr-c.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da8c1adcf5cefd0274f26077fadbfaeb0216344/gcc%2Fconfig%2Favr%2Favr-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da8c1adcf5cefd0274f26077fadbfaeb0216344/gcc%2Fconfig%2Favr%2Favr-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-c.c?ref=2da8c1adcf5cefd0274f26077fadbfaeb0216344", "patch": "@@ -77,23 +77,21 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n   builtin_define_std (\"AVR\");\n \n   if (avr_current_arch->macro)\n-    cpp_define (pfile, avr_current_arch->macro);\n+    cpp_define_formatted (pfile, \"__AVR_ARCH__=%s\", avr_current_arch->macro);\n   if (avr_extra_arch_macro)\n     cpp_define (pfile, avr_extra_arch_macro);\n-  if (avr_current_arch->have_elpm)\n-    cpp_define (pfile, \"__AVR_HAVE_RAMPZ__\");\n-  if (avr_current_arch->have_elpm)\n-    cpp_define (pfile, \"__AVR_HAVE_ELPM__\");\n-  if (avr_current_arch->have_elpmx)\n-    cpp_define (pfile, \"__AVR_HAVE_ELPMX__\");\n-  if (avr_current_arch->have_movw_lpmx)\n-    {\n-      cpp_define (pfile, \"__AVR_HAVE_MOVW__\");\n-      cpp_define (pfile, \"__AVR_HAVE_LPMX__\");\n-    }\n+  if (AVR_HAVE_RAMPD)    cpp_define (pfile, \"__AVR_HAVE_RAMPD__\");\n+  if (AVR_HAVE_RAMPX)    cpp_define (pfile, \"__AVR_HAVE_RAMPX__\");\n+  if (AVR_HAVE_RAMPY)    cpp_define (pfile, \"__AVR_HAVE_RAMPY__\");\n+  if (AVR_HAVE_RAMPZ)    cpp_define (pfile, \"__AVR_HAVE_RAMPZ__\");\n+  if (AVR_HAVE_ELPM)     cpp_define (pfile, \"__AVR_HAVE_ELPM__\");\n+  if (AVR_HAVE_ELPMX)    cpp_define (pfile, \"__AVR_HAVE_ELPMX__\");\n+  if (AVR_HAVE_MOVW)     cpp_define (pfile, \"__AVR_HAVE_MOVW__\");\n+  if (AVR_HAVE_LPMX)     cpp_define (pfile, \"__AVR_HAVE_LPMX__\");\n+\n   if (avr_current_arch->asm_only)\n     cpp_define (pfile, \"__AVR_ASM_ONLY__\");\n-  if (avr_current_arch->have_mul)\n+  if (AVR_HAVE_MUL)\n     {\n       cpp_define (pfile, \"__AVR_ENHANCED__\");\n       cpp_define (pfile, \"__AVR_HAVE_MUL__\");\n@@ -103,6 +101,8 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n       cpp_define (pfile, \"__AVR_MEGA__\");\n       cpp_define (pfile, \"__AVR_HAVE_JMP_CALL__\");\n     }\n+  if (AVR_XMEGA)\n+    cpp_define (pfile, \"__AVR_XMEGA__\");\n   if (avr_current_arch->have_eijmp_eicall)\n     {\n       cpp_define (pfile, \"__AVR_HAVE_EIJMP_EICALL__\");"}, {"sha": "d04485420c965cfb7051b7934b2e6a67787c8a06", "filename": "gcc/config/avr/avr-devices.c", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da8c1adcf5cefd0274f26077fadbfaeb0216344/gcc%2Fconfig%2Favr%2Favr-devices.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da8c1adcf5cefd0274f26077fadbfaeb0216344/gcc%2Fconfig%2Favr%2Favr-devices.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-devices.c?ref=2da8c1adcf5cefd0274f26077fadbfaeb0216344", "patch": "@@ -32,21 +32,27 @@ avr_arch_types[] =\n   /* unknown device specified */\n   { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, 1, NULL,              \"avr2\"  },\n   /*\n-    A  M  J  LM E  E  E         d S   S O  # F\n-    S  U  M  PO L  L  I         a t   F ff 6 l \n-    M  L  P  MV P  P  J  -  -   t a   R s  4 a   \n-             XW M  M  M         a r     e    s\n-                   X  P           t     t  k h  */\n-  { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, 1, \"__AVR_ARCH__=1\",  \"avr1\"  },\n-  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, 1, \"__AVR_ARCH__=2\",  \"avr2\"  },\n-  { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0x0060, 32, 1, \"__AVR_ARCH__=25\", \"avr25\" },\n-  { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, 1, \"__AVR_ARCH__=3\",  \"avr3\"  },\n-  { 0, 0, 1, 0, 1, 0, 0, 0, 0, 0x0060, 32, 2, \"__AVR_ARCH__=31\", \"avr31\" },\n-  { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0x0060, 32, 1, \"__AVR_ARCH__=35\", \"avr35\" },\n-  { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0x0060, 32, 1, \"__AVR_ARCH__=4\",  \"avr4\"  },\n-  { 0, 1, 1, 1, 0, 0, 0, 0, 0, 0x0060, 32, 1, \"__AVR_ARCH__=5\",  \"avr5\"  },\n-  { 0, 1, 1, 1, 1, 1, 0, 0, 0, 0x0060, 32, 2, \"__AVR_ARCH__=51\", \"avr51\" },\n-  { 0, 1, 1, 1, 1, 1, 1, 0, 0, 0x0060, 32, 4, \"__AVR_ARCH__=6\",  \"avr6\"  }\n+    A  M  J  LM E  E  E  X  R   d S   S O  # F  A\n+    S  U  M  PO L  L  I  M  A   a t   F ff 6 l  r\n+    M  L  P  MV P  P  J  E  M   t a   R s  4 a  c \n+             XW M  M  M  G  P   a r     e    s  h\n+                   X  P  A  D     t     t  k h  ID   */\n+  { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, 1,  \"1\",   \"avr1\"  },\n+  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, 1,  \"2\",   \"avr2\"  },\n+  { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0x0060, 32, 1,  \"25\",  \"avr25\" },\n+  { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, 1,  \"3\",   \"avr3\"  },\n+  { 0, 0, 1, 0, 1, 0, 0, 0, 0, 0x0060, 32, 2,  \"31\",  \"avr31\" },\n+  { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0x0060, 32, 1,  \"35\",  \"avr35\" },\n+  { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0x0060, 32, 1,  \"4\",   \"avr4\"  },\n+  { 0, 1, 1, 1, 0, 0, 0, 0, 0, 0x0060, 32, 1,  \"5\",   \"avr5\"  },\n+  { 0, 1, 1, 1, 1, 1, 0, 0, 0, 0x0060, 32, 2,  \"51\",  \"avr51\" },\n+  { 0, 1, 1, 1, 1, 1, 1, 0, 0, 0x0060, 32, 4,  \"6\",   \"avr6\"  },\n+\n+  { 0, 1, 1, 1, 0, 0, 0, 1, 0, 0x2000,  0, 1,  \"102\", \"avrxmega2\" },\n+  { 0, 1, 1, 1, 0, 0, 0, 1, 0, 0x2000,  0, 1,  \"104\", \"avrxmega4\" }, /* Same */\n+  { 0, 1, 1, 1, 0, 0, 0, 1, 1, 0x2000,  0, 1,  \"105\", \"avrxmega5\" },\n+  { 0, 1, 1, 1, 1, 1, 1, 1, 0, 0x2000,  0, 4,  \"106\", \"avrxmega6\" },\n+  { 0, 1, 1, 1, 1, 1, 1, 1, 1, 0x2000,  0, 4,  \"107\", \"avrxmega7\" }\n };\n \n const struct mcu_type_s avr_mcu_types[] = {"}, {"sha": "03a92b458c0560eb40543910d8920ea666c071c8", "filename": "gcc/config/avr/avr-mcus.def", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da8c1adcf5cefd0274f26077fadbfaeb0216344/gcc%2Fconfig%2Favr%2Favr-mcus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da8c1adcf5cefd0274f26077fadbfaeb0216344/gcc%2Fconfig%2Favr%2Favr-mcus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-mcus.def?ref=2da8c1adcf5cefd0274f26077fadbfaeb0216344", "patch": "@@ -201,6 +201,36 @@ AVR_MCU (\"at90usb1287\",          ARCH_AVR51, \"__AVR_AT90USB1287__\",      0, 0, 0\n AVR_MCU (\"avr6\",                 ARCH_AVR6, NULL,                        0, 0, 0x0200, \"m2561\")\n AVR_MCU (\"atmega2560\",           ARCH_AVR6, \"__AVR_ATmega2560__\",        0, 0, 0x0200, \"m2560\")\n AVR_MCU (\"atmega2561\",           ARCH_AVR6, \"__AVR_ATmega2561__\",        0, 0, 0x0200, \"m2561\")\n+/* Xmega, 16K <= Flash < 64K, RAM <= 64K */\n+AVR_MCU (\"avrxmega2\",        ARCH_AVRXMEGA2, NULL,                       0, 0, 0x2000, \"x32a4\")\n+AVR_MCU (\"atxmega16a4\",      ARCH_AVRXMEGA2, \"__AVR_ATxmega16A4__\",      0, 0, 0x2000, \"x16a4\")\n+AVR_MCU (\"atxmega16d4\",      ARCH_AVRXMEGA2, \"__AVR_ATxmega16D4__\",      0, 0, 0x2000, \"x16d4\")\n+AVR_MCU (\"atxmega16x1\",      ARCH_AVRXMEGA2, \"__AVR_ATxmega16X1__\",      0, 0, 0x2000, \"x16x1\")\n+AVR_MCU (\"atxmega32a4\",      ARCH_AVRXMEGA2, \"__AVR_ATxmega32A4__\",      0, 0, 0x2000, \"x32a4\")\n+AVR_MCU (\"atxmega32d4\",      ARCH_AVRXMEGA2, \"__AVR_ATxmega32D4__\",      0, 0, 0x2000, \"x32d4\")\n+AVR_MCU (\"atxmega32x1\",      ARCH_AVRXMEGA2, \"__AVR_ATxmega32X1__\",      0, 0, 0x2000, \"x32x1\")\n+/* Xmega, Flash == 64K, RAM <= 64K */\n+AVR_MCU (\"avrxmega4\",        ARCH_AVRXMEGA4, NULL,                       0, 0, 0x2000, \"x64a4\")\n+AVR_MCU (\"atxmega64a3\",      ARCH_AVRXMEGA4, \"__AVR_ATxmega64A3__\",      0, 0, 0x2000, \"x64a3\")\n+AVR_MCU (\"atxmega64d3\",      ARCH_AVRXMEGA4, \"__AVR_ATxmega64D3__\",      0, 0, 0x2000, \"x64d3\")\n+/* Xmega, Flash == 64K, RAM > 64K */\n+AVR_MCU (\"avrxmega5\",        ARCH_AVRXMEGA5, NULL,                       0, 0, 0x2000, \"x64a1\")\n+AVR_MCU (\"atxmega64a1\",      ARCH_AVRXMEGA5, \"__AVR_ATxmega64A1__\",      0, 0, 0x2000, \"x64a1\")\n+AVR_MCU (\"atxmega64a1u\",     ARCH_AVRXMEGA5, \"__AVR_ATxmega64A1U__\",     0, 0, 0x2000, \"x64a1u\")\n+/* Xmega, 128K <= Flash <= 256K, RAM <= 64K */\n+AVR_MCU (\"avrxmega6\",        ARCH_AVRXMEGA6, NULL,                       0, 0, 0x2000, \"x128a3\")\n+AVR_MCU (\"atxmega128a3\",     ARCH_AVRXMEGA6, \"__AVR_ATxmega128A3__\",     0, 0, 0x2000, \"x128a3\")\n+AVR_MCU (\"atxmega128d3\",     ARCH_AVRXMEGA6, \"__AVR_ATxmega128D3__\",     0, 0, 0x2000, \"x128d3\")\n+AVR_MCU (\"atxmega192a3\",     ARCH_AVRXMEGA6, \"__AVR_ATxmega192A3__\",     0, 0, 0x2000, \"x192a3\")\n+AVR_MCU (\"atxmega192d3\",     ARCH_AVRXMEGA6, \"__AVR_ATxmega192D3__\",     0, 0, 0x2000, \"x192d3\")\n+AVR_MCU (\"atxmega256a3\",     ARCH_AVRXMEGA6, \"__AVR_ATxmega256A3__\",     0, 0, 0x2000, \"x256a3\")\n+AVR_MCU (\"atxmega256a3b\",    ARCH_AVRXMEGA6, \"__AVR_ATxmega256A3B__\",    0, 0, 0x2000, \"x256a3b\")\n+AVR_MCU (\"atxmega256a3bu\",   ARCH_AVRXMEGA6, \"__AVR_ATxmega256A3BU__\",   0, 0, 0x2000, \"x256a3bu\")\n+AVR_MCU (\"atxmega256d3\",     ARCH_AVRXMEGA6, \"__AVR_ATxmega256D3__\",     0, 0, 0x2000, \"x256d3\")\n+/* Xmega, 128K <= Flash <= 256K, RAM > 64K RAM.  */\n+AVR_MCU (\"avrxmega7\",        ARCH_AVRXMEGA7, NULL,                       0, 0, 0x2000, \"x128a1\")\n+AVR_MCU (\"atxmega128a1\",     ARCH_AVRXMEGA7, \"__AVR_ATxmega128A1__\",     0, 0, 0x2000, \"x128a1\")\n+AVR_MCU (\"atxmega128a1u\",    ARCH_AVRXMEGA7, \"__AVR_ATxmega128A1U__\",    0, 0, 0x2000, \"x128a1u\")\n /* Assembler only.  */\n AVR_MCU (\"avr1\",                 ARCH_AVR1, NULL,                        0, 0, 0x0060, \"s1200\")\n AVR_MCU (\"at90s1200\",            ARCH_AVR1, \"__AVR_AT90S1200__\",         0, 0, 0x0060, \"s1200\")"}, {"sha": "32fc17914fe4b3b9a9482fb306bdabbc1f70f099", "filename": "gcc/config/avr/avr-tables.opt", "status": "modified", "additions": 81, "deletions": 6, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da8c1adcf5cefd0274f26077fadbfaeb0216344/gcc%2Fconfig%2Favr%2Favr-tables.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da8c1adcf5cefd0274f26077fadbfaeb0216344/gcc%2Fconfig%2Favr%2Favr-tables.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-tables.opt?ref=2da8c1adcf5cefd0274f26077fadbfaeb0216344", "patch": "@@ -504,20 +504,95 @@ EnumValue\n Enum(avr_mcu) String(atmega2561) Value(159)\n \n EnumValue\n-Enum(avr_mcu) String(avr1) Value(160)\n+Enum(avr_mcu) String(avrxmega2) Value(160)\n \n EnumValue\n-Enum(avr_mcu) String(at90s1200) Value(161)\n+Enum(avr_mcu) String(atxmega16a4) Value(161)\n \n EnumValue\n-Enum(avr_mcu) String(attiny11) Value(162)\n+Enum(avr_mcu) String(atxmega16d4) Value(162)\n \n EnumValue\n-Enum(avr_mcu) String(attiny12) Value(163)\n+Enum(avr_mcu) String(atxmega16x1) Value(163)\n \n EnumValue\n-Enum(avr_mcu) String(attiny15) Value(164)\n+Enum(avr_mcu) String(atxmega32a4) Value(164)\n \n EnumValue\n-Enum(avr_mcu) String(attiny28) Value(165)\n+Enum(avr_mcu) String(atxmega32d4) Value(165)\n+\n+EnumValue\n+Enum(avr_mcu) String(atxmega32x1) Value(166)\n+\n+EnumValue\n+Enum(avr_mcu) String(avrxmega4) Value(167)\n+\n+EnumValue\n+Enum(avr_mcu) String(atxmega64a3) Value(168)\n+\n+EnumValue\n+Enum(avr_mcu) String(atxmega64d3) Value(169)\n+\n+EnumValue\n+Enum(avr_mcu) String(avrxmega5) Value(170)\n+\n+EnumValue\n+Enum(avr_mcu) String(atxmega64a1) Value(171)\n+\n+EnumValue\n+Enum(avr_mcu) String(atxmega64a1u) Value(172)\n+\n+EnumValue\n+Enum(avr_mcu) String(avrxmega6) Value(173)\n+\n+EnumValue\n+Enum(avr_mcu) String(atxmega128a3) Value(174)\n+\n+EnumValue\n+Enum(avr_mcu) String(atxmega128d3) Value(175)\n+\n+EnumValue\n+Enum(avr_mcu) String(atxmega192a3) Value(176)\n+\n+EnumValue\n+Enum(avr_mcu) String(atxmega192d3) Value(177)\n+\n+EnumValue\n+Enum(avr_mcu) String(atxmega256a3) Value(178)\n+\n+EnumValue\n+Enum(avr_mcu) String(atxmega256a3b) Value(179)\n+\n+EnumValue\n+Enum(avr_mcu) String(atxmega256a3bu) Value(180)\n+\n+EnumValue\n+Enum(avr_mcu) String(atxmega256d3) Value(181)\n+\n+EnumValue\n+Enum(avr_mcu) String(avrxmega7) Value(182)\n+\n+EnumValue\n+Enum(avr_mcu) String(atxmega128a1) Value(183)\n+\n+EnumValue\n+Enum(avr_mcu) String(atxmega128a1u) Value(184)\n+\n+EnumValue\n+Enum(avr_mcu) String(avr1) Value(185)\n+\n+EnumValue\n+Enum(avr_mcu) String(at90s1200) Value(186)\n+\n+EnumValue\n+Enum(avr_mcu) String(attiny11) Value(187)\n+\n+EnumValue\n+Enum(avr_mcu) String(attiny12) Value(188)\n+\n+EnumValue\n+Enum(avr_mcu) String(attiny15) Value(189)\n+\n+EnumValue\n+Enum(avr_mcu) String(attiny28) Value(190)\n "}, {"sha": "8a0d69ae3ea680a38574aa443f995922f02f473d", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 262, "deletions": 34, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da8c1adcf5cefd0274f26077fadbfaeb0216344/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da8c1adcf5cefd0274f26077fadbfaeb0216344/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=2da8c1adcf5cefd0274f26077fadbfaeb0216344", "patch": "@@ -112,6 +112,12 @@ typedef struct\n   /* SREG: The pocessor status */\n   int sreg;\n \n+  /* RAMPX, RAMPY, RAMPD and CCP of XMEGA */\n+  int ccp;\n+  int rampd;\n+  int rampx;\n+  int rampy;\n+\n   /* RAMPZ: The high byte of 24-bit address used with ELPM */ \n   int rampz;\n \n@@ -177,8 +183,18 @@ rtx zero_reg_rtx;\n extern GTY(()) rtx all_regs_rtx[32];\n rtx all_regs_rtx[32];\n \n-/* RAMPZ special function register */\n+/* SREG, the processor status */\n+extern GTY(()) rtx sreg_rtx;\n+rtx sreg_rtx;\n+\n+/* RAMP* special function registers */\n+extern GTY(()) rtx rampd_rtx;\n+extern GTY(()) rtx rampx_rtx;\n+extern GTY(()) rtx rampy_rtx;\n extern GTY(()) rtx rampz_rtx;\n+rtx rampd_rtx;\n+rtx rampx_rtx;\n+rtx rampy_rtx;\n rtx rampz_rtx;\n \n /* RTX containing the strings \"\" and \"e\", respectively */\n@@ -424,6 +440,11 @@ avr_option_override (void)\n   /* RAMPZ: Address' high part when loading via ELPM */\n   avr_addr.rampz = 0x3B + avr_current_arch->sfr_offset;\n \n+  avr_addr.rampy = 0x3A + avr_current_arch->sfr_offset;\n+  avr_addr.rampx = 0x39 + avr_current_arch->sfr_offset;\n+  avr_addr.rampd = 0x38 + avr_current_arch->sfr_offset;\n+  avr_addr.ccp = 0x34 + avr_current_arch->sfr_offset;\n+\n   /* SP: Stack Pointer (SP_H:SP_L) */\n   avr_addr.sp_l = 0x3D + avr_current_arch->sfr_offset;\n   avr_addr.sp_h = avr_addr.sp_l + 1;\n@@ -450,13 +471,6 @@ avr_init_expanders (void)\n {\n   int regno;\n \n-  static bool done = false;\n-\n-  if (done)\n-    return;\n-  else\n-    done = true;\n-\n   for (regno = 0; regno < 32; regno ++)\n     all_regs_rtx[regno] = gen_rtx_REG (QImode, regno);\n \n@@ -466,6 +480,10 @@ avr_init_expanders (void)\n \n   lpm_addr_reg_rtx = gen_rtx_REG (HImode, REG_Z);\n \n+  sreg_rtx = gen_rtx_MEM (QImode, GEN_INT (avr_addr.sreg));\n+  rampd_rtx = gen_rtx_MEM (QImode, GEN_INT (avr_addr.rampd));\n+  rampx_rtx = gen_rtx_MEM (QImode, GEN_INT (avr_addr.rampx));\n+  rampy_rtx = gen_rtx_MEM (QImode, GEN_INT (avr_addr.rampy));\n   rampz_rtx = gen_rtx_MEM (QImode, GEN_INT (avr_addr.rampz));\n \n   xstring_empty = gen_rtx_CONST_STRING (VOIDmode, \"\");\n@@ -903,6 +921,35 @@ emit_push_byte (unsigned regno, bool frame_related_p)\n   cfun->machine->stack_usage++;\n }\n \n+\n+/*  Helper for expand_prologue.  Emit a push of a SFR via tmp_reg.\n+    SFR is a MEM representing the memory location of the SFR.\n+    If CLR_P then clear the SFR after the push using zero_reg.  */\n+\n+static void\n+emit_push_sfr (rtx sfr, bool frame_related_p, bool clr_p)\n+{\n+  rtx insn;\n+  \n+  gcc_assert (MEM_P (sfr));\n+\n+  /* IN __tmp_reg__, IO(SFR) */\n+  insn = emit_move_insn (tmp_reg_rtx, sfr);\n+  if (frame_related_p)\n+    RTX_FRAME_RELATED_P (insn) = 1;\n+  \n+  /* PUSH __tmp_reg__ */\n+  emit_push_byte (TMP_REGNO, frame_related_p);\n+\n+  if (clr_p)\n+    {\n+      /* OUT IO(SFR), __zero_reg__ */\n+      insn = emit_move_insn (sfr, const0_rtx);\n+      if (frame_related_p)\n+        RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+}\n+\n static void\n avr_prologue_setup_frame (HOST_WIDE_INT size, HARD_REG_SET set)\n {\n@@ -1061,7 +1108,7 @@ avr_prologue_setup_frame (HOST_WIDE_INT size, HARD_REG_SET set)\n              changed the CFA to the frame pointer this operation\n              need not be annotated if frame pointer is needed.  */\n               \n-          if (AVR_HAVE_8BIT_SP)\n+          if (AVR_HAVE_8BIT_SP || AVR_XMEGA)\n             {\n               insn = emit_move_insn (stack_pointer_rtx, fp);\n             }\n@@ -1166,26 +1213,42 @@ expand_prologue (void)\n \n       /* Push SREG.  */\n       /* ??? There's no dwarf2 column reserved for SREG.  */\n-      emit_move_insn (tmp_reg_rtx,\n-                      gen_rtx_MEM (QImode, GEN_INT (avr_addr.sreg)));\n-      emit_push_byte (TMP_REGNO, false);\n+      emit_push_sfr (sreg_rtx, false, false /* clr */);\n \n-      /* Push RAMPZ.  */\n-      /* ??? There's no dwarf2 column reserved for RAMPZ.  */\n-      if (AVR_HAVE_RAMPZ \n-          && TEST_HARD_REG_BIT (set, REG_Z)\n-          && TEST_HARD_REG_BIT (set, REG_Z + 1))\n-        {\n-          emit_move_insn (tmp_reg_rtx, rampz_rtx);\n-          emit_push_byte (TMP_REGNO, false);\n-        }\n-        \n       /* Clear zero reg.  */\n       emit_move_insn (zero_reg_rtx, const0_rtx);\n \n       /* Prevent any attempt to delete the setting of ZERO_REG!  */\n       emit_use (zero_reg_rtx);\n-    }\n+\n+      /* Push and clear RAMPD/X/Y/Z if present and low-part register is used.\n+         ??? There are no dwarf2 columns reserved for RAMPD/X/Y/Z.  */\n+      \n+      if (AVR_HAVE_RAMPD)\n+        emit_push_sfr (rampd_rtx, false /* frame-related */, true /* clr */);\n+\n+      if (AVR_HAVE_RAMPX\n+          && TEST_HARD_REG_BIT (set, REG_X)\n+          && TEST_HARD_REG_BIT (set, REG_X + 1))\n+        {\n+          emit_push_sfr (rampx_rtx, false /* frame-related */, true /* clr */);\n+        }\n+\n+      if (AVR_HAVE_RAMPY\n+          && (frame_pointer_needed\n+              || (TEST_HARD_REG_BIT (set, REG_Y)\n+                  && TEST_HARD_REG_BIT (set, REG_Y + 1))))\n+        {\n+          emit_push_sfr (rampy_rtx, false /* frame-related */, true /* clr */);\n+        }\n+\n+      if (AVR_HAVE_RAMPZ \n+          && TEST_HARD_REG_BIT (set, REG_Z)\n+          && TEST_HARD_REG_BIT (set, REG_Z + 1))\n+        {\n+          emit_push_sfr (rampz_rtx, false /* frame-related */, true /* clr */);\n+        }\n+    }  /* is_interrupt is_signal */\n \n   avr_prologue_setup_frame (size, set);\n   \n@@ -1344,7 +1407,7 @@ expand_epilogue (bool sibcall_p)\n \n       /* Copy to stack pointer.  */\n               \n-      if (AVR_HAVE_8BIT_SP)\n+      if (AVR_HAVE_8BIT_SP || AVR_XMEGA)\n         {\n           emit_move_insn (stack_pointer_rtx, fp);\n         }\n@@ -1407,21 +1470,44 @@ expand_epilogue (bool sibcall_p)\n \n   if (isr_p)\n     {\n-      /* Restore RAMPZ using tmp reg as scratch.  */\n+      /* Restore RAMPZ/Y/X/D using tmp_reg as scratch.\n+         The conditions to restore them must be tha same as in prologue.  */\n       \n-      if (AVR_HAVE_RAMPZ \n+      if (AVR_HAVE_RAMPX\n+          && TEST_HARD_REG_BIT (set, REG_X)\n+          && TEST_HARD_REG_BIT (set, REG_X + 1))\n+        {\n+          emit_pop_byte (TMP_REGNO);\n+          emit_move_insn (rampx_rtx, tmp_reg_rtx);\n+        }\n+\n+      if (AVR_HAVE_RAMPY\n+          && (frame_pointer_needed\n+              || (TEST_HARD_REG_BIT (set, REG_Y)\n+                  && TEST_HARD_REG_BIT (set, REG_Y + 1))))\n+        {\n+          emit_pop_byte (TMP_REGNO);\n+          emit_move_insn (rampy_rtx, tmp_reg_rtx);\n+        }\n+\n+      if (AVR_HAVE_RAMPZ\n           && TEST_HARD_REG_BIT (set, REG_Z)\n           && TEST_HARD_REG_BIT (set, REG_Z + 1))\n         {\n           emit_pop_byte (TMP_REGNO);\n           emit_move_insn (rampz_rtx, tmp_reg_rtx);\n         }\n \n-      /* Restore SREG using tmp reg as scratch.  */\n+      if (AVR_HAVE_RAMPD)\n+        {\n+          emit_pop_byte (TMP_REGNO);\n+          emit_move_insn (rampd_rtx, tmp_reg_rtx);\n+        }\n+\n+      /* Restore SREG using tmp_reg as scratch.  */\n       \n       emit_pop_byte (TMP_REGNO);\n-      emit_move_insn (gen_rtx_MEM (QImode, GEN_INT (avr_addr.sreg)), \n-                      tmp_reg_rtx);\n+      emit_move_insn (sreg_rtx, tmp_reg_rtx);\n \n       /* Restore tmp REG.  */\n       emit_pop_byte (TMP_REGNO);\n@@ -1903,7 +1989,16 @@ avr_print_operand (FILE *file, rtx x, int code)\n       else if (low_io_address_operand (x, VOIDmode)\n                || high_io_address_operand (x, VOIDmode))\n         {\n-          if (ival == avr_addr.rampz)       fprintf (file, \"__RAMPZ__\");\n+          if (AVR_HAVE_RAMPZ && ival == avr_addr.rampz)\n+            fprintf (file, \"__RAMPZ__\");\n+          else if (AVR_HAVE_RAMPY && ival == avr_addr.rampy)\n+            fprintf (file, \"__RAMPY__\");\n+          else if (AVR_HAVE_RAMPX && ival == avr_addr.rampx)\n+            fprintf (file, \"__RAMPX__\");\n+          else if (AVR_HAVE_RAMPD && ival == avr_addr.rampd)\n+            fprintf (file, \"__RAMPD__\");\n+          else if (AVR_XMEGA && ival == avr_addr.ccp)\n+            fprintf (file, \"__CCP__\");\n           else if (ival == avr_addr.sreg)   fprintf (file, \"__SREG__\");\n           else if (ival == avr_addr.sp_l)   fprintf (file, \"__SP_L__\");\n           else if (ival == avr_addr.sp_h)   fprintf (file, \"__SP_H__\");\n@@ -2901,6 +2996,10 @@ output_movhi (rtx insn, rtx xop[], int *plen)\n             {\n               if (AVR_HAVE_8BIT_SP)\n                 return avr_asm_len (\"out __SP_L__,%A1\", xop, plen, -1);\n+\n+              if (AVR_XMEGA)\n+                return avr_asm_len (\"out __SP_L__,%A1\" CR_TAB\n+                                    \"out __SP_H__,%B1\", xop, plen, -2);\n               \n               /* Use simple load of SP if no interrupts are  used.  */\n               \n@@ -3875,18 +3974,138 @@ out_movqi_mr_r (rtx insn, rtx op[], int *plen)\n   return avr_asm_len (\"st %0,%1\", op, plen, -1);\n }\n \n+\n+/* Helper for the next function for XMEGA.  It does the same\n+   but with low byte first.  */\n+\n static const char*\n-out_movhi_mr_r (rtx insn, rtx op[], int *plen)\n+avr_out_movhi_mr_r_xmega (rtx insn, rtx op[], int *plen)\n {\n   rtx dest = op[0];\n   rtx src = op[1];\n   rtx base = XEXP (dest, 0);\n   int reg_base = true_regnum (base);\n   int reg_src = true_regnum (src);\n-  /* \"volatile\" forces writing high byte first, even if less efficient,\n-     for correct operation with 16-bit I/O registers.  */\n+\n+  /* \"volatile\" forces writing low byte first, even if less efficient,\n+     for correct operation with 16-bit I/O registers like SP.  */\n   int mem_volatile_p = MEM_VOLATILE_P (dest);\n \n+  if (CONSTANT_ADDRESS_P (base))\n+    return optimize > 0 && io_address_operand (base, HImode)\n+      ? avr_asm_len (\"out %i0,%A1\" CR_TAB\n+                     \"out %i0+1,%B1\", op, plen, -2)\n+\n+      : avr_asm_len (\"sts %m0,%A1\" CR_TAB\n+                     \"sts %m0+1,%B1\", op, plen, -4);\n+  \n+  if (reg_base > 0)\n+    {\n+      if (reg_base != REG_X)\n+        return avr_asm_len (\"st %0,%A1\" CR_TAB\n+                            \"std %0+1,%B1\", op, plen, -2);\n+      \n+      if (reg_src == REG_X)\n+        /* \"st X+,r26\" and \"st -X,r26\" are undefined.  */\n+        avr_asm_len (\"mov __tmp_reg__,r27\" CR_TAB\n+                     \"st X,r26\"            CR_TAB\n+                     \"adiw r26,1\"          CR_TAB\n+                     \"st X,__tmp_reg__\", op, plen, -4);\n+      else\n+        avr_asm_len (\"st X+,%A1\" CR_TAB\n+                     \"st X,%B1\", op, plen, -2);\n+            \n+      return reg_unused_after (insn, src)\n+        ? \"\"\n+        : avr_asm_len (\"sbiw r26,1\", op, plen, 1);\n+    }\n+  else if (GET_CODE (base) == PLUS)\n+    {\n+      int disp = INTVAL (XEXP (base, 1));\n+      reg_base = REGNO (XEXP (base, 0));\n+      if (disp > MAX_LD_OFFSET (GET_MODE (dest)))\n+        {\n+          if (reg_base != REG_Y)\n+            fatal_insn (\"incorrect insn:\",insn);\n+          \n+          return disp <= 63 + MAX_LD_OFFSET (GET_MODE (dest))\n+            ? avr_asm_len (\"adiw r28,%o0-62\" CR_TAB\n+                           \"std Y+62,%A1\"    CR_TAB\n+                           \"std Y+63,%B1\"    CR_TAB\n+                           \"sbiw r28,%o0-62\", op, plen, -4)\n+\n+            : avr_asm_len (\"subi r28,lo8(-%o0)\" CR_TAB\n+                           \"sbci r29,hi8(-%o0)\" CR_TAB\n+                           \"st Y,%A1\"           CR_TAB\n+                           \"std Y+1,%B1\"        CR_TAB\n+                           \"subi r28,lo8(%o0)\"  CR_TAB\n+                           \"sbci r29,hi8(%o0)\", op, plen, -6);\n+        }\n+      \n+      if (reg_base != REG_X)\n+        return avr_asm_len (\"std %A0,%A1\" CR_TAB\n+                            \"std %B0,%B1\", op, plen, -2);\n+      /* (X + d) = R */\n+      return reg_src == REG_X\n+        ? avr_asm_len (\"mov __tmp_reg__,r26\"  CR_TAB\n+                       \"mov __zero_reg__,r27\" CR_TAB\n+                       \"adiw r26,%o0\"         CR_TAB\n+                       \"st X+,__tmp_reg__\"    CR_TAB\n+                       \"st X,__zero_reg__\"    CR_TAB\n+                       \"clr __zero_reg__\"     CR_TAB\n+                       \"sbiw r26,%o0+1\", op, plen, -7)\n+\n+        : avr_asm_len (\"adiw r26,%o0\" CR_TAB\n+                       \"st X+,%A1\"    CR_TAB\n+                       \"st X,%B1\"     CR_TAB\n+                       \"sbiw r26,%o0+1\", op, plen, -4);\n+    }\n+  else if (GET_CODE (base) == PRE_DEC) /* (--R) */\n+    {\n+      if (!mem_volatile_p)\n+        return avr_asm_len (\"st %0,%B1\" CR_TAB\n+                            \"st %0,%A1\", op, plen, -2);\n+\n+      return REGNO (XEXP (base, 0)) == REG_X\n+        ? avr_asm_len (\"sbiw r26,2\"  CR_TAB\n+                       \"st X+,%A1\"   CR_TAB\n+                       \"st X,%B1\"    CR_TAB\n+                       \"sbiw r26,1\", op, plen, -4)\n+\n+        : avr_asm_len (\"sbiw %r0,2\"  CR_TAB\n+                       \"st %p0,%A1\"  CR_TAB\n+                       \"std %p0+1,%B1\", op, plen, -3);\n+    }\n+  else if (GET_CODE (base) == POST_INC) /* (R++) */\n+    {\n+      return avr_asm_len (\"st %0,%A1\"  CR_TAB\n+                          \"st %0,%B1\", op, plen, -2);\n+      \n+    }\n+  fatal_insn (\"unknown move insn:\",insn);\n+  return \"\";\n+}\n+\n+\n+static const char*\n+out_movhi_mr_r (rtx insn, rtx op[], int *plen)\n+{\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx base = XEXP (dest, 0);\n+  int reg_base = true_regnum (base);\n+  int reg_src = true_regnum (src);\n+  int mem_volatile_p;\n+\n+  /* \"volatile\" forces writing high-byte first (no-xmega) resp.\n+     low-byte first (xmega) even if less efficient, for correct\n+     operation with 16-bit I/O registers like.  */\n+\n+  if (AVR_XMEGA)\n+    return avr_out_movhi_mr_r_xmega (insn, op, plen);\n+\n+  mem_volatile_p = MEM_VOLATILE_P (dest);\n+\n   if (CONSTANT_ADDRESS_P (base))\n     return optimize > 0 && io_address_operand (base, HImode)\n       ? avr_asm_len (\"out %i0+1,%B1\" CR_TAB\n@@ -7332,7 +7551,16 @@ avr_file_start (void)\n \n   fprintf (asm_out_file, \"__SP_L__ = 0x%02x\\n\", avr_addr.sp_l - sfr_offset);\n   fprintf (asm_out_file, \"__SREG__ = 0x%02x\\n\", avr_addr.sreg - sfr_offset);\n-  fprintf (asm_out_file, \"__RAMPZ__ = 0x%02x\\n\", avr_addr.rampz - sfr_offset);\n+  if (AVR_HAVE_RAMPZ)\n+    fprintf (asm_out_file, \"__RAMPZ__ = 0x%02x\\n\", avr_addr.rampz - sfr_offset);\n+  if (AVR_HAVE_RAMPY)\n+    fprintf (asm_out_file, \"__RAMPY__ = 0x%02x\\n\", avr_addr.rampy - sfr_offset);\n+  if (AVR_HAVE_RAMPX)\n+    fprintf (asm_out_file, \"__RAMPX__ = 0x%02x\\n\", avr_addr.rampx - sfr_offset);\n+  if (AVR_HAVE_RAMPD)\n+    fprintf (asm_out_file, \"__RAMPD__ = 0x%02x\\n\", avr_addr.rampd - sfr_offset);\n+  if (AVR_XMEGA)\n+    fprintf (asm_out_file, \"__CCP__ = 0x%02x\\n\", avr_addr.ccp - sfr_offset);\n   fprintf (asm_out_file, \"__tmp_reg__ = %d\\n\", TMP_REGNO);\n   fprintf (asm_out_file, \"__zero_reg__ = %d\\n\", ZERO_REGNO);\n }"}, {"sha": "1b7bd3551cc61e229036d83829560c26a5de2c55", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da8c1adcf5cefd0274f26077fadbfaeb0216344/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da8c1adcf5cefd0274f26077fadbfaeb0216344/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=2da8c1adcf5cefd0274f26077fadbfaeb0216344", "patch": "@@ -46,11 +46,12 @@ struct base_arch_s\n   /* Core have 'EICALL' and 'EIJMP' instructions.  */\n   int have_eijmp_eicall;\n \n-  /* Reserved for xmega architecture.  */\n-  int reserved;\n+  /* This is an XMEGA core.  */\n+  int xmega_p;\n \n-  /* Reserved for xmega architecture.  */\n-  int reserved2;\n+  /* This core has the RAMPD special function register\n+     and thus also the RAMPX, RAMPY and RAMPZ registers.  */\n+  int have_rampd;\n   \n   /* Default start of data section address for architecture.  */\n   int default_data_section_start;\n@@ -62,6 +63,7 @@ struct base_arch_s\n   /* Number of 64k segments in the flash.  */\n   int n_segments;\n \n+  /* Architecture id to built-in define __AVR_ARCH__ (NULL -> no macro) */\n   const char *const macro;\n   \n   /* Architecture name.  */\n@@ -83,7 +85,12 @@ enum avr_arch\n   ARCH_AVR4,\n   ARCH_AVR5,\n   ARCH_AVR51,\n-  ARCH_AVR6\n+  ARCH_AVR6,\n+  ARCH_AVRXMEGA2,\n+  ARCH_AVRXMEGA4,\n+  ARCH_AVRXMEGA5,\n+  ARCH_AVRXMEGA6,\n+  ARCH_AVRXMEGA7\n };\n \n struct mcu_type_s {\n@@ -175,13 +182,19 @@ enum\n #define AVR_HAVE_LPMX (avr_current_arch->have_movw_lpmx)\n #define AVR_HAVE_ELPM (avr_current_arch->have_elpm)\n #define AVR_HAVE_ELPMX (avr_current_arch->have_elpmx)\n-#define AVR_HAVE_RAMPZ (avr_current_arch->have_elpm)\n+#define AVR_HAVE_RAMPD (avr_current_arch->have_rampd)\n+#define AVR_HAVE_RAMPX (avr_current_arch->have_rampd)\n+#define AVR_HAVE_RAMPY (avr_current_arch->have_rampd)\n+#define AVR_HAVE_RAMPZ (avr_current_arch->have_elpm             \\\n+                        || avr_current_arch->have_rampd)\n #define AVR_HAVE_EIJMP_EICALL (avr_current_arch->have_eijmp_eicall)\n #define AVR_HAVE_8BIT_SP (avr_current_device->short_sp || TARGET_TINY_STACK)\n \n #define AVR_2_BYTE_PC (!AVR_HAVE_EIJMP_EICALL)\n #define AVR_3_BYTE_PC (AVR_HAVE_EIJMP_EICALL)\n \n+#define AVR_XMEGA (avr_current_arch->xmega_p)\n+\n #define BITS_BIG_ENDIAN 0\n #define BYTES_BIG_ENDIAN 0\n #define WORDS_BIG_ENDIAN 0"}, {"sha": "88117b1cc37d8645d5449b87ba9b4176f1dfc8c7", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da8c1adcf5cefd0274f26077fadbfaeb0216344/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da8c1adcf5cefd0274f26077fadbfaeb0216344/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=2da8c1adcf5cefd0274f26077fadbfaeb0216344", "patch": "@@ -155,9 +155,10 @@\n ;; ijmp : ISA has no EICALL/EIJMP        eijmp : ISA has EICALL/EIJMP\n ;; lpm  : ISA has no LPMX                lpmx  : ISA has LPMX\n ;; elpm : ISA has ELPM but no ELPMX      elpmx : ISA has ELPMX\n+;; no_xmega: non-XMEGA core              xmega : XMEGA core\n \n (define_attr \"isa\"\n-  \"mov,movw, rjmp,jmp, ijmp,eijmp, lpm,lpmx, elpm,elpmx,\n+  \"mov,movw, rjmp,jmp, ijmp,eijmp, lpm,lpmx, elpm,elpmx, no_xmega,xmega,\n    standard\"\n   (const_string \"standard\"))\n \n@@ -204,6 +205,14 @@\n          (and (eq_attr \"isa\" \"elpmx\")\n               (match_test \"AVR_HAVE_ELPMX\"))\n          (const_int 1)\n+\n+         (and (eq_attr \"isa\" \"xmega\")\n+              (match_test \"AVR_XMEGA\"))\n+         (const_int 1)\n+\n+         (and (eq_attr \"isa\" \"no_xmega\")\n+              (match_test \"!AVR_XMEGA\"))\n+         (const_int 1)\n          ] (const_int 0)))\n \n \n@@ -580,15 +589,17 @@\n ;; handled by generic movhi insn.\n \n (define_insn \"movhi_sp_r\"\n-  [(set (match_operand:HI 0 \"stack_register_operand\"                \"=q,q\")\n-        (unspec_volatile:HI [(match_operand:HI 1 \"register_operand\"  \"r,r\")\n-                             (match_operand:HI 2 \"const_int_operand\" \"L,P\")]\n+  [(set (match_operand:HI 0 \"stack_register_operand\"                \"=q,q,q\")\n+        (unspec_volatile:HI [(match_operand:HI 1 \"register_operand\"  \"r,r,r\")\n+                             (match_operand:HI 2 \"const_int_operand\" \"L,P,LP\")]\n                             UNSPECV_WRITE_SP))]\n   \"!AVR_HAVE_8BIT_SP\"\n   \"@\n \tout __SP_H__,%B1\\;out __SP_L__,%A1\n-\tcli\\;out __SP_H__,%B1\\;sei\\;out __SP_L__,%A1\"\n-  [(set_attr \"length\" \"2,4\")\n+\tcli\\;out __SP_H__,%B1\\;sei\\;out __SP_L__,%A1\n+\tout __SP_L__,%A1\\;out __SP_H__,%B1\"\n+  [(set_attr \"length\" \"2,4,2\")\n+   (set_attr \"isa\" \"no_xmega,no_xmega,xmega\")\n    (set_attr \"cc\" \"none\")])\n \n (define_peephole2"}, {"sha": "582c6dae6f7550acf7abebefd8dd538e126adc1d", "filename": "gcc/config/avr/multilib.h", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da8c1adcf5cefd0274f26077fadbfaeb0216344/gcc%2Fconfig%2Favr%2Fmultilib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da8c1adcf5cefd0274f26077fadbfaeb0216344/gcc%2Fconfig%2Favr%2Fmultilib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fmultilib.h?ref=2da8c1adcf5cefd0274f26077fadbfaeb0216344", "patch": "@@ -44,19 +44,24 @@ static const char* const avr_multilib_raw[] = {\n   \"avr25/tiny-stack mmcu=attiny261;\",\n   \"avr25/tiny-stack mmcu=attiny261a;\",\n \n-  \". !mmcu=avr2 !mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6 !mtiny-stack !mmcu=at90s2313 !mmcu=at90s2323 !mmcu=at90s2333 !mmcu=at90s2343 !mmcu=attiny22 !mmcu=attiny26 !mmcu=at90s4433 !mmcu=attiny13 !mmcu=attiny13a !mmcu=attiny2313 !mmcu=attiny2313a !mmcu=attiny24 !mmcu=attiny24a !mmcu=attiny25 !mmcu=attiny261 !mmcu=attiny261a;\",\n-  \"avr2 mmcu=avr2 !mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6 !mtiny-stack;\",\n-  \"avr25 !mmcu=avr2 mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6 !mtiny-stack;\",\n-  \"avr3 !mmcu=avr2 !mmcu=avr25 mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6;\",\n-  \"avr31 !mmcu=avr2 !mmcu=avr25 !mmcu=avr3 mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6;\",\n-  \"avr35 !mmcu=avr2 !mmcu=avr25 !mmcu=avr3 !mmcu=avr31 mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6;\",\n-  \"avr4 !mmcu=avr2 !mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6;\",\n-  \"avr5 !mmcu=avr2 !mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 mmcu=avr5 !mmcu=avr51 !mmcu=avr6;\",\n-  \"avr51 !mmcu=avr2 !mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 mmcu=avr51 !mmcu=avr6;\",\n-  \"avr6 !mmcu=avr2 !mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 mmcu=avr6;\",\n-  \"tiny-stack !mmcu=avr2 !mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6 mtiny-stack;\",\n-  \"avr2/tiny-stack mmcu=avr2 !mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6 mtiny-stack;\",\n-  \"avr25/tiny-stack !mmcu=avr2 mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6 mtiny-stack;\",\n+  \". !mmcu=avr2 !mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6 !mmcu=avrxmega2 !mmcu=avrxmega4 !mmcu=avrxmega5 !mmcu=avrxmega6 !mmcu=avrxmega7 !mtiny-stack !mmcu=at90s2313 !mmcu=at90s2323 !mmcu=at90s2333 !mmcu=at90s2343 !mmcu=attiny22 !mmcu=attiny26 !mmcu=at90s4433 !mmcu=attiny13 !mmcu=attiny13a !mmcu=attiny2313 !mmcu=attiny2313a !mmcu=attiny24 !mmcu=attiny24a !mmcu=attiny25 !mmcu=attiny261 !mmcu=attiny261a;\",\n+  \"avr2 mmcu=avr2 !mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6 !mmcu=avrxmega2 !mmcu=avrxmega4 !mmcu=avrxmega5 !mmcu=avrxmega6 !mmcu=avrxmega7 !mtiny-stack;\",\n+  \"avr25 !mmcu=avr2 mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6 !mmcu=avrxmega2 !mmcu=avrxmega4 !mmcu=avrxmega5 !mmcu=avrxmega6 !mmcu=avrxmega7 !mtiny-stack;\",\n+  \"avr3 !mmcu=avr2 !mmcu=avr25 mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6 !mmcu=avrxmega2 !mmcu=avrxmega4 !mmcu=avrxmega5 !mmcu=avrxmega6 !mmcu=avrxmega7;\",\n+  \"avr31 !mmcu=avr2 !mmcu=avr25 !mmcu=avr3 mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6 !mmcu=avrxmega2 !mmcu=avrxmega4 !mmcu=avrxmega5 !mmcu=avrxmega6 !mmcu=avrxmega7;\",\n+  \"avr35 !mmcu=avr2 !mmcu=avr25 !mmcu=avr3 !mmcu=avr31 mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6 !mmcu=avrxmega2 !mmcu=avrxmega4 !mmcu=avrxmega5 !mmcu=avrxmega6 !mmcu=avrxmega7;\",\n+  \"avr4 !mmcu=avr2 !mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6 !mmcu=avrxmega2 !mmcu=avrxmega4 !mmcu=avrxmega5 !mmcu=avrxmega6 !mmcu=avrxmega7;\",\n+  \"avr5 !mmcu=avr2 !mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 mmcu=avr5 !mmcu=avr51 !mmcu=avr6 !mmcu=avrxmega2 !mmcu=avrxmega4 !mmcu=avrxmega5 !mmcu=avrxmega6 !mmcu=avrxmega7;\",\n+  \"avr51 !mmcu=avr2 !mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 mmcu=avr51 !mmcu=avr6 !mmcu=avrxmega2 !mmcu=avrxmega4 !mmcu=avrxmega5 !mmcu=avrxmega6 !mmcu=avrxmega7;\",\n+  \"avr6 !mmcu=avr2 !mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 mmcu=avr6 !mmcu=avrxmega2 !mmcu=avrxmega4 !mmcu=avrxmega5 !mmcu=avrxmega6 !mmcu=avrxmega7;\",\n+  \"avrxmega2 !mmcu=avr2 !mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6 mmcu=avrxmega2 !mmcu=avrxmega4 !mmcu=avrxmega5 !mmcu=avrxmega6 !mmcu=avrxmega7;\",\n+  \"avrxmega4 !mmcu=avr2 !mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6 !mmcu=avrxmega2 mmcu=avrxmega4 !mmcu=avrxmega5 !mmcu=avrxmega6 !mmcu=avrxmega7;\",\n+  \"avrxmega5 !mmcu=avr2 !mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6 !mmcu=avrxmega2 !mmcu=avrxmega4 mmcu=avrxmega5 !mmcu=avrxmega6 !mmcu=avrxmega7;\",\n+  \"avrxmega6 !mmcu=avr2 !mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6 !mmcu=avrxmega2 !mmcu=avrxmega4 !mmcu=avrxmega5 mmcu=avrxmega6 !mmcu=avrxmega7;\",\n+  \"avrxmega7 !mmcu=avr2 !mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6 !mmcu=avrxmega2 !mmcu=avrxmega4 !mmcu=avrxmega5 !mmcu=avrxmega6 mmcu=avrxmega7;\",\n+  \"tiny-stack !mmcu=avr2 !mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6 !mmcu=avrxmega2 !mmcu=avrxmega4 !mmcu=avrxmega5 !mmcu=avrxmega6 !mmcu=avrxmega7 mtiny-stack;\",\n+  \"avr2/tiny-stack mmcu=avr2 !mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6 !mmcu=avrxmega2 !mmcu=avrxmega4 !mmcu=avrxmega5 !mmcu=avrxmega6 !mmcu=avrxmega7 mtiny-stack;\",\n+  \"avr25/tiny-stack !mmcu=avr2 mmcu=avr25 !mmcu=avr3 !mmcu=avr31 !mmcu=avr35 !mmcu=avr4 !mmcu=avr5 !mmcu=avr51 !mmcu=avr6 !mmcu=avrxmega2 !mmcu=avrxmega4 !mmcu=avrxmega5 !mmcu=avrxmega6 !mmcu=avrxmega7 mtiny-stack;\",\n \n   NULL\n };"}, {"sha": "f6563c6751d206226c2beb0eeef7a386dd8d5395", "filename": "gcc/config/avr/predicates.md", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da8c1adcf5cefd0274f26077fadbfaeb0216344/gcc%2Fconfig%2Favr%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da8c1adcf5cefd0274f26077fadbfaeb0216344/gcc%2Fconfig%2Favr%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fpredicates.md?ref=2da8c1adcf5cefd0274f26077fadbfaeb0216344", "patch": "@@ -45,17 +45,20 @@\n ;; Return true if OP is a valid address for lower half of I/O space.\n (define_predicate \"low_io_address_operand\"\n   (and (match_code \"const_int\")\n-       (match_test \"IN_RANGE((INTVAL (op)), 0x20, 0x3F)\")))\n+       (match_test \"IN_RANGE (INTVAL (op) - avr_current_arch->sfr_offset,\n+                              0, 0x1f)\")))\n \n ;; Return true if OP is a valid address for high half of I/O space.\n (define_predicate \"high_io_address_operand\"\n   (and (match_code \"const_int\")\n-       (match_test \"IN_RANGE((INTVAL (op)), 0x40, 0x5F)\")))\n+       (match_test \"IN_RANGE (INTVAL (op) - avr_current_arch->sfr_offset,\n+                              0x20, 0x3F)\")))\n \n ;; Return true if OP is a valid address of I/O space.\n (define_predicate \"io_address_operand\"\n   (and (match_code \"const_int\")\n-       (match_test \"IN_RANGE((INTVAL (op)), 0x20, (0x60 - GET_MODE_SIZE(mode)))\")))\n+       (match_test \"IN_RANGE (INTVAL (op) - avr_current_arch->sfr_offset,\n+                              0, 0x40 - GET_MODE_SIZE (mode))\")))\n \n ;; Return 1 if OP is a general operand not in flash memory\n (define_predicate \"nop_general_operand\""}, {"sha": "886d5507c5cc40e3a7944c2475383a763ee7730f", "filename": "gcc/config/avr/t-multilib", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da8c1adcf5cefd0274f26077fadbfaeb0216344/gcc%2Fconfig%2Favr%2Ft-multilib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da8c1adcf5cefd0274f26077fadbfaeb0216344/gcc%2Fconfig%2Favr%2Ft-multilib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Ft-multilib?ref=2da8c1adcf5cefd0274f26077fadbfaeb0216344", "patch": "@@ -21,9 +21,9 @@\n # along with GCC; see the file COPYING3.  If not see\n # <http://www.gnu.org/licenses/>.\n \n-MULTILIB_OPTIONS = mmcu=avr2/mmcu=avr25/mmcu=avr3/mmcu=avr31/mmcu=avr35/mmcu=avr4/mmcu=avr5/mmcu=avr51/mmcu=avr6 mtiny-stack\n+MULTILIB_OPTIONS = mmcu=avr2/mmcu=avr25/mmcu=avr3/mmcu=avr31/mmcu=avr35/mmcu=avr4/mmcu=avr5/mmcu=avr51/mmcu=avr6/mmcu=avrxmega2/mmcu=avrxmega4/mmcu=avrxmega5/mmcu=avrxmega6/mmcu=avrxmega7 mtiny-stack\n \n-MULTILIB_DIRNAMES =  avr2 avr25 avr3 avr31 avr35 avr4 avr5 avr51 avr6 tiny-stack avr25/tiny-stack\n+MULTILIB_DIRNAMES =  avr2 avr25 avr3 avr31 avr35 avr4 avr5 avr51 avr6 avrxmega2 avrxmega4 avrxmega5 avrxmega6 avrxmega7 tiny-stack avr25/tiny-stack\n \n MULTILIB_EXCEPTIONS = \\\n \tmmcu=avr3/mtiny-stack \\\n@@ -32,7 +32,12 @@ MULTILIB_EXCEPTIONS = \\\n \tmmcu=avr4/mtiny-stack \\\n \tmmcu=avr5/mtiny-stack \\\n \tmmcu=avr51/mtiny-stack \\\n-\tmmcu=avr6/mtiny-stack\n+\tmmcu=avr6/mtiny-stack \\\n+\tmmcu=avrxmega2/mtiny-stack \\\n+\tmmcu=avrxmega4/mtiny-stack \\\n+\tmmcu=avrxmega5/mtiny-stack \\\n+\tmmcu=avrxmega6/mtiny-stack \\\n+\tmmcu=avrxmega7/mtiny-stack\n \n MULTILIB_MATCHES = \\\n \tmmcu?at90s2313=mmcu?at90s2313 \\\n@@ -189,4 +194,24 @@ MULTILIB_MATCHES = \\\n \tmmcu?avr51=mmcu?at90usb1286 \\\n \tmmcu?avr51=mmcu?at90usb1287 \\\n \tmmcu?avr6=mmcu?atmega2560 \\\n-\tmmcu?avr6=mmcu?atmega2561\n+\tmmcu?avr6=mmcu?atmega2561 \\\n+\tmmcu?avrxmega2=mmcu?atxmega16a4 \\\n+\tmmcu?avrxmega2=mmcu?atxmega16d4 \\\n+\tmmcu?avrxmega2=mmcu?atxmega16x1 \\\n+\tmmcu?avrxmega2=mmcu?atxmega32a4 \\\n+\tmmcu?avrxmega2=mmcu?atxmega32d4 \\\n+\tmmcu?avrxmega2=mmcu?atxmega32x1 \\\n+\tmmcu?avrxmega4=mmcu?atxmega64a3 \\\n+\tmmcu?avrxmega4=mmcu?atxmega64d3 \\\n+\tmmcu?avrxmega5=mmcu?atxmega64a1 \\\n+\tmmcu?avrxmega5=mmcu?atxmega64a1u \\\n+\tmmcu?avrxmega6=mmcu?atxmega128a3 \\\n+\tmmcu?avrxmega6=mmcu?atxmega128d3 \\\n+\tmmcu?avrxmega6=mmcu?atxmega192a3 \\\n+\tmmcu?avrxmega6=mmcu?atxmega192d3 \\\n+\tmmcu?avrxmega6=mmcu?atxmega256a3 \\\n+\tmmcu?avrxmega6=mmcu?atxmega256a3b \\\n+\tmmcu?avrxmega6=mmcu?atxmega256a3bu \\\n+\tmmcu?avrxmega6=mmcu?atxmega256d3 \\\n+\tmmcu?avrxmega7=mmcu?atxmega128a1 \\\n+\tmmcu?avrxmega7=mmcu?atxmega128a1u"}, {"sha": "8219423a064d99a8ef10fd3fafd6a0cd154b2abf", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da8c1adcf5cefd0274f26077fadbfaeb0216344/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da8c1adcf5cefd0274f26077fadbfaeb0216344/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=2da8c1adcf5cefd0274f26077fadbfaeb0216344", "patch": "@@ -1,3 +1,11 @@\n+2012-01-15  Georg-Johann Lay  <avr@gjlay.de>\n+\t    Anatoly Sokolov <aesok@post.ru>\n+\t    Eric Weddington <eric.weddington@atmel.com>\n+\n+\tPR target/52261\n+\t* config/avr/lib1funcs.S (__prologue_saves__): Handle AVR_XMEGA\n+\t(__epilogue_restores__): Ditto.\n+\n 2012-02-15  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR target/51921"}, {"sha": "eba0486452be5182d11f1a3c601edbeb4c8698f6", "filename": "libgcc/config/avr/lib1funcs.S", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da8c1adcf5cefd0274f26077fadbfaeb0216344/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da8c1adcf5cefd0274f26077fadbfaeb0216344/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flib1funcs.S?ref=2da8c1adcf5cefd0274f26077fadbfaeb0216344", "patch": "@@ -1696,6 +1696,13 @@ DEFUN __prologue_saves__\n \tsub\tr28,r26\n \tout\t__SP_L__,r28\n \tclr\tr29\n+#elif defined (__AVR__XMEGA__)\n+\tin\tr28,__SP_L__\n+\tin\tr29,__SP_H__\n+\tsub\tr28,r26\n+\tsbc\tr29,r27\n+\tout\t__SP_L__,r28\n+\tout\t__SP_H__,r29\n #else\n \tin\tr28,__SP_L__\n \tin\tr29,__SP_H__\n@@ -1745,6 +1752,13 @@ DEFUN __epilogue_restores__\n \tadd\tr28,r30\n \tout\t__SP_L__,r28\n \tmov\tr28, r26\n+#elif defined (__AVR__XMEGA__)\n+\tldd  r27,Y+1\n+\tadd  r28,r30\n+\tadc  r29,__zero_reg__\n+\tout  __SP_L__,r28\n+\tout  __SP_H__,r29\n+\twmov 28, 26\n #else\n \tldd\tr27,Y+1\n \tadd\tr28,r30"}]}