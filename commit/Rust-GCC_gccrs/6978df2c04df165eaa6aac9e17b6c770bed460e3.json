{"sha": "6978df2c04df165eaa6aac9e17b6c770bed460e3", "node_id": "C_kwDOANBUbNoAKDY5NzhkZjJjMDRkZjE2NWVhYTZhYWM5ZTE3YjZjNzcwYmVkNDYwZTM", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-03-02T23:34:59Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-03-02T23:34:59Z"}, "message": "c++, v3: Emit fundamental tinfos for _Float16/decltype(0.0bf16) types on ia32 with -mno-sse2 [PR108883]\n\n_Float16 and decltype(0.0bf16) types are on x86 supported only with\n-msse2.  On x86_64 that is the default, but on ia32 it is not.\nWe should still emit fundamental type tinfo for those types in\nlibsupc++.a/libstdc++.*, regardless of whether libsupc++/libstdc++\nis compiled with -msse2 or not, as user programs can be compiled\nwith different ISA flags from libsupc++/libstdc++ and if they\nare compiled with -msse2 and use std::float16_t or std::bfloat16_t\nand need RTTI for it, it should work out of the box.  Furthermore,\nlibstdc++ ABI on ia32 shouldn't depend on whether the library\nis compiled with -mno-sse or -msse2.\n\nUnfortunately, just hacking up libsupc++ Makefile/configure so that\na single source is compiled with -msse2 isn't appropriate, because\nthat TU emits also code and the code should be able to run on CPUs\nwhich libstdc++ supports.  We could add [[gnu::attribute (\"no-sse2\")]]\nthere perhaps conditionally, but it all gets quite ugly.\n\nThe following patch instead adds a target hook which allows the backend\nto temporarily tweak registered types such that emit_support_tinfos\nemits whatever is needed.\n\nAdditionally, it makes emit_support_tinfos_1 call emit_tinfo_decl\nimmediately, so that temporarily created dummy types for emit_support_tinfo\npurposes only can be nullified again afterwards.  And removes the\nprevious fallback_* types used for dfloat*_type_node tinfos even when\ndecimal types aren't supported.\n\n2023-03-03  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR target/108883\ngcc/\n\t* target.h (emit_support_tinfos_callback): New typedef.\n\t* targhooks.h (default_emit_support_tinfos): Declare.\n\t* targhooks.cc (default_emit_support_tinfos): New function.\n\t* target.def (emit_support_tinfos): New target hook.\n\t* doc/tm.texi.in (emit_support_tinfos): Document it.\n\t* doc/tm.texi: Regenerated.\n\t* config/i386/i386.cc (ix86_emit_support_tinfos): New function.\n\t(TARGET_EMIT_SUPPORT_TINFOS): Redefine.\ngcc/cp/\n\t* cp-tree.h (enum cp_tree_index): Remove CPTI_FALLBACK_DFLOAT*_TYPE\n\tenumerators.\n\t(fallback_dfloat32_type, fallback_dfloat64_type,\n\tfallback_dfloat128_type): Remove.\n\t* rtti.cc (emit_support_tinfo_1): If not emitted already, call\n\temit_tinfo_decl and remove from unemitted_tinfo_decls right away.\n\t(emit_support_tinfos): Move &dfloat*_type_node from fundamentals array\n\tinto new fundamentals_with_fallback array.  Call emit_support_tinfo_1\n\ton elements of that array too, with the difference that if\n\tthe type is NULL, use a fallback REAL_TYPE for it temporarily.\n\tDrop the !targetm.decimal_float_supported_p () handling.  Call\n\ttargetm.emit_support_tinfos at the end.\n\t* mangle.cc (write_builtin_type): Remove references to\n\tfallback_dfloat*_type.  Handle bfloat16_type_node mangling.", "tree": {"sha": "c143c41db97e91f6581b9f37a6f0eb83a6cb5842", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c143c41db97e91f6581b9f37a6f0eb83a6cb5842"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6978df2c04df165eaa6aac9e17b6c770bed460e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6978df2c04df165eaa6aac9e17b6c770bed460e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6978df2c04df165eaa6aac9e17b6c770bed460e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6978df2c04df165eaa6aac9e17b6c770bed460e3/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b432c0f777ab9b8436fb07f71de6ea4d259b869", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b432c0f777ab9b8436fb07f71de6ea4d259b869", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b432c0f777ab9b8436fb07f71de6ea4d259b869"}], "stats": {"total": 123, "additions": 94, "deletions": 29}, "files": [{"sha": "5d0e4739a84593519b3efaa3157b73467a9b97f7", "filename": "gcc/config/i386/i386.cc", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6978df2c04df165eaa6aac9e17b6c770bed460e3/gcc%2Fconfig%2Fi386%2Fi386.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6978df2c04df165eaa6aac9e17b6c770bed460e3/gcc%2Fconfig%2Fi386%2Fi386.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.cc?ref=6978df2c04df165eaa6aac9e17b6c770bed460e3", "patch": "@@ -22775,6 +22775,27 @@ ix86_mangle_type (const_tree type)\n     }\n }\n \n+/* Create C++ tinfo symbols for only conditionally available fundamental\n+   types.  */\n+\n+static void\n+ix86_emit_support_tinfos (emit_support_tinfos_callback callback)\n+{\n+  extern tree ix86_float16_type_node;\n+  extern tree ix86_bf16_type_node;\n+\n+  if (!TARGET_SSE2)\n+    {\n+      gcc_checking_assert (!float16_type_node && !bfloat16_type_node);\n+      float16_type_node = ix86_float16_type_node;\n+      bfloat16_type_node = ix86_bf16_type_node;\n+      callback (float16_type_node);\n+      callback (bfloat16_type_node);\n+      float16_type_node = NULL_TREE;\n+      bfloat16_type_node = NULL_TREE;\n+    }\n+}\n+\n static GTY(()) tree ix86_tls_stack_chk_guard_decl;\n \n static tree\n@@ -24954,6 +24975,9 @@ ix86_libgcc_floating_mode_supported_p\n #undef TARGET_MANGLE_TYPE\n #define TARGET_MANGLE_TYPE ix86_mangle_type\n \n+#undef TARGET_EMIT_SUPPORT_TINFOS\n+#define TARGET_EMIT_SUPPORT_TINFOS ix86_emit_support_tinfos\n+\n #undef TARGET_STACK_PROTECT_GUARD\n #define TARGET_STACK_PROTECT_GUARD ix86_stack_protect_guard\n "}, {"sha": "fb21c064141922182b6cbd74007819d8677c7f98", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6978df2c04df165eaa6aac9e17b6c770bed460e3/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6978df2c04df165eaa6aac9e17b6c770bed460e3/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6978df2c04df165eaa6aac9e17b6c770bed460e3", "patch": "@@ -235,10 +235,6 @@ enum cp_tree_index\n \n     CPTI_PSEUDO_CONTRACT_VIOLATION,\n \n-    CPTI_FALLBACK_DFLOAT32_TYPE,\n-    CPTI_FALLBACK_DFLOAT64_TYPE,\n-    CPTI_FALLBACK_DFLOAT128_TYPE,\n-\n     CPTI_MAX\n };\n \n@@ -397,13 +393,6 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n    access nodes in tree.h.  */\n \n #define access_default_node\t\tnull_node\n-\n-/* Variant of dfloat{32,64,128}_type_node only used for fundamental\n-   rtti purposes if DFP is disabled.  */\n-#define fallback_dfloat32_type\t\tcp_global_trees[CPTI_FALLBACK_DFLOAT32_TYPE]\n-#define fallback_dfloat64_type\t\tcp_global_trees[CPTI_FALLBACK_DFLOAT64_TYPE]\n-#define fallback_dfloat128_type\t\tcp_global_trees[CPTI_FALLBACK_DFLOAT128_TYPE]\n-\n \f\n #include \"name-lookup.h\"\n "}, {"sha": "242b3f31cba0ade59736100446f0a23d87e4ef60", "filename": "gcc/cp/mangle.cc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6978df2c04df165eaa6aac9e17b6c770bed460e3/gcc%2Fcp%2Fmangle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6978df2c04df165eaa6aac9e17b6c770bed460e3/gcc%2Fcp%2Fmangle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.cc?ref=6978df2c04df165eaa6aac9e17b6c770bed460e3", "patch": "@@ -2732,11 +2732,11 @@ write_builtin_type (tree type)\n \twrite_char ('d');\n       else if (type == long_double_type_node)\n \twrite_char ('e');\n-      else if (type == dfloat32_type_node || type == fallback_dfloat32_type)\n+      else if (type == dfloat32_type_node)\n \twrite_string (\"Df\");\n-      else if (type == dfloat64_type_node || type == fallback_dfloat64_type)\n+      else if (type == dfloat64_type_node)\n \twrite_string (\"Dd\");\n-      else if (type == dfloat128_type_node || type == fallback_dfloat128_type)\n+      else if (type == dfloat128_type_node)\n \twrite_string (\"De\");\n       else if (type == float16_type_node)\n \twrite_string (\"DF16_\");\n@@ -2752,6 +2752,8 @@ write_builtin_type (tree type)\n \twrite_string (\"DF64x\");\n       else if (type == float128x_type_node)\n \twrite_string (\"DF128x\");\n+      else if (type == bfloat16_type_node)\n+\twrite_string (\"DF16b\");\n       else\n \tgcc_unreachable ();\n       break;"}, {"sha": "2a253a438616312bc1fdc407a167460cd008ec70", "filename": "gcc/cp/rtti.cc", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6978df2c04df165eaa6aac9e17b6c770bed460e3/gcc%2Fcp%2Frtti.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6978df2c04df165eaa6aac9e17b6c770bed460e3/gcc%2Fcp%2Frtti.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.cc?ref=6978df2c04df165eaa6aac9e17b6c770bed460e3", "patch": "@@ -1577,6 +1577,15 @@ emit_support_tinfo_1 (tree bltn)\n \t  gcc_assert (TREE_PUBLIC (tinfo) && !DECL_COMDAT (tinfo));\n \t  DECL_INTERFACE_KNOWN (tinfo) = 1;\n \t}\n+\n+      /* Emit it right away if not emitted already.  */\n+      if (DECL_INITIAL (tinfo) == NULL_TREE)\n+\t{\n+\t  gcc_assert (unemitted_tinfo_decls->last () == tinfo);\n+\t  bool ok = emit_tinfo_decl (tinfo);\n+\t  gcc_assert (ok);\n+\t  unemitted_tinfo_decls->pop ();\n+\t}\n     }\n }\n \n@@ -1602,12 +1611,18 @@ emit_support_tinfos (void)\n     &long_integer_type_node, &long_unsigned_type_node,\n     &long_long_integer_type_node, &long_long_unsigned_type_node,\n     &float_type_node, &double_type_node, &long_double_type_node,\n-    &dfloat32_type_node, &dfloat64_type_node, &dfloat128_type_node,\n     &bfloat16_type_node, &float16_type_node, &float32_type_node,\n     &float64_type_node, &float128_type_node, &float32x_type_node,\n     &float64x_type_node, &float128x_type_node, &nullptr_type_node,\n     0\n   };\n+  /* Similar, but for floating point types only which should get type info\n+     regardless whether they are non-NULL or NULL.  */\n+  static tree *const fundamentals_with_fallback[] =\n+  {\n+    &dfloat32_type_node, &dfloat64_type_node, &dfloat128_type_node,\n+    0\n+  };\n   int ix;\n \n   /* Look for a defined class.  */\n@@ -1627,8 +1642,20 @@ emit_support_tinfos (void)\n   location_t saved_loc = input_location;\n   input_location = BUILTINS_LOCATION;\n   doing_runtime = 1;\n+  tree fallback = NULL_TREE;\n   for (ix = 0; fundamentals[ix]; ix++)\n     emit_support_tinfo_1 (*fundamentals[ix]);\n+  for (ix = 0; fundamentals_with_fallback[ix]; ix++)\n+    if (*fundamentals_with_fallback[ix])\n+      emit_support_tinfo_1 (*fundamentals_with_fallback[ix]);\n+    else\n+      {\n+\tif (fallback == NULL_TREE)\n+\t  fallback = make_node (REAL_TYPE);\n+\t*fundamentals_with_fallback[ix] = fallback;\n+\temit_support_tinfo_1 (fallback);\n+\t*fundamentals_with_fallback[ix] = NULL_TREE;\n+      }\n   for (ix = 0; ix < NUM_INT_N_ENTS; ix ++)\n     if (int_n_enabled_p[ix])\n       {\n@@ -1637,20 +1664,10 @@ emit_support_tinfos (void)\n       }\n   for (tree t = registered_builtin_types; t; t = TREE_CHAIN (t))\n     emit_support_tinfo_1 (TREE_VALUE (t));\n-  /* For compatibility, emit DFP typeinfos even when DFP isn't enabled,\n-     because we've emitted that in the past.  */\n-  if (!targetm.decimal_float_supported_p ())\n-    {\n-      gcc_assert (dfloat32_type_node == NULL_TREE\n-\t\t  && dfloat64_type_node == NULL_TREE\n-\t\t  && dfloat128_type_node == NULL_TREE);\n-      fallback_dfloat32_type = make_node (REAL_TYPE);\n-      fallback_dfloat64_type = make_node (REAL_TYPE);\n-      fallback_dfloat128_type = make_node (REAL_TYPE);\n-      emit_support_tinfo_1 (fallback_dfloat32_type);\n-      emit_support_tinfo_1 (fallback_dfloat64_type);\n-      emit_support_tinfo_1 (fallback_dfloat128_type);\n-    }\n+\n+  /* Emit additional typeinfos as requested by target.  */\n+  targetm.emit_support_tinfos (emit_support_tinfo_1);\n+\n   input_location = saved_loc;\n }\n "}, {"sha": "ec90c46ea2ffd80d5c56dcd0458f9b901c5e627f", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6978df2c04df165eaa6aac9e17b6c770bed460e3/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6978df2c04df165eaa6aac9e17b6c770bed460e3/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=6978df2c04df165eaa6aac9e17b6c770bed460e3", "patch": "@@ -1525,6 +1525,15 @@ appropriate for a target that does not define any new fundamental\n types.\n @end deftypefn\n \n+@deftypefn {Target Hook} void TARGET_EMIT_SUPPORT_TINFOS (emit_support_tinfos_callback @var{callback})\n+If your target defines any fundamental types which depend on ISA flags,\n+they might need C++ tinfo symbols in libsupc++/libstdc++ regardless of\n+ISA flags the library is compiled with.\n+This hook allows creating tinfo symbols even for those cases, by temporarily\n+creating each corresponding fundamental type trees, calling the\n+@var{callback} function on it and setting the type back to @code{nullptr}.\n+@end deftypefn\n+\n @node Type Layout\n @section Layout of Source Language Data Types\n "}, {"sha": "930b109863f236e42dff0924244154bb35ba9667", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6978df2c04df165eaa6aac9e17b6c770bed460e3/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6978df2c04df165eaa6aac9e17b6c770bed460e3/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=6978df2c04df165eaa6aac9e17b6c770bed460e3", "patch": "@@ -1286,6 +1286,8 @@ pattern needs to support both a 32- and a 64-bit mode.\n \n @hook TARGET_MANGLE_TYPE\n \n+@hook TARGET_EMIT_SUPPORT_TINFOS\n+\n @node Type Layout\n @section Layout of Source Language Data Types\n "}, {"sha": "4b2c53aba14e65e469c613a8cc30baed8ce439d7", "filename": "gcc/target.def", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6978df2c04df165eaa6aac9e17b6c770bed460e3/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6978df2c04df165eaa6aac9e17b6c770bed460e3/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=6978df2c04df165eaa6aac9e17b6c770bed460e3", "patch": "@@ -2606,6 +2606,19 @@ types.\",\n  const char *, (const_tree type),\n  hook_constcharptr_const_tree_null)\n \n+/* Temporarily add conditional target specific types for the purpose of\n+   emitting C++ fundamental type tinfos.  */\n+DEFHOOK\n+(emit_support_tinfos,\n+ \"If your target defines any fundamental types which depend on ISA flags,\\n\\\n+they might need C++ tinfo symbols in libsupc++/libstdc++ regardless of\\n\\\n+ISA flags the library is compiled with.\\n\\\n+This hook allows creating tinfo symbols even for those cases, by temporarily\\n\\\n+creating each corresponding fundamental type trees, calling the\\n\\\n+@var{callback} function on it and setting the type back to @code{nullptr}.\",\n+ void, (emit_support_tinfos_callback callback),\n+ default_emit_support_tinfos)\n+\n /* Make any adjustments to libfunc names needed for this target.  */\n DEFHOOK\n (init_libfuncs,"}, {"sha": "39de522602613fcfa44b613c3feafa851adf969b", "filename": "gcc/target.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6978df2c04df165eaa6aac9e17b6c770bed460e3/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6978df2c04df165eaa6aac9e17b6c770bed460e3/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=6978df2c04df165eaa6aac9e17b6c770bed460e3", "patch": "@@ -260,6 +260,8 @@ enum poly_value_estimate_kind\n   POLY_VALUE_LIKELY\n };\n \n+typedef void (*emit_support_tinfos_callback) (tree);\n+\n extern bool verify_type_context (location_t, type_context_kind, const_tree,\n \t\t\t\t bool = false);\n "}, {"sha": "ea1a17cb1ab4acc1a142bfc0b9b9db876e3da349", "filename": "gcc/targhooks.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6978df2c04df165eaa6aac9e17b6c770bed460e3/gcc%2Ftarghooks.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6978df2c04df165eaa6aac9e17b6c770bed460e3/gcc%2Ftarghooks.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.cc?ref=6978df2c04df165eaa6aac9e17b6c770bed460e3", "patch": "@@ -752,6 +752,11 @@ default_builtin_reciprocal (tree)\n   return NULL_TREE;\n }\n \n+void\n+default_emit_support_tinfos (emit_support_tinfos_callback)\n+{\n+}\n+\n bool\n hook_bool_CUMULATIVE_ARGS_arg_info_false (cumulative_args_t,\n \t\t\t\t\t  const function_arg_info &)"}, {"sha": "8725f1bb7d6b8c0b85f83eb1b48ba87675847127", "filename": "gcc/targhooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6978df2c04df165eaa6aac9e17b6c770bed460e3/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6978df2c04df165eaa6aac9e17b6c770bed460e3/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=6978df2c04df165eaa6aac9e17b6c770bed460e3", "patch": "@@ -98,6 +98,8 @@ extern int default_builtin_vectorization_cost (enum vect_cost_for_stmt, tree, in\n \n extern tree default_builtin_reciprocal (tree);\n \n+extern void default_emit_support_tinfos (emit_support_tinfos_callback);\n+\n extern HOST_WIDE_INT default_static_rtx_alignment (machine_mode);\n extern HOST_WIDE_INT default_constant_alignment (const_tree, HOST_WIDE_INT);\n extern HOST_WIDE_INT constant_alignment_word_strings (const_tree,"}]}