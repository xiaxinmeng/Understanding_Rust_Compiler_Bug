{"sha": "3b2d8145a4c349058d76ce299ea7eea605572004", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2IyZDgxNDVhNGMzNDkwNThkNzZjZTI5OWVhN2VlYTYwNTU3MjAwNA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-12-22T05:20:59Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-12-22T20:13:13Z"}, "message": "runtime: add \"success\" field to sudog\n\nThis is the gofrontend version of https://golang.org/cl/245019.\nOriginal CL description:\n\n    The current wakeup protocol for channel communications is that the\n    second goroutine sets gp.param to the sudog when a value is\n    successfully communicated over the channel, and to nil when the wakeup\n    is due to closing the channel.\n\n    Setting nil to indicate channel closure works okay for chansend and\n    chanrecv, because they're only communicating with one channel, so they\n    know it must be the channel that was closed. However, it means\n    selectgo has to re-poll all of the channels to figure out which one\n    was closed.\n\n    This commit adds a \"success\" field to sudog, and changes the wakeup\n    protocol to always set gp.param to sg, and to use sg.success to\n    indicate successful communication vs channel closure.\n\n    While here, this also reorganizes the chansend code slightly so that\n    the sudog is still released to the pool if the send blocks and then is\n    awoken because the channel closed.\n\n    For golang/go#40410\n\nThis is being brought over to gofrontend as a step toward upgrading to\nGo1.16beta1, setting up for more compiler changes related to select handling.\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/279734", "tree": {"sha": "004c66f4f6990bed01d4afe6ecac2727f38a5aaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/004c66f4f6990bed01d4afe6ecac2727f38a5aaa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b2d8145a4c349058d76ce299ea7eea605572004", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b2d8145a4c349058d76ce299ea7eea605572004", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b2d8145a4c349058d76ce299ea7eea605572004", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b2d8145a4c349058d76ce299ea7eea605572004/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48357ce4f22c8298ea5fb01d6873bc7bf56180e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48357ce4f22c8298ea5fb01d6873bc7bf56180e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48357ce4f22c8298ea5fb01d6873bc7bf56180e5"}], "stats": {"total": 52, "additions": 29, "deletions": 23}, "files": [{"sha": "bb537f152b9c0f81d45d2d0afd037d2421b0d4c3", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2d8145a4c349058d76ce299ea7eea605572004/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2d8145a4c349058d76ce299ea7eea605572004/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=3b2d8145a4c349058d76ce299ea7eea605572004", "patch": "@@ -1,4 +1,4 @@\n-d0e56e82bb298268ec0f306fef99a715c892d4a7\n+eca96e39cb895805b617e0e1f184f893ed3e46bb\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "1b20aff6ea3490c242aebd1df965232719434c92", "filename": "libgo/go/runtime/chan.go", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2d8145a4c349058d76ce299ea7eea605572004/libgo%2Fgo%2Fruntime%2Fchan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2d8145a4c349058d76ce299ea7eea605572004/libgo%2Fgo%2Fruntime%2Fchan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fchan.go?ref=3b2d8145a4c349058d76ce299ea7eea605572004", "patch": "@@ -285,18 +285,19 @@ func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {\n \t}\n \tgp.waiting = nil\n \tgp.activeStackChans = false\n-\tif gp.param == nil {\n-\t\tif c.closed == 0 {\n-\t\t\tthrow(\"chansend: spurious wakeup\")\n-\t\t}\n-\t\tpanic(plainError(\"send on closed channel\"))\n-\t}\n+\tclosed := !mysg.success\n \tgp.param = nil\n \tif mysg.releasetime > 0 {\n \t\tblockevent(mysg.releasetime-t0, 2)\n \t}\n \tmysg.c = nil\n \treleaseSudog(mysg)\n+\tif closed {\n+\t\tif c.closed == 0 {\n+\t\t\tthrow(\"chansend: spurious wakeup\")\n+\t\t}\n+\t\tpanic(plainError(\"send on closed channel\"))\n+\t}\n \treturn true\n }\n \n@@ -333,6 +334,7 @@ func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {\n \tgp := sg.g\n \tunlockf()\n \tgp.param = unsafe.Pointer(sg)\n+\tsg.success = true\n \tif sg.releasetime != 0 {\n \t\tsg.releasetime = cputicks()\n \t}\n@@ -406,7 +408,8 @@ func closechan(c *hchan) {\n \t\t\tsg.releasetime = cputicks()\n \t\t}\n \t\tgp := sg.g\n-\t\tgp.param = nil\n+\t\tgp.param = unsafe.Pointer(sg)\n+\t\tsg.success = false\n \t\tif raceenabled {\n \t\t\traceacquireg(gp, c.raceaddr())\n \t\t}\n@@ -424,7 +427,8 @@ func closechan(c *hchan) {\n \t\t\tsg.releasetime = cputicks()\n \t\t}\n \t\tgp := sg.g\n-\t\tgp.param = nil\n+\t\tgp.param = unsafe.Pointer(sg)\n+\t\tsg.success = false\n \t\tif raceenabled {\n \t\t\traceacquireg(gp, c.raceaddr())\n \t\t}\n@@ -607,11 +611,11 @@ func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool)\n \tif mysg.releasetime > 0 {\n \t\tblockevent(mysg.releasetime-t0, 2)\n \t}\n-\tclosed := gp.param == nil\n+\tsuccess := mysg.success\n \tgp.param = nil\n \tmysg.c = nil\n \treleaseSudog(mysg)\n-\treturn true, !closed\n+\treturn true, success\n }\n \n // recv processes a receive operation on a full channel c.\n@@ -664,6 +668,7 @@ func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {\n \tgp := sg.g\n \tunlockf()\n \tgp.param = unsafe.Pointer(sg)\n+\tsg.success = true\n \tif sg.releasetime != 0 {\n \t\tsg.releasetime = cputicks()\n \t}"}, {"sha": "f30d1bcde6e1fe032d49246cb9e24c3f263652d4", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2d8145a4c349058d76ce299ea7eea605572004/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2d8145a4c349058d76ce299ea7eea605572004/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=3b2d8145a4c349058d76ce299ea7eea605572004", "patch": "@@ -354,6 +354,12 @@ type sudog struct {\n \t// g.selectDone must be CAS'd to win the wake-up race.\n \tisSelect bool\n \n+\t// success indicates whether communication over channel c\n+\t// succeeded. It is true if the goroutine was awoken because a\n+\t// value was delivered over channel c, and false if awoken\n+\t// because c was closed.\n+\tsuccess bool\n+\n \tparent   *sudog // semaRoot binary tree\n \twaitlink *sudog // g.waiting list or semaRoot\n \twaittail *sudog // semaRoot"}, {"sha": "c31aa344b552f1e39d29fc83e580cf49907e64e1", "filename": "libgo/go/runtime/select.go", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2d8145a4c349058d76ce299ea7eea605572004/libgo%2Fgo%2Fruntime%2Fselect.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2d8145a4c349058d76ce299ea7eea605572004/libgo%2Fgo%2Fruntime%2Fselect.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fselect.go?ref=3b2d8145a4c349058d76ce299ea7eea605572004", "patch": "@@ -235,10 +235,10 @@ func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool) {\n \t\tnextp  **sudog\n \t)\n \n-loop:\n \t// pass 1 - look for something already waiting\n \tvar casi int\n \tvar cas *scase\n+\tvar caseSuccess bool\n \tvar caseReleaseTime int64 = -1\n \tvar recvOK bool\n \tfor _, casei := range pollorder {\n@@ -335,6 +335,7 @@ loop:\n \t// We singly-linked up the SudoGs in lock order.\n \tcasi = -1\n \tcas = nil\n+\tcaseSuccess = false\n \tsglist = gp.waiting\n \t// Clear all elem before unlinking from gp.waiting.\n \tfor sg1 := gp.waiting; sg1 != nil; sg1 = sg1.waitlink {\n@@ -350,6 +351,7 @@ loop:\n \t\t\t// sg has already been dequeued by the G that woke us up.\n \t\t\tcasi = int(casei)\n \t\t\tcas = k\n+\t\t\tcaseSuccess = sglist.success\n \t\t\tif sglist.releasetime > 0 {\n \t\t\t\tcaseReleaseTime = sglist.releasetime\n \t\t\t}\n@@ -368,16 +370,7 @@ loop:\n \t}\n \n \tif cas == nil {\n-\t\t// We can wake up with gp.param == nil (so cas == nil)\n-\t\t// when a channel involved in the select has been closed.\n-\t\t// It is easiest to loop and re-run the operation;\n-\t\t// we'll see that it's now closed.\n-\t\t// Maybe some day we can signal the close explicitly,\n-\t\t// but we'd have to distinguish close-on-reader from close-on-writer.\n-\t\t// It's easiest not to duplicate the code and just recheck above.\n-\t\t// We know that something closed, and things never un-close,\n-\t\t// so we won't block again.\n-\t\tgoto loop\n+\t\tthrow(\"selectgo: bad wakeup\")\n \t}\n \n \tc = cas.c\n@@ -387,7 +380,9 @@ loop:\n \t}\n \n \tif cas.kind == caseRecv {\n-\t\trecvOK = true\n+\t\trecvOK = caseSuccess\n+\t} else if cas.kind == caseSend && !caseSuccess {\n+\t\tgoto sclose\n \t}\n \n \tselunlock(scases, lockorder)"}]}