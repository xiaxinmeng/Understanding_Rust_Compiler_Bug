{"sha": "1ff7789b515733ab51c8c6686d1bcfcbf681b94b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZmNzc4OWI1MTU3MzNhYjUxYzhjNjY4NmQxYmNmY2JmNjgxYjk0Yg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1996-07-11T22:36:45Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1996-07-11T22:36:45Z"}, "message": "Deal with -fpic and inlined functions\n\nFrom-SVN: r12428", "tree": {"sha": "05c040cb5bca6a449057c5f2ba09582c1666f2da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05c040cb5bca6a449057c5f2ba09582c1666f2da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ff7789b515733ab51c8c6686d1bcfcbf681b94b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ff7789b515733ab51c8c6686d1bcfcbf681b94b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ff7789b515733ab51c8c6686d1bcfcbf681b94b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ff7789b515733ab51c8c6686d1bcfcbf681b94b/comments", "author": null, "committer": null, "parents": [{"sha": "c05330a92385c577fc5a56a48c666663e4b55132", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c05330a92385c577fc5a56a48c666663e4b55132", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c05330a92385c577fc5a56a48c666663e4b55132"}], "stats": {"total": 133, "additions": 109, "deletions": 24}, "files": [{"sha": "536e1e404dd167744fa50fdcc31a4890dd20aade", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 102, "deletions": 23, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff7789b515733ab51c8c6686d1bcfcbf681b94b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff7789b515733ab51c8c6686d1bcfcbf681b94b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=1ff7789b515733ab51c8c6686d1bcfcbf681b94b", "patch": "@@ -372,24 +372,6 @@ rs6000_immed_double_const (i0, i1, mode)\n   return immed_double_const (i0, i1, mode);\n }\n \n-\f\n-/* Return the GOT register, creating it if needed.  */\n-\n-struct rtx_def *\n-rs6000_got_register (value)\n-     rtx value;\n-{\n-  if (!pic_offset_table_rtx)\n-    {\n-      if (reload_in_progress || reload_completed)\n-\tfatal_insn (\"internal error -- needed new GOT register during reload phase to load:\", value);\n-\n-      pic_offset_table_rtx = gen_reg_rtx (SImode);\n-    }\n-\n-  return pic_offset_table_rtx;\n-}\n-\n \f\n /* Return non-zero if this function is known to have a null epilogue.  */\n \n@@ -2077,6 +2059,81 @@ ccr_bit (op, scc_p)\n       abort ();\n     }\n }\n+\f\n+/* Return the GOT register, creating it if needed.  */\n+\n+struct rtx_def *\n+rs6000_got_register (value)\n+     rtx value;\n+{\n+  if (!pic_offset_table_rtx)\n+    {\n+      if (reload_in_progress || reload_completed)\n+\tfatal_insn (\"internal error -- needed new GOT register during reload phase to load:\", value);\n+\n+      current_function_uses_pic_offset_table = 1;\n+      pic_offset_table_rtx = gen_rtx (REG, Pmode, GOT_TOC_REGNUM);\n+    }\n+\n+  return pic_offset_table_rtx;\n+}\n+\n+\f\n+/* Replace all occurances of register FROM with an new pseduo register in an insn X.\n+   Store the pseudo register used in REG.\n+   This is only safe during FINALIZE_PIC, since the registers haven't been setup\n+   yet.  */\n+\n+static rtx\n+rs6000_replace_regno (x, from, reg)\n+     rtx x;\n+     int from;\n+     rtx *reg;\n+{\n+  register int i, j;\n+  register char *fmt;\n+\n+  /* Allow this function to make replacements in EXPR_LISTs.  */\n+  if (!x)\n+    return x;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case SCRATCH:\n+    case PC:\n+    case CC0:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return x;\n+\n+    case REG:\n+      if (REGNO (x) == from)\n+\t{\n+\t  if (! *reg)\n+\t    *reg = gen_reg_rtx (Pmode);\n+\n+\t  return *reg;\n+\t}\n+\n+      return x;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (x));\n+  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\tXEXP (x, i) = rs6000_replace_regno (XEXP (x, i), from, reg);\n+      else if (fmt[i] == 'E')\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  XVECEXP (x, i, j) = rs6000_replace_regno (XVECEXP (x, i, j), from, reg);\n+    }\n+\n+  return x;\n+}  \n+\n \f\n /* By generating position-independent code, when two different\n    programs (A and B) share a common library (libC.a), the text of\n@@ -2098,17 +2155,39 @@ rs6000_finalize_pic ()\n {\n   if (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n     {\n-      /* If a PIC register has been created, insert the pic initialization\n-\t at the function beginning.  */\n-      if (pic_offset_table_rtx)\n+      /* Loop through all of the insns, replacing the special GOT_TOC_REGNUM\n+\t with an appropriate pseduo register.  If we find we need GOT/TOC,\n+\t add the appropriate init code.  */\n+      if (flag_pic)\n \t{\n \t  rtx insn = get_insns ();\n-\t  rtx init = gen_init_v4_pic (pic_offset_table_rtx);\n+\t  rtx reg = NULL_RTX;\n+\t  rtx first_insn;\n \n \t  if (GET_CODE (insn) == NOTE)\n \t    insn = next_nonnote_insn (insn);\n \n-\t  emit_insn_before (init, insn);\n+\t  first_insn = insn;\n+\t  for ( ; insn != NULL_RTX; insn = NEXT_INSN (insn))\n+\t    {\n+\t      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t\t{\n+\t\t  PATTERN (insn) = rs6000_replace_regno (PATTERN (insn),\n+\t\t\t\t\t\t\t GOT_TOC_REGNUM,\n+\t\t\t\t\t\t\t &reg);\n+\n+\t\t  if (REG_NOTES (insn))\n+\t\t    REG_NOTES (insn) = rs6000_replace_regno (REG_NOTES (insn),\n+\t\t\t\t\t\t\t     GOT_TOC_REGNUM,\n+\t\t\t\t\t\t\t     &reg);\n+\t\t}\n+\t    }\n+\n+\t  if (reg)\n+\t    {\n+\t      rtx init = gen_init_v4_pic (reg);\n+\t      emit_insn_before (init, first_insn);\n+\t    }\n \t}\n     }\n }"}, {"sha": "58632eb9b3460369add533ec807fd238e1d4690f", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff7789b515733ab51c8c6686d1bcfcbf681b94b/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff7789b515733ab51c8c6686d1bcfcbf681b94b/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=1ff7789b515733ab51c8c6686d1bcfcbf681b94b", "patch": "@@ -847,10 +847,16 @@ extern struct rs6000_cpu_select rs6000_select[];\n /* Special register that represents memory, used for float/int conversions.  */\n #define FPMEM_REGNUM 76\n \n+/* Register to use as a placeholder for the GOT/allocated TOC register.\n+   FINALIZE_PIC will change all uses of this register to a an appropriate\n+   pseudo register when it adds the code to setup the GOT.  We use r2\n+   because it is a reserved register in all of the ABI's.  */\n+#define GOT_TOC_REGNUM 2\n+\n /* Place that structure value return address is placed.\n \n    On the RS/6000, it is passed as an extra parameter.  */\n-#define STRUCT_VALUE\t0\n+#define STRUCT_VALUE 0\n \f\n /* Define the classes of registers for register constraints in the\n    machine description.  Also define ranges of constants."}]}