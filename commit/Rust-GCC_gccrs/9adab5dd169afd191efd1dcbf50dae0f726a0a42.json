{"sha": "9adab5dd169afd191efd1dcbf50dae0f726a0a42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFkYWI1ZGQxNjlhZmQxOTFlZmQxZGNiZjUwZGFlMGY3MjZhMGE0Mg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-02-08T15:30:22Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-02-08T15:30:22Z"}, "message": "libgo: update to Go1.10rc2\n    \n    Reviewed-on: https://go-review.googlesource.com/92736\n\nFrom-SVN: r257493", "tree": {"sha": "55e1207fb22e51fd55c08d7f337c1822acf46f7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55e1207fb22e51fd55c08d7f337c1822acf46f7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9adab5dd169afd191efd1dcbf50dae0f726a0a42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9adab5dd169afd191efd1dcbf50dae0f726a0a42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9adab5dd169afd191efd1dcbf50dae0f726a0a42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9adab5dd169afd191efd1dcbf50dae0f726a0a42/comments", "author": null, "committer": null, "parents": [{"sha": "b5ec4de777870e2d4ff2a5de604eafd1bf0e50df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5ec4de777870e2d4ff2a5de604eafd1bf0e50df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5ec4de777870e2d4ff2a5de604eafd1bf0e50df"}], "stats": {"total": 1380, "additions": 1035, "deletions": 345}, "files": [{"sha": "bdaea8180f4107c1a9946dabc11da62bc8a0a149", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -1,4 +1,4 @@\n-cdc28627b7abfd73f5d552813db8eb4293b823b0\n+2aa95f1499cf931ef8e95c7958463829276a0f2c\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "26b8869db901594eb577bde77d3e3cb12a0977f3", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -1,4 +1,4 @@\n-5348aed83e39bd1d450d92d7f627e994c2db6ebf\n+20e228f2fdb44350c858de941dff4aea9f3127b8\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "dc3cdca6363558938f9b3dea6f00d2eaa65fffbe", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -1 +1 @@\n-go1.10rc1\n+go1.10rc2"}, {"sha": "c16b63a313bb96c6dae51b435b8216ce97a85e20", "filename": "libgo/go/cmd/cgo/doc.go", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -45,8 +45,8 @@ For example:\n \t// #include <png.h>\n \timport \"C\"\n \n-Alternatively, CPPFLAGS and LDFLAGS may be obtained via the pkg-config\n-tool using a '#cgo pkg-config:' directive followed by the package names.\n+Alternatively, CPPFLAGS and LDFLAGS may be obtained via the pkg-config tool\n+using a '#cgo pkg-config:' directive followed by the package names.\n For example:\n \n \t// #cgo pkg-config: png cairo\n@@ -55,11 +55,21 @@ For example:\n \n The default pkg-config tool may be changed by setting the PKG_CONFIG environment variable.\n \n+For security reasons, only a limited set of flags are allowed, notably -D, -I, and -l.\n+To allow additional flags, set CGO_CFLAGS_ALLOW to a regular expression\n+matching the new flags. To disallow flags that would otherwise be allowed,\n+set CGO_CFLAGS_DISALLOW to a regular expression matching arguments\n+that must be disallowed. In both cases the regular expression must match\n+a full argument: to allow -mfoo=bar, use CGO_CFLAGS_ALLOW='-mfoo.*',\n+not just CGO_CFLAGS_ALLOW='-mfoo'. Similarly named variables control\n+the allowed CPPFLAGS, CXXFLAGS, FFLAGS, and LDFLAGS.\n+\n When building, the CGO_CFLAGS, CGO_CPPFLAGS, CGO_CXXFLAGS, CGO_FFLAGS and\n CGO_LDFLAGS environment variables are added to the flags derived from\n these directives. Package-specific flags should be set using the\n directives, not the environment variables, so that builds work in\n-unmodified environments.\n+unmodified environments. Flags obtained from environment variables\n+are not subject to the security limitations described above.\n \n All the cgo CPPFLAGS and CFLAGS directives in a package are concatenated and\n used to compile C files in that package. All the CPPFLAGS and CXXFLAGS"}, {"sha": "534fba17eb4bbfe5155d0f7ae212c13dff2f7a7c", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -2345,12 +2345,6 @@ func (c *typeConv) FuncArg(dtype dwarf.Type, pos token.Pos) *Type {\n \t\t\t\tbreak\n \t\t\t}\n \n-\t\t\t// If we already know the typedef for t just use that.\n-\t\t\t// See issue 19832.\n-\t\t\tif def := typedef[t.Go.(*ast.Ident).Name]; def != nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\n \t\t\tt = c.Type(ptr, pos)\n \t\t\tif t == nil {\n \t\t\t\treturn nil"}, {"sha": "5e1ac5aaf571f90fa5f6a58aee4a43b131e151c2", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -1227,17 +1227,26 @@\n // \tCGO_CFLAGS\n // \t\tFlags that cgo will pass to the compiler when compiling\n // \t\tC code.\n-// \tCGO_CPPFLAGS\n-// \t\tFlags that cgo will pass to the compiler when compiling\n-// \t\tC or C++ code.\n-// \tCGO_CXXFLAGS\n-// \t\tFlags that cgo will pass to the compiler when compiling\n-// \t\tC++ code.\n-// \tCGO_FFLAGS\n-// \t\tFlags that cgo will pass to the compiler when compiling\n-// \t\tFortran code.\n-// \tCGO_LDFLAGS\n-// \t\tFlags that cgo will pass to the compiler when linking.\n+// \tCGO_CFLAGS_ALLOW\n+// \t\tA regular expression specifying additional flags to allow\n+// \t\tto appear in #cgo CFLAGS source code directives.\n+// \t\tDoes not apply to the CGO_CFLAGS environment variable.\n+// \tCGO_CFLAGS_DISALLOW\n+// \t\tA regular expression specifying flags that must be disallowed\n+// \t\tfrom appearing in #cgo CFLAGS source code directives.\n+// \t\tDoes not apply to the CGO_CFLAGS environment variable.\n+// \tCGO_CPPFLAGS, CGO_CPPFLAGS_ALLOW, CGO_CPPFLAGS_DISALLOW\n+// \t\tLike CGO_CFLAGS, CGO_CFLAGS_ALLOW, and CGO_CFLAGS_DISALLOW,\n+// \t\tbut for the C preprocessor.\n+// \tCGO_CXXFLAGS, CGO_CXXFLAGS_ALLOW, CGO_CXXFLAGS_DISALLOW\n+// \t\tLike CGO_CFLAGS, CGO_CFLAGS_ALLOW, and CGO_CFLAGS_DISALLOW,\n+// \t\tbut for the C++ compiler.\n+// \tCGO_FFLAGS, CGO_FFLAGS_ALLOW, CGO_FFLAGS_DISALLOW\n+// \t\tLike CGO_CFLAGS, CGO_CFLAGS_ALLOW, and CGO_CFLAGS_DISALLOW,\n+// \t\tbut for the Fortran compiler.\n+// \tCGO_LDFLAGS, CGO_LDFLAGS_ALLOW, CGO_LDFLAGS_DISALLOW\n+// \t\tLike CGO_CFLAGS, CGO_CFLAGS_ALLOW, and CGO_CFLAGS_DISALLOW,\n+// \t\tbut for the linker.\n // \tCXX\n // \t\tThe command to use to compile C++ code.\n // \tPKG_CONFIG"}, {"sha": "c5a3d7b36bc5cf4e943a35842296532e6b1a7462", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 244, "deletions": 1, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -81,6 +81,13 @@ func init() {\n \t\t\tskipExternal = true\n \t\t\tcanRun = false\n \t\t}\n+\tcase \"plan9\":\n+\t\tswitch runtime.GOARCH {\n+\t\tcase \"arm\":\n+\t\t\t// many plan9/arm machines are too slow to run\n+\t\t\t// the full set of external tests.\n+\t\t\tskipExternal = true\n+\t\t}\n \tcase \"windows\":\n \t\texeSuffix = \".exe\"\n \t}\n@@ -2815,7 +2822,7 @@ func TestCgoHandlesWlORIGIN(t *testing.T) {\n \tdefer tg.cleanup()\n \ttg.parallel()\n \ttg.tempFile(\"src/origin/origin.go\", `package origin\n-\t\t// #cgo !darwin LDFLAGS: -Wl,-rpath -Wl,$ORIGIN\n+\t\t// #cgo !darwin LDFLAGS: -Wl,-rpath,$ORIGIN\n \t\t// void f(void) {}\n \t\timport \"C\"\n \t\tfunc f() { C.f() }`)\n@@ -5421,6 +5428,30 @@ func TestTestCacheInputs(t *testing.T) {\n \t}\n }\n \n+func TestNoCache(t *testing.T) {\n+\tswitch runtime.GOOS {\n+\tcase \"windows\":\n+\t\tt.Skipf(\"no unwritable directories on %s\", runtime.GOOS)\n+\t}\n+\tif os.Getuid() == 0 {\n+\t\tt.Skip(\"skipping test because running as root\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempFile(\"triv.go\", `package main; func main() {}`)\n+\ttg.must(os.MkdirAll(tg.path(\"unwritable\"), 0555))\n+\thome := \"HOME\"\n+\tif runtime.GOOS == \"plan9\" {\n+\t\thome = \"home\"\n+\t}\n+\ttg.setenv(home, tg.path(filepath.Join(\"unwritable\", \"home\")))\n+\ttg.unsetenv(\"GOCACHE\")\n+\ttg.run(\"build\", \"-o\", tg.path(\"triv\"), tg.path(\"triv.go\"))\n+\ttg.grepStderr(\"disabling cache\", \"did not disable cache\")\n+}\n+\n func TestTestVet(t *testing.T) {\n \ttooSlow(t)\n \ttg := testgo(t)\n@@ -5463,6 +5494,44 @@ func TestTestVet(t *testing.T) {\n \ttg.grepStdout(`ok\\s+vetfail/p2`, \"did not run vetfail/p2\")\n }\n \n+func TestTestRebuild(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\n+\t// golang.org/issue/23701.\n+\t// b_test imports b with augmented method from export_test.go.\n+\t// b_test also imports a, which imports b.\n+\t// Must not accidentally see un-augmented b propagate through a to b_test.\n+\ttg.tempFile(\"src/a/a.go\", `package a\n+\t\timport \"b\"\n+\t\ttype Type struct{}\n+\t\tfunc (*Type) M() b.T {return 0}\n+\t`)\n+\ttg.tempFile(\"src/b/b.go\", `package b\n+\t\ttype T int\n+\t\ttype I interface {M() T}\n+\t`)\n+\ttg.tempFile(\"src/b/export_test.go\", `package b\n+\t\tfunc (*T) Method() *T { return nil }\n+\t`)\n+\ttg.tempFile(\"src/b/b_test.go\", `package b_test\n+\t\timport (\n+\t\t\t\"testing\"\n+\t\t\t\"a\"\n+\t\t\t. \"b\"\n+\t\t)\n+\t\tfunc TestBroken(t *testing.T) {\n+\t\t\tx := new(T)\n+\t\t\tx.Method()\n+\t\t\t_ = new(a.Type)\n+\t\t}\n+\t`)\n+\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"test\", \"b\")\n+}\n+\n func TestInstallDeps(t *testing.T) {\n \ttooSlow(t)\n \ttg := testgo(t)\n@@ -5712,3 +5781,177 @@ func TestCpuprofileTwice(t *testing.T) {\n \ttg.run(\"test\", \"-o=\"+bin, \"-cpuprofile=\"+out, \"x\")\n \ttg.mustExist(out)\n }\n+\n+// Issue 23694.\n+func TestAtomicCoverpkgAll(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo has no cover tool\")\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\n+\ttg.tempFile(\"src/x/x.go\", `package x; import _ \"sync/atomic\"; func F() {}`)\n+\ttg.tempFile(\"src/x/x_test.go\", `package x; import \"testing\"; func TestF(t *testing.T) { F() }`)\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"test\", \"-coverpkg=all\", \"-covermode=atomic\", \"x\")\n+\tif canRace {\n+\t\ttg.run(\"test\", \"-coverpkg=all\", \"-race\", \"x\")\n+\t}\n+}\n+\n+func TestBadCommandLines(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\n+\ttg.tempFile(\"src/x/x.go\", \"package x\\n\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\n+\ttg.run(\"build\", \"x\")\n+\n+\ttg.tempFile(\"src/x/@y.go\", \"package x\\n\")\n+\ttg.runFail(\"build\", \"x\")\n+\ttg.grepStderr(\"invalid input file name \\\"@y.go\\\"\", \"did not reject @y.go\")\n+\ttg.must(os.Remove(tg.path(\"src/x/@y.go\")))\n+\n+\ttg.tempFile(\"src/x/-y.go\", \"package x\\n\")\n+\ttg.runFail(\"build\", \"x\")\n+\ttg.grepStderr(\"invalid input file name \\\"-y.go\\\"\", \"did not reject -y.go\")\n+\ttg.must(os.Remove(tg.path(\"src/x/-y.go\")))\n+\n+\tif runtime.Compiler == \"gccgo\" {\n+\t\ttg.runFail(\"build\", \"-gccgoflags=all=@x\", \"x\")\n+\t} else {\n+\t\ttg.runFail(\"build\", \"-gcflags=all=@x\", \"x\")\n+\t}\n+\ttg.grepStderr(\"invalid command-line argument @x in command\", \"did not reject @x during exec\")\n+\n+\ttg.tempFile(\"src/@x/x.go\", \"package x\\n\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.runFail(\"build\", \"@x\")\n+\ttg.grepStderr(\"invalid input directory name \\\"@x\\\"\", \"did not reject @x directory\")\n+\n+\ttg.tempFile(\"src/@x/y/y.go\", \"package y\\n\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.runFail(\"build\", \"@x/y\")\n+\ttg.grepStderr(\"invalid import path \\\"@x/y\\\"\", \"did not reject @x/y import path\")\n+\n+\ttg.tempFile(\"src/-x/x.go\", \"package x\\n\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.runFail(\"build\", \"--\", \"-x\")\n+\ttg.grepStderr(\"invalid input directory name \\\"-x\\\"\", \"did not reject -x directory\")\n+\n+\ttg.tempFile(\"src/-x/y/y.go\", \"package y\\n\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.runFail(\"build\", \"--\", \"-x/y\")\n+\ttg.grepStderr(\"invalid import path \\\"-x/y\\\"\", \"did not reject -x/y import path\")\n+}\n+\n+func TestBadCgoDirectives(t *testing.T) {\n+\tif !canCgo {\n+\t\tt.Skip(\"no cgo\")\n+\t}\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\n+\ttg.tempFile(\"src/x/x.go\", \"package x\\n\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\n+\tif runtime.Compiler == \"gc\" {\n+\t\ttg.tempFile(\"src/x/x.go\", `package x\n+\n+\t\t\t//go:cgo_ldflag \"-fplugin=foo.so\"\n+\n+\t\t\timport \"C\"\n+\t\t`)\n+\t\ttg.runFail(\"build\", \"x\")\n+\t\ttg.grepStderr(\"//go:cgo_ldflag .* only allowed in cgo-generated code\", \"did not reject //go:cgo_ldflag directive\")\n+\t}\n+\n+\ttg.must(os.Remove(tg.path(\"src/x/x.go\")))\n+\ttg.runFail(\"build\", \"x\")\n+\ttg.grepStderr(\"no Go files\", \"did not report missing source code\")\n+\ttg.tempFile(\"src/x/_cgo_yy.go\", `package x\n+\n+\t\t//go:cgo_ldflag \"-fplugin=foo.so\"\n+\n+\t\timport \"C\"\n+\t`)\n+\ttg.runFail(\"build\", \"x\")\n+\ttg.grepStderr(\"no Go files\", \"did not report missing source code\") // _* files are ignored...\n+\n+\tif runtime.Compiler == \"gc\" {\n+\t\ttg.runFail(\"build\", tg.path(\"src/x/_cgo_yy.go\")) // ... but if forced, the comment is rejected\n+\t\t// Actually, today there is a separate issue that _ files named\n+\t\t// on the command-line are ignored. Once that is fixed,\n+\t\t// we want to see the cgo_ldflag error.\n+\t\ttg.grepStderr(\"//go:cgo_ldflag only allowed in cgo-generated code|no Go files\", \"did not reject //go:cgo_ldflag directive\")\n+\t}\n+\n+\ttg.must(os.Remove(tg.path(\"src/x/_cgo_yy.go\")))\n+\n+\ttg.tempFile(\"src/x/x.go\", \"package x\\n\")\n+\ttg.tempFile(\"src/x/y.go\", `package x\n+\t\t// #cgo CFLAGS: -fplugin=foo.so\n+\t\timport \"C\"\n+\t`)\n+\ttg.runFail(\"build\", \"x\")\n+\ttg.grepStderr(\"invalid flag in #cgo CFLAGS: -fplugin=foo.so\", \"did not reject -fplugin\")\n+\n+\ttg.tempFile(\"src/x/y.go\", `package x\n+\t\t// #cgo CFLAGS: -Ibar -fplugin=foo.so\n+\t\timport \"C\"\n+\t`)\n+\ttg.runFail(\"build\", \"x\")\n+\ttg.grepStderr(\"invalid flag in #cgo CFLAGS: -fplugin=foo.so\", \"did not reject -fplugin\")\n+\n+\ttg.tempFile(\"src/x/y.go\", `package x\n+\t\t// #cgo pkg-config: -foo\n+\t\timport \"C\"\n+\t`)\n+\ttg.runFail(\"build\", \"x\")\n+\ttg.grepStderr(\"invalid pkg-config package name: -foo\", \"did not reject pkg-config: -foo\")\n+\n+\ttg.tempFile(\"src/x/y.go\", `package x\n+\t\t// #cgo pkg-config: @foo\n+\t\timport \"C\"\n+\t`)\n+\ttg.runFail(\"build\", \"x\")\n+\ttg.grepStderr(\"invalid pkg-config package name: @foo\", \"did not reject pkg-config: -foo\")\n+\n+\ttg.tempFile(\"src/x/y.go\", `package x\n+\t\t// #cgo CFLAGS: @foo\n+\t\timport \"C\"\n+\t`)\n+\ttg.runFail(\"build\", \"x\")\n+\ttg.grepStderr(\"invalid flag in #cgo CFLAGS: @foo\", \"did not reject @foo flag\")\n+\n+\ttg.tempFile(\"src/x/y.go\", `package x\n+\t\t// #cgo CFLAGS: -D\n+\t\timport \"C\"\n+\t`)\n+\ttg.runFail(\"build\", \"x\")\n+\ttg.grepStderr(\"invalid flag in #cgo CFLAGS: -D without argument\", \"did not reject trailing -I flag\")\n+\n+\t// Note that -I @foo is allowed because we rewrite it into -I /path/to/src/@foo\n+\t// before the check is applied. There's no such rewrite for -D.\n+\n+\ttg.tempFile(\"src/x/y.go\", `package x\n+\t\t// #cgo CFLAGS: -D @foo\n+\t\timport \"C\"\n+\t`)\n+\ttg.runFail(\"build\", \"x\")\n+\ttg.grepStderr(\"invalid flag in #cgo CFLAGS: -D @foo\", \"did not reject -D @foo flag\")\n+\n+\ttg.tempFile(\"src/x/y.go\", `package x\n+\t\t// #cgo CFLAGS: -D@foo\n+\t\timport \"C\"\n+\t`)\n+\ttg.runFail(\"build\", \"x\")\n+\ttg.grepStderr(\"invalid flag in #cgo CFLAGS: -D@foo\", \"did not reject -D@foo flag\")\n+\n+\ttg.setenv(\"CGO_CFLAGS\", \"-D@foo\")\n+\ttg.tempFile(\"src/x/y.go\", `package x\n+\t\timport \"C\"\n+\t`)\n+\ttg.run(\"build\", \"-n\", \"x\")\n+\ttg.grepStderr(\"-D@foo\", \"did not find -D@foo in commands\")\n+}"}, {"sha": "97283762258d659c0a6fcacc5d9c32fe80eebc88", "filename": "libgo/go/cmd/go/internal/cache/default.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -5,7 +5,7 @@\n package cache\n \n import (\n-\t\"cmd/go/internal/base\"\n+\t\"fmt\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n@@ -40,7 +40,8 @@ func initDefaultCache() {\n \t\treturn\n \t}\n \tif err := os.MkdirAll(dir, 0777); err != nil {\n-\t\tbase.Fatalf(\"initializing cache in $GOCACHE: %s\", err)\n+\t\tfmt.Fprintf(os.Stderr, \"go: disabling cache (%s) due to initialization failure: %s\\n\", dir, err)\n+\t\treturn\n \t}\n \tif _, err := os.Stat(filepath.Join(dir, \"README\")); err != nil {\n \t\t// Best effort.\n@@ -49,7 +50,8 @@ func initDefaultCache() {\n \n \tc, err := Open(dir)\n \tif err != nil {\n-\t\tbase.Fatalf(\"initializing cache in $GOCACHE: %s\", err)\n+\t\tfmt.Fprintf(os.Stderr, \"go: disabling cache (%s) due to initialization failure: %s\\n\", dir, err)\n+\t\treturn\n \t}\n \tdefaultCache = c\n }"}, {"sha": "603f7b5060c98522a930c380effa9e7eaa8b0581", "filename": "libgo/go/cmd/go/internal/envcmd/env.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -113,7 +113,12 @@ func findEnv(env []cfg.EnvVar, name string) string {\n func ExtraEnvVars() []cfg.EnvVar {\n \tvar b work.Builder\n \tb.Init()\n-\tcppflags, cflags, cxxflags, fflags, ldflags := b.CFlags(&load.Package{})\n+\tcppflags, cflags, cxxflags, fflags, ldflags, err := b.CFlags(&load.Package{})\n+\tif err != nil {\n+\t\t// Should not happen - b.CFlags was given an empty package.\n+\t\tfmt.Fprintf(os.Stderr, \"go: invalid cflags: %v\\n\", err)\n+\t\treturn nil\n+\t}\n \tcmd := b.GccCmd(\".\", \"\")\n \treturn []cfg.EnvVar{\n \t\t// Note: Update the switch in runEnv below when adding to this list."}, {"sha": "9a9fc4e944891c2eefb8704a242c3c2546684683", "filename": "libgo/go/cmd/go/internal/help/helpdoc.go", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -487,17 +487,26 @@ Environment variables for use with cgo:\n \tCGO_CFLAGS\n \t\tFlags that cgo will pass to the compiler when compiling\n \t\tC code.\n-\tCGO_CPPFLAGS\n-\t\tFlags that cgo will pass to the compiler when compiling\n-\t\tC or C++ code.\n-\tCGO_CXXFLAGS\n-\t\tFlags that cgo will pass to the compiler when compiling\n-\t\tC++ code.\n-\tCGO_FFLAGS\n-\t\tFlags that cgo will pass to the compiler when compiling\n-\t\tFortran code.\n-\tCGO_LDFLAGS\n-\t\tFlags that cgo will pass to the compiler when linking.\n+\tCGO_CFLAGS_ALLOW\n+\t\tA regular expression specifying additional flags to allow\n+\t\tto appear in #cgo CFLAGS source code directives.\n+\t\tDoes not apply to the CGO_CFLAGS environment variable.\n+\tCGO_CFLAGS_DISALLOW\n+\t\tA regular expression specifying flags that must be disallowed\n+\t\tfrom appearing in #cgo CFLAGS source code directives.\n+\t\tDoes not apply to the CGO_CFLAGS environment variable.\n+\tCGO_CPPFLAGS, CGO_CPPFLAGS_ALLOW, CGO_CPPFLAGS_DISALLOW\n+\t\tLike CGO_CFLAGS, CGO_CFLAGS_ALLOW, and CGO_CFLAGS_DISALLOW,\n+\t\tbut for the C preprocessor.\n+\tCGO_CXXFLAGS, CGO_CXXFLAGS_ALLOW, CGO_CXXFLAGS_DISALLOW\n+\t\tLike CGO_CFLAGS, CGO_CFLAGS_ALLOW, and CGO_CFLAGS_DISALLOW,\n+\t\tbut for the C++ compiler.\n+\tCGO_FFLAGS, CGO_FFLAGS_ALLOW, CGO_FFLAGS_DISALLOW\n+\t\tLike CGO_CFLAGS, CGO_CFLAGS_ALLOW, and CGO_CFLAGS_DISALLOW,\n+\t\tbut for the Fortran compiler.\n+\tCGO_LDFLAGS, CGO_LDFLAGS_ALLOW, CGO_LDFLAGS_DISALLOW\n+\t\tLike CGO_CFLAGS, CGO_CFLAGS_ALLOW, and CGO_CFLAGS_DISALLOW,\n+\t\tbut for the linker.\n \tCXX\n \t\tThe command to use to compile C++ code.\n \tPKG_CONFIG"}, {"sha": "ac764b4d028605f0b74737bae851a0fbf63e3794", "filename": "libgo/go/cmd/go/internal/load/pkg.go", "status": "modified", "additions": 88, "deletions": 16, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -17,6 +17,7 @@ import (\n \t\"sort\"\n \t\"strings\"\n \t\"unicode\"\n+\t\"unicode/utf8\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n@@ -55,6 +56,8 @@ type PackagePublic struct {\n \tStaleReason string `json:\",omitempty\"` // why is Stale true?\n \n \t// Source files\n+\t// If you add to this list you MUST add to p.AllFiles (below) too.\n+\t// Otherwise file name security lists will not apply to any new additions.\n \tGoFiles        []string `json:\",omitempty\"` // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n \tCgoFiles       []string `json:\",omitempty\"` // .go sources files that import \"C\"\n \tIgnoredGoFiles []string `json:\",omitempty\"` // .go sources ignored due to build constraints\n@@ -86,12 +89,38 @@ type PackagePublic struct {\n \tDepsErrors []*PackageError `json:\",omitempty\"` // errors loading dependencies\n \n \t// Test information\n+\t// If you add to this list you MUST add to p.AllFiles (below) too.\n+\t// Otherwise file name security lists will not apply to any new additions.\n \tTestGoFiles  []string `json:\",omitempty\"` // _test.go files in package\n \tTestImports  []string `json:\",omitempty\"` // imports from TestGoFiles\n \tXTestGoFiles []string `json:\",omitempty\"` // _test.go files outside package\n \tXTestImports []string `json:\",omitempty\"` // imports from XTestGoFiles\n }\n \n+// AllFiles returns the names of all the files considered for the package.\n+// This is used for sanity and security checks, so we include all files,\n+// even IgnoredGoFiles, because some subcommands consider them.\n+// The go/build package filtered others out (like foo_wrongGOARCH.s)\n+// and that's OK.\n+func (p *Package) AllFiles() []string {\n+\treturn str.StringList(\n+\t\tp.GoFiles,\n+\t\tp.CgoFiles,\n+\t\tp.IgnoredGoFiles,\n+\t\tp.CFiles,\n+\t\tp.CXXFiles,\n+\t\tp.MFiles,\n+\t\tp.HFiles,\n+\t\tp.FFiles,\n+\t\tp.SFiles,\n+\t\tp.SwigFiles,\n+\t\tp.SwigCXXFiles,\n+\t\tp.SysoFiles,\n+\t\tp.TestGoFiles,\n+\t\tp.XTestGoFiles,\n+\t)\n+}\n+\n type PackageInternal struct {\n \t// Unexported fields are not part of the public API.\n \tBuild        *build.Package\n@@ -420,6 +449,9 @@ func LoadImport(path, srcDir string, parent *Package, stk *ImportStack, importPo\n \t\tvar err error\n \t\tif debugDeprecatedImportcfgDir != \"\" {\n \t\t\tbp, err = cfg.BuildContext.ImportDir(debugDeprecatedImportcfgDir, 0)\n+\t\t} else if DebugDeprecatedImportcfg.enabled {\n+\t\t\tbp = new(build.Package)\n+\t\t\terr = fmt.Errorf(\"unknown import path %q: not in import cfg\", importPath)\n \t\t} else {\n \t\t\tbuildMode := build.ImportComment\n \t\t\tif mode&UseVendor == 0 || path != origPath {\n@@ -518,6 +550,13 @@ func isDir(path string) bool {\n // x/vendor/path, vendor/path, or else stay path if none of those exist.\n // VendoredImportPath returns the expanded path or, if no expansion is found, the original.\n func VendoredImportPath(parent *Package, path string) (found string) {\n+\tif DebugDeprecatedImportcfg.enabled {\n+\t\tif d, i := DebugDeprecatedImportcfg.lookup(parent, path); d != \"\" {\n+\t\t\treturn i\n+\t\t}\n+\t\treturn path\n+\t}\n+\n \tif parent == nil || parent.Root == \"\" {\n \t\treturn path\n \t}\n@@ -1010,22 +1049,8 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t// To avoid problems on case-insensitive files, we reject any package\n \t// where two different input files have equal names under a case-insensitive\n \t// comparison.\n-\tf1, f2 := str.FoldDup(str.StringList(\n-\t\tp.GoFiles,\n-\t\tp.CgoFiles,\n-\t\tp.IgnoredGoFiles,\n-\t\tp.CFiles,\n-\t\tp.CXXFiles,\n-\t\tp.MFiles,\n-\t\tp.HFiles,\n-\t\tp.FFiles,\n-\t\tp.SFiles,\n-\t\tp.SysoFiles,\n-\t\tp.SwigFiles,\n-\t\tp.SwigCXXFiles,\n-\t\tp.TestGoFiles,\n-\t\tp.XTestGoFiles,\n-\t))\n+\tinputs := p.AllFiles()\n+\tf1, f2 := str.FoldDup(inputs)\n \tif f1 != \"\" {\n \t\tp.Error = &PackageError{\n \t\t\tImportStack: stk.Copy(),\n@@ -1034,6 +1059,37 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t\treturn\n \t}\n \n+\t// If first letter of input file is ASCII, it must be alphanumeric.\n+\t// This avoids files turning into flags when invoking commands,\n+\t// and other problems we haven't thought of yet.\n+\t// Also, _cgo_ files must be generated by us, not supplied.\n+\t// They are allowed to have //go:cgo_ldflag directives.\n+\t// The directory scan ignores files beginning with _,\n+\t// so we shouldn't see any _cgo_ files anyway, but just be safe.\n+\tfor _, file := range inputs {\n+\t\tif !SafeArg(file) || strings.HasPrefix(file, \"_cgo_\") {\n+\t\t\tp.Error = &PackageError{\n+\t\t\t\tImportStack: stk.Copy(),\n+\t\t\t\tErr:         fmt.Sprintf(\"invalid input file name %q\", file),\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tif name := pathpkg.Base(p.ImportPath); !SafeArg(name) {\n+\t\tp.Error = &PackageError{\n+\t\t\tImportStack: stk.Copy(),\n+\t\t\tErr:         fmt.Sprintf(\"invalid input directory name %q\", name),\n+\t\t}\n+\t\treturn\n+\t}\n+\tif !SafeArg(p.ImportPath) {\n+\t\tp.Error = &PackageError{\n+\t\t\tImportStack: stk.Copy(),\n+\t\t\tErr:         fmt.Sprintf(\"invalid import path %q\", p.ImportPath),\n+\t\t}\n+\t\treturn\n+\t}\n+\n \t// Build list of imported packages and full dependency list.\n \timports := make([]*Package, 0, len(p.Imports))\n \tfor i, path := range importPaths {\n@@ -1160,6 +1216,22 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t}\n }\n \n+// SafeArg reports whether arg is a \"safe\" command-line argument,\n+// meaning that when it appears in a command-line, it probably\n+// doesn't have some special meaning other than its own name.\n+// Obviously args beginning with - are not safe (they look like flags).\n+// Less obviously, args beginning with @ are not safe (they look like\n+// GNU binutils flagfile specifiers, sometimes called \"response files\").\n+// To be conservative, we reject almost any arg beginning with non-alphanumeric ASCII.\n+// We accept leading . _ and / as likely in file system paths.\n+func SafeArg(name string) bool {\n+\tif name == \"\" {\n+\t\treturn false\n+\t}\n+\tc := name[0]\n+\treturn '0' <= c && c <= '9' || 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z' || c == '.' || c == '_' || c == '/' || c >= utf8.RuneSelf\n+}\n+\n // LinkerDeps returns the list of linker-induced dependencies for main package p.\n func LinkerDeps(p *Package) []string {\n \t// Everything links runtime."}, {"sha": "978547079644789cd14b3058d4451afed77e5720", "filename": "libgo/go/cmd/go/internal/test/test.go", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -662,6 +662,15 @@ func runTest(cmd *base.Command, args []string) {\n \t\t\t\t\thaveMatch = true\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\t// Silently ignore attempts to run coverage on\n+\t\t\t// sync/atomic when using atomic coverage mode.\n+\t\t\t// Atomic coverage mode uses sync/atomic, so\n+\t\t\t// we can't also do coverage on it.\n+\t\t\tif testCoverMode == \"atomic\" && p.Standard && p.ImportPath == \"sync/atomic\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n \t\t\tif haveMatch {\n \t\t\t\ttestCoverPkgs = append(testCoverPkgs, p)\n \t\t\t}\n@@ -894,7 +903,7 @@ func builderTest(b *work.Builder, p *load.Package) (buildAction, runAction, prin\n \t\tt.ImportXtest = true\n \t}\n \n-\tif ptest != p && localCover {\n+\tif ptest != p {\n \t\t// We have made modifications to the package p being tested\n \t\t// and are rebuilding p (as ptest).\n \t\t// Arrange to rebuild all packages q such that\n@@ -903,13 +912,6 @@ func builderTest(b *work.Builder, p *load.Package) (buildAction, runAction, prin\n \t\t// Strictly speaking, the rebuild is only necessary if the\n \t\t// modifications to p change its export metadata, but\n \t\t// determining that is a bit tricky, so we rebuild always.\n-\t\t// TODO(rsc): Once we get export metadata changes\n-\t\t// handled properly, look into the expense of dropping\n-\t\t// \"&& localCover\" above.\n-\t\t//\n-\t\t// This will cause extra compilation, so for now we only do it\n-\t\t// when testCover is set. The conditions are more general, though,\n-\t\t// and we may find that we need to do it always in the future.\n \t\trecompileForTest(pmain, p, ptest, pxtest)\n \t}\n "}, {"sha": "5527e90756d38aeda3faf81844a4f1dd10ff2560", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "modified", "additions": 75, "deletions": 15, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -197,7 +197,7 @@ func (b *Builder) buildActionID(a *Action) cache.ActionID {\n \tfmt.Fprintf(h, \"omitdebug %v standard %v local %v prefix %q\\n\", p.Internal.OmitDebug, p.Standard, p.Internal.Local, p.Internal.LocalPrefix)\n \tif len(p.CgoFiles)+len(p.SwigFiles) > 0 {\n \t\tfmt.Fprintf(h, \"cgo %q\\n\", b.toolID(\"cgo\"))\n-\t\tcppflags, cflags, cxxflags, fflags, _ := b.CFlags(p)\n+\t\tcppflags, cflags, cxxflags, fflags, _, _ := b.CFlags(p)\n \t\tfmt.Fprintf(h, \"CC=%q %q %q\\n\", b.ccExe(), cppflags, cflags)\n \t\tif len(p.CXXFiles)+len(p.SwigFiles) > 0 {\n \t\t\tfmt.Fprintf(h, \"CXX=%q %q\\n\", b.cxxExe(), cxxflags)\n@@ -521,7 +521,14 @@ func (b *Builder) build(a *Action) (err error) {\n \t}\n \n \t// Prepare Go import config.\n+\t// We start it off with a comment so it can't be empty, so icfg.Bytes() below is never nil.\n+\t// It should never be empty anyway, but there have been bugs in the past that resulted\n+\t// in empty configs, which then unfortunately turn into \"no config passed to compiler\",\n+\t// and the compiler falls back to looking in pkg itself, which mostly works,\n+\t// except when it doesn't.\n \tvar icfg bytes.Buffer\n+\tfmt.Fprintf(&icfg, \"# import config\\n\")\n+\n \tfor i, raw := range a.Package.Internal.RawImports {\n \t\tfinal := a.Package.Imports[i]\n \t\tif final != raw {\n@@ -938,28 +945,38 @@ func splitPkgConfigOutput(out []byte) []string {\n // Calls pkg-config if needed and returns the cflags/ldflags needed to build the package.\n func (b *Builder) getPkgConfigFlags(p *load.Package) (cflags, ldflags []string, err error) {\n \tif pkgs := p.CgoPkgConfig; len(pkgs) > 0 {\n+\t\tfor _, pkg := range pkgs {\n+\t\t\tif !load.SafeArg(pkg) {\n+\t\t\t\treturn nil, nil, fmt.Errorf(\"invalid pkg-config package name: %s\", pkg)\n+\t\t\t}\n+\t\t}\n \t\tvar out []byte\n-\t\tout, err = b.runOut(p.Dir, p.ImportPath, nil, b.PkgconfigCmd(), \"--cflags\", pkgs)\n+\t\tout, err = b.runOut(p.Dir, p.ImportPath, nil, b.PkgconfigCmd(), \"--cflags\", \"--\", pkgs)\n \t\tif err != nil {\n \t\t\tb.showOutput(nil, p.Dir, b.PkgconfigCmd()+\" --cflags \"+strings.Join(pkgs, \" \"), string(out))\n \t\t\tb.Print(err.Error() + \"\\n\")\n-\t\t\terr = errPrintedOutput\n-\t\t\treturn\n+\t\t\treturn nil, nil, errPrintedOutput\n \t\t}\n \t\tif len(out) > 0 {\n \t\t\tcflags = splitPkgConfigOutput(out)\n+\t\t\tif err := checkCompilerFlags(\"CFLAGS\", \"pkg-config --cflags\", cflags); err != nil {\n+\t\t\t\treturn nil, nil, err\n+\t\t\t}\n \t\t}\n-\t\tout, err = b.runOut(p.Dir, p.ImportPath, nil, b.PkgconfigCmd(), \"--libs\", pkgs)\n+\t\tout, err = b.runOut(p.Dir, p.ImportPath, nil, b.PkgconfigCmd(), \"--libs\", \"--\", pkgs)\n \t\tif err != nil {\n \t\t\tb.showOutput(nil, p.Dir, b.PkgconfigCmd()+\" --libs \"+strings.Join(pkgs, \" \"), string(out))\n \t\t\tb.Print(err.Error() + \"\\n\")\n-\t\t\terr = errPrintedOutput\n-\t\t\treturn\n+\t\t\treturn nil, nil, errPrintedOutput\n \t\t}\n \t\tif len(out) > 0 {\n \t\t\tldflags = strings.Fields(string(out))\n+\t\t\tif err := checkLinkerFlags(\"CFLAGS\", \"pkg-config --cflags\", ldflags); err != nil {\n+\t\t\t\treturn nil, nil, err\n+\t\t\t}\n \t\t}\n \t}\n+\n \treturn\n }\n \n@@ -1464,6 +1481,17 @@ func (b *Builder) processOutput(out []byte) string {\n // It returns the command output and any errors that occurred.\n func (b *Builder) runOut(dir string, desc string, env []string, cmdargs ...interface{}) ([]byte, error) {\n \tcmdline := str.StringList(cmdargs...)\n+\n+\tfor _, arg := range cmdline {\n+\t\t// GNU binutils commands, including gcc and gccgo, interpret an argument\n+\t\t// @foo anywhere in the command line (even following --) as meaning\n+\t\t// \"read and insert arguments from the file named foo.\"\n+\t\t// Don't say anything that might be misinterpreted that way.\n+\t\tif strings.HasPrefix(arg, \"@\") {\n+\t\t\treturn nil, fmt.Errorf(\"invalid command-line argument %s in command: %s\", arg, joinUnambiguously(cmdline))\n+\t\t}\n+\t}\n+\n \tif cfg.BuildN || cfg.BuildX {\n \t\tvar envcmdline string\n \t\tfor _, e := range env {\n@@ -1916,22 +1944,44 @@ func envList(key, def string) []string {\n }\n \n // CFlags returns the flags to use when invoking the C, C++ or Fortran compilers, or cgo.\n-func (b *Builder) CFlags(p *load.Package) (cppflags, cflags, cxxflags, fflags, ldflags []string) {\n+func (b *Builder) CFlags(p *load.Package) (cppflags, cflags, cxxflags, fflags, ldflags []string, err error) {\n \tdefaults := \"-g -O2\"\n \n-\tcppflags = str.StringList(envList(\"CGO_CPPFLAGS\", \"\"), p.CgoCPPFLAGS)\n-\tcflags = str.StringList(envList(\"CGO_CFLAGS\", defaults), p.CgoCFLAGS)\n-\tcxxflags = str.StringList(envList(\"CGO_CXXFLAGS\", defaults), p.CgoCXXFLAGS)\n-\tfflags = str.StringList(envList(\"CGO_FFLAGS\", defaults), p.CgoFFLAGS)\n-\tldflags = str.StringList(envList(\"CGO_LDFLAGS\", defaults), p.CgoLDFLAGS)\n+\tif cppflags, err = buildFlags(\"CPPFLAGS\", \"\", p.CgoCPPFLAGS, checkCompilerFlags); err != nil {\n+\t\treturn\n+\t}\n+\tif cflags, err = buildFlags(\"CFLAGS\", defaults, p.CgoCFLAGS, checkCompilerFlags); err != nil {\n+\t\treturn\n+\t}\n+\tif cxxflags, err = buildFlags(\"CXXFLAGS\", defaults, p.CgoCXXFLAGS, checkCompilerFlags); err != nil {\n+\t\treturn\n+\t}\n+\tif fflags, err = buildFlags(\"FFLAGS\", defaults, p.CgoFFLAGS, checkCompilerFlags); err != nil {\n+\t\treturn\n+\t}\n+\tif ldflags, err = buildFlags(\"LDFLAGS\", defaults, p.CgoLDFLAGS, checkLinkerFlags); err != nil {\n+\t\treturn\n+\t}\n+\n \treturn\n }\n \n+func buildFlags(name, defaults string, fromPackage []string, check func(string, string, []string) error) ([]string, error) {\n+\tif err := check(name, \"#cgo \"+name, fromPackage); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn str.StringList(envList(\"CGO_\"+name, defaults), fromPackage), nil\n+}\n+\n var cgoRe = regexp.MustCompile(`[/\\\\:]`)\n \n func (b *Builder) cgo(a *Action, cgoExe, objdir string, pcCFLAGS, pcLDFLAGS, cgofiles, gccfiles, gxxfiles, mfiles, ffiles []string) (outGo, outObj []string, err error) {\n \tp := a.Package\n-\tcgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, cgoFFLAGS, cgoLDFLAGS := b.CFlags(p)\n+\tcgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, cgoFFLAGS, cgoLDFLAGS, err := b.CFlags(p)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n \tcgoCPPFLAGS = append(cgoCPPFLAGS, pcCFLAGS...)\n \tcgoLDFLAGS = append(cgoLDFLAGS, pcLDFLAGS...)\n \t// If we are compiling Objective-C code, then we need to link against libobjc\n@@ -1981,6 +2031,12 @@ func (b *Builder) cgo(a *Action, cgoExe, objdir string, pcCFLAGS, pcLDFLAGS, cgo\n \t}\n \n \t// Update $CGO_LDFLAGS with p.CgoLDFLAGS.\n+\t// These flags are recorded in the generated _cgo_gotypes.go file\n+\t// using //go:cgo_ldflag directives, the compiler records them in the\n+\t// object file for the package, and then the Go linker passes them\n+\t// along to the host linker. At this point in the code, cgoLDFLAGS\n+\t// consists of the original $CGO_LDFLAGS (unchecked) and all the\n+\t// flags put together from source code (checked).\n \tvar cgoenv []string\n \tif len(cgoLDFLAGS) > 0 {\n \t\tflags := make([]string, len(cgoLDFLAGS))\n@@ -2272,7 +2328,11 @@ func (b *Builder) swigIntSize(objdir string) (intsize string, err error) {\n \n // Run SWIG on one SWIG input file.\n func (b *Builder) swigOne(a *Action, p *load.Package, file, objdir string, pcCFLAGS []string, cxx bool, intgosize string) (outGo, outC string, err error) {\n-\tcgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, _, _ := b.CFlags(p)\n+\tcgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, _, _, err := b.CFlags(p)\n+\tif err != nil {\n+\t\treturn \"\", \"\", err\n+\t}\n+\n \tvar cflags []string\n \tif cxx {\n \t\tcflags = str.StringList(cgoCPPFLAGS, pcCFLAGS, cgoCXXFLAGS)"}, {"sha": "fee5beeb15f3ea342384770d686814fe7eacba36", "filename": "libgo/go/cmd/go/internal/work/security.go", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -0,0 +1,160 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Checking of compiler and linker flags.\n+// We must avoid flags like -fplugin=, which can allow\n+// arbitrary code execution during the build.\n+// Do not make changes here without carefully\n+// considering the implications.\n+// (That's why the code is isolated in a file named security.go.)\n+//\n+// Note that -Wl,foo means split foo on commas and pass to\n+// the linker, so that -Wl,-foo,bar means pass -foo bar to\n+// the linker. Similarly -Wa,foo for the assembler and so on.\n+// If any of these are permitted, the wildcard portion must\n+// disallow commas.\n+//\n+// Note also that GNU binutils accept any argument @foo\n+// as meaning \"read more flags from the file foo\", so we must\n+// guard against any command-line argument beginning with @,\n+// even things like \"-I @foo\".\n+// We use load.SafeArg (which is even more conservative)\n+// to reject these.\n+//\n+// Even worse, gcc -I@foo (one arg) turns into cc1 -I @foo (two args),\n+// so although gcc doesn't expand the @foo, cc1 will.\n+// So out of paranoia, we reject @ at the beginning of every\n+// flag argument that might be split into its own argument.\n+\n+package work\n+\n+import (\n+\t\"cmd/go/internal/load\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"regexp\"\n+)\n+\n+var re = regexp.MustCompile\n+\n+var validCompilerFlags = []*regexp.Regexp{\n+\tre(`-D([A-Za-z_].*)`),\n+\tre(`-I([^@\\-].*)`),\n+\tre(`-O`),\n+\tre(`-O([^@\\-].*)`),\n+\tre(`-W`),\n+\tre(`-W([^@,]+)`), // -Wall but not -Wa,-foo.\n+\tre(`-f(no-)?objc-arc`),\n+\tre(`-f(no-)?omit-frame-pointer`),\n+\tre(`-f(no-)?(pic|PIC|pie|PIE)`),\n+\tre(`-f(no-)?split-stack`),\n+\tre(`-f(no-)?stack-(.+)`),\n+\tre(`-f(no-)?strict-aliasing`),\n+\tre(`-fsanitize=(.+)`),\n+\tre(`-g([^@\\-].*)?`),\n+\tre(`-m(arch|cpu|fpu|tune)=([^@\\-].*)`),\n+\tre(`-m(no-)?stack-(.+)`),\n+\tre(`-mmacosx-(.+)`),\n+\tre(`-mnop-fun-dllimport`),\n+\tre(`-pthread`),\n+\tre(`-std=([^@\\-].*)`),\n+\tre(`-x([^@\\-].*)`),\n+}\n+\n+var validCompilerFlagsWithNextArg = []string{\n+\t\"-D\",\n+\t\"-I\",\n+\t\"-framework\",\n+\t\"-x\",\n+}\n+\n+var validLinkerFlags = []*regexp.Regexp{\n+\tre(`-F([^@\\-].*)`),\n+\tre(`-l([^@\\-].*)`),\n+\tre(`-L([^@\\-].*)`),\n+\tre(`-f(no-)?(pic|PIC|pie|PIE)`),\n+\tre(`-fsanitize=([^@\\-].*)`),\n+\tre(`-g([^@\\-].*)?`),\n+\tre(`-m(arch|cpu|fpu|tune)=([^@\\-].*)`),\n+\tre(`-(pic|PIC|pie|PIE)`),\n+\tre(`-pthread`),\n+\n+\t// Note that any wildcards in -Wl need to exclude comma,\n+\t// since -Wl splits its argument at commas and passes\n+\t// them all to the linker uninterpreted. Allowing comma\n+\t// in a wildcard would allow tunnelling arbitrary additional\n+\t// linker arguments through one of these.\n+\tre(`-Wl,-rpath,([^,@\\-][^,]+)`),\n+\tre(`-Wl,--(no-)?warn-([^,]+)`),\n+\n+\tre(`[a-zA-Z0-9_].*\\.(o|obj|dll|dylib|so)`), // direct linker inputs: x.o or libfoo.so (but not -foo.o or @foo.o)\n+}\n+\n+var validLinkerFlagsWithNextArg = []string{\n+\t\"-F\",\n+\t\"-l\",\n+\t\"-L\",\n+\t\"-framework\",\n+}\n+\n+func checkCompilerFlags(name, source string, list []string) error {\n+\treturn checkFlags(name, source, list, validCompilerFlags, validCompilerFlagsWithNextArg)\n+}\n+\n+func checkLinkerFlags(name, source string, list []string) error {\n+\treturn checkFlags(name, source, list, validLinkerFlags, validLinkerFlagsWithNextArg)\n+}\n+\n+func checkFlags(name, source string, list []string, valid []*regexp.Regexp, validNext []string) error {\n+\t// Let users override rules with $CGO_CFLAGS_ALLOW, $CGO_CFLAGS_DISALLOW, etc.\n+\tvar (\n+\t\tallow    *regexp.Regexp\n+\t\tdisallow *regexp.Regexp\n+\t)\n+\tif env := os.Getenv(\"CGO_\" + name + \"_ALLOW\"); env != \"\" {\n+\t\tr, err := regexp.Compile(env)\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"parsing $CGO_%s_ALLOW: %v\", name, err)\n+\t\t}\n+\t\tallow = r\n+\t}\n+\tif env := os.Getenv(\"CGO_\" + name + \"_DISALLOW\"); env != \"\" {\n+\t\tr, err := regexp.Compile(env)\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"parsing $CGO_%s_DISALLOW: %v\", name, err)\n+\t\t}\n+\t\tdisallow = r\n+\t}\n+\n+Args:\n+\tfor i := 0; i < len(list); i++ {\n+\t\targ := list[i]\n+\t\tif disallow != nil && disallow.FindString(arg) == arg {\n+\t\t\tgoto Bad\n+\t\t}\n+\t\tif allow != nil && allow.FindString(arg) == arg {\n+\t\t\tcontinue Args\n+\t\t}\n+\t\tfor _, re := range valid {\n+\t\t\tif re.FindString(arg) == arg { // must be complete match\n+\t\t\t\tcontinue Args\n+\t\t\t}\n+\t\t}\n+\t\tfor _, x := range validNext {\n+\t\t\tif arg == x {\n+\t\t\t\tif i+1 < len(list) && load.SafeArg(list[i+1]) {\n+\t\t\t\t\ti++\n+\t\t\t\t\tcontinue Args\n+\t\t\t\t}\n+\t\t\t\tif i+1 < len(list) {\n+\t\t\t\t\treturn fmt.Errorf(\"invalid flag in %s: %s %s\", source, arg, list[i+1])\n+\t\t\t\t}\n+\t\t\t\treturn fmt.Errorf(\"invalid flag in %s: %s without argument\", source, arg)\n+\t\t\t}\n+\t\t}\n+\tBad:\n+\t\treturn fmt.Errorf(\"invalid flag in %s: %s\", source, arg)\n+\t}\n+\treturn nil\n+}"}, {"sha": "739ab5a6ee63b5b82aa3b61633e6e351457c1118", "filename": "libgo/go/cmd/go/internal/work/security_test.go", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -0,0 +1,240 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package work\n+\n+import (\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+var goodCompilerFlags = [][]string{\n+\t{\"-DFOO\"},\n+\t{\"-Dfoo=bar\"},\n+\t{\"-I/\"},\n+\t{\"-I/etc/passwd\"},\n+\t{\"-I.\"},\n+\t{\"-O\"},\n+\t{\"-O2\"},\n+\t{\"-Osmall\"},\n+\t{\"-W\"},\n+\t{\"-Wall\"},\n+\t{\"-fobjc-arc\"},\n+\t{\"-fno-objc-arc\"},\n+\t{\"-fomit-frame-pointer\"},\n+\t{\"-fno-omit-frame-pointer\"},\n+\t{\"-fpic\"},\n+\t{\"-fno-pic\"},\n+\t{\"-fPIC\"},\n+\t{\"-fno-PIC\"},\n+\t{\"-fpie\"},\n+\t{\"-fno-pie\"},\n+\t{\"-fPIE\"},\n+\t{\"-fno-PIE\"},\n+\t{\"-fsplit-stack\"},\n+\t{\"-fno-split-stack\"},\n+\t{\"-fstack-xxx\"},\n+\t{\"-fno-stack-xxx\"},\n+\t{\"-fsanitize=hands\"},\n+\t{\"-g\"},\n+\t{\"-ggdb\"},\n+\t{\"-march=souza\"},\n+\t{\"-mcpu=123\"},\n+\t{\"-mfpu=123\"},\n+\t{\"-mtune=happybirthday\"},\n+\t{\"-mstack-overflow\"},\n+\t{\"-mno-stack-overflow\"},\n+\t{\"-mmacosx-version\"},\n+\t{\"-mnop-fun-dllimport\"},\n+\t{\"-pthread\"},\n+\t{\"-std=c99\"},\n+\t{\"-xc\"},\n+\t{\"-D\", \"FOO\"},\n+\t{\"-D\", \"foo=bar\"},\n+\t{\"-I\", \".\"},\n+\t{\"-I\", \"/etc/passwd\"},\n+\t{\"-I\", \"\u4e16\u754c\"},\n+\t{\"-framework\", \"Chocolate\"},\n+\t{\"-x\", \"c\"},\n+}\n+\n+var badCompilerFlags = [][]string{\n+\t{\"-D@X\"},\n+\t{\"-D-X\"},\n+\t{\"-I@dir\"},\n+\t{\"-I-dir\"},\n+\t{\"-O@1\"},\n+\t{\"-Wa,-foo\"},\n+\t{\"-W@foo\"},\n+\t{\"-g@gdb\"},\n+\t{\"-g-gdb\"},\n+\t{\"-march=@dawn\"},\n+\t{\"-march=-dawn\"},\n+\t{\"-std=@c99\"},\n+\t{\"-std=-c99\"},\n+\t{\"-x@c\"},\n+\t{\"-x-c\"},\n+\t{\"-D\", \"@foo\"},\n+\t{\"-D\", \"-foo\"},\n+\t{\"-I\", \"@foo\"},\n+\t{\"-I\", \"-foo\"},\n+\t{\"-framework\", \"-Caffeine\"},\n+\t{\"-framework\", \"@Home\"},\n+\t{\"-x\", \"--c\"},\n+\t{\"-x\", \"@obj\"},\n+}\n+\n+func TestCheckCompilerFlags(t *testing.T) {\n+\tfor _, f := range goodCompilerFlags {\n+\t\tif err := checkCompilerFlags(\"test\", \"test\", f); err != nil {\n+\t\t\tt.Errorf(\"unexpected error for %q: %v\", f, err)\n+\t\t}\n+\t}\n+\tfor _, f := range badCompilerFlags {\n+\t\tif err := checkCompilerFlags(\"test\", \"test\", f); err == nil {\n+\t\t\tt.Errorf(\"missing error for %q\", f)\n+\t\t}\n+\t}\n+}\n+\n+var goodLinkerFlags = [][]string{\n+\t{\"-Fbar\"},\n+\t{\"-lbar\"},\n+\t{\"-Lbar\"},\n+\t{\"-fpic\"},\n+\t{\"-fno-pic\"},\n+\t{\"-fPIC\"},\n+\t{\"-fno-PIC\"},\n+\t{\"-fpie\"},\n+\t{\"-fno-pie\"},\n+\t{\"-fPIE\"},\n+\t{\"-fno-PIE\"},\n+\t{\"-fsanitize=hands\"},\n+\t{\"-g\"},\n+\t{\"-ggdb\"},\n+\t{\"-march=souza\"},\n+\t{\"-mcpu=123\"},\n+\t{\"-mfpu=123\"},\n+\t{\"-mtune=happybirthday\"},\n+\t{\"-pic\"},\n+\t{\"-pthread\"},\n+\t{\"-Wl,-rpath,foo\"},\n+\t{\"-Wl,-rpath,$ORIGIN/foo\"},\n+\t{\"-Wl,--warn-error\"},\n+\t{\"-Wl,--no-warn-error\"},\n+\t{\"foo.so\"},\n+\t{\"_\u4e16\u754c.dll\"},\n+\t{\"libcgosotest.dylib\"},\n+\t{\"-F\", \"framework\"},\n+\t{\"-l\", \".\"},\n+\t{\"-l\", \"/etc/passwd\"},\n+\t{\"-l\", \"\u4e16\u754c\"},\n+\t{\"-L\", \"framework\"},\n+\t{\"-framework\", \"Chocolate\"},\n+}\n+\n+var badLinkerFlags = [][]string{\n+\t{\"-DFOO\"},\n+\t{\"-Dfoo=bar\"},\n+\t{\"-O\"},\n+\t{\"-O2\"},\n+\t{\"-Osmall\"},\n+\t{\"-W\"},\n+\t{\"-Wall\"},\n+\t{\"-fobjc-arc\"},\n+\t{\"-fno-objc-arc\"},\n+\t{\"-fomit-frame-pointer\"},\n+\t{\"-fno-omit-frame-pointer\"},\n+\t{\"-fsplit-stack\"},\n+\t{\"-fno-split-stack\"},\n+\t{\"-fstack-xxx\"},\n+\t{\"-fno-stack-xxx\"},\n+\t{\"-mstack-overflow\"},\n+\t{\"-mno-stack-overflow\"},\n+\t{\"-mmacosx-version\"},\n+\t{\"-mnop-fun-dllimport\"},\n+\t{\"-std=c99\"},\n+\t{\"-xc\"},\n+\t{\"-D\", \"FOO\"},\n+\t{\"-D\", \"foo=bar\"},\n+\t{\"-I\", \"FOO\"},\n+\t{\"-L\", \"@foo\"},\n+\t{\"-L\", \"-foo\"},\n+\t{\"-x\", \"c\"},\n+\t{\"-D@X\"},\n+\t{\"-D-X\"},\n+\t{\"-I@dir\"},\n+\t{\"-I-dir\"},\n+\t{\"-O@1\"},\n+\t{\"-Wa,-foo\"},\n+\t{\"-W@foo\"},\n+\t{\"-g@gdb\"},\n+\t{\"-g-gdb\"},\n+\t{\"-march=@dawn\"},\n+\t{\"-march=-dawn\"},\n+\t{\"-std=@c99\"},\n+\t{\"-std=-c99\"},\n+\t{\"-x@c\"},\n+\t{\"-x-c\"},\n+\t{\"-D\", \"@foo\"},\n+\t{\"-D\", \"-foo\"},\n+\t{\"-I\", \"@foo\"},\n+\t{\"-I\", \"-foo\"},\n+\t{\"-l\", \"@foo\"},\n+\t{\"-l\", \"-foo\"},\n+\t{\"-framework\", \"-Caffeine\"},\n+\t{\"-framework\", \"@Home\"},\n+\t{\"-x\", \"--c\"},\n+\t{\"-x\", \"@obj\"},\n+\t{\"-Wl,-rpath,@foo\"},\n+}\n+\n+func TestCheckLinkerFlags(t *testing.T) {\n+\tfor _, f := range goodLinkerFlags {\n+\t\tif err := checkLinkerFlags(\"test\", \"test\", f); err != nil {\n+\t\t\tt.Errorf(\"unexpected error for %q: %v\", f, err)\n+\t\t}\n+\t}\n+\tfor _, f := range badLinkerFlags {\n+\t\tif err := checkLinkerFlags(\"test\", \"test\", f); err == nil {\n+\t\t\tt.Errorf(\"missing error for %q\", f)\n+\t\t}\n+\t}\n+}\n+\n+func TestCheckFlagAllowDisallow(t *testing.T) {\n+\tif err := checkCompilerFlags(\"TEST\", \"test\", []string{\"-disallow\"}); err == nil {\n+\t\tt.Fatalf(\"missing error for -disallow\")\n+\t}\n+\tos.Setenv(\"CGO_TEST_ALLOW\", \"-disallo\")\n+\tif err := checkCompilerFlags(\"TEST\", \"test\", []string{\"-disallow\"}); err == nil {\n+\t\tt.Fatalf(\"missing error for -disallow with CGO_TEST_ALLOW=-disallo\")\n+\t}\n+\tos.Setenv(\"CGO_TEST_ALLOW\", \"-disallow\")\n+\tif err := checkCompilerFlags(\"TEST\", \"test\", []string{\"-disallow\"}); err != nil {\n+\t\tt.Fatalf(\"unexpected error for -disallow with CGO_TEST_ALLOW=-disallow: %v\", err)\n+\t}\n+\tos.Unsetenv(\"CGO_TEST_ALLOW\")\n+\n+\tif err := checkCompilerFlags(\"TEST\", \"test\", []string{\"-Wall\"}); err != nil {\n+\t\tt.Fatalf(\"unexpected error for -Wall: %v\", err)\n+\t}\n+\tos.Setenv(\"CGO_TEST_DISALLOW\", \"-Wall\")\n+\tif err := checkCompilerFlags(\"TEST\", \"test\", []string{\"-Wall\"}); err == nil {\n+\t\tt.Fatalf(\"missing error for -Wall with CGO_TEST_DISALLOW=-Wall\")\n+\t}\n+\tos.Setenv(\"CGO_TEST_ALLOW\", \"-Wall\") // disallow wins\n+\tif err := checkCompilerFlags(\"TEST\", \"test\", []string{\"-Wall\"}); err == nil {\n+\t\tt.Fatalf(\"missing error for -Wall with CGO_TEST_DISALLOW=-Wall and CGO_TEST_ALLOW=-Wall\")\n+\t}\n+\n+\tos.Setenv(\"CGO_TEST_ALLOW\", \"-fplugin.*\")\n+\tos.Setenv(\"CGO_TEST_DISALLOW\", \"-fplugin=lint.so\")\n+\tif err := checkCompilerFlags(\"TEST\", \"test\", []string{\"-fplugin=faster.so\"}); err != nil {\n+\t\tt.Fatalf(\"unexpected error for -fplugin=faster.so: %v\", err)\n+\t}\n+\tif err := checkCompilerFlags(\"TEST\", \"test\", []string{\"-fplugin=lint.so\"}); err == nil {\n+\t\tt.Fatalf(\"missing error for -fplugin=lint.so: %v\", err)\n+\t}\n+}"}, {"sha": "1e54b4cf2cf1759f4fc6dedc9e0fd18ada651d19", "filename": "libgo/go/database/sql/driver/driver.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -379,6 +379,10 @@ type Rows interface {\n \t// size as the Columns() are wide.\n \t//\n \t// Next should return io.EOF when there are no more rows.\n+\t//\n+\t// The dest should not be written to outside of Next. Care\n+\t// should be taken when closing Rows not to modify\n+\t// a buffer held in dest.\n \tNext(dest []Value) error\n }\n "}, {"sha": "abb8d40fc022ed5c492e2709bdd1ec82b8fcccac", "filename": "libgo/go/database/sql/fakedb_test.go", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -1020,11 +1020,6 @@ func (rc *rowsCursor) touchMem() {\n }\n \n func (rc *rowsCursor) Close() error {\n-\tif !rc.closed {\n-\t\tfor _, bs := range rc.bytesClone {\n-\t\t\tbs[0] = 255 // first byte corrupted\n-\t\t}\n-\t}\n \trc.touchMem()\n \trc.parentMem.touchMem()\n \trc.closed = true"}, {"sha": "ae6bf7102e36c907fdd293ffee615ff6fb5c8f0f", "filename": "libgo/go/database/sql/sql_test.go", "status": "modified", "additions": 3, "deletions": 37, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -663,43 +663,6 @@ func TestPoolExhaustOnCancel(t *testing.T) {\n \t}\n }\n \n-func TestByteOwnership(t *testing.T) {\n-\tdb := newTestDB(t, \"people\")\n-\tdefer closeDB(t, db)\n-\trows, err := db.Query(\"SELECT|people|name,photo|\")\n-\tif err != nil {\n-\t\tt.Fatalf(\"Query: %v\", err)\n-\t}\n-\ttype row struct {\n-\t\tname  []byte\n-\t\tphoto RawBytes\n-\t}\n-\tgot := []row{}\n-\tfor rows.Next() {\n-\t\tvar r row\n-\t\terr = rows.Scan(&r.name, &r.photo)\n-\t\tif err != nil {\n-\t\t\tt.Fatalf(\"Scan: %v\", err)\n-\t\t}\n-\t\tgot = append(got, r)\n-\t}\n-\tcorruptMemory := []byte(\"\\xffPHOTO\")\n-\twant := []row{\n-\t\t{name: []byte(\"Alice\"), photo: corruptMemory},\n-\t\t{name: []byte(\"Bob\"), photo: corruptMemory},\n-\t\t{name: []byte(\"Chris\"), photo: corruptMemory},\n-\t}\n-\tif !reflect.DeepEqual(got, want) {\n-\t\tt.Errorf(\"mismatch.\\n got: %#v\\nwant: %#v\", got, want)\n-\t}\n-\n-\tvar photo RawBytes\n-\terr = db.QueryRow(\"SELECT|people|photo|name=?\", \"Alice\").Scan(&photo)\n-\tif err == nil {\n-\t\tt.Error(\"want error scanning into RawBytes from QueryRow\")\n-\t}\n-}\n-\n func TestRowsColumns(t *testing.T) {\n \tdb := newTestDB(t, \"people\")\n \tdefer closeDB(t, db)\n@@ -3192,8 +3155,11 @@ func TestIssue18429(t *testing.T) {\n \t\t\t// reported.\n \t\t\trows, _ := tx.QueryContext(ctx, \"WAIT|\"+qwait+\"|SELECT|people|name|\")\n \t\t\tif rows != nil {\n+\t\t\t\tvar name string\n \t\t\t\t// Call Next to test Issue 21117 and check for races.\n \t\t\t\tfor rows.Next() {\n+\t\t\t\t\t// Scan the buffer so it is read and checked for races.\n+\t\t\t\t\trows.Scan(&name)\n \t\t\t\t}\n \t\t\t\trows.Close()\n \t\t\t}"}, {"sha": "6f9838b55b92680ae590a5680bdc38e9b83c62ae", "filename": "libgo/go/go/build/deps_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -302,7 +302,7 @@ var pkgDeps = map[string][]string{\n \t\"os/user\": {\"L4\", \"CGO\", \"io/ioutil\", \"os\", \"syscall\"},\n \n \t// Internal package used only for testing.\n-\t\"os/signal/internal/pty\": {\"CGO\", \"fmt\", \"os\"},\n+\t\"os/signal/internal/pty\": {\"CGO\", \"fmt\", \"os\", \"syscall\"},\n \n \t// Basic networking.\n \t// Because net must be used by any package that wants to"}, {"sha": "299910de284e77324fcde27e31c3b1fb303a788b", "filename": "libgo/go/go/internal/gccgoimporter/gccgoinstallation_test.go", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fgccgoinstallation_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fgccgoinstallation_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fgccgoinstallation_test.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -62,8 +62,6 @@ var importablePackages = [...]string{\n \t\"encoding/pem\",\n \t\"encoding/xml\",\n \t\"errors\",\n-\t\"exp/proxy\",\n-\t\"exp/terminal\",\n \t\"expvar\",\n \t\"flag\",\n \t\"fmt\",\n@@ -114,8 +112,6 @@ var importablePackages = [...]string{\n \t\"net/smtp\",\n \t\"net/textproto\",\n \t\"net/url\",\n-\t\"old/regexp\",\n-\t\"old/template\",\n \t\"os/exec\",\n \t\"os\",\n \t\"os/signal\","}, {"sha": "516e557cfd29816ac1904dc577bbd5bec9ec22d9", "filename": "libgo/go/net/sock_bsd.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fnet%2Fsock_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fnet%2Fsock_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock_bsd.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -20,7 +20,7 @@ func maxListenerBacklog() int {\n \tcase \"darwin\":\n \t\tn, err = syscall.SysctlUint32(\"kern.ipc.somaxconn\")\n \tcase \"freebsd\":\n-\t\tn, err = syscall.SysctlUint32(\"kern.ipc.acceptqueue\")\n+\t\tn, err = syscall.SysctlUint32(\"kern.ipc.soacceptqueue\")\n \tcase \"netbsd\":\n \t\t// NOTE: NetBSD has no somaxconn-like kernel state so far\n \tcase \"openbsd\":"}, {"sha": "a7f8710b955db572679762e03ee3c99ec8a69fe5", "filename": "libgo/go/os/exec.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fos%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fos%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -88,6 +88,11 @@ func FindProcess(pid int) (*Process, error) {\n // specified by name, argv and attr. The argv slice will become os.Args in the\n // new process, so it normally starts with the program name.\n //\n+// If the calling goroutine has locked the operating system thread\n+// with runtime.LockOSThread and modified any inheritable OS-level\n+// thread state (for example, Linux or Plan 9 name spaces), the new\n+// process will inherit the caller's thread state.\n+//\n // StartProcess is a low-level interface. The os/exec package provides\n // higher-level interfaces.\n //"}, {"sha": "5ef9540141ef0e7bba36b6b97bc3e1c7de81b92c", "filename": "libgo/go/os/exec/exec.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fos%2Fexec%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fos%2Fexec%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Fexec.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -293,6 +293,11 @@ func (c *Cmd) closeDescriptors(closers []io.Closer) {\n //\n // If the command starts but does not complete successfully, the error is of\n // type *ExitError. Other error types may be returned for other situations.\n+//\n+// If the calling goroutine has locked the operating system thread\n+// with runtime.LockOSThread and modified any inheritable OS-level\n+// thread state (for example, Linux or Plan 9 name spaces), the new\n+// process will inherit the caller's thread state.\n func (c *Cmd) Run() error {\n \tif err := c.Start(); err != nil {\n \t\treturn err"}, {"sha": "e52d19ac30cadba254a2fc38949058c107466b30", "filename": "libgo/go/os/signal/internal/pty/pty.go", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fos%2Fsignal%2Finternal%2Fpty%2Fpty.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fos%2Fsignal%2Finternal%2Fpty%2Fpty.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fsignal%2Finternal%2Fpty%2Fpty.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -33,21 +33,35 @@ func close(int32) int32\n \n const _O_RDWR = 2\n \n+type PtyError struct {\n+\tFuncName    string\n+\tErrorString string\n+\tErrno       syscall.Errno\n+}\n+\n+func ptyError(name string, err error) *PtyError {\n+\treturn &PtyError{name, err.Error(), err.(syscall.Errno)}\n+}\n+\n+func (e *PtyError) Error() string {\n+\treturn fmt.Sprintf(\"%s: %s\", e.FuncName, e.ErrorString)\n+}\n+\n // Open returns a master pty and the name of the linked slave tty.\n func Open() (master *os.File, slave string, err error) {\n \tm := posix_openpt(_O_RDWR)\n \tif m < 0 {\n-\t\treturn nil, \"\", fmt.Errorf(\"posix_openpt: %v\", syscall.GetErrno())\n+\t\treturn nil, \"\", ptyError(\"posix_openpt\", syscall.GetErrno())\n \t}\n \tif grantpt(m) < 0 {\n \t\terrno := syscall.GetErrno()\n \t\tclose(m)\n-\t\treturn nil, \"\", fmt.Errorf(\"grantpt: %v\", errno)\n+\t\treturn nil, \"\", ptyError(\"grantpt\", errno)\n \t}\n \tif unlockpt(m) < 0 {\n \t\terrno := syscall.GetErrno()\n \t\tclose(m)\n-\t\treturn nil, \"\", fmt.Errorf(\"unlockpt: %v\", errno)\n+\t\treturn nil, \"\", ptyError(\"unlockpt\", errno)\n \t}\n \tp := ptsname(m)\n \ts := (*[32000]byte)(unsafe.Pointer(p))[:]"}, {"sha": "84a2a08ce9b6e5a11e072f581b72cbc890e40414", "filename": "libgo/go/os/signal/signal_cgo_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_cgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_cgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_cgo_test.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -72,6 +72,10 @@ func TestTerminalSignal(t *testing.T) {\n \n \tmaster, sname, err := pty.Open()\n \tif err != nil {\n+\t\tptyErr := err.(*pty.PtyError)\n+\t\tif ptyErr.FuncName == \"posix_openpt\" && ptyErr.Errno == syscall.EACCES {\n+\t\t\tt.Skip(\"posix_openpt failed with EACCES, assuming chroot and skipping\")\n+\t\t}\n \t\tt.Fatal(err)\n \t}\n \tdefer master.Close()"}, {"sha": "6688b3cbf6be30795617c1db0e0016f1cd41bdf7", "filename": "libgo/go/runtime/crash_cgo_test.go", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fruntime%2Fcrash_cgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fruntime%2Fcrash_cgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcrash_cgo_test.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -493,3 +493,24 @@ func TestSigStackSwapping(t *testing.T) {\n \t\tt.Errorf(\"expected %q got %v\", want, got)\n \t}\n }\n+\n+func TestCgoTracebackSigpanic(t *testing.T) {\n+\t// Test unwinding over a sigpanic in C code without a C\n+\t// symbolizer. See issue #23576.\n+\tif runtime.GOOS == \"windows\" {\n+\t\t// On Windows if we get an exception in C code, we let\n+\t\t// the Windows exception handler unwind it, rather\n+\t\t// than injecting a sigpanic.\n+\t\tt.Skip(\"no sigpanic in C on windows\")\n+\t}\n+\tt.Parallel()\n+\tgot := runTestProg(t, \"testprogcgo\", \"TracebackSigpanic\")\n+\twant := \"runtime.sigpanic\"\n+\tif !strings.Contains(got, want) {\n+\t\tt.Fatalf(\"want failure containing %q. output:\\n%s\\n\", want, got)\n+\t}\n+\tnowant := \"unexpected return pc\"\n+\tif strings.Contains(got, nowant) {\n+\t\tt.Fatalf(\"failure incorrectly contains %q. output:\\n%s\\n\", nowant, got)\n+\t}\n+}"}, {"sha": "cb46030980260d1a6d029bd860a7f84577b73b23", "filename": "libgo/go/runtime/testdata/testprogcgo/sigpanic.go", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Fsigpanic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Fsigpanic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Fsigpanic.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// This program will crash.\n+// We want to test unwinding from sigpanic into C code (without a C symbolizer).\n+\n+/*\n+#cgo CFLAGS: -O0\n+\n+char *pnil;\n+\n+static int f1(void) {\n+\t*pnil = 0;\n+\treturn 0;\n+}\n+*/\n+import \"C\"\n+\n+func init() {\n+\tregister(\"TracebackSigpanic\", TracebackSigpanic)\n+}\n+\n+func TracebackSigpanic() {\n+\tC.f1()\n+}"}, {"sha": "d174ebd9cfeedc5a589ad9268609e21b39998764", "filename": "libgo/go/text/template/doc.go", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -110,12 +110,6 @@ data, defined in detail in the corresponding sections that follow.\n \t\tT0 is executed; otherwise, dot is set to the successive elements\n \t\tof the array, slice, or map and T1 is executed.\n \n-\t{{break}}\n-\t\tBreak out of the surrounding range loop.\n-\n-\t{{continue}}\n-\t\tBegin the next iteration of the surrounding range loop.\n-\n \t{{template \"name\"}}\n \t\tThe template with the specified name is executed with nil data.\n "}, {"sha": "2923dd9d83fb4d01d72b9f9c365c7ff8ff38134e", "filename": "libgo/go/text/template/exec.go", "status": "modified", "additions": 24, "deletions": 60, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -27,12 +27,11 @@ const maxExecDepth = 1000\n // template so that multiple executions of the same template\n // can execute in parallel.\n type state struct {\n-\ttmpl       *Template\n-\twr         io.Writer\n-\tnode       parse.Node // current node, for errors.\n-\tvars       []variable // push-down stack of variable values.\n-\tdepth      int        // the height of the stack of executing templates.\n-\trangeDepth int        // nesting level of range loops.\n+\ttmpl  *Template\n+\twr    io.Writer\n+\tnode  parse.Node // current node, for errors\n+\tvars  []variable // push-down stack of variable values.\n+\tdepth int        // the height of the stack of executing templates.\n }\n \n // variable holds the dynamic value of a variable such as $, $x etc.\n@@ -223,17 +222,9 @@ func (t *Template) DefinedTemplates() string {\n \treturn s\n }\n \n-type rangeControl int8\n-\n-const (\n-\trangeNone     rangeControl = iota // no action.\n-\trangeBreak                        // break out of range.\n-\trangeContinue                     // continues next range iteration.\n-)\n-\n // Walk functions step through the major pieces of the template structure,\n // generating output as they go.\n-func (s *state) walk(dot reflect.Value, node parse.Node) rangeControl {\n+func (s *state) walk(dot reflect.Value, node parse.Node) {\n \ts.at(node)\n \tswitch node := node.(type) {\n \tcase *parse.ActionNode:\n@@ -244,42 +235,29 @@ func (s *state) walk(dot reflect.Value, node parse.Node) rangeControl {\n \t\t\ts.printValue(node, val)\n \t\t}\n \tcase *parse.IfNode:\n-\t\treturn s.walkIfOrWith(parse.NodeIf, dot, node.Pipe, node.List, node.ElseList)\n+\t\ts.walkIfOrWith(parse.NodeIf, dot, node.Pipe, node.List, node.ElseList)\n \tcase *parse.ListNode:\n \t\tfor _, node := range node.Nodes {\n-\t\t\tif c := s.walk(dot, node); c != rangeNone {\n-\t\t\t\treturn c\n-\t\t\t}\n+\t\t\ts.walk(dot, node)\n \t\t}\n \tcase *parse.RangeNode:\n-\t\treturn s.walkRange(dot, node)\n+\t\ts.walkRange(dot, node)\n \tcase *parse.TemplateNode:\n \t\ts.walkTemplate(dot, node)\n \tcase *parse.TextNode:\n \t\tif _, err := s.wr.Write(node.Text); err != nil {\n \t\t\ts.writeError(err)\n \t\t}\n \tcase *parse.WithNode:\n-\t\treturn s.walkIfOrWith(parse.NodeWith, dot, node.Pipe, node.List, node.ElseList)\n-\tcase *parse.BreakNode:\n-\t\tif s.rangeDepth == 0 {\n-\t\t\ts.errorf(\"invalid break outside of range\")\n-\t\t}\n-\t\treturn rangeBreak\n-\tcase *parse.ContinueNode:\n-\t\tif s.rangeDepth == 0 {\n-\t\t\ts.errorf(\"invalid continue outside of range\")\n-\t\t}\n-\t\treturn rangeContinue\n+\t\ts.walkIfOrWith(parse.NodeWith, dot, node.Pipe, node.List, node.ElseList)\n \tdefault:\n \t\ts.errorf(\"unknown node: %s\", node)\n \t}\n-\treturn rangeNone\n }\n \n // walkIfOrWith walks an 'if' or 'with' node. The two control structures\n // are identical in behavior except that 'with' sets dot.\n-func (s *state) walkIfOrWith(typ parse.NodeType, dot reflect.Value, pipe *parse.PipeNode, list, elseList *parse.ListNode) rangeControl {\n+func (s *state) walkIfOrWith(typ parse.NodeType, dot reflect.Value, pipe *parse.PipeNode, list, elseList *parse.ListNode) {\n \tdefer s.pop(s.mark())\n \tval := s.evalPipeline(dot, pipe)\n \ttruth, ok := isTrue(val)\n@@ -288,14 +266,13 @@ func (s *state) walkIfOrWith(typ parse.NodeType, dot reflect.Value, pipe *parse.\n \t}\n \tif truth {\n \t\tif typ == parse.NodeWith {\n-\t\t\treturn s.walk(val, list)\n+\t\t\ts.walk(val, list)\n \t\t} else {\n-\t\t\treturn s.walk(dot, list)\n+\t\t\ts.walk(dot, list)\n \t\t}\n \t} else if elseList != nil {\n-\t\treturn s.walk(dot, elseList)\n+\t\ts.walk(dot, elseList)\n \t}\n-\treturn rangeNone\n }\n \n // IsTrue reports whether the value is 'true', in the sense of not the zero of its type,\n@@ -333,14 +310,13 @@ func isTrue(val reflect.Value) (truth, ok bool) {\n \treturn truth, true\n }\n \n-func (s *state) walkRange(dot reflect.Value, r *parse.RangeNode) rangeControl {\n+func (s *state) walkRange(dot reflect.Value, r *parse.RangeNode) {\n \ts.at(r)\n \tdefer s.pop(s.mark())\n \tval, _ := indirect(s.evalPipeline(dot, r.Pipe))\n \t// mark top of stack before any variables in the body are pushed.\n \tmark := s.mark()\n-\ts.rangeDepth++\n-\toneIteration := func(index, elem reflect.Value) rangeControl {\n+\toneIteration := func(index, elem reflect.Value) {\n \t\t// Set top var (lexically the second if there are two) to the element.\n \t\tif len(r.Pipe.Decl) > 0 {\n \t\t\ts.setVar(1, elem)\n@@ -349,33 +325,26 @@ func (s *state) walkRange(dot reflect.Value, r *parse.RangeNode) rangeControl {\n \t\tif len(r.Pipe.Decl) > 1 {\n \t\t\ts.setVar(2, index)\n \t\t}\n-\t\tctrl := s.walk(elem, r.List)\n+\t\ts.walk(elem, r.List)\n \t\ts.pop(mark)\n-\t\treturn ctrl\n \t}\n \tswitch val.Kind() {\n \tcase reflect.Array, reflect.Slice:\n \t\tif val.Len() == 0 {\n \t\t\tbreak\n \t\t}\n \t\tfor i := 0; i < val.Len(); i++ {\n-\t\t\tif ctrl := oneIteration(reflect.ValueOf(i), val.Index(i)); ctrl == rangeBreak {\n-\t\t\t\tbreak\n-\t\t\t}\n+\t\t\toneIteration(reflect.ValueOf(i), val.Index(i))\n \t\t}\n-\t\ts.rangeDepth--\n-\t\treturn rangeNone\n+\t\treturn\n \tcase reflect.Map:\n \t\tif val.Len() == 0 {\n \t\t\tbreak\n \t\t}\n \t\tfor _, key := range sortKeys(val.MapKeys()) {\n-\t\t\tif ctrl := oneIteration(key, val.MapIndex(key)); ctrl == rangeBreak {\n-\t\t\t\tbreak\n-\t\t\t}\n+\t\t\toneIteration(key, val.MapIndex(key))\n \t\t}\n-\t\ts.rangeDepth--\n-\t\treturn rangeNone\n+\t\treturn\n \tcase reflect.Chan:\n \t\tif val.IsNil() {\n \t\t\tbreak\n@@ -386,25 +355,20 @@ func (s *state) walkRange(dot reflect.Value, r *parse.RangeNode) rangeControl {\n \t\t\tif !ok {\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\tif ctrl := oneIteration(reflect.ValueOf(i), elem); ctrl == rangeBreak {\n-\t\t\t\tbreak\n-\t\t\t}\n+\t\t\toneIteration(reflect.ValueOf(i), elem)\n \t\t}\n \t\tif i == 0 {\n \t\t\tbreak\n \t\t}\n-\t\ts.rangeDepth--\n-\t\treturn rangeNone\n+\t\treturn\n \tcase reflect.Invalid:\n \t\tbreak // An invalid value is likely a nil map, etc. and acts like an empty map.\n \tdefault:\n \t\ts.errorf(\"range can't iterate over %v\", val)\n \t}\n-\ts.rangeDepth--\n \tif r.ElseList != nil {\n-\t\treturn s.walk(dot, r.ElseList)\n+\t\ts.walk(dot, r.ElseList)\n \t}\n-\treturn rangeNone\n }\n \n func (s *state) walkTemplate(dot reflect.Value, t *parse.TemplateNode) {"}, {"sha": "d0cda6bd625da787d8dd41fb204ff79ae392fbce", "filename": "libgo/go/text/template/exec_test.go", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -513,10 +513,6 @@ var execTests = []execTest{\n \t{\"declare in range\", \"{{range $x := .PSI}}<{{$foo:=$x}}{{$x}}>{{end}}\", \"<21><22><23>\", tVal, true},\n \t{\"range count\", `{{range $i, $x := count 5}}[{{$i}}]{{$x}}{{end}}`, \"[0]a[1]b[2]c[3]d[4]e\", tVal, true},\n \t{\"range nil count\", `{{range $i, $x := count 0}}{{else}}empty{{end}}`, \"empty\", tVal, true},\n-\t{\"range quick break\", `{{range .SI}}{{break}}{{.}}{{end}}`, \"\", tVal, true},\n-\t{\"range break after two\", `{{range $i, $x := .SI}}{{if ge $i 2}}{{break}}{{end}}{{.}}{{end}}`, \"34\", tVal, true},\n-\t{\"range continue\", `{{range .SI}}{{continue}}{{.}}{{end}}`, \"\", tVal, true},\n-\t{\"range continue condition\", `{{range .SI}}{{if eq . 3 }}{{continue}}{{end}}{{.}}{{end}}`, \"45\", tVal, true},\n \n \t// Cute examples.\n \t{\"or as if true\", `{{or .SI \"slice is empty\"}}`, \"[3 4 5]\", tVal, true},"}, {"sha": "e112cb7714a422a58fd824e751a8a569deda9e88", "filename": "libgo/go/text/template/parse/lex.go", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Flex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Flex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Flex.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -60,8 +60,6 @@ const (\n \t// Keywords appear after all the rest.\n \titemKeyword  // used only to delimit the keywords\n \titemBlock    // block keyword\n-\titemBreak    // break keyword\n-\titemContinue // continue keyword\n \titemDot      // the cursor, spelled '.'\n \titemDefine   // define keyword\n \titemElse     // else keyword\n@@ -76,8 +74,6 @@ const (\n var key = map[string]itemType{\n \t\".\":        itemDot,\n \t\"block\":    itemBlock,\n-\t\"break\":    itemBreak,\n-\t\"continue\": itemContinue,\n \t\"define\":   itemDefine,\n \t\"else\":     itemElse,\n \t\"end\":      itemEnd,"}, {"sha": "cb01cd98b6ab2263618a5feec888e8bfc58807d5", "filename": "libgo/go/text/template/parse/lex_test.go", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Flex_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Flex_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Flex_test.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -192,7 +192,7 @@ var lexTests = []lexTest{\n \t\ttRight,\n \t\ttEOF,\n \t}},\n-\t{\"keywords\", \"{{range if else end with break continue}}\", []item{\n+\t{\"keywords\", \"{{range if else end with}}\", []item{\n \t\ttLeft,\n \t\tmkItem(itemRange, \"range\"),\n \t\ttSpace,\n@@ -203,10 +203,6 @@ var lexTests = []lexTest{\n \t\tmkItem(itemEnd, \"end\"),\n \t\ttSpace,\n \t\tmkItem(itemWith, \"with\"),\n-\t\ttSpace,\n-\t\tmkItem(itemBreak, \"break\"),\n-\t\ttSpace,\n-\t\tmkItem(itemContinue, \"continue\"),\n \t\ttRight,\n \t\ttEOF,\n \t}},"}, {"sha": "55ff46c17ab28e84875f70758cc41796651fa53e", "filename": "libgo/go/text/template/parse/node.go", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fnode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fnode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fnode.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -69,8 +69,6 @@ const (\n \tNodeTemplate                   // A template invocation action.\n \tNodeVariable                   // A $ variable.\n \tNodeWith                       // A with action.\n-\tNodeBreak                      // A break action.\n-\tNodeContinue                   // A continue action.\n )\n \n // Nodes.\n@@ -798,68 +796,6 @@ func (r *RangeNode) Copy() Node {\n \treturn r.tr.newRange(r.Pos, r.Line, r.Pipe.CopyPipe(), r.List.CopyList(), r.ElseList.CopyList())\n }\n \n-// BreakNode represents a {{break}} action.\n-type BreakNode struct {\n-\tNodeType\n-\tPos\n-\ttr *Tree\n-}\n-\n-func (t *Tree) newBreak(pos Pos) *BreakNode {\n-\treturn &BreakNode{NodeType: NodeBreak, Pos: pos, tr: t}\n-}\n-\n-func (b *BreakNode) Type() NodeType {\n-\treturn b.NodeType\n-}\n-\n-func (b *BreakNode) String() string {\n-\treturn \"{{break}}\"\n-}\n-\n-func (b *BreakNode) Copy() Node {\n-\treturn b.tr.newBreak(b.Pos)\n-}\n-\n-func (b *BreakNode) Position() Pos {\n-\treturn b.Pos\n-}\n-\n-func (b *BreakNode) tree() *Tree {\n-\treturn b.tr\n-}\n-\n-// ContinueNode represents a {{continue}} action.\n-type ContinueNode struct {\n-\tNodeType\n-\tPos\n-\ttr *Tree\n-}\n-\n-func (t *Tree) newContinue(pos Pos) *ContinueNode {\n-\treturn &ContinueNode{NodeType: NodeContinue, Pos: pos, tr: t}\n-}\n-\n-func (c *ContinueNode) Type() NodeType {\n-\treturn c.NodeType\n-}\n-\n-func (c *ContinueNode) String() string {\n-\treturn \"{{continue}}\"\n-}\n-\n-func (c *ContinueNode) Copy() Node {\n-\treturn c.tr.newContinue(c.Pos)\n-}\n-\n-func (c *ContinueNode) Position() Pos {\n-\treturn c.Pos\n-}\n-\n-func (c *ContinueNode) tree() *Tree {\n-\treturn c.tr\n-}\n-\n // WithNode represents a {{with}} action and its commands.\n type WithNode struct {\n \tBranchNode"}, {"sha": "a91a544ce016f2c5446c441dcc30a3abf5d39966", "filename": "libgo/go/text/template/parse/parse.go", "status": "modified", "additions": 6, "deletions": 38, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -23,13 +23,12 @@ type Tree struct {\n \tRoot      *ListNode // top-level root of the tree.\n \ttext      string    // text parsed to create the template (or its parent)\n \t// Parsing only; cleared after parse.\n-\tfuncs      []map[string]interface{}\n-\tlex        *lexer\n-\ttoken      [3]item // three-token lookahead for parser.\n-\tpeekCount  int\n-\tvars       []string // variables defined at the moment.\n-\ttreeSet    map[string]*Tree\n-\trangeDepth int // nesting level of range loops.\n+\tfuncs     []map[string]interface{}\n+\tlex       *lexer\n+\ttoken     [3]item // three-token lookahead for parser.\n+\tpeekCount int\n+\tvars      []string // variables defined at the moment.\n+\ttreeSet   map[string]*Tree\n }\n \n // Copy returns a copy of the Tree. Any parsing state is discarded.\n@@ -220,7 +219,6 @@ func (t *Tree) stopParse() {\n \tt.vars = nil\n \tt.funcs = nil\n \tt.treeSet = nil\n-\tt.rangeDepth = 0\n }\n \n // Parse parses the template definition string to construct a representation of\n@@ -375,10 +373,6 @@ func (t *Tree) action() (n Node) {\n \t\treturn t.templateControl()\n \tcase itemWith:\n \t\treturn t.withControl()\n-\tcase itemBreak:\n-\t\treturn t.breakControl()\n-\tcase itemContinue:\n-\t\treturn t.continueControl()\n \t}\n \tt.backup()\n \ttoken := t.peek()\n@@ -459,13 +453,7 @@ func (t *Tree) parseControl(allowElseIf bool, context string) (pos Pos, line int\n \tdefer t.popVars(len(t.vars))\n \tpipe = t.pipeline(context)\n \tvar next Node\n-\tif context == \"range\" {\n-\t\tt.rangeDepth++\n-\t}\n \tlist, next = t.itemList()\n-\tif context == \"range\" {\n-\t\tt.rangeDepth--\n-\t}\n \tswitch next.Type() {\n \tcase nodeEnd: //done\n \tcase nodeElse:\n@@ -510,26 +498,6 @@ func (t *Tree) rangeControl() Node {\n \treturn t.newRange(t.parseControl(false, \"range\"))\n }\n \n-// Break:\n-//\t{{break}}\n-// Break keyword is past.\n-func (t *Tree) breakControl() Node {\n-\tif t.rangeDepth == 0 {\n-\t\tt.errorf(\"unexpected break outside of range\")\n-\t}\n-\treturn t.newBreak(t.expect(itemRightDelim, \"break\").pos)\n-}\n-\n-// Continue:\n-//\t{{continue}}\n-// Continue keyword is past.\n-func (t *Tree) continueControl() Node {\n-\tif t.rangeDepth == 0 {\n-\t\tt.errorf(\"unexpected continue outside of range\")\n-\t}\n-\treturn t.newContinue(t.expect(itemRightDelim, \"continue\").pos)\n-}\n-\n // With:\n //\t{{with pipeline}} itemList {{end}}\n //\t{{with pipeline}} itemList {{else}} itemList {{end}}"}, {"sha": "81f14aca986cdcb8774f0c2562cc388bf6a4bb16", "filename": "libgo/go/text/template/parse/parse_test.go", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -218,12 +218,6 @@ var parseTests = []parseTest{\n \t\t`{{range $x := .SI}}{{.}}{{end}}`},\n \t{\"range 2 vars\", \"{{range $x, $y := .SI}}{{.}}{{end}}\", noError,\n \t\t`{{range $x, $y := .SI}}{{.}}{{end}}`},\n-\t{\"range []int with break\", \"{{range .SI}}{{break}}{{.}}{{end}}\", noError,\n-\t\t`{{range .SI}}{{break}}{{.}}{{end}}`},\n-\t{\"range []int with break in else\", \"{{range .SI}}{{range .SI}}{{.}}{{else}}{{break}}{{end}}{{end}}\", noError,\n-\t\t`{{range .SI}}{{range .SI}}{{.}}{{else}}{{break}}{{end}}{{end}}`},\n-\t{\"range []int with continue\", \"{{range .SI}}{{continue}}{{.}}{{end}}\", noError,\n-\t\t`{{range .SI}}{{continue}}{{.}}{{end}}`},\n \t{\"constants\", \"{{range .SI 1 -3.2i true false 'a' nil}}{{end}}\", noError,\n \t\t`{{range .SI 1 -3.2i true false 'a' nil}}{{end}}`},\n \t{\"template\", \"{{template `x`}}\", noError,\n@@ -294,12 +288,6 @@ var parseTests = []parseTest{\n \t{\"empty pipeline\", `{{printf \"%d\" ( ) }}`, hasError, \"\"},\n \t// Missing pipeline in block\n \t{\"block definition\", `{{block \"foo\"}}hello{{end}}`, hasError, \"\"},\n-\t// Invalid range control\n-\t{\"break outside of range\", `{{break}}`, hasError, \"\"},\n-\t{\"break in range else, outside of range\", `{{range .}}{{.}}{{else}}{{break}}{{end}}`, hasError, \"\"},\n-\t{\"continue outside of range\", `{{continue}}`, hasError, \"\"},\n-\t{\"continue in range else, outside of range\", `{{range .}}{{.}}{{else}}{{continue}}{{end}}`, hasError, \"\"},\n-\t{\"additional break data\", `{{range .}}{{break label}}{{end}}`, hasError, \"\"},\n }\n \n var builtins = map[string]interface{}{"}, {"sha": "2c232cf58a788cc7956298530f35fc928e64e73e", "filename": "libgo/misc/cgo/errors/src/err1.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fmisc%2Fcgo%2Ferrors%2Fsrc%2Ferr1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fmisc%2Fcgo%2Ferrors%2Fsrc%2Ferr1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Fsrc%2Ferr1.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -5,7 +5,7 @@\n package main\n \n /*\n-#cgo LDFLAGS: -c\n+#cgo LDFLAGS: -L/nonexist\n \n void test() {\n \txxx;\t\t// ERROR HERE"}, {"sha": "44587770af41ab38575fd16bfbef8cfc6cf21d2e", "filename": "libgo/misc/cgo/test/issue19832.go", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ec4de777870e2d4ff2a5de604eafd1bf0e50df/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue19832.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ec4de777870e2d4ff2a5de604eafd1bf0e50df/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue19832.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue19832.go?ref=b5ec4de777870e2d4ff2a5de604eafd1bf0e50df", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Issue 19832. Functions taking a pointer typedef were being expanded and triggering a compiler error.\n-\n-package cgotest\n-\n-// typedef struct { int i; } *PS;\n-// void T19832(PS p) {}\n-import \"C\"\n-import \"testing\"\n-\n-func test19832(t *testing.T) {\n-\tC.T19832(nil)\n-}"}, {"sha": "7205c5a5a2505250adf5bfa54909f37bb27b8798", "filename": "libgo/misc/cgo/test/issue4029.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4029.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4029.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4029.c?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -4,6 +4,25 @@\n \n // +build !windows\n \n+#include <stdint.h>\n+#include <dlfcn.h>\n+\n+// Write our own versions of dlopen/dlsym/dlclose so that we represent\n+// the opaque handle as a Go uintptr rather than a Go pointer to avoid\n+// garbage collector confusion.  See issue 23663.\n+\n+uintptr_t dlopen4029(char* name, int flags) {\n+\treturn (uintptr_t)(dlopen(name, flags));\n+}\n+\n+uintptr_t dlsym4029(uintptr_t handle, char* name) {\n+\treturn (uintptr_t)(dlsym((void*)(handle), name));\n+}\n+\n+int dlclose4029(uintptr_t handle) {\n+\treturn dlclose((void*)(handle));\n+}\n+\n void call4029(void *arg) {\n \tvoid (*fn)(void) = arg;\n \tfn();"}, {"sha": "8e468d367d1ec9d9ad21ae6b564e64293bc93057", "filename": "libgo/misc/cgo/test/issue4029.go", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4029.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adab5dd169afd191efd1dcbf50dae0f726a0a42/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4029.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4029.go?ref=9adab5dd169afd191efd1dcbf50dae0f726a0a42", "patch": "@@ -7,10 +7,15 @@\n package cgotest\n \n /*\n+#include <stdint.h>\n #include <dlfcn.h>\n #cgo linux LDFLAGS: -ldl\n \n-extern void call4029(void *arg);\n+extern uintptr_t dlopen4029(char*, int);\n+extern uintptr_t dlsym4029(uintptr_t, char*);\n+extern int dlclose4029(uintptr_t);\n+\n+extern void call4029(uintptr_t arg);\n */\n import \"C\"\n \n@@ -51,15 +56,15 @@ func test4029(t *testing.T) {\n }\n \n func loadThySelf(t *testing.T, symbol string) {\n-\tthis_process := C.dlopen(nil, C.RTLD_NOW)\n-\tif this_process == nil {\n+\tthis_process := C.dlopen4029(nil, C.RTLD_NOW)\n+\tif this_process == 0 {\n \t\tt.Error(\"dlopen:\", C.GoString(C.dlerror()))\n \t\treturn\n \t}\n-\tdefer C.dlclose(this_process)\n+\tdefer C.dlclose4029(this_process)\n \n-\tsymbol_address := C.dlsym(this_process, C.CString(symbol))\n-\tif symbol_address == nil {\n+\tsymbol_address := C.dlsym4029(this_process, C.CString(symbol))\n+\tif symbol_address == 0 {\n \t\tt.Error(\"dlsym:\", C.GoString(C.dlerror()))\n \t\treturn\n \t}"}]}