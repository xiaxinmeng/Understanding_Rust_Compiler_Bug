{"sha": "8ad02175016741bf92109e29ed27b061ca630d84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFkMDIxNzUwMTY3NDFiZjkyMTA5ZTI5ZWQyN2IwNjFjYTYzMGQ4NA==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2007-07-02T14:26:11Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2007-07-02T14:26:11Z"}, "message": "re PR tree-optimization/31966 (Miscompiles valid code with -ftree-vectorize)\n\n\tPR tree-optimization/31966\n\tPR tree-optimization/32533\n\t* tree-if-conv.c (add_to_dst_predicate_list): Use \"edge\", not\n\t\"basic_block\" description as its third argument.  Update function\n\tcalls to get destination bb from \"edge\" argument.  Save \"cond\" into\n\taux field of the edge.  Update prototype for changed arguments.\n\t(find_phi_replacement_condition): Operate on incoming edges, not\n\ton predecessor blocks.  If there is a condition saved in the\n\tincoming edge aux field, AND it with incoming bb predicate.\n\tReturn source bb of the first edge.\n\t(clean_predicate_lists): Clean aux field of outgoing node edges.\n\t(tree_if_conversion): Do not initialize cond variable. Move\n\tvariable declaration into the loop.\n\t(replace_phi_with_cond_gimple_modify_stmt): Remove unneded\n\tinitializations of new_stmt, arg0 and arg1 variables.\n\ntestsuite/ChangeLog:\n\n\tPR tree-optimization/31966\n\tPR tree-optimization/32533\n\t* gcc.dg/tree-ssa/pr31966.c: New runtime test.\n\t* gfortran.dg/pr32533.f90: Ditto.\n\nFrom-SVN: r126206", "tree": {"sha": "e6256265d9ec807148d707395d47c9e9a81a175e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6256265d9ec807148d707395d47c9e9a81a175e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ad02175016741bf92109e29ed27b061ca630d84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ad02175016741bf92109e29ed27b061ca630d84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ad02175016741bf92109e29ed27b061ca630d84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ad02175016741bf92109e29ed27b061ca630d84/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bc90eb85d96aaf4494bad8a8426f29d5d8e908bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc90eb85d96aaf4494bad8a8426f29d5d8e908bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc90eb85d96aaf4494bad8a8426f29d5d8e908bd"}], "stats": {"total": 211, "additions": 166, "deletions": 45}, "files": [{"sha": "585c547f2ee1cfcd6e86db744448e894fa553b5b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad02175016741bf92109e29ed27b061ca630d84/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad02175016741bf92109e29ed27b061ca630d84/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8ad02175016741bf92109e29ed27b061ca630d84", "patch": "@@ -1,3 +1,21 @@\n+2007-07-02  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR tree-optimization/31966\n+\tPR tree-optimization/32533\n+\t* tree-if-conv.c (add_to_dst_predicate_list): Use \"edge\", not\n+\t\"basic_block\" description as its third argument.  Update function\n+\tcalls to get destination bb from \"edge\" argument.  Save \"cond\" into\n+\taux field of the edge.  Update prototype for changed arguments.\n+\t(find_phi_replacement_condition): Operate on incoming edges, not\n+\ton predecessor blocks.  If there is a condition saved in the\n+\tincoming edge aux field, AND it with incoming bb predicate.\n+\tReturn source bb of the first edge.\n+\t(clean_predicate_lists): Clean aux field of outgoing node edges.\n+\t(tree_if_conversion): Do not initialize cond variable. Move\n+\tvariable declaration into the loop.\n+\t(replace_phi_with_cond_gimple_modify_stmt): Remove unneded\n+\tinitializations of new_stmt, arg0 and arg1 variables.\n+\n 2007-07-02  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree-nrv.c (dest_safe_for_nrv_p): Grok any handled_component_p,"}, {"sha": "496a40f43a07ddfcb012b7e42a5d4c011516c541", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad02175016741bf92109e29ed27b061ca630d84/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad02175016741bf92109e29ed27b061ca630d84/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8ad02175016741bf92109e29ed27b061ca630d84", "patch": "@@ -1,3 +1,10 @@\n+2007-07-02  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR tree-optimization/31966\n+\tPR tree-optimization/32533\n+\t* gcc.dg/tree-ssa/pr31966.c: New runtime test.\n+\t* gfortran.dg/pr32533.f90: Ditto.\n+\n 2007-07-02  Jakub Jelinek  <jakub@redhat.com>\n \n \t* g++.dg/opt/nrv12.C: New test."}, {"sha": "a18f9d041ee977fa477b4f7f6e29d67ed8c93a4e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr31966.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad02175016741bf92109e29ed27b061ca630d84/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr31966.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad02175016741bf92109e29ed27b061ca630d84/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr31966.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr31966.c?ref=8ad02175016741bf92109e29ed27b061ca630d84", "patch": "@@ -0,0 +1,50 @@\n+/* Contributed by Jack Lloyd  <lloyd@randombit.net> */\n+\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+/* { dg-options \"-O2 -ftree-vectorize -march=nocona\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+typedef unsigned long long word;\n+\n+const unsigned int MP_WORD_BITS = 64;\n+const word MP_WORD_MASK = ~((word)0);\n+const word MP_WORD_TOP_BIT = (word)1 << (8*sizeof(word) - 1);\n+\n+extern void abort (void);\n+\n+word do_div(word n1, word n0, word d)\n+{\n+  word high = n1 % d, quotient = 0;\n+  unsigned int j;\n+\n+  for(j = 0; j != MP_WORD_BITS; ++j)\n+    {\n+      word high_top_bit = (high & MP_WORD_TOP_BIT);\n+\n+      high <<= 1;\n+      high |= (n0 >> (MP_WORD_BITS-1-j)) & 1;\n+      quotient <<= 1;\n+\n+      if(high_top_bit || high >= d)\n+\t{\n+\t  high -= d;\n+\t  quotient |= 1;\n+\t}\n+    }\n+\n+  return quotient;\n+}\n+\n+int main()\n+{\n+  word result;\n+\n+  result = do_div(0x0000000000200000ll,\n+\t\t  0x0000000000000000ll,\n+\t\t  0x86E53497CE000000ll);\n+\n+  \n+  if (result != 0x3CBA83)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "c312415eb02aae06b21c6e969787c57cd47a1014", "filename": "gcc/testsuite/gfortran.dg/pr32533.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad02175016741bf92109e29ed27b061ca630d84/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32533.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad02175016741bf92109e29ed27b061ca630d84/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32533.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32533.f90?ref=8ad02175016741bf92109e29ed27b061ca630d84", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do run }\n+! { dg-options \"-O2 -ftree-vectorize -ffast-math\" }\n+!\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+!\n+SUBROUTINE T(nsubcell,sab_max,subcells)\n+  INTEGER, PARAMETER :: dp=KIND(0.0D0)\n+  REAL(dp) :: sab_max(3), subcells,nsubcell(3)\n+  nsubcell(:) = MIN(MAX(1,NINT(0.5_dp*subcells/sab_max(:))),20)\n+END SUBROUTINE T\n+\n+INTEGER, PARAMETER :: dp=KIND(0.0D0)\n+REAL(dp) :: sab_max(3), subcells,nsubcell(3)\n+subcells=2.0_dp\n+sab_max=0.590060749244805_dp\n+CALL T(nsubcell,sab_max,subcells)\n+IF (ANY(nsubcell.NE.2.0_dp)) CALL ABORT()\n+END"}, {"sha": "bd828bcf463f54b712879bd9381bcf7db3f14108", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 73, "deletions": 45, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad02175016741bf92109e29ed27b061ca630d84/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad02175016741bf92109e29ed27b061ca630d84/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=8ad02175016741bf92109e29ed27b061ca630d84", "patch": "@@ -114,7 +114,8 @@ static bool if_convertible_stmt_p (struct loop *, basic_block, tree);\n static bool if_convertible_bb_p (struct loop *, basic_block, basic_block);\n static bool if_convertible_loop_p (struct loop *, bool);\n static void add_to_predicate_list (basic_block, tree);\n-static tree add_to_dst_predicate_list (struct loop * loop, basic_block, tree, tree,\n+static tree add_to_dst_predicate_list (struct loop * loop, edge,\n+\t\t\t\t       tree, tree,\n \t\t\t\t       block_stmt_iterator *);\n static void clean_predicate_lists (struct loop *loop);\n static basic_block find_phi_replacement_condition (struct loop *loop,\n@@ -144,7 +145,6 @@ tree_if_conversion (struct loop *loop, bool for_vectorizer)\n {\n   basic_block bb;\n   block_stmt_iterator itr;\n-  tree cond;\n   unsigned int i;\n \n   ifc_bbs = NULL;\n@@ -164,11 +164,11 @@ tree_if_conversion (struct loop *loop, bool for_vectorizer)\n       return false;\n     }\n \n-  cond = NULL_TREE;\n-\n   /* Do actual work now.  */\n   for (i = 0; i < loop->num_nodes; i++)\n     {\n+      tree cond;\n+\n       bb = ifc_bbs [i];\n \n       /* Update condition using predicate list.  */\n@@ -192,7 +192,6 @@ tree_if_conversion (struct loop *loop, bool for_vectorizer)\n \t  basic_block bb_n = single_succ (bb);\n \t  if (cond != NULL_TREE)\n \t    add_to_predicate_list (bb_n, cond);\n-\t  cond = NULL_TREE;\n \t}\n     }\n \n@@ -276,12 +275,12 @@ tree_if_convert_cond_expr (struct loop *loop, tree stmt, tree cond,\n   /* Add new condition into destination's predicate list.  */\n \n   /* If 'c' is true then TRUE_EDGE is taken.  */\n-  add_to_dst_predicate_list (loop, true_edge->dest, cond,\n+  add_to_dst_predicate_list (loop, true_edge, cond,\n \t\t\t     unshare_expr (c), bsi);\n \n   /* If 'c' is false then FALSE_EDGE is taken.  */\n   c2 = invert_truthvalue (unshare_expr (c));\n-  add_to_dst_predicate_list (loop, false_edge->dest, cond, c2, bsi);\n+  add_to_dst_predicate_list (loop, false_edge, cond, c2, bsi);\n \n   /* Now this conditional statement is redundant. Remove it.\n      But, do not remove exit condition! Update exit condition\n@@ -578,7 +577,15 @@ if_convertible_loop_p (struct loop *loop, bool for_vectorizer ATTRIBUTE_UNUSED)\n       /* ??? Check data dependency for vectorizer.  */\n \n       /* What about phi nodes ? */\n-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+      phi = phi_nodes (bb);\n+\n+      /* Clear aux field of incoming edges to a bb with a phi node.  */\n+      if (phi)\n+\tFOR_EACH_EDGE (e, ei, bb->preds)\n+\t  e->aux = NULL;\n+\n+      /* Check statements.  */\n+      for (; phi; phi = PHI_CHAIN (phi))\n \tif (!if_convertible_phi_p (loop, bb, phi))\n \t  return false;\n \n@@ -615,13 +622,13 @@ add_to_predicate_list (basic_block bb, tree new_cond)\n    existing condition.  */\n \n static tree\n-add_to_dst_predicate_list (struct loop * loop, basic_block bb,\n+add_to_dst_predicate_list (struct loop * loop, edge e,\n \t\t\t   tree prev_cond, tree cond,\n \t\t\t   block_stmt_iterator *bsi)\n {\n   tree new_cond = NULL_TREE;\n \n-  if (!flow_bb_inside_loop_p (loop, bb))\n+  if (!flow_bb_inside_loop_p (loop, e->dest))\n     return NULL_TREE;\n \n   if (prev_cond == boolean_true_node || !prev_cond)\n@@ -642,29 +649,42 @@ add_to_dst_predicate_list (struct loop * loop, basic_block bb,\n       if (tmp_stmts2)\n         bsi_insert_before (bsi, tmp_stmts2, BSI_SAME_STMT);\n \n+      /* Add the condition to aux field of the edge.  In case edge\n+\t destination is a PHI node, this condition will be ANDed with\n+\t block predicate to construct complete condition.  */\n+      e->aux = cond;\n+\n       /* new_cond == prev_cond AND cond */\n       tmp = build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t    unshare_expr (prev_cond), cond);\n       tmp_stmt = ifc_temp_var (boolean_type_node, tmp);\n       bsi_insert_before (bsi, tmp_stmt, BSI_SAME_STMT);\n       new_cond = GIMPLE_STMT_OPERAND (tmp_stmt, 0);\n     }\n-  add_to_predicate_list (bb, new_cond);\n+  add_to_predicate_list (e->dest, new_cond);\n   return new_cond;\n }\n \n-/* During if-conversion aux field from basic block is used to hold predicate\n-   list. Clean each basic block's predicate list for the given LOOP.  */\n+/* During if-conversion aux field from basic block structure is used to hold\n+   predicate list. Clean each basic block's predicate list for the given LOOP.\n+   Also clean aux field of succesor edges, used to hold true and false\n+   condition from conditional expression.  */\n \n static void\n clean_predicate_lists (struct loop *loop)\n {\n   basic_block *bb;\n   unsigned int i;\n+  edge e;\n+  edge_iterator ei;\n+\n   bb = get_loop_body (loop);\n   for (i = 0; i < loop->num_nodes; i++)\n-    bb[i]->aux = NULL;\n-\n+    {\n+      bb[i]->aux = NULL;\n+      FOR_EACH_EDGE (e, ei, bb[i]->succs)\n+\te->aux = NULL;\n+    }\n   free (bb);\n }\n \n@@ -677,13 +697,12 @@ find_phi_replacement_condition (struct loop *loop,\n \t\t\t\tbasic_block bb, tree *cond,\n                                 block_stmt_iterator *bsi)\n {\n-  basic_block first_bb = NULL;\n-  basic_block second_bb = NULL;\n+  edge first_edge, second_edge;\n   tree tmp_cond, new_stmts;\n \n   gcc_assert (EDGE_COUNT (bb->preds) == 2);\n-  first_bb = (EDGE_PRED (bb, 0))->src;\n-  second_bb = (EDGE_PRED (bb, 1))->src;\n+  first_edge = EDGE_PRED (bb, 0);\n+  second_edge = EDGE_PRED (bb, 1);\n \n   /* Use condition based on following criteria:\n      1)\n@@ -704,42 +723,55 @@ find_phi_replacement_condition (struct loop *loop,\n        S3: x = (c == d) ? b : a;\n \n        S3 is preferred over S1 and S2*, Make 'b' first_bb and use \n-       its condition.  \n+       its condition.\n \n      4) If  pred B is dominated by pred A then use pred B's condition.\n         See PR23115.  */\n \n   /* Select condition that is not TRUTH_NOT_EXPR.  */\n-  tmp_cond = first_bb->aux;\n+  tmp_cond = (first_edge->src)->aux;\n   if (TREE_CODE (tmp_cond) == TRUTH_NOT_EXPR)\n     {\n-      basic_block tmp_bb;\n-      tmp_bb = first_bb;\n-      first_bb = second_bb;\n-      second_bb = tmp_bb;\n+      edge tmp_edge;\n+\n+      tmp_edge = first_edge;\n+      first_edge = second_edge;\n+      second_edge = tmp_edge;\n     }\n \n   /* Check if FIRST_BB is loop header or not and make sure that\n      FIRST_BB does not dominate SECOND_BB.  */\n-  if (first_bb == loop->header\n-      || dominated_by_p (CDI_DOMINATORS, second_bb, first_bb))\n+  if (first_edge->src == loop->header\n+      || dominated_by_p (CDI_DOMINATORS,\n+\t\t\t second_edge->src, first_edge->src))\n     {\n-      tmp_cond = second_bb->aux;\n-      if (TREE_CODE (tmp_cond) == TRUTH_NOT_EXPR)\n-\t{\n-\t  /* Select non loop header condition but do not switch basic blocks.  */\n-\t  *cond = invert_truthvalue (unshare_expr (tmp_cond));\n-\t}\n+      *cond = (second_edge->src)->aux;\n+\n+      /* If there is a condition on an incoming edge,\n+\t AND it with the incoming bb predicate.  */\n+      if (second_edge->aux)\n+\t*cond = build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t*cond, first_edge->aux);\n+\n+      if (TREE_CODE (*cond) == TRUTH_NOT_EXPR)\n+\t/* We can be smart here and choose inverted\n+\t   condition without switching bbs.  */\n+\t  *cond = invert_truthvalue (*cond);\n       else\n-\t{\n-\t  /* Select non loop header condition.  */\n-\t  first_bb = second_bb;\n-\t  *cond = first_bb->aux;\n-\t}\n+\t/* Select non loop header bb.  */\n+\tfirst_edge = second_edge;\n     }\n   else\n-    /* FIRST_BB is not loop header */\n-    *cond = first_bb->aux;\n+    {\n+      /* FIRST_BB is not loop header */\n+      *cond = (first_edge->src)->aux;\n+\n+      /* If there is a condition on an incoming edge,\n+\t AND it with the incoming bb predicate.  */\n+      if (first_edge->aux)\n+\t*cond = build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t*cond, first_edge->aux);\n+    }\n \n   /* Create temp. for the condition. Vectorizer prefers to have gimple\n      value as condition. Various targets use different means to communicate\n@@ -759,7 +791,7 @@ find_phi_replacement_condition (struct loop *loop,\n \n   gcc_assert (*cond);\n \n-  return first_bb;\n+  return first_edge->src;\n }\n \n \n@@ -791,10 +823,6 @@ replace_phi_with_cond_gimple_modify_stmt (tree phi, tree cond,\n   /* Find basic block and initialize iterator.  */\n   bb = bb_for_stmt (phi);\n \n-  new_stmt = NULL_TREE;\n-  arg_0 = NULL_TREE;\n-  arg_1 = NULL_TREE;\n-\n   /* Use condition that is not TRUTH_NOT_EXPR in conditional modify expr.  */\n   if (EDGE_PRED (bb, 1)->src == true_bb)\n     {"}]}