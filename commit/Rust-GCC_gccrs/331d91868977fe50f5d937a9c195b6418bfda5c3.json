{"sha": "331d91868977fe50f5d937a9c195b6418bfda5c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzMxZDkxODY4OTc3ZmU1MGY1ZDkzN2E5YzE5NWI2NDE4YmZkYTVjMw==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2009-05-15T07:12:03Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2009-05-15T07:12:03Z"}, "message": "frv.h: Clean up references to GO_IF_LEGITIMATE_ADDRESS.\n\n2009-05-15  Paolo Bonzini  <bonzini@gnu.org>\n\n        * config/frv/frv.h: Clean up references to GO_IF_LEGITIMATE_ADDRESS.\n        * config/frv/frv.c: Likewise.\n        * config/s390/s390.c: Likewise.\n        * config/sparc/sparc.h: Likewise.\n        * config/i386/i386.h: Likewise.\n        * config/i386/i386.c: Likewise.\n        * config/crx/crx.c: Likewise.\n        * config/m68hc11/m68hc11.h: Likewise.\n        * config/iq2000/iq2000.c: Likewise.\n        * config/mn10300/mn10300.h: Likewise.\n        * config/mn10300/mn10300.c: Likewise.\n        * config/m68k/m68k.c: Likewise.\n        * config/rs6000/rs6000.c: Likewise.\n        * config/rs6000/xcoff.h: Likewise.\n        * config/rs6000/linux64.h: Likewise.\n        * config/rs6000/sysv4.h: Likewise.\n        * config/score/score3.c: Likewise.\n        * config/score/score7.c: Likewise.\n        * config/score/score.c: Likewise.\n        * config/arm/arm.md: Likewise.\n        * config/mips/mips.c: Likewise.\n        * config/mips/mips.md: Likewise.\n        * config/bfin/bfin.h: Likewise.\n        * config/pa/pa.c: Likewise.\n        * config/pa/constraints.md: Likewise.\n\n        * config/pdp11/pdp11-protos.h (legitimate_address_p): Delete.\n        * config/pdp11/pdp11.c (legitimate_address_p): Delete.\n        * config/pdp11/pdp11.h: Use memory_address_p instead.\n\nFrom-SVN: r147560", "tree": {"sha": "e10eac6a328c0d0e11829d547d99f57f5dad7b22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e10eac6a328c0d0e11829d547d99f57f5dad7b22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/331d91868977fe50f5d937a9c195b6418bfda5c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/331d91868977fe50f5d937a9c195b6418bfda5c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/331d91868977fe50f5d937a9c195b6418bfda5c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/331d91868977fe50f5d937a9c195b6418bfda5c3/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "602b85231dd432fdad1cdb814eec39d449a33d7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/602b85231dd432fdad1cdb814eec39d449a33d7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/602b85231dd432fdad1cdb814eec39d449a33d7f"}], "stats": {"total": 160, "additions": 68, "deletions": 92}, "files": [{"sha": "b089b1d4cd1013e09e759f048e8c9a1ce280542b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -1,3 +1,35 @@\n+2009-05-15  Paolo Bonzini  <bonzini@gnu.org>\n+\n+        * config/frv/frv.h: Clean up references to GO_IF_LEGITIMATE_ADDRESS.\n+        * config/frv/frv.c: Likewise.\n+        * config/s390/s390.c: Likewise.\n+        * config/sparc/sparc.h: Likewise.\n+        * config/i386/i386.h: Likewise.\n+        * config/i386/i386.c: Likewise.\n+        * config/crx/crx.c: Likewise.\n+        * config/m68hc11/m68hc11.h: Likewise.\n+        * config/iq2000/iq2000.c: Likewise.\n+        * config/mn10300/mn10300.h: Likewise.\n+        * config/mn10300/mn10300.c: Likewise.\n+        * config/m68k/m68k.c: Likewise.\n+        * config/rs6000/rs6000.c: Likewise.\n+        * config/rs6000/xcoff.h: Likewise.\n+        * config/rs6000/linux64.h: Likewise.\n+        * config/rs6000/sysv4.h: Likewise.\n+        * config/score/score3.c: Likewise.\n+        * config/score/score7.c: Likewise.\n+        * config/score/score.c: Likewise.\n+        * config/arm/arm.md: Likewise.\n+        * config/mips/mips.c: Likewise.\n+        * config/mips/mips.md: Likewise.\n+        * config/bfin/bfin.h: Likewise.\n+        * config/pa/pa.c: Likewise.\n+        * config/pa/constraints.md: Likewise.\n+\n+        * config/pdp11/pdp11-protos.h (legitimate_address_p): Delete.\n+        * config/pdp11/pdp11.c (legitimate_address_p): Delete.\n+        * config/pdp11/pdp11.h: Use memory_address_p instead.\n+\n 2009-05-14  Ian Lance Taylor  <iant@google.com>\n \n \t* passes.c (finish_optimization_passes): Change i to int."}, {"sha": "6f4f64cf6c198b0c808d4fc5c9bc4658a45855f9", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -5476,8 +5476,8 @@\n \n           /* ??? We shouldn't really get invalid addresses here, but this can\n \t     happen if we are passed a SP (never OK for HImode/QImode) or \n-\t     virtual register (rejected by GO_IF_LEGITIMATE_ADDRESS for \n-\t     HImode/QImode) relative address.  */\n+\t     virtual register (also rejected as illegitimate for HImode/QImode)\n+\t     relative address.  */\n           /* ??? This should perhaps be fixed elsewhere, for instance, in\n \t     fixup_stack_1, by checking for other kinds of invalid addresses,\n \t     e.g. a bare reference to a virtual register.  This may confuse the\n@@ -5708,8 +5708,8 @@\n \t{\n           /* ??? We shouldn't really get invalid addresses here, but this can\n \t     happen if we are passed a SP (never OK for HImode/QImode) or\n-\t     virtual register (rejected by GO_IF_LEGITIMATE_ADDRESS for\n-\t     HImode/QImode) relative address.  */\n+\t     virtual register (also rejected as illegitimate for HImode/QImode)\n+\t     relative address.  */\n           /* ??? This should perhaps be fixed elsewhere, for instance, in\n \t     fixup_stack_1, by checking for other kinds of invalid addresses,\n \t     e.g. a bare reference to a virtual register.  This may confuse the"}, {"sha": "29e4f9108429255e5684a6897275fd372316660b", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -908,7 +908,7 @@ typedef struct {\n \n /*   A number, the maximum number of registers that can appear in a\n      valid memory address.  Note that it is up to you to specify a\n-     value equal to the maximum number that `GO_IF_LEGITIMATE_ADDRESS'\n+     value equal to the maximum number that `TARGET_LEGITIMATE_ADDRESS_P'\n      would ever accept. */\n #define MAX_REGS_PER_ADDRESS 1\n "}, {"sha": "0ea5fbca7a1a9249f1ad391943973b13c26e958e", "filename": "gcc/config/crx/crx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fcrx%2Fcrx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fcrx%2Fcrx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.c?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -545,7 +545,7 @@ crx_function_arg_regno_p (int n)\n /* ADDRESSING MODES */\n /* ---------------- */\n \n-/* Implements the macro GO_IF_LEGITIMATE_ADDRESS defined in crx.h.\n+/* Implements the hook for TARGET_LEGITIMATE_ADDRESS_P defined in crx.h.\n  * The following addressing modes are supported on CRX:\n  *\n  * Relocations\t\t--> const | symbol_ref | label_ref"}, {"sha": "c7e717e05ae501f8668f88df926e8bfc9969ce8b", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -3327,12 +3327,6 @@ frv_regno_ok_for_base_p (int regno, int strict_p)\n    conditional to define the strict variant in that case and the non-strict\n    variant otherwise.\n \n-   Subroutines to check for acceptable registers for various purposes (one for\n-   base registers, one for index registers, and so on) are typically among the\n-   subroutines used to define `GO_IF_LEGITIMATE_ADDRESS'.  Then only these\n-   subroutine macros need have two variants; the higher levels of macros may be\n-   the same whether strict or not.\n-\n    Normally, constant addresses which are the sum of a `symbol_ref' and an\n    integer are stored inside a `const' RTX to mark them as constant.\n    Therefore, there is no need to recognize such sums specifically as\n@@ -3343,22 +3337,6 @@ frv_regno_ok_for_base_p (int regno, int strict_p)\n    are not marked with `const'.  It assumes that a naked `plus' indicates\n    indexing.  If so, then you *must* reject such naked constant sums as\n    illegitimate addresses, so that none of them will be given to\n-   `PRINT_OPERAND_ADDRESS'.\n-\n-   On some machines, whether a symbolic address is legitimate depends on the\n-   section that the address refers to.  On these machines, define the macro\n-   `ENCODE_SECTION_INFO' to store the information into the `symbol_ref', and\n-   then check for it here.  When you see a `const', you will have to look\n-   inside it to find the `symbol_ref' in order to determine the section.\n-\n-   The best way to modify the name string is by adding text to the beginning,\n-   with suitable punctuation to prevent any ambiguity.  Allocate the new name\n-   in `saveable_obstack'.  You will have to modify `ASM_OUTPUT_LABELREF' to\n-   remove and decode the added text and output the name accordingly, and define\n-   `(* targetm.strip_name_encoding)' to access the original name string.\n-\n-   You can check the information stored here into the `symbol_ref' in the\n-   definitions of the macros `GO_IF_LEGITIMATE_ADDRESS' and\n    `PRINT_OPERAND_ADDRESS'.  */\n \n int\n@@ -3484,7 +3462,7 @@ frv_legitimate_address_p_1 (enum machine_mode mode,\n \n   if (TARGET_DEBUG_ADDR)\n     {\n-      fprintf (stderr, \"\\n========== GO_IF_LEGITIMATE_ADDRESS, mode = %s, result = %d, addresses are %sstrict%s\\n\",\n+      fprintf (stderr, \"\\n========== legitimate_address_p, mode = %s, result = %d, addresses are %sstrict%s\\n\",\n \t       GET_MODE_NAME (mode), ret, (strict_p) ? \"\" : \"not \",\n \t       (condexec_p) ? \", inside conditional code\" : \"\");\n       debug_rtx (x);"}, {"sha": "15047e3c7ed5223bdded3947da29bfec5866268a", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -2022,7 +2022,7 @@ __asm__(\"\\n\"\t\t\t\t\t\t\t\t\\\n \n /* A number, the maximum number of registers that can appear in a valid memory\n    address.  Note that it is up to you to specify a value equal to the maximum\n-   number that `GO_IF_LEGITIMATE_ADDRESS' would ever accept.  */\n+   number that `TARGET_LEGITIMATE_ADDRESS_P' would ever accept.  */\n #define MAX_REGS_PER_ADDRESS 2\n \n /* A C expression that is nonzero if X (assumed to be a `reg' RTX) is valid for"}, {"sha": "743618c4dea81672ce161d9756486662dad74f0a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -9258,9 +9258,9 @@ legitimate_pic_address_disp_p (rtx disp)\n   return 0;\n }\n \n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression that is a valid\n-   memory address for an instruction.  The MODE argument is the machine mode\n-   for the MEM expression that wants to use this address.\n+/* Recognizes RTL expressions that are valid memory addresses for an\n+   instruction.  The MODE argument is the machine mode for the MEM\n+   expression that wants to use this address.\n \n    It only recognizes address in canonical form.  LEGITIMIZE_ADDRESS should\n    convert common non-canonical forms to canonical form so that they will\n@@ -9527,7 +9527,7 @@ ix86_GOT_alias_set (void)\n       differentiate them from global data objects.  The returned\n       address is the PIC reg + an unspec constant.\n \n-   GO_IF_LEGITIMATE_ADDRESS rejects symbolic references unless the PIC\n+   TARGET_LEGITIMATE_ADDRESS_P rejects symbolic references unless the PIC\n    reg also appears in the address.  */\n \n static rtx\n@@ -10011,9 +10011,6 @@ legitimize_dllimport_symbol (rtx symbol, bool want_reg)\n    OLDX is the address as it was before break_out_memory_refs was called.\n    In some cases it is useful to look at this to decide what needs to be done.\n \n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n    It is always safe for this macro to do nothing.  It exists to recognize\n    opportunities to optimize the output.\n "}, {"sha": "f41ed7db665c242a1b6e708cac2b500a15e40208", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -1803,12 +1803,12 @@ typedef struct ix86_args {\n #define REG_OK_FOR_BASE_P(X)   REG_OK_FOR_BASE_STRICT_P (X)\n #endif\n \n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+/* TARGET_LEGITIMATE_ADDRESS_P recognizes an RTL expression\n    that is a valid memory address for an instruction.\n    The MODE argument is the machine mode for the MEM expression\n    that wants to use this address.\n \n-   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n+   The other macros defined here are used only in TARGET_LEGITIMATE_ADDRESS_P,\n    except for CONSTANT_ADDRESS_P which is usually machine-independent.\n \n    See legitimize_pic_address in i386.c for details as to what"}, {"sha": "5ba18886778c17875596271c010239661a13bc3b", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -258,7 +258,7 @@ iq2000_legitimate_address_p (enum machine_mode mode, rtx xinsn, bool strict)\n {\n   if (TARGET_DEBUG_A_MODE)\n     {\n-      GO_PRINTF2 (\"\\n========== GO_IF_LEGITIMATE_ADDRESS, %sstrict\\n\",\n+      GO_PRINTF2 (\"\\n========== legitimate_address_p, %sstrict\\n\",\n \t\t  strict ? \"\" : \"not \");\n       GO_DEBUG_RTX (xinsn);\n     }"}, {"sha": "e795485f9c18b77bee4f4882fb6f9f0edf7eeded", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -1132,7 +1132,7 @@ extern unsigned char m68hc11_reg_valid_for_index[FIRST_PSEUDO_REGISTER];\n /* Maximum number of registers that can appear in a valid memory address */\n #define MAX_REGS_PER_ADDRESS\t2\n \n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression that is a\n+/* TARGET_LEGITIMATE_ADDRESS_P recognizes an RTL expression that is a\n    valid memory address for an instruction. The MODE argument is the\n    machine mode for the MEM expression that wants to use this address.  */\n "}, {"sha": "3e463023625e21eb54f4dbae5a0ebc6f5f177278", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -4269,7 +4269,7 @@ strict_low_part_peephole_ok (enum machine_mode mode, rtx first_insn,\n    simple fact that the m68k does not allow a pc-relative addressing\n    mode as a destination.  gcc does not distinguish between source and\n    destination addresses.  Hence, if we claim that pc-relative address\n-   modes are valid, e.g. GO_IF_LEGITIMATE_ADDRESS accepts them, then we\n+   modes are valid, e.g. TARGET_LEGITIMATE_ADDRESS_P accepts them, then we\n    end up with invalid code.  To get around this problem, we left\n    pc-relative modes as invalid addresses, and then added special\n    predicates and constraints to accept them."}, {"sha": "ed10c391971c0b33626f3f652ecb4be061fbc387", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -2140,7 +2140,7 @@ mips_stack_address_p (rtx x, enum machine_mode mode)\n \n /* Return true if ADDR matches the pattern for the LWXS load scaled indexed\n    address instruction.  Note that such addresses are not considered\n-   legitimate in the GO_IF_LEGITIMATE_ADDRESS sense, because their use\n+   legitimate in the TARGET_LEGITIMATE_ADDRESS_P sense, because their use\n    is so restricted.  */\n \n static bool"}, {"sha": "78539cbe49db88195363954ef4892ff5c9cc7c00", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -4081,7 +4081,7 @@\n ;; instructions will still work correctly.\n \n ;; ??? Perhaps it would be better to support these instructions by\n-;; modifying GO_IF_LEGITIMATE_ADDRESS and friends.  However, since\n+;; modifying TARGET_LEGITIMATE_ADDRESS_P and friends.  However, since\n ;; these instructions can only be used to load and store floating\n ;; point registers, that would probably cause trouble in reload.\n "}, {"sha": "608f8a0fa35ed1555c02b806b88e4925c63e5c3f", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -1794,9 +1794,6 @@ symbolic_operand (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n    OLDX is the address as it was before break_out_memory_refs was called.\n    In some cases it is useful to look at this to decide what needs to be done.\n \n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n    Normally it is always safe for this macro to do nothing.  It exists to\n    recognize opportunities to optimize the output.\n "}, {"sha": "c1f3d5cd3f354b293d50d820a374d06c5ec52772", "filename": "gcc/config/pa/constraints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fpa%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fpa%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fconstraints.md?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -131,7 +131,7 @@\n \t\t\t\t\t  ? SFmode : DFmode),\n \t\t\t\t\t XEXP (op, 0))\")))\n \n-;; We could allow short displacements but GO_IF_LEGITIMATE_ADDRESS\n+;; We could allow short displacements but TARGET_LEGITIMATE_ADDRESS_P\n ;; can't tell when a long displacement is valid.\n (define_constraint \"W\"\n   \"A register indirect memory operand.\""}, {"sha": "a55f2ec01478ac3d7866ee836dad11c2eded2887", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -871,9 +871,6 @@ legitimize_tls_address (rtx addr)\n    OLDX is the address as it was before break_out_memory_refs was called.\n    In some cases it is useful to look at this to decide what needs to be done.\n \n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n    It is always safe for this macro to do nothing.  It exists to recognize\n    opportunities to optimize the output.\n "}, {"sha": "2c4bd22fde66555d49aec6e22e230d819043da33", "filename": "gcc/config/pdp11/pdp11-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -26,7 +26,6 @@ extern int expand_shift_operand (rtx, enum machine_mode);\n extern int immediate15_operand (rtx, enum machine_mode);\n extern int simple_memory_operand (rtx, enum machine_mode);\n \n-extern int legitimate_address_p (enum machine_mode, rtx);\n extern int legitimate_const_double_p (rtx);\n extern void notice_update_cc_on_set (rtx, rtx);\n extern void output_addr_const_pdp11 (FILE *, rtx);"}, {"sha": "b46760897a512aedb14d98a3984101833f6df473", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -1606,20 +1606,6 @@ output_block_move(rtx *operands)\n     return \"\";\n }\n \n-int\n-legitimate_address_p (enum machine_mode mode, rtx address)\n-{\n-/* #define REG_OK_STRICT */\n-    GO_IF_LEGITIMATE_ADDRESS(mode, address, win);\n-    \n-    return 0;\n-    \n-  win:\n-    return 1;\n-\n-/* #undef REG_OK_STRICT */\n-}\n-\n /* This function checks whether a real value can be encoded as\n    a literal, i.e., addressing mode 27.  In that mode, real values\n    are one word values, so the remaining 48 bits have to be zero.  */"}, {"sha": "ac678f5cb5b683f44b9ad61a5bb76de383df9c19", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -371,7 +371,7 @@ enum reg_class { NO_REGS, MUL_REGS, GENERAL_REGS, LOAD_FPU_REGS, NO_LOAD_FPU_REG\n \n #define EXTRA_CONSTRAINT(OP,CODE)\t\t\t\t\t\\\n   ((GET_CODE (OP) != MEM) ? 0\t\t\t\t\t\t\\\n-   : !legitimate_address_p (GET_MODE (OP), XEXP (OP, 0)) ? 0\t\t\\\n+   : !memory_address_p (GET_MODE (OP), XEXP (OP, 0)) ? 0\t\t\\\n    : ((CODE) == 'Q')\t  ? !simple_memory_operand (OP, GET_MODE (OP))\t\\\n    : ((CODE) == 'R')\t  ? simple_memory_operand (OP, GET_MODE (OP))\t\\\n    : 0)"}, {"sha": "c3193dcfe0de1fe82b6a2b0a04e97fce3842c4fc", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -471,9 +471,8 @@ extern int dot_symbols;\n    we also do this for floating-point constants.  We actually can only\n    do this if the FP formats of the target and host machines are the\n    same, but we can't check that since not every file that uses\n-   GO_IF_LEGITIMATE_ADDRESS_P includes real.h.  We also do this when\n-   we can write the entry into the TOC and the entry is not larger\n-   than a TOC entry.  */\n+   the macros includes real.h.  We also do this when we can write the\n+   entry into the TOC and the entry is not larger than a TOC entry.  */\n \n #undef  ASM_OUTPUT_SPECIAL_POOL_ENTRY_P\n #define ASM_OUTPUT_SPECIAL_POOL_ENTRY_P(X, MODE)\t\t\t\\"}, {"sha": "be2eca084b1f9d4eb6e7b80893a50f408767c876", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -3794,8 +3794,6 @@ legitimate_lo_sum_address_p (enum machine_mode mode, rtx x, int strict)\n    called.  In some cases it is useful to look at this to decide what\n    needs to be done.\n \n-   MODE is passed so that this function can use GO_IF_LEGITIMATE_ADDRESS.\n-\n    It is always safe for this function to do nothing.  It exists to\n    recognize opportunities to optimize the output.\n \n@@ -4390,7 +4388,7 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n   return x;\n }\n \n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+/* TARGET_LEGITIMATE_ADDRESS_P recognizes an RTL expression\n    that is a valid memory address for an instruction.\n    The MODE argument is the machine mode for the MEM expression\n    that wants to use this address."}, {"sha": "611c0d299c8f37e8452bf36795e1c633d382012a", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -387,8 +387,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n    containing one of them.  If -mfp-in-toc (the default), we also do\n    this for floating-point constants.  We actually can only do this\n    if the FP formats of the target and host machines are the same, but\n-   we can't check that since not every file that uses\n-   GO_IF_LEGITIMATE_ADDRESS_P includes real.h.\n+   we can't check that since not every file that uses these target macros\n+   includes real.h.\n \n    Unlike AIX, we don't key off of -mminimal-toc, but instead do not\n    allow floating point constants in the TOC if -mrelocatable.  */"}, {"sha": "6560f319a25aaa7e0f4bc1d3698507672a885a3b", "filename": "gcc/config/rs6000/xcoff.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Frs6000%2Fxcoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Frs6000%2Fxcoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fxcoff.h?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -70,10 +70,9 @@\n    or a CONST containing one of them.  If -mfp-in-toc (the default),\n    we also do this for floating-point constants.  We actually can only\n    do this if the FP formats of the target and host machines are the\n-   same, but we can't check that since not every file that uses\n-   GO_IF_LEGITIMATE_ADDRESS_P includes real.h.  We also do this when\n-   we can write the entry into the TOC and the entry is not larger\n-   than a TOC entry.  */\n+   same, but we can't check that since not every file that uses these\n+   target macros includes real.h.  We also do this when we can write the\n+   entry into the TOC and the entry is not larger than a TOC entry.  */\n \n #define ASM_OUTPUT_SPECIAL_POOL_ENTRY_P(X, MODE)\t\t\t\\\n   (TARGET_TOC\t\t\t\t\t\t\t\t\\"}, {"sha": "b1cfad1adfec3d282164cfa3fea9a2e34dc62106", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -3190,7 +3190,7 @@ s390_load_address (rtx dst, rtx src)\n       differentiate them from global data objects.  The returned\n       address is the PIC reg + an unspec constant.\n \n-   GO_IF_LEGITIMATE_ADDRESS rejects symbolic references unless the PIC\n+   TARGET_LEGITIMIZE_ADDRESS_P rejects symbolic references unless the PIC\n    reg also appears in the address.  */\n \n rtx"}, {"sha": "b75f3cfaebfac3875bb50f93e65b73ea6928d355", "filename": "gcc/config/score/score.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fscore%2Fscore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fscore%2Fscore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.c?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -533,7 +533,7 @@ score_regno_mode_ok_for_base_p (int regno, int strict)\n   gcc_unreachable ();\n }\n \n-/* Implement GO_IF_LEGITIMATE_ADDRESS macro.  */\n+/* Implement TARGET_LEGITIMIZE_ADDRESS_P.  */\n bool\n score_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n {"}, {"sha": "4258d29e525792fc4217108eb60a339372369432", "filename": "gcc/config/score/score3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fscore%2Fscore3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fscore%2Fscore3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore3.c?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -910,7 +910,7 @@ score3_regno_mode_ok_for_base_p (int regno, int strict)\n   return GP_REG_P (regno);\n }\n \n-/* Implement GO_IF_LEGITIMATE_ADDRESS macro.  */\n+/* Implement TARGET_LEGITIMATE_ADDRESS_P macro.  */\n bool\n score3_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n {"}, {"sha": "9ab6ebd3004b3a6dbf3f83750dd551fc2b9972db", "filename": "gcc/config/score/score7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fscore%2Fscore7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fscore%2Fscore7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore7.c?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -901,7 +901,7 @@ score7_regno_mode_ok_for_base_p (int regno, int strict)\n   return GP_REG_P (regno);\n }\n \n-/* Implement GO_IF_LEGITIMATE_ADDRESS macro.  */\n+/* Implement TARGET_LEGITIMATE_ADDRESS_P macro.  */\n bool\n score7_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n {"}, {"sha": "406ee68cf2f96cef97c02bdcac1aff2c2cf15ef9", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331d91868977fe50f5d937a9c195b6418bfda5c3/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=331d91868977fe50f5d937a9c195b6418bfda5c3", "patch": "@@ -1845,15 +1845,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define USE_AS_OFFSETABLE_LO10 0\n #endif\n \f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   On SPARC, the actual legitimate addresses must be REG+REG or REG+SMALLINT\n-   ordinarily.  This changes a bit when generating PIC.\n-\n-   If you change this, execute \"rm explow.o recog.o reload.o\".  */\n+/* On SPARC, the actual legitimate addresses must be REG+REG or REG+SMALLINT\n+   ordinarily.  This changes a bit when generating PIC.  The details are\n+   in sparc.c's implementation of TARGET_LEGITIMATE_ADDRESS_P.  */\n \n #define SYMBOLIC_CONST(X) symbolic_operand (X, VOIDmode)\n "}]}