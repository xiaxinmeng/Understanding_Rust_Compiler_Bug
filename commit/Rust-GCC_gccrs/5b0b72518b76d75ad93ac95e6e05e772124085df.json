{"sha": "5b0b72518b76d75ad93ac95e6e05e772124085df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWIwYjcyNTE4Yjc2ZDc1YWQ5M2FjOTVlNmUwNWU3NzIxMjQwODVkZg==", "commit": {"author": {"name": "Erik Edelmann", "email": "eedelman@gcc.gnu.org", "date": "2006-02-12T17:34:15Z"}, "committer": {"name": "Erik Edelmann", "email": "eedelman@gcc.gnu.org", "date": "2006-02-12T17:34:15Z"}, "message": "re PR fortran/25806 (problems with functions returning array pointers?)\n\nfortran/\n2006-02-12  Erik Edelmann  <eedelman@gcc.gnu.org>\n\n        PR fortran/25806\n        * trans-array.c (gfc_trans_allocate_array_storage): New argument\n        dealloc; free the temporary only if dealloc is true.\n        (gfc_trans_allocate_temp_array): New argument bool dealloc, to be \n        passed onwards to gfc_trans_allocate_array_storage.\n        (gfc_trans_array_constructor, gfc_conv_loop_setup): Update call to\n        gfc_trans_allocate_temp_array.\n        * trans-array.h (gfc_trans_allocate_temp_array): Update function\n        prototype.\n        * trans-expr.c (gfc_conv_function_call): Set new argument 'dealloc'\n        to gfc_trans_allocate_temp_array to false in case of functions\n        returning pointers.\n        (gfc_trans_arrayfunc_assign): Return NULL for functions returning\n        pointers.\n\n\ntestsuite/\n2006-02-12  Erik Edelmann  <eedelman@gcc.gnu.org>\n\n        PR fortran/25806\n        * gfortran.dg/ret_pointer_2.f90: New test.\n\nFrom-SVN: r110893", "tree": {"sha": "567b946985b670e7b860c5ac6728f1f803b19ebb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/567b946985b670e7b860c5ac6728f1f803b19ebb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b0b72518b76d75ad93ac95e6e05e772124085df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b0b72518b76d75ad93ac95e6e05e772124085df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b0b72518b76d75ad93ac95e6e05e772124085df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b0b72518b76d75ad93ac95e6e05e772124085df/comments", "author": null, "committer": null, "parents": [{"sha": "cac90078ea4d95125ad7e45c610d3859dfc1d164", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cac90078ea4d95125ad7e45c610d3859dfc1d164", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cac90078ea4d95125ad7e45c610d3859dfc1d164"}], "stats": {"total": 102, "additions": 86, "deletions": 16}, "files": [{"sha": "8551a74a91f3faf98f30977743633451ab7e55c0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b0b72518b76d75ad93ac95e6e05e772124085df/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b0b72518b76d75ad93ac95e6e05e772124085df/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5b0b72518b76d75ad93ac95e6e05e772124085df", "patch": "@@ -1,3 +1,20 @@\n+2006-02-12  Erik Edelmann  <eedelman@gcc.gnu.org>\n+\n+\tPR fortran/25806\n+\t* trans-array.c (gfc_trans_allocate_array_storage): New argument\n+\tdealloc; free the temporary only if dealloc is true.\n+\t(gfc_trans_allocate_temp_array): New argument bool dealloc, to be\n+\tpassed onwards to gfc_trans_allocate_array_storage.\n+\t(gfc_trans_array_constructor, gfc_conv_loop_setup): Update call to\n+\tgfc_trans_allocate_temp_array.\n+\t* trans-array.h (gfc_trans_allocate_temp_array): Update function\n+\tprototype.\n+\t* trans-expr.c (gfc_conv_function_call): Set new argument 'dealloc'\n+\tto gfc_trans_allocate_temp_array to false in case of functions\n+\treturning pointers.\n+\t(gfc_trans_arrayfunc_assign): Return NULL for functions returning\n+\tpointers.\n+\n 2006-02-10  Steven G. Kargl  <kargls@comcast.net>\n \n \tPR fortran/20858"}, {"sha": "5e8238b67632b75d393c223f6e69498c6b8e74e1", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b0b72518b76d75ad93ac95e6e05e772124085df/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b0b72518b76d75ad93ac95e6e05e772124085df/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=5b0b72518b76d75ad93ac95e6e05e772124085df", "patch": "@@ -479,18 +479,18 @@ gfc_set_loop_bounds_from_array_spec (gfc_interface_mapping * mapping,\n \n \n /* Generate code to allocate an array temporary, or create a variable to\n-   hold the data.  If size is NULL zero the descriptor so that so that the\n-   callee will allocate the array.  Also generates code to free the array\n-   afterwards.\n+   hold the data.  If size is NULL, zero the descriptor so that the\n+   callee will allocate the array.  If DEALLOC is true, also generate code to\n+   free the array afterwards.\n \n    Initialization code is added to PRE and finalization code to POST.\n    DYNAMIC is true if the caller may want to extend the array later\n    using realloc.  This prevents us from putting the array on the stack.  */\n \n static void\n gfc_trans_allocate_array_storage (stmtblock_t * pre, stmtblock_t * post,\n-\t\t\t\t  gfc_ss_info * info, tree size, tree nelem,\n-\t\t\t\t  bool dynamic)\n+                                  gfc_ss_info * info, tree size, tree nelem,\n+                                  bool dynamic, bool dealloc)\n {\n   tree tmp;\n   tree args;\n@@ -546,7 +546,7 @@ gfc_trans_allocate_array_storage (stmtblock_t * pre, stmtblock_t * post,\n   tmp = gfc_conv_descriptor_offset (desc);\n   gfc_add_modify_expr (pre, tmp, gfc_index_zero_node);\n \n-  if (!onstack)\n+  if (dealloc && !onstack)\n     {\n       /* Free the temporary.  */\n       tmp = gfc_conv_descriptor_data_get (desc);\n@@ -565,12 +565,13 @@ gfc_trans_allocate_array_storage (stmtblock_t * pre, stmtblock_t * post,\n    Also fills in the descriptor, data and offset fields of info if known.\n    Returns the size of the array, or NULL for a callee allocated array.\n \n-   PRE, POST and DYNAMIC are as for gfc_trans_allocate_array_storage.  */\n+   PRE, POST, DYNAMIC and DEALLOC are as for gfc_trans_allocate_array_storage.\n+ */\n \n tree\n gfc_trans_allocate_temp_array (stmtblock_t * pre, stmtblock_t * post,\n-\t\t\t       gfc_loopinfo * loop, gfc_ss_info * info,\n-\t\t\t       tree eltype, bool dynamic)\n+                               gfc_loopinfo * loop, gfc_ss_info * info,\n+                               tree eltype, bool dynamic, bool dealloc)\n {\n   tree type;\n   tree desc;\n@@ -665,7 +666,8 @@ gfc_trans_allocate_temp_array (stmtblock_t * pre, stmtblock_t * post,\n     size = fold_build2 (MULT_EXPR, gfc_array_index_type, size,\n \t\t\tTYPE_SIZE_UNIT (gfc_get_element_type (type)));\n \n-  gfc_trans_allocate_array_storage (pre, post, info, size, nelem, dynamic);\n+  gfc_trans_allocate_array_storage (pre, post, info, size, nelem, dynamic,\n+                                    dealloc);\n \n   if (info->dimen > loop->temp_dim)\n     loop->temp_dim = info->dimen;\n@@ -1416,7 +1418,7 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss)\n     }\n \n   gfc_trans_allocate_temp_array (&loop->pre, &loop->post, loop,\n-\t\t\t\t &ss->data.info, type, dynamic);\n+                                 &ss->data.info, type, dynamic, true);\n \n   desc = ss->data.info.descriptor;\n   offset = gfc_index_zero_node;\n@@ -2832,7 +2834,8 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n       loop->temp_ss->type = GFC_SS_SECTION;\n       loop->temp_ss->data.info.dimen = n;\n       gfc_trans_allocate_temp_array (&loop->pre, &loop->post, loop,\n-\t\t\t\t     &loop->temp_ss->data.info, tmp, false);\n+                                     &loop->temp_ss->data.info, tmp, false,\n+                                     true);\n     }\n \n   for (n = 0; n < loop->temp_dim; n++)"}, {"sha": "2f9fd2d74ffd5884b12a4b72202835c20d79f4f8", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b0b72518b76d75ad93ac95e6e05e772124085df/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b0b72518b76d75ad93ac95e6e05e772124085df/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=5b0b72518b76d75ad93ac95e6e05e772124085df", "patch": "@@ -32,7 +32,8 @@ void gfc_set_loop_bounds_from_array_spec (gfc_interface_mapping *,\n \n /* Generate code to allocate a temporary array.  */\n tree gfc_trans_allocate_temp_array (stmtblock_t *, stmtblock_t *,\n-\t\t\t\t    gfc_loopinfo *, gfc_ss_info *, tree, bool);\n+                                    gfc_loopinfo *, gfc_ss_info *, tree, bool,\n+                                    bool);\n \n /* Generate function entry code for allocation of compiler allocated array\n    variables.  */"}, {"sha": "3fbbf0e09e372ce4a02884a14f63c0429c036b9a", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b0b72518b76d75ad93ac95e6e05e772124085df/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b0b72518b76d75ad93ac95e6e05e772124085df/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=5b0b72518b76d75ad93ac95e6e05e772124085df", "patch": "@@ -1953,9 +1953,11 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t  /* Evaluate the bounds of the result, if known.  */\n \t  gfc_set_loop_bounds_from_array_spec (&mapping, se, sym->result->as);\n \n-\t  /* Allocate a temporary to store the result.  */\n-\t  gfc_trans_allocate_temp_array (&se->pre, &se->post,\n-\t\t\t\t\t se->loop, info, tmp, false);\n+\t  /* Allocate a temporary to store the result.  In case the function\n+             returns a pointer, the temporary will be a shallow copy and\n+             mustn't be deallocated.  */\n+          gfc_trans_allocate_temp_array (&se->pre, &se->post, se->loop, info,\n+                                         tmp, false, !sym->attr.pointer);\n \n \t  /* Zero the first stride to indicate a temporary.  */\n \t  tmp = gfc_conv_descriptor_stride (info->descriptor, gfc_rank_cst[0]);\n@@ -2913,6 +2915,10 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n   if (gfc_ref_needs_temporary_p (expr1->ref))\n     return NULL;\n \n+  /* Functions returning pointers need temporaries.  */\n+  if (expr2->symtree->n.sym->attr.pointer)\n+    return NULL;\n+\n   /* Check that no LHS component references appear during an array\n      reference. This is needed because we do not have the means to\n      span any arbitrary stride with an array descriptor. This check"}, {"sha": "845090db732d17fb503b508f294927cb63d67adc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b0b72518b76d75ad93ac95e6e05e772124085df/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b0b72518b76d75ad93ac95e6e05e772124085df/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5b0b72518b76d75ad93ac95e6e05e772124085df", "patch": "@@ -1,3 +1,8 @@\n+2006-02-12  Erik Edelmann  <eedelman@gcc.gnu.org>\n+\n+\tPR fortran/25806\n+\t* gfortran.dg/ret_pointer_2.f90: New test.\n+\n 2006-02-10  Zdenek Dvorak <dvorakz@suse.cz>\n \n \t* gcc.dg/20050105-1.c: Do not use -floop-optimize2."}, {"sha": "939411b7bc22c2dcae617e2e499d0d1a494c1ff3", "filename": "gcc/testsuite/gfortran.dg/ret_pointer_2.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b0b72518b76d75ad93ac95e6e05e772124085df/gcc%2Ftestsuite%2Fgfortran.dg%2Fret_pointer_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b0b72518b76d75ad93ac95e6e05e772124085df/gcc%2Ftestsuite%2Fgfortran.dg%2Fret_pointer_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fret_pointer_2.f90?ref=5b0b72518b76d75ad93ac95e6e05e772124085df", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do run }\n+! PR 25806: Functions returning pointers to arrays\n+program a \n+    integer, target :: storage(5)\n+    integer :: s(3)\n+\n+\n+    print *, x(3)  ! { dg-output \" *1  *2  *3\" }\n+\n+    if (ssum(x(3)) /= 6) call abort()\n+\n+    s = 0\n+    s = x(3)\n+    if (any(s /= (/1, 2, 3/))) call abort()\n+\n+contains\n+\n+    function x(n) result(t)\n+        integer, intent(in) :: n\n+        integer, pointer :: t(:)\n+        integer :: i\n+\n+        t => storage(1:n)\n+        t = (/ (i, i = 1, n) /)\n+\n+    end function x\n+\n+\n+    integer function ssum(a)\n+        integer, intent(in) :: a(:)\n+\n+        ssum = sum(a)\n+        \n+    end function ssum\n+\n+end program a\n+\n+"}]}