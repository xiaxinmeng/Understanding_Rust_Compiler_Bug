{"sha": "6ccd356e0da3245e1743988cb7faaf20b0b97013", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNjZDM1NmUwZGEzMjQ1ZTE3NDM5ODhjYjdmYWFmMjBiMGI5NzAxMw==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2004-12-23T00:10:45Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2004-12-23T00:10:45Z"}, "message": "re PR target/18896 (addressing split complex parm)\n\n\tPR target/18896\n\t* function.c (split_complex_args): Set DECL_ARTIFICIAL and DECL_IGNORED_P\n\tfor real and imaginary parts if the parm is addressable.\n\t(assign_parms_unsplit_complex): If parm addressable, save real\n\tand imaginary parts to a stack temp.  Pass assign_parm_data_all.\n\t(assign_parms): Adjust assign_parms_unsplit_complex call.\n\nFrom-SVN: r92519", "tree": {"sha": "f9983e1173a0178659ea2dcac186bfcb84c41f44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9983e1173a0178659ea2dcac186bfcb84c41f44"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ccd356e0da3245e1743988cb7faaf20b0b97013", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ccd356e0da3245e1743988cb7faaf20b0b97013", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ccd356e0da3245e1743988cb7faaf20b0b97013", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ccd356e0da3245e1743988cb7faaf20b0b97013/comments", "author": null, "committer": null, "parents": [{"sha": "44075220296e2fe935eaf9e868229f90ab051e67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44075220296e2fe935eaf9e868229f90ab051e67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44075220296e2fe935eaf9e868229f90ab051e67"}], "stats": {"total": 45, "additions": 42, "deletions": 3}, "files": [{"sha": "4c3262596b8f10f2dbeca26ee4b97eee6903ab5e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ccd356e0da3245e1743988cb7faaf20b0b97013/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ccd356e0da3245e1743988cb7faaf20b0b97013/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6ccd356e0da3245e1743988cb7faaf20b0b97013", "patch": "@@ -1,3 +1,12 @@\n+2004-12-23  Alan Modra  <amodra@bigpond.net.au>\n+\n+\tPR target/18896\n+\t* function.c (split_complex_args): Set DECL_ARTIFICIAL and DECL_IGNORED_P\n+\tfor real and imaginary parts if the parm is addressable.\n+\t(assign_parms_unsplit_complex): If parm addressable, save real\n+\tand imaginary parts to a stack temp.  Pass assign_parm_data_all.\n+\t(assign_parms): Adjust assign_parms_unsplit_complex call.\n+\n 2004-12-22  Daniel Berlin  <dberlin@dberlin.org>\n \t\n \t* tree.h (DECL_PTA_ALIASVAR): Dead."}, {"sha": "1250f36db741a330e2b7496700ca5488c00a25a6", "filename": "gcc/function.c", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ccd356e0da3245e1743988cb7faaf20b0b97013/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ccd356e0da3245e1743988cb7faaf20b0b97013/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=6ccd356e0da3245e1743988cb7faaf20b0b97013", "patch": "@@ -2049,18 +2049,28 @@ split_complex_args (tree args)\n \t{\n \t  tree decl;\n \t  tree subtype = TREE_TYPE (type);\n+\t  bool addressable = TREE_ADDRESSABLE (p);\n \n \t  /* Rewrite the PARM_DECL's type with its component.  */\n \t  TREE_TYPE (p) = subtype;\n \t  DECL_ARG_TYPE (p) = TREE_TYPE (DECL_ARG_TYPE (p));\n \t  DECL_MODE (p) = VOIDmode;\n \t  DECL_SIZE (p) = NULL;\n \t  DECL_SIZE_UNIT (p) = NULL;\n+\t  /* If this arg must go in memory, put it in a pseudo here.\n+\t     We can't allow it to go in memory as per normal parms,\n+\t     because the usual place might not have the imag part\n+\t     adjacent to the real part.  */\n+\t  DECL_ARTIFICIAL (p) = addressable;\n+\t  DECL_IGNORED_P (p) = addressable;\n+\t  TREE_ADDRESSABLE (p) = 0;\n \t  layout_decl (p, 0);\n \n \t  /* Build a second synthetic decl.  */\n \t  decl = build_decl (PARM_DECL, NULL_TREE, subtype);\n \t  DECL_ARG_TYPE (decl) = DECL_ARG_TYPE (p);\n+\t  DECL_ARTIFICIAL (decl) = addressable;\n+\t  DECL_IGNORED_P (decl) = addressable;\n \t  layout_decl (decl, 0);\n \n \t  /* Splice it in; skip the new decl.  */\n@@ -2924,9 +2934,10 @@ assign_parm_setup_stack (struct assign_parm_data_all *all, tree parm,\n    undo the frobbing that we did in assign_parms_augmented_arg_list.  */\n \n static void\n-assign_parms_unsplit_complex (tree orig_fnargs, tree fnargs)\n+assign_parms_unsplit_complex (struct assign_parm_data_all *all, tree fnargs)\n {\n   tree parm;\n+  tree orig_fnargs = all->orig_fnargs;\n \n   for (parm = orig_fnargs; parm; parm = TREE_CHAIN (parm))\n     {\n@@ -2943,7 +2954,26 @@ assign_parms_unsplit_complex (tree orig_fnargs, tree fnargs)\n \t      real = gen_lowpart_SUBREG (inner, real);\n \t      imag = gen_lowpart_SUBREG (inner, imag);\n \t    }\n-\t  tmp = gen_rtx_CONCAT (DECL_MODE (parm), real, imag);\n+\n+\t  if (TREE_ADDRESSABLE (parm))\n+\t    {\n+\t      rtx rmem, imem;\n+\t      HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (parm));\n+\n+\t      /* split_complex_arg put the real and imag parts in\n+\t\t pseudos.  Move them to memory.  */\n+\t      tmp = assign_stack_local (DECL_MODE (parm), size, 0);\n+\t      set_mem_attributes (tmp, parm, 1);\n+\t      rmem = adjust_address_nv (tmp, inner, 0);\n+\t      imem = adjust_address_nv (tmp, inner, GET_MODE_SIZE (inner));\n+\t      push_to_sequence (all->conversion_insns);\n+\t      emit_move_insn (rmem, real);\n+\t      emit_move_insn (imem, imag);\n+\t      all->conversion_insns = get_insns ();\n+\t      end_sequence ();\n+\t    }\n+\t  else\n+\t    tmp = gen_rtx_CONCAT (DECL_MODE (parm), real, imag);\n \t  SET_DECL_RTL (parm, tmp);\n \n \t  real = DECL_INCOMING_RTL (fnargs);\n@@ -3055,7 +3085,7 @@ assign_parms (tree fndecl)\n     }\n \n   if (targetm.calls.split_complex_arg && fnargs != all.orig_fnargs)\n-    assign_parms_unsplit_complex (all.orig_fnargs, fnargs);\n+    assign_parms_unsplit_complex (&all, fnargs);\n \n   /* Output all parameter conversion instructions (possibly including calls)\n      now that all parameters have been copied out of hard registers.  */"}]}