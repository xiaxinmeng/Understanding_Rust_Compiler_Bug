{"sha": "a6d1cd85ca568580c29f4e9fa778b13f513d1a37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZkMWNkODVjYTU2ODU4MGMyOWY0ZTlmYTc3OGIxM2Y1MTNkMWEzNw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-12-09T10:01:18Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-12-09T10:01:18Z"}, "message": "reginfo.c (struct subregs_of_mode_node): Remove.\n\n2010-12-09  Richard Guenther  <rguenther@suse.de>\n\n\t* reginfo.c (struct subregs_of_mode_node): Remove.\n\t(subregs_of_mode): Likewise.\n\t(som_hash): Likewise.\n\t(som_eq): Likewise.\n\t(invalid_mode_changes): New bitmap.\n\t(record_subregs_of_mode): Get subregs_of_mode argument.\n\tFill in invalid_mode_changes bitmap.\n\t(find_subregs_of_mode): Get subregs_of_mode argument and pass\n\tit through.\n\t(init_subregs_of_mode): Adjust.\n\t(finish_subregs_of_mode): Likewise.\n\t(invalid_mode_change_p): Query invalid_mode_changes bitmap.\n\nFrom-SVN: r167632", "tree": {"sha": "a41ad74d742216044c7d6ea4e18f12451eacdb15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a41ad74d742216044c7d6ea4e18f12451eacdb15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6d1cd85ca568580c29f4e9fa778b13f513d1a37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6d1cd85ca568580c29f4e9fa778b13f513d1a37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6d1cd85ca568580c29f4e9fa778b13f513d1a37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6d1cd85ca568580c29f4e9fa778b13f513d1a37/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fa1fabcbbce4ec891b5856ebd994384c6635736b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa1fabcbbce4ec891b5856ebd994384c6635736b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa1fabcbbce4ec891b5856ebd994384c6635736b"}], "stats": {"total": 116, "additions": 46, "deletions": 70}, "files": [{"sha": "7380a979f78451f6ce1eeea253bf1be0f9f6d179", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d1cd85ca568580c29f4e9fa778b13f513d1a37/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d1cd85ca568580c29f4e9fa778b13f513d1a37/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6d1cd85ca568580c29f4e9fa778b13f513d1a37", "patch": "@@ -1,3 +1,18 @@\n+2010-12-09  Richard Guenther  <rguenther@suse.de>\n+\n+\t* reginfo.c (struct subregs_of_mode_node): Remove.\n+\t(subregs_of_mode): Likewise.\n+\t(som_hash): Likewise.\n+\t(som_eq): Likewise.\n+\t(invalid_mode_changes): New bitmap.\n+\t(record_subregs_of_mode): Get subregs_of_mode argument.\n+\tFill in invalid_mode_changes bitmap.\n+\t(find_subregs_of_mode): Get subregs_of_mode argument and pass\n+\tit through.\n+\t(init_subregs_of_mode): Adjust.\n+\t(finish_subregs_of_mode): Likewise.\n+\t(invalid_mode_change_p): Query invalid_mode_changes bitmap.\n+\n 2010-12-09  Richard Guenther  <rguenther@suse.de>\n \n \t* ira.c (ira): Do not call finish_subregs_of_mode."}, {"sha": "83ac4499b517ae59be6e237c7bac533eaaebe678", "filename": "gcc/reginfo.c", "status": "modified", "additions": 31, "deletions": 70, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d1cd85ca568580c29f4e9fa778b13f513d1a37/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d1cd85ca568580c29f4e9fa778b13f513d1a37/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=a6d1cd85ca568580c29f4e9fa778b13f513d1a37", "patch": "@@ -1235,39 +1235,13 @@ reg_classes_intersect_p (reg_class_t c1, reg_class_t c2)\n \n #ifdef CANNOT_CHANGE_MODE_CLASS\n \n-struct subregs_of_mode_node\n-{\n-  unsigned int block;\n-  unsigned char modes[MAX_MACHINE_MODE];\n-};\n-\n-static htab_t subregs_of_mode;\n-\n-static hashval_t\n-som_hash (const void *x)\n-{\n-  const struct subregs_of_mode_node *const a =\n-    (const struct subregs_of_mode_node *) x;\n-  return a->block;\n-}\n-\n-static int\n-som_eq (const void *x, const void *y)\n-{\n-  const struct subregs_of_mode_node *const a =\n-    (const struct subregs_of_mode_node *) x;\n-  const struct subregs_of_mode_node *const b =\n-    (const struct subregs_of_mode_node *) y;\n-  return a->block == b->block;\n-}\n+static bitmap invalid_mode_changes;\n \n static void\n-record_subregs_of_mode (rtx subreg)\n+record_subregs_of_mode (rtx subreg, bitmap subregs_of_mode)\n {\n-  struct subregs_of_mode_node dummy, *node;\n   enum machine_mode mode;\n   unsigned int regno;\n-  void **slot;\n \n   if (!REG_P (SUBREG_REG (subreg)))\n     return;\n@@ -1278,41 +1252,41 @@ record_subregs_of_mode (rtx subreg)\n   if (regno < FIRST_PSEUDO_REGISTER)\n     return;\n \n-  dummy.block = regno & -8;\n-  slot = htab_find_slot_with_hash (subregs_of_mode, &dummy,\n-\t\t\t\t   dummy.block, INSERT);\n-  node = (struct subregs_of_mode_node *) *slot;\n-  if (node == NULL)\n+  if (bitmap_set_bit (subregs_of_mode,\n+\t\t      regno * NUM_MACHINE_MODES + (unsigned int) mode))\n     {\n-      node = XCNEW (struct subregs_of_mode_node);\n-      node->block = regno & -8;\n-      *slot = node;\n+      unsigned int rclass;\n+      for (rclass = 0; rclass < N_REG_CLASSES; rclass++)\n+\tif (!bitmap_bit_p (invalid_mode_changes,\n+\t\t\t   regno * N_REG_CLASSES + rclass)\n+\t    && CANNOT_CHANGE_MODE_CLASS (PSEUDO_REGNO_MODE (regno),\n+\t\t\t\t\t mode, (enum reg_class) rclass))\n+\t  bitmap_set_bit (invalid_mode_changes,\n+\t\t\t  regno * N_REG_CLASSES + rclass);\n     }\n-\n-  node->modes[mode] |= 1 << (regno & 7);\n }\n \n /* Call record_subregs_of_mode for all the subregs in X.  */\n static void\n-find_subregs_of_mode (rtx x)\n+find_subregs_of_mode (rtx x, bitmap subregs_of_mode)\n {\n   enum rtx_code code = GET_CODE (x);\n   const char * const fmt = GET_RTX_FORMAT (code);\n   int i;\n \n   if (code == SUBREG)\n-    record_subregs_of_mode (x);\n+    record_subregs_of_mode (x, subregs_of_mode);\n \n   /* Time for some deep diving.  */\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tfind_subregs_of_mode (XEXP (x, i));\n+\tfind_subregs_of_mode (XEXP (x, i), subregs_of_mode);\n       else if (fmt[i] == 'E')\n \t{\n \t  int j;\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t    find_subregs_of_mode (XVECEXP (x, i, j));\n+\t    find_subregs_of_mode (XVECEXP (x, i, j), subregs_of_mode);\n \t}\n     }\n }\n@@ -1322,50 +1296,37 @@ init_subregs_of_mode (void)\n {\n   basic_block bb;\n   rtx insn;\n+  bitmap_obstack srom_obstack;\n+  bitmap subregs_of_mode;\n \n-  if (subregs_of_mode)\n-    htab_empty (subregs_of_mode);\n-  else\n-    subregs_of_mode = htab_create (100, som_hash, som_eq, free);\n+  gcc_assert (invalid_mode_changes == NULL);\n+  invalid_mode_changes = BITMAP_ALLOC (NULL);\n+  bitmap_obstack_initialize (&srom_obstack);\n+  subregs_of_mode = BITMAP_ALLOC (&srom_obstack);\n \n   FOR_EACH_BB (bb)\n     FOR_BB_INSNS (bb, insn)\n-    if (NONDEBUG_INSN_P (insn))\n-      find_subregs_of_mode (PATTERN (insn));\n+      if (NONDEBUG_INSN_P (insn))\n+        find_subregs_of_mode (PATTERN (insn), subregs_of_mode);\n+\n+  BITMAP_FREE (subregs_of_mode);\n+  bitmap_obstack_release (&srom_obstack);\n }\n \n /* Return 1 if REGNO has had an invalid mode change in CLASS from FROM\n    mode.  */\n bool\n invalid_mode_change_p (unsigned int regno,\n-\t\t       enum reg_class rclass ATTRIBUTE_UNUSED)\n+\t\t       enum reg_class rclass)\n {\n-  struct subregs_of_mode_node dummy, *node;\n-  unsigned int to;\n-  unsigned char mask;\n-  enum machine_mode from = PSEUDO_REGNO_MODE (regno);\n-\n-  gcc_assert (subregs_of_mode);\n-  dummy.block = regno & -8;\n-  node = (struct subregs_of_mode_node *)\n-    htab_find_with_hash (subregs_of_mode, &dummy, dummy.block);\n-  if (node == NULL)\n-    return false;\n-\n-  mask = 1 << (regno & 7);\n-  for (to = VOIDmode; to < NUM_MACHINE_MODES; to++)\n-    if (node->modes[to] & mask)\n-      if (CANNOT_CHANGE_MODE_CLASS (from, (enum machine_mode) to, rclass))\n-\treturn true;\n-\n-  return false;\n+  return bitmap_bit_p (invalid_mode_changes,\n+\t\t       regno * N_REG_CLASSES + (unsigned) rclass);\n }\n \n void\n finish_subregs_of_mode (void)\n {\n-  htab_delete (subregs_of_mode);\n-  subregs_of_mode = 0;\n+  BITMAP_FREE (invalid_mode_changes);\n }\n #else\n void"}]}