{"sha": "7221f080227636b16826313a5148999c777d8b67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzIyMWYwODAyMjc2MzZiMTY4MjYzMTNhNTE0ODk5OWM3NzdkOGI2Nw==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1999-02-02T11:52:00Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1999-02-02T11:52:00Z"}, "message": "(recombine_givs): Don't use a giv that's likely to be dead to derive others.\n\n\t* (recombine_givs): Don't use a giv that's likely to be dead to\n\tderive others.\n\t* loop.c (recombine_givs): Fix test for lifetime overlaps / loop\n\twrap around when deriving givs.\n\nFrom-SVN: r24967", "tree": {"sha": "9289d57fce739fc33850e22a887d052e865e60fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9289d57fce739fc33850e22a887d052e865e60fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7221f080227636b16826313a5148999c777d8b67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7221f080227636b16826313a5148999c777d8b67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7221f080227636b16826313a5148999c777d8b67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7221f080227636b16826313a5148999c777d8b67/comments", "author": null, "committer": null, "parents": [{"sha": "e77dbc56f903af3ca76d16c29d8061385cf80e52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e77dbc56f903af3ca76d16c29d8061385cf80e52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e77dbc56f903af3ca76d16c29d8061385cf80e52"}], "stats": {"total": 34, "additions": 29, "deletions": 5}, "files": [{"sha": "cf302bc48f1ab7b77be94f40039699b891ef7602", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7221f080227636b16826313a5148999c777d8b67/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7221f080227636b16826313a5148999c777d8b67/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7221f080227636b16826313a5148999c777d8b67", "patch": "@@ -1,3 +1,11 @@\n+Tue Feb  2 19:48:29 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* (recombine_givs): Don't use a giv that's likely to be dead to\n+\tderive others.\n+\n+\t* loop.c (recombine_givs): Fix test for lifetime overlaps / loop\n+\twrap around when deriving givs.\n+\n Mon Feb  1 20:00:40 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* recog.c (check_asm_operands): Treat indeterminate operand ok"}, {"sha": "8323a273c6ab568ff8339b4899391c7ad6f75bc4", "filename": "gcc/loop.c", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7221f080227636b16826313a5148999c777d8b67/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7221f080227636b16826313a5148999c777d8b67/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=7221f080227636b16826313a5148999c777d8b67", "patch": "@@ -7293,16 +7293,28 @@ recombine_givs (bl, loop_start, loop_end, unroll_p)\n \t    continue;\n \t  if (! last_giv)\n \t    {\n-\t      last_giv = v;\n-\t      life_start = stats[i].start_luid;\n-\t      life_end = stats[i].end_luid;\n+\t      /* Don't use a giv that's likely to be dead to derive\n+\t\t others - that would be likely to keep that giv alive.  */\n+\t      if (! v->maybe_dead || v->combined_with)\n+\t\t{\n+\t\t  last_giv = v;\n+\t\t  life_start = stats[i].start_luid;\n+\t\t  life_end = stats[i].end_luid;\n+\t\t}\n \t      continue;\n \t    }\n \t  /* Use unsigned arithmetic to model loop wrap around.  */\n \t  if (((unsigned) stats[i].start_luid - life_start\n \t       >= (unsigned) life_end - life_start)\n \t      && ((unsigned) stats[i].end_luid - life_start\n-\t\t  >= (unsigned) life_end - life_start)\n+\t\t  > (unsigned) life_end - life_start)\n+\t      /*  Check that the giv insn we're about to use for deriving\n+\t\t  precedes all uses of that giv.  Note that initializing the\n+\t\t  derived giv would defeat the purpose of reducing register\n+\t\t  pressure.\n+\t\t  ??? We could arrange to move the insn.  */\n+\t      && ((unsigned) stats[i].end_luid - INSN_LUID (loop_start)\n+                  > (unsigned) stats[i].start_luid - INSN_LUID (loop_start))\n \t      && rtx_equal_p (last_giv->mult_val, v->mult_val)\n \t      /* ??? Could handle libcalls, but would need more logic.  */\n \t      && ! find_reg_note (v->insn, REG_RETVAL, NULL_RTX)\n@@ -7312,7 +7324,11 @@ recombine_givs (bl, loop_start, loop_end, unroll_p)\n \t\t don't have this detailed control flow information.\n \t\t N.B. since last_giv will be reduced, it is valid\n \t\t anywhere in the loop, so we don't need to check the\n-\t\t validity of last_giv.  */\n+\t\t validity of last_giv.\n+\t\t We rely here on the fact that v->always_executed implies that\n+\t\t there is no jump to someplace else in the loop before the\n+\t\t giv insn, and hence any insn that is executed before the\n+\t\t giv insn in the loop will have a lower luid.  */\n \t      && (v->always_executed || ! v->combined_with)\n \t      && (sum = express_from (last_giv, v))\n \t      /* Make sure we don't make the add more expensive.  ADD_COST"}]}