{"sha": "63d77adf435de2c2f21672da6c39927653bf8333", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNkNzdhZGY0MzVkZTJjMmYyMTY3MmRhNmMzOTkyNzY1M2JmODMzMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-09-28T18:05:08Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-09-28T18:05:08Z"}, "message": "Make both assembler syntaxes do the same for PIC calls.\n\nFrom-SVN: r10410", "tree": {"sha": "a2d275165a1fce1b60a0cf5d7a3a7d1cb01ccc1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2d275165a1fce1b60a0cf5d7a3a7d1cb01ccc1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63d77adf435de2c2f21672da6c39927653bf8333", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63d77adf435de2c2f21672da6c39927653bf8333", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63d77adf435de2c2f21672da6c39927653bf8333", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63d77adf435de2c2f21672da6c39927653bf8333/comments", "author": null, "committer": null, "parents": [{"sha": "c57eee671195eb511c607b0b61d0f4b560a0db68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c57eee671195eb511c607b0b61d0f4b560a0db68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c57eee671195eb511c607b0b61d0f4b560a0db68"}], "stats": {"total": 41, "additions": 19, "deletions": 22}, "files": [{"sha": "4c54862370c4aaf4fabc5cb0c1e06cb3eb3673f1", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63d77adf435de2c2f21672da6c39927653bf8333/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63d77adf435de2c2f21672da6c39927653bf8333/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=63d77adf435de2c2f21672da6c39927653bf8333", "patch": "@@ -5827,23 +5827,22 @@\n }\")\n \n \n+;; For PIC calls, in order to be able to support\n+;; dynamic linker LAZY BINDING, all the procedure calls need to go \n+;; through the PLT (Procedure Linkage Table) section in PIC mode.\n+;;\n ;; PIC calls are handled by loading the address of the function into a \n ;; register (via movsi), then emitting a register indirect call using\n ;; the \"jsr\" function call syntax.\n ;;\n-;; It is important to note that the \"jsr\" syntax is always used for \n-;; PIC calls, even on machines in which GCC normally uses the \"jbsr\"\n-;; syntax for non-PIC calls.  This keeps at least 1 assembler (Sun)\n-;; from emitting incorrect code for a PIC call.\n+;; When outputting MIT syntax (e.g. on Suns), we add a bogus extra\n+;; operand to the jbsr statement to indicate that this call should\n+;; go through the PLT (why? because this is the way that Sun does it).\n ;;\n ;; We have different patterns for PIC calls and non-PIC calls.  The\n-;; different patterns are only used to choose the right syntax\n-;; (\"jsr\" vs \"jbsr\").\n+;; different patterns are only used to choose the right syntax.\n ;;\n-;; On svr4 m68k, PIC stuff is done differently. To be able to support\n-;; dynamic linker LAZY BINDING, all the procedure calls need to go \n-;; through the PLT (Procedure Linkage Table) section in PIC mode. The \n-;; svr4 m68k assembler recognizes this syntax: `bsr FUNC@PLTPC' and it \n+;; The svr4 m68k assembler recognizes this syntax: `bsr FUNC@PLTPC' and it \n ;; will create the correct relocation entry (R_68K_PLT32) for `FUNC', \n ;; that tells the linker editor to create an entry for `FUNC' in PLT\n ;; section at link time. However, all global objects reference are still\n@@ -5875,12 +5874,7 @@\n   \"\n {\n   if (flag_pic && GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF)\n-#ifdef MOTOROLA\n     SYMBOL_REF_FLAG (XEXP (operands[0], 0)) = 1;\n-#else\n-    operands[0] = gen_rtx (MEM, GET_MODE (operands[0]),\n-\t\t\t   force_reg (Pmode, XEXP (operands[0], 0)));\n-#endif\n }\")\n \n ;; This is a normal call sequence.\n@@ -5911,9 +5905,9 @@\n \n   \"flag_pic\"\n   \"*\n-#ifdef MOTOROLA\n   if (GET_CODE (operands[0]) == MEM \n       && GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF)\n+#ifdef MOTOROLA\n #ifdef HPUX_ASM\n     return \\\"bsr.l %0\\\";\n #else\n@@ -5923,6 +5917,10 @@\n     return \\\"bsr %0@PLTPC\\\";\n #endif\n #endif\n+#else\n+    /* The ',a1' is a dummy argument telling the Sun assembler we want PIC,\n+       GAS just plain ignores it.  */\n+    return \\\"jbsr %0,a1\\\";\n #endif\n   return \\\"jsr %0\\\";\n \")\n@@ -5939,12 +5937,7 @@\n   \"\n {\n   if (flag_pic && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF)\n-#ifdef MOTOROLA\n     SYMBOL_REF_FLAG (XEXP (operands[1], 0)) = 1;\n-#else\n-    operands[1] = gen_rtx (MEM, GET_MODE (operands[1]),\n-\t\t\t   force_reg (Pmode, XEXP (operands[1], 0)));\n-#endif\n }\")\n \n ;; This is a normal call_value\n@@ -5975,9 +5968,9 @@\n   ;; Operand 2 not really used on the m68000.\n   \"flag_pic\"\n   \"*\n-#ifdef MOTOROLA\n   if (GET_CODE (operands[1]) == MEM \n       && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF)\n+#ifdef MOTOROLA\n #ifdef HPUX_ASM\n     return \\\"bsr.l %1\\\";\n #else\n@@ -5987,6 +5980,10 @@\n     return \\\"bsr %1@PLTPC\\\";\n #endif\n #endif\n+#else\n+    /* The ',a1' is a dummy argument telling the Sun assembler we want PIC\n+       GAS just plain ignores it.  */\n+    return \\\"jbsr %1,a1\\\";\n #endif\n   return \\\"jsr %1\\\";\n \")"}]}