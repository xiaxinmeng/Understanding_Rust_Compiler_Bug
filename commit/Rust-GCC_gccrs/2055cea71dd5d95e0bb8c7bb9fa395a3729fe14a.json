{"sha": "2055cea71dd5d95e0bb8c7bb9fa395a3729fe14a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA1NWNlYTcxZGQ1ZDk1ZTBiYjhjN2JiOWZhMzk1YTM3MjlmZTE0YQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1991-11-27T14:45:36Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1991-11-27T14:45:36Z"}, "message": "Initial revision\n\nFrom-SVN: r76", "tree": {"sha": "37c3f48ec6df430923fa7fa7e6be780507f68e45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37c3f48ec6df430923fa7fa7e6be780507f68e45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2055cea71dd5d95e0bb8c7bb9fa395a3729fe14a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2055cea71dd5d95e0bb8c7bb9fa395a3729fe14a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2055cea71dd5d95e0bb8c7bb9fa395a3729fe14a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2055cea71dd5d95e0bb8c7bb9fa395a3729fe14a/comments", "author": null, "committer": null, "parents": [{"sha": "f12b3074c5ad03379166517525522832d508d037", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f12b3074c5ad03379166517525522832d508d037", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f12b3074c5ad03379166517525522832d508d037"}], "stats": {"total": 1901, "additions": 1901, "deletions": 0}, "files": [{"sha": "8ba3a601c5adb583bfebe648177c2b93654b23c7", "filename": "gcc/recog.c", "status": "added", "additions": 1901, "deletions": 0, "changes": 1901, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2055cea71dd5d95e0bb8c7bb9fa395a3729fe14a/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2055cea71dd5d95e0bb8c7bb9fa395a3729fe14a/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=2055cea71dd5d95e0bb8c7bb9fa395a3729fe14a", "patch": "@@ -0,0 +1,1901 @@\n+/* Subroutines used by or related to instruction recognition.\n+   Copyright (C) 1987-1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include <stdio.h>\n+#include \"insn-config.h\"\n+#include \"insn-attr.h\"\n+#include \"insn-flags.h\"\n+#include \"insn-codes.h\"\n+#include \"recog.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"flags.h\"\n+#include \"real.h\"\n+\n+#ifndef STACK_PUSH_CODE\n+#ifdef STACK_GROWS_DOWNWARD\n+#define STACK_PUSH_CODE PRE_DEC\n+#else\n+#define STACK_PUSH_CODE PRE_INC\n+#endif\n+#endif\n+\n+/* Import from final.c: */\n+extern rtx alter_subreg ();\n+\n+int strict_memory_address_p ();\n+int memory_address_p ();\n+\n+/* Nonzero means allow operands to be volatile.\n+   This should be 0 if you are generating rtl, such as if you are calling\n+   the functions in optabs.c and expmed.c (most of the time).\n+   This should be 1 if all valid insns need to be recognized,\n+   such as in regclass.c and final.c and reload.c.\n+\n+   init_recog and init_recog_no_volatile are responsible for setting this.  */\n+\n+int volatile_ok;\n+\n+/* On return from `constrain_operands', indicate which alternative\n+   was satisfied.  */\n+\n+int which_alternative;\n+\n+/* Nonzero after end of reload pass.\n+   Set to 1 or 0 by toplev.c.\n+   Controls the significance of (SUBREG (MEM)).  */\n+\n+int reload_completed;\n+\n+/* Initialize data used by the function `recog'.\n+   This must be called once in the compilation of a function\n+   before any insn recognition may be done in the function.  */\n+\n+void\n+init_recog_no_volatile ()\n+{\n+  volatile_ok = 0;\n+}\n+\n+init_recog ()\n+{\n+  volatile_ok = 1;\n+}\n+\n+/* Try recognizing the instruction INSN,\n+   and return the code number that results.\n+   Remeber the code so that repeated calls do not\n+   need to spend the time for actual rerecognition.\n+\n+   This function is the normal interface to instruction recognition.\n+   The automatically-generated function `recog' is normally called\n+   through this one.  (The only exception is in combine.c.)  */\n+\n+int\n+recog_memoized (insn)\n+     rtx insn;\n+{\n+  if (INSN_CODE (insn) < 0)\n+    INSN_CODE (insn) = recog (PATTERN (insn), insn, 0);\n+  return INSN_CODE (insn);\n+}\n+\f\n+/* Check that X is an insn-body for an `asm' with operands\n+   and that the operands mentioned in it are legitimate.  */\n+\n+int\n+check_asm_operands (x)\n+     rtx x;\n+{\n+  int noperands = asm_noperands (x);\n+  rtx *operands;\n+  int i;\n+\n+  if (noperands < 0)\n+    return 0;\n+  if (noperands == 0)\n+    return 1;\n+\n+  operands = (rtx *) alloca (noperands * sizeof (rtx));\n+  decode_asm_operands (x, operands, 0, 0, 0);\n+\n+  for (i = 0; i < noperands; i++)\n+    if (!general_operand (operands[i], VOIDmode))\n+      return 0;\n+\n+  return 1;\n+}\n+\f\n+/* Static data for the next two routines.\n+\n+   The maximum number of changes supported is defined as the maximum\n+   number of operands times 5.  This allows for repeated substitutions\n+   inside complex indexed address, or, alternatively, changes in up\n+   to 5 insns.  */\n+\n+#define MAX_CHANGE_LOCS\t(MAX_RECOG_OPERANDS * 5)\n+\n+static rtx change_objects[MAX_CHANGE_LOCS];\n+static int change_old_codes[MAX_CHANGE_LOCS];\n+static rtx *change_locs[MAX_CHANGE_LOCS];\n+static rtx change_olds[MAX_CHANGE_LOCS];\n+\n+static int num_changes = 0;\n+\n+/* Validate a proposed change to OBJECT.  LOC is the location in the rtl for\n+   at which NEW will be placed.  If OBJECT is zero, no validation is done,\n+   the change is simply made.\n+\n+   Two types of objects are supported:  If OBJECT is a MEM, memory_address_p\n+   will be called with the address and mode as parameters.  If OBJECT is\n+   an INSN, CALL_INSN, or JUMP_INSN, the insn will be re-recognized with\n+   the change in place.\n+\n+   IN_GROUP is non-zero if this is part of a group of changes that must be\n+   performed as a group.  In that case, the changes will be stored.  The\n+   function `apply_change_group' will validate and apply the changes.\n+\n+   If IN_GROUP is zero, this is a single change.  Try to recognize the insn\n+   or validate the memory reference with the change applied.  If the result\n+   is not valid for the machine, suppress the change and return zero.\n+   Otherwise, perform the change and return 1.  */\n+\n+int\n+validate_change (object, loc, new, in_group)\n+    rtx object;\n+    rtx *loc;\n+    rtx new;\n+    int in_group;\n+{\n+  rtx old = *loc;\n+\n+  if (old == new || rtx_equal_p (old, new))\n+    return 1;\n+\n+  if (num_changes >= MAX_CHANGE_LOCS\n+      || (in_group == 0 && num_changes != 0))\n+    abort ();\n+\n+  *loc = new;\n+\n+  /* Save the information describing this change.  */\n+  change_objects[num_changes] = object;\n+  change_locs[num_changes] = loc;\n+  change_olds[num_changes] = old;\n+\n+  if (object && GET_CODE (object) != MEM)\n+    {\n+      /* Set INSN_CODE to force rerecognition of insn.  Save old code in\n+\t case invalid.  */\n+      change_old_codes[num_changes] = INSN_CODE (object);\n+      INSN_CODE (object) = -1;\n+    }\n+\n+  num_changes++;\n+\n+  /* If we are making a group of changes, return 1.  Otherwise, validate the\n+     change group we made.  */\n+\n+  if (in_group)\n+    return 1;\n+  else\n+    return apply_change_group ();\n+}\n+\n+/* Apply a group of changes previously issued with `validate_change'.\n+   Return 1 if all changes are valid, zero otherwise.  */\n+\n+int\n+apply_change_group ()\n+{\n+  int i;\n+\n+  /* The changes have been applied and all INSN_CODEs have been reset to force\n+     rerecognition.\n+\n+     The changes are valid if we aren't given an object, or if we are\n+     given a MEM and it still is a valid address, or if this is in insn\n+     and it is recognized.  In the latter case, if reload has completed,\n+     we also require that the operands meet the constraints for\n+     the insn.  We do not allow modifying an ASM_OPERANDS after reload\n+     has completed because verifying the constraints is too difficult.  */\n+\n+  for (i = 0; i < num_changes; i++)\n+    {\n+      rtx object = change_objects[i];\n+\n+      if (object == 0)\n+\tcontinue;\n+\n+      if (GET_CODE (object) == MEM)\n+\t{\n+\t  if (! memory_address_p (GET_MODE (object), XEXP (object, 0)))\n+\t    break;\n+\t}\n+      else if ((recog_memoized (object) < 0\n+\t\t&& (asm_noperands (PATTERN (object)) < 0\n+\t\t    || ! check_asm_operands (PATTERN (object))\n+\t\t    || reload_completed))\n+\t       || (reload_completed\n+\t\t   && (insn_extract (object),\n+\t\t       ! constrain_operands (INSN_CODE (object), 1))))\n+\t{\n+\t  rtx pat = PATTERN (object);\n+\n+\t  /* Perhaps we couldn't recognize the insn because there were\n+\t     extra CLOBBERs at the end.  If so, try to re-recognize\n+\t     without the last CLOBBER (later iterations will cause each of\n+\t     them to be eliminated, in turn).  But don't do this if we\n+\t     have an ASM_OPERAND.  */\n+\t  if (GET_CODE (pat) == PARALLEL\n+\t      && GET_CODE (XVECEXP (pat, 0, XVECLEN (pat, 0) - 1)) == CLOBBER\n+\t      && asm_noperands (PATTERN (object)) < 0)\n+\t    {\n+\t       rtx newpat;\n+\n+\t       if (XVECLEN (pat, 0) == 2)\n+\t\t newpat = XVECEXP (pat, 0, 0);\n+\t       else\n+\t\t {\n+\t\t   int j;\n+\n+\t\t   newpat = gen_rtx (PARALLEL, VOIDmode, \n+\t\t\t\t     gen_rtvec (XVECLEN (pat, 0) - 1));\n+\t\t   for (j = 0; j < XVECLEN (newpat, 0); j++)\n+\t\t     XVECEXP (newpat, 0, j) = XVECEXP (pat, 0, j);\n+\t\t }\n+\n+\t       /* Add a new change to this group to replace the pattern\n+\t\t  with this new pattern.  Then consider this change\n+\t\t  as having succeeded.  The change we added will\n+\t\t  cause the entire call to fail if things remain invalid.\n+\n+\t\t  Note that this can lose if a later change than the one\n+\t\t  we are processing specified &XVECEXP (PATTERN (object), 0, X)\n+\t\t  but this shouldn't occur.  */\n+\n+\t       validate_change (object, &PATTERN (object), newpat, 1);\n+\t     }\n+\t  else if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n+\t    /* If this insn is a CLOBBER or USE, it is always valid, but is\n+\t       never recognized.  */\n+\t    continue;\n+\t  else\n+\t    break;\n+\t}\n+    }\n+\n+  if (i == num_changes)\n+    {\n+      num_changes = 0;\n+      return 1;\n+    }\n+  else\n+    {\n+      cancel_changes (0);\n+      return 0;\n+    }\n+}\n+\n+/* Return the number of changes so far in the current group.   */\n+\n+int\n+num_validated_changes ()\n+{\n+  return num_changes;\n+}\n+\n+/* Retract the changes numbered NUM and up.  */\n+\n+void\n+cancel_changes (num)\n+     int num;\n+{\n+  int i;\n+\n+  /* Back out all the changes.  Do this in the opposite order in which\n+     they were made.  */\n+  for (i = num_changes - 1; i >= num; i--)\n+    {\n+      *change_locs[i] = change_olds[i];\n+      if (change_objects[i] && GET_CODE (change_objects[i]) != MEM)\n+\tINSN_CODE (change_objects[i]) = change_old_codes[i];\n+    }\n+  num_changes = num;\n+}\n+\n+/* Replace every occurrence of FROM in X with TO.  Mark each change with\n+   validate_change passing OBJECT.  */\n+\n+static void\n+validate_replace_rtx_1 (loc, from, to, object)\n+     rtx *loc;\n+     rtx from, to, object;\n+{\n+  register int i, j;\n+  register char *fmt;\n+  register rtx x = *loc;\n+  enum rtx_code code = GET_CODE (x);\n+\n+  /* X matches FROM if it is the same rtx or they are both referring to the\n+     same register in the same mode.  Avoid calling rtx_equal_p unless the\n+     operands look similar.  */\n+\n+  if (x == from\n+      || (GET_CODE (x) == REG && GET_CODE (from) == REG\n+\t  && GET_MODE (x) == GET_MODE (from)\n+\t  && REGNO (x) == REGNO (from))\n+      || (GET_CODE (x) == GET_CODE (from) && GET_MODE (x) == GET_MODE (from)\n+\t  && rtx_equal_p (x, from)))\n+    {\n+      validate_change (object, loc, to, 1);\n+      return;\n+    }\n+\n+  /* For commutative or comparison operations, try replacing each argument\n+     separately and seeing if we made any changes.  If so, put a constant\n+     argument last.*/\n+  if (GET_RTX_CLASS (code) == '<' || GET_RTX_CLASS (code) == 'c')\n+    {\n+      int prev_changes = num_changes;\n+\n+      validate_replace_rtx_1 (&XEXP (x, 0), from, to, object);\n+      validate_replace_rtx_1 (&XEXP (x, 1), from, to, object);\n+      if (prev_changes != num_changes && CONSTANT_P (XEXP (x, 0)))\n+\t{\n+\t  validate_change (object, loc,\n+\t\t\t   gen_rtx (GET_RTX_CLASS (code) == 'c' ? code\n+\t\t\t\t    : swap_condition (code),\n+\t\t\t\t    GET_MODE (x), XEXP (x, 1), XEXP (x, 0)),\n+\t\t\t   1);\n+\t  x = *loc;\n+\t  code = GET_CODE (x);\n+\t}\n+    }\n+\n+  switch (code)\n+    {\n+    case PLUS:\n+      /* If we have have a PLUS whose second operand is now a CONST_INT, use\n+\t plus_constant to try to simplify it.  */\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT && XEXP (x, 1) == to)\n+\tvalidate_change (object, loc, \n+\t\t\t plus_constant (XEXP (x, 0), INTVAL (XEXP (x, 1))), 1);\n+      return;\n+      \n+    case ZERO_EXTEND:\n+    case SIGN_EXTEND:\n+      /* In these cases, the operation to be performed depends on the mode\n+\t of the operand.  If we are replacing the operand with a VOIDmode\n+\t constant, we lose the information.  So try to simplify the operation\n+\t in that case.  If it fails, substitute in something that we know\n+\t won't be recogized.  */\n+      if (GET_MODE (to) == VOIDmode\n+\t  && (XEXP (x, 0) == from\n+\t      || (GET_CODE (XEXP (x, 0)) == REG && GET_CODE (from) == REG\n+\t\t  && GET_MODE (XEXP (x, 0)) == GET_MODE (from)\n+\t\t  && REGNO (XEXP (x, 0)) == REGNO (from))))\n+\t{\n+\t  rtx new = simplify_unary_operation (code, GET_MODE (x), to,\n+\t\t\t\t\t      GET_MODE (from));\n+\t  if (new == 0)\n+\t    new = gen_rtx (CLOBBER, GET_MODE (x), const0_rtx);\n+\n+\t  validate_change (object, loc, new, 1);\n+\t  return;\n+\t}\n+      break;\n+\t\n+    case SUBREG:\n+      /* If we have a SUBREG of a register that we are replacing and we are\n+\t replacing it with a MEM, make a new MEM and try replacing the\n+\t SUBREG with it.  Don't do this if the MEM has a mode-dependent address\n+\t or if we would be widening it.  */\n+\n+      if (SUBREG_REG (x) == from\n+\t  && GET_CODE (from) == REG\n+\t  && GET_CODE (to) == MEM\n+\t  && ! mode_dependent_address_p (XEXP (to, 0))\n+\t  && ! MEM_VOLATILE_P (to)\n+\t  && GET_MODE_SIZE (GET_MODE (x)) <= GET_MODE_SIZE (GET_MODE (to)))\n+\t{\n+\t  int offset = SUBREG_WORD (x) * UNITS_PER_WORD;\n+\t  enum machine_mode mode = GET_MODE (x);\n+\t  rtx new;\n+\n+#if BYTES_BIG_ENDIAN\n+\t  offset += (MIN (UNITS_PER_WORD,\n+\t\t\t  GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n+\t\t     - MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode)));\n+#endif\n+\n+\t  new = gen_rtx (MEM, mode, plus_constant (XEXP (to, 0), offset));\n+\t  MEM_VOLATILE_P (new) = MEM_VOLATILE_P (to);\n+\t  RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (to);\n+\t  MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (to);\n+\t  validate_change (object, loc, new, 1);\n+\t  return;\n+\t}\n+      break;\n+\n+    case ZERO_EXTRACT:\n+    case SIGN_EXTRACT:\n+      /* If we are replacing a register with memory, try to change the memory\n+\t to be the mode required for memory in extract operations (this isn't\n+\t likely to be an insertion operation; if it was, nothing bad will\n+\t happen, we might just fail in some cases).  */\n+\n+      if (XEXP (x, 0) == from && GET_CODE (from) == REG && GET_CODE (to) == MEM\n+\t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && GET_CODE (XEXP (x, 2)) == CONST_INT\n+\t  && ! mode_dependent_address_p (XEXP (to, 0))\n+\t  && ! MEM_VOLATILE_P (to))\n+\t{\n+\t  enum machine_mode wanted_mode = VOIDmode;\n+\t  enum machine_mode is_mode = GET_MODE (to);\n+\t  int width = INTVAL (XEXP (x, 1));\n+\t  int pos = INTVAL (XEXP (x, 2));\n+\n+#ifdef HAVE_extzv\n+\t  if (code == ZERO_EXTRACT)\n+\t    wanted_mode = insn_operand_mode[(int) CODE_FOR_extzv][1];\n+#endif\n+#ifdef HAVE_extv\n+\t  if (code == SIGN_EXTRACT)\n+\t    wanted_mode = insn_operand_mode[(int) CODE_FOR_extv][1];\n+#endif\n+\n+\t  /* If we have a narrower mode, we can do someting.  */\n+\t  if (wanted_mode != VOIDmode\n+\t      && GET_MODE_SIZE (wanted_mode) < GET_MODE_SIZE (is_mode))\n+\t    {\n+\t      int offset = pos / BITS_PER_UNIT;\n+\t      rtx newmem;\n+\n+\t\t  /* If the bytes and bits are counted differently, we\n+\t\t     must adjust the offset.  */\n+#if BYTES_BIG_ENDIAN != BITS_BIG_ENDIAN\n+\t      offset = (GET_MODE_SIZE (is_mode) - GET_MODE_SIZE (wanted_mode)\n+\t\t\t- offset);\n+#endif\n+\n+\t      pos %= GET_MODE_BITSIZE (wanted_mode);\n+\n+\t      newmem = gen_rtx (MEM, wanted_mode,\n+\t\t\t\tplus_constant (XEXP (to, 0), offset));\n+\t      RTX_UNCHANGING_P (newmem) = RTX_UNCHANGING_P (to);\n+\t      MEM_VOLATILE_P (newmem) = MEM_VOLATILE_P (to);\n+\t      MEM_IN_STRUCT_P (newmem) = MEM_IN_STRUCT_P (to);\n+\n+\t      validate_change (object, &XEXP (x, 2),\n+\t\t\t       gen_rtx (CONST_INT, VOIDmode, pos), 1);\n+\t      validate_change (object, &XEXP (x, 0), newmem, 1);\n+\t    }\n+\t}\n+\n+      break;\n+    }\n+      \n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\tvalidate_replace_rtx_1 (&XEXP (x, i), from, to, object);\n+      else if (fmt[i] == 'E')\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  validate_replace_rtx_1 (&XVECEXP (x, i, j), from, to, object);\n+    }\n+}\n+\n+/* Try replacing every occurrence of FROM in INSN with TO.  After all\n+   changes have been made, validate by seeing if INSN is still valid.  */\n+\n+int\n+validate_replace_rtx (from, to, insn)\n+     rtx from, to, insn;\n+{\n+  validate_replace_rtx_1 (&PATTERN (insn), from, to, insn);\n+  return apply_change_group ();\n+}\n+\f\n+#ifdef HAVE_cc0\n+/* Return 1 if the insn using CC0 set by INSN does not contain\n+   any ordered tests applied to the condition codes.\n+   EQ and NE tests do not count.  */\n+\n+int\n+next_insn_tests_no_inequality (insn)\n+     rtx insn;\n+{\n+  register rtx next = next_cc0_user (insn);\n+\n+  /* If there is no next insn, we have to take the conservative choice.  */\n+  if (next == 0)\n+    return 0;\n+\n+  return ((GET_CODE (next) == JUMP_INSN\n+\t   || GET_CODE (next) == INSN\n+\t   || GET_CODE (next) == CALL_INSN)\n+\t  && ! inequality_comparisons_p (PATTERN (next)));\n+}\n+\n+#if 0  /* This is useless since the insn that sets the cc's\n+\t  must be followed immediately by the use of them.  */\n+/* Return 1 if the CC value set up by INSN is not used.  */\n+\n+int\n+next_insns_test_no_inequality (insn)\n+     rtx insn;\n+{\n+  register rtx next = NEXT_INSN (insn);\n+\n+  for (; next != 0; next = NEXT_INSN (next))\n+    {\n+      if (GET_CODE (next) == CODE_LABEL\n+\t  || GET_CODE (next) == BARRIER)\n+\treturn 1;\n+      if (GET_CODE (next) == NOTE)\n+\tcontinue;\n+      if (inequality_comparisons_p (PATTERN (next)))\n+\treturn 0;\n+      if (sets_cc0_p (PATTERN (next)) == 1)\n+\treturn 1;\n+      if (! reg_mentioned_p (cc0_rtx, PATTERN (next)))\n+\treturn 1;\n+    }\n+  return 1;\n+}\n+#endif\n+#endif\n+\f\n+/* This is used by find_single_use to locate an rtx that contains exactly one\n+   use of DEST, which is typically either a REG or CC0.  It returns a\n+   pointer to the innermost rtx expression containing DEST.  Appearances of\n+   DEST that are being used to totally replace it are not counted.  */\n+\n+static rtx *\n+find_single_use_1 (dest, loc)\n+     rtx dest;\n+     rtx *loc;\n+{\n+  rtx x = *loc;\n+  enum rtx_code code = GET_CODE (x);\n+  rtx *result = 0;\n+  rtx *this_result;\n+  int i;\n+  char *fmt;\n+\n+  switch (code)\n+    {\n+    case CONST_INT:\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST_DOUBLE:\n+    case CLOBBER:\n+      return 0;\n+\n+    case SET:\n+      /* If the destination is anything other than CC0, PC, a REG or a SUBREG\n+\t of a REG that occupies all of the REG, the insn uses DEST if\n+\t it is mentioned in the destination or the source.  Otherwise, we\n+\t need just check the source.  */\n+      if (GET_CODE (SET_DEST (x)) != CC0\n+\t  && GET_CODE (SET_DEST (x)) != PC\n+\t  && GET_CODE (SET_DEST (x)) != REG\n+\t  && ! (GET_CODE (SET_DEST (x)) == SUBREG\n+\t\t&& GET_CODE (SUBREG_REG (SET_DEST (x))) == REG\n+\t\t&& (((GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_DEST (x))))\n+\t\t      + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n+\t\t    == ((GET_MODE_SIZE (GET_MODE (SET_DEST (x)))\n+\t\t\t + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD))))\n+\tbreak;\n+\n+      return find_single_use_1 (dest, &SET_SRC (x));\n+\n+    case MEM:\n+    case SUBREG:\n+      return find_single_use_1 (dest, &XEXP (x, 0));\n+    }\n+\n+  /* If it wasn't one of the common cases above, check each expression and\n+     vector of this code.  Look for a unique usage of DEST.  */\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  if (dest == XEXP (x, i)\n+\t      || (GET_CODE (dest) == REG && GET_CODE (XEXP (x, i)) == REG\n+\t\t  && REGNO (dest) == REGNO (XEXP (x, i))))\n+\t    this_result = loc;\n+\t  else\n+\t    this_result = find_single_use_1 (dest, &XEXP (x, i));\n+\n+\t  if (result == 0)\n+\t    result = this_result;\n+\t  else if (this_result)\n+\t    /* Duplicate usage.  */\n+\t    return 0;\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  int j;\n+\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    {\n+\t      if (XVECEXP (x, i, j) == dest\n+\t\t  || (GET_CODE (dest) == REG\n+\t\t      && GET_CODE (XVECEXP (x, i, j)) == REG\n+\t\t      && REGNO (XVECEXP (x, i, j)) == REGNO (dest)))\n+\t\tthis_result = loc;\n+\t      else\n+\t\tthis_result = find_single_use_1 (dest, &XVECEXP (x, i, j));\n+\n+\t      if (result == 0)\n+\t\tresult = this_result;\n+\t      else if (this_result)\n+\t\treturn 0;\n+\t    }\n+\t}\n+    }\n+\n+  return result;\n+}\n+\f\n+/* See if DEST, produced in INSN, is used only a single time in the\n+   sequel.  If so, return a pointer to the innermost rtx expression in which\n+   it is used.\n+\n+   If PLOC is non-zero, *PLOC is set to the insn containing the single use.\n+\n+   This routine will return usually zero either before flow is called (because\n+   there will be no LOG_LINKS notes) or after reload (because the REG_DEAD\n+   note can't be trusted).\n+\n+   If DEST is cc0_rtx, we look only at the next insn.  In that case, we don't\n+   care about REG_DEAD notes or LOG_LINKS.\n+\n+   Otherwise, we find the single use by finding an insn that has a\n+   LOG_LINKS pointing at INSN and has a REG_DEAD note for DEST.  If DEST is\n+   only referenced once in that insn, we know that it must be the first\n+   and last insn referencing DEST.  */\n+\n+rtx *\n+find_single_use (dest, insn, ploc)\n+     rtx dest;\n+     rtx insn;\n+     rtx *ploc;\n+{\n+  rtx next;\n+  rtx *result;\n+  rtx link;\n+\n+#ifdef HAVE_cc0\n+  if (dest == cc0_rtx)\n+    {\n+      next = NEXT_INSN (insn);\n+      if (next == 0\n+\t  || (GET_CODE (next) != INSN && GET_CODE (next) != JUMP_INSN))\n+\treturn 0;\n+\n+      result = find_single_use_1 (dest, &PATTERN (next));\n+      if (result && ploc)\n+\t*ploc = next;\n+      return result;\n+    }\n+#endif\n+\n+  if (reload_completed || reload_in_progress || GET_CODE (dest) != REG)\n+    return 0;\n+\n+  for (next = next_nonnote_insn (insn);\n+       next != 0 && GET_CODE (next) != CODE_LABEL;\n+       next = next_nonnote_insn (next))\n+    if (GET_RTX_CLASS (GET_CODE (next)) == 'i' && dead_or_set_p (next, dest))\n+      {\n+\tfor (link = LOG_LINKS (next); link; link = XEXP (link, 1))\n+\t  if (XEXP (link, 0) == insn)\n+\t    break;\n+\n+\tif (link)\n+\t  {\n+\t    result = find_single_use_1 (dest, &PATTERN (next));\n+\t    if (ploc)\n+\t      *ploc = next;\n+\t    return result;\n+\t  }\n+      }\n+\n+  return 0;\n+}\n+\f\n+/* Return 1 if OP is a valid general operand for machine mode MODE.\n+   This is either a register reference, a memory reference,\n+   or a constant.  In the case of a memory reference, the address\n+   is checked for general validity for the target machine.\n+\n+   Register and memory references must have mode MODE in order to be valid,\n+   but some constants have no machine mode and are valid for any mode.\n+\n+   If MODE is VOIDmode, OP is checked for validity for whatever mode\n+   it has.\n+\n+   The main use of this function is as a predicate in match_operand\n+   expressions in the machine description.\n+\n+   For an explaination of this function's behavior for registers of\n+   class NO_REGS, see the comment for `register_operand'.  */\n+\n+int\n+general_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  register enum rtx_code code = GET_CODE (op);\n+  int mode_altering_drug = 0;\n+\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (op);\n+\n+  /* Don't accept CONST_INT or anything similar\n+     if the caller wants something floating.  */\n+  if (GET_MODE (op) == VOIDmode && mode != VOIDmode\n+      && GET_MODE_CLASS (mode) != MODE_INT)\n+    return 0;\n+\n+  if (CONSTANT_P (op))\n+    return ((GET_MODE (op) == VOIDmode || GET_MODE (op) == mode)\n+#ifdef LEGITIMATE_PIC_OPERAND_P\n+\t    && (! flag_pic || LEGITIMATE_PIC_OPERAND_P (op))\n+#endif\n+\t    && LEGITIMATE_CONSTANT_P (op));\n+\n+  /* Except for certain constants with VOIDmode, already checked for,\n+     OP's mode must match MODE if MODE specifies a mode.  */\n+\n+  if (GET_MODE (op) != mode)\n+    return 0;\n+\n+  if (code == SUBREG)\n+    {\n+#ifdef INSN_SCHEDULING\n+      /* On machines that have insn scheduling, we want all memory\n+\t reference to be explicit, so outlaw paradoxical SUBREGs.  */\n+      if (GET_CODE (SUBREG_REG (op)) == MEM\n+\t  && GET_MODE_SIZE (mode) > GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))))\n+\treturn 0;\n+#endif\n+\n+      op = SUBREG_REG (op);\n+      code = GET_CODE (op);\n+#if 0\n+      /* No longer needed, since (SUBREG (MEM...))\n+\t will load the MEM into a reload reg in the MEM's own mode.  */\n+      mode_altering_drug = 1;\n+#endif\n+    }\n+\n+  if (code == REG)\n+    /* A register whose class is NO_REGS is not a general operand.  */\n+    return (REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t    || REGNO_REG_CLASS (REGNO (op)) != NO_REGS);\n+\n+  if (code == MEM)\n+    {\n+      register rtx y = XEXP (op, 0);\n+      if (! volatile_ok && MEM_VOLATILE_P (op))\n+\treturn 0;\n+      /* Use the mem's mode, since it will be reloaded thus.  */\n+      mode = GET_MODE (op);\n+      GO_IF_LEGITIMATE_ADDRESS (mode, y, win);\n+    }\n+  return 0;\n+\n+ win:\n+  if (mode_altering_drug)\n+    return ! mode_dependent_address_p (XEXP (op, 0));\n+  return 1;\n+}\n+\f\n+/* Return 1 if OP is a valid memory address for a memory reference\n+   of mode MODE.\n+\n+   The main use of this function is as a predicate in match_operand\n+   expressions in the machine description.  */\n+\n+int\n+address_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return memory_address_p (mode, op);\n+}\n+\n+/* Return 1 if OP is a register reference of mode MODE.\n+   If MODE is VOIDmode, accept a register in any mode.\n+\n+   The main use of this function is as a predicate in match_operand\n+   expressions in the machine description.\n+\n+   As a special exception, registers whose class is NO_REGS are\n+   not accepted by `register_operand'.  The reason for this change\n+   is to allow the representation of special architecture artifacts\n+   (such as a condition code register) without extending the rtl\n+   definitions.  Since registers of class NO_REGS cannot be used\n+   as registers in any case where register classes are examined,\n+   it is most consistent to keep this function from accepting them.  */\n+\n+int\n+register_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return 0;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      /* Before reload, we can allow (SUBREG (MEM...)) as a register operand\n+\t because it is guaranteed to be reloaded into one.\n+\t Just make sure the MEM is valid in itself.\n+\t (Ideally, (SUBREG (MEM)...) should not exist after reload,\n+\t but currently it does result from (SUBREG (REG)...) where the\n+\t reg went on the stack.)  */\n+      if (! reload_completed && GET_CODE (SUBREG_REG (op)) == MEM)\n+\treturn general_operand (op, mode);\n+      op = SUBREG_REG (op);\n+    }\n+\n+  /* We don't consider registers whose class is NO_REGS\n+     to be a register operand.  */\n+  return (GET_CODE (op) == REG\n+\t  && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t      || REGNO_REG_CLASS (REGNO (op)) != NO_REGS));\n+}\n+\n+/* Return 1 if OP should match a MATCH_SCRATCH, i.e., if it is a SCRATCH\n+   or a hard register.  */\n+\n+int\n+scratch_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_MODE (op) == mode\n+\t  && (GET_CODE (op) == SCRATCH\n+\t      || (GET_CODE (op) == REG\n+\t\t  && REGNO (op) < FIRST_PSEUDO_REGISTER)));\n+}\n+\n+/* Return 1 if OP is a valid immediate operand for mode MODE.\n+\n+   The main use of this function is as a predicate in match_operand\n+   expressions in the machine description.  */\n+\n+int\n+immediate_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  /* Don't accept CONST_INT or anything similar\n+     if the caller wants something floating.  */\n+  if (GET_MODE (op) == VOIDmode && mode != VOIDmode\n+      && GET_MODE_CLASS (mode) != MODE_INT)\n+    return 0;\n+\n+  return (CONSTANT_P (op)\n+\t  && (GET_MODE (op) == mode || mode == VOIDmode\n+\t      || GET_MODE (op) == VOIDmode)\n+#ifdef LEGITIMATE_PIC_OPERAND_P\n+\t  && (! flag_pic || LEGITIMATE_PIC_OPERAND_P (op))\n+#endif\n+\t  && LEGITIMATE_CONSTANT_P (op));\n+}\n+\n+/* Returns 1 if OP is an operand that is a CONST_INT.  */\n+\n+int\n+const_int_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return GET_CODE (op) == CONST_INT;\n+}\n+\n+/* Returns 1 if OP is an operand that is a constant integer or constant\n+   floating-point number.  */\n+\n+int\n+const_double_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  /* Don't accept CONST_INT or anything similar\n+     if the caller wants something floating.  */\n+  if (GET_MODE (op) == VOIDmode && mode != VOIDmode\n+      && GET_MODE_CLASS (mode) != MODE_INT)\n+    return 0;\n+\n+  return ((GET_CODE (op) == CONST_DOUBLE || GET_CODE (op) == CONST_INT)\n+\t  && (mode == VOIDmode || GET_MODE (op) == mode\n+\t      || GET_MODE (op) == VOIDmode));\n+}\n+\n+/* Return 1 if OP is a general operand that is not an immediate operand.  */\n+\n+int\n+nonimmediate_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return (general_operand (op, mode) && ! CONSTANT_P (op));\n+}\n+\n+/* Return 1 if OP is a register reference or immediate value of mode MODE.  */\n+\n+int\n+nonmemory_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (CONSTANT_P (op))\n+    {\n+      /* Don't accept CONST_INT or anything similar\n+\t if the caller wants something floating.  */\n+      if (GET_MODE (op) == VOIDmode && mode != VOIDmode\n+\t  && GET_MODE_CLASS (mode) != MODE_INT)\n+\treturn 0;\n+\n+      return ((GET_MODE (op) == VOIDmode || GET_MODE (op) == mode)\n+#ifdef LEGITIMATE_PIC_OPERAND_P\n+\t      && (! flag_pic || LEGITIMATE_PIC_OPERAND_P (op))\n+#endif\n+\t      && LEGITIMATE_CONSTANT_P (op));\n+    }\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return 0;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      /* Before reload, we can allow (SUBREG (MEM...)) as a register operand\n+\t because it is guaranteed to be reloaded into one.\n+\t Just make sure the MEM is valid in itself.\n+\t (Ideally, (SUBREG (MEM)...) should not exist after reload,\n+\t but currently it does result from (SUBREG (REG)...) where the\n+\t reg went on the stack.)  */\n+      if (! reload_completed && GET_CODE (SUBREG_REG (op)) == MEM)\n+\treturn general_operand (op, mode);\n+      op = SUBREG_REG (op);\n+    }\n+\n+  /* We don't consider registers whose class is NO_REGS\n+     to be a register operand.  */\n+  return (GET_CODE (op) == REG\n+\t  && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t      || REGNO_REG_CLASS (REGNO (op)) != NO_REGS));\n+}\n+\n+/* Return 1 if OP is a valid operand that stands for pushing a\n+   value of mode MODE onto the stack.\n+\n+   The main use of this function is as a predicate in match_operand\n+   expressions in the machine description.  */\n+\n+int\n+push_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+\n+  if (GET_MODE (op) != mode)\n+    return 0;\n+\n+  op = XEXP (op, 0);\n+\n+  if (GET_CODE (op) != STACK_PUSH_CODE)\n+    return 0;\n+\n+  return XEXP (op, 0) == stack_pointer_rtx;\n+}\n+\n+/* Return 1 if ADDR is a valid memory address for mode MODE.  */\n+\n+int\n+memory_address_p (mode, addr)\n+     enum machine_mode mode;\n+     register rtx addr;\n+{\n+  GO_IF_LEGITIMATE_ADDRESS (mode, addr, win);\n+  return 0;\n+\n+ win:\n+  return 1;\n+}\n+\n+/* Return 1 if OP is a valid memory reference with mode MODE,\n+   including a valid address.\n+\n+   The main use of this function is as a predicate in match_operand\n+   expressions in the machine description.  */\n+\n+int\n+memory_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  rtx inner;\n+\n+  if (! reload_completed)\n+    /* Note that no SUBREG is a memory operand before end of reload pass,\n+       because (SUBREG (MEM...)) forces reloading into a register.  */\n+    return GET_CODE (op) == MEM && general_operand (op, mode);\n+\n+  if (mode != VOIDmode && GET_MODE (op) != mode)\n+    return 0;\n+\n+  inner = op;\n+  if (GET_CODE (inner) == SUBREG)\n+    inner = SUBREG_REG (inner);\n+\n+  return (GET_CODE (inner) == MEM && general_operand (op, mode));\n+}\n+\n+/* Return 1 if OP is a valid indirect memory reference with mode MODE;\n+   that is, a memory reference whose address is a general_operand.  */\n+\n+int\n+indirect_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  /* Before reload, a SUBREG isn't in memory (see memory_operand, above).  */\n+  if (! reload_completed\n+      && GET_CODE (op) == SUBREG && GET_CODE (SUBREG_REG (op)) == MEM)\n+    {\n+      register int offset = SUBREG_WORD (op) * UNITS_PER_WORD;\n+      rtx inner = SUBREG_REG (op);\n+\n+#if BYTES_BIG_ENDIAN\n+      offset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (op)))\n+\t\t - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (inner))));\n+#endif\n+\n+      /* The only way that we can have a general_operand as the resulting\n+\t address is if OFFSET is zero and the address already is an operand\n+\t or if the address is (plus Y (const_int -OFFSET)) and Y is an\n+\t operand.  */\n+\n+      return ((offset == 0 && general_operand (XEXP (inner, 0), Pmode))\n+\t      || (GET_CODE (XEXP (inner, 0)) == PLUS\n+\t\t  && GET_CODE (XEXP (XEXP (inner, 0), 1)) == CONST_INT\n+\t\t  && INTVAL (XEXP (XEXP (inner, 0), 1)) == -offset\n+\t\t  && general_operand (XEXP (XEXP (inner, 0), 0), Pmode)));\n+    }\n+\n+  return (GET_CODE (op) == MEM\n+\t  && memory_operand (op, mode)\n+\t  && general_operand (XEXP (op, 0), Pmode));\n+}\n+\n+/* Return 1 if this is a comparison operator.  This allows the use of\n+   MATCH_OPERATOR to recognize all the branch insns.  */\n+\n+int\n+comparison_operator (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  return ((mode == VOIDmode || GET_MODE (op) == mode)\n+\t  && GET_RTX_CLASS (GET_CODE (op)) == '<');\n+}\n+\f\n+/* If BODY is an insn body that uses ASM_OPERANDS,\n+   return the number of operands (both input and output) in the insn.\n+   Otherwise return -1.  */\n+\n+int\n+asm_noperands (body)\n+     rtx body;\n+{\n+  if (GET_CODE (body) == ASM_OPERANDS)\n+    /* No output operands: return number of input operands.  */\n+    return ASM_OPERANDS_INPUT_LENGTH (body);\n+  if (GET_CODE (body) == SET && GET_CODE (SET_SRC (body)) == ASM_OPERANDS)\n+    /* Single output operand: BODY is (set OUTPUT (asm_operands ...)).  */\n+    return ASM_OPERANDS_INPUT_LENGTH (SET_SRC (body)) + 1;\n+  else if (GET_CODE (body) == PARALLEL\n+\t   && GET_CODE (XVECEXP (body, 0, 0)) == SET\n+\t   && GET_CODE (SET_SRC (XVECEXP (body, 0, 0))) == ASM_OPERANDS)\n+    {\n+      /* Multiple output operands, or 1 output plus some clobbers:\n+\t body is [(set OUTPUT (asm_operands ...))... (clobber (reg ...))...].  */\n+      int i;\n+      int n_sets;\n+\n+      /* Count backwards through CLOBBERs to determine number of SETs.  */\n+      for (i = XVECLEN (body, 0); i > 0; i--)\n+\t{\n+\t  if (GET_CODE (XVECEXP (body, 0, i - 1)) == SET)\n+\t    break;\n+\t  if (GET_CODE (XVECEXP (body, 0, i - 1)) != CLOBBER)\n+\t    return -1;\n+\t}\n+\n+      /* N_SETS is now number of output operands.  */\n+      n_sets = i;\n+\n+      /* Verify that all the SETs we have\n+\t came from a single original asm_operands insn\n+\t (so that invalid combinations are blocked).  */\n+      for (i = 0; i < n_sets; i++)\n+\t{\n+\t  rtx elt = XVECEXP (body, 0, i);\n+\t  if (GET_CODE (elt) != SET)\n+\t    return -1;\n+\t  if (GET_CODE (SET_SRC (elt)) != ASM_OPERANDS)\n+\t    return -1;\n+\t  /* If these ASM_OPERANDS rtx's came from different original insns\n+\t     then they aren't allowed together.  */\n+\t  if (ASM_OPERANDS_INPUT_VEC (SET_SRC (elt))\n+\t      != ASM_OPERANDS_INPUT_VEC (SET_SRC (XVECEXP (body, 0, 0))))\n+\t    return -1;\n+\t}\n+      return (ASM_OPERANDS_INPUT_LENGTH (SET_SRC (XVECEXP (body, 0, 0)))\n+\t      + n_sets);\n+    }\n+  else if (GET_CODE (body) == PARALLEL\n+\t   && GET_CODE (XVECEXP (body, 0, 0)) == ASM_OPERANDS)\n+    {\n+      /* 0 outputs, but some clobbers:\n+\t body is [(asm_operands ...) (clobber (reg ...))...].  */\n+      int i;\n+\n+      /* Make sure all the other parallel things really are clobbers.  */\n+      for (i = XVECLEN (body, 0) - 1; i > 0; i--)\n+\tif (GET_CODE (XVECEXP (body, 0, i)) != CLOBBER)\n+\t  return -1;\n+\n+      return ASM_OPERANDS_INPUT_LENGTH (XVECEXP (body, 0, 0));\n+    }\n+  else\n+    return -1;\n+}\n+\n+/* Assuming BODY is an insn body that uses ASM_OPERANDS,\n+   copy its operands (both input and output) into the vector OPERANDS,\n+   the locations of the operands within the insn into the vector OPERAND_LOCS,\n+   and the constraints for the operands into CONSTRAINTS.\n+   Write the modes of the operands into MODES.\n+   Return the assembler-template.\n+\n+   If MODES, OPERAND_LOCS, CONSTRAINTS or OPERANDS is 0,\n+   we don't store that info.  */\n+\n+char *\n+decode_asm_operands (body, operands, operand_locs, constraints, modes)\n+     rtx body;\n+     rtx *operands;\n+     rtx **operand_locs;\n+     char **constraints;\n+     enum machine_mode *modes;\n+{\n+  register int i;\n+  int noperands;\n+  char *template = 0;\n+\n+  if (GET_CODE (body) == SET && GET_CODE (SET_SRC (body)) == ASM_OPERANDS)\n+    {\n+      rtx asmop = SET_SRC (body);\n+      /* Single output operand: BODY is (set OUTPUT (asm_operands ....)).  */\n+\n+      noperands = ASM_OPERANDS_INPUT_LENGTH (asmop) + 1;\n+\n+      for (i = 1; i < noperands; i++)\n+\t{\n+\t  if (operand_locs)\n+\t    operand_locs[i] = &ASM_OPERANDS_INPUT (asmop, i - 1);\n+\t  if (operands)\n+\t    operands[i] = ASM_OPERANDS_INPUT (asmop, i - 1);\n+\t  if (constraints)\n+\t    constraints[i] = ASM_OPERANDS_INPUT_CONSTRAINT (asmop, i - 1);\n+\t  if (modes)\n+\t    modes[i] = ASM_OPERANDS_INPUT_MODE (asmop, i - 1);\n+\t}\n+\n+      /* The output is in the SET.\n+\t Its constraint is in the ASM_OPERANDS itself.  */\n+      if (operands)\n+\toperands[0] = SET_DEST (body);\n+      if (operand_locs)\n+\toperand_locs[0] = &SET_DEST (body);\n+      if (constraints)\n+\tconstraints[0] = ASM_OPERANDS_OUTPUT_CONSTRAINT (asmop);\n+      if (modes)\n+\tmodes[0] = GET_MODE (SET_DEST (body));\n+      template = ASM_OPERANDS_TEMPLATE (asmop);\n+    }\n+  else if (GET_CODE (body) == ASM_OPERANDS)\n+    {\n+      rtx asmop = body;\n+      /* No output operands: BODY is (asm_operands ....).  */\n+\n+      noperands = ASM_OPERANDS_INPUT_LENGTH (asmop);\n+\n+      /* The input operands are found in the 1st element vector.  */\n+      /* Constraints for inputs are in the 2nd element vector.  */\n+      for (i = 0; i < noperands; i++)\n+\t{\n+\t  if (operand_locs)\n+\t    operand_locs[i] = &ASM_OPERANDS_INPUT (asmop, i);\n+\t  if (operands)\n+\t    operands[i] = ASM_OPERANDS_INPUT (asmop, i);\n+\t  if (constraints)\n+\t    constraints[i] = ASM_OPERANDS_INPUT_CONSTRAINT (asmop, i);\n+\t  if (modes)\n+\t    modes[i] = ASM_OPERANDS_INPUT_MODE (asmop, i);\n+\t}\n+      template = ASM_OPERANDS_TEMPLATE (asmop);\n+    }\n+  else if (GET_CODE (body) == PARALLEL\n+\t   && GET_CODE (XVECEXP (body, 0, 0)) == SET)\n+    {\n+      rtx asmop = SET_SRC (XVECEXP (body, 0, 0));\n+      int nparallel = XVECLEN (body, 0); /* Includes CLOBBERs.  */\n+      int nin = ASM_OPERANDS_INPUT_LENGTH (asmop);\n+      int nout = 0;\t\t/* Does not include CLOBBERs.  */\n+\n+      /* At least one output, plus some CLOBBERs.  */\n+\n+      /* The outputs are in the SETs.\n+\t Their constraints are in the ASM_OPERANDS itself.  */\n+      for (i = 0; i < nparallel; i++)\n+\t{\n+\t  if (GET_CODE (XVECEXP (body, 0, i)) == CLOBBER)\n+\t    break;\t\t/* Past last SET */\n+\t  \n+\t  if (operands)\n+\t    operands[i] = SET_DEST (XVECEXP (body, 0, i));\n+\t  if (operand_locs)\n+\t    operand_locs[i] = &SET_DEST (XVECEXP (body, 0, i));\n+\t  if (constraints)\n+\t    constraints[i] = XSTR (SET_SRC (XVECEXP (body, 0, i)), 1);\n+\t  if (modes)\n+\t    modes[i] = GET_MODE (SET_DEST (XVECEXP (body, 0, i)));\n+\t  nout++;\n+\t}\n+\n+      for (i = 0; i < nin; i++)\n+\t{\n+\t  if (operand_locs)\n+\t    operand_locs[i + nout] = &ASM_OPERANDS_INPUT (asmop, i);\n+\t  if (operands)\n+\t    operands[i + nout] = ASM_OPERANDS_INPUT (asmop, i);\n+\t  if (constraints)\n+\t    constraints[i + nout] = ASM_OPERANDS_INPUT_CONSTRAINT (asmop, i);\n+\t  if (modes)\n+\t    modes[i + nout] = ASM_OPERANDS_INPUT_MODE (asmop, i);\n+\t}\n+\n+      template = ASM_OPERANDS_TEMPLATE (asmop);\n+    }\n+  else if (GET_CODE (body) == PARALLEL\n+\t   && GET_CODE (XVECEXP (body, 0, 0)) == ASM_OPERANDS)\n+    {\n+      /* No outputs, but some CLOBBERs.  */\n+\n+      rtx asmop = XVECEXP (body, 0, 0);\n+      int nin = ASM_OPERANDS_INPUT_LENGTH (asmop);\n+\n+      for (i = 0; i < nin; i++)\n+\t{\n+\t  if (operand_locs)\n+\t    operand_locs[i] = &ASM_OPERANDS_INPUT (asmop, i);\n+\t  if (operands)\n+\t    operands[i] = ASM_OPERANDS_INPUT (asmop, i);\n+\t  if (constraints)\n+\t    constraints[i] = ASM_OPERANDS_INPUT_CONSTRAINT (asmop, i);\n+\t  if (modes)\n+\t    modes[i] = ASM_OPERANDS_INPUT_MODE (asmop, i);\n+\t}\n+\n+      template = ASM_OPERANDS_TEMPLATE (asmop);\n+    }\n+\n+  return template;\n+}\n+\f\n+extern rtx plus_constant_for_output ();\n+extern rtx copy_rtx ();\n+\n+/* Given an rtx *P, if it is a sum containing an integer constant term,\n+   return the location (type rtx *) of the pointer to that constant term.\n+   Otherwise, return a null pointer.  */\n+\n+static rtx *\n+find_constant_term_loc (p)\n+     rtx *p;\n+{\n+  register rtx *tem;\n+  register enum rtx_code code = GET_CODE (*p);\n+\n+  /* If *P IS such a constant term, P is its location.  */\n+\n+  if (code == CONST_INT || code == SYMBOL_REF || code == LABEL_REF\n+      || code == CONST)\n+    return p;\n+\n+  /* Otherwise, if not a sum, it has no constant term.  */\n+\n+  if (GET_CODE (*p) != PLUS)\n+    return 0;\n+\n+  /* If one of the summands is constant, return its location.  */\n+\n+  if (XEXP (*p, 0) && CONSTANT_P (XEXP (*p, 0))\n+      && XEXP (*p, 1) && CONSTANT_P (XEXP (*p, 1)))\n+    return p;\n+\n+  /* Otherwise, check each summand for containing a constant term.  */\n+\n+  if (XEXP (*p, 0) != 0)\n+    {\n+      tem = find_constant_term_loc (&XEXP (*p, 0));\n+      if (tem != 0)\n+\treturn tem;\n+    }\n+\n+  if (XEXP (*p, 1) != 0)\n+    {\n+      tem = find_constant_term_loc (&XEXP (*p, 1));\n+      if (tem != 0)\n+\treturn tem;\n+    }\n+\n+  return 0;\n+}\n+\f\n+/* Return 1 if OP is a memory reference\n+   whose address contains no side effects\n+   and remains valid after the addition\n+   of a positive integer less than the\n+   size of the object being referenced.\n+\n+   We assume that the original address is valid and do not check it.\n+\n+   This uses strict_memory_address_p as a subroutine, so\n+   don't use it before reload.  */\n+\n+int\n+offsettable_memref_p (op)\n+     rtx op;\n+{\n+  return ((GET_CODE (op) == MEM)\n+\t  && offsettable_address_p (1, GET_MODE (op), XEXP (op, 0)));\n+}\n+\n+/* Similar, but don't require a strictly valid mem ref:\n+   consider pseudo-regs valid as index or base regs.  */\n+\n+int\n+offsettable_nonstrict_memref_p (op)\n+     rtx op;\n+{\n+  return ((GET_CODE (op) == MEM)\n+\t  && offsettable_address_p (0, GET_MODE (op), XEXP (op, 0)));\n+}\n+\n+/* Return 1 if Y is a memory address which contains no side effects\n+   and would remain valid after the addition of a positive integer\n+   less than the size of that mode.\n+\n+   We assume that the original address is valid and do not check it.\n+   We do check that it is valid for narrower modes.\n+\n+   If STRICTP is nonzero, we require a strictly valid address,\n+   for the sake of use in reload.c.  */\n+\n+int\n+offsettable_address_p (strictp, mode, y)\n+     int strictp;\n+     enum machine_mode mode;\n+     register rtx y;\n+{\n+  register enum rtx_code ycode = GET_CODE (y);\n+  register rtx z;\n+  rtx y1 = y;\n+  rtx *y2;\n+  int (*addressp) () = (strictp ? strict_memory_address_p : memory_address_p);\n+\n+  if (CONSTANT_ADDRESS_P (y))\n+    return 1;\n+\n+  /* Adjusting an offsettable address involves changing to a narrower mode.\n+     Make sure that's OK.  */\n+\n+  if (mode_dependent_address_p (y))\n+    return 0;\n+\n+  /* If the expression contains a constant term,\n+     see if it remains valid when max possible offset is added.  */\n+\n+  if ((ycode == PLUS) && (y2 = find_constant_term_loc (&y1)))\n+    {\n+      int good;\n+\n+      y1 = *y2;\n+      *y2 = plus_constant (*y2, GET_MODE_SIZE (mode) - 1);\n+      /* Use QImode because an odd displacement may be automatically invalid\n+\t for any wider mode.  But it should be valid for a single byte.  */\n+      good = (*addressp) (QImode, y);\n+\n+      /* In any case, restore old contents of memory.  */\n+      *y2 = y1;\n+      return good;\n+    }\n+\n+  if (ycode == PRE_DEC || ycode == PRE_INC\n+      || ycode == POST_DEC || ycode == POST_INC)\n+    return 0;\n+\n+  /* The offset added here is chosen as the maximum offset that\n+     any instruction could need to add when operating on something\n+     of the specified mode.  We assume that if Y and Y+c are\n+     valid addresses then so is Y+d for all 0<d<c.  */\n+\n+  z = plus_constant_for_output (y, GET_MODE_SIZE (mode) - 1);\n+\n+  /* Use QImode because an odd displacement may be automatically invalid\n+     for any wider mode.  But it should be valid for a single byte.  */\n+  return (*addressp) (QImode, z);\n+}\n+\n+/* Return 1 if ADDR is an address-expression whose effect depends\n+   on the mode of the memory reference it is used in.\n+\n+   Autoincrement addressing is a typical example of mode-dependence\n+   because the amount of the increment depends on the mode.  */\n+\n+int\n+mode_dependent_address_p (addr)\n+     rtx addr;\n+{\n+  GO_IF_MODE_DEPENDENT_ADDRESS (addr, win);\n+  return 0;\n+ win:\n+  return 1;\n+}\n+\n+/* Return 1 if OP is a general operand\n+   other than a memory ref with a mode dependent address.  */\n+\n+int\n+mode_independent_operand (op, mode)\n+     enum machine_mode mode;\n+     rtx op;\n+{\n+  rtx addr;\n+\n+  if (! general_operand (op, mode))\n+    return 0;\n+\n+  if (GET_CODE (op) != MEM)\n+    return 1;\n+\n+  addr = XEXP (op, 0);\n+  GO_IF_MODE_DEPENDENT_ADDRESS (addr, lose);\n+  return 1;\n+ lose:\n+  return 0;\n+}\n+\n+/* Given an operand OP that is a valid memory reference\n+   which satisfies offsettable_memref_p,\n+   return a new memory reference whose address has been adjusted by OFFSET.\n+   OFFSET should be positive and less than the size of the object referenced.\n+*/\n+\n+rtx\n+adj_offsettable_operand (op, offset)\n+     rtx op;\n+     int offset;\n+{\n+  register enum rtx_code code = GET_CODE (op);\n+\n+  if (code == MEM) \n+    {\n+      register rtx y = XEXP (op, 0);\n+      register rtx new;\n+\n+      if (CONSTANT_ADDRESS_P (y))\n+\t{\n+\t  new = gen_rtx (MEM, GET_MODE (op), plus_constant_for_output (y, offset));\n+\t  RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (op);\n+\t  return new;\n+\t}\n+\n+      if (GET_CODE (y) == PLUS)\n+\t{\n+\t  rtx z = y;\n+\t  register rtx *const_loc;\n+\n+\t  op = copy_rtx (op);\n+\t  z = XEXP (op, 0);\n+\t  const_loc = find_constant_term_loc (&z);\n+\t  if (const_loc)\n+\t    {\n+\t      *const_loc = plus_constant_for_output (*const_loc, offset);\n+\t      return op;\n+\t    }\n+\t}\n+\n+      new = gen_rtx (MEM, GET_MODE (op), plus_constant_for_output (y, offset));\n+      RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (op);\n+      return new;\n+    }\n+  abort ();\n+}\n+\f\n+#ifdef REGISTER_CONSTRAINTS\n+\n+/* Check the operands of an insn (found in recog_operands)\n+   against the insn's operand constraints (found via INSN_CODE_NUM)\n+   and return 1 if they are valid.\n+\n+   WHICH_ALTERNATIVE is set to a number which indicates which\n+   alternative of constraints was matched: 0 for the first alternative,\n+   1 for the next, etc.\n+\n+   In addition, when two operands are match\n+   and it happens that the output operand is (reg) while the\n+   input operand is --(reg) or ++(reg) (a pre-inc or pre-dec),\n+   make the output operand look like the input.\n+   This is because the output operand is the one the template will print.\n+\n+   This is used in final, just before printing the assembler code and by\n+   the routines that determine an insn's attribute.\n+\n+   If STRICT is a positive non-zero value, it means that we have been\n+   called after reload has been completed.  In that case, we must\n+   do all checks strictly.  If it is zero, it means that we have been called\n+   before reload has completed.  In that case, we first try to see if we can\n+   find an alternative that matches strictly.  If not, we try again, this\n+   time assuming that reload will fix up the insn.  This provides a \"best\n+   guess\" for the alternative and is used to compute attributes of insns prior\n+   to reload.  A negative value of STRICT is used for this internal call.  */\n+\n+struct funny_match\n+{\n+  int this, other;\n+};\n+\n+int\n+constrain_operands (insn_code_num, strict)\n+     int insn_code_num;\n+     int strict;\n+{\n+  char *constraints[MAX_RECOG_OPERANDS];\n+  register int c;\n+  int noperands = insn_n_operands[insn_code_num];\n+\n+  struct funny_match funny_match[MAX_RECOG_OPERANDS];\n+  int funny_match_index;\n+  int nalternatives = insn_n_alternatives[insn_code_num];\n+\n+  if (noperands == 0 || nalternatives == 0)\n+    return 1;\n+\n+  for (c = 0; c < noperands; c++)\n+    constraints[c] = insn_operand_constraint[insn_code_num][c];\n+\n+  which_alternative = 0;\n+\n+  while (which_alternative < nalternatives)\n+    {\n+      register int opno;\n+      int lose = 0;\n+      funny_match_index = 0;\n+\n+      for (opno = 0; opno < noperands; opno++)\n+\t{\n+\t  register rtx op = recog_operand[opno];\n+\t  enum machine_mode mode = GET_MODE (op);\n+\t  register char *p = constraints[opno];\n+\t  int offset = 0;\n+\t  int win = 0;\n+\t  int val;\n+\n+\t  if (GET_CODE (op) == SUBREG)\n+\t    {\n+\t      if (GET_CODE (SUBREG_REG (op)) == REG\n+\t\t  && REGNO (SUBREG_REG (op)) < FIRST_PSEUDO_REGISTER)\n+\t\toffset = SUBREG_WORD (op);\n+\t      op = SUBREG_REG (op);\n+\t    }\n+\n+\t  /* An empty constraint or empty alternative\n+\t     allows anything which matched the pattern.  */\n+\t  if (*p == 0 || *p == ',')\n+\t    win = 1;\n+\n+\t  while (*p && (c = *p++) != ',')\n+\t    switch (c)\n+\t      {\n+\t      case '=':\n+\t      case '+':\n+\t      case '?':\n+\t      case '#':\n+\t      case '&':\n+\t      case '!':\n+\t      case '*':\n+\t      case '%':\n+\t\tbreak;\n+\n+\t      case '0':\n+\t      case '1':\n+\t      case '2':\n+\t      case '3':\n+\t      case '4':\n+\t\t/* This operand must be the same as a previous one.\n+\t\t   This kind of constraint is used for instructions such\n+\t\t   as add when they take only two operands.\n+\n+\t\t   Note that the lower-numbered operand is passed first.\n+\n+\t\t   If we are not testing strictly, assume that this constraint\n+\t\t   will be satisfied.  */\n+\t\tif (strict < 0)\n+\t\t  val = 1;\n+\t\telse\n+\t\t  val = operands_match_p (recog_operand[c - '0'],\n+\t\t\t\t\t  recog_operand[opno]);\n+\n+\t\tif (val != 0)\n+\t\t  win = 1;\n+\t\t/* If output is *x and input is *--x,\n+\t\t   arrange later to change the output to *--x as well,\n+\t\t   since the output op is the one that will be printed.  */\n+\t\tif (val == 2 && strict > 0)\n+\t\t  {\n+\t\t    funny_match[funny_match_index].this = opno;\n+\t\t    funny_match[funny_match_index++].other = c - '0';\n+\t\t  }\n+\t\tbreak;\n+\n+\t      case 'p':\n+\t\t/* p is used for address_operands.  When we are called by\n+\t\t   gen_input_reload, no one will have checked that the\n+\t\t   address is strictly valid, i.e., that all pseudos\n+\t\t   requiring hard regs have gotten them.  */\n+\t\tif (strict <= 0\n+\t\t    || (strict_memory_address_p\n+\t\t\t(insn_operand_mode[insn_code_num][opno], op)))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t\t/* No need to check general_operand again;\n+\t\t   it was done in insn-recog.c.  */\n+\t      case 'g':\n+\t\t/* Anything goes unless it is a REG and really has a hard reg\n+\t\t   but the hard reg is not in the class GENERAL_REGS.  */\n+\t\tif (strict < 0\n+\t\t    || GENERAL_REGS == ALL_REGS\n+\t\t    || GET_CODE (op) != REG\n+\t\t    || reg_fits_class_p (op, GENERAL_REGS, offset, mode))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 'r':\n+\t\tif (strict < 0\n+\t\t    || (strict == 0\n+\t\t\t&& GET_CODE (op) == REG\n+\t\t\t&& REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+\t\t    || (strict == 0 && GET_CODE (op) == SCRATCH)\n+\t\t    || (GET_CODE (op) == REG\n+\t\t\t&& (GENERAL_REGS == ALL_REGS\n+\t\t\t    || reg_fits_class_p (op, GENERAL_REGS,\n+\t\t\t\t\t\t offset, mode))))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 'X':\n+\t\t/* This is used for a MATCH_SCRATCH in the cases when we\n+\t\t   don't actually need anything.  So anything goes any time. */\n+\t\twin = 1;\n+\t\tbreak;\n+\n+\t      case 'm':\n+\t\tif (GET_CODE (op) == MEM\n+\t\t    /* Before reload, accept what reload can turn into mem.  */\n+\t\t    || (strict < 0 && CONSTANT_P (op)))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case '<':\n+\t\tif (GET_CODE (op) == MEM\n+\t\t    && (GET_CODE (XEXP (op, 0)) == PRE_DEC\n+\t\t\t|| GET_CODE (XEXP (op, 0)) == POST_DEC))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case '>':\n+\t\tif (GET_CODE (op) == MEM\n+\t\t    && (GET_CODE (XEXP (op, 0)) == PRE_INC\n+\t\t\t|| GET_CODE (XEXP (op, 0)) == POST_INC))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 'E':\n+\t\t/* Match any CONST_DOUBLE, but only if\n+\t\t   we can examine the bits of it reliably.  */\n+\t\tif ((HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n+\t\t     || HOST_BITS_PER_INT != BITS_PER_WORD)\n+\t\t    && GET_CODE (op) != VOIDmode && ! flag_pretend_float)\n+\t\t  break;\n+\t\tif (GET_CODE (op) == CONST_DOUBLE)\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 'F':\n+\t\tif (GET_CODE (op) == CONST_DOUBLE)\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 'G':\n+\t      case 'H':\n+\t\tif (GET_CODE (op) == CONST_DOUBLE\n+\t\t    && CONST_DOUBLE_OK_FOR_LETTER_P (op, c))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 's':\n+\t\tif (GET_CODE (op) == CONST_INT\n+\t\t    || (GET_CODE (op) == CONST_DOUBLE\n+\t\t\t&& GET_MODE (op) == VOIDmode))\n+\t\t  break;\n+\t      case 'i':\n+\t\tif (CONSTANT_P (op))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 'n':\n+\t\tif (GET_CODE (op) == CONST_INT\n+\t\t    || (GET_CODE (op) == CONST_DOUBLE\n+\t\t\t&& GET_MODE (op) == VOIDmode))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 'I':\n+\t      case 'J':\n+\t      case 'K':\n+\t      case 'L':\n+\t      case 'M':\n+\t      case 'N':\n+\t      case 'O':\n+\t      case 'P':\n+\t\tif (GET_CODE (op) == CONST_INT\n+\t\t    && CONST_OK_FOR_LETTER_P (INTVAL (op), c))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+#ifdef EXTRA_CONSTRAINT\n+              case 'Q':\n+              case 'R':\n+              case 'S':\n+              case 'T':\n+              case 'U':\n+\t\tif (EXTRA_CONSTRAINT (op, c))\n+\t\t  win = 1;\n+\t\tbreak;\n+#endif\n+\n+\t      case 'V':\n+\t\tif (GET_CODE (op) == MEM\n+\t\t    && ! offsettable_memref_p (op))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 'o':\n+\t\tif ((strict > 0 && offsettable_memref_p (op))\n+\t\t    || (strict == 0 && offsettable_nonstrict_memref_p (op))\n+\t\t    /* Before reload, accept what reload can handle.  */\n+\t\t    || (strict < 0\n+\t\t\t&& (CONSTANT_P (op) || GET_CODE (op) == MEM)))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      default:\n+\t\tif (strict < 0\n+\t\t    || (strict == 0\n+\t\t\t&& GET_CODE (op) == REG\n+\t\t\t&& REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+\t\t    || (strict == 0 && GET_CODE (op) == SCRATCH)\n+\t\t    || (GET_CODE (op) == REG\n+\t\t\t&& reg_fits_class_p (op, REG_CLASS_FROM_LETTER (c),\n+\t\t\t\t\t     offset, mode)))\n+\t\t  win = 1;\n+\t      }\n+\n+\t  constraints[opno] = p;\n+\t  /* If this operand did not win somehow,\n+\t     this alternative loses.  */\n+\t  if (! win)\n+\t    lose = 1;\n+\t}\n+      /* This alternative won; the operands are ok.\n+\t Change whichever operands this alternative says to change.  */\n+      if (! lose)\n+\t{\n+\t  while (--funny_match_index >= 0)\n+\t    {\n+\t      recog_operand[funny_match[funny_match_index].other]\n+\t\t= recog_operand[funny_match[funny_match_index].this];\n+\t    }\n+\t  return 1;\n+\t}\n+\n+      which_alternative++;\n+    }\n+\n+  /* If we are about to reject this, but we are not to test strictly,\n+     try a very loose test.  Only return failure if it fails also.  */\n+  if (strict == 0)\n+    return constrain_operands (insn_code_num, -1);\n+  else\n+    return 0;\n+}\n+\n+/* Return 1 iff OPERAND (assumed to be a REG rtx)\n+   is a hard reg in class CLASS when its regno is offsetted by OFFSET\n+   and changed to mode MODE.\n+   If REG occupies multiple hard regs, all of them must be in CLASS.  */\n+\n+int\n+reg_fits_class_p (operand, class, offset, mode)\n+     rtx operand;\n+     register enum reg_class class;\n+     int offset;\n+     enum machine_mode mode;\n+{\n+  register int regno = REGNO (operand);\n+  if (regno < FIRST_PSEUDO_REGISTER\n+      && TEST_HARD_REG_BIT (reg_class_contents[(int) class],\n+\t\t\t    regno + offset))\n+    {\n+      register int sr;\n+      regno += offset;\n+      for (sr = HARD_REGNO_NREGS (regno, mode) - 1;\n+\t   sr > 0; sr--)\n+\tif (! TEST_HARD_REG_BIT (reg_class_contents[(int) class],\n+\t\t\t\t regno + sr))\n+\t  break;\n+      return sr == 0;\n+    }\n+\n+  return 0;\n+}\n+\n+#endif /* REGISTER_CONSTRAINTS */"}]}