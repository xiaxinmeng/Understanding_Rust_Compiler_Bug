{"sha": "df1afcca584270fcb6b8902492758b5ec261a4d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGYxYWZjY2E1ODQyNzBmY2I2Yjg5MDI0OTI3NThiNWVjMjYxYTRkNQ==", "commit": {"author": {"name": "Harald Anlauf", "email": "anlauf@gmx.de", "date": "2019-07-16T19:58:15Z"}, "committer": {"name": "Harald Anlauf", "email": "anlauf@gcc.gnu.org", "date": "2019-07-16T19:58:15Z"}, "message": "re PR fortran/90903 (Implement runtime checks for bit manipulation intrinsics)\n\n2019-07-16  Harald Anlauf  <anlauf@gmx.de>\n\n\tPR fortran/90903\n\t* libgfortran.h: Add mask for -fcheck=bits option.\n\t* options.c (gfc_handle_runtime_check_option): Add option \"bits\"\n\tto run-time checks selectable via -fcheck.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_btest)\n\t(gfc_conv_intrinsic_singlebitop, gfc_conv_intrinsic_ibits)\n\t(gfc_conv_intrinsic_shift, gfc_conv_intrinsic_ishft)\n\t(gfc_conv_intrinsic_ishftc): Implement run-time checks for the\n\tPOS, LEN, SHIFT, and SIZE arguments.\n\t* gfortran.texi: Document run-time checks for bit manipulation\n\tintrinsics.\n\t* invoke.texi: Document new -fcheck=bits option.\n\n\tPR fortran/90903\n\t* gfortran.dg/check_bits_1.f90: New testcase.\n\nFrom-SVN: r273535", "tree": {"sha": "877d574bcb5078adbad39bbac737be31206f86d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/877d574bcb5078adbad39bbac737be31206f86d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df1afcca584270fcb6b8902492758b5ec261a4d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df1afcca584270fcb6b8902492758b5ec261a4d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df1afcca584270fcb6b8902492758b5ec261a4d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df1afcca584270fcb6b8902492758b5ec261a4d5/comments", "author": {"login": "harald-anlauf", "id": 90786862, "node_id": "MDQ6VXNlcjkwNzg2ODYy", "avatar_url": "https://avatars.githubusercontent.com/u/90786862?v=4", "gravatar_id": "", "url": "https://api.github.com/users/harald-anlauf", "html_url": "https://github.com/harald-anlauf", "followers_url": "https://api.github.com/users/harald-anlauf/followers", "following_url": "https://api.github.com/users/harald-anlauf/following{/other_user}", "gists_url": "https://api.github.com/users/harald-anlauf/gists{/gist_id}", "starred_url": "https://api.github.com/users/harald-anlauf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/harald-anlauf/subscriptions", "organizations_url": "https://api.github.com/users/harald-anlauf/orgs", "repos_url": "https://api.github.com/users/harald-anlauf/repos", "events_url": "https://api.github.com/users/harald-anlauf/events{/privacy}", "received_events_url": "https://api.github.com/users/harald-anlauf/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "460bf043c8266dd080308f4783137aee0d0f862c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/460bf043c8266dd080308f4783137aee0d0f862c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/460bf043c8266dd080308f4783137aee0d0f862c"}], "stats": {"total": 254, "additions": 247, "deletions": 7}, "files": [{"sha": "342aaa5a2f8efdb50938b55e8780b1f478f123c5", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1afcca584270fcb6b8902492758b5ec261a4d5/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1afcca584270fcb6b8902492758b5ec261a4d5/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=df1afcca584270fcb6b8902492758b5ec261a4d5", "patch": "@@ -1,3 +1,18 @@\n+2019-07-16  Harald Anlauf  <anlauf@gmx.de>\n+\n+\tPR fortran/90903\n+\t* libgfortran.h: Add mask for -fcheck=bits option.\n+\t* options.c (gfc_handle_runtime_check_option): Add option \"bits\"\n+\tto run-time checks selectable via -fcheck.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_btest)\n+\t(gfc_conv_intrinsic_singlebitop, gfc_conv_intrinsic_ibits)\n+\t(gfc_conv_intrinsic_shift, gfc_conv_intrinsic_ishft)\n+\t(gfc_conv_intrinsic_ishftc): Implement run-time checks for the\n+\tPOS, LEN, SHIFT, and SIZE arguments.\n+\t* gfortran.texi: Document run-time checks for bit manipulation\n+\tintrinsics.\n+\t* invoke.texi: Document new -fcheck=bits option.\n+\n 2019-07-14  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/87233"}, {"sha": "4f654508abc5cfb904d7eb5b59ec806fc37439d4", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1afcca584270fcb6b8902492758b5ec261a4d5/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1afcca584270fcb6b8902492758b5ec261a4d5/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=df1afcca584270fcb6b8902492758b5ec261a4d5", "patch": "@@ -3790,7 +3790,8 @@ initialization using @code{_gfortran_set_args}.\n Default: enabled.\n @item @var{option}[6] @tab Enables run-time checking.  Possible values\n are (bitwise or-ed): GFC_RTCHECK_BOUNDS (1), GFC_RTCHECK_ARRAY_TEMPS (2),\n-GFC_RTCHECK_RECURSION (4), GFC_RTCHECK_DO (16), GFC_RTCHECK_POINTER (32).\n+GFC_RTCHECK_RECURSION (4), GFC_RTCHECK_DO (16), GFC_RTCHECK_POINTER (32),\n+GFC_RTCHECK_BITS (64).\n Default: disabled.\n @item @var{option}[7] @tab Unused.\n @item @var{option}[8] @tab Show a warning when invoking @code{STOP} and"}, {"sha": "f8efcd824ebdb5a7ae699219b64d6d7daf2b07c2", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1afcca584270fcb6b8902492758b5ec261a4d5/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1afcca584270fcb6b8902492758b5ec261a4d5/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=df1afcca584270fcb6b8902492758b5ec261a4d5", "patch": "@@ -183,7 +183,7 @@ and warnings}.\n @gccoptlist{-faggressive-function-elimination -fblas-matmul-limit=@var{n} @gol\n -fbounds-check -ftail-call-workaround -ftail-call-workaround=@var{n} @gol\n -fcheck-array-temporaries @gol\n--fcheck=@var{<all|array-temps|bounds|do|mem|pointer|recursion>} @gol\n+-fcheck=@var{<all|array-temps|bits|bounds|do|mem|pointer|recursion>} @gol\n -fcoarray=@var{<none|single|lib>} -fexternal-blas -ff2c\n -ffrontend-loop-interchange @gol\n -ffrontend-optimize @gol\n@@ -1558,6 +1558,7 @@ library needs to be linked.\n @item -fcheck=@var{<keyword>}\n @opindex @code{fcheck}\n @cindex array, bounds checking\n+@cindex bit intrinsics checking\n @cindex bounds checking\n @cindex pointer checking\n @cindex memory checking\n@@ -1582,6 +1583,10 @@ sometimes useful in optimization, in order to avoid such temporaries.\n \n Note: The warning is only printed once per location.\n \n+@item @samp{bits}\n+Enable generation of run-time checks for invalid arguments to the bit\n+manipulation intrinsics.\n+\n @item @samp{bounds}\n Enable generation of run-time checks for array subscripts\n and against the declared minimum and maximum values.  It also"}, {"sha": "f82fc6a2730d7285dee620285e7b74c7a49fa06c", "filename": "gcc/fortran/libgfortran.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1afcca584270fcb6b8902492758b5ec261a4d5/gcc%2Ffortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1afcca584270fcb6b8902492758b5ec261a4d5/gcc%2Ffortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flibgfortran.h?ref=df1afcca584270fcb6b8902492758b5ec261a4d5", "patch": "@@ -73,9 +73,11 @@ along with GCC; see the file COPYING3.  If not see\n #define GFC_RTCHECK_DO          (1<<3)\n #define GFC_RTCHECK_POINTER     (1<<4)\n #define GFC_RTCHECK_MEM         (1<<5)\n+#define GFC_RTCHECK_BITS        (1<<6)\n #define GFC_RTCHECK_ALL        (GFC_RTCHECK_BOUNDS | GFC_RTCHECK_ARRAY_TEMPS \\\n \t\t\t\t| GFC_RTCHECK_RECURSION | GFC_RTCHECK_DO \\\n-\t\t\t\t| GFC_RTCHECK_POINTER | GFC_RTCHECK_MEM)\n+\t\t\t\t| GFC_RTCHECK_POINTER | GFC_RTCHECK_MEM \\\n+\t\t\t\t| GFC_RTCHECK_BITS)\n \n /* Special unit numbers used to convey certain conditions.  Numbers -4\n    thru -9 available.  NEWUNIT values start at -10.  */"}, {"sha": "ef37cccec977998e112e7af4d06fc9c0d0a9bd32", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1afcca584270fcb6b8902492758b5ec261a4d5/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1afcca584270fcb6b8902492758b5ec261a4d5/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=df1afcca584270fcb6b8902492758b5ec261a4d5", "patch": "@@ -580,12 +580,12 @@ gfc_handle_runtime_check_option (const char *arg)\n   int result, pos = 0, n;\n   static const char * const optname[] = { \"all\", \"bounds\", \"array-temps\",\n \t\t\t\t\t  \"recursion\", \"do\", \"pointer\",\n-\t\t\t\t\t  \"mem\", NULL };\n+\t\t\t\t\t  \"mem\", \"bits\", NULL };\n   static const int optmask[] = { GFC_RTCHECK_ALL, GFC_RTCHECK_BOUNDS,\n \t\t\t\t GFC_RTCHECK_ARRAY_TEMPS,\n \t\t\t\t GFC_RTCHECK_RECURSION, GFC_RTCHECK_DO,\n \t\t\t\t GFC_RTCHECK_POINTER, GFC_RTCHECK_MEM,\n-\t\t\t\t 0 };\n+\t\t\t\t GFC_RTCHECK_BITS, 0 };\n  \n   while (*arg)\n     {"}, {"sha": "a6e33833680a01f33929f1d5c34b77aba592d60b", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 165, "deletions": 2, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1afcca584270fcb6b8902492758b5ec261a4d5/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1afcca584270fcb6b8902492758b5ec261a4d5/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=df1afcca584270fcb6b8902492758b5ec261a4d5", "patch": "@@ -6166,6 +6166,24 @@ gfc_conv_intrinsic_btest (gfc_se * se, gfc_expr * expr)\n   gfc_conv_intrinsic_function_args (se, expr, args, 2);\n   type = TREE_TYPE (args[0]);\n \n+  /* Optionally generate code for runtime argument check.  */\n+  if (gfc_option.rtcheck & GFC_RTCHECK_BITS)\n+    {\n+      tree below = fold_build2_loc (input_location, LT_EXPR,\n+\t\t\t\t    logical_type_node, args[1],\n+\t\t\t\t    build_int_cst (TREE_TYPE (args[1]), 0));\n+      tree nbits = build_int_cst (TREE_TYPE (args[1]), TYPE_PRECISION (type));\n+      tree above = fold_build2_loc (input_location, GE_EXPR,\n+\t\t\t\t    logical_type_node, args[1], nbits);\n+      tree scond = fold_build2_loc (input_location, TRUTH_ORIF_EXPR,\n+\t\t\t\t    logical_type_node, below, above);\n+      gfc_trans_runtime_check (true, false, scond, &se->pre, &expr->where,\n+\t\t\t       \"POS argument (%ld) out of range 0:%ld \"\n+\t\t\t       \"in intrinsic BTEST\",\n+\t\t\t       fold_convert (long_integer_type_node, args[1]),\n+\t\t\t       fold_convert (long_integer_type_node, nbits));\n+    }\n+\n   tmp = fold_build2_loc (input_location, LSHIFT_EXPR, type,\n \t\t\t build_int_cst (type, 1), args[1]);\n   tmp = fold_build2_loc (input_location, BIT_AND_EXPR, type, args[0], tmp);\n@@ -6236,6 +6254,32 @@ gfc_conv_intrinsic_singlebitop (gfc_se * se, gfc_expr * expr, int set)\n   gfc_conv_intrinsic_function_args (se, expr, args, 2);\n   type = TREE_TYPE (args[0]);\n \n+  /* Optionally generate code for runtime argument check.  */\n+  if (gfc_option.rtcheck & GFC_RTCHECK_BITS)\n+    {\n+      tree below = fold_build2_loc (input_location, LT_EXPR,\n+\t\t\t\t    logical_type_node, args[1],\n+\t\t\t\t    build_int_cst (TREE_TYPE (args[1]), 0));\n+      tree nbits = build_int_cst (TREE_TYPE (args[1]), TYPE_PRECISION (type));\n+      tree above = fold_build2_loc (input_location, GE_EXPR,\n+\t\t\t\t    logical_type_node, args[1], nbits);\n+      tree scond = fold_build2_loc (input_location, TRUTH_ORIF_EXPR,\n+\t\t\t\t    logical_type_node, below, above);\n+      size_t len_name = strlen (expr->value.function.isym->name);\n+      char *name = XALLOCAVEC (char, len_name + 1);\n+      for (size_t i = 0; i < len_name; i++)\n+\tname[i] = TOUPPER (expr->value.function.isym->name[i]);\n+      name[len_name] = '\\0';\n+      tree iname = gfc_build_addr_expr (pchar_type_node,\n+\t\t\t\t\tgfc_build_cstring_const (name));\n+      gfc_trans_runtime_check (true, false, scond, &se->pre, &expr->where,\n+\t\t\t       \"POS argument (%ld) out of range 0:%ld \"\n+\t\t\t       \"in intrinsic %s\",\n+\t\t\t       fold_convert (long_integer_type_node, args[1]),\n+\t\t\t       fold_convert (long_integer_type_node, nbits),\n+\t\t\t       iname);\n+    }\n+\n   tmp = fold_build2_loc (input_location, LSHIFT_EXPR, type,\n \t\t\t build_int_cst (type, 1), args[1]);\n   if (set)\n@@ -6261,6 +6305,42 @@ gfc_conv_intrinsic_ibits (gfc_se * se, gfc_expr * expr)\n   gfc_conv_intrinsic_function_args (se, expr, args, 3);\n   type = TREE_TYPE (args[0]);\n \n+  /* Optionally generate code for runtime argument check.  */\n+  if (gfc_option.rtcheck & GFC_RTCHECK_BITS)\n+    {\n+      tree tmp1 = fold_convert (long_integer_type_node, args[1]);\n+      tree tmp2 = fold_convert (long_integer_type_node, args[2]);\n+      tree nbits = build_int_cst (long_integer_type_node,\n+\t\t\t\t  TYPE_PRECISION (type));\n+      tree below = fold_build2_loc (input_location, LT_EXPR,\n+\t\t\t\t    logical_type_node, args[1],\n+\t\t\t\t    build_int_cst (TREE_TYPE (args[1]), 0));\n+      tree above = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t\t    logical_type_node, tmp1, nbits);\n+      tree scond = fold_build2_loc (input_location, TRUTH_ORIF_EXPR,\n+\t\t\t\t    logical_type_node, below, above);\n+      gfc_trans_runtime_check (true, false, scond, &se->pre, &expr->where,\n+\t\t\t       \"POS argument (%ld) out of range 0:%ld \"\n+\t\t\t       \"in intrinsic IBITS\", tmp1, nbits);\n+      below = fold_build2_loc (input_location, LT_EXPR,\n+\t\t\t       logical_type_node, args[2],\n+\t\t\t       build_int_cst (TREE_TYPE (args[2]), 0));\n+      above = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t       logical_type_node, tmp2, nbits);\n+      scond = fold_build2_loc (input_location, TRUTH_ORIF_EXPR,\n+\t\t\t       logical_type_node, below, above);\n+      gfc_trans_runtime_check (true, false, scond, &se->pre, &expr->where,\n+\t\t\t       \"LEN argument (%ld) out of range 0:%ld \"\n+\t\t\t       \"in intrinsic IBITS\", tmp2, nbits);\n+      above = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t       long_integer_type_node, tmp1, tmp2);\n+      scond = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t       logical_type_node, above, nbits);\n+      gfc_trans_runtime_check (true, false, scond, &se->pre, &expr->where,\n+\t\t\t       \"POS(%ld)+LEN(%ld)>BIT_SIZE(%ld) \"\n+\t\t\t       \"in intrinsic IBITS\", tmp1, tmp2, nbits);\n+    }\n+\n   mask = build_int_cst (type, -1);\n   mask = fold_build2_loc (input_location, LSHIFT_EXPR, type, mask, args[2]);\n   mask = fold_build1_loc (input_location, BIT_NOT_EXPR, type, mask);\n@@ -6382,6 +6462,32 @@ gfc_conv_intrinsic_shift (gfc_se * se, gfc_expr * expr, bool right_shift,\n      gcc requires a shift width < BIT_SIZE(I), so we have to catch this\n      special case.  */\n   num_bits = build_int_cst (TREE_TYPE (args[1]), TYPE_PRECISION (type));\n+\n+  /* Optionally generate code for runtime argument check.  */\n+  if (gfc_option.rtcheck & GFC_RTCHECK_BITS)\n+    {\n+      tree below = fold_build2_loc (input_location, LT_EXPR,\n+\t\t\t\t    logical_type_node, args[1],\n+\t\t\t\t    build_int_cst (TREE_TYPE (args[1]), 0));\n+      tree above = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t\t    logical_type_node, args[1], num_bits);\n+      tree scond = fold_build2_loc (input_location, TRUTH_ORIF_EXPR,\n+\t\t\t\t    logical_type_node, below, above);\n+      size_t len_name = strlen (expr->value.function.isym->name);\n+      char *name = XALLOCAVEC (char, len_name + 1);\n+      for (size_t i = 0; i < len_name; i++)\n+\tname[i] = TOUPPER (expr->value.function.isym->name[i]);\n+      name[len_name] = '\\0';\n+      tree iname = gfc_build_addr_expr (pchar_type_node,\n+\t\t\t\t\tgfc_build_cstring_const (name));\n+      gfc_trans_runtime_check (true, false, scond, &se->pre, &expr->where,\n+\t\t\t       \"SHIFT argument (%ld) out of range 0:%ld \"\n+\t\t\t       \"in intrinsic %s\",\n+\t\t\t       fold_convert (long_integer_type_node, args[1]),\n+\t\t\t       fold_convert (long_integer_type_node, num_bits),\n+\t\t\t       iname);\n+    }\n+\n   cond = fold_build2_loc (input_location, GE_EXPR, logical_type_node,\n \t\t\t  args[1], num_bits);\n \n@@ -6436,6 +6542,20 @@ gfc_conv_intrinsic_ishft (gfc_se * se, gfc_expr * expr)\n      gcc requires a shift width < BIT_SIZE(I), so we have to catch this\n      special case.  */\n   num_bits = build_int_cst (TREE_TYPE (args[1]), TYPE_PRECISION (type));\n+\n+  /* Optionally generate code for runtime argument check.  */\n+  if (gfc_option.rtcheck & GFC_RTCHECK_BITS)\n+    {\n+      tree outside = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t\t    logical_type_node, width, num_bits);\n+      gfc_trans_runtime_check (true, false, outside, &se->pre, &expr->where,\n+\t\t\t       \"SHIFT argument (%ld) out of range -%ld:%ld \"\n+\t\t\t       \"in intrinsic ISHFT\",\n+\t\t\t       fold_convert (long_integer_type_node, args[1]),\n+\t\t\t       fold_convert (long_integer_type_node, num_bits),\n+\t\t\t       fold_convert (long_integer_type_node, num_bits));\n+    }\n+\n   cond = fold_build2_loc (input_location, GE_EXPR, logical_type_node, width,\n \t\t\t  num_bits);\n   se->expr = fold_build3_loc (input_location, COND_EXPR, type, cond,\n@@ -6454,19 +6574,22 @@ gfc_conv_intrinsic_ishftc (gfc_se * se, gfc_expr * expr)\n   tree lrot;\n   tree rrot;\n   tree zero;\n+  tree nbits;\n   unsigned int num_args;\n \n   num_args = gfc_intrinsic_argument_list_length (expr);\n   args = XALLOCAVEC (tree, num_args);\n \n   gfc_conv_intrinsic_function_args (se, expr, args, num_args);\n \n+  type = TREE_TYPE (args[0]);\n+  nbits = build_int_cst (long_integer_type_node, TYPE_PRECISION (type));\n+\n   if (num_args == 3)\n     {\n       /* Use a library function for the 3 parameter version.  */\n       tree int4type = gfc_get_int_type (4);\n \n-      type = TREE_TYPE (args[0]);\n       /* We convert the first argument to at least 4 bytes, and\n \t convert back afterwards.  This removes the need for library\n \t functions for all argument sizes, and function will be\n@@ -6480,6 +6603,32 @@ gfc_conv_intrinsic_ishftc (gfc_se * se, gfc_expr * expr)\n       args[1] = convert (int4type, args[1]);\n       args[2] = convert (int4type, args[2]);\n \n+      /* Optionally generate code for runtime argument check.  */\n+      if (gfc_option.rtcheck & GFC_RTCHECK_BITS)\n+\t{\n+\t  tree size = fold_convert (long_integer_type_node, args[2]);\n+\t  tree below = fold_build2_loc (input_location, LE_EXPR,\n+\t\t\t\t\tlogical_type_node, size,\n+\t\t\t\t\tbuild_int_cst (TREE_TYPE (args[1]), 0));\n+\t  tree above = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t\t\tlogical_type_node, size, nbits);\n+\t  tree scond = fold_build2_loc (input_location, TRUTH_ORIF_EXPR,\n+\t\t\t\t\tlogical_type_node, below, above);\n+\t  gfc_trans_runtime_check (true, false, scond, &se->pre, &expr->where,\n+\t\t\t\t   \"SIZE argument (%ld) out of range 1:%ld \"\n+\t\t\t\t   \"in intrinsic ISHFTC\", size, nbits);\n+\t  tree width = fold_convert (long_integer_type_node, args[1]);\n+\t  width = fold_build1_loc (input_location, ABS_EXPR,\n+\t\t\t\t   long_integer_type_node, width);\n+\t  scond = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t\t   logical_type_node, width, size);\n+\t  gfc_trans_runtime_check (true, false, scond, &se->pre, &expr->where,\n+\t\t\t\t   \"SHIFT argument (%ld) out of range -%ld:%ld \"\n+\t\t\t\t   \"in intrinsic ISHFTC\",\n+\t\t\t\t   fold_convert (long_integer_type_node, args[1]),\n+\t\t\t\t   size, size);\n+\t}\n+\n       switch (expr->ts.kind)\n \t{\n \tcase 1:\n@@ -6505,12 +6654,26 @@ gfc_conv_intrinsic_ishftc (gfc_se * se, gfc_expr * expr)\n \n       return;\n     }\n-  type = TREE_TYPE (args[0]);\n \n   /* Evaluate arguments only once.  */\n   args[0] = gfc_evaluate_now (args[0], &se->pre);\n   args[1] = gfc_evaluate_now (args[1], &se->pre);\n \n+  /* Optionally generate code for runtime argument check.  */\n+  if (gfc_option.rtcheck & GFC_RTCHECK_BITS)\n+    {\n+      tree width = fold_convert (long_integer_type_node, args[1]);\n+      width = fold_build1_loc (input_location, ABS_EXPR,\n+\t\t\t       long_integer_type_node, width);\n+      tree outside = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t\t      logical_type_node, width, nbits);\n+      gfc_trans_runtime_check (true, false, outside, &se->pre, &expr->where,\n+\t\t\t       \"SHIFT argument (%ld) out of range -%ld:%ld \"\n+\t\t\t       \"in intrinsic ISHFTC\",\n+\t\t\t       fold_convert (long_integer_type_node, args[1]),\n+\t\t\t       nbits, nbits);\n+    }\n+\n   /* Rotate left if positive.  */\n   lrot = fold_build2_loc (input_location, LROTATE_EXPR, type, args[0], args[1]);\n "}, {"sha": "689299b53b78520b5876b93c2c172ff5f40a1367", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1afcca584270fcb6b8902492758b5ec261a4d5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1afcca584270fcb6b8902492758b5ec261a4d5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=df1afcca584270fcb6b8902492758b5ec261a4d5", "patch": "@@ -1,3 +1,8 @@\n+2019-07-16  Harald Anlauf  <anlauf@gmx.de>\n+\n+\tPR fortran/90903\n+\t* gfortran.dg/check_bits_1.f90: New testcase.\n+\n 2019-07-16  Jeff Law  <law@redhat.com>\n \n \tPR rtl-optimization/91173"}, {"sha": "1ed3e81bcca00105bf62edd281840d13e5fb1b6f", "filename": "gcc/testsuite/gfortran.dg/check_bits_1.f90", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1afcca584270fcb6b8902492758b5ec261a4d5/gcc%2Ftestsuite%2Fgfortran.dg%2Fcheck_bits_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1afcca584270fcb6b8902492758b5ec261a4d5/gcc%2Ftestsuite%2Fgfortran.dg%2Fcheck_bits_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcheck_bits_1.f90?ref=df1afcca584270fcb6b8902492758b5ec261a4d5", "patch": "@@ -0,0 +1,49 @@\n+! { dg-do run }\n+! { dg-options \"-fcheck=bits -fdump-tree-original\" }\n+! { dg-shouldfail \"Fortran runtime error: SIZE argument (0) out of range 1:32 in intrinsic ISHFTC\" }\n+! { dg-output \"At line 44 .*\" }\n+!\n+! Verify that the runtime checks for the bit manipulation intrinsic functions\n+! do not generate false-positives\n+program check\n+  implicit none\n+  integer :: i, k, pos, len, shift, size, nb\n+  nb = bit_size (i)\n+  i = 0\n+  do pos = 0, nb-1\n+     k = ibset (i, pos)\n+     i = ibclr (k, pos)\n+     if (btest (i, pos)) stop 1\n+  end do\n+  do pos = 0, nb\n+     do len = 0, nb-pos\n+        i = ibits (i, pos, len)\n+     end do\n+  end do\n+  do shift = 0, nb\n+     k = ishft (i,  shift)\n+     i = ishft (k, -shift)\n+  end do\n+  do shift = 0, nb\n+     k = shiftl (i, shift) ! Fortran 2008\n+     i = shiftr (k, shift)\n+     i = shifta (i, shift)\n+     k = lshift (i, shift) ! GNU extensions\n+     i = rshift (k, shift)\n+  end do\n+  do shift = 0, nb\n+     k = ishftc (i,  shift)\n+     i = ishftc (k, -shift)\n+     do size = max (1,shift), nb\n+        k = ishftc (i,  shift, size)\n+        i = ishftc (k, -shift, size)\n+     end do\n+  end do\n+  size = 0\n+  ! The following line should fail with a runtime error:\n+  k = ishftc (i, 0, size)\n+  ! Should never get here with -fcheck=bits\n+  stop 2\n+end program check\n+\n+! { dg-final { scan-tree-dump-times \"_gfortran_runtime_error_at\" 21 \"original\" } }"}]}