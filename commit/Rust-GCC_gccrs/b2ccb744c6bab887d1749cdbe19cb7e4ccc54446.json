{"sha": "b2ccb744c6bab887d1749cdbe19cb7e4ccc54446", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJjY2I3NDRjNmJhYjg4N2QxNzQ5Y2RiZTE5Y2I3ZTRjY2M1NDQ0Ng==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2002-06-11T13:53:02Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2002-06-11T13:53:02Z"}, "message": "s390.md (reload_base, ltorg): Remove.\n\n\t* config/s390/s390.md (reload_base, ltorg): Remove.\n\t* s390.c (s390_stop_dump_lit_p, s390_dump_literal_pool,\n\ts390_asm_output_pool_prologue, s390_pool_start_insn): Remove.\n\t* s390-protos.h (s390_stop_dump_lit_p, s390_dump_literal_pool,\n\ts390_asm_output_pool_prologue): Likewise.\n\t* s390.h (s390_pool_start_insn): Likewise.\n\n\t* s390.c (s390_output_symbolic_const): Remove support for\n\told-style pool chunks.\n\t(s390_function_epilogue): Likewise.\n\t(s390_output_constant_pool): Likewise.  Also, fix incorrect\n\talignment for 64-bit literal pools.\n\t(print_operand_address): Remove 'y' and 'Y' format flags.\n\t* s390.h (ASM_OUTPUT_POOL_PROLOGUE): Remove support for\n\told-style pool chunks.\n\t(ASM_OUTPUT_SPECIAL_POOL_ENTRY): Likewise.\n\t(ASM_OUTPUT_POOL_EPILOGUE): Remove.\n\t(S390_CHUNK_MAX, S390_CHUNK_OV, S390_POOL_MAX): Remove.\n\n\t* s390.c (consttable_operand): New function.\n\t* s390-protos.h (consttable_operand): Declare it.\n\t* s390.h (PREDICATE_CODES): Add consttable_operand.\n\t* s390.md (consttable_qi, consttable_hi, consttable_si, consttable_di,\n\tconsttable_sf, consttable_df, pool_start_31, pool_end_31,\n\tpool_start_64, pool_end_64, reload_base, reload_base2): New insns.\n\t* s390.c (struct constant, struct constant_pool): New data types.\n\t(constant_modes, gen_consttable): New variables.\n\t(s390_start_pool, s390_end_pool, s390_add_pool,\n\ts390_dump_pool, s390_free_pool): New functions.\n\t(s390_chunkify_pool): Completely reimplement literal pool\n\toverflow handling.\n\n\t* s390.c (s390_pool_overflow): New variable.\n\t* s390.h (s390_pool_overflow): Declare it.\n\t* s390.md (cjump, icjump): Use it to adapt length for out-of-range\n\tjumps in literal pool overflow situations.\n\n\t* s390.c (s390_decompose_address): Accept new-style pool chunk offsets.\n\t(s390_frame_info): Account for possible use of RETURN_REGNUM\n\tby new literal pool overflow code.\n\t(s390_emit_prologue): Likewise.\n\nFrom-SVN: r54500", "tree": {"sha": "69933cdc01fa9fea2fb96a7a30e44d3c2648be6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69933cdc01fa9fea2fb96a7a30e44d3c2648be6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2ccb744c6bab887d1749cdbe19cb7e4ccc54446", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2ccb744c6bab887d1749cdbe19cb7e4ccc54446", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2ccb744c6bab887d1749cdbe19cb7e4ccc54446", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2ccb744c6bab887d1749cdbe19cb7e4ccc54446/comments", "author": null, "committer": null, "parents": [{"sha": "2f937369fa50dfd2f5af11b18d30c5489451072c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f937369fa50dfd2f5af11b18d30c5489451072c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f937369fa50dfd2f5af11b18d30c5489451072c"}], "stats": {"total": 1081, "additions": 811, "deletions": 270}, "files": [{"sha": "d173955c810038a8cd585dd0bf571d926c35101c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2ccb744c6bab887d1749cdbe19cb7e4ccc54446/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2ccb744c6bab887d1749cdbe19cb7e4ccc54446/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b2ccb744c6bab887d1749cdbe19cb7e4ccc54446", "patch": "@@ -1,3 +1,47 @@\n+2002-06-11  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390.md (reload_base, ltorg): Remove.\n+\t* s390.c (s390_stop_dump_lit_p, s390_dump_literal_pool, \n+\ts390_asm_output_pool_prologue, s390_pool_start_insn): Remove.\n+\t* s390-protos.h (s390_stop_dump_lit_p, s390_dump_literal_pool, \n+\ts390_asm_output_pool_prologue): Likewise.\n+\t* s390.h (s390_pool_start_insn): Likewise.\n+\n+\t* s390.c (s390_output_symbolic_const): Remove support for \n+\told-style pool chunks.\n+\t(s390_function_epilogue): Likewise.\n+\t(s390_output_constant_pool): Likewise.  Also, fix incorrect \n+\talignment for 64-bit literal pools.\n+\t(print_operand_address): Remove 'y' and 'Y' format flags.\n+\t* s390.h (ASM_OUTPUT_POOL_PROLOGUE): Remove support for \n+\told-style pool chunks.\n+\t(ASM_OUTPUT_SPECIAL_POOL_ENTRY): Likewise.\n+\t(ASM_OUTPUT_POOL_EPILOGUE): Remove.\n+\t(S390_CHUNK_MAX, S390_CHUNK_OV, S390_POOL_MAX): Remove.\n+\n+\t* s390.c (consttable_operand): New function.\n+\t* s390-protos.h (consttable_operand): Declare it.\n+\t* s390.h (PREDICATE_CODES): Add consttable_operand.\n+\t* s390.md (consttable_qi, consttable_hi, consttable_si, consttable_di, \n+\tconsttable_sf, consttable_df, pool_start_31, pool_end_31, \n+\tpool_start_64, pool_end_64, reload_base, reload_base2): New insns.\n+\t* s390.c (struct constant, struct constant_pool): New data types.\n+\t(constant_modes, gen_consttable): New variables.\n+\t(s390_start_pool, s390_end_pool, s390_add_pool, \n+\ts390_dump_pool, s390_free_pool): New functions.\n+\t(s390_chunkify_pool): Completely reimplement literal pool \n+\toverflow handling.\n+\n+\t* s390.c (s390_pool_overflow): New variable.\n+\t* s390.h (s390_pool_overflow): Declare it.\n+\t* s390.md (cjump, icjump): Use it to adapt length for out-of-range \n+\tjumps in literal pool overflow situations.\n+\n+\t* s390.c (s390_decompose_address): Accept new-style pool chunk offsets.\n+\t(s390_frame_info): Account for possible use of RETURN_REGNUM \n+\tby new literal pool overflow code.\n+\t(s390_emit_prologue): Likewise.\n+\n 2002-06-05  David S. Miller  <davem@redhat.com>\n \n \tDelete SEQUENCE rtl usage outside of reorg and ssa passes."}, {"sha": "cd4ac10c7de5580a1446db097dc2d7e5928bdcd8", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2ccb744c6bab887d1749cdbe19cb7e4ccc54446/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2ccb744c6bab887d1749cdbe19cb7e4ccc54446/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=b2ccb744c6bab887d1749cdbe19cb7e4ccc54446", "patch": "@@ -32,6 +32,7 @@ extern void s390_function_profiler PARAMS ((FILE *, int));\n \n #ifdef RTX_CODE\n extern int const0_operand PARAMS ((rtx, enum machine_mode));\n+extern int consttable_operand PARAMS ((rtx, enum machine_mode));\n extern int larl_operand PARAMS ((rtx, enum machine_mode));\n extern int fp_operand PARAMS ((rtx, enum machine_mode));\n extern int s_operand PARAMS ((rtx, enum machine_mode));\n@@ -65,16 +66,13 @@ extern void s390_output_symbolic_const PARAMS ((FILE *, rtx));\n extern void print_operand_address PARAMS ((FILE *, rtx));\n extern void print_operand PARAMS ((FILE *, rtx, int));\n extern void s390_output_constant_pool PARAMS ((FILE *));\n-extern int s390_stop_dump_lit_p PARAMS ((rtx));\n-extern void s390_dump_literal_pool PARAMS ((rtx, rtx));\n extern void s390_trampoline_template PARAMS ((FILE *));\n extern void s390_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n extern rtx s390_gen_rtx_const_DI PARAMS ((int, int));\n extern rtx s390_simplify_dwarf_addr PARAMS ((rtx));\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE\n-extern void s390_asm_output_pool_prologue PARAMS ((FILE *, const char *, tree, int));\n extern int s390_function_arg_pass_by_reference PARAMS ((enum machine_mode, tree));\n extern void s390_function_arg_advance PARAMS ((CUMULATIVE_ARGS *, enum machine_mode, tree, int));\n extern tree s390_build_va_list PARAMS ((void));"}, {"sha": "b37f917031e8a43ac6cf0c80357afd2956233d47", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 639, "deletions": 198, "changes": 837, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2ccb744c6bab887d1749cdbe19cb7e4ccc54446/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2ccb744c6bab887d1749cdbe19cb7e4ccc54446/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=b2ccb744c6bab887d1749cdbe19cb7e4ccc54446", "patch": "@@ -140,6 +140,8 @@ static int s390_decompose_address PARAMS ((rtx, struct s390_address *, int));\n static int reg_used_in_mem_p PARAMS ((int, rtx));\n static int addr_generation_dependency_p PARAMS ((rtx, rtx));\n static void s390_split_branches PARAMS ((void));\n+static void find_constant_pool_ref PARAMS ((rtx, rtx *));\n+static void replace_constant_pool_ref PARAMS ((rtx *, rtx, rtx));\n static void s390_chunkify_pool PARAMS ((void));\n static int save_fprs_p PARAMS ((void));\n static int find_unused_clobbered_reg PARAMS ((void));\n@@ -635,6 +637,18 @@ const0_operand (op, mode)\n   return op == CONST0_RTX (mode);\n }\n \n+/* Return true if OP is constant.\n+   OP is the current operation.\n+   MODE is the current operation mode.  */\n+\n+int\n+consttable_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  return CONSTANT_P (op);\n+}\n+\n /* Return true if the mode of operand OP matches MODE.\n    If MODE is set to VOIDmode, set it to the mode of OP.  */ \n \n@@ -1395,6 +1409,26 @@ s390_decompose_address (addr, out, strict)\n \t  pointer = TRUE;\n         }\n \n+      /* Accept chunkfied literal pool symbol references.  */\n+      else if (GET_CODE (disp) == CONST\n+               && GET_CODE (XEXP (disp, 0)) == MINUS\n+               && GET_CODE (XEXP (XEXP (disp, 0), 0)) == LABEL_REF\n+               && GET_CODE (XEXP (XEXP (disp, 0), 1)) == LABEL_REF)\n+        {\n+\t  pointer = TRUE;\n+        }\n+ \n+      /* Likewise if a constant offset is present.  */\n+      else if (GET_CODE (disp) == CONST\n+               && GET_CODE (XEXP (disp, 0)) == PLUS\n+               && GET_CODE (XEXP (XEXP (disp, 0), 1)) == CONST_INT\n+               && GET_CODE (XEXP (XEXP (disp, 0), 0)) == MINUS\n+               && GET_CODE (XEXP (XEXP (XEXP (disp, 0), 0), 0)) == LABEL_REF\n+               && GET_CODE (XEXP (XEXP (XEXP (disp, 0), 0), 1)) == LABEL_REF)\n+        {\n+\t  pointer = TRUE;\n+        }\n+\n       /* We can convert literal pool addresses to \n          displacements by basing them off the base register.  */\n       else\n@@ -1944,18 +1978,10 @@ s390_output_symbolic_const (file, x)\n       break;\n \n     case CONST_INT:\n-      output_addr_const (file, x);\n-      break;\n-\n     case LABEL_REF:\n     case CODE_LABEL:\n-      output_addr_const (file, x);\n-      break;\n-\n     case SYMBOL_REF:\n       output_addr_const (file, x);\n-      if (CONSTANT_POOL_ADDRESS_P (x) && s390_pool_count != 0)\n-        fprintf (file, \"_%X\", s390_pool_count);\n       break;\n \n     case UNSPEC:\n@@ -1965,8 +1991,7 @@ s390_output_symbolic_const (file, x)\n         {\n         case 100:\n \t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n-          fprintf (file, \"-.LT%X_%X\", \n-                   s390_function_count, s390_pool_count);\n+          fprintf (file, \"-.LT%X\", s390_function_count);\n \t  break;\n \tcase 110:\n \t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n@@ -1986,8 +2011,7 @@ s390_output_symbolic_const (file, x)\n \t  break;\n \tcase 114:\n \t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n-          fprintf (file, \"@PLT-.LT%X_%X\",\n-\t           s390_function_count, s390_pool_count);\n+          fprintf (file, \"@PLT-.LT%X\", s390_function_count);\n \t  break;\n \tdefault:\n \t  output_operand_lossage (\"invalid UNSPEC as operand (2)\");\n@@ -2032,8 +2056,6 @@ print_operand_address (file, addr)\n \n     'C': print opcode suffix for branch condition.\n     'D': print opcode suffix for inverse branch condition.\n-    'Y': print current constant pool address (pc-relative).\n-    'y': print current constant pool address (absolute).\n     'O': print only the displacement of a memory reference.\n     'R': print only the base register of a memory reference.\n     'N': print the second word of a DImode operand.\n@@ -2059,14 +2081,6 @@ print_operand (file, x, code)\n       fprintf (file, s390_branch_condition_mnemonic (x, TRUE));\n       return;\n \n-    case 'Y':\n-      fprintf (file, \".LT%X_%X-.\", s390_function_count, s390_pool_count);\n-      return;\n-\n-    case 'y':\n-      fprintf (file, \".LT%X_%X\", s390_function_count, s390_pool_count);\n-      return;\n-\n     case 'O':\n       {\n         struct s390_address ad;\n@@ -2384,60 +2398,6 @@ s390_adjust_priority (insn, priority)\n }\n \n \n-/* Pool concept for Linux 390:\n-   - Function prologue saves used register \n-   - literal pool is dumped in prologue and  jump across with bras\n-   - If function has more than 4 k literals, at about every \n-     S390_CHUNK_MAX offset in the function a literal pool will be\n-     dumped\n-     - in this case, a branch from one chunk to other chunk needs\n-       a reload of base register at the code label branched to.  */\n-\n-/* Index of constant pool chunk that is currently being processed.\n-   Set to -1 before function output has started.  */\n-int s390_pool_count = -1;\n-\n-/* First insn using the constant pool chunk that is currently being\n-   processed.  */\n-rtx s390_pool_start_insn = NULL_RTX;\n-\n-/* Called from the ASM_OUTPUT_POOL_PROLOGUE macro to \n-   prepare for printing a literal pool chunk to stdio stream FILE.  \n-\n-   FNAME and FNDECL specify the name and type of the current function.\n-   SIZE is the size in bytes of the current literal pool.  */\n- \n-void \n-s390_asm_output_pool_prologue (file, fname, fndecl, size)\n-     FILE *file;\n-     const char *fname ATTRIBUTE_UNUSED;\n-     tree fndecl;\n-     int size ATTRIBUTE_UNUSED;\n-{\n-\n-  if (s390_pool_count>0) {\n-    /*\n-     * We are in an internal pool, branch over\n-     */\n-    if (TARGET_64BIT)\n-      {\n-\tfprintf (file, \"\\tlarl\\t%s,.LT%X_%X\\n\", \n-\t\t reg_names[BASE_REGISTER],\n-\t\t s390_function_count, s390_pool_count);\n-\treadonly_data_section ();\n-\tASM_OUTPUT_ALIGN (file, floor_log2 (3));\n-\tfprintf (file, \".LT%X_%X:\\t# Pool %d\\n\",\n-\t\t s390_function_count, s390_pool_count, s390_pool_count);\n-      }\n-    else\n-    fprintf (file,\"\\t.align 4\\n\\tbras\\t%s,0f\\n.LT%X_%X:\\t# Pool %d \\n\",\n-\t     reg_names[BASE_REGISTER],\n-\t     s390_function_count, s390_pool_count, s390_pool_count);\n-  }\n-  if (!TARGET_64BIT)\n-    function_section (fndecl);\n-}\n-\n /* Split all branches that exceed the maximum distance.  */\n \n static void \n@@ -2516,62 +2476,490 @@ s390_split_branches (void)\n     }\n }\n \n+\n+/* Find a literal pool symbol referenced in RTX X, and store \n+   it at REF.  Will abort if X contains references to more than \n+   one such pool symbol; multiple references to the same symbol\n+   are allowed, however. \n+\n+   The rtx pointed to by REF must be initialized to NULL_RTX \n+   by the caller before calling this routine.  */\n+\n+static void\n+find_constant_pool_ref (x, ref)\n+     rtx x;\n+     rtx *ref;\n+{\n+  int i, j;\n+  const char *fmt;\n+\n+  if (GET_CODE (x) == SYMBOL_REF\n+      && CONSTANT_POOL_ADDRESS_P (x))\n+    {\n+      if (*ref == NULL_RTX)\n+        *ref = x;\n+      else if (*ref != x)\n+        abort();\n+    }\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (x));\n+  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+        {\n+          find_constant_pool_ref (XEXP (x, i), ref);\n+        }\n+      else if (fmt[i] == 'E')\n+        {\n+          for (j = 0; j < XVECLEN (x, i); j++)\n+            find_constant_pool_ref (XVECEXP (x, i, j), ref);\n+        }\n+    }\n+}\n+\n+/* Replace every reference to the literal pool symbol REF\n+   in X by the address ADDR.  Fix up MEMs as required.  */\n+\n+static void\n+replace_constant_pool_ref (x, ref, addr)\n+     rtx *x;\n+     rtx ref;\n+     rtx addr;\n+{\n+  int i, j;\n+  const char *fmt;\n+\n+  if (*x == ref)\n+    abort ();\n+\n+  /* Literal pool references can only occur inside a MEM ...  */\n+  if (GET_CODE (*x) == MEM)\n+    {\n+      rtx memref = XEXP (*x, 0);\n+\n+      if (memref == ref)\n+\t{\n+\t  *x = replace_equiv_address (*x, addr);\n+\t  return;\n+\t}\n+\n+      if (GET_CODE (memref) == CONST\n+\t  && GET_CODE (XEXP (memref, 0)) == PLUS\n+\t  && GET_CODE (XEXP (XEXP (memref, 0), 1)) == CONST_INT\n+\t  && XEXP (XEXP (memref, 0), 0) == ref)\n+\t{\n+\t  HOST_WIDE_INT off = INTVAL (XEXP (XEXP (memref, 0), 1));\n+\t  *x = replace_equiv_address (*x, plus_constant (addr, off));\n+\t  return;\n+\t}\n+    }\n+\n+  /* ... or a load-address type pattern.  */\n+  if (GET_CODE (*x) == SET)\n+    {\n+      rtx addrref = SET_SRC (*x);\n+\n+      if (addrref == ref)\n+\t{\n+\t  SET_SRC (*x) = addr;\n+\t  return;\n+\t}\n+\n+      if (GET_CODE (addrref) == CONST\n+\t  && GET_CODE (XEXP (addrref, 0)) == PLUS\n+\t  && GET_CODE (XEXP (XEXP (addrref, 0), 1)) == CONST_INT\n+\t  && XEXP (XEXP (addrref, 0), 0) == ref)\n+\t{\n+\t  HOST_WIDE_INT off = INTVAL (XEXP (XEXP (addrref, 0), 1));\n+\t  SET_SRC (*x) = plus_constant (addr, off);\n+\t  return;\n+\t}\n+    }\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (*x));\n+  for (i = GET_RTX_LENGTH (GET_CODE (*x)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+        {\n+          replace_constant_pool_ref (&XEXP (*x, i), ref, addr);\n+        }\n+      else if (fmt[i] == 'E')\n+        {\n+          for (j = 0; j < XVECLEN (*x, i); j++)\n+            replace_constant_pool_ref (&XVECEXP (*x, i, j), ref, addr);\n+        }\n+    }\n+}\n+\n+/* We keep a list of constants we which we have to add to internal\n+   constant tables in the middle of large functions.  */\n+\n+#define NR_C_MODES 6\n+enum machine_mode constant_modes[NR_C_MODES] = \n+{\n+  DFmode, DImode,\n+  SFmode, SImode,\n+  HImode,\n+  QImode\n+};\n+\n+rtx (*gen_consttable[NR_C_MODES])(rtx) =\n+{\n+  gen_consttable_df, gen_consttable_di,\n+  gen_consttable_sf, gen_consttable_si,\n+  gen_consttable_hi,\n+  gen_consttable_qi\n+};\n+\n+struct constant\n+{\n+  struct constant *next;\n+  rtx value;\n+  rtx label;\n+};\n+\n+struct constant_pool\n+{\n+  struct constant_pool *next;\n+  rtx first_insn;\n+  rtx last_insn;\n+\n+  struct constant *constants[NR_C_MODES];\n+  rtx label;\n+  int size;\n+};\n+\n+static struct constant_pool *s390_start_pool PARAMS ((struct constant_pool **, rtx));\n+static void s390_end_pool PARAMS ((struct constant_pool *, rtx));\n+static struct constant_pool *s390_find_pool PARAMS ((struct constant_pool *, rtx));\n+static rtx s390_add_pool PARAMS ((struct constant_pool *, rtx, enum machine_mode));\n+static rtx s390_dump_pool PARAMS ((struct constant_pool *));\n+static void s390_free_pool PARAMS ((struct constant_pool *));\n+\n+/* Create new constant pool covering instructions starting at INSN\n+   and chain it to the end of POOL_LIST.  */\n+\n+static struct constant_pool *\n+s390_start_pool (pool_list, insn)\n+     struct constant_pool **pool_list;\n+     rtx insn;\n+{\n+  struct constant_pool *pool, **prev;\n+  int i;\n+\n+  pool = (struct constant_pool *) xmalloc (sizeof *pool);\n+  pool->next = NULL;\n+  for (i = 0; i < NR_C_MODES; i++)\n+    pool->constants[i] = NULL;\n+\n+  pool->label = gen_label_rtx ();\n+  pool->first_insn = insn;\n+  pool->last_insn = NULL_RTX;\n+  pool->size = 0;\n+ \n+  for (prev = pool_list; *prev; prev = &(*prev)->next)\n+    ;\n+  *prev = pool;\n+\n+  return pool;\n+}\n+\n+/* End range of instructions covered by POOL at INSN.  */\n+\n+static void\n+s390_end_pool (pool, insn)\n+     struct constant_pool *pool;\n+     rtx insn;\n+{\n+  pool->last_insn = insn;\n+}\n+\n+/* Return pool out of POOL_LIST that covers INSN.  */\n+\n+static struct constant_pool *\n+s390_find_pool (pool_list, insn)\n+     struct constant_pool *pool_list;\n+     rtx insn;\n+{\n+  int addr = INSN_ADDRESSES (INSN_UID (insn));\n+  struct constant_pool *pool;\n+\n+  if (addr == -1)\n+    return NULL;\n+\n+  for (pool = pool_list; pool; pool = pool->next)\n+    if (INSN_ADDRESSES (INSN_UID (pool->first_insn)) <= addr\n+        && (pool->last_insn == NULL_RTX\n+            || INSN_ADDRESSES (INSN_UID (pool->last_insn)) > addr))\n+      break;\n+\n+  return pool;\n+}\n+\n+/* Add constant VAL of mode MODE to the constant pool POOL.\n+   Return an RTX describing the distance from the start of\n+   the pool to the location of the new constant.  */\n+\n+static rtx\n+s390_add_pool (pool, val, mode)\n+     struct constant_pool *pool;\n+     rtx val;\n+     enum machine_mode mode;\n+{\n+  struct constant *c;\n+  rtx offset;\n+  int i;\n+\n+  for (i = 0; i < NR_C_MODES; i++)\n+    if (constant_modes[i] == mode)\n+      break;\n+  if (i == NR_C_MODES)\n+    abort ();\n+\n+  for (c = pool->constants[i]; c != NULL; c = c->next)\n+    if (rtx_equal_p (val, c->value))\n+      break;\n+\n+  if (c == NULL)\n+    {\n+      c = (struct constant *) xmalloc (sizeof *c);\n+      c->value = val;\n+      c->label = gen_label_rtx ();\n+      c->next = pool->constants[i];\n+      pool->constants[i] = c;\n+      pool->size += GET_MODE_SIZE (mode);\n+    }\n+\n+  offset = gen_rtx_MINUS (Pmode, gen_rtx_LABEL_REF (Pmode, c->label), \n+\t\t\t\t gen_rtx_LABEL_REF (Pmode, pool->label));\n+  offset = gen_rtx_CONST (Pmode, offset);\n+  return offset;\n+}\n+\n+/* Dump out the constants in POOL.  */\n+\n+static rtx\n+s390_dump_pool (pool)\n+     struct constant_pool *pool;\n+{\n+  struct constant *c;\n+  rtx insn;\n+  int i;\n+\n+  /* Select location to put literal pool.  */\n+  if (TARGET_64BIT)\n+    insn = get_last_insn ();\n+  else\n+    insn = pool->last_insn? pool->last_insn : get_last_insn ();\n+\n+  /* Pool start insn switches to proper section \n+     and guarantees necessary alignment.  */\n+  if (TARGET_64BIT)\n+    insn = emit_insn_after (gen_pool_start_64 (), insn);\n+  else\n+    insn = emit_insn_after (gen_pool_start_31 (), insn);\n+  INSN_ADDRESSES_NEW (insn, -1);\n+\n+  insn = emit_label_after (pool->label, insn);\n+  INSN_ADDRESSES_NEW (insn, -1);\n+\n+  /* Dump constants in descending alignment requirement order,\n+     ensuring proper alignment for every constant.  */\n+  for (i = 0; i < NR_C_MODES; i++)\n+    for (c = pool->constants[i]; c; c = c->next)\n+      {\n+\tinsn = emit_label_after (c->label, insn);\n+\tINSN_ADDRESSES_NEW (insn, -1);\n+\tinsn = emit_insn_after (gen_consttable[i] (c->value), insn);\n+\tINSN_ADDRESSES_NEW (insn, -1);\n+      }\n+\n+  /* Pool end insn switches back to previous section \n+     and guarantees necessary alignment.  */\n+  if (TARGET_64BIT)\n+    insn = emit_insn_after (gen_pool_end_64 (), insn);\n+  else\n+    insn = emit_insn_after (gen_pool_end_31 (), insn);\n+  INSN_ADDRESSES_NEW (insn, -1);\n+\n+  insn = emit_barrier_after (insn);\n+  INSN_ADDRESSES_NEW (insn, -1);\n+\n+  return insn;\n+}\n+\n+/* Free all memory used by POOL.  */\n+\n+static void\n+s390_free_pool (pool)\n+     struct constant_pool *pool;\n+{\n+  int i;\n+\n+  for (i = 0; i < NR_C_MODES; i++)\n+    {\n+      struct constant *c = pool->constants[i];\n+      while (c != NULL)\n+\t{\n+\t  struct constant *next = c->next;\n+\t  free (c);\n+\t  c = next;\n+\t}\n+    }\n+\n+  free (pool);\n+} \n+\n+/* Used in s390.md for branch length calculation.  */\n+int s390_pool_overflow = 0;\n+\n /* Chunkify the literal pool if required.  */\n \n+#define S390_POOL_CHUNK_MIN\t0xc00\n+#define S390_POOL_CHUNK_MAX\t0xe00\n+\n static void \n s390_chunkify_pool (void)\n {\n-  int *ltorg_uids, max_ltorg, chunk, last_addr, next_addr;\n+  rtx base_reg = gen_rtx_REG (Pmode, \n+\t\t\t      TARGET_64BIT? BASE_REGISTER : RETURN_REGNUM);\n+\n+  struct constant_pool *curr_pool = NULL, *pool_list = NULL;\n+  int extra_size = 0;\n+  bitmap far_labels;\n   rtx insn;\n \n   /* Do we need to chunkify the literal pool?  */\n \n-  if (get_pool_size () <= S390_POOL_MAX)\n+  if (get_pool_size () < S390_POOL_CHUNK_MAX)\n     return;\n \n-  /* Find all insns where a literal pool chunk must be inserted.  */\n+  /* Scan all insns and move literals to pool chunks.\n+     Replace all occurrances of literal pool references\n+     by explicit references to pool chunk entries.  */\n \n-  ltorg_uids = alloca (insn_current_address / 1024 + 1024);\n-  max_ltorg = 0;\n-\n-  last_addr = 0;\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n-      if (INSN_ADDRESSES (INSN_UID (insn)) - last_addr < S390_CHUNK_MAX)\n+      if (GET_CODE (insn) == INSN)\n+\t{\n+\t  rtx addr, pool_ref = NULL_RTX;\n+\t  find_constant_pool_ref (PATTERN (insn), &pool_ref);\n+\t  if (pool_ref)\n+\t    {\n+\t      if (!curr_pool)\n+\t\tcurr_pool = s390_start_pool (&pool_list, insn);\n+\n+\t      addr = s390_add_pool (curr_pool, get_pool_constant (pool_ref), \n+\t\t\t\t\t       get_pool_mode (pool_ref));\n+\n+\t      addr = gen_rtx_PLUS (Pmode, base_reg, addr);\n+\t      replace_constant_pool_ref (&PATTERN (insn), pool_ref, addr);\n+\t      INSN_CODE (insn) = -1;\n+\t    }\n+\t}\n+\n+      if (!curr_pool \n+\t  || INSN_ADDRESSES_SIZE () <= (size_t) INSN_UID (insn)\n+          || INSN_ADDRESSES (INSN_UID (insn)) == -1)\n \tcontinue;\n-      if (INSN_ADDRESSES (INSN_UID (insn)) - last_addr > S390_CHUNK_OV)\n-\tabort ();\n \n-      if (GET_CODE (insn) == CODE_LABEL\n-\t  && !(GET_CODE (NEXT_INSN (insn)) == JUMP_INSN\n-\t       && (GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_VEC\n-\t\t   || GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_DIFF_VEC)))\n+      if (TARGET_64BIT)\n \t{\n-\t  ltorg_uids[max_ltorg++] = INSN_UID (prev_real_insn (insn));\n-\t  last_addr = INSN_ADDRESSES (ltorg_uids[max_ltorg-1]);\n-\t  continue;\n-\t}\n+\t  if (curr_pool->size < S390_POOL_CHUNK_MAX)\n+\t    continue;\n \n-      if (GET_CODE (insn) == CALL_INSN)\n+\t  s390_end_pool (curr_pool, insn);\n+\t  curr_pool = NULL;\n+\t}\n+      else\n \t{\n-\t  ltorg_uids[max_ltorg++] = INSN_UID (insn);\n-\t  last_addr = INSN_ADDRESSES (ltorg_uids[max_ltorg-1]);\n-\t  continue;\n+          int chunk_size = INSN_ADDRESSES (INSN_UID (insn))\n+\t\t \t   - INSN_ADDRESSES (INSN_UID (curr_pool->first_insn))\n+\t\t\t + extra_size;\n+\n+\t  /* We will later have to insert base register reload insns.\n+\t     Those will have an effect on code size, which we need to\n+\t     consider here.  This calculation makes rather pessimistic\n+\t     worst-case assumptions.  */\n+\t  if (GET_CODE (insn) == CODE_LABEL\n+\t      || GET_CODE (insn) == JUMP_INSN)\n+\t    extra_size += 6;\n+\t  else if (GET_CODE (insn) == CALL_INSN)\n+\t    extra_size += 4;\n+\n+\t  if (chunk_size < S390_POOL_CHUNK_MIN\n+\t      && curr_pool->size < S390_POOL_CHUNK_MIN)\n+\t    continue;\n+\n+\t  /* Pool chunks can only be inserted after BARRIERs ...  */\n+\t  if (GET_CODE (insn) == BARRIER)\n+\t    {\n+\t      s390_end_pool (curr_pool, insn);\n+\t      curr_pool = NULL;\n+\t      extra_size = 0;\n+\t    }\n+\n+\t  /* ... so if we don't find one in time, create one.  */\n+          else if ((chunk_size > S390_POOL_CHUNK_MAX\n+\t           || curr_pool->size > S390_POOL_CHUNK_MAX)\n+\t          && (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN))\n+\t    {\n+\t      int addr = INSN_ADDRESSES (INSN_UID (insn));\n+              rtx label, jump, barrier;\n+\n+ \t      label = gen_label_rtx ();\n+\t      jump = emit_jump_insn_after (gen_jump (label), insn);\n+\t      barrier = emit_barrier_after (jump);\n+\t      insn = emit_label_after (label, barrier);\n+\t      JUMP_LABEL (jump) = label;\n+\t      LABEL_NUSES (label) = 1;\n+\n+\t      INSN_ADDRESSES_NEW (jump, addr+1);\n+\t      INSN_ADDRESSES_NEW (barrier, addr+1);\n+\t      INSN_ADDRESSES_NEW (insn, -1);\n+\n+\t      s390_end_pool (curr_pool, barrier);\n+\t      curr_pool = NULL;\n+\t      extra_size = 0;\n+\t    }\n \t}\n     }\n \n-  ltorg_uids[max_ltorg] = -1;\n+  /* Dump out all literal pools.  */\n+\n+  for (curr_pool = pool_list; curr_pool; curr_pool = curr_pool->next)\n+    s390_dump_pool (curr_pool);\n \n-  /* Find and mark all labels that are branched into \n+\n+  /* Find all labels that are branched into \n      from an insn belonging to a different chunk.  */\n \n-  chunk = last_addr = 0;\n-  next_addr = ltorg_uids[chunk] == -1 ? insn_current_address + 1\n-\t      : INSN_ADDRESSES (ltorg_uids[chunk]);\n+  far_labels = BITMAP_XMALLOC ();\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) == JUMP_INSN) \n+      /* Labels marked with LABEL_PRESERVE_P can be target\n+\t of non-local jumps, so we have to mark them.\n+\t The same holds for named labels.\n+\n+\t Don't do that, however, if it is the label before\n+\t a jump table.  */\n+\n+      if (GET_CODE (insn) == CODE_LABEL \n+\t  && (LABEL_PRESERVE_P (insn) || LABEL_NAME (insn)))\n+\t{\n+\t  rtx vec_insn = next_real_insn (insn);\n+\t  rtx vec_pat = vec_insn && GET_CODE (vec_insn) == JUMP_INSN ? \n+\t\t\tPATTERN (vec_insn) : NULL_RTX;\n+\t  if (!vec_pat\n+\t      || !(GET_CODE (vec_pat) == ADDR_VEC\n+\t\t   || GET_CODE (vec_pat) == ADDR_DIFF_VEC))\n+\t    bitmap_set_bit (far_labels, CODE_LABEL_NUMBER (insn));\n+\t}\n+\n+      /* If we have a direct jump (conditional or unconditional)\n+\t or a casesi jump, check all potential targets.  */\n+      else if (GET_CODE (insn) == JUMP_INSN) \n \t{\n           rtx pat = PATTERN (insn);\n           if (GET_CODE (pat) == SET) \n@@ -2592,112 +2980,140 @@ s390_chunkify_pool (void)\n \n \t      if (label)\n \t\t{\n-\t          if (INSN_ADDRESSES (INSN_UID (label)) <= last_addr\n-\t              || INSN_ADDRESSES (INSN_UID (label)) > next_addr)\n-\t\t    SYMBOL_REF_USED (label) = 1;\n+\t          if (s390_find_pool (pool_list, label) \n+\t\t      != s390_find_pool (pool_list, insn))\n+\t\t    bitmap_set_bit (far_labels, CODE_LABEL_NUMBER (label));\n \t\t}\n             } \n-          else if (GET_CODE (pat) == ADDR_VEC\n-\t           || GET_CODE (pat) == ADDR_DIFF_VEC)\n-            {\n-\t      int i, diff_p = GET_CODE (pat) == ADDR_DIFF_VEC;\n-\n-              for (i = 0; i < XVECLEN (pat, diff_p); i++) \n-\t        {\n-\t          rtx label = XEXP (XVECEXP (pat, diff_p, i), 0);\n+\t  else if (GET_CODE (pat) == PARALLEL\n+\t\t   && XVECLEN (pat, 0) == 2\n+\t\t   && GET_CODE (XVECEXP (pat, 0, 0)) == SET\n+\t\t   && GET_CODE (XVECEXP (pat, 0, 1)) == USE\n+\t\t   && GET_CODE (XEXP (XVECEXP (pat, 0, 1), 0)) == LABEL_REF)\n+\t    {\n+\t      /* Find the jump table used by this casesi jump.  */\n+\t      rtx vec_label = XEXP (XEXP (XVECEXP (pat, 0, 1), 0), 0);\n+\t      rtx vec_insn = next_real_insn (vec_label);\n+\t      rtx vec_pat = vec_insn && GET_CODE (vec_insn) == JUMP_INSN ? \n+\t\t\t    PATTERN (vec_insn) : NULL_RTX;\n+\t      if (vec_pat\n+\t\t  && (GET_CODE (vec_pat) == ADDR_VEC\n+\t\t      || GET_CODE (vec_pat) == ADDR_DIFF_VEC))\n+\t\t{\n+\t\t  int i, diff_p = GET_CODE (vec_pat) == ADDR_DIFF_VEC;\n \n-\t          if (INSN_ADDRESSES (INSN_UID (label)) <= last_addr\n-\t              || INSN_ADDRESSES (INSN_UID (label)) > next_addr)\n-\t\t    SYMBOL_REF_USED (label) = 1;\n-\t        }\n-            }\n-        }\n+\t\t  for (i = 0; i < XVECLEN (vec_pat, diff_p); i++)\n+\t\t    {\n+\t\t      rtx label = XEXP (XVECEXP (vec_pat, diff_p, i), 0);\n \n-      if (INSN_UID (insn) == ltorg_uids[chunk]) \n-        {\n-\t  last_addr = INSN_ADDRESSES (ltorg_uids[chunk++]);\n-\t  next_addr = ltorg_uids[chunk] == -1 ? insn_current_address + 1\n-\t\t      : INSN_ADDRESSES (ltorg_uids[chunk]);\n+\t\t      if (s390_find_pool (pool_list, label) \n+\t\t\t  != s390_find_pool (pool_list, insn))\n+\t\t\tbitmap_set_bit (far_labels, CODE_LABEL_NUMBER (label));\n+\t\t    }\n+\t\t}\n+\t    }\n         }\n     }\n \n-  /* Insert literal pools and base register reload insns.  */\n+  /* Insert base register reload insns before every pool.  */\n+\n+  for (curr_pool = pool_list; curr_pool; curr_pool = curr_pool->next)\n+    if (TARGET_64BIT)\n+      {\n+\trtx pool_ref = gen_rtx_LABEL_REF (Pmode, curr_pool->label);\n+\trtx new_insn = gen_rtx_SET (Pmode, base_reg, pool_ref);\n+\trtx insn = curr_pool->first_insn;\n+        INSN_ADDRESSES_NEW (emit_insn_before (new_insn, insn), -1);\n+      }\n+    else\n+      {\n+\trtx new_insn = gen_reload_base (base_reg, curr_pool->label);\n+\trtx insn = curr_pool->first_insn;\n+        INSN_ADDRESSES_NEW (emit_insn_before (new_insn, insn), -1);\n+      }\n+\n+  /* Insert base register reload insns at every far label.  */\n \n-  chunk = 0;\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    {\n-      if (INSN_UID (insn) == ltorg_uids[chunk]) \n-        {\n-\t  rtx new_insn = gen_ltorg (GEN_INT (chunk++));\n-\t  INSN_ADDRESSES_NEW (emit_insn_after (new_insn, insn), -1);\n-        }\n+    if (GET_CODE (insn) == CODE_LABEL \n+        && bitmap_bit_p (far_labels, CODE_LABEL_NUMBER (insn)))\n+      {\n+\tstruct constant_pool *pool = s390_find_pool (pool_list, insn);\n+\tif (pool)\n+\t  {\n+\t    if (TARGET_64BIT)\n+\t      {\n+\t\trtx pool_ref = gen_rtx_LABEL_REF (Pmode, pool->label);\n+\t\trtx new_insn = gen_rtx_SET (Pmode, base_reg, pool_ref);\n+\t        INSN_ADDRESSES_NEW (emit_insn_after (new_insn, insn), -1);\n+\t      }\n+\t    else\n+\t      {\n+\t\trtx new_insn = gen_reload_base (base_reg, pool->label);\n+\t        INSN_ADDRESSES_NEW (emit_insn_after (new_insn, insn), -1);\n+ \t      }\n+\t  }\n+      }\n+\n+  /* Insert base register reload insns after every call if necessary.  */\n+\n+  if (REGNO (base_reg) == RETURN_REGNUM)\n+    for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+      if (GET_CODE (insn) == CALL_INSN)\n+\t {\n+\t   struct constant_pool *pool = s390_find_pool (pool_list, insn);\n+\t   if (pool)\n+\t     {\n+\t       rtx new_insn = gen_reload_base2 (base_reg, pool->label);\n+\t       INSN_ADDRESSES_NEW (emit_insn_after (new_insn, insn), -1);\n+\t     }\n+\t  }\n \n-      if (GET_CODE (insn) == CODE_LABEL && SYMBOL_REF_USED (insn))\n-\t{\n-\t  rtx new_insn = gen_reload_base (insn);\n-\t  INSN_ADDRESSES_NEW (emit_insn_after (new_insn, insn), -1);\n-\t}\n-    }\n \n   /* Recompute insn addresses.  */\n \n+  s390_pool_overflow = 1;\n   init_insn_lengths ();\n   shorten_branches (get_insns ());\n-}\n+  s390_pool_overflow = 0;\n \n-/* Return true if INSN is a 'ltorg' insn.  */\n+  /* Insert base register reload insns after far branches.  */\n \n-int \n-s390_stop_dump_lit_p (insn)\n-    rtx insn;\n-{\n-  rtx body=PATTERN (insn);\n-  if (GET_CODE (body) == PARALLEL\n-      && GET_CODE (XVECEXP (body, 0, 0)) == SET\n-      && GET_CODE (XVECEXP (body, 0, 1)) == USE\n-      && GET_CODE (XEXP ((XVECEXP (body, 0, 1)),0)) == CONST_INT\n-      && GET_CODE (SET_DEST (XVECEXP (body, 0, 0))) == REG\n-      && REGNO (SET_DEST (XVECEXP (body, 0, 0))) == BASE_REGISTER\n-      && SET_SRC (XVECEXP (body, 0, 0)) == pc_rtx) {\n-    return 1;\n-  }\n-  else\n-    return 0;   \n-}\n-\n-/* Output literal pool chunk to be used for insns\n-   between insn ACT_INSN and the insn with UID STOP.  */\n-\n-void\n-s390_dump_literal_pool (act_insn, stop)\n-     rtx act_insn;\n-     rtx stop;\n-{\n-  s390_pool_start_insn = act_insn;\n-  s390_pool_count++;\n-  output_constant_pool (current_function_name, current_function_decl);\n-  function_section (current_function_decl);\n-}\n+  if (!TARGET_64BIT)\n+    for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+      if (GET_CODE (insn) == JUMP_INSN\n+\t  && GET_CODE (PATTERN (insn)) == SET\n+\t  && get_attr_length (insn) >= 12)\n+\t{\n+\t  struct constant_pool *pool = s390_find_pool (pool_list, insn);\n+\t  if (pool)\n+\t    {\n+\t      rtx new_insn = gen_reload_base (base_reg, pool->label);\n+\t      INSN_ADDRESSES_NEW (emit_insn_after (new_insn, insn), -1);\n+\t    }\n+\t}\n \n-/* Number of elements of current constant pool.  */\n-int s390_nr_constants;\n \n-/* Return true if floating point registers need to be saved.  */\n+  /* Free all memory.  */\n \n-static int \n-save_fprs_p ()\n-{\n-  int i;\n-  if (!TARGET_64BIT)\n-    return 0;\n-  for (i=24; i<=31; i++) \n+  while (pool_list)\n     {\n-      if (regs_ever_live[i] == 1)\n-\treturn 1;\n+      struct constant_pool *next = pool_list->next;\n+      s390_free_pool (pool_list);\n+      pool_list = next;\n     }\n-  return 0;\n+\n+  BITMAP_XFREE (far_labels);\n }\n \n+\n+/* Index of constant pool chunk that is currently being processed.\n+   Set to -1 before function output has started.  */\n+int s390_pool_count = -1;\n+\n+/* Number of elements of current constant pool.  */\n+int s390_nr_constants;\n+\n /* Output main constant pool to stdio stream FILE.  */ \n \n void\n@@ -2707,26 +3123,46 @@ s390_output_constant_pool (file)\n   /* Output constant pool.  */\n   if (s390_nr_constants)\n     {\n-      s390_pool_count = 0;\n       if (TARGET_64BIT)\n \t{\n-\t  fprintf (file, \"\\tlarl\\t%s,.LT%X_%X\\n\", reg_names[BASE_REGISTER],\n-\t\t   s390_function_count, s390_pool_count);\n+\t  fprintf (file, \"\\tlarl\\t%s,.LT%X\\n\", reg_names[BASE_REGISTER],\n+\t\t   s390_function_count);\n \t  readonly_data_section ();\n-\t  ASM_OUTPUT_ALIGN (file, floor_log2 (3));\n+\t  ASM_OUTPUT_ALIGN (file, 3);\n \t}\n       else\n \t{\n-\t  fprintf (file, \"\\tbras\\t%s,.LTN%X_%X\\n\", reg_names[BASE_REGISTER],\n-\t\t   s390_function_count, s390_pool_count);\n+\t  fprintf (file, \"\\tbras\\t%s,.LTN%X\\n\", reg_names[BASE_REGISTER],\n+\t\t   s390_function_count);\n \t}\n-      fprintf (file, \".LT%X_%X:\\n\", s390_function_count, s390_pool_count);\n+      fprintf (file, \".LT%X:\\n\", s390_function_count);\n+\n+      s390_pool_count = 0;\n       output_constant_pool (current_function_name, current_function_decl);\n-      fprintf (file, \".LTN%X_%X:\\n\", s390_function_count,\n-\t       s390_pool_count);\n+      s390_pool_count = -1;\n+\n       if (TARGET_64BIT)\n \tfunction_section (current_function_decl);\n+      else\n+        fprintf (file, \".LTN%X:\\n\", s390_function_count);\n+    }\n+}\n+\n+\n+/* Return true if floating point registers need to be saved.  */\n+\n+static int \n+save_fprs_p ()\n+{\n+  int i;\n+  if (!TARGET_64BIT)\n+    return 0;\n+  for (i=24; i<=31; i++) \n+    {\n+      if (regs_ever_live[i] == 1)\n+\treturn 1;\n     }\n+  return 0;\n }\n \n /* Find first call clobbered register unsused in a function.\n@@ -2774,6 +3210,12 @@ s390_frame_info (frame)\n   if (frame->frame_size > 0)\n     regs_ever_live[STACK_POINTER_REGNUM] = 1;\n \n+  /* If the literal pool might overflow, the return register might\n+     be used as temp literal pointer.  */\n+\n+  if (!TARGET_64BIT && get_pool_size () >= S390_POOL_CHUNK_MAX / 2)\n+    regs_ever_live[RETURN_REGNUM] = 1;\n+\n   /* If there is (possibly) any pool entry, we need to \n      load base register.  */\n \n@@ -2895,8 +3337,6 @@ s390_function_epilogue (file, lsize)\n      HOST_WIDE_INT lsize ATTRIBUTE_UNUSED;\n {\n   current_function_uses_pic_offset_table = 0;\n-  s390_pool_start_insn = NULL_RTX;\n-  s390_pool_count = -1;\n   s390_function_count++;\n }\n \n@@ -2917,7 +3357,8 @@ s390_emit_prologue ()\n   /* Choose best register to use for temp use within prologue.  */\n   \n   if (frame.return_reg_saved_p\n-      && !has_hard_reg_initial_val (Pmode, RETURN_REGNUM))\n+      && !has_hard_reg_initial_val (Pmode, RETURN_REGNUM)\n+      && get_pool_size () < S390_POOL_CHUNK_MAX / 2)\n     temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n   else\n     temp_reg = gen_rtx_REG (Pmode, 1);"}, {"sha": "2e342ead45f12e9e911599d78a184f2f0238e883", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 4, "deletions": 52, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2ccb744c6bab887d1749cdbe19cb7e4ccc54446/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2ccb744c6bab887d1749cdbe19cb7e4ccc54446/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=b2ccb744c6bab887d1749cdbe19cb7e4ccc54446", "patch": "@@ -1259,6 +1259,8 @@ extern struct rtx_def *s390_compare_op0, *s390_compare_op1;\n   {\"load_multiple_operation\", {PARALLEL}},\t\t\t        \\\n   {\"store_multiple_operation\", {PARALLEL}},\t\t\t        \\\n   {\"const0_operand\",  { CONST_INT, CONST_DOUBLE }},\t\t\t\\\n+  {\"consttable_operand\", { SYMBOL_REF, LABEL_REF, CONST, \t\t\\\n+\t\t\t   CONST_INT, CONST_DOUBLE }},\t\t\t\\\n   {\"s390_plus_operand\", { PLUS }},\n \n \n@@ -1277,20 +1279,12 @@ extern struct rtx_def *s390_compare_op0, *s390_compare_op1;\n /* Constant Pool for all symbols operands which are changed with\n    force_const_mem during insn generation (expand_insn).  */\n \n-extern struct rtx_def *s390_pool_start_insn;\n extern int s390_pool_count;\n extern int s390_nr_constants;\n-\n-/* Function is splitted in chunk, if literal pool could overflow\n-   Value need to be lowered, if problems with displacement overflow.  */\n-\n-#define S390_CHUNK_MAX 0xe00\n-#define S390_CHUNK_OV 0x1000\n-#define S390_POOL_MAX 0xe00\n+extern int s390_pool_overflow;\n \n #define ASM_OUTPUT_POOL_PROLOGUE(FILE, FUNNAME, fndecl, size)  \t        \\\n {\t\t\t\t\t\t\t\t       \t\\\n-  register rtx insn;\t\t\t\t\t\t       \t\\\n   struct pool_constant *pool;\t\t\t\t\t       \t\\\n \t\t\t\t\t\t\t\t        \\\n     if (s390_pool_count == -1)                                        \t\\\n@@ -1300,53 +1294,11 @@ extern int s390_nr_constants;\n \t if (pool->mark) s390_nr_constants++;\t\t                \\\n        return;                                      \t                \\\n      }                                                                  \\\n-    if (first_pool == 0) {                                              \\\n-      s390_asm_output_pool_prologue (FILE, FUNNAME, fndecl, size);    \t\\\n-      return;\t\t\t\t\t\t\t      \t\\\n-    }\t\t\t\t\t\t\t\t       \t\\\n-    for (pool = first_pool; pool; pool = pool->next)\t\t       \t\\\n-      pool->mark = 0;\t\t\t\t\t\t       \t\\\n-  \t\t\t\t\t\t\t\t       \t\\\n-    insn = s390_pool_start_insn;\t\t\t\t       \t\\\n-  \t\t\t\t\t\t\t\t       \t\\\n-    if (insn==NULL_RTX)\t \t\t\t\t\t       \t\\\n-      insn = get_insns ();\t\t \t\t                \\\n-    else\t\t       \t\t\t                        \\\n-      insn = NEXT_INSN (insn);\t\t                                \\\n-    for (; insn; insn = NEXT_INSN (insn)) {    \t\t                \\\n-      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i') {\t\t       \t\\\n-        if (s390_stop_dump_lit_p (insn)) { \t       \t\t       \t\\\n-\t  mark_constants (PATTERN (insn));\t\t\t       \t\\\n-\t  break;\t\t\t\t\t\t       \t\\\n-        } else\t\t\t\t\t\t\t       \t\\\n-\t  mark_constants (PATTERN (insn));\t\t\t       \t\\\n-      }\t\t\t\t\t\t\t\t       \t\\\n-    }\t\t\t\t\t\t\t\t       \t\\\n-\t\t\t\t\t\t\t\t       \t\\\n-    /* Mark entries referenced by other entries */\t\t\t\\\n-    for (pool = first_pool; pool; pool = pool->next)\t\t       \t\\\n-      if (pool->mark)\t\t\t\t\t\t\t\\\n-        mark_constants (pool->constant);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t       \t\\\n-    s390_asm_output_pool_prologue (FILE, FUNNAME, fndecl, size);     \t\\\n }\n \n-/* We need to return, because otherwise the pool is deleted of the \n-   constant pool after the first output.  */\n-\n-#define ASM_OUTPUT_POOL_EPILOGUE(FILE, FUNNAME, fndecl, size) return;\n-\n #define ASM_OUTPUT_SPECIAL_POOL_ENTRY(FILE, EXP, MODE, ALIGN, LABELNO, WIN) \\\n {\t\t\t\t\t\t\t\t\t    \\\n-  if ((s390_pool_count == 0) || (s390_pool_count > 0 && LABELNO >= 0))\t    \\\n-    {\t\t\t\t\t\t\t\t\t    \\\n-      fprintf (FILE, \".LC%d:\\n\", LABELNO);\t\t\t\t    \\\n-      LABELNO = ~LABELNO;\t\t\t\t\t\t    \\\n-    }\t\t\t\t\t\t\t\t\t    \\\n-  if (s390_pool_count > 0)\t\t\t\t\t\t    \\\n-    {\t\t\t\t\t\t\t\t\t    \\\n-      fprintf (FILE, \".LC%d_%X:\\n\", ~LABELNO, s390_pool_count);\t\t    \\\n-    }\t\t\t\t\t\t\t\t\t    \\\n+  fprintf (FILE, \".LC%d:\\n\", LABELNO);\t\t\t\t\t    \\\n \t\t\t\t\t\t\t\t\t    \\\n   /* Output the value of the constant itself.  */\t\t\t    \\\n   switch (GET_MODE_CLASS (MODE))\t\t\t\t\t    \\"}, {"sha": "f9a1d7b7af7aa957f5f92b9c757f8ba7058d46ae", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 123, "deletions": 17, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2ccb744c6bab887d1749cdbe19cb7e4ccc54446/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2ccb744c6bab887d1749cdbe19cb7e4ccc54446/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=b2ccb744c6bab887d1749cdbe19cb7e4ccc54446", "patch": "@@ -5676,6 +5676,9 @@\n                 (const_int 4)\n                (ne (symbol_ref \"TARGET_64BIT\") (const_int 0))\n                  (const_int 6)\n+\t       (ne (symbol_ref \"s390_pool_overflow\") (const_int 0))\n+                 (if_then_else (eq (symbol_ref \"flag_pic\") (const_int 0))\n+                               (const_int 12) (const_int 14))\n                (eq (symbol_ref \"flag_pic\") (const_int 0))\n                  (const_int 6)] (const_int 8)))])\n \n@@ -5725,6 +5728,9 @@\n                 (const_int 4)\n                (ne (symbol_ref \"TARGET_64BIT\") (const_int 0))\n                  (const_int 6)\n+\t       (ne (symbol_ref \"s390_pool_overflow\") (const_int 0))\n+                 (if_then_else (eq (symbol_ref \"flag_pic\") (const_int 0))\n+                               (const_int 12) (const_int 14))\n                (eq (symbol_ref \"flag_pic\") (const_int 0))\n                  (const_int 6)] (const_int 8)))])\n \n@@ -6384,33 +6390,133 @@\n ; Special literal pool access instruction pattern(s).\n ;\n \n-(define_insn \"reload_base\"\n-  [(parallel [(set (reg 13) (pc))\n-              (use (label_ref (match_operand 0 \"\" \"\")))])]\n+(define_insn \"consttable_qi\"\n+  [(unspec_volatile [(match_operand:QI 0 \"consttable_operand\" \"X\")] 200)]\n   \"\"\n   \"*\n {\n-  if (TARGET_64BIT)\n-    return \\\"larl\\\\t13,%y0\\\";\t\t\t\n-  else\n-    return \\\"basr\\\\t13,0\\;ahi\\\\t13,%Y0\\\";\n+  assemble_integer (operands[0], 1, BITS_PER_UNIT, 1);\n+  return \\\"\\\";\n }\"\n-  [(set_attr \"op_type\" \"NN\")\n-   (set_attr \"type\"    \"la\")\n-   (set_attr \"length\"  \"8\")])\n+  [(set_attr \"op_type\"  \"NN\")\n+   (set_attr \"length\"   \"1\")])\n+\n+(define_insn \"consttable_hi\"\n+  [(unspec_volatile [(match_operand:HI 0 \"consttable_operand\" \"X\")] 201)]\n+  \"\"\n+  \"*\n+{\n+  assemble_integer (operands[0], 2, 2*BITS_PER_UNIT, 1);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"op_type\"  \"NN\")\n+   (set_attr \"length\"   \"2\")])\n+\n+(define_insn \"consttable_si\"\n+  [(unspec_volatile [(match_operand:SI 0 \"consttable_operand\" \"X\")] 202)]\n+  \"\"\n+  \"*\n+{\n+  if (!TARGET_64BIT && flag_pic && SYMBOLIC_CONST (operands[0]))\n+    return \\\".long\\\\t%0\\\";\n \n-(define_insn \"ltorg\"\n-  [(parallel [(set (reg 13) (pc))\n-              (use (match_operand:SI 0 \"const_int_operand\" \"\"))])]\n+  assemble_integer (operands[0], 4, 4*BITS_PER_UNIT, 1);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"op_type\"  \"NN\")\n+   (set_attr \"length\"   \"4\")])\n+\n+(define_insn \"consttable_di\"\n+  [(unspec_volatile [(match_operand:DI 0 \"consttable_operand\" \"X\")] 203)]\n   \"\"\n   \"*\n {\n-   s390_dump_literal_pool (insn, operands[0]);\n-   return \\\"0:\\\";\n+  assemble_integer (operands[0], 8, 8*BITS_PER_UNIT, 1);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"op_type\"  \"NN\")\n+   (set_attr \"length\"   \"8\")])\n+\n+(define_insn \"consttable_sf\"\n+  [(unspec_volatile [(match_operand:SF 0 \"consttable_operand\" \"X\")] 204)]\n+  \"\"\n+  \"*\n+{\n+  REAL_VALUE_TYPE r;\n+\n+  if (GET_CODE (operands[0]) != CONST_DOUBLE)\n+    abort ();\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, operands[0]);\n+  assemble_real (r, SFmode, 4*BITS_PER_UNIT);\n+  return \\\"\\\";\n }\"\n+  [(set_attr \"op_type\"  \"NN\")\n+   (set_attr \"length\"   \"4\")])\n+\n+(define_insn \"consttable_df\"\n+  [(unspec_volatile [(match_operand:DF 0 \"consttable_operand\" \"X\")] 205)]\n+  \"\"\n+  \"*\n+{\n+  REAL_VALUE_TYPE r;\n+\n+  if (GET_CODE (operands[0]) != CONST_DOUBLE)\n+    abort ();\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, operands[0]);\n+  assemble_real (r, DFmode, 8*BITS_PER_UNIT);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"op_type\"  \"NN\")\n+   (set_attr \"length\"   \"8\")])\n+\n+(define_insn \"pool_start_31\"\n+  [(unspec_volatile [(const_int 0)] 206)]\n+  \"!TARGET_64BIT\"\n+  \".align\\\\t4\"\n+  [(set_attr \"op_type\"  \"NN\")\n+   (set_attr \"length\"   \"2\")])\n+\n+(define_insn \"pool_end_31\"\n+  [(unspec_volatile [(const_int 0)] 207)]\n+  \"!TARGET_64BIT\"\n+  \".align\\\\t2\"\n+  [(set_attr \"op_type\"  \"NN\")\n+   (set_attr \"length\"   \"2\")])\n+\n+(define_insn \"pool_start_64\"\n+  [(unspec_volatile [(const_int 0)] 206)]\n+  \"TARGET_64BIT\"\n+  \".section\\\\t.rodata\\;.align\\\\t8\"\n+  [(set_attr \"op_type\"  \"NN\")\n+   (set_attr \"length\"   \"0\")])\n+\n+(define_insn \"pool_end_64\"\n+  [(unspec_volatile [(const_int 0)] 207)]\n+  \"TARGET_64BIT\"\n+  \".previous\"\n+  [(set_attr \"op_type\"  \"NN\")\n+   (set_attr \"length\"   \"0\")])\n+\n+(define_insn \"reload_base\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+        (unspec:SI [(label_ref (match_operand 1 \"\" \"\"))] 210))]\n+  \"!TARGET_64BIT\"\n+  \"basr\\\\t%0,0\\;la\\\\t%0,%1-.(%0)\"\n   [(set_attr \"op_type\" \"NN\")\n-   (set_attr \"type\"    \"other\")\n-   (set_attr \"length\"  \"4096\")])\n+   (set_attr \"type\"    \"la\")\n+   (set_attr \"length\"  \"6\")])\n+\n+(define_insn \"reload_base2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+        (unspec:SI [(label_ref (match_operand 1 \"\" \"\"))] 211))]\n+  \"!TARGET_64BIT\"\n+  \"la\\\\t%0,%1-.(%0)\"\n+  [(set_attr \"op_type\" \"NN\")\n+   (set_attr \"type\"    \"la\")\n+   (set_attr \"length\"  \"4\")])\n+\n \n ;;\n ;; Insns related to generating the function prologue and epilogue."}]}