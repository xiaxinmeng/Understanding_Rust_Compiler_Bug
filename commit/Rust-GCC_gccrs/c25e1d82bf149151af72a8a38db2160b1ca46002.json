{"sha": "c25e1d82bf149151af72a8a38db2160b1ca46002", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI1ZTFkODJiZjE0OTE1MWFmNzJhOGEzOGRiMjE2MGIxY2E0NjAwMg==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2016-07-20T14:12:16Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2016-07-20T14:12:16Z"}, "message": "Implement attribute progmem on reduced Tiny cores by adding flash offset 0x4000 to respective symbols.\n\ngcc/\n\tImplement attribute progmem on reduced Tiny cores by adding\n\tflash offset 0x4000 to respective symbols.\n\n\tPR target/71948\n\t* doc/extend.texi (AVR Variable Attributes) [progmem]: Add\n\tdocumentation how it works on reduced Tiny cores.\n\t(AVR Named Address Spaces): No support for reduced Tiny.\n\t* config/avr/avr.c (AVR_SYMBOL_FLAG_TINY_PM): New macro.\n\t(avr_address_tiny_pm_p): New static function.\n\t(avr_print_operand_address) [AVR_TINY]: Add AVR_TINY_PM_OFFSET\n\tif the address is in progmem.\n\t(avr_assemble_integer): Same.\n\t(avr_encode_section_info) [AVR_TINY]: Set AVR_SYMBOL_FLAG_TINY_PM\n\tfor symbol_ref in progmem.\n\t* config/avr/avr.h (AVR_TINY_PM_OFFSET): New macro.\n\t* config/avr/avr-c.c (avr_cpu_cpp_builtins): Use it instead of\n\tmagic 0x4000 when built-in def'ing __AVR_TINY_PM_BASE_ADDRESS__.\ngcc/testsuite/\n\tPR target/71948\n\t* gcc.target/avr/torture/tiny-progmem.c: New test.\n\nFrom-SVN: r238525", "tree": {"sha": "2bc4015645e9b395fa0a3e6e1abc9653b4d1d21b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bc4015645e9b395fa0a3e6e1abc9653b4d1d21b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c25e1d82bf149151af72a8a38db2160b1ca46002", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c25e1d82bf149151af72a8a38db2160b1ca46002", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c25e1d82bf149151af72a8a38db2160b1ca46002", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c25e1d82bf149151af72a8a38db2160b1ca46002/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25e08379b869ba2f2def6d0e9d8443e053f8c3be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25e08379b869ba2f2def6d0e9d8443e053f8c3be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25e08379b869ba2f2def6d0e9d8443e053f8c3be"}], "stats": {"total": 227, "additions": 220, "deletions": 7}, "files": [{"sha": "167c46a1ca2d3792f3b4b3c962dbe279400780eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c25e1d82bf149151af72a8a38db2160b1ca46002/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c25e1d82bf149151af72a8a38db2160b1ca46002/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c25e1d82bf149151af72a8a38db2160b1ca46002", "patch": "@@ -1,3 +1,23 @@\n+2016-07-20  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tImplement attribute progmem on reduced Tiny cores by adding\n+\tflash offset 0x4000 to respective symbols.\n+\n+\tPR target/71948\n+\t* doc/extend.texi (AVR Variable Attributes) [progmem]: Add\n+\tdocumentation how it works on reduced Tiny cores.\n+\t(AVR Named Address Spaces): No support for reduced Tiny.\n+\t* config/avr/avr.c (AVR_SYMBOL_FLAG_TINY_PM): New macro.\n+\t(avr_address_tiny_pm_p): New static function.\n+\t(avr_print_operand_address) [AVR_TINY]: Add AVR_TINY_PM_OFFSET\n+\tif the address is in progmem.\n+\t(avr_assemble_integer): Same.\n+\t(avr_encode_section_info) [AVR_TINY]: Set AVR_SYMBOL_FLAG_TINY_PM\n+\tfor symbol_ref in progmem.\n+\t* config/avr/avr.h (AVR_TINY_PM_OFFSET): New macro.\n+\t* config/avr/avr-c.c (avr_cpu_cpp_builtins): Use it instead of\n+\tmagic 0x4000 when built-in def'ing __AVR_TINY_PM_BASE_ADDRESS__.\n+\n 2016-07-20  Patrick Palka  <ppalka@gcc.gnu.org>\n \n \t* configure.ac (thin_archive_support): New variable.  AC_SUBST it."}, {"sha": "270b803edf0a6abc973b29d2f0f92a9c6fb00fee", "filename": "gcc/config/avr/avr-c.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c25e1d82bf149151af72a8a38db2160b1ca46002/gcc%2Fconfig%2Favr%2Favr-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c25e1d82bf149151af72a8a38db2160b1ca46002/gcc%2Fconfig%2Favr%2Favr-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-c.c?ref=c25e1d82bf149151af72a8a38db2160b1ca46002", "patch": "@@ -296,7 +296,7 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n   builtin_define_std (\"AVR\");\n \n   /* __AVR_DEVICE_NAME__ and  avr_mcu_types[].macro like __AVR_ATmega8__\n-\t are defined by -D command option, see device-specs file.  */\n+     are defined by -D command option, see device-specs file.  */\n \n   if (avr_arch->macro)\n     cpp_define_formatted (pfile, \"__AVR_ARCH__=%s\", avr_arch->macro);\n@@ -337,7 +337,8 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n          it has been mapped to the data memory.  For AVR_TINY devices\n          (ATtiny4/5/9/10/20 and 40) mapped program memory starts at 0x4000. */\n \n-      cpp_define (pfile, \"__AVR_TINY_PM_BASE_ADDRESS__=0x4000\");\n+      cpp_define_formatted (pfile, \"__AVR_TINY_PM_BASE_ADDRESS__=0x%x\",\n+                            AVR_TINY_PM_OFFSET);\n     }\n \n   if (AVR_HAVE_EIJMP_EICALL)"}, {"sha": "95f691c7ac749361d2225d2c425d31003d86a143", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c25e1d82bf149151af72a8a38db2160b1ca46002/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c25e1d82bf149151af72a8a38db2160b1ca46002/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=c25e1d82bf149151af72a8a38db2160b1ca46002", "patch": "@@ -80,6 +80,10 @@\n   ((SYMBOL_REF_FLAGS (sym) & AVR_SYMBOL_FLAG_PROGMEM)           \\\n    / SYMBOL_FLAG_MACH_DEP)\n \n+/* (AVR_TINY only): Symbol has attribute progmem */\n+#define AVR_SYMBOL_FLAG_TINY_PM \\\n+  (SYMBOL_FLAG_MACH_DEP << 4)\n+\n #define TINY_ADIW(REG1, REG2, I)                                \\\n     \"subi \" #REG1 \",lo8(-(\" #I \"))\" CR_TAB                      \\\n     \"sbci \" #REG2 \",hi8(-(\" #I \"))\"\n@@ -2161,12 +2165,35 @@ cond_string (enum rtx_code code)\n }\n \n \n+/* Return true if rtx X is a CONST or SYMBOL_REF with progmem.\n+   This must be used for AVR_TINY only because on other cores\n+   the flash memory is not visible in the RAM address range and\n+   cannot be read by, say,  LD instruction.  */\n+\n+static bool\n+avr_address_tiny_pm_p (rtx x)\n+{\n+  if (CONST == GET_CODE (x))\n+    x = XEXP (XEXP (x, 0), 0);\n+\n+  if (SYMBOL_REF_P (x))\n+    return SYMBOL_REF_FLAGS (x) & AVR_SYMBOL_FLAG_TINY_PM;\n+\n+  return false;\n+}\n+\n /* Implement `TARGET_PRINT_OPERAND_ADDRESS'.  */\n /* Output ADDR to FILE as address.  */\n \n static void\n avr_print_operand_address (FILE *file, machine_mode /*mode*/, rtx addr)\n {\n+  if (AVR_TINY\n+      && avr_address_tiny_pm_p (addr))\n+    {\n+      addr = plus_constant (Pmode, addr, AVR_TINY_PM_OFFSET);\n+    }\n+\n   switch (GET_CODE (addr))\n     {\n     case REG:\n@@ -8937,6 +8964,12 @@ avr_assemble_integer (rtx x, unsigned int size, int aligned_p)\n       return true;\n     }\n \n+  if (AVR_TINY\n+      && avr_address_tiny_pm_p (x))\n+    {\n+      x = plus_constant (Pmode, x, AVR_TINY_PM_OFFSET);\n+    }\n+\n   return default_assemble_integer (x, size, aligned_p);\n }\n \n@@ -9603,7 +9636,7 @@ avr_encode_section_info (tree decl, rtx rtl, int new_decl_p)\n   if (decl && DECL_P (decl)\n       && TREE_CODE (decl) != FUNCTION_DECL\n       && MEM_P (rtl)\n-      && SYMBOL_REF == GET_CODE (XEXP (rtl, 0)))\n+      && SYMBOL_REF_P (XEXP (rtl, 0)))\n    {\n       rtx sym = XEXP (rtl, 0);\n       tree type = TREE_TYPE (decl);\n@@ -9616,7 +9649,8 @@ avr_encode_section_info (tree decl, rtx rtl, int new_decl_p)\n       /* PSTR strings are in generic space but located in flash:\n          patch address space.  */\n \n-      if (-1 == avr_progmem_p (decl, attr))\n+      if (!AVR_TINY\n+          && -1 == avr_progmem_p (decl, attr))\n         as = ADDR_SPACE_FLASH;\n \n       AVR_SYMBOL_SET_ADDR_SPACE (sym, as);\n@@ -9647,6 +9681,19 @@ avr_encode_section_info (tree decl, rtx rtl, int new_decl_p)\n       if (addr_attr && !DECL_EXTERNAL (decl))\n \tSYMBOL_REF_FLAGS (sym) |= SYMBOL_FLAG_ADDRESS;\n     }\n+\n+  if (AVR_TINY\n+      && decl\n+      && VAR_DECL == TREE_CODE (decl)\n+      && -1 == avr_progmem_p (decl, DECL_ATTRIBUTES (decl))\n+      && MEM_P (rtl)\n+      && SYMBOL_REF_P (XEXP (rtl, 0)))\n+    {\n+      /* Tag symbols for later addition of 0x4000 (AVR_TINY_PM_OFFSET).  */\n+\n+      rtx sym = XEXP (rtl, 0);\n+      SYMBOL_REF_FLAGS (sym) |= AVR_SYMBOL_FLAG_TINY_PM;\n+    }\n }\n \n "}, {"sha": "5eb90b52cbf630e8d62b190dadb33750a285ce25", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c25e1d82bf149151af72a8a38db2160b1ca46002/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c25e1d82bf149151af72a8a38db2160b1ca46002/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=c25e1d82bf149151af72a8a38db2160b1ca46002", "patch": "@@ -74,6 +74,8 @@ enum\n                         || avr_arch->have_rampd)\n #define AVR_HAVE_EIJMP_EICALL (avr_arch->have_eijmp_eicall)\n \n+#define AVR_TINY_PM_OFFSET (0x4000)\n+\n /* Handling of 8-bit SP versus 16-bit SP is as follows:\n \n FIXME: DRIVER_SELF_SPECS has changed."}, {"sha": "8a21c5b251bfa6c64b3f28cb13baf69bbf3a71d2", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c25e1d82bf149151af72a8a38db2160b1ca46002/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c25e1d82bf149151af72a8a38db2160b1ca46002/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=c25e1d82bf149151af72a8a38db2160b1ca46002", "patch": "@@ -1422,6 +1422,11 @@ const __memx void *pfoo = &foo;\n Such code requires at least binutils 2.23, see\n @w{@uref{http://sourceware.org/PR13503,PR13503}}.\n \n+@item\n+On the reduced Tiny devices like ATtiny40, no address spaces are supported.\n+Data can be put into and read from flash memory by means of\n+attribute @code{progmem}, see @ref{AVR Variable Attributes}.\n+\n @end itemize\n \n @subsection M32C Named Address Spaces\n@@ -5847,10 +5852,12 @@ attribute accomplishes this by putting respective variables into a\n section whose name starts with @code{.progmem}.\n \n This attribute works similar to the @code{section} attribute\n-but adds additional checking. Notice that just like the\n-@code{section} attribute, @code{progmem} affects the location\n-of the data but not how this data is accessed.\n+but adds additional checking.\n \n+@table @asis\n+@item @bullet{}@tie{} Ordinary AVR cores with 32 general purpose registers:\n+@code{progmem} affects the location\n+of the data but not how this data is accessed.\n In order to read data located with the @code{progmem} attribute\n (inline) assembler must be used.\n @smallexample\n@@ -5873,6 +5880,28 @@ normally resides in the data memory (RAM).\n See also the @ref{AVR Named Address Spaces} section for\n an alternate way to locate and access data in flash memory.\n \n+@item @bullet{}@tie{}Reduced AVR Tiny cores like ATtiny40:\n+The compiler adds @code{0x4000}\n+to the addresses of objects and declarations in @code{progmem} and locates\n+the objects in flash memory, namely in section @code{.progmem.data}.\n+The offset is needed because the flash memory is visible in the RAM\n+address space starting at address @code{0x4000}.\n+\n+Data in @code{progmem} can be accessed by means of ordinary C@tie{}code,\n+no special functions or macros are needed.\n+\n+@smallexample\n+/* var is located in flash memory */\n+extern const int var[2] __attribute__((progmem));\n+\n+int read_var (int i)\n+@{\n+    return var[i];\n+@}\n+@end smallexample\n+\n+@end table\n+\n @item io\n @itemx io (@var{addr})\n @cindex @code{io} variable attribute, AVR"}, {"sha": "952513711ca16d41c06899ef4d1deeb1d4380dc6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c25e1d82bf149151af72a8a38db2160b1ca46002/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c25e1d82bf149151af72a8a38db2160b1ca46002/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c25e1d82bf149151af72a8a38db2160b1ca46002", "patch": "@@ -1,3 +1,8 @@\n+2016-07-20  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/71948\n+\t* gcc.target/avr/torture/tiny-progmem.c: New test.\n+\n 2016-07-20  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/71909"}, {"sha": "1545c55ca3ea9432bc58f38143cdd29525473e21", "filename": "gcc/testsuite/gcc.target/avr/torture/tiny-progmem.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c25e1d82bf149151af72a8a38db2160b1ca46002/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Ftiny-progmem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c25e1d82bf149151af72a8a38db2160b1ca46002/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Ftiny-progmem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Ftiny-progmem.c?ref=c25e1d82bf149151af72a8a38db2160b1ca46002", "patch": "@@ -0,0 +1,109 @@\n+/* { dg-do run } */\n+/* { dg-options \"-Wl,--defsym,test6_xdata=0\" } */\n+\n+#ifdef __AVR_TINY__\n+#define PM __attribute__((__progmem__))\n+#else\n+/* On general core, just resort to vanilla C. */\n+#define PM /* Empty */\n+#endif\n+\n+#define PSTR(s) (__extension__({ static const char __c[] PM = (s); &__c[0];}))\n+\n+#define NI __attribute__((noinline,noclone))\n+\n+const volatile int data[] PM = { 1234, 5678 };\n+const volatile int * volatile pdata = &data[1];\n+\n+int ram[2];\n+\n+const int myvar PM = 42;\n+extern const int xvar __asm (\"myvar\") PM;\n+\n+NI int const volatile* get_addr_1 (void)\n+{\n+  return &data[1];\n+}\n+\n+NI int const volatile* get_addr_x (int x)\n+{\n+  return &data[x];\n+}\n+\n+void test_1 (void)\n+{\n+  if (data[0] != 1234)\n+    __builtin_abort();\n+\n+  if (data[1] != 5678)\n+    __builtin_abort();\n+}\n+\n+void test_2 (void)\n+{\n+  if (data[1] != 5678)\n+    __builtin_abort();\n+}\n+\n+void test_3 (void)\n+{\n+  if (&data[1] != pdata)\n+    __builtin_abort();\n+}\n+\n+void test_4 (void)\n+{\n+  if (5678 != *get_addr_1())\n+    __builtin_abort();\n+  if (5678 != *get_addr_x(1))\n+    __builtin_abort();\n+}\n+\n+void test_5 (void)\n+{\n+  __builtin_memcpy (&ram, (void*) &data, 4);\n+  if (ram[0] - ram[1] != 1234 - 5678)\n+    __builtin_abort();\n+}\n+\n+const char pmSTR[] PM = \"01234\";\n+\n+NI const char* get_pmSTR (int i)\n+{\n+  return pmSTR + 2 + i;\n+}\n+\n+void test_6 (void)\n+{\n+#ifdef __AVR_TINY__\n+  extern const int test6_xdata PM;\n+  const char* str = PSTR (\"Hallo\");\n+  if (0 == (__AVR_TINY_PM_BASE_ADDRESS__ & (__UINTPTR_TYPE__) str))\n+    __builtin_abort();\n+  if (0 == (__AVR_TINY_PM_BASE_ADDRESS__ & (__UINTPTR_TYPE__) test6_xdata))\n+    __builtin_abort();\n+#endif\n+  \n+  if (get_pmSTR (0)[0] != '0' + 2)\n+    __builtin_abort();\n+  if (get_pmSTR (1)[0] != '1' + 2)\n+    __builtin_abort();\n+}\n+\n+void test_7 (void)\n+{\n+  if (xvar != 42)\n+    __builtin_abort();\n+}\n+\n+int main()\n+{\n+  test_1();\n+  test_2();\n+  test_3();\n+  test_4();\n+  test_5();\n+  test_6();\n+  test_7();\n+  return 0;\n+}"}]}