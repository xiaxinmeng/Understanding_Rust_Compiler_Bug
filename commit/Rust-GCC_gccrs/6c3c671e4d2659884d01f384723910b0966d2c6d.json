{"sha": "6c3c671e4d2659884d01f384723910b0966d2c6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmMzYzY3MWU0ZDI2NTk4ODRkMDFmMzg0NzIzOTEwYjA5NjZkMmM2ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-21T16:16:43Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-21T16:16:43Z"}, "message": "[multiple changes]\n\n2014-01-21  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* aspects.adb Add entries for Async_Readers, Async_Writers,\n\tEffective_Reads and Effective_Writes in table Canonical_Aspect.\n\t* aspects.ads Add entries for Async_Readers, Async_Writers,\n\tEffective_Reads and Effective_Writes in tables Aspect_Id,\n\tAspect_Names, Aspect_Delay and Implementation_Defined_Aspect.\n\t* atree.adb (Ekind_In): New version with 8 parameters.\n\t(Node34): New routine.\n\t(Set_Node34): New routine.\n\t* atree.ads (Ekind_In): New version with 8 parameters.\n\t(Node34): New routine.\n\t(Set_Node34): New routine.\n\t* einfo.adb Contract is now Node34.\n\t(Contract): Update the assertion and node usage.\n\t(Get_Pragma): Include pragmas Async_Readers, Async_Writers,\n\tEffective_Reads and Effective_Writes.\n\t(Set_Contract): Update the assertion and node usage.\n\t(Write_Field24_Name): Remove the output for a contract.\n\t(Write_Field34_Name): Add output for a contract.\n\t* einfo.ads Contract is now Node34. Update the comment on\n\tattribute usage and related node structures.\n\t(Get_Pragma): Update the comment on usage.\n\t* par-prag.adb (Prag): Pragmas Async_Readers, Async_Writers,\n\tEffective_Reads and Effective_Writes do not require special\n\tprocessing by the parser.\n\t* sem_ch3.adb (Analyze_Variable_Contract): New routine.\n\t(Analyze_Declarations): Analyze the contract of a variable at\n\tthe end of the declarative region.\n\t(Analyze_Object_Declaration): Create a contract for a variable.\n\t* sem_ch6.adb (Analyze_Subprogram_Contract): Update the retrieval\n\tof classification pragmas.\n\t(Process_Formals): Detect an illegal\n\tuse of a volatile object as a formal in a function.\n\t* sem_ch12.adb (Instantiate_Object): Detect an illegal use of\n\ta volatile object as an actual in generic instantiation.\n\t* sem_prag.adb Add entries for Async_Readers, Async_Writers,\n\tEffective_Reads and Effective_Writes in table Sig_Flags.\n\t(Analyze_External_State_In_Decl_Part): New routine.\n\t(Analyze_Global_Item): Detect an illegal use of a volatile object\n\tas a global item of a function.\n\t(Analyze_Pragma): Reimplement\n\tpragma Abstract_State. Add support for pragmas Async_Readers,\n\tAsync_Writers, Effective_Reads and Effective_Writes.\n\t(Check_External_Properties): New routine.\n\t* sem_prag.ads (Analyze_External_State_In_Decl_Part): New routine.\n\t(Check_External_Properties): New routine.\n\t* sem_res.adb (Resolve_Actuals): Detect an illegal use of a\n\tvolatile object as an actual in a call.\n\t(Resolve_Entity_Name):\n\tAdd local variables Par, Prev and Usage_OK. Detect illegal\n\tcontexts of volatile objects.\n\t* sem_util.adb (Add_Contract_Item): Add support for\n\tpragmas associated with the contract of a variable.\n\t(Async_Readers_Enabled): New routine.\n\t(Async_Writers_Enabled): New routine.\n\t(Effective_Reads_Enabled): New routine.\n\t(Effective_Writes_Enabled): New routine.\n\t(Has_Enabled_Property):\n\tNew routine.\n\t(Is_Unchecked_Conversion_Instance): New routine.\n\t(Is_Volatile_Object): Add support for entities that may denote\n\ta volatile object.\n\t* sem_util.ads (Add_Contract_Item): Update the\n\tcomment on usage.\n\t(Async_Readers_Enabled): New routine.\n\t(Async_Writers_Enabled): New routine.\n\t(Effective_Reads_Enabled): New routine.\n\t(Effective_Writes_Enabled): New routine.\n\t(Is_Unchecked_Conversion_Instance): New routine.\n\t* sinfo.ads Update the comment on the structure of N_Contract.\n\t* snames.ads-tmpl Add predefined names for Async_Readers,\n\tAsync_Writers, Effective_Reads and Effective_Writes. Add\n\tpragma ids for Async_Readers, Async_Writers, Effective_Reads\n\tand Effective_Writes.\n\n2014-01-21  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch4.adb (Eval_Op_Expon): Use CRT_Safe_Compile_Time_Known_Value\n\t* sem_eval.adb (Compile_Time_Known_Value): Remove special\n\thandling of CRT mode (CRT_Safe_Compile_Time_Known_Value): New\n\tfunction (Eval_Op_Expon): Add CRT_Safe in call to Test_Foldable\n\t(Test_Foldable): Add CRT_Safe parameter\n\t* sem_eval.ads (Compile_Time_Known_Value): Remove special\n\thandling of CRT mode.\n\t(CRT_Safe_Compile_Time_Known_Value): New function.\n\nFrom-SVN: r206886", "tree": {"sha": "8ed9f54f33935952c4e9823fa9733894c38423dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ed9f54f33935952c4e9823fa9733894c38423dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c3c671e4d2659884d01f384723910b0966d2c6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c3c671e4d2659884d01f384723910b0966d2c6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c3c671e4d2659884d01f384723910b0966d2c6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c3c671e4d2659884d01f384723910b0966d2c6d/comments", "author": null, "committer": null, "parents": [{"sha": "084c220328b5738ed943d513cc8f646cfa167dea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/084c220328b5738ed943d513cc8f646cfa167dea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/084c220328b5738ed943d513cc8f646cfa167dea"}], "stats": {"total": 1427, "additions": 1207, "deletions": 220}, "files": [{"sha": "2fbcd79c418cd46bfae093d0358d101af595b3af", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6c3c671e4d2659884d01f384723910b0966d2c6d", "patch": "@@ -1,3 +1,90 @@\n+2014-01-21  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* aspects.adb Add entries for Async_Readers, Async_Writers,\n+\tEffective_Reads and Effective_Writes in table Canonical_Aspect.\n+\t* aspects.ads Add entries for Async_Readers, Async_Writers,\n+\tEffective_Reads and Effective_Writes in tables Aspect_Id,\n+\tAspect_Names, Aspect_Delay and Implementation_Defined_Aspect.\n+\t* atree.adb (Ekind_In): New version with 8 parameters.\n+\t(Node34): New routine.\n+\t(Set_Node34): New routine.\n+\t* atree.ads (Ekind_In): New version with 8 parameters.\n+\t(Node34): New routine.\n+\t(Set_Node34): New routine.\n+\t* einfo.adb Contract is now Node34.\n+\t(Contract): Update the assertion and node usage.\n+\t(Get_Pragma): Include pragmas Async_Readers, Async_Writers,\n+\tEffective_Reads and Effective_Writes.\n+\t(Set_Contract): Update the assertion and node usage.\n+\t(Write_Field24_Name): Remove the output for a contract.\n+\t(Write_Field34_Name): Add output for a contract.\n+\t* einfo.ads Contract is now Node34. Update the comment on\n+\tattribute usage and related node structures.\n+\t(Get_Pragma): Update the comment on usage.\n+\t* par-prag.adb (Prag): Pragmas Async_Readers, Async_Writers,\n+\tEffective_Reads and Effective_Writes do not require special\n+\tprocessing by the parser.\n+\t* sem_ch3.adb (Analyze_Variable_Contract): New routine.\n+\t(Analyze_Declarations): Analyze the contract of a variable at\n+\tthe end of the declarative region.\n+\t(Analyze_Object_Declaration): Create a contract for a variable.\n+\t* sem_ch6.adb (Analyze_Subprogram_Contract): Update the retrieval\n+\tof classification pragmas.\n+\t(Process_Formals): Detect an illegal\n+\tuse of a volatile object as a formal in a function.\n+\t* sem_ch12.adb (Instantiate_Object): Detect an illegal use of\n+\ta volatile object as an actual in generic instantiation.\n+\t* sem_prag.adb Add entries for Async_Readers, Async_Writers,\n+\tEffective_Reads and Effective_Writes in table Sig_Flags.\n+\t(Analyze_External_State_In_Decl_Part): New routine.\n+\t(Analyze_Global_Item): Detect an illegal use of a volatile object\n+\tas a global item of a function.\n+\t(Analyze_Pragma): Reimplement\n+\tpragma Abstract_State. Add support for pragmas Async_Readers,\n+\tAsync_Writers, Effective_Reads and Effective_Writes.\n+\t(Check_External_Properties): New routine.\n+\t* sem_prag.ads (Analyze_External_State_In_Decl_Part): New routine.\n+\t(Check_External_Properties): New routine.\n+\t* sem_res.adb (Resolve_Actuals): Detect an illegal use of a\n+\tvolatile object as an actual in a call.\n+\t(Resolve_Entity_Name):\n+\tAdd local variables Par, Prev and Usage_OK. Detect illegal\n+\tcontexts of volatile objects.\n+\t* sem_util.adb (Add_Contract_Item): Add support for\n+\tpragmas associated with the contract of a variable.\n+\t(Async_Readers_Enabled): New routine.\n+\t(Async_Writers_Enabled): New routine.\n+\t(Effective_Reads_Enabled): New routine.\n+\t(Effective_Writes_Enabled): New routine.\n+\t(Has_Enabled_Property):\n+\tNew routine.\n+\t(Is_Unchecked_Conversion_Instance): New routine.\n+\t(Is_Volatile_Object): Add support for entities that may denote\n+\ta volatile object.\n+\t* sem_util.ads (Add_Contract_Item): Update the\n+\tcomment on usage.\n+\t(Async_Readers_Enabled): New routine.\n+\t(Async_Writers_Enabled): New routine.\n+\t(Effective_Reads_Enabled): New routine.\n+\t(Effective_Writes_Enabled): New routine.\n+\t(Is_Unchecked_Conversion_Instance): New routine.\n+\t* sinfo.ads Update the comment on the structure of N_Contract.\n+\t* snames.ads-tmpl Add predefined names for Async_Readers,\n+\tAsync_Writers, Effective_Reads and Effective_Writes. Add\n+\tpragma ids for Async_Readers, Async_Writers, Effective_Reads\n+\tand Effective_Writes.\n+\n+2014-01-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch4.adb (Eval_Op_Expon): Use CRT_Safe_Compile_Time_Known_Value\n+\t* sem_eval.adb (Compile_Time_Known_Value): Remove special\n+\thandling of CRT mode (CRT_Safe_Compile_Time_Known_Value): New\n+\tfunction (Eval_Op_Expon): Add CRT_Safe in call to Test_Foldable\n+\t(Test_Foldable): Add CRT_Safe parameter\n+\t* sem_eval.ads (Compile_Time_Known_Value): Remove special\n+\thandling of CRT mode.\n+\t(CRT_Safe_Compile_Time_Known_Value): New function.\n+\n 2014-01-21  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_prag.adb (Analyze_Pragma, case SPARK_Mode): Fix problem"}, {"sha": "64a239ad23d5764884a46076b688886e0b79e7e8", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=6c3c671e4d2659884d01f384723910b0966d2c6d", "patch": "@@ -472,6 +472,8 @@ package body Aspects is\n     Aspect_Address                      => Aspect_Address,\n     Aspect_Alignment                    => Aspect_Alignment,\n     Aspect_All_Calls_Remote             => Aspect_All_Calls_Remote,\n+    Aspect_Async_Readers                => Aspect_Async_Readers,\n+    Aspect_Async_Writers                => Aspect_Async_Writers,\n     Aspect_Asynchronous                 => Aspect_Asynchronous,\n     Aspect_Atomic                       => Aspect_Atomic,\n     Aspect_Atomic_Components            => Aspect_Atomic_Components,\n@@ -492,6 +494,8 @@ package body Aspects is\n     Aspect_Discard_Names                => Aspect_Discard_Names,\n     Aspect_Dispatching_Domain           => Aspect_Dispatching_Domain,\n     Aspect_Dynamic_Predicate            => Aspect_Predicate,\n+    Aspect_Effective_Reads              => Aspect_Effective_Reads,\n+    Aspect_Effective_Writes             => Aspect_Effective_Writes,\n     Aspect_Elaborate_Body               => Aspect_Elaborate_Body,\n     Aspect_Export                       => Aspect_Export,\n     Aspect_External_Name                => Aspect_External_Name,"}, {"sha": "c5d76320ee380ff2963b654797ec286811878cbc", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=6c3c671e4d2659884d01f384723910b0966d2c6d", "patch": "@@ -161,10 +161,14 @@ package Aspects is\n \n       Aspect_Ada_2005,                      -- GNAT\n       Aspect_Ada_2012,                      -- GNAT\n+      Aspect_Async_Readers,                 -- GNAT\n+      Aspect_Async_Writers,                 -- GNAT\n       Aspect_Asynchronous,\n       Aspect_Atomic,\n       Aspect_Atomic_Components,\n       Aspect_Discard_Names,\n+      Aspect_Effective_Reads,               -- GNAT\n+      Aspect_Effective_Writes,              -- GNAT\n       Aspect_Export,\n       Aspect_Favor_Top_Level,               -- GNAT\n       Aspect_Independent,\n@@ -215,11 +219,15 @@ package Aspects is\n      (Aspect_Abstract_State           => True,\n       Aspect_Ada_2005                 => True,\n       Aspect_Ada_2012                 => True,\n+      Aspect_Async_Readers            => True,\n+      Aspect_Async_Writers            => True,\n       Aspect_Compiler_Unit            => True,\n       Aspect_Contract_Cases           => True,\n       Aspect_Depends                  => True,\n       Aspect_Dimension                => True,\n       Aspect_Dimension_System         => True,\n+      Aspect_Effective_Reads          => True,\n+      Aspect_Effective_Writes         => True,\n       Aspect_Favor_Top_Level          => True,\n       Aspect_Global                   => True,\n       Aspect_Inline_Always            => True,\n@@ -368,6 +376,8 @@ package Aspects is\n       Aspect_Address                      => Name_Address,\n       Aspect_Alignment                    => Name_Alignment,\n       Aspect_All_Calls_Remote             => Name_All_Calls_Remote,\n+      Aspect_Async_Readers                => Name_Async_Readers,\n+      Aspect_Async_Writers                => Name_Async_Writers,\n       Aspect_Asynchronous                 => Name_Asynchronous,\n       Aspect_Atomic                       => Name_Atomic,\n       Aspect_Atomic_Components            => Name_Atomic_Components,\n@@ -388,6 +398,8 @@ package Aspects is\n       Aspect_Discard_Names                => Name_Discard_Names,\n       Aspect_Dispatching_Domain           => Name_Dispatching_Domain,\n       Aspect_Dynamic_Predicate            => Name_Dynamic_Predicate,\n+      Aspect_Effective_Reads              => Name_Effective_Reads,\n+      Aspect_Effective_Writes             => Name_Effective_Writes,\n       Aspect_Elaborate_Body               => Name_Elaborate_Body,\n       Aspect_External_Name                => Name_External_Name,\n       Aspect_External_Tag                 => Name_External_Tag,\n@@ -575,6 +587,8 @@ package Aspects is\n      (No_Aspect                           => Always_Delay,\n       Aspect_Address                      => Always_Delay,\n       Aspect_All_Calls_Remote             => Always_Delay,\n+      Aspect_Async_Readers                => Always_Delay,\n+      Aspect_Async_Writers                => Always_Delay,\n       Aspect_Asynchronous                 => Always_Delay,\n       Aspect_Attach_Handler               => Always_Delay,\n       Aspect_Compiler_Unit                => Always_Delay,\n@@ -588,6 +602,8 @@ package Aspects is\n       Aspect_Discard_Names                => Always_Delay,\n       Aspect_Dispatching_Domain           => Always_Delay,\n       Aspect_Dynamic_Predicate            => Always_Delay,\n+      Aspect_Effective_Reads              => Always_Delay,\n+      Aspect_Effective_Writes             => Always_Delay,\n       Aspect_Elaborate_Body               => Always_Delay,\n       Aspect_External_Name                => Always_Delay,\n       Aspect_External_Tag                 => Always_Delay,"}, {"sha": "86820b45e4590d7052b25f40b40cebb7242c62b7", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=6c3c671e4d2659884d01f384723910b0966d2c6d", "patch": "@@ -1008,6 +1008,28 @@ package body Atree is\n              T = V7;\n    end Ekind_In;\n \n+   function Ekind_In\n+     (T  : Entity_Kind;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind;\n+      V4 : Entity_Kind;\n+      V5 : Entity_Kind;\n+      V6 : Entity_Kind;\n+      V7 : Entity_Kind;\n+      V8 : Entity_Kind) return Boolean\n+   is\n+   begin\n+      return T = V1 or else\n+             T = V2 or else\n+             T = V3 or else\n+             T = V4 or else\n+             T = V5 or else\n+             T = V6 or else\n+             T = V7 or else\n+             T = V8;\n+   end Ekind_In;\n+\n    function Ekind_In\n      (E  : Entity_Id;\n       V1 : Entity_Kind;\n@@ -1077,6 +1099,21 @@ package body Atree is\n       return Ekind_In (Ekind (E), V1, V2, V3, V4, V5, V6, V7);\n    end Ekind_In;\n \n+   function Ekind_In\n+     (E  : Entity_Id;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind;\n+      V4 : Entity_Kind;\n+      V5 : Entity_Kind;\n+      V6 : Entity_Kind;\n+      V7 : Entity_Kind;\n+      V8 : Entity_Kind) return Boolean\n+   is\n+   begin\n+      return Ekind_In (Ekind (E), V1, V2, V3, V4, V5, V6, V7, V8);\n+   end Ekind_In;\n+\n    ------------------------\n    -- Set_Reporting_Proc --\n    ------------------------\n@@ -2601,6 +2638,12 @@ package body Atree is\n          return Node_Id (Nodes.Table (N + 5).Field9);\n       end Node33;\n \n+      function Node34 (N : Node_Id) return Node_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Node_Id (Nodes.Table (N + 5).Field10);\n+      end Node34;\n+\n       function List1 (N : Node_Id) return List_Id is\n       begin\n          pragma Assert (N <= Nodes.Last);\n@@ -5348,6 +5391,12 @@ package body Atree is\n          Nodes.Table (N + 5).Field9 := Union_Id (Val);\n       end Set_Node33;\n \n+      procedure Set_Node34 (N : Node_Id; Val : Node_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Field10 := Union_Id (Val);\n+      end Set_Node34;\n+\n       procedure Set_List1 (N : Node_Id; Val : List_Id) is\n       begin\n          pragma Assert (N <= Nodes.Last);"}, {"sha": "d5b3bca3f0c7a013bed22c112f91f6c689c41848", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=6c3c671e4d2659884d01f384723910b0966d2c6d", "patch": "@@ -754,6 +754,17 @@ package Atree is\n       V6 : Entity_Kind;\n       V7 : Entity_Kind) return Boolean;\n \n+   function Ekind_In\n+     (E  : Entity_Id;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind;\n+      V4 : Entity_Kind;\n+      V5 : Entity_Kind;\n+      V6 : Entity_Kind;\n+      V7 : Entity_Kind;\n+      V8 : Entity_Kind) return Boolean;\n+\n    function Ekind_In\n      (T  : Entity_Kind;\n       V1 : Entity_Kind;\n@@ -799,6 +810,17 @@ package Atree is\n       V6 : Entity_Kind;\n       V7 : Entity_Kind) return Boolean;\n \n+   function Ekind_In\n+     (T  : Entity_Kind;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind;\n+      V4 : Entity_Kind;\n+      V5 : Entity_Kind;\n+      V6 : Entity_Kind;\n+      V7 : Entity_Kind;\n+      V8 : Entity_Kind) return Boolean;\n+\n    pragma Inline (Ekind_In);\n    --  Inline all above functions\n \n@@ -1212,6 +1234,9 @@ package Atree is\n       function Node33 (N : Node_Id) return Node_Id;\n       pragma Inline (Node33);\n \n+      function Node34 (N : Node_Id) return Node_Id;\n+      pragma Inline (Node34);\n+\n       function List1 (N : Node_Id) return List_Id;\n       pragma Inline (List1);\n \n@@ -2515,6 +2540,9 @@ package Atree is\n       procedure Set_Node33 (N : Node_Id; Val : Node_Id);\n       pragma Inline (Set_Node33);\n \n+      procedure Set_Node34 (N : Node_Id; Val : Node_Id);\n+      pragma Inline (Set_Node34);\n+\n       procedure Set_List1 (N : Node_Id; Val : List_Id);\n       pragma Inline (Set_List1);\n "}, {"sha": "65d54bb503131f89c0df4cecd949cc7391f8b7f5", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=6c3c671e4d2659884d01f384723910b0966d2c6d", "patch": "@@ -214,7 +214,6 @@ package body Einfo is\n    --    Stored_Constraint               Elist23\n \n    --    Related_Expression              Node24\n-   --    Contract                        Node24\n \n    --    Interface_Alias                 Node25\n    --    Interfaces                      Elist25\n@@ -252,7 +251,7 @@ package body Einfo is\n \n    --    SPARK_Aux_Pragma                Node33\n \n-   --    (unused)                        Node34\n+   --    Contract                        Node34\n \n    --    (unused)                        Node35\n \n@@ -1079,10 +1078,11 @@ package body Einfo is\n                        E_Generic_Package,\n                        E_Package,\n                        E_Package_Body,\n-                       E_Subprogram_Body)\n+                       E_Subprogram_Body,\n+                       E_Variable)\n           or else Is_Generic_Subprogram (Id)\n           or else Is_Subprogram (Id));\n-      return Node24 (Id);\n+      return Node34 (Id);\n    end Contract;\n \n    function Entry_Parameters_Type (Id : E) return E is\n@@ -3727,10 +3727,11 @@ package body Einfo is\n                        E_Package,\n                        E_Package_Body,\n                        E_Subprogram_Body,\n+                       E_Variable,\n                        E_Void)\n           or else Is_Generic_Subprogram (Id)\n           or else Is_Subprogram (Id));\n-      Set_Node24 (Id, V);\n+      Set_Node34 (Id, V);\n    end Set_Contract;\n \n    procedure Set_Entry_Parameters_Type (Id : E; V : E) is\n@@ -6395,7 +6396,11 @@ package body Einfo is\n    function Get_Pragma (E : Entity_Id; Id : Pragma_Id) return Node_Id is\n       Is_CDG  : constant Boolean :=\n                   Id = Pragma_Abstract_State    or else\n+                  Id = Pragma_Async_Readers     or else\n+                  Id = Pragma_Async_Writers     or else\n                   Id = Pragma_Depends           or else\n+                  Id = Pragma_Effective_Reads   or else\n+                  Id = Pragma_Effective_Writes  or else\n                   Id = Pragma_Global            or else\n                   Id = Pragma_Initial_Condition or else\n                   Id = Pragma_Initializes       or else\n@@ -9216,16 +9221,6 @@ package body Einfo is\n               Type_Kind                                    =>\n             Write_Str (\"Related_Expression\");\n \n-         when E_Entry                                      |\n-              E_Entry_Family                               |\n-              E_Generic_Package                            |\n-              E_Package                                    |\n-              E_Package_Body                               |\n-              E_Subprogram_Body                            |\n-              Generic_Subprogram_Kind                      |\n-              Subprogram_Kind                              =>\n-            Write_Str (\"Contract\");\n-\n          when others                                       =>\n             Write_Str (\"Field24???\");\n       end case;\n@@ -9468,6 +9463,17 @@ package body Einfo is\n    procedure Write_Field34_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Entry                                      |\n+              E_Entry_Family                               |\n+              E_Generic_Package                            |\n+              E_Package                                    |\n+              E_Package_Body                               |\n+              E_Subprogram_Body                            |\n+              E_Variable                                   |\n+              Generic_Subprogram_Kind                      |\n+              Subprogram_Kind                              =>\n+            Write_Str (\"Contract\");\n+\n          when others                                       =>\n             Write_Str (\"Field34??\");\n       end case;"}, {"sha": "75995743c04e4f9d3104c7accf2e11636ebee185", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=6c3c671e4d2659884d01f384723910b0966d2c6d", "patch": "@@ -1027,11 +1027,11 @@ package Einfo is\n --       accept statement for a member of the family, and in the prefix of\n --       'COUNT when it applies to a family member.\n \n---    Contract (Node24)\n+--    Contract (Node34)\n --       Defined in entry, entry family, package, package body, subprogram and\n---       subprogram body entities as well as their respective generic forms.\n---       Points to the contract of the entity, holding various assertion items\n---       and data classifiers.\n+--       subprogram body entities as well as their respective generic forms. A\n+--       contract is also applicable to a variable. Points to the contract of\n+--       the entity, holding various assertion items and data classifiers.\n \n --    Entry_Parameters_Type (Node15)\n --       Defined in entries. Points to the access-to-record type that is\n@@ -5369,9 +5369,9 @@ package Einfo is\n    --    Accept_Address                      (Elist21)\n    --    Scope_Depth_Value                   (Uint22)\n    --    Protection_Object                   (Node23)   (protected kind)\n-   --    Contract                            (Node24)\n    --    PPC_Wrapper                         (Node25)\n    --    Extra_Formals                       (Node28)\n+   --    Contract                            (Node34)\n    --    Default_Expressions_Processed       (Flag108)\n    --    Entry_Accepted                      (Flag152)\n    --    Is_AST_Entry                        (Flag132)  (for entry only)\n@@ -5472,7 +5472,6 @@ package Einfo is\n    --    Generic_Renamings                   (Elist23)  (for an instance)\n    --    Inner_Instances                     (Elist23)  (generic case only)\n    --    Protection_Object                   (Node23)   (for concurrent kind)\n-   --    Contract                            (Node24)\n    --    Interface_Alias                     (Node25)\n    --    Overridden_Operation                (Node26)\n    --    Wrapped_Entity                      (Node27)   (non-generic case only)\n@@ -5481,6 +5480,7 @@ package Einfo is\n    --    Corresponding_Equality              (Node30)   (implicit /= only)\n    --    Thunk_Entity                        (Node31)   (thunk case only)\n    --    SPARK_Pragma                        (Node32)\n+   --    Contract                            (Node34)\n    --    Body_Needed_For_SAL                 (Flag40)\n    --    Elaboration_Entity_Required         (Flag174)\n    --    Default_Expressions_Processed       (Flag108)\n@@ -5631,9 +5631,9 @@ package Einfo is\n    --    Alias                               (Node18)\n    --    Extra_Accessibility_Of_Result       (Node19)\n    --    Last_Entity                         (Node20)\n-   --    Contract                            (Node24)\n    --    Overridden_Operation                (Node26)\n    --    Subprograms_For_Type                (Node29)\n+   --    Contract                            (Node34)\n    --    Has_Invariants                      (Flag232)\n    --    Has_Postconditions                  (Flag240)\n    --    Is_Machine_Code_Subprogram          (Flag137)\n@@ -5676,13 +5676,13 @@ package Einfo is\n    --    Generic_Renamings                   (Elist23)  (for an instance)\n    --    Inner_Instances                     (Elist23)  (generic case only)\n    --    Limited_View                        (Node23)   (non-generic/instance)\n-   --    Contract                            (Node24)\n    --    Abstract_States                     (Elist25)\n    --    Package_Instantiation               (Node26)\n    --    Current_Use_Clause                  (Node27)\n    --    Finalizer                           (Node28)   (non-generic case only)\n    --    SPARK_Aux_Pragma                    (Node33)\n    --    SPARK_Pragma                        (Node32)\n+   --    Contract                            (Node34)\n    --    Delay_Subprogram_Descriptors        (Flag50)\n    --    Body_Needed_For_SAL                 (Flag40)\n    --    Discard_Names                       (Flag88)\n@@ -5715,10 +5715,10 @@ package Einfo is\n    --    Spec_Entity                         (Node19)\n    --    Last_Entity                         (Node20)\n    --    Scope_Depth_Value                   (Uint22)\n-   --    Contract                            (Node24)\n    --    Finalizer                           (Node28)   (non-generic case only)\n    --    SPARK_Aux_Pragma                    (Node33)\n    --    SPARK_Pragma                        (Node32)\n+   --    Contract                            (Node34)\n    --    Delay_Subprogram_Descriptors        (Flag50)\n    --    Has_Anonymous_Master                (Flag253)\n    --    SPARK_Aux_Pragma_Inherited          (Flag266)\n@@ -5760,14 +5760,14 @@ package Einfo is\n    --    Generic_Renamings                   (Elist23)  (for an instance)\n    --    Inner_Instances                     (Elist23)  (generic case only)\n    --    Protection_Object                   (Node23)   (for concurrent kind)\n-   --    Contract                            (Node24)\n    --    Interface_Alias                     (Node25)\n    --    Overridden_Operation                (Node26)   (never for init proc)\n    --    Wrapped_Entity                      (Node27)   (non-generic case only)\n    --    Extra_Formals                       (Node28)\n    --    Static_Initialization               (Node30)   (init_proc only)\n    --    Thunk_Entity                        (Node31)   (thunk case only)\n    --    SPARK_Pragma                        (Node32)\n+   --    Contract                            (Node34)\n    --    Body_Needed_For_SAL                 (Flag40)\n    --    Delay_Cleanups                      (Flag114)\n    --    Discard_Names                       (Flag88)\n@@ -5938,10 +5938,10 @@ package Einfo is\n    --    Corresponding_Protected_Entry       (Node18)\n    --    Last_Entity                         (Node20)\n    --    Scope_Depth_Value                   (Uint22)\n-   --    Contract                            (Node24)\n    --    Extra_Formals                       (Node28)\n    --    SPARK_Pragma                        (Node32)\n    --    SPARK_Pragma_Inherited              (Flag265)\n+   --    Contract                            (Node34)\n    --    Scope_Depth                         (synth)\n \n    --  E_Subprogram_Type\n@@ -6001,6 +6001,7 @@ package Einfo is\n    --    Last_Assignment                     (Node26)\n    --    Related_Type                        (Node27)\n    --    Initialization_Statements           (Node28)\n+   --    Contract                            (Node34)\n    --    Has_Alignment_Clause                (Flag46)\n    --    Has_Atomic_Components               (Flag86)\n    --    Has_Biased_Representation           (Flag139)\n@@ -7494,15 +7495,21 @@ package Einfo is\n    --  with the given pragma Id. If found, the value returned is the N_Pragma\n    --  node, otherwise Empty is returned. The following contract pragmas that\n    --  appear in N_Contract nodes are also handled by this routine:\n+   --    Abstract_State\n+   --    Async_Readers\n+   --    Async_Writers\n    --    Contract_Cases\n    --    Depends\n+   --    Effective_Reads\n+   --    Effective_Writes\n    --    Global\n    --    Initial_Condition\n    --    Initializes\n    --    Precondition\n    --    Postcondition\n    --    Refined_Depends\n    --    Refined_Global\n+   --    Refined_State\n \n    function Get_Record_Representation_Clause (E : Entity_Id) return Node_Id;\n    --  Searches the Rep_Item chain for a given entity E, for a record"}, {"sha": "03dc4fdccc4421b2a8c4e4772a93ef7183d84de6", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=6c3c671e4d2659884d01f384723910b0966d2c6d", "patch": "@@ -7352,7 +7352,12 @@ package body Exp_Ch4 is\n       --  Test for case of known right argument where we can replace the\n       --  exponentiation by an equivalent expression using multiplication.\n \n-      if Compile_Time_Known_Value (Exp) then\n+      --  Note: use CRT_Safe version of Compile_Time_Known_Value because in\n+      --  configurable run-time mode, we may not have the exponentiation\n+      --  routine available, and we don't want the legality of the program\n+      --  to depend on how clever the compiler is in knowing values.\n+\n+      if CRT_Safe_Compile_Time_Known_Value (Exp) then\n          Expv := Expr_Value (Exp);\n \n          --  We only fold small non-negative exponents. You might think we\n@@ -7454,7 +7459,8 @@ package body Exp_Ch4 is\n       --  result if the shift causes an overflow before the modular reduction.\n \n       if Nkind (Base) = N_Integer_Literal\n-        and then Intval (Base) = 2\n+        and then CRT_Safe_Compile_Time_Known_Value (Base)\n+        and then Expr_Value (Base) = Uint_2\n         and then Is_Integer_Type (Root_Type (Exptyp))\n         and then Esize (Root_Type (Exptyp)) <= Esize (Standard_Integer)\n         and then Is_Unsigned_Type (Exptyp)"}, {"sha": "0d70800973e878864fa5bf4e1f86f9dbea502328", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=6c3c671e4d2659884d01f384723910b0966d2c6d", "patch": "@@ -1109,6 +1109,8 @@ begin\n \n       when Pragma_Abort_Defer                    |\n            Pragma_Abstract_State                 |\n+           Pragma_Async_Readers                  |\n+           Pragma_Async_Writers                  |\n            Pragma_Assertion_Policy               |\n            Pragma_Assume                         |\n            Pragma_Assume_No_Invalid_Values       |\n@@ -1153,6 +1155,8 @@ begin\n            Pragma_Disable_Atomic_Synchronization |\n            Pragma_Discard_Names                  |\n            Pragma_Dispatching_Domain             |\n+           Pragma_Effective_Reads                |\n+           Pragma_Effective_Writes               |\n            Pragma_Eliminate                      |\n            Pragma_Elaborate                      |\n            Pragma_Elaborate_All                  |"}, {"sha": "1f030d9106425e2f06a0cbb678f9a4393ac4f0b0", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=6c3c671e4d2659884d01f384723910b0966d2c6d", "patch": "@@ -9840,6 +9840,16 @@ package body Sem_Ch12 is\n            (\"actual must exclude null to match generic formal#\", Actual);\n       end if;\n \n+      --  The following check is only relevant in formal verification mode as\n+      --  it is not a standard Ada legality rule. A volatile object cannot be\n+      --  used as an actual in a generic instantiation.\n+\n+      if GNATprove_Mode and then Is_Volatile_Object (Actual) then\n+         Error_Msg_N\n+           (\"volatile object cannot act as actual in generic instantiation\",\n+            Actual);\n+      end if;\n+\n       return List;\n    end Instantiate_Object;\n "}, {"sha": "f40d1cff2c77541b90599fcd4b76296dbf80e251", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 85, "deletions": 2, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=6c3c671e4d2659884d01f384723910b0966d2c6d", "patch": "@@ -91,6 +91,15 @@ package body Sem_Ch3 is\n    --  abstract interface types implemented by a record type or a derived\n    --  record type.\n \n+   procedure Analyze_Variable_Contract (Var_Id : Entity_Id);\n+   --  Analyze all delayed aspects chained on the contract of variable Var_Id\n+   --  as if they appeared at the end of the declarative region. The aspects in\n+   --  consideration are:\n+   --    Async_Readers\n+   --    Async_Writers\n+   --    Effective_Reads\n+   --    Effective_Writes\n+\n    procedure Build_Derived_Type\n      (N             : Node_Id;\n       Parent_Type   : Entity_Id;\n@@ -2353,8 +2362,9 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n-      --  Analyze the contracts of a subprogram declaration or a body now due\n-      --  to delayed visibility requirements of aspects.\n+      --  Analyze the contracts of subprogram declarations, subprogram bodies\n+      --  and variables now due to the delayed visibility requirements of their\n+      --  aspects.\n \n       Decl := First (L);\n       while Present (Decl) loop\n@@ -2363,6 +2373,11 @@ package body Sem_Ch3 is\n \n          elsif Nkind (Decl) = N_Subprogram_Declaration then\n             Analyze_Subprogram_Contract (Defining_Entity (Decl));\n+\n+         elsif Nkind (Decl) = N_Object_Declaration\n+           and then Ekind (Defining_Entity (Decl)) = E_Variable\n+         then\n+            Analyze_Variable_Contract (Defining_Entity (Decl));\n          end if;\n \n          Next (Decl);\n@@ -3698,6 +3713,8 @@ package body Sem_Ch3 is\n          if Present (E) then\n             Set_Has_Initial_Value (Id, True);\n          end if;\n+\n+         Set_Contract (Id, Make_Contract (Sloc (Id)));\n       end if;\n \n       --  Initialize alignment and size and capture alignment setting\n@@ -4769,6 +4786,72 @@ package body Sem_Ch3 is\n       end if;\n    end Analyze_Subtype_Indication;\n \n+   -------------------------------\n+   -- Analyze_Variable_Contract --\n+   -------------------------------\n+\n+   procedure Analyze_Variable_Contract (Var_Id : Entity_Id) is\n+      Items  : constant Node_Id := Contract (Var_Id);\n+      AR_Val : Boolean := False;\n+      AW_Val : Boolean := False;\n+      ER_Val : Boolean := False;\n+      EW_Val : Boolean := False;\n+      Nam    : Name_Id;\n+      Prag   : Node_Id;\n+      Seen   : Boolean := False;\n+\n+   begin\n+      --  The following check is only relevant in formal verification mode as\n+      --  it is not standard Ada legality rule. The declaration of a volatile\n+      --  variable must appear at the library level.\n+\n+      if GNATprove_Mode\n+        and then Is_Volatile_Object (Var_Id)\n+        and then not Is_Library_Level_Entity (Var_Id)\n+      then\n+         Error_Msg_N\n+           (\"volatile variable & must be declared at library level\", Var_Id);\n+      end if;\n+\n+      --  Examine the contract\n+\n+      if Present (Items) then\n+\n+         --  Analyze classification pragmas\n+\n+         Prag := Classifications (Items);\n+         while Present (Prag) loop\n+            Nam := Pragma_Name (Prag);\n+\n+            if Nam = Name_Async_Readers then\n+               Analyze_External_State_In_Decl_Part (Prag, AR_Val);\n+               Seen := True;\n+\n+            elsif Nam = Name_Async_Writers then\n+               Analyze_External_State_In_Decl_Part (Prag, AW_Val);\n+               Seen := True;\n+\n+            elsif Nam = Name_Effective_Reads then\n+               Analyze_External_State_In_Decl_Part (Prag, ER_Val);\n+               Seen := True;\n+\n+            else pragma Assert (Nam = Name_Effective_Writes);\n+               Analyze_External_State_In_Decl_Part (Prag, EW_Val);\n+               Seen := True;\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+      end if;\n+\n+      --  Once all external properties have been processed, verify their mutual\n+      --  interaction.\n+\n+      if Seen then\n+         Check_External_Properties (Var_Id, AR_Val, AW_Val, ER_Val, EW_Val);\n+      end if;\n+   end Analyze_Variable_Contract;\n+\n    --------------------------\n    -- Analyze_Variant_Part --\n    --------------------------"}, {"sha": "91efb6f930e5fa52e6253383e4f33ce43e8fcc10", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=6c3c671e4d2659884d01f384723910b0966d2c6d", "patch": "@@ -3503,7 +3503,7 @@ package body Sem_Ch6 is\n \n          --  Analyze classification pragmas\n \n-         Prag := Classifications (Contract (Subp));\n+         Prag := Classifications (Items);\n          while Present (Prag) loop\n             Nam := Pragma_Name (Prag);\n \n@@ -11117,6 +11117,18 @@ package body Sem_Ch6 is\n             Null_Exclusion_Static_Checks (Param_Spec);\n          end if;\n \n+         --  The following check is only relevant in formal verification mode\n+         --  as it is not a standard Ada legality rule. A function cannot have\n+         --  a volatile formal parameter.\n+\n+         if GNATprove_Mode\n+           and then Is_Volatile_Object (Formal)\n+           and then Ekind_In (Scope (Formal), E_Function, E_Generic_Function)\n+         then\n+            Error_Msg_N\n+              (\"function cannot have a volatile formal parameter\", Formal);\n+         end if;\n+\n       <<Continue>>\n          Next (Param_Spec);\n       end loop;"}, {"sha": "8f7eff4af686305f01c264a9078b423060c0cb9a", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 51, "deletions": 43, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=6c3c671e4d2659884d01f384723910b0966d2c6d", "patch": "@@ -227,13 +227,17 @@ package body Sem_Eval is\n    --    Is_Static_Expression flag from the operands.\n \n    procedure Test_Expression_Is_Foldable\n-     (N    : Node_Id;\n-      Op1  : Node_Id;\n-      Op2  : Node_Id;\n-      Stat : out Boolean;\n-      Fold : out Boolean);\n+     (N        : Node_Id;\n+      Op1      : Node_Id;\n+      Op2      : Node_Id;\n+      Stat     : out Boolean;\n+      Fold     : out Boolean;\n+      CRT_Safe : Boolean := False);\n    --  Same processing, except applies to an expression N with two operands\n-   --  Op1 and Op2. The result is static only if both operands are static.\n+   --  Op1 and Op2. The result is static only if both operands are static. If\n+   --  CRT_Safe is set True, then CRT_Safe_Compile_Time_Known_Value is used\n+   --  for the tests that the two operands are known at compile time. See\n+   --  spec of this routine for further details.\n \n    function Test_In_Range\n      (N            : Node_Id;\n@@ -1287,10 +1291,7 @@ package body Sem_Eval is\n    -- Compile_Time_Known_Value --\n    ------------------------------\n \n-   function Compile_Time_Known_Value\n-     (Op         : Node_Id;\n-      Ignore_CRT : Boolean := False) return Boolean\n-   is\n+   function Compile_Time_Known_Value (Op : Node_Id) return Boolean is\n       K      : constant Node_Kind := Nkind (Op);\n       CV_Ent : CV_Entry renames CV_Cache (Nat (Op) mod CV_Cache_Size);\n \n@@ -1309,31 +1310,6 @@ package body Sem_Eval is\n          return False;\n       end if;\n \n-      --  If this is not a static expression or a null literal, and we are in\n-      --  configurable run-time mode, then we consider it not known at compile\n-      --  time. This avoids anomalies where whether something is allowed with a\n-      --  given configurable run-time library depends on how good the compiler\n-      --  is at optimizing and knowing that things are constant when they are\n-      --  nonstatic. This check is suppressed if Ignore_CRT is True\n-\n-      if (Configurable_Run_Time_Mode and not Ignore_CRT)\n-        and then K /= N_Null\n-        and then not Is_Static_Expression (Op)\n-      then\n-         --  We make an exception for expressions that evaluate to True/False,\n-         --  to suppress spurious checks in ZFP mode. So far we have not seen\n-         --  any negative consequences of this exception.\n-\n-         if Is_Entity_Name (Op)\n-           and then Ekind (Entity (Op)) = E_Enumeration_Literal\n-           and then Etype (Entity (Op)) = Standard_Boolean\n-         then\n-            null;\n-         else\n-            return False;\n-         end if;\n-      end if;\n-\n       --  If we have an entity name, then see if it is the name of a constant\n       --  and if so, test the corresponding constant value, or the name of\n       --  an enumeration literal, which is always a constant.\n@@ -1487,6 +1463,21 @@ package body Sem_Eval is\n       end if;\n    end Compile_Time_Known_Value_Or_Aggr;\n \n+   ---------------------------------------\n+   -- CRT_Safe_Compile_Time_Known_Value --\n+   ---------------------------------------\n+\n+   function CRT_Safe_Compile_Time_Known_Value (Op : Node_Id) return Boolean is\n+   begin\n+      if (Configurable_Run_Time_Mode or No_Run_Time_Mode)\n+        and then not Is_OK_Static_Expression (Op)\n+      then\n+         return False;\n+      else\n+         return Compile_Time_Known_Value (Op);\n+      end if;\n+   end CRT_Safe_Compile_Time_Known_Value;\n+\n    -----------------\n    -- Eval_Actual --\n    -----------------\n@@ -1542,6 +1533,8 @@ package body Sem_Eval is\n          return;\n       end if;\n \n+      --  Otherwise attempt to fold\n+\n       if Is_Universal_Numeric_Type (Etype (Left))\n            and then\n          Is_Universal_Numeric_Type (Etype (Right))\n@@ -2537,12 +2530,19 @@ package body Sem_Eval is\n    begin\n       --  If not foldable we are done\n \n-      Test_Expression_Is_Foldable (N, Left, Right, Stat, Fold);\n+      Test_Expression_Is_Foldable\n+        (N, Left, Right, Stat, Fold, CRT_Safe => True);\n+\n+      --  Return if not foldable\n \n       if not Fold then\n          return;\n       end if;\n \n+      if Configurable_Run_Time_Mode and not Stat then\n+         return;\n+      end if;\n+\n       --  Fold exponentiation operation\n \n       declare\n@@ -5214,11 +5214,12 @@ package body Sem_Eval is\n    --  Two operand case\n \n    procedure Test_Expression_Is_Foldable\n-     (N    : Node_Id;\n-      Op1  : Node_Id;\n-      Op2  : Node_Id;\n-      Stat : out Boolean;\n-      Fold : out Boolean)\n+     (N        : Node_Id;\n+      Op1      : Node_Id;\n+      Op2      : Node_Id;\n+      Stat     : out Boolean;\n+      Fold     : out Boolean;\n+      CRT_Safe : Boolean := False)\n    is\n       Rstat : constant Boolean := Is_Static_Expression (Op1)\n                                     and then Is_Static_Expression (Op2);\n@@ -5281,8 +5282,15 @@ package body Sem_Eval is\n       elsif not Rstat then\n          Check_Non_Static_Context (Op1);\n          Check_Non_Static_Context (Op2);\n-         Fold := Compile_Time_Known_Value (Op1)\n-                   and then Compile_Time_Known_Value (Op2);\n+\n+         if CRT_Safe then\n+            Fold := CRT_Safe_Compile_Time_Known_Value (Op1)\n+                      and then CRT_Safe_Compile_Time_Known_Value (Op2);\n+         else\n+            Fold := Compile_Time_Known_Value (Op1)\n+                      and then Compile_Time_Known_Value (Op2);\n+         end if;\n+\n          return;\n \n       --  Else result is static and foldable. Both operands are static, and"}, {"sha": "aee03d9df2b08edd587eb6b24a8ff4303dd59ba9", "filename": "gcc/ada/sem_eval.ads", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsem_eval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsem_eval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.ads?ref=6c3c671e4d2659884d01f384723910b0966d2c6d", "patch": "@@ -224,23 +224,21 @@ package Sem_Eval is\n    --  Determine whether two types T1, T2, which have the same base type,\n    --  are statically matching subtypes (RM 4.9.1(1-2)).\n \n-   function Compile_Time_Known_Value\n-     (Op         : Node_Id;\n-      Ignore_CRT : Boolean := False) return Boolean;\n+   function Compile_Time_Known_Value (Op : Node_Id) return Boolean;\n    --  Returns true if Op is an expression not raising Constraint_Error whose\n    --  value is known at compile time and for which a call to Expr_Value can\n    --  be used to determine this value. This is always true if Op is a static\n    --  expression, but can also be true for expressions which are technically\n-   --  non-static but which are in fact known at compile time. Some possible\n-   --  examples of such expressions might be the static lower bound of a\n-   --  non-static range or the value of a constant object whose initial\n-   --  value is itself compile time known in the sense of this routine. Note\n-   --  that this routine is defended against unanalyzed expressions. Such\n-   --  expressions will not cause a blowup, they may cause pessimistic (i.e.\n-   --  False) results to be returned. In general we take a pessimistic view.\n-   --  False does not mean the value could not be known at compile time, but\n-   --  True means that absolutely definition it is known at compile time and\n-   --  it is safe to call Expr_Value on the expression Op.\n+   --  non-static but which are in fact known at compile time. Some examples of\n+   --  such expressions are the static lower bound of a non-static range or the\n+   --  value of a constant object whose initial value is itself compile time\n+   --  known in the sense of this routine. Note that this routine is defended\n+   --  against unanalyzed expressions. Such expressions will not cause a\n+   --  blowup, they may cause pessimistic (i.e. False) results to be returned.\n+   --  In general we take a pessimistic view. False does not mean the value\n+   --  could not be known at compile time, but True means that absolutely\n+   --  definition it is known at compile time and it is safe to call\n+   --  Expr_Value on the expression Op.\n    --\n    --  Note that we don't define precisely the set of expressions that return\n    --  True. Callers should not make any assumptions regarding the value that\n@@ -250,9 +248,11 @@ package Sem_Eval is\n    --  efficiency optimization purposes. The code generated can often be more\n    --  efficient with compile time known values, e.g. range analysis for the\n    --  purpose of removing checks is more effective if we know precise bounds.\n-   --\n-   --  The Ignore_CRT parameter has to do with the special case of configurable\n-   --  runtime mode. Consider the following example:\n+\n+   function CRT_Safe_Compile_Time_Known_Value (Op : Node_Id) return Boolean;\n+   --  In the case of configurable run-times, there may be an issue calling\n+   --  Compile_Time_Known_Value with non-static expressions where the legality\n+   --  of the program is not well-defined. Consider this example:\n    --\n    --    X := B ** C;\n    --\n@@ -266,18 +266,10 @@ package Sem_Eval is\n    --  then what we say is that exponentiation is permitted if the exponent is\n    --  officially static and has a value in the range 0 .. 4.\n    --\n-   --  However, in the normal case, we want efficient code in the case where\n-   --  a non-static exponent is known at compile time. To take care of this,\n-   --  the normal default behavior is that in configurable run-time mode most\n-   --  expressions are considered known at compile time ONLY in the case where\n-   --  they are officially static. An exception is boolean objects which may\n-   --  be considered known at compile time even in configurable run-time mode.\n-   --\n-   --  That loses optimization opportunities, and it would be better to look\n-   --  case by case at each use of Compile_Time_Known_Value to see if this\n-   --  configurable run-time mode special processing is needed. The Ignore_CRT\n-   --  parameter can be set to True to ignore this special handling in cases\n-   --  where it is known to be safe to do so.\n+   --  In a case like this, we use CRT_Safe_Compile_Time_Known_Value to avoid\n+   --  this effect. This routine will return False for a non-static expression\n+   --  if we are in configurable run-time mode, even if the expression would\n+   --  normally be considered compile-time known.\n \n    function Compile_Time_Known_Value_Or_Aggr (Op : Node_Id) return Boolean;\n    --  Similar to Compile_Time_Known_Value, but also returns True if the value"}, {"sha": "8148c4656ddd056701466e0fdf79830f99c82d49", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 436, "deletions": 113, "changes": 549, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=6c3c671e4d2659884d01f384723910b0966d2c6d", "patch": "@@ -1637,6 +1637,53 @@ package body Sem_Prag is\n       end if;\n    end Analyze_Depends_In_Decl_Part;\n \n+   -----------------------------------------\n+   -- Analyze_External_State_In_Decl_Part --\n+   -----------------------------------------\n+\n+   procedure Analyze_External_State_In_Decl_Part\n+     (N        : Node_Id;\n+      Expr_Val : out Boolean)\n+   is\n+      Arg1 : constant Node_Id := First (Pragma_Argument_Associations (N));\n+      Obj  : constant Node_Id := Get_Pragma_Arg (Arg1);\n+      Expr : constant Node_Id := Get_Pragma_Arg (Next (Arg1));\n+\n+   begin\n+      Error_Msg_Name_1 := Pragma_Name (N);\n+\n+      --  The Async / Effective pragmas must apply to a volatile object other\n+      --  than a formal subprogram parameter.\n+\n+      if Is_Volatile_Object (Obj) then\n+         if Is_Entity_Name (Obj)\n+           and then Present (Entity (Obj))\n+           and then Is_Formal (Entity (Obj))\n+         then\n+            Error_Msg_N\n+              (\"external state % cannot apply to a formal parameter\", N);\n+         end if;\n+      else\n+         Error_Msg_N (\"external state % must apply to a volatile object\", N);\n+      end if;\n+\n+      --  Ensure that the expression (if present) is static Boolean. A missing\n+      --  argument defaults the value to True.\n+\n+      Expr_Val := True;\n+\n+      if Present (Expr) then\n+         Analyze_And_Resolve (Expr, Standard_Boolean);\n+\n+         if Is_Static_Expression (Expr) then\n+            Expr_Val := Is_True (Expr_Value (Expr));\n+         else\n+            Error_Msg_Name_1 := Pragma_Name (N);\n+            Error_Msg_N (\"expression of % must be static\", Expr);\n+         end if;\n+      end if;\n+   end Analyze_External_State_In_Decl_Part;\n+\n    ---------------------------------\n    -- Analyze_Global_In_Decl_Part --\n    ---------------------------------\n@@ -1830,6 +1877,16 @@ package body Sem_Prag is\n                Check_Mode_Restriction_In_Enclosing_Context (Item, Item_Id);\n             end if;\n \n+            --  A volatile object cannot appear as a global item of a function\n+\n+            if Is_Volatile_Object (Item)\n+              and then Ekind_In (Spec_Id, E_Function, E_Generic_Function)\n+            then\n+               Error_Msg_N\n+                 (\"volatile object cannot act as global item of a function\",\n+                  Item);\n+            end if;\n+\n             --  The same entity might be referenced through various way. Check\n             --  the entity of the item rather than the item itself.\n \n@@ -9429,29 +9486,49 @@ package body Sem_Prag is\n          --  ABSTRACT_STATE_LIST ::=\n          --    null\n          --  | STATE_NAME_WITH_OPTIONS\n-         --  | (STATE_NAME_WITH_OPTIONS {, STATE_NAME_WITH_OPTIONS})\n+         --  | (STATE_NAME_WITH_OPTIONS {, STATE_NAME_WITH_OPTIONS} )\n \n          --  STATE_NAME_WITH_OPTIONS ::=\n-         --    state_NAME\n-         --  | (state_NAME with OPTION_LIST)\n+         --    STATE_NAME\n+         --  | (STATE_NAME with OPTION_LIST)\n \n          --  OPTION_LIST ::= OPTION {, OPTION}\n \n-         --  OPTION ::= SIMPLE_OPTION | NAME_VALUE_OPTION\n+         --  OPTION ::=\n+         --    SIMPLE_OPTION\n+         --  | NAME_VALUE_OPTION\n+\n+         --  SIMPLE_OPTION ::= identifier\n+\n+         --  NAME_VALUE_OPTION ::=\n+         --    Part_Of => ABSTRACT_STATE\n+         --  | External [=> EXTERNAL_PROPERTY_LIST]\n \n-         --  SIMPLE_OPTION ::=\n-         --    External | Non_Volatile | Input_Only | Output_Only\n+         --  EXTERNAL_PROPERTY_LIST ::=\n+         --    EXTERNAL_PROPERTY\n+         --  | (EXTERNAL_PROPERTY {, EXTERNAL_PROPERTY} )\n \n-         --  NAME_VALUE_OPTION ::= Part_Of => abstract_state_NAME\n+         --  EXTERNAL_PROPERTY ::=\n+         --    Async_Readers    [=> boolean_EXPRESSION]\n+         --  | Async_Writers    [=> boolean_EXPRESSION]\n+         --  | Effective_Reads  [=> boolean_EXPRESSION]\n+         --  | Effective_Writes [=> boolean_EXPRESSION]\n+\n+         --  STATE_NAME ::= defining_identifier\n+\n+         --  ABSTRACT_STATE ::= name\n \n          when Pragma_Abstract_State => Abstract_State : declare\n-            Pack_Id : Entity_Id;\n \n             --  Flags used to verify the consistency of states\n \n             Non_Null_Seen : Boolean := False;\n             Null_Seen     : Boolean := False;\n \n+            Pack_Id : Entity_Id;\n+            --  The entity of the related package when pragma Abstract_State\n+            --  appears.\n+\n             procedure Analyze_Abstract_State (State : Node_Id);\n             --  Verify the legality of a single state declaration. Create and\n             --  decorate a state abstraction entity and introduce it into the\n@@ -9462,13 +9539,201 @@ package body Sem_Prag is\n             ----------------------------\n \n             procedure Analyze_Abstract_State (State : Node_Id) is\n+\n+               --  Flags used to verify the consistency of options\n+\n+               AR_Seen       : Boolean := False;\n+               AW_Seen       : Boolean := False;\n+               ER_Seen       : Boolean := False;\n+               EW_Seen       : Boolean := False;\n+               External_Seen : Boolean := False;\n+               Part_Of_Seen  : Boolean := False;\n+\n+               --  Flags used to store the static value of all external states'\n+               --  expressions.\n+\n+               AR_Val : Boolean := False;\n+               AW_Val : Boolean := False;\n+               ER_Val : Boolean := False;\n+               EW_Val : Boolean := False;\n+\n+               procedure Analyze_External_Option (Opt : Node_Id);\n+               --  Verify the legality of option External\n+\n+               procedure Analyze_External_Property\n+                 (Prop : Node_Id;\n+                  Expr : Node_Id := Empty);\n+               --  Verify the legailty of a single external property. Prop\n+               --  denotes the external property. Expr is the expression used\n+               --  to set the property.\n+\n+               procedure Analyze_Part_Of_Option (Opt : Node_Id);\n+               --  Verify the legality of option Part_Of\n+\n                procedure Check_Duplicate_Option\n                  (Opt    : Node_Id;\n                   Status : in out Boolean);\n                --  Flag Status denotes whether a particular option has been\n                --  seen while processing a state. This routine verifies that\n                --  Opt is not a duplicate property and sets the flag Status.\n \n+               -----------------------------\n+               -- Analyze_External_Option --\n+               -----------------------------\n+\n+               procedure Analyze_External_Option (Opt : Node_Id) is\n+                  Errors : constant Nat := Serious_Errors_Detected;\n+                  Prop   : Node_Id;\n+                  Props  : Node_Id := Empty;\n+\n+               begin\n+                  Check_Duplicate_Option (Opt, External_Seen);\n+\n+                  if Nkind (Opt) = N_Component_Association then\n+                     Props := Expression (Opt);\n+                  end if;\n+\n+                  --  External state with properties\n+\n+                  if Present (Props) then\n+\n+                     --  Multiple properties appear as an aggregate\n+\n+                     if Nkind (Props) = N_Aggregate then\n+\n+                        --  Simple property form\n+\n+                        Prop := First (Expressions (Props));\n+                        while Present (Prop) loop\n+                           Analyze_External_Property (Prop);\n+                           Next (Prop);\n+                        end loop;\n+\n+                        --  Property with expression form\n+\n+                        Prop := First (Component_Associations (Props));\n+                        while Present (Prop) loop\n+                           Analyze_External_Property\n+                             (Prop => First (Choices (Prop)),\n+                              Expr => Expression (Prop));\n+\n+                           Next (Prop);\n+                        end loop;\n+\n+                     --  Single property\n+\n+                     else\n+                        Analyze_External_Property (Props);\n+                     end if;\n+\n+                  --  An external state defined without any properties defaults\n+                  --  all properties to True.\n+\n+                  else\n+                     AR_Val := True;\n+                     AW_Val := True;\n+                     ER_Val := True;\n+                     EW_Val := True;\n+                  end if;\n+\n+                  --  Once all external properties have been processed, verify\n+                  --  their mutual interaction. Do not perform the check when\n+                  --  at least one of the properties is illegal as this will\n+                  --  produce a bogus error.\n+\n+                  if Errors = Serious_Errors_Detected then\n+                     Check_External_Properties\n+                       (State, AR_Val, AW_Val, ER_Val, EW_Val);\n+                  end if;\n+               end Analyze_External_Option;\n+\n+               -------------------------------\n+               -- Analyze_External_Property --\n+               -------------------------------\n+\n+               procedure Analyze_External_Property\n+                 (Prop : Node_Id;\n+                  Expr : Node_Id := Empty)\n+               is\n+                  Expr_Val : Boolean;\n+\n+               begin\n+                  --  The external property must be one of the predefined four\n+                  --  reader / writer choices.\n+\n+                  if Nkind (Prop) /= N_Identifier\n+                    or else not Nam_In (Chars (Prop), Name_Async_Readers,\n+                                                      Name_Async_Writers,\n+                                                      Name_Effective_Reads,\n+                                                      Name_Effective_Writes)\n+                  then\n+                     Error_Msg_N (\"invalid external state property\", Prop);\n+                     return;\n+                  end if;\n+\n+                  --  Ensure that the expression of the external state property\n+                  --  is static Boolean (if applicable).\n+\n+                  if Present (Expr) then\n+                     Analyze_And_Resolve (Expr, Standard_Boolean);\n+\n+                     if Is_Static_Expression (Expr) then\n+                        Expr_Val := Is_True (Expr_Value (Expr));\n+                     else\n+                        Error_Msg_N\n+                          (\"expression of external state property must be \"\n+                           & \"static\", Expr);\n+                     end if;\n+\n+                  --  The lack of expression defaults the property to True\n+\n+                  else\n+                     Expr_Val := True;\n+                  end if;\n+\n+                  if Chars (Prop) = Name_Async_Readers then\n+                     Check_Duplicate_Option (Prop, AR_Seen);\n+                     AR_Val := Expr_Val;\n+\n+                  elsif Chars (Prop) = Name_Async_Writers then\n+                     Check_Duplicate_Option (Prop, AW_Seen);\n+                     AW_Val := Expr_Val;\n+\n+                  elsif Chars (Prop) = Name_Effective_Reads then\n+                     Check_Duplicate_Option (Prop, ER_Seen);\n+                     ER_Val := Expr_Val;\n+\n+                  else\n+                     Check_Duplicate_Option (Prop, EW_Seen);\n+                     EW_Val := Expr_Val;\n+                  end if;\n+               end Analyze_External_Property;\n+\n+               ----------------------------\n+               -- Analyze_Part_Of_Option --\n+               ----------------------------\n+\n+               procedure Analyze_Part_Of_Option (Opt : Node_Id) is\n+                  Par_State : constant Node_Id := Expression (Opt);\n+\n+               begin\n+                  Check_Duplicate_Option (Opt, Part_Of_Seen);\n+\n+                  Analyze (Par_State);\n+\n+                  --  The expression of option Part_Of must denote an abstract\n+                  --  state.\n+\n+                  if not Is_Entity_Name (Par_State)\n+                    or else No (Entity (Par_State))\n+                    or else Ekind (Entity (Par_State)) /= E_Abstract_State\n+                  then\n+                     Error_Msg_N\n+                       (\"option Part_Of must denote an abstract state\",\n+                        Par_State);\n+                  end if;\n+               end Analyze_Part_Of_Option;\n+\n                ----------------------------\n                -- Check_Duplicate_Option --\n                ----------------------------\n@@ -9489,20 +9754,11 @@ package body Sem_Prag is\n \n                Errors    : constant Nat := Serious_Errors_Detected;\n                Loc       : constant Source_Ptr := Sloc (State);\n-               Assoc     : Node_Id;\n-               Id        : Entity_Id;\n                Is_Null   : Boolean := False;\n-               Name      : Name_Id;\n                Opt       : Node_Id;\n-               Par_State : Node_Id;\n-\n-               --  Flags used to verify the consistency of options\n-\n-               External_Seen     : Boolean := False;\n-               Input_Seen        : Boolean := False;\n-               Non_Volatile_Seen : Boolean := False;\n-               Output_Seen       : Boolean := False;\n-               Part_Of_Seen      : Boolean := False;\n+               Opt_Nam   : Node_Id;\n+               State_Id  : Entity_Id;\n+               State_Nam : Name_Id;\n \n             --  Start of processing for Analyze_Abstract_State\n \n@@ -9517,7 +9773,7 @@ package body Sem_Prag is\n                --  Null states appear as internally generated entities\n \n                elsif Nkind (State) = N_Null then\n-                  Name := New_Internal_Name ('S');\n+                  State_Nam := New_Internal_Name ('S');\n                   Is_Null   := True;\n                   Null_Seen := True;\n \n@@ -9533,117 +9789,63 @@ package body Sem_Prag is\n                --  Simple state declaration\n \n                elsif Nkind (State) = N_Identifier then\n-                  Name := Chars (State);\n+                  State_Nam     := Chars (State);\n                   Non_Null_Seen := True;\n \n                --  State declaration with various options. This construct\n                --  appears as an extension aggregate in the tree.\n \n                elsif Nkind (State) = N_Extension_Aggregate then\n                   if Nkind (Ancestor_Part (State)) = N_Identifier then\n-                     Name := Chars (Ancestor_Part (State));\n+                     State_Nam     := Chars (Ancestor_Part (State));\n                      Non_Null_Seen := True;\n                   else\n                      Error_Msg_N\n                        (\"state name must be an identifier\",\n                         Ancestor_Part (State));\n                   end if;\n \n-                  --  Process options External, Input_Only, Output_Only and\n-                  --  Volatile. Ensure that none of them appear more than once.\n+                  --  Catch an attempt to introduce a simple option which is\n+                  --  currently not allowed. An exception to this is External\n+                  --  defined without any properties.\n \n                   Opt := First (Expressions (State));\n                   while Present (Opt) loop\n-                     if Nkind (Opt) = N_Identifier then\n-                        if Chars (Opt) = Name_External then\n-                           Check_Duplicate_Option (Opt, External_Seen);\n-                        elsif Chars (Opt) = Name_Input_Only then\n-                           Check_Duplicate_Option (Opt, Input_Seen);\n-                        elsif Chars (Opt) = Name_Output_Only then\n-                           Check_Duplicate_Option (Opt, Output_Seen);\n-                        elsif Chars (Opt) = Name_Non_Volatile then\n-                           Check_Duplicate_Option (Opt, Non_Volatile_Seen);\n-\n-                        --  Ensure that the abstract state component of option\n-                        --  Part_Of has not been omitted.\n-\n-                        elsif Chars (Opt) = Name_Part_Of then\n-                           Error_Msg_N\n-                             (\"option Part_Of requires an abstract state\",\n-                              Opt);\n-                        else\n-                           Error_Msg_N (\"invalid state option\", Opt);\n-                        end if;\n+                     if Nkind (Opt) = N_Identifier\n+                       and then Chars (Opt) = Name_External\n+                     then\n+                        Analyze_External_Option (Opt);\n                      else\n-                        Error_Msg_N (\"invalid state option\", Opt);\n+                        Error_Msg_N\n+                          (\"simple option not allowed in state declaration\",\n+                           Opt);\n                      end if;\n \n                      Next (Opt);\n                   end loop;\n \n-                  --  External may appear on its own or with exactly one option\n-                  --  Input_Only or Output_Only, but not both.\n-\n-                  if External_Seen\n-                    and then Input_Seen\n-                    and then Output_Seen\n-                  then\n-                     Error_Msg_N\n-                       (\"option External requires exactly one option \"\n-                        & \"Input_Only or Output_Only\", State);\n-                  end if;\n+                  --  Options External and Part_Of appear as component\n+                  --  associations.\n \n-                  --  Either Input_Only or Output_Only require External\n+                  Opt := First (Component_Associations (State));\n+                  while Present (Opt) loop\n+                     Opt_Nam := First (Choices (Opt));\n \n-                  if (Input_Seen or Output_Seen)\n-                    and then not External_Seen\n-                  then\n-                     Error_Msg_N\n-                       (\"options Input_Only and Output_Only require option \"\n-                        & \"External\", State);\n-                  end if;\n+                     if Nkind (Opt_Nam) = N_Identifier then\n+                        if Chars (Opt_Nam) = Name_External then\n+                           Analyze_External_Option (Opt);\n \n-                  --  Option Part_Of appears as a component association\n+                        elsif Chars (Opt_Nam) = Name_Part_Of then\n+                           Analyze_Part_Of_Option (Opt);\n \n-                  Assoc := First (Component_Associations (State));\n-                  while Present (Assoc) loop\n-                     Opt := First (Choices (Assoc));\n-                     while Present (Opt) loop\n-                        if Nkind (Opt) = N_Identifier\n-                          and then Chars (Opt) = Name_Part_Of\n-                        then\n-                           Check_Duplicate_Option (Opt, Part_Of_Seen);\n                         else\n                            Error_Msg_N (\"invalid state option\", Opt);\n                         end if;\n-\n-                        Next (Opt);\n-                     end loop;\n-\n-                     --  Part_Of must denote a parent state. Ensure that the\n-                     --  tree is not malformed by checking the expression of\n-                     --  the component association.\n-\n-                     Par_State := Expression (Assoc);\n-                     pragma Assert (Present (Par_State));\n-\n-                     Analyze (Par_State);\n-\n-                     --  Part_Of specified a legal state, this automatically\n-                     --  makes the state a constituent.\n-\n-                     if Is_Entity_Name (Par_State)\n-                       and then Present (Entity (Par_State))\n-                       and then Ekind (Entity (Par_State)) = E_Abstract_State\n-                     then\n-                        null;\n                      else\n-                        Error_Msg_N\n-                         (\"option Part_Of must denote an abstract state\",\n-                          Par_State);\n+                        Error_Msg_N (\"invalid state option\", Opt);\n                      end if;\n \n-                     Next (Assoc);\n+                     Next (Opt);\n                   end loop;\n \n                --  Any other attempt to declare a state is erroneous\n@@ -9662,35 +9864,37 @@ package body Sem_Prag is\n                --  The generated state abstraction reuses the same characters\n                --  from the original state declaration. Decorate the entity.\n \n-               Id := Make_Defining_Identifier (Loc, New_External_Name (Name));\n-               Set_Comes_From_Source       (Id, not Is_Null);\n-               Set_Parent                  (Id, State);\n-               Set_Ekind                   (Id, E_Abstract_State);\n-               Set_Etype                   (Id, Standard_Void_Type);\n-               Set_Refined_State           (Id, Empty);\n-               Set_Refinement_Constituents (Id, New_Elmt_List);\n+               State_Id :=\n+                 Make_Defining_Identifier (Loc, New_External_Name (State_Nam));\n+\n+               Set_Comes_From_Source       (State_Id, not Is_Null);\n+               Set_Parent                  (State_Id, State);\n+               Set_Ekind                   (State_Id, E_Abstract_State);\n+               Set_Etype                   (State_Id, Standard_Void_Type);\n+               Set_Refined_State           (State_Id, Empty);\n+               Set_Refinement_Constituents (State_Id, New_Elmt_List);\n \n                --  Every non-null state must be nameable and resolvable the\n                --  same way a constant is.\n \n                if not Is_Null then\n                   Push_Scope (Pack_Id);\n-                  Enter_Name (Id);\n+                  Enter_Name (State_Id);\n                   Pop_Scope;\n                end if;\n \n                --  Verify whether the state introduces an illegal hidden state\n                --  within a package subject to a null abstract state.\n \n-               Check_No_Hidden_State (Id);\n+               Check_No_Hidden_State (State_Id);\n \n                --  Associate the state with its related package\n \n                if No (Abstract_States (Pack_Id)) then\n                   Set_Abstract_States (Pack_Id, New_Elmt_List);\n                end if;\n \n-               Append_Elmt (Id, Abstract_States (Pack_Id));\n+               Append_Elmt (State_Id, Abstract_States (Pack_Id));\n             end Analyze_Abstract_State;\n \n             --  Local variables\n@@ -9733,7 +9937,6 @@ package body Sem_Prag is\n                State := First (Expressions (State));\n                while Present (State) loop\n                   Analyze_Abstract_State (State);\n-\n                   Next (State);\n                end loop;\n \n@@ -10455,6 +10658,73 @@ package body Sem_Prag is\n             end if;\n          end AST_Entry;\n \n+         ------------------------------------------------------------------\n+         -- Async_Readers/Async_Writers/Effective_Reads/Effective_Writes --\n+         ------------------------------------------------------------------\n+\n+         --  pragma Asynch_Readers   ( identifier [, boolean_EXPRESSION] );\n+         --  pragma Asynch_Writers   ( identifier [, boolean_EXPRESSION] );\n+         --  pragma Effective_Reads  ( identifier [, boolean_EXPRESSION] );\n+         --  pragma Effective_Writes ( identifier [, boolean_EXPRESSION] );\n+\n+         when Pragma_Async_Readers    |\n+              Pragma_Async_Writers    |\n+              Pragma_Effective_Reads  |\n+              Pragma_Effective_Writes =>\n+         Async_Effective : declare\n+            Duplic : Node_Id;\n+            Obj_Id : Entity_Id;\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_No_Identifiers;\n+            Check_At_Least_N_Arguments (1);\n+            Check_At_Most_N_Arguments  (2);\n+            Check_Arg_Is_Local_Name (Arg1);\n+\n+            Arg1 := Get_Pragma_Arg (Arg1);\n+\n+            --  Perform minimal verification to ensure that the argument is at\n+            --  least a variable. Subsequent finer grained checks will be done\n+            --  at the end of the declarative region the contains the pragma.\n+\n+            if Is_Entity_Name (Arg1) and then Present (Entity (Arg1)) then\n+               Obj_Id := Entity (Get_Pragma_Arg (Arg1));\n+\n+               --  It is not efficient to examine preceding statements in order\n+               --  to detect duplicate pragmas as Boolean aspects may appear\n+               --  anywhere between the related object declaration and its\n+               --  freeze point. As an alternative, inspect the contents of the\n+               --  variable contract.\n+\n+               if Ekind (Obj_Id) = E_Variable then\n+                  Duplic := Get_Pragma (Obj_Id, Prag_Id);\n+\n+                  if Present (Duplic) then\n+                     Error_Msg_Name_1 := Pname;\n+                     Error_Msg_Sloc   := Sloc (Duplic);\n+                     Error_Msg_N (\"pragma % duplicates pragma declared #\", N);\n+\n+                  --  Chain the pragma on the contract for further processing.\n+                  --  This also aids in detecting duplicates.\n+\n+                  else\n+                     Add_Contract_Item (N, Obj_Id);\n+                  end if;\n+\n+                  --  The minimum legality requirements have been met, do not\n+                  --  fall through to the error message.\n+\n+                  return;\n+               end if;\n+            end if;\n+\n+            --  If we get here, then the pragma applies to a non-object\n+            --  construct, issue a generic error.\n+\n+            Error_Pragma (\"pragma % must apply to a volatile object\");\n+         end Async_Effective;\n+\n          ------------------\n          -- Asynchronous --\n          ------------------\n@@ -18208,7 +18478,6 @@ package body Sem_Prag is\n                      Set_SPARK_Pragma_Inherited     (Spec_Id, False);\n                      Set_SPARK_Aux_Pragma           (Spec_Id, N);\n                      Set_SPARK_Aux_Pragma_Inherited (Spec_Id, True);\n-\n                      return;\n \n                   --  The pragma applies to a subprogram declaration\n@@ -22244,6 +22513,56 @@ package body Sem_Prag is\n       return False;\n    end Appears_In;\n \n+   -------------------------------\n+   -- Check_External_Properties --\n+   -------------------------------\n+\n+   procedure Check_External_Properties\n+     (Item : Node_Id;\n+      AR   : Boolean;\n+      AW   : Boolean;\n+      ER   : Boolean;\n+      EW   : Boolean)\n+   is\n+   begin\n+      --  All properties enabled\n+\n+      if AR and then AW and then ER and then EW then\n+         null;\n+\n+      --  Async_Readers + Effective_Writes\n+      --  Async_Readers + Async_Writers + Effective_Writes\n+\n+      elsif AR and then EW and then not ER then\n+         null;\n+\n+      --  Async_Writers + Effective_Reads\n+      --  Async_Readers + Async_Writers + Effective_Reads\n+\n+      elsif AW and then ER and then not EW then\n+         null;\n+\n+      --  Async_Readers + Async_Writers\n+\n+      elsif AR and then AW and then not ER and then not EW then\n+         null;\n+\n+      --  Async_Readers\n+\n+      elsif AR and then not AW and then not ER and then not EW then\n+         null;\n+\n+      --  Async_Writers\n+\n+      elsif AW and then not AR and then not ER and then not EW then\n+         null;\n+\n+      else\n+         Error_Msg_N\n+           (\"illegal combination of external state properties\", Item);\n+      end if;\n+   end Check_External_Properties;\n+\n    ----------------\n    -- Check_Kind --\n    ----------------\n@@ -22995,18 +23314,20 @@ package body Sem_Prag is\n       Pragma_Ada_12                         => -1,\n       Pragma_Ada_2012                       => -1,\n       Pragma_All_Calls_Remote               => -1,\n-      Pragma_Allow_Integer_Address          => 0,\n+      Pragma_Allow_Integer_Address          =>  0,\n       Pragma_Annotate                       => -1,\n       Pragma_Assert                         => -1,\n       Pragma_Assert_And_Cut                 => -1,\n       Pragma_Assertion_Policy               =>  0,\n       Pragma_Assume                         => -1,\n       Pragma_Assume_No_Invalid_Values       =>  0,\n-      Pragma_Attribute_Definition           => +3,\n+      Pragma_Async_Readers                  =>  0,\n+      Pragma_Async_Writers                  =>  0,\n       Pragma_Asynchronous                   => -1,\n       Pragma_Atomic                         =>  0,\n       Pragma_Atomic_Components              =>  0,\n       Pragma_Attach_Handler                 => -1,\n+      Pragma_Attribute_Definition           => +3,\n       Pragma_Check                          => 99,\n       Pragma_Check_Float_Overflow           =>  0,\n       Pragma_Check_Name                     =>  0,\n@@ -23038,6 +23359,8 @@ package body Sem_Prag is\n       Pragma_Disable_Atomic_Synchronization => -1,\n       Pragma_Discard_Names                  =>  0,\n       Pragma_Dispatching_Domain             => -1,\n+      Pragma_Effective_Reads                =>  0,\n+      Pragma_Effective_Writes               =>  0,\n       Pragma_Elaborate                      => -1,\n       Pragma_Elaborate_All                  => -1,\n       Pragma_Elaborate_Body                 => -1,"}, {"sha": "bb57d997740a299b558993da14fba679f24aba85", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=6c3c671e4d2659884d01f384723910b0966d2c6d", "patch": "@@ -60,6 +60,13 @@ package Sem_Prag is\n    --  Perform full analysis of delayed pragma Depends. This routine is also\n    --  capable of performing basic analysis of pragma Refined_Depends.\n \n+   procedure Analyze_External_State_In_Decl_Part\n+     (N        : Node_Id;\n+      Expr_Val : out Boolean);\n+   --  Perform full analysis of delayed pragmas Async_Readers, Async_Writers,\n+   --  Effective_Reads and Effective_Writes. Flag Expr_Val contains the Boolean\n+   --  argument of the pragma or a default True if no argument is present.\n+\n    procedure Analyze_Global_In_Decl_Part (N : Node_Id);\n    --  Perform full analysis of delayed pragma Global. This routine is also\n    --  capable of performing basic analysis of pragma Refind_Global.\n@@ -121,6 +128,17 @@ package Sem_Prag is\n    --  whether -gnata was used, if so, then the call has no effect, otherwise\n    --  Is_Ignored (but not Is_Disabled) is set True.\n \n+   procedure Check_External_Properties\n+     (Item : Node_Id;\n+      AR   : Boolean;\n+      AW   : Boolean;\n+      ER   : Boolean;\n+      EW   : Boolean);\n+   --  Flags AR, AW, ER and EW denote the static values of external properties\n+   --  Async_Readers, Async_Writers, Effective_Reads and Effective_Writes. Item\n+   --  is the related variable or state. Ensure the legality of the permutation\n+   --  and if this is not the case, issue an error.\n+\n    function Delay_Config_Pragma_Analyze (N : Node_Id) return Boolean;\n    --  N is a pragma appearing in a configuration pragma file. Most such\n    --  pragmas are analyzed when the file is read, before parsing and analyzing"}, {"sha": "e86ca319c7c49feea42c106912cd1867addc56e9", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 98, "deletions": 1, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=6c3c671e4d2659884d01f384723910b0966d2c6d", "patch": "@@ -4249,6 +4249,32 @@ package body Sem_Res is\n                Check_Unset_Reference (A);\n             end if;\n \n+            --  The following checks are only relevant in formal verification\n+            --  mode as they are not standard Ada legality rule.\n+\n+            if GNATprove_Mode\n+              and then Is_Volatile_Object (A)\n+            then\n+               --  A volatile object may act as an actual parameter when the\n+               --  corresponding formal is of a non-scalar volatile type.\n+\n+               if Is_Volatile (Etype (F))\n+                 and then not Is_Scalar_Type (Etype (F))\n+               then\n+                  null;\n+\n+               --  A volatile object may act as an actual parameter in a call\n+               --  to an instance of Unchecked_Conversion.\n+\n+               elsif Is_Unchecked_Conversion_Instance (Nam) then\n+                  null;\n+\n+               else\n+                  Error_Msg_N\n+                    (\"volatile object cannot act as actual in a call\", A);\n+               end if;\n+            end if;\n+\n             Next_Actual (A);\n \n          --  Case where actual is not present\n@@ -6322,7 +6348,12 @@ package body Sem_Res is\n    --  Used to resolve identifiers and expanded names\n \n    procedure Resolve_Entity_Name (N : Node_Id; Typ : Entity_Id) is\n-      E : constant Entity_Id := Entity (N);\n+      E    : constant Entity_Id := Entity (N);\n+      Par  : Node_Id;\n+      Prev : Node_Id;\n+\n+      Usage_OK : Boolean := False;\n+      --  Flag set when the use of a volatile object agrees with its context\n \n    begin\n       --  If garbage from errors, set to Any_Type and return\n@@ -6425,6 +6456,72 @@ package body Sem_Res is\n \n          Eval_Entity_Name (N);\n       end if;\n+\n+      --  The following checks are only relevant in formal verification mode as\n+      --  they are not standard Ada legality rule. A volatile object subject to\n+      --  enabled properties Async_Writers or Effective_Reads must appear in a\n+      --  specific context.\n+\n+      if GNATprove_Mode\n+        and then Ekind (E) = E_Variable\n+        and then Is_Volatile_Object (E)\n+        and then\n+          (Async_Writers_Enabled (E)\n+             or else Effective_Reads_Enabled (E))\n+      then\n+         Par  := Parent (N);\n+         Prev := N;\n+         while Present (Par) loop\n+\n+            --  The variable can appear on either side of an assignment\n+\n+            if Nkind (Par) = N_Assignment_Statement then\n+               Usage_OK := True;\n+               exit;\n+\n+            --  The variable is part of the initialization expression of an\n+            --  object. Ensure that the climb of the parent chain came from the\n+            --  expression side and not from the name side.\n+\n+            elsif Nkind (Par) = N_Object_Declaration\n+              and then Present (Expression (Par))\n+              and then Prev = Expression (Par)\n+            then\n+               Usage_OK := True;\n+               exit;\n+\n+            --  The variable appears as an actual parameter in a call to an\n+            --  instance of Unchecked_Conversion whose result is renamed.\n+\n+            elsif Nkind (Par) = N_Function_Call\n+              and then Is_Unchecked_Conversion_Instance (Entity (Name (Par)))\n+              and then Nkind (Parent (Par)) = N_Object_Renaming_Declaration\n+            then\n+               Usage_OK := True;\n+               exit;\n+\n+            --  Assume that references to volatile objects that appear as\n+            --  actual parameters in a procedure call are always legal. The\n+            --  full legality check is done when the actuals are resolved.\n+\n+            elsif Nkind (Par) = N_Procedure_Call_Statement then\n+               Usage_OK := True;\n+               exit;\n+\n+            --  Prevent the search from going too far\n+\n+            elsif Is_Body_Or_Package_Declaration (Par) then\n+               exit;\n+            end if;\n+\n+            Prev := Par;\n+            Par  := Parent (Par);\n+         end loop;\n+\n+         if not Usage_OK then\n+            Error_Msg_N (\"volatile object cannot appear in this context\", N);\n+         end if;\n+      end if;\n    end Resolve_Entity_Name;\n \n    -------------------"}, {"sha": "6ba2a16e8d86fc30c8d7558d1c4b8ec1704d1883", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 201, "deletions": 4, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=6c3c671e4d2659884d01f384723910b0966d2c6d", "patch": "@@ -113,6 +113,13 @@ package body Sem_Util is\n    --  components in the selected variant to determine whether all of them\n    --  have a default.\n \n+   function Has_Enabled_Property\n+     (Extern   : Node_Id;\n+      Prop_Nam : Name_Id) return Boolean;\n+   --  Subsidiary to routines Async_xxx_Enabled and Effective_xxx_Enabled.\n+   --  Given pragma External, determine whether it contains a property denoted\n+   --  by its name Prop_Nam and if it does, whether its expression is True.\n+\n    function Has_Null_Extension (T : Entity_Id) return Boolean;\n    --  T is a derived tagged type. Check whether the type extension is null.\n    --  If the parent type is fully initialized, T can be treated as such.\n@@ -339,6 +346,27 @@ package body Sem_Util is\n \n          --  The pragma is not a proper contract item\n \n+         else\n+            raise Program_Error;\n+         end if;\n+\n+      --  Contract items related to variables. The applicable pragmas are:\n+      --    Async_Readers\n+      --    Async_Writers\n+      --    Effective_Reads\n+      --    Effective_Writes\n+\n+      elsif Ekind (Id) = E_Variable then\n+         if Nam_In (Nam, Name_Async_Readers,\n+                         Name_Async_Writers,\n+                         Name_Effective_Reads,\n+                         Name_Effective_Writes)\n+         then\n+            Set_Next_Pragma (Prag, Classifications (Items));\n+            Set_Classifications (Items, Prag);\n+\n+         --  The pragma is not a proper contract item\n+\n          else\n             raise Program_Error;\n          end if;\n@@ -525,6 +553,40 @@ package body Sem_Util is\n       end if;\n    end Apply_Compile_Time_Constraint_Error;\n \n+   ---------------------------\n+   -- Async_Readers_Enabled --\n+   ---------------------------\n+\n+   function Async_Readers_Enabled (Id : Entity_Id) return Boolean is\n+   begin\n+      if Ekind (Id) = E_Abstract_State then\n+         return\n+           Has_Enabled_Property\n+             (Extern   => Get_Pragma (Id, Pragma_External),\n+              Prop_Nam => Name_Async_Readers);\n+\n+      else pragma Assert (Ekind (Id) = E_Variable);\n+         return Present (Get_Pragma (Id, Pragma_Async_Readers));\n+      end if;\n+   end Async_Readers_Enabled;\n+\n+   ---------------------------\n+   -- Async_Writers_Enabled --\n+   ---------------------------\n+\n+   function Async_Writers_Enabled (Id : Entity_Id) return Boolean is\n+   begin\n+      if Ekind (Id) = E_Abstract_State then\n+         return\n+           Has_Enabled_Property\n+             (Extern   => Get_Pragma (Id, Pragma_External),\n+              Prop_Nam => Name_Async_Writers);\n+\n+      else pragma Assert (Ekind (Id) = E_Variable);\n+         return Present (Get_Pragma (Id, Pragma_Async_Writers));\n+      end if;\n+   end Async_Writers_Enabled;\n+\n    --------------------------------------\n    -- Available_Full_View_Of_Component --\n    --------------------------------------\n@@ -4730,6 +4792,40 @@ package body Sem_Util is\n       end if;\n    end Effective_Extra_Accessibility;\n \n+   -----------------------------\n+   -- Effective_Reads_Enabled --\n+   -----------------------------\n+\n+   function Effective_Reads_Enabled (Id : Entity_Id) return Boolean is\n+   begin\n+      if Ekind (Id) = E_Abstract_State then\n+         return\n+           Has_Enabled_Property\n+             (Extern   => Get_Pragma (Id, Pragma_External),\n+              Prop_Nam => Name_Effective_Reads);\n+\n+      else pragma Assert (Ekind (Id) = E_Variable);\n+         return Present (Get_Pragma (Id, Pragma_Effective_Reads));\n+      end if;\n+   end Effective_Reads_Enabled;\n+\n+   ------------------------------\n+   -- Effective_Writes_Enabled --\n+   ------------------------------\n+\n+   function Effective_Writes_Enabled (Id : Entity_Id) return Boolean is\n+   begin\n+      if Ekind (Id) = E_Abstract_State then\n+         return\n+           Has_Enabled_Property\n+             (Extern   => Get_Pragma (Id, Pragma_External),\n+              Prop_Nam => Name_Effective_Writes);\n+\n+      else pragma Assert (Ekind (Id) = E_Variable);\n+         return Present (Get_Pragma (Id, Pragma_Effective_Writes));\n+      end if;\n+   end Effective_Writes_Enabled;\n+\n    ------------------------------\n    -- Enclosing_Comp_Unit_Node --\n    ------------------------------\n@@ -7062,6 +7158,76 @@ package body Sem_Util is\n       return False;\n    end Has_Discriminant_Dependent_Constraint;\n \n+   --------------------------\n+   -- Has_Enabled_Property --\n+   --------------------------\n+\n+   function Has_Enabled_Property\n+     (Extern   : Node_Id;\n+      Prop_Nam : Name_Id) return Boolean\n+   is\n+      Prop  : Node_Id;\n+      Props : Node_Id := Empty;\n+\n+   begin\n+      --  The related abstract state or variable do not have an Extern pragma,\n+      --  the property in question cannot be set.\n+\n+      if No (Extern) then\n+         return False;\n+\n+      elsif Nkind (Extern) = N_Component_Association then\n+         Props := Expression (Extern);\n+      end if;\n+\n+      --  External state with properties\n+\n+      if Present (Props) then\n+\n+         --  Multiple properties appear as an aggregate\n+\n+         if Nkind (Props) = N_Aggregate then\n+\n+            --  Simple property form\n+\n+            Prop := First (Expressions (Props));\n+            while Present (Prop) loop\n+               if Chars (Prop) = Prop_Nam then\n+                  return True;\n+               end if;\n+\n+               Next (Prop);\n+            end loop;\n+\n+            --  Property with expression form\n+\n+            Prop := First (Component_Associations (Props));\n+            while Present (Prop) loop\n+               if Chars (Prop) = Prop_Nam then\n+                  return Is_True (Expr_Value (Expression (Prop)));\n+               end if;\n+\n+               Next (Prop);\n+            end loop;\n+\n+            --  Pragma Extern contains properties, but not the one we want\n+\n+            return False;\n+\n+         --  Single property\n+\n+         else\n+            return Chars (Prop) = Prop_Nam;\n+         end if;\n+\n+      --  An external state defined without any properties defaults all\n+      --  properties to True;\n+\n+      else\n+         return True;\n+      end if;\n+   end Has_Enabled_Property;\n+\n    --------------------\n    -- Has_Infinities --\n    --------------------\n@@ -10669,6 +10835,31 @@ package body Sem_Util is\n       return (U /= 0);\n    end Is_True;\n \n+   --------------------------------------\n+   -- Is_Unchecked_Conversion_Instance --\n+   --------------------------------------\n+\n+   function Is_Unchecked_Conversion_Instance (Id : Entity_Id) return Boolean is\n+      Gen_Par : Entity_Id;\n+\n+   begin\n+      --  Look for a function whose generic parent is the predefined intrinsic\n+      --  function Unchecked_Conversion.\n+\n+      if Ekind (Id) = E_Function then\n+         Gen_Par := Generic_Parent (Parent (Id));\n+\n+         return\n+           Present (Gen_Par)\n+             and then Chars (Gen_Par) = Name_Unchecked_Conversion\n+             and then Is_Intrinsic_Subprogram (Gen_Par)\n+             and then Is_Predefined_File_Name\n+                        (Unit_File_Name (Get_Source_Unit (Gen_Par)));\n+      end if;\n+\n+      return False;\n+   end Is_Unchecked_Conversion_Instance;\n+\n    -------------------------------\n    -- Is_Universal_Numeric_Type --\n    -------------------------------\n@@ -11017,12 +11208,12 @@ package body Sem_Util is\n \n    function Is_Volatile_Object (N : Node_Id) return Boolean is\n \n-      function Object_Has_Volatile_Components (N : Node_Id) return Boolean;\n-      --  Determines if given object has volatile components\n-\n       function Is_Volatile_Prefix (N : Node_Id) return Boolean;\n       --  If prefix is an implicit dereference, examine designated type\n \n+      function Object_Has_Volatile_Components (N : Node_Id) return Boolean;\n+      --  Determines if given object has volatile components\n+\n       ------------------------\n       -- Is_Volatile_Prefix --\n       ------------------------\n@@ -11077,7 +11268,13 @@ package body Sem_Util is\n    --  Start of processing for Is_Volatile_Object\n \n    begin\n-      if Is_Volatile (Etype (N))\n+      if Nkind (N) = N_Defining_Identifier then\n+         return Is_Volatile (N) or else Is_Volatile (Etype (N));\n+\n+      elsif Nkind (N) = N_Expanded_Name then\n+         return Is_Volatile_Object (Entity (N));\n+\n+      elsif Is_Volatile (Etype (N))\n         or else (Is_Entity_Name (N) and then Is_Volatile (Entity (N)))\n       then\n          return True;"}, {"sha": "ba76ca680a203fdf2e1cdf4ce371e02c8fabd257", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=6c3c671e4d2659884d01f384723910b0966d2c6d", "patch": "@@ -47,8 +47,12 @@ package Sem_Util is\n    --  Add pragma Prag to the contract of an entry, a package [body] or a\n    --  subprogram [body] denoted by Id. The following are valid pragmas:\n    --    Abstract_States\n+   --    Async_Readers\n+   --    Async_Writers\n    --    Contract_Cases\n    --    Depends\n+   --    Effective_Reads\n+   --    Effective_Writes\n    --    Global\n    --    Initial_Condition\n    --    Initializes\n@@ -120,6 +124,16 @@ package Sem_Util is\n    --  not end with a ? (this is used when the caller wants to parameterize\n    --  whether an error or warning is given.\n \n+   function Async_Readers_Enabled (Id : Entity_Id) return Boolean;\n+   --  Given the entity of an abstract state or a variable, determine whether\n+   --  Id is subject to external property Async_Readers and if it is, the\n+   --  related expression evaluates to True.\n+\n+   function Async_Writers_Enabled (Id : Entity_Id) return Boolean;\n+   --  Given the entity of an abstract state or a variable, determine whether\n+   --  Id is subject to external property Async_Writers and if it is, the\n+   --  related expression evaluates to True.\n+\n    function Available_Full_View_Of_Component (T : Entity_Id) return Boolean;\n    --  If at the point of declaration an array type has a private or limited\n    --  component, several array operations are not avaiable on the type, and\n@@ -485,6 +499,16 @@ package Sem_Util is\n    --  Same as Einfo.Extra_Accessibility except thtat object renames\n    --  are looked through.\n \n+   function Effective_Reads_Enabled (Id : Entity_Id) return Boolean;\n+   --  Given the entity of an abstract state or a variable, determine whether\n+   --  Id is subject to external property Effective_Reads and if it is, the\n+   --  related expression evaluates to True.\n+\n+   function Effective_Writes_Enabled (Id : Entity_Id) return Boolean;\n+   --  Given the entity of an abstract state or a variable, determine whether\n+   --  Id is subject to external property Effective_Writes and if it is, the\n+   --  related expression evaluates to True.\n+\n    function Enclosing_Comp_Unit_Node (N : Node_Id) return Node_Id;\n    --  Returns the enclosing N_Compilation_Unit Node that is the root of a\n    --  subtree containing N.\n@@ -1164,6 +1188,10 @@ package Sem_Util is\n    --  operand (i.e. is either 0 for False, or 1 for True). This function tests\n    --  if it is True (i.e. non-zero).\n \n+   function Is_Unchecked_Conversion_Instance (Id : Entity_Id) return Boolean;\n+   --  Determine whether an arbitrary entity denotes an instance of function\n+   --  Ada.Unchecked_Conversion.\n+\n    function Is_Universal_Numeric_Type (T : Entity_Id) return Boolean;\n    pragma Inline (Is_Universal_Numeric_Type);\n    --  True if T is Universal_Integer or Universal_Real"}, {"sha": "866332ed81fd7102882fb6ad580f0239607c497c", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=6c3c671e4d2659884d01f384723910b0966d2c6d", "patch": "@@ -7240,7 +7240,11 @@ package Sinfo is\n       --  establish dependencies between subprogram or package inputs and\n       --  outputs. Currently the following pragmas appear in this list:\n       --    Abstract_States\n+      --    Async_Readers\n+      --    Async_Writers\n       --    Depends\n+      --    Effective_Reads\n+      --    Effective_Writes\n       --    Global\n       --    Initial_Condition\n       --    Initializes"}, {"sha": "fe4000a1740fe3e6060b9b21dd9fd0ea2437a238", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3c671e4d2659884d01f384723910b0966d2c6d/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=6c3c671e4d2659884d01f384723910b0966d2c6d", "patch": "@@ -460,6 +460,8 @@ package Snames is\n \n    Name_Assert                         : constant Name_Id := N + $; -- Ada 05\n    Name_Assert_And_Cut                 : constant Name_Id := N + $; -- GNAT\n+   Name_Async_Readers                  : constant Name_Id := N + $; -- GNAT\n+   Name_Async_Writers                  : constant Name_Id := N + $; -- GNAT\n    Name_Asynchronous                   : constant Name_Id := N + $;\n    Name_Atomic                         : constant Name_Id := N + $;\n    Name_Atomic_Components              : constant Name_Id := N + $;\n@@ -486,6 +488,8 @@ package Snames is\n \n    Name_Debug                          : constant Name_Id := N + $; -- GNAT\n    Name_Depends                        : constant Name_Id := N + $; -- GNAT\n+   Name_Effective_Reads                : constant Name_Id := N + $; -- GNAT\n+   Name_Effective_Writes               : constant Name_Id := N + $; -- GNAT\n    Name_Elaborate                      : constant Name_Id := N + $; -- Ada 83\n    Name_Elaborate_All                  : constant Name_Id := N + $;\n    Name_Elaborate_Body                 : constant Name_Id := N + $;\n@@ -1788,6 +1792,8 @@ package Snames is\n       Pragma_All_Calls_Remote,\n       Pragma_Assert,\n       Pragma_Assert_And_Cut,\n+      Pragma_Async_Readers,\n+      Pragma_Async_Writers,\n       Pragma_Asynchronous,\n       Pragma_Atomic,\n       Pragma_Atomic_Components,\n@@ -1807,6 +1813,8 @@ package Snames is\n       Pragma_CPP_Vtable,\n       Pragma_Debug,\n       Pragma_Depends,\n+      Pragma_Effective_Reads,\n+      Pragma_Effective_Writes,\n       Pragma_Elaborate,\n       Pragma_Elaborate_All,\n       Pragma_Elaborate_Body,"}]}