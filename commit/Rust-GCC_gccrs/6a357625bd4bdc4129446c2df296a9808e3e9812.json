{"sha": "6a357625bd4bdc4129446c2df296a9808e3e9812", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmEzNTc2MjViZDRiZGM0MTI5NDQ2YzJkZjI5NmE5ODA4ZTNlOTgxMg==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2000-09-15T21:16:31Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2000-09-15T21:16:31Z"}, "message": "c-common.c (format_wanted_type): New structure.\n\n\t* c-common.c (format_wanted_type): New structure.\n\t(check_format_types): New function.\n\t(check_format_info): Pass all checking of types of format\n\targuments, including width and precision arguments, to this new\n\tfunction.\n\nFrom-SVN: r36446", "tree": {"sha": "1b00f586c8c9e0fef2fa04594e4268c52e3d08fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b00f586c8c9e0fef2fa04594e4268c52e3d08fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a357625bd4bdc4129446c2df296a9808e3e9812", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a357625bd4bdc4129446c2df296a9808e3e9812", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a357625bd4bdc4129446c2df296a9808e3e9812", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a357625bd4bdc4129446c2df296a9808e3e9812/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a1d1088df3144fd467d9a706757c9b1cac3a55b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a1d1088df3144fd467d9a706757c9b1cac3a55b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a1d1088df3144fd467d9a706757c9b1cac3a55b"}], "stats": {"total": 208, "additions": 161, "deletions": 47}, "files": [{"sha": "bda64dca09a9b724342c519af8c637431c6e93fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a357625bd4bdc4129446c2df296a9808e3e9812/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a357625bd4bdc4129446c2df296a9808e3e9812/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a357625bd4bdc4129446c2df296a9808e3e9812", "patch": "@@ -1,3 +1,11 @@\n+2000-09-15  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* c-common.c (format_wanted_type): New structure.\n+\t(check_format_types): New function.\n+\t(check_format_info): Pass all checking of types of format\n+\targuments, including width and precision arguments, to this new\n+\tfunction.\n+\n 2000-09-15  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n \n \t* BUGS: Remove file."}, {"sha": "2f35541214af7e3dd5af269a3070a8231f92d99c", "filename": "gcc/c-common.c", "status": "modified", "additions": 153, "deletions": 47, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a357625bd4bdc4129446c2df296a9808e3e9812/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a357625bd4bdc4129446c2df296a9808e3e9812/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=6a357625bd4bdc4129446c2df296a9808e3e9812", "patch": "@@ -31,6 +31,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"ggc.h\"\n #include \"expr.h\"\n #include \"tm_p.h\"\n+#include \"intl.h\"\n \n #if USE_CPPLIB\n #include \"cpplib.h\"\n@@ -1291,6 +1292,38 @@ typedef struct\n } format_kind_info;\n \n \n+/* Structure describing details of a type expected in format checking,\n+   and the type to check against it.  */\n+typedef struct format_wanted_type\n+{\n+  /* The type wanted.  */\n+  tree wanted_type;\n+  /* The name of this type to use in diagnostics.  */\n+  const char *wanted_type_name;\n+  /* The level of indirection through pointers at which this type occurs.  */\n+  int pointer_count;\n+  /* Whether, when pointer_count is 1, to allow any character type when\n+     pedantic, rather than just the character or void type specified.  */\n+  int char_lenient_flag;\n+  /* Whether the argument, dereferenced once, is written into and so the\n+     argument must not be a pointer to a const-qualified type.  */\n+  int writing_in_flag;\n+  /* If warnings should be of the form \"field precision is not type int\",\n+     the name to use (in this case \"field precision\"), otherwise NULL,\n+     for \"%s format, %s arg\" type messages.  If (in an extension), this\n+     is a pointer type, wanted_type_name should be set to include the\n+     terminating '*' characters of the type name to give a correct\n+     message.  */\n+  const char *name;\n+  /* The actual parameter to check against the wanted type.  */\n+  tree param;\n+  /* The argument number of that parameter.  */\n+  int arg_num;\n+  /* The next type to check for this format conversion, or NULL if none.  */\n+  struct format_wanted_type *next;\n+} format_wanted_type;\n+\n+\n static const format_length_info printf_length_specs[] =\n {\n   { \"h\", FMT_LEN_h, STD_C89, \"hh\", FMT_LEN_hh, STD_C99 },\n@@ -1483,6 +1516,8 @@ static int maybe_read_dollar_number\t\tPARAMS ((const char **, int,\n \t\t\t\t\t\t\t tree, tree *));\n static void finish_dollar_format_checking\tPARAMS ((void));\n \n+static void check_format_types\tPARAMS ((format_wanted_type *));\n+\n /* Initialize the table of functions to perform format checking on.\n    The ISO C functions are always checked (whether <stdio.h> is\n    included or not), since it is common to call printf without\n@@ -1842,10 +1877,14 @@ check_format_info (info, params)\n   int format_length;\n   tree format_tree;\n   tree cur_param;\n-  tree cur_type;\n   tree wanted_type;\n   enum format_std_version wanted_type_std;\n   const char *wanted_type_name;\n+  format_wanted_type width_wanted_type;\n+  format_wanted_type precision_wanted_type;\n+  format_wanted_type main_wanted_type;\n+  format_wanted_type *first_wanted_type;\n+  format_wanted_type *last_wanted_type;\n   tree first_fillin_param;\n   const char *format_chars;\n   const format_kind_info *fki = NULL;\n@@ -1959,8 +1998,8 @@ check_format_info (info, params)\n   while (1)\n     {\n       int aflag;\n-      int char_type_flag = 0;\n-      int writing_in_flag = 0;\n+      first_wanted_type = NULL;\n+      last_wanted_type = NULL;\n       if (*format_chars == 0)\n \t{\n \t  if (format_chars - TREE_STRING_POINTER (format_tree) != format_length)\n@@ -2132,16 +2171,20 @@ check_format_info (info, params)\n \t\t      params = TREE_CHAIN (params);\n \t\t      ++arg_num;\n \t\t    }\n-\t\t  /* size_t is generally not valid here.\n-\t\t     It will work on most machines, because size_t and int\n-\t\t     have the same mode.  But might as well warn anyway,\n-\t\t     since it will fail on other machines.  */\n-\t\t  if ((TYPE_MAIN_VARIANT (TREE_TYPE (cur_param))\n-\t\t       != integer_type_node)\n-\t\t      &&\n-\t\t      (TYPE_MAIN_VARIANT (TREE_TYPE (cur_param))\n-\t\t       != unsigned_type_node))\n-\t\t    warning (\"field width is not type int (arg %d)\", arg_num);\n+\t\t  width_wanted_type.wanted_type = integer_type_node;\n+\t\t  width_wanted_type.wanted_type_name = NULL;\n+\t\t  width_wanted_type.pointer_count = 0;\n+\t\t  width_wanted_type.char_lenient_flag = 0;\n+\t\t  width_wanted_type.writing_in_flag = 0;\n+\t\t  width_wanted_type.name = _(\"field width\");\n+\t\t  width_wanted_type.param = cur_param;\n+\t\t  width_wanted_type.arg_num = arg_num;\n+\t\t  width_wanted_type.next = NULL;\n+\t\t  if (last_wanted_type != 0)\n+\t\t    last_wanted_type->next = &width_wanted_type;\n+\t\t  if (first_wanted_type == 0)\n+\t\t    first_wanted_type = &width_wanted_type;\n+\t\t  last_wanted_type = &width_wanted_type;\n \t\t}\n \t    }\n \t  else\n@@ -2185,13 +2228,20 @@ check_format_info (info, params)\n \t\t\t  params = TREE_CHAIN (params);\n \t\t\t  ++arg_num;\n \t\t\t}\n-\t\t      if ((TYPE_MAIN_VARIANT (TREE_TYPE (cur_param))\n-\t\t\t   != integer_type_node)\n-\t\t\t  &&\n-\t\t\t  (TYPE_MAIN_VARIANT (TREE_TYPE (cur_param))\n-\t\t\t   != unsigned_type_node))\n-\t\t\twarning (\"field precision is not type int (arg %d)\",\n-\t\t\t\t arg_num);\n+\t\t      precision_wanted_type.wanted_type = integer_type_node;\n+\t\t      precision_wanted_type.wanted_type_name = NULL;\n+\t\t      precision_wanted_type.pointer_count = 0;\n+\t\t      precision_wanted_type.char_lenient_flag = 0;\n+\t\t      precision_wanted_type.writing_in_flag = 0;\n+\t\t      precision_wanted_type.name = _(\"field precision\");\n+\t\t      precision_wanted_type.param = cur_param;\n+\t\t      precision_wanted_type.arg_num = arg_num;\n+\t\t      precision_wanted_type.next = NULL;\n+\t\t      if (last_wanted_type != 0)\n+\t\t\tlast_wanted_type->next = &precision_wanted_type;\n+\t\t      if (first_wanted_type == 0)\n+\t\t\tfirst_wanted_type = &precision_wanted_type;\n+\t\t      last_wanted_type = &precision_wanted_type;\n \t\t    }\n \t\t}\n \t      else\n@@ -2357,8 +2407,20 @@ check_format_info (info, params)\n       wanted_type_name = fci->types[length_chars_val].name;\n       wanted_type_std = fci->types[length_chars_val].std;\n       if (wanted_type == 0)\n-\twarning (\"use of `%s' length modifier with `%c' type character\",\n-\t\t length_chars, format_char);\n+\t{\n+\t  warning (\"use of `%s' length modifier with `%c' type character\",\n+\t\t   length_chars, format_char);\n+\t  /* Heuristic: skip one argument when an invalid length/type\n+\t     combination is encountered.  */\n+\t  arg_num++;\n+\t  if (params == 0)\n+\t    {\n+\t      tfaff ();\n+\t      return;\n+\t    }\n+\t  params = TREE_CHAIN (params);\n+\t  continue;\n+\t}\n       else if (pedantic\n \t       /* Warn if non-standard, provided it is more non-standard\n \t\t  than the length and type characters that may already\n@@ -2378,30 +2440,70 @@ check_format_info (info, params)\n       /* Finally. . .check type of argument against desired type!  */\n       if (info->first_arg_num == 0)\n \tcontinue;\n-      if (fci->pointer_count == 0 && wanted_type == void_type_node)\n-\t/* This specifier takes no argument.  */\n-\tcontinue;\n-      if (params == 0)\n+      if (!(fci->pointer_count == 0 && wanted_type == void_type_node))\n \t{\n-\t  tfaff ();\n-\t  return;\n+\t  if (params == 0)\n+\t    {\n+\t      tfaff ();\n+\t      return;\n+\t    }\n+\t  cur_param = TREE_VALUE (params);\n+\t  params = TREE_CHAIN (params);\n+\t  ++arg_num;\n+\t  main_wanted_type.wanted_type = wanted_type;\n+\t  main_wanted_type.wanted_type_name = wanted_type_name;\n+\t  main_wanted_type.pointer_count = fci->pointer_count + aflag;\n+\t  main_wanted_type.char_lenient_flag = 0;\n+\t  if (index (fci->flag_chars, 'c') != 0)\n+\t    main_wanted_type.char_lenient_flag = 1;\n+\t  main_wanted_type.writing_in_flag = 0;\n+\t  if (info->format_type == scanf_format_type\n+\t       || (info->format_type == printf_format_type\n+\t\t   && format_char == 'n'))\n+\t    main_wanted_type.writing_in_flag = 1;\n+\t  main_wanted_type.name = NULL;\n+\t  main_wanted_type.param = cur_param;\n+\t  main_wanted_type.arg_num = arg_num;\n+\t  main_wanted_type.next = NULL;\n+\t  if (last_wanted_type != 0)\n+\t    last_wanted_type->next = &main_wanted_type;\n+\t  if (first_wanted_type == 0)\n+\t    first_wanted_type = &main_wanted_type;\n+\t  last_wanted_type = &main_wanted_type;\n \t}\n-      cur_param = TREE_VALUE (params);\n-      params = TREE_CHAIN (params);\n-      ++arg_num;\n+\n+      if (first_wanted_type != 0)\n+\tcheck_format_types (first_wanted_type);\n+\n+    }\n+}\n+\n+\n+/* Check the argument types from a single format conversion (possibly\n+   including width and precision arguments).  */\n+static void\n+check_format_types (types)\n+     format_wanted_type *types;\n+{\n+  for (; types != 0; types = types->next)\n+    {\n+      tree cur_param;\n+      tree cur_type;\n+      tree wanted_type;\n+      int arg_num;\n+      int i;\n+      int char_type_flag;\n+      cur_param = types->param;\n       cur_type = TREE_TYPE (cur_param);\n+      char_type_flag = 0;\n+      wanted_type = types->wanted_type;\n+      arg_num = types->arg_num;\n \n       STRIP_NOPS (cur_param);\n \n-      if ((info->format_type == scanf_format_type\n-\t   || (info->format_type == printf_format_type\n-\t       && format_char == 'n'))\n-\t  && wanted_type != 0)\n-\twriting_in_flag = 1;\n-\n       /* Check the types of any additional pointer arguments\n \t that precede the \"real\" argument.  */\n-      for (i = 0; i < fci->pointer_count + aflag; ++i)\n+      for (i = 0; i < types->pointer_count; ++i)\n \t{\n \t  if (TREE_CODE (cur_type) == POINTER_TYPE)\n \t    {\n@@ -2417,7 +2519,7 @@ check_format_info (info, params)\n \t\t at the first indirection only, if for example\n \t\t void * const * is passed to scanf %p; passing\n \t\t const void ** is simply passing an incompatible type.  */\n-\t      if (writing_in_flag\n+\t      if (types->writing_in_flag\n \t\t  && i == 0\n \t\t  && TREE_CODE (cur_type) != ERROR_MARK\n \t\t  && (TYPE_READONLY (cur_type)\n@@ -2443,7 +2545,7 @@ check_format_info (info, params)\n \t    }\n \t  if (TREE_CODE (cur_type) != ERROR_MARK)\n \t    {\n-\t      if (fci->pointer_count + aflag == 1)\n+\t      if (types->pointer_count == 1)\n \t\twarning (\"format argument is not a pointer (arg %d)\", arg_num);\n \t      else\n \t\twarning (\"format argument is not a pointer to a pointer (arg %d)\", arg_num);\n@@ -2454,13 +2556,13 @@ check_format_info (info, params)\n       /* Check whether the argument type is a character type.  This leniency\n \t only applies to certain formats, flagged with 'c'.\n       */\n-      if (TREE_CODE (cur_type) != ERROR_MARK && index (fci->flag_chars, 'c') != 0)\n+      if (TREE_CODE (cur_type) != ERROR_MARK && types->char_lenient_flag)\n \tchar_type_flag = (TYPE_MAIN_VARIANT (cur_type) == char_type_node\n \t\t\t  || TYPE_MAIN_VARIANT (cur_type) == signed_char_type_node\n \t\t\t  || TYPE_MAIN_VARIANT (cur_type) == unsigned_char_type_node);\n \n       /* Check the type of the \"real\" argument, if there's a type we want.  */\n-      if (i == fci->pointer_count + aflag && wanted_type != 0\n+      if (i == types->pointer_count && wanted_type != 0\n \t  && TREE_CODE (cur_type) != ERROR_MARK\n \t  && wanted_type != TYPE_MAIN_VARIANT (cur_type)\n \t  /* If we want `void *', allow any pointer type.\n@@ -2469,7 +2571,7 @@ check_format_info (info, params)\n \t     types.\n \t  */\n \t  && ! (wanted_type == void_type_node\n-\t\t&& fci->pointer_count > 0\n+\t\t&& types->pointer_count > 0\n \t\t&& (! pedantic\n \t\t    || TYPE_MAIN_VARIANT (cur_type) == void_type_node\n \t\t    || (i == 1 && char_type_flag)))\n@@ -2533,10 +2635,14 @@ check_format_info (info, params)\n \t\t but we should allow for programs with a perverse typedef\n \t\t making size_t something other than what the compiler\n \t\t thinks.  */\n-\t      if (wanted_type_name != 0\n-\t\t  && strcmp (wanted_type_name, that) != 0)\n-\t\tthis = wanted_type_name;\n-\t      warning (\"%s format, %s arg (arg %d)\", this, that, arg_num);\n+\t      if (types->wanted_type_name != 0\n+\t\t  && strcmp (types->wanted_type_name, that) != 0)\n+\t\tthis = types->wanted_type_name;\n+\t      if (types->name != 0)\n+\t\twarning (\"%s is not type %s (arg %d)\", types->name, this,\n+\t\t\t arg_num);\n+\t      else\n+\t\twarning (\"%s format, %s arg (arg %d)\", this, that, arg_num);\n \t    }\n \t}\n     }"}]}