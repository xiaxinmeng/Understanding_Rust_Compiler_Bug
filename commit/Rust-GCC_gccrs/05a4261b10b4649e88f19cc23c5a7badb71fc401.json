{"sha": "05a4261b10b4649e88f19cc23c5a7badb71fc401", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDVhNDI2MWIxMGI0NjQ5ZTg4ZjE5Y2MyM2M1YTdiYWRiNzFmYzQwMQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2013-05-18T20:18:55Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2013-05-18T20:18:55Z"}, "message": "unique_ptr.h (make_unique): Declare inline.\n\n\t* include/bits/unique_ptr.h (make_unique): Declare inline.\n\t(unique_ptr<T[],D>::reset()): Combine two overloads into one.\n\t(default_delete, unique_ptr): Add doxygen comments.\n\t* include/bits/shared_ptr_base.h: Improve doxygen comments.\n\t* include/bits/shared_ptr.h: Likewise.\n\t* testsuite/20_util/default_delete/48631_neg.cc: Adjust dg-error line\n\tnumber.\n\t* testsuite/20_util/unique_ptr/assign/48635_neg.cc: Likewise.\n\nFrom-SVN: r199069", "tree": {"sha": "d9760becd472f3a39b3bb47bb7a52a89d8170354", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9760becd472f3a39b3bb47bb7a52a89d8170354"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05a4261b10b4649e88f19cc23c5a7badb71fc401", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05a4261b10b4649e88f19cc23c5a7badb71fc401", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05a4261b10b4649e88f19cc23c5a7badb71fc401", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05a4261b10b4649e88f19cc23c5a7badb71fc401/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82ec8686e79aaa48f294c0a9bb5dd7338b68afde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82ec8686e79aaa48f294c0a9bb5dd7338b68afde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82ec8686e79aaa48f294c0a9bb5dd7338b68afde"}], "stats": {"total": 188, "additions": 168, "deletions": 20}, "files": [{"sha": "db995a767fabb85c7a2eba9f5bc948b23104d4b5", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a4261b10b4649e88f19cc23c5a7badb71fc401/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a4261b10b4649e88f19cc23c5a7badb71fc401/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=05a4261b10b4649e88f19cc23c5a7badb71fc401", "patch": "@@ -1,3 +1,18 @@\n+2013-05-18  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\t* include/bits/unique_ptr.h (make_unique): Declare inline.\n+\t(unique_ptr<T[],D>::reset()): Combine two overloads into one.\n+\t(default_delete, unique_ptr): Add doxygen comments.\n+\t* include/bits/shared_ptr_base.h: Improve doxygen comments.\n+\t* include/bits/shared_ptr.h: Likewise.\n+\t* testsuite/20_util/default_delete/48631_neg.cc: Adjust dg-error line\n+\tnumber.\n+\t* testsuite/20_util/unique_ptr/assign/48635_neg.cc: Likewise.\n+\n+2013-05-18  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\t* doc/xml/manual/status_cxx2011.xml: Fix markup error.\n+\n 2013-05-18  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \t* doc/xml/manual/status_cxx2011.xml: Fix markup error."}, {"sha": "3a99cff0061d7b2fb246d715c871e690d557e055", "filename": "libstdc++-v3/include/bits/shared_ptr.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a4261b10b4649e88f19cc23c5a7badb71fc401/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a4261b10b4649e88f19cc23c5a7badb71fc401/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h?ref=05a4261b10b4649e88f19cc23c5a7badb71fc401", "patch": "@@ -60,7 +60,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * @{\n    */\n \n-  /// 2.2.3.7 shared_ptr I/O\n+  /// 20.7.2.2.11 shared_ptr I/O\n   template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>\n     inline std::basic_ostream<_Ch, _Tr>&\n     operator<<(std::basic_ostream<_Ch, _Tr>& __os,\n@@ -70,7 +70,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __os;\n     }\n \n-  /// 2.2.3.10 shared_ptr get_deleter (experimental)\n+  /// 20.7.2.2.10 shared_ptr get_deleter\n   template<typename _Del, typename _Tp, _Lock_policy _Lp>\n     inline _Del*\n     get_deleter(const __shared_ptr<_Tp, _Lp>& __p) noexcept"}, {"sha": "fb19d0887dcb13d557cb6a162e60763ae56c5281", "filename": "libstdc++-v3/include/bits/shared_ptr_base.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a4261b10b4649e88f19cc23c5a7badb71fc401/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a4261b10b4649e88f19cc23c5a7badb71fc401/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h?ref=05a4261b10b4649e88f19cc23c5a7badb71fc401", "patch": "@@ -1204,13 +1204,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public _Sp_less<__shared_ptr<_Tp, _Lp>>\n     { };\n \n-  // 2.2.3.8 shared_ptr specialized algorithms.\n+  // 20.7.2.2.8 shared_ptr specialized algorithms.\n   template<typename _Tp, _Lock_policy _Lp>\n     inline void\n     swap(__shared_ptr<_Tp, _Lp>& __a, __shared_ptr<_Tp, _Lp>& __b) noexcept\n     { __a.swap(__b); }\n \n-  // 2.2.3.9 shared_ptr casts\n+  // 20.7.2.2.9 shared_ptr casts\n \n   // The seemingly equivalent code:\n   // shared_ptr<_Tp, _Lp>(static_cast<_Tp*>(__r.get()))"}, {"sha": "c6c9a5a04a5ce68128e6b819556d2b3f15ff3f49", "filename": "libstdc++-v3/include/bits/unique_ptr.h", "status": "modified", "additions": 146, "deletions": 13, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a4261b10b4649e88f19cc23c5a7badb71fc401/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a4261b10b4649e88f19cc23c5a7badb71fc401/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h?ref=05a4261b10b4649e88f19cc23c5a7badb71fc401", "patch": "@@ -49,16 +49,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename> class auto_ptr;\n #endif\n \n-  /// Primary template, default_delete.\n+  /// Primary template of default_delete, used by unique_ptr\n   template<typename _Tp>\n     struct default_delete\n     {\n+      /// Default constructor\n       constexpr default_delete() noexcept = default;\n \n+      /** @brief Converting constructor.\n+       *\n+       * Allows conversion from a deleter for arrays of another type, @p _Up,\n+       * only if @p _Up* is convertible to @p _Tp*.\n+       */\n       template<typename _Up, typename = typename\n \t       enable_if<is_convertible<_Up*, _Tp*>::value>::type>\n         default_delete(const default_delete<_Up>&) noexcept { }\n \n+      /// Calls @c delete @p __ptr\n       void\n       operator()(_Tp* __ptr) const\n       {\n@@ -70,7 +77,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // _GLIBCXX_RESOLVE_LIB_DEFECTS\n   // DR 740 - omit specialization for array objects with a compile time length\n-  /// Specialization, default_delete.\n+  /// Specialization for arrays, default_delete.\n   template<typename _Tp>\n     struct default_delete<_Tp[]>\n     {\n@@ -85,12 +92,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t    __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;\n \n     public:\n+      /// Default constructor\n       constexpr default_delete() noexcept = default;\n \n+      /** @brief Converting constructor.\n+       *\n+       * Allows conversion from a deleter for arrays of another type, such as\n+       * a const-qualified version of @p _Tp.\n+       *\n+       * Conversions from types derived from @c _Tp are not allowed because\n+       * it is unsafe to @c delete[] an array of derived types through a\n+       * pointer to the base type.\n+       */\n       template<typename _Up, typename = typename\n \t       enable_if<!__is_derived_Tp<_Up>::value>::type>\n         default_delete(const default_delete<_Up[]>&) noexcept { }\n \n+      /// Calls @c delete[] @p __ptr\n       void\n       operator()(_Tp* __ptr) const\n       {\n@@ -132,34 +150,65 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef _Dp                       deleter_type;\n \n       // Constructors.\n+\n+      /// Default constructor, creates a unique_ptr that owns nothing.\n       constexpr unique_ptr() noexcept\n       : _M_t()\n       { static_assert(!is_pointer<deleter_type>::value,\n \t\t     \"constructed with null function pointer deleter\"); }\n \n+      /** Takes ownership of a pointer.\n+       *\n+       * @param __p  A pointer to an object of @c element_type\n+       *\n+       * The deleter will be value-initialized.\n+       */\n       explicit\n       unique_ptr(pointer __p) noexcept\n       : _M_t(__p, deleter_type())\n       { static_assert(!is_pointer<deleter_type>::value,\n \t\t     \"constructed with null function pointer deleter\"); }\n \n+      /** Takes ownership of a pointer.\n+       *\n+       * @param __p  A pointer to an object of @c element_type\n+       * @param __d  A reference to a deleter.\n+       *\n+       * The deleter will be initialized with @p __d\n+       */\n       unique_ptr(pointer __p,\n \t  typename conditional<is_reference<deleter_type>::value,\n \t    deleter_type, const deleter_type&>::type __d) noexcept\n       : _M_t(__p, __d) { }\n \n+      /** Takes ownership of a pointer.\n+       *\n+       * @param __p  A pointer to an object of @c element_type\n+       * @param __d  An rvalue reference to a deleter.\n+       *\n+       * The deleter will be initialized with @p std::move(__d)\n+       */\n       unique_ptr(pointer __p,\n \t  typename remove_reference<deleter_type>::type&& __d) noexcept\n       : _M_t(std::move(__p), std::move(__d))\n       { static_assert(!std::is_reference<deleter_type>::value,\n \t\t      \"rvalue deleter bound to reference\"); }\n \n+      /// Creates a unique_ptr that owns nothing.\n       constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n \n       // Move constructors.\n+\n+      /// Move constructor.\n       unique_ptr(unique_ptr&& __u) noexcept\n       : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }\n \n+      /** @brief Converting constructor from another type\n+       *\n+       * Requires that the pointer owned by @p __u is convertible to the\n+       * type of pointer owned by this object, @p __u does not own an array,\n+       * and @p __u has a compatible deleter type.\n+       */\n       template<typename _Up, typename _Ep, typename = _Require<\n \t       is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,\n \t       __not_<is_array<_Up>>,\n@@ -171,12 +220,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{ }\n \n #if _GLIBCXX_USE_DEPRECATED\n+      /// Converting constructor from @c auto_ptr\n       template<typename _Up, typename = _Require<\n \t       is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>\n \tunique_ptr(auto_ptr<_Up>&& __u) noexcept;\n #endif\n \n-      // Destructor.\n+      /// Destructor, invokes the deleter if the stored pointer is not null.\n       ~unique_ptr() noexcept\n       {\n \tauto& __ptr = std::get<0>(_M_t);\n@@ -186,6 +236,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       // Assignment.\n+\n+      /** @brief Move assignment operator.\n+       *\n+       * @param __u  The object to transfer ownership from.\n+       *\n+       * Invokes the deleter first if this object owns a pointer.\n+       */\n       unique_ptr&\n       operator=(unique_ptr&& __u) noexcept\n       {\n@@ -194,6 +251,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn *this;\n       }\n \n+      /** @brief Assignment from another type.\n+       *\n+       * @param __u  The object to transfer ownership from, which owns a\n+       *             convertible pointer to a non-array object.\n+       *\n+       * Invokes the deleter first if this object owns a pointer.\n+       */\n       template<typename _Up, typename _Ep>\n \ttypename enable_if< __and_<\n \t  is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,\n@@ -207,6 +271,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return *this;\n \t}\n \n+      /// Reset the %unique_ptr to empty, invoking the deleter if necessary.\n       unique_ptr&\n       operator=(nullptr_t) noexcept\n       {\n@@ -215,36 +280,45 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       // Observers.\n+\n+      /// Dereference the stored pointer.\n       typename add_lvalue_reference<element_type>::type\n       operator*() const\n       {\n \t_GLIBCXX_DEBUG_ASSERT(get() != pointer());\n \treturn *get();\n       }\n \n+      /// Return the stored pointer.\n       pointer\n       operator->() const noexcept\n       {\n \t_GLIBCXX_DEBUG_ASSERT(get() != pointer());\n \treturn get();\n       }\n \n+      /// Return the stored pointer.\n       pointer\n       get() const noexcept\n       { return std::get<0>(_M_t); }\n \n+      /// Return a reference to the stored deleter.\n       deleter_type&\n       get_deleter() noexcept\n       { return std::get<1>(_M_t); }\n \n+      /// Return a reference to the stored deleter.\n       const deleter_type&\n       get_deleter() const noexcept\n       { return std::get<1>(_M_t); }\n \n+      /// Return @c true if the stored pointer is not null.\n       explicit operator bool() const noexcept\n       { return get() == pointer() ? false : true; }\n \n       // Modifiers.\n+\n+      /// Release ownership of any stored pointer.\n       pointer\n       release() noexcept\n       {\n@@ -253,6 +327,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn __p;\n       }\n \n+      /** @brief Replace the stored pointer.\n+       *\n+       * @param __p  The new pointer to store.\n+       *\n+       * The deleter will be invoked if a pointer is already owned.\n+       */\n       void\n       reset(pointer __p = pointer()) noexcept\n       {\n@@ -262,6 +342,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  get_deleter()(__p);\n       }\n \n+      /// Exchange the pointer and deleter with another object.\n       void\n       swap(unique_ptr& __u) noexcept\n       {\n@@ -326,37 +407,61 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef _Dp                       deleter_type;\n \n       // Constructors.\n+\n+      /// Default constructor, creates a unique_ptr that owns nothing.\n       constexpr unique_ptr() noexcept\n       : _M_t()\n       { static_assert(!std::is_pointer<deleter_type>::value,\n \t\t      \"constructed with null function pointer deleter\"); }\n \n+      /** Takes ownership of a pointer.\n+       *\n+       * @param __p  A pointer to an array of @c element_type\n+       *\n+       * The deleter will be value-initialized.\n+       */\n       explicit\n       unique_ptr(pointer __p) noexcept\n       : _M_t(__p, deleter_type())\n       { static_assert(!is_pointer<deleter_type>::value,\n \t\t      \"constructed with null function pointer deleter\"); }\n \n+      // Disable construction from convertible pointer types.\n       template<typename _Up, typename = _Require<is_pointer<pointer>,\n \t       is_convertible<_Up*, pointer>, __is_derived_Tp<_Up>>>\n \texplicit\n \tunique_ptr(_Up* __p) = delete;\n \n+      /** Takes ownership of a pointer.\n+       *\n+       * @param __p  A pointer to an array of @c element_type\n+       * @param __d  A reference to a deleter.\n+       *\n+       * The deleter will be initialized with @p __d\n+       */\n       unique_ptr(pointer __p,\n \t  typename conditional<is_reference<deleter_type>::value,\n \t      deleter_type, const deleter_type&>::type __d) noexcept\n       : _M_t(__p, __d) { }\n \n+      /** Takes ownership of a pointer.\n+       *\n+       * @param __p  A pointer to an array of @c element_type\n+       * @param __d  A reference to a deleter.\n+       *\n+       * The deleter will be initialized with @p std::move(__d)\n+       */\n       unique_ptr(pointer __p, typename\n \t\t remove_reference<deleter_type>::type&& __d) noexcept\n       : _M_t(std::move(__p), std::move(__d))\n       { static_assert(!is_reference<deleter_type>::value,\n \t\t      \"rvalue deleter bound to reference\"); }\n \n-      // Move constructor.\n+      /// Move constructor.\n       unique_ptr(unique_ptr&& __u) noexcept\n       : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }\n \n+      /// Creates a unique_ptr that owns nothing.\n       constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n \n       template<typename _Up, typename _Ep,\n@@ -369,7 +474,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t: _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))\n \t{ }\n \n-      // Destructor.\n+      /// Destructor, invokes the deleter if the stored pointer is not null.\n       ~unique_ptr()\n       {\n \tauto& __ptr = std::get<0>(_M_t);\n@@ -379,6 +484,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       // Assignment.\n+\n+      /** @brief Move assignment operator.\n+       *\n+       * @param __u  The object to transfer ownership from.\n+       *\n+       * Invokes the deleter first if this object owns a pointer.\n+       */\n       unique_ptr&\n       operator=(unique_ptr&& __u) noexcept\n       {\n@@ -387,6 +499,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn *this;\n       }\n \n+      /** @brief Assignment from another type.\n+       *\n+       * @param __u  The object to transfer ownership from, which owns a\n+       *             convertible pointer to an array object.\n+       *\n+       * Invokes the deleter first if this object owns a pointer.\n+       */\n       template<typename _Up, typename _Ep>\n \ttypename\n \tenable_if<__safe_conversion<_Up, _Ep>::value, unique_ptr&>::type\n@@ -397,6 +516,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return *this;\n \t}\n \n+      /// Reset the %unique_ptr to empty, invoking the deleter if necessary.\n       unique_ptr&\n       operator=(nullptr_t) noexcept\n       {\n@@ -405,29 +525,37 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       // Observers.\n+\n+      /// Access an element of owned array.\n       typename std::add_lvalue_reference<element_type>::type\n       operator[](size_t __i) const\n       {\n \t_GLIBCXX_DEBUG_ASSERT(get() != pointer());\n \treturn get()[__i];\n       }\n \n+      /// Return the stored pointer.\n       pointer\n       get() const noexcept\n       { return std::get<0>(_M_t); }\n \n+      /// Return a reference to the stored deleter.\n       deleter_type&\n       get_deleter() noexcept\n       { return std::get<1>(_M_t); }\n \n+      /// Return a reference to the stored deleter.\n       const deleter_type&\n       get_deleter() const noexcept\n       { return std::get<1>(_M_t); }\n \n+      /// Return @c true if the stored pointer is not null.\n       explicit operator bool() const noexcept\n       { return get() == pointer() ? false : true; }\n \n       // Modifiers.\n+\n+      /// Release ownership of any stored pointer.\n       pointer\n       release() noexcept\n       {\n@@ -436,23 +564,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn __p;\n       }\n \n+      /** @brief Replace the stored pointer.\n+       *\n+       * @param __p  The new pointer to store.\n+       *\n+       * The deleter will be invoked if a pointer is already owned.\n+       */\n       void\n-      reset() noexcept\n-      { reset(pointer()); }\n-\n-      void\n-      reset(pointer __p) noexcept\n+      reset(pointer __p = pointer()) noexcept\n       {\n \tusing std::swap;\n \tswap(std::get<0>(_M_t), __p);\n \tif (__p != nullptr)\n \t  get_deleter()(__p);\n       }\n \n+      // Disable resetting from convertible pointer types.\n       template<typename _Up, typename = _Require<is_pointer<pointer>,\n \t       is_convertible<_Up*, pointer>, __is_derived_Tp<_Up>>>\n \tvoid reset(_Up*) = delete;\n \n+      /// Exchange the pointer and deleter with another object.\n       void\n       swap(unique_ptr& __u) noexcept\n       {\n@@ -471,6 +603,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t   conditional<is_reference<deleter_type>::value,\n \t\t   deleter_type, const deleter_type&>::type) = delete;\n \n+      // Disable construction from convertible pointer types.\n       template<typename _Up, typename = _Require<is_pointer<pointer>,\n \t       is_convertible<_Up*, pointer>, __is_derived_Tp<_Up>>>\n \tunique_ptr(_Up*, typename\n@@ -622,19 +755,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   /// std::make_unique for single objects\n   template<typename _Tp, typename... _Args>\n-    typename _MakeUniq<_Tp>::__single_object\n+    inline typename _MakeUniq<_Tp>::__single_object\n     make_unique(_Args&&... __args)\n     { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }\n \n   /// std::make_unique for arrays of unknown bound\n   template<typename _Tp>\n-    typename _MakeUniq<_Tp>::__array\n+    inline typename _MakeUniq<_Tp>::__array\n     make_unique(size_t __num)\n     { return unique_ptr<_Tp>(new typename remove_extent<_Tp>::type[__num]()); }\n \n   /// Disable std::make_unique for arrays of known bound\n   template<typename _Tp, typename... _Args>\n-    typename _MakeUniq<_Tp>::__invalid_type\n+    inline typename _MakeUniq<_Tp>::__invalid_type\n     make_unique(_Args&&...) = delete;\n #endif\n "}, {"sha": "d0619fd9ca0ce175431a4058aca0be323a9e8fe3", "filename": "libstdc++-v3/testsuite/20_util/default_delete/48631_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a4261b10b4649e88f19cc23c5a7badb71fc401/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdefault_delete%2F48631_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a4261b10b4649e88f19cc23c5a7badb71fc401/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdefault_delete%2F48631_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdefault_delete%2F48631_neg.cc?ref=05a4261b10b4649e88f19cc23c5a7badb71fc401", "patch": "@@ -27,4 +27,4 @@ struct D : B { };\n D d;\n std::default_delete<B[]> db;\n typedef decltype(db(&d)) type; // { dg-error \"use of deleted function\" }\n-// { dg-error \"declared here\" \"\" { target *-*-* } 104 }\n+// { dg-error \"declared here\" \"\" { target *-*-* } 122 }"}, {"sha": "c78564270f4199d7e0dec6c1ff44036456cf6114", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/assign/48635_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a4261b10b4649e88f19cc23c5a7badb71fc401/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fassign%2F48635_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a4261b10b4649e88f19cc23c5a7badb71fc401/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fassign%2F48635_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fassign%2F48635_neg.cc?ref=05a4261b10b4649e88f19cc23c5a7badb71fc401", "patch": "@@ -41,10 +41,10 @@ void f()\n   std::unique_ptr<int, B&> ub(nullptr, b);\n   std::unique_ptr<int, D&> ud(nullptr, d);\n   ub = std::move(ud);\n-// { dg-error \"use of deleted function\" \"\" { target *-*-* } 206 }\n+// { dg-error \"use of deleted function\" \"\" { target *-*-* } 270 }\n \n   std::unique_ptr<int[], B&> uba(nullptr, b);\n   std::unique_ptr<int[], D&> uda(nullptr, d);\n   uba = std::move(uda);\n-// { dg-error \"use of deleted function\" \"\" { target *-*-* } 396 }\n+// { dg-error \"use of deleted function\" \"\" { target *-*-* } 515 }\n }"}]}