{"sha": "ea69031c5facc70e4a96df83cd58702900fd54b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE2OTAzMWM1ZmFjYzcwZTRhOTZkZjgzY2Q1ODcwMjkwMGZkNTRiNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-01-10T21:18:22Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2020-01-10T21:18:22Z"}, "message": "re PR tree-optimization/93210 (Sub-optimal code optimization on struct/combound constexpr (gcc vs. clang))\n\n\tPR tree-optimization/93210\n\t* fold-const.h (native_encode_initializer,\n\tcan_native_interpret_type_p): Declare.\n\t* fold-const.c (native_encode_string): Fix up handling with off != -1,\n\tsimplify.\n\t(native_encode_initializer): New function, moved from dwarf2out.c.\n\tAdjust to native_encode_expr compatible arguments, including dry-run\n\tand partial extraction modes.  Don't handle STRING_CST.\n\t(can_native_interpret_type_p): No longer static.\n\t* gimple-fold.c (fold_ctor_reference): For native_encode_expr, verify\n\toffset / BITS_PER_UNIT fits into int and don't call it if\n\tcan_native_interpret_type_p fails.  If suboff is NULL and for\n\tCONSTRUCTOR fold_{,non}array_ctor_reference returns NULL, retry with\n\tnative_encode_initializer.\n\t(fold_const_aggregate_ref_1): Formatting fix.\n\t* dwarf2out.c (native_encode_initializer): Moved to fold-const.c.\n\t(tree_add_const_value_attribute): Adjust caller.\n\n\t* gcc.dg/pr93210.c: New test.\n\t* g++.dg/opt/pr93210.C: New test.\n\nFrom-SVN: r280141", "tree": {"sha": "879c6e151d192e9ac99c83999572027edc8d0517", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/879c6e151d192e9ac99c83999572027edc8d0517"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea69031c5facc70e4a96df83cd58702900fd54b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea69031c5facc70e4a96df83cd58702900fd54b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea69031c5facc70e4a96df83cd58702900fd54b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea69031c5facc70e4a96df83cd58702900fd54b6/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "974bb8a4dcbf51a153ab72da91a7256a296e7fa1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/974bb8a4dcbf51a153ab72da91a7256a296e7fa1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/974bb8a4dcbf51a153ab72da91a7256a296e7fa1"}], "stats": {"total": 531, "additions": 373, "deletions": 158}, "files": [{"sha": "6b24415a4d632bdbefb95ffa926f2950d1b0c60c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea69031c5facc70e4a96df83cd58702900fd54b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea69031c5facc70e4a96df83cd58702900fd54b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ea69031c5facc70e4a96df83cd58702900fd54b6", "patch": "@@ -1,5 +1,23 @@\n 2020-01-10  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR tree-optimization/93210\n+\t* fold-const.h (native_encode_initializer,\n+\tcan_native_interpret_type_p): Declare.\n+\t* fold-const.c (native_encode_string): Fix up handling with off != -1,\n+\tsimplify.\n+\t(native_encode_initializer): New function, moved from dwarf2out.c.\n+\tAdjust to native_encode_expr compatible arguments, including dry-run\n+\tand partial extraction modes.  Don't handle STRING_CST.\n+\t(can_native_interpret_type_p): No longer static.\n+\t* gimple-fold.c (fold_ctor_reference): For native_encode_expr, verify\n+\toffset / BITS_PER_UNIT fits into int and don't call it if\n+\tcan_native_interpret_type_p fails.  If suboff is NULL and for\n+\tCONSTRUCTOR fold_{,non}array_ctor_reference returns NULL, retry with\n+\tnative_encode_initializer.\n+\t(fold_const_aggregate_ref_1): Formatting fix.\n+\t* dwarf2out.c (native_encode_initializer): Moved to fold-const.c.\n+\t(tree_add_const_value_attribute): Adjust caller.\n+\n \tPR tree-optimization/90838\n \t* tree-ssa-forwprop.c (simplify_count_trailing_zeroes): Use\n \tSCALAR_INT_TYPE_MODE instead of TYPE_MODE as operand of"}, {"sha": "70b3fad13a2df3351140544bb6a8a159977b2006", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 145, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea69031c5facc70e4a96df83cd58702900fd54b6/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea69031c5facc70e4a96df83cd58702900fd54b6/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=ea69031c5facc70e4a96df83cd58702900fd54b6", "patch": "@@ -20258,150 +20258,6 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl, bool cache_p)\n   return tree_add_const_value_attribute_for_decl (die, decl);\n }\n \n-/* Helper function for tree_add_const_value_attribute.  Natively encode\n-   initializer INIT into an array.  Return true if successful.  */\n-\n-static bool\n-native_encode_initializer (tree init, unsigned char *array, int size)\n-{\n-  tree type;\n-\n-  if (init == NULL_TREE)\n-    return false;\n-\n-  STRIP_NOPS (init);\n-  switch (TREE_CODE (init))\n-    {\n-    case STRING_CST:\n-      type = TREE_TYPE (init);\n-      if (TREE_CODE (type) == ARRAY_TYPE)\n-\t{\n-\t  tree enttype = TREE_TYPE (type);\n-\t  scalar_int_mode mode;\n-\n-\t  if (!is_int_mode (TYPE_MODE (enttype), &mode)\n-\t      || GET_MODE_SIZE (mode) != 1)\n-\t    return false;\n-\t  if (int_size_in_bytes (type) != size)\n-\t    return false;\n-\t  if (size > TREE_STRING_LENGTH (init))\n-\t    {\n-\t      memcpy (array, TREE_STRING_POINTER (init),\n-\t\t      TREE_STRING_LENGTH (init));\n-\t      memset (array + TREE_STRING_LENGTH (init),\n-\t\t      '\\0', size - TREE_STRING_LENGTH (init));\n-\t    }\n-\t  else\n-\t    memcpy (array, TREE_STRING_POINTER (init), size);\n-\t  return true;\n-\t}\n-      return false;\n-    case CONSTRUCTOR:\n-      type = TREE_TYPE (init);\n-      if (int_size_in_bytes (type) != size)\n-\treturn false;\n-      if (TREE_CODE (type) == ARRAY_TYPE)\n-\t{\n-\t  HOST_WIDE_INT min_index;\n-\t  unsigned HOST_WIDE_INT cnt;\n-\t  int curpos = 0, fieldsize;\n-\t  constructor_elt *ce;\n-\n-\t  if (TYPE_DOMAIN (type) == NULL_TREE\n-\t      || !tree_fits_shwi_p (TYPE_MIN_VALUE (TYPE_DOMAIN (type))))\n-\t    return false;\n-\n-\t  fieldsize = int_size_in_bytes (TREE_TYPE (type));\n-\t  if (fieldsize <= 0)\n-\t    return false;\n-\n-\t  min_index = tree_to_shwi (TYPE_MIN_VALUE (TYPE_DOMAIN (type)));\n-\t  memset (array, '\\0', size);\n-\t  FOR_EACH_VEC_SAFE_ELT (CONSTRUCTOR_ELTS (init), cnt, ce)\n-\t    {\n-\t      tree val = ce->value;\n-\t      tree index = ce->index;\n-\t      int pos = curpos;\n-\t      if (index && TREE_CODE (index) == RANGE_EXPR)\n-\t\tpos = (tree_to_shwi (TREE_OPERAND (index, 0)) - min_index)\n-\t\t      * fieldsize;\n-\t      else if (index)\n-\t\tpos = (tree_to_shwi (index) - min_index) * fieldsize;\n-\n-\t      if (val)\n-\t\t{\n-\t\t  STRIP_NOPS (val);\n-\t\t  if (!native_encode_initializer (val, array + pos, fieldsize))\n-\t\t    return false;\n-\t\t}\n-\t      curpos = pos + fieldsize;\n-\t      if (index && TREE_CODE (index) == RANGE_EXPR)\n-\t\t{\n-\t\t  int count = tree_to_shwi (TREE_OPERAND (index, 1))\n-\t\t\t      - tree_to_shwi (TREE_OPERAND (index, 0));\n-\t\t  while (count-- > 0)\n-\t\t    {\n-\t\t      if (val)\n-\t\t\tmemcpy (array + curpos, array + pos, fieldsize);\n-\t\t      curpos += fieldsize;\n-\t\t    }\n-\t\t}\n-\t      gcc_assert (curpos <= size);\n-\t    }\n-\t  return true;\n-\t}\n-      else if (TREE_CODE (type) == RECORD_TYPE\n-\t       || TREE_CODE (type) == UNION_TYPE)\n-\t{\n-\t  tree field = NULL_TREE;\n-\t  unsigned HOST_WIDE_INT cnt;\n-\t  constructor_elt *ce;\n-\n-\t  if (int_size_in_bytes (type) != size)\n-\t    return false;\n-\n-\t  if (TREE_CODE (type) == RECORD_TYPE)\n-\t    field = TYPE_FIELDS (type);\n-\n-\t  FOR_EACH_VEC_SAFE_ELT (CONSTRUCTOR_ELTS (init), cnt, ce)\n-\t    {\n-\t      tree val = ce->value;\n-\t      int pos, fieldsize;\n-\n-\t      if (ce->index != 0)\n-\t\tfield = ce->index;\n-\n-\t      if (val)\n-\t\tSTRIP_NOPS (val);\n-\n-\t      if (field == NULL_TREE || DECL_BIT_FIELD (field))\n-\t\treturn false;\n-\n-\t      if (TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE\n-\t\t  && TYPE_DOMAIN (TREE_TYPE (field))\n-\t\t  && ! TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (field))))\n-\t\treturn false;\n-\t      else if (DECL_SIZE_UNIT (field) == NULL_TREE\n-\t\t       || !tree_fits_shwi_p (DECL_SIZE_UNIT (field)))\n-\t\treturn false;\n-\t      fieldsize = tree_to_shwi (DECL_SIZE_UNIT (field));\n-\t      pos = int_byte_position (field);\n-\t      gcc_assert (pos + fieldsize <= size);\n-\t      if (val && fieldsize != 0\n-\t\t  && !native_encode_initializer (val, array + pos, fieldsize))\n-\t\treturn false;\n-\t    }\n-\t  return true;\n-\t}\n-      return false;\n-    case VIEW_CONVERT_EXPR:\n-    case NON_LVALUE_EXPR:\n-      return native_encode_initializer (TREE_OPERAND (init, 0), array, size);\n-    default:\n-      return native_encode_expr (init, array, size) == size;\n-    }\n-}\n-\n /* Attach a DW_AT_const_value attribute to DIE. The value of the\n    attribute is the const value T.  */\n \n@@ -20446,7 +20302,7 @@ tree_add_const_value_attribute (dw_die_ref die, tree t)\n \t{\n \t  unsigned char *array = ggc_cleared_vec_alloc<unsigned char> (size);\n \n-\t  if (native_encode_initializer (init, array, size))\n+\t  if (native_encode_initializer (init, array, size) == size)\n \t    {\n \t      add_AT_vec (die, DW_AT_const_value, size, 1, array);\n \t      return true;"}, {"sha": "aefa91666e2e9d731fe4b60f9a2c87a9e09f92d8", "filename": "gcc/fold-const.c", "status": "modified", "additions": 212, "deletions": 7, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea69031c5facc70e4a96df83cd58702900fd54b6/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea69031c5facc70e4a96df83cd58702900fd54b6/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=ea69031c5facc70e4a96df83cd58702900fd54b6", "patch": "@@ -7837,22 +7837,20 @@ native_encode_string (const_tree expr, unsigned char *ptr, int len, int off)\n     return 0;\n   if (off == -1)\n     off = 0;\n+  len = MIN (total_bytes - off, len);\n   if (ptr == NULL)\n     /* Dry run.  */;\n-  else if (TREE_STRING_LENGTH (expr) - off < MIN (total_bytes, len))\n+  else\n     {\n       int written = 0;\n       if (off < TREE_STRING_LENGTH (expr))\n \t{\n \t  written = MIN (len, TREE_STRING_LENGTH (expr) - off);\n \t  memcpy (ptr, TREE_STRING_POINTER (expr) + off, written);\n \t}\n-      memset (ptr + written, 0,\n-\t      MIN (total_bytes - written, len - written));\n+      memset (ptr + written, 0, len - written);\n     }\n-  else\n-    memcpy (ptr, TREE_STRING_POINTER (expr) + off, MIN (total_bytes, len));\n-  return MIN (total_bytes - off, len);\n+  return len;\n }\n \n \n@@ -7895,6 +7893,213 @@ native_encode_expr (const_tree expr, unsigned char *ptr, int len, int off)\n     }\n }\n \n+/* Similar to native_encode_expr, but also handle CONSTRUCTORs, VCEs,\n+   NON_LVALUE_EXPRs and nops.  */\n+\n+int\n+native_encode_initializer (tree init, unsigned char *ptr, int len,\n+\t\t\t   int off)\n+{\n+  /* We don't support starting at negative offset and -1 is special.  */\n+  if (off < -1 || init == NULL_TREE)\n+    return 0;\n+\n+  STRIP_NOPS (init);\n+  switch (TREE_CODE (init))\n+    {\n+    case VIEW_CONVERT_EXPR:\n+    case NON_LVALUE_EXPR:\n+      return native_encode_initializer (TREE_OPERAND (init, 0), ptr, len, off);\n+    default:\n+      return native_encode_expr (init, ptr, len, off);\n+    case CONSTRUCTOR:\n+      tree type = TREE_TYPE (init);\n+      HOST_WIDE_INT total_bytes = int_size_in_bytes (type);\n+      if (total_bytes < 0)\n+\treturn 0;\n+      if ((off == -1 && total_bytes > len) || off >= total_bytes)\n+\treturn 0;\n+      int o = off == -1 ? 0 : off;\n+      if (TREE_CODE (type) == ARRAY_TYPE)\n+\t{\n+\t  HOST_WIDE_INT min_index;\n+\t  unsigned HOST_WIDE_INT cnt;\n+\t  HOST_WIDE_INT curpos = 0, fieldsize;\n+\t  constructor_elt *ce;\n+\n+\t  if (TYPE_DOMAIN (type) == NULL_TREE\n+\t      || !tree_fits_shwi_p (TYPE_MIN_VALUE (TYPE_DOMAIN (type))))\n+\t    return 0;\n+\n+\t  fieldsize = int_size_in_bytes (TREE_TYPE (type));\n+\t  if (fieldsize <= 0)\n+\t    return 0;\n+\n+\t  min_index = tree_to_shwi (TYPE_MIN_VALUE (TYPE_DOMAIN (type)));\n+\t  if (ptr != NULL)\n+\t    memset (ptr, '\\0', MIN (total_bytes - off, len));\n+\n+\t  FOR_EACH_VEC_SAFE_ELT (CONSTRUCTOR_ELTS (init), cnt, ce)\n+\t    {\n+\t      tree val = ce->value;\n+\t      tree index = ce->index;\n+\t      HOST_WIDE_INT pos = curpos, count = 0;\n+\t      bool full = false;\n+\t      if (index && TREE_CODE (index) == RANGE_EXPR)\n+\t\t{\n+\t\t  if (!tree_fits_shwi_p (TREE_OPERAND (index, 0))\n+\t\t      || !tree_fits_shwi_p (TREE_OPERAND (index, 1)))\n+\t\t    return 0;\n+\t\t  pos = (tree_to_shwi (TREE_OPERAND (index, 0)) - min_index)\n+\t\t\t* fieldsize;\n+\t\t  count = (tree_to_shwi (TREE_OPERAND (index, 1))\n+\t\t\t   - tree_to_shwi (TREE_OPERAND (index, 0)));\n+\t\t}\n+\t      else if (index)\n+\t\t{\n+\t\t  if (!tree_fits_shwi_p (index))\n+\t\t    return 0;\n+\t\t  pos = (tree_to_shwi (index) - min_index) * fieldsize;\n+\t\t}\n+\n+\t      curpos = pos;\n+\t      if (val)\n+\t\tdo\n+\t\t  {\n+\t\t    if (off == -1\n+\t\t\t|| (curpos >= off\n+\t\t\t    && (curpos + fieldsize\n+\t\t\t\t<= (HOST_WIDE_INT) off + len)))\n+\t\t      {\n+\t\t\tif (full)\n+\t\t\t  {\n+\t\t\t    if (ptr)\n+\t\t\t      memcpy (ptr + (curpos - o), ptr + (pos - o),\n+\t\t\t\t      fieldsize);\n+\t\t\t  }\n+\t\t\telse if (!native_encode_initializer (val,\n+\t\t\t\t\t\t\t     ptr\n+\t\t\t\t\t\t\t     ? ptr + curpos - o\n+\t\t\t\t\t\t\t     : NULL,\n+\t\t\t\t\t\t\t     fieldsize,\n+\t\t\t\t\t\t\t     off == -1 ? -1\n+\t\t\t\t\t\t\t\t       : 0))\n+\t\t\t  return 0;\n+\t\t\telse\n+\t\t\t  {\n+\t\t\t    full = true;\n+\t\t\t    pos = curpos;\n+\t\t\t  }\n+\t\t      }\n+\t\t    else if (curpos + fieldsize > off\n+\t\t\t     && curpos < (HOST_WIDE_INT) off + len)\n+\t\t      {\n+\t\t\t/* Partial overlap.  */\n+\t\t\tunsigned char *p = NULL;\n+\t\t\tint no = 0;\n+\t\t\tint l;\n+\t\t\tif (curpos >= off)\n+\t\t\t  {\n+\t\t\t    if (ptr)\n+\t\t\t      p = ptr + curpos - off;\n+\t\t\t    l = MIN ((HOST_WIDE_INT) off + len - curpos,\n+\t\t\t\t     fieldsize);\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  {\n+\t\t\t    p = ptr;\n+\t\t\t    no = off - curpos;\n+\t\t\t    l = len;\n+\t\t\t  }\n+\t\t\tif (!native_encode_initializer (val, p, l, no))\n+\t\t\t  return 0;\n+\t\t      }\n+\t\t    curpos += fieldsize;\n+\t\t  }\n+\t\twhile (count-- != 0);\n+\t    }\n+\t  return MIN (total_bytes - off, len);\n+\t}\n+      else if (TREE_CODE (type) == RECORD_TYPE\n+\t       || TREE_CODE (type) == UNION_TYPE)\n+\t{\n+\t  unsigned HOST_WIDE_INT cnt;\n+\t  constructor_elt *ce;\n+\n+\t  if (ptr != NULL)\n+\t    memset (ptr, '\\0', MIN (total_bytes - off, len));\n+\t  FOR_EACH_VEC_SAFE_ELT (CONSTRUCTOR_ELTS (init), cnt, ce)\n+\t    {\n+\t      tree field = ce->index;\n+\t      tree val = ce->value;\n+\t      HOST_WIDE_INT pos, fieldsize;\n+\n+\t      if (field == NULL_TREE)\n+\t\treturn 0;\n+\n+\t      pos = int_byte_position (field);\n+\t      if (off != -1 && (HOST_WIDE_INT) off + len <= pos)\n+\t\tcontinue;\n+\n+\t      if (TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE\n+\t\t  && TYPE_DOMAIN (TREE_TYPE (field))\n+\t\t  && ! TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (field))))\n+\t\treturn 0;\n+\t      if (DECL_SIZE_UNIT (field) == NULL_TREE\n+\t\t  || !tree_fits_shwi_p (DECL_SIZE_UNIT (field)))\n+\t\treturn 0;\n+\t      fieldsize = tree_to_shwi (DECL_SIZE_UNIT (field));\n+\t      if (fieldsize == 0)\n+\t\tcontinue;\n+\n+\t      if (off != -1 && pos + fieldsize <= off)\n+\t\tcontinue;\n+\n+\t      if (DECL_BIT_FIELD (field))\n+\t\treturn 0;\n+\n+\t      if (val == NULL_TREE)\n+\t\tcontinue;\n+\n+\t      if (off == -1\n+\t\t  || (pos >= off\n+\t\t      && (pos + fieldsize <= (HOST_WIDE_INT) off + len)))\n+\t\t{\n+\t\t  if (!native_encode_initializer (val, ptr ? ptr + pos - o\n+\t\t\t\t\t\t\t   : NULL,\n+\t\t\t\t\t\t  fieldsize,\n+\t\t\t\t\t\t  off == -1 ? -1 : 0))\n+\t\t    return 0;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Partial overlap.  */\n+\t\t  unsigned char *p = NULL;\n+\t\t  int no = 0;\n+\t\t  int l;\n+\t\t  if (pos >= off)\n+\t\t    {\n+\t\t      if (ptr)\n+\t\t\tp = ptr + pos - off;\n+\t\t      l = MIN ((HOST_WIDE_INT) off + len - pos,\n+\t\t\t\tfieldsize);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      p = ptr;\n+\t\t      no = off - pos;\n+\t\t      l = len;\n+\t\t    }\n+\t\t  if (!native_encode_initializer (val, p, l, no))\n+\t\t    return 0;\n+\t\t}\n+\t    }\n+\t  return MIN (total_bytes - off, len);\n+\t}\n+      return 0;\n+    }\n+}\n+\n \n /* Subroutine of native_interpret_expr.  Interpret the contents of\n    the buffer PTR of length LEN as an INTEGER_CST of type TYPE.\n@@ -8129,7 +8334,7 @@ native_interpret_expr (tree type, const unsigned char *ptr, int len)\n /* Returns true if we can interpret the contents of a native encoding\n    as TYPE.  */\n \n-static bool\n+bool\n can_native_interpret_type_p (tree type)\n {\n   switch (TREE_CODE (type))"}, {"sha": "7ac792f16a80903b4dd5d5d5dbe0602a8f58e5c5", "filename": "gcc/fold-const.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea69031c5facc70e4a96df83cd58702900fd54b6/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea69031c5facc70e4a96df83cd58702900fd54b6/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=ea69031c5facc70e4a96df83cd58702900fd54b6", "patch": "@@ -26,7 +26,10 @@ extern int folding_initializer;\n \n /* Convert between trees and native memory representation.  */\n extern int native_encode_expr (const_tree, unsigned char *, int, int off = -1);\n+extern int native_encode_initializer (tree, unsigned char *, int,\n+\t\t\t\t      int off = -1);\n extern tree native_interpret_expr (tree, const unsigned char *, int);\n+extern bool can_native_interpret_type_p (tree);\n \n /* Fold constants as much as possible in an expression.\n    Returns the simplified expression."}, {"sha": "569f91e492e53764233eaabed6e5abd8c25d315e", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea69031c5facc70e4a96df83cd58702900fd54b6/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea69031c5facc70e4a96df83cd58702900fd54b6/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=ea69031c5facc70e4a96df83cd58702900fd54b6", "patch": "@@ -6919,8 +6919,10 @@ fold_ctor_reference (tree type, tree ctor, const poly_uint64 &poly_offset,\n   if (CONSTANT_CLASS_P (ctor)\n       && BITS_PER_UNIT == 8\n       && offset % BITS_PER_UNIT == 0\n+      && offset / BITS_PER_UNIT <= INT_MAX\n       && size % BITS_PER_UNIT == 0\n-      && size <= MAX_BITSIZE_MODE_ANY_MODE)\n+      && size <= MAX_BITSIZE_MODE_ANY_MODE\n+      && can_native_interpret_type_p (type))\n     {\n       unsigned char buf[MAX_BITSIZE_MODE_ANY_MODE / BITS_PER_UNIT];\n       int len = native_encode_expr (ctor, buf, size / BITS_PER_UNIT,\n@@ -6934,13 +6936,35 @@ fold_ctor_reference (tree type, tree ctor, const poly_uint64 &poly_offset,\n       if (!suboff)\n \tsuboff = &dummy;\n \n+      tree ret;\n       if (TREE_CODE (TREE_TYPE (ctor)) == ARRAY_TYPE\n \t  || TREE_CODE (TREE_TYPE (ctor)) == VECTOR_TYPE)\n-\treturn fold_array_ctor_reference (type, ctor, offset, size,\n-\t\t\t\t\t  from_decl, suboff);\n+\tret = fold_array_ctor_reference (type, ctor, offset, size,\n+\t\t\t\t\t from_decl, suboff);\n+      else\n+\tret = fold_nonarray_ctor_reference (type, ctor, offset, size,\n+\t\t\t\t\t    from_decl, suboff);\n+\n+      /* Fall back to native_encode_initializer.  Needs to be done\n+\t only in the outermost fold_ctor_reference call (because it itself\n+\t recurses into CONSTRUCTORs) and doesn't update suboff.  */\n+      if (ret == NULL_TREE\n+\t  && suboff == &dummy\n+\t  && BITS_PER_UNIT == 8\n+\t  && offset % BITS_PER_UNIT == 0\n+\t  && offset / BITS_PER_UNIT <= INT_MAX\n+\t  && size % BITS_PER_UNIT == 0\n+\t  && size <= MAX_BITSIZE_MODE_ANY_MODE\n+\t  && can_native_interpret_type_p (type))\n+\t{\n+\t  unsigned char buf[MAX_BITSIZE_MODE_ANY_MODE / BITS_PER_UNIT];\n+\t  int len = native_encode_initializer (ctor, buf, size / BITS_PER_UNIT,\n+\t\t\t\t\t       offset / BITS_PER_UNIT);\n+\t  if (len > 0)\n+\t    return native_interpret_expr (type, buf, len);\n+\t}\n \n-      return fold_nonarray_ctor_reference (type, ctor, offset, size,\n-\t\t\t\t\t   from_decl, suboff);\n+      return ret;\n     }\n \n   return NULL_TREE;\n@@ -7049,7 +7073,7 @@ fold_const_aggregate_ref_1 (tree t, tree (*valueize) (tree))\n \ttree c = fold_const_aggregate_ref_1 (TREE_OPERAND (t, 0), valueize);\n \tif (c && TREE_CODE (c) == COMPLEX_CST)\n \t  return fold_build1_loc (EXPR_LOCATION (t),\n-\t\t\t      TREE_CODE (t), TREE_TYPE (t), c);\n+\t\t\t\t  TREE_CODE (t), TREE_TYPE (t), c);\n \tbreak;\n       }\n "}, {"sha": "527d53bf0efea1ead117fc7731f8d558d4e83476", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea69031c5facc70e4a96df83cd58702900fd54b6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea69031c5facc70e4a96df83cd58702900fd54b6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ea69031c5facc70e4a96df83cd58702900fd54b6", "patch": "@@ -1,3 +1,9 @@\n+2020-01-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/93210\n+\t* gcc.dg/pr93210.c: New test.\n+\t* g++.dg/opt/pr93210.C: New test.\n+\n 2020-01-10  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR inline-asm/93027"}, {"sha": "11ade7be7850ee0f20242ca30796598ed267abf8", "filename": "gcc/testsuite/g++.dg/opt/pr93210.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea69031c5facc70e4a96df83cd58702900fd54b6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr93210.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea69031c5facc70e4a96df83cd58702900fd54b6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr93210.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr93210.C?ref=ea69031c5facc70e4a96df83cd58702900fd54b6", "patch": "@@ -0,0 +1,37 @@\n+// PR tree-optimization/93210\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-O2 -fdump-tree-optimized\" }\n+// { dg-final { scan-tree-dump-not \"static_member\\.d\" \"optimized\" } }\n+\n+union U { struct { unsigned int a, b; } c; unsigned long long d; };\n+\n+inline\n+bool operator == (U const &x, U const &y) noexcept\n+{\n+  return x.d == y.d;\n+};\n+\n+struct S\n+{\n+  static constexpr U static_member = { { 13, 42 } };\n+  bool foo (U const &y) const noexcept;\n+  bool bar (U const &y) const noexcept;\n+};\n+\n+#if __cpp_inline_variables < 201606L\n+constexpr U S::static_member;\n+#endif\n+\n+#if __SIZEOF_INT__ * 2 == __SIZEOF_LONG_LONG__\n+bool\n+S::foo (U const &y) const noexcept\n+{\n+  return static_member == y;\n+}\n+\n+bool\n+S::bar (U const &y) const noexcept\n+{\n+  return U (static_member) == y;\n+}\n+#endif"}, {"sha": "ec4194b6b49f8f30170e464eb20eacb91fa7a92e", "filename": "gcc/testsuite/gcc.dg/pr93210.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea69031c5facc70e4a96df83cd58702900fd54b6/gcc%2Ftestsuite%2Fgcc.dg%2Fpr93210.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea69031c5facc70e4a96df83cd58702900fd54b6/gcc%2Ftestsuite%2Fgcc.dg%2Fpr93210.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr93210.c?ref=ea69031c5facc70e4a96df83cd58702900fd54b6", "patch": "@@ -0,0 +1,66 @@\n+/* PR tree-optimization/93210 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-times \"return \\[0-9]\\[0-9a-fA-FxX]*;\" 31 \"optimized\" } } */\n+\n+#ifdef __SIZEOF_INT128__\n+typedef unsigned __int128 L;\n+#else\n+typedef unsigned long long L;\n+#endif\n+struct S { signed char a, b; unsigned char c; };\n+struct T { signed char d; struct S e[25]; signed char f; };\n+union U { struct T g; L h[10]; };\n+const union U u = { { 1, { { 2, 3, 4 }, { 5, 6, 7 }, { 8, 9, 10 },\n+                           { 12, 13, 14 }, { 15, 16, 17 }, { 18, 19, 20 },\n+                           { 22, 23, 24 }, { 25, 26, 27 }, { 28, 29, 30 },\n+                           { 32, 33, 34 }, { 35, 36, 37 }, { 38, 39, 40 },\n+                           { 42, 43, 44 }, { 45, 46, 47 }, { 48, 49, 50 },\n+                           { 52, 53, 54 }, { 55, 56, 57 }, { 58, 59, 60 },\n+                           { 62, 63, 64 }, { 65, 66, 67 }, { 68, 69, 70 },\n+                           { 72, 73, 74 }, { 75, 76, 77 }, { 78, 79, 80 },\n+                           { 82, 83, 84 } }, 85 } };\n+const union U v = { { 1, { { 2, 3, 4 }, [1 ... 23] = { 5, 6, 7 },\n+\t\t\t   { 8, 9, 10 } }, 86 } };\n+struct A { char a[5]; char b[16]; char c[7]; };\n+union V { struct A d; unsigned int e[10]; };\n+const union V w = { { \"abcde\", \"ijkl\", \"mnopqr\" } };\n+#define N(n) __attribute__((noipa)) L foo##n (void) { return u.h[n]; }\n+#define M N(0) N(1) N(2) N(3) N(4) N(5) N(6) N(7) N(8) N(9)\n+M\n+#undef N\n+#define N(n) __attribute__((noipa)) L bar##n (void) { return v.h[n]; }\n+M\n+#undef N\n+#define N(n) __attribute__((noipa)) L baz##n (void) { return w.e[n]; }\n+M\n+\n+typedef L (*F) (void);\n+F arr[30] = {\n+#undef N\n+#define N(n) foo##n,\n+M\n+#undef N\n+#define N(n) bar##n,\n+M\n+#undef N\n+#define N(n) baz##n,\n+M\n+};\n+\n+int\n+main ()\n+{\n+  const union U *p = &u;\n+  const union U *q = &v;\n+  const union V *r = &w;\n+  __asm (\"\" : \"+g\" (p));\n+  __asm (\"\" : \"+g\" (q));\n+  __asm (\"\" : \"+g\" (r));\n+  for (int i = 0; i < 10; i++)\n+    if (arr[i] () != p->h[i]\n+\t|| arr[i + 10] () != q->h[i]\n+\t|| arr[i + 20] () != r->e[i])\n+      __builtin_abort ();\n+  return 0;\n+}"}]}