{"sha": "fca9dc00583665bb89e63df672ba2f2184bb9ee6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNhOWRjMDA1ODM2NjViYjg5ZTYzZGY2NzJiYTJmMjE4NGJiOWVlNg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2003-10-19T21:37:32Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2003-10-19T21:37:32Z"}, "message": "Makefile.in (toplev.o): Add value-prof.h dependency.\n\n\t* Makefile.in (toplev.o): Add value-prof.h dependency.\n\t(value-prof.o): Add REGS_H dependency.\n\t* common.opt (fprofile-values, fvpt): New.\n\t* flags.h (flag_value_profile_transformations): Declare.\n\t* opts.c (common_handle_option): Handle -fprofile_values and\n\t-fvpt.\n\t* profile.c (branch_prob): Don't remove death notes here.\n\t* timevar.def (TV_VPT): New.\n\t* value-prof.c: Include regs.h.\n\t(insn_divmod_values_to_profile, gen_divmod_fixed_value, gen_mod_pow2,\n\tgen_mod_subtract, divmod_fixed_value_transform,mod_pow2_value_transform,\n\tmod_subtract_transform, value_profile_transformations): New.\n\t(insn_values_to_profile): Call insn_divmod_values_to_profile.\n\t(find_values_to_profile): Add dumps.\n\t* value-prof.h (value_profile_transformations): Declare.\n\t* toplev.c: Include value-prof.h.\n\t(rest_of_handle_value_profile_transformations): New.\n\t(enum dump_file_index): Add DFI_vpt.\n\t(dump_file): Add vpt dump.\n\t(flag_value_profile_transformations): New.\n\t(lang_independent_options): Add flag_profile_values and\n\tflag_value_profile_transformations.\n\t(rest_of_compilation): Call\n\trest_of_handle_value_profile_transformations.\n\t(process_options): Let -fvpt imply -fprofile-values.\n\t* doc/invoke.texi (-fvpt): Document.\n\nFrom-SVN: r72685", "tree": {"sha": "c3c61559cf453a985bdb4923c4ed4eae300f5c6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3c61559cf453a985bdb4923c4ed4eae300f5c6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fca9dc00583665bb89e63df672ba2f2184bb9ee6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fca9dc00583665bb89e63df672ba2f2184bb9ee6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fca9dc00583665bb89e63df672ba2f2184bb9ee6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fca9dc00583665bb89e63df672ba2f2184bb9ee6/comments", "author": null, "committer": null, "parents": [{"sha": "47395a24e6a35ef07316b593fb17bf4d767707a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47395a24e6a35ef07316b593fb17bf4d767707a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47395a24e6a35ef07316b593fb17bf4d767707a7"}], "stats": {"total": 713, "additions": 703, "deletions": 10}, "files": [{"sha": "5dc8b6803f51d67091db2c1fa0da1f7169bffab2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fca9dc00583665bb89e63df672ba2f2184bb9ee6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fca9dc00583665bb89e63df672ba2f2184bb9ee6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fca9dc00583665bb89e63df672ba2f2184bb9ee6", "patch": "@@ -1,3 +1,32 @@\n+2003-10-19  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* Makefile.in (toplev.o): Add value-prof.h dependency.\n+\t(value-prof.o): Add REGS_H dependency.\n+\t* common.opt (fprofile-values, fvpt): New.\n+\t* flags.h (flag_value_profile_transformations): Declare.\n+\t* opts.c (common_handle_option): Handle -fprofile_values and\n+\t-fvpt.\n+\t* profile.c (branch_prob): Don't remove death notes here.\n+\t* timevar.def (TV_VPT): New.\n+\t* value-prof.c: Include regs.h.\n+\t(insn_divmod_values_to_profile, gen_divmod_fixed_value, gen_mod_pow2,\n+\tgen_mod_subtract, divmod_fixed_value_transform,mod_pow2_value_transform,\n+\tmod_subtract_transform, value_profile_transformations): New.\n+\t(insn_values_to_profile): Call insn_divmod_values_to_profile.\n+\t(find_values_to_profile): Add dumps.\n+\t* value-prof.h (value_profile_transformations): Declare.\n+\t* toplev.c: Include value-prof.h.\n+\t(rest_of_handle_value_profile_transformations): New.\n+\t(enum dump_file_index): Add DFI_vpt.\n+\t(dump_file): Add vpt dump.\n+\t(flag_value_profile_transformations): New.\n+\t(lang_independent_options): Add flag_profile_values and\n+\tflag_value_profile_transformations.\n+\t(rest_of_compilation): Call\n+\trest_of_handle_value_profile_transformations.\n+\t(process_options): Let -fvpt imply -fprofile-values.\n+\t* doc/invoke.texi (-fvpt): Document.\n+\n 2003-10-19  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.c (print_reg): Do not abort on certain registers."}, {"sha": "7ba6b7d0089e81ed8b297fe05e1560eab4e44c06", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fca9dc00583665bb89e63df672ba2f2184bb9ee6/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fca9dc00583665bb89e63df672ba2f2184bb9ee6/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=fca9dc00583665bb89e63df672ba2f2184bb9ee6", "patch": "@@ -1499,7 +1499,7 @@ toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_\n    function.h flags.h xcoffout.h input.h $(INSN_ATTR_H) output.h $(DIAGNOSTIC_H) \\\n    debug.h insn-config.h intl.h $(RECOG_H) Makefile toplev.h \\\n    dwarf2out.h sdbout.h dbxout.h $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) \\\n-   graph.h $(LOOP_H) except.h $(REGS_H) $(TIMEVAR_H) \\\n+   graph.h $(LOOP_H) except.h $(REGS_H) $(TIMEVAR_H) value-prof.h \\\n    ssa.h $(PARAMS_H) $(TM_P_H) reload.h dwarf2asm.h $(TARGET_H) \\\n    langhooks.h insn-flags.h cfglayout.h real.h cfgloop.h \\\n    hosthooks.h $(LANGHOOKS_DEF_H) cgraph.h $(COVERAGE_H)\n@@ -1653,7 +1653,7 @@ profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    toplev.h $(BASIC_BLOCK_H) $(COVERAGE_H) $(TREE_H) value-prof.h\n value-prof.o : value-prof.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h value-prof.h $(EXPR_H) output.h flags.h \\\n-   $(RECOG_H) insn-config.h $(OPTABS_H)\n+   $(RECOG_H) insn-config.h $(OPTABS_H) $(REGS_H)\n loop.o : loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h $(LOOP_H) \\\n    insn-config.h $(REGS_H) hard-reg-set.h $(RECOG_H) $(EXPR_H) \\\n    real.h $(PREDICT_H) $(BASIC_BLOCK_H) function.h cfgloop.h \\"}, {"sha": "2ad0e0a58f6280510fc2365e68ad0ee40abaec21", "filename": "gcc/common.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fca9dc00583665bb89e63df672ba2f2184bb9ee6/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fca9dc00583665bb89e63df672ba2f2184bb9ee6/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=fca9dc00583665bb89e63df672ba2f2184bb9ee6", "patch": "@@ -517,6 +517,10 @@ fprofile-arcs\n Common\n Insert arc-based program profiling code\n \n+fprofile-values\n+Common\n+Insert code to profile values of expressions\n+\n frandom-seed\n Common\n \n@@ -719,6 +723,10 @@ fverbose-asm\n Common\n Add extra commentary to assembler output\n \n+fvpt\n+Common\n+Use expression value profiles in optimizations\n+\n fweb\n Common\n Construct webs and split unrelated uses of single variable"}, {"sha": "c99af2cb4d6fdb4f7a8047ec486d555c61ed3983", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fca9dc00583665bb89e63df672ba2f2184bb9ee6/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fca9dc00583665bb89e63df672ba2f2184bb9ee6/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=fca9dc00583665bb89e63df672ba2f2184bb9ee6", "patch": "@@ -264,7 +264,7 @@ in the following sections.\n @xref{Optimize Options,,Options that Control Optimization}.\n @gccoptlist{-falign-functions=@var{n}  -falign-jumps=@var{n} @gol\n -falign-labels=@var{n}  -falign-loops=@var{n}  @gol\n--fbranch-probabilities -fprofile-values -fbranch-target-load-optimize @gol\n+-fbranch-probabilities -fprofile-values -fvpt -fbranch-target-load-optimize @gol\n -fbranch-target-load-optimize2 -fcaller-saves  -fcprop-registers @gol\n -fcse-follow-jumps  -fcse-skip-blocks  -fdata-sections @gol\n -fdelayed-branch  -fdelete-null-pointer-checks @gol\n@@ -4564,6 +4564,16 @@ With @option{-fbranch-probabilities}, it reads back the data gathered\n from profiling values of expressions and adds @samp{REG_VALUE_PROFILE}\n notes to instructions for their later usage in optimizations.\n \n+@item -fvpt\n+@opindex fvpt\n+If combined with @option{-fprofile-arcs}, it instructs the compiler to add\n+a code to gather information about values of expressions.\n+\n+With @option{-fbranch-probabilities}, it reads back the data gathered\n+and actually performs the optimizations based on them.\n+Currently the optimizations include specialization of division operation\n+using the knowledge about the value of the denominator.\n+\n @item -fnew-ra\n @opindex fnew-ra\n Use a graph coloring register allocator.  Currently this option is meant"}, {"sha": "5b6f7283b6c0f57e0e16b0dba3709bc510e1071e", "filename": "gcc/flags.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fca9dc00583665bb89e63df672ba2f2184bb9ee6/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fca9dc00583665bb89e63df672ba2f2184bb9ee6/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=fca9dc00583665bb89e63df672ba2f2184bb9ee6", "patch": "@@ -680,6 +680,9 @@ extern int flag_gcse_sm;\n \n extern int flag_gcse_las;\n \n+/* Nonzero if value histograms should be used to optimize code.  */\n+extern int flag_value_profile_transformations;\n+\n /* Perform branch target register optimization before prologue / epilogue\n    threading.  */\n "}, {"sha": "6439e26670f039e10c03f8038c69fd7dd6aa09c6", "filename": "gcc/opts.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fca9dc00583665bb89e63df672ba2f2184bb9ee6/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fca9dc00583665bb89e63df672ba2f2184bb9ee6/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=fca9dc00583665bb89e63df672ba2f2184bb9ee6", "patch": "@@ -1182,6 +1182,14 @@ common_handle_option (size_t scode, const char *arg,\n       profile_arc_flag = value;\n       break;\n \n+    case OPT_fprofile_values:\n+      flag_profile_values = value;\n+      break;\n+\n+    case OPT_fvpt:\n+      flag_value_profile_transformations = value;\n+      break;\n+\n     case OPT_frandom_seed:\n       /* The real switch is -fno-random-seed.  */\n       if (value)"}, {"sha": "625a904a428cba96e75bab2f00867bb91ec7e922", "filename": "gcc/profile.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fca9dc00583665bb89e63df672ba2f2184bb9ee6/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fca9dc00583665bb89e63df672ba2f2184bb9ee6/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=fca9dc00583665bb89e63df672ba2f2184bb9ee6", "patch": "@@ -988,8 +988,6 @@ branch_prob (void)\n       allocate_reg_info (max_reg_num (), FALSE, FALSE);\n     }\n \n-  if (flag_profile_values)\n-    count_or_remove_death_notes (NULL, 1);\n   remove_fake_edges ();\n   free_aux_for_edges ();\n   /* Re-merge split basic blocks and the mess introduced by"}, {"sha": "74fda87e8379812f1016f0507fa4800f144ee2c3", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fca9dc00583665bb89e63df672ba2f2184bb9ee6/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fca9dc00583665bb89e63df672ba2f2184bb9ee6/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=fca9dc00583665bb89e63df672ba2f2184bb9ee6", "patch": "@@ -72,6 +72,7 @@ DEFTIMEVAR (TV_TRACER                , \"tracer\")\n DEFTIMEVAR (TV_WEB                   , \"web\")\n DEFTIMEVAR (TV_CSE2                  , \"CSE 2\")\n DEFTIMEVAR (TV_BRANCH_PROB           , \"branch prediction\")\n+DEFTIMEVAR (TV_VPT                   , \"value profile opts\")\n DEFTIMEVAR (TV_FLOW                  , \"flow analysis\")\n DEFTIMEVAR (TV_COMBINE               , \"combiner\")\n DEFTIMEVAR (TV_IFCVT\t\t     , \"if-conversion\")"}, {"sha": "151f6c652806bdbb0e568b7a864e2202cf73723f", "filename": "gcc/toplev.c", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fca9dc00583665bb89e63df672ba2f2184bb9ee6/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fca9dc00583665bb89e63df672ba2f2184bb9ee6/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=fca9dc00583665bb89e63df672ba2f2184bb9ee6", "patch": "@@ -78,6 +78,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"cgraph.h\"\n #include \"opts.h\"\n #include \"coverage.h\"\n+#include \"value-prof.h\"\n \n #if defined (DWARF2_UNWIND_INFO) || defined (DWARF2_DEBUGGING_INFO)\n #include \"dwarf2out.h\"\n@@ -137,6 +138,7 @@ static void rest_of_handle_null_pointer (tree, rtx);\n static void rest_of_handle_addressof (tree, rtx);\n static void rest_of_handle_cfg (tree, rtx);\n static void rest_of_handle_branch_prob (tree, rtx);\n+static void rest_of_handle_value_profile_transformations (tree, rtx);\n static void rest_of_handle_if_conversion (tree, rtx);\n static void rest_of_handle_if_after_combine (tree, rtx);\n static void rest_of_handle_tracer (tree, rtx);\n@@ -264,6 +266,7 @@ enum dump_file_index\n   DFI_bypass,\n   DFI_cfg,\n   DFI_bp,\n+  DFI_vpt,\n   DFI_ce1,\n   DFI_tracer,\n   DFI_web,\n@@ -296,7 +299,7 @@ enum dump_file_index\n    Remaining -d letters:\n \n \t\"            m   q         \"\n-\t\"         JK   O Q    V  Y \"\n+\t\"         JK   O Q       Y \"\n */\n \n static struct dump_file_info dump_file[DFI_MAX] =\n@@ -318,6 +321,7 @@ static struct dump_file_info dump_file[DFI_MAX] =\n   { \"bypass\",   'G', 1, 0, 0 }, /* Yes, duplicate enable switch.  */\n   { \"cfg\",\t'f', 1, 0, 0 },\n   { \"bp\",\t'b', 1, 0, 0 },\n+  { \"vpt\",\t'V', 1, 0, 0 },\n   { \"ce1\",\t'C', 1, 0, 0 },\n   { \"tracer\",\t'T', 1, 0, 0 },\n   { \"web\",      'Z', 0, 0, 0 },\n@@ -404,6 +408,9 @@ int profile_arc_flag = 0;\n \n int flag_profile_values = 0;\n \n+/* Nonzero if value histograms should be used to optimize code.  */\n+int flag_value_profile_transformations = 0;\n+\n /* Nonzero if generating info for gcov to calculate line test coverage.  */\n \n int flag_test_coverage = 0;\n@@ -1110,6 +1117,8 @@ static const lang_independent_options f_options[] =\n   {\"asynchronous-unwind-tables\", &flag_asynchronous_unwind_tables, 1 },\n   {\"non-call-exceptions\", &flag_non_call_exceptions, 1 },\n   {\"profile-arcs\", &profile_arc_flag, 1 },\n+  {\"profile-values\", &flag_profile_values, 1 },\n+  {\"vpt\", &flag_value_profile_transformations, 1 },\n   {\"test-coverage\", &flag_test_coverage, 1 },\n   {\"branch-probabilities\", &flag_branch_probabilities, 1 },\n   {\"profile\", &profile_flag, 1 },\n@@ -2462,6 +2471,7 @@ rest_of_handle_branch_prob (tree decl, rtx insns)\n \n   timevar_push (TV_BRANCH_PROB);\n   open_dump_file (DFI_bp, decl);\n+\n   if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n     branch_prob ();\n \n@@ -2481,6 +2491,20 @@ rest_of_handle_branch_prob (tree decl, rtx insns)\n   timevar_pop (TV_BRANCH_PROB);\n }\n \n+/* Do optimizations based on expression value profiles.  */\n+static void\n+rest_of_handle_value_profile_transformations (tree decl, rtx insns)\n+{\n+  open_dump_file (DFI_vpt, decl);\n+  timevar_push (TV_VPT);\n+\n+  if (value_profile_transformations ())\n+    cleanup_cfg (CLEANUP_EXPENSIVE);\n+\n+  timevar_pop (TV_VPT);\n+  close_dump_file (DFI_vpt, print_rtl_with_bb, insns);\n+}\n+\n /* Do control and data flow analysis; write some of the results to the\n    dump file.  */\n static void\n@@ -3345,7 +3369,18 @@ rest_of_compilation (tree decl)\n \n   if (optimize > 0\n       || profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n-    rest_of_handle_branch_prob (decl, insns);\n+    {\n+      rest_of_handle_branch_prob (decl, insns);\n+\n+      if (flag_branch_probabilities\n+\t  && flag_profile_values\n+\t  && flag_value_profile_transformations)\n+\trest_of_handle_value_profile_transformations (decl, insns);\n+\n+      /* Remove the death notes created for vpt.  */\n+      if (flag_profile_values)\n+\tcount_or_remove_death_notes (NULL, 1);\n+    }\n \n   if (optimize > 0)\n     rest_of_handle_if_conversion (decl, insns);\n@@ -4228,6 +4263,9 @@ process_options (void)\n   if (flag_unit_at_a_time && ! lang_hooks.callgraph.expand_function)\n     flag_unit_at_a_time = 0;\n \n+  if (flag_value_profile_transformations)\n+    flag_profile_values = 1;\n+\n   /* Warn about options that are not supported on this machine.  */\n #ifndef INSN_SCHEDULING\n   if (flag_schedule_insns || flag_schedule_insns_after_reload)"}, {"sha": "3924fa76c184cdd5664412333239f852d2890950", "filename": "gcc/value-prof.c", "status": "modified", "additions": 600, "deletions": 3, "changes": 603, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fca9dc00583665bb89e63df672ba2f2184bb9ee6/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fca9dc00583665bb89e63df672ba2f2184bb9ee6/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=fca9dc00583665bb89e63df672ba2f2184bb9ee6", "patch": "@@ -32,6 +32,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"insn-config.h\"\n #include \"recog.h\"\n #include \"optabs.h\"\n+#include \"regs.h\"\n \n /* In this file value profile based optimizations will be placed (none are\n    here just now, but they are hopefully coming soon).\n@@ -49,7 +50,17 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    -- the expression that is profiled\n    -- list of counters starting from the first one.  */\n \n+static void insn_divmod_values_to_profile (rtx, unsigned *,\n+\t\t\t\t\t   struct histogram_value **);\n static void insn_values_to_profile (rtx, unsigned *, struct histogram_value **);\n+static rtx gen_divmod_fixed_value (enum machine_mode, enum rtx_code, rtx, rtx,\n+\t\t\t\t   rtx, gcov_type);\n+static rtx gen_mod_pow2 (enum machine_mode, enum rtx_code, rtx, rtx, rtx);\n+static rtx gen_mod_subtract (enum machine_mode, enum rtx_code, rtx, rtx, rtx,\n+\t\t\t     int);\n+static bool divmod_fixed_value_transform (rtx insn);\n+static bool mod_pow2_value_transform (rtx);\n+static bool mod_subtract_transform (rtx);\n \f\n /* Release the list of VALUES of length N_VALUES for that we want to measure\n    histograms.  */\n@@ -60,13 +71,106 @@ free_profiled_values (unsigned n_values ATTRIBUTE_UNUSED,\n   free (values);\n }\n \n+/* Find values inside INSN for that we want to measure histograms for\n+   division/modulo optimization.  */\n+static void\n+insn_divmod_values_to_profile (rtx insn, unsigned *n_values,\n+\t\t\t       struct histogram_value **values)\n+{\n+  rtx set, set_src, op1, op2;\n+  enum machine_mode mode;\n+\n+  if (!INSN_P (insn))\n+    return;\n+\n+  set = single_set (insn);\n+  if (!set)\n+    return;\n+\n+  mode = GET_MODE (SET_DEST (set));\n+  if (!INTEGRAL_MODE_P (mode))\n+    return;\n+\n+  set_src = SET_SRC (set);\n+  switch (GET_CODE (set_src))\n+    {\n+    case DIV:\n+    case MOD:\n+    case UDIV:\n+    case UMOD:\n+      op1 = XEXP (set_src, 0);\n+      op2 = XEXP (set_src, 1);\n+      if (side_effects_p (op2))\n+\treturn;\n+\n+      /* Check for a special case where the divisor is power of 2.  */\n+      if ((GET_CODE (set_src) == UMOD) && !CONSTANT_P (op2))\n+\t{\n+\t  *values = xrealloc (*values,\n+\t\t\t      (*n_values + 1)\n+\t\t\t\t* sizeof (struct histogram_value));\n+\t  (*values)[*n_values].value = op2;\n+\t  (*values)[*n_values].seq = NULL_RTX;\n+\t  (*values)[*n_values].mode = mode;\n+\t  (*values)[*n_values].insn = insn;\n+\t  (*values)[*n_values].type = HIST_TYPE_POW2;\n+\t  (*values)[*n_values].hdata.pow2.may_be_other = 1;\n+\t  (*n_values)++;\n+\t}\n+\n+      /* Check whether the divisor is not in fact a constant.  */\n+      if (!CONSTANT_P (op2))\n+\t{\n+\t  *values = xrealloc (*values,\n+\t\t\t      (*n_values + 1)\n+\t\t\t\t* sizeof (struct histogram_value));\n+\t  (*values)[*n_values].value = op2;\n+\t  (*values)[*n_values].mode = mode;\n+\t  (*values)[*n_values].seq = NULL_RTX;\n+\t  (*values)[*n_values].insn = insn;\n+\t  (*values)[*n_values].type = HIST_TYPE_SINGLE_VALUE;\n+\t  (*n_values)++;\n+\t}\n+\n+      /* For mod, check whether it is not often a noop (or replacable by\n+\t a few subtractions).  */\n+      if (GET_CODE (set_src) == UMOD && !side_effects_p (op1))\n+\t{\n+\t  rtx tmp;\n+\n+\t  *values = xrealloc (*values,\n+\t\t\t      (*n_values + 1)\n+\t\t\t\t* sizeof (struct histogram_value));\n+\t  start_sequence ();\n+\t  tmp = simplify_gen_binary (DIV, mode, copy_rtx (op1), copy_rtx (op2));\n+\t  (*values)[*n_values].value = force_operand (tmp, NULL_RTX);\n+\t  (*values)[*n_values].seq = get_insns ();\n+\t  end_sequence ();\n+\t  (*values)[*n_values].mode = mode;\n+\t  (*values)[*n_values].insn = insn;\n+\t  (*values)[*n_values].type = HIST_TYPE_INTERVAL;\n+\t  (*values)[*n_values].hdata.intvl.int_start = 0;\n+\t  (*values)[*n_values].hdata.intvl.steps = 2;\n+\t  (*values)[*n_values].hdata.intvl.may_be_less = 1;\n+\t  (*values)[*n_values].hdata.intvl.may_be_more = 1;\n+\t  (*n_values)++;\n+\t}\n+      return;\n+\n+    default:\n+      return;\n+    }\n+}\n+\n /* Find values inside INSN for that we want to measure histograms and adds\n    them to list VALUES (increasing the record of its length in N_VALUES).  */\n static void\n-insn_values_to_profile (rtx insn ATTRIBUTE_UNUSED,\n-\t\t\tunsigned *n_values ATTRIBUTE_UNUSED,\n-\t\t\tstruct histogram_value **values ATTRIBUTE_UNUSED)\n+insn_values_to_profile (rtx insn,\n+\t\t\tunsigned *n_values,\n+\t\t\tstruct histogram_value **values)\n {\n+  if (flag_value_profile_transformations)\n+    insn_divmod_values_to_profile (insn, n_values, values);\n }\n \n /* Find list of values for that we want to measure histograms.  */\n@@ -86,21 +190,40 @@ find_values_to_profile (unsigned *n_values, struct histogram_value **values)\n       switch ((*values)[i].type)\n \t{\n \tcase HIST_TYPE_INTERVAL:\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file,\n+\t\t     \"Interval counter for insn %d, range %d -- %d.\\n\",\n+\t\t     INSN_UID ((*values)[i].insn),\n+\t\t     (*values)[i].hdata.intvl.int_start,\n+\t\t     ((*values)[i].hdata.intvl.int_start\n+\t\t      + (*values)[i].hdata.intvl.steps - 1));\n \t  (*values)[i].n_counters = (*values)[i].hdata.intvl.steps +\n \t\t  ((*values)[i].hdata.intvl.may_be_less ? 1 : 0) +\n \t\t  ((*values)[i].hdata.intvl.may_be_more ? 1 : 0);\n \t  break;\n \n \tcase HIST_TYPE_POW2:\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file,\n+\t\t     \"Pow2 counter for insn %d.\\n\",\n+\t\t     INSN_UID ((*values)[i].insn));\n \t  (*values)[i].n_counters = GET_MODE_BITSIZE ((*values)[i].mode) +\n \t\t  ((*values)[i].hdata.pow2.may_be_other ? 1 : 0);\n \t  break;\n \n \tcase HIST_TYPE_SINGLE_VALUE:\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file,\n+\t\t     \"Single value counter for insn %d.\\n\",\n+\t\t     INSN_UID ((*values)[i].insn));\n \t  (*values)[i].n_counters = 3;\n \t  break;\n \n \tcase HIST_TYPE_CONST_DELTA:\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file,\n+\t\t     \"Constant delta counter for insn %d.\\n\",\n+\t\t     INSN_UID ((*values)[i].insn));\n \t  (*values)[i].n_counters = 4;\n \t  break;\n \n@@ -109,3 +232,477 @@ find_values_to_profile (unsigned *n_values, struct histogram_value **values)\n \t}\n     }\n }\n+\n+/* Main entry point.  Finds REG_VALUE_PROFILE notes from profiler and uses\n+   them to identify and exploit properties of values that are hard to analyze\n+   statically.\n+\n+   We do following transformations:\n+\n+   1)\n+\n+   x = a / b;\n+\n+   where b is almost always a constant N is transformed to\n+\n+   if (b == N)\n+     x = a / N;\n+   else\n+     x = a / b;\n+\n+   Analogically with %\n+\n+   2)\n+\n+   x = a % b\n+\n+   where b is almost always a power of 2 and the division is unsigned\n+   TODO -- handle signed case as well\n+\n+   if ((b & (b - 1)) == 0)\n+     x = a & (b - 1);\n+   else\n+     x = x % b;\n+\n+   Note that when b = 0, no error will occur and x = a; this is correct,\n+   as result of such operation is undefined.\n+\n+   3)\n+\n+   x = a % b\n+\n+   where a is almost always less then b and the division is unsigned\n+   TODO -- handle signed case as well\n+\n+   x = a;\n+   if (x >= b)\n+     x %= b;\n+\n+   4)\n+\n+   x = a % b\n+\n+   where a is almost always less then 2 * b and the division is unsigned\n+   TODO -- handle signed case as well\n+\n+   x = a;\n+   if (x >= b)\n+     x -= b;\n+   if (x >= b)\n+     x %= b;\n+\n+   It would be possible to continue analogically for K * b for other small\n+   K's, but it is probably not useful.\n+\n+   TODO:\n+\n+   There are other useful cases that could be handled by a similar mechanism,\n+   for example:\n+   \n+   for (i = 0; i < n; i++)\n+     ...\n+   \n+   transform to (for constant N):\n+   \n+   if (n == N)\n+     for (i = 0; i < N; i++)\n+       ...\n+   else\n+     for (i = 0; i < n; i++)\n+       ...\n+   making unroller happy.  Since this may grow the code significantly,\n+   we would have to be very careful here.  */\n+\n+bool\n+value_profile_transformations ()\n+{\n+  rtx insn, next;\n+  int changed = false;\n+\n+  for (insn = get_insns (); insn; insn = next)\n+    {\n+      next = NEXT_INSN (insn);\n+\n+      if (!INSN_P (insn))\n+\tcontinue;\n+\n+      /* Scan for insn carrying a histogram.  */\n+      if (!find_reg_note (insn, REG_VALUE_PROFILE, 0))\n+\tcontinue;\n+\n+      /* Ignore cold areas -- we are growing a code.  */\n+      if (!maybe_hot_bb_p (BLOCK_FOR_INSN (insn)))\n+\tcontinue;\n+\n+      if (rtl_dump_file)\n+\t{\n+\t  fprintf (rtl_dump_file, \"Trying transformations on insn %d\\n\",\n+\t\t   INSN_UID (insn));\n+\t  print_rtl_single (rtl_dump_file, insn);\n+\t}\n+\n+      /* Transformations:  */\n+      if (flag_value_profile_transformations\n+\t  && (mod_subtract_transform (insn)\n+\t      || divmod_fixed_value_transform (insn)\n+\t      || mod_pow2_value_transform (insn)))\n+\tchanged = true;\n+    }\n+\n+  if (changed)\n+    {\n+      commit_edge_insertions ();\n+      allocate_reg_info (max_reg_num (), FALSE, FALSE);\n+    }\n+\n+  return changed;\n+}\n+\n+/* Generate code for transformation 1 (with MODE and OPERATION, operands OP1\n+   and OP2 whose value is expected to be VALUE and result TARGET).  */\n+static rtx\n+gen_divmod_fixed_value (enum machine_mode mode, enum rtx_code operation,\n+\t\t\trtx target, rtx op1, rtx op2, gcov_type value)\n+{\n+  rtx tmp, tmp1;\n+  rtx neq_label = gen_label_rtx ();\n+  rtx end_label = gen_label_rtx ();\n+  rtx sequence;\n+\n+  start_sequence ();\n+  \n+  if (!REG_P (op2))\n+    {\n+      tmp = gen_reg_rtx (mode);\n+      emit_move_insn (tmp, copy_rtx (op2));\n+    }\n+  else\n+    tmp = op2;\n+\n+  do_compare_rtx_and_jump (tmp, GEN_INT (value), NE, 0, mode, NULL_RTX,\n+\t\t\t   NULL_RTX, neq_label);\n+  tmp1 = simplify_gen_binary (operation, mode, copy_rtx (op1), GEN_INT (value));\n+  tmp1 = force_operand (tmp1, target);\n+  if (tmp1 != target)\n+    emit_move_insn (copy_rtx (target), copy_rtx (tmp1));\n+\n+  emit_jump_insn (gen_jump (end_label));\n+  emit_barrier ();\n+\n+  emit_label (neq_label);\n+  tmp1 = simplify_gen_binary (operation, mode, copy_rtx (op1), copy_rtx (tmp));\n+  tmp1 = force_operand (tmp1, target);\n+  if (tmp1 != target)\n+    emit_move_insn (copy_rtx (target), copy_rtx (tmp1));\n+  \n+  emit_label (end_label);\n+\n+  sequence = get_insns ();\n+  end_sequence ();\n+  rebuild_jump_labels (sequence);\n+  return sequence;\n+}\n+\n+/* Do transform 1) on INSN if applicable.  */\n+static bool\n+divmod_fixed_value_transform (rtx insn)\n+{\n+  rtx set, set_src, set_dest, op1, op2, value, histogram;\n+  enum rtx_code code;\n+  enum machine_mode mode;\n+  gcov_type val, count, all;\n+  edge e;\n+\n+  set = single_set (insn);\n+  if (!set)\n+    return false;\n+\n+  set_src = SET_SRC (set);\n+  set_dest = SET_DEST (set);\n+  code = GET_CODE (set_src);\n+  mode = GET_MODE (set_dest);\n+  \n+  if (code != DIV && code != MOD && code != UDIV && code != UMOD)\n+    return false;\n+  op1 = XEXP (set_src, false);\n+  op2 = XEXP (set_src, 1);\n+\n+  for (histogram = REG_NOTES (insn);\n+       histogram;\n+       histogram = XEXP (histogram, 1))\n+    if (REG_NOTE_KIND (histogram) == REG_VALUE_PROFILE\n+\t&& XEXP (XEXP (histogram, 0), 0) == GEN_INT (HIST_TYPE_SINGLE_VALUE))\n+      break;\n+\n+  if (!histogram)\n+    return false;\n+\n+  histogram = XEXP (XEXP (histogram, 0), 1);\n+  value = XEXP (histogram, 0);\n+  histogram = XEXP (histogram, 1);\n+  val = INTVAL (XEXP (histogram, 0));\n+  histogram = XEXP (histogram, 1);\n+  count = INTVAL (XEXP (histogram, 0));\n+  histogram = XEXP (histogram, 1);\n+  all = INTVAL (XEXP (histogram, 0));\n+\n+  /* We requiere that count is at least half of all; this means\n+     that for the transformation to fire the value must be constant\n+     at least 50% of time (and 75% gives the garantee of usage).  */\n+  if (!rtx_equal_p (op2, value) || 2 * count < all)\n+    return false;\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"Div/mod by constant transformation on insn %d\\n\",\n+\t     INSN_UID (insn));\n+\n+  e = split_block (BLOCK_FOR_INSN (insn), PREV_INSN (insn));\n+  delete_insn (insn);\n+  \n+  insert_insn_on_edge (\n+\tgen_divmod_fixed_value (mode, code, set_dest, op1, op2, val), e);\n+\n+  return true;\n+}\n+\n+/* Generate code for transformation 2 (with MODE and OPERATION, operands OP1\n+   and OP2 and result TARGET).  */\n+static rtx\n+gen_mod_pow2 (enum machine_mode mode, enum rtx_code operation, rtx target,\n+\t      rtx op1, rtx op2)\n+{\n+  rtx tmp, tmp1, tmp2, tmp3;\n+  rtx neq_label = gen_label_rtx ();\n+  rtx end_label = gen_label_rtx ();\n+  rtx sequence;\n+\n+  start_sequence ();\n+  \n+  if (!REG_P (op2))\n+    {\n+      tmp = gen_reg_rtx (mode);\n+      emit_move_insn (tmp, copy_rtx (op2));\n+    }\n+  else\n+    tmp = op2;\n+\n+  tmp1 = expand_simple_binop (mode, PLUS, tmp, constm1_rtx, NULL_RTX,\n+\t\t\t      0, OPTAB_WIDEN);\n+  tmp2 = expand_simple_binop (mode, AND, tmp, tmp1, NULL_RTX,\n+\t\t\t      0, OPTAB_WIDEN);\n+  do_compare_rtx_and_jump (tmp2, const0_rtx, NE, 0, mode, NULL_RTX,\n+\t\t\t   NULL_RTX, neq_label);\n+  tmp3 = expand_simple_binop (mode, AND, op1, tmp1, target,\n+\t\t\t      0, OPTAB_WIDEN);\n+  if (tmp3 != target)\n+    emit_move_insn (copy_rtx (target), tmp3);\n+  emit_jump_insn (gen_jump (end_label));\n+  emit_barrier ();\n+\n+  emit_label (neq_label);\n+  tmp1 = simplify_gen_binary (operation, mode, copy_rtx (op1), copy_rtx (tmp));\n+  tmp1 = force_operand (tmp1, target);\n+  if (tmp1 != target)\n+    emit_move_insn (target, tmp1);\n+  \n+  emit_label (end_label);\n+\n+  sequence = get_insns ();\n+  end_sequence ();\n+  rebuild_jump_labels (sequence);\n+  return sequence;\n+}\n+\n+/* Do transform 2) on INSN if applicable.  */\n+static bool\n+mod_pow2_value_transform (rtx insn)\n+{\n+  rtx set, set_src, set_dest, op1, op2, value, histogram;\n+  enum rtx_code code;\n+  enum machine_mode mode;\n+  gcov_type wrong_values, count;\n+  edge e;\n+  int i;\n+\n+  set = single_set (insn);\n+  if (!set)\n+    return false;\n+\n+  set_src = SET_SRC (set);\n+  set_dest = SET_DEST (set);\n+  code = GET_CODE (set_src);\n+  mode = GET_MODE (set_dest);\n+  \n+  if (code != UMOD)\n+    return false;\n+  op1 = XEXP (set_src, 0);\n+  op2 = XEXP (set_src, 1);\n+\n+  for (histogram = REG_NOTES (insn);\n+       histogram;\n+       histogram = XEXP (histogram, 1))\n+    if (REG_NOTE_KIND (histogram) == REG_VALUE_PROFILE\n+\t&& XEXP (XEXP (histogram, 0), 0) == GEN_INT (HIST_TYPE_POW2))\n+      break;\n+\n+  if (!histogram)\n+    return false;\n+\n+  histogram = XEXP (XEXP (histogram, 0), 1);\n+  value = XEXP (histogram, 0);\n+  histogram = XEXP (histogram, 1);\n+  wrong_values =INTVAL (XEXP (histogram, 0));\n+  histogram = XEXP (histogram, 1);\n+\n+  count = 0;\n+  for (i = 0; i < GET_MODE_BITSIZE (mode); i++)\n+    {\n+      count += INTVAL (XEXP (histogram, 0));\n+      histogram = XEXP (histogram, 1);\n+    }\n+\n+  if (!rtx_equal_p (op2, value))\n+    return false;\n+\n+  /* We require that we hit a power of two at least half of all evaluations.  */\n+  if (count < wrong_values)\n+    return false;\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"Mod power of 2 transformation on insn %d\\n\",\n+\t     INSN_UID (insn));\n+\n+  e = split_block (BLOCK_FOR_INSN (insn), PREV_INSN (insn));\n+  delete_insn (insn);\n+  \n+  insert_insn_on_edge (\n+\tgen_mod_pow2 (mode, code, set_dest, op1, op2), e);\n+\n+  return true;\n+}\n+\n+/* Generate code for transformations 3 and 4 (with MODE and OPERATION,\n+   operands OP1 and OP2, result TARGET and at most SUB subtractions).  */\n+static rtx\n+gen_mod_subtract (enum machine_mode mode, enum rtx_code operation,\n+\t\t  rtx target, rtx op1, rtx op2, int sub)\n+{\n+  rtx tmp, tmp1;\n+  rtx end_label = gen_label_rtx ();\n+  rtx sequence;\n+  int i;\n+\n+  start_sequence ();\n+  \n+  if (!REG_P (op2))\n+    {\n+      tmp = gen_reg_rtx (mode);\n+      emit_move_insn (tmp, copy_rtx (op2));\n+    }\n+  else\n+    tmp = op2;\n+\n+  emit_move_insn (target, copy_rtx (op1));\n+  do_compare_rtx_and_jump (target, tmp, LTU, 0, mode, NULL_RTX,\n+\t\t\t   NULL_RTX, end_label);\n+  \n+\n+  for (i = 0; i < sub; i++)\n+    {\n+      tmp1 = expand_simple_binop (mode, MINUS, target, tmp, target,\n+\t    \t\t\t  0, OPTAB_WIDEN);\n+      if (tmp1 != target)\n+\temit_move_insn (target, tmp1);\n+      do_compare_rtx_and_jump (target, tmp, LTU, 0, mode, NULL_RTX,\n+    \t\t\t       NULL_RTX, end_label);\n+    }\n+\n+  tmp1 = simplify_gen_binary (operation, mode, copy_rtx (target), copy_rtx (tmp));\n+  tmp1 = force_operand (tmp1, target);\n+  if (tmp1 != target)\n+    emit_move_insn (target, tmp1);\n+  \n+  emit_label (end_label);\n+\n+  sequence = get_insns ();\n+  end_sequence ();\n+  rebuild_jump_labels (sequence);\n+  return sequence;\n+}\n+\n+/* Do transforms 3) and 4) on INSN if applicable.  */\n+static bool\n+mod_subtract_transform (rtx insn)\n+{\n+  rtx set, set_src, set_dest, op1, op2, value, histogram;\n+  enum rtx_code code;\n+  enum machine_mode mode;\n+  gcov_type wrong_values, counts[2], count, all;\n+  edge e;\n+  int i;\n+\n+  set = single_set (insn);\n+  if (!set)\n+    return false;\n+\n+  set_src = SET_SRC (set);\n+  set_dest = SET_DEST (set);\n+  code = GET_CODE (set_src);\n+  mode = GET_MODE (set_dest);\n+  \n+  if (code != UMOD)\n+    return false;\n+  op1 = XEXP (set_src, 0);\n+  op2 = XEXP (set_src, 1);\n+\n+  for (histogram = REG_NOTES (insn);\n+       histogram;\n+       histogram = XEXP (histogram, 1))\n+    if (REG_NOTE_KIND (histogram) == REG_VALUE_PROFILE\n+\t&& XEXP (XEXP (histogram, 0), 0) == GEN_INT (HIST_TYPE_INTERVAL))\n+      break;\n+\n+  if (!histogram)\n+    return false;\n+\n+  histogram = XEXP (XEXP (histogram, 0), 1);\n+  value = XEXP (histogram, 0);\n+  histogram = XEXP (histogram, 1);\n+\n+  all = 0;\n+  for (i = 0; i < 2; i++)\n+    {\n+      counts[i] = INTVAL (XEXP (histogram, 0));\n+      all += counts[i];\n+      histogram = XEXP (histogram, 1);\n+    }\n+  wrong_values = INTVAL (XEXP (histogram, 0));\n+  histogram = XEXP (histogram, 1);\n+  wrong_values += INTVAL (XEXP (histogram, 0));\n+  all += wrong_values;\n+\n+  /* We require that we use just subtractions in at least 50% of all\n+     evaluations.  */\n+  count = 0;\n+  for (i = 0; i < 2; i++)\n+    {\n+      count += counts[i];\n+      if (count * 2 >= all)\n+\tbreak;\n+    }\n+  \n+  if (i == 2)\n+    return false;\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"Mod subtract transformation on insn %d\\n\",\n+\t     INSN_UID (insn));\n+\n+  e = split_block (BLOCK_FOR_INSN (insn), PREV_INSN (insn));\n+  delete_insn (insn);\n+  \n+  insert_insn_on_edge (\n+\tgen_mod_subtract (mode, code, set_dest, op1, op2, i), e);\n+\n+  return true;\n+}"}, {"sha": "afbeb916eb853e86e01af80b05b5298c4f568822", "filename": "gcc/value-prof.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fca9dc00583665bb89e63df672ba2f2184bb9ee6/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fca9dc00583665bb89e63df672ba2f2184bb9ee6/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=fca9dc00583665bb89e63df672ba2f2184bb9ee6", "patch": "@@ -61,3 +61,4 @@ struct histogram_value\n \n extern void find_values_to_profile (unsigned *, struct histogram_value **);\n extern void free_profiled_values (unsigned, struct histogram_value *);\n+extern bool value_profile_transformations (void);"}]}