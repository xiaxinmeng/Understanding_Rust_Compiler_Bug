{"sha": "8879d71c144425a6a52f6ae22fbcab265ef5eea9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg3OWQ3MWMxNDQ0MjVhNmE1MmY2YWUyMmZiY2FiMjY1ZWY1ZWVhOQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-21T21:16:09Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-21T21:16:09Z"}, "message": "cfgrtl.c: Use rtx subclasses\n\ngcc/\n2014-08-21  David Malcolm  <dmalcolm@redhat.com>\n\n\t* cfgrtl.c (can_delete_note_p): Require a const rtx_note * rather\n\tthan a const_rtx.\n\t(can_delete_label_p): Require a const rtx_code_label * rather than\n\ta const_rtx.\n\t(delete_insn): Add checked cast to rtx_code_label * when we know\n\twe're dealing with LABEL_P (insn).  Strengthen local \"bb_note\" from\n\trtx to rtx_insn *.\n\t(delete_insn_chain): Strengthen locals \"prev\" and \"current\" from\n\trtx to rtx_insn *.  Add a checked cast when assigning from\n\t\"finish\" (strengthening the params will come later).  Add a\n\tchecked cast to rtx_note * in region where we know\n\tNOTE_P (current).\n\t(rtl_delete_block): Strengthen locals \"insn\" and \"end\" from rtx to\n\trtx_insn *.\n\t(compute_bb_for_insn): Likewise.\n\t(free_bb_for_insn): Likewise for local \"insn\".\n\t(compute_bb_for_insn): Likewise.\n\t(update_bb_for_insn_chain): Strengthen params \"begin\", \"end\" and\n\tlocal \"insn\" from rtx to rtx_insn *\n\t(flow_active_insn_p): Require a const rtx_insn * rather than a\n\tconst_rtx.\n\t(contains_no_active_insn_p): Strengthen local \"insn\" from rtx to\n\trtx_insn *.\n\t(can_fallthru): Likewise for locals \"insn\" and \"insn2\".\n\t(bb_note): Likewise for local \"note\".\n\t(first_insn_after_basic_block_note): Likewise for local \"note\" and\n\tfor return type.\n\t(rtl_split_block): Likewise for locals \"insn\" and \"next\".\n\t(unique_locus_on_edge_between_p): Likewise for locals \"insn\" and\n\t\"end\".\n\t(rtl_merge_blocks): Likewise for locals \"b_head\", \"b_end\",\n\t\"a_end\", \"del_first\", \"del_last\", \"b_debug_start\", \"b_debug_end\",\n\t\"prev\", \"tmp\".\n\t(try_redirect_by_replacing_jump): Likewise for locals \"insn\" (both of\n\tthem), \"kill_from\", \"barrier\", \"new_insn\".\n\t(patch_jump_insn): Likewise for params \"insn\", \"old_label\".\n\t(redirect_branch_edge): Likewise for locals \"old_label\", \"insn\".\n\t(force_nonfallthru_and_redirect): Likewise for locals \"insn\",\n\t\"old_label\", \"new_label\".\n\t(rtl_tidy_fallthru_edge): Likewise for local \"q\".\n\t(rtl_split_edge): Likewise for locals \"before\", \"last\".\n\t(commit_one_edge_insertion): Likewise for locals \"before\",\n\t\"after\", \"insns\", \"tmp\", \"last\", adding a checked cast where\n\tcurrently necessary.\n\t(commit_edge_insertions): Likewise.\n\t(rtl_dump_bb): Likewise for locals \"insn\", \"last\".\n\t(print_rtl_with_bb): Likewise for local \"x\".\n\t(rtl_verify_bb_insns): Likewise for local \"x\".\n\t(rtl_verify_bb_pointers): Likewise for local \"insn\".\n\t(rtl_verify_bb_insn_chain): Likewise for locals \"x\", \"last_head\",\n\t\"head\", \"end\".\n\t(rtl_verify_fallthru): Likewise for local \"insn\".\n\t(rtl_verify_bb_layout): Likewise for locals \"x\" and \"rtx_first\".\n\t(purge_dead_edges): Likewise for local \"insn\".\n\t(fixup_abnormal_edges): Likewise for locals \"insn\", \"stop\", \"next\".\n\t(skip_insns_after_block): Likewise for return type and for locals\n\t\"insn\", \"last_insn\", \"next_head\", \"prev\".\n\t(record_effective_endpoints): Likewise for locals \"next_insn\",\n\t\"insn\", \"end\".\n\t(fixup_reorder_chain): Likewise for locals \"bb_end_insn\" and \"end\".\n\t(verify_insn_chain): Likewise for locals \"x\", \"prevx\", \"nextx\".\n\t(cfg_layout_can_duplicate_bb_p): Likewise for local \"insn\".\n\t(duplicate_insn_chain): For now, add checked cast from rtx to\n\trtx_insn * when returning insn.\n\t(cfg_layout_duplicate_bb): Likewise for local \"insn\".\n\t(cfg_layout_delete_block): Likewise for locals \"insn\", \"next\",\n\t\"prev\", \"remaints\".\n\t(cfg_layout_merge_blocks): Likewise for local \"insn\", \"last\".\n\t(rtl_block_empty_p): Likewise.\n\t(rtl_split_block_before_cond_jump): Likewise for locals \"insn\",\n\t\"split_point\", \"last\".\n\t(rtl_block_ends_with_call_p): Likewise for local \"insn\".\n\t(need_fake_edge_p): Strengthen param \"insn\" from const_rtx to\n\tconst rtx_insn *.\n\t(rtl_flow_call_edges_add): Strengthen locals \"insn\", \"prev_insn\",\n\t\"split_at_insn\" from rtx to rtx_insn *.\n\t(rtl_lv_add_condition_to_bb): Likewise for locals \"seq\", \"jump\".\n\t(rtl_can_remove_branch_p): Strengthen local \"insn\" from const_rtx\n\tto const rtx_insn *.\n\t(rtl_account_profile_record): Likewise.\n\nFrom-SVN: r214295", "tree": {"sha": "455b21445ff11166eb32404b7d0720e1df07c8dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/455b21445ff11166eb32404b7d0720e1df07c8dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8879d71c144425a6a52f6ae22fbcab265ef5eea9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8879d71c144425a6a52f6ae22fbcab265ef5eea9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8879d71c144425a6a52f6ae22fbcab265ef5eea9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8879d71c144425a6a52f6ae22fbcab265ef5eea9/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1f75b71e6b25558fbf3a941c70c412ad8c98a82b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f75b71e6b25558fbf3a941c70c412ad8c98a82b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f75b71e6b25558fbf3a941c70c412ad8c98a82b"}], "stats": {"total": 273, "additions": 181, "deletions": 92}, "files": [{"sha": "3abae91b09010e62b32239eeca0f52f32e6295cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8879d71c144425a6a52f6ae22fbcab265ef5eea9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8879d71c144425a6a52f6ae22fbcab265ef5eea9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8879d71c144425a6a52f6ae22fbcab265ef5eea9", "patch": "@@ -1,3 +1,86 @@\n+2014-08-21  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* cfgrtl.c (can_delete_note_p): Require a const rtx_note * rather\n+\tthan a const_rtx.\n+\t(can_delete_label_p): Require a const rtx_code_label * rather than\n+\ta const_rtx.\n+\t(delete_insn): Add checked cast to rtx_code_label * when we know\n+\twe're dealing with LABEL_P (insn).  Strengthen local \"bb_note\" from\n+\trtx to rtx_insn *.\n+\t(delete_insn_chain): Strengthen locals \"prev\" and \"current\" from\n+\trtx to rtx_insn *.  Add a checked cast when assigning from\n+\t\"finish\" (strengthening the params will come later).  Add a\n+\tchecked cast to rtx_note * in region where we know\n+\tNOTE_P (current).\n+\t(rtl_delete_block): Strengthen locals \"insn\" and \"end\" from rtx to\n+\trtx_insn *.\n+\t(compute_bb_for_insn): Likewise.\n+\t(free_bb_for_insn): Likewise for local \"insn\".\n+\t(compute_bb_for_insn): Likewise.\n+\t(update_bb_for_insn_chain): Strengthen params \"begin\", \"end\" and\n+\tlocal \"insn\" from rtx to rtx_insn *\n+\t(flow_active_insn_p): Require a const rtx_insn * rather than a\n+\tconst_rtx.\n+\t(contains_no_active_insn_p): Strengthen local \"insn\" from rtx to\n+\trtx_insn *.\n+\t(can_fallthru): Likewise for locals \"insn\" and \"insn2\".\n+\t(bb_note): Likewise for local \"note\".\n+\t(first_insn_after_basic_block_note): Likewise for local \"note\" and\n+\tfor return type.\n+\t(rtl_split_block): Likewise for locals \"insn\" and \"next\".\n+\t(unique_locus_on_edge_between_p): Likewise for locals \"insn\" and\n+\t\"end\".\n+\t(rtl_merge_blocks): Likewise for locals \"b_head\", \"b_end\",\n+\t\"a_end\", \"del_first\", \"del_last\", \"b_debug_start\", \"b_debug_end\",\n+\t\"prev\", \"tmp\".\n+\t(try_redirect_by_replacing_jump): Likewise for locals \"insn\" (both of\n+\tthem), \"kill_from\", \"barrier\", \"new_insn\".\n+\t(patch_jump_insn): Likewise for params \"insn\", \"old_label\".\n+\t(redirect_branch_edge): Likewise for locals \"old_label\", \"insn\".\n+\t(force_nonfallthru_and_redirect): Likewise for locals \"insn\",\n+\t\"old_label\", \"new_label\".\n+\t(rtl_tidy_fallthru_edge): Likewise for local \"q\".\n+\t(rtl_split_edge): Likewise for locals \"before\", \"last\".\n+\t(commit_one_edge_insertion): Likewise for locals \"before\",\n+\t\"after\", \"insns\", \"tmp\", \"last\", adding a checked cast where\n+\tcurrently necessary.\n+\t(commit_edge_insertions): Likewise.\n+\t(rtl_dump_bb): Likewise for locals \"insn\", \"last\".\n+\t(print_rtl_with_bb): Likewise for local \"x\".\n+\t(rtl_verify_bb_insns): Likewise for local \"x\".\n+\t(rtl_verify_bb_pointers): Likewise for local \"insn\".\n+\t(rtl_verify_bb_insn_chain): Likewise for locals \"x\", \"last_head\",\n+\t\"head\", \"end\".\n+\t(rtl_verify_fallthru): Likewise for local \"insn\".\n+\t(rtl_verify_bb_layout): Likewise for locals \"x\" and \"rtx_first\".\n+\t(purge_dead_edges): Likewise for local \"insn\".\n+\t(fixup_abnormal_edges): Likewise for locals \"insn\", \"stop\", \"next\".\n+\t(skip_insns_after_block): Likewise for return type and for locals\n+\t\"insn\", \"last_insn\", \"next_head\", \"prev\".\n+\t(record_effective_endpoints): Likewise for locals \"next_insn\",\n+\t\"insn\", \"end\".\n+\t(fixup_reorder_chain): Likewise for locals \"bb_end_insn\" and \"end\".\n+\t(verify_insn_chain): Likewise for locals \"x\", \"prevx\", \"nextx\".\n+\t(cfg_layout_can_duplicate_bb_p): Likewise for local \"insn\".\n+\t(duplicate_insn_chain): For now, add checked cast from rtx to\n+\trtx_insn * when returning insn.\n+\t(cfg_layout_duplicate_bb): Likewise for local \"insn\".\n+\t(cfg_layout_delete_block): Likewise for locals \"insn\", \"next\",\n+\t\"prev\", \"remaints\".\n+\t(cfg_layout_merge_blocks): Likewise for local \"insn\", \"last\".\n+\t(rtl_block_empty_p): Likewise.\n+\t(rtl_split_block_before_cond_jump): Likewise for locals \"insn\",\n+\t\"split_point\", \"last\".\n+\t(rtl_block_ends_with_call_p): Likewise for local \"insn\".\n+\t(need_fake_edge_p): Strengthen param \"insn\" from const_rtx to\n+\tconst rtx_insn *.\n+\t(rtl_flow_call_edges_add): Strengthen locals \"insn\", \"prev_insn\",\n+\t\"split_at_insn\" from rtx to rtx_insn *.\n+\t(rtl_lv_add_condition_to_bb): Likewise for locals \"seq\", \"jump\".\n+\t(rtl_can_remove_branch_p): Strengthen local \"insn\" from const_rtx\n+\tto const rtx_insn *.\n+\t(rtl_account_profile_record): Likewise.\n+\n 2014-08-21  David Malcolm  <dmalcolm@redhat.com>\n \n \t* cfgloopanal.c (num_loop_insns): Strengthen local \"insn\" from"}, {"sha": "59f093782c2d5fd84c63c955be7d736bfc2bd818", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 98, "deletions": 92, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8879d71c144425a6a52f6ae22fbcab265ef5eea9/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8879d71c144425a6a52f6ae22fbcab265ef5eea9/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=8879d71c144425a6a52f6ae22fbcab265ef5eea9", "patch": "@@ -67,15 +67,15 @@ along with GCC; see the file COPYING3.  If not see\n static GTY(()) rtx cfg_layout_function_footer;\n static GTY(()) rtx cfg_layout_function_header;\n \n-static rtx skip_insns_after_block (basic_block);\n+static rtx_insn *skip_insns_after_block (basic_block);\n static void record_effective_endpoints (void);\n static rtx label_for_bb (basic_block);\n static void fixup_reorder_chain (void);\n \n void verify_insn_chain (void);\n static void fixup_fallthru_exit_predecessor (void);\n-static int can_delete_note_p (const_rtx);\n-static int can_delete_label_p (const_rtx);\n+static int can_delete_note_p (const rtx_note *);\n+static int can_delete_label_p (const rtx_code_label *);\n static basic_block rtl_split_edge (edge);\n static bool rtl_move_block_after (basic_block, basic_block);\n static int rtl_verify_flow_info (void);\n@@ -95,7 +95,7 @@ static void rtl_make_forwarder_block (edge);\n    so that we may simply delete it.  */\n \n static int\n-can_delete_note_p (const_rtx note)\n+can_delete_note_p (const rtx_note *note)\n {\n   switch (NOTE_KIND (note))\n     {\n@@ -112,7 +112,7 @@ can_delete_note_p (const_rtx note)\n /* True if a given label can be deleted.  */\n \n static int\n-can_delete_label_p (const_rtx label)\n+can_delete_label_p (const rtx_code_label *label)\n {\n   return (!LABEL_PRESERVE_P (label)\n \t  /* User declared labels must be preserved.  */\n@@ -133,11 +133,11 @@ delete_insn (rtx insn)\n       /* Some labels can't be directly removed from the INSN chain, as they\n \t might be references via variables, constant pool etc.\n \t Convert them to the special NOTE_INSN_DELETED_LABEL note.  */\n-      if (! can_delete_label_p (insn))\n+      if (! can_delete_label_p (as_a <rtx_code_label *> (insn)))\n \t{\n \t  const char *name = LABEL_NAME (insn);\n \t  basic_block bb = BLOCK_FOR_INSN (insn);\n-\t  rtx bb_note = NEXT_INSN (insn);\n+\t  rtx_insn *bb_note = NEXT_INSN (insn);\n \n \t  really_delete = false;\n \t  PUT_CODE (insn, NOTE);\n@@ -240,16 +240,16 @@ delete_insn_and_edges (rtx insn)\n void\n delete_insn_chain (rtx start, rtx finish, bool clear_bb)\n {\n-  rtx prev, current;\n+  rtx_insn *prev, *current;\n \n   /* Unchain the insns one by one.  It would be quicker to delete all of these\n      with a single unchaining, rather than one at a time, but we need to keep\n      the NOTE's.  */\n-  current = finish;\n+  current = safe_as_a <rtx_insn *> (finish);\n   while (1)\n     {\n       prev = PREV_INSN (current);\n-      if (NOTE_P (current) && !can_delete_note_p (current))\n+      if (NOTE_P (current) && !can_delete_note_p (as_a <rtx_note *> (current)))\n \t;\n       else\n \tdelete_insn (current);\n@@ -391,7 +391,7 @@ cfg_layout_create_basic_block (void *head, void *end, basic_block after)\n static void\n rtl_delete_block (basic_block b)\n {\n-  rtx insn, end;\n+  rtx_insn *insn, *end;\n \n   /* If the head of this block is a CODE_LABEL, then it might be the\n      label for an exception handler which can't be reached.  We need\n@@ -419,8 +419,8 @@ compute_bb_for_insn (void)\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      rtx end = BB_END (bb);\n-      rtx insn;\n+      rtx_insn *end = BB_END (bb);\n+      rtx_insn *insn;\n \n       for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n \t{\n@@ -436,7 +436,7 @@ compute_bb_for_insn (void)\n unsigned int\n free_bb_for_insn (void)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     if (!BARRIER_P (insn))\n       BLOCK_FOR_INSN (insn) = NULL;\n@@ -525,9 +525,9 @@ emit_insn_at_entry (rtx insn)\n    (i.e. both BEGIN and END will be updated. */\n \n static void\n-update_bb_for_insn_chain (rtx begin, rtx end, basic_block bb)\n+update_bb_for_insn_chain (rtx_insn *begin, rtx_insn *end, basic_block bb)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   end = NEXT_INSN (end);\n   for (insn = begin; insn != end; insn = NEXT_INSN (insn))\n@@ -549,7 +549,7 @@ update_bb_for_insn (basic_block bb)\n    even after reload.  */\n \n static bool\n-flow_active_insn_p (const_rtx insn)\n+flow_active_insn_p (const rtx_insn *insn)\n {\n   if (active_insn_p (insn))\n     return true;\n@@ -573,7 +573,7 @@ flow_active_insn_p (const_rtx insn)\n bool\n contains_no_active_insn_p (const_basic_block bb)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun) || bb == ENTRY_BLOCK_PTR_FOR_FN (cfun)\n       || !single_succ_p (bb))\n@@ -617,8 +617,8 @@ forwarder_block_p (const_basic_block bb)\n bool\n can_fallthru (basic_block src, basic_block target)\n {\n-  rtx insn = BB_END (src);\n-  rtx insn2;\n+  rtx_insn *insn = BB_END (src);\n+  rtx_insn *insn2;\n   edge e;\n   edge_iterator ei;\n \n@@ -665,7 +665,7 @@ could_fall_through (basic_block src, basic_block target)\n rtx_note *\n bb_note (basic_block bb)\n {\n-  rtx note;\n+  rtx_insn *note;\n \n   note = BB_HEAD (bb);\n   if (LABEL_P (note))\n@@ -678,16 +678,16 @@ bb_note (basic_block bb)\n /* Return the INSN immediately following the NOTE_INSN_BASIC_BLOCK\n    note associated with the BLOCK.  */\n \n-static rtx\n+static rtx_insn *\n first_insn_after_basic_block_note (basic_block block)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   /* Get the first instruction in the block.  */\n   insn = BB_HEAD (block);\n \n   if (insn == NULL_RTX)\n-    return NULL_RTX;\n+    return NULL;\n   if (LABEL_P (insn))\n     insn = NEXT_INSN (insn);\n   gcc_assert (NOTE_INSN_BASIC_BLOCK_P (insn));\n@@ -702,7 +702,7 @@ static basic_block\n rtl_split_block (basic_block bb, void *insnp)\n {\n   basic_block new_bb;\n-  rtx insn = (rtx) insnp;\n+  rtx_insn *insn = (rtx_insn *) insnp;\n   edge e;\n   edge_iterator ei;\n \n@@ -712,7 +712,7 @@ rtl_split_block (basic_block bb, void *insnp)\n \n       if (insn)\n \t{\n-\t  rtx next = insn;\n+\t  rtx_insn *next = insn;\n \n \t  insn = PREV_INSN (insn);\n \n@@ -764,7 +764,7 @@ static bool\n unique_locus_on_edge_between_p (basic_block a, basic_block b)\n {\n   const location_t goto_locus = EDGE_SUCC (a, 0)->goto_locus;\n-  rtx insn, end;\n+  rtx_insn *insn, *end;\n \n   if (LOCATION_LOCUS (goto_locus) == UNKNOWN_LOCATION)\n     return false;\n@@ -813,9 +813,9 @@ emit_nop_for_unique_locus_between (basic_block a, basic_block b)\n static void\n rtl_merge_blocks (basic_block a, basic_block b)\n {\n-  rtx b_head = BB_HEAD (b), b_end = BB_END (b), a_end = BB_END (a);\n-  rtx del_first = NULL_RTX, del_last = NULL_RTX;\n-  rtx b_debug_start = b_end, b_debug_end = b_end;\n+  rtx_insn *b_head = BB_HEAD (b), *b_end = BB_END (b), *a_end = BB_END (a);\n+  rtx_insn *del_first = NULL, *del_last = NULL;\n+  rtx_insn *b_debug_start = b_end, *b_debug_end = b_end;\n   bool forwarder_p = (b->flags & BB_FORWARDER_BLOCK) != 0;\n   int b_empty = 0;\n \n@@ -854,7 +854,7 @@ rtl_merge_blocks (basic_block a, basic_block b)\n   /* If there was a jump out of A, delete it.  */\n   if (JUMP_P (a_end))\n     {\n-      rtx prev;\n+      rtx_insn *prev;\n \n       for (prev = PREV_INSN (a_end); ; prev = PREV_INSN (prev))\n \tif (!NOTE_P (prev)\n@@ -869,7 +869,7 @@ rtl_merge_blocks (basic_block a, basic_block b)\n \t the insn that set cc0.  */\n       if (only_sets_cc0_p (prev))\n \t{\n-\t  rtx tmp = prev;\n+\t  rtx_insn *tmp = prev;\n \n \t  prev = prev_nonnote_insn (prev);\n \t  if (!prev)\n@@ -995,7 +995,7 @@ edge\n try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n {\n   basic_block src = e->src;\n-  rtx insn = BB_END (src), kill_from;\n+  rtx_insn *insn = BB_END (src), *kill_from;\n   rtx set;\n   int fallthru = 0;\n \n@@ -1051,7 +1051,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n       /* Selectively unlink whole insn chain.  */\n       if (in_cfglayout)\n \t{\n-\t  rtx insn = BB_FOOTER (src);\n+\t  rtx_insn *insn = BB_FOOTER (src);\n \n \t  delete_insn_chain (kill_from, BB_END (src), false);\n \n@@ -1100,7 +1100,8 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n   else\n     {\n       rtx target_label = block_label (target);\n-      rtx barrier, label;\n+      rtx_insn *barrier;\n+      rtx label;\n       rtx_jump_table_data *table;\n \n       emit_jump_insn_after_noloc (gen_jump (target_label), insn);\n@@ -1129,7 +1130,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n \t      /* Move the jump before barrier so that the notes\n \t\t which originally were or were created before jump table are\n \t\t inside the basic block.  */\n-\t      rtx new_insn = BB_END (src);\n+\t      rtx_insn *new_insn = BB_END (src);\n \n \t      update_bb_for_insn_chain (NEXT_INSN (BB_END (src)),\n \t\t\t\t        PREV_INSN (barrier), src);\n@@ -1172,7 +1173,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n    doesn't work.  */\n \n static bool\n-patch_jump_insn (rtx insn, rtx old_label, basic_block new_bb)\n+patch_jump_insn (rtx_insn *insn, rtx_insn *old_label, basic_block new_bb)\n {\n   rtx_jump_table_data *table;\n   rtx tmp;\n@@ -1287,9 +1288,9 @@ patch_jump_insn (rtx insn, rtx old_label, basic_block new_bb)\n static edge\n redirect_branch_edge (edge e, basic_block target)\n {\n-  rtx old_label = BB_HEAD (e->dest);\n+  rtx_insn *old_label = BB_HEAD (e->dest);\n   basic_block src = e->src;\n-  rtx insn = BB_END (src);\n+  rtx_insn *insn = BB_END (src);\n \n   /* We can only redirect non-fallthru edges of jump insn.  */\n   if (e->flags & EDGE_FALLTHRU)\n@@ -1575,9 +1576,10 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n \t}\n       if (adjust_jump_target)\n \t{\n-\t  rtx insn = BB_END (e->src), note;\n-\t  rtx old_label = BB_HEAD (e->dest);\n-\t  rtx new_label = BB_HEAD (target);\n+\t  rtx_insn *insn = BB_END (e->src);\n+\t  rtx note;\n+\t  rtx_insn *old_label = BB_HEAD (e->dest);\n+\t  rtx_insn *new_label = BB_HEAD (target);\n \n \t  if (JUMP_LABEL (insn) == old_label)\n \t    {\n@@ -1735,7 +1737,7 @@ rtl_redirect_edge_and_branch_force (edge e, basic_block target)\n static void\n rtl_tidy_fallthru_edge (edge e)\n {\n-  rtx q;\n+  rtx_insn *q;\n   basic_block b = e->src, c = b->next_bb;\n \n   /* ??? In a late-running flow pass, other folks may have deleted basic\n@@ -1813,7 +1815,7 @@ static basic_block\n rtl_split_edge (edge edge_in)\n {\n   basic_block bb, new_bb;\n-  rtx before;\n+  rtx_insn *before;\n \n   /* Abnormal edges cannot be split.  */\n   gcc_assert (!(edge_in->flags & EDGE_ABNORMAL));\n@@ -1832,7 +1834,7 @@ rtl_split_edge (edge edge_in)\n   if (edge_in->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     before = BB_HEAD (edge_in->dest);\n   else\n-    before = NULL_RTX;\n+    before = NULL;\n \n   /* If this is a fall through edge to the exit block, the blocks might be\n      not adjacent, and the right place is after the source.  */\n@@ -1903,7 +1905,7 @@ rtl_split_edge (edge edge_in)\n \t  /* For asm goto even splitting of fallthru edge might\n \t     need insn patching, as other labels might point to the\n \t     old label.  */\n-\t  rtx last = BB_END (edge_in->src);\n+\t  rtx_insn *last = BB_END (edge_in->src);\n \t  if (last\n \t      && JUMP_P (last)\n \t      && edge_in->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n@@ -1944,11 +1946,11 @@ insert_insn_on_edge (rtx pattern, edge e)\n void\n commit_one_edge_insertion (edge e)\n {\n-  rtx before = NULL_RTX, after = NULL_RTX, insns, tmp, last;\n+  rtx_insn *before = NULL, *after = NULL, *insns, *tmp, *last;\n   basic_block bb;\n \n   /* Pull the insns off the edge now since the edge might go away.  */\n-  insns = e->insns.r;\n+  insns = safe_as_a <rtx_insn *> (e->insns.r);\n   e->insns.r = NULL_RTX;\n \n   /* Figure out where to put these insns.  If the destination has\n@@ -2087,8 +2089,8 @@ commit_edge_insertions (void)\n static void\n rtl_dump_bb (FILE *outf, basic_block bb, int indent, int flags)\n {\n-  rtx insn;\n-  rtx last;\n+  rtx_insn *insn;\n+  rtx_insn *last;\n   char *s_indent;\n \n   s_indent = (char *) alloca ((size_t) indent + 1);\n@@ -2155,7 +2157,7 @@ print_rtl_with_bb (FILE *outf, const_rtx rtx_first, int flags)\n \t{\n \t  FOR_EACH_BB_REVERSE_FN (bb, cfun)\n \t    {\n-\t      rtx x;\n+\t      rtx_insn *x;\n \n \t      start[INSN_UID (BB_HEAD (bb))] = bb;\n \t      end[INSN_UID (BB_END (bb))] = bb;\n@@ -2583,7 +2585,7 @@ rtl_verify_edges (void)\n static int\n rtl_verify_bb_insns (void)\n {\n-  rtx x;\n+  rtx_insn *x;\n   int err = 0;\n   basic_block bb;\n \n@@ -2652,7 +2654,7 @@ rtl_verify_bb_pointers (void)\n   /* Check the general integrity of the basic blocks.  */\n   FOR_EACH_BB_REVERSE_FN (bb, cfun)\n     {\n-      rtx insn;\n+      rtx_insn *insn;\n \n       if (!(bb->flags & BB_RTL))\n \t{\n@@ -2733,17 +2735,17 @@ rtl_verify_bb_insn_chain (void)\n {\n   basic_block bb;\n   int err = 0;\n-  rtx x;\n-  rtx last_head = get_last_insn ();\n+  rtx_insn *x;\n+  rtx_insn *last_head = get_last_insn ();\n   basic_block *bb_info;\n   const int max_uid = get_max_uid ();\n \n   bb_info = XCNEWVEC (basic_block, max_uid);\n \n   FOR_EACH_BB_REVERSE_FN (bb, cfun)\n     {\n-      rtx head = BB_HEAD (bb);\n-      rtx end = BB_END (bb);\n+      rtx_insn *head = BB_HEAD (bb);\n+      rtx_insn *end = BB_END (bb);\n \n       for (x = last_head; x != NULL_RTX; x = PREV_INSN (x))\n \t{\n@@ -2829,7 +2831,7 @@ rtl_verify_fallthru (void)\n       e = find_fallthru_edge (bb->succs);\n       if (!e)\n \t{\n-\t  rtx insn;\n+\t  rtx_insn *insn;\n \n \t  /* Ensure existence of barrier in BB with no fallthru edges.  */\n \t  for (insn = NEXT_INSN (BB_END (bb)); ; insn = NEXT_INSN (insn))\n@@ -2847,7 +2849,7 @@ rtl_verify_fallthru (void)\n       else if (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t       && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t{\n-\t  rtx insn;\n+\t  rtx_insn *insn;\n \n \t  if (e->src->next_bb != e->dest)\n \t    {\n@@ -2881,9 +2883,9 @@ rtl_verify_bb_layout (void)\n {\n   basic_block bb;\n   int err = 0;\n-  rtx x;\n+  rtx_insn *x;\n   int num_bb_notes;\n-  const rtx rtx_first = get_insns ();\n+  rtx_insn * const rtx_first = get_insns ();\n   basic_block last_bb_seen = ENTRY_BLOCK_PTR_FOR_FN (cfun), curr_bb = NULL;\n \n   num_bb_notes = 0;\n@@ -2980,7 +2982,8 @@ bool\n purge_dead_edges (basic_block bb)\n {\n   edge e;\n-  rtx insn = BB_END (bb), note;\n+  rtx_insn *insn = BB_END (bb);\n+  rtx note;\n   bool purged = false;\n   bool found;\n   edge_iterator ei;\n@@ -3242,7 +3245,7 @@ fixup_abnormal_edges (void)\n \n       if (e && !CALL_P (BB_END (bb)) && !can_throw_internal (BB_END (bb)))\n \t{\n-\t  rtx insn;\n+\t  rtx_insn *insn;\n \n \t  /* Get past the new insns generated.  Allow notes, as the insns\n \t     may be already deleted.  */\n@@ -3254,7 +3257,7 @@ fixup_abnormal_edges (void)\n \n \t  if (CALL_P (insn) || can_throw_internal (insn))\n \t    {\n-\t      rtx stop, next;\n+\t      rtx_insn *stop, *next;\n \n \t      e = find_fallthru_edge (bb->succs);\n \n@@ -3326,12 +3329,12 @@ unlink_insn_chain (rtx first, rtx last)\n    associated with BB (e.g., barriers). If there are any such insns,\n    we return the last one. Otherwise, we return the end of BB.  */\n \n-static rtx\n+static rtx_insn *\n skip_insns_after_block (basic_block bb)\n {\n-  rtx insn, last_insn, next_head, prev;\n+  rtx_insn *insn, *last_insn, *next_head, *prev;\n \n-  next_head = NULL_RTX;\n+  next_head = NULL;\n   if (bb->next_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     next_head = BB_HEAD (bb->next_bb);\n \n@@ -3430,9 +3433,9 @@ label_for_bb (basic_block bb)\n static void\n record_effective_endpoints (void)\n {\n-  rtx next_insn;\n+  rtx_insn *next_insn;\n   basic_block bb;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   for (insn = get_insns ();\n        insn\n@@ -3452,7 +3455,7 @@ record_effective_endpoints (void)\n   next_insn = get_insns ();\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      rtx end;\n+      rtx_insn *end;\n \n       if (PREV_INSN (BB_HEAD (bb)) && next_insn != BB_HEAD (bb))\n \tSET_BB_HEADER (bb) = unlink_insn_chain (next_insn,\n@@ -3699,7 +3702,7 @@ fixup_reorder_chain (void)\n        bb->aux)\n     {\n       edge e_fall, e_taken, e;\n-      rtx bb_end_insn;\n+      rtx_insn *bb_end_insn;\n       rtx ret_label = NULL_RTX;\n       basic_block nb;\n       edge_iterator ei;\n@@ -3875,7 +3878,7 @@ fixup_reorder_chain (void)\n \t      edge e2;\n \t      edge_iterator ei2;\n \t      basic_block dest, nb;\n-\t      rtx end;\n+\t      rtx_insn *end;\n \n \t      insn = BB_END (e->src);\n \t      end = PREV_INSN (BB_HEAD (e->src));\n@@ -3938,7 +3941,7 @@ fixup_reorder_chain (void)\n DEBUG_FUNCTION void\n verify_insn_chain (void)\n {\n-  rtx x, prevx, nextx;\n+  rtx_insn *x, *prevx, *nextx;\n   int insn_cnt1, insn_cnt2;\n \n   for (prevx = NULL, insn_cnt1 = 1, x = get_insns ();\n@@ -4066,7 +4069,7 @@ cfg_layout_can_duplicate_bb_p (const_basic_block bb)\n   /* Do not duplicate blocks containing insns that can't be copied.  */\n   if (targetm.cannot_copy_insn_p)\n     {\n-      rtx insn = BB_HEAD (bb);\n+      rtx_insn *insn = BB_HEAD (bb);\n       while (1)\n \t{\n \t  if (INSN_P (insn) && targetm.cannot_copy_insn_p (insn))\n@@ -4174,7 +4177,7 @@ duplicate_insn_chain (rtx from, rtx to)\n static basic_block\n cfg_layout_duplicate_bb (basic_block bb)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   basic_block new_bb;\n \n   insn = duplicate_insn_chain (BB_HEAD (bb), BB_END (bb));\n@@ -4412,7 +4415,8 @@ cfg_layout_redirect_edge_and_branch_force (edge e, basic_block dest)\n static void\n cfg_layout_delete_block (basic_block bb)\n {\n-  rtx insn, next, prev = PREV_INSN (BB_HEAD (bb)), *to, remaints;\n+  rtx_insn *insn, *next, *prev = PREV_INSN (BB_HEAD (bb)), *remaints;\n+  rtx *to;\n \n   if (BB_HEADER (bb))\n     {\n@@ -4545,7 +4549,7 @@ static void\n cfg_layout_merge_blocks (basic_block a, basic_block b)\n {\n   bool forwarder_p = (b->flags & BB_FORWARDER_BLOCK) != 0;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   gcc_checking_assert (cfg_layout_can_merge_blocks_p (a, b));\n \n@@ -4577,7 +4581,7 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n \tSET_BB_FOOTER (a) = SET_BB_FOOTER (b);\n       else\n \t{\n-\t  rtx last = BB_FOOTER (a);\n+\t  rtx_insn *last = BB_FOOTER (a);\n \n \t  while (NEXT_INSN (last))\n \t    last = NEXT_INSN (last);\n@@ -4596,7 +4600,7 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n \tSET_BB_FOOTER (a) = BB_HEADER (b);\n       else\n \t{\n-\t  rtx last = BB_HEADER (b);\n+\t  rtx_insn *last = BB_HEADER (b);\n  \n \t  while (NEXT_INSN (last))\n \t    last = NEXT_INSN (last);\n@@ -4676,7 +4680,7 @@ rtl_make_forwarder_block (edge fallthru ATTRIBUTE_UNUSED)\n static bool\n rtl_block_empty_p (basic_block bb)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   if (bb == ENTRY_BLOCK_PTR_FOR_FN (cfun)\n       || bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n@@ -4695,9 +4699,9 @@ rtl_block_empty_p (basic_block bb)\n static basic_block\n rtl_split_block_before_cond_jump (basic_block bb)\n {\n-  rtx insn;\n-  rtx split_point = NULL;\n-  rtx last = NULL;\n+  rtx_insn *insn;\n+  rtx_insn *split_point = NULL;\n+  rtx_insn *last = NULL;\n   bool found_code = false;\n \n   FOR_BB_INSNS (bb, insn)\n@@ -4722,7 +4726,7 @@ rtl_split_block_before_cond_jump (basic_block bb)\n static bool\n rtl_block_ends_with_call_p (basic_block bb)\n {\n-  rtx insn = BB_END (bb);\n+  rtx_insn *insn = BB_END (bb);\n \n   while (!CALL_P (insn)\n \t && insn != BB_HEAD (bb)\n@@ -4745,7 +4749,7 @@ rtl_block_ends_with_condjump_p (const_basic_block bb)\n    Helper function for rtl_flow_call_edges_add.  */\n \n static bool\n-need_fake_edge_p (const_rtx insn)\n+need_fake_edge_p (const rtx_insn *insn)\n {\n   if (!INSN_P (insn))\n     return false;\n@@ -4804,7 +4808,7 @@ rtl_flow_call_edges_add (sbitmap blocks)\n   if (check_last_block)\n     {\n       basic_block bb = EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb;\n-      rtx insn = BB_END (bb);\n+      rtx_insn *insn = BB_END (bb);\n \n       /* Back up past insns that must be kept in the same block as a call.  */\n       while (insn != BB_HEAD (bb)\n@@ -4831,8 +4835,8 @@ rtl_flow_call_edges_add (sbitmap blocks)\n   for (i = NUM_FIXED_BLOCKS; i < last_bb; i++)\n     {\n       basic_block bb = BASIC_BLOCK_FOR_FN (cfun, i);\n-      rtx insn;\n-      rtx prev_insn;\n+      rtx_insn *insn;\n+      rtx_insn *prev_insn;\n \n       if (!bb)\n \tcontinue;\n@@ -4846,7 +4850,7 @@ rtl_flow_call_edges_add (sbitmap blocks)\n \t  if (need_fake_edge_p (insn))\n \t    {\n \t      edge e;\n-\t      rtx split_at_insn = insn;\n+\t      rtx_insn *split_at_insn = insn;\n \n \t      /* Don't split the block between a call and an insn that should\n \t\t remain in the same block as the call.  */\n@@ -4901,7 +4905,8 @@ rtl_lv_add_condition_to_bb (basic_block first_head ,\n \t\t\t    basic_block second_head ATTRIBUTE_UNUSED,\n \t\t\t    basic_block cond_bb, void *comp_rtx)\n {\n-  rtx label, seq, jump;\n+  rtx label;\n+  rtx_insn *seq, *jump;\n   rtx op0 = XEXP ((rtx)comp_rtx, 0);\n   rtx op1 = XEXP ((rtx)comp_rtx, 1);\n   enum rtx_code comp = GET_CODE ((rtx)comp_rtx);\n@@ -4966,7 +4971,8 @@ rtl_can_remove_branch_p (const_edge e)\n {\n   const_basic_block src = e->src;\n   const_basic_block target = EDGE_SUCC (src, EDGE_SUCC (src, 0) == e)->dest;\n-  const_rtx insn = BB_END (src), set;\n+  const rtx_insn *insn = BB_END (src);\n+  rtx set;\n \n   /* The conditions are taken from try_redirect_by_replacing_jump.  */\n   if (target == EXIT_BLOCK_PTR_FOR_FN (cfun))\n@@ -5004,7 +5010,7 @@ static void\n rtl_account_profile_record (basic_block bb, int after_pass,\n \t\t\t    struct profile_record *record)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   FOR_BB_INSNS (bb, insn)\n     if (INSN_P (insn))\n       {"}]}