{"sha": "c755e77d63980a40e93c82da335aa59cb30de107", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc1NWU3N2Q2Mzk4MGE0MGU5M2M4MmRhMzM1YWE1OWNiMzBkZTEwNw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2003-10-17T14:47:30Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-10-17T14:47:30Z"}, "message": "Makefile.am: Add new files.\n\n\n2003-10-17  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* src/Makefile.am: Add new files.\n\t* src/Makefile.in: Regenerate.\n\t* src/globals.cc: Split into..\n\t* src/globals_io.cc: New.\n\t* src/globals_locale.cc: New.\n\t* src/ios.cc: Split into...\n\t* src/ios_init.cc: New.\n\t* src/ios_locale.cc: New.\n\t* src/locale-inst.cc: Split into..\n\t* src/wlocale-inst.cc: New.\n\t* src/locale-misc-inst.cc: New.\n\t* src/locale.cc, src/localename: Split into...\n\t* src/locale_facets.cc: New.\n\t* src/locale_init.cc: New.\n\t* src/wstring-inst.cc: Add copyright info.\n\nFrom-SVN: r72607", "tree": {"sha": "7c4f8aa15ee039cf95bf1f255b0fc30a256d14d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c4f8aa15ee039cf95bf1f255b0fc30a256d14d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c755e77d63980a40e93c82da335aa59cb30de107", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c755e77d63980a40e93c82da335aa59cb30de107", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c755e77d63980a40e93c82da335aa59cb30de107", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c755e77d63980a40e93c82da335aa59cb30de107/comments", "author": null, "committer": null, "parents": [{"sha": "efc2515b4913b2b8870b041475542277520aa002", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efc2515b4913b2b8870b041475542277520aa002", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efc2515b4913b2b8870b041475542277520aa002"}], "stats": {"total": 2757, "additions": 1443, "deletions": 1314}, "files": [{"sha": "64d19da7c073bd3ae9186f673a3d546957d60fe7", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=c755e77d63980a40e93c82da335aa59cb30de107", "patch": "@@ -1,3 +1,21 @@\n+2003-10-17  Benjamin Kosnik  <bkoz@redhat.com>\n+ \n+\t* src/Makefile.am: Add new files.\n+\t* src/Makefile.in: Regenerate.\n+\t* src/globals.cc: Split into..\n+\t* src/globals_io.cc: New.\n+\t* src/globals_locale.cc: New.\n+\t* src/ios.cc: Split into...\n+\t* src/ios_init.cc: New.\n+\t* src/ios_locale.cc: New.\n+\t* src/locale-inst.cc: Split into..\n+\t* src/wlocale-inst.cc: New.\n+\t* src/locale-misc-inst.cc: New.\n+\t* src/locale.cc, src/localename: Split into...\n+\t* src/locale_facets.cc: New.\n+\t* src/locale_init.cc: New.\n+\t* src/wstring-inst.cc: Add copyright info.\n+\n 2003-10-16  Petur Runolfsson  <peturr02@ru.is>\n \n \tPR libstdc++/11450"}, {"sha": "e3e04b52f12891931d8b368ab4cf6f53819089c9", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=c755e77d63980a40e93c82da335aa59cb30de107", "patch": "@@ -91,33 +91,40 @@ basic_file.cc: ${glibcxx_srcdir}/$(BASIC_FILE_CC)\n \n # Sources present in the src directory.\n sources = \\\n-\tallocator-inst.cc \\\n \tcodecvt.cc \\\n \tcomplex_io.cc \\\n-\tconcept-inst.cc \\\n \tctype.cc \\\n \tdemangle.cc \\\n-\text-inst.cc \\\n-\tfstream-inst.cc \\\n \tfunctexcept.cc \\\n-\tglobals.cc \\\n-\tio-inst.cc \\\n+\tglobals_locale.cc \\\n+\tglobals_io.cc \\\n \tios.cc \\\n \tios_failure.cc \\\n-\tistream-inst.cc \\\n+\tios_init.cc \\\n+\tios_locale.cc \\\n \tlimits.cc \\\n \tlocale.cc \\\n-\tlocale-inst.cc \\\n+\tlocale_init.cc \\\n+\tlocale_facets.cc \\\n \tlocalename.cc \\\n+\tstdexcept.cc \\\n+\tstl_tree.cc \\\n+\tstrstream.cc \\\n+\tallocator-inst.cc \\\n+\tconcept-inst.cc \\\n+\tfstream-inst.cc \\\n+\text-inst.cc \\\n+\tio-inst.cc \\\n+\tistream-inst.cc \\\n+\tlocale-inst.cc \\\n+\tlocale-misc-inst.cc \\\n \tmisc-inst.cc \\\n \tostream-inst.cc \\\n \tsstream-inst.cc \\\n-\tstdexcept.cc \\\n-\tstl_tree.cc \\\n \tstreambuf-inst.cc \\\n \tstring-inst.cc \\\n-\tstrstream.cc \\\n \tvalarray-inst.cc \\\n+\twlocale-inst.cc \\\n \twstring-inst.cc \\\n \t${host_sources} \\\n \t${host_sources_extra}"}, {"sha": "40d6f8bc94a53b1aae9771471f5ca884043f8c0d", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=c755e77d63980a40e93c82da335aa59cb30de107", "patch": "@@ -1,4 +1,4 @@\n-# Makefile.in generated by automake 1.7.6 from Makefile.am.\n+# Makefile.in generated by automake 1.7.8 from Makefile.am.\n # @configure_input@\n \n # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n@@ -81,8 +81,6 @@ ECHO_T = @ECHO_T@\n EGREP = @EGREP@\n EXEEXT = @EXEEXT@\n EXTRA_CXX_FLAGS = @EXTRA_CXX_FLAGS@\n-FPOS_H = @FPOS_H@\n-FPOS_INC_SRCDIR = @FPOS_INC_SRCDIR@\n GLIBCXX_BUILD_DEBUG_FALSE = @GLIBCXX_BUILD_DEBUG_FALSE@\n GLIBCXX_BUILD_DEBUG_TRUE = @GLIBCXX_BUILD_DEBUG_TRUE@\n GLIBCXX_BUILD_PCH_FALSE = @GLIBCXX_BUILD_PCH_FALSE@\n@@ -250,33 +248,40 @@ host_sources_extra = \\\n \n # Sources present in the src directory.\n sources = \\\n-\tallocator-inst.cc \\\n \tcodecvt.cc \\\n \tcomplex_io.cc \\\n-\tconcept-inst.cc \\\n \tctype.cc \\\n \tdemangle.cc \\\n-\text-inst.cc \\\n-\tfstream-inst.cc \\\n \tfunctexcept.cc \\\n-\tglobals.cc \\\n-\tio-inst.cc \\\n+\tglobals_locale.cc \\\n+\tglobals_io.cc \\\n \tios.cc \\\n \tios_failure.cc \\\n-\tistream-inst.cc \\\n+\tios_init.cc \\\n+\tios_locale.cc \\\n \tlimits.cc \\\n \tlocale.cc \\\n-\tlocale-inst.cc \\\n+\tlocale_init.cc \\\n+\tlocale_facets.cc \\\n \tlocalename.cc \\\n+\tstdexcept.cc \\\n+\tstl_tree.cc \\\n+\tstrstream.cc \\\n+\tallocator-inst.cc \\\n+\tconcept-inst.cc \\\n+\tfstream-inst.cc \\\n+\text-inst.cc \\\n+\tio-inst.cc \\\n+\tistream-inst.cc \\\n+\tlocale-inst.cc \\\n+\tlocale-misc-inst.cc \\\n \tmisc-inst.cc \\\n \tostream-inst.cc \\\n \tsstream-inst.cc \\\n-\tstdexcept.cc \\\n-\tstl_tree.cc \\\n \tstreambuf-inst.cc \\\n \tstring-inst.cc \\\n-\tstrstream.cc \\\n \tvalarray-inst.cc \\\n+\twlocale-inst.cc \\\n \twstring-inst.cc \\\n \t${host_sources} \\\n \t${host_sources_extra}\n@@ -355,14 +360,16 @@ am__objects_1 = codecvt_members.lo collate_members.lo ctype_members.lo \\\n \tmessages_members.lo monetary_members.lo numeric_members.lo \\\n \ttime_members.lo\n am__objects_2 = basic_file.lo c++locale.lo\n-am__objects_3 = allocator-inst.lo codecvt.lo complex_io.lo \\\n-\tconcept-inst.lo ctype.lo demangle.lo ext-inst.lo \\\n-\tfstream-inst.lo functexcept.lo globals.lo io-inst.lo ios.lo \\\n-\tios_failure.lo istream-inst.lo limits.lo locale.lo locale-inst.lo \\\n-\tlocalename.lo misc-inst.lo ostream-inst.lo sstream-inst.lo \\\n-\tstdexcept.lo stl_tree.lo streambuf-inst.lo string-inst.lo \\\n-\tstrstream.lo valarray-inst.lo wstring-inst.lo $(am__objects_1) \\\n-\t$(am__objects_2)\n+am__objects_3 = codecvt.lo complex_io.lo ctype.lo demangle.lo \\\n+\tfunctexcept.lo globals_locale.lo globals_io.lo ios.lo \\\n+\tios_failure.lo ios_init.lo ios_locale.lo limits.lo locale.lo \\\n+\tlocale_init.lo locale_facets.lo localename.lo stdexcept.lo \\\n+\tstl_tree.lo strstream.lo allocator-inst.lo concept-inst.lo \\\n+\tfstream-inst.lo ext-inst.lo io-inst.lo istream-inst.lo \\\n+\tlocale-inst.lo locale-misc-inst.lo misc-inst.lo ostream-inst.lo \\\n+\tsstream-inst.lo streambuf-inst.lo string-inst.lo \\\n+\tvalarray-inst.lo wlocale-inst.lo wstring-inst.lo \\\n+\t$(am__objects_1) $(am__objects_2)\n am_libstdc___la_OBJECTS = $(am__objects_3)\n libstdc___la_OBJECTS = $(am_libstdc___la_OBJECTS)\n \n@@ -373,7 +380,8 @@ CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n \t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n CXXLD = $(CXX)\n DIST_SOURCES = $(libstdc___la_SOURCES)\n-DIST_COMMON = $(top_srcdir)/fragment.am Makefile.am Makefile.in\n+DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/fragment.am \\\n+\tMakefile.am\n SOURCES = $(libstdc___la_SOURCES)\n \n all: all-am\n@@ -552,7 +560,7 @@ mostlyclean-generic:\n clean-generic:\n \n distclean-generic:\n-\t-rm -f Makefile $(CONFIG_CLEAN_FILES)\n+\t-rm -f $(CONFIG_CLEAN_FILES)\n \n maintainer-clean-generic:\n \t@echo \"This command is intended for maintainers to use\"\n@@ -563,7 +571,7 @@ clean-am: clean-generic clean-libtool clean-toolexeclibLTLIBRARIES \\\n \tmostlyclean-am\n \n distclean: distclean-am\n-\n+\t-rm -f Makefile\n distclean-am: clean-am distclean-compile distclean-generic \\\n \tdistclean-libtool distclean-tags\n \n@@ -586,7 +594,7 @@ install-man:\n installcheck-am:\n \n maintainer-clean: maintainer-clean-am\n-\n+\t-rm -f Makefile\n maintainer-clean-am: distclean-am maintainer-clean-generic\n \n mostlyclean: mostlyclean-am"}, {"sha": "7be53f2f30d0e37d4a6740eec86c352e9804af3c", "filename": "libstdc++-v3/src/globals_io.cc", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Fglobals_io.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Fglobals_io.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fglobals_io.cc?ref=c755e77d63980a40e93c82da335aa59cb30de107", "patch": "@@ -0,0 +1,128 @@\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include \"bits/c++config.h\"\n+#include \"bits/gthr.h\"\n+#include <fstream>\n+#include <istream>\n+#include <ostream>\n+#include <ext/stdio_filebuf.h>\n+#include <ext/stdio_sync_filebuf.h>\n+\n+// On AIX, and perhaps other systems, library initialization order is\n+// not guaranteed.  For example, the static initializers for the main\n+// program might run before the static initializers for this library.\n+// That means that we cannot rely on static initialization in the\n+// library; there is no guarantee that things will get initialized in\n+// time.  This file contains definitions of all global variables that\n+// require initialization as arrays of characters.\n+\n+// NB: asm directives can rename these non-exported, namespace\n+// __gnu_cxx symbols into exported, namespace std symbols with the\n+// appropriate symbol version name.\n+// The rename syntax is \n+//   asm (\".symver currentname,oldname@@GLIBCXX_3.2\")\n+// In macro form:\n+// _GLIBCXX_ASM_SYMVER(currentname, oldname, GLIBCXX_3.2)\n+\n+namespace std\n+{\n+  // Standard stream objects.\n+  // NB: Iff <iostream> is included, these definitions become wonky.\n+  typedef char fake_istream[sizeof(istream)]\n+  __attribute__ ((aligned(__alignof__(istream))));\n+  typedef char fake_ostream[sizeof(ostream)] \n+  __attribute__ ((aligned(__alignof__(ostream))));\n+  fake_istream cin;\n+  fake_ostream cout;\n+  fake_ostream cerr;\n+  fake_ostream clog;\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  typedef char fake_wistream[sizeof(wistream)] \n+  __attribute__ ((aligned(__alignof__(wistream))));\n+  typedef char fake_wostream[sizeof(wostream)] \n+  __attribute__ ((aligned(__alignof__(wostream))));\n+  fake_wistream wcin;\n+  fake_wostream wcout;\n+  fake_wostream wcerr;\n+  fake_wostream wclog;\n+#endif\n+} // namespace std\n+\n+namespace __gnu_cxx\n+{\n+  using namespace std;\n+\n+  // We use different stream buffer types depending on whether\n+  // ios_base::sync_with_stdio(false) has been called.\n+  typedef char fake_stdiobuf[sizeof(stdio_sync_filebuf<char>)]\n+  __attribute__ ((aligned(__alignof__(stdio_sync_filebuf<char>))));\n+  fake_stdiobuf buf_cout_sync;\n+  fake_stdiobuf buf_cin_sync;\n+  fake_stdiobuf buf_cerr_sync;\n+\n+  typedef char fake_filebuf[sizeof(stdio_filebuf<char>)]\n+  __attribute__ ((aligned(__alignof__(stdio_filebuf<char>))));\n+  fake_filebuf buf_cout;\n+  fake_filebuf buf_cin;\n+  fake_filebuf buf_cerr;\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  typedef char fake_wstdiobuf[sizeof(stdio_sync_filebuf<wchar_t>)]\n+  __attribute__ ((aligned(__alignof__(stdio_sync_filebuf<wchar_t>))));\n+  fake_wstdiobuf buf_wcout_sync;\n+  fake_wstdiobuf buf_wcin_sync;\n+  fake_wstdiobuf buf_wcerr_sync;\n+\n+  typedef char fake_wfilebuf[sizeof(stdio_filebuf<wchar_t>)]\n+  __attribute__ ((aligned(__alignof__(stdio_filebuf<wchar_t>))));\n+  fake_wfilebuf buf_wcout;\n+  fake_wfilebuf buf_wcin;\n+  fake_wfilebuf buf_wcerr;\n+#endif\n+\n+  // Globals for once-only runtime initialization of mutex objects.  This\n+  // allows static initialization of these objects on systems that need a\n+  // function call to initialize a mutex.  For example, see stl_threads.h.\n+#ifdef __GTHREAD_MUTEX_INIT\n+#elif defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n+  __gthread_once_t _GLIBCXX_once = __GTHREAD_ONCE_INIT;\n+  __gthread_mutex_t _GLIBCXX_mutex;\n+  __gthread_mutex_t *_GLIBCXX_mutex_address;\n+  \n+  // Once-only initializer function for _GLIBCXX_mutex.  \n+  void\n+  _GLIBCXX_mutex_init ()\n+  { __GTHREAD_MUTEX_INIT_FUNCTION (&_GLIBCXX_mutex); }\n+\n+  // Once-only initializer function for _GLIBCXX_mutex_address.  \n+  void\n+  _GLIBCXX_mutex_address_init ()\n+  { __GTHREAD_MUTEX_INIT_FUNCTION (_GLIBCXX_mutex_address); }\n+#endif\n+} // namespace __gnu_cxx"}, {"sha": "c79a379ff1a9541a66d3d84f602864b529618235", "filename": "libstdc++-v3/src/globals_locale.cc", "status": "renamed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Fglobals_locale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Fglobals_locale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fglobals_locale.cc?ref=c755e77d63980a40e93c82da335aa59cb30de107", "patch": "@@ -25,14 +25,7 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-#include \"bits/c++config.h\"\n-#include \"bits/gthr.h\"\n-#include <fstream>\n-#include <istream>\n-#include <ostream>\n #include <locale>\n-#include <ext/stdio_filebuf.h>\n-#include <ext/stdio_sync_filebuf.h>\n \n // On AIX, and perhaps other systems, library initialization order is\n // not guaranteed.  For example, the static initializers for the main\n@@ -50,63 +43,10 @@\n // In macro form:\n // _GLIBCXX_ASM_SYMVER(currentname, oldname, GLIBCXX_3.2)\n \n-namespace std\n-{\n-  // Standard stream objects.\n-  // NB: Iff <iostream> is included, these definitions become wonky.\n-  typedef char fake_istream[sizeof(istream)]\n-  __attribute__ ((aligned(__alignof__(istream))));\n-  typedef char fake_ostream[sizeof(ostream)] \n-  __attribute__ ((aligned(__alignof__(ostream))));\n-  fake_istream cin;\n-  fake_ostream cout;\n-  fake_ostream cerr;\n-  fake_ostream clog;\n-\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  typedef char fake_wistream[sizeof(wistream)] \n-  __attribute__ ((aligned(__alignof__(wistream))));\n-  typedef char fake_wostream[sizeof(wostream)] \n-  __attribute__ ((aligned(__alignof__(wostream))));\n-  fake_wistream wcin;\n-  fake_wostream wcout;\n-  fake_wostream wcerr;\n-  fake_wostream wclog;\n-#endif\n-} // namespace std\n-\n namespace __gnu_cxx\n {\n   using namespace std;\n \n-  // We use different stream buffer types depending on whether\n-  // ios_base::sync_with_stdio(false) has been called.\n-  typedef char fake_stdiobuf[sizeof(stdio_sync_filebuf<char>)]\n-  __attribute__ ((aligned(__alignof__(stdio_sync_filebuf<char>))));\n-  fake_stdiobuf buf_cout_sync;\n-  fake_stdiobuf buf_cin_sync;\n-  fake_stdiobuf buf_cerr_sync;\n-\n-  typedef char fake_filebuf[sizeof(stdio_filebuf<char>)]\n-  __attribute__ ((aligned(__alignof__(stdio_filebuf<char>))));\n-  fake_filebuf buf_cout;\n-  fake_filebuf buf_cin;\n-  fake_filebuf buf_cerr;\n-\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  typedef char fake_wstdiobuf[sizeof(stdio_sync_filebuf<wchar_t>)]\n-  __attribute__ ((aligned(__alignof__(stdio_sync_filebuf<wchar_t>))));\n-  fake_wstdiobuf buf_wcout_sync;\n-  fake_wstdiobuf buf_wcin_sync;\n-  fake_wstdiobuf buf_wcerr_sync;\n-\n-  typedef char fake_wfilebuf[sizeof(stdio_filebuf<wchar_t>)]\n-  __attribute__ ((aligned(__alignof__(stdio_filebuf<wchar_t>))));\n-  fake_wfilebuf buf_wcout;\n-  fake_wfilebuf buf_wcin;\n-  fake_wfilebuf buf_wcerr;\n-#endif\n-\n   typedef char fake_locale_Impl[sizeof(locale::_Impl)]\n   __attribute__ ((aligned(__alignof__(locale::_Impl))));\n   fake_locale_Impl c_locale_impl;\n@@ -267,24 +207,4 @@ namespace __gnu_cxx\n   __attribute__ ((aligned(__alignof__(std::__timepunct_cache<wchar_t>))));\n   fake_time_cache_w timepunct_cache_w;\n #endif\n-\n-  // Globals for once-only runtime initialization of mutex objects.  This\n-  // allows static initialization of these objects on systems that need a\n-  // function call to initialize a mutex.  For example, see stl_threads.h.\n-#ifdef __GTHREAD_MUTEX_INIT\n-#elif defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n-  __gthread_once_t _GLIBCXX_once = __GTHREAD_ONCE_INIT;\n-  __gthread_mutex_t _GLIBCXX_mutex;\n-  __gthread_mutex_t *_GLIBCXX_mutex_address;\n-  \n-  // Once-only initializer function for _GLIBCXX_mutex.  \n-  void\n-  _GLIBCXX_mutex_init ()\n-  { __GTHREAD_MUTEX_INIT_FUNCTION (&_GLIBCXX_mutex); }\n-\n-  // Once-only initializer function for _GLIBCXX_mutex_address.  \n-  void\n-  _GLIBCXX_mutex_address_init ()\n-  { __GTHREAD_MUTEX_INIT_FUNCTION (_GLIBCXX_mutex_address); }\n-#endif\n } // namespace __gnu_cxx", "previous_filename": "libstdc++-v3/src/globals.cc"}, {"sha": "fdc1f06c1cba820c2bd55142dc9142e3d33a02a0", "filename": "libstdc++-v3/src/ios.cc", "status": "modified", "additions": 21, "deletions": 191, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Fios.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Fios.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fios.cc?ref=c755e77d63980a40e93c82da335aa59cb30de107", "patch": "@@ -33,51 +33,11 @@\n //\n \n #include <ios>\n-#include <ostream>\n-#include <istream>\n-#include <fstream>\n+#include <limits>\n #include <bits/atomicity.h>\n-#include <ext/stdio_filebuf.h>\n-#include <ext/stdio_sync_filebuf.h>\n-\n-namespace __gnu_cxx\n-{\n-  // Extern declarations for global objects in src/globals.cc.\n-  extern stdio_sync_filebuf<char> buf_cout_sync;\n-  extern stdio_sync_filebuf<char> buf_cin_sync;\n-  extern stdio_sync_filebuf<char> buf_cerr_sync;\n-\n-  extern stdio_filebuf<char> buf_cout;\n-  extern stdio_filebuf<char> buf_cin;\n-  extern stdio_filebuf<char> buf_cerr;\n-\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  extern stdio_sync_filebuf<wchar_t> buf_wcout_sync;\n-  extern stdio_sync_filebuf<wchar_t> buf_wcin_sync;\n-  extern stdio_sync_filebuf<wchar_t> buf_wcerr_sync;\n-\n-  extern stdio_filebuf<wchar_t> buf_wcout;\n-  extern stdio_filebuf<wchar_t> buf_wcin;\n-  extern stdio_filebuf<wchar_t> buf_wcerr;\n-#endif\n-} // namespace __gnu_cxx\n \n namespace std \n {\n-  using namespace __gnu_cxx;\n-  \n-  extern istream cin;\n-  extern ostream cout;\n-  extern ostream cerr;\n-  extern ostream clog;\n-\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  extern wistream wcin;\n-  extern wostream wcout;\n-  extern wostream wcerr;\n-  extern wostream wclog;\n-#endif\n-\n   // Definitions for static const data members of __ios_flags.\n   const __ios_flags::__int_type __ios_flags::_S_boolalpha;\n   const __ios_flags::__int_type __ios_flags::_S_dec;\n@@ -146,69 +106,30 @@ namespace std\n   const ios_base::seekdir ios_base::end;\n \n   const int ios_base::_S_local_word_size;\n+\n   int ios_base::Init::_S_ios_base_init = 0;\n+\n   bool ios_base::Init::_S_synced_with_stdio = true;\n \n-  ios_base::Init::Init()\n+  ios_base::ios_base() \n+  : _M_callbacks(0), _M_word_size(_S_local_word_size), _M_word(_M_local_word)\n   {\n-    if (_S_ios_base_init == 0)\n-      {\n-\t// Standard streams default to synced with \"C\" operations.\n-\t_S_synced_with_stdio = true;\n-\n-\tnew (&buf_cout_sync) stdio_sync_filebuf<char>(stdout);\n-\tnew (&buf_cin_sync) stdio_sync_filebuf<char>(stdin);\n-\tnew (&buf_cerr_sync) stdio_sync_filebuf<char>(stderr);\n-\n-\t// The standard streams are constructed once only and never\n-\t// destroyed.\n-\tnew (&cout) ostream(&buf_cout_sync);\n-\tnew (&cin) istream(&buf_cin_sync);\n-\tnew (&cerr) ostream(&buf_cerr_sync);\n-\tnew (&clog) ostream(&buf_cerr_sync);\n-\tcin.tie(&cout);\n-\tcerr.flags(ios_base::unitbuf);\n-\t\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-\tnew (&buf_wcout_sync) stdio_sync_filebuf<wchar_t>(stdout);\n-\tnew (&buf_wcin_sync) stdio_sync_filebuf<wchar_t>(stdin);\n-\tnew (&buf_wcerr_sync) stdio_sync_filebuf<wchar_t>(stderr);\n-\n-\tnew (&wcout) wostream(&buf_wcout_sync);\n-\tnew (&wcin) wistream(&buf_wcin_sync);\n-\tnew (&wcerr) wostream(&buf_wcerr_sync);\n-\tnew (&wclog) wostream(&buf_wcerr_sync);\n-\twcin.tie(&wcout);\n-\twcerr.flags(ios_base::unitbuf);\n-#endif\n-\n-\t_S_ios_base_init = 1;\n-      }\n-    ++_S_ios_base_init;\n+    // Do nothing: basic_ios::init() does it.  \n+    // NB: _M_callbacks and _M_word must be zero for non-initialized\n+    // ios_base to go through ~ios_base gracefully.\n   }\n-\n-  ios_base::Init::~Init()\n+  \n+  // 27.4.2.7  ios_base constructors/destructors\n+  ios_base::~ios_base()\n   {\n-    if (--_S_ios_base_init == 1)\n+    _M_call_callbacks(erase_event);\n+    _M_dispose_callbacks();\n+    if (_M_word != _M_local_word) \n       {\n-\t// Catch any exceptions thrown by basic_ostream::flush()\n-\ttry\n-\t  { \n-\t    // Flush standard output streams as required by 27.4.2.1.6\n-\t    cout.flush();\n-\t    cerr.flush();\n-\t    clog.flush();\n-    \n-#ifdef _GLIBCXX_USE_WCHAR_T\n-\t    wcout.flush();\n-\t    wcerr.flush();\n-\t    wclog.flush();    \n-#endif\n-\t  }\n-\tcatch (...)\n-\t  { }\n+\tdelete [] _M_word;\n+\t_M_word = 0;\n       }\n-  } \n+  }\n \n   // 27.4.2.5  ios_base storage functions\n   int \n@@ -220,6 +141,10 @@ namespace std\n     return __exchange_and_add(&_S_top, 1) + 4;\n   }\n \n+  void \n+  ios_base::register_callback(event_callback __fn, int __index)\n+  { _M_callbacks = new _Callback_list(__fn, __index, _M_callbacks); }\n+\n   // 27.4.2.5  iword/pword storage\n   ios_base::_Words&\n   ios_base::_M_grow_words(int ix)\n@@ -262,51 +187,6 @@ namespace std\n     _M_word_size = newsize;\n     return _M_word[ix];\n   }\n-  \n-  // Called only by basic_ios<>::init.\n-  void \n-  ios_base::_M_init()   \n-  {\n-    // NB: May be called more than once\n-    _M_precision = 6;\n-    _M_width = 0;\n-    _M_flags = skipws | dec;\n-    _M_ios_locale = locale();\n-  }  \n-  \n-  // 27.4.2.3  ios_base locale functions\n-  locale\n-  ios_base::imbue(const locale& __loc)\n-  {\n-    locale __old = _M_ios_locale;\n-    _M_ios_locale = __loc;\n-    _M_call_callbacks(imbue_event);\n-    return __old;\n-  }\n-\n-  ios_base::ios_base() \n-  : _M_callbacks(0), _M_word_size(_S_local_word_size), _M_word(_M_local_word)\n-  {\n-    // Do nothing: basic_ios::init() does it.  \n-    // NB: _M_callbacks and _M_word must be zero for non-initialized\n-    // ios_base to go through ~ios_base gracefully.\n-  }\n-  \n-  // 27.4.2.7  ios_base constructors/destructors\n-  ios_base::~ios_base()\n-  {\n-    _M_call_callbacks(erase_event);\n-    _M_dispose_callbacks();\n-    if (_M_word != _M_local_word) \n-      {\n-\tdelete [] _M_word;\n-\t_M_word = 0;\n-      }\n-  }\n-\n-  void \n-  ios_base::register_callback(event_callback __fn, int __index)\n-  { _M_callbacks = new _Callback_list(__fn, __index, _M_callbacks); }\n \n   void \n   ios_base::_M_call_callbacks(event __e) throw()\n@@ -334,54 +214,4 @@ namespace std\n       }\n     _M_callbacks = 0;\n   }\n-\n-  bool \n-  ios_base::sync_with_stdio(bool __sync)\n-  { \n-    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-    // 49.  Underspecification of ios_base::sync_with_stdio\n-    bool __ret = ios_base::Init::_S_synced_with_stdio;\n-\n-    // Turn off sync with C FILE* for cin, cout, cerr, clog iff\n-    // currently synchronized.\n-    if (!__sync && __ret)\n-      {\n-\tios_base::Init::_S_synced_with_stdio = __sync;\n-\n-\t// Explicitly call dtors to free any memory that is\n-\t// dynamically allocated by filebuf ctor or member functions,\n-\t// but don't deallocate all memory by calling operator delete.\n-\tbuf_cout_sync.~stdio_sync_filebuf<char>();\n-\tbuf_cin_sync.~stdio_sync_filebuf<char>();\n-\tbuf_cerr_sync.~stdio_sync_filebuf<char>();\n-\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-\tbuf_wcout_sync.~stdio_sync_filebuf<wchar_t>();\n-\tbuf_wcin_sync.~stdio_sync_filebuf<wchar_t>();\n-\tbuf_wcerr_sync.~stdio_sync_filebuf<wchar_t>();\n-#endif\n-\n-\t// Create stream buffers for the standard streams and use\n-\t// those buffers without destroying and recreating the\n-\t// streams.\n-\tnew (&buf_cout) stdio_filebuf<char>(stdout, ios_base::out);\n-\tnew (&buf_cin) stdio_filebuf<char>(stdin, ios_base::in);\n-\tnew (&buf_cerr) stdio_filebuf<char>(stderr, ios_base::out);\n-\tcout.rdbuf(&buf_cout);\n-\tcin.rdbuf(&buf_cin);\n-\tcerr.rdbuf(&buf_cerr);\n-\tclog.rdbuf(&buf_cerr);\n-    \n-#ifdef _GLIBCXX_USE_WCHAR_T\n-\tnew (&buf_wcout) stdio_filebuf<wchar_t>(stdout, ios_base::out);\n-\tnew (&buf_wcin) stdio_filebuf<wchar_t>(stdin, ios_base::in);\n-\tnew (&buf_wcerr) stdio_filebuf<wchar_t>(stderr, ios_base::out);\n-\twcout.rdbuf(&buf_wcout);\n-\twcin.rdbuf(&buf_wcin);\n-\twcerr.rdbuf(&buf_wcerr);\n-\twclog.rdbuf(&buf_wcerr);\n-#endif\n-      }\n-    return __ret; \n-  }\n } // namespace std"}, {"sha": "1645ea7b38160f24631ab363fcebe1669b615fd2", "filename": "libstdc++-v3/src/ios_init.cc", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Fios_init.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Fios_init.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fios_init.cc?ref=c755e77d63980a40e93c82da335aa59cb30de107", "patch": "@@ -0,0 +1,191 @@\n+// Iostreams base classes -*- C++ -*-\n+\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 27.4  Iostreams base classes\n+//\n+\n+#include <ios>\n+#include <ostream>\n+#include <istream>\n+#include <fstream>\n+#include <bits/atomicity.h>\n+#include <ext/stdio_filebuf.h>\n+#include <ext/stdio_sync_filebuf.h>\n+\n+namespace __gnu_cxx\n+{\n+  // Extern declarations for global objects in src/globals.cc.\n+  extern stdio_sync_filebuf<char> buf_cout_sync;\n+  extern stdio_sync_filebuf<char> buf_cin_sync;\n+  extern stdio_sync_filebuf<char> buf_cerr_sync;\n+\n+  extern stdio_filebuf<char> buf_cout;\n+  extern stdio_filebuf<char> buf_cin;\n+  extern stdio_filebuf<char> buf_cerr;\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  extern stdio_sync_filebuf<wchar_t> buf_wcout_sync;\n+  extern stdio_sync_filebuf<wchar_t> buf_wcin_sync;\n+  extern stdio_sync_filebuf<wchar_t> buf_wcerr_sync;\n+\n+  extern stdio_filebuf<wchar_t> buf_wcout;\n+  extern stdio_filebuf<wchar_t> buf_wcin;\n+  extern stdio_filebuf<wchar_t> buf_wcerr;\n+#endif\n+} // namespace __gnu_cxx\n+\n+namespace std \n+{\n+  using namespace __gnu_cxx;\n+  \n+  extern istream cin;\n+  extern ostream cout;\n+  extern ostream cerr;\n+  extern ostream clog;\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  extern wistream wcin;\n+  extern wostream wcout;\n+  extern wostream wcerr;\n+  extern wostream wclog;\n+#endif\n+\n+  ios_base::Init::Init()\n+  {\n+    if (_S_ios_base_init == 0)\n+      {\n+\t// Standard streams default to synced with \"C\" operations.\n+\t_S_synced_with_stdio = true;\n+\n+\tnew (&buf_cout_sync) stdio_sync_filebuf<char>(stdout);\n+\tnew (&buf_cin_sync) stdio_sync_filebuf<char>(stdin);\n+\tnew (&buf_cerr_sync) stdio_sync_filebuf<char>(stderr);\n+\n+\t// The standard streams are constructed once only and never\n+\t// destroyed.\n+\tnew (&cout) ostream(&buf_cout_sync);\n+\tnew (&cin) istream(&buf_cin_sync);\n+\tnew (&cerr) ostream(&buf_cerr_sync);\n+\tnew (&clog) ostream(&buf_cerr_sync);\n+\tcin.tie(&cout);\n+\tcerr.flags(ios_base::unitbuf);\n+\t\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+\tnew (&buf_wcout_sync) stdio_sync_filebuf<wchar_t>(stdout);\n+\tnew (&buf_wcin_sync) stdio_sync_filebuf<wchar_t>(stdin);\n+\tnew (&buf_wcerr_sync) stdio_sync_filebuf<wchar_t>(stderr);\n+\n+\tnew (&wcout) wostream(&buf_wcout_sync);\n+\tnew (&wcin) wistream(&buf_wcin_sync);\n+\tnew (&wcerr) wostream(&buf_wcerr_sync);\n+\tnew (&wclog) wostream(&buf_wcerr_sync);\n+\twcin.tie(&wcout);\n+\twcerr.flags(ios_base::unitbuf);\n+#endif\n+\n+\t_S_ios_base_init = 1;\n+      }\n+    ++_S_ios_base_init;\n+  }\n+\n+  ios_base::Init::~Init()\n+  {\n+    if (--_S_ios_base_init == 1)\n+      {\n+\t// Catch any exceptions thrown by basic_ostream::flush()\n+\ttry\n+\t  { \n+\t    // Flush standard output streams as required by 27.4.2.1.6\n+\t    cout.flush();\n+\t    cerr.flush();\n+\t    clog.flush();\n+    \n+#ifdef _GLIBCXX_USE_WCHAR_T\n+\t    wcout.flush();\n+\t    wcerr.flush();\n+\t    wclog.flush();    \n+#endif\n+\t  }\n+\tcatch (...)\n+\t  { }\n+      }\n+  } \n+\n+  bool \n+  ios_base::sync_with_stdio(bool __sync)\n+  { \n+    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+    // 49.  Underspecification of ios_base::sync_with_stdio\n+    bool __ret = ios_base::Init::_S_synced_with_stdio;\n+\n+    // Turn off sync with C FILE* for cin, cout, cerr, clog iff\n+    // currently synchronized.\n+    if (!__sync && __ret)\n+      {\n+\tios_base::Init::_S_synced_with_stdio = __sync;\n+\n+\t// Explicitly call dtors to free any memory that is\n+\t// dynamically allocated by filebuf ctor or member functions,\n+\t// but don't deallocate all memory by calling operator delete.\n+\tbuf_cout_sync.~stdio_sync_filebuf<char>();\n+\tbuf_cin_sync.~stdio_sync_filebuf<char>();\n+\tbuf_cerr_sync.~stdio_sync_filebuf<char>();\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+\tbuf_wcout_sync.~stdio_sync_filebuf<wchar_t>();\n+\tbuf_wcin_sync.~stdio_sync_filebuf<wchar_t>();\n+\tbuf_wcerr_sync.~stdio_sync_filebuf<wchar_t>();\n+#endif\n+\n+\t// Create stream buffers for the standard streams and use\n+\t// those buffers without destroying and recreating the\n+\t// streams.\n+\tnew (&buf_cout) stdio_filebuf<char>(stdout, ios_base::out);\n+\tnew (&buf_cin) stdio_filebuf<char>(stdin, ios_base::in);\n+\tnew (&buf_cerr) stdio_filebuf<char>(stderr, ios_base::out);\n+\tcout.rdbuf(&buf_cout);\n+\tcin.rdbuf(&buf_cin);\n+\tcerr.rdbuf(&buf_cerr);\n+\tclog.rdbuf(&buf_cerr);\n+    \n+#ifdef _GLIBCXX_USE_WCHAR_T\n+\tnew (&buf_wcout) stdio_filebuf<wchar_t>(stdout, ios_base::out);\n+\tnew (&buf_wcin) stdio_filebuf<wchar_t>(stdin, ios_base::in);\n+\tnew (&buf_wcerr) stdio_filebuf<wchar_t>(stderr, ios_base::out);\n+\twcout.rdbuf(&buf_wcout);\n+\twcin.rdbuf(&buf_wcin);\n+\twcerr.rdbuf(&buf_wcerr);\n+\twclog.rdbuf(&buf_wcerr);\n+#endif\n+      }\n+    return __ret; \n+  }\n+} // namespace std"}, {"sha": "008a4850d36b56d8ccca70f58b7e8b621e7a662e", "filename": "libstdc++-v3/src/ios_locale.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Fios_locale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Fios_locale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fios_locale.cc?ref=c755e77d63980a40e93c82da335aa59cb30de107", "patch": "@@ -0,0 +1,60 @@\n+// Iostreams base classes -*- C++ -*-\n+\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 27.4  Iostreams base classes\n+//\n+\n+#include <ios>\n+#include <locale>\n+\n+namespace std \n+{\n+  // Called only by basic_ios<>::init.\n+  void \n+  ios_base::_M_init()   \n+  {\n+    // NB: May be called more than once\n+    _M_precision = 6;\n+    _M_width = 0;\n+    _M_flags = skipws | dec;\n+    _M_ios_locale = locale();\n+  }  \n+  \n+  // 27.4.2.3  ios_base locale functions\n+  locale\n+  ios_base::imbue(const locale& __loc)\n+  {\n+    locale __old = _M_ios_locale;\n+    _M_ios_locale = __loc;\n+    _M_call_callbacks(imbue_event);\n+    return __old;\n+  }\n+} // namespace std"}, {"sha": "27a51f04afb034a717db59521cf8ed299fa7400e", "filename": "libstdc++-v3/src/locale-inst.cc", "status": "modified", "additions": 97, "deletions": 342, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc?ref=c755e77d63980a40e93c82da335aa59cb30de107", "patch": "@@ -31,466 +31,221 @@\n // ISO C++ 14882: 22.1  Locales\n //\n \n-#include <cstdlib>\n-#include <clocale>\n-#include <cstring>\n #include <locale>\n \n+// Instantiation configuration.\n+#ifndef C\n+# define C char\n+#endif\n+\n namespace std\n {\n   // moneypunct, money_get, and money_put\n-  template class moneypunct<char, false>;\n-  template class moneypunct<char, true>;\n-  template struct __moneypunct_cache<char>;\n-  template class moneypunct_byname<char, false>;\n-  template class moneypunct_byname<char, true>;\n-  template class money_get<char, istreambuf_iterator<char> >;\n-  template class money_put<char, ostreambuf_iterator<char> >;\n-\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  template class moneypunct<wchar_t, false>;\n-  template class moneypunct<wchar_t, true>;\n-  template struct __moneypunct_cache<wchar_t>;\n-  template class moneypunct_byname<wchar_t, false>;\n-  template class moneypunct_byname<wchar_t, true>;\n-  template class money_get<wchar_t, istreambuf_iterator<wchar_t> >;\n-  template class money_put<wchar_t, ostreambuf_iterator<wchar_t> >;\n-#endif\n+  template class moneypunct<C, false>;\n+  template class moneypunct<C, true>;\n+  template struct __moneypunct_cache<C>;\n+  template class moneypunct_byname<C, false>;\n+  template class moneypunct_byname<C, true>;\n+  template class money_get<C, istreambuf_iterator<C> >;\n+  template class money_put<C, ostreambuf_iterator<C> >;\n \n   // numpunct, numpunct_byname, num_get, and num_put\n-  template class numpunct<char>;\n-  template struct __numpunct_cache<char>;\n-  template class numpunct_byname<char>;\n-  template class num_get<char, istreambuf_iterator<char> >;\n-  template class num_put<char, ostreambuf_iterator<char> >; \n-  template\n-    ostreambuf_iterator<char>\n-    num_put<char, ostreambuf_iterator<char> >::\n-    _M_insert_int(ostreambuf_iterator<char>, ios_base&, char, \n+  template class numpunct<C>;\n+  template struct __numpunct_cache<C>;\n+  template class numpunct_byname<C>;\n+  template class num_get<C, istreambuf_iterator<C> >;\n+  template class num_put<C, ostreambuf_iterator<C> >; \n+  template\n+    ostreambuf_iterator<C>\n+    num_put<C, ostreambuf_iterator<C> >::\n+    _M_insert_int(ostreambuf_iterator<C>, ios_base&, C, \n \t\t  long) const;\n \n   template\n-    ostreambuf_iterator<char>\n-    num_put<char, ostreambuf_iterator<char> >::\n-    _M_insert_int(ostreambuf_iterator<char>, ios_base&, char, \n+    ostreambuf_iterator<C>\n+    num_put<C, ostreambuf_iterator<C> >::\n+    _M_insert_int(ostreambuf_iterator<C>, ios_base&, C, \n \t\t  unsigned long) const;\n \n #ifdef _GLIBCXX_USE_LONG_LONG\n   template\n-    ostreambuf_iterator<char>\n-    num_put<char, ostreambuf_iterator<char> >::\n-    _M_insert_int(ostreambuf_iterator<char>, ios_base&, char, \n+    ostreambuf_iterator<C>\n+    num_put<C, ostreambuf_iterator<C> >::\n+    _M_insert_int(ostreambuf_iterator<C>, ios_base&, C, \n \t\t  long long) const;\n \n   template\n-    ostreambuf_iterator<char>\n-    num_put<char, ostreambuf_iterator<char> >::\n-    _M_insert_int(ostreambuf_iterator<char>, ios_base&, char, \n+    ostreambuf_iterator<C>\n+    num_put<C, ostreambuf_iterator<C> >::\n+    _M_insert_int(ostreambuf_iterator<C>, ios_base&, C, \n \t\t  unsigned long long) const;\n #endif\n \n   template\n-    ostreambuf_iterator<char>\n-    num_put<char, ostreambuf_iterator<char> >::\n-    _M_insert_float(ostreambuf_iterator<char>, ios_base&, char, char, \n+    ostreambuf_iterator<C>\n+    num_put<C, ostreambuf_iterator<C> >::\n+    _M_insert_float(ostreambuf_iterator<C>, ios_base&, C, char, \n \t\t    double) const;\n \n   template\n-    ostreambuf_iterator<char>\n-    num_put<char, ostreambuf_iterator<char> >::\n-    _M_insert_float(ostreambuf_iterator<char>, ios_base&, char, char, \n+    ostreambuf_iterator<C>\n+    num_put<C, ostreambuf_iterator<C> >::\n+    _M_insert_float(ostreambuf_iterator<C>, ios_base&, C, char, \n \t\t    long double) const;\n   \n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  template class numpunct<wchar_t>;\n-  template struct __numpunct_cache<wchar_t>;\n-  template class numpunct_byname<wchar_t>;\n-  template class num_get<wchar_t, istreambuf_iterator<wchar_t> >;\n-  template class num_put<wchar_t, ostreambuf_iterator<wchar_t> >;\n-\n-  template\n-    ostreambuf_iterator<wchar_t>\n-    num_put<wchar_t, ostreambuf_iterator<wchar_t> >::\n-    _M_insert_int(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t, \n-\t\t  long) const;\n-\n-  template\n-    ostreambuf_iterator<wchar_t>\n-    num_put<wchar_t, ostreambuf_iterator<wchar_t> >::\n-    _M_insert_int(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t, \n-\t\t  unsigned long) const;\n-\n-#ifdef _GLIBCXX_USE_LONG_LONG\n-  template\n-    ostreambuf_iterator<wchar_t>\n-    num_put<wchar_t, ostreambuf_iterator<wchar_t> >::\n-    _M_insert_int(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t,\n-\t\t  long long) const;\n-\n-  template\n-    ostreambuf_iterator<wchar_t>\n-    num_put<wchar_t, ostreambuf_iterator<wchar_t> >::\n-    _M_insert_int(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t,\n-\t\t  unsigned long long) const;\n-#endif\n-\n-  template\n-    ostreambuf_iterator<wchar_t>\n-    num_put<wchar_t, ostreambuf_iterator<wchar_t> >::\n-    _M_insert_float(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t, char, \n-\t\t    double) const;\n-  \n-  template\n-    ostreambuf_iterator<wchar_t>\n-    num_put<wchar_t, ostreambuf_iterator<wchar_t> >::\n-    _M_insert_float(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t, char, \n-\t\t    long double) const;\n-#endif\n-\n   // time_get and time_put\n-  template class __timepunct<char>;\n-  template struct __timepunct_cache<char>;\n-  template class time_put<char, ostreambuf_iterator<char> >;\n-  template class time_put_byname<char, ostreambuf_iterator<char> >;\n-  template class time_get<char, istreambuf_iterator<char> >;\n-  template class time_get_byname<char, istreambuf_iterator<char> >;\n-\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  template class __timepunct<wchar_t>;\n-  template struct __timepunct_cache<wchar_t>;\n-  template class time_put<wchar_t, ostreambuf_iterator<wchar_t> >;\n-  template class time_put_byname<wchar_t, ostreambuf_iterator<wchar_t> >;\n-  template class time_get<wchar_t, istreambuf_iterator<wchar_t> >;\n-  template class time_get_byname<wchar_t, istreambuf_iterator<wchar_t> >;\n-#endif\n+  template class __timepunct<C>;\n+  template struct __timepunct_cache<C>;\n+  template class time_put<C, ostreambuf_iterator<C> >;\n+  template class time_put_byname<C, ostreambuf_iterator<C> >;\n+  template class time_get<C, istreambuf_iterator<C> >;\n+  template class time_get_byname<C, istreambuf_iterator<C> >;\n \n   // messages\n-  template class messages<char>;\n-  template class messages_byname<char>;\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  template class messages<wchar_t>;\n-  template class messages_byname<wchar_t>;\n-#endif\n+  template class messages<C>;\n+  template class messages_byname<C>;\n   \n   // ctype\n-  inline template class __ctype_abstract_base<char>;\n-  template class ctype_byname<char>;\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  inline template class __ctype_abstract_base<wchar_t>;\n-  template class ctype_byname<wchar_t>;\n-#endif\n+  inline template class __ctype_abstract_base<C>;\n+  template class ctype_byname<C>;\n   \n   // codecvt\n-  inline template class __codecvt_abstract_base<char, char, mbstate_t>;\n-  template class codecvt_byname<char, char, mbstate_t>;\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  inline template class __codecvt_abstract_base<wchar_t, char, mbstate_t>;\n-  template class codecvt_byname<wchar_t, char, mbstate_t>;\n-#endif\n+  inline template class __codecvt_abstract_base<C, char, mbstate_t>;\n+  template class codecvt_byname<C, char, mbstate_t>;\n \n   // collate\n-  template class collate<char>;\n-  template class collate_byname<char>;\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  template class collate<wchar_t>;\n-  template class collate_byname<wchar_t>;\n-#endif\n+  template class collate<C>;\n+  template class collate_byname<C>;\n     \n   // use_facet\n   // NB: use_facet<ctype> is specialized\n   template\n-    const codecvt<char, char, mbstate_t>& \n-    use_facet<codecvt<char, char, mbstate_t> >(const locale&);\n+    const codecvt<C, char, mbstate_t>& \n+    use_facet<codecvt<C, char, mbstate_t> >(const locale&);\n \n   template\n-    const collate<char>& \n-    use_facet<collate<char> >(const locale&);\n+    const collate<C>& \n+    use_facet<collate<C> >(const locale&);\n \n   template\n-    const numpunct<char>& \n-    use_facet<numpunct<char> >(const locale&);\n+    const numpunct<C>& \n+    use_facet<numpunct<C> >(const locale&);\n \n   template \n-    const num_put<char>& \n-    use_facet<num_put<char> >(const locale&);\n+    const num_put<C>& \n+    use_facet<num_put<C> >(const locale&);\n \n   template \n-    const num_get<char>& \n-    use_facet<num_get<char> >(const locale&);\n+    const num_get<C>& \n+    use_facet<num_get<C> >(const locale&);\n \n   template\n-    const moneypunct<char, true>& \n-    use_facet<moneypunct<char, true> >(const locale&);\n+    const moneypunct<C, true>& \n+    use_facet<moneypunct<C, true> >(const locale&);\n \n   template\n-    const moneypunct<char, false>& \n-    use_facet<moneypunct<char, false> >(const locale&);\n+    const moneypunct<C, false>& \n+    use_facet<moneypunct<C, false> >(const locale&);\n \n   template \n-    const money_put<char>& \n-    use_facet<money_put<char> >(const locale&);\n+    const money_put<C>& \n+    use_facet<money_put<C> >(const locale&);\n \n   template \n-    const money_get<char>& \n-    use_facet<money_get<char> >(const locale&);\n+    const money_get<C>& \n+    use_facet<money_get<C> >(const locale&);\n \n   template\n-    const __timepunct<char>& \n-    use_facet<__timepunct<char> >(const locale&);\n+    const __timepunct<C>& \n+    use_facet<__timepunct<C> >(const locale&);\n \n   template \n-    const time_put<char>& \n-    use_facet<time_put<char> >(const locale&);\n+    const time_put<C>& \n+    use_facet<time_put<C> >(const locale&);\n \n   template \n-    const time_get<char>& \n-    use_facet<time_get<char> >(const locale&);\n+    const time_get<C>& \n+    use_facet<time_get<C> >(const locale&);\n \n   template \n-    const messages<char>& \n-    use_facet<messages<char> >(const locale&);\n-\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  template\n-    const codecvt<wchar_t, char, mbstate_t>& \n-    use_facet<codecvt<wchar_t, char, mbstate_t> >(locale const&);\n-\n-  template\n-    const collate<wchar_t>& \n-    use_facet<collate<wchar_t> >(const locale&);\n-\n-  template\n-    const numpunct<wchar_t>& \n-    use_facet<numpunct<wchar_t> >(const locale&);\n-\n-  template \n-    const num_put<wchar_t>& \n-    use_facet<num_put<wchar_t> >(const locale&);\n-\n-  template \n-    const num_get<wchar_t>& \n-    use_facet<num_get<wchar_t> >(const locale&);\n-\n-  template\n-    const moneypunct<wchar_t, true>& \n-    use_facet<moneypunct<wchar_t, true> >(const locale&);\n-\n-  template\n-    const moneypunct<wchar_t, false>& \n-    use_facet<moneypunct<wchar_t, false> >(const locale&);\n- \n-  template \n-    const money_put<wchar_t>& \n-    use_facet<money_put<wchar_t> >(const locale&);\n-\n-  template \n-    const money_get<wchar_t>& \n-    use_facet<money_get<wchar_t> >(const locale&);\n-\n-  template\n-    const __timepunct<wchar_t>& \n-    use_facet<__timepunct<wchar_t> >(const locale&);\n-\n-  template \n-    const time_put<wchar_t>& \n-    use_facet<time_put<wchar_t> >(const locale&);\n-\n-  template \n-    const time_get<wchar_t>& \n-    use_facet<time_get<wchar_t> >(const locale&);\n-\n-  template \n-    const messages<wchar_t>& \n-    use_facet<messages<wchar_t> >(const locale&);\n-#endif\n+    const messages<C>& \n+    use_facet<messages<C> >(const locale&);\n \n   // has_facet\n   template \n     bool\n-    has_facet<ctype<char> >(const locale&);\n-\n-  template \n-    bool\n-    has_facet<codecvt<char, char, mbstate_t> >(const locale&);\n-\n-  template \n-    bool\n-    has_facet<collate<char> >(const locale&);\n-\n-  template \n-    bool\n-    has_facet<numpunct<char> >(const locale&);\n+    has_facet<ctype<C> >(const locale&);\n \n   template \n     bool\n-    has_facet<num_put<char> >(const locale&);\n+    has_facet<codecvt<C, char, mbstate_t> >(const locale&);\n \n   template \n     bool\n-    has_facet<num_get<char> >(const locale&);\n+    has_facet<collate<C> >(const locale&);\n \n   template \n     bool\n-    has_facet<moneypunct<char> >(const locale&);\n+    has_facet<numpunct<C> >(const locale&);\n \n   template \n     bool\n-    has_facet<money_put<char> >(const locale&);\n+    has_facet<num_put<C> >(const locale&);\n \n   template \n     bool\n-    has_facet<money_get<char> >(const locale&);\n+    has_facet<num_get<C> >(const locale&);\n \n   template \n     bool\n-    has_facet<__timepunct<char> >(const locale&);\n+    has_facet<moneypunct<C> >(const locale&);\n \n   template \n     bool\n-    has_facet<time_put<char> >(const locale&);\n-\n-  template \n-    bool\n-    has_facet<time_get<char> >(const locale&);\n-\n-  template \n-    bool\n-    has_facet<messages<char> >(const locale&);\n-\n-#ifdef _GLIBCXX_USE_WCHAR_T\n- template \n-    bool\n-    has_facet<ctype<wchar_t> >(const locale&);\n+    has_facet<money_put<C> >(const locale&);\n \n   template \n     bool\n-    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);\n+    has_facet<money_get<C> >(const locale&);\n \n   template \n     bool\n-    has_facet<collate<wchar_t> >(const locale&);\n+    has_facet<__timepunct<C> >(const locale&);\n \n   template \n     bool\n-    has_facet<numpunct<wchar_t> >(const locale&);\n+    has_facet<time_put<C> >(const locale&);\n \n   template \n     bool\n-    has_facet<num_put<wchar_t> >(const locale&);\n+    has_facet<time_get<C> >(const locale&);\n \n   template \n     bool\n-    has_facet<num_get<wchar_t> >(const locale&);\n+    has_facet<messages<C> >(const locale&);\n \n-  template \n-    bool\n-    has_facet<moneypunct<wchar_t> >(const locale&);\n-\n-  template \n-    bool\n-    has_facet<money_put<wchar_t> >(const locale&);\n-\n-  template \n-    bool\n-    has_facet<money_get<wchar_t> >(const locale&);\n \n-  template \n-    bool\n-    has_facet<__timepunct<wchar_t> >(const locale&);\n-\n-  template \n-    bool\n-    has_facet<time_put<wchar_t> >(const locale&);\n-\n-  template \n-    bool\n-    has_facet<time_get<wchar_t> >(const locale&);\n-\n-  template \n-    bool\n-    has_facet<messages<wchar_t> >(const locale&);\n-#endif\n-\n-  // locale\n+  // locale functions.\n   template\n-    char*\n-    __add_grouping<char>(char*, char, char const*, char const*, \n-\t\t\t char const*, char const*);\n+    C*\n+    __add_grouping<C>(C*, C, char const*, char const*, \n+\t\t\t C const*, C const*);\n \n   template\n     bool\n-    __verify_grouping<char>(const basic_string<char>&, basic_string<char>&);\n+    __verify_grouping<C>(const basic_string<C>&, basic_string<C>&);\n \n-  template class __pad<char, char_traits<char> >;\n+  template class __pad<C, char_traits<C> >;\n \n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  template\n-    wchar_t*\n-    __add_grouping<wchar_t>(wchar_t*, wchar_t, char const*, char const*, \n-\t\t\t    wchar_t const*, wchar_t const*);\n-  template\n-    bool\n-    __verify_grouping<wchar_t>(const basic_string<wchar_t>&, \n-\t\t\t       basic_string<wchar_t>&);\n-\n-  template class __pad<wchar_t, char_traits<wchar_t> >;\n-#endif \n-\n-  template\n-    int\n-    __convert_from_v(char*, const int, const char*, double, \n-\t\t     const __c_locale&, int);\n-\n-  template\n-    int\n-    __convert_from_v(char*, const int, const char*, long double, \n-\t\t     const __c_locale&, int);\n-\n-  template\n-    int\n-    __convert_from_v(char*, const int, const char*, long, \n-\t\t     const __c_locale&, int);\n-\n-  template\n-    int\n-    __convert_from_v(char*, const int, const char*, unsigned long, \n-\t\t     const __c_locale&, int);\n-\n-#ifdef _GLIBCXX_USE_LONG_LONG\n-  template\n-    int\n-    __convert_from_v(char*, const int, const char*, long long, \n-\t\t     const __c_locale&, int);\n-\n-  template\n-    int\n-    __convert_from_v(char*, const int, const char*, unsigned long long, \n-\t\t     const __c_locale&, int);\n-#endif\n-\n-  template\n-    int\n-    __int_to_char(char*, const int, unsigned long, const char*, \n-\t\t  ios_base::fmtflags, bool);\n-\n-#ifdef _GLIBCXX_USE_WCHAR_T\n   template\n     int\n-    __int_to_char(wchar_t*, const int, unsigned long, const wchar_t*, \n+    __int_to_char(C*, const int, unsigned long, const C*, \n \t\t  ios_base::fmtflags, bool);\n-#endif\n \n #ifdef _GLIBCXX_USE_LONG_LONG\n   template\n     int\n-    __int_to_char(char*, const int, unsigned long long, const char*, \n-\t\t  ios_base::fmtflags, bool);\n-\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  template\n-    int\n-    __int_to_char(wchar_t*, const int, unsigned long long, const wchar_t*,\n+    __int_to_char(C*, const int, unsigned long long, const C*, \n \t\t  ios_base::fmtflags, bool);\n #endif\n-#endif\n } // namespace std"}, {"sha": "73169c19cdd492420b136da08164c1c06d567809", "filename": "libstdc++-v3/src/locale-misc-inst.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Flocale-misc-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Flocale-misc-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale-misc-inst.cc?ref=c755e77d63980a40e93c82da335aa59cb30de107", "patch": "@@ -0,0 +1,69 @@\n+// Locale support -*- C++ -*-\n+\n+// Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 22.1  Locales\n+//\n+\n+#include <locale>\n+\n+namespace std\n+{\n+  template\n+    int\n+    __convert_from_v(char*, const int, const char*, double, \n+\t\t     const __c_locale&, int);\n+\n+  template\n+    int\n+    __convert_from_v(char*, const int, const char*, long double, \n+\t\t     const __c_locale&, int);\n+\n+  template\n+    int\n+    __convert_from_v(char*, const int, const char*, long, \n+\t\t     const __c_locale&, int);\n+\n+  template\n+    int\n+    __convert_from_v(char*, const int, const char*, unsigned long, \n+\t\t     const __c_locale&, int);\n+\n+#ifdef _GLIBCXX_USE_LONG_LONG\n+  template\n+    int\n+    __convert_from_v(char*, const int, const char*, long long, \n+\t\t     const __c_locale&, int);\n+\n+  template\n+    int\n+    __convert_from_v(char*, const int, const char*, unsigned long long, \n+\t\t     const __c_locale&, int);\n+#endif\n+} // namespace std"}, {"sha": "78d0059e3ed6fa20990de4c9d9f6baf8f0e3b604", "filename": "libstdc++-v3/src/locale.cc", "status": "modified", "additions": 172, "deletions": 362, "changes": 534, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc?ref=c755e77d63980a40e93c82da335aa59cb30de107", "patch": "@@ -34,17 +34,8 @@\n #include <locale>\n #include <bits/atomicity.h>\n \n-namespace __gnu_cxx\n-{\n-  // Defined in globals.cc.\n-  extern std::locale \t\tc_locale;\n-  extern std::locale::_Impl \tc_locale_impl;\n-} // namespace __gnu_cxx\n-\n namespace std \n {\n-  using namespace __gnu_cxx;\n-\n   // Definitions for static const data members of locale.\n   const locale::category \tlocale::none;\n   const locale::category \tlocale::ctype;\n@@ -55,10 +46,6 @@ namespace std\n   const locale::category \tlocale::messages;\n   const locale::category \tlocale::all;\n \n-  // In the future, GLIBCXX_ABI > 5 should remove all uses of\n-  // _GLIBCXX_ASM_SYMVER in this file, and remove exports of any\n-  // static data members of locale.\n-\n   // These are no longer exported.\n   locale::_Impl*                locale::_S_classic;\n   locale::_Impl* \t\tlocale::_S_global; \n@@ -68,112 +55,6 @@ namespace std\n   __gthread_once_t \t\tlocale::_S_once = __GTHREAD_ONCE_INIT;\n #endif\n \n-  size_t\n-  locale::id::_M_id() const\n-  {\n-    if (!_M_index)\n-      _M_index = 1 + __exchange_and_add(&_S_highwater, 1);\n-    return _M_index - 1;\n-  }\n-\n-  // Definitions for static const data members of locale::id\n-  _Atomic_word locale::id::_S_highwater;  // init'd to 0 by linker\n-\n-  // Definitions for static const data members of locale::_Impl\n-  const locale::id* const\n-  locale::_Impl::_S_id_ctype[] =\n-  {\n-    &std::ctype<char>::id, \n-    &codecvt<char, char, mbstate_t>::id,\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-    &std::ctype<wchar_t>::id,\n-    &codecvt<wchar_t, char, mbstate_t>::id,\n-#endif\n-    0\n-  };\n-\n-  const locale::id* const\n-  locale::_Impl::_S_id_numeric[] =\n-  {\n-    &num_get<char>::id,  \n-    &num_put<char>::id,  \n-    &numpunct<char>::id, \n-#ifdef _GLIBCXX_USE_WCHAR_T\n-    &num_get<wchar_t>::id,\n-    &num_put<wchar_t>::id,\n-    &numpunct<wchar_t>::id,\n-#endif\n-    0\n-  };\n-  \n-  const locale::id* const\n-  locale::_Impl::_S_id_collate[] =\n-  {\n-    &std::collate<char>::id,\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-    &std::collate<wchar_t>::id,\n-#endif\n-    0\n-  };\n-\n-  const locale::id* const\n-  locale::_Impl::_S_id_time[] =\n-  {\n-    &__timepunct<char>::id, \n-    &time_get<char>::id, \n-    &time_put<char>::id, \n-#ifdef _GLIBCXX_USE_WCHAR_T\n-    &__timepunct<wchar_t>::id, \n-    &time_get<wchar_t>::id,\n-    &time_put<wchar_t>::id,\n-#endif\n-    0\n-  };\n-  \n-  const locale::id* const\n-  locale::_Impl::_S_id_monetary[] =\n-  {\n-    &money_get<char>::id,        \n-    &money_put<char>::id,        \n-    &moneypunct<char, false>::id, \n-    &moneypunct<char, true >::id, \n-#ifdef _GLIBCXX_USE_WCHAR_T\n-    &money_get<wchar_t>::id,\n-    &money_put<wchar_t>::id,\n-    &moneypunct<wchar_t, false>::id,\n-    &moneypunct<wchar_t, true >::id,\n-#endif\n-    0\n-  };\n-\n-  const locale::id* const\n-  locale::_Impl::_S_id_messages[] =\n-  {\n-    &std::messages<char>::id, \n-#ifdef _GLIBCXX_USE_WCHAR_T\n-    &std::messages<wchar_t>::id,\n-#endif\n-    0\n-  };\n-  \n-  const locale::id* const* const\n-  locale::_Impl::_S_facet_categories[] =\n-  {\n-    // Order must match the decl order in class locale.\n-    locale::_Impl::_S_id_ctype,\n-    locale::_Impl::_S_id_numeric,\n-    locale::_Impl::_S_id_collate,\n-    locale::_Impl::_S_id_time,\n-    locale::_Impl::_S_id_monetary,\n-    locale::_Impl::_S_id_messages,\n-    0\n-  };\n-\n-  locale::locale() throw()\n-  { \n-    _S_initialize(); \n-    (_M_impl = _S_global)->_M_add_reference(); \n-  }\n \n   locale::locale(const locale& __other) throw()\n   { (_M_impl = __other._M_impl)->_M_add_reference(); }\n@@ -184,130 +65,6 @@ namespace std\n   locale::locale(_Impl* __ip) throw() : _M_impl(__ip)\n   { }\n \n-  locale::locale(const char* __s)\n-  {\n-    if (__s)\n-      {\n-\t_S_initialize(); \n-\tif (std::strcmp(__s, \"C\") == 0 || std::strcmp(__s, \"POSIX\") == 0)\n-\t  (_M_impl = _S_classic)->_M_add_reference();\n-\telse if (std::strcmp(__s, \"\") != 0)\n-\t  _M_impl = new _Impl(__s, 1);\n-\telse\n-\t  {\n-\t    // Get it from the environment.\n-\t    char* __env = std::getenv(\"LC_ALL\");\n-\t    // If LC_ALL is set we are done.\n-\t    if (__env && std::strcmp(__env, \"\") != 0)\n-\t      {\n-\t\tif (std::strcmp(__env, \"C\") == 0 \n-\t\t    || std::strcmp(__env, \"POSIX\") == 0)\n-\t\t  (_M_impl = _S_classic)->_M_add_reference();\n-\t\telse\n-\t\t  _M_impl = new _Impl(__env, 1);\n-\t      }\n-\t    else\n-\t      {\n-\t\tstring __res;\n-\t\t// LANG may set a default different from \"C\".\n-\t\tchar* __env = std::getenv(\"LANG\");\n-\t\tif (!__env || std::strcmp(__env, \"\") == 0 \n-\t\t    || std::strcmp(__env, \"C\") == 0 \n-\t\t    || std::strcmp(__env, \"POSIX\") == 0)\n-\t\t  __res = \"C\";\n-\t\telse \n-\t\t  __res = __env;\n-\t\t\n-\t\t// Scan the categories looking for the first one\n-\t\t// different from LANG.\n-\t\tsize_t __i = 0;\n-\t\tif (__res == \"C\")\n-\t\t  for (; __i < _S_categories_size; ++__i)\n-\t\t    {\n-\t\t      __env = std::getenv(_S_categories[__i]);\n-\t\t      if (__env && std::strcmp(__env, \"\") != 0 \n-\t\t\t  && std::strcmp(__env, \"C\") != 0 \n-\t\t\t  && std::strcmp(__env, \"POSIX\") != 0)\n-\t\t\tbreak;\n-\t\t    }\n-\t\telse\n-\t\t  for (; __i < _S_categories_size; ++__i)\n-\t\t    {\n-\t\t      __env = std::getenv(_S_categories[__i]);\n-\t\t      if (__env && std::strcmp(__env, \"\") != 0\n-\t\t\t  && __res != __env)\n-\t\t\tbreak;\n-\t\t    }\n-\t\n-\t\t// If one is found, build the complete string of\n-\t\t// the form LC_CTYPE=xxx;LC_NUMERIC=yyy; and so on...\n-\t\tif (__i < _S_categories_size)\n-\t\t  {\n-\t\t    string __str;\n-\t\t    for (size_t __j = 0; __j < __i; ++__j)\n-\t\t      {\n-\t\t\t__str += _S_categories[__j];\n-\t\t\t__str += '=';\n-\t\t\t__str += __res;\n-\t\t\t__str += ';';\n-\t\t      }\n-\t\t    __str += _S_categories[__i];\n-\t\t    __str += '=';\n-\t\t    __str += __env;\n-\t\t    __str += ';';\n-\t\t    __i++;\n-\t\t    for (; __i < _S_categories_size; ++__i)\n-\t\t      {\n-\t\t\t__env = std::getenv(_S_categories[__i]);\n-\t\t\tif (!__env || std::strcmp(__env, \"\") == 0)\n-\t\t\t  {\n-\t\t\t    __str += _S_categories[__i];\n-\t\t\t    __str += '=';\n-\t\t\t    __str += __res;\n-\t\t\t    __str += ';';\n-\t\t\t  }\n-\t\t\telse if (std::strcmp(__env, \"C\") == 0\n-\t\t\t\t || std::strcmp(__env, \"POSIX\") == 0)\n-\t\t\t  {\n-\t\t\t    __str += _S_categories[__i];\n-\t\t\t    __str += \"=C;\";\n-\t\t\t  }\n-\t\t\telse\n-\t\t\t  {\n-\t\t\t    __str += _S_categories[__i];\n-\t\t\t    __str += '=';\n-\t\t\t    __str += __env;\n-\t\t\t    __str += ';';\n-\t\t\t  }\n-\t\t      }\n-\t\t    __str.erase(__str.end() - 1);\n-\t\t    _M_impl = new _Impl(__str.c_str(), 1);\n-\t\t  }\n-\t\t// ... otherwise either an additional instance of\n-\t\t// the \"C\" locale or LANG.\n-\t\telse if (__res == \"C\")\n-\t\t  (_M_impl = _S_classic)->_M_add_reference();\n-\t\telse\n-\t\t  _M_impl = new _Impl(__res.c_str(), 1);\n-\t      }\n-\t  }\n-      }\n-    else\n-      __throw_runtime_error(\"locale::locale NULL not valid\");\n-  }\n-\n-  locale::locale(const locale& __base, const char* __s, category __cat)\n-  { \n-    // NB: There are complicated, yet more efficient ways to do\n-    // this. Building up locales on a per-category way is tedious, so\n-    // let's do it this way until people complain.\n-    locale __add(__s);\n-    _M_coalesce(__base, __add, __cat);\n-  }\n-\n-  locale::locale(const locale& __base, const locale& __add, category __cat)\n-  { _M_coalesce(__base, __add, __cat); }\n-\n   locale::~locale() throw()\n   { _M_impl->_M_remove_reference(); }\n \n@@ -328,27 +85,6 @@ namespace std\n     return *this;\n   }\n \n-  locale\n-  locale::global(const locale& __other)\n-  {\n-    _S_initialize();\n-\n-    // XXX MT\n-    _Impl* __old = _S_global;\n-    __other._M_impl->_M_add_reference();\n-    _S_global = __other._M_impl; \n-    if (_S_global->_M_check_same_name() \n-\t&& (std::strcmp(_S_global->_M_names[0], \"*\") != 0))\n-      setlocale(LC_ALL, __other.name().c_str());\n-\n-    // Reference count sanity check: one reference removed for the\n-    // subsition of __other locale, one added by return-by-value. Net\n-    // difference: zero. When the returned locale object's destrutor\n-    // is called, then the reference count is decremented and possibly\n-    // destroyed.\n-    return locale(__old);\n-  }\n-\n   string\n   locale::name() const\n   {\n@@ -371,50 +107,6 @@ namespace std\n     return __ret;\n   }\n \n-  const locale&\n-  locale::classic()\n-  {\n-    _S_initialize();\n-    return c_locale;\n-  }\n-\n-  void\n-  locale::_S_initialize_once()\n-  {\n-    // 2 references.\n-    // One reference for _S_classic, one for _S_global\n-    _S_classic = new (&c_locale_impl) _Impl(2);\n-    _S_global = _S_classic; \t    \n-    new (&c_locale) locale(_S_classic);\n-  }\n-\n-  void  \n-  locale::_S_initialize()\n-  {\n-#ifdef __GTHREADS\n-    if (__gthread_active_p())\n-      __gthread_once(&_S_once, _S_initialize_once);\n-#endif\n-    if (!_S_classic)\n-      _S_initialize_once();\n-  }\n-\n-  void\n-  locale::_M_coalesce(const locale& __base, const locale& __add, \n-\t\t      category __cat)\n-  {\n-    __cat = _S_normalize_category(__cat);  \n-    _M_impl = new _Impl(*__base._M_impl, 1);  \n-\n-    try \n-      { _M_impl->_M_replace_categories(__add._M_impl, __cat); }\n-    catch (...) \n-      { \n-\t_M_impl->_M_remove_reference(); \n-\t__throw_exception_again;\n-      }\n-  }\n-\n   locale::category\n   locale::_S_normalize_category(category __cat) \n   {\n@@ -457,6 +149,7 @@ namespace std\n     return __ret;\n   }\n \n+  // locale::facet\n   __c_locale locale::facet::_S_c_locale;\n \n   const char locale::facet::_S_c_name[2] = \"C\";\n@@ -465,9 +158,6 @@ namespace std\n   __gthread_once_t locale::facet::_S_once = __GTHREAD_ONCE_INIT;\n #endif\n \n-  locale::facet::\n-  ~facet() { }\n-\n   void\n   locale::facet::_S_initialize_once()\n   {\n@@ -494,62 +184,182 @@ namespace std\n   locale::facet::_S_get_c_name()\n   { return _S_c_name; }\n \n-  // Definitions for static const data members of time_base.\n-  template<> \n-    const char*\n-    __timepunct_cache<char>::_S_timezones[14] =\n-    { \n-      \"GMT\", \"HST\", \"AKST\", \"PST\", \"MST\", \"CST\", \"EST\", \"AST\", \"NST\", \"CET\", \n-      \"IST\", \"EET\", \"CST\", \"JST\"  \n-    };\n- \n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  template<> \n-    const wchar_t*\n-    __timepunct_cache<wchar_t>::_S_timezones[14] =\n-    { \n-      L\"GMT\", L\"HST\", L\"AKST\", L\"PST\", L\"MST\", L\"CST\", L\"EST\", L\"AST\", \n-      L\"NST\", L\"CET\", L\"IST\", L\"EET\", L\"CST\", L\"JST\"  \n-    };\n-#endif\n+  locale::facet::\n+  ~facet() { }\n \n-  // Definitions for static const data members of money_base.\n-  const money_base::pattern \n-  money_base::_S_default_pattern =  { {symbol, sign, none, value} };\n+  // locale::_Impl\n+  locale::_Impl::\n+  ~_Impl() throw()\n+  {\n+    if (_M_facets)\n+      for (size_t __i = 0; __i < _M_facets_size; ++__i)\n+\tif (_M_facets[__i])\n+\t  _M_facets[__i]->_M_remove_reference();\n+    delete [] _M_facets;\n+\n+    if (_M_caches)\n+      for (size_t __i = 0; __i < _M_facets_size; ++__i)\n+\tif (_M_caches[__i])\n+\t  _M_caches[__i]->_M_remove_reference(); \n+    delete [] _M_caches;\n+\n+    if (_M_names)\n+      for (size_t __i = 0; __i < _S_categories_size; ++__i)\n+\tdelete [] _M_names[__i];  \n+    delete [] _M_names;\n+  }\n \n-  const char* __num_base::_S_atoms_in = \"-+xX0123456789eEabcdfABCDF\";\n-  const char* __num_base::_S_atoms_out =\"-+xX0123456789abcdef0123456789ABCDEF\";\n+  // Clone existing _Impl object.\n+  locale::_Impl::\n+  _Impl(const _Impl& __imp, size_t __refs)\n+  : _M_references(__refs), _M_facets_size(__imp._M_facets_size)\n+  {\n+    _M_facets = _M_caches = 0;\n+    _M_names = 0;\n+    try\n+      {\n+\t_M_facets = new const facet*[_M_facets_size];\n+\tfor (size_t __i = 0; __i < _M_facets_size; ++__i)\n+\t  {\n+\t    _M_facets[__i] = __imp._M_facets[__i];\n+\t    if (_M_facets[__i])\n+\t      _M_facets[__i]->_M_add_reference();\n+\t  }\n+\t_M_caches = new const facet*[_M_facets_size];\n+\tfor (size_t __i = 0; __i < _M_facets_size; ++__i)\n+\t  {\n+\t    _M_caches[__i] = __imp._M_caches[__i];\n+\t    if (_M_caches[__i])\n+\t      _M_caches[__i]->_M_add_reference(); \t\n+\t  }\n+\t_M_names = new char*[_S_categories_size];\n+\tfor (size_t __i = 0; __i < _S_categories_size; ++__i)\n+\t  _M_names[__i] = 0;\n+\n+\t// Name all the categories.\n+\tfor (size_t __i = 0; __i < _S_categories_size; ++__i)\n+\t  {\n+\t    char* __new = new char[std::strlen(__imp._M_names[__i]) + 1];\n+\t    std::strcpy(__new, __imp._M_names[__i]);\n+\t    _M_names[__i] = __new;\n+\t  }\n+      }\n+    catch(...)\n+      {\n+\tthis->~_Impl();\n+\t__throw_exception_again;\n+      }\n+  }\n \n-  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-  // According to the resolution of DR 231, about 22.2.2.2.2, p11,\n-  // \"str.precision() is specified in the conversion specification\".\n   void\n-  __num_base::_S_format_float(const ios_base& __io, char* __fptr, char __mod)\n+  locale::_Impl::\n+  _M_replace_category(const _Impl* __imp, const locale::id* const* __idpp)\n   {\n-    ios_base::fmtflags __flags = __io.flags();\n-    *__fptr++ = '%';\n-    // [22.2.2.2.2] Table 60\n-    if (__flags & ios_base::showpos)\n-      *__fptr++ = '+';\n-    if (__flags & ios_base::showpoint)\n-      *__fptr++ = '#';\n-\n-    // As per DR 231: _always_, not only when \n-    // __flags & ios_base::fixed || __prec > 0\n-    *__fptr++ = '.';\n-    *__fptr++ = '*';\n-\n-    if (__mod)\n-      *__fptr++ = __mod;\n-    ios_base::fmtflags __fltfield = __flags & ios_base::floatfield;\n-    // [22.2.2.2.2] Table 58\n-    if (__fltfield == ios_base::fixed)\n-      *__fptr++ = 'f';\n-    else if (__fltfield == ios_base::scientific)\n-      *__fptr++ = (__flags & ios_base::uppercase) ? 'E' : 'e';\n-    else\n-      *__fptr++ = (__flags & ios_base::uppercase) ? 'G' : 'g';\n-    *__fptr = '\\0';\n+    for (; *__idpp; ++__idpp)\n+      _M_replace_facet(__imp, *__idpp);\n+  }\n+  \n+  void\n+  locale::_Impl::\n+  _M_replace_facet(const _Impl* __imp, const locale::id* __idp)\n+  {\n+    size_t __index = __idp->_M_id();\n+    if ((__index > (__imp->_M_facets_size - 1)) || !__imp->_M_facets[__index])\n+      __throw_runtime_error(\"locale::_Impl::_M_replace_facet\");\n+    _M_install_facet(__idp, __imp->_M_facets[__index]); \n+  }\n+\n+  void\n+  locale::_Impl::\n+  _M_install_facet(const locale::id* __idp, const facet* __fp)\n+  {\n+    if (__fp)\n+      {\n+\tsize_t __index = __idp->_M_id();\n+\n+\t// Check size of facet vector to ensure adequate room.\n+\tif (__index > _M_facets_size - 1)\n+\t  {\n+\t    const size_t __new_size = __index + 4;\n+\n+\t    // New facet array.\n+\t    const facet** __oldf = _M_facets;\n+\t    const facet** __newf;\n+\t    __newf = new const facet*[__new_size]; \n+\t    for (size_t __i = 0; __i < _M_facets_size; ++__i)\n+\t      __newf[__i] = _M_facets[__i];\n+\t    for (size_t __i2 = _M_facets_size; __i2 < __new_size; ++__i2)\n+\t      __newf[__i2] = 0;\n+\n+\t    // New cache array.\n+\t    const facet** __oldc = _M_caches;\n+\t    const facet** __newc;\n+\t    try\n+\t      {\n+\t\t__newc = new const facet*[__new_size];\n+\t      }\n+\t    catch(...)\n+\t      {\n+\t\tdelete [] __newf;\n+\t\t__throw_exception_again;\n+\t      }\n+\t    for (size_t __i = 0; __i < _M_facets_size; ++__i)\n+\t      __newc[__i] = _M_caches[__i];\n+\t    for (size_t __i2 = _M_facets_size; __i2 < __new_size; ++__i2)\n+\t      __newc[__i2] = 0;\n+\n+\t    _M_facets_size = __new_size;\n+\t    _M_facets = __newf;\n+\t    _M_caches = __newc;\n+\t    delete [] __oldf;\n+\t    delete [] __oldc;\n+\t  }\n+\n+\t__fp->_M_add_reference();\n+\tconst facet*& __fpr = _M_facets[__index];\n+\tif (__fpr)\n+\t  {\n+\t    // Replacing an existing facet. Order matters.\n+\t    __fpr->_M_remove_reference();\n+\t    __fpr = __fp;\n+\t  }\n+\telse\n+\t  {\n+\t    // Installing a newly created facet into an empty\n+\t    // _M_facets container, say a newly-constructed,\n+\t    // swanky-fresh _Impl.\n+\t    _M_facets[__index] = __fp;\n+\t  }\n+\n+\t// Ideally, it would be nice to only remove the caches that\n+\t// are now incorrect. However, some of the caches depend on\n+\t// multiple facets, and we only know about one facet\n+\t// here. It's no great loss: the first use of the new facet\n+\t// will create a new, correctly cached facet anyway.\n+\tfor (size_t __i = 0; __i < _M_facets_size; ++__i)\n+\t  {\n+\t    const facet* __cpr = _M_caches[__i];\n+\t    if (__cpr)\n+\t      {\n+\t\t__cpr->_M_remove_reference();\n+\t\t_M_caches[__i] = 0;\n+\t      }\n+\t  }\n+      }\n+  }\n+\n+\n+  // locale::id\n+  // Definitions for static const data members of locale::id\n+  _Atomic_word locale::id::_S_highwater;  // init'd to 0 by linker\n+\n+  size_t\n+  locale::id::_M_id() const\n+  {\n+    if (!_M_index)\n+      _M_index = 1 + __exchange_and_add(&_S_highwater, 1);\n+    return _M_index - 1;\n   }\n } // namespace std\n \n+"}, {"sha": "6a0ccf21257f6cd3fcabfaefd5d63d8cd2219b6f", "filename": "libstdc++-v3/src/locale_facets.cc", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Flocale_facets.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Flocale_facets.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale_facets.cc?ref=c755e77d63980a40e93c82da335aa59cb30de107", "patch": "@@ -0,0 +1,91 @@\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <locale>\n+\n+namespace std \n+{\n+  // Definitions for static const data members of time_base.\n+  template<> \n+    const char*\n+    __timepunct_cache<char>::_S_timezones[14] =\n+    { \n+      \"GMT\", \"HST\", \"AKST\", \"PST\", \"MST\", \"CST\", \"EST\", \"AST\", \"NST\", \"CET\", \n+      \"IST\", \"EET\", \"CST\", \"JST\"  \n+    };\n+ \n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  template<> \n+    const wchar_t*\n+    __timepunct_cache<wchar_t>::_S_timezones[14] =\n+    { \n+      L\"GMT\", L\"HST\", L\"AKST\", L\"PST\", L\"MST\", L\"CST\", L\"EST\", L\"AST\", \n+      L\"NST\", L\"CET\", L\"IST\", L\"EET\", L\"CST\", L\"JST\"  \n+    };\n+#endif\n+\n+  // Definitions for static const data members of money_base.\n+  const money_base::pattern \n+  money_base::_S_default_pattern =  { {symbol, sign, none, value} };\n+\n+  const char* __num_base::_S_atoms_in = \"-+xX0123456789eEabcdfABCDF\";\n+  const char* __num_base::_S_atoms_out =\"-+xX0123456789abcdef0123456789ABCDEF\";\n+\n+  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+  // According to the resolution of DR 231, about 22.2.2.2.2, p11,\n+  // \"str.precision() is specified in the conversion specification\".\n+  void\n+  __num_base::_S_format_float(const ios_base& __io, char* __fptr, char __mod)\n+  {\n+    ios_base::fmtflags __flags = __io.flags();\n+    *__fptr++ = '%';\n+    // [22.2.2.2.2] Table 60\n+    if (__flags & ios_base::showpos)\n+      *__fptr++ = '+';\n+    if (__flags & ios_base::showpoint)\n+      *__fptr++ = '#';\n+\n+    // As per DR 231: _always_, not only when \n+    // __flags & ios_base::fixed || __prec > 0\n+    *__fptr++ = '.';\n+    *__fptr++ = '*';\n+\n+    if (__mod)\n+      *__fptr++ = __mod;\n+    ios_base::fmtflags __fltfield = __flags & ios_base::floatfield;\n+    // [22.2.2.2.2] Table 58\n+    if (__fltfield == ios_base::fixed)\n+      *__fptr++ = 'f';\n+    else if (__fltfield == ios_base::scientific)\n+      *__fptr++ = (__flags & ios_base::uppercase) ? 'E' : 'e';\n+    else\n+      *__fptr++ = (__flags & ios_base::uppercase) ? 'G' : 'g';\n+    *__fptr = '\\0';\n+  }\n+} // namespace std\n+"}, {"sha": "1273b2a4422d33a5332212683222d1e55d794fb5", "filename": "libstdc++-v3/src/locale_init.cc", "status": "added", "additions": 340, "deletions": 0, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Flocale_init.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Flocale_init.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale_init.cc?ref=c755e77d63980a40e93c82da335aa59cb30de107", "patch": "@@ -0,0 +1,340 @@\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <clocale>\n+#include <cstring>\n+#include <cstdlib>     // For getenv, free.\n+#include <cctype>\n+#include <cwctype>     // For towupper, etc.\n+#include <locale>\n+#include <bits/atomicity.h>\n+\n+namespace __gnu_cxx\n+{\n+  // Defined in globals.cc.\n+  extern std::locale \t\tc_locale;\n+  extern std::locale::_Impl \tc_locale_impl;\n+\n+  extern std::locale::facet* facet_vec[_GLIBCXX_NUM_FACETS];\n+  extern char* name_vec[6 + _GLIBCXX_NUM_CATEGORIES];\n+  extern char name_c[6 + _GLIBCXX_NUM_CATEGORIES][2];\n+\n+  extern std::ctype<char>\t\t\tctype_c;\n+  extern std::collate<char> \t\t\tcollate_c;\n+  extern std::numpunct<char> \t\t\tnumpunct_c;\n+  extern std::num_get<char> \t\t\t\tnum_get_c;\n+  extern std::num_put<char> \t\t\t\tnum_put_c;  \n+  extern std::codecvt<char, char, mbstate_t>\t\tcodecvt_c;\n+  extern std::moneypunct<char, false> \t\tmoneypunct_cf;\n+  extern std::moneypunct<char, true> \t\tmoneypunct_ct;\n+  extern std::money_get<char> \t\t\tmoney_get_c;\n+  extern std::money_put<char> \t\t\tmoney_put_c;\n+  extern std::__timepunct<char> \t\t\ttimepunct_c;\n+  extern std::time_get<char> \t\t\ttime_get_c;\n+  extern std::time_put<char> \t\t\ttime_put_c;\n+  extern std::messages<char> \t\t\tmessages_c;\n+#ifdef  _GLIBCXX_USE_WCHAR_T\n+  extern std::ctype<wchar_t>\t\t\tctype_w;\n+  extern std::collate<wchar_t> \t\t\tcollate_w;\n+  extern std::numpunct<wchar_t> \t\t\tnumpunct_w;\n+  extern std::num_get<wchar_t> \t\t\tnum_get_w;\n+  extern std::num_put<wchar_t> \t\t\tnum_put_w;\n+  extern std::codecvt<wchar_t, char, mbstate_t>\tcodecvt_w;\n+  extern std::moneypunct<wchar_t, false> \t\tmoneypunct_wf;\n+  extern std::moneypunct<wchar_t, true> \t\tmoneypunct_wt;\n+  extern std::money_get<wchar_t> \t\t\tmoney_get_w;\n+  extern std::money_put<wchar_t> \t\t\tmoney_put_w;\n+  extern std::__timepunct<wchar_t> \t\t\ttimepunct_w;\n+  extern std::time_get<wchar_t> \t\t\ttime_get_w;\n+  extern std::time_put<wchar_t> \t\t\ttime_put_w;\n+  extern std::messages<wchar_t> \t\tmessages_w;\n+#endif\n+\n+  // And the caches....\n+  extern std::locale::facet* cache_vec[_GLIBCXX_NUM_FACETS];\n+  extern std::__numpunct_cache<char>\t\t\tnumpunct_cache_c;\n+  extern std::__moneypunct_cache<char>\t\tmoneypunct_cache_cf;\n+  extern std::__moneypunct_cache<char>\t\tmoneypunct_cache_ct;\n+  extern std::__timepunct_cache<char>\t\ttimepunct_cache_c;\n+#ifdef  _GLIBCXX_USE_WCHAR_T\n+  extern std::__numpunct_cache<wchar_t>\t\tnumpunct_cache_w;\n+  extern std::__moneypunct_cache<wchar_t>\t\tmoneypunct_cache_wf;\n+  extern std::__moneypunct_cache<wchar_t>\t\tmoneypunct_cache_wt;\n+  extern std::__timepunct_cache<wchar_t>\t\ttimepunct_cache_w;\n+#endif\n+} // namespace __gnu_cxx\n+\n+namespace std \n+{\n+  using namespace __gnu_cxx;\n+\n+  locale::locale() throw()\n+  { \n+    _S_initialize(); \n+    (_M_impl = _S_global)->_M_add_reference(); \n+  }\n+\n+  locale\n+  locale::global(const locale& __other)\n+  {\n+    _S_initialize();\n+\n+    // XXX MT\n+    _Impl* __old = _S_global;\n+    __other._M_impl->_M_add_reference();\n+    _S_global = __other._M_impl; \n+    if (_S_global->_M_check_same_name() \n+\t&& (std::strcmp(_S_global->_M_names[0], \"*\") != 0))\n+      setlocale(LC_ALL, __other.name().c_str());\n+\n+    // Reference count sanity check: one reference removed for the\n+    // subsition of __other locale, one added by return-by-value. Net\n+    // difference: zero. When the returned locale object's destrutor\n+    // is called, then the reference count is decremented and possibly\n+    // destroyed.\n+    return locale(__old);\n+  }\n+\n+  const locale&\n+  locale::classic()\n+  {\n+    _S_initialize();\n+    return c_locale;\n+  }\n+\n+  void\n+  locale::_S_initialize_once()\n+  {\n+    // 2 references.\n+    // One reference for _S_classic, one for _S_global\n+    _S_classic = new (&c_locale_impl) _Impl(2);\n+    _S_global = _S_classic; \t    \n+    new (&c_locale) locale(_S_classic);\n+  }\n+\n+  void  \n+  locale::_S_initialize()\n+  {\n+#ifdef __GTHREADS\n+    if (__gthread_active_p())\n+      __gthread_once(&_S_once, _S_initialize_once);\n+    else\n+#endif\n+      {\n+\tif (!_S_classic)\n+\t  _S_initialize_once();\n+      }\n+  }\n+\n+  // Definitions for static const data members of locale::_Impl\n+  const locale::id* const\n+  locale::_Impl::_S_id_ctype[] =\n+  {\n+    &std::ctype<char>::id, \n+    &codecvt<char, char, mbstate_t>::id,\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+    &std::ctype<wchar_t>::id,\n+    &codecvt<wchar_t, char, mbstate_t>::id,\n+#endif\n+    0\n+  };\n+\n+  const locale::id* const\n+  locale::_Impl::_S_id_numeric[] =\n+  {\n+    &num_get<char>::id,  \n+    &num_put<char>::id,  \n+    &numpunct<char>::id, \n+#ifdef _GLIBCXX_USE_WCHAR_T\n+    &num_get<wchar_t>::id,\n+    &num_put<wchar_t>::id,\n+    &numpunct<wchar_t>::id,\n+#endif\n+    0\n+  };\n+  \n+  const locale::id* const\n+  locale::_Impl::_S_id_collate[] =\n+  {\n+    &std::collate<char>::id,\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+    &std::collate<wchar_t>::id,\n+#endif\n+    0\n+  };\n+\n+  const locale::id* const\n+  locale::_Impl::_S_id_time[] =\n+  {\n+    &__timepunct<char>::id, \n+    &time_get<char>::id, \n+    &time_put<char>::id, \n+#ifdef _GLIBCXX_USE_WCHAR_T\n+    &__timepunct<wchar_t>::id, \n+    &time_get<wchar_t>::id,\n+    &time_put<wchar_t>::id,\n+#endif\n+    0\n+  };\n+  \n+  const locale::id* const\n+  locale::_Impl::_S_id_monetary[] =\n+  {\n+    &money_get<char>::id,        \n+    &money_put<char>::id,        \n+    &moneypunct<char, false>::id, \n+    &moneypunct<char, true >::id, \n+#ifdef _GLIBCXX_USE_WCHAR_T\n+    &money_get<wchar_t>::id,\n+    &money_put<wchar_t>::id,\n+    &moneypunct<wchar_t, false>::id,\n+    &moneypunct<wchar_t, true >::id,\n+#endif\n+    0\n+  };\n+\n+  const locale::id* const\n+  locale::_Impl::_S_id_messages[] =\n+  {\n+    &std::messages<char>::id, \n+#ifdef _GLIBCXX_USE_WCHAR_T\n+    &std::messages<wchar_t>::id,\n+#endif\n+    0\n+  };\n+  \n+  const locale::id* const* const\n+  locale::_Impl::_S_facet_categories[] =\n+  {\n+    // Order must match the decl order in class locale.\n+    locale::_Impl::_S_id_ctype,\n+    locale::_Impl::_S_id_numeric,\n+    locale::_Impl::_S_id_collate,\n+    locale::_Impl::_S_id_time,\n+    locale::_Impl::_S_id_monetary,\n+    locale::_Impl::_S_id_messages,\n+    0\n+  };\n+\n+  // Construct \"C\" _Impl.\n+  locale::_Impl::\n+  _Impl(size_t __refs) throw() \n+  : _M_references(__refs), _M_facets_size(_GLIBCXX_NUM_FACETS)\n+  {\n+    _M_facets = new (&facet_vec) const facet*[_M_facets_size];\n+    _M_caches = new (&cache_vec) const facet*[_M_facets_size];\n+    for (size_t __i = 0; __i < _M_facets_size; ++__i)\n+      _M_facets[__i] = _M_caches[__i] = 0;\n+\n+    // Name all the categories.\n+    _M_names = new (&name_vec) char*[_S_categories_size];\n+    for (size_t __i = 0; __i < _S_categories_size; ++__i)\n+      {\n+\t_M_names[__i] = new (&name_c[__i]) char[2];\n+\tstd::strcpy(_M_names[__i], locale::facet::_S_get_c_name());\n+      }\n+\n+    // This is needed as presently the C++ version of \"C\" locales\n+    // != data in the underlying locale model for __timepunct,\n+    // numpunct, and moneypunct. Also, the \"C\" locales must be\n+    // constructed in a way such that they are pre-allocated.\n+    // NB: Set locale::facets(ref) count to one so that each individual\n+    // facet is not destroyed when the locale (and thus locale::_Impl) is\n+    // destroyed.\n+    _M_init_facet(new (&ctype_c) std::ctype<char>(0, false, 1));\n+    _M_init_facet(new (&codecvt_c) codecvt<char, char, mbstate_t>(1));\n+\n+    typedef __numpunct_cache<char> num_cache_c;\n+    num_cache_c* __npc = new (&numpunct_cache_c) num_cache_c(2);\n+    _M_init_facet(new (&numpunct_c) numpunct<char>(__npc, 1));\n+\n+    _M_init_facet(new (&num_get_c) num_get<char>(1));\n+    _M_init_facet(new (&num_put_c) num_put<char>(1));\n+    _M_init_facet(new (&collate_c) std::collate<char>(1));\n+\n+    typedef __moneypunct_cache<char> money_cache_c;\n+    money_cache_c* __mpcf = new (&moneypunct_cache_cf) money_cache_c(2);\n+    _M_init_facet(new (&moneypunct_cf) moneypunct<char, false>(__mpcf, 1));\n+    money_cache_c* __mpct = new (&moneypunct_cache_ct) money_cache_c(2);\n+    _M_init_facet(new (&moneypunct_ct) moneypunct<char, true>(__mpct, 1));\n+\n+    _M_init_facet(new (&money_get_c) money_get<char>(1));\n+    _M_init_facet(new (&money_put_c) money_put<char>(1));\n+\n+    typedef __timepunct_cache<char> time_cache_c;\n+    time_cache_c* __tpc = new (&timepunct_cache_c) time_cache_c(2);\n+    _M_init_facet(new (&timepunct_c) __timepunct<char>(__tpc, 1));\n+\n+    _M_init_facet(new (&time_get_c) time_get<char>(1));\n+    _M_init_facet(new (&time_put_c) time_put<char>(1));\n+    _M_init_facet(new (&messages_c) std::messages<char>(1));\t\n+\n+#ifdef  _GLIBCXX_USE_WCHAR_T\n+    _M_init_facet(new (&ctype_w) std::ctype<wchar_t>(1));\n+    _M_init_facet(new (&codecvt_w) codecvt<wchar_t, char, mbstate_t>(1));\n+\n+    typedef __numpunct_cache<wchar_t> num_cache_w;\n+    num_cache_w* __npw = new (&numpunct_cache_w) num_cache_w(2);\n+    _M_init_facet(new (&numpunct_w) numpunct<wchar_t>(__npw, 1));\n+\n+    _M_init_facet(new (&num_get_w) num_get<wchar_t>(1));\n+    _M_init_facet(new (&num_put_w) num_put<wchar_t>(1));\n+    _M_init_facet(new (&collate_w) std::collate<wchar_t>(1));\n+\n+    typedef __moneypunct_cache<wchar_t> money_cache_w;\n+    money_cache_w* __mpwf = new (&moneypunct_cache_wf) money_cache_w(2);\n+    _M_init_facet(new (&moneypunct_wf) moneypunct<wchar_t, false>(__mpwf, 1));\n+    money_cache_w* __mpwt = new (&moneypunct_cache_wt) money_cache_w(2);\n+    _M_init_facet(new (&moneypunct_wt) moneypunct<wchar_t, true>(__mpwt, 1));\n+\n+    _M_init_facet(new (&money_get_w) money_get<wchar_t>(1));\n+    _M_init_facet(new (&money_put_w) money_put<wchar_t>(1));\n+\n+    typedef __timepunct_cache<wchar_t> time_cache_w;\n+    time_cache_w* __tpw = new (&timepunct_cache_w) time_cache_w(2);\n+    _M_init_facet(new (&timepunct_w) __timepunct<wchar_t>(__tpw, 1));\n+\n+    _M_init_facet(new (&time_get_w) time_get<wchar_t>(1));\n+    _M_init_facet(new (&time_put_w) time_put<wchar_t>(1));\n+    _M_init_facet(new (&messages_w) std::messages<wchar_t>(1));\n+#endif \n+     \n+    // This locale is safe to pre-cache, after all the facets have\n+    // been created and installed.\n+    _M_caches[numpunct<char>::id._M_id()] = __npc;\n+    _M_caches[moneypunct<char, false>::id._M_id()] = __mpcf;\n+    _M_caches[moneypunct<char, true>::id._M_id()] = __mpct;\n+    _M_caches[__timepunct<char>::id._M_id()] = __tpc;\n+#ifdef  _GLIBCXX_USE_WCHAR_T\n+    _M_caches[numpunct<wchar_t>::id._M_id()] = __npw;\n+    _M_caches[moneypunct<wchar_t, false>::id._M_id()] = __mpwf;\n+    _M_caches[moneypunct<wchar_t, true>::id._M_id()] = __mpwt;\n+    _M_caches[__timepunct<wchar_t>::id._M_id()] = __tpw;\n+#endif\n+  }\n+} // namespace std"}, {"sha": "e14053c95803e96bf36bb99332b008e2a6e52917", "filename": "libstdc++-v3/src/localename.cc", "status": "modified", "additions": 132, "deletions": 302, "changes": 434, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc?ref=c755e77d63980a40e93c82da335aa59cb30de107", "patch": "@@ -30,123 +30,147 @@\n #include <cstring>\n #include <locale>\n \n-namespace __gnu_cxx\n-{\n-  using namespace std;\n-\n-  // Defined in globals.cc.\n-  extern locale::facet* facet_vec[_GLIBCXX_NUM_FACETS];\n-  extern char* name_vec[6 + _GLIBCXX_NUM_CATEGORIES];\n-  extern char name_c[6 + _GLIBCXX_NUM_CATEGORIES][2];\n-\n-  extern std::ctype<char>\t\t\tctype_c;\n-  extern std::collate<char> \t\t\tcollate_c;\n-  extern numpunct<char> \t\t\tnumpunct_c;\n-  extern num_get<char> \t\t\t\tnum_get_c;\n-  extern num_put<char> \t\t\t\tnum_put_c;  \n-  extern codecvt<char, char, mbstate_t>\t\tcodecvt_c;\n-  extern moneypunct<char, false> \t\tmoneypunct_cf;\n-  extern moneypunct<char, true> \t\tmoneypunct_ct;\n-  extern money_get<char> \t\t\tmoney_get_c;\n-  extern money_put<char> \t\t\tmoney_put_c;\n-  extern __timepunct<char> \t\t\ttimepunct_c;\n-  extern time_get<char> \t\t\ttime_get_c;\n-  extern time_put<char> \t\t\ttime_put_c;\n-  extern std::messages<char> \t\t\tmessages_c;\n-#ifdef  _GLIBCXX_USE_WCHAR_T\n-  extern std::ctype<wchar_t>\t\t\tctype_w;\n-  extern std::collate<wchar_t> \t\t\tcollate_w;\n-  extern numpunct<wchar_t> \t\t\tnumpunct_w;\n-  extern num_get<wchar_t> \t\t\tnum_get_w;\n-  extern num_put<wchar_t> \t\t\tnum_put_w;\n-  extern codecvt<wchar_t, char, mbstate_t>\tcodecvt_w;\n-  extern moneypunct<wchar_t, false> \t\tmoneypunct_wf;\n-  extern moneypunct<wchar_t, true> \t\tmoneypunct_wt;\n-  extern money_get<wchar_t> \t\t\tmoney_get_w;\n-  extern money_put<wchar_t> \t\t\tmoney_put_w;\n-  extern __timepunct<wchar_t> \t\t\ttimepunct_w;\n-  extern time_get<wchar_t> \t\t\ttime_get_w;\n-  extern time_put<wchar_t> \t\t\ttime_put_w;\n-  extern std::messages<wchar_t> \t\tmessages_w;\n-#endif\n-\n-  // And the caches....\n-  extern locale::facet* cache_vec[_GLIBCXX_NUM_FACETS];\n-  extern __numpunct_cache<char>\t\t\tnumpunct_cache_c;\n-  extern __moneypunct_cache<char>\t\tmoneypunct_cache_cf;\n-  extern __moneypunct_cache<char>\t\tmoneypunct_cache_ct;\n-  extern __timepunct_cache<char>\t\ttimepunct_cache_c;\n-#ifdef  _GLIBCXX_USE_WCHAR_T\n-  extern __numpunct_cache<wchar_t>\t\tnumpunct_cache_w;\n-  extern __moneypunct_cache<wchar_t>\t\tmoneypunct_cache_wf;\n-  extern __moneypunct_cache<wchar_t>\t\tmoneypunct_cache_wt;\n-  extern __timepunct_cache<wchar_t>\t\ttimepunct_cache_w;\n-#endif\n-} // namespace __gnu_cxx\n-\n namespace std\n {\n   using namespace __gnu_cxx;\n \n-  locale::_Impl::\n-  ~_Impl() throw()\n-  {\n-    if (_M_facets)\n-      for (size_t __i = 0; __i < _M_facets_size; ++__i)\n-\tif (_M_facets[__i])\n-\t  _M_facets[__i]->_M_remove_reference();\n-    delete [] _M_facets;\n-\n-    if (_M_caches)\n-      for (size_t __i = 0; __i < _M_facets_size; ++__i)\n-\tif (_M_caches[__i])\n-\t  _M_caches[__i]->_M_remove_reference(); \n-    delete [] _M_caches;\n-\n-    if (_M_names)\n-      for (size_t __i = 0; __i < _S_categories_size; ++__i)\n-\tdelete [] _M_names[__i];  \n-    delete [] _M_names;\n-  }\n-\n-  // Clone existing _Impl object.\n-  locale::_Impl::\n-  _Impl(const _Impl& __imp, size_t __refs)\n-  : _M_references(__refs), _M_facets_size(__imp._M_facets_size)\n+  \n+  locale::locale(const char* __s)\n   {\n-    _M_facets = _M_caches = 0;\n-    _M_names = 0;\n-    try\n+    if (__s)\n       {\n-\t_M_facets = new const facet*[_M_facets_size];\n-\tfor (size_t __i = 0; __i < _M_facets_size; ++__i)\n-\t  {\n-\t    _M_facets[__i] = __imp._M_facets[__i];\n-\t    if (_M_facets[__i])\n-\t      _M_facets[__i]->_M_add_reference();\n-\t  }\n-\t_M_caches = new const facet*[_M_facets_size];\n-\tfor (size_t __i = 0; __i < _M_facets_size; ++__i)\n-\t  {\n-\t    _M_caches[__i] = __imp._M_caches[__i];\n-\t    if (_M_caches[__i])\n-\t      _M_caches[__i]->_M_add_reference(); \t\n-\t  }\n-\t_M_names = new char*[_S_categories_size];\n-\tfor (size_t __i = 0; __i < _S_categories_size; ++__i)\n-\t  _M_names[__i] = 0;\n-\n-\t// Name all the categories.\n-\tfor (size_t __i = 0; __i < _S_categories_size; ++__i)\n+\t_S_initialize(); \n+\tif (std::strcmp(__s, \"C\") == 0 || std::strcmp(__s, \"POSIX\") == 0)\n+\t  (_M_impl = _S_classic)->_M_add_reference();\n+\telse if (std::strcmp(__s, \"\") != 0)\n+\t  _M_impl = new _Impl(__s, 1);\n+\telse\n \t  {\n-\t    char* __new = new char[std::strlen(__imp._M_names[__i]) + 1];\n-\t    std::strcpy(__new, __imp._M_names[__i]);\n-\t    _M_names[__i] = __new;\n+\t    // Get it from the environment.\n+\t    char* __env = std::getenv(\"LC_ALL\");\n+\t    // If LC_ALL is set we are done.\n+\t    if (__env && std::strcmp(__env, \"\") != 0)\n+\t      {\n+\t\tif (std::strcmp(__env, \"C\") == 0 \n+\t\t    || std::strcmp(__env, \"POSIX\") == 0)\n+\t\t  (_M_impl = _S_classic)->_M_add_reference();\n+\t\telse\n+\t\t  _M_impl = new _Impl(__env, 1);\n+\t      }\n+\t    else\n+\t      {\n+\t\tstring __res;\n+\t\t// LANG may set a default different from \"C\".\n+\t\tchar* __env = std::getenv(\"LANG\");\n+\t\tif (!__env || std::strcmp(__env, \"\") == 0 \n+\t\t    || std::strcmp(__env, \"C\") == 0 \n+\t\t    || std::strcmp(__env, \"POSIX\") == 0)\n+\t\t  __res = \"C\";\n+\t\telse \n+\t\t  __res = __env;\n+\t\t\n+\t\t// Scan the categories looking for the first one\n+\t\t// different from LANG.\n+\t\tsize_t __i = 0;\n+\t\tif (__res == \"C\")\n+\t\t  for (; __i < _S_categories_size; ++__i)\n+\t\t    {\n+\t\t      __env = std::getenv(_S_categories[__i]);\n+\t\t      if (__env && std::strcmp(__env, \"\") != 0 \n+\t\t\t  && std::strcmp(__env, \"C\") != 0 \n+\t\t\t  && std::strcmp(__env, \"POSIX\") != 0)\n+\t\t\tbreak;\n+\t\t    }\n+\t\telse\n+\t\t  for (; __i < _S_categories_size; ++__i)\n+\t\t    {\n+\t\t      __env = std::getenv(_S_categories[__i]);\n+\t\t      if (__env && std::strcmp(__env, \"\") != 0\n+\t\t\t  && __res != __env)\n+\t\t\tbreak;\n+\t\t    }\n+\t\n+\t\t// If one is found, build the complete string of\n+\t\t// the form LC_CTYPE=xxx;LC_NUMERIC=yyy; and so on...\n+\t\tif (__i < _S_categories_size)\n+\t\t  {\n+\t\t    string __str;\n+\t\t    for (size_t __j = 0; __j < __i; ++__j)\n+\t\t      {\n+\t\t\t__str += _S_categories[__j];\n+\t\t\t__str += '=';\n+\t\t\t__str += __res;\n+\t\t\t__str += ';';\n+\t\t      }\n+\t\t    __str += _S_categories[__i];\n+\t\t    __str += '=';\n+\t\t    __str += __env;\n+\t\t    __str += ';';\n+\t\t    __i++;\n+\t\t    for (; __i < _S_categories_size; ++__i)\n+\t\t      {\n+\t\t\t__env = std::getenv(_S_categories[__i]);\n+\t\t\tif (!__env || std::strcmp(__env, \"\") == 0)\n+\t\t\t  {\n+\t\t\t    __str += _S_categories[__i];\n+\t\t\t    __str += '=';\n+\t\t\t    __str += __res;\n+\t\t\t    __str += ';';\n+\t\t\t  }\n+\t\t\telse if (std::strcmp(__env, \"C\") == 0\n+\t\t\t\t || std::strcmp(__env, \"POSIX\") == 0)\n+\t\t\t  {\n+\t\t\t    __str += _S_categories[__i];\n+\t\t\t    __str += \"=C;\";\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  {\n+\t\t\t    __str += _S_categories[__i];\n+\t\t\t    __str += '=';\n+\t\t\t    __str += __env;\n+\t\t\t    __str += ';';\n+\t\t\t  }\n+\t\t      }\n+\t\t    __str.erase(__str.end() - 1);\n+\t\t    _M_impl = new _Impl(__str.c_str(), 1);\n+\t\t  }\n+\t\t// ... otherwise either an additional instance of\n+\t\t// the \"C\" locale or LANG.\n+\t\telse if (__res == \"C\")\n+\t\t  (_M_impl = _S_classic)->_M_add_reference();\n+\t\telse\n+\t\t  _M_impl = new _Impl(__res.c_str(), 1);\n+\t      }\n \t  }\n       }\n-    catch(...)\n-      {\n-\tthis->~_Impl();\n+    else\n+      __throw_runtime_error(\"locale::locale NULL not valid\");\n+  }\n+\n+  locale::locale(const locale& __base, const char* __s, category __cat)\n+  { \n+    // NB: There are complicated, yet more efficient ways to do\n+    // this. Building up locales on a per-category way is tedious, so\n+    // let's do it this way until people complain.\n+    locale __add(__s);\n+    _M_coalesce(__base, __add, __cat);\n+  }\n+\n+  locale::locale(const locale& __base, const locale& __add, category __cat)\n+  { _M_coalesce(__base, __add, __cat); }\n+\n+  void\n+  locale::_M_coalesce(const locale& __base, const locale& __add, \n+\t\t      category __cat)\n+  {\n+    __cat = _S_normalize_category(__cat);  \n+    _M_impl = new _Impl(*__base._M_impl, 1);  \n+\n+    try \n+      { _M_impl->_M_replace_categories(__add._M_impl, __cat); }\n+    catch (...) \n+      { \n+\t_M_impl->_M_remove_reference(); \n \t__throw_exception_again;\n       }\n   }\n@@ -243,103 +267,6 @@ namespace std\n       }\t\n   }\n \n-  // Construct \"C\" _Impl.\n-  locale::_Impl::\n-  _Impl(size_t __refs) throw() \n-  : _M_references(__refs), _M_facets_size(_GLIBCXX_NUM_FACETS)\n-  {\n-    _M_facets = new (&facet_vec) const facet*[_M_facets_size];\n-    _M_caches = new (&cache_vec) const facet*[_M_facets_size];\n-    for (size_t __i = 0; __i < _M_facets_size; ++__i)\n-      _M_facets[__i] = _M_caches[__i] = 0;\n-\n-    // Name all the categories.\n-    _M_names = new (&name_vec) char*[_S_categories_size];\n-    for (size_t __i = 0; __i < _S_categories_size; ++__i)\n-      {\n-\t_M_names[__i] = new (&name_c[__i]) char[2];\n-\tstd::strcpy(_M_names[__i], locale::facet::_S_get_c_name());\n-      }\n-\n-    // This is needed as presently the C++ version of \"C\" locales\n-    // != data in the underlying locale model for __timepunct,\n-    // numpunct, and moneypunct. Also, the \"C\" locales must be\n-    // constructed in a way such that they are pre-allocated.\n-    // NB: Set locale::facets(ref) count to one so that each individual\n-    // facet is not destroyed when the locale (and thus locale::_Impl) is\n-    // destroyed.\n-    _M_init_facet(new (&ctype_c) std::ctype<char>(0, false, 1));\n-    _M_init_facet(new (&codecvt_c) codecvt<char, char, mbstate_t>(1));\n-\n-    typedef __numpunct_cache<char> num_cache_c;\n-    num_cache_c* __npc = new (&numpunct_cache_c) num_cache_c(2);\n-    _M_init_facet(new (&numpunct_c) numpunct<char>(__npc, 1));\n-\n-    _M_init_facet(new (&num_get_c) num_get<char>(1));\n-    _M_init_facet(new (&num_put_c) num_put<char>(1));\n-    _M_init_facet(new (&collate_c) std::collate<char>(1));\n-\n-    typedef __moneypunct_cache<char> money_cache_c;\n-    money_cache_c* __mpcf = new (&moneypunct_cache_cf) money_cache_c(2);\n-    _M_init_facet(new (&moneypunct_cf) moneypunct<char, false>(__mpcf, 1));\n-    money_cache_c* __mpct = new (&moneypunct_cache_ct) money_cache_c(2);\n-    _M_init_facet(new (&moneypunct_ct) moneypunct<char, true>(__mpct, 1));\n-\n-    _M_init_facet(new (&money_get_c) money_get<char>(1));\n-    _M_init_facet(new (&money_put_c) money_put<char>(1));\n-\n-    typedef __timepunct_cache<char> time_cache_c;\n-    time_cache_c* __tpc = new (&timepunct_cache_c) time_cache_c(2);\n-    _M_init_facet(new (&timepunct_c) __timepunct<char>(__tpc, 1));\n-\n-    _M_init_facet(new (&time_get_c) time_get<char>(1));\n-    _M_init_facet(new (&time_put_c) time_put<char>(1));\n-    _M_init_facet(new (&messages_c) std::messages<char>(1));\t\n-\n-#ifdef  _GLIBCXX_USE_WCHAR_T\n-    _M_init_facet(new (&ctype_w) std::ctype<wchar_t>(1));\n-    _M_init_facet(new (&codecvt_w) codecvt<wchar_t, char, mbstate_t>(1));\n-\n-    typedef __numpunct_cache<wchar_t> num_cache_w;\n-    num_cache_w* __npw = new (&numpunct_cache_w) num_cache_w(2);\n-    _M_init_facet(new (&numpunct_w) numpunct<wchar_t>(__npw, 1));\n-\n-    _M_init_facet(new (&num_get_w) num_get<wchar_t>(1));\n-    _M_init_facet(new (&num_put_w) num_put<wchar_t>(1));\n-    _M_init_facet(new (&collate_w) std::collate<wchar_t>(1));\n-\n-    typedef __moneypunct_cache<wchar_t> money_cache_w;\n-    money_cache_w* __mpwf = new (&moneypunct_cache_wf) money_cache_w(2);\n-    _M_init_facet(new (&moneypunct_wf) moneypunct<wchar_t, false>(__mpwf, 1));\n-    money_cache_w* __mpwt = new (&moneypunct_cache_wt) money_cache_w(2);\n-    _M_init_facet(new (&moneypunct_wt) moneypunct<wchar_t, true>(__mpwt, 1));\n-\n-    _M_init_facet(new (&money_get_w) money_get<wchar_t>(1));\n-    _M_init_facet(new (&money_put_w) money_put<wchar_t>(1));\n-\n-    typedef __timepunct_cache<wchar_t> time_cache_w;\n-    time_cache_w* __tpw = new (&timepunct_cache_w) time_cache_w(2);\n-    _M_init_facet(new (&timepunct_w) __timepunct<wchar_t>(__tpw, 1));\n-\n-    _M_init_facet(new (&time_get_w) time_get<wchar_t>(1));\n-    _M_init_facet(new (&time_put_w) time_put<wchar_t>(1));\n-    _M_init_facet(new (&messages_w) std::messages<wchar_t>(1));\n-#endif \n-     \n-    // This locale is safe to pre-cache, after all the facets have\n-    // been created and installed.\n-    _M_caches[numpunct<char>::id._M_id()] = __npc;\n-    _M_caches[moneypunct<char, false>::id._M_id()] = __mpcf;\n-    _M_caches[moneypunct<char, true>::id._M_id()] = __mpct;\n-    _M_caches[__timepunct<char>::id._M_id()] = __tpc;\n-#ifdef  _GLIBCXX_USE_WCHAR_T\n-    _M_caches[numpunct<wchar_t>::id._M_id()] = __npw;\n-    _M_caches[moneypunct<wchar_t, false>::id._M_id()] = __mpwf;\n-    _M_caches[moneypunct<wchar_t, true>::id._M_id()] = __mpwt;\n-    _M_caches[__timepunct<wchar_t>::id._M_id()] = __tpw;\n-#endif\n-  }\n-  \n   void\n   locale::_Impl::\n   _M_replace_categories(const _Impl* __imp, category __cat)\n@@ -363,101 +290,4 @@ namespace std\n \t  }\n       }\n   }\n-\n-  void\n-  locale::_Impl::\n-  _M_replace_category(const _Impl* __imp, const locale::id* const* __idpp)\n-  {\n-    for (; *__idpp; ++__idpp)\n-      _M_replace_facet(__imp, *__idpp);\n-  }\n-  \n-  void\n-  locale::_Impl::\n-  _M_replace_facet(const _Impl* __imp, const locale::id* __idp)\n-  {\n-    const size_t __index = __idp->_M_id();\n-    if ((__index > (__imp->_M_facets_size - 1)) || !__imp->_M_facets[__index])\n-      __throw_runtime_error(\"locale::_Impl::_M_replace_facet\");\n-    _M_install_facet(__idp, __imp->_M_facets[__index]); \n-  }\n-\n-  void\n-  locale::_Impl::\n-  _M_install_facet(const locale::id* __idp, const facet* __fp)\n-  {\n-    if (__fp)\n-      {\n-\tsize_t __index = __idp->_M_id();\n-\n-\t// Check size of facet vector to ensure adequate room.\n-\tif (__index > _M_facets_size - 1)\n-\t  {\n-\t    const size_t __new_size = __index + 4;\n-\n-\t    // New facet array.\n-\t    const facet** __oldf = _M_facets;\n-\t    const facet** __newf;\n-\t    __newf = new const facet*[__new_size]; \n-\t    for (size_t __i = 0; __i < _M_facets_size; ++__i)\n-\t      __newf[__i] = _M_facets[__i];\n-\t    for (size_t __i2 = _M_facets_size; __i2 < __new_size; ++__i2)\n-\t      __newf[__i2] = 0;\n-\n-\t    // New cache array.\n-\t    const facet** __oldc = _M_caches;\n-\t    const facet** __newc;\n-\t    try\n-\t      {\n-\t\t__newc = new const facet*[__new_size];\n-\t      }\n-\t    catch(...)\n-\t      {\n-\t\tdelete [] __newf;\n-\t\t__throw_exception_again;\n-\t      }\n-\t    for (size_t __i = 0; __i < _M_facets_size; ++__i)\n-\t      __newc[__i] = _M_caches[__i];\n-\t    for (size_t __i2 = _M_facets_size; __i2 < __new_size; ++__i2)\n-\t      __newc[__i2] = 0;\n-\n-\t    _M_facets_size = __new_size;\n-\t    _M_facets = __newf;\n-\t    _M_caches = __newc;\n-\t    delete [] __oldf;\n-\t    delete [] __oldc;\n-\t  }\n-\n-\t__fp->_M_add_reference();\n-\tconst facet*& __fpr = _M_facets[__index];\n-\tif (__fpr)\n-\t  {\n-\t    // Replacing an existing facet. Order matters.\n-\t    __fpr->_M_remove_reference();\n-\t    __fpr = __fp;\n-\t  }\n-\telse\n-\t  {\n-\t    // Installing a newly created facet into an empty\n-\t    // _M_facets container, say a newly-constructed,\n-\t    // swanky-fresh _Impl.\n-\t    _M_facets[__index] = __fp;\n-\t  }\n-\n-\t// Ideally, it would be nice to only remove the caches that\n-\t// are now incorrect. However, some of the caches depend on\n-\t// multiple facets, and we only know about one facet\n-\t// here. It's no great loss: the first use of the new facet\n-\t// will create a new, correctly cached facet anyway.\n-\tfor (size_t __i = 0; __i < _M_facets_size; ++__i)\n-\t  {\n-\t    const facet* __cpr = _M_caches[__i];\n-\t    if (__cpr)\n-\t      {\n-\t\t__cpr->_M_remove_reference();\n-\t\t_M_caches[__i] = 0;\n-\t      }\n-\t  }\n-      }\n-  }\n } // namespace std"}, {"sha": "fa5059dae92f08d734028f9c2c98caaf61d3b86c", "filename": "libstdc++-v3/src/wlocale-inst.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Fwlocale-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Fwlocale-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fwlocale-inst.cc?ref=c755e77d63980a40e93c82da335aa59cb30de107", "patch": "@@ -0,0 +1,39 @@\n+// Locale support -*- C++ -*-\n+\n+// Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 22.1  Locales\n+//\n+\n+#include <bits/c++config.h>\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+#define C wchar_t\n+#include \"locale-inst.cc\"\n+#endif"}, {"sha": "2bcdcfcd30845faadfcc06f6fb7d41650e3a5136", "filename": "libstdc++-v3/src/wstring-inst.cc", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Fwstring-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c755e77d63980a40e93c82da335aa59cb30de107/libstdc%2B%2B-v3%2Fsrc%2Fwstring-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fwstring-inst.cc?ref=c755e77d63980a40e93c82da335aa59cb30de107", "patch": "@@ -1,3 +1,36 @@\n+// wide string support -*- C++ -*-\n+\n+// Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 21  Strings library\n+//\n+\n #include <bits/c++config.h>\n \n #ifdef _GLIBCXX_USE_WCHAR_T"}]}