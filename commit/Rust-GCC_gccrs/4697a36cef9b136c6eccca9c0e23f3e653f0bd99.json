{"sha": "4697a36cef9b136c6eccca9c0e23f3e653f0bd99", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY5N2EzNmNlZjliMTM2YzZlY2NjYTljMGUyM2YzZTY1M2YwYmQ5OQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1995-07-21T18:15:38Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1995-07-21T18:15:38Z"}, "message": "V.4 support.\n\nFrom-SVN: r10152", "tree": {"sha": "0e5cc4703597f1c6a3c73f46056d729ad549598e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e5cc4703597f1c6a3c73f46056d729ad549598e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4697a36cef9b136c6eccca9c0e23f3e653f0bd99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4697a36cef9b136c6eccca9c0e23f3e653f0bd99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4697a36cef9b136c6eccca9c0e23f3e653f0bd99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/comments", "author": null, "committer": null, "parents": [{"sha": "b3ae05da16d8c62758cdd5e49814b00d8f8a0923", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3ae05da16d8c62758cdd5e49814b00d8f8a0923", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3ae05da16d8c62758cdd5e49814b00d8f8a0923"}], "stats": {"total": 1956, "additions": 1507, "deletions": 449}, "files": [{"sha": "31c0fd354d741c6599bb924ab3da1bf1af66baa4", "filename": "gcc/config/rs6000/aix3newas.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Faix3newas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Faix3newas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix3newas.h?ref=4697a36cef9b136c6eccca9c0e23f3e653f0bd99", "patch": "@@ -47,6 +47,29 @@ Boston, MA 02111-1307, USA.  */\n %{mcpu=603: -mppc} \\\n %{mcpu=604: -mppc}\"\n \n+/* Define the options for the binder: Start text at 512, align all segments\n+   to 512 bytes, and warn if there is text relocation.\n+\n+   The -bhalt:4 option supposedly changes the level at which ld will abort,\n+   but it also suppresses warnings about multiply defined symbols and is\n+   used by the AIX cc command.  So we use it here.\n+\n+   -bnodelcsect undoes a poor choice of default relating to multiply-defined\n+   csects.  See AIX documentation for more information about this.\n+\n+   -bM:SRE tells the linker that the output file is Shared REusable.  Note\n+   that to actually build a shared library you will also need to specify an\n+   export list with the -Wl,-bE option.\n+\n+   If -mcpu=common, export the architecture dependent multiply/divide routines\n+   as per README.RS6000.  */\n+\n+#undef\tLINK_SPEC\n+#define LINK_SPEC \"-T512 -H512 %{!r:-btextro} -bhalt:4 -bnodelcsect\\\n+   %{static:-bnso -bI:/lib/syscalls.exp} \\\n+   %{mcpu=common: milli.exp%s} \\\n+   %{!shared:%{g*:-bexport:/usr/lib/libg.exp}} %{shared:-bM:SRE}\"\n+\n /* These are not necessary when we pass -u to the assembler, and undefining\n    them saves a great deal of space in object files.  */\n "}, {"sha": "d775a21910e312e3291388e8ef73d0134a450d7f", "filename": "gcc/config/rs6000/eabi.asm", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Feabi.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Feabi.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Feabi.asm?ref=4697a36cef9b136c6eccca9c0e23f3e653f0bd99", "patch": "@@ -27,6 +27,12 @@\n .Lgot2e = .-.LCTOC1\n \t.long\t_GOT2_END_\t\t\t# -mrelocatable GOT pointers end\n \n+.Lfixups = .-.LCTOC1\n+\t.long\t_FIXUP_START_\t\t\t# start of .fixup section\n+\n+.Lfixupe = .-.LCTOC1\n+\t.long\t_FIXUP_END_\t\t\t# end of .fixup section\n+\n \t.text\n .Lptr:\n \t.long\t.LCTOC1-.Laddr\t\t\t# PC relative pointer to .got2\n@@ -64,16 +70,36 @@ __eabi:\tmflr\t0\n \tadd\t4,12,4\n \n \tcmpw\t1,3,4\t\t\t\t# any pointers to adjust\n-\tbc\t12,6,.Ldone\n+\tbc\t12,6,.Lfix\n \n .Lloop:\n-\tlwz\t11,0(3)\t\t\t\t# next pointer\n-\tadd\t11,11,12\t\t\t# adjust\n-\tstw\t11,0(3)\n+\tlwz\t5,0(3)\t\t\t\t# next pointer\n+\tadd\t5,5,12\t\t\t\t# adjust\n+\tstw\t5,0(3)\n \taddi\t3,3,4\t\t\t\t# bump to next word\n \tcmpw\t1,3,4\t\t\t\t# more pointers to adjust?\n \tbc\t4,6,.Lloop\n \n+# Fixup any user initialized pointers now (the compiler drops pointers to\n+# each of the relocs that it does in the .fixup section).  Note, the pointers\n+# themselves have already been fixed up by the previous loop.\n+\n+.Lfix:\n+\tlwz\t3,.Lfixups(11)\t\t\t# fixup pointers start\n+\tlwz\t4,.Lfixupe(11)\t\t\t# fixup pointers end\n+\n+\tcmpw\t1,3,4\t\t\t\t# any user pointers to adjust\n+\tbc\t12,6,.Ldone\n+\n+.Lfloop:\n+\tlwz\t5,0(3)\t\t\t\t# next pointer\n+\tlwz\t6,0(5)\t\t\t\t# get the pointer it points to\n+\tadd\t6,6,12\t\t\t\t# adjust\n+\tstw\t6,0(5)\n+\taddi\t3,3,4\t\t\t\t# bump to next word\n+\tcmpw\t1,3,4\t\t\t\t# more pointers to adjust?\n+\tbc\t4,6,.Lfloop\n+\n # Done adjusting pointers, return\n \n .Ldone:"}, {"sha": "829a180401af22037a877a5ddd3d606a9459e096", "filename": "gcc/config/rs6000/eabi.h", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Feabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Feabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Feabi.h?ref=4697a36cef9b136c6eccca9c0e23f3e653f0bd99", "patch": "@@ -50,6 +50,11 @@ Boston, MA 02111-1307, USA.  */\n #define MINIMAL_TOC_SECTION_ASM_OP \\\n   ((TARGET_RELOCATABLE) ? \"\\t.section\\t\\\".got2\\\",\\\"aw\\\"\" : \"\\t.section\\t\\\".got1\\\",\\\"aw\\\"\")\n \n+/* Put relocatable data in .data, not .rodata so initialized pointers can be updated */\n+#undef\tCONST_SECTION_ASM_OP\n+#define CONST_SECTION_ASM_OP \\\n+  ((TARGET_RELOCATABLE) ? \"\\t.section\\t\\\".data\\\"\\t# .rodata\" : \"\\t.section\\t\\\".rodata\\\"\")\n+\n /* Invoke an initializer function to set up the GOT */\n #define NAME__MAIN \"__eabi\"\n #define INVOKE__main 1\n@@ -74,3 +79,43 @@ Boston, MA 02111-1307, USA.  */\n #undef\tENDFILE_SPEC\n #define\tENDFILE_SPEC \"\"\n \n+/* This is how to output an assembler line defining an `int' constant.\n+   For -mrelocatable, we mark all addresses that need to be fixed up\n+   in the .fixup section.  */\n+#undef\tASM_OUTPUT_INT\n+#define ASM_OUTPUT_INT(FILE,VALUE)\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  static int recurse = 0;\t\t\t\t\t\t\\\n+  if (TARGET_RELOCATABLE\t\t\t\t\t\t\\\n+      && in_section != in_toc\t\t\t\t\t\t\\\n+      && in_section != in_text\t\t\t\t\t\t\\\n+      && in_section != in_ctors\t\t\t\t\t\t\\\n+      && in_section != in_dtors\t\t\t\t\t\t\\\n+      && !recurse\t\t\t\t\t\t\t\\\n+      && GET_CODE (VALUE) != CONST_INT\t\t\t\t\t\\\n+      && GET_CODE (VALUE) != CONST_DOUBLE)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      static int labelno = 0;\t\t\t\t\t\t\\\n+      char buf[256], *p;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      recurse = 1;\t\t\t\t\t\t\t\\\n+      ASM_GENERATE_INTERNAL_LABEL (buf, \"LCP\", labelno++);\t\t\\\n+      STRIP_NAME_ENCODING (p, buf);\t\t\t\t\t\\\n+      fprintf (FILE, \"%s:\\n\", p);\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.long (\");\t\t\t\t\t\\\n+      output_addr_const (FILE, (VALUE));\t\t\t\t\\\n+      fprintf (FILE, \")@fixup\\n\");\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.section\\t\\\".fixup\\\",\\\"aw\\\"\\n\");\t\t\\\n+      ASM_OUTPUT_ALIGN (FILE, 2);\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.long\\t%s\\n\", p);\t\t\t\t\\\n+      fprintf (FILE, \"\\t.previous\\n\");\t\t\t\t\t\\\n+      recurse = 0;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.long \");\t\t\t\t\t\\\n+      output_addr_const (FILE, (VALUE));\t\t\t\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+"}, {"sha": "6e92d17df8ce0384835ca3054f2790a363dded12", "filename": "gcc/config/rs6000/eabiaix.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Feabiaix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Feabiaix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Feabiaix.h?ref=4697a36cef9b136c6eccca9c0e23f3e653f0bd99", "patch": "@@ -0,0 +1,53 @@\n+/* Embedded ELF system support, using old AIX based calling sequence.\n+   Copyright (C) 1995 Free Software Foundation, Inc.\n+   Contributed by Cygnus Support.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"rs6000/eabi.h\"\n+\n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT (MASK_POWERPC | MASK_NEW_MNEMONICS | MASK_AIX_CALLS)\n+\n+#undef CPP_SPEC\n+#define CPP_SPEC \"\\\n+%{posix: -D_POSIX_SOURCE} \\\n+%{mrelocatable: -D_RELOCATABLE} \\\n+%{mcall-sysv: -D_CALL_SYSV} %{mcall-aix: -D_CALL_AIX} %{!mcall-sysv: %{!mcall-aix: -D_CALL_AIX}} \\\n+%{msoft-float: -D_SOFT_FLOAT} %{mcpu=403: -D_SOFT_FLOAT} \\\n+%{mlittle: -D_LITTLE_ENDIAN -Amachine(littleendian)} \\\n+%{mlittle-endian: -D_LITTLE_ENDIAN -Amachine(littleendian)} \\\n+%{!mlittle: %{!mlittle-endian: -D_BIG_ENDIAN -Amachine(bigendian)}} \\\n+%{!mcpu*: \\\n+  %{mpower: %{!mpower2: -D_ARCH_PWR}} \\\n+  %{mpower2: -D_ARCH_PWR2} \\\n+  %{mpowerpc*: -D_ARCH_PPC} \\\n+  %{mno-powerpc: %{!mpower: %{!mpower2: -D_ARCH_COM}}} \\\n+  %{!mno-powerpc: -D_ARCH_PPC}} \\\n+%{mcpu=common: -D_ARCH_COM} \\\n+%{mcpu=power: -D_ARCH_PWR} \\\n+%{mcpu=powerpc: -D_ARCH_PPC} \\\n+%{mcpu=rios: -D_ARCH_PWR} \\\n+%{mcpu=rios1: -D_ARCH_PWR} \\\n+%{mcpu=rios2: -D_ARCH_PWR2} \\\n+%{mcpu=rsc: -D_ARCH_PWR} \\\n+%{mcpu=rsc1: -D_ARCH_PWR} \\\n+%{mcpu=403: -D_ARCH_PPC} \\\n+%{mcpu=601: -D_ARCH_PPC -D_ARCH_PWR} \\\n+%{mcpu=603: -D_ARCH_PPC} \\\n+%{mcpu=604: -D_ARCH_PPC}\""}, {"sha": "11ff65ea9fafb80e802a9259299a2979134d915a", "filename": "gcc/config/rs6000/eabile.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Feabile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Feabile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Feabile.h?ref=4697a36cef9b136c6eccca9c0e23f3e653f0bd99", "patch": "@@ -29,6 +29,8 @@ Boston, MA 02111-1307, USA.  */\n #define CPP_SPEC \"\\\n %{posix: -D_POSIX_SOURCE} \\\n %{mrelocatable: -D_RELOCATABLE} \\\n+%{mcall-sysv: -D_CALL_SYSV} %{mcall-aix: -D_CALL_AIX} %{!mcall-sysv: %{!mcall-aix: -D_CALL_SYSV}} \\\n+%{msoft-float: -D_SOFT_FLOAT} %{mcpu=403: -D_SOFT_FLOAT} \\\n %{mbig: -D_BIG_ENDIAN -Amachine(bigendian)} \\\n %{mbig-endian: -D_BIG_ENDIAN -Amachine(bigendian)} \\\n %{!mbig: %{!mbig-endian: -D_LITTLE_ENDIAN -Amachine(littleendian)}} \\"}, {"sha": "ea3a2b757fe3c47941116cdd745579a9f4b53b7f", "filename": "gcc/config/rs6000/milli.exp", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Fmilli.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Fmilli.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fmilli.exp?ref=4697a36cef9b136c6eccca9c0e23f3e653f0bd99", "patch": "@@ -0,0 +1,7 @@\n+#!\n+__mulh          0x3100\n+__mull          0x3180\n+__divss         0x3200\n+__divus         0x3280\n+__quoss         0x3300\n+__quous         0x3380"}, {"sha": "424b025de18ad5d4a5d674a7714306b06959f39d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 820, "deletions": 226, "changes": 1046, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=4697a36cef9b136c6eccca9c0e23f3e653f0bd99", "patch": "@@ -70,6 +70,9 @@ int rs6000_compare_fp_p;\n    get the address of the GOT section */\n int rs6000_pic_labelno;\n #endif\n+\n+/* Whether a System V.4 varargs area was created.  */\n+int rs6000_sysv_varargs_p;\n \f\n /* Override command line options.  Mostly we process the processor\n    type and sometimes adjust other TARGET_ options.  */\n@@ -212,11 +215,18 @@ rs6000_immed_double_const (i0, i1, mode)\n int\n direct_return ()\n {\n-  return (reload_completed\n-\t  && first_reg_to_save () == 32\n-\t  && first_fp_reg_to_save () == 64\n-\t  && ! regs_ever_live[65]\n-\t  && ! rs6000_pushes_stack ());\n+  if (reload_completed)\n+    {\n+      rs6000_stack_t *info = rs6000_stack_info ();\n+\n+      if (info->first_gp_reg_save == 32\n+\t  && info->first_fp_reg_save == 64\n+\t  && !info->lr_save_p\n+\t  && !info->push_p)\n+\treturn 1;\n+    }\n+\n+  return 0;\n }\n \n /* Returns 1 always.  */\n@@ -621,6 +631,394 @@ input_operand (op, mode)\n      for an add will be valid.  */\n   return add_operand (op, mode);\n }\n+\f\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+\n+   For incoming args we set the number of arguments in the prototype large\n+   so we never return an EXPR_LIST.  */\n+\n+void\n+init_cumulative_args (cum, fntype, libname, incoming)\n+     CUMULATIVE_ARGS *cum;\n+     tree fntype;\n+     rtx libname;\n+     int incoming;\n+{\n+  static CUMULATIVE_ARGS zero_cumulative;\n+\n+  *cum = zero_cumulative;\n+  cum->words = 0;\n+  cum->fregno = FP_ARG_MIN_REG;\n+  cum->prototype = (fntype && TYPE_ARG_TYPES (fntype));\n+\n+  if (incoming)\n+    {\n+      cum->nargs_prototype = 1000;\t\t/* don't return an EXPR_LIST */\n+#ifdef TARGET_V4_CALLS\n+      if (TARGET_V4_CALLS)\n+\tcum->varargs_offset = RS6000_VARARGS_OFFSET;\n+#endif\n+    }\n+\n+  else if (cum->prototype)\n+    cum->nargs_prototype = (list_length (TYPE_ARG_TYPES (fntype)) - 1\n+\t\t\t    + (TYPE_MODE (TREE_TYPE (fntype)) == BLKmode\n+\t\t\t       || RETURN_IN_MEMORY (TREE_TYPE (fntype))));\n+\n+  else\n+    cum->nargs_prototype = 0;\n+\n+  cum->orig_nargs = cum->nargs_prototype;\n+  if (TARGET_DEBUG_ARG)\n+    {\n+      fprintf (stderr, \"\\ninit_cumulative_args:\");\n+      if (fntype)\n+\t{\n+\t  tree ret_type = TREE_TYPE (fntype);\n+\t  fprintf (stderr, \" ret code = %s,\",\n+\t\t   tree_code_name[ (int)TREE_CODE (ret_type) ]);\n+\t}\n+\n+#ifdef TARGET_V4_CALLS\n+      if (TARGET_V4_CALLS && incoming)\n+\tfprintf (stderr, \" varargs = %d, \", cum->varargs_offset);\n+#endif\n+\n+      fprintf (stderr, \" proto = %d, nargs = %d\\n\",\n+\t       cum->prototype, cum->nargs_prototype);\n+    }\n+}\n+\f\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+void\n+function_arg_advance (cum, mode, type, named)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+{\n+  cum->nargs_prototype--;\n+\n+#ifdef TARGET_V4_CALLS\n+  if (TARGET_V4_CALLS)\n+    {\n+      /* Long longs must not be split between registers and stack */\n+      if ((GET_MODE_CLASS (mode) != MODE_FLOAT || TARGET_SOFT_FLOAT)\n+\t  && type && !AGGREGATE_TYPE_P (type)\n+\t  && cum->words < GP_ARG_NUM_REG\n+\t  && cum->words + RS6000_ARG_SIZE (mode, type, named) > GP_ARG_NUM_REG)\n+\t{\n+\t  cum->words = GP_ARG_NUM_REG;\n+\t}\n+\n+      /* Aggregates get passed as pointers */\n+      if (type && AGGREGATE_TYPE_P (type))\n+\tcum->words++;\n+\n+      /* Floats go in registers, & don't occupy space in the GP registers\n+\t like they do for AIX unless software floating point.  */\n+      else if (GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t       && TARGET_HARD_FLOAT\n+\t       && cum->fregno <= FP_ARG_V4_MAX_REG)\n+\tcum->fregno++;\n+\n+      else\n+\tcum->words += RS6000_ARG_SIZE (mode, type, 1);\n+    }\n+  else\n+#endif\n+    if (named)\n+      {\n+\tcum->words += RS6000_ARG_SIZE (mode, type, named);\n+\tif (GET_MODE_CLASS (mode) == MODE_FLOAT && TARGET_HARD_FLOAT)\n+\t  cum->fregno++;\n+      }\n+\n+  if (TARGET_DEBUG_ARG)\n+    fprintf (stderr,\n+\t     \"function_adv: words = %2d, fregno = %2d, nargs = %4d, proto = %d, mode = %4s, named = %d\\n\",\n+\t     cum->words, cum->fregno, cum->nargs_prototype, cum->prototype, GET_MODE_NAME (mode), named);\n+}\n+\f\n+/* Determine where to put an argument to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).\n+\n+   On RS/6000 the first eight words of non-FP are normally in registers\n+   and the rest are pushed.  Under AIX, the first 13 FP args are in registers.\n+   Under V.4, the first 8 FP args are in registers.\n+\n+   If this is floating-point and no prototype is specified, we use\n+   both an FP and integer register (or possibly FP reg and stack).  Library\n+   functions (when TYPE is zero) always have the proper types for args,\n+   so we can pass the FP value just in one register.  emit_library_function\n+   doesn't support EXPR_LIST anyway.  */\n+\n+struct rtx_def *\n+function_arg (cum, mode, type, named)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+{\n+  if (TARGET_DEBUG_ARG)\n+    fprintf (stderr,\n+\t     \"function_arg: words = %2d, fregno = %2d, nargs = %4d, proto = %d, mode = %4s, named = %d\\n\",\n+\t     cum->words, cum->fregno, cum->nargs_prototype, cum->prototype, GET_MODE_NAME (mode), named);\n+\n+  /* Return a marker to indicate whether CR1 needs to set or clear the bit that V.4\n+     uses to say fp args were passed in registers.  Assume that we don't need the\n+     marker for software floating point, or compiler generated library calls.  */\n+  if (mode == VOIDmode)\n+    {\n+#ifdef TARGET_V4_CALLS\n+      if (TARGET_V4_CALLS && TARGET_HARD_FLOAT && cum->nargs_prototype < 0\n+\t  && type && (cum->prototype || TARGET_NO_PROTOTYPE))\n+\treturn GEN_INT ((cum->fregno == FP_ARG_MIN_REG) ? -1 : 1);\n+#endif\n+\n+      return GEN_INT (0);\n+    }\n+\n+  if (!named)\n+    {\n+#ifdef TARGET_V4_CALLS\n+      if (!TARGET_V4_CALLS)\n+#endif\n+\treturn NULL_RTX;\n+    }\n+\n+  if (type && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+    return NULL_RTX;\n+\n+  if (USE_FP_FOR_ARG_P (*cum, mode, type))\n+    {\n+      if ((cum->nargs_prototype > 0)\n+#ifdef TARGET_V4_CALLS\n+\t  || TARGET_V4_CALLS\t/* V.4 never passes FP values in GP registers */\n+#endif\n+\t  || !type)\n+\treturn gen_rtx (REG, mode, cum->fregno);\n+\n+      return gen_rtx (EXPR_LIST, VOIDmode,\n+\t\t      ((cum->words < GP_ARG_NUM_REG)\n+\t\t       ? gen_rtx (REG, mode, GP_ARG_MIN_REG + cum->words)\n+\t\t       : NULL_RTX),\n+\t\t      gen_rtx (REG, mode, cum->fregno));\n+    }\n+\n+#ifdef TARGET_V4_CALLS\n+  /* Long longs won't be split between register and stack */\n+  else if (TARGET_V4_CALLS &&\n+\t   cum->words + RS6000_ARG_SIZE (mode, type, named) > GP_ARG_NUM_REG)\n+    {\n+      return NULL_RTX;\n+    }\n+#endif\n+\n+  else if (cum->words < GP_ARG_NUM_REG)\n+    return gen_rtx (REG, mode, GP_ARG_MIN_REG + cum->words);\n+\n+  return NULL_RTX;\n+}\n+\f\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.  */\n+\n+int\n+function_arg_partial_nregs (cum, mode, type, named)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+{\n+  if (! named)\n+    return 0;\n+\n+#ifdef TARGET_V4_CALLS\n+  if (TARGET_V4_CALLS)\n+    return 0;\n+#endif\n+\n+  if (USE_FP_FOR_ARG_P (*cum, mode, type))\n+    {\n+      if (cum->nargs_prototype >= 0)\n+\treturn 0;\n+    }\n+\n+  if (cum->words < GP_ARG_NUM_REG\n+      && GP_ARG_NUM_REG < (cum->words + RS6000_ARG_SIZE (mode, type, named)))\n+    {\n+      int ret = GP_ARG_NUM_REG - cum->words;\n+      if (ret && TARGET_DEBUG_ARG)\n+\tfprintf (stderr, \"function_arg_partial_nregs: %d\\n\", ret);\n+\n+      return ret;\n+    }\n+\n+  return 0;\n+}\n+\f\n+/* A C expression that indicates when an argument must be passed by\n+   reference.  If nonzero for an argument, a copy of that argument is\n+   made in memory and a pointer to the argument is passed instead of\n+   the argument itself.  The pointer is passed in whatever way is\n+   appropriate for passing a pointer to that type.\n+\n+   Under V.4, structures and unions are passed by reference.  */\n+\n+int\n+function_arg_pass_by_reference (cum, mode, type, named)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+{\n+#ifdef TARGET_V4_CALLS\n+  if (TARGET_V4_CALLS && type && AGGREGATE_TYPE_P (type))\n+    {\n+      if (TARGET_DEBUG_ARG)\n+\tfprintf (stderr, \"function_arg_pass_by_reference: aggregate\\n\");\n+\n+      return 1;\n+    }\n+#endif\n+\n+  return 0;\n+}\n+\n+\f\n+/* Perform any needed actions needed for a function that is receiving a\n+   variable number of arguments. \n+\n+   CUM is as above.\n+\n+   MODE and TYPE are the mode and type of the current parameter.\n+\n+   PRETEND_SIZE is a variable that should be set to the amount of stack\n+   that must be pushed by the prolog to pretend that our caller pushed\n+   it.\n+\n+   Normally, this macro will push all remaining incoming registers on the\n+   stack and set PRETEND_SIZE to the length of the registers pushed.  */\n+\n+void\n+setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int *pretend_size;\n+     int no_rtl;\n+\n+{\n+  rtx save_area = virtual_incoming_args_rtx;\n+  int reg_size\t= (TARGET_64BIT) ? 8 : 4;\n+\n+  if (TARGET_DEBUG_ARG)\n+    fprintf (stderr,\n+\t     \"setup_vararg: words = %2d, fregno = %2d, nargs = %4d, proto = %d, mode = %4s, no_rtl= %d\\n\",\n+\t     cum->words, cum->fregno, cum->nargs_prototype, cum->prototype, GET_MODE_NAME (mode), no_rtl);\n+\n+#ifdef TARGET_V4_CALLS\n+  if (TARGET_V4_CALLS && !no_rtl)\n+    {\n+      rs6000_sysv_varargs_p = 1;\n+      save_area = plus_constant (frame_pointer_rtx, RS6000_VARARGS_OFFSET);\n+    }\n+#endif\n+\n+  if (cum->words < 8)\n+    {\n+      int first_reg_offset = cum->words;\n+\n+      if (MUST_PASS_IN_STACK (mode, type))\n+\tfirst_reg_offset += RS6000_ARG_SIZE (TYPE_MODE (type), type, 1);\n+\n+      if (first_reg_offset > GP_ARG_NUM_REG)\n+\tfirst_reg_offset = GP_ARG_NUM_REG;\n+\n+      if (!no_rtl && first_reg_offset != GP_ARG_NUM_REG)\n+\tmove_block_from_reg\n+\t  (GP_ARG_MIN_REG + first_reg_offset,\n+\t   gen_rtx (MEM, BLKmode,\n+\t\t    plus_constant (save_area, first_reg_offset * reg_size)),\n+\t   GP_ARG_NUM_REG - first_reg_offset,\n+\t   (GP_ARG_NUM_REG - first_reg_offset) * UNITS_PER_WORD);\n+\n+      *pretend_size = (GP_ARG_NUM_REG - first_reg_offset) * UNITS_PER_WORD;\n+    }\n+\n+#ifdef TARGET_V4_CALLS\n+  /* Save FP registers if needed.  */\n+  if (TARGET_V4_CALLS && TARGET_HARD_FLOAT && !no_rtl)\n+    {\n+      int fregno     = cum->fregno;\n+      int num_fp_reg = FP_ARG_V4_MAX_REG + 1 - fregno;\n+\n+      if (num_fp_reg >= 0)\n+\t{\n+\t  rtx cr1 = gen_rtx (REG, CCmode, 69);\n+\t  rtx lab = gen_label_rtx ();\n+\t  int off = (GP_ARG_NUM_REG * reg_size) + ((fregno - FP_ARG_MIN_REG) * 8);\n+\n+\t  emit_jump_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t\t   pc_rtx,\n+\t\t\t\t   gen_rtx (IF_THEN_ELSE, VOIDmode,\n+\t\t\t\t\t    gen_rtx (NE, VOIDmode, cr1, const0_rtx),\n+\t\t\t\t\t    gen_rtx (LABEL_REF, VOIDmode, lab),\n+\t\t\t\t\t    pc_rtx)));\n+\n+\t  while ( num_fp_reg-- >= 0)\n+\t    {\n+\t      emit_move_insn (gen_rtx (MEM, DFmode, plus_constant (save_area, off)),\n+\t\t\t      gen_rtx (REG, DFmode, fregno++));\n+\t      off += 8;\n+\t    }\n+\n+\t  emit_label (lab);\n+\t}\n+    }\n+#endif\n+}\n+\f\n+/* If defined, is a C expression that produces the machine-specific\n+   code for a call to `__builtin_saveregs'.  This code will be moved\n+   to the very beginning of the function, before any parameter access\n+   are made.  The return value of this function should be an RTX that\n+   contains the value to use as the return of `__builtin_saveregs'.\n+\n+   The argument ARGS is a `tree_list' containing the arguments that\n+   were passed to `__builtin_saveregs'.\n+\n+   If this macro is not defined, the compiler will output an ordinary\n+   call to the library function `__builtin_saveregs'.\n+   \n+   On the Power/PowerPC return the address of the area on the stack\n+   used to hold arguments.  Under AIX, this includes the 8 word register\n+   save area.  Under V.4 this does not.  */\n+\n+struct rtx_def *\n+expand_builtin_saveregs (args)\n+     tree args;\n+{\n+  return virtual_incoming_args_rtx;\n+}\n+\n \f\n /* Expand a block move operation, and return 1 if successful.  Return 0\n    if we should let the compiler generate normal code.\n@@ -1205,7 +1603,7 @@ print_operand (file, x, code)\n \n     case '*':\n       /* Write the register number of the TOC register.  */\n-      fputs (TARGET_MINIMAL_TOC ? \"30\" : \"2\", file);\n+      fputs (TARGET_MINIMAL_TOC ? reg_names[30] : reg_names[2], file);\n       return;\n \n     case 'A':\n@@ -1633,26 +2031,36 @@ print_operand_address (file, x)\n      register rtx x;\n {\n   if (GET_CODE (x) == REG)\n-    fprintf (file, \"0(%d)\", REGNO (x));\n+    fprintf (file, \"0(%s)\", reg_names[ REGNO (x) ]);\n   else if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == CONST)\n     {\n       output_addr_const (file, x);\n       /* When TARGET_MINIMAL_TOC, use the indirected toc table pointer instead\n \t of the toc pointer.  */\n-      if (TARGET_MINIMAL_TOC)\n-\tfprintf (file, \"(30)\");\n+#ifdef TARGET_NO_TOC\n+      if (TARGET_NO_TOC)\n+\t;\n       else\n-\tfprintf (file, \"(2)\");\n+#endif\n+\tfprintf (file, \"(%s)\", reg_names[ TARGET_MINIMAL_TOC ? 30 : 2 ]);\n     }\n   else if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == REG)\n     {\n       if (REGNO (XEXP (x, 0)) == 0)\n-\tfprintf (file, \"%d,%d\", REGNO (XEXP (x, 1)), REGNO (XEXP (x, 0)));\n+\tfprintf (file, \"%s,%s\", reg_names[ REGNO (XEXP (x, 1)) ],\n+\t\t reg_names[ REGNO (XEXP (x, 0)) ]);\n       else\n-\tfprintf (file, \"%d,%d\", REGNO (XEXP (x, 0)), REGNO (XEXP (x, 1)));\n+\tfprintf (file, \"%s,%s\", reg_names[ REGNO (XEXP (x, 0)) ],\n+\t\t reg_names[ REGNO (XEXP (x, 1)) ]);\n     }\n   else if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-    fprintf (file, \"%d(%d)\", INTVAL (XEXP (x, 1)), REGNO (XEXP (x, 0)));\n+    fprintf (file, \"%d(%s)\", INTVAL (XEXP (x, 1)), reg_names[ REGNO (XEXP (x, 0)) ]);\n+  else if (TARGET_ELF && !TARGET_64BIT && GET_CODE (x) == LO_SUM\n+\t   && GET_CODE (XEXP (x, 0)) == REG && CONSTANT_P (XEXP (x, 1)))\n+    {\n+      output_addr_const (file, XEXP (x, 1));\n+      fprintf (file, \"@l(%s)\", reg_names[ REGNO (XEXP (x, 0)) ]);\n+    }\n   else\n     abort ();\n }\n@@ -1678,9 +2086,11 @@ first_reg_to_save ()\n      to 23 to do this.  Don't use the frame pointer in reg 31.\n \n      For now, save enough room for all of the parameter registers.  */\n+#ifndef USING_SVR4_H\n   if (profile_flag)\n     if (first_reg > 23)\n       first_reg = 23;\n+#endif\n \n   return first_reg;\n }\n@@ -1700,31 +2110,6 @@ first_fp_reg_to_save ()\n   return first_reg;\n }\n \n-/* Return 1 if we need to save CR.  */\n-\n-int\n-must_save_cr ()\n-{\n-  return regs_ever_live[70] || regs_ever_live[71] || regs_ever_live[72];\n-}\n-\n-/* Compute the size of the save area in the stack, including the space for\n-   the fixed area.  */\n-\n-int\n-rs6000_sa_size ()\n-{\n-  int size;\n-\n-  /* We have the six fixed words, plus the size of the register save \n-     areas, rounded to a double-word.  */\n-  size = 6 + (32 - first_reg_to_save ()) + (64 - first_fp_reg_to_save ()) * 2;\n-  if (size & 1)\n-    size++;\n-\n-  return size * 4;\n-}\n-\n /* Return non-zero if this function makes calls.  */\n \n int\n@@ -1743,23 +2128,259 @@ rs6000_makes_calls ()\n   return 0;\n }\n \n-/* Return non-zero if this function needs to push space on the stack.  */\n+\f\n+/* Calculate the stack information for the current function.  This is\n+   complicated by having two separate calling sequences, the AIX calling\n+   sequence and the V.4 calling sequence.\n+\n+   AIX stack frames look like:\n+\n+\tSP---->\t+---------------------------------------+\n+\t\t| back chain to caller\t\t\t| 0\n+\t\t+---------------------------------------+\n+\t\t| saved CR\t\t\t\t| 4\n+\t\t+---------------------------------------+\n+\t\t| saved LR\t\t\t\t| 8\n+\t\t+---------------------------------------+\n+\t\t| reserved for compilers\t\t| 12\n+\t\t+---------------------------------------+\n+\t\t| reserved for binders\t\t\t| 16\n+\t\t+---------------------------------------+\n+\t\t| saved TOC pointer\t\t\t| 20\n+\t\t+---------------------------------------+\n+\t\t| Parameter save area (P)\t\t| 24\n+\t\t+---------------------------------------+\n+\t\t| Alloca space (A)\t\t\t| 24+P\n+\t\t+---------------------------------------+\n+\t\t| Local variable space (L)\t\t| 24+P+A\n+\t\t+---------------------------------------+\n+\t\t| Save area for GP registers (G)\t| 24+P+A+L\n+\t\t+---------------------------------------+\n+\t\t| Save area for FP registers (F)\t| 24+P+A+L+G\n+\t\t+---------------------------------------+\n+\told SP->| back chain to caller's caller\t\t|\n+\t\t+---------------------------------------+\n+\n+   V.4 stack frames look like:\n+\n+\tSP---->\t+---------------------------------------+\n+\t\t| back chain to caller\t\t\t| 0\n+\t\t+---------------------------------------+\n+\t\t| saved LR\t\t\t\t| 4\n+\t\t+---------------------------------------+\n+\t\t| Parameter save area (P)\t\t| 8\n+\t\t+---------------------------------------+\n+\t\t| Alloca space (A)\t\t\t| 8+P\n+\t\t+---------------------------------------+\n+\t\t| Varargs save area (V)\t\t\t| 8+P+A\n+\t\t+---------------------------------------+\n+\t\t| Local variable space (L)\t\t| 8+P+A+V\n+\t\t+---------------------------------------+\n+\t\t| saved CR (C)\t\t\t\t| 8+P+A+V+L\n+\t\t+---------------------------------------+\n+\t\t| Save area for GP registers (G)\t| 8+P+A+V+L+C\n+\t\t+---------------------------------------+\n+\t\t| Save area for FP registers (F)\t| 8+P+A+V+L+C+G\n+\t\t+---------------------------------------+\n+\told SP->| back chain to caller's caller\t\t|\n+\t\t+---------------------------------------+\n+*/\n \n-int\n-rs6000_pushes_stack ()\n+rs6000_stack_t *\n+rs6000_stack_info ()\n {\n-  int total_size = (rs6000_sa_size () + get_frame_size ()\n-\t\t    + current_function_outgoing_args_size);\n+  static rs6000_stack_t info, zero_info;\n+  rs6000_stack_t *info_ptr = &info;\n+  int reg_size = TARGET_64BIT ? 8 : 4;\n+  int v4_call_p = 0;\n+\n+  /* Zero all fields portably */\n+  info = zero_info;\n+\n+  /* Select which calling sequence */\n+#ifdef TARGET_V4_CALLS\n+  if (TARGET_V4_CALLS)\n+    info_ptr->v4_call_p = v4_call_p = 1;\n+#endif\n+\n+  /* Calculate which registers need to be saved & save area size */\n+  info_ptr->first_gp_reg_save = first_reg_to_save ();\n+  info_ptr->gp_size = reg_size * (32 - info_ptr->first_gp_reg_save);\n+\n+  info_ptr->first_fp_reg_save = first_fp_reg_to_save ();\n+  info_ptr->fp_size = 8 * (64 - info_ptr->first_fp_reg_save);\n \n-  /* We need to push the stack if a frame pointer is needed (because the\n-     stack might be dynamically adjusted), if we are debugging, if the\n-     total stack size is more than 220 bytes, or if we make calls.  */\n+  /* Does this function call anything? */\n+  info_ptr->calls_p = rs6000_makes_calls ();\n \n-  return (frame_pointer_needed || write_symbols != NO_DEBUG\n-\t  || total_size > 220\n-\t  || rs6000_makes_calls ());\n+  /* Determine if we need to save the link register */\n+  if (regs_ever_live[65] || profile_flag\n+#ifdef TARGET_RELOCATABLE\n+      || (TARGET_RELOCATABLE && (get_pool_size () != 0))\n+#endif\n+      || (info_ptr->first_fp_reg_save != 64\n+\t  && !FP_SAVE_INLINE (info_ptr->first_fp_reg_save))\n+      || (v4_call_p && current_function_calls_alloca)\n+      || info_ptr->calls_p)\n+    {\n+      info_ptr->lr_save_p = 1;\n+      regs_ever_live[65] = 1;\n+    }\n+\n+  /* Determine if we need to save the condition code registers */\n+  if (regs_ever_live[70] || regs_ever_live[71] || regs_ever_live[72])\n+    {\n+      info_ptr->cr_save_p = 1;\n+      if (v4_call_p)\n+\tinfo_ptr->cr_size = reg_size;\n+    }\n+\n+  /* Determine various sizes */\n+  info_ptr->reg_size     = reg_size;\n+  info_ptr->fixed_size   = RS6000_SAVE_AREA;\n+  info_ptr->varargs_size = RS6000_VARARGS_AREA;\n+  info_ptr->vars_size    = ALIGN (get_frame_size (), 8);\n+  info_ptr->parm_size    = ALIGN (current_function_outgoing_args_size, 8);\n+  info_ptr->save_size    = ALIGN (info_ptr->fp_size + info_ptr->gp_size + info_ptr->cr_size, 8);\n+  info_ptr->total_size   = ALIGN (info_ptr->vars_size\n+\t\t\t\t  + info_ptr->parm_size\n+\t\t\t\t  + info_ptr->save_size\n+\t\t\t\t  + info_ptr->varargs_size\n+\t\t\t\t  + info_ptr->fixed_size, STACK_BOUNDARY / BITS_PER_UNIT);\n+\n+  /* Determine if we need to allocate any stack frame.\n+     For AIX We need to push the stack if a frame pointer is needed (because\n+     the stack might be dynamically adjusted), if we are debugging, if the\n+     total stack size is more than 220 bytes, or if we make calls.\n+\n+     For V.4 we don't have the stack cushion that AIX uses, but assume that\n+     the debugger can handle stackless frames.  */\n+\n+  if (info_ptr->calls_p)\n+    info_ptr->push_p = 1;\n+\n+  else if (v4_call_p)\n+    info_ptr->push_p = (info_ptr->total_size > info_ptr->fixed_size\n+\t\t\t|| info_ptr->lr_save_p);\n+\n+  else\n+    info_ptr->push_p = (frame_pointer_needed\n+\t\t\t|| write_symbols != NO_DEBUG\n+\t\t\t|| info_ptr->total_size > 220);\n+\n+  /* Calculate the offsets */\n+  info_ptr->fp_save_offset = - info_ptr->fp_size;\n+  info_ptr->gp_save_offset = info_ptr->fp_save_offset - info_ptr->gp_size;\n+  if (v4_call_p)\n+    {\n+      info_ptr->cr_save_offset = info_ptr->gp_save_offset - reg_size;\n+      info_ptr->lr_save_offset = - info_ptr->total_size + reg_size;\n+    }\n+  else\n+    {\n+      info_ptr->cr_save_offset = 4;\n+      info_ptr->lr_save_offset = 8;\n+    }\n+\n+  /* Zero offsets if we're not saving those registers */\n+  if (!info_ptr->fp_size)\n+    info_ptr->fp_save_offset = 0;\n+\n+  if (!info_ptr->gp_size)\n+    info_ptr->gp_save_offset = 0;\n+\n+  if (!info_ptr->lr_save_p)\n+    info_ptr->lr_save_offset = 0;\n+\n+  if (!info_ptr->cr_save_p)\n+    info_ptr->cr_save_offset = 0;\n+\n+  return info_ptr;\n }\n \n+void\n+debug_stack_info (info)\n+     rs6000_stack_t *info;\n+{\n+  if (!info)\n+    info = rs6000_stack_info ();\n+\n+  fprintf (stderr, \"\\nStack information for function %s:\\n\",\n+\t   ((current_function_decl && DECL_NAME (current_function_decl))\n+\t    ? IDENTIFIER_POINTER (DECL_NAME (current_function_decl))\n+\t    : \"<unknown>\"));\n+\n+  if (info->first_gp_reg_save != 32)\n+    fprintf (stderr, \"\\tfirst_gp_reg_save   = %5d\\n\", info->first_gp_reg_save);\n+\n+  if (info->first_fp_reg_save != 64)\n+    fprintf (stderr, \"\\tfirst_fp_reg_save   = %5d\\n\", info->first_fp_reg_save);\n+\n+  if (info->lr_save_p)\n+    fprintf (stderr, \"\\tlr_save_p           = %5d\\n\", info->lr_save_p);\n+\n+  if (info->cr_save_p)\n+    fprintf (stderr, \"\\tcr_save_p           = %5d\\n\", info->cr_save_p);\n+\n+  if (info->push_p)\n+    fprintf (stderr, \"\\tpush_p              = %5d\\n\", info->push_p);\n+\n+  if (info->calls_p)\n+    fprintf (stderr, \"\\tcalls_p             = %5d\\n\", info->calls_p);\n+\n+  if (info->v4_call_p)\n+    fprintf (stderr, \"\\tv4_call_p           = %5d\\n\", info->v4_call_p);\n+\n+  if (info->gp_save_offset)\n+    fprintf (stderr, \"\\tgp_save_offset      = %5d\\n\", info->gp_save_offset);\n+\n+  if (info->fp_save_offset)\n+    fprintf (stderr, \"\\tfp_save_offset      = %5d\\n\", info->fp_save_offset);\n+\n+  if (info->lr_save_offset)\n+    fprintf (stderr, \"\\tlr_save_offset      = %5d\\n\", info->lr_save_offset);\n+\n+  if (info->cr_save_offset)\n+    fprintf (stderr, \"\\tcr_save_offset      = %5d\\n\", info->cr_save_offset);\n+\n+  if (info->varargs_save_offset)\n+    fprintf (stderr, \"\\tvarargs_save_offset = %5d\\n\", info->varargs_save_offset);\n+\n+  if (info->total_size)\n+    fprintf (stderr, \"\\ttotal_size          = %5d\\n\", info->total_size);\n+\n+  if (info->varargs_size)\n+    fprintf (stderr, \"\\tvarargs_size        = %5d\\n\", info->varargs_size);\n+\n+  if (info->vars_size)\n+    fprintf (stderr, \"\\tvars_size           = %5d\\n\", info->vars_size);\n+\n+  if (info->parm_size)\n+    fprintf (stderr, \"\\tparm_size           = %5d\\n\", info->parm_size);\n+\n+  if (info->fixed_size)\n+    fprintf (stderr, \"\\tfixed_size          = %5d\\n\", info->fixed_size);\n+\n+  if (info->gp_size)\n+    fprintf (stderr, \"\\tgp_size             = %5d\\n\", info->gp_size);\n+\n+  if (info->fp_size)\n+    fprintf (stderr, \"\\tfp_size             = %5d\\n\", info->fp_size);\n+\n+  if (info->cr_size)\n+    fprintf (stderr, \"\\tcr_size             = %5d\\n\", info->cr_size);\n+\n+  if (info->save_size)\n+    fprintf (stderr, \"\\tsave_size           = %5d\\n\", info->save_size);\n+\n+  if (info->reg_size != 4)\n+    fprintf (stderr, \"\\treg_size            = %5d\\n\", info->reg_size);\n+\n+  fprintf (stderr, \"\\n\");\n+}\n+\n+\f\n+\n #ifdef USING_SVR4_H\n /* Write out a System V.4 style traceback table before the prologue\n \n@@ -1781,77 +2402,62 @@ svr4_traceback (file, name, decl)\n      FILE *file;\n      tree name, decl;\n {\n-\n-  int first_reg\t\t= first_reg_to_save ();\n-  int first_fp_reg\t= first_fp_reg_to_save ();\n-  int pushes_stack\t= rs6000_pushes_stack ();\n+  rs6000_stack_t *info = rs6000_stack_info ();\n   long tag;\n-  long version\t\t= 0;\t\t\t/* version number */\n-  long tag_type\t\t= 0;\t\t\t/* function type */\n-  long extended_tag\t= 0;\t\t\t/* additional tag words needed */\n-  long spare\t\t= 0;\t\t\t/* reserved for future use */\n-  long alloca_reg;\t\t\t\t/* stack/frame register */\n-  long fpr_max\t\t= 64 - first_fp_reg;\t/* # of floating point registers saved */\n-  long gpr_max\t\t= 32 - first_reg;\t/* # of general purpose registers saved */\n-  long sp_max;\t\t\t\t\t/* 1 if the function acquires a stack frame */\n-  long lr_max;\t\t\t\t\t/* 1 if the function stores the link register */\n-  long cr_max;\t\t\t\t\t/* 1 if the function has a CR save word */\n-  long fpscr_max\t= 0;\t\t\t/* 1 if the function has a FPSCR save word */\n+  long version\t\t= 0;\t\t\t\t/* version number */\n+  long tag_type\t\t= 0;\t\t\t\t/* function type */\n+  long extended_tag\t= 0;\t\t\t\t/* additional tag words needed */\n+  long spare\t\t= 0;\t\t\t\t/* reserved for future use */\n+  long fpscr_max\t= 0;\t\t\t\t/* 1 if the function has a FPSCR save word */\n+  long fpr_max\t\t= 64 - info->first_fp_reg_save;\t/* # of floating point registers saved */\n+  long gpr_max\t\t= 32 - info->first_gp_reg_save;\t/* # of general purpose registers saved */\n+  long alloca_reg;\t\t\t\t\t/* stack/frame register */\n \n   if (frame_pointer_needed)\n     alloca_reg = 31;\n \n-  else if (pushes_stack != 0)\n+  else if (info->push_p != 0)\n     alloca_reg = 1;\n \n   else\n     alloca_reg = 0;\n \n-  lr_max = (regs_ever_live[65] || first_fp_reg < 62 || profile_flag);\n-  cr_max = (must_save_cr () != 0);\n-  sp_max = (pushes_stack != 0);\n-\n-  tag = (((version & 3) << 24)\n-\t | ((tag_type & 7) << 21)\n-\t | ((extended_tag & 1) << 20)\n-\t | ((spare & 1) << 19)\n-\t | ((alloca_reg & 0x1f) << 14)\n-\t | ((fpr_max & 0x1f) << 9)\n-\t | ((gpr_max & 0x1f) << 4)\n-\t | ((sp_max & 1) << 3)\n-\t | ((lr_max & 1) << 2)\n-\t | ((cr_max & 1) << 1)\n-\t | ((fpscr_max & 1) << 0));\n+  tag = ((version << 24)\n+\t | (tag_type << 21)\n+\t | (extended_tag << 20)\n+\t | (spare << 19)\n+\t | (alloca_reg << 14)\n+\t | (fpr_max << 9)\n+\t | (gpr_max << 4)\n+\t | (info->push_p << 3)\n+\t | (info->lr_save_p << 2)\n+\t | (info->cr_save_p << 1)\n+\t | (fpscr_max << 0));\n \t   \n   fprintf (file, \"\\t.long 0x%lx\\n\", tag);\n }\n \n #endif /* USING_SVR4_H */\n-\n+\f\n /* Write function prologue.  */\n-\n void\n output_prolog (file, size)\n      FILE *file;\n      int size;\n {\n-  int first_reg = first_reg_to_save ();\n-  int must_push = rs6000_pushes_stack ();\n-  int first_fp_reg = first_fp_reg_to_save ();\n-  int basic_size = rs6000_sa_size ();\n-  int total_size = (basic_size + size + current_function_outgoing_args_size);\n-  char buf[256];\n+  rs6000_stack_t *info = rs6000_stack_info ();\n+  char *store_reg = (TARGET_64BIT) ? \"\\tstd %s,%d(%s)\" : \"\\t{st|stw} %s,%d(%s)\\n\";\n \n-  /* Round size to multiple of 8 bytes.  */\n-  total_size = (total_size + 7) & ~7;\n+  if (TARGET_DEBUG_STACK)\n+    debug_stack_info (info);\n \n   /* Write .extern for any function we will call to save and restore fp\n      values.  */\n #ifndef USING_SVR4_H\n-  if (first_fp_reg < 62)\n+  if (info->first_fp_reg_save < 62)\n     fprintf (file, \"\\t.extern %s%d%s\\n\\t.extern %s%d%s\\n\",\n-\t     SAVE_FP_PREFIX, first_fp_reg - 32, SAVE_FP_SUFFIX,\n-\t     RESTORE_FP_PREFIX, first_fp_reg - 32, RESTORE_FP_SUFFIX);\n+\t     SAVE_FP_PREFIX, info->first_fp_reg_save - 32, SAVE_FP_SUFFIX,\n+\t     RESTORE_FP_PREFIX, info->first_fp_reg_save - 32, RESTORE_FP_SUFFIX);\n #endif\n \n   /* Write .extern for truncation routines, if needed.  */\n@@ -1861,6 +2467,7 @@ output_prolog (file, size)\n \t       RS6000_ITRUNC, RS6000_UITRUNC);\n       trunc_defined = 1;\n     }\n+\n   /* Write .extern for AIX common mode routines, if needed.  */\n   if (! TARGET_POWER && ! TARGET_POWERPC && ! common_mode_defined)\n     {\n@@ -1873,100 +2480,79 @@ output_prolog (file, size)\n       common_mode_defined = 1;\n     }\n \n-#ifdef USING_SVR4_H\n-  /* If we have a relocatable GOT section, we need to save the LR. */\n-  if (TARGET_RELOCATABLE && get_pool_size () != 0)\n-    regs_ever_live[65] = 1;\n-#endif\n-\n-  /* If we have to call a function to save fpr's, or if we are doing profiling,\n-     then we will be using LR.  */\n-  if (profile_flag)\n-    regs_ever_live[65] = 1;\n-\n-#ifndef USING_SVR4_H\n-  if (first_fp_reg < 62)\n-    regs_ever_live[65] = 1;\n-#endif\n-\n   /* If we use the link register, get it into r0.  */\n-  if (regs_ever_live[65])\n-    asm_fprintf (file, \"\\tmflr 0\\n\");\n+  if (info->lr_save_p)\n+    asm_fprintf (file, \"\\tmflr %s\\n\", reg_names[0]);\n \n   /* If we need to save CR, put it into r12.  */\n-  if (must_save_cr ())\n-    asm_fprintf (file, \"\\tmfcr 12\\n\");\n+  if (info->cr_save_p)\n+    asm_fprintf (file, \"\\tmfcr %s\\n\", reg_names[12]);\n \n   /* Do any required saving of fpr's.  If only one or two to save, do it\n      ourself.  Otherwise, call function.  Note that since they are statically\n      linked, we do not need a nop following them.  */\n-  if (first_fp_reg == 62)\n-    asm_fprintf (file, \"\\tstfd 30,-16(1)\\n\\tstfd 31,-8(1)\\n\");\n-  else if (first_fp_reg == 63)\n-    asm_fprintf (file, \"\\tstfd 31,-8(1)\\n\");\n-  else if (first_fp_reg != 64)\n+  if (FP_SAVE_INLINE (info->first_fp_reg_save))\n     {\n-#ifndef USING_SVR4_H\n-      asm_fprintf (file, \"\\tbl %s%d%s\\n\", SAVE_FP_PREFIX, first_fp_reg - 32, SAVE_FP_SUFFIX);\n-#else\n-      int regno, loc;\n+      int regno = info->first_fp_reg_save;\n+      int loc   = info->fp_save_offset;\n \n-      for (regno = first_fp_reg,\n-\t   loc = - (64 - first_fp_reg) * 8;\n-\t   regno < 64;\n-\t   regno++, loc += 8)\n-\tasm_fprintf (file, \"\\tstfd %d,%d(1)\\n\", regno - 32, loc);\n-#endif\n+      for ( ; regno < 64; regno++, loc += 8)\n+\tasm_fprintf (file, \"\\tstfd %s,%d(%s)\\n\", reg_names[regno], loc, reg_names[1]);\n     }\n+  else if (info->first_fp_reg_save != 64)\n+    asm_fprintf (file, \"\\tbl %s%d%s\\n\", SAVE_FP_PREFIX,\n+\t\t info->first_fp_reg_save - 32, SAVE_FP_SUFFIX);\n \n   /* Now save gpr's.  */\n-  if (! TARGET_MULTIPLE || first_reg == 31)\n+  if (! TARGET_MULTIPLE || info->first_gp_reg_save == 31 || TARGET_64BIT)\n     {\n-      int regno, loc;\n+      int regno    = info->first_gp_reg_save;\n+      int loc      = info->gp_save_offset;\n+      int reg_size = (TARGET_64BIT) ? 8 : 4;\n \n-      for (regno = first_reg,\n-\t   loc = - (32 - first_reg) * 4 - (64 - first_fp_reg) * 8;\n-\t   regno < 32;\n-\t   regno++, loc += 4)\n-\tasm_fprintf (file, \"\\t{st|stw} %d,%d(1)\\n\", regno, loc);\n+      for ( ; regno < 32; regno++, loc += reg_size)\n+\tasm_fprintf (file, store_reg, reg_names[regno], loc, reg_names[1]);\n     }\n \n-  else if (first_reg != 32)\n-    asm_fprintf (file, \"\\t{stm|stmw} %d,%d(1)\\n\", first_reg,\n-\t     - (32 - first_reg) * 4 - (64 - first_fp_reg) * 8);\n+  else if (info->first_gp_reg_save != 32)\n+    asm_fprintf (file, \"\\t{stm|stmw} %s,%d(%s)\\n\",\n+\t\t reg_names[info->first_gp_reg_save],\n+\t\t info->gp_save_offset,\n+\t\t reg_names[1]);\n \n   /* Save lr if we used it.  */\n-  if (regs_ever_live[65])\n-    asm_fprintf (file, \"\\t{st|stw} 0,8(1)\\n\");\n+  if (info->lr_save_p)\n+    asm_fprintf (file, store_reg, reg_names[0], info->lr_save_offset, reg_names[1]);\n \n   /* Save CR if we use any that must be preserved.  */\n-  if (must_save_cr ())\n-    asm_fprintf (file, \"\\t{st|stw} 12,4(1)\\n\");\n+  if (info->cr_save_p)\n+    asm_fprintf (file, store_reg, reg_names[12], info->cr_save_offset, reg_names[1]);\n \n   /* Update stack and set back pointer.  */\n-  if (must_push)\n+  if (info->push_p)\n     {\n-      if (total_size < 32767)\n-\tasm_fprintf (file, \"\\t{stu|stwu} 1,%d(1)\\n\", - total_size);\n+      if (info->total_size < 32767)\n+\tasm_fprintf (file,\n+\t\t     (TARGET_64BIT) ? \"\\tstdu %s,%d(%s)\\n\" : \"\\t{stu|stwu} %s,%d(%s)\\n\",\n+\t\t     reg_names[1], - info->total_size, reg_names[1]);\n       else\n \t{\n-\t  asm_fprintf (file, \"\\t{liu|lis} 0,%d\\n\\t{oril|ori} 0,0,%d\\n\",\n-\t\t   (total_size >> 16) & 0xffff, total_size & 0xffff);\n-\t  if (TARGET_POWERPC)\n-\t    asm_fprintf (file, \"\\tsubf 12,0,1\\n\");\n-\t  else\n-\t    asm_fprintf (file, \"\\t{sf|subfc} 12,0,1\\n\");\n-\t  asm_fprintf (file, \"\\t{st|stw} 1,0(12)\\n\\tmr 1,12\\n\");\n+\t  asm_fprintf (file, \"\\t{liu|lis} %s,%d\\n\\t{oril|ori} %s,%s,%d\\n\",\n+\t\t       reg_names[0], (info->total_size >> 16) & 0xffff,\n+\t\t       reg_names[0], reg_names[0], info->total_size & 0xffff);\n+\t  asm_fprintf (file,\n+\t\t       (TARGET_64BIT) ? \"\\tstdux %s,%s,%s\\n\" : \"\\tstwux %s,%s,%s\\n\",\n+\t\t       reg_names[1], reg_names[1], reg_names[0]);\n \t}\n     }\n \n   /* Set frame pointer, if needed.  */\n   if (frame_pointer_needed)\n-    asm_fprintf (file, \"\\tmr 31,1\\n\");\n+    asm_fprintf (file, \"\\tmr %s,%s\\n\", reg_names[31], reg_names[1]);\n \n   /* If TARGET_MINIMAL_TOC, and the constant pool is needed, then load the\n      TOC_TABLE address into register 30.  */\n-  if (TARGET_MINIMAL_TOC && get_pool_size () != 0)\n+  if (TARGET_TOC && TARGET_MINIMAL_TOC && get_pool_size () != 0)\n     {\n       char buf[256];\n \n@@ -1979,43 +2565,54 @@ output_prolog (file, size)\n \t  fprintf (file, \"\\n\");\n \n \t  ASM_OUTPUT_INTERNAL_LABEL (file, \"LCF\", rs6000_pic_labelno);\n-\t  fprintf (file, \"\\tmflr 30\\n\");\n+\t  fprintf (file, \"\\tmflr %s\\n\", reg_names[30]);\n \n \t  if (TARGET_POWERPC64)\n-\t    fprintf (file, \"\\tld 0,\");\n+\t    fprintf (file, \"\\tld\");\n \t  else if (TARGET_NEW_MNEMONICS)\n-\t    fprintf (file, \"\\tlwz 0,\");\n+\t    fprintf (file, \"\\tlwz\");\n \t  else\n-\t    fprintf (file, \"\\tl 0,\");\n+\t    fprintf (file, \"\\tl\");\n \n-\t  fprintf (file, \"(\");\n+\t  fprintf (file, \" %s,(\", reg_names[0]);\n \t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LCL\", rs6000_pic_labelno);\n \t  assemble_name (file, buf);\n \t  fprintf (file, \"-\");\n \t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LCF\", rs6000_pic_labelno);\n \t  assemble_name (file, buf);\n-\t  fprintf (file, \")(30)\\n\");\n-\t  asm_fprintf (file, \"\\t{cax|add} 30,0,30\\n\");\n+\t  fprintf (file, \")(%s)\\n\", reg_names[30]);\n+\t  asm_fprintf (file, \"\\t{cax|add} %s,%s,%s\\n\",\n+\t\t       reg_names[30], reg_names[0], reg_names[30]);\n \t  rs6000_pic_labelno++;\n \t}\n-      else if (TARGET_NO_TOC)\n+      else if (!TARGET_64BIT)\n \t{\n \t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LCTOC\", 1);\n-\t  asm_fprintf (file, \"\\t{cau|addis} 30,0,\");\n+\t  asm_fprintf (file, \"\\t{cau|addis} %s,%s,\", reg_names[30], reg_names[0]);\n \t  assemble_name (file, buf);\n \t  asm_fprintf (file, \"@ha\\n\");\n-\t  asm_fprintf (file, \"\\t{cal|addi} 30,30,\");\n-\t  assemble_name (file, buf);\n-\t  asm_fprintf (file, \"@l\\n\");\n+\t  if (TARGET_NEW_MNEMONICS)\n+\t    {\n+\t      asm_fprintf (file, \"\\taddi %s,%s,\", reg_names[30], reg_names[30]);\n+\t      assemble_name (file, buf);\n+\t      asm_fprintf (file, \"@l\\n\");\n+\t    }\n+\t  else\n+\t    {\n+\t      asm_fprintf (file, \"\\tcal %s,\", reg_names[30]);\n+\t      assemble_name (file, buf);\n+\t      asm_fprintf (file, \"@l(%s)\\n\", reg_names[30]);\n+\t    }\n \t}\n       else\n+\tabort ();\n+\n+#else\t/* !USING_SVR4_H */\n+      ASM_GENERATE_INTERNAL_LABEL (buf, \"LCTOC\", 0);\n+      asm_fprintf (file, \"\\t{l|lwz} %s,\", reg_names[30]);\n+      assemble_name (file, buf);\n+      asm_fprintf (file, \"(%s)\\n\", reg_names[2]);\n #endif /* USING_SVR4_H */\n-\t{\n-\t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LCTOC\", 0);\n-\t  asm_fprintf (file, \"\\t{l|lwz} 30,\");\n-\t  assemble_name (file, buf);\n-\t  asm_fprintf (file, \"(2)\\n\");\n-\t}\n     }\n }\n \n@@ -2026,16 +2623,10 @@ output_epilog (file, size)\n      FILE *file;\n      int size;\n {\n-  int first_reg = first_reg_to_save ();\n-  int must_push = rs6000_pushes_stack ();\n-  int first_fp_reg = first_fp_reg_to_save ();\n-  int basic_size = rs6000_sa_size ();\n-  int total_size = (basic_size + size + current_function_outgoing_args_size);\n+  rs6000_stack_t *info = rs6000_stack_info ();\n+  char *load_reg = (TARGET_64BIT) ? \"\\tld %s,%d(%s)\" : \"\\t{l|lwz} %s,%d(%s)\\n\";\n   rtx insn = get_last_insn ();\n \n-  /* Round size to multiple of 8 bytes.  */\n-  total_size = (total_size + 7) & ~7;\n-\n   /* If the last insn was a BARRIER, we don't have to write anything except\n      the trace table.  */\n   if (GET_CODE (insn) == NOTE)\n@@ -2046,71 +2637,68 @@ output_epilog (file, size)\n \t frame, restore the old stack pointer using the backchain.  Otherwise,\n \t we know what size to update it with.  */\n       if (frame_pointer_needed || current_function_calls_alloca\n-\t  || total_size > 32767)\n-\tasm_fprintf (file, \"\\t{l|lwz} 1,0(1)\\n\");\n-      else if (must_push)\n-\tasm_fprintf (file, \"\\t{cal 1,%d(1)|addi 1,1,%d}\\n\", total_size);\n+\t  || info->total_size > 32767)\n+\tasm_fprintf (file, load_reg, reg_names[1], 0, reg_names[1]);\n+      else if (info->push_p)\n+\t{\n+\t  if (TARGET_NEW_MNEMONICS)\n+\t    asm_fprintf (file, \"\\taddi %s,%s,%d\\n\", reg_names[1], reg_names[1], info->total_size);\n+\t  else\n+\t    asm_fprintf (file, \"\\tcal %s,%d(%s)\\n\", reg_names[1], info->total_size, reg_names[1]);\n+\t}\n \n       /* Get the old lr if we saved it.  */\n-      if (regs_ever_live[65])\n-\tasm_fprintf (file, \"\\t{l|lwz} 0,8(1)\\n\");\n+      if (info->lr_save_p)\n+\tasm_fprintf (file, load_reg, reg_names[0], info->lr_save_offset, reg_names[1]);\n \n       /* Get the old cr if we saved it.  */\n-      if (must_save_cr ())\n-\tasm_fprintf (file, \"\\t{l|lwz} 12,4(1)\\n\");\n+      if (info->cr_save_p)\n+\tasm_fprintf (file, load_reg, reg_names[12], info->cr_save_offset, reg_names[1]);\n \n       /* Set LR here to try to overlap restores below.  */\n-      if (regs_ever_live[65])\n-\tasm_fprintf (file, \"\\tmtlr 0\\n\");\n+      if (info->lr_save_p)\n+\tasm_fprintf (file, \"\\tmtlr %s\\n\", reg_names[0]);\n \n       /* Restore gpr's.  */\n-      if (! TARGET_MULTIPLE || first_reg == 31)\n+      if (! TARGET_MULTIPLE || info->first_gp_reg_save == 31 || TARGET_64BIT)\n \t{\n-\t  int regno, loc;\n+\t  int regno    = info->first_gp_reg_save;\n+\t  int loc      = info->gp_save_offset;\n+\t  int reg_size = (TARGET_64BIT) ? 8 : 4;\n \n-\t  for (regno = first_reg,\n-\t       loc = - (32 - first_reg) * 4 - (64 - first_fp_reg) * 8;\n-\t       regno < 32;\n-\t       regno++, loc += 4)\n-\t    asm_fprintf (file, \"\\t{l|lwz} %d,%d(1)\\n\", regno, loc);\n+\t  for ( ; regno < 32; regno++, loc += reg_size)\n+\t    asm_fprintf (file, load_reg, reg_names[regno], loc, reg_names[1]);\n \t}\n \n-      else if (first_reg != 32)\n-\tasm_fprintf (file, \"\\t{lm|lmw} %d,%d(1)\\n\", first_reg,\n-\t     - (32 - first_reg) * 4 - (64 - first_fp_reg) * 8);\n+      else if (info->first_gp_reg_save != 32)\n+\tasm_fprintf (file, \"\\t{lm|lmw} %s,%d(%s)\\n\",\n+\t\t     reg_names[info->first_gp_reg_save],\n+\t\t     info->gp_save_offset,\n+\t\t     reg_names[1]);\n \n       /* Restore fpr's if we can do it without calling a function.  */\n-      if (first_fp_reg == 62)\n-\tasm_fprintf (file, \"\\tlfd 30,-16(1)\\n\\tlfd 31,-8(1)\\n\");\n-      else if (first_fp_reg == 63)\n-\tasm_fprintf (file, \"\\tlfd 31,-8(1)\\n\");\n+      if (FP_SAVE_INLINE (info->first_fp_reg_save))\n+\t{\n+\t  int regno = info->first_fp_reg_save;\n+\t  int loc   = info->fp_save_offset;\n+\n+\t  for ( ; regno < 64; regno++, loc += 8)\n+\t    asm_fprintf (file, \"\\tlfd %s,%d(%s)\\n\", reg_names[regno], loc, reg_names[1]);\n+\t}\n \n       /* If we saved cr, restore it here.  Just those of cr2, cr3, and cr4\n \t that were used.  */\n-      if (must_save_cr ())\n-\tasm_fprintf (file, \"\\tmtcrf %d,12\\n\",\n+      if (info->cr_save_p)\n+\tasm_fprintf (file, \"\\tmtcrf %d,%s\\n\",\n \t\t     (regs_ever_live[70] != 0) * 0x20\n \t\t     + (regs_ever_live[71] != 0) * 0x10\n-\t\t     + (regs_ever_live[72] != 0) * 0x8);\n+\t\t     + (regs_ever_live[72] != 0) * 0x8, reg_names[12]);\n \n       /* If we have to restore more than two FP registers, branch to the\n \t restore function.  It will return to our caller.  */\n-      if (first_fp_reg < 62)\n-\t{\n-#ifndef USING_SVR4_H\n-\t  asm_fprintf (file, \"\\tb %s%d%s\\n\", RESTORE_FP_PREFIX, first_fp_reg - 32, RESTORE_FP_SUFFIX);\n-#else\n-\t  int regno, loc;\n-\n-\t  for (regno = first_fp_reg,\n-\t       loc = - (64 - first_fp_reg) * 8;\n-\t       regno < 64;\n-\t       regno++, loc += 8)\n-\t    asm_fprintf (file, \"\\tlfd %d,%d(1)\\n\", regno - 32, loc);\n-\n-\t  asm_fprintf (file, \"\\t{br|blr}\\n\");\n-#endif\n-\t}\n+      if (info->first_fp_reg_save != 64 && !FP_SAVE_INLINE (info->first_fp_reg_save))\n+\tasm_fprintf (file, \"\\tb %s%d%s\\n\", RESTORE_FP_PREFIX,\n+\t\t     info->first_fp_reg_save - 32, RESTORE_FP_SUFFIX);\n       else\n \tasm_fprintf (file, \"\\t{br|blr}\\n\");\n     }\n@@ -2184,7 +2772,7 @@ output_epilog (file, size)\n \t has controlled storage, function has no toc, function uses fp,\n \t function logs/aborts fp operations.  */\n       /* Assume that fp operations are used if any fp reg must be saved.  */\n-      fprintf (file, \"%d,\", (1 << 5) | ((first_fp_reg != 64) << 1));\n+      fprintf (file, \"%d,\", (1 << 5) | ((info->first_fp_reg_save != 64) << 1));\n \n       /* 6 bitfields: function is interrupt handler, name present in\n \t proc table, function calls alloca, on condition directives\n@@ -2194,12 +2782,12 @@ output_epilog (file, size)\n \t set up as a frame pointer, even when there is no alloca call.  */\n       fprintf (file, \"%d,\",\n \t       ((1 << 6) | (frame_pointer_needed << 5)\n-\t\t| (must_save_cr () << 1) | (regs_ever_live[65])));\n+\t\t| (info->cr_save_p << 1) | (info->lr_save_p)));\n \n       /* 3 bitfields: saves backchain, spare bit, number of fpr saved\n \t (6 bits).  */\n       fprintf (file, \"%d,\",\n-\t       (must_push << 7) | (64 - first_fp_reg_to_save ()));\n+\t       (info->push_p << 7) | (64 - info->first_fp_reg_save));\n \n       /* 2 bitfields: spare bits (2 bits), number of gpr saved (6 bits).  */\n       fprintf (file, \"%d,\", (32 - first_reg_to_save ()));\n@@ -2308,6 +2896,9 @@ output_epilog (file, size)\n \tfprintf (file, \"\\t.byte 31\\n\");\n     }\n #endif /* !USING_SVR4_H */\n+\n+  /* Reset varargs indicator */\n+  rs6000_sysv_varargs_p = 0;\n }\n \f\n /* Output a TOC entry.  We derive the entry name from what is\n@@ -2324,6 +2915,9 @@ output_toc (file, x, labelno)\n   rtx base = x;\n   int offset = 0;\n \n+  if (TARGET_NO_TOC)\n+    abort ();\n+\n #ifdef USING_SVR4_H\n   if (TARGET_MINIMAL_TOC)\n     {"}, {"sha": "9bc64c3ba2c7aa4beb79370a02f31bfc953622ef", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 245, "deletions": 142, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=4697a36cef9b136c6eccca9c0e23f3e653f0bd99", "patch": "@@ -150,6 +150,10 @@ extern int target_flags;\n #define MASK_STRING\t\t0x4000\n #define MASK_STRING_SET\t\t0x8000\n \n+/* Temporary debug switches */\n+#define MASK_DEBUG_STACK\t0x10000\n+#define MASK_DEBUG_ARG\t\t0x20000\n+\n #define TARGET_POWER\t\t(target_flags & MASK_POWER)\n #define TARGET_POWER2\t\t(target_flags & MASK_POWER2)\n #define TARGET_POWERPC\t\t(target_flags & MASK_POWERPC)\n@@ -166,9 +170,23 @@ extern int target_flags;\n #define\tTARGET_MULTIPLE_SET\t(target_flags & MASK_MULTIPLE_SET)\n #define TARGET_STRING\t\t(target_flags & MASK_STRING)\n #define TARGET_STRING_SET\t(target_flags & MASK_STRING_SET)\n+#define\tTARGET_DEBUG_STACK\t(target_flags & MASK_DEBUG_STACK)\n+#define\tTARGET_DEBUG_ARG\t(target_flags & MASK_DEBUG_ARG)\n \n #define TARGET_HARD_FLOAT\t(! TARGET_SOFT_FLOAT)\n \n+/* Pseudo target to indicate whether the object format is ELF\n+   (to get around not having conditional compilation in the md file)  */\n+#ifndef\tTARGET_ELF\n+#define\tTARGET_ELF\t\t0\n+#endif\n+\n+/* If this isn't V.4, don't support -mno-toc.  */\n+#ifndef TARGET_NO_TOC\n+#define TARGET_NO_TOC\t\t0\n+#define\tTARGET_TOC\t\t1\n+#endif\n+\n /* Run-time compilation parameters selecting different hardware subsets.\n \n    Macro to define tables used to set the flags.\n@@ -215,6 +233,8 @@ extern int target_flags;\n   {\"string\",\t\tMASK_STRING | MASK_STRING_SET},\t\t\t\\\n   {\"no-string\",\t\t- MASK_STRING},\t\t\t\t\t\\\n   {\"no-string\",\t\tMASK_STRING_SET},\t\t\t\t\\\n+  {\"debug-stack\",\tMASK_DEBUG_STACK},\t\t\t\t\\\n+  {\"debug-arg\",\t\tMASK_DEBUG_ARG},\t\t\t\t\\\n   SUBTARGET_SWITCHES\t\t\t\t\t\t\t\\\n   {\"\",\t\t\tTARGET_DEFAULT}}\n \n@@ -833,6 +853,32 @@ enum reg_class { NO_REGS, BASE_REGS, GENERAL_REGS, FLOAT_REGS,\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n+/* Structure used to define the rs6000 stack */\n+typedef struct rs6000_stack {\n+  int first_gp_reg_save;\t/* first callee saved GP register used */\n+  int first_fp_reg_save;\t/* first callee saved FP register used */\n+  int lr_save_p;\t\t/* true if the link reg needs to be saved */\n+  int cr_save_p;\t\t/* true if the CR reg needs to be saved */\n+  int push_p;\t\t\t/* true if we need to allocate stack space */\n+  int calls_p;\t\t\t/* true if the function makes any calls */\n+  int v4_call_p;\t\t/* true if V.4 calling sequence used */\n+  int gp_save_offset;\t\t/* offset to save GP regs from inital SP */\n+  int fp_save_offset;\t\t/* offset to save FP regs from inital SP */\n+  int lr_save_offset;\t\t/* offset to save LR from initial SP */\n+  int cr_save_offset;\t\t/* offset to save CR from initial SP */\n+  int varargs_save_offset;\t/* offset to save the varargs registers */\n+  int reg_size;\t\t\t/* register size (4 or 8) */\n+  int varargs_size;\t\t/* size to hold V.4 args passed in regs */\n+  int vars_size;\t\t/* variable save area size */\n+  int parm_size;\t\t/* outgoing parameter size */\n+  int save_size;\t\t/* save area size */\n+  int fixed_size;\t\t/* fixed size of stack frame */\n+  int gp_size;\t\t\t/* size of saved GP registers */\n+  int fp_size;\t\t\t/* size of saved FP registers */\n+  int cr_size;\t\t\t/* size to hold CR if not in save_size */\n+  int total_size;\t\t/* total bytes allocated for stack */\n+} rs6000_stack_t;\n+\n /* Define this if pushing a word on the stack\n    makes the stack pointer a smaller address.  */\n #define STACK_GROWS_DOWNWARD\n@@ -846,6 +892,29 @@ enum reg_class { NO_REGS, BASE_REGS, GENERAL_REGS, FLOAT_REGS,\n    arguments.  */\n /* #define FRAME_GROWS_DOWNWARD */\n \n+/* Size of the outgoing register save area */\n+#define RS6000_REG_SAVE (TARGET_64BIT ? 64 : 32)\n+\n+/* Size of the fixed area on the stack */\n+#define RS6000_SAVE_AREA (TARGET_64BIT ? 48 : 24)\n+\n+/* Size of the V.4 varargs area if needed */\n+#define RS6000_VARARGS_AREA 0\n+\n+/* Whether a V.4 varargs area is needed */\n+extern int rs6000_sysv_varargs_p;\n+\n+/* Align an address */\n+#define ALIGN(n,a) (((n) + (a) - 1) & ~((a) - 1))\n+\n+/* Size of V.4 varargs area in bytes */\n+#define RS6000_VARARGS_SIZE \\\n+  ((GP_ARG_NUM_REG * (TARGET_64BIT ? 8 : 4)) + (FP_ARG_NUM_REG * 8) + 8)\n+\n+/* Offset of V.4 varargs area */\n+#define RS6000_VARARGS_OFFSET \\\n+  (ALIGN (current_function_outgoing_args_size, 8) + RS6000_SAVE_AREA)\n+\n /* Offset within stack frame to start allocating local variables at.\n    If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n    first local allocated.  Otherwise, it is the offset to the BEGINNING\n@@ -855,8 +924,9 @@ enum reg_class { NO_REGS, BASE_REGS, GENERAL_REGS, FLOAT_REGS,\n    except for dynamic allocations.  So we start after the fixed area and\n    outgoing parameter area.  */\n \n-#define STARTING_FRAME_OFFSET (current_function_outgoing_args_size \\\n-\t\t\t       + (TARGET_64BIT ? 48 : 24))\n+#define STARTING_FRAME_OFFSET (ALIGN (current_function_outgoing_args_size, 8) \\\n+\t\t\t       + RS6000_VARARGS_AREA \\\n+\t\t\t       + RS6000_SAVE_AREA)\n \n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by.\n@@ -866,12 +936,12 @@ enum reg_class { NO_REGS, BASE_REGS, GENERAL_REGS, FLOAT_REGS,\n /* Offset of first parameter from the argument pointer register value.\n    On the RS/6000, we define the argument pointer to the start of the fixed\n    area.  */\n-#define FIRST_PARM_OFFSET(FNDECL) (TARGET_64BIT ? 48 : 24)\n+#define FIRST_PARM_OFFSET(FNDECL) RS6000_SAVE_AREA\n \n /* Define this if stack space is still allocated for a parameter passed\n    in a register.  The value is the number of bytes allocated to this\n    area.  */\n-#define REG_PARM_STACK_SPACE(FNDECL)\t(TARGET_64BIT ? 64 : 32)\n+#define REG_PARM_STACK_SPACE(FNDECL)\tRS6000_REG_SAVE\n \n /* Define this if the above stack space is to be considered part of the\n    space allocated by the caller.  */\n@@ -880,7 +950,7 @@ enum reg_class { NO_REGS, BASE_REGS, GENERAL_REGS, FLOAT_REGS,\n /* This is the difference between the logical top of stack and the actual sp.\n \n    For the RS/6000, sp points past the fixed area. */\n-#define STACK_POINTER_OFFSET (TARGET_64BIT ? 48 : 24)\n+#define STACK_POINTER_OFFSET RS6000_SAVE_AREA\n \n /* Define this if the maximum size of all the outgoing args is to be\n    accumulated and pushed during the prologue.  The amount can be\n@@ -922,18 +992,35 @@ enum reg_class { NO_REGS, BASE_REGS, GENERAL_REGS, FLOAT_REGS,\n #define RETURN_IN_MEMORY(TYPE) \\\n   (TYPE_MODE (TYPE) == BLKmode)\n \n+/* Minimum and maximum general purpose registers used to hold arguments.  */\n+#define GP_ARG_MIN_REG 3\n+#define GP_ARG_MAX_REG 10\n+#define GP_ARG_NUM_REG (GP_ARG_MAX_REG - GP_ARG_MIN_REG + 1)\n+\n+/* Minimum and maximum floating point registers used to hold arguments.  */\n+#define FP_ARG_MIN_REG 33\n+#define FP_ARG_MAX_REG 45\n+#define FP_ARG_NUM_REG (FP_ARG_MAX_REG - FP_ARG_MIN_REG + 1)\n+\n+/* Return registers */\n+#define GP_ARG_RETURN GP_ARG_MIN_REG\n+#define FP_ARG_RETURN FP_ARG_MIN_REG\n+\n+/* Define cutoff for using external functions to save floating point */\n+#define FP_SAVE_INLINE(FIRST_REG) ((FIRST_REG) == 62 || (FIRST_REG) == 63)\n+\n /* 1 if N is a possible register number for a function value\n    as seen by the caller.\n \n    On RS/6000, this is r3 and fp1.  */\n-\n-#define FUNCTION_VALUE_REGNO_P(N)  ((N) == 3 || ((N) == 33))\n+#define FUNCTION_VALUE_REGNO_P(N)  ((N) == GP_ARG_RETURN || ((N) == FP_ARG_RETURN))\n \n /* 1 if N is a possible register number for function argument passing.\n    On RS/6000, these are r3-r10 and fp1-fp13.  */\n+#define FUNCTION_ARG_REGNO_P(N)\t\t\t\t\t\t\\\n+  (((unsigned)((N) - GP_ARG_MIN_REG) < (unsigned)(GP_ARG_NUM_REG))\t\\\n+   || ((unsigned)((N) - FP_ARG_MIN_REG) < (unsigned)(FP_ARG_NUM_REG)))\n \n-#define FUNCTION_ARG_REGNO_P(N)\t\\\n-  (((N) <= 10 && (N) >= 3) || ((N) >= 33 && (N) <= 45))\n \f\n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should\n@@ -944,10 +1031,21 @@ enum reg_class { NO_REGS, BASE_REGS, GENERAL_REGS, FLOAT_REGS,\n    On the RS/6000, this is a structure.  The first element is the number of\n    total argument words, the second is used to store the next\n    floating-point register number, and the third says how many more args we\n-   have prototype types for.  */\n-\n-struct rs6000_args {int words, fregno, nargs_prototype; };\n-#define CUMULATIVE_ARGS struct rs6000_args\n+   have prototype types for.\n+\n+   The System V.4 varargs/stdarg support requires that this structure's size\n+   be a multiple of sizeof(int), and that WORDS, FREGNO, NARGS_PROTOTYPE,\n+   ORIG_NARGS, and VARARGS_OFFSET be the first five ints.  */\n+\n+typedef struct rs6000_args\n+{\n+  int words;\t\t\t/* # words uses for passing GP registers */\n+  int fregno;\t\t\t/* next available FP register */\n+  int nargs_prototype;\t\t/* # args left in the current prototype */\n+  int orig_nargs;\t\t/* Original value of nargs_prototype */\n+  int varargs_offset;\t\t/* offset of the varargs save area */\n+  int prototype;\t\t/* Whether a prototype was defined */\n+} CUMULATIVE_ARGS;\n \n /* Define intermediate macro to compute the size (in registers) of an argument\n    for the RS/6000.  */\n@@ -962,40 +1060,27 @@ struct rs6000_args {int words, fregno, nargs_prototype; };\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is 0.  */\n \n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)\t\\\n-  (CUM).words = 0,\t\t\t\t\\\n-  (CUM).fregno = 33,\t\t\t\t\\\n-  (CUM).nargs_prototype = (FNTYPE && TYPE_ARG_TYPES (FNTYPE)\t\t\\\n-\t\t\t   ? (list_length (TYPE_ARG_TYPES (FNTYPE)) - 1 \\\n-\t\t\t      + (TYPE_MODE (TREE_TYPE (FNTYPE)) == BLKmode \\\n-\t\t\t\t || RETURN_IN_MEMORY (TREE_TYPE (FNTYPE)))) \\\n-\t\t\t   : 0)\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME) \\\n+  init_cumulative_args (&CUM, FNTYPE, LIBNAME, FALSE)\n \n /* Similar, but when scanning the definition of a procedure.  We always\n    set NARGS_PROTOTYPE large so we never return an EXPR_LIST.  */\n \n-#define INIT_CUMULATIVE_INCOMING_ARGS(CUM,FNTYPE,IGNORE) \\\n-  (CUM).words = 0,\t\t\t\t\\\n-  (CUM).fregno = 33,\t\t\t\t\\\n-  (CUM).nargs_prototype = 1000\n+#define INIT_CUMULATIVE_INCOMING_ARGS(CUM,FNTYPE,LIBNAME) \\\n+  init_cumulative_args (&CUM, FNTYPE, LIBNAME, TRUE)\n \n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n-{ (CUM).nargs_prototype--;\t\t\t\t\\\n-  if (NAMED)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      (CUM).words += RS6000_ARG_SIZE (MODE, TYPE, NAMED); \\\n-      if (GET_MODE_CLASS (MODE) == MODE_FLOAT)\t\t\\\n-\t(CUM).fregno++;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-}\n+  function_arg_advance (&CUM, MODE, TYPE, NAMED)\n \n /* Non-zero if we can use a floating-point register to pass this arg.  */\n-#define USE_FP_FOR_ARG_P(CUM,MODE,TYPE)\t\\\n-  (GET_MODE_CLASS (MODE) == MODE_FLOAT && (CUM).fregno < 46 && TARGET_HARD_FLOAT)\n+#define USE_FP_FOR_ARG_P(CUM,MODE,TYPE) \\\n+  (GET_MODE_CLASS (MODE) == MODE_FLOAT  \\\n+   && (CUM).fregno <= FP_ARG_MAX_REG    \\\n+   && TARGET_HARD_FLOAT)\n \n /* Determine where to put an argument to a function.\n    Value is zero to push the argument on the stack,\n@@ -1019,30 +1104,24 @@ struct rs6000_args {int words, fregno, nargs_prototype; };\n    so we can pass the FP value just in one register.  emit_library_function\n    doesn't support EXPR_LIST anyway.  */\n \n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\t\\\n-  (! (NAMED) ? 0\t\t\t\t\t\t\t\\\n-   : ((TYPE) != 0 && TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST) ? 0\t\\\n-   : USE_FP_FOR_ARG_P (CUM, MODE, TYPE)\t\t\t\t\t\\\n-   ? ((CUM).nargs_prototype > 0 || (TYPE) == 0\t\t\t\t\\\n-      ? gen_rtx (REG, MODE, (CUM).fregno)\t\t\t\t\\\n-      : ((CUM).words < 8\t\t\t\t\t\t\\\n-\t ? gen_rtx (EXPR_LIST, VOIDmode,\t\t\t\t\\\n-\t\t    gen_rtx (REG, (MODE), 3 + (CUM).words),\t\t\\\n-\t\t    gen_rtx (REG, (MODE), (CUM).fregno))\t\t\\\n-\t : gen_rtx (EXPR_LIST, VOIDmode, 0,\t\t\t\t\\\n-\t\t    gen_rtx (REG, (MODE), (CUM).fregno))))\t\t\\\n-   : (CUM).words < 8 ? gen_rtx(REG, (MODE), 3 + (CUM).words) : 0)\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+  function_arg (&CUM, MODE, TYPE, NAMED)\n \n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n    For args passed entirely in registers or entirely in memory, zero.  */\n \n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\t\\\n-  (! (NAMED) ? 0\t\t\t\t\t\t\t\\\n-   : USE_FP_FOR_ARG_P (CUM, MODE, TYPE) && (CUM).nargs_prototype >= 0 ? 0 \\\n-   : (((CUM).words < 8\t\t\t\t\t\t\t\\\n-       && 8 < ((CUM).words + RS6000_ARG_SIZE (MODE, TYPE, NAMED)))\t\\\n-      ? 8 - (CUM).words : 0))\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n+  function_arg_partial_nregs (&CUM, MODE, TYPE, NAMED)\n+\n+/* A C expression that indicates when an argument must be passed by\n+   reference.  If nonzero for an argument, a copy of that argument is\n+   made in memory and a pointer to the argument is passed instead of\n+   the argument itself.  The pointer is passed in whatever way is\n+   appropriate for passing a pointer to that type. */\n+\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n+  function_arg_pass_by_reference(&CUM, MODE, TYPE, NAMED)\n \n /* Perform any needed actions needed for a function that is receiving a\n    variable number of arguments. \n@@ -1058,27 +1137,23 @@ struct rs6000_args {int words, fregno, nargs_prototype; };\n    Normally, this macro will push all remaining incoming registers on the\n    stack and set PRETEND_SIZE to the length of the registers pushed.  */\n \n-#define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL)\t\\\n-{ if ((CUM).words < 8)\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      int first_reg_offset = (CUM).words;\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (MUST_PASS_IN_STACK (MODE, TYPE))\t\t\t\t\\\n-\tfirst_reg_offset += RS6000_ARG_SIZE (TYPE_MODE (TYPE), TYPE, 1); \\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (first_reg_offset > 8)\t\t\t\t\t\t\\\n-\tfirst_reg_offset = 8;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (! (NO_RTL) && first_reg_offset != 8)\t\t\t\t\\\n-\tmove_block_from_reg\t\t\t\t\t\t\\\n-\t  (3 + first_reg_offset,\t\t\t\t\t\\\n-\t   gen_rtx (MEM, BLKmode,\t\t\t\t\t\\\n-\t\t    plus_constant (virtual_incoming_args_rtx,\t\t\\\n-\t\t\t\t   first_reg_offset * 4)),\t\t\\\n-\t   8 - first_reg_offset, (8 - first_reg_offset) * UNITS_PER_WORD); \\\n-      PRETEND_SIZE = (8 - first_reg_offset) * UNITS_PER_WORD;\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n+#define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL) \\\n+  setup_incoming_varargs (&CUM, MODE, TYPE, &PRETEND_SIZE, NO_RTL)\n+\n+/* If defined, is a C expression that produces the machine-specific\n+   code for a call to `__builtin_saveregs'.  This code will be moved\n+   to the very beginning of the function, before any parameter access\n+   are made.  The return value of this function should be an RTX that\n+   contains the value to use as the return of `__builtin_saveregs'.\n+\n+   The argument ARGS is a `tree_list' containing the arguments that\n+   were passed to `__builtin_saveregs'.\n+\n+   If this macro is not defined, the compiler will output an ordinary\n+   call to the library function `__builtin_saveregs'.  */\n+\n+#define EXPAND_BUILTIN_SAVEREGS(ARGS) \\\n+  expand_builtin_saveregs (ARGS)\n \n /* This macro generates the assembly code for function entry.\n    FILE is a stdio stream to output the code to.\n@@ -1210,34 +1285,21 @@ struct rs6000_args {int words, fregno, nargs_prototype; };\n #define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\\\n  ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM\t\\\n   ? ! frame_pointer_needed\t\t\t\t\t\\\n-  : (FROM) == 30 ? ! TARGET_MINIMAL_TOC || get_pool_size () == 0 \\\n+  : (FROM) == 30 ? ! TARGET_MINIMAL_TOC || TARGET_NO_TOC || get_pool_size () == 0 \\\n   : 1)\n \n /* Define the offset between two registers, one to be eliminated, and the other\n    its replacement, at the start of a routine.  */\n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  int total_stack_size = (rs6000_sa_size () + get_frame_size ()\t\t\\\n-\t\t\t  + current_function_outgoing_args_size);\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  total_stack_size = (total_stack_size + 7) & ~7;\t\t\t\\\n+  rs6000_stack_t *info = rs6000_stack_info ();\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n  if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (rs6000_pushes_stack ())\t\t\t\t\t\\\n-\t(OFFSET) = 0;\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\t(OFFSET) = - total_stack_size;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if ((FROM) == ARG_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM) \\\n-      (OFFSET) = total_stack_size;\t\t\t\t\t\\\n-  else if ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM) \\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (rs6000_pushes_stack ())\t\t\t\t\t\\\n-\t(OFFSET) = total_stack_size;\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\t(OFFSET) = 0;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n+   (OFFSET) = (info->push_p) ? 0 : - info->total_size;\t\t\t\\\n+ else if ((FROM) == ARG_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM)\t\\\n+   (OFFSET) = info->total_size;\t\t\t\t\t\t\\\n+ else if ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\t\\\n+   (OFFSET) = (info->push_p) ? info->total_size : 0;\t\t\t\\\n   else if ((FROM) == 30)\t\t\t\t\t\t\\\n     (OFFSET) = 0;\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n@@ -1341,12 +1403,14 @@ struct rs6000_args {int words, fregno, nargs_prototype; };\n    we must ensure that both words are addressable.  */\n \n #define LEGITIMATE_CONSTANT_POOL_BASE_P(X)\t\t\t\t\\\n-  (GET_CODE (X) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (X)\t\t\\\n+  (TARGET_TOC && GET_CODE (X) == SYMBOL_REF\t\t\t\t\\\n+   && CONSTANT_POOL_ADDRESS_P (X)\t\t\t\t\t\\\n    && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (X)))\n \n #define LEGITIMATE_CONSTANT_POOL_ADDRESS_P(X)\t\t\t\t\\\n   (LEGITIMATE_CONSTANT_POOL_BASE_P (X)\t\t\t\t\t\\\n-   || (GET_CODE (X) == CONST && GET_CODE (XEXP (X, 0)) == PLUS\t\t\\\n+   || (TARGET_TOC\t\t\t\t\t\t\t\\\n+       && GET_CODE (X) == CONST && GET_CODE (XEXP (X, 0)) == PLUS\t\\\n        && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT\t\t\t\\\n        && LEGITIMATE_CONSTANT_POOL_BASE_P (XEXP (XEXP (X, 0), 0))))\n \n@@ -1374,6 +1438,16 @@ struct rs6000_args {int words, fregno, nargs_prototype; };\n #define LEGITIMATE_INDIRECT_ADDRESS_P(X)\t\\\n   (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\n \n+#define LEGITIMATE_LO_SUM_ADDRESS_P(MODE, X)\t\t\\\n+  (TARGET_ELF\t\t\t\t\t\t\\\n+   && (MODE) != DImode\t\t\t\t\t\\\n+   && (MODE) != TImode\t\t\t\t\t\\\n+   && (TARGET_HARD_FLOAT || (MODE) != DFmode)\t\t\\\n+   && GET_CODE (X) == LO_SUM\t\t\t\t\\\n+   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\\\n+   && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\\\n+   && CONSTANT_P (XEXP (X, 1)))\n+\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\\\n { if (LEGITIMATE_INDIRECT_ADDRESS_P (X))\t\t\\\n     goto ADDR;\t\t\t\t\t\t\\\n@@ -1391,6 +1465,8 @@ struct rs6000_args {int words, fregno, nargs_prototype; };\n       && (TARGET_HARD_FLOAT || (MODE) != DFmode)\t\\\n       && LEGITIMATE_INDEXED_ADDRESS_P (X))\t\t\\\n     goto ADDR;\t\t\t\t\t\t\\\n+  if (LEGITIMATE_LO_SUM_ADDRESS_P (MODE, X))\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n }\n \f\n /* Try machine-dependent ways of modifying an illegitimate address\n@@ -1416,32 +1492,42 @@ struct rs6000_args {int words, fregno, nargs_prototype; };\n    Then check for the sum of a register and something not constant, try to\n    load the other things into a register and return the sum.  */\n \n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\\\n-{ if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == REG\t\\\n-    && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n-    && (unsigned) (INTVAL (XEXP (X, 1)) + 0x8000) >= 0x10000)\t\\\n-    { int high_int, low_int;\t\t\t\t\t\\\n-      high_int = INTVAL (XEXP (X, 1)) >> 16;\t\t\t\\\n-      low_int = INTVAL (XEXP (X, 1)) & 0xffff;\t\t\t\\\n-      if (low_int & 0x8000)\t\t\t\t\t\\\n-\thigh_int += 1, low_int |= 0xffff0000;\t\t\t\\\n-      (X) = gen_rtx (PLUS, SImode,\t\t\t\t\\\n-\t\t     force_operand\t\t\t\t\\\n-\t\t     \t(gen_rtx (PLUS, SImode, XEXP (X, 0), \\\n-\t\t\t\t  gen_rtx (CONST_INT, VOIDmode, \\\n-\t\t\t\t\t\t      high_int << 16)), 0),\\\n-\t\t     gen_rtx (CONST_INT, VOIDmode, low_int));\t\\\n-      goto WIN;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == REG \\\n-\t   && GET_CODE (XEXP (X, 1)) != CONST_INT\t\t\\\n-\t   && (TARGET_HARD_FLOAT || (MODE) != DFmode)\t\t\\\n-\t   && (MODE) != DImode && (MODE) != TImode) \t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\\\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\t\\\n+{ if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == REG\t\t\\\n+    && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n+    && (unsigned) (INTVAL (XEXP (X, 1)) + 0x8000) >= 0x10000)\t\t\\\n+    { int high_int, low_int;\t\t\t\t\t\t\\\n+      high_int = INTVAL (XEXP (X, 1)) >> 16;\t\t\t\t\\\n+      low_int = INTVAL (XEXP (X, 1)) & 0xffff;\t\t\t\t\\\n+      if (low_int & 0x8000)\t\t\t\t\t\t\\\n+\thigh_int += 1, low_int |= 0xffff0000;\t\t\t\t\\\n+      (X) = gen_rtx (PLUS, SImode,\t\t\t\t\t\\\n+\t\t     force_operand\t\t\t\t\t\\\n+\t\t     \t(gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\\\n+\t\t\t\t  gen_rtx (CONST_INT, VOIDmode,\t\t\\\n+\t\t\t\t\t\t      high_int << 16)), 0), \\\n+\t\t     gen_rtx (CONST_INT, VOIDmode, low_int));\t\t\\\n+      goto WIN;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == REG\t\\\n+\t   && GET_CODE (XEXP (X, 1)) != CONST_INT\t\t\t\\\n+\t   && (TARGET_HARD_FLOAT || (MODE) != DFmode)\t\t\t\\\n+\t   && (MODE) != DImode && (MODE) != TImode)\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\t\\\n \t\t     force_reg (SImode, force_operand (XEXP (X, 1), 0))); \\\n-      goto WIN;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n+      goto WIN;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (TARGET_ELF && !TARGET_64BIT && TARGET_NO_TOC\t\t\t\\\n+\t   && GET_CODE (X) != CONST_INT\t\t\t\t\t\\\n+\t   && GET_CODE (X) != CONST_DOUBLE && CONSTANT_P (X)\t\t\\\n+\t   && (TARGET_HARD_FLOAT || (MODE) != DFmode)\t\t\t\\\n+\t   && (MODE) != DImode && (MODE) != TImode)\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rtx reg = gen_reg_rtx (Pmode);\t\t\t\t\t\\\n+      emit_insn (gen_elf_high (reg, (X)));\t\t\t\t\\\n+      (X) = gen_rtx (LO_SUM, Pmode, reg, (X));\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n }\n \n /* Go to LABEL if ADDR (a legitimate address expression)\n@@ -1462,6 +1548,8 @@ struct rs6000_args {int words, fregno, nargs_prototype; };\n     goto LABEL;\t\t\t\t\t\t\t\\\n   if (GET_CODE (ADDR) == PRE_DEC)\t\t\t\t\\\n     goto LABEL;\t\t\t\t\t\t\t\\\n+  if (GET_CODE (ADDR) == LO_SUM)\t\t\t\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\\\n }\n \f\n /* Define this if some processing needs to be done immediately before\n@@ -1561,7 +1649,7 @@ struct rs6000_args {int words, fregno, nargs_prototype; };\n    The sle and sre instructions which allow SHIFT_COUNT_TRUNCATED\n    have been dropped from the PowerPC architecture.  */\n \n-#define SHIFT_COUNT_TRUNCATED TARGET_POWER ? 1 : 0\n+#define SHIFT_COUNT_TRUNCATED (TARGET_POWER ? 1 : 0)\n \n /* Use atexit for static constructors/destructors, instead of defining\n    our own exit function.  */\n@@ -1575,12 +1663,13 @@ struct rs6000_args {int words, fregno, nargs_prototype; };\n    On the RS/6000, if it is valid in the insn, it is free.  So this\n    always returns 0.  */\n \n-#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE)\t\t\t\\\n   case CONST_INT:\t\t\t\t\t\t\\\n   case CONST:\t\t\t\t\t\t\t\\\n   case LABEL_REF:\t\t\t\t\t\t\\\n   case SYMBOL_REF:\t\t\t\t\t\t\\\n   case CONST_DOUBLE:\t\t\t\t\t\t\\\n+  case HIGH:\t\t\t\t\t\t\t\\\n     return 0;\n \n /* Provide the costs of a rtl expression.  This is in the body of a\n@@ -1894,7 +1983,7 @@ toc_section ()\t\t\t\t\t\t\\\n   fprintf (FILE, \"\\t.long .\");\t\t\t\t\t\\\n   RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n   fprintf (FILE, \", TOC[tc0], 0\\n\");\t\t\t\t\\\n-  fprintf (FILE, \".csect .text[PR]\\n.\");\t\t\t\t\\\n+  fprintf (FILE, \".csect .text[PR]\\n.\");\t\t\t\\\n   RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n   fprintf (FILE, \":\\n\");\t\t\t\t\t\\\n   if (write_symbols == XCOFF_DEBUG)\t\t\t\t\\\n@@ -1909,15 +1998,16 @@ toc_section ()\t\t\t\t\t\t\\\n    we can't check that since not every file that uses\n    GO_IF_LEGITIMATE_ADDRESS_P includes real.h.  */\n \n-#define ASM_OUTPUT_SPECIAL_POOL_ENTRY_P(X)\t\t\t\\\n-  (GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\\\n-   || (GET_CODE (X) == CONST && GET_CODE (XEXP (X, 0)) == PLUS\t\\\n-       && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF)\t\\\n-   || GET_CODE (X) == LABEL_REF\t\t\t\t\t\\\n-   || (! (TARGET_NO_FP_IN_TOC && ! TARGET_MINIMAL_TOC)\t\t\\\n-       && GET_CODE (X) == CONST_DOUBLE\t\t\t\t\\\n-       && GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\\\n-       && BITS_PER_WORD == HOST_BITS_PER_INT))\n+#define ASM_OUTPUT_SPECIAL_POOL_ENTRY_P(X)\t\t\t\t\\\n+  (TARGET_TOC\t\t\t\t\t\t\t\t\\\n+   && (GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\\\n+       || (GET_CODE (X) == CONST && GET_CODE (XEXP (X, 0)) == PLUS\t\\\n+\t   && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF)\t\t\\\n+       || GET_CODE (X) == LABEL_REF\t\t\t\t\t\\\n+       || (! (TARGET_NO_FP_IN_TOC && ! TARGET_MINIMAL_TOC)\t\t\\\n+\t   && GET_CODE (X) == CONST_DOUBLE\t\t\t\t\\\n+\t   && GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\\\n+\t   && BITS_PER_WORD == HOST_BITS_PER_INT)))\n \n /* Select section for constant in constant pool.\n \n@@ -2230,15 +2320,23 @@ toc_section ()\t\t\t\t\t\t\\\n /* This is how to output code to push a register on the stack.\n    It need not be very fast code.  */\n \n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n-  asm_fprintf (FILE, \"\\{tstu|stwu} %s,-4(r1)\\n\", reg_names[REGNO]);\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  extern char *reg_names[];\t\t\t\t\t\t\\\n+  asm_fprintf (FILE, \"\\{tstu|stwu} %s,-4(%s)\\n\", reg_names[REGNO],\t\\\n+\t       reg_names[1]);\t\t\t\t\t\t\\\n+} while (0)\n \n /* This is how to output an insn to pop a register from the stack.\n    It need not be very fast code.  */\n \n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n-  asm_fprintf (FILE, \"\\t{l|lwz} %s,0(r1)\\n\\t{ai|addic} r1,r1,4\\n\",  \\\n-    reg_names[REGNO])\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  extern char *reg_names[];\t\t\t\t\t\t\\\n+  asm_fprintf (FILE, \"\\t{l|lwz} %s,0(%s)\\n\\t{ai|addic} %s,%s,4\\n\",\t\\\n+\t       reg_names[REGNO], reg_names[1], reg_names[1],\t\t\\\n+\t       reg_names[1]);\t\t\t\t\t\t\\\n+} while (0)\n \n /* This is how to output an element of a case-vector that is absolute. \n    (RS/6000 does not use such vectors, but we must define this macro\n@@ -2396,6 +2494,13 @@ extern int lwa_operand ();\n extern int call_operand ();\n extern int current_file_function_operand ();\n extern int input_operand ();\n+extern void init_cumulative_args ();\n+extern void function_arg_advance ();\n+extern struct rtx_def *function_arg ();\n+extern int function_arg_partial_nregs ();\n+extern int function_arg_pass_by_reference ();\n+extern void setup_incoming_varargs ();\n+extern struct rtx_def *expand_builtin_saveregs ();\n extern int expand_block_move ();\n extern int load_multiple_operation ();\n extern int store_multiple_operation ();\n@@ -2411,10 +2516,8 @@ extern void print_operand ();\n extern void print_operand_address ();\n extern int first_reg_to_save ();\n extern int first_fp_reg_to_save ();\n-extern int must_save_cr ();\n-extern int rs6000_sa_size ();\n extern int rs6000_makes_calls ();\n-extern int rs6000_pushes_stack ();\n+extern rs6000_stack_t *rs6000_stack_info ();\n extern void svr4_traceback ();\n extern void output_prolog ();\n extern void output_epilog ();"}, {"sha": "06de4882591a40b94566925ca6a962515d588c81", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 148, "deletions": 26, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=4697a36cef9b136c6eccca9c0e23f3e653f0bd99", "patch": "@@ -3487,6 +3487,7 @@\n    (use (reg:DF 33))\n    (parallel [(set (reg:SI 3)\n \t\t   (call (mem:SI (match_operand 2 \"\" \"\")) (const_int 0)))\n+\t      (use (const_int 0))\n \t      (clobber (scratch:SI))])\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(reg:SI 3))]\n@@ -3832,7 +3833,24 @@\n   [(set_attr \"type\" \"delayed_compare\")])\n \f\n ;; Now define ways of moving data around.\n-;;\n+\n+;; Elf specific ways of loading addresses for non-PIC code.\n+;; The output of this could be r0, but we limit it to base\n+;; registers, since almost all uses of this will need it\n+;; in a base register shortly.\n+(define_insn \"elf_high\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=b\")\n+\t(high:SI (match_operand 1 \"\" \"\")))]\n+  \"TARGET_ELF && !TARGET_64BIT\"\n+  \"{cau|addis} %0,0,%1@ha\")\n+\n+(define_insn \"elf_low\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"b\")\n+\t\t   (match_operand 2 \"\" \"\")))]\n+   \"TARGET_ELF && !TARGET_64BIT\"\n+   \"{cal %0,%a2@l(%1)|addi %0,%1,%2@l}\")\n+\n ;; For SI, we special-case integers that can't be loaded in one insn.  We\n ;; do the load 16-bits at a time.  We could do this by loading from memory,\n ;; and this is even supposed to be faster, but it is simpler not to get\n@@ -3850,7 +3868,22 @@\n   if (GET_CODE (operands[1]) == CONST_DOUBLE)\n     operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n \n-  if (CONSTANT_P (operands[1]) && GET_CODE (operands[1]) != CONST_INT\n+  if (TARGET_ELF && TARGET_NO_TOC && !TARGET_64BIT\n+      && CONSTANT_P (operands[1])\n+      && GET_CODE (operands[1]) != HIGH\n+      && GET_CODE (operands[1]) != CONST_INT)\n+    {\n+      rtx target = (reload_completed || reload_in_progress)\n+\t\t\t? operands[0] : gen_reg_rtx (SImode);\n+\n+      emit_insn (gen_elf_high (target, operands[1]));\n+      emit_insn (gen_elf_low (operands[0], target, operands[1]));\n+      DONE;\n+    }\n+\n+  if (CONSTANT_P (operands[1])\n+      && GET_CODE (operands[1]) != CONST_INT\n+      && GET_CODE (operands[1]) != HIGH\n       && ! LEGITIMATE_CONSTANT_POOL_ADDRESS_P (operands[1]))\n     {\n       /* If we are to limit the number of things we put in the TOC and\n@@ -5014,7 +5047,7 @@\n   \"lwaux %3,%0,%2\"\n   [(set_attr \"type\" \"load\")])\n \n-(define_insn \"\"\n+(define_insn \"movdi_update\"\n   [(set (mem:DI (plus:DI (match_operand:DI 1 \"gpc_reg_operand\" \"0,0\")\n \t\t\t (match_operand:DI 2 \"reg_or_short_operand\" \"r,I\")))\n \t(match_operand:DI 3 \"gpc_reg_operand\" \"r,r\"))\n@@ -5037,7 +5070,7 @@\n    {lu|lwzu} %3,%2(%0)\"\n   [(set_attr \"type\" \"load\")])\n \n-(define_insn \"\"\n+(define_insn \"movsi_update\"\n   [(set (mem:SI (plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"0,0\")\n \t\t\t (match_operand:SI 2 \"reg_or_short_operand\" \"r,I\")))\n \t(match_operand:SI 3 \"gpc_reg_operand\" \"r,r\"))\n@@ -5215,12 +5248,48 @@\n \t(minus:SI (reg:SI 1) (match_operand:SI 0 \"reg_or_short_operand\" \"\")))]\n   \"\"\n   \"\n-{ rtx chain = gen_reg_rtx (SImode);\n+{ rtx chain = gen_reg_rtx (Pmode);\n   rtx stack_bot = gen_rtx (MEM, Pmode, stack_pointer_rtx);\n+  rtx neg_op0;\n+  rtx lr_addr = NULL_RTX;\n+  rtx lr = NULL_RTX;\n \n   emit_move_insn (chain, stack_bot);\n-  emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx, operands[0]));\n-  emit_move_insn (stack_bot, chain);\n+\n+#ifdef TARGET_V4_CALLS\n+  if (TARGET_V4_CALLS)\n+    {\n+      lr = gen_reg_rtx (Pmode);\n+      lr_addr = gen_rtx (MEM, Pmode, gen_rtx (PLUS, Pmode,\n+\t\t\t\t\t      stack_pointer_rtx,\n+\t\t\t\t\t      GEN_INT (4)));\n+      emit_move_insn (lr, lr_addr);\n+    }\n+#endif\n+\n+  if (GET_CODE (operands[0]) != CONST_INT\n+      || INTVAL (operands[0]) < -32767\n+      || INTVAL (operands[0]) > 32768)\n+    {\n+      neg_op0 = gen_reg_rtx (Pmode);\n+      if (TARGET_POWERPC64)\n+\temit_insn (gen_negdi2 (neg_op0, operands[0]));\n+      else\n+\temit_insn (gen_negsi2 (neg_op0, operands[0]));\n+    }\n+  else\n+    neg_op0 = GEN_INT (- INTVAL (operands[0]));\n+\n+  if (TARGET_POWERPC64)\n+    emit_insn (gen_movdi_update (stack_pointer_rtx, stack_pointer_rtx, neg_op0, chain));\n+  else\n+    emit_insn (gen_movsi_update (stack_pointer_rtx, stack_pointer_rtx, neg_op0, chain));\n+\n+#ifdef TARGET_V4_CALLS\n+  if (TARGET_V4_CALLS)\n+    emit_move_insn (lr_addr, lr);\n+#endif\n+\n   DONE;\n }\")\n \n@@ -5310,6 +5379,7 @@\n (define_expand \"call\"\n   [(parallel [(call (mem:SI (match_operand:SI 0 \"address_operand\" \"\"))\n \t\t    (match_operand 1 \"\" \"\"))\n+\t      (use (match_operand 2 \"\" \"\"))\n \t      (clobber (scratch:SI))])]\n   \"\"\n   \"\n@@ -5334,6 +5404,7 @@\n   [(parallel [(set (match_operand 0 \"\" \"\")\n \t\t   (call (mem:SI (match_operand:SI 1 \"address_operand\" \"\"))\n \t\t\t (match_operand 2 \"\" \"\")))\n+\t      (use (match_operand 3 \"\" \"\"))\n \t      (clobber (scratch:SI))])]\n   \"\"\n   \"\n@@ -5355,24 +5426,50 @@\n }\")\n \n ;; Call to function in current module.  No TOC pointer reload needed.\n+;; Operand2 is non-zero if we are using the V.4 calling sequence and\n+;; either the function was not prototyped, or it was prototyped as a\n+;; variable argument function.  It is > 0 if FP registers were passed\n+;; and < 0 if they were not.\n \n (define_insn \"\"\n-  [(call (mem:SI (match_operand:SI 0 \"current_file_function_operand\" \"s\"))\n-\t (match_operand 1 \"\" \"g\"))\n-   (clobber (match_scratch:SI 2 \"=l\"))]\n+  [(call (mem:SI (match_operand:SI 0 \"current_file_function_operand\" \"s,s\"))\n+\t (match_operand 1 \"\" \"g,g\"))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n+   (clobber (match_scratch:SI 3 \"=l,l\"))]\n   \"\"\n-  \"bl %z0\")\n+  \"*\n+{\n+  if (INTVAL (operands[2]) > 0)\n+    return \\\"creqv 6,6,6\\;bl %z0\\\";\n+\n+  else if (INTVAL (operands[2]) < 0)\n+    return \\\"crxor 6,6,6\\;bl %z0\\\";\n+\n+  return \\\"bl %z0\\\";\n+}\"\n+  [(set_attr \"length\" \"4,8\")])\n \n ;; Call to function which may be in another module.  Restore the TOC\n ;; pointer (r2) after the call unless this is System V.\n+;; Operand2 is non-zero if we are using the V.4 calling sequence and\n+;; either the function was not prototyped, or it was prototyped as a\n+;; variable argument function.  It is > 0 if FP registers were passed\n+;; and < 0 if they were not.\n \n (define_insn \"\"\n-  [(call (mem:SI (match_operand:SI 0 \"call_operand\" \"l,s\"))\n-\t (match_operand 1 \"\" \"fg,fg\"))\n-   (clobber (match_scratch:SI 2 \"=l,l\"))]\n+  [(call (mem:SI (match_operand:SI 0 \"call_operand\" \"l,s,l,s\"))\n+\t (match_operand 1 \"\" \"fg,fg,fg,fg\"))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"O,O,n,n\"))\n+   (clobber (match_scratch:SI 3 \"=l,l,l,l\"))]\n   \"\"\n   \"*\n {\n+  if (INTVAL (operands[2]) > 0)\n+    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n+\n+  else if (INTVAL (operands[2]) < 0)\n+    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n+\n #ifndef USING_SVR4_H\n   if (GET_CODE (operands[0]) == REG)\n     return \\\"{brl|blrl}\\;{l|lwz} 2,20(1)\\\";\n@@ -5386,24 +5483,42 @@\n   return \\\"bl %z0\\\";\n #endif\n }\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"length\" \"8,8,12,12\")])\n \n (define_insn \"\"\n-  [(set (match_operand 0 \"\" \"=fg\")\n-\t(call (mem:SI (match_operand:SI 1 \"current_file_function_operand\" \"s\"))\n-\t      (match_operand 2 \"\" \"g\")))\n-   (clobber (match_scratch:SI 3 \"=l\"))]\n+  [(set (match_operand 0 \"\" \"=fg,fg\")\n+\t(call (mem:SI (match_operand:SI 1 \"current_file_function_operand\" \"s,s\"))\n+\t      (match_operand 2 \"\" \"g,g\")))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n+   (clobber (match_scratch:SI 4 \"=l,l\"))]\n   \"\"\n-  \"bl %z1\")\n+  \"*\n+{\n+  if (INTVAL (operands[3]) > 0)\n+    return \\\"creqv 6,6,6\\;bl %z1\\\";\n+\n+  else if (INTVAL (operands[3]) < 0)\n+    return \\\"crxor 6,6,6\\;bl %z1\\\";\n+\n+  return \\\"bl %z1\\\";\n+}\"\n+  [(set_attr \"length\" \"4,8\")])\n \n (define_insn \"\"\n-  [(set (match_operand 0 \"\" \"=fg,fg\")\n-\t(call (mem:SI (match_operand:SI 1 \"call_operand\" \"l,s\"))\n-\t      (match_operand 2 \"\" \"fg,fg\")))\n-   (clobber (match_scratch:SI 3 \"=l,l\"))]\n+  [(set (match_operand 0 \"\" \"=fg,fg,fg,fg\")\n+\t(call (mem:SI (match_operand:SI 1 \"call_operand\" \"l,s,l,s\"))\n+\t      (match_operand 2 \"\" \"fg,fg,fg,fg\")))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"O,O,n,n\"))\n+   (clobber (match_scratch:SI 4 \"=l,l,l,l\"))]\n   \"\"\n   \"*\n {\n+  if (INTVAL (operands[3]) > 0)\n+    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n+\n+  else if (INTVAL (operands[3]) < 0)\n+    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n+\n #ifndef USING_SVR4_H\n   if (GET_CODE (operands[1]) == REG)\n     return \\\"{brl|blrl}\\;{l|lwz} 2,20(1)\\\";\n@@ -5417,7 +5532,7 @@\n   return \\\"bl %z1\\\";\n #endif\n }\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"length\" \"8,8,12,12\")])\n \n ;; Call subroutine returning any type.\n \n@@ -5431,7 +5546,7 @@\n {\n   int i;\n \n-  emit_call_insn (gen_call (operands[0], const0_rtx, NULL, const0_rtx));\n+  emit_call_insn (gen_call (operands[0], const0_rtx, const0_rtx, const0_rtx));\n \n   for (i = 0; i < XVECLEN (operands[2], 0); i++)\n     {\n@@ -5455,6 +5570,13 @@\n   [(unspec_volatile [(const_int 0)] 0)]\n   \"\"\n   \"\")\n+\n+;; Sync instruction used for V.4 trampolines\n+(define_insn \"sync\"\n+  [(unspec [(match_operand 0 \"\" \"\")] 1)]\n+  \"\"\n+  \"sync\")\n+\n \f\n ;; Compare insns are next.  Note that the RS/6000 has two types of compares,\n ;; signed & unsigned, and one type of branch."}, {"sha": "d79cc94f832e77796cf482b67bdae717f7d5446d", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 128, "deletions": 44, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=4697a36cef9b136c6eccca9c0e23f3e653f0bd99", "patch": "@@ -27,20 +27,35 @@ Boston, MA 02111-1307, USA.  */\n #define MASK_RELOCATABLE\t0x10000000\t/* GOT pointers are PC relative */\n #define\tMASK_NO_TRACEBACK\t0x08000000\t/* eliminate traceback words */\n #define MASK_LITTLE_ENDIAN\t0x04000000\t/* target is little endian */\n-#define MASK_NO_TOC\t\t0x02000000\t/* do not use TOC for loading addresses */\n+#define MASK_AIX_CALLS\t\t0x02000000\t/* Use AIX calling sequence */\n+#define MASK_PROTOTYPE\t\t0x01000000\t/* Only prototyped fcns pass variable args */\n \n #define\tTARGET_NO_BITFIELD_TYPE\t(target_flags & MASK_NO_BITFIELD_TYPE)\n #define TARGET_STRICT_ALIGN\t(target_flags & MASK_STRICT_ALIGN)\n #define TARGET_RELOCATABLE\t(target_flags & MASK_RELOCATABLE)\n #define TARGET_NO_TRACEBACK\t(target_flags & MASK_NO_TRACEBACK)\n #define TARGET_LITTLE_ENDIAN\t(target_flags & MASK_LITTLE_ENDIAN)\n-#define TARGET_NO_TOC\t\t(target_flags & MASK_NO_TOC)\n+#define TARGET_AIX_CALLS\t(target_flags & MASK_AIX_CALLS)\n+#define\tTARGET_PROTOTYPE\t(target_flags & MASK_PROTOTYPE)\n+#define\tTARGET_TOC\t\t(target_flags & (MASK_64BIT\t\t\\\n+\t\t\t\t\t\t | MASK_RELOCATABLE\t\\\n+\t\t\t\t\t\t | MASK_MINIMAL_TOC))\n \n #define\tTARGET_BITFIELD_TYPE\t(! TARGET_NO_BITFIELD_TYPE)\n #define\tTARGET_TRACEBACK\t(! TARGET_NO_TRACEBACK)\n #define TARGET_BIG_ENDIAN\t(! TARGET_LITTLE_ENDIAN)\n-#define TARGET_TOC\t\t(! TARGET_NO_TOC)\n+#define TARGET_NO_AIX_CALLS\t(! TARGET_AIX_CALLS)\n+#define\tTARGET_NO_PROTOTYPE\t(! TARGET_PROTOTYPE)\n+#define\tTARGET_NO_TOC\t\t(! TARGET_TOC)\n \n+#define TARGET_V4_CALLS\t\tTARGET_NO_AIX_CALLS\n+\n+/* Pseudo target to indicate whether the object format is ELF\n+   (to get around not having conditional compilation in the md file)  */\n+#define\tTARGET_ELF\t\t1\n+\n+/* Note, V.4 no longer uses a normal TOC, so make -mfull-toc, be just\n+   the same as -mminimal-toc.  */\n #undef\tSUBTARGET_SWITCHES\n #define SUBTARGET_SWITCHES\t\t\t\t\t\t\\\n   { \"bit-align\",\t-MASK_NO_BITFIELD_TYPE },\t\t\t\\\n@@ -55,8 +70,13 @@ Boston, MA 02111-1307, USA.  */\n   { \"little\",\t\t MASK_LITTLE_ENDIAN },\t\t\t\t\\\n   { \"big-endian\",\t-MASK_LITTLE_ENDIAN },\t\t\t\t\\\n   { \"big\",\t\t-MASK_LITTLE_ENDIAN },\t\t\t\t\\\n-  { \"no-toc\",\t\t MASK_NO_TOC | MASK_MINIMAL_TOC },\t\t\\\n-  { \"toc\",\t\t-MASK_NO_TOC },\n+  { \"no-toc\",\t\t 0 },\t\t\t\t\t\t\\\n+  { \"toc\",\t\t MASK_MINIMAL_TOC },\t\t\t\t\\\n+  { \"full-toc\",\t\t MASK_MINIMAL_TOC },\t\t\t\t\\\n+  { \"call-aix\",\t\t MASK_AIX_CALLS },\t\t\t\t\\\n+  { \"call-sysv\",\t-MASK_AIX_CALLS },\t\t\t\t\\\n+  { \"prototype\",\t MASK_PROTOTYPE },\t\t\t\t\\\n+  { \"no-prototype\",\t-MASK_PROTOTYPE },\n \n /* Sometimes certain combinations of command options do not make sense\n    on a particular target machine.  You can define a macro\n@@ -69,22 +89,10 @@ Boston, MA 02111-1307, USA.  */\n \n #define SUBTARGET_OVERRIDE_OPTIONS\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_RELOCATABLE && TARGET_NO_TOC)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      target_flags &= ~ MASK_NO_TOC;\t\t\t\t\t\\\n-      error (\"-mrelocatable and -mno-toc are incompatible.\");\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n   if (TARGET_RELOCATABLE && !TARGET_MINIMAL_TOC)\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       target_flags |= MASK_MINIMAL_TOC;\t\t\t\t\t\\\n       error (\"-mrelocatable and -mno-minimal-toc are incompatible.\");\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_NO_TOC && !TARGET_MINIMAL_TOC)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      target_flags |= MASK_MINIMAL_TOC;\t\t\t\t\t\\\n-      error (\"-mno-toc and -mno-minimal-toc are incompatible.\");\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n } while (0)\n \n@@ -96,12 +104,38 @@ do {\t\t\t\t\t\t\t\t\t\\\n #undef\tFIXED_R13\n #define FIXED_R13 1\n \n+/* System V.4 passes the first 8 floating arguments in registers,\n+   instead of the first 13 like AIX does.  */\n+#undef\tFP_ARG_MAX_REG\n+#define\tFP_ARG_AIX_MAX_REG\t45\n+#define\tFP_ARG_V4_MAX_REG\t40\n+#define\tFP_ARG_MAX_REG ((TARGET_AIX_CALLS) ? FP_ARG_AIX_MAX_REG : FP_ARG_V4_MAX_REG)\n+\n+/* Size of the V.4 varargs area if needed */\n+#undef\tRS6000_VARARGS_AREA\n+#define RS6000_VARARGS_AREA ((rs6000_sysv_varargs_p) ? RS6000_VARARGS_SIZE : 0)\n+\n /* Override default big endianism */\n #undef  BYTES_BIG_ENDIAN\n #undef  WORDS_BIG_ENDIAN\n #define BYTES_BIG_ENDIAN (TARGET_BIG_ENDIAN)\n #define WORDS_BIG_ENDIAN (TARGET_BIG_ENDIAN)\n \n+/* Size of the outgoing register save area */\n+#undef\tRS6000_REG_SAVE\n+#define RS6000_REG_SAVE (TARGET_AIX_CALLS ? (TARGET_64BIT ? 64 : 32) : 0)\n+\n+/* Size of the fixed area on the stack.  For AIX, use the standard 6 word\n+   area, otherwise use 2 words to store back chain & LR.  */\n+#undef\tRS6000_SAVE_AREA\n+#define RS6000_SAVE_AREA \\\n+  ((TARGET_AIX_CALLS ? 24 : 8) << (TARGET_64BIT ? 1 : 0))\n+\n+/* Define cutoff for using external functions to save floating point.\n+   Currently on V.4, always use inline stores */\n+#undef\tFP_SAVE_INLINE\n+#define FP_SAVE_INLINE(FIRST_REG) ((FIRST_REG) < 64)\n+\n /* Don't generate XCOFF debugging information.  */\n \n #undef XCOFF_DEBUGGING_INFO\n@@ -192,37 +226,14 @@ toc_section ()\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   if (in_section != in_toc)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n+      in_section = in_toc;\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", MINIMAL_TOC_SECTION_ASM_OP);\t\\\n       if (! toc_initialized)\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  if (!TARGET_RELOCATABLE && !TARGET_NO_TOC)\t\t\t\\\n-\t    fprintf (asm_out_file, \"%s\\n\", TOC_SECTION_ASM_OP);\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t  if (TARGET_MINIMAL_TOC)\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      if (!TARGET_RELOCATABLE && !TARGET_NO_TOC)\t\t\\\n-\t\t{\t\t\t\t\t\t\t\\\n-\t\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LCTOC\", 0);\t\\\n-\t\t  fprintf (asm_out_file, \"\\t.tc \");\t\t\t\\\n-\t\t  ASM_OUTPUT_INTERNAL_LABEL_PREFIX (asm_out_file, \"LCTOC1[TC],\"); \\\n-\t\t  ASM_OUTPUT_INTERNAL_LABEL_PREFIX (asm_out_file, \"LCTOC1\"); \\\n-\t\t  fprintf (asm_out_file, \"\\n\");\t\t\t\t\\\n-\t\t}\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t      fprintf (asm_out_file, \"%s\\n\", MINIMAL_TOC_SECTION_ASM_OP); \\\n-\t      ASM_OUTPUT_INTERNAL_LABEL_PREFIX (asm_out_file, \"LCTOC1\"); \\\n-\t      fprintf (asm_out_file, \" = .+32768\\n\");\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n+\t  ASM_OUTPUT_INTERNAL_LABEL_PREFIX (asm_out_file, \"LCTOC1\");\t\\\n+\t  fprintf (asm_out_file, \" = .+32768\\n\");\t\t\t\\\n \t  toc_initialized = 1;\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\tfprintf (asm_out_file, \"%s\\n\",\t\t\t\t\t\\\n-\t\t (TARGET_MINIMAL_TOC\t\t\t\t\t\\\n-\t\t  ? MINIMAL_TOC_SECTION_ASM_OP\t\t\t\t\\\n-\t\t  : TOC_SECTION_ASM_OP));\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      in_section = in_toc;\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\n \n@@ -342,7 +353,78 @@ while (0)\n \n #undef TARGET_VERSION\n #define TARGET_VERSION fprintf (stderr, \" (PowerPC System V.4)\");\n+\f\n+\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.\n+\n+   The trampoline should set the static chain pointer to value placed\n+   into the trampoline and should branch to the specified routine.\n+\n+   Unlike AIX, this needs real code.  */\n+\n+#undef\tTRAMPOLINE_TEMPLATE\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  char *sc = reg_names[STATIC_CHAIN_REGNUM];\t\t\t\t\\\n+  char *r0 = reg_names[0];\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (STATIC_CHAIN_REGNUM == 0 || !TARGET_NEW_MNEMONICS)\t\t\\\n+    abort ();\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_64BIT)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmflr %s\\n\", r0);\t\t/* offset  0 */\t\\\n+      fprintf (FILE, \"\\tbl .LTRAMP1\\n\");\t\t/* offset  4 */\t\\\n+      fprintf (FILE, \"\\t.long 0,0,0,0\\n\");\t\t/* offset  8 */\t\\\n+      fprintf (FILE, \".LTRAMP1:\\n\");\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmflr %s\\n\", sc);\t\t/* offset 28 */\t\\\n+      fprintf (FILE, \"\\tmtlr %s\\n\", r0);\t\t/* offset 32 */\t\\\n+      fprintf (FILE, \"\\tld %s,0(%s)\\n\", r0, sc);\t/* offset 36 */\t\\\n+      fprintf (FILE, \"\\tld %s,8(%s)\\n\", sc, sc);\t/* offset 40 */\t\\\n+      fprintf (FILE, \"\\tmtctr %s\\n\", r0);\t\t/* offset 44 */\t\\\n+      fprintf (FILE, \"\\tbctr\\n\");\t\t\t/* offset 48 */\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmflr %s\\n\", r0);\t\t/* offset  0 */\t\\\n+      fprintf (FILE, \"\\tbl .LTRAMP1\\n\");\t\t/* offset  4 */\t\\\n+      fprintf (FILE, \"\\t.long 0,0\\n\");\t\t\t/* offset  8 */\t\\\n+      fprintf (FILE, \".LTRAMP1:\\n\");\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmflr %s\\n\", sc);\t\t/* offset 20 */\t\\\n+      fprintf (FILE, \"\\tmtlr %s\\n\", r0);\t\t/* offset 24 */\t\\\n+      fprintf (FILE, \"\\tlwz %s,0(%s)\\n\", r0, sc);\t/* offset 28 */\t\\\n+      fprintf (FILE, \"\\tlwz %s,4(%s)\\n\", sc, sc);\t/* offset 32 */\t\\\n+      fprintf (FILE, \"\\tmtctr %s\\n\", r0);\t\t/* offset 36 */\t\\\n+      fprintf (FILE, \"\\tbctr\\n\");\t\t\t/* offset 40 */\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#undef\tTRAMPOLINE_SIZE\n+#define TRAMPOLINE_SIZE    (TARGET_64BIT ? 52 : 44)\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+#undef\tINITIALIZE_TRAMPOLINE\n+#define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, CXT)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  rtx reg = gen_reg_rtx (Pmode);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (reg, FNADDR);\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, Pmode,\t\t\t\t\t\\\n+\t\t\t   plus_constant (ADDR, 8)),\t\t\t\\\n+\t\t  reg);\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, Pmode,\t\t\t\t\t\\\n+\t\t\t   plus_constant (ADDR, (TARGET_64BIT ? 16 : 12))), \\\n+\t\t  CXT);\t\t\t\t\t\t\t\\\n+  emit_insn (gen_sync (gen_rtx (MEM, BLKmode, ADDR)));\t\t\t\\\n+}\n \n+\f\n #undef CPP_PREDEFINES\n #define CPP_PREDEFINES \\\n   \"-DPPC -Dunix -D__svr4__ -Asystem(unix) -Asystem(svr4) -Acpu(powerpc) -Amachine(powerpc)\"\n@@ -382,6 +464,8 @@ while (0)\n #define CPP_SPEC \"\\\n %{posix: -D_POSIX_SOURCE} \\\n %{mrelocatable: -D_RELOCATABLE} \\\n+%{mcall-sysv: -D_CALL_SYSV} %{mcall-aix: -D_CALL_AIX} %{!mcall-sysv: %{!mcall-aix: -D_CALL_SYSV}} \\\n+%{msoft-float: -D_SOFT_FLOAT} %{mcpu=403: -D_SOFT_FLOAT} \\\n %{mlittle: -D_LITTLE_ENDIAN -Amachine(littleendian)} \\\n %{mlittle-endian: -D_LITTLE_ENDIAN -Amachine(littleendian)} \\\n %{!mlittle: %{!mlittle-endian: -D_BIG_ENDIAN -Amachine(bigendian)}} \\"}, {"sha": "59bd1b72c83b08e8ab08caf5b16efadbdf108819", "filename": "gcc/config/rs6000/sysv4le.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Fsysv4le.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Fsysv4le.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4le.h?ref=4697a36cef9b136c6eccca9c0e23f3e653f0bd99", "patch": "@@ -29,6 +29,8 @@ Boston, MA 02111-1307, USA.  */\n #define CPP_SPEC \"\\\n %{posix: -D_POSIX_SOURCE} \\\n %{mrelocatable: -D_RELOCATABLE} \\\n+%{mcall-sysv: -D_CALL_SYSV} %{mcall-aix: -D_CALL_AIX} %{!mcall-sysv: %{!mcall-aix: -D_CALL_SYSV}} \\\n+%{msoft-float: -D_SOFT_FLOAT} %{mcpu=403: -D_SOFT_FLOAT} \\\n %{mbig: -D_BIG_ENDIAN -Amachine(bigendian)} \\\n %{mbig-endian: -D_BIG_ENDIAN -Amachine(bigendian)} \\\n %{!mbig: %{!mbig-endian: -D_LITTLE_ENDIAN -Amachine(littleendian)}} \\"}, {"sha": "db4b936dcbff4cd651324212119d0a59d36eb049", "filename": "gcc/config/rs6000/t-ppcgas", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Ft-ppcgas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Ft-ppcgas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-ppcgas?ref=4697a36cef9b136c6eccca9c0e23f3e653f0bd99", "patch": "@@ -16,15 +16,12 @@ fp-bit.c: $(srcdir)/config/fp-bit.c\n # Build libgcc.a with different options.\n \n MULTILIB_OPTIONS\t= msoft-float \\\n-\t\t\t  mno-toc \\\n-\t\t\t  mlittle/mbig\n+\t\t\t  mlittle\n \n MULTILIB_DIRNAMES\t= soft-float \\\n-\t\t\t  no-toc \\\n-\t\t\t  little-endian big-endian\n+\t\t\t  little-endian\n \n MULTILIB_MATCHES\t= mlittle=mlittle-endian \\\n-\t\t\t  mbig=mbig-endian \\\n \t\t\t  msoft-float=mcpu?403 \\\n \t\t\t  msoft-float=mcpu?mpc403 \\\n \t\t\t  msoft-float=mcpu?ppc403"}, {"sha": "382d15b797533497c365610ae5cd82c5f6966d83", "filename": "gcc/config/rs6000/t-rs6000", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4697a36cef9b136c6eccca9c0e23f3e653f0bd99/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-rs6000?ref=4697a36cef9b136c6eccca9c0e23f3e653f0bd99", "patch": "@@ -15,8 +15,8 @@ fp-bit.c: $(srcdir)/config/fp-bit.c\n \n # Build the libraries for both hard and soft floating point\n \n-MULTILIB_OPTIONS = msoft-float\n-MULTILIB_DIRNAMES = soft-float\n+MULTILIB_OPTIONS = msoft-float mcpu=common\n+MULTILIB_DIRNAMES = soft-float common\n \n LIBGCC = stmp-multilib\n INSTALL_LIBGCC = install-multilib"}]}