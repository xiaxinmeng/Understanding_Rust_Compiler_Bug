{"sha": "f1f862aec2c3b93dbd6adfc35b0e1b6034e59c21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFmODYyYWVjMmMzYjkzZGJkNmFkZmMzNWIwZTFiNjAzNGU1OWMyMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-05-26T07:35:21Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-05-26T07:35:21Z"}, "message": "openmp: Ensure copy ctor for composite distribute parallel for class iterators is instantiated [PR95197]\n\nDuring gimplification omp_finish_clause langhook is called in several places\nto add the language specific info to the clause like what default/copy ctors,\ndtors and assignment operators should be used.\n\nUnfortunately, if it refers to some not yet instantiated method, during\ngimplification it is too late and the methods will not be instantiated\nanymore.  For other cases, the genericizer has code to detect those and\ninstantiate whatever is needed, this change adds the same for\ndistribute parallel for class iterators where we under the hood need\na copy constructor for the iterator to implement it.\n\n2020-05-26  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/95197\n\t* gimplify.c (find_combined_omp_for): Move to omp-general.c.\n\t* omp-general.h (find_combined_omp_for): Declare.\n\t* omp-general.c: Include tree-iterator.h.\n\t(find_combined_omp_for): New function, moved from gimplify.c.\n\n\t* cp-gimplify.c: Include omp-general.h.\n\t(cp_genericize_r) <case OMP_DISTRIBUTE>: For class iteration\n\tvariables in composite distribute parallel for, instantiate copy\n\tctor of their types.", "tree": {"sha": "17585550346141aee0230a55878d86d63504b279", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17585550346141aee0230a55878d86d63504b279"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1f862aec2c3b93dbd6adfc35b0e1b6034e59c21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1f862aec2c3b93dbd6adfc35b0e1b6034e59c21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1f862aec2c3b93dbd6adfc35b0e1b6034e59c21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1f862aec2c3b93dbd6adfc35b0e1b6034e59c21/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c7f8cbcc7f77d6956624f2bb455c33f253524fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c7f8cbcc7f77d6956624f2bb455c33f253524fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c7f8cbcc7f77d6956624f2bb455c33f253524fd"}], "stats": {"total": 177, "additions": 120, "deletions": 57}, "files": [{"sha": "53d715dcd89e9ed135c4c7edfd39b0cb359fe946", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f862aec2c3b93dbd6adfc35b0e1b6034e59c21/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f862aec2c3b93dbd6adfc35b0e1b6034e59c21/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=f1f862aec2c3b93dbd6adfc35b0e1b6034e59c21", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"output.h\"\n #include \"file-prefix-map.h\"\n #include \"cgraph.h\"\n+#include \"omp-general.h\"\n \n /* Forward declarations.  */\n \n@@ -1650,9 +1651,70 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n       *stmt_p = genericize_spaceship (*stmt_p);\n       break;\n \n+    case OMP_DISTRIBUTE:\n+      /* Need to explicitly instantiate copy ctors on class iterators of\n+\t composite distribute parallel for.  */\n+      if (OMP_FOR_INIT (*stmt_p) == NULL_TREE)\n+\t{\n+\t  tree *data[4] = { NULL, NULL, NULL, NULL };\n+\t  tree inner = walk_tree (&OMP_FOR_BODY (*stmt_p),\n+\t\t\t\t  find_combined_omp_for, data, NULL);\n+\t  if (inner != NULL_TREE\n+\t      && TREE_CODE (inner) == OMP_FOR)\n+\t    {\n+\t      for (int i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (inner)); i++)\n+\t\tif (OMP_FOR_ORIG_DECLS (inner)\n+\t\t    && TREE_CODE (TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (inner),\n+\t\t\t\t  i)) == TREE_LIST\n+\t\t    && TREE_PURPOSE (TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (inner),\n+\t\t\t\t     i)))\n+\t\t  {\n+\t\t    tree orig = TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (inner), i);\n+\t\t    /* Class iterators aren't allowed on OMP_SIMD, so the only\n+\t\t       case we need to solve is distribute parallel for.  */\n+\t\t    gcc_assert (TREE_CODE (inner) == OMP_FOR\n+\t\t\t\t&& data[1]);\n+\t\t    tree orig_decl = TREE_PURPOSE (orig);\n+\t\t    tree c, cl = NULL_TREE;\n+\t\t    for (c = OMP_FOR_CLAUSES (inner);\n+\t\t\t c; c = OMP_CLAUSE_CHAIN (c))\n+\t\t      if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_PRIVATE\n+\t\t\t   || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE)\n+\t\t\t  && OMP_CLAUSE_DECL (c) == orig_decl)\n+\t\t\t{\n+\t\t\t  cl = c;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    if (cl == NULL_TREE)\n+\t\t      {\n+\t\t\tfor (c = OMP_PARALLEL_CLAUSES (*data[1]);\n+\t\t\t     c; c = OMP_CLAUSE_CHAIN (c))\n+\t\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_PRIVATE\n+\t\t\t      && OMP_CLAUSE_DECL (c) == orig_decl)\n+\t\t\t    {\n+\t\t\t      cl = c;\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t      }\n+\t\t    if (cl)\n+\t\t      {\n+\t\t\torig_decl = require_complete_type (orig_decl);\n+\t\t\ttree inner_type = TREE_TYPE (orig_decl);\n+\t\t\tif (orig_decl == error_mark_node)\n+\t\t\t  continue;\n+\t\t\tif (TYPE_REF_P (TREE_TYPE (orig_decl)))\n+\t\t\t  inner_type = TREE_TYPE (inner_type);\n+\n+\t\t\twhile (TREE_CODE (inner_type) == ARRAY_TYPE)\n+\t\t\t  inner_type = TREE_TYPE (inner_type);\n+\t\t\tget_copy_ctor (inner_type, tf_warning_or_error);\n+\t\t      }\n+\t\t}\n+\t    }\n+\t}\n+      /* FALLTHRU */\n     case OMP_FOR:\n     case OMP_SIMD:\n-    case OMP_DISTRIBUTE:\n     case OMP_LOOP:\n     case OACC_LOOP:\n       genericize_omp_for_stmt (stmt_p, walk_subtrees, data);"}, {"sha": "7f00d97baa1d698b99cd1f213af985edb64aca3d", "filename": "gcc/gimplify.c", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f862aec2c3b93dbd6adfc35b0e1b6034e59c21/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f862aec2c3b93dbd6adfc35b0e1b6034e59c21/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=f1f862aec2c3b93dbd6adfc35b0e1b6034e59c21", "patch": "@@ -10963,62 +10963,6 @@ gimplify_omp_task (tree *expr_p, gimple_seq *pre_p)\n   *expr_p = NULL_TREE;\n }\n \n-/* Helper function of gimplify_omp_for, find OMP_FOR resp. OMP_SIMD\n-   with non-NULL OMP_FOR_INIT.  Also, fill in pdata array,\n-   pdata[0] non-NULL if there is anything non-trivial in between, pdata[1]\n-   is address of OMP_PARALLEL in between if any, pdata[2] is address of\n-   OMP_FOR in between if any and pdata[3] is address of the inner\n-   OMP_FOR/OMP_SIMD.  */\n-\n-static tree\n-find_combined_omp_for (tree *tp, int *walk_subtrees, void *data)\n-{\n-  tree **pdata = (tree **) data;\n-  *walk_subtrees = 0;\n-  switch (TREE_CODE (*tp))\n-    {\n-    case OMP_FOR:\n-      if (OMP_FOR_INIT (*tp) != NULL_TREE)\n-\t{\n-\t  pdata[3] = tp;\n-\t  return *tp;\n-\t}\n-      pdata[2] = tp;\n-      *walk_subtrees = 1;\n-      break;\n-    case OMP_SIMD:\n-      if (OMP_FOR_INIT (*tp) != NULL_TREE)\n-\t{\n-\t  pdata[3] = tp;\n-\t  return *tp;\n-\t}\n-      break;\n-    case BIND_EXPR:\n-      if (BIND_EXPR_VARS (*tp)\n-\t  || (BIND_EXPR_BLOCK (*tp)\n-\t      && BLOCK_VARS (BIND_EXPR_BLOCK (*tp))))\n-\tpdata[0] = tp;\n-      *walk_subtrees = 1;\n-      break;\n-    case STATEMENT_LIST:\n-      if (!tsi_one_before_end_p (tsi_start (*tp)))\n-\tpdata[0] = tp;\n-      *walk_subtrees = 1;\n-      break;\n-    case TRY_FINALLY_EXPR:\n-      pdata[0] = tp;\n-      *walk_subtrees = 1;\n-      break;\n-    case OMP_PARALLEL:\n-      pdata[1] = tp;\n-      *walk_subtrees = 1;\n-      break;\n-    default:\n-      break;\n-    }\n-  return NULL_TREE;\n-}\n-\n /* Gimplify the gross structure of an OMP_FOR statement.  */\n \n static enum gimplify_status"}, {"sha": "1a2e71ecf8cbe3aad1f01d6a6bbf80755f9c3ace", "filename": "gcc/omp-general.c", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f862aec2c3b93dbd6adfc35b0e1b6034e59c21/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f862aec2c3b93dbd6adfc35b0e1b6034e59c21/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=f1f862aec2c3b93dbd6adfc35b0e1b6034e59c21", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hsa-common.h\"\n #include \"tree-pass.h\"\n #include \"omp-device-properties.h\"\n+#include \"tree-iterator.h\"\n \n enum omp_requires omp_requires_mask;\n \n@@ -504,6 +505,61 @@ omp_build_barrier (tree lhs)\n   return g;\n }\n \n+/* Find OMP_FOR resp. OMP_SIMD with non-NULL OMP_FOR_INIT.  Also, fill in pdata\n+   array, pdata[0] non-NULL if there is anything non-trivial in between,\n+   pdata[1] is address of OMP_PARALLEL in between if any, pdata[2] is address\n+   of OMP_FOR in between if any and pdata[3] is address of the inner\n+   OMP_FOR/OMP_SIMD.  */\n+\n+tree\n+find_combined_omp_for (tree *tp, int *walk_subtrees, void *data)\n+{\n+  tree **pdata = (tree **) data;\n+  *walk_subtrees = 0;\n+  switch (TREE_CODE (*tp))\n+    {\n+    case OMP_FOR:\n+      if (OMP_FOR_INIT (*tp) != NULL_TREE)\n+\t{\n+\t  pdata[3] = tp;\n+\t  return *tp;\n+\t}\n+      pdata[2] = tp;\n+      *walk_subtrees = 1;\n+      break;\n+    case OMP_SIMD:\n+      if (OMP_FOR_INIT (*tp) != NULL_TREE)\n+\t{\n+\t  pdata[3] = tp;\n+\t  return *tp;\n+\t}\n+      break;\n+    case BIND_EXPR:\n+      if (BIND_EXPR_VARS (*tp)\n+\t  || (BIND_EXPR_BLOCK (*tp)\n+\t      && BLOCK_VARS (BIND_EXPR_BLOCK (*tp))))\n+\tpdata[0] = tp;\n+      *walk_subtrees = 1;\n+      break;\n+    case STATEMENT_LIST:\n+      if (!tsi_one_before_end_p (tsi_start (*tp)))\n+\tpdata[0] = tp;\n+      *walk_subtrees = 1;\n+      break;\n+    case TRY_FINALLY_EXPR:\n+      pdata[0] = tp;\n+      *walk_subtrees = 1;\n+      break;\n+    case OMP_PARALLEL:\n+      pdata[1] = tp;\n+      *walk_subtrees = 1;\n+      break;\n+    default:\n+      break;\n+    }\n+  return NULL_TREE;\n+}\n+\n /* Return maximum possible vectorization factor for the target.  */\n \n poly_uint64"}, {"sha": "ad28b2b7970f13d789b9baed3d072b7207cf9310", "filename": "gcc/omp-general.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f862aec2c3b93dbd6adfc35b0e1b6034e59c21/gcc%2Fomp-general.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f862aec2c3b93dbd6adfc35b0e1b6034e59c21/gcc%2Fomp-general.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.h?ref=f1f862aec2c3b93dbd6adfc35b0e1b6034e59c21", "patch": "@@ -82,6 +82,7 @@ extern tree omp_get_for_step_from_incr (location_t loc, tree incr);\n extern void omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \t\t\t\t  struct omp_for_data_loop *loops);\n extern gimple *omp_build_barrier (tree lhs);\n+extern tree find_combined_omp_for (tree *, int *, void *);\n extern poly_uint64 omp_max_vf (void);\n extern int omp_max_simt_vf (void);\n extern int omp_constructor_traits_to_codes (tree, enum tree_code *);"}]}