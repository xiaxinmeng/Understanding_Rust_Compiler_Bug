{"sha": "07045266050a099eba38651b6c56730b9674e3be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDcwNDUyNjYwNTBhMDk5ZWJhMzg2NTFiNmM1NjczMGI5Njc0ZTNiZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2007-10-18T17:34:31Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-10-18T17:34:31Z"}, "message": "mips.h (set_volatile): Delete.\n\ngcc/\n\t* config/mips/mips.h (set_volatile): Delete.\n\t* config/mips/mips.c (set_volatile): Delete.\n\t(mips_print_operand_punctuation): New function, split out from\n\tprint_operand.  Remove '%{', '%}', '%~', '%&' and '%!'.\n\tUse the same character ordering in the code and the comments.\n\tUse a recursive call to handle '*'.  Abort on unknown characters.\n\t(mips_init_print_operand_punct): New function, split out from\n\toverride_options.\n\t(mips_print_int_branch_condition): New function, split out from\n\tprint_operand.  Use GET_RTX_NAME.  Use output_operand_lossage\n\tto report unexpected codes.\n\t(mips_print_float_branch_condition): New function, split out from\n\tprint_operand.  Use output_operand_lossage to report unexpected codes.\n\t(print_operand): Rework to use a case statement.  Use the\n\tsame letter ordering in the code and the comments.  Use\n\toutput_operand_lossage to report unexpected codes and\n\treverse_condition to handle inverted branch conditions.\n\t(override_options): Use mips_init_print_operand_punct.\n\nFrom-SVN: r129453", "tree": {"sha": "65fb460e83c2ffe60bf5a77b4a51017757030422", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65fb460e83c2ffe60bf5a77b4a51017757030422"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07045266050a099eba38651b6c56730b9674e3be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07045266050a099eba38651b6c56730b9674e3be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07045266050a099eba38651b6c56730b9674e3be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07045266050a099eba38651b6c56730b9674e3be/comments", "author": null, "committer": null, "parents": [{"sha": "ab77a036ff36a414ba6c54d03216d03cf0797591", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab77a036ff36a414ba6c54d03216d03cf0797591", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab77a036ff36a414ba6c54d03216d03cf0797591"}], "stats": {"total": 604, "additions": 294, "deletions": 310}, "files": [{"sha": "dcb51c5aa430dd488977da9cdb604491150dad6f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07045266050a099eba38651b6c56730b9674e3be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07045266050a099eba38651b6c56730b9674e3be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07045266050a099eba38651b6c56730b9674e3be", "patch": "@@ -1,3 +1,24 @@\n+2007-10-18  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\t* config/mips/mips.h (set_volatile): Delete.\n+\t* config/mips/mips.c (set_volatile): Delete.\n+\t(mips_print_operand_punctuation): New function, split out from\n+\tprint_operand.  Remove '%{', '%}', '%~', '%&' and '%!'.\n+\tUse the same character ordering in the code and the comments.\n+\tUse a recursive call to handle '*'.  Abort on unknown characters.\n+\t(mips_init_print_operand_punct): New function, split out from\n+\toverride_options.\n+\t(mips_print_int_branch_condition): New function, split out from\n+\tprint_operand.  Use GET_RTX_NAME.  Use output_operand_lossage\n+\tto report unexpected codes.\n+\t(mips_print_float_branch_condition): New function, split out from\n+\tprint_operand.  Use output_operand_lossage to report unexpected codes.\n+\t(print_operand): Rework to use a case statement.  Use the\n+\tsame letter ordering in the code and the comments.  Use\n+\toutput_operand_lossage to report unexpected codes and\n+\treverse_condition to handle inverted branch conditions.\n+\t(override_options): Use mips_init_print_operand_punct.\n+\n 2007-10-18  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* config/mips/mips.h: Move variable declarations to end of file and"}, {"sha": "3e690098a1061395ebd449dd4a188e7f17f4aaf9", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 273, "deletions": 309, "changes": 582, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07045266050a099eba38651b6c56730b9674e3be/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07045266050a099eba38651b6c56730b9674e3be/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=07045266050a099eba38651b6c56730b9674e3be", "patch": "@@ -446,7 +446,6 @@ int mips_dwarf_regno[FIRST_PSEUDO_REGISTER];\n int set_noreorder;\n int set_noat;\n int set_nomacro;\n-int set_volatile;\n \n /* The next branch instruction is a branch likely, not branch normal.  */\n int mips_branch_likely;\n@@ -6287,358 +6286,344 @@ print_operand_reloc (FILE *file, rtx op, enum mips_symbol_context context,\n       fputc (')', file);\n }\n \n-/* Implement the PRINT_OPERAND macro.  The MIPS-specific operand codes are:\n-\n-   'X'  OP is CONST_INT, prints 32 bits in hexadecimal format = \"0x%08x\",\n-   'x'  OP is CONST_INT, prints 16 bits in hexadecimal format = \"0x%04x\",\n-   'h'  OP is HIGH, prints %hi(X),\n-   'd'  output integer constant in decimal,\n-   'z'\tif the operand is 0, use $0 instead of normal operand.\n-   'D'  print second part of double-word register or memory operand.\n-   'L'  print low-order register of double-word register operand.\n-   'M'  print high-order register of double-word register operand.\n-   'C'  print part of opcode for a branch condition.\n-   'F'  print part of opcode for a floating-point branch condition.\n-   'N'  print part of opcode for a branch condition, inverted.\n-   'W'  print part of opcode for a floating-point branch condition, inverted.\n-   'T'  print 'f' for (eq:CC ...), 't' for (ne:CC ...),\n-\t      'z' for (eq:?I ...), 'n' for (ne:?I ...).\n-   't'  like 'T', but with the EQ/NE cases reversed\n-   'Y'  for a CONST_INT X, print mips_fp_conditions[X]\n-   'Z'  print the operand and a comma for ISA_HAS_8CC, otherwise print nothing\n-   'R'  print the reloc associated with LO_SUM\n-   'q'  print DSP accumulator registers\n-\n+/* Print the text for PRINT_OPERAND punctation character CH to FILE.\n    The punctuation characters are:\n \n-   '('\tTurn on .set noreorder\n-   ')'\tTurn on .set reorder\n-   '['\tTurn on .set noat\n-   ']'\tTurn on .set at\n-   '<'\tTurn on .set nomacro\n-   '>'\tTurn on .set macro\n-   '{'\tTurn on .set volatile (not GAS)\n-   '}'\tTurn on .set novolatile (not GAS)\n-   '&'\tTurn on .set noreorder if filling delay slots\n-   '*'\tTurn on both .set noreorder and .set nomacro if filling delay slots\n-   '!'\tTurn on .set nomacro if filling delay slots\n-   '#'\tPrint nop if in a .set noreorder section.\n-   '/'\tLike '#', but does nothing within a delayed branch sequence\n-   '?'\tPrint 'l' if we are to use a branch likely instead of normal branch.\n-   '@'\tPrint the name of the assembler temporary register (at or $1).\n+   '('\tStart a nested \".set noreorder\" block.\n+   ')'\tEnd a nested \".set noreorder\" block.\n+   '['\tStart a nested \".set noat\" block.\n+   ']'\tEnd a nested \".set noat\" block.\n+   '<'\tStart a nested \".set nomacro\" block.\n+   '>'\tEnd a nested \".set nomacro\" block.\n+   '*'\tBehave like %(%< if generating a delayed-branch sequence.\n+   '#'\tPrint a nop if in a \".set noreorder\" block.\n+   '/'\tLike '#', but do nothing within a delayed-branch sequence.\n+   '?'\tPrint \"l\" if mips_branch_likely is true\n    '.'\tPrint the name of the register with a hard-wired zero (zero or $0).\n+   '@'\tPrint the name of the assembler temporary register (at or $1).\n    '^'\tPrint the name of the pic call-through register (t9 or $25).\n-   '$'\tPrint the name of the stack pointer register (sp or $29).\n    '+'\tPrint the name of the gp register (usually gp or $28).\n-   '~'\tOutput a branch alignment to LABEL_ALIGN(NULL).\n-   '|'  Print .set push; .set mips2 if !ISA_HAS_LL_SC.\n-   '-'  Print .set pop under the same conditions for '|'.  */\n+   '$'\tPrint the name of the stack pointer register (sp or $29).\n+   '|'\tPrint \".set push; .set mips2\" if !ISA_HAS_LL_SC.\n+   '-'\tPrint \".set pop\" under the same conditions for '|'.\n \n-void\n-print_operand (FILE *file, rtx op, int letter)\n-{\n-  register enum rtx_code code;\n+   See also mips_init_print_operand_pucnt.  */\n \n-  if (PRINT_OPERAND_PUNCT_VALID_P (letter))\n+static void\n+mips_print_operand_punctuation (FILE *file, int ch)\n+{\n+  switch (ch)\n     {\n-      switch (letter)\n-\t{\n-\tcase '?':\n-\t  if (mips_branch_likely)\n-\t    putc ('l', file);\n-\t  break;\n+    case '(':\n+      if (set_noreorder++ == 0)\n+\tfputs (\".set\\tnoreorder\\n\\t\", file);\n+      break;\n \n-\tcase '@':\n-\t  fputs (reg_names [GP_REG_FIRST + 1], file);\n-\t  break;\n+    case ')':\n+      gcc_assert (set_noreorder > 0);\n+      if (--set_noreorder == 0)\n+\tfputs (\"\\n\\t.set\\treorder\", file);\n+      break;\n \n-\tcase '^':\n-\t  fputs (reg_names [PIC_FUNCTION_ADDR_REGNUM], file);\n-\t  break;\n+    case '[':\n+      if (set_noat++ == 0)\n+\tfputs (\".set\\tnoat\\n\\t\", file);\n+      break;\n \n-\tcase '.':\n-\t  fputs (reg_names [GP_REG_FIRST + 0], file);\n-\t  break;\n+    case ']':\n+      gcc_assert (set_noat > 0);\n+      if (--set_noat == 0)\n+\tfputs (\"\\n\\t.set\\tat\", file);\n+      break;\n \n-\tcase '$':\n-\t  fputs (reg_names[STACK_POINTER_REGNUM], file);\n-\t  break;\n+    case '<':\n+      if (set_nomacro++ == 0)\n+\tfputs (\".set\\tnomacro\\n\\t\", file);\n+      break;\n \n-\tcase '+':\n-\t  fputs (reg_names[PIC_OFFSET_TABLE_REGNUM], file);\n-\t  break;\n+    case '>':\n+      gcc_assert (set_nomacro > 0);\n+      if (--set_nomacro == 0)\n+\tfputs (\"\\n\\t.set\\tmacro\", file);\n+      break;\n \n-\tcase '&':\n-\t  if (final_sequence != 0 && set_noreorder++ == 0)\n-\t    fputs (\".set\\tnoreorder\\n\\t\", file);\n-\t  break;\n+    case '*':\n+      if (final_sequence != 0)\n+\t{\n+\t  mips_print_operand_punctuation (file, '(');\n+\t  mips_print_operand_punctuation (file, '<');\n+\t}\n+      break;\n \n-\tcase '*':\n-\t  if (final_sequence != 0)\n-\t    {\n-\t      if (set_noreorder++ == 0)\n-\t\tfputs (\".set\\tnoreorder\\n\\t\", file);\n+    case '#':\n+      if (set_noreorder != 0)\n+\tfputs (\"\\n\\tnop\", file);\n+      break;\n \n-\t      if (set_nomacro++ == 0)\n-\t\tfputs (\".set\\tnomacro\\n\\t\", file);\n-\t    }\n-\t  break;\n+    case '/':\n+      /* Print an extra newline so that the delayed insn is separated\n+\t from the following ones.  This looks neater and is consistent\n+\t with non-nop delayed sequences.  */\n+      if (set_noreorder != 0 && final_sequence == 0)\n+\tfputs (\"\\n\\tnop\\n\", file);\n+      break;\n \n-\tcase '!':\n-\t  if (final_sequence != 0 && set_nomacro++ == 0)\n-\t    fputs (\"\\n\\t.set\\tnomacro\", file);\n-\t  break;\n+    case '?':\n+      if (mips_branch_likely)\n+\tputc ('l', file);\n+      break;\n \n-\tcase '#':\n-\t  if (set_noreorder != 0)\n-\t    fputs (\"\\n\\tnop\", file);\n-\t  break;\n+    case '.':\n+      fputs (reg_names[GP_REG_FIRST + 0], file);\n+      break;\n \n-\tcase '/':\n-\t  /* Print an extra newline so that the delayed insn is separated\n-\t     from the following ones.  This looks neater and is consistent\n-\t     with non-nop delayed sequences.  */\n-\t  if (set_noreorder != 0 && final_sequence == 0)\n-\t    fputs (\"\\n\\tnop\\n\", file);\n-\t  break;\n+    case '@':\n+      fputs (reg_names[GP_REG_FIRST + 1], file);\n+      break;\n \n-\tcase '(':\n-\t  if (set_noreorder++ == 0)\n-\t    fputs (\".set\\tnoreorder\\n\\t\", file);\n-\t  break;\n+    case '^':\n+      fputs (reg_names[PIC_FUNCTION_ADDR_REGNUM], file);\n+      break;\n \n-\tcase ')':\n-\t  if (set_noreorder == 0)\n-\t    error (\"internal error: %%) found without a %%( in assembler pattern\");\n+    case '+':\n+      fputs (reg_names[PIC_OFFSET_TABLE_REGNUM], file);\n+      break;\n \n-\t  else if (--set_noreorder == 0)\n-\t    fputs (\"\\n\\t.set\\treorder\", file);\n+    case '$':\n+      fputs (reg_names[STACK_POINTER_REGNUM], file);\n+      break;\n \n-\t  break;\n+    case '|':\n+      if (!ISA_HAS_LL_SC)\n+\tfputs (\".set\\tpush\\n\\t.set\\tmips2\\n\\t\", file);\n+      break;\n \n-\tcase '[':\n-\t  if (set_noat++ == 0)\n-\t    fputs (\".set\\tnoat\\n\\t\", file);\n-\t  break;\n+    case '-':\n+      if (!ISA_HAS_LL_SC)\n+\tfputs (\"\\n\\t.set\\tpop\", file);\n+      break;\n \n-\tcase ']':\n-\t  if (set_noat == 0)\n-\t    error (\"internal error: %%] found without a %%[ in assembler pattern\");\n-\t  else if (--set_noat == 0)\n-\t    fputs (\"\\n\\t.set\\tat\", file);\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+}\n \n-\t  break;\n+/* Initialize mips_print_operand_punct.  */\n \n-\tcase '<':\n-\t  if (set_nomacro++ == 0)\n-\t    fputs (\".set\\tnomacro\\n\\t\", file);\n-\t  break;\n+static void\n+mips_init_print_operand_punct (void)\n+{\n+  const char *p;\n \n-\tcase '>':\n-\t  if (set_nomacro == 0)\n-\t    error (\"internal error: %%> found without a %%< in assembler pattern\");\n-\t  else if (--set_nomacro == 0)\n-\t    fputs (\"\\n\\t.set\\tmacro\", file);\n+  for (p = \"()[]<>*#/?.@^+$|-\"; *p; p++)\n+    mips_print_operand_punct[(unsigned char) *p] = true;\n+}\n \n-\t  break;\n+/* PRINT_OPERAND prefix LETTER refers to the integer branch instruction\n+   associated with condition CODE.  Print the condition part of the\n+   opcode to FILE.  */\n \n-\tcase '{':\n-\t  if (set_volatile++ == 0)\n-\t    fputs (\"#.set\\tvolatile\\n\\t\", file);\n-\t  break;\n+static void\n+mips_print_int_branch_condition (FILE *file, enum rtx_code code, int letter)\n+{\n+  switch (code)\n+    {\n+    case EQ:\n+    case NE:\n+    case GT:\n+    case GE:\n+    case LT:\n+    case LE:\n+    case GTU:\n+    case GEU:\n+    case LTU:\n+    case LEU:\n+      /* Conveniently, the MIPS names for these conditions are the same\n+\t as their RTL equivalents.  */\n+      fputs (GET_RTX_NAME (code), file);\n+      break;\n \n-\tcase '}':\n-\t  if (set_volatile == 0)\n-\t    error (\"internal error: %%} found without a %%{ in assembler pattern\");\n-\t  else if (--set_volatile == 0)\n-\t    fputs (\"\\n\\t#.set\\tnovolatile\", file);\n+    default:\n+      output_operand_lossage (\"'%%%c' is not a valid operand prefix\", letter);\n+      break;\n+    }\n+}\n \n-\t  break;\n+/* Likewise floating-point branches.  */\n \n-\tcase '~':\n-\t  {\n-\t    if (align_labels_log > 0)\n-\t      ASM_OUTPUT_ALIGN (file, align_labels_log);\n-\t  }\n-\t  break;\n+static void\n+mips_print_float_branch_condition (FILE *file, enum rtx_code code, int letter)\n+{\n+  switch (code)\n+    {\n+    case EQ:\n+      fputs (\"c1f\", file);\n+      break;\n \n-\tcase '|':\n-\t  if (!ISA_HAS_LL_SC)\n-\t    fputs (\".set\\tpush\\n\\t.set\\tmips2\\n\\t\", file);\n-\t  break;\n+    case NE:\n+      fputs (\"c1t\", file);\n+      break;\n \n-\tcase '-':\n-\t  if (!ISA_HAS_LL_SC)\n-\t    fputs (\"\\n\\t.set\\tpop\", file);\n-\t  break;\n+    default:\n+      output_operand_lossage (\"'%%%c' is not a valid operand prefix\", letter);\n+      break;\n+    }\n+}\n \n-\tdefault:\n-\t  error (\"PRINT_OPERAND: unknown punctuation '%c'\", letter);\n-\t  break;\n-\t}\n+/* Implement the PRINT_OPERAND macro.  The MIPS-specific operand codes are:\n \n-      return;\n-    }\n+   'X'\tPrint CONST_INT OP in hexadecimal format.\n+   'x'\tPrint the low 16 bits of CONST_INT OP in hexadecimal format.\n+   'd'\tPrint CONST_INT OP in decimal.\n+   'h'\tPrint the high-part relocation associated with OP, after stripping\n+\t  any outermost HIGH.\n+   'R'\tPrint the low-part relocation associated with OP.\n+   'C'\tPrint the integer branch condition for comparison OP.\n+   'N'\tPrint the inverse of the integer branch condition for comparison OP.\n+   'F'\tPrint the FPU branch condition for comparison OP.\n+   'W'\tPrint the inverse of the FPU branch condition for comparison OP.\n+   'T'\tPrint 'f' for (eq:CC ...), 't' for (ne:CC ...),\n+\t      'z' for (eq:?I ...), 'n' for (ne:?I ...).\n+   't'\tLike 'T', but with the EQ/NE cases reversed\n+   'Y'\tPrint mips_fp_conditions[INTVAL (OP)]\n+   'Z'\tPrint OP and a comma for ISA_HAS_8CC, otherwise print nothing.\n+   'q'\tPrint a DSP accumulator register.\n+   'D'\tPrint the second part of a double-word register or memory operand.\n+   'L'\tPrint the low-order register in a double-word register operand.\n+   'M'\tPrint high-order register in a double-word register operand.\n+   'z'\tPrint $0 if OP is zero, otherwise print OP normally.  */\n+\n+void\n+print_operand (FILE *file, rtx op, int letter)\n+{\n+  enum rtx_code code;\n \n-  if (! op)\n+  if (PRINT_OPERAND_PUNCT_VALID_P (letter))\n     {\n-      error (\"PRINT_OPERAND null pointer\");\n+      mips_print_operand_punctuation (file, letter);\n       return;\n     }\n \n+  gcc_assert (op);\n   code = GET_CODE (op);\n \n-  if (letter == 'C')\n-    switch (code)\n-      {\n-      case EQ:\tfputs (\"eq\",  file); break;\n-      case NE:\tfputs (\"ne\",  file); break;\n-      case GT:\tfputs (\"gt\",  file); break;\n-      case GE:\tfputs (\"ge\",  file); break;\n-      case LT:\tfputs (\"lt\",  file); break;\n-      case LE:\tfputs (\"le\",  file); break;\n-      case GTU: fputs (\"gtu\", file); break;\n-      case GEU: fputs (\"geu\", file); break;\n-      case LTU: fputs (\"ltu\", file); break;\n-      case LEU: fputs (\"leu\", file); break;\n-      default:\n-\tfatal_insn (\"PRINT_OPERAND, invalid insn for %%C\", op);\n-      }\n-\n-  else if (letter == 'N')\n-    switch (code)\n-      {\n-      case EQ:\tfputs (\"ne\",  file); break;\n-      case NE:\tfputs (\"eq\",  file); break;\n-      case GT:\tfputs (\"le\",  file); break;\n-      case GE:\tfputs (\"lt\",  file); break;\n-      case LT:\tfputs (\"ge\",  file); break;\n-      case LE:\tfputs (\"gt\",  file); break;\n-      case GTU: fputs (\"leu\", file); break;\n-      case GEU: fputs (\"ltu\", file); break;\n-      case LTU: fputs (\"geu\", file); break;\n-      case LEU: fputs (\"gtu\", file); break;\n-      default:\n-\tfatal_insn (\"PRINT_OPERAND, invalid insn for %%N\", op);\n-      }\n+  switch (letter)\n+    {\n+    case 'X':\n+      if (GET_CODE (op) == CONST_INT)\n+\tfprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (op));\n+      else\n+\toutput_operand_lossage (\"invalid use of '%%%c'\", letter);\n+      break;\n \n-  else if (letter == 'F')\n-    switch (code)\n-      {\n-      case EQ: fputs (\"c1f\", file); break;\n-      case NE: fputs (\"c1t\", file); break;\n-      default:\n-\tfatal_insn (\"PRINT_OPERAND, invalid insn for %%F\", op);\n-      }\n+    case 'x':\n+      if (GET_CODE (op) == CONST_INT)\n+\tfprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (op) & 0xffff);\n+      else\n+\toutput_operand_lossage (\"invalid use of '%%%c'\", letter);\n+      break;\n \n-  else if (letter == 'W')\n-    switch (code)\n-      {\n-      case EQ: fputs (\"c1t\", file); break;\n-      case NE: fputs (\"c1f\", file); break;\n-      default:\n-\tfatal_insn (\"PRINT_OPERAND, invalid insn for %%W\", op);\n-      }\n+    case 'd':\n+      if (GET_CODE (op) == CONST_INT)\n+\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (op));\n+      else\n+\toutput_operand_lossage (\"invalid use of '%%%c'\", letter);\n+      break;\n \n-  else if (letter == 'h')\n-    {\n-      if (GET_CODE (op) == HIGH)\n+    case 'h':\n+      if (code == HIGH)\n \top = XEXP (op, 0);\n-\n       print_operand_reloc (file, op, SYMBOL_CONTEXT_LEA, mips_hi_relocs);\n-    }\n+      break;\n+\n+    case 'R':\n+      print_operand_reloc (file, op, SYMBOL_CONTEXT_LEA, mips_lo_relocs);\n+      break;\n \n-  else if (letter == 'R')\n-    print_operand_reloc (file, op, SYMBOL_CONTEXT_LEA, mips_lo_relocs);\n+    case 'C':\n+      mips_print_int_branch_condition (file, code, letter);\n+      break;\n \n-  else if (letter == 'Y')\n-    {\n-      if (GET_CODE (op) == CONST_INT\n-\t  && ((unsigned HOST_WIDE_INT) INTVAL (op)\n-\t      < ARRAY_SIZE (mips_fp_conditions)))\n-\tfputs (mips_fp_conditions[INTVAL (op)], file);\n+    case 'N':\n+      mips_print_int_branch_condition (file, reverse_condition (code), letter);\n+      break;\n+\n+    case 'F':\n+      mips_print_float_branch_condition (file, code, letter);\n+      break;\n+\n+    case 'W':\n+      mips_print_float_branch_condition (file, reverse_condition (code),\n+\t\t\t\t\t letter);\n+      break;\n+\n+    case 'T':\n+    case 't':\n+      {\n+\tint truth = (code == NE) == (letter == 'T');\n+\tfputc (\"zfnt\"[truth * 2 + (GET_MODE (op) == CCmode)], file);\n+      }\n+      break;\n+\n+    case 'Y':\n+      if (code == CONST_INT && UINTVAL (op) < ARRAY_SIZE (mips_fp_conditions))\n+\tfputs (mips_fp_conditions[UINTVAL (op)], file);\n       else\n-\toutput_operand_lossage (\"invalid %%Y value\");\n-    }\n+\toutput_operand_lossage (\"'%%%c' is not a valid operand prefix\",\n+\t\t\t\tletter);\n+      break;\n \n-  else if (letter == 'Z')\n-    {\n+    case 'Z':\n       if (ISA_HAS_8CC)\n \t{\n \t  print_operand (file, op, 0);\n \t  fputc (',', file);\n \t}\n-    }\n-\n-  else if (letter == 'q')\n-    {\n-      int regnum;\n-\n-      if (code != REG)\n-\tfatal_insn (\"PRINT_OPERAND, invalid insn for %%q\", op);\n+      break;\n \n-      regnum = REGNO (op);\n-      if (MD_REG_P (regnum))\n+    case 'q':\n+      if (code == REG && MD_REG_P (REGNO (op)))\n \tfprintf (file, \"$ac0\");\n-      else if (DSP_ACC_REG_P (regnum))\n-\tfprintf (file, \"$ac%c\", reg_names[regnum][3]);\n-      else\n-\tfatal_insn (\"PRINT_OPERAND, invalid insn for %%q\", op);\n-    }\n-\n-  else if (code == REG || code == SUBREG)\n-    {\n-      register int regnum;\n-\n-      if (code == REG)\n-\tregnum = REGNO (op);\n-      else\n-\tregnum = true_regnum (op);\n-\n-      if ((letter == 'M' && ! WORDS_BIG_ENDIAN)\n-\t  || (letter == 'L' && WORDS_BIG_ENDIAN)\n-\t  || letter == 'D')\n-\tregnum++;\n-\n-      fprintf (file, \"%s\", reg_names[regnum]);\n-    }\n-\n-  else if (code == MEM)\n-    {\n-      if (letter == 'D')\n-\toutput_address (plus_constant (XEXP (op, 0), 4));\n+      else if (code == REG && DSP_ACC_REG_P (REGNO (op)))\n+\tfprintf (file, \"$ac%c\", reg_names[REGNO (op)][3]);\n       else\n-\toutput_address (XEXP (op, 0));\n-    }\n-\n-  else if (letter == 'x' && GET_CODE (op) == CONST_INT)\n-    fprintf (file, HOST_WIDE_INT_PRINT_HEX, 0xffff & INTVAL(op));\n-\n-  else if (letter == 'X' && GET_CODE(op) == CONST_INT)\n-    fprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (op));\n-\n-  else if (letter == 'd' && GET_CODE(op) == CONST_INT)\n-    fprintf (file, HOST_WIDE_INT_PRINT_DEC, (INTVAL(op)));\n+\toutput_operand_lossage (\"invalid use of '%%%c'\", letter);\n+      break;\n \n-  else if (letter == 'z' && op == CONST0_RTX (GET_MODE (op)))\n-    fputs (reg_names[GP_REG_FIRST], file);\n+    default:\n+      switch (code)\n+\t{\n+\tcase REG:\n+\t  {\n+\t    unsigned int regno = REGNO (op);\n+\t    if ((letter == 'M' && TARGET_LITTLE_ENDIAN)\n+\t\t|| (letter == 'L' && TARGET_BIG_ENDIAN)\n+\t\t|| letter == 'D')\n+\t      regno++;\n+\t    fprintf (file, \"%s\", reg_names[regno]);\n+\t  }\n+\t  break;\n \n-  else if (letter == 'd' || letter == 'x' || letter == 'X')\n-    output_operand_lossage (\"invalid use of %%d, %%x, or %%X\");\n+\tcase MEM:\n+\t  if (letter == 'D')\n+\t    output_address (plus_constant (XEXP (op, 0), 4));\n+\t  else\n+\t    output_address (XEXP (op, 0));\n+\t  break;\n \n-  else if (letter == 'T' || letter == 't')\n-    {\n-      int truth = (code == NE) == (letter == 'T');\n-      fputc (\"zfnt\"[truth * 2 + (GET_MODE (op) == CCmode)], file);\n+\tdefault:\n+\t  if (letter == 'z' && op == CONST0_RTX (GET_MODE (op)))\n+\t    fputs (reg_names[GP_REG_FIRST], file);\n+\t  else if (CONST_GP_P (op))\n+\t    fputs (reg_names[GLOBAL_POINTER_REGNUM], file);\n+\t  else\n+\t    output_addr_const (file, mips_strip_unspec_address (op));\n+\t  break;\n+\t}\n     }\n-\n-  else if (CONST_GP_P (op))\n-    fputs (reg_names[GLOBAL_POINTER_REGNUM], file);\n-\n-  else\n-    output_addr_const (file, mips_strip_unspec_address (op));\n }\n-\f\n+\n /* Output address operand X to FILE.  */\n \n void\n@@ -12318,28 +12303,7 @@ override_options (void)\n   if (TARGET_DSPR2)\n     target_flags |= MASK_DSP;\n \n-  mips_print_operand_punct['?'] = 1;\n-  mips_print_operand_punct['#'] = 1;\n-  mips_print_operand_punct['/'] = 1;\n-  mips_print_operand_punct['&'] = 1;\n-  mips_print_operand_punct['!'] = 1;\n-  mips_print_operand_punct['*'] = 1;\n-  mips_print_operand_punct['@'] = 1;\n-  mips_print_operand_punct['.'] = 1;\n-  mips_print_operand_punct['('] = 1;\n-  mips_print_operand_punct[')'] = 1;\n-  mips_print_operand_punct['['] = 1;\n-  mips_print_operand_punct[']'] = 1;\n-  mips_print_operand_punct['<'] = 1;\n-  mips_print_operand_punct['>'] = 1;\n-  mips_print_operand_punct['{'] = 1;\n-  mips_print_operand_punct['}'] = 1;\n-  mips_print_operand_punct['^'] = 1;\n-  mips_print_operand_punct['$'] = 1;\n-  mips_print_operand_punct['+'] = 1;\n-  mips_print_operand_punct['~'] = 1;\n-  mips_print_operand_punct['|'] = 1;\n-  mips_print_operand_punct['-'] = 1;\n+  mips_init_print_operand_punct ();\n \n   /* Set up array to map GCC register number to debug register number.\n      Ignore the special purpose register numbers.  */"}, {"sha": "2c401ec6c0cb7133b8571c7792637ed4cde15188", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07045266050a099eba38651b6c56730b9674e3be/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07045266050a099eba38651b6c56730b9674e3be/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=07045266050a099eba38651b6c56730b9674e3be", "patch": "@@ -3070,7 +3070,6 @@ extern int sym_lineno;\t\t\t/* sgi next label # for each stmt */\n extern int set_noreorder;\t\t/* # of nested .set noreorder's  */\n extern int set_nomacro;\t\t\t/* # of nested .set nomacro's  */\n extern int set_noat;\t\t\t/* # of nested .set noat's  */\n-extern int set_volatile;\t\t/* # of nested .set volatile's  */\n extern int mips_branch_likely;\t\t/* emit 'l' after br (branch likely) */\n extern int mips_dbx_regno[];\n extern int mips_dwarf_regno[];"}]}