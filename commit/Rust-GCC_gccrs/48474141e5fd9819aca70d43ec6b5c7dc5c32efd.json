{"sha": "48474141e5fd9819aca70d43ec6b5c7dc5c32efd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg0NzQxNDFlNWZkOTgxOWFjYTcwZDQzZWM2YjVjN2RjNWMzMmVmZA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-01-07T14:14:08Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-01-07T14:14:08Z"}, "message": "re PR fortran/22146 (ICE when calling ELEMENTAL subroutines)\n\n2006-01-07  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/22146\n\t* trans-array.c (gfc_reverse_ss): Remove static attribute.\n\t(gfc_walk_elemental_function_args): Replace gfc_expr * argument for\n\tthe function call with the corresponding gfc_actual_arglist*.  Change\n\tcode accordingly.\n\t(gfc_walk_function_expr): Call to gfc_walk_elemental_function_args\n\tnow requires the actual argument list instead of the expression for\n\tthe function call.\n\t* trans-array.h: Modify the prototype for gfc_walk_elemental_function_args\n\tand provide a prototype for gfc_reverse_ss.\n\t* trans-stmt.h (gfc_trans_call): Add the scalarization code for the case\n\twhere an elemental subroutine has array valued actual arguments.\n\n\tPR fortran/25029\n\tPR fortran/21256\n\tPR fortran/20868\n\tPR fortran/20870\n\t* resolve.c (check_assumed_size_reference): New function to check for upper\n\tbound in assumed size array references.\n\t(resolve_assumed_size_actual): New function to do a very restricted scan\n\tof actual argument expressions of those procedures for which incomplete\n\tassumed size array references are not allowed.\n\t(resolve_function, resolve_call): Switch off assumed size checking of\n\tactual arguments, except for elemental procedures and intrinsic\n\tinquiry functions, in some circumstances.\n\t(resolve_variable): Call check_assumed_size_reference.\n\n2006-01-07  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/22146\n\t* gfortran.dg/elemental_subroutine_1.f90: New test.\n\t* gfortran.dg/elemental_subroutine_2.f90: New test.\n\n\tPR fortran/25029\n\tPR fortran/21256\n\t* gfortran.dg/assumed_size_refs_1.f90: New test.\n\n\tPR fortran/20868\n\tPR fortran/20870\n\t* gfortran.dg/assumed_size_refs_2.f90: New test.\n\t* gfortran.dg/initialization_1.f90: Change warning message.\n\nFrom-SVN: r109449", "tree": {"sha": "8785e3be102d322461d93c74f12f78817c533fe6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8785e3be102d322461d93c74f12f78817c533fe6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48474141e5fd9819aca70d43ec6b5c7dc5c32efd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48474141e5fd9819aca70d43ec6b5c7dc5c32efd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48474141e5fd9819aca70d43ec6b5c7dc5c32efd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/comments", "author": null, "committer": null, "parents": [{"sha": "2784076858a053092d1a712678d89cbb5cbd67ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2784076858a053092d1a712678d89cbb5cbd67ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2784076858a053092d1a712678d89cbb5cbd67ba"}], "stats": {"total": 530, "additions": 503, "deletions": 27}, "files": [{"sha": "9d51fdd4ee4feba2f3a50bb2842486f35af6c54c", "filename": "MAINTAINERS", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=48474141e5fd9819aca70d43ec6b5c7dc5c32efd", "patch": "@@ -331,6 +331,7 @@ Richard Stallman\t\t\t\trms@gnu.org\n Graham Stott\t\t\t\t\tgraham.stott@btinternet.com\n Mike Stump\t\t\t\t\tmrs@apple.com\n Jeff Sturm\t\t\t\t\tjsturm@gcc.gnu.org\n+Paul Thomas\t\t\t\t\tpault@gcc.gnu.org\n Kresten Krab Thorup\t\t\t\tkrab@gcc.gnu.org\n Caroline Tice\t\t\t\t\tctice@apple.com\n Michael Tiemann\t\t\t\t\ttiemann@redhat.com"}, {"sha": "ea086409fe892fca30d0131d7d3cf365b5dabf6a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=48474141e5fd9819aca70d43ec6b5c7dc5c32efd", "patch": "@@ -1,3 +1,32 @@\n+2006-01-07  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/22146\n+\t* trans-array.c (gfc_reverse_ss): Remove static attribute.\n+\t(gfc_walk_elemental_function_args): Replace gfc_expr * argument for\n+\tthe function call with the corresponding gfc_actual_arglist*.  Change\n+\tcode accordingly.\n+\t(gfc_walk_function_expr): Call to gfc_walk_elemental_function_args\n+\tnow requires the actual argument list instead of the expression for\n+\tthe function call.\n+\t* trans-array.h: Modify the prototype for gfc_walk_elemental_function_args\n+\tand provide a prototype for gfc_reverse_ss.\n+\t* trans-stmt.h (gfc_trans_call): Add the scalarization code for the case\n+\twhere an elemental subroutine has array valued actual arguments.\n+\n+\tPR fortran/25029\n+\tPR fortran/21256\n+\tPR fortran/20868\n+\tPR fortran/20870\n+\t* resolve.c (check_assumed_size_reference): New function to check for upper\n+\tbound in assumed size array references.\n+\t(resolve_assumed_size_actual): New function to do a very restricted scan\n+\tof actual argument expressions of those procedures for which incomplete\n+\tassumed size array references are not allowed.\n+\t(resolve_function, resolve_call): Switch off assumed size checking of\n+\tactual arguments, except for elemental procedures and intrinsic\n+\tinquiry functions, in some circumstances.\n+\t(resolve_variable): Call check_assumed_size_reference.\n+\n 2006-01-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/25598"}, {"sha": "5e64bf7ff0d9d4b9338d4b75563e5ff8d08c11d5", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 137, "deletions": 1, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=48474141e5fd9819aca70d43ec6b5c7dc5c32efd", "patch": "@@ -696,6 +696,69 @@ procedure_kind (gfc_symbol * sym)\n   return PTYPE_UNKNOWN;\n }\n \n+/* Check references to assumed size arrays.  The flag need_full_assumed_size\n+   is non-zero when matching actual arguments.  */\n+\n+static int need_full_assumed_size = 0;\n+\n+static bool\n+check_assumed_size_reference (gfc_symbol * sym, gfc_expr * e)\n+{\n+  gfc_ref * ref;\n+  int dim;\n+  int last = 1;\n+\n+  if (need_full_assumed_size\n+\t|| !(sym->as && sym->as->type == AS_ASSUMED_SIZE))\n+      return false;\n+\n+  for (ref = e->ref; ref; ref = ref->next)\n+    if (ref->type == REF_ARRAY)\n+      for (dim = 0; dim < ref->u.ar.as->rank; dim++)\n+\tlast = (ref->u.ar.end[dim] == NULL) && (ref->u.ar.type == DIMEN_ELEMENT);\n+\n+  if (last)\n+    {\n+      gfc_error (\"The upper bound in the last dimension must \"\n+\t\t \"appear in the reference to the assumed size \"\n+\t\t \"array '%s' at %L.\", sym->name, &e->where);\n+      return true;\n+    }\n+  return false;\n+}\n+\n+\n+/* Look for bad assumed size array references in argument expressions\n+  of elemental and array valued intrinsic procedures.  Since this is\n+  called from procedure resolution functions, it only recurses at\n+  operators.  */\n+\n+static bool\n+resolve_assumed_size_actual (gfc_expr *e)\n+{\n+  if (e == NULL)\n+   return false;\n+\n+  switch (e->expr_type)\n+    {\n+    case EXPR_VARIABLE:\n+      if (e->symtree\n+\t    && check_assumed_size_reference (e->symtree->n.sym, e))\n+\treturn true;\n+      break;\n+\n+    case EXPR_OP:\n+      if (resolve_assumed_size_actual (e->value.op.op1)\n+\t    || resolve_assumed_size_actual (e->value.op.op2))\n+\treturn true;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n \n /* Resolve an actual argument list.  Most of the time, this is just\n    resolving the expressions in the list.\n@@ -1092,10 +1155,18 @@ resolve_function (gfc_expr * expr)\n   gfc_actual_arglist *arg;\n   const char *name;\n   try t;\n+  int temp;\n+\n+  /* Switch off assumed size checking and do this again for certain kinds\n+     of procedure, once the procedure itself is resolved.  */\n+  need_full_assumed_size++;\n \n   if (resolve_actual_arglist (expr->value.function.actual) == FAILURE)\n     return FAILURE;\n \n+  /* Resume assumed_size checking. */\n+  need_full_assumed_size--;\n+\n /* See if function is already resolved.  */\n \n   if (expr->value.function.name != NULL)\n@@ -1133,14 +1204,16 @@ resolve_function (gfc_expr * expr)\n   if (expr->expr_type != EXPR_FUNCTION)\n     return t;\n \n+  temp = need_full_assumed_size;\n+  need_full_assumed_size = 0;\n+\n   if (expr->value.function.actual != NULL\n       && ((expr->value.function.esym != NULL\n \t   && expr->value.function.esym->attr.elemental)\n \t  || (expr->value.function.isym != NULL\n \t      && expr->value.function.isym->elemental)))\n     {\n       /* The rank of an elemental is the rank of its array argument(s).  */\n-\n       for (arg = expr->value.function.actual; arg; arg = arg->next)\n \t{\n \t  if (arg->expr != NULL && arg->expr->rank > 0)\n@@ -1149,8 +1222,45 @@ resolve_function (gfc_expr * expr)\n \t      break;\n \t    }\n \t}\n+\n+      /* Being elemental, the last upper bound of an assumed size array\n+\t argument must be present.  */\n+      for (arg = expr->value.function.actual; arg; arg = arg->next)\n+\t{\n+\t  if (arg->expr != NULL\n+\t\t&& arg->expr->rank > 0\n+\t\t&& resolve_assumed_size_actual (arg->expr))\n+\t    return FAILURE;\n+\t}\n     }\n \n+  else if (expr->value.function.actual != NULL\n+      && expr->value.function.isym != NULL\n+      && strcmp (expr->value.function.isym->name, \"lbound\"))\n+    {\n+      /* Array instrinsics must also have the last upper bound of an\n+\t asumed size array argument.  UBOUND and SIZE have to be\n+\t excluded from the check if the second argument is anything\n+\t than a constant.  */\n+      int inquiry;\n+      inquiry = strcmp (expr->value.function.isym->name, \"ubound\") == 0\n+\t\t  || strcmp (expr->value.function.isym->name, \"size\") == 0;\n+\t    \n+      for (arg = expr->value.function.actual; arg; arg = arg->next)\n+\t{\n+\t  if (inquiry && arg->next != NULL && arg->next->expr\n+\t\t&& arg->next->expr->expr_type != EXPR_CONSTANT)\n+\t    break;\n+\t  \n+\t  if (arg->expr != NULL\n+\t\t&& arg->expr->rank > 0\n+\t\t&& resolve_assumed_size_actual (arg->expr))\n+\t    return FAILURE;\n+\t}\n+    }\n+\n+  need_full_assumed_size = temp;\n+\n   if (!pure_function (expr, &name))\n     {\n       if (forall_flag)\n@@ -1400,9 +1510,17 @@ resolve_call (gfc_code * c)\n {\n   try t;\n \n+  /* Switch off assumed size checking and do this again for certain kinds\n+     of procedure, once the procedure itself is resolved.  */\n+  need_full_assumed_size++;\n+\n   if (resolve_actual_arglist (c->ext.actual) == FAILURE)\n     return FAILURE;\n \n+  /* Resume assumed_size checking. */\n+  need_full_assumed_size--;\n+\n+\n   t = SUCCESS;\n   if (c->resolved_sym == NULL)\n     switch (procedure_kind (c->symtree->n.sym))\n@@ -1423,6 +1541,21 @@ resolve_call (gfc_code * c)\n \tgfc_internal_error (\"resolve_subroutine(): bad function type\");\n       }\n \n+  if (c->ext.actual != NULL\n+      && c->symtree->n.sym->attr.elemental)\n+    {\n+      gfc_actual_arglist * a;\n+      /* Being elemental, the last upper bound of an assumed size array\n+\t argument must be present.  */\n+      for (a = c->ext.actual; a; a = a->next)\n+\t{\n+\t  if (a->expr != NULL\n+\t\t&& a->expr->rank > 0\n+\t\t&& resolve_assumed_size_actual (a->expr))\n+\t    return FAILURE;\n+\t}\n+    }\n+\n   if (t == SUCCESS)\n     find_noncopying_intrinsics (c->resolved_sym, c->ext.actual);\n   return t;\n@@ -2349,6 +2482,9 @@ resolve_variable (gfc_expr * e)\n       e->ts = sym->ts;\n     }\n \n+  if (check_assumed_size_reference (sym, e))\n+    return FAILURE;\n+\n   return SUCCESS;\n }\n "}, {"sha": "68bed0a18b3b88e0b1ea3e1a504cc0ac14de71df", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=48474141e5fd9819aca70d43ec6b5c7dc5c32efd", "patch": "@@ -4529,7 +4529,7 @@ gfc_walk_op_expr (gfc_ss * ss, gfc_expr * expr)\n \n /* Reverse a SS chain.  */\n \n-static gfc_ss *\n+gfc_ss *\n gfc_reverse_ss (gfc_ss * ss)\n {\n   gfc_ss *next;\n@@ -4555,10 +4555,9 @@ gfc_reverse_ss (gfc_ss * ss)\n /* Walk the arguments of an elemental function.  */\n \n gfc_ss *\n-gfc_walk_elemental_function_args (gfc_ss * ss, gfc_expr * expr,\n+gfc_walk_elemental_function_args (gfc_ss * ss, gfc_actual_arglist *arg,\n \t\t\t\t  gfc_ss_type type)\n {\n-  gfc_actual_arglist *arg;\n   int scalar;\n   gfc_ss *head;\n   gfc_ss *tail;\n@@ -4567,7 +4566,7 @@ gfc_walk_elemental_function_args (gfc_ss * ss, gfc_expr * expr,\n   head = gfc_ss_terminator;\n   tail = NULL;\n   scalar = 1;\n-  for (arg = expr->value.function.actual; arg; arg = arg->next)\n+  for (; arg; arg = arg->next)\n     {\n       if (!arg->expr)\n \tcontinue;\n@@ -4644,7 +4643,8 @@ gfc_walk_function_expr (gfc_ss * ss, gfc_expr * expr)\n   /* Walk the parameters of an elemental function.  For now we always pass\n      by reference.  */\n   if (sym->attr.elemental)\n-    return gfc_walk_elemental_function_args (ss, expr, GFC_SS_REFERENCE);\n+    return gfc_walk_elemental_function_args (ss, expr->value.function.actual,\n+\t\t\t\t\t     GFC_SS_REFERENCE);\n \n   /* Scalar functions are OK as these are evaluated outside the scalarization\n      loop.  Pass back and let the caller deal with it.  */"}, {"sha": "564e6490a26a73a678c7982f731263a7dc54ec1d", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=48474141e5fd9819aca70d43ec6b5c7dc5c32efd", "patch": "@@ -48,11 +48,14 @@ void gfc_trans_static_array_pointer (gfc_symbol *);\n \n /* Generate scalarization information for an expression.  */\n gfc_ss *gfc_walk_expr (gfc_expr *);\n-/* Walk the arguments of an intrinsic function.  */\n-gfc_ss *gfc_walk_elemental_function_args (gfc_ss *, gfc_expr *, gfc_ss_type);\n+/* Walk the arguments of an elemental function.  */\n+gfc_ss *gfc_walk_elemental_function_args (gfc_ss *, gfc_actual_arglist *,\n+\t\t\t\t\t  gfc_ss_type);\n /* Walk an intrinsic function.  */\n gfc_ss *gfc_walk_intrinsic_function (gfc_ss *, gfc_expr *,\n \t\t\t\t     gfc_intrinsic_sym *);\n+/* Reverse the order of an SS chain.  */\n+gfc_ss *gfc_reverse_ss (gfc_ss *);\n \n /* Free the SS associated with a loop.  */\n void gfc_cleanup_loop (gfc_loopinfo *);"}, {"sha": "699a2947e9346ea8b3e49cc1a94b17670d8ad7ca", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=48474141e5fd9819aca70d43ec6b5c7dc5c32efd", "patch": "@@ -3380,7 +3380,7 @@ gfc_walk_intrinsic_function (gfc_ss * ss, gfc_expr * expr,\n   gcc_assert (isym);\n \n   if (isym->elemental)\n-    return gfc_walk_elemental_function_args (ss, expr, GFC_SS_SCALAR);\n+    return gfc_walk_elemental_function_args (ss, expr->value.function.actual, GFC_SS_SCALAR);\n \n   if (expr->rank == 0)\n     return ss;"}, {"sha": "cf88918b58650e61ebd5d5cf5295942058a99272", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 79, "deletions": 17, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=48474141e5fd9819aca70d43ec6b5c7dc5c32efd", "patch": "@@ -209,6 +209,7 @@ tree\n gfc_trans_call (gfc_code * code)\n {\n   gfc_se se;\n+  gfc_ss * ss;\n   int has_alternate_specifier;\n \n   /* A CALL starts a new block because the actual arguments may have to\n@@ -218,28 +219,81 @@ gfc_trans_call (gfc_code * code)\n \n   gcc_assert (code->resolved_sym);\n \n-  /* Translate the call.  */\n-  has_alternate_specifier\n-    = gfc_conv_function_call (&se, code->resolved_sym, code->ext.actual);\n+  ss = gfc_ss_terminator;\n+  if (code->resolved_sym->attr.elemental)\n+    ss = gfc_walk_elemental_function_args (ss, code->ext.actual, GFC_SS_REFERENCE);\n \n-  /* A subroutine without side-effect, by definition, does nothing!  */\n-  TREE_SIDE_EFFECTS (se.expr) = 1;\n-\n-  /* Chain the pieces together and return the block.  */\n-  if (has_alternate_specifier)\n+  /* Is not an elemental subroutine call with array valued arguments.  */\n+  if (ss == gfc_ss_terminator)\n     {\n-      gfc_code *select_code;\n-      gfc_symbol *sym;\n-      select_code = code->next;\n-      gcc_assert(select_code->op == EXEC_SELECT);\n-      sym = select_code->expr->symtree->n.sym;\n-      se.expr = convert (gfc_typenode_for_spec (&sym->ts), se.expr);\n-      gfc_add_modify_expr (&se.pre, sym->backend_decl, se.expr);\n+\n+      /* Translate the call.  */\n+      has_alternate_specifier\n+\t= gfc_conv_function_call (&se, code->resolved_sym, code->ext.actual);\n+\n+      /* A subroutine without side-effect, by definition, does nothing!  */\n+      TREE_SIDE_EFFECTS (se.expr) = 1;\n+\n+      /* Chain the pieces together and return the block.  */\n+      if (has_alternate_specifier)\n+\t{\n+\t  gfc_code *select_code;\n+\t  gfc_symbol *sym;\n+\t  select_code = code->next;\n+\t  gcc_assert(select_code->op == EXEC_SELECT);\n+\t  sym = select_code->expr->symtree->n.sym;\n+\t  se.expr = convert (gfc_typenode_for_spec (&sym->ts), se.expr);\n+\t  gfc_add_modify_expr (&se.pre, sym->backend_decl, se.expr);\n+\t}\n+      else\n+\tgfc_add_expr_to_block (&se.pre, se.expr);\n+\n+      gfc_add_block_to_block (&se.pre, &se.post);\n     }\n+\n   else\n-    gfc_add_expr_to_block (&se.pre, se.expr);\n+    {\n+      /* An elemental subroutine call with array valued arguments has\n+\t to be scalarized.  */\n+      gfc_loopinfo loop;\n+      stmtblock_t body;\n+      stmtblock_t block;\n+      gfc_se loopse;\n+\n+      /* gfc_walk_elemental_function_args renders the ss chain in the\n+         reverse order to the actual argument order.  */\n+      ss = gfc_reverse_ss (ss);\n+\n+      /* Initialize the loop.  */\n+      gfc_init_se (&loopse, NULL);\n+      gfc_init_loopinfo (&loop);\n+      gfc_add_ss_to_loop (&loop, ss);\n+\n+      gfc_conv_ss_startstride (&loop);\n+      gfc_conv_loop_setup (&loop);\n+      gfc_mark_ss_chain_used (ss, 1);\n+\n+      /* Generate the loop body.  */\n+      gfc_start_scalarized_body (&loop, &body);\n+      gfc_init_block (&block);\n+      gfc_copy_loopinfo_to_se (&loopse, &loop);\n+      loopse.ss = ss;\n+\n+      /* Add the subroutine call to the block.  */\n+      gfc_conv_function_call (&loopse, code->resolved_sym, code->ext.actual);\n+      gfc_add_expr_to_block (&loopse.pre, loopse.expr);\n+\n+      gfc_add_block_to_block (&block, &loopse.pre);\n+      gfc_add_block_to_block (&block, &loopse.post);\n+\n+      /* Finish up the loop block and the loop.  */\n+      gfc_add_expr_to_block (&body, gfc_finish_block (&block));\n+      gfc_trans_scalarizing_loops (&loop, &body);\n+      gfc_add_block_to_block (&se.pre, &loop.pre);\n+      gfc_add_block_to_block (&se.pre, &loop.post);\n+      gfc_cleanup_loop (&loop);\n+    }\n \n-  gfc_add_block_to_block (&se.pre, &se.post);\n   return gfc_finish_block (&se.pre);\n }\n \n@@ -2501,6 +2555,14 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n           gfc_add_expr_to_block (&block, tmp);\n           break;\n \n+\t/* Explicit subroutine calls are prevented by the frontend but interface\n+\t   assignments can legitimately produce them.  */\n+\tcase EXEC_CALL:\n+\t  assign = gfc_trans_call (c);\n+          tmp = gfc_trans_nested_forall_loop (nested_forall_info, assign, 1, 1);\n+          gfc_add_expr_to_block (&block, tmp);\n+          break;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}"}, {"sha": "7a0e309a6b7e30c3c70638f569c536c5ff8f2f3f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=48474141e5fd9819aca70d43ec6b5c7dc5c32efd", "patch": "@@ -1,3 +1,18 @@\n+2006-01-07  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/22146\n+\t* gfortran.dg/elemental_subroutine_1.f90: New test.\n+\t* gfortran.dg/elemental_subroutine_2.f90: New test.\n+\n+\tPR fortran/25029\n+\tPR fortran/21256\n+\t* gfortran.dg/assumed_size_refs_1.f90: New test.\n+\n+\tPR fortran/20868\n+\tPR fortran/20870\n+\t* gfortran.dg/assumed_size_refs_2.f90: New test.\n+\t* gfortran.dg/initialization_1.f90: Change warning message.\n+\n 2005-01-06  Zdenek Dvorak <dvorakz@suse.cz>\n \n \t* gcc.dg/tree-ssa/loop-15.c: New test."}, {"sha": "ff42c02a623e420aedb1d23bddad572d9302736b", "filename": "gcc/testsuite/gfortran.dg/assumed_size_refs_1.f90", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_size_refs_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_size_refs_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_size_refs_1.f90?ref=48474141e5fd9819aca70d43ec6b5c7dc5c32efd", "patch": "@@ -0,0 +1,64 @@\n+!==================assumed_size_refs_1.f90==================\n+! { dg-do compile }\n+! Test the fix for PR25029, PR21256 in which references to\n+! assumed size arrays without an upper bound to the last\n+! dimension were generating no error. The first version of\n+! the patch failed in DHSEQR, as pointed out by Toon Moene\n+! in http://gcc.gnu.org/ml/fortran/2005-12/msg00466.html\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+program assumed_size_test_1\n+  implicit none\n+  real a(2, 4)\n+\n+  a = 1.0\n+  call foo (a)\n+\n+contains\n+  subroutine foo(m)\n+    real, target :: m(1:2, *)\n+    real x(2,2,2)\n+    real, external :: bar\n+    real, pointer :: p(:,:), q(:,:)\n+    allocate (q(2,2))\n+\n+! PR25029\n+    p => m                     ! { dg-error \"upper bound in the last dimension\" }\n+    q = m                      ! { dg-error \"upper bound in the last dimension\" }\n+\n+! PR21256( and PR25060)\n+    m = 1                      ! { dg-error \"upper bound in the last dimension\" }\n+\n+    m(1,1) = 2.0\n+    x = bar (m)\n+    x = fcn (m)                ! { dg-error \"upper bound in the last dimension\" }\n+    m(:, 1:2) = fcn (q)\n+    call sub (m, x)            ! { dg-error \"upper bound in the last dimension\" }\n+    call sub (m(1:2, 1:2), x)\n+    print *, p\n+\n+    call DHSEQR(x)\n+\n+  end subroutine foo\n+\n+  elemental function fcn (a) result (b)\n+    real, intent(in) :: a\n+    real :: b\n+    b = 2.0 * a\n+  end function fcn\n+\n+  elemental subroutine sub (a, b)\n+    real, intent(inout) :: a, b\n+    b = 2.0 * a\n+  end subroutine sub\n+  \n+  SUBROUTINE DHSEQR( WORK )\n+    REAL WORK( * )\n+    EXTERNAL           DLARFX\n+    INTRINSIC          MIN\n+    WORK( 1 ) = 1.0\n+    CALL DLARFX( MIN( 1, 8 ), WORK )\n+  END SUBROUTINE DHSEQR\n+\n+end program assumed_size_test_1"}, {"sha": "8eb708d4989804406a8be36ad298081ac8af4358", "filename": "gcc/testsuite/gfortran.dg/assumed_size_refs_2.f90", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_size_refs_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_size_refs_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_size_refs_2.f90?ref=48474141e5fd9819aca70d43ec6b5c7dc5c32efd", "patch": "@@ -0,0 +1,44 @@\n+!==================assumed_size_refs_1.f90==================\n+! { dg-do compile }\n+! Test the fix for PR20868 & PR20870 in which references to\n+! assumed size arrays without an upper bound to the last\n+! dimension were generating no error.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+program assumed_size_test_2\n+  implicit none\n+  real a(2, 4)\n+\n+  a = 1.0\n+  call foo (a)\n+\n+contains\n+  subroutine foo(m)\n+    real, target :: m(1:2, *)\n+    real x(2,2,2)\n+    real, pointer :: q(:,:)\n+    integer :: i\n+    allocate (q(2,2))\n+\n+    q = cos (1.0 + abs(m))     ! { dg-error \"upper bound in the last dimension\" }\n+\n+    x = reshape (m, (/2,2,2/)) ! { dg-error \"upper bound in the last dimension\" }\n+\n+! PR20868\n+    print *, ubound (m)        ! { dg-error \"upper bound in the last dimension\" }\n+    print *, lbound (m)\n+\n+! PR20870\n+    print *, size (m)          ! { dg-error \"upper bound in the last dimension\" }\n+\n+! Check non-array valued intrinsics\n+    print *, ubound (m, 1)\n+    print *, ubound (m, 2)     ! { dg-error \"not a valid dimension index\" }\n+    \n+    i = 2\n+    print *, size (m, i)\n+\n+  end subroutine foo\n+\n+end program assumed_size_test_2"}, {"sha": "450dd059e0904d0173c1cf688c2053a642b26b52", "filename": "gcc/testsuite/gfortran.dg/elemental_subroutine_1.f90", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_subroutine_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_subroutine_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_subroutine_1.f90?ref=48474141e5fd9819aca70d43ec6b5c7dc5c32efd", "patch": "@@ -0,0 +1,58 @@\n+! { dg-do run }\n+! Test the fix for pr22146, where and elemental subroutine with\n+! array actual arguments would cause an ICE in gfc_conv_function_call.\n+! The module is the original test case and the rest is a basic\n+! functional test of the scalarization of the function call.\n+!\n+! Contributed by Erik Edelmann  <erik.edelmann@iki.fi>\n+!             and Paul Thomas   <pault@gcc.gnu.org>\n+\n+  module pr22146\n+\n+contains\n+\n+    elemental subroutine foo(a)\n+      integer, intent(out) :: a\n+      a = 0\n+    end subroutine foo\n+\n+    subroutine bar()\n+      integer :: a(10)\n+      call foo(a)\n+    end subroutine bar\n+\n+end module pr22146\n+\n+  use pr22146\n+  real, dimension (2)  :: x, y\n+  real :: u, v\n+  x = (/1.0, 2.0/)\n+  u = 42.0\n+\n+  call bar ()\n+\n+! Check the various combinations of scalar and array.\n+  call foobar (x, y)\n+  if (any(y.ne.-x)) call abort ()\n+\n+  call foobar (u, y)\n+  if (any(y.ne.-42.0)) call abort ()\n+\n+  call foobar (u, v)\n+  if (v.ne.-42.0) call abort ()\n+\n+  call foobar (x, v)\n+  if (v.ne.-2.0) call abort ()\n+\n+! Test an expression in the INTENT(IN) argument\n+  call foobar (cos (x) + u, y)\n+  if (any(abs (y + cos (x) + u) .gt. 2.0e-6)) call abort ()\n+\n+contains\n+\n+  elemental subroutine foobar (a, b)\n+    real, intent(IN) :: a\n+    real, intent(out) :: b\n+    b = -a\n+  end subroutine foobar\n+end\n\\ No newline at end of file"}, {"sha": "5683de89d3757708a6df3beb5f538766a794f9d9", "filename": "gcc/testsuite/gfortran.dg/elemental_subroutine_2.f90", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_subroutine_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_subroutine_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_subroutine_2.f90?ref=48474141e5fd9819aca70d43ec6b5c7dc5c32efd", "patch": "@@ -0,0 +1,64 @@\n+! { dg-do run }\n+! Test the fix for pr22146, where and elemental subroutine with\n+! array actual arguments would cause an ICE in gfc_conv_function_call.\n+! This test checks that the main uses for elemental subroutines work\n+! correctly; namely, as module procedures and as procedures called\n+! from elemental functions. The compiler would ICE on the former with\n+! the first version of the patch.\n+!\n+! Contributed by Paul Thomas   <pault@gcc.gnu.org>\n+\n+module type\n+  type itype\n+    integer :: i\n+    character(1) :: ch\n+  end type itype\n+end module type\n+\n+module assign\n+  interface assignment (=)\n+    module procedure itype_to_int\n+  end interface\n+contains\n+  elemental subroutine itype_to_int (i, it)\n+    use type\n+    type(itype), intent(in) :: it\n+    integer, intent(out) :: i\n+    i = it%i\n+  end subroutine itype_to_int\n+\n+  elemental function i_from_itype (it) result (i)\n+    use type\n+    type(itype), intent(in) :: it\n+    integer :: i\n+    i = it\n+  end function i_from_itype\n+\n+end module assign\n+\n+program test_assign\n+  use type\n+  use assign\n+  type(itype) :: x(2, 2)\n+  integer :: i(2, 2)\n+\n+! Test an elemental subroutine call from an elementary function.\n+  x = reshape ((/(itype (j, \"a\"), j = 1,4)/), (/2,2/))\n+  forall (j = 1:2, k = 1:2)\n+    i(j, k) = i_from_itype (x (j, k))\n+  end forall\n+  if (any(reshape (i, (/4/)).ne.(/1,2,3,4/))) call abort ()\n+\n+! Check the interface assignment (not part of the patch).\n+  x = reshape ((/(itype (j**2, \"b\"), j = 1,4)/), (/2,2/))\n+  i = x\n+  if (any(reshape (i, (/4/)).ne.(/1,4,9,16/))) call abort ()\n+\n+! Use the interface assignment within a forall block.\n+  x = reshape ((/(itype (j**3, \"c\"), j = 1,4)/), (/2,2/))\n+  forall (j = 1:2, k = 1:2)\n+    i(j, k) = x (j, k)\n+  end forall\n+  if (any(reshape (i, (/4/)).ne.(/1,8,27,64/))) call abort ()\n+\n+end program test_assign\n\\ No newline at end of file"}, {"sha": "e845472043d641bf886f62f53934576df97b6148", "filename": "gcc/testsuite/gfortran.dg/initialization_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48474141e5fd9819aca70d43ec6b5c7dc5c32efd/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_1.f90?ref=48474141e5fd9819aca70d43ec6b5c7dc5c32efd", "patch": "@@ -26,7 +26,7 @@ subroutine foo(ch1, x, y)\n     integer :: l1 = len (ch1)     ! { dg-warning \"assumed character length variable\" }\n \n ! These are warnings because they are gfortran extensions.\n-    integer :: m3 = size (x, 1)   ! { dg-warning \"Evaluation of nonstandard initialization\" }\n+    integer :: m3 = size (x, 1)   ! { dg-warning \"upper bound in the last dimension\" }\n     integer :: m4(2) = shape (z)  ! { dg-warning \"Evaluation of nonstandard initialization\" }\n \n ! This does not depend on non-constant properties."}]}