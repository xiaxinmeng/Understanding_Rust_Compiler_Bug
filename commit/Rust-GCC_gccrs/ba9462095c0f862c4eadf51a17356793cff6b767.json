{"sha": "ba9462095c0f862c4eadf51a17356793cff6b767", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE5NDYyMDk1YzBmODYyYzRlYWRmNTFhMTczNTY3OTNjZmY2Yjc2Nw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-03-13T12:28:09Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-03-13T12:28:09Z"}, "message": "re PR rtl-optimization/26254 (FAIL: gcc.c-torture/compile/20011109-1.c,-O1)\n\n\tPR rtl-optimization/26254\n\t* loop-invariant.c (seq_insns_valid_p): New function.\n\t(move_invariant_reg): Only emit new code if it is valid.\n\nFrom-SVN: r111998", "tree": {"sha": "68820cf0999d064302331848793e3f957154f420", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68820cf0999d064302331848793e3f957154f420"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba9462095c0f862c4eadf51a17356793cff6b767", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba9462095c0f862c4eadf51a17356793cff6b767", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba9462095c0f862c4eadf51a17356793cff6b767", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba9462095c0f862c4eadf51a17356793cff6b767/comments", "author": null, "committer": null, "parents": [{"sha": "96e82e0a8ae6309f957f263e15ea502f615e0f0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96e82e0a8ae6309f957f263e15ea502f615e0f0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96e82e0a8ae6309f957f263e15ea502f615e0f0a"}], "stats": {"total": 64, "additions": 52, "deletions": 12}, "files": [{"sha": "ab470b709cda03594b3092dffb3025907fdb1611", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9462095c0f862c4eadf51a17356793cff6b767/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9462095c0f862c4eadf51a17356793cff6b767/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba9462095c0f862c4eadf51a17356793cff6b767", "patch": "@@ -1,3 +1,9 @@\n+2006-03-13  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR rtl-optimization/26254\n+\t* loop-invariant.c (seq_insns_valid_p): New function.\n+\t(move_invariant_reg): Only emit new code if it is valid.\n+\n 2006-03-13  Zdenek Dvorak <dvorakz@suse.cz>\n \n \t* cfgrtl.c (last_loop_beg_note, back_edge_of_syntactic_loop_p):"}, {"sha": "026af40822ceee6c83fcfcd9c549d40fcdfab03b", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 46, "deletions": 12, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9462095c0f862c4eadf51a17356793cff6b767/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9462095c0f862c4eadf51a17356793cff6b767/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=ba9462095c0f862c4eadf51a17356793cff6b767", "patch": "@@ -1109,22 +1109,38 @@ find_invariants_to_move (void)\n     }\n }\n \n-/* Move invariant INVNO out of the LOOP.  */\n+/* Returns true if all insns in SEQ are valid.  */\n \n-static void\n+static bool\n+seq_insns_valid_p (rtx seq)\n+{\n+  rtx x;\n+\n+  for (x = seq; x; x = NEXT_INSN (x))\n+    if (insn_invalid_p (x))\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Move invariant INVNO out of the LOOP.  Returns true if this succeeds, false\n+   otherwise.  */\n+\n+static bool\n move_invariant_reg (struct loop *loop, unsigned invno)\n {\n   struct invariant *inv = VEC_index (invariant_p, invariants, invno);\n   struct invariant *repr = VEC_index (invariant_p, invariants, inv->eqto);\n   unsigned i;\n   basic_block preheader = loop_preheader_edge (loop)->src;\n-  rtx reg, set, seq, op;\n+  rtx reg, set, dest, seq, op;\n   struct use *use;\n   bitmap_iterator bi;\n \n-  if (inv->reg\n-      || !repr->move)\n-    return;\n+  if (inv->reg)\n+    return true;\n+  if (!repr->move)\n+    return false;\n \n   /* If this is a representative of the class of equivalent invariants,\n      really move the invariant.  Otherwise just replace its use with\n@@ -1135,7 +1151,8 @@ move_invariant_reg (struct loop *loop, unsigned invno)\n \t{\n \t  EXECUTE_IF_SET_IN_BITMAP (inv->depends_on, 0, i, bi)\n \t    {\n-\t      move_invariant_reg (loop, i);\n+\t      if (!move_invariant_reg (loop, i))\n+\t\tgoto fail;\n \t    }\n \t}\n \n@@ -1145,14 +1162,15 @@ move_invariant_reg (struct loop *loop, unsigned invno)\n \t would not be dominated by it, we may just move it (TODO).  Otherwise we\n \t need to create a temporary register.  */\n       set = single_set (inv->insn);\n-      reg = gen_reg_rtx (GET_MODE (SET_DEST (set)));\n-      emit_insn_after (gen_move_insn (SET_DEST (set), reg), inv->insn);\n+      dest = SET_DEST (set);\n+      reg = gen_reg_rtx (GET_MODE (dest));\n \n-      /* If the SET_DEST of the invariant insn is a reg, we can just move\n+      /* If the SET_DEST of the invariant insn is a pseudo, we can just move\n \t the insn out of the loop.  Otherwise, we have to use gen_move_insn\n \t to let emit_move_insn produce a valid instruction stream.  */\n-      if (REG_P (SET_DEST (set)))\n+      if (REG_P (dest) && !HARD_REGISTER_P (dest))\n \t{\n+\t  emit_insn_after (gen_move_insn (dest, reg), inv->insn);\n \t  SET_DEST (set) = reg;\n \t  reorder_insns (inv->insn, inv->insn, BB_END (preheader));\n \t}\n@@ -1165,13 +1183,18 @@ move_invariant_reg (struct loop *loop, unsigned invno)\n \t  seq = get_insns ();\n \t  end_sequence ();\n \n+\t  if (!seq_insns_valid_p (seq))\n+\t    goto fail;\n \t  emit_insn_after (seq, BB_END (preheader));\n+      \n+\t  emit_insn_after (gen_move_insn (dest, reg), inv->insn);\n \t  delete_insn (inv->insn);\n \t}\n     }\n   else\n     {\n-      move_invariant_reg (loop, repr->invno);\n+      if (!move_invariant_reg (loop, repr->invno))\n+\tgoto fail;\n       reg = repr->reg;\n       set = single_set (inv->insn);\n       emit_insn_after (gen_move_insn (SET_DEST (set), reg), inv->insn);\n@@ -1188,6 +1211,17 @@ move_invariant_reg (struct loop *loop, unsigned invno)\n       for (use = inv->def->uses; use; use = use->next)\n \t*use->pos = reg;\n     }\n+\n+  return true;\n+\n+fail:\n+  /* If we failed, clear move flag, so that we do not try to move inv\n+     again.  */\n+  if (dump_file)\n+    fprintf (dump_file, \"Failed to move invariant %d\\n\", invno);\n+  inv->move = false;\n+  inv->reg = NULL_RTX;\n+  return false;\n }\n \n /* Move selected invariant out of the LOOP.  Newly created regs are marked"}]}