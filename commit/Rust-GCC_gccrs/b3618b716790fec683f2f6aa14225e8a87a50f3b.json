{"sha": "b3618b716790fec683f2f6aa14225e8a87a50f3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM2MThiNzE2NzkwZmVjNjgzZjJmNmFhMTQyMjVlOGE4N2E1MGYzYg==", "commit": {"author": {"name": "Daniel Krugler", "email": "daniel.kruegler@googlemail.com", "date": "2012-10-09T22:31:44Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2012-10-09T22:31:44Z"}, "message": "type_traits (common_time): Provide \"SFINAE-friendly\" implementation.\n\n2012-10-09  Daniel Krugler  <daniel.kruegler@googlemail.com>\n\n\t* include/std/type_traits (common_time): Provide \"SFINAE-friendly\"\n\timplementation.\n\t(__success_type, __failure_type): Fix.\n\t* include/std/chrono (common_type): Likewise for the chrono::time_point\n\tspecialization.\n\t* testsuite/20_util/common_type/requirements/sfinae_friendly_1.cc: New.\n\t* testsuite/20_util/common_type/requirements/sfinae_friendly_2.cc:\n\tLikewise.\n\t* testsuite/20_util/duration/requirements/sfinae_friendly_1.cc:\n\tLikewise.\n\t* testsuite/20_util/common_type/requirements/typedefs-1.cc: Adjust wrt\n\tLWG 2141.\n\t* testsuite/20_util/duration/requirements/typedefs_neg1.cc: Adjust\n\tdg-error line numbers.\n\t* testsuite/20_util/duration/requirements/typedefs_neg2.cc: Likewise.\n\t* testsuite/20_util/duration/requirements/typedefs_neg3.cc: Likewise.\n\t* testsuite/20_util/make_signed/requirements/typedefs_neg.cc: Likewise.\n\t* testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc:\n\tLikewise.\n\t* testsuite/20_util/declval/requirements/1_neg.cc: Likewise.\n\n\t* testsuite/20_util/result_of/sfinae_friendly_1.cc: Trivial stylistic\n\ttweaks.\n\t* testsuite/20_util/result_of/sfinae_friendly_2.cc: Likewise.\n\nFrom-SVN: r192276", "tree": {"sha": "8ed2608f34cbf269d7220c821624ef679371cc03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ed2608f34cbf269d7220c821624ef679371cc03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3618b716790fec683f2f6aa14225e8a87a50f3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3618b716790fec683f2f6aa14225e8a87a50f3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3618b716790fec683f2f6aa14225e8a87a50f3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3618b716790fec683f2f6aa14225e8a87a50f3b/comments", "author": {"login": "Dani-Hub", "id": 431432, "node_id": "MDQ6VXNlcjQzMTQzMg==", "avatar_url": "https://avatars.githubusercontent.com/u/431432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dani-Hub", "html_url": "https://github.com/Dani-Hub", "followers_url": "https://api.github.com/users/Dani-Hub/followers", "following_url": "https://api.github.com/users/Dani-Hub/following{/other_user}", "gists_url": "https://api.github.com/users/Dani-Hub/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dani-Hub/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dani-Hub/subscriptions", "organizations_url": "https://api.github.com/users/Dani-Hub/orgs", "repos_url": "https://api.github.com/users/Dani-Hub/repos", "events_url": "https://api.github.com/users/Dani-Hub/events{/privacy}", "received_events_url": "https://api.github.com/users/Dani-Hub/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "71111e6b202aa01dc4b2ba50ee592c87f240ba7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71111e6b202aa01dc4b2ba50ee592c87f240ba7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71111e6b202aa01dc4b2ba50ee592c87f240ba7f"}], "stats": {"total": 701, "additions": 630, "deletions": 71}, "files": [{"sha": "fac31ad846d7001ef251799491ec57c8e56ef4d3", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b3618b716790fec683f2f6aa14225e8a87a50f3b", "patch": "@@ -1,3 +1,30 @@\n+2012-10-09  Daniel Krugler  <daniel.kruegler@googlemail.com>\n+\n+\t* include/std/type_traits (common_time): Provide \"SFINAE-friendly\"\n+\timplementation.\n+\t(__success_type, __failure_type): Fix.\n+\t* include/std/chrono (common_type): Likewise for the chrono::time_point\n+\tspecialization.\n+\t* testsuite/20_util/common_type/requirements/sfinae_friendly_1.cc: New.\n+\t* testsuite/20_util/common_type/requirements/sfinae_friendly_2.cc:\n+\tLikewise.\n+\t* testsuite/20_util/duration/requirements/sfinae_friendly_1.cc:\n+\tLikewise.\n+\t* testsuite/20_util/common_type/requirements/typedefs-1.cc: Adjust wrt\n+\tLWG 2141.\n+\t* testsuite/20_util/duration/requirements/typedefs_neg1.cc: Adjust\n+\tdg-error line numbers.\n+\t* testsuite/20_util/duration/requirements/typedefs_neg2.cc: Likewise.\n+\t* testsuite/20_util/duration/requirements/typedefs_neg3.cc: Likewise.\n+\t* testsuite/20_util/make_signed/requirements/typedefs_neg.cc: Likewise.\n+\t* testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc:\n+\tLikewise.\n+\t* testsuite/20_util/declval/requirements/1_neg.cc: Likewise.\n+\n+\t* testsuite/20_util/result_of/sfinae_friendly_1.cc: Trivial stylistic\n+\ttweaks.\n+\t* testsuite/20_util/result_of/sfinae_friendly_2.cc: Likewise.\n+\n 2012-10-09  Andrew MacLeod  <amacleod@redhat.com>\n \n \tPR libstdc++/54861"}, {"sha": "209f395ed3d97837811fc5f3a03918c853f8bacc", "filename": "libstdc++-v3/include/std/chrono", "status": "modified", "additions": 39, "deletions": 19, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono?ref=b3618b716790fec683f2f6aa14225e8a87a50f3b", "patch": "@@ -69,33 +69,53 @@ namespace std _GLIBCXX_VISIBILITY(default)\n   }\n \n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n-  // 20.11.4.3 specialization of common_type (for duration)\n-  template<typename _Rep1, typename _Period1, typename _Rep2, typename _Period2>\n-    struct common_type<chrono::duration<_Rep1, _Period1>,\n-\t\t       chrono::duration<_Rep2, _Period2>>\n+\n+  // 20.11.4.3 specialization of common_type (for duration, sfinae-friendly)\n+  \n+  template<typename _CT, typename _Period1, typename _Period2>\n+    struct __duration_common_type_wrapper\n     {\n     private:\n-      typedef __static_gcd<_Period1::num, _Period2::num> \t__gcd_num;\n-      typedef __static_gcd<_Period1::den, _Period2::den> \t__gcd_den;\n-      typedef typename common_type<_Rep1, _Rep2>::type\t\t__cr;\n+      typedef __static_gcd<_Period1::num, _Period2::num> __gcd_num;\n+      typedef __static_gcd<_Period1::den, _Period2::den> __gcd_den;\n+      typedef typename _CT::type __cr;\n       typedef ratio<__gcd_num::value,\n-\t\t    (_Period1::den / __gcd_den::value) * _Period2::den> __r;\n-\n+        (_Period1::den / __gcd_den::value) * _Period2::den> __r;\n     public:\n-      typedef chrono::duration<__cr, __r> \t\t\ttype;\n+      typedef __success_type<chrono::duration<__cr, __r>> type;\n     };\n \n-  // 20.11.4.3 specialization of common_type (for time_point)\n-  template<typename _Clock, typename _Dur1, typename _Dur2>\n-    struct common_type<chrono::time_point<_Clock, _Dur1>,\n-\t\t       chrono::time_point<_Clock, _Dur2>>\n-    {\n-    private:\n-      typedef typename common_type<_Dur1, _Dur2>::type \t\t__ct;\n+  template<typename _Period1, typename _Period2>\n+    struct __duration_common_type_wrapper<__failure_type, _Period1, _Period2>\n+    { typedef __failure_type type; };\n \n-    public:\n-      typedef chrono::time_point<_Clock, __ct> \t\t\ttype;\n+  template<typename _Rep1, typename _Period1, typename _Rep2, typename _Period2>\n+    struct common_type<chrono::duration<_Rep1, _Period1>,\n+             chrono::duration<_Rep2, _Period2>>\n+    : public __duration_common_type_wrapper<typename __member_type_wrapper<\n+             common_type<_Rep1, _Rep2>>::type, _Period1, _Period2>::type\n+    { };\n+\n+  // 20.11.4.3 specialization of common_type (for time_point, sfinae-friendly)\n+  \n+  template<typename _CT, typename _Clock>\n+    struct __timepoint_common_type_wrapper\n+    {\n+      typedef __success_type<chrono::time_point<_Clock, typename _CT::type>>\n+        type;\n     };\n+\n+  template<typename _Clock>\n+    struct __timepoint_common_type_wrapper<__failure_type, _Clock>\n+    { typedef __failure_type type; };\n+\n+  template<typename _Clock, typename _Duration1, typename _Duration2>\n+    struct common_type<chrono::time_point<_Clock, _Duration1>,\n+             chrono::time_point<_Clock, _Duration2>>\n+    : public __timepoint_common_type_wrapper<typename __member_type_wrapper<\n+             common_type<_Duration1, _Duration2>>::type, _Clock>::type\n+    { };\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n \n   namespace chrono"}, {"sha": "ccec92045b4c5a9d2647c5344854b55cd088e2ae", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 64, "deletions": 14, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=b3618b716790fec683f2f6aa14225e8a87a50f3b", "patch": "@@ -133,6 +133,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     typedef struct { char __arr[2]; } __two;\n   };\n \n+  // For several sfinae-friendly trait implementations we transport both the\n+  // result information (as the member type) and the failure information (no\n+  // member type). This is very similar to std::enable_if, but we cannot use\n+  // them, because we need to derive from them as an implementation detail.\n+\n+  template<typename _Tp>\n+    struct __success_type\n+    { typedef _Tp type; };\n+\n+  struct __failure_type\n+  { };\n+\n   // primary type categories.\n \n   template<typename>\n@@ -1771,25 +1783,70 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct conditional<false, _Iftrue, _Iffalse>\n     { typedef _Iffalse type; };\n \n-\n   /// common_type\n   template<typename... _Tp>\n     struct common_type;\n \n+  // sfinae-friendly common_type implementation:\n+\n+  struct __do_common_type_impl\n+  {\n+    template<typename _Tp, typename _Up>\n+      static __success_type<typename decay<\n+        decltype(true ? std::declval<_Tp>() : std::declval<_Up>())\n+      >::type> _S_test(int);\n+\n+    template<typename, typename>\n+      static __failure_type _S_test(...);\n+  };\n+\n+  template<typename _Tp, typename _Up>\n+    struct __common_type_impl\n+    : private __do_common_type_impl\n+    {\n+      typedef decltype(_S_test<_Tp, _Up>(0)) type;\n+    };\n+\n+  struct __do_member_type_wrapper\n+  {\n+    template<typename _Tp>\n+      static __success_type<typename _Tp::type> _S_test(int);\n+\n+    template<typename>\n+      static __failure_type _S_test(...);\n+  };\n+\n+  template<typename _Tp>\n+    struct __member_type_wrapper\n+    : private __do_member_type_wrapper\n+    {\n+      typedef decltype(_S_test<_Tp>(0)) type;\n+    };\n+\n+  template<typename _CTp, typename... _Args>\n+    struct __expanded_common_type_wrapper\n+    {\n+      typedef common_type<typename _CTp::type, _Args...> type;\n+    };\n+\n+  template<typename... _Args>\n+    struct __expanded_common_type_wrapper<__failure_type, _Args...>\n+    { typedef __failure_type type; };\n+\n   template<typename _Tp>\n     struct common_type<_Tp>\n     { typedef _Tp type; };\n \n   template<typename _Tp, typename _Up>\n     struct common_type<_Tp, _Up>\n-    { typedef decltype(true ? declval<_Tp>() : declval<_Up>()) type; };\n+    : public __common_type_impl<_Tp, _Up>::type\n+    { };\n \n   template<typename _Tp, typename _Up, typename... _Vp>\n     struct common_type<_Tp, _Up, _Vp...>\n-    {\n-      typedef typename\n-        common_type<typename common_type<_Tp, _Up>::type, _Vp...>::type type;\n-    };\n+    : public __expanded_common_type_wrapper<typename __member_type_wrapper<\n+               common_type<_Tp, _Up>>::type, _Vp...>::type\n+    { };\n \n   /// The underlying type of an enum.\n   template<typename _Tp>\n@@ -1818,14 +1875,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Signature>\n     class result_of;\n \n-  // sfinae-friendly result_of implementation. We use enable_if to transport\n-  // both the result information (as the member type) and the failure\n-  // information (no member type).\n-\n-  template<typename _Tp>\n-    using __success_type = enable_if<true, _Tp>;\n-\n-  using __failure_type = enable_if<false>;\n+  // sfinae-friendly result_of implementation:\n \n   // [func.require] paragraph 1 bullet 1:\n   struct __result_of_memfun_ref_impl"}, {"sha": "de7ca27071460fa264a7094e0419b393fbad7e6c", "filename": "libstdc++-v3/testsuite/20_util/common_type/requirements/sfinae_friendly_1.cc", "status": "added", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fcommon_type%2Frequirements%2Fsfinae_friendly_1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fcommon_type%2Frequirements%2Fsfinae_friendly_1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fcommon_type%2Frequirements%2Fsfinae_friendly_1.cc?ref=b3618b716790fec683f2f6aa14225e8a87a50f3b", "patch": "@@ -0,0 +1,341 @@\n+// { dg-options \"-std=c++11\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+#include <initializer_list>\n+\n+//TODO: Uncomment this once gcc bug 53000 has been resolved:\n+//#define HAS_53000_FIXED\n+\n+// Helper types:\n+struct has_type_impl\n+{\n+  template<typename T, typename = typename T::type>\n+  static std::true_type test(int);\n+  template<typename>\n+  static std::false_type test(...);\n+};\n+\n+template<typename T>\n+struct has_type : public decltype(has_type_impl::test<T>(0))\n+{};\n+\n+template<typename T, typename Expected>\n+struct is_expected_type : public std::is_same<typename T::type, Expected>\n+{};\n+\n+template<typename P1, typename P2>\n+struct and_ : public std::conditional<P1::value, P2, std::false_type>::type\n+{};\n+\n+template<typename T, typename Expected>\n+struct is_type : public and_<has_type<T>, is_expected_type<T, Expected>>\n+{};\n+\n+// Inspection types:\n+\n+struct S {};\n+\n+struct B {};\n+struct D : B {};\n+\n+struct F1 { operator void*(); };\n+struct F2 { operator void*(); };\n+\n+struct G1 { operator const void*(); };\n+struct G2 { operator volatile void*(); };\n+\n+template<typename T>\n+struct ImplicitTo\n+{\n+  operator T();\n+};\n+\n+template<typename T>\n+struct ExplicitTo\n+{\n+  explicit operator T();\n+};\n+\n+template<typename T>\n+struct PrivateImplicitTo\n+{\n+private:\n+  operator T();\n+};\n+\n+auto lmd1 = [](int, double) {};\n+auto lmd2 = [](int, double) {};\n+\n+struct Abstract\n+{\n+  virtual ~Abstract() = 0;\n+};\n+\n+enum class ScEn;\n+\n+enum UnscEn : int;\n+\n+struct Ukn;\n+\n+union U\n+{\n+  int i;\n+};\n+\n+union U2\n+{\n+  long i;\n+};\n+\n+union UConv1\n+{\n+  operator Abstract*();\n+};\n+\n+union UConv2\n+{\n+  operator Abstract*();\n+};\n+\n+struct X1 {};\n+struct X2 {};\n+struct RX12 {};\n+struct RX21 {};\n+struct Y1 {};\n+struct Y2 {};\n+struct Y3 {};\n+struct Y4 {};\n+\n+namespace std {\n+\n+  template<>\n+  struct common_type<X1, X2>\n+  {\n+    typedef RX12 type;\n+  };\n+\n+  template<>\n+  struct common_type<X2, X1>\n+  {\n+    typedef RX21 type;\n+  };\n+\n+  template<>\n+  struct common_type<RX12, X1>\n+  {\n+    typedef Y1 type;\n+  };\n+\n+  template<>\n+  struct common_type<X1, RX12>\n+  {\n+    typedef Y2 type;\n+  };\n+\n+  template<>\n+  struct common_type<RX21, X1>\n+  {\n+    typedef Y3 type;\n+  };\n+\n+  template<>\n+  struct common_type<X1, RX21>\n+  {\n+    typedef Y4 type;\n+  };\n+}\n+\n+static_assert(is_type<std::common_type<int, int>, int>(), \"\");\n+static_assert(is_type<std::common_type<ScEn, ScEn>, ScEn>(), \"\");\n+static_assert(is_type<std::common_type<UnscEn, UnscEn>, UnscEn>(), \"\");\n+static_assert(is_type<std::common_type<int, int>, int>(), \"\");\n+static_assert(is_type<std::common_type<UnscEn, int>, int>(), \"\");\n+static_assert(is_type<std::common_type<int, int, int>, int>(), \"\");\n+static_assert(is_type<std::common_type<int, int, int, int>, int>(), \"\");\n+static_assert(is_type<std::common_type<int, int, int, int, int>, int>(), \"\");\n+static_assert(is_type<std::common_type<S, S>, S>(), \"\");\n+static_assert(is_type<std::common_type<const S, const S>, S>(), \"\");\n+static_assert(is_type<std::common_type<std::initializer_list<int>,\n+\t      std::initializer_list<int>>, std::initializer_list<int>>(), \"\");\n+static_assert(is_type<std::common_type<B, D>, B>(), \"\");\n+static_assert(is_type<std::common_type<D, B>, B>(), \"\");\n+static_assert(is_type<std::common_type<F1, F2>, void*>(), \"\");\n+static_assert(is_type<std::common_type<F2, F1>, void*>(), \"\");\n+static_assert(is_type<std::common_type<G1, G2>, const volatile void*>(), \"\");\n+static_assert(is_type<std::common_type<G2, G1>, const volatile void*>(), \"\");\n+static_assert(is_type<std::common_type<int*, const volatile int*>,\n+\t      const volatile int*>(), \"\");\n+static_assert(is_type<std::common_type<void*, const volatile int*>,\n+\t      const volatile void*>(), \"\");\n+static_assert(is_type<std::common_type<void, void>, void>(), \"\");\n+static_assert(is_type<std::common_type<const void, const void>, void>(), \"\");\n+static_assert(is_type<std::common_type<int&, int&&>, int>(), \"\");\n+static_assert(is_type<std::common_type<int&, int&>, int>(), \"\");\n+static_assert(is_type<std::common_type<int&&, int&&>, int>(), \"\");\n+static_assert(is_type<std::common_type<U&, const U&&>, U>(), \"\");\n+static_assert(is_type<std::common_type<U&, U&>, U>(), \"\");\n+static_assert(is_type<std::common_type<U&&, U&&>, U>(), \"\");\n+static_assert(is_type<std::common_type<int B::*, int D::*>, int D::*>(), \"\");\n+static_assert(is_type<std::common_type<int D::*, int B::*>, int D::*>(), \"\");\n+static_assert(is_type<std::common_type<const int B::*, volatile int D::*>,\n+\t      const volatile int D::*>(), \"\");\n+static_assert(is_type<std::common_type<int (B::*)(), int (D::*)()>,\n+\t      int (D::*)()>(), \"\");\n+static_assert(is_type<std::common_type<int (B::*)() const, int (D::*)() const>,\n+\t      int (D::*)() const>(), \"\");\n+static_assert(is_type<std::common_type<int[3], int[3]>, int*>(), \"\");\n+static_assert(is_type<std::common_type<int[1], const int[3]>,\n+\t      const int*>(), \"\");\n+static_assert(is_type<std::common_type<void(), void()>, void(*)()>(), \"\");\n+static_assert(is_type<std::common_type<void(&)(), void(&)()>, void(*)()>(), \"\");\n+static_assert(is_type<std::common_type<void(&)(), void(&&)()>,\n+\t      void(*)()>(), \"\");\n+static_assert(is_type<std::common_type<void(&&)(), void(&)()>,\n+\t      void(*)()>(), \"\");\n+static_assert(is_type<std::common_type<void(&&)(), void(&&)()>,\n+\t      void(*)()>(), \"\");\n+static_assert(is_type<std::common_type<ImplicitTo<int>, int>, int>(), \"\");\n+static_assert(is_type<std::common_type<ImplicitTo<int>, ImplicitTo<int>>,\n+\t      ImplicitTo<int>>(), \"\");\n+static_assert(is_type<std::common_type<ImplicitTo<int>, int,\n+\t      ImplicitTo<int>>, int>(), \"\");\n+static_assert(is_type<std::common_type<ExplicitTo<int>, ExplicitTo<int>>,\n+\t      ExplicitTo<int>>(), \"\");\n+static_assert(is_type<std::common_type<decltype(lmd1), decltype(lmd1)>,\n+\t      decltype(lmd1)>(), \"\");\n+static_assert(is_type<std::common_type<decltype(lmd1)&, decltype(lmd1)&>,\n+\t      decltype(lmd1)>(), \"\");\n+static_assert(is_type<std::common_type<decltype(lmd1)&, decltype(lmd2)&>,\n+\t      void(*)(int, double)>(), \"\");\n+static_assert(is_type<std::common_type<decltype(nullptr), void*>, void*>(), \"\");\n+static_assert(is_type<std::common_type<decltype(nullptr), int*>, int*>(), \"\");\n+static_assert(is_type<std::common_type<const decltype(nullptr)&, int*>,\n+\t      int*>(), \"\");\n+static_assert(is_type<std::common_type<decltype(nullptr), const volatile int*>,\n+\t      const volatile int*>(), \"\");\n+static_assert(is_type<std::common_type<decltype(nullptr), int (B::*)()>,\n+\t      int (B::*)()>(), \"\");\n+static_assert(is_type<std::common_type<decltype(nullptr), int (B::*)() const>,\n+\t      int (B::*)() const>(), \"\");\n+static_assert(is_type<std::common_type<decltype(nullptr), const int B::*>,\n+\t      const int B::*>(), \"\");\n+static_assert(is_type<std::common_type<Abstract&, Abstract&>, Abstract>(), \"\");\n+static_assert(is_type<std::common_type<Ukn&, Ukn&>, Ukn>(), \"\");\n+static_assert(is_type<std::common_type<ImplicitTo<B&>, B&>, B>(), \"\");\n+static_assert(is_type<std::common_type<ImplicitTo<B&>&, B&&>, B>(), \"\");\n+static_assert(is_type<std::common_type<UConv1, const Abstract*&>,\n+\t      const Abstract*>(), \"\");\n+static_assert(is_type<std::common_type<UConv1, UConv2>, Abstract*>(), \"\");\n+static_assert(is_type<std::common_type<UConv1&, UConv2&>, Abstract*>(), \"\");\n+\n+#ifdef HAS_53000_FIXED\n+static_assert(is_type<std::common_type<Abstract&&, Abstract&&>,\n+\t      Abstract>(), \"\");\n+static_assert(is_type<std::common_type<const Abstract&&,\n+\t\t\t\t       volatile Abstract&&>, Abstract>(), \"\");\n+static_assert(is_type<std::common_type<Ukn&&, Ukn&&>, Ukn>(), \"\");\n+static_assert(is_type<std::common_type<const Ukn&&, volatile Ukn&&>,\n+\t      Ukn>(), \"\");\n+#endif\n+\n+static_assert(is_type<std::common_type<X1, X2>, RX12>(), \"\");\n+static_assert(is_type<std::common_type<X2, X1>, RX21>(), \"\");\n+\n+static_assert(is_type<std::common_type<X1, X2, X1>, Y1>(), \"\");\n+static_assert(is_type<std::common_type<X2, X1, X1>, Y3>(), \"\");\n+\n+static_assert(is_type<std::common_type<X1, X1, X2>, RX12>(), \"\");\n+static_assert(is_type<std::common_type<X1, X1, X2, X1>, Y1>(), \"\");\n+\n+static_assert(!has_type<std::common_type<>>(), \"\");\n+static_assert(!has_type<std::common_type<int, S>>(), \"\");\n+static_assert(!has_type<std::common_type<U, S>>(), \"\");\n+static_assert(!has_type<std::common_type<U, U2>>(), \"\");\n+static_assert(!has_type<std::common_type<const ImplicitTo<int>, int>>(), \"\");\n+static_assert(!has_type<std::common_type<PrivateImplicitTo<int>, int>>(), \"\");\n+static_assert(!has_type<std::common_type<const PrivateImplicitTo<int>,\n+\t      int>>(), \"\");\n+static_assert(!has_type<std::common_type<int, Ukn>>(), \"\");\n+static_assert(!has_type<std::common_type<int, Abstract>>(), \"\");\n+static_assert(!has_type<std::common_type<Ukn, Abstract>>(), \"\");\n+static_assert(!has_type<std::common_type<int, void>>(), \"\");\n+static_assert(!has_type<std::common_type<int, const volatile void>>(), \"\");\n+static_assert(!has_type<std::common_type<Abstract, void>>(), \"\");\n+static_assert(!has_type<std::common_type<Ukn, void>>(), \"\");\n+static_assert(!has_type<std::common_type<int[4], void>>(), \"\");\n+static_assert(!has_type<std::common_type<ScEn, void>>(), \"\");\n+static_assert(!has_type<std::common_type<UnscEn, void>>(), \"\");\n+static_assert(!has_type<std::common_type<U, void>>(), \"\");\n+static_assert(!has_type<std::common_type<std::initializer_list<int>,\n+\t      void>>(), \"\");\n+static_assert(!has_type<std::common_type<int, int, int, S>>(), \"\");\n+static_assert(!has_type<std::common_type<int, int, S, int>>(), \"\");\n+static_assert(!has_type<std::common_type<int, S, int, int>>(), \"\");\n+static_assert(!has_type<std::common_type<S, int, int, int>>(), \"\");\n+static_assert(!has_type<std::common_type<int, int, void, int, int>>(), \"\");\n+static_assert(!has_type<std::common_type<B, S>>(), \"\");\n+static_assert(!has_type<std::common_type<int, B, S>>(), \"\");\n+static_assert(!has_type<std::common_type<B, int, S>>(), \"\");\n+static_assert(!has_type<std::common_type<B, S, int>>(), \"\");\n+static_assert(!has_type<std::common_type<int*, double*>>(), \"\");\n+static_assert(!has_type<std::common_type<void*, void(*)(...)>>(), \"\");\n+static_assert(!has_type<std::common_type<void(*)(), void(*)(...)>>(), \"\");\n+static_assert(!has_type<std::common_type<void(*)(), void(S::*)()>>(), \"\");\n+static_assert(!has_type<std::common_type<void(S::*)() const,\n+\t      void(S::*)()>>(), \"\");\n+static_assert(!has_type<std::common_type<int S::*, long S::*>>(), \"\");\n+static_assert(!has_type<std::common_type<int S::*, void(S::*)()>>(), \"\");\n+static_assert(!has_type<std::common_type<int (B::*)(),\n+\t      int (D::*)() const>>(), \"\");\n+static_assert(!has_type<std::common_type<int (B::*)() const,\n+\t      int (D::*)()>>(), \"\");\n+static_assert(!has_type<std::common_type<int, ExplicitTo<int>>>(), \"\");\n+static_assert(!has_type<std::common_type<ImplicitTo<int>,\n+\t\t\t\t\t ExplicitTo<int>>>(), \"\");\n+static_assert(!has_type<std::common_type<ScEn, int>>(), \"\");\n+static_assert(!has_type<std::common_type<ScEn, UnscEn>>(), \"\");\n+static_assert(!has_type<std::common_type<U, S, Abstract, void, D,\n+\t      int (B::*)(), int[5]>>(), \"\");\n+static_assert(!has_type<std::common_type<UConv1, Abstract&&>>(), \"\");\n+static_assert(!has_type<std::common_type<std::initializer_list<int>,\n+\t\t\t\t\t std::initializer_list<long>>>(), \"\");\n+\n+void test(int i)\n+{\n+  auto local_lmd1 = [=](int, double) { return i + i; };\n+  auto local_lmd2 = [=](int, double) { return i - i; };\n+\n+  static_assert(is_type<std::common_type<decltype(local_lmd1),\n+\t\t        decltype(local_lmd1)>, decltype(local_lmd1)>(), \"\");\n+  static_assert(is_type<std::common_type<decltype(local_lmd1)&,\n+\t\t        decltype(local_lmd1)>, decltype(local_lmd1)>(), \"\");\n+  static_assert(is_type<std::common_type<decltype(local_lmd1)&,\n+\t\t\tdecltype(local_lmd1)&>, decltype(local_lmd1)>(), \"\");\n+\n+  static_assert(!has_type<std::common_type<decltype(local_lmd1),\n+\t\tdecltype(lmd1)>>(), \"\");\n+  static_assert(!has_type<std::common_type<decltype(local_lmd1)&,\n+\t\tdecltype(lmd1)&>>(), \"\");\n+  static_assert(!has_type<std::common_type<decltype(local_lmd1),\n+\t\tdecltype(local_lmd2)>>(), \"\");\n+  static_assert(!has_type<std::common_type<decltype(local_lmd1)&,\n+\t\tdecltype(local_lmd2)&>>(), \"\");\n+}"}, {"sha": "e4d4fa0d0c4cbc2d4fb361f038b29095cc8d7b02", "filename": "libstdc++-v3/testsuite/20_util/common_type/requirements/sfinae_friendly_2.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fcommon_type%2Frequirements%2Fsfinae_friendly_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fcommon_type%2Frequirements%2Fsfinae_friendly_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fcommon_type%2Frequirements%2Fsfinae_friendly_2.cc?ref=b3618b716790fec683f2f6aa14225e8a87a50f3b", "patch": "@@ -0,0 +1,51 @@\n+// { dg-options \"-std=c++11\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+#include <array>\n+#include <utility>\n+\n+template<typename... Args>\n+constexpr\n+std::array<typename std::common_type<Args...>::type, sizeof...(Args)>\n+make_array(Args&&... args)  // { dg-error \"invalid use\" }\n+{\n+  typedef typename std::common_type<Args...>::type CT;\n+  return std::array<CT, sizeof...(Args)>{static_cast<CT>\n+      (std::forward<Args>(args))...};\n+}\n+\n+void test01()\n+{\n+  constexpr auto a1 = make_array(0);\n+  constexpr auto a2 = make_array(0, 1.2);\n+  constexpr auto a3 = make_array(5, true, 3.1415f, 'c');\n+\n+  static_assert(std::is_same<decltype(a1), const std::array<int, 1>>(), \"\");\n+  static_assert(std::is_same<decltype(a2), const std::array<double, 2>>(), \"\");\n+  static_assert(std::is_same<decltype(a3), const std::array<float, 4>>(), \"\");\n+}\n+\n+void test02()\n+{\n+  make_array(); // { dg-error \"no matching function\" }\n+}\n+// { dg-prune-output \"substitution\" }\n+// { dg-prune-output \"include\" }"}, {"sha": "2d6babef02c779eb0a541cbe94d721cf631e27be", "filename": "libstdc++-v3/testsuite/20_util/common_type/requirements/typedefs-1.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fcommon_type%2Frequirements%2Ftypedefs-1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fcommon_type%2Frequirements%2Ftypedefs-1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fcommon_type%2Frequirements%2Ftypedefs-1.cc?ref=b3618b716790fec683f2f6aa14225e8a87a50f3b", "patch": "@@ -1,6 +1,6 @@\n // { dg-options \"-std=gnu++0x\" }\n //\n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2008-2012 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -105,7 +105,7 @@ void test02()\n   COMMON_TYPE_TEST_ALL_2(int, int, int, 1);\n   COMMON_TYPE_TEST_ALL_2(int, double, double, 2);\n   COMMON_TYPE_TEST_2(NO_CV, A, A, A, 3);\n-  COMMON_TYPE_TEST_2(const, A, A, const A, 4);\n+  COMMON_TYPE_TEST_2(const, A, A, A, 4);\n   COMMON_TYPE_TEST_2(NO_CV, B, A, A, 5);  \n }\n "}, {"sha": "91d3553bb1dcb704faf774fdc7b948269c630424", "filename": "libstdc++-v3/testsuite/20_util/declval/requirements/1_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc?ref=b3618b716790fec683f2f6aa14225e8a87a50f3b", "patch": "@@ -19,7 +19,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"static assertion failed\" \"\" { target *-*-* } 1812 }\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 1869 }\n \n #include <utility>\n "}, {"sha": "48b0197d91163694d2b16031c15c17d984dd0eed", "filename": "libstdc++-v3/testsuite/20_util/duration/requirements/sfinae_friendly_1.cc", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Fsfinae_friendly_1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Fsfinae_friendly_1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Fsfinae_friendly_1.cc?ref=b3618b716790fec683f2f6aa14225e8a87a50f3b", "patch": "@@ -0,0 +1,66 @@\n+// { dg-options \"-std=c++11\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+#include <chrono>\n+\n+// Helper types:\n+struct has_type_impl\n+{\n+  template<typename T, typename = typename T::type>\n+  static std::true_type test(int);\n+  template<typename>\n+  static std::false_type test(...);\n+};\n+\n+template<typename T>\n+struct has_type : public decltype(has_type_impl::test<T>(0))\n+{};\n+\n+template<typename T, typename Expected>\n+struct is_expected_type : public std::is_same<typename T::type, Expected>\n+{};\n+\n+template<typename P1, typename P2>\n+struct and_ : public std::conditional<P1::value, P2, std::false_type>::type\n+{};\n+\n+template<typename T, typename Expected>\n+struct is_type : public and_<has_type<T>, is_expected_type<T, Expected>>\n+{};\n+\n+// Inspection types:\n+\n+typedef std::chrono::duration<int, std::nano> din;\n+typedef std::chrono::duration<double, std::nano> ddn;\n+typedef std::chrono::duration<int, std::milli> dim;\n+\n+static_assert(is_type<std::common_type<din, din>, din>(), \"\");\n+static_assert(is_type<std::common_type<din, din, din>, din>(), \"\");\n+\n+static_assert(is_type<std::common_type<din, ddn>, ddn>(), \"\");\n+static_assert(is_type<std::common_type<din, din, ddn>, ddn>(), \"\");\n+static_assert(is_type<std::common_type<din, ddn>, ddn>(), \"\");\n+static_assert(is_type<std::common_type<ddn, din, din>, ddn>(), \"\");\n+\n+static_assert(!has_type<std::common_type<din, int>>(), \"\");\n+static_assert(!has_type<std::common_type<din, din, int>>(), \"\");\n+static_assert(!has_type<std::common_type<int, din, din>>(), \"\");\n+"}, {"sha": "d127d210b85ee52b21c62e48760e076483a152ae", "filename": "libstdc++-v3/testsuite/20_util/duration/requirements/typedefs_neg1.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg1.cc?ref=b3618b716790fec683f2f6aa14225e8a87a50f3b", "patch": "@@ -3,7 +3,7 @@\n // { dg-require-cstdint \"\" }\n // 2008-07-31 Chris Fairles <chris.fairles@gmail.com>\n \n-// Copyright (C) 2008, 2009, 2010, 2011, 2012 Free Software Foundation, Inc.\n+// Copyright (C) 2008-2012 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,5 +31,5 @@ void test01()\n   test_type d;\n }\n \n-// { dg-error \"rep cannot be a duration\" \"\" { target *-*-* } 225 }\n+// { dg-error \"rep cannot be a duration\" \"\" { target *-*-* } 245 }\n // { dg-error \"required from here\" \"\" { target *-*-* } 31 }"}, {"sha": "f4e4501a56eeec628532b0b73d5bfd574f41fddf", "filename": "libstdc++-v3/testsuite/20_util/duration/requirements/typedefs_neg2.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg2.cc?ref=b3618b716790fec683f2f6aa14225e8a87a50f3b", "patch": "@@ -3,7 +3,7 @@\n // { dg-require-cstdint \"\" }\n // 2008-07-31 Chris Fairles <chris.fairles@gmail.com>\n \n-// Copyright (C) 2008, 2009, 2010, 2011, 2012 Free Software Foundation, Inc.\n+// Copyright (C) 2008-2012 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,5 +32,5 @@ void test01()\n   test_type d;\t\t\t// { dg-error \"required from here\" }\n }\n \n-// { dg-error \"must be a specialization of ratio\" \"\" { target *-*-* } 226 }\n+// { dg-error \"must be a specialization of ratio\" \"\" { target *-*-* } 246 }\n // { dg-prune-output \"not a member\" }"}, {"sha": "113cda8bca4372db9ea19679b070d6fbf0c674e6", "filename": "libstdc++-v3/testsuite/20_util/duration/requirements/typedefs_neg3.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg3.cc?ref=b3618b716790fec683f2f6aa14225e8a87a50f3b", "patch": "@@ -3,7 +3,7 @@\n // { dg-require-cstdint \"\" }\n // 2008-07-31 Chris Fairles <chris.fairles@gmail.com>\n \n-// Copyright (C) 2008, 2009, 2010, 2011, 2012 Free Software Foundation, Inc.\n+// Copyright (C) 2008-2012 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -33,5 +33,5 @@ void test01()\n   test_type d;\n }\n \n-// { dg-error \"period must be positive\" \"\" { target *-*-* } 228 }\n+// { dg-error \"period must be positive\" \"\" { target *-*-* } 248 }\n // { dg-error \"required from here\" \"\" { target *-*-* } 33 }"}, {"sha": "b0b811115ee71bf5939a19d7b12b71fc050ed8c9", "filename": "libstdc++-v3/testsuite/20_util/make_signed/requirements/typedefs_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc?ref=b3618b716790fec683f2f6aa14225e8a87a50f3b", "patch": "@@ -48,5 +48,5 @@ void test01()\n // { dg-error \"required from here\" \"\" { target *-*-* } 40 }\n // { dg-error \"required from here\" \"\" { target *-*-* } 42 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1601 }\n-// { dg-error \"declaration of\" \"\" { target *-*-* } 1565 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1613 }\n+// { dg-error \"declaration of\" \"\" { target *-*-* } 1577 }"}, {"sha": "8f4cf24cd14c7cc1969d7c103da938f458165a0e", "filename": "libstdc++-v3/testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc?ref=b3618b716790fec683f2f6aa14225e8a87a50f3b", "patch": "@@ -48,5 +48,5 @@ void test01()\n // { dg-error \"required from here\" \"\" { target *-*-* } 40 }\n // { dg-error \"required from here\" \"\" { target *-*-* } 42 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1519 }\n-// { dg-error \"declaration of\" \"\" { target *-*-* } 1483 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1531 }\n+// { dg-error \"declaration of\" \"\" { target *-*-* } 1495 }"}, {"sha": "b70c85b99a8930297063619b1f50fab9aaf278f0", "filename": "libstdc++-v3/testsuite/20_util/result_of/sfinae_friendly_1.cc", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fresult_of%2Fsfinae_friendly_1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fresult_of%2Fsfinae_friendly_1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fresult_of%2Fsfinae_friendly_1.cc?ref=b3618b716790fec683f2f6aa14225e8a87a50f3b", "patch": "@@ -29,23 +29,27 @@\n // Helper types:\n struct has_type_impl\n {\n-  template<class T, class = typename T::type>\n+  template<typename T, typename = typename T::type>\n   static std::true_type test(int);\n \n-  template<class>\n+  template<typename>\n   static std::false_type test(...);\n };\n \n-template<class T>\n-struct has_type : decltype(has_type_impl::test<T>(0))\n+template<typename T>\n+struct has_type : public decltype(has_type_impl::test<T>(0))\n {};\n \n-template<class T, class Res>\n-struct is_expected_type : std::is_same<typename T::type, Res>\n+template<typename T, typename Res>\n+struct is_expected_type : public std::is_same<typename T::type, Res>\n {};\n \n-template<class T, class Res>\n-struct is_type : std::__and_<has_type<T>, is_expected_type<T, Res>>\n+template<typename P1, typename P2>\n+struct and_ : public std::conditional<P1::value, P2, std::false_type>::type\n+{};\n+\n+template<typename T, typename Res>\n+struct is_type : public and_<has_type<T>, is_expected_type<T, Res>>\n {};\n \n // Types under inspection:\n@@ -76,18 +80,18 @@ typedef void (B::*base_func_void)() const;\n typedef bool (B::*base_func_bool_int)(int) const volatile;\n \n struct ident_functor {\n-  template<class T>\n+  template<typename T>\n   T operator()(T&& x);\n };\n \n-template<class Ret = void>\n+template<typename Ret = void>\n struct variable_functor {\n-  template<class... T>\n+  template<typename... T>\n   Ret operator()(T&&...);\n };\n \n struct ident_functor_noref {\n-  template<class T>\n+  template<typename T>\n   typename std::remove_reference<T>::type operator()(T&& x);\n };\n \n@@ -136,26 +140,26 @@ union PrivateUnion {\n   bool operator()(std::nullptr_t);\n };\n \n-template<class T>\n+template<typename T>\n struct ImplicitTo {\n   operator T();\n };\n \n-template<class>\n+template<typename>\n struct never { static const bool value = false; };\n \n-template<class T>\n+template<typename T>\n struct BrokenTrait {\n   static_assert(never<T>::value, \"Error!\");\n   typedef T type;\n };\n \n-template<class T>\n+template<typename T>\n struct BadSmartPtr : T {\n   T& operator*() const noexcept(typename BrokenTrait<T>::type());\n };\n \n-template<class Ret>\n+template<typename Ret>\n using FuncEllipses = Ret(...);\n \n static_assert(is_type<std::result_of<S(int)>, short>::value, \"Error!\");"}, {"sha": "d566c9305e4c7bb5de9ca2eb2b23318fde7cde19", "filename": "libstdc++-v3/testsuite/20_util/result_of/sfinae_friendly_2.cc", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fresult_of%2Fsfinae_friendly_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3618b716790fec683f2f6aa14225e8a87a50f3b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fresult_of%2Fsfinae_friendly_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fresult_of%2Fsfinae_friendly_2.cc?ref=b3618b716790fec683f2f6aa14225e8a87a50f3b", "patch": "@@ -23,16 +23,16 @@\n #include <type_traits>\n #include <string>\n \n-struct eat { template<class T> eat(T const &) {} };\n+struct eat { template<typename T> eat(T const &) {} };\n struct not_incrementable {};\n \n struct inc {\n- template<class T>\n+ template<typename T>\n  auto operator()(T t) const -> decltype(t++)\n  { return t++; }\n };\n \n-template<class A>\n+template<typename A>\n typename std::result_of<inc(A)>::type // sfinae here\n try_inc(A a) {\n   return inc()(a);\n@@ -43,10 +43,10 @@ try_inc(eat) {\n   return not_incrementable();\n }\n \n-template<class>\n+template<typename>\n struct never { static const bool value = false; };\n \n-template<class T>\n+template<typename T>\n struct Fail\n {\n   static_assert(never<T>::value, \"duh\");\n@@ -55,16 +55,16 @@ struct Fail\n \n struct Fun\n {\n-  template<class T>\n+  template<typename T>\n   typename Fail<T>::type operator()(T)\n   { return 0; }\n };\n \n-template<class T>\n+template<typename T>\n typename std::result_of<Fun(T)>::type foo(T)\n { return 0; }\n \n-template<class>\n+template<typename>\n int foo(...)\n { return 0; }\n "}]}