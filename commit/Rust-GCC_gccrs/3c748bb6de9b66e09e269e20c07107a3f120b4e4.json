{"sha": "3c748bb6de9b66e09e269e20c07107a3f120b4e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M3NDhiYjZkZTliNjZlMDllMjY5ZTIwYzA3MTA3YTNmMTIwYjRlNA==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1999-08-29T10:09:29Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-08-29T10:09:29Z"}, "message": "loop.c (this_loop_info): New variable.\n\n        * loop.c (this_loop_info): New variable.\n        (loop_has_call, loop_has_volatile, loop_has_tablejump,\n        loop_continue, loops_enclosed): Replace with fields in this_loop_info.\n        All uses updated.\n        (prescan_loop, strength_reduce): New argument loop_info.  All callers\n        updated.\n        (scan_loop): New variable loop_info, initialise to address of\n        this_loop_info.\n        (prescan_loop): Set loop_info->vtop if find NOTE_INSN_LOOP_VTOP.\n        Delete variable loop_has_multiple_exit targets and replace with\n        field in this_loop_info.\n        (find_and_verify_loops): Rename this_loop to this_loop_num.\n        (strength_reduce): Delete loop_iteration_info.  Replace variable\n        loop_info with function argument of same name.\n        (insert_bct): Rework test for loop being completely unrolled.\n\n        * loop.h (struct loop_info): New fields num, loops_enclosed,\n        has_call, has_volatile, has_tablejump, has_multiple_exit_targets,\n        has_indirect_jump, and cont.  Redefine use of unroll_number.\n        (loop_unroll_number): Delete.\n\n        * unroll.c (unroll_loop): Store loop unroll count in unroll_number\n        field of loop_info.\n        (loop_iterations): Delete variable vtop and instead use\n        loop_info->vtop computed in prescan_loop.\n\nFrom-SVN: r28961", "tree": {"sha": "081581dadb1ace2082aa33467e7eb70198b0dc67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/081581dadb1ace2082aa33467e7eb70198b0dc67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c748bb6de9b66e09e269e20c07107a3f120b4e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c748bb6de9b66e09e269e20c07107a3f120b4e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c748bb6de9b66e09e269e20c07107a3f120b4e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c748bb6de9b66e09e269e20c07107a3f120b4e4/comments", "author": null, "committer": null, "parents": [{"sha": "ceb45eb8971b1325c407e74d0aa914c916a822c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceb45eb8971b1325c407e74d0aa914c916a822c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ceb45eb8971b1325c407e74d0aa914c916a822c5"}], "stats": {"total": 268, "additions": 141, "deletions": 127}, "files": [{"sha": "51a11005d9df47f45e6b4337e35edea762829ffb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c748bb6de9b66e09e269e20c07107a3f120b4e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c748bb6de9b66e09e269e20c07107a3f120b4e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c748bb6de9b66e09e269e20c07107a3f120b4e4", "patch": "@@ -1,3 +1,31 @@\n+1999-08-29  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* loop.c (this_loop_info): New variable.\n+\t(loop_has_call, loop_has_volatile, loop_has_tablejump,\n+\tloop_continue, loops_enclosed): Replace with fields in this_loop_info.\n+\tAll uses updated.\n+\t(prescan_loop, strength_reduce): New argument loop_info.  All callers\n+\tupdated.\n+\t(scan_loop): New variable loop_info, initialise to address of\n+\tthis_loop_info.\n+\t(prescan_loop): Set loop_info->vtop if find NOTE_INSN_LOOP_VTOP.\n+\tDelete variable loop_has_multiple_exit targets and replace with\n+\tfield in this_loop_info.\n+\t(find_and_verify_loops): Rename this_loop to this_loop_num.\n+\t(strength_reduce): Delete loop_iteration_info.  Replace variable\n+\tloop_info with function argument of same name.\n+\t(insert_bct): Rework test for loop being completely unrolled.\n+\n+\t* loop.h (struct loop_info): New fields num, loops_enclosed,\n+\thas_call, has_volatile, has_tablejump, has_multiple_exit_targets,\n+\thas_indirect_jump, and cont.  Redefine use of unroll_number.\n+\t(loop_unroll_number): Delete.\n+\n+\t* unroll.c (unroll_loop): Store loop unroll count in unroll_number\n+\tfield of loop_info.\n+\t(loop_iterations): Delete variable vtop and instead use\n+\tloop_info->vtop computed in prescan_loop.\n+\n Sun Aug 29 03:27:23 1999  Scott Weikart <scott@igc.apc.org>\n \n \t* fix-header.c (main): Do not pass a null pointer to strcmp."}, {"sha": "a3b2bb0271ec5494b859b7c933b014bbd899078e", "filename": "gcc/loop.c", "status": "modified", "additions": 90, "deletions": 91, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c748bb6de9b66e09e269e20c07107a3f120b4e4/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c748bb6de9b66e09e269e20c07107a3f120b4e4/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=3c748bb6de9b66e09e269e20c07107a3f120b4e4", "patch": "@@ -51,6 +51,11 @@ Boston, MA 02111-1307, USA.  */\n #include \"except.h\"\n #include \"toplev.h\"\n \n+/* Information about the loop being processed used to compute\n+   the number of loop iterations for loop unrolling and doloop\n+   optimization.  */\n+static struct loop_info this_loop_info;\n+\n /* Vector mapping INSN_UIDs to luids.\n    The luids are like uids but increase monotonically always.\n    We use them to see whether a jump comes from outside a given loop.  */\n@@ -121,25 +126,6 @@ rtx *loop_number_exit_labels;\n \n int *loop_number_exit_count;\n \n-/* Nonzero if there is a subroutine call in the current loop.  */\n-\n-static int loop_has_call;\n-\n-/* Nonzero if there is a volatile memory reference in the current\n-   loop.  */\n-\n-static int loop_has_volatile;\n-\n-/* Nonzero if there is a tablejump in the current loop.  */\n-\n-static int loop_has_tablejump;\n-\n-/* Added loop_continue which is the NOTE_INSN_LOOP_CONT of the\n-   current loop.  A continue statement will generate a branch to\n-   NEXT_INSN (loop_continue).  */\n-\n-static rtx loop_continue;\n-\n /* Indexed by register number, contains the number of times the reg\n    is set during the loop being scanned.\n    During code motion, a negative value indicates a reg that has been\n@@ -203,9 +189,10 @@ static int loop_mems_idx;\n \n static int loop_mems_allocated;\n \n-/* Nonzero if we don't know what MEMs were changed in the current loop.\n-   This happens if the loop contains a call (in which case `loop_has_call'\n-   will also be set) or if we store into more than NUM_STORES MEMs.  */\n+/* Nonzero if we don't know what MEMs were changed in the current\n+   loop.  This happens if the loop contains a call (in which case\n+   `loop_info->has_call' will also be set) or if we store into more\n+   than NUM_STORES MEMs.  */\n \n static int unknown_address_altered;\n \n@@ -215,9 +202,6 @@ static int num_movables;\n /* Count of memory write instructions discovered in the loop.  */\n static int num_mem_sets;\n \n-/* Number of loops contained within the current one, including itself.  */\n-static int loops_enclosed;\n-\n /* Bound on pseudo register number before loop optimization.\n    A pseudo has valid regscan info if its number is < max_reg_before_loop.  */\n int max_reg_before_loop;\n@@ -289,7 +273,7 @@ FILE *loop_dump_stream;\n static void verify_dominator PROTO((int));\n static void find_and_verify_loops PROTO((rtx));\n static void mark_loop_jump PROTO((rtx, int));\n-static void prescan_loop PROTO((rtx, rtx));\n+static void prescan_loop PROTO((rtx, rtx, struct loop_info *));\n static int reg_in_basic_block_p PROTO((rtx, rtx));\n static int consec_sets_invariant_p PROTO((rtx, int, rtx));\n static int labels_in_range_p PROTO((rtx, int));\n@@ -313,7 +297,8 @@ static int rtx_equal_for_loop_p PROTO((rtx, rtx, struct movable *));\n static void add_label_notes PROTO((rtx, rtx));\n static void move_movables PROTO((struct movable *, int, int, rtx, rtx, int));\n static int count_nonfixed_reads PROTO((rtx));\n-static void strength_reduce PROTO((rtx, rtx, rtx, int, rtx, rtx, rtx, int, int));\n+static void strength_reduce PROTO((rtx, rtx, rtx, int, rtx, rtx, \n+\t\t\t\t   struct loop_info *, rtx, int, int));\n static void find_single_use_in_loop PROTO((rtx, rtx, varray_type));\n static int valid_initial_value_p PROTO((rtx, rtx, int, rtx));\n static void find_mem_givs PROTO((rtx, rtx, int, rtx, rtx));\n@@ -665,6 +650,7 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n   /* Nonzero if we are scanning instructions in a sub-loop.  */\n   int loop_depth = 0;\n   int nregs;\n+  struct loop_info *loop_info = &this_loop_info;\n \n   /* Determine whether this loop starts with a jump down to a test at\n      the end.  This will occur for a small number of loops with a test\n@@ -694,8 +680,8 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n   scan_start = p;\n \n   /* Set up variables describing this loop.  */\n-  prescan_loop (loop_start, end);\n-  threshold = (loop_has_call ? 1 : 2) * (1 + n_non_fixed_regs);\n+  prescan_loop (loop_start, end, loop_info);\n+  threshold = (loop_info->has_call ? 1 : 2) * (1 + n_non_fixed_regs);\n \n   /* If loop has a jump before the first label,\n      the true entry is the target of that jump.\n@@ -778,9 +764,9 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n     {\n       fprintf (loop_dump_stream, \"\\nLoop from %d to %d: %d real insns.\\n\",\n \t       INSN_UID (loop_start), INSN_UID (end), insn_count);\n-      if (loop_continue)\n+      if (loop_info->cont)\n \tfprintf (loop_dump_stream, \"Continue at insn %d.\\n\",\n-\t\t INSN_UID (loop_continue));\n+\t\t INSN_UID (loop_info->cont));\n     }\n \n   /* Scan through the loop finding insns that are safe to move.\n@@ -907,7 +893,7 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n \t\t Don't do this if P has a REG_RETVAL note or if we have\n \t\t SMALL_REGISTER_CLASSES and SET_SRC is a hard register.  */\n \n-\t      if (loop_has_call\n+\t      if (loop_info->has_call\n \t\t  && VARRAY_RTX (reg_single_usage, regno) != 0\n \t\t  && VARRAY_RTX (reg_single_usage, regno) != const0_rtx\n \t\t  && REGNO_FIRST_UID (regno) == INSN_UID (p)\n@@ -1171,7 +1157,8 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n     {\n       the_movables = movables;\n       strength_reduce (scan_start, end, loop_top,\n-\t\t       insn_count, loop_start, end, loop_cont, unroll_p, bct_p);\n+\t\t       insn_count, loop_start, end,\n+\t\t       loop_info, loop_cont, unroll_p, bct_p);\n     }\n \n   VARRAY_FREE (reg_single_usage);\n@@ -1692,7 +1679,7 @@ rtx_equal_for_loop_p (x, y, movables)\n }\n \f\n /* If X contains any LABEL_REF's, add REG_LABEL notes for them to all\n-  insns in INSNS which use thet reference.  */\n+  insns in INSNS which use the reference.  */\n \n static void\n add_label_notes (x, insns)\n@@ -2392,37 +2379,40 @@ constant_high_bytes (p, loop_start)\n }\n #endif\n \f\n-/* Scan a loop setting the variables `unknown_address_altered',\n-   `num_mem_sets', `loop_continue', `loops_enclosed', `loop_has_call',\n-   `loop_has_volatile', and `loop_has_tablejump'.\n-   Also, fill in the array `loop_mems' and the list `loop_store_mems'.  */\n+/* Scan a loop setting the elements `cont', `vtop', `loops_enclosed',\n+   `has_call', `has_volatile', and `has_tablejump' within LOOP_INFO.\n+   Set the global variables `unknown_address_altered' and\n+   `num_mem_sets'.  Also, fill in the array `loop_mems' and the list\n+   `loop_store_mems'.  */\n \n static void\n-prescan_loop (start, end)\n+prescan_loop (start, end, loop_info)\n      rtx start, end;\n+     struct loop_info *loop_info;\n {\n   register int level = 1;\n   rtx insn;\n-  int loop_has_multiple_exit_targets = 0;\n   /* The label after END.  Jumping here is just like falling off the\n      end of the loop.  We use next_nonnote_insn instead of next_label\n      as a hedge against the (pathological) case where some actual insn\n      might end up between the two.  */\n   rtx exit_target = next_nonnote_insn (end);\n-  if (exit_target == NULL_RTX || GET_CODE (exit_target) != CODE_LABEL)\n-    loop_has_multiple_exit_targets = 1;\n+\n+  loop_info->num = uid_loop_num [INSN_UID (start)];\n+  loop_info->has_indirect_jump = indirect_jump_in_function;\n+  loop_info->has_call = 0;\n+  loop_info->has_volatile = 0;\n+  loop_info->has_tablejump = 0;\n+  loop_info->loops_enclosed = 1;\n+  loop_info->has_multiple_exit_targets = 0;\n+  loop_info->cont = 0;\n+  loop_info->vtop = 0;\n \n   unknown_address_altered = 0;\n-  loop_has_call = 0;\n-  loop_has_volatile = 0;\n-  loop_has_tablejump = 0;\n   loop_store_mems = NULL_RTX;\n   first_loop_store_insn = NULL_RTX;\n   loop_mems_idx = 0;\n-\n   num_mem_sets = 0;\n-  loops_enclosed = 1;\n-  loop_continue = 0;\n \n   for (insn = NEXT_INSN (start); insn != NEXT_INSN (end);\n        insn = NEXT_INSN (insn))\n@@ -2433,7 +2423,7 @@ prescan_loop (start, end)\n \t    {\n \t      ++level;\n \t      /* Count number of loops contained in this one.  */\n-\t      loops_enclosed++;\n+\t      loop_info->loops_enclosed++;\n \t    }\n \t  else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n \t    {\n@@ -2447,33 +2437,42 @@ prescan_loop (start, end)\n \t  else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_CONT)\n \t    {\n \t      if (level == 1)\n-\t\tloop_continue = insn;\n+\t\tloop_info->cont = insn;\n+\t    }\n+\t  else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_VTOP)\n+\t    {\n+\t      /* If there is a NOTE_INSN_LOOP_VTOP, then this is a for\n+\t\t or while style loop, with a loop exit test at the\n+\t\t start.  Thus, we can assume that the loop condition\n+\t\t was true when the loop was entered.  */\n+\t      if (level == 1)\n+\t\tloop_info->vtop = insn;\n \t    }\n \t}\n       else if (GET_CODE (insn) == CALL_INSN)\n \t{\n \t  if (! CONST_CALL_P (insn))\n \t    unknown_address_altered = 1;\n-\t  loop_has_call = 1;\n+\t  loop_info->has_call = 1;\n \t}\n       else if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN)\n \t{\n \t  rtx label1 = NULL_RTX;\n \t  rtx label2 = NULL_RTX;\n \n \t  if (volatile_refs_p (PATTERN (insn)))\n-\t    loop_has_volatile = 1;\n+\t    loop_info->has_volatile = 1;\n \n \t  if (GET_CODE (insn) == JUMP_INSN\n \t      && (GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC\n \t\t  || GET_CODE (PATTERN (insn)) == ADDR_VEC))\n-\t    loop_has_tablejump = 1;\n+\t    loop_info->has_tablejump = 1;\n \t  \n \t  note_stores (PATTERN (insn), note_addr_stored);\n \t  if (! first_loop_store_insn && loop_store_mems)\n \t    first_loop_store_insn = insn;\n \n-\t  if (! loop_has_multiple_exit_targets\n+\t  if (! loop_info->has_multiple_exit_targets\n \t      && GET_CODE (insn) == JUMP_INSN\n \t      && GET_CODE (PATTERN (insn)) == SET\n \t      && SET_DEST (PATTERN (insn)) == pc_rtx)\n@@ -2494,14 +2493,14 @@ prescan_loop (start, end)\n \t\t    if (GET_CODE (label1) != LABEL_REF)\n \t\t      {\n \t\t\t/* Something tricky.  */\n-\t\t\tloop_has_multiple_exit_targets = 1;\n+\t\t\tloop_info->has_multiple_exit_targets = 1;\n \t\t\tbreak;\n \t\t      }\n \t\t    else if (XEXP (label1, 0) != exit_target\n \t\t\t     && LABEL_OUTSIDE_LOOP_P (label1))\n \t\t      {\n \t\t\t/* A jump outside the current loop.  */\n-\t\t\tloop_has_multiple_exit_targets = 1;\n+\t\t\tloop_info->has_multiple_exit_targets = 1;\n \t\t\tbreak;\n \t\t      }\n \t\t  }\n@@ -2512,23 +2511,23 @@ prescan_loop (start, end)\n \t    }\n \t}\n       else if (GET_CODE (insn) == RETURN)\n-\tloop_has_multiple_exit_targets = 1;\n+\tloop_info->has_multiple_exit_targets = 1;\n     }\n \n   /* Now, rescan the loop, setting up the LOOP_MEMS array.  */\n   if (/* We can't tell what MEMs are aliased by what.  */\n       !unknown_address_altered \n       /* An exception thrown by a called function might land us\n \t anywhere.  */\n-      && !loop_has_call\n+      && !loop_info->has_call\n       /* We don't want loads for MEMs moved to a location before the\n \t one at which their stack memory becomes allocated.  (Note\n \t that this is not a problem for malloc, etc., since those\n \t require actual function calls.  */\n       && !current_function_calls_alloca\n       /* There are ways to leave the loop other than falling off the\n \t end.  */\n-      && !loop_has_multiple_exit_targets)\n+      && !loop_info->has_multiple_exit_targets)\n     for (insn = NEXT_INSN (start); insn != NEXT_INSN (end);\n \t insn = NEXT_INSN (insn))\n       for_each_rtx (&insn, insert_loop_mem, 0);\n@@ -2662,41 +2661,41 @@ find_and_verify_loops (f)\n \t       && GET_CODE (PATTERN (insn)) != RETURN\n \t       && current_loop >= 0)\n \t{\n-\t  int this_loop;\n+\t  int this_loop_num;\n \t  rtx label = JUMP_LABEL (insn);\n \n \t  if (! condjump_p (insn) && ! condjump_in_parallel_p (insn))\n \t    label = NULL_RTX;\n \n-\t  this_loop = current_loop;\n+\t  this_loop_num = current_loop;\n \t  do\n \t    {\n \t      /* First see if we care about this loop.  */\n-\t      if (loop_number_loop_cont[this_loop]\n-\t\t  && loop_number_cont_dominator[this_loop] != const0_rtx)\n+\t      if (loop_number_loop_cont[this_loop_num]\n+\t\t  && loop_number_cont_dominator[this_loop_num] != const0_rtx)\n \t\t{\n \t\t  /* If the jump destination is not known, invalidate\n \t\t     loop_number_const_dominator.  */\n \t\t  if (! label)\n-\t\t    loop_number_cont_dominator[this_loop] = const0_rtx;\n+\t\t    loop_number_cont_dominator[this_loop_num] = const0_rtx;\n \t\t  else\n \t\t    /* Check if the destination is between loop start and\n \t\t       cont.  */\n \t\t    if ((INSN_LUID (label)\n-\t\t\t < INSN_LUID (loop_number_loop_cont[this_loop]))\n+\t\t\t < INSN_LUID (loop_number_loop_cont[this_loop_num]))\n \t\t\t&& (INSN_LUID (label)\n-\t\t\t    > INSN_LUID (loop_number_loop_starts[this_loop]))\n+\t\t\t    > INSN_LUID (loop_number_loop_starts[this_loop_num]))\n \t\t\t/* And if there is no later destination already\n \t\t\t   recorded.  */\n-\t\t\t&& (! loop_number_cont_dominator[this_loop]\n+\t\t\t&& (! loop_number_cont_dominator[this_loop_num]\n \t\t\t    || (INSN_LUID (label)\n \t\t\t\t> INSN_LUID (loop_number_cont_dominator\n-\t\t\t\t\t     [this_loop]))))\n-\t\t      loop_number_cont_dominator[this_loop] = label;\n+\t\t\t\t\t     [this_loop_num]))))\n+\t\t      loop_number_cont_dominator[this_loop_num] = label;\n \t\t}\n-\t      this_loop = loop_outer_loop[this_loop];\n+\t      this_loop_num = loop_outer_loop[this_loop_num];\n \t    }\n-\t  while (this_loop >= 0);\n+\t  while (this_loop_num >= 0);\n \t}\n \n       /* Note that this will mark the NOTE_INSN_LOOP_END note as being in the\n@@ -3207,7 +3206,7 @@ invariant_p (x)\n \t  && ! current_function_has_nonlocal_goto)\n \treturn 1;\n \n-      if (loop_has_call\n+      if (this_loop_info.has_call\n \t  && REGNO (x) < FIRST_PSEUDO_REGISTER && call_used_regs[REGNO (x)])\n \treturn 0;\n \n@@ -3662,13 +3661,14 @@ static rtx addr_placeholder;\n \n static void\n strength_reduce (scan_start, end, loop_top, insn_count,\n-\t\t loop_start, loop_end, loop_cont, unroll_p, bct_p)\n+\t\t loop_start, loop_end, loop_info, loop_cont, unroll_p, bct_p)\n      rtx scan_start;\n      rtx end;\n      rtx loop_top;\n      int insn_count;\n      rtx loop_start;\n      rtx loop_end;\n+     struct loop_info *loop_info;\n      rtx loop_cont;\n      int unroll_p, bct_p ATTRIBUTE_UNUSED;\n {\n@@ -3694,7 +3694,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n      since in that case saving an insn makes more difference\n      and more registers are available.  */\n   /* ??? could set this to last value of threshold in move_movables */\n-  int threshold = (loop_has_call ? 1 : 2) * (3 + n_non_fixed_regs);\n+  int threshold = (loop_info->has_call ? 1 : 2) * (3 + n_non_fixed_regs);\n   /* Map of pseudo-register replacements.  */\n   rtx *reg_map;\n   int reg_map_size;\n@@ -3703,8 +3703,6 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n   rtx end_insert_before;\n   int loop_depth = 0;\n   int n_extra_increment;\n-  struct loop_info loop_iteration_info;\n-  struct loop_info *loop_info = &loop_iteration_info;\n   int unrolled_insn_copies;\n \n   /* If scan_start points to the loop exit test, we have to be wary of\n@@ -4158,7 +4156,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \n   /* If the loop contains volatile memory references do not allow any\n      replacements to take place, since this could loose the volatile markers.  */\n-  if (n_extra_increment  && ! loop_has_volatile)\n+  if (n_extra_increment  && ! loop_info->has_volatile)\n     {\n       int nregs = first_increment_giv + n_extra_increment;\n \n@@ -4572,7 +4570,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n       int benefit;\n       int all_reduced;\n       rtx final_value = 0;\n-      unsigned nregs;\n+      unsigned int nregs;\n \n       /* Test whether it will be possible to eliminate this biv\n \t provided all givs are reduced.  This is possible if either\n@@ -6034,7 +6032,7 @@ basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val, location)\n       /* convert_modes aborts if we try to convert to or from CCmode, so just\n          exclude that case.  It is very unlikely that a condition code value\n \t would be a useful iterator anyways.  */\n-      if (loops_enclosed == 1\n+      if (this_loop_info.loops_enclosed == 1\n \t  && GET_MODE_CLASS (mode) != MODE_CC\n \t  && GET_MODE_CLASS (GET_MODE (dest_reg)) != MODE_CC)\n  \t{\n@@ -7896,8 +7894,8 @@ check_dbra_loop (loop_end, insn_count, loop_start, loop_info)\n \t about all these things.  */\n \n       if ((num_nonfixed_reads <= 1\n-\t   && !loop_has_call\n-\t   && !loop_has_volatile\n+\t   && ! loop_info->has_call\n+\t   && ! loop_info->has_volatile\n \t   && reversible_mem_store\n \t   && (bl->giv_count + bl->biv_count + num_mem_sets\n \t      + num_movables + compare_and_branch == insn_count)\n@@ -7925,7 +7923,7 @@ check_dbra_loop (loop_end, insn_count, loop_start, loop_info)\n \t\t  || (GET_CODE (comparison) == LE\n \t\t      && no_use_except_counting)))\n \t    {\n-\t      HOST_WIDE_INT add_val, add_adjust, comparison_val = 0;\n+\t      HOST_WIDE_INT add_val, add_adjust, comparison_val;\n \t      rtx initial_value, comparison_value;\n \t      int nonneg = 0;\n \t      enum rtx_code cmp_code;\n@@ -7983,12 +7981,13 @@ check_dbra_loop (loop_end, insn_count, loop_start, loop_info)\n \n \t      /* First check if we can do a vanilla loop reversal.  */\n \t      if (initial_value == const0_rtx\n-\t\t  /* If we have a decrement_and_branch_on_count, prefer\n-\t\t     the NE test, since this will allow that instruction to\n-\t\t     be generated.  Note that we must use a vanilla loop\n-\t\t     reversal if the biv is used to calculate a giv or has\n-\t\t     a non-counting use.  */\n-#if ! defined (HAVE_decrement_and_branch_until_zero) && defined (HAVE_decrement_and_branch_on_count)\n+\t\t  /* If we have a decrement_and_branch_on_count,\n+\t\t     prefer the NE test, since this will allow that\n+\t\t     instruction to be generated.  Note that we must\n+\t\t     use a vanilla loop reversal if the biv is used to\n+\t\t     calculate a giv or has a non-counting use.  */\n+#if ! defined (HAVE_decrement_and_branch_until_zero) \\\n+&& defined (HAVE_decrement_and_branch_on_count)\n \t\t  && (! (add_val == 1 && loop_info->vtop\n \t\t         && (bl->biv_count == 0\n \t\t\t     || no_use_except_counting)))\n@@ -9116,7 +9115,7 @@ insert_bct (loop_start, loop_end, loop_info)\n   int loop_num = uid_loop_num [INSN_UID (loop_start)];\n \n   /* It's impossible to instrument a competely unrolled loop.  */\n-  if (loop_info->unroll_number == -1)\n+  if (loop_info->unroll_number == loop_info->n_iterations)\n     return;\n \n   /* Make sure that the count register is not in use.  */\n@@ -9153,7 +9152,7 @@ insert_bct (loop_start, loop_end, loop_info)\n \n   /* Make sure that the loop does not contain a function call\n      (the count register might be altered by the called function).  */\n-  if (loop_has_call)\n+  if (loop_info->has_call)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n@@ -9164,7 +9163,7 @@ insert_bct (loop_start, loop_end, loop_info)\n \n   /* Make sure that the loop does not jump via a table.\n      (the count register might be used to perform the branch on table).  */\n-  if (loop_has_tablejump)\n+  if (loop_info->has_tablejump)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,"}, {"sha": "2578956bd9532ff7a3be33854783344de5e6bbbf", "filename": "gcc/loop.h", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c748bb6de9b66e09e269e20c07107a3f120b4e4/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c748bb6de9b66e09e269e20c07107a3f120b4e4/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=3c748bb6de9b66e09e269e20c07107a3f120b4e4", "patch": "@@ -158,6 +158,22 @@ struct iv_class {\n \n struct loop_info\n {\n+  /* Loop number.  */\n+  int num;\n+  /* Loops enclosed by this loop including itself.  */\n+  int loops_enclosed;\n+  /* Nonzero if there is a subroutine call in the current loop.  */\n+  int has_call;\n+  /* Nonzero if there is a volatile memory reference in the current\n+     loop.  */\n+  int has_volatile;\n+  /* Nonzero if there is a tablejump in the current loop.  */\n+  int has_tablejump;\n+  /* Nonzero if there are ways to leave the loop other than falling\n+     off the end.  */\n+  int has_multiple_exit_targets;\n+  /* Nonzero if there is an indirect jump in the current function.  */\n+  int has_indirect_jump;\n   /* Register or constant initial loop value.  */\n   rtx initial_value;\n   /* Register or constant value used for comparison test.  */\n@@ -181,15 +197,13 @@ struct loop_info\n      wider iterator, this number will be zero if the number of loop\n      iterations is too large for an unsigned integer to hold.  */\n   unsigned HOST_WIDE_INT n_iterations;\n-  /* The loop unrolling factor.\n-     Potential values:\n-     0: unrolled\n-     1: not unrolled.\n-     -1: completely unrolled\n-     >0: holds the unroll exact factor.  */\n+  /* The number of times the loop body was unrolled.  */\n   unsigned int unroll_number;\n   /* Non-zero if the loop has a NOTE_INSN_LOOP_VTOP.  */\n   rtx vtop;\n+  /* Non-zero if the loop has a NOTE_INSN_LOOP_CONT.\n+     A continue statement will generate a branch to NEXT_INSN (cont).  */\n+  rtx cont;\n };\n \n /* Definitions used by the basic induction variable discovery code.  */\n@@ -240,10 +254,10 @@ rtx final_giv_value PROTO((struct induction *, rtx, rtx,\n \t\t\t   unsigned HOST_WIDE_INT));\n void emit_unrolled_add PROTO((rtx, rtx, rtx));\n int back_branch_in_range_p PROTO((rtx, rtx, rtx));\n-int loop_insn_first_p PROTO((rtx, rtx));\n \n-extern int *loop_unroll_number;\n+int loop_insn_first_p PROTO((rtx, rtx));\n \n /* Forward declarations for non-static functions declared in stmt.c.  */\n void find_loop_tree_blocks PROTO((void));\n void unroll_block_trees PROTO((void));\n+"}, {"sha": "23932fba115304dcaf086a2e6141c4c0f70841c2", "filename": "gcc/unroll.c", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c748bb6de9b66e09e269e20c07107a3f120b4e4/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c748bb6de9b66e09e269e20c07107a3f120b4e4/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=3c748bb6de9b66e09e269e20c07107a3f120b4e4", "patch": "@@ -1117,11 +1117,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n   /* At this point, we are guaranteed to unroll the loop.  */\n \n   /* Keep track of the unroll factor for the loop.  */\n-  if (unroll_type == UNROLL_COMPLETELY)\n-    loop_info->unroll_number = -1;\n-  else\n-    loop_info->unroll_number = unroll_number;\n-\n+  loop_info->unroll_number = unroll_number;\n \n   /* For each biv and giv, determine whether it can be safely split into\n      a different variable for each unrolled copy of the loop body.\n@@ -3500,7 +3496,6 @@ loop_find_equiv_value (loop_start, reg)\n   return ret;\n }\n \n-\n /* Return a simplified rtx for the expression OP - REG.\n \n    REG must appear in OP, and OP must be a register or the sum of a register\n@@ -3566,7 +3561,6 @@ find_common_reg_term (op0, op1)\n   return NULL_RTX;\n }\n \n-\n /* Calculate the number of loop iterations.  Returns the exact number of loop\n    iterations if it can be calculated, otherwise returns zero.  */\n \n@@ -3584,7 +3578,6 @@ loop_iterations (loop_start, loop_end, loop_info)\n   int increment_dir;\n   int unsigned_p, compare_dir, final_larger;\n   rtx last_loop_insn;\n-  rtx vtop;\n   rtx reg_term;\n \n   loop_info->n_iterations = 0;\n@@ -3596,7 +3589,6 @@ loop_iterations (loop_start, loop_end, loop_info)\n   loop_info->increment = 0;\n   loop_info->iteration_var = 0;\n   loop_info->unroll_number = 1;\n-  loop_info->vtop = 0;\n \n   /* We used to use prev_nonnote_insn here, but that fails because it might\n      accidentally get the branch for a contained loop if the branch for this\n@@ -3645,25 +3637,6 @@ loop_iterations (loop_start, loop_end, loop_info)\n   iteration_var = XEXP (comparison, 0);\n   comparison_value = XEXP (comparison, 1);\n \n-  /* Check if there is a NOTE_INSN_LOOP_VTOP note.  If there is,\n-     that means that this is a for or while style loop, with\n-     a loop exit test at the start.  Thus, we can assume that\n-     the loop condition was true when the loop was entered.\n-\n-     We start at the end and search backwards for the previous\n-     NOTE.  If there is no NOTE_INSN_LOOP_VTOP for this loop,\n-     the search will stop at the NOTE_INSN_LOOP_CONT.  */\n-  vtop = loop_end;\n-  do\n-    vtop = PREV_INSN (vtop);\n-  while (GET_CODE (vtop) != NOTE\n-\t || NOTE_LINE_NUMBER (vtop) > 0\n-\t || NOTE_LINE_NUMBER (vtop) == NOTE_REPEATED_LINE_NUMBER\n-\t || NOTE_LINE_NUMBER (vtop) == NOTE_INSN_DELETED);\n-  if (NOTE_LINE_NUMBER (vtop) != NOTE_INSN_LOOP_VTOP)\n-    vtop = NULL_RTX;\n-  loop_info->vtop = vtop;\n-\n   if (GET_CODE (iteration_var) != REG)\n     {\n       if (loop_dump_stream)"}]}