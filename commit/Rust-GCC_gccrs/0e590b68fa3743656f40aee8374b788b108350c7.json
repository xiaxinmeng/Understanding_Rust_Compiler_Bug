{"sha": "0e590b68fa3743656f40aee8374b788b108350c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU1OTBiNjhmYTM3NDM2NTZmNDBhZWU4Mzc0Yjc4OGIxMDgzNTBjNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-22T15:32:32Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-22T15:32:32Z"}, "message": "Materialize clones on demand\n\nthis patch removes the pass to materialize all clones and instead this\nis now done on demand.  The motivation is to reduce lifetime of function\nbodies in ltrans that should noticeably reduce memory use for highly\nparallel compilations of large programs (like Martin does) or with\npartitioning reduced/disabled. For cc1 with one partition the memory use\nseems to go down from 4gb to cca 1.5gb (seeing from top, so this is not\nparticularly accurate).\n\ngcc/ChangeLog:\n\n2020-10-22  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* cgraph.c (cgraph_node::get_untransformed_body): Perform lazy\n\tclone materialization.\n\t* cgraph.h (cgraph_node::materialize_clone): Declare.\n\t(symbol_table::materialize_all_clones): Remove.\n\t* cgraphclones.c (cgraph_materialize_clone): Turn to ...\n\t(cgraph_node::materialize_clone): .. this one; move here\n\tdumping from symbol_table::materialize_all_clones.\n\t(symbol_table::materialize_all_clones): Remove.\n\t* cgraphunit.c (mark_functions_to_output): Clear stmt references.\n\t(cgraph_node::expand): Initialize bitmaps early;\n\tdo not call execute_all_ipa_transforms if there are no transforms.\n\t* ipa-inline-transform.c (save_inline_function_body): Fix formating.\n\t(inline_transform): Materialize all clones before function is modified.\n\t* ipa-param-manipulation.c (ipa_param_adjustments::modify_call):\n\tMaterialize clone if needed.\n\t* ipa.c (class pass_materialize_all_clones): Remove.\n\t(make_pass_materialize_all_clones): Remove.\n\t* passes.c (execute_all_ipa_transforms): Materialize all clones.\n\t* passes.def: Remove pass_materialize_all_clones.\n\t* tree-pass.h (make_pass_materialize_all_clones): Remove.\n\t* tree-ssa-structalias.c (ipa_pta_execute): Clear refs.", "tree": {"sha": "1183a176f4543e9e141d2a2657e1212e6f1dc7af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1183a176f4543e9e141d2a2657e1212e6f1dc7af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e590b68fa3743656f40aee8374b788b108350c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e590b68fa3743656f40aee8374b788b108350c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e590b68fa3743656f40aee8374b788b108350c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e590b68fa3743656f40aee8374b788b108350c7/comments", "author": null, "committer": null, "parents": [{"sha": "c26d7df103197e52dcd6edbb9a7f58eafdd6c715", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c26d7df103197e52dcd6edbb9a7f58eafdd6c715", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c26d7df103197e52dcd6edbb9a7f58eafdd6c715"}], "stats": {"total": 253, "additions": 94, "deletions": 159}, "files": [{"sha": "067984d773cc34393ad6624d3ef2a65217d090bc", "filename": "gcc/cgraph.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e590b68fa3743656f40aee8374b788b108350c7/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e590b68fa3743656f40aee8374b788b108350c7/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=0e590b68fa3743656f40aee8374b788b108350c7", "patch": "@@ -3872,16 +3872,27 @@ cgraph_node::function_or_virtual_thunk_symbol\n }\n \n /* When doing LTO, read cgraph_node's body from disk if it is not already\n-   present.  */\n+   present.  Also perform any necessary clone materializations.  */\n \n bool\n-cgraph_node::get_untransformed_body (void)\n+cgraph_node::get_untransformed_body ()\n {\n   lto_file_decl_data *file_data;\n   const char *data, *name;\n   size_t len;\n   tree decl = this->decl;\n \n+  /* See if there is clone to be materialized.\n+     (inline clones does not need materialization, but we can be seeing\n+      an inline clone of real clone).  */\n+  cgraph_node *p = this;\n+  for (cgraph_node *c = clone_of; c; c = c->clone_of)\n+    {\n+      if (c->decl != decl)\n+\tp->materialize_clone ();\n+      p = c;\n+    }\n+\n   /* Check if body is already there.  Either we have gimple body or\n      the function is thunk and in that case we set DECL_ARGUMENTS.  */\n   if (DECL_ARGUMENTS (decl) || gimple_has_body_p (decl))"}, {"sha": "6c4503427644113645049d26a69f6b162234bd78", "filename": "gcc/cgraph.h", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e590b68fa3743656f40aee8374b788b108350c7/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e590b68fa3743656f40aee8374b788b108350c7/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=0e590b68fa3743656f40aee8374b788b108350c7", "patch": "@@ -1145,12 +1145,14 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n \n   /* When doing LTO, read cgraph_node's body from disk if it is not already\n      present.  */\n-  bool get_untransformed_body (void);\n+  bool get_untransformed_body ();\n \n   /* Prepare function body.  When doing LTO, read cgraph_node's body from disk \n      if it is not already present.  When some IPA transformations are scheduled,\n      apply them.  */\n-  bool get_body (void);\n+  bool get_body ();\n+\n+  void materialize_clone (void);\n \n   /* Release memory used to represent body of function.\n      Use this only for functions that are released before being translated to\n@@ -2286,13 +2288,6 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n      functions inserted into callgraph already at construction time.  */\n   void process_new_functions (void);\n \n-  /* Once all functions from compilation unit are in memory, produce all clones\n-     and update all calls.  We might also do this on demand if we don't want to\n-     bring all functions to memory prior compilation, but current WHOPR\n-     implementation does that and it is bit easier to keep everything right\n-     in this order.  */\n-  void materialize_all_clones (void);\n-\n   /* Register a symbol NODE.  */\n   inline void register_symbol (symtab_node *node);\n "}, {"sha": "07a51a58aef9a8bc1ae18ccc76086a1ef670706e", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 40, "deletions": 97, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e590b68fa3743656f40aee8374b788b108350c7/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e590b68fa3743656f40aee8374b788b108350c7/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=0e590b68fa3743656f40aee8374b788b108350c7", "patch": "@@ -1083,114 +1083,57 @@ void cgraph_node::remove_from_clone_tree ()\n \n /* Given virtual clone, turn it into actual clone.  */\n \n-static void\n-cgraph_materialize_clone (cgraph_node *node)\n-{\n-  bitmap_obstack_initialize (NULL);\n-  node->former_clone_of = node->clone_of->decl;\n-  if (node->clone_of->former_clone_of)\n-    node->former_clone_of = node->clone_of->former_clone_of;\n-  /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n-  tree_function_versioning (node->clone_of->decl, node->decl,\n-\t\t\t    node->clone.tree_map, node->clone.param_adjustments,\n-\t\t\t    true, NULL, NULL);\n-  if (symtab->dump_file)\n-    {\n-      dump_function_to_file (node->clone_of->decl, symtab->dump_file,\n-\t\t\t     dump_flags);\n-      dump_function_to_file (node->decl, symtab->dump_file, dump_flags);\n-    }\n-\n-  cgraph_node *clone_of = node->clone_of;\n-  /* Function is no longer clone.  */\n-  node->remove_from_clone_tree ();\n-  if (!clone_of->analyzed && !clone_of->clones)\n-    {\n-      clone_of->release_body ();\n-      clone_of->remove_callees ();\n-      clone_of->remove_all_references ();\n-    }\n-  bitmap_obstack_release (NULL);\n-}\n-\n-/* Once all functions from compilation unit are in memory, produce all clones\n-   and update all calls.  We might also do this on demand if we don't want to\n-   bring all functions to memory prior compilation, but current WHOPR\n-   implementation does that and it is a bit easier to keep everything right in\n-   this order.  */\n-\n void\n-symbol_table::materialize_all_clones (void)\n+cgraph_node::materialize_clone ()\n {\n-  cgraph_node *node;\n-  bool stabilized = false;\n-  \n-\n+  clone_of->get_untransformed_body ();\n+  former_clone_of = clone_of->decl;\n+  if (clone_of->former_clone_of)\n+    former_clone_of = clone_of->former_clone_of;\n   if (symtab->dump_file)\n-    fprintf (symtab->dump_file, \"Materializing clones\\n\");\n-\n-  cgraph_node::checking_verify_cgraph_nodes ();\n-\n-  /* We can also do topological order, but number of iterations should be\n-     bounded by number of IPA passes since single IPA pass is probably not\n-     going to create clones of clones it created itself.  */\n-  while (!stabilized)\n     {\n-      stabilized = true;\n-      FOR_EACH_FUNCTION (node)\n+      fprintf (symtab->dump_file, \"cloning %s to %s\\n\",\n+\t       clone_of->dump_name (),\n+\t       dump_name ());\n+      if (clone.tree_map)\n         {\n-\t  if (node->clone_of && node->decl != node->clone_of->decl\n-\t      && !gimple_has_body_p (node->decl))\n+\t  fprintf (symtab->dump_file, \"    replace map:\");\n+\t  for (unsigned int i = 0;\n+\t       i < vec_safe_length (clone.tree_map);\n+\t       i++)\n \t    {\n-\t      if (!node->clone_of->clone_of)\n-\t\tnode->clone_of->get_untransformed_body ();\n-\t      if (gimple_has_body_p (node->clone_of->decl))\n-\t        {\n-\t\t  if (symtab->dump_file)\n-\t\t    {\n-\t\t      fprintf (symtab->dump_file, \"cloning %s to %s\\n\",\n-\t\t\t       node->clone_of->dump_name (),\n-\t\t\t       node->dump_name ());\n-\t\t      if (node->clone.tree_map)\n-\t\t        {\n-\t\t\t  unsigned int i;\n-\t\t\t  fprintf (symtab->dump_file, \"    replace map:\");\n-\t\t\t  for (i = 0;\n-\t\t\t       i < vec_safe_length (node->clone.tree_map);\n-\t\t\t       i++)\n-\t\t\t    {\n-\t\t\t      ipa_replace_map *replace_info;\n-\t\t\t      replace_info = (*node->clone.tree_map)[i];\n-\t\t\t      fprintf (symtab->dump_file, \"%s %i -> \",\n-\t\t\t\t       i ? \",\" : \"\", replace_info->parm_num);\n-\t\t\t      print_generic_expr (symtab->dump_file,\n-\t\t\t\t\t\t  replace_info->new_tree);\n-\t\t\t    }\n-\t\t\t  fprintf (symtab->dump_file, \"\\n\");\n-\t\t\t}\n-\t\t      if (node->clone.param_adjustments)\n-\t\t\tnode->clone.param_adjustments->dump (symtab->dump_file);\n-\t\t    }\n-\t\t  cgraph_materialize_clone (node);\n-\t\t  stabilized = false;\n-\t        }\n+\t      ipa_replace_map *replace_info;\n+\t      replace_info = (*clone.tree_map)[i];\n+\t      fprintf (symtab->dump_file, \"%s %i -> \",\n+\t\t       i ? \",\" : \"\", replace_info->parm_num);\n+\t      print_generic_expr (symtab->dump_file,\n+\t\t\t\t  replace_info->new_tree);\n \t    }\n+\t  fprintf (symtab->dump_file, \"\\n\");\n \t}\n+      if (clone.param_adjustments)\n+\tclone.param_adjustments->dump (symtab->dump_file);\n     }\n-  FOR_EACH_FUNCTION (node)\n-    if (!node->analyzed && node->callees)\n-      {\n-\tnode->remove_callees ();\n-\tnode->remove_all_references ();\n-      }\n-    else\n-      node->clear_stmts_in_references ();\n+  /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n+  tree_function_versioning (clone_of->decl, decl,\n+\t\t\t    clone.tree_map, clone.param_adjustments,\n+\t\t\t    true, NULL, NULL);\n   if (symtab->dump_file)\n-    fprintf (symtab->dump_file, \"Materialization Call site updates done.\\n\");\n-\n-  cgraph_node::checking_verify_cgraph_nodes ();\n+    {\n+      dump_function_to_file (clone_of->decl, symtab->dump_file,\n+\t\t\t     dump_flags);\n+      dump_function_to_file (decl, symtab->dump_file, dump_flags);\n+    }\n \n-  symtab->remove_unreachable_nodes (symtab->dump_file);\n+  cgraph_node *this_clone_of = clone_of;\n+  /* Function is no longer clone.  */\n+  remove_from_clone_tree ();\n+  if (!this_clone_of->analyzed && !this_clone_of->clones)\n+    {\n+      this_clone_of->release_body ();\n+      this_clone_of->remove_callees ();\n+      this_clone_of->remove_all_references ();\n+    }\n }\n \n #include \"gt-cgraphclones.h\""}, {"sha": "1e2262789dd9feb5929c457c321723ad4f6dfcf3", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e590b68fa3743656f40aee8374b788b108350c7/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e590b68fa3743656f40aee8374b788b108350c7/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=0e590b68fa3743656f40aee8374b788b108350c7", "patch": "@@ -1601,6 +1601,7 @@ mark_functions_to_output (void)\n   FOR_EACH_FUNCTION (node)\n     {\n       tree decl = node->decl;\n+      node->clear_stmts_in_references ();\n \n       gcc_assert (!node->process || node->same_comdat_group);\n       if (node->process)\n@@ -2274,6 +2275,9 @@ cgraph_node::expand (void)\n   announce_function (decl);\n   process = 0;\n   gcc_assert (lowered);\n+\n+  /* Initialize the default bitmap obstack.  */\n+  bitmap_obstack_initialize (NULL);\n   get_untransformed_body ();\n \n   /* Generate RTL for the body of DECL.  */\n@@ -2282,9 +2286,6 @@ cgraph_node::expand (void)\n \n   gcc_assert (symtab->global_info_ready);\n \n-  /* Initialize the default bitmap obstack.  */\n-  bitmap_obstack_initialize (NULL);\n-\n   /* Initialize the RTL code for the function.  */\n   saved_loc = input_location;\n   input_location = DECL_SOURCE_LOCATION (decl);\n@@ -2298,7 +2299,8 @@ cgraph_node::expand (void)\n   bitmap_obstack_initialize (&reg_obstack); /* FIXME, only at RTL generation*/\n \n   update_ssa (TODO_update_ssa_only_virtuals);\n-  execute_all_ipa_transforms (false);\n+  if (ipa_transforms_to_apply.exists ())\n+    execute_all_ipa_transforms (false);\n \n   /* Perform all tree transforms and optimizations.  */\n "}, {"sha": "f419df04961f8c7fec6f81367300b6ae3e699104", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e590b68fa3743656f40aee8374b788b108350c7/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e590b68fa3743656f40aee8374b788b108350c7/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=0e590b68fa3743656f40aee8374b788b108350c7", "patch": "@@ -644,16 +644,16 @@ save_inline_function_body (struct cgraph_node *node)\n   tree_function_versioning (node->decl, first_clone->decl,\n \t\t\t    NULL, NULL, true, NULL, NULL);\n \n-  /* The function will be short lived and removed after we inline all the clones,\n-     but make it internal so we won't confuse ourself.  */\n+  /* The function will be short lived and removed after we inline all the\n+     clones, but make it internal so we won't confuse ourself.  */\n   DECL_EXTERNAL (first_clone->decl) = 0;\n   TREE_PUBLIC (first_clone->decl) = 0;\n   DECL_COMDAT (first_clone->decl) = 0;\n   first_clone->ipa_transforms_to_apply.release ();\n \n   /* When doing recursive inlining, the clone may become unnecessary.\n-     This is possible i.e. in the case when the recursive function is proved to be\n-     non-throwing and the recursion happens only in the EH landing pad.\n+     This is possible i.e. in the case when the recursive function is proved to\n+     be non-throwing and the recursion happens only in the EH landing pad.\n      We cannot remove the clone until we are done with saving the body.\n      Remove it now.  */\n   if (!first_clone->callers)\n@@ -696,6 +696,14 @@ inline_transform (struct cgraph_node *node)\n   if (cfun->after_inlining)\n     return 0;\n \n+  cgraph_node *next_clone;\n+  for (cgraph_node *n = node->clones; n; n = next_clone)\n+    {\n+      next_clone = n->next_sibling_clone;\n+      if (n->decl != node->decl)\n+\tn->materialize_clone ();\n+    }\n+\n   /* We might need the body of this function so that we can expand\n      it inline somewhere else.  */\n   if (preserve_function_body_p (node))"}, {"sha": "438f4bd5a68984d3fbeb019e2586927f457d7f96", "filename": "gcc/ipa-param-manipulation.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e590b68fa3743656f40aee8374b788b108350c7/gcc%2Fipa-param-manipulation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e590b68fa3743656f40aee8374b788b108350c7/gcc%2Fipa-param-manipulation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.c?ref=0e590b68fa3743656f40aee8374b788b108350c7", "patch": "@@ -783,6 +783,13 @@ ipa_param_adjustments::modify_call (gcall *stmt,\n     {\n       vec<tree, va_gc> **debug_args = NULL;\n       unsigned i = 0;\n+      cgraph_node *callee_node = cgraph_node::get (callee_decl);\n+\n+      /* FIXME: we don't seem to be able to insert debug args before clone\n+\t is materialized.  Materializing them early leads to extra memory\n+\t use.  */\n+      if (callee_node->clone_of)\n+\tcallee_node->get_untransformed_body ();\n       for (tree old_parm = DECL_ARGUMENTS (old_decl);\n \t   old_parm && i < old_nargs && ((int) i) < m_always_copy_start;\n \t   old_parm = DECL_CHAIN (old_parm), i++)"}, {"sha": "ab7256d857fa788f408cfe199da89b6667bd9d62", "filename": "gcc/ipa.c", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e590b68fa3743656f40aee8374b788b108350c7/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e590b68fa3743656f40aee8374b788b108350c7/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=0e590b68fa3743656f40aee8374b788b108350c7", "patch": "@@ -1386,43 +1386,3 @@ make_pass_ipa_single_use (gcc::context *ctxt)\n   return new pass_ipa_single_use (ctxt);\n }\n \n-/* Materialize all clones.  */\n-\n-namespace {\n-\n-const pass_data pass_data_materialize_all_clones =\n-{\n-  SIMPLE_IPA_PASS, /* type */\n-  \"materialize-all-clones\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  TV_IPA_OPT, /* tv_id */\n-  0, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_materialize_all_clones : public simple_ipa_opt_pass\n-{\n-public:\n-  pass_materialize_all_clones (gcc::context *ctxt)\n-    : simple_ipa_opt_pass (pass_data_materialize_all_clones, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual unsigned int execute (function *)\n-    {\n-      symtab->materialize_all_clones ();\n-      return 0;\n-    }\n-\n-}; // class pass_materialize_all_clones\n-\n-} // anon namespace\n-\n-simple_ipa_opt_pass *\n-make_pass_materialize_all_clones (gcc::context *ctxt)\n-{\n-  return new pass_materialize_all_clones (ctxt);\n-}"}, {"sha": "1942b7cd1c3d13370c4b0f85e00c2648eb2ce5f2", "filename": "gcc/passes.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e590b68fa3743656f40aee8374b788b108350c7/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e590b68fa3743656f40aee8374b788b108350c7/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=0e590b68fa3743656f40aee8374b788b108350c7", "patch": "@@ -2271,6 +2271,14 @@ execute_all_ipa_transforms (bool do_not_collect)\n     return;\n   node = cgraph_node::get (current_function_decl);\n \n+  cgraph_node *next_clone;\n+  for (cgraph_node *n = node->clones; n; n = next_clone)\n+    {\n+      next_clone = n->next_sibling_clone;\n+      if (n->decl != node->decl)\n+\tn->materialize_clone ();\n+    }\n+\n   if (node->ipa_transforms_to_apply.exists ())\n     {\n       unsigned int i;"}, {"sha": "cf15d8eafcac4863b415eb42ae11c8207979498d", "filename": "gcc/passes.def", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e590b68fa3743656f40aee8374b788b108350c7/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e590b68fa3743656f40aee8374b788b108350c7/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=0e590b68fa3743656f40aee8374b788b108350c7", "patch": "@@ -172,7 +172,6 @@ along with GCC; see the file COPYING3.  If not see\n      passes are executed after partitioning and thus see just parts of the\n      compiled unit.  */\n   INSERT_PASSES_AFTER (all_late_ipa_passes)\n-  NEXT_PASS (pass_materialize_all_clones);\n   NEXT_PASS (pass_ipa_pta);\n   NEXT_PASS (pass_omp_simd_clone);\n   TERMINATE_PASS_LIST (all_late_ipa_passes)"}, {"sha": "1e8badfe4be76283e3e3cdd1951d9af41974a604", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e590b68fa3743656f40aee8374b788b108350c7/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e590b68fa3743656f40aee8374b788b108350c7/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=0e590b68fa3743656f40aee8374b788b108350c7", "patch": "@@ -519,8 +519,6 @@ extern ipa_opt_pass_d *make_pass_ipa_cdtor_merge (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_single_use (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_comdats (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_modref (gcc::context *ctxt);\n-extern simple_ipa_opt_pass *make_pass_materialize_all_clones (gcc::context *\n-\t\t\t\t\t\t\t      ctxt);\n \n extern gimple_opt_pass *make_pass_cleanup_cfg_post_optimizing (gcc::context\n \t\t\t\t\t\t\t       *ctxt);"}, {"sha": "ac29365e8090f67248e274a1ac7254153507b00e", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e590b68fa3743656f40aee8374b788b108350c7/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e590b68fa3743656f40aee8374b788b108350c7/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=0e590b68fa3743656f40aee8374b788b108350c7", "patch": "@@ -8138,6 +8138,10 @@ ipa_pta_execute (void)\n       from = constraints.length ();\n     }\n \n+  /* FIXME: Clone materialization is not preserving stmt references.  */\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    node->clear_stmts_in_references ();\n+\n   /* Build the constraints.  */\n   FOR_EACH_DEFINED_FUNCTION (node)\n     {"}]}