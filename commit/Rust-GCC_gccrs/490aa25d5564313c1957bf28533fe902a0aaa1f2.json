{"sha": "490aa25d5564313c1957bf28533fe902a0aaa1f2", "node_id": "C_kwDOANBUbNoAKDQ5MGFhMjVkNTU2NDMxM2MxOTU3YmYyODUzM2ZlOTAyYTBhYWExZjI", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-10-21T14:13:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-21T14:13:47Z"}, "message": "Merge #1608\n\n1608: Initial support for closures r=philberty a=philberty\n\nThis patch series introduces initial support for closures. Rust's implementation\r\nof closures is actually pretty clever, the function signatures for closures is driven\r\nby the specific FnTrait that the closure implements, this means a CallExpr to a closure\r\nbecomes a method-call expr with the receiver type being the closure itself using the\r\nnormal autoderef mechanism to do method selection for an implicit impl block.\r\n\r\nSee https://github.com/rust-lang/rust/blob/7807a694c2f079fd3f395821bcc357eee8650071/library/core/src/ops/function.rs#L54-L71\r\n\r\nThe other implicit part of this is that arguments being passed to a closure _must_\r\nbe passed as a tuple. The down side of allowing libcore to specify the signatures\r\nof the closure functions is that we are limited in how we pass arguments, but\r\nusing a tuple and then using similar machinery from the match-expr to restructure\r\nthe parameter access to become the tuple accessors makes it look seamless. For\r\nexample:\r\n\r\n```rust\r\n  let closure_annotated = |i: i32| -> i32 { i + 123 };\r\n  let i = 1;\r\n  closure_annotated(i);\r\n```\r\n\r\nWil generate a function and call-expr such as:\r\n\r\n```c\r\ni32 test::main::{{closure}} (struct {{closure}} $closure, struct (i32) args)\r\n{\r\n  _1 = args.__0; // this is 'i'\r\n  return _1 + 123;\r\n}\r\n\r\n\r\n__attribute__((cdecl))\r\ni32 test::main ()\r\n{\r\n  struct \r\n{\r\n  i32 __0;\r\n} D.137;\r\n  i32 D.140;\r\n  const i32 a;\r\n  const struct{{closure}} closure_annotated;\r\n  const i32 i;\r\n\r\n  try\r\n    {\r\n      a = 1;\r\n      i = 1;\r\n      D.137.__0 = i;\r\n      _1 = test::main::{{closure}} (closure_annotated, D.137);\r\n     <...>\r\n    }\r\n  finally\r\n    {\r\n      closure_annotated = {CLOBBER(eol)};\r\n    }\r\n}\r\n\r\n```\r\n\r\nNote this patch series does not implement the argument capture yet but this patch set is\r\ngood start to the implementation so far. \r\n\r\nAddresses #195 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "3fee40077e3efdb231b96772bd58c02522ce6f3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fee40077e3efdb231b96772bd58c02522ce6f3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/490aa25d5564313c1957bf28533fe902a0aaa1f2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjUqkbCRBK7hj4Ov3rIwAAfDAIAEh3xhE/IT0oM+GmTYjqStfG\nosRnqR5rZXGlJqv13E5EgmNSG88/PZOq4+GzcQeWHrdiOMhVf94voPasQG5WjUCU\nbsa2SwnjYHQB1gKEkyADyF/jufstrqD5R44RMIdIjL7mcm5bEJ7Er4KUrLUG/dpJ\n2BROLygrew+WrB0WZyaxdVQ+EElHEOSzUhMPc6WR0nI9/e78Zxzr3wSHU6BeeJ1Y\nank5LlC1rjJ6BIcnUThMFwJb/wtlI1rsC0WnLApJBMHCFduxmmkWeJGAnyIXO8v+\n3AqL+/DGSEAhC8ecgyECW0+h45MaWp2r9bn5iBHArFriGgqsq64NvFnVHybRhU8=\n=kSbK\n-----END PGP SIGNATURE-----\n", "payload": "tree 3fee40077e3efdb231b96772bd58c02522ce6f3a\nparent 60b21d2f58f46c93fc33f6192682abfed62d8dd9\nparent 05bd0555fa398c171acc22b6cfa1d5974202a5c7\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1666361627 +0000\ncommitter GitHub <noreply@github.com> 1666361627 +0000\n\nMerge #1608\n\n1608: Initial support for closures r=philberty a=philberty\n\nThis patch series introduces initial support for closures. Rust's implementation\r\nof closures is actually pretty clever, the function signatures for closures is driven\r\nby the specific FnTrait that the closure implements, this means a CallExpr to a closure\r\nbecomes a method-call expr with the receiver type being the closure itself using the\r\nnormal autoderef mechanism to do method selection for an implicit impl block.\r\n\r\nSee https://github.com/rust-lang/rust/blob/7807a694c2f079fd3f395821bcc357eee8650071/library/core/src/ops/function.rs#L54-L71\r\n\r\nThe other implicit part of this is that arguments being passed to a closure _must_\r\nbe passed as a tuple. The down side of allowing libcore to specify the signatures\r\nof the closure functions is that we are limited in how we pass arguments, but\r\nusing a tuple and then using similar machinery from the match-expr to restructure\r\nthe parameter access to become the tuple accessors makes it look seamless. For\r\nexample:\r\n\r\n```rust\r\n  let closure_annotated = |i: i32| -> i32 { i + 123 };\r\n  let i = 1;\r\n  closure_annotated(i);\r\n```\r\n\r\nWil generate a function and call-expr such as:\r\n\r\n```c\r\ni32 test::main::{{closure}} (struct {{closure}} $closure, struct (i32) args)\r\n{\r\n  _1 = args.__0; // this is 'i'\r\n  return _1 + 123;\r\n}\r\n\r\n\r\n__attribute__((cdecl))\r\ni32 test::main ()\r\n{\r\n  struct \r\n{\r\n  i32 __0;\r\n} D.137;\r\n  i32 D.140;\r\n  const i32 a;\r\n  const struct{{closure}} closure_annotated;\r\n  const i32 i;\r\n\r\n  try\r\n    {\r\n      a = 1;\r\n      i = 1;\r\n      D.137.__0 = i;\r\n      _1 = test::main::{{closure}} (closure_annotated, D.137);\r\n     <...>\r\n    }\r\n  finally\r\n    {\r\n      closure_annotated = {CLOBBER(eol)};\r\n    }\r\n}\r\n\r\n```\r\n\r\nNote this patch series does not implement the argument capture yet but this patch set is\r\ngood start to the implementation so far. \r\n\r\nAddresses #195 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/490aa25d5564313c1957bf28533fe902a0aaa1f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/490aa25d5564313c1957bf28533fe902a0aaa1f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/490aa25d5564313c1957bf28533fe902a0aaa1f2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60b21d2f58f46c93fc33f6192682abfed62d8dd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60b21d2f58f46c93fc33f6192682abfed62d8dd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60b21d2f58f46c93fc33f6192682abfed62d8dd9"}, {"sha": "05bd0555fa398c171acc22b6cfa1d5974202a5c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05bd0555fa398c171acc22b6cfa1d5974202a5c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05bd0555fa398c171acc22b6cfa1d5974202a5c7"}], "stats": {"total": 3760, "additions": 2455, "deletions": 1305}, "files": [{"sha": "024fe2333271deb15f470933629171818b5c2663", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -89,6 +89,8 @@ GRS_OBJS = \\\n     rust/rust-ast-lower-base.o \\\n     rust/rust-ast-lower-pattern.o \\\n     rust/rust-ast-lower-item.o \\\n+    rust/rust-ast-lower-expr.o \\\n+    rust/rust-ast-lower-type.o \\\n     rust/rust-early-name-resolver.o \\\n     rust/rust-name-resolver.o \\\n     rust/rust-ast-resolve.o \\"}, {"sha": "c58fae5e564501c1e67c2aeaffeaa5f30f8f7bfa", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -2134,8 +2134,6 @@ struct ClosureParam\n private:\n   std::vector<Attribute> outer_attrs;\n   std::unique_ptr<Pattern> pattern;\n-\n-  // bool has_type_given;\n   std::unique_ptr<Type> type;\n   Location locus;\n \n@@ -2202,19 +2200,19 @@ struct ClosureParam\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<Pattern> &get_pattern ()\n   {\n     rust_assert (pattern != nullptr);\n     return pattern;\n   }\n \n-  // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<Type> &get_type ()\n   {\n     rust_assert (has_type_given ());\n     return type;\n   }\n+\n+  Location get_locus () const { return locus; }\n };\n \n // Base closure definition expression AST node - abstract\n@@ -2248,6 +2246,8 @@ class ClosureExpr : public ExprWithoutBlock\n   {\n     outer_attrs = std::move (new_attrs);\n   }\n+\n+  bool get_has_move () const { return has_move; }\n };\n \n // Represents a non-type-specified closure expression AST node\n@@ -2307,7 +2307,6 @@ class ClosureExprInner : public ClosureExpr\n     return closure_inner == nullptr;\n   }\n \n-  // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<Expr> &get_definition_expr ()\n   {\n     rust_assert (closure_inner != nullptr);"}, {"sha": "46430548c5687d6d0023b21dab145a02b0ae3a2f", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -898,6 +898,8 @@ struct TypePathFunction\n     rust_assert (has_return_type ());\n     return return_type;\n   }\n+\n+  Location get_locus () const { return locus; }\n };\n \n // Segment used in type path with a function argument"}, {"sha": "8f62f45a4c39117316388127c61a0f9e06a5772a", "filename": "gcc/rust/backend/rust-compile-block.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fbackend%2Frust-compile-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fbackend%2Frust-compile-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-block.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -57,8 +57,7 @@ class CompileConditionalBlocks : public HIRCompileBase,\n   // Empty visit for unused Expression HIR nodes.\n   void visit (HIR::PathInExpression &) override {}\n   void visit (HIR::QualifiedPathInExpression &) override {}\n-  void visit (HIR::ClosureExprInner &) override {}\n-  void visit (HIR::ClosureExprInnerTyped &) override {}\n+  void visit (HIR::ClosureExpr &) override {}\n   void visit (HIR::StructExprFieldIdentifier &) override {}\n   void visit (HIR::StructExprFieldIdentifierValue &) override {}\n   void visit (HIR::StructExprFieldIndexValue &) override {}\n@@ -146,8 +145,7 @@ class CompileExprWithBlock : public HIRCompileBase,\n   // Empty visit for unused Expression HIR nodes.\n   void visit (HIR::PathInExpression &) override {}\n   void visit (HIR::QualifiedPathInExpression &) override {}\n-  void visit (HIR::ClosureExprInner &) override {}\n-  void visit (HIR::ClosureExprInnerTyped &) override {}\n+  void visit (HIR::ClosureExpr &) override {}\n   void visit (HIR::StructExprFieldIdentifier &) override {}\n   void visit (HIR::StructExprFieldIdentifierValue &) override {}\n   void visit (HIR::StructExprFieldIndexValue &) override {}"}, {"sha": "658b9a3f595faace4978af15e2dd5fb5d3fdf19e", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -147,6 +147,35 @@ class Context\n     mono_fns[dId].push_back ({ref, fn});\n   }\n \n+  void insert_closure_decl (const TyTy::ClosureType *ref, tree fn)\n+  {\n+    auto dId = ref->get_def_id ();\n+    auto it = mono_closure_fns.find (dId);\n+    if (it == mono_closure_fns.end ())\n+      mono_closure_fns[dId] = {};\n+\n+    mono_closure_fns[dId].push_back ({ref, fn});\n+  }\n+\n+  tree lookup_closure_decl (const TyTy::ClosureType *ref)\n+  {\n+    auto dId = ref->get_def_id ();\n+    auto it = mono_closure_fns.find (dId);\n+    if (it == mono_closure_fns.end ())\n+      return error_mark_node;\n+\n+    for (auto &i : it->second)\n+      {\n+\tconst TyTy::ClosureType *t = i.first;\n+\ttree fn = i.second;\n+\n+\tif (ref->is_equal (*t))\n+\t  return fn;\n+      }\n+\n+    return error_mark_node;\n+  }\n+\n   bool lookup_function_decl (HirId id, tree *fn, DefId dId = UNKNOWN_DEFID,\n \t\t\t     const TyTy::BaseType *ref = nullptr,\n \t\t\t     const std::string &asm_name = std::string ())\n@@ -343,6 +372,8 @@ class Context\n   std::vector<tree> loop_begin_labels;\n   std::map<DefId, std::vector<std::pair<const TyTy::BaseType *, tree>>>\n     mono_fns;\n+  std::map<DefId, std::vector<std::pair<const TyTy::ClosureType *, tree>>>\n+    mono_closure_fns;\n   std::map<HirId, tree> implicit_pattern_bindings;\n   std::map<hashval_t, tree> main_variants;\n "}, {"sha": "b077a12f7a35b47dc67ff718814ad48c70c5ebfd", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 299, "deletions": 7, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -1589,9 +1589,7 @@ CompileExpr::visit (HIR::CallExpr &expr)\n     }\n \n   // must be a tuple constructor\n-  bool is_fn = tyty->get_kind () == TyTy::TypeKind::FNDEF\n-\t       || tyty->get_kind () == TyTy::TypeKind::FNPTR;\n-  bool is_adt_ctor = !is_fn;\n+  bool is_adt_ctor = tyty->get_kind () == TyTy::TypeKind::ADT;\n   if (is_adt_ctor)\n     {\n       rust_assert (tyty->get_kind () == TyTy::TypeKind::ADT);\n@@ -1692,20 +1690,28 @@ CompileExpr::visit (HIR::CallExpr &expr)\n     return true;\n   };\n \n+  auto fn_address = CompileExpr::Compile (expr.get_fnexpr (), ctx);\n+\n+  // is this a closure call?\n+  bool possible_trait_call\n+    = generate_possible_fn_trait_call (expr, fn_address, &translated);\n+  if (possible_trait_call)\n+    return;\n+\n   bool is_varadic = false;\n   if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n     {\n       const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n       is_varadic = fn->is_varadic ();\n     }\n \n-  size_t required_num_args;\n+  size_t required_num_args = expr.get_arguments ().size ();\n   if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n     {\n       const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n       required_num_args = fn->num_params ();\n     }\n-  else\n+  else if (tyty->get_kind () == TyTy::TypeKind::FNPTR)\n     {\n       const TyTy::FnPtr *fn = static_cast<const TyTy::FnPtr *> (tyty);\n       required_num_args = fn->num_params ();\n@@ -1746,8 +1752,7 @@ CompileExpr::visit (HIR::CallExpr &expr)\n       args.push_back (rvalue);\n     }\n \n-  // must be a call to a function\n-  auto fn_address = CompileExpr::Compile (expr.get_fnexpr (), ctx);\n+  // must be a regular call to a function\n   translated = ctx->get_backend ()->call_expression (fn_address, args, nullptr,\n \t\t\t\t\t\t     expr.get_locus ());\n }\n@@ -2798,5 +2803,292 @@ CompileExpr::visit (HIR::ArrayIndexExpr &expr)\n \t\t\t\t\t\t   expr.get_locus ());\n }\n \n+void\n+CompileExpr::visit (HIR::ClosureExpr &expr)\n+{\n+  TyTy::BaseType *closure_expr_ty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &closure_expr_ty))\n+    {\n+      rust_fatal_error (expr.get_locus (),\n+\t\t\t\"did not resolve type for this ClosureExpr\");\n+      return;\n+    }\n+  rust_assert (closure_expr_ty->get_kind () == TyTy::TypeKind::CLOSURE);\n+  TyTy::ClosureType *closure_tyty\n+    = static_cast<TyTy::ClosureType *> (closure_expr_ty);\n+  tree compiled_closure_tyty = TyTyResolveCompile::compile (ctx, closure_tyty);\n+\n+  // generate closure function\n+  generate_closure_function (expr, *closure_tyty, compiled_closure_tyty);\n+\n+  // lets ignore state capture for now we need to instantiate the struct anyway\n+  // then generate the function\n+\n+  std::vector<tree> vals;\n+  // TODO\n+  // setup argument captures based on the mode?\n+\n+  translated\n+    = ctx->get_backend ()->constructor_expression (compiled_closure_tyty, false,\n+\t\t\t\t\t\t   vals, -1, expr.get_locus ());\n+}\n+\n+tree\n+CompileExpr::generate_closure_function (HIR::ClosureExpr &expr,\n+\t\t\t\t\tTyTy::ClosureType &closure_tyty,\n+\t\t\t\t\ttree compiled_closure_tyty)\n+{\n+  TyTy::FnType *fn_tyty = nullptr;\n+  tree compiled_fn_type\n+    = generate_closure_fntype (expr, closure_tyty, compiled_closure_tyty,\n+\t\t\t       &fn_tyty);\n+  if (compiled_fn_type == error_mark_node)\n+    return error_mark_node;\n+\n+  const Resolver::CanonicalPath &parent_canonical_path\n+    = closure_tyty.get_ident ().path;\n+  Resolver::CanonicalPath path = parent_canonical_path.append (\n+    Resolver::CanonicalPath::new_seg (UNKNOWN_NODEID, \"{{closure}}\"));\n+\n+  std::string ir_symbol_name = path.get ();\n+  std::string asm_name = ctx->mangle_item (&closure_tyty, path);\n+\n+  unsigned int flags = 0;\n+  tree fndecl\n+    = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name, asm_name,\n+\t\t\t\t     flags, expr.get_locus ());\n+\n+  // insert into the context\n+  ctx->insert_function_decl (fn_tyty, fndecl);\n+  ctx->insert_closure_decl (&closure_tyty, fndecl);\n+\n+  // setup the parameters\n+  std::vector<Bvariable *> param_vars;\n+\n+  // closure self\n+  Bvariable *self_param\n+    = ctx->get_backend ()->parameter_variable (fndecl, \"$closure\",\n+\t\t\t\t\t       compiled_closure_tyty,\n+\t\t\t\t\t       expr.get_locus ());\n+  DECL_ARTIFICIAL (self_param->get_decl ()) = 1;\n+  param_vars.push_back (self_param);\n+\n+  // setup the implicit argument captures\n+  // TODO\n+\n+  // args tuple\n+  tree args_type\n+    = TyTyResolveCompile::compile (ctx, &closure_tyty.get_parameters ());\n+  Bvariable *args_param\n+    = ctx->get_backend ()->parameter_variable (fndecl, \"args\", args_type,\n+\t\t\t\t\t       expr.get_locus ());\n+  param_vars.push_back (args_param);\n+\n+  // setup the implicit mappings for the arguments. Since argument passing to\n+  // closure functions is done via passing a tuple but the closure body expects\n+  // just normal arguments this means we need to destructure them similar to\n+  // what we do in MatchExpr's. This means when we have a closure-param of a we\n+  // actually setup the destructure to take from the args tuple\n+\n+  tree args_param_expr = args_param->get_tree (expr.get_locus ());\n+  size_t i = 0;\n+  for (auto &closure_param : expr.get_params ())\n+    {\n+      tree compiled_param_var = ctx->get_backend ()->struct_field_expression (\n+\targs_param_expr, i, closure_param.get_locus ());\n+\n+      const HIR::Pattern &param_pattern = *closure_param.get_pattern ();\n+      ctx->insert_pattern_binding (\n+\tparam_pattern.get_pattern_mappings ().get_hirid (), compiled_param_var);\n+      i++;\n+    }\n+\n+  if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n+    return error_mark_node;\n+\n+  // lookup locals\n+  HIR::Expr *function_body = expr.get_expr ().get ();\n+  auto body_mappings = function_body->get_mappings ();\n+  Resolver::Rib *rib = nullptr;\n+  bool ok\n+    = ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (), &rib);\n+  rust_assert (ok);\n+\n+  std::vector<Bvariable *> locals\n+    = compile_locals_for_block (ctx, *rib, fndecl);\n+\n+  tree enclosing_scope = NULL_TREE;\n+  Location start_location = function_body->get_locus ();\n+  Location end_location = function_body->get_locus ();\n+  bool is_block_expr\n+    = function_body->get_expression_type () == HIR::Expr::ExprType::Block;\n+  if (is_block_expr)\n+    {\n+      HIR::BlockExpr *body = static_cast<HIR::BlockExpr *> (function_body);\n+      start_location = body->get_locus ();\n+      end_location = body->get_end_locus ();\n+    }\n+\n+  tree code_block = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t\t\tstart_location, end_location);\n+  ctx->push_block (code_block);\n+\n+  TyTy::BaseType *tyret = &closure_tyty.get_result_type ();\n+  bool function_has_return = !closure_tyty.get_result_type ().is_unit ();\n+  Bvariable *return_address = nullptr;\n+  if (function_has_return)\n+    {\n+      tree return_type = TyTyResolveCompile::compile (ctx, tyret);\n+\n+      bool address_is_taken = false;\n+      tree ret_var_stmt = NULL_TREE;\n+\n+      return_address = ctx->get_backend ()->temporary_variable (\n+\tfndecl, code_block, return_type, NULL, address_is_taken,\n+\texpr.get_locus (), &ret_var_stmt);\n+\n+      ctx->add_statement (ret_var_stmt);\n+    }\n+\n+  ctx->push_fn (fndecl, return_address);\n+\n+  if (is_block_expr)\n+    {\n+      HIR::BlockExpr *body = static_cast<HIR::BlockExpr *> (function_body);\n+      compile_function_body (ctx, fndecl, *body, true);\n+    }\n+  else\n+    {\n+      tree value = CompileExpr::Compile (function_body, ctx);\n+      tree return_expr\n+\t= ctx->get_backend ()->return_statement (fndecl, {value},\n+\t\t\t\t\t\t function_body->get_locus ());\n+      ctx->add_statement (return_expr);\n+    }\n+\n+  tree bind_tree = ctx->pop_block ();\n+\n+  gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n+  DECL_SAVED_TREE (fndecl) = bind_tree;\n+\n+  ctx->pop_fn ();\n+  ctx->push_function (fndecl);\n+\n+  return fndecl;\n+}\n+\n+tree\n+CompileExpr::generate_closure_fntype (HIR::ClosureExpr &expr,\n+\t\t\t\t      const TyTy::ClosureType &closure_tyty,\n+\t\t\t\t      tree compiled_closure_tyty,\n+\t\t\t\t      TyTy::FnType **fn_tyty)\n+{\n+  // grab the specified_bound\n+  rust_assert (closure_tyty.num_specified_bounds () == 1);\n+  const TyTy::TypeBoundPredicate &predicate\n+    = *closure_tyty.get_specified_bounds ().begin ();\n+\n+  // ensure the fn_once_output associated type is set\n+  closure_tyty.setup_fn_once_output ();\n+\n+  // the function signature is based on the trait bound that the closure\n+  // implements which is determined at the type resolution time\n+  //\n+  // https://github.com/rust-lang/rust/blob/7807a694c2f079fd3f395821bcc357eee8650071/library/core/src/ops/function.rs#L54-L71\n+\n+  TyTy::TypeBoundPredicateItem item = TyTy::TypeBoundPredicateItem::error ();\n+  if (predicate.get_name ().compare (\"FnOnce\") == 0)\n+    {\n+      item = predicate.lookup_associated_item (\"call_once\");\n+    }\n+  else if (predicate.get_name ().compare (\"FnMut\") == 0)\n+    {\n+      item = predicate.lookup_associated_item (\"call_mut\");\n+    }\n+  else if (predicate.get_name ().compare (\"Fn\") == 0)\n+    {\n+      item = predicate.lookup_associated_item (\"call\");\n+    }\n+  else\n+    {\n+      // FIXME error message?\n+      gcc_unreachable ();\n+      return error_mark_node;\n+    }\n+\n+  rust_assert (!item.is_error ());\n+\n+  TyTy::BaseType *item_tyty = item.get_tyty_for_receiver (&closure_tyty);\n+  rust_assert (item_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+  *fn_tyty = static_cast<TyTy::FnType *> (item_tyty);\n+  return TyTyResolveCompile::compile (ctx, item_tyty);\n+}\n+\n+bool\n+CompileExpr::generate_possible_fn_trait_call (HIR::CallExpr &expr,\n+\t\t\t\t\t      tree receiver, tree *result)\n+{\n+  TyTy::FnType *fn_sig = nullptr;\n+  bool found_overload = ctx->get_tyctx ()->lookup_operator_overload (\n+    expr.get_mappings ().get_hirid (), &fn_sig);\n+  if (!found_overload)\n+    return false;\n+\n+  auto id = fn_sig->get_ty_ref ();\n+  auto dId = fn_sig->get_id ();\n+\n+  tree function = error_mark_node;\n+  bool found_closure = ctx->lookup_function_decl (id, &function, dId, fn_sig);\n+  if (!found_closure)\n+    {\n+      // something went wrong we still return true as this was meant to be an fn\n+      // trait call\n+      *result = error_mark_node;\n+      return true;\n+    }\n+\n+  // need to apply any autoderef's to the self argument\n+  HirId autoderef_mappings_id = expr.get_mappings ().get_hirid ();\n+  std::vector<Resolver::Adjustment> *adjustments = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_autoderef_mappings (autoderef_mappings_id,\n+\t\t\t\t\t\t\t  &adjustments);\n+  rust_assert (ok);\n+\n+  // apply adjustments for the fn call\n+  tree self = resolve_adjustements (*adjustments, receiver, expr.get_locus ());\n+\n+  // resolve the arguments\n+  std::vector<tree> tuple_arg_vals;\n+  for (auto &argument : expr.get_arguments ())\n+    {\n+      auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n+      tuple_arg_vals.push_back (rvalue);\n+    }\n+\n+  // this is always the 2nd argument in the function signature\n+  tree fnty = TREE_TYPE (function);\n+  tree fn_arg_tys = TYPE_ARG_TYPES (fnty);\n+  tree tuple_args_tyty_chain = TREE_CHAIN (fn_arg_tys);\n+  tree tuple_args_tyty = TREE_VALUE (tuple_args_tyty_chain);\n+\n+  tree tuple_args\n+    = ctx->get_backend ()->constructor_expression (tuple_args_tyty, false,\n+\t\t\t\t\t\t   tuple_arg_vals, -1,\n+\t\t\t\t\t\t   expr.get_locus ());\n+\n+  // args are always self, and the tuple of the args we are passing where\n+  // self is the path of the call-expr in this case the fn_address\n+  std::vector<tree> args;\n+  args.push_back (self);\n+  args.push_back (tuple_args);\n+\n+  tree call_address = address_expression (function, expr.get_locus ());\n+  *result = ctx->get_backend ()->call_expression (call_address, args,\n+\t\t\t\t\t\t  nullptr /* static chain ?*/,\n+\t\t\t\t\t\t  expr.get_locus ());\n+  return true;\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "a259daf0d6923db39ff442a990aff2165cc40f54", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -67,10 +67,9 @@ class CompileExpr : private HIRCompileBase, protected HIR::HIRExpressionVisitor\n   void visit (HIR::RangeToExpr &expr) override;\n   void visit (HIR::RangeFullExpr &expr) override;\n   void visit (HIR::RangeFromToInclExpr &expr) override;\n+  void visit (HIR::ClosureExpr &expr) override;\n \n   // TODO\n-  void visit (HIR::ClosureExprInner &) override {}\n-  void visit (HIR::ClosureExprInnerTyped &) override {}\n   void visit (HIR::ErrorPropagationExpr &) override {}\n   void visit (HIR::RangeToInclExpr &) override {}\n   void visit (HIR::ForLoopExpr &) override {}\n@@ -143,6 +142,19 @@ class CompileExpr : private HIRCompileBase, protected HIR::HIRExpressionVisitor\n \t\t\t  const TyTy::ArrayType &array_tyty, tree array_type,\n \t\t\t  HIR::ArrayElemsCopied &elems);\n \n+protected:\n+  tree generate_closure_function (HIR::ClosureExpr &expr,\n+\t\t\t\t  TyTy::ClosureType &closure_tyty,\n+\t\t\t\t  tree compiled_closure_tyty);\n+\n+  tree generate_closure_fntype (HIR::ClosureExpr &expr,\n+\t\t\t\tconst TyTy::ClosureType &closure_tyty,\n+\t\t\t\ttree compiled_closure_tyty,\n+\t\t\t\tTyTy::FnType **fn_tyty);\n+\n+  bool generate_possible_fn_trait_call (HIR::CallExpr &expr, tree receiver,\n+\t\t\t\t\ttree *result);\n+\n private:\n   CompileExpr (Context *ctx);\n "}, {"sha": "5e56e0a0b5d15b896165dd0dd7b7b2c128bfd212", "filename": "gcc/rust/backend/rust-compile-type.cc", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.cc?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -97,9 +97,15 @@ TyTyResolveCompile::visit (const TyTy::InferType &)\n }\n \n void\n-TyTyResolveCompile::visit (const TyTy::ClosureType &)\n+TyTyResolveCompile::visit (const TyTy::ClosureType &type)\n {\n-  gcc_unreachable ();\n+  std::vector<Backend::typed_identifier> fields;\n+  tree type_record = ctx->get_backend ()->struct_type (fields);\n+  RS_CLOSURE_FLAG (type_record) = 1;\n+\n+  std::string named_struct_str = type.get_ident ().path.get () + \"{{closure}}\";\n+  translated = ctx->get_backend ()->named_type (named_struct_str, type_record,\n+\t\t\t\t\t\ttype.get_ident ().locus);\n }\n \n void"}, {"sha": "83aefa7997a84d16b77ffe018444ee117e7ec136", "filename": "gcc/rust/backend/rust-mangle.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fbackend%2Frust-mangle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fbackend%2Frust-mangle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-mangle.cc?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -13,6 +13,8 @@ static const std::string kMangledRef = \"$RF$\";\n static const std::string kMangledPtr = \"$BP$\";\n static const std::string kMangledLeftSqParen = \"$u5b$\";\t // [\n static const std::string kMangledRightSqParen = \"$u5d$\"; // ]\n+static const std::string kMangledLeftBrace = \"$u7b$\";\t // {\n+static const std::string kMangledRightBrace = \"$u7d$\";\t // }\n static const std::string kQualPathBegin = \"_\" + kMangledSubstBegin;\n static const std::string kMangledComma = \"$C$\";\n \n@@ -66,6 +68,10 @@ legacy_mangle_name (const std::string &name)\n \tm = kMangledLeftSqParen;\n       else if (c == ']')\n \tm = kMangledRightSqParen;\n+      else if (c == '{')\n+\tm = kMangledLeftBrace;\n+      else if (c == '}')\n+\tm = kMangledRightBrace;\n       else if (c == ',')\n \tm = kMangledComma;\n       else if (c == ':')"}, {"sha": "4a110163fd836a20024f89b7262ccdbd5ea57786", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -82,6 +82,11 @@\n #define SLICE_TYPE_P(TYPE)                                                     \\\n   (TREE_CODE (TYPE) == RECORD_TYPE && TREE_LANG_FLAG_0 (TYPE))\n \n+// lambda?\n+#define RS_CLOSURE_FLAG TREE_LANG_FLAG_1\n+#define RS_CLOSURE_TYPE_P(TYPE)                                                \\\n+  (TREE_CODE (TYPE) == RECORD_TYPE && TREE_LANG_FLAG_1 (TYPE))\n+\n /* Returns true if NODE is a pointer to member function type.  */\n #define TYPE_PTRMEMFUNC_P(NODE)                                                \\\n   (TREE_CODE (NODE) == RECORD_TYPE && TYPE_PTRMEMFUNC_FLAG (NODE))"}, {"sha": "a8280583a64c7c677efab4a46c836888107fbfa9", "filename": "gcc/rust/checks/errors/privacy/rust-privacy-reporter.cc", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-reporter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-reporter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-reporter.cc?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -408,7 +408,7 @@ PrivacyReporter::visit (HIR::FieldAccessExpr &expr)\n }\n \n void\n-PrivacyReporter::visit (HIR::ClosureExprInner &expr)\n+PrivacyReporter::visit (HIR::ClosureExpr &expr)\n {\n   // Not handled yet\n }\n@@ -424,12 +424,6 @@ PrivacyReporter::visit (HIR::BlockExpr &expr)\n     last_expr->accept_vis (*this);\n }\n \n-void\n-PrivacyReporter::visit (HIR::ClosureExprInnerTyped &expr)\n-{\n-  // Not handled yet\n-}\n-\n void\n PrivacyReporter::visit (HIR::ContinueExpr &expr)\n {}"}, {"sha": "38a5f08fcdd791bf4011362b62f8a52ff46c601c", "filename": "gcc/rust/checks/errors/privacy/rust-privacy-reporter.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-reporter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-reporter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-reporter.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -83,8 +83,7 @@ types\n \n   virtual void visit (HIR::QualifiedPathInExpression &expr);\n   virtual void visit (HIR::PathInExpression &expr);\n-  virtual void visit (HIR::ClosureExprInnerTyped &);\n-  virtual void visit (HIR::ClosureExprInner &expr);\n+  virtual void visit (HIR::ClosureExpr &expr);\n   virtual void visit (HIR::StructExprStructFields &);\n   virtual void visit (HIR::StructExprStruct &);\n   virtual void visit (HIR::LiteralExpr &expr);"}, {"sha": "3254a982b91a1b6538f80f5e91caca690b8bde22", "filename": "gcc/rust/checks/errors/rust-const-checker.cc", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fchecks%2Ferrors%2Frust-const-checker.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fchecks%2Ferrors%2Frust-const-checker.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Frust-const-checker.cc?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -382,8 +382,10 @@ ConstChecker::visit (FieldAccessExpr &expr)\n }\n \n void\n-ConstChecker::visit (ClosureExprInner &expr)\n-{}\n+ConstChecker::visit (ClosureExpr &expr)\n+{\n+  expr.get_expr ()->accept_vis (*this);\n+}\n \n void\n ConstChecker::visit (BlockExpr &expr)\n@@ -395,10 +397,6 @@ ConstChecker::visit (BlockExpr &expr)\n     expr.get_final_expr ()->accept_vis (*this);\n }\n \n-void\n-ConstChecker::visit (ClosureExprInnerTyped &expr)\n-{}\n-\n void\n ConstChecker::visit (ContinueExpr &expr)\n {}"}, {"sha": "f0175df940d20526d5decc0f22886d9fee45d679", "filename": "gcc/rust/checks/errors/rust-const-checker.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fchecks%2Ferrors%2Frust-const-checker.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fchecks%2Ferrors%2Frust-const-checker.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Frust-const-checker.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -111,9 +111,8 @@ class ConstChecker : public HIRFullVisitor\n   virtual void visit (CallExpr &expr) override;\n   virtual void visit (MethodCallExpr &expr) override;\n   virtual void visit (FieldAccessExpr &expr) override;\n-  virtual void visit (ClosureExprInner &expr) override;\n+  virtual void visit (ClosureExpr &expr) override;\n   virtual void visit (BlockExpr &expr) override;\n-  virtual void visit (ClosureExprInnerTyped &expr) override;\n   virtual void visit (ContinueExpr &expr) override;\n   virtual void visit (BreakExpr &expr) override;\n   virtual void visit (RangeFromToExpr &expr) override;"}, {"sha": "55a21590b2eae42161d334cf7b70e802156ce1f0", "filename": "gcc/rust/checks/errors/rust-unsafe-checker.cc", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fchecks%2Ferrors%2Frust-unsafe-checker.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fchecks%2Ferrors%2Frust-unsafe-checker.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Frust-unsafe-checker.cc?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -453,8 +453,10 @@ UnsafeChecker::visit (FieldAccessExpr &expr)\n }\n \n void\n-UnsafeChecker::visit (ClosureExprInner &expr)\n-{}\n+UnsafeChecker::visit (ClosureExpr &expr)\n+{\n+  expr.get_expr ()->accept_vis (*this);\n+}\n \n void\n UnsafeChecker::visit (BlockExpr &expr)\n@@ -466,10 +468,6 @@ UnsafeChecker::visit (BlockExpr &expr)\n     expr.get_final_expr ()->accept_vis (*this);\n }\n \n-void\n-UnsafeChecker::visit (ClosureExprInnerTyped &expr)\n-{}\n-\n void\n UnsafeChecker::visit (ContinueExpr &expr)\n {}"}, {"sha": "fe564a2088ec9d572e2eb19af6346020cbd14dd4", "filename": "gcc/rust/checks/errors/rust-unsafe-checker.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fchecks%2Ferrors%2Frust-unsafe-checker.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fchecks%2Ferrors%2Frust-unsafe-checker.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Frust-unsafe-checker.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -88,9 +88,8 @@ class UnsafeChecker : public HIRFullVisitor\n   virtual void visit (CallExpr &expr) override;\n   virtual void visit (MethodCallExpr &expr) override;\n   virtual void visit (FieldAccessExpr &expr) override;\n-  virtual void visit (ClosureExprInner &expr) override;\n+  virtual void visit (ClosureExpr &expr) override;\n   virtual void visit (BlockExpr &expr) override;\n-  virtual void visit (ClosureExprInnerTyped &expr) override;\n   virtual void visit (ContinueExpr &expr) override;\n   virtual void visit (BreakExpr &expr) override;\n   virtual void visit (RangeFromToExpr &expr) override;"}, {"sha": "ed5ed13c21ee1575a6f64d3de71dabecfdffb8f1", "filename": "gcc/rust/checks/lints/rust-lint-marklive.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fchecks%2Flints%2Frust-lint-marklive.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fchecks%2Flints%2Frust-lint-marklive.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Flints%2Frust-lint-marklive.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -285,6 +285,11 @@ class MarkLive : public MarkLiveBase\n       item->accept_vis (*this);\n   }\n \n+  void visit (HIR::ClosureExpr &expr) override\n+  {\n+    expr.get_expr ()->accept_vis (*this);\n+  }\n+\n private:\n   std::vector<HirId> worklist;\n   std::set<HirId> liveSymbols;"}, {"sha": "592d9e810f9819e27a6dc66844443635184ba58e", "filename": "gcc/rust/hir/rust-ast-lower-base.cc", "status": "modified", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -658,119 +658,6 @@ ASTLoweringBase::lower_self (AST::SelfParam &self)\n \t\t\t self.get_locus ());\n }\n \n-void\n-ASTLowerTypePath::visit (AST::TypePathSegmentGeneric &segment)\n-{\n-  std::vector<HIR::GenericArgsBinding> binding_args; // TODO\n-\n-  std::string segment_name = segment.get_ident_segment ().as_string ();\n-  bool has_separating_scope_resolution\n-    = segment.get_separating_scope_resolution ();\n-\n-  auto generic_args = lower_generic_args (segment.get_generic_args ());\n-\n-  auto crate_num = mappings->get_current_crate ();\n-  auto hirid = mappings->get_next_hir_id (crate_num);\n-  Analysis::NodeMapping mapping (crate_num, segment.get_node_id (), hirid,\n-\t\t\t\t UNKNOWN_LOCAL_DEFID);\n-\n-  translated_segment\n-    = new HIR::TypePathSegmentGeneric (std::move (mapping), segment_name,\n-\t\t\t\t       has_separating_scope_resolution,\n-\t\t\t\t       generic_args, segment.get_locus ());\n-}\n-\n-void\n-ASTLowerQualifiedPathInType::visit (AST::QualifiedPathInType &path)\n-{\n-  auto crate_num = mappings->get_current_crate ();\n-  auto hirid = mappings->get_next_hir_id (crate_num);\n-  Analysis::NodeMapping qual_mappings (\n-    crate_num, path.get_qualified_path_type ().get_node_id (), hirid,\n-    UNKNOWN_LOCAL_DEFID);\n-\n-  HIR::Type *qual_type = ASTLoweringType::translate (\n-    path.get_qualified_path_type ().get_type ().get ());\n-  HIR::TypePath *qual_trait = ASTLowerTypePath::translate (\n-    path.get_qualified_path_type ().get_as_type_path ());\n-\n-  HIR::QualifiedPathType qual_path_type (\n-    qual_mappings, std::unique_ptr<HIR::Type> (qual_type),\n-    std::unique_ptr<HIR::TypePath> (qual_trait),\n-    path.get_qualified_path_type ().get_locus ());\n-\n-  translated_segment = nullptr;\n-  path.get_associated_segment ()->accept_vis (*this);\n-  if (translated_segment == nullptr)\n-    {\n-      rust_fatal_error (path.get_associated_segment ()->get_locus (),\n-\t\t\t\"failed to translate AST TypePathSegment\");\n-      return;\n-    }\n-  std::unique_ptr<HIR::TypePathSegment> associated_segment (translated_segment);\n-\n-  std::vector<std::unique_ptr<HIR::TypePathSegment>> translated_segments;\n-  for (auto &seg : path.get_segments ())\n-    {\n-      translated_segment = nullptr;\n-      seg->accept_vis (*this);\n-      if (translated_segment == nullptr)\n-\t{\n-\t  rust_fatal_error (seg->get_locus (),\n-\t\t\t    \"failed to translte AST TypePathSegment\");\n-\t}\n-      translated_segments.push_back (\n-\tstd::unique_ptr<HIR::TypePathSegment> (translated_segment));\n-    }\n-\n-  Analysis::NodeMapping mapping (crate_num, path.get_node_id (), hirid,\n-\t\t\t\t mappings->get_next_localdef_id (crate_num));\n-  translated = new HIR::QualifiedPathInType (std::move (mapping),\n-\t\t\t\t\t     std::move (qual_path_type),\n-\t\t\t\t\t     std::move (associated_segment),\n-\t\t\t\t\t     std::move (translated_segments),\n-\t\t\t\t\t     path.get_locus ());\n-}\n-\n-void\n-ASTLoweringType::visit (AST::TraitObjectTypeOneBound &type)\n-{\n-  std::vector<std::unique_ptr<HIR::TypeParamBound>> bounds;\n-  HIR::TypeParamBound *translated_bound\n-    = ASTLoweringTypeBounds::translate (&type.get_trait_bound ());\n-  bounds.push_back (std::unique_ptr<HIR::TypeParamBound> (translated_bound));\n-\n-  auto crate_num = mappings->get_current_crate ();\n-  Analysis::NodeMapping mapping (crate_num, type.get_node_id (),\n-\t\t\t\t mappings->get_next_hir_id (crate_num),\n-\t\t\t\t mappings->get_next_localdef_id (crate_num));\n-\n-  translated = new HIR::TraitObjectType (mapping, std::move (bounds),\n-\t\t\t\t\t type.get_locus (), type.is_dyn ());\n-}\n-\n-void\n-ASTLoweringType::visit (AST::TraitObjectType &type)\n-{\n-  std::vector<std::unique_ptr<HIR::TypeParamBound>> bounds;\n-\n-  for (auto &bound : type.get_type_param_bounds ())\n-    {\n-      HIR::TypeParamBound *translated_bound\n-\t= ASTLoweringTypeBounds::translate (bound.get ());\n-      bounds.push_back (\n-\tstd::unique_ptr<HIR::TypeParamBound> (translated_bound));\n-    }\n-\n-  auto crate_num = mappings->get_current_crate ();\n-  Analysis::NodeMapping mapping (crate_num, type.get_node_id (),\n-\t\t\t\t mappings->get_next_hir_id (crate_num),\n-\t\t\t\t mappings->get_next_localdef_id (crate_num));\n-\n-  translated = new HIR::TraitObjectType (mapping, std::move (bounds),\n-\t\t\t\t\t type.get_locus (), type.is_dyn ());\n-}\n-\n HIR::Type *\n ASTLoweringBase::lower_type_no_bounds (AST::TypeNoBounds *type)\n {"}, {"sha": "16fe13c8242cd9bf29af8903bf878d665ca2160d", "filename": "gcc/rust/hir/rust-ast-lower-base.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -313,6 +313,8 @@ class ASTLoweringBase : public AST::ASTVisitor\n   HIR::Literal lower_literal (const AST::Literal &literal);\n \n   HIR::ExternBlock *lower_extern_block (AST::ExternBlock &extern_block);\n+\n+  HIR::ClosureParam lower_closure_param (AST::ClosureParam &param);\n };\n \n } // namespace HIR"}, {"sha": "df4ba9d29114136a5ef31cded675c3bc518a60c7", "filename": "gcc/rust/hir/rust-ast-lower-expr.cc", "status": "added", "additions": 810, "deletions": 0, "changes": 810, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.cc?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -0,0 +1,810 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-lower-expr.h\"\n+#include \"rust-ast-lower-base.h\"\n+#include \"rust-ast-lower-block.h\"\n+#include \"rust-ast-lower-struct-field-expr.h\"\n+#include \"rust-ast-lower-pattern.h\"\n+#include \"rust-ast-lower-type.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+ASTLoweringExpr::ASTLoweringExpr ()\n+  : ASTLoweringBase (), translated (nullptr), translated_array_elems (nullptr),\n+    terminated (false)\n+{}\n+\n+HIR::Expr *\n+ASTLoweringExpr::translate (AST::Expr *expr, bool *terminated)\n+{\n+  ASTLoweringExpr resolver;\n+  expr->accept_vis (resolver);\n+  if (resolver.translated == nullptr)\n+    {\n+      rust_fatal_error (expr->get_locus (), \"Failed to lower expr: [%s]\",\n+\t\t\texpr->as_string ().c_str ());\n+      return nullptr;\n+    }\n+\n+  resolver.mappings->insert_hir_expr (resolver.translated);\n+  resolver.mappings->insert_location (\n+    resolver.translated->get_mappings ().get_hirid (), expr->get_locus ());\n+\n+  if (terminated != nullptr)\n+    *terminated = resolver.terminated;\n+\n+  return resolver.translated;\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::TupleIndexExpr &expr)\n+{\n+  HIR::Expr *tuple_expr\n+    = ASTLoweringExpr::translate (expr.get_tuple_expr ().get (), &terminated);\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::TupleIndexExpr (mapping, std::unique_ptr<HIR::Expr> (tuple_expr),\n+\t\t\t       expr.get_tuple_index (), expr.get_outer_attrs (),\n+\t\t\t       expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::TupleExpr &expr)\n+{\n+  std::vector<std::unique_ptr<HIR::Expr> > tuple_elements;\n+  for (auto &e : expr.get_tuple_elems ())\n+    {\n+      HIR::Expr *t = ASTLoweringExpr::translate (e.get ());\n+      tuple_elements.push_back (std::unique_ptr<HIR::Expr> (t));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::TupleExpr (std::move (mapping), std::move (tuple_elements),\n+\t\t\t  expr.get_inner_attrs (), expr.get_outer_attrs (),\n+\t\t\t  expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::IfExpr &expr)\n+{\n+  translated = ASTLoweringIfBlock::translate (&expr, &terminated);\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::IfExprConseqElse &expr)\n+{\n+  translated = ASTLoweringIfBlock::translate (&expr, &terminated);\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::IfExprConseqIf &expr)\n+{\n+  translated = ASTLoweringIfBlock::translate (&expr, &terminated);\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::BlockExpr &expr)\n+{\n+  translated = ASTLoweringBlock::translate (&expr, &terminated);\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::UnsafeBlockExpr &expr)\n+{\n+  translated = ASTLoweringBlock::translate (&expr, &terminated);\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::PathInExpression &expr)\n+{\n+  translated = ASTLowerPathInExpression::translate (&expr);\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::QualifiedPathInExpression &expr)\n+{\n+  translated = ASTLowerQualPathInExpression::translate (&expr);\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::ReturnExpr &expr)\n+{\n+  terminated = true;\n+  HIR::Expr *return_expr\n+    = expr.has_returned_expr ()\n+\t? ASTLoweringExpr::translate (expr.get_returned_expr ().get ())\n+\t: nullptr;\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated = new HIR::ReturnExpr (mapping, expr.get_locus (),\n+\t\t\t\t    std::unique_ptr<HIR::Expr> (return_expr));\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::CallExpr &expr)\n+{\n+  HIR::Expr *func\n+    = ASTLoweringExpr::translate (expr.get_function_expr ().get ());\n+\n+  auto const &in_params = expr.get_params ();\n+  std::vector<std::unique_ptr<HIR::Expr> > params;\n+  for (auto &param : in_params)\n+    {\n+      auto trans = ASTLoweringExpr::translate (param.get ());\n+      params.push_back (std::unique_ptr<HIR::Expr> (trans));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (\n+    crate_num, UNKNOWN_NODEID /* this can map back to the AST*/,\n+    mappings->get_next_hir_id (crate_num), UNKNOWN_LOCAL_DEFID);\n+\n+  translated = new HIR::CallExpr (mapping, std::unique_ptr<HIR::Expr> (func),\n+\t\t\t\t  std::move (params), expr.get_outer_attrs (),\n+\t\t\t\t  expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::MethodCallExpr &expr)\n+{\n+  HIR::PathExprSegment method_path\n+    = lower_path_expr_seg (expr.get_method_name ());\n+\n+  HIR::Expr *receiver\n+    = ASTLoweringExpr::translate (expr.get_receiver_expr ().get ());\n+\n+  auto const &in_params = expr.get_params ();\n+  std::vector<std::unique_ptr<HIR::Expr> > params;\n+  for (auto &param : in_params)\n+    {\n+      auto trans = ASTLoweringExpr::translate (param.get ());\n+      params.push_back (std::unique_ptr<HIR::Expr> (trans));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::MethodCallExpr (mapping, std::unique_ptr<HIR::Expr> (receiver),\n+\t\t\t       method_path, std::move (params),\n+\t\t\t       expr.get_outer_attrs (), expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::AssignmentExpr &expr)\n+{\n+  HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_left_expr ().get ());\n+  HIR::Expr *rhs = ASTLoweringExpr::translate (expr.get_right_expr ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::AssignmentExpr (mapping, std::unique_ptr<HIR::Expr> (lhs),\n+\t\t\t       std::unique_ptr<HIR::Expr> (rhs),\n+\t\t\t       expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::IdentifierExpr &expr)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping1 (crate_num, expr.get_node_id (),\n+\t\t\t\t  mappings->get_next_hir_id (crate_num),\n+\t\t\t\t  UNKNOWN_LOCAL_DEFID);\n+  Analysis::NodeMapping mapping2 (mapping1);\n+\n+  HIR::PathIdentSegment ident_seg (expr.get_ident ());\n+  HIR::PathExprSegment seg (mapping1, ident_seg, expr.get_locus (),\n+\t\t\t    HIR::GenericArgs::create_empty ());\n+  translated = new HIR::PathInExpression (mapping2, {seg}, expr.get_locus (),\n+\t\t\t\t\t  false, expr.get_outer_attrs ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::ArrayExpr &expr)\n+{\n+  expr.get_array_elems ()->accept_vis (*this);\n+  rust_assert (translated_array_elems != nullptr);\n+  HIR::ArrayElems *elems = translated_array_elems;\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::ArrayExpr (mapping, std::unique_ptr<HIR::ArrayElems> (elems),\n+\t\t\t  expr.get_inner_attrs (), expr.get_outer_attrs (),\n+\t\t\t  expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::ArrayIndexExpr &expr)\n+{\n+  HIR::Expr *array_expr\n+    = ASTLoweringExpr::translate (expr.get_array_expr ().get ());\n+  HIR::Expr *array_index_expr\n+    = ASTLoweringExpr::translate (expr.get_index_expr ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::ArrayIndexExpr (mapping, std::unique_ptr<HIR::Expr> (array_expr),\n+\t\t\t       std::unique_ptr<HIR::Expr> (array_index_expr),\n+\t\t\t       expr.get_outer_attrs (), expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::ArrayElemsValues &elems)\n+{\n+  std::vector<std::unique_ptr<HIR::Expr> > elements;\n+  for (auto &elem : elems.get_values ())\n+    {\n+      HIR::Expr *translated_elem = ASTLoweringExpr::translate (elem.get ());\n+      elements.push_back (std::unique_ptr<HIR::Expr> (translated_elem));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (mappings->get_current_crate (),\n+\t\t\t\t elems.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated_array_elems\n+    = new HIR::ArrayElemsValues (mapping, std::move (elements));\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::ArrayElemsCopied &elems)\n+{\n+  HIR::Expr *element\n+    = ASTLoweringExpr::translate (elems.get_elem_to_copy ().get ());\n+  HIR::Expr *num_copies\n+    = ASTLoweringExpr::translate (elems.get_num_copies ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (mappings->get_current_crate (),\n+\t\t\t\t elems.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated_array_elems\n+    = new HIR::ArrayElemsCopied (mapping, std::unique_ptr<HIR::Expr> (element),\n+\t\t\t\t std::unique_ptr<HIR::Expr> (num_copies));\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::LiteralExpr &expr)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  HIR::Literal l = lower_literal (expr.get_literal ());\n+  translated = new HIR::LiteralExpr (mapping, std::move (l), expr.get_locus (),\n+\t\t\t\t     expr.get_outer_attrs ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::ArithmeticOrLogicalExpr &expr)\n+{\n+  HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_left_expr ().get ());\n+  rust_assert (lhs != nullptr);\n+  HIR::Expr *rhs = ASTLoweringExpr::translate (expr.get_right_expr ().get ());\n+  rust_assert (rhs != nullptr);\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated = new HIR::ArithmeticOrLogicalExpr (\n+    mapping, std::unique_ptr<HIR::Expr> (lhs), std::unique_ptr<HIR::Expr> (rhs),\n+    expr.get_expr_type (), expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::ComparisonExpr &expr)\n+{\n+  HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_left_expr ().get ());\n+  rust_assert (lhs != nullptr);\n+  HIR::Expr *rhs = ASTLoweringExpr::translate (expr.get_right_expr ().get ());\n+  rust_assert (rhs != nullptr);\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::ComparisonExpr (mapping, std::unique_ptr<HIR::Expr> (lhs),\n+\t\t\t       std::unique_ptr<HIR::Expr> (rhs),\n+\t\t\t       expr.get_expr_type (), expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::LazyBooleanExpr &expr)\n+{\n+  HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_left_expr ().get ());\n+  rust_assert (lhs != nullptr);\n+  HIR::Expr *rhs = ASTLoweringExpr::translate (expr.get_right_expr ().get ());\n+  rust_assert (rhs != nullptr);\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::LazyBooleanExpr (mapping, std::unique_ptr<HIR::Expr> (lhs),\n+\t\t\t\tstd::unique_ptr<HIR::Expr> (rhs),\n+\t\t\t\texpr.get_expr_type (), expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::NegationExpr &expr)\n+{\n+  HIR::Expr *negated_value\n+    = ASTLoweringExpr::translate (expr.get_negated_expr ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+  translated\n+    = new HIR::NegationExpr (mapping,\n+\t\t\t     std::unique_ptr<HIR::Expr> (negated_value),\n+\t\t\t     expr.get_expr_type (), expr.get_outer_attrs (),\n+\t\t\t     expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::TypeCastExpr &expr)\n+{\n+  HIR::Expr *expr_to_cast_to\n+    = ASTLoweringExpr::translate (expr.get_casted_expr ().get ());\n+  HIR::Type *type_to_cast_to\n+    = lower_type_no_bounds (expr.get_type_to_cast_to ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::TypeCastExpr (mapping,\n+\t\t\t     std::unique_ptr<HIR::Expr> (expr_to_cast_to),\n+\t\t\t     std::unique_ptr<HIR::Type> (type_to_cast_to),\n+\t\t\t     expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::CompoundAssignmentExpr &expr)\n+{\n+  ArithmeticOrLogicalOperator op;\n+  switch (expr.get_expr_type ())\n+    {\n+    case CompoundAssignmentOperator::ADD:\n+      op = ArithmeticOrLogicalOperator::ADD;\n+      break;\n+    case CompoundAssignmentOperator::SUBTRACT:\n+      op = ArithmeticOrLogicalOperator::SUBTRACT;\n+      break;\n+    case CompoundAssignmentOperator::MULTIPLY:\n+      op = ArithmeticOrLogicalOperator::MULTIPLY;\n+      break;\n+    case CompoundAssignmentOperator::DIVIDE:\n+      op = ArithmeticOrLogicalOperator::DIVIDE;\n+      break;\n+    case CompoundAssignmentOperator::MODULUS:\n+      op = ArithmeticOrLogicalOperator::MODULUS;\n+      break;\n+    case CompoundAssignmentOperator::BITWISE_AND:\n+      op = ArithmeticOrLogicalOperator::BITWISE_AND;\n+      break;\n+    case CompoundAssignmentOperator::BITWISE_OR:\n+      op = ArithmeticOrLogicalOperator::BITWISE_OR;\n+      break;\n+    case CompoundAssignmentOperator::BITWISE_XOR:\n+      op = ArithmeticOrLogicalOperator::BITWISE_XOR;\n+      break;\n+    case CompoundAssignmentOperator::LEFT_SHIFT:\n+      op = ArithmeticOrLogicalOperator::LEFT_SHIFT;\n+      break;\n+    case CompoundAssignmentOperator::RIGHT_SHIFT:\n+      op = ArithmeticOrLogicalOperator::RIGHT_SHIFT;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  HIR::Expr *asignee_expr\n+    = ASTLoweringExpr::translate (expr.get_left_expr ().get ());\n+  HIR::Expr *value = ASTLoweringExpr::translate (expr.get_right_expr ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated = new HIR::CompoundAssignmentExpr (\n+    mapping, std::unique_ptr<HIR::Expr> (asignee_expr),\n+    std::unique_ptr<HIR::Expr> (value), op, expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::StructExprStruct &struct_expr)\n+{\n+  HIR::PathInExpression *path\n+    = ASTLowerPathInExpression::translate (&struct_expr.get_struct_name ());\n+  HIR::PathInExpression copied_path (*path);\n+  delete path;\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, struct_expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated = new HIR::StructExprStruct (mapping, copied_path,\n+\t\t\t\t\t  struct_expr.get_inner_attrs (),\n+\t\t\t\t\t  struct_expr.get_outer_attrs (),\n+\t\t\t\t\t  struct_expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::StructExprStructFields &struct_expr)\n+{\n+  // bit of a hack for now\n+  HIR::PathInExpression *path\n+    = ASTLowerPathInExpression::translate (&struct_expr.get_struct_name ());\n+  HIR::PathInExpression copied_path (*path);\n+  delete path;\n+\n+  HIR::StructBase *base = nullptr;\n+  if (struct_expr.has_struct_base ())\n+    {\n+      HIR::Expr *translated_base = ASTLoweringExpr::translate (\n+\tstruct_expr.get_struct_base ().get_base_struct ().get ());\n+      base = new HIR::StructBase (std::unique_ptr<HIR::Expr> (translated_base));\n+    }\n+\n+  auto const &in_fields = struct_expr.get_fields ();\n+  std::vector<std::unique_ptr<HIR::StructExprField> > fields;\n+  for (auto &field : in_fields)\n+    {\n+      HIR::StructExprField *translated\n+\t= ASTLowerStructExprField::translate (field.get ());\n+      fields.push_back (std::unique_ptr<HIR::StructExprField> (translated));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, struct_expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::StructExprStructFields (mapping, copied_path, std::move (fields),\n+\t\t\t\t       struct_expr.get_locus (), base,\n+\t\t\t\t       struct_expr.get_inner_attrs (),\n+\t\t\t\t       struct_expr.get_outer_attrs ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::GroupedExpr &expr)\n+{\n+  HIR::Expr *paren_expr\n+    = ASTLoweringExpr::translate (expr.get_expr_in_parens ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::GroupedExpr (mapping, std::unique_ptr<HIR::Expr> (paren_expr),\n+\t\t\t    expr.get_inner_attrs (), expr.get_outer_attrs (),\n+\t\t\t    expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::FieldAccessExpr &expr)\n+{\n+  HIR::Expr *receiver\n+    = ASTLoweringExpr::translate (expr.get_receiver_expr ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+  translated\n+    = new HIR::FieldAccessExpr (mapping, std::unique_ptr<HIR::Expr> (receiver),\n+\t\t\t\texpr.get_field_name (), expr.get_outer_attrs (),\n+\t\t\t\texpr.get_locus ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::LoopExpr &expr)\n+{\n+  translated = ASTLoweringExprWithBlock::translate (&expr, &terminated);\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::WhileLoopExpr &expr)\n+{\n+  translated = ASTLoweringExprWithBlock::translate (&expr, &terminated);\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::ForLoopExpr &expr)\n+{\n+  translated = ASTLoweringExprWithBlock::translate (&expr, &terminated);\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::BreakExpr &expr)\n+{\n+  HIR::Lifetime break_label = lower_lifetime (expr.get_label ());\n+  HIR::Expr *break_expr\n+    = expr.has_break_expr ()\n+\t? ASTLoweringExpr::translate (expr.get_break_expr ().get ())\n+\t: nullptr;\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::BreakExpr (mapping, expr.get_locus (), std ::move (break_label),\n+\t\t\t  std::unique_ptr<HIR::Expr> (break_expr),\n+\t\t\t  expr.get_outer_attrs ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::ContinueExpr &expr)\n+{\n+  HIR::Lifetime break_label = lower_lifetime (expr.get_label ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::ContinueExpr (mapping, expr.get_locus (),\n+\t\t\t     std ::move (break_label), expr.get_outer_attrs ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::BorrowExpr &expr)\n+{\n+  HIR::Expr *borrow_lvalue\n+    = ASTLoweringExpr::translate (expr.get_borrowed_expr ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  HIR::BorrowExpr *borrow_expr\n+    = new HIR::BorrowExpr (mapping, std::unique_ptr<HIR::Expr> (borrow_lvalue),\n+\t\t\t   expr.get_is_mut () ? Mutability::Mut\n+\t\t\t\t\t      : Mutability::Imm,\n+\t\t\t   expr.get_outer_attrs (), expr.get_locus ());\n+\n+  if (expr.get_is_double_borrow ())\n+    {\n+      NodeId artifical_bouble_borrow_id = mappings->get_next_node_id ();\n+      Analysis::NodeMapping mapping (crate_num, artifical_bouble_borrow_id,\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     UNKNOWN_LOCAL_DEFID);\n+\n+      borrow_expr\n+\t= new HIR::BorrowExpr (mapping,\n+\t\t\t       std::unique_ptr<HIR::Expr> (borrow_expr),\n+\t\t\t       expr.get_is_mut () ? Mutability::Mut\n+\t\t\t\t\t\t  : Mutability::Imm,\n+\t\t\t       expr.get_outer_attrs (), expr.get_locus ());\n+    }\n+\n+  translated = borrow_expr;\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::DereferenceExpr &expr)\n+{\n+  HIR::Expr *dref_lvalue\n+    = ASTLoweringExpr::translate (expr.get_dereferenced_expr ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::DereferenceExpr (mapping,\n+\t\t\t\tstd::unique_ptr<HIR::Expr> (dref_lvalue),\n+\t\t\t\texpr.get_outer_attrs (), expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::MatchExpr &expr)\n+{\n+  translated = ASTLoweringExprWithBlock::translate (&expr, &terminated);\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::RangeFromToExpr &expr)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  HIR::Expr *range_from\n+    = ASTLoweringExpr::translate (expr.get_from_expr ().get ());\n+  HIR::Expr *range_to = ASTLoweringExpr::translate (expr.get_to_expr ().get ());\n+\n+  translated\n+    = new HIR::RangeFromToExpr (mapping,\n+\t\t\t\tstd::unique_ptr<HIR::Expr> (range_from),\n+\t\t\t\tstd::unique_ptr<HIR::Expr> (range_to),\n+\t\t\t\texpr.get_locus ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::RangeFromExpr &expr)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  HIR::Expr *range_from\n+    = ASTLoweringExpr::translate (expr.get_from_expr ().get ());\n+\n+  translated\n+    = new HIR::RangeFromExpr (mapping, std::unique_ptr<HIR::Expr> (range_from),\n+\t\t\t      expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::RangeToExpr &expr)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  HIR::Expr *range_to = ASTLoweringExpr::translate (expr.get_to_expr ().get ());\n+\n+  translated\n+    = new HIR::RangeToExpr (mapping, std::unique_ptr<HIR::Expr> (range_to),\n+\t\t\t    expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::RangeFullExpr &expr)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated = new HIR::RangeFullExpr (mapping, expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::RangeFromToInclExpr &expr)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  HIR::Expr *range_from\n+    = ASTLoweringExpr::translate (expr.get_from_expr ().get ());\n+  HIR::Expr *range_to = ASTLoweringExpr::translate (expr.get_to_expr ().get ());\n+\n+  translated\n+    = new HIR::RangeFromToInclExpr (mapping,\n+\t\t\t\t    std::unique_ptr<HIR::Expr> (range_from),\n+\t\t\t\t    std::unique_ptr<HIR::Expr> (range_to),\n+\t\t\t\t    expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::ClosureExprInner &expr)\n+{\n+  HIR::Expr *closure_expr\n+    = ASTLoweringExpr::translate (expr.get_definition_expr ().get ());\n+\n+  std::vector<HIR::ClosureParam> closure_params;\n+  for (auto &param : expr.get_params ())\n+    {\n+      HIR::ClosureParam p = lower_closure_param (param);\n+      closure_params.push_back (std::move (p));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated\n+    = new HIR::ClosureExpr (mapping, std::move (closure_params),\n+\t\t\t    nullptr /* closure_return_type */,\n+\t\t\t    std::unique_ptr<HIR::Expr> (closure_expr),\n+\t\t\t    expr.get_has_move (), expr.get_outer_attrs (),\n+\t\t\t    expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringExpr::visit (AST::ClosureExprInnerTyped &expr)\n+{\n+  HIR::Type *closure_return_type = nullptr;\n+  HIR::Expr *closure_expr\n+    = ASTLoweringExpr::translate (expr.get_definition_block ().get ());\n+\n+  std::vector<HIR::ClosureParam> closure_params;\n+  for (auto &param : expr.get_params ())\n+    {\n+      HIR::ClosureParam p = lower_closure_param (param);\n+      closure_params.push_back (std::move (p));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated\n+    = new HIR::ClosureExpr (mapping, std::move (closure_params),\n+\t\t\t    std::unique_ptr<HIR::Type> (closure_return_type),\n+\t\t\t    std::unique_ptr<HIR::Expr> (closure_expr),\n+\t\t\t    expr.get_has_move (), expr.get_outer_attrs (),\n+\t\t\t    expr.get_locus ());\n+}\n+\n+} // namespace HIR\n+} // namespace Rust"}, {"sha": "0963e40c5f0d6327be8a24c63b8356d2716490fc", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 47, "deletions": 699, "changes": 746, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -19,11 +19,7 @@\n #ifndef RUST_AST_LOWER_EXPR\n #define RUST_AST_LOWER_EXPR\n \n-#include \"rust-diagnostics.h\"\n #include \"rust-ast-lower-base.h\"\n-#include \"rust-ast-lower-block.h\"\n-#include \"rust-ast-lower-struct-field-expr.h\"\n-#include \"rust-ast-lower-pattern.h\"\n \n namespace Rust {\n namespace HIR {\n@@ -76,703 +72,55 @@ class ASTLoweringExpr : public ASTLoweringBase\n   using Rust::HIR::ASTLoweringBase::visit;\n \n public:\n-  static HIR::Expr *translate (AST::Expr *expr, bool *terminated = nullptr)\n-  {\n-    ASTLoweringExpr resolver;\n-    expr->accept_vis (resolver);\n-    if (resolver.translated == nullptr)\n-      {\n-\trust_fatal_error (expr->get_locus (), \"Failed to lower expr: [%s]\",\n-\t\t\t  expr->as_string ().c_str ());\n-\treturn nullptr;\n-      }\n-\n-    resolver.mappings->insert_hir_expr (resolver.translated);\n-    resolver.mappings->insert_location (\n-      resolver.translated->get_mappings ().get_hirid (), expr->get_locus ());\n-\n-    if (terminated != nullptr)\n-      *terminated = resolver.terminated;\n-\n-    return resolver.translated;\n-  }\n-\n-  void visit (AST::TupleIndexExpr &expr) override\n-  {\n-    HIR::Expr *tuple_expr\n-      = ASTLoweringExpr::translate (expr.get_tuple_expr ().get (), &terminated);\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated\n-      = new HIR::TupleIndexExpr (mapping,\n-\t\t\t\t std::unique_ptr<HIR::Expr> (tuple_expr),\n-\t\t\t\t expr.get_tuple_index (),\n-\t\t\t\t expr.get_outer_attrs (), expr.get_locus ());\n-  }\n-\n-  void visit (AST::TupleExpr &expr) override\n-  {\n-    std::vector<std::unique_ptr<HIR::Expr> > tuple_elements;\n-    for (auto &e : expr.get_tuple_elems ())\n-      {\n-\tHIR::Expr *t = ASTLoweringExpr::translate (e.get ());\n-\ttuple_elements.push_back (std::unique_ptr<HIR::Expr> (t));\n-      }\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated\n-      = new HIR::TupleExpr (std::move (mapping), std::move (tuple_elements),\n-\t\t\t    expr.get_inner_attrs (), expr.get_outer_attrs (),\n-\t\t\t    expr.get_locus ());\n-  }\n-\n-  void visit (AST::IfExpr &expr) override\n-  {\n-    translated = ASTLoweringIfBlock::translate (&expr, &terminated);\n-  }\n-\n-  void visit (AST::IfExprConseqElse &expr) override\n-  {\n-    translated = ASTLoweringIfBlock::translate (&expr, &terminated);\n-  }\n-\n-  void visit (AST::IfExprConseqIf &expr) override\n-  {\n-    translated = ASTLoweringIfBlock::translate (&expr, &terminated);\n-  }\n-\n-  void visit (AST::BlockExpr &expr) override\n-  {\n-    translated = ASTLoweringBlock::translate (&expr, &terminated);\n-  }\n-\n-  void visit (AST::UnsafeBlockExpr &expr) override\n-  {\n-    translated = ASTLoweringBlock::translate (&expr, &terminated);\n-  }\n-\n-  void visit (AST::PathInExpression &expr) override\n-  {\n-    translated = ASTLowerPathInExpression::translate (&expr);\n-  }\n-\n-  void visit (AST::QualifiedPathInExpression &expr) override\n-  {\n-    translated = ASTLowerQualPathInExpression::translate (&expr);\n-  }\n-\n-  void visit (AST::ReturnExpr &expr) override\n-  {\n-    terminated = true;\n-    HIR::Expr *return_expr\n-      = expr.has_returned_expr ()\n-\t  ? ASTLoweringExpr::translate (expr.get_returned_expr ().get ())\n-\t  : nullptr;\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated = new HIR::ReturnExpr (mapping, expr.get_locus (),\n-\t\t\t\t      std::unique_ptr<HIR::Expr> (return_expr));\n-  }\n-\n-  void visit (AST::CallExpr &expr) override\n-  {\n-    HIR::Expr *func\n-      = ASTLoweringExpr::translate (expr.get_function_expr ().get ());\n-\n-    auto const &in_params = expr.get_params ();\n-    std::vector<std::unique_ptr<HIR::Expr> > params;\n-    for (auto &param : in_params)\n-      {\n-\tauto trans = ASTLoweringExpr::translate (param.get ());\n-\tparams.push_back (std::unique_ptr<HIR::Expr> (trans));\n-      }\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (\n-      crate_num, UNKNOWN_NODEID /* this can map back to the AST*/,\n-      mappings->get_next_hir_id (crate_num), UNKNOWN_LOCAL_DEFID);\n-\n-    translated = new HIR::CallExpr (mapping, std::unique_ptr<HIR::Expr> (func),\n-\t\t\t\t    std::move (params), expr.get_outer_attrs (),\n-\t\t\t\t    expr.get_locus ());\n-  }\n-\n-  void visit (AST::MethodCallExpr &expr) override\n-  {\n-    HIR::PathExprSegment method_path\n-      = lower_path_expr_seg (expr.get_method_name ());\n-\n-    HIR::Expr *receiver\n-      = ASTLoweringExpr::translate (expr.get_receiver_expr ().get ());\n-\n-    auto const &in_params = expr.get_params ();\n-    std::vector<std::unique_ptr<HIR::Expr> > params;\n-    for (auto &param : in_params)\n-      {\n-\tauto trans = ASTLoweringExpr::translate (param.get ());\n-\tparams.push_back (std::unique_ptr<HIR::Expr> (trans));\n-      }\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated\n-      = new HIR::MethodCallExpr (mapping, std::unique_ptr<HIR::Expr> (receiver),\n-\t\t\t\t method_path, std::move (params),\n-\t\t\t\t expr.get_outer_attrs (), expr.get_locus ());\n-  }\n-\n-  void visit (AST::AssignmentExpr &expr) override\n-  {\n-    HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_left_expr ().get ());\n-    HIR::Expr *rhs = ASTLoweringExpr::translate (expr.get_right_expr ().get ());\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated\n-      = new HIR::AssignmentExpr (mapping, std::unique_ptr<HIR::Expr> (lhs),\n-\t\t\t\t std::unique_ptr<HIR::Expr> (rhs),\n-\t\t\t\t expr.get_locus ());\n-  }\n-\n-  void visit (AST::IdentifierExpr &expr) override\n-  {\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping1 (crate_num, expr.get_node_id (),\n-\t\t\t\t    mappings->get_next_hir_id (crate_num),\n-\t\t\t\t    UNKNOWN_LOCAL_DEFID);\n-    Analysis::NodeMapping mapping2 (mapping1);\n-\n-    HIR::PathIdentSegment ident_seg (expr.get_ident ());\n-    HIR::PathExprSegment seg (mapping1, ident_seg, expr.get_locus (),\n-\t\t\t      HIR::GenericArgs::create_empty ());\n-    translated = new HIR::PathInExpression (mapping2, {seg}, expr.get_locus (),\n-\t\t\t\t\t    false, expr.get_outer_attrs ());\n-  }\n-\n-  void visit (AST::ArrayExpr &expr) override\n-  {\n-    expr.get_array_elems ()->accept_vis (*this);\n-    rust_assert (translated_array_elems != nullptr);\n-    HIR::ArrayElems *elems = translated_array_elems;\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated\n-      = new HIR::ArrayExpr (mapping, std::unique_ptr<HIR::ArrayElems> (elems),\n-\t\t\t    expr.get_inner_attrs (), expr.get_outer_attrs (),\n-\t\t\t    expr.get_locus ());\n-  }\n-\n-  void visit (AST::ArrayIndexExpr &expr) override\n-  {\n-    HIR::Expr *array_expr\n-      = ASTLoweringExpr::translate (expr.get_array_expr ().get ());\n-    HIR::Expr *array_index_expr\n-      = ASTLoweringExpr::translate (expr.get_index_expr ().get ());\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated\n-      = new HIR::ArrayIndexExpr (mapping,\n-\t\t\t\t std::unique_ptr<HIR::Expr> (array_expr),\n-\t\t\t\t std::unique_ptr<HIR::Expr> (array_index_expr),\n-\t\t\t\t expr.get_outer_attrs (), expr.get_locus ());\n-  }\n-\n-  void visit (AST::ArrayElemsValues &elems) override\n-  {\n-    std::vector<std::unique_ptr<HIR::Expr> > elements;\n-    for (auto &elem : elems.get_values ())\n-      {\n-\tHIR::Expr *translated_elem = ASTLoweringExpr::translate (elem.get ());\n-\telements.push_back (std::unique_ptr<HIR::Expr> (translated_elem));\n-      }\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (mappings->get_current_crate (),\n-\t\t\t\t   elems.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated_array_elems\n-      = new HIR::ArrayElemsValues (mapping, std::move (elements));\n-  }\n-\n-  void visit (AST::ArrayElemsCopied &elems) override\n-  {\n-    HIR::Expr *element\n-      = ASTLoweringExpr::translate (elems.get_elem_to_copy ().get ());\n-    HIR::Expr *num_copies\n-      = ASTLoweringExpr::translate (elems.get_num_copies ().get ());\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (mappings->get_current_crate (),\n-\t\t\t\t   elems.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated_array_elems\n-      = new HIR::ArrayElemsCopied (mapping,\n-\t\t\t\t   std::unique_ptr<HIR::Expr> (element),\n-\t\t\t\t   std::unique_ptr<HIR::Expr> (num_copies));\n-  }\n-\n-  void visit (AST::LiteralExpr &expr) override\n-  {\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    HIR::Literal l = lower_literal (expr.get_literal ());\n-    translated\n-      = new HIR::LiteralExpr (mapping, std::move (l), expr.get_locus (),\n-\t\t\t      expr.get_outer_attrs ());\n-  }\n-\n-  void visit (AST::ArithmeticOrLogicalExpr &expr) override\n-  {\n-    HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_left_expr ().get ());\n-    rust_assert (lhs != nullptr);\n-    HIR::Expr *rhs = ASTLoweringExpr::translate (expr.get_right_expr ().get ());\n-    rust_assert (rhs != nullptr);\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated\n-      = new HIR::ArithmeticOrLogicalExpr (mapping,\n-\t\t\t\t\t  std::unique_ptr<HIR::Expr> (lhs),\n-\t\t\t\t\t  std::unique_ptr<HIR::Expr> (rhs),\n-\t\t\t\t\t  expr.get_expr_type (),\n-\t\t\t\t\t  expr.get_locus ());\n-  }\n-\n-  void visit (AST::ComparisonExpr &expr) override\n-  {\n-    HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_left_expr ().get ());\n-    rust_assert (lhs != nullptr);\n-    HIR::Expr *rhs = ASTLoweringExpr::translate (expr.get_right_expr ().get ());\n-    rust_assert (rhs != nullptr);\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated\n-      = new HIR::ComparisonExpr (mapping, std::unique_ptr<HIR::Expr> (lhs),\n-\t\t\t\t std::unique_ptr<HIR::Expr> (rhs),\n-\t\t\t\t expr.get_expr_type (), expr.get_locus ());\n-  }\n-\n-  void visit (AST::LazyBooleanExpr &expr) override\n-  {\n-    HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_left_expr ().get ());\n-    rust_assert (lhs != nullptr);\n-    HIR::Expr *rhs = ASTLoweringExpr::translate (expr.get_right_expr ().get ());\n-    rust_assert (rhs != nullptr);\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated\n-      = new HIR::LazyBooleanExpr (mapping, std::unique_ptr<HIR::Expr> (lhs),\n-\t\t\t\t  std::unique_ptr<HIR::Expr> (rhs),\n-\t\t\t\t  expr.get_expr_type (), expr.get_locus ());\n-  }\n-\n-  void visit (AST::NegationExpr &expr) override\n-  {\n-    HIR::Expr *negated_value\n-      = ASTLoweringExpr::translate (expr.get_negated_expr ().get ());\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-    translated\n-      = new HIR::NegationExpr (mapping,\n-\t\t\t       std::unique_ptr<HIR::Expr> (negated_value),\n-\t\t\t       expr.get_expr_type (), expr.get_outer_attrs (),\n-\t\t\t       expr.get_locus ());\n-  }\n-\n-  void visit (AST::TypeCastExpr &expr) override\n-  {\n-    HIR::Expr *expr_to_cast_to\n-      = ASTLoweringExpr::translate (expr.get_casted_expr ().get ());\n-    HIR::Type *type_to_cast_to\n-      = lower_type_no_bounds (expr.get_type_to_cast_to ().get ());\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated\n-      = new HIR::TypeCastExpr (mapping,\n-\t\t\t       std::unique_ptr<HIR::Expr> (expr_to_cast_to),\n-\t\t\t       std::unique_ptr<HIR::Type> (type_to_cast_to),\n-\t\t\t       expr.get_locus ());\n-  }\n-\n-  void visit (AST::CompoundAssignmentExpr &expr) override\n-  {\n-    ArithmeticOrLogicalOperator op;\n-    switch (expr.get_expr_type ())\n-      {\n-      case CompoundAssignmentOperator::ADD:\n-\top = ArithmeticOrLogicalOperator::ADD;\n-\tbreak;\n-      case CompoundAssignmentOperator::SUBTRACT:\n-\top = ArithmeticOrLogicalOperator::SUBTRACT;\n-\tbreak;\n-      case CompoundAssignmentOperator::MULTIPLY:\n-\top = ArithmeticOrLogicalOperator::MULTIPLY;\n-\tbreak;\n-      case CompoundAssignmentOperator::DIVIDE:\n-\top = ArithmeticOrLogicalOperator::DIVIDE;\n-\tbreak;\n-      case CompoundAssignmentOperator::MODULUS:\n-\top = ArithmeticOrLogicalOperator::MODULUS;\n-\tbreak;\n-      case CompoundAssignmentOperator::BITWISE_AND:\n-\top = ArithmeticOrLogicalOperator::BITWISE_AND;\n-\tbreak;\n-      case CompoundAssignmentOperator::BITWISE_OR:\n-\top = ArithmeticOrLogicalOperator::BITWISE_OR;\n-\tbreak;\n-      case CompoundAssignmentOperator::BITWISE_XOR:\n-\top = ArithmeticOrLogicalOperator::BITWISE_XOR;\n-\tbreak;\n-      case CompoundAssignmentOperator::LEFT_SHIFT:\n-\top = ArithmeticOrLogicalOperator::LEFT_SHIFT;\n-\tbreak;\n-      case CompoundAssignmentOperator::RIGHT_SHIFT:\n-\top = ArithmeticOrLogicalOperator::RIGHT_SHIFT;\n-\tbreak;\n-      default:\n-\tgcc_unreachable ();\n-      }\n-\n-    HIR::Expr *asignee_expr\n-      = ASTLoweringExpr::translate (expr.get_left_expr ().get ());\n-    HIR::Expr *value\n-      = ASTLoweringExpr::translate (expr.get_right_expr ().get ());\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated = new HIR::CompoundAssignmentExpr (\n-      mapping, std::unique_ptr<HIR::Expr> (asignee_expr),\n-      std::unique_ptr<HIR::Expr> (value), op, expr.get_locus ());\n-  }\n-\n-  void visit (AST::StructExprStruct &struct_expr) override\n-  {\n-    HIR::PathInExpression *path\n-      = ASTLowerPathInExpression::translate (&struct_expr.get_struct_name ());\n-    HIR::PathInExpression copied_path (*path);\n-    delete path;\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, struct_expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated = new HIR::StructExprStruct (mapping, copied_path,\n-\t\t\t\t\t    struct_expr.get_inner_attrs (),\n-\t\t\t\t\t    struct_expr.get_outer_attrs (),\n-\t\t\t\t\t    struct_expr.get_locus ());\n-  }\n-\n-  void visit (AST::StructExprStructFields &struct_expr) override\n-  {\n-    // bit of a hack for now\n-    HIR::PathInExpression *path\n-      = ASTLowerPathInExpression::translate (&struct_expr.get_struct_name ());\n-    HIR::PathInExpression copied_path (*path);\n-    delete path;\n-\n-    HIR::StructBase *base = nullptr;\n-    if (struct_expr.has_struct_base ())\n-      {\n-\tHIR::Expr *translated_base = ASTLoweringExpr::translate (\n-\t  struct_expr.get_struct_base ().get_base_struct ().get ());\n-\tbase\n-\t  = new HIR::StructBase (std::unique_ptr<HIR::Expr> (translated_base));\n-      }\n-\n-    auto const &in_fields = struct_expr.get_fields ();\n-    std::vector<std::unique_ptr<HIR::StructExprField> > fields;\n-    for (auto &field : in_fields)\n-      {\n-\tHIR::StructExprField *translated\n-\t  = ASTLowerStructExprField::translate (field.get ());\n-\tfields.push_back (std::unique_ptr<HIR::StructExprField> (translated));\n-      }\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, struct_expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated = new HIR::StructExprStructFields (\n-      mapping, copied_path, std::move (fields), struct_expr.get_locus (), base,\n-      struct_expr.get_inner_attrs (), struct_expr.get_outer_attrs ());\n-  }\n-\n-  void visit (AST::GroupedExpr &expr) override\n-  {\n-    HIR::Expr *paren_expr\n-      = ASTLoweringExpr::translate (expr.get_expr_in_parens ().get ());\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated\n-      = new HIR::GroupedExpr (mapping, std::unique_ptr<HIR::Expr> (paren_expr),\n-\t\t\t      expr.get_inner_attrs (), expr.get_outer_attrs (),\n-\t\t\t      expr.get_locus ());\n-  }\n-\n-  void visit (AST::FieldAccessExpr &expr) override\n-  {\n-    HIR::Expr *receiver\n-      = ASTLoweringExpr::translate (expr.get_receiver_expr ().get ());\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-    translated\n-      = new HIR::FieldAccessExpr (mapping,\n-\t\t\t\t  std::unique_ptr<HIR::Expr> (receiver),\n-\t\t\t\t  expr.get_field_name (),\n-\t\t\t\t  expr.get_outer_attrs (), expr.get_locus ());\n-  }\n-\n-  void visit (AST::LoopExpr &expr) override\n-  {\n-    translated = ASTLoweringExprWithBlock::translate (&expr, &terminated);\n-  }\n-\n-  void visit (AST::WhileLoopExpr &expr) override\n-  {\n-    translated = ASTLoweringExprWithBlock::translate (&expr, &terminated);\n-  }\n-\n-  void visit (AST::ForLoopExpr &expr) override\n-  {\n-    translated = ASTLoweringExprWithBlock::translate (&expr, &terminated);\n-  }\n-\n-  void visit (AST::BreakExpr &expr) override\n-  {\n-    HIR::Lifetime break_label = lower_lifetime (expr.get_label ());\n-    HIR::Expr *break_expr\n-      = expr.has_break_expr ()\n-\t  ? ASTLoweringExpr::translate (expr.get_break_expr ().get ())\n-\t  : nullptr;\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated = new HIR::BreakExpr (mapping, expr.get_locus (),\n-\t\t\t\t     std ::move (break_label),\n-\t\t\t\t     std::unique_ptr<HIR::Expr> (break_expr),\n-\t\t\t\t     expr.get_outer_attrs ());\n-  }\n-\n-  void visit (AST::ContinueExpr &expr) override\n-  {\n-    HIR::Lifetime break_label = lower_lifetime (expr.get_label ());\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated = new HIR::ContinueExpr (mapping, expr.get_locus (),\n-\t\t\t\t\tstd ::move (break_label),\n-\t\t\t\t\texpr.get_outer_attrs ());\n-  }\n-\n-  void visit (AST::BorrowExpr &expr) override\n-  {\n-    HIR::Expr *borrow_lvalue\n-      = ASTLoweringExpr::translate (expr.get_borrowed_expr ().get ());\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    HIR::BorrowExpr *borrow_expr\n-      = new HIR::BorrowExpr (mapping,\n-\t\t\t     std::unique_ptr<HIR::Expr> (borrow_lvalue),\n-\t\t\t     expr.get_is_mut () ? Mutability::Mut\n-\t\t\t\t\t\t: Mutability::Imm,\n-\t\t\t     expr.get_outer_attrs (), expr.get_locus ());\n-\n-    if (expr.get_is_double_borrow ())\n-      {\n-\tNodeId artifical_bouble_borrow_id = mappings->get_next_node_id ();\n-\tAnalysis::NodeMapping mapping (crate_num, artifical_bouble_borrow_id,\n-\t\t\t\t       mappings->get_next_hir_id (crate_num),\n-\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n-\n-\tborrow_expr\n-\t  = new HIR::BorrowExpr (mapping,\n-\t\t\t\t std::unique_ptr<HIR::Expr> (borrow_expr),\n-\t\t\t\t expr.get_is_mut () ? Mutability::Mut\n-\t\t\t\t\t\t    : Mutability::Imm,\n-\t\t\t\t expr.get_outer_attrs (), expr.get_locus ());\n-      }\n-\n-    translated = borrow_expr;\n-  }\n-\n-  void visit (AST::DereferenceExpr &expr) override\n-  {\n-    HIR::Expr *dref_lvalue\n-      = ASTLoweringExpr::translate (expr.get_dereferenced_expr ().get ());\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated\n-      = new HIR::DereferenceExpr (mapping,\n-\t\t\t\t  std::unique_ptr<HIR::Expr> (dref_lvalue),\n-\t\t\t\t  expr.get_outer_attrs (), expr.get_locus ());\n-  }\n-\n-  void visit (AST::MatchExpr &expr) override\n-  {\n-    translated = ASTLoweringExprWithBlock::translate (&expr, &terminated);\n-  }\n-\n-  void visit (AST::RangeFromToExpr &expr) override\n-  {\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    HIR::Expr *range_from\n-      = ASTLoweringExpr::translate (expr.get_from_expr ().get ());\n-    HIR::Expr *range_to\n-      = ASTLoweringExpr::translate (expr.get_to_expr ().get ());\n-\n-    translated\n-      = new HIR::RangeFromToExpr (mapping,\n-\t\t\t\t  std::unique_ptr<HIR::Expr> (range_from),\n-\t\t\t\t  std::unique_ptr<HIR::Expr> (range_to),\n-\t\t\t\t  expr.get_locus ());\n-  }\n-\n-  void visit (AST::RangeFromExpr &expr) override\n-  {\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    HIR::Expr *range_from\n-      = ASTLoweringExpr::translate (expr.get_from_expr ().get ());\n-\n-    translated\n-      = new HIR::RangeFromExpr (mapping,\n-\t\t\t\tstd::unique_ptr<HIR::Expr> (range_from),\n-\t\t\t\texpr.get_locus ());\n-  }\n-\n-  void visit (AST::RangeToExpr &expr) override\n-  {\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    HIR::Expr *range_to\n-      = ASTLoweringExpr::translate (expr.get_to_expr ().get ());\n-\n-    translated\n-      = new HIR::RangeToExpr (mapping, std::unique_ptr<HIR::Expr> (range_to),\n-\t\t\t      expr.get_locus ());\n-  }\n-\n-  void visit (AST::RangeFullExpr &expr) override\n-  {\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated = new HIR::RangeFullExpr (mapping, expr.get_locus ());\n-  }\n-\n-  void visit (AST::RangeFromToInclExpr &expr) override\n-  {\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    HIR::Expr *range_from\n-      = ASTLoweringExpr::translate (expr.get_from_expr ().get ());\n-    HIR::Expr *range_to\n-      = ASTLoweringExpr::translate (expr.get_to_expr ().get ());\n-\n-    translated\n-      = new HIR::RangeFromToInclExpr (mapping,\n-\t\t\t\t      std::unique_ptr<HIR::Expr> (range_from),\n-\t\t\t\t      std::unique_ptr<HIR::Expr> (range_to),\n-\t\t\t\t      expr.get_locus ());\n-  }\n+  static HIR::Expr *translate (AST::Expr *expr, bool *terminated = nullptr);\n+\n+  void visit (AST::TupleIndexExpr &expr) override;\n+  void visit (AST::TupleExpr &expr) override;\n+  void visit (AST::IfExpr &expr) override;\n+  void visit (AST::IfExprConseqElse &expr) override;\n+  void visit (AST::IfExprConseqIf &expr) override;\n+  void visit (AST::BlockExpr &expr) override;\n+  void visit (AST::UnsafeBlockExpr &expr) override;\n+  void visit (AST::PathInExpression &expr) override;\n+  void visit (AST::QualifiedPathInExpression &expr) override;\n+  void visit (AST::ReturnExpr &expr) override;\n+  void visit (AST::CallExpr &expr) override;\n+  void visit (AST::MethodCallExpr &expr) override;\n+  void visit (AST::AssignmentExpr &expr) override;\n+  void visit (AST::IdentifierExpr &expr) override;\n+  void visit (AST::ArrayExpr &expr) override;\n+  void visit (AST::ArrayIndexExpr &expr) override;\n+  void visit (AST::ArrayElemsValues &elems) override;\n+  void visit (AST::ArrayElemsCopied &elems) override;\n+  void visit (AST::LiteralExpr &expr) override;\n+  void visit (AST::ArithmeticOrLogicalExpr &expr) override;\n+  void visit (AST::ComparisonExpr &expr) override;\n+  void visit (AST::LazyBooleanExpr &expr) override;\n+  void visit (AST::NegationExpr &expr) override;\n+  void visit (AST::TypeCastExpr &expr) override;\n+  void visit (AST::CompoundAssignmentExpr &expr) override;\n+  void visit (AST::StructExprStruct &struct_expr) override;\n+  void visit (AST::StructExprStructFields &struct_expr) override;\n+  void visit (AST::GroupedExpr &expr) override;\n+  void visit (AST::FieldAccessExpr &expr) override;\n+  void visit (AST::LoopExpr &expr) override;\n+  void visit (AST::WhileLoopExpr &expr) override;\n+  void visit (AST::ForLoopExpr &expr) override;\n+  void visit (AST::BreakExpr &expr) override;\n+  void visit (AST::ContinueExpr &expr) override;\n+  void visit (AST::BorrowExpr &expr) override;\n+  void visit (AST::DereferenceExpr &expr) override;\n+  void visit (AST::MatchExpr &expr) override;\n+  void visit (AST::RangeFromToExpr &expr) override;\n+  void visit (AST::RangeFromExpr &expr) override;\n+  void visit (AST::RangeToExpr &expr) override;\n+  void visit (AST::RangeFullExpr &expr) override;\n+  void visit (AST::RangeFromToInclExpr &expr) override;\n+  void visit (AST::ClosureExprInner &expr) override;\n+  void visit (AST::ClosureExprInnerTyped &expr) override;\n \n private:\n-  ASTLoweringExpr ()\n-    : ASTLoweringBase (), translated (nullptr),\n-      translated_array_elems (nullptr), terminated (false)\n-  {}\n+  ASTLoweringExpr ();\n \n   HIR::Expr *translated;\n   HIR::ArrayElems *translated_array_elems;"}, {"sha": "2c9a0dc59a18b0fff24fdc44c1e46b5cc56cf6b9", "filename": "gcc/rust/hir/rust-ast-lower-pattern.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.cc?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -22,6 +22,24 @@\n namespace Rust {\n namespace HIR {\n \n+ASTLoweringPattern::ASTLoweringPattern () : translated (nullptr) {}\n+\n+HIR::Pattern *\n+ASTLoweringPattern::translate (AST::Pattern *pattern)\n+{\n+  ASTLoweringPattern resolver;\n+  pattern->accept_vis (resolver);\n+\n+  rust_assert (resolver.translated != nullptr);\n+\n+  resolver.mappings->insert_hir_pattern (resolver.translated);\n+  resolver.mappings->insert_location (\n+    resolver.translated->get_pattern_mappings ().get_hirid (),\n+    pattern->get_locus ());\n+\n+  return resolver.translated;\n+}\n+\n void\n ASTLoweringPattern::visit (AST::IdentifierPattern &pattern)\n {"}, {"sha": "4ab81a856a7118ed371df0b3c767c0bebf497777", "filename": "gcc/rust/hir/rust-ast-lower-pattern.h", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -29,39 +29,19 @@ class ASTLoweringPattern : public ASTLoweringBase\n   using Rust::HIR::ASTLoweringBase::visit;\n \n public:\n-  static HIR::Pattern *translate (AST::Pattern *pattern)\n-  {\n-    ASTLoweringPattern resolver;\n-    pattern->accept_vis (resolver);\n-\n-    rust_assert (resolver.translated != nullptr);\n-\n-    resolver.mappings->insert_hir_pattern (resolver.translated);\n-    resolver.mappings->insert_location (\n-      resolver.translated->get_pattern_mappings ().get_hirid (),\n-      pattern->get_locus ());\n-\n-    return resolver.translated;\n-  }\n+  static HIR::Pattern *translate (AST::Pattern *pattern);\n \n   void visit (AST::IdentifierPattern &pattern) override;\n-\n   void visit (AST::PathInExpression &pattern) override;\n-\n   void visit (AST::StructPattern &pattern) override;\n-\n   void visit (AST::TupleStructPattern &pattern) override;\n-\n   void visit (AST::WildcardPattern &pattern) override;\n-\n   void visit (AST::TuplePattern &pattern) override;\n-\n   void visit (AST::LiteralPattern &pattern) override;\n-\n   void visit (AST::RangePattern &pattern) override;\n \n private:\n-  ASTLoweringPattern () : translated (nullptr) {}\n+  ASTLoweringPattern ();\n \n   HIR::Pattern *translated;\n };"}, {"sha": "92a14f4dacf1273c8fce4f09a32ecbbbd0cd51b3", "filename": "gcc/rust/hir/rust-ast-lower-type.cc", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Frust-ast-lower-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Frust-ast-lower-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.cc?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -0,0 +1,232 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-lower-type.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+HIR::TypePath *\n+ASTLowerTypePath::translate (AST::TypePath &type)\n+{\n+  ASTLowerTypePath resolver;\n+  type.accept_vis (resolver);\n+  rust_assert (resolver.translated != nullptr);\n+  return resolver.translated;\n+}\n+\n+void\n+ASTLowerTypePath::visit (AST::TypePathSegmentFunction &segment)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  auto hirid = mappings->get_next_hir_id (crate_num);\n+  Analysis::NodeMapping mapping (crate_num, segment.get_node_id (), hirid,\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  HIR::PathIdentSegment ident (segment.get_ident_segment ().as_string ());\n+\n+  AST::TypePathFunction &fn = segment.get_type_path_function ();\n+  std::vector<std::unique_ptr<HIR::Type>> inputs;\n+  for (auto &param : fn.get_params ())\n+    {\n+      HIR::Type *hir_type = ASTLoweringType::translate (param.get ());\n+      inputs.push_back (std::unique_ptr<HIR::Type> (hir_type));\n+    }\n+\n+  HIR::Type *result_type\n+    = fn.has_return_type ()\n+\t? ASTLoweringType::translate (fn.get_return_type ().get ())\n+\t: nullptr;\n+\n+  HIR::TypePathFunction function_path (std::move (inputs),\n+\t\t\t\t       std::unique_ptr<HIR::Type> (\n+\t\t\t\t\t result_type));\n+\n+  translated_segment = new HIR::TypePathSegmentFunction (\n+    mapping, std::move (ident), segment.get_separating_scope_resolution (),\n+    std::move (function_path), segment.get_locus ());\n+}\n+\n+void\n+ASTLowerTypePath::visit (AST::TypePathSegment &segment)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  auto hirid = mappings->get_next_hir_id (crate_num);\n+  Analysis::NodeMapping mapping (crate_num, segment.get_node_id (), hirid,\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  HIR::PathIdentSegment ident (segment.get_ident_segment ().as_string ());\n+  translated_segment\n+    = new HIR::TypePathSegment (std::move (mapping), ident,\n+\t\t\t\tsegment.get_separating_scope_resolution (),\n+\t\t\t\tsegment.get_locus ());\n+}\n+\n+void\n+ASTLowerTypePath::visit (AST::TypePathSegmentGeneric &segment)\n+{\n+  std::vector<HIR::GenericArgsBinding> binding_args; // TODO\n+\n+  std::string segment_name = segment.get_ident_segment ().as_string ();\n+  bool has_separating_scope_resolution\n+    = segment.get_separating_scope_resolution ();\n+\n+  auto generic_args = lower_generic_args (segment.get_generic_args ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  auto hirid = mappings->get_next_hir_id (crate_num);\n+  Analysis::NodeMapping mapping (crate_num, segment.get_node_id (), hirid,\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated_segment\n+    = new HIR::TypePathSegmentGeneric (std::move (mapping), segment_name,\n+\t\t\t\t       has_separating_scope_resolution,\n+\t\t\t\t       generic_args, segment.get_locus ());\n+}\n+\n+void\n+ASTLowerTypePath::visit (AST::TypePath &path)\n+{\n+  std::vector<std::unique_ptr<HIR::TypePathSegment>> translated_segments;\n+\n+  for (auto &seg : path.get_segments ())\n+    {\n+      translated_segment = nullptr;\n+      seg->accept_vis (*this);\n+      if (translated_segment == nullptr)\n+\t{\n+\t  rust_fatal_error (seg->get_locus (),\n+\t\t\t    \"failed to translate AST TypePathSegment\");\n+\t}\n+      translated_segments.push_back (\n+\tstd::unique_ptr<HIR::TypePathSegment> (translated_segment));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  auto hirid = mappings->get_next_hir_id (crate_num);\n+  Analysis::NodeMapping mapping (crate_num, path.get_node_id (), hirid,\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated\n+    = new HIR::TypePath (std::move (mapping), std::move (translated_segments),\n+\t\t\t path.get_locus (),\n+\t\t\t path.has_opening_scope_resolution_op ());\n+}\n+\n+HIR::QualifiedPathInType *\n+ASTLowerQualifiedPathInType::translate (AST::QualifiedPathInType &type)\n+{\n+  ASTLowerQualifiedPathInType resolver;\n+  type.accept_vis (resolver);\n+  rust_assert (resolver.translated != nullptr);\n+  return resolver.translated;\n+}\n+\n+void\n+ASTLowerQualifiedPathInType::visit (AST::QualifiedPathInType &path)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  auto hirid = mappings->get_next_hir_id (crate_num);\n+  Analysis::NodeMapping qual_mappings (\n+    crate_num, path.get_qualified_path_type ().get_node_id (), hirid,\n+    UNKNOWN_LOCAL_DEFID);\n+\n+  HIR::Type *qual_type = ASTLoweringType::translate (\n+    path.get_qualified_path_type ().get_type ().get ());\n+  HIR::TypePath *qual_trait = ASTLowerTypePath::translate (\n+    path.get_qualified_path_type ().get_as_type_path ());\n+\n+  HIR::QualifiedPathType qual_path_type (\n+    qual_mappings, std::unique_ptr<HIR::Type> (qual_type),\n+    std::unique_ptr<HIR::TypePath> (qual_trait),\n+    path.get_qualified_path_type ().get_locus ());\n+\n+  translated_segment = nullptr;\n+  path.get_associated_segment ()->accept_vis (*this);\n+  if (translated_segment == nullptr)\n+    {\n+      rust_fatal_error (path.get_associated_segment ()->get_locus (),\n+\t\t\t\"failed to translate AST TypePathSegment\");\n+      return;\n+    }\n+  std::unique_ptr<HIR::TypePathSegment> associated_segment (translated_segment);\n+\n+  std::vector<std::unique_ptr<HIR::TypePathSegment>> translated_segments;\n+  for (auto &seg : path.get_segments ())\n+    {\n+      translated_segment = nullptr;\n+      seg->accept_vis (*this);\n+      if (translated_segment == nullptr)\n+\t{\n+\t  rust_fatal_error (seg->get_locus (),\n+\t\t\t    \"failed to translte AST TypePathSegment\");\n+\t}\n+      translated_segments.push_back (\n+\tstd::unique_ptr<HIR::TypePathSegment> (translated_segment));\n+    }\n+\n+  Analysis::NodeMapping mapping (crate_num, path.get_node_id (), hirid,\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+  translated = new HIR::QualifiedPathInType (std::move (mapping),\n+\t\t\t\t\t     std::move (qual_path_type),\n+\t\t\t\t\t     std::move (associated_segment),\n+\t\t\t\t\t     std::move (translated_segments),\n+\t\t\t\t\t     path.get_locus ());\n+}\n+\n+void\n+ASTLoweringType::visit (AST::TraitObjectTypeOneBound &type)\n+{\n+  std::vector<std::unique_ptr<HIR::TypeParamBound>> bounds;\n+  HIR::TypeParamBound *translated_bound\n+    = ASTLoweringTypeBounds::translate (&type.get_trait_bound ());\n+  bounds.push_back (std::unique_ptr<HIR::TypeParamBound> (translated_bound));\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, type.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated = new HIR::TraitObjectType (mapping, std::move (bounds),\n+\t\t\t\t\t type.get_locus (), type.is_dyn ());\n+}\n+\n+void\n+ASTLoweringType::visit (AST::TraitObjectType &type)\n+{\n+  std::vector<std::unique_ptr<HIR::TypeParamBound>> bounds;\n+\n+  for (auto &bound : type.get_type_param_bounds ())\n+    {\n+      HIR::TypeParamBound *translated_bound\n+\t= ASTLoweringTypeBounds::translate (bound.get ());\n+      bounds.push_back (\n+\tstd::unique_ptr<HIR::TypeParamBound> (translated_bound));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, type.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated = new HIR::TraitObjectType (mapping, std::move (bounds),\n+\t\t\t\t\t type.get_locus (), type.is_dyn ());\n+}\n+\n+} // namespace HIR\n+} // namespace Rust"}, {"sha": "d593b4808290600937d92506c08d557133d6a1c0", "filename": "gcc/rust/hir/rust-ast-lower-type.h", "status": "modified", "additions": 5, "deletions": 58, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -32,59 +32,12 @@ class ASTLowerTypePath : public ASTLoweringBase\n   using Rust::HIR::ASTLoweringBase::visit;\n \n public:\n-  static HIR::TypePath *translate (AST::TypePath &type)\n-  {\n-    ASTLowerTypePath resolver;\n-    type.accept_vis (resolver);\n-    rust_assert (resolver.translated != nullptr);\n-    return resolver.translated;\n-  }\n-\n-  void visit (AST::TypePathSegmentFunction &) override { gcc_unreachable (); }\n-\n-  void visit (AST::TypePathSegment &segment) override\n-  {\n-    auto crate_num = mappings->get_current_crate ();\n-    auto hirid = mappings->get_next_hir_id (crate_num);\n-    Analysis::NodeMapping mapping (crate_num, segment.get_node_id (), hirid,\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    HIR::PathIdentSegment ident (segment.get_ident_segment ().as_string ());\n-    translated_segment\n-      = new HIR::TypePathSegment (std::move (mapping), ident,\n-\t\t\t\t  segment.get_separating_scope_resolution (),\n-\t\t\t\t  segment.get_locus ());\n-  }\n+  static HIR::TypePath *translate (AST::TypePath &type);\n \n+  void visit (AST::TypePathSegmentFunction &segment) override;\n+  void visit (AST::TypePathSegment &segment) override;\n   void visit (AST::TypePathSegmentGeneric &segment) override;\n-\n-  void visit (AST::TypePath &path) override\n-  {\n-    std::vector<std::unique_ptr<HIR::TypePathSegment>> translated_segments;\n-\n-    for (auto &seg : path.get_segments ())\n-      {\n-\ttranslated_segment = nullptr;\n-\tseg->accept_vis (*this);\n-\tif (translated_segment == nullptr)\n-\t  {\n-\t    rust_fatal_error (seg->get_locus (),\n-\t\t\t      \"failed to translate AST TypePathSegment\");\n-\t  }\n-\ttranslated_segments.push_back (\n-\t  std::unique_ptr<HIR::TypePathSegment> (translated_segment));\n-      }\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    auto hirid = mappings->get_next_hir_id (crate_num);\n-    Analysis::NodeMapping mapping (crate_num, path.get_node_id (), hirid,\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-\n-    translated\n-      = new HIR::TypePath (std::move (mapping), std::move (translated_segments),\n-\t\t\t   path.get_locus (),\n-\t\t\t   path.has_opening_scope_resolution_op ());\n-  }\n+  void visit (AST::TypePath &path) override;\n \n protected:\n   HIR::TypePathSegment *translated_segment;\n@@ -98,13 +51,7 @@ class ASTLowerQualifiedPathInType : public ASTLowerTypePath\n   using ASTLowerTypePath::visit;\n \n public:\n-  static HIR::QualifiedPathInType *translate (AST::QualifiedPathInType &type)\n-  {\n-    ASTLowerQualifiedPathInType resolver;\n-    type.accept_vis (resolver);\n-    rust_assert (resolver.translated != nullptr);\n-    return resolver.translated;\n-  }\n+  static HIR::QualifiedPathInType *translate (AST::QualifiedPathInType &type);\n \n   void visit (AST::QualifiedPathInType &path) override;\n "}, {"sha": "52b7003a04a7182451cc8b498ef45a8b557d2368", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -22,9 +22,12 @@\n #include \"rust-ast-lower-expr.h\"\n #include \"rust-ast-lower-block.h\"\n #include \"rust-ast-lower-type.h\"\n+#include \"rust-ast-lower-pattern.h\"\n+#include \"rust-ast-lower-struct-field-expr.h\"\n \n namespace Rust {\n namespace HIR {\n+using HIR::ClosureParam;\n \n Visibility\n translate_visibility (const AST::Visibility &vis)\n@@ -473,5 +476,25 @@ ASTLowerQualPathInExpression::visit (AST::QualifiedPathInExpression &expr)\n \t\t\t\t\t\t   expr.get_locus (),\n \t\t\t\t\t\t   expr.get_outer_attrs ());\n }\n+\n+ClosureParam\n+ASTLoweringBase::lower_closure_param (AST::ClosureParam &param)\n+{\n+  HIR::Pattern *param_pattern\n+    = ASTLoweringPattern::translate (param.get_pattern ().get ());\n+\n+  HIR::Type *param_type\n+    = param.has_type_given ()\n+\t? ASTLoweringType::translate (param.get_type ().get ())\n+\t: nullptr;\n+\n+  return HIR::ClosureParam (std::unique_ptr<HIR::Pattern> (param_pattern),\n+\t\t\t    param.get_locus (),\n+\t\t\t    param.has_type_given ()\n+\t\t\t      ? std::unique_ptr<HIR::Type> (param_type)\n+\t\t\t      : nullptr,\n+\t\t\t    param.get_outer_attrs ());\n+}\n+\n } // namespace HIR\n } // namespace Rust"}, {"sha": "11d4cd10527e042acd5a2ea0178883e89b78c006", "filename": "gcc/rust/hir/rust-hir-dump.cc", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Frust-hir-dump.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Frust-hir-dump.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-hir-dump.cc?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -197,7 +197,7 @@ void\n Dump::visit (FieldAccessExpr &)\n {}\n void\n-Dump::visit (ClosureExprInner &)\n+Dump::visit (ClosureExpr &)\n {}\n void\n Dump::visit (BlockExpr &block_expr)\n@@ -212,9 +212,7 @@ Dump::visit (BlockExpr &block_expr)\n   stream << \"]\";\n   indent--;\n }\n-void\n-Dump::visit (ClosureExprInnerTyped &)\n-{}\n+\n void\n Dump::visit (ContinueExpr &)\n {}"}, {"sha": "1953efeffd68e18a4d4363df81d24d8e031b98e7", "filename": "gcc/rust/hir/rust-hir-dump.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Frust-hir-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Frust-hir-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-hir-dump.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -78,9 +78,8 @@ class Dump : public HIRFullVisitor\n   virtual void visit (CallExpr &) override;\n   virtual void visit (MethodCallExpr &) override;\n   virtual void visit (FieldAccessExpr &) override;\n-  virtual void visit (ClosureExprInner &) override;\n+  virtual void visit (ClosureExpr &) override;\n   virtual void visit (BlockExpr &) override;\n-  virtual void visit (ClosureExprInnerTyped &) override;\n   virtual void visit (ContinueExpr &) override;\n   virtual void visit (BreakExpr &) override;\n   virtual void visit (RangeFromToExpr &) override;"}, {"sha": "66d8509e818aae45ab7507ce20a1b976431629c3", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 90, "deletions": 123, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -1985,28 +1985,31 @@ class FieldAccessExpr : public ExprWithoutBlock\n struct ClosureParam\n {\n private:\n+  std::vector<AST::Attribute> outer_attrs;\n   std::unique_ptr<Pattern> pattern;\n-\n-  // bool has_type_given;\n   std::unique_ptr<Type> type;\n-\n-  // TODO: should this store location data?\n+  Location locus;\n \n public:\n   // Returns whether the type of the parameter has been given.\n   bool has_type_given () const { return type != nullptr; }\n \n   // Constructor for closure parameter\n-  ClosureParam (std::unique_ptr<Pattern> param_pattern,\n-\t\tstd::unique_ptr<Type> param_type = nullptr)\n-    : pattern (std::move (param_pattern)), type (std::move (param_type))\n+  ClosureParam (std::unique_ptr<Pattern> param_pattern, Location locus,\n+\t\tstd::unique_ptr<Type> param_type = nullptr,\n+\t\tstd::vector<AST::Attribute> outer_attrs = {})\n+    : outer_attrs (std::move (outer_attrs)),\n+      pattern (std::move (param_pattern)), type (std::move (param_type)),\n+      locus (locus)\n   {}\n \n   // Copy constructor required due to cloning as a result of unique_ptrs\n   ClosureParam (ClosureParam const &other)\n     : pattern (other.pattern->clone_pattern ())\n   {\n     // guard to protect from null pointer dereference\n+    if (other.pattern != nullptr)\n+      pattern = other.pattern->clone_pattern ();\n     if (other.type != nullptr)\n       type = other.type->clone_type ();\n   }\n@@ -2016,8 +2019,17 @@ struct ClosureParam\n   // Assignment operator must be overloaded to clone as well\n   ClosureParam &operator= (ClosureParam const &other)\n   {\n-    pattern = other.pattern->clone_pattern ();\n-    type = other.type->clone_type ();\n+    outer_attrs = other.outer_attrs;\n+\n+    // guard to protect from null pointer dereference\n+    if (other.pattern != nullptr)\n+      pattern = other.pattern->clone_pattern ();\n+    else\n+      pattern = nullptr;\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    else\n+      type = nullptr;\n \n     return *this;\n   }\n@@ -2026,31 +2038,79 @@ struct ClosureParam\n   ClosureParam (ClosureParam &&other) = default;\n   ClosureParam &operator= (ClosureParam &&other) = default;\n \n-  // Returns whether closure parameter is in an error state.\n-  bool is_error () const { return pattern == nullptr; }\n+  std::string as_string () const;\n+\n+  const std::vector<AST::Attribute> &get_outer_attrs () const\n+  {\n+    return outer_attrs;\n+  }\n+  std::vector<AST::Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  // Creates an error state closure parameter.\n-  static ClosureParam create_error () { return ClosureParam (nullptr); }\n+  std::unique_ptr<Pattern> &get_pattern ()\n+  {\n+    rust_assert (pattern != nullptr);\n+    return pattern;\n+  }\n \n-  std::string as_string () const;\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (has_type_given ());\n+    return type;\n+  }\n+\n+  Location get_locus () const { return locus; }\n };\n \n // Base closure definition expression HIR node - abstract\n class ClosureExpr : public ExprWithoutBlock\n {\n+private:\n   bool has_move;\n   std::vector<ClosureParam> params;\n   Location locus;\n+  std::unique_ptr<Type> return_type;\n+  std::unique_ptr<Expr> expr;\n \n-protected:\n+public:\n   ClosureExpr (Analysis::NodeMapping mappings,\n-\t       std::vector<ClosureParam> closure_params, bool has_move,\n+\t       std::vector<ClosureParam> closure_params,\n+\t       std::unique_ptr<Type> closure_return_type,\n+\t       std::unique_ptr<Expr> closure_expr, bool has_move,\n \t       AST::AttrVec outer_attribs, Location locus)\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attribs)),\n-      has_move (has_move), params (std::move (closure_params)), locus (locus)\n+      has_move (has_move), params (std::move (closure_params)), locus (locus),\n+      return_type (std::move (closure_return_type)),\n+      expr (std::move (closure_expr))\n   {}\n \n-public:\n+  // Copy constructor requires cloning\n+  ClosureExpr (ClosureExpr const &other)\n+    : ExprWithoutBlock (other.get_mappings (), other.get_outer_attrs ())\n+  {\n+    return_type\n+      = other.has_return_type () ? other.return_type->clone_type () : nullptr;\n+    expr = other.expr->clone_expr ();\n+    params = other.params;\n+    has_move = other.has_move;\n+  }\n+\n+  // Overload assignment operator to clone unique_ptrs\n+  ClosureExpr &operator= (ClosureExpr const &other)\n+  {\n+    mappings = other.mappings;\n+    return_type\n+      = other.has_return_type () ? other.return_type->clone_type () : nullptr;\n+    expr = other.expr->clone_expr ();\n+    params = other.params;\n+    has_move = other.has_move;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ClosureExpr (ClosureExpr &&other) = default;\n+  ClosureExpr &operator= (ClosureExpr &&other) = default;\n+\n   std::string as_string () const override;\n \n   Location get_locus () const override final { return locus; }\n@@ -2059,64 +2119,36 @@ class ClosureExpr : public ExprWithoutBlock\n   {\n     return ExprType::Closure;\n   }\n-};\n-\n-// Represents a non-type-specified closure expression HIR node\n-class ClosureExprInner : public ClosureExpr\n-{\n-  std::unique_ptr<Expr> closure_inner;\n-\n-public:\n-  std::string as_string () const override;\n \n-  // Constructor for a ClosureExprInner\n-  ClosureExprInner (Analysis::NodeMapping mappings,\n-\t\t    std::unique_ptr<Expr> closure_inner_expr,\n-\t\t    std::vector<ClosureParam> closure_params, Location locus,\n-\t\t    bool is_move = false,\n-\t\t    AST::AttrVec outer_attribs = AST::AttrVec ())\n-    : ClosureExpr (std::move (mappings), std::move (closure_params), is_move,\n-\t\t   std::move (outer_attribs), locus),\n-      closure_inner (std::move (closure_inner_expr))\n-  {}\n+  bool get_has_move () const { return has_move; }\n \n-  // Copy constructor must be defined to allow copying via cloning of unique_ptr\n-  ClosureExprInner (ClosureExprInner const &other)\n-    : ClosureExpr (other), closure_inner (other.closure_inner->clone_expr ())\n-  {}\n+  bool has_return_type () const { return return_type != nullptr; }\n \n-  // Overload assignment operator to clone closure_inner\n-  ClosureExprInner &operator= (ClosureExprInner const &other)\n+  std::unique_ptr<Type> &get_return_type ()\n   {\n-    ClosureExpr::operator= (other);\n-    closure_inner = other.closure_inner->clone_expr ();\n-    // params = other.params;\n-    // has_move = other.has_move;\n-    // outer_attrs = other.outer_attrs;\n-\n-    return *this;\n-  }\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  };\n+  std::unique_ptr<Expr> &get_expr () { return expr; }\n \n-  // move constructors\n-  ClosureExprInner (ClosureExprInner &&other) = default;\n-  ClosureExprInner &operator= (ClosureExprInner &&other) = default;\n+  std::vector<ClosureParam> &get_params () { return params; }\n \n   void accept_vis (HIRFullVisitor &vis) override;\n   void accept_vis (HIRExpressionVisitor &vis) override;\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n-  ClosureExprInner *clone_expr_impl () const override\n+  ClosureExpr *clone_expr_impl () const override\n   {\n-    return new ClosureExprInner (*this);\n+    return new ClosureExpr (*this);\n   }\n \n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n-  ClosureExprInner *clone_expr_without_block_impl () const override\n+  ClosureExpr *clone_expr_without_block_impl () const override\n   {\n-    return new ClosureExprInner (*this);\n+    return new ClosureExpr (*this);\n   }\n };\n \n@@ -2239,71 +2271,6 @@ class BlockExpr : public ExprWithBlock\n   }\n };\n \n-// Represents a type-specified closure expression HIR node\n-class ClosureExprInnerTyped : public ClosureExpr\n-{\n-  std::unique_ptr<Type> return_type;\n-  std::unique_ptr<BlockExpr>\n-    expr; // only used because may be polymorphic in future\n-\n-public:\n-  std::string as_string () const override;\n-\n-  // Constructor potentially with a move\n-  ClosureExprInnerTyped (Analysis::NodeMapping mappings,\n-\t\t\t std::unique_ptr<Type> closure_return_type,\n-\t\t\t std::unique_ptr<BlockExpr> closure_expr,\n-\t\t\t std::vector<ClosureParam> closure_params,\n-\t\t\t Location locus, bool is_move = false,\n-\t\t\t AST::AttrVec outer_attribs = AST::AttrVec ())\n-    : ClosureExpr (std::move (mappings), std::move (closure_params), is_move,\n-\t\t   std::move (outer_attribs), locus),\n-      return_type (std::move (closure_return_type)),\n-      expr (std::move (closure_expr))\n-  {}\n-\n-  // Copy constructor requires cloning\n-  ClosureExprInnerTyped (ClosureExprInnerTyped const &other)\n-    : ClosureExpr (other), return_type (other.return_type->clone_type ()),\n-      expr (other.expr->clone_block_expr ())\n-  {}\n-\n-  // Overload assignment operator to clone unique_ptrs\n-  ClosureExprInnerTyped &operator= (ClosureExprInnerTyped const &other)\n-  {\n-    ClosureExpr::operator= (other);\n-    return_type = other.return_type->clone_type ();\n-    expr = other.expr->clone_block_expr ();\n-    // params = other.params;\n-    // has_move = other.has_move;\n-    // outer_attrs = other.outer_attrs;\n-\n-    return *this;\n-  }\n-\n-  // move constructors\n-  ClosureExprInnerTyped (ClosureExprInnerTyped &&other) = default;\n-  ClosureExprInnerTyped &operator= (ClosureExprInnerTyped &&other) = default;\n-\n-  void accept_vis (HIRFullVisitor &vis) override;\n-  void accept_vis (HIRExpressionVisitor &vis) override;\n-\n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ClosureExprInnerTyped *clone_expr_impl () const override\n-  {\n-    return new ClosureExprInnerTyped (*this);\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ClosureExprInnerTyped *clone_expr_without_block_impl () const override\n-  {\n-    return new ClosureExprInnerTyped (*this);\n-  }\n-};\n-\n // HIR node representing continue expression within loops\n class ContinueExpr : public ExprWithoutBlock\n {"}, {"sha": "717facff687aef96f838403d7c7d479d9980daeb", "filename": "gcc/rust/hir/tree/rust-hir-full-decls.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -94,9 +94,7 @@ class MethodCallExpr;\n class FieldAccessExpr;\n struct ClosureParam;\n class ClosureExpr;\n-class ClosureExprInner;\n class BlockExpr;\n-class ClosureExprInnerTyped;\n class ContinueExpr;\n class BreakExpr;\n class RangeExpr;"}, {"sha": "7e5b49db1dcbb08345e7c951a2d1f59403f449e9", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 4, "deletions": 33, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -1133,15 +1133,8 @@ ClosureExpr::as_string () const\n \t}\n     }\n \n-  return str;\n-}\n-\n-std::string\n-ClosureExprInnerTyped::as_string () const\n-{\n-  std::string str = ClosureExpr::as_string ();\n-\n-  str += \"\\n Return type: \" + return_type->as_string ();\n+  str += \"\\n Return type: \"\n+\t + (has_return_type () ? return_type->as_string () : \"none\");\n \n   str += \"\\n Body: \" + expr->as_string ();\n \n@@ -1515,16 +1508,6 @@ UnsafeBlockExpr::as_string () const\n   return str + \"\\n\" + indent_spaces (out) + \"}\\n\" + expr->as_string ();\n }\n \n-std::string\n-ClosureExprInner::as_string () const\n-{\n-  std::string str = ClosureExpr::as_string ();\n-\n-  str += \"\\n Expression: \" + closure_inner->as_string ();\n-\n-  return str;\n-}\n-\n std::string\n IfExpr::as_string () const\n {\n@@ -4038,7 +4021,7 @@ FieldAccessExpr::accept_vis (HIRFullVisitor &vis)\n }\n \n void\n-ClosureExprInner::accept_vis (HIRFullVisitor &vis)\n+ClosureExpr::accept_vis (HIRFullVisitor &vis)\n {\n   vis.visit (*this);\n }\n@@ -4049,12 +4032,6 @@ BlockExpr::accept_vis (HIRFullVisitor &vis)\n   vis.visit (*this);\n }\n \n-void\n-ClosureExprInnerTyped::accept_vis (HIRFullVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n void\n ContinueExpr::accept_vis (HIRFullVisitor &vis)\n {\n@@ -4986,7 +4963,7 @@ IfExpr::accept_vis (HIRExpressionVisitor &vis)\n }\n \n void\n-ClosureExprInner::accept_vis (HIRExpressionVisitor &vis)\n+ClosureExpr::accept_vis (HIRExpressionVisitor &vis)\n {\n   vis.visit (*this);\n }\n@@ -5075,12 +5052,6 @@ QualifiedPathInExpression::accept_vis (HIRPatternVisitor &vis)\n   vis.visit (*this);\n }\n \n-void\n-ClosureExprInnerTyped::accept_vis (HIRExpressionVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n void\n ExprStmtWithBlock::accept_vis (HIRStmtVisitor &vis)\n {"}, {"sha": "06f3acbf904880ade0fb82530e4e35d1d38585f3", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "modified", "additions": 29, "deletions": 39, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -529,56 +529,29 @@ class TypePathSegmentGeneric : public TypePathSegment\n struct TypePathFunction\n {\n private:\n-  // TODO: remove\n-  /*bool has_inputs;\n-  TypePathFnInputs inputs;*/\n-  // inlined from TypePathFnInputs\n   std::vector<std::unique_ptr<Type> > inputs;\n-\n-  // bool has_type;\n   std::unique_ptr<Type> return_type;\n \n-  // FIXME: think of better way to mark as invalid than taking up storage\n-  bool is_invalid;\n-\n-  // TODO: should this have location info?\n-\n-protected:\n-  // Constructor only used to create invalid type path functions.\n-  TypePathFunction (bool is_invalid) : is_invalid (is_invalid) {}\n-\n public:\n   // Returns whether the return type of the function has been specified.\n   bool has_return_type () const { return return_type != nullptr; }\n \n   // Returns whether the function has inputs.\n   bool has_inputs () const { return !inputs.empty (); }\n \n-  // Returns whether function is in an error state.\n-  bool is_error () const { return is_invalid; }\n-\n-  // Creates an error state function.\n-  static TypePathFunction create_error () { return TypePathFunction (true); }\n-\n-  // Constructor\n-  TypePathFunction (std::vector<std::unique_ptr<Type> > inputs,\n-\t\t    Type *type = nullptr)\n-    : inputs (std::move (inputs)), return_type (type), is_invalid (false)\n-  {}\n-  // FIXME: deprecated\n-\n   // Constructor\n   TypePathFunction (std::vector<std::unique_ptr<Type> > inputs,\n-\t\t    std::unique_ptr<Type> type = nullptr)\n-    : inputs (std::move (inputs)), return_type (std::move (type)),\n-      is_invalid (false)\n+\t\t    std::unique_ptr<Type> type)\n+    : inputs (std::move (inputs)), return_type (std::move (type))\n   {}\n \n   // Copy constructor with clone\n   TypePathFunction (TypePathFunction const &other)\n-    : return_type (other.return_type->clone_type ()),\n-      is_invalid (other.is_invalid)\n   {\n+    return_type = other.has_return_type ()\n+\t\t    ? other.get_return_type ()->clone_type ()\n+\t\t    : nullptr;\n+\n     inputs.reserve (other.inputs.size ());\n     for (const auto &e : other.inputs)\n       inputs.push_back (e->clone_type ());\n@@ -589,8 +562,9 @@ struct TypePathFunction\n   // Overloaded assignment operator to clone type\n   TypePathFunction &operator= (TypePathFunction const &other)\n   {\n-    return_type = other.return_type->clone_type ();\n-    is_invalid = other.is_invalid;\n+    return_type = other.has_return_type ()\n+\t\t    ? other.get_return_type ()->clone_type ()\n+\t\t    : nullptr;\n \n     inputs.reserve (other.inputs.size ());\n     for (const auto &e : other.inputs)\n@@ -604,6 +578,23 @@ struct TypePathFunction\n   TypePathFunction &operator= (TypePathFunction &&other) = default;\n \n   std::string as_string () const;\n+\n+  const std::vector<std::unique_ptr<Type> > &get_params () const\n+  {\n+    return inputs;\n+  };\n+  std::vector<std::unique_ptr<Type> > &get_params () { return inputs; };\n+\n+  const std::unique_ptr<Type> &get_return_type () const\n+  {\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  };\n+  std::unique_ptr<Type> &get_return_type ()\n+  {\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  };\n };\n \n // Segment used in type path with a function argument\n@@ -638,10 +629,9 @@ class TypePathSegmentFunction : public TypePathSegment\n \n   void accept_vis (HIRFullVisitor &vis) override;\n \n-  virtual SegmentType get_type () const override final\n-  {\n-    return SegmentType::FUNCTION;\n-  }\n+  SegmentType get_type () const override final { return SegmentType::FUNCTION; }\n+\n+  TypePathFunction &get_function_path () { return function_path; }\n \n protected:\n   // Use covariance to override base class method"}, {"sha": "a92279210fd184e00f8f0572bea58de6c69511db", "filename": "gcc/rust/hir/tree/rust-hir-visitor.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -63,9 +63,8 @@ class HIRFullVisitor\n   virtual void visit (CallExpr &expr) = 0;\n   virtual void visit (MethodCallExpr &expr) = 0;\n   virtual void visit (FieldAccessExpr &expr) = 0;\n-  virtual void visit (ClosureExprInner &expr) = 0;\n   virtual void visit (BlockExpr &expr) = 0;\n-  virtual void visit (ClosureExprInnerTyped &expr) = 0;\n+  virtual void visit (ClosureExpr &expr) = 0;\n   virtual void visit (ContinueExpr &expr) = 0;\n   virtual void visit (BreakExpr &expr) = 0;\n   virtual void visit (RangeFromToExpr &expr) = 0;\n@@ -206,9 +205,8 @@ class HIRFullVisitorBase : public HIRFullVisitor\n   virtual void visit (CallExpr &) override {}\n   virtual void visit (MethodCallExpr &) override {}\n   virtual void visit (FieldAccessExpr &) override {}\n-  virtual void visit (ClosureExprInner &) override {}\n+  virtual void visit (ClosureExpr &) override {}\n   virtual void visit (BlockExpr &) override {}\n-  virtual void visit (ClosureExprInnerTyped &) override {}\n   virtual void visit (ContinueExpr &) override {}\n   virtual void visit (BreakExpr &) override {}\n   virtual void visit (RangeFromToExpr &) override {}\n@@ -419,8 +417,7 @@ class HIRExpressionVisitor\n \n   virtual void visit (HIR::QualifiedPathInExpression &expr) = 0;\n   virtual void visit (HIR::PathInExpression &expr) = 0;\n-  virtual void visit (ClosureExprInnerTyped &) = 0;\n-  virtual void visit (ClosureExprInner &expr) = 0;\n+  virtual void visit (ClosureExpr &) = 0;\n   virtual void visit (StructExprStructFields &) = 0;\n   virtual void visit (StructExprStruct &) = 0;\n   virtual void visit (LiteralExpr &expr) = 0;"}, {"sha": "97c20c978fcc48940afa9c4799c419ccf7a520d2", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -238,6 +238,7 @@ class ExprWithoutBlock;\n // Base expression HIR node - abstract\n class Expr : public Node\n {\n+protected:\n   AST::AttrVec outer_attrs;\n   Analysis::NodeMapping mappings;\n "}, {"sha": "60b3ebacc2c4fbbb6141af05dd142accb2686a31", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.cc", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -565,6 +565,64 @@ ResolveExpr::visit (AST::RangeFromToInclExpr &expr)\n   ResolveExpr::go (expr.get_to_expr ().get (), prefix, canonical_prefix);\n }\n \n+void\n+ResolveExpr::visit (AST::ClosureExprInner &expr)\n+{\n+  NodeId scope_node_id = expr.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  for (auto &p : expr.get_params ())\n+    {\n+      resolve_closure_param (p);\n+    }\n+\n+  ResolveExpr::go (expr.get_definition_expr ().get (), prefix,\n+\t\t   canonical_prefix);\n+\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveExpr::visit (AST::ClosureExprInnerTyped &expr)\n+{\n+  NodeId scope_node_id = expr.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  for (auto &p : expr.get_params ())\n+    {\n+      resolve_closure_param (p);\n+    }\n+\n+  ResolveType::go (expr.get_return_type ().get ());\n+  ResolveExpr::go (expr.get_definition_block ().get (), prefix,\n+\t\t   canonical_prefix);\n+\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveExpr::resolve_closure_param (AST::ClosureParam &param)\n+{\n+  PatternDeclaration::go (param.get_pattern ().get ());\n+\n+  if (param.has_type_given ())\n+    ResolveType::go (param.get_type ().get ());\n+}\n+\n ResolveExpr::ResolveExpr (const CanonicalPath &prefix,\n \t\t\t  const CanonicalPath &canonical_prefix)\n   : ResolverBase (), prefix (prefix), canonical_prefix (canonical_prefix)"}, {"sha": "c11718efd374dd58018aa3882afb5e1e51f17232", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 5, "deletions": 43, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -34,90 +34,52 @@ class ResolveExpr : public ResolverBase\n \t\t  const CanonicalPath &canonical_prefix);\n \n   void visit (AST::TupleIndexExpr &expr) override;\n-\n   void visit (AST::TupleExpr &expr) override;\n-\n   void visit (AST::PathInExpression &expr) override;\n-\n   void visit (AST::QualifiedPathInExpression &expr) override;\n-\n   void visit (AST::ReturnExpr &expr) override;\n-\n   void visit (AST::CallExpr &expr) override;\n-\n   void visit (AST::MethodCallExpr &expr) override;\n-\n   void visit (AST::AssignmentExpr &expr) override;\n-\n   void visit (AST::IdentifierExpr &expr) override;\n-\n   void visit (AST::ArithmeticOrLogicalExpr &expr) override;\n-\n   void visit (AST::CompoundAssignmentExpr &expr) override;\n-\n   void visit (AST::ComparisonExpr &expr) override;\n-\n   void visit (AST::LazyBooleanExpr &expr) override;\n-\n   void visit (AST::NegationExpr &expr) override;\n-\n   void visit (AST::TypeCastExpr &expr) override;\n-\n   void visit (AST::IfExpr &expr) override;\n-\n   void visit (AST::IfExprConseqElse &expr) override;\n-\n   void visit (AST::IfExprConseqIf &expr) override;\n-\n   void visit (AST::IfLetExpr &expr) override;\n-\n   void visit (AST::BlockExpr &expr) override;\n-\n   void visit (AST::UnsafeBlockExpr &expr) override;\n-\n   void visit (AST::ArrayElemsValues &elems) override;\n-\n   void visit (AST::ArrayExpr &expr) override;\n-\n   void visit (AST::ArrayIndexExpr &expr) override;\n-\n   void visit (AST::ArrayElemsCopied &elems) override;\n-\n-  // this this an empty struct constructor like 'S {}'\n   void visit (AST::StructExprStruct &struct_expr) override;\n-\n-  // this this a struct constructor with fields\n   void visit (AST::StructExprStructFields &struct_expr) override;\n-\n   void visit (AST::GroupedExpr &expr) override;\n-\n   void visit (AST::FieldAccessExpr &expr) override;\n-\n   void visit (AST::LoopExpr &expr) override;\n-\n   void visit (AST::BreakExpr &expr) override;\n-\n   void visit (AST::WhileLoopExpr &expr) override;\n-\n   void visit (AST::ForLoopExpr &expr) override;\n-\n   void visit (AST::ContinueExpr &expr) override;\n-\n   void visit (AST::BorrowExpr &expr) override;\n-\n   void visit (AST::DereferenceExpr &expr) override;\n-\n   void visit (AST::MatchExpr &expr) override;\n-\n   void visit (AST::RangeFromToExpr &expr) override;\n-\n   void visit (AST::RangeFromExpr &expr) override;\n-\n   void visit (AST::RangeToExpr &expr) override;\n-\n   void visit (AST::RangeFullExpr &expr) override;\n-\n   void visit (AST::RangeFromToInclExpr &expr) override;\n+  void visit (AST::ClosureExprInner &expr) override;\n+  void visit (AST::ClosureExprInnerTyped &expr) override;\n+\n+protected:\n+  void resolve_closure_param (AST::ClosureParam &param);\n \n private:\n   ResolveExpr (const CanonicalPath &prefix,"}, {"sha": "e42bab68234a5cbfe2cebb5e81c9df80ab444613", "filename": "gcc/rust/resolve/rust-ast-resolve-type.cc", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -149,7 +149,20 @@ ResolveRelativeTypePath::go (AST::TypePath &path, NodeId &resolved_node_id)\n \t  break;\n \n \tcase AST::TypePathSegment::SegmentType::FUNCTION:\n-\t  gcc_unreachable ();\n+\t  AST::TypePathSegmentFunction *fnseg\n+\t    = static_cast<AST::TypePathSegmentFunction *> (segment.get ());\n+\n+\t  AST::TypePathFunction &fn = fnseg->get_type_path_function ();\n+\t  for (auto &param : fn.get_params ())\n+\t    {\n+\t      ResolveType::go (param.get ());\n+\t    }\n+\n+\t  if (fn.has_return_type ())\n+\t    {\n+\t      ResolveType::go (fn.get_return_type ().get ());\n+\t    }\n+\n \t  break;\n \t}\n "}, {"sha": "8911a1d99f7da77625e8cb3fe6f192e27b565d5a", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.cc", "status": "modified", "additions": 304, "deletions": 11, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -178,16 +178,6 @@ TypeCheckExpr::visit (HIR::CallExpr &expr)\n {\n   TyTy::BaseType *function_tyty = TypeCheckExpr::Resolve (expr.get_fnexpr ());\n \n-  bool valid_tyty = function_tyty->get_kind () == TyTy::TypeKind::ADT\n-\t\t    || function_tyty->get_kind () == TyTy::TypeKind::FNDEF\n-\t\t    || function_tyty->get_kind () == TyTy::TypeKind::FNPTR;\n-  if (!valid_tyty)\n-    {\n-      rust_error_at (expr.get_locus (),\n-\t\t     \"Failed to resolve expression of function call\");\n-      return;\n-    }\n-\n   rust_debug_loc (expr.get_locus (), \"resolved_call_expr to: {%s}\",\n \t\t  function_tyty->get_name ().c_str ());\n \n@@ -214,6 +204,24 @@ TypeCheckExpr::visit (HIR::CallExpr &expr)\n \t  rust_assert (adt->number_of_variants () == 1);\n \t  variant = *adt->get_variants ().at (0);\n \t}\n+\n+      infered\n+\t= TyTy::TypeCheckCallExpr::go (function_tyty, expr, variant, context);\n+      return;\n+    }\n+\n+  bool resolved_fn_trait_call\n+    = resolve_fn_trait_call (expr, function_tyty, &infered);\n+  if (resolved_fn_trait_call)\n+    return;\n+\n+  bool valid_tyty = function_tyty->get_kind () == TyTy::TypeKind::FNDEF\n+\t\t    || function_tyty->get_kind () == TyTy::TypeKind::FNPTR;\n+  if (!valid_tyty)\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"Failed to resolve expression of function call\");\n+      return;\n     }\n \n   infered = TyTy::TypeCheckCallExpr::go (function_tyty, expr, variant, context);\n@@ -1162,7 +1170,8 @@ TypeCheckExpr::visit (HIR::MethodCallExpr &expr)\n   rust_debug (\"type-checking method_call: {%s}\", lookup->debug_str ().c_str ());\n \n   TyTy::BaseType *function_ret_tyty\n-    = TyTy::TypeCheckMethodCallExpr::go (lookup, expr, adjusted_self, context);\n+    = TyTy::TypeCheckMethodCallExpr::go (static_cast<TyTy::FnType *> (lookup),\n+\t\t\t\t\t expr, adjusted_self, context);\n   if (function_ret_tyty == nullptr\n       || function_ret_tyty->get_kind () == TyTy::TypeKind::ERROR)\n     {\n@@ -1418,6 +1427,128 @@ TypeCheckExpr::visit (HIR::MatchExpr &expr)\n     }\n }\n \n+void\n+TypeCheckExpr::visit (HIR::ClosureExpr &expr)\n+{\n+  TypeCheckContextItem &current_context = context->peek_context ();\n+  TyTy::FnType *current_context_fndecl = current_context.get_context_type ();\n+\n+  HirId ref = expr.get_mappings ().get_hirid ();\n+  DefId id = expr.get_mappings ().get_defid ();\n+  RustIdent ident{current_context_fndecl->get_ident ().path, expr.get_locus ()};\n+\n+  // get from parent context\n+  std::vector<TyTy::SubstitutionParamMapping> subst_refs\n+    = current_context_fndecl->clone_substs ();\n+\n+  std::vector<TyTy::TyVar> parameter_types;\n+  for (auto &p : expr.get_params ())\n+    {\n+      if (p.has_type_given ())\n+\t{\n+\t  TyTy::BaseType *param_tyty\n+\t    = TypeCheckType::Resolve (p.get_type ().get ());\n+\t  TyTy::TyVar param_ty (param_tyty->get_ref ());\n+\t  parameter_types.push_back (param_ty);\n+\n+\t  TypeCheckPattern::Resolve (p.get_pattern ().get (),\n+\t\t\t\t     param_ty.get_tyty ());\n+\t}\n+      else\n+\t{\n+\t  TyTy::TyVar param_ty\n+\t    = TyTy::TyVar::get_implicit_infer_var (p.get_locus ());\n+\t  parameter_types.push_back (param_ty);\n+\n+\t  TypeCheckPattern::Resolve (p.get_pattern ().get (),\n+\t\t\t\t     param_ty.get_tyty ());\n+\t}\n+    }\n+\n+  // we generate an implicit hirid for the closure args\n+  HirId implicit_args_id = mappings->get_next_hir_id ();\n+  TyTy::TupleType *closure_args\n+    = new TyTy::TupleType (implicit_args_id, expr.get_locus (),\n+\t\t\t   parameter_types);\n+  context->insert_implicit_type (closure_args);\n+\n+  Location result_type_locus = expr.has_return_type ()\n+\t\t\t\t ? expr.get_return_type ()->get_locus ()\n+\t\t\t\t : expr.get_locus ();\n+  TyTy::TyVar result_type\n+    = expr.has_return_type ()\n+\t? TyTy::TyVar (\n+\t  TypeCheckType::Resolve (expr.get_return_type ().get ())->get_ref ())\n+\t: TyTy::TyVar::get_implicit_infer_var (expr.get_locus ());\n+\n+  // resolve the block\n+  Location closure_expr_locus = expr.get_expr ()->get_locus ();\n+  TyTy::BaseType *closure_expr_ty\n+    = TypeCheckExpr::Resolve (expr.get_expr ().get ());\n+  coercion_site (expr.get_mappings ().get_hirid (),\n+\t\t TyTy::TyWithLocation (result_type.get_tyty (),\n+\t\t\t\t       result_type_locus),\n+\t\t TyTy::TyWithLocation (closure_expr_ty, closure_expr_locus),\n+\t\t expr.get_locus ());\n+\n+  // generate the closure type\n+  infered = new TyTy::ClosureType (ref, id, ident, closure_args, result_type,\n+\t\t\t\t   subst_refs);\n+\n+  // FIXME\n+  // all closures automatically inherit the appropriate fn trait. Lets just\n+  // assume FnOnce for now. I think this is based on the return type of the\n+  // closure\n+\n+  Analysis::RustLangItem::ItemType lang_item_type\n+    = Analysis::RustLangItem::ItemType::FN_ONCE;\n+  DefId respective_lang_item_id = UNKNOWN_DEFID;\n+  bool lang_item_defined\n+    = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n+  if (!lang_item_defined)\n+    {\n+      // FIXME\n+      // we need to have a unified way or error'ing when we are missing lang\n+      // items that is useful\n+      rust_fatal_error (\n+\texpr.get_locus (), \"unable to find lang item: %<%s%>\",\n+\tAnalysis::RustLangItem::ToString (lang_item_type).c_str ());\n+    }\n+  rust_assert (lang_item_defined);\n+\n+  // these lang items are always traits\n+  HIR::Item *item = mappings->lookup_defid (respective_lang_item_id);\n+  rust_assert (item->get_item_kind () == HIR::Item::ItemKind::Trait);\n+  HIR::Trait *trait_item = static_cast<HIR::Trait *> (item);\n+\n+  TraitReference *trait = TraitResolver::Resolve (*trait_item);\n+  rust_assert (!trait->is_error ());\n+\n+  TyTy::TypeBoundPredicate predicate (*trait, expr.get_locus ());\n+\n+  // resolve the trait bound where the <(Args)> are the parameter tuple type\n+  HIR::GenericArgs args = HIR::GenericArgs::create_empty (expr.get_locus ());\n+\n+  // lets generate an implicit Type so that it resolves to the implict tuple\n+  // type we have created\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_mappings ().get_nodeid (),\n+\t\t\t\t implicit_args_id, UNKNOWN_LOCAL_DEFID);\n+  HIR::TupleType *implicit_tuple\n+    = new HIR::TupleType (mapping,\n+\t\t\t  {} // we dont need to fill this out because it will\n+\t\t\t     // auto resolve because the hir id's match\n+\t\t\t  ,\n+\t\t\t  expr.get_locus ());\n+  args.get_type_args ().push_back (std::unique_ptr<HIR::Type> (implicit_tuple));\n+\n+  // apply the arguments\n+  predicate.apply_generic_arguments (&args);\n+\n+  // finally inherit the trait bound\n+  infered->inherit_bounds ({predicate});\n+}\n+\n bool\n TypeCheckExpr::resolve_operator_overload (\n   Analysis::RustLangItem::ItemType lang_item_type, HIR::OperatorExprMeta expr,\n@@ -1623,6 +1754,168 @@ TypeCheckExpr::resolve_operator_overload (\n   return true;\n }\n \n+HIR::PathIdentSegment\n+TypeCheckExpr::resolve_possible_fn_trait_call_method_name (\n+  const TyTy::BaseType &receiver)\n+{\n+  // Question\n+  // do we need to probe possible bounds here? I think not, i think when we\n+  // support Fn traits they are explicitly specified\n+\n+  // FIXME\n+  // the logic to map the FnTrait to their respective call trait-item is\n+  // duplicated over in the backend/rust-compile-expr.cc\n+  for (const auto &bound : receiver.get_specified_bounds ())\n+    {\n+      bool found_fn = bound.get_name ().compare (\"Fn\") == 0;\n+      bool found_fn_mut = bound.get_name ().compare (\"FnMut\") == 0;\n+      bool found_fn_once = bound.get_name ().compare (\"FnOnce\") == 0;\n+\n+      if (found_fn)\n+\t{\n+\t  return HIR::PathIdentSegment (\"call\");\n+\t}\n+      else if (found_fn_mut)\n+\t{\n+\t  return HIR::PathIdentSegment (\"call_mut\");\n+\t}\n+      else if (found_fn_once)\n+\t{\n+\t  return HIR::PathIdentSegment (\"call_once\");\n+\t}\n+    }\n+\n+  // nothing\n+  return HIR::PathIdentSegment (\"\");\n+}\n+\n+bool\n+TypeCheckExpr::resolve_fn_trait_call (HIR::CallExpr &expr,\n+\t\t\t\t      TyTy::BaseType *receiver_tyty,\n+\t\t\t\t      TyTy::BaseType **result)\n+{\n+  // we turn this into a method call expr\n+  HIR::PathIdentSegment method_name\n+    = resolve_possible_fn_trait_call_method_name (*receiver_tyty);\n+  if (method_name.is_error ())\n+    return false;\n+\n+  auto candidates = MethodResolver::Probe (receiver_tyty, method_name);\n+  if (candidates.empty ())\n+    return false;\n+\n+  if (candidates.size () > 1)\n+    {\n+      RichLocation r (expr.get_locus ());\n+      for (auto &c : candidates)\n+\tr.add_range (c.candidate.locus);\n+\n+      rust_error_at (\n+\tr, \"multiple candidates found for function trait method call %<%s%>\",\n+\tmethod_name.as_string ().c_str ());\n+      return false;\n+    }\n+\n+  if (receiver_tyty->get_kind () == TyTy::TypeKind::CLOSURE)\n+    {\n+      const TyTy::ClosureType &closure\n+\t= static_cast<TyTy::ClosureType &> (*receiver_tyty);\n+      closure.setup_fn_once_output ();\n+    }\n+\n+  auto candidate = *candidates.begin ();\n+  rust_debug_loc (expr.get_locus (),\n+\t\t  \"resolved call-expr to fn trait: {%u} {%s}\",\n+\t\t  candidate.candidate.ty->get_ref (),\n+\t\t  candidate.candidate.ty->debug_str ().c_str ());\n+\n+  // Get the adjusted self\n+  Adjuster adj (receiver_tyty);\n+  TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n+\n+  // store the adjustments for code-generation to know what to do which must be\n+  // stored onto the receiver to so as we don't trigger duplicate deref mappings\n+  // ICE when an argument is a method call\n+  HirId autoderef_mappings_id = expr.get_mappings ().get_hirid ();\n+  context->insert_autoderef_mappings (autoderef_mappings_id,\n+\t\t\t\t      std::move (candidate.adjustments));\n+  context->insert_receiver (expr.get_mappings ().get_hirid (), receiver_tyty);\n+\n+  PathProbeCandidate &resolved_candidate = candidate.candidate;\n+  TyTy::BaseType *lookup_tyty = candidate.candidate.ty;\n+  NodeId resolved_node_id\n+    = resolved_candidate.is_impl_candidate ()\n+\t? resolved_candidate.item.impl.impl_item->get_impl_mappings ()\n+\t    .get_nodeid ()\n+\t: resolved_candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n+\n+  if (lookup_tyty->get_kind () != TyTy::TypeKind::FNDEF)\n+    {\n+      RichLocation r (expr.get_locus ());\n+      r.add_range (resolved_candidate.locus);\n+      rust_error_at (r, \"associated impl item is not a method\");\n+      return false;\n+    }\n+\n+  TyTy::BaseType *lookup = lookup_tyty;\n+  TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n+  if (!fn->is_method ())\n+    {\n+      RichLocation r (expr.get_locus ());\n+      r.add_range (resolved_candidate.locus);\n+      rust_error_at (r, \"associated function is not a method\");\n+      return false;\n+    }\n+\n+  // fn traits only support tuple argument passing so we need to implicitly set\n+  // this up to get the same type checking we get in the rest of the pipeline\n+\n+  std::vector<TyTy::TyVar> call_args;\n+  for (auto &arg : expr.get_arguments ())\n+    {\n+      TyTy::BaseType *a = TypeCheckExpr::Resolve (arg.get ());\n+      call_args.push_back (TyTy::TyVar (a->get_ref ()));\n+    }\n+\n+  // crate implicit tuple\n+  HirId implicit_arg_id = mappings->get_next_hir_id ();\n+  Analysis::NodeMapping mapping (mappings->get_current_crate (), UNKNOWN_NODEID,\n+\t\t\t\t implicit_arg_id, UNKNOWN_LOCAL_DEFID);\n+\n+  TyTy::TupleType *tuple\n+    = new TyTy::TupleType (implicit_arg_id, expr.get_locus (), call_args);\n+  context->insert_implicit_type (implicit_arg_id, tuple);\n+\n+  std::vector<TyTy::Argument> args;\n+  TyTy::Argument a (mapping, tuple,\n+\t\t    expr.get_locus () /*FIXME is there a better location*/);\n+  args.push_back (std::move (a));\n+\n+  TyTy::BaseType *function_ret_tyty\n+    = TyTy::TypeCheckMethodCallExpr::go (fn, expr.get_mappings (), args,\n+\t\t\t\t\t expr.get_locus (), expr.get_locus (),\n+\t\t\t\t\t adjusted_self, context);\n+  if (function_ret_tyty == nullptr\n+      || function_ret_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"failed check fn trait call-expr MethodCallExpr\");\n+      return false;\n+    }\n+\n+  // store the expected fntype\n+  context->insert_operator_overload (expr.get_mappings ().get_hirid (), fn);\n+\n+  // set up the resolved name on the path\n+  resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t  resolved_node_id);\n+\n+  // return the result of the function back\n+  *result = function_ret_tyty;\n+\n+  return true;\n+}\n+\n bool\n TypeCheckExpr::validate_arithmetic_type (\n   const TyTy::BaseType *tyty, HIR::ArithmeticOrLogicalExpr::ExprType expr_type)"}, {"sha": "3ac8c4dfff81c7f1d3bc684c834ec7b7f846c325", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -69,10 +69,9 @@ class TypeCheckExpr : private TypeCheckBase, private HIR::HIRExpressionVisitor\n   void visit (HIR::RangeFullExpr &expr) override;\n   void visit (HIR::RangeFromToInclExpr &expr) override;\n   void visit (HIR::WhileLoopExpr &expr) override;\n+  void visit (HIR::ClosureExpr &expr) override;\n \n   // TODO\n-  void visit (HIR::ClosureExprInnerTyped &) override {}\n-  void visit (HIR::ClosureExprInner &expr) override {}\n   void visit (HIR::ErrorPropagationExpr &expr) override {}\n   void visit (HIR::RangeToInclExpr &expr) override {}\n   void visit (HIR::WhileLetLoopExpr &expr) override {}\n@@ -104,6 +103,13 @@ class TypeCheckExpr : private TypeCheckBase, private HIR::HIRExpressionVisitor\n \t\t\t     HIR::OperatorExprMeta expr, TyTy::BaseType *lhs,\n \t\t\t     TyTy::BaseType *rhs);\n \n+  bool resolve_fn_trait_call (HIR::CallExpr &expr,\n+\t\t\t      TyTy::BaseType *function_tyty,\n+\t\t\t      TyTy::BaseType **result);\n+\n+  HIR::PathIdentSegment\n+  resolve_possible_fn_trait_call_method_name (const TyTy::BaseType &receiver);\n+\n private:\n   TypeCheckExpr ();\n "}, {"sha": "d785835f7c727e91197cc5c998a1ca92be099eaa", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -70,6 +70,8 @@ class TypeCheckContextItem\n     return item.trait_item;\n   }\n \n+  TyTy::FnType *get_context_type ();\n+\n private:\n   union Item\n   {"}, {"sha": "34b60b37644722db9f89afe28e44949c30419b1f", "filename": "gcc/rust/typecheck/rust-tyctx.cc", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -154,5 +154,37 @@ TypeCheckContext::peek_context ()\n   return return_type_stack.back ().first;\n }\n \n+// TypeCheckContextItem\n+\n+TyTy::FnType *\n+TypeCheckContextItem::get_context_type ()\n+{\n+  auto &context = *TypeCheckContext::get ();\n+\n+  HirId reference = UNKNOWN_HIRID;\n+  switch (get_type ())\n+    {\n+    case ITEM:\n+      reference = get_item ()->get_mappings ().get_hirid ();\n+      break;\n+\n+    case IMPL_ITEM:\n+      reference = get_impl_item ().second->get_mappings ().get_hirid ();\n+      break;\n+\n+    case TRAIT_ITEM:\n+      reference = get_trait_item ()->get_mappings ().get_hirid ();\n+      break;\n+    }\n+\n+  rust_assert (reference != UNKNOWN_HIRID);\n+\n+  TyTy::BaseType *lookup = nullptr;\n+  bool ok = context.lookup_type (reference, &lookup);\n+  rust_assert (ok);\n+  rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+  return static_cast<TyTy::FnType *> (lookup);\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "53eccb79d93b9ba3b4093154c307f179bb283a42", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 62, "deletions": 7, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -84,16 +84,71 @@ TypeCheckBase::get_predicate_from_bound (HIR::TypePath &type_path)\n     = HIR::GenericArgs::create_empty (type_path.get_locus ());\n \n   auto &final_seg = type_path.get_final_segment ();\n-  if (final_seg->is_generic_segment ())\n+  switch (final_seg->get_type ())\n     {\n-      auto final_generic_seg\n-\t= static_cast<HIR::TypePathSegmentGeneric *> (final_seg.get ());\n-      if (final_generic_seg->has_generic_args ())\n-\t{\n-\t  args = final_generic_seg->get_generic_args ();\n-\t}\n+      case HIR::TypePathSegment::SegmentType::GENERIC: {\n+\tauto final_generic_seg\n+\t  = static_cast<HIR::TypePathSegmentGeneric *> (final_seg.get ());\n+\tif (final_generic_seg->has_generic_args ())\n+\t  {\n+\t    args = final_generic_seg->get_generic_args ();\n+\t  }\n+      }\n+      break;\n+\n+      case HIR::TypePathSegment::SegmentType::FUNCTION: {\n+\tauto final_function_seg\n+\t  = static_cast<HIR::TypePathSegmentFunction *> (final_seg.get ());\n+\tauto &fn = final_function_seg->get_function_path ();\n+\n+\t// we need to make implicit generic args which must be an implicit Tuple\n+\tauto crate_num = mappings->get_current_crate ();\n+\tHirId implicit_args_id = mappings->get_next_hir_id ();\n+\tAnalysis::NodeMapping mapping (crate_num,\n+\t\t\t\t       final_seg->get_mappings ().get_nodeid (),\n+\t\t\t\t       implicit_args_id, UNKNOWN_LOCAL_DEFID);\n+\n+\tstd::vector<std::unique_ptr<HIR::Type>> params_copy;\n+\tfor (auto &p : fn.get_params ())\n+\t  {\n+\t    params_copy.push_back (p->clone_type ());\n+\t  }\n+\n+\tHIR::TupleType *implicit_tuple\n+\t  = new HIR::TupleType (mapping, std::move (params_copy),\n+\t\t\t\tfinal_seg->get_locus ());\n+\n+\tstd::vector<std::unique_ptr<HIR::Type>> inputs;\n+\tinputs.push_back (std::unique_ptr<HIR::Type> (implicit_tuple));\n+\n+\targs = HIR::GenericArgs ({} /* lifetimes */,\n+\t\t\t\t std::move (inputs) /* type_args*/,\n+\t\t\t\t {} /* binding_args*/, {} /* const_args */,\n+\t\t\t\t final_seg->get_locus ());\n+\n+\t// resolve the fn_once_output type\n+\tTyTy::BaseType *fn_once_output_ty\n+\t  = fn.has_return_type ()\n+\t      ? TypeCheckType::Resolve (fn.get_return_type ().get ())\n+\t      : TyTy::TupleType::get_unit_type (\n+\t\tfinal_seg->get_mappings ().get_hirid ());\n+\tcontext->insert_implicit_type (final_seg->get_mappings ().get_hirid (),\n+\t\t\t\t       fn_once_output_ty);\n+\n+\t// setup the associated type.. ??\n+\t// fn_once_output_ty->debug ();\n+      }\n+      break;\n+\n+    default:\n+      /* nothing to do */\n+      break;\n     }\n \n+  // FIXME\n+  // I think this should really be just be if the !args.is_empty() because\n+  // someone might wrongly apply generic arguments where they should not and\n+  // they will be missing error diagnostics\n   if (predicate.requires_generic_args ())\n     {\n       // this is applying generic arguments to a trait reference"}, {"sha": "18a34be09bfc9be3c9b29e262d4e41316817a20d", "filename": "gcc/rust/typecheck/rust-tyty-call.cc", "status": "modified", "additions": 68, "deletions": 30, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.cc?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -216,29 +216,77 @@ TypeCheckCallExpr::visit (FnPtr &type)\n \n // method call checker\n \n-void\n-TypeCheckMethodCallExpr::visit (FnType &type)\n+TypeCheckMethodCallExpr::TypeCheckMethodCallExpr (\n+  Analysis::NodeMapping call_mappings, std::vector<Argument> &args,\n+  Location call_locus, Location receiver_locus, TyTy::BaseType *adjusted_self,\n+  Resolver::TypeCheckContext *context)\n+  : call_mappings (call_mappings), arguments (args), call_locus (call_locus),\n+    receiver_locus (receiver_locus), adjusted_self (adjusted_self),\n+    context (context), mappings (Analysis::Mappings::get ())\n+{}\n+\n+BaseType *\n+TypeCheckMethodCallExpr::go (FnType *ref, HIR::MethodCallExpr &call,\n+\t\t\t     TyTy::BaseType *adjusted_self,\n+\t\t\t     Resolver::TypeCheckContext *context)\n+{\n+  std::vector<Argument> args;\n+  for (auto &arg : call.get_arguments ())\n+    {\n+      BaseType *argument_expr_tyty\n+\t= Resolver::TypeCheckExpr::Resolve (arg.get ());\n+      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (arg->get_locus (),\n+\t\t\t \"failed to resolve type for argument\");\n+\t  return new ErrorType (ref->get_ref ());\n+\t}\n+\n+      Argument a (arg->get_mappings (), argument_expr_tyty, arg->get_locus ());\n+      args.push_back (std::move (a));\n+    }\n+\n+  TypeCheckMethodCallExpr checker (call.get_mappings (), args,\n+\t\t\t\t   call.get_locus (),\n+\t\t\t\t   call.get_receiver ()->get_locus (),\n+\t\t\t\t   adjusted_self, context);\n+  return checker.check (*ref);\n+}\n+\n+BaseType *\n+TypeCheckMethodCallExpr::go (FnType *ref, Analysis::NodeMapping call_mappings,\n+\t\t\t     std::vector<Argument> &args, Location call_locus,\n+\t\t\t     Location receiver_locus,\n+\t\t\t     TyTy::BaseType *adjusted_self,\n+\t\t\t     Resolver::TypeCheckContext *context)\n+{\n+  TypeCheckMethodCallExpr checker (call_mappings, args, call_locus,\n+\t\t\t\t   receiver_locus, adjusted_self, context);\n+  return checker.check (*ref);\n+}\n+\n+BaseType *\n+TypeCheckMethodCallExpr::check (FnType &type)\n {\n   Resolver::TypeCheckBase::unify_site (\n-    call.get_mappings ().get_hirid (), TyWithLocation (type.get_self_type ()),\n-    TyWithLocation (adjusted_self, call.get_receiver ()->get_locus ()),\n-    call.get_locus ());\n+    call_mappings.get_hirid (), TyWithLocation (type.get_self_type ()),\n+    TyWithLocation (adjusted_self, receiver_locus), call_locus);\n \n   // +1 for the receiver self\n-  size_t num_args_to_call = call.num_params () + 1;\n+  size_t num_args_to_call = arguments.size () + 1;\n   if (num_args_to_call != type.num_params ())\n     {\n-      rust_error_at (call.get_locus (),\n+      rust_error_at (call_locus,\n \t\t     \"unexpected number of arguments %lu expected %lu\",\n-\t\t     (unsigned long) call.num_params (),\n+\t\t     (unsigned long) num_args_to_call,\n \t\t     (unsigned long) type.num_params ());\n-      return;\n+      return new ErrorType (type.get_ref ());\n     }\n \n   size_t i = 1;\n-  for (auto &argument : call.get_arguments ())\n+  for (auto &argument : arguments)\n     {\n-      Location arg_locus = argument->get_locus ();\n+      Location arg_locus = argument.get_locus ();\n \n       auto fnparam = type.param_at (i);\n       HIR::Pattern *fn_param_pattern = fnparam.first;\n@@ -248,41 +296,31 @@ TypeCheckMethodCallExpr::visit (FnType &type)\n \t    ? mappings->lookup_location (param_ty->get_ref ())\n \t    : fn_param_pattern->get_locus ();\n \n-      auto argument_expr_tyty\n-\t= Resolver::TypeCheckExpr::Resolve (argument.get ());\n-      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n-\t{\n-\t  rust_error_at (\n-\t    argument->get_locus (),\n-\t    \"failed to resolve type for argument expr in CallExpr\");\n-\t  return;\n-\t}\n-\n-      HirId coercion_side_id = argument->get_mappings ().get_hirid ();\n+      auto argument_expr_tyty = argument.get_argument_type ();\n+      HirId coercion_side_id = argument.get_mappings ().get_hirid ();\n       auto resolved_argument_type = Resolver::TypeCheckBase::coercion_site (\n \tcoercion_side_id, TyWithLocation (param_ty, param_locus),\n-\tTyWithLocation (argument_expr_tyty, arg_locus), argument->get_locus ());\n+\tTyWithLocation (argument_expr_tyty, arg_locus), arg_locus);\n       if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n \t{\n-\t  rust_error_at (argument->get_locus (),\n-\t\t\t \"Type Resolution failure on parameter\");\n-\t  return;\n+\t  rust_error_at (arg_locus, \"Type Resolution failure on parameter\");\n+\t  return new ErrorType (type.get_ref ());\n \t}\n \n       i++;\n     }\n \n   if (i != num_args_to_call)\n     {\n-      rust_error_at (call.get_locus (),\n+      rust_error_at (call_locus,\n \t\t     \"unexpected number of arguments %lu expected %lu\",\n-\t\t     (unsigned long) i, (unsigned long) call.num_params ());\n-      return;\n+\t\t     (unsigned long) i, (unsigned long) arguments.size ());\n+      return new ErrorType (type.get_ref ());\n     }\n \n   type.monomorphize ();\n \n-  resolved = type.get_return_type ()->monomorphized_clone ();\n+  return type.get_return_type ()->monomorphized_clone ();\n }\n \n } // namespace TyTy"}, {"sha": "eef567ac419b5a22aa0ce7d79210f1b71590eeb4", "filename": "gcc/rust/typecheck/rust-tyty-call.h", "status": "modified", "additions": 36, "deletions": 43, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -84,58 +84,51 @@ class TypeCheckCallExpr : private TyVisitor\n   Analysis::Mappings *mappings;\n };\n \n-class TypeCheckMethodCallExpr : private TyVisitor\n+class Argument\n {\n public:\n-  // Resolve the Method parameters and return back the return type\n-  static BaseType *go (BaseType *ref, HIR::MethodCallExpr &call,\n-\t\t       TyTy::BaseType *adjusted_self,\n-\t\t       Resolver::TypeCheckContext *context)\n-  {\n-    TypeCheckMethodCallExpr checker (call, adjusted_self, context);\n-    ref->accept_vis (checker);\n-    return checker.resolved;\n-  }\n+  Argument (Analysis::NodeMapping mapping, BaseType *argument_type,\n+\t    Location locus)\n+    : mapping (mapping), argument_type (argument_type), locus (locus)\n+  {}\n \n-  void visit (InferType &) override { gcc_unreachable (); }\n-  void visit (TupleType &) override { gcc_unreachable (); }\n-  void visit (ArrayType &) override { gcc_unreachable (); }\n-  void visit (SliceType &) override { gcc_unreachable (); }\n-  void visit (BoolType &) override { gcc_unreachable (); }\n-  void visit (IntType &) override { gcc_unreachable (); }\n-  void visit (UintType &) override { gcc_unreachable (); }\n-  void visit (FloatType &) override { gcc_unreachable (); }\n-  void visit (USizeType &) override { gcc_unreachable (); }\n-  void visit (ISizeType &) override { gcc_unreachable (); }\n-  void visit (ErrorType &) override { gcc_unreachable (); }\n-  void visit (ADTType &) override { gcc_unreachable (); };\n-  void visit (CharType &) override { gcc_unreachable (); }\n-  void visit (ReferenceType &) override { gcc_unreachable (); }\n-  void visit (PointerType &) override { gcc_unreachable (); }\n-  void visit (ParamType &) override { gcc_unreachable (); }\n-  void visit (StrType &) override { gcc_unreachable (); }\n-  void visit (NeverType &) override { gcc_unreachable (); }\n-  void visit (PlaceholderType &) override { gcc_unreachable (); }\n-  void visit (ProjectionType &) override { gcc_unreachable (); }\n-  void visit (DynamicObjectType &) override { gcc_unreachable (); }\n+  Location get_locus () const { return locus; }\n \n-  // FIXME\n-  void visit (FnPtr &type) override { gcc_unreachable (); }\n+  BaseType *get_argument_type () { return argument_type; }\n \n-  // call fns\n-  void visit (FnType &type) override;\n-  void visit (ClosureType &type) override { gcc_unreachable (); }\n+  Analysis::NodeMapping get_mappings () const { return mapping; }\n \n private:\n-  TypeCheckMethodCallExpr (HIR::MethodCallExpr &c,\n+  Analysis::NodeMapping mapping;\n+  BaseType *argument_type;\n+  Location locus;\n+};\n+\n+class TypeCheckMethodCallExpr\n+{\n+public:\n+  static BaseType *go (FnType *ref, HIR::MethodCallExpr &call,\n+\t\t       TyTy::BaseType *adjusted_self,\n+\t\t       Resolver::TypeCheckContext *context);\n+\n+  static BaseType *go (FnType *ref, Analysis::NodeMapping call_mappings,\n+\t\t       std::vector<Argument> &args, Location call_locus,\n+\t\t       Location receiver_locus, TyTy::BaseType *adjusted_self,\n+\t\t       Resolver::TypeCheckContext *context);\n+\n+protected:\n+  BaseType *check (FnType &type);\n+\n+  TypeCheckMethodCallExpr (Analysis::NodeMapping call_mappings,\n+\t\t\t   std::vector<Argument> &args, Location call_locus,\n+\t\t\t   Location receiver_locus,\n \t\t\t   TyTy::BaseType *adjusted_self,\n-\t\t\t   Resolver::TypeCheckContext *context)\n-    : resolved (nullptr), call (c), adjusted_self (adjusted_self),\n-      context (context), mappings (Analysis::Mappings::get ())\n-  {}\n+\t\t\t   Resolver::TypeCheckContext *context);\n \n-  BaseType *resolved;\n-  HIR::MethodCallExpr &call;\n+  Analysis::NodeMapping call_mappings;\n+  std::vector<Argument> &arguments;\n+  Location call_locus;\n+  Location receiver_locus;\n   TyTy::BaseType *adjusted_self;\n   Resolver::TypeCheckContext *context;\n   Analysis::Mappings *mappings;"}, {"sha": "23e52d941662b0e7e2c493ba774ff13eab6c7b66", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -871,6 +871,29 @@ class ClosureCmp : public BaseCmp\n     ok = true;\n   }\n \n+  void visit (const ClosureType &type) override\n+  {\n+    if (base->get_def_id () != type.get_def_id ())\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    if (!base->get_parameters ().can_eq (&type.get_parameters (), false))\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    if (!base->get_result_type ().can_eq (&type.get_result_type (), false))\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const ClosureType *base;"}, {"sha": "fe654cad12920cde91c4e1628fb7f8c6fa8bbc31", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -624,7 +624,45 @@ class ClosureRules : public BaseRules\n public:\n   ClosureRules (ClosureType *base) : BaseRules (base), base (base) {}\n \n-  // TODO\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (ClosureType &type) override\n+  {\n+    if (base->get_def_id () != type.get_def_id ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    TyTy::BaseType *args_res\n+      = base->get_parameters ().unify (&type.get_parameters ());\n+    if (args_res == nullptr || args_res->get_kind () == TypeKind::ERROR)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    TyTy::BaseType *res\n+      = base->get_result_type ().unify (&type.get_result_type ());\n+    if (res == nullptr || res->get_kind () == TypeKind::ERROR)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n \n private:\n   BaseType *get_base () override { return base; }"}, {"sha": "e56bdd17b873cb6002f9f978ffed8c61d1b0b727", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 66, "deletions": 5, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -27,6 +27,7 @@\n #include \"rust-substitution-mapper.h\"\n #include \"rust-hir-trait-ref.h\"\n #include \"rust-hir-type-bounds.h\"\n+#include \"rust-hir-trait-resolve.h\"\n #include \"options.h\"\n \n namespace Rust {\n@@ -200,6 +201,7 @@ BaseType::bounds_compatible (const BaseType &other, Location locus,\n \t  rust_error_at (r,\n \t\t\t \"bounds not satisfied for %s %<%s%> is not satisfied\",\n \t\t\t other.get_name ().c_str (), missing_preds.c_str ());\n+\t  // rust_assert (!emit_error);\n \t}\n     }\n \n@@ -1672,7 +1674,9 @@ ClosureType::accept_vis (TyConstVisitor &vis) const\n std::string\n ClosureType::as_string () const\n {\n-  return \"TODO\";\n+  std::string params_buf = parameters->as_string ();\n+  return \"|\" + params_buf + \"| {\" + result_type.get_tyty ()->as_string ()\n+\t + \"} {\" + raw_bounds_as_string () + \"}\";\n }\n \n BaseType *\n@@ -1692,15 +1696,26 @@ ClosureType::can_eq (const BaseType *other, bool emit_errors) const\n bool\n ClosureType::is_equal (const BaseType &other) const\n {\n-  gcc_unreachable ();\n-  return false;\n+  if (other.get_kind () != TypeKind::CLOSURE)\n+    return false;\n+\n+  const ClosureType &other2 = static_cast<const ClosureType &> (other);\n+  if (get_def_id () != other2.get_def_id ())\n+    return false;\n+\n+  if (!get_parameters ().is_equal (other2.get_parameters ()))\n+    return false;\n+\n+  return get_result_type ().is_equal (other2.get_result_type ());\n }\n \n BaseType *\n ClosureType::clone () const\n {\n-  return new ClosureType (get_ref (), get_ty_ref (), ident, id, parameter_types,\n-\t\t\t  result_type, clone_substs (), get_combined_refs ());\n+  return new ClosureType (get_ref (), get_ty_ref (), ident, id,\n+\t\t\t  (TyTy::TupleType *) parameters->clone (), result_type,\n+\t\t\t  clone_substs (), get_combined_refs (),\n+\t\t\t  specified_bounds);\n }\n \n BaseType *\n@@ -1716,6 +1731,52 @@ ClosureType::handle_substitions (SubstitutionArgumentMappings mappings)\n   return nullptr;\n }\n \n+void\n+ClosureType::setup_fn_once_output () const\n+{\n+  // lookup the lang items\n+  auto fn_once_lang_item = Analysis::RustLangItem::ItemType::FN_ONCE;\n+  auto fn_once_output_lang_item\n+    = Analysis::RustLangItem::ItemType::FN_ONCE_OUTPUT;\n+\n+  DefId trait_id = UNKNOWN_DEFID;\n+  bool trait_lang_item_defined\n+    = mappings->lookup_lang_item (fn_once_lang_item, &trait_id);\n+  rust_assert (trait_lang_item_defined);\n+\n+  DefId trait_item_id = UNKNOWN_DEFID;\n+  bool trait_item_lang_item_defined\n+    = mappings->lookup_lang_item (fn_once_output_lang_item, &trait_item_id);\n+  rust_assert (trait_item_lang_item_defined);\n+\n+  // resolve to the trait\n+  HIR::Item *item = mappings->lookup_defid (trait_id);\n+  rust_assert (item->get_item_kind () == HIR::Item::ItemKind::Trait);\n+  HIR::Trait *trait = static_cast<HIR::Trait *> (item);\n+\n+  Resolver::TraitReference *trait_ref\n+    = Resolver::TraitResolver::Resolve (*trait);\n+  rust_assert (!trait_ref->is_error ());\n+\n+  // resolve to trait item\n+  HIR::TraitItem *trait_item\n+    = mappings->lookup_trait_item_defid (trait_item_id);\n+  rust_assert (trait_item != nullptr);\n+  rust_assert (trait_item->get_item_kind ()\n+\t       == HIR::TraitItem::TraitItemKind::TYPE);\n+  std::string item_identifier = trait_item->trait_identifier ();\n+\n+  // setup associated types  #[lang = \"fn_once_output\"]\n+  Resolver::TraitItemReference *item_reference = nullptr;\n+  bool found = trait_ref->lookup_trait_item_by_type (\n+    item_identifier, Resolver::TraitItemReference::TraitItemType::TYPE,\n+    &item_reference);\n+  rust_assert (found);\n+\n+  // setup\n+  item_reference->associated_type_set (&get_result_type ());\n+}\n+\n void\n ArrayType::accept_vis (TyVisitor &vis)\n {"}, {"sha": "9a9f0aa915eeada43efc1937da0f50ab16a04bf3", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -1626,31 +1626,35 @@ class ClosureType : public BaseType, public SubstitutionRef\n {\n public:\n   ClosureType (HirId ref, DefId id, RustIdent ident,\n-\t       std::vector<TyVar> parameter_types, TyVar result_type,\n+\t       TyTy::TupleType *parameters, TyVar result_type,\n \t       std::vector<SubstitutionParamMapping> subst_refs,\n-\t       std::set<HirId> refs = std::set<HirId> ())\n+\t       std::set<HirId> refs = std::set<HirId> (),\n+\t       std::vector<TypeBoundPredicate> specified_bounds\n+\t       = std::vector<TypeBoundPredicate> ())\n     : BaseType (ref, ref, TypeKind::CLOSURE, ident, refs),\n       SubstitutionRef (std::move (subst_refs),\n \t\t       SubstitutionArgumentMappings::error ()),\n-      parameter_types (std::move (parameter_types)),\n-      result_type (std::move (result_type)), id (id)\n+      parameters (parameters), result_type (std::move (result_type)), id (id)\n   {\n     LocalDefId local_def_id = id.localDefId;\n     rust_assert (local_def_id != UNKNOWN_LOCAL_DEFID);\n+    inherit_bounds (specified_bounds);\n   }\n \n   ClosureType (HirId ref, HirId ty_ref, RustIdent ident, DefId id,\n-\t       std::vector<TyVar> parameter_types, TyVar result_type,\n+\t       TyTy::TupleType *parameters, TyVar result_type,\n \t       std::vector<SubstitutionParamMapping> subst_refs,\n-\t       std::set<HirId> refs = std::set<HirId> ())\n+\t       std::set<HirId> refs = std::set<HirId> (),\n+\t       std::vector<TypeBoundPredicate> specified_bounds\n+\t       = std::vector<TypeBoundPredicate> ())\n     : BaseType (ref, ty_ref, TypeKind::CLOSURE, ident, refs),\n       SubstitutionRef (std::move (subst_refs),\n \t\t       SubstitutionArgumentMappings::error ()),\n-      parameter_types (std::move (parameter_types)),\n-      result_type (std::move (result_type)), id (id)\n+      parameters (parameters), result_type (std::move (result_type)), id (id)\n   {\n     LocalDefId local_def_id = id.localDefId;\n     rust_assert (local_def_id != UNKNOWN_LOCAL_DEFID);\n+    inherit_bounds (specified_bounds);\n   }\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -1669,13 +1673,8 @@ class ClosureType : public BaseType, public SubstitutionRef\n \n   bool is_concrete () const override final\n   {\n-    for (auto &param : parameter_types)\n-      {\n-\tauto p = param.get_tyty ();\n-\tif (!p->is_concrete ())\n-\t  return false;\n-      }\n-    return result_type.get_tyty ()->is_concrete ();\n+    return parameters->is_concrete ()\n+\t   && result_type.get_tyty ()->is_concrete ();\n   }\n \n   bool needs_generic_substitutions () const override final\n@@ -1693,8 +1692,15 @@ class ClosureType : public BaseType, public SubstitutionRef\n   ClosureType *\n   handle_substitions (SubstitutionArgumentMappings mappings) override final;\n \n+  TyTy::TupleType &get_parameters () const { return *parameters; }\n+  TyTy::BaseType &get_result_type () const { return *result_type.get_tyty (); }\n+\n+  DefId get_def_id () const { return id; }\n+\n+  void setup_fn_once_output () const;\n+\n private:\n-  std::vector<TyVar> parameter_types;\n+  TyTy::TupleType *parameters;\n   TyVar result_type;\n   DefId id;\n };"}, {"sha": "111a8673c4494baaca9dc457e66650ed7d3f9433", "filename": "gcc/rust/util/rust-lang-item.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Futil%2Frust-lang-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Frust%2Futil%2Frust-lang-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-lang-item.h?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -75,6 +75,7 @@ class RustLangItem\n \n     // functions\n     FN_ONCE,\n+    FN_ONCE_OUTPUT,\n \n     UNKNOWN,\n   };\n@@ -225,6 +226,10 @@ class RustLangItem\n       {\n \treturn ItemType::FN_ONCE;\n       }\n+    else if (item.compare (\"fn_once_output\") == 0)\n+      {\n+\treturn ItemType::FN_ONCE_OUTPUT;\n+      }\n \n     return ItemType::UNKNOWN;\n   }\n@@ -305,6 +310,8 @@ class RustLangItem\n \treturn \"const_slice_ptr\";\n       case FN_ONCE:\n \treturn \"fn_once\";\n+      case FN_ONCE_OUTPUT:\n+\treturn \"fn_once_output\";\n \n       case UNKNOWN:\n \treturn \"<UNKNOWN>\";"}, {"sha": "62afa78a038d9a4f55d7f6c8dee138e01563ba11", "filename": "gcc/testsuite/rust/execute/torture/closure1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fclosure1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fclosure1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fclosure1.rs?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -0,0 +1,18 @@\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"fn_once\"]\n+pub trait FnOnce<Args> {\n+    #[lang = \"fn_once_output\"]\n+    type Output;\n+\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+fn main() -> i32 {\n+    let closure_annotated = |i: i32| -> i32 { i + 1 };\n+\n+    let i = 1;\n+    closure_annotated(i) - 2\n+}"}, {"sha": "45b3b5ce8b4b6fdf465e97e6ac78f3b091cd2a2d", "filename": "gcc/testsuite/rust/execute/torture/closure2.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fclosure2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490aa25d5564313c1957bf28533fe902a0aaa1f2/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fclosure2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fclosure2.rs?ref=490aa25d5564313c1957bf28533fe902a0aaa1f2", "patch": "@@ -0,0 +1,32 @@\n+// { dg-output \"3\\n\" }\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"fn_once\"]\n+pub trait FnOnce<Args> {\n+    #[lang = \"fn_once_output\"]\n+    type Output;\n+\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+fn f<F: FnOnce(i32) -> i32>(g: F) {\n+    let call = g(1);\n+    unsafe {\n+        let a = \"%i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, call);\n+    }\n+}\n+\n+pub fn main() -> i32 {\n+    let a = |i: i32| {\n+        let b = i + 2;\n+        b\n+    };\n+    f(a);\n+    0\n+}"}]}