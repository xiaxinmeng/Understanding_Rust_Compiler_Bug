{"sha": "4b58290fe6d467cf8d1c4f72e35c308218728b3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI1ODI5MGZlNmQ0NjdjZjhkMWM0ZjcyZTM1YzMwODIxODcyOGIzYg==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@redhat.com", "date": "2001-08-25T17:14:36Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2001-08-25T17:14:36Z"}, "message": "config.gcc: Add stormy16-*-elf case.\n\n\t* config.gcc: Add stormy16-*-elf case.\n\t* config/stormy16/stormy-abi: New file.\n\t* config/stormy16/stormy16-lib2.c: New file.\n\t* config/stormy16/stormy16-protos.h: New file.\n\t* config/stormy16/stormy16.c: New file.\n\t* config/stormy16/stormy16.h: New file.\n\t* config/stormy16/stormy16.md: New file.\n\t* config/stormy16/t-stormy16: New file.\n\nFrom-SVN: r45173", "tree": {"sha": "fbf9af098961c2e4bb58532af29c22fbd8e437a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbf9af098961c2e4bb58532af29c22fbd8e437a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b58290fe6d467cf8d1c4f72e35c308218728b3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b58290fe6d467cf8d1c4f72e35c308218728b3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b58290fe6d467cf8d1c4f72e35c308218728b3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b58290fe6d467cf8d1c4f72e35c308218728b3b/comments", "author": null, "committer": null, "parents": [{"sha": "d3fe11e62408ef839371ae20b5c666219de209a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3fe11e62408ef839371ae20b5c666219de209a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3fe11e62408ef839371ae20b5c666219de209a9"}], "stats": {"total": 8618, "additions": 8618, "deletions": 0}, "files": [{"sha": "f3ad806fb61d0e5b07efa271e639723fc735eba6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b58290fe6d467cf8d1c4f72e35c308218728b3b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b58290fe6d467cf8d1c4f72e35c308218728b3b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b58290fe6d467cf8d1c4f72e35c308218728b3b", "patch": "@@ -1,3 +1,14 @@\n+2001-08-22  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* config.gcc: Add stormy16-*-elf case.\n+\t* config/stormy16/stormy-abi: New file.\n+\t* config/stormy16/stormy16-lib2.c: New file.\n+\t* config/stormy16/stormy16-protos.h: New file.\n+\t* config/stormy16/stormy16.c: New file.\n+\t* config/stormy16/stormy16.h: New file.\n+\t* config/stormy16/stormy16.md: New file.\n+\t* config/stormy16/t-stormy16: New file.\n+\n Sat Aug 25 15:46:51 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.h (no-accumulate-outgoing-args): Use proper mask."}, {"sha": "a6d89aef86c376bdfacff375d3b3684c5737aa41", "filename": "gcc/config.gcc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b58290fe6d467cf8d1c4f72e35c308218728b3b/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b58290fe6d467cf8d1c4f72e35c308218728b3b/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=4b58290fe6d467cf8d1c4f72e35c308218728b3b", "patch": "@@ -3099,6 +3099,10 @@ sparc64-*-linux*)\t\t# 64-bit Sparc's running GNU/Linux\n \tfi\n \tfloat_format=sparc\n \t;;\n+stormy16-*-elf)\n+\ttmake_file=\"stormy16/t-stormy16\"\n+\textra_parts=\"crtbegin.o crtend.o\"\n+\t;;\n strongarm-*-elf*)\n \ttm_file=arm/strongarm-elf.h\n \ttmake_file=arm/t-strongarm-elf"}, {"sha": "78ed4b07c34bbda628e6dfff7a9cc746bf3559ca", "filename": "gcc/config/stormy16/stormy-abi", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b58290fe6d467cf8d1c4f72e35c308218728b3b/gcc%2Fconfig%2Fstormy16%2Fstormy-abi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b58290fe6d467cf8d1c4f72e35c308218728b3b/gcc%2Fconfig%2Fstormy16%2Fstormy-abi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy-abi?ref=4b58290fe6d467cf8d1c4f72e35c308218728b3b", "patch": "@@ -0,0 +1,153 @@\n+Stormy16 ABI\n+************\n+\n+!!!!! NOTE !!!!!\n+This document is a draft and is subject to change.\n+!!!!! NOTE !!!!!\n+\n+This part of the file describes the conventions required to write\n+ELF object files that are link-compatible with the ones produced\n+by the GNU toolchains.\n+\n+Bit and Byte Ordering\n+=====================\n+\n+This implementation is little-endian.   Bits are numbered starting \n+from 0 being the LSB.\n+\n+In this document, 'word' means 16 bits.\n+\n+Calling Sequence\n+================\n+\n+The registers are allocated as follows:\n+\n+Register\tPurpose\n+-------------------------------------------------------------------\n+r0, r1\t\tCall-volatile.  May be changed during the execution\n+\t\tof a call instruction.\n+r2 through r9\tArgument passing; call-clobbered.\n+r10 through r13\tCall-saved.\n+r14\t\tProgram status word.\n+r15\t\tStack pointer.\n+\n+\n+The return value of a procedure is returned in r2-r9 if it fits,\n+otherwise a pointer is passed as a `hidden' first argument\n+and the return value is placed there.\n+\n+Arguments are passed in registers starting in r2, then on the stack.\n+Arguments of size not a multiple of a word are padded to whole words.\n+If an argument would otherwise be passed partially in registers, and\n+partially on the stack, the whole of it is passed on the stack.  The\n+last argument is pushed on the stack first.\n+\n+After a procedure's arguments are pushed on the stack,\n+the return address is pushed on the stack, as if by the call\n+instruction.  The return address is on the top of the stack when\n+a procedure is called.\n+\n+Objects whose size is a multiple of 16 bits are aligned to a 16-bit\n+boundary.\n+\n+Pointers are 16 bits, referencing addresses between 0 and 0xFFFF.\n+\n+Procedure pointers are also implemented as 16-bit pointers.\n+\n+Variable Argument Functions\n+===========================\n+\n+The C type 'va_list' is implemented as a structure, as follows:\n+\n+struct {\n+  char *base;\n+  unsigned count;\n+}\n+\n+Both fields are 16 bits.  An argument of size N bytes\n+(N will be even) is accessed as if by the following code:\n+\n+char *result;\n+if (count + N > 16)\n+  {\n+    if (count < 16)\n+      count = 16;\n+    result = base - (count + N - 16 + 4);\n+  }\n+else\n+  {\n+    result = base + count;\n+  }\n+count += N;\n+/* The argument is at `*result'.  */\n+\n+\n+One implementation of this is if a variadic function first\n+pushes registers 2 through 9 in sequence at entry, and\n+sets 'base' to the address of the first word pushed, \n+producing a stack that appears like:\n+\n+SP ->\n+\t[other data]\n+\tr9\n+\tr8\n+\tr7\n+\tr6\n+\tr5\n+\tr4\n+\tr3\n+count-> r2\n+\tReturn address (two words)\n+\t9th procedure parameter word\n+\t10th procedure parameter word\n+\t...\n+\tlast procedure parameter word\n+\n+and initialises 'count' to be the number of bytes of non-variable\n+arguments to the function.\n+\n+ELF File Format\n+===============\n+\n+ELF file header\n+---------------\n+\n+Stormy16 ELF files are distinguished by the value EM_STORMY16 in\n+the e_machine field of the ELF file header:\n+\n+#define EM_STORMY16\t        0xad45\n+\n+DWARF Register Number Mapping\n+-----------------------------\n+\n+Registers r0 through r15 are mapped to numbers 0 through 15.\n+\n+Relocations\n+-----------\n+\n+RELA relocs are used exclusively.  The relocation types defined are:\n+\n+Name\t\t\tValue\tField\tCalculation\tOverflow\n+----------------------------------------------------------------\n+R_STORMY16_NONE\t\t0\tnone\tnone\t\tnone\n+R_STORMY16_32\t\t1\t32\tS + A\t\tnone\n+R_STORMY16_16\t\t2\t16\tS + A\t\tunsigned\n+R_STORMY16_8\t\t3\t8\tS + A\t\tunsigned\n+R_STORMY16_PC32\t\t4\t32\tS + A - P\tnone\n+R_STORMY16_PC16\t\t5\t16\tS + A - P\tsigned\n+R_STORMY16_PC8\t\t6\t8\tS + A - P\tsigned\n+R_STORMY16_REL_12\t7\t16:12:0\tS + A - P\tsigned\n+R_STORMY16_24\t\t8\t32:23:1\t(S + A) >> 1\tunsigned\n+R_STORMY16_GNU_VTINHERIT 9\tn/a\tn/a\t\tn/a\n+R_STORMY16_GNU_VTENTRY\t10\tn/a\tn/a\t\tn/a\n+\n+In the 'Calculation' column, 'S' is the value of the symbol to which\n+the reloc refers, 'A' is the addend, and 'P' represents the place of\n+the storage unit being relocated.\n+\n+In the 'Field' column, the first number indicates whether the\n+relocation refers to a byte, word or doubleword.  The second number,\n+if any, indicates the size of the bitfield into which the relocation\n+is to occur (and also the size for overflow checking).  The third\n+number indicates the first bit of the bitfield in the word or\n+doubleword, counting the LSB as bit 0."}, {"sha": "7038624be0edf676a4d4cdd46c6c13d0e391da86", "filename": "gcc/config/stormy16/stormy16-lib2.c", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b58290fe6d467cf8d1c4f72e35c308218728b3b/gcc%2Fconfig%2Fstormy16%2Fstormy16-lib2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b58290fe6d467cf8d1c4f72e35c308218728b3b/gcc%2Fconfig%2Fstormy16%2Fstormy16-lib2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16-lib2.c?ref=4b58290fe6d467cf8d1c4f72e35c308218728b3b", "patch": "@@ -0,0 +1,142 @@\n+typedef\t\t int HItype\t\t__attribute__ ((mode (HI)));\n+typedef\t\t int SItype\t\t__attribute__ ((mode (SI)));\n+typedef unsigned int USItype\t\t__attribute__ ((mode (SI)));\n+\n+typedef int word_type\t\t\t__attribute__ ((mode (__word__)));\n+\n+USItype\n+udivmodsi4(USItype num, USItype den, word_type modwanted)\n+{\n+  USItype bit = 1;\n+  USItype res = 0;\n+\n+  while (den < num && bit && !(den & (1L<<31)))\n+    {\n+      den <<=1;\n+      bit <<=1;\n+    }\n+  while (bit)\n+    {\n+      if (num >= den)\n+\t{\n+\t  num -= den;\n+\t  res |= bit;\n+\t}\n+      bit >>=1;\n+      den >>=1;\n+    }\n+  if (modwanted) return num;\n+  return res;\n+}\n+\n+\n+\n+SItype\n+__divsi3 (SItype a, SItype b)\n+{\n+  word_type neg = 0;\n+  SItype res;\n+\n+  if (a < 0)\n+    {\n+      a = -a;\n+      neg = !neg;\n+    }\n+\n+  if (b < 0)\n+    {\n+      b = -b;\n+      neg = !neg;\n+    }\n+\n+  res = udivmodsi4 (a, b, 0);\n+\n+  if (neg)\n+    res = -res;\n+\n+  return res;\n+}\n+\n+\n+\n+SItype\n+__modsi3 (SItype a, SItype b)\n+{\n+  word_type neg = 0;\n+  SItype res;\n+\n+  if (a < 0)\n+    {\n+      a = -a;\n+      neg = 1;\n+    }\n+\n+  if (b < 0)\n+    b = -b;\n+\n+  res = udivmodsi4 (a, b, 1);\n+\n+  if (neg)\n+    res = -res;\n+\n+  return res;\n+}\n+\n+\n+\n+\n+SItype\n+__udivsi3 (SItype a, SItype b)\n+{\n+  return udivmodsi4 (a, b, 0);\n+}\n+\n+\n+\n+SItype\n+__umodsi3 (SItype a, SItype b)\n+{\n+  return udivmodsi4 (a, b, 1);\n+}\n+\n+SItype\n+__ashlsi3 (SItype a, SItype b)\n+{\n+  word_type i;\n+  \n+  if (b & 16)\n+    a <<= 16;\n+  if (b & 8)\n+    a <<= 8;\n+  for (i = (b & 0x7); i > 0; --i)\n+    a <<= 1;\n+  return a;\n+}\n+\n+SItype\n+__ashrsi3 (SItype a, SItype b)\n+{\n+  word_type i;\n+  \n+  if (b & 16)\n+    a >>= 16;\n+  if (b & 8)\n+    a >>= 8;\n+  for (i = (b & 0x7); i > 0; --i)\n+    a >>= 1;\n+  return a;\n+}\n+\n+USItype\n+__lshrsi3 (USItype a, USItype b)\n+{\n+  word_type i;\n+  \n+  if (b & 16)\n+    a >>= 16;\n+  if (b & 8)\n+    a >>= 8;\n+  for (i = (b & 0x7); i > 0; --i)\n+    a >>= 1;\n+  return a;\n+}"}, {"sha": "39a84537ca6726328e723c11c0ac68fab05bbd82", "filename": "gcc/config/stormy16/stormy16-protos.h", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b58290fe6d467cf8d1c4f72e35c308218728b3b/gcc%2Fconfig%2Fstormy16%2Fstormy16-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b58290fe6d467cf8d1c4f72e35c308218728b3b/gcc%2Fconfig%2Fstormy16%2Fstormy16-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16-protos.h?ref=4b58290fe6d467cf8d1c4f72e35c308218728b3b", "patch": "@@ -0,0 +1,91 @@\n+/* Prototypes for exported functions defined in stormy16.c\n+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+   Contributed by Red Hat, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+\n+\n+extern struct stormy16_stack_layout \n+\t\t    stormy16_compute_stack_layout PARAMS((void));\n+extern void         stormy16_expand_prologue      PARAMS ((void));\n+extern void         stormy16_expand_epilogue      PARAMS ((void));\n+extern int\tstormy16_initial_elimination_offset PARAMS ((int, int));\n+extern int\tdirect_return PARAMS ((void));\n+extern int\tstormy16_interrupt_function_p PARAMS ((void));\n+extern int\tstormy16_epilogue_uses PARAMS ((int));\n+\n+#if defined (TREE_CODE)\n+#  if defined (HAVE_MACHINE_MODES)\n+extern CUMULATIVE_ARGS stormy16_function_arg_advance \n+  PARAMS ((CUMULATIVE_ARGS, enum machine_mode, tree, int));\n+#  endif\n+extern void    stormy16_setup_incoming_varargs \n+  PARAMS ((CUMULATIVE_ARGS, int, tree, int *));\n+extern tree    stormy16_build_va_list PARAMS ((void));\n+extern void    stormy16_encode_section_info PARAMS ((tree));\n+#endif\n+\n+#if defined (TREE_CODE) && defined (RTX_CODE)\n+extern void    stormy16_expand_builtin_va_start PARAMS ((int, tree, rtx));\n+extern rtx     stormy16_expand_builtin_va_arg PARAMS ((tree, tree));\n+extern void    stormy16_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n+extern rtx     stormy16_function_value PARAMS ((tree, tree));\n+#endif\n+\n+#ifdef RTX_CODE\n+extern void stormy16_emit_cbranch PARAMS ((enum rtx_code, rtx));\n+extern char * stormy16_output_cbranch_hi PARAMS ((rtx, const char *, int, \n+\t\t\t\t\t\t  rtx));\n+extern char * stormy16_output_cbranch_si PARAMS ((rtx, const char *, int, \n+\t\t\t\t\t\t  rtx));\n+extern int stormy16_mode_dependent_address_p PARAMS ((rtx));\n+extern int stormy16_extra_constraint_p PARAMS ((rtx, int));\n+\n+extern void stormy16_print_operand          PARAMS ((FILE *, rtx, int));\n+extern void stormy16_print_operand_address  PARAMS ((FILE *, rtx));\n+\n+extern void stormy16_expand_casesi PARAMS ((rtx, rtx, rtx, rtx, rtx));\n+extern void stormy16_output_addr_vec PARAMS ((FILE *, rtx, rtx));\n+extern void stormy16_expand_call PARAMS ((rtx, rtx, rtx));\n+#endif\n+\n+#if defined (HAVE_MACHINE_MODES) && defined (RTX_CODE)\n+extern int stormy16_ineqsi_operator PARAMS ((rtx, enum machine_mode));\n+extern int equality_operator PARAMS ((rtx, enum machine_mode));\n+extern int inequality_operator PARAMS ((rtx, enum machine_mode));\n+extern void stormy16_split_cbranch PARAMS ((enum machine_mode, \n+\t\t\t\t\t   rtx, rtx, rtx, rtx));\n+extern int  short_memory_operand PARAMS ((rtx, enum machine_mode));\n+extern enum reg_class stormy16_secondary_reload_class \n+  PARAMS ((enum reg_class, enum machine_mode, rtx));\n+extern int  stormy16_carry_plus_operand PARAMS ((rtx, enum machine_mode));\n+extern enum reg_class stormy16_preferred_reload_class \n+  PARAMS ((rtx, enum reg_class));\n+extern int stormy16_legitimate_address_p \n+   PARAMS ((enum machine_mode, rtx, int));\n+extern void stormy16_split_move PARAMS ((enum machine_mode, rtx, rtx));\n+extern void stormy16_expand_move PARAMS ((enum machine_mode, rtx, rtx));\n+extern void stormy16_expand_arith PARAMS ((enum machine_mode, enum rtx_code, \n+\t\t\t\t\t   rtx, rtx, rtx, rtx));\n+extern int  shift_operator PARAMS ((rtx, enum machine_mode));\n+extern const char * stormy16_output_shift PARAMS ((enum machine_mode, \n+\t\t\t\t\t\t   enum rtx_code, \n+\t\t\t\t\t\t   rtx, rtx, rtx));\n+#endif\n+"}, {"sha": "c29bc085d954d8cf4706a7190c9a485a38869803", "filename": "gcc/config/stormy16/stormy16.c", "status": "added", "additions": 1873, "deletions": 0, "changes": 1873, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b58290fe6d467cf8d1c4f72e35c308218728b3b/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b58290fe6d467cf8d1c4f72e35c308218728b3b/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=4b58290fe6d467cf8d1c4f72e35c308218728b3b", "patch": "@@ -0,0 +1,1873 @@\n+/* Stormy16 target functions.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Contributed by Red Hat, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"recog.h\"\n+#include \"toplev.h\"\n+#include \"obstack.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+#include \"output.h\"\n+#include \"except.h\"\n+#include \"function.h\"\n+#include \"target.h\"\n+#include \"target-def.h\"\n+#include \"tm_p.h\"\n+\n+static rtx emit_addhi3_postreload PARAMS ((rtx, rtx, rtx));\n+\n+/* Define the information needed to generate branch and scc insns.  This is\n+   stored from the compare operation.  */\n+struct rtx_def * stormy16_compare_op0;\n+struct rtx_def * stormy16_compare_op1;\n+\n+/* Return 1 if this is a LT, GE, LTU, or GEU operator.  */\n+\n+int\n+stormy16_ineqsi_operator (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+  \n+  return ((mode == VOIDmode || GET_MODE (op) == mode)\n+\t  && (code == LT || code == GE || code == LTU || code == GEU));\n+}\n+\n+/* Return 1 if this is an EQ or NE operator.  */\n+\n+int\n+equality_operator (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  return ((mode == VOIDmode || GET_MODE (op) == mode)\n+\t  && (GET_CODE (op) == EQ || GET_CODE (op) == NE));\n+}\n+\n+/* Return 1 if this is a comparison operator but not an EQ or NE operator.  */\n+\n+int\n+inequality_operator (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  return comparison_operator (op, mode) && ! equality_operator (op, mode);\n+}\n+\n+/* Branches are handled as follows:\n+\n+   1. HImode compare-and-branches.  The machine supports these\n+      natively, so the appropriate pattern is emitted directly.\n+\n+   2. SImode EQ and NE.  These are emitted as pairs of HImode\n+      compare-and-branches.      \n+\n+   3. SImode LT, GE, LTU and GEU.  These are emitted as a sequence\n+      of a SImode subtract followed by a branch (not a compare-and-branch),\n+      like this:\n+      sub\n+      sbc\n+      blt\n+\n+   4. SImode GT, LE, GTU, LEU.  These are emitted as a sequence like:\n+      sub\n+      sbc\n+      blt\n+      or\n+      bne\n+*/\n+\n+/* Emit a branch of kind CODE to location LOC.  */\n+\n+void\n+stormy16_emit_cbranch (code, loc)\n+     enum rtx_code code;\n+     rtx loc;\n+{\n+  rtx op0 = stormy16_compare_op0;\n+  rtx op1 = stormy16_compare_op1;\n+  rtx condition_rtx, loc_ref, branch, cy_clobber;\n+  rtvec vec;\n+  enum machine_mode mode;\n+  \n+  mode = GET_MODE (op0);\n+  if (mode != HImode && mode != SImode)\n+    abort ();\n+\n+  if (mode == SImode\n+      && (code == GT || code == LE || code == GTU || code == LEU))\n+    {\n+      int unsigned_p = (code == GTU || code == LEU);\n+      int gt_p = (code == GT || code == GTU);\n+      rtx lab;\n+      \n+      if (gt_p)\n+\tlab = gen_label_rtx ();\n+      stormy16_emit_cbranch (unsigned_p ? LTU : LT, gt_p ? lab : loc);\n+      /* This should be generated as a comparison against the temporary\n+\t created by the previous insn, but reload can't handle that.  */\n+      stormy16_emit_cbranch (gt_p ? NE : EQ, loc);\n+      if (gt_p)\n+\temit_label (lab);\n+      return;\n+    }\n+  else if (mode == SImode \n+\t   && (code == NE || code == EQ)\n+\t   && op1 != const0_rtx)\n+    {\n+      rtx lab;\n+      int num_words = GET_MODE_BITSIZE (mode) / BITS_PER_WORD;\n+      int i;\n+      \n+      if (code == EQ)\n+\tlab = gen_label_rtx ();\n+      \n+      for (i = 0; i < num_words - 1; i++)\n+\t{\n+\t  stormy16_compare_op0 = simplify_gen_subreg (word_mode, op0, mode, \n+\t\t\t\t\t\t      i * UNITS_PER_WORD);\n+\t  stormy16_compare_op1 = simplify_gen_subreg (word_mode, op1, mode, \n+\t\t\t\t\t\t      i * UNITS_PER_WORD);\n+\t  stormy16_emit_cbranch (NE, code == EQ ? lab : loc);\n+\t}\n+      stormy16_compare_op0 = simplify_gen_subreg (word_mode, op0, mode, \n+\t\t\t\t\t\t  i * UNITS_PER_WORD);\n+      stormy16_compare_op1 = simplify_gen_subreg (word_mode, op1, mode, \n+\t\t\t\t\t\t  i * UNITS_PER_WORD);\n+      stormy16_emit_cbranch (code, loc);\n+\n+      if (code == EQ)\n+\temit_label (lab);\n+      return;\n+    }\n+\n+  /* We can't allow reload to try to generate any reload after a branch,\n+     so when some register must match we must make the temporary ourselves.  */\n+  if (mode != HImode)\n+    {\n+      rtx tmp;\n+      tmp = gen_reg_rtx (mode);\n+      emit_move_insn (tmp, op0);\n+      op0 = tmp;\n+    }\n+\n+  condition_rtx = gen_rtx (code, mode, op0, op1);\n+  loc_ref = gen_rtx_LABEL_REF (VOIDmode, loc);\n+  branch = gen_rtx_SET (VOIDmode, pc_rtx,\n+\t\t\tgen_rtx_IF_THEN_ELSE (VOIDmode, condition_rtx,\n+\t\t\t\t\t      loc_ref, pc_rtx));\n+\n+  cy_clobber = gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (BImode));\n+\n+  if (mode == HImode)\n+    vec = gen_rtvec (2, branch, cy_clobber);\n+  else if (code == NE || code == EQ)\n+    vec = gen_rtvec (2, branch, gen_rtx_CLOBBER (VOIDmode, op0));\n+  else\n+    {\n+      rtx sub;\n+#if 0\n+      sub = gen_rtx_SET (VOIDmode, op0, gen_rtx_MINUS (SImode, op0, op1));\n+#else\n+      sub = gen_rtx_CLOBBER (SImode, op0);\n+#endif\n+      vec = gen_rtvec (3, branch, sub, cy_clobber);\n+    }\n+\n+  emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, vec));\n+}\n+\n+/* Take a SImode conditional branch, one of GT/LE/GTU/LEU, and split\n+   the arithmetic operation.  Most of the work is done by\n+   stormy16_expand_arith.  */\n+\n+void\n+stormy16_split_cbranch (mode, label, comparison, dest, carry)\n+     enum machine_mode mode;\n+     rtx label;\n+     rtx comparison;\n+     rtx dest;\n+     rtx carry;\n+{\n+  rtx op0 = XEXP (comparison, 0);\n+  rtx op1 = XEXP (comparison, 1);\n+  rtx seq;\n+  rtx compare;\n+  \n+  start_sequence ();\n+  stormy16_expand_arith (mode, COMPARE, dest, op0, op1, carry);\n+  seq = gen_sequence ();\n+  end_sequence ();\n+  compare = SET_SRC (XVECEXP (PATTERN (XVECEXP (seq, 0, XVECLEN (seq, 0) - 1)),\n+\t\t\t      0, 0));\n+  PUT_CODE (XEXP (compare, 0), GET_CODE (comparison));\n+  XEXP (compare, 1) = gen_rtx_LABEL_REF (VOIDmode, label);\n+  emit_insn (seq);\n+}\n+\n+\n+/* Return the string to output a conditional branch to LABEL, which is\n+   the operand number of the label.\n+\n+   OP is the conditional expression, or NULL for branch-always.\n+\n+   REVERSED is non-zero if we should reverse the sense of the comparison.\n+\n+   INSN is the insn.  */\n+\n+char *\n+stormy16_output_cbranch_hi (op, label, reversed, insn)\n+     rtx op;\n+     const char * label;\n+     int reversed;\n+     rtx insn;\n+{\n+  static char string[64];\n+  int need_longbranch = (op != NULL_RTX\n+\t\t\t ? get_attr_length (insn) == 8\n+\t\t\t : get_attr_length (insn) == 4);\n+  int really_reversed = reversed ^ need_longbranch;\n+  const char *ccode;\n+  const char *template;\n+  const char *operands;\n+  enum rtx_code code;\n+  \n+  if (! op)\n+    {\n+      if (need_longbranch)\n+\tccode = \"jmpf\";\n+      else\n+\tccode = \"br\";\n+      sprintf (string, \"%s %s\", ccode, label);\n+      return string;\n+    }\n+\n+  code = GET_CODE (op);\n+\n+  if (GET_CODE (XEXP (op, 0)) != REG)\n+    {\n+      code = swap_condition (code);\n+      operands = \"%3,%2\";\n+    }\n+  else\n+      operands = \"%2,%3\";\n+\n+  /* Work out which way this really branches.  */\n+  if (really_reversed)\n+    code = reverse_condition (code);\n+\n+  switch (code)\n+    {\n+    case EQ:   ccode = \"z\";   break;\n+    case NE:   ccode = \"nz\";  break;\n+    case GE:   ccode = \"ge\";  break;\n+    case LT:   ccode = \"lt\";  break;\n+    case GT:   ccode = \"gt\";  break;\n+    case LE:   ccode = \"le\";  break;\n+    case GEU:  ccode = \"nc\";  break;\n+    case LTU:  ccode = \"c\";   break;\n+    case GTU:  ccode = \"hi\";  break;\n+    case LEU:  ccode = \"ls\";  break;\n+      \n+    default:\n+      abort ();\n+    }\n+\n+  if (need_longbranch)\n+    template = \"b%s %s,.+8 | jmpf %s\";\n+  else\n+    template = \"b%s %s,%s\";\n+  sprintf (string, template, ccode, operands, label);\n+  \n+  return string;\n+}\n+\n+/* Return the string to output a conditional branch to LABEL, which is\n+   the operand number of the label, but suitable for the tail of a\n+   SImode branch.\n+\n+   OP is the conditional expression (OP is never NULL_RTX).\n+\n+   REVERSED is non-zero if we should reverse the sense of the comparison.\n+\n+   INSN is the insn.  */\n+\n+char *\n+stormy16_output_cbranch_si (op, label, reversed, insn)\n+     rtx op;\n+     const char * label;\n+     int reversed;\n+     rtx insn;\n+{\n+  static char string[64];\n+  int need_longbranch = get_attr_length (insn) >= 8;\n+  int really_reversed = reversed ^ need_longbranch;\n+  const char *ccode;\n+  const char *template;\n+  char prevop[16];\n+  enum rtx_code code;\n+  \n+  code = GET_CODE (op);\n+\n+  /* Work out which way this really branches.  */\n+  if (really_reversed)\n+    code = reverse_condition (code);\n+\n+  switch (code)\n+    {\n+    case EQ:   ccode = \"z\";   break;\n+    case NE:   ccode = \"nz\";  break;\n+    case GE:   ccode = \"ge\";  break;\n+    case LT:   ccode = \"lt\";  break;\n+    case GEU:  ccode = \"nc\";  break;\n+    case LTU:  ccode = \"c\";   break;\n+\n+      /* The missing codes above should never be generated.  */\n+    default:\n+      abort ();\n+    }\n+\n+  switch (code)\n+    {\n+    case EQ: case NE:\n+      {\n+\tint regnum;\n+\t\n+\tif (GET_CODE (XEXP (op, 0)) != REG)\n+\t  abort ();\n+      \n+\tregnum = REGNO (XEXP (op, 0));\n+\tsprintf (prevop, \"or %s,%s\", reg_names[regnum], reg_names[regnum+1]);\n+      }\n+      break;\n+\n+    case GE: case LT: case GEU: case LTU:\n+      strcpy (prevop, \"sbc %2,%3\");\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  if (need_longbranch)\n+    template = \"%s | b%s .+6 | jmpf %s\";\n+  else\n+    template = \"%s | b%s %s\";\n+  sprintf (string, template, prevop, ccode, label);\n+  \n+  return string;\n+}\n+\f\n+/* Many machines have some registers that cannot be copied directly to or from\n+   memory or even from other types of registers.  An example is the `MQ'\n+   register, which on most machines, can only be copied to or from general\n+   registers, but not memory.  Some machines allow copying all registers to and\n+   from memory, but require a scratch register for stores to some memory\n+   locations (e.g., those with symbolic address on the RT, and those with\n+   certain symbolic address on the Sparc when compiling PIC).  In some cases,\n+   both an intermediate and a scratch register are required.\n+\n+   You should define these macros to indicate to the reload phase that it may\n+   need to allocate at least one register for a reload in addition to the\n+   register to contain the data.  Specifically, if copying X to a register\n+   CLASS in MODE requires an intermediate register, you should define\n+   `SECONDARY_INPUT_RELOAD_CLASS' to return the largest register class all of\n+   whose registers can be used as intermediate registers or scratch registers.\n+\n+   If copying a register CLASS in MODE to X requires an intermediate or scratch\n+   register, `SECONDARY_OUTPUT_RELOAD_CLASS' should be defined to return the\n+   largest register class required.  If the requirements for input and output\n+   reloads are the same, the macro `SECONDARY_RELOAD_CLASS' should be used\n+   instead of defining both macros identically.\n+\n+   The values returned by these macros are often `GENERAL_REGS'.  Return\n+   `NO_REGS' if no spare register is needed; i.e., if X can be directly copied\n+   to or from a register of CLASS in MODE without requiring a scratch register.\n+   Do not define this macro if it would always return `NO_REGS'.\n+\n+   If a scratch register is required (either with or without an intermediate\n+   register), you should define patterns for `reload_inM' or `reload_outM', as\n+   required..  These patterns, which will normally be implemented with a\n+   `define_expand', should be similar to the `movM' patterns, except that\n+   operand 2 is the scratch register.\n+\n+   Define constraints for the reload register and scratch register that contain\n+   a single register class.  If the original reload register (whose class is\n+   CLASS) can meet the constraint given in the pattern, the value returned by\n+   these macros is used for the class of the scratch register.  Otherwise, two\n+   additional reload registers are required.  Their classes are obtained from\n+   the constraints in the insn pattern.\n+\n+   X might be a pseudo-register or a `subreg' of a pseudo-register, which could\n+   either be in a hard register or in memory.  Use `true_regnum' to find out;\n+   it will return -1 if the pseudo is in memory and the hard register number if\n+   it is in a register.\n+\n+   These macros should not be used in the case where a particular class of\n+   registers can only be copied to memory and not to another class of\n+   registers.  In that case, secondary reload registers are not needed and\n+   would not be helpful.  Instead, a stack location must be used to perform the\n+   copy and the `movM' pattern should use memory as a intermediate storage.\n+   This case often occurs between floating-point and general registers.  */\n+\n+enum reg_class\n+stormy16_secondary_reload_class (class, mode, x)\n+     enum reg_class class;\n+     enum machine_mode mode;\n+     rtx x;\n+{\n+  /* This chip has the interesting property that only the first eight\n+     registers can be moved to/from memory.  */\n+  if ((GET_CODE (x) == MEM\n+       || ((GET_CODE (x) == SUBREG || GET_CODE (x) == REG)\n+\t   && (true_regnum (x) == -1\n+\t       || true_regnum (x) >= FIRST_PSEUDO_REGISTER)))\n+      && ! reg_class_subset_p (class, EIGHT_REGS))\n+    return EIGHT_REGS;\n+\n+  /* When reloading a PLUS, the carry register will be required\n+     unless the inc or dec instructions can be used.  */\n+  if (stormy16_carry_plus_operand (x, mode))\n+    return CARRY_REGS;\n+\n+  return NO_REGS;\n+}\n+\n+/* Recognise a PLUS that needs the carry register.  */\n+int\n+stormy16_carry_plus_operand (x, mode)\n+     rtx x;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  return (GET_CODE (x) == PLUS\n+\t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && (INTVAL (XEXP (x, 1)) < -4 || INTVAL (XEXP (x, 1)) > 4));\n+}\n+\n+\n+enum reg_class\n+stormy16_preferred_reload_class (x, class)\n+     enum reg_class class;\n+     rtx x;\n+{\n+  if (class == GENERAL_REGS\n+      && GET_CODE (x) == MEM)\n+    return EIGHT_REGS;\n+\n+  return class;\n+}\n+\n+#define LEGITIMATE_ADDRESS_INTEGER_P(X, OFFSET)\t\t\t\t\\\n+ (GET_CODE (X) == CONST_INT\t\t\t\t\t\t\\\n+  && (unsigned HOST_WIDE_INT) (INTVAL (X) + (OFFSET) + 2048) < 4096)\n+\n+#define LEGITIMATE_ADDRESS_CONST_INT_P(X, OFFSET)\t\t\t \\\n+ (GET_CODE (X) == CONST_INT\t\t\t\t\t\t \\\n+  && INTVAL (X) + (OFFSET) >= 0\t\t\t\t\t\t \\\n+  && INTVAL (X) + (OFFSET) < 0x8000\t\t\t\t\t \\\n+  && (INTVAL (X) + (OFFSET) < 0x100 || INTVAL (X) + (OFFSET) >= 0x7F00))\n+\n+int\n+stormy16_legitimate_address_p (mode, x, strict)\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     rtx x;\n+     int strict;\n+{\n+  if (LEGITIMATE_ADDRESS_CONST_INT_P (x, 0))\n+    return 1;\n+\n+  if (GET_CODE (x) == PLUS\n+      && LEGITIMATE_ADDRESS_INTEGER_P (XEXP (x, 1), 0))\n+    x = XEXP (x, 0);\n+  \n+  if (GET_CODE (x) == POST_INC\n+      || GET_CODE (x) == PRE_DEC)\n+    x = XEXP (x, 0);\n+  \n+  if (GET_CODE (x) == REG && REGNO_OK_FOR_BASE_P (REGNO (x))\n+      && (! strict || REGNO (x) < FIRST_PSEUDO_REGISTER))\n+    return 1;\n+  \n+  return 0;\n+}\n+\n+/* Return nonzero if memory address X (an RTX) can have different\n+   meanings depending on the machine mode of the memory reference it\n+   is used for or if the address is valid for some modes but not\n+   others.\n+\n+   Autoincrement and autodecrement addresses typically have mode-dependent\n+   effects because the amount of the increment or decrement is the size of the\n+   operand being addressed.  Some machines have other mode-dependent addresses.\n+   Many RISC machines have no mode-dependent addresses.\n+\n+   You may assume that ADDR is a valid address for the machine.  \n+   \n+   On this chip, this is true if the address is valid with an offset\n+   of 0 but not of 6, because in that case it cannot be used as an\n+   address for DImode or DFmode, or if the address is a post-increment\n+   or pre-decrement address.  */\n+int\n+stormy16_mode_dependent_address_p (x)\n+     rtx x;\n+{\n+  if (LEGITIMATE_ADDRESS_CONST_INT_P (x, 0)\n+      && ! LEGITIMATE_ADDRESS_CONST_INT_P (x, 6))\n+    return 1;\n+  \n+  if (GET_CODE (x) == PLUS\n+      && LEGITIMATE_ADDRESS_INTEGER_P (XEXP (x, 1), 0)\n+      && ! LEGITIMATE_ADDRESS_INTEGER_P (XEXP (x, 1), 6))\n+    return 1;\n+\n+  if (GET_CODE (x) == PLUS)\n+    x = XEXP (x, 0);\n+\n+  if (GET_CODE (x) == POST_INC\n+      || GET_CODE (x) == PRE_DEC)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* A C expression that defines the optional machine-dependent constraint\n+   letters (`Q', `R', `S', `T', `U') that can be used to segregate specific\n+   types of operands, usually memory references, for the target machine.\n+   Normally this macro will not be defined.  If it is required for a particular\n+   target machine, it should return 1 if VALUE corresponds to the operand type\n+   represented by the constraint letter C.  If C is not defined as an extra\n+   constraint, the value returned should be 0 regardless of VALUE.  */\n+int\n+stormy16_extra_constraint_p (x, c)\n+     rtx x;\n+     int c;\n+{\n+  switch (c)\n+    {\n+      /* 'Q' is for pushes.  */\n+    case 'Q':\n+      return (GET_CODE (x) == MEM\n+\t      && GET_CODE (XEXP (x, 0)) == POST_INC\n+\t      && XEXP (XEXP (x, 0), 0) == stack_pointer_rtx);\n+\n+      /* 'R' is for pops.  */\n+    case 'R':\n+      return (GET_CODE (x) == MEM\n+\t      && GET_CODE (XEXP (x, 0)) == PRE_DEC\n+\t      && XEXP (XEXP (x, 0), 0) == stack_pointer_rtx);\n+\n+      /* 'S' is for immediate memory addresses.  */\n+    case 'S':\n+      return (GET_CODE (x) == MEM\n+\t      && GET_CODE (XEXP (x, 0)) == CONST_INT\n+\t      && stormy16_legitimate_address_p (VOIDmode, XEXP (x, 0), 0));\n+\n+      /* 'T' is for Rx.  */\n+    case 'T':\n+      /* Not implemented yet.  */\n+      return 0;\n+\n+      /* 'U' is for CONST_INT values not between 2 and 15 inclusive,\n+\t for allocating a scratch register for 32-bit shifts.  */\n+    case 'U':\n+      return (GET_CODE (x) == CONST_INT\n+\t      && (INTVAL (x) < 2 || INTVAL (x) > 15));\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+int\n+short_memory_operand (x, mode)\n+     rtx x;\n+     enum machine_mode mode;\n+{\n+  if (! memory_operand (x, mode))\n+    return 0;\n+  return (GET_CODE (XEXP (x, 0)) != PLUS);\n+}\n+\n+/* Splitter for the 'move' patterns, for modes not directly implemeted\n+   by hardware.  Emit insns to copy a value of mode MODE from SRC to\n+   DEST.\n+\n+   This function is only called when reload_completed.\n+   */\n+\n+void \n+stormy16_split_move (mode, dest, src)\n+     enum machine_mode mode;\n+     rtx dest;\n+     rtx src;\n+{\n+  int num_words = GET_MODE_BITSIZE (mode) / BITS_PER_WORD;\n+  int direction, end, i;\n+  int src_modifies = 0;\n+  int dest_modifies = 0;\n+  int src_volatile = 0;\n+  int dest_volatile = 0;\n+  rtx mem_operand;\n+  \n+  /* Check initial conditions.  */\n+  if (! reload_completed\n+      || mode == QImode || mode == HImode\n+      || ! nonimmediate_operand (dest, mode)\n+      || ! general_operand (src, mode))\n+    abort ();\n+\n+  /* This case is not supported below, and shouldn't be generated.  */\n+  if (GET_CODE (dest) == MEM\n+      && GET_CODE (src) == MEM)\n+    abort ();\n+\n+  /* This case is very very bad after reload, so trap it now.  */\n+  if (GET_CODE (dest) == SUBREG\n+      || GET_CODE (src) == SUBREG)\n+    abort ();\n+\n+  /* The general idea is to copy by words, offsetting the source and\n+     destination.  Normally the least-significant word will be copied\n+     first, but for pre-dec operations it's better to copy the \n+     most-significant word first.  Only one operand can be a pre-dec\n+     or post-inc operand.  \n+\n+     It's also possible that the copy overlaps so that the direction\n+     must be reversed.  */\n+  direction = 1;\n+  \n+  if (GET_CODE (dest) == MEM)\n+    {\n+      mem_operand = XEXP (dest, 0);\n+      dest_modifies = side_effects_p (mem_operand);\n+      dest_volatile = MEM_VOLATILE_P (dest);\n+      if (dest_volatile)\n+\t{\n+\t  dest = copy_rtx (dest);\n+\t  MEM_VOLATILE_P (dest) = 0;\n+\t}\n+    }\n+  else if (GET_CODE (src) == MEM)\n+    {\n+      mem_operand = XEXP (src, 0);\n+      src_modifies = side_effects_p (mem_operand);\n+      src_volatile = MEM_VOLATILE_P (src);\n+      if (src_volatile)\n+\t{\n+\t  src = copy_rtx (src);\n+\t  MEM_VOLATILE_P (src) = 0;\n+\t}\n+    }\n+  else\n+    mem_operand = NULL_RTX;\n+\n+  if (mem_operand == NULL_RTX)\n+    {\n+      if (GET_CODE (src) == REG\n+\t  && GET_CODE (dest) == REG\n+\t  && reg_overlap_mentioned_p (dest, src)\n+\t  && REGNO (dest) > REGNO (src))\n+\tdirection = -1;\n+    }\n+  else if (GET_CODE (mem_operand) == PRE_DEC\n+      || (GET_CODE (mem_operand) == PLUS \n+\t  && GET_CODE (XEXP (mem_operand, 0)) == PRE_DEC))\n+    direction = -1;\n+  else if (GET_CODE (src) == MEM\n+\t   && reg_overlap_mentioned_p (dest, src))\n+    {\n+      int regno;\n+      if (GET_CODE (dest) != REG)\n+\tabort ();\n+      regno = REGNO (dest);\n+      \n+      if (! refers_to_regno_p (regno, regno + num_words, mem_operand, 0))\n+\tabort ();\n+      \n+      if (refers_to_regno_p (regno, regno + 1, mem_operand, 0))\n+\tdirection = -1;\n+      else if (refers_to_regno_p (regno + num_words - 1, regno + num_words,\n+\t\t\t\t  mem_operand, 0))\n+\tdirection = 1;\n+      else\n+\t/* This means something like\n+\t   (set (reg:DI r0) (mem:DI (reg:HI r1)))\n+\t   which we'd need to support by doing the set of the second word\n+\t   last.  */\n+\tabort ();\n+    }\n+\n+  end = direction < 0 ? -1 : num_words;\n+  for (i = direction < 0 ? num_words - 1 : 0; i != end; i += direction)\n+    {\n+      rtx w_src, w_dest;\n+      if (src_modifies)\n+\tw_src = gen_rtx_MEM (word_mode, mem_operand);\n+      else\n+\tw_src = simplify_gen_subreg (word_mode, src, mode, i * UNITS_PER_WORD);\n+      if (src_volatile)\n+\tMEM_VOLATILE_P (w_src) = 1;\n+      if (dest_modifies)\n+\tw_dest = gen_rtx_MEM (word_mode, mem_operand);\n+      else\n+\tw_dest = simplify_gen_subreg (word_mode, dest, mode, \n+\t\t\t\t      i * UNITS_PER_WORD);\n+      if (dest_volatile)\n+\tMEM_VOLATILE_P (w_dest) = 1;\n+      \n+      /* The simplify_subreg calls must always be able to simplify.  */\n+      if (GET_CODE (w_src) == SUBREG\n+\t  || GET_CODE (w_dest) == SUBREG)\n+\tabort ();\n+      \n+      emit_insn (gen_rtx_SET (VOIDmode, w_dest, w_src));\n+    }\n+}\n+\n+/* Expander for the 'move' patterns.  Emit insns to copy a value of\n+   mode MODE from SRC to DEST.  */\n+\n+void \n+stormy16_expand_move (mode, dest, src)\n+     enum machine_mode mode;\n+     rtx dest;\n+     rtx src;\n+{\n+  /* There are only limited immediate-to-memory move instructions.  */\n+  if (! reload_in_progress\n+      && ! reload_completed\n+      && GET_CODE (dest) == MEM\n+      && (GET_CODE (XEXP (dest, 0)) != CONST_INT\n+\t  || ! stormy16_legitimate_address_p (mode, XEXP (dest, 0), 0))\n+      && GET_CODE (src) != REG\n+      && GET_CODE (src) != SUBREG)\n+    src = copy_to_mode_reg (mode, src);\n+\n+  /* Don't emit something we would immediately split.  */\n+  if (reload_completed\n+      && mode != HImode && mode != QImode)\n+    {\n+      stormy16_split_move (mode, dest, src);\n+      return;\n+    }\n+  \n+  emit_insn (gen_rtx_SET (VOIDmode, dest, src));\n+}\n+\n+\f\n+/* Stack Layout:\n+\n+   The stack is laid out as follows:\n+\n+SP->\n+FP->\tLocal variables\n+\tRegister save area (up to 4 words)\n+\tArgument register save area for stdarg (NUM_ARGUMENT_REGISTERS words)\n+\n+AP->\tReturn address (two words)\n+\t9th procedure parameter word\n+\t10th procedure parameter word\n+\t...\n+\tlast procedure parameter word\n+\n+  The frame pointer location is tuned to make it most likely that all\n+  parameters and local variables can be accessed using a load-indexed\n+  instruction.  */\n+\n+/* A structure to describe the layout.  */\n+struct stormy16_stack_layout\n+{\n+  /* Size of the topmost three items on the stack.  */\n+  int locals_size;\n+  int register_save_size;\n+  int stdarg_save_size;\n+  /* Sum of the above items.  */\n+  int frame_size;\n+  /* Various offsets.  */\n+  int first_local_minus_ap;\n+  int sp_minus_fp;\n+  int fp_minus_ap;\n+};\n+\n+/* Does REGNO need to be saved?  */\n+#define REG_NEEDS_SAVE(REGNUM, IFUN)\t\t\t\t\t\\\n+  ((regs_ever_live[REGNUM] && ! call_used_regs[REGNUM])\t\t\t\\\n+   || (IFUN && ! fixed_regs[REGNUM] && call_used_regs[REGNUM]\t\t\\\n+       && (regs_ever_live[REGNUM] || ! current_function_is_leaf)))\n+\n+/* Compute the stack layout.  */\n+struct stormy16_stack_layout \n+stormy16_compute_stack_layout ()\n+{\n+  struct stormy16_stack_layout layout;\n+  int regno;\n+  const int ifun = stormy16_interrupt_function_p ();\n+\n+  layout.locals_size = get_frame_size ();\n+  \n+  layout.register_save_size = 0;\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (REG_NEEDS_SAVE (regno, ifun))\n+      layout.register_save_size += UNITS_PER_WORD;\n+  \n+  if (current_function_varargs || current_function_stdarg)\n+    layout.stdarg_save_size = NUM_ARGUMENT_REGISTERS * UNITS_PER_WORD;\n+  else\n+    layout.stdarg_save_size = 0;\n+  \n+  layout.frame_size = (layout.locals_size \n+\t\t       + layout.register_save_size \n+\t\t       + layout.stdarg_save_size);\n+  \n+  if (current_function_args_size <= 2048 && current_function_args_size != -1)\n+    {\n+      if (layout.frame_size + INCOMING_FRAME_SP_OFFSET \n+\t  + current_function_args_size <= 2048)\n+\tlayout.fp_minus_ap = layout.frame_size + INCOMING_FRAME_SP_OFFSET;\n+      else\n+\tlayout.fp_minus_ap = 2048 - current_function_args_size;\n+    }\n+  else\n+    layout.fp_minus_ap = (layout.stdarg_save_size \n+\t\t\t  + layout.register_save_size\n+\t\t\t  + INCOMING_FRAME_SP_OFFSET);\n+  layout.sp_minus_fp = (layout.frame_size + INCOMING_FRAME_SP_OFFSET \n+\t\t\t- layout.fp_minus_ap);\n+  layout.first_local_minus_ap = layout.sp_minus_fp - layout.locals_size;\n+  return layout;\n+}\n+\n+/* Determine how all the special registers get eliminated.  */\n+int\n+stormy16_initial_elimination_offset (from, to)\n+     int from, to;\n+{\n+  struct stormy16_stack_layout layout;\n+  int result;\n+  \n+  layout = stormy16_compute_stack_layout ();\n+\n+  if (from == FRAME_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n+    result = layout.sp_minus_fp - layout.locals_size;\n+  else if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n+    result = -layout.locals_size;\n+  else if (from == ARG_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n+    result = -layout.fp_minus_ap;\n+  else if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n+    result = -(layout.sp_minus_fp + layout.fp_minus_ap);\n+  else\n+    abort ();\n+\n+  return result;\n+}\n+\n+static rtx\n+emit_addhi3_postreload (dest, src0, src1)\n+     rtx dest;\n+     rtx src0;\n+     rtx src1;\n+{\n+  rtx set, clobber, insn;\n+  \n+  set = gen_rtx_SET (VOIDmode, dest, gen_rtx_PLUS (HImode, src0, src1));\n+  clobber = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (BImode, 16));\n+  insn = emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set, clobber)));\n+  return insn;\n+}\n+\n+/* Called after register allocation to add any instructions needed for the\n+   prologue.  Using a prologue insn is favored compared to putting all of the\n+   instructions in the FUNCTION_PROLOGUE macro, since it allows the scheduler\n+   to intermix instructions with the saves of the caller saved registers.  In\n+   some cases, it might be necessary to emit a barrier instruction as the last\n+   insn to prevent such scheduling.\n+\n+   Also any insns generated here should have RTX_FRAME_RELATED_P(insn) = 1\n+   so that the debug info generation code can handle them properly.  */\n+void\n+stormy16_expand_prologue ()\n+{\n+  struct stormy16_stack_layout layout;\n+  int regno;\n+  rtx insn;\n+  rtx mem_push_rtx;\n+  rtx mem_fake_push_rtx;\n+  const int ifun = stormy16_interrupt_function_p ();\n+  \n+  mem_push_rtx = gen_rtx_POST_INC (Pmode, stack_pointer_rtx);\n+  mem_push_rtx = gen_rtx_MEM (HImode, mem_push_rtx);\n+  mem_fake_push_rtx = gen_rtx_PRE_INC (Pmode, stack_pointer_rtx);\n+  mem_fake_push_rtx = gen_rtx_MEM (HImode, mem_fake_push_rtx);\n+    \n+  layout = stormy16_compute_stack_layout ();\n+\n+  /* Save the argument registers if necessary.  */\n+  if (layout.stdarg_save_size)\n+    for (regno = FIRST_ARGUMENT_REGISTER; \n+\t regno < FIRST_ARGUMENT_REGISTER + NUM_ARGUMENT_REGISTERS;\n+\t regno++)\n+      {\n+\trtx reg = gen_rtx_REG (HImode, regno);\n+\tinsn = emit_move_insn (mem_push_rtx, reg);\n+\tRTX_FRAME_RELATED_P (insn) = 1;\n+\tREG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\t\t\t\t      gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t\t\t   mem_fake_push_rtx,\n+\t\t\t\t\t\t\t   reg),\n+\t\t\t\t\t      REG_NOTES (insn));\n+      }\n+  \n+  /* Push each of the registers to save.  */\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (REG_NEEDS_SAVE (regno, ifun))\n+      {\n+\trtx reg = gen_rtx_REG (HImode, regno);\n+\tinsn = emit_move_insn (mem_push_rtx, reg);\n+\tRTX_FRAME_RELATED_P (insn) = 1;\n+\tREG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\t\t\t\t      gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t\t\t   mem_fake_push_rtx,\n+\t\t\t\t\t\t\t   reg),\n+\t\t\t\t\t      REG_NOTES (insn));\n+      }\n+\n+  /* It's just possible that the SP here might be what we need for\n+     the new FP... */\n+  if (frame_pointer_needed && layout.sp_minus_fp == layout.locals_size)\n+    {\n+      insn = emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n+  /* Allocate space for local variables.  */\n+  if (layout.locals_size)\n+    {\n+      insn = emit_addhi3_postreload (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t     GEN_INT (layout.locals_size));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n+  /* Set up the frame pointer, if required.  */\n+  if (frame_pointer_needed && layout.sp_minus_fp != layout.locals_size)\n+    {\n+      insn = emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      if (layout.sp_minus_fp)\n+\t{\n+\t  insn = emit_addhi3_postreload (hard_frame_pointer_rtx,\n+\t\t\t\t\t hard_frame_pointer_rtx,\n+\t\t\t\t\t GEN_INT (-layout.sp_minus_fp));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+    }\n+}\n+\n+/* Do we need an epilogue at all?  */\n+int\n+direct_return ()\n+{\n+  return (reload_completed \n+\t  && stormy16_compute_stack_layout ().frame_size == 0);\n+}\n+\n+/* Called after register allocation to add any instructions needed for the\n+   epilogue.  Using a epilogue insn is favored compared to putting all of the\n+   instructions in the FUNCTION_PROLOGUE macro, since it allows the scheduler\n+   to intermix instructions with the saves of the caller saved registers.  In\n+   some cases, it might be necessary to emit a barrier instruction as the last\n+   insn to prevent such scheduling.  */\n+\n+void\n+stormy16_expand_epilogue ()\n+{\n+  struct stormy16_stack_layout layout;\n+  rtx mem_pop_rtx;\n+  int regno;\n+  const int ifun = stormy16_interrupt_function_p ();\n+  \n+  mem_pop_rtx = gen_rtx_PRE_DEC (Pmode, stack_pointer_rtx);\n+  mem_pop_rtx = gen_rtx_MEM (HImode, mem_pop_rtx);\n+  \n+  layout = stormy16_compute_stack_layout ();\n+\n+  /* Pop the stack for the locals.  */\n+  if (layout.locals_size)\n+    emit_addhi3_postreload (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t    GEN_INT (- layout.locals_size));\n+\n+  /* Restore any call-saved registers.  */\n+  for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; regno--)\n+    if (REG_NEEDS_SAVE (regno, ifun))\n+      emit_move_insn (gen_rtx_REG (HImode, regno), mem_pop_rtx);\n+  \n+  /* Pop the stack for the stdarg save area.  */\n+  if (layout.stdarg_save_size)\n+    emit_addhi3_postreload (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t    GEN_INT (- layout.stdarg_save_size));\n+\n+  /* Return.  */\n+  if (ifun)\n+    emit_jump_insn (gen_return_internal_interrupt ());\n+  else\n+    emit_jump_insn (gen_return_internal ());\n+}\n+\n+int\n+stormy16_epilogue_uses (regno)\n+     int regno;\n+{\n+  if (reload_completed && call_used_regs[regno])\n+    {\n+      const int ifun = stormy16_interrupt_function_p ();\n+      return REG_NEEDS_SAVE (regno, ifun);\n+    }\n+  return 0;\n+}\n+\f\n+/* Return an updated summarizer variable CUM to advance past an\n+   argument in the argument list.  The values MODE, TYPE and NAMED\n+   describe that argument.  Once this is done, the variable CUM is\n+   suitable for analyzing the *following* argument with\n+   `FUNCTION_ARG', etc.\n+\n+   This function need not do anything if the argument in question was\n+   passed on the stack.  The compiler knows how to track the amount of\n+   stack space used for arguments without any special help.  However,\n+   it makes life easier for stormy16_build_va_list if it does update\n+   the word count.  */\n+CUMULATIVE_ARGS\n+stormy16_function_arg_advance (cum, mode, type, named)\n+     CUMULATIVE_ARGS cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named ATTRIBUTE_UNUSED;\n+{\n+  /* If an argument would otherwise be passed partially in registers,\n+     and partially on the stack, the whole of it is passed on the\n+     stack.  */\n+  if (cum < NUM_ARGUMENT_REGISTERS\n+      && cum + STORMY16_WORD_SIZE (type, mode) > NUM_ARGUMENT_REGISTERS)\n+    cum = NUM_ARGUMENT_REGISTERS;\n+  \n+  cum += STORMY16_WORD_SIZE (type, mode);\n+  \n+  return cum;\n+}\n+\n+/* Do any needed setup for a variadic function.  CUM has not been updated\n+   for the last named argument which has type TYPE and mode MODE.  */\n+void\n+stormy16_setup_incoming_varargs (cum, int_mode, type, pretend_size)\n+     CUMULATIVE_ARGS cum ATTRIBUTE_UNUSED;\n+     int             int_mode ATTRIBUTE_UNUSED;\n+     tree            type ATTRIBUTE_UNUSED;\n+     int *           pretend_size ATTRIBUTE_UNUSED;\n+{\n+}\n+\n+/* Build the va_list type.\n+\n+   For this chip, va_list is a record containing a counter and a pointer.\n+   The counter is of type 'int' and indicates how many bytes\n+   have been used to date.  The pointer indicates the stack position\n+   for arguments that have not been passed in registers.  \n+   To keep the layout nice, the pointer is first in the structure.  */\n+\n+tree\n+stormy16_build_va_list ()\n+{\n+  tree f_1, f_2, record, type_decl;\n+\n+  record = make_lang_type (RECORD_TYPE);\n+  type_decl = build_decl (TYPE_DECL, get_identifier (\"__va_list_tag\"), record);\n+\n+  f_2 = build_decl (FIELD_DECL, get_identifier (\"base\"),\n+\t\t      ptr_type_node);\n+  f_1 = build_decl (FIELD_DECL, get_identifier (\"count\"), \n+\t\t      unsigned_type_node);\n+\n+  DECL_FIELD_CONTEXT (f_1) = record;\n+  DECL_FIELD_CONTEXT (f_2) = record;\n+\n+  TREE_CHAIN (record) = type_decl;\n+  TYPE_NAME (record) = type_decl;\n+  TYPE_FIELDS (record) = f_1;\n+  TREE_CHAIN (f_1) = f_2;\n+\n+  layout_type (record);\n+\n+  return record;\n+}\n+\n+/* Implement the stdarg/varargs va_start macro.  STDARG_P is non-zero if this\n+   is stdarg.h instead of varargs.h.  VALIST is the tree of the va_list\n+   variable to initialize.  NEXTARG is the machine independent notion of the\n+   'next' argument after the variable arguments.  */\n+void\n+stormy16_expand_builtin_va_start (stdarg_p, valist, nextarg)\n+     int stdarg_p ATTRIBUTE_UNUSED;\n+     tree valist;\n+     rtx nextarg ATTRIBUTE_UNUSED;\n+{\n+  tree f_base, f_count;\n+  tree base, count;\n+  tree t;\n+\n+  if (stormy16_interrupt_function_p ())\n+    error (\"cannot use va_start in interrupt function\");\n+  \n+  f_base = TYPE_FIELDS (va_list_type_node);\n+  f_count = TREE_CHAIN (f_base);\n+  \n+  base = build (COMPONENT_REF, TREE_TYPE (f_base), valist, f_base);\n+  count = build (COMPONENT_REF, TREE_TYPE (f_count), valist, f_count);\n+\n+  t = make_tree (TREE_TYPE (base), virtual_incoming_args_rtx);\n+  t = build (PLUS_EXPR, TREE_TYPE (base), t, \n+\t     build_int_2 (INCOMING_FRAME_SP_OFFSET, 0));\n+  t = build (MODIFY_EXPR, TREE_TYPE (base), base, t);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  t = build (MODIFY_EXPR, TREE_TYPE (count), count, \n+\t     build_int_2 (current_function_args_info * UNITS_PER_WORD, 0));\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+}\n+\n+/* Implement the stdarg/varargs va_arg macro.  VALIST is the variable\n+   of type va_list as a tree, TYPE is the type passed to va_arg.  */\n+rtx\n+stormy16_expand_builtin_va_arg (valist, type)\n+     tree valist;\n+     tree type;\n+{\n+  tree f_base, f_count;\n+  tree base, count;\n+  rtx count_rtx, addr_rtx, r;\n+  rtx lab_gotaddr, lab_fromstack;\n+  tree t;\n+  int size, last_reg_count;\n+  tree size_tree, count_plus_size;\n+  \n+  f_base = TYPE_FIELDS (va_list_type_node);\n+  f_count = TREE_CHAIN (f_base);\n+  \n+  base = build (COMPONENT_REF, TREE_TYPE (f_base), valist, f_base);\n+  count = build (COMPONENT_REF, TREE_TYPE (f_count), valist, f_count);\n+\n+  size = PUSH_ROUNDING (int_size_in_bytes (type));\n+  size_tree = round_up (size_in_bytes (type), UNITS_PER_WORD);\n+  \n+  last_reg_count = NUM_ARGUMENT_REGISTERS * UNITS_PER_WORD - size;\n+\n+  count_rtx = expand_expr (count, NULL_RTX, HImode, EXPAND_NORMAL);\n+  lab_gotaddr = gen_label_rtx ();\n+  lab_fromstack = gen_label_rtx ();\n+  addr_rtx = gen_reg_rtx (Pmode);\n+  emit_cmp_and_jump_insns (count_rtx, GEN_INT (last_reg_count),\n+\t\t\t  GTU, const1_rtx, HImode, 1, 1, lab_fromstack);\n+  \n+  t = build (PLUS_EXPR, ptr_type_node, base, count);\n+  r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n+  if (r != addr_rtx)\n+    emit_move_insn (addr_rtx, r);\n+\n+  emit_jump_insn (gen_jump (lab_gotaddr));\n+  emit_barrier ();\n+  emit_label (lab_fromstack);\n+  \n+  /* Arguments larger than a word might need to skip over some\n+     registers, since arguments are either passed entirely in\n+     registers or entirely on the stack.  */\n+  if (size > 2 || size < 0)\n+    {\n+      rtx lab_notransition = gen_label_rtx ();\n+      emit_cmp_and_jump_insns (count_rtx, GEN_INT (NUM_ARGUMENT_REGISTERS \n+\t\t\t\t\t\t   * UNITS_PER_WORD),\n+\t\t\t       GEU, const1_rtx, HImode, 1, 1, \n+\t\t\t       lab_notransition);\n+      \n+      t = build (MODIFY_EXPR, TREE_TYPE (count), count, \n+\t\t build_int_2 (NUM_ARGUMENT_REGISTERS * UNITS_PER_WORD, 0));\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+      \n+      emit_label (lab_notransition);\n+    }\n+\n+  t = build (PLUS_EXPR, sizetype, size_tree,\n+\t     build_int_2 ((- NUM_ARGUMENT_REGISTERS * UNITS_PER_WORD\n+\t\t\t   + INCOMING_FRAME_SP_OFFSET),\n+\t\t\t  -1));\n+  t = build (PLUS_EXPR, TREE_TYPE (count), count, fold (t));\n+  t = build (MINUS_EXPR, TREE_TYPE (base), base, t);\n+  r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n+  if (r != addr_rtx)\n+    emit_move_insn (addr_rtx, r);\n+\t     \n+  emit_label (lab_gotaddr);\n+\n+  count_plus_size = build (PLUS_EXPR, TREE_TYPE (count), count, size_tree);\n+  t = build (MODIFY_EXPR, TREE_TYPE (count), count, count_plus_size);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  return addr_rtx;\n+}\n+\n+/* Initialize the variable parts of a trampoline.  ADDR is an RTX for\n+   the address of the trampoline; FNADDR is an RTX for the address of\n+   the nested function; STATIC_CHAIN is an RTX for the static chain\n+   value that should be passed to the function when it is called.  */\n+void\n+stormy16_initialize_trampoline (addr, fnaddr, static_chain)\n+     rtx addr;\n+     rtx fnaddr;\n+     rtx static_chain;\n+{\n+  rtx reg_addr = gen_reg_rtx (Pmode);\n+  rtx temp = gen_reg_rtx (HImode);\n+  rtx reg_fnaddr = gen_reg_rtx (HImode);\n+  rtx reg_addr_mem;\n+\n+  reg_addr_mem = gen_rtx_MEM (HImode, gen_rtx_POST_INC (Pmode, reg_addr));\n+    \n+  emit_move_insn (reg_addr, addr);\n+  emit_move_insn (temp, GEN_INT (0x3130 | STATIC_CHAIN_REGNUM));\n+  emit_move_insn (reg_addr_mem, temp);\n+  emit_move_insn (temp, static_chain);\n+  emit_move_insn (reg_addr_mem, temp);\n+  emit_move_insn (reg_fnaddr, fnaddr);\n+  emit_move_insn (temp, reg_fnaddr);\n+  emit_insn (gen_andhi3 (temp, temp, GEN_INT (0xFF)));\n+  emit_insn (gen_iorhi3 (temp, temp, GEN_INT (0x0200)));\n+  emit_move_insn (reg_addr_mem, temp);\n+  emit_insn (gen_lshrhi3 (reg_fnaddr, reg_fnaddr, GEN_INT (8)));\n+  emit_move_insn (reg_addr_mem, reg_fnaddr);\n+}\n+\n+/* Create an RTX representing the place where a function returns a\n+   value of data type VALTYPE.  VALTYPE is a tree node representing a\n+   data type.  Write `TYPE_MODE (VALTYPE)' to get the machine mode\n+   used to represent that type.  On many machines, only the mode is\n+   relevant.  (Actually, on most machines, scalar values are returned\n+   in the same place regardless of mode).\n+\n+   If `PROMOTE_FUNCTION_RETURN' is defined, you must apply the same promotion\n+   rules specified in `PROMOTE_MODE' if VALTYPE is a scalar type.\n+\n+   If the precise function being called is known, FUNC is a tree node\n+   (`FUNCTION_DECL') for it; otherwise, FUNC is a null pointer.  This makes it\n+   possible to use a different value-returning convention for specific\n+   functions when all their calls are known.\n+\n+   `FUNCTION_VALUE' is not used for return vales with aggregate data types,\n+   because these are returned in another way.  See `STRUCT_VALUE_REGNUM' and\n+   related macros.  */\n+rtx\n+stormy16_function_value (valtype, func)\n+     tree valtype;\n+     tree func ATTRIBUTE_UNUSED;\n+{\n+  enum machine_mode mode;\n+  mode = TYPE_MODE (valtype);\n+  PROMOTE_MODE (mode, 0, valtype);\n+  return gen_rtx_REG (mode, RETURN_VALUE_REGNUM);\n+}\n+\n+/* Mark functions with SYMBOL_REF_FLAG.  */\n+\n+void\n+stormy16_encode_section_info (decl)\n+     tree decl;\n+{\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    SYMBOL_REF_FLAG (XEXP (DECL_RTL (decl), 0)) = 1;\n+}\n+\f\n+/* Print a memory address as an operand to reference that memory location.  */\n+void\n+stormy16_print_operand_address (file, address)\n+     FILE * file;\n+     rtx    address;\n+{\n+  HOST_WIDE_INT offset;\n+  int pre_dec, post_inc;\n+\n+  /* There are a few easy cases.  */\n+  if (GET_CODE (address) == CONST_INT)\n+    {\n+      fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (address) & 0xFFFF);\n+      return;\n+    }\n+  \n+  if (CONSTANT_P (address) || GET_CODE (address) == CODE_LABEL)\n+    {\n+      output_addr_const (file, address);\n+      return;\n+    }\n+  \n+  /* Otherwise, it's hopefully something of the form \n+     (plus:HI (pre_dec:HI (reg:HI ...)) (const_int ...))\n+  */\n+\n+  if (GET_CODE (address) == PLUS)\n+    {\n+      if (GET_CODE (XEXP (address, 1)) != CONST_INT)\n+\tabort ();\n+      offset = INTVAL (XEXP (address, 1));\n+      address = XEXP (address, 0);\n+    }\n+  else\n+    offset = 0;\n+\n+  pre_dec = (GET_CODE (address) == PRE_DEC);\n+  post_inc = (GET_CODE (address) == POST_INC);\n+  if (pre_dec || post_inc)\n+    address = XEXP (address, 0);\n+  \n+  if (GET_CODE (address) != REG)\n+    abort ();\n+\n+  fputc ('(', file);\n+  if (pre_dec)\n+    fputs (\"--\", file);\n+  fputs (reg_names [REGNO (address)], file);\n+  if (post_inc)\n+    fputs (\"++\", file);\n+  if (offset != 0)\n+    {\n+      fputc (',', file);\n+      fprintf (file, HOST_WIDE_INT_PRINT_DEC, offset);\n+    }\n+  fputc (')', file);\n+}\n+\n+/* Print an operand to a assembler instruction.  */\n+void\n+stormy16_print_operand (file, x, code)\n+     FILE * file;\n+     rtx    x;\n+     int    code;\n+{\n+  switch (code)\n+    {\n+    case 'B':\n+\t/* There is either one bit set, or one bit clear, in X.\n+\t   Print it preceded by '#'.  */\n+      {\n+\tHOST_WIDE_INT xx, l;\n+\n+\tif (GET_CODE (x) == CONST_INT)\n+\t  xx = INTVAL (x);\n+\telse\n+\t  output_operand_lossage (\"`B' operand is not constant\");\n+\t\n+\tl = exact_log2 (xx);\n+\tif (l == -1)\n+\t  l = exact_log2 (~xx);\n+\tif (l == -1)\n+\t  output_operand_lossage (\"`B' operand has multiple bits set\");\n+\t\n+\tfputs (IMMEDIATE_PREFIX, file);\n+\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, l);\n+\treturn;\n+      }\n+\n+    case 'C':\n+      /* Print the symbol without a surrounding @fptr().  */\n+      if (GET_CODE (x) == SYMBOL_REF)\n+\tassemble_name (file, XSTR (x, 0));\n+      else\n+\tstormy16_print_operand_address (file, x);\n+      return;\n+\n+    case 'o':\n+    case 'O':\n+      /* Print the immediate operand less one, preceded by '#'.  \n+         For 'O', negate it first.  */\n+      {\n+\tHOST_WIDE_INT xx;\n+\t\n+\tif (GET_CODE (x) == CONST_INT)\n+\t  xx = INTVAL (x);\n+\telse\n+\t  output_operand_lossage (\"`o' operand is not constant\");\n+\t\n+\tif (code == 'O')\n+\t  xx = -xx;\n+\t\n+\tfputs (IMMEDIATE_PREFIX, file);\n+\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, xx - 1);\n+\treturn;\n+      }\n+\n+    case 0:\n+      /* Handled below.  */\n+      break;\n+      \n+    default:\n+      output_operand_lossage (\"stormy16_print_operand: unknown code\");\n+      return;\n+    }\n+\n+  switch (GET_CODE (x))\n+    {\n+    case REG:\n+      fputs (reg_names [REGNO (x)], file);\n+      break;\n+\n+    case MEM:\n+      stormy16_print_operand_address (file, XEXP (x, 0));\n+      break;\n+\n+    default:\n+      /* Some kind of constant or label; an immediate operand,\n+         so prefix it with '#' for the assembler.  */\n+      fputs (IMMEDIATE_PREFIX, file);\n+      output_addr_const (file, x);\n+      break;\n+    }\n+\n+  return;\n+}\n+\n+\f\n+/* Expander for the `casesi' pattern.\n+   INDEX is the index of the switch statement.\n+   LOWER_BOUND is a CONST_INT that is the value of INDEX corresponding\n+     to the first table entry.\n+   RANGE is the number of table entries.\n+   TABLE is an ADDR_VEC that is the jump table.\n+   DEFAULT_LABEL is the address to branch to if INDEX is outside the\n+     range LOWER_BOUND to LOWER_BOUND+RANGE-1.\n+*/\n+\n+void \n+stormy16_expand_casesi (index, lower_bound, range, table, default_label)\n+     rtx index;\n+     rtx lower_bound;\n+     rtx range;\n+     rtx table;\n+     rtx default_label;\n+{\n+  HOST_WIDE_INT range_i = INTVAL (range);\n+  rtx int_index;\n+\n+  /* This code uses 'br', so it can deal only with tables of size up to\n+     8192 entries.  */\n+  if (range_i >= 8192)\n+    sorry (\"switch statement of size %lu entries too large\", \n+\t   (unsigned long) range_i);\n+\n+  index = expand_binop (SImode, sub_optab, index, lower_bound, index, 0,\n+\t\t\tOPTAB_LIB_WIDEN);\n+  emit_cmp_and_jump_insns (index, range, GTU, NULL_RTX, SImode, 1,\n+\t\t\t   0, default_label);\n+  int_index = gen_lowpart_common (HImode, index);\n+  emit_insn (gen_ashlhi3 (int_index, int_index, GEN_INT (2)));\n+  emit_jump_insn (gen_tablejump_pcrel (int_index, table));\n+}\n+\n+/* Output an ADDR_VEC.  It is output as a sequence of 'jmpf'\n+   instructions, without label or alignment or any other special\n+   constructs.  We know that the previous instruction will be the\n+   `tablejump_pcrel' output above.\n+\n+   TODO: it might be nice to output 'br' instructions if they could\n+   all reach.  */\n+\n+void\n+stormy16_output_addr_vec (file, label, table)\n+     FILE *file;\n+     rtx label ATTRIBUTE_UNUSED;\n+     rtx table;\n+{ \n+  int vlen, idx;\n+  \n+  function_section (current_function_decl);\n+\n+  vlen = XVECLEN (table, 0);\n+  for (idx = 0; idx < vlen; idx++)\n+    {\n+      fputs (\"\\tjmpf \", file);\n+      stormy16_print_operand_address (file, \n+\t\t\t\t      XEXP (XVECEXP (table, 0, idx), 0));\n+      fputc ('\\n', file);\n+    }\n+}\n+\n+\f\n+/* Expander for the `call' patterns.\n+   INDEX is the index of the switch statement.\n+   LOWER_BOUND is a CONST_INT that is the value of INDEX corresponding\n+     to the first table entry.\n+   RANGE is the number of table entries.\n+   TABLE is an ADDR_VEC that is the jump table.\n+   DEFAULT_LABEL is the address to branch to if INDEX is outside the\n+     range LOWER_BOUND to LOWER_BOUND+RANGE-1.\n+*/\n+\n+void \n+stormy16_expand_call (retval, dest, counter)\n+     rtx retval;\n+     rtx dest;\n+     rtx counter;\n+{\n+  rtx call, temp;\n+  enum machine_mode mode;\n+\n+  if (GET_CODE (dest) != MEM)\n+    abort ();\n+  dest = XEXP (dest, 0);\n+\n+  if (! CONSTANT_P (dest)\n+      && GET_CODE (dest) != REG)\n+    dest = force_reg (Pmode, dest);\n+  \n+  if (retval == NULL)\n+    mode = VOIDmode;\n+  else\n+    mode = GET_MODE (retval);\n+\n+  call = gen_rtx_CALL (mode, gen_rtx_MEM (FUNCTION_MODE, dest),\n+\t\t       counter);\n+  if (retval)\n+    call = gen_rtx_SET (VOIDmode, retval, call);\n+  \n+  if (! CONSTANT_P (dest))\n+    {\n+      temp = gen_reg_rtx (HImode);\n+      emit_move_insn (temp, const0_rtx);\n+    }\n+  else\n+    temp = const0_rtx;\n+  \n+  call = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, call, \n+\t\t\t\t\t\tgen_rtx_USE (VOIDmode, temp)));\n+  emit_call_insn (call);\n+}\n+\f\n+/* Expanders for multiword computational operations.  */\n+\n+/* Expander for arithmetic operations; emit insns to compute\n+\n+   (set DEST (CODE:MODE SRC0 SRC1))\n+   \n+   using CARRY as a temporary.  When CODE is COMPARE, a branch\n+   template is generated (this saves duplicating code in\n+   stormy16_split_cbranch).  */\n+\n+void \n+stormy16_expand_arith (mode, code, dest, src0, src1, carry)\n+     enum machine_mode mode;\n+     enum rtx_code code;\n+     rtx dest;\n+     rtx src0;\n+     rtx src1;\n+     rtx carry;\n+{\n+  int num_words = GET_MODE_BITSIZE (mode) / BITS_PER_WORD;\n+  int i;\n+  int firstloop = 1;\n+\n+  if (code == NEG)\n+    {\n+      rtx zero_reg = gen_reg_rtx (word_mode);\n+      emit_move_insn (zero_reg, src0);\n+      src0 = zero_reg;\n+    }\n+  \n+  for (i = 0; i < num_words; i++)\n+    {\n+      rtx w_src0, w_src1, w_dest;\n+      rtx insn;\n+      \n+      if (code == NEG)\n+\tw_src0 = src0;\n+      else\n+\tw_src0 = simplify_gen_subreg (word_mode, src0, mode, \n+\t\t\t\t      i * UNITS_PER_WORD);\n+      w_src1 = simplify_gen_subreg (word_mode, src1, mode, i * UNITS_PER_WORD);\n+      w_dest = simplify_gen_subreg (word_mode, dest, mode, i * UNITS_PER_WORD);\n+\n+      switch (code)\n+\t{\n+\tcase PLUS:\n+\t  if (firstloop\n+\t      && GET_CODE (w_src1) == CONST_INT && INTVAL (w_src1) == 0)\n+\t    continue;\n+\t  \n+\t  if (firstloop)\n+\t    insn = gen_addchi4 (w_dest, w_src0, w_src1, carry);\n+\t  else\n+\t    insn = gen_addchi5 (w_dest, w_src0, w_src1, carry, carry);\n+\t  break;\n+\n+\tcase NEG:\n+\tcase MINUS:\n+\tcase COMPARE:\n+\t  if (code == COMPARE && i == num_words - 1)\n+\t    {\n+\t      rtx branch, sub, clobber, sub_1;\n+\t      \n+\t      sub_1 = gen_rtx_MINUS (HImode, w_src0, \n+\t\t\t\t     gen_rtx_ZERO_EXTEND (HImode, carry));\n+\t      sub = gen_rtx_SET (VOIDmode, w_dest,\n+\t\t\t\t gen_rtx_MINUS (HImode, sub_1, w_src1));\n+\t      clobber = gen_rtx_CLOBBER (VOIDmode, carry);\n+\t      branch = gen_rtx_SET (VOIDmode, pc_rtx,\n+\t\t\t\t    gen_rtx_IF_THEN_ELSE (VOIDmode,\n+\t\t\t\t\t\t\t  gen_rtx_EQ (HImode,\n+\t\t\t\t\t\t\t\t      sub_1,\n+\t\t\t\t\t\t\t\t      w_src1),\n+\t\t\t\t\t\t\t  pc_rtx,\n+\t\t\t\t\t\t\t  pc_rtx));\n+\t      insn = gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\t       gen_rtvec (3, branch, sub, clobber));\n+\t    }\n+\t  else if (firstloop\n+\t\t   && code != COMPARE\n+\t\t   && GET_CODE (w_src1) == CONST_INT && INTVAL (w_src1) == 0)\n+\t    continue;\n+\t  else if (firstloop)\n+\t    insn = gen_subchi4 (w_dest, w_src0, w_src1, carry);\n+\t  else\n+\t    insn = gen_subchi5 (w_dest, w_src0, w_src1, carry, carry);\n+\t  break;\n+\n+\tcase IOR:\n+\tcase XOR:\n+\tcase AND:\n+\t  if (GET_CODE (w_src1) == CONST_INT \n+\t      && INTVAL (w_src1) == -(code == AND))\n+\t    continue;\n+\t  \n+\t  insn = gen_rtx_SET (VOIDmode, w_dest, gen_rtx (code, mode,\n+\t\t\t\t\t\t\t w_src0, w_src1));\n+\t  break;\n+\n+\tcase NOT:\n+\t  insn = gen_rtx_SET (VOIDmode, w_dest, gen_rtx_NOT (mode, w_src0));\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+      \n+      firstloop = 0;\n+      emit (insn);\n+    }\n+}\n+\n+/* Return 1 if OP is a shift operator.  */\n+\n+int\n+shift_operator (op, mode)\n+     register rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  return (code == ASHIFT\n+\t  || code == ASHIFTRT\n+\t  || code == LSHIFTRT);\n+}\n+\n+/* The shift operations are split at output time for constant values;\n+   variable-width shifts get handed off to a library routine.  \n+\n+   Generate an output string to do (set X (CODE:MODE X SIZE_R))\n+   SIZE_R will be a CONST_INT, X will be a hard register.  */\n+\n+const char * \n+stormy16_output_shift (mode, code, x, size_r, temp)\n+     enum machine_mode mode;\n+     enum rtx_code code;\n+     rtx x;\n+     rtx size_r;\n+     rtx temp;\n+{\n+  HOST_WIDE_INT size;\n+  const char *r0, *r1, *rt;\n+  static char r[64];\n+\n+  if (GET_CODE (size_r) != CONST_INT\n+      || GET_CODE (x) != REG\n+      || mode != SImode)\n+    abort ();\n+  size = INTVAL (size_r) & (GET_MODE_BITSIZE (mode) - 1);\n+\n+  if (size == 0)\n+    return \"\";\n+\n+  r0 = reg_names [REGNO (x)];\n+  r1 = reg_names [REGNO (x) + 1];\n+  rt = reg_names [REGNO (temp)];\n+\n+  /* For shifts of size 1, we can use the rotate instructions.  */\n+  if (size == 1)\n+    {\n+      switch (code)\n+\t{\n+\tcase ASHIFT:\n+\t  sprintf (r, \"shl %s,#1 | rlc %s,#1\", r0, r1);\n+\t  break;\n+\tcase ASHIFTRT:\n+\t  sprintf (r, \"asr %s,#1 | rrc %s,#1\", r1, r0);\n+\t  break;\n+\tcase LSHIFTRT:\n+\t  sprintf (r, \"shr %s,#1 | rrc %s,#1\", r1, r0);\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      return r;\n+    }\n+  \n+  /* For large shifts, there are easy special cases.  */\n+  if (size == 16)\n+    {\n+      switch (code)\n+\t{\n+\tcase ASHIFT:\n+\t  sprintf (r, \"mov %s,%s | mov %s,#0\", r1, r0, r0);\n+\t  break;\n+\tcase ASHIFTRT:\n+\t  sprintf (r, \"mov %s,%s | asr %s,#15\", r0, r1, r1);\n+\t  break;\n+\tcase LSHIFTRT:\n+\t  sprintf (r, \"mov %s,%s | mov %s,#0\", r0, r1, r1);\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      return r;\n+    }\n+  if (size > 16)\n+    {\n+      switch (code)\n+\t{\n+\tcase ASHIFT:\n+\t  sprintf (r, \"mov %s,%s | mov %s,#0 | shl %s,#%d\", \n+\t\t   r1, r0, r0, r1, (int) size - 16);\n+\t  break;\n+\tcase ASHIFTRT:\n+\t  sprintf (r, \"mov %s,%s | asr %s,#15 | asr %s,#%d\", \n+\t\t   r0, r1, r1, r0, (int) size - 16);\n+\t  break;\n+\tcase LSHIFTRT:\n+\t  sprintf (r, \"mov %s,%s | mov %s,#0 | shr %s,#%d\", \n+\t\t   r0, r1, r1, r0, (int) size - 16);\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      return r;\n+    }\n+\n+  /* For the rest, we have to do more work.  In particular, we\n+     need a temporary.  */\n+  switch (code)\n+    {\n+    case ASHIFT:\n+      sprintf (r, \n+\t       \"mov %s,%s | shl %s,#%d | shl %s,#%d | shr %s,#%d | or %s,%s\", \n+\t       rt, r0, r0, (int) size, r1, (int) size, rt, (int) 16-size,\n+\t       r1, rt);\n+      break;\n+    case ASHIFTRT:\n+      sprintf (r, \n+\t       \"mov %s,%s | asr %s,#%d | shr %s,#%d | shl %s,#%d | or %s,%s\", \n+\t       rt, r1, r1, (int) size, r0, (int) size, rt, (int) 16-size,\n+\t       r0, rt);\n+      break;\n+    case LSHIFTRT:\n+      sprintf (r, \n+\t       \"mov %s,%s | shr %s,#%d | shr %s,#%d | shl %s,#%d | or %s,%s\", \n+\t       rt, r1, r1, (int) size, r0, (int) size, rt, (int) 16-size,\n+\t       r0, rt);\n+      break;\n+    default:\n+      abort ();\n+    }\n+  return r;\n+}\n+\f\n+/* Attribute handling.  */\n+\n+/* Return nonzero if the function is an interrupt function.  */\n+int\n+stormy16_interrupt_function_p ()\n+{\n+  tree attributes;\n+  \n+  /* The dwarf2 mechanism asks for INCOMING_FRAME_SP_OFFSET before\n+     any functions are declared, which is demonstrably wrong, but\n+     it is worked around here.  FIXME.  */\n+  if (!cfun)\n+    return 0;\n+\n+  attributes = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));\n+  return lookup_attribute (\"interrupt\", attributes) != NULL_TREE;\n+}\n+\n+/* If defined, a C function which returns nonzero if IDENTIFIER\n+   with arguments ARGS is a valid machine specific attribute for TYPE.\n+   The attributes in ATTRIBUTES have previously been assigned to TYPE.  */\n+#undef TARGET_VALID_TYPE_ATTRIBUTE\n+#define TARGET_VALID_TYPE_ATTRIBUTE stormy16_valid_type_attribute\n+static int stormy16_valid_type_attribute PARAMS ((tree TYPE,\n+\t\t\t\t\t\t  tree ATTRIBUTES,\n+\t\t\t\t\t\t  tree IDENTIFIER,\n+\t\t\t\t\t\t  tree ARGS));\n+\n+static int\n+stormy16_valid_type_attribute (type, attributes, identifier, args)\n+     tree type;\n+     tree attributes ATTRIBUTE_UNUSED;\n+     tree identifier;\n+     tree args ATTRIBUTE_UNUSED;\n+{\n+  if (TREE_CODE (type) != FUNCTION_TYPE)\n+    return 0;\n+  \n+  if (is_attribute_p (\"interrupt\", identifier))\n+    return 1;\n+\n+  return 0;\n+}\n+\f\n+struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "7310e6cdc1beb3d9e0251c1fe9a10bb1d5597b67", "filename": "gcc/config/stormy16/stormy16.h", "status": "added", "additions": 5355, "deletions": 0, "changes": 5355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b58290fe6d467cf8d1c4f72e35c308218728b3b/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b58290fe6d467cf8d1c4f72e35c308218728b3b/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=4b58290fe6d467cf8d1c4f72e35c308218728b3b"}, {"sha": "83860b46eec097903dcd4204a829df9327128d2b", "filename": "gcc/config/stormy16/stormy16.md", "status": "added", "additions": 971, "deletions": 0, "changes": 971, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b58290fe6d467cf8d1c4f72e35c308218728b3b/gcc%2Fconfig%2Fstormy16%2Fstormy16.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b58290fe6d467cf8d1c4f72e35c308218728b3b/gcc%2Fconfig%2Fstormy16%2Fstormy16.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.md?ref=4b58290fe6d467cf8d1c4f72e35c308218728b3b", "patch": "@@ -0,0 +1,971 @@\n+;; STORMY16 Machine description template\n+;; Copyright (C) 1997, 1998, 1999, 2001 Free Software Foundation, Inc.\n+;; Contributed by Red Hat, Inc.\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: Attributes\n+;; ::\n+;; ::::::::::::::::::::\n+\n+; Categorize branches for the conditional in the length attribute.\n+(define_attr \"branch_class\" \"notdirectbranch,br12,bcc12,bcc8p2,bcc8p4\" \n+    (const_string \"notdirectbranch\"))\n+\n+; The length of an instruction, used for branch shortening.\n+(define_attr \"length\" \"\" \n+  (cond\n+   [(eq_attr \"branch_class\" \"br12\")\n+     (if_then_else (and (ge (minus (match_dup 0) (pc)) (const_int -2046))\n+\t\t\t(lt (minus (match_dup 0) (pc)) (const_int 2048)))\n+\t\t   (const_int 2)\n+\t\t   (const_int 4))\n+    (eq_attr \"branch_class\" \"bcc12\")\n+     (if_then_else (and (ge (minus (match_dup 0) (pc)) (const_int -2044))\n+\t\t\t(lt (minus (match_dup 0) (pc)) (const_int 2048)))\n+\t\t   (const_int 4)\n+\t\t   (const_int 8))\n+    (eq_attr \"branch_class\" \"bcc8p2\")\n+     (if_then_else (and (ge (minus (match_dup 0) (pc)) (const_int -124))\n+\t\t\t(lt (minus (match_dup 0) (pc)) (const_int 128)))\n+\t\t   (const_int 4)\n+\t\t   (const_int 8))\n+    (eq_attr \"branch_class\" \"bcc8p4\")\n+     (if_then_else (and (ge (minus (match_dup 0) (pc)) (const_int -122))\n+\t\t\t(lt (minus (match_dup 0) (pc)) (const_int 128)))\n+\t\t   (const_int 6)\n+\t\t   (const_int 10))]\n+   (const_int 2)))\n+\n+; The operand which determines the setting of Rpsw.\n+; The numbers indicate the operand number,\n+; 'clobber' indicates it is changed in some unspecified way\n+; 'nop' means it is not changed.\n+(define_attr \"psw_operand\" \"clobber,nop,0,1,2,3,4\" (const_string \"0\"))\n+\n+(define_asm_attributes [(set_attr \"length\" \"4\")\n+\t\t\t(set_attr \"psw_operand\" \"clobber\")])\n+\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: Moves\n+;; ::\n+;; ::::::::::::::::::::\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"{ stormy16_expand_move (QImode, operands[0], operands[1]); DONE; }\")\n+\n+(define_insn \"*movqi_internal\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,Q,r,m,e,e,T,r,S\")\n+\t(match_operand:QI 1 \"general_operand\"       \"r,r,R,e,m,i,i,i,i\"))]\n+  \"\"\n+  \"@\n+   mov %0,%1\n+   push %1\n+   pop %0\n+   mov.b %0,%1\n+   mov.b %0,%1\n+   mov %0,%1\n+   mov Rx,%1\n+   mov %0,%1\n+   mov.b %0,%1\"\n+  [(set_attr_alternative \"length\" \n+\t     [(const_int 2)\n+\t      (const_int 2)\n+\t      (const_int 2)\n+\t      (if_then_else (match_operand:QI 0 \"short_memory_operand\" \"\")\n+\t\t\t    (const_int 2)\n+\t\t\t    (const_int 4))\n+\t      (if_then_else (match_operand:QI 1 \"short_memory_operand\" \"\")\n+\t\t\t    (const_int 2)\n+\t\t\t    (const_int 4))\n+\t      (const_int 2)\n+\t      (const_int 2)\n+\t      (const_int 4)\n+\t      (const_int 4)])\n+   (set_attr \"psw_operand\" \"0,nop,nop,0,0,0,nop,0,nop\")])\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"{ stormy16_expand_move (HImode, operands[0], operands[1]); DONE; }\")\n+\n+(define_insn \"*movhi_internal\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,Q,r,m,e,e,T,r,S\")\n+\t(match_operand:HI 1 \"general_operand\"       \"r,r,R,e,m,L,L,i,i\"))]\n+  \"\"\n+  \"@\n+   mov %0,%1\n+   push %1\n+   pop %0\n+   mov.w %0,%1\n+   mov.w %0,%1\n+   mov.w %0,%1\n+   mov.w Rx,%1\n+   mov.w %0,%1\n+   mov.w %0,%1\"\n+  [(set_attr_alternative \"length\" \n+\t     [(const_int 2)\n+\t      (const_int 2)\n+\t      (const_int 2)\n+\t      (if_then_else (match_operand:QI 0 \"short_memory_operand\" \"\")\n+\t\t\t    (const_int 2)\n+\t\t\t    (const_int 4))\n+\t      (if_then_else (match_operand:QI 1 \"short_memory_operand\" \"\")\n+\t\t\t    (const_int 2)\n+\t\t\t    (const_int 4))\n+\t      (const_int 2)\n+\t      (const_int 2)\n+\t      (const_int 4)\n+\t      (const_int 4)])\n+   (set_attr \"psw_operand\" \"0,nop,nop,0,0,0,nop,0,nop\")])\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"{ stormy16_expand_move (SImode, operands[0], operands[1]); DONE; }\")\n+\n+(define_insn_and_split \"*movsi_internal\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,Q,r,m,e,&e,e,r,S\")\n+\t(match_operand:SI 1 \"general_operand\"       \"r,r,R,e,o, V,L,i,i\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(pc)]\n+  \"{ stormy16_split_move (SImode, operands[0], operands[1]); DONE; }\"\n+  [(set_attr_alternative \"length\" \n+\t     [(const_int 4)\n+\t      (const_int 4)\n+\t      (const_int 4)\n+\t      (if_then_else (match_operand:QI 0 \"short_memory_operand\" \"\")\n+\t\t\t    (const_int 6)\n+\t\t\t    (const_int 8))\n+\t      (if_then_else (match_operand:QI 1 \"short_memory_operand\" \"\")\n+\t\t\t    (const_int 6)\n+\t\t\t    (const_int 8))\n+\t      (if_then_else (match_operand:QI 1 \"short_memory_operand\" \"\")\n+\t\t\t    (const_int 6)\n+\t\t\t    (const_int 8))\n+\t      (const_int 4)\n+\t      (const_int 8)\n+\t      (const_int 8)])])\n+\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: Conversions\n+;; ::\n+;; ::::::::::::::::::::\n+\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:HI (match_operand:QI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"cbw %0\")\n+\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: Bit field extraction\n+;; ::\n+;; ::::::::::::::::::::\n+\n+;; Extract an unsigned bit field\n+;(define_insn \"extzv\"\n+;  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+;\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+;\t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")\n+;\t\t\t (match_operand:SI 3 \"const_int_operand\" \"n\")))]\n+;  \"\"\n+;  \"extzv %0,%1,%2,%3\"\n+;  [(set_attr \"length\" \"4\")])\n+\n+;; Insert a bit field\n+;(define_insn \"insv\"\n+;  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n+;\t\t\t (match_operand:SI 1 \"const_int_operand\" \"n\")\n+;\t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\"))\n+;\t(match_operand:SI 3 \"nonmemory_operand\" \"ri\"))]\n+;  \"\"\n+;  \"insv %0,%1,%2,%3\"\n+;  [(set_attr \"length\" \"4\")])\n+\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: 16 bit Integer arithmetic\n+;; ::\n+;; ::::::::::::::::::::\n+\n+;; Addition\n+; Operand 3 is marked earlyclobber because that helps reload\n+; to generate better code---this pattern will never need the\n+; carry register as an input, and some output reloads or input\n+; reloads might need to use it.  In fact, without the '&' reload\n+; will fail in some cases.\n+(define_insn \"addhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,T,T,r,r,r\")\n+\t(plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,0,0,0,0\")\n+\t\t (match_operand:HI 2 \"nonmemory_operand\" \"O,P,L,M,Ir,N,i\")))\n+   (clobber (match_scratch:BI 3 \"=X,X,&y,&y,&y,&y,&y\"))]\n+  \"\"\n+  \"@\n+   inc %0,%o2\n+   dec %0,%O2\n+   add Rx,%2\n+   sub Rx,#%n2\n+   add %0,%2\n+   sub %0,#%n2\n+   add %0,%2\"\n+  [(set_attr \"length\" \"2,2,2,2,2,2,4\")])\n+\n+; Reload can generate addition operations.  The SECONDARY_RELOAD_CLASS\n+; macro causes it to allocate the carry register; this pattern\n+; shows it how to place the register in RTL to make the addition work.\n+(define_expand \"reload_inhi\"\n+  [(parallel [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t\t   (match_operand:HI 1 \"stormy16_carry_plus_operand\" \"\"))\n+\t      (clobber (match_operand:BI 2 \"\" \"=&y\"))])]\n+  \"\"\n+  \"if (! rtx_equal_p (operands[0], XEXP (operands[1], 0)))\n+    {\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[0], XEXP (operands[1], 0)));\n+      operands[1] = gen_rtx_PLUS (GET_MODE (operands[1]), operands[0],\n+\t\t\t\t  XEXP (operands[1], 1));\n+    }\n+ \")\n+\n+(define_insn \"addchi4\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=T,r,r\")\n+\t(plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0\")\n+\t\t (match_operand:HI 2 \"nonmemory_operand\" \"L,Ir,i\")))\n+   (set (match_operand:BI 3 \"register_operand\" \"=y,y,y\")\n+        (truncate:BI (lshiftrt:SI (plus:SI (zero_extend:SI (match_dup 1))\n+\t\t\t\t\t   (zero_extend:SI (match_dup 2)))\n+\t\t\t\t  (const_int 16))))]\n+  \"\"\n+  \"@\n+   add Rx,%2\n+   add %0,%2\n+   add %0,%2\"\n+  [(set_attr \"length\" \"2,2,4\")])\n+\n+(define_insn \"addchi5\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=T,r,r\")\n+\t(plus:HI (plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0\")\n+\t\t\t  (zero_extend:HI (match_operand:BI 3 \n+\t\t\t\t\t\t\t    \"register_operand\"\n+\t\t\t\t\t\t\t    \"y,y,y\")))\n+\t\t (match_operand:HI 2 \"nonmemory_operand\" \"L,Ir,i\")))\n+   (set (match_operand:BI 4 \"register_operand\" \"=y,y,y\") \n+        (truncate:BI (lshiftrt:SI (plus:SI (plus:SI \n+\t\t\t\t\t    (zero_extend:SI (match_dup 1))\n+\t\t\t\t\t    (zero_extend:SI (match_dup 3)))\n+\t\t\t\t\t   (zero_extend:SI (match_dup 2)))\n+\t\t\t\t  (const_int 16))))]\n+  \"\"\n+  \"@\n+   adc Rx,%2\n+   adc %0,%2\n+   adc %0,%2\"\n+  [(set_attr \"length\" \"2,2,4\")])\n+\n+;; Subtraction\n+; Operand 3 is marked earlyclobber because that helps reload\n+; to generate better code---this pattern will never need the\n+; carry register as an input, and some output reloads or input\n+; reloads might need to use it.  In fact, without the '&' reload\n+; will fail in some cases.\n+(define_insn \"subhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,T,T,r,r,r\")\n+\t(minus:HI (match_operand:HI 1 \"register_operand\" \"0,0,0,0,0,0,0\")\n+\t\t  (match_operand:HI 2 \"nonmemory_operand\" \"O,P,L,M,rI,M,i\")))\n+   (clobber (match_scratch:BI 3 \"=X,X,&y,&y,&y,&y,&y\"))]\n+  \"\"\n+  \"@\n+   dec %0,%o2\n+   inc %0,%O2\n+   sub Rx,%2\n+   add Rx,#%n2\n+   sub %0,%2\n+   add %0,#%n2\n+   sub %0,%2\"\n+  [(set_attr \"length\" \"2,2,2,2,2,2,4\")])\n+\n+(define_insn \"subchi4\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=T,r,r\")\n+\t(minus:HI (match_operand:HI 1 \"register_operand\" \"0,0,0\")\n+\t\t  (match_operand:HI 2 \"nonmemory_operand\" \"L,Ir,i\")))\n+   (set (match_operand:BI 3 \"register_operand\" \"=y,y,y\") \n+        (truncate:BI (lshiftrt:SI (minus:SI (zero_extend:SI (match_dup 1))\n+\t\t\t\t\t    (zero_extend:SI (match_dup 2)))\n+\t\t\t\t  (const_int 16))))]\n+  \"\"\n+  \"@\n+   sub Rx,%2\n+   sub %0,%2\n+   sub %0,%2\"\n+  [(set_attr \"length\" \"2,2,4\")])\n+\n+(define_insn \"subchi5\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=T,r,r\")\n+\t(minus:HI (minus:HI (match_operand:HI 1 \"register_operand\" \"0,0,0\")\n+\t\t\t  (zero_extend:HI (match_operand:BI 3 \n+\t\t\t\t\t\t\t    \"register_operand\"\n+\t\t\t\t\t\t\t    \"y,y,y\")))\n+\t\t (match_operand:HI 2 \"nonmemory_operand\" \"L,Ir,i\")))\n+   (set (match_operand:BI 4 \"register_operand\" \"=y,y,y\") \n+        (truncate:BI (lshiftrt:SI (minus:SI (minus:SI \n+\t\t\t\t\t     (zero_extend:SI (match_dup 1))\n+\t\t\t\t\t     (zero_extend:SI (match_dup 3)))\n+\t\t\t\t\t    (zero_extend:SI (match_dup 2)))\n+\t\t\t\t  (const_int 16))))]\n+  \"\"\n+  \"@\n+   sbc Rx,%2\n+   sbc %0,%2\n+   sbc %0,%2\"\n+  [(set_attr \"length\" \"2,2,4\")])\n+\n+; Basic multiplication\n+(define_insn \"mulhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n+\t(mult:HI (match_operand:HI 1 \"register_operand\" \"%a\")\n+\t\t (match_operand:HI 2 \"register_operand\" \"c\")))\n+   (clobber (match_scratch:HI 3 \"=b\"))\n+   ]\n+  \"\"\n+  \"mul\"\n+  [(set_attr \"psw_operand\" \"nop\")])\n+\n+;; Unsigned multiplication producing 64 bit results from 32 bit inputs\n+; The constraint on operand 0 is 't' because it is actually two regs\n+; long, and both regs must match the constraint.\n+(define_insn \"umulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=t\")\n+\t(mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"%a\"))\n+\t\t (zero_extend:SI (match_operand:HI 2 \"register_operand\" \"c\"))))\n+   ]\n+  \"\"\n+  \"mul\"\n+  [(set_attr \"psw_operand\" \"nop\")])\n+\n+;; Unsigned division giving both quotient and remainder\n+(define_insn \"udivmodhi4\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n+\t(div:HI (match_operand:HI 1 \"register_operand\" \"a\")\n+\t\t(match_operand:HI 2 \"register_operand\" \"c\")))\n+   (set (match_operand:HI 3 \"register_operand\" \"=b\")\n+\t(mod:HI (match_dup 1)\n+\t\t(match_dup 2)))]\n+  \"\"\n+  \"div\"\n+  [(set_attr \"psw_operand\" \"nop\")])\n+\n+;; Negation\n+\n+(define_expand \"neghi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(not:HI (match_operand:HI 1 \"register_operand\" \"\")))\n+   (parallel [(set (match_dup 0) (plus:HI (match_dup 0) (const_int 1)))\n+\t      (clobber (match_scratch:BI 3 \"\"))])]\n+  \"\"\n+  \"\")\n+\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: 16 bit Integer Shifts and Rotates\n+;; ::\n+;; ::::::::::::::::::::\n+\n+;; Arithmetic Shift Left\n+(define_insn \"ashlhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(ashift:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:HI 2 \"nonmemory_operand\" \"ri\")))\n+   (clobber (match_scratch:BI 3 \"=y\"))]\n+  \"\"\n+  \"shl %0,%2\")\n+\n+;; Arithmetic Shift Right\n+(define_insn \"ashrhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:HI 2 \"nonmemory_operand\" \"ri\")))\n+   (clobber (match_scratch:BI 3 \"=y\"))]\n+  \"\"\n+  \"asr %0,%2\")\n+\n+;; Logical Shift Right\n+(define_insn \"lshrhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:HI 2 \"nonmemory_operand\" \"ri\")))\n+   (clobber (match_scratch:BI 3 \"=y\"))]\n+  \"\"\n+  \"shr %0,%2\")\n+\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: 16 Bit Integer Logical operations\n+;; ::\n+;; ::::::::::::::::::::\n+\n+;; Logical AND, 16 bit integers\n+(define_insn \"andhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=T,r,r,r\")\n+\t(and:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,0\")\n+\t\t(match_operand:HI 2 \"nonmemory_operand\" \"L,r,K,i\")))]\n+  \"\"\n+  \"@\n+   and Rx,%2\n+   and %0,%2\n+   clr1 %0,%B2\n+   and %0,%2\"\n+  [(set_attr \"length\" \"2,2,2,4\")])\n+\n+;; Inclusive OR, 16 bit integers\n+(define_insn \"iorhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=T,r,r,r\")\n+\t(ior:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,0\")\n+\t\t(match_operand:HI 2 \"nonmemory_operand\" \"L,r,J,i\")))]\n+  \"\"\n+  \"@\n+   or Rx,%2\n+   or %0,%2\n+   set1 %0,%B2\n+   or %0,%2\"\n+  [(set_attr \"length\" \"2,2,2,4\")])\n+\n+;; Exclusive OR, 16 bit integers\n+(define_insn \"xorhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=T,r,r\")\n+\t(xor:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0\")\n+\t\t(match_operand:HI 2 \"nonmemory_operand\" \"L,r,i\")))]\n+  \"\"\n+  \"@\n+   xor Rx,%2\n+   xor %0,%2\n+   xor %0,%2\"\n+  [(set_attr \"length\" \"2,2,4\")])\n+\n+;; One's complement, 16 bit integers\n+(define_insn \"one_cmplhi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(not:HI (match_operand:HI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"not %0\")\n+\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: 32 bit Integer arithmetic\n+;; ::\n+;; ::::::::::::::::::::\n+\n+;; Addition\n+(define_insn_and_split \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"ri\")))\n+   (clobber (match_scratch:BI 3 \"=y\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(pc)]\n+  \"{ stormy16_expand_arith (SImode, PLUS, operands[0], operands[1],\n+\t\t\t    operands[2], operands[3]); DONE; } \"\n+  [(set_attr \"length\" \"4\")])\n+\n+;; Subtraction\n+(define_insn_and_split \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"ri\")))\n+   (clobber (match_scratch:BI 3 \"=y\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(pc)]\n+  \"{ stormy16_expand_arith (SImode, MINUS, operands[0], operands[1],\n+\t\t\t    operands[2], operands[3]); DONE; } \"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_expand \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(neg:SI (match_operand:SI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"{ stormy16_expand_arith (SImode, NEG, operands[0], const0_rtx,\n+\t\t\t    operands[1], gen_reg_rtx (BImode)); DONE; }\")\n+\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: 32 bit Integer Shifts and Rotates\n+;; ::\n+;; ::::::::::::::::::::\n+\n+;; Arithmetic Shift Left\n+(define_expand \"ashlsi3\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (ashift:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t      (match_operand:SI 2 \"const_int_operand\" \"\")))\n+\t      (clobber (match_dup 3))\n+\t      (clobber (match_dup 4))])]\n+  \"\"\n+  \" if (! const_int_operand (operands[2], SImode)) FAIL;\n+  operands[3] = gen_reg_rtx (BImode); operands[4] = gen_reg_rtx (HImode); \")\n+\n+;; Arithmetic Shift Right\n+(define_expand \"ashrsi3\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t        (match_operand:SI 2 \"const_int_operand\" \"\")))\n+\t      (clobber (match_dup 3))\n+\t      (clobber (match_dup 4))])]\n+  \"\"\n+  \" if (! const_int_operand (operands[2], SImode)) FAIL;\n+  operands[3] = gen_reg_rtx (BImode); operands[4] = gen_reg_rtx (HImode); \")\n+\n+;; Logical Shift Right\n+(define_expand \"lshrsi3\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t        (match_operand:SI 2 \"const_int_operand\" \"\")))\n+\t      (clobber (match_dup 3))\n+\t      (clobber (match_dup 4))])]\n+  \"\"\n+  \" if (! const_int_operand (operands[2], SImode)) FAIL;\n+  operands[3] = gen_reg_rtx (BImode); operands[4] = gen_reg_rtx (HImode); \")\n+\n+(define_insn \"*shiftsi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(match_operator:SI 5 \"shift_operator\"\n+\t [(match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t  (match_operand:SI 2 \"const_int_operand\" \"U,n\")]))\n+   (clobber (match_operand:BI 3 \"register_operand\" \"=y,y\"))\n+   (clobber (match_operand:HI 4 \"\" \"=X,r\"))]\n+  \"\"\n+  \"* return stormy16_output_shift (SImode, GET_CODE (operands[5]), \n+\t\t\t\t   operands[0], operands[2], operands[4]);\"\n+  [(set_attr \"length\" \"6,10\")\n+   (set_attr \"psw_operand\" \"clobber,clobber\")])\n+\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: Comparisons\n+;; ::\n+;; ::::::::::::::::::::\n+\n+;; Note, we store the operands in the comparison insns, and use them later\n+;; when generating the branch or scc operation.\n+\n+;; First the routines called by the machine independent part of the compiler\n+(define_expand \"cmphi\"\n+  [(set (cc0)\n+        (compare (match_operand:HI 0 \"register_operand\" \"\")\n+  \t\t (match_operand:HI 1 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  stormy16_compare_op0 = operands[0];\n+  stormy16_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+; There are no real SImode comparisons, but some can be emulated\n+; by performing a SImode subtract and looking at the condition flags.\n+(define_expand \"cmpsi\"\n+  [(set (cc0)\n+        (compare (match_operand:SI 0 \"register_operand\" \"\")\n+  \t\t (match_operand:SI 1 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  stormy16_compare_op0 = operands[0];\n+  stormy16_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: Branches\n+;; ::\n+;; ::::::::::::::::::::\n+\n+(define_expand \"beq\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"{ stormy16_emit_cbranch (EQ, operands[0]); DONE; }\")\n+\n+(define_expand \"bne\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"{ stormy16_emit_cbranch (NE, operands[0]); DONE; }\")\n+\n+(define_expand \"bge\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"{ stormy16_emit_cbranch (GE, operands[0]); DONE; }\")\n+\n+(define_expand \"bgt\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"{ stormy16_emit_cbranch (GT, operands[0]); DONE; }\")\n+\n+(define_expand \"ble\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"{ stormy16_emit_cbranch (LE, operands[0]); DONE; }\")\n+\n+(define_expand \"blt\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"{ stormy16_emit_cbranch (LT, operands[0]); DONE; }\")\n+\n+(define_expand \"bgeu\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"{ stormy16_emit_cbranch (GEU, operands[0]); DONE; }\")\n+\n+(define_expand \"bgtu\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"{ stormy16_emit_cbranch (GTU, operands[0]); DONE; }\")\n+\n+(define_expand \"bleu\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"{ stormy16_emit_cbranch (LEU, operands[0]); DONE; }\")\n+\n+(define_expand \"bltu\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"{ stormy16_emit_cbranch (LTU, operands[0]); DONE; }\")\n+\n+\n+(define_insn \"*cbranchhi\"\n+  [(set (pc) \n+\t(if_then_else (match_operator:HI 1 \"comparison_operator\"\n+\t\t\t\t      [(match_operand:HI 2 \"nonmemory_operand\" \n+\t\t\t\t\t\"r,e,L\")\n+\t\t\t\t       (match_operand:HI 3 \"nonmemory_operand\"\n+\t\t\t\t\t\t      \"r,L,e\")])\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))\n+   (clobber (match_operand:BI 4 \"\" \"=&y,&y,&y\"))]\n+  \"\"\n+  \"*\n+{\n+  return stormy16_output_cbranch_hi (operands[1], \\\"%l0\\\", 0, insn);\n+}\"\n+  [(set_attr \"branch_class\" \"bcc12\")\n+   (set_attr \"psw_operand\" \"0,0,1\")])\n+\n+(define_insn \"*cbranchhi_neg\"\n+  [(set (pc) \n+\t(if_then_else (match_operator:HI 1 \"comparison_operator\"\n+\t\t\t\t      [(match_operand:HI 2 \"nonmemory_operand\" \n+\t\t\t\t\t\t\t \"r,e,L\")\n+\t\t\t\t       (match_operand:HI 3 \"nonmemory_operand\"\n+\t\t\t\t\t\t\t \"r,L,e\")])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))\n+   (clobber (match_operand:BI 4 \"\" \"=&y,&y,&y\"))]\n+  \"\"\n+  \"*\n+{\n+  return stormy16_output_cbranch_hi (operands[1], \\\"%l0\\\", 1, insn);\n+}\"\n+  [(set_attr \"branch_class\" \"bcc12\")\n+   (set_attr \"psw_operand\" \"0,0,1\")])\n+\n+(define_insn \"*eqbranchsi\"\n+  [(set (pc)\n+\t(if_then_else (match_operator:SI 1 \"equality_operator\"\n+\t\t\t\t      [(match_operand:SI 2 \"register_operand\" \n+\t\t\t\t\t\t\t \"+r\")\n+\t\t\t\t       (const_int 0)])\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))\n+;; Although I would greatly like the 'match_dup' in the following line\n+;; to actually be a register constraint, there is (at the time of writing) no\n+;; way for reload to insert an output reload on the edges out of a branch.\n+;; If reload is fixed to use insert_insn_on_edge, this can be changed.\n+   (clobber (match_dup 2))]\n+  \"\"\n+  \"*\n+{\n+  return stormy16_output_cbranch_si (operands[1], \\\"%l0\\\", 0, insn);\n+}\"\n+  [(set_attr \"branch_class\" \"bcc8p2\")\n+   (set_attr \"psw_operand\" \"clobber\")])\n+\n+(define_insn_and_split \"*ineqbranchsi\"\n+  [(set (pc)\n+\t(if_then_else (match_operator:SI 1 \"stormy16_ineqsi_operator\"\n+\t\t\t\t      [(match_operand:SI 2 \"register_operand\" \n+\t\t\t\t\t\t\t \"+r\")\n+\t\t\t\t       (match_operand:SI 3 \"nonmemory_operand\" \n+\t\t\t\t\t\t\t \"ri\")])\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))\n+;; Although I would greatly like the 'match_dup' in the following line\n+;; to actually be a register constraint, there is (at the time of writing) no\n+;; way for reload to insert an output reload on the edges out of a branch.\n+;; If reload is fixed to use insert_insn_on_edge, this can be changed,\n+;; preferably to a 'minus' operand that explains the actual operation, like:\n+; (set (match_operand 5 \"register_operand\" \"=2\")\n+;      (minus:SI (match_operand 6 \"register_operand\" \"2\")\n+;\t\t (match_operand 7 \"register_operand\" \"3\")))\n+   (clobber (match_dup 2))\n+   (clobber (match_operand:BI 4 \"\" \"=&y\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(pc)]\n+  \"{ stormy16_split_cbranch (SImode, operands[0], operands[1], operands[2],\n+\t\t\t     operands[4]); DONE; }\"\n+  [(set_attr \"length\" \"8\")])\n+\n+(define_insn \"*ineqbranch_1\"\n+  [(set (pc)\n+\t(if_then_else (match_operator:HI 5 \"stormy16_ineqsi_operator\"\n+\t\t       [(minus:HI (match_operand:HI 1 \"register_operand\" \n+\t\t\t\t\t\t    \"T,r,r\")\n+\t\t\t   (zero_extend:HI (match_operand:BI 4\n+\t\t\t\t\t\t\t     \"register_operand\"\n+\t\t\t\t\t\t\t     \"y,y,y\")))\n+\t\t\t(match_operand:HI 3 \"nonmemory_operand\" \"L,Ir,i\")])\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))\n+   (set (match_operand:HI 2 \"register_operand\" \"=2,2,2\")\n+\t(minus:HI (minus:HI (match_dup 1) (zero_extend:HI (match_dup 4)))\n+\t\t  (match_dup 3)))\n+   (clobber (match_operand:BI 6 \"\" \"=y,y,y\"))]\n+  \"\"\n+  \"*\n+{\n+  return stormy16_output_cbranch_si (operands[5], \\\"%l0\\\", 0, insn);\n+}\"\n+  [(set_attr \"branch_class\" \"bcc8p2,bcc8p2,bcc8p4\")\n+   (set_attr \"psw_operand\" \"2,2,2\")])\n+\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: Call and branch instructions\n+;; ::\n+;; ::::::::::::::::::::\n+\n+;; Subroutine call instruction returning no value.  Operand 0 is the function\n+;; to call; operand 1 is the number of bytes of arguments pushed (in mode\n+;; `SImode', except it is normally a `const_int'); operand 2 is the number of\n+;; registers used as operands.\n+\n+;; On most machines, operand 2 is not actually stored into the RTL pattern.  It\n+;; is supplied for the sake of some RISC machines which need to put this\n+;; information into the assembler code; they can put it in the RTL instead of\n+;; operand 1.\n+\n+(define_expand \"call\"\n+  [(call (match_operand:HI 0 \"memory_operand\" \"m\")\n+\t (match_operand 1 \"\" \"\"))\n+   (use (match_operand 2 \"immediate_operand\" \"\"))]\n+  \"\"\n+  \"stormy16_expand_call (NULL_RTX, operands[0], operands[1]); DONE;\")\n+\n+;; Subroutine call instruction returning a value.  Operand 0 is the hard\n+;; register in which the value is returned.  There are three more operands, the\n+;; same as the three operands of the `call' instruction (but with numbers\n+;; increased by one).\n+\n+;; Subroutines that return `BLKmode' objects use the `call' insn.\n+\n+(define_expand \"call_value\"\n+  [(set (match_operand 0 \"register_operand\" \"=r\")\n+\t(call (match_operand:HI 1 \"memory_operand\" \"m\")\n+\t      (match_operand:SI 2 \"\" \"\")))\n+\t(use (match_operand 3 \"immediate_operand\" \"\"))]\n+  \"\"\n+  \"stormy16_expand_call (operands[0], operands[1], operands[2]); DONE;\")\n+\n+(define_insn \"*call_internal\"\n+  [(call (mem:HI (match_operand:HI 0 \"nonmemory_operand\" \"i,r\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (use (match_operand:HI 2 \"nonmemory_operand\" \"X,t\"))]\n+  \"\"\n+  \"@\n+   callf %C0\n+   call %2,%0\"\n+  [(set_attr \"length\" \"4,2\")\n+   (set_attr \"psw_operand\" \"clobber\")])\n+\n+(define_insn \"*call_value_internal\"\n+  [(set (match_operand 3 \"register_operand\" \"=r,r\")\n+        (call (mem:HI (match_operand:HI 0 \"nonmemory_operand\" \"i,r\"))\n+\t      (match_operand 1 \"\" \"\")))\n+   (use (match_operand:HI 2 \"nonmemory_operand\" \"X,t\"))]\n+  \"\"\n+  \"@\n+   callf %C0\n+   call %2,%0\"\n+  [(set_attr \"length\" \"4,2\")\n+   (set_attr \"psw_operand\" \"clobber\")])\n+\n+;; Subroutine return\n+(define_expand \"return\"\n+  [(return)]\n+  \"direct_return()\"\n+  \"\")\n+\n+(define_insn \"return_internal\"\n+  [(return)]\n+  \"\"\n+  \"ret\"\n+  [(set_attr \"psw_operand\" \"nop\")])\n+\n+(define_insn \"return_internal_interrupt\"\n+  [(return)\n+   (unspec_volatile [(const_int 0)] 1)]\n+  \"\"\n+  \"iret\"\n+  [(set_attr \"psw_operand\" \"clobber\")])\n+\n+;; Normal unconditional jump\n+(define_insn \"jump\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  return stormy16_output_cbranch_hi (NULL_RTX, \\\"%l0\\\", 0, insn);\n+}\"\n+  [(set_attr \"branch_class\" \"br12\")\n+   (set_attr \"psw_operand\" \"nop\")])\n+\n+;; Indirect jump through a register\n+(define_expand \"indirect_jump\"\n+  [(set (match_dup 1) (const_int 0))\n+   (parallel [(set (pc) (match_operand:HI 0 \"register_operand\" \"r\"))\n+\t      (use (match_dup 1))])]\n+  \"\"\n+  \"operands[1] = gen_reg_rtx (HImode);\")\n+\n+(define_insn \"\"\n+  [(set (pc) (match_operand:HI 0 \"register_operand\" \"r\"))\n+   (use (match_operand:HI 1 \"register_operand\" \"t\"))]\n+  \"\"\n+  \"jmp %1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"psw_operand\" \"nop\")])\n+\n+;; Table-based switch statements.\n+(define_expand \"casesi\"\n+  [(use (match_operand:SI 0 \"register_operand\" \"\"))\n+   (use (match_operand:SI 1 \"immediate_operand\" \"\"))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"\"))\n+   (use (label_ref (match_operand 3 \"\" \"\")))\n+   (use (label_ref (match_operand 4 \"\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  stormy16_expand_casesi (operands[0], operands[1], operands[2],\n+\t\t\t  operands[3], operands[4]);\n+  DONE;\n+}\")\n+\n+(define_insn \"tablejump_pcrel\"\n+  [(set (pc) (plus:HI (pc) (match_operand:HI 0 \"register_operand\" \"r\")))\n+   (use (label_ref:SI (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"br %0\"\n+  [(set_attr \"psw_operand\" \"nop\")])\n+\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: Prologue and Epilogue instructions\n+;; ::\n+;; ::::::::::::::::::::\n+\n+;; Called after register allocation to add any instructions needed for the\n+;; prologue.  Using a prologue insn is favored compared to putting all of the\n+;; instructions in the FUNCTION_PROLOGUE macro, since it allows the scheduler\n+;; to intermix instructions with the saves of the caller saved registers.  In\n+;; some cases, it might be necessary to emit a barrier instruction as the last\n+;; insn to prevent such scheduling.\n+(define_expand \"prologue\"\n+  [(const_int 1)]\n+  \"\"\n+  \"\n+{\n+  stormy16_expand_prologue ();\n+  DONE;\n+}\")\n+\n+;; Called after register allocation to add any instructions needed for the\n+;; epilogue.  Using a epilogue insn is favored compared to putting all of the\n+;; instructions in the FUNCTION_EPILOGUE macro, since it allows the scheduler\n+;; to intermix instructions with the restires of the caller saved registers.\n+;; In some cases, it might be necessary to emit a barrier instruction as the\n+;; first insn to prevent such scheduling.\n+(define_expand \"epilogue\"\n+  [(const_int 2)]\n+  \"\"\n+  \"\n+{\n+  stormy16_expand_epilogue ();\n+  DONE;\n+}\")\n+\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: Miscellaneous instructions\n+;; ::\n+;; ::::::::::::::::::::\n+\n+;; No operation, needed in case the user uses -g but not -O.\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\"\n+  [(set_attr \"psw_operand\" \"nop\")])\n+\n+;; Pseudo instruction that prevents the scheduler from moving code above this\n+;; point.\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"length\" \"0\")\n+   (set_attr \"psw_operand\" \"nop\")])"}, {"sha": "241b89bc8f4a0903d33da3e88b1aa3c13607c98b", "filename": "gcc/config/stormy16/t-stormy16", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b58290fe6d467cf8d1c4f72e35c308218728b3b/gcc%2Fconfig%2Fstormy16%2Ft-stormy16", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b58290fe6d467cf8d1c4f72e35c308218728b3b/gcc%2Fconfig%2Fstormy16%2Ft-stormy16", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Ft-stormy16?ref=4b58290fe6d467cf8d1c4f72e35c308218728b3b", "patch": "@@ -0,0 +1,18 @@\n+# -*- makefile -*-\n+\n+# SImode routines\n+\n+LIB2FUNCS_EXTRA = \\\n+\t$(srcdir)/config/stormy16/stormy16-lib2.c\n+\n+# floating point emulation libraries\n+\n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT'\t\t\t\t> fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c\t\t\t>> fp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c > dp-bit.c"}]}