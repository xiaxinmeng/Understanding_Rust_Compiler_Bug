{"sha": "510c9192493b6af5c4c70b14390fe340bca8ecaa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTEwYzkxOTI0OTNiNmFmNWM0YzcwYjE0MzkwZmUzNDBiY2E4ZWNhYQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-06-07T12:13:13Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-06-07T12:13:13Z"}, "message": "Enable sanitization for hash tables.\n\n2019-06-07  Martin Liska  <mliska@suse.cz>\n\n\t* cselib.c (cselib_init): Disable hash table\n\tsanitization.\n\t* hash-set.h: Pass new default argument to m_table.\n\t* hash-table.c: Add global variable with hash table\n\tsanitization limit.\n\t* hash-table.h (Allocator>::hash_table): Add new argument\n\tto ctor.\n\t(hashtab_chk_error): New.\n\t* params.def (PARAM_HASH_TABLE_VERIFICATION_LIMIT): New.\n\t* toplev.c (process_options): Set hash_table_sanitize_eq_limit\n\tfrom the PARAM_HASH_TABLE_VERIFICATION_LIMIT value.\n\nFrom-SVN: r272038", "tree": {"sha": "c2e8bab0a5b755fef04328d8776654af5bc76f67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2e8bab0a5b755fef04328d8776654af5bc76f67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/510c9192493b6af5c4c70b14390fe340bca8ecaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/510c9192493b6af5c4c70b14390fe340bca8ecaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/510c9192493b6af5c4c70b14390fe340bca8ecaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/510c9192493b6af5c4c70b14390fe340bca8ecaa/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "686a56a85d39750cd5c0c42f2ea747c8632e519e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/686a56a85d39750cd5c0c42f2ea747c8632e519e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/686a56a85d39750cd5c0c42f2ea747c8632e519e"}], "stats": {"total": 98, "additions": 91, "deletions": 7}, "files": [{"sha": "a1cffe10a32d5612cba275c2c5e12128285f91a8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/510c9192493b6af5c4c70b14390fe340bca8ecaa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/510c9192493b6af5c4c70b14390fe340bca8ecaa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=510c9192493b6af5c4c70b14390fe340bca8ecaa", "patch": "@@ -1,3 +1,17 @@\n+2019-06-07  Martin Liska  <mliska@suse.cz>\n+\n+\t* cselib.c (cselib_init): Disable hash table\n+\tsanitization.\n+\t* hash-set.h: Pass new default argument to m_table.\n+\t* hash-table.c: Add global variable with hash table\n+\tsanitization limit.\n+\t* hash-table.h (Allocator>::hash_table): Add new argument\n+\tto ctor.\n+\t(hashtab_chk_error): New.\n+\t* params.def (PARAM_HASH_TABLE_VERIFICATION_LIMIT): New.\n+\t* toplev.c (process_options): Set hash_table_sanitize_eq_limit\n+\tfrom the PARAM_HASH_TABLE_VERIFICATION_LIMIT value.\n+\n 2019-06-07  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* common.opt (flto-odr-type-merging): Ignore."}, {"sha": "a1cbdec97181a88d248530489a500a717d455ea6", "filename": "gcc/cselib.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/510c9192493b6af5c4c70b14390fe340bca8ecaa/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/510c9192493b6af5c4c70b14390fe340bca8ecaa/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=510c9192493b6af5c4c70b14390fe340bca8ecaa", "patch": "@@ -2858,9 +2858,14 @@ cselib_init (int record_what)\n     }\n   used_regs = XNEWVEC (unsigned int, cselib_nregs);\n   n_used_regs = 0;\n-  cselib_hash_table = new hash_table<cselib_hasher> (31);\n+  /* FIXME: enable sanitization (PR87845) */\n+  cselib_hash_table\n+    = new hash_table<cselib_hasher> (31, /* ggc */ false,\n+\t\t\t\t     /* sanitize_eq_and_hash */ false);\n   if (cselib_preserve_constants)\n-    cselib_preserved_hash_table = new hash_table<cselib_hasher> (31);\n+    cselib_preserved_hash_table\n+      = new hash_table<cselib_hasher> (31, /* ggc */ false,\n+\t\t\t\t       /* sanitize_eq_and_hash */ false);\n   next_uid = 1;\n }\n "}, {"sha": "d891ed782975d3de00340e8d1c70047b344ddb58", "filename": "gcc/hash-set.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/510c9192493b6af5c4c70b14390fe340bca8ecaa/gcc%2Fhash-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/510c9192493b6af5c4c70b14390fe340bca8ecaa/gcc%2Fhash-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-set.h?ref=510c9192493b6af5c4c70b14390fe340bca8ecaa", "patch": "@@ -28,7 +28,7 @@ class hash_set\n public:\n   typedef typename Traits::value_type Key;\n   explicit hash_set (size_t n = 13, bool ggc = false CXX_MEM_STAT_INFO)\n-    : m_table (n, ggc, GATHER_STATISTICS, HASH_SET_ORIGIN PASS_MEM_STAT) {}\n+    : m_table (n, ggc, true, GATHER_STATISTICS, HASH_SET_ORIGIN PASS_MEM_STAT) {}\n \n   /* Create a hash_set in gc memory with space for at least n elements.  */\n "}, {"sha": "8e86fffa36fe7f21dda1f87145042bb513dbb12c", "filename": "gcc/hash-table.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/510c9192493b6af5c4c70b14390fe340bca8ecaa/gcc%2Fhash-table.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/510c9192493b6af5c4c70b14390fe340bca8ecaa/gcc%2Fhash-table.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.c?ref=510c9192493b6af5c4c70b14390fe340bca8ecaa", "patch": "@@ -74,6 +74,9 @@ struct prime_ent const prime_tab[] = {\n   { 0xfffffffb, 0x00000006, 0x00000008, 31 }\n };\n \n+/* Limit number of comparisons when calling hash_table<>::verify.  */\n+unsigned int hash_table_sanitize_eq_limit;\n+\n /* The following function returns an index into the above table of the\n    nearest prime number which is greater than N, and near a power of two. */\n "}, {"sha": "686a13dbd4b212063be1262c1e02ceb49034471d", "filename": "gcc/hash-table.h", "status": "modified", "additions": 56, "deletions": 4, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/510c9192493b6af5c4c70b14390fe340bca8ecaa/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/510c9192493b6af5c4c70b14390fe340bca8ecaa/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=510c9192493b6af5c4c70b14390fe340bca8ecaa", "patch": "@@ -295,6 +295,8 @@ struct prime_ent\n \n extern struct prime_ent const prime_tab[];\n \n+/* Limit number of comparisons when calling hash_table<>::verify.  */\n+extern unsigned int hash_table_sanitize_eq_limit;\n \n /* Functions for computing hash table indexes.  */\n \n@@ -371,10 +373,12 @@ class hash_table\n \n public:\n   explicit hash_table (size_t, bool ggc = false,\n+\t\t       bool sanitize_eq_and_hash = true,\n \t\t       bool gather_mem_stats = GATHER_STATISTICS,\n \t\t       mem_alloc_origin origin = HASH_TABLE_ORIGIN\n \t\t       CXX_MEM_STAT_INFO);\n   explicit hash_table (const hash_table &, bool ggc = false,\n+\t\t       bool sanitize_eq_and_hash = true,\n \t\t       bool gather_mem_stats = GATHER_STATISTICS,\n \t\t       mem_alloc_origin origin = HASH_TABLE_ORIGIN\n \t\t       CXX_MEM_STAT_INFO);\n@@ -516,6 +520,7 @@ class hash_table\n \n   value_type *alloc_entries (size_t n CXX_MEM_STAT_INFO) const;\n   value_type *find_empty_slot_for_expand (hashval_t);\n+  void verify (const compare_type &comparable, hashval_t hash);\n   bool too_empty_p (unsigned int);\n   void expand ();\n   static bool is_deleted (value_type &v)\n@@ -564,6 +569,9 @@ class hash_table\n   /* if m_entries is stored in ggc memory.  */\n   bool m_ggc;\n \n+  /* True if the table should be sanitized for equal and hash functions.  */\n+  bool m_sanitize_eq_and_hash;\n+\n   /* If we should gather memory statistics for the table.  */\n #if GATHER_STATISTICS\n   bool m_gather_mem_stats;\n@@ -586,12 +594,13 @@ extern void dump_hash_table_loc_statistics (void);\n template<typename Descriptor, bool Lazy,\n \t template<typename Type> class Allocator>\n hash_table<Descriptor, Lazy, Allocator>::hash_table (size_t size, bool ggc,\n+\t\t\t\t\t\t     bool sanitize_eq_and_hash,\n \t\t\t\t\t\t     bool gather_mem_stats\n \t\t\t\t\t\t     ATTRIBUTE_UNUSED,\n \t\t\t\t\t\t     mem_alloc_origin origin\n \t\t\t\t\t\t     MEM_STAT_DECL) :\n   m_n_elements (0), m_n_deleted (0), m_searches (0), m_collisions (0),\n-  m_ggc (ggc)\n+  m_ggc (ggc), m_sanitize_eq_and_hash (sanitize_eq_and_hash)\n #if GATHER_STATISTICS\n   , m_gather_mem_stats (gather_mem_stats)\n #endif\n@@ -617,12 +626,14 @@ template<typename Descriptor, bool Lazy,\n \t template<typename Type> class Allocator>\n hash_table<Descriptor, Lazy, Allocator>::hash_table (const hash_table &h,\n \t\t\t\t\t\t     bool ggc,\n+\t\t\t\t\t\t     bool sanitize_eq_and_hash,\n \t\t\t\t\t\t     bool gather_mem_stats\n \t\t\t\t\t\t     ATTRIBUTE_UNUSED,\n \t\t\t\t\t\t     mem_alloc_origin origin\n \t\t\t\t\t\t     MEM_STAT_DECL) :\n   m_n_elements (h.m_n_elements), m_n_deleted (h.m_n_deleted),\n-  m_searches (0), m_collisions (0), m_ggc (ggc)\n+  m_searches (0), m_collisions (0), m_ggc (ggc),\n+  m_sanitize_eq_and_hash (sanitize_eq_and_hash)\n #if GATHER_STATISTICS\n   , m_gather_mem_stats (gather_mem_stats)\n #endif\n@@ -912,7 +923,13 @@ ::find_with_hash (const compare_type &comparable, hashval_t hash)\n       entry = &m_entries[index];\n       if (is_empty (*entry)\n           || (!is_deleted (*entry) && Descriptor::equal (*entry, comparable)))\n-        return *entry;\n+\t{\n+#if CHECKING_P\n+\t  if (m_sanitize_eq_and_hash)\n+\t    verify (comparable, hash);\n+#endif\n+\t  return *entry;\n+\t}\n     }\n }\n \n@@ -941,8 +958,12 @@ ::find_slot_with_hash (const compare_type &comparable, hashval_t hash,\n   if (insert == INSERT && m_size * 3 <= m_n_elements * 4)\n     expand ();\n \n-  m_searches++;\n+#if CHECKING_P\n+  if (m_sanitize_eq_and_hash)\n+    verify (comparable, hash);\n+#endif\n \n+  m_searches++;\n   value_type *first_deleted_slot = NULL;\n   hashval_t index = hash_table_mod1 (hash, m_size_prime_index);\n   hashval_t hash2 = hash_table_mod2 (hash, m_size_prime_index);\n@@ -989,6 +1010,37 @@ ::find_slot_with_hash (const compare_type &comparable, hashval_t hash,\n   return &m_entries[index];\n }\n \n+/* Report a hash table checking error.  */\n+\n+ATTRIBUTE_NORETURN ATTRIBUTE_COLD\n+static void\n+hashtab_chk_error ()\n+{\n+  fprintf (stderr, \"hash table checking failed: \"\n+\t   \"equal operator returns true for a pair \"\n+\t   \"of values with a different hash value\\n\");\n+  gcc_unreachable ();\n+}\n+\n+/* Verify that all existing elements in th hash table which are\n+   equal to COMPARABLE have an equal HASH value provided as argument.  */\n+\n+template<typename Descriptor, bool Lazy,\n+\t template<typename Type> class Allocator>\n+void\n+hash_table<Descriptor, Lazy, Allocator>\n+::verify (const compare_type &comparable, hashval_t hash)\n+{\n+  for (size_t i = 0; i < MIN (hash_table_sanitize_eq_limit, m_size); i++)\n+    {\n+      value_type *entry = &m_entries[i];\n+      if (!is_empty (*entry) && !is_deleted (*entry)\n+\t  && hash != Descriptor::hash (*entry)\n+\t  && Descriptor::equal (*entry, comparable))\n+\thashtab_chk_error ();\n+    }\n+}\n+\n /* This function deletes an element with the given COMPARABLE value\n    from hash table starting with the given HASH.  If there is no\n    matching element in the hash table, this function does nothing. */"}, {"sha": "0db6095141396cefc7cde4c979b5cf842dc5596e", "filename": "gcc/params.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/510c9192493b6af5c4c70b14390fe340bca8ecaa/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/510c9192493b6af5c4c70b14390fe340bca8ecaa/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=510c9192493b6af5c4c70b14390fe340bca8ecaa", "patch": "@@ -1431,6 +1431,12 @@ DEFPARAM(PARAM_GIMPLE_FE_COMPUTED_HOT_BB_THRESHOLD,\n \t \" The parameter is used only in GIMPLE FE.\",\n \t 0, 0, 0)\n \n+DEFPARAM(PARAM_HASH_TABLE_VERIFICATION_LIMIT,\n+\t \"hash-table-verification-limit\",\n+\t \"The number of elements for which hash table verification is done for \"\n+\t \"each searched element.\",\n+\t 100, 0, 0)\n+\n /*\n \n Local variables:"}, {"sha": "116be7be395545d2233d355d0ab60149f2b0afe7", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/510c9192493b6af5c4c70b14390fe340bca8ecaa/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/510c9192493b6af5c4c70b14390fe340bca8ecaa/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=510c9192493b6af5c4c70b14390fe340bca8ecaa", "patch": "@@ -1799,6 +1799,10 @@ process_options (void)\n   optimization_default_node = build_optimization_node (&global_options);\n   optimization_current_node = optimization_default_node;\n \n+  if (flag_checking >= 2)\n+    hash_table_sanitize_eq_limit\n+      = PARAM_VALUE (PARAM_HASH_TABLE_VERIFICATION_LIMIT);\n+\n   /* Please don't change global_options after this point, those changes won't\n      be reflected in optimization_{default,current}_node.  */\n }"}]}