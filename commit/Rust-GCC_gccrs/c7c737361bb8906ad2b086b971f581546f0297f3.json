{"sha": "c7c737361bb8906ad2b086b971f581546f0297f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdjNzM3MzYxYmI4OTA2YWQyYjA4NmI5NzFmNTgxNTQ2ZjAyOTdmMw==", "commit": {"author": {"name": "Zoltan Hidvegi", "email": "hzoli@hzoli.2y.net", "date": "2001-11-30T02:16:31Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2001-11-30T02:16:31Z"}, "message": "doloop.c (doloop_valid_p): Check for LTU and GTU as well.\n\n2001-11-29  Zoltan Hidvegi  <hzoli@hzoli.2y.net>\n\n        * doloop.c (doloop_valid_p): Check for LTU and GTU as well.\n\nFrom-SVN: r47468", "tree": {"sha": "c6729b7563e218d0bc02e8e4883618d4104e4090", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6729b7563e218d0bc02e8e4883618d4104e4090"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7c737361bb8906ad2b086b971f581546f0297f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7c737361bb8906ad2b086b971f581546f0297f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7c737361bb8906ad2b086b971f581546f0297f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7c737361bb8906ad2b086b971f581546f0297f3/comments", "author": null, "committer": null, "parents": [{"sha": "20c29ebe49754fa84ce1dfedcf0a27698db9e67b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20c29ebe49754fa84ce1dfedcf0a27698db9e67b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20c29ebe49754fa84ce1dfedcf0a27698db9e67b"}], "stats": {"total": 31, "additions": 25, "deletions": 6}, "files": [{"sha": "00f7de42a1fa009362e6e225a26496842b0267dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c737361bb8906ad2b086b971f581546f0297f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c737361bb8906ad2b086b971f581546f0297f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c7c737361bb8906ad2b086b971f581546f0297f3", "patch": "@@ -1,3 +1,7 @@\n+2001-11-29  Zoltan Hidvegi  <hzoli@hzoli.2y.net>\n+\n+\t* doloop.c (doloop_valid_p): Check for LTU and GTU as well.\n+\n 2001-11-29  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* config/rs6000/rs6000.c (function_arg): Unnamed vector arguments "}, {"sha": "f6b765a0bbd2b2364fd88042cf0fc54c67d19235", "filename": "gcc/doloop.c", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c737361bb8906ad2b086b971f581546f0297f3/gcc%2Fdoloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c737361bb8906ad2b086b971f581546f0297f3/gcc%2Fdoloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoloop.c?ref=c7c737361bb8906ad2b086b971f581546f0297f3", "patch": "@@ -353,23 +353,38 @@ doloop_valid_p (loop, jump_insn)\n       && ((loop_info->comparison_code == LEU\n \t   && INTVAL (loop_info->increment) > 0)\n \t  || (loop_info->comparison_code == GEU\n-\t      && INTVAL (loop_info->increment) < 0)))\n+\t      && INTVAL (loop_info->increment) < 0)\n+\t  || (loop_info->comparison_code == LTU\n+\t      && INTVAL (loop_info->increment) > 1)\n+\t  || (loop_info->comparison_code == GTU\n+\t      && INTVAL (loop_info->increment) < -1)))\n     {\n       /* If the comparison is LEU and the comparison value is UINT_MAX\n \t then the loop will not terminate.  Similarly, if the\n \t comparison code is GEU and the initial value is 0, the loop\n \t will not terminate.\n \n-\t Note that with LE and GE, the loop behaviour can be\n-\t implementation dependent if an overflow occurs, say between\n-\t INT_MAX and INT_MAX + 1.  We thus don't have to worry about\n-\t these two cases.\n+\t If the absolute increment is not 1, the loop can be infinite\n+\t even with LTU/GTU, e.g. for (i = 3; i > 0; i -= 2)\n+\n+\t Note that with LE and GE, the loop behaviour is undefined\n+\t (C++ standard section 5 clause 5) if an overflow occurs, say\n+\t between INT_MAX and INT_MAX + 1.  We thus don't have to worry\n+\t about these two cases.\n \n \t ??? We could compute these conditions at run-time and have a\n \t additional jump around the loop to ensure an infinite loop.\n \t However, it is very unlikely that this is the intended\n \t behaviour of the loop and checking for these rare boundary\n-\t conditions would pessimize all other code.  */\n+\t conditions would pessimize all other code.\n+\n+\t If the loop is executed only a few times an extra check to\n+\t restart the loop could use up most of the benefits of using a\n+\t count register loop.  Note however, that normally, this\n+\t restart branch would never execute, so it could be predicted\n+\t well by the CPU.  We should generate the pessimistic code by\n+\t default, and have an option, e.g. -funsafe-loops that would\n+\t enable count-register loops in this case.  */\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n \t\t \"Doloop: Possible infinite iteration case ignored.\\n\");"}]}