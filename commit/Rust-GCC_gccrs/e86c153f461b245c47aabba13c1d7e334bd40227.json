{"sha": "e86c153f461b245c47aabba13c1d7e334bd40227", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg2YzE1M2Y0NjFiMjQ1YzQ3YWFiYmExM2MxZDdlMzM0YmQ0MDIyNw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-31T21:29:19Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-31T21:29:19Z"}, "message": "(LIBCALL_VALUE): Handle XFmode.\n\n(ASM_OUTPUT_FLOAT, ASM_OUTPUT_DOUBLE): Use REAL_VALUE... macros.\n(PRINT_OPERAND): Likewise.\n(ASM_OUTPUT_LONG_DOUBLE): New definition.\n\nFrom-SVN: r3974", "tree": {"sha": "be653ab763a6d5622dca0a00d31bca5d019dbd02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be653ab763a6d5622dca0a00d31bca5d019dbd02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e86c153f461b245c47aabba13c1d7e334bd40227", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e86c153f461b245c47aabba13c1d7e334bd40227", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e86c153f461b245c47aabba13c1d7e334bd40227", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e86c153f461b245c47aabba13c1d7e334bd40227/comments", "author": null, "committer": null, "parents": [{"sha": "2743360a6e3c65400577b3b79f7fc3f8a30b021e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2743360a6e3c65400577b3b79f7fc3f8a30b021e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2743360a6e3c65400577b3b79f7fc3f8a30b021e"}], "stats": {"total": 54, "additions": 34, "deletions": 20}, "files": [{"sha": "08968a479185dd61e774e1d8f693b0d74b7c93b6", "filename": "gcc/config/m68k/mot3300.h", "status": "modified", "additions": 34, "deletions": 20, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e86c153f461b245c47aabba13c1d7e334bd40227/gcc%2Fconfig%2Fm68k%2Fmot3300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e86c153f461b245c47aabba13c1d7e334bd40227/gcc%2Fconfig%2Fm68k%2Fmot3300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fmot3300.h?ref=e86c153f461b245c47aabba13c1d7e334bd40227", "patch": "@@ -252,7 +252,7 @@ output_file_directive ((FILE), main_input_filename)\n /* NYI: If -mold return pointer in a0 and d0 */\n \n #undef FUNCTION_VALUE\n-#define FUNCTION_VALUE(VALTYPE,FUNC) LIBCALL_VALUE(TYPE_MODE(VALTYPE))\n+#define FUNCTION_VALUE(VALTYPE,FUNC) LIBCALL_VALUE (TYPE_MODE (VALTYPE))\n \n /* sysV68 (brain damaged) cc convention support. */\n /* Commented out until we find a safe way to make it optional.  */\n@@ -268,8 +268,11 @@ output_file_directive ((FILE), main_input_filename)\n /* If TARGET_68881, SF and DF values are returned in fp0 instead of d0.  */\n \n #undef LIBCALL_VALUE\n-#define LIBCALL_VALUE(MODE) \\\n- gen_rtx (REG, (MODE), ((TARGET_68881 && ((MODE) == SFmode || (MODE) == DFmode)) ? 16 : 0))\n+#define LIBCALL_VALUE(MODE)\t\t\t\t\t\t   \\\n+ gen_rtx (REG, (MODE),\t\t\t\t\t\t\t   \\\n+\t  ((TARGET_68881\t\t\t\t\t\t   \\\n+\t    && ((MODE) == SFmode || (MODE) == DFmode || (MODE) == XFmode)) \\\n+\t   ? 16 : 0))\n \n /* 1 if N is a possible register number for a function value.\n    d0 may be used, and fp0 as well if -msoft-float is not specified.  */\n@@ -307,19 +310,29 @@ output_file_directive ((FILE), main_input_filename)\n   sprintf ((OUTPUT), \"%s_%%%d\", (NAME), (LABELNO)))\n \n /* The sysV68 as doesn't know about double's and float's.  */\n+/* This is how to output an assembler line defining a `double' constant.  */\n \n #undef ASM_OUTPUT_DOUBLE\n #define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n-do { union { double d; long l[2]; } tem;\t\t\t\\\n-     tem.d = (VALUE);\t\t\t\t\t\t\\\n-     fprintf(FILE, \"\\tlong 0x%x,0x%x\\n\", tem.l[0], tem.l[1]);\t\\\n+do { long l[2];\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\\\n+     fprintf (FILE, \"\\tlong 0x%x,0x%x\\n\", l[0], l[1]); \\\n    } while (0)\n \n+#undef ASM_OUTPUT_LONG_DOUBLE\n+#define ASM_OUTPUT_LONG_DOUBLE(FILE,VALUE)  \t\t\t\t\\\n+do { long l[3];\t\t\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_LONG_DOUBLE (VALUE, l);\t\t\t\\\n+     fprintf (FILE, \"\\tlong 0x%x,0x%x,0x%x\\n\", l[0], l[1], l[2]);\t\\\n+   } while (0)\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n #undef ASM_OUTPUT_FLOAT\n #define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n-do { union { float f; long l;} tem;\t\t\t\\\n-     tem.f = (VALUE);\t\t\t\t\t\\\n-     fprintf (FILE, \"\\tlong 0x%x\\n\", tem.l);\t\t\\\n+do { long l;\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\\\n+     fprintf ((FILE), \"\\tlong 0x%x\\n\", l);\t\\\n    } while (0)\n \n /* This is how to output an assembler line defining an `int' constant.  */\n@@ -447,19 +460,20 @@ do { union { float f; long l;} tem;\t\t\t\\\n   else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n     output_address (XEXP (X, 0));\t\t\t\t\t\\\n   else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == SFmode)\t\\\n-    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n-      union { float f; int i; } u1;\t\t\t\t\t\\\n-      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n-      u1.f = u.d;\t\t\t\t\t\t\t\\\n+    { REAL_VALUE_TYPE r; long l;\t\t\t\t\t\\\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, X);\t\t\t\t\\\n+      REAL_VALUE_TO_TARGET_SINGLE (r, l);\t\t\t\t\\\n       /* Use hex representation even if CODE is f.  as needs it.  */\t\\\n-      if (CODE == 'f')\t\t\t\t\t\t\t\\\n-        fprintf (FILE, \"&0x%x\", u1.i);\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-        fprintf (FILE, \"&0x%x\", u1.i); }\t\t\t\t\\\n+      fprintf (FILE, \"&0x%x\", l); }\t\t\t\t\t\\\n   else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == DFmode)\t\\\n-    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n-      PRINT_OPERAND_EXTRACT_FLOAT (X);\t\t\t\t\t\\\n-      fprintf (FILE, \"&0x%08x%08x\", u.i[0], u.i[1]); }\t\t\t\\\n+    { REAL_VALUE_TYPE r; int i[2];\t\t\t\t\t\\\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, X);\t\t\t\t\\\n+      REAL_VALUE_TO_TARGET_DOUBLE (r, i);\t\t\t\t\\\n+      fprintf (FILE, \"&0x%08x%08x\", i[0], i[1]); }\t\t\t\\\n+  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == XFmode)\t\\\n+    { REAL_VALUE_TYPE r;\t\t\t\t\t\t\\\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, X);\t\t\t\t\\\n+      ASM_OUTPUT_LONG_DOUBLE_OPERAND (FILE, r); }\t\t\t\\\n   else { putc ('&', FILE); output_addr_const (FILE, X); }}\n \n #undef PRINT_OPERAND_ADDRESS"}]}