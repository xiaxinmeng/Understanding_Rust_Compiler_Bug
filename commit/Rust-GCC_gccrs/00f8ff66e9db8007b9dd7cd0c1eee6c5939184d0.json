{"sha": "00f8ff66e9db8007b9dd7cd0c1eee6c5939184d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBmOGZmNjZlOWRiODAwN2I5ZGQ3Y2QwYzFlZWU2YzU5MzkxODRkMA==", "commit": {"author": {"name": "Steve Chamberlain", "email": "sac@gnu.org", "date": "1994-11-24T04:38:49Z"}, "committer": {"name": "Steve Chamberlain", "email": "sac@gnu.org", "date": "1994-11-24T04:38:49Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r8563", "tree": {"sha": "2bb0c89a1a98e2755a2a86ef1fdd8413a987e80f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bb0c89a1a98e2755a2a86ef1fdd8413a987e80f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00f8ff66e9db8007b9dd7cd0c1eee6c5939184d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00f8ff66e9db8007b9dd7cd0c1eee6c5939184d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00f8ff66e9db8007b9dd7cd0c1eee6c5939184d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00f8ff66e9db8007b9dd7cd0c1eee6c5939184d0/comments", "author": null, "committer": null, "parents": [{"sha": "43d826d977b824c55159cadeb7580cc4431cade7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43d826d977b824c55159cadeb7580cc4431cade7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43d826d977b824c55159cadeb7580cc4431cade7"}], "stats": {"total": 355, "additions": 255, "deletions": 100}, "files": [{"sha": "ef7e73c890c7236663635cc525493d3578efab95", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 116, "deletions": 20, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f8ff66e9db8007b9dd7cd0c1eee6c5939184d0/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f8ff66e9db8007b9dd7cd0c1eee6c5939184d0/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=00f8ff66e9db8007b9dd7cd0c1eee6c5939184d0", "patch": "@@ -38,6 +38,10 @@\n #include \"obstack.h\"\n #include \"expr.h\"\n \n+#define MSW (TARGET_LITTLE_ENDIAN ? 1 : 0)\n+#define LSW (TARGET_LITTLE_ENDIAN ? 0 : 1)\n+\n+\n static rtx add_constant ();\n \n int pragma_interrupt;\n@@ -52,6 +56,12 @@ static rtx shiftsyms[32];\n struct rtx_def *table_lab;\n enum attr_cpu sh_cpu;\t\t/* target cpu */\n \n+\n+char *max_si;\n+char *max_hi;\n+int  max_count_si;\n+int  max_count_hi;\n+\n /* Global variables for machine-dependent things. */\n \n /* Saved operands from the last compare to use when we generate an scc\n@@ -338,8 +348,9 @@ print_operand_address (stream, x)\n    '!'  dump the constant table\n    '#'  output a nop if there is nothing to put in the delay slot\n    '@'  print rte or rts depending upon pragma interruptness\n-   'R'  print the next register or memory location along, ie the lsw in\n-   a double word value\n+   'R'  print the LSW of a dp value - changes if in little endian\n+   'T'  print the next word of a dp value - same as 'R' in big endian mode.\n+   'S'  print the MSW of a dp value - changes if in little endian\n    'O'  print a constant without the #\n    'M'  print a constant as its negative\n    'N'  print insides of a @++ or @-- o */\n@@ -385,14 +396,38 @@ print_operand (stream, x, code)\n       fputs (reg_names[REGNO (XEXP (XEXP (x, 0), 0))], (stream));\n       break;\n     case 'R':\n-      /* Next location along in memory or register */\n+      /* LSW of a double */\n+      switch (GET_CODE (x))\n+\t{\n+\tcase REG:\n+\t  fputs (reg_names[REGNO (x) + LSW], (stream));\n+\t  break;\n+\tcase MEM:\n+\t  print_operand_address (stream, XEXP (adj_offsettable_operand (x, LSW *4), 0));\n+\t  break;\n+\t}\n+      break;\n+    case 'T':\n+      /* Next word of a double */\n       switch (GET_CODE (x))\n \t{\n \tcase REG:\n \t  fputs (reg_names[REGNO (x) + 1], (stream));\n \t  break;\n \tcase MEM:\n-\t  print_operand_address (stream, XEXP (adj_offsettable_operand (x, 4), 0));\n+\t  print_operand_address (stream, XEXP (adj_offsettable_operand (x,1 *4), 0));\n+\t  break;\n+\t}\n+      break;\n+    case 'S':\n+      /* MSW of a double */\n+      switch (GET_CODE (x))\n+\t{\n+\tcase REG:\n+\t  fputs (reg_names[REGNO (x) + MSW], (stream));\n+\t  break;\n+\tcase MEM:\n+\t  print_operand_address (stream, XEXP (adj_offsettable_operand (x, MSW *4), 0));\n \t  break;\n \t}\n       break;\n@@ -829,38 +864,40 @@ output_movedouble (insn, operands, mode)\n       && GET_CODE (XEXP (dst, 0)) == POST_INC)\n     {\n       operands[0] = XEXP (XEXP (dst, 0), 0);\n-      return \"mov.l\t%R1,@(4,%0)\\n\\tmov.l\t%1,@%0\\n\\tadd\t#8,%0\";\n+      return \"mov.l\t%T1,@(4,%0)\\n\\tmov.l\t%1,@%0\\n\\tadd\t#8,%0\";\n     }\n   if (register_operand (dst, mode)\n       && register_operand (src, mode))\n     {\n       if (REGNO (src) == MACH_REG)\n-\treturn \"sts\tmach,%0\\n\\tsts\tmacl,%R0\";\n+\treturn \"sts\tmach,%S0\\n\\tsts\tmacl,%R0\";\n \n       /*\n          when mov.d r1,r2 do r2->r3 then r1->r2\n          when mov.d r1,r0 do r1->r0 then r2->r1\n        */\n \n       if (REGNO (src) + 1 == REGNO (dst))\n-\treturn \"mov\t%R1,%R0\\n\\tmov\t%1,%0 ! cra\";\n+\treturn \"mov\t%T1,%T0\\n\\tmov\t%1,%0 ! cra\";\n       else\n-\treturn \"mov\t%1,%0\\n\\tmov\t%R1,%R0 ! crb\";\n+\treturn \"mov\t%1,%0\\n\\tmov\t%T1,%T0 ! crb\";\n     }\n   else if (GET_CODE (src) == CONST_INT)\n     {\n       HOST_WIDE_INT val = INTVAL (src);\n       int rn = REGNO (operands[0]);\n+      int msw = rn + MSW;\n+      int lsw = rn + LSW;\n       if (val < 0)\n \t{\n-\t  fprintf (asm_out_file, \"\\tmov\t#-1,r%d\\n\", rn);\n+\t  fprintf (asm_out_file, \"\\tmov\t#-1,r%d\\n\", msw);\n \t}\n       else\n \t{\n-\t  fprintf (asm_out_file, \"\\tmov\t#0,r%d\\n\", rn);\n+\t  fprintf (asm_out_file, \"\\tmov\t#0,r%d\\n\", msw);\n \t}\n \n-      fprintf (asm_out_file, \"\\tmov\t#%d,r%d\\n\", val, rn + 1);\n+      fprintf (asm_out_file, \"\\tmov\t#%d,r%d\\n\", val, lsw);\n       return \"\";\n     }\n   else if (GET_CODE (src) == MEM)\n@@ -885,11 +922,11 @@ output_movedouble (insn, operands, mode)\n \t}\n       else if (GET_CODE (inside) == LABEL_REF)\n \t{\n-\t  return \"mov.l\t%1,%0\\n\\tmov.l\t%1+4,%R0\";\n+\t  return \"mov.l\t%1,%0\\n\\tmov.l\t%1+4,%T0\";\n \t}\n       else if (GET_CODE (inside) == POST_INC)\n \t{\n-\t  return \"mov.l\t%1,%0\\n\\tmov.l\t%1,%R0 !mdi\\n\";\n+\t  return \"mov.l\t%1,%0\\n\\tmov.l\t%1,%T0 !mdi\\n\";\n \t}\n       else\n \tabort ();\n@@ -936,11 +973,11 @@ output_movedouble (insn, operands, mode)\n       if (dreg == ptrreg1)\n \t{\n \t  /* Copy into the second half first */\n-\t  return \"mov.l\t%R1,%R0\\n\\tmov.l\t%1,%0 ! cr\";\n+\t  return \"mov.l\t%T1,%T0\\n\\tmov.l\t%1,%0 ! cr\";\n \t}\n     }\n \n-  return \"mov.l\t%1,%0\\n\\tmov.l\t%R1,%R0\";\n+  return \"mov.l\t%1,%0\\n\\tmov.l\t%T1,%T0\";\n }\n \n /* Emit assembly to shift reg by k bits */\n@@ -1372,6 +1409,9 @@ output_options (file, f_options, f_len, W_options, W_len,\n \n   fprintf (file, term);\n   fprintf (file, \"! %d %d\\n\", max_count_si, max_count_hi);\n+\n+  if (TARGET_LITTLE_ENDIAN)\n+    fprintf (file, \"\\t.little\\n\");\n }\n \n void\n@@ -1390,12 +1430,36 @@ output_file_start (file, f_options, f_len, W_options, W_len)\n   data_section ();\n \n \n-  pos = fprintf (file, \"\\n! Hitachi SH cc1 (%s) (release I-1) arguments:\", version_string);\n+  pos = fprintf (file, \"\\n! Hitachi SH cc1 (%s) arguments:\", version_string);\n   output_options (file, f_options, f_len, W_options, W_len,\n \t\t  pos, 75, \" \", \"\\n! \", \"\\n\\n\");\n }\n \f\n \n+/* Actual number of instructions used to make a shift by N */\n+char ashiftrt_insns[] = { 0,1,2,3,4,5,8,8,8,8,8,8,8,8,8,8,2,3,4,5,8,8,8,8,8,8,8,8,8,8,8,2};\n+char lshiftrt_insns[] = { 0,1,1,2,2,3,3,4,1,2,2,3,3,4,4,5,1,2,2,3,3,4,4,5,2,3,3,4,4,5,5,6};\n+char shift_insns[]    = { 0,1,1,2,2,3,3,4,1,2,2,3,3,4,4,5,1,2,2,3,3,4,4,5,2,3,3,4,4,5,5,6};\n+\n+int \n+shiftinsns (shift, n)\n+enum rtx_code shift;\n+int n;\n+{\n+  switch (shift) \n+    {\n+    case ASHIFTRT:\n+      return ashiftrt_insns[n];\n+    case LSHIFTRT:\n+      return lshiftrt_insns[n];\n+    case ASHIFT:\n+      return shift_insns[n];\n+    default:\n+      abort();\n+    }\n+}\n+\n+\n \n /* Return the cost of a shift */\n \n@@ -1404,14 +1468,16 @@ shiftcosts (RTX)\n      rtx RTX;\n {\n   /* If shift by a non constant, then this will be expensive. */\n-  if (GET_CODE (XEXP (RTX, 1)) != CONST_INT)\n-    return 20;\n+  if (GET_CODE (XEXP (RTX, 1)) != CONST_INT) \n+    {\n+      return 20;\n+    }\n \n   /* otherwise, it will be very cheap if by one of the constants\n      we can cope with. */\n+\n   if (CONST_OK_FOR_K (INTVAL (XEXP (RTX, 1))))\n     return 1;\n-\n   /* otherwise it will be several insns, but we pretend that it will be more than\n      just the components, so that combine doesn't glue together a load of shifts into\n      one shift which has to be emitted as a bunch anyway - breaking scheduling */\n@@ -1541,10 +1607,12 @@ gen_shifty_op (code, operands)\n   rtx wrk = gen_reg_rtx (SImode);\n   rtx t;\n   char *func;\n+\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n       int value = INTVAL (operands[2]);\n     top:\n+\n       switch (code)\n \t{\n \tcase ASHIFTRT:\n@@ -1554,7 +1622,20 @@ gen_shifty_op (code, operands)\n \t      value = -value;\n \t      goto top;\n \t    }\n-\n+\t  if (value == 31)\n+\t    {\n+\t      emit_insn (gen_ashrsi2_31 (operands[0], operands[1]));\n+\t      return 1;\n+\t    }\n+\t  else if (value >= 16 && value <= 19) \n+\t    {\n+\t      emit_insn (gen_ashrsi2_16 (wrk, operands[1]));\n+\t      value -= 16;\n+\t      while (value --)\n+\t\tgen_ashift (ASHIFTRT,1, wrk);\n+\t      emit_move_insn (operands[0], wrk);\n+\t      return 1;\n+\t    }\t  \n \t  /* Expand a short sequence inline, longer call a magic routine */\n \t  if (value <= 5)\n \t    {\n@@ -1626,6 +1707,7 @@ gen_shifty_op (code, operands)\n \n \t}\n     }\n+\n   return 0;\n }\n \n@@ -2413,6 +2495,17 @@ arith_operand (op, mode)\n }\n \n \n+/* Returns 1 if OP is a valid count operand for a shift operation. */\n+int \n+shiftby_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (immediate_operand (op, mode)) \n+    return 1;\n+  return 0;\n+}\n+\n /* Returns 1 if OP is a valid source operand for a logical operation. */\n \n int\n@@ -2515,6 +2608,8 @@ sh_function_arg_partial_nregs (CUM, MODE, TYPE, NAMED)\n   return 0;\n }\n \n+\n+\n /* Turn this on to recognise shift insns which aren't supported in the\n    hardware.  This will allow the combiner to notice more patterns,\n    but the down side is that the asm outputter will have to emit\n@@ -2525,3 +2620,4 @@ int fake_shift()\n {\n   return 0;\n }\n+"}, {"sha": "21351b21f3dfe57c0ce298e55332aab7acc2f268", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 61, "deletions": 34, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f8ff66e9db8007b9dd7cd0c1eee6c5939184d0/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f8ff66e9db8007b9dd7cd0c1eee6c5939184d0/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=00f8ff66e9db8007b9dd7cd0c1eee6c5939184d0", "patch": "@@ -41,8 +41,14 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #define SDB_DELIM \";\"\n \n+#define CPP_SPEC \"%{ml:-D__LITTLE_ENDIAN__}\"\n+\n #define CPP_PREDEFINES \"-D__sh__ -Acpu(sh) -Amachine(sh)\"\n \n+#define ASM_SPEC  \"%{ml:-little}\"\n+\n+#define LINK_SPEC \"%{ml:-m shl}\"\n+\n /* Show we can debug even without a frame pointer.  */\n #define CAN_DEBUG_WITHOUT_FP\n \n@@ -93,6 +99,7 @@ extern int target_flags;\n #define BSR_BIT   \t(1<<26)\n #define SHORTADDR_BIT   (1<<27)\n #define PACKSTRUCT_BIT  (1<<28)\n+#define LITTLE_ENDIAN_BIT (1<<29)\n \n /* Nonzero if we should generate code using type 0 insns */\n #define TARGET_SH0 (target_flags & SH0_BIT)\n@@ -160,49 +167,58 @@ extern int target_flags;\n /* Nonzero if packing structures as small as they'll go (incompatible with Hitachi's compiler) */\n #define TARGET_PACKSTRUCT       (target_flags & PACKSTRUCT_BIT)\n \n-#define TARGET_SWITCHES  \t\t\\\n-{ {\"isize\", \t( ISIZE_BIT) },\t\t\\\n-  {\"space\", \t( SPACE_BIT) },\t\t\\\n-  {\"0\",\t        ( SH0_BIT) },\t\t\\\n-  {\"1\",\t        ( SH1_BIT) },\t\t\\\n-  {\"2\",\t        ( SH2_BIT) },\t\t\\\n-  {\"3\",\t        ( SH3_BIT) },\t\t\\\n-  {\"ac\",  \t( MAC_BIT) },\t\t\\\n-  {\"dalign\",  \t( DALIGN_BIT) },\t\\\n-  {\"c\",  \t( C_BIT) },\t\t\\\n-  {\"r\",  \t( RTL_BIT) },\t\t\\\n-  {\"bigtable\", \t( BIGTABLE_BIT)},\t\\\n-  {\"try-r0\", \t( TRYR0_BIT)},\t\t\\\n-  {\"R\",  \t( R_BIT) },\t\t\\\n-  {\"nosave\",  \t( NOSAVE_BIT) },\t\\\n-  {\"clen3\",     ( CONSTLEN_3_BIT) },    \\\n-  {\"clen0\",     ( CONSTLEN_0_BIT) },    \\\n-  {\"smallcall\",\t( SMALLCALL_BIT) },\t\\\n-  {\"hitachi\",\t( HITACHI_BIT) },\t\\\n-  {\"paranoid\",\t( PARANOID_BIT) },\t\\\n-  {\"r2\",\t( RETR2_BIT) },\t\t\\\n-  {\"shortaddr\", ( SHORTADDR_BIT) },     \\\n-  {\"bsr\",       ( BSR_BIT) },    \t\\\n-  {\"packstruct\",( PACKSTRUCT_BIT) },    \\\n-  {\"\",   \tTARGET_DEFAULT} \t\\\n+\n+#define TARGET_LITTLE_ENDIAN     (target_flags & LITTLE_ENDIAN_BIT)\n+\n+#define TARGET_SWITCHES  \t\t\t\\\n+{ {\"0\",\t        (SH0_BIT) },\t\t\t\\\n+  {\"1\",\t        (SH1_BIT) },\t\t\t\\\n+  {\"2\",\t        (SH2_BIT) },\t\t\t\\\n+  {\"3\",\t        (SH3_BIT) },\t\t\t\\\n+  {\"3l\",        (SH3_BIT|LITTLE_ENDIAN_BIT)},\t\\\n+  {\"R\",  \t(R_BIT) },\t\t\t\\\n+  {\"ac\",  \t(MAC_BIT) },\t\t\t\\\n+  {\"b\",\t\t(-LITTLE_ENDIAN_BIT) },  \t\\\n+  {\"bigtable\", \t(BIGTABLE_BIT)},\t\t\\\n+  {\"bsr\",       (BSR_BIT) },    \t\t\\\n+  {\"c\",  \t(C_BIT) },\t\t\t\\\n+  {\"clen0\",     (CONSTLEN_0_BIT) },    \t\t\\\n+  {\"clen3\",     (CONSTLEN_3_BIT) },    \t\t\\\n+  {\"dalign\",  \t(DALIGN_BIT) },\t\t\t\\\n+  {\"hitachi\",\t(HITACHI_BIT) },\t\t\\\n+  {\"isize\", \t(ISIZE_BIT) },\t\t\t\\\n+  {\"l\",\t\t(LITTLE_ENDIAN_BIT) },  \t\\\n+  {\"nosave\",  \t(NOSAVE_BIT) },\t\t\t\\\n+  {\"packstruct\",(PACKSTRUCT_BIT) },    \t\t\\\n+  {\"paranoid\",\t(PARANOID_BIT) },\t\t\\\n+  {\"r\",  \t(RTL_BIT) },\t\t\t\\\n+  {\"r2\",\t(RETR2_BIT) },\t\t\t\\\n+  {\"shortaddr\", (SHORTADDR_BIT) },\t     \t\\\n+  {\"smallcall\",\t(SMALLCALL_BIT) },\t\t\\\n+  {\"space\", \t(SPACE_BIT) },\t\t\t\\\n+  {\"try-r0\", \t(TRYR0_BIT)},\t\t\t\\\n+  {\"\",   \tTARGET_DEFAULT} \t\t\\\n }\n \n+\n #define TARGET_DEFAULT  (FAST_BIT)\n \n+\n /* Macro to define table for command options with values.  */\n #define TARGET_OPTIONS \\\n \t{ { \"maxsi-\", &max_si}, \\\n \t  { \"maxhi-\", &max_hi} }\n \n+\n #define OVERRIDE_OPTIONS \t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\\\n   sh_cpu = CPU_SH0;\t\t\t\t\t\t\\\n   if (TARGET_SH1)\t\t\t\t\t\t\\\n     sh_cpu = CPU_SH1;\t\t\t\t\t\t\\\n   if (TARGET_SH2)\t\t\t\t\t\t\\\n     sh_cpu = CPU_SH2;\t\t\t\t\t\t\\\n-  if (TARGET_SH3)\t\t\t\t\t\t\\\n-    sh_cpu = CPU_SH3;\t\t\t\t\t\t\\\n+ if (TARGET_SH3)\t\t\t\t\t\t\\\n+    sh_cpu = CPU_SH3|CPU_SH2;\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n   /*  We *MUST* always define optimize since we *HAVE* to run   \\\n       shorten branches to get correct code. */                  \\\n@@ -234,14 +250,25 @@ do {\t\t\t\t\t\t\t\t\\\n \n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.  */\n+\n #define BITS_BIG_ENDIAN  0\n \n+\n /* Define this if most significant byte of a word is the lowest numbered.  */\n-#define BYTES_BIG_ENDIAN 1\n+#define BYTES_BIG_ENDIAN (TARGET_LITTLE_ENDIAN == 0)\n \n /* Define this if most significant word of a multiword number is the lowest\n    numbered.  */\n-#define WORDS_BIG_ENDIAN 1\n+#define WORDS_BIG_ENDIAN (TARGET_LITTLE_ENDIAN == 0)\n+\n+\n+/* Define this to set the endianness to use in libgcc2.c, which can\n+   not depend on target_flags.  */\n+#if defined(__LITTLE_ENDIAN__)\n+#define LIBGCC2_WORDS_BIG_ENDIAN 0\n+#else\n+#define LIBGCC2_WORDS_BIG_ENDIAN 1\n+#endif\n \n /* Number of bits in an addressable storage unit */\n #define BITS_PER_UNIT  8\n@@ -1156,7 +1183,7 @@ extern int current_function_anonymous_args;\n   case UDIV:\t\t\t\t\t\t\\\n   case MOD:\t\t\t\t\t\t\\\n   case UMOD:\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (100);\t\t\t\t\\\n+    return COSTS_N_INSNS (20);\t\t\t\t\\\n   case FLOAT:\t\t\t\t\t\t\\\n   case FIX:\t\t\t\t\t\t\\\n     return 100;\n@@ -1492,7 +1519,7 @@ extern char *output_far_jump();\n extern int pragma_interrupt;\n #define MOVE_RATIO (TARGET_SMALLCODE ? 4 : 16)\n \n-char *max_si;\n-char *max_hi;\n-int max_count_si;\n-int max_count_hi;\n+extern char *max_si;\n+extern char *max_hi;\n+extern int max_count_si;\n+extern int max_count_hi;"}, {"sha": "f009d8c352af4d41cf0abb4003246b4ab461c4f7", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 73, "deletions": 46, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f8ff66e9db8007b9dd7cd0c1eee6c5939184d0/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f8ff66e9db8007b9dd7cd0c1eee6c5939184d0/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=00f8ff66e9db8007b9dd7cd0c1eee6c5939184d0", "patch": "@@ -33,8 +33,8 @@\n ;;   %*  --  print a local label\n ;;   %^  --  increment the local label number\n ;;   %#  --  output a nop if there is nothing to put in the delay slot\n-;;   %R  --  print the next register or memory location along, ie the lsw in\n-;;           a double word value\n+;;   %R  --  print the lsw arg of a double, \n+;;   %S  --  print the msw arg of a double\n ;;   %O  --  print a constant without the #\n ;;   %M  --  print a constant as its negative\n ;;\n@@ -128,9 +128,9 @@\n ;; (define_function_unit {name} {num-units} {n-users} {test}\n ;;                       {ready-delay} {issue-delay} [{conflict-list}])\n \t\t\t\t      \n-(define_function_unit \"memory\" 1 0 (eq_attr \"type\" \"load,pcloadsi,pcloadhi\") 2 0)\n-(define_function_unit \"mpy\"    1 0 (eq_attr \"type\" \"smpy\") 3 0)\n-(define_function_unit \"mpy\"    1 0 (eq_attr \"type\" \"dmpy\") 5 0)\n+(define_function_unit \"memory\" 1 0 (eq_attr \"type\" \"load,pcloadsi,pcloadhi\") 2 2)\n+(define_function_unit \"mpy\"    1 0 (eq_attr \"type\" \"smpy\") 7 7)\n+(define_function_unit \"mpy\"    1 0 (eq_attr \"type\" \"dmpy\") 9 9)\n \n (define_attr \"needs_delay_slot\" \"yes,no\"\n   (cond [(eq_attr \"type\" \"jump\")   (const_string \"yes\")\n@@ -151,7 +151,7 @@\n \n (define_delay \n   (and (eq_attr \"type\" \"cbranch\") \n-       (eq_attr \"cpu\" \"sh2\"))\n+       (eq_attr \"cpu\" \"sh2,sh3\"))\n   [(eq_attr \"in_delay_slot\" \"yes\") (nil) (nil)])\n \n (define_attr \"in_delay_slot\" \"maybe,yes,no\" \n@@ -270,7 +270,7 @@\n \t\t (match_operand:DI 2 \"register_operand\" \"r\")))\n    (clobber (reg:SI 18))]\n   \"\"\n-  \"clrt\\;addc\t%R2,%R0\\;addc\t%2,%0\"\n+  \"clrt\\;addc\t%R2,%R0\\;addc\t%S2,%S0\"\n   [(set_attr \"length\" \"6\")])\n \n \n@@ -302,7 +302,7 @@\n \t\t (match_operand:DI 2 \"register_operand\" \"r\")))\n    (clobber (reg:SI 18))]\n   \"\"\n-  \"clrt\\;subc\t%R2,%R0\\;subc\t%2,%0\"\n+  \"clrt\\;subc\t%R2,%R0\\;subc\t%S2,%S0\"\n   [(set_attr \"length\" \"6\")])\n \n (define_insn \"subsi3\"\n@@ -488,11 +488,12 @@\n   \"TARGET_SH2\"\n   \"\")\n \n+\n (define_insn \"\"\n   [(set (reg:DI 20)\n \t(mult:DI (sign_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n \t\t (sign_extend:DI (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))]\n-  \"TARGET_SH2\"\n+  \"(TARGET_SH2) && 0\"\n   \"dmuls.l\t%2,%1\"\n   [(set_attr \"type\" \"dmpy\")])\n \n@@ -502,14 +503,14 @@\n \t\t (sign_extend:DI (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))\n    (set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n \t(reg:DI 20))]\n-  \"TARGET_SH2\"\n+  \"(TARGET_SH2) && 0\"\n   \"\")\n \n (define_insn \"\"\n   [(set (reg:DI 20)\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n \t\t (zero_extend:DI (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))]\n-  \"TARGET_SH2\"\n+  \"(TARGET_SH2) && 0\"\n   \"dmulu.l\t%2,%1\"\n   [(set_attr \"type\" \"dmpy\")])\n \n@@ -519,7 +520,7 @@\n \t\t (zero_extend:DI (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))\n    (set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n \t(reg:DI 20))]\n-  \"TARGET_SH2\"\n+  \"(TARGET_SH2) && 0\"\n   \"\")\n \n \f\n@@ -614,6 +615,8 @@\n ;;\n ;; shift left\n \n+\n+\n (define_insn \"ashlsi3_k\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,r\")\n \t(ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"0,0\")\n@@ -643,7 +646,7 @@\n (define_expand \"ashlsi3\"\n   [(parallel[(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n \t\t  (ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n-\t\t\t     (match_operand:SI 2 \"immediate_operand\" \"\")))\n+\t\t\t     (match_operand:SI 2 \"shiftby_operand\" \"\")))\n \t     (clobber (reg:SI 18))])]\n   \"\"\n   \"if (gen_shifty_op (ASHIFT, operands)) DONE; else FAIL;\")\n@@ -661,15 +664,6 @@\n   \"shar\t%0\"\n   [(set_attr \"type\" \"arith\")])\n \n-(define_insn \"ashrsi3_16\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))\n-   (clobber (reg:SI 18))]\n-  \"INTVAL(operands[2]) == 16\"\n-  \"shlr16\t%0\\;exts.w\t%0,%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"length\" \"4\")])\n \n ; an arithmetic shift right by 16 is better as a logical shift and a \n ; sign extend\n@@ -685,6 +679,25 @@\n ;    (set (match_dup 0) (sign_extend:SI (subreg:HI (match_dup 3) 0)))]\n ;  \"operands[3] = gen_reg_rtx (SImode);\")\n \n+(define_insn \"ashrsi2_16\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t\t\t  (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t\t       (const_int 16)))\n+\t     (clobber (reg:SI 18))]\n+  \"\"\n+  \"shlr16\t%0\\;exts.w\t%0,%0\"\n+  [(set_attr \"length\" \"4\")])\n+\n+\n+(define_insn \"ashrsi2_31\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t     (const_int 31)))]\n+  \"\"\n+  \"shal\t%0\\;subc\t%0,%0\"\n+  [(set_attr \"length\" \"4\")])\n+\n+\n (define_insn \"ashrsi3_n\"\n   [(set (reg:SI 4)\n \t(ashiftrt:SI (reg:SI 4)\n@@ -710,6 +723,7 @@\n ; logical shift right\n ;\n \n+\n (define_insn \"lshrsi3_k\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,r\")\n \t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0,0\")\n@@ -736,7 +750,7 @@\n (define_expand \"lshrsi3\"\n   [(parallel[(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n \t\t  (lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n-\t\t\t       (match_operand:SI 2 \"immediate_operand\" \"\")))\n+\t\t\t       (match_operand:SI 2 \"shiftby_operand\" \"\")))\n \t     (clobber (reg:SI 18))])]\n   \"\"\n   \"if (gen_shifty_op (LSHIFTRT, operands)) DONE; else FAIL;\") \n@@ -747,7 +761,7 @@\n \t\t   (const_int 1)))\n    (clobber (reg:SI 18))]\n   \"\"\n-  \"shll\t%R0\\;rotcl\t%0\"\n+  \"shll\t%R0\\;rotcl\t%S0\"\n   [(set_attr \"length\" \"4\")])\n \n (define_expand \"ashldi3\"\n@@ -766,7 +780,7 @@\n \t\t     (const_int 1)))\n    (clobber (reg:SI 18))]\n   \"\"\n-  \"shlr\t%0\\;rotcr\t%R0\"\n+  \"shlr\t%S0\\;rotcr\t%R0\"\n   [(set_attr \"length\" \"4\")])\n \n (define_expand \"lshrdi3\"\n@@ -784,7 +798,7 @@\n \t\t     (const_int 1)))\n    (clobber (reg:SI 18))]\n   \"\"\n-  \"shar\t%0\\;rotcr\t%R0\"\n+  \"shar\t%S0\\;rotcr\t%R0\"\n   [(set_attr \"length\" \"4\")])\n \n (define_expand \"ashrdi3\"\n@@ -876,18 +890,16 @@\n ;; -------------------------------------------------------------------------\n \n (define_insn \"extendsidi2\"\n-  [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r,r\")\n-\t(sign_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"0,r\")))\n+  [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n+\t(sign_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (clobber (reg:SI 18))]\n   \"\"\n-  \"@\n-\tmov\t%1,%0\\;shll\t%0\\;subc\t%0,%0 ! b sidi2\n-\tmov\t%1,%0\\;mov\t%1,%R0\\;shll\t%0\\;subc\t%0,%0 ! a sidi2\"\n-  [(set_attr \"length\" \"6,8\")]) \n+  \"mov\t%1,%S0\\;mov\t%1,%R0\\;shll\t%S0\\;subc\t%S0,%S0 ! a sidi2\"\n+  [(set_attr \"length\" \"8\")]) \n \n (define_insn \"extendhisi2\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,z,r\")\n-\t(sign_extend:SI (match_operand:HI 1 \"arith_operand\" \"r,u,m\")))]\n+\t(sign_extend:SI (match_operand:HI 1 \"general_movsrc_operand\" \"r,u,m\")))]\n   \"\"\n   \"@\n \texts.w\t%1,%0\n@@ -1046,7 +1058,7 @@\n   [(set (match_operand:DI 0 \"push_operand\" \"=<\")\n \t(match_operand:DI 1 \"arith_reg_operand\" \"r\"))]\n    \"\"\n-   \"mov.l\t%R1,%0\\;mov.l\t%1,%0\"\n+   \"mov.l\t%T1,%0\\;mov.l\t%01,%0\"\n    [(set_attr \"length\" \"4\")\n     (set_attr \"type\" \"store\")])\n \n@@ -1109,7 +1121,7 @@\n   [(set (match_operand:DF 0 \"push_operand\" \"=<\")\n \t(match_operand:DF 1 \"arith_reg_operand\" \"r\"))]\n    \"\"\n-  \"mov.l\t%R1,%0\\;mov.l\t%1,%0\"\n+  \"mov.l\t%T1,%0\\;mov.l\t%1,%0\"\n    [(set_attr \"length\" \"4\")\n     (set_attr \"type\" \"store\")])\n \n@@ -1434,17 +1446,17 @@\n ;; Misc insns\n ;; ------------------------------------------------------------------------\n \n-(define_insn \"dect\"\n-  [(parallel[\n-\t     (set (reg:SI 18)\n-\t\t  (eq:SI (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t\t\t (const_int 1)))\n-\n-\t     (set (match_dup 0)\n-\t\t  (plus:SI (match_dup 0)\n-\t\t\t   (const_int -1)))])]\n-  \"TARGET_SH2\"\n-  \"dt\t%0\")\n+;(define_insn \"dect\"\n+;  [(parallel[\n+;\t     (set (match_dup 0)\n+;\t\t  (plus:SI (match_dup 0)\n+;\t\t\t   (const_int -1)))\n+;\n+;\t     (set (reg:SI 18)\n+;\t\t  (eq:SI (match_operand:SI 0 \"register_operand\" \"=r\")\n+;\t\t\t (const_int 0)))])]\n+;  \"TARGET_SH2\"\n+;  \"dt\t%0\")\n \n (define_insn \"nop\"\n   [(const_int 0)]\n@@ -1918,3 +1930,18 @@\n \n \n \t\t\t\n+\n+\n+(define_peephole \n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int -1)))\n+   (set (reg:SI 18)\n+\t(eq:SI (match_dup 0)\n+\t       (const_int 0)))]\n+  \"TARGET_SH2\"\n+  \"dt\t%0\")\n+  \n+\t\n+\t\n+\t"}, {"sha": "c2462a092d792522cf54bb78c65077b8481691bc", "filename": "gcc/config/sh/t-sh", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f8ff66e9db8007b9dd7cd0c1eee6c5939184d0/gcc%2Fconfig%2Fsh%2Ft-sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f8ff66e9db8007b9dd7cd0c1eee6c5939184d0/gcc%2Fconfig%2Fsh%2Ft-sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Ft-sh?ref=00f8ff66e9db8007b9dd7cd0c1eee6c5939184d0", "patch": "@@ -26,3 +26,8 @@ fp-bit.c: $(srcdir)/config/fp-bit.c\n \tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n \n \n+MULTILIB_OPTIONS=ml\n+MULTILIB_DIRNAMES=ml\n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib"}]}