{"sha": "5e20bdd7298dfa02e6908bbba92bfd7e3e994025", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUyMGJkZDcyOThkZmEwMmU2OTA4YmJiYTkyYmZkN2UzZTk5NDAyNQ==", "commit": {"author": {"name": "Josef Zlomek", "email": "zlomekj@suse.cz", "date": "2004-02-22T18:48:42Z"}, "committer": {"name": "Josef Zlomek", "email": "zlomek@gcc.gnu.org", "date": "2004-02-22T18:48:42Z"}, "message": "backport: tree-inline.c (insert_decl_map): New.\n\n\tMerge from tree-ssa:\n\t2003-11-20  Richard Henderson  <rth@redhat.com>\n\n\t\t* tree-inline.c (insert_decl_map): New.\n\t\t(remap_decl, remap_type, remap_block, copy_body_r,\n\t\tinitialize_inlined_parameters, declare_return_variable,\n\t\tremap_save_expr): Use it.\n\n\t* function.c (copy_body_r): Add mapping from id->ret_label to\n\tid->ret_label.  Revert test for ret_label.\n\nFrom-SVN: r78271", "tree": {"sha": "5f5511f07c8544a8b9bfd213ad562f328330c34c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f5511f07c8544a8b9bfd213ad562f328330c34c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e20bdd7298dfa02e6908bbba92bfd7e3e994025", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e20bdd7298dfa02e6908bbba92bfd7e3e994025", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e20bdd7298dfa02e6908bbba92bfd7e3e994025", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e20bdd7298dfa02e6908bbba92bfd7e3e994025/comments", "author": null, "committer": null, "parents": [{"sha": "4112be4ad381448094bc3c5d7c3c3b1ed8c48615", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4112be4ad381448094bc3c5d7c3c3b1ed8c48615", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4112be4ad381448094bc3c5d7c3c3b1ed8c48615"}], "stats": {"total": 88, "additions": 53, "deletions": 35}, "files": [{"sha": "77442759de7c14cf1552d6c9cc803d7512ae8af9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20bdd7298dfa02e6908bbba92bfd7e3e994025/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20bdd7298dfa02e6908bbba92bfd7e3e994025/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e20bdd7298dfa02e6908bbba92bfd7e3e994025", "patch": "@@ -1,3 +1,16 @@\n+2004-02-22  Josef Zlomek  <zlomekj@suse.cz>\n+\n+\tMerge from tree-ssa:\n+\t2003-11-20  Richard Henderson  <rth@redhat.com>\n+\n+\t\t* tree-inline.c (insert_decl_map): New.\n+\t\t(remap_decl, remap_type, remap_block, copy_body_r,\n+\t\tinitialize_inlined_parameters, declare_return_variable,\n+\t\tremap_save_expr): Use it.\n+\n+\t* function.c (copy_body_r): Add mapping from id->ret_label to\n+\tid->ret_label.  Revert test for ret_label.\n+\n 2004-02-22  Jakub Jelinek  <jakub@redhat.com>\n \n \t* genoutput.c (process_template): Strip trailing whitespace in @"}, {"sha": "3ef97051ebc09d7e9a1d164f0ebfcfc69e8099f7", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 40, "deletions": 35, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20bdd7298dfa02e6908bbba92bfd7e3e994025/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20bdd7298dfa02e6908bbba92bfd7e3e994025/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=5e20bdd7298dfa02e6908bbba92bfd7e3e994025", "patch": "@@ -128,6 +128,22 @@ static void remap_block (tree *, tree, inline_data *);\n static tree add_stmt_to_compound (tree, tree, tree);\n #endif /* INLINER_FOR_JAVA */\n \n+/* Insert a tree->tree mapping for ID.  Despite the name suggests\n+   that the trees should be variables, it is used for more than that.  */\n+\n+static void\n+insert_decl_map (inline_data *id, tree key, tree value)\n+{\n+  splay_tree_insert (id->decl_map, (splay_tree_key) key,\n+\t\t     (splay_tree_value) value);\n+\n+  /* Always insert an identity map as well.  If we see this same new\n+     node again, we won't want to duplicate it a second time.  */\n+  if (key != value)\n+    splay_tree_insert (id->decl_map, (splay_tree_key) value,\n+\t\t       (splay_tree_value) value);\n+}\n+\n /* Remap DECL during the copying of the BLOCK tree for the function.  */\n \n static tree\n@@ -189,9 +205,8 @@ remap_decl (tree decl, inline_data *id)\n \n       /* Remember it, so that if we encounter this local entity\n \t again we can reuse this copy.  */\n-      n = splay_tree_insert (id->decl_map,\n-\t\t\t     (splay_tree_key) decl,\n-\t\t\t     (splay_tree_value) t);\n+      insert_decl_map (id, decl, t);\n+      return t;\n     }\n \n   return (tree) n->value;\n@@ -214,15 +229,13 @@ remap_type (tree type, inline_data *id)\n   /* The type only needs remapping if it's variably modified.  */\n   if (! variably_modified_type_p (type))\n     {\n-      splay_tree_insert (id->decl_map, (splay_tree_key) type,\n-\t\t\t (splay_tree_value) type);\n+      insert_decl_map (id, type, type);\n       return type;\n     }\n   \n   /* We do need a copy.  build and register it now.  */\n   new = copy_node (type);\n-  splay_tree_insert (id->decl_map, (splay_tree_key) type,\n-\t\t     (splay_tree_value) new);\n+  insert_decl_map (id, type, new);\n \n   /* This is a new type, not a copy of an old type.  Need to reassociate\n      variants.  We can handle everything except the main variant lazily.  */\n@@ -392,9 +405,7 @@ remap_block (tree *block, tree decls, inline_data *id)\n \t  *first_block = new_block;\n \t}\n       /* Remember the remapped block.  */\n-      splay_tree_insert (id->decl_map,\n-\t\t\t (splay_tree_key) old_block,\n-\t\t\t (splay_tree_value) new_block);\n+      insert_decl_map (id, old_block, new_block);\n     }\n   /* If this is the end of a scope, set the SCOPE_STMT_BLOCK to be the\n      remapped block.  */\n@@ -568,15 +579,16 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n       /* If we're not returning anything just do the jump.  */\n       else\n \t*tp = goto_stmt;\n+\n+      /* We can't replace return label while inlining function\n+\t because it is in the outer function.  */\n+      insert_decl_map (id, id->ret_label, id->ret_label);\n     }\n   /* Local variables and labels need to be replaced by equivalent\n      variables.  We don't want to copy static variables; there's only\n      one of those, no matter how many times we inline the containing\n-     function.\n-     We do not also want to copy the label which we put into\n-     GOTO_STMT which replaced RETURN_STMT.  */\n-  else if (*tp != id->ret_label\n-\t   && (*lang_hooks.tree_inlining.auto_var_in_fn_p) (*tp, fn))\n+     function.  */\n+  else if ((*lang_hooks.tree_inlining.auto_var_in_fn_p) (*tp, fn))\n     {\n       tree new_decl;\n \n@@ -611,9 +623,7 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n          will refer to it, so save a copy ready for remapping.  We\n          save it in the decl_map, although it isn't a decl.  */\n       tree new_block = copy_node (*tp);\n-      splay_tree_insert (id->decl_map,\n-\t\t\t (splay_tree_key) *tp,\n-\t\t\t (splay_tree_value) new_block);\n+      insert_decl_map (id, *tp, new_block);\n       *tp = new_block;\n     }\n   else if (TREE_CODE (*tp) == EXIT_BLOCK_EXPR)\n@@ -784,9 +794,7 @@ DECL_ARGUMENTS (fn);\n \t      else if (TREE_TYPE (value) != TREE_TYPE (p))\n \t\tvalue = fold (build1 (NOP_EXPR, TREE_TYPE (p), value));\n \n-\t      splay_tree_insert (id->decl_map,\n-\t\t\t\t (splay_tree_key) p,\n-\t\t\t\t (splay_tree_value) value);\n+\t      insert_decl_map (id, p, value);\n \t      continue;\n \t    }\n \t}\n@@ -807,9 +815,7 @@ DECL_ARGUMENTS (fn);\n       /* Register the VAR_DECL as the equivalent for the PARM_DECL;\n \t that way, when the PARM_DECL is encountered, it will be\n \t automatically replaced by the VAR_DECL.  */\n-      splay_tree_insert (id->decl_map,\n-\t\t\t (splay_tree_key) p,\n-\t\t\t (splay_tree_value) var_sub);\n+      insert_decl_map (id, p, var_sub);\n \n       /* Declare this new variable.  */\n #ifndef INLINER_FOR_JAVA\n@@ -947,9 +953,7 @@ declare_return_variable (struct inline_data *id, tree return_slot_addr,\n   /* Register the VAR_DECL as the equivalent for the RESULT_DECL; that\n      way, when the RESULT_DECL is encountered, it will be\n      automatically replaced by the VAR_DECL.  */\n-  splay_tree_insert (id->decl_map,\n-\t\t     (splay_tree_key) result,\n-\t\t     (splay_tree_value) var);\n+  insert_decl_map (id, result, var);\n \n   /* Build the USE_STMT.  If the return type of the function was\n      promoted, convert it back to the expected type.  */\n@@ -2005,34 +2009,35 @@ remap_save_expr (tree *tp, void *st_, tree fn, int *walk_subtrees)\n {\n   splay_tree st = (splay_tree) st_;\n   splay_tree_node n;\n+  tree t;\n \n   /* See if we already encountered this SAVE_EXPR.  */\n   n = splay_tree_lookup (st, (splay_tree_key) *tp);\n \n   /* If we didn't already remap this SAVE_EXPR, do so now.  */\n   if (!n)\n     {\n-      tree t = copy_node (*tp);\n+      t = copy_node (*tp);\n \n       /* The SAVE_EXPR is now part of the function into which we\n \t are inlining this body.  */\n       SAVE_EXPR_CONTEXT (t) = fn;\n       /* And we haven't evaluated it yet.  */\n       SAVE_EXPR_RTL (t) = NULL_RTX;\n       /* Remember this SAVE_EXPR.  */\n-      n = splay_tree_insert (st,\n-\t\t\t     (splay_tree_key) *tp,\n-\t\t\t     (splay_tree_value) t);\n+      splay_tree_insert (st, (splay_tree_key) *tp, (splay_tree_value) t);\n       /* Make sure we don't remap an already-remapped SAVE_EXPR.  */\n       splay_tree_insert (st, (splay_tree_key) t, (splay_tree_value) t);\n     }\n   else\n-    /* We've already walked into this SAVE_EXPR, so we needn't do it\n-       again.  */\n-    *walk_subtrees = 0;\n+    {\n+      /* We've already walked into this SAVE_EXPR; don't do it again.  */\n+      *walk_subtrees = 0;\n+      t = (tree) n->value;\n+    }\n \n   /* Replace this SAVE_EXPR with the copy.  */\n-  *tp = (tree) n->value;\n+  *tp = t;\n }\n \n #ifdef INLINER_FOR_JAVA"}]}