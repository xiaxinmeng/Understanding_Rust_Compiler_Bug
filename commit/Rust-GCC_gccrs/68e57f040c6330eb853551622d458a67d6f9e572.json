{"sha": "68e57f040c6330eb853551622d458a67d6f9e572", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhlNTdmMDQwYzYzMzBlYjg1MzU1MTYyMmQ0NThhNjdkNmY5ZTU3Mg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-10-08T16:49:24Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-10-08T16:49:24Z"}, "message": "Make tree_expr_nonnegative_warnv_p recurse into SSA names\n\nThe upcoming patch to move sqrt and cbrt simplifications to match.pd\ncaused a regression because the (abs @0)->@0 simplification didn't\ntrigger for:\n\n        (abs (convert (abs X)))\n\nThe simplification is based on tree_expr_nonnegative_p, which at\nthe moment just gives up if it sees an SSA_NAME.\n\nThis patch makes tree_expr_nonnegative_p recurse into SSA name\ndefinitions, but limits the depth of recursion to a small number\nfor the reason mentioned in the comment (adapted from an existing\ncomment in gimple_val_nonnegative_real_p).  The patch reuses code\nin tree-vrp.c, moving it to gimple-fold.c.  It also replaces calls\nto gimple_val_nonnegative_real_p with calls to tree_expr_nonnegative_p.\n\nA knock-on effect is that we can now prove _i_589 < 0 is false in\nsequences like:\n\n      i_1917 = ASSERT_EXPR <i_1075, i_1075 == 0>;\n      _i_589 = (const int) i_1917;\n      _i_1507 = ASSERT_EXPR <_i_589, _i_589 < 0>;\n\nThis defeats an assert in tree-vrp.c that ASSERT_EXPR conditions\nare never known to be false.  Previously the assert only ever used\nlocal knowledge and so would be limited to cases like x != x for\ninteger x.  Now that we use global knowledge it's possible to prove\nthe assertion condition is false in blocks that are in practice\nunreachable.  The patch therefore removes the assert.\n\nBootstrapped & regression-tested on x86_64-linux-gnu.  I didn't write\na specific test because this is already covered by the testsuite if\nthe follow-on patch is also applied.\n\ngcc/\n\t* params.def (PARAM_MAX_SSA_NAME_QUERY_DEPTH): New param.\n\t* doc/invoke.texi (--param max-ssa-name-query-depth): Document.\n\t* fold-const.h (tree_unary_nonnegative_warnv_p)\n\t(tree_single_nonnegative_warnv_p, tree_call_nonnegative_warnv_p)\n\t(tree_expr_nonnegative_warnv_p): Add depth parameters.\n\t* fold-const.c: Include gimple-fold.h and params.h.\n\t(tree_ssa_name_nonnegative_warnv_p): New function.\n\t(tree_unary_nonnegative_warnv_p, tree_binary_nonnegative_warnv_p)\n\t(tree_single_nonnegative_warnv_p, tree_call_nonnegative_warnv_p)\n\t(tree_invalid_nonnegative_warnv_p, tree_expr_nonnegative_warnv_p):\n\tAdd a depth parameter and increment it for recursive calls to\n\ttree_expr_nonnegative_warnv_p.  Use tree_ssa_name_nonnegative_warnv_p\n\tto handle SSA names.\n\t* gimple-fold.h (gimple_val_nonnegative_real_p): Delete.\n\t(gimple_stmt_nonnegative_warnv_p): Declare.\n\t* tree-vrp.c (remove_range_assertions): Remove assert that condition\n\tcannot be proven false.\n\t(gimple_assign_nonnegative_warnv_p, gimple_call_nonnegative_warnv_p)\n\t(gimple_stmt_nonnegative_warnv_p): Move to...\n\t* gimple-fold.c: ...here.  Add depth parameters and pass them\n\tdown to the tree routines.  Accept statements that aren't\n\tassignments or calls but just return false for them.\n\t(gimple_val_nonnegative_real_p): Delete.\n\t* tree-ssa-math-opts.c (gimple_expand_builtin_pow): Use\n\ttree_expr_nonnegative_p instead of gimple_val_nonnegative_real_p.\n\tCheck HONOR_NANs first.\n\nFrom-SVN: r228614", "tree": {"sha": "61678cfe315bf4f20ccae0603f837d13eeab72a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61678cfe315bf4f20ccae0603f837d13eeab72a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68e57f040c6330eb853551622d458a67d6f9e572", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68e57f040c6330eb853551622d458a67d6f9e572", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68e57f040c6330eb853551622d458a67d6f9e572", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68e57f040c6330eb853551622d458a67d6f9e572/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "170f473b525d0af69dc4577186762a3519b952a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/170f473b525d0af69dc4577186762a3519b952a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/170f473b525d0af69dc4577186762a3519b952a4"}], "stats": {"total": 516, "additions": 212, "deletions": 304}, "files": [{"sha": "4416f5c5582974b92cefc7cb1a7b4ea0641dd000", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e57f040c6330eb853551622d458a67d6f9e572/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e57f040c6330eb853551622d458a67d6f9e572/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68e57f040c6330eb853551622d458a67d6f9e572", "patch": "@@ -1,3 +1,32 @@\n+2015-10-08  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* params.def (PARAM_MAX_SSA_NAME_QUERY_DEPTH): New param.\n+\t* doc/invoke.texi (--param max-ssa-name-query-depth): Document.\n+\t* fold-const.h (tree_unary_nonnegative_warnv_p)\n+\t(tree_single_nonnegative_warnv_p, tree_call_nonnegative_warnv_p)\n+\t(tree_expr_nonnegative_warnv_p): Add depth parameters.\n+\t* fold-const.c: Include gimple-fold.h and params.h.\n+\t(tree_ssa_name_nonnegative_warnv_p): New function.\n+\t(tree_unary_nonnegative_warnv_p, tree_binary_nonnegative_warnv_p)\n+\t(tree_single_nonnegative_warnv_p, tree_call_nonnegative_warnv_p)\n+\t(tree_invalid_nonnegative_warnv_p, tree_expr_nonnegative_warnv_p):\n+\tAdd a depth parameter and increment it for recursive calls to\n+\ttree_expr_nonnegative_warnv_p.  Use tree_ssa_name_nonnegative_warnv_p\n+\tto handle SSA names.\n+\t* gimple-fold.h (gimple_val_nonnegative_real_p): Delete.\n+\t(gimple_stmt_nonnegative_warnv_p): Declare.\n+\t* tree-vrp.c (remove_range_assertions): Remove assert that condition\n+\tcannot be proven false.\n+\t(gimple_assign_nonnegative_warnv_p, gimple_call_nonnegative_warnv_p)\n+\t(gimple_stmt_nonnegative_warnv_p): Move to...\n+\t* gimple-fold.c: ...here.  Add depth parameters and pass them\n+\tdown to the tree routines.  Accept statements that aren't\n+\tassignments or calls but just return false for them.\n+\t(gimple_val_nonnegative_real_p): Delete.\n+\t* tree-ssa-math-opts.c (gimple_expand_builtin_pow): Use\n+\ttree_expr_nonnegative_p instead of gimple_val_nonnegative_real_p.\n+\tCheck HONOR_NANs first.\n+\n 2015-10-08  Martin Jambor  <mjambor@suse.cz>\n \n \t* ipa-cp.c (meet_with_1): Make the argument of abs signed.  Remove"}, {"sha": "1b44b444cbe3e907269d3debf596c948b87fdb81", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e57f040c6330eb853551622d458a67d6f9e572/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e57f040c6330eb853551622d458a67d6f9e572/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=68e57f040c6330eb853551622d458a67d6f9e572", "patch": "@@ -11132,6 +11132,10 @@ automaton.  The default is 50.\n Chunk size of omp schedule for loops parallelized by parloops.  The default\n is 0.\n \n+@item max-ssa-name-query-depth\n+Maximum depth of recursion when querying properties of SSA names in things\n+like fold routines.  One level of recursion corresponds to following a\n+use-def chain.\n @end table\n @end table\n "}, {"sha": "5d8822fde8e89b0d661eda8a2264ede45332692e", "filename": "gcc/fold-const.c", "status": "modified", "additions": 84, "deletions": 87, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e57f040c6330eb853551622d458a67d6f9e572/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e57f040c6330eb853551622d458a67d6f9e572/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=68e57f040c6330eb853551622d458a67d6f9e572", "patch": "@@ -77,6 +77,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"generic-match.h\"\n #include \"optabs-query.h\"\n+#include \"gimple-fold.h\"\n+#include \"params.h\"\n \n #ifndef LOAD_EXTEND_OP\n #define LOAD_EXTEND_OP(M) UNKNOWN\n@@ -12749,6 +12751,12 @@ multiple_of_p (tree type, const_tree top, const_tree bottom)\n     }\n }\n \n+#define tree_expr_nonnegative_warnv_p(X, Y) \\\n+  _Pragma (\"GCC error \\\"Use RECURSE for recursive calls\\\"\") 0\n+\n+#define RECURSE(X) \\\n+  ((tree_expr_nonnegative_warnv_p) (X, strict_overflow_p, depth + 1))\n+\n /* Return true if CODE or TYPE is known to be non-negative. */\n \n static bool\n@@ -12765,11 +12773,11 @@ tree_simple_nonnegative_warnv_p (enum tree_code code, tree type)\n /* Return true if (CODE OP0) is known to be non-negative.  If the return\n    value is based on the assumption that signed overflow is undefined,\n    set *STRICT_OVERFLOW_P to true; otherwise, don't change\n-   *STRICT_OVERFLOW_P.  */\n+   *STRICT_OVERFLOW_P.  DEPTH is the current nesting depth of the query.  */\n \n bool\n tree_unary_nonnegative_warnv_p (enum tree_code code, tree type, tree op0,\n-\t\t\t\tbool *strict_overflow_p)\n+\t\t\t\tbool *strict_overflow_p, int depth)\n {\n   if (TYPE_UNSIGNED (type))\n     return true;\n@@ -12791,8 +12799,7 @@ tree_unary_nonnegative_warnv_p (enum tree_code code, tree type, tree op0,\n     case NON_LVALUE_EXPR:\n     case FLOAT_EXPR:\n     case FIX_TRUNC_EXPR:\n-      return tree_expr_nonnegative_warnv_p (op0,\n-\t\t\t\t\t    strict_overflow_p);\n+      return RECURSE (op0);\n \n     CASE_CONVERT:\n       {\n@@ -12802,21 +12809,18 @@ tree_unary_nonnegative_warnv_p (enum tree_code code, tree type, tree op0,\n \tif (TREE_CODE (outer_type) == REAL_TYPE)\n \t  {\n \t    if (TREE_CODE (inner_type) == REAL_TYPE)\n-\t      return tree_expr_nonnegative_warnv_p (op0,\n-\t\t\t\t\t\t    strict_overflow_p);\n+\t      return RECURSE (op0);\n \t    if (INTEGRAL_TYPE_P (inner_type))\n \t      {\n \t\tif (TYPE_UNSIGNED (inner_type))\n \t\t  return true;\n-\t\treturn tree_expr_nonnegative_warnv_p (op0,\n-\t\t\t\t\t\t      strict_overflow_p);\n+\t\treturn RECURSE (op0);\n \t      }\n \t  }\n \telse if (INTEGRAL_TYPE_P (outer_type))\n \t  {\n \t    if (TREE_CODE (inner_type) == REAL_TYPE)\n-\t      return tree_expr_nonnegative_warnv_p (op0,\n-\t\t\t\t\t\t    strict_overflow_p);\n+\t      return RECURSE (op0);\n \t    if (INTEGRAL_TYPE_P (inner_type))\n \t      return TYPE_PRECISION (inner_type) < TYPE_PRECISION (outer_type)\n \t\t      && TYPE_UNSIGNED (inner_type);\n@@ -12835,11 +12839,12 @@ tree_unary_nonnegative_warnv_p (enum tree_code code, tree type, tree op0,\n /* Return true if (CODE OP0 OP1) is known to be non-negative.  If the return\n    value is based on the assumption that signed overflow is undefined,\n    set *STRICT_OVERFLOW_P to true; otherwise, don't change\n-   *STRICT_OVERFLOW_P.  */\n+   *STRICT_OVERFLOW_P.  DEPTH is the current nesting depth of the query.  */\n \n bool\n tree_binary_nonnegative_warnv_p (enum tree_code code, tree type, tree op0,\n-\t\t\t\t      tree op1, bool *strict_overflow_p)\n+\t\t\t\t tree op1, bool *strict_overflow_p,\n+\t\t\t\t int depth)\n {\n   if (TYPE_UNSIGNED (type))\n     return true;\n@@ -12849,10 +12854,7 @@ tree_binary_nonnegative_warnv_p (enum tree_code code, tree type, tree op0,\n     case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n       if (FLOAT_TYPE_P (type))\n-\treturn (tree_expr_nonnegative_warnv_p (op0,\n-\t\t\t\t\t       strict_overflow_p)\n-\t\t&& tree_expr_nonnegative_warnv_p (op1,\n-\t\t\t\t\t\t  strict_overflow_p));\n+\treturn RECURSE (op0) && RECURSE (op1);\n \n       /* zero_extend(x) + zero_extend(y) is non-negative if x and y are\n \t both unsigned and at least 2 bits shorter than the result.  */\n@@ -12878,8 +12880,7 @@ tree_binary_nonnegative_warnv_p (enum tree_code code, tree type, tree op0,\n \t  /* x * x is always non-negative for floating point x\n \t     or without overflow.  */\n \t  if (operand_equal_p (op0, op1, 0)\n-\t      || (tree_expr_nonnegative_warnv_p (op0, strict_overflow_p)\n-\t\t  && tree_expr_nonnegative_warnv_p (op1, strict_overflow_p)))\n+\t      || (RECURSE (op0) && RECURSE (op1)))\n \t    {\n \t      if (ANY_INTEGRAL_TYPE_P (type)\n \t\t  && TYPE_OVERFLOW_UNDEFINED (type))\n@@ -12928,10 +12929,7 @@ tree_binary_nonnegative_warnv_p (enum tree_code code, tree type, tree op0,\n \n     case BIT_AND_EXPR:\n     case MAX_EXPR:\n-      return (tree_expr_nonnegative_warnv_p (op0,\n-\t\t\t\t\t     strict_overflow_p)\n-\t      || tree_expr_nonnegative_warnv_p (op1,\n-\t\t\t\t\t\tstrict_overflow_p));\n+      return RECURSE (op0) || RECURSE (op1);\n \n     case BIT_IOR_EXPR:\n     case BIT_XOR_EXPR:\n@@ -12941,17 +12939,14 @@ tree_binary_nonnegative_warnv_p (enum tree_code code, tree type, tree op0,\n     case CEIL_DIV_EXPR:\n     case FLOOR_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n-      return (tree_expr_nonnegative_warnv_p (op0,\n-\t\t\t\t\t     strict_overflow_p)\n-\t      && tree_expr_nonnegative_warnv_p (op1,\n-\t\t\t\t\t\tstrict_overflow_p));\n+      return RECURSE (op0) && RECURSE (op1);\n \n     case TRUNC_MOD_EXPR:\n     case CEIL_MOD_EXPR:\n     case FLOOR_MOD_EXPR:\n     case ROUND_MOD_EXPR:\n-      return tree_expr_nonnegative_warnv_p (op0,\n-\t\t\t\t\t    strict_overflow_p);\n+      return RECURSE (op0);\n+\n     default:\n       return tree_simple_nonnegative_warnv_p (code, type);\n     }\n@@ -12960,13 +12955,32 @@ tree_binary_nonnegative_warnv_p (enum tree_code code, tree type, tree op0,\n   return false;\n }\n \n+/* Return true if SSA name T is known to be non-negative.  If the return\n+   value is based on the assumption that signed overflow is undefined,\n+   set *STRICT_OVERFLOW_P to true; otherwise, don't change\n+   *STRICT_OVERFLOW_P.  DEPTH is the current nesting depth of the query.  */\n+\n+static bool\n+tree_ssa_name_nonnegative_warnv_p (tree t, bool *strict_overflow_p, int depth)\n+{\n+  /* Limit the depth of recursion to avoid quadratic behavior.\n+     This is expected to catch almost all occurrences in practice.\n+     If this code misses important cases that unbounded recursion\n+     would not, passes that need this information could be revised\n+     to provide it through dataflow propagation.  */\n+  if (depth < PARAM_VALUE (PARAM_MAX_SSA_NAME_QUERY_DEPTH))\n+    return gimple_stmt_nonnegative_warnv_p (SSA_NAME_DEF_STMT (t),\n+\t\t\t\t\t    strict_overflow_p, depth);\n+  return tree_simple_nonnegative_warnv_p (TREE_CODE (t), TREE_TYPE (t));\n+}\n+\n /* Return true if T is known to be non-negative.  If the return\n    value is based on the assumption that signed overflow is undefined,\n    set *STRICT_OVERFLOW_P to true; otherwise, don't change\n-   *STRICT_OVERFLOW_P.  */\n+   *STRICT_OVERFLOW_P.  DEPTH is the current nesting depth of the query.  */\n \n bool\n-tree_single_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n+tree_single_nonnegative_warnv_p (tree t, bool *strict_overflow_p, int depth)\n {\n   if (TYPE_UNSIGNED (TREE_TYPE (t)))\n     return true;\n@@ -12983,26 +12997,24 @@ tree_single_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n       return ! FIXED_VALUE_NEGATIVE (TREE_FIXED_CST (t));\n \n     case COND_EXPR:\n-      return (tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 1),\n-\t\t\t\t\t     strict_overflow_p)\n-\t      && tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 2),\n-\t\t\t\t\t\tstrict_overflow_p));\n+      return RECURSE (TREE_OPERAND (t, 1)) && RECURSE (TREE_OPERAND (t, 2));\n+\n+    case SSA_NAME:\n+      return tree_ssa_name_nonnegative_warnv_p (t, strict_overflow_p, depth);\n+\n     default:\n-      return tree_simple_nonnegative_warnv_p (TREE_CODE (t),\n-\t\t\t\t\t\t   TREE_TYPE (t));\n+      return tree_simple_nonnegative_warnv_p (TREE_CODE (t), TREE_TYPE (t));\n     }\n-  /* We don't know sign of `t', so be conservative and return false.  */\n-  return false;\n }\n \n /* Return true if T is known to be non-negative.  If the return\n    value is based on the assumption that signed overflow is undefined,\n    set *STRICT_OVERFLOW_P to true; otherwise, don't change\n-   *STRICT_OVERFLOW_P.  */\n+   *STRICT_OVERFLOW_P.  DEPTH is the current nesting depth of the query.  */\n \n bool\n-tree_call_nonnegative_warnv_p (tree type, tree fndecl,\n-\t\t\t       tree arg0, tree arg1, bool *strict_overflow_p)\n+tree_call_nonnegative_warnv_p (tree type, tree fndecl, tree arg0, tree arg1,\n+\t\t\t       bool *strict_overflow_p, int depth)\n {\n   if (fndecl && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n     switch (DECL_FUNCTION_CODE (fndecl))\n@@ -13033,8 +13045,7 @@ tree_call_nonnegative_warnv_p (tree type, tree fndecl,\n \t/* sqrt(-0.0) is -0.0.  */\n \tif (!HONOR_SIGNED_ZEROS (element_mode (type)))\n \t  return true;\n-\treturn tree_expr_nonnegative_warnv_p (arg0,\n-\t\t\t\t\t      strict_overflow_p);\n+\treturn RECURSE (arg0);\n \n \tCASE_FLT_FN (BUILT_IN_ASINH):\n \tCASE_FLT_FN (BUILT_IN_ATAN):\n@@ -13072,36 +13083,27 @@ tree_call_nonnegative_warnv_p (tree type, tree fndecl,\n \tCASE_FLT_FN (BUILT_IN_TANH):\n \tCASE_FLT_FN (BUILT_IN_TRUNC):\n \t/* True if the 1st argument is nonnegative.  */\n-\treturn tree_expr_nonnegative_warnv_p (arg0,\n-\t\t\t\t\t      strict_overflow_p);\n+\treturn RECURSE (arg0);\n \n \tCASE_FLT_FN (BUILT_IN_FMAX):\n \t/* True if the 1st OR 2nd arguments are nonnegative.  */\n-\treturn (tree_expr_nonnegative_warnv_p (arg0,\n-\t\t\t\t\t       strict_overflow_p)\n-\t\t|| (tree_expr_nonnegative_warnv_p (arg1,\n-\t\t\t\t\t\t   strict_overflow_p)));\n+\treturn RECURSE (arg0) || RECURSE (arg1);\n \n \tCASE_FLT_FN (BUILT_IN_FMIN):\n \t/* True if the 1st AND 2nd arguments are nonnegative.  */\n-\treturn (tree_expr_nonnegative_warnv_p (arg0,\n-\t\t\t\t\t       strict_overflow_p)\n-\t\t&& (tree_expr_nonnegative_warnv_p (arg1,\n-\t\t\t\t\t\t   strict_overflow_p)));\n+\treturn RECURSE (arg0) && RECURSE (arg1);\n \n \tCASE_FLT_FN (BUILT_IN_COPYSIGN):\n \t/* True if the 2nd argument is nonnegative.  */\n-\treturn tree_expr_nonnegative_warnv_p (arg1,\n-\t\t\t\t\t      strict_overflow_p);\n+\treturn RECURSE (arg1);\n \n \tCASE_FLT_FN (BUILT_IN_POWI):\n \t/* True if the 1st argument is nonnegative or the second\n \t   argument is an even integer.  */\n \tif (TREE_CODE (arg1) == INTEGER_CST\n \t    && (TREE_INT_CST_LOW (arg1) & 1) == 0)\n \t  return true;\n-\treturn tree_expr_nonnegative_warnv_p (arg0,\n-\t\t\t\t\t      strict_overflow_p);\n+\treturn RECURSE (arg0);\n \n \tCASE_FLT_FN (BUILT_IN_POW):\n \t/* True if the 1st argument is nonnegative or the second\n@@ -13121,23 +13123,21 @@ tree_call_nonnegative_warnv_p (tree type, tree fndecl,\n \t\t  return true;\n \t      }\n \t  }\n-\treturn tree_expr_nonnegative_warnv_p (arg0,\n-\t\t\t\t\t      strict_overflow_p);\n+\treturn RECURSE (arg0);\n \n       default:\n \tbreak;\n       }\n-  return tree_simple_nonnegative_warnv_p (CALL_EXPR,\n-\t\t\t\t\t  type);\n+  return tree_simple_nonnegative_warnv_p (CALL_EXPR, type);\n }\n \n /* Return true if T is known to be non-negative.  If the return\n    value is based on the assumption that signed overflow is undefined,\n    set *STRICT_OVERFLOW_P to true; otherwise, don't change\n-   *STRICT_OVERFLOW_P.  */\n+   *STRICT_OVERFLOW_P.  DEPTH is the current nesting depth of the query.  */\n \n static bool\n-tree_invalid_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n+tree_invalid_nonnegative_warnv_p (tree t, bool *strict_overflow_p, int depth)\n {\n   enum tree_code code = TREE_CODE (t);\n   if (TYPE_UNSIGNED (TREE_TYPE (t)))\n@@ -13153,7 +13153,7 @@ tree_invalid_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n \t/* If the initializer is non-void, then it's a normal expression\n \t   that will be assigned to the slot.  */\n \tif (!VOID_TYPE_P (t))\n-\t  return tree_expr_nonnegative_warnv_p (t, strict_overflow_p);\n+\t  return RECURSE (t);\n \n \t/* Otherwise, the initializer sets the slot in some way.  One common\n \t   way is an assignment statement at the end of the initializer.  */\n@@ -13171,8 +13171,7 @@ tree_invalid_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n \t  }\n \tif (TREE_CODE (t) == MODIFY_EXPR\n \t    && TREE_OPERAND (t, 0) == temp)\n-\t  return tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 1),\n-\t\t\t\t\t\tstrict_overflow_p);\n+\t  return RECURSE (TREE_OPERAND (t, 1));\n \n \treturn false;\n       }\n@@ -13186,35 +13185,33 @@ tree_invalid_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n \t\t\t\t\t      get_callee_fndecl (t),\n \t\t\t\t\t      arg0,\n \t\t\t\t\t      arg1,\n-\t\t\t\t\t      strict_overflow_p);\n+\t\t\t\t\t      strict_overflow_p, depth);\n       }\n     case COMPOUND_EXPR:\n     case MODIFY_EXPR:\n-      return tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 1),\n-\t\t\t\t\t    strict_overflow_p);\n+      return RECURSE (TREE_OPERAND (t, 1));\n+\n     case BIND_EXPR:\n-      return tree_expr_nonnegative_warnv_p (expr_last (TREE_OPERAND (t, 1)),\n-\t\t\t\t\t    strict_overflow_p);\n+      return RECURSE (expr_last (TREE_OPERAND (t, 1)));\n+\n     case SAVE_EXPR:\n-      return tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 0),\n-\t\t\t\t\t    strict_overflow_p);\n+      return RECURSE (TREE_OPERAND (t, 0));\n \n     default:\n-      return tree_simple_nonnegative_warnv_p (TREE_CODE (t),\n-\t\t\t\t\t\t   TREE_TYPE (t));\n+      return tree_simple_nonnegative_warnv_p (TREE_CODE (t), TREE_TYPE (t));\n     }\n-\n-  /* We don't know sign of `t', so be conservative and return false.  */\n-  return false;\n }\n \n+#undef RECURSE\n+#undef tree_expr_nonnegative_warnv_p\n+\n /* Return true if T is known to be non-negative.  If the return\n    value is based on the assumption that signed overflow is undefined,\n    set *STRICT_OVERFLOW_P to true; otherwise, don't change\n-   *STRICT_OVERFLOW_P.  */\n+   *STRICT_OVERFLOW_P.  DEPTH is the current nesting depth of the query.  */\n \n bool\n-tree_expr_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n+tree_expr_nonnegative_warnv_p (tree t, bool *strict_overflow_p, int depth)\n {\n   enum tree_code code;\n   if (t == error_mark_node)\n@@ -13229,18 +13226,18 @@ tree_expr_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n \t\t\t\t\t      TREE_TYPE (t),\n \t\t\t\t\t      TREE_OPERAND (t, 0),\n \t\t\t\t\t      TREE_OPERAND (t, 1),\n-\t\t\t\t\t      strict_overflow_p);\n+\t\t\t\t\t      strict_overflow_p, depth);\n \n     case tcc_unary:\n       return tree_unary_nonnegative_warnv_p (TREE_CODE (t),\n \t\t\t\t\t     TREE_TYPE (t),\n \t\t\t\t\t     TREE_OPERAND (t, 0),\n-\t\t\t\t\t     strict_overflow_p);\n+\t\t\t\t\t     strict_overflow_p, depth);\n \n     case tcc_constant:\n     case tcc_declaration:\n     case tcc_reference:\n-      return tree_single_nonnegative_warnv_p (t, strict_overflow_p);\n+      return tree_single_nonnegative_warnv_p (t, strict_overflow_p, depth);\n \n     default:\n       break;\n@@ -13255,12 +13252,12 @@ tree_expr_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n \t\t\t\t\t      TREE_TYPE (t),\n \t\t\t\t\t      TREE_OPERAND (t, 0),\n \t\t\t\t\t      TREE_OPERAND (t, 1),\n-\t\t\t\t\t      strict_overflow_p);\n+\t\t\t\t\t      strict_overflow_p, depth);\n     case TRUTH_NOT_EXPR:\n       return tree_unary_nonnegative_warnv_p (TREE_CODE (t),\n \t\t\t\t\t     TREE_TYPE (t),\n \t\t\t\t\t     TREE_OPERAND (t, 0),\n-\t\t\t\t\t     strict_overflow_p);\n+\t\t\t\t\t     strict_overflow_p, depth);\n \n     case COND_EXPR:\n     case CONSTRUCTOR:\n@@ -13269,10 +13266,10 @@ tree_expr_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n     case ADDR_EXPR:\n     case WITH_SIZE_EXPR:\n     case SSA_NAME:\n-      return tree_single_nonnegative_warnv_p (t, strict_overflow_p);\n+      return tree_single_nonnegative_warnv_p (t, strict_overflow_p, depth);\n \n     default:\n-      return tree_invalid_nonnegative_warnv_p (t, strict_overflow_p);\n+      return tree_invalid_nonnegative_warnv_p (t, strict_overflow_p, depth);\n     }\n }\n "}, {"sha": "ee74dc87b6b4f7243458fa534fb09301f4bbc74e", "filename": "gcc/fold-const.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e57f040c6330eb853551622d458a67d6f9e572/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e57f040c6330eb853551622d458a67d6f9e572/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=68e57f040c6330eb853551622d458a67d6f9e572", "patch": "@@ -132,11 +132,13 @@ extern bool tree_unary_nonzero_warnv_p (enum tree_code, tree, tree, bool *);\n extern bool tree_binary_nonzero_warnv_p (enum tree_code, tree, tree, tree op1,\n                                          bool *);\n extern bool tree_single_nonzero_warnv_p (tree, bool *);\n-extern bool tree_unary_nonnegative_warnv_p (enum tree_code, tree, tree, bool *);\n+extern bool tree_unary_nonnegative_warnv_p (enum tree_code, tree, tree,\n+\t\t\t\t\t    bool *, int);\n extern bool tree_binary_nonnegative_warnv_p (enum tree_code, tree, tree, tree,\n-                                             bool *);\n-extern bool tree_single_nonnegative_warnv_p (tree t, bool *strict_overflow_p);\n-extern bool tree_call_nonnegative_warnv_p (tree, tree, tree, tree, bool *);\n+\t\t\t\t\t     bool *, int);\n+extern bool tree_single_nonnegative_warnv_p (tree, bool *, int);\n+extern bool tree_call_nonnegative_warnv_p (tree, tree, tree, tree, bool *,\n+\t\t\t\t\t   int);\n \n extern bool fold_real_zero_addition_p (const_tree, const_tree, int);\n extern tree combine_comparisons (location_t, enum tree_code, enum tree_code,\n@@ -160,7 +162,7 @@ extern tree size_diffop_loc (location_t, tree, tree);\n extern tree non_lvalue_loc (location_t, tree);\n \n extern bool tree_expr_nonnegative_p (tree);\n-extern bool tree_expr_nonnegative_warnv_p (tree, bool *);\n+extern bool tree_expr_nonnegative_warnv_p (tree, bool *, int = 0);\n extern tree make_range (tree, int *, tree *, tree *, bool *);\n extern tree make_range_step (location_t, enum tree_code, tree, tree, tree,\n \t\t\t     tree *, tree *, int *, bool *);"}, {"sha": "0292f0495097fe6d494a206dd7e25eab29d797a4", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 77, "deletions": 131, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e57f040c6330eb853551622d458a67d6f9e572/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e57f040c6330eb853551622d458a67d6f9e572/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=68e57f040c6330eb853551622d458a67d6f9e572", "patch": "@@ -5773,137 +5773,6 @@ gimple_get_virt_method_for_binfo (HOST_WIDE_INT token, tree known_binfo,\n   return gimple_get_virt_method_for_vtable (token, v, offset, can_refer);\n }\n \n-/* Return true iff VAL is a gimple expression that is known to be\n-   non-negative.  Restricted to floating-point inputs.  */\n-\n-bool\n-gimple_val_nonnegative_real_p (tree val)\n-{\n-  gimple *def_stmt;\n-\n-  gcc_assert (val && SCALAR_FLOAT_TYPE_P (TREE_TYPE (val)));\n-\n-  /* Use existing logic for non-gimple trees.  */\n-  if (tree_expr_nonnegative_p (val))\n-    return true;\n-\n-  if (TREE_CODE (val) != SSA_NAME)\n-    return false;\n-\n-  /* Currently we look only at the immediately defining statement\n-     to make this determination, since recursion on defining \n-     statements of operands can lead to quadratic behavior in the\n-     worst case.  This is expected to catch almost all occurrences\n-     in practice.  It would be possible to implement limited-depth\n-     recursion if important cases are lost.  Alternatively, passes\n-     that need this information (such as the pow/powi lowering code\n-     in the cse_sincos pass) could be revised to provide it through\n-     dataflow propagation.  */\n-\n-  def_stmt = SSA_NAME_DEF_STMT (val);\n-\n-  if (is_gimple_assign (def_stmt))\n-    {\n-      tree op0, op1;\n-\n-      /* See fold-const.c:tree_expr_nonnegative_p for additional\n-\t cases that could be handled with recursion.  */\n-\n-      switch (gimple_assign_rhs_code (def_stmt))\n-\t{\n-\tcase ABS_EXPR:\n-\t  /* Always true for floating-point operands.  */\n-\t  return true;\n-\n-\tcase MULT_EXPR:\n-\t  /* True if the two operands are identical (since we are\n-\t     restricted to floating-point inputs).  */\n-\t  op0 = gimple_assign_rhs1 (def_stmt);\n-\t  op1 = gimple_assign_rhs2 (def_stmt);\n-\n-\t  if (op0 == op1\n-\t      || operand_equal_p (op0, op1, 0))\n-\t    return true;\n-\n-\tdefault:\n-\t  return false;\n-\t}\n-    }\n-  else if (is_gimple_call (def_stmt))\n-    {\n-      tree fndecl = gimple_call_fndecl (def_stmt);\n-      if (fndecl\n-\t  && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n-\t{\n-\t  tree arg1;\n-\n-\t  switch (DECL_FUNCTION_CODE (fndecl))\n-\t    {\n-\t    CASE_FLT_FN (BUILT_IN_ACOS):\n-\t    CASE_FLT_FN (BUILT_IN_ACOSH):\n-\t    CASE_FLT_FN (BUILT_IN_CABS):\n-\t    CASE_FLT_FN (BUILT_IN_COSH):\n-\t    CASE_FLT_FN (BUILT_IN_ERFC):\n-\t    CASE_FLT_FN (BUILT_IN_EXP):\n-\t    CASE_FLT_FN (BUILT_IN_EXP10):\n-\t    CASE_FLT_FN (BUILT_IN_EXP2):\n-\t    CASE_FLT_FN (BUILT_IN_FABS):\n-\t    CASE_FLT_FN (BUILT_IN_FDIM):\n-\t    CASE_FLT_FN (BUILT_IN_HYPOT):\n-\t    CASE_FLT_FN (BUILT_IN_POW10):\n-\t      return true;\n-\n-\t    CASE_FLT_FN (BUILT_IN_SQRT):\n-\t      /* sqrt(-0.0) is -0.0, and sqrt is not defined over other\n-\t\t nonnegative inputs.  */\n-\t      if (!HONOR_SIGNED_ZEROS (val))\n-\t\treturn true;\n-\n-\t      break;\n-\n-\t    CASE_FLT_FN (BUILT_IN_POWI):\n-\t      /* True if the second argument is an even integer.  */\n-\t      arg1 = gimple_call_arg (def_stmt, 1);\n-\n-\t      if (TREE_CODE (arg1) == INTEGER_CST\n-\t\t  && (TREE_INT_CST_LOW (arg1) & 1) == 0)\n-\t\treturn true;\n-\n-\t      break;\n-\t      \n-\t    CASE_FLT_FN (BUILT_IN_POW):\n-\t      /* True if the second argument is an even integer-valued\n-\t\t real.  */\n-\t      arg1 = gimple_call_arg (def_stmt, 1);\n-\n-\t      if (TREE_CODE (arg1) == REAL_CST)\n-\t\t{\n-\t\t  REAL_VALUE_TYPE c;\n-\t\t  HOST_WIDE_INT n;\n-\n-\t\t  c = TREE_REAL_CST (arg1);\n-\t\t  n = real_to_integer (&c);\n-\n-\t\t  if ((n & 1) == 0)\n-\t\t    {\n-\t\t      REAL_VALUE_TYPE cint;\n-\t\t      real_from_integer (&cint, VOIDmode, n, SIGNED);\n-\t\t      if (real_identical (&c, &cint))\n-\t\t\treturn true;\n-\t\t    }\n-\t\t}\n-\n-\t      break;\n-\n-\t    default:\n-\t      return false;\n-\t    }\n-\t}\n-    }\n-\n-  return false;\n-}\n-\n /* Given a pointer value OP0, return a simplified version of an\n    indirection through OP0, or NULL_TREE if no simplification is\n    possible.  Note that the resulting type may be different from\n@@ -6280,3 +6149,80 @@ gimple_convert (gimple_seq *seq, location_t loc, tree type, tree op)\n     return op;\n   return gimple_build (seq, loc, NOP_EXPR, type, op);\n }\n+\n+/* Return true if the result of assignment STMT is known to be non-negative.\n+   If the return value is based on the assumption that signed overflow is\n+   undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't change\n+   *STRICT_OVERFLOW_P.  DEPTH is the current nesting depth of the query.  */\n+\n+static bool\n+gimple_assign_nonnegative_warnv_p (gimple *stmt, bool *strict_overflow_p,\n+\t\t\t\t   int depth)\n+{\n+  enum tree_code code = gimple_assign_rhs_code (stmt);\n+  switch (get_gimple_rhs_class (code))\n+    {\n+    case GIMPLE_UNARY_RHS:\n+      return tree_unary_nonnegative_warnv_p (gimple_assign_rhs_code (stmt),\n+\t\t\t\t\t     gimple_expr_type (stmt),\n+\t\t\t\t\t     gimple_assign_rhs1 (stmt),\n+\t\t\t\t\t     strict_overflow_p, depth);\n+    case GIMPLE_BINARY_RHS:\n+      return tree_binary_nonnegative_warnv_p (gimple_assign_rhs_code (stmt),\n+\t\t\t\t\t      gimple_expr_type (stmt),\n+\t\t\t\t\t      gimple_assign_rhs1 (stmt),\n+\t\t\t\t\t      gimple_assign_rhs2 (stmt),\n+\t\t\t\t\t      strict_overflow_p, depth);\n+    case GIMPLE_TERNARY_RHS:\n+      return false;\n+    case GIMPLE_SINGLE_RHS:\n+      return tree_single_nonnegative_warnv_p (gimple_assign_rhs1 (stmt),\n+\t\t\t\t\t      strict_overflow_p, depth);\n+    case GIMPLE_INVALID_RHS:\n+      break;\n+    }\n+  gcc_unreachable ();\n+}\n+\n+/* Return true if return value of call STMT is known to be non-negative.\n+   If the return value is based on the assumption that signed overflow is\n+   undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't change\n+   *STRICT_OVERFLOW_P.  DEPTH is the current nesting depth of the query.  */\n+\n+static bool\n+gimple_call_nonnegative_warnv_p (gimple *stmt, bool *strict_overflow_p,\n+\t\t\t\t int depth)\n+{\n+  tree arg0 = gimple_call_num_args (stmt) > 0 ?\n+    gimple_call_arg (stmt, 0) : NULL_TREE;\n+  tree arg1 = gimple_call_num_args (stmt) > 1 ?\n+    gimple_call_arg (stmt, 1) : NULL_TREE;\n+\n+  return tree_call_nonnegative_warnv_p (gimple_expr_type (stmt),\n+\t\t\t\t\tgimple_call_fndecl (stmt),\n+\t\t\t\t\targ0,\n+\t\t\t\t\targ1,\n+\t\t\t\t\tstrict_overflow_p, depth);\n+}\n+\n+/* Return true if STMT is known to compute a non-negative value.\n+   If the return value is based on the assumption that signed overflow is\n+   undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't change\n+   *STRICT_OVERFLOW_P.  DEPTH is the current nesting depth of the query.  */\n+\n+bool\n+gimple_stmt_nonnegative_warnv_p (gimple *stmt, bool *strict_overflow_p,\n+\t\t\t\t int depth)\n+{\n+  switch (gimple_code (stmt))\n+    {\n+    case GIMPLE_ASSIGN:\n+      return gimple_assign_nonnegative_warnv_p (stmt, strict_overflow_p,\n+\t\t\t\t\t\tdepth);\n+    case GIMPLE_CALL:\n+      return gimple_call_nonnegative_warnv_p (stmt, strict_overflow_p,\n+\t\t\t\t\t      depth);\n+    default:\n+      return false;\n+    }\n+}"}, {"sha": "c6b4609f8345d9b51e8d627e0e2c967986dc1292", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e57f040c6330eb853551622d458a67d6f9e572/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e57f040c6330eb853551622d458a67d6f9e572/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=68e57f040c6330eb853551622d458a67d6f9e572", "patch": "@@ -48,7 +48,6 @@ extern tree gimple_get_virt_method_for_binfo (HOST_WIDE_INT, tree,\n extern tree gimple_get_virt_method_for_vtable (HOST_WIDE_INT, tree,\n \t\t\t\t\t       unsigned HOST_WIDE_INT,\n \t\t\t\t\t       bool *can_refer = NULL);\n-extern bool gimple_val_nonnegative_real_p (tree);\n extern tree gimple_fold_indirect_ref (tree);\n extern bool arith_code_with_undefined_signed_overflow (tree_code);\n extern gimple_seq rewrite_to_defined_overflow (gimple *);\n@@ -113,6 +112,8 @@ gimple_convert (gimple_seq *seq, tree type, tree op)\n   return gimple_convert (seq, UNKNOWN_LOCATION, type, op);\n }\n \n+extern bool gimple_stmt_nonnegative_warnv_p (gimple *, bool *, int = 0);\n+\n /* In gimple-match.c.  */\n extern tree gimple_simplify (enum tree_code, tree, tree,\n \t\t\t     gimple_seq *, tree (*)(tree));"}, {"sha": "8b8b9fe3ff76eab22a8de0e8c08052c065bde5a3", "filename": "gcc/params.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e57f040c6330eb853551622d458a67d6f9e572/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e57f040c6330eb853551622d458a67d6f9e572/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=68e57f040c6330eb853551622d458a67d6f9e572", "patch": "@@ -1152,6 +1152,12 @@ DEFPARAM (PARAM_PARLOOPS_CHUNK_SIZE,\n \t  \"parloops-chunk-size\",\n \t  \"Chunk size of omp schedule for loops parallelized by parloops\",\n \t  0, 0, 0)\n+\n+DEFPARAM (PARAM_MAX_SSA_NAME_QUERY_DEPTH,\n+\t  \"max-ssa-name-query-depth\",\n+\t  \"Maximum recursion depth allowed when querying a property of an\"\n+\t  \" SSA name\",\n+\t  2, 1, 0)\n /*\n \n Local variables:"}, {"sha": "21604f592ede83ae1e9572f8f8e1d1c01575e93d", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e57f040c6330eb853551622d458a67d6f9e572/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e57f040c6330eb853551622d458a67d6f9e572/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=68e57f040c6330eb853551622d458a67d6f9e572", "patch": "@@ -1526,7 +1526,7 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n \n   if (flag_unsafe_math_optimizations\n       && cbrtfn\n-      && (gimple_val_nonnegative_real_p (arg0) || !HONOR_NANS (mode))\n+      && (!HONOR_NANS (mode) || tree_expr_nonnegative_p (arg0))\n       && real_equal (&c, &dconst1_3))\n     return build_and_insert_call (gsi, loc, cbrtfn, arg0);\n   \n@@ -1538,7 +1538,7 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n   if (flag_unsafe_math_optimizations\n       && sqrtfn\n       && cbrtfn\n-      && (gimple_val_nonnegative_real_p (arg0) || !HONOR_NANS (mode))\n+      && (!HONOR_NANS (mode) || tree_expr_nonnegative_p (arg0))\n       && speed_p\n       && hw_sqrt_exists\n       && real_equal (&c, &dconst1_6))\n@@ -1594,7 +1594,7 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n \n   if (flag_unsafe_math_optimizations\n       && cbrtfn\n-      && (gimple_val_nonnegative_real_p (arg0) || !HONOR_NANS (mode))\n+      && (!HONOR_NANS (mode) || tree_expr_nonnegative_p (arg0))\n       && real_identical (&c2, &c)\n       && !c2_is_int\n       && optimize_function_for_speed_p (cfun)"}, {"sha": "fe34ffdf03e5de6de4d56b277eceae855ef4c10c", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e57f040c6330eb853551622d458a67d6f9e572/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e57f040c6330eb853551622d458a67d6f9e572/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=68e57f040c6330eb853551622d458a67d6f9e572", "patch": "@@ -1007,80 +1007,6 @@ usable_range_p (value_range *vr, bool *strict_overflow_p)\n   return true;\n }\n \n-\n-/* Return true if the result of assignment STMT is know to be non-negative.\n-   If the return value is based on the assumption that signed overflow is\n-   undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't change\n-   *STRICT_OVERFLOW_P.*/\n-\n-static bool\n-gimple_assign_nonnegative_warnv_p (gimple *stmt, bool *strict_overflow_p)\n-{\n-  enum tree_code code = gimple_assign_rhs_code (stmt);\n-  switch (get_gimple_rhs_class (code))\n-    {\n-    case GIMPLE_UNARY_RHS:\n-      return tree_unary_nonnegative_warnv_p (gimple_assign_rhs_code (stmt),\n-\t\t\t\t\t     gimple_expr_type (stmt),\n-\t\t\t\t\t     gimple_assign_rhs1 (stmt),\n-\t\t\t\t\t     strict_overflow_p);\n-    case GIMPLE_BINARY_RHS:\n-      return tree_binary_nonnegative_warnv_p (gimple_assign_rhs_code (stmt),\n-\t\t\t\t\t      gimple_expr_type (stmt),\n-\t\t\t\t\t      gimple_assign_rhs1 (stmt),\n-\t\t\t\t\t      gimple_assign_rhs2 (stmt),\n-\t\t\t\t\t      strict_overflow_p);\n-    case GIMPLE_TERNARY_RHS:\n-      return false;\n-    case GIMPLE_SINGLE_RHS:\n-      return tree_single_nonnegative_warnv_p (gimple_assign_rhs1 (stmt),\n-\t\t\t\t\t      strict_overflow_p);\n-    case GIMPLE_INVALID_RHS:\n-      gcc_unreachable ();\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Return true if return value of call STMT is know to be non-negative.\n-   If the return value is based on the assumption that signed overflow is\n-   undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't change\n-   *STRICT_OVERFLOW_P.*/\n-\n-static bool\n-gimple_call_nonnegative_warnv_p (gimple *stmt, bool *strict_overflow_p)\n-{\n-  tree arg0 = gimple_call_num_args (stmt) > 0 ?\n-    gimple_call_arg (stmt, 0) : NULL_TREE;\n-  tree arg1 = gimple_call_num_args (stmt) > 1 ?\n-    gimple_call_arg (stmt, 1) : NULL_TREE;\n-\n-  return tree_call_nonnegative_warnv_p (gimple_expr_type (stmt),\n-\t\t\t\t\tgimple_call_fndecl (stmt),\n-\t\t\t\t\targ0,\n-\t\t\t\t\targ1,\n-\t\t\t\t\tstrict_overflow_p);\n-}\n-\n-/* Return true if STMT is know to compute a non-negative value.\n-   If the return value is based on the assumption that signed overflow is\n-   undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't change\n-   *STRICT_OVERFLOW_P.*/\n-\n-static bool\n-gimple_stmt_nonnegative_warnv_p (gimple *stmt, bool *strict_overflow_p)\n-{\n-  switch (gimple_code (stmt))\n-    {\n-    case GIMPLE_ASSIGN:\n-      return gimple_assign_nonnegative_warnv_p (stmt, strict_overflow_p);\n-    case GIMPLE_CALL:\n-      return gimple_call_nonnegative_warnv_p (stmt, strict_overflow_p);\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n /* Return true if the result of assignment STMT is know to be non-zero.\n    If the return value is based on the assumption that signed overflow is\n    undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't change\n@@ -6858,12 +6784,9 @@ remove_range_assertions (void)\n \t    tree lhs = gimple_assign_lhs (stmt);\n \t    tree rhs = gimple_assign_rhs1 (stmt);\n \t    tree var;\n-\t    tree cond = fold (ASSERT_EXPR_COND (rhs));\n \t    use_operand_p use_p;\n \t    imm_use_iterator iter;\n \n-\t    gcc_assert (cond != boolean_false_node);\n-\n \t    var = ASSERT_EXPR_VAR (rhs);\n \t    gcc_assert (TREE_CODE (var) == SSA_NAME);\n "}]}