{"sha": "455acc43518744b89d6a795bbba5045bd228060b", "node_id": "C_kwDOANBUbNoAKDQ1NWFjYzQzNTE4NzQ0Yjg5ZDZhNzk1YmJiYTUwNDViZDIyODA2MGI", "commit": {"author": {"name": "Florian Weimer", "email": "fweimer@redhat.com", "date": "2023-01-03T15:47:31Z"}, "committer": {"name": "Florian Weimer", "email": "fweimer@redhat.com", "date": "2023-01-03T15:47:31Z"}, "message": "Revert \"Compute a table of DWARF register sizes at compile\"\n\nThis reverts commit 3b6cac2b44b384cd2091eaeaebeb3478c253a25d.", "tree": {"sha": "00679ff51b9eab7e53021605ef2fbb170de729bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00679ff51b9eab7e53021605ef2fbb170de729bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/455acc43518744b89d6a795bbba5045bd228060b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/455acc43518744b89d6a795bbba5045bd228060b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/455acc43518744b89d6a795bbba5045bd228060b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/455acc43518744b89d6a795bbba5045bd228060b/comments", "author": {"login": "fweimer-rh", "id": 75532728, "node_id": "MDQ6VXNlcjc1NTMyNzI4", "avatar_url": "https://avatars.githubusercontent.com/u/75532728?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fweimer-rh", "html_url": "https://github.com/fweimer-rh", "followers_url": "https://api.github.com/users/fweimer-rh/followers", "following_url": "https://api.github.com/users/fweimer-rh/following{/other_user}", "gists_url": "https://api.github.com/users/fweimer-rh/gists{/gist_id}", "starred_url": "https://api.github.com/users/fweimer-rh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fweimer-rh/subscriptions", "organizations_url": "https://api.github.com/users/fweimer-rh/orgs", "repos_url": "https://api.github.com/users/fweimer-rh/repos", "events_url": "https://api.github.com/users/fweimer-rh/events{/privacy}", "received_events_url": "https://api.github.com/users/fweimer-rh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fweimer-rh", "id": 75532728, "node_id": "MDQ6VXNlcjc1NTMyNzI4", "avatar_url": "https://avatars.githubusercontent.com/u/75532728?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fweimer-rh", "html_url": "https://github.com/fweimer-rh", "followers_url": "https://api.github.com/users/fweimer-rh/followers", "following_url": "https://api.github.com/users/fweimer-rh/following{/other_user}", "gists_url": "https://api.github.com/users/fweimer-rh/gists{/gist_id}", "starred_url": "https://api.github.com/users/fweimer-rh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fweimer-rh/subscriptions", "organizations_url": "https://api.github.com/users/fweimer-rh/orgs", "repos_url": "https://api.github.com/users/fweimer-rh/repos", "events_url": "https://api.github.com/users/fweimer-rh/events{/privacy}", "received_events_url": "https://api.github.com/users/fweimer-rh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d010efbfb89721bc9ca9e657e980ff0d8e6187af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d010efbfb89721bc9ca9e657e980ff0d8e6187af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d010efbfb89721bc9ca9e657e980ff0d8e6187af"}], "stats": {"total": 133, "additions": 75, "deletions": 58}, "files": [{"sha": "6c15780a2b60c9f1e45331b85519491d741c979e", "filename": "gcc/config/msp430/msp430.cc", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455acc43518744b89d6a795bbba5045bd228060b/gcc%2Fconfig%2Fmsp430%2Fmsp430.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455acc43518744b89d6a795bbba5045bd228060b/gcc%2Fconfig%2Fmsp430%2Fmsp430.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.cc?ref=455acc43518744b89d6a795bbba5045bd228060b", "patch": "@@ -3202,9 +3202,11 @@ msp430_expand_eh_return (rtx eh_handler)\n #undef  TARGET_INIT_DWARF_REG_SIZES_EXTRA\n #define TARGET_INIT_DWARF_REG_SIZES_EXTRA msp430_init_dwarf_reg_sizes_extra\n void\n-msp430_init_dwarf_reg_sizes_extra (poly_uint16 *sizes)\n+msp430_init_dwarf_reg_sizes_extra (tree address)\n {\n   int i;\n+  rtx addr = expand_normal (address);\n+  rtx mem = gen_rtx_MEM (BLKmode, addr);\n \n   /* This needs to match msp430_unwind_word_mode (above).  */\n   if (!msp430x)\n@@ -3216,7 +3218,12 @@ msp430_init_dwarf_reg_sizes_extra (poly_uint16 *sizes)\n       unsigned int rnum = DWARF2_FRAME_REG_OUT (dnum, 1);\n \n       if (rnum < DWARF_FRAME_REGISTERS)\n-\tsizes[rnum] = 4;\n+\t{\n+\t  HOST_WIDE_INT offset = rnum * GET_MODE_SIZE (QImode);\n+\n+\t  emit_move_insn (adjust_address (mem, QImode, offset),\n+\t\t\t  gen_int_mode (4, QImode));\n+\t}\n     }\n }\n "}, {"sha": "6ac3adcec6bd390c861235138e1b9b963fb0a70b", "filename": "gcc/config/rs6000/rs6000.cc", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455acc43518744b89d6a795bbba5045bd228060b/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455acc43518744b89d6a795bbba5045bd228060b/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.cc?ref=455acc43518744b89d6a795bbba5045bd228060b", "patch": "@@ -23860,17 +23860,27 @@ rs6000_initial_elimination_offset (int from, int to)\n /* Fill in sizes of registers used by unwinder.  */\n \n static void\n-rs6000_init_dwarf_reg_sizes_extra (poly_uint16 *sizes)\n+rs6000_init_dwarf_reg_sizes_extra (tree address)\n {\n   if (TARGET_MACHO && ! TARGET_ALTIVEC)\n     {\n       int i;\n+      machine_mode mode = TYPE_MODE (char_type_node);\n+      rtx addr = expand_expr (address, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+      rtx mem = gen_rtx_MEM (BLKmode, addr);\n+      rtx value = gen_int_mode (16, mode);\n \n       /* On Darwin, libgcc may be built to run on both G3 and G4/5.\n \t The unwinder still needs to know the size of Altivec registers.  */\n \n       for (i = FIRST_ALTIVEC_REGNO; i < LAST_ALTIVEC_REGNO+1; i++)\n-\tsizes[i] = 16;\n+\t{\n+\t  int column = DWARF_REG_TO_UNWIND_COLUMN\n+\t\t(DWARF2_FRAME_REG_OUT (DWARF_FRAME_REGNUM (i), true));\n+\t  HOST_WIDE_INT offset = column * GET_MODE_SIZE (mode);\n+\n+\t  emit_move_insn (adjust_address (mem, mode, offset), value);\n+\t}\n     }\n }\n "}, {"sha": "8fe49c2ba3dbb4efd6143772082c4f8f5cc9728d", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455acc43518744b89d6a795bbba5045bd228060b/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455acc43518744b89d6a795bbba5045bd228060b/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=455acc43518744b89d6a795bbba5045bd228060b", "patch": "@@ -9840,14 +9840,13 @@ used to return a smaller mode than the raw mode to prevent call\n clobbered parts of a register altering the frame register size\n @end deftypefn\n \n-@deftypefn {Target Hook} void TARGET_INIT_DWARF_REG_SIZES_EXTRA (poly_uint16 *@var{sizes})\n+@deftypefn {Target Hook} void TARGET_INIT_DWARF_REG_SIZES_EXTRA (tree @var{address})\n If some registers are represented in Dwarf-2 unwind information in\n multiple pieces, define this hook to fill in information about the\n sizes of those pieces in the table used by the unwinder at runtime.\n-It will be called by @code{generate_dwarf_reg_sizes} after\n+It will be called by @code{expand_builtin_init_dwarf_reg_sizes} after\n filling in a single size corresponding to each hard register;\n-@var{sizes} is the address of the table.  It will contain\n-@code{DWARF_FRAME_REGISTERS} elements when this hook is called.\n+@var{address} is the address of the table.\n @end deftypefn\n \n @deftypefn {Target Hook} bool TARGET_ASM_TTYPE (rtx @var{sym})"}, {"sha": "1c70bd83f28e48661fb392e8acb7806ed9635892", "filename": "gcc/dwarf2cfi.cc", "status": "modified", "additions": 47, "deletions": 46, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455acc43518744b89d6a795bbba5045bd228060b/gcc%2Fdwarf2cfi.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455acc43518744b89d6a795bbba5045bd228060b/gcc%2Fdwarf2cfi.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.cc?ref=455acc43518744b89d6a795bbba5045bd228060b", "patch": "@@ -36,7 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"except.h\"\t\t/* expand_builtin_dwarf_sp_column */\n #include \"profile-count.h\"\t/* For expr.h */\n-#include \"expr.h\"\t\t/* expand_normal, emit_move_insn */\n+#include \"expr.h\"\t\t/* init_return_column_size */\n #include \"output.h\"\t\t/* asm_out_file */\n #include \"debug.h\"\t\t/* dwarf2out_do_frame, dwarf2out_do_cfi_asm */\n #include \"flags.h\"\t\t/* dwarf_debuginfo_p */\n@@ -241,6 +241,18 @@ expand_builtin_dwarf_sp_column (void)\n   return GEN_INT (DWARF2_FRAME_REG_OUT (dwarf_regnum, 1));\n }\n \n+/* MEM is a memory reference for the register size table, each element of\n+   which has mode MODE.  Initialize column C as a return address column.  */\n+\n+static void\n+init_return_column_size (scalar_int_mode mode, rtx mem, unsigned int c)\n+{\n+  HOST_WIDE_INT offset = c * GET_MODE_SIZE (mode);\n+  HOST_WIDE_INT size = GET_MODE_SIZE (Pmode);\n+  emit_move_insn (adjust_address (mem, mode, offset),\n+\t\t  gen_int_mode (size, mode));\n+}\n+\n /* Datastructure used by expand_builtin_init_dwarf_reg_sizes and\n    init_one_dwarf_reg_size to communicate on what has been done by the\n    latter.  */\n@@ -262,14 +274,17 @@ struct init_one_dwarf_reg_state\n    use for the size entry to initialize, and INIT_STATE is the communication\n    datastructure conveying what we're doing to our caller.  */\n \n-static void\n-init_one_dwarf_reg_size (int regno, machine_mode regmode,\n-\t\t\t poly_uint16 *table,\n-\t\t\t init_one_dwarf_reg_state *init_state)\n+static\n+void init_one_dwarf_reg_size (int regno, machine_mode regmode,\n+\t\t\t      rtx table, machine_mode slotmode,\n+\t\t\t      init_one_dwarf_reg_state *init_state)\n {\n   const unsigned int dnum = DWARF_FRAME_REGNUM (regno);\n   const unsigned int rnum = DWARF2_FRAME_REG_OUT (dnum, 1);\n   const unsigned int dcol = DWARF_REG_TO_UNWIND_COLUMN (rnum);\n+  \n+  poly_int64 slotoffset = dcol * GET_MODE_SIZE (slotmode);\n+  poly_int64 regsize = GET_MODE_SIZE (regmode);\n \n   init_state->processed_regno[regno] = true;\n \n@@ -283,80 +298,66 @@ init_one_dwarf_reg_size (int regno, machine_mode regmode,\n       init_state->wrote_return_column = true;\n     }\n \n-  table[dcol] = GET_MODE_SIZE (regmode);\n+  /* ??? When is this true?  Should it be a test based on DCOL instead?  */\n+  if (maybe_lt (slotoffset, 0))\n+    return;\n+\n+  emit_move_insn (adjust_address (table, slotmode, slotoffset),\n+\t\t  gen_int_mode (regsize, slotmode));\n }\n \n-/* Fill SIZES with size information for each DWARF register. */\n+/* Generate code to initialize the dwarf register size table located\n+   at the provided ADDRESS.  */\n \n-static void\n-generate_dwarf_reg_sizes (poly_uint16 *sizes)\n+void\n+expand_builtin_init_dwarf_reg_sizes (tree address)\n {\n-  for (unsigned int i = 0; i < DWARF_FRAME_REGISTERS; i++)\n-    sizes[i] = poly_uint16{};\n+  unsigned int i;\n+  scalar_int_mode mode = SCALAR_INT_TYPE_MODE (char_type_node);\n+  rtx addr = expand_normal (address);\n+  rtx mem = gen_rtx_MEM (BLKmode, addr);\n+\n+  init_one_dwarf_reg_state init_state;\n \n-  init_one_dwarf_reg_state init_state{};\n   memset ((char *)&init_state, 0, sizeof (init_state));\n \n-  for (unsigned int i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n+      machine_mode save_mode;\n+      rtx span;\n+\n       /* No point in processing a register multiple times.  This could happen\n \t with register spans, e.g. when a reg is first processed as a piece of\n \t a span, then as a register on its own later on.  */\n \n       if (init_state.processed_regno[i])\n \tcontinue;\n \n-      machine_mode save_mode = targetm.dwarf_frame_reg_mode (i);\n-      rtx span = targetm.dwarf_register_span (gen_rtx_REG (save_mode, i));\n+      save_mode = targetm.dwarf_frame_reg_mode (i);\n+      span = targetm.dwarf_register_span (gen_rtx_REG (save_mode, i));\n \n       if (!span)\n-\tinit_one_dwarf_reg_size (i, save_mode, sizes, &init_state);\n+\tinit_one_dwarf_reg_size (i, save_mode, mem, mode, &init_state);\n       else\n \t{\n \t  for (int si = 0; si < XVECLEN (span, 0); si++)\n \t    {\n \t      rtx reg = XVECEXP (span, 0, si);\n \n \t      init_one_dwarf_reg_size\n-\t\t(REGNO (reg), GET_MODE (reg), sizes, &init_state);\n+\t\t(REGNO (reg), GET_MODE (reg), mem, mode, &init_state);\n \t    }\n \t}\n     }\n \n   if (!init_state.wrote_return_column)\n-    sizes[DWARF_FRAME_RETURN_COLUMN] = GET_MODE_SIZE (Pmode);\n+    init_return_column_size (mode, mem, DWARF_FRAME_RETURN_COLUMN);\n \n #ifdef DWARF_ALT_FRAME_RETURN_COLUMN\n-  sizes[DWARF_ALT_FRAME_RETURN_COLUMN] = GET_MODE_SIZE (Pmode);\n+  init_return_column_size (mode, mem, DWARF_ALT_FRAME_RETURN_COLUMN);\n #endif\n \n-  if (targetm.init_dwarf_reg_sizes_extra != nullptr)\n-    targetm.init_dwarf_reg_sizes_extra (sizes);\n-}\n-\n-/* Generate code to initialize the dwarf register size table located\n-   at the provided ADDRESS.  */\n-\n-void\n-expand_builtin_init_dwarf_reg_sizes (tree address)\n-{\n-  poly_uint16 *sizes = XALLOCAVEC (poly_uint16, DWARF_FRAME_REGISTERS);\n-  generate_dwarf_reg_sizes (sizes);\n-\n-  scalar_int_mode mode = SCALAR_INT_TYPE_MODE (char_type_node);\n-  rtx addr = expand_normal (address);\n-  rtx mem = gen_rtx_MEM (BLKmode, addr);\n-  for (unsigned int i = 0; i < DWARF_FRAME_REGISTERS; ++i)\n-    {\n-      unsigned short value;\n-      if (sizes[i].is_constant (&value) && value == 0)\n-\t/* No need to set the value to zero again.  */\n-\tcontinue;\n-\n-      HOST_WIDE_INT offset = i * GET_MODE_SIZE (mode);\n-      emit_move_insn (adjust_address (mem, mode, offset),\n-\t\t      gen_int_mode (sizes[i], mode));\n-    }\n+  targetm.init_dwarf_reg_sizes_extra (address);\n }\n \n \f"}, {"sha": "db8af0cbe81624513f114fc9bbd8be61d855f409", "filename": "gcc/target.def", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455acc43518744b89d6a795bbba5045bd228060b/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455acc43518744b89d6a795bbba5045bd228060b/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=455acc43518744b89d6a795bbba5045bd228060b", "patch": "@@ -4039,11 +4039,11 @@ DEFHOOK\n  \"If some registers are represented in Dwarf-2 unwind information in\\n\\\n multiple pieces, define this hook to fill in information about the\\n\\\n sizes of those pieces in the table used by the unwinder at runtime.\\n\\\n-It will be called by @code{generate_dwarf_reg_sizes} after\\n\\\n+It will be called by @code{expand_builtin_init_dwarf_reg_sizes} after\\n\\\n filling in a single size corresponding to each hard register;\\n\\\n-@var{sizes} is the address of the table.  It will contain\\n\\\n-@code{DWARF_FRAME_REGISTERS} elements when this hook is called.\",\n- void, (poly_uint16 *sizes), nullptr)\n+@var{address} is the address of the table.\",\n+ void, (tree address),\n+ hook_void_tree)\n \n /* Fetch the fixed register(s) which hold condition codes, for\n    targets where it makes sense to look for duplicate assignments to"}]}