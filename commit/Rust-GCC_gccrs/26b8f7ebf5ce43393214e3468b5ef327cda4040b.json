{"sha": "26b8f7ebf5ce43393214e3468b5ef327cda4040b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZiOGY3ZWJmNWNlNDMzOTMyMTRlMzQ2OGI1ZWYzMjdjZGE0MDQwYg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-10-24T19:16:15Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-10-24T19:16:15Z"}, "message": "compiler: Implement 3-index slicing.\n\nFrom-SVN: r204034", "tree": {"sha": "18bba1fa68aa59cb44b80a14e23cce9161add836", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18bba1fa68aa59cb44b80a14e23cce9161add836"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26b8f7ebf5ce43393214e3468b5ef327cda4040b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26b8f7ebf5ce43393214e3468b5ef327cda4040b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26b8f7ebf5ce43393214e3468b5ef327cda4040b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26b8f7ebf5ce43393214e3468b5ef327cda4040b/comments", "author": null, "committer": null, "parents": [{"sha": "ccc23115665abdfad7394cc9dbc0c64e79a0164d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccc23115665abdfad7394cc9dbc0c64e79a0164d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccc23115665abdfad7394cc9dbc0c64e79a0164d"}], "stats": {"total": 215, "additions": 171, "deletions": 44}, "files": [{"sha": "c4d326861786fc08b5c3c355d0ee7aea6d0b523f", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 126, "deletions": 26, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26b8f7ebf5ce43393214e3468b5ef327cda4040b/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26b8f7ebf5ce43393214e3468b5ef327cda4040b/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=26b8f7ebf5ce43393214e3468b5ef327cda4040b", "patch": "@@ -10235,7 +10235,9 @@ Index_expression::do_traverse(Traverse* traverse)\n   if (Expression::traverse(&this->left_, traverse) == TRAVERSE_EXIT\n       || Expression::traverse(&this->start_, traverse) == TRAVERSE_EXIT\n       || (this->end_ != NULL\n-\t  && Expression::traverse(&this->end_, traverse) == TRAVERSE_EXIT))\n+\t  && Expression::traverse(&this->end_, traverse) == TRAVERSE_EXIT)\n+      || (this->cap_ != NULL\n+          && Expression::traverse(&this->cap_, traverse) == TRAVERSE_EXIT))\n     return TRAVERSE_EXIT;\n   return TRAVERSE_CONTINUE;\n }\n@@ -10250,6 +10252,7 @@ Index_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n   Expression* left = this->left_;\n   Expression* start = this->start_;\n   Expression* end = this->end_;\n+  Expression* cap = this->cap_;\n \n   Type* type = left->type();\n   if (type->is_error())\n@@ -10260,20 +10263,27 @@ Index_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n       return Expression::make_error(location);\n     }\n   else if (type->array_type() != NULL)\n-    return Expression::make_array_index(left, start, end, location);\n+    return Expression::make_array_index(left, start, end, cap, location);\n   else if (type->points_to() != NULL\n \t   && type->points_to()->array_type() != NULL\n \t   && !type->points_to()->is_slice_type())\n     {\n       Expression* deref = Expression::make_unary(OPERATOR_MULT, left,\n \t\t\t\t\t\t location);\n-      return Expression::make_array_index(deref, start, end, location);\n+      return Expression::make_array_index(deref, start, end, cap, location);\n     }\n   else if (type->is_string_type())\n-    return Expression::make_string_index(left, start, end, location);\n+    {\n+      if (cap != NULL)\n+        {\n+          error_at(location, \"invalid 3-index slice of string\");\n+          return Expression::make_error(location);\n+        }\n+      return Expression::make_string_index(left, start, end, location);\n+    }\n   else if (type->map_type() != NULL)\n     {\n-      if (end != NULL)\n+      if (end != NULL || cap != NULL)\n \t{\n \t  error_at(location, \"invalid slice of map\");\n \t  return Expression::make_error(location);\n@@ -10292,14 +10302,15 @@ Index_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n     }\n }\n \n-// Write an indexed expression (expr[expr:expr] or expr[expr]) to a\n-// dump context\n+// Write an indexed expression\n+// (expr[expr:expr:expr], expr[expr:expr] or expr[expr]) to a dump context.\n \n void\n Index_expression::dump_index_expression(Ast_dump_context* ast_dump_context, \n \t\t\t\t\tconst Expression* expr, \n \t\t\t\t\tconst Expression* start,\n-\t\t\t\t\tconst Expression* end)\n+\t\t\t\t\tconst Expression* end,\n+\t\t\t\t\tconst Expression* cap)\n {\n   expr->dump_expression(ast_dump_context);\n   ast_dump_context->ostream() << \"[\";\n@@ -10309,6 +10320,11 @@ Index_expression::dump_index_expression(Ast_dump_context* ast_dump_context,\n       ast_dump_context->ostream() << \":\";\n       end->dump_expression(ast_dump_context);\n     }\n+  if (cap != NULL)\n+    {\n+      ast_dump_context->ostream() << \":\";\n+      cap->dump_expression(ast_dump_context);\n+    }\n   ast_dump_context->ostream() << \"]\";\n }\n \n@@ -10319,16 +10335,16 @@ Index_expression::do_dump_expression(Ast_dump_context* ast_dump_context)\n     const\n {\n   Index_expression::dump_index_expression(ast_dump_context, this->left_, \n-                                          this->start_, this->end_);\n+                                          this->start_, this->end_, this->cap_);\n }\n \n // Make an index expression.\n \n Expression*\n Expression::make_index(Expression* left, Expression* start, Expression* end,\n-\t\t       Location location)\n+\t\t       Expression* cap, Location location)\n {\n-  return new Index_expression(left, start, end, location);\n+  return new Index_expression(left, start, end, cap, location);\n }\n \n // An array index.  This is used for both indexing and slicing.\n@@ -10337,9 +10353,9 @@ class Array_index_expression : public Expression\n {\n  public:\n   Array_index_expression(Expression* array, Expression* start,\n-\t\t\t Expression* end, Location location)\n+\t\t\t Expression* end, Expression* cap, Location location)\n     : Expression(EXPRESSION_ARRAY_INDEX, location),\n-      array_(array), start_(start), end_(end), type_(NULL)\n+      array_(array), start_(start), end_(end), cap_(cap), type_(NULL)\n   { }\n \n  protected:\n@@ -10363,6 +10379,9 @@ class Array_index_expression : public Expression\n \t\t\t\t\t(this->end_ == NULL\n \t\t\t\t\t ? NULL\n \t\t\t\t\t : this->end_->copy()),\n+\t\t\t\t\t(this->cap_ == NULL\n+\t\t\t\t\t ? NULL\n+\t\t\t\t\t : this->cap_->copy()),\n \t\t\t\t\tthis->location());\n   }\n \n@@ -10394,6 +10413,9 @@ class Array_index_expression : public Expression\n   // The end index of a slice.  This may be NULL for a simple array\n   // index, or it may be a nil expression for the length of the array.\n   Expression* end_;\n+  // The capacity argument of a slice.  This may be NULL for an array index or\n+  // slice.\n+  Expression* cap_;\n   // The type of the expression.\n   Type* type_;\n };\n@@ -10412,6 +10434,11 @@ Array_index_expression::do_traverse(Traverse* traverse)\n       if (Expression::traverse(&this->end_, traverse) == TRAVERSE_EXIT)\n \treturn TRAVERSE_EXIT;\n     }\n+  if (this->cap_ != NULL)\n+    {\n+      if (Expression::traverse(&this->cap_, traverse) == TRAVERSE_EXIT)\n+        return TRAVERSE_EXIT;\n+    }\n   return TRAVERSE_CONTINUE;\n }\n \n@@ -10451,6 +10478,8 @@ Array_index_expression::do_determine_type(const Type_context*)\n   this->start_->determine_type_no_context();\n   if (this->end_ != NULL)\n     this->end_->determine_type_no_context();\n+  if (this->cap_ != NULL)\n+    this->cap_->determine_type_no_context();\n }\n \n // Check types of an array index.\n@@ -10473,6 +10502,14 @@ Array_index_expression::do_check_types(Gogo*)\n       && (!this->end_->numeric_constant_value(&nc)\n \t  || nc.to_unsigned_long(&v) == Numeric_constant::NC_UL_NOTINT))\n     this->report_error(_(\"slice end must be integer\"));\n+  if (this->cap_ != NULL\n+      && this->cap_->type()->integer_type() == NULL\n+      && !this->cap_->type()->is_error()\n+      && !this->cap_->is_nil_expression()\n+      && !this->cap_->is_error_expression()\n+      && (!this->cap_->numeric_constant_value(&nc)\n+\t  || nc.to_unsigned_long(&v) == Numeric_constant::NC_UL_NOTINT))\n+    this->report_error(_(\"slice capacity must be integer\"));\n \n   Array_type* array_type = this->array_->type()->array_type();\n   if (array_type == NULL)\n@@ -10510,8 +10547,10 @@ Array_index_expression::do_check_types(Gogo*)\n     {\n       Numeric_constant enc;\n       mpz_t eval;\n+      bool eval_valid = false;\n       if (this->end_->numeric_constant_value(&enc) && enc.to_int(&eval))\n \t{\n+\t  eval_valid = true;\n \t  if (mpz_sgn(eval) < 0\n \t      || mpz_sizeinbase(eval, 2) >= int_bits\n \t      || (lval_valid && mpz_cmp(eval, lval) > 0))\n@@ -10521,8 +10560,37 @@ Array_index_expression::do_check_types(Gogo*)\n \t    }\n \t  else if (ival_valid && mpz_cmp(ival, eval) > 0)\n \t    this->report_error(_(\"inverted slice range\"));\n-\t  mpz_clear(eval);\n \t}\n+\n+      Numeric_constant cnc;\n+      mpz_t cval;\n+      if (this->cap_ != NULL\n+          && this->cap_->numeric_constant_value(&cnc) && cnc.to_int(&cval))\n+        {\n+          if (mpz_sgn(cval) < 0\n+              || mpz_sizeinbase(cval, 2) >= int_bits\n+              || (lval_valid && mpz_cmp(cval, lval) > 0))\n+            {\n+              error_at(this->cap_->location(), \"array index out of bounds\");\n+              this->set_is_error();\n+            }\n+\t  else if (ival_valid && mpz_cmp(ival, cval) > 0)\n+\t    {\n+\t      error_at(this->cap_->location(),\n+\t\t       \"invalid slice index: capacity less than start\");\n+\t      this->set_is_error();\n+\t    }\n+          else if (eval_valid && mpz_cmp(eval, cval) > 0)\n+            {\n+              error_at(this->cap_->location(),\n+                       \"invalid slice index: capacity less than length\");\n+              this->set_is_error();\n+            }\n+          mpz_clear(cval);\n+        }\n+\n+      if (eval_valid)\n+        mpz_clear(eval);\n     }\n   if (ival_valid)\n     mpz_clear(ival);\n@@ -10602,9 +10670,17 @@ Array_index_expression::do_get_tree(Translate_context* context)\n       capacity_tree = save_expr(capacity_tree);\n     }\n \n+  tree cap_arg = capacity_tree;\n+  if (this->cap_ != NULL)\n+    {\n+      cap_arg = this->cap_->get_tree(context);\n+      if (cap_arg == error_mark_node)\n+        return error_mark_node;\n+    }\n+\n   tree length_type = (length_tree != NULL_TREE\n \t\t      ? TREE_TYPE(length_tree)\n-\t\t      : TREE_TYPE(capacity_tree));\n+\t\t      : TREE_TYPE(cap_arg));\n \n   tree bad_index = boolean_false_node;\n \n@@ -10676,6 +10752,29 @@ Array_index_expression::do_get_tree(Translate_context* context)\n \n   // Array slice.\n \n+  if (this->cap_ != NULL)\n+    {\n+      if (!DECL_P(cap_arg))\n+        cap_arg = save_expr(cap_arg);\n+      if (!INTEGRAL_TYPE_P(TREE_TYPE(cap_arg)))\n+        cap_arg = convert_to_integer(length_type, cap_arg);\n+\n+      bad_index = Expression::check_bounds(cap_arg, length_type, bad_index,\n+                                           loc);\n+      cap_arg = fold_convert_loc(loc.gcc_location(), length_type, cap_arg);\n+\n+      tree bad_cap = fold_build2_loc(loc.gcc_location(), TRUTH_OR_EXPR,\n+                                     boolean_type_node,\n+                                     fold_build2_loc(loc.gcc_location(),\n+                                                     LT_EXPR, boolean_type_node,\n+                                                     cap_arg, start_tree),\n+                                     fold_build2_loc(loc.gcc_location(),\n+                                                     GT_EXPR, boolean_type_node,\n+                                                     cap_arg, capacity_tree));\n+      bad_index = fold_build2_loc(loc.gcc_location(), TRUTH_OR_EXPR,\n+                                  boolean_type_node, bad_index, bad_cap);\n+    }\n+\n   tree end_tree;\n   if (this->end_->is_nil_expression())\n     end_tree = length_tree;\n@@ -10701,11 +10800,12 @@ Array_index_expression::do_get_tree(Translate_context* context)\n \t\t\t\t\t\t     end_tree, start_tree),\n \t\t\t\t     fold_build2_loc(loc.gcc_location(),\n                                                      GT_EXPR, boolean_type_node,\n-\t\t\t\t\t\t     end_tree, capacity_tree));\n+\t\t\t\t\t\t     end_tree, cap_arg));\n       bad_index = fold_build2_loc(loc.gcc_location(), TRUTH_OR_EXPR,\n                                   boolean_type_node, bad_index, bad_end);\n     }\n \n+\n   Type* element_type = array_type->element_type();\n   tree element_type_tree = type_to_tree(element_type->get_backend(gogo));\n   if (element_type_tree == error_mark_node)\n@@ -10729,8 +10829,7 @@ Array_index_expression::do_get_tree(Translate_context* context)\n                                             length_type, end_tree, start_tree);\n \n   tree result_capacity_tree = fold_build2_loc(loc.gcc_location(), MINUS_EXPR,\n-                                              length_type, capacity_tree,\n-                                              start_tree);\n+                                              length_type, cap_arg, start_tree);\n \n   tree struct_tree = type_to_tree(this->type()->get_backend(gogo));\n   go_assert(TREE_CODE(struct_tree) == RECORD_TYPE);\n@@ -10780,16 +10879,17 @@ Array_index_expression::do_dump_expression(Ast_dump_context* ast_dump_context)\n     const\n {\n   Index_expression::dump_index_expression(ast_dump_context, this->array_, \n-                                          this->start_, this->end_);\n+                                          this->start_, this->end_, this->cap_);\n }\n \n-// Make an array index expression.  END may be NULL.\n+// Make an array index expression.  END and CAP may be NULL.\n \n Expression*\n Expression::make_array_index(Expression* array, Expression* start,\n-\t\t\t     Expression* end, Location location)\n+                             Expression* end, Expression* cap,\n+                             Location location)\n {\n-  return new Array_index_expression(array, start, end, location);\n+  return new Array_index_expression(array, start, end, cap, location);\n }\n \n // A string index.  This is used for both indexing and slicing.\n@@ -11067,8 +11167,8 @@ void\n String_index_expression::do_dump_expression(Ast_dump_context* ast_dump_context)\n     const\n {\n-  Index_expression::dump_index_expression(ast_dump_context, this->string_, \n-\t\t\t\t\t  this->start_, this->end_);\n+  Index_expression::dump_index_expression(ast_dump_context, this->string_,\n+                                          this->start_, this->end_, NULL);\n }\n \n // Make a string index expression.  END may be NULL.\n@@ -11295,8 +11395,8 @@ void\n Map_index_expression::do_dump_expression(Ast_dump_context* ast_dump_context) \n     const\n {\n-  Index_expression::dump_index_expression(ast_dump_context, \n-                                          this->map_, this->index_, NULL);\n+  Index_expression::dump_index_expression(ast_dump_context, this->map_,\n+                                          this->index_, NULL, NULL);\n }\n \n // Make a map index expression."}, {"sha": "a94330dc4d77b03baebb46a83a7f7a9c2c15081f", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26b8f7ebf5ce43393214e3468b5ef327cda4040b/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26b8f7ebf5ce43393214e3468b5ef327cda4040b/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=26b8f7ebf5ce43393214e3468b5ef327cda4040b", "patch": "@@ -232,19 +232,21 @@ class Expression\n \t\t    Named_object* function, Location);\n \n   // Make an index or slice expression.  This is a parser expression\n-  // which represents LEFT[START:END].  END may be NULL, meaning an\n-  // index rather than a slice.  At parse time we may not know the\n-  // type of LEFT.  After parsing this is lowered to an array index, a\n-  // string index, or a map index.\n+  // which represents LEFT[START:END:CAP].  END may be NULL, meaning an\n+  // index rather than a slice.  CAP may be NULL, meaning we use the default\n+  // capacity of LEFT. At parse time we may not know the type of LEFT.\n+  // After parsing this is lowered to an array index, a string index,\n+  // or a map index.\n   static Expression*\n   make_index(Expression* left, Expression* start, Expression* end,\n-\t     Location);\n+             Expression* cap, Location);\n \n   // Make an array index expression.  END may be NULL, in which case\n-  // this is an lvalue.\n+  // this is an lvalue.  CAP may be NULL, in which case it defaults\n+  // to cap(ARRAY).\n   static Expression*\n   make_array_index(Expression* array, Expression* start, Expression* end,\n-\t\t   Location);\n+                   Expression* cap, Location);\n \n   // Make a string index expression.  END may be NULL.  This is never\n   // an lvalue.\n@@ -1672,9 +1674,9 @@ class Index_expression : public Parser_expression\n {\n  public:\n   Index_expression(Expression* left, Expression* start, Expression* end,\n-\t\t   Location location)\n+                   Expression* cap, Location location)\n     : Parser_expression(EXPRESSION_INDEX, location),\n-      left_(left), start_(start), end_(end), is_lvalue_(false)\n+      left_(left), start_(start), end_(end), cap_(cap), is_lvalue_(false)\n   { }\n \n   // Record that this expression is an lvalue.\n@@ -1683,10 +1685,11 @@ class Index_expression : public Parser_expression\n   { this->is_lvalue_ = true; }\n \n   // Dump an index expression, i.e. an expression of the form\n-  // expr[expr] or expr[expr:expr], to a dump context.\n+  // expr[expr], expr[expr:expr], or expr[expr:expr:expr] to a dump context.\n   static void\n   dump_index_expression(Ast_dump_context*, const Expression* expr, \n-                        const Expression* start, const Expression* end);\n+                        const Expression* start, const Expression* end,\n+                        const Expression* cap);\n \n  protected:\n   int\n@@ -1702,6 +1705,9 @@ class Index_expression : public Parser_expression\n \t\t\t\t(this->end_ == NULL\n \t\t\t\t ? NULL\n \t\t\t\t : this->end_->copy()),\n+\t\t\t\t(this->cap_ == NULL\n+\t\t\t\t ? NULL\n+\t\t\t\t : this->cap_->copy()),\n \t\t\t\tthis->location());\n   }\n \n@@ -1723,6 +1729,10 @@ class Index_expression : public Parser_expression\n   // The second index.  This is NULL for an index, non-NULL for a\n   // slice.\n   Expression* end_;\n+  // The capacity argument.  This is NULL for indices and slices that use the\n+  // default capacity, non-NULL for indices and slices that specify the\n+  // capacity.\n+  Expression* cap_;\n   // Whether this is being used as an l-value.  We set this during the\n   // parse because map index expressions need to know.\n   bool is_lvalue_;"}, {"sha": "6e56f835699ee648c155fe09cd68ab6552d42b05", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26b8f7ebf5ce43393214e3468b5ef327cda4040b/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26b8f7ebf5ce43393214e3468b5ef327cda4040b/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=26b8f7ebf5ce43393214e3468b5ef327cda4040b", "patch": "@@ -3152,7 +3152,7 @@ Parse::selector(Expression* left, bool* is_type_switch)\n }\n \n // Index          = \"[\" Expression \"]\" .\n-// Slice          = \"[\" Expression \":\" [ Expression ] \"]\" .\n+// Slice          = \"[\" Expression \":\" [ Expression ] [ \":\" Expression ] \"]\" .\n \n Expression*\n Parse::index(Expression* expr)\n@@ -3178,14 +3178,31 @@ Parse::index(Expression* expr)\n       // We use nil to indicate a missing high expression.\n       if (this->advance_token()->is_op(OPERATOR_RSQUARE))\n \tend = Expression::make_nil(this->location());\n+      else if (this->peek_token()->is_op(OPERATOR_COLON))\n+\t{\n+\t  error_at(this->location(), \"middle index required in 3-index slice\");\n+\t  end = Expression::make_error(this->location());\n+\t}\n       else\n \tend = this->expression(PRECEDENCE_NORMAL, false, true, NULL, NULL);\n     }\n+\n+  Expression* cap = NULL;\n+  if (this->peek_token()->is_op(OPERATOR_COLON))\n+    {\n+      if (this->advance_token()->is_op(OPERATOR_RSQUARE))\n+\t{\n+\t  error_at(this->location(), \"final index required in 3-index slice\");\n+\t  cap = Expression::make_error(this->location());\n+\t}\n+      else\n+        cap = this->expression(PRECEDENCE_NORMAL, false, true, NULL, NULL);\n+    }\n   if (!this->peek_token()->is_op(OPERATOR_RSQUARE))\n     error_at(this->location(), \"missing %<]%>\");\n   else\n     this->advance_token();\n-  return Expression::make_index(expr, start, end, location);\n+  return Expression::make_index(expr, start, end, cap, location);\n }\n \n // Call           = \"(\" [ ArgumentList [ \",\" ] ] \")\" ."}, {"sha": "3a0bc3b9739e1c42e597a3427b39ad61fab00fd6", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26b8f7ebf5ce43393214e3468b5ef327cda4040b/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26b8f7ebf5ce43393214e3468b5ef327cda4040b/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=26b8f7ebf5ce43393214e3468b5ef327cda4040b", "patch": "@@ -5540,7 +5540,7 @@ For_range_statement::lower_range_array(Gogo* gogo,\n \n       ref = this->make_range_ref(range_object, range_temp, loc);\n       Expression* ref2 = Expression::make_temporary_reference(index_temp, loc);\n-      Expression* index = Expression::make_index(ref, ref2, NULL, loc);\n+      Expression* index = Expression::make_index(ref, ref2, NULL, NULL, loc);\n \n       tref = Expression::make_temporary_reference(value_temp, loc);\n       tref->set_is_lvalue();\n@@ -5641,7 +5641,7 @@ For_range_statement::lower_range_slice(Gogo* gogo,\n \n       ref = Expression::make_temporary_reference(for_temp, loc);\n       Expression* ref2 = Expression::make_temporary_reference(index_temp, loc);\n-      Expression* index = Expression::make_index(ref, ref2, NULL, loc);\n+      Expression* index = Expression::make_index(ref, ref2, NULL, NULL, loc);\n \n       tref = Expression::make_temporary_reference(value_temp, loc);\n       tref->set_is_lvalue();\n@@ -5849,7 +5849,7 @@ For_range_statement::lower_range_map(Gogo*,\n   Expression* zexpr = Expression::make_integer(&zval, NULL, loc);\n   mpz_clear(zval);\n \n-  Expression* index = Expression::make_index(ref, zexpr, NULL, loc);\n+  Expression* index = Expression::make_index(ref, zexpr, NULL, NULL, loc);\n \n   Expression* ne = Expression::make_binary(OPERATOR_NOTEQ, index,\n \t\t\t\t\t   Expression::make_nil(loc),"}, {"sha": "ea68c43714b81b9f0e7669c78a50c586319d54bb", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26b8f7ebf5ce43393214e3468b5ef327cda4040b/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26b8f7ebf5ce43393214e3468b5ef327cda4040b/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=26b8f7ebf5ce43393214e3468b5ef327cda4040b", "patch": "@@ -5645,12 +5645,12 @@ Array_type::write_equal_function(Gogo* gogo, Named_type* name)\n   Expression* e1 = Expression::make_temporary_reference(p1, bloc);\n   e1 = Expression::make_unary(OPERATOR_MULT, e1, bloc);\n   ref = Expression::make_temporary_reference(index, bloc);\n-  e1 = Expression::make_array_index(e1, ref, NULL, bloc);\n+  e1 = Expression::make_array_index(e1, ref, NULL, NULL, bloc);\n \n   Expression* e2 = Expression::make_temporary_reference(p2, bloc);\n   e2 = Expression::make_unary(OPERATOR_MULT, e2, bloc);\n   ref = Expression::make_temporary_reference(index, bloc);\n-  e2 = Expression::make_array_index(e2, ref, NULL, bloc);\n+  e2 = Expression::make_array_index(e2, ref, NULL, NULL, bloc);\n \n   Expression* cond = Expression::make_binary(OPERATOR_NOTEQ, e1, e2, bloc);\n "}]}