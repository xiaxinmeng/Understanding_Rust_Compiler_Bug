{"sha": "44780b91eb61d1a4ae3a6f94300d1b97a1d06557", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ3ODBiOTFlYjYxZDFhNGFlM2E2Zjk0MzAwZDFiOTdhMWQwNjU1Nw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2018-04-05T04:26:36Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2018-04-05T04:26:36Z"}, "message": "[PR c++/84979] reject auto in explicit tmpl args for tmpl-fn\n\nWith concepts, we accept auto in explicit template arguments, but we\nshould only accept them for template classes.  Passing them to\ntemplate functions or variables is not allowed.  So, reject it, at\nparse time if possible, at specialization time otherwise.\n\n\nfor  gcc/cp/ChangeLog\n\n\tPR c++/84979\n\t* pt.c (check_auto_in_tmpl_args): New.\n\t(tsubst_qualified_id): Use it to reject template args\n\treferencing auto for non-type templates.\n\t* parser.c (cp_parser_template_id): Likewise.\n\t* cp-tree.h (check_auto_in_tmpl_args): Declare.\n\t* typeck2.c (build_functional_cast): Report correct location\n\tfor invalid use of auto.\n\nfor  gcc/testsuite/ChangeLog\n\n\tPR c++/84979\n\t* g++.dg/concepts/pr84979.C: New.\n\t* g++.dg/concepts/pr84979-2.C: New.\n\t* g++.dg/concepts/pr84979-3.C: New.\n\nFrom-SVN: r259124", "tree": {"sha": "06ddb1def51912f29c6d94f008bbdf5cc0ed872b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06ddb1def51912f29c6d94f008bbdf5cc0ed872b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44780b91eb61d1a4ae3a6f94300d1b97a1d06557", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44780b91eb61d1a4ae3a6f94300d1b97a1d06557", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44780b91eb61d1a4ae3a6f94300d1b97a1d06557", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44780b91eb61d1a4ae3a6f94300d1b97a1d06557/comments", "author": null, "committer": null, "parents": [{"sha": "da0c8d9793df1083a21628efdb6368174d2d78d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da0c8d9793df1083a21628efdb6368174d2d78d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da0c8d9793df1083a21628efdb6368174d2d78d4"}], "stats": {"total": 179, "additions": 177, "deletions": 2}, "files": [{"sha": "4ae78f73b2bdceab927381ddb5911f0d27799772", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44780b91eb61d1a4ae3a6f94300d1b97a1d06557/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44780b91eb61d1a4ae3a6f94300d1b97a1d06557/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=44780b91eb61d1a4ae3a6f94300d1b97a1d06557", "patch": "@@ -1,3 +1,14 @@\n+2018-04-05  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR c++/84979\n+\t* pt.c (check_auto_in_tmpl_args): New.\n+\t(tsubst_qualified_id): Use it to reject template args\n+\treferencing auto for non-type templates.\n+\t* parser.c (cp_parser_template_id): Likewise.\n+\t* cp-tree.h (check_auto_in_tmpl_args): Declare.\n+\t* typeck2.c (build_functional_cast): Report correct location\n+\tfor invalid use of auto.\n+\n 2018-04-04  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/85215 - ICE with copy-init from conversion."}, {"sha": "dbe34c096f0fd2c7729dc2d94abb64b23e04f8e2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44780b91eb61d1a4ae3a6f94300d1b97a1d06557/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44780b91eb61d1a4ae3a6f94300d1b97a1d06557/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=44780b91eb61d1a4ae3a6f94300d1b97a1d06557", "patch": "@@ -6500,6 +6500,7 @@ extern void maybe_show_extern_c_location (void);\n \n /* in pt.c */\n extern bool check_template_shadow\t\t(tree);\n+extern bool check_auto_in_tmpl_args             (tree, tree);\n extern tree get_innermost_template_args\t\t(tree, int);\n extern void maybe_begin_member_template_processing (tree);\n extern void maybe_end_member_template_processing (void);"}, {"sha": "0ffa13de5376d1252e30f273378497ae55c97cd0", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44780b91eb61d1a4ae3a6f94300d1b97a1d06557/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44780b91eb61d1a4ae3a6f94300d1b97a1d06557/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=44780b91eb61d1a4ae3a6f94300d1b97a1d06557", "patch": "@@ -15826,8 +15826,16 @@ cp_parser_template_id (cp_parser *parser,\n   location_t combined_loc\n     = make_location (token->location, token->location, finish_loc);\n \n+  /* Check for concepts autos where they don't belong.  We could\n+     identify types in some cases of idnetifier TEMPL, looking ahead\n+     for a CPP_SCOPE, but that would buy us nothing: we accept auto in\n+     types.  We reject them in functions, but if what we have is an\n+     identifier, even with none_type we can't conclude it's NOT a\n+     type, we have to wait for template substitution.  */\n+  if (flag_concepts && check_auto_in_tmpl_args (templ, arguments))\n+    template_id = error_mark_node;\n   /* Build a representation of the specialization.  */\n-  if (identifier_p (templ))\n+  else if (identifier_p (templ))\n     template_id = build_min_nt_loc (combined_loc,\n \t\t\t\t    TEMPLATE_ID_EXPR,\n \t\t\t\t    templ, arguments);"}, {"sha": "741c578b65ba188c1a9b04e8f0231ac33887fe78", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44780b91eb61d1a4ae3a6f94300d1b97a1d06557/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44780b91eb61d1a4ae3a6f94300d1b97a1d06557/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=44780b91eb61d1a4ae3a6f94300d1b97a1d06557", "patch": "@@ -14906,6 +14906,15 @@ tsubst_qualified_id (tree qualified_id, tree args,\n \n   if (is_template)\n     {\n+      /* We may be repeating a check already done during parsing, but\n+\t if it was well-formed and passed then, it will pass again\n+\t now, and if it didn't, we wouldn't have got here.  The case\n+\t we want to catch is when we couldn't tell then, and can now,\n+\t namely when templ prior to substitution was an\n+\t identifier.  */\n+      if (flag_concepts && check_auto_in_tmpl_args (expr, template_args))\n+\treturn error_mark_node;\n+\n       if (variable_template_p (expr))\n \texpr = lookup_and_finish_template_variable (expr, template_args,\n \t\t\t\t\t\t    complain);\n@@ -26550,6 +26559,49 @@ type_uses_auto (tree type)\n     return find_type_usage (type, is_auto);\n }\n \n+/* Report ill-formed occurrences of auto types in ARGUMENTS.  If\n+   concepts are enabled, auto is acceptable in template arguments, but\n+   only when TEMPL identifies a template class.  Return TRUE if any\n+   such errors were reported.  */\n+\n+bool\n+check_auto_in_tmpl_args (tree tmpl, tree args)\n+{\n+  /* If there were previous errors, nevermind.  */\n+  if (!args || TREE_CODE (args) != TREE_VEC)\n+    return false;\n+\n+  /* If TMPL is an identifier, we're parsing and we can't tell yet\n+     whether TMPL is supposed to be a type, a function or a variable.\n+     We'll only be able to tell during template substitution, so we\n+     expect to be called again then.  If concepts are enabled and we\n+     know we have a type, we're ok.  */\n+  if (flag_concepts\n+      && (identifier_p (tmpl)\n+\t  || (DECL_P (tmpl)\n+\t      &&  (DECL_TYPE_TEMPLATE_P (tmpl)\n+\t\t   || DECL_TEMPLATE_TEMPLATE_PARM_P (tmpl)))))\n+    return false;\n+\n+  /* Quickly search for any occurrences of auto; usually there won't\n+     be any, and then we'll avoid allocating the vector.  */\n+  if (!type_uses_auto (args))\n+    return false;\n+\n+  bool errors = false;\n+\n+  tree vec = extract_autos (args);\n+  for (int i = 0; i < TREE_VEC_LENGTH (vec); i++)\n+    {\n+      tree xauto = TREE_VALUE (TREE_VEC_ELT (vec, i));\n+      error_at (DECL_SOURCE_LOCATION (xauto),\n+\t\t\"invalid use of %qT in template argument\", xauto);\n+      errors = true;\n+    }\n+\n+  return errors;\n+}\n+\n /* For a given template T, return the vector of typedefs referenced\n    in T for which access check is needed at T instantiation time.\n    T is either  a FUNCTION_DECL or a RECORD_TYPE."}, {"sha": "3bdeae1501f5b3733230fd97bdf3d36fd2bd191e", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44780b91eb61d1a4ae3a6f94300d1b97a1d06557/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44780b91eb61d1a4ae3a6f94300d1b97a1d06557/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=44780b91eb61d1a4ae3a6f94300d1b97a1d06557", "patch": "@@ -2081,7 +2081,8 @@ build_functional_cast (tree exp, tree parms, tsubst_flags_t complain)\n       if (!CLASS_PLACEHOLDER_TEMPLATE (anode))\n \t{\n \t  if (complain & tf_error)\n-\t    error (\"invalid use of %qT\", anode);\n+\t    error_at (DECL_SOURCE_LOCATION (TEMPLATE_TYPE_DECL (anode)),\n+\t\t      \"invalid use of %qT\", anode);\n \t  return error_mark_node;\n \t}\n       else if (!parms)"}, {"sha": "570bfdca4dfc456b36a72ac25107f784a7c86d58", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44780b91eb61d1a4ae3a6f94300d1b97a1d06557/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44780b91eb61d1a4ae3a6f94300d1b97a1d06557/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=44780b91eb61d1a4ae3a6f94300d1b97a1d06557", "patch": "@@ -1,3 +1,10 @@\n+2018-04-05  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR c++/84979\n+\t* g++.dg/concepts/pr84979.C: New.\n+\t* g++.dg/concepts/pr84979-2.C: New.\n+\t* g++.dg/concepts/pr84979-3.C: New.\n+\n 2018-04-04  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/80026"}, {"sha": "ce69a0f8ac53169865de422d55d2a4536415c83f", "filename": "gcc/testsuite/g++.dg/concepts/pr84979-2.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44780b91eb61d1a4ae3a6f94300d1b97a1d06557/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr84979-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44780b91eb61d1a4ae3a6f94300d1b97a1d06557/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr84979-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr84979-2.C?ref=44780b91eb61d1a4ae3a6f94300d1b97a1d06557", "patch": "@@ -0,0 +1,41 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-fconcepts\" }\n+\n+template <typename T>\n+void foo1(T& t) {\n+  typename T::template C<void> tcv = t;\n+  typename T::template C<auto> u = tcv;\n+  T::template C<auto>::f (tcv, u); // { dg-error \"incomplete\" }\n+  (typename T::template D<auto> (t)); // { dg-error \"invalid\" }\n+}\n+\n+struct T1 {\n+  template <typename T> struct C {\n+    C(T1&);\n+    static void f(T1&, C&);\n+  };\n+  template <typename T> struct D {\n+    D(T1&);\n+  };\n+};\n+\n+template <typename T>\n+void foo2(T& t) {\n+  typename T::template C<void> tcv = t;\n+  typename T::template C<auto> u = tcv;\n+  T::template C<auto>::f (tcv, u); // { dg-error \"incomplete\" }\n+  T::template D<auto> (t); // { dg-error \"invalid\" }\n+}\n+\n+struct T2 {\n+  template <typename T> struct C {\n+    C(T2&);\n+    static void f(T2&, C&);\n+  };\n+  template <typename T> static void D(T2&);\n+};\n+\n+void f(T1& t1, T2& t2) {\n+  foo1 (t1);\n+  foo2 (t2);\n+}"}, {"sha": "3809c2d3033bacfc198762885e4983dadf5da642", "filename": "gcc/testsuite/g++.dg/concepts/pr84979-3.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44780b91eb61d1a4ae3a6f94300d1b97a1d06557/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr84979-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44780b91eb61d1a4ae3a6f94300d1b97a1d06557/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr84979-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr84979-3.C?ref=44780b91eb61d1a4ae3a6f94300d1b97a1d06557", "patch": "@@ -0,0 +1,45 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-fconcepts\" }\n+\n+// This is like pr84979-2.C, except that we swap the types passed to\n+// the template functions foo1 and foo2, so that the expectations WRT\n+// D's typeness are not met.\n+\n+template <typename T>\n+void foo1(T& t) {\n+  typename T::template C<void> tcv = t;\n+  typename T::template C<auto> u = tcv;\n+  T::template C<auto>::f (tcv, u); // { dg-error \"incomplete\" }\n+  (typename T::template D<auto> (t)); // { dg-error \"invalid\" }\n+}\n+\n+struct T1 {\n+  template <typename T> struct C {\n+    C(T1&);\n+    static void f(T1&, C&);\n+  };\n+  template <typename T> struct D {\n+    D(T1&);\n+  };\n+};\n+\n+template <typename T>\n+void foo2(T& t) {\n+  typename T::template C<void> tcv = t;\n+  typename T::template C<auto> u = tcv;\n+  T::template C<auto>::f (tcv, u); // { dg-error \"incomplete\" }\n+  T::template D<auto> (t); // { dg-error \"yields a type\" }\n+}\n+\n+struct T2 {\n+  template <typename T> struct C {\n+    C(T2&);\n+    static void f(T2&, C&);\n+  };\n+  template <typename T> static void D(T2&);\n+};\n+\n+void f(T1& t1, T2& t2) {\n+  foo1 (t2);\n+  foo2 (t1);\n+}"}, {"sha": "9bd40df103a8812ee0b887c70f771ebf6aedbf78", "filename": "gcc/testsuite/g++.dg/concepts/pr84979.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44780b91eb61d1a4ae3a6f94300d1b97a1d06557/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr84979.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44780b91eb61d1a4ae3a6f94300d1b97a1d06557/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr84979.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr84979.C?ref=44780b91eb61d1a4ae3a6f94300d1b97a1d06557", "patch": "@@ -0,0 +1,9 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-fconcepts\" }\n+\n+template<typename> void foo() {}\n+\n+void bar()\n+{\n+  foo<auto>(); // { dg-error \"invalid\" }\n+}"}]}