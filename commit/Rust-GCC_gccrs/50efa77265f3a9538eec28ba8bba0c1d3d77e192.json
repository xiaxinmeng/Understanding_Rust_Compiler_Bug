{"sha": "50efa77265f3a9538eec28ba8bba0c1d3d77e192", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBlZmE3NzI2NWYzYTk1MzhlZWMyOGJhOGJiYTBjMWQzZDc3ZTE5Mg==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2013-05-22T08:06:53Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2013-05-22T08:06:53Z"}, "message": "Improve RANDOM_SEED example.\n\n2013-05-22  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\t* intrinsic.texi (RANDOM_SEED): Improve example.\n\nFrom-SVN: r199182", "tree": {"sha": "4e6c0e652f5bf0c870b07805d0381caea06cdb34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e6c0e652f5bf0c870b07805d0381caea06cdb34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50efa77265f3a9538eec28ba8bba0c1d3d77e192", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50efa77265f3a9538eec28ba8bba0c1d3d77e192", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50efa77265f3a9538eec28ba8bba0c1d3d77e192", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50efa77265f3a9538eec28ba8bba0c1d3d77e192/comments", "author": null, "committer": null, "parents": [{"sha": "c0602ab82fb900a92cdeb0b09dfbf16a993aaf7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0602ab82fb900a92cdeb0b09dfbf16a993aaf7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0602ab82fb900a92cdeb0b09dfbf16a993aaf7b"}], "stats": {"total": 74, "additions": 57, "deletions": 17}, "files": [{"sha": "89d83cf5bca4fde3e8dedd95ef3dc3ffd7e347cf", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50efa77265f3a9538eec28ba8bba0c1d3d77e192/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50efa77265f3a9538eec28ba8bba0c1d3d77e192/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=50efa77265f3a9538eec28ba8bba0c1d3d77e192", "patch": "@@ -1,3 +1,7 @@\n+2013-05-22  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\t* intrinsic.texi (RANDOM_SEED): Improve example.\n+\n 2013-05-21  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/57035"}, {"sha": "db4d748c87644ec1b6b811d8fd4cf7b293bb28e8", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 53, "deletions": 17, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50efa77265f3a9538eec28ba8bba0c1d3d77e192/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50efa77265f3a9538eec28ba8bba0c1d3d77e192/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=50efa77265f3a9538eec28ba8bba0c1d3d77e192", "patch": "@@ -10173,9 +10173,12 @@ end program\n Restarts or queries the state of the pseudorandom number generator used by \n @code{RANDOM_NUMBER}.\n \n-If @code{RANDOM_SEED} is called without arguments, it is initialized to\n-a default state. The example below shows how to initialize the random \n-seed based on the system's time.\n+If @code{RANDOM_SEED} is called without arguments, it is initialized\n+to a default state. The example below shows how to initialize the\n+random seed with a varying seed in order to ensure a different random\n+number sequence for each invocation of the program. Note that setting\n+any of the seed values to zero should be avoided as it can result in\n+poor quality random numbers being generated.\n \n @item @emph{Standard}:\n Fortran 95 and later\n@@ -10203,20 +10206,53 @@ the @var{SIZE} argument.\n \n @item @emph{Example}:\n @smallexample\n-SUBROUTINE init_random_seed()\n-  INTEGER :: i, n, clock\n-  INTEGER, DIMENSION(:), ALLOCATABLE :: seed\n-\n-  CALL RANDOM_SEED(size = n)\n-  ALLOCATE(seed(n))\n-\n-  CALL SYSTEM_CLOCK(COUNT=clock)\n-\n-  seed = clock + 37 * (/ (i - 1, i = 1, n) /)\n-  CALL RANDOM_SEED(PUT = seed)\n-\n-  DEALLOCATE(seed)\n-END SUBROUTINE\n+subroutine init_random_seed()\n+  implicit none\n+  integer, allocatable :: seed(:)\n+  integer :: i, n, un, istat, dt(8), pid, t(2), s\n+  integer(8) :: count, tms\n+  \n+  call random_seed(size = n)\n+  allocate(seed(n))\n+  ! First try if the OS provides a random number generator\n+  open(newunit=un, file=\"/dev/urandom\", access=\"stream\", &\n+       form=\"unformatted\", action=\"read\", status=\"old\", iostat=istat)\n+  if (istat == 0) then\n+     read(un) seed\n+     close(un)\n+  else\n+     ! Fallback to XOR:ing the current time and pid. The PID is\n+     ! useful in case one launches multiple instances of the same\n+     ! program in parallel.\n+     call system_clock(count)\n+     if (count /= 0) then\n+        t = transfer(count, t)\n+     else\n+        call date_and_time(values=dt)\n+        tms = (dt(1) - 1970) * 365_8 * 24 * 60 * 60 * 1000 &\n+             + dt(2) * 31_8 * 24 * 60 * 60 * 1000 &\n+             + dt(3) * 24 * 60 * 60 * 60 * 1000 &\n+             + dt(5) * 60 * 60 * 1000 &\n+             + dt(6) * 60 * 1000 + dt(7) * 1000 &\n+             + dt(8)\n+        t = transfer(tms, t)\n+     end if\n+     s = ieor(t(1), t(2))\n+     pid = getpid() + 1099279 ! Add a prime\n+     s = ieor(s, pid)\n+     if (n >= 3) then\n+        seed(1) = t(1) + 36269\n+        seed(2) = t(2) + 72551\n+        seed(3) = pid\n+        if (n > 3) then\n+           seed(4:) = s + 37 * (/ (i, i = 0, n - 4) /)\n+        end if\n+     else \n+        seed = s + 37 * (/ (i, i = 0, n - 1 ) /)\n+     end if\n+  end if\n+  call random_seed(put=seed)\n+end subroutine init_random_seed\n @end smallexample\n \n @item @emph{See also}:"}]}