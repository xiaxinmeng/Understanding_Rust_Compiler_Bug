{"sha": "35523fce7493b23c87d400b4942f61a9fcddf43a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU1MjNmY2U3NDkzYjIzYzg3ZDQwMGI0OTQyZjYxYTlmY2RkZjQzYQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-03-28T21:25:08Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-03-28T21:25:08Z"}, "message": "reorg.c (ANNUL_IFTRUE_SLOTS, [...]): Add new flags variable to these dummy macros.\n\n\t* reorg.c (ANNUL_IFTRUE_SLOTS, ANNUL_IFFALSE_SLOTS): Add new\n\tflags variable to these dummy macros.\n\t(get_jump_flags): New function.\n\t(optimize_skip): Get jump flags information from the delay insn.\n\t(steal_delay_list_from_target): Get jump flags information from the\n\tdelay insn and the label of the trial jump.\n\t(steal_delay_list_from_fallthrough): Get jump flags information\n\tfrom the delay insn.\n\t(try_merge_delay_insns): Likewise.\n\t(fill_simple_delay_slots): Likewise.\n\t(fill_slots_from_thread): Likewise.\n\t(make_return_insn): Likewise.\n\nFrom-SVN: r3904", "tree": {"sha": "1d74671217c5c6befaa921620f28b452b622f04a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d74671217c5c6befaa921620f28b452b622f04a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35523fce7493b23c87d400b4942f61a9fcddf43a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35523fce7493b23c87d400b4942f61a9fcddf43a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35523fce7493b23c87d400b4942f61a9fcddf43a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35523fce7493b23c87d400b4942f61a9fcddf43a/comments", "author": null, "committer": null, "parents": [{"sha": "0b0316dc4307a5445525d433d03f887fb59cf3b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b0316dc4307a5445525d433d03f887fb59cf3b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b0316dc4307a5445525d433d03f887fb59cf3b0"}], "stats": {"total": 146, "additions": 122, "deletions": 24}, "files": [{"sha": "787d9ff2b107ff6e80a95bcd9d8c3c2b8ca079fd", "filename": "gcc/reorg.c", "status": "modified", "additions": 122, "deletions": 24, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35523fce7493b23c87d400b4942f61a9fcddf43a/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35523fce7493b23c87d400b4942f61a9fcddf43a/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=35523fce7493b23c87d400b4942f61a9fcddf43a", "patch": "@@ -53,6 +53,13 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    target that would only be safe to execute knowing that the branch\n    is taken.\n \n+   The HP-PA always has a branch delay slot.  For unconditional branches\n+   its effects can be annulled when the branch is taken.  The effects \n+   of the delay slot in a conditional branch can be nullified for forward\n+   taken branches, or for untaken backward branches.  This means\n+   we can hoist insns from the fall-through path for forward branches or\n+   steal insns from the target of backward branches.\n+\n    Three techniques for filling delay slots have been implemented so far:\n \n    (1) `fill_simple_delay_slots' is the simplest, most efficient way\n@@ -128,10 +135,10 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define obstack_chunk_free free\n \n #ifndef ANNUL_IFTRUE_SLOTS\n-#define eligible_for_annul_true(INSN, SLOTS, TRIAL) 0\n+#define eligible_for_annul_true(INSN, SLOTS, TRIAL, FLAGS) 0\n #endif\n #ifndef ANNUL_IFFALSE_SLOTS\n-#define eligible_for_annul_false(INSN, SLOTS, TRIAL) 0\n+#define eligible_for_annul_false(INSN, SLOTS, TRIAL, FLAGS) 0\n #endif\n \n /* Insns which have delay slots that have not yet been filled.  */\n@@ -221,6 +228,7 @@ static void delete_from_delay_slot PROTO((rtx));\n static void delete_scheduled_jump PROTO((rtx));\n static void note_delay_statistics PROTO((int, int));\n static rtx optimize_skip\tPROTO((rtx));\n+static int get_jump_flags PROTO((rtx, rtx));\n static int mostly_true_jump\tPROTO((rtx, rtx));\n static rtx get_branch_condition\tPROTO((rtx, rtx));\n static int condition_dominates_p PROTO((rtx, rtx));\n@@ -1048,13 +1056,16 @@ optimize_skip (insn)\n   rtx next_trial = next_active_insn (trial);\n   rtx delay_list = 0;\n   rtx target_label;\n+  int flags;\n+\n+  flags = get_jump_flags (insn, JUMP_LABEL (insn));\n \n   if (trial == 0\n       || GET_CODE (trial) != INSN\n       || GET_CODE (PATTERN (trial)) == SEQUENCE\n       || recog_memoized (trial) < 0\n-      || (! eligible_for_annul_false (insn, 0, trial)\n-\t  && ! eligible_for_annul_true (insn, 0, trial)))\n+      || (! eligible_for_annul_false (insn, 0, trial, flags)\n+\t  && ! eligible_for_annul_true (insn, 0, trial, flags)))\n     return 0;\n \n   /* There are two cases where we are just executing one insn (we assume\n@@ -1070,11 +1081,11 @@ optimize_skip (insn)\n \t  && (simplejump_p (next_trial)\n \t      || GET_CODE (PATTERN (next_trial)) == RETURN)))\n     {\n-      if (eligible_for_annul_false (insn, 0, trial))\n+      if (eligible_for_annul_false (insn, 0, trial, flags))\n \t{\n \t  if (invert_jump (insn, JUMP_LABEL (insn)))\n \t    INSN_FROM_TARGET_P (trial) = 1;\n-\t  else if (! eligible_for_annul_true (insn, 0, trial))\n+\t  else if (! eligible_for_annul_true (insn, 0, trial, flags))\n \t    return 0;\n \t}\n \n@@ -1104,6 +1115,74 @@ optimize_skip (insn)\n }\n #endif\n \f\n+\n+/*  Encode and return branch direction and prediction information for\n+    INSN assuming it will jump to LABEL.\n+\n+    Non conditional branches return no direction information and\n+    are predicted as very likely taken.  */\n+static int\n+get_jump_flags (insn, label)\n+     rtx insn, label;\n+{\n+  int flags;\n+\n+  /* get_jump_flags can be passed any insn with delay slots, these may\n+     be INSNs, CALL_INSNs, or JUMP_INSNs.  Only JUMP_INSNs have branch\n+     direction information, and only if they are conditional jumps.\n+\n+     If LABEL is zero, then there is no way to determine the branch\n+     direction.  */\n+  if (GET_CODE (insn) == JUMP_INSN\n+      && condjump_p (insn)\n+      && INSN_UID (insn) <= max_uid\n+      && INSN_UID (label) <= max_uid\n+      && label != 0)\n+    flags \n+      = (uid_to_ruid[INSN_UID (label)] > uid_to_ruid[INSN_UID (insn)])\n+\t ? ATTR_FLAG_forward : ATTR_FLAG_backward;\n+  /* No valid direction information.  */\n+  else\n+    flags = 0;\n+  \n+  /* If insn is a conditional branch call mostly_true_jump to get\n+     determine the branch prediction.  \n+\n+     Non conditional branches are predicted as very likely taken.  */\n+  if (GET_CODE (insn) == JUMP_INSN\n+      && condjump_p (insn))\n+    {\n+      int prediction;\n+\n+      prediction = mostly_true_jump (insn, get_branch_condition (insn, label));\n+      switch (prediction)\n+\t{\n+\t  case 2:\n+\t    flags |= (ATTR_FLAG_very_likely | ATTR_FLAG_likely);\n+\t    break;\n+\t  case 1:\n+\t    flags |= ATTR_FLAG_likely;\n+\t    break;\n+\n+\t  case 0:\n+\t    flags |= ATTR_FLAG_unlikely;\n+\t    break;\n+\t  /* mostly_true_jump does not return -1 for very unlikely jumps\n+\t     yet, but it should in the future.  */\n+\t  case -1:\n+\t    flags |= (ATTR_FLAG_very_unlikely | ATTR_FLAG_unlikely);\n+\t    break;\n+\n+\t  default:\n+\t    abort();\n+\t}\n+    }\n+  else\n+    flags |= (ATTR_FLAG_very_likely | ATTR_FLAG_likely);\n+\n+  return flags;\n+}\n+\n /* Return truth value of the statement that this branch\n    is mostly taken.  If we think that the branch is extremely likely\n    to be taken, we return 2.  If the branch is slightly more likely to be\n@@ -1315,6 +1394,7 @@ steal_delay_list_from_target (insn, condition, seq, delay_list,\n   for (i = 1; i < XVECLEN (seq, 0); i++)\n     {\n       rtx trial = XVECEXP (seq, 0, i);\n+      int flags;\n \n       if (insn_references_resource_p (trial, sets, 0)\n \t  || insn_sets_resource_p (trial, needed, 0)\n@@ -1335,13 +1415,17 @@ steal_delay_list_from_target (insn, condition, seq, delay_list,\n       if (redundant_insn_p (trial, insn, new_delay_list))\n \tcontinue;\n \n+      /* We will end up re-vectoring this branch, so compute flags\n+\t based on jumping to the new label.  */\n+      flags = get_jump_flags (insn, JUMP_LABEL (XVECEXP (seq, 0, 0)));\n+\n       if (! must_annul\n \t  && ((condition == const_true_rtx\n \t       || (! insn_sets_resource_p (trial, other_needed, 0)\n \t\t   && ! may_trap_p (PATTERN (trial)))))\n-\t  ? eligible_for_delay (insn, total_slots_filled, trial)\n+\t  ? eligible_for_delay (insn, total_slots_filled, trial, flags)\n \t  : (must_annul = 1,\n-\t     eligible_for_annul_false (insn, total_slots_filled, trial)))\n+\t     eligible_for_annul_false (insn, total_slots_filled, trial, flags)))\n \t{\n \t  temp = copy_rtx (trial);\n \t  INSN_FROM_TARGET_P (temp) = 1;\n@@ -1390,6 +1474,9 @@ steal_delay_list_from_fallthrough (insn, condition, seq,\n      int *pannul_p;\n {\n   int i;\n+  int flags;\n+\n+  flags = get_jump_flags (insn, JUMP_LABEL (insn));\n \n   /* We can't do anything if SEQ's delay insn isn't an\n      unconditional branch.  */\n@@ -1425,9 +1512,9 @@ steal_delay_list_from_fallthrough (insn, condition, seq,\n \t  && ((condition == const_true_rtx\n \t       || (! insn_sets_resource_p (trial, other_needed, 0)\n \t\t   && ! may_trap_p (PATTERN (trial)))))\n-\t  ? eligible_for_delay (insn, *pslots_filled, trial)\n+\t  ? eligible_for_delay (insn, *pslots_filled, trial, flags)\n \t  : (*pannul_p = 1,\n-\t     eligible_for_annul_true (insn, *pslots_filled, trial)))\n+\t     eligible_for_annul_true (insn, *pslots_filled, trial, flags)))\n \t{\n \t  delete_from_delay_slot (trial);\n \t  delay_list = add_to_delay_list (trial, delay_list);\n@@ -1464,6 +1551,9 @@ try_merge_delay_insns (insn, thread)\n   struct resources set, needed;\n   rtx merged_insns = 0;\n   int i;\n+  int flags;\n+\n+  flags = get_jump_flags (insn, JUMP_LABEL (insn));\n \n   CLEAR_RESOURCE (&needed);\n   CLEAR_RESOURCE (&set);\n@@ -1500,7 +1590,7 @@ try_merge_delay_insns (insn, thread)\n \t  && rtx_equal_p (PATTERN (next_to_match), PATTERN (trial))\n \t  /* Have to test this condition if annul condition is different\n \t     from (and less restrictive than) non-annulling one.  */\n-\t  && eligible_for_delay (delay_insn, slot_number - 1, trial))\n+\t  && eligible_for_delay (delay_insn, slot_number - 1, trial, flags))\n \t{\n \t  next_trial = next_nonnote_insn (trial);\n \n@@ -1545,7 +1635,7 @@ try_merge_delay_insns (insn, thread)\n \t      && ! sets_cc0_p (PATTERN (dtrial))\n #endif\n \t      && rtx_equal_p (PATTERN (next_to_match), PATTERN (dtrial))\n-\t      && eligible_for_delay (delay_insn, slot_number - 1, dtrial))\n+\t      && eligible_for_delay (delay_insn, slot_number - 1, dtrial, flags))\n \t    {\n \t      if (! annul_p)\n \t\t{\n@@ -2396,6 +2486,7 @@ fill_simple_delay_slots (first, non_jumps_p)\n \n   for (i = 0; i < num_unfilled_slots; i++)\n     {\n+      int flags;\n       /* Get the next insn to fill.  If it has already had any slots assigned,\n \t we can't do anything with it.  Maybe we'll improve this later.  */\n \n@@ -2407,7 +2498,8 @@ fill_simple_delay_slots (first, non_jumps_p)\n \t  || (GET_CODE (insn) == JUMP_INSN && non_jumps_p)\n \t  || (GET_CODE (insn) != JUMP_INSN && ! non_jumps_p))\n \tcontinue;\n-\n+     \n+      flags = get_jump_flags (insn, JUMP_LABEL (insn));\n       slots_to_fill = num_delay_slots (insn);\n       if (slots_to_fill == 0)\n \tabort ();\n@@ -2433,7 +2525,7 @@ fill_simple_delay_slots (first, non_jumps_p)\n \t  && (trial = next_active_insn (insn))\n \t  && GET_CODE (trial) == JUMP_INSN\n \t  && simplejump_p (trial)\n-\t  && eligible_for_delay (insn, slots_filled, trial)\n+\t  && eligible_for_delay (insn, slots_filled, trial, flags)\n \t  && no_labels_between_p (insn, trial))\n \t{\n \t  slots_filled++;\n@@ -2497,7 +2589,7 @@ fill_simple_delay_slots (first, non_jumps_p)\n \t\t{\n \t\t  trial = try_split (pat, trial, 1);\n \t\t  next_trial = prev_nonnote_insn (trial);\n-\t\t  if (eligible_for_delay (insn, slots_filled, trial))\n+\t\t  if (eligible_for_delay (insn, slots_filled, trial, flags))\n \t\t    {\n \t\t      /* In this case, we are searching backward, so if we\n \t\t\t find insns to put on the delay list, we want\n@@ -2653,7 +2745,7 @@ fill_simple_delay_slots (first, non_jumps_p)\n #endif\n \t\t  && ! (maybe_never && may_trap_p (pat))\n \t\t  && (trial = try_split (pat, trial, 0))\n-\t\t  && eligible_for_delay (insn, slots_filled, trial))\n+\t\t  && eligible_for_delay (insn, slots_filled, trial, flags))\n \t\t{\n \t\t  next_trial = next_nonnote_insn (trial);\n \t\t  delay_list = add_to_delay_list (trial, delay_list);\n@@ -2704,7 +2796,7 @@ fill_simple_delay_slots (first, non_jumps_p)\n #endif\n \t      && ! (maybe_never && may_trap_p (PATTERN (next_trial)))\n \t      && (next_trial = try_split (PATTERN (next_trial), next_trial, 0))\n-\t      && eligible_for_delay (insn, slots_filled, next_trial))\n+\t      && eligible_for_delay (insn, slots_filled, next_trial, flags))\n \t    {\n \t      rtx new_label = next_active_insn (next_trial);\n \n@@ -2839,12 +2931,15 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n   rtx trial;\n   int lose = 0;\n   int must_annul = 0;\n+  int flags;\n \n   /* Validate our arguments.  */\n   if ((condition == const_true_rtx && ! thread_if_true)\n       || (! own_thread && ! thread_if_true))\n     abort ();\n \n+  flags = get_jump_flags (insn, JUMP_LABEL (insn));\n+\n   /* If our thread is the end of subroutine, we can't get any delay\n      insns from that.  */\n   if (thread == 0)\n@@ -2930,7 +3025,7 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n \t    {\n \t      trial = try_split (pat, trial, 0);\n \t      pat = PATTERN (trial);\n-\t      if (eligible_for_delay (insn, *pslots_filled, trial))\n+\t      if (eligible_for_delay (insn, *pslots_filled, trial, flags))\n \t\tgoto winner;\n \t    }\n \t  else if (0\n@@ -2945,8 +3040,8 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n \t      trial = try_split (pat, trial, 0);\n \t      pat = PATTERN (trial);\n \t      if ((thread_if_true\n-\t\t   ? eligible_for_annul_false (insn, *pslots_filled, trial)\n-\t\t   : eligible_for_annul_true (insn, *pslots_filled, trial)))\n+\t\t   ? eligible_for_annul_false (insn, *pslots_filled, trial, flags)\n+\t\t   : eligible_for_annul_true (insn, *pslots_filled, trial, flags)))\n \t\t{\n \t\t  rtx temp;\n \n@@ -3075,7 +3170,7 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n       pat = PATTERN (trial);\n \n       if (GET_CODE (trial) != INSN || GET_CODE (pat) != SET\n-\t  || ! eligible_for_delay (insn, 0, trial))\n+\t  || ! eligible_for_delay (insn, 0, trial, flags))\n \treturn 0;\n \n       dest = SET_DEST (pat), src = SET_SRC (pat);\n@@ -3589,6 +3684,8 @@ make_return_insns (first)\n \n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     {\n+      int flags;\n+\n       /* Only look at filled JUMP_INSNs that go to the end of function\n \t label.  */\n       if (GET_CODE (insn) != INSN\n@@ -3612,6 +3709,7 @@ make_return_insns (first)\n \t It can if it has more or an equal number of slots and the contents\n \t of each is valid.  */\n \n+      flags = get_jump_flags (jump_insn, JUMP_LABEL (jump_insn));\n       slots = num_delay_slots (jump_insn);\n       if (slots >= XVECLEN (pat, 0) - 1)\n \t{\n@@ -3621,15 +3719,15 @@ make_return_insns (first)\n \t\t   (INSN_ANNULLED_BRANCH_P (jump_insn)\n \t\t    && INSN_FROM_TARGET_P (XVECEXP (pat, 0, i)))\n \t\t   ? eligible_for_annul_false (jump_insn, i - 1,\n-\t\t\t\t\t       XVECEXP (pat, 0, i)) :\n+\t\t\t\t\t       XVECEXP (pat, 0, i), flags) :\n #endif\n #ifdef ANNUL_IFTRUE_SLOTS\n \t\t   (INSN_ANNULLED_BRANCH_P (jump_insn)\n \t\t    && ! INSN_FROM_TARGET_P (XVECEXP (pat, 0, i)))\n \t\t   ? eligible_for_annul_true (jump_insn, i - 1,\n-\t\t\t\t\t      XVECEXP (pat, 0, i)) :\n+\t\t\t\t\t      XVECEXP (pat, 0, i), flags) :\n #endif\n-\t\t   eligible_for_delay (jump_insn, i -1, XVECEXP (pat, 0, i))))\n+\t\t   eligible_for_delay (jump_insn, i -1, XVECEXP (pat, 0, i), flags)))\n \t      break;\n \t}\n       else"}]}