{"sha": "12d79b13fc314b349a727b2ab15d4d06270f3496", "node_id": "C_kwDOANBUbNoAKDEyZDc5YjEzZmMzMTRiMzQ5YTcyN2IyYWIxNWQ0ZDA2MjcwZjM0OTY", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-05-31T15:06:58Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2023-06-06T23:36:56Z"}, "message": "gccrs: Respect the concrete type when resolving qualifed path types\n\nConcrete types can resolve to assoicated impl blocks which will allow us to\nresolve the path to the projection type instead of the placeholder trait\nassociated type which can change. The projection will be fixed and is\nsafer to use.\n\nFixes #2165 #2166\n\ngcc/rust/ChangeLog:\n\n\t* typecheck/rust-hir-trait-resolve.cc: when the bound is concrete keep the mapping\n\t* typecheck/rust-hir-type-check-path.cc (TypeCheckExpr::visit): add missing call\n\t* typecheck/rust-hir-type-check-type.cc (TypeCheckType::visit): make this the same as paths\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/compile/issue-2165.rs: New test.\n\t* rust/compile/issue-2166.rs: New test.\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>", "tree": {"sha": "1f7099a14c44c5047ecb9fb464f22e33c0cf68cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f7099a14c44c5047ecb9fb464f22e33c0cf68cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12d79b13fc314b349a727b2ab15d4d06270f3496", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12d79b13fc314b349a727b2ab15d4d06270f3496", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12d79b13fc314b349a727b2ab15d4d06270f3496", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12d79b13fc314b349a727b2ab15d4d06270f3496/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b322540fa0fce561cf86e371dd7f304f1343511", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b322540fa0fce561cf86e371dd7f304f1343511", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b322540fa0fce561cf86e371dd7f304f1343511"}], "stats": {"total": 150, "additions": 103, "deletions": 47}, "files": [{"sha": "77411dc63455c2b4e9446001d6251d49ba93060b", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d79b13fc314b349a727b2ab15d4d06270f3496/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d79b13fc314b349a727b2ab15d4d06270f3496/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=12d79b13fc314b349a727b2ab15d4d06270f3496", "patch": "@@ -415,7 +415,10 @@ AssociatedImplTrait::setup_associated_types (\n   // we need to figure out what Y is\n \n   TyTy::BaseType *associated_self = get_self ();\n-  rust_assert (associated_self->can_eq (self, false));\n+\n+  rust_debug (\"setup_associated_types for: %s->%s bound %s\",\n+\t      associated_self->debug_str ().c_str (),\n+\t      self->debug_str ().c_str (), bound.as_string ().c_str ());\n \n   // grab the parameters\n   HIR::ImplBlock &impl_block = *get_impl_block ();\n@@ -445,6 +448,14 @@ AssociatedImplTrait::setup_associated_types (\n \t}\n     }\n \n+  // this callback gives us the parameters that get substituted so we can\n+  // compute the constrained type parameters for this impl block\n+  std::map<std::string, HirId> param_mappings;\n+  TyTy::ParamSubstCb param_subst_cb\n+    = [&] (const TyTy::ParamType &p, const TyTy::SubstitutionArg &a) {\n+\tparam_mappings[p.get_symbol ()] = a.get_tyty ()->get_ref ();\n+      };\n+\n   // generate inference variables for these bound arguments so we can compute\n   // their values\n   Location locus;\n@@ -458,19 +469,13 @@ AssociatedImplTrait::setup_associated_types (\n \t}\n       else\n \t{\n-\t  args.push_back (\n-\t    TyTy::SubstitutionArg (&p, p.get_param_ty ()->resolve ()));\n+\t  TyTy::ParamType *param = p.get_param_ty ();\n+\t  TyTy::BaseType *resolved = param->destructure ();\n+\t  args.push_back (TyTy::SubstitutionArg (&p, resolved));\n+\t  param_mappings[param->get_symbol ()] = resolved->get_ref ();\n \t}\n     }\n \n-  // this callback gives us the parameters that get substituted so we can\n-  // compute the constrained type parameters for this impl block\n-  std::map<std::string, HirId> param_mappings;\n-  TyTy::ParamSubstCb param_subst_cb\n-    = [&] (const TyTy::ParamType &p, const TyTy::SubstitutionArg &a) {\n-\tparam_mappings[p.get_symbol ()] = a.get_tyty ()->get_ref ();\n-      };\n-\n   TyTy::SubstitutionArgumentMappings infer_arguments (std::move (args), {},\n \t\t\t\t\t\t      locus, param_subst_cb);\n   TyTy::BaseType *impl_self_infer"}, {"sha": "a62ebcb1d77a575088dfafe9becf327afb248538", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d79b13fc314b349a727b2ab15d4d06270f3496/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d79b13fc314b349a727b2ab15d4d06270f3496/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=12d79b13fc314b349a727b2ab15d4d06270f3496", "patch": "@@ -89,6 +89,8 @@ TypeCheckExpr::visit (HIR::QualifiedPathInExpression &expr)\n     = lookup_associated_impl_block (specified_bound, root);\n   if (associated_impl_trait != nullptr)\n     {\n+      associated_impl_trait->setup_associated_types (root, specified_bound);\n+\n       for (auto &i :\n \t   associated_impl_trait->get_impl_block ()->get_impl_items ())\n \t{"}, {"sha": "0cdac6e369fa817129b171dcc91e189cc9b0d38b", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "modified", "additions": 53, "deletions": 36, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d79b13fc314b349a727b2ab15d4d06270f3496/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d79b13fc314b349a727b2ab15d4d06270f3496/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=12d79b13fc314b349a727b2ab15d4d06270f3496", "patch": "@@ -178,8 +178,8 @@ TypeCheckType::visit (HIR::QualifiedPathInType &path)\n     }\n \n   // Resolve the trait now\n-  TraitReference *trait_ref\n-    = TraitResolver::Resolve (*qual_path_type.get_trait ().get ());\n+  std::unique_ptr<HIR::TypePath> &trait_path_ref = qual_path_type.get_trait ();\n+  TraitReference *trait_ref = TraitResolver::Resolve (*trait_path_ref.get ());\n   if (trait_ref->is_error ())\n     return;\n \n@@ -201,36 +201,6 @@ TypeCheckType::visit (HIR::QualifiedPathInType &path)\n   // inherit the bound\n   root->inherit_bounds ({specified_bound});\n \n-  // setup the associated types\n-  const TraitReference *specified_bound_ref = specified_bound.get ();\n-  auto candidates = TypeBoundsProbe::Probe (root);\n-  AssociatedImplTrait *associated_impl_trait = nullptr;\n-  for (auto &probed_bound : candidates)\n-    {\n-      const TraitReference *bound_trait_ref = probed_bound.first;\n-      const HIR::ImplBlock *associated_impl = probed_bound.second;\n-\n-      HirId impl_block_id = associated_impl->get_mappings ().get_hirid ();\n-      AssociatedImplTrait *associated = nullptr;\n-      bool found_impl_trait\n-\t= context->lookup_associated_trait_impl (impl_block_id, &associated);\n-      if (found_impl_trait)\n-\t{\n-\t  bool found_trait = specified_bound_ref->is_equal (*bound_trait_ref);\n-\t  bool found_self = associated->get_self ()->can_eq (root, false);\n-\t  if (found_trait && found_self)\n-\t    {\n-\t      associated_impl_trait = associated;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  if (associated_impl_trait != nullptr)\n-    {\n-      associated_impl_trait->setup_associated_types (root, specified_bound);\n-    }\n-\n   // lookup the associated item from the specified bound\n   std::unique_ptr<HIR::TypePathSegment> &item_seg\n     = path.get_associated_segment ();\n@@ -243,8 +213,57 @@ TypeCheckType::visit (HIR::QualifiedPathInType &path)\n       return;\n     }\n \n-  // infer the root type\n-  translated = item.get_tyty_for_receiver (root);\n+  // we try to look for the real impl item if possible\n+  HIR::ImplItem *impl_item = nullptr;\n+  if (root->is_concrete ())\n+    {\n+      // lookup the associated impl trait for this if we can (it might be\n+      // generic)\n+      AssociatedImplTrait *associated_impl_trait\n+\t= lookup_associated_impl_block (specified_bound, root);\n+      if (associated_impl_trait != nullptr)\n+\t{\n+\t  associated_impl_trait->setup_associated_types (root, specified_bound);\n+\n+\t  for (auto &i :\n+\t       associated_impl_trait->get_impl_block ()->get_impl_items ())\n+\t    {\n+\t      bool found = i->get_impl_item_name ().compare (\n+\t\t\t     item_seg_identifier.as_string ())\n+\t\t\t   == 0;\n+\t      if (found)\n+\t\t{\n+\t\t  impl_item = i.get ();\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  NodeId root_resolved_node_id = UNKNOWN_NODEID;\n+  if (impl_item == nullptr)\n+    {\n+      // this may be valid as there could be a default trait implementation here\n+      // and we dont need to worry if the trait item is actually implemented or\n+      // not because this will have already been validated as part of the trait\n+      // impl block\n+      translated = item.get_tyty_for_receiver (root);\n+      root_resolved_node_id\n+\t= item.get_raw_item ()->get_mappings ().get_nodeid ();\n+    }\n+  else\n+    {\n+      HirId impl_item_id = impl_item->get_impl_mappings ().get_hirid ();\n+      bool ok = query_type (impl_item_id, &translated);\n+      if (!ok)\n+\t{\n+\t  // FIXME\n+\t  // I think query_type should error if required here anyway\n+\t  return;\n+\t}\n+\n+      root_resolved_node_id = impl_item->get_impl_mappings ().get_nodeid ();\n+    }\n \n   // turbo-fish segment path::<ty>\n   if (item_seg->get_type () == HIR::TypePathSegment::SegmentType::GENERIC)\n@@ -270,8 +289,6 @@ TypeCheckType::visit (HIR::QualifiedPathInType &path)\n     }\n \n   // continue on as a path-in-expression\n-  const TraitItemReference *trait_item_ref = item.get_raw_item ();\n-  NodeId root_resolved_node_id = trait_item_ref->get_mappings ().get_nodeid ();\n   bool fully_resolved = path.get_segments ().empty ();\n   if (fully_resolved)\n     {"}, {"sha": "199bc13aa68682398649037282584faf71cc8709", "filename": "gcc/testsuite/rust/compile/issue-2165.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d79b13fc314b349a727b2ab15d4d06270f3496/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2165.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d79b13fc314b349a727b2ab15d4d06270f3496/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2165.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2165.rs?ref=12d79b13fc314b349a727b2ab15d4d06270f3496", "patch": "@@ -0,0 +1,9 @@\n+pub trait Alpha<T = Self> {\n+    type Beta;\n+}\n+\n+impl Alpha for u32 {\n+    type Beta = u32;\n+}\n+\n+type Delta = <u32 as Alpha<u32>>::Beta;"}, {"sha": "f333888879a41d1f574c2e94ee3e27bf4a992fc8", "filename": "gcc/testsuite/rust/compile/issue-2166.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d79b13fc314b349a727b2ab15d4d06270f3496/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2166.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d79b13fc314b349a727b2ab15d4d06270f3496/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2166.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2166.rs?ref=12d79b13fc314b349a727b2ab15d4d06270f3496", "patch": "@@ -0,0 +1,23 @@\n+trait Add {\n+    type Output;\n+\n+    fn add(self) -> u32;\n+}\n+\n+impl Add for u32 {\n+    type Output = u32;\n+\n+    fn add(self) -> u32 {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        0\n+    }\n+}\n+\n+impl<'a> Add for &'a u32 {\n+    type Output = u32;\n+\n+    fn add(self) -> <u32 as Add>::Output {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        0\n+    }\n+}"}]}