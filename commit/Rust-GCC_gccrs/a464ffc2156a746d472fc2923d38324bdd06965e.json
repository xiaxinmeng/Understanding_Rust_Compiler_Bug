{"sha": "a464ffc2156a746d472fc2923d38324bdd06965e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQ2NGZmYzIxNTZhNzQ2ZDQ3MmZjMjkyM2QzODMyNGJkZDA2OTY1ZQ==", "commit": {"author": {"name": "Mihail Ionescu", "email": "mihail.ionescu@arm.com", "date": "2020-01-15T11:45:53Z"}, "committer": {"name": "Mihail Ionescu", "email": "mihail.ionescu@arm.com", "date": "2020-01-16T15:12:08Z"}, "message": "[PATCH, GCC/ARM, 9/10] Call nscall function with blxns\n\nThis change to use BLXNS to call a nonsecure function from secure\ndirectly (not using a libcall) is made in 2 steps:\n- change nonsecure_call patterns to use blxns instead of calling\n  __gnu_cmse_nonsecure_call\n- loosen requirement for function address to allow any register when\n  doing BLXNS.\n\nThe former is a straightforward check over whether instructions added in\nArmv8.1-M Mainline are available while the latter consist in making the\nnonsecure call pattern accept any register by using match_operand and\nchanging the nonsecure_call_internal expander to no force r4 when\ntargeting Armv8.1-M Mainline.\n\nThe tricky bit is actually in the test update, specifically how to check\nthat register lists for CLRM have all registers except for the one\nholding parameters (already done) and the one holding the address used\nby BLXNS. This is achieved with 3 scan-assembler directives.\n\n1) The first one lists all registers that can appear in CLRM but make\n   each of them optional.\n   Property guaranteed: no wrong register is cleared and none appears\n   twice in the register list.\n2) The second directive check that the CLRM is made of a fixed number\n   of the right registers to be cleared. The number used is the number\n   of registers that could contain a secret minus one (used to hold the\n   address of the function to call.\n   Property guaranteed: register list has the right number of registers\n   Cumulated property guaranteed: only registers with a potential secret\n   are cleared and they are all listed but ont\n3) The last directive checks that we cannot find a CLRM with a register\n   in it that also appears in BLXNS. This is check via the use of a\n   back-reference on any of the allowed register in CLRM, the\n   back-reference enforcing that whatever register match in CLRM must be\n   the same in the BLXNS.\n   Property guaranteed: register used for BLXNS is different from\n   registers cleared in CLRM.\n\nSome more care needs to happen for the gcc.target/arm/cmse/cmse-1.c\ntestcase due to there being two CLRM generated. To ensure the third\ndirective match the right CLRM to the BLXNS, a negative lookahead is\nused between the CLRM register list and the BLXNS. The way negative\nlookahead work is by matching the *position* where a given regular\nexpression does not match. In this case, since it comes after the CLRM\nregister list it is requesting that what comes after the register list\ndoes not have a CLRM again followed by BLXNS. This guarantees that the\n.*blxns after only matches a blxns without another CLRM before.\n\n*** gcc/ChangeLog ***\n\n2020-01-16  Mihail-Calin Ionescu  <mihail.ionescu@arm.com>\n2020-01-16  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n\t* config/arm/arm.md (nonsecure_call_internal): Do not force memory\n\taddress in r4 when targeting Armv8.1-M Mainline.\n\t(nonsecure_call_value_internal): Likewise.\n\t* config/arm/thumb2.md (nonsecure_call_reg_thumb2): Make memory address\n\ta register match_operand again.  Emit BLXNS when targeting\n\tArmv8.1-M Mainline.\n\t(nonsecure_call_value_reg_thumb2): Likewise.\n\n*** gcc/testsuite/ChangeLog ***\n\n2020-01-16  Mihail-Calin Ionescu  <mihail.ionescu@arm.com>\n2020-01-16  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n\t* gcc.target/arm/cmse/cmse-1.c: Add check for BLXNS when instructions\n\tintroduced in Armv8.1-M Mainline Security Extensions are available and\n\trestrict checks for libcall to __gnu_cmse_nonsecure_call to Armv8-M\n\ttargets only.  Adapt CLRM check to verify register used for BLXNS is\n\tnot in the CLRM register list.\n\t* gcc.target/arm/cmse/cmse-14.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/bitfield-4.c: Likewise and adapt\n\tcheck for LSB clearing bit to be using the same register as BLXNS when\n\ttargeting Armv8.1-M Mainline.\n\t* gcc.target/arm/cmse/mainline/8_1m/bitfield-5.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/bitfield-6.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/bitfield-7.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/bitfield-8.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/bitfield-9.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/bitfield-and-union.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/hard-sp/cmse-13.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/hard-sp/cmse-7.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/hard-sp/cmse-8.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/hard/cmse-13.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/hard/cmse-7.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/hard/cmse-8.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/soft/cmse-13.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/soft/cmse-7.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/soft/cmse-8.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/softfp-sp/cmse-7.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/softfp-sp/cmse-8.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-13.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-7.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-8.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/union-1.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/union-2.c: Likewise.\n\t* gcc.target/arm/cmse/cmse-15.c: Count BLXNS when targeting Armv8.1-M\n\tMainline and restrict libcall count to Armv8-M.", "tree": {"sha": "c3bbeae3575659bf0b00af642b2832346a5b953f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3bbeae3575659bf0b00af642b2832346a5b953f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a464ffc2156a746d472fc2923d38324bdd06965e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a464ffc2156a746d472fc2923d38324bdd06965e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a464ffc2156a746d472fc2923d38324bdd06965e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a464ffc2156a746d472fc2923d38324bdd06965e/comments", "author": null, "committer": null, "parents": [{"sha": "0ab81d9cc73303c376a0014774ab6058d40a25a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ab81d9cc73303c376a0014774ab6058d40a25a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ab81d9cc73303c376a0014774ab6058d40a25a0"}], "stats": {"total": 469, "additions": 357, "deletions": 112}, "files": [{"sha": "123a9c39c9a59199d085c56d89b912643e9ba919", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -1,6 +1,17 @@\n 2020-01-16  Mihail-Calin Ionescu <mihail.ionescu@arm.com>\n 2020-01-16  Thomas Preud'homme <thomas.preudhomme@arm.com>\n \n+\t* config/arm/arm.md (nonsecure_call_internal): Do not force memory\n+\taddress in r4 when targeting Armv8.1-M Mainline.\n+\t(nonsecure_call_value_internal): Likewise.\n+\t* config/arm/thumb2.md (nonsecure_call_reg_thumb2): Make memory address\n+\ta register match_operand again.  Emit BLXNS when targeting\n+\tArmv8.1-M Mainline.\n+\t(nonsecure_call_value_reg_thumb2): Likewise.\n+\n+2020-01-16  Mihail-Calin Ionescu  <mihail.ionescu@arm.com>\n+2020-01-16  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n \t* config/arm/arm.c (arm_add_cfa_adjust_cfa_note): Declare early.\n \t(cmse_nonsecure_call_inline_register_clear): Define new lazy_fpclear\n \tvariable as true when floating-point ABI is not hard.  Replace"}, {"sha": "6ec6f718deaafd25d6b45e02a264c70197f5db31", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -8387,12 +8387,15 @@\n   \"use_cmse\"\n   \"\n   {\n-    rtx tmp;\n-    tmp = copy_to_suggested_reg (XEXP (operands[0], 0),\n+    if (!TARGET_HAVE_FPCXT_CMSE)\n+      {\n+\trtx tmp =\n+\t  copy_to_suggested_reg (XEXP (operands[0], 0),\n \t\t\t\t gen_rtx_REG (SImode, R4_REGNUM),\n \t\t\t\t SImode);\n \n-    operands[0] = replace_equiv_address (operands[0], tmp);\n+\toperands[0] = replace_equiv_address (operands[0], tmp);\n+      }\n   }\")\n \n (define_insn \"*call_reg_armv5\"\n@@ -8495,12 +8498,15 @@\n   \"use_cmse\"\n   \"\n   {\n-    rtx tmp;\n-    tmp = copy_to_suggested_reg (XEXP (operands[1], 0),\n+    if (!TARGET_HAVE_FPCXT_CMSE)\n+      {\n+\trtx tmp =\n+\t  copy_to_suggested_reg (XEXP (operands[1], 0),\n \t\t\t\t gen_rtx_REG (SImode, R4_REGNUM),\n \t\t\t\t SImode);\n \n-    operands[1] = replace_equiv_address (operands[1], tmp);\n+\toperands[1] = replace_equiv_address (operands[1], tmp);\n+      }\n   }\")\n \n (define_insn \"*call_value_reg_armv5\""}, {"sha": "3ca491126355c79e22c4924a489dfd407ee6d27a", "filename": "gcc/config/arm/thumb2.md", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Fconfig%2Farm%2Fthumb2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Fconfig%2Farm%2Fthumb2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb2.md?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -537,13 +537,18 @@\n )\n \n (define_insn \"*nonsecure_call_reg_thumb2\"\n-  [(call (unspec:SI [(mem:SI (reg:SI R4_REGNUM))]\n+  [(call (unspec:SI [(mem:SI (match_operand:SI 0 \"s_register_operand\" \"l*r\"))]\n \t\t    UNSPEC_NONSECURE_MEM)\n-\t (match_operand 0 \"\" \"\"))\n-   (use (match_operand 1 \"\" \"\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (use (match_operand 2 \"\" \"\"))\n    (clobber (reg:SI LR_REGNUM))]\n   \"TARGET_THUMB2 && use_cmse\"\n-  \"bl\\\\t__gnu_cmse_nonsecure_call\"\n+  {\n+    if (TARGET_HAVE_FPCXT_CMSE)\n+      return \"blxns\\\\t%0\";\n+    else\n+      return \"bl\\\\t__gnu_cmse_nonsecure_call\";\n+  }\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"call\")]\n )\n@@ -562,13 +567,18 @@\n (define_insn \"*nonsecure_call_value_reg_thumb2\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call\n-\t (unspec:SI [(mem:SI (reg:SI R4_REGNUM))]\n+\t (unspec:SI [(mem:SI (match_operand:SI 1 \"register_operand\" \"l*r\"))]\n \t\t    UNSPEC_NONSECURE_MEM)\n-\t (match_operand 1 \"\" \"\")))\n-   (use (match_operand 2 \"\" \"\"))\n+\t (match_operand 2 \"\" \"\")))\n+   (use (match_operand 3 \"\" \"\"))\n    (clobber (reg:SI LR_REGNUM))]\n   \"TARGET_THUMB2 && use_cmse\"\n-  \"bl\\t__gnu_cmse_nonsecure_call\"\n+  {\n+    if (TARGET_HAVE_FPCXT_CMSE)\n+      return \"blxns\\\\t%1\";\n+    else\n+      return \"bl\\\\t__gnu_cmse_nonsecure_call\";\n+  }\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"call\")]\n )"}, {"sha": "1cfe47d2bb712938f06e40323137105c9c1a5572", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -1,6 +1,43 @@\n 2020-01-16  Mihail-Calin Ionescu <mihail.ionescu@arm.com>\n 2020-01-16  Thomas Preud'homme <thomas.preudhomme@arm.com>\n \n+\t* gcc.target/arm/cmse/cmse-1.c: Add check for BLXNS when instructions\n+\tintroduced in Armv8.1-M Mainline Security Extensions are available and\n+\trestrict checks for libcall to __gnu_cmse_nonsecure_call to Armv8-M\n+\ttargets only.  Adapt CLRM check to verify register used for BLXNS is\n+\tnot in the CLRM register list.\n+\t* gcc.target/arm/cmse/cmse-14.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/bitfield-4.c: Likewise and adapt\n+\tcheck for LSB clearing bit to be using the same register as BLXNS when\n+\ttargeting Armv8.1-M Mainline.\n+\t* gcc.target/arm/cmse/mainline/8_1m/bitfield-5.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/bitfield-6.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/bitfield-7.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/bitfield-8.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/bitfield-9.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/bitfield-and-union.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/hard-sp/cmse-13.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/hard-sp/cmse-7.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/hard-sp/cmse-8.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/hard/cmse-13.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/hard/cmse-7.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/hard/cmse-8.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/soft/cmse-13.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/soft/cmse-7.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/soft/cmse-8.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/softfp-sp/cmse-7.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/softfp-sp/cmse-8.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-13.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-7.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-8.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/union-1.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/union-2.c: Likewise.\n+\t* gcc.target/arm/cmse/cmse-15.c: Count BLXNS when targeting Armv8.1-M\n+\tMainline and restrict libcall count to Armv8-M.\n+\n+2020-01-16  Mihail-Calin Ionescu  <mihail.ionescu@arm.com>\n+2020-01-16  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n \t* gcc.target/arm/cmse/mainline/8_1m/soft/cmse-13.c: Add check for VLSTM and\n \tVLLDM.\n \t* gcc.target/arm/cmse/mainline/8_1m/soft/cmse-7.c: Likewise."}, {"sha": "ddfcfacab5f601a729319a9d2dab03e61ee56bca", "filename": "gcc/testsuite/gcc.target/arm/cmse/cmse-1.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse-1.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -110,7 +110,13 @@ qux (int_nsfunc_t * callback)\n /* { dg-final { scan-assembler \"vldr\\tFPCXTNS, \\\\\\[sp\\\\\\], #4\" { target arm_cmse_clear_ok } } } */\n /* { dg-final { scan-assembler \"msr\\tAPSR_nzcvq\" { target { ! arm_cmse_clear_ok } } } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" { target arm_cmse_clear_ok } } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r0, r1, r2, r3, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" { target arm_cmse_clear_ok } } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r0, )?(r1, )?(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" { target arm_cmse_clear_ok } } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[0-9\\]|r10|fp|ip), ){12}APSR\\}\" { target arm_cmse_clear_ok } } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[0-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}(?!.*clrm.*blxns).*blxns\\t\\\\1\" { target arm_cmse_clear_ok } } } */\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" { target arm_cmse_clear_ok } } } */\n \n int call_callback (void)\n@@ -120,4 +126,5 @@ int call_callback (void)\n   else\n     return default_callback ();\n }\n-/* { dg-final { scan-assembler-times \"bl\\\\s+__gnu_cmse_nonsecure_call\" 1 } } */\n+/* { dg-final { scan-assembler-times \"bl\\\\s+__gnu_cmse_nonsecure_call\" 1 { target { ! arm_cmse_clear_ok } } } } */\n+/* { dg-final { scan-assembler \"blxns\" { target arm_cmse_clear_ok } } } */"}, {"sha": "5ab97856066e14c0005b56210e62f2b7a59fd911", "filename": "gcc/testsuite/gcc.target/arm/cmse/cmse-14.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse-14.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -10,7 +10,15 @@ int foo (void)\n }\n \n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" { target arm_cmse_clear_ok } } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r0, r1, r2, r3, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" { target arm_cmse_clear_ok } } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r0, )?(r1, )?(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" { target arm_cmse_clear_ok } } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[0-9\\]|r10|fp|ip), ){12}APSR\\}\" { target arm_cmse_clear_ok } } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[0-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" { target arm_cmse_clear_ok } } } */\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" { target arm_cmse_clear_ok } } } */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n-/* { dg-final { scan-assembler-not \"^(.*\\\\s)?bl?\\[^\\\\s]*\\\\s+bar\" } } */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" { target { ! arm_cmse_clear_ok } } } } */\n+/* { dg-final { scan-assembler-not \"^(.*\\\\s)?bl?\\[^\\\\s]*\\\\s+bar\" { target { ! arm_cmse_clear_ok } } } } */\n+/* { dg-final { scan-assembler \"blxns\" { target arm_cmse_clear_ok } } } */\n+/* { dg-final { scan-assembler-not \"^(.*\\\\s)?bl?(?!xns)\\[^\\\\s]*\\\\s+bar\" { target arm_cmse_clear_ok } } } */"}, {"sha": "0e37b50e004d74dc81f5a8bdc0c9ba21ceaca67d", "filename": "gcc/testsuite/gcc.target/arm/cmse/cmse-15.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse-15.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -69,4 +69,9 @@ int secure5 (void)\n {\n   return (*s_bar2) ();\n }\n-/* { dg-final { scan-assembler-times \"bl\\\\s+__gnu_cmse_nonsecure_call\" 6 } } */\n+\n+/* ARMv8-M expectation.  */\n+/* { dg-final { scan-assembler-times \"bl\\\\s+__gnu_cmse_nonsecure_call\" 6 { target { ! arm_cmse_clear_ok } } } } */\n+\n+/* ARMv8.1-M expectation.  */\n+/* { dg-final { scan-assembler-times \"blxns\" 6 { target arm_cmse_clear_ok } } } */"}, {"sha": "ff34edb21c36c9f114aa934fa86ea962d932f273", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/bitfield-4.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fbitfield-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fbitfield-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fbitfield-4.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -10,9 +10,16 @@\n /* { dg-final { scan-assembler \"and\\tr1, r1, ip\" } } */\n /* { dg-final { scan-assembler \"mov\\tip, #3\" } } */\n /* { dg-final { scan-assembler \"and\\tr2, r2, ip\" } } */\n-/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n-/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[3-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[3-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r3, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[3-9\\]|r10|fp|ip), ){9}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[3-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "4d1407aba4418006463fdca59cbe90e768e78391", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/bitfield-5.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fbitfield-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fbitfield-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fbitfield-5.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -8,9 +8,16 @@\n /* { dg-final { scan-assembler \"and\\tr0, r0, ip\" } } */\n /* { dg-final { scan-assembler \"movw\\tip, #2047\" } } */\n /* { dg-final { scan-assembler \"and\\tr1, r1, ip\" } } */\n-/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n-/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[2-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[2-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r2, r3, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[2-9\\]|r10|fp|ip), ){10}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[2-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "9b1227adfdc03457266573447c7996245a114110", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/bitfield-6.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fbitfield-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fbitfield-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fbitfield-6.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -11,9 +11,16 @@\n /* { dg-final { scan-assembler \"and\\tr1, r1, ip\" } } */\n /* { dg-final { scan-assembler \"mov\\tip, #255\" } } */\n /* { dg-final { scan-assembler \"and\\tr2, r2, ip\" } } */\n-/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n-/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[3-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[3-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r3, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[3-9\\]|r10|fp|ip), ){9}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[3-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "aec958fc9b9d125c54022911ee34affa9dd81797", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/bitfield-7.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fbitfield-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fbitfield-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fbitfield-7.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -8,9 +8,16 @@\n /* { dg-final { scan-assembler \"and\\tr0, r0, ip\" } } */\n /* { dg-final { scan-assembler \"movw\\tip, #2047\" } } */\n /* { dg-final { scan-assembler \"and\\tr1, r1, ip\" } } */\n-/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n-/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[2-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[2-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r2, r3, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[2-9\\]|r10|fp|ip), ){10}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[2-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "ae039e292d55423b1dc1b19551278418224bbe5e", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/bitfield-8.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fbitfield-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fbitfield-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fbitfield-8.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -11,9 +11,16 @@\n /* { dg-final { scan-assembler \"movw\\tip, #65535\" } } */\n /* { dg-final { scan-assembler \"movt\\tip, 31\" } } */\n /* { dg-final { scan-assembler \"and\\tr2, r2, ip\" } } */\n-/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n-/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[3-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[3-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r3, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[3-9\\]|r10|fp|ip), ){9}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[3-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "f455f8cf19b1d8f32bd6ca208d33c144da644c29", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/bitfield-9.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fbitfield-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fbitfield-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fbitfield-9.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -5,9 +5,16 @@\n \n /* { dg-final { scan-assembler \"movw\\tip, #1799\" } } */\n /* { dg-final { scan-assembler \"and\\tr0, r0, ip\" } } */\n-/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n-/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[1-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[1-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r1, r2, r3, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r1, )?(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[1-9\\]|r10|fp|ip), ){11}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[1-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "3e76364c40452a7946e3b97e2321fd6e6d204355", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/bitfield-and-union.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fbitfield-and-union.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fbitfield-and-union.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fbitfield-and-union.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -15,9 +15,16 @@\n /* { dg-final { scan-assembler \"movw\\tip, #65535\" } } */\n /* { dg-final { scan-assembler \"movt\\tip, 31\" } } */\n /* { dg-final { scan-assembler \"and\\tr3, r3, ip\" } } */\n-/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n-/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[4-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[4-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[4-9\\]|r10|fp|ip), ){8}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[4-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "0c49277389271321c7fd7faa6ae6aaee2c299def", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/hard-sp/cmse-13.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard-sp%2Fcmse-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard-sp%2Fcmse-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard-sp%2Fcmse-13.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -6,11 +6,18 @@\n #include \"../../../cmse-13.x\"\n \n /* Checks for saving and clearing prior to function call.  */\n-/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n-/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n /* { dg-final { scan-assembler \"vpush.64\\t\\{d8, d9, d10, d11, d12, d13, d14, d15\\}\" } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r0, r1, r2, r3, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r0, )?(r1, )?(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[0-9\\]|r10|fp|ip), ){12}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[0-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler-not \"vmov\\.f32\\ts0, #1\\.0\" } } */\n /* { dg-final { scan-assembler-not \"vmov\\.f32\\ts2, #1\\.0\" } } */\n /* { dg-final { scan-assembler-not \"vmov\\.f32\\ts3, #1\\.0\" } } */\n@@ -20,4 +27,4 @@\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "3c66b0a8c6f1c7be6c8cf77b2c71916a08c7b357", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/hard-sp/cmse-7.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard-sp%2Fcmse-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard-sp%2Fcmse-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard-sp%2Fcmse-7.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -6,14 +6,21 @@\n #include \"../../../cmse-7.x\"\n \n /* Checks for saving and clearing prior to function call.  */\n-/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n-/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n /* { dg-final { scan-assembler \"vpush.64\\t\\{d8, d9, d10, d11, d12, d13, d14, d15\\}\" } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r0, r1, r2, r3, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r0, )?(r1, )?(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[0-9\\]|r10|fp|ip), ){12}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[0-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"vscclrm\\t\\{s0-s31, VPR\\}\" } } */\n /* { dg-final { scan-assembler \"vldm\\tsp!, \\{d8-d15\\}\" } } */\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "7d456c39705b15fa5b55270ac6b4ed57f5c7e465", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/hard-sp/cmse-8.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard-sp%2Fcmse-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard-sp%2Fcmse-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard-sp%2Fcmse-8.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -6,16 +6,23 @@\n #include \"../../../cmse-8.x\"\n \n /* Checks for saving and clearing prior to function call.  */\n-/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n-/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n /* { dg-final { scan-assembler \"vpush.64\\t\\{d8, d9, d10, d11, d12, d13, d14, d15\\}\" } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r0, r1, r2, r3, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r0, )?(r1, )?(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[0-9\\]|r10|fp|ip), ){12}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[0-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler-not \"vmov\\.f32\\ts0, #1\\.0\" } } */\n /* { dg-final { scan-assembler-not \"vmov\\.f32\\ts1, #1\\.0\" } } */\n /* { dg-final { scan-assembler \"vscclrm\\t\\{s2-s31, VPR\\}\" } } */\n /* { dg-final { scan-assembler \"vldm\\tsp!, \\{d8-d15\\}\" } } */\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "ab95c83a1167aff9fd4c0e24fe5580895cfbf0bb", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/hard/cmse-13.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard%2Fcmse-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard%2Fcmse-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard%2Fcmse-13.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -6,11 +6,18 @@\n #include \"../../../cmse-13.x\"\n \n /* Checks for saving and clearing prior to function call.  */\n-/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n-/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n /* { dg-final { scan-assembler \"vpush.64\\t\\{d8, d9, d10, d11, d12, d13, d14, d15\\}\" } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r0, r1, r2, r3, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r0, )?(r1, )?(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[0-9\\]|r10|fp|ip), ){12}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[0-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler-not \"vmov\\.f32\\ts0, #1\\.0\" } } */\n /* { dg-final { scan-assembler-not \"vmov\\.f64\\td0, #1\\.0\" } } */\n /* { dg-final { scan-assembler-not \"vmov\\.f64\\td1, #1\\.0\" } } */\n@@ -22,4 +29,4 @@\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "cf58d547972e21e0816a1bdf74968d0b50d2bd08", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/hard/cmse-7.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard%2Fcmse-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard%2Fcmse-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard%2Fcmse-7.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -6,14 +6,21 @@\n #include \"../../../cmse-7.x\"\n \n /* Checks for saving and clearing prior to function call.  */\n-/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n-/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n /* { dg-final { scan-assembler \"vpush.64\\t\\{d8, d9, d10, d11, d12, d13, d14, d15\\}\" } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r0, r1, r2, r3, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r0, )?(r1, )?(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[0-9\\]|r10|fp|ip), ){12}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[0-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"vscclrm\\t\\{s0-s31, VPR\\}\" } } */\n /* { dg-final { scan-assembler \"vldm\\tsp!, \\{d8-d15\\}\" } } */\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "1854d03d0814c90f8014a28fb1c81c6866f0071d", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/hard/cmse-8.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard%2Fcmse-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard%2Fcmse-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard%2Fcmse-8.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -6,15 +6,22 @@\n #include \"../../../cmse-8.x\"\n \n /* Checks for saving and clearing prior to function call.  */\n-/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n-/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n /* { dg-final { scan-assembler \"vpush.64\\t\\{d8, d9, d10, d11, d12, d13, d14, d15\\}\" } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r0, r1, r2, r3, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r0, )?(r1, )?(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[0-9\\]|r10|fp|ip), ){12}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[0-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler-not \"vmov\\.f64\\td0, #1\\.0\" } } */\n /* { dg-final { scan-assembler \"vscclrm\\t\\{s2-s31, VPR\\}\" } } */\n /* { dg-final { scan-assembler \"vldm\\tsp!, \\{d8-d15\\}\" } } */\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "1b207c394081e6ec9bf569961a4a059d5b47fe20", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/soft/cmse-13.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoft%2Fcmse-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoft%2Fcmse-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoft%2Fcmse-13.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -5,18 +5,25 @@\n #include \"../../../cmse-13.x\"\n \n /* Checks for saving and clearing prior to function call.  */\n-/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n-/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[1,4-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[1,4-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler-not \"mov\\tr0, r4\" } } */\n /* { dg-final { scan-assembler-not \"mov\\tr2, r4\" } } */\n /* { dg-final { scan-assembler-not \"mov\\tr3, r4\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n /* { dg-final { scan-assembler \"vlstm\\tsp\" } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r1, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r1, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[1,4-9\\]|r10|fp|ip), ){9}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[1,4-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"vlldm\\tsp\" } } */\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n /* { dg-final { scan-assembler-not \"vmov\" } } */\n /* { dg-final { scan-assembler-not \"vmsr\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "3ec639480868944ed29065936c1fab10aa9e0fed", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/soft/cmse-7.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoft%2Fcmse-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoft%2Fcmse-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoft%2Fcmse-7.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -5,15 +5,22 @@\n #include \"../../../cmse-7.x\"\n \n /* Checks for saving and clearing prior to function call.  */\n-/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n-/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n /* { dg-final { scan-assembler \"vlstm\\tsp\" } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r0, r1, r2, r3, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r0, )?(r1, )?(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[0-9\\]|r10|fp|ip), ){12}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[0-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"vlldm\\tsp\" } } */\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n /* { dg-final { scan-assembler-not \"vmov\" } } */\n /* { dg-final { scan-assembler-not \"vmsr\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "5c1d245d4aa966812e52f327c7ceba5dabba2e18", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/soft/cmse-8.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoft%2Fcmse-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoft%2Fcmse-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoft%2Fcmse-8.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -5,17 +5,24 @@\n #include \"../../../cmse-8.x\"\n \n /* Checks for saving and clearing prior to function call.  */\n-/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n-/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[2-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[2-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler-not \"mov\\tr0, r4\" } } */\n /* { dg-final { scan-assembler-not \"mov\\tr1, r4\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n /* { dg-final { scan-assembler \"vlstm\\tsp\" } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r2, r3, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[2-9\\]|r10|fp|ip), ){10}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[2-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"vlldm\\tsp\" } } */\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n /* { dg-final { scan-assembler-not \"vmov\" } } */\n /* { dg-final { scan-assembler-not \"vmsr\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "3228692c2686fcae8e1369f984aaa6c375ad6418", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp-sp/cmse-7.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp-sp%2Fcmse-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp-sp%2Fcmse-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp-sp%2Fcmse-7.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -6,13 +6,20 @@\n #include \"../../../cmse-7.x\"\n \n /* Checks for saving and clearing prior to function call.  */\n-/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n-/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n /* { dg-final { scan-assembler \"vlstm\\tsp\" } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r0, r1, r2, r3, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r0, )?(r1, )?(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[0-9\\]|r10|fp|ip), ){12}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[0-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"vlldm\\tsp\" } } */\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "1c60d97dabd99136533a61fef5ae099eae4bbc93", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp-sp/cmse-8.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp-sp%2Fcmse-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp-sp%2Fcmse-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp-sp%2Fcmse-8.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -6,15 +6,22 @@\n #include \"../../../cmse-8.x\"\n \n /* Checks for saving and clearing prior to function call.  */\n-/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n-/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[2-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[2-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler-not \"mov\\tr0, r4\" } } */\n /* { dg-final { scan-assembler-not \"mov\\tr1, r4\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n /* { dg-final { scan-assembler \"vlstm\\tsp\" } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r2, r3, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[2-9\\]|r10|fp|ip), ){10}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[2-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"vlldm\\tsp\" } } */\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "c366f6ae4ccc65d943dbbf045925ca9c6e8921ca", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-13.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp%2Fcmse-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp%2Fcmse-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp%2Fcmse-13.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -6,16 +6,23 @@\n #include \"../../../cmse-13.x\"\n \n /* Checks for saving and clearing prior to function call.  */\n-/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n-/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[1,4-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[1,4-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler-not \"mov\\tr0, r4\" } } */\n /* { dg-final { scan-assembler-not \"mov\\tr2, r4\" } } */\n /* { dg-final { scan-assembler-not \"mov\\tr3, r4\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n /* { dg-final { scan-assembler \"vlstm\\tsp\" } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r1, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r1, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[1,4-9\\]|r10|fp|ip), ){9}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[1,4-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"vlldm\\tsp\" } } */\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "186a4480f4e816bdb2413ecbc690470e1c2480e6", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-7.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp%2Fcmse-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp%2Fcmse-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp%2Fcmse-7.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -6,13 +6,20 @@\n #include \"../../../cmse-7.x\"\n \n /* Checks for saving and clearing prior to function call.  */\n-/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n-/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n /* { dg-final { scan-assembler \"vlstm\\tsp\" } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r0, r1, r2, r3, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r0, )?(r1, )?(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[0-9\\]|r10|fp|ip), ){12}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[0-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"vlldm\\tsp\" } } */\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "f0f74f06bbd1eed2f71b46bc8947c99ce1de0765", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-8.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp%2Fcmse-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp%2Fcmse-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp%2Fcmse-8.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -6,15 +6,22 @@\n #include \"../../../cmse-8.x\"\n \n /* Checks for saving and clearing prior to function call.  */\n-/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n-/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[2-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[2-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler-not \"mov\\tr0, r4\" } } */\n /* { dg-final { scan-assembler-not \"mov\\tr1, r4\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n /* { dg-final { scan-assembler \"vlstm\\tsp\" } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r2, r3, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[2-9\\]|r10|fp|ip), ){10}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[2-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"vlldm\\tsp\" } } */\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "4d58eed1ac21e32dfa893397736be45129af53b8", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/union-1.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Funion-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Funion-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Funion-1.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -8,9 +8,16 @@\n /* { dg-final { scan-assembler \"and\\tr0, r0, ip\" } } */\n /* { dg-final { scan-assembler \"movw\\tip, #511\" } } */\n /* { dg-final { scan-assembler \"and\\tr1, r1, ip\" } } */\n-/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n-/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[2-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[2-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r2, r3, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[2-9\\]|r10|fp|ip), ){10}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[2-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "95de458b50172f6e84ffc2625fc35eca8f65108a", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/union-2.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Funion-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a464ffc2156a746d472fc2923d38324bdd06965e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Funion-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Funion-2.c?ref=a464ffc2156a746d472fc2923d38324bdd06965e", "patch": "@@ -12,9 +12,16 @@\n /* { dg-final { scan-assembler \"movw\\tip, #65535\" } } */\n /* { dg-final { scan-assembler \"movt\\tip, 31\" } } */\n /* { dg-final { scan-assembler \"and\\tr2, r2, ip\" } } */\n-/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n-/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[3-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[3-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n-/* { dg-final { scan-assembler \"clrm\\t\\{r3, r5, r6, r7, r8, r9, r10, fp, ip, APSR\\}\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[3-9\\]|r10|fp|ip), ){9}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[3-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n /* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n-/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}]}