{"sha": "620e594be58d2f933902a6619fd20aa618070b4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjIwZTU5NGJlNThkMmY5MzM5MDJhNjYxOWZkMjBhYTYxODA3MGI0Yg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-11-13T20:05:03Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-11-13T20:05:03Z"}, "message": "Eliminate source_location in favor of location_t\n\nHistorically GCC used location_t, while libcpp used source_location.\n\nThis inconsistency has been annoying me for a while, so this patch\nremoves source_location in favor of location_t throughout\n(as the latter is shorter).\n\ngcc/ChangeLog:\n\t* builtins.c: Replace \"source_location\" with \"location_t\".\n\t* diagnostic-show-locus.c: Likewise.\n\t* diagnostic.c: Likewise.\n\t* dumpfile.c: Likewise.\n\t* gcc-rich-location.h: Likewise.\n\t* genmatch.c: Likewise.\n\t* gimple.h: Likewise.\n\t* gimplify.c: Likewise.\n\t* input.c: Likewise.\n\t* input.h: Likewise.  Eliminate the typedef.\n\t* omp-expand.c: Likewise.\n\t* selftest.h: Likewise.\n\t* substring-locations.h (get_source_location_for_substring):\n\tRename to..\n\t(get_location_within_string): ...this.\n\t* tree-cfg.c: Replace \"source_location\" with \"location_t\".\n\t* tree-cfgcleanup.c: Likewise.\n\t* tree-diagnostic.c: Likewise.\n\t* tree-into-ssa.c: Likewise.\n\t* tree-outof-ssa.c: Likewise.\n\t* tree-parloops.c: Likewise.\n\t* tree-phinodes.c: Likewise.\n\t* tree-phinodes.h: Likewise.\n\t* tree-ssa-loop-ivopts.c: Likewise.\n\t* tree-ssa-loop-manip.c: Likewise.\n\t* tree-ssa-phiopt.c: Likewise.\n\t* tree-ssa-phiprop.c: Likewise.\n\t* tree-ssa-threadupdate.c: Likewise.\n\t* tree-ssa.c: Likewise.\n\t* tree-ssa.h: Likewise.\n\t* tree-vect-loop-manip.c: Likewise.\n\ngcc/c-family/ChangeLog:\n\t* c-common.c (c_get_substring_location): Update for renaming of\n\tget_source_location_for_substring to get_location_within_string.\n\t* c-lex.c: Replace \"source_location\" with \"location_t\".\n\t* c-opts.c: Likewise.\n\t* c-ppoutput.c: Likewise.\n\ngcc/c/ChangeLog:\n\t* c-decl.c: Replace \"source_location\" with \"location_t\".\n\t* c-tree.h: Likewise.\n\t* c-typeck.c: Likewise.\n\t* gimple-parser.c: Likewise.\n\ngcc/cp/ChangeLog:\n\t* call.c: Replace \"source_location\" with \"location_t\".\n\t* cp-tree.h: Likewise.\n\t* cvt.c: Likewise.\n\t* name-lookup.c: Likewise.\n\t* parser.c: Likewise.\n\t* typeck.c: Likewise.\n\ngcc/fortran/ChangeLog:\n\t* cpp.c: Replace \"source_location\" with \"location_t\".\n\t* gfortran.h: Likewise.\n\ngcc/go/ChangeLog:\n\t* go-gcc-diagnostics.cc: Replace \"source_location\" with \"location_t\".\n\t* go-gcc.cc: Likewise.\n\t* go-linemap.cc: Likewise.\n\t* go-location.h: Likewise.\n\t* gofrontend/README: Likewise.\n\ngcc/jit/ChangeLog:\n\t* jit-playback.c: Replace \"source_location\" with \"location_t\".\n\ngcc/testsuite/ChangeLog:\n\t* g++.dg/plugin/comment_plugin.c: Replace \"source_location\" with\n\t\"location_t\".\n\t* gcc.dg/plugin/diagnostic_plugin_test_show_locus.c: Likewise.\n\nlibcc1/ChangeLog:\n\t* libcc1plugin.cc: Replace \"source_location\" with \"location_t\".\n\t(plugin_context::get_source_location): Rename to...\n\t(plugin_context::get_location_t): ...this.\n\t* libcp1plugin.cc: Likewise.\n\nlibcpp/ChangeLog:\n\t* charset.c: Replace \"source_location\" with \"location_t\".\n\t* directives-only.c: Likewise.\n\t* directives.c: Likewise.\n\t* errors.c: Likewise.\n\t* expr.c: Likewise.\n\t* files.c: Likewise.\n\t* include/cpplib.h: Likewise.  Rename MAX_SOURCE_LOCATION to\n\tMAX_LOCATION_T.\n\t* include/line-map.h: Likewise.\n\t* init.c: Likewise.\n\t* internal.h: Likewise.\n\t* lex.c: Likewise.\n\t* line-map.c: Likewise.\n\t* location-example.txt: Likewise.\n\t* macro.c: Likewise.\n\t* pch.c: Likewise.\n\t* traditional.c: Likewise.\n\nFrom-SVN: r266085", "tree": {"sha": "18b833ac960291d05524d5994ae4292048632226", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18b833ac960291d05524d5994ae4292048632226"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/620e594be58d2f933902a6619fd20aa618070b4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/620e594be58d2f933902a6619fd20aa618070b4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/620e594be58d2f933902a6619fd20aa618070b4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/620e594be58d2f933902a6619fd20aa618070b4b/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f9731de3db4c59ff0a241ce2c3d6f80aca5b5c28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9731de3db4c59ff0a241ce2c3d6f80aca5b5c28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9731de3db4c59ff0a241ce2c3d6f80aca5b5c28"}], "stats": {"total": 1574, "additions": 840, "deletions": 734}, "files": [{"sha": "9f474bb00750c356ba0b4ea122b937ab96540340", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -1,3 +1,37 @@\n+2018-11-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* builtins.c: Replace \"source_location\" with \"location_t\".\n+\t* diagnostic-show-locus.c: Likewise.\n+\t* diagnostic.c: Likewise.\n+\t* dumpfile.c: Likewise.\n+\t* gcc-rich-location.h: Likewise.\n+\t* genmatch.c: Likewise.\n+\t* gimple.h: Likewise.\n+\t* gimplify.c: Likewise.\n+\t* input.c: Likewise.\n+\t* input.h: Likewise.  Eliminate the typedef.\n+\t* omp-expand.c: Likewise.\n+\t* selftest.h: Likewise.\n+\t* substring-locations.h (get_source_location_for_substring):\n+\tRename to..\n+\t(get_location_within_string): ...this.\n+\t* tree-cfg.c: Replace \"source_location\" with \"location_t\".\n+\t* tree-cfgcleanup.c: Likewise.\n+\t* tree-diagnostic.c: Likewise.\n+\t* tree-into-ssa.c: Likewise.\n+\t* tree-outof-ssa.c: Likewise.\n+\t* tree-parloops.c: Likewise.\n+\t* tree-phinodes.c: Likewise.\n+\t* tree-phinodes.h: Likewise.\n+\t* tree-ssa-loop-ivopts.c: Likewise.\n+\t* tree-ssa-loop-manip.c: Likewise.\n+\t* tree-ssa-phiopt.c: Likewise.\n+\t* tree-ssa-phiprop.c: Likewise.\n+\t* tree-ssa-threadupdate.c: Likewise.\n+\t* tree-ssa.c: Likewise.\n+\t* tree-ssa.h: Likewise.\n+\t* tree-vect-loop-manip.c: Likewise.\n+\n 2018-11-13  Michael Ploujnikov  <michael.ploujnikov@oracle.com>\n \n \t* doc/extend.texi: Fix typo in the weakref description."}, {"sha": "ebde2db6e6494cf7e4441f6834e65fcb81e1629c", "filename": "gcc/builtins.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -6151,7 +6151,7 @@ get_memmodel (tree exp)\n {\n   rtx op;\n   unsigned HOST_WIDE_INT val;\n-  source_location loc\n+  location_t loc\n     = expansion_point_location_if_in_system_header (input_location);\n \n   /* If the parameter is not a constant, it's a run time value so we'll just\n@@ -6227,7 +6227,7 @@ expand_builtin_atomic_compare_exchange (machine_mode mode, tree exp,\n   enum memmodel success, failure;\n   tree weak;\n   bool is_weak;\n-  source_location loc\n+  location_t loc\n     = expansion_point_location_if_in_system_header (input_location);\n \n   success = get_memmodel (CALL_EXPR_ARG (exp, 4));\n@@ -6354,7 +6354,7 @@ expand_ifn_atomic_compare_exchange (gcall *call)\n   enum memmodel success, failure;\n   tree lhs;\n   bool is_weak;\n-  source_location loc\n+  location_t loc\n     = expansion_point_location_if_in_system_header (gimple_location (call));\n \n   success = get_memmodel (gimple_call_arg (call, 4));\n@@ -6426,7 +6426,7 @@ expand_builtin_atomic_load (machine_mode mode, tree exp, rtx target)\n   model = get_memmodel (CALL_EXPR_ARG (exp, 1));\n   if (is_mm_release (model) || is_mm_acq_rel (model))\n     {\n-      source_location loc\n+      location_t loc\n \t= expansion_point_location_if_in_system_header (input_location);\n       warning_at (loc, OPT_Winvalid_memory_model,\n \t\t  \"invalid memory model for %<__atomic_load%>\");\n@@ -6458,7 +6458,7 @@ expand_builtin_atomic_store (machine_mode mode, tree exp)\n   if (!(is_mm_relaxed (model) || is_mm_seq_cst (model)\n \t|| is_mm_release (model)))\n     {\n-      source_location loc\n+      location_t loc\n \t= expansion_point_location_if_in_system_header (input_location);\n       warning_at (loc, OPT_Winvalid_memory_model,\n \t\t  \"invalid memory model for %<__atomic_store%>\");\n@@ -6651,7 +6651,7 @@ expand_builtin_atomic_clear (tree exp)\n \n   if (is_mm_consume (model) || is_mm_acquire (model) || is_mm_acq_rel (model))\n     {\n-      source_location loc\n+      location_t loc\n \t= expansion_point_location_if_in_system_header (input_location);\n       warning_at (loc, OPT_Winvalid_memory_model,\n \t\t  \"invalid memory model for %<__atomic_store%>\");\n@@ -10200,7 +10200,7 @@ fold_builtin_next_arg (tree exp, bool va_start_p)\n      definition of the va_start macro (perhaps on the token for\n      builtin) in a system header, so warnings will not be emitted.\n      Use the location in real source code.  */\n-  source_location current_location =\n+  location_t current_location =\n     linemap_unwind_to_first_non_reserved_loc (line_table, input_location,\n \t\t\t\t\t      NULL);\n "}, {"sha": "4b8d8228dfa2fac5e7de4fb5ccb1f5a922a574ca", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -1,3 +1,11 @@\n+2018-11-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-common.c (c_get_substring_location): Update for renaming of\n+\tget_source_location_for_substring to get_location_within_string.\n+\t* c-lex.c: Replace \"source_location\" with \"location_t\".\n+\t* c-opts.c: Likewise.\n+\t* c-ppoutput.c: Likewise.\n+\n 2018-11-13  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/81824"}, {"sha": "9c2f18609acb48b4cff92c5c4a655f7cb64aba5f", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -862,13 +862,13 @@ c_get_substring_location (const substring_loc &substr_loc,\n   if (tok_type == CPP_OTHER)\n     return \"unrecognized string type\";\n \n-  return get_source_location_for_substring (parse_in, g_string_concat_db,\n-\t\t\t\t\t    substr_loc.get_fmt_string_loc (),\n-\t\t\t\t\t    tok_type,\n-\t\t\t\t\t    substr_loc.get_caret_idx (),\n-\t\t\t\t\t    substr_loc.get_start_idx (),\n-\t\t\t\t\t    substr_loc.get_end_idx (),\n-\t\t\t\t\t    out_loc);\n+  return get_location_within_string (parse_in, g_string_concat_db,\n+\t\t\t\t     substr_loc.get_fmt_string_loc (),\n+\t\t\t\t     tok_type,\n+\t\t\t\t     substr_loc.get_caret_idx (),\n+\t\t\t\t     substr_loc.get_start_idx (),\n+\t\t\t\t     substr_loc.get_end_idx (),\n+\t\t\t\t     out_loc);\n }\n \n \f"}, {"sha": "d979a970459a6567f5135c53740c196b5acf23b3", "filename": "gcc/c-family/c-lex.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fc-family%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fc-family%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-lex.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -237,7 +237,7 @@ fe_file_change (const line_map_ordinary *new_map)\n }\n \n static void\n-cb_def_pragma (cpp_reader *pfile, source_location loc)\n+cb_def_pragma (cpp_reader *pfile, location_t loc)\n {\n   /* Issue a warning message if we have been asked to do so.  Ignore\n      unknown pragmas in system headers unless an explicit\n@@ -265,7 +265,7 @@ cb_def_pragma (cpp_reader *pfile, source_location loc)\n \n /* #define callback for DWARF and DWARF2 debug info.  */\n static void\n-cb_define (cpp_reader *pfile, source_location loc, cpp_hashnode *node)\n+cb_define (cpp_reader *pfile, location_t loc, cpp_hashnode *node)\n {\n   const struct line_map *map = linemap_lookup (line_table, loc);\n   (*debug_hooks->define) (SOURCE_LINE (linemap_check_ordinary (map), loc),\n@@ -274,7 +274,7 @@ cb_define (cpp_reader *pfile, source_location loc, cpp_hashnode *node)\n \n /* #undef callback for DWARF and DWARF2 debug info.  */\n static void\n-cb_undef (cpp_reader * ARG_UNUSED (pfile), source_location loc,\n+cb_undef (cpp_reader * ARG_UNUSED (pfile), location_t loc,\n \t  cpp_hashnode *node)\n {\n   const struct line_map *map = linemap_lookup (line_table, loc);"}, {"sha": "356bd4c3627d4dcbf3977a5f67d7bc53a7c31913", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -1393,7 +1393,7 @@ c_finish_options (void)\n       cb_file_change (parse_in, bltin_map);\n \n       /* Make sure all of the builtins about to be declared have\n-\t BUILTINS_LOCATION has their source_location.  */\n+\t BUILTINS_LOCATION has their location_t.  */\n       cpp_force_token_locations (parse_in, BUILTINS_LOCATION);\n \n       cpp_init_builtins (parse_in, flag_hosted);"}, {"sha": "bb5d99650c72b80b6bb3687e500b164e790e2f1c", "filename": "gcc/c-family/c-ppoutput.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fc-family%2Fc-ppoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fc-family%2Fc-ppoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ppoutput.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -59,24 +59,24 @@ static void account_for_newlines (const unsigned char *, size_t);\n static int dump_macro (cpp_reader *, cpp_hashnode *, void *);\n static void dump_queued_macros (cpp_reader *);\n \n-static bool print_line_1 (source_location, const char*, FILE *);\n-static bool print_line (source_location, const char *);\n-static bool maybe_print_line_1 (source_location, FILE *);\n-static bool maybe_print_line (source_location);\n+static bool print_line_1 (location_t, const char*, FILE *);\n+static bool print_line (location_t, const char *);\n+static bool maybe_print_line_1 (location_t, FILE *);\n+static bool maybe_print_line (location_t);\n static bool do_line_change (cpp_reader *, const cpp_token *,\n-\t\t\t    source_location, int);\n+\t\t\t    location_t, int);\n \n /* Callback routines for the parser.   Most of these are active only\n    in specific modes.  */\n static void cb_line_change (cpp_reader *, const cpp_token *, int);\n-static void cb_define (cpp_reader *, source_location, cpp_hashnode *);\n-static void cb_undef (cpp_reader *, source_location, cpp_hashnode *);\n-static void cb_used_define (cpp_reader *, source_location, cpp_hashnode *);\n-static void cb_used_undef (cpp_reader *, source_location, cpp_hashnode *);\n-static void cb_include (cpp_reader *, source_location, const unsigned char *,\n+static void cb_define (cpp_reader *, location_t, cpp_hashnode *);\n+static void cb_undef (cpp_reader *, location_t, cpp_hashnode *);\n+static void cb_used_define (cpp_reader *, location_t, cpp_hashnode *);\n+static void cb_used_undef (cpp_reader *, location_t, cpp_hashnode *);\n+static void cb_include (cpp_reader *, location_t, const unsigned char *,\n \t\t\tconst char *, int, const cpp_token **);\n-static void cb_ident (cpp_reader *, source_location, const cpp_string *);\n-static void cb_def_pragma (cpp_reader *, source_location);\n+static void cb_ident (cpp_reader *, location_t, const cpp_string *);\n+static void cb_def_pragma (cpp_reader *, location_t);\n static void cb_read_pch (cpp_reader *pfile, const char *name,\n \t\t\t int fd, const char *orig_name);\n \n@@ -179,7 +179,7 @@ scan_translation_unit (cpp_reader *pfile)\n   print.source = NULL;\n   for (;;)\n     {\n-      source_location loc;\n+      location_t loc;\n       const cpp_token *token = cpp_get_token_with_location (pfile, &loc);\n \n       if (token->type == CPP_PADDING)\n@@ -336,7 +336,7 @@ scan_translation_unit_trad (cpp_reader *pfile)\n    return FALSE.  */\n \n static bool\n-maybe_print_line_1 (source_location src_loc, FILE *stream)\n+maybe_print_line_1 (location_t src_loc, FILE *stream)\n {\n   bool emitted_line_marker = false;\n   int src_line = LOCATION_LINE (src_loc);\n@@ -373,7 +373,7 @@ maybe_print_line_1 (source_location src_loc, FILE *stream)\n    return FALSE.  */\n \n static bool\n-maybe_print_line (source_location src_loc)\n+maybe_print_line (location_t src_loc)\n {\n   if (cpp_get_options (parse_in)->debug)\n     linemap_dump_location (line_table, src_loc,\n@@ -386,7 +386,7 @@ maybe_print_line (source_location src_loc)\n    was effectively emitted, return TRUE otherwise return FALSE.  */\n \n static bool\n-print_line_1 (source_location src_loc, const char *special_flags, FILE *stream)\n+print_line_1 (location_t src_loc, const char *special_flags, FILE *stream)\n {\n   bool emitted_line_marker = false;\n \n@@ -435,7 +435,7 @@ print_line_1 (source_location src_loc, const char *special_flags, FILE *stream)\n    line marker was effectively emitted, FALSE otherwise.  */\n \n static bool\n-print_line (source_location src_loc, const char *special_flags)\n+print_line (location_t src_loc, const char *special_flags)\n {\n     if (cpp_get_options (parse_in)->debug)\n       linemap_dump_location (line_table, src_loc,\n@@ -447,7 +447,7 @@ print_line (source_location src_loc, const char *special_flags)\n    Return TRUE if a line marker is emitted, FALSE otherwise.  */\n static bool\n do_line_change (cpp_reader *pfile, const cpp_token *token,\n-\t\tsource_location src_loc, int parsing_args)\n+\t\tlocation_t src_loc, int parsing_args)\n {\n   bool emitted_line_marker = false;\n   if (define_queue || undef_queue)\n@@ -487,7 +487,7 @@ cb_line_change (cpp_reader *pfile, const cpp_token *token,\n }\n \n static void\n-cb_ident (cpp_reader *pfile ATTRIBUTE_UNUSED, source_location line,\n+cb_ident (cpp_reader *pfile ATTRIBUTE_UNUSED, location_t line,\n \t  const cpp_string *str)\n {\n   maybe_print_line (line);\n@@ -496,7 +496,7 @@ cb_ident (cpp_reader *pfile ATTRIBUTE_UNUSED, source_location line,\n }\n \n static void\n-cb_define (cpp_reader *pfile, source_location line, cpp_hashnode *node)\n+cb_define (cpp_reader *pfile, location_t line, cpp_hashnode *node)\n {\n   const line_map_ordinary *map;\n \n@@ -520,7 +520,7 @@ cb_define (cpp_reader *pfile, source_location line, cpp_hashnode *node)\n }\n \n static void\n-cb_undef (cpp_reader *pfile ATTRIBUTE_UNUSED, source_location line,\n+cb_undef (cpp_reader *pfile ATTRIBUTE_UNUSED, location_t line,\n \t  cpp_hashnode *node)\n {\n   maybe_print_line (line);\n@@ -529,7 +529,7 @@ cb_undef (cpp_reader *pfile ATTRIBUTE_UNUSED, source_location line,\n }\n \n static void\n-cb_used_define (cpp_reader *pfile, source_location line ATTRIBUTE_UNUSED,\n+cb_used_define (cpp_reader *pfile, location_t line ATTRIBUTE_UNUSED,\n \t\tcpp_hashnode *node)\n {\n   if (cpp_user_macro_p (node))\n@@ -544,7 +544,7 @@ cb_used_define (cpp_reader *pfile, source_location line ATTRIBUTE_UNUSED,\n \n static void\n cb_used_undef (cpp_reader *pfile ATTRIBUTE_UNUSED,\n-\t       source_location line ATTRIBUTE_UNUSED,\n+\t       location_t line ATTRIBUTE_UNUSED,\n \t       cpp_hashnode *node)\n {\n   macro_queue *q;\n@@ -595,7 +595,7 @@ dump_queued_macros (cpp_reader *pfile ATTRIBUTE_UNUSED)\n }\n \n static void\n-cb_include (cpp_reader *pfile ATTRIBUTE_UNUSED, source_location line,\n+cb_include (cpp_reader *pfile ATTRIBUTE_UNUSED, location_t line,\n \t    const unsigned char *dir, const char *header, int angle_brackets,\n \t    const cpp_token **comments)\n {\n@@ -676,7 +676,7 @@ pp_file_change (const line_map_ordinary *map)\n \n /* Copy a #pragma directive to the preprocessed output.  */\n static void\n-cb_def_pragma (cpp_reader *pfile, source_location line)\n+cb_def_pragma (cpp_reader *pfile, location_t line)\n {\n   maybe_print_line (line);\n   fputs (\"#pragma \", print.outf);"}, {"sha": "6620bd0c5bfd99454c4e8299d7fdaf6116e9cc54", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -1,3 +1,10 @@\n+2018-11-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-decl.c: Replace \"source_location\" with \"location_t\".\n+\t* c-tree.h: Likewise.\n+\t* c-typeck.c: Likewise.\n+\t* gimple-parser.c: Likewise.\n+\n 2018-11-09  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-parser.c (c_parser_omp_clause_final): Use"}, {"sha": "4a62b1e49990bdadf23682f591191606c557f087", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -9955,7 +9955,7 @@ build_null_declspecs (void)\n    SPECS, returning SPECS.  */\n \n struct c_declspecs *\n-declspecs_add_addrspace (source_location location,\n+declspecs_add_addrspace (location_t location,\n \t\t\t struct c_declspecs *specs, addr_space_t as)\n {\n   specs->non_sc_seen_p = true;\n@@ -9978,7 +9978,7 @@ declspecs_add_addrspace (source_location location,\n    returning SPECS.  */\n \n struct c_declspecs *\n-declspecs_add_qual (source_location loc,\n+declspecs_add_qual (location_t loc,\n \t\t    struct c_declspecs *specs, tree qual)\n {\n   enum rid i;\n@@ -10895,7 +10895,7 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n    declaration specifiers SPECS, returning SPECS.  */\n \n struct c_declspecs *\n-declspecs_add_scspec (source_location loc,\n+declspecs_add_scspec (location_t loc,\n \t\t      struct c_declspecs *specs,\n \t\t      tree scspec)\n {\n@@ -11014,7 +11014,7 @@ declspecs_add_scspec (source_location loc,\n    returning SPECS.  */\n \n struct c_declspecs *\n-declspecs_add_attrs (source_location loc, struct c_declspecs *specs, tree attrs)\n+declspecs_add_attrs (location_t loc, struct c_declspecs *specs, tree attrs)\n {\n   specs->attrs = chainon (attrs, specs->attrs);\n   specs->locations[cdw_attributes] = loc;\n@@ -11026,7 +11026,7 @@ declspecs_add_attrs (source_location loc, struct c_declspecs *specs, tree attrs)\n    alignment is ALIGN) to the declaration specifiers SPECS, returning\n    SPECS.  */\n struct c_declspecs *\n-declspecs_add_alignas (source_location loc,\n+declspecs_add_alignas (location_t loc,\n \t\t       struct c_declspecs *specs, tree align)\n {\n   int align_log;"}, {"sha": "5ed2f48f763ba274b0ba67337d5f09375468b6ab", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -288,7 +288,7 @@ enum c_declspec_word {\n    specifier is added, please update the enum c_declspec_word above\n    accordingly.  */\n struct c_declspecs {\n-  source_location locations[cdw_number_of_elements];\n+  location_t locations[cdw_number_of_elements];\n   /* The type specified, if a single type specifier such as a struct,\n      union or enum specifier, typedef name or typeof specifies the\n      whole type, or NULL_TREE if none or a keyword such as \"void\" or\n@@ -592,19 +592,19 @@ extern struct c_declarator *build_id_declarator (tree);\n extern struct c_declarator *make_pointer_declarator (struct c_declspecs *,\n \t\t\t\t\t\t     struct c_declarator *);\n extern struct c_declspecs *build_null_declspecs (void);\n-extern struct c_declspecs *declspecs_add_qual (source_location,\n+extern struct c_declspecs *declspecs_add_qual (location_t,\n \t\t\t\t\t       struct c_declspecs *, tree);\n extern struct c_declspecs *declspecs_add_type (location_t,\n \t\t\t\t\t       struct c_declspecs *,\n \t\t\t\t\t       struct c_typespec);\n-extern struct c_declspecs *declspecs_add_scspec (source_location,\n+extern struct c_declspecs *declspecs_add_scspec (location_t,\n \t\t\t\t\t\t struct c_declspecs *, tree);\n-extern struct c_declspecs *declspecs_add_attrs (source_location,\n+extern struct c_declspecs *declspecs_add_attrs (location_t,\n \t\t\t\t\t\tstruct c_declspecs *, tree);\n-extern struct c_declspecs *declspecs_add_addrspace (source_location,\n+extern struct c_declspecs *declspecs_add_addrspace (location_t,\n \t\t\t\t\t\t    struct c_declspecs *,\n \t\t\t\t\t\t    addr_space_t);\n-extern struct c_declspecs *declspecs_add_alignas (source_location,\n+extern struct c_declspecs *declspecs_add_alignas (location_t,\n \t\t\t\t\t\t  struct c_declspecs *, tree);\n extern struct c_declspecs *finish_declspecs (struct c_declspecs *);\n "}, {"sha": "5d4e973c89e4da532848683e95133b599aef5253", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -6226,7 +6226,7 @@ pedwarn_init (location_t loc, int opt, const char *gmsgid, ...)\n   /* Use the location where a macro was expanded rather than where\n      it was defined to make sure macros defined in system headers\n      but used incorrectly elsewhere are diagnosed.  */\n-  source_location exploc = expansion_point_location_if_in_system_header (loc);\n+  location_t exploc = expansion_point_location_if_in_system_header (loc);\n   auto_diagnostic_group d;\n   va_list ap;\n   va_start (ap, gmsgid);\n@@ -6254,7 +6254,7 @@ warning_init (location_t loc, int opt, const char *gmsgid)\n   /* Use the location where a macro was expanded rather than where\n      it was defined to make sure macros defined in system headers\n      but used incorrectly elsewhere are diagnosed.  */\n-  source_location exploc = expansion_point_location_if_in_system_header (loc);\n+  location_t exploc = expansion_point_location_if_in_system_header (loc);\n \n   /* The gmsgid may be a format string with %< and %>. */\n   warned = warning_at (exploc, opt, gmsgid);\n@@ -10234,7 +10234,7 @@ c_finish_return (location_t loc, tree retval, tree origtype)\n \n   /* Use the expansion point to handle cases such as returning NULL\n      in a function returning void.  */\n-  source_location xloc = expansion_point_location_if_in_system_header (loc);\n+  location_t xloc = expansion_point_location_if_in_system_header (loc);\n \n   if (TREE_THIS_VOLATILE (current_function_decl))\n     warning_at (xloc, 0,"}, {"sha": "c80a8bb6c6cda132880ffc280abc5eb08444548b", "filename": "gcc/c/gimple-parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fc%2Fgimple-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fc%2Fgimple-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fgimple-parser.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -1643,7 +1643,7 @@ c_finish_gimple_return (location_t loc, tree retval)\n \n   /* Use the expansion point to handle cases such as returning NULL\n      in a function returning void.  */\n-  source_location xloc = expansion_point_location_if_in_system_header (loc);\n+  location_t xloc = expansion_point_location_if_in_system_header (loc);\n \n   if (TREE_THIS_VOLATILE (current_function_decl))\n     warning_at (xloc, 0,"}, {"sha": "1587b49e7dd341baf9ffffd8cac9a73f20cc37df", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -1,3 +1,12 @@\n+2018-11-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* call.c: Replace \"source_location\" with \"location_t\".\n+\t* cp-tree.h: Likewise.\n+\t* cvt.c: Likewise.\n+\t* name-lookup.c: Likewise.\n+\t* parser.c: Likewise.\n+\t* typeck.c: Likewise.\n+\n 2018-11-12  Jason Merrill  <jason@redhat.com>\n \n \tImplement P0315R4, Lambdas in unevaluated contexts."}, {"sha": "ee099cc7277fcf34b1b932694020b485f89fc5ee", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -6681,7 +6681,7 @@ conversion_null_warnings (tree totype, tree expr, tree fn, int argnum)\n   if (null_node_p (expr) && TREE_CODE (totype) != BOOLEAN_TYPE\n       && ARITHMETIC_TYPE_P (totype))\n     {\n-      source_location loc =\n+      location_t loc =\n \texpansion_point_location_if_in_system_header (input_location);\n \n       if (fn)\n@@ -6710,7 +6710,7 @@ conversion_null_warnings (tree totype, tree expr, tree fn, int argnum)\n   else if (null_ptr_cst_p (expr) &&\n \t   (TYPE_PTR_OR_PTRMEM_P (totype) || NULLPTR_TYPE_P (totype)))\n     {\n-      source_location loc =\n+      location_t loc =\n        expansion_point_location_if_in_system_header (input_location);\n       maybe_warn_zero_as_null_pointer_constant (expr, loc);\n     }\n@@ -7386,7 +7386,7 @@ convert_arg_to_ellipsis (tree arg, tsubst_flags_t complain)\n /* va_arg (EXPR, TYPE) is a builtin. Make sure it is not abused.  */\n \n tree\n-build_x_va_arg (source_location loc, tree expr, tree type)\n+build_x_va_arg (location_t loc, tree expr, tree type)\n {\n   if (processing_template_decl)\n     {"}, {"sha": "bfb88de9e34b076cb84a72c60470c1834851d879", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -5783,7 +5783,7 @@ enum cp_decl_spec {\n struct cp_decl_specifier_seq {\n   /* An array of locations for the declaration sepecifiers, indexed by\n      enum cp_decl_spec_word.  */\n-  source_location locations[ds_last];\n+  location_t locations[ds_last];\n   /* The primary type, if any, given by the decl-specifier-seq.\n      Modifiers, like \"short\", \"const\", and \"unsigned\" are not\n      reflected here.  This field will be a TYPE, unless a typedef-name\n@@ -6183,7 +6183,7 @@ extern void pop_defarg_context\t\t\t(void);\n extern tree convert_default_arg\t\t\t(tree, tree, tree, int,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree convert_arg_to_ellipsis\t\t(tree, tsubst_flags_t);\n-extern tree build_x_va_arg\t\t\t(source_location, tree, tree);\n+extern tree build_x_va_arg\t\t\t(location_t, tree, tree);\n extern tree cxx_type_promotes_to\t\t(tree);\n extern tree type_passed_as\t\t\t(tree);\n extern tree convert_for_arg_passing\t\t(tree, tree, tsubst_flags_t);\n@@ -6351,7 +6351,7 @@ extern tree build_cp_library_fn_ptr\t\t(const char *, tree, int);\n extern tree push_library_fn\t\t\t(tree, tree, tree, int);\n extern tree push_void_library_fn\t\t(tree, tree, int);\n extern tree push_throw_library_fn\t\t(tree, tree);\n-extern void warn_misplaced_attr_for_class_type  (source_location location,\n+extern void warn_misplaced_attr_for_class_type  (location_t location,\n \t\t\t\t\t\t tree class_type);\n extern tree check_tag_decl\t\t\t(cp_decl_specifier_seq *, bool);\n extern tree shadow_tag\t\t\t\t(cp_decl_specifier_seq *);"}, {"sha": "eb1687377c3e049bd6164a0b6405b0ad90a96ddb", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -1687,7 +1687,7 @@ build_expr_type_conversion (int desires, tree expr, bool complain)\n       && (desires & WANT_INT)\n       && !(desires & WANT_NULL))\n     {\n-      source_location loc =\n+      location_t loc =\n \texpansion_point_location_if_in_system_header (input_location);\n \n       warning_at (loc, OPT_Wconversion_null,"}, {"sha": "89a1823162630157449a25b1dfe5213c1a8df93c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -4752,7 +4752,7 @@ fixup_anonymous_aggr (tree t)\n    class-key, in it class-specifier.  */\n \n void\n-warn_misplaced_attr_for_class_type (source_location location,\n+warn_misplaced_attr_for_class_type (location_t location,\n \t\t\t\t    tree class_type)\n {\n   gcc_assert (OVERLOAD_TYPE_P (class_type));\n@@ -10257,7 +10257,7 @@ grokdeclarator (const cp_declarator *declarator,\n   bool constexpr_p = decl_spec_seq_has_spec_p (declspecs, ds_constexpr);\n   bool late_return_type_p = false;\n   bool array_parameter_p = false;\n-  source_location saved_loc = input_location;\n+  location_t saved_loc = input_location;\n   tree reqs = NULL_TREE;\n \n   signed_p = decl_spec_seq_has_spec_p (declspecs, ds_signed);"}, {"sha": "239bb013b83347687ea9ba2dfb2220fb2307e531", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -6049,7 +6049,7 @@ class macro_use_before_def : public deferred_diagnostic\n   static macro_use_before_def *\n   maybe_make (location_t use_loc, cpp_hashnode *macro)\n   {\n-    source_location def_loc = cpp_macro_definition_location (macro);\n+    location_t def_loc = cpp_macro_definition_location (macro);\n     if (def_loc == UNKNOWN_LOCATION)\n       return NULL;\n "}, {"sha": "e9e49b15702bcfa9bcdfa39506ba4391c658fb0f", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -5441,7 +5441,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t  {\n \t    tree expression;\n \t    tree type;\n-\t    source_location type_location;\n+\t    location_t type_location;\n \t    location_t start_loc\n \t      = cp_lexer_peek_token (parser->lexer)->location;\n \t    /* The `__builtin_va_arg' construct is used to handle\n@@ -28525,7 +28525,7 @@ set_and_check_decl_spec_loc (cp_decl_specifier_seq *decl_specs,\n   if (decl_specs == NULL)\n     return;\n \n-  source_location location = token->location;\n+  location_t location = token->location;\n \n   if (decl_specs->locations[ds] == 0)\n     {"}, {"sha": "7b42d539dfb93e50ee7c06d7526447c4e09e3b86", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -4433,7 +4433,7 @@ cp_build_binary_op (location_t location,\n \t      && !TYPE_PTR_OR_PTRMEM_P (type1)))\n       && (complain & tf_warning))\n     {\n-      source_location loc =\n+      location_t loc =\n \texpansion_point_location_if_in_system_header (input_location);\n \n       warning_at (loc, OPT_Wpointer_arith, \"NULL used in arithmetic\");"}, {"sha": "278e17274e96c64122df055cc7315cdea377a9f3", "filename": "gcc/diagnostic-show-locus.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fdiagnostic-show-locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fdiagnostic-show-locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-show-locus.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -777,11 +777,11 @@ compatible_locations_p (location_t loc_a, location_t loc_b)\n \t  /* Expand each location towards the spelling location, and\n \t     recurse.  */\n \t  const line_map_macro *macro_map = linemap_check_macro (map_a);\n-\t  source_location loc_a_toward_spelling\n+\t  location_t loc_a_toward_spelling\n \t    = linemap_macro_map_loc_unwind_toward_spelling (line_table,\n \t\t\t\t\t\t\t    macro_map,\n \t\t\t\t\t\t\t    loc_a);\n-\t  source_location loc_b_toward_spelling\n+\t  location_t loc_b_toward_spelling\n \t    = linemap_macro_map_loc_unwind_toward_spelling (line_table,\n \t\t\t\t\t\t\t    macro_map,\n \t\t\t\t\t\t\t    loc_b);"}, {"sha": "3d86a21fbaa442fecf7fca015c5ae3a4d8c9ae8e", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -794,12 +794,12 @@ print_parseable_fixits (pretty_printer *pp, rich_location *richloc)\n   for (unsigned i = 0; i < richloc->get_num_fixit_hints (); i++)\n     {\n       const fixit_hint *hint = richloc->get_fixit_hint (i);\n-      source_location start_loc = hint->get_start_loc ();\n+      location_t start_loc = hint->get_start_loc ();\n       expanded_location start_exploc = expand_location (start_loc);\n       pp_string (pp, \"fix-it:\");\n       print_escaped_string (pp, start_exploc.file);\n       /* For compatibility with clang, print as a half-open range.  */\n-      source_location next_loc = hint->get_next_loc ();\n+      location_t next_loc = hint->get_next_loc ();\n       expanded_location next_exploc = expand_location (next_loc);\n       pp_printf (pp, \":{%i:%i-%i:%i}:\",\n \t\t start_exploc.line, start_exploc.column,"}, {"sha": "86651df3aa2c5ae90b3204d8c651b0705ea5fbc9", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -47,7 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n \n static dump_flags_t pflags;\t\t      /* current dump_flags */\n \n-static void dump_loc (dump_flags_t, FILE *, source_location);\n+static void dump_loc (dump_flags_t, FILE *, location_t);\n \n /* Current -fopt-info output stream, if any, and flags.  */\n static FILE *alt_dump_file = NULL;\n@@ -466,7 +466,7 @@ kind_as_string (dump_flags_t dump_kind)\n /* Print source location on DFILE if enabled.  */\n \n static void\n-dump_loc (dump_flags_t dump_kind, FILE *dfile, source_location loc)\n+dump_loc (dump_flags_t dump_kind, FILE *dfile, location_t loc)\n {\n   if (dump_kind)\n     {\n@@ -487,7 +487,7 @@ dump_loc (dump_flags_t dump_kind, FILE *dfile, source_location loc)\n /* Print source location to PP if enabled.  */\n \n static void\n-dump_loc (dump_flags_t dump_kind, pretty_printer *pp, source_location loc)\n+dump_loc (dump_flags_t dump_kind, pretty_printer *pp, location_t loc)\n {\n   if (dump_kind)\n     {"}, {"sha": "8474baa0a72e21470c4cb9d7d669894b7df22f6e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -1,3 +1,8 @@\n+2018-11-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* cpp.c: Replace \"source_location\" with \"location_t\".\n+\t* gfortran.h: Likewise.\n+\n 2018-11-08  Jakub Jelinek  <jakub@redhat.com>\n \n \t* trans-openmp.c (gfc_trans_omp_clauses): Use"}, {"sha": "95b08a91343590e425859c7e84772dc2ef4dc866", "filename": "gcc/fortran/cpp.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ffortran%2Fcpp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ffortran%2Fcpp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcpp.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -134,14 +134,14 @@ static void scan_translation_unit_trad (cpp_reader *);\n    in specific modes.  */\n static void cb_file_change (cpp_reader *, const line_map_ordinary *);\n static void cb_line_change (cpp_reader *, const cpp_token *, int);\n-static void cb_define (cpp_reader *, source_location, cpp_hashnode *);\n-static void cb_undef (cpp_reader *, source_location, cpp_hashnode *);\n-static void cb_def_pragma (cpp_reader *, source_location);\n-static void cb_include (cpp_reader *, source_location, const unsigned char *,\n+static void cb_define (cpp_reader *, location_t, cpp_hashnode *);\n+static void cb_undef (cpp_reader *, location_t, cpp_hashnode *);\n+static void cb_def_pragma (cpp_reader *, location_t);\n+static void cb_include (cpp_reader *, location_t, const unsigned char *,\n \t\t\tconst char *, int, const cpp_token **);\n-static void cb_ident (cpp_reader *, source_location, const cpp_string *);\n-static void cb_used_define (cpp_reader *, source_location, cpp_hashnode *);\n-static void cb_used_undef (cpp_reader *, source_location, cpp_hashnode *);\n+static void cb_ident (cpp_reader *, location_t, const cpp_string *);\n+static void cb_used_define (cpp_reader *, location_t, cpp_hashnode *);\n+static void cb_used_undef (cpp_reader *, location_t, cpp_hashnode *);\n static bool cb_cpp_diagnostic (cpp_reader *, enum cpp_diagnostic_level,\n \t\t\t       enum cpp_warning_reason, rich_location *,\n \t\t\t       const char *, va_list *)\n@@ -578,7 +578,7 @@ gfc_cpp_init (void)\n   if (!gfc_cpp_option.no_predefined)\n     {\n       /* Make sure all of the builtins about to be declared have\n-\tBUILTINS_LOCATION has their source_location.  */\n+\tBUILTINS_LOCATION has their location_t.  */\n       cpp_force_token_locations (cpp_in, BUILTINS_LOCATION);\n \n       cpp_define_builtins (cpp_in);\n@@ -709,8 +709,8 @@ static void scan_translation_unit_trad (cpp_reader *);\n static void account_for_newlines (const unsigned char *, size_t);\n static int dump_macro (cpp_reader *, cpp_hashnode *, void *);\n \n-static void print_line (source_location, const char *);\n-static void maybe_print_line (source_location);\n+static void print_line (location_t, const char *);\n+static void maybe_print_line (location_t);\n \n \n /* Writes out the preprocessed file, handling spacing and paste\n@@ -790,7 +790,7 @@ scan_translation_unit_trad (cpp_reader *pfile)\n    different line to the current one, output the required newlines or\n    a line marker.  */\n static void\n-maybe_print_line (source_location src_loc)\n+maybe_print_line (location_t src_loc)\n {\n   const line_map_ordinary *map\n     = linemap_check_ordinary (linemap_lookup (line_table, src_loc));\n@@ -819,7 +819,7 @@ maybe_print_line (source_location src_loc)\n /* Output a line marker for logical line LINE.  Special flags are \"1\"\n    or \"2\" indicating entering or leaving a file.  */\n static void\n-print_line (source_location src_loc, const char *special_flags)\n+print_line (location_t src_loc, const char *special_flags)\n {\n   /* End any previous line of text.  */\n   if (print.printed)\n@@ -897,7 +897,7 @@ static void\n cb_line_change (cpp_reader *pfile, const cpp_token *token,\n \t\tint parsing_args)\n {\n-  source_location src_loc = token->src_loc;\n+  location_t src_loc = token->src_loc;\n \n   if (token->type == CPP_EOF || parsing_args)\n     return;\n@@ -924,7 +924,7 @@ cb_line_change (cpp_reader *pfile, const cpp_token *token,\n }\n \n static void\n-cb_ident (cpp_reader *pfile ATTRIBUTE_UNUSED, source_location line,\n+cb_ident (cpp_reader *pfile ATTRIBUTE_UNUSED, location_t line,\n \t  const cpp_string *str)\n {\n   maybe_print_line (line);\n@@ -933,7 +933,7 @@ cb_ident (cpp_reader *pfile ATTRIBUTE_UNUSED, source_location line,\n }\n \n static void\n-cb_define (cpp_reader *pfile ATTRIBUTE_UNUSED, source_location line,\n+cb_define (cpp_reader *pfile ATTRIBUTE_UNUSED, location_t line,\n            cpp_hashnode *node ATTRIBUTE_UNUSED)\n {\n   maybe_print_line (line);\n@@ -952,7 +952,7 @@ cb_define (cpp_reader *pfile ATTRIBUTE_UNUSED, source_location line,\n }\n \n static void\n-cb_undef (cpp_reader *pfile ATTRIBUTE_UNUSED, source_location line,\n+cb_undef (cpp_reader *pfile ATTRIBUTE_UNUSED, location_t line,\n \t  cpp_hashnode *node)\n {\n   maybe_print_line (line);\n@@ -961,7 +961,7 @@ cb_undef (cpp_reader *pfile ATTRIBUTE_UNUSED, source_location line,\n }\n \n static void\n-cb_include (cpp_reader *pfile ATTRIBUTE_UNUSED, source_location line,\n+cb_include (cpp_reader *pfile ATTRIBUTE_UNUSED, location_t line,\n \t    const unsigned char *dir, const char *header, int angle_brackets,\n \t    const cpp_token **comments)\n {\n@@ -1003,7 +1003,7 @@ dump_macro (cpp_reader *pfile, cpp_hashnode *node, void *v ATTRIBUTE_UNUSED)\n }\n \n static void\n-cb_used_define (cpp_reader *pfile, source_location line ATTRIBUTE_UNUSED,\n+cb_used_define (cpp_reader *pfile, location_t line ATTRIBUTE_UNUSED,\n \t\tcpp_hashnode *node)\n {\n   gfc_cpp_macro_queue *q;\n@@ -1086,7 +1086,7 @@ pp_dir_change (cpp_reader *pfile ATTRIBUTE_UNUSED, const char *dir)\n \n /* Copy a #pragma directive to the preprocessed output.  */\n static void\n-cb_def_pragma (cpp_reader *pfile, source_location line)\n+cb_def_pragma (cpp_reader *pfile, location_t line)\n {\n   maybe_print_line (line);\n   fputs (\"#pragma \", print.outf);\n@@ -1096,7 +1096,7 @@ cb_def_pragma (cpp_reader *pfile, source_location line)\n \n static void\n cb_used_undef (cpp_reader *pfile ATTRIBUTE_UNUSED,\n-\t       source_location line ATTRIBUTE_UNUSED,\n+\t       location_t line ATTRIBUTE_UNUSED,\n \t       cpp_hashnode *node)\n {\n   gfc_cpp_macro_queue *q;"}, {"sha": "128f5746aa9cdc6bd51324222cd9c51258961d3f", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -952,7 +952,7 @@ typedef struct gfc_file\n \n typedef struct gfc_linebuf\n {\n-  source_location location;\n+  location_t location;\n   struct gfc_file *file;\n   struct gfc_linebuf *next;\n "}, {"sha": "200bbb53c67a09fcd6ad9684695e3b7d869a4da3", "filename": "gcc/gcc-rich-location.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fgcc-rich-location.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fgcc-rich-location.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc-rich-location.h?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -28,7 +28,7 @@ class gcc_rich_location : public rich_location\n   /* Constructors.  */\n \n   /* Constructing from a location.  */\n-  gcc_rich_location (source_location loc, const range_label *label = NULL)\n+  gcc_rich_location (location_t loc, const range_label *label = NULL)\n   : rich_location (line_table, loc, label)\n   {\n   }"}, {"sha": "8e3827c6d7fc87cc3f4558317a7f24d191eaa009", "filename": "gcc/genmatch.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -53,15 +53,15 @@ unsigned verbose;\n static struct line_maps *line_table;\n \n /* The rich_location class within libcpp requires a way to expand\n-   source_location instances, and relies on the client code\n+   location_t instances, and relies on the client code\n    providing a symbol named\n      linemap_client_expand_location_to_spelling_point\n    to do this.\n \n    This is the implementation for genmatch.  */\n \n expanded_location\n-linemap_client_expand_location_to_spelling_point (source_location loc,\n+linemap_client_expand_location_to_spelling_point (location_t loc,\n \t\t\t\t\t\t  enum location_aspect)\n {\n   const struct line_map_ordinary *map;\n@@ -78,7 +78,7 @@ diagnostic_cb (cpp_reader *, enum cpp_diagnostic_level errtype,\n \t       const char *msg, va_list *ap)\n {\n   const line_map_ordinary *map;\n-  source_location location = richloc->get_loc ();\n+  location_t location = richloc->get_loc ();\n   linemap_resolve_location (line_table, location, LRK_SPELLING_LOCATION, &map);\n   expanded_location loc = linemap_expand_location (line_table, map, location);\n   fprintf (stderr, \"%s:%d:%d %s: \", loc.file, loc.line, loc.column,\n@@ -131,7 +131,7 @@ static void\n #if GCC_VERSION >= 4001\n __attribute__((format (printf, 2, 3)))\n #endif\n-fatal_at (source_location loc, const char *msg, ...)\n+fatal_at (location_t loc, const char *msg, ...)\n {\n   rich_location richloc (line_table, loc);\n   va_list ap;\n@@ -157,7 +157,7 @@ static void\n #if GCC_VERSION >= 4001\n __attribute__((format (printf, 2, 3)))\n #endif\n-warning_at (source_location loc, const char *msg, ...)\n+warning_at (location_t loc, const char *msg, ...)\n {\n   rich_location richloc (line_table, loc);\n   va_list ap;\n@@ -184,7 +184,7 @@ fprintf_indent (FILE *f, unsigned int indent, const char *format, ...)\n }\n \n static void\n-output_line_directive (FILE *f, source_location location,\n+output_line_directive (FILE *f, location_t location,\n \t\t       bool dumpfile = false, bool fnargs = false)\n {\n   const line_map_ordinary *map;\n@@ -667,10 +667,10 @@ struct capture_info;\n \n struct operand {\n   enum op_type { OP_PREDICATE, OP_EXPR, OP_CAPTURE, OP_C_EXPR, OP_IF, OP_WITH };\n-  operand (enum op_type type_, source_location loc_)\n+  operand (enum op_type type_, location_t loc_)\n     : type (type_), location (loc_) {}\n   enum op_type type;\n-  source_location location;\n+  location_t location;\n   virtual void gen_transform (FILE *, int, const char *, bool, int,\n \t\t\t      const char *, capture_info *,\n \t\t\t      dt_operand ** = 0,\n@@ -682,7 +682,7 @@ struct operand {\n \n struct predicate : public operand\n {\n-  predicate (predicate_id *p_, source_location loc)\n+  predicate (predicate_id *p_, location_t loc)\n     : operand (OP_PREDICATE, loc), p (p_) {}\n   predicate_id *p;\n };\n@@ -692,7 +692,7 @@ struct predicate : public operand\n \n struct expr : public operand\n {\n-  expr (id_base *operation_, source_location loc, bool is_commutative_ = false)\n+  expr (id_base *operation_, location_t loc, bool is_commutative_ = false)\n     : operand (OP_EXPR, loc), operation (operation_),\n       ops (vNULL), expr_type (NULL), is_commutative (is_commutative_),\n       is_generic (false), force_single_use (false) {}\n@@ -733,7 +733,7 @@ struct c_expr : public operand\n     id_tab (const char *id_, const char *oper_): id (id_), oper (oper_) {}\n   };\n \n-  c_expr (cpp_reader *r_, source_location loc,\n+  c_expr (cpp_reader *r_, location_t loc,\n \t  vec<cpp_token> code_, unsigned nr_stmts_,\n \t  vec<id_tab> ids_, cid_map_t *capture_ids_)\n     : operand (OP_C_EXPR, loc), r (r_), code (code_),\n@@ -755,7 +755,7 @@ struct c_expr : public operand\n \n struct capture : public operand\n {\n-  capture (source_location loc, unsigned where_, operand *what_, bool value_)\n+  capture (location_t loc, unsigned where_, operand *what_, bool value_)\n       : operand (OP_CAPTURE, loc), where (where_), value_match (value_),\n         what (what_) {}\n   /* Identifier index for the value.  */\n@@ -775,7 +775,7 @@ struct capture : public operand\n \n struct if_expr : public operand\n {\n-  if_expr (source_location loc)\n+  if_expr (location_t loc)\n     : operand (OP_IF, loc), cond (NULL), trueexpr (NULL), falseexpr (NULL) {}\n   c_expr *cond;\n   operand *trueexpr;\n@@ -786,7 +786,7 @@ struct if_expr : public operand\n \n struct with_expr : public operand\n {\n-  with_expr (source_location loc)\n+  with_expr (location_t loc)\n     : operand (OP_WITH, loc), with (NULL), subexpr (NULL) {}\n   c_expr *with;\n   operand *subexpr;\n@@ -1797,13 +1797,13 @@ decision_tree::find_node (vec<dt_node *>& ops, dt_node *p)\n \t    {\n \t      if (verbose >= 1)\n \t\t{\n-\t\t  source_location p_loc = 0;\n+\t\t  location_t p_loc = 0;\n \t\t  if (p->type == dt_node::DT_OPERAND)\n \t\t    p_loc = as_a <dt_operand *> (p)->op->location;\n-\t\t  source_location op_loc = 0;\n+\t\t  location_t op_loc = 0;\n \t\t  if (ops[i]->type == dt_node::DT_OPERAND)\n \t\t    op_loc = as_a <dt_operand *> (ops[i])->op->location;\n-\t\t  source_location true_loc = 0;\n+\t\t  location_t true_loc = 0;\n \t\t  true_loc = true_node->op->location;\n \t\t  warning_at (p_loc,\n \t\t\t      \"failed to merge decision tree node\");\n@@ -3925,18 +3925,18 @@ class parser\n   c_expr *parse_c_expr (cpp_ttype);\n   operand *parse_op ();\n \n-  void record_operlist (source_location, user_id *);\n+  void record_operlist (location_t, user_id *);\n \n   void parse_pattern ();\n   operand *parse_result (operand *, predicate_id *);\n   void push_simplify (simplify::simplify_kind,\n \t\t      vec<simplify *>&, operand *, operand *);\n   void parse_simplify (simplify::simplify_kind,\n \t\t       vec<simplify *>&, predicate_id *, operand *);\n-  void parse_for (source_location);\n-  void parse_if (source_location);\n-  void parse_predicates (source_location);\n-  void parse_operator_list (source_location);\n+  void parse_for (location_t);\n+  void parse_if (location_t);\n+  void parse_predicates (location_t);\n+  void parse_operator_list (location_t);\n \n   void finish_match_operand (operand *);\n \n@@ -4094,7 +4094,7 @@ parser::get_internal_capture_id ()\n /* Record an operator-list use for transparent for handling.  */\n \n void\n-parser::record_operlist (source_location loc, user_id *p)\n+parser::record_operlist (location_t loc, user_id *p)\n {\n   if (!oper_lists_set->add (p))\n     {\n@@ -4168,7 +4168,7 @@ parser::parse_operation ()\n struct operand *\n parser::parse_capture (operand *op, bool require_existing)\n {\n-  source_location src_loc = eat_token (CPP_ATSIGN)->src_loc;\n+  location_t src_loc = eat_token (CPP_ATSIGN)->src_loc;\n   const cpp_token *token = peek ();\n   const char *id = NULL;\n   bool value_match = false;\n@@ -4324,7 +4324,7 @@ parser::parse_c_expr (cpp_ttype start)\n   unsigned opencnt;\n   vec<cpp_token> code = vNULL;\n   unsigned nr_stmts = 0;\n-  source_location loc = eat_token (start)->src_loc;\n+  location_t loc = eat_token (start)->src_loc;\n   if (start == CPP_OPEN_PAREN)\n     end = CPP_CLOSE_PAREN;\n   else if (start == CPP_OPEN_BRACE)\n@@ -4513,7 +4513,7 @@ parser::parse_result (operand *result, predicate_id *matcher)\n   else if (peek_ident (\"switch\"))\n     {\n       token = eat_ident (\"switch\");\n-      source_location ifloc = eat_token (CPP_OPEN_PAREN)->src_loc;\n+      location_t ifloc = eat_token (CPP_OPEN_PAREN)->src_loc;\n       eat_ident (\"if\");\n       if_expr *ife = new if_expr (ifloc);\n       operand *res = ife;\n@@ -4652,7 +4652,7 @@ parser::parse_simplify (simplify::simplify_kind kind,\n      subst = <ident> '(' <ident>... ')'  */\n \n void\n-parser::parse_for (source_location)\n+parser::parse_for (location_t)\n {\n   auto_vec<const cpp_token *> user_id_tokens;\n   vec<user_id *> user_ids = vNULL;\n@@ -4766,7 +4766,7 @@ parser::parse_for (source_location)\n      oprs = '(' 'define_operator_list' <ident> <ident>... ')'  */\n \n void\n-parser::parse_operator_list (source_location)\n+parser::parse_operator_list (location_t)\n {\n   const cpp_token *token = peek (); \n   const char *id = get_ident ();\n@@ -4818,7 +4818,7 @@ parser::parse_operator_list (source_location)\n      if = '(' 'if' '(' <c-expr> ')' <pattern> ')'  */\n \n void\n-parser::parse_if (source_location)\n+parser::parse_if (location_t)\n {\n   c_expr *ifexpr = parse_c_expr (CPP_OPEN_PAREN);\n \n@@ -4842,7 +4842,7 @@ parser::parse_if (source_location)\n      preds = '(' 'define_predicates' <ident>... ')'  */\n \n void\n-parser::parse_predicates (source_location)\n+parser::parse_predicates (location_t)\n {\n   do\n     {\n@@ -4873,7 +4873,7 @@ parser::parse_pattern ()\n   else if (strcmp (id, \"match\") == 0)\n     {\n       bool with_args = false;\n-      source_location e_loc = peek ()->src_loc;\n+      location_t e_loc = peek ()->src_loc;\n       if (peek ()->type == CPP_OPEN_PAREN)\n \t{\n \t  eat_token (CPP_OPEN_PAREN);"}, {"sha": "9853521f984d035137ba481cba4e0201ca7c0a69", "filename": "gcc/gimple.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -4426,15 +4426,15 @@ gimple_phi_arg_edge (gphi *phi, size_t i)\n \n /* Return the source location of gimple argument I of phi node PHI.  */\n \n-static inline source_location\n+static inline location_t\n gimple_phi_arg_location (gphi *phi, size_t i)\n {\n   return gimple_phi_arg (phi, i)->locus;\n }\n \n /* Return the source location of the argument on edge E of phi node PHI.  */\n \n-static inline source_location\n+static inline location_t\n gimple_phi_arg_location_from_edge (gphi *phi, edge e)\n {\n   return gimple_phi_arg (phi, e->dest_idx)->locus;\n@@ -4443,7 +4443,7 @@ gimple_phi_arg_location_from_edge (gphi *phi, edge e)\n /* Set the source location of gimple argument I of phi node PHI to LOC.  */\n \n static inline void\n-gimple_phi_arg_set_location (gphi *phi, size_t i, source_location loc)\n+gimple_phi_arg_set_location (gphi *phi, size_t i, location_t loc)\n {\n   gimple_phi_arg (phi, i)->locus = loc;\n }"}, {"sha": "ad7f824e0fa2a70bd86016f1c96b756c44d7d392", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -13840,7 +13840,7 @@ gimplify_va_arg_expr (tree *expr_p, gimple_seq *pre_p,\n       bool warned;\n       /* Use the expansion point to handle cases such as passing bool (defined\n \t in a system header) through `...'.  */\n-      source_location xloc\n+      location_t xloc\n \t= expansion_point_location_if_in_system_header (loc);\n \n       /* Unfortunately, this is merely undefined, rather than a constraint"}, {"sha": "5f18b80a76741f8ef251dfed759ee34576220351", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -1,3 +1,11 @@\n+2018-11-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* go-gcc-diagnostics.cc: Replace \"source_location\" with \"location_t\".\n+\t* go-gcc.cc: Likewise.\n+\t* go-linemap.cc: Likewise.\n+\t* go-location.h: Likewise.\n+\t* gofrontend/README: Likewise.\n+\n 2018-10-31  Ian Lance Taylor  <iant@golang.org>\n \n \t* go-gcc.cc (Gcc_backend::write_global_definitions): Don't call"}, {"sha": "6ddf0f4d59666b650d729b9f8d12feaa88c51c9e", "filename": "gcc/go/go-gcc-diagnostics.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fgo%2Fgo-gcc-diagnostics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fgo%2Fgo-gcc-diagnostics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc-diagnostics.cc?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -24,7 +24,7 @@\n void\n go_be_error_at(const Location location, const std::string& errmsg)\n {\n-  source_location gcc_loc = location.gcc_location();\n+  location_t gcc_loc = location.gcc_location();\n   error_at(gcc_loc, \"%s\", errmsg.c_str());\n }\n \n@@ -33,23 +33,23 @@ void\n go_be_warning_at(const Location location,\n                  int opt, const std::string& warningmsg)\n {\n-  source_location gcc_loc = location.gcc_location();\n+  location_t gcc_loc = location.gcc_location();\n   warning_at(gcc_loc, opt, \"%s\", warningmsg.c_str());\n }\n \n void\n go_be_fatal_error(const Location location,\n                   const std::string& fatalmsg)\n {\n-  source_location gcc_loc = location.gcc_location();\n+  location_t gcc_loc = location.gcc_location();\n   fatal_error(gcc_loc, \"%s\", fatalmsg.c_str());\n }\n \n void\n go_be_inform(const Location location,\n              const std::string& infomsg)\n {\n-  source_location gcc_loc = location.gcc_location();\n+  location_t gcc_loc = location.gcc_location();\n   inform(gcc_loc, \"%s\", infomsg.c_str());\n }\n "}, {"sha": "be2302932f740233f5d9fde3282b00af5974bda7", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -2243,9 +2243,9 @@ Gcc_backend::switch_statement(\n     {\n       if (pc->empty())\n \t{\n-\t  source_location loc = (*ps != NULL\n-                                 ? EXPR_LOCATION((*ps)->get_tree())\n-                                 : UNKNOWN_LOCATION);\n+\t  location_t loc = (*ps != NULL\n+\t\t\t    ? EXPR_LOCATION((*ps)->get_tree())\n+\t\t\t    : UNKNOWN_LOCATION);\n \t  tree label = create_artificial_label(loc);\n \t  tree c = build_case_label(NULL_TREE, NULL_TREE, label);\n \t  append_to_statement_list(c, &stmt_list);\n@@ -2259,7 +2259,7 @@ Gcc_backend::switch_statement(\n \t      tree t = (*pcv)->get_tree();\n \t      if (t == error_mark_node)\n \t\treturn this->error_statement();\n-\t      source_location loc = EXPR_LOCATION(t);\n+\t      location_t loc = EXPR_LOCATION(t);\n \t      tree label = create_artificial_label(loc);\n \t      tree c = build_case_label((*pcv)->get_tree(), NULL_TREE, label);\n \t      append_to_statement_list(c, &stmt_list);"}, {"sha": "1d72e79647d80146f283e7caa189509881f01c5b", "filename": "gcc/go/go-linemap.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fgo%2Fgo-linemap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fgo%2Fgo-linemap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-linemap.cc?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -77,7 +77,7 @@ std::string\n Gcc_linemap::to_string(Location location)\n {\n   const line_map_ordinary *lmo;\n-  source_location resolved_location;\n+  location_t resolved_location;\n \n   // Screen out unknown and predeclared locations; produce output\n   // only for simple file:line locations."}, {"sha": "6637b86d0858027b79ab6c526a71215896700e23", "filename": "gcc/go/go-location.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fgo%2Fgo-location.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fgo%2Fgo-location.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-location.h?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -18,16 +18,16 @@ class Location\n     : gcc_loc_(UNKNOWN_LOCATION)\n   { }\n \n-  explicit Location(source_location loc)\n+  explicit Location(location_t loc)\n     : gcc_loc_(loc)\n   { }\n \n-  source_location\n+  location_t\n   gcc_location() const\n   { return this->gcc_loc_; }\n \n  private:\n-  source_location gcc_loc_;\n+  location_t gcc_loc_;\n };\n \n // The Go frontend requires the ability to compare Locations."}, {"sha": "b139194b0eb08799f4801f66b21e4d2f512be1ed", "filename": "gcc/go/gofrontend/README", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fgo%2Fgofrontend%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fgo%2Fgofrontend%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FREADME?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -14,7 +14,7 @@ header files.\n Issues to be faced in this transition:\n \n * Representation of source locations.\n-  + Currently the frontend uses gcc's source_location codes, using the\n+  + Currently the frontend uses gcc's location_t codes, using the\n     interface in libcpp/line-map.h.\n \n * Handling of error messages."}, {"sha": "347122e98a852b4f324be28b6576c04c333b0f57", "filename": "gcc/input.c", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -152,7 +152,7 @@ static const size_t fcache_line_record_size = 100;\n    ASPECT controls which part of the location to use.  */\n \n static expanded_location\n-expand_location_1 (source_location loc,\n+expand_location_1 (location_t loc,\n \t\t   bool expansion_point_p,\n \t\t   enum location_aspect aspect)\n {\n@@ -201,14 +201,14 @@ expand_location_1 (source_location loc,\n \t  break;\n \tcase LOCATION_ASPECT_START:\n \t  {\n-\t    source_location start = get_start (loc);\n+\t    location_t start = get_start (loc);\n \t    if (start != loc)\n \t      return expand_location_1 (start, expansion_point_p, aspect);\n \t  }\n \t  break;\n \tcase LOCATION_ASPECT_FINISH:\n \t  {\n-\t    source_location finish = get_finish (loc);\n+\t    location_t finish = get_finish (loc);\n \t    if (finish != loc)\n \t      return expand_location_1 (finish, expansion_point_p, aspect);\n \t  }\n@@ -256,7 +256,7 @@ static size_t\n total_lines_num (const char *file_path)\n {\n   size_t r = 0;\n-  source_location l = 0;\n+  location_t l = 0;\n   if (linemap_get_file_highest_location (line_table, file_path, &l))\n     {\n       gcc_assert (l >= RESERVED_LOCATION_COUNT);\n@@ -786,7 +786,7 @@ location_missing_trailing_newline (const char *file_path)\n    function would return true if passed a token \"4\" that is the result\n    of the expansion of the built-in __LINE__ macro.  */\n bool\n-is_location_from_builtin_token (source_location loc)\n+is_location_from_builtin_token (location_t loc)\n {\n   const line_map_ordinary *map = NULL;\n   loc = linemap_resolve_location (line_table, loc,\n@@ -800,7 +800,7 @@ is_location_from_builtin_token (source_location loc)\n    readable location is set to the string \"<built-in>\".  */\n \n expanded_location\n-expand_location (source_location loc)\n+expand_location (location_t loc)\n {\n   return expand_location_1 (loc, /*expansion_point_p=*/true,\n \t\t\t    LOCATION_ASPECT_CARET);\n@@ -813,14 +813,14 @@ expand_location (source_location loc)\n    \"<built-in>\".  */\n \n expanded_location\n-expand_location_to_spelling_point (source_location loc,\n+expand_location_to_spelling_point (location_t loc,\n \t\t\t\t   enum location_aspect aspect)\n {\n   return expand_location_1 (loc, /*expansion_point_p=*/false, aspect);\n }\n \n /* The rich_location class within libcpp requires a way to expand\n-   source_location instances, and relies on the client code\n+   location_t instances, and relies on the client code\n    providing a symbol named\n      linemap_client_expand_location_to_spelling_point\n    to do this.\n@@ -829,7 +829,7 @@ expand_location_to_spelling_point (source_location loc,\n    which simply calls into expand_location_1.  */\n \n expanded_location\n-linemap_client_expand_location_to_spelling_point (source_location loc,\n+linemap_client_expand_location_to_spelling_point (location_t loc,\n \t\t\t\t\t\t  enum location_aspect aspect)\n {\n   return expand_location_1 (loc, /*expansion_point_p=*/false, aspect);\n@@ -848,8 +848,8 @@ linemap_client_expand_location_to_spelling_point (source_location loc,\n    warning_at, the diagnostic would be suppressed (unless\n    -Wsystem-headers).  */\n \n-source_location\n-expansion_point_location_if_in_system_header (source_location location)\n+location_t\n+expansion_point_location_if_in_system_header (location_t location)\n {\n   if (in_system_header_at (location))\n     location = linemap_resolve_location (line_table, location,\n@@ -861,8 +861,8 @@ expansion_point_location_if_in_system_header (source_location location)\n /* If LOCATION is a virtual location for a token coming from the expansion\n    of a macro, unwind to the location of the expansion point of the macro.  */\n \n-source_location\n-expansion_point_location (source_location location)\n+location_t\n+expansion_point_location (location_t location)\n {\n   return linemap_resolve_location (line_table, location,\n \t\t\t\t   LRK_MACRO_EXPANSION_POINT, NULL);\n@@ -976,7 +976,7 @@ dump_line_table_statistics (void)\n \n /* Get location one beyond the final location in ordinary map IDX.  */\n \n-static source_location\n+static location_t\n get_end_location (struct line_maps *set, unsigned int idx)\n {\n   if (idx == LINEMAPS_ORDINARY_USED (set) - 1)\n@@ -1001,37 +1001,37 @@ write_digit (FILE *stream, int digit)\n static void\n write_digit_row (FILE *stream, int indent,\n \t\t const line_map_ordinary *map,\n-\t\t source_location loc, int max_col, int divisor)\n+\t\t location_t loc, int max_col, int divisor)\n {\n   fprintf (stream, \"%*c\", indent, ' ');\n   fprintf (stream, \"|\");\n   for (int column = 1; column < max_col; column++)\n     {\n-      source_location column_loc = loc + (column << map->m_range_bits);\n+      location_t column_loc = loc + (column << map->m_range_bits);\n       write_digit (stream, column_loc / divisor);\n     }\n   fprintf (stream, \"\\n\");\n }\n \n /* Write a half-closed (START) / half-open (END) interval of\n-   source_location to STREAM.  */\n+   location_t to STREAM.  */\n \n static void\n dump_location_range (FILE *stream,\n-\t\t     source_location start, source_location end)\n+\t\t     location_t start, location_t end)\n {\n   fprintf (stream,\n-\t   \"  source_location interval: %u <= loc < %u\\n\",\n+\t   \"  location_t interval: %u <= loc < %u\\n\",\n \t   start, end);\n }\n \n /* Write a labelled description of a half-closed (START) / half-open (END)\n-   interval of source_location to STREAM.  */\n+   interval of location_t to STREAM.  */\n \n static void\n dump_labelled_location_range (FILE *stream,\n \t\t\t      const char *name,\n-\t\t\t      source_location start, source_location end)\n+\t\t\t      location_t start, location_t end)\n {\n   fprintf (stream, \"%s\\n\", name);\n   dump_location_range (stream, start, end);\n@@ -1050,7 +1050,7 @@ dump_location_info (FILE *stream)\n   /* Visualize the ordinary line_map instances, rendering the sources. */\n   for (unsigned int idx = 0; idx < LINEMAPS_ORDINARY_USED (line_table); idx++)\n     {\n-      source_location end_location = get_end_location (line_table, idx);\n+      location_t end_location = get_end_location (line_table, idx);\n       /* half-closed: doesn't include this one. */\n \n       const line_map_ordinary *map\n@@ -1069,7 +1069,7 @@ dump_location_info (FILE *stream)\n \t       map->m_range_bits);\n \n       /* Render the span of source lines that this \"map\" covers.  */\n-      for (source_location loc = MAP_START_LOCATION (map);\n+      for (location_t loc = MAP_START_LOCATION (map);\n \t   loc < end_location;\n \t   loc += (1 << map->m_range_bits) )\n \t{\n@@ -1094,7 +1094,7 @@ dump_location_info (FILE *stream)\n \n \t      /* \"loc\" is at column 0, which means \"the whole line\".\n \t\t Render the locations *within* the line, by underlining\n-\t\t it, showing the source_location numeric values\n+\t\t it, showing the location_t numeric values\n \t\t at each column.  */\n \t      size_t max_col = (1 << map->m_column_and_range_bits) - 1;\n \t      if (max_col > line_text.length ())\n@@ -1128,12 +1128,12 @@ dump_location_info (FILE *stream)\n   /* Visualize the macro line_map instances, rendering the sources. */\n   for (unsigned int i = 0; i < LINEMAPS_MACRO_USED (line_table); i++)\n     {\n-      /* Each macro map that is allocated owns source_location values\n+      /* Each macro map that is allocated owns location_t values\n \t that are *lower* that the one before them.\n \t Hence it's meaningful to view them either in order of ascending\n \t source locations, or in order of ascending macro map index.  */\n-      const bool ascending_source_locations = true;\n-      unsigned int idx = (ascending_source_locations\n+      const bool ascending_location_ts = true;\n+      unsigned int idx = (ascending_location_ts\n \t\t\t  ? (LINEMAPS_MACRO_USED (line_table) - (i + 1))\n \t\t\t  : i);\n       const line_map_macro *map = LINEMAPS_MACRO_MAP_AT (line_table, idx);\n@@ -1154,8 +1154,8 @@ dump_location_info (FILE *stream)\n       fprintf (stream, \"  macro_locations:\\n\");\n       for (unsigned int i = 0; i < MACRO_MAP_NUM_MACRO_TOKENS (map); i++)\n \t{\n-\t  source_location x = MACRO_MAP_LOCATIONS (map)[2 * i];\n-\t  source_location y = MACRO_MAP_LOCATIONS (map)[(2 * i) + 1];\n+\t  location_t x = MACRO_MAP_LOCATIONS (map)[2 * i];\n+\t  location_t y = MACRO_MAP_LOCATIONS (map)[(2 * i) + 1];\n \n \t  /* linemap_add_macro_token encodes token numbers in an expansion\n \t     by putting them after MAP_START_LOCATION. */\n@@ -1166,7 +1166,7 @@ dump_location_info (FILE *stream)\n \t     adding 2 extra args for padding tokens; presumably there may\n \t     be a leading and/or trailing padding token injected,\n \t     each for 2 more location slots.\n-\t     This would explain there being up to 4 source_locations slots\n+\t     This would explain there being up to 4 location_ts slots\n \t     that may be uninitialized.  */\n \n \t  fprintf (stream, \"    %u: %u, %u\\n\",\n@@ -1191,17 +1191,17 @@ dump_location_info (FILE *stream)\n       fprintf (stream, \"\\n\");\n     }\n \n-  /* It appears that MAX_SOURCE_LOCATION itself is never assigned to a\n+  /* It appears that MAX_LOCATION_T itself is never assigned to a\n      macro map, presumably due to an off-by-one error somewhere\n      between the logic in linemap_enter_macro and\n      LINEMAPS_MACRO_LOWEST_LOCATION.  */\n-  dump_labelled_location_range (stream, \"MAX_SOURCE_LOCATION\",\n-\t\t\t\tMAX_SOURCE_LOCATION,\n-\t\t\t\tMAX_SOURCE_LOCATION + 1);\n+  dump_labelled_location_range (stream, \"MAX_LOCATION_T\",\n+\t\t\t\tMAX_LOCATION_T,\n+\t\t\t\tMAX_LOCATION_T + 1);\n \n   /* Visualize ad-hoc values.  */\n   dump_labelled_location_range (stream, \"AD-HOC LOCATIONS\",\n-\t\t\t\tMAX_SOURCE_LOCATION + 1, UINT_MAX);\n+\t\t\t\tMAX_LOCATION_T + 1, UINT_MAX);\n }\n \n /* string_concat's constructor.  */\n@@ -1473,12 +1473,12 @@ get_substring_ranges_for_loc (cpp_reader *pfile,\n    than for end-users.  */\n \n const char *\n-get_source_location_for_substring (cpp_reader *pfile,\n-\t\t\t\t   string_concat_db *concats,\n-\t\t\t\t   location_t strloc,\n-\t\t\t\t   enum cpp_ttype type,\n-\t\t\t\t   int caret_idx, int start_idx, int end_idx,\n-\t\t\t\t   source_location *out_loc)\n+get_location_within_string (cpp_reader *pfile,\n+\t\t\t    string_concat_db *concats,\n+\t\t\t    location_t strloc,\n+\t\t\t    enum cpp_ttype type,\n+\t\t\t    int caret_idx, int start_idx, int end_idx,\n+\t\t\t    location_t *out_loc)\n {\n   gcc_checking_assert (caret_idx >= 0);\n   gcc_checking_assert (start_idx >= 0);\n@@ -1638,7 +1638,7 @@ assert_loceq (const char *exp_filename, int exp_linenum, int exp_colnum,\n    - line_table->default_range_bits: some frontends use a non-zero value\n    and others use zero\n    - the fallback modes within line-map.c: there are various threshold\n-   values for source_location/location_t beyond line-map.c changes\n+   values for location_t beyond line-map.c changes\n    behavior (disabling of the range-packing optimization, disabling\n    of column-tracking).  We can exercise these by starting the line_table\n    at interesting values at or near these thresholds."}, {"sha": "1f766f3cf1f21a00a31992c3df671499ef38f195", "filename": "gcc/input.h", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -27,17 +27,17 @@ extern GTY(()) struct line_maps *line_table;\n extern GTY(()) struct line_maps *saved_line_table;\n \n /* A value which will never be used to represent a real location.  */\n-#define UNKNOWN_LOCATION ((source_location) 0)\n+#define UNKNOWN_LOCATION ((location_t) 0)\n \n /* The location for declarations in \"<built-in>\" */\n-#define BUILTINS_LOCATION ((source_location) 1)\n+#define BUILTINS_LOCATION ((location_t) 1)\n \n /* line-map.c reserves RESERVED_LOCATION_COUNT to the user.  Ensure\n    both UNKNOWN_LOCATION and BUILTINS_LOCATION fit into that.  */\n STATIC_ASSERT (BUILTINS_LOCATION < RESERVED_LOCATION_COUNT);\n \n-extern bool is_location_from_builtin_token (source_location);\n-extern expanded_location expand_location (source_location);\n+extern bool is_location_from_builtin_token (location_t);\n+extern expanded_location expand_location (location_t);\n \n /* A class capturing the bounds of a buffer, to allow for run-time\n    bounds-checking in a checked build.  */\n@@ -86,15 +86,11 @@ extern char_span location_get_source_line (const char *file_path, int line);\n \n extern bool location_missing_trailing_newline (const char *file_path);\n extern expanded_location\n-expand_location_to_spelling_point (source_location,\n+expand_location_to_spelling_point (location_t,\n \t\t\t\t   enum location_aspect aspect\n \t\t\t\t     = LOCATION_ASPECT_CARET);\n-extern source_location expansion_point_location_if_in_system_header (source_location);\n-extern source_location expansion_point_location (source_location);\n-\n-/* Historically GCC used location_t, while cpp used source_location.\n-   This could be removed but it hardly seems worth the effort.  */\n-typedef source_location location_t;\n+extern location_t expansion_point_location_if_in_system_header (location_t);\n+extern location_t expansion_point_location (location_t);\n \n extern location_t input_location;\n "}, {"sha": "8451fd500e61ac6e4d7ea100504ea63b88dd3250", "filename": "gcc/jit/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -1,3 +1,7 @@\n+2018-11-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit-playback.c: Replace \"source_location\" with \"location_t\".\n+\n 2018-10-17  David Malcolm  <dmalcolm@redhat.com>\n \n \t* Make-lang.in (selftest-jit): New."}, {"sha": "1bb0fde211edcab4e5da1c8d7b42ef352389563b", "filename": "gcc/jit/jit-playback.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fjit%2Fjit-playback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fjit%2Fjit-playback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -2827,7 +2827,7 @@ handle_locations ()\n   FOR_EACH_VEC_ELT (m_cached_locations, i, cached_location)\n     {\n       tree t = cached_location->first;\n-      source_location srcloc = cached_location->second->m_srcloc;\n+      location_t srcloc = cached_location->second->m_srcloc;\n \n       /* This covers expressions: */\n       if (CAN_HAVE_LOCATION_P (t))\n@@ -2927,7 +2927,7 @@ new_location (recording::location *rloc,\n /* Deferred setting of the location for a given tree, by adding the\n    (tree, playback::location) pair to a list of deferred associations.\n    We will actually set the location on the tree later on once\n-   the source_location for the playback::location exists.  */\n+   the location_t for the playback::location exists.  */\n \n void\n playback::context::"}, {"sha": "2dfb96e6e3431b011194e5d593ccc5039159751d", "filename": "gcc/jit/jit-playback.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fjit%2Fjit-playback.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fjit%2Fjit-playback.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.h?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -686,7 +686,7 @@ class location : public wrapper\n \n   recording::location *get_recording_loc () const { return m_recording_loc; }\n \n-  source_location m_srcloc;\n+  location_t m_srcloc;\n \n private:\n   recording::location *m_recording_loc;"}, {"sha": "2361520e60b73765c0c4ed0564b9159744d4750c", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -3333,7 +3333,7 @@ expand_omp_for_generic (struct omp_region *region,\n \t  gphi_iterator psi;\n \t  for (psi = gsi_start_phis (l3_bb); !gsi_end_p (psi); gsi_next (&psi))\n \t    {\n-\t      source_location locus;\n+\t      location_t locus;\n \t      gphi *nphi;\n \t      gphi *exit_phi = psi.phi ();\n \n@@ -4476,7 +4476,7 @@ expand_omp_for_static_chunk (struct omp_region *region,\n \t   gsi_next (&psi), ++i)\n \t{\n \t  gphi *nphi;\n-\t  source_location locus;\n+\t  location_t locus;\n \n \t  phi = psi.phi ();\n \t  if (operand_equal_p (gimple_phi_arg_def (phi, 0),"}, {"sha": "29ade6baf77e7da3b040efd394514130f30cf5a4", "filename": "gcc/selftest.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -141,7 +141,7 @@ class auto_fix_quotes\n    - line_table->default_range_bits: some frontends use a non-zero value\n    and others use zero\n    - the fallback modes within line-map.c: there are various threshold\n-   values for source_location/location_t beyond line-map.c changes\n+   values for location_t beyond line-map.c changes\n    behavior (disabling of the range-packing optimization, disabling\n    of column-tracking).  We can exercise these by starting the line_table\n    at interesting values at or near these thresholds."}, {"sha": "19047a14705a1cea521f98d94b1b640c6ed617b6", "filename": "gcc/substring-locations.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fsubstring-locations.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Fsubstring-locations.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsubstring-locations.h?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -115,12 +115,12 @@ class format_string_diagnostic_t\n /* Implementation detail, for use when implementing\n    LANG_HOOKS_GET_SUBSTRING_LOCATION.  */\n \n-extern const char *get_source_location_for_substring (cpp_reader *pfile,\n-\t\t\t\t\t\t      string_concat_db *concats,\n-\t\t\t\t\t\t      location_t strloc,\n-\t\t\t\t\t\t      enum cpp_ttype type,\n-\t\t\t\t\t\t      int caret_idx,\n-\t\t\t\t\t\t      int start_idx, int end_idx,\n-\t\t\t\t\t\t      location_t *out_loc);\n+extern const char *get_location_within_string (cpp_reader *pfile,\n+\t\t\t\t\t       string_concat_db *concats,\n+\t\t\t\t\t       location_t strloc,\n+\t\t\t\t\t       enum cpp_ttype type,\n+\t\t\t\t\t       int caret_idx,\n+\t\t\t\t\t       int start_idx, int end_idx,\n+\t\t\t\t\t       location_t *out_loc);\n \n #endif /* ! GCC_SUBSTRING_LOCATIONS_H */"}, {"sha": "9a9cd82dd3e34d28b80e6640189f88612964a24a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -1,3 +1,9 @@\n+2018-11-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* g++.dg/plugin/comment_plugin.c: Replace \"source_location\" with\n+\t\"location_t\".\n+\t* gcc.dg/plugin/diagnostic_plugin_test_show_locus.c: Likewise.\n+\n 2018-11-13  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/81824"}, {"sha": "3164385cec7b2087933833a384d47674d06a2d64", "filename": "gcc/testsuite/g++.dg/plugin/comment_plugin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fcomment_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fcomment_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fcomment_plugin.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -13,7 +13,7 @@ int plugin_is_GPL_compatible;\n /* Test callback for cpp_callbacks::comments.  */\n \n void\n-my_comment_cb (cpp_reader *, source_location loc,\n+my_comment_cb (cpp_reader *, location_t loc,\n \t       const unsigned char *content, size_t len)\n {\n   if (in_system_header_at (loc))"}, {"sha": "7cc90de802e8b38f407fc4cbb0236c679833f240", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic_plugin_test_show_locus.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_show_locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_show_locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_show_locus.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -22,7 +22,7 @@\n    hard-coded locations relative to the top of each function.\n \n    The plugin uses a function \"get_loc\" below to map from line/column\n-   numbers to source_location, and this relies on input_location being in\n+   numbers to location_t, and this relies on input_location being in\n    the same ordinary line_map as the locations in question.  The plugin\n    runs after parsing, so input_location will be at the end of the file.\n \n@@ -90,7 +90,7 @@ class pass_test_show_locus : public gimple_opt_pass\n \n }; // class pass_test_show_locus\n \n-/* Given LINE_NUM and COL_NUM, generate a source_location in the\n+/* Given LINE_NUM and COL_NUM, generate a location_t in the\n    current file, relative to input_location.  This relies on the\n    location being expressible in the same ordinary line_map as\n    input_location (which is typically at the end of the source file\n@@ -100,7 +100,7 @@ class pass_test_show_locus : public gimple_opt_pass\n \n    COL_NUM uses the Emacs convention of 0-based column numbers.  */\n \n-static source_location\n+static location_t\n get_loc (unsigned int line_num, unsigned int col_num)\n {\n   /* Use input_location to get the relevant line_map */\n@@ -109,7 +109,7 @@ get_loc (unsigned int line_num, unsigned int col_num)\n \t\t\t\t\t\t  input_location));\n \n   /* Convert from 0-based column numbers to 1-based column numbers.  */\n-  source_location loc\n+  location_t loc\n     = linemap_position_for_line_and_column (line_table,\n \t\t\t\t\t    line_map,\n \t\t\t\t\t    line_num, col_num + 1);"}, {"sha": "582cf18ad0dc34fe0ddcf43b0b30104e8262a12d", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -9212,7 +9212,7 @@ class pass_warn_function_return : public gimple_opt_pass\n unsigned int\n pass_warn_function_return::execute (function *fun)\n {\n-  source_location location;\n+  location_t location;\n   gimple *last;\n   edge e;\n   edge_iterator ei;"}, {"sha": "3c82b11e8d8329bf252ebc8c920f51a6a7a7a6f1", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -529,7 +529,7 @@ remove_forwarder_block (basic_block bb)\n \t       gsi_next (&psi))\n \t    {\n \t      gphi *phi = psi.phi ();\n-\t      source_location l = gimple_phi_arg_location_from_edge (phi, succ);\n+\t      location_t l = gimple_phi_arg_location_from_edge (phi, succ);\n \t      tree def = gimple_phi_arg_def (phi, succ->dest_idx);\n \t      add_phi_arg (phi, unshare_expr (def), s, l);\n \t    }\n@@ -1082,7 +1082,7 @@ remove_forwarder_block_with_phi (basic_block bb)\n \t{\n \t  gphi *phi = gsi.phi ();\n \t  tree def = gimple_phi_arg_def (phi, succ->dest_idx);\n-\t  source_location locus = gimple_phi_arg_location_from_edge (phi, succ);\n+\t  location_t locus = gimple_phi_arg_location_from_edge (phi, succ);\n \n \t  if (TREE_CODE (def) == SSA_NAME)\n \t    {"}, {"sha": "01eed713df6d26af5d78ee2d6aeb0b2cf59dea70", "filename": "gcc/tree-diagnostic.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-diagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-diagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-diagnostic.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -56,7 +56,7 @@ default_tree_diagnostic_starter (diagnostic_context *context,\n struct loc_map_pair\n {\n   const line_map_macro *map;\n-  source_location where;\n+  location_t where;\n };\n \n \n@@ -99,7 +99,7 @@ struct loc_map_pair\n static void\n maybe_unwind_expanded_macro_loc (diagnostic_context *context,\n                                  const diagnostic_info *diagnostic,\n-                                 source_location where)\n+                                 location_t where)\n {\n   const struct line_map *map;\n   auto_vec<loc_map_pair> loc_vec;\n@@ -178,14 +178,14 @@ maybe_unwind_expanded_macro_loc (diagnostic_context *context,\n \n         /* Resolve the location iter->where into the locus 1/ of the\n            comment above.  */\n-        source_location resolved_def_loc =\n+        location_t resolved_def_loc =\n           linemap_resolve_location (line_table, iter->where,\n                                     LRK_MACRO_DEFINITION_LOCATION, NULL);\n \n \t/* Don't print trace for locations that are reserved or from\n \t   within a system header.  */\n         const line_map_ordinary *m = NULL;\n-        source_location l = \n+        location_t l = \n           linemap_resolve_location (line_table, resolved_def_loc,\n                                     LRK_SPELLING_LOCATION,  &m);\n         if (l < RESERVED_LOCATION_COUNT || LINEMAP_SYSP (m))\n@@ -210,7 +210,7 @@ maybe_unwind_expanded_macro_loc (diagnostic_context *context,\n         /* Resolve the location of the expansion point of the macro\n            which expansion gave the token represented by def_loc.\n            This is the locus 2/ of the earlier comment.  */\n-        source_location resolved_exp_loc =\n+        location_t resolved_exp_loc =\n           linemap_resolve_location (line_table,\n                                     MACRO_MAP_EXPANSION_POINT_LOCATION (iter->map),\n                                     LRK_MACRO_DEFINITION_LOCATION, NULL);"}, {"sha": "79259b69a2686929d76e24610cdc74bd886f671b", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -2119,7 +2119,7 @@ rewrite_update_phi_arguments (basic_block bb)\n           /* Update the argument if there is a reaching def.  */\n \t  if (reaching_def)\n \t    {\n-\t      source_location locus;\n+\t      location_t locus;\n \t      int arg_i = PHI_ARG_INDEX_FROM_USE (arg_p);\n \n \t      SET_USE (arg_p, reaching_def);"}, {"sha": "5d8f9a1938f6ed96bf7af78233cc579fc9dbe7de", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -143,7 +143,7 @@ struct elim_graph\n   auto_vec<int> edge_list;\n \n   /* Source locus on each edge */\n-  auto_vec<source_location> edge_locus;\n+  auto_vec<location_t> edge_locus;\n \n   /* Visited vector.  */\n   auto_sbitmap visited;\n@@ -162,7 +162,7 @@ struct elim_graph\n   auto_vec<tree> const_copies;\n \n   /* Source locations for any constant copies.  */\n-  auto_vec<source_location> copy_locus;\n+  auto_vec<location_t> copy_locus;\n };\n \n \n@@ -238,7 +238,7 @@ emit_partition_copy (rtx dest, rtx src, int unsignedsrcp, tree sizeexp)\n /* Insert a copy instruction from partition SRC to DEST onto edge E.  */\n \n static void\n-insert_partition_copy_on_edge (edge e, int dest, int src, source_location locus)\n+insert_partition_copy_on_edge (edge e, int dest, int src, location_t locus)\n {\n   tree var;\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -272,7 +272,7 @@ insert_partition_copy_on_edge (edge e, int dest, int src, source_location locus)\n    onto edge E.  */\n \n static void\n-insert_value_copy_on_edge (edge e, int dest, tree src, source_location locus)\n+insert_value_copy_on_edge (edge e, int dest, tree src, location_t locus)\n {\n   rtx dest_rtx, seq, x;\n   machine_mode dest_mode, src_mode;\n@@ -333,7 +333,7 @@ insert_value_copy_on_edge (edge e, int dest, tree src, source_location locus)\n \n static void\n insert_rtx_to_part_on_edge (edge e, int dest, rtx src, int unsignedsrcp,\n-\t\t\t    source_location locus)\n+\t\t\t    location_t locus)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -367,7 +367,7 @@ insert_rtx_to_part_on_edge (edge e, int dest, rtx src, int unsignedsrcp,\n    onto edge E.  */\n \n static void\n-insert_part_to_rtx_on_edge (edge e, rtx dest, int src, source_location locus)\n+insert_part_to_rtx_on_edge (edge e, rtx dest, int src, location_t locus)\n {\n   tree var;\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -444,7 +444,7 @@ elim_graph_add_node (elim_graph *g, int node)\n /* Add the edge PRED->SUCC to graph G.  */\n \n static inline void\n-elim_graph_add_edge (elim_graph *g, int pred, int succ, source_location locus)\n+elim_graph_add_edge (elim_graph *g, int pred, int succ, location_t locus)\n {\n   g->edge_list.safe_push (pred);\n   g->edge_list.safe_push (succ);\n@@ -456,7 +456,7 @@ elim_graph_add_edge (elim_graph *g, int pred, int succ, source_location locus)\n    return the successor node.  -1 is returned if there is no such edge.  */\n \n static inline int\n-elim_graph_remove_succ_edge (elim_graph *g, int node, source_location *locus)\n+elim_graph_remove_succ_edge (elim_graph *g, int node, location_t *locus)\n {\n   int y;\n   unsigned x;\n@@ -556,7 +556,7 @@ eliminate_build (elim_graph *g)\n   for (gsi = gsi_start_phis (g->e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gphi *phi = gsi.phi ();\n-      source_location locus;\n+      location_t locus;\n \n       p0 = var_to_partition (g->map, gimple_phi_result (phi));\n       /* Ignore results which are not in partitions.  */\n@@ -597,7 +597,7 @@ static void\n elim_forward (elim_graph *g, int T)\n {\n   int S;\n-  source_location locus;\n+  location_t locus;\n \n   bitmap_set_bit (g->visited, T);\n   FOR_EACH_ELIM_GRAPH_SUCC (g, T, S, locus,\n@@ -615,7 +615,7 @@ static int\n elim_unvisited_predecessor (elim_graph *g, int T)\n {\n   int P;\n-  source_location locus;\n+  location_t locus;\n \n   FOR_EACH_ELIM_GRAPH_PRED (g, T, P, locus,\n     {\n@@ -631,7 +631,7 @@ static void\n elim_backward (elim_graph *g, int T)\n {\n   int P;\n-  source_location locus;\n+  location_t locus;\n \n   bitmap_set_bit (g->visited, T);\n   FOR_EACH_ELIM_GRAPH_PRED (g, T, P, locus,\n@@ -666,7 +666,7 @@ static void\n elim_create (elim_graph *g, int T)\n {\n   int P, S;\n-  source_location locus;\n+  location_t locus;\n \n   if (elim_unvisited_predecessor (g, T))\n     {\n@@ -741,7 +741,7 @@ eliminate_phi (edge e, elim_graph *g)\n     {\n       int dest;\n       tree src;\n-      source_location locus;\n+      location_t locus;\n \n       src = g->const_copies.pop ();\n       dest = g->const_dests.pop ();"}, {"sha": "81d7742e7a76b84711940df14183c9c443b79de4", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -1041,7 +1041,7 @@ create_phi_for_local_result (reduction_info **slot, struct loop *loop)\n   gphi *new_phi;\n   basic_block store_bb, continue_bb;\n   tree local_res;\n-  source_location locus;\n+  location_t locus;\n \n   /* STORE_BB is the block where the phi\n      should be stored.  It is the destination of the loop exit.\n@@ -2131,7 +2131,7 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n   for (gphi_iterator gpi = gsi_start_phis (ex_bb);\n        !gsi_end_p (gpi); gsi_next (&gpi))\n     {\n-      source_location locus;\n+      location_t locus;\n       gphi *phi = gpi.phi ();\n       tree def = PHI_ARG_DEF_FROM_EDGE (phi, exit);\n       gimple *def_stmt = SSA_NAME_DEF_STMT (def);"}, {"sha": "16dcf67e2f07e03fa2993cf126a6bd9824ca1cbf", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -351,7 +351,7 @@ create_phi_node (tree var, basic_block bb)\n    PHI points to the reallocated phi node when we return.  */\n \n void\n-add_phi_arg (gphi *phi, tree def, edge e, source_location locus)\n+add_phi_arg (gphi *phi, tree def, edge e, location_t locus)\n {\n   basic_block bb = e->dest;\n "}, {"sha": "8a06870fb4578e43e0c030d9183403a484f1779d", "filename": "gcc/tree-phinodes.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-phinodes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-phinodes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.h?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -24,7 +24,7 @@ extern void phinodes_print_statistics (void);\n extern void reserve_phi_args_for_new_edge (basic_block);\n extern void add_phi_node_to_bb (gphi *phi, basic_block bb);\n extern gphi *create_phi_node (tree, basic_block);\n-extern void add_phi_arg (gphi *, tree, edge, source_location);\n+extern void add_phi_arg (gphi *, tree, edge, location_t);\n extern void remove_phi_args (edge);\n extern void remove_phi_node (gimple_stmt_iterator *, bool);\n extern void remove_phi_nodes (basic_block);"}, {"sha": "6f56f5aa7f556fa3a5189c359d95e79b13eb2a87", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -543,7 +543,7 @@ struct ivopts_data\n {\n   /* The currently optimized loop.  */\n   struct loop *current_loop;\n-  source_location loop_loc;\n+  location_t loop_loc;\n \n   /* Numbers of iterations for all exits of the current loop.  */\n   hash_map<edge, tree_niter_desc *> *niters;"}, {"sha": "c05738c24e089c69a00a5472525cbd637ac3bf2a", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -786,7 +786,7 @@ split_loop_exit_edge (edge exit, bool copy_constants_p)\n   tree new_name, name;\n   use_operand_p op_p;\n   gphi_iterator psi;\n-  source_location locus;\n+  location_t locus;\n \n   for (psi = gsi_start_phis (dest); !gsi_end_p (psi); gsi_next (&psi))\n     {"}, {"sha": "e185e9c270f284ae8c0114e6934c9b478d89a39f", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -423,7 +423,7 @@ factor_out_conditional_conversion (edge e0, edge e1, gphi *phi,\n   tree temp, result;\n   gphi *newphi;\n   gimple_stmt_iterator gsi, gsi_for_def;\n-  source_location locus = gimple_location (phi);\n+  location_t locus = gimple_location (phi);\n   enum tree_code convert_code;\n \n   /* Handle only PHI statements with two arguments.  TODO: If all\n@@ -669,7 +669,7 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n \n   if (!useless_type_conversion_p (TREE_TYPE (result), TREE_TYPE (new_var)))\n     {\n-      source_location locus_0, locus_1;\n+      location_t locus_0, locus_1;\n \n       new_var2 = make_ssa_name (TREE_TYPE (result));\n       new_stmt = gimple_build_assign (new_var2, CONVERT_EXPR, new_var);\n@@ -2049,7 +2049,7 @@ cond_store_replacement (basic_block middle_bb, basic_block join_bb,\n   gphi *newphi;\n   gassign *new_stmt;\n   gimple_stmt_iterator gsi;\n-  source_location locus;\n+  location_t locus;\n \n   /* Check if middle_bb contains of only one store.  */\n   if (!assign\n@@ -2133,7 +2133,7 @@ cond_if_else_store_replacement_1 (basic_block then_bb, basic_block else_bb,\n \t\t\t\t  gimple *else_assign)\n {\n   tree lhs_base, lhs, then_rhs, else_rhs, name;\n-  source_location then_locus, else_locus;\n+  location_t then_locus, else_locus;\n   gimple_stmt_iterator gsi;\n   gphi *newphi;\n   gassign *new_stmt;"}, {"sha": "2869b602e052b679b20c3e1644db4880c9b4f516", "filename": "gcc/tree-ssa-phiprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-ssa-phiprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-ssa-phiprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiprop.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -159,7 +159,7 @@ phiprop_insert_phi (basic_block bb, gphi *phi, gimple *use_stmt,\n     {\n       tree old_arg, new_var;\n       gassign *tmp;\n-      source_location locus;\n+      location_t locus;\n \n       old_arg = PHI_ARG_DEF_FROM_EDGE (phi, e);\n       locus = gimple_phi_arg_location_from_edge (phi, e);"}, {"sha": "6630516b99a10f0a087958f33c9b12278c0632b2", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -431,7 +431,7 @@ copy_phi_arg_into_existing_phi (edge src_e, edge tgt_e)\n       gphi *src_phi = gsi.phi ();\n       gphi *dest_phi = gsi2.phi ();\n       tree val = gimple_phi_arg_def (src_phi, src_idx);\n-      source_location locus = gimple_phi_arg_location (src_phi, src_idx);\n+      location_t locus = gimple_phi_arg_location (src_phi, src_idx);\n \n       SET_PHI_ARG_DEF (dest_phi, tgt_idx, val);\n       gimple_phi_arg_set_location (dest_phi, tgt_idx, locus);\n@@ -445,7 +445,7 @@ copy_phi_arg_into_existing_phi (edge src_e, edge tgt_e)\n \n static tree\n get_value_locus_in_path (tree def, vec<jump_thread_edge *> *path,\n-\t\t\t basic_block bb, int idx, source_location *locus)\n+\t\t\t basic_block bb, int idx, location_t *locus)\n {\n   tree arg;\n   gphi *def_phi;\n@@ -499,7 +499,7 @@ copy_phi_args (basic_block bb, edge src_e, edge tgt_e,\n     {\n       gphi *phi = gsi.phi ();\n       tree def = gimple_phi_arg_def (phi, src_indx);\n-      source_location locus = gimple_phi_arg_location (phi, src_indx);\n+      location_t locus = gimple_phi_arg_location (phi, src_indx);\n \n       if (TREE_CODE (def) == SSA_NAME\n \t  && !virtual_operand_p (gimple_phi_result (phi)))"}, {"sha": "bd8b91f8b4b1d6f43edde19e5f40d61c7c51a6c7", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -52,7 +52,7 @@ static hash_map<edge, auto_vec<edge_var_map> > *edge_var_maps;\n /* Add a mapping with PHI RESULT and PHI DEF associated with edge E.  */\n \n void\n-redirect_edge_var_map_add (edge e, tree result, tree def, source_location locus)\n+redirect_edge_var_map_add (edge e, tree result, tree def, location_t locus)\n {\n   edge_var_map new_node;\n \n@@ -151,7 +151,7 @@ ssa_redirect_edge (edge e, basic_block dest)\n     for (gsi = gsi_start_phis (e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n \ttree def;\n-\tsource_location locus ;\n+\tlocation_t locus;\n \n \tphi = gsi.phi ();\n \tdef = gimple_phi_arg_def (phi, e->dest_idx);"}, {"sha": "b2d676fe3eb355d2260244b10e6026d9995d9641", "filename": "gcc/tree-ssa.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.h?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -24,14 +24,14 @@ along with GCC; see the file COPYING3.  If not see\n struct edge_var_map {\n   tree result;\t\t\t/* PHI result.  */\n   tree def;\t\t\t/* PHI arg definition.  */\n-  source_location locus;        /* PHI arg location.  */\n+  location_t locus;        /* PHI arg location.  */\n };\n \n /* A vector of var maps.  */\n typedef vec<edge_var_map, va_heap, vl_embed> edge_var_map_vector;\n \n \n-extern void redirect_edge_var_map_add (edge, tree, tree, source_location);\n+extern void redirect_edge_var_map_add (edge, tree, tree, location_t);\n extern void redirect_edge_var_map_clear (edge);\n extern void redirect_edge_var_map_dup (edge, edge);\n extern vec<edge_var_map> *redirect_edge_var_map_vector (edge);\n@@ -74,7 +74,7 @@ redirect_edge_var_map_result (edge_var_map *v)\n \n /* Given an edge_var_map V, return the PHI arg location.  */\n \n-static inline source_location\n+static inline location_t\n redirect_edge_var_map_location (edge_var_map *v)\n {\n   return v->locus;"}, {"sha": "efaa22fc2d7a23a4e44d7b2ae24e27683f59ee56", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -2172,7 +2172,7 @@ slpeel_update_phi_nodes_for_guard1 (struct loop *skip_loop,\n \t\t\t\t    struct loop *update_loop,\n \t\t\t\t    edge guard_edge, edge merge_edge)\n {\n-  source_location merge_loc, guard_loc;\n+  location_t merge_loc, guard_loc;\n   edge orig_e = loop_preheader_edge (skip_loop);\n   edge update_e = loop_preheader_edge (update_loop);\n   gphi_iterator gsi_orig, gsi_update;"}, {"sha": "f48ba14f9dc8701b869e8fbbbb866f5065ce7ceb", "filename": "libcc1/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/libcc1%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/libcc1%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2FChangeLog?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -1,3 +1,10 @@\n+2018-11-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* libcc1plugin.cc: Replace \"source_location\" with \"location_t\".\n+\t(plugin_context::get_source_location): Rename to...\n+\t(plugin_context::get_location_t): ...this.\n+\t* libcp1plugin.cc: Likewise.\n+\n 2018-10-31  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR bootstrap/82856"}, {"sha": "f759c79844b66c97fc6d65787fb4538ad0bfc766", "filename": "libcc1/libcc1plugin.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/libcc1%2Flibcc1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/libcc1%2Flibcc1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcc1plugin.cc?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -187,15 +187,15 @@ struct plugin_context : public cc1_plugin::connection\n     return t;\n   }\n \n-  source_location get_source_location (const char *filename,\n-\t\t\t\t       unsigned int line_number)\n+  location_t get_location_t (const char *filename,\n+\t\t\t     unsigned int line_number)\n   {\n     if (filename == NULL)\n       return UNKNOWN_LOCATION;\n \n     filename = intern_filename (filename);\n     linemap_add (line_table, LC_ENTER, false, filename, line_number);\n-    source_location loc = linemap_line_start (line_table, line_number, 0);\n+    location_t loc = linemap_line_start (line_table, line_number, 0);\n     linemap_add (line_table, LC_LEAVE, false, NULL, 0);\n     return loc;\n   }\n@@ -397,7 +397,7 @@ plugin_build_decl (cc1_plugin::connection *self,\n       abort ();\n     }\n \n-  source_location loc = ctx->get_source_location (filename, line_number);\n+  location_t loc = ctx->get_location_t (filename, line_number);\n \n   decl = build_decl (loc, code, identifier, sym_type);\n   TREE_USED (decl) = 1;\n@@ -448,7 +448,7 @@ plugin_tagbind (cc1_plugin::connection *self,\n {\n   plugin_context *ctx = static_cast<plugin_context *> (self);\n   tree t = convert_in (tagged_type), x;\n-  c_pushtag (ctx->get_source_location (filename, line_number),\n+  c_pushtag (ctx->get_location_t (filename, line_number),\n \t     get_identifier (name), t);\n \n   /* Propagate the newly-added type name so that previously-created\n@@ -884,7 +884,7 @@ plugin_build_constant (cc1_plugin::connection *self, gcc_type type_in,\n   tree type = convert_in (type_in);\n \n   cst = build_int_cst (type, value);\n-  decl = build_decl (ctx->get_source_location (filename, line_number),\n+  decl = build_decl (ctx->get_location_t (filename, line_number),\n \t\t     CONST_DECL, get_identifier (name), type);\n   DECL_INITIAL (decl) = cst;\n   pushdecl_safe (decl);"}, {"sha": "f8ed90b835f5ef6bef72e6e9b9c8acf93a21a2ce", "filename": "libcc1/libcp1plugin.cc", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/libcc1%2Flibcp1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/libcc1%2Flibcp1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1plugin.cc?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -178,15 +178,15 @@ struct plugin_context : public cc1_plugin::connection\n     return t;\n   }\n \n-  source_location get_source_location (const char *filename,\n-\t\t\t\t       unsigned int line_number)\n+  location_t get_location_t (const char *filename,\n+\t\t\t     unsigned int line_number)\n   {\n     if (filename == NULL)\n       return UNKNOWN_LOCATION;\n \n     filename = intern_filename (filename);\n     linemap_add (line_table, LC_ENTER, false, filename, line_number);\n-    source_location loc = linemap_line_start (line_table, line_number, 0);\n+    location_t loc = linemap_line_start (line_table, line_number, 0);\n     linemap_add (line_table, LC_LEAVE, false, NULL, 0);\n     return loc;\n   }\n@@ -1028,7 +1028,7 @@ plugin_add_using_decl (cc1_plugin::connection *,\n static tree\n build_named_class_type (enum tree_code code,\n \t\t\ttree id,\n-\t\t\tsource_location loc)\n+\t\t\tlocation_t loc)\n {\n   /* See at_fake_function_scope_p.  */\n   gcc_assert (!at_function_scope_p ());\n@@ -1114,7 +1114,7 @@ plugin_build_decl (cc1_plugin::connection *self,\n       gcc_assert (!substitution_name);\n     }\n \n-  source_location loc = ctx->get_source_location (filename, line_number);\n+  location_t loc = ctx->get_location_t (filename, line_number);\n   bool class_member_p = at_class_scope_p ();\n   bool ctor = false, dtor = false, assop = false;\n   tree_code opcode = ERROR_MARK;\n@@ -1742,7 +1742,7 @@ plugin_start_class_type (cc1_plugin::connection *self,\n \t\t\t unsigned int line_number)\n {\n   plugin_context *ctx = static_cast<plugin_context *> (self);\n-  source_location loc = ctx->get_source_location (filename, line_number);\n+  location_t loc = ctx->get_location_t (filename, line_number);\n   tree typedecl = convert_in (typedecl_in);\n   tree type = TREE_TYPE (typedecl);\n \n@@ -1802,8 +1802,8 @@ plugin_start_closure_class_type (cc1_plugin::connection *self,\n \n   tree lambda_expr = build_lambda_expr ();\n \n-  LAMBDA_EXPR_LOCATION (lambda_expr) = ctx->get_source_location (filename,\n-\t\t\t\t\t\t\t\t line_number);\n+  LAMBDA_EXPR_LOCATION (lambda_expr) = ctx->get_location_t (filename,\n+\t\t\t\t\t\t\t    line_number);\n \n   tree type = begin_lambda_type (lambda_expr);\n \n@@ -1936,7 +1936,7 @@ plugin_start_enum_type (cc1_plugin::connection *self,\n \n   gcc_assert (is_new_type);\n \n-  source_location loc = ctx->get_source_location (filename, line_number);\n+  location_t loc = ctx->get_location_t (filename, line_number);\n   tree type_decl = TYPE_NAME (type);\n   DECL_SOURCE_LOCATION (type_decl) = loc;\n   SET_OPAQUE_ENUM_P (type, false);\n@@ -2244,7 +2244,7 @@ plugin_build_type_template_parameter (cc1_plugin::connection *self,\n \t\t\t\t      unsigned int line_number)\n {\n   plugin_context *ctx = static_cast<plugin_context *> (self);\n-  source_location loc = ctx->get_source_location (filename, line_number);\n+  location_t loc = ctx->get_location_t (filename, line_number);\n \n   gcc_assert (template_parm_scope_p ());\n \n@@ -2274,7 +2274,7 @@ plugin_build_template_template_parameter (cc1_plugin::connection *self,\n \t\t\t\t\t  unsigned int line_number)\n {\n   plugin_context *ctx = static_cast<plugin_context *> (self);\n-  source_location loc = ctx->get_source_location (filename, line_number);\n+  location_t loc = ctx->get_location_t (filename, line_number);\n \n   gcc_assert (template_parm_scope_p ());\n \n@@ -2309,7 +2309,7 @@ plugin_build_value_template_parameter (cc1_plugin::connection *self,\n \t\t\t\t       unsigned int line_number)\n {\n   plugin_context *ctx = static_cast<plugin_context *> (self);\n-  source_location loc = ctx->get_source_location (filename, line_number);\n+  location_t loc = ctx->get_location_t (filename, line_number);\n \n   gcc_assert (template_parm_scope_p ());\n \n@@ -3354,7 +3354,7 @@ plugin_build_function_template_specialization (cc1_plugin::connection *self,\n \t\t\t\t\t       unsigned int line_number)\n {\n   plugin_context *ctx = static_cast<plugin_context *> (self);\n-  source_location loc = ctx->get_source_location (filename, line_number);\n+  location_t loc = ctx->get_location_t (filename, line_number);\n   tree name = convert_in (template_decl);\n   tree targsl = targlist (targs);\n \n@@ -3374,7 +3374,7 @@ plugin_build_class_template_specialization (cc1_plugin::connection *self,\n \t\t\t\t\t    unsigned int line_number)\n {\n   plugin_context *ctx = static_cast<plugin_context *> (self);\n-  source_location loc = ctx->get_source_location (filename, line_number);\n+  location_t loc = ctx->get_location_t (filename, line_number);\n   tree name = convert_in (template_decl);\n \n   tree tdecl = finish_template_type (name, targlist (args), false);;\n@@ -3601,7 +3601,7 @@ plugin_build_constant (cc1_plugin::connection *self, gcc_type type_in,\n   cst = build_int_cst (type, value);\n   if (!TYPE_READONLY (type))\n     type = build_qualified_type (type, TYPE_QUAL_CONST);\n-  decl = build_decl (ctx->get_source_location (filename, line_number),\n+  decl = build_decl (ctx->get_location_t (filename, line_number),\n \t\t     VAR_DECL, get_identifier (name), type);\n   TREE_STATIC (decl) = 1;\n   TREE_READONLY (decl) = 1;\n@@ -3637,7 +3637,7 @@ plugin_add_static_assert (cc1_plugin::connection *self,\n   TREE_TYPE (message) = char_array_type_node;\n   fix_string_type (message);\n \n-  source_location loc = ctx->get_source_location (filename, line_number);\n+  location_t loc = ctx->get_location_t (filename, line_number);\n \n   bool member_p = at_class_scope_p ();\n "}, {"sha": "575f18e5e0cb6b90e69b3bbeb9900457bf101b47", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -1,3 +1,23 @@\n+2018-11-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* charset.c: Replace \"source_location\" with \"location_t\".\n+\t* directives-only.c: Likewise.\n+\t* directives.c: Likewise.\n+\t* errors.c: Likewise.\n+\t* expr.c: Likewise.\n+\t* files.c: Likewise.\n+\t* include/cpplib.h: Likewise.  Rename MAX_SOURCE_LOCATION to\n+\tMAX_LOCATION_T.\n+\t* include/line-map.h: Likewise.\n+\t* init.c: Likewise.\n+\t* internal.h: Likewise.\n+\t* lex.c: Likewise.\n+\t* line-map.c: Likewise.\n+\t* location-example.txt: Likewise.\n+\t* macro.c: Likewise.\n+\t* pch.c: Likewise.\n+\t* traditional.c: Likewise.\n+\n 2018-11-07  Hafiz Abid Qadeer  <abidh@codesourcery.com>\n \n         * configure: Regenerated."}, {"sha": "9f2620cef454e33381d89c260162ffc7c8e0fe17", "filename": "libcpp/charset.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Fcharset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Fcharset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fcharset.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -2135,7 +2135,7 @@ _cpp_default_encoding (void)\n /* Constructor for cpp_string_location_reader.  */\n \n cpp_string_location_reader::\n-cpp_string_location_reader (source_location src_loc,\n+cpp_string_location_reader (location_t src_loc,\n \t\t\t    line_maps *line_table)\n : m_line_table (line_table)\n {"}, {"sha": "c2bcd9fc5ef1fbeb52e542220d85052b08dca323", "filename": "libcpp/directives-only.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Fdirectives-only.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Fdirectives-only.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives-only.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -43,7 +43,7 @@ _cpp_preprocess_dir_only (cpp_reader *pfile,\n   unsigned flags;\n   linenum_type lines;\n   int col;\n-  source_location loc;\n+  location_t loc;\n \n  restart:\n   /* Buffer initialization ala _cpp_clean_line(). */"}, {"sha": "7a8db572c3f1d27f7e6396452dcd3b294ae2f8cd", "filename": "libcpp/directives.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -30,7 +30,7 @@ along with this program; see the file COPYING3.  If not see\n struct if_stack\n {\n   struct if_stack *next;\n-  source_location line;\t\t/* Line where condition started.  */\n+  location_t line;\t\t/* Line where condition started.  */\n   const cpp_hashnode *mi_cmacro;/* macro name for #ifndef around entire file */\n   bool skip_elses;\t\t/* Can future #else / #elif be skipped?  */\n   bool was_skipping;\t\t/* If were skipping on entry.  */\n@@ -98,7 +98,7 @@ static void directive_diagnostics (cpp_reader *, const directive *, int);\n static void run_directive (cpp_reader *, int, const char *, size_t);\n static char *glue_header_name (cpp_reader *);\n static const char *parse_include (cpp_reader *, int *, const cpp_token ***,\n-\t\t\t\t  source_location *);\n+\t\t\t\t  location_t *);\n static void push_conditional (cpp_reader *, int, int, const cpp_hashnode *);\n static unsigned int read_flag (cpp_reader *, unsigned int);\n static bool strtolinenum (const uchar *, size_t, linenum_type *, bool *);\n@@ -124,8 +124,8 @@ static void do_linemarker (cpp_reader *);\n static const cpp_token *get_token_no_padding (cpp_reader *);\n static const cpp_token *get__Pragma_string (cpp_reader *);\n static void destringize_and_run (cpp_reader *, const cpp_string *,\n-\t\t\t\t source_location);\n-static bool parse_answer (cpp_reader *, int, source_location, cpp_macro **);\n+\t\t\t\t location_t);\n+static bool parse_answer (cpp_reader *, int, location_t, cpp_macro **);\n static cpp_hashnode *parse_assertion (cpp_reader *, int, cpp_macro **);\n static cpp_macro **find_answer (cpp_hashnode *, const cpp_macro *);\n static void handle_assertion (cpp_reader *, const char *, int);\n@@ -756,7 +756,7 @@ glue_header_name (cpp_reader *pfile)\n \n static const char *\n parse_include (cpp_reader *pfile, int *pangle_brackets,\n-\t       const cpp_token ***buf, source_location *location)\n+\t       const cpp_token ***buf, location_t *location)\n {\n   char *fname;\n   const cpp_token *header;\n@@ -814,7 +814,7 @@ do_include_common (cpp_reader *pfile, enum include_type type)\n   const char *fname;\n   int angle_brackets;\n   const cpp_token **buf = NULL;\n-  source_location location;\n+  location_t location;\n \n   /* Re-enable saving of comments if requested, so that the include\n      callback can dump comments which follow #include.  */\n@@ -1093,7 +1093,7 @@ do_linemarker (cpp_reader *pfile)\n     }\n   /* Compensate for the increment in linemap_add that occurs in\n      _cpp_do_file_change.  We're currently at the start of the line\n-     *following* the #line directive.  A separate source_location for this\n+     *following* the #line directive.  A separate location_t for this\n      location makes no sense (until we do the LC_LEAVE), and\n      complicates LAST_SOURCE_LINE_LOCATION.  */\n   pfile->line_table->highest_location--;\n@@ -1135,7 +1135,7 @@ do_diagnostic (cpp_reader *pfile, enum cpp_diagnostic_level code,\n {\n   const unsigned char *dir_name;\n   unsigned char *line;\n-  source_location src_loc = pfile->cur_token[-1].src_loc;\n+  location_t src_loc = pfile->cur_token[-1].src_loc;\n \n   if (print_dir)\n     dir_name = pfile->directive->name;\n@@ -1432,7 +1432,7 @@ do_pragma (cpp_reader *pfile)\n {\n   const struct pragma_entry *p = NULL;\n   const cpp_token *token, *pragma_token;\n-  source_location pragma_token_virt_loc = 0;\n+  location_t pragma_token_virt_loc = 0;\n   cpp_token ns_token;\n   unsigned int count = 1;\n \n@@ -1538,7 +1538,7 @@ do_pragma_push_macro (cpp_reader *pfile)\n   txt = get__Pragma_string (pfile);\n   if (!txt)\n     {\n-      source_location src_loc = pfile->cur_token[-1].src_loc;\n+      location_t src_loc = pfile->cur_token[-1].src_loc;\n       cpp_error_with_line (pfile, CPP_DL_ERROR, src_loc, 0,\n \t\t \"invalid #pragma push_macro directive\");\n       check_eol (pfile, false);\n@@ -1593,7 +1593,7 @@ do_pragma_pop_macro (cpp_reader *pfile)\n   txt = get__Pragma_string (pfile);\n   if (!txt)\n     {\n-      source_location src_loc = pfile->cur_token[-1].src_loc;\n+      location_t src_loc = pfile->cur_token[-1].src_loc;\n       cpp_error_with_line (pfile, CPP_DL_ERROR, src_loc, 0,\n \t\t \"invalid #pragma pop_macro directive\");\n       check_eol (pfile, false);\n@@ -1695,7 +1695,7 @@ do_pragma_dependency (cpp_reader *pfile)\n {\n   const char *fname;\n   int angle_brackets, ordering;\n-  source_location location;\n+  location_t location;\n \n   fname = parse_include (pfile, &angle_brackets, NULL, &location);\n   if (!fname)\n@@ -1801,7 +1801,7 @@ get__Pragma_string (cpp_reader *pfile)\n    \\\" and \\\\ sequences, and process the result as a #pragma directive.  */\n static void\n destringize_and_run (cpp_reader *pfile, const cpp_string *in,\n-\t\t     source_location expansion_loc)\n+\t\t     location_t expansion_loc)\n {\n   const unsigned char *src, *limit;\n   char *dest, *result;\n@@ -1921,7 +1921,7 @@ destringize_and_run (cpp_reader *pfile, const cpp_string *in,\n \n /* Handle the _Pragma operator.  Return 0 on error, 1 if ok.  */\n int\n-_cpp_do__Pragma (cpp_reader *pfile, source_location expansion_loc)\n+_cpp_do__Pragma (cpp_reader *pfile, location_t expansion_loc)\n {\n   const cpp_token *string = get__Pragma_string (pfile);\n   pfile->directive_result.type = CPP_PADDING;\n@@ -2142,7 +2142,7 @@ push_conditional (cpp_reader *pfile, int skip, int type,\n    ANSWERP to point to the answer.  PRED_LOC is the location of the\n    predicate.  */\n static bool\n-parse_answer (cpp_reader *pfile, int type, source_location pred_loc,\n+parse_answer (cpp_reader *pfile, int type, location_t pred_loc,\n \t      cpp_macro **answer_ptr)\n {\n   /* In a conditional, it is legal to not have an open paren.  We"}, {"sha": "6746428ecf36424ffd307835f9a14a46e70e4a8d", "filename": "libcpp/errors.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Ferrors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Ferrors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ferrors.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -52,7 +52,7 @@ cpp_diagnostic (cpp_reader * pfile, enum cpp_diagnostic_level level,\n \t\tenum cpp_warning_reason reason,\n \t\tconst char *msgid, va_list *ap)\n {\n-  source_location src_loc;\n+  location_t src_loc;\n \n   if (CPP_OPTION (pfile, traditional))\n     {\n@@ -150,7 +150,7 @@ ATTRIBUTE_FPTR_PRINTF(6,0)\n static bool\n cpp_diagnostic_with_line (cpp_reader * pfile, enum cpp_diagnostic_level level,\n \t\t\t  enum cpp_warning_reason reason,\n-\t\t\t  source_location src_loc, unsigned int column,\n+\t\t\t  location_t src_loc, unsigned int column,\n \t\t\t  const char *msgid, va_list *ap)\n {\n   bool ret;\n@@ -169,7 +169,7 @@ cpp_diagnostic_with_line (cpp_reader * pfile, enum cpp_diagnostic_level level,\n \n bool\n cpp_error_with_line (cpp_reader *pfile, enum cpp_diagnostic_level level,\n-\t\t     source_location src_loc, unsigned int column,\n+\t\t     location_t src_loc, unsigned int column,\n \t\t     const char *msgid, ...)\n {\n   va_list ap;\n@@ -188,7 +188,7 @@ cpp_error_with_line (cpp_reader *pfile, enum cpp_diagnostic_level level,\n \n bool\n cpp_warning_with_line (cpp_reader *pfile, enum cpp_warning_reason reason,\n-\t\t       source_location src_loc, unsigned int column,\n+\t\t       location_t src_loc, unsigned int column,\n \t\t       const char *msgid, ...)\n {\n   va_list ap;\n@@ -207,7 +207,7 @@ cpp_warning_with_line (cpp_reader *pfile, enum cpp_warning_reason reason,\n \n bool\n cpp_pedwarning_with_line (cpp_reader *pfile, enum cpp_warning_reason reason,\n-\t\t\t  source_location src_loc, unsigned int column,\n+\t\t\t  location_t src_loc, unsigned int column,\n \t\t\t  const char *msgid, ...)\n {\n   va_list ap;\n@@ -227,7 +227,7 @@ cpp_pedwarning_with_line (cpp_reader *pfile, enum cpp_warning_reason reason,\n \n bool\n cpp_warning_with_line_syshdr (cpp_reader *pfile, enum cpp_warning_reason reason,\n-\t\t\t      source_location src_loc, unsigned int column,\n+\t\t\t      location_t src_loc, unsigned int column,\n \t\t\t      const char *msgid, ...)\n {\n   va_list ap;\n@@ -247,7 +247,7 @@ cpp_warning_with_line_syshdr (cpp_reader *pfile, enum cpp_warning_reason reason,\n \n bool\n cpp_error_at (cpp_reader * pfile, enum cpp_diagnostic_level level,\n-\t      source_location src_loc, const char *msgid, ...)\n+\t      location_t src_loc, const char *msgid, ...)\n {\n   va_list ap;\n   bool ret;\n@@ -298,7 +298,7 @@ cpp_errno (cpp_reader *pfile, enum cpp_diagnostic_level level,\n bool\n cpp_errno_filename (cpp_reader *pfile, enum cpp_diagnostic_level level,\n \t\t    const char *filename,\n-\t\t    source_location loc)\n+\t\t    location_t loc)\n {\n   if (filename[0] == '\\0')\n     filename = _(\"stdout\");"}, {"sha": "a639f5a47bc77a4a744543c6ea74c0dea7ac44fd", "filename": "libcpp/expr.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fexpr.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -30,7 +30,7 @@ struct op\n {\n   const cpp_token *token;\t/* The token forming op (for diagnostics).  */\n   cpp_num value;\t\t/* The value logically \"right\" of op.  */\n-  source_location loc;          /* The location of this value.         */\n+  location_t loc;          /* The location of this value.         */\n   enum cpp_ttype op;\n };\n \n@@ -52,13 +52,13 @@ static cpp_num num_equality_op (cpp_reader *, cpp_num, cpp_num,\n \t\t\t\tenum cpp_ttype);\n static cpp_num num_mul (cpp_reader *, cpp_num, cpp_num);\n static cpp_num num_div_op (cpp_reader *, cpp_num, cpp_num, enum cpp_ttype,\n-\t\t\t   source_location);\n+\t\t\t   location_t);\n static cpp_num num_lshift (cpp_num, size_t, size_t);\n static cpp_num num_rshift (cpp_num, size_t, size_t);\n \n static cpp_num append_digit (cpp_num, int, int, size_t);\n static cpp_num parse_defined (cpp_reader *);\n-static cpp_num eval_token (cpp_reader *, const cpp_token *, source_location);\n+static cpp_num eval_token (cpp_reader *, const cpp_token *, location_t);\n static struct op *reduce (cpp_reader *, struct op *, enum cpp_ttype);\n static unsigned int interpret_float_suffix (cpp_reader *, const uchar *, size_t);\n static unsigned int interpret_int_suffix (cpp_reader *, const uchar *, size_t);\n@@ -505,7 +505,7 @@ cpp_get_userdef_suffix (const cpp_token *tok)\n    VIRTUAL_LOCATION is the virtual location for TOKEN.  */\n unsigned int\n cpp_classify_number (cpp_reader *pfile, const cpp_token *token,\n-\t\t     const char **ud_suffix, source_location virtual_location)\n+\t\t     const char **ud_suffix, location_t virtual_location)\n {\n   const uchar *str = token->val.str.text;\n   const uchar *limit;\n@@ -1091,7 +1091,7 @@ parse_defined (cpp_reader *pfile)\n    operators).  */\n static cpp_num\n eval_token (cpp_reader *pfile, const cpp_token *token,\n-\t    source_location virtual_location)\n+\t    location_t virtual_location)\n {\n   cpp_num result;\n   unsigned int temp;\n@@ -1288,7 +1288,7 @@ _cpp_parse_expr (cpp_reader *pfile, bool is_if)\n   struct op *top = pfile->op_stack;\n   unsigned int lex_count;\n   bool saw_leading_not, want_value = true;\n-  source_location virtual_location = 0;\n+  location_t virtual_location = 0;\n \n   pfile->state.skip_eval = 0;\n \n@@ -2086,7 +2086,7 @@ num_mul (cpp_reader *pfile, cpp_num lhs, cpp_num rhs)\n \n static cpp_num\n num_div_op (cpp_reader *pfile, cpp_num lhs, cpp_num rhs, enum cpp_ttype op,\n-\t    source_location location)\n+\t    location_t location)\n {\n   cpp_num result, sub;\n   cpp_num_part mask;"}, {"sha": "3771fad75ec1dfb7fc3bd00361b7ea446b4b8a04", "filename": "libcpp/files.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Ffiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Ffiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ffiles.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -144,7 +144,7 @@ struct cpp_file_hash_entry\n {\n   struct cpp_file_hash_entry *next;\n   cpp_dir *start_dir;\n-  source_location location;\n+  location_t location;\n   union\n   {\n     _cpp_file *file;\n@@ -171,18 +171,18 @@ static bool open_file (_cpp_file *file);\n static bool pch_open_file (cpp_reader *pfile, _cpp_file *file,\n \t\t\t   bool *invalid_pch);\n static bool find_file_in_dir (cpp_reader *pfile, _cpp_file *file,\n-\t\t\t      bool *invalid_pch, source_location loc);\n+\t\t\t      bool *invalid_pch, location_t loc);\n static bool read_file_guts (cpp_reader *pfile, _cpp_file *file,\n-\t\t\t    source_location loc);\n+\t\t\t    location_t loc);\n static bool read_file (cpp_reader *pfile, _cpp_file *file,\n-\t\t       source_location loc);\n+\t\t       location_t loc);\n static bool should_stack_file (cpp_reader *, _cpp_file *file, bool import,\n-\t\t\t       source_location loc);\n+\t\t\t       location_t loc);\n static struct cpp_dir *search_path_head (cpp_reader *, const char *fname,\n \t\t\t\t int angle_brackets, enum include_type);\n static const char *dir_name_of_file (_cpp_file *file);\n static void open_file_failed (cpp_reader *pfile, _cpp_file *file, int,\n-\t\t\t      source_location);\n+\t\t\t      location_t);\n static struct cpp_file_hash_entry *search_cache (struct cpp_file_hash_entry *head,\n \t\t\t\t\t     const cpp_dir *start_dir);\n static _cpp_file *make_cpp_file (cpp_reader *, cpp_dir *, const char *fname);\n@@ -377,7 +377,7 @@ maybe_shorter_path (const char * file)\n \n static bool\n find_file_in_dir (cpp_reader *pfile, _cpp_file *file, bool *invalid_pch,\n-\t\t  source_location loc)\n+\t\t  location_t loc)\n {\n   char *path;\n \n@@ -507,7 +507,7 @@ _cpp_find_failed (_cpp_file *file)\n _cpp_file *\n _cpp_find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir,\n \t\tbool fake, int angle_brackets, bool implicit_preinclude,\n-\t\tsource_location loc)\n+\t\tlocation_t loc)\n {\n   struct cpp_file_hash_entry *entry;\n   void **hash_slot;\n@@ -671,7 +671,7 @@ _cpp_find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir,\n \n    FIXME: Flush file cache and try again if we run out of memory.  */\n static bool\n-read_file_guts (cpp_reader *pfile, _cpp_file *file, source_location loc)\n+read_file_guts (cpp_reader *pfile, _cpp_file *file, location_t loc)\n {\n   ssize_t size, total, count;\n   uchar *buf;\n@@ -755,7 +755,7 @@ read_file_guts (cpp_reader *pfile, _cpp_file *file, source_location loc)\n    have been passed through find_file() at some stage.  Use LOC for\n    any diagnostics.  */\n static bool\n-read_file (cpp_reader *pfile, _cpp_file *file, source_location loc)\n+read_file (cpp_reader *pfile, _cpp_file *file, location_t loc)\n {\n   /* If we already have its contents in memory, succeed immediately.  */\n   if (file->buffer_valid)\n@@ -783,7 +783,7 @@ read_file (cpp_reader *pfile, _cpp_file *file, source_location loc)\n    Use LOC for any diagnostics.  */\n static bool\n should_stack_file (cpp_reader *pfile, _cpp_file *file, bool import,\n-\t\t   source_location loc)\n+\t\t   location_t loc)\n {\n   _cpp_file *f;\n \n@@ -892,7 +892,7 @@ should_stack_file (cpp_reader *pfile, _cpp_file *file, bool import,\n    stacked.  Use LOC for any diagnostics.  */\n bool\n _cpp_stack_file (cpp_reader *pfile, _cpp_file *file, bool import,\n-\t\t source_location loc)\n+\t\t location_t loc)\n {\n   cpp_buffer *buffer;\n   int sysp;\n@@ -1007,7 +1007,7 @@ dir_name_of_file (_cpp_file *file)\n    Returns true if a buffer was stacked.  */\n bool\n _cpp_stack_include (cpp_reader *pfile, const char *fname, int angle_brackets,\n-\t\t    enum include_type type, source_location loc)\n+\t\t    enum include_type type, location_t loc)\n {\n   struct cpp_dir *dir;\n   _cpp_file *file;\n@@ -1037,7 +1037,7 @@ _cpp_stack_include (cpp_reader *pfile, const char *fname, int angle_brackets,\n   /* Compensate for the increment in linemap_add that occurs if\n       _cpp_stack_file actually stacks the file.  In the case of a\n      normal #include, we're currently at the start of the line\n-     *following* the #include.  A separate source_location for this\n+     *following* the #include.  A separate location_t for this\n      location makes no sense (until we do the LC_LEAVE), and\n      complicates LAST_SOURCE_LINE_LOCATION.  This does not apply if we\n      found a PCH file (in which case linemap_add is not called) or we\n@@ -1059,7 +1059,7 @@ _cpp_stack_include (cpp_reader *pfile, const char *fname, int angle_brackets,\n /* Could not open FILE.  The complication is dependency output.  */\n static void\n open_file_failed (cpp_reader *pfile, _cpp_file *file, int angle_brackets,\n-\t\t  source_location loc)\n+\t\t  location_t loc)\n {\n   int sysp = pfile->line_table->highest_line > 1 && pfile->buffer ? pfile->buffer->sysp : 0;\n   bool print_dep = CPP_OPTION (pfile, deps.style) > (angle_brackets || !!sysp);\n@@ -1247,7 +1247,7 @@ cpp_included (cpp_reader *pfile, const char *fname)\n    filenames aliased by links or redundant . or .. traversals etc.  */\n bool\n cpp_included_before (cpp_reader *pfile, const char *fname,\n-\t\t     source_location location)\n+\t\t     location_t location)\n {\n   struct cpp_file_hash_entry *entry\n     = (struct cpp_file_hash_entry *)"}, {"sha": "ba99be612a53f00c36f7d581531d7a3a4a5c7886", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -240,8 +240,10 @@ struct GTY(()) cpp_identifier {\n /* A preprocessing token.  This has been carefully packed and should\n    occupy 16 bytes on 32-bit hosts and 24 bytes on 64-bit hosts.  */\n struct GTY(()) cpp_token {\n-  source_location src_loc;\t/* Location of first char of token,\n-\t\t\t\t   together with range of full token.  */\n+\n+  /* Location of first char of token, together with range of full token.  */\n+  location_t src_loc;\n+\n   ENUM_BITFIELD(cpp_ttype) type : CHAR_BIT;  /* token type */\n   unsigned short flags;\t\t/* flags - see above */\n \n@@ -624,12 +626,12 @@ struct cpp_callbacks\n   void (*file_change) (cpp_reader *, const line_map_ordinary *);\n \n   void (*dir_change) (cpp_reader *, const char *);\n-  void (*include) (cpp_reader *, source_location, const unsigned char *,\n+  void (*include) (cpp_reader *, location_t, const unsigned char *,\n \t\t   const char *, int, const cpp_token **);\n-  void (*define) (cpp_reader *, source_location, cpp_hashnode *);\n-  void (*undef) (cpp_reader *, source_location, cpp_hashnode *);\n-  void (*ident) (cpp_reader *, source_location, const cpp_string *);\n-  void (*def_pragma) (cpp_reader *, source_location);\n+  void (*define) (cpp_reader *, location_t, cpp_hashnode *);\n+  void (*undef) (cpp_reader *, location_t, cpp_hashnode *);\n+  void (*ident) (cpp_reader *, location_t, const cpp_string *);\n+  void (*def_pragma) (cpp_reader *, location_t);\n   int (*valid_pch) (cpp_reader *, const char *, int);\n   void (*read_pch) (cpp_reader *, const char *, int, const char *);\n   missing_header_cb missing_header;\n@@ -649,14 +651,14 @@ struct cpp_callbacks\n \n   /* Callbacks for when a macro is expanded, or tested (whether\n      defined or not at the time) in #ifdef, #ifndef or \"defined\".  */\n-  void (*used_define) (cpp_reader *, source_location, cpp_hashnode *);\n-  void (*used_undef) (cpp_reader *, source_location, cpp_hashnode *);\n+  void (*used_define) (cpp_reader *, location_t, cpp_hashnode *);\n+  void (*used_undef) (cpp_reader *, location_t, cpp_hashnode *);\n   /* Called before #define and #undef or other macro definition\n      changes are processed.  */\n   void (*before_define) (cpp_reader *);\n   /* Called whenever a macro is expanded or tested.\n      Second argument is the location of the start of the current expansion.  */\n-  void (*used) (cpp_reader *, source_location, cpp_hashnode *);\n+  void (*used) (cpp_reader *, location_t, cpp_hashnode *);\n \n   /* Callback to identify whether an attribute exists.  */\n   int (*has_attribute) (cpp_reader *);\n@@ -676,7 +678,7 @@ struct cpp_callbacks\n      The content contains the opening slash-star (or slash-slash),\n      and for C-style comments contains the closing star-slash.  For\n      C++-style comments it does not include the terminating newline.  */\n-  void (*comment) (cpp_reader *, source_location, const unsigned char *,\n+  void (*comment) (cpp_reader *, location_t, const unsigned char *,\n \t\t   size_t);\n \n   /* Callback for filename remapping in __FILE__ and __BASE_FILE__ macro\n@@ -753,7 +755,7 @@ struct GTY(()) cpp_macro {\n   } GTY ((desc (\"%1.kind == cmk_assert\"))) parm;\n \n   /* Definition line number.  */\n-  source_location line;\n+  location_t line;\n \n   /* Number of tokens in body, or bytes for traditional macros.  */\n   /* Do we really need 2^32-1 range here?  */\n@@ -884,13 +886,13 @@ struct GTY(()) cpp_hashnode {\n \n class cpp_string_location_reader {\n  public:\n-  cpp_string_location_reader (source_location src_loc,\n+  cpp_string_location_reader (location_t src_loc,\n \t\t\t      line_maps *line_table);\n \n   source_range get_next ();\n \n  private:\n-  source_location m_loc;\n+  location_t m_loc;\n   int m_offset_per_column;\n   line_maps *m_line_table;\n };\n@@ -995,7 +997,7 @@ extern int cpp_avoid_paste (cpp_reader *, const cpp_token *,\n \t\t\t    const cpp_token *);\n extern const cpp_token *cpp_get_token (cpp_reader *);\n extern const cpp_token *cpp_get_token_with_location (cpp_reader *,\n-\t\t\t\t\t\t     source_location *);\n+\t\t\t\t\t\t     location_t *);\n inline bool cpp_user_macro_p (const cpp_hashnode *node)\n {\n   return node->type == NT_USER_MACRO;\n@@ -1017,7 +1019,7 @@ inline bool cpp_fun_like_macro_p (cpp_hashnode *node)\n \n extern const unsigned char *cpp_macro_definition (cpp_reader *,\n \t\t\t\t\t\t  cpp_hashnode *);\n-inline source_location cpp_macro_definition_location (cpp_hashnode *node)\n+inline location_t cpp_macro_definition_location (cpp_hashnode *node)\n {\n   return node->value.macro->line;\n }\n@@ -1126,7 +1128,7 @@ struct cpp_num\n /* Classify a CPP_NUMBER token.  The return value is a combination of\n    the flags from the above sets.  */\n extern unsigned cpp_classify_number (cpp_reader *, const cpp_token *,\n-\t\t\t\t     const char **, source_location);\n+\t\t\t\t     const char **, location_t);\n \n /* Return the classification flags for a float suffix.  */\n extern unsigned int cpp_interpret_float_suffix (cpp_reader *, const char *,\n@@ -1165,30 +1167,30 @@ extern bool cpp_errno (cpp_reader *, enum cpp_diagnostic_level,\n /* Similarly, but with \"FILENAME: \" instead of \"MSGID: \", where\n    the filename is not localized.  */\n extern bool cpp_errno_filename (cpp_reader *, enum cpp_diagnostic_level,\n-\t\t\t\tconst char *filename, source_location loc);\n+\t\t\t\tconst char *filename, location_t loc);\n \n /* Same as cpp_error, except additionally specifies a position as a\n    (translation unit) physical line and physical column.  If the line is\n    zero, then no location is printed.  */\n extern bool cpp_error_with_line (cpp_reader *, enum cpp_diagnostic_level,\n-\t\t\t\t source_location, unsigned,\n+\t\t\t\t location_t, unsigned,\n \t\t\t\t const char *msgid, ...)\n   ATTRIBUTE_PRINTF_5;\n extern bool cpp_warning_with_line (cpp_reader *, enum cpp_warning_reason,\n-\t\t\t\t   source_location, unsigned,\n+\t\t\t\t   location_t, unsigned,\n \t\t\t\t   const char *msgid, ...)\n   ATTRIBUTE_PRINTF_5;\n extern bool cpp_pedwarning_with_line (cpp_reader *, enum cpp_warning_reason,\n-\t\t\t\t      source_location, unsigned,\n+\t\t\t\t      location_t, unsigned,\n \t\t\t\t      const char *msgid, ...)\n   ATTRIBUTE_PRINTF_5;\n extern bool cpp_warning_with_line_syshdr (cpp_reader *, enum cpp_warning_reason,\n-\t\t\t\t\t  source_location, unsigned,\n+\t\t\t\t\t  location_t, unsigned,\n \t\t\t\t\t  const char *msgid, ...)\n   ATTRIBUTE_PRINTF_5;\n \n extern bool cpp_error_at (cpp_reader * pfile, enum cpp_diagnostic_level,\n-\t\t\t  source_location src_loc, const char *msgid, ...)\n+\t\t\t  location_t src_loc, const char *msgid, ...)\n   ATTRIBUTE_PRINTF_4;\n \n extern bool cpp_error_at (cpp_reader * pfile, enum cpp_diagnostic_level,\n@@ -1219,7 +1221,7 @@ typedef struct\n   char *comment;\n \n   /* source location for the given comment.  */\n-  source_location sloc;\n+  location_t sloc;\n } cpp_comment;\n \n /* Structure holding all comments for a given cpp_reader.  */\n@@ -1258,7 +1260,7 @@ extern unsigned char *cpp_quote_string (unsigned char *, const unsigned char *,\n \n /* In files.c */\n extern bool cpp_included (cpp_reader *, const char *);\n-extern bool cpp_included_before (cpp_reader *, const char *, source_location);\n+extern bool cpp_included_before (cpp_reader *, const char *, location_t);\n extern void cpp_make_system_header (cpp_reader *, int, int);\n extern bool cpp_push_include (cpp_reader *, const char *);\n extern bool cpp_push_default_include (cpp_reader *, const char *);\n@@ -1281,7 +1283,7 @@ extern int cpp_read_state (cpp_reader *, const char *, FILE *,\n \t\t\t   struct save_macro_data *);\n \n /* In lex.c */\n-extern void cpp_force_token_locations (cpp_reader *, source_location);\n+extern void cpp_force_token_locations (cpp_reader *, location_t);\n extern void cpp_stop_forcing_token_locations (cpp_reader *);\n \n /* In expr.c */"}, {"sha": "357b211cc381b15ef4507cd3beb83aa6f549a7ad", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 112, "deletions": 112, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -73,7 +73,7 @@ enum lc_reason\n   LC_HWM /* High Water Mark.  */\n };\n \n-/* The typedef \"source_location\" is a key within the location database,\n+/* The typedef \"location_t\" is a key within the location database,\n    identifying a source location or macro expansion, along with range\n    information, and (optionally) a pointer for use by gcc.\n \n@@ -182,7 +182,7 @@ enum lc_reason\n              | macromap[1]->start_location   | Start of macro map 1\n   -----------+-------------------------------+-------------------------------\n              | macromap[0]->start_location   | Start of macro map 0\n-  0x7fffffff | MAX_SOURCE_LOCATION           | Also used as a mask for\n+  0x7fffffff | MAX_LOCATION_T                | Also used as a mask for\n              |                               | accessing the ad-hoc data table\n   -----------+-------------------------------+-------------------------------\n   0x80000000 | Start of ad-hoc values; the lower 31 bits are used as an index\n@@ -283,9 +283,9 @@ enum lc_reason\n      finish == ordmap->start + (23 << 12) + (19 << 5)\n             == ordmap->start + 0x17260\n \n-   To further see how source_location works in practice, see the\n+   To further see how location_t works in practice, see the\n    worked example in libcpp/location-example.txt.  */\n-typedef unsigned int source_location;\n+typedef unsigned int location_t;\n \n /* Do not track column numbers higher than this one.  As a result, the\n    range of column_bits is [12, 18] (or 0 if column numbers are\n@@ -295,15 +295,15 @@ const unsigned int LINE_MAP_MAX_COLUMN_NUMBER = (1U << 12);\n /* Do not pack ranges if locations get higher than this.\n    If you change this, update:\n      gcc.dg/plugin/location-overflow-test-*.c.  */\n-const source_location LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES = 0x50000000;\n+const location_t LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES = 0x50000000;\n \n /* Do not track column numbers if locations get higher than this.\n    If you change this, update:\n      gcc.dg/plugin/location-overflow-test-*.c.  */\n-const source_location LINE_MAP_MAX_LOCATION_WITH_COLS = 0x60000000;\n+const location_t LINE_MAP_MAX_LOCATION_WITH_COLS = 0x60000000;\n \n /* Highest possible source location encoded within an ordinary map.  */\n-const source_location LINE_MAP_MAX_LOCATION = 0x70000000;\n+const location_t LINE_MAP_MAX_LOCATION = 0x70000000;\n \n /* A range of source locations.\n \n@@ -315,25 +315,25 @@ const source_location LINE_MAP_MAX_LOCATION = 0x70000000;\n    let's do it the simple way, as a pair.  */\n struct GTY(()) source_range\n {\n-  source_location m_start;\n-  source_location m_finish;\n+  location_t m_start;\n+  location_t m_finish;\n \n   /* We avoid using constructors, since various structs that\n      don't yet have constructors will embed instances of\n      source_range.  */\n \n-  /* Make a source_range from a source_location.  */\n-  static source_range from_location (source_location loc)\n+  /* Make a source_range from a location_t.  */\n+  static source_range from_location (location_t loc)\n   {\n     source_range result;\n     result.m_start = loc;\n     result.m_finish = loc;\n     return result;\n   }\n \n-  /* Make a source_range from a pair of source_location.  */\n-  static source_range from_locations (source_location start,\n-\t\t\t\t      source_location finish)\n+  /* Make a source_range from a pair of location_t.  */\n+  static source_range from_locations (location_t start,\n+\t\t\t\t      location_t finish)\n   {\n     source_range result;\n     result.m_start = start;\n@@ -379,7 +379,7 @@ typedef size_t (*line_map_round_alloc_size_func) (size_t);\n /* This contains GTY mark-up to support precompiled headers.\n    line_map is an abstract class, only derived objects exist.  */\n struct GTY((tag (\"0\"), desc (\"MAP_ORDINARY_P (&%h) ? 1 : 2\"))) line_map {\n-  source_location start_location;\n+  location_t start_location;\n \n   /* Size and alignment is (usually) 4 bytes.  */\n };\n@@ -395,7 +395,7 @@ struct GTY((tag (\"0\"), desc (\"MAP_ORDINARY_P (&%h) ? 1 : 2\"))) line_map {\n    (The top line is line 1 and the leftmost column is column 1; line/column 0\n    means \"entire file/line\" or \"unknown line/column\" or \"not applicable\".)\n \n-   The highest possible source location is MAX_SOURCE_LOCATION.  */\n+   The highest possible source location is MAX_LOCATION_T.  */\n struct GTY((tag (\"1\"))) line_map_ordinary : public line_map {\n   /* Base class is 4 bytes.  */\n \n@@ -410,7 +410,7 @@ struct GTY((tag (\"1\"))) line_map_ordinary : public line_map {\n      cpp_buffer.  */\n   unsigned char sysp;\n \n-  /* Number of the low-order source_location bits used for column numbers\n+  /* Number of the low-order location_t bits used for column numbers\n      and ranges.  */\n   unsigned int m_column_and_range_bits : 8;\n \n@@ -437,14 +437,14 @@ struct GTY((tag (\"1\"))) line_map_ordinary : public line_map {\n   /* Location from whence this line map was included.  For regular\n      #includes, this location will be the last location of a map.  For\n      outermost file, this is 0.  */\n-  source_location included_from;\n+  location_t included_from;\n \n   /* Size is 20 or 24 bytes, no padding  */\n };\n \n /* This is the highest possible source location encoded within an\n    ordinary or macro map.  */\n-const source_location MAX_SOURCE_LOCATION = 0x7FFFFFFF;\n+const location_t MAX_LOCATION_T = 0x7FFFFFFF;\n \n struct cpp_hashnode;\n \n@@ -521,14 +521,14 @@ struct GTY((tag (\"2\"))) line_map_macro : public line_map {\n      In the example above x1 (for token \"+\") is going to be the same\n      as y1.  x0 is the spelling location for the argument token \"1\",\n      and x2 is the spelling location for the argument token \"2\".  */\n-  source_location * GTY((atomic)) macro_locations;\n+  location_t * GTY((atomic)) macro_locations;\n \n   /* This is the location of the expansion point of the current macro\n      map.  It's the location of the macro name.  That location is held\n      by the map that was current right before the current one. It\n      could have been either a macro or an ordinary map, depending on\n      if we are in a nested expansion context not.  */\n-  source_location expansion;\n+  location_t expansion;\n \n   /* Size is 20 or 32 (4 bytes padding on 64-bit).  */\n };\n@@ -561,19 +561,19 @@ struct GTY((tag (\"2\"))) line_map_macro : public line_map {\n /* Get whether location LOC is an ad-hoc, ordinary or macro location.  */\n \n inline bool\n-IS_ORDINARY_LOC (source_location loc)\n+IS_ORDINARY_LOC (location_t loc)\n {\n   return loc < LINE_MAP_MAX_LOCATION;\n }\n \n inline bool\n-IS_ADHOC_LOC (source_location loc)\n+IS_ADHOC_LOC (location_t loc)\n {\n-  return loc > MAX_SOURCE_LOCATION;\n+  return loc > MAX_LOCATION_T;\n }\n \n inline bool\n-IS_MACRO_LOC (source_location loc)\n+IS_MACRO_LOC (location_t loc)\n {\n   return !IS_ORDINARY_LOC (loc) && !IS_ADHOC_LOC (loc);\n }\n@@ -634,7 +634,7 @@ linemap_check_macro (const line_map *map)\n \n /* Read the start location of MAP.  */\n \n-inline source_location\n+inline location_t\n MAP_START_LOCATION (const line_map *map)\n {\n   return map->start_location;\n@@ -687,15 +687,15 @@ MACRO_MAP_NUM_MACRO_TOKENS (const line_map_macro *macro_map)\n /* Get the array of pairs of locations within macro map MAP.\n    See the declaration of line_map_macro for more information.  */\n \n-inline source_location *\n+inline location_t *\n MACRO_MAP_LOCATIONS (const line_map_macro *macro_map)\n {\n   return macro_map->macro_locations;\n }\n \n /* Get the location of the expansion point of the macro map MAP.  */\n \n-inline source_location\n+inline location_t\n MACRO_MAP_EXPANSION_POINT_LOCATION (const line_map_macro *macro_map)\n {\n   return macro_map->expansion;\n@@ -742,7 +742,7 @@ struct GTY(()) maps_info_macro {\n /* Data structure to associate a source_range together with an arbitrary\n    data pointer with a source location.  */\n struct GTY(()) location_adhoc_data {\n-  source_location locus;\n+  location_t locus;\n   source_range src_range;\n   void * GTY((skip)) data;\n };\n@@ -761,7 +761,7 @@ struct htab;\n \n struct GTY(()) location_adhoc_data_map {\n   struct htab * GTY((skip)) htab;\n-  source_location curr_loc;\n+  location_t curr_loc;\n   unsigned int allocated;\n   struct location_adhoc_data GTY((length (\"%h.allocated\"))) *data;\n };\n@@ -781,11 +781,11 @@ struct GTY(()) line_maps {\n   /* If true, prints an include trace a la -H.  */\n   bool trace_includes;\n \n-  /* Highest source_location \"given out\".  */\n-  source_location highest_location;\n+  /* Highest location_t \"given out\".  */\n+  location_t highest_location;\n \n-  /* Start of line of highest source_location \"given out\".  */\n-  source_location highest_line;\n+  /* Start of line of highest location_t \"given out\".  */\n+  location_t highest_line;\n \n   /* The maximum column number we can quickly allocate.  Higher numbers\n      may require allocating a new line_map.  */\n@@ -802,7 +802,7 @@ struct GTY(()) line_maps {\n \n   /* The special location value that is used as spelling location for\n      built-in tokens.  */\n-  source_location builtin_location;\n+  location_t builtin_location;\n \n   /* True if we've seen a #line or # 44 \"file\" directive.  */\n   bool seen_line_directive;\n@@ -1032,12 +1032,12 @@ LINEMAPS_LAST_MACRO_MAP (const line_maps *set)\n \n /* Returns the lowest location [of a token resulting from macro\n    expansion] encoded in this line table.  */\n-inline source_location\n+inline location_t\n LINEMAPS_MACRO_LOWEST_LOCATION (const line_maps *set)\n {\n   return LINEMAPS_MACRO_USED (set)\n          ? MAP_START_LOCATION (LINEMAPS_LAST_MACRO_MAP (set))\n-         : MAX_SOURCE_LOCATION + 1;\n+         : MAX_LOCATION_T + 1;\n }\n \n /* Returns the last macro map allocated in the line table SET.  */\n@@ -1047,33 +1047,33 @@ LINEMAPS_LAST_ALLOCATED_MACRO_MAP (const line_maps *set)\n   return (line_map_macro *)LINEMAPS_LAST_ALLOCATED_MAP (set, true);\n }\n \n-extern source_location get_combined_adhoc_loc (struct line_maps *,\n-\t\t\t\t\t       source_location,\n+extern location_t get_combined_adhoc_loc (struct line_maps *,\n+\t\t\t\t\t       location_t,\n \t\t\t\t\t       source_range,\n \t\t\t\t\t       void *);\n-extern void *get_data_from_adhoc_loc (struct line_maps *, source_location);\n-extern source_location get_location_from_adhoc_loc (struct line_maps *,\n-\t\t\t\t\t\t    source_location);\n+extern void *get_data_from_adhoc_loc (struct line_maps *, location_t);\n+extern location_t get_location_from_adhoc_loc (struct line_maps *,\n+\t\t\t\t\t\t    location_t);\n \n-extern source_range get_range_from_loc (line_maps *set, source_location loc);\n+extern source_range get_range_from_loc (line_maps *set, location_t loc);\n \n /* Get whether location LOC is a \"pure\" location, or\n    whether it is an ad-hoc location, or embeds range information.  */\n \n bool\n-pure_location_p (line_maps *set, source_location loc);\n+pure_location_p (line_maps *set, location_t loc);\n \n /* Given location LOC within SET, strip away any packed range information\n    or ad-hoc information.  */\n \n-extern source_location get_pure_location (line_maps *set,\n-\t\t\t\t\t  source_location loc);\n+extern location_t get_pure_location (line_maps *set,\n+\t\t\t\t\t  location_t loc);\n \n /* Combine LOC and BLOCK, giving a combined adhoc location.  */\n \n-inline source_location\n+inline location_t\n COMBINE_LOCATION_DATA (struct line_maps *set,\n-\t\t       source_location loc,\n+\t\t       location_t loc,\n \t\t       source_range src_range,\n \t\t       void *block)\n {\n@@ -1087,19 +1087,19 @@ extern void rebuild_location_adhoc_htab (struct line_maps *);\n    spelling location for built-in tokens.  This BUILTIN_LOCATION has\n    to be strictly less than RESERVED_LOCATION_COUNT.  */\n extern void linemap_init (struct line_maps *set,\n-\t\t\t  source_location builtin_location);\n+\t\t\t  location_t builtin_location);\n \n /* Check for and warn about line_maps entered but not exited.  */\n \n extern void linemap_check_files_exited (struct line_maps *);\n \n-/* Return a source_location for the start (i.e. column==0) of\n+/* Return a location_t for the start (i.e. column==0) of\n    (physical) line TO_LINE in the current source file (as in the\n    most recent linemap_add).   MAX_COLUMN_HINT is the highest column\n    number we expect to use in this line (but it does not change\n    the highest_location).  */\n \n-extern source_location linemap_line_start\n+extern location_t linemap_line_start\n (struct line_maps *set, linenum_type to_line,  unsigned int max_column_hint);\n \n /* Add a mapping of logical source line to physical source file and\n@@ -1126,7 +1126,7 @@ extern const struct line_map *linemap_add\n    binary search. If no line map have been allocated yet, this\n    function returns NULL.  */\n extern const struct line_map *linemap_lookup\n-  (struct line_maps *, source_location);\n+  (struct line_maps *, location_t);\n \n /* Returns TRUE if the line table set tracks token locations across\n    macro expansion, FALSE otherwise.  */\n@@ -1145,49 +1145,49 @@ const char* linemap_map_get_macro_name (const line_map_macro *);\n    that is part of a macro replacement-list defined in a system\n    header, but expanded in a non-system file.  */\n int linemap_location_in_system_header_p (struct line_maps *,\n-\t\t\t\t\t source_location);\n+\t\t\t\t\t location_t);\n \n /* Return TRUE if LOCATION is a source code location of a token that is part of\n    a macro expansion, FALSE otherwise.  */\n bool linemap_location_from_macro_expansion_p (const struct line_maps *,\n-\t\t\t\t\t      source_location);\n+\t\t\t\t\t      location_t);\n \n /* TRUE if LOCATION is a source code location of a token that is part of the\n    definition of a macro, FALSE otherwise.  */\n bool linemap_location_from_macro_definition_p (struct line_maps *,\n-\t\t\t\t\t       source_location);\n+\t\t\t\t\t       location_t);\n \n /* With the precondition that LOCATION is the locus of a token that is\n    an argument of a function-like macro MACRO_MAP and appears in the\n    expansion of MACRO_MAP, return the locus of that argument in the\n    context of the caller of MACRO_MAP.  */\n \n-extern source_location linemap_macro_map_loc_unwind_toward_spelling\n-  (line_maps *set, const line_map_macro *macro_map, source_location location);\n+extern location_t linemap_macro_map_loc_unwind_toward_spelling\n+  (line_maps *set, const line_map_macro *macro_map, location_t location);\n \n-/* source_location values from 0 to RESERVED_LOCATION_COUNT-1 will\n+/* location_t values from 0 to RESERVED_LOCATION_COUNT-1 will\n    be reserved for libcpp user as special values, no token from libcpp\n    will contain any of those locations.  */\n-const source_location RESERVED_LOCATION_COUNT = 2;\n+const location_t RESERVED_LOCATION_COUNT = 2;\n \n-/* Converts a map and a source_location to source line.  */\n+/* Converts a map and a location_t to source line.  */\n inline linenum_type\n-SOURCE_LINE (const line_map_ordinary *ord_map, source_location loc)\n+SOURCE_LINE (const line_map_ordinary *ord_map, location_t loc)\n {\n   return ((loc - ord_map->start_location)\n \t  >> ord_map->m_column_and_range_bits) + ord_map->to_line;\n }\n \n-/* Convert a map and source_location to source column number.  */\n+/* Convert a map and location_t to source column number.  */\n inline linenum_type\n-SOURCE_COLUMN (const line_map_ordinary *ord_map, source_location loc)\n+SOURCE_COLUMN (const line_map_ordinary *ord_map, location_t loc)\n {\n   return ((loc - ord_map->start_location)\n \t  & ((1 << ord_map->m_column_and_range_bits) - 1)) >> ord_map->m_range_bits;\n }\n \n \n-inline source_location\n+inline location_t\n linemap_included_from (const line_map_ordinary *ord_map)\n {\n   return ord_map->included_from;\n@@ -1205,26 +1205,26 @@ MAIN_FILE_P (const line_map_ordinary *ord_map)\n   return ord_map->included_from == 0;\n }\n \n-/* Encode and return a source_location from a column number. The\n+/* Encode and return a location_t from a column number. The\n    source line considered is the last source line used to call\n    linemap_line_start, i.e, the last source line which a location was\n    encoded from.  */\n-extern source_location\n+extern location_t\n linemap_position_for_column (struct line_maps *, unsigned int);\n \n /* Encode and return a source location from a given line and\n    column.  */\n-source_location\n+location_t\n linemap_position_for_line_and_column (line_maps *set,\n \t\t\t\t      const line_map_ordinary *,\n \t\t\t\t      linenum_type, unsigned int);\n \n-/* Encode and return a source_location starting from location LOC and\n+/* Encode and return a location_t starting from location LOC and\n    shifting it by OFFSET columns.  This function does not support\n    virtual locations.  */\n-source_location\n+location_t\n linemap_position_for_loc_and_offset (struct line_maps *set,\n-\t\t\t\t     source_location loc,\n+\t\t\t\t     location_t loc,\n \t\t\t\t     unsigned int offset);\n \n /* Return the file this map is for.  */\n@@ -1256,16 +1256,16 @@ LINEMAP_SYSP (const line_map_ordinary *ord_map)\n    the same token as the token for POST, and a negative value\n    otherwise.  */\n int linemap_compare_locations (struct line_maps *set,\n-\t\t\t       source_location   pre,\n-\t\t\t       source_location   post);\n+\t\t\t       location_t   pre,\n+\t\t\t       location_t   post);\n \n /* Return TRUE if LOC_A denotes the location a token that comes\n    topogically before the token denoted by location LOC_B, or if they\n    are equal.  */\n inline bool\n linemap_location_before_p (struct line_maps *set,\n-\t\t\t   source_location loc_a,\n-\t\t\t   source_location loc_b)\n+\t\t\t   location_t loc_a,\n+\t\t\t   location_t loc_b)\n {\n   return linemap_compare_locations (set, loc_a, loc_b) >= 0;\n }\n@@ -1324,7 +1324,7 @@ enum range_display_kind\n \n struct location_range\n {\n-  source_location m_loc;\n+  location_t m_loc;\n \n   enum range_display_kind m_range_display_kind;\n \n@@ -1607,7 +1607,7 @@ class fixit_hint;\n \n    Adding a fix-it hint can fail: for example, attempts to insert content\n    at the transition between two line maps may fail due to there being no\n-   source_location (aka location_t) value to express the new location.\n+   location_t value to express the new location.\n \n    Attempts to add a fix-it hint within a macro expansion will fail.\n \n@@ -1637,24 +1637,24 @@ class rich_location\n   /* Constructors.  */\n \n   /* Constructing from a location.  */\n-  rich_location (line_maps *set, source_location loc,\n+  rich_location (line_maps *set, location_t loc,\n \t\t const range_label *label = NULL);\n \n   /* Destructor.  */\n   ~rich_location ();\n \n   /* Accessors.  */\n-  source_location get_loc () const { return get_loc (0); }\n-  source_location get_loc (unsigned int idx) const;\n+  location_t get_loc () const { return get_loc (0); }\n+  location_t get_loc (unsigned int idx) const;\n \n   void\n-  add_range (source_location loc,\n+  add_range (location_t loc,\n \t     enum range_display_kind range_display_kind\n \t       = SHOW_RANGE_WITHOUT_CARET,\n \t     const range_label *label = NULL);\n \n   void\n-  set_range (unsigned int idx, source_location loc,\n+  set_range (unsigned int idx, location_t loc,\n \t     enum range_display_kind range_display_kind);\n \n   unsigned int get_num_locations () const { return m_ranges.count (); }\n@@ -1678,7 +1678,7 @@ class rich_location\n \n   /* Suggest inserting NEW_CONTENT immediately before the start of WHERE.  */\n   void\n-  add_fixit_insert_before (source_location where,\n+  add_fixit_insert_before (location_t where,\n \t\t\t   const char *new_content);\n \n   /* Suggest inserting NEW_CONTENT immediately after the end of the primary\n@@ -1688,7 +1688,7 @@ class rich_location\n \n   /* Suggest inserting NEW_CONTENT immediately after the end of WHERE.  */\n   void\n-  add_fixit_insert_after (source_location where,\n+  add_fixit_insert_after (location_t where,\n \t\t\t  const char *new_content);\n \n   /* Methods for adding removal fix-it hints.  */\n@@ -1700,7 +1700,7 @@ class rich_location\n   /* Suggest removing the content covered between the start and finish\n      of WHERE.  */\n   void\n-  add_fixit_remove (source_location where);\n+  add_fixit_remove (location_t where);\n \n   /* Suggest removing the content covered by SRC_RANGE.  */\n   void\n@@ -1715,7 +1715,7 @@ class rich_location\n   /* Suggest replacing the content between the start and finish of\n      WHERE with NEW_CONTENT.  */\n   void\n-  add_fixit_replace (source_location where,\n+  add_fixit_replace (location_t where,\n \t\t     const char *new_content);\n \n   /* Suggest replacing the content covered by SRC_RANGE with\n@@ -1751,10 +1751,10 @@ class rich_location\n   }\n \n private:\n-  bool reject_impossible_fixit (source_location where);\n+  bool reject_impossible_fixit (location_t where);\n   void stop_supporting_fixits ();\n-  void maybe_add_fixit (source_location start,\n-\t\t\tsource_location next_loc,\n+  void maybe_add_fixit (location_t start,\n+\t\t\tlocation_t next_loc,\n \t\t\tconst char *new_content);\n \n public:\n@@ -1843,16 +1843,16 @@ class range_label\n class fixit_hint\n {\n  public:\n-  fixit_hint (source_location start,\n-\t      source_location next_loc,\n+  fixit_hint (location_t start,\n+\t      location_t next_loc,\n \t      const char *new_content);\n   ~fixit_hint () { free (m_bytes); }\n \n   bool affects_line_p (const char *file, int line) const;\n-  source_location get_start_loc () const { return m_start; }\n-  source_location get_next_loc () const { return m_next_loc; }\n-  bool maybe_append (source_location start,\n-\t\t     source_location next_loc,\n+  location_t get_start_loc () const { return m_start; }\n+  location_t get_next_loc () const { return m_next_loc; }\n+  bool maybe_append (location_t start,\n+\t\t     location_t next_loc,\n \t\t     const char *new_content);\n \n   const char *get_string () const { return m_bytes; }\n@@ -1867,8 +1867,8 @@ class fixit_hint\n      this is a half-open/half-closed range:\n        [start, next_loc)\n      so that we can support insertion via start == next_loc.  */\n-  source_location m_start;\n-  source_location m_next_loc;\n+  location_t m_start;\n+  location_t m_next_loc;\n   char *m_bytes;\n   size_t m_len;\n };\n@@ -1932,10 +1932,10 @@ enum location_resolution_kind\n    resolves to a location reserved for the client code, like\n    UNKNOWN_LOCATION or BUILTINS_LOCATION in GCC.  */\n \n-source_location linemap_resolve_location (struct line_maps *,\n-\t\t\t\t\t  source_location loc,\n-\t\t\t\t\t  enum location_resolution_kind lrk,\n-\t\t\t\t\t  const line_map_ordinary **loc_map);\n+location_t linemap_resolve_location (struct line_maps *,\n+\t\t\t\t     location_t loc,\n+\t\t\t\t     enum location_resolution_kind lrk,\n+\t\t\t\t     const line_map_ordinary **loc_map);\n \n /* Suppose that LOC is the virtual location of a token coming from the\n    expansion of a macro M.  This function then steps up to get the\n@@ -1944,9 +1944,9 @@ source_location linemap_resolve_location (struct line_maps *,\n    the point where M' was expanded.  LOC_MAP is an output parameter.\n    When non-NULL, *LOC_MAP is set to the map of the returned\n    location.  */\n-source_location linemap_unwind_toward_expansion (struct line_maps *,\n-\t\t\t\t\t\t source_location loc,\n-\t\t\t\t\t\t const struct line_map **loc_map);\n+location_t linemap_unwind_toward_expansion (struct line_maps *,\n+\t\t\t\t\t    location_t loc,\n+\t\t\t\t\t    const struct line_map **loc_map);\n \n /* If LOC is the virtual location of a token coming from the expansion\n    of a macro M and if its spelling location is reserved (e.g, a\n@@ -1962,17 +1962,17 @@ source_location linemap_unwind_toward_expansion (struct line_maps *,\n \n    *MAP is set to the map of the returned location if the later is\n    different from LOC.  */\n-source_location linemap_unwind_to_first_non_reserved_loc (struct line_maps *,\n-\t\t\t\t\t\t\t  source_location loc,\n-\t\t\t\t\t\t\t  const struct line_map **map);\n+location_t linemap_unwind_to_first_non_reserved_loc (struct line_maps *,\n+\t\t\t\t\t\t     location_t loc,\n+\t\t\t\t\t\t     const struct line_map **map);\n \n /* Expand source code location LOC and return a user readable source\n    code location.  LOC must be a spelling (non-virtual) location.  If\n    it's a location < RESERVED_LOCATION_COUNT a zeroed expanded source\n    location is returned.  */\n expanded_location linemap_expand_location (struct line_maps *,\n \t\t\t\t\t   const struct line_map *,\n-\t\t\t\t\t   source_location loc);\n+\t\t\t\t\t   location_t loc);\n \n /* Statistics about maps allocation and usage as returned by\n    linemap_get_statistics.  */\n@@ -1999,15 +1999,15 @@ struct linemap_stats\n    location emitted for that file.  */\n bool linemap_get_file_highest_location (struct line_maps * set,\n \t\t\t\t\tconst char *file_name,\n-\t\t\t\t\tsource_location *loc);\n+\t\t\t\t\tlocation_t *loc);\n \n /* Compute and return statistics about the memory consumption of some\n    parts of the line table SET.  */\n void linemap_get_statistics (struct line_maps *, struct linemap_stats *);\n \n /* Dump debugging information about source location LOC into the file\n    stream STREAM. SET is the line map set LOC comes from.  */\n-void linemap_dump_location (struct line_maps *, source_location, FILE *);\n+void linemap_dump_location (struct line_maps *, location_t, FILE *);\n \n /* Dump line map at index IX in line table SET to STREAM.  If STREAM\n    is NULL, use stderr.  IS_MACRO is true if the caller wants to\n@@ -2019,7 +2019,7 @@ void linemap_dump (FILE *, struct line_maps *, unsigned, bool);\n    specifies how many macro maps to dump.  */\n void line_table_dump (FILE *, struct line_maps *, unsigned int, unsigned int);\n \n-/* An enum for distinguishing the various parts within a source_location.  */\n+/* An enum for distinguishing the various parts within a location_t.  */\n \n enum location_aspect\n {\n@@ -2028,14 +2028,14 @@ enum location_aspect\n   LOCATION_ASPECT_FINISH\n };\n \n-/* The rich_location class requires a way to expand source_location instances.\n+/* The rich_location class requires a way to expand location_t instances.\n    We would directly use expand_location_to_spelling_point, which is\n    implemented in gcc/input.c, but we also need to use it for rich_location\n    within genmatch.c.\n    Hence we require client code of libcpp to implement the following\n    symbol.  */\n extern expanded_location\n-linemap_client_expand_location_to_spelling_point (source_location,\n+linemap_client_expand_location_to_spelling_point (location_t,\n \t\t\t\t\t\t  enum location_aspect);\n \n #endif /* !LIBCPP_LINE_MAP_H  */"}, {"sha": "849aedc67f289034160c23aed14c4ac0c239a9fd", "filename": "libcpp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finit.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -633,7 +633,7 @@ cpp_post_options (cpp_reader *pfile)\n const char *\n cpp_read_main_file (cpp_reader *pfile, const char *fname)\n {\n-  const source_location loc = 0;\n+  const location_t loc = 0;\n \n   if (CPP_OPTION (pfile, deps.style) != DEPS_NONE)\n     {"}, {"sha": "59e18ec3db3adb70244dcfc510bd7d42f2e4f33c", "filename": "libcpp/internal.h", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -150,11 +150,11 @@ typedef struct\n      location at index 0 is the virtual location of the token at index\n      0 in the current instance of cpp_context; similarly for all the\n      other virtual locations.  */\n-  source_location *virt_locs;\n+  location_t *virt_locs;\n   /* This is a pointer to the current virtual location.  This is used\n      to iterate over the virtual locations while we iterate over the\n      tokens they belong to.  */\n-  source_location *cur_virt_loc;\n+  location_t *cur_virt_loc;\n } macro_context;\n \n /* The kind of tokens carried by a cpp_context.  */\n@@ -372,7 +372,7 @@ struct def_pragma_macro {\n   unsigned char *definition;\n \n   /* Definition line number.  */\n-  source_location line;\n+  location_t line;\n   /* If macro defined in system header.  */\n   unsigned int syshdr   : 1;\n   /* Nonzero if it has been expanded or had its existence tested.  */\n@@ -400,7 +400,7 @@ struct cpp_reader\n   struct line_maps *line_table;\n \n   /* The line of the '#' of the current directive.  */\n-  source_location directive_line;\n+  location_t directive_line;\n \n   /* Memory buffers.  */\n   _cpp_buff *a_buff;\t\t/* Aligned permanent storage.  */\n@@ -419,7 +419,7 @@ struct cpp_reader\n \n   /* When expanding a macro at top-level, this is the location of the\n      macro invocation.  */\n-  source_location invocation_location;\n+  location_t invocation_location;\n \n   /* This is the node representing the macro being expanded at\n      top-level.  The value of this data member is valid iff\n@@ -551,7 +551,7 @@ struct cpp_reader\n     unsigned char *base;\n     unsigned char *limit;\n     unsigned char *cur;\n-    source_location first_line;\n+    location_t first_line;\n   } out;\n \n   /* Used for buffer overlays by traditional.c.  */\n@@ -572,7 +572,7 @@ struct cpp_reader\n \n   /* If non-zero, the lexer will use this location for the next token\n      instead of getting a location from the linemap.  */\n-  source_location forced_token_location;\n+  location_t forced_token_location;\n };\n \n /* Character classes.  Based on the more primitive macros in safe-ctype.h.\n@@ -646,7 +646,7 @@ extern bool _cpp_arguments_ok (cpp_reader *, cpp_macro *, const cpp_hashnode *,\n \t\t\t       unsigned int);\n extern const unsigned char *_cpp_builtin_macro_text (cpp_reader *,\n \t\t\t\t\t\t     cpp_hashnode *,\n-\t\t\t\t\t\t     source_location = 0);\n+\t\t\t\t\t\t     location_t = 0);\n extern int _cpp_warn_if_unused_macro (cpp_reader *, cpp_hashnode *, void *);\n extern void _cpp_push_token_context (cpp_reader *, cpp_hashnode *,\n \t\t\t\t     const cpp_token *, unsigned int);\n@@ -659,14 +659,14 @@ extern void _cpp_destroy_hashtable (cpp_reader *);\n /* In files.c */\n typedef struct _cpp_file _cpp_file;\n extern _cpp_file *_cpp_find_file (cpp_reader *, const char *, cpp_dir *,\n-\t\t\t\t  bool, int, bool, source_location);\n+\t\t\t\t  bool, int, bool, location_t);\n extern bool _cpp_find_failed (_cpp_file *);\n extern void _cpp_mark_file_once_only (cpp_reader *, struct _cpp_file *);\n extern void _cpp_fake_include (cpp_reader *, const char *);\n extern bool _cpp_stack_file (cpp_reader *, _cpp_file*, bool,\n-\t\t\t     source_location);\n+\t\t\t     location_t);\n extern bool _cpp_stack_include (cpp_reader *, const char *, int,\n-\t\t\t\tenum include_type, source_location);\n+\t\t\t\tenum include_type, location_t);\n extern int _cpp_compare_file_date (cpp_reader *, const char *, int);\n extern void _cpp_report_missing_guards (cpp_reader *);\n extern void _cpp_init_files (cpp_reader *);\n@@ -717,7 +717,7 @@ extern int _cpp_handle_directive (cpp_reader *, int);\n extern void _cpp_define_builtin (cpp_reader *, const char *);\n extern char ** _cpp_save_pragma_names (cpp_reader *);\n extern void _cpp_restore_pragma_names (cpp_reader *, char **);\n-extern int _cpp_do__Pragma (cpp_reader *, source_location);\n+extern int _cpp_do__Pragma (cpp_reader *, location_t);\n extern void _cpp_init_directives (cpp_reader *);\n extern void _cpp_init_internal_pragmas (cpp_reader *);\n extern void _cpp_do_file_change (cpp_reader *, enum lc_reason, const char *,\n@@ -730,7 +730,7 @@ struct _cpp_dir_only_callbacks\n {\n   /* Called to print a block of lines. */\n   void (*print_lines) (int, const void *, size_t);\n-  bool (*maybe_print_line) (source_location);\n+  bool (*maybe_print_line) (location_t);\n };\n \n extern void _cpp_preprocess_dir_only (cpp_reader *,\n@@ -867,7 +867,7 @@ ufputs (const unsigned char *s, FILE *f)\n    the replacement-list of MACRO.  */\n const line_map_macro *linemap_enter_macro (struct line_maps *,\n \t\t\t\t\t   struct cpp_hashnode*,\n-\t\t\t\t\t   source_location,\n+\t\t\t\t\t   location_t,\n \t\t\t\t\t   unsigned int);\n \n /* Create and return a virtual location for a token that is part of a\n@@ -892,18 +892,18 @@ const line_map_macro *linemap_enter_macro (struct line_maps *,\n    MACRO_DEFINITION_LOC is the location in the macro definition,\n    either of the token itself or of a macro parameter that it\n    replaces.  */\n-source_location linemap_add_macro_token (const line_map_macro *,\n-\t\t\t\t\t unsigned int,\n-\t\t\t\t\t source_location,\n-\t\t\t\t\t source_location);\n+location_t linemap_add_macro_token (const line_map_macro *,\n+\t\t\t\t    unsigned int,\n+\t\t\t\t    location_t,\n+\t\t\t\t    location_t);\n \n /* Return the source line number corresponding to source location\n    LOCATION.  SET is the line map set LOCATION comes from.  If\n    LOCATION is the location of token that is part of the\n    expansion-list of a macro expansion return the line number of the\n    macro expansion point.  */\n int linemap_get_expansion_line (struct line_maps *,\n-\t\t\t\tsource_location);\n+\t\t\t\tlocation_t);\n \n /* Return the path of the file corresponding to source code location\n    LOCATION.\n@@ -914,7 +914,7 @@ int linemap_get_expansion_line (struct line_maps *,\n \n    SET is the line map set LOCATION comes from.  */\n const char* linemap_get_expansion_filename (struct line_maps *,\n-\t\t\t\t\t    source_location);\n+\t\t\t\t\t    location_t);\n \n #ifdef __cplusplus\n }"}, {"sha": "3a2fdb175cac61b42a8be4ddcf29b1d9a61668a4", "filename": "libcpp/lex.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -1232,7 +1232,7 @@ static int\n skip_line_comment (cpp_reader *pfile)\n {\n   cpp_buffer *buffer = pfile->buffer;\n-  source_location orig_line = pfile->line_table->highest_line;\n+  location_t orig_line = pfile->line_table->highest_line;\n \n   while (*buffer->cur != '\\n')\n     buffer->cur++;\n@@ -1894,7 +1894,7 @@ lex_raw_string (cpp_reader *pfile, cpp_token *token, const uchar *base,\n \t  _cpp_process_line_notes (pfile, false);\n \t  if (!_cpp_get_fresh_line (pfile))\n \t    {\n-\t      source_location src_loc = token->src_loc;\n+\t      location_t src_loc = token->src_loc;\n \t      token->type = CPP_EOF;\n \t      /* Tell the compiler the line number of the EOF token.  */\n \t      token->src_loc = pfile->line_table->highest_line;\n@@ -3774,11 +3774,11 @@ cpp_token_val_index (const cpp_token *tok)\n }\n \n /* All tokens lexed in R after calling this function will be forced to\n-   have their source_location to be P, until\n+   have their location_t to be P, until\n    cpp_stop_forcing_token_locations is called for R.  */\n \n void\n-cpp_force_token_locations (cpp_reader *r, source_location loc)\n+cpp_force_token_locations (cpp_reader *r, location_t loc)\n {\n   r->forced_token_location = loc;\n }"}, {"sha": "bea7bb81d1ccf262e6b46973db9fc78f3849d791", "filename": "libcpp/line-map.c", "status": "modified", "additions": 148, "deletions": 148, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -28,21 +28,21 @@ along with this program; see the file COPYING3.  If not see\n \n static void trace_include (const struct line_maps *, const line_map_ordinary *);\n static const line_map_ordinary * linemap_ordinary_map_lookup (struct line_maps *,\n-\t\t\t\t\t\t\t      source_location);\n+\t\t\t\t\t\t\t      location_t);\n static const line_map_macro* linemap_macro_map_lookup (struct line_maps *,\n-\t\t\t\t\t\t       source_location);\n-static source_location linemap_macro_map_loc_to_def_point\n-(const line_map_macro *, source_location);\n-static source_location linemap_macro_map_loc_to_exp_point\n-(const line_map_macro *, source_location);\n-static source_location linemap_macro_loc_to_spelling_point\n-(struct line_maps *, source_location, const line_map_ordinary **);\n-static source_location linemap_macro_loc_to_def_point (struct line_maps *,\n-\t\t\t\t\t\t       source_location,\n-\t\t\t\t\t\t       const line_map_ordinary **);\n-static source_location linemap_macro_loc_to_exp_point (struct line_maps *,\n-\t\t\t\t\t\t       source_location,\n-\t\t\t\t\t\t       const line_map_ordinary **);\n+\t\t\t\t\t\t       location_t);\n+static location_t linemap_macro_map_loc_to_def_point\n+(const line_map_macro *, location_t);\n+static location_t linemap_macro_map_loc_to_exp_point\n+(const line_map_macro *, location_t);\n+static location_t linemap_macro_loc_to_spelling_point\n+(struct line_maps *, location_t, const line_map_ordinary **);\n+static location_t linemap_macro_loc_to_def_point (line_maps *,\n+\t\t\t\t\t\t  location_t,\n+\t\t\t\t\t\t  const line_map_ordinary **);\n+static location_t linemap_macro_loc_to_exp_point (line_maps *,\n+\t\t\t\t\t\t  location_t,\n+\t\t\t\t\t\t  const line_map_ordinary **);\n \n /* Counters defined in macro.c.  */\n extern unsigned num_expanded_macros_counter;\n@@ -110,16 +110,16 @@ rebuild_location_adhoc_htab (struct line_maps *set)\n \n /* Helper function for get_combined_adhoc_loc.\n    Can the given LOCUS + SRC_RANGE and DATA pointer be stored compactly\n-   within a source_location, without needing to use an ad-hoc location.  */\n+   within a location_t, without needing to use an ad-hoc location.  */\n \n static bool\n can_be_stored_compactly_p (struct line_maps *set,\n-\t\t\t   source_location locus,\n+\t\t\t   location_t locus,\n \t\t\t   source_range src_range,\n \t\t\t   void *data)\n {\n   /* If there's an ad-hoc pointer, we can't store it directly in the\n-     source_location, we need the lookaside.  */\n+     location_t, we need the lookaside.  */\n   if (data)\n     return false;\n \n@@ -139,7 +139,7 @@ can_be_stored_compactly_p (struct line_maps *set,\n \n   /* All 3 locations must be within ordinary maps, typically, the same\n      ordinary map.  */\n-  source_location lowest_macro_loc = LINEMAPS_MACRO_LOWEST_LOCATION (set);\n+  location_t lowest_macro_loc = LINEMAPS_MACRO_LOWEST_LOCATION (set);\n   if (locus >= lowest_macro_loc)\n     return false;\n   if (src_range.m_start >= lowest_macro_loc)\n@@ -153,9 +153,9 @@ can_be_stored_compactly_p (struct line_maps *set,\n \n /* Combine LOCUS and DATA to a combined adhoc loc.  */\n \n-source_location\n+location_t\n get_combined_adhoc_loc (struct line_maps *set,\n-\t\t\tsource_location locus,\n+\t\t\tlocation_t locus,\n \t\t\tsource_range src_range,\n \t\t\tvoid *data)\n {\n@@ -164,7 +164,7 @@ get_combined_adhoc_loc (struct line_maps *set,\n \n   if (IS_ADHOC_LOC (locus))\n     locus\n-      = set->location_adhoc_data_map.data[locus & MAX_SOURCE_LOCATION].locus;\n+      = set->location_adhoc_data_map.data[locus & MAX_LOCATION_T].locus;\n   if (locus == 0 && data == NULL)\n     return 0;\n \n@@ -186,7 +186,7 @@ get_combined_adhoc_loc (struct line_maps *set,\n       unsigned int col_diff = (int_diff >> ordmap->m_range_bits);\n       if (col_diff < (1U << ordmap->m_range_bits))\n \t{\n-\t  source_location packed = locus | col_diff;\n+\t  location_t packed = locus | col_diff;\n \t  set->num_optimized_ranges++;\n \t  return packed;\n \t}\n@@ -243,36 +243,36 @@ get_combined_adhoc_loc (struct line_maps *set,\n /* Return the data for the adhoc loc.  */\n \n void *\n-get_data_from_adhoc_loc (struct line_maps *set, source_location loc)\n+get_data_from_adhoc_loc (struct line_maps *set, location_t loc)\n {\n   linemap_assert (IS_ADHOC_LOC (loc));\n-  return set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].data;\n+  return set->location_adhoc_data_map.data[loc & MAX_LOCATION_T].data;\n }\n \n /* Return the location for the adhoc loc.  */\n \n-source_location\n-get_location_from_adhoc_loc (struct line_maps *set, source_location loc)\n+location_t\n+get_location_from_adhoc_loc (struct line_maps *set, location_t loc)\n {\n   linemap_assert (IS_ADHOC_LOC (loc));\n-  return set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].locus;\n+  return set->location_adhoc_data_map.data[loc & MAX_LOCATION_T].locus;\n }\n \n /* Return the source_range for adhoc location LOC.  */\n \n static source_range\n-get_range_from_adhoc_loc (struct line_maps *set, source_location loc)\n+get_range_from_adhoc_loc (struct line_maps *set, location_t loc)\n {\n   linemap_assert (IS_ADHOC_LOC (loc));\n-  return set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].src_range;\n+  return set->location_adhoc_data_map.data[loc & MAX_LOCATION_T].src_range;\n }\n \n /* Get the source_range of location LOC, either from the ad-hoc\n    lookaside table, or embedded inside LOC itself.  */\n \n source_range\n get_range_from_loc (struct line_maps *set,\n-\t\t    source_location loc)\n+\t\t    location_t loc)\n {\n   if (IS_ADHOC_LOC (loc))\n     return get_range_from_adhoc_loc (set, loc);\n@@ -298,7 +298,7 @@ get_range_from_loc (struct line_maps *set,\n    whether it is an ad-hoc location, or embeds range information.  */\n \n bool\n-pure_location_p (line_maps *set, source_location loc)\n+pure_location_p (line_maps *set, location_t loc)\n {\n   if (IS_ADHOC_LOC (loc))\n     return false;\n@@ -317,12 +317,12 @@ pure_location_p (line_maps *set, source_location loc)\n /* Given location LOC within SET, strip away any packed range information\n    or ad-hoc information.  */\n \n-source_location\n-get_pure_location (line_maps *set, source_location loc)\n+location_t\n+get_pure_location (line_maps *set, location_t loc)\n {\n   if (IS_ADHOC_LOC (loc))\n     loc\n-      = set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].locus;\n+      = set->location_adhoc_data_map.data[loc & MAX_LOCATION_T].locus;\n \n   if (loc >= LINEMAPS_MACRO_LOWEST_LOCATION (set))\n     return loc;\n@@ -340,7 +340,7 @@ get_pure_location (line_maps *set, source_location loc)\n \n void\n linemap_init (struct line_maps *set,\n-\t      source_location builtin_location)\n+\t      location_t builtin_location)\n {\n #if __GNUC__ == 4 && __GNUC_MINOR__ == 2 && !defined (__clang__)\n   /* PR33916, needed to fix PR82939.  */\n@@ -386,7 +386,7 @@ linemap_check_files_exited (struct line_maps *set)\n    macro maps are allocated in different memory location.  */\n \n static struct line_map *\n-new_linemap (struct line_maps *set,  source_location start_location)\n+new_linemap (struct line_maps *set,  location_t start_location)\n {\n   bool macro_p = start_location >= LINE_MAP_MAX_LOCATION;\n   unsigned num_maps_allocated = LINEMAPS_ALLOCATED (set, macro_p);\n@@ -464,7 +464,7 @@ linemap_add (struct line_maps *set, enum lc_reason reason,\n {\n   /* Generate a start_location above the current highest_location.\n      If possible, make the low range bits be zero.  */\n-  source_location start_location;\n+  location_t start_location;\n   if (set->highest_location < LINE_MAP_MAX_LOCATION_WITH_COLS)\n     {\n       start_location = set->highest_location + (1 << set->default_range_bits);\n@@ -610,9 +610,9 @@ linemap_tracks_macro_expansion_locs_p (struct line_maps *set)\n \n const line_map_macro *\n linemap_enter_macro (struct line_maps *set, struct cpp_hashnode *macro_node,\n-\t\t     source_location expansion, unsigned int num_tokens)\n+\t\t     location_t expansion, unsigned int num_tokens)\n {\n-  source_location start_location\n+  location_t start_location\n     = LINEMAPS_MACRO_LOWEST_LOCATION (set) - num_tokens;\n \n   if (start_location < LINE_MAP_MAX_LOCATION)\n@@ -624,12 +624,12 @@ linemap_enter_macro (struct line_maps *set, struct cpp_hashnode *macro_node,\n   map->macro = macro_node;\n   map->n_tokens = num_tokens;\n   map->macro_locations\n-    = (source_location*) set->reallocator (NULL,\n+    = (location_t*) set->reallocator (NULL,\n \t\t\t\t\t   2 * num_tokens\n-\t\t\t\t\t   * sizeof (source_location));\n+\t\t\t\t\t   * sizeof (location_t));\n   map->expansion = expansion;\n   memset (MACRO_MAP_LOCATIONS (map), 0,\n-\t  2 * num_tokens * sizeof (source_location));\n+\t  2 * num_tokens * sizeof (location_t));\n \n   LINEMAPS_MACRO_CACHE (set) = LINEMAPS_MACRO_USED (set) - 1;\n \n@@ -659,13 +659,13 @@ linemap_enter_macro (struct line_maps *set, struct cpp_hashnode *macro_node,\n    either of the token itself or of a macro parameter that it\n    replaces.  */\n \n-source_location\n+location_t\n linemap_add_macro_token (const line_map_macro *map,\n \t\t\t unsigned int token_no,\n-\t\t\t source_location orig_loc,\n-\t\t\t source_location orig_parm_replacement_loc)\n+\t\t\t location_t orig_loc,\n+\t\t\t location_t orig_parm_replacement_loc)\n {\n-  source_location result;\n+  location_t result;\n \n   linemap_assert (linemap_macro_expansion_map_p (map));\n   linemap_assert (token_no < MACRO_MAP_NUM_MACRO_TOKENS (map));\n@@ -677,19 +677,19 @@ linemap_add_macro_token (const line_map_macro *map,\n   return result;\n }\n \n-/* Return a source_location for the start (i.e. column==0) of\n+/* Return a location_t for the start (i.e. column==0) of\n    (physical) line TO_LINE in the current source file (as in the\n    most recent linemap_add).   MAX_COLUMN_HINT is the highest column\n    number we expect to use in this line (but it does not change\n    the highest_location).  */\n \n-source_location\n+location_t\n linemap_line_start (struct line_maps *set, linenum_type to_line,\n \t\t    unsigned int max_column_hint)\n {\n   line_map_ordinary *map = LINEMAPS_LAST_ORDINARY_MAP (set);\n-  source_location highest = set->highest_location;\n-  source_location r;\n+  location_t highest = set->highest_location;\n+  location_t r;\n   linenum_type last_line =\n     SOURCE_LINE (map, set->highest_line);\n   int line_delta = to_line - last_line;\n@@ -717,7 +717,7 @@ linemap_line_start (struct line_maps *set, linenum_type to_line,\n \t  || highest > LINE_MAP_MAX_LOCATION_WITH_COLS)\n \t{\n \t  /* If the column number is ridiculous or we've allocated a huge\n-\t     number of source_locations, give up on column numbers\n+\t     number of location_ts, give up on column numbers\n \t     (and on packed ranges).  */\n \t  max_column_hint = 0;\n \t  column_bits = 0;\n@@ -782,15 +782,15 @@ linemap_line_start (struct line_maps *set, linenum_type to_line,\n   return r;\n }\n \n-/* Encode and return a source_location from a column number. The\n+/* Encode and return a location_t from a column number. The\n    source line considered is the last source line used to call\n    linemap_line_start, i.e, the last source line which a location was\n    encoded from.  */\n \n-source_location\n+location_t\n linemap_position_for_column (struct line_maps *set, unsigned int to_column)\n {\n-  source_location r = set->highest_line;\n+  location_t r = set->highest_line;\n \n   linemap_assert\n     (!linemap_macro_expansion_map_p (LINEMAPS_LAST_ORDINARY_MAP (set)));\n@@ -800,7 +800,7 @@ linemap_position_for_column (struct line_maps *set, unsigned int to_column)\n       if (r > LINE_MAP_MAX_LOCATION_WITH_COLS\n \t  || to_column > LINE_MAP_MAX_COLUMN_NUMBER)\n \t{\n-\t  /* Running low on source_locations - disable column numbers.  */\n+\t  /* Running low on location_ts - disable column numbers.  */\n \t  return r;\n \t}\n       else\n@@ -833,41 +833,41 @@ linemap_position_for_column (struct line_maps *set, unsigned int to_column)\n /* Encode and return a source location from a given line and\n    column.  */\n \n-source_location\n+location_t\n linemap_position_for_line_and_column (line_maps *set,\n \t\t\t\t      const line_map_ordinary *ord_map,\n \t\t\t\t      linenum_type line,\n \t\t\t\t      unsigned column)\n {\n   linemap_assert (ORDINARY_MAP_STARTING_LINE_NUMBER (ord_map) <= line);\n \n-  source_location r = MAP_START_LOCATION (ord_map);\n+  location_t r = MAP_START_LOCATION (ord_map);\n   r += ((line - ORDINARY_MAP_STARTING_LINE_NUMBER (ord_map))\n \t<< ord_map->m_column_and_range_bits);\n   if (r <= LINE_MAP_MAX_LOCATION_WITH_COLS)\n     r += ((column & ((1 << ord_map->m_column_and_range_bits) - 1))\n \t  << ord_map->m_range_bits);\n-  source_location upper_limit = LINEMAPS_MACRO_LOWEST_LOCATION (set);\n+  location_t upper_limit = LINEMAPS_MACRO_LOWEST_LOCATION (set);\n   if (r >= upper_limit)\n     r = upper_limit - 1;\n   if (r > set->highest_location)\n     set->highest_location = r;\n   return r;\n }\n \n-/* Encode and return a source_location starting from location LOC and\n+/* Encode and return a location_t starting from location LOC and\n    shifting it by COLUMN_OFFSET columns.  This function does not support\n    virtual locations.  */\n \n-source_location\n+location_t\n linemap_position_for_loc_and_offset (struct line_maps *set,\n-\t\t\t\t     source_location loc,\n+\t\t\t\t     location_t loc,\n \t\t\t\t     unsigned int column_offset)\n {\n   const line_map_ordinary * map = NULL;\n \n   if (IS_ADHOC_LOC (loc))\n-    loc = set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].locus;\n+    loc = set->location_adhoc_data_map.data[loc & MAX_LOCATION_T].locus;\n \n   /* This function does not support virtual locations yet.  */\n   if (linemap_location_from_macro_expansion_p (set, loc))\n@@ -913,7 +913,7 @@ linemap_position_for_loc_and_offset (struct line_maps *set,\n   if (column >= (1u << (map->m_column_and_range_bits - map->m_range_bits)))\n     return loc;\n \n-  source_location r = \n+  location_t r = \n     linemap_position_for_line_and_column (set, map, line, column);\n   if (linemap_assert_fails (r <= set->highest_location)\n       || linemap_assert_fails (map == linemap_lookup (set, r)))\n@@ -926,10 +926,10 @@ linemap_position_for_loc_and_offset (struct line_maps *set,\n    ordinary or a macro map), returns that map.  */\n \n const struct line_map*\n-linemap_lookup (struct line_maps *set, source_location line)\n+linemap_lookup (struct line_maps *set, location_t line)\n {\n   if (IS_ADHOC_LOC (line))\n-    line = set->location_adhoc_data_map.data[line & MAX_SOURCE_LOCATION].locus;\n+    line = set->location_adhoc_data_map.data[line & MAX_LOCATION_T].locus;\n   if (linemap_location_from_macro_expansion_p (set, line))\n     return linemap_macro_map_lookup (set, line);\n   return linemap_ordinary_map_lookup (set, line);\n@@ -941,13 +941,13 @@ linemap_lookup (struct line_maps *set, source_location line)\n    binary search.  */\n \n static const line_map_ordinary *\n-linemap_ordinary_map_lookup (struct line_maps *set, source_location line)\n+linemap_ordinary_map_lookup (struct line_maps *set, location_t line)\n {\n   unsigned int md, mn, mx;\n   const line_map_ordinary *cached, *result;\n \n   if (IS_ADHOC_LOC (line))\n-    line = set->location_adhoc_data_map.data[line & MAX_SOURCE_LOCATION].locus;\n+    line = set->location_adhoc_data_map.data[line & MAX_LOCATION_T].locus;\n \n   if (set ==  NULL || line < RESERVED_LOCATION_COUNT)\n     return NULL;\n@@ -989,13 +989,13 @@ linemap_ordinary_map_lookup (struct line_maps *set, source_location line)\n    binary search.  */\n \n static const line_map_macro *\n-linemap_macro_map_lookup (struct line_maps *set, source_location line)\n+linemap_macro_map_lookup (struct line_maps *set, location_t line)\n {\n   unsigned int md, mn, mx;\n   const struct line_map_macro *cached, *result;\n \n   if (IS_ADHOC_LOC (line))\n-    line = set->location_adhoc_data_map.data[line & MAX_SOURCE_LOCATION].locus;\n+    line = set->location_adhoc_data_map.data[line & MAX_LOCATION_T].locus;\n \n   linemap_assert (line >= LINEMAPS_MACRO_LOWEST_LOCATION (set));\n \n@@ -1045,9 +1045,9 @@ linemap_macro_expansion_map_p (const struct line_map *map)\n    Read the comments of struct line_map and struct line_map_macro in\n    line-map.h to understand what a macro expansion point is.  */\n \n-static source_location\n+static location_t\n linemap_macro_map_loc_to_exp_point (const line_map_macro *map,\n-\t\t\t\t    source_location location ATTRIBUTE_UNUSED)\n+\t\t\t\t    location_t location ATTRIBUTE_UNUSED)\n {\n   linemap_assert (linemap_macro_expansion_map_p (map)\n \t\t  && location >= MAP_START_LOCATION (map));\n@@ -1065,9 +1065,9 @@ linemap_macro_map_loc_to_exp_point (const line_map_macro *map,\n    Return the location of the token at the definition point of the\n    macro.  */\n \n-static source_location\n+static location_t\n linemap_macro_map_loc_to_def_point (const line_map_macro *map,\n-\t\t\t\t    source_location location)\n+\t\t\t\t    location_t location)\n {\n   unsigned token_no;\n \n@@ -1089,10 +1089,10 @@ linemap_macro_map_loc_to_def_point (const line_map_macro *map,\n \n    In other words, this returns the xI location presented in the\n    comments of line_map_macro above.  */\n-source_location\n+location_t\n linemap_macro_map_loc_unwind_toward_spelling (line_maps *set,\n \t\t\t\t\t      const line_map_macro* map,\n-\t\t\t\t\t      source_location location)\n+\t\t\t\t\t      location_t location)\n {\n   unsigned token_no;\n \n@@ -1120,13 +1120,13 @@ linemap_macro_map_loc_unwind_toward_spelling (line_maps *set,\n \n int\n linemap_get_expansion_line (struct line_maps *set,\n-\t\t\t    source_location location)\n+\t\t\t    location_t location)\n {\n   const line_map_ordinary *map = NULL;\n \n   if (IS_ADHOC_LOC (location))\n     location = set->location_adhoc_data_map.data[location\n-\t\t\t\t\t\t & MAX_SOURCE_LOCATION].locus;\n+\t\t\t\t\t\t & MAX_LOCATION_T].locus;\n \n   if (location < RESERVED_LOCATION_COUNT)\n     return 0;\n@@ -1148,13 +1148,13 @@ linemap_get_expansion_line (struct line_maps *set,\n \n const char*\n linemap_get_expansion_filename (struct line_maps *set,\n-\t\t\t\tsource_location location)\n+\t\t\t\tlocation_t location)\n {\n   const struct line_map_ordinary *map = NULL;\n \n   if (IS_ADHOC_LOC (location))\n     location = set->location_adhoc_data_map.data[location\n-\t\t\t\t\t\t & MAX_SOURCE_LOCATION].locus;\n+\t\t\t\t\t\t & MAX_LOCATION_T].locus;\n \n   if (location < RESERVED_LOCATION_COUNT)\n     return NULL;\n@@ -1186,13 +1186,13 @@ linemap_map_get_macro_name (const line_map_macro *macro_map)\n \n int\n linemap_location_in_system_header_p (struct line_maps *set,\n-\t\t\t\t     source_location location)\n+\t\t\t\t     location_t location)\n {\n   const struct line_map *map = NULL;\n \n   if (IS_ADHOC_LOC (location))\n     location = set->location_adhoc_data_map.data[location\n-\t\t\t\t\t\t & MAX_SOURCE_LOCATION].locus;\n+\t\t\t\t\t\t & MAX_LOCATION_T].locus;\n \n   if (location < RESERVED_LOCATION_COUNT)\n     return false;\n@@ -1211,7 +1211,7 @@ linemap_location_in_system_header_p (struct line_maps *set,\n \t      const line_map_macro *macro_map = linemap_check_macro (map);\n \n \t      /* It's a token resulting from a macro expansion.  */\n-\t      source_location loc =\n+\t      location_t loc =\n \t\tlinemap_macro_map_loc_unwind_toward_spelling (set, macro_map, location);\n \t      if (loc < RESERVED_LOCATION_COUNT)\n \t\t/* This token might come from a built-in macro.  Let's\n@@ -1232,11 +1232,11 @@ linemap_location_in_system_header_p (struct line_maps *set,\n \n bool\n linemap_location_from_macro_expansion_p (const struct line_maps *set,\n-\t\t\t\t\t source_location location)\n+\t\t\t\t\t location_t location)\n {\n   if (IS_ADHOC_LOC (location))\n     location = set->location_adhoc_data_map.data[location\n-\t\t\t\t\t\t & MAX_SOURCE_LOCATION].locus;\n+\t\t\t\t\t\t & MAX_LOCATION_T].locus;\n \n   return IS_MACRO_LOC (location);\n }\n@@ -1248,10 +1248,10 @@ linemap_location_from_macro_expansion_p (const struct line_maps *set,\n \n static const struct line_map*\n first_map_in_common_1 (struct line_maps *set,\n-\t\t       source_location *loc0,\n-\t\t       source_location *loc1)\n+\t\t       location_t *loc0,\n+\t\t       location_t *loc1)\n {\n-  source_location l0 = *loc0, l1 = *loc1;\n+  location_t l0 = *loc0, l1 = *loc1;\n   const struct line_map *map0 = linemap_lookup (set, l0),\n     *map1 = linemap_lookup (set, l1);\n \n@@ -1290,10 +1290,10 @@ first_map_in_common_1 (struct line_maps *set,\n \n static const struct line_map*\n first_map_in_common (struct line_maps *set,\n-\t\t     source_location loc0,\n-\t\t     source_location loc1,\n-\t\t     source_location  *res_loc0,\n-\t\t     source_location  *res_loc1)\n+\t\t     location_t loc0,\n+\t\t     location_t loc1,\n+\t\t     location_t  *res_loc0,\n+\t\t     location_t  *res_loc1)\n {\n   *res_loc0 = loc0;\n   *res_loc1 = loc1;\n@@ -1308,11 +1308,11 @@ first_map_in_common (struct line_maps *set,\n \n int\n linemap_compare_locations (struct line_maps *set,\n-\t\t\t   source_location  pre,\n-\t\t\t   source_location post)\n+\t\t\t   location_t  pre,\n+\t\t\t   location_t post)\n {\n   bool pre_virtual_p, post_virtual_p;\n-  source_location l0 = pre, l1 = post;\n+  location_t l0 = pre, l1 = post;\n \n   if (IS_ADHOC_LOC (l0))\n     l0 = get_location_from_adhoc_loc (set, l0);\n@@ -1378,9 +1378,9 @@ trace_include (const struct line_maps *set, const line_map_ordinary *map)\n \n    This is a subroutine for linemap_resolve_location.  */\n \n-static source_location\n+static location_t\n linemap_macro_loc_to_spelling_point (struct line_maps *set,\n-\t\t\t\t     source_location location,\n+\t\t\t\t     location_t location,\n \t\t\t\t     const line_map_ordinary **original_map)\n {\n   linemap_assert (set && location >= RESERVED_LOCATION_COUNT);\n@@ -1412,16 +1412,16 @@ linemap_macro_loc_to_spelling_point (struct line_maps *set,\n \n    This is a subroutine of linemap_resolve_location.  */\n \n-static source_location\n+static location_t\n linemap_macro_loc_to_def_point (struct line_maps *set,\n-\t\t\t\tsource_location location,\n+\t\t\t\tlocation_t location,\n \t\t\t\tconst line_map_ordinary **original_map)\n {\n   linemap_assert (set && location >= RESERVED_LOCATION_COUNT);\n \n   for (;;)\n     {\n-      source_location caret_loc = location;\n+      location_t caret_loc = location;\n       if (IS_ADHOC_LOC (caret_loc))\n \tcaret_loc = get_location_from_adhoc_loc (set, caret_loc);\n \n@@ -1454,16 +1454,16 @@ linemap_macro_loc_to_def_point (struct line_maps *set,\n \n    This is a subroutine of linemap_resolve_location.  */\n \n-static source_location\n+static location_t\n linemap_macro_loc_to_exp_point (struct line_maps *set,\n-\t\t\t\tsource_location location,\n+\t\t\t\tlocation_t location,\n \t\t\t\tconst line_map_ordinary **original_map)\n {\n   struct line_map *map;\n \n   if (IS_ADHOC_LOC (location))\n     location = set->location_adhoc_data_map.data[location\n-\t\t\t\t\t\t & MAX_SOURCE_LOCATION].locus;\n+\t\t\t\t\t\t & MAX_LOCATION_T].locus;\n \n   linemap_assert (set && location >= RESERVED_LOCATION_COUNT);\n \n@@ -1529,15 +1529,15 @@ linemap_macro_loc_to_exp_point (struct line_maps *set,\n    resolves to a location reserved for the client code, like\n    UNKNOWN_LOCATION or BUILTINS_LOCATION in GCC.  */\n \n-source_location\n+location_t\n linemap_resolve_location (struct line_maps *set,\n-\t\t\t  source_location loc,\n+\t\t\t  location_t loc,\n \t\t\t  enum location_resolution_kind lrk,\n \t\t\t  const line_map_ordinary **map)\n {\n-  source_location locus = loc;\n+  location_t locus = loc;\n   if (IS_ADHOC_LOC (loc))\n-    locus = set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].locus;\n+    locus = set->location_adhoc_data_map.data[loc & MAX_LOCATION_T].locus;\n \n   if (locus < RESERVED_LOCATION_COUNT)\n     {\n@@ -1571,7 +1571,7 @@ linemap_resolve_location (struct line_maps *set,\n \n bool\n linemap_location_from_macro_definition_p (struct line_maps *set,\n-\t\t\t\t\t  source_location loc)\n+\t\t\t\t\t  location_t loc)\n {\n   if (IS_ADHOC_LOC (loc))\n     loc = get_location_from_adhoc_loc (set, loc);\n@@ -1584,13 +1584,13 @@ linemap_location_from_macro_definition_p (struct line_maps *set,\n       const struct line_map_macro *map\n \t= linemap_check_macro (linemap_lookup (set, loc));\n \n-      source_location s_loc\n+      location_t s_loc\n \t= linemap_macro_map_loc_unwind_toward_spelling (set, map, loc);\n       if (linemap_location_from_macro_expansion_p (set, s_loc))\n \tloc = s_loc;\n       else\n \t{\n-\t  source_location def_loc\n+\t  location_t def_loc\n \t    = linemap_macro_map_loc_to_def_point (map, loc);\n \t  return s_loc == def_loc;\n \t}\n@@ -1609,17 +1609,17 @@ linemap_location_from_macro_definition_p (struct line_maps *set,\n    *LOC_MAP must be set to the map of LOC.  This function then sets it\n    to the map of the returned location.  */\n \n-source_location\n+location_t\n linemap_unwind_toward_expansion (struct line_maps *set,\n-\t\t\t\t source_location loc,\n+\t\t\t\t location_t loc,\n \t\t\t\t const struct line_map **map)\n {\n-  source_location resolved_location;\n+  location_t resolved_location;\n   const line_map_macro *macro_map = linemap_check_macro (*map);\n   const struct line_map *resolved_map;\n \n   if (IS_ADHOC_LOC (loc))\n-    loc = set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].locus;\n+    loc = set->location_adhoc_data_map.data[loc & MAX_LOCATION_T].locus;\n \n   resolved_location =\n     linemap_macro_map_loc_unwind_toward_spelling (set, macro_map, loc);\n@@ -1649,17 +1649,17 @@ linemap_unwind_toward_expansion (struct line_maps *set,\n \n    *MAP is set to the map of the returned location if the later is\n    different from LOC.  */\n-source_location\n+location_t\n linemap_unwind_to_first_non_reserved_loc (struct line_maps *set,\n-\t\t\t\t\t  source_location loc,\n+\t\t\t\t\t  location_t loc,\n \t\t\t\t\t  const struct line_map **map)\n {\n-  source_location resolved_loc;\n+  location_t resolved_loc;\n   const struct line_map *map0 = NULL;\n   const line_map_ordinary *map1 = NULL;\n \n   if (IS_ADHOC_LOC (loc))\n-    loc = set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].locus;\n+    loc = set->location_adhoc_data_map.data[loc & MAX_LOCATION_T].locus;\n \n   map0 = linemap_lookup (set, loc);\n   if (!linemap_macro_expansion_map_p (map0))\n@@ -1696,7 +1696,7 @@ linemap_unwind_to_first_non_reserved_loc (struct line_maps *set,\n expanded_location\n linemap_expand_location (struct line_maps *set,\n \t\t\t const struct line_map *map,\n-\t\t\t source_location loc)\n+\t\t\t location_t loc)\n \n {\n   expanded_location xloc;\n@@ -1705,8 +1705,8 @@ linemap_expand_location (struct line_maps *set,\n   if (IS_ADHOC_LOC (loc))\n     {\n       xloc.data\n-\t= set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].data;\n-      loc = set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].locus;\n+\t= set->location_adhoc_data_map.data[loc & MAX_LOCATION_T].data;\n+      loc = set->location_adhoc_data_map.data[loc & MAX_LOCATION_T].locus;\n     }\n \n   if (loc < RESERVED_LOCATION_COUNT)\n@@ -1801,16 +1801,16 @@ linemap_dump (FILE *stream, struct line_maps *set, unsigned ix, bool is_macro)\n \n void\n linemap_dump_location (struct line_maps *set,\n-\t\t       source_location loc,\n+\t\t       location_t loc,\n \t\t       FILE *stream)\n {\n   const line_map_ordinary *map;\n-  source_location location;\n+  location_t location;\n   const char *path = \"\", *from = \"\";\n   int l = -1, c = -1, s = -1, e = -1;\n \n   if (IS_ADHOC_LOC (loc))\n-    loc = set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].locus;\n+    loc = set->location_adhoc_data_map.data[loc & MAX_LOCATION_T].locus;\n \n   if (loc == 0)\n     return;\n@@ -1852,7 +1852,7 @@ linemap_dump_location (struct line_maps *set,\n bool\n linemap_get_file_highest_location (struct line_maps *set,\n \t\t\t\t   const char *file_name,\n-\t\t\t\t   source_location *loc)\n+\t\t\t\t   location_t *loc)\n {\n   /* If the set is empty or no ordinary map has been created then\n      there is no file to look for ...  */\n@@ -1874,7 +1874,7 @@ linemap_get_file_highest_location (struct line_maps *set,\n   /* The highest location for a given map is either the starting\n      location of the next map minus one, or -- if the map is the\n      latest one -- the highest location of the set.  */\n-  source_location result;\n+  location_t result;\n   if (i == (int) set->info_ordinary.used - 1)\n     result = set->highest_location;\n   else\n@@ -1915,14 +1915,14 @@ linemap_get_statistics (struct line_maps *set,\n       linemap_assert (linemap_macro_expansion_map_p (cur_map));\n \n       macro_maps_locations_size +=\n-\t2 * MACRO_MAP_NUM_MACRO_TOKENS (cur_map) * sizeof (source_location);\n+\t2 * MACRO_MAP_NUM_MACRO_TOKENS (cur_map) * sizeof (location_t);\n \n       for (i = 0; i < 2 * MACRO_MAP_NUM_MACRO_TOKENS (cur_map); i += 2)\n \t{\n \t  if (MACRO_MAP_LOCATIONS (cur_map)[i] ==\n \t      MACRO_MAP_LOCATIONS (cur_map)[i + 1])\n \t    duplicated_macro_maps_locations_size +=\n-\t      sizeof (source_location);\n+\t      sizeof (location_t);\n \t}\n     }\n \n@@ -1989,7 +1989,7 @@ line_table_dump (FILE *stream, struct line_maps *set, unsigned int num_ordinary,\n \n /* Construct a rich_location with location LOC as its initial range.  */\n \n-rich_location::rich_location (line_maps *set, source_location loc,\n+rich_location::rich_location (line_maps *set, location_t loc,\n \t\t\t      const range_label *label) :\n   m_line_table (set),\n   m_ranges (),\n@@ -2012,7 +2012,7 @@ rich_location::~rich_location ()\n \n /* Get location IDX within this rich_location.  */\n \n-source_location\n+location_t\n rich_location::get_loc (unsigned int idx) const\n {\n   const location_range *locrange = get_range (idx);\n@@ -2075,7 +2075,7 @@ rich_location::override_column (int column)\n /* Add the given range.  */\n \n void\n-rich_location::add_range (source_location loc,\n+rich_location::add_range (location_t loc,\n \t\t\t  enum range_display_kind range_display_kind,\n \t\t\t  const range_label *label)\n {\n@@ -2100,7 +2100,7 @@ rich_location::add_range (source_location loc,\n    - the \"%C\" and \"%L\" format codes in the Fortran frontend.  */\n \n void\n-rich_location::set_range (unsigned int idx, source_location loc,\n+rich_location::set_range (unsigned int idx, location_t loc,\n \t\t\t  enum range_display_kind range_display_kind)\n {\n   /* We can either overwrite an existing range, or add one exactly\n@@ -2136,10 +2136,10 @@ rich_location::add_fixit_insert_before (const char *new_content)\n    immediately before the start of WHERE.  */\n \n void\n-rich_location::add_fixit_insert_before (source_location where,\n+rich_location::add_fixit_insert_before (location_t where,\n \t\t\t\t\tconst char *new_content)\n {\n-  source_location start = get_range_from_loc (m_line_table, where).m_start;\n+  location_t start = get_range_from_loc (m_line_table, where).m_start;\n   maybe_add_fixit (start, start, new_content);\n }\n \n@@ -2156,11 +2156,11 @@ rich_location::add_fixit_insert_after (const char *new_content)\n    immediately after the end-point of WHERE.  */\n \n void\n-rich_location::add_fixit_insert_after (source_location where,\n+rich_location::add_fixit_insert_after (location_t where,\n \t\t\t\t       const char *new_content)\n {\n-  source_location finish = get_range_from_loc (m_line_table, where).m_finish;\n-  source_location next_loc\n+  location_t finish = get_range_from_loc (m_line_table, where).m_finish;\n+  location_t next_loc\n     = linemap_position_for_loc_and_offset (m_line_table, finish, 1);\n \n   /* linemap_position_for_loc_and_offset can fail, if so, it returns\n@@ -2189,7 +2189,7 @@ rich_location::add_fixit_remove ()\n    the start and finish of WHERE.  */\n \n void\n-rich_location::add_fixit_remove (source_location where)\n+rich_location::add_fixit_remove (location_t where)\n {\n   source_range range = get_range_from_loc (m_line_table, where);\n   add_fixit_remove (range);\n@@ -2219,7 +2219,7 @@ rich_location::add_fixit_replace (const char *new_content)\n    the start and finish of WHERE with NEW_CONTENT.  */\n \n void\n-rich_location::add_fixit_replace (source_location where,\n+rich_location::add_fixit_replace (location_t where,\n \t\t\t\t  const char *new_content)\n {\n   source_range range = get_range_from_loc (m_line_table, where);\n@@ -2233,11 +2233,11 @@ void\n rich_location::add_fixit_replace (source_range src_range,\n \t\t\t\t  const char *new_content)\n {\n-  source_location start = get_pure_location (m_line_table, src_range.m_start);\n-  source_location finish = get_pure_location (m_line_table, src_range.m_finish);\n+  location_t start = get_pure_location (m_line_table, src_range.m_start);\n+  location_t finish = get_pure_location (m_line_table, src_range.m_finish);\n \n   /* Fix-it hints use half-closed ranges, so attempt to offset the endpoint.  */\n-  source_location next_loc\n+  location_t next_loc\n     = linemap_position_for_loc_and_offset (m_line_table, finish, 1);\n   /* linemap_position_for_loc_and_offset can fail, if so, it returns\n      its input value.  */\n@@ -2268,7 +2268,7 @@ rich_location::get_last_fixit_hint () const\n    Otherwise (the common case), return false.  */\n \n bool\n-rich_location::reject_impossible_fixit (source_location where)\n+rich_location::reject_impossible_fixit (location_t where)\n {\n   /* Fix-its within a rich_location should either all be suggested, or\n      none of them should be suggested.\n@@ -2306,8 +2306,8 @@ rich_location::stop_supporting_fixits ()\n    consolidating into the prior fixit if possible.  */\n \n void\n-rich_location::maybe_add_fixit (source_location start,\n-\t\t\t\tsource_location next_loc,\n+rich_location::maybe_add_fixit (location_t start,\n+\t\t\t\tlocation_t next_loc,\n \t\t\t\tconst char *new_content)\n {\n   if (reject_impossible_fixit (start))\n@@ -2388,8 +2388,8 @@ rich_location::maybe_add_fixit (source_location start,\n \n /* class fixit_hint.  */\n \n-fixit_hint::fixit_hint (source_location start,\n-\t\t\tsource_location next_loc,\n+fixit_hint::fixit_hint (location_t start,\n+\t\t\tlocation_t next_loc,\n \t\t\tconst char *new_content)\n : m_start (start),\n   m_next_loc (next_loc),\n@@ -2427,8 +2427,8 @@ fixit_hint::affects_line_p (const char *file, int line) const\n    Otherwise return false.  */\n \n bool\n-fixit_hint::maybe_append (source_location start,\n-\t\t\t  source_location next_loc,\n+fixit_hint::maybe_append (location_t start,\n+\t\t\t  location_t next_loc,\n \t\t\t  const char *new_content)\n {\n   /* For consolidation to be possible, START must be at this hint's"}, {"sha": "829ca53b89b1e067e23bfe0da91b3743871c5bfc", "filename": "libcpp/location-example.txt", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Flocation-example.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Flocation-example.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flocation-example.txt?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -20,17 +20,17 @@ extern int foo ();\n \n \n The undocumented -fdump-internal-locations option outputs this information\n-to stderr, showing what each source_location value means.  Source code\n-lines are quoted, showing both per-line source_location values and\n-per-line&column source_location values (written vertically under the\n+to stderr, showing what each location_t value means.  Source code\n+lines are quoted, showing both per-line location_t values and\n+per-line&column location_t values (written vertically under the\n corresponding character of source code).\n \n VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\n RESERVED LOCATIONS\n-  source_location interval: 0 <= loc < 2\n+  location_t interval: 0 <= loc < 2\n \n ORDINARY MAP: 0\n-  source_location interval: 32 <= loc < 64\n+  location_t interval: 32 <= loc < 64\n   file: test.c\n   starting at line: 1\n   column bits: 12\n@@ -40,36 +40,36 @@ test.c:  1|loc:   32|#include \"test.h\"\n                     |46802468024680246\n \n ORDINARY MAP: 1\n-  source_location interval: 64 <= loc < 96\n+  location_t interval: 64 <= loc < 96\n   file: <built-in>\n   starting at line: 0\n   column bits: 0\n   range bits: 0\n \n ORDINARY MAP: 2\n-  source_location interval: 96 <= loc < 128\n+  location_t interval: 96 <= loc < 128\n   file: <command-line>\n   starting at line: 0\n   column bits: 0\n   range bits: 0\n \n ORDINARY MAP: 3\n-  source_location interval: 128 <= loc < 160128\n+  location_t interval: 128 <= loc < 160128\n   file: /usr/include/stdc-predef.h\n   starting at line: 1\n   column bits: 12\n   range bits: 5\n (contents of /usr/include/stdc-predef.h snipped for brevity)\n \n ORDINARY MAP: 4\n-  source_location interval: 160128 <= loc < 160160\n+  location_t interval: 160128 <= loc < 160160\n   file: <command-line>\n   starting at line: 32\n   column bits: 12\n   range bits: 5\n \n ORDINARY MAP: 5\n-  source_location interval: 160160 <= loc < 164256\n+  location_t interval: 160160 <= loc < 164256\n   file: test.c\n   starting at line: 1\n   column bits: 12\n@@ -81,7 +81,7 @@ test.c:  1|loc:160160|#include \"test.h\"\n                     |24680246802468024\n \n ORDINARY MAP: 6\n-  source_location interval: 164256 <= loc < 173280\n+  location_t interval: 164256 <= loc < 173280\n   file: test.h\n   starting at line: 1\n   column bits: 12\n@@ -103,7 +103,7 @@ test.h:  3|loc:172448|#define PLUS(A, B) A + B\n                     |024680246802468024680246\n \n ORDINARY MAP: 7\n-  source_location interval: 173280 <= loc < 202016\n+  location_t interval: 173280 <= loc < 202016\n   file: test.c\n   starting at line: 2\n   column bits: 12\n@@ -150,10 +150,10 @@ test.c:  9|loc:201952|}\n                     |4\n \n UNALLOCATED LOCATIONS\n-  source_location interval: 202016 <= loc < 2147483633\n+  location_t interval: 202016 <= loc < 2147483633\n \n MACRO 1: PLUS (7 tokens)\n-  source_location interval: 2147483633 <= loc < 2147483640\n+  location_t interval: 2147483633 <= loc < 2147483640\n test.c:7:11: note: expansion point is location 194115\n    int b = PLUS (3,4);\n            ^~~~\n@@ -189,7 +189,7 @@ x-location == y-location == 2947526575 encodes token # 800042942\n x-location == y-location == 2947526575 encodes token # 800042942\n \n MACRO 0: PLUS (7 tokens)\n-  source_location interval: 2147483640 <= loc < 2147483647\n+  location_t interval: 2147483640 <= loc < 2147483647\n test.c:6:11: note: expansion point is location 190019\n    int a = PLUS (1,2);\n            ^~~~\n@@ -224,9 +224,9 @@ x-location == y-location == 2947526575 encodes token # 800042935\n     6: 2947526575, 2947526575\n x-location == y-location == 2947526575 encodes token # 800042935\n \n-MAX_SOURCE_LOCATION\n-  source_location interval: 2147483647 <= loc < 2147483648\n+MAX_LOCATION_T\n+  location_t interval: 2147483647 <= loc < 2147483648\n \n AD-HOC LOCATIONS\n-  source_location interval: 2147483648 <= loc < 4294967295\n+  location_t interval: 2147483648 <= loc < 4294967295\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "3cbf24ec95f0d493bc5887565f24f579d1f25030", "filename": "libcpp/macro.c", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -39,9 +39,9 @@ struct macro_arg\n   const cpp_token *stringified;\t/* Stringified argument.  */\n   unsigned int count;\t\t/* # of tokens in argument.  */\n   unsigned int expanded_count;\t/* # of tokens in expanded argument.  */\n-  source_location *virt_locs;\t/* Where virtual locations for\n+  location_t *virt_locs;\t/* Where virtual locations for\n \t\t\t\t   unexpanded tokens are stored.  */\n-  source_location *expanded_virt_locs; /* Where virtual locations for\n+  location_t *expanded_virt_locs; /* Where virtual locations for\n \t\t\t\t\t  expanded tokens are\n \t\t\t\t\t  stored.  */\n };\n@@ -72,7 +72,7 @@ struct macro_arg_token_iter\n   /* A pointer to the \"full\" location of the current token.  If\n      -ftrack-macro-expansion is used this location tracks loci across\n      macro expansion.  */\n-  const source_location *location_ptr;\n+  const location_t *location_ptr;\n #if CHECKING_P\n   /* The number of times the iterator went forward. This useful only\n      when checking is enabled.  */\n@@ -235,22 +235,22 @@ class vaopt_state {\n   int m_state;\n \n   /* The location of the paste token.  */\n-  source_location m_paste_location;\n+  location_t m_paste_location;\n \n   /* Location of the __VA_OPT__ token.  */\n-  source_location m_location;\n+  location_t m_location;\n };\n \n /* Macro expansion.  */\n \n static int enter_macro_context (cpp_reader *, cpp_hashnode *,\n-\t\t\t\tconst cpp_token *, source_location);\n+\t\t\t\tconst cpp_token *, location_t);\n static int builtin_macro (cpp_reader *, cpp_hashnode *,\n-\t\t\t  source_location, source_location);\n+\t\t\t  location_t, location_t);\n static void push_ptoken_context (cpp_reader *, cpp_hashnode *, _cpp_buff *,\n \t\t\t\t const cpp_token **, unsigned int);\n static void push_extended_tokens_context (cpp_reader *, cpp_hashnode *,\n-\t\t\t\t\t  _cpp_buff *, source_location *,\n+\t\t\t\t\t  _cpp_buff *, location_t *,\n \t\t\t\t\t  const cpp_token **, unsigned int);\n static _cpp_buff *collect_args (cpp_reader *, const cpp_hashnode *,\n \t\t\t\t_cpp_buff **, unsigned *);\n@@ -260,53 +260,53 @@ static void expand_arg (cpp_reader *, macro_arg *);\n static const cpp_token *new_string_token (cpp_reader *, uchar *, unsigned int);\n static const cpp_token *stringify_arg (cpp_reader *, macro_arg *);\n static void paste_all_tokens (cpp_reader *, const cpp_token *);\n-static bool paste_tokens (cpp_reader *, source_location,\n+static bool paste_tokens (cpp_reader *, location_t,\n \t\t\t  const cpp_token **, const cpp_token *);\n static void alloc_expanded_arg_mem (cpp_reader *, macro_arg *, size_t);\n static void ensure_expanded_arg_room (cpp_reader *, macro_arg *, size_t, size_t *);\n static void delete_macro_args (_cpp_buff*, unsigned num_args);\n static void set_arg_token (macro_arg *, const cpp_token *,\n-\t\t\t   source_location, size_t,\n+\t\t\t   location_t, size_t,\n \t\t\t   enum macro_arg_token_kind,\n \t\t\t   bool);\n-static const source_location *get_arg_token_location (const macro_arg *,\n+static const location_t *get_arg_token_location (const macro_arg *,\n \t\t\t\t\t\t      enum macro_arg_token_kind);\n static const cpp_token **arg_token_ptr_at (const macro_arg *,\n \t\t\t\t\t   size_t,\n \t\t\t\t\t   enum macro_arg_token_kind,\n-\t\t\t\t\t   source_location **virt_location);\n+\t\t\t\t\t   location_t **virt_location);\n \n static void macro_arg_token_iter_init (macro_arg_token_iter *, bool,\n \t\t\t\t       enum macro_arg_token_kind,\n \t\t\t\t       const macro_arg *,\n \t\t\t\t       const cpp_token **);\n static const cpp_token *macro_arg_token_iter_get_token\n (const macro_arg_token_iter *it);\n-static source_location macro_arg_token_iter_get_location\n+static location_t macro_arg_token_iter_get_location\n (const macro_arg_token_iter *);\n static void macro_arg_token_iter_forward (macro_arg_token_iter *);\n static _cpp_buff *tokens_buff_new (cpp_reader *, size_t,\n-\t\t\t\t   source_location **);\n+\t\t\t\t   location_t **);\n static size_t tokens_buff_count (_cpp_buff *);\n static const cpp_token **tokens_buff_last_token_ptr (_cpp_buff *);\n static inline const cpp_token **tokens_buff_put_token_to (const cpp_token **,\n-                                                          source_location *,\n+                                                          location_t *,\n                                                           const cpp_token *,\n-                                                          source_location,\n-                                                          source_location,\n+                                                          location_t,\n+                                                          location_t,\n                                                           const line_map_macro *,\n                                                           unsigned int);\n \n static const cpp_token **tokens_buff_add_token (_cpp_buff *,\n-\t\t\t\t\t\tsource_location *,\n+\t\t\t\t\t\tlocation_t *,\n \t\t\t\t\t\tconst cpp_token *,\n-\t\t\t\t\t\tsource_location,\n-\t\t\t\t\t\tsource_location,\n+\t\t\t\t\t\tlocation_t,\n+\t\t\t\t\t\tlocation_t,\n \t\t\t\t\t\tconst line_map_macro *,\n \t\t\t\t\t\tunsigned int);\n static inline void tokens_buff_remove_last_token (_cpp_buff *);\n static void replace_args (cpp_reader *, cpp_hashnode *, cpp_macro *,\n-\t\t\t  macro_arg *, source_location);\n+\t\t\t  macro_arg *, location_t);\n static _cpp_buff *funlike_invocation_p (cpp_reader *, cpp_hashnode *,\n \t\t\t\t\t_cpp_buff **, unsigned *);\n static cpp_macro *create_iso_definition (cpp_reader *);\n@@ -322,8 +322,8 @@ static void check_trad_stringification (cpp_reader *, const cpp_macro *,\n static bool reached_end_of_context (cpp_context *);\n static void consume_next_token_from_context (cpp_reader *pfile,\n \t\t\t\t\t     const cpp_token **,\n-\t\t\t\t\t     source_location *);\n-static const cpp_token* cpp_get_token_1 (cpp_reader *, source_location *);\n+\t\t\t\t\t     location_t *);\n+static const cpp_token* cpp_get_token_1 (cpp_reader *, location_t *);\n \n static cpp_hashnode* macro_of_context (cpp_context *context);\n \n@@ -382,7 +382,7 @@ static const char * const monthnames[] =\n    a builtin macro. */\n const uchar *\n _cpp_builtin_macro_text (cpp_reader *pfile, cpp_hashnode *node,\n-\t\t\t source_location loc)\n+\t\t\t location_t loc)\n {\n   const uchar *result = NULL;\n   linenum_type number = 1;\n@@ -587,7 +587,7 @@ _cpp_builtin_macro_text (cpp_reader *pfile, cpp_hashnode *node,\n    point of the macro.  */\n static int\n builtin_macro (cpp_reader *pfile, cpp_hashnode *node,\n-\t       source_location loc, source_location expand_loc)\n+\t       location_t loc, location_t expand_loc)\n {\n   const uchar *buf;\n   size_t len;\n@@ -623,7 +623,7 @@ builtin_macro (cpp_reader *pfile, cpp_hashnode *node,\n \t Create a macro line map and generate a virtual location for\n \t the token resulting from the expansion of the built-in\n \t macro.  */\n-      source_location *virt_locs = NULL;\n+      location_t *virt_locs = NULL;\n       _cpp_buff *token_buf = tokens_buff_new (pfile, 1, &virt_locs);\n       const line_map_macro * map =\n \tlinemap_enter_macro (pfile->line_table, node, loc, 1);\n@@ -773,7 +773,7 @@ stringify_arg (cpp_reader *pfile, macro_arg *arg)\n    guaranteed to not have the PASTE_LEFT flag set.  LOCATION is\n    the virtual location used for error reporting.  */\n static bool\n-paste_tokens (cpp_reader *pfile, source_location location,\n+paste_tokens (cpp_reader *pfile, location_t location,\n \t      const cpp_token **plhs, const cpp_token *rhs)\n {\n   unsigned char *buf, *end, *lhsend;\n@@ -803,7 +803,7 @@ paste_tokens (cpp_reader *pfile, source_location location,\n   lhs = _cpp_lex_direct (pfile);\n   if (pfile->buffer->cur != pfile->buffer->rlimit)\n     {\n-      source_location saved_loc = lhs->src_loc;\n+      location_t saved_loc = lhs->src_loc;\n \n       _cpp_pop_buffer (pfile);\n       _cpp_backup_tokens (pfile, 1);\n@@ -841,7 +841,7 @@ paste_all_tokens (cpp_reader *pfile, const cpp_token *lhs)\n {\n   const cpp_token *rhs = NULL;\n   cpp_context *context = pfile->context;\n-  source_location virt_loc = 0;\n+  location_t virt_loc = 0;\n \n   /* We are expanding a macro and we must have been called on a token\n      that appears at the left hand side of a ## operator.  */\n@@ -903,7 +903,7 @@ paste_all_tokens (cpp_reader *pfile, const cpp_token *lhs)\n   /* Put the resulting token in its own context.  */\n   if (context->tokens_kind == TOKENS_KIND_EXTENDED)\n     {\n-      source_location *virt_locs = NULL;\n+      location_t *virt_locs = NULL;\n       _cpp_buff *token_buf = tokens_buff_new (pfile, 1, &virt_locs);\n       tokens_buff_add_token (token_buf, virt_locs, lhs,\n \t\t\t     virt_loc, 0, NULL, 0);\n@@ -993,7 +993,7 @@ collect_args (cpp_reader *pfile, const cpp_hashnode *node,\n   macro_arg *args, *arg;\n   const cpp_token *token;\n   unsigned int argc;\n-  source_location virt_loc;\n+  location_t virt_loc;\n   bool track_macro_expansion_p = CPP_OPTION (pfile, track_macro_expansion);\n   unsigned num_args_alloced = 0;\n \n@@ -1030,7 +1030,7 @@ collect_args (cpp_reader *pfile, const cpp_hashnode *node,\n       if (track_macro_expansion_p)\n \t{\n \t  virt_locs_capacity = DEFAULT_NUM_TOKENS_PER_MACRO_ARG;\n-\t  arg->virt_locs = XNEWVEC (source_location,\n+\t  arg->virt_locs = XNEWVEC (location_t,\n \t\t\t\t    virt_locs_capacity);\n \t}\n \n@@ -1048,7 +1048,7 @@ collect_args (cpp_reader *pfile, const cpp_hashnode *node,\n \t      && (ntokens + 2 > virt_locs_capacity))\n \t    {\n \t      virt_locs_capacity += ARG_TOKENS_EXTENT;\n-\t      arg->virt_locs = XRESIZEVEC (source_location,\n+\t      arg->virt_locs = XRESIZEVEC (location_t,\n \t\t\t\t\t   arg->virt_locs,\n \t\t\t\t\t   virt_locs_capacity);\n \t    }\n@@ -1260,7 +1260,7 @@ macro_real_token_count (const cpp_macro *macro)\n    macro.  */\n static int\n enter_macro_context (cpp_reader *pfile, cpp_hashnode *node,\n-\t\t     const cpp_token *result, source_location location)\n+\t\t     const cpp_token *result, location_t location)\n {\n   /* The presence of a macro invalidates a file's controlling macro.  */\n   pfile->mi_valid = false;\n@@ -1340,7 +1340,7 @@ enter_macro_context (cpp_reader *pfile, cpp_hashnode *node,\n \t      unsigned int i;\n \t      const cpp_token *src = macro->exp.tokens;\n \t      const line_map_macro *map;\n-\t      source_location *virt_locs = NULL;\n+\t      location_t *virt_locs = NULL;\n \t      _cpp_buff *macro_tokens\n \t\t= tokens_buff_new (pfile, tokens_count, &virt_locs);\n \n@@ -1401,7 +1401,7 @@ enter_macro_context (cpp_reader *pfile, cpp_hashnode *node,\n   pfile->about_to_expand_macro_p = false;\n   /* Handle built-in macros and the _Pragma operator.  */\n   {\n-    source_location expand_loc;\n+    location_t expand_loc;\n \n     if (/* The top-level macro invocation that triggered the expansion\n \t   we are looking at is with a function-like user macro ...  */\n@@ -1467,12 +1467,12 @@ delete_macro_args (_cpp_buff *buff, unsigned num_args)\n    tokens, at least.  */\n static void\n set_arg_token (macro_arg *arg, const cpp_token *token,\n-\t       source_location location, size_t index,\n+\t       location_t location, size_t index,\n \t       enum macro_arg_token_kind kind,\n \t       bool track_macro_exp_p)\n {\n   const cpp_token **token_ptr;\n-  source_location *loc = NULL;\n+  location_t *loc = NULL;\n \n   token_ptr =\n     arg_token_ptr_at (arg, index, kind,\n@@ -1493,13 +1493,13 @@ set_arg_token (macro_arg *arg, const cpp_token *token,\n /* Get the pointer to the location of the argument token of the\n    function-like macro argument ARG.  This function must be called\n    only when we -ftrack-macro-expansion is on.  */\n-static const source_location *\n+static const location_t *\n get_arg_token_location (const macro_arg *arg,\n \t\t\tenum macro_arg_token_kind kind)\n {\n-  const source_location *loc = NULL;\n+  const location_t *loc = NULL;\n   const cpp_token **token_ptr =\n-    arg_token_ptr_at (arg, 0, kind, (source_location **) &loc);\n+    arg_token_ptr_at (arg, 0, kind, (location_t **) &loc);\n \n   if (token_ptr == NULL)\n     return NULL;\n@@ -1516,7 +1516,7 @@ get_arg_token_location (const macro_arg *arg,\n static const cpp_token **\n arg_token_ptr_at (const macro_arg *arg, size_t index,\n \t\t  enum macro_arg_token_kind kind,\n-\t\t  source_location **virt_location)\n+\t\t  location_t **virt_location)\n {\n   const cpp_token **tokens_ptr = NULL;\n \n@@ -1546,7 +1546,7 @@ arg_token_ptr_at (const macro_arg *arg, size_t index,\n \t*virt_location = &arg->expanded_virt_locs[index];\n       else if (kind == MACRO_ARG_TOKEN_STRINGIFIED)\n \t*virt_location =\n-\t  (source_location *) &tokens_ptr[index]->src_loc;\n+\t  (location_t *) &tokens_ptr[index]->src_loc;\n     }\n   return &tokens_ptr[index];\n }\n@@ -1623,7 +1623,7 @@ macro_arg_token_iter_get_token (const macro_arg_token_iter *it)\n }\n \n /* Return the location of the token pointed to by the iterator.*/\n-static source_location\n+static location_t\n macro_arg_token_iter_get_location (const macro_arg_token_iter *it)\n {\n #if CHECKING_P\n@@ -1720,14 +1720,14 @@ last_token_is (_cpp_buff *buff, const cpp_token **ptr)\n    function-like macro invocation.  */\n static void\n replace_args (cpp_reader *pfile, cpp_hashnode *node, cpp_macro *macro,\n-\t      macro_arg *args, source_location expansion_point_loc)\n+\t      macro_arg *args, location_t expansion_point_loc)\n {\n   unsigned int i, total;\n   const cpp_token *src, *limit;\n   const cpp_token **first = NULL;\n   macro_arg *arg;\n   _cpp_buff *buff = NULL;\n-  source_location *virt_locs = NULL;\n+  location_t *virt_locs = NULL;\n   unsigned int exp_count;\n   const line_map_macro *map = NULL;\n   int track_macro_exp;\n@@ -1797,7 +1797,7 @@ replace_args (cpp_reader *pfile, cpp_hashnode *node, cpp_macro *macro,\n      \n      As far as tokens are concerned, the memory overhead of\n      -ftrack-macro-expansion is proportional to the number of\n-     macros that get expanded multiplied by sizeof (source_location).\n+     macros that get expanded multiplied by sizeof (location_t).\n      The good news is that extra memory gets freed when the macro\n      context is freed, i.e shortly after the macro got expanded.  */\n \n@@ -2216,7 +2216,7 @@ static void\n push_extended_tokens_context (cpp_reader *pfile,\n \t\t\t      cpp_hashnode *macro,\n \t\t\t      _cpp_buff *token_buff,\n-\t\t\t      source_location *virt_locs,\n+\t\t\t      location_t *virt_locs,\n \t\t\t      const cpp_token **first,\n \t\t\t      unsigned int count)\n {\n@@ -2262,13 +2262,13 @@ _cpp_push_text_context (cpp_reader *pfile, cpp_hashnode *macro,\n    expansion.  */\n static _cpp_buff*\n tokens_buff_new (cpp_reader *pfile, size_t len,\n-\t\t source_location **virt_locs)\n+\t\t location_t **virt_locs)\n {\n   size_t tokens_size = len * sizeof (cpp_token *);\n-  size_t locs_size = len * sizeof (source_location);\n+  size_t locs_size = len * sizeof (location_t);\n \n   if (virt_locs != NULL)\n-    *virt_locs = XNEWVEC (source_location, locs_size);\n+    *virt_locs = XNEWVEC (location_t, locs_size);\n   return _cpp_get_buff (pfile, tokens_size);\n }\n \n@@ -2325,14 +2325,14 @@ tokens_buff_remove_last_token (_cpp_buff *tokens_buff)\n    point.  */\n static inline const cpp_token **\n tokens_buff_put_token_to (const cpp_token **dest,\n-\t\t\t  source_location *virt_loc_dest,\n+\t\t\t  location_t *virt_loc_dest,\n \t\t\t  const cpp_token *token,\n-\t\t\t  source_location virt_loc,\n-\t\t\t  source_location parm_def_loc,\t\t\t  \n+\t\t\t  location_t virt_loc,\n+\t\t\t  location_t parm_def_loc,\n \t\t\t  const line_map_macro *map,\n \t\t\t  unsigned int macro_token_index)\n {\n-  source_location macro_loc = virt_loc;\n+  location_t macro_loc = virt_loc;\n   const cpp_token **result;\n \n   if (virt_loc_dest)\n@@ -2370,15 +2370,15 @@ tokens_buff_put_token_to (const cpp_token **dest,\n    position of the token coming right after the insertion point.  */\n static const cpp_token **\n tokens_buff_add_token (_cpp_buff *buffer,\n-\t\t       source_location *virt_locs,\n+\t\t       location_t *virt_locs,\n \t\t       const cpp_token *token,\n-\t\t       source_location virt_loc,\n-\t\t       source_location parm_def_loc,\n+\t\t       location_t virt_loc,\n+\t\t       location_t parm_def_loc,\n \t\t       const line_map_macro *map,\n \t\t       unsigned int macro_token_index)\n {\n   const cpp_token **result;\n-  source_location *virt_loc_dest = NULL;\n+  location_t *virt_loc_dest = NULL;\n   unsigned token_index = \n     (BUFF_FRONT (buffer) - buffer->base) / sizeof (cpp_token *);\n \n@@ -2410,7 +2410,7 @@ alloc_expanded_arg_mem (cpp_reader *pfile, macro_arg *arg, size_t capacity)\n \n   arg->expanded = XNEWVEC (const cpp_token *, capacity);\n   if (CPP_OPTION (pfile, track_macro_expansion))\n-    arg->expanded_virt_locs = XNEWVEC (source_location, capacity);\n+    arg->expanded_virt_locs = XNEWVEC (location_t, capacity);\n \n }\n \n@@ -2432,9 +2432,9 @@ ensure_expanded_arg_room (cpp_reader *pfile, macro_arg *arg,\n   if (CPP_OPTION (pfile, track_macro_expansion))\n     {\n       if (arg->expanded_virt_locs == NULL)\n-\targ->expanded_virt_locs = XNEWVEC (source_location, size);\n+\targ->expanded_virt_locs = XNEWVEC (location_t, size);\n       else\n-\targ->expanded_virt_locs = XRESIZEVEC (source_location,\n+\targ->expanded_virt_locs = XRESIZEVEC (location_t,\n \t\t\t\t\t      arg->expanded_virt_locs,\n \t\t\t\t\t      size);\n     }\n@@ -2477,7 +2477,7 @@ expand_arg (cpp_reader *pfile, macro_arg *arg)\n   for (;;)\n     {\n       const cpp_token *token;\n-      source_location location;\n+      location_t location;\n \n       ensure_expanded_arg_room (pfile, arg, arg->expanded_count + 1,\n \t\t\t\t&capacity);\n@@ -2616,7 +2616,7 @@ reached_end_of_context (cpp_context *context)\n static inline void\n consume_next_token_from_context (cpp_reader *pfile,\n \t\t\t\t const cpp_token ** token,\n-\t\t\t\t source_location *location)\n+\t\t\t\t location_t *location)\n {\n   cpp_context *c = pfile->context;\n \n@@ -2655,8 +2655,8 @@ consume_next_token_from_context (cpp_reader *pfile,\n    location if we are in the traditional mode, and just returns\n    LOCATION otherwise.  */\n \n-static inline source_location\n-maybe_adjust_loc_for_trad_cpp (cpp_reader *pfile, source_location location)\n+static inline location_t\n+maybe_adjust_loc_for_trad_cpp (cpp_reader *pfile, location_t location)\n {\n   if (CPP_OPTION (pfile, traditional))\n     {\n@@ -2681,12 +2681,12 @@ maybe_adjust_loc_for_trad_cpp (cpp_reader *pfile, source_location location)\n    cpp_get_token_with_location to learn more about the meaning of this\n    location.  */\n static const cpp_token*\n-cpp_get_token_1 (cpp_reader *pfile, source_location *location)\n+cpp_get_token_1 (cpp_reader *pfile, location_t *location)\n {\n   const cpp_token *result;\n   /* This token is a virtual token that either encodes a location\n      related to macro expansion or a spelling location.  */\n-  source_location virt_loc = 0;\n+  location_t virt_loc = 0;\n   /* pfile->about_to_expand_macro_p can be overriden by indirect calls\n      to functions that push macro contexts.  So let's save it so that\n      we can restore it when we are about to leave this routine.  */\n@@ -2884,7 +2884,7 @@ cpp_get_token (cpp_reader *pfile)\n    location is just the same thing as its spelling location.  */\n \n const cpp_token *\n-cpp_get_token_with_location (cpp_reader *pfile, source_location *loc)\n+cpp_get_token_with_location (cpp_reader *pfile, location_t *loc)\n {\n   return cpp_get_token_1 (pfile, loc);\n }"}, {"sha": "fb6c12a91056f6056b78bcf4b9317844a16a980e", "filename": "libcpp/pch.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Fpch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Fpch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fpch.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -437,7 +437,7 @@ _cpp_restore_pushed_macros (cpp_reader *r, FILE *f)\n \t    return 0;\n \n \t  p->definition = defn;\n-\t  if (fread (&(p->line), sizeof (source_location), 1, f) != 1)\n+\t  if (fread (&(p->line), sizeof (location_t), 1, f) != 1)\n \t    return 0;\n \t  defnlen = 0;\n \t  if (fread (&defnlen, sizeof (defnlen), 1, f) != 1)\n@@ -501,7 +501,7 @@ _cpp_save_pushed_macros (cpp_reader *r, FILE *f)\n \t  if (fwrite (&defnlen, sizeof (size_t), 1, f) != 1\n \t      || fwrite (pp[i]->definition, defnlen, 1, f) != 1)\n \t    return 0;\n-\t  if (fwrite (&(pp[i]->line), sizeof (source_location), 1, f) != 1)\n+\t  if (fwrite (&(pp[i]->line), sizeof (location_t), 1, f) != 1)\n \t    return 0;\n \t  defnlen = 0;\n \t  defnlen |= (pp[i]->syshdr != 0 ? 1 : 0);"}, {"sha": "a5383375cf1557a42d0acdb8e9ffc4d0f07b7106", "filename": "libcpp/traditional.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Ftraditional.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/620e594be58d2f933902a6619fd20aa618070b4b/libcpp%2Ftraditional.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ftraditional.c?ref=620e594be58d2f933902a6619fd20aa618070b4b", "patch": "@@ -60,7 +60,7 @@ struct fun_macro\n   size_t offset;\n \n   /* The line the macro name appeared on.  */\n-  source_location line;\n+  location_t line;\n \n   /* Number of parameters.  */\n   unsigned int paramc;\n@@ -161,7 +161,7 @@ static const uchar *\n copy_comment (cpp_reader *pfile, const uchar *cur, int in_define)\n {\n   bool unterminated, copy = false;\n-  source_location src_loc = pfile->line_table->highest_line;\n+  location_t src_loc = pfile->line_table->highest_line;\n   cpp_buffer *buffer = pfile->buffer;\n \n   buffer->cur = cur;"}]}