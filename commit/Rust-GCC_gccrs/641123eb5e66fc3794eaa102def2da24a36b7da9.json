{"sha": "641123eb5e66fc3794eaa102def2da24a36b7da9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQxMTIzZWI1ZTY2ZmMzNzk0ZWFhMTAyZGVmMmRhMjRhMzZiN2RhOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2014-10-13T07:05:46Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-10-13T07:05:46Z"}, "message": "rtlanal.c (generic_subrtx_iterator <T>::add_subrtxes_to_queue): Add the parts of an insn in reverse order, with the pattern at the top of the queue.\n\ngcc/\n\t* rtlanal.c (generic_subrtx_iterator <T>::add_subrtxes_to_queue):\n\tAdd the parts of an insn in reverse order, with the pattern at\n\tthe top of the queue.  Detect when we're iterating over a SEQUENCE\n\tpattern and in that case just consider patterns of subinstructions.\n\nFrom-SVN: r216137", "tree": {"sha": "2ce789a065eadcf5490f63a72017e229498de3ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ce789a065eadcf5490f63a72017e229498de3ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/641123eb5e66fc3794eaa102def2da24a36b7da9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/641123eb5e66fc3794eaa102def2da24a36b7da9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/641123eb5e66fc3794eaa102def2da24a36b7da9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/641123eb5e66fc3794eaa102def2da24a36b7da9/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "eaa89fd82a53aded2226b88716bfc56adeecf133", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaa89fd82a53aded2226b88716bfc56adeecf133", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaa89fd82a53aded2226b88716bfc56adeecf133"}], "stats": {"total": 80, "additions": 58, "deletions": 22}, "files": [{"sha": "e01505f32824d2001fbd6e0885ff925f9229c856", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641123eb5e66fc3794eaa102def2da24a36b7da9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641123eb5e66fc3794eaa102def2da24a36b7da9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=641123eb5e66fc3794eaa102def2da24a36b7da9", "patch": "@@ -1,3 +1,10 @@\n+2014-10-13  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* rtlanal.c (generic_subrtx_iterator <T>::add_subrtxes_to_queue):\n+\tAdd the parts of an insn in reverse order, with the pattern at\n+\tthe top of the queue.  Detect when we're iterating over a SEQUENCE\n+\tpattern and in that case just consider patterns of subinstructions.\n+\n 2014-10-12  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/59401"}, {"sha": "4651f709f974c9f6d1af7870941b38977f953697", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 51, "deletions": 22, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641123eb5e66fc3794eaa102def2da24a36b7da9/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641123eb5e66fc3794eaa102def2da24a36b7da9/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=641123eb5e66fc3794eaa102def2da24a36b7da9", "patch": "@@ -128,29 +128,58 @@ generic_subrtx_iterator <T>::add_subrtxes_to_queue (array_type &array,\n \t\t\t\t\t\t    value_type *base,\n \t\t\t\t\t\t    size_t end, rtx_type x)\n {\n-  const char *format = GET_RTX_FORMAT (GET_CODE (x));\n+  enum rtx_code code = GET_CODE (x);\n+  const char *format = GET_RTX_FORMAT (code);\n   size_t orig_end = end;\n-  for (int i = 0; format[i]; ++i)\n-    if (format[i] == 'e')\n-      {\n-\tvalue_type subx = T::get_value (x->u.fld[i].rt_rtx);\n-\tif (__builtin_expect (end < LOCAL_ELEMS, true))\n-\t  base[end++] = subx;\n-\telse\n-\t  base = add_single_to_queue (array, base, end++, subx);\n-      }\n-    else if (format[i] == 'E')\n-      {\n-\tint length = GET_NUM_ELEM (x->u.fld[i].rt_rtvec);\n-\trtx *vec = x->u.fld[i].rt_rtvec->elem;\n-\tif (__builtin_expect (end + length <= LOCAL_ELEMS, true))\n-\t  for (int j = 0; j < length; j++)\n-\t    base[end++] = T::get_value (vec[j]);\n-\telse\n-\t  for (int j = 0; j < length; j++)\n-\t    base = add_single_to_queue (array, base, end++,\n-\t\t\t\t\tT::get_value (vec[j]));\n-      }\n+  if (__builtin_expect (INSN_P (x), false))\n+    {\n+      /* Put the pattern at the top of the queue, since that's what\n+\t we're likely to want most.  It also allows for the SEQUENCE\n+\t code below.  */\n+      for (int i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; --i)\n+\tif (format[i] == 'e')\n+\t  {\n+\t    value_type subx = T::get_value (x->u.fld[i].rt_rtx);\n+\t    if (__builtin_expect (end < LOCAL_ELEMS, true))\n+\t      base[end++] = subx;\n+\t    else\n+\t      base = add_single_to_queue (array, base, end++, subx);\n+\t  }\n+    }\n+  else\n+    for (int i = 0; format[i]; ++i)\n+      if (format[i] == 'e')\n+\t{\n+\t  value_type subx = T::get_value (x->u.fld[i].rt_rtx);\n+\t  if (__builtin_expect (end < LOCAL_ELEMS, true))\n+\t    base[end++] = subx;\n+\t  else\n+\t    base = add_single_to_queue (array, base, end++, subx);\n+\t}\n+      else if (format[i] == 'E')\n+\t{\n+\t  unsigned int length = GET_NUM_ELEM (x->u.fld[i].rt_rtvec);\n+\t  rtx *vec = x->u.fld[i].rt_rtvec->elem;\n+\t  if (__builtin_expect (end + length <= LOCAL_ELEMS, true))\n+\t    for (unsigned int j = 0; j < length; j++)\n+\t      base[end++] = T::get_value (vec[j]);\n+\t  else\n+\t    for (unsigned int j = 0; j < length; j++)\n+\t      base = add_single_to_queue (array, base, end++,\n+\t\t\t\t\t  T::get_value (vec[j]));\n+\t  if (code == SEQUENCE && end == length)\n+\t    /* If the subrtxes of the sequence fill the entire array then\n+\t       we know that no other parts of a containing insn are queued.\n+\t       The caller is therefore iterating over the sequence as a\n+\t       PATTERN (...), so we also want the patterns of the\n+\t       subinstructions.  */\n+\t    for (unsigned int j = 0; j < length; j++)\n+\t      {\n+\t\ttypename T::rtx_type x = T::get_rtx (base[j]);\n+\t\tif (INSN_P (x))\n+\t\t  base[j] = T::get_value (PATTERN (x));\n+\t      }\n+\t}\n   return end - orig_end;\n }\n "}]}