{"sha": "004bb936d6d5f177af26ad4905595e843d5665a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA0YmI5MzZkNmQ1ZjE3N2FmMjZhZDQ5MDU1OTVlODQzZDU2NjVhNQ==", "commit": {"author": {"name": "Lewis Hyatt", "email": "lhyatt@gmail.com", "date": "2020-07-14T16:05:56Z"}, "committer": {"name": "Lewis Hyatt", "email": "lhyatt@gmail.com", "date": "2020-07-14T16:05:56Z"}, "message": "diagnostics: Support conversion of tabs to spaces [PR49973] [PR86904]\n\nSupports conversion of tabs to spaces when outputting diagnostics. Also\nadds -fdiagnostics-column-unit and -fdiagnostics-column-origin options to\ncontrol how the column number is output, thereby resolving the two PRs.\n\ngcc/c-family/ChangeLog:\n\n\tPR other/86904\n\t* c-indentation.c (should_warn_for_misleading_indentation): Get\n\tglobal tabstop from the new source.\n\t* c-opts.c (c_common_handle_option): Remove handling of -ftabstop, which\n\tis now a common option.\n\t* c.opt: Likewise.\n\ngcc/ChangeLog:\n\n\tPR preprocessor/49973\n\tPR other/86904\n\t* common.opt: Handle -ftabstop here instead of in c-family\n\toptions.  Add -fdiagnostics-column-unit= and\n\t-fdiagnostics-column-origin= options.\n\t* opts.c (common_handle_option): Handle the new options.\n\t* diagnostic-format-json.cc (json_from_expanded_location): Add\n\tdiagnostic_context argument.  Use it to convert column numbers as per\n\tthe new options.\n\t(json_from_location_range): Likewise.\n\t(json_from_fixit_hint): Likewise.\n\t(json_end_diagnostic): Pass the new context argument to helper\n\tfunctions above.  Add \"column-origin\" field to the output.\n\t(test_unknown_location): Add the new context argument to calls to\n\thelper functions.\n\t(test_bad_endpoints): Likewise.\n\t* diagnostic-show-locus.c\n\t(exploc_with_display_col::exploc_with_display_col): Support\n\ttabstop parameter.\n\t(layout_point::layout_point): Make use of class\n\texploc_with_display_col.\n\t(layout_range::layout_range): Likewise.\n\t(struct line_bounds): Clarify that the units are now always\n\tdisplay columns.  Rename members accordingly.  Add constructor.\n\t(layout::print_source_line): Add support for tab expansion.\n\t(make_range): Adapt to class layout_range changes.\n\t(layout::maybe_add_location_range): Likewise.\n\t(layout::layout): Adapt to class exploc_with_display_col changes.\n\t(layout::calculate_x_offset_display): Support tabstop parameter.\n\t(layout::print_annotation_line): Adapt to struct line_bounds changes.\n\t(layout::print_line): Likewise.\n\t(line_label::line_label): Add diagnostic_context argument.\n\t(get_affected_range): Likewise.\n\t(get_printed_columns): Likewise.\n\t(layout::print_any_labels): Adapt to struct line_label changes.\n\t(class correction): Add m_tabstop member.\n\t(correction::correction): Add tabstop argument.\n\t(correction::compute_display_cols): Use m_tabstop.\n\t(class line_corrections): Add m_context member.\n\t(line_corrections::line_corrections): Add diagnostic_context argument.\n\t(line_corrections::add_hint): Use m_context to handle tabstops.\n\t(layout::print_trailing_fixits): Adapt to class line_corrections\n\tchanges.\n\t(test_layout_x_offset_display_utf8): Support tabstop parameter.\n\t(test_layout_x_offset_display_tab): New selftest.\n\t(test_one_liner_colorized_utf8): Likewise.\n\t(test_tab_expansion): Likewise.\n\t(test_diagnostic_show_locus_one_liner_utf8): Call the new tests.\n\t(diagnostic_show_locus_c_tests): Likewise.\n\t(test_overlapped_fixit_printing): Adapt to helper class and\n\tfunction changes.\n\t(test_overlapped_fixit_printing_utf8): Likewise.\n\t(test_overlapped_fixit_printing_2): Likewise.\n\t* diagnostic.h (enum diagnostics_column_unit): New enum.\n\t(struct diagnostic_context): Add members for the new options.\n\t(diagnostic_converted_column): Declare.\n\t(json_from_expanded_location): Add new context argument.\n\t* diagnostic.c (diagnostic_initialize): Initialize new members.\n\t(diagnostic_converted_column): New function.\n\t(maybe_line_and_column): Be willing to output a column of 0.\n\t(diagnostic_get_location_text): Convert column number as per the new\n\toptions.\n\t(diagnostic_report_current_module): Likewise.\n\t(assert_location_text): Add origin and column_unit arguments for\n\ttesting the new functionality.\n\t(test_diagnostic_get_location_text): Test the new functionality.\n\t* doc/invoke.texi: Document the new options and behavior.\n\t* input.h (location_compute_display_column): Add tabstop argument.\n\t* input.c (location_compute_display_column): Likewise.\n\t(test_cpp_utf8): Add selftests for tab expansion.\n\t* tree-diagnostic-path.cc (default_tree_make_json_for_path): Pass the\n\tnew context argument to json_from_expanded_location().\n\nlibcpp/ChangeLog:\n\n\tPR preprocessor/49973\n\tPR other/86904\n\t* include/cpplib.h (struct cpp_options):  Removed support for -ftabstop,\n\twhich is now handled by diagnostic_context.\n\t(class cpp_display_width_computation): New class.\n\t(cpp_byte_column_to_display_column): Add optional tabstop argument.\n\t(cpp_display_width): Likewise.\n\t(cpp_display_column_to_byte_column): Likewise.\n\t* charset.c\n\t(cpp_display_width_computation::cpp_display_width_computation): New\n\tfunction.\n\t(cpp_display_width_computation::advance_display_cols): Likewise.\n\t(compute_next_display_width): Removed and implemented this\n\tfunctionality in a new function...\n\t(cpp_display_width_computation::process_next_codepoint): ...here.\n\t(cpp_byte_column_to_display_column): Added tabstop argument.\n\tReimplemented in terms of class cpp_display_width_computation.\n\t(cpp_display_column_to_byte_column): Likewise.\n\t* init.c (cpp_create_reader): Remove handling of -ftabstop, which is now\n\thandled by diagnostic_context.\n\ngcc/testsuite/ChangeLog:\n\n\tPR preprocessor/49973\n\tPR other/86904\n\t* c-c++-common/Wmisleading-indentation-3.c: Adjust expected output\n\tfor new defaults.\n\t* c-c++-common/Wmisleading-indentation.c: Likewise.\n\t* c-c++-common/diagnostic-format-json-1.c: Likewise.\n\t* c-c++-common/diagnostic-format-json-2.c: Likewise.\n\t* c-c++-common/diagnostic-format-json-3.c: Likewise.\n\t* c-c++-common/diagnostic-format-json-4.c: Likewise.\n\t* c-c++-common/diagnostic-format-json-5.c: Likewise.\n\t* c-c++-common/missing-close-symbol.c: Likewise.\n\t* g++.dg/diagnostic/bad-binary-ops.C: Likewise.\n\t* g++.dg/parse/error4.C: Likewise.\n\t* g++.old-deja/g++.brendan/crash11.C: Likewise.\n\t* g++.old-deja/g++.pt/overload2.C: Likewise.\n\t* g++.old-deja/g++.robertl/eb109.C: Likewise.\n\t* gcc.dg/analyzer/malloc-paths-9.c: Likewise.\n\t* gcc.dg/bad-binary-ops.c: Likewise.\n\t* gcc.dg/format/branch-1.c: Likewise.\n\t* gcc.dg/format/pr79210.c: Likewise.\n\t* gcc.dg/plugin/diagnostic-test-expressions-1.c: Likewise.\n\t* gcc.dg/plugin/diagnostic-test-string-literals-1.c: Likewise.\n\t* gcc.dg/redecl-4.c: Likewise.\n\t* gfortran.dg/diagnostic-format-json-1.F90: Likewise.\n\t* gfortran.dg/diagnostic-format-json-2.F90: Likewise.\n\t* gfortran.dg/diagnostic-format-json-3.F90: Likewise.\n\t* go.dg/arrayclear.go: Add a comment explaining why adding a\n\tcomment was necessary to work around a dejagnu bug.\n\t* c-c++-common/diagnostic-units-1.c: New test.\n\t* c-c++-common/diagnostic-units-2.c: New test.\n\t* c-c++-common/diagnostic-units-3.c: New test.\n\t* c-c++-common/diagnostic-units-4.c: New test.\n\t* c-c++-common/diagnostic-units-5.c: New test.\n\t* c-c++-common/diagnostic-units-6.c: New test.\n\t* c-c++-common/diagnostic-units-7.c: New test.\n\t* c-c++-common/diagnostic-units-8.c: New test.", "tree": {"sha": "fe3ee343abc249a14509943f4e731f8fb73f6206", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe3ee343abc249a14509943f4e731f8fb73f6206"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/004bb936d6d5f177af26ad4905595e843d5665a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/004bb936d6d5f177af26ad4905595e843d5665a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/004bb936d6d5f177af26ad4905595e843d5665a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/004bb936d6d5f177af26ad4905595e843d5665a5/comments", "author": null, "committer": null, "parents": [{"sha": "5f809982e8e05c39029431363e08759d6c750f0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f809982e8e05c39029431363e08759d6c750f0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f809982e8e05c39029431363e08759d6c750f0e"}], "stats": {"total": 1393, "additions": 1106, "deletions": 287}, "files": [{"sha": "d814f6f29e6989c19047015ed4c14ed1c2d7c164", "filename": "gcc/c-family/c-indentation.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Fc-family%2Fc-indentation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Fc-family%2Fc-indentation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-indentation.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -24,8 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-common.h\"\n #include \"c-indentation.h\"\n #include \"selftest.h\"\n-\n-extern cpp_options *cpp_opts;\n+#include \"diagnostic.h\"\n \n /* Round up VIS_COLUMN to nearest tab stop. */\n \n@@ -299,7 +298,7 @@ should_warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n   expanded_location next_stmt_exploc = expand_location (next_stmt_loc);\n   expanded_location guard_exploc = expand_location (guard_loc);\n \n-  const unsigned int tab_width = cpp_opts->tabstop;\n+  const unsigned int tab_width = global_dc->tabstop;\n \n   /* They must be in the same file.  */\n   if (next_stmt_exploc.file != body_exploc.file)"}, {"sha": "38d3384942363f210104ed2d26166f4a25f2e37d", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -504,12 +504,6 @@ c_common_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n \tcpp_opts->track_macro_expansion = 2;\n       break;\n \n-    case OPT_ftabstop_:\n-      /* It is documented that we silently ignore silly values.  */\n-      if (value >= 1 && value <= 100)\n-\tcpp_opts->tabstop = value;\n-      break;\n-\n     case OPT_fexec_charset_:\n       cpp_opts->narrow_charset = arg;\n       break;"}, {"sha": "a09f15d800ea30b1793e746efa3bdca2aab29c2e", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -1876,10 +1876,6 @@ Enum(strong_eval_order) String(some) Value(1)\n EnumValue\n Enum(strong_eval_order) String(all) Value(2)\n \n-ftabstop=\n-C ObjC C++ ObjC++ Joined RejectNegative UInteger\n--ftabstop=<number>\tDistance between tab stops for column reporting.\n-\n ftemplate-backtrace-limit=\n C++ ObjC++ Joined RejectNegative UInteger Var(template_backtrace_limit) Init(10)\n Set the maximum number of template instantiation notes for a single warning or error."}, {"sha": "a3893a4725e55b9002613cd04d37e5e98582c16f", "filename": "gcc/common.opt", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -1328,6 +1328,14 @@ Enum(diagnostic_url_rule) String(always) Value(DIAGNOSTICS_URL_YES)\n EnumValue\n Enum(diagnostic_url_rule) String(auto) Value(DIAGNOSTICS_URL_AUTO)\n \n+fdiagnostics-column-unit=\n+Common Joined RejectNegative Enum(diagnostics_column_unit)\n+-fdiagnostics-column-unit=[display|byte]\tSelect whether column numbers are output as display columns (default) or raw bytes.\n+\n+fdiagnostics-column-origin=\n+Common Joined RejectNegative UInteger\n+-fdiagnostics-column-origin=<number>\tSet the number of the first column.  The default is 1-based as per GNU style, but some utilities may expect 0-based, for example.\n+\n fdiagnostics-format=\n Common Joined RejectNegative Enum(diagnostics_output_format)\n -fdiagnostics-format=[text|json]\tSelect output format.\n@@ -1336,6 +1344,15 @@ Common Joined RejectNegative Enum(diagnostics_output_format)\n SourceInclude\n diagnostic.h\n \n+Enum\n+Name(diagnostics_column_unit) Type(int)\n+\n+EnumValue\n+Enum(diagnostics_column_unit) String(display) Value(DIAGNOSTICS_COLUMN_UNIT_DISPLAY)\n+\n+EnumValue\n+Enum(diagnostics_column_unit) String(byte) Value(DIAGNOSTICS_COLUMN_UNIT_BYTE)\n+\n Enum\n Name(diagnostics_output_format) Type(int)\n \n@@ -1365,6 +1382,10 @@ fdiagnostics-path-format=\n Common Joined RejectNegative Var(flag_diagnostics_path_format) Enum(diagnostic_path_format) Init(DPF_INLINE_EVENTS)\n Specify how to print any control-flow path associated with a diagnostic.\n \n+ftabstop=\n+Common Joined RejectNegative UInteger\n+-ftabstop=<number>      Distance between tab stops for column reporting.\n+\n Enum\n Name(diagnostic_path_format) Type(int)\n "}, {"sha": "465c42fdfdea5d6a219412f6a68007f5b0d4317d", "filename": "gcc/diagnostic-format-json.cc", "status": "modified", "additions": 41, "deletions": 14, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Fdiagnostic-format-json.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Fdiagnostic-format-json.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-format-json.cc?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"diagnostic.h\"\n+#include \"selftest-diagnostic.h\"\n #include \"diagnostic-metadata.h\"\n #include \"json.h\"\n #include \"selftest.h\"\n@@ -43,21 +44,43 @@ static json::array *cur_children_array;\n /* Generate a JSON object for LOC.  */\n \n json::value *\n-json_from_expanded_location (location_t loc)\n+json_from_expanded_location (diagnostic_context *context, location_t loc)\n {\n   expanded_location exploc = expand_location (loc);\n   json::object *result = new json::object ();\n   if (exploc.file)\n     result->set (\"file\", new json::string (exploc.file));\n   result->set (\"line\", new json::integer_number (exploc.line));\n-  result->set (\"column\", new json::integer_number (exploc.column));\n+\n+  const enum diagnostics_column_unit orig_unit = context->column_unit;\n+  struct\n+  {\n+    const char *name;\n+    enum diagnostics_column_unit unit;\n+  } column_fields[] = {\n+    {\"display-column\", DIAGNOSTICS_COLUMN_UNIT_DISPLAY},\n+    {\"byte-column\", DIAGNOSTICS_COLUMN_UNIT_BYTE}\n+  };\n+  int the_column = INT_MIN;\n+  for (int i = 0; i != sizeof column_fields / sizeof (*column_fields); ++i)\n+    {\n+      context->column_unit = column_fields[i].unit;\n+      const int col = diagnostic_converted_column (context, exploc);\n+      result->set (column_fields[i].name, new json::integer_number (col));\n+      if (column_fields[i].unit == orig_unit)\n+\tthe_column = col;\n+    }\n+  gcc_assert (the_column != INT_MIN);\n+  result->set (\"column\", new json::integer_number (the_column));\n+  context->column_unit = orig_unit;\n   return result;\n }\n \n /* Generate a JSON object for LOC_RANGE.  */\n \n static json::object *\n-json_from_location_range (const location_range *loc_range, unsigned range_idx)\n+json_from_location_range (diagnostic_context *context,\n+\t\t\t  const location_range *loc_range, unsigned range_idx)\n {\n   location_t caret_loc = get_pure_location (loc_range->m_loc);\n \n@@ -68,13 +91,13 @@ json_from_location_range (const location_range *loc_range, unsigned range_idx)\n   location_t finish_loc = get_finish (loc_range->m_loc);\n \n   json::object *result = new json::object ();\n-  result->set (\"caret\", json_from_expanded_location (caret_loc));\n+  result->set (\"caret\", json_from_expanded_location (context, caret_loc));\n   if (start_loc != caret_loc\n       && start_loc != UNKNOWN_LOCATION)\n-    result->set (\"start\", json_from_expanded_location (start_loc));\n+    result->set (\"start\", json_from_expanded_location (context, start_loc));\n   if (finish_loc != caret_loc\n       && finish_loc != UNKNOWN_LOCATION)\n-    result->set (\"finish\", json_from_expanded_location (finish_loc));\n+    result->set (\"finish\", json_from_expanded_location (context, finish_loc));\n \n   if (loc_range->m_label)\n     {\n@@ -91,14 +114,14 @@ json_from_location_range (const location_range *loc_range, unsigned range_idx)\n /* Generate a JSON object for HINT.  */\n \n static json::object *\n-json_from_fixit_hint (const fixit_hint *hint)\n+json_from_fixit_hint (diagnostic_context *context, const fixit_hint *hint)\n {\n   json::object *fixit_obj = new json::object ();\n \n   location_t start_loc = hint->get_start_loc ();\n-  fixit_obj->set (\"start\", json_from_expanded_location (start_loc));\n+  fixit_obj->set (\"start\", json_from_expanded_location (context, start_loc));\n   location_t next_loc = hint->get_next_loc ();\n-  fixit_obj->set (\"next\", json_from_expanded_location (next_loc));\n+  fixit_obj->set (\"next\", json_from_expanded_location (context, next_loc));\n   fixit_obj->set (\"string\", new json::string (hint->get_string ()));\n \n   return fixit_obj;\n@@ -190,11 +213,13 @@ json_end_diagnostic (diagnostic_context *context, diagnostic_info *diagnostic,\n   else\n     {\n       /* Otherwise, make diag_obj be the top-level object within the group;\n-\t add a \"children\" array.  */\n+\t add a \"children\" array and record the column origin.  */\n       toplevel_array->append (diag_obj);\n       cur_group = diag_obj;\n       cur_children_array = new json::array ();\n       diag_obj->set (\"children\", cur_children_array);\n+      diag_obj->set (\"column-origin\",\n+\t\t     new json::integer_number (context->column_origin));\n     }\n \n   const rich_location *richloc = diagnostic->richloc;\n@@ -205,7 +230,7 @@ json_end_diagnostic (diagnostic_context *context, diagnostic_info *diagnostic,\n   for (unsigned int i = 0; i < richloc->get_num_locations (); i++)\n     {\n       const location_range *loc_range = richloc->get_range (i);\n-      json::object *loc_obj = json_from_location_range (loc_range, i);\n+      json::object *loc_obj = json_from_location_range (context, loc_range, i);\n       if (loc_obj)\n \tloc_array->append (loc_obj);\n     }\n@@ -217,7 +242,7 @@ json_end_diagnostic (diagnostic_context *context, diagnostic_info *diagnostic,\n       for (unsigned int i = 0; i < richloc->get_num_fixit_hints (); i++)\n \t{\n \t  const fixit_hint *hint = richloc->get_fixit_hint (i);\n-\t  json::object *fixit_obj = json_from_fixit_hint (hint);\n+\t  json::object *fixit_obj = json_from_fixit_hint (context, hint);\n \t  fixit_array->append (fixit_obj);\n \t}\n     }\n@@ -320,7 +345,8 @@ namespace selftest {\n static void\n test_unknown_location ()\n {\n-  delete json_from_expanded_location (UNKNOWN_LOCATION);\n+  test_diagnostic_context dc;\n+  delete json_from_expanded_location (&dc, UNKNOWN_LOCATION);\n }\n \n /* Verify that we gracefully handle attempts to serialize bad\n@@ -338,7 +364,8 @@ test_bad_endpoints ()\n   loc_range.m_range_display_kind = SHOW_RANGE_WITH_CARET;\n   loc_range.m_label = NULL;\n \n-  json::object *obj = json_from_location_range (&loc_range, 0);\n+  test_diagnostic_context dc;\n+  json::object *obj = json_from_location_range (&dc, &loc_range, 0);\n   /* We should have a \"caret\" value, but no \"start\" or \"finish\" values.  */\n   ASSERT_TRUE (obj != NULL);\n   ASSERT_TRUE (obj->get (\"caret\") != NULL);"}, {"sha": "da3c5b6a92dd25dc6eb08c6f30b73057f07ca917", "filename": "gcc/diagnostic-show-locus.c", "status": "modified", "additions": 369, "deletions": 135, "changes": 504, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Fdiagnostic-show-locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Fdiagnostic-show-locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-show-locus.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -175,9 +175,10 @@ enum column_unit {\n class exploc_with_display_col : public expanded_location\n {\n  public:\n-  exploc_with_display_col (const expanded_location &exploc)\n+  exploc_with_display_col (const expanded_location &exploc, int tabstop)\n     : expanded_location (exploc),\n-      m_display_col (location_compute_display_column (exploc)) {}\n+      m_display_col (location_compute_display_column (exploc, tabstop))\n+  {}\n \n   int m_display_col;\n };\n@@ -189,11 +190,11 @@ class exploc_with_display_col : public expanded_location\n class layout_point\n {\n  public:\n-  layout_point (const expanded_location &exploc)\n+  layout_point (const exploc_with_display_col &exploc)\n     : m_line (exploc.line)\n   {\n     m_columns[CU_BYTES] = exploc.column;\n-    m_columns[CU_DISPLAY_COLS] = location_compute_display_column (exploc);\n+    m_columns[CU_DISPLAY_COLS] = exploc.m_display_col;\n   }\n \n   linenum_type m_line;\n@@ -205,10 +206,10 @@ class layout_point\n class layout_range\n {\n  public:\n-  layout_range (const expanded_location *start_exploc,\n-\t\tconst expanded_location *finish_exploc,\n+  layout_range (const exploc_with_display_col &start_exploc,\n+\t\tconst exploc_with_display_col &finish_exploc,\n \t\tenum range_display_kind range_display_kind,\n-\t\tconst expanded_location *caret_exploc,\n+\t\tconst exploc_with_display_col &caret_exploc,\n \t\tunsigned original_idx,\n \t\tconst range_label *label);\n \n@@ -226,22 +227,18 @@ class layout_range\n \n /* A struct for use by layout::print_source_line for telling\n    layout::print_annotation_line the extents of the source line that\n-   it printed, so that underlines can be clipped appropriately.  */\n+   it printed, so that underlines can be clipped appropriately.  Units\n+   are 1-based display columns.  */\n \n struct line_bounds\n {\n-  int m_first_non_ws;\n-  int m_last_non_ws;\n+  int m_first_non_ws_disp_col;\n+  int m_last_non_ws_disp_col;\n \n-  void convert_to_display_cols (char_span line)\n+  line_bounds ()\n   {\n-    m_first_non_ws = cpp_byte_column_to_display_column (line.get_buffer (),\n-\t\t\t\t\t\t\tline.length (),\n-\t\t\t\t\t\t\tm_first_non_ws);\n-\n-    m_last_non_ws = cpp_byte_column_to_display_column (line.get_buffer (),\n-\t\t\t\t\t\t       line.length (),\n-\t\t\t\t\t\t       m_last_non_ws);\n+    m_first_non_ws_disp_col = INT_MAX;\n+    m_last_non_ws_disp_col = 0;\n   }\n };\n \n@@ -351,8 +348,8 @@ class layout\n  private:\n   bool will_show_line_p (linenum_type row) const;\n   void print_leading_fixits (linenum_type row);\n-  void print_source_line (linenum_type row, const char *line, int line_bytes,\n-\t\t\t  line_bounds *lbounds_out);\n+  line_bounds print_source_line (linenum_type row, const char *line,\n+\t\t\t\t int line_bytes);\n   bool should_print_annotation_line_p (linenum_type row) const;\n   void start_annotation_line (char margin_char = ' ') const;\n   void print_annotation_line (linenum_type row, const line_bounds lbounds);\n@@ -513,16 +510,16 @@ colorizer::get_color_by_name (const char *name)\n    Initialize various layout_point fields from expanded_location\n    equivalents; we've already filtered on file.  */\n \n-layout_range::layout_range (const expanded_location *start_exploc,\n-\t\t\t    const expanded_location *finish_exploc,\n+layout_range::layout_range (const exploc_with_display_col &start_exploc,\n+\t\t\t    const exploc_with_display_col &finish_exploc,\n \t\t\t    enum range_display_kind range_display_kind,\n-\t\t\t    const expanded_location *caret_exploc,\n+\t\t\t    const exploc_with_display_col &caret_exploc,\n \t\t\t    unsigned original_idx,\n \t\t\t    const range_label *label)\n-: m_start (*start_exploc),\n-  m_finish (*finish_exploc),\n+: m_start (start_exploc),\n+  m_finish (finish_exploc),\n   m_range_display_kind (range_display_kind),\n-  m_caret (*caret_exploc),\n+  m_caret (caret_exploc),\n   m_original_idx (original_idx),\n   m_label (label)\n {\n@@ -646,6 +643,9 @@ layout_range::intersects_line_p (linenum_type row) const\n \n #if CHECKING_P\n \n+/* Default for when we don't care what the tab expansion is set to.  */\n+static const int def_tabstop = 8;\n+\n /* Create some expanded locations for testing layout_range.  The filename\n    member of the explocs is set to the empty string.  This member will only be\n    inspected by the calls to location_compute_display_column() made from the\n@@ -662,8 +662,11 @@ make_range (int start_line, int start_col, int end_line, int end_col)\n     = {\"\", start_line, start_col, NULL, false};\n   const expanded_location finish_exploc\n     = {\"\", end_line, end_col, NULL, false};\n-  return layout_range (&start_exploc, &finish_exploc, SHOW_RANGE_WITHOUT_CARET,\n-\t\t       &start_exploc, 0, NULL);\n+  return layout_range (exploc_with_display_col (start_exploc, def_tabstop),\n+\t\t       exploc_with_display_col (finish_exploc, def_tabstop),\n+\t\t       SHOW_RANGE_WITHOUT_CARET,\n+\t\t       exploc_with_display_col (start_exploc, def_tabstop),\n+\t\t       0, NULL);\n }\n \n /* Selftests for layout_range::contains_point and\n@@ -964,7 +967,7 @@ layout::layout (diagnostic_context * context,\n : m_context (context),\n   m_pp (context->printer),\n   m_primary_loc (richloc->get_range (0)->m_loc),\n-  m_exploc (richloc->get_expanded_location (0)),\n+  m_exploc (richloc->get_expanded_location (0), context->tabstop),\n   m_colorizer (context, diagnostic_kind),\n   m_colorize_source_p (context->colorize_source_p),\n   m_show_labels_p (context->show_labels_p),\n@@ -1060,7 +1063,10 @@ layout::maybe_add_location_range (const location_range *loc_range,\n \n   /* Everything is now known to be in the correct source file,\n      but it may require further sanitization.  */\n-  layout_range ri (&start, &finish, loc_range->m_range_display_kind, &caret,\n+  layout_range ri (exploc_with_display_col (start, m_context->tabstop),\n+\t\t   exploc_with_display_col (finish, m_context->tabstop),\n+\t\t   loc_range->m_range_display_kind,\n+\t\t   exploc_with_display_col (caret, m_context->tabstop),\n \t\t   original_idx, loc_range->m_label);\n \n   /* If we have a range that finishes before it starts (perhaps\n@@ -1394,7 +1400,7 @@ layout::calculate_x_offset_display ()\n     = get_line_bytes_without_trailing_whitespace (line.get_buffer (),\n \t\t\t\t\t\t  line.length ());\n   int eol_display_column\n-    = cpp_display_width (line.get_buffer (), line_bytes);\n+    = cpp_display_width (line.get_buffer (), line_bytes, m_context->tabstop);\n   if (caret_display_column > eol_display_column\n       || !caret_display_column)\n     {\n@@ -1445,16 +1451,13 @@ layout::calculate_x_offset_display ()\n }\n \n /* Print line ROW of source code, potentially colorized at any ranges, and\n-   populate *LBOUNDS_OUT.\n-   LINE is the source line (not necessarily 0-terminated) and LINE_BYTES\n-   is its length in bytes.\n-   This function deals only with byte offsets, not display columns, so\n-   m_x_offset_display must be converted from display to byte units.  In\n-   particular, LINE_BYTES and LBOUNDS_OUT are in bytes.  */\n+   return the line bounds.  LINE is the source line (not necessarily\n+   0-terminated) and LINE_BYTES is its length in bytes.  In order to handle both\n+   colorization and tab expansion, this function tracks the line position in\n+   both byte and display column units.  */\n \n-void\n-layout::print_source_line (linenum_type row, const char *line, int line_bytes,\n-\t\t\t   line_bounds *lbounds_out)\n+line_bounds\n+layout::print_source_line (linenum_type row, const char *line, int line_bytes)\n {\n   m_colorizer.set_normal_text ();\n \n@@ -1469,30 +1472,29 @@ layout::print_source_line (linenum_type row, const char *line, int line_bytes,\n   else\n     pp_space (m_pp);\n \n-  /* We will stop printing the source line at any trailing whitespace, and start\n-     printing it as per m_x_offset_display.  */\n+  /* We will stop printing the source line at any trailing whitespace.  */\n   line_bytes = get_line_bytes_without_trailing_whitespace (line,\n \t\t\t\t\t\t\t   line_bytes);\n-  int x_offset_bytes = 0;\n-  if (m_x_offset_display)\n-    {\n-      x_offset_bytes = cpp_display_column_to_byte_column (line, line_bytes,\n-\t\t\t\t\t\t\t  m_x_offset_display);\n-      /* In case the leading portion of the line that will be skipped over ends\n-\t with a character with wcwidth > 1, then it is possible we skipped too\n-\t much, so account for that by padding with spaces.  */\n-      const int overage\n-\t= cpp_byte_column_to_display_column (line, line_bytes, x_offset_bytes)\n-\t- m_x_offset_display;\n-      for (int column = 0; column < overage; ++column)\n-\tpp_space (m_pp);\n-      line += x_offset_bytes;\n-    }\n \n-  /* Print the line.  */\n-  int first_non_ws = INT_MAX;\n-  int last_non_ws = 0;\n-  for (int col_byte = 1 + x_offset_bytes; col_byte <= line_bytes; col_byte++)\n+  /* This object helps to keep track of which display column we are at, which is\n+     necessary for computing the line bounds in display units, for doing\n+     tab expansion, and for implementing m_x_offset_display.  */\n+  cpp_display_width_computation dw (line, line_bytes, m_context->tabstop);\n+\n+  /* Skip the first m_x_offset_display display columns.  In case the leading\n+     portion that will be skipped ends with a character with wcwidth > 1, then\n+     it is possible we skipped too much, so account for that by padding with\n+     spaces.  Note that this does the right thing too in case a tab was the last\n+     character to be skipped over; the tab is effectively replaced by the\n+     correct number of trailing spaces needed to offset by the desired number of\n+     display columns.  */\n+  for (int skipped_display_cols = dw.advance_display_cols (m_x_offset_display);\n+       skipped_display_cols > m_x_offset_display; --skipped_display_cols)\n+    pp_space (m_pp);\n+\n+  /* Print the line and compute the line_bounds.  */\n+  line_bounds lbounds;\n+  while (!dw.done ())\n     {\n       /* Assuming colorization is enabled for the caret and underline\n \t characters, we may also colorize the associated characters\n@@ -1510,7 +1512,8 @@ layout::print_source_line (linenum_type row, const char *line, int line_bytes,\n \t{\n \t  bool in_range_p;\n \t  point_state state;\n-\t  in_range_p = get_state_at_point (row, col_byte,\n+\t  const int start_byte_col = dw.bytes_processed () + 1;\n+\t  in_range_p = get_state_at_point (row, start_byte_col,\n \t\t\t\t\t   0, INT_MAX,\n \t\t\t\t\t   CU_BYTES,\n \t\t\t\t\t   &state);\n@@ -1519,22 +1522,44 @@ layout::print_source_line (linenum_type row, const char *line, int line_bytes,\n \t  else\n \t    m_colorizer.set_normal_text ();\n \t}\n-      char c = *line;\n-      if (c == '\\0' || c == '\\t' || c == '\\r')\n-\tc = ' ';\n-      if (c != ' ')\n+\n+      /* Get the display width of the next character to be output, expanding\n+\t tabs and replacing some control bytes with spaces as necessary.  */\n+      const char *c = dw.next_byte ();\n+      const int start_disp_col = dw.display_cols_processed () + 1;\n+      const int this_display_width = dw.process_next_codepoint ();\n+      if (*c == '\\t')\n+\t{\n+\t  /* The returned display width is the number of spaces into which the\n+\t     tab should be expanded.  */\n+\t  for (int i = 0; i != this_display_width; ++i)\n+\t    pp_space (m_pp);\n+\t  continue;\n+\t}\n+      if (*c == '\\0' || *c == '\\r')\n \t{\n-\t  last_non_ws = col_byte;\n-\t  if (first_non_ws == INT_MAX)\n-\t    first_non_ws = col_byte;\n+\t  /* cpp_wcwidth() promises to return 1 for all control bytes, and we\n+\t     want to output these as a single space too, so this case is\n+\t     actually the same as the '\\t' case.  */\n+\t  gcc_assert (this_display_width == 1);\n+\t  pp_space (m_pp);\n+\t  continue;\n \t}\n-      pp_character (m_pp, c);\n-      line++;\n+\n+      /* We have a (possibly multibyte) character to output; update the line\n+\t bounds if it is not whitespace.  */\n+      if (*c != ' ')\n+\t{\n+\t  lbounds.m_last_non_ws_disp_col = dw.display_cols_processed ();\n+\t  if (lbounds.m_first_non_ws_disp_col == INT_MAX)\n+\t    lbounds.m_first_non_ws_disp_col = start_disp_col;\n+\t}\n+\n+      /* Output the character.  */\n+      while (c != dw.next_byte ()) pp_character (m_pp, *c++);\n     }\n   print_newline ();\n-\n-  lbounds_out->m_first_non_ws = first_non_ws;\n-  lbounds_out->m_last_non_ws = last_non_ws;\n+  return lbounds;\n }\n \n /* Determine if we should print an annotation line for ROW.\n@@ -1576,14 +1601,13 @@ layout::start_annotation_line (char margin_char) const\n }\n \n /* Print a line consisting of the caret/underlines for the given\n-   source line.  This function works with display columns, rather than byte\n-   counts; in particular, LBOUNDS should be in display column units.  */\n+   source line.  */\n \n void\n layout::print_annotation_line (linenum_type row, const line_bounds lbounds)\n {\n   int x_bound = get_x_bound_for_row (row, m_exploc.m_display_col,\n-\t\t\t\t     lbounds.m_last_non_ws);\n+\t\t\t\t     lbounds.m_last_non_ws_disp_col);\n \n   start_annotation_line ();\n   pp_space (m_pp);\n@@ -1593,8 +1617,8 @@ layout::print_annotation_line (linenum_type row, const line_bounds lbounds)\n       bool in_range_p;\n       point_state state;\n       in_range_p = get_state_at_point (row, column,\n-\t\t\t\t       lbounds.m_first_non_ws,\n-\t\t\t\t       lbounds.m_last_non_ws,\n+\t\t\t\t       lbounds.m_first_non_ws_disp_col,\n+\t\t\t\t       lbounds.m_last_non_ws_disp_col,\n \t\t\t\t       CU_DISPLAY_COLS,\n \t\t\t\t       &state);\n       if (in_range_p)\n@@ -1631,12 +1655,14 @@ layout::print_annotation_line (linenum_type row, const line_bounds lbounds)\n class line_label\n {\n public:\n-  line_label (int state_idx, int column, label_text text)\n+  line_label (diagnostic_context *context, int state_idx, int column,\n+\t      label_text text)\n   : m_state_idx (state_idx), m_column (column),\n     m_text (text), m_label_line (0), m_has_vbar (true)\n   {\n     const int bytes = strlen (text.m_buffer);\n-    m_display_width = cpp_display_width (text.m_buffer, bytes);\n+    m_display_width\n+      = cpp_display_width (text.m_buffer, bytes, context->tabstop);\n   }\n \n   /* Sorting is primarily by column, then by state index.  */\n@@ -1696,7 +1722,7 @@ layout::print_any_labels (linenum_type row)\n \tif (text.m_buffer == NULL)\n \t  continue;\n \n-\tlabels.safe_push (line_label (i, disp_col, text));\n+\tlabels.safe_push (line_label (m_context, i, disp_col, text));\n       }\n   }\n \n@@ -1976,7 +2002,8 @@ class column_range\n \n /* Get the range of bytes or display columns that HINT would affect.  */\n static column_range\n-get_affected_range (const fixit_hint *hint, enum column_unit col_unit)\n+get_affected_range (diagnostic_context *context,\n+\t\t    const fixit_hint *hint, enum column_unit col_unit)\n {\n   expanded_location exploc_start = expand_location (hint->get_start_loc ());\n   expanded_location exploc_finish = expand_location (hint->get_next_loc ());\n@@ -1986,11 +2013,13 @@ get_affected_range (const fixit_hint *hint, enum column_unit col_unit)\n   int finish_column;\n   if (col_unit == CU_DISPLAY_COLS)\n     {\n-      start_column = location_compute_display_column (exploc_start);\n+      start_column\n+\t= location_compute_display_column (exploc_start, context->tabstop);\n       if (hint->insertion_p ())\n \tfinish_column = start_column - 1;\n       else\n-\tfinish_column = location_compute_display_column (exploc_finish);\n+\tfinish_column\n+\t  = location_compute_display_column (exploc_finish, context->tabstop);\n     }\n   else\n     {\n@@ -2003,12 +2032,12 @@ get_affected_range (const fixit_hint *hint, enum column_unit col_unit)\n /* Get the range of display columns that would be printed for HINT.  */\n \n static column_range\n-get_printed_columns (const fixit_hint *hint)\n+get_printed_columns (diagnostic_context *context, const fixit_hint *hint)\n {\n   expanded_location exploc = expand_location (hint->get_start_loc ());\n-  int start_column = location_compute_display_column (exploc);\n-  int hint_width = cpp_display_width (hint->get_string (),\n-\t\t\t\t      hint->get_length ());\n+  int start_column = location_compute_display_column (exploc, context->tabstop);\n+  int hint_width = cpp_display_width (hint->get_string (), hint->get_length (),\n+\t\t\t\t      context->tabstop);\n   int final_hint_column = start_column + hint_width - 1;\n   if (hint->insertion_p ())\n     {\n@@ -2018,7 +2047,8 @@ get_printed_columns (const fixit_hint *hint)\n     {\n       exploc = expand_location (hint->get_next_loc ());\n       --exploc.column;\n-      int finish_column = location_compute_display_column (exploc);\n+      int finish_column\n+\t= location_compute_display_column (exploc, context->tabstop);\n       return column_range (start_column,\n \t\t\t   MAX (finish_column, final_hint_column));\n     }\n@@ -2035,12 +2065,14 @@ class correction\n   correction (column_range affected_bytes,\n \t      column_range affected_columns,\n \t      column_range printed_columns,\n-\t      const char *new_text, size_t new_text_len)\n+\t      const char *new_text, size_t new_text_len,\n+\t      int tabstop)\n   : m_affected_bytes (affected_bytes),\n     m_affected_columns (affected_columns),\n     m_printed_columns (printed_columns),\n     m_text (xstrdup (new_text)),\n     m_byte_length (new_text_len),\n+    m_tabstop (tabstop),\n     m_alloc_sz (new_text_len + 1)\n   {\n     compute_display_cols ();\n@@ -2058,7 +2090,7 @@ class correction\n \n   void compute_display_cols ()\n   {\n-    m_display_cols = cpp_display_width (m_text, m_byte_length);\n+    m_display_cols = cpp_display_width (m_text, m_byte_length, m_tabstop);\n   }\n \n   void overwrite (int dst_offset, const char_span &src_span)\n@@ -2086,6 +2118,7 @@ class correction\n   char *m_text;\n   size_t m_byte_length; /* Not including null-terminator.  */\n   int m_display_cols;\n+  int m_tabstop;\n   size_t m_alloc_sz;\n };\n \n@@ -2121,13 +2154,15 @@ correction::ensure_terminated ()\n class line_corrections\n {\n public:\n-  line_corrections (const char *filename, linenum_type row)\n-  : m_filename (filename), m_row (row)\n+  line_corrections (diagnostic_context *context, const char *filename,\n+\t\t    linenum_type row)\n+    : m_context (context), m_filename (filename), m_row (row)\n   {}\n   ~line_corrections ();\n \n   void add_hint (const fixit_hint *hint);\n \n+  diagnostic_context *m_context;\n   const char *m_filename;\n   linenum_type m_row;\n   auto_vec <correction *> m_corrections;\n@@ -2173,9 +2208,10 @@ source_line::source_line (const char *filename, int line)\n void\n line_corrections::add_hint (const fixit_hint *hint)\n {\n-  column_range affected_bytes = get_affected_range (hint, CU_BYTES);\n-  column_range affected_columns = get_affected_range (hint, CU_DISPLAY_COLS);\n-  column_range printed_columns = get_printed_columns (hint);\n+  column_range affected_bytes = get_affected_range (m_context, hint, CU_BYTES);\n+  column_range affected_columns = get_affected_range (m_context, hint,\n+\t\t\t\t\t\t      CU_DISPLAY_COLS);\n+  column_range printed_columns = get_printed_columns (m_context, hint);\n \n   /* Potentially consolidate.  */\n   if (!m_corrections.is_empty ())\n@@ -2243,7 +2279,8 @@ line_corrections::add_hint (const fixit_hint *hint)\n \t\t\t\t\t   affected_columns,\n \t\t\t\t\t   printed_columns,\n \t\t\t\t\t   hint->get_string (),\n-\t\t\t\t\t   hint->get_length ()));\n+\t\t\t\t\t   hint->get_length (),\n+\t\t\t\t\t   m_context->tabstop));\n }\n \n /* If there are any fixit hints on source line ROW, print them.\n@@ -2257,7 +2294,7 @@ layout::print_trailing_fixits (linenum_type row)\n {\n   /* Build a list of correction instances for the line,\n      potentially consolidating hints (for the sake of readability).  */\n-  line_corrections corrections (m_exploc.file, row);\n+  line_corrections corrections (m_context, m_exploc.file, row);\n   for (unsigned int i = 0; i < m_fixit_hints.length (); i++)\n     {\n       const fixit_hint *hint = m_fixit_hints[i];\n@@ -2499,15 +2536,11 @@ layout::print_line (linenum_type row)\n   if (!line)\n     return;\n \n-  line_bounds lbounds;\n   print_leading_fixits (row);\n-  print_source_line (row, line.get_buffer (), line.length (), &lbounds);\n+  const line_bounds lbounds\n+    = print_source_line (row, line.get_buffer (), line.length ());\n   if (should_print_annotation_line_p (row))\n-    {\n-      if (lbounds.m_first_non_ws != INT_MAX)\n-\tlbounds.convert_to_display_cols (line);\n-      print_annotation_line (row, lbounds);\n-    }\n+    print_annotation_line (row, lbounds);\n   if (m_show_labels_p)\n     print_any_labels (row);\n   print_trailing_fixits (row);\n@@ -2670,9 +2703,11 @@ test_layout_x_offset_display_utf8 (const line_table_case &case_)\n \n   char_span lspan = location_get_source_line (tmp.get_filename (), 1);\n   ASSERT_EQ (line_display_cols,\n-\t     cpp_display_width (lspan.get_buffer (), lspan.length ()));\n+\t     cpp_display_width (lspan.get_buffer (), lspan.length (),\n+\t\t\t\tdef_tabstop));\n   ASSERT_EQ (line_display_cols,\n-\t     location_compute_display_column (expand_location (line_end)));\n+\t     location_compute_display_column (expand_location (line_end),\n+\t\t\t\t\t      def_tabstop));\n   ASSERT_EQ (0, memcmp (lspan.get_buffer () + (emoji_col - 1),\n \t\t\t\"\\xf0\\x9f\\x98\\x82\\xf0\\x9f\\x98\\x82\", 8));\n \n@@ -2774,6 +2809,111 @@ test_layout_x_offset_display_utf8 (const line_table_case &case_)\n \n }\n \n+static void\n+test_layout_x_offset_display_tab (const line_table_case &case_)\n+{\n+  const char *content\n+    = \"This line is very long, so that we can use it to test the logic for \"\n+      \"clipping long lines.  Also this: `\\t' is a tab that occupies 1 byte and \"\n+      \"a variable number of display columns, starting at column #103.\\n\";\n+\n+  /* Number of bytes in the line, subtracting one to remove the newline.  */\n+  const int line_bytes = strlen (content) - 1;\n+\n+ /* The column where the tab begins.  Byte or display is the same as there are\n+    no multibyte characters earlier on the line.  */\n+  const int tab_col = 103;\n+\n+  /* Effective extra size of the tab beyond what a single space would have taken\n+     up, indexed by tabstop.  */\n+  static const int num_tabstops = 11;\n+  int extra_width[num_tabstops];\n+  for (int tabstop = 1; tabstop != num_tabstops; ++tabstop)\n+    {\n+      const int this_tab_size = tabstop - (tab_col - 1) % tabstop;\n+      extra_width[tabstop] = this_tab_size - 1;\n+    }\n+  /* Example of this calculation: if tabstop is 10, the tab starting at column\n+     #103 has to expand into 8 spaces, covering columns 103-110, so that the\n+     next character is at column #111.  So it takes up 7 more columns than\n+     a space would have taken up.  */\n+  ASSERT_EQ (7, extra_width[10]);\n+\n+  temp_source_file tmp (SELFTEST_LOCATION, \".c\", content);\n+  line_table_test ltt (case_);\n+\n+  linemap_add (line_table, LC_ENTER, false, tmp.get_filename (), 1);\n+\n+  location_t line_end = linemap_position_for_column (line_table, line_bytes);\n+\n+  /* Don't attempt to run the tests if column data might be unavailable.  */\n+  if (line_end > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    return;\n+\n+  /* Check that cpp_display_width handles the tabs as expected.  */\n+  char_span lspan = location_get_source_line (tmp.get_filename (), 1);\n+  ASSERT_EQ ('\\t', *(lspan.get_buffer () + (tab_col - 1)));\n+  for (int tabstop = 1; tabstop != num_tabstops; ++tabstop)\n+    {\n+      ASSERT_EQ (line_bytes + extra_width[tabstop],\n+\t\t cpp_display_width (lspan.get_buffer (), lspan.length (),\n+\t\t\t\t    tabstop));\n+      ASSERT_EQ (line_bytes + extra_width[tabstop],\n+\t\t location_compute_display_column (expand_location (line_end),\n+\t\t\t\t\t\t  tabstop));\n+    }\n+\n+  /* Check that the tab is expanded to the expected number of spaces.  */\n+  rich_location richloc (line_table,\n+\t\t\t linemap_position_for_column (line_table,\n+\t\t\t\t\t\t      tab_col + 1));\n+  for (int tabstop = 1; tabstop != num_tabstops; ++tabstop)\n+    {\n+      test_diagnostic_context dc;\n+      dc.tabstop = tabstop;\n+      layout test_layout (&dc, &richloc, DK_ERROR);\n+      test_layout.print_line (1);\n+      const char *out = pp_formatted_text (dc.printer);\n+      ASSERT_EQ (NULL, strchr (out, '\\t'));\n+      const char *left_quote = strchr (out, '`');\n+      const char *right_quote = strchr (out, '\\'');\n+      ASSERT_NE (NULL, left_quote);\n+      ASSERT_NE (NULL, right_quote);\n+      ASSERT_EQ (right_quote - left_quote, extra_width[tabstop] + 2);\n+    }\n+\n+  /* Check that the line is offset properly and that the tab is broken up\n+     into the expected number of spaces when it is the last character skipped\n+     over.  */\n+  for (int tabstop = 1; tabstop != num_tabstops; ++tabstop)\n+    {\n+      test_diagnostic_context dc;\n+      dc.tabstop = tabstop;\n+      static const int small_width = 24;\n+      dc.caret_max_width = small_width - 4;\n+      dc.min_margin_width = test_left_margin - test_linenum_sep + 1;\n+      dc.show_line_numbers_p = true;\n+      layout test_layout (&dc, &richloc, DK_ERROR);\n+      test_layout.print_line (1);\n+\n+      /* We have arranged things so that two columns will be printed before\n+\t the caret.  If the tab results in more than one space, this should\n+\t produce two spaces in the output; otherwise, it will be a single space\n+\t preceded by the opening quote before the tab character.  */\n+      const char *output1\n+\t= \"   1 |   ' is a tab that occupies 1 byte and a variable number of \"\n+\t  \"display columns, starting at column #103.\\n\"\n+\t  \"     |   ^\\n\\n\";\n+      const char *output2\n+\t= \"   1 | ` ' is a tab that occupies 1 byte and a variable number of \"\n+\t  \"display columns, starting at column #103.\\n\"\n+\t  \"     |   ^\\n\\n\";\n+      const char *expected_output = (extra_width[tabstop] ? output1 : output2);\n+      ASSERT_STREQ (expected_output, pp_formatted_text (dc.printer));\n+    }\n+}\n+\n+\n /* Verify that diagnostic_show_locus works sanely on UNKNOWN_LOCATION.  */\n \n static void\n@@ -3854,6 +3994,27 @@ test_one_liner_labels_utf8 ()\n   }\n }\n \n+/* Make sure that colorization codes don't interrupt a multibyte\n+   sequence, which would corrupt it.  */\n+static void\n+test_one_liner_colorized_utf8 ()\n+{\n+  test_diagnostic_context dc;\n+  dc.colorize_source_p = true;\n+  diagnostic_color_init (&dc, DIAGNOSTICS_COLOR_YES);\n+  const location_t pi = linemap_position_for_column (line_table, 12);\n+  rich_location richloc (line_table, pi);\n+  diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+\n+  /* In order to avoid having the test depend on exactly how the colorization\n+     was effected, just confirm there are two pi characters in the output.  */\n+  const char *result = pp_formatted_text (dc.printer);\n+  const char *null_term = result + strlen (result);\n+  const char *first_pi = strstr (result, \"\\xcf\\x80\");\n+  ASSERT_TRUE (first_pi && first_pi <= null_term - 2);\n+  ASSERT_STR_CONTAINS (first_pi + 2, \"\\xcf\\x80\");\n+}\n+\n /* Run the various one-liner tests.  */\n \n static void\n@@ -3884,8 +4045,10 @@ test_diagnostic_show_locus_one_liner_utf8 (const line_table_case &case_)\n   ASSERT_EQ (31, LOCATION_COLUMN (line_end));\n \n   char_span lspan = location_get_source_line (tmp.get_filename (), 1);\n-  ASSERT_EQ (25, cpp_display_width (lspan.get_buffer (), lspan.length ()));\n-  ASSERT_EQ (25, location_compute_display_column (expand_location (line_end)));\n+  ASSERT_EQ (25, cpp_display_width (lspan.get_buffer (), lspan.length (),\n+\t\t\t\t    def_tabstop));\n+  ASSERT_EQ (25, location_compute_display_column (expand_location (line_end),\n+\t\t\t\t\t\t  def_tabstop));\n \n   test_one_liner_simple_caret_utf8 ();\n   test_one_liner_caret_and_range_utf8 ();\n@@ -3900,6 +4063,7 @@ test_diagnostic_show_locus_one_liner_utf8 (const line_table_case &case_)\n   test_one_liner_many_fixits_1_utf8 ();\n   test_one_liner_many_fixits_2_utf8 ();\n   test_one_liner_labels_utf8 ();\n+  test_one_liner_colorized_utf8 ();\n }\n \n /* Verify that gcc_rich_location::add_location_if_nearby works.  */\n@@ -4272,25 +4436,28 @@ test_overlapped_fixit_printing (const line_table_case &case_)\n     /* Unit-test the line_corrections machinery.  */\n     ASSERT_EQ (3, richloc.get_num_fixit_hints ());\n     const fixit_hint *hint_0 = richloc.get_fixit_hint (0);\n-    ASSERT_EQ (column_range (12, 12), get_affected_range (hint_0, CU_BYTES));\n     ASSERT_EQ (column_range (12, 12),\n-\t\t\t   get_affected_range (hint_0, CU_DISPLAY_COLS));\n-    ASSERT_EQ (column_range (12, 22), get_printed_columns (hint_0));\n+\t       get_affected_range (&dc, hint_0, CU_BYTES));\n+    ASSERT_EQ (column_range (12, 12),\n+\t       get_affected_range (&dc, hint_0, CU_DISPLAY_COLS));\n+    ASSERT_EQ (column_range (12, 22), get_printed_columns (&dc, hint_0));\n     const fixit_hint *hint_1 = richloc.get_fixit_hint (1);\n-    ASSERT_EQ (column_range (18, 18), get_affected_range (hint_1, CU_BYTES));\n     ASSERT_EQ (column_range (18, 18),\n-\t\t\t   get_affected_range (hint_1, CU_DISPLAY_COLS));\n-    ASSERT_EQ (column_range (18, 20), get_printed_columns (hint_1));\n+\t       get_affected_range (&dc, hint_1, CU_BYTES));\n+    ASSERT_EQ (column_range (18, 18),\n+\t       get_affected_range (&dc, hint_1, CU_DISPLAY_COLS));\n+    ASSERT_EQ (column_range (18, 20), get_printed_columns (&dc, hint_1));\n     const fixit_hint *hint_2 = richloc.get_fixit_hint (2);\n-    ASSERT_EQ (column_range (29, 28), get_affected_range (hint_2, CU_BYTES));\n     ASSERT_EQ (column_range (29, 28),\n-\t\t\t   get_affected_range (hint_2, CU_DISPLAY_COLS));\n-    ASSERT_EQ (column_range (29, 29), get_printed_columns (hint_2));\n+\t       get_affected_range (&dc, hint_2, CU_BYTES));\n+    ASSERT_EQ (column_range (29, 28),\n+\t       get_affected_range (&dc, hint_2, CU_DISPLAY_COLS));\n+    ASSERT_EQ (column_range (29, 29), get_printed_columns (&dc, hint_2));\n \n     /* Add each hint in turn to a line_corrections instance,\n        and verify that they are consolidated into one correction instance\n        as expected.  */\n-    line_corrections lc (tmp.get_filename (), 1);\n+    line_corrections lc (&dc, tmp.get_filename (), 1);\n \n     /* The first replace hint by itself.  */\n     lc.add_hint (hint_0);\n@@ -4484,25 +4651,28 @@ test_overlapped_fixit_printing_utf8 (const line_table_case &case_)\n     /* Unit-test the line_corrections machinery.  */\n     ASSERT_EQ (3, richloc.get_num_fixit_hints ());\n     const fixit_hint *hint_0 = richloc.get_fixit_hint (0);\n-    ASSERT_EQ (column_range (14, 14), get_affected_range (hint_0, CU_BYTES));\n+    ASSERT_EQ (column_range (14, 14),\n+\t       get_affected_range (&dc, hint_0, CU_BYTES));\n     ASSERT_EQ (column_range (12, 12),\n-\t\t\t   get_affected_range (hint_0, CU_DISPLAY_COLS));\n-    ASSERT_EQ (column_range (12, 22), get_printed_columns (hint_0));\n+\t       get_affected_range (&dc, hint_0, CU_DISPLAY_COLS));\n+    ASSERT_EQ (column_range (12, 22), get_printed_columns (&dc, hint_0));\n     const fixit_hint *hint_1 = richloc.get_fixit_hint (1);\n-    ASSERT_EQ (column_range (22, 22), get_affected_range (hint_1, CU_BYTES));\n+    ASSERT_EQ (column_range (22, 22),\n+\t       get_affected_range (&dc, hint_1, CU_BYTES));\n     ASSERT_EQ (column_range (18, 18),\n-\t\t\t   get_affected_range (hint_1, CU_DISPLAY_COLS));\n-    ASSERT_EQ (column_range (18, 20), get_printed_columns (hint_1));\n+\t       get_affected_range (&dc, hint_1, CU_DISPLAY_COLS));\n+    ASSERT_EQ (column_range (18, 20), get_printed_columns (&dc, hint_1));\n     const fixit_hint *hint_2 = richloc.get_fixit_hint (2);\n-    ASSERT_EQ (column_range (35, 34), get_affected_range (hint_2, CU_BYTES));\n+    ASSERT_EQ (column_range (35, 34),\n+\t       get_affected_range (&dc, hint_2, CU_BYTES));\n     ASSERT_EQ (column_range (30, 29),\n-\t\t\t   get_affected_range (hint_2, CU_DISPLAY_COLS));\n-    ASSERT_EQ (column_range (30, 30), get_printed_columns (hint_2));\n+\t       get_affected_range (&dc, hint_2, CU_DISPLAY_COLS));\n+    ASSERT_EQ (column_range (30, 30), get_printed_columns (&dc, hint_2));\n \n     /* Add each hint in turn to a line_corrections instance,\n        and verify that they are consolidated into one correction instance\n        as expected.  */\n-    line_corrections lc (tmp.get_filename (), 1);\n+    line_corrections lc (&dc, tmp.get_filename (), 1);\n \n     /* The first replace hint by itself.  */\n     lc.add_hint (hint_0);\n@@ -4689,21 +4859,24 @@ test_overlapped_fixit_printing_2 (const line_table_case &case_)\n \n   /* Two insertions, in the wrong order.  */\n   {\n+    test_diagnostic_context dc;\n+\n     rich_location richloc (line_table, col_20);\n     richloc.add_fixit_insert_before (col_23, \"{\");\n     richloc.add_fixit_insert_before (col_21, \"}\");\n \n     /* These fixits should be accepted; they can't be consolidated.  */\n     ASSERT_EQ (2, richloc.get_num_fixit_hints ());\n     const fixit_hint *hint_0 = richloc.get_fixit_hint (0);\n-    ASSERT_EQ (column_range (23, 22), get_affected_range (hint_0, CU_BYTES));\n-    ASSERT_EQ (column_range (23, 23), get_printed_columns (hint_0));\n+    ASSERT_EQ (column_range (23, 22),\n+\t       get_affected_range (&dc, hint_0, CU_BYTES));\n+    ASSERT_EQ (column_range (23, 23), get_printed_columns (&dc, hint_0));\n     const fixit_hint *hint_1 = richloc.get_fixit_hint (1);\n-    ASSERT_EQ (column_range (21, 20), get_affected_range (hint_1, CU_BYTES));\n-    ASSERT_EQ (column_range (21, 21), get_printed_columns (hint_1));\n+    ASSERT_EQ (column_range (21, 20),\n+\t       get_affected_range (&dc, hint_1, CU_BYTES));\n+    ASSERT_EQ (column_range (21, 21), get_printed_columns (&dc, hint_1));\n \n     /* Verify that they're printed correctly.  */\n-    test_diagnostic_context dc;\n     diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n     ASSERT_STREQ (\" int a5[][0][0] = { 1, 2 };\\n\"\n \t\t  \"                    ^\\n\"\n@@ -4955,6 +5128,65 @@ test_fixit_deletion_affecting_newline (const line_table_case &case_)\n \t\tpp_formatted_text (dc.printer));\n }\n \n+static void\n+test_tab_expansion (const line_table_case &case_)\n+{\n+  /* Create a tempfile and write some text to it.  This example uses a tabstop\n+     of 8, as the column numbers attempt to indicate:\n+\n+    .....................000.01111111111.22222333333  display\n+    .....................123.90123456789.56789012345  columns  */\n+  const char *content = \"  \\t   This: `\\t' is a tab.\\n\";\n+  /* ....................000 00000011111 11111222222  byte\n+     ....................123 45678901234 56789012345  columns  */\n+\n+  const int tabstop = 8;\n+  const int first_non_ws_byte_col = 7;\n+  const int right_quote_byte_col = 15;\n+  const int last_byte_col = 25;\n+  ASSERT_EQ (35, cpp_display_width (content, last_byte_col, tabstop));\n+\n+  temp_source_file tmp (SELFTEST_LOCATION, \".c\", content);\n+  line_table_test ltt (case_);\n+  linemap_add (line_table, LC_ENTER, false, tmp.get_filename (), 1);\n+\n+  /* Don't attempt to run the tests if column data might be unavailable.  */\n+  location_t line_end = linemap_position_for_column (line_table, last_byte_col);\n+  if (line_end > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    return;\n+\n+  /* Check that the leading whitespace with mixed tabs and spaces is expanded\n+     into 11 spaces.  Recall that print_line() also puts one space before\n+     everything too.  */\n+  {\n+    test_diagnostic_context dc;\n+    dc.tabstop = tabstop;\n+    rich_location richloc (line_table,\n+\t\t\t   linemap_position_for_column (line_table,\n+\t\t\t\t\t\t\tfirst_non_ws_byte_col));\n+    layout test_layout (&dc, &richloc, DK_ERROR);\n+    test_layout.print_line (1);\n+    ASSERT_STREQ (\"            This: `      ' is a tab.\\n\"\n+\t\t  \"            ^\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+\n+  /* Confirm the display width was tracked correctly across the internal tab\n+     as well.  */\n+  {\n+    test_diagnostic_context dc;\n+    dc.tabstop = tabstop;\n+    rich_location richloc (line_table,\n+\t\t\t   linemap_position_for_column (line_table,\n+\t\t\t\t\t\t\tright_quote_byte_col));\n+    layout test_layout (&dc, &richloc, DK_ERROR);\n+    test_layout.print_line (1);\n+    ASSERT_STREQ (\"            This: `      ' is a tab.\\n\"\n+\t\t  \"                         ^\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+}\n+\n /* Verify that line numbers are correctly printed for the case of\n    a multiline range in which the width of the line numbers changes\n    (e.g. from \"9\" to \"10\").  */\n@@ -5012,6 +5244,7 @@ diagnostic_show_locus_c_tests ()\n   test_layout_range_for_multiple_lines ();\n \n   for_each_line_table_case (test_layout_x_offset_display_utf8);\n+  for_each_line_table_case (test_layout_x_offset_display_tab);\n \n   test_get_line_bytes_without_trailing_whitespace ();\n \n@@ -5029,6 +5262,7 @@ diagnostic_show_locus_c_tests ()\n   for_each_line_table_case (test_fixit_insert_containing_newline_2);\n   for_each_line_table_case (test_fixit_replace_containing_newline);\n   for_each_line_table_case (test_fixit_deletion_affecting_newline);\n+  for_each_line_table_case (test_tab_expansion);\n \n   test_line_numbers_multiline_range ();\n }"}, {"sha": "1b6c98458920103739fb1ffe0f682899d19b0944", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 101, "deletions": 12, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"selftest.h\"\n #include \"selftest-diagnostic.h\"\n #include \"opts.h\"\n+#include \"cpplib.h\"\n \n #ifdef HAVE_TERMIOS_H\n # include <termios.h>\n@@ -219,6 +220,9 @@ diagnostic_initialize (diagnostic_context *context, int n_opts)\n   context->min_margin_width = 0;\n   context->show_ruler_p = false;\n   context->parseable_fixits_p = false;\n+  context->column_unit = DIAGNOSTICS_COLUMN_UNIT_DISPLAY;\n+  context->column_origin = 1;\n+  context->tabstop = 8;\n   context->edit_context_ptr = NULL;\n   context->diagnostic_group_nesting_depth = 0;\n   context->diagnostic_group_emission_count = 0;\n@@ -353,8 +357,37 @@ diagnostic_get_color_for_kind (diagnostic_t kind)\n   return diagnostic_kind_color[kind];\n }\n \n+/* Given an expanded_location, convert the column (which is in 1-based bytes)\n+   to the requested units and origin.  Return -1 if the column is\n+   invalid (<= 0).  */\n+int\n+diagnostic_converted_column (diagnostic_context *context, expanded_location s)\n+{\n+  if (s.column <= 0)\n+    return -1;\n+\n+  int one_based_col;\n+  switch (context->column_unit)\n+    {\n+    case DIAGNOSTICS_COLUMN_UNIT_DISPLAY:\n+      one_based_col = location_compute_display_column (s, context->tabstop);\n+      break;\n+\n+    case DIAGNOSTICS_COLUMN_UNIT_BYTE:\n+      one_based_col = s.column;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return one_based_col + (context->column_origin - 1);\n+}\n+\n /* Return a formatted line and column ':%line:%column'.  Elided if\n-   zero.  The result is a statically allocated buffer.  */\n+   line == 0 or col < 0.  (A column of 0 may be valid due to the\n+   -fdiagnostics-column-origin option.)\n+   The result is a statically allocated buffer.  */\n \n static const char *\n maybe_line_and_column (int line, int col)\n@@ -363,8 +396,9 @@ maybe_line_and_column (int line, int col)\n \n   if (line)\n     {\n-      size_t l = snprintf (result, sizeof (result),\n-\t\t\t   col ? \":%d:%d\" : \":%d\", line, col);\n+      size_t l\n+\t= snprintf (result, sizeof (result),\n+\t\t    col >= 0 ? \":%d:%d\" : \":%d\", line, col);\n       gcc_checking_assert (l < sizeof (result));\n     }\n   else\n@@ -383,8 +417,14 @@ diagnostic_get_location_text (diagnostic_context *context,\n   const char *locus_cs = colorize_start (pp_show_color (pp), \"locus\");\n   const char *locus_ce = colorize_stop (pp_show_color (pp));\n   const char *file = s.file ? s.file : progname;\n-  int line = strcmp (file, N_(\"<built-in>\")) ? s.line : 0;\n-  int col = context->show_column ? s.column : 0;\n+  int line = 0;\n+  int col = -1;\n+  if (strcmp (file, N_(\"<built-in>\")))\n+    {\n+      line = s.line;\n+      if (context->show_column)\n+\tcol = diagnostic_converted_column (context, s);\n+    }\n \n   const char *line_col = maybe_line_and_column (line, col);\n   return build_message_string (\"%s%s%s:%s\", locus_cs, file,\n@@ -650,14 +690,20 @@ diagnostic_report_current_module (diagnostic_context *context, location_t where)\n       if (! MAIN_FILE_P (map))\n \t{\n \t  bool first = true;\n+\t  expanded_location s = {};\n \t  do\n \t    {\n \t      where = linemap_included_from (map);\n \t      map = linemap_included_from_linemap (line_table, map);\n-\t      const char *line_col\n-\t\t= maybe_line_and_column (SOURCE_LINE (map, where),\n-\t\t\t\t\t first && context->show_column\n-\t\t\t\t\t ? SOURCE_COLUMN (map, where) : 0);\n+\t      s.file = LINEMAP_FILE (map);\n+\t      s.line = SOURCE_LINE (map, where);\n+\t      int col = -1;\n+\t      if (first && context->show_column)\n+\t\t{\n+\t\t  s.column = SOURCE_COLUMN (map, where);\n+\t\t  col = diagnostic_converted_column (context, s);\n+\t\t}\n+\t      const char *line_col = maybe_line_and_column (s.line, col);\n \t      static const char *const msgs[] =\n \t\t{\n \t\t N_(\"In file included from\"),\n@@ -666,7 +712,7 @@ diagnostic_report_current_module (diagnostic_context *context, location_t where)\n \t      unsigned index = !first;\n \t      pp_verbatim (context->printer, \"%s%s %r%s%s%R\",\n \t\t\t   first ? \"\" : \",\\n\", _(msgs[index]),\n-\t\t\t   \"locus\", LINEMAP_FILE (map), line_col);\n+\t\t\t   \"locus\", s.file, line_col);\n \t      first = false;\n \t    }\n \t  while (! MAIN_FILE_P (map));\n@@ -2042,10 +2088,15 @@ test_print_parseable_fixits_replace ()\n static void\n assert_location_text (const char *expected_loc_text,\n \t\t      const char *filename, int line, int column,\n-\t\t      bool show_column)\n+\t\t      bool show_column,\n+\t\t      int origin = 1,\n+\t\t      enum diagnostics_column_unit column_unit\n+\t\t\t= DIAGNOSTICS_COLUMN_UNIT_BYTE)\n {\n   test_diagnostic_context dc;\n   dc.show_column = show_column;\n+  dc.column_unit = column_unit;\n+  dc.column_origin = origin;\n \n   expanded_location xloc;\n   xloc.file = filename;\n@@ -2069,14 +2120,52 @@ test_diagnostic_get_location_text ()\n   assert_location_text (\"PROGNAME:\", NULL, 0, 0, true);\n   assert_location_text (\"<built-in>:\", \"<built-in>\", 42, 10, true);\n   assert_location_text (\"foo.c:42:10:\", \"foo.c\", 42, 10, true);\n-  assert_location_text (\"foo.c:42:\", \"foo.c\", 42, 0, true);\n+  assert_location_text (\"foo.c:42:9:\", \"foo.c\", 42, 10, true, 0);\n+  assert_location_text (\"foo.c:42:1010:\", \"foo.c\", 42, 10, true, 1001);\n+  for (int origin = 0; origin != 2; ++origin)\n+    assert_location_text (\"foo.c:42:\", \"foo.c\", 42, 0, true, origin);\n   assert_location_text (\"foo.c:\", \"foo.c\", 0, 10, true);\n   assert_location_text (\"foo.c:42:\", \"foo.c\", 42, 10, false);\n   assert_location_text (\"foo.c:\", \"foo.c\", 0, 10, false);\n \n   maybe_line_and_column (INT_MAX, INT_MAX);\n   maybe_line_and_column (INT_MIN, INT_MIN);\n \n+  {\n+    /* In order to test display columns vs byte columns, we need to create a\n+       file for location_get_source_line() to read.  */\n+\n+    const char *const content = \"smile \\xf0\\x9f\\x98\\x82\\n\";\n+    const int line_bytes = strlen (content) - 1;\n+    const int def_tabstop = 8;\n+    const int display_width = cpp_display_width (content, line_bytes,\n+\t\t\t\t\t\t def_tabstop);\n+    ASSERT_EQ (line_bytes - 2, display_width);\n+    temp_source_file tmp (SELFTEST_LOCATION, \".c\", content);\n+    const char *const fname = tmp.get_filename ();\n+    const int buf_len = strlen (fname) + 16;\n+    char *const expected = XNEWVEC (char, buf_len);\n+\n+    snprintf (expected, buf_len, \"%s:1:%d:\", fname, line_bytes);\n+    assert_location_text (expected, fname, 1, line_bytes, true,\n+\t\t\t  1, DIAGNOSTICS_COLUMN_UNIT_BYTE);\n+\n+    snprintf (expected, buf_len, \"%s:1:%d:\", fname, line_bytes - 1);\n+    assert_location_text (expected, fname, 1, line_bytes, true,\n+\t\t\t  0, DIAGNOSTICS_COLUMN_UNIT_BYTE);\n+\n+    snprintf (expected, buf_len, \"%s:1:%d:\", fname, display_width);\n+    assert_location_text (expected, fname, 1, line_bytes, true,\n+\t\t\t  1, DIAGNOSTICS_COLUMN_UNIT_DISPLAY);\n+\n+    snprintf (expected, buf_len, \"%s:1:%d:\", fname, display_width - 1);\n+    assert_location_text (expected, fname, 1, line_bytes, true,\n+\t\t\t  0, DIAGNOSTICS_COLUMN_UNIT_DISPLAY);\n+\n+    XDELETEVEC (expected);\n+  }\n+\n+\n   progname = old_progname;\n }\n "}, {"sha": "4051601abfd70d53f595c5873a1120ca15c78c40", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -24,6 +24,20 @@ along with GCC; see the file COPYING3.  If not see\n #include \"pretty-print.h\"\n #include \"diagnostic-core.h\"\n \n+/* An enum for controlling what units to use for the column number\n+   when diagnostics are output, used by the -fdiagnostics-column-unit option.\n+   Tabs will be expanded or not according to the value of -ftabstop.  The origin\n+   (default 1) is controlled by -fdiagnostics-column-origin.  */\n+\n+enum diagnostics_column_unit\n+{\n+  /* The default from GCC 11 onwards: display columns.  */\n+  DIAGNOSTICS_COLUMN_UNIT_DISPLAY,\n+\n+  /* The behavior in GCC 10 and earlier: simple bytes.  */\n+  DIAGNOSTICS_COLUMN_UNIT_BYTE\n+};\n+\n /* Enum for overriding the standard output format.  */\n \n enum diagnostics_output_format\n@@ -280,6 +294,15 @@ struct diagnostic_context\n      rest of the diagnostic.  */\n   bool parseable_fixits_p;\n \n+  /* What units to use when outputting the column number.  */\n+  enum diagnostics_column_unit column_unit;\n+\n+  /* The origin for the column number (1-based or 0-based typically).  */\n+  int column_origin;\n+\n+  /* The size of the tabstop for tab expansion.  */\n+  int tabstop;\n+\n   /* If non-NULL, an edit_context to which fix-it hints should be\n      applied, for generating patches.  */\n   edit_context *edit_context_ptr;\n@@ -458,6 +481,8 @@ diagnostic_same_line (const diagnostic_context *context,\n }\n \n extern const char *diagnostic_get_color_for_kind (diagnostic_t kind);\n+extern int diagnostic_converted_column (diagnostic_context *context,\n+\t\t\t\t\texpanded_location s);\n \n /* Pure text formatting support functions.  */\n extern char *file_name_as_prefix (diagnostic_context *, const char *);\n@@ -470,6 +495,7 @@ extern void diagnostic_output_format_init (diagnostic_context *,\n /* Compute the number of digits in the decimal representation of an integer.  */\n extern int num_digits (int);\n \n-extern json::value *json_from_expanded_location (location_t loc);\n+extern json::value *json_from_expanded_location (diagnostic_context *context,\n+\t\t\t\t\t\t location_t loc);\n \n #endif /* ! GCC_DIAGNOSTIC_H */"}, {"sha": "825fd669a757f486bcc477bfe7e457dfe57a3b42", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 63, "deletions": 5, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -292,7 +292,9 @@ Objective-C and Objective-C++ Dialects}.\n -fdiagnostics-show-template-tree  -fno-elide-type @gol\n -fdiagnostics-path-format=@r{[}none@r{|}separate-events@r{|}inline-events@r{]} @gol\n -fdiagnostics-show-path-depths @gol\n--fno-show-column}\n+-fno-show-column @gol\n+-fdiagnostics-column-unit=@r{[}display@r{|}byte@r{]} @gol\n+-fdiagnostics-column-origin=@var{origin}}\n \n @item Warning Options\n @xref{Warning Options,,Options to Request or Suppress Warnings}.\n@@ -4730,6 +4732,31 @@ Do not print column numbers in diagnostics.  This may be necessary if\n diagnostics are being scanned by a program that does not understand the\n column numbers, such as @command{dejagnu}.\n \n+@item -fdiagnostics-column-unit=@var{UNIT}\n+@opindex fdiagnostics-column-unit\n+Select the units for the column number.  This affects traditional diagnostics\n+(in the absence of @option{-fno-show-column}), as well as JSON format\n+diagnostics if requested.\n+\n+The default @var{UNIT}, @samp{display}, considers the number of display\n+columns occupied by each character.  This may be larger than the number\n+of bytes required to encode the character, in the case of tab\n+characters, or it may be smaller, in the case of multibyte characters.\n+For example, the character ``GREEK SMALL LETTER PI (U+03C0)'' occupies one\n+display column, and its UTF-8 encoding requires two bytes; the character\n+``SLIGHTLY SMILING FACE (U+1F642)'' occupies two display columns, and\n+its UTF-8 encoding requires four bytes.\n+\n+Setting @var{UNIT} to @samp{byte} changes the column number to the raw byte\n+count in all cases, as was traditionally output by GCC prior to version 11.1.0.\n+\n+@item -fdiagnostics-column-origin=@var{ORIGIN}\n+@opindex fdiagnostics-column-origin\n+Select the origin for column numbers, i.e. the column number assigned to the\n+first column.  The default value of 1 corresponds to traditional GCC\n+behavior and to the GNU style guide.  Some utilities may perform better with an\n+origin of 0; any non-negative value may be specified.\n+\n @item -fdiagnostics-format=@var{FORMAT}\n @opindex fdiagnostics-format\n Select a different format for printing diagnostics.\n@@ -4765,11 +4792,15 @@ might be printed in JSON form (after formatting) like this:\n         \"locations\": [\n             @{\n                 \"caret\": @{\n+\t\t    \"display-column\": 3,\n+\t\t    \"byte-column\": 3,\n                     \"column\": 3,\n                     \"file\": \"misleading-indentation.c\",\n                     \"line\": 15\n                 @},\n                 \"finish\": @{\n+\t\t    \"display-column\": 4,\n+\t\t    \"byte-column\": 4,\n                     \"column\": 4,\n                     \"file\": \"misleading-indentation.c\",\n                     \"line\": 15\n@@ -4785,6 +4816,8 @@ might be printed in JSON form (after formatting) like this:\n                 \"locations\": [\n                     @{\n                         \"caret\": @{\n+\t\t\t    \"display-column\": 5,\n+\t\t\t    \"byte-column\": 5,\n                             \"column\": 5,\n                             \"file\": \"misleading-indentation.c\",\n                             \"line\": 17\n@@ -4794,6 +4827,7 @@ might be printed in JSON form (after formatting) like this:\n                 \"message\": \"...this statement, but the latter is @dots{}\"\n             @}\n         ]\n+\t\"column-origin\": 1,\n     @},\n     @dots{}\n ]\n@@ -4806,10 +4840,34 @@ A diagnostic has a @code{kind}.  If this is @code{warning}, then there is\n an @code{option} key describing the command-line option controlling the\n warning.\n \n-A diagnostic can contain zero or more locations.  Each location has up\n-to three positions within it: a @code{caret} position and optional\n-@code{start} and @code{finish} positions.  A location can also have\n-an optional @code{label} string.  For example, this error:\n+A diagnostic can contain zero or more locations.  Each location has an\n+optional @code{label} string and up to three positions within it: a\n+@code{caret} position and optional @code{start} and @code{finish} positions.\n+A position is described by a @code{file} name, a @code{line} number, and\n+three numbers indicating a column position:\n+@itemize @bullet\n+\n+@item\n+@code{display-column} counts display columns, accounting for tabs and\n+multibyte characters.\n+\n+@item\n+@code{byte-column} counts raw bytes.\n+\n+@item\n+@code{column} is equal to one of\n+the previous two, as dictated by the @option{-fdiagnostics-column-unit}\n+option.\n+\n+@end itemize\n+All three columns are relative to the origin specified by\n+@option{-fdiagnostics-column-origin}, which is typically equal to 1 but may\n+be set, for instance, to 0 for compatibility with other utilities that\n+number columns from 0.  The column origin is recorded in the JSON output in\n+the @code{column-origin} tag.  In the remaining examples below, the extra\n+column number outputs have been omitted for brevity.\n+\n+For example, this error:\n \n @smallexample\n bad-binary-ops.c:64:23: error: invalid operands to binary + (have 'S' @{aka"}, {"sha": "d573b90341a1c22267c10d4b998cca29e1d96b99", "filename": "gcc/input.c", "status": "modified", "additions": 46, "deletions": 26, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -913,15 +913,15 @@ make_location (location_t caret, source_range src_range)\n    source line in order to calculate the display width.  If that cannot be done\n    for any reason, then returns the byte column as a fallback.  */\n int\n-location_compute_display_column (expanded_location exploc)\n+location_compute_display_column (expanded_location exploc, int tabstop)\n {\n   if (!(exploc.file && *exploc.file && exploc.line && exploc.column))\n     return exploc.column;\n   char_span line = location_get_source_line (exploc.file, exploc.line);\n   /* If line is NULL, this function returns exploc.column which is the\n      desired fallback.  */\n   return cpp_byte_column_to_display_column (line.get_buffer (), line.length (),\n-\t\t\t\t\t    exploc.column);\n+\t\t\t\t\t    exploc.column, tabstop);\n }\n \n /* Dump statistics to stderr about the memory usage of the line_table\n@@ -3608,33 +3608,46 @@ test_line_offset_overflow ()\n \n void test_cpp_utf8 ()\n {\n+  const int def_tabstop = 8;\n   /* Verify that wcwidth of invalid UTF-8 or control bytes is 1.  */\n   {\n-    int w_bad = cpp_display_width (\"\\xf0!\\x9f!\\x98!\\x82!\", 8);\n+    int w_bad = cpp_display_width (\"\\xf0!\\x9f!\\x98!\\x82!\", 8, def_tabstop);\n     ASSERT_EQ (8, w_bad);\n-    int w_ctrl = cpp_display_width (\"\\r\\t\\n\\v\\0\\1\", 6);\n-    ASSERT_EQ (6, w_ctrl);\n+    int w_ctrl = cpp_display_width (\"\\r\\n\\v\\0\\1\", 5, def_tabstop);\n+    ASSERT_EQ (5, w_ctrl);\n   }\n \n   /* Verify that wcwidth of valid UTF-8 is as expected.  */\n   {\n-    const int w_pi = cpp_display_width (\"\\xcf\\x80\", 2);\n+    const int w_pi = cpp_display_width (\"\\xcf\\x80\", 2, def_tabstop);\n     ASSERT_EQ (1, w_pi);\n-    const int w_emoji = cpp_display_width (\"\\xf0\\x9f\\x98\\x82\", 4);\n+    const int w_emoji = cpp_display_width (\"\\xf0\\x9f\\x98\\x82\", 4, def_tabstop);\n     ASSERT_EQ (2, w_emoji);\n-    const int w_umlaut_precomposed = cpp_display_width (\"\\xc3\\xbf\", 2);\n+    const int w_umlaut_precomposed = cpp_display_width (\"\\xc3\\xbf\", 2,\n+\t\t\t\t\t\t\tdef_tabstop);\n     ASSERT_EQ (1, w_umlaut_precomposed);\n-    const int w_umlaut_combining = cpp_display_width (\"y\\xcc\\x88\", 3);\n+    const int w_umlaut_combining = cpp_display_width (\"y\\xcc\\x88\", 3,\n+\t\t\t\t\t\t      def_tabstop);\n     ASSERT_EQ (1, w_umlaut_combining);\n-    const int w_han = cpp_display_width (\"\\xe4\\xb8\\xba\", 3);\n+    const int w_han = cpp_display_width (\"\\xe4\\xb8\\xba\", 3, def_tabstop);\n     ASSERT_EQ (2, w_han);\n-    const int w_ascii = cpp_display_width (\"GCC\", 3);\n+    const int w_ascii = cpp_display_width (\"GCC\", 3, def_tabstop);\n     ASSERT_EQ (3, w_ascii);\n     const int w_mixed = cpp_display_width (\"\\xcf\\x80 = 3.14 \\xf0\\x9f\\x98\\x82\"\n-\t\t\t\t\t   \"\\x9f! \\xe4\\xb8\\xba y\\xcc\\x88\", 24);\n+\t\t\t\t\t   \"\\x9f! \\xe4\\xb8\\xba y\\xcc\\x88\",\n+\t\t\t\t\t   24, def_tabstop);\n     ASSERT_EQ (18, w_mixed);\n   }\n \n+  /* Verify that display width properly expands tabs.  */\n+  {\n+    const char *tstr = \"\\tabc\\td\";\n+    ASSERT_EQ (6, cpp_display_width (tstr, 6, 1));\n+    ASSERT_EQ (10, cpp_display_width (tstr, 6, 3));\n+    ASSERT_EQ (17, cpp_display_width (tstr, 6, 8));\n+    ASSERT_EQ (1, cpp_display_column_to_byte_column (tstr, 6, 7, 8));\n+  }\n+\n   /* Verify that cpp_byte_column_to_display_column can go past the end,\n      and similar edge cases.  */\n   {\n@@ -3645,10 +3658,13 @@ void test_cpp_utf8 ()\n       /* 111122223456\n \t Byte columns.  */\n \n-    ASSERT_EQ (5, cpp_display_width (str, 6));\n-    ASSERT_EQ (105, cpp_byte_column_to_display_column (str, 6, 106));\n-    ASSERT_EQ (10000, cpp_byte_column_to_display_column (NULL, 0, 10000));\n-    ASSERT_EQ (0, cpp_byte_column_to_display_column (NULL, 10000, 0));\n+    ASSERT_EQ (5, cpp_display_width (str, 6, def_tabstop));\n+    ASSERT_EQ (105,\n+\t       cpp_byte_column_to_display_column (str, 6, 106, def_tabstop));\n+    ASSERT_EQ (10000,\n+\t       cpp_byte_column_to_display_column (NULL, 0, 10000, def_tabstop));\n+    ASSERT_EQ (0,\n+\t       cpp_byte_column_to_display_column (NULL, 10000, 0, def_tabstop));\n   }\n \n   /* Verify that cpp_display_column_to_byte_column can go past the end,\n@@ -3662,21 +3678,25 @@ void test_cpp_utf8 ()\n       /* 000000000000000000000000000000000111111\n \t 111122223333444456666777788889999012345\n \t Byte columns.  */\n-    ASSERT_EQ (4, cpp_display_column_to_byte_column (str, 15, 2));\n-    ASSERT_EQ (15, cpp_display_column_to_byte_column (str, 15, 11));\n-    ASSERT_EQ (115, cpp_display_column_to_byte_column (str, 15, 111));\n-    ASSERT_EQ (10000, cpp_display_column_to_byte_column (NULL, 0, 10000));\n-    ASSERT_EQ (0, cpp_display_column_to_byte_column (NULL, 10000, 0));\n+    ASSERT_EQ (4, cpp_display_column_to_byte_column (str, 15, 2, def_tabstop));\n+    ASSERT_EQ (15,\n+\t       cpp_display_column_to_byte_column (str, 15, 11, def_tabstop));\n+    ASSERT_EQ (115,\n+\t       cpp_display_column_to_byte_column (str, 15, 111, def_tabstop));\n+    ASSERT_EQ (10000,\n+\t       cpp_display_column_to_byte_column (NULL, 0, 10000, def_tabstop));\n+    ASSERT_EQ (0,\n+\t       cpp_display_column_to_byte_column (NULL, 10000, 0, def_tabstop));\n \n     /* Verify that we do not interrupt a UTF-8 sequence.  */\n-    ASSERT_EQ (4, cpp_display_column_to_byte_column (str, 15, 1));\n+    ASSERT_EQ (4, cpp_display_column_to_byte_column (str, 15, 1, def_tabstop));\n \n     for (int byte_col = 1; byte_col <= 15; ++byte_col)\n       {\n-\tconst int disp_col = cpp_byte_column_to_display_column (str, 15,\n-\t\t\t\t\t\t\t\tbyte_col);\n-\tconst int byte_col2 = cpp_display_column_to_byte_column (str, 15,\n-\t\t\t\t\t\t\t\t disp_col);\n+\tconst int disp_col\n+\t  = cpp_byte_column_to_display_column (str, 15, byte_col, def_tabstop);\n+\tconst int byte_col2\n+\t  = cpp_display_column_to_byte_column (str, 15, disp_col, def_tabstop);\n \n \t/* If we ask for the display column in the middle of a UTF-8\n \t   sequence, it will return the length of the partial sequence,"}, {"sha": "4790a571c6a8b25399c92dc081a506bd588d472a", "filename": "gcc/input.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -38,7 +38,9 @@ STATIC_ASSERT (BUILTINS_LOCATION < RESERVED_LOCATION_COUNT);\n \n extern bool is_location_from_builtin_token (location_t);\n extern expanded_location expand_location (location_t);\n-extern int location_compute_display_column (expanded_location);\n+\n+extern int location_compute_display_column (expanded_location exploc,\n+\t\t\t\t\t    int tabstop);\n \n /* A class capturing the bounds of a buffer, to allow for run-time\n    bounds-checking in a checked build.  */"}, {"sha": "499eb9006431f178d243fe99d9b776a4b00ade90", "filename": "gcc/opts.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -2404,6 +2404,14 @@ common_handle_option (struct gcc_options *opts,\n       dc->parseable_fixits_p = value;\n       break;\n \n+    case OPT_fdiagnostics_column_unit_:\n+      dc->column_unit = (enum diagnostics_column_unit)value;\n+      break;\n+\n+    case OPT_fdiagnostics_column_origin_:\n+      dc->column_origin = value;\n+      break;\n+\n     case OPT_fdiagnostics_show_cwe:\n       dc->show_cwe = value;\n       break;\n@@ -2792,6 +2800,12 @@ common_handle_option (struct gcc_options *opts,\n       check_alignment_argument (loc, arg, \"functions\");\n       break;\n \n+    case OPT_ftabstop_:\n+      /* It is documented that we silently ignore silly values.  */\n+      if (value >= 1 && value <= 100)\n+\tdc->tabstop = value;\n+      break;\n+\n     default:\n       /* If the flag was handled in a standard way, assume the lack of\n \t processing here is intentional.  */"}, {"sha": "2314ad42402f312faf6ad8c0aa3598feefe420fb", "filename": "gcc/testsuite/c-c++-common/Wmisleading-indentation-3.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation-3.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -36,20 +36,20 @@ int fn_6 (int a, int b, int c)\n \t/* ... */\n \tif ((err = foo (a)) != 0)\n \t\tgoto fail;\n-\tif ((err = foo (b)) != 0) /* { dg-message \"2: this 'if' clause does not guard...\" } */\n+\tif ((err = foo (b)) != 0) /* { dg-message \"9: this 'if' clause does not guard...\" } */\n \t\tgoto fail;\n-\t\tgoto fail; /* { dg-message \"3: ...this statement, but the latter is misleadingly indented as if it were guarded by the 'if'\" } */\n+\t\tgoto fail; /* { dg-message \"17: ...this statement, but the latter is misleadingly indented as if it were guarded by the 'if'\" } */\n \tif ((err = foo (c)) != 0)\n \t\tgoto fail;\n \t/* ... */\n \n /* { dg-begin-multiline-output \"\" }\n-  if ((err = foo (b)) != 0)\n-  ^~\n+         if ((err = foo (b)) != 0)\n+         ^~\n    { dg-end-multiline-output \"\" } */\n /* { dg-begin-multiline-output \"\" }\n-   goto fail;\n-   ^~~~\n+                 goto fail;\n+                 ^~~~\n    { dg-end-multiline-output \"\" } */\n \n fail:"}, {"sha": "202c6bc7fdf02fd1a7090274d9aa52909e2d8615", "filename": "gcc/testsuite/c-c++-common/Wmisleading-indentation.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -65,9 +65,9 @@ int fn_6 (int a, int b, int c)\n \t/* ... */\n \tif ((err = foo (a)) != 0)\n \t\tgoto fail;\n-\tif ((err = foo (b)) != 0) /* { dg-message \"2: this 'if' clause does not guard...\" } */\n+\tif ((err = foo (b)) != 0) /* { dg-message \"9: this 'if' clause does not guard...\" } */\n \t\tgoto fail;\n-\t\tgoto fail; /* { dg-message \"3: ...this statement, but the latter is misleadingly indented as if it were guarded by the 'if'\" } */\n+\t\tgoto fail; /* { dg-message \"17: ...this statement, but the latter is misleadingly indented as if it were guarded by the 'if'\" } */\n \tif ((err = foo (c)) != 0)\n \t\tgoto fail;\n \t/* ... */\n@@ -178,7 +178,7 @@ void fn_16_tabs (void)\n     while (flagA)\n       if (flagB) /* { dg-message \"7: this 'if' clause does not guard...\" } */\n \tfoo (0);\n-\tfoo (1);/* { dg-message \"2: ...this statement, but the latter is misleadingly indented as if it were guarded by the 'if'\" } */\n+\tfoo (1);/* { dg-message \"9: ...this statement, but the latter is misleadingly indented as if it were guarded by the 'if'\" } */\n }\n \n void fn_17_spaces (void)"}, {"sha": "740becb55486fcc58ee806b26307ad1bd8a4448e", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-json-1.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-1.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -8,17 +8,22 @@\n    We can't rely on any ordering of the keys.  */\n \n /* { dg-regexp \"\\\"kind\\\": \\\"error\\\"\" } */\n+/* { dg-regexp \"\\\"column-origin\\\": 1\" } */\n /* { dg-regexp \"\\\"message\\\": \\\"#error message\\\"\" } */\n \n /* { dg-regexp \"\\\"caret\\\": \\{\" } */\n /* { dg-regexp \"\\\"file\\\": \\\"\\[^\\n\\r\\\"\\]*diagnostic-format-json-1.c\\\"\" } */\n /* { dg-regexp \"\\\"line\\\": 4\" } */\n /* { dg-regexp \"\\\"column\\\": 2\" } */\n+/* { dg-regexp \"\\\"display-column\\\": 2\" } */\n+/* { dg-regexp \"\\\"byte-column\\\": 2\" } */\n \n /* { dg-regexp \"\\\"finish\\\": \\{\" } */\n /* { dg-regexp \"\\\"file\\\": \\\"\\[^\\n\\r\\\"\\]*diagnostic-format-json-1.c\\\"\" } */\n /* { dg-regexp \"\\\"line\\\": 4\" } */\n /* { dg-regexp \"\\\"column\\\": 6\" } */\n+/* { dg-regexp \"\\\"display-column\\\": 6\" } */\n+/* { dg-regexp \"\\\"byte-column\\\": 6\" } */\n \n /* { dg-regexp \"\\\"locations\\\": \\[\\[\\{\\}, \\]*\\]\" } */\n /* { dg-regexp \"\\\"children\\\": \\[\\[\\]\\[\\]\\]\" } */"}, {"sha": "2f24a6c659603b6e4fe8d1c9507ef4d1129fbb2d", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-json-2.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-2.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -8,6 +8,7 @@\n    We can't rely on any ordering of the keys.  */\n \n /* { dg-regexp \"\\\"kind\\\": \\\"warning\\\"\" } */\n+/* { dg-regexp \"\\\"column-origin\\\": 1\" } */\n /* { dg-regexp \"\\\"message\\\": \\\"#warning message\\\"\" } */\n /* { dg-regexp \"\\\"option\\\": \\\"-Wcpp\\\"\" } */\n /* { dg-regexp \"\\\"option_url\\\": \\\"https:\\[^\\n\\r\\\"\\]*#index-Wcpp\\\"\" } */\n@@ -16,11 +17,15 @@\n /* { dg-regexp \"\\\"file\\\": \\\"\\[^\\n\\r\\\"\\]*diagnostic-format-json-2.c\\\"\" } */\n /* { dg-regexp \"\\\"line\\\": 4\" } */\n /* { dg-regexp \"\\\"column\\\": 2\" } */\n+/* { dg-regexp \"\\\"display-column\\\": 2\" } */\n+/* { dg-regexp \"\\\"byte-column\\\": 2\" } */\n \n /* { dg-regexp \"\\\"finish\\\": \\{\" } */\n /* { dg-regexp \"\\\"file\\\": \\\"\\[^\\n\\r\\\"\\]*diagnostic-format-json-2.c\\\"\" } */\n /* { dg-regexp \"\\\"line\\\": 4\" } */\n /* { dg-regexp \"\\\"column\\\": 8\" } */\n+/* { dg-regexp \"\\\"display-column\\\": 8\" } */\n+/* { dg-regexp \"\\\"byte-column\\\": 8\" } */\n \n /* { dg-regexp \"\\\"locations\\\": \\[\\[\\{\\}, \\]*\\]\" } */\n /* { dg-regexp \"\\\"children\\\": \\[\\[\\]\\[\\]\\]\" } */"}, {"sha": "afe96a9048f361b751b6a070ae3a8cea835a9908", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-json-3.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-3.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -8,6 +8,7 @@\n    We can't rely on any ordering of the keys.  */\n \n /* { dg-regexp \"\\\"kind\\\": \\\"error\\\"\" } */\n+/* { dg-regexp \"\\\"column-origin\\\": 1\" } */\n /* { dg-regexp \"\\\"message\\\": \\\"#warning message\\\"\" } */\n /* { dg-regexp \"\\\"option\\\": \\\"-Werror=cpp\\\"\" } */\n /* { dg-regexp \"\\\"option_url\\\": \\\"https:\\[^\\n\\r\\\"\\]*#index-Wcpp\\\"\" } */\n@@ -16,11 +17,15 @@\n /* { dg-regexp \"\\\"file\\\": \\\"\\[^\\n\\r\\\"\\]*diagnostic-format-json-3.c\\\"\" } */\n /* { dg-regexp \"\\\"line\\\": 4\" } */\n /* { dg-regexp \"\\\"column\\\": 2\" } */\n+/* { dg-regexp \"\\\"display-column\\\": 2\" } */\n+/* { dg-regexp \"\\\"byte-column\\\": 2\" } */\n \n /* { dg-regexp \"\\\"finish\\\": \\{\" } */\n /* { dg-regexp \"\\\"file\\\": \\\"\\[^\\n\\r\\\"\\]*diagnostic-format-json-3.c\\\"\" } */\n /* { dg-regexp \"\\\"line\\\": 4\" } */\n /* { dg-regexp \"\\\"column\\\": 8\" } */\n+/* { dg-regexp \"\\\"display-column\\\": 8\" } */\n+/* { dg-regexp \"\\\"byte-column\\\": 8\" } */\n \n /* { dg-regexp \"\\\"locations\\\": \\[\\[\\{\\}, \\]*\\]\" } */\n /* { dg-regexp \"\\\"children\\\": \\[\\[\\]\\[\\]\\]\" } */"}, {"sha": "ae51091e0eac0cde2509ec41407906cffe20a82d", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-json-4.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-4.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -24,15 +24,20 @@ int test (void)\n /* { dg-regexp \"\\\"file\\\": \\\"\\[^\\n\\r\\\"\\]*diagnostic-format-json-4.c\\\"\" } */\n /* { dg-regexp \"\\\"line\\\": 8\" } */\n /* { dg-regexp \"\\\"column\\\": 5\" } */\n+/* { dg-regexp \"\\\"display-column\\\": 5\" } */\n+/* { dg-regexp \"\\\"byte-column\\\": 5\" } */\n \n /* { dg-regexp \"\\\"finish\\\": \\{\" } */\n /* { dg-regexp \"\\\"file\\\": \\\"\\[^\\n\\r\\\"\\]*diagnostic-format-json-4.c\\\"\" } */\n /* { dg-regexp \"\\\"line\\\": 8\" } */\n /* { dg-regexp \"\\\"column\\\": 10\" } */\n+/* { dg-regexp \"\\\"display-column\\\": 10\" } */\n+/* { dg-regexp \"\\\"byte-column\\\": 10\" } */\n \n /* The outer diagnostic.  */\n \n /* { dg-regexp \"\\\"kind\\\": \\\"warning\\\"\" } */\n+/* { dg-regexp \"\\\"column-origin\\\": 1\" } */\n /* { dg-regexp \"\\\"message\\\": \\\"this 'if' clause does not guard...\\\"\" } */\n /* { dg-regexp \"\\\"option\\\": \\\"-Wmisleading-indentation\\\"\" } */\n /* { dg-regexp \"\\\"option_url\\\": \\\"https:\\[^\\n\\r\\\"\\]*#index-Wmisleading-indentation\\\"\" } */\n@@ -41,11 +46,15 @@ int test (void)\n /* { dg-regexp \"\\\"file\\\": \\\"\\[^\\n\\r\\\"\\]*diagnostic-format-json-4.c\\\"\" } */\n /* { dg-regexp \"\\\"line\\\": 6\" } */\n /* { dg-regexp \"\\\"column\\\": 3\" } */\n+/* { dg-regexp \"\\\"display-column\\\": 3\" } */\n+/* { dg-regexp \"\\\"byte-column\\\": 3\" } */\n \n /* { dg-regexp \"\\\"finish\\\": \\{\" } */\n /* { dg-regexp \"\\\"file\\\": \\\"\\[^\\n\\r\\\"\\]*diagnostic-format-json-4.c\\\"\" } */\n /* { dg-regexp \"\\\"line\\\": 6\" } */\n /* { dg-regexp \"\\\"column\\\": 4\" } */\n+/* { dg-regexp \"\\\"display-column\\\": 4\" } */\n+/* { dg-regexp \"\\\"byte-column\\\": 4\" } */\n \n /* More from the nested diagnostic (we can't guarantee what order the\n    \"file\" keys are consumed).  */"}, {"sha": "e0e9ce4be98a8e32f7b37a2634d16ba949a9b3d0", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-json-5.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-5.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -13,6 +13,7 @@ int test (struct s *ptr)\n    We can't rely on any ordering of the keys.  */\n \n /* { dg-regexp \"\\\"kind\\\": \\\"error\\\"\" } */\n+/* { dg-regexp \"\\\"column-origin\\\": 1\" } */\n /* { dg-regexp \"\\\"message\\\": \\\".*\\\"\" } */\n \n /* Verify fix-it hints.  */\n@@ -23,23 +24,31 @@ int test (struct s *ptr)\n /* { dg-regexp \"\\\"file\\\": \\\"\\[^\\n\\r\\\"\\]*diagnostic-format-json-5.c\\\"\" } */\n /* { dg-regexp \"\\\"line\\\": 8\" } */\n /* { dg-regexp \"\\\"column\\\": 15\" } */\n+/* { dg-regexp \"\\\"display-column\\\": 15\" } */\n+/* { dg-regexp \"\\\"byte-column\\\": 15\" } */\n \n /* { dg-regexp \"\\\"next\\\": \\{\" } */\n /* { dg-regexp \"\\\"file\\\": \\\"\\[^\\n\\r\\\"\\]*diagnostic-format-json-5.c\\\"\" } */\n /* { dg-regexp \"\\\"line\\\": 8\" } */\n /* { dg-regexp \"\\\"column\\\": 21\" } */\n+/* { dg-regexp \"\\\"display-column\\\": 21\" } */\n+/* { dg-regexp \"\\\"byte-column\\\": 21\" } */\n \n /* { dg-regexp \"\\\"fixits\\\": \\[\\[\\{\\}, \\]*\\]\" } */\n \n /* { dg-regexp \"\\\"caret\\\": \\{\" } */\n /* { dg-regexp \"\\\"file\\\": \\\"\\[^\\n\\r\\\"\\]*diagnostic-format-json-5.c\\\"\" } */\n /* { dg-regexp \"\\\"line\\\": 8\" } */\n /* { dg-regexp \"\\\"column\\\": 15\" } */\n+/* { dg-regexp \"\\\"display-column\\\": 15\" } */\n+/* { dg-regexp \"\\\"byte-column\\\": 15\" } */\n \n /* { dg-regexp \"\\\"finish\\\": \\{\" } */\n /* { dg-regexp \"\\\"file\\\": \\\"\\[^\\n\\r\\\"\\]*diagnostic-format-json-5.c\\\"\" } */\n /* { dg-regexp \"\\\"line\\\": 8\" } */\n /* { dg-regexp \"\\\"column\\\": 20\" } */\n+/* { dg-regexp \"\\\"display-column\\\": 20\" } */\n+/* { dg-regexp \"\\\"byte-column\\\": 20\" } */\n \n /* { dg-regexp \"\\\"locations\\\": \\[\\[\\{\\}, \\]*\\]\" } */\n /* { dg-regexp \"\\\"children\\\": \\[\\[\\]\\[\\]\\]\" } */"}, {"sha": "8d38b7de03e046c376d6bb329948786b5293fb99", "filename": "gcc/testsuite/c-c++-common/diagnostic-units-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-1.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdiagnostics-column-unit=byte -fshow-column -fdiagnostics-show-caret -Wmultichar\" } */\n+\n+/* column units: bytes (via arg)\n+   column origin: 1 (via default)\n+   tabstop: 8 (via default) */\n+\n+/* This line starts with a tab.  */\n+\tint c1 = 'c1'; /* { dg-warning \"11: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+         int c1 = 'c1';\n+                  ^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+/* This line starts with <tabstop> spaces.  */\n+        int c2 = 'c2'; /* { dg-warning \"18: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+         int c2 = 'c2';\n+                  ^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+/* This line starts with <tabstop> spaces and has an internal tab after\n+   a space.  */\n+        int c3 = \t'c3'; /* { dg-warning \"19: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+         int c3 =        'c3';\n+                         ^~~~\n+   { dg-end-multiline-output \"\" } */"}, {"sha": "29a2edefd9fd7fd4dd8b643c336dd6bad9f1f7d8", "filename": "gcc/testsuite/c-c++-common/diagnostic-units-2.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-2.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdiagnostics-column-unit=display -fshow-column -fdiagnostics-show-caret -Wmultichar\" } */\n+\n+/* column units: display (via arg)\n+   column origin: 1 (via default)\n+   tabstop: 8 (via default) */\n+\n+/* This line starts with a tab.  */\n+\tint c1 = 'c1'; /* { dg-warning \"18: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+         int c1 = 'c1';\n+                  ^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+/* This line starts with <tabstop> spaces.  */\n+        int c2 = 'c2'; /* { dg-warning \"18: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+         int c2 = 'c2';\n+                  ^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+/* This line starts with <tabstop> spaces and has an internal tab after\n+   a space.  */\n+        int c3 = \t'c3'; /* { dg-warning \"25: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+         int c3 =        'c3';\n+                         ^~~~\n+   { dg-end-multiline-output \"\" } */"}, {"sha": "714ee8f2de4f65d0357df2ac7f4da9dde931d6a3", "filename": "gcc/testsuite/c-c++-common/diagnostic-units-3.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-3.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdiagnostics-column-unit=byte -fshow-column -fdiagnostics-show-caret -ftabstop=200 -Wmultichar\" } */\n+\n+/* column units: bytes (via arg)\n+   column origin: 1 (via fallback from overly large argument)\n+   tabstop: 8 (via default) */\n+\n+/* This line starts with a tab.  */\n+\tint c1 = 'c1'; /* { dg-warning \"11: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+         int c1 = 'c1';\n+                  ^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+/* This line starts with <tabstop> spaces.  */\n+        int c2 = 'c2'; /* { dg-warning \"18: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+         int c2 = 'c2';\n+                  ^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+/* This line starts with <tabstop> spaces and has an internal tab after\n+   a space.  */\n+        int c3 = \t'c3'; /* { dg-warning \"19: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+         int c3 =        'c3';\n+                         ^~~~\n+   { dg-end-multiline-output \"\" } */"}, {"sha": "f9c9da914b23208d031427ceb16ae2244e9e926c", "filename": "gcc/testsuite/c-c++-common/diagnostic-units-4.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-4.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdiagnostics-column-unit=byte -fshow-column -fdiagnostics-show-caret -fdiagnostics-column-origin=0 -Wmultichar\" } */\n+\n+/* column units: bytes (via arg)\n+   column origin: 0 (via arg)\n+   tabstop: 8 (via default) */\n+\n+/* This line starts with a tab.  */\n+\tint c1 = 'c1'; /* { dg-warning \"10: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+         int c1 = 'c1';\n+                  ^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+/* This line starts with <tabstop> spaces.  */\n+        int c2 = 'c2'; /* { dg-warning \"17: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+         int c2 = 'c2';\n+                  ^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+/* This line starts with <tabstop> spaces and has an internal tab after\n+   a space.  */\n+        int c3 = \t'c3'; /* { dg-warning \"18: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+         int c3 =        'c3';\n+                         ^~~~\n+   { dg-end-multiline-output \"\" } */"}, {"sha": "99d5299a732182d41c2c34abe97eca7df084a9c3", "filename": "gcc/testsuite/c-c++-common/diagnostic-units-5.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-5.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdiagnostics-column-unit=display -fshow-column -fdiagnostics-show-caret -fdiagnostics-column-origin=0 -Wmultichar\" } */\n+\n+/* column units: display (via arg)\n+   column origin: 0 (via arg)\n+   tabstop: 8 (via default) */\n+\n+/* This line starts with a tab.  */\n+\tint c1 = 'c1'; /* { dg-warning \"17: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+         int c1 = 'c1';\n+                  ^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+/* This line starts with <tabstop> spaces.  */\n+        int c2 = 'c2'; /* { dg-warning \"17: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+         int c2 = 'c2';\n+                  ^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+/* This line starts with <tabstop> spaces and has an internal tab after\n+   a space.  */\n+        int c3 = \t'c3'; /* { dg-warning \"24: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+         int c3 =        'c3';\n+                         ^~~~\n+   { dg-end-multiline-output \"\" } */"}, {"sha": "c1e6e4ed477e94656fdbd60f5b40c74893b6d5ec", "filename": "gcc/testsuite/c-c++-common/diagnostic-units-6.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-6.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdiagnostics-column-unit=byte -fshow-column -fdiagnostics-show-caret -fdiagnostics-column-origin=100 -Wmultichar\" } */\n+\n+/* column units: bytes (via arg)\n+   column origin: 100 (via arg)\n+   tabstop: 8 (via default) */\n+\n+/* This line starts with a tab.  */\n+\tint c1 = 'c1'; /* { dg-warning \"110: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+         int c1 = 'c1';\n+                  ^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+/* This line starts with <tabstop> spaces.  */\n+        int c2 = 'c2'; /* { dg-warning \"117: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+         int c2 = 'c2';\n+                  ^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+/* This line starts with <tabstop> spaces and has an internal tab after\n+   a space.  */\n+        int c3 = \t'c3'; /* { dg-warning \"118: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+         int c3 =        'c3';\n+                         ^~~~\n+   { dg-end-multiline-output \"\" } */"}, {"sha": "dab221ae235d6562e282f99d48ce0cc6f7849613", "filename": "gcc/testsuite/c-c++-common/diagnostic-units-7.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-7.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdiagnostics-column-unit=byte -fshow-column -fdiagnostics-show-caret -ftabstop=9 -Wmultichar\" } */\n+\n+/* column units: bytes (via arg)\n+   column origin: 1 (via default)\n+   tabstop: 9 (via arg) */\n+\n+/* This line starts with a tab.  */\n+\tint c1 = 'c1'; /* { dg-warning \"11: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+          int c1 = 'c1';\n+                   ^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+/* This line starts with <tabstop> spaces.  */\n+         int c2 = 'c2'; /* { dg-warning \"19: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+          int c2 = 'c2';\n+                   ^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+/* This line starts with <tabstop> spaces and has an internal tab after\n+   a space.  */\n+         int c3 = \t'c3'; /* { dg-warning \"20: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+          int c3 =          'c3';\n+                            ^~~~\n+   { dg-end-multiline-output \"\" } */"}, {"sha": "d713b32dabc4916971d07af0028260a37baf15d5", "filename": "gcc/testsuite/c-c++-common/diagnostic-units-8.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-units-8.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fshow-column -fdiagnostics-show-caret -ftabstop=9 -Wmultichar\" } */\n+\n+/* column units: display (via default)\n+   column origin: 1 (via default)\n+   tabstop: 9 (via arg) */\n+\n+/* This line starts with a tab.  */\n+\tint c1 = 'c1'; /* { dg-warning \"19: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+          int c1 = 'c1';\n+                   ^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+/* This line starts with <tabstop> spaces.  */\n+         int c2 = 'c2'; /* { dg-warning \"19: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+          int c2 = 'c2';\n+                   ^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+/* This line starts with <tabstop> spaces and has an internal tab after\n+   a space.  */\n+         int c3 = \t'c3'; /* { dg-warning \"28: multi-character character constant\" } */\n+/* { dg-begin-multiline-output \"\" }\n+          int c3 =          'c3';\n+                            ^~~~\n+   { dg-end-multiline-output \"\" } */"}, {"sha": "9f1de3d0c47de640b6f4d916d43830c8d7bcc33f", "filename": "gcc/testsuite/c-c++-common/missing-close-symbol.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fmissing-close-symbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fmissing-close-symbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fmissing-close-symbol.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -24,9 +24,9 @@ void test_static_assert_different_line (void)\n   _Static_assert(sizeof(int) >= sizeof(char), /* { dg-message \"to match this '\\\\('\" } */\n \t\t \"msg\"; /* { dg-error \"expected '\\\\)' before ';' token\" } */\n   /* { dg-begin-multiline-output \"\" }\n-    \"msg\";\n-         ^\n-         )\n+                  \"msg\";\n+                       ^\n+                       )\n      { dg-end-multiline-output \"\" } */\n   /* { dg-begin-multiline-output \"\" }\n    _Static_assert(sizeof(int) >= sizeof(char),"}, {"sha": "ebbf3001055dedff30ed36f85f10eb3d53c6100d", "filename": "gcc/testsuite/g++.dg/diagnostic/bad-binary-ops.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fbad-binary-ops.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fbad-binary-ops.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fbad-binary-ops.C?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -33,10 +33,10 @@ int test_2 (void)\n            ~~~~~~~~~~~~~~~~\n                          |\n                          s\n-    + some_other_function ());\n-    ^ ~~~~~~~~~~~~~~~~~~~~~~\n-                          |\n-                          t\n+           + some_other_function ());\n+           ^ ~~~~~~~~~~~~~~~~~~~~~~\n+                                 |\n+                                 t\n    { dg-end-multiline-output \"\" } */\n }\n "}, {"sha": "fe8de73790d2d9da70173a740a4bb7ea149ddaaa", "filename": "gcc/testsuite/g++.dg/parse/error4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror4.C?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -7,4 +7,4 @@ struct X {\n \t\t int);\n };\n \n-// { dg-error \"4:'itn' has not been declared\" \"\" { target *-*-* } 6 }\n+// { dg-error \"18:'itn' has not been declared\" \"\" { target *-*-* } 6 }"}, {"sha": "d2b37a5122d2ff5ffa10171cd86198f70127620c", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/crash11.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash11.C?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -9,13 +9,13 @@ class A {\n \tint\th;\n \tA() { i=10; j=20; }\n \tvirtual void f1() { printf(\"i=%d j=%d\\n\",i,j); }\n-\tfriend virtual void f2() { printf(\"i=%d j=%d\\n\",i,j); } // { dg-error \"9:virtual functions cannot be friends\" }\n+\tfriend virtual void f2() { printf(\"i=%d j=%d\\n\",i,j); } // { dg-error \"16:virtual functions cannot be friends\" }\n };\n \n class B : public A {\n     public:\n \tvirtual void f1() { printf(\"i=%d j=%d\\n\",i,j); }// { dg-error \"\" }  member.*// ERROR -  member.*\n-\tfriend virtual void f2() { printf(\"i=%d j=%d\\n\",i,j); }  // { dg-error \"9:virtual functions cannot be friends\" }\n+\tfriend virtual void f2() { printf(\"i=%d j=%d\\n\",i,j); }  // { dg-error \"16:virtual functions cannot be friends\" }\n // { dg-error \"private\" \"\" { target *-*-* } .-1 }\n };\n "}, {"sha": "bbc9e51aff6ae4c5891928725c0334ef7b1865db", "filename": "gcc/testsuite/g++.old-deja/g++.pt/overload2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Foverload2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Foverload2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Foverload2.C?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -12,5 +12,5 @@ int\n main()\n {\n \tC<char*>\tc;\n-\tchar*\t\tp = Z(c.O); //{ dg-error \"13:'Z' was not declared\" } ambiguous c.O\n+\tchar*\t\tp = Z(c.O); //{ dg-error \"29:'Z' was not declared\" } ambiguous c.O\n }"}, {"sha": "b98e8da6b1e5c3ebcb9be5bf1a58acfa060bd2e8", "filename": "gcc/testsuite/g++.old-deja/g++.robertl/eb109.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb109.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb109.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb109.C?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -48,8 +48,8 @@ ostream& operator<<(ostream& os, Graph<VertexType,EdgeType>& G)\n \n         // The compiler does not like this line!!!!!!\n         typename Graph<VertexType, EdgeType>::Successor::iterator\n-\t  startN = G[i].second.begin(), // { dg-error \"14:no match\" } no index operator\n-\t  endN   = G[i].second.end();  // { dg-error \"14:no match\" } no index operator\n+\t  startN = G[i].second.begin(), // { dg-error \"21:no match\" } no index operator\n+\t  endN   = G[i].second.end();  // { dg-error \"21:no match\" } no index operator\n \n         while(startN != endN)\n         {"}, {"sha": "51190c92391cf49f9dc78174393b3bc26931ae55", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-paths-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-9.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -288,7 +288,7 @@ int test_3 (int x, int y)\n     |      |     ~~~~~~~~~~\n     |      |     |\n     |      |     (4) ...to here\n-    |   NN |      to dereference it above\n+    |   NN |                    to dereference it above\n     |   NN |   return *ptr;\n     |      |          ~~~~\n     |      |          |"}, {"sha": "45668be0a29ce5bb3d59b5e0471e27ac02cb2b13", "filename": "gcc/testsuite/gcc.dg/bad-binary-ops.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fgcc.dg%2Fbad-binary-ops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fgcc.dg%2Fbad-binary-ops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbad-binary-ops.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -35,10 +35,10 @@ int test_2 (void)\n            ~~~~~~~~~~~~~~~~\n            |\n            struct s\n-    + some_other_function ());\n-    ^ ~~~~~~~~~~~~~~~~~~~~~~\n-      |\n-      struct t\n+           + some_other_function ());\n+           ^ ~~~~~~~~~~~~~~~~~~~~~~\n+             |\n+             struct t\n    { dg-end-multiline-output \"\" } */\n }\n "}, {"sha": "4ea39b52b2e83c2ee0aa103adcac3b5464d6ee38", "filename": "gcc/testsuite/gcc.dg/format/branch-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fbranch-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fbranch-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fbranch-1.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -10,7 +10,7 @@ foo (long l, int nfoo)\n {\n   printf ((nfoo > 1) ? \"%d foos\" : \"%d foo\", nfoo);\n   printf ((l > 1) ? \"%d foos\" /* { dg-warning \"23:int\" \"wrong type in conditional expr\" } */\n-\t          : \"%d foo\", l); /* { dg-warning \"16:int\" \"wrong type in conditional expr\" } */\n+\t          : \"%d foo\", l); /* { dg-warning \"23:int\" \"wrong type in conditional expr\" } */\n   printf ((l > 1) ? \"%ld foos\" : \"%d foo\", l); /* { dg-warning \"36:int\" \"wrong type in conditional expr\" } */\n   printf ((l > 1) ? \"%d foos\" : \"%ld foo\", l); /* { dg-warning \"23:int\" \"wrong type in conditional expr\" } */\n   /* Should allow one case to have extra arguments.  */"}, {"sha": "6bdabdf21ec81301fa52b24d7ef40317de8a2cc1", "filename": "gcc/testsuite/gcc.dg/format/pr79210.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fpr79210.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fpr79210.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fpr79210.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -20,4 +20,4 @@ LPFC_VPORT_ATTR_R(peer_port_login,\n \t\t  \"Allow peer ports on the same physical port to login to each \"\n \t\t  \"other.\");\n \n-/* { dg-warning \"6: format .%d. expects argument of type .int., but argument 4 has type .unsigned int. \" \"\" { target *-*-* } .-12 } */\n+/* { dg-warning \"20: format .%d. expects argument of type .int., but argument 4 has type .unsigned int. \" \"\" { target *-*-* } .-12 } */"}, {"sha": "d7691e4be51663f4e71161a38390a3529b0920b9", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-test-expressions-1.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-expressions-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-expressions-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-expressions-1.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -540,15 +540,15 @@ void test_builtin_types_compatible_p (unsigned long i)\n   __emit_expression_range (0,\n \t\t\t   f (i) + __builtin_types_compatible_p (long, int)); /* { dg-warning \"range\" } */\n /* { dg-begin-multiline-output \"\" }\n-       f (i) + __builtin_types_compatible_p (long, int));\n-       ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+                            f (i) + __builtin_types_compatible_p (long, int));\n+                            ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    { dg-end-multiline-output \"\" } */\n \n   __emit_expression_range (0,\n \t\t\t   __builtin_types_compatible_p (long, int) + f (i)); /* { dg-warning \"range\" } */\n /* { dg-begin-multiline-output \"\" }\n-       __builtin_types_compatible_p (long, int) + f (i));\n-       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n+                            __builtin_types_compatible_p (long, int) + f (i));\n+                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n    { dg-end-multiline-output \"\" } */\n }\n \n@@ -671,8 +671,8 @@ void test_multiple_ordinary_maps (void)\n /* { dg-begin-multiline-output \"\" }\n    __emit_expression_range (0, foo (0,\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-        \"0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\"));\n-        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+                                    \"0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\"));\n+                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    { dg-end-multiline-output \"\" } */\n \n   /* Another expression that transitions between ordinary maps; this\n@@ -685,8 +685,8 @@ void test_multiple_ordinary_maps (void)\n /* { dg-begin-multiline-output \"\" }\n    __emit_expression_range (0, foo (0, \"01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\",\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-        0));\n-        ~~                      \n+                                    0));\n+                                    ~~\n    { dg-end-multiline-output \"\" } */\n }\n "}, {"sha": "4cba87be2aece08a801e2d7828a9b9e5cc324b7f", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-test-string-literals-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-string-literals-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-string-literals-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-string-literals-1.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -335,11 +335,11 @@ pr87652 (const char *stem, int counter)\n /* { dg-error \"unable to read substring location: unable to read source line\" \"\" { target c } 329 } */\n /* { dg-error \"unable to read substring location: failed to get ordinary maps\" \"\" { target c++ } 329 } */\n /* { dg-begin-multiline-output \"\" }\n-     __emit_string_literal_range(__FILE__\":%5d: \" format, \\\n+     __emit_string_literal_range(__FILE__\":%5d: \" format,        \\\n                                  ^~~~~~~~\n      { dg-end-multiline-output \"\" { target c } } */\n /* { dg-begin-multiline-output \"\" }\n-     __emit_string_literal_range(__FILE__\":%5d: \" format, \\\n+     __emit_string_literal_range(__FILE__\":%5d: \" format,        \\\n                                  ^\n      { dg-end-multiline-output \"\" { target c++ } } */\n "}, {"sha": "2c214bb02c7c5da23321ecfa4bb6d148c9d82b76", "filename": "gcc/testsuite/gcc.dg/redecl-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-4.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -15,7 +15,7 @@ f (void)\n     /* Should get format warnings even though the built-in declaration\n        isn't \"visible\".  */\n     printf (\n-\t    \"%s\", 1); /* { dg-warning \"8:format\" } */\n+\t    \"%s\", 1); /* { dg-warning \"15:format\" } */\n     /* The type of strcmp here should have no prototype.  */\n     if (0)\n       strcmp (1);"}, {"sha": "606fe0f891aa6db92f1febf26578360dab61e739", "filename": "gcc/testsuite/gfortran.dg/diagnostic-format-json-1.F90", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fgfortran.dg%2Fdiagnostic-format-json-1.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fgfortran.dg%2Fdiagnostic-format-json-1.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdiagnostic-format-json-1.F90?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -8,17 +8,22 @@\n ! We can't rely on any ordering of the keys.\n \n ! { dg-regexp \"\\\"kind\\\": \\\"error\\\"\" }\n+! { dg-regexp \"\\\"column-origin\\\": 1\" }\n ! { dg-regexp \"\\\"message\\\": \\\"#error message\\\"\" }\n \n ! { dg-regexp \"\\\"caret\\\": \\{\" }\n ! { dg-regexp \"\\\"file\\\": \\\"\\[^\\n\\r\\\"\\]*diagnostic-format-json-1.F90\\\"\" }\n ! { dg-regexp \"\\\"line\\\": 4\" }\n ! { dg-regexp \"\\\"column\\\": 2\" }\n+! { dg-regexp \"\\\"display-column\\\": 2\" }\n+! { dg-regexp \"\\\"byte-column\\\": 2\" }\n \n ! { dg-regexp \"\\\"finish\\\": \\{\" }\n ! { dg-regexp \"\\\"file\\\": \\\"\\[^\\n\\r\\\"\\]*diagnostic-format-json-1.F90\\\"\" }\n ! { dg-regexp \"\\\"line\\\": 4\" }\n ! { dg-regexp \"\\\"column\\\": 6\" }\n+! { dg-regexp \"\\\"display-column\\\": 6\" }\n+! { dg-regexp \"\\\"byte-column\\\": 6\" }\n \n ! { dg-regexp \"\\\"locations\\\": \\[\\[\\{\\}, \\]*\\]\" }\n ! { dg-regexp \"\\\"children\\\": \\[\\[\\]\\[\\]\\]\" }"}, {"sha": "56615f0ca5a0cd376847a9636e15c6c1fdca56e8", "filename": "gcc/testsuite/gfortran.dg/diagnostic-format-json-2.F90", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fgfortran.dg%2Fdiagnostic-format-json-2.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fgfortran.dg%2Fdiagnostic-format-json-2.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdiagnostic-format-json-2.F90?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -8,6 +8,7 @@\n ! We can't rely on any ordering of the keys. \n \n ! { dg-regexp \"\\\"kind\\\": \\\"warning\\\"\" }\n+! { dg-regexp \"\\\"column-origin\\\": 1\" }\n ! { dg-regexp \"\\\"message\\\": \\\"#warning message\\\"\" }\n ! { dg-regexp \"\\\"option\\\": \\\"-Wcpp\\\"\" }\n ! { dg-regexp \"\\\"option_url\\\": \\\"\\[^\\n\\r\\\"\\]*#index-Wcpp\\\"\" }\n@@ -16,11 +17,15 @@\n ! { dg-regexp \"\\\"file\\\": \\\"\\[^\\n\\r\\\"\\]*diagnostic-format-json-2.F90\\\"\" }\n ! { dg-regexp \"\\\"line\\\": 4\" }\n ! { dg-regexp \"\\\"column\\\": 2\" }\n+! { dg-regexp \"\\\"display-column\\\": 2\" }\n+! { dg-regexp \"\\\"byte-column\\\": 2\" }\n \n ! { dg-regexp \"\\\"finish\\\": \\{\" }\n ! { dg-regexp \"\\\"file\\\": \\\"\\[^\\n\\r\\\"\\]*diagnostic-format-json-2.F90\\\"\" }\n ! { dg-regexp \"\\\"line\\\": 4\" }\n ! { dg-regexp \"\\\"column\\\": 8\" }\n+! { dg-regexp \"\\\"display-column\\\": 8\" }\n+! { dg-regexp \"\\\"byte-column\\\": 8\" }\n \n ! { dg-regexp \"\\\"locations\\\": \\[\\[\\{\\}, \\]*\\]\" }\n ! { dg-regexp \"\\\"children\\\": \\[\\[\\]\\[\\]\\]\" }"}, {"sha": "5021475909135c6f278c693831329017aa93a712", "filename": "gcc/testsuite/gfortran.dg/diagnostic-format-json-3.F90", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fgfortran.dg%2Fdiagnostic-format-json-3.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fgfortran.dg%2Fdiagnostic-format-json-3.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdiagnostic-format-json-3.F90?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -8,6 +8,7 @@\n ! We can't rely on any ordering of the keys.\n \n ! { dg-regexp \"\\\"kind\\\": \\\"error\\\"\" }\n+! { dg-regexp \"\\\"column-origin\\\": 1\" }\n ! { dg-regexp \"\\\"message\\\": \\\"#warning message\\\"\" }\n ! { dg-regexp \"\\\"option\\\": \\\"-Werror=cpp\\\"\" }\n ! { dg-regexp \"\\\"option_url\\\": \\\"\\[^\\n\\r\\\"\\]*#index-Wcpp\\\"\" }\n@@ -16,11 +17,15 @@\n ! { dg-regexp \"\\\"file\\\": \\\"\\[^\\n\\r\\\"\\]*diagnostic-format-json-3.F90\\\"\" }\n ! { dg-regexp \"\\\"line\\\": 4\" }\n ! { dg-regexp \"\\\"column\\\": 2\" }\n+! { dg-regexp \"\\\"display-column\\\": 2\" }\n+! { dg-regexp \"\\\"byte-column\\\": 2\" }\n \n ! { dg-regexp \"\\\"finish\\\": \\{\" }\n ! { dg-regexp \"\\\"file\\\": \\\"\\[^\\n\\r\\\"\\]*diagnostic-format-json-3.F90\\\"\" }\n ! { dg-regexp \"\\\"line\\\": 4\" }\n ! { dg-regexp \"\\\"column\\\": 8\" }\n+! { dg-regexp \"\\\"display-column\\\": 8\" }\n+! { dg-regexp \"\\\"byte-column\\\": 8\" }\n \n ! { dg-regexp \"\\\"locations\\\": \\[\\[\\{\\}, \\]*\\]\" }\n ! { dg-regexp \"\\\"children\\\": \\[\\[\\]\\[\\]\\]\" }"}, {"sha": "aa5ba0761d70106b2c5f4b75c63346dea70b0e80", "filename": "gcc/testsuite/go.dg/arrayclear.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fgo.dg%2Farrayclear.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftestsuite%2Fgo.dg%2Farrayclear.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.dg%2Farrayclear.go?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -1,5 +1,8 @@\n // { dg-do compile }\n // { dg-options \"-fgo-debug-optimization\" }\n+// This comment is necessary to work around a dejagnu bug. Otherwise, the\n+// column of the second error message would equal the row of the first one, and\n+// since the errors are also identical, dejagnu is not able to distinguish them.\n \n package p\n "}, {"sha": "82b3c2d6b6a4607d254ee40ba56bbf603699ffe5", "filename": "gcc/tree-diagnostic-path.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftree-diagnostic-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/gcc%2Ftree-diagnostic-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-diagnostic-path.cc?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -493,7 +493,7 @@ default_tree_diagnostic_path_printer (diagnostic_context *context,\n    doesn't have access to trees (for m_fndecl).  */\n \n json::value *\n-default_tree_make_json_for_path (diagnostic_context *,\n+default_tree_make_json_for_path (diagnostic_context *context,\n \t\t\t\t const diagnostic_path *path)\n {\n   json::array *path_array = new json::array ();\n@@ -504,7 +504,8 @@ default_tree_make_json_for_path (diagnostic_context *,\n       json::object *event_obj = new json::object ();\n       if (event.get_location ())\n \tevent_obj->set (\"location\",\n-\t\t\tjson_from_expanded_location (event.get_location ()));\n+\t\t\tjson_from_expanded_location (context,\n+\t\t\t\t\t\t     event.get_location ()));\n       label_text event_text (event.get_desc (false));\n       event_obj->set (\"description\", new json::string (event_text.m_buffer));\n       event_text.maybe_free ();"}, {"sha": "28b81c9c8642c0978734f3b9fcd449acaa649710", "filename": "libcpp/charset.c", "status": "modified", "additions": 68, "deletions": 30, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/libcpp%2Fcharset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/libcpp%2Fcharset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fcharset.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -2276,49 +2276,90 @@ cpp_string_location_reader::get_next ()\n   return result;\n }\n \n-/* Helper for cpp_byte_column_to_display_column and its inverse.  Given a\n-   pointer to a UTF-8-encoded character, compute its display width.  *INBUFP\n-   points on entry to the start of the UTF-8 encoding of the character, and\n-   is updated to point just after the last byte of the encoding.  *INBYTESLEFTP\n-   contains on entry the remaining size of the buffer into which *INBUFP\n-   points, and this is also updated accordingly.  If *INBUFP does not\n+cpp_display_width_computation::\n+cpp_display_width_computation (const char *data, int data_length, int tabstop) :\n+  m_begin (data),\n+  m_next (m_begin),\n+  m_bytes_left (data_length),\n+  m_tabstop (tabstop),\n+  m_display_cols (0)\n+{\n+  gcc_assert (m_tabstop > 0);\n+}\n+\n+\n+/* The main implementation function for class cpp_display_width_computation.\n+   m_next points on entry to the start of the UTF-8 encoding of the next\n+   character, and is updated to point just after the last byte of the encoding.\n+   m_bytes_left contains on entry the remaining size of the buffer into which\n+   m_next points, and this is also updated accordingly.  If m_next does not\n    point to a valid UTF-8-encoded sequence, then it will be treated as a single\n-   byte with display width 1.  */\n+   byte with display width 1.  m_cur_display_col is the current display column,\n+   relative to which tab stops should be expanded.  Returns the display width of\n+   the codepoint just processed.  */\n \n-static inline int\n-compute_next_display_width (const uchar **inbufp, size_t *inbytesleftp)\n+int\n+cpp_display_width_computation::process_next_codepoint ()\n {\n   cppchar_t c;\n-  if (one_utf8_to_cppchar (inbufp, inbytesleftp, &c) != 0)\n+  int next_width;\n+\n+  if (*m_next == '\\t')\n+    {\n+      ++m_next;\n+      --m_bytes_left;\n+      next_width = m_tabstop - (m_display_cols % m_tabstop);\n+    }\n+  else if (one_utf8_to_cppchar ((const uchar **) &m_next, &m_bytes_left, &c)\n+\t   != 0)\n     {\n       /* Input is not convertible to UTF-8.  This could be fine, e.g. in a\n \t string literal, so don't complain.  Just treat it as if it has a width\n \t of one.  */\n-      ++*inbufp;\n-      --*inbytesleftp;\n-      return 1;\n+      ++m_next;\n+      --m_bytes_left;\n+      next_width = 1;\n+    }\n+  else\n+    {\n+      /*  one_utf8_to_cppchar() has updated m_next and m_bytes_left for us.  */\n+      next_width = cpp_wcwidth (c);\n     }\n \n-  /*  one_utf8_to_cppchar() has updated inbufp and inbytesleftp for us.  */\n-  return cpp_wcwidth (c);\n+  m_display_cols += next_width;\n+  return next_width;\n+}\n+\n+/*  Utility to advance the byte stream by the minimum amount needed to consume\n+    N display columns.  Returns the number of display columns that were\n+    actually skipped.  This could be less than N, if there was not enough data,\n+    or more than N, if the last character to be skipped had a sufficiently large\n+    display width.  */\n+int\n+cpp_display_width_computation::advance_display_cols (int n)\n+{\n+  const int start = m_display_cols;\n+  const int target = start + n;\n+  while (m_display_cols < target && !done ())\n+    process_next_codepoint ();\n+  return m_display_cols - start;\n }\n \n /*  For the string of length DATA_LENGTH bytes that begins at DATA, compute\n     how many display columns are occupied by the first COLUMN bytes.  COLUMN\n     may exceed DATA_LENGTH, in which case the phantom bytes at the end are\n-    treated as if they have display width 1.  */\n+    treated as if they have display width 1.  Tabs are expanded to the next tab\n+    stop, relative to the start of DATA.  */\n \n int\n cpp_byte_column_to_display_column (const char *data, int data_length,\n-\t\t\t\t   int column)\n+\t\t\t\t   int column, int tabstop)\n {\n-  int display_col = 0;\n-  const uchar *udata = (const uchar *) data;\n   const int offset = MAX (0, column - data_length);\n-  size_t inbytesleft = column - offset;\n-  while (inbytesleft)\n-    display_col += compute_next_display_width (&udata, &inbytesleft);\n-  return display_col + offset;\n+  cpp_display_width_computation dw (data, column - offset, tabstop);\n+  while (!dw.done ())\n+    dw.process_next_codepoint ();\n+  return dw.display_cols_processed () + offset;\n }\n \n /*  For the string of length DATA_LENGTH bytes that begins at DATA, compute\n@@ -2328,14 +2369,11 @@ cpp_byte_column_to_display_column (const char *data, int data_length,\n \n int\n cpp_display_column_to_byte_column (const char *data, int data_length,\n-\t\t\t\t   int display_col)\n+\t\t\t\t   int display_col, int tabstop)\n {\n-  int column = 0;\n-  const uchar *udata = (const uchar *) data;\n-  size_t inbytesleft = data_length;\n-  while (column < display_col && inbytesleft)\n-      column += compute_next_display_width (&udata, &inbytesleft);\n-  return data_length - inbytesleft + MAX (0, display_col - column);\n+  cpp_display_width_computation dw (data, data_length, tabstop);\n+  const int avail_display = dw.advance_display_cols (display_col);\n+  return dw.bytes_processed () + MAX (0, display_col - avail_display);\n }\n \n /* Our own version of wcwidth().  We don't use the actual wcwidth() in glibc,"}, {"sha": "8e398863cf6e8695b21b3d7eea708d114b82ec64", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -312,9 +312,6 @@ enum cpp_normalize_level {\n    carries all the options visible to the command line.  */\n struct cpp_options\n {\n-  /* Characters between tab stops.  */\n-  unsigned int tabstop;\n-\n   /* The language we're preprocessing.  */\n   enum c_lang lang;\n \n@@ -1335,14 +1332,43 @@ extern const char * cpp_get_userdef_suffix\n   (const cpp_token *);\n \n /* In charset.c */\n+\n+/* A class to manage the state while converting a UTF-8 sequence to cppchar_t\n+   and computing the display width one character at a time.  */\n+class cpp_display_width_computation {\n+ public:\n+  cpp_display_width_computation (const char *data, int data_length,\n+\t\t\t\t int tabstop);\n+  const char *next_byte () const { return m_next; }\n+  int bytes_processed () const { return m_next - m_begin; }\n+  int bytes_left () const { return m_bytes_left; }\n+  bool done () const { return !bytes_left (); }\n+  int display_cols_processed () const { return m_display_cols; }\n+\n+  int process_next_codepoint ();\n+  int advance_display_cols (int n);\n+\n+ private:\n+  const char *const m_begin;\n+  const char *m_next;\n+  size_t m_bytes_left;\n+  const int m_tabstop;\n+  int m_display_cols;\n+};\n+\n+/* Convenience functions that are simple use cases for class\n+   cpp_display_width_computation.  Tab characters will be expanded to spaces\n+   as determined by TABSTOP.  */\n int cpp_byte_column_to_display_column (const char *data, int data_length,\n-\t\t\t\t       int column);\n-inline int cpp_display_width (const char *data, int data_length)\n+\t\t\t\t       int column, int tabstop);\n+inline int cpp_display_width (const char *data, int data_length,\n+\t\t\t      int tabstop)\n {\n-    return cpp_byte_column_to_display_column (data, data_length, data_length);\n+  return cpp_byte_column_to_display_column (data, data_length, data_length,\n+\t\t\t\t\t    tabstop);\n }\n int cpp_display_column_to_byte_column (const char *data, int data_length,\n-\t\t\t\t       int display_col);\n+\t\t\t\t       int display_col, int tabstop);\n int cpp_wcwidth (cppchar_t c);\n \n #endif /* ! LIBCPP_CPPLIB_H */"}, {"sha": "0aac5acd0a359dc4d5bcd8ad08f87169663433b3", "filename": "libcpp/init.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004bb936d6d5f177af26ad4905595e843d5665a5/libcpp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004bb936d6d5f177af26ad4905595e843d5665a5/libcpp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finit.c?ref=004bb936d6d5f177af26ad4905595e843d5665a5", "patch": "@@ -190,7 +190,6 @@ cpp_create_reader (enum c_lang lang, cpp_hash_table *table,\n   CPP_OPTION (pfile, discard_comments) = 1;\n   CPP_OPTION (pfile, discard_comments_in_macro_exp) = 1;\n   CPP_OPTION (pfile, max_include_depth) = 200;\n-  CPP_OPTION (pfile, tabstop) = 8;\n   CPP_OPTION (pfile, operator_names) = 1;\n   CPP_OPTION (pfile, warn_trigraphs) = 2;\n   CPP_OPTION (pfile, warn_endif_labels) = 1;"}]}