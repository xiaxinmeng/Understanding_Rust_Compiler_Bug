{"sha": "6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZkMGE3MmE1MzgxZWMzZWMzY2YwOTc0YWRjMTdlNzBjN2E1N2Y3OA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-20T15:39:55Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-20T15:39:55Z"}, "message": "[multiple changes]\n\n2014-01-20  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch9.adb, checks.adb, exp_intr.adb: Minor reformatting.\n\t* sem_res.adb (Resolve): Fix error causing infinite loop for\n\tinteger used as address. Allow addresses as integers.\n\n2014-01-20  Arnaud Charlet  <charlet@adacore.com>\n\n\t* s-osinte-linux.ads (struct_sigaction): Fix rep clause.\n\n2014-01-20  Bob Duff  <duff@adacore.com>\n\n\t* par-ch8.adb (P_Use_Type_Clause): Detect syntax\n\terror when \"use all\" is not followed by \"type\".\n\nFrom-SVN: r206829", "tree": {"sha": "617227db0bb63d276a03b86319ba887c1fc9d4da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/617227db0bb63d276a03b86319ba887c1fc9d4da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78/comments", "author": null, "committer": null, "parents": [{"sha": "3b4598a761a9eb685e5a5013416f6c4f790ec6aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b4598a761a9eb685e5a5013416f6c4f790ec6aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b4598a761a9eb685e5a5013416f6c4f790ec6aa"}], "stats": {"total": 251, "additions": 144, "deletions": 107}, "files": [{"sha": "97defc95cdea258d1321ddb9ce66445af6806700", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78", "patch": "@@ -1,3 +1,18 @@\n+2014-01-20  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch9.adb, checks.adb, exp_intr.adb: Minor reformatting.\n+\t* sem_res.adb (Resolve): Fix error causing infinite loop for\n+\tinteger used as address. Allow addresses as integers.\n+\n+2014-01-20  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* s-osinte-linux.ads (struct_sigaction): Fix rep clause.\n+\n+2014-01-20  Bob Duff  <duff@adacore.com>\n+\n+\t* par-ch8.adb (P_Use_Type_Clause): Detect syntax\n+\terror when \"use all\" is not followed by \"type\".\n+\n 2014-01-20  Bob Duff  <duff@adacore.com>\n \n \t* exp_intr.adb (Expand_Unc_Deallocation): Remove warning on abort"}, {"sha": "1e4cff810c56b7e0bf6ed6f336b2de00dda14eed", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78", "patch": "@@ -767,9 +767,11 @@ package body Checks is\n            and then not Warnings_Off (E)\n            and then Restriction_Active (No_Exception_Propagation)\n          then\n-            Error_Msg_N (\"address value may be incompatible with \" &\n-                           \"alignment of object?\", N);\n+            Error_Msg_N\n+              (\"address value may be incompatible with alignment of object?\",\n+               N);\n          end if;\n+\n          return;\n       end if;\n "}, {"sha": "752354298913687c9d36017d7ece12762beb4102", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 57, "deletions": 58, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78", "patch": "@@ -70,9 +70,9 @@ package body Exp_Ch9 is\n    --  The following constant establishes the upper bound for the index of\n    --  an entry family. It is used to limit the allocated size of protected\n    --  types with defaulted discriminant of an integer type, when the bound\n-   --  of some entry family depends on a discriminant. The limitation to\n-   --  entry families of 128K should be reasonable in all cases, and is a\n-   --  documented implementation restriction.\n+   --  of some entry family depends on a discriminant. The limitation to entry\n+   --  families of 128K should be reasonable in all cases, and is a documented\n+   --  implementation restriction.\n \n    Entry_Family_Bound : constant Int := 2**16;\n \n@@ -202,8 +202,8 @@ package body Exp_Ch9 is\n    --  pre/postconditions. The body gathers the PPC's and expands them in the\n    --  usual way, and performs the entry call itself. This way preconditions\n    --  are evaluated before the call is queued. E is the entry in question,\n-   --  and Decl is the enclosing synchronized type declaration at whose\n-   --  freeze point the generated body is analyzed.\n+   --  and Decl is the enclosing synchronized type declaration at whose freeze\n+   --  point the generated body is analyzed.\n \n    function Build_Protected_Entry\n      (N   : Node_Id;\n@@ -238,12 +238,12 @@ package body Exp_Ch9 is\n       Pid       : Node_Id;\n       N_Op_Spec : Node_Id) return Node_Id;\n    --  This function is used to construct the protected version of a protected\n-   --  subprogram. Its statement sequence first defers abort, then locks\n-   --  the associated protected object, and then enters a block that contains\n-   --  a call to the unprotected version of the subprogram (for details, see\n-   --  Build_Unprotected_Subprogram_Body). This block statement requires\n-   --  a cleanup handler that unlocks the object in all cases.\n-   --  (see Exp_Ch7.Expand_Cleanup_Actions).\n+   --  subprogram. Its statement sequence first defers abort, then locks the\n+   --  associated protected object, and then enters a block that contains a\n+   --  call to the unprotected version of the subprogram (for details, see\n+   --  Build_Unprotected_Subprogram_Body). This block statement requires a\n+   --  cleanup handler that unlocks the object in all cases. For details,\n+   --  see Exp_Ch7.Expand_Cleanup_Actions.\n \n    function Build_Renamed_Formal_Declaration\n      (New_F          : Entity_Id;\n@@ -262,14 +262,13 @@ package body Exp_Ch9 is\n      (Prefix      : Entity_Id;\n       Selector    : Entity_Id;\n       Append_Char : Character := ' ') return Name_Id;\n-   --  Build a name in the form of Prefix__Selector, with an optional\n-   --  character appended. This is used for internal subprograms generated\n-   --  for operations of protected types, including barrier functions.\n-   --  For the subprograms generated for entry bodies and entry barriers,\n-   --  the generated name includes a sequence number that makes names\n-   --  unique in the presence of entry overloading. This is necessary\n-   --  because entry body procedures and barrier functions all have the\n-   --  same signature.\n+   --  Build a name in the form of Prefix__Selector, with an optional character\n+   --  appended. This is used for internal subprograms generated for operations\n+   --  of protected types, including barrier functions. For the subprograms\n+   --  generated for entry bodies and entry barriers, the generated name\n+   --  includes a sequence number that makes names unique in the presence of\n+   --  entry overloading. This is necessary because entry body procedures and\n+   --  barrier functions all have the same signature.\n \n    procedure Build_Simple_Entry_Call\n      (N       : Node_Id;\n@@ -350,14 +349,14 @@ package body Exp_Ch9 is\n \n    procedure Ensure_Statement_Present (Loc : Source_Ptr; Alt : Node_Id);\n    --  If control flow optimizations are suppressed, and Alt is an accept,\n-   --  delay, or entry call alternative with no trailing statements, insert a\n-   --  null trailing statement with the given Loc (which is the sloc of the\n-   --  accept, delay, or entry call statement). There might not be any\n-   --  generated code for the accept, delay, or entry call itself (the\n-   --  effect of these statements is part of the general processsing done\n-   --  for the enclosing selective accept, timed entry call, or asynchronous\n-   --  select), and the null statement is there to carry the sloc of that\n-   --  statement to the back-end for trace-based coverage analysis purposes.\n+   --  delay, or entry call alternative with no trailing statements, insert\n+   --  a null trailing statement with the given Loc (which is the sloc of\n+   --  the accept, delay, or entry call statement). There might not be any\n+   --  generated code for the accept, delay, or entry call itself (the effect\n+   --  of these statements is part of the general processsing done for the\n+   --  enclosing selective accept, timed entry call, or asynchronous select),\n+   --  and the null statement is there to carry the sloc of that statement to\n+   --  the back-end for trace-based coverage analysis purposes.\n \n    procedure Extract_Dispatching_Call\n      (N        : Node_Id;\n@@ -376,32 +375,32 @@ package body Exp_Ch9 is\n       Concval : out Node_Id;\n       Ename   : out Node_Id;\n       Index   : out Node_Id);\n-   --  Given an entry call, returns the associated concurrent object,\n-   --  the entry name, and the entry family index.\n+   --  Given an entry call, returns the associated concurrent object, the entry\n+   --  name, and the entry family index.\n \n    function Family_Offset\n      (Loc  : Source_Ptr;\n       Hi   : Node_Id;\n       Lo   : Node_Id;\n       Ttyp : Entity_Id;\n       Cap  : Boolean) return Node_Id;\n-   --  Compute (Hi - Lo) for two entry family indexes. Hi is the index in\n-   --  an accept statement, or the upper bound in the discrete subtype of\n-   --  an entry declaration. Lo is the corresponding lower bound. Ttyp is\n-   --  the concurrent type of the entry. If Cap is true, the result is\n-   --  capped according to Entry_Family_Bound.\n+   --  Compute (Hi - Lo) for two entry family indexes. Hi is the index in an\n+   --  accept statement, or the upper bound in the discrete subtype of an entry\n+   --  declaration. Lo is the corresponding lower bound. Ttyp is the concurrent\n+   --  type of the entry. If Cap is true, the result is capped according to\n+   --  Entry_Family_Bound.\n \n    function Family_Size\n      (Loc  : Source_Ptr;\n       Hi   : Node_Id;\n       Lo   : Node_Id;\n       Ttyp : Entity_Id;\n       Cap  : Boolean) return Node_Id;\n-   --  Compute (Hi - Lo) + 1 Max 0, to determine the number of entries in\n-   --  a family, and handle properly the superflat case. This is equivalent\n-   --  to the use of 'Length on the index type, but must use Family_Offset\n-   --  to handle properly the case of bounds that depend on discriminants.\n-   --  If Cap is true, the result is capped according to Entry_Family_Bound.\n+   --  Compute (Hi - Lo) + 1 Max 0, to determine the number of entries in a\n+   --  family, and handle properly the superflat case. This is equivalent to\n+   --  the use of 'Length on the index type, but must use Family_Offset to\n+   --  handle properly the case of bounds that depend on discriminants. If\n+   --  Cap is true, the result is capped according to Entry_Family_Bound.\n \n    procedure Find_Enclosing_Context\n      (N             : Node_Id;\n@@ -417,8 +416,8 @@ package body Exp_Ch9 is\n \n    function Index_Object (Spec_Id : Entity_Id) return Entity_Id;\n    --  Given a subprogram identifier, return the entity which is associated\n-   --  with the protection entry index in the Protected_Body_Subprogram or the\n-   --  Task_Body_Procedure of Spec_Id. The returned entity denotes formal\n+   --  with the protection entry index in the Protected_Body_Subprogram or\n+   --  the Task_Body_Procedure of Spec_Id. The returned entity denotes formal\n    --  parameter _E.\n \n    function Is_Exception_Safe (Subprogram : Node_Id) return Boolean;\n@@ -436,9 +435,9 @@ package body Exp_Ch9 is\n \n    function Null_Statements (Stats : List_Id) return Boolean;\n    --  Used to check DO-END sequence. Checks for equivalent of DO NULL; END.\n-   --  Allows labels, and pragma Warnings/Unreferenced in the sequence as\n-   --  well to still count as null. Returns True for a null sequence. The\n-   --  argument is the list of statements from the DO-END sequence.\n+   --  Allows labels, and pragma Warnings/Unreferenced in the sequence as well\n+   --  to still count as null. Returns True for a null sequence. The argument\n+   --  is the list of statements from the DO-END sequence.\n \n    function Parameter_Block_Pack\n      (Loc     : Source_Ptr;\n@@ -447,8 +446,8 @@ package body Exp_Ch9 is\n       Formals : List_Id;\n       Decls   : List_Id;\n       Stmts   : List_Id) return Entity_Id;\n-   --  Set the components of the generated parameter block with the values of\n-   --  the actual parameters. Generate aliased temporaries to capture the\n+   --  Set the components of the generated parameter block with the values\n+   --  of the actual parameters. Generate aliased temporaries to capture the\n    --  values for types that are passed by copy. Otherwise generate a reference\n    --  to the actual's value. Return the address of the aggregate block.\n    --  Generate:\n@@ -605,8 +604,8 @@ package body Exp_Ch9 is\n             S :=\n               Etype (Discrete_Subtype_Definition (Declaration_Node (Prev)));\n \n-            --  The need for the following full view retrieval stems from\n-            --  this complex case of nested generics and tasking:\n+            --  The need for the following full view retrieval stems from this\n+            --  complex case of nested generics and tasking:\n \n             --     generic\n             --        type Formal_Index is range <>;\n@@ -638,6 +637,7 @@ package body Exp_Ch9 is\n             --  We are currently building the index expression for the entry\n             --  call \"T.E\" (1). Part of the expansion must mention the range\n             --  of the discrete type \"Index\" (2) of entry family \"Fam\".\n+\n             --  However only the private view of type \"Index\" is available to\n             --  the inner generic (3) because there was no prior mention of\n             --  the type inside \"Inner\". This visibility requirement is\n@@ -708,9 +708,9 @@ package body Exp_Ch9 is\n          Set_Etype (New_F, Etype (Formal));\n          Set_Scope (New_F, Ent);\n \n-         --  Now we set debug info needed on New_F even though it does not\n-         --  come from source, so that the debugger will get the right\n-         --  information for these generated names.\n+         --  Now we set debug info needed on New_F even though it does not come\n+         --  from source, so that the debugger will get the right information\n+         --  for these generated names.\n \n          Set_Debug_Info_Needed (New_F);\n \n@@ -843,8 +843,8 @@ package body Exp_Ch9 is\n          New_S := Stats;\n       end if;\n \n-      --  At this stage we know that the new statement sequence does not\n-      --  have an exception handler part, so we supply one to call\n+      --  At this stage we know that the new statement sequence does\n+      --  not have an exception handler part, so we supply one to call\n       --  Exceptional_Complete_Rendezvous. This handler is\n \n       --    when all others =>\n@@ -974,8 +974,7 @@ package body Exp_Ch9 is\n \n             Prepend_To (Decls, Decl);\n \n-            --  Ensure that the _chain appears in the proper scope of the\n-            --  context.\n+            --  Ensure that _chain appears in the proper scope of the context\n \n             if Context_Id /= Current_Scope then\n                Push_Scope (Context_Id);\n@@ -1189,9 +1188,9 @@ package body Exp_Ch9 is\n                   while Nkind (Par) /= N_Compilation_Unit loop\n                      Par := Parent (Par);\n \n-                     --  If we fall off the top, we are at the outer level, and\n-                     --  the environment task is our effective master, so\n-                     --  nothing to mark.\n+                     --  If we fall off the top, we are at the outer level,\n+                     --  and the environment task is our effective master,\n+                     --  so nothing to mark.\n \n                      if Nkind_In (Par, N_Block_Statement,\n                                        N_Subprogram_Body,"}, {"sha": "6289b1ee224c5e5d33eb78480359357525a182e2", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78", "patch": "@@ -1018,11 +1018,12 @@ package body Exp_Intr is\n       --  For a task type, call Free_Task before freeing the ATCB\n \n       if Is_Task_Type (Desig_T) then\n+\n          --  We used to detect the case of Abort followed by a Free here,\n-         --  because the Free wouldn't actually free if it happens before the\n-         --  aborted task actually terminates. The warning is removed, because\n-         --  Free now works properly (the task will be freed once it\n-         --  terminates).\n+         --  because the Free wouldn't actually free if it happens before\n+         --  the aborted task actually terminates. The warning was removed,\n+         --  because Free now works properly (the task will be freed once\n+         --  it terminates).\n \n          Append_To\n            (Stmts, Cleanup_Task (N, Duplicate_Subexpr_No_Checks (Arg)));"}, {"sha": "8b349b417d6a1f18c377ee51b54c2280ece646d8", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78", "patch": "@@ -1239,8 +1239,9 @@ If the configuration pragma\n @code{Allow_Integer_Address} is given, then integer expressions may\n be used anywhere a value of type @code{System.Address} is required.\n The effect is to introduce an implicit unchecked conversion from the\n-integer value to type @code{System.Address}. The following example\n-compiles without errors:\n+integer value to type @code{System.Address}. The reverse case of using\n+an address where an integer type is required is handled analogously.\n+The following example compiles without errors:\n \n @smallexample @c ada\n pragma Allow_Integer_Address;\n@@ -1253,6 +1254,8 @@ package AddrAsInt is\n    m : Address := 16#4000#;\n    n : constant Address := 4000;\n    p : constant Address := Address (X + Y);\n+   v : Integer := y'Address;\n+   w : constant Integer := Integer (Y'Address);\n    type R is new integer;\n    RR : R := 1000;\n    Z : Integer;"}, {"sha": "b4eaf8c72284eb326ff64526823461b1b57d0fca", "filename": "gcc/ada/par-ch8.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78/gcc%2Fada%2Fpar-ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78/gcc%2Fada%2Fpar-ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch8.adb?ref=6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78", "patch": "@@ -113,7 +113,12 @@ package body Ch8 is\n          Error_Msg_Ada_2012_Feature (\"|`USE ALL TYPE`\", Token_Ptr);\n          All_Present := True;\n          Scan; -- past ALL\n-      else\n+\n+         if Token /= Tok_Type then\n+            Error_Msg_SC (\"TYPE expected\");\n+         end if;\n+\n+      else pragma Assert (Token = Tok_Type);\n          All_Present := False;\n       end if;\n "}, {"sha": "3f8df80c0721aa3e77e6d3b74a72b4dd14ae26ae", "filename": "gcc/ada/s-osinte-linux.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78/gcc%2Fada%2Fs-osinte-linux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78/gcc%2Fada%2Fs-osinte-linux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-linux.ads?ref=6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78", "patch": "@@ -7,7 +7,7 @@\n --                                  S p e c                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---          Copyright (C) 1995-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1995-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -589,7 +589,8 @@ private\n    for struct_sigaction use record\n       sa_handler at Linux.sa_handler_pos range 0 .. Standard'Address_Size - 1;\n       sa_mask    at Linux.sa_mask_pos    range 0 .. 1023;\n-      sa_flags   at Linux.sa_flags_pos   range 0 .. Standard'Address_Size - 1;\n+      sa_flags   at Linux.sa_flags_pos\n+        range 0 .. Interfaces.C.unsigned_long'Size - 1;\n    end record;\n    --  We intentionally leave sa_restorer unspecified and let the compiler\n    --  append it after the last field, so disable corresponding warning."}, {"sha": "2dc9291a4114b7f714c15935efd0aa04a525519c", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 49, "deletions": 38, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=6fd0a72a5381ec3ec3cf0974adc17e70c7a57f78", "patch": "@@ -2612,30 +2612,36 @@ package body Sem_Res is\n                end;\n             end if;\n \n-            --  If an error message was issued already, Found got reset to\n-            --  True, so if it is still False, issue standard Wrong_Type msg.\n-\n-            --  First check for special case of Address wanted, integer found\n-            --  with the configuration pragma Allow_Integer_Address active.\n-\n-            if Allow_Integer_Address\n-              and then Is_RTE (Typ, RE_Address)\n-              and then Is_Integer_Type (Etype (N))\n-            then\n-               Rewrite\n-                 (N, Unchecked_Convert_To (RTE (RE_Address),\n-                  Relocate_Node (N)));\n-               Analyze_And_Resolve (N, RTE (RE_Address));\n-               return;\n+            --  Looks like we have a type error, but check for special case\n+            --  of Address wanted, integer found, with the configuration pragma\n+            --  Allow_Integer_Address active. If we have this case, introduce\n+            --  an unchecked conversion to allow the integer expression to be\n+            --  treated as an Address. The reverse case of integer wanted,\n+            --  Address found, is treated in an analogous manner.\n+\n+            if Allow_Integer_Address then\n+               if (Is_RTE (Typ, RE_Address)\n+                    and then Is_Integer_Type (Etype (N)))\n+                 or else\n+                   (Is_Integer_Type (Typ)\n+                     and then Is_RTE (Etype (N), RE_Address))\n+               then\n+                  Rewrite (N, Unchecked_Convert_To (Typ, Relocate_Node (N)));\n+                  Analyze_And_Resolve (N, Typ);\n+                  return;\n+               end if;\n+            end if;\n \n-            --  OK, not the special case go ahead and issue message\n+            --  That special Allow_Integer_Address check did not appply, so we\n+            --  have a real type error. If an error message was issued already,\n+            --  Found got reset to True, so if it's still False, issue standard\n+            --  Wrong_Type message.\n \n-            elsif not Found then\n-               if Is_Overloaded (N)\n-                 and then Nkind (N) = N_Function_Call\n-               then\n+            if not Found then\n+               if Is_Overloaded (N) and then Nkind (N) = N_Function_Call then\n                   declare\n                      Subp_Name : Node_Id;\n+\n                   begin\n                      if Is_Entity_Name (Name (N)) then\n                         Subp_Name := Name (N);\n@@ -11085,6 +11091,23 @@ package body Sem_Res is\n          end;\n       end if;\n \n+      --  Deal with conversion of integer type to address if the pragma\n+      --  Allow_Integer_Address is in effect. We convert the conversion to\n+      --  an unchecked conversion in this case and we are all done!\n+\n+      if Allow_Integer_Address\n+        and then\n+          ((Is_RTE (Target_Type, RE_Address)\n+             and then Is_Integer_Type (Opnd_Type))\n+          or else\n+           (Is_RTE (Opnd_Type, RE_Address)\n+             and then Is_Integer_Type (Target_Type)))\n+      then\n+         Rewrite (N, Unchecked_Convert_To (Target_Type, Expression (N)));\n+         Analyze_And_Resolve (N, Target_Type);\n+         return True;\n+      end if;\n+\n       --  If we are within a child unit, check whether the type of the\n       --  expression has an ancestor in a parent unit, in which case it\n       --  belongs to its derivation class even if the ancestor is private.\n@@ -11094,7 +11117,7 @@ package body Sem_Res is\n \n       --  Numeric types\n \n-      if Is_Numeric_Type (Target_Type)  then\n+      if Is_Numeric_Type (Target_Type) then\n \n          --  A universal fixed expression can be converted to any numeric type\n \n@@ -11120,11 +11143,11 @@ package body Sem_Res is\n \n          else\n             return Conversion_Check\n-                    (Is_Numeric_Type (Opnd_Type)\n-                      or else\n-                        (Present (Inc_Ancestor)\n-                          and then Is_Numeric_Type (Inc_Ancestor)),\n-                     \"illegal operand for numeric conversion\");\n+                     (Is_Numeric_Type (Opnd_Type)\n+                       or else\n+                         (Present (Inc_Ancestor)\n+                           and then Is_Numeric_Type (Inc_Ancestor)),\n+                      \"illegal operand for numeric conversion\");\n          end if;\n \n       --  Array types\n@@ -11637,18 +11660,6 @@ package body Sem_Res is\n             (\"add ALL to }!\", N, Target_Type);\n          return False;\n \n-      --  Deal with conversion of integer type to address if the pragma\n-      --  Allow_Integer_Address is in effect.\n-\n-      elsif Allow_Integer_Address\n-        and then Is_RTE (Etype (N), RE_Address)\n-        and then Is_Integer_Type (Etype (Operand))\n-      then\n-         Rewrite (N,\n-           Unchecked_Convert_To (RTE (RE_Address), Relocate_Node (N)));\n-         Analyze_And_Resolve (N, RTE (RE_Address));\n-         return True;\n-\n       --  Here we have a real conversion error\n \n       else"}]}