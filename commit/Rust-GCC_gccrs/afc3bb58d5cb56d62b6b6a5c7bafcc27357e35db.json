{"sha": "afc3bb58d5cb56d62b6b6a5c7bafcc27357e35db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZjM2JiNThkNWNiNTZkNjJiNmI2YTVjN2JhZmNjMjczNTdlMzVkYg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-02-21T20:59:26Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-02-21T20:59:26Z"}, "message": "* libsupc++/vterminate.cc\n\t(__gnu_cxx::__verbose_terminate_handler): Guard against recursive\n\tcalls to terminate.\n\t* src/demangle.cc (__cxa_demangle): Wrap in try-catch block.\n\nFrom-SVN: r78235", "tree": {"sha": "6d61b2824699cd8de17a0d01e06990679f06a550", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d61b2824699cd8de17a0d01e06990679f06a550"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afc3bb58d5cb56d62b6b6a5c7bafcc27357e35db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afc3bb58d5cb56d62b6b6a5c7bafcc27357e35db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afc3bb58d5cb56d62b6b6a5c7bafcc27357e35db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afc3bb58d5cb56d62b6b6a5c7bafcc27357e35db/comments", "author": null, "committer": null, "parents": [{"sha": "e1efc7a02828457976b61df42fd5b8444177784f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1efc7a02828457976b61df42fd5b8444177784f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1efc7a02828457976b61df42fd5b8444177784f"}], "stats": {"total": 120, "additions": 72, "deletions": 48}, "files": [{"sha": "e560c6c16bca7f48b292ad7c65832448e48007ff", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afc3bb58d5cb56d62b6b6a5c7bafcc27357e35db/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afc3bb58d5cb56d62b6b6a5c7bafcc27357e35db/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=afc3bb58d5cb56d62b6b6a5c7bafcc27357e35db", "patch": "@@ -1,3 +1,13 @@\n+2004-02-21  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* libsupc++/vterminate.cc\n+\t(__gnu_cxx::__verbose_terminate_handler): Guard against recursive\n+\tcalls to terminate.\n+\t* src/demangle.cc (__cxa_demangle): Wrap in try-catch block.\n+\n+\t* testsuite/testsuite_hooks.cc (__gnu_test::set_memory_limits): Do\n+\tnot set RLIMIT_AS on HP-UX.\n+\n 2004-02-21  Mark Mitchell  <mark@codesourcery.com>\n \n \t* testsuite/testsuite_hooks.cc (__gnu_test::set_memory_limits): Do"}, {"sha": "0ec9f2ccfe4cf99280435d3ec97a3b2eac0be092", "filename": "libstdc++-v3/libsupc++/vterminate.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afc3bb58d5cb56d62b6b6a5c7bafcc27357e35db/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvterminate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afc3bb58d5cb56d62b6b6a5c7bafcc27357e35db/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvterminate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvterminate.cc?ref=afc3bb58d5cb56d62b6b6a5c7bafcc27357e35db", "patch": "@@ -51,6 +51,16 @@ namespace __gnu_cxx\n    stderr.  */\n   void __verbose_terminate_handler()\n   {\n+    static bool terminating;\n+\n+    if (terminating)\n+      {\n+\twritestr (\"terminate called recursively\\n\");\n+\tabort ();\n+      }\n+ \n+   terminating = true;\n+\n     // Make sure there was an exception; terminate is also called for an\n     // attempt to rethrow when there is no suitable exception.\n     type_info *t = __cxa_current_exception_type();"}, {"sha": "779076d3554b22a295139dff140562a0f6251a9e", "filename": "libstdc++-v3/src/demangle.cc", "status": "modified", "additions": 52, "deletions": 48, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afc3bb58d5cb56d62b6b6a5c7bafcc27357e35db/libstdc%2B%2B-v3%2Fsrc%2Fdemangle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afc3bb58d5cb56d62b6b6a5c7bafcc27357e35db/libstdc%2B%2B-v3%2Fsrc%2Fdemangle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fdemangle.cc?ref=afc3bb58d5cb56d62b6b6a5c7bafcc27357e35db", "patch": "@@ -106,63 +106,67 @@ namespace __cxxabiv1\n   __cxa_demangle(char const* mangled_name, char* buf, std::size_t* n, \n \t\t int* status)\n   {\n-    using namespace __gnu_cxx;\n-    typedef demangler::session<std::allocator<char> > session_type;\n+    try {\n+      using namespace __gnu_cxx;\n+      typedef demangler::session<std::allocator<char> > session_type;\n \n-    if (!mangled_name || (buf && !n))\n-      return failure(invalid_argument, status);\n+      if (!mangled_name || (buf && !n))\n+\treturn failure(invalid_argument, status);\n \n-    std::string result;\n-    if (mangled_name[0] == '_')\t\t\n-    {\n-      // External name?\n-      if (mangled_name[1] == 'Z')\t\t\n-      {\n-\t// C++ name?\n-\tint cnt = session_type::\n-\t    decode_encoding(result, mangled_name + 2, INT_MAX);\n-\tif (cnt < 0 || mangled_name[cnt + 2] != 0)\n-\t  return failure(invalid_mangled_name, status);\n-\treturn finish(result.data(), result.size(), buf, n, status);\n-      }\n-      else if (mangled_name[1] == 'G')\t\n+      std::string result;\n+      if (mangled_name[0] == '_')\t\t\n       {\n-\t// Possible _GLOBAL__ extension?\n-\tif (!std::strncmp(mangled_name, \"_GLOBAL__\", 9) \n-\t    && (mangled_name[9] == 'D' || mangled_name[9] == 'I')\n-\t    && mangled_name[10] == '_')\n+\t// External name?\n+\tif (mangled_name[1] == 'Z')\t\t\n \t{\n-\t  if (mangled_name[9] == 'D')\n-\t    result.assign(\"global destructors keyed to \", 28);\n-\t  else\n-\t    result.assign(\"global constructors keyed to \", 29);\n-\t  // Output the disambiguation part as-is.\n-\t  result += mangled_name + 11;\n+\t  // C++ name?\n+\t  int cnt = session_type::\n+\t      decode_encoding(result, mangled_name + 2, INT_MAX);\n+\t  if (cnt < 0 || mangled_name[cnt + 2] != 0)\n+\t    return failure(invalid_mangled_name, status);\n \t  return finish(result.data(), result.size(), buf, n, status);\n \t}\n+\telse if (mangled_name[1] == 'G')\t\n+\t{\n+\t  // Possible _GLOBAL__ extension?\n+\t  if (!std::strncmp(mangled_name, \"_GLOBAL__\", 9) \n+\t      && (mangled_name[9] == 'D' || mangled_name[9] == 'I')\n+\t      && mangled_name[10] == '_')\n+\t  {\n+\t    if (mangled_name[9] == 'D')\n+\t      result.assign(\"global destructors keyed to \", 28);\n+\t    else\n+\t      result.assign(\"global constructors keyed to \", 29);\n+\t    // Output the disambiguation part as-is.\n+\t    result += mangled_name + 11;\n+\t    return finish(result.data(), result.size(), buf, n, status);\n+\t  }\n+\t}\n       }\n-    }\n \n-    // Ambiguities are possible between extern \"C\" object names and\n-    // internal built-in type names, e.g. \"i\" may be either an object\n-    // named \"i\" or the built-in \"int\" type.  Such ambiguities should\n-    // be resolved to user names over built-in names.  Builtin types\n-    // are any single lower case character.  Any other single\n-    // character is not a mangled type so we can treat those the same\n-    // here.\n-    if (mangled_name[1] == 0)\n-      return finish(mangled_name, 1, buf, n, status);\n-\n-    // Not a built-in type or external name, try to demangle input as\n-    // NTBS mangled type name.\n-    session_type demangler_session(mangled_name, INT_MAX);\n-    if (!demangler_session.decode_type(result) \n-\t|| demangler_session.remaining_input_characters())\n-    {\n-      // Failure to demangle, assume extern \"C\" name.\n-      result = mangled_name;\t\t\n+      // Ambiguities are possible between extern \"C\" object names and\n+      // internal built-in type names, e.g. \"i\" may be either an object\n+      // named \"i\" or the built-in \"int\" type.  Such ambiguities should\n+      // be resolved to user names over built-in names.  Builtin types\n+      // are any single lower case character.  Any other single\n+      // character is not a mangled type so we can treat those the same\n+      // here.\n+      if (mangled_name[1] == 0)\n+\treturn finish(mangled_name, 1, buf, n, status);\n+\n+      // Not a built-in type or external name, try to demangle input as\n+      // NTBS mangled type name.\n+      session_type demangler_session(mangled_name, INT_MAX);\n+      if (!demangler_session.decode_type(result) \n+\t  || demangler_session.remaining_input_characters())\n+      {\n+\t// Failure to demangle, assume extern \"C\" name.\n+\tresult = mangled_name;\t\t\n+      }\n+      return finish(result.data(), result.size(), buf, n, status);\n+    } catch (std::bad_alloc&) {\n+      return failure(memory_allocation_failure, status);\n     }\n-    return finish(result.data(), result.size(), buf, n, status);\n   }\n } // namespace __cxxabiv1\n "}]}