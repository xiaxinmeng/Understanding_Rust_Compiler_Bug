{"sha": "630363b4354eb2db2a1451c4c4c97529c42f2021", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjMwMzYzYjQzNTRlYjJkYjJhMTQ1MWM0YzRjOTc1MjljNDJmMjAyMQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-05-27T18:04:58Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-05-27T18:04:58Z"}, "message": "c-common.c (c_common_init): Always use intmax_t.\n\n\t* c-common.c (c_common_init): Always use intmax_t.\ntestsuite:\n\t* gcc.dg/cpp/arith-2.c: Remove.\n\t* gcc.dg/cpp/arith-3.c: Don't set std=c99.\n\nFrom-SVN: r53936", "tree": {"sha": "1308c86098b7fe11bedea640c72b3f51e573c46f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1308c86098b7fe11bedea640c72b3f51e573c46f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/630363b4354eb2db2a1451c4c4c97529c42f2021", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/630363b4354eb2db2a1451c4c4c97529c42f2021", "html_url": "https://github.com/Rust-GCC/gccrs/commit/630363b4354eb2db2a1451c4c4c97529c42f2021", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/630363b4354eb2db2a1451c4c4c97529c42f2021/comments", "author": null, "committer": null, "parents": [{"sha": "d94cde01caf1c1de657a0f1f0b5798a3e8b9341b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d94cde01caf1c1de657a0f1f0b5798a3e8b9341b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d94cde01caf1c1de657a0f1f0b5798a3e8b9341b"}], "stats": {"total": 463, "additions": 11, "deletions": 452}, "files": [{"sha": "e8073223063a63f22ecb8dcf17bad5b19e63165a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/630363b4354eb2db2a1451c4c4c97529c42f2021/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/630363b4354eb2db2a1451c4c4c97529c42f2021/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=630363b4354eb2db2a1451c4c4c97529c42f2021", "patch": "@@ -1,3 +1,7 @@\n+2002-05-27  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* c-common.c (c_common_init): Always use intmax_t.\n+\n 2002-05-27  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* c-common.c (c_common_init): Use intmax_t for now."}, {"sha": "6086b027840c0be7d97054ede5bb2046d5b7e83c", "filename": "gcc/c-common.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/630363b4354eb2db2a1451c4c4c97529c42f2021/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/630363b4354eb2db2a1451c4c4c97529c42f2021/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=630363b4354eb2db2a1451c4c4c97529c42f2021", "patch": "@@ -4488,10 +4488,7 @@ c_common_init (filename)\n \n   /* Set up preprocessor arithmetic.  Must be done after call to\n      c_common_nodes_and_builtins for wchar_type_node to be good.  */\n-  if (flag_isoc99 || 1)\n-    options->precision = TYPE_PRECISION (intmax_type_node);\n-  else\n-    options->precision = TYPE_PRECISION (long_integer_type_node);\n+  options->precision = TYPE_PRECISION (intmax_type_node);\n   options->char_precision = TYPE_PRECISION (char_type_node);\n   options->int_precision = TYPE_PRECISION (integer_type_node);\n   options->wchar_precision = TYPE_PRECISION (wchar_type_node);"}, {"sha": "b510c04de403e5cfc5892a3d09ed843c1f7bb263", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/630363b4354eb2db2a1451c4c4c97529c42f2021/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/630363b4354eb2db2a1451c4c4c97529c42f2021/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=630363b4354eb2db2a1451c4c4c97529c42f2021", "patch": "@@ -1,3 +1,8 @@\n+2002-05-27  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* gcc.dg/cpp/arith-2.c: Remove.\n+\t* gcc.dg/cpp/arith-3.c: Don't set std=c99.\n+\n 2002-05-27  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* gcc.dg/cpp/arith-2.c, gcc.dg/cpp/arith-3.c: New tests."}, {"sha": "315585e459b2669d563ca29c00e5fa7b3ac6e436", "filename": "gcc/testsuite/gcc.dg/cpp/arith-2.c", "status": "removed", "additions": 0, "deletions": 447, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d94cde01caf1c1de657a0f1f0b5798a3e8b9341b/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Farith-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d94cde01caf1c1de657a0f1f0b5798a3e8b9341b/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Farith-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Farith-2.c?ref=d94cde01caf1c1de657a0f1f0b5798a3e8b9341b", "patch": "@@ -1,447 +0,0 @@\n-/* Preprocessor arithmetic semantic tests.  */\n-\n-/* Copyright (C) 2002 Free Software Foundation, Inc.  */\n-/* Source: Neil Booth, 26 May 2002.  */\n-\n-/* The file tests overflow warnings for, and values of, preprocessor\n-   arithmetic that are dependent on target precision.  \n-\n-   Please keep changes to arith-2.c and arith-3.c in sync.  */\n-\n-/* { dg-do preprocess } */\n-/* { dg-options \"-std=c89 -fno-show-column\" } */\n-\n-#include <limits.h>\n-\n-#define APPEND2(NUM, SUFF) NUM ## SUFF\n-#define APPEND(NUM, SUFF) APPEND2(NUM, SUFF)\n-\n-#define TARGET_UTYPE_MAX ULONG_MAX\n-\n-/* The tests in this file depend only on the macros defined in this\n-   #if block.  Note that it is no good calculating these values, as\n-   the intent is to test both the preprocessor's number parser and\n-   arithmetic.  */\n-#if TARGET_UTYPE_MAX == 65535UL\n-\n-#  define TARG_PRECISION 16\n-#  define MAX_INT  32767\n-#  define MAX_UINT 65535\n-\n-#  define TARG_MAX_HEX 0x7fff\n-#  define TARG_MAX_OCT 077777\n-#  define TARG_MAX_PLUS_1 32768L\n-#  define TARG_MAX_PLUS_1_U 32768UL\n-#  define TARG_MAX_PLUS_1_HEX 0x8000\n-#  define TARG_MAX_PLUS_1_OCT 0100000\n-#  define UTARG_MAX_HEX 0xffff\n-#  define UTARG_MAX_OCT 0177777\n-#  define UTARG_MAX_PLUS_1 65536L\n-#  define UTARG_MAX_PLUS_1_HEX 0x10000\n-#  define UTARG_MAX_PLUS_1_OCT 0200000\n-\n-#  define TARG_LOWPART_PLUS_1 256L\n-#  define TARG_LOWPART_PLUS_1_U 256UL\n-\n-  /* Division and modulo; anything that uses the high half in both\n-     dividend and divisor.  */\n-#  define LONG_UDIVISION 61234UL / 260L\n-#  define LONG_UDIVISION_ANSWER 235\n-#  define LONG_SDIVISION -15000L / 299L\n-#  define LONG_SDIVISION_ANSWER -50\n-#  define LONG_UMODULO 61234UL % 260L\n-#  define LONG_UMODULO_ANSWER 134\n-#  define LONG_SMODULO -15000L % 299L\n-#  define LONG_SMODULO_ANSWER -50\n-\n-#elif TARGET_UTYPE_MAX == 4294967295UL\n-\n-#  define TARG_PRECISION 32\n-#  define MAX_INT  2147483647\n-#  define MAX_UINT 4294967295\n-\n-#  define TARG_MAX_HEX 0x7fffffff\n-#  define TARG_MAX_OCT 017777777777\n-#  define TARG_MAX_PLUS_1 2147483648L\n-#  define TARG_MAX_PLUS_1_U 2147483648UL\n-#  define TARG_MAX_PLUS_1_HEX 0x80000000\n-#  define TARG_MAX_PLUS_1_OCT 020000000000\n-#  define UTARG_MAX_HEX 0xffffffff\n-#  define UTARG_MAX_OCT 037777777777\n-#  define UTARG_MAX_PLUS_1 4294967296L\n-#  define UTARG_MAX_PLUS_1_HEX 0x100000000\n-#  define UTARG_MAX_PLUS_1_OCT 040000000000\n-\n-#  define TARG_LOWPART_PLUS_1 65536\n-#  define TARG_LOWPART_PLUS_1_U 65536UL\n-\n-  /* Division and modulo; anything that uses the high half in both\n-     dividend and divisor.  */\n-#  define LONG_UDIVISION 268335456UL / 70000L\n-#  define LONG_UDIVISION_ANSWER 3833\n-#  define LONG_SDIVISION -368335456L / 123456L\n-#  define LONG_SDIVISION_ANSWER -2983\n-#  define LONG_UMODULO 268335456UL % 70000L\n-#  define LONG_UMODULO_ANSWER 25456\n-#  define LONG_SMODULO -368335456L % 123456L\n-#  define LONG_SMODULO_ANSWER -66208\n-\n-#elif TARGET_UTYPE_MAX == 18446744073709551615UL\n-\n-#  define TARG_PRECISION 64\n-#  define MAX_INT  9223372036854775807\n-#  define MAX_UINT 18446744073709551615\n-\n-#  define TARG_MAX_HEX 0x7fffffffffffffff\n-#  define TARG_MAX_OCT 0777777777777777777777\n-#  define TARG_MAX_PLUS_1 9223372036854775808L\n-#  define TARG_MAX_PLUS_1_U 9223372036854775808UL\n-#  define TARG_MAX_PLUS_1_HEX 0x8000000000000000\n-#  define TARG_MAX_PLUS_1_OCT 01000000000000000000000\n-#  define UTARG_MAX_HEX 0xffffffffffffffff\n-#  define UTARG_MAX_OCT 01777777777777777777777\n-#  define UTARG_MAX_PLUS_1 18446744073709551616L\n-#  define UTARG_MAX_PLUS_1_HEX 0x10000000000000000\n-#  define UTARG_MAX_PLUS_1_OCT 02000000000000000000000\n-\n-#  define TARG_LOWPART_PLUS_1 4294967296\n-#  define TARG_LOWPART_PLUS_1_U 4294967296U\n-\n-  /* Division and modulo; anything that uses the high half in both\n-     dividend and divisor.  */\n-#  define LONG_UDIVISION 235184372088832UL / 17279869184L\n-#  define LONG_UDIVISION_ANSWER 13610\n-#  define LONG_SDIVISION -234582345927345L / 12345678901L\n-#  define LONG_SDIVISION_ANSWER -19001\n-#  define LONG_UMODULO 235184372088832UL % 17279869184L\n-#  define LONG_UMODULO_ANSWER 5352494592L\n-#  define LONG_SMODULO -234582345927345L % 12345678901L\n-#  define LONG_SMODULO_ANSWER -2101129444L\n-\n-#else\n-\n-#  error Please extend the macros here so that this file tests your target\n-\n-#endif\n-\n-/* Create more macros based on the above.  */\n-#define TARG_PART_BITS (TARG_PRECISION / 2)\n-#define TARG_MIN (-TARG_MAX - 1)\n-#define TARG_MAX APPEND (MAX_INT, L)\n-#define TARG_MAX_U APPEND (MAX_INT, UL)\n-#define UTARG_MAX APPEND (MAX_UINT, L)\n-#define UTARG_MAX_U APPEND (MAX_UINT, UL)\n-\n-/* And now the tests.  */\n-\n-#if TARG_MAX\t\t\t/* { dg-bogus \"so large\" }  */\n-#endif\n-#if TARG_MAX_PLUS_1_HEX\t\t/* { dg-bogus \"so large\" }  */\n-#endif\n-#if TARG_MAX_PLUS_1_OCT\t\t/* { dg-bogus \"so large\" }  */\n-#endif\n-\n-#if UTARG_MAX\t\t\t/* { dg-warning \"so large\" }  */\n-#endif\n-#if UTARG_MAX_PLUS_1\t\t/* { dg-error \"too large\" }  */\n-#endif\n-#if UTARG_MAX_PLUS_1_HEX\t/* { dg-error \"too large\" }  */\n-#endif\n-#if UTARG_MAX_HEX\t\t/* { dg-bogus \"too large\" }  */\n-#endif\n-#if UTARG_MAX_PLUS_1_OCT\t/* { dg-error \"too large\" }  */\n-#endif\n-#if UTARG_MAX_OCT\t\t/* { dg-bogus \"too large\" }  */\n-#endif\n-\n-#if TARG_MAX < 0 || TARG_MAX_PLUS_1 < 0\t/* { dg-warning \"so large\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if UTARG_MAX_HEX < 0 || TARG_MAX_HEX < 0\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if UTARG_MAX_OCT < 0 || TARG_MAX_OCT < 0\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if -1 != UTARG_MAX_U\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-\n-\n-\n-/* Test each operator correctly warns of overflow conditions, and\n-   gives the right answer.  */\n-\n-/* Binary +.  */\n-#if TARG_MAX + 1 != TARG_MIN\t/* { dg-warning \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if -TARG_MAX + -2 != TARG_MAX\t/* { dg-warning \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if -TARG_MAX + -1 != TARG_MIN\t/* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if TARG_MAX_U + 1 != TARG_MIN\t/* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if -TARG_MAX_U + -2 != TARG_MAX /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-\n-\n-\n-/* Binary -.  */\n-#if TARG_MAX - -1 != TARG_MIN\t/* { dg-warning \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if -TARG_MAX - 2 != TARG_MAX\t/* { dg-warning \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if -TARG_MAX - 1 != TARG_MIN\t/* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if TARG_MAX_U - -1 != TARG_MIN\t/* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if -TARG_MAX_U - 2 != TARG_MAX /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-\n-\n-\n-\n-/* Binary *.  */\n-#if TARG_LOWPART_PLUS_1 * (TARG_LOWPART_PLUS_1 >> 1) != TARG_MIN /* { dg-warning \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if (TARG_LOWPART_PLUS_1 >> 1) * TARG_LOWPART_PLUS_1 != TARG_MIN /* { dg-warning \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if (TARG_LOWPART_PLUS_1 << 1) * (TARG_LOWPART_PLUS_1 + 1) != (TARG_LOWPART_PLUS_1 << 1) /* { dg-warning \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if TARG_MAX * 1 != TARG_MAX\t/* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if (TARG_MAX >> 1) * 2\t!= TARG_MAX - 1 /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if (TARG_LOWPART_PLUS_1_U + 61) * (TARG_LOWPART_PLUS_1 << 1) != 61 * (TARG_LOWPART_PLUS_1 << 1) /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if (TARG_LOWPART_PLUS_1 >> 1) * TARG_LOWPART_PLUS_1_U != TARG_MIN /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if 1 * TARG_MIN != TARG_MIN\t/* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-\n-\n-\n-/* Binary /.  */\n-#if TARG_MIN / -1 != TARG_MIN\t/* { dg-warning \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if TARG_MIN / 1 != TARG_MIN\t/* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if -TARG_MAX_PLUS_1_U / -1 != 0 /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if -5 / (2 - 2) /* { dg-error \"division by zero\" } */\n-#endif\n-\n-#if LONG_UDIVISION != LONG_UDIVISION_ANSWER\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if LONG_SDIVISION != LONG_SDIVISION_ANSWER\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-/* Binary %.  Cannot overflow.  */\n-#if -5 % (2 - 2) /* { dg-error \"division by zero\" } */\n-#endif\n-\n-#if TARG_MIN % 1 /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if LONG_UMODULO != LONG_UMODULO_ANSWER\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if LONG_SMODULO != LONG_SMODULO_ANSWER\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if 234 % -1U != 234\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if TARG_MIN % -1U != TARG_MIN\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-/* Binary << and Binary >>, the latter cannot overflow.  */\n-#if -1 >> 3 != -1     /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if TARG_MAX >> 3 != TARG_MAX / 8     /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if 0 << 256 != 0  /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if 1 << 256 != 0 /* { dg-warning \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if 1U << 256 != 0  /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if TARG_MAX << 1 != -2  /* { dg-warning \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if TARG_MAX_U << 1 != -2  /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if TARG_LOWPART_PLUS_1 << TARG_PART_BITS != 0  /* { dg-warning \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if TARG_LOWPART_PLUS_1 << (TARG_PART_BITS - 1) != TARG_MIN  /* { dg-warning \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if TARG_LOWPART_PLUS_1_U << (TARG_PART_BITS - 1) != TARG_MIN  /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if TARG_LOWPART_PLUS_1 << (TARG_PART_BITS - 2) != (TARG_MAX_PLUS_1_U >> 1)  /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-/* Test how the sign bit is handled.  */\n-#if (TARG_MIN << 1) != 0    /* { dg-warning \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if (TARG_MAX_PLUS_1_U << 1) != 0    /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if (TARG_MIN >> 1) != 3U << (TARG_PRECISION - 2)    /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if (TARG_MAX_PLUS_1_U >> 1) != 1 << (TARG_PRECISION - 2)    /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-\n-\n-/* Unary -.  It can overflow in just one case.  */\n-#if -TARG_MIN != TARG_MIN  /* { dg-warning \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if - -TARG_MAX != TARG_MAX   /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-\n-\n-\n-/* Unary +, ~, and !.  They cannot overflow.  */\n-#if +TARG_MAX != TARG_MAX  /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if !TARG_MAX + !TARG_MIN != 0   /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if ~TARG_MAX , ~TARG_MIN != TARG_MAX  /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-\n-\n-\n-/* Bitwise &, ^, |.  They cannot overflow.  */\n-#if (TARG_MAX & -1), (TARG_MIN & -1) != TARG_MIN  /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if TARG_MAX | -1, (TARG_MIN | -1) != -1  /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if TARG_MAX ^ -1, (TARG_MIN ^ -1) != TARG_MAX  /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-\n-\n-\n-/* Comparison operators.  They cannot overflow.  */\n-#if -1 <= TARG_MAX, (TARG_MIN <= 1) != 1  /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if -1 >= TARG_MAX, (TARG_MIN >= 1) != 0  /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if -1 < TARG_MAX, (TARG_MIN < 1) != 1  /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if -1 > TARG_MAX, (TARG_MIN > 1) != 0  /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-\n-\n-\n-/* Comma and ? : operators.  They cannot overflow.  */\n-#if -1, TARG_MAX, TARG_MIN != TARG_MIN  /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif\n-\n-#if -1 ? TARG_MAX: TARG_MAX, 0 ? 1: TARG_MIN != TARG_MIN /* { dg-bogus \"overflow\" } */\n-# error\t\t/* { dg-bogus \"error\" }  */\n-#endif"}, {"sha": "53d182192167bac74086246a145fbb7dc3df2ee1", "filename": "gcc/testsuite/gcc.dg/cpp/arith-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/630363b4354eb2db2a1451c4c4c97529c42f2021/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Farith-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/630363b4354eb2db2a1451c4c4c97529c42f2021/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Farith-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Farith-3.c?ref=630363b4354eb2db2a1451c4c4c97529c42f2021", "patch": "@@ -9,7 +9,7 @@\n    Please keep changes to arith-2.c and arith-3.c in sync.  */\n \n /* { dg-do preprocess } */\n-/* { dg-options \"-std=c99 -fno-show-column\" } */\n+/* { dg-options \"-fno-show-column\" } */\n \n #include <limits.h>\n "}]}