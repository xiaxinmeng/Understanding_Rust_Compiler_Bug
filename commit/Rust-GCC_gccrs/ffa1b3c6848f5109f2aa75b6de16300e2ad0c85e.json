{"sha": "ffa1b3c6848f5109f2aa75b6de16300e2ad0c85e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZhMWIzYzY4NDhmNTEwOWYyYWE3NWI2ZGUxNjMwMGUyYWQwYzg1ZQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2007-01-27T02:52:37Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2007-01-27T02:52:37Z"}, "message": "i386.c (ix86_swap_binary_operands_p): New helper function to simplify/factorize operand order canonicalization.\n\n\n\t* config/i386/i386.c (ix86_swap_binary_operands_p): New helper\n\tfunction to simplify/factorize operand order canonicalization.\n\t(ix86_fixup_binary_operands): Reorganize using the above function.\n\t(ix86_binary_operator_ok): Likewise.\n\nFrom-SVN: r121227", "tree": {"sha": "f551c5b4fadc45b0d9ed918bff8cceeb8d2737eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f551c5b4fadc45b0d9ed918bff8cceeb8d2737eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffa1b3c6848f5109f2aa75b6de16300e2ad0c85e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffa1b3c6848f5109f2aa75b6de16300e2ad0c85e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffa1b3c6848f5109f2aa75b6de16300e2ad0c85e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffa1b3c6848f5109f2aa75b6de16300e2ad0c85e/comments", "author": null, "committer": null, "parents": [{"sha": "18763871089cf3b077b73d704dbaef827eb8046b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18763871089cf3b077b73d704dbaef827eb8046b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18763871089cf3b077b73d704dbaef827eb8046b"}], "stats": {"total": 144, "additions": 94, "deletions": 50}, "files": [{"sha": "2b169ff328aaa75b86d2a616e598776011f52a0f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffa1b3c6848f5109f2aa75b6de16300e2ad0c85e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffa1b3c6848f5109f2aa75b6de16300e2ad0c85e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ffa1b3c6848f5109f2aa75b6de16300e2ad0c85e", "patch": "@@ -1,3 +1,10 @@\n+2007-01-26  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* config/i386/i386.c (ix86_swap_binary_operands_p): New helper\n+\tfunction to simplify/factorize operand order canonicalization.\n+\t(ix86_fixup_binary_operands): Reorganize using the above function.\n+\t(ix86_binary_operator_ok): Likewise.\n+\n 2007-01-27  Jakub Jelinek  <jakub@redhat.com>\n \n \t* genattrtab.c (struct attr_value_list, insn_code_values): Move to"}, {"sha": "35b03a9cc48ae32c8f6a91414615d7889f29e9d0", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 87, "deletions": 50, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffa1b3c6848f5109f2aa75b6de16300e2ad0c85e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffa1b3c6848f5109f2aa75b6de16300e2ad0c85e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ffa1b3c6848f5109f2aa75b6de16300e2ad0c85e", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines used for code generation on IA-32.\n    Copyright (C) 1988, 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n-   2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -9384,6 +9384,43 @@ ix86_expand_push (enum machine_mode mode, rtx x)\n   emit_move_insn (tmp, x);\n }\n \n+/* Helper function of ix86_fixup_binary_operands to canonicalize\n+   operand order.  Returns true if the operands should be swapped.  */\n+   \n+static bool\n+ix86_swap_binary_operands_p (enum rtx_code code, enum machine_mode mode,\n+\t\t\t     rtx operands[])\n+{\n+  rtx dst = operands[0];\n+  rtx src1 = operands[1];\n+  rtx src2 = operands[2];\n+\n+  /* If the operation is not commutative, we can't do anything.  */\n+  if (GET_RTX_CLASS (code) != RTX_COMM_ARITH)\n+    return false;\n+\n+  /* Highest priority is that src1 should match dst.  */\n+  if (rtx_equal_p (dst, src1))\n+    return false;\n+  if (rtx_equal_p (dst, src2))\n+    return true;\n+\n+  /* Next highest priority is that immediate constants come second.  */\n+  if (immediate_operand (src2, mode))\n+    return false;\n+  if (immediate_operand (src1, mode))\n+    return true;\n+\n+  /* Lowest priority is that memory references should come second.  */\n+  if (MEM_P (src2))\n+    return false;\n+  if (MEM_P (src1))\n+    return true;\n+\n+  return false;\n+}\n+\n+\n /* Fix up OPERANDS to satisfy ix86_binary_operator_ok.  Return the\n    destination to use for the operation.  If different from the true\n    destination in operands[0], a copy operation will be required.  */\n@@ -9392,55 +9429,46 @@ rtx\n ix86_fixup_binary_operands (enum rtx_code code, enum machine_mode mode,\n \t\t\t    rtx operands[])\n {\n-  int matching_memory;\n-  rtx src1, src2, dst;\n+  rtx dst = operands[0];\n+  rtx src1 = operands[1];\n+  rtx src2 = operands[2];\n \n-  dst = operands[0];\n-  src1 = operands[1];\n-  src2 = operands[2];\n-\n-  /* Recognize <var1> = <value> <op> <var1> for commutative operators */\n-  if (GET_RTX_CLASS (code) == RTX_COMM_ARITH\n-      && (rtx_equal_p (dst, src2)\n-\t  || immediate_operand (src1, mode)))\n+  /* Canonicalize operand order.  */\n+  if (ix86_swap_binary_operands_p (code, mode, operands))\n     {\n       rtx temp = src1;\n       src1 = src2;\n       src2 = temp;\n     }\n \n-  /* If the destination is memory, and we do not have matching source\n-     operands, do things in registers.  */\n-  matching_memory = 0;\n-  if (MEM_P (dst))\n-    {\n-      if (rtx_equal_p (dst, src1))\n-\tmatching_memory = 1;\n-      else if (GET_RTX_CLASS (code) == RTX_COMM_ARITH\n-\t       && rtx_equal_p (dst, src2))\n-\tmatching_memory = 2;\n-      else\n-\tdst = gen_reg_rtx (mode);\n-    }\n-\n   /* Both source operands cannot be in memory.  */\n   if (MEM_P (src1) && MEM_P (src2))\n     {\n-      if (matching_memory != 2)\n-\tsrc2 = force_reg (mode, src2);\n+      /* Optimization: Only read from memory once.  */\n+      if (rtx_equal_p (src1, src2))\n+\t{\n+\t  src2 = force_reg (mode, src2);\n+\t  src1 = src2;\n+\t}\n       else\n-\tsrc1 = force_reg (mode, src1);\n+\tsrc2 = force_reg (mode, src2);\n     }\n \n-  /* If the operation is not commutable, source 1 cannot be a constant\n-     or non-matching memory.  */\n-  if ((CONSTANT_P (src1)\n-       || (!matching_memory && MEM_P (src1)))\n-      && GET_RTX_CLASS (code) != RTX_COMM_ARITH)\n+  /* If the destination is memory, and we do not have matching source\n+     operands, do things in registers.  */\n+  if (MEM_P (dst) && !rtx_equal_p (dst, src1))\n+    dst = gen_reg_rtx (mode);\n+\n+  /* Source 1 cannot be a constant.  */\n+  if (CONSTANT_P (src1))\n     src1 = force_reg (mode, src1);\n \n-  src1 = operands[1] = src1;\n-  src2 = operands[2] = src2;\n+  /* Source 1 cannot be a non-matching memory.  */\n+  if (MEM_P (src1) && !rtx_equal_p (dst, src1))\n+    src1 = force_reg (mode, src1);\n+\n+  operands[1] = src1;\n+  operands[2] = src2;\n   return dst;\n }\n \n@@ -9494,28 +9522,37 @@ ix86_expand_binary_operator (enum rtx_code code, enum machine_mode mode,\n    appropriate constraints.  */\n \n int\n-ix86_binary_operator_ok (enum rtx_code code,\n-\t\t\t enum machine_mode mode ATTRIBUTE_UNUSED,\n+ix86_binary_operator_ok (enum rtx_code code, enum machine_mode mode,\n \t\t\t rtx operands[3])\n {\n+  rtx dst = operands[0];\n+  rtx src1 = operands[1];\n+  rtx src2 = operands[2];\n+\n   /* Both source operands cannot be in memory.  */\n-  if (MEM_P (operands[1]) && MEM_P (operands[2]))\n-    return 0;\n-  /* If the operation is not commutable, source 1 cannot be a constant.  */\n-  if (CONSTANT_P (operands[1]) && GET_RTX_CLASS (code) != RTX_COMM_ARITH)\n+  if (MEM_P (src1) && MEM_P (src2))\n     return 0;\n+\n+  /* Canonicalize operand order for commutative operators.  */\n+  if (ix86_swap_binary_operands_p (code, mode, operands))\n+    {\n+      rtx temp = src1;\n+      src1 = src2;\n+      src2 = temp;\n+    }\n+\n   /* If the destination is memory, we must have a matching source operand.  */\n-  if (MEM_P (operands[0])\n-      && ! (rtx_equal_p (operands[0], operands[1])\n-\t    || (GET_RTX_CLASS (code) == RTX_COMM_ARITH\n-\t\t&& rtx_equal_p (operands[0], operands[2]))))\n+  if (MEM_P (dst) && !rtx_equal_p (dst, src1))\n+      return 0;\n+\n+  /* Source 1 cannot be a constant.  */\n+  if (CONSTANT_P (src1))\n     return 0;\n-  /* If the operation is not commutable and the source 1 is memory, we must\n-     have a matching destination.  */\n-  if (MEM_P (operands[1])\n-      && GET_RTX_CLASS (code) != RTX_COMM_ARITH\n-      && ! rtx_equal_p (operands[0], operands[1]))\n+\n+  /* Source 1 cannot be a non-matching memory.  */\n+  if (MEM_P (src1) && !rtx_equal_p (dst, src1))\n     return 0;\n+\n   return 1;\n }\n "}]}