{"sha": "6b35ae12ce9371bf0ae7ad202c4393cdd77fad55", "node_id": "C_kwDOANBUbNoAKDZiMzVhZTEyY2U5MzcxYmYwYWU3YWQyMDJjNDM5M2NkZDc3ZmFkNTU", "commit": {"author": {"name": "Joel Phillips", "email": "simplytheother@gmail.com", "date": "2022-10-21T11:34:11Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:03Z"}, "message": "gccrs: Add Rust front-end base AST data structures\n\nThis is a full C++11 class hierarchy representing the Rust AST. We do not\nallow dynamic_cast and so the main mechanism to work with the AST is by\nusing the visitor interface. Slowly we are adding TREE_CODE style node\ntypes to the AST which will allow for more ways to work with the AST but\nfor now this is it.\n\nSee: https://doc.rust-lang.org/reference/items.html\n\n\tgcc/rust/\n\t* ast/rust-ast-full-decls.h: New.\n\t* ast/rust-ast-full-test.cc: New.\n\t* ast/rust-ast-full.h: New.\n\t* ast/rust-ast.h: New.\n\t* operator.h: New.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n\nSigned-off-by: Joel Phillips <simplytheother@gmail.com>", "tree": {"sha": "81f4cf5d0069ed5b725352e9508637a719bfa7be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81f4cf5d0069ed5b725352e9508637a719bfa7be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b35ae12ce9371bf0ae7ad202c4393cdd77fad55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b35ae12ce9371bf0ae7ad202c4393cdd77fad55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b35ae12ce9371bf0ae7ad202c4393cdd77fad55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b35ae12ce9371bf0ae7ad202c4393cdd77fad55/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc4171edb3c35690c67a928cbb431aa702bdbe79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc4171edb3c35690c67a928cbb431aa702bdbe79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc4171edb3c35690c67a928cbb431aa702bdbe79"}], "stats": {"total": 8193, "additions": 8193, "deletions": 0}, "files": [{"sha": "47f332193cc20f0acaa47cbb9511772b92d59c38", "filename": "gcc/rust/ast/rust-ast-full-decls.h", "status": "added", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b35ae12ce9371bf0ae7ad202c4393cdd77fad55/gcc%2Frust%2Fast%2Frust-ast-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b35ae12ce9371bf0ae7ad202c4393cdd77fad55/gcc%2Frust%2Fast%2Frust-ast-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-decls.h?ref=6b35ae12ce9371bf0ae7ad202c4393cdd77fad55", "patch": "@@ -0,0 +1,273 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_FULL_DECLS_H\n+#define RUST_AST_FULL_DECLS_H\n+\n+// Forward declarations for all AST classes. Useful for not having to include\n+// all definitions.\n+\n+namespace Rust {\n+namespace AST {\n+// rust-ast.h\n+class AttrInput;\n+class TokenTree;\n+class MacroMatch;\n+class Token;\n+struct Literal;\n+class DelimTokenTree;\n+class PathSegment;\n+class SimplePathSegment;\n+class SimplePath;\n+struct Attribute;\n+class MetaItemInner;\n+class AttrInputMetaItemContainer;\n+class MetaItem;\n+class Stmt;\n+class Item;\n+class Expr;\n+class ExprWithoutBlock;\n+class IdentifierExpr;\n+class Pattern;\n+class Type;\n+class TypeNoBounds;\n+class TypeParamBound;\n+class Lifetime;\n+class GenericParam;\n+class LifetimeParam;\n+class ConstGenericParam;\n+class MacroItem;\n+class TraitItem;\n+class InherentImplItem;\n+class TraitImplItem;\n+struct Crate;\n+class PathExpr;\n+\n+// rust-path.h\n+class PathIdentSegment;\n+struct GenericArgsBinding;\n+struct GenericArgs;\n+class PathExprSegment;\n+class PathPattern;\n+class PathInExpression;\n+class TypePathSegment;\n+class TypePathSegmentGeneric;\n+struct TypePathFunction;\n+class TypePathSegmentFunction;\n+class TypePath;\n+struct QualifiedPathType;\n+class QualifiedPathInExpression;\n+class QualifiedPathInType;\n+\n+// rust-expr.h\n+class ExprWithBlock;\n+class LiteralExpr;\n+class AttrInputLiteral;\n+class MetaItemLitExpr;\n+class MetaItemPathLit;\n+class OperatorExpr;\n+class BorrowExpr;\n+class DereferenceExpr;\n+class ErrorPropagationExpr;\n+class NegationExpr;\n+class ArithmeticOrLogicalExpr;\n+class ComparisonExpr;\n+class LazyBooleanExpr;\n+class TypeCastExpr;\n+class AssignmentExpr;\n+class CompoundAssignmentExpr;\n+class GroupedExpr;\n+class ArrayElems;\n+class ArrayElemsValues;\n+class ArrayElemsCopied;\n+class ArrayExpr;\n+class ArrayIndexExpr;\n+class TupleExpr;\n+class TupleIndexExpr;\n+class StructExpr;\n+class StructExprStruct;\n+struct StructBase;\n+class StructExprField;\n+class StructExprFieldIdentifier;\n+class StructExprFieldWithVal;\n+class StructExprFieldIdentifierValue;\n+class StructExprFieldIndexValue;\n+class StructExprStructFields;\n+class StructExprStructBase;\n+class CallExpr;\n+class MethodCallExpr;\n+class FieldAccessExpr;\n+struct ClosureParam;\n+class ClosureExpr;\n+class ClosureExprInner;\n+class BlockExpr;\n+class ClosureExprInnerTyped;\n+class ContinueExpr;\n+class BreakExpr;\n+class RangeExpr;\n+class RangeFromToExpr;\n+class RangeFromExpr;\n+class RangeToExpr;\n+class RangeFullExpr;\n+class RangeFromToInclExpr;\n+class RangeToInclExpr;\n+class ReturnExpr;\n+class UnsafeBlockExpr;\n+class LoopLabel;\n+class BaseLoopExpr;\n+class LoopExpr;\n+class WhileLoopExpr;\n+class WhileLetLoopExpr;\n+class ForLoopExpr;\n+class IfExpr;\n+class IfExprConseqElse;\n+class IfExprConseqIf;\n+class IfLetExpr;\n+class IfExprConseqIfLet;\n+class IfLetExprConseqElse;\n+class IfLetExprConseqIf;\n+class IfLetExprConseqIfLet;\n+struct MatchArm;\n+// class MatchCase;\n+// class MatchCaseBlockExpr;\n+// class MatchCaseExpr;\n+struct MatchCase;\n+class MatchExpr;\n+class AwaitExpr;\n+class AsyncBlockExpr;\n+\n+// rust-stmt.h\n+class EmptyStmt;\n+class LetStmt;\n+class ExprStmt;\n+class ExprStmtWithoutBlock;\n+class ExprStmtWithBlock;\n+\n+// rust-item.h\n+class TypeParam;\n+class WhereClauseItem;\n+class LifetimeWhereClauseItem;\n+class TypeBoundWhereClauseItem;\n+struct WhereClause;\n+struct SelfParam;\n+struct FunctionQualifiers;\n+struct FunctionParam;\n+struct Visibility;\n+class Method;\n+class VisItem;\n+class Module;\n+class ExternCrate;\n+class UseTree;\n+class UseTreeGlob;\n+class UseTreeList;\n+class UseTreeRebind;\n+class UseDeclaration;\n+class Function;\n+class TypeAlias;\n+class Struct;\n+struct StructField;\n+class StructStruct;\n+struct TupleField;\n+class TupleStruct;\n+class EnumItem;\n+class EnumItemTuple;\n+class EnumItemStruct;\n+class EnumItemDiscriminant;\n+class Enum;\n+class Union;\n+class ConstantItem;\n+class StaticItem;\n+struct TraitFunctionDecl;\n+class TraitItemFunc;\n+struct TraitMethodDecl;\n+class TraitItemMethod;\n+class TraitItemConst;\n+class TraitItemType;\n+class Trait;\n+class Impl;\n+class InherentImpl;\n+class TraitImpl;\n+class ExternalItem;\n+class ExternalStaticItem;\n+struct NamedFunctionParam;\n+class ExternalFunctionItem;\n+class ExternBlock;\n+\n+// rust-macro.h\n+class MacroMatchFragment;\n+class MacroMatchRepetition;\n+class MacroMatcher;\n+struct MacroTranscriber;\n+struct MacroRule;\n+class MacroRulesDefinition;\n+class MacroInvocation;\n+class MetaItemPath;\n+class MetaItemSeq;\n+class MetaWord;\n+class MetaNameValueStr;\n+class MetaListPaths;\n+class MetaListNameValueStr;\n+\n+// rust-pattern.h\n+class LiteralPattern;\n+class IdentifierPattern;\n+class WildcardPattern;\n+class RangePatternBound;\n+class RangePatternBoundLiteral;\n+class RangePatternBoundPath;\n+class RangePatternBoundQualPath;\n+class RangePattern;\n+class ReferencePattern;\n+struct StructPatternEtc;\n+class StructPatternField;\n+class StructPatternFieldTuplePat;\n+class StructPatternFieldIdentPat;\n+class StructPatternFieldIdent;\n+struct StructPatternElements;\n+class StructPattern;\n+class TupleStructItems;\n+class TupleStructItemsNoRange;\n+class TupleStructItemsRange;\n+class TupleStructPattern;\n+class TuplePatternItems;\n+class TuplePatternItemsMultiple;\n+class TuplePatternItemsRanged;\n+class TuplePattern;\n+class GroupedPattern;\n+class SlicePattern;\n+\n+// rust-type.h\n+class TraitBound;\n+class ImplTraitType;\n+class TraitObjectType;\n+class ParenthesisedType;\n+class ImplTraitTypeOneBound;\n+class TraitObjectTypeOneBound;\n+class TupleType;\n+class NeverType;\n+class RawPointerType;\n+class ReferenceType;\n+class ArrayType;\n+class SliceType;\n+class InferredType;\n+struct MaybeNamedParam;\n+class BareFunctionType;\n+} // namespace AST\n+} // namespace Rust\n+\n+#endif"}, {"sha": "1e8a93d462fde0246a83dd055eb142e4d208d8aa", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "added", "additions": 5810, "deletions": 0, "changes": 5810, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b35ae12ce9371bf0ae7ad202c4393cdd77fad55/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b35ae12ce9371bf0ae7ad202c4393cdd77fad55/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=6b35ae12ce9371bf0ae7ad202c4393cdd77fad55"}, {"sha": "5ab136c61b6e1b21b16e51b83b8f24d353f9e4af", "filename": "gcc/rust/ast/rust-ast-full.h", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b35ae12ce9371bf0ae7ad202c4393cdd77fad55/gcc%2Frust%2Fast%2Frust-ast-full.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b35ae12ce9371bf0ae7ad202c4393cdd77fad55/gcc%2Frust%2Fast%2Frust-ast-full.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full.h?ref=6b35ae12ce9371bf0ae7ad202c4393cdd77fad55", "patch": "@@ -0,0 +1,31 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_FULL_H\n+#define RUST_AST_FULL_H\n+// Use as a fast way of including all aspects of the AST (i.e. all headers)\n+#include \"rust-ast.h\"\n+#include \"rust-expr.h\"\n+#include \"rust-item.h\"\n+#include \"rust-path.h\"\n+#include \"rust-pattern.h\"\n+#include \"rust-stmt.h\"\n+#include \"rust-type.h\"\n+#include \"rust-macro.h\"\n+\n+#endif"}, {"sha": "461a2460f8f5f5566c2c87d89250930d9e027717", "filename": "gcc/rust/ast/rust-ast.h", "status": "added", "additions": 2007, "deletions": 0, "changes": 2007, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b35ae12ce9371bf0ae7ad202c4393cdd77fad55/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b35ae12ce9371bf0ae7ad202c4393cdd77fad55/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=6b35ae12ce9371bf0ae7ad202c4393cdd77fad55", "patch": "@@ -0,0 +1,2007 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_BASE_H\n+#define RUST_AST_BASE_H\n+// Base for AST used in gccrs, basically required by all specific ast things\n+\n+#include \"rust-system.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-token.h\"\n+#include \"rust-location.h\"\n+\n+namespace Rust {\n+// TODO: remove typedefs and make actual types for these\n+typedef std::string Identifier;\n+typedef int TupleIndex;\n+struct Session;\n+\n+namespace AST {\n+// foward decl: ast visitor\n+class ASTVisitor;\n+using AttrVec = std::vector<Attribute>;\n+\n+// The available kinds of AST Nodes\n+enum Kind\n+{\n+  UNKNOWN,\n+  MACRO_RULES_DEFINITION,\n+  MACRO_INVOCATION,\n+};\n+\n+// Abstract base class for all AST elements\n+class Node\n+{\n+public:\n+  /**\n+   * Get the kind of Node this is. This is used to differentiate various AST\n+   * elements with very little overhead when extracting the derived type through\n+   * static casting is not necessary.\n+   */\n+  // FIXME: Mark this as `= 0` in the future to make sure every node implements\n+  // it\n+  virtual Kind get_ast_kind () const { return Kind::UNKNOWN; }\n+};\n+\n+// Delimiter types - used in macros and whatever.\n+enum DelimType\n+{\n+  PARENS,\n+  SQUARE,\n+  CURLY\n+};\n+\n+// forward decl for use in token tree method\n+class Token;\n+\n+// A tree of tokens (or a single token) - abstract base class\n+class TokenTree\n+{\n+public:\n+  virtual ~TokenTree () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TokenTree> clone_token_tree () const\n+  {\n+    return std::unique_ptr<TokenTree> (clone_token_tree_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  /* Converts token tree to a flat token stream. Tokens must be pointer to avoid\n+   * mutual dependency with Token. */\n+  virtual std::vector<std::unique_ptr<Token> > to_token_stream () const = 0;\n+\n+protected:\n+  // pure virtual clone implementation\n+  virtual TokenTree *clone_token_tree_impl () const = 0;\n+};\n+\n+// Abstract base class for a macro match\n+class MacroMatch\n+{\n+public:\n+  enum MacroMatchType\n+  {\n+    Fragment,\n+    Repetition,\n+    Matcher,\n+    Tok\n+  };\n+\n+  virtual ~MacroMatch () {}\n+\n+  virtual std::string as_string () const = 0;\n+  virtual Location get_match_locus () const = 0;\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<MacroMatch> clone_macro_match () const\n+  {\n+    return std::unique_ptr<MacroMatch> (clone_macro_match_impl ());\n+  }\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual MacroMatchType get_macro_match_type () const = 0;\n+\n+protected:\n+  // pure virtual clone implementation\n+  virtual MacroMatch *clone_macro_match_impl () const = 0;\n+};\n+\n+// A token is a kind of token tree (except delimiter tokens)\n+class Token : public TokenTree, public MacroMatch\n+{\n+  // A token is a kind of token tree (except delimiter tokens)\n+  // A token is a kind of MacroMatch (except $ and delimiter tokens)\n+#if 0\n+  // TODO: improve member variables - current ones are the same as lexer token\n+  // Token kind.\n+  TokenId token_id;\n+  // Token location.\n+  Location locus;\n+  // Associated text (if any) of token.\n+  std::string str;\n+  // Token type hint (if any).\n+  PrimitiveCoreType type_hint;\n+#endif\n+\n+  const_TokenPtr tok_ref;\n+\n+  /* new idea: wrapper around const_TokenPtr used for heterogeneuous storage in\n+   * token trees. rather than convert back and forth when parsing macros, just\n+   * wrap it. */\n+\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Token> clone_token () const\n+  {\n+    return std::unique_ptr<Token> (clone_token_impl ());\n+  }\n+\n+#if 0\n+  /* constructor from general text - avoid using if lexer const_TokenPtr is\n+   * available */\n+  Token (TokenId token_id, Location locus, std::string str,\n+\t PrimitiveCoreType type_hint)\n+    : token_id (token_id), locus (locus), str (std::move (str)),\n+      type_hint (type_hint)\n+  {}\n+#endif\n+  // not doable with new implementation - will have to make a const_TokenPtr\n+\n+  // Constructor from lexer const_TokenPtr\n+#if 0\n+  /* TODO: find workaround for std::string being nullptr - probably have to\n+   * introduce new method in lexer Token, or maybe make conversion method\n+   * there */\n+  Token (const_TokenPtr lexer_token_ptr)\n+    : token_id (lexer_token_ptr->get_id ()),\n+      locus (lexer_token_ptr->get_locus ()), str (\"\"),\n+      type_hint (lexer_token_ptr->get_type_hint ())\n+  {\n+    // FIXME: change to \"should have str\" later?\n+    if (lexer_token_ptr->has_str ())\n+      {\n+\tstr = lexer_token_ptr->get_str ();\n+\n+\t// DEBUG\n+\trust_debug (\"ast token created with str '%s'\", str.c_str ());\n+      }\n+    else\n+      {\n+\t// FIXME: is this returning correct thing?\n+\tstr = lexer_token_ptr->get_token_description ();\n+\n+\t// DEBUG\n+\trust_debug (\"ast token created with string '%s'\", str.c_str ());\n+      }\n+\n+    // DEBUG\n+    if (lexer_token_ptr->should_have_str () && !lexer_token_ptr->has_str ())\n+      {\n+\trust_debug (\n+\t\t \"BAD: for token '%s', should have string but does not!\",\n+\t\t lexer_token_ptr->get_token_description ());\n+      }\n+  }\n+#endif\n+  Token (const_TokenPtr lexer_tok_ptr) : tok_ref (std::move (lexer_tok_ptr)) {}\n+\n+  bool is_string_lit () const\n+  {\n+    switch (get_id ())\n+      {\n+      case STRING_LITERAL:\n+      case BYTE_STRING_LITERAL:\n+\treturn true;\n+      default:\n+\treturn false;\n+      }\n+  }\n+\n+  std::string as_string () const override;\n+  Location get_match_locus () const override { return tok_ref->get_locus (); };\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // Return copy of itself but in token stream form.\n+  std::vector<std::unique_ptr<Token> > to_token_stream () const override;\n+\n+  TokenId get_id () const { return tok_ref->get_id (); }\n+  const std::string &get_str () const { return tok_ref->get_str (); }\n+\n+  Location get_locus () const { return tok_ref->get_locus (); }\n+\n+  PrimitiveCoreType get_type_hint () const { return tok_ref->get_type_hint (); }\n+\n+  // Get a new token pointer copy.\n+  const_TokenPtr get_tok_ptr () const { return tok_ref; }\n+\n+  MacroMatchType get_macro_match_type () const override\n+  {\n+    return MacroMatchType::Tok;\n+  }\n+\n+protected:\n+  // No virtual for now as not polymorphic but can be in future\n+  /*virtual*/ Token *clone_token_impl () const { return new Token (*this); }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  Token *clone_token_tree_impl () const final override\n+  {\n+    return clone_token_impl ();\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  Token *clone_macro_match_impl () const final override\n+  {\n+    return clone_token_impl ();\n+  }\n+};\n+\n+// A literal - value with a type. Used in LiteralExpr and LiteralPattern.\n+struct Literal\n+{\n+public:\n+  enum LitType\n+  {\n+    CHAR,\n+    STRING,\n+    BYTE,\n+    BYTE_STRING,\n+    INT,\n+    FLOAT,\n+    BOOL,\n+    ERROR\n+  };\n+\n+private:\n+  /* TODO: maybe make subclasses of each type of literal with their typed values\n+   * (or generics) */\n+  std::string value_as_string;\n+  LitType type;\n+  PrimitiveCoreType type_hint;\n+\n+public:\n+  std::string as_string () const { return value_as_string; }\n+\n+  LitType get_lit_type () const { return type; }\n+\n+  PrimitiveCoreType get_type_hint () const { return type_hint; }\n+\n+  Literal (std::string value_as_string, LitType type,\n+\t   PrimitiveCoreType type_hint)\n+    : value_as_string (std::move (value_as_string)), type (type),\n+      type_hint (type_hint)\n+  {}\n+\n+  static Literal create_error ()\n+  {\n+    return Literal (\"\", ERROR, PrimitiveCoreType::CORETYPE_UNKNOWN);\n+  }\n+\n+  // Returns whether literal is in an invalid state.\n+  bool is_error () const { return type == ERROR; }\n+};\n+\n+/* Forward decl - definition moved to rust-expr.h as it requires LiteralExpr to\n+ * be defined */\n+class AttrInputLiteral;\n+\n+/* TODO: move applicable stuff into here or just don't include it because\n+ * nothing uses it A segment of a path (maybe) */\n+class PathSegment\n+{\n+public:\n+  virtual ~PathSegment () {}\n+\n+  virtual std::string as_string () const = 0;\n+\n+  // TODO: add visitor here?\n+};\n+\n+// A segment of a simple path without generic or type arguments\n+class SimplePathSegment : public PathSegment\n+{\n+  std::string segment_name;\n+  Location locus;\n+  NodeId node_id;\n+\n+  // only allow identifiers, \"super\", \"self\", \"crate\", or \"$crate\"\n+public:\n+  // TODO: put checks in constructor to enforce this rule?\n+  SimplePathSegment (std::string segment_name, Location locus)\n+    : segment_name (std::move (segment_name)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n+\n+  /* Returns whether simple path segment is in an invalid state (currently, if\n+   * empty). */\n+  bool is_error () const { return segment_name.empty (); }\n+\n+  // Creates an error SimplePathSegment\n+  static SimplePathSegment create_error ()\n+  {\n+    return SimplePathSegment (std::string (\"\"), Location ());\n+  }\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+  NodeId get_node_id () const { return node_id; }\n+  const std::string &get_segment_name () const { return segment_name; }\n+  bool is_super_path_seg () const\n+  {\n+    return as_string ().compare (\"super\") == 0;\n+  }\n+  bool is_crate_path_seg () const\n+  {\n+    return as_string ().compare (\"crate\") == 0;\n+  }\n+  bool is_lower_self () const { return as_string ().compare (\"self\") == 0; }\n+  bool is_big_self () const { return as_string ().compare (\"Self\") == 0; }\n+};\n+\n+// A simple path without generic or type arguments\n+class SimplePath\n+{\n+  bool has_opening_scope_resolution;\n+  std::vector<SimplePathSegment> segments;\n+  Location locus;\n+  NodeId node_id;\n+\n+public:\n+  // Constructor\n+  SimplePath (std::vector<SimplePathSegment> path_segments,\n+\t      bool has_opening_scope_resolution = false,\n+\t      Location locus = Location ())\n+    : has_opening_scope_resolution (has_opening_scope_resolution),\n+      segments (std::move (path_segments)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n+\n+  // Creates an empty SimplePath.\n+  static SimplePath create_empty ()\n+  {\n+    return SimplePath (std::vector<SimplePathSegment> ());\n+  }\n+\n+  // Returns whether the SimplePath is empty, i.e. has path segments.\n+  bool is_empty () const { return segments.empty (); }\n+\n+  std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+  NodeId get_node_id () const { return node_id; }\n+\n+  // does this need visitor if not polymorphic? probably not\n+\n+  // path-to-string comparison operator\n+  bool operator== (const std::string &rhs) const\n+  {\n+    return !has_opening_scope_resolution && segments.size () == 1\n+\t   && segments[0].as_string () == rhs;\n+  }\n+\n+  /* Creates a single-segment SimplePath from a string. This will not check to\n+   * ensure that this is a valid identifier in path, so be careful. Also, this\n+   * will have no location data.\n+   * TODO have checks? */\n+  static SimplePath from_str (std::string str, Location locus)\n+  {\n+    std::vector<AST::SimplePathSegment> single_segments\n+      = {AST::SimplePathSegment (std::move (str), locus)};\n+    return SimplePath (std::move (single_segments));\n+  }\n+\n+  const std::vector<SimplePathSegment> &get_segments () const\n+  {\n+    return segments;\n+  }\n+\n+  std::vector<SimplePathSegment> &get_segments () { return segments; }\n+};\n+\n+// path-to-string inverse comparison operator\n+inline bool\n+operator!= (const SimplePath &lhs, const std::string &rhs)\n+{\n+  return !(lhs == rhs);\n+}\n+\n+// forward decl for Attribute\n+class AttrInput;\n+\n+// aka Attr\n+// Attribute AST representation\n+struct Attribute\n+{\n+private:\n+  SimplePath path;\n+\n+  // bool has_attr_input;\n+  std::unique_ptr<AttrInput> attr_input;\n+\n+  Location locus;\n+\n+  // TODO: maybe a variable storing whether attr input is parsed or not\n+\n+public:\n+  // Returns whether Attribute has AttrInput\n+  bool has_attr_input () const { return attr_input != nullptr; }\n+\n+  // Constructor has pointer AttrInput for polymorphism reasons\n+  Attribute (SimplePath path, std::unique_ptr<AttrInput> input,\n+\t     Location locus = Location ())\n+    : path (std::move (path)), attr_input (std::move (input)), locus (locus)\n+  {}\n+\n+  // default destructor\n+  ~Attribute () = default;\n+\n+  // no point in being defined inline as requires virtual call anyway\n+  Attribute (const Attribute &other);\n+\n+  // no point in being defined inline as requires virtual call anyway\n+  Attribute &operator= (const Attribute &other);\n+\n+  // default move semantics\n+  Attribute (Attribute &&other) = default;\n+  Attribute &operator= (Attribute &&other) = default;\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Attribute> clone_attribute () const\n+  {\n+    return std::unique_ptr<Attribute> (clone_attribute_impl ());\n+  }\n+\n+  // Creates an empty attribute (which is invalid)\n+  static Attribute create_empty ()\n+  {\n+    return Attribute (SimplePath::create_empty (), nullptr);\n+  }\n+\n+  // Returns whether the attribute is considered an \"empty\" attribute.\n+  bool is_empty () const { return attr_input == nullptr && path.is_empty (); }\n+\n+  Location get_locus () const { return locus; }\n+\n+  AttrInput &get_attr_input () const { return *attr_input; }\n+\n+  /* e.g.:\n+      #![crate_type = \"lib\"]\n+      #[test]\n+      #[cfg(target_os = \"linux\")]\n+      #[allow(non_camel_case_types)]\n+      #![allow(unused_variables)]\n+  */\n+\n+  // Full built-in attribute list:\n+  /*   cfg\n+   *   cfg_attr\n+   *   test\n+   *   ignore\n+   *   should_panic\n+   *   derive\n+   *   macro_export\n+   *   macro_use\n+   *   proc_macro\n+   *   proc_macro_derive\n+   *   proc_macro_attribute\n+   *   allow\n+   *   warn\n+   *   deny\n+   *   forbid\n+   *   deprecated\n+   *   must_use\n+   *   link\n+   *   link_name\n+   *   no_link\n+   *   repr\n+   *   crate_type\n+   *   no_main\n+   *   export_name\n+   *   link_section\n+   *   no_mangle\n+   *   used\n+   *   crate_name\n+   *   inline\n+   *   cold\n+   *   no_builtins\n+   *   target_feature\n+   *   doc\n+   *   no_std\n+   *   no_implicit_prelude\n+   *   path\n+   *   recursion_limit\n+   *   type_length_limit\n+   *   panic_handler\n+   *   global_allocator\n+   *   windows_subsystem\n+   *   feature     */\n+\n+  std::string as_string () const;\n+\n+  // no visitor pattern as not currently polymorphic\n+\n+  const SimplePath &get_path () const { return path; }\n+  SimplePath &get_path () { return path; }\n+\n+  // Call to parse attribute body to meta item syntax.\n+  void parse_attr_to_meta_item ();\n+\n+  /* Determines whether cfg predicate is true and item with attribute should not\n+   * be stripped. Attribute body must already be parsed to meta item. */\n+  bool check_cfg_predicate (const Session &session) const;\n+\n+  // Returns whether body has been parsed to meta item form or not.\n+  bool is_parsed_to_meta_item () const;\n+\n+  /* Returns any attributes generated from cfg_attr attributes. Attribute body\n+   * must already be parsed to meta item. */\n+  std::vector<Attribute> separate_cfg_attrs () const;\n+\n+protected:\n+  // not virtual as currently no subclasses of Attribute, but could be in future\n+  /*virtual*/ Attribute *clone_attribute_impl () const\n+  {\n+    return new Attribute (*this);\n+  }\n+};\n+\n+// Attribute body - abstract base class\n+class AttrInput\n+{\n+public:\n+  enum AttrInputType\n+  {\n+    LITERAL,\n+    META_ITEM,\n+    TOKEN_TREE,\n+  };\n+\n+  virtual ~AttrInput () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<AttrInput> clone_attr_input () const\n+  {\n+    return std::unique_ptr<AttrInput> (clone_attr_input_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual bool check_cfg_predicate (const Session &session) const = 0;\n+\n+  // Parse attribute input to meta item, if possible\n+  virtual AttrInput *parse_to_meta_item () const { return nullptr; }\n+\n+  virtual std::vector<Attribute> separate_cfg_attrs () const { return {}; }\n+\n+  // Returns whether attr input has been parsed to meta item syntax.\n+  virtual bool is_meta_item () const = 0;\n+\n+  virtual AttrInputType get_attr_input_type () const = 0;\n+\n+protected:\n+  // pure virtual clone implementation\n+  virtual AttrInput *clone_attr_input_impl () const = 0;\n+};\n+\n+// Forward decl - defined in rust-macro.h\n+class MetaNameValueStr;\n+\n+// abstract base meta item inner class\n+class MetaItemInner\n+{\n+protected:\n+  // pure virtual as MetaItemInner\n+  virtual MetaItemInner *clone_meta_item_inner_impl () const = 0;\n+\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<MetaItemInner> clone_meta_item_inner () const\n+  {\n+    return std::unique_ptr<MetaItemInner> (clone_meta_item_inner_impl ());\n+  }\n+\n+  virtual ~MetaItemInner ();\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  /* HACK: used to simplify parsing - creates a copy of that type, or returns\n+   * null */\n+  virtual std::unique_ptr<MetaNameValueStr> to_meta_name_value_str () const;\n+\n+  // HACK: used to simplify parsing - same thing\n+  virtual SimplePath to_path_item () const\n+  {\n+    return SimplePath::create_empty ();\n+  }\n+\n+  virtual Attribute to_attribute () const { return Attribute::create_empty (); }\n+\n+  virtual bool check_cfg_predicate (const Session &session) const = 0;\n+\n+  virtual bool is_key_value_pair () const { return false; }\n+};\n+\n+// Container used to store MetaItems as AttrInput (bridge-ish kinda thing)\n+class AttrInputMetaItemContainer : public AttrInput\n+{\n+  std::vector<std::unique_ptr<MetaItemInner> > items;\n+\n+public:\n+  AttrInputMetaItemContainer (\n+    std::vector<std::unique_ptr<MetaItemInner> > items)\n+    : items (std::move (items))\n+  {}\n+\n+  // copy constructor with vector clone\n+  AttrInputMetaItemContainer (const AttrInputMetaItemContainer &other)\n+  {\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_meta_item_inner ());\n+  }\n+\n+  // copy assignment operator with vector clone\n+  AttrInputMetaItemContainer &\n+  operator= (const AttrInputMetaItemContainer &other)\n+  {\n+    AttrInput::operator= (other);\n+\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_meta_item_inner ());\n+\n+    return *this;\n+  }\n+\n+  // default move constructors\n+  AttrInputMetaItemContainer (AttrInputMetaItemContainer &&other) = default;\n+  AttrInputMetaItemContainer &operator= (AttrInputMetaItemContainer &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  bool check_cfg_predicate (const Session &session) const override;\n+\n+  AttrInputType get_attr_input_type () const final override\n+  {\n+    return AttrInput::AttrInputType::META_ITEM;\n+  }\n+\n+  // Clones this object.\n+  std::unique_ptr<AttrInputMetaItemContainer>\n+  clone_attr_input_meta_item_container () const\n+  {\n+    return std::unique_ptr<AttrInputMetaItemContainer> (\n+      clone_attr_input_meta_item_container_impl ());\n+  }\n+\n+  std::vector<Attribute> separate_cfg_attrs () const override;\n+\n+  bool is_meta_item () const override { return true; }\n+\n+  // TODO: this mutable getter seems dodgy\n+  std::vector<std::unique_ptr<MetaItemInner> > &get_items () { return items; }\n+  const std::vector<std::unique_ptr<MetaItemInner> > &get_items () const\n+  {\n+    return items;\n+  }\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  AttrInputMetaItemContainer *clone_attr_input_impl () const final override\n+  {\n+    return clone_attr_input_meta_item_container_impl ();\n+  }\n+\n+  AttrInputMetaItemContainer *clone_attr_input_meta_item_container_impl () const\n+  {\n+    return new AttrInputMetaItemContainer (*this);\n+  }\n+};\n+\n+// A token tree with delimiters\n+class DelimTokenTree : public TokenTree, public AttrInput\n+{\n+  DelimType delim_type;\n+  std::vector<std::unique_ptr<TokenTree> > token_trees;\n+  Location locus;\n+\n+protected:\n+  DelimTokenTree *clone_delim_tok_tree_impl () const\n+  {\n+    return new DelimTokenTree (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning a DelimTokenTree\n+   * object */\n+  DelimTokenTree *clone_attr_input_impl () const final override\n+  {\n+    return clone_delim_tok_tree_impl ();\n+  }\n+\n+  /* Use covariance to implement clone function as returning a DelimTokenTree\n+   * object */\n+  DelimTokenTree *clone_token_tree_impl () const final override\n+  {\n+    return clone_delim_tok_tree_impl ();\n+  }\n+\n+public:\n+  DelimTokenTree (DelimType delim_type,\n+\t\t  std::vector<std::unique_ptr<TokenTree> > token_trees\n+\t\t  = std::vector<std::unique_ptr<TokenTree> > (),\n+\t\t  Location locus = Location ())\n+    : delim_type (delim_type), token_trees (std::move (token_trees)),\n+      locus (locus)\n+  {}\n+\n+  // Copy constructor with vector clone\n+  DelimTokenTree (DelimTokenTree const &other)\n+    : delim_type (other.delim_type), locus (other.locus)\n+  {\n+    token_trees.reserve (other.token_trees.size ());\n+    for (const auto &e : other.token_trees)\n+      token_trees.push_back (e->clone_token_tree ());\n+  }\n+\n+  // overloaded assignment operator with vector clone\n+  DelimTokenTree &operator= (DelimTokenTree const &other)\n+  {\n+    delim_type = other.delim_type;\n+    locus = other.locus;\n+\n+    token_trees.reserve (other.token_trees.size ());\n+    for (const auto &e : other.token_trees)\n+      token_trees.push_back (e->clone_token_tree ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  DelimTokenTree (DelimTokenTree &&other) = default;\n+  DelimTokenTree &operator= (DelimTokenTree &&other) = default;\n+\n+  static DelimTokenTree create_empty () { return DelimTokenTree (PARENS); }\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  bool check_cfg_predicate (const Session &) const override\n+  {\n+    // this should never be called - should be converted first\n+    rust_assert (false);\n+    return false;\n+  }\n+\n+  AttrInputMetaItemContainer *parse_to_meta_item () const override;\n+\n+  std::vector<std::unique_ptr<Token> > to_token_stream () const override;\n+\n+  std::unique_ptr<DelimTokenTree> clone_delim_token_tree () const\n+  {\n+    return std::unique_ptr<DelimTokenTree> (clone_delim_tok_tree_impl ());\n+  }\n+\n+  bool is_meta_item () const override { return false; }\n+\n+  AttrInputType get_attr_input_type () const final override\n+  {\n+    return AttrInput::AttrInputType::TOKEN_TREE;\n+  }\n+\n+  std::vector<std::unique_ptr<TokenTree> > &get_token_trees ()\n+  {\n+    return token_trees;\n+  }\n+\n+  DelimType get_delim_type () const { return delim_type; }\n+};\n+\n+/* Forward decl - definition moved to rust-expr.h as it requires LiteralExpr to\n+ * be defined */\n+class AttrInputLiteral;\n+\n+// abstract base meta item class\n+class MetaItem : public MetaItemInner\n+{\n+};\n+\n+// Forward decl - defined in rust-expr.h\n+class MetaItemLitExpr;\n+\n+// Forward decl - defined in rust-expr.h\n+class MetaItemPathLit;\n+\n+// Forward decl - defined in rust-macro.h\n+class MetaItemPath;\n+\n+// Forward decl - defined in rust-macro.h\n+class MetaItemSeq;\n+\n+// Forward decl - defined in rust-macro.h\n+class MetaWord;\n+\n+// Forward decl - defined in rust-macro.h\n+class MetaListPaths;\n+\n+// Forward decl - defined in rust-macro.h\n+class MetaListNameValueStr;\n+\n+/* Base statement abstract class. Note that most \"statements\" are not allowed in\n+ * top-level module scope - only a subclass of statements called \"items\" are. */\n+class Stmt : public Node\n+{\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Stmt> clone_stmt () const\n+  {\n+    return std::unique_ptr<Stmt> (clone_stmt_impl ());\n+  }\n+\n+  virtual ~Stmt () {}\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual Location get_locus () const = 0;\n+\n+  virtual void mark_for_strip () = 0;\n+  virtual bool is_marked_for_strip () const = 0;\n+  NodeId get_node_id () const { return node_id; }\n+\n+  virtual bool is_item () const = 0;\n+\n+protected:\n+  Stmt () : node_id (Analysis::Mappings::get ()->get_next_node_id ()) {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual Stmt *clone_stmt_impl () const = 0;\n+\n+  NodeId node_id;\n+};\n+\n+// Rust \"item\" AST node (declaration of top-level/module-level allowed stuff)\n+class Item : public Stmt\n+{\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Item> clone_item () const\n+  {\n+    return std::unique_ptr<Item> (clone_item_impl ());\n+  }\n+\n+  /* Adds crate names to the vector passed by reference, if it can\n+   * (polymorphism). TODO: remove, unused. */\n+  virtual void\n+  add_crate_name (std::vector<std::string> &names ATTRIBUTE_UNUSED) const\n+  {}\n+\n+  // FIXME: ARTHUR: Is it okay to have removed that final? Is it *required*\n+  // behavior that we have items that can also be expressions?\n+  bool is_item () const override { return true; }\n+\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual Item *clone_item_impl () const = 0;\n+\n+  /* Save having to specify two clone methods in derived classes by making\n+   * statement clone return item clone. Hopefully won't affect performance too\n+   * much. */\n+  Item *clone_stmt_impl () const final override { return clone_item_impl (); }\n+};\n+\n+// forward decl of ExprWithoutBlock\n+class ExprWithoutBlock;\n+\n+// Base expression AST node - abstract\n+class Expr : public Node\n+{\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Expr> clone_expr () const\n+  {\n+    return std::unique_ptr<Expr> (clone_expr_impl ());\n+  }\n+\n+  /* TODO: public methods that could be useful:\n+   *  - get_type() - returns type of expression. set_type() may also be useful\n+   * for some?\n+   *  - evaluate() - evaluates expression if constant? can_evaluate()? */\n+\n+  /* HACK: downcasting without dynamic_cast (if possible) via polymorphism -\n+   * overrided in subclasses of ExprWithoutBlock */\n+  virtual ExprWithoutBlock *as_expr_without_block () const { return nullptr; }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual ~Expr () {}\n+\n+  virtual Location get_locus () const = 0;\n+\n+  // HACK: strictly not needed, but faster than full downcast clone\n+  virtual bool is_expr_without_block () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual void mark_for_strip () = 0;\n+  virtual bool is_marked_for_strip () const = 0;\n+\n+  virtual NodeId get_node_id () const { return node_id; }\n+\n+  virtual void set_node_id (NodeId id) { node_id = id; }\n+\n+protected:\n+  // Constructor\n+  Expr () : node_id (Analysis::Mappings::get ()->get_next_node_id ()) {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual Expr *clone_expr_impl () const = 0;\n+\n+  // TODO: think of less hacky way to implement this kind of thing\n+  // Sets outer attributes.\n+  virtual void set_outer_attrs (std::vector<Attribute>) = 0;\n+\n+  NodeId node_id;\n+};\n+\n+// AST node for an expression without an accompanying block - abstract\n+class ExprWithoutBlock : public Expr\n+{\n+protected:\n+  // pure virtual clone implementation\n+  virtual ExprWithoutBlock *clone_expr_without_block_impl () const = 0;\n+\n+  /* Save having to specify two clone methods in derived classes by making expr\n+   * clone return exprwithoutblock clone. Hopefully won't affect performance too\n+   * much. */\n+  ExprWithoutBlock *clone_expr_impl () const final override\n+  {\n+    return clone_expr_without_block_impl ();\n+  }\n+\n+  bool is_expr_without_block () const final override { return true; };\n+\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<ExprWithoutBlock> clone_expr_without_block () const\n+  {\n+    return std::unique_ptr<ExprWithoutBlock> (clone_expr_without_block_impl ());\n+  }\n+\n+  /* downcasting hack from expr to use pratt parsing with\n+   * parse_expr_without_block */\n+  ExprWithoutBlock *as_expr_without_block () const final override\n+  {\n+    return clone_expr_without_block_impl ();\n+  }\n+\n+  virtual ExprWithoutBlock *to_stmt () const { return clone_expr_impl (); }\n+};\n+\n+/* HACK: IdentifierExpr, delete when figure out identifier vs expr problem in\n+ * Pratt parser */\n+/* Alternatively, identifiers could just be represented as single-segment paths\n+ */\n+class IdentifierExpr : public ExprWithoutBlock\n+{\n+  std::vector<Attribute> outer_attrs;\n+  Identifier ident;\n+  Location locus;\n+\n+public:\n+  IdentifierExpr (Identifier ident, std::vector<Attribute> outer_attrs,\n+\t\t  Location locus)\n+    : outer_attrs (std::move (outer_attrs)), ident (std::move (ident)),\n+      locus (locus)\n+  {}\n+\n+  std::string as_string () const override { return ident; }\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  Identifier get_ident () const { return ident; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // Clones this object.\n+  std::unique_ptr<IdentifierExpr> clone_identifier_expr () const\n+  {\n+    return std::unique_ptr<IdentifierExpr> (clone_identifier_expr_impl ());\n+  }\n+\n+  // \"Error state\" if ident is empty, so base stripping on this.\n+  void mark_for_strip () override { ident = {}; }\n+  bool is_marked_for_strip () const override { return ident.empty (); }\n+\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n+\n+protected:\n+  // Clone method implementation\n+  IdentifierExpr *clone_expr_without_block_impl () const final override\n+  {\n+    return clone_identifier_expr_impl ();\n+  }\n+\n+  IdentifierExpr *clone_identifier_expr_impl () const\n+  {\n+    return new IdentifierExpr (*this);\n+  }\n+};\n+\n+// Pattern base AST node\n+class Pattern\n+{\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Pattern> clone_pattern () const\n+  {\n+    return std::unique_ptr<Pattern> (clone_pattern_impl ());\n+  }\n+\n+  // possible virtual methods: is_refutable()\n+\n+  virtual ~Pattern () {}\n+\n+  virtual std::string as_string () const = 0;\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  // as only one kind of pattern can be stripped, have default of nothing\n+  virtual void mark_for_strip () {}\n+  virtual bool is_marked_for_strip () const { return false; }\n+\n+  virtual Location get_locus () const = 0;\n+  virtual NodeId get_pattern_node_id () const = 0;\n+\n+protected:\n+  // Clone pattern implementation as pure virtual method\n+  virtual Pattern *clone_pattern_impl () const = 0;\n+};\n+\n+// forward decl for Type\n+class TraitBound;\n+\n+// Base class for types as represented in AST - abstract\n+class Type : public Node\n+{\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Type> clone_type () const\n+  {\n+    return std::unique_ptr<Type> (clone_type_impl ());\n+  }\n+\n+  // virtual destructor\n+  virtual ~Type () {}\n+\n+  virtual std::string as_string () const = 0;\n+\n+  /* HACK: convert to trait bound. Virtual method overriden by classes that\n+   * enable this. */\n+  virtual TraitBound *to_trait_bound (bool) const { return nullptr; }\n+  /* as pointer, shouldn't require definition beforehand, only forward\n+   * declaration. */\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  // as only two kinds of types can be stripped, have default of nothing\n+  virtual void mark_for_strip () {}\n+  virtual bool is_marked_for_strip () const { return false; }\n+\n+  virtual Location get_locus () const = 0;\n+\n+  NodeId get_node_id () const { return node_id; }\n+\n+protected:\n+  Type () : node_id (Analysis::Mappings::get ()->get_next_node_id ()) {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual Type *clone_type_impl () const = 0;\n+\n+  NodeId node_id;\n+};\n+\n+// A type without parentheses? - abstract\n+class TypeNoBounds : public Type\n+{\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TypeNoBounds> clone_type_no_bounds () const\n+  {\n+    return std::unique_ptr<TypeNoBounds> (clone_type_no_bounds_impl ());\n+  }\n+\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual TypeNoBounds *clone_type_no_bounds_impl () const = 0;\n+\n+  /* Save having to specify two clone methods in derived classes by making type\n+   * clone return typenobounds clone. Hopefully won't affect performance too\n+   * much. */\n+  TypeNoBounds *clone_type_impl () const final override\n+  {\n+    return clone_type_no_bounds_impl ();\n+  }\n+\n+  TypeNoBounds () : Type () {}\n+};\n+\n+/* Abstract base class representing a type param bound - Lifetime and TraitBound\n+ * extends it */\n+class TypeParamBound\n+{\n+public:\n+  virtual ~TypeParamBound () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TypeParamBound> clone_type_param_bound () const\n+  {\n+    return std::unique_ptr<TypeParamBound> (clone_type_param_bound_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  NodeId get_node_id () const { return node_id; }\n+\n+  virtual Location get_locus () const = 0;\n+\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual TypeParamBound *clone_type_param_bound_impl () const = 0;\n+\n+  TypeParamBound (NodeId node_id) : node_id (node_id) {}\n+\n+  NodeId node_id;\n+};\n+\n+// Represents a lifetime (and is also a kind of type param bound)\n+class Lifetime : public TypeParamBound\n+{\n+public:\n+  enum LifetimeType\n+  {\n+    NAMED,   // corresponds to LIFETIME_OR_LABEL\n+    STATIC,  // corresponds to 'static\n+    WILDCARD // corresponds to '_\n+  };\n+\n+private:\n+  LifetimeType lifetime_type;\n+  std::string lifetime_name;\n+  Location locus;\n+  NodeId node_id;\n+\n+public:\n+  // Constructor\n+  Lifetime (LifetimeType type, std::string name = std::string (),\n+\t    Location locus = Location ())\n+    : TypeParamBound (Analysis::Mappings::get ()->get_next_node_id ()),\n+      lifetime_type (type), lifetime_name (std::move (name)), locus (locus)\n+  {}\n+\n+  Lifetime (NodeId id, LifetimeType type, std::string name = std::string (),\n+\t    Location locus = Location ())\n+    : TypeParamBound (id), lifetime_type (type),\n+      lifetime_name (std::move (name)), locus (locus)\n+  {}\n+\n+  // Creates an \"error\" lifetime.\n+  static Lifetime error () { return Lifetime (NAMED, \"\"); }\n+\n+  // Returns true if the lifetime is in an error state.\n+  bool is_error () const\n+  {\n+    return lifetime_type == NAMED && lifetime_name.empty ();\n+  }\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  LifetimeType get_lifetime_type () { return lifetime_type; }\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  std::string get_lifetime_name () const { return lifetime_name; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  Lifetime *clone_type_param_bound_impl () const override\n+  {\n+    return new Lifetime (node_id, lifetime_type, lifetime_name, locus);\n+  }\n+};\n+\n+/* Base generic parameter in AST. Abstract - can be represented by a Lifetime or\n+ * Type param */\n+class GenericParam\n+{\n+public:\n+  enum class Kind\n+  {\n+    Lifetime,\n+    Type,\n+    Const,\n+  };\n+\n+  virtual ~GenericParam () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<GenericParam> clone_generic_param () const\n+  {\n+    return std::unique_ptr<GenericParam> (clone_generic_param_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual Location get_locus () const = 0;\n+\n+  virtual Kind get_kind () const = 0;\n+\n+  NodeId get_node_id () { return node_id; }\n+\n+protected:\n+  GenericParam () : node_id (Analysis::Mappings::get ()->get_next_node_id ()) {}\n+  GenericParam (NodeId node_id) : node_id (node_id) {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual GenericParam *clone_generic_param_impl () const = 0;\n+\n+  NodeId node_id;\n+};\n+\n+// A lifetime generic parameter (as opposed to a type generic parameter)\n+class LifetimeParam : public GenericParam\n+{\n+  Lifetime lifetime;\n+  std::vector<Lifetime> lifetime_bounds;\n+  Attribute outer_attr;\n+  Location locus;\n+\n+public:\n+  Lifetime get_lifetime () const { return lifetime; }\n+\n+  // Returns whether the lifetime param has any lifetime bounds.\n+  bool has_lifetime_bounds () const { return !lifetime_bounds.empty (); }\n+\n+  // Returns whether the lifetime param has an outer attribute.\n+  bool has_outer_attribute () const { return !outer_attr.is_empty (); }\n+\n+  // Creates an error state lifetime param.\n+  static LifetimeParam create_error ()\n+  {\n+    return LifetimeParam (Lifetime::error (), {}, Attribute::create_empty (),\n+\t\t\t  Location ());\n+  }\n+\n+  // Returns whether the lifetime param is in an error state.\n+  bool is_error () const { return lifetime.is_error (); }\n+\n+  // Constructor\n+  LifetimeParam (Lifetime lifetime, std::vector<Lifetime> lifetime_bounds,\n+\t\t Attribute outer_attr, Location locus)\n+    : lifetime (std::move (lifetime)),\n+      lifetime_bounds (std::move (lifetime_bounds)),\n+      outer_attr (std::move (outer_attr)), locus (locus)\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  Kind get_kind () const override final { return Kind::Lifetime; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  LifetimeParam *clone_generic_param_impl () const override\n+  {\n+    return new LifetimeParam (*this);\n+  }\n+};\n+\n+// A macro item AST node - abstract base class\n+class MacroItem : public Item\n+{\n+};\n+\n+// Item used in trait declarations - abstract base class\n+class TraitItem\n+{\n+protected:\n+  TraitItem () : node_id (Analysis::Mappings::get ()->get_next_node_id ()) {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual TraitItem *clone_trait_item_impl () const = 0;\n+\n+  NodeId node_id;\n+\n+public:\n+  virtual ~TraitItem () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TraitItem> clone_trait_item () const\n+  {\n+    return std::unique_ptr<TraitItem> (clone_trait_item_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual void mark_for_strip () = 0;\n+  virtual bool is_marked_for_strip () const = 0;\n+\n+  NodeId get_node_id () const { return node_id; }\n+};\n+\n+/* Abstract base class for items used within an inherent impl block (the impl\n+ * name {} one) */\n+class InherentImplItem\n+{\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual InherentImplItem *clone_inherent_impl_item_impl () const = 0;\n+\n+public:\n+  virtual ~InherentImplItem () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<InherentImplItem> clone_inherent_impl_item () const\n+  {\n+    return std::unique_ptr<InherentImplItem> (clone_inherent_impl_item_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual void mark_for_strip () = 0;\n+  virtual bool is_marked_for_strip () const = 0;\n+\n+  virtual Location get_locus () const = 0;\n+};\n+\n+// Abstract base class for items used in a trait impl\n+class TraitImplItem\n+{\n+protected:\n+  virtual TraitImplItem *clone_trait_impl_item_impl () const = 0;\n+\n+public:\n+  virtual ~TraitImplItem (){};\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TraitImplItem> clone_trait_impl_item () const\n+  {\n+    return std::unique_ptr<TraitImplItem> (clone_trait_impl_item_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual void mark_for_strip () = 0;\n+  virtual bool is_marked_for_strip () const = 0;\n+};\n+\n+// Abstract base class for an item used inside an extern block\n+class ExternalItem\n+{\n+public:\n+  ExternalItem () : node_id (Analysis::Mappings::get ()->get_next_node_id ()) {}\n+\n+  virtual ~ExternalItem () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<ExternalItem> clone_external_item () const\n+  {\n+    return std::unique_ptr<ExternalItem> (clone_external_item_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual void mark_for_strip () = 0;\n+  virtual bool is_marked_for_strip () const = 0;\n+\n+  NodeId get_node_id () const { return node_id; }\n+\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual ExternalItem *clone_external_item_impl () const = 0;\n+\n+  NodeId node_id;\n+};\n+\n+/* Data structure to store the data used in macro invocations and macro\n+ * invocations with semicolons. */\n+struct MacroInvocData\n+{\n+private:\n+  SimplePath path;\n+  DelimTokenTree token_tree;\n+\n+  // One way of parsing the macro. Probably not applicable for all macros.\n+  std::vector<std::unique_ptr<MetaItemInner> > parsed_items;\n+  bool parsed_to_meta_item = false;\n+\n+public:\n+  std::string as_string () const;\n+\n+  MacroInvocData (SimplePath path, DelimTokenTree token_tree)\n+    : path (std::move (path)), token_tree (std::move (token_tree))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  MacroInvocData (const MacroInvocData &other)\n+    : path (other.path), token_tree (other.token_tree),\n+      parsed_to_meta_item (other.parsed_to_meta_item)\n+  {\n+    parsed_items.reserve (other.parsed_items.size ());\n+    for (const auto &e : other.parsed_items)\n+      parsed_items.push_back (e->clone_meta_item_inner ());\n+  }\n+\n+  // Copy assignment operator with vector clone\n+  MacroInvocData &operator= (const MacroInvocData &other)\n+  {\n+    path = other.path;\n+    token_tree = other.token_tree;\n+    parsed_to_meta_item = other.parsed_to_meta_item;\n+\n+    parsed_items.reserve (other.parsed_items.size ());\n+    for (const auto &e : other.parsed_items)\n+      parsed_items.push_back (e->clone_meta_item_inner ());\n+\n+    return *this;\n+  }\n+\n+  // Move constructors\n+  MacroInvocData (MacroInvocData &&other) = default;\n+  MacroInvocData &operator= (MacroInvocData &&other) = default;\n+\n+  // Invalid if path is empty, so base stripping on that.\n+  void mark_for_strip () { path = SimplePath::create_empty (); }\n+  bool is_marked_for_strip () const { return path.is_empty (); }\n+\n+  // Returns whether the macro has been parsed already.\n+  bool is_parsed () const { return parsed_to_meta_item; }\n+  // TODO: update on other ways of parsing it\n+\n+  // TODO: this mutable getter seems kinda dodgy\n+  DelimTokenTree &get_delim_tok_tree () { return token_tree; }\n+  const DelimTokenTree &get_delim_tok_tree () const { return token_tree; }\n+\n+  // TODO: this mutable getter seems kinda dodgy\n+  SimplePath &get_path () { return path; }\n+  const SimplePath &get_path () const { return path; }\n+\n+  void\n+  set_meta_item_output (std::vector<std::unique_ptr<MetaItemInner> > new_items)\n+  {\n+    parsed_items = std::move (new_items);\n+  }\n+  // TODO: mutable getter seems kinda dodgy\n+  std::vector<std::unique_ptr<MetaItemInner> > &get_meta_items ()\n+  {\n+    return parsed_items;\n+  }\n+  const std::vector<std::unique_ptr<MetaItemInner> > &get_meta_items () const\n+  {\n+    return parsed_items;\n+  }\n+};\n+\n+class SingleASTNode\n+{\n+public:\n+  enum NodeType\n+  {\n+    EXPRESSION,\n+    ITEM,\n+    STMT,\n+    EXTERN,\n+    TRAIT,\n+    IMPL,\n+    TRAIT_IMPL,\n+    TYPE,\n+  };\n+\n+private:\n+  NodeType kind;\n+\n+  // FIXME make this a union\n+  std::unique_ptr<Expr> expr;\n+  std::unique_ptr<Item> item;\n+  std::unique_ptr<Stmt> stmt;\n+  std::unique_ptr<ExternalItem> external_item;\n+  std::unique_ptr<TraitItem> trait_item;\n+  std::unique_ptr<InherentImplItem> impl_item;\n+  std::unique_ptr<TraitImplItem> trait_impl_item;\n+  std::unique_ptr<Type> type;\n+\n+public:\n+  SingleASTNode (std::unique_ptr<Expr> expr)\n+    : kind (EXPRESSION), expr (std::move (expr))\n+  {}\n+\n+  SingleASTNode (std::unique_ptr<Item> item)\n+    : kind (ITEM), item (std::move (item))\n+  {}\n+\n+  SingleASTNode (std::unique_ptr<Stmt> stmt)\n+    : kind (STMT), stmt (std::move (stmt))\n+  {}\n+\n+  SingleASTNode (std::unique_ptr<ExternalItem> item)\n+    : kind (EXTERN), external_item (std::move (item))\n+  {}\n+\n+  SingleASTNode (std::unique_ptr<TraitItem> item)\n+    : kind (TRAIT), trait_item (std::move (item))\n+  {}\n+\n+  SingleASTNode (std::unique_ptr<InherentImplItem> item)\n+    : kind (IMPL), impl_item (std::move (item))\n+  {}\n+\n+  SingleASTNode (std::unique_ptr<TraitImplItem> trait_impl_item)\n+    : kind (TRAIT_IMPL), trait_impl_item (std::move (trait_impl_item))\n+  {}\n+\n+  SingleASTNode (std::unique_ptr<Type> type)\n+    : kind (TYPE), type (std::move (type))\n+  {}\n+\n+  SingleASTNode (SingleASTNode const &other)\n+  {\n+    kind = other.kind;\n+    switch (kind)\n+      {\n+      case EXPRESSION:\n+\texpr = other.expr->clone_expr ();\n+\tbreak;\n+\n+      case ITEM:\n+\titem = other.item->clone_item ();\n+\tbreak;\n+\n+      case STMT:\n+\tstmt = other.stmt->clone_stmt ();\n+\tbreak;\n+\n+      case EXTERN:\n+\texternal_item = other.external_item->clone_external_item ();\n+\tbreak;\n+\n+      case TRAIT:\n+\ttrait_item = other.trait_item->clone_trait_item ();\n+\tbreak;\n+\n+      case IMPL:\n+\timpl_item = other.impl_item->clone_inherent_impl_item ();\n+\tbreak;\n+\n+      case TRAIT_IMPL:\n+\ttrait_impl_item = other.trait_impl_item->clone_trait_impl_item ();\n+\tbreak;\n+\n+      case TYPE:\n+\ttype = other.type->clone_type ();\n+\tbreak;\n+      }\n+  }\n+\n+  SingleASTNode operator= (SingleASTNode const &other)\n+  {\n+    kind = other.kind;\n+    switch (kind)\n+      {\n+      case EXPRESSION:\n+\texpr = other.expr->clone_expr ();\n+\tbreak;\n+\n+      case ITEM:\n+\titem = other.item->clone_item ();\n+\tbreak;\n+\n+      case STMT:\n+\tstmt = other.stmt->clone_stmt ();\n+\tbreak;\n+\n+      case EXTERN:\n+\texternal_item = other.external_item->clone_external_item ();\n+\tbreak;\n+\n+      case TRAIT:\n+\ttrait_item = other.trait_item->clone_trait_item ();\n+\tbreak;\n+\n+      case IMPL:\n+\timpl_item = other.impl_item->clone_inherent_impl_item ();\n+\tbreak;\n+\n+      case TRAIT_IMPL:\n+\ttrait_impl_item = other.trait_impl_item->clone_trait_impl_item ();\n+\tbreak;\n+\n+      case TYPE:\n+\ttype = other.type->clone_type ();\n+\tbreak;\n+      }\n+    return *this;\n+  }\n+\n+  SingleASTNode (SingleASTNode &&other) = default;\n+  SingleASTNode &operator= (SingleASTNode &&other) = default;\n+\n+  NodeType get_kind () const { return kind; }\n+\n+  std::unique_ptr<Expr> &get_expr ()\n+  {\n+    rust_assert (kind == EXPRESSION);\n+    return expr;\n+  }\n+\n+  std::unique_ptr<Item> &get_item ()\n+  {\n+    rust_assert (kind == ITEM);\n+    return item;\n+  }\n+\n+  std::unique_ptr<Stmt> &get_stmt ()\n+  {\n+    rust_assert (kind == STMT);\n+    return stmt;\n+  }\n+\n+  /**\n+   * Access the inner nodes and take ownership of them.\n+   * You can only call these functions once per node\n+   */\n+\n+  std::unique_ptr<Stmt> take_stmt ()\n+  {\n+    rust_assert (!is_error ());\n+    return std::move (stmt);\n+  }\n+\n+  std::unique_ptr<Expr> take_expr ()\n+  {\n+    rust_assert (!is_error ());\n+    return std::move (expr);\n+  }\n+\n+  std::unique_ptr<Item> take_item ()\n+  {\n+    rust_assert (!is_error ());\n+    return std::move (item);\n+  }\n+\n+  std::unique_ptr<TraitItem> take_trait_item ()\n+  {\n+    rust_assert (!is_error ());\n+    return std::move (trait_item);\n+  }\n+\n+  std::unique_ptr<ExternalItem> take_external_item ()\n+  {\n+    rust_assert (!is_error ());\n+    return std::move (external_item);\n+  }\n+\n+  std::unique_ptr<InherentImplItem> take_impl_item ()\n+  {\n+    rust_assert (!is_error ());\n+    return std::move (impl_item);\n+  }\n+\n+  std::unique_ptr<TraitImplItem> take_trait_impl_item ()\n+  {\n+    rust_assert (!is_error ());\n+    return std::move (trait_impl_item);\n+  }\n+\n+  std::unique_ptr<Type> take_type ()\n+  {\n+    rust_assert (!is_error ());\n+    return std::move (type);\n+  }\n+\n+  void accept_vis (ASTVisitor &vis)\n+  {\n+    switch (kind)\n+      {\n+      case EXPRESSION:\n+\texpr->accept_vis (vis);\n+\tbreak;\n+\n+      case ITEM:\n+\titem->accept_vis (vis);\n+\tbreak;\n+\n+      case STMT:\n+\tstmt->accept_vis (vis);\n+\tbreak;\n+\n+      case EXTERN:\n+\texternal_item->accept_vis (vis);\n+\tbreak;\n+\n+      case TRAIT:\n+\ttrait_item->accept_vis (vis);\n+\tbreak;\n+\n+      case IMPL:\n+\timpl_item->accept_vis (vis);\n+\tbreak;\n+\n+      case TRAIT_IMPL:\n+\ttrait_impl_item->accept_vis (vis);\n+\tbreak;\n+\n+      case TYPE:\n+\ttype->accept_vis (vis);\n+\tbreak;\n+      }\n+  }\n+\n+  bool is_error ()\n+  {\n+    switch (kind)\n+      {\n+      case EXPRESSION:\n+\treturn expr == nullptr;\n+      case ITEM:\n+\treturn item == nullptr;\n+      case STMT:\n+\treturn stmt == nullptr;\n+      case EXTERN:\n+\treturn external_item == nullptr;\n+      case TRAIT:\n+\treturn trait_item == nullptr;\n+      case IMPL:\n+\treturn impl_item == nullptr;\n+      case TRAIT_IMPL:\n+\treturn trait_impl_item == nullptr;\n+      case TYPE:\n+\treturn type == nullptr;\n+      }\n+\n+    gcc_unreachable ();\n+    return true;\n+  }\n+\n+  std::string as_string ()\n+  {\n+    switch (kind)\n+      {\n+      case EXPRESSION:\n+\treturn \"Expr: \" + expr->as_string ();\n+      case ITEM:\n+\treturn \"Item: \" + item->as_string ();\n+      case STMT:\n+\treturn \"Stmt: \" + stmt->as_string ();\n+      case EXTERN:\n+\treturn \"External Item: \" + external_item->as_string ();\n+      case TRAIT:\n+\treturn \"Trait Item: \" + trait_item->as_string ();\n+      case IMPL:\n+\treturn \"Impl Item: \" + impl_item->as_string ();\n+      case TRAIT_IMPL:\n+\treturn \"Trait Impl Item: \" + trait_impl_item->as_string ();\n+      case TYPE:\n+\treturn \"Type: \" + type->as_string ();\n+      }\n+\n+    gcc_unreachable ();\n+    return \"\";\n+  }\n+};\n+\n+/* Basically, a \"fragment\" that can be incorporated into the AST, created as\n+ * a result of macro expansion. Really annoying to work with due to the fact\n+ * that macros can really expand to anything. As such, horrible representation\n+ * at the moment. */\n+class ASTFragment\n+{\n+private:\n+  /* basic idea: essentially, a vector of tagged unions of different AST node\n+   * types. Now, this could actually be stored without a tagged union if the\n+   * different AST node types had a unified parent, but that would create\n+   * issues with the diamond problem or significant performance penalties. So\n+   * a tagged union had to be used instead. A vector is used to represent the\n+   * ability for a macro to expand to two statements, for instance. */\n+\n+  std::vector<SingleASTNode> nodes;\n+  bool fragment_is_error;\n+\n+  /**\n+   * We need to make a special case for Expression and Type fragments as only\n+   * one Node will be extracted from the `nodes` vector\n+   */\n+\n+  bool is_single_fragment () const { return nodes.size () == 1; }\n+\n+  bool is_single_fragment_kind (SingleASTNode::NodeType kind) const\n+  {\n+    return is_single_fragment () && nodes[0].get_kind () == kind;\n+  }\n+\n+public:\n+  ASTFragment (std::vector<SingleASTNode> nodes, bool fragment_is_error = false)\n+    : nodes (std::move (nodes)), fragment_is_error (fragment_is_error)\n+  {\n+    if (fragment_is_error)\n+      rust_assert (nodes.empty ());\n+  }\n+\n+  ASTFragment (ASTFragment const &other)\n+    : fragment_is_error (other.fragment_is_error)\n+  {\n+    nodes.clear ();\n+    nodes.reserve (other.nodes.size ());\n+    for (auto &n : other.nodes)\n+      {\n+\tnodes.push_back (n);\n+      }\n+  }\n+\n+  ASTFragment &operator= (ASTFragment const &other)\n+  {\n+    fragment_is_error = other.fragment_is_error;\n+    nodes.clear ();\n+    nodes.reserve (other.nodes.size ());\n+    for (auto &n : other.nodes)\n+      {\n+\tnodes.push_back (n);\n+      }\n+\n+    return *this;\n+  }\n+\n+  static ASTFragment create_error () { return ASTFragment ({}, true); }\n+\n+  std::vector<SingleASTNode> &get_nodes () { return nodes; }\n+  bool is_error () const { return fragment_is_error; }\n+\n+  bool should_expand () const { return !is_error (); }\n+\n+  std::unique_ptr<Expr> take_expression_fragment ()\n+  {\n+    rust_assert (is_single_fragment_kind (SingleASTNode::NodeType::EXPRESSION));\n+    return nodes[0].take_expr ();\n+  }\n+\n+  std::unique_ptr<Type> take_type_fragment ()\n+  {\n+    rust_assert (is_single_fragment_kind (SingleASTNode::NodeType::TYPE));\n+    return nodes[0].take_type ();\n+  }\n+\n+  void accept_vis (ASTVisitor &vis)\n+  {\n+    for (auto &node : nodes)\n+      node.accept_vis (vis);\n+  }\n+};\n+\n+// A crate AST object - holds all the data for a single compilation unit\n+struct Crate\n+{\n+  std::vector<Attribute> inner_attrs;\n+  // dodgy spacing required here\n+  /* TODO: is it better to have a vector of items here or a module (implicit\n+   * top-level one)? */\n+  std::vector<std::unique_ptr<Item> > items;\n+\n+  NodeId node_id;\n+\n+public:\n+  // Constructor\n+  Crate (std::vector<std::unique_ptr<Item> > items,\n+\t std::vector<Attribute> inner_attrs)\n+    : inner_attrs (std::move (inner_attrs)), items (std::move (items)),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n+\n+  // Copy constructor with vector clone\n+  Crate (Crate const &other)\n+    : inner_attrs (other.inner_attrs), node_id (other.node_id)\n+  {\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_item ());\n+  }\n+\n+  ~Crate () = default;\n+\n+  // Overloaded assignment operator with vector clone\n+  Crate &operator= (Crate const &other)\n+  {\n+    inner_attrs = other.inner_attrs;\n+    node_id = other.node_id;\n+\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_item ());\n+\n+    return *this;\n+  }\n+\n+  // Move constructors\n+  Crate (Crate &&other) = default;\n+  Crate &operator= (Crate &&other) = default;\n+\n+  // Get crate representation as string (e.g. for debugging).\n+  std::string as_string () const;\n+\n+  // Delete all crate information, e.g. if fails cfg.\n+  void strip_crate ()\n+  {\n+    inner_attrs.clear ();\n+    inner_attrs.shrink_to_fit ();\n+\n+    items.clear ();\n+    items.shrink_to_fit ();\n+    // TODO: is this the best way to do this?\n+  }\n+\n+  NodeId get_node_id () const { return node_id; }\n+  const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n+};\n+\n+// Base path expression AST node - abstract\n+class PathExpr : public ExprWithoutBlock\n+{\n+};\n+} // namespace AST\n+} // namespace Rust\n+\n+#endif"}, {"sha": "6813db3ed13e872b39c245af27a5ef335909e65c", "filename": "gcc/rust/operator.h", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b35ae12ce9371bf0ae7ad202c4393cdd77fad55/gcc%2Frust%2Foperator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b35ae12ce9371bf0ae7ad202c4393cdd77fad55/gcc%2Frust%2Foperator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Foperator.h?ref=6b35ae12ce9371bf0ae7ad202c4393cdd77fad55", "patch": "@@ -0,0 +1,72 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_OPERATOR_H\n+#define RUST_OPERATOR_H\n+\n+enum class NegationOperator\n+{\n+  NEGATE,\n+  NOT\n+};\n+\n+enum class ArithmeticOrLogicalOperator\n+{\n+  ADD,\t       // std::ops::Add\n+  SUBTRACT,    // std::ops::Sub\n+  MULTIPLY,    // std::ops::Mul\n+  DIVIDE,      // std::ops::Div\n+  MODULUS,     // std::ops::Rem\n+  BITWISE_AND, // std::ops::BitAnd\n+  BITWISE_OR,  // std::ops::BitOr\n+  BITWISE_XOR, // std::ops::BitXor\n+  LEFT_SHIFT,  // std::ops::Shl\n+  RIGHT_SHIFT  // std::ops::Shr\n+};\n+\n+enum class ComparisonOperator\n+{\n+  EQUAL,\t    // std::cmp::PartialEq::eq\n+  NOT_EQUAL,\t    // std::cmp::PartialEq::ne\n+  GREATER_THAN,\t    // std::cmp::PartialEq::gt\n+  LESS_THAN,\t    // std::cmp::PartialEq::lt\n+  GREATER_OR_EQUAL, // std::cmp::PartialEq::ge\n+  LESS_OR_EQUAL\t    // std::cmp::PartialEq::le\n+};\n+\n+enum class LazyBooleanOperator\n+{\n+  LOGICAL_OR,\n+  LOGICAL_AND\n+};\n+\n+enum class CompoundAssignmentOperator\n+{\n+  ADD,\t       // std::ops::AddAssign\n+  SUBTRACT,    // std::ops::SubAssign\n+  MULTIPLY,    // std::ops::MulAssign\n+  DIVIDE,      // std::ops::DivAssign\n+  MODULUS,     // std::ops::RemAssign\n+  BITWISE_AND, // std::ops::BitAndAssign\n+  BITWISE_OR,  // std::ops::BitOrAssign\n+  BITWISE_XOR, // std::ops::BitXorAssign\n+  LEFT_SHIFT,  // std::ops::ShlAssign\n+  RIGHT_SHIFT  // std::ops::ShrAssign\n+};\n+\n+#endif // RUST_OPERATOR_H"}]}