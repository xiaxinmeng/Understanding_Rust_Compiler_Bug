{"sha": "d6b418fa0b3d5dc88ffb3f1673f82e6dbf5da6d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZiNDE4ZmEwYjNkNWRjODhmZmIzZjE2NzNmODJlNmRiZjVkYTZkMQ==", "commit": {"author": {"name": "Simon Martin", "email": "simartin@users.sourceforge.net", "date": "2006-12-16T08:51:42Z"}, "committer": {"name": "Simon Martin", "email": "simartin@gcc.gnu.org", "date": "2006-12-16T08:51:42Z"}, "message": "re PR c++/29475 (incomplete  template diagnostics.)\n\n2006-12-16  Simon Martin  <simartin@users.sourceforge.net>\n\n\tPR c++/29475\n\t* cp-tree.h (struct deferred_access_check): New structure to represent a\n\tdeferred access check. It replaces the previous representation as a tree.\n\t(get_deferred_access_checks): Return a vector of struct\n\tdeferred_access_check instead of a tree list.\n\t(perform_access_checks): Take a vector of struct deferred_access_check\n\tinstead of a tree list.\n\t* semantics.c (struct deferred_access): Store the deferred access checks\n\tas a vector of struct deferred_access_check instead of a tree list.\n\t(push_deferring_access_checks): Handle the change in struct\n\tdeferred_access.\n\t(get_deferred_access_checks): Likewise.\n\t(pop_to_parent_deferring_access_checks): Likewise.\n\t(perform_or_defer_access_check): Likewise.\n\t(perform_access_checks): Take a vector of struct deferred_access_check\n\tinstead of a tree list.\n\t* parser.c (struct tree_check): New structure to store various data\n\tassociated with a CPP_NESTED_NAME_SPECIFIER or CPP_TEMPLATE_ID token.\n\t(struct cp_token): Changed the value field to be a union with a pointer to\n\ta struct tree_check for CPP_NESTED_NAME_SPECIFIER or CPP_TEMPLATE_ID\n\ttokens and a tree field for all other tokens.\n\t(eof_token): Adjusted due to the change in struct cp_token.\n\t(cp_lexer_get_preprocessor_token): Likewise.\n\t(cp_lexer_purge_token): Likewise.\n\t(cp_lexer_purge_tokens_after): Likewise.\n\t(cp_lexer_print_token): Likewise.\n\t(cp_parser_error): Likewise.\n\t(cp_parser_identifier): Likewise.\n\t(cp_parser_string_literal): Likewise.\n\t(cp_parser_primary_expression): Likewise.\n\t(cp_parser_unqualified_id): Likewise.\n\t(cp_parser_parenthesized_expression_list): Likewise.\n\t(cp_parser_storage_class_specifier_opt): Likewise.\n\t(cp_parser_function_specifier_opt): Likewise.\n\t(cp_parser_type_specifier): Likewise.\n\t(cp_parser_simple_type_specifier): Likewise.\n\t(cp_parser_initializer_list): Likewise.\n\t(cp_parser_member_specification_opt): Likewise.\n\t(cp_parser_attribute_list): Likewise.\n\t(cp_parser_objc_expression): Likewise.\n\t(cp_parser_objc_protocol_qualifiers): Likewise.\n\t(cp_parser_objc_selector): Likewise.\n\t(cp_parser_objc_declaration): Likewise.\n\t(cp_parser_objc_statement): Likewise.\n\t(cp_parser_omp_clause_name): Likewise.\n\t(cp_parser_omp_clause_default): Likewise.\n\t(cp_parser_omp_clause_schedule): Likewise.\n\t(cp_parser_omp_parallel): Likewise.\n\t(cp_parser_initial_pragma): Likewise.\n\t(pragma_lex): Likewise.\n\t(cp_parser_pre_parsed_nested_name_specifier): Likewise.\n\t(cp_parser_nested_name_specifier_opt): Likewise.\n\tUse cp_token::u::tree_check_value to save the token's value, the\n\tassociated deferred checks and its qualifying scope.\n\t(cp_parser_template_id): Likewise.\n\t(cp_parser_template_declaration_after_export): Adjusted the call to\n\tget_deferred_access_checks.\n\t(cp_parser_init_declarator): Take the access checks as a vector of struct\n\tdeferred_access_check instead of a tree list.\n\t(cp_parser_single_declaration): Likewise.\n\t(cp_parser_perform_template_parameter_access_checks): Likewise.\n\t(cp_parser_simple_declaration): Adjusted the call to\n\tcp_parser_init_declarator.\n\t(cp_parser_explicit_specialization): Adjusted the call to\n\tcp_parser_single_declaration.\n\nFrom-SVN: r119961", "tree": {"sha": "a7b346cda4d3b77e77b9aa9c9d5fdd0dbacf5afe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7b346cda4d3b77e77b9aa9c9d5fdd0dbacf5afe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6b418fa0b3d5dc88ffb3f1673f82e6dbf5da6d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6b418fa0b3d5dc88ffb3f1673f82e6dbf5da6d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6b418fa0b3d5dc88ffb3f1673f82e6dbf5da6d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6b418fa0b3d5dc88ffb3f1673f82e6dbf5da6d1/comments", "author": {"login": "simartin", "id": 935202, "node_id": "MDQ6VXNlcjkzNTIwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/935202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/simartin", "html_url": "https://github.com/simartin", "followers_url": "https://api.github.com/users/simartin/followers", "following_url": "https://api.github.com/users/simartin/following{/other_user}", "gists_url": "https://api.github.com/users/simartin/gists{/gist_id}", "starred_url": "https://api.github.com/users/simartin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/simartin/subscriptions", "organizations_url": "https://api.github.com/users/simartin/orgs", "repos_url": "https://api.github.com/users/simartin/repos", "events_url": "https://api.github.com/users/simartin/events{/privacy}", "received_events_url": "https://api.github.com/users/simartin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e6a98ba89323ec0f641df79101ea99dadda441ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6a98ba89323ec0f641df79101ea99dadda441ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6a98ba89323ec0f641df79101ea99dadda441ce"}], "stats": {"total": 396, "additions": 265, "deletions": 131}, "files": [{"sha": "b51ebc0e89920eb52728315fb960fe79ccc2ddd7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b418fa0b3d5dc88ffb3f1673f82e6dbf5da6d1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b418fa0b3d5dc88ffb3f1673f82e6dbf5da6d1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d6b418fa0b3d5dc88ffb3f1673f82e6dbf5da6d1", "patch": "@@ -1,3 +1,71 @@\n+2006-12-16  Simon Martin  <simartin@users.sourceforge.net>\n+\n+\tPR c++/29475\n+\t* cp-tree.h (struct deferred_access_check): New structure to represent a\n+\tdeferred access check. It replaces the previous representation as a tree.\n+\t(get_deferred_access_checks): Return a vector of struct\n+\tdeferred_access_check instead of a tree list.\n+\t(perform_access_checks): Take a vector of struct deferred_access_check\n+\tinstead of a tree list.\n+\t* semantics.c (struct deferred_access): Store the deferred access checks\n+\tas a vector of struct deferred_access_check instead of a tree list.\n+\t(push_deferring_access_checks): Handle the change in struct\n+\tdeferred_access.\n+\t(get_deferred_access_checks): Likewise.\n+\t(pop_to_parent_deferring_access_checks): Likewise.\n+\t(perform_or_defer_access_check): Likewise.\n+\t(perform_access_checks): Take a vector of struct deferred_access_check\n+\tinstead of a tree list.\n+\t* parser.c (struct tree_check): New structure to store various data\n+\tassociated with a CPP_NESTED_NAME_SPECIFIER or CPP_TEMPLATE_ID token.\n+\t(struct cp_token): Changed the value field to be a union with a pointer to\n+\ta struct tree_check for CPP_NESTED_NAME_SPECIFIER or CPP_TEMPLATE_ID\n+\ttokens and a tree field for all other tokens.\n+\t(eof_token): Adjusted due to the change in struct cp_token.\n+\t(cp_lexer_get_preprocessor_token): Likewise.\n+\t(cp_lexer_purge_token): Likewise.\n+\t(cp_lexer_purge_tokens_after): Likewise.\n+\t(cp_lexer_print_token): Likewise.\n+\t(cp_parser_error): Likewise.\n+\t(cp_parser_identifier): Likewise.\n+\t(cp_parser_string_literal): Likewise.\n+\t(cp_parser_primary_expression): Likewise.\n+\t(cp_parser_unqualified_id): Likewise.\n+\t(cp_parser_parenthesized_expression_list): Likewise.\n+\t(cp_parser_storage_class_specifier_opt): Likewise.\n+\t(cp_parser_function_specifier_opt): Likewise.\n+\t(cp_parser_type_specifier): Likewise.\n+\t(cp_parser_simple_type_specifier): Likewise.\n+\t(cp_parser_initializer_list): Likewise.\n+\t(cp_parser_member_specification_opt): Likewise.\n+\t(cp_parser_attribute_list): Likewise.\n+\t(cp_parser_objc_expression): Likewise.\n+\t(cp_parser_objc_protocol_qualifiers): Likewise.\n+\t(cp_parser_objc_selector): Likewise.\n+\t(cp_parser_objc_declaration): Likewise.\n+\t(cp_parser_objc_statement): Likewise.\n+\t(cp_parser_omp_clause_name): Likewise.\n+\t(cp_parser_omp_clause_default): Likewise.\n+\t(cp_parser_omp_clause_schedule): Likewise.\n+\t(cp_parser_omp_parallel): Likewise.\n+\t(cp_parser_initial_pragma): Likewise.\n+\t(pragma_lex): Likewise.\n+\t(cp_parser_pre_parsed_nested_name_specifier): Likewise.\n+\t(cp_parser_nested_name_specifier_opt): Likewise.\n+\tUse cp_token::u::tree_check_value to save the token's value, the\n+\tassociated deferred checks and its qualifying scope.\n+\t(cp_parser_template_id): Likewise.\n+\t(cp_parser_template_declaration_after_export): Adjusted the call to\n+\tget_deferred_access_checks.\n+\t(cp_parser_init_declarator): Take the access checks as a vector of struct\n+\tdeferred_access_check instead of a tree list.\n+\t(cp_parser_single_declaration): Likewise.\n+\t(cp_parser_perform_template_parameter_access_checks): Likewise.\n+\t(cp_parser_simple_declaration): Adjusted the call to\n+\tcp_parser_init_declarator.\n+\t(cp_parser_explicit_specialization): Adjusted the call to\n+\tcp_parser_single_declaration.\n+\n 2006-12-13  Ian Lance Taylor  <iant@google.com>\n \n \tPR c++/19564"}, {"sha": "3968f96c9aa3b7bb1f978e6d1a367f9694a0889c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b418fa0b3d5dc88ffb3f1673f82e6dbf5da6d1/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b418fa0b3d5dc88ffb3f1673f82e6dbf5da6d1/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d6b418fa0b3d5dc88ffb3f1673f82e6dbf5da6d1", "patch": "@@ -4234,14 +4234,29 @@ extern tree copied_binfo\t\t\t(tree, tree);\n extern tree original_binfo\t\t\t(tree, tree);\n extern int shared_member_p\t\t\t(tree);\n \n+\n+/* The representation of a deferred access check.  */\n+\n+typedef struct deferred_access_check GTY(())\n+{\n+  /* The base class in which the declaration is referenced. */\n+  tree binfo;\n+  /* The declaration whose access must be checked.  */\n+  tree decl;\n+  /* The declaration that should be used in the error message.  */\n+  tree diag_decl;\n+} deferred_access_check;\n+DEF_VEC_O(deferred_access_check);\n+DEF_VEC_ALLOC_O(deferred_access_check,gc);\n+\n /* in semantics.c */\n extern void push_deferring_access_checks\t(deferring_kind);\n extern void resume_deferring_access_checks\t(void);\n extern void stop_deferring_access_checks\t(void);\n extern void pop_deferring_access_checks\t\t(void);\n-extern tree get_deferred_access_checks\t\t(void);\n+extern VEC (deferred_access_check,gc)* get_deferred_access_checks\t\t(void);\n extern void pop_to_parent_deferring_access_checks (void);\n-extern void perform_access_checks\t\t(tree);\n+extern void perform_access_checks\t\t(VEC (deferred_access_check,gc)*);\n extern void perform_deferred_access_checks\t(void);\n extern void perform_or_defer_access_check\t(tree, tree, tree);\n extern int stmts_are_full_exprs_p\t\t(void);"}, {"sha": "ae2b4a028031c43e324e3bdd58a0fe4500c922b1", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 124, "deletions": 86, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b418fa0b3d5dc88ffb3f1673f82e6dbf5da6d1/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b418fa0b3d5dc88ffb3f1673f82e6dbf5da6d1/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=d6b418fa0b3d5dc88ffb3f1673f82e6dbf5da6d1", "patch": "@@ -45,6 +45,20 @@\n /* The cp_lexer_* routines mediate between the lexer proper (in libcpp\n    and c-lex.c) and the C++ parser.  */\n \n+/* A token's value and its associated deferred access checks and\n+   qualifying scope.  */\n+\n+struct tree_check GTY(())\n+{\n+  /* The value associated with the token.  */\n+  tree value;\n+  /* The checks that have been associated with value.  */\n+  VEC (deferred_access_check, gc)* checks;\n+  /* The token's qualifying scope (used when it is a\n+     CPP_NESTED_NAME_SPECIFIER).  */\n+  tree qualifying_scope;\n+};\n+\n /* A C++ token.  */\n \n typedef struct cp_token GTY (())\n@@ -69,7 +83,12 @@ typedef struct cp_token GTY (())\n   /* The input file stack index at which this token was found.  */\n   unsigned input_file_stack_index : INPUT_FILE_STACK_BITS;\n   /* The value associated with this token, if any.  */\n-  tree value;\n+  union cp_token_value {\n+    /* Used for CPP_NESTED_NAME_SPECIFIER and CPP_TEMPLATE_ID.  */\n+    struct tree_check* GTY((tag (\"1\"))) tree_check_value;\n+    /* Use for all other tokens.  */\n+    tree GTY((tag (\"0\"))) value;\n+  } GTY((desc (\"(%1.type == CPP_TEMPLATE_ID) || (%1.type == CPP_NESTED_NAME_SPECIFIER)\"))) u;\n   /* The location at which this token was found.  */\n   location_t location;\n } cp_token;\n@@ -81,7 +100,7 @@ DEF_VEC_ALLOC_P (cp_token_position,heap);\n \n static const cp_token eof_token =\n {\n-  CPP_EOF, RID_MAX, 0, PRAGMA_NONE, 0, 0, false, 0, NULL_TREE,\n+  CPP_EOF, RID_MAX, 0, PRAGMA_NONE, 0, 0, false, 0, { NULL },\n #if USE_MAPPED_LOCATION\n   0\n #else\n@@ -394,7 +413,7 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer ATTRIBUTE_UNUSED ,\n \n    /* Get a new token from the preprocessor.  */\n   token->type\n-    = c_lex_with_flags (&token->value, &token->location, &token->flags);\n+    = c_lex_with_flags (&token->u.value, &token->location, &token->flags);\n   token->input_file_stack_index = input_file_stack_tick;\n   token->keyword = RID_MAX;\n   token->pragma_kind = PRAGMA_NONE;\n@@ -410,17 +429,17 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer ATTRIBUTE_UNUSED ,\n   /* Check to see if this token is a keyword.  */\n   if (token->type == CPP_NAME)\n     {\n-      if (C_IS_RESERVED_WORD (token->value))\n+      if (C_IS_RESERVED_WORD (token->u.value))\n \t{\n \t  /* Mark this token as a keyword.  */\n \t  token->type = CPP_KEYWORD;\n \t  /* Record which keyword.  */\n-\t  token->keyword = C_RID_CODE (token->value);\n+\t  token->keyword = C_RID_CODE (token->u.value);\n \t  /* Update the value.  Some keywords are mapped to particular\n \t     entities, rather than simply having the value of the\n \t     corresponding IDENTIFIER_NODE.  For example, `__const' is\n \t     mapped to `const'.  */\n-\t  token->value = ridpointers[token->keyword];\n+\t  token->u.value = ridpointers[token->keyword];\n \t}\n       else\n \t{\n@@ -432,7 +451,7 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer ATTRIBUTE_UNUSED ,\n   else if (token->type == CPP_AT_NAME)\n     {\n       token->type = CPP_KEYWORD;\n-      switch (C_RID_CODE (token->value))\n+      switch (C_RID_CODE (token->u.value))\n \t{\n \t/* Map 'class' to '@class', 'private' to '@private', etc.  */\n \tcase RID_CLASS: token->keyword = RID_AT_CLASS; break;\n@@ -442,14 +461,14 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer ATTRIBUTE_UNUSED ,\n \tcase RID_THROW: token->keyword = RID_AT_THROW; break;\n \tcase RID_TRY: token->keyword = RID_AT_TRY; break;\n \tcase RID_CATCH: token->keyword = RID_AT_CATCH; break;\n-\tdefault: token->keyword = C_RID_CODE (token->value);\n+\tdefault: token->keyword = C_RID_CODE (token->u.value);\n \t}\n     }\n   else if (token->type == CPP_PRAGMA)\n     {\n       /* We smuggled the cpp_token->u.pragma value in an INTEGER_CST.  */\n-      token->pragma_kind = TREE_INT_CST_LOW (token->value);\n-      token->value = NULL;\n+      token->pragma_kind = TREE_INT_CST_LOW (token->u.value);\n+      token->u.value = NULL_TREE;\n     }\n }\n \n@@ -641,7 +660,7 @@ cp_lexer_purge_token (cp_lexer *lexer)\n   gcc_assert (tok != &eof_token);\n   tok->type = CPP_PURGED;\n   tok->location = UNKNOWN_LOCATION;\n-  tok->value = NULL_TREE;\n+  tok->u.value = NULL_TREE;\n   tok->keyword = RID_MAX;\n \n   do\n@@ -675,7 +694,7 @@ cp_lexer_purge_tokens_after (cp_lexer *lexer, cp_token *tok)\n     {\n       tok->type = CPP_PURGED;\n       tok->location = UNKNOWN_LOCATION;\n-      tok->value = NULL_TREE;\n+      tok->u.value = NULL_TREE;\n       tok->keyword = RID_MAX;\n     }\n }\n@@ -753,16 +772,16 @@ cp_lexer_print_token (FILE * stream, cp_token *token)\n     case CPP_KEYWORD:\n       /* Some keywords have a value that is not an IDENTIFIER_NODE.\n \t For example, `struct' is mapped to an INTEGER_CST.  */\n-      if (TREE_CODE (token->value) != IDENTIFIER_NODE)\n+      if (TREE_CODE (token->u.value) != IDENTIFIER_NODE)\n \tbreak;\n       /* else fall through */\n     case CPP_NAME:\n-      fputs (IDENTIFIER_POINTER (token->value), stream);\n+      fputs (IDENTIFIER_POINTER (token->u.value), stream);\n       break;\n \n     case CPP_STRING:\n     case CPP_WSTRING:\n-      fprintf (stream, \" \\\"%s\\\"\", TREE_STRING_POINTER (token->value));\n+      fprintf (stream, \" \\\"%s\\\"\", TREE_STRING_POINTER (token->u.value));\n       break;\n \n     default:\n@@ -1606,7 +1625,7 @@ static void cp_parser_static_assert\n /* Declarators [gram.dcl.decl] */\n \n static tree cp_parser_init_declarator\n-  (cp_parser *, cp_decl_specifier_seq *, tree, bool, bool, int, bool *);\n+  (cp_parser *, cp_decl_specifier_seq *, VEC (deferred_access_check,gc)*, bool, bool, int, bool *);\n static cp_declarator *cp_parser_declarator\n   (cp_parser *, cp_parser_declarator_kind, int *, bool *, bool);\n static cp_declarator *cp_parser_direct_declarator\n@@ -1806,9 +1825,9 @@ static tree cp_parser_function_definition_after_declarator\n static void cp_parser_template_declaration_after_export\n   (cp_parser *, bool);\n static void cp_parser_perform_template_parameter_access_checks\n-  (tree);\n+  (VEC (deferred_access_check,gc)*);\n static tree cp_parser_single_declaration\n-  (cp_parser *, tree, bool, bool *);\n+  (cp_parser *, VEC (deferred_access_check,gc)*, bool, bool *);\n static tree cp_parser_functional_cast\n   (cp_parser *, tree);\n static tree cp_parser_save_member_function_body\n@@ -1962,7 +1981,7 @@ cp_parser_error (cp_parser* parser, const char* message)\n \t\t\tCPP_KEYWORD, keywords are treated like\n \t\t\tidentifiers.  */\n \t\t     (token->type == CPP_KEYWORD ? CPP_NAME : token->type),\n-\t\t     token->value);\n+\t\t     token->u.value);\n     }\n }\n \n@@ -2703,7 +2722,7 @@ cp_parser_identifier (cp_parser* parser)\n   /* Look for the identifier.  */\n   token = cp_parser_require (parser, CPP_NAME, \"identifier\");\n   /* Return the value.  */\n-  return token ? token->value : error_mark_node;\n+  return token ? token->u.value : error_mark_node;\n }\n \n /* Parse a sequence of adjacent string constants.  Returns a\n@@ -2744,8 +2763,8 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok)\n     {\n       cp_lexer_consume_token (parser->lexer);\n \n-      str.text = (const unsigned char *)TREE_STRING_POINTER (tok->value);\n-      str.len = TREE_STRING_LENGTH (tok->value);\n+      str.text = (const unsigned char *)TREE_STRING_POINTER (tok->u.value);\n+      str.len = TREE_STRING_LENGTH (tok->u.value);\n       count = 1;\n       if (tok->type == CPP_WSTRING)\n \twide = true;\n@@ -2761,8 +2780,8 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok)\n \t{\n \t  cp_lexer_consume_token (parser->lexer);\n \t  count++;\n-\t  str.text = (unsigned char *)TREE_STRING_POINTER (tok->value);\n-\t  str.len = TREE_STRING_LENGTH (tok->value);\n+\t  str.text = (unsigned char *)TREE_STRING_POINTER (tok->u.value);\n+\t  str.len = TREE_STRING_LENGTH (tok->u.value);\n \t  if (tok->type == CPP_WSTRING)\n \t    wide = true;\n \n@@ -2929,7 +2948,7 @@ cp_parser_primary_expression (cp_parser *parser,\n       /* Floating-point literals are only allowed in an integral\n \t constant expression if they are cast to an integral or\n \t enumeration type.  */\n-      if (TREE_CODE (token->value) == REAL_CST\n+      if (TREE_CODE (token->u.value) == REAL_CST\n \t  && parser->integral_constant_expression_p\n \t  && pedantic)\n \t{\n@@ -2966,7 +2985,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    cp_parser_non_integral_constant_expression\n \t      (parser, \"floating-point literal\");\n \t}\n-      return token->value;\n+      return token->u.value;\n \n     case CPP_STRING:\n     case CPP_WSTRING:\n@@ -3082,7 +3101,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t     Consume the token.  */\n \t  token = cp_lexer_consume_token (parser->lexer);\n \t  /* Look up the name.  */\n-\t  return finish_fname (token->value);\n+\t  return finish_fname (token->u.value);\n \n \tcase RID_VA_ARG:\n \t  {\n@@ -3519,7 +3538,7 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t    && token->type == CPP_NAME\n \t    && (cp_lexer_peek_nth_token (parser->lexer, 2)->type\n \t\t== CPP_OPEN_PAREN)\n-\t    && constructor_name_p (token->value, scope))\n+\t    && constructor_name_p (token->u.value, scope))\n \t  {\n \t    cp_lexer_consume_token (parser->lexer);\n \t    return build_nt (BIT_NOT_EXPR, scope);\n@@ -3820,7 +3839,7 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t\t      tree decl;\n \t\t      tree ambiguous_decls;\n \n-\t\t      decl = cp_parser_lookup_name (parser, token->value,\n+\t\t      decl = cp_parser_lookup_name (parser, token->u.value,\n \t\t\t\t\t\t    none_type,\n \t\t\t\t\t\t    /*is_template=*/false,\n \t\t\t\t\t\t    /*is_namespace=*/false,\n@@ -3831,13 +3850,13 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t\t      else if (ambiguous_decls)\n \t\t\t{\n \t\t\t  error (\"reference to %qD is ambiguous\",\n-\t\t\t\t token->value);\n+\t\t\t\t token->u.value);\n \t\t\t  print_candidates (ambiguous_decls);\n \t\t\t  decl = error_mark_node;\n \t\t\t}\n \t\t      else\n \t\t\tcp_parser_name_lookup_error\n-\t\t\t  (parser, token->value, decl,\n+\t\t\t  (parser, token->u.value, decl,\n \t\t\t   \"is not a class or namespace\");\n \t\t    }\n \t\t  parser->scope = error_mark_node;\n@@ -3896,17 +3915,17 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n   if (success && start)\n     {\n       cp_token *token;\n-      tree access_checks;\n \n       token = cp_lexer_token_at (parser->lexer, start);\n       /* Reset the contents of the START token.  */\n       token->type = CPP_NESTED_NAME_SPECIFIER;\n       /* Retrieve any deferred checks.  Do not pop this access checks yet\n \t so the memory will not be reclaimed during token replacing below.  */\n-      access_checks = get_deferred_access_checks ();\n-      token->value = build_tree_list (copy_list (access_checks),\n-\t\t\t\t      parser->scope);\n-      TREE_TYPE (token->value) = parser->qualifying_scope;\n+      token->u.tree_check_value = GGC_CNEW (struct tree_check);\n+      token->u.tree_check_value->value = parser->scope;\n+      token->u.tree_check_value->checks = get_deferred_access_checks ();\n+      token->u.tree_check_value->qualifying_scope =\n+\tparser->qualifying_scope;\n       token->keyword = RID_MAX;\n \n       /* Purge all subsequent tokens.  */\n@@ -4764,7 +4783,7 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n \t    /* Consume the identifier.  */\n \t    token = cp_lexer_consume_token (parser->lexer);\n \t    /* Save the identifier.  */\n-\t    identifier = token->value;\n+\t    identifier = token->u.value;\n \t  }\n \telse\n \t  {\n@@ -7451,7 +7470,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n \n       /* Parse the init-declarator.  */\n       decl = cp_parser_init_declarator (parser, &decl_specifiers,\n-\t\t\t\t\t/*checks=*/NULL_TREE,\n+\t\t\t\t\t/*checks=*/NULL,\n \t\t\t\t\tfunction_definition_allowed_p,\n \t\t\t\t\t/*member_p=*/false,\n \t\t\t\t\tdeclares_class_or_enum,\n@@ -7789,7 +7808,7 @@ cp_parser_storage_class_specifier_opt (cp_parser* parser)\n     case RID_MUTABLE:\n     case RID_THREAD:\n       /* Consume the token.  */\n-      return cp_lexer_consume_token (parser->lexer)->value;\n+      return cp_lexer_consume_token (parser->lexer)->u.value;\n \n     default:\n       return NULL_TREE;\n@@ -7837,7 +7856,7 @@ cp_parser_function_specifier_opt (cp_parser* parser,\n     }\n \n   /* Consume the token.  */\n-  return cp_lexer_consume_token (parser->lexer)->value;\n+  return cp_lexer_consume_token (parser->lexer)->u.value;\n }\n \n /* Parse a linkage-specification.\n@@ -8876,11 +8895,13 @@ cp_parser_template_id (cp_parser *parser,\n \t\t       bool check_dependency_p,\n \t\t       bool is_declaration)\n {\n+  int i;\n   tree template;\n   tree arguments;\n   tree template_id;\n   cp_token_position start_of_id = 0;\n-  tree access_check = NULL_TREE;\n+  deferred_access_check *chk;\n+  VEC (deferred_access_check,gc) *access_check;\n   cp_token *next_token, *next_token_2;\n   bool is_identifier;\n \n@@ -8889,18 +8910,25 @@ cp_parser_template_id (cp_parser *parser,\n   next_token = cp_lexer_peek_token (parser->lexer);\n   if (next_token->type == CPP_TEMPLATE_ID)\n     {\n-      tree value;\n-      tree check;\n+      struct tree_check *check_value;\n \n       /* Get the stored value.  */\n-      value = cp_lexer_consume_token (parser->lexer)->value;\n+      check_value = cp_lexer_consume_token (parser->lexer)->u.tree_check_value;\n       /* Perform any access checks that were deferred.  */\n-      for (check = TREE_PURPOSE (value); check; check = TREE_CHAIN (check))\n-\tperform_or_defer_access_check (TREE_PURPOSE (check),\n-\t\t\t\t       TREE_VALUE (check),\n-\t\t\t\t       TREE_VALUE (check));\n+      access_check = check_value->checks;\n+      if (access_check)\n+\t{\n+\t  for (i = 0 ;\n+\t       VEC_iterate (deferred_access_check, access_check, i, chk) ;\n+\t       ++i)\n+\t    {\n+\t      perform_or_defer_access_check (chk->binfo,\n+\t\t\t\t\t     chk->decl,\n+\t\t\t\t\t     chk->diag_decl);\n+\t    }\n+\t}\n       /* Return the stored value.  */\n-      return TREE_VALUE (value);\n+      return check_value->value;\n     }\n \n   /* Avoid performing name lookup if there is no possibility of\n@@ -9016,10 +9044,6 @@ cp_parser_template_id (cp_parser *parser,\n       template_id = lookup_template_function (template, arguments);\n     }\n \n-  /* Retrieve any deferred checks.  Do not pop this access checks yet\n-     so the memory will not be reclaimed during token replacing below.  */\n-  access_check = get_deferred_access_checks ();\n-\n   /* If parsing tentatively, replace the sequence of tokens that makes\n      up the template-id with a CPP_TEMPLATE_ID token.  That way,\n      should we re-parse the token stream, we will not have to repeat\n@@ -9032,7 +9056,11 @@ cp_parser_template_id (cp_parser *parser,\n \n       /* Reset the contents of the START_OF_ID token.  */\n       token->type = CPP_TEMPLATE_ID;\n-      token->value = build_tree_list (access_check, template_id);\n+      /* Retrieve any deferred checks.  Do not pop this access checks yet\n+\t so the memory will not be reclaimed during token replacing below.  */\n+      token->u.tree_check_value = GGC_CNEW (struct tree_check);\n+      token->u.tree_check_value->value = template_id;\n+      token->u.tree_check_value->checks = get_deferred_access_checks ();\n       token->keyword = RID_MAX;\n \n       /* Purge all subsequent tokens.  */\n@@ -9697,7 +9725,7 @@ cp_parser_explicit_specialization (cp_parser* parser)\n   else\n     /* Parse the dependent declaration.  */\n     cp_parser_single_declaration (parser,\n-\t\t\t\t  /*checks=*/NULL_TREE,\n+\t\t\t\t  /*checks=*/NULL,\n \t\t\t\t  /*member_p=*/false,\n \t\t\t\t  /*friend_p=*/NULL);\n   /* We're done with the specialization.  */\n@@ -9864,7 +9892,7 @@ cp_parser_type_specifier (cp_parser* parser,\n \t  ++decl_specs->specs[(int)ds];\n \t  decl_specs->any_specifiers_p = true;\n \t}\n-      return cp_lexer_consume_token (parser->lexer)->value;\n+      return cp_lexer_consume_token (parser->lexer)->u.value;\n     }\n \n   /* If we do not already have a type-specifier, assume we are looking\n@@ -10007,7 +10035,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \tdecl_specs->any_specifiers_p = true;\n \n       /* Consume the token.  */\n-      id = cp_lexer_consume_token (parser->lexer)->value;\n+      id = cp_lexer_consume_token (parser->lexer)->u.value;\n \n       /* There is no valid C++ program where a non-template type is\n \t followed by a \"<\".  That usually indicates that the user thought\n@@ -11150,7 +11178,7 @@ cp_parser_asm_definition (cp_parser* parser)\n static tree\n cp_parser_init_declarator (cp_parser* parser,\n \t\t\t   cp_decl_specifier_seq *decl_specifiers,\n-\t\t\t   tree checks,\n+\t\t\t   VEC (deferred_access_check,gc)* checks,\n \t\t\t   bool function_definition_allowed_p,\n \t\t\t   bool member_p,\n \t\t\t   int declares_class_or_enum,\n@@ -12948,7 +12976,7 @@ cp_parser_initializer_list (cp_parser* parser, bool* non_constant_p)\n \t  if (pedantic)\n \t    pedwarn (\"ISO C++ does not allow designated initializers\");\n \t  /* Consume the identifier.  */\n-\t  identifier = cp_lexer_consume_token (parser->lexer)->value;\n+\t  identifier = cp_lexer_consume_token (parser->lexer)->u.value;\n \t  /* Consume the `:'.  */\n \t  cp_lexer_consume_token (parser->lexer);\n \t}\n@@ -13753,7 +13781,7 @@ cp_parser_member_specification_opt (cp_parser* parser)\n \t  /* Consume the access-specifier.  */\n \t  cp_lexer_consume_token (parser->lexer);\n \t  /* Remember which access-specifier is active.  */\n-\t  current_access_specifier = token->value;\n+\t  current_access_specifier = token->u.value;\n \t  /* Look for the `:'.  */\n \t  cp_parser_require (parser, CPP_COLON, \"`:'\");\n \t  break;\n@@ -14933,7 +14961,7 @@ cp_parser_attribute_list (cp_parser* parser)\n \n \t  /* Save away the identifier that indicates which attribute\n \t     this is.  */\n-\t  identifier = token->value;\n+\t  identifier = token->u.value;\n \t  attribute = build_tree_list (identifier, NULL_TREE);\n \n \t  /* Peek at the next token.  */\n@@ -15766,7 +15794,7 @@ static void\n cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n {\n   tree decl = NULL_TREE;\n-  tree checks;\n+  VEC (deferred_access_check,gc) *checks;\n   tree parameter_list;\n   bool friend_p = false;\n   bool need_lang_pop;\n@@ -15889,7 +15917,7 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n    get_deferred_access_checks.  */\n \n static void\n-cp_parser_perform_template_parameter_access_checks (tree checks)\n+cp_parser_perform_template_parameter_access_checks (VEC (deferred_access_check,gc)* checks)\n {\n   ++processing_template_parmlist;\n   perform_access_checks (checks);\n@@ -15905,7 +15933,7 @@ cp_parser_perform_template_parameter_access_checks (tree checks)\n \n static tree\n cp_parser_single_declaration (cp_parser* parser,\n-\t\t\t      tree checks,\n+\t\t\t      VEC (deferred_access_check,gc)* checks,\n \t\t\t      bool member_p,\n \t\t\t      bool* friend_p)\n {\n@@ -16851,19 +16879,29 @@ cp_parser_optional_template_keyword (cp_parser *parser)\n static void\n cp_parser_pre_parsed_nested_name_specifier (cp_parser *parser)\n {\n-  tree value;\n-  tree check;\n+  int i;\n+  struct tree_check *check_value;\n+  deferred_access_check *chk;\n+  VEC (deferred_access_check,gc) *checks;\n \n   /* Get the stored value.  */\n-  value = cp_lexer_consume_token (parser->lexer)->value;\n+  check_value = cp_lexer_consume_token (parser->lexer)->u.tree_check_value;\n   /* Perform any access checks that were deferred.  */\n-  for (check = TREE_PURPOSE (value); check; check = TREE_CHAIN (check))\n-    perform_or_defer_access_check (TREE_PURPOSE (check),\n-\t\t\t\t   TREE_VALUE (check),\n-\t\t\t\t   TREE_VALUE (check));\n+  checks = check_value->checks;\n+  if (checks)\n+    {\n+      for (i = 0 ;\n+\t   VEC_iterate (deferred_access_check, checks, i, chk) ;\n+\t   ++i)\n+\t{\n+\t  perform_or_defer_access_check (chk->binfo,\n+\t\t\t\t\t chk->decl,\n+\t\t\t\t\t chk->diag_decl);\n+\t}\n+    }\n   /* Set the scope from the stored value.  */\n-  parser->scope = TREE_VALUE (value);\n-  parser->qualifying_scope = TREE_TYPE (value);\n+  parser->scope = check_value->value;\n+  parser->qualifying_scope = check_value->qualifying_scope;\n   parser->object_scope = NULL_TREE;\n }\n \n@@ -17051,7 +17089,7 @@ cp_parser_objc_expression (cp_parser* parser)\n \n     case CPP_OBJC_STRING:\n       kwd = cp_lexer_consume_token (parser->lexer);\n-      return objc_build_string_object (kwd->value);\n+      return objc_build_string_object (kwd->u.value);\n \n     case CPP_KEYWORD:\n       switch (kwd->keyword)\n@@ -17069,7 +17107,7 @@ cp_parser_objc_expression (cp_parser* parser)\n \t  break;\n \t}\n     default:\n-      error (\"misplaced %<@%D%> Objective-C++ construct\", kwd->value);\n+      error (\"misplaced %<@%D%> Objective-C++ construct\", kwd->u.value);\n       cp_parser_skip_to_end_of_block_or_statement (parser);\n     }\n \n@@ -17459,7 +17497,7 @@ cp_parser_objc_protocol_qualifiers (cp_parser* parser)\n   tree quals = NULL_TREE, node;\n   cp_token *token = cp_lexer_peek_token (parser->lexer);\n \n-  node = token->value;\n+  node = token->u.value;\n \n   while (node && TREE_CODE (node) == IDENTIFIER_NODE\n \t && (node == ridpointers [(int) RID_IN]\n@@ -17472,7 +17510,7 @@ cp_parser_objc_protocol_qualifiers (cp_parser* parser)\n       quals = tree_cons (NULL_TREE, node, quals);\n       cp_lexer_consume_token (parser->lexer);\n       token = cp_lexer_peek_token (parser->lexer);\n-      node = token->value;\n+      node = token->u.value;\n     }\n \n   return quals;\n@@ -17543,7 +17581,7 @@ cp_parser_objc_selector (cp_parser* parser)\n     case CPP_OR_EQ: return get_identifier (\"or_eq\");\n     case CPP_XOR: return get_identifier (\"xor\");\n     case CPP_XOR_EQ: return get_identifier (\"xor_eq\");\n-    default: return token->value;\n+    default: return token->u.value;\n     }\n }\n \n@@ -17992,7 +18030,7 @@ cp_parser_objc_declaration (cp_parser* parser)\n       cp_parser_objc_end_implementation (parser);\n       break;\n     default:\n-      error (\"misplaced %<@%D%> Objective-C++ construct\", kwd->value);\n+      error (\"misplaced %<@%D%> Objective-C++ construct\", kwd->u.value);\n       cp_parser_skip_to_end_of_block_or_statement (parser);\n     }\n }\n@@ -18123,7 +18161,7 @@ cp_parser_objc_statement (cp_parser * parser) {\n     case RID_AT_THROW:\n       return cp_parser_objc_throw_statement (parser);\n     default:\n-      error (\"misplaced %<@%D%> Objective-C++ construct\", kwd->value);\n+      error (\"misplaced %<@%D%> Objective-C++ construct\", kwd->u.value);\n       cp_parser_skip_to_end_of_block_or_statement (parser);\n     }\n \n@@ -18150,7 +18188,7 @@ cp_parser_omp_clause_name (cp_parser *parser)\n     result = PRAGMA_OMP_CLAUSE_PRIVATE;\n   else if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n-      tree id = cp_lexer_peek_token (parser->lexer)->value;\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n       const char *p = IDENTIFIER_POINTER (id);\n \n       switch (p[0])\n@@ -18304,7 +18342,7 @@ cp_parser_omp_clause_default (cp_parser *parser, tree list)\n     return list;\n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n-      tree id = cp_lexer_peek_token (parser->lexer)->value;\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n       const char *p = IDENTIFIER_POINTER (id);\n \n       switch (p[0])\n@@ -18515,7 +18553,7 @@ cp_parser_omp_clause_schedule (cp_parser *parser, tree list)\n \n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n-      tree id = cp_lexer_peek_token (parser->lexer)->value;\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n       const char *p = IDENTIFIER_POINTER (id);\n \n       switch (p[0])\n@@ -19164,7 +19202,7 @@ cp_parser_omp_parallel (cp_parser *parser, cp_token *pragma_tok)\n     }\n   else if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n-      tree id = cp_lexer_peek_token (parser->lexer)->value;\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n       const char *p = IDENTIFIER_POINTER (id);\n       if (strcmp (p, \"sections\") == 0)\n \t{\n@@ -19320,7 +19358,7 @@ cp_parser_initial_pragma (cp_token *first_token)\n   cp_lexer_get_preprocessor_token (NULL, first_token);\n   if (first_token->type == CPP_STRING)\n     {\n-      name = first_token->value;\n+      name = first_token->u.value;\n \n       cp_lexer_get_preprocessor_token (NULL, first_token);\n       if (first_token->type != CPP_PRAGMA_EOL)\n@@ -19440,7 +19478,7 @@ pragma_lex (tree *value)\n   tok = cp_lexer_peek_token (the_parser->lexer);\n \n   ret = tok->type;\n-  *value = tok->value;\n+  *value = tok->u.value;\n \n   if (ret == CPP_PRAGMA_EOL || ret == CPP_EOF)\n     ret = CPP_EOF;"}, {"sha": "41d2be9817cfa2c4293abf2643de028b22793ece", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 56, "deletions": 43, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b418fa0b3d5dc88ffb3f1673f82e6dbf5da6d1/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b418fa0b3d5dc88ffb3f1673f82e6dbf5da6d1/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=d6b418fa0b3d5dc88ffb3f1673f82e6dbf5da6d1", "patch": "@@ -96,23 +96,23 @@ static tree finalize_nrv_r (tree *, int *, void *);\n \n    2. When a declaration such as a type, or a variable, is encountered,\n       the function `perform_or_defer_access_check' is called.  It\n-      maintains a TREE_LIST of all deferred checks.\n+      maintains a VEC of all deferred checks.\n \n    3. The global `current_class_type' or `current_function_decl' is then\n       setup by the parser.  `enforce_access' relies on these information\n       to check access.\n \n    4. Upon exiting the context mentioned in step 1,\n       `perform_deferred_access_checks' is called to check all declaration\n-      stored in the TREE_LIST.   `pop_deferring_access_checks' is then\n+      stored in the VEC. `pop_deferring_access_checks' is then\n       called to restore the previous access checking mode.\n \n       In case of parsing error, we simply call `pop_deferring_access_checks'\n       without `perform_deferred_access_checks'.  */\n \n typedef struct deferred_access GTY(())\n {\n-  /* A TREE_LIST representing name-lookups for which we have deferred\n+  /* A VEC representing name-lookups for which we have deferred\n      checking access controls.  We cannot check the accessibility of\n      names used in a decl-specifier-seq until we know what is being\n      declared because code like:\n@@ -124,12 +124,8 @@ typedef struct deferred_access GTY(())\n \n        A::B* A::f() { return 0; }\n \n-     is valid, even though `A::B' is not generally accessible.\n-\n-     The TREE_PURPOSE of each node is the scope used to qualify the\n-     name being looked up; the TREE_VALUE is the DECL to which the\n-     name was resolved.  */\n-  tree deferred_access_checks;\n+     is valid, even though `A::B' is not generally accessible.  */\n+  VEC (deferred_access_check,gc)* GTY(()) deferred_access_checks;\n \n   /* The current mode of access checks.  */\n   enum deferring_kind deferring_access_checks_kind;\n@@ -157,7 +153,7 @@ push_deferring_access_checks (deferring_kind deferring)\n       deferred_access *ptr;\n \n       ptr = VEC_safe_push (deferred_access, gc, deferred_access_stack, NULL);\n-      ptr->deferred_access_checks = NULL_TREE;\n+      ptr->deferred_access_checks = NULL;\n       ptr->deferring_access_checks_kind = deferring;\n     }\n }\n@@ -200,7 +196,7 @@ pop_deferring_access_checks (void)\n    access occurred; the TREE_VALUE is the declaration named.\n    */\n \n-tree\n+VEC (deferred_access_check,gc)*\n get_deferred_access_checks (void)\n {\n   if (deferred_access_no_check)\n@@ -221,7 +217,7 @@ pop_to_parent_deferring_access_checks (void)\n     deferred_access_no_check--;\n   else\n     {\n-      tree checks;\n+      VEC (deferred_access_check,gc) *checks;\n       deferred_access *ptr;\n \n       checks = (VEC_last (deferred_access, deferred_access_stack)\n@@ -232,29 +228,31 @@ pop_to_parent_deferring_access_checks (void)\n       if (ptr->deferring_access_checks_kind == dk_no_deferred)\n \t{\n \t  /* Check access.  */\n-\t  for (; checks; checks = TREE_CHAIN (checks))\n-\t    enforce_access (TREE_PURPOSE (checks),\n-\t\t\t    TREE_VALUE (checks), TREE_VALUE (checks));\n+\t  perform_access_checks (checks);\n \t}\n       else\n \t{\n \t  /* Merge with parent.  */\n-\t  tree next;\n-\t  tree original = ptr->deferred_access_checks;\n+\t  int i, j;\n+\t  deferred_access_check *chk, *probe;\n \n-\t  for (; checks; checks = next)\n+\t  for (i = 0 ;\n+\t       VEC_iterate (deferred_access_check, checks, i, chk) ;\n+\t       ++i)\n \t    {\n-\t      tree probe;\n-\n-\t      next = TREE_CHAIN (checks);\n-\n-\t      for (probe = original; probe; probe = TREE_CHAIN (probe))\n-\t\tif (TREE_VALUE (probe) == TREE_VALUE (checks)\n-\t\t    && TREE_PURPOSE (probe) == TREE_PURPOSE (checks))\n-\t\t  goto found;\n+\t      for (j = 0 ;\n+\t\t   VEC_iterate (deferred_access_check,\n+\t\t\t\tptr->deferred_access_checks, j, probe) ;\n+\t\t   ++j)\n+\t\t{\n+\t\t  if (probe->binfo == chk->binfo &&\n+\t\t      probe->decl == chk->decl &&\n+\t\t      probe->diag_decl == chk->diag_decl)\n+\t\t    goto found;\n+\t\t}\n \t      /* Insert into parent's checks.  */\n-\t      TREE_CHAIN (checks) = ptr->deferred_access_checks;\n-\t      ptr->deferred_access_checks = checks;\n+\t      VEC_safe_push (deferred_access_check, gc,\n+\t\t\t     ptr->deferred_access_checks, chk);\n \t    found:;\n \t    }\n \t}\n@@ -266,14 +264,16 @@ pop_to_parent_deferring_access_checks (void)\n    DECL node stored in the TREE_VALUE of the node.  */\n \n void\n-perform_access_checks (tree checks)\n+perform_access_checks (VEC (deferred_access_check,gc)* checks)\n {\n-  while (checks)\n-    {\n-      enforce_access (TREE_PURPOSE (checks),\n-\t\t      TREE_VALUE (checks), TREE_VALUE (checks));\n-      checks = TREE_CHAIN (checks);\n-    }\n+  int i;\n+  deferred_access_check *chk;\n+\n+  if (!checks)\n+    return;\n+\n+  for (i = 0 ; VEC_iterate (deferred_access_check, checks, i, chk) ; ++i)\n+    enforce_access (chk->binfo, chk->decl, chk->diag_decl);\n }\n \n /* Perform the deferred access checks.\n@@ -304,8 +304,11 @@ perform_deferred_access_checks (void)\n void\n perform_or_defer_access_check (tree binfo, tree decl, tree diag_decl)\n {\n-  tree check;\n+  int i;\n   deferred_access *ptr;\n+  deferred_access_check *chk;\n+  deferred_access_check *new_access;\n+\n \n   /* Exit if we are in a context that no access checking is performed.\n      */\n@@ -324,14 +327,24 @@ perform_or_defer_access_check (tree binfo, tree decl, tree diag_decl)\n     }\n \n   /* See if we are already going to perform this check.  */\n-  for (check = ptr->deferred_access_checks;\n-       check;\n-       check = TREE_CHAIN (check))\n-    if (TREE_VALUE (check) == decl && TREE_PURPOSE (check) == binfo)\n-      return;\n+  for (i = 0 ;\n+       VEC_iterate (deferred_access_check,\n+\t\t    ptr->deferred_access_checks, i, chk) ;\n+       ++i)\n+    {\n+      if (chk->decl == decl && chk->binfo == binfo &&\n+\t  chk->diag_decl == diag_decl)\n+\t{\n+\t  return;\n+\t}\n+    }\n   /* If not, record the check.  */\n-  ptr->deferred_access_checks\n-    = tree_cons (binfo, decl, ptr->deferred_access_checks);\n+  new_access =\n+    VEC_safe_push (deferred_access_check, gc,\n+\t\t   ptr->deferred_access_checks, 0);\n+  new_access->binfo = binfo;\n+  new_access->decl = decl;\n+  new_access->diag_decl = diag_decl;\n }\n \n /* Returns nonzero if the current statement is a full expression,"}]}