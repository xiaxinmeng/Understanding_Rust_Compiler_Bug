{"sha": "acce8ce3bf1d3e588a9fb867cec6207e20596482", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNjZThjZTNiZjFkM2U1ODhhOWZiODY3Y2VjNjIwN2UyMDU5NjQ4Mg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-06-06T15:31:47Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-06-06T15:31:47Z"}, "message": "re PR tree-optimization/59299 (We do not sink loads)\n\n2014-06-06  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/59299\n\t* tree-ssa-sink.c (all_immediate_uses_same_place): Work on\n\ta def operand.\n\t(nearest_common_dominator_of_uses): Likewise.\n\t(statement_sink_location): Adjust.  Support sinking loads.\n\n\t* gcc.dg/tree-ssa/ssa-sink-10.c: New testcase.\n\nFrom-SVN: r211317", "tree": {"sha": "b895eada531f39c0c77fdeb6275329d7f5673c0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b895eada531f39c0c77fdeb6275329d7f5673c0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/acce8ce3bf1d3e588a9fb867cec6207e20596482", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acce8ce3bf1d3e588a9fb867cec6207e20596482", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acce8ce3bf1d3e588a9fb867cec6207e20596482", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acce8ce3bf1d3e588a9fb867cec6207e20596482/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f0bb873672d194163ce75f1ab5c30d9c8bf03ecc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0bb873672d194163ce75f1ab5c30d9c8bf03ecc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0bb873672d194163ce75f1ab5c30d9c8bf03ecc"}], "stats": {"total": 158, "additions": 107, "deletions": 51}, "files": [{"sha": "19aeddc91904aaaa505152b322b06ce641b2bf96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acce8ce3bf1d3e588a9fb867cec6207e20596482/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acce8ce3bf1d3e588a9fb867cec6207e20596482/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=acce8ce3bf1d3e588a9fb867cec6207e20596482", "patch": "@@ -1,3 +1,11 @@\n+2014-06-06  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/59299\n+\t* tree-ssa-sink.c (all_immediate_uses_same_place): Work on\n+\ta def operand.\n+\t(nearest_common_dominator_of_uses): Likewise.\n+\t(statement_sink_location): Adjust.  Support sinking loads.\n+\n 2014-06-06  Martin Jambor  <mjambor@suse.cz>\n \n \t* ipa-prop.c (get_place_in_agg_contents_list): New function."}, {"sha": "7141aa3515d8bcfb04ebfbe1cb927f2ce73e5b86", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acce8ce3bf1d3e588a9fb867cec6207e20596482/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acce8ce3bf1d3e588a9fb867cec6207e20596482/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=acce8ce3bf1d3e588a9fb867cec6207e20596482", "patch": "@@ -1,3 +1,8 @@\n+2014-06-06  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/59299\n+\t* gcc.dg/tree-ssa/ssa-sink-10.c: New testcase.\n+\n 2014-06-06  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* gcc.dg/tree-ssa/pr42585.c: Skip for AArch64."}, {"sha": "6593598bbcb37692656894dd133921f63f5ecca7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-10.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acce8ce3bf1d3e588a9fb867cec6207e20596482/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sink-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acce8ce3bf1d3e588a9fb867cec6207e20596482/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sink-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sink-10.c?ref=acce8ce3bf1d3e588a9fb867cec6207e20596482", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-sink-details\" } */\n+\n+int x[1024], y[1024], z[1024], w[1024];\n+void foo (void)\n+{\n+  int i;\n+  for (i = 1; i < 1024; ++i)\n+    {\n+      int a = x[i];\n+      int b = y[i];\n+      int c = x[i-1];\n+      int d = y[i-1];\n+      if (w[i])\n+\tz[i] = (a + b) + (c + d);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Sinking # VUSE\" 4 \"sink\" } } */\n+/* { dg-final { cleanup-tree-dump \"sink\" } } */"}, {"sha": "f7485ef0efa1554501a99f31b4553f50c8cb3156", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 74, "deletions": 51, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acce8ce3bf1d3e588a9fb867cec6207e20596482/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acce8ce3bf1d3e588a9fb867cec6207e20596482/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=acce8ce3bf1d3e588a9fb867cec6207e20596482", "patch": "@@ -110,26 +110,22 @@ find_bb_for_arg (gimple phi, tree def)\n    used in, so that you only have one place you can sink it to.  */\n \n static bool\n-all_immediate_uses_same_place (gimple stmt)\n+all_immediate_uses_same_place (def_operand_p def_p)\n {\n-  gimple firstuse = NULL;\n-  ssa_op_iter op_iter;\n+  tree var = DEF_FROM_PTR (def_p);\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n-  tree var;\n \n-  FOR_EACH_SSA_TREE_OPERAND (var, stmt, op_iter, SSA_OP_ALL_DEFS)\n+  gimple firstuse = NULL;\n+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, var)\n     {\n-      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, var)\n-        {\n-\t  if (is_gimple_debug (USE_STMT (use_p)))\n-\t    continue;\n-\t  if (firstuse == NULL)\n-\t    firstuse = USE_STMT (use_p);\n-\t  else\n-\t    if (firstuse != USE_STMT (use_p))\n-\t      return false;\n-\t}\n+      if (is_gimple_debug (USE_STMT (use_p)))\n+\tcontinue;\n+      if (firstuse == NULL)\n+\tfirstuse = USE_STMT (use_p);\n+      else\n+\tif (firstuse != USE_STMT (use_p))\n+\t  return false;\n     }\n \n   return true;\n@@ -138,49 +134,44 @@ all_immediate_uses_same_place (gimple stmt)\n /* Find the nearest common dominator of all of the immediate uses in IMM.  */\n \n static basic_block\n-nearest_common_dominator_of_uses (gimple stmt, bool *debug_stmts)\n+nearest_common_dominator_of_uses (def_operand_p def_p, bool *debug_stmts)\n {\n+  tree var = DEF_FROM_PTR (def_p);\n   bitmap blocks = BITMAP_ALLOC (NULL);\n   basic_block commondom;\n   unsigned int j;\n   bitmap_iterator bi;\n-  ssa_op_iter op_iter;\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n-  tree var;\n \n-  bitmap_clear (blocks);\n-  FOR_EACH_SSA_TREE_OPERAND (var, stmt, op_iter, SSA_OP_ALL_DEFS)\n+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, var)\n     {\n-      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, var)\n-        {\n-\t  gimple usestmt = USE_STMT (use_p);\n-\t  basic_block useblock;\n+      gimple usestmt = USE_STMT (use_p);\n+      basic_block useblock;\n \n-\t  if (gimple_code (usestmt) == GIMPLE_PHI)\n-\t    {\n-\t      int idx = PHI_ARG_INDEX_FROM_USE (use_p);\n+      if (gimple_code (usestmt) == GIMPLE_PHI)\n+\t{\n+\t  int idx = PHI_ARG_INDEX_FROM_USE (use_p);\n \n-\t      useblock = gimple_phi_arg_edge (usestmt, idx)->src;\n-\t    }\n-\t  else if (is_gimple_debug (usestmt))\n-\t    {\n-\t      *debug_stmts = true;\n-\t      continue;\n-\t    }\n-\t  else\n-\t    {\n-\t      useblock = gimple_bb (usestmt);\n-\t    }\n+\t  useblock = gimple_phi_arg_edge (usestmt, idx)->src;\n+\t}\n+      else if (is_gimple_debug (usestmt))\n+\t{\n+\t  *debug_stmts = true;\n+\t  continue;\n+\t}\n+      else\n+\t{\n+\t  useblock = gimple_bb (usestmt);\n+\t}\n \n-\t  /* Short circuit. Nothing dominates the entry block.  */\n-\t  if (useblock == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n-\t    {\n-\t      BITMAP_FREE (blocks);\n-\t      return NULL;\n-\t    }\n-\t  bitmap_set_bit (blocks, useblock->index);\n+      /* Short circuit. Nothing dominates the entry block.  */\n+      if (useblock == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n+\t{\n+\t  BITMAP_FREE (blocks);\n+\t  return NULL;\n \t}\n+      bitmap_set_bit (blocks, useblock->index);\n     }\n   commondom = BASIC_BLOCK_FOR_FN (cfun, bitmap_first_set_bit (blocks));\n   EXECUTE_IF_SET_IN_BITMAP (blocks, 0, j, bi)\n@@ -294,8 +285,6 @@ statement_sink_location (gimple stmt, basic_block frombb,\n      be seen by an external routine that needs it depending on where it gets\n      moved to.\n \n-     We don't want to sink loads from memory.\n-\n      We can't sink statements that end basic blocks without splitting the\n      incoming edge for the sink location to place it there.\n \n@@ -313,7 +302,6 @@ statement_sink_location (gimple stmt, basic_block frombb,\n   if (stmt_ends_bb_p (stmt)\n       || gimple_has_side_effects (stmt)\n       || gimple_has_volatile_ops (stmt)\n-      || (gimple_vuse (stmt) && !gimple_vdef (stmt))\n       || (cfun->has_local_explicit_reg_vars\n \t  && TYPE_MODE (TREE_TYPE (gimple_assign_lhs (stmt))) == BLKmode))\n     return false;\n@@ -332,7 +320,7 @@ statement_sink_location (gimple stmt, basic_block frombb,\n \n   /* If stmt is a store the one and only use needs to be the VOP\n      merging PHI node.  */\n-  if (gimple_vdef (stmt))\n+  if (virtual_operand_p (DEF_FROM_PTR (def_p)))\n     {\n       FOR_EACH_IMM_USE_FAST (use_p, imm_iter, DEF_FROM_PTR (def_p))\n \t{\n@@ -369,15 +357,50 @@ statement_sink_location (gimple stmt, basic_block frombb,\n      common dominator of all the immediate uses.  For PHI nodes, we have to\n      find the nearest common dominator of all of the predecessor blocks, since\n      that is where insertion would have to take place.  */\n-  else if (!all_immediate_uses_same_place (stmt))\n+  else if (gimple_vuse (stmt)\n+\t   || !all_immediate_uses_same_place (def_p))\n     {\n       bool debug_stmts = false;\n-      basic_block commondom = nearest_common_dominator_of_uses (stmt,\n+      basic_block commondom = nearest_common_dominator_of_uses (def_p,\n \t\t\t\t\t\t\t\t&debug_stmts);\n \n       if (commondom == frombb)\n \treturn false;\n \n+      /* If this is a load then do not sink past any stores.\n+\t ???  This is overly simple but cheap.  We basically look\n+\t for an existing load with the same VUSE in the path to one\n+\t of the sink candidate blocks and we adjust commondom to the\n+\t nearest to commondom.  */\n+      if (gimple_vuse (stmt))\n+\t{\n+\t  imm_use_iterator imm_iter;\n+\t  use_operand_p use_p;\n+\t  basic_block found = NULL;\n+\t  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, gimple_vuse (stmt))\n+\t    {\n+\t      gimple use_stmt = USE_STMT (use_p);\n+\t      basic_block bb = gimple_bb (use_stmt);\n+\t      /* For PHI nodes the block we know sth about\n+\t\t is the incoming block with the use.  */\n+\t      if (gimple_code (use_stmt) == GIMPLE_PHI)\n+\t\tbb = EDGE_PRED (bb, PHI_ARG_INDEX_FROM_USE (use_p))->src;\n+\t      /* Any dominator of commondom would be ok with\n+\t         adjusting commondom to that block.  */\n+\t      bb = nearest_common_dominator (CDI_DOMINATORS, bb, commondom);\n+\t      if (!found)\n+\t\tfound = bb;\n+\t      else if (dominated_by_p (CDI_DOMINATORS, bb, found))\n+\t\tfound = bb;\n+\t      /* If we can't improve, stop.  */\n+\t      if (found == commondom)\n+\t\tbreak;\n+\t    }\n+\t  commondom = found;\n+\t  if (commondom == frombb)\n+\t    return false;\n+\t}\n+\n       /* Our common dominator has to be dominated by frombb in order to be a\n \t trivially safe place to put this statement, since it has multiple\n \t uses.  */"}]}