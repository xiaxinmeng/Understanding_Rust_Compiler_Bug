{"sha": "7e4ca97cac069886c2e54674f973f723e68ee912", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U0Y2E5N2NhYzA2OTg4NmMyZTU0Njc0Zjk3M2Y3MjNlNjhlZTkxMg==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-04-10T16:40:32Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-04-12T21:39:45Z"}, "message": "Refactor Method resolution to take advantage of PathProbe\n\nThis canonicalizes method resolution to the Path Probe used for Path expr\nresolution. So any errors will gain the same diagnostics.", "tree": {"sha": "8c40840d2527f2587b4cae90e8f7651cb6917188", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c40840d2527f2587b4cae90e8f7651cb6917188"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e4ca97cac069886c2e54674f973f723e68ee912", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e4ca97cac069886c2e54674f973f723e68ee912", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e4ca97cac069886c2e54674f973f723e68ee912", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e4ca97cac069886c2e54674f973f723e68ee912/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85f587410612c8d2ec65dd23063a849d13005957", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85f587410612c8d2ec65dd23063a849d13005957", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85f587410612c8d2ec65dd23063a849d13005957"}], "stats": {"total": 166, "additions": 89, "deletions": 77}, "files": [{"sha": "b2391e317f0f4a1adec1d291e14f8020c2f8688d", "filename": "gcc/rust/typecheck/rust-hir-method-resolve.h", "status": "modified", "additions": 19, "deletions": 60, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e4ca97cac069886c2e54674f973f723e68ee912/gcc%2Frust%2Ftypecheck%2Frust-hir-method-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e4ca97cac069886c2e54674f973f723e68ee912/gcc%2Frust%2Ftypecheck%2Frust-hir-method-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-method-resolve.h?ref=7e4ca97cac069886c2e54674f973f723e68ee912", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-hir-type-check-base.h\"\n #include \"rust-hir-full.h\"\n #include \"rust-tyty.h\"\n+#include \"rust-hir-path-probe.h\"\n #include \"rust-substitution-mapper.h\"\n \n namespace Rust {\n@@ -32,74 +33,32 @@ class MethodResolution : public TypeCheckBase\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static std::vector<HIR::Method *> Probe (TyTy::BaseType *receiver,\n-\t\t\t\t\t   HIR::PathExprSegment method_name)\n+  static std::vector<PathProbeCandidate>\n+  Probe (std::vector<PathProbeCandidate> &path_candidates)\n   {\n-    MethodResolution probe (receiver, method_name);\n-\n-    // lookup impl items for this crate and find all methods that can resolve to\n-    // this receiver\n-    probe.mappings->iterate_impl_items (\n-      [&] (HirId id, HIR::InherentImplItem *item,\n-\t   HIR::InherentImpl *impl) mutable -> bool {\n-\titem->accept_vis (probe);\n-\treturn true;\n-      });\n-\n-    return probe.probed;\n+    MethodResolution probe;\n+    for (auto &c : path_candidates)\n+      probe.process_candidate (c);\n+\n+    return probe.candidates;\n   }\n \n-  void visit (HIR::Method &method) override\n+  void process_candidate (PathProbeCandidate &candidate)\n   {\n-    TyTy::BaseType *self_lookup = nullptr;\n-    if (!context->lookup_type (\n-\t  method.get_self_param ().get_mappings ().get_hirid (), &self_lookup))\n-      {\n-\trust_error_at (method.get_self_param ().get_locus (),\n-\t\t       \"failed to lookup lookup self type in MethodProbe\");\n-\treturn;\n-      }\n-\n-    // are the names the same\n-    HIR::PathIdentSegment seg = method_name.get_segment ();\n-    if (seg.as_string ().compare (method.get_method_name ()) != 0)\n-      {\n-\t// if the method name does not match then this is not a valid match\n-\treturn;\n-      }\n-\n-    if (self_lookup->get_kind () != receiver->get_kind ())\n-      return;\n-\n-    if (receiver->has_subsititions_defined ()\n-\t!= self_lookup->has_subsititions_defined ())\n-      return;\n-\n-    if (self_lookup->has_subsititions_defined ())\n-      {\n-\t// we assume the receiver should be fully substituted at this stage\n-\tself_lookup = SubstMapperFromExisting::Resolve (receiver, self_lookup);\n-      }\n-\n-    if (!receiver->is_equal (*self_lookup))\n-      {\n-\t// incompatible self argument then this is not a valid method for this\n-\t// receiver\n-\treturn;\n-      }\n-\n-    probed.push_back (&method);\n+    is_method_flag = false;\n+    candidate.impl_item->accept_vis (*this);\n+\n+    if (is_method_flag)\n+      candidates.push_back (candidate);\n   }\n \n-private:\n-  MethodResolution (TyTy::BaseType *receiver, HIR::PathExprSegment method_name)\n-    : TypeCheckBase (), receiver (receiver), method_name (method_name)\n-  {}\n+  void visit (HIR::Method &method) override { is_method_flag = true; }\n \n-  TyTy::BaseType *receiver;\n-  HIR::PathExprSegment method_name;\n+private:\n+  MethodResolution () : TypeCheckBase () {}\n \n-  std::vector<HIR::Method *> probed;\n+  bool is_method_flag;\n+  std::vector<PathProbeCandidate> candidates;\n };\n \n } // namespace Resolver"}, {"sha": "cb2f2502f03c81f9283f1615fed4d26b62d4f3cb", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e4ca97cac069886c2e54674f973f723e68ee912/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e4ca97cac069886c2e54674f973f723e68ee912/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=7e4ca97cac069886c2e54674f973f723e68ee912", "patch": "@@ -210,34 +210,37 @@ class TypeCheckExpr : public TypeCheckBase\n     // which is simple. There will need to be adjustments to ensure we can turn\n     // the receiver into borrowed references etc\n \n-    auto probes\n-      = MethodResolution::Probe (receiver_tyty, expr.get_method_name ());\n-    if (probes.size () == 0)\n+    auto candidates\n+      = PathProbeType::Probe (receiver_tyty,\n+\t\t\t      expr.get_method_name ().get_segment ());\n+    if (candidates.size () == 0)\n       {\n \trust_error_at (expr.get_locus (),\n \t\t       \"failed to resolve the PathExprSegment to any Method\");\n \treturn;\n       }\n-    else if (probes.size () > 1)\n+\n+    // filter all methods\n+    auto possible_methods = MethodResolution::Probe (candidates);\n+    if (possible_methods.size () == 0)\n       {\n-\trust_error_at (\n-\t  expr.get_locus (),\n-\t  \"multiple candidates in MethodCallExpr have been probed is \"\n-\t  \"not currently supported\");\n+\trust_error_at (expr.get_method_name ().get_locus (),\n+\t\t       \"no method named %s found in scope\",\n+\t\t       expr.get_method_name ().as_string ().c_str ());\n \treturn;\n       }\n-\n-    auto resolved_method = probes.at (0);\n-    TyTy::BaseType *lookup_tyty;\n-    if (!context->lookup_type (resolved_method->get_mappings ().get_hirid (),\n-\t\t\t       &lookup_tyty))\n+    else if (possible_methods.size () > 1)\n       {\n-\trust_error_at (resolved_method->get_locus (),\n-\t\t       \"failed to lookup type for CallExpr: %s\",\n-\t\t       expr.as_string ().c_str ());\n+\tReportMultipleCandidateError::Report (\n+\t  possible_methods, expr.get_method_name ().get_segment (),\n+\t  expr.get_method_name ().get_locus ());\n \treturn;\n       }\n \n+    auto resolved_candidate = possible_methods.at (0);\n+    HIR::InherentImplItem *resolved_method = resolved_candidate.impl_item;\n+    TyTy::BaseType *lookup_tyty = resolved_candidate.ty;\n+\n     TyTy::BaseType *lookup = lookup_tyty;\n     if (lookup_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n       {\n@@ -270,7 +273,7 @@ class TypeCheckExpr : public TypeCheckBase\n     // set up the resolved name on the path\n     resolver->insert_resolved_name (\n       expr.get_mappings ().get_nodeid (),\n-      resolved_method->get_mappings ().get_nodeid ());\n+      resolved_method->get_impl_mappings ().get_nodeid ());\n \n     // return the result of the function back\n     infered = function_ret_tyty;"}, {"sha": "adf02ee6f4a8faba715de00686c14d2516efe370", "filename": "gcc/testsuite/rust.test/compile/generics15.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e4ca97cac069886c2e54674f973f723e68ee912/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics15.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e4ca97cac069886c2e54674f973f723e68ee912/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics15.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics15.rs?ref=7e4ca97cac069886c2e54674f973f723e68ee912", "patch": "@@ -0,0 +1,21 @@\n+struct Foo<T>(T, bool);\n+\n+impl Foo<i32> {\n+    fn bar(self) -> i32 {\n+        self.0\n+    }\n+}\n+\n+impl Foo<f32> {\n+    fn bar(self) -> f32 {\n+        self.0\n+    }\n+}\n+\n+fn main() {\n+    let a = Foo(123, true);\n+    let aa = a.bar();\n+\n+    let b = Foo(456f32, true);\n+    let bb = b.bar();\n+}"}, {"sha": "1af24e07159a6a9b7dd1e5ca7e219a7023045b81", "filename": "gcc/testsuite/rust.test/compile/generics16.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e4ca97cac069886c2e54674f973f723e68ee912/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics16.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e4ca97cac069886c2e54674f973f723e68ee912/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics16.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics16.rs?ref=7e4ca97cac069886c2e54674f973f723e68ee912", "patch": "@@ -0,0 +1,29 @@\n+struct Foo<T>(T, bool);\n+\n+impl Foo<i32> {\n+    fn new() -> Self {\n+        Foo(123, true)\n+    }\n+\n+    fn bar(self) -> i32 {\n+        self.0\n+    }\n+}\n+\n+impl Foo<f32> {\n+    fn new() -> Self {\n+        Foo(123f32, true)\n+    }\n+\n+    fn bar(self) -> f32 {\n+        self.0\n+    }\n+}\n+\n+fn main() {\n+    let a = Foo::<i32>::new();\n+    let aa: i32 = a.bar();\n+\n+    let b = Foo::<f32>::new();\n+    let bb: f32 = b.bar();\n+}"}]}