{"sha": "a77a9a18c058d41eeb634e6c6a6f56d9bae04d55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc3YTlhMThjMDU4ZDQxZWViNjM0ZTZjNmE2ZjU2ZDliYWUwNGQ1NQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2002-08-02T11:57:22Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2002-08-02T11:57:22Z"}, "message": "langhooks-def.h (LANG_HOOKS_EXPR_SIZE): New macro.\n\n        * langhooks-def.h (LANG_HOOKS_EXPR_SIZE): New macro.\n        * langhooks.c (lhd_expr_size): Define default.\n        * langhooks.h (struct lang_hooks): Add expr_size.\n        * explow.c (expr_size): Call it.\n        * expr.c (store_expr): Don't copy an expression of size zero.\n        (expand_expr) [CONSTRUCTOR]: Use expr_size to calculate how much\n        to store.\n        * Makefile.in (builtins.o): Depend on langhooks.h.\n\n        * cp-lang.c (LANG_HOOKS_EXPR_SIZE): Define.\n        (cp_expr_size): New fn.\n        * call.c (build_over_call): Lose empty class hackery.\n        (convert_arg_to_ellipsis): Promote non-POD warning to error.\n        * typeck.c (build_modify_expr): Don't use save_expr on an lvalue.\n\nFrom-SVN: r55983", "tree": {"sha": "72cdfa1019e7a95a9c990b7e0b9711b69f589e01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72cdfa1019e7a95a9c990b7e0b9711b69f589e01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "367aa58580632b0bef67f5bbcc41009eb8a09381", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/367aa58580632b0bef67f5bbcc41009eb8a09381", "html_url": "https://github.com/Rust-GCC/gccrs/commit/367aa58580632b0bef67f5bbcc41009eb8a09381"}], "stats": {"total": 132, "additions": 86, "deletions": 46}, "files": [{"sha": "6480ba94aeffb8b501a1f17eab0cac3af17bc34e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a77a9a18c058d41eeb634e6c6a6f56d9bae04d55", "patch": "@@ -1,3 +1,14 @@\n+2002-08-02  Jason Merrill  <jason@redhat.com>\n+\n+\t* langhooks-def.h (LANG_HOOKS_EXPR_SIZE): New macro.\n+\t* langhooks.c (lhd_expr_size): Define default.\n+\t* langhooks.h (struct lang_hooks): Add expr_size.\n+\t* explow.c (expr_size): Call it.\n+\t* expr.c (store_expr): Don't copy an expression of size zero.\n+\t(expand_expr) [CONSTRUCTOR]: Use expr_size to calculate how much\n+\tto store.\n+\t* Makefile.in (builtins.o): Depend on langhooks.h.\n+\n 2002-08-02  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* Makefile.in (ra-debug.o): Depend on $(TM_P_H)."}, {"sha": "c27b5d8f75ace3d04133d69b68458c1a4dc874e4", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=a77a9a18c058d41eeb634e6c6a6f56d9bae04d55", "patch": "@@ -1427,7 +1427,7 @@ expr.o : expr.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h function.h \\\n builtins.o : builtins.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    $(TARGET_H) function.h $(REGS_H) $(EXPR_H) $(OPTABS_H) insn-config.h \\\n    $(RECOG_H) output.h typeclass.h hard-reg-set.h toplev.h hard-reg-set.h \\\n-   except.h $(TM_P_H) $(PREDICT_H) libfuncs.h real.h\n+   except.h $(TM_P_H) $(PREDICT_H) libfuncs.h real.h langhooks.h\n calls.o : calls.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    $(EXPR_H) langhooks.h \\\n    libfuncs.h $(REGS_H) toplev.h output.h function.h $(TIMEVAR_H) $(TM_P_H)"}, {"sha": "e4def020fb70a339900c0526b346edfbd149c041", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a77a9a18c058d41eeb634e6c6a6f56d9bae04d55", "patch": "@@ -1,5 +1,11 @@\n 2002-08-02  Jason Merrill  <jason@redhat.com>\n \n+\t* cp-lang.c (LANG_HOOKS_EXPR_SIZE): Define.\n+\t(cp_expr_size): New fn.\n+\t* call.c (build_over_call): Lose empty class hackery.\n+\t(convert_arg_to_ellipsis): Promote non-POD warning to error.\n+\t* typeck.c (build_modify_expr): Don't use save_expr on an lvalue.\n+\n \t* semantics.c (expand_body): Do tree optimization in the function\n \tcontext, too.\n "}, {"sha": "9029a7072dca319719a19ef99c2853090bc23c50", "filename": "gcc/cp/call.c", "status": "modified", "additions": 9, "deletions": 30, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a77a9a18c058d41eeb634e6c6a6f56d9bae04d55", "patch": "@@ -4111,9 +4111,12 @@ convert_arg_to_ellipsis (arg)\n   \n   if (arg != error_mark_node && ! pod_type_p (TREE_TYPE (arg)))\n     {\n-      /* Undefined behaviour [expr.call] 5.2.2/7.  */\n-      warning (\"cannot pass objects of non-POD type `%#T' through `...'\",\n-\t\t  TREE_TYPE (arg));\n+      /* Undefined behaviour [expr.call] 5.2.2/7.  We used to just warn\n+\t here and do a bitwise copy, but now cp_expr_size will abort if we\n+\t try to do that.  */\n+      error (\"cannot pass objects of non-POD type `%#T' through `...'\",\n+\t     TREE_TYPE (arg));\n+      arg = error_mark_node;\n     }\n \n   return arg;\n@@ -4436,15 +4439,8 @@ build_over_call (cand, args, flags)\n \t  else if (TYPE_HAS_TRIVIAL_INIT_REF (DECL_CONTEXT (fn)))\n \t    return build_target_expr_with_type (arg, DECL_CONTEXT (fn));\n \t}\n-      else if ((!real_lvalue_p (arg)\n-\t\t|| TYPE_HAS_TRIVIAL_INIT_REF (DECL_CONTEXT (fn)))\n-\t       /* Empty classes have padding which can be hidden\n-\t          inside an (empty) base of the class. This must not\n-\t          be touched as it might overlay things. When the\n-\t          gcc core learns about empty classes, we can treat it\n-\t          like other classes. */\n-\t       && !(is_empty_class (DECL_CONTEXT (fn))\n-\t\t    && TYPE_HAS_TRIVIAL_INIT_REF (DECL_CONTEXT (fn))))\n+      else if (!real_lvalue_p (arg)\n+\t       || TYPE_HAS_TRIVIAL_INIT_REF (DECL_CONTEXT (fn)))\n \t{\n \t  tree address;\n \t  tree to = stabilize_reference\n@@ -4466,24 +4462,7 @@ build_over_call (cand, args, flags)\n \t(build_indirect_ref (TREE_VALUE (converted_args), 0));\n \n       arg = build_indirect_ref (TREE_VALUE (TREE_CHAIN (converted_args)), 0);\n-      if (is_empty_class (TREE_TYPE (to)))\n-\t{\n-\t  TREE_USED (arg) = 1;\n-\n-\t  val = build (COMPOUND_EXPR, DECL_CONTEXT (fn), arg, to);\n-\t  /* Even though the assignment may not actually result in any\n-\t     code being generated, we do not want to warn about the\n-\t     assignment having no effect.  That would be confusing to\n-\t     users who may be performing the assignment as part of a\n-\t     generic algorithm, for example.\n-\t     \n-\t     Ideally, the notions of having side-effects and of being\n-\t     useless would be orthogonal.  */\n-\t  TREE_SIDE_EFFECTS (val) = 1;\n-\t  TREE_NO_UNUSED_WARNING (val) = 1;\n-\t}\n-      else\n-\tval = build (MODIFY_EXPR, TREE_TYPE (to), to, arg);\n+      val = build (MODIFY_EXPR, TREE_TYPE (to), to, arg);\n       return val;\n     }\n "}, {"sha": "024534e2831706cdc27d405bb08aafd1b90fbb7f", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=a77a9a18c058d41eeb634e6c6a6f56d9bae04d55", "patch": "@@ -31,6 +31,7 @@ Boston, MA 02111-1307, USA.  */\n static HOST_WIDE_INT cxx_get_alias_set PARAMS ((tree));\n static bool ok_to_generate_alias_set_for_type PARAMS ((tree));\n static bool cxx_warn_unused_global_decl PARAMS ((tree));\n+static tree cp_expr_size PARAMS ((tree));\n \n #undef LANG_HOOKS_NAME\n #define LANG_HOOKS_NAME \"GNU C++\"\n@@ -133,6 +134,8 @@ static bool cxx_warn_unused_global_decl PARAMS ((tree));\n #define LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN cp_dump_tree\n #undef LANG_HOOKS_TREE_DUMP_TYPE_QUALS_FN\n #define LANG_HOOKS_TREE_DUMP_TYPE_QUALS_FN cp_type_quals\n+#undef LANG_HOOKS_EXPR_SIZE\n+#define LANG_HOOKS_EXPR_SIZE cp_expr_size\n \n #undef LANG_HOOKS_MAKE_TYPE\n #define LANG_HOOKS_MAKE_TYPE cxx_make_type\n@@ -280,3 +283,28 @@ cxx_warn_unused_global_decl (decl)\n \n   return true;\n }\n+\n+/* Langhook for expr_size: Tell the backend that the value of an expression\n+   of non-POD class type does not include any tail padding; a derived class\n+   might have allocated something there.  */\n+\n+static tree\n+cp_expr_size (exp)\n+     tree exp;\n+{\n+  if (CLASS_TYPE_P (TREE_TYPE (exp)))\n+    {\n+      /* The backend should not be interested in the size of an expression\n+\t of a type with both of these set; all copies of such types must go\n+\t through a constructor or assignment op.  */\n+      if (TYPE_HAS_COMPLEX_INIT_REF (TREE_TYPE (exp))\n+\t  && TYPE_HAS_COMPLEX_ASSIGN_REF (TREE_TYPE (exp)))\n+\tabort ();\n+      /* This would be wrong for a type with virtual bases, but they are\n+\t caught by the abort above.  */\n+      return CLASSTYPE_SIZE_UNIT (TREE_TYPE (exp));\n+    }\n+  else\n+    /* Use the default code.  */\n+    return lhd_expr_size (exp);\n+}"}, {"sha": "965f3f4399d8468d9f5a5a3856ca003e12fb43e5", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a77a9a18c058d41eeb634e6c6a6f56d9bae04d55", "patch": "@@ -5077,8 +5077,9 @@ build_modify_expr (lhs, modifycode, rhs)\n \t   except that the RHS goes through a save-expr\n \t   so the code to compute it is only emitted once.  */\n \ttree cond;\n+\ttree preeval = NULL_TREE;\n \n-\trhs = save_expr (rhs);\n+\trhs = stabilize_expr (rhs, &preeval);\n \t\n \t/* Check this here to avoid odd errors when trying to convert\n \t   a throw to the type of the COND_EXPR.  */\n@@ -5098,10 +5099,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \t  return cond;\n \t/* Make sure the code to compute the rhs comes out\n \t   before the split.  */\n-\treturn build (COMPOUND_EXPR, TREE_TYPE (lhs),\n-\t\t      /* Cast to void to suppress warning\n-\t\t\t from warn_if_unused_value.  */\n-\t\t      cp_convert (void_type_node, rhs), cond);\n+\treturn build (COMPOUND_EXPR, TREE_TYPE (lhs), preeval, cond);\n       }\n       \n     case OFFSET_REF:"}, {"sha": "5bc34517e8e303ddecfc3a7dad2aa5972231e7e4", "filename": "gcc/explow.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=a77a9a18c058d41eeb634e6c6a6f56d9bae04d55", "patch": "@@ -34,6 +34,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"insn-config.h\"\n #include \"ggc.h\"\n #include \"recog.h\"\n+#include \"langhooks.h\"\n \n static rtx break_out_memory_refs\tPARAMS ((rtx));\n static void emit_stack_probe\t\tPARAMS ((rtx));\n@@ -285,20 +286,13 @@ rtx\n expr_size (exp)\n      tree exp;\n {\n-  tree size;\n-\n-  if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'd'\n-      && DECL_SIZE_UNIT (exp) != 0)\n-    size = DECL_SIZE_UNIT (exp);\n-  else\n-    size = size_in_bytes (TREE_TYPE (exp));\n+  tree size = (*lang_hooks.expr_size) (exp);\n \n   if (TREE_CODE (size) != INTEGER_CST\n       && contains_placeholder_p (size))\n     size = build (WITH_RECORD_EXPR, sizetype, size, exp);\n \n   return expand_expr (size, NULL_RTX, TYPE_MODE (sizetype), 0);\n-\n }\n \f\n /* Return a copy of X in which all memory references"}, {"sha": "dddd26877709b88b1081679c6d0fbce2bd8e9ada", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=a77a9a18c058d41eeb634e6c6a6f56d9bae04d55", "patch": "@@ -4241,6 +4241,8 @@ store_expr (exp, target, want_value)\n        || (temp != target && (side_effects_p (temp)\n \t\t\t      || side_effects_p (target))))\n       && TREE_CODE (exp) != ERROR_MARK\n+      /* If there's nothing to copy, don't bother.  */\n+      && expr_size (exp) != const0_rtx\n       && ! dont_store_target\n \t /* If store_expr stores a DECL whose DECL_RTL(exp) == TARGET,\n \t    but TARGET is not valid memory reference, TEMP will differ\n@@ -6810,8 +6812,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t\t\t       * TYPE_QUAL_CONST))),\n \t\t\t     0, TREE_ADDRESSABLE (exp), 1);\n \n-\t  store_constructor (exp, target, 0,\n-\t\t\t     int_size_in_bytes (TREE_TYPE (exp)));\n+\t  store_constructor (exp, target, 0, INTVAL (expr_size (exp)));\n \t  return target;\n \t}\n "}, {"sha": "d8628513559ef55c6a562a392255d8df3c0b71c3", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=a77a9a18c058d41eeb634e6c6a6f56d9bae04d55", "patch": "@@ -62,6 +62,7 @@ extern void lhd_set_decl_assembler_name PARAMS ((tree));\n extern bool lhd_warn_unused_global_decl PARAMS ((tree));\n extern void lhd_incomplete_type_error PARAMS ((tree, tree));\n extern tree lhd_type_promotes_to PARAMS ((tree));\n+extern tree lhd_expr_size PARAMS ((tree));\n \n /* Declarations of default tree inlining hooks.  */\n tree lhd_tree_inlining_walk_subtrees\t\tPARAMS ((tree *, int *,\n@@ -109,6 +110,7 @@ tree lhd_tree_inlining_convert_parm_for_inlining PARAMS ((tree, tree, tree));\n #define LANG_HOOKS_PRINT_IDENTIFIER\tlhd_print_tree_nothing\n #define LANG_HOOKS_PRINT_ERROR_FUNCTION lhd_print_error_function\n #define LANG_HOOKS_DECL_PRINTABLE_NAME\tlhd_decl_printable_name\n+#define LANG_HOOKS_EXPR_SIZE\t\tlhd_expr_size\n \n #define LANG_HOOKS_FUNCTION_INIT\tlhd_do_nothing_f\n #define LANG_HOOKS_FUNCTION_FINAL\tlhd_do_nothing_f\n@@ -247,6 +249,7 @@ int lhd_tree_dump_type_quals\t\t\tPARAMS ((tree));\n   LANG_HOOKS_PRINT_IDENTIFIER, \\\n   LANG_HOOKS_DECL_PRINTABLE_NAME, \\\n   LANG_HOOKS_PRINT_ERROR_FUNCTION, \\\n+  LANG_HOOKS_EXPR_SIZE, \\\n   LANG_HOOKS_ATTRIBUTE_TABLE, \\\n   LANG_HOOKS_COMMON_ATTRIBUTE_TABLE, \\\n   LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE, \\"}, {"sha": "e2feb06736040ab135df139a0af99343dcc6c2b5", "filename": "gcc/langhooks.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=a77a9a18c058d41eeb634e6c6a6f56d9bae04d55", "patch": "@@ -421,3 +421,17 @@ lhd_tree_dump_type_quals (t)\n {\n   return TYPE_QUALS (t);\n }\n+\n+/* lang_hooks.expr_size: Determine the size of the value of an expression T\n+   in a language-specific way.  Returns a tree for the size in bytes.  */\n+\n+tree\n+lhd_expr_size (exp)\n+     tree exp;\n+{\n+  if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'd'\n+      && DECL_SIZE_UNIT (exp) != 0)\n+    return DECL_SIZE_UNIT (exp);\n+  else\n+    return size_in_bytes (TREE_TYPE (exp));\n+}"}, {"sha": "7ddd32c88f7c7166d26c265407975148a421e826", "filename": "gcc/langhooks.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=a77a9a18c058d41eeb634e6c6a6f56d9bae04d55", "patch": "@@ -328,6 +328,12 @@ struct lang_hooks\n   void (*print_error_function) PARAMS ((struct diagnostic_context *,\n \t\t\t\t\tconst char *));\n \n+  /* Called from expr_size to calculate the size of the value of an\n+     expression in a language-dependent way.  Returns a tree for the size\n+     in bytes.  A frontend can call lhd_expr_size to get the default\n+     semantics in cases that it doesn't want to handle specially.  */\n+  tree (*expr_size) PARAMS ((tree));\n+\n   /* Pointers to machine-independent attribute tables, for front ends\n      using attribs.c.  If one is NULL, it is ignored.  Respectively, a\n      table of attributes specific to the language, a table of"}]}