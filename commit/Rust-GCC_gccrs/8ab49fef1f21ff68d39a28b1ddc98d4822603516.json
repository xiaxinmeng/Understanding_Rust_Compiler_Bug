{"sha": "8ab49fef1f21ff68d39a28b1ddc98d4822603516", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFiNDlmZWYxZjIxZmY2OGQzOWEyOGIxZGRjOThkNDgyMjYwMzUxNg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-08-14T20:53:26Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-08-14T20:53:26Z"}, "message": "fold-const.c (negate_expr_p): MULT_EXPRs and RDIV_EXPRs are easy to negate if either operand is easy to negate...\n\n\n\t* fold-const.c (negate_expr_p): MULT_EXPRs and RDIV_EXPRs are easy\n\tto negate if either operand is easy to negate, if we don't care\n\tabout sign-dependent rounding.\n\t(negate_expr): Make the logic to negate a REAL_CST explicit.\n\tAttempt to negate a MULT_EXPR or RDIV_EXPR by negating an operand\n\tthat's easy to negate, if we don't honor sign-dependent rounding.\n\t(fold <MULT_EXPR>): Optimize -A * B as A * -B if B is easy to\n\tnegate, and the symmetric A * -B as -A * B if A is easy to negate.\n\t(fold <RDIV_EXPR>): Likewise, optimize -A/B and C/-D as A/-B and\n\t-C/D if B and C are cheap to negate.  Add an explicit rule to\n\toptimize X/-1.0 as -X when we don't care about signaling NaNs.\n\nFrom-SVN: r70455", "tree": {"sha": "9a1c805b0d9f0abdd6f5f935e7f53f0fb1091c08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a1c805b0d9f0abdd6f5f935e7f53f0fb1091c08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ab49fef1f21ff68d39a28b1ddc98d4822603516", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ab49fef1f21ff68d39a28b1ddc98d4822603516", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ab49fef1f21ff68d39a28b1ddc98d4822603516", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ab49fef1f21ff68d39a28b1ddc98d4822603516/comments", "author": null, "committer": null, "parents": [{"sha": "74bed51bf60b6c4a51a05b6fa54cde5be2194b40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74bed51bf60b6c4a51a05b6fa54cde5be2194b40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74bed51bf60b6c4a51a05b6fa54cde5be2194b40"}], "stats": {"total": 81, "additions": 76, "deletions": 5}, "files": [{"sha": "159dc12c7372bb99102c02829bef68af54d6b47b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab49fef1f21ff68d39a28b1ddc98d4822603516/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab49fef1f21ff68d39a28b1ddc98d4822603516/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8ab49fef1f21ff68d39a28b1ddc98d4822603516", "patch": "@@ -1,3 +1,17 @@\n+2003-08-14  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (negate_expr_p): MULT_EXPRs and RDIV_EXPRs are easy\n+\tto negate if either operand is easy to negate, if we don't care\n+\tabout sign-dependent rounding.\n+\t(negate_expr): Make the logic to negate a REAL_CST explicit.\n+\tAttempt to negate a MULT_EXPR or RDIV_EXPR by negating an operand\n+\tthat's easy to negate, if we don't honor sign-dependent rounding.\n+\t(fold <MULT_EXPR>): Optimize -A * B as A * -B if B is easy to\n+\tnegate, and the symmetric A * -B as -A * B if A is easy to negate.\n+\t(fold <RDIV_EXPR>): Likewise, optimize -A/B and C/-D as A/-B and\n+\t-C/D if B and C are cheap to negate.  Add an explicit rule to\n+\toptimize X/-1.0 as -X when we don't care about signaling NaNs.\n+\n 2003-08-14  Zack Weinberg  <zack@codesourcery.com>\n \n \t* Makefile.in (tm_file): Rename tm_include_list."}, {"sha": "11d0f9d0f74a7b0abf458309ac15348af8239da5", "filename": "gcc/fold-const.c", "status": "modified", "additions": 62, "deletions": 5, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab49fef1f21ff68d39a28b1ddc98d4822603516/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab49fef1f21ff68d39a28b1ddc98d4822603516/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=8ab49fef1f21ff68d39a28b1ddc98d4822603516", "patch": "@@ -847,6 +847,18 @@ negate_expr_p (tree t)\n       /* We can't turn -(A-B) into B-A when we honor signed zeros.  */\n       return ! FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations;\n \n+    case MULT_EXPR:\n+      if (TREE_UNSIGNED (TREE_TYPE (t)))\n+        break;\n+\n+      /* Fall through.  */\n+\n+    case RDIV_EXPR:\n+      if (! HONOR_SIGN_DEPENDENT_ROUNDING (TYPE_MODE (TREE_TYPE (t))))\n+\treturn negate_expr_p (TREE_OPERAND (t, 1))\n+\t       || negate_expr_p (TREE_OPERAND (t, 0));\n+      break;\n+\n     default:\n       break;\n     }\n@@ -871,13 +883,19 @@ negate_expr (tree t)\n   switch (TREE_CODE (t))\n     {\n     case INTEGER_CST:\n-    case REAL_CST:\n       if (! TREE_UNSIGNED (type)\n \t  && 0 != (tem = fold (build1 (NEGATE_EXPR, type, t)))\n \t  && ! TREE_OVERFLOW (tem))\n \treturn tem;\n       break;\n \n+    case REAL_CST:\n+      tem = build_real (type, REAL_VALUE_NEGATE (TREE_REAL_CST (t)));\n+      /* Two's complement FP formats, such as c4x, may overflow.  */\n+      if (! TREE_OVERFLOW (tem))\n+\treturn convert (type, tem);\n+      break;\n+\n     case NEGATE_EXPR:\n       return convert (type, TREE_OPERAND (t, 0));\n \n@@ -890,6 +908,30 @@ negate_expr (tree t)\n \t\t\t\t     TREE_OPERAND (t, 0))));\n       break;\n \n+    case MULT_EXPR:\n+      if (TREE_UNSIGNED (TREE_TYPE (t)))\n+        break;\n+\n+      /* Fall through.  */\n+\n+    case RDIV_EXPR:\n+      if (! HONOR_SIGN_DEPENDENT_ROUNDING (TYPE_MODE (TREE_TYPE (t))))\n+\t{\n+\t  tem = TREE_OPERAND (t, 1);\n+\t  if (negate_expr_p (tem))\n+\t    return convert (type,\n+\t\t\t    fold (build (TREE_CODE (t), TREE_TYPE (t),\n+\t\t\t\t\t TREE_OPERAND (t, 0),\n+\t\t\t\t\t negate_expr (tem))));\n+\t  tem = TREE_OPERAND (t, 0);\n+\t  if (negate_expr_p (tem))\n+\t    return convert (type,\n+\t\t\t    fold (build (TREE_CODE (t), TREE_TYPE (t),\n+\t\t\t\t\t negate_expr (tem),\n+\t\t\t\t\t TREE_OPERAND (t, 1))));\n+\t}\n+      break;\n+\n     default:\n       break;\n     }\n@@ -5965,8 +6007,13 @@ fold (tree expr)\n \n     case MULT_EXPR:\n       /* (-A) * (-B) -> A * B  */\n-      if (TREE_CODE (arg0) == NEGATE_EXPR && TREE_CODE (arg1) == NEGATE_EXPR)\n-\treturn fold (build (MULT_EXPR, type, TREE_OPERAND (arg0, 0),\n+      if (TREE_CODE (arg0) == NEGATE_EXPR && negate_expr_p (arg1))\n+\treturn fold (build (MULT_EXPR, type,\n+\t\t\t    TREE_OPERAND (arg0, 0),\n+\t\t\t    negate_expr (arg1)));\n+      if (TREE_CODE (arg1) == NEGATE_EXPR && negate_expr_p (arg0))\n+\treturn fold (build (MULT_EXPR, type,\n+\t\t\t    negate_expr (arg0),\n \t\t\t    TREE_OPERAND (arg1, 0)));\n \n       if (! FLOAT_TYPE_P (type))\n@@ -6315,15 +6362,25 @@ fold (tree expr)\n \treturn t;\n \n       /* (-A) / (-B) -> A / B  */\n-      if (TREE_CODE (arg0) == NEGATE_EXPR && TREE_CODE (arg1) == NEGATE_EXPR)\n-\treturn fold (build (RDIV_EXPR, type, TREE_OPERAND (arg0, 0),\n+      if (TREE_CODE (arg0) == NEGATE_EXPR && negate_expr_p (arg1))\n+\treturn fold (build (RDIV_EXPR, type,\n+\t\t\t    TREE_OPERAND (arg0, 0),\n+\t\t\t    negate_expr (arg1)));\n+      if (TREE_CODE (arg1) == NEGATE_EXPR && negate_expr_p (arg0))\n+\treturn fold (build (RDIV_EXPR, type,\n+\t\t\t    negate_expr (arg0),\n \t\t\t    TREE_OPERAND (arg1, 0)));\n \n       /* In IEEE floating point, x/1 is not equivalent to x for snans.  */\n       if (!HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0)))\n \t  && real_onep (arg1))\n \treturn non_lvalue (convert (type, arg0));\n \n+      /* In IEEE floating point, x/-1 is not equivalent to -x for snans.  */\n+      if (!HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0)))\n+\t  && real_minus_onep (arg1))\n+\treturn non_lvalue (convert (type, negate_expr (arg0)));\n+\n       /* If ARG1 is a constant, we can convert this to a multiply by the\n \t reciprocal.  This does not have the same rounding properties,\n \t so only do this if -funsafe-math-optimizations.  We can actually"}]}