{"sha": "07e30160beaa207f56f170900fac0d799c6af410", "node_id": "C_kwDOANBUbNoAKDA3ZTMwMTYwYmVhYTIwN2Y1NmYxNzA5MDBmYWMwZDc5OWM2YWY0MTA", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-09-09T21:11:42Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-09-09T21:11:42Z"}, "message": "analyzer: add support for plugin-supplied known function behaviors\n\nThis patch adds the ability for plugins to register \"known functions\"\nwith the analyzer, identified by name.  If -fanalyzer sees a call to\nsuch a function (with no body), it will use a plugin-provided subclass\nof the new known_function abstract base class to model the possible\noutcomes of the function call.\n\ngcc/ChangeLog:\n\t* Makefile.in (ANALYZER_OBJS): Add\n\tanalyzer/known-function-manager.o.\n\ngcc/analyzer/ChangeLog:\n\t* analyzer.h (class known_function_manager): New forward decl.\n\t(class known_function): New.\n\t(plugin_analyzer_init_iface::register_known_function): New.\n\t* engine.cc: Include \"analyzer/known-function-manager.h\".\n\t(plugin_analyzer_init_impl::plugin_analyzer_init_impl): Add\n\tknown_fn_mgr param.\n\t(plugin_analyzer_init_impl::register_state_machine): Add\n\tLOC_SCOPE.\n\t(plugin_analyzer_init_impl::register_known_function): New.\n\t(plugin_analyzer_init_impl::m_known_fn_mgr): New.\n\t(impl_run_checkers): Update plugin callback invocation to use\n\teng's known_function_manager.\n\t* known-function-manager.cc: New file.\n\t* known-function-manager.h: New file.\n\t* region-model-manager.cc\n\t(region_model_manager::region_model_manager): Pass logger to\n\tm_known_fn_mgr's ctor.\n\t* region-model.cc (region_model::update_for_zero_return): New.\n\t(region_model::update_for_nonzero_return): New.\n\t(maybe_simplify_upper_bound): New.\n\t(region_model::maybe_get_copy_bounds): New.\n\t(region_model::get_known_function): New.\n\t(region_model::on_call_pre): Handle plugin-supplied known\n\tfunctions.\n\t* region-model.h: Include \"analyzer/known-function-manager.h\".\n\t(region_model_manager::get_known_function_manager): New.\n\t(region_model_manager::m_known_fn_mgr): New.\n\t(call_details::get_model): New accessor.\n\t(region_model::maybe_get_copy_bounds): New decl.\n\t(region_model::update_for_zero_return): New decl.\n\t(region_model::update_for_nonzero_return): New decl.\n\t(region_model::get_known_function): New decl.\n\t(region_model::get_known_function_manager): New.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/plugin/analyzer_known_fns_plugin.c: New test plugin.\n\t* gcc.dg/plugin/known-fns-1.c: New test.\n\t* gcc.dg/plugin/plugin.exp (plugin_test_list): Add the new plugin\n\tand test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "76a87f37f5031b99f173e7f152f8bfd172e10515", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76a87f37f5031b99f173e7f152f8bfd172e10515"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07e30160beaa207f56f170900fac0d799c6af410", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07e30160beaa207f56f170900fac0d799c6af410", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07e30160beaa207f56f170900fac0d799c6af410", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07e30160beaa207f56f170900fac0d799c6af410/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "084dc9a0c6cec14596093ad077fc3e25c6b99bc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/084dc9a0c6cec14596093ad077fc3e25c6b99bc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/084dc9a0c6cec14596093ad077fc3e25c6b99bc3"}], "stats": {"total": 550, "additions": 548, "deletions": 2}, "files": [{"sha": "a4689d52e36d83128ad76c67ed21eea715195e59", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e30160beaa207f56f170900fac0d799c6af410/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e30160beaa207f56f170900fac0d799c6af410/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=07e30160beaa207f56f170900fac0d799c6af410", "patch": "@@ -1262,6 +1262,7 @@ ANALYZER_OBJS = \\\n \tanalyzer/engine.o \\\n \tanalyzer/feasible-graph.o \\\n \tanalyzer/function-set.o \\\n+\tanalyzer/known-function-manager.o \\\n \tanalyzer/pending-diagnostic.o \\\n \tanalyzer/program-point.o \\\n \tanalyzer/program-state.o \\"}, {"sha": "b325aee37ce959b3136168b2d2d6e5f9de69450a", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e30160beaa207f56f170900fac0d799c6af410/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e30160beaa207f56f170900fac0d799c6af410/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=07e30160beaa207f56f170900fac0d799c6af410", "patch": "@@ -113,6 +113,7 @@ class engine;\n class state_machine;\n class logger;\n class visitor;\n+class known_function_manager;\n \n /* Forward decls of functions.  */\n \n@@ -218,12 +219,24 @@ extern location_t get_stmt_location (const gimple *stmt, function *fun);\n \n extern bool compat_types_p (tree src_type, tree dst_type);\n \n+/* Abstract base class for simulating the behavior of known functions,\n+   supplied by plugins.  */\n+\n+class known_function\n+{\n+public:\n+  virtual ~known_function () {}\n+  virtual void impl_call_pre (const call_details &cd) const = 0;\n+};\n+\n /* Passed by pointer to PLUGIN_ANALYZER_INIT callbacks.  */\n \n class plugin_analyzer_init_iface\n {\n public:\n   virtual void register_state_machine (state_machine *) = 0;\n+  virtual void register_known_function (const char *name,\n+\t\t\t\t\tknown_function *) = 0;\n   virtual logger *get_logger () const = 0;\n };\n "}, {"sha": "742ac02e4f28d8bf9c85fecdba8c2f8325190ce5", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e30160beaa207f56f170900fac0d799c6af410/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e30160beaa207f56f170900fac0d799c6af410/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=07e30160beaa207f56f170900fac0d799c6af410", "patch": "@@ -71,6 +71,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"tree-dfa.h\"\n+#include \"analyzer/known-function-manager.h\"\n \n /* For an overview, see gcc/doc/analyzer.texi.  */\n \n@@ -5813,23 +5814,34 @@ class plugin_analyzer_init_impl : public plugin_analyzer_init_iface\n {\n public:\n   plugin_analyzer_init_impl (auto_delete_vec <state_machine> *checkers,\n+\t\t\t     known_function_manager *known_fn_mgr,\n \t\t\t     logger *logger)\n   : m_checkers (checkers),\n+    m_known_fn_mgr (known_fn_mgr),\n     m_logger (logger)\n   {}\n \n   void register_state_machine (state_machine *sm) final override\n   {\n+    LOG_SCOPE (m_logger);\n     m_checkers->safe_push (sm);\n   }\n \n+  void register_known_function (const char *name,\n+\t\t\t\tknown_function *kf) final override\n+  {\n+    LOG_SCOPE (m_logger);\n+    m_known_fn_mgr->add (name, kf);\n+  }\n+\n   logger *get_logger () const final override\n   {\n     return m_logger;\n   }\n \n private:\n   auto_delete_vec <state_machine> *m_checkers;\n+  known_function_manager *m_known_fn_mgr;\n   logger *m_logger;\n };\n \n@@ -5885,7 +5897,9 @@ impl_run_checkers (logger *logger)\n   auto_delete_vec <state_machine> checkers;\n   make_checkers (checkers, logger);\n \n-  plugin_analyzer_init_impl data (&checkers, logger);\n+  plugin_analyzer_init_impl data (&checkers,\n+\t\t\t\t  eng.get_known_function_manager (),\n+\t\t\t\t  logger);\n   invoke_plugin_callbacks (PLUGIN_ANALYZER_INIT, &data);\n \n   if (logger)"}, {"sha": "f0fd4fc527174877f8f1468550fc3f272b3c1db5", "filename": "gcc/analyzer/known-function-manager.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e30160beaa207f56f170900fac0d799c6af410/gcc%2Fanalyzer%2Fknown-function-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e30160beaa207f56f170900fac0d799c6af410/gcc%2Fanalyzer%2Fknown-function-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fknown-function-manager.cc?ref=07e30160beaa207f56f170900fac0d799c6af410", "patch": "@@ -0,0 +1,78 @@\n+/* Support for plugin-supplied behaviors of known functions.\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"diagnostic-core.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"stringpool.h\"\n+#include \"analyzer/known-function-manager.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* class known_function_manager : public log_user.  */\n+\n+known_function_manager::known_function_manager (logger *logger)\n+: log_user (logger)\n+{\n+}\n+\n+known_function_manager::~known_function_manager ()\n+{\n+  /* Delete all owned kfs.  */\n+  for (auto iter : m_map_id_to_kf)\n+    delete iter.second;\n+}\n+\n+void\n+known_function_manager::add (const char *name, known_function *kf)\n+{\n+  LOG_FUNC_1 (get_logger (), \"registering %s\", name);\n+  tree id = get_identifier (name);\n+  m_map_id_to_kf.put (id, kf);\n+}\n+\n+const known_function *\n+known_function_manager::get_by_identifier (tree identifier)\n+{\n+  known_function **slot = m_map_id_to_kf.get (identifier);\n+  if (slot)\n+    return *slot;\n+  else\n+    return NULL;\n+}\n+\n+const known_function *\n+known_function_manager::get_by_fndecl (tree fndecl)\n+{\n+  if (tree identifier = DECL_NAME (fndecl))\n+    return get_by_identifier (identifier);\n+  return NULL;\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "fbde853a721b1af0d5aeb95b4635a09c1ca79a60", "filename": "gcc/analyzer/known-function-manager.h", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e30160beaa207f56f170900fac0d799c6af410/gcc%2Fanalyzer%2Fknown-function-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e30160beaa207f56f170900fac0d799c6af410/gcc%2Fanalyzer%2Fknown-function-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fknown-function-manager.h?ref=07e30160beaa207f56f170900fac0d799c6af410", "patch": "@@ -0,0 +1,45 @@\n+/* Support for plugin-supplied behaviors of known functions.\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_KNOWN_FUNCTION_MANAGER_H\n+#define GCC_ANALYZER_KNOWN_FUNCTION_MANAGER_H\n+\n+namespace ana {\n+\n+class known_function_manager : public log_user\n+{\n+public:\n+  known_function_manager (logger *logger);\n+  ~known_function_manager ();\n+  void add (const char *name, known_function *kf);\n+  const known_function *get_by_identifier (tree identifier);\n+  const known_function *get_by_fndecl (tree fndecl);\n+\n+private:\n+  DISABLE_COPY_AND_ASSIGN (known_function_manager);\n+\n+  /* Map from identifier to known_function instance.\n+     Has ownership of the latter.  */\n+  hash_map<tree, known_function *> m_map_id_to_kf;\n+};\n+\n+} // namespace ana\n+\n+#endif /* GCC_ANALYZER_KNOWN_FUNCTION_MANAGER_H */"}, {"sha": "cbda77f3d9ce482041763e6282f02fc33645bbe7", "filename": "gcc/analyzer/region-model-manager.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e30160beaa207f56f170900fac0d799c6af410/gcc%2Fanalyzer%2Fregion-model-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e30160beaa207f56f170900fac0d799c6af410/gcc%2Fanalyzer%2Fregion-model-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.cc?ref=07e30160beaa207f56f170900fac0d799c6af410", "patch": "@@ -81,7 +81,8 @@ region_model_manager::region_model_manager (logger *logger)\n   m_globals_region (alloc_region_id (), &m_root_region),\n   m_globals_map (),\n   m_store_mgr (this),\n-  m_range_mgr (new bounded_ranges_manager ())\n+  m_range_mgr (new bounded_ranges_manager ()),\n+  m_known_fn_mgr (logger)\n {\n }\n "}, {"sha": "bc9db69315f67bbdf1e633079d7ba6e421a41410", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e30160beaa207f56f170900fac0d799c6af410/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e30160beaa207f56f170900fac0d799c6af410/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=07e30160beaa207f56f170900fac0d799c6af410", "patch": "@@ -1968,6 +1968,110 @@ maybe_get_const_fn_result (const call_details &cd)\n   return sval;\n }\n \n+/* Update this model for an outcome of a call that returns zero.\n+   If UNMERGEABLE, then make the result unmergeable, e.g. to prevent\n+   the state-merger code from merging success and failure outcomes.  */\n+\n+void\n+region_model::update_for_zero_return (const call_details &cd,\n+\t\t\t\t      bool unmergeable)\n+{\n+  if (!cd.get_lhs_type ())\n+    return;\n+  const svalue *result\n+    = m_mgr->get_or_create_int_cst (cd.get_lhs_type (), 0);\n+  if (unmergeable)\n+    result = m_mgr->get_or_create_unmergeable (result);\n+  set_value (cd.get_lhs_region (), result, cd.get_ctxt ());\n+}\n+\n+/* Update this model for an outcome of a call that returns non-zero.  */\n+\n+void\n+region_model::update_for_nonzero_return (const call_details &cd)\n+{\n+  if (!cd.get_lhs_type ())\n+    return;\n+  const svalue *zero\n+    = m_mgr->get_or_create_int_cst (cd.get_lhs_type (), 0);\n+  const svalue *result\n+    = get_store_value (cd.get_lhs_region (), cd.get_ctxt ());\n+  add_constraint (result, NE_EXPR, zero, cd.get_ctxt ());\n+}\n+\n+/* Subroutine of region_model::maybe_get_copy_bounds.\n+   The Linux kernel commonly uses\n+     min_t([unsigned] long, VAR, sizeof(T));\n+   to set an upper bound on the size of a copy_to_user.\n+   Attempt to simplify such sizes by trying to get the upper bound as a\n+   constant.\n+   Return the simplified svalue if possible, or NULL otherwise.  */\n+\n+static const svalue *\n+maybe_simplify_upper_bound (const svalue *num_bytes_sval,\n+\t\t\t    region_model_manager *mgr)\n+{\n+  tree type = num_bytes_sval->get_type ();\n+  while (const svalue *raw = num_bytes_sval->maybe_undo_cast ())\n+    num_bytes_sval = raw;\n+  if (const binop_svalue *binop_sval = num_bytes_sval->dyn_cast_binop_svalue ())\n+    if (binop_sval->get_op () == MIN_EXPR)\n+      if (binop_sval->get_arg1 ()->get_kind () == SK_CONSTANT)\n+\t{\n+\t  return mgr->get_or_create_cast (type, binop_sval->get_arg1 ());\n+\t  /* TODO: we might want to also capture the constraint\n+\t     when recording the diagnostic, or note that we're using\n+\t     the upper bound.  */\n+\t}\n+  return NULL;\n+}\n+\n+/* Attempt to get an upper bound for the size of a copy when simulating a\n+   copy function.\n+\n+   NUM_BYTES_SVAL is the symbolic value for the size of the copy.\n+   Use it if it's constant, otherwise try to simplify it.  Failing\n+   that, use the size of SRC_REG if constant.\n+\n+   Return a symbolic value for an upper limit on the number of bytes\n+   copied, or NULL if no such value could be determined.  */\n+\n+const svalue *\n+region_model::maybe_get_copy_bounds (const region *src_reg,\n+\t\t\t\t     const svalue *num_bytes_sval)\n+{\n+  if (num_bytes_sval->maybe_get_constant ())\n+    return num_bytes_sval;\n+\n+  if (const svalue *simplified\n+      = maybe_simplify_upper_bound (num_bytes_sval, m_mgr))\n+    num_bytes_sval = simplified;\n+\n+  if (num_bytes_sval->maybe_get_constant ())\n+    return num_bytes_sval;\n+\n+  /* For now, try just guessing the size as the capacity of the\n+     base region of the src.\n+     This is a hack; we might get too large a value.  */\n+  const region *src_base_reg = src_reg->get_base_region ();\n+  num_bytes_sval = get_capacity (src_base_reg);\n+\n+  if (num_bytes_sval->maybe_get_constant ())\n+    return num_bytes_sval;\n+\n+  /* Non-constant: give up. */\n+  return NULL;\n+}\n+\n+/* Get any known_function for FNDECL, or NULL if there is none.  */\n+\n+const known_function *\n+region_model::get_known_function (tree fndecl) const\n+{\n+  known_function_manager *known_fn_mgr = m_mgr->get_known_function_manager ();\n+  return known_fn_mgr->get_by_fndecl (fndecl);\n+}\n+\n /* Update this model for the CALL stmt, using CTXT to report any\n    diagnostics - the first half.\n \n@@ -2224,6 +2328,11 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt,\n \t{\n \t  /* Handle in \"on_call_post\".  */\n \t}\n+      else if (const known_function *kf = get_known_function (callee_fndecl))\n+\t{\n+\t  kf->impl_call_pre (cd);\n+\t  return false;\n+\t}\n       else if (!fndecl_has_gimple_body_p (callee_fndecl)\n \t       && (!(callee_fndecl_flags & (ECF_CONST | ECF_PURE)))\n \t       && !fndecl_built_in_p (callee_fndecl))"}, {"sha": "8d2e3daec28747486a01d53d89e9a8d229420f91", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e30160beaa207f56f170900fac0d799c6af410/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e30160beaa207f56f170900fac0d799c6af410/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=07e30160beaa207f56f170900fac0d799c6af410", "patch": "@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"analyzer/svalue.h\"\n #include \"analyzer/region.h\"\n+#include \"analyzer/known-function-manager.h\"\n \n using namespace ana;\n \n@@ -347,6 +348,11 @@ class region_model_manager\n   store_manager *get_store_manager () { return &m_store_mgr; }\n   bounded_ranges_manager *get_range_manager () const { return m_range_mgr; }\n \n+  known_function_manager *get_known_function_manager ()\n+  {\n+    return &m_known_fn_mgr;\n+  }\n+\n   /* Dynamically-allocated region instances.\n      The number of these within the analysis can grow arbitrarily.\n      They are still owned by the manager.  */\n@@ -504,6 +510,8 @@ class region_model_manager\n \n   bounded_ranges_manager *m_range_mgr;\n \n+  known_function_manager m_known_fn_mgr;\n+\n   /* \"Dynamically-allocated\" region instances.\n      The number of these within the analysis can grow arbitrarily.\n      They are still owned by the manager.  */\n@@ -521,6 +529,7 @@ class call_details\n   call_details (const gcall *call, region_model *model,\n \t\tregion_model_context *ctxt);\n \n+  region_model *get_model () const { return m_model; }\n   region_model_manager *get_manager () const;\n   region_model_context *get_ctxt () const { return m_ctxt; }\n   uncertainty_t *get_uncertainty () const;\n@@ -645,6 +654,12 @@ class region_model\n   void impl_call_va_arg (const call_details &cd);\n   void impl_call_va_end (const call_details &cd);\n \n+  const svalue *maybe_get_copy_bounds (const region *src_reg,\n+\t\t\t\t       const svalue *num_bytes_sval);\n+  void update_for_zero_return (const call_details &cd,\n+\t\t\t       bool unmergeable);\n+  void update_for_nonzero_return (const call_details &cd);\n+\n   void handle_unrecognized_call (const gcall *call,\n \t\t\t\t region_model_context *ctxt);\n   void get_reachable_svalues (svalue_set *out,\n@@ -815,6 +830,8 @@ class region_model\n   get_representative_path_var_1 (const region *reg,\n \t\t\t\t svalue_set *visited) const;\n \n+  const known_function *get_known_function (tree fndecl) const;\n+\n   bool add_constraint (const svalue *lhs,\n \t\t       enum tree_code op,\n \t\t       const svalue *rhs,\n@@ -1324,6 +1341,10 @@ class engine\n   engine (const supergraph *sg = NULL, logger *logger = NULL);\n   const supergraph *get_supergraph () { return m_sg; }\n   region_model_manager *get_model_manager () { return &m_mgr; }\n+  known_function_manager *get_known_function_manager ()\n+  {\n+    return m_mgr.get_known_function_manager ();\n+  }\n \n   void log_stats (logger *logger) const;\n "}, {"sha": "060a3082fd68886692c067eae70baff0753f2d7e", "filename": "gcc/testsuite/gcc.dg/plugin/analyzer_known_fns_plugin.c", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e30160beaa207f56f170900fac0d799c6af410/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_known_fns_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e30160beaa207f56f170900fac0d799c6af410/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_known_fns_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_known_fns_plugin.c?ref=07e30160beaa207f56f170900fac0d799c6af410", "patch": "@@ -0,0 +1,201 @@\n+/* Proof-of-concept of a -fanalyzer plugin to handle known functions.  */\n+/* { dg-options \"-g\" } */\n+\n+#include \"gcc-plugin.h\"\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"diagnostic-core.h\"\n+#include \"graphviz.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"tree-dfa.h\"\n+#include \"stringpool.h\"\n+#include \"convert.h\"\n+#include \"target.h\"\n+#include \"fold-const.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"diagnostic-color.h\"\n+#include \"diagnostic-metadata.h\"\n+#include \"tristate.h\"\n+#include \"bitmap.h\"\n+#include \"selftest.h\"\n+#include \"function.h\"\n+#include \"json.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"cfg.h\"\n+#include \"digraph.h\"\n+#include \"analyzer/supergraph.h\"\n+#include \"sbitmap.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"analyzer/call-info.h\"\n+\n+int plugin_is_GPL_compatible;\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* Basic example of known fn behavior.  */\n+\n+class known_function_returns_42 : public known_function\n+{\n+public:\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    if (cd.get_lhs_type ())\n+      {\n+\tconst svalue *result\n+\t  = cd.get_manager ()->get_or_create_int_cst (cd.get_lhs_type (), 42);\n+\tcd.maybe_set_lhs (result);\n+      }\n+  }\n+};\n+\n+/* Example of bifurcation, with a copy that can fail.  */\n+\n+class known_function_attempt_to_copy : public known_function\n+{\n+public:\n+  class copy_success : public success_call_info\n+  {\n+  public:\n+    copy_success (const call_details &cd,\n+\t\t  const region *sized_dest_reg,\n+\t\t  const svalue *copied_sval)\n+    : success_call_info (cd),\n+      m_sized_dest_reg (sized_dest_reg),\n+      m_copied_sval (copied_sval)\n+    {}\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const final override\n+    {\n+      call_details cd (get_call_details (model, ctxt));\n+      model->update_for_zero_return (cd, true);\n+      model->set_value (m_sized_dest_reg, m_copied_sval, ctxt);\n+      return true;\n+    }\n+\n+    const region *m_sized_dest_reg;\n+    const svalue *m_copied_sval;\n+    const region *m_sized_src_reg;\n+  };\n+\n+  class copy_failure : public failed_call_info\n+  {\n+  public:\n+    copy_failure (const call_details &cd)\n+    : failed_call_info (cd)\n+    {}\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const final override\n+    {\n+      call_details cd (get_call_details (model, ctxt));\n+      model->update_for_nonzero_return (cd);\n+      /* Leave the destination region untouched.  */\n+      return true;\n+    }\n+  };\n+\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    region_model_manager *mgr = cd.get_manager ();\n+    region_model *model = cd.get_model ();\n+\n+    const svalue *dest_sval = cd.get_arg_svalue (0);\n+    const svalue *src_sval = cd.get_arg_svalue (1);\n+    const svalue *num_bytes_sval = cd.get_arg_svalue (2);\n+\n+    const region *dest_reg = model->deref_rvalue (dest_sval,\n+\t\t\t\t\t\t  cd.get_arg_tree (0),\n+\t\t\t\t\t\t  cd.get_ctxt ());\n+    const region *src_reg = model->deref_rvalue (src_sval,\n+\t\t\t\t\t\t cd.get_arg_tree (1),\n+\t\t\t\t\t\t cd.get_ctxt ());\n+    if (const svalue * bounded_sval\n+\t  = model->maybe_get_copy_bounds (src_reg, num_bytes_sval))\n+      num_bytes_sval = bounded_sval;\n+\n+    if (tree cst = num_bytes_sval->maybe_get_constant ())\n+      if (zerop (cst))\n+\t/* No-op.  */\n+\treturn;\n+\n+    const region *sized_src_reg = mgr->get_sized_region (src_reg,\n+\t\t\t\t\t\t\t NULL_TREE,\n+\t\t\t\t\t\t\t num_bytes_sval);\n+\n+    const svalue *copied_sval\n+      = model->get_store_value (sized_src_reg, cd.get_ctxt ());\n+\n+    const region *sized_dest_reg = mgr->get_sized_region (dest_reg,\n+\t\t\t\t\t\t\t  NULL_TREE,\n+\t\t\t\t\t\t\t  num_bytes_sval);\n+\n+    if (cd.get_ctxt ())\n+      {\n+\t/* Bifurcate state, creating a \"failure\" out-edge.  */\n+\tcd.get_ctxt ()->bifurcate (new copy_failure (cd));\n+\n+\t/* The \"unbifurcated\" state is the \"success\" case.  */\n+\tcopy_success success (cd,\n+\t\t\t      sized_dest_reg,\n+\t\t\t      copied_sval);\n+\tsuccess.update_model (model, NULL, cd.get_ctxt ());\n+      }\n+  }\n+};\n+\n+/* Callback handler for the PLUGIN_ANALYZER_INIT event.  */\n+\n+static void\n+known_fn_analyzer_init_cb (void *gcc_data, void */*user_data*/)\n+{\n+  ana::plugin_analyzer_init_iface *iface\n+    = (ana::plugin_analyzer_init_iface *)gcc_data;\n+  LOG_SCOPE (iface->get_logger ());\n+  if (0)\n+    inform (input_location, \"got here: known_fn_analyzer_init_cb\");\n+  iface->register_known_function (\"returns_42\",\n+\t\t\t\t  new known_function_returns_42 ());\n+  iface->register_known_function (\"attempt_to_copy\",\n+\t\t\t\t  new known_function_attempt_to_copy ());\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */\n+\n+int\n+plugin_init (struct plugin_name_args *plugin_info,\n+\t     struct plugin_gcc_version *version)\n+{\n+#if ENABLE_ANALYZER\n+  const char *plugin_name = plugin_info->base_name;\n+  if (0)\n+    inform (input_location, \"got here; %qs\", plugin_name);\n+  register_callback (plugin_info->base_name,\n+\t\t     PLUGIN_ANALYZER_INIT,\n+\t\t     ana::known_fn_analyzer_init_cb,\n+\t\t     NULL); /* void *user_data */\n+#else\n+  sorry_no_analyzer ();\n+#endif\n+  return 0;\n+}"}, {"sha": "5fa49f6a93fab8df65708ce485ceb920b458e3cf", "filename": "gcc/testsuite/gcc.dg/plugin/known-fns-1.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e30160beaa207f56f170900fac0d799c6af410/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fknown-fns-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e30160beaa207f56f170900fac0d799c6af410/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fknown-fns-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fknown-fns-1.c?ref=07e30160beaa207f56f170900fac0d799c6af410", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fanalyzer\" } */\n+/* { dg-require-effective-target analyzer } */\n+\n+#include \"../analyzer/analyzer-decls.h\"\n+\n+/* Basic example of known fn behavior.  */\n+\n+extern int returns_42 (void);\n+\n+void test_1 (void)\n+{\n+  int val = returns_42 ();\n+  __analyzer_eval (val == 42); /* { dg-warning \"TRUE\" } */\n+}\n+\n+/* Example of bifurcation, with a copy that can fail.  */\n+\n+extern int\n+attempt_to_copy (void *to, const void *from, int sz);\n+\n+void test_copy_success (void *to, const void *from, int sz)\n+{\n+  if (!attempt_to_copy (to, from, sz))\n+    {\n+      /* Success */\n+    }\n+}\n+\n+void test_copy_failure (void *to, const void *from, int sz)\n+{\n+  if (attempt_to_copy (to, from, sz)) /* { dg-message \"when 'attempt_to_copy' fails\" } */\n+    __analyzer_dump_path (); /* { dg-message \"path\" } */\n+}\n+\n+struct coord\n+{\n+  int x;\n+  int y;\n+  int z;\n+};\n+\n+void test_copy_2 (void)\n+{\n+  struct coord to = {1, 2, 3};\n+  struct coord from = {4, 5, 6};\n+  if (attempt_to_copy (&to, &from, sizeof (struct coord)))\n+    {\n+      /* Failure.  */\n+      __analyzer_eval (to.x == 1); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (to.y == 2); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (to.z == 3); /* { dg-warning \"TRUE\" } */\n+    }\n+  else\n+    {\n+      /* Success.  */\n+      __analyzer_eval (to.x == 4); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (to.y == 5); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (to.z == 6); /* { dg-warning \"TRUE\" } */\n+    }\n+}"}, {"sha": "c05366f3f851a67cfd8ad7ce1cdb8ff15c7a4536", "filename": "gcc/testsuite/gcc.dg/plugin/plugin.exp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e30160beaa207f56f170900fac0d799c6af410/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e30160beaa207f56f170900fac0d799c6af410/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp?ref=07e30160beaa207f56f170900fac0d799c6af410", "patch": "@@ -123,6 +123,8 @@ set plugin_test_list [list \\\n \t  dump-2.c } \\\n     { analyzer_gil_plugin.c \\\n \t  gil-1.c } \\\n+    { analyzer_known_fns_plugin.c \\\n+\t  known-fns-1.c } \\\n ]\n \n foreach plugin_test $plugin_test_list {"}]}