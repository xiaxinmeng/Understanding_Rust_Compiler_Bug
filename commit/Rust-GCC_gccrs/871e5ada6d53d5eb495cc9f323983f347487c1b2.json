{"sha": "871e5ada6d53d5eb495cc9f323983f347487c1b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODcxZTVhZGE2ZDUzZDVlYjQ5NWNjOWYzMjM5ODNmMzQ3NDg3YzFiMg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-01-31T12:10:14Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-06-02T10:11:02Z"}, "message": "Make TOPN counter dynamically allocated.\n\ngcc/ChangeLog:\n\n\t* coverage.c (get_coverage_counts): Skip sanity check for TOP N counters\n\tas they have variable number of counters.\n\t* gcov-dump.c (main): Add new option -r.\n\t(print_usage): Likewise.\n\t(tag_counters): All new raw format.\n\t* gcov-io.h (struct gcov_kvp): New.\n\t(GCOV_TOPN_VALUES): Remove.\n\t(GCOV_TOPN_VALUES_COUNTERS): Likewise.\n\t(GCOV_TOPN_MEM_COUNTERS): New.\n\t(GCOV_TOPN_DISK_COUNTERS): Likewise.\n\t(GCOV_TOPN_MAXIMUM_TRACKED_VALUES): Likewise.\n\t* ipa-profile.c (ipa_profile_generate_summary): Use\n\tGCOV_TOPN_MAXIMUM_TRACKED_VALUES.\n\t(ipa_profile_write_edge_summary): Likewise.\n\t(ipa_profile_read_edge_summary): Likewise.\n\t(ipa_profile): Remove usage of GCOV_TOPN_VALUES.\n\t* profile.c (sort_hist_values): Sort variable number\n\tof counters.\n\t(compute_value_histograms): Special case for TOP N counters\n\tthat have dynamic number of key-value pairs.\n\t* value-prof.c (dump_histogram_value): Dump variable number\n\tof key-value pairs.\n\t(stream_in_histogram_value): Stream in variable number\n\tof key-value pairs for TOP N counter.\n\t(get_nth_most_common_value): Deal with variable number\n\tof key-value pairs.\n\t(dump_ic_profile): Use GCOV_TOPN_MAXIMUM_TRACKED_VALUES\n\tfor loop iteration.\n\t(gimple_find_values_to_profile): Set GCOV_TOPN_MEM_COUNTERS\n\tto n_counters.\n\t* doc/gcov-dump.texi: Document new -r option.\n\nlibgcc/ChangeLog:\n\n\t* libgcov-driver.c (prune_topn_counter): Remove.\n\t(prune_counters): Likewise.\n\t(merge_one_data): Special case TOP N counters\n\tas they have variable length.\n\t(write_top_counters): New.\n\t(write_one_data): Special case TOP N.\n\t(dump_one_gcov): Do not prune TOP N counters.\n\t* libgcov-merge.c (merge_topn_values_set): Remove.\n\t(__gcov_merge_topn): Use gcov_topn_add_value.\n\t* libgcov-profiler.c (__gcov_topn_values_profiler_body):\n\tLikewise here.\n\t* libgcov.h (gcov_counter_add): New.\n\t(gcov_counter_set_if_null): Likewise.\n\t(gcov_topn_add_value): New.", "tree": {"sha": "15075fc87b2c7817e72f0b26b065a91e7963d0e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15075fc87b2c7817e72f0b26b065a91e7963d0e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/871e5ada6d53d5eb495cc9f323983f347487c1b2", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEE6I4wzqqylQBfXaRhTcGC3A+nN4UFAl7WJbYACgkQTcGC3A+n\nN4Wl8wgAjprYda1heQyxM/OcEMEp/T0Kc1/eiKUTkZUuL7koyTfezlt0OtveKsta\n1+CDYFjI+9telTNFjsIHW9tuDrSE+WWAAtfb0IHqu0E1iVoePSl72DO2z4ziFlwx\n3gJHcmqbBg/EL3NbatJe3ISgv8xb/sUj3glTRUkd27HyNj7a9GqtYlieY7BeFSDQ\nR73MDzjqOQDOGiNYVIBULW3kwGrljj7UZkjvB2xicKPJAIBIL11belhdOF4MGe7v\nKyneAiZOHcjFB+0dFAcfY5Fg2bJ/9qPXTev/AxEvDudQ5AYPS+bjkP8VckB2HFGp\nZelpoaR61AcVqrapy6hdt4sMrTvgIQ==\n=hSRe\n-----END PGP SIGNATURE-----", "payload": "tree 15075fc87b2c7817e72f0b26b065a91e7963d0e6\nparent 23438370f768802fefd732529177fcea074c493b\nauthor Martin Liska <mliska@suse.cz> 1580472614 +0100\ncommitter Martin Liska <mliska@suse.cz> 1591092662 +0200\n\nMake TOPN counter dynamically allocated.\n\ngcc/ChangeLog:\n\n\t* coverage.c (get_coverage_counts): Skip sanity check for TOP N counters\n\tas they have variable number of counters.\n\t* gcov-dump.c (main): Add new option -r.\n\t(print_usage): Likewise.\n\t(tag_counters): All new raw format.\n\t* gcov-io.h (struct gcov_kvp): New.\n\t(GCOV_TOPN_VALUES): Remove.\n\t(GCOV_TOPN_VALUES_COUNTERS): Likewise.\n\t(GCOV_TOPN_MEM_COUNTERS): New.\n\t(GCOV_TOPN_DISK_COUNTERS): Likewise.\n\t(GCOV_TOPN_MAXIMUM_TRACKED_VALUES): Likewise.\n\t* ipa-profile.c (ipa_profile_generate_summary): Use\n\tGCOV_TOPN_MAXIMUM_TRACKED_VALUES.\n\t(ipa_profile_write_edge_summary): Likewise.\n\t(ipa_profile_read_edge_summary): Likewise.\n\t(ipa_profile): Remove usage of GCOV_TOPN_VALUES.\n\t* profile.c (sort_hist_values): Sort variable number\n\tof counters.\n\t(compute_value_histograms): Special case for TOP N counters\n\tthat have dynamic number of key-value pairs.\n\t* value-prof.c (dump_histogram_value): Dump variable number\n\tof key-value pairs.\n\t(stream_in_histogram_value): Stream in variable number\n\tof key-value pairs for TOP N counter.\n\t(get_nth_most_common_value): Deal with variable number\n\tof key-value pairs.\n\t(dump_ic_profile): Use GCOV_TOPN_MAXIMUM_TRACKED_VALUES\n\tfor loop iteration.\n\t(gimple_find_values_to_profile): Set GCOV_TOPN_MEM_COUNTERS\n\tto n_counters.\n\t* doc/gcov-dump.texi: Document new -r option.\n\nlibgcc/ChangeLog:\n\n\t* libgcov-driver.c (prune_topn_counter): Remove.\n\t(prune_counters): Likewise.\n\t(merge_one_data): Special case TOP N counters\n\tas they have variable length.\n\t(write_top_counters): New.\n\t(write_one_data): Special case TOP N.\n\t(dump_one_gcov): Do not prune TOP N counters.\n\t* libgcov-merge.c (merge_topn_values_set): Remove.\n\t(__gcov_merge_topn): Use gcov_topn_add_value.\n\t* libgcov-profiler.c (__gcov_topn_values_profiler_body):\n\tLikewise here.\n\t* libgcov.h (gcov_counter_add): New.\n\t(gcov_counter_set_if_null): Likewise.\n\t(gcov_topn_add_value): New.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/871e5ada6d53d5eb495cc9f323983f347487c1b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/871e5ada6d53d5eb495cc9f323983f347487c1b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/871e5ada6d53d5eb495cc9f323983f347487c1b2/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23438370f768802fefd732529177fcea074c493b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23438370f768802fefd732529177fcea074c493b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23438370f768802fefd732529177fcea074c493b"}], "stats": {"total": 534, "additions": 285, "deletions": 249}, "files": [{"sha": "1dcda4353cd4a0d6ee57301dce455344c4c370d6", "filename": "gcc/coverage.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/871e5ada6d53d5eb495cc9f323983f347487c1b2/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/871e5ada6d53d5eb495cc9f323983f347487c1b2/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=871e5ada6d53d5eb495cc9f323983f347487c1b2", "patch": "@@ -345,8 +345,11 @@ get_coverage_counts (unsigned counter, unsigned cfg_checksum,\n \t can do about it.  */\n       return NULL;\n     }\n-  \n-  if (entry->cfg_checksum != cfg_checksum || entry->n_counts != n_counts)\n+\n+  if (entry->cfg_checksum != cfg_checksum\n+      || (counter != GCOV_COUNTER_V_INDIR\n+\t  && counter != GCOV_COUNTER_V_TOPN\n+\t  && entry->n_counts != n_counts))\n     {\n       static int warned = 0;\n       bool warning_printed = false;"}, {"sha": "419df988df4f8bdf8a6fa370506fd3091ea1b11c", "filename": "gcc/doc/gcov-dump.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/871e5ada6d53d5eb495cc9f323983f347487c1b2/gcc%2Fdoc%2Fgcov-dump.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/871e5ada6d53d5eb495cc9f323983f347487c1b2/gcc%2Fdoc%2Fgcov-dump.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcov-dump.texi?ref=871e5ada6d53d5eb495cc9f323983f347487c1b2", "patch": "@@ -61,6 +61,7 @@ gcov-dump [@option{-v}|@option{--version}]\n      [@option{-h}|@option{--help}]\n      [@option{-l}|@option{--long}]\n      [@option{-p}|@option{--positions}]\n+     [@option{-r}|@option{--raw}]\n      @var{gcovfiles}\n @c man end\n @end ignore\n@@ -80,6 +81,10 @@ Dump content of records.\n @itemx --positions\n Dump positions of records.\n \n+@item -r\n+@itemx --raw\n+Print content records in raw format.\n+\n @item -v\n @itemx --version\n Display the @command{gcov-dump} version number (on the standard output),"}, {"sha": "90cbd1ace52f19eafb3146c5a17d4b3d5e00db17", "filename": "gcc/gcov-dump.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/871e5ada6d53d5eb495cc9f323983f347487c1b2/gcc%2Fgcov-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/871e5ada6d53d5eb495cc9f323983f347487c1b2/gcc%2Fgcov-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-dump.c?ref=871e5ada6d53d5eb495cc9f323983f347487c1b2", "patch": "@@ -49,6 +49,7 @@ typedef struct tag_format\n \n static int flag_dump_contents = 0;\n static int flag_dump_positions = 0;\n+static int flag_dump_raw = 0;\n \n static const struct option options[] =\n {\n@@ -95,7 +96,7 @@ main (int argc ATTRIBUTE_UNUSED, char **argv)\n \n   diagnostic_initialize (global_dc, 0);\n \n-  while ((opt = getopt_long (argc, argv, \"hlpvw\", options, NULL)) != -1)\n+  while ((opt = getopt_long (argc, argv, \"hlprvw\", options, NULL)) != -1)\n     {\n       switch (opt)\n \t{\n@@ -111,6 +112,9 @@ main (int argc ATTRIBUTE_UNUSED, char **argv)\n \tcase 'p':\n \t  flag_dump_positions = 1;\n \t  break;\n+\tcase 'r':\n+\t  flag_dump_raw = 1;\n+\t  break;\n \tdefault:\n \t  fprintf (stderr, \"unknown flag `%c'\\n\", opt);\n \t}\n@@ -129,6 +133,7 @@ print_usage (void)\n   printf (\"  -h, --help           Print this help\\n\");\n   printf (\"  -l, --long           Dump record contents too\\n\");\n   printf (\"  -p, --positions      Dump record positions\\n\");\n+  printf (\"  -r, --raw\t\t  Print content records in raw format\\n\");\n   printf (\"  -v, --version        Print version number\\n\");\n   printf (\"\\nFor bug reporting instructions, please see:\\n%s.\\n\",\n \t   bug_report_url);\n@@ -441,7 +446,12 @@ tag_counters (const char *filename ATTRIBUTE_UNUSED,\n \t{\n \t  gcov_type count;\n \n-\t  if (!(ix & 7))\n+\t  if (flag_dump_raw)\n+\t    {\n+\t      if (ix == 0)\n+\t\tprintf (\": \");\n+\t    }\n+\t  else if (!(ix & 7))\n \t    {\n \t      printf (\"\\n\");\n \t      print_prefix (filename, depth, gcov_position ());"}, {"sha": "940eb7d85615177f9db5e15073a88c2b7cec257f", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/871e5ada6d53d5eb495cc9f323983f347487c1b2/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/871e5ada6d53d5eb495cc9f323983f347487c1b2/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=871e5ada6d53d5eb495cc9f323983f347487c1b2", "patch": "@@ -170,6 +170,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #ifndef GCC_GCOV_IO_H\n #define GCC_GCOV_IO_H\n \n+/* GCOV key-value pair linked list type.  */\n+\n+struct gcov_kvp;\n+\n+struct gcov_kvp\n+{\n+  gcov_type value;\n+  gcov_type count;\n+  struct gcov_kvp *next;\n+};\n+\n #ifndef IN_LIBGCOV\n /* About the host */\n \n@@ -272,11 +283,14 @@ GCOV_COUNTERS\n #define GCOV_N_VALUE_COUNTERS \\\n   (GCOV_LAST_VALUE_COUNTER - GCOV_FIRST_VALUE_COUNTER + 1)\n \n-/* Number of top N value histogram.  */\n-#define GCOV_TOPN_VALUES 4\n+/* Number of top N counters when being in memory.  */\n+#define GCOV_TOPN_MEM_COUNTERS 3\n+\n+/* Number of top N counters in disk representation.  */\n+#define GCOV_TOPN_DISK_COUNTERS 2\n \n-/* Total number of single value counters.  */\n-#define GCOV_TOPN_VALUES_COUNTERS (2 * GCOV_TOPN_VALUES + 1)\n+/* Maximum number of tracked TOP N value profiles.  */\n+#define GCOV_TOPN_MAXIMUM_TRACKED_VALUES 32\n \n /* Convert a counter index to a tag.  */\n #define GCOV_TAG_FOR_COUNTER(COUNT)\t\t\t\t\\"}, {"sha": "43e9b6bb4dbbf827c565ca8433cfcaf6f5d0c974", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/871e5ada6d53d5eb495cc9f323983f347487c1b2/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/871e5ada6d53d5eb495cc9f323983f347487c1b2/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=871e5ada6d53d5eb495cc9f323983f347487c1b2", "patch": "@@ -295,7 +295,8 @@ ipa_profile_generate_summary (void)\n \t\t      speculative_call_summary *csum\n \t\t\t= call_sums->get_create (e);\n \n-\t\t      for (unsigned j = 0; j < GCOV_TOPN_VALUES; j++)\n+\t\t      for (unsigned j = 0; j < GCOV_TOPN_MAXIMUM_TRACKED_VALUES;\n+\t\t\t   j++)\n \t\t\t{\n \t\t\t  if (!get_nth_most_common_value (NULL, \"indirect call\",\n \t\t\t\t\t\t\t  h, &val, &count, &all,\n@@ -342,7 +343,7 @@ ipa_profile_write_edge_summary (lto_simple_output_block *ob,\n \n   len = csum->speculative_call_targets.length ();\n \n-  gcc_assert (len <= GCOV_TOPN_VALUES);\n+  gcc_assert (len <= GCOV_TOPN_MAXIMUM_TRACKED_VALUES);\n \n   streamer_write_hwi_stream (ob->main_stream, len);\n \n@@ -448,8 +449,7 @@ ipa_profile_read_edge_summary (class lto_input_block *ib, cgraph_edge *edge)\n   unsigned i, len;\n \n   len = streamer_read_hwi (ib);\n-  gcc_assert (len <= GCOV_TOPN_VALUES);\n-\n+  gcc_assert (len <= GCOV_TOPN_MAXIMUM_TRACKED_VALUES);\n   speculative_call_summary *csum = call_sums->get_create (edge);\n \n   for (i = 0; i < len; i++)\n@@ -885,8 +885,7 @@ ipa_profile (void)\n \t\t\t\t   item.target_probability\n \t\t\t\t     / (float) REG_BR_PROB_BASE);\n \t\t\t}\n-\t\t      if (item.target_probability\n-\t\t \t  < REG_BR_PROB_BASE / GCOV_TOPN_VALUES / 2)\n+\t\t      if (item.target_probability < REG_BR_PROB_BASE / 2)\n \t\t\t{\n \t\t\t  nuseless++;\n \t\t\t  if (dump_file)"}, {"sha": "bd1eac123dfb1f9f02ae69e144d81db17c750c94", "filename": "gcc/profile.c", "status": "modified", "additions": 39, "deletions": 31, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/871e5ada6d53d5eb495cc9f323983f347487c1b2/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/871e5ada6d53d5eb495cc9f323983f347487c1b2/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=871e5ada6d53d5eb495cc9f323983f347487c1b2", "patch": "@@ -765,26 +765,22 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n static void\n sort_hist_values (histogram_value hist)\n {\n-  /* counters[2] equal to -1 means that all counters are invalidated.  */\n-  if (hist->hvalue.counters[2] == -1)\n-    return;\n-\n   gcc_assert (hist->type == HIST_TYPE_TOPN_VALUES\n \t      || hist->type == HIST_TYPE_INDIR_CALL);\n \n-  gcc_assert (hist->n_counters == GCOV_TOPN_VALUES_COUNTERS);\n-\n+  int counters = hist->hvalue.counters[1];\n+  for (int i = 0; i < counters - 1; i++)\n   /* Hist value is organized as:\n-     [total_executions, value1, counter1, ..., value4, counter4]\n+     [total_executions, N, counter1, ..., valueN, counterN]\n      Use decrease bubble sort to rearrange it.  The sort starts from <value1,\n      counter1> and compares counter first.  If counter is same, compares the\n      value, exchange it if small to keep stable.  */\n-  for (unsigned i = 0; i < GCOV_TOPN_VALUES - 1; i++)\n+\n     {\n       bool swapped = false;\n-      for (unsigned j = 0; j < GCOV_TOPN_VALUES - 1 - i; j++)\n+      for (int j = 0; j < counters - 1 - i; j++)\n \t{\n-\t  gcov_type *p = &hist->hvalue.counters[2 * j + 1];\n+\t  gcov_type *p = &hist->hvalue.counters[2 * j + 2];\n \t  if (p[1] < p[3] || (p[1] == p[3] && p[0] < p[2]))\n \t    {\n \t      std::swap (p[0], p[2]);\n@@ -847,31 +843,43 @@ compute_value_histograms (histogram_values values, unsigned cfg_checksum,\n       gimple *stmt = hist->hvalue.stmt;\n \n       t = (int) hist->type;\n+      bool topn_p = (hist->type == HIST_TYPE_TOPN_VALUES\n+\t\t     || hist->type == HIST_TYPE_INDIR_CALL);\n \n-      aact_count = act_count[t];\n-\n-      if (act_count[t])\n-        act_count[t] += hist->n_counters;\n-\n-      gimple_add_histogram_value (cfun, stmt, hist);\n-      hist->hvalue.counters =  XNEWVEC (gcov_type, hist->n_counters);\n-      for (j = 0; j < hist->n_counters; j++)\n-        if (aact_count)\n-          hist->hvalue.counters[j] = aact_count[j];\n-        else\n-          hist->hvalue.counters[j] = 0;\n-\n-      if (hist->type == HIST_TYPE_TOPN_VALUES\n-\t  || hist->type == HIST_TYPE_INDIR_CALL)\n+      /* TOP N counter uses variable number of counters.  */\n+      if (topn_p)\n \t{\n-\t  /* Each count value is multiplied by GCOV_TOPN_VALUES.  */\n-\t  if (hist->hvalue.counters[2] != -1)\n-\t    for (unsigned i = 0; i < GCOV_TOPN_VALUES; i++)\n-\t      hist->hvalue.counters[2 * i + 2]\n-\t\t= RDIV (hist->hvalue.counters[2 * i + 2], GCOV_TOPN_VALUES);\n-\n+\t  unsigned total_size;\n+\t  if (act_count[t])\n+\t    total_size = 2 + 2 * act_count[t][1];\n+\t  else\n+\t    total_size = 2;\n+\t  gimple_add_histogram_value (cfun, stmt, hist);\n+\t  hist->n_counters = total_size;\n+\t  hist->hvalue.counters = XNEWVEC (gcov_type, hist->n_counters);\n+\t  for (j = 0; j < hist->n_counters; j++)\n+\t    if (act_count[t])\n+\t      hist->hvalue.counters[j] = act_count[t][j];\n+\t    else\n+\t      hist->hvalue.counters[j] = 0;\n+\t  act_count[t] += hist->n_counters;\n \t  sort_hist_values (hist);\n \t}\n+      else\n+\t{\n+\t  aact_count = act_count[t];\n+\n+\t  if (act_count[t])\n+\t    act_count[t] += hist->n_counters;\n+\n+\t  gimple_add_histogram_value (cfun, stmt, hist);\n+\t  hist->hvalue.counters = XNEWVEC (gcov_type, hist->n_counters);\n+\t  for (j = 0; j < hist->n_counters; j++)\n+\t    if (aact_count)\n+\t      hist->hvalue.counters[j] = aact_count[j];\n+\t    else\n+\t      hist->hvalue.counters[j] = 0;\n+\t}\n \n       /* Time profiler counter is not related to any statement,\n          so that we have to read the counter and set the value to"}, {"sha": "ea1b1a8f98f59f2085142b9d7117d5d0c4cc515f", "filename": "gcc/value-prof.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/871e5ada6d53d5eb495cc9f323983f347487c1b2/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/871e5ada6d53d5eb495cc9f323983f347487c1b2/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=871e5ada6d53d5eb495cc9f323983f347487c1b2", "patch": "@@ -265,16 +265,15 @@ dump_histogram_value (FILE *dump_file, histogram_value hist)\n \t\t    ? \"Top N value counter\" : \"Indirect call counter\"));\n \t  if (hist->hvalue.counters)\n \t    {\n-\t      fprintf (dump_file, \" all: %\" PRId64 \"%s, values: \",\n-\t\t       (int64_t) abs_hwi (hist->hvalue.counters[0]),\n-\t\t       hist->hvalue.counters[0] < 0\n-\t\t       ? \" (values missing)\": \"\");\n-\t      for (unsigned i = 0; i < GCOV_TOPN_VALUES; i++)\n+\t      unsigned count = hist->hvalue.counters[1];\n+\t      fprintf (dump_file, \" all: %\" PRId64 \", %\" PRId64 \" values: \",\n+\t\t       (int64_t) hist->hvalue.counters[0], (int64_t) count);\n+\t      for (unsigned i = 0; i < count; i++)\n \t\t{\n \t\t  fprintf (dump_file, \"[%\" PRId64 \":%\" PRId64 \"]\",\n-\t\t\t   (int64_t) hist->hvalue.counters[2 * i + 1],\n-\t\t\t   (int64_t) hist->hvalue.counters[2 * i + 2]);\n-\t\t  if (i != GCOV_TOPN_VALUES - 1)\n+\t\t\t   (int64_t) hist->hvalue.counters[2 * i + 2],\n+\t\t\t   (int64_t) hist->hvalue.counters[2 * i + 3]);\n+\t\t  if (i != count - 1)\n \t\t    fprintf (dump_file, \", \");\n \t\t}\n \t      fprintf (dump_file, \".\\n\");\n@@ -377,7 +376,6 @@ stream_in_histogram_value (class lto_input_block *ib, gimple *stmt)\n \n \tcase HIST_TYPE_TOPN_VALUES:\n \tcase HIST_TYPE_INDIR_CALL:\n-\t  ncounters = GCOV_TOPN_VALUES_COUNTERS;\n \t  break;\n \n \tcase HIST_TYPE_IOR:\n@@ -388,12 +386,31 @@ stream_in_histogram_value (class lto_input_block *ib, gimple *stmt)\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      new_val->hvalue.counters = XNEWVAR (gcov_type,\n-\t\t\t\t\t  sizeof (*new_val->hvalue.counters)\n-\t\t\t\t\t  * ncounters);\n-      new_val->n_counters = ncounters;\n-      for (i = 0; i < ncounters; i++)\n-\tnew_val->hvalue.counters[i] = streamer_read_gcov_count (ib);\n+\n+      /* TOP N counters have variable number of counters.  */\n+      if (type == HIST_TYPE_INDIR_CALL || type == HIST_TYPE_TOPN_VALUES)\n+\t{\n+\t  gcov_type total = streamer_read_gcov_count (ib);\n+\t  gcov_type ncounters = streamer_read_gcov_count (ib);\n+\t  new_val->hvalue.counters = XNEWVAR (gcov_type,\n+\t\t\t\t\t      sizeof (*new_val->hvalue.counters)\n+\t\t\t\t\t      * (2 + 2 * ncounters));\n+\t  new_val->hvalue.counters[0] = total;\n+\t  new_val->hvalue.counters[1] = ncounters;\n+\t  new_val->n_counters = 2 + 2 * ncounters;\n+\t  for (i = 0; i < 2 * ncounters; i++)\n+\t    new_val->hvalue.counters[2 + i] = streamer_read_gcov_count (ib);\n+\t}\n+      else\n+\t{\n+\t  new_val->hvalue.counters = XNEWVAR (gcov_type,\n+\t\t\t\t\t      sizeof (*new_val->hvalue.counters)\n+\t\t\t\t\t      * ncounters);\n+\t  new_val->n_counters = ncounters;\n+\t  for (i = 0; i < ncounters; i++)\n+\t    new_val->hvalue.counters[i] = streamer_read_gcov_count (ib);\n+\t}\n+\n       if (!next_p)\n \tgimple_add_histogram_value (cfun, stmt, new_val);\n       else\n@@ -738,15 +755,17 @@ get_nth_most_common_value (gimple *stmt, const char *counter_type,\n \t\t\t   histogram_value hist, gcov_type *value,\n \t\t\t   gcov_type *count, gcov_type *all, unsigned n)\n {\n-  gcc_assert (n < GCOV_TOPN_VALUES);\n+  unsigned counters = hist->hvalue.counters[1];\n+  if (n >= counters)\n+    return false;\n \n   *count = 0;\n   *value = 0;\n \n   gcov_type read_all = abs_hwi (hist->hvalue.counters[0]);\n \n-  gcov_type v = hist->hvalue.counters[2 * n + 1];\n-  gcov_type c = hist->hvalue.counters[2 * n + 2];\n+  gcov_type v = hist->hvalue.counters[2 * n + 2];\n+  gcov_type c = hist->hvalue.counters[2 * n + 3];\n \n   if (hist->hvalue.counters[0] < 0\n       && (flag_profile_reproducible == PROFILE_REPRODUCIBILITY_PARALLEL_RUNS\n@@ -1433,7 +1452,7 @@ dump_ic_profile (gimple_stmt_iterator *gsi)\n   count = 0;\n   all = histogram->hvalue.counters[0];\n \n-  for (unsigned j = 0; j < GCOV_TOPN_VALUES; j++)\n+  for (unsigned j = 0; j < GCOV_TOPN_MAXIMUM_TRACKED_VALUES; j++)\n     {\n       if (!get_nth_most_common_value (NULL, \"indirect call\", histogram, &val,\n \t\t\t\t      &count, &all, j))\n@@ -1902,7 +1921,7 @@ gimple_find_values_to_profile (histogram_values *values)\n \n \tcase HIST_TYPE_TOPN_VALUES:\n \tcase HIST_TYPE_INDIR_CALL:\n-\t  hist->n_counters = GCOV_TOPN_VALUES_COUNTERS;\n+\t  hist->n_counters = GCOV_TOPN_MEM_COUNTERS;\n \t  break;\n \n         case HIST_TYPE_TIME_PROFILE:"}, {"sha": "8348d9f33ecd95fbd730dada0a3c8aba47c34de1", "filename": "libgcc/libgcov-driver.c", "status": "modified", "additions": 54, "deletions": 62, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/871e5ada6d53d5eb495cc9f323983f347487c1b2/libgcc%2Flibgcov-driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/871e5ada6d53d5eb495cc9f323983f347487c1b2/libgcc%2Flibgcov-driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-driver.c?ref=871e5ada6d53d5eb495cc9f323983f347487c1b2", "patch": "@@ -213,51 +213,6 @@ static struct gcov_fn_buffer *fn_buffer;\n /* Including system dependent components. */\n #include \"libgcov-driver-system.c\"\n \n-/* Prune TOP N value COUNTERS.  It's needed in order to preserve\n-   reproducibility of builds.  */\n-\n-static void\n-prune_topn_counter (gcov_type *counters, gcov_type all)\n-{\n-  for (unsigned i = 0; i < GCOV_TOPN_VALUES; i++)\n-    if (counters[2 * i + 1] < all)\n-      {\n-\tcounters[2 * i] = 0;\n-\tcounters[2 * i + 1] = 0;\n-      }\n-}\n-\n-/* Prune counters so that they are ready to store or merge.  */\n-\n-static void\n-prune_counters (struct gcov_info *gi)\n-{\n-  for (unsigned i = 0; i < gi->n_functions; i++)\n-    {\n-      const struct gcov_fn_info *gfi = gi->functions[i];\n-      const struct gcov_ctr_info *ci = gfi->ctrs;\n-\n-      for (unsigned j = 0; j < GCOV_COUNTERS; j++)\n-\t{\n-\t  if (gi->merge[j] == NULL)\n-\t    continue;\n-\n-\t  if (gi->merge[j] == __gcov_merge_topn)\n-\t    {\n-\t      gcc_assert (!(ci->num % GCOV_TOPN_VALUES_COUNTERS));\n-\t      for (unsigned k = 0; k < (ci->num / GCOV_TOPN_VALUES_COUNTERS);\n-\t\t   k++)\n-\t\t{\n-\t\t  gcov_type *counters\n-\t\t    = ci->values + (k * GCOV_TOPN_VALUES_COUNTERS);\n-\t\t  prune_topn_counter (counters + 1, *counters);\n-\t\t}\n-\t    }\n-\t  ci++;\n-\t}\n-    }\n-}\n-\n /* This function merges counters in GI_PTR to an existing gcda file.\n    Return 0 on success.\n    Return -1 on error. In this case, caller will goto read_fatal.  */\n@@ -346,16 +301,18 @@ merge_one_data (const char *filename,\n           if (!merge)\n             continue;\n \n-          tag = gcov_read_unsigned ();\n-          length = gcov_read_unsigned ();\n-          if (tag != GCOV_TAG_FOR_COUNTER (t_ix)\n-              || length != GCOV_TAG_COUNTER_LENGTH (ci_ptr->num))\n-            goto read_mismatch;\n-          (*merge) (ci_ptr->values, ci_ptr->num);\n-          ci_ptr++;\n-        }\n+\t  tag = gcov_read_unsigned ();\n+\t  length = gcov_read_unsigned ();\n+\t  if (tag != GCOV_TAG_FOR_COUNTER (t_ix)\n+\t      || (length != GCOV_TAG_COUNTER_LENGTH (ci_ptr->num)\n+\t\t  && t_ix != GCOV_COUNTER_V_TOPN\n+\t\t  && t_ix != GCOV_COUNTER_V_INDIR))\n+\t    goto read_mismatch;\n+\t  (*merge) (ci_ptr->values, ci_ptr->num);\n+\t  ci_ptr++;\n+\t}\n       if ((error = gcov_is_error ()))\n-        goto read_error;\n+\tgoto read_error;\n     }\n \n   if (tag)\n@@ -374,6 +331,37 @@ merge_one_data (const char *filename,\n   return -1;\n }\n \n+/* Store all TOP N counters where each has a dynamic length.  */\n+\n+static void\n+write_top_counters (const struct gcov_ctr_info *ci_ptr,\n+\t\t    unsigned t_ix,\n+\t\t    gcov_unsigned_t n_counts)\n+{\n+  unsigned counters = n_counts / GCOV_TOPN_MEM_COUNTERS;\n+  gcc_assert (n_counts % GCOV_TOPN_MEM_COUNTERS == 0);\n+  unsigned pair_total = 0;\n+  for (unsigned i = 0; i < counters; i++)\n+    pair_total += ci_ptr->values[GCOV_TOPN_MEM_COUNTERS * i + 1];\n+  unsigned disk_size = GCOV_TOPN_DISK_COUNTERS * counters + 2 * pair_total;\n+  gcov_write_tag_length (GCOV_TAG_FOR_COUNTER (t_ix),\n+\t\t\t GCOV_TAG_COUNTER_LENGTH (disk_size));\n+\n+  for (unsigned i = 0; i < counters; i++)\n+    {\n+      gcov_type pair_count = ci_ptr->values[GCOV_TOPN_MEM_COUNTERS * i + 1];\n+      gcov_write_counter (ci_ptr->values[GCOV_TOPN_MEM_COUNTERS * i]);\n+      gcov_write_counter (pair_count);\n+      for (struct gcov_kvp *node\n+\t   = (struct gcov_kvp *)ci_ptr->values[GCOV_TOPN_MEM_COUNTERS * i + 2];\n+\t   node != NULL; node = node->next)\n+\t{\n+\t  gcov_write_counter (node->value);\n+\t  gcov_write_counter (node->count);\n+\t}\n+    }\n+}\n+\n /* Write counters in GI_PTR and the summary in PRG to a gcda file. In\n    the case of appending to an existing file, SUMMARY_POS will be non-zero.\n    We will write the file starting from SUMMAY_POS.  */\n@@ -433,11 +421,18 @@ write_one_data (const struct gcov_info *gi_ptr,\n             continue;\n \n           n_counts = ci_ptr->num;\n-          gcov_write_tag_length (GCOV_TAG_FOR_COUNTER (t_ix),\n-                                 GCOV_TAG_COUNTER_LENGTH (n_counts));\n-          c_ptr = ci_ptr->values;\n-          while (n_counts--)\n-            gcov_write_counter (*c_ptr++);\n+\n+\t  if (gi_ptr->merge[t_ix] == __gcov_merge_topn)\n+\t    write_top_counters (ci_ptr, t_ix, n_counts);\n+\t  else\n+\t    {\n+\t      gcov_write_tag_length (GCOV_TAG_FOR_COUNTER (t_ix),\n+\t\t\t\t     GCOV_TAG_COUNTER_LENGTH (n_counts));\n+\t      c_ptr = ci_ptr->values;\n+\t      while (n_counts--)\n+\t\tgcov_write_counter (*c_ptr++);\n+\t    }\n+\n           ci_ptr++;\n         }\n       if (buffered)\n@@ -476,9 +471,6 @@ dump_one_gcov (struct gcov_info *gi_ptr, struct gcov_filename *gf,\n   gcov_unsigned_t tag;\n   fn_buffer = 0;\n \n-  /* Prune current counters before we merge them.  */\n-  prune_counters (gi_ptr);\n-\n   error = gcov_exit_open_gcda_file (gi_ptr, gf);\n   if (error == -1)\n     return;"}, {"sha": "1acdaa0403e60b7ab47d700218fc6c5eb9a32355", "filename": "libgcc/libgcov-merge.c", "status": "modified", "additions": 20, "deletions": 83, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/871e5ada6d53d5eb495cc9f323983f347487c1b2/libgcc%2Flibgcov-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/871e5ada6d53d5eb495cc9f323983f347487c1b2/libgcc%2Flibgcov-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-merge.c?ref=871e5ada6d53d5eb495cc9f323983f347487c1b2", "patch": "@@ -86,86 +86,6 @@ __gcov_merge_time_profile (gcov_type *counters, unsigned n_counters)\n \n #ifdef L_gcov_merge_topn\n \n-/* To merging of TOPN profiles.\n-   counters[0] is the number of executions\n-   for i in 0 ... TOPN-1\n-     counters[2 * i + 1] is target\n-     counters[2 * i + 2] is corresponding hitrate counter.\n-\n-   Because we prune counters only those with probability >= 1/TOPN are\n-   present now.\n-\n-   We use sign of counters[0] to track whether the number of different\n-   targets exceeds TOPN.  */\n-\n-static void\n-merge_topn_values_set (gcov_type *counters)\n-{\n-  /* First value is number of total executions of the profiler.  */\n-  gcov_type all = gcov_get_counter ();\n-  gcov_type *total = &counters[0];\n-  ++counters;\n-\n-  /* Negative value means that counter is missing some of values.  */\n-  if (all < 0)\n-    *total = -(*total);\n-\n-  *total += all;\n-\n-  /* Read all part values.  */\n-  gcov_type read_counters[2 * GCOV_TOPN_VALUES];\n-  for (unsigned i = 0; i < GCOV_TOPN_VALUES; i++)\n-    {\n-      read_counters[2 * i] = gcov_get_counter_target ();\n-      read_counters[2 * i + 1] = gcov_get_counter_ignore_scaling (-1);\n-    }\n-\n-  for (unsigned i = 0; i < GCOV_TOPN_VALUES; i++)\n-    {\n-      if (read_counters[2 * i + 1] == 0)\n-\tcontinue;\n-\n-      unsigned j;\n-      int slot = 0;\n-\n-      for (j = 0; j < GCOV_TOPN_VALUES; j++)\n-\t{\n-\t  if (counters[2 * j] == read_counters[2 * i])\n-\t    {\n-\t      counters[2 * j + 1] += read_counters[2 * i + 1];\n-\t      break;\n-\t    }\n-\t  else if (counters[2 * j + 1] < counters[2 * slot + 1])\n-\t    slot = j;\n-\t}\n-\n-      if (j == GCOV_TOPN_VALUES)\n-\t{\n-\t  gcov_type slot_count = counters[2 * slot + 1];\n-\t  /* We found an empty slot.  */\n-\t  if (slot_count == 0)\n-\t    {\n-\t      /* If we found empty slot, add the value.  */\n-\t      counters[2 * slot] = read_counters[2 * i];\n-\t      counters[2 * slot + 1] = read_counters[2 * i + 1];\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Here we are loosing some values.  */\n-\t      if (*total >= 0)\n-\t\t*total = -(*total);\n-\t      if (read_counters[2 * i + 1] > slot_count)\n-\t\t{\n-\t\t  counters[2 * slot] = read_counters[2 * i];\n-\t\t  counters[2 * slot + 1] = read_counters[2 * i + 1];\n-\t\t}\n-\t      else\n-\t\tcounters[2 * slot + 1] -= read_counters[2 * i + 1];\n-\t    }\n-\t}\n-    }\n-}\n-\n /* The profile merging function for choosing the most common value.\n    It is given an array COUNTERS of N_COUNTERS old counters and it\n    reads the same number of counters from the gcov file.  The counters\n@@ -175,13 +95,30 @@ merge_topn_values_set (gcov_type *counters)\n    -- the stored candidate on the most common value of the measured entity\n    -- counter\n    */\n+\n void\n __gcov_merge_topn (gcov_type *counters, unsigned n_counters)\n {\n-  gcc_assert (!(n_counters % GCOV_TOPN_VALUES_COUNTERS));\n+  gcc_assert (!(n_counters % GCOV_TOPN_MEM_COUNTERS));\n \n-  for (unsigned i = 0; i < (n_counters / GCOV_TOPN_VALUES_COUNTERS); i++)\n-    merge_topn_values_set (counters + (i * GCOV_TOPN_VALUES_COUNTERS));\n+  for (unsigned i = 0; i < (n_counters / GCOV_TOPN_MEM_COUNTERS); i++)\n+    {\n+      /* First value is number of total executions of the profiler.  */\n+      gcov_type all = gcov_get_counter_ignore_scaling (-1);\n+      gcov_type n = gcov_get_counter_ignore_scaling (-1);\n+\n+      counters[GCOV_TOPN_MEM_COUNTERS * i] += all;\n+\n+      for (unsigned j = 0; j < n; j++)\n+\t{\n+\t  gcov_type value = gcov_get_counter_target ();\n+\t  gcov_type count = gcov_get_counter_ignore_scaling (-1);\n+\n+\t  // TODO: we should use atomic here\n+\t  gcov_topn_add_value (counters + GCOV_TOPN_MEM_COUNTERS * i, value,\n+\t\t\t       count, 0, 0);\n+\t}\n+    }\n }\n #endif /* L_gcov_merge_topn */\n "}, {"sha": "7b171382a077114cd96e9c76af484f5fed1cbfaa", "filename": "libgcc/libgcov-profiler.c", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/871e5ada6d53d5eb495cc9f323983f347487c1b2/libgcc%2Flibgcov-profiler.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/871e5ada6d53d5eb495cc9f323983f347487c1b2/libgcc%2Flibgcov-profiler.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-profiler.c?ref=871e5ada6d53d5eb495cc9f323983f347487c1b2", "patch": "@@ -105,51 +105,13 @@ __gcov_pow2_profiler_atomic (gcov_type *counters, gcov_type value)\n }\n #endif\n \n-\n /* Tries to determine N most commons value among its inputs.  */\n \n static inline void\n __gcov_topn_values_profiler_body (gcov_type *counters, gcov_type value,\n \t\t\t\t  int use_atomic)\n {\n-  if (use_atomic)\n-    __atomic_fetch_add (&counters[0], 1, __ATOMIC_RELAXED);\n-  else\n-    counters[0]++;\n-\n-  ++counters;\n-\n-  /* First try to find an existing value.  */\n-  int empty_counter = -1;\n-\n-  for (unsigned i = 0; i < GCOV_TOPN_VALUES; i++)\n-    if (value == counters[2 * i])\n-      {\n-\tif (use_atomic)\n-\t  __atomic_fetch_add (&counters[2 * i + 1], GCOV_TOPN_VALUES,\n-\t\t\t      __ATOMIC_RELAXED);\n-\telse\n-\t  counters[2 * i + 1] += GCOV_TOPN_VALUES;\n-\treturn;\n-      }\n-    else if (counters[2 * i + 1] <= 0)\n-      empty_counter = i;\n-\n-  /* Find an empty slot for a new value.  */\n-  if (empty_counter != -1)\n-    {\n-      counters[2 * empty_counter] = value;\n-      counters[2 * empty_counter + 1] = GCOV_TOPN_VALUES;\n-      return;\n-    }\n-\n-  /* We haven't found an empty slot, then decrement all\n-     counter values by one.  */\n-  for (unsigned i = 0; i < GCOV_TOPN_VALUES; i++)\n-    if (use_atomic)\n-      __atomic_fetch_sub (&counters[2 * i + 1], 1, __ATOMIC_RELAXED);\n-    else\n-      counters[2 * i + 1]--;\n+  gcov_topn_add_value (counters, value, 1, use_atomic, 1);\n }\n \n #ifdef L_gcov_topn_values_profiler"}, {"sha": "bc38f4dd80447f09a8b8cb791ed9896313595a85", "filename": "libgcc/libgcov.h", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/871e5ada6d53d5eb495cc9f323983f347487c1b2/libgcc%2Flibgcov.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/871e5ada6d53d5eb495cc9f323983f347487c1b2/libgcc%2Flibgcov.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov.h?ref=871e5ada6d53d5eb495cc9f323983f347487c1b2", "patch": "@@ -373,6 +373,93 @@ gcov_get_counter_target (void)\n #endif\n }\n \n+/* Add VALUE to *COUNTER and make it with atomic operation\n+   if USE_ATOMIC is true.  */\n+\n+static inline void\n+gcov_counter_add (gcov_type *counter, gcov_type value, int use_atomic)\n+{\n+  if (use_atomic)\n+    __atomic_fetch_add (counter, value, __ATOMIC_RELAXED);\n+  else\n+    *counter += value;\n+}\n+\n+/* Set NODE to memory location COUNTER and make it with atomic operation\n+   if USE_ATOMIC is true.  */\n+\n+static inline int\n+gcov_counter_set_if_null (gcov_type *counter, struct gcov_kvp *node,\n+\t\t\t  int use_atomic)\n+{\n+  if (use_atomic)\n+    return !__sync_val_compare_and_swap (counter, NULL, (intptr_t)node);\n+  else\n+    {\n+      *counter = (intptr_t)node;\n+      return 1;\n+    }\n+}\n+\n+/* Add key value pair VALUE:COUNT to a top N COUNTERS.  When INCREMENT_TOTAL\n+   is true, add COUNT to total of the TOP counter.  If USE_ATOMIC is true,\n+   do it in atomic way.  */\n+\n+static inline void\n+gcov_topn_add_value (gcov_type *counters, gcov_type value, gcov_type count,\n+\t\t     int use_atomic, int increment_total)\n+{\n+  if (increment_total)\n+    gcov_counter_add (&counters[0], 1, use_atomic);\n+\n+  struct gcov_kvp *prev_node = NULL;\n+  struct gcov_kvp *minimal_node = NULL;\n+  struct gcov_kvp *current_node  = (struct gcov_kvp *)counters[2];\n+\n+  while (current_node)\n+    {\n+      if (current_node->value == value)\n+\t{\n+\t  gcov_counter_add (&current_node->count, count, use_atomic);\n+\t  return;\n+\t}\n+\n+      if (minimal_node == NULL\n+\t  || current_node->count < minimal_node->count)\n+\tminimal_node = current_node;\n+\n+      prev_node = current_node;\n+      current_node = current_node->next;\n+    }\n+\n+  if (counters[1] == GCOV_TOPN_MAXIMUM_TRACKED_VALUES)\n+    {\n+      if (--minimal_node->count < count)\n+\t{\n+\t  minimal_node->value = value;\n+\t  minimal_node->count = count;\n+\t}\n+    }\n+  else\n+    {\n+      struct gcov_kvp *new_node\n+\t= (struct gcov_kvp *)xmalloc (sizeof (struct gcov_kvp));\n+      new_node->value = value;\n+      new_node->count = count;\n+\n+      int success = 0;\n+      if (!counters[2])\n+\tsuccess = gcov_counter_set_if_null (&counters[2], new_node, use_atomic);\n+      else if (prev_node && !prev_node->next)\n+\tsuccess = gcov_counter_set_if_null ((gcov_type *)&prev_node->next,\n+\t\t\t\t\t    new_node, use_atomic);\n+\n+      /* Increment number of nodes.  */\n+      if (success)\n+\tgcov_counter_add (&counters[1], 1, use_atomic);\n+    }\n+}\n+\n #endif /* !inhibit_libc */\n \n #endif /* GCC_LIBGCOV_H */"}]}