{"sha": "e11a4c8086c3e6fadeb25950bffca82be527ed8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTExYTRjODA4NmMzZTZmYWRlYjI1OTUwYmZmY2E4MmJlNTI3ZWQ4Yg==", "commit": {"author": {"name": "David Alan Gilbert", "email": "david.gilbert@linaro.org", "date": "2011-10-14T14:39:32Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-10-14T14:39:32Z"}, "message": "di-longlong64-sync-1.c: New test.\n\ngcc/testsuite/\n2011-10-14  David Alan Gilbert  <david.gilbert@linaro.org>\n\n\t* gcc.dg/di-longlong64-sync-1.c: New test.\n\t* gcc.dg/di-sync-multithread.c: New test.\n\t* gcc.target/arm/di-longlong64-sync-withhelpers.c: New test.\n\t* gcc.target/arm/di-longlong64-sync-withldrexd.c: New test.\n\t* lib/target-supports.exp: (arm_arch_*_ok): Series of effective-target\n\ttests for v5, v6, v6k, and v7-a, and add-options helpers.\n\t(check_effective_target_arm_arm_ok): New helper.\n\t(check_effective_target_sync_longlong): New helper.\n\nFrom-SVN: r179983", "tree": {"sha": "1eac349fa79439900ee2821fb4b51a27644f2739", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1eac349fa79439900ee2821fb4b51a27644f2739"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e11a4c8086c3e6fadeb25950bffca82be527ed8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e11a4c8086c3e6fadeb25950bffca82be527ed8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e11a4c8086c3e6fadeb25950bffca82be527ed8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e11a4c8086c3e6fadeb25950bffca82be527ed8b/comments", "author": null, "committer": null, "parents": [{"sha": "41aac0de5b574d74a08d92d7dbddb1735fcff694", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41aac0de5b574d74a08d92d7dbddb1735fcff694", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41aac0de5b574d74a08d92d7dbddb1735fcff694"}], "stats": {"total": 477, "additions": 477, "deletions": 0}, "files": [{"sha": "2a475abc0e8fab40cc9e814d46b01294022d412a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e11a4c8086c3e6fadeb25950bffca82be527ed8b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e11a4c8086c3e6fadeb25950bffca82be527ed8b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e11a4c8086c3e6fadeb25950bffca82be527ed8b", "patch": "@@ -1,3 +1,14 @@\n+2011-10-14  David Alan Gilbert  <david.gilbert@linaro.org>\n+\n+\t* gcc.dg/di-longlong64-sync-1.c: New test.\n+\t* gcc.dg/di-sync-multithread.c: New test.\n+\t* gcc.target/arm/di-longlong64-sync-withhelpers.c: New test.\n+\t* gcc.target/arm/di-longlong64-sync-withldrexd.c: New test.\n+\t* lib/target-supports.exp: (arm_arch_*_ok): Series of effective-target\n+\ttests for v5, v6, v6k, and v7-a, and add-options helpers.\n+\t(check_effective_target_arm_arm_ok): New helper.\n+\t(check_effective_target_sync_longlong): New helper.\n+\n 2011-10-14  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/50723"}, {"sha": "82a4ea246174c705ed363d98dec2c3fdfb967cdf", "filename": "gcc/testsuite/gcc.dg/di-longlong64-sync-1.c", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e11a4c8086c3e6fadeb25950bffca82be527ed8b/gcc%2Ftestsuite%2Fgcc.dg%2Fdi-longlong64-sync-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e11a4c8086c3e6fadeb25950bffca82be527ed8b/gcc%2Ftestsuite%2Fgcc.dg%2Fdi-longlong64-sync-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdi-longlong64-sync-1.c?ref=e11a4c8086c3e6fadeb25950bffca82be527ed8b", "patch": "@@ -0,0 +1,164 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_longlong } */\n+/* { dg-options \"-std=gnu99\" } */\n+/* { dg-message \"note: '__sync_fetch_and_nand' changed semantics in GCC 4.4\" \"\" { target *-*-* } 0 } */\n+/* { dg-message \"note: '__sync_nand_and_fetch' changed semantics in GCC 4.4\" \"\" { target *-*-* } 0 } */\n+\n+\n+/* Test basic functionality of the intrinsics.  The operations should\n+   not be optimized away if no one checks the return values.  */\n+\n+/* Based on ia64-sync-[12].c, but 1) long on ARM is 32 bit so use long long\n+   (an explicit 64bit type maybe a better bet) and 2) Use values that cross\n+   the 32bit boundary and cause carries since the actual maths are done as\n+   pairs of 32 bit instructions.  */\n+\n+/* Note: This file is #included by some of the ARM tests.  */\n+\n+__extension__ typedef __SIZE_TYPE__ size_t;\n+\n+extern void abort (void);\n+extern void *memcpy (void *, const void *, size_t);\n+extern int memcmp (const void *, const void *, size_t);\n+\n+/* Temporary space where the work actually gets done.  */\n+static long long AL[24];\n+/* Values copied into AL before we start.  */\n+static long long init_di[24] = { 0x100000002ll, 0x200000003ll, 0, 1,\n+\n+\t\t\t\t 0x100000002ll, 0x100000002ll,\n+\t\t\t\t 0x100000002ll, 0x100000002ll,\n+\n+\t\t\t\t 0, 0x1000e0de0000ll,\n+\t\t\t\t 42 , 0xc001c0de0000ll,\n+\n+\t\t\t\t -1ll, 0, 0xff00ff0000ll, -1ll,\n+\n+\t\t\t\t 0, 0x1000e0de0000ll,\n+\t\t\t\t 42 , 0xc001c0de0000ll,\n+\n+\t\t\t\t -1ll, 0, 0xff00ff0000ll, -1ll};\n+/* This is what should be in AL at the end.  */\n+static long long test_di[24] = { 0x1234567890ll, 0x1234567890ll, 1, 0,\n+\n+\t\t\t\t 0x100000002ll, 0x100000002ll,\n+\t\t\t\t 0x100000002ll, 0x100000002ll,\n+\n+\t\t\t\t 1, 0xc001c0de0000ll,\n+\t\t\t\t 20, 0x1000e0de0000ll,\n+\n+\t\t\t\t 0x300000007ll , 0x500000009ll,\n+\t\t\t\t 0xf100ff0001ll, ~0xa00000007ll,\n+\n+\t\t\t\t 1, 0xc001c0de0000ll,\n+\t\t\t\t 20, 0x1000e0de0000ll,\n+\n+\t\t\t\t 0x300000007ll , 0x500000009ll,\n+\t\t\t\t 0xf100ff0001ll, ~0xa00000007ll };\n+\n+/* First check they work in terms of what they do to memory.  */\n+static void\n+do_noret_di (void)\n+{\n+  __sync_val_compare_and_swap (AL+0, 0x100000002ll, 0x1234567890ll);\n+  __sync_bool_compare_and_swap (AL+1, 0x200000003ll, 0x1234567890ll);\n+  __sync_lock_test_and_set (AL+2, 1);\n+  __sync_lock_release (AL+3);\n+\n+  /* The following tests should not change the value since the\n+     original does NOT match.  */\n+  __sync_val_compare_and_swap (AL+4, 0x000000002ll, 0x1234567890ll);\n+  __sync_val_compare_and_swap (AL+5, 0x100000000ll, 0x1234567890ll);\n+  __sync_bool_compare_and_swap (AL+6, 0x000000002ll, 0x1234567890ll);\n+  __sync_bool_compare_and_swap (AL+7, 0x100000000ll, 0x1234567890ll);\n+\n+  __sync_fetch_and_add (AL+8, 1);\n+  __sync_fetch_and_add (AL+9, 0xb000e0000000ll); /* + to both halves & carry.  */\n+  __sync_fetch_and_sub (AL+10, 22);\n+  __sync_fetch_and_sub (AL+11, 0xb000e0000000ll);\n+\n+  __sync_fetch_and_and (AL+12, 0x300000007ll);\n+  __sync_fetch_and_or (AL+13, 0x500000009ll);\n+  __sync_fetch_and_xor (AL+14, 0xe00000001ll);\n+  __sync_fetch_and_nand (AL+15, 0xa00000007ll);\n+\n+  /* These should be the same as the fetch_and_* cases except for\n+     return value.  */\n+  __sync_add_and_fetch (AL+16, 1);\n+  /* add to both halves & carry.  */\n+  __sync_add_and_fetch (AL+17, 0xb000e0000000ll);\n+  __sync_sub_and_fetch (AL+18, 22);\n+  __sync_sub_and_fetch (AL+19, 0xb000e0000000ll);\n+\n+  __sync_and_and_fetch (AL+20, 0x300000007ll);\n+  __sync_or_and_fetch (AL+21, 0x500000009ll);\n+  __sync_xor_and_fetch (AL+22, 0xe00000001ll);\n+  __sync_nand_and_fetch (AL+23, 0xa00000007ll);\n+}\n+\n+/* Now check return values.  */\n+static void\n+do_ret_di (void)\n+{\n+  if (__sync_val_compare_and_swap (AL+0, 0x100000002ll, 0x1234567890ll) !=\n+\t0x100000002ll) abort ();\n+  if (__sync_bool_compare_and_swap (AL+1, 0x200000003ll, 0x1234567890ll) !=\n+\t1) abort ();\n+  if (__sync_lock_test_and_set (AL+2, 1) != 0) abort ();\n+  __sync_lock_release (AL+3); /* no return value, but keep to match results.  */\n+\n+  /* The following tests should not change the value since the\n+     original does NOT match.  */\n+  if (__sync_val_compare_and_swap (AL+4, 0x000000002ll, 0x1234567890ll) !=\n+\t0x100000002ll) abort ();\n+  if (__sync_val_compare_and_swap (AL+5, 0x100000000ll, 0x1234567890ll) !=\n+\t0x100000002ll) abort ();\n+  if (__sync_bool_compare_and_swap (AL+6, 0x000000002ll, 0x1234567890ll) !=\n+\t0) abort ();\n+  if (__sync_bool_compare_and_swap (AL+7, 0x100000000ll, 0x1234567890ll) !=\n+\t0) abort ();\n+\n+  if (__sync_fetch_and_add (AL+8, 1) != 0) abort ();\n+  if (__sync_fetch_and_add (AL+9, 0xb000e0000000ll) != 0x1000e0de0000ll) abort ();\n+  if (__sync_fetch_and_sub (AL+10, 22) != 42) abort ();\n+  if (__sync_fetch_and_sub (AL+11, 0xb000e0000000ll) != 0xc001c0de0000ll)\n+\tabort ();\n+\n+  if (__sync_fetch_and_and (AL+12, 0x300000007ll) != -1ll) abort ();\n+  if (__sync_fetch_and_or (AL+13, 0x500000009ll) != 0) abort ();\n+  if (__sync_fetch_and_xor (AL+14, 0xe00000001ll) != 0xff00ff0000ll) abort ();\n+  if (__sync_fetch_and_nand (AL+15, 0xa00000007ll) != -1ll) abort ();\n+\n+  /* These should be the same as the fetch_and_* cases except for\n+     return value.  */\n+  if (__sync_add_and_fetch (AL+16, 1) != 1) abort ();\n+  if (__sync_add_and_fetch (AL+17, 0xb000e0000000ll) != 0xc001c0de0000ll)\n+\tabort ();\n+  if (__sync_sub_and_fetch (AL+18, 22) != 20) abort ();\n+  if (__sync_sub_and_fetch (AL+19, 0xb000e0000000ll) != 0x1000e0de0000ll)\n+\tabort ();\n+\n+  if (__sync_and_and_fetch (AL+20, 0x300000007ll) != 0x300000007ll) abort ();\n+  if (__sync_or_and_fetch (AL+21, 0x500000009ll) != 0x500000009ll) abort ();\n+  if (__sync_xor_and_fetch (AL+22, 0xe00000001ll) != 0xf100ff0001ll) abort ();\n+  if (__sync_nand_and_fetch (AL+23, 0xa00000007ll) != ~0xa00000007ll) abort ();\n+}\n+\n+int main ()\n+{\n+  memcpy (AL, init_di, sizeof (init_di));\n+\n+  do_noret_di ();\n+\n+  if (memcmp (AL, test_di, sizeof (test_di)))\n+    abort ();\n+\n+  memcpy (AL, init_di, sizeof (init_di));\n+\n+  do_ret_di ();\n+\n+  if (memcmp (AL, test_di, sizeof (test_di)))\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "c99878ea1294cae17d2e11e7c8dfcdd4ee57560d", "filename": "gcc/testsuite/gcc.dg/di-sync-multithread.c", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e11a4c8086c3e6fadeb25950bffca82be527ed8b/gcc%2Ftestsuite%2Fgcc.dg%2Fdi-sync-multithread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e11a4c8086c3e6fadeb25950bffca82be527ed8b/gcc%2Ftestsuite%2Fgcc.dg%2Fdi-sync-multithread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdi-sync-multithread.c?ref=e11a4c8086c3e6fadeb25950bffca82be527ed8b", "patch": "@@ -0,0 +1,205 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_longlong } */\n+/* { dg-require-effective-target pthread_h } */\n+/* { dg-require-effective-target pthread } */\n+/* { dg-options \"-pthread -std=gnu99\" } */\n+\n+/* test of long long atomic ops performed in parallel in 3 pthreads\n+   david.gilbert@linaro.org */\n+\n+#include <pthread.h>\n+#include <unistd.h>\n+\n+/*#define DEBUGIT 1 */\n+\n+#ifdef DEBUGIT\n+#include <stdio.h>\n+\n+#define DOABORT(x,...) {\\\n+\t fprintf (stderr, x, __VA_ARGS__); fflush (stderr); abort ();\\\n+\t }\n+\n+#else\n+\n+#define DOABORT(x,...) abort ();\n+\n+#endif\n+\n+/* Passed to each thread to describe which bits it is going to work on.  */\n+struct threadwork {\n+  unsigned long long count; /* incremented each time the worker loops.  */\n+  unsigned int thread;    /* ID */\n+  unsigned int addlsb;    /* 8 bit */\n+  unsigned int logic1lsb; /* 5 bit */\n+  unsigned int logic2lsb; /* 8 bit */\n+};\n+\n+/* The shared word where all the atomic work is done.  */\n+static volatile long long workspace;\n+\n+/* A shared word to tell the workers to quit when non-0.  */\n+static long long doquit;\n+\n+extern void abort (void);\n+\n+/* Note this test doesn't test the return values much.  */\n+void*\n+worker (void* data)\n+{\n+  struct threadwork *tw = (struct threadwork*)data;\n+  long long add1bit = 1ll << tw->addlsb;\n+  long long logic1bit = 1ll << tw->logic1lsb;\n+  long long logic2bit = 1ll << tw->logic2lsb;\n+\n+  /* Clear the bits we use.  */\n+  __sync_and_and_fetch (&workspace, ~(0xffll * add1bit));\n+  __sync_fetch_and_and (&workspace, ~(0x1fll * logic1bit));\n+  __sync_fetch_and_and (&workspace, ~(0xffll * logic2bit));\n+\n+  do\n+    {\n+      long long tmp1, tmp2, tmp3;\n+      /* OK, lets try and do some stuff to the workspace - by the end\n+         of the main loop our area should be the same as it is now - i.e. 0.  */\n+\n+      /* Push the arithmetic section upto 128 - one of the threads will\n+         case this to carry accross the 32bit boundary.  */\n+      for (tmp2 = 0; tmp2 < 64; tmp2++)\n+\t{\n+\t  /* Add 2 using the two different adds.  */\n+\t  tmp1 = __sync_add_and_fetch (&workspace, add1bit);\n+\t  tmp3 = __sync_fetch_and_add (&workspace, add1bit);\n+\n+\t  /* The value should be the intermediate add value in both cases.  */\n+\t  if ((tmp1 & (add1bit * 0xff)) != (tmp3 & (add1bit * 0xff)))\n+\t    DOABORT (\"Mismatch of add intermediates on thread %d \"\n+\t\t\t\"workspace=0x%llx tmp1=0x%llx \"\n+\t\t\t\"tmp2=0x%llx tmp3=0x%llx\\n\",\n+\t\t\t tw->thread, workspace, tmp1, tmp2, tmp3);\n+\t}\n+\n+      /* Set the logic bits.  */\n+      tmp2=__sync_or_and_fetch (&workspace,\n+\t\t\t  0x1fll * logic1bit | 0xffll * logic2bit);\n+\n+      /* Check the logic bits are set and the arithmetic value is correct.  */\n+      if ((tmp2 & (0x1fll * logic1bit | 0xffll * logic2bit\n+\t\t\t| 0xffll * add1bit))\n+\t  != (0x1fll * logic1bit | 0xffll * logic2bit | 0x80ll * add1bit))\n+\tDOABORT (\"Midloop check failed on thread %d \"\n+\t\t\t\"workspace=0x%llx tmp2=0x%llx \"\n+\t\t\t\"masktmp2=0x%llx expected=0x%llx\\n\",\n+\t\ttw->thread, workspace, tmp2,\n+\t\ttmp2 & (0x1fll * logic1bit | 0xffll * logic2bit |\n+\t\t\t 0xffll * add1bit),\n+\t\t(0x1fll * logic1bit | 0xffll * logic2bit | 0x80ll * add1bit));\n+\n+      /* Pull the arithmetic set back down to 0 - again this should cause a\n+\t carry across the 32bit boundary in one thread.  */\n+\n+      for (tmp2 = 0; tmp2 < 64; tmp2++)\n+\t{\n+\t  /* Subtract 2 using the two different subs.  */\n+\t  tmp1=__sync_sub_and_fetch (&workspace, add1bit);\n+\t  tmp3=__sync_fetch_and_sub (&workspace, add1bit);\n+\n+\t  /* The value should be the intermediate sub value in both cases.  */\n+\t  if ((tmp1 & (add1bit * 0xff)) != (tmp3 & (add1bit * 0xff)))\n+\t    DOABORT (\"Mismatch of sub intermediates on thread %d \"\n+\t\t\t\"workspace=0x%llx tmp1=0x%llx \"\n+\t\t\t\"tmp2=0x%llx tmp3=0x%llx\\n\",\n+\t\t\ttw->thread, workspace, tmp1, tmp2, tmp3);\n+\t}\n+\n+\n+      /* Clear the logic bits.  */\n+      __sync_fetch_and_xor (&workspace, 0x1fll * logic1bit);\n+      tmp3=__sync_and_and_fetch (&workspace, ~(0xffll * logic2bit));\n+\n+      /* The logic bits and the arithmetic bits should be zero again.  */\n+      if (tmp3 & (0x1fll * logic1bit | 0xffll * logic2bit | 0xffll * add1bit))\n+\tDOABORT (\"End of worker loop; bits none 0 on thread %d \"\n+\t\t\t\"workspace=0x%llx tmp3=0x%llx \"\n+\t\t\t\"mask=0x%llx maskedtmp3=0x%llx\\n\",\n+\t\ttw->thread, workspace, tmp3, (0x1fll * logic1bit |\n+\t\t\t0xffll * logic2bit | 0xffll * add1bit),\n+\t\ttmp3 & (0x1fll * logic1bit | 0xffll * logic2bit | 0xffll * add1bit));\n+\n+      __sync_add_and_fetch (&tw->count, 1);\n+    }\n+  while (!__sync_bool_compare_and_swap (&doquit, 1, 1));\n+\n+  pthread_exit (0);\n+}\n+\n+int\n+main ()\n+{\n+  /* We have 3 threads doing three sets of operations, an 8 bit\n+     arithmetic field, a 5 bit logic field and an 8 bit logic\n+     field (just to pack them all in).\n+\n+  6      5       4       4       3       2       1\n+  3      6       8       0       2       4       6       8       0\n+  |...,...|...,...|...,...|...,...|...,...|...,...|...,...|...,...\n+  - T0   --  T1  -- T2   --T2 --  T0  -*- T2-- T1-- T1   -***- T0-\n+   logic2  logic2  arith   log2  arith  log1 log1  arith     log1\n+\n+  */\n+  unsigned int t;\n+  long long tmp;\n+  int err;\n+\n+  struct threadwork tw[3]={\n+    { 0ll, 0, 27, 0, 56 },\n+    { 0ll, 1,  8,16, 48 },\n+    { 0ll, 2, 40,21, 35 }\n+  };\n+\n+  pthread_t threads[3];\n+\n+  __sync_lock_release (&doquit);\n+\n+  /* Get the work space into a known value - All 1's.  */\n+  __sync_lock_release (&workspace); /* Now all 0.  */\n+  tmp = __sync_val_compare_and_swap (&workspace, 0, -1ll);\n+  if (tmp!=0)\n+    DOABORT (\"Initial __sync_val_compare_and_swap wasn't 0 workspace=0x%llx \"\n+\t\t\"tmp=0x%llx\\n\", workspace,tmp);\n+\n+  for (t = 0; t < 3; t++)\n+  {\n+    err=pthread_create (&threads[t], NULL , worker, &tw[t]);\n+    if (err) DOABORT (\"pthread_create failed on thread %d with error %d\\n\",\n+\tt, err);\n+  };\n+\n+  sleep (5);\n+\n+  /* Stop please.  */\n+  __sync_lock_test_and_set (&doquit, 1ll);\n+\n+  for (t = 0; t < 3; t++)\n+    {\n+      err=pthread_join (threads[t], NULL);\n+      if (err)\n+\tDOABORT (\"pthread_join failed on thread %d with error %d\\n\", t, err);\n+    };\n+\n+  __sync_synchronize ();\n+\n+  /* OK, so all the workers have finished -\n+     the workers should have zero'd their workspace, the unused areas\n+     should still be 1.  */\n+  if (!__sync_bool_compare_and_swap (&workspace, 0x040000e0ll, 0))\n+    DOABORT (\"End of run workspace mismatch, got %llx\\n\", workspace);\n+\n+  /* All the workers should have done some work.  */\n+  for (t = 0; t < 3; t++)\n+    {\n+      if (tw[t].count == 0) DOABORT (\"Worker %d gave 0 count\\n\", t);\n+    };\n+\n+  return 0;\n+}\n+"}, {"sha": "19342bf80ddf012f5cda6b87dcb6f3bd154db5f4", "filename": "gcc/testsuite/gcc.target/arm/di-longlong64-sync-withhelpers.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e11a4c8086c3e6fadeb25950bffca82be527ed8b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fdi-longlong64-sync-withhelpers.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e11a4c8086c3e6fadeb25950bffca82be527ed8b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fdi-longlong64-sync-withhelpers.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fdi-longlong64-sync-withhelpers.c?ref=e11a4c8086c3e6fadeb25950bffca82be527ed8b", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v5_ok } */\n+/* { dg-options \"-std=gnu99\" } */\n+/* { dg-add-options arm_arch_v5 } */\n+/* { dg-message \"note: '__sync_fetch_and_nand' changed semantics in GCC 4.4\" \"\" { target *-*-* } 0 } */\n+/* { dg-message \"note: '__sync_nand_and_fetch' changed semantics in GCC 4.4\" \"\" { target *-*-* } 0 } */\n+/* { dg-message \"file included\" \"In file included\" { target *-*-* } 0 } */\n+\n+#include \"../../gcc.dg/di-longlong64-sync-1.c\"\n+\n+/* On an old ARM we have no ldrexd or strexd so we have to use helpers.  */\n+/* { dg-final { scan-assembler-not \"ldrexd\" } } */\n+/* { dg-final { scan-assembler-not \"strexd\" } } */\n+/* { dg-final { scan-assembler \"__sync_\" } } */"}, {"sha": "dab69405ef4715d17254b0bdc3e859ca6665afa3", "filename": "gcc/testsuite/gcc.target/arm/di-longlong64-sync-withldrexd.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e11a4c8086c3e6fadeb25950bffca82be527ed8b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fdi-longlong64-sync-withldrexd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e11a4c8086c3e6fadeb25950bffca82be527ed8b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fdi-longlong64-sync-withldrexd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fdi-longlong64-sync-withldrexd.c?ref=e11a4c8086c3e6fadeb25950bffca82be527ed8b", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arm_ok } */\n+/* { dg-options \"-marm -std=gnu99\" } */\n+/* { dg-require-effective-target arm_arch_v6k_ok } */\n+/* { dg-add-options arm_arch_v6k } */\n+/* { dg-message \"note: '__sync_fetch_and_nand' changed semantics in GCC 4.4\" \"\" { target *-*-* } 0 } */\n+/* { dg-message \"note: '__sync_nand_and_fetch' changed semantics in GCC 4.4\" \"\" { target *-*-* } 0 } */\n+/* { dg-message \"file included\" \"In file included\" { target *-*-* } 0 } */\n+\n+#include \"../../gcc.dg/di-longlong64-sync-1.c\"\n+\n+/* We should be using ldrexd, strexd and no helpers or shorter ldrex.  */\n+/* { dg-final { scan-assembler-times \"\\tldrexd\" 46 } } */\n+/* { dg-final { scan-assembler-times \"\\tstrexd\" 46 } } */\n+/* { dg-final { scan-assembler-not \"__sync_\" } } */\n+/* { dg-final { scan-assembler-not \"ldrex\\t\" } } */\n+/* { dg-final { scan-assembler-not \"strex\\t\" } } */"}, {"sha": "77f8a0002549362305872c0002e1aaf213d95ae3", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e11a4c8086c3e6fadeb25950bffca82be527ed8b/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e11a4c8086c3e6fadeb25950bffca82be527ed8b/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=e11a4c8086c3e6fadeb25950bffca82be527ed8b", "patch": "@@ -2067,6 +2067,47 @@ proc check_effective_target_arm_fp16_ok { } {\n \t\tcheck_effective_target_arm_fp16_ok_nocache]\n }\n \n+# Creates a series of routines that return 1 if the given architecture\n+# can be selected and a routine to give the flags to select that architecture\n+# Note: Extra flags may be added to disable options from newer compilers\n+# (Thumb in particular - but others may be added in the future)\n+# Usage: /* { dg-require-effective-target arm_arch_v5_ok } */\n+#        /* { dg-add-options arm_arch_v5 } */\n+foreach { armfunc armflag armdef } { v5 \"-march=armv5 -marm\" __ARM_ARCH_5__\n+\t\t\t\t     v6 \"-march=armv6\" __ARM_ARCH_6__\n+\t\t\t\t     v6k \"-march=armv6k\" __ARM_ARCH_6K__\n+\t\t\t\t     v7a \"-march=armv7-a\" __ARM_ARCH_7A__ } {\n+    eval [string map [list FUNC $armfunc FLAG $armflag DEF $armdef ] {\n+\tproc check_effective_target_arm_arch_FUNC_ok { } {\n+\t    if { [ string match \"*-marm*\" \"FLAG\" ] &&\n+\t\t![check_effective_target_arm_arm_ok] } {\n+\t\treturn 0\n+\t    }\n+\t    return [check_no_compiler_messages arm_arch_FUNC_ok assembly {\n+\t\t#if !defined (DEF)\n+\t\t#error FOO\n+\t\t#endif\n+\t    } \"FLAG\" ]\n+\t}\n+\n+\tproc add_options_for_arm_arch_FUNC { flags } {\n+\t    return \"$flags FLAG\"\n+\t}\n+    }]\n+}\n+\n+# Return 1 if this is an ARM target where -marm causes ARM to be\n+# used (not Thumb)\n+\n+proc check_effective_target_arm_arm_ok { } {\n+    return [check_no_compiler_messages arm_arm_ok assembly {\n+\t#if !defined (__arm__) || defined (__thumb__) || defined (__thumb2__)\n+\t#error FOO\n+\t#endif\n+    } \"-marm\"]\n+}\n+\n+\n # Return 1 is this is an ARM target where -mthumb causes Thumb-1 to be\n # used.\n \n@@ -3457,6 +3498,31 @@ proc check_effective_target_sync_int_long { } {\n     return $et_sync_int_long_saved\n }\n \n+# Return 1 if the target supports atomic operations on \"long long\" and can\n+# execute them\n+# So far only put checks in for ARM, others may want to add their own\n+proc check_effective_target_sync_longlong { } {\n+    return [check_runtime sync_longlong_runtime {\n+      #include <stdlib.h>\n+      int main ()\n+      {\n+\tlong long l1;\n+\n+\tif (sizeof (long long) != 8)\n+\t  exit (1);\n+\n+      #ifdef __arm__\n+\t/* Just check for native; checking for kernel fallback is tricky.  */\n+\tasm volatile (\"ldrexd r0,r1, [%0]\" : : \"r\" (&l1) : \"r0\", \"r1\");\n+      #else\n+      # error \"Add other suitable archs here\"\n+      #endif\n+\n+\texit (0);\n+      }\n+    } \"\" ]\n+}\n+\n # Return 1 if the target supports atomic operations on \"char\" and \"short\".\n \n proc check_effective_target_sync_char_short { } {"}]}