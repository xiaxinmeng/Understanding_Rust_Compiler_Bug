{"sha": "06d7e8e7066b42f440993419493909fefafdc4d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZkN2U4ZTcwNjZiNDJmNDQwOTkzNDE5NDkzOTA5ZmVmYWZkYzRkNQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-09-30T13:33:54Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-09-30T13:33:54Z"}, "message": "haifa-sched.c (modulo_ii, [...]): New static variables.\n\n\t* haifa-sched.c (modulo_ii, modulo_max_states, modulo_n_insns,\n\tmodulo_insns_scheduled, modulo_iter0_max_uid, modulo_backtracks_left,\n\tmodulo_last_stage): New static variables.\n\t(set_modulo_params, discard_delay_pairs_above): New functions.\n\t(struct delay_pair): New member stages.\n\t(htab_i2_traverse, htab_i1_traverse): New static functions.\n\t(record_delay_slot_pair): New arg stages.  All callers changed.\n\tRecord it.\n\t(pair_delay): Take stages into account.\n\t(add_delay_dependencies): Don't do so for stage pairs.\n\t(struct sched_block_state): New member modulo_epilogue.\n\t(save_backtrack_point): Don't set SHADOW_P for stage pairs.\n\t(unschedule_insns_until): Decrease modulo_insns_scheduled.\n\tSet HARD_DEP without using or.\n\t(resolve_dependencies): New static function.\n\t(prune_ready_list): New arg modulo_epilogue_p.  All callers changed.\n\tIf it is true, allow only insns with INSN_EXACT_TICK set.\n\t(schedule_block): Return bool, always true for normal scheduling,\n\ttrue or false depending on modulo scheduling success otherwise.\n\tAdd bookkeeping for modulo scheduling, and call resolve_dependencies\n\ton everything left over after a modulo schedule.\n\t(haifa_sched_init): Remove check_cfg call.  Clear modulo_ii.\n\t* sched-int.h (schedule_block, record_delay_slot_pair): Adjust\n\tdeclarations.\n\t(set_modulo_params, discard_delay_pairs_above): Declare.\n\t* params.def (PARAM_MAX_MODULO_BACKTRACK_ATTEMPS): New.\n\t* doc/invoke.texi (--param): Document it.\n\nFrom-SVN: r179383", "tree": {"sha": "d5defa483a7652bacc4b555ea1317b96b9ec56a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5defa483a7652bacc4b555ea1317b96b9ec56a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06d7e8e7066b42f440993419493909fefafdc4d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06d7e8e7066b42f440993419493909fefafdc4d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06d7e8e7066b42f440993419493909fefafdc4d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06d7e8e7066b42f440993419493909fefafdc4d5/comments", "author": null, "committer": null, "parents": [{"sha": "ccb3dd5a143aa1975281425685a70f7bd6a130fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccb3dd5a143aa1975281425685a70f7bd6a130fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccb3dd5a143aa1975281425685a70f7bd6a130fa"}], "stats": {"total": 388, "additions": 356, "deletions": 32}, "files": [{"sha": "483b3641f45f8fe8473f42687686079f7892f673", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d7e8e7066b42f440993419493909fefafdc4d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d7e8e7066b42f440993419493909fefafdc4d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06d7e8e7066b42f440993419493909fefafdc4d5", "patch": "@@ -1,3 +1,33 @@\n+2011-09-30  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* haifa-sched.c (modulo_ii, modulo_max_states, modulo_n_insns,\n+\tmodulo_insns_scheduled, modulo_iter0_max_uid, modulo_backtracks_left,\n+\tmodulo_last_stage): New static variables.\n+\t(set_modulo_params, discard_delay_pairs_above): New functions.\n+\t(struct delay_pair): New member stages.\n+\t(htab_i2_traverse, htab_i1_traverse): New static functions.\n+\t(record_delay_slot_pair): New arg stages.  All callers changed.\n+\tRecord it.\n+\t(pair_delay): Take stages into account.\n+\t(add_delay_dependencies): Don't do so for stage pairs.\n+\t(struct sched_block_state): New member modulo_epilogue.\n+\t(save_backtrack_point): Don't set SHADOW_P for stage pairs.\n+\t(unschedule_insns_until): Decrease modulo_insns_scheduled.\n+\tSet HARD_DEP without using or.\n+\t(resolve_dependencies): New static function.\n+\t(prune_ready_list): New arg modulo_epilogue_p.  All callers changed.\n+\tIf it is true, allow only insns with INSN_EXACT_TICK set.\n+\t(schedule_block): Return bool, always true for normal scheduling,\n+\ttrue or false depending on modulo scheduling success otherwise.\n+\tAdd bookkeeping for modulo scheduling, and call resolve_dependencies\n+\ton everything left over after a modulo schedule.\n+\t(haifa_sched_init): Remove check_cfg call.  Clear modulo_ii.\n+\t* sched-int.h (schedule_block, record_delay_slot_pair): Adjust\n+\tdeclarations.\n+\t(set_modulo_params, discard_delay_pairs_above): Declare.\n+\t* params.def (PARAM_MAX_MODULO_BACKTRACK_ATTEMPS): New.\n+\t* doc/invoke.texi (--param): Document it.\n+\n 2011-09-30  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/50574"}, {"sha": "98c65b56cc8e4203bda69345ba87ac3aa1193348", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d7e8e7066b42f440993419493909fefafdc4d5/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d7e8e7066b42f440993419493909fefafdc4d5/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=06d7e8e7066b42f440993419493909fefafdc4d5", "patch": "@@ -4810,7 +4810,7 @@ split_delayed_branch (rtx insn)\n   i1 = emit_insn_before (pat, insn);\n   PATTERN (insn) = newpat;\n   INSN_CODE (insn) = -1;\n-  record_delay_slot_pair (i1, insn, 5);\n+  record_delay_slot_pair (i1, insn, 5, 0);\n }\n \n /* Split every insn (i.e. jumps and calls) which can have delay slots into"}, {"sha": "8e43f823583cd152507086fbeb6ae3450f10b3ad", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d7e8e7066b42f440993419493909fefafdc4d5/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d7e8e7066b42f440993419493909fefafdc4d5/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=06d7e8e7066b42f440993419493909fefafdc4d5", "patch": "@@ -8474,6 +8474,11 @@ before flushing the current state and starting over.  Large functions\n with few branches or calls can create excessively large lists which\n needlessly consume memory and resources.\n \n+@item max-modulo-backtrack-attempts\n+The maximum number of backtrack attempts the scheduler should make\n+when modulo scheduling a loop.  Larger values can exponentially increase\n+compile time.\n+\n @item max-inline-insns-single\n Several parameters control the tree inliner used in gcc.\n This number sets the maximum number of instructions (counted in GCC's"}, {"sha": "a5b4aebefee2d99946b1682f9ecb29ba86ebaec7", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 309, "deletions": 29, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d7e8e7066b42f440993419493909fefafdc4d5/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d7e8e7066b42f440993419493909fefafdc4d5/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=06d7e8e7066b42f440993419493909fefafdc4d5", "patch": "@@ -163,6 +163,31 @@ int issue_rate;\n    enable a DCE pass.  */\n bool sched_no_dce;\n \n+/* The current initiation interval used when modulo scheduling.  */\n+static int modulo_ii;\n+\n+/* The maximum number of stages we are prepared to handle.  */\n+static int modulo_max_stages;\n+\n+/* The number of insns that exist in each iteration of the loop.  We use this\n+   to detect when we've scheduled all insns from the first iteration.  */\n+static int modulo_n_insns;\n+\n+/* The current count of insns in the first iteration of the loop that have\n+   already been scheduled.  */\n+static int modulo_insns_scheduled;\n+\n+/* The maximum uid of insns from the first iteration of the loop.  */\n+static int modulo_iter0_max_uid;\n+\n+/* The number of times we should attempt to backtrack when modulo scheduling.\n+   Decreased each time we have to backtrack.  */\n+static int modulo_backtracks_left;\n+\n+/* The stage in which the last insn from the original loop was\n+   scheduled.  */\n+static int modulo_last_stage;\n+\n /* sched-verbose controls the amount of debugging output the\n    scheduler prints.  It is controlled by -fsched-verbose=N:\n    N>0 and no -DSR : the output is directed to stderr.\n@@ -507,6 +532,29 @@ haifa_classify_insn (const_rtx insn)\n {\n   return haifa_classify_rtx (PATTERN (insn));\n }\n+\f\n+/* After the scheduler initialization function has been called, this function\n+   can be called to enable modulo scheduling.  II is the initiation interval\n+   we should use, it affects the delays for delay_pairs that were recorded as\n+   separated by a given number of stages.\n+\n+   MAX_STAGES provides us with a limit\n+   after which we give up scheduling; the caller must have unrolled at least\n+   as many copies of the loop body and recorded delay_pairs for them.\n+   \n+   INSNS is the number of real (non-debug) insns in one iteration of\n+   the loop.  MAX_UID can be used to test whether an insn belongs to\n+   the first iteration of the loop; all of them have a uid lower than\n+   MAX_UID.  */\n+void\n+set_modulo_params (int ii, int max_stages, int insns, int max_uid)\n+{\n+  modulo_ii = ii;\n+  modulo_max_stages = max_stages;\n+  modulo_n_insns = insns;\n+  modulo_iter0_max_uid = max_uid;\n+  modulo_backtracks_left = PARAM_VALUE (PARAM_MAX_MODULO_BACKTRACK_ATTEMPTS);\n+}\n \n /* A structure to record a pair of insns where the first one is a real\n    insn that has delay slots, and the second is its delayed shadow.\n@@ -518,13 +566,73 @@ struct delay_pair\n   struct delay_pair *next_same_i1;\n   rtx i1, i2;\n   int cycles;\n+  /* When doing modulo scheduling, we a delay_pair can also be used to\n+     show that I1 and I2 are the same insn in a different stage.  If that\n+     is the case, STAGES will be nonzero.  */\n+  int stages;\n };\n \n /* Two hash tables to record delay_pairs, one indexed by I1 and the other\n    indexed by I2.  */\n static htab_t delay_htab;\n static htab_t delay_htab_i2;\n \n+/* Called through htab_traverse.  Walk the hashtable using I2 as\n+   index, and delete all elements involving an UID higher than\n+   that pointed to by *DATA.  */\n+static int\n+htab_i2_traverse (void **slot, void *data)\n+{\n+  int maxuid = *(int *)data;\n+  struct delay_pair *p = *(struct delay_pair **)slot;\n+  if (INSN_UID (p->i2) >= maxuid || INSN_UID (p->i1) >= maxuid)\n+    {\n+      htab_clear_slot (delay_htab_i2, slot);\n+    }\n+  return 1;\n+}\n+\n+/* Called through htab_traverse.  Walk the hashtable using I2 as\n+   index, and delete all elements involving an UID higher than\n+   that pointed to by *DATA.  */\n+static int\n+htab_i1_traverse (void **slot, void *data)\n+{\n+  int maxuid = *(int *)data;\n+  struct delay_pair **pslot = (struct delay_pair **)slot;\n+  struct delay_pair *p, *first, **pprev;\n+\n+  if (INSN_UID ((*pslot)->i1) >= maxuid)\n+    {\n+      htab_clear_slot (delay_htab, slot);\n+      return 1;\n+    }\n+  pprev = &first;\n+  for (p = *pslot; p; p = p->next_same_i1)\n+    {\n+      if (INSN_UID (p->i2) < maxuid)\n+\t{\n+\t  *pprev = p;\n+\t  pprev = &p->next_same_i1;\n+\t}\n+    }\n+  *pprev = NULL;\n+  if (first == NULL)\n+    htab_clear_slot (delay_htab, slot);\n+  else\n+    *pslot = first;\n+  return 1;\n+}\n+\n+/* Discard all delay pairs which involve an insn with an UID higher\n+   than MAX_UID.  */\n+void\n+discard_delay_pairs_above (int max_uid)\n+{\n+  htab_traverse (delay_htab, htab_i1_traverse, &max_uid);\n+  htab_traverse (delay_htab_i2, htab_i2_traverse, &max_uid);\n+}\n+\n /* Returns a hash value for X (which really is a delay_pair), based on\n    hashing just I1.  */\n static hashval_t\n@@ -555,25 +663,32 @@ delay_i2_eq (const void *x, const void *y)\n   return ((const struct delay_pair *) x)->i2 == y;\n }\n \n-/* This function can be called by a port just before it starts the\n-   final scheduling pass.  It records the fact that an instruction\n-   with delay slots has been split into two insns, I1 and I2.  The\n-   first one will be scheduled normally and initiates the operation.\n-   The second one is a shadow which must follow a specific number of\n-   CYCLES after I1; its only purpose is to show the side effect that\n-   occurs at that cycle in the RTL.  If a JUMP_INSN or a CALL_INSN has\n-   been split, I1 should be a normal INSN, while I2 retains the\n-   original insn type.  */\n+/* This function can be called by a port just before it starts the final\n+   scheduling pass.  It records the fact that an instruction with delay\n+   slots has been split into two insns, I1 and I2.  The first one will be\n+   scheduled normally and initiates the operation.  The second one is a\n+   shadow which must follow a specific number of cycles after I1; its only\n+   purpose is to show the side effect that occurs at that cycle in the RTL.\n+   If a JUMP_INSN or a CALL_INSN has been split, I1 should be a normal INSN,\n+   while I2 retains the original insn type.\n+\n+   There are two ways in which the number of cycles can be specified,\n+   involving the CYCLES and STAGES arguments to this function.  If STAGES\n+   is zero, we just use the value of CYCLES.  Otherwise, STAGES is a factor\n+   which is multiplied by MODULO_II to give the number of cycles.  This is\n+   only useful if the caller also calls set_modulo_params to enable modulo\n+   scheduling.  */\n \n void\n-record_delay_slot_pair (rtx i1, rtx i2, int cycles)\n+record_delay_slot_pair (rtx i1, rtx i2, int cycles, int stages)\n {\n   struct delay_pair *p = XNEW (struct delay_pair);\n   struct delay_pair **slot;\n \n   p->i1 = i1;\n   p->i2 = i2;\n   p->cycles = cycles;\n+  p->stages = stages;\n \n   if (!delay_htab)\n     {\n@@ -596,7 +711,10 @@ record_delay_slot_pair (rtx i1, rtx i2, int cycles)\n static int\n pair_delay (struct delay_pair *p)\n {\n-  return p->cycles;\n+  if (p->stages == 0)\n+    return p->cycles;\n+  else\n+    return p->stages * modulo_ii;\n }\n \n /* Given an insn INSN, add a dependence on its delayed shadow if it\n@@ -619,14 +737,16 @@ add_delay_dependencies (rtx insn)\n   if (!pair)\n     return;\n   add_dependence (insn, pair->i1, REG_DEP_ANTI);\n+  if (pair->stages)\n+    return;\n \n   FOR_EACH_DEP (pair->i2, SD_LIST_BACK, sd_it, dep)\n     {\n       rtx pro = DEP_PRO (dep);\n       struct delay_pair *other_pair\n \t= (struct delay_pair *)htab_find_with_hash (delay_htab_i2, pro,\n \t\t\t\t\t\t    htab_hash_pointer (pro));\n-      if (!other_pair)\n+      if (!other_pair || other_pair->stages)\n \tcontinue;\n       if (pair_delay (other_pair) >= pair_delay (pair))\n \t{\n@@ -1851,6 +1971,9 @@ struct sched_block_state\n   /* True if a shadow insn has been scheduled in the current cycle, which\n      means that no more normal insns can be issued.  */\n   bool shadows_only_p;\n+  /* True if we're winding down a modulo schedule, which means that we only\n+     issue insns with INSN_EXACT_TICK set.  */\n+  bool modulo_epilogue;\n   /* Initialized with the machine's issue rate every cycle, and updated\n      by calls to the variable_issue hook.  */\n   int can_issue_more;\n@@ -2223,7 +2346,7 @@ save_backtrack_point (struct delay_pair *pair,\n       mark_backtrack_feeds (pair->i2, 1);\n       INSN_TICK (pair->i2) = INVALID_TICK;\n       INSN_EXACT_TICK (pair->i2) = clock_var + pair_delay (pair);\n-      SHADOW_P (pair->i2) = true;\n+      SHADOW_P (pair->i2) = pair->stages == 0;\n       pair = pair->next_same_i1;\n     }\n }\n@@ -2249,11 +2372,14 @@ unschedule_insns_until (rtx insn)\n       if (last != insn)\n \tINSN_TICK (last) = INVALID_TICK;\n \n+      if (modulo_ii > 0 && INSN_UID (last) < modulo_iter0_max_uid)\n+\tmodulo_insns_scheduled--;\n+\n       for (sd_it = sd_iterator_start (last, SD_LIST_RES_FORW);\n \t   sd_iterator_cond (&sd_it, &dep);)\n \t{\n \t  rtx con = DEP_CON (dep);\n-\t  TODO_SPEC (con) |= HARD_DEP;\n+\t  TODO_SPEC (con) = HARD_DEP;\n \t  INSN_TICK (con) = INVALID_TICK;\n \t  sd_unresolve_dep (sd_it);\n \t}\n@@ -2467,6 +2593,56 @@ estimate_shadow_tick (struct delay_pair *p)\n   return 0;\n }\n \n+/* If INSN has no unresolved backwards dependencies, add it to the schedule and\n+   recursively resolve all its forward dependencies.  */\n+static void\n+resolve_dependencies (rtx insn)\n+{\n+  sd_iterator_def sd_it;\n+  dep_t dep;\n+\n+  /* Don't use sd_lists_empty_p; it ignores debug insns.  */\n+  if (DEPS_LIST_FIRST (INSN_HARD_BACK_DEPS (insn)) != NULL\n+      || DEPS_LIST_FIRST (INSN_SPEC_BACK_DEPS (insn)) != NULL)\n+    return;\n+\n+  if (sched_verbose >= 4)\n+    fprintf (sched_dump, \";;\\tquickly resolving %d\\n\", INSN_UID (insn));\n+\n+  if (QUEUE_INDEX (insn) >= 0)\n+    queue_remove (insn);\n+\n+  VEC_safe_push (rtx, heap, scheduled_insns, insn);\n+\n+  /* Update dependent instructions.  */\n+  for (sd_it = sd_iterator_start (insn, SD_LIST_FORW);\n+       sd_iterator_cond (&sd_it, &dep);)\n+    {\n+      rtx next = DEP_CON (dep);\n+\n+      if (sched_verbose >= 4)\n+\tfprintf (sched_dump, \";;\\t\\tdep %d against %d\\n\", INSN_UID (insn),\n+\t\t INSN_UID (next));\n+\n+      /* Resolve the dependence between INSN and NEXT.\n+\t sd_resolve_dep () moves current dep to another list thus\n+\t advancing the iterator.  */\n+      sd_resolve_dep (sd_it);\n+\n+      if (!IS_SPECULATION_BRANCHY_CHECK_P (insn))\n+\t{\n+\t  resolve_dependencies (next);\n+\t}\n+      else\n+\t/* Check always has only one forward dependence (to the first insn in\n+\t   the recovery block), therefore, this will be executed only once.  */\n+\t{\n+\t  gcc_assert (sd_lists_empty_p (insn, SD_LIST_FORW));\n+\t}\n+    }\n+}\n+\n+\n /* Return the head and tail pointers of ebb starting at BEG and ending\n    at END.  */\n void\n@@ -3448,15 +3624,12 @@ commit_schedule (rtx prev_head, rtx tail, basic_block *target_bb)\n    issue an asm statement.\n \n    If SHADOWS_ONLY_P is true, we eliminate all real insns and only\n-   leave those for which SHADOW_P is true.\n-\n-   Return the number of cycles we must\n-   advance to find the next ready instruction, or zero if there remain\n-   insns on the ready list.  */\n+   leave those for which SHADOW_P is true.  If MODULO_EPILOGUE is true,\n+   we only leave insns which have an INSN_EXACT_TICK.  */\n \n static void\n prune_ready_list (state_t temp_state, bool first_cycle_insn_p,\n-\t\t  bool shadows_only_p)\n+\t\t  bool shadows_only_p, bool modulo_epilogue_p)\n {\n   int i;\n \n@@ -3467,6 +3640,12 @@ prune_ready_list (state_t temp_state, bool first_cycle_insn_p,\n       int cost = 0;\n       const char *reason = \"resource conflict\";\n \n+      if (modulo_epilogue_p && !DEBUG_INSN_P (insn)\n+\t  && INSN_EXACT_TICK (insn) == INVALID_TICK)\n+\t{\n+\t  cost = max_insn_queue_index;\n+\t  reason = \"not an epilogue insn\";\n+\t}\n       if (shadows_only_p && !DEBUG_INSN_P (insn) && !SHADOW_P (insn))\n \t{\n \t  cost = 1;\n@@ -3580,10 +3759,11 @@ verify_shadows (void)\n    TARGET_BB, possibly bringing insns from subsequent blocks in the same\n    region.  */\n \n-void\n+bool\n schedule_block (basic_block *target_bb)\n {\n   int i;\n+  bool success = modulo_ii == 0;\n   struct sched_block_state ls;\n   state_t temp_state = NULL;  /* It is used for multipass scheduling.  */\n   int sort_p, advance, start_clock_var;\n@@ -3704,6 +3884,9 @@ schedule_block (basic_block *target_bb)\n   gcc_assert (VEC_length (rtx, scheduled_insns) == 0);\n   sort_p = TRUE;\n   must_backtrack = false;\n+  modulo_insns_scheduled = 0;\n+\n+  ls.modulo_epilogue = false;\n \n   /* Loop until all the insns in BB are scheduled.  */\n   while ((*current_sched_info->schedule_more_p) ())\n@@ -3733,8 +3916,41 @@ schedule_block (basic_block *target_bb)\n \t}\n       while (advance > 0);\n \n-      if (ready.n_ready > 0)\n-\tprune_ready_list (temp_state, true, false);\n+      if (ls.modulo_epilogue)\n+\t{\n+\t  int stage = clock_var / modulo_ii;\n+\t  if (stage > modulo_last_stage * 2 + 2)\n+\t    {\n+\t      if (sched_verbose >= 2)\n+\t\tfprintf (sched_dump,\n+\t\t\t \";;\\t\\tmodulo scheduled succeeded at II %d\\n\",\n+\t\t\t modulo_ii);\n+\t      success = true;\n+\t      goto end_schedule;\n+\t    }\n+\t}\n+      else if (modulo_ii > 0)\n+\t{\n+\t  int stage = clock_var / modulo_ii;\n+\t  if (stage > modulo_max_stages)\n+\t    {\n+\t      if (sched_verbose >= 2)\n+\t\tfprintf (sched_dump,\n+\t\t\t \";;\\t\\tfailing schedule due to excessive stages\\n\");\n+\t      goto end_schedule;\n+\t    }\n+\t  if (modulo_n_insns == modulo_insns_scheduled\n+\t      && stage > modulo_last_stage)\n+\t    {\n+\t      if (sched_verbose >= 2)\n+\t\tfprintf (sched_dump,\n+\t\t\t \";;\\t\\tfound kernel after %d stages, II %d\\n\",\n+\t\t\t stage, modulo_ii);\n+\t      ls.modulo_epilogue = true;\n+\t    }\n+\t}\n+\n+      prune_ready_list (temp_state, true, false, ls.modulo_epilogue);\n       if (ready.n_ready == 0)\n \tcontinue;\n       if (must_backtrack)\n@@ -3912,6 +4128,11 @@ schedule_block (basic_block *target_bb)\n \n \t  /* DECISION is made.  */\n \n+\t  if (modulo_ii > 0 && INSN_UID (insn) < modulo_iter0_max_uid)\n+\t    {\n+\t      modulo_insns_scheduled++;\n+\t      modulo_last_stage = clock_var / modulo_ii;\n+\t    }\n           if (TODO_SPEC (insn) & SPECULATIVE)\n             generate_recovery_code (insn);\n \n@@ -3964,7 +4185,8 @@ schedule_block (basic_block *target_bb)\n \n \t  ls.first_cycle_insn_p = false;\n \t  if (ready.n_ready > 0)\n-\t    prune_ready_list (temp_state, false, ls.shadows_only_p);\n+\t    prune_ready_list (temp_state, false, ls.shadows_only_p,\n+\t\t\t      ls.modulo_epilogue);\n \t}\n \n     do_backtrack:\n@@ -3979,6 +4201,12 @@ schedule_block (basic_block *target_bb)\n \t\tbreak;\n \t      }\n \t  }\n+      if (must_backtrack && modulo_ii > 0)\n+\t{\n+\t  if (modulo_backtracks_left == 0)\n+\t    goto end_schedule;\n+\t  modulo_backtracks_left--;\n+\t}\n       while (must_backtrack)\n \t{\n \t  struct haifa_saved_data *failed;\n@@ -4012,19 +4240,60 @@ schedule_block (basic_block *target_bb)\n \t    }\n \t}\n     }\n+  if (ls.modulo_epilogue)\n+    success = true;\n  end_schedule:\n+  if (modulo_ii > 0)\n+    {\n+      /* Once again, debug insn suckiness: they can be on the ready list\n+\t even if they have unresolved dependencies.  To make our view\n+\t of the world consistent, remove such \"ready\" insns.  */\n+    restart_debug_insn_loop:\n+      for (i = ready.n_ready - 1; i >= 0; i--)\n+\t{\n+\t  rtx x;\n+\n+\t  x = ready_element (&ready, i);\n+\t  if (DEPS_LIST_FIRST (INSN_HARD_BACK_DEPS (x)) != NULL\n+\t      || DEPS_LIST_FIRST (INSN_SPEC_BACK_DEPS (x)) != NULL)\n+\t    {\n+\t      ready_remove (&ready, i);\n+\t      goto restart_debug_insn_loop;\n+\t    }\n+\t}\n+      for (i = ready.n_ready - 1; i >= 0; i--)\n+\t{\n+\t  rtx x;\n+\n+\t  x = ready_element (&ready, i);\n+\t  resolve_dependencies (x);\n+\t}\n+      for (i = 0; i <= max_insn_queue_index; i++)\n+\t{\n+\t  rtx link;\n+\t  while ((link = insn_queue[i]) != NULL)\n+\t    {\n+\t      rtx x = XEXP (link, 0);\n+\t      insn_queue[i] = XEXP (link, 1);\n+\t      QUEUE_INDEX (x) = QUEUE_NOWHERE;\n+\t      free_INSN_LIST_node (link);\n+\t      resolve_dependencies (x);\n+\t    }\n+\t}\n+    }\n+\n   /* Debug info.  */\n   if (sched_verbose)\n     {\n       fprintf (sched_dump, \";;\\tReady list (final):  \");\n       debug_ready_list (&ready);\n     }\n \n-  if (current_sched_info->queue_must_finish_empty)\n+  if (modulo_ii == 0 && current_sched_info->queue_must_finish_empty)\n     /* Sanity check -- queue must be empty now.  Meaningless if region has\n        multiple bbs.  */\n     gcc_assert (!q_size && !ready.n_ready && !ready.n_debug);\n-  else\n+  else if (modulo_ii == 0)\n     {\n       /* We must maintain QUEUE_INDEX between blocks in region.  */\n       for (i = ready.n_ready - 1; i >= 0; i--)\n@@ -4052,9 +4321,16 @@ schedule_block (basic_block *target_bb)\n \t  }\n     }\n \n-  commit_schedule (prev_head, tail, target_bb);\n-  if (sched_verbose)\n-    fprintf (sched_dump, \";;   total time = %d\\n\", clock_var);\n+  if (success)\n+    {\n+      commit_schedule (prev_head, tail, target_bb);\n+      if (sched_verbose)\n+\tfprintf (sched_dump, \";;   total time = %d\\n\", clock_var);\n+    }\n+  else\n+    last_scheduled_insn = tail;\n+\n+  VEC_truncate (rtx, scheduled_insns, 0);\n \n   if (!current_sched_info->queue_must_finish_empty\n       || haifa_recovery_bb_recently_added_p)\n@@ -4092,6 +4368,8 @@ schedule_block (basic_block *target_bb)\n   current_sched_info->tail = tail;\n \n   free_backtrack_queue ();\n+\n+  return success;\n }\n \f\n /* Set_priorities: compute priority of each insn in the block.  */\n@@ -4302,6 +4580,8 @@ haifa_sched_init (void)\n   nr_begin_data = nr_begin_control = nr_be_in_data = nr_be_in_control = 0;\n   before_recovery = 0;\n   after_recovery = 0;\n+\n+  modulo_ii = 0;\n }\n \n /* Finish work with the data specific to the Haifa scheduler.  */"}, {"sha": "5e49c48f7b9db968bdf0dfd222510553e05fa606", "filename": "gcc/params.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d7e8e7066b42f440993419493909fefafdc4d5/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d7e8e7066b42f440993419493909fefafdc4d5/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=06d7e8e7066b42f440993419493909fefafdc4d5", "patch": "@@ -165,6 +165,13 @@ DEFPARAM(PARAM_MAX_PENDING_LIST_LENGTH,\n \t \"The maximum length of scheduling's pending operations list\",\n \t 32, 0, 0)\n \n+/* This parameter limits the number of backtracking attempts when using the\n+   haifa scheduler for modulo scheduling.  */\n+DEFPARAM(PARAM_MAX_MODULO_BACKTRACK_ATTEMPTS,\n+\t \"max-modulo-backtrack-attempts\",\n+\t \"The maximum number of backtrack attempts the scheduler should make when modulo scheduling a loop\",\n+\t 40, 0, 0)\n+\n DEFPARAM(PARAM_LARGE_FUNCTION_INSNS,\n \t \"large-function-insns\",\n \t \"The size of function body to be considered large\","}, {"sha": "5e90cd1da53d3827ab37530f59af00adcc4c2dab", "filename": "gcc/sched-int.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d7e8e7066b42f440993419493909fefafdc4d5/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d7e8e7066b42f440993419493909fefafdc4d5/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=06d7e8e7066b42f440993419493909fefafdc4d5", "patch": "@@ -1257,7 +1257,7 @@ extern int dep_cost (dep_t);\n extern int set_priorities (rtx, rtx);\n \n extern void sched_setup_bb_reg_pressure_info (basic_block, rtx);\n-extern void schedule_block (basic_block *);\n+extern bool schedule_block (basic_block *);\n \n extern int cycle_issued_insns;\n extern int issue_rate;\n@@ -1330,7 +1330,9 @@ extern int current_blocks;\n extern int target_bb;\n extern bool sched_no_dce;\n \n-extern void record_delay_slot_pair (rtx, rtx, int);\n+extern void set_modulo_params (int, int, int, int);\n+extern void record_delay_slot_pair (rtx, rtx, int, int);\n+extern void discard_delay_pairs_above (int);\n extern void free_delay_pairs (void);\n extern void add_delay_dependencies (rtx);\n extern bool sched_is_disabled_for_current_region_p (void);"}]}