{"sha": "066aca280f5d83e2afcf755e2627e4d40571aef7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY2YWNhMjgwZjVkODNlMmFmY2Y3NTVlMjYyN2U0ZDQwNTcxYWVmNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-08-14T09:58:18Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-08-14T09:58:18Z"}, "message": "(count_possible_groups) Pass CLASS as arg and only try to find groups\nof that class.\n\nFrom-SVN: r7915", "tree": {"sha": "bed5d2c18a30e5551ffcb9b054ecec56a659200e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bed5d2c18a30e5551ffcb9b054ecec56a659200e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/066aca280f5d83e2afcf755e2627e4d40571aef7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/066aca280f5d83e2afcf755e2627e4d40571aef7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/066aca280f5d83e2afcf755e2627e4d40571aef7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/066aca280f5d83e2afcf755e2627e4d40571aef7/comments", "author": null, "committer": null, "parents": [{"sha": "a49fdcae47e88d6276ced83ea5eeb7f5d969a133", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a49fdcae47e88d6276ced83ea5eeb7f5d969a133", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a49fdcae47e88d6276ced83ea5eeb7f5d969a133"}], "stats": {"total": 102, "additions": 50, "deletions": 52}, "files": [{"sha": "999b5e3f30c8b3fd0155a2a4e631b1d642f11a4f", "filename": "gcc/reload1.c", "status": "modified", "additions": 50, "deletions": 52, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/066aca280f5d83e2afcf755e2627e4d40571aef7/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/066aca280f5d83e2afcf755e2627e4d40571aef7/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=066aca280f5d83e2afcf755e2627e4d40571aef7", "patch": "@@ -327,7 +327,7 @@ struct hard_reg_n_uses { int regno; int uses; };\n \f\n static int possible_group_p\t\tPROTO((int, int *));\n static void count_possible_groups\tPROTO((int *, enum machine_mode *,\n-\t\t\t\t\t       int *));\n+\t\t\t\t\t       int *, int));\n static int modes_equiv_for_class_p\tPROTO((enum machine_mode,\n \t\t\t\t\t       enum machine_mode,\n \t\t\t\t\t       enum reg_class));\n@@ -1603,7 +1603,8 @@ reload (first, global, dumpfile)\n \t      /* If any single spilled regs happen to form groups,\n \t\t count them now.  Maybe we don't really need\n \t\t to spill another group.  */\n-\t      count_possible_groups (group_size, group_mode, max_groups);\n+\t      count_possible_groups (group_size, group_mode, max_groups,\n+\t\t\t\t     class);\n \n \t      if (max_groups[class] <= 0)\n \t\tbreak;\n@@ -2063,68 +2064,65 @@ possible_group_p (regno, max_groups)\n   return 0;\n }\n \f\n-/* Count any groups that can be formed from the registers recently spilled.\n-   This is done class by class, in order of ascending class number.  */\n+/* Count any groups of CLASS that can be formed from the registers recently\n+   spilled.  */\n \n static void\n-count_possible_groups (group_size, group_mode, max_groups)\n+count_possible_groups (group_size, group_mode, max_groups, class)\n      int *group_size;\n      enum machine_mode *group_mode;\n      int *max_groups;\n+     int class;\n {\n-  int i;\n+  HARD_REG_SET new;\n+  int i, j;\n+\n   /* Now find all consecutive groups of spilled registers\n      and mark each group off against the need for such groups.\n      But don't count them against ordinary need, yet.  */\n \n-  for (i = 0; i < N_REG_CLASSES; i++)\n-    if (group_size[i] > 1)\n+  if (group_size[class] == 0)\n+    return;\n+\n+  CLEAR_HARD_REG_SET (new);\n+\n+  /* Make a mask of all the regs that are spill regs in class I.  */\n+  for (i = 0; i < n_spills; i++)\n+    if (TEST_HARD_REG_BIT (reg_class_contents[class], spill_regs[i])\n+\t&& ! TEST_HARD_REG_BIT (counted_for_groups, spill_regs[i])\n+\t&& ! TEST_HARD_REG_BIT (counted_for_nongroups, spill_regs[i]))\n+      SET_HARD_REG_BIT (new, spill_regs[i]);\n+\n+  /* Find each consecutive group of them.  */\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER && max_groups[class] > 0; i++)\n+    if (TEST_HARD_REG_BIT (new, i)\n+\t&& i + group_size[class] <= FIRST_PSEUDO_REGISTER\n+\t&& HARD_REGNO_MODE_OK (i, group_mode[class]))\n       {\n-\tHARD_REG_SET new;\n-\tint j;\n-\n-\tCLEAR_HARD_REG_SET (new);\n-\n-\t/* Make a mask of all the regs that are spill regs in class I.  */\n-\tfor (j = 0; j < n_spills; j++)\n-\t  if (TEST_HARD_REG_BIT (reg_class_contents[i], spill_regs[j])\n-\t      && ! TEST_HARD_REG_BIT (counted_for_groups, spill_regs[j])\n-\t      && ! TEST_HARD_REG_BIT (counted_for_nongroups,\n-\t\t\t\t      spill_regs[j]))\n-\t    SET_HARD_REG_BIT (new, spill_regs[j]);\n-\n-\t/* Find each consecutive group of them.  */\n-\tfor (j = 0; j < FIRST_PSEUDO_REGISTER && max_groups[i] > 0; j++)\n-\t  if (TEST_HARD_REG_BIT (new, j)\n-\t      && j + group_size[i] <= FIRST_PSEUDO_REGISTER\n-\t      /* Next line in case group-mode for this class\n-\t\t demands an even-odd pair.  */\n-\t      && HARD_REGNO_MODE_OK (j, group_mode[i]))\n-\t    {\n-\t      int k;\n-\t      for (k = 1; k < group_size[i]; k++)\n-\t\tif (! TEST_HARD_REG_BIT (new, j + k))\n-\t\t  break;\n-\t      if (k == group_size[i])\n-\t\t{\n-\t\t  /* We found a group.  Mark it off against this class's\n-\t\t     need for groups, and against each superclass too.  */\n-\t\t  register enum reg_class *p;\n-\t\t  max_groups[i]--;\n-\t\t  p = reg_class_superclasses[i];\n-\t\t  while (*p != LIM_REG_CLASSES)\n-\t\t    max_groups[(int) *p++]--;\n-\t\t  /* Don't count these registers again.  */\n-\t\t  for (k = 0; k < group_size[i]; k++)\n-\t\t    SET_HARD_REG_BIT (counted_for_groups, j + k);\n-\t\t}\n-\t      /* Skip to the last reg in this group.  When j is incremented\n-\t\t above, it will then point to the first reg of the next\n-\t\t possible group.  */\n-\t      j += k - 1;\n-\t    }\n-      }\n+\tfor (j = 1; j < group_size[class]; j++)\n+\t  if (! TEST_HARD_REG_BIT (new, i + j))\n+\t    break;\n \n+\tif (j == group_size[class])\n+\t  {\n+\t    /* We found a group.  Mark it off against this class's need for\n+\t       groups, and against each superclass too.  */\n+\t    register enum reg_class *p;\n+\n+\t    max_groups[class]--;\n+\t    p = reg_class_superclasses[class];\n+\t    while (*p != LIM_REG_CLASSES)\n+\t      max_groups[(int) *p++]--;\n+\n+\t    /* Don't count these registers again.  */\n+\t    for (j = 0; j < group_size[j]; j++)\n+\t      SET_HARD_REG_BIT (counted_for_groups, i + j);\n+\t  }\n+\n+\t/* Skip to the last reg in this group.  When i is incremented above,\n+\t   it will then point to the first reg of the next possible group.  */\n+\ti += j - 1;\n+      }\n }\n \f\n /* ALLOCATE_MODE is a register mode that needs to be reloaded.  OTHER_MODE is"}]}