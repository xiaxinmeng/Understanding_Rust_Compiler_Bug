{"sha": "e920ebc9311d99636a40f1ff229ecd4167f46166", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkyMGViYzkzMTFkOTk2MzZhNDBmMWZmMjI5ZWNkNDE2N2Y0NjE2Ng==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "1999-12-30T22:36:25Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1999-12-30T22:36:25Z"}, "message": "class.c (class_depth): Return -1 if the class doesn't load properly.\n\n1999-12-14  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n        * class.c (class_depth): Return -1 if the class doesn't load\n        properly.\n        * expr.c (can_widen_reference_to): Check for errors during depth\n        computation and return 0 accordingly.\n        * jcf-parse.c (parse_source_file): Call java_fix_constructors to\n        create default constructors and add an other error check.\n        * parse.h (java_fix_constructors): Prototyped.\n        * parse.y (java_pre_expand_clinit): Likewise.\n        (build_super_invocation): Re-prototyped to feature one argument.\n        (java_check_circular_reference): Directly use `current'.\n        (java_fix_constructors): New function.\n        (java_check_regular_methods): Don't create default constructors\n        here, but abort if none were found.\n        (java_complete_expand_methods): Pre-process <clinit> calling\n        java_pre_expand_clinit.\n        (java_pre_expand_clinit): New function.\n        (fix_constructors): build_super_invocation invoked with the\n        current method declaration as an argument.\n        (build_super_invocation): Use the context of the processed method\n        decl argument instead of current_class.\n        * typeck.c (lookup_java_method): Take WFLs in method names into\n        account.\n\nFrom-SVN: r31144", "tree": {"sha": "9853301b4a969ce1435d6529c461d2f6510bc73a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9853301b4a969ce1435d6529c461d2f6510bc73a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e920ebc9311d99636a40f1ff229ecd4167f46166", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e920ebc9311d99636a40f1ff229ecd4167f46166", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e920ebc9311d99636a40f1ff229ecd4167f46166", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e920ebc9311d99636a40f1ff229ecd4167f46166/comments", "author": null, "committer": null, "parents": [{"sha": "f0353e33dc68775a0c880a86d24b7f8df95ed7c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0353e33dc68775a0c880a86d24b7f8df95ed7c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0353e33dc68775a0c880a86d24b7f8df95ed7c7"}], "stats": {"total": 199, "additions": 137, "deletions": 62}, "files": [{"sha": "f27b2bcdbc4da7f22b03727a7ea72aeb2f7b0cdc", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e920ebc9311d99636a40f1ff229ecd4167f46166/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e920ebc9311d99636a40f1ff229ecd4167f46166/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=e920ebc9311d99636a40f1ff229ecd4167f46166", "patch": "@@ -1,3 +1,28 @@\n+1999-12-14  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* class.c (class_depth): Return -1 if the class doesn't load\n+\tproperly.\n+\t* expr.c (can_widen_reference_to): Check for errors during depth\n+\tcomputation and return 0 accordingly.\n+\t* jcf-parse.c (parse_source_file): Call java_fix_constructors to\n+\tcreate default constructors and add an other error check.\n+\t* parse.h (java_fix_constructors): Prototyped.\n+\t* parse.y (java_pre_expand_clinit): Likewise.\n+\t(build_super_invocation): Re-prototyped to feature one argument.\n+\t(java_check_circular_reference): Directly use `current'.\n+\t(java_fix_constructors): New function.\n+\t(java_check_regular_methods): Don't create default constructors\n+\there, but abort if none were found.\n+\t(java_complete_expand_methods): Pre-process <clinit> calling\n+\tjava_pre_expand_clinit.\n+\t(java_pre_expand_clinit): New function.\n+\t(fix_constructors): build_super_invocation invoked with the\n+\tcurrent method declaration as an argument.\n+\t(build_super_invocation): Use the context of the processed method\n+\tdecl argument instead of current_class.\n+\t* typeck.c (lookup_java_method): Take WFLs in method names into\n+\taccount.\n+\t\n 1999-12-17  Tom Tromey  <tromey@cygnus.com>\n \n \t* gjavah.c (decode_signature_piece): Print \"::\" in JArray<>.  This"}, {"sha": "e042c13193137bec5a6821a6ce5f9ee839bc304e", "filename": "gcc/java/class.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e920ebc9311d99636a40f1ff229ecd4167f46166/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e920ebc9311d99636a40f1ff229ecd4167f46166/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=e920ebc9311d99636a40f1ff229ecd4167f46166", "patch": "@@ -403,6 +403,8 @@ class_depth (clas)\n   int depth = 0;\n   if (! CLASS_LOADED_P (clas))\n     load_class (clas, 1);\n+  if (TYPE_SIZE (clas) == error_mark_node)\n+    return -1;\n   while (clas != object_type_node)\n     {\n       depth++;"}, {"sha": "d789efb6292fe02f374397c507f735d204c1e6a7", "filename": "gcc/java/expr.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e920ebc9311d99636a40f1ff229ecd4167f46166/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e920ebc9311d99636a40f1ff229ecd4167f46166/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=e920ebc9311d99636a40f1ff229ecd4167f46166", "patch": "@@ -386,6 +386,10 @@ can_widen_reference_to (source_type, target_type)\n \t  int source_depth = class_depth (source_type);\n \t  int target_depth = class_depth (target_type);\n \n+\t  /* class_depth can return a negative depth if an error occurred */\n+\t  if (source_depth < 0 || target_depth < 0)\n+\t    return 0;\n+\n \t  if (CLASS_INTERFACE (TYPE_NAME (target_type)))\n \t    {\n \t      /* target_type is OK if source_type or source_type ancestors"}, {"sha": "c182789391112d352c476839cbc94d71db2df7f0", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e920ebc9311d99636a40f1ff229ecd4167f46166/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e920ebc9311d99636a40f1ff229ecd4167f46166/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=e920ebc9311d99636a40f1ff229ecd4167f46166", "patch": "@@ -756,6 +756,8 @@ parse_source_file (file)\n   java_parse_abort_on_error ();\n   java_check_circular_reference (); /* Check on circular references */\n   java_parse_abort_on_error ();\n+  java_fix_constructors ();\t    /* Fix the constructors */\n+  java_parse_abort_on_error ();\n }\n \n static int"}, {"sha": "2cfbedaf6028632089d3a71baa5cbe7605a5e78f", "filename": "gcc/java/parse.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e920ebc9311d99636a40f1ff229ecd4167f46166/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e920ebc9311d99636a40f1ff229ecd4167f46166/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=e920ebc9311d99636a40f1ff229ecd4167f46166", "patch": "@@ -662,6 +662,7 @@ struct parser_ctxt {\n void safe_layout_class PROTO ((tree));\n void java_complete_class PROTO ((void));\n void java_check_circular_reference PROTO ((void));\n+void java_fix_constructors PROTO ((void));\n void java_check_final PROTO ((void));\n void java_layout_classes PROTO ((void));\n tree java_method_add_stmt PROTO ((tree, tree));"}, {"sha": "e5853a7061afc9eb6dd3b93ed64cb3c4e2aa2033", "filename": "gcc/java/parse.y", "status": "modified", "additions": 96, "deletions": 60, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e920ebc9311d99636a40f1ff229ecd4167f46166/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e920ebc9311d99636a40f1ff229ecd4167f46166/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=e920ebc9311d99636a40f1ff229ecd4167f46166", "patch": "@@ -134,6 +134,7 @@ static tree register_incomplete_type PROTO ((int, tree, tree, tree));\n static tree obtain_incomplete_type PROTO ((tree));\n static tree java_complete_lhs PROTO ((tree));\n static tree java_complete_tree PROTO ((tree));\n+static int java_pre_expand_clinit PROTO ((tree));\n static void java_complete_expand_method PROTO ((tree));\n static int  unresolved_type_p PROTO ((tree, tree *));\n static void create_jdep_list PROTO ((struct parser_ctxt *));\n@@ -216,7 +217,7 @@ static int check_thrown_exceptions_do PROTO ((tree));\n static void purge_unchecked_exceptions PROTO ((tree));\n static void check_throws_clauses PROTO ((tree, tree, tree));\n static void finish_method_declaration PROTO ((tree));\n-static tree build_super_invocation PROTO ((void));\n+static tree build_super_invocation PROTO ((tree));\n static int verify_constructor_circularity PROTO ((tree, tree));\n static char *constructor_circularity_msg PROTO ((tree, tree));\n static tree build_this_super_qualified_invocation PROTO ((int, tree, tree,\n@@ -3985,7 +3986,7 @@ java_check_circular_reference ()\n   for (current = ctxp->class_list; current; current = TREE_CHAIN (current))\n     {\n       tree type = TREE_TYPE (current);\n-      if (CLASS_INTERFACE (TYPE_NAME (type)))\n+      if (CLASS_INTERFACE (current))\n \t{\n \t  /* Check all interfaces this class extends */\n \t  tree basetype_vec = TYPE_BINFO_BASETYPES (type);\n@@ -4010,6 +4011,44 @@ java_check_circular_reference ()\n     }\n }\n \n+/* Fix the constructors. This will be called right after circular\n+   references have been checked. It is necessary to fix constructors\n+   early even if no code generation will take place for that class:\n+   some generated constructor might be required by the class whose\n+   compilation triggered this one to be simply loaded.  */\n+\n+void\n+java_fix_constructors ()\n+{\n+  tree current;\n+\n+  for (current = ctxp->class_list; current; current = TREE_CHAIN (current))\n+    {\n+      tree decl;\n+      tree class_type = TREE_TYPE (current);\n+      int saw_ctor = 0;\n+\n+      for (decl = TYPE_METHODS (class_type); decl; decl = TREE_CHAIN (decl))\n+\t{\n+\t  if (DECL_CONSTRUCTOR_P (decl))\n+\t    {\n+\t      fix_constructors (decl);\n+\t      saw_ctor = 1;\n+\t    }\n+\t}\n+\n+      if (!saw_ctor)\n+\t{\n+\t  int flags = (get_access_flags_from_decl (current) & ACC_PUBLIC ?\n+\t\t       ACC_PUBLIC : 0);\n+\t  decl = create_artificial_method (class_type, flags, void_type_node, \n+\t\t\t\t\t   init_identifier_node, \n+\t\t\t\t\t   end_params_node);\n+\t  DECL_CONSTRUCTOR_P (decl) = 1;\n+\t}\n+    }\n+}\n+\n /* safe_layout_class just makes sure that we can load a class without\n    disrupting the current_class, input_file, lineno, etc, information\n    about the class processed currently.  */\n@@ -4916,24 +4955,7 @@ java_check_regular_methods (class_decl)\n   java_check_abstract_method_definitions (class_decl);\n \n   if (!saw_constructor)\n-    {\n-      /* No constructor seen, we craft one, at line 0. Since this\n-       operation takes place after we laid methods out\n-       (layout_class_methods), we prepare the its DECL\n-       appropriately. */\n-      int flags;\n-      tree decl;\n-\n-      /* If the class is declared PUBLIC, the default constructor is\n-         PUBLIC otherwise it has default access implied by no access\n-         modifiers. */\n-      flags = (get_access_flags_from_decl (class_decl) & ACC_PUBLIC ?\n-\t       ACC_PUBLIC : 0);\n-      decl = create_artificial_method (class, flags, void_type_node, \n-\t\t\t\t       init_identifier_node, end_params_node);\n-      DECL_CONSTRUCTOR_P (decl) = 1;\n-      layout_class_method (TREE_TYPE (class_decl), NULL_TREE, decl, NULL_TREE);\n-    }\n+    fatal (\"No constructor found\");\n }\n \n /* Return a non zero value if the `throws' clause of METHOD (if any)\n@@ -5999,7 +6021,7 @@ java_complete_expand_methods ()\n     {\n       int is_interface;\n       tree class_type = CLASS_TO_HANDLE_TYPE (TREE_TYPE (current));\n-      tree decl;\n+      tree decl, prev_decl;\n \n       current_class = TREE_TYPE (current);\n       is_interface = CLASS_INTERFACE (TYPE_NAME (current_class));\n@@ -6008,42 +6030,21 @@ java_complete_expand_methods ()\n       init_outgoing_cpool ();\n \n       /* We want <clinit> (if any) to be processed first. */\n-      decl = tree_last (TYPE_METHODS (class_type));\n-      if (IS_CLINIT (decl))\n-\t{\n-\t  tree fbody = DECL_FUNCTION_BODY (decl);\n-\t  tree list;\n-\t  if (fbody != NULL_TREE)\n-\t    {\n-\t      /* First check if we can ignore empty <clinit> */\n-\t      tree block_body = BLOCK_EXPR_BODY (fbody);\n-\n-\t      current_this = NULL_TREE;\n-\t      current_function_decl = decl;\n-\t      if (block_body != NULL_TREE)\n-\t\t{\n-\t\t  /* Prevent the use of `this' inside <clinit> */\n-\t\t  ctxp->explicit_constructor_p = 1;\n+      for (prev_decl = NULL_TREE, decl = TYPE_METHODS (class_type); \n+\t   decl; prev_decl= decl, decl = TREE_CHAIN (decl))\n+\tif (IS_CLINIT (decl))\n+\t  {\n+\t    if (!java_pre_expand_clinit (decl))\n+\t      {\n+\t\tif (prev_decl)\n+\t\t  TREE_CHAIN (prev_decl) = TREE_CHAIN (decl);\n+\t\telse\n+\t\t  TYPE_METHODS (class_type) = TREE_CHAIN (decl);\n+\t      }\n+\t    break;\n+\t  }\n \n-\t\t  block_body = java_complete_tree (block_body);\n-\t\t  ctxp->explicit_constructor_p = 0;\n-\t\t  BLOCK_EXPR_BODY (fbody) = block_body;\n-\t\t  if (block_body != NULL_TREE\n-\t\t      && TREE_CODE (block_body) == BLOCK\n-\t\t      && BLOCK_EXPR_BODY (block_body) == empty_stmt_node)\n-\t\t    decl = NULL_TREE;\n-\t\t}\n-\t    }\n-\t  list = nreverse (TREE_CHAIN (nreverse (TYPE_METHODS (class_type))));\n-\t  if (decl != NULL_TREE)\n-\t    {\n-\t      TREE_CHAIN (decl) = list;\n-\t      TYPE_METHODS (class_type) = decl;\n-\t    }\n-\t    else\n-\t      TYPE_METHODS (class_type) = list;\n-\t}\n-      \n+      /* Now go on for regular business.  */\n       for (decl = TYPE_METHODS (class_type); decl; decl = TREE_CHAIN (decl))\n \t{\n \t  current_function_decl = decl;\n@@ -6092,6 +6093,40 @@ java_complete_expand_methods ()\n    the list of the catch clauses of the currently analysed try block. */\n static tree currently_caught_type_list;\n \n+/* Complete and expand <clinit>. Return a non zero value if <clinit>\n+   is worth keeping.  */\n+\n+static int\n+java_pre_expand_clinit (decl)\n+     tree decl;\n+{\n+  tree fbody = DECL_FUNCTION_BODY (decl);\n+  tree list;\n+  int to_return = 1;\n+\n+  if (fbody != NULL_TREE)\n+    {\n+      /* First check if we can ignore empty <clinit> */\n+      tree block_body = BLOCK_EXPR_BODY (fbody);\n+      \n+      current_this = NULL_TREE;\n+      current_function_decl = decl;\n+      if (block_body != NULL_TREE)\n+\t{\n+\t  /* Prevent the use of `this' inside <clinit> */\n+\t  ctxp->explicit_constructor_p = 1;\n+\t  block_body = java_complete_tree (block_body);\n+\t  ctxp->explicit_constructor_p = 0;\n+\n+\t  BLOCK_EXPR_BODY (fbody) = block_body;\n+\t  if (block_body != NULL_TREE  && TREE_CODE (block_body) == BLOCK\n+\t      && BLOCK_EXPR_BODY (block_body) == empty_stmt_node)\n+\t    to_return = 0;\n+\t}\n+    }\n+  return to_return;\n+}\n+\n /* Complete and expand a method.  */\n \n static void\n@@ -6197,7 +6232,7 @@ fix_constructors (mdecl)\n       /* We don't generate a super constructor invocation if we're\n \t compiling java.lang.Object. build_super_invocation takes care\n \t of that. */\n-      compound = java_method_add_stmt (mdecl, build_super_invocation ());\n+      compound = java_method_add_stmt (mdecl, build_super_invocation (mdecl));\n \n       end_artificial_method_body (mdecl);\n     }\n@@ -6229,7 +6264,7 @@ fix_constructors (mdecl)\n       /* The constructor is missing an invocation of super() */\n       if (!found)\n \tcompound = add_stmt_to_compound (compound, NULL_TREE,\n-\t\t\t\t\t build_super_invocation ());\n+\t\t\t\t\t build_super_invocation (mdecl));\n       \n       /* Fix the constructor main block if we're adding extra stmts */\n       if (compound)\n@@ -8923,9 +8958,10 @@ maybe_absorb_scoping_blocks ()\n    we're currently dealing with the class java.lang.Object. */\n \n static tree\n-build_super_invocation ()\n+build_super_invocation (mdecl)\n+     tree mdecl;\n {\n-  if (current_class == object_type_node)\n+  if (DECL_CONTEXT (mdecl) == object_type_node)\n     return empty_stmt_node;\n   else\n     {"}, {"sha": "213a3899fbc183b343d6b1cf59c4b46fe24755c7", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e920ebc9311d99636a40f1ff229ecd4167f46166/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e920ebc9311d99636a40f1ff229ecd4167f46166/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=e920ebc9311d99636a40f1ff229ecd4167f46166", "patch": "@@ -755,7 +755,10 @@ lookup_java_method (searched_class, method_name, method_signature)\n \t   method != NULL_TREE;  method = TREE_CHAIN (method))\n \t{\n \t  tree method_sig = build_java_signature (TREE_TYPE (method));\n-\t  if (DECL_NAME (method) == method_name \n+\t  tree name = DECL_NAME (method);\n+\n+\t  if ((TREE_CODE (name) == EXPR_WITH_FILE_LOCATION ?\n+\t       EXPR_WFL_NODE (name) : name) == method_name\n \t      && method_sig == method_signature)\n \t    return method;\n \t}\n@@ -788,8 +791,10 @@ lookup_java_method (searched_class, method_name, method_signature)\n               method != NULL_TREE;  method = TREE_CHAIN (method))\n            {\n              tree method_sig = build_java_signature (TREE_TYPE (method));\n+\t     tree name = DECL_NAME (method);\n \n-             if (DECL_NAME (method) == method_name \n+\t     if ((TREE_CODE (name) == EXPR_WITH_FILE_LOCATION ?\n+\t\t  EXPR_WFL_NODE (name) : name) == method_name\n \t\t && method_sig == method_signature)\n                return method;\n            }"}]}