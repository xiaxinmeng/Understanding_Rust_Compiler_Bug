{"sha": "a90fe12c80a13ffed9d5c775703788275d8b7c42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTkwZmUxMmM4MGExM2ZmZWQ5ZDVjNzc1NzAzNzg4Mjc1ZDhiN2M0Mg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-07-11T19:43:25Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-07-11T19:43:25Z"}, "message": "Define std::atomic_ref and std::atomic<floating-point> for C++20\n\nThis adds the new atomic types from C++2a, as proposed by P0019 and\nP0020. To reduce duplication the calls to the compiler's atomic\nbuilt-ins are wrapped in new functions in the __atomic_impl namespace.\nThese functions are currently only used by std::atomic<floating-point>\nand std::atomic_ref but could also be used for all other specializations\nof std::atomic.\n\n\t* include/bits/atomic_base.h (__atomic_impl): New namespace for\n\twrappers around atomic built-ins.\n\t(__atomic_float, __atomic_ref): New class templates for use as base\n\tclasses.\n\t* include/std/atomic (atomic<float>, atomic<double>)\n\t(atomic<long double>): New explicit specializations.\n\t(atomic_ref): New class template.\n\t(__cpp_lib_atomic_ref): Define.\n\t* include/std/version (__cpp_lib_atomic_ref): Define.\n\t* testsuite/29_atomics/atomic/60695.cc: Adjust dg-error.\n    \t* testsuite/29_atomics/atomic_float/1.cc: New test.\n    \t* testsuite/29_atomics/atomic_float/requirements.cc: New test.\n    \t* testsuite/29_atomics/atomic_ref/deduction.cc: New test.\n    \t* testsuite/29_atomics/atomic_ref/float.cc: New test.\n    \t* testsuite/29_atomics/atomic_ref/generic.cc: New test.\n    \t* testsuite/29_atomics/atomic_ref/integral.cc: New test.\n    \t* testsuite/29_atomics/atomic_ref/pointer.cc: New test.\n    \t* testsuite/29_atomics/atomic_ref/requirements.cc: New test.\n\nFrom-SVN: r273420", "tree": {"sha": "aa520ab892dcf849531edb655bcff7516e600618", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa520ab892dcf849531edb655bcff7516e600618"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a90fe12c80a13ffed9d5c775703788275d8b7c42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a90fe12c80a13ffed9d5c775703788275d8b7c42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a90fe12c80a13ffed9d5c775703788275d8b7c42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a90fe12c80a13ffed9d5c775703788275d8b7c42/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c98bdadcb67e12c63882587d96ab6335711f009", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c98bdadcb67e12c63882587d96ab6335711f009", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c98bdadcb67e12c63882587d96ab6335711f009"}], "stats": {"total": 2716, "additions": 2714, "deletions": 2}, "files": [{"sha": "688615f48c9285129c81cd62692469f57ff9ff25", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a90fe12c80a13ffed9d5c775703788275d8b7c42", "patch": "@@ -1,3 +1,24 @@\n+2019-07-11  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/bits/atomic_base.h (__atomic_impl): New namespace for\n+\twrappers around atomic built-ins.\n+\t(__atomic_float, __atomic_ref): New class templates for use as base\n+\tclasses.\n+\t* include/std/atomic (atomic<float>, atomic<double>)\n+\t(atomic<long double>): New explicit specializations.\n+\t(atomic_ref): New class template.\n+\t(__cpp_lib_atomic_ref): Define.\n+\t* include/std/version (__cpp_lib_atomic_ref): Define.\n+\t* testsuite/29_atomics/atomic/60695.cc: Adjust dg-error.\n+\t* testsuite/29_atomics/atomic_float/1.cc: New test.\n+\t* testsuite/29_atomics/atomic_float/requirements.cc: New test.\n+\t* testsuite/29_atomics/atomic_ref/deduction.cc: New test.\n+\t* testsuite/29_atomics/atomic_ref/float.cc: New test.\n+\t* testsuite/29_atomics/atomic_ref/generic.cc: New test.\n+\t* testsuite/29_atomics/atomic_ref/integral.cc: New test.\n+\t* testsuite/29_atomics/atomic_ref/pointer.cc: New test.\n+\t* testsuite/29_atomics/atomic_ref/requirements.cc: New test.\n+\n 2019-07-06  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/ext/atomicity.h (__exchange_and_add, __atomic_add): Replace"}, {"sha": "146e70a9f2ebb0e7915cb4561f82a638b8e4e648", "filename": "libstdc++-v3/include/bits/atomic_base.h", "status": "modified", "additions": 871, "deletions": 0, "changes": 871, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h?ref=a90fe12c80a13ffed9d5c775703788275d8b7c42", "patch": "@@ -35,6 +35,7 @@\n #include <bits/c++config.h>\n #include <stdint.h>\n #include <bits/atomic_lockfree_defines.h>\n+#include <bits/move.h>\n \n #ifndef _GLIBCXX_ALWAYS_INLINE\n #define _GLIBCXX_ALWAYS_INLINE inline __attribute__((__always_inline__))\n@@ -817,6 +818,876 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), int(__m)); }\n     };\n \n+#if __cplusplus > 201703L\n+  // Implementation details of atomic_ref and atomic<floating-point>.\n+  namespace __atomic_impl\n+  {\n+    // Remove volatile and create a non-deduced context for value arguments.\n+    template<typename _Tp>\n+      using _Val = remove_volatile_t<_Tp>;\n+\n+    // As above, but for difference_type arguments.\n+    template<typename _Tp>\n+      using _Diff = conditional_t<is_pointer_v<_Tp>, ptrdiff_t, _Val<_Tp>>;\n+\n+    template<size_t _Size, size_t _Align>\n+      _GLIBCXX_ALWAYS_INLINE bool\n+      is_lock_free() noexcept\n+      {\n+\t// Produce a fake, minimally aligned pointer.\n+\treturn __atomic_is_lock_free(_Size, reinterpret_cast<void *>(-_Align));\n+      }\n+\n+    template<typename _Tp>\n+      _GLIBCXX_ALWAYS_INLINE void\n+      store(_Tp* __ptr, _Val<_Tp> __t, memory_order __m) noexcept\n+      { __atomic_store(__ptr, std::__addressof(__t), int(__m)); }\n+\n+    template<typename _Tp>\n+      _GLIBCXX_ALWAYS_INLINE _Tp\n+      load(_Tp* __ptr, memory_order __m) noexcept\n+      {\n+\talignas(_Tp) unsigned char __buf[sizeof(_Tp)];\n+\t_Tp* __dest = reinterpret_cast<_Tp*>(__buf);\n+\t__atomic_load(__ptr, __dest, int(__m));\n+\treturn *__dest;\n+      }\n+\n+    template<typename _Tp>\n+      _GLIBCXX_ALWAYS_INLINE _Tp\n+      exchange(_Tp* __ptr, _Val<_Tp> __desired, memory_order __m) noexcept\n+      {\n+        alignas(_Tp) unsigned char __buf[sizeof(_Tp)];\n+\t_Tp* __dest = reinterpret_cast<_Tp*>(__buf);\n+\t__atomic_exchange(__ptr, std::__addressof(__desired), __dest, int(__m));\n+\treturn *__dest;\n+      }\n+\n+    template<typename _Tp>\n+      _GLIBCXX_ALWAYS_INLINE bool\n+      compare_exchange_weak(_Tp* __ptr, _Val<_Tp>& __expected,\n+\t\t\t    _Val<_Tp> __desired, memory_order __success,\n+\t\t\t    memory_order __failure) noexcept\n+      {\n+\treturn __atomic_compare_exchange(__ptr, std::__addressof(__expected),\n+\t\t\t\t\t std::__addressof(__desired), true,\n+\t\t\t\t\t int(__success), int(__failure));\n+      }\n+\n+    template<typename _Tp>\n+      _GLIBCXX_ALWAYS_INLINE bool\n+      compare_exchange_strong(_Tp* __ptr, _Val<_Tp>& __expected,\n+\t\t\t      _Val<_Tp> __desired, memory_order __success,\n+\t\t\t      memory_order __failure) noexcept\n+      {\n+\treturn __atomic_compare_exchange(__ptr, std::__addressof(__expected),\n+\t\t\t\t\t std::__addressof(__desired), false,\n+\t\t\t\t\t int(__success), int(__failure));\n+      }\n+\n+    template<typename _Tp>\n+      _GLIBCXX_ALWAYS_INLINE _Tp\n+      fetch_add(_Tp* __ptr, _Diff<_Tp> __i, memory_order __m) noexcept\n+      { return __atomic_fetch_add(__ptr, __i, int(__m)); }\n+\n+    template<typename _Tp>\n+      _GLIBCXX_ALWAYS_INLINE _Tp\n+      fetch_sub(_Tp* __ptr, _Diff<_Tp> __i, memory_order __m) noexcept\n+      { return __atomic_fetch_sub(__ptr, __i, int(__m)); }\n+\n+    template<typename _Tp>\n+      _GLIBCXX_ALWAYS_INLINE _Tp\n+      fetch_and(_Tp* __ptr, _Val<_Tp> __i, memory_order __m) noexcept\n+      { return __atomic_fetch_and(__ptr, __i, int(__m)); }\n+\n+    template<typename _Tp>\n+      _GLIBCXX_ALWAYS_INLINE _Tp\n+      fetch_or(_Tp* __ptr, _Val<_Tp> __i, memory_order __m) noexcept\n+      { return __atomic_fetch_or(__ptr, __i, int(__m)); }\n+\n+    template<typename _Tp>\n+      _GLIBCXX_ALWAYS_INLINE _Tp\n+      fetch_xor(_Tp* __ptr, _Val<_Tp> __i, memory_order __m) noexcept\n+      { return __atomic_fetch_xor(__ptr, __i, int(__m)); }\n+\n+    template<typename _Tp>\n+      _GLIBCXX_ALWAYS_INLINE _Tp\n+      __add_fetch(_Tp* __ptr, _Diff<_Tp> __i) noexcept\n+      { return __atomic_add_fetch(__ptr, __i, __ATOMIC_SEQ_CST); }\n+\n+    template<typename _Tp>\n+      _GLIBCXX_ALWAYS_INLINE _Tp\n+      __sub_fetch(_Tp* __ptr, _Diff<_Tp> __i) noexcept\n+      { return __atomic_sub_fetch(__ptr, __i, __ATOMIC_SEQ_CST); }\n+\n+    template<typename _Tp>\n+      _GLIBCXX_ALWAYS_INLINE _Tp\n+      __and_fetch(_Tp* __ptr, _Val<_Tp> __i) noexcept\n+      { return __atomic_and_fetch(__ptr, __i, __ATOMIC_SEQ_CST); }\n+\n+    template<typename _Tp>\n+      _GLIBCXX_ALWAYS_INLINE _Tp\n+      __or_fetch(_Tp* __ptr, _Val<_Tp> __i) noexcept\n+      { return __atomic_or_fetch(__ptr, __i, __ATOMIC_SEQ_CST); }\n+\n+    template<typename _Tp>\n+      _GLIBCXX_ALWAYS_INLINE _Tp\n+      __xor_fetch(_Tp* __ptr, _Val<_Tp> __i) noexcept\n+      { return __atomic_xor_fetch(__ptr, __i, __ATOMIC_SEQ_CST); }\n+\n+    template<typename _Tp>\n+      _Tp\n+      __fetch_add_flt(_Tp* __ptr, _Val<_Tp> __i, memory_order __m) noexcept\n+      {\n+\t_Val<_Tp> __oldval = load(__ptr, memory_order_relaxed);\n+\t_Val<_Tp> __newval = __oldval + __i;\n+\twhile (!compare_exchange_weak(__ptr, __oldval, __newval, __m,\n+\t\t\t\t      memory_order_relaxed))\n+\t  __newval = __oldval + __i;\n+\treturn __oldval;\n+      }\n+\n+    template<typename _Tp>\n+      _Tp\n+      __fetch_sub_flt(_Tp* __ptr, _Val<_Tp> __i, memory_order __m) noexcept\n+      {\n+\t_Val<_Tp> __oldval = load(__ptr, memory_order_relaxed);\n+\t_Val<_Tp> __newval = __oldval - __i;\n+\twhile (!compare_exchange_weak(__ptr, __oldval, __newval, __m,\n+\t\t\t\t      memory_order_relaxed))\n+\t  __newval = __oldval - __i;\n+\treturn __oldval;\n+      }\n+\n+    template<typename _Tp>\n+      _Tp\n+      __add_fetch_flt(_Tp* __ptr, _Val<_Tp> __i) noexcept\n+      {\n+\t_Val<_Tp> __oldval = load(__ptr, memory_order_relaxed);\n+\t_Val<_Tp> __newval = __oldval + __i;\n+\twhile (!compare_exchange_weak(__ptr, __oldval, __newval,\n+\t\t\t\t      memory_order_seq_cst,\n+\t\t\t\t      memory_order_relaxed))\n+\t  __newval = __oldval + __i;\n+\treturn __newval;\n+      }\n+\n+    template<typename _Tp>\n+      _Tp\n+      __sub_fetch_flt(_Tp* __ptr, _Val<_Tp> __i) noexcept\n+      {\n+\t_Val<_Tp> __oldval = load(__ptr, memory_order_relaxed);\n+\t_Val<_Tp> __newval = __oldval - __i;\n+\twhile (!compare_exchange_weak(__ptr, __oldval, __newval,\n+\t\t\t\t      memory_order_seq_cst,\n+\t\t\t\t      memory_order_relaxed))\n+\t  __newval = __oldval - __i;\n+\treturn __newval;\n+      }\n+  } // namespace __atomic_impl\n+\n+  // base class for atomic<floating-point-type>\n+  template<typename _Fp>\n+    struct __atomic_float\n+    {\n+      static_assert(is_floating_point_v<_Fp>);\n+\n+      static constexpr size_t _S_alignment = __alignof__(_Fp);\n+\n+    public:\n+      using value_type = _Fp;\n+      using difference_type = value_type;\n+\n+      static constexpr bool is_always_lock_free\n+\t= __atomic_always_lock_free(sizeof(_Fp), 0);\n+\n+      __atomic_float() = default;\n+\n+      constexpr\n+      __atomic_float(_Fp __t) : _M_fp(__t)\n+      { }\n+\n+      __atomic_float(const __atomic_float&) = delete;\n+      __atomic_float& operator=(const __atomic_float&) = delete;\n+      __atomic_float& operator=(const __atomic_float&) volatile = delete;\n+\n+      _Fp\n+      operator=(_Fp __t) volatile noexcept\n+      {\n+\tthis->store(__t);\n+\treturn __t;\n+      }\n+\n+      _Fp\n+      operator=(_Fp __t) noexcept\n+      {\n+\tthis->store(__t);\n+\treturn __t;\n+      }\n+\n+      bool\n+      is_lock_free() const volatile noexcept\n+      { return __atomic_impl::is_lock_free<sizeof(_Fp), _S_alignment>(); }\n+\n+      bool\n+      is_lock_free() const noexcept\n+      { return __atomic_impl::is_lock_free<sizeof(_Fp), _S_alignment>(); }\n+\n+      void\n+      store(_Fp __t, memory_order __m = memory_order_seq_cst) volatile noexcept\n+      { __atomic_impl::store(&_M_fp, __t, __m); }\n+\n+      void\n+      store(_Fp __t, memory_order __m = memory_order_seq_cst) noexcept\n+      { __atomic_impl::store(&_M_fp, __t, __m); }\n+\n+      _Fp\n+      load(memory_order __m = memory_order_seq_cst) const volatile noexcept\n+      { return __atomic_impl::load(&_M_fp, __m); }\n+\n+      _Fp\n+      load(memory_order __m = memory_order_seq_cst) const noexcept\n+      { return __atomic_impl::load(&_M_fp, __m); }\n+\n+      operator _Fp() const volatile noexcept { return this->load(); }\n+      operator _Fp() const noexcept { return this->load(); }\n+\n+      _Fp\n+      exchange(_Fp __desired,\n+\t       memory_order __m = memory_order_seq_cst) volatile noexcept\n+      { return __atomic_impl::exchange(&_M_fp, __desired, __m); }\n+\n+      _Fp\n+      exchange(_Fp __desired,\n+\t       memory_order __m = memory_order_seq_cst) noexcept\n+      { return __atomic_impl::exchange(&_M_fp, __desired, __m); }\n+\n+      bool\n+      compare_exchange_weak(_Fp& __expected, _Fp __desired,\n+\t\t\t    memory_order __success,\n+\t\t\t    memory_order __failure) noexcept\n+      {\n+\treturn __atomic_impl::compare_exchange_weak(&_M_fp,\n+\t\t\t\t\t\t    __expected, __desired,\n+\t\t\t\t\t\t    __success, __failure);\n+      }\n+\n+      bool\n+      compare_exchange_weak(_Fp& __expected, _Fp __desired,\n+\t\t\t    memory_order __success,\n+\t\t\t    memory_order __failure) volatile noexcept\n+      {\n+\treturn __atomic_impl::compare_exchange_weak(&_M_fp,\n+\t\t\t\t\t\t    __expected, __desired,\n+\t\t\t\t\t\t    __success, __failure);\n+      }\n+\n+      bool\n+      compare_exchange_strong(_Fp& __expected, _Fp __desired,\n+\t\t\t      memory_order __success,\n+\t\t\t      memory_order __failure) noexcept\n+      {\n+\treturn __atomic_impl::compare_exchange_strong(&_M_fp,\n+\t\t\t\t\t\t      __expected, __desired,\n+\t\t\t\t\t\t      __success, __failure);\n+      }\n+\n+      bool\n+      compare_exchange_strong(_Fp& __expected, _Fp __desired,\n+\t\t\t      memory_order __success,\n+\t\t\t      memory_order __failure) volatile noexcept\n+      {\n+\treturn __atomic_impl::compare_exchange_strong(&_M_fp,\n+\t\t\t\t\t\t      __expected, __desired,\n+\t\t\t\t\t\t      __success, __failure);\n+      }\n+\n+      bool\n+      compare_exchange_weak(_Fp& __expected, _Fp __desired,\n+\t\t\t    memory_order __order = memory_order_seq_cst)\n+      noexcept\n+      {\n+\treturn compare_exchange_weak(__expected, __desired, __order,\n+                                     __cmpexch_failure_order(__order));\n+      }\n+\n+      bool\n+      compare_exchange_weak(_Fp& __expected, _Fp __desired,\n+\t\t\t    memory_order __order = memory_order_seq_cst)\n+      volatile noexcept\n+      {\n+\treturn compare_exchange_weak(__expected, __desired, __order,\n+                                     __cmpexch_failure_order(__order));\n+      }\n+\n+      bool\n+      compare_exchange_strong(_Fp& __expected, _Fp __desired,\n+\t\t\t      memory_order __order = memory_order_seq_cst)\n+      noexcept\n+      {\n+\treturn compare_exchange_strong(__expected, __desired, __order,\n+\t\t\t\t       __cmpexch_failure_order(__order));\n+      }\n+\n+      bool\n+      compare_exchange_strong(_Fp& __expected, _Fp __desired,\n+\t\t\t      memory_order __order = memory_order_seq_cst)\n+      volatile noexcept\n+      {\n+\treturn compare_exchange_strong(__expected, __desired, __order,\n+\t\t\t\t       __cmpexch_failure_order(__order));\n+      }\n+\n+      value_type\n+      fetch_add(value_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) noexcept\n+      { return __atomic_impl::__fetch_add_flt(&_M_fp, __i, __m); }\n+\n+      value_type\n+      fetch_add(value_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n+      { return __atomic_impl::__fetch_add_flt(&_M_fp, __i, __m); }\n+\n+      value_type\n+      fetch_sub(value_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) noexcept\n+      { return __atomic_impl::__fetch_sub_flt(&_M_fp, __i, __m); }\n+\n+      value_type\n+      fetch_sub(value_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n+      { return __atomic_impl::__fetch_sub_flt(&_M_fp, __i, __m); }\n+\n+      value_type\n+      operator+=(value_type __i) noexcept\n+      { return __atomic_impl::__add_fetch_flt(&_M_fp, __i); }\n+\n+      value_type\n+      operator+=(value_type __i) volatile noexcept\n+      { return __atomic_impl::__add_fetch_flt(&_M_fp, __i); }\n+\n+      value_type\n+      operator-=(value_type __i) noexcept\n+      { return __atomic_impl::__sub_fetch_flt(&_M_fp, __i); }\n+\n+      value_type\n+      operator-=(value_type __i) volatile noexcept\n+      { return __atomic_impl::__sub_fetch_flt(&_M_fp, __i); }\n+\n+    private:\n+      alignas(_S_alignment) _Fp _M_fp;\n+    };\n+\n+  template<typename _Tp,\n+\t   bool = is_integral_v<_Tp>, bool = is_floating_point_v<_Tp>>\n+    struct __atomic_ref;\n+\n+  // base class for non-integral, non-floating-point, non-pointer types\n+  template<typename _Tp>\n+    struct __atomic_ref<_Tp, false, false>\n+    {\n+      static_assert(is_trivially_copyable_v<_Tp>);\n+\n+      // 1/2/4/8/16-byte types must be aligned to at least their size.\n+      static constexpr int _S_min_alignment\n+\t= (sizeof(_Tp) & (sizeof(_Tp) - 1)) || sizeof(_Tp) > 16\n+\t? 0 : sizeof(_Tp);\n+\n+    public:\n+      using value_type = _Tp;\n+\n+      static constexpr bool is_always_lock_free\n+\t= __atomic_always_lock_free(sizeof(_Tp), 0);\n+\n+      static constexpr size_t required_alignment\n+\t= _S_min_alignment > alignof(_Tp) ? _S_min_alignment : alignof(_Tp);\n+\n+      __atomic_ref& operator=(const __atomic_ref&) = delete;\n+\n+      explicit\n+      __atomic_ref(_Tp& __t) : _M_ptr(std::__addressof(__t))\n+      { __glibcxx_assert(((uintptr_t)_M_ptr % required_alignment) == 0); }\n+\n+      __atomic_ref(const __atomic_ref&) noexcept = default;\n+\n+      _Tp\n+      operator=(_Tp __t) const noexcept\n+      {\n+\tthis->store(__t);\n+\treturn __t;\n+      }\n+\n+      operator _Tp() const noexcept { return this->load(); }\n+\n+      bool\n+      is_lock_free() const noexcept\n+      { return __atomic_impl::is_lock_free<sizeof(_Tp), required_alignment>(); }\n+\n+      void\n+      store(_Tp __t, memory_order __m = memory_order_seq_cst) const noexcept\n+      { __atomic_impl::store(_M_ptr, __t, __m); }\n+\n+      _Tp\n+      load(memory_order __m = memory_order_seq_cst) const noexcept\n+      { return __atomic_impl::load(_M_ptr, __m); }\n+\n+      _Tp\n+      exchange(_Tp __desired, memory_order __m = memory_order_seq_cst)\n+      const noexcept\n+      { return __atomic_impl::exchange(_M_ptr, __desired, __m); }\n+\n+      bool\n+      compare_exchange_weak(_Tp& __expected, _Tp __desired,\n+\t\t\t    memory_order __success,\n+\t\t\t    memory_order __failure) const noexcept\n+      {\n+\treturn __atomic_impl::compare_exchange_weak(_M_ptr,\n+\t\t\t\t\t\t    __expected, __desired,\n+\t\t\t\t\t\t    __success, __failure);\n+      }\n+\n+      bool\n+      compare_exchange_strong(_Tp& __expected, _Tp __desired,\n+\t\t\t    memory_order __success,\n+\t\t\t    memory_order __failure) const noexcept\n+      {\n+\treturn __atomic_impl::compare_exchange_strong(_M_ptr,\n+\t\t\t\t\t\t      __expected, __desired,\n+\t\t\t\t\t\t      __success, __failure);\n+      }\n+\n+      bool\n+      compare_exchange_weak(_Tp& __expected, _Tp __desired,\n+\t\t\t    memory_order __order = memory_order_seq_cst)\n+      const noexcept\n+      {\n+\treturn compare_exchange_weak(__expected, __desired, __order,\n+                                     __cmpexch_failure_order(__order));\n+      }\n+\n+      bool\n+      compare_exchange_strong(_Tp& __expected, _Tp __desired,\n+\t\t\t      memory_order __order = memory_order_seq_cst)\n+      const noexcept\n+      {\n+\treturn compare_exchange_strong(__expected, __desired, __order,\n+\t\t\t\t       __cmpexch_failure_order(__order));\n+      }\n+\n+    private:\n+      _Tp* _M_ptr;\n+    };\n+\n+  // base class for atomic_ref<integral-type>\n+  template<typename _Tp>\n+    struct __atomic_ref<_Tp, true, false>\n+    {\n+      static_assert(is_integral_v<_Tp>);\n+\n+    public:\n+      using value_type = _Tp;\n+      using difference_type = value_type;\n+\n+      static constexpr bool is_always_lock_free\n+\t= __atomic_always_lock_free(sizeof(_Tp), 0);\n+\n+      static constexpr size_t required_alignment\n+\t= sizeof(_Tp) > alignof(_Tp) ? sizeof(_Tp) : alignof(_Tp);\n+\n+      __atomic_ref() = delete;\n+      __atomic_ref& operator=(const __atomic_ref&) = delete;\n+\n+      explicit\n+      __atomic_ref(_Tp& __t) : _M_ptr(&__t)\n+      { __glibcxx_assert(((uintptr_t)_M_ptr % required_alignment) == 0); }\n+\n+      __atomic_ref(const __atomic_ref&) noexcept = default;\n+\n+      _Tp\n+      operator=(_Tp __t) const noexcept\n+      {\n+\tthis->store(__t);\n+\treturn __t;\n+      }\n+\n+      operator _Tp() const noexcept { return this->load(); }\n+\n+      bool\n+      is_lock_free() const noexcept\n+      {\n+\treturn __atomic_impl::is_lock_free<sizeof(_Tp), required_alignment>();\n+      }\n+\n+      void\n+      store(_Tp __t, memory_order __m = memory_order_seq_cst) const noexcept\n+      { __atomic_impl::store(_M_ptr, __t, __m); }\n+\n+      _Tp\n+      load(memory_order __m = memory_order_seq_cst) const noexcept\n+      { return __atomic_impl::load(_M_ptr, __m); }\n+\n+      _Tp\n+      exchange(_Tp __desired,\n+\t       memory_order __m = memory_order_seq_cst) const noexcept\n+      { return __atomic_impl::exchange(_M_ptr, __desired, __m); }\n+\n+      bool\n+      compare_exchange_weak(_Tp& __expected, _Tp __desired,\n+\t\t\t    memory_order __success,\n+\t\t\t    memory_order __failure) const noexcept\n+      {\n+\treturn __atomic_impl::compare_exchange_weak(_M_ptr,\n+\t\t\t\t\t\t    __expected, __desired,\n+\t\t\t\t\t\t    __success, __failure);\n+      }\n+\n+      bool\n+      compare_exchange_strong(_Tp& __expected, _Tp __desired,\n+\t\t\t      memory_order __success,\n+\t\t\t      memory_order __failure) const noexcept\n+      {\n+\treturn __atomic_impl::compare_exchange_strong(_M_ptr,\n+\t\t\t\t\t\t      __expected, __desired,\n+\t\t\t\t\t\t      __success, __failure);\n+      }\n+\n+      bool\n+      compare_exchange_weak(_Tp& __expected, _Tp __desired,\n+\t\t\t    memory_order __order = memory_order_seq_cst)\n+      const noexcept\n+      {\n+\treturn compare_exchange_weak(__expected, __desired, __order,\n+                                     __cmpexch_failure_order(__order));\n+      }\n+\n+      bool\n+      compare_exchange_strong(_Tp& __expected, _Tp __desired,\n+\t\t\t      memory_order __order = memory_order_seq_cst)\n+      const noexcept\n+      {\n+\treturn compare_exchange_strong(__expected, __desired, __order,\n+\t\t\t\t       __cmpexch_failure_order(__order));\n+      }\n+\n+      value_type\n+      fetch_add(value_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) const noexcept\n+      { return __atomic_impl::fetch_add(_M_ptr, __i, __m); }\n+\n+      value_type\n+      fetch_sub(value_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) const noexcept\n+      { return __atomic_impl::fetch_sub(_M_ptr, __i, __m); }\n+\n+      value_type\n+      fetch_and(value_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) const noexcept\n+      { return __atomic_impl::fetch_and(_M_ptr, __i, __m); }\n+\n+      value_type\n+      fetch_or(value_type __i,\n+\t       memory_order __m = memory_order_seq_cst) const noexcept\n+      { return __atomic_impl::fetch_or(_M_ptr, __i, __m); }\n+\n+      value_type\n+      fetch_xor(value_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) const noexcept\n+      { return __atomic_impl::fetch_xor(_M_ptr, __i, __m); }\n+\n+      _GLIBCXX_ALWAYS_INLINE value_type\n+      operator++(int) const noexcept\n+      { return fetch_add(1); }\n+\n+      _GLIBCXX_ALWAYS_INLINE value_type\n+      operator--(int) const noexcept\n+      { return fetch_sub(1); }\n+\n+      value_type\n+      operator++() const noexcept\n+      { return __atomic_impl::__add_fetch(_M_ptr, value_type(1)); }\n+\n+      value_type\n+      operator--() const noexcept\n+      { return __atomic_impl::__sub_fetch(_M_ptr, value_type(1)); }\n+\n+      value_type\n+      operator+=(value_type __i) const noexcept\n+      { return __atomic_impl::__add_fetch(_M_ptr, __i); }\n+\n+      value_type\n+      operator-=(value_type __i) const noexcept\n+      { return __atomic_impl::__sub_fetch(_M_ptr, __i); }\n+\n+      value_type\n+      operator&=(value_type __i) const noexcept\n+      { return __atomic_impl::__and_fetch(_M_ptr, __i); }\n+\n+      value_type\n+      operator|=(value_type __i) const noexcept\n+      { return __atomic_impl::__or_fetch(_M_ptr, __i); }\n+\n+      value_type\n+      operator^=(value_type __i) const noexcept\n+      { return __atomic_impl::__xor_fetch(_M_ptr, __i); }\n+\n+    private:\n+      _Tp* _M_ptr;\n+    };\n+\n+  // base class for atomic_ref<floating-point-type>\n+  template<typename _Fp>\n+    struct __atomic_ref<_Fp, false, true>\n+    {\n+      static_assert(is_floating_point_v<_Fp>);\n+\n+    public:\n+      using value_type = _Fp;\n+      using difference_type = value_type;\n+\n+      static constexpr bool is_always_lock_free\n+\t= __atomic_always_lock_free(sizeof(_Fp), 0);\n+\n+      static constexpr size_t required_alignment = __alignof__(_Fp);\n+\n+      __atomic_ref() = delete;\n+      __atomic_ref& operator=(const __atomic_ref&) = delete;\n+\n+      explicit\n+      __atomic_ref(_Fp& __t) : _M_ptr(&__t)\n+      { __glibcxx_assert(((uintptr_t)_M_ptr % required_alignment) == 0); }\n+\n+      __atomic_ref(const __atomic_ref&) noexcept = default;\n+\n+      _Fp\n+      operator=(_Fp __t) const noexcept\n+      {\n+\tthis->store(__t);\n+\treturn __t;\n+      }\n+\n+      operator _Fp() const noexcept { return this->load(); }\n+\n+      bool\n+      is_lock_free() const noexcept\n+      {\n+\treturn __atomic_impl::is_lock_free<sizeof(_Fp), required_alignment>();\n+      }\n+\n+      void\n+      store(_Fp __t, memory_order __m = memory_order_seq_cst) const noexcept\n+      { __atomic_impl::store(_M_ptr, __t, __m); }\n+\n+      _Fp\n+      load(memory_order __m = memory_order_seq_cst) const noexcept\n+      { return __atomic_impl::load(_M_ptr, __m); }\n+\n+      _Fp\n+      exchange(_Fp __desired,\n+\t       memory_order __m = memory_order_seq_cst) const noexcept\n+      { return __atomic_impl::exchange(_M_ptr, __desired, __m); }\n+\n+      bool\n+      compare_exchange_weak(_Fp& __expected, _Fp __desired,\n+\t\t\t    memory_order __success,\n+\t\t\t    memory_order __failure) const noexcept\n+      {\n+\treturn __atomic_impl::compare_exchange_weak(_M_ptr,\n+\t\t\t\t\t\t    __expected, __desired,\n+\t\t\t\t\t\t    __success, __failure);\n+      }\n+\n+      bool\n+      compare_exchange_strong(_Fp& __expected, _Fp __desired,\n+\t\t\t    memory_order __success,\n+\t\t\t    memory_order __failure) const noexcept\n+      {\n+\treturn __atomic_impl::compare_exchange_strong(_M_ptr,\n+\t\t\t\t\t\t      __expected, __desired,\n+\t\t\t\t\t\t      __success, __failure);\n+      }\n+\n+      bool\n+      compare_exchange_weak(_Fp& __expected, _Fp __desired,\n+\t\t\t    memory_order __order = memory_order_seq_cst)\n+      const noexcept\n+      {\n+\treturn compare_exchange_weak(__expected, __desired, __order,\n+                                     __cmpexch_failure_order(__order));\n+      }\n+\n+      bool\n+      compare_exchange_strong(_Fp& __expected, _Fp __desired,\n+\t\t\t      memory_order __order = memory_order_seq_cst)\n+      const noexcept\n+      {\n+\treturn compare_exchange_strong(__expected, __desired, __order,\n+\t\t\t\t       __cmpexch_failure_order(__order));\n+      }\n+\n+      value_type\n+      fetch_add(value_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) const noexcept\n+      { return __atomic_impl::__fetch_add_flt(_M_ptr, __i, __m); }\n+\n+      value_type\n+      fetch_sub(value_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) const noexcept\n+      { return __atomic_impl::__fetch_sub_flt(_M_ptr, __i, __m); }\n+\n+      value_type\n+      operator+=(value_type __i) const noexcept\n+      { return __atomic_impl::__add_fetch_flt(_M_ptr, __i); }\n+\n+      value_type\n+      operator-=(value_type __i) const noexcept\n+      { return __atomic_impl::__sub_fetch_flt(_M_ptr, __i); }\n+\n+    private:\n+      _Fp* _M_ptr;\n+    };\n+\n+  // base class for atomic_ref<pointer-type>\n+  template<typename _Tp>\n+    struct __atomic_ref<_Tp*, false, false>\n+    {\n+    public:\n+      using value_type = _Tp*;\n+      using difference_type = ptrdiff_t;\n+\n+      static constexpr bool is_always_lock_free = ATOMIC_POINTER_LOCK_FREE == 2;\n+\n+      static constexpr size_t required_alignment = __alignof__(_Tp*);\n+\n+      __atomic_ref() = delete;\n+      __atomic_ref& operator=(const __atomic_ref&) = delete;\n+\n+      explicit\n+      __atomic_ref(_Tp*& __t) : _M_ptr(std::__addressof(__t))\n+      { __glibcxx_assert(((uintptr_t)_M_ptr % required_alignment) == 0); }\n+\n+      __atomic_ref(const __atomic_ref&) noexcept = default;\n+\n+      _Tp*\n+      operator=(_Tp* __t) const noexcept\n+      {\n+\tthis->store(__t);\n+\treturn __t;\n+      }\n+\n+      operator _Tp*() const noexcept { return this->load(); }\n+\n+      bool\n+      is_lock_free() const noexcept\n+      {\n+\treturn __atomic_impl::is_lock_free<sizeof(_Tp*), required_alignment>();\n+      }\n+\n+      void\n+      store(_Tp* __t, memory_order __m = memory_order_seq_cst) const noexcept\n+      { __atomic_impl::store(_M_ptr, __t, __m); }\n+\n+      _Tp*\n+      load(memory_order __m = memory_order_seq_cst) const noexcept\n+      { return __atomic_impl::load(_M_ptr, __m); }\n+\n+      _Tp*\n+      exchange(_Tp* __desired,\n+\t       memory_order __m = memory_order_seq_cst) const noexcept\n+      { return __atomic_impl::exchange(_M_ptr, __desired, __m); }\n+\n+      bool\n+      compare_exchange_weak(_Tp*& __expected, _Tp* __desired,\n+\t\t\t    memory_order __success,\n+\t\t\t    memory_order __failure) const noexcept\n+      {\n+\treturn __atomic_impl::compare_exchange_weak(_M_ptr,\n+\t\t\t\t\t\t    __expected, __desired,\n+\t\t\t\t\t\t    __success, __failure);\n+      }\n+\n+      bool\n+      compare_exchange_strong(_Tp*& __expected, _Tp* __desired,\n+\t\t\t    memory_order __success,\n+\t\t\t    memory_order __failure) const noexcept\n+      {\n+\treturn __atomic_impl::compare_exchange_strong(_M_ptr,\n+\t\t\t\t\t\t      __expected, __desired,\n+\t\t\t\t\t\t      __success, __failure);\n+      }\n+\n+      bool\n+      compare_exchange_weak(_Tp*& __expected, _Tp* __desired,\n+\t\t\t    memory_order __order = memory_order_seq_cst)\n+      const noexcept\n+      {\n+\treturn compare_exchange_weak(__expected, __desired, __order,\n+                                     __cmpexch_failure_order(__order));\n+      }\n+\n+      bool\n+      compare_exchange_strong(_Tp*& __expected, _Tp* __desired,\n+\t\t\t      memory_order __order = memory_order_seq_cst)\n+      const noexcept\n+      {\n+\treturn compare_exchange_strong(__expected, __desired, __order,\n+\t\t\t\t       __cmpexch_failure_order(__order));\n+      }\n+\n+      _GLIBCXX_ALWAYS_INLINE value_type\n+      fetch_add(difference_type __d,\n+\t\tmemory_order __m = memory_order_seq_cst) const noexcept\n+      { return __atomic_impl::fetch_add(_M_ptr, _S_type_size(__d), __m); }\n+\n+      _GLIBCXX_ALWAYS_INLINE value_type\n+      fetch_sub(difference_type __d,\n+\t\tmemory_order __m = memory_order_seq_cst) const noexcept\n+      { return __atomic_impl::fetch_sub(_M_ptr, _S_type_size(__d), __m); }\n+\n+      value_type\n+      operator++(int) const noexcept\n+      { return fetch_add(1); }\n+\n+      value_type\n+      operator--(int) const noexcept\n+      { return fetch_sub(1); }\n+\n+      value_type\n+      operator++() const noexcept\n+      {\n+\treturn __atomic_impl::__add_fetch(_M_ptr, _S_type_size(1));\n+      }\n+\n+      value_type\n+      operator--() const noexcept\n+      {\n+\treturn __atomic_impl::__sub_fetch(_M_ptr, _S_type_size(1));\n+      }\n+\n+      value_type\n+      operator+=(difference_type __d) const noexcept\n+      {\n+\treturn __atomic_impl::__add_fetch(_M_ptr, _S_type_size(__d));\n+      }\n+\n+      value_type\n+      operator-=(difference_type __d) const noexcept\n+      {\n+\treturn __atomic_impl::__sub_fetch(_M_ptr, _S_type_size(__d));\n+      }\n+\n+    private:\n+      static constexpr ptrdiff_t\n+      _S_type_size(ptrdiff_t __d) noexcept\n+      {\n+\tstatic_assert(is_object_v<_Tp>);\n+\treturn __d * sizeof(_Tp);\n+      }\n+\n+      _Tp** _M_ptr;\n+    };\n+\n+#endif // C++2a\n+\n   // @} group atomics\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "26d8d3946da34b0b5c51f7554f19d6e54e9e7565", "filename": "libstdc++-v3/include/std/atomic", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic?ref=a90fe12c80a13ffed9d5c775703788275d8b7c42", "patch": "@@ -39,7 +39,6 @@\n #else\n \n #include <bits/atomic_base.h>\n-#include <bits/move.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -1472,6 +1471,71 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t     __atomic_val_t<_ITp> __i) noexcept\n     { return atomic_fetch_xor_explicit(__a, __i, memory_order_seq_cst); }\n \n+#if __cplusplus > 201703L\n+  template<>\n+    struct atomic<float> : __atomic_float<float>\n+    {\n+      atomic() noexcept = default;\n+\n+      constexpr\n+      atomic(float __fp) noexcept : __atomic_float<float>(__fp)\n+      { }\n+\n+      atomic& operator=(const atomic&) volatile = delete;\n+      atomic& operator=(const atomic&) = delete;\n+\n+      using __atomic_float<float>::operator=;\n+    };\n+\n+  template<>\n+    struct atomic<double> : __atomic_float<double>\n+    {\n+      atomic() noexcept = default;\n+\n+      constexpr\n+      atomic(double __fp) noexcept : __atomic_float<double>(__fp)\n+      { }\n+\n+      atomic& operator=(const atomic&) volatile = delete;\n+      atomic& operator=(const atomic&) = delete;\n+\n+      using __atomic_float<double>::operator=;\n+    };\n+\n+  template<>\n+    struct atomic<long double> : __atomic_float<long double>\n+    {\n+      atomic() noexcept = default;\n+\n+      constexpr\n+      atomic(long double __fp) noexcept : __atomic_float<long double>(__fp)\n+      { }\n+\n+      atomic& operator=(const atomic&) volatile = delete;\n+      atomic& operator=(const atomic&) = delete;\n+\n+      using __atomic_float<long double>::operator=;\n+    };\n+\n+#define __cpp_lib_atomic_ref 201806L\n+\n+  /// Class template to provide atomic operations on a non-atomic variable.\n+  template<typename _Tp>\n+    struct atomic_ref : __atomic_ref<_Tp>\n+    {\n+      explicit\n+      atomic_ref(_Tp& __t) noexcept : __atomic_ref<_Tp>(__t)\n+      { }\n+\n+      atomic_ref& operator=(const atomic_ref&) = delete;\n+\n+      atomic_ref(const atomic_ref&) = default;\n+\n+      using __atomic_ref<_Tp>::operator=;\n+    };\n+\n+#endif // C++2a\n+\n   // @} group atomics\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "d134f7fde01d9261177c7be39790013b37e192c3", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=a90fe12c80a13ffed9d5c775703788275d8b7c42", "patch": "@@ -150,6 +150,7 @@\n \n #if __cplusplus > 201703L\n // c++2a\n+#define __cpp_lib_atomic_ref 201806L\n #define __cpp_lib_bind_front 201902L\n #define __cpp_lib_bounded_array_traits 201902L\n #if __cpp_impl_destroying_delete"}, {"sha": "5065730dd91d7df87432124709ed67789e5c0ade", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/60695.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2F60695.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2F60695.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2F60695.cc?ref=a90fe12c80a13ffed9d5c775703788275d8b7c42", "patch": "@@ -27,4 +27,4 @@ struct X {\n   char stuff[0]; // GNU extension, type has zero size\n };\n \n-std::atomic<X> a;  // { dg-error \"not supported\" \"\" { target *-*-* } 194 }\n+std::atomic<X> a;  // { dg-error \"zero-sized types\" \"\" { target *-*-* } 0 }"}, {"sha": "bd0e353538d9667e0a94bd59362a7eef7d7204f6", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_float/1.cc", "status": "added", "additions": 573, "deletions": 0, "changes": 573, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_float%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_float%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_float%2F1.cc?ref=a90fe12c80a13ffed9d5c775703788275d8b7c42", "patch": "@@ -0,0 +1,573 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <atomic>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  const auto mo = std::memory_order_relaxed;\n+  bool ok;\n+  float expected;\n+\n+  if constexpr (std::atomic<float>::is_always_lock_free)\n+  {\n+    std::atomic<float> a0;\n+    std::atomic<float> a1(1.0f);\n+    ok = a0.is_lock_free();\n+    a0 = a1.load();\n+    VERIFY( a0.load() == a1.load() );\n+    VERIFY( a0.load(mo) == a0.load() );\n+    a0.store(0.5f);\n+    a1.store(0.5f, mo);\n+    VERIFY( a0.load() == a1.load() );\n+    auto f0 = a0.exchange(12.5f);\n+    auto f1 = a1.exchange(12.5f, mo);\n+    VERIFY( a0 == 12.5f );\n+    VERIFY( a0.load() == a1.load() );\n+    VERIFY( f0 == 0.5f );\n+    VERIFY( f0 == f1 );\n+\n+    expected = 12.5f;\n+    while (!a0.compare_exchange_weak(expected, 1.6f, mo, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a0.load() == 1.6f );\n+    VERIFY( expected == 12.5f );\n+    expected = 1.5f;\n+    ok = a1.compare_exchange_weak(expected, 1.6f, mo, mo);\n+    VERIFY( !ok && a1.load() == 12.5f && expected == 12.5f );\n+    VERIFY( expected == 12.5f );\n+    expected = 1.6f;\n+    ok = a0.compare_exchange_strong(expected, 3.2f, mo, mo);\n+    VERIFY( ok && a0.load() == 3.2f );\n+    VERIFY( expected == 1.6f );\n+    expected = 1.5f;\n+    ok = a1.compare_exchange_strong(expected, 3.2f, mo, mo);\n+    VERIFY( !ok && a1.load() == 12.5f && expected == 12.5f );\n+\n+    expected = 3.2f;\n+    while (!a0.compare_exchange_weak(expected, .64f))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a0.load() == .64f );\n+    expected = 12.5f;\n+    while (!a1.compare_exchange_weak(expected, 1.6f, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a1.load() == 1.6f );\n+    expected = 0.5f;\n+    ok = a0.compare_exchange_weak(expected, 3.2f);\n+    VERIFY( !ok && a0.load() == .64f && expected == .64f );\n+    expected = 0.5f;\n+    ok = a1.compare_exchange_weak(expected, 3.2f, mo);\n+    VERIFY( !ok && a1.load() == 1.6f && expected == 1.6f );\n+\n+    expected = .64f;\n+    ok = a0.compare_exchange_strong(expected, 12.8f);\n+    VERIFY( ok && a0.load() == 12.8f );\n+    expected = 1.6f;\n+    ok = a1.compare_exchange_strong(expected, 2.56f, mo);\n+    VERIFY( ok && a1.load() == 2.56f );\n+    expected = 0.5f;\n+    ok = a0.compare_exchange_strong(expected, 3.2f);\n+    VERIFY( !ok && a0.load() == 12.8f && expected == 12.8f );\n+    expected = 0.5f;\n+    ok = a1.compare_exchange_strong(expected, 3.2f, mo);\n+    VERIFY( !ok && a1.load() == 2.56f && expected == 2.56f );\n+\n+    f0 = a0.fetch_add(1.2f);\n+    VERIFY( f0 == 12.8f );\n+    VERIFY( a0 == 14.0f );\n+    f1 = a1.fetch_add(2.4f, mo);\n+    VERIFY( f1 == 2.56f );\n+    VERIFY( a1 == 4.96f );\n+\n+    f0 = a0.fetch_sub(1.2f);\n+    VERIFY( f0 == 14.0f );\n+    VERIFY( a0 == 12.8f );\n+    f1 = a1.fetch_sub(3.5f, mo);\n+    VERIFY( f1 == 4.96f );\n+    VERIFY( a1 == 1.46f );\n+\n+    f0 = a0 += 1.2f;\n+    VERIFY( f0 == 14.0f );\n+    VERIFY( a0 == 14.0f );\n+\n+    f0 = a0 -= 0.8f;\n+    VERIFY( f0 == 13.2f );\n+    VERIFY( a0 == 13.2f );\n+  }\n+\n+  // Repeat for volatile std::atomic<float>\n+  if constexpr (std::atomic<float>::is_always_lock_free)\n+  {\n+    volatile std::atomic<float> a0;\n+    volatile std::atomic<float> a1(1.0f);\n+    ok = a0.is_lock_free();\n+    a0 = a1.load();\n+    VERIFY( a0.load() == a1.load() );\n+    VERIFY( a0.load(mo) == a0.load() );\n+    a0.store(0.5f);\n+    a1.store(0.5f, mo);\n+    VERIFY( a0.load() == a1.load() );\n+    auto f0 = a0.exchange(12.5f);\n+    auto f1 = a1.exchange(12.5f, mo);\n+    VERIFY( a0 == 12.5f );\n+    VERIFY( a0.load() == a1.load() );\n+    VERIFY( f0 == 0.5f );\n+    VERIFY( f0 == f1 );\n+\n+    expected = 12.5f;\n+    while (!a0.compare_exchange_weak(expected, 1.6f, mo, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a0.load() == 1.6f );\n+    VERIFY( expected == 12.5f );\n+    expected = 1.5f;\n+    ok = a1.compare_exchange_weak(expected, 1.6f, mo, mo);\n+    VERIFY( !ok && a1.load() == 12.5f && expected == 12.5f );\n+    VERIFY( expected == 12.5f );\n+    expected = 1.6f;\n+    ok = a0.compare_exchange_strong(expected, 3.2f, mo, mo);\n+    VERIFY( ok && a0.load() == 3.2f );\n+    VERIFY( expected == 1.6f );\n+    expected = 1.5f;\n+    ok = a1.compare_exchange_strong(expected, 3.2f, mo, mo);\n+    VERIFY( !ok && a1.load() == 12.5f && expected == 12.5f );\n+\n+    expected = 3.2f;\n+    while (!a0.compare_exchange_weak(expected, .64f))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a0.load() == .64f );\n+    expected = 12.5f;\n+    while (!a1.compare_exchange_weak(expected, 1.6f, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a1.load() == 1.6f );\n+    expected = 0.5f;\n+    ok = a0.compare_exchange_weak(expected, 3.2f);\n+    VERIFY( !ok && a0.load() == .64f && expected == .64f );\n+    expected = 0.5f;\n+    ok = a1.compare_exchange_weak(expected, 3.2f, mo);\n+    VERIFY( !ok && a1.load() == 1.6f && expected == 1.6f );\n+\n+    expected = .64f;\n+    ok = a0.compare_exchange_strong(expected, 12.8f);\n+    VERIFY( ok && a0.load() == 12.8f );\n+    expected = 1.6f;\n+    ok = a1.compare_exchange_strong(expected, 2.56f, mo);\n+    VERIFY( ok && a1.load() == 2.56f );\n+    expected = 0.5f;\n+    ok = a0.compare_exchange_strong(expected, 3.2f);\n+    VERIFY( !ok && a0.load() == 12.8f && expected == 12.8f );\n+    expected = 0.5f;\n+    ok = a1.compare_exchange_strong(expected, 3.2f, mo);\n+    VERIFY( !ok && a1.load() == 2.56f && expected == 2.56f );\n+\n+    f0 = a0.fetch_add(1.2f);\n+    VERIFY( f0 == 12.8f );\n+    VERIFY( a0 == 14.0f );\n+    f1 = a1.fetch_add(2.4f, mo);\n+    VERIFY( f1 == 2.56f );\n+    VERIFY( a1 == 4.96f );\n+\n+    f0 = a0.fetch_sub(1.2f);\n+    VERIFY( f0 == 14.0f );\n+    VERIFY( a0 == 12.8f );\n+    f1 = a1.fetch_sub(3.5f, mo);\n+    VERIFY( f1 == 4.96f );\n+    VERIFY( a1 == 1.46f );\n+\n+    f0 = a0 += 1.2f;\n+    VERIFY( f0 == 14.0f );\n+    VERIFY( a0 == 14.0f );\n+\n+    f0 = a0 -= 0.8f;\n+    VERIFY( f0 == 13.2f );\n+    VERIFY( a0 == 13.2f );\n+  }\n+}\n+\n+void\n+test02()\n+{\n+  const auto mo = std::memory_order_relaxed;\n+  bool ok;\n+  double expected;\n+\n+  if constexpr (std::atomic<double>::is_always_lock_free)\n+  {\n+    std::atomic<double> a0;\n+    std::atomic<double> a1(1.0);\n+    ok = a0.is_lock_free();\n+    a0 = a1.load();\n+    VERIFY( a0.load() == a1.load() );\n+    VERIFY( a0.load(mo) == a0.load() );\n+    a0.store(0.5);\n+    a1.store(0.5, mo);\n+    VERIFY( a0.load() == a1.load() );\n+    auto f0 = a0.exchange(12.5);\n+    auto f1 = a1.exchange(12.5, mo);\n+    VERIFY( a0 == 12.5 );\n+    VERIFY( a0.load() == a1.load() );\n+    VERIFY( f0 == 0.5 );\n+    VERIFY( f0 == f1 );\n+\n+    expected = 12.5;\n+    while (!a0.compare_exchange_weak(expected, 1.6, mo, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a0.load() == 1.6 );\n+    VERIFY( expected == 12.5 );\n+    expected = 1.5;\n+    ok = a1.compare_exchange_weak(expected, 1.6, mo, mo);\n+    VERIFY( !ok && a1.load() == 12.5 && expected == 12.5 );\n+    VERIFY( expected == 12.5 );\n+    expected = 1.6;\n+    ok = a0.compare_exchange_strong(expected, 3.2, mo, mo);\n+    VERIFY( ok && a0.load() == 3.2 );\n+    VERIFY( expected == 1.6 );\n+    expected = 1.5;\n+    ok = a1.compare_exchange_strong(expected, 3.2, mo, mo);\n+    VERIFY( !ok && a1.load() == 12.5 && expected == 12.5 );\n+\n+    expected = 3.2;\n+    while (!a0.compare_exchange_weak(expected, .64))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a0.load() == .64 );\n+    expected = 12.5;\n+    while (!a1.compare_exchange_weak(expected, 1.6, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a1.load() == 1.6 );\n+    expected = 0.5;\n+    ok = a0.compare_exchange_weak(expected, 3.2);\n+    VERIFY( !ok && a0.load() == .64 && expected == .64 );\n+    expected = 0.5;\n+    ok = a1.compare_exchange_weak(expected, 3.2, mo);\n+    VERIFY( !ok && a1.load() == 1.6 && expected == 1.6 );\n+\n+    expected = .64;\n+    ok = a0.compare_exchange_strong(expected, 12.8);\n+    VERIFY( ok && a0.load() == 12.8 );\n+    expected = 1.6;\n+    ok = a1.compare_exchange_strong(expected, 2.56, mo);\n+    VERIFY( ok && a1.load() == 2.56 );\n+    expected = 0.5;\n+    ok = a0.compare_exchange_strong(expected, 3.2);\n+    VERIFY( !ok && a0.load() == 12.8 && expected == 12.8 );\n+    expected = 0.5;\n+    ok = a1.compare_exchange_strong(expected, 3.2, mo);\n+    VERIFY( !ok && a1.load() == 2.56 && expected == 2.56 );\n+\n+    f0 = a0.fetch_add(1.2);\n+    VERIFY( f0 == 12.8 );\n+    VERIFY( a0 == 14.0 );\n+    f1 = a1.fetch_add(2.4, mo);\n+    VERIFY( f1 == 2.56 );\n+    VERIFY( a1 == 4.96 );\n+\n+    f0 = a0.fetch_sub(1.2);\n+    VERIFY( f0 == 14.0 );\n+    VERIFY( a0 == 12.8 );\n+    f1 = a1.fetch_sub(3.5, mo);\n+    VERIFY( f1 == 4.96 );\n+    VERIFY( a1 == 1.46 );\n+\n+    f0 = a0 += 1.2;\n+    VERIFY( f0 == 14.0 );\n+    VERIFY( a0 == 14.0 );\n+\n+    f0 = a0 -= 0.8;\n+    VERIFY( f0 == 13.2 );\n+    VERIFY( a0 == 13.2 );\n+  }\n+\n+  // Repeat for volatile std::atomic<double>\n+  if constexpr (std::atomic<double>::is_always_lock_free)\n+  {\n+    volatile std::atomic<double> a0;\n+    volatile std::atomic<double> a1(1.0);\n+    ok = a0.is_lock_free();\n+    a0 = a1.load();\n+    VERIFY( a0.load() == a1.load() );\n+    VERIFY( a0.load(mo) == a0.load() );\n+    a0.store(0.5);\n+    a1.store(0.5, mo);\n+    VERIFY( a0.load() == a1.load() );\n+    auto f0 = a0.exchange(12.5);\n+    auto f1 = a1.exchange(12.5, mo);\n+    VERIFY( a0 == 12.5 );\n+    VERIFY( a0.load() == a1.load() );\n+    VERIFY( f0 == 0.5 );\n+    VERIFY( f0 == f1 );\n+\n+    expected = 12.5;\n+    while (!a0.compare_exchange_weak(expected, 1.6, mo, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a0.load() == 1.6 );\n+    VERIFY( expected == 12.5 );\n+    expected = 1.5;\n+    ok = a1.compare_exchange_weak(expected, 1.6, mo, mo);\n+    VERIFY( !ok && a1.load() == 12.5 && expected == 12.5 );\n+    VERIFY( expected == 12.5 );\n+    expected = 1.6;\n+    ok = a0.compare_exchange_strong(expected, 3.2, mo, mo);\n+    VERIFY( ok && a0.load() == 3.2 );\n+    VERIFY( expected == 1.6 );\n+    expected = 1.5;\n+    ok = a1.compare_exchange_strong(expected, 3.2, mo, mo);\n+    VERIFY( !ok && a1.load() == 12.5 && expected == 12.5 );\n+\n+    expected = 3.2;\n+    while (!a0.compare_exchange_weak(expected, .64))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a0.load() == .64 );\n+    expected = 12.5;\n+    while (!a1.compare_exchange_weak(expected, 1.6, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a1.load() == 1.6 );\n+    expected = 0.5;\n+    ok = a0.compare_exchange_weak(expected, 3.2);\n+    VERIFY( !ok && a0.load() == .64 && expected == .64 );\n+    expected = 0.5;\n+    ok = a1.compare_exchange_weak(expected, 3.2, mo);\n+    VERIFY( !ok && a1.load() == 1.6 && expected == 1.6 );\n+\n+    expected = .64;\n+    ok = a0.compare_exchange_strong(expected, 12.8);\n+    VERIFY( ok && a0.load() == 12.8 );\n+    expected = 1.6;\n+    ok = a1.compare_exchange_strong(expected, 2.56, mo);\n+    VERIFY( ok && a1.load() == 2.56 );\n+    expected = 0.5;\n+    ok = a0.compare_exchange_strong(expected, 3.2);\n+    VERIFY( !ok && a0.load() == 12.8 && expected == 12.8 );\n+    expected = 0.5;\n+    ok = a1.compare_exchange_strong(expected, 3.2, mo);\n+    VERIFY( !ok && a1.load() == 2.56 && expected == 2.56 );\n+\n+    f0 = a0.fetch_add(1.2);\n+    VERIFY( f0 == 12.8 );\n+    VERIFY( a0 == 14.0 );\n+    f1 = a1.fetch_add(2.4, mo);\n+    VERIFY( f1 == 2.56 );\n+    VERIFY( a1 == 4.96 );\n+\n+    f0 = a0.fetch_sub(1.2);\n+    VERIFY( f0 == 14.0 );\n+    VERIFY( a0 == 12.8 );\n+    f1 = a1.fetch_sub(3.5, mo);\n+    VERIFY( f1 == 4.96 );\n+    VERIFY( a1 == 1.46 );\n+\n+    f0 = a0 += 1.2;\n+    VERIFY( f0 == 14.0 );\n+    VERIFY( a0 == 14.0 );\n+\n+    f0 = a0 -= 0.8;\n+    VERIFY( f0 == 13.2 );\n+    VERIFY( a0 == 13.2 );\n+  }\n+}\n+\n+void\n+test03()\n+{\n+  const auto mo = std::memory_order_relaxed;\n+  bool ok;\n+  long double expected;\n+\n+  if constexpr (std::atomic<long double>::is_always_lock_free)\n+  {\n+    std::atomic<long double> a0;\n+    std::atomic<long double> a1(1.0l);\n+    ok = a0.is_lock_free();\n+    a0 = a1.load();\n+    VERIFY( a0.load() == a1.load() );\n+    VERIFY( a0.load(mo) == a0.load() );\n+    a0.store(0.5l);\n+    a1.store(0.5l, mo);\n+    VERIFY( a0.load() == a1.load() );\n+    auto f0 = a0.exchange(12.5l);\n+    auto f1 = a1.exchange(12.5l, mo);\n+    VERIFY( a0 == 12.5l );\n+    VERIFY( a0.load() == a1.load() );\n+    VERIFY( f0 == 0.5l );\n+    VERIFY( f0 == f1 );\n+\n+    expected = 12.5l;\n+    while (!a0.compare_exchange_weak(expected, 1.6l, mo, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a0.load() == 1.6l );\n+    VERIFY( expected == 12.5l );\n+    expected = 1.5l;\n+    ok = a1.compare_exchange_weak(expected, 1.6l, mo, mo);\n+    VERIFY( !ok && a1.load() == 12.5l && expected == 12.5l );\n+    VERIFY( expected == 12.5l );\n+    expected = 1.6l;\n+    ok = a0.compare_exchange_strong(expected, 3.2l, mo, mo);\n+    VERIFY( ok && a0.load() == 3.2l );\n+    VERIFY( expected == 1.6l );\n+    expected = 1.5l;\n+    ok = a1.compare_exchange_strong(expected, 3.2l, mo, mo);\n+    VERIFY( !ok && a1.load() == 12.5l && expected == 12.5l );\n+\n+    expected = 3.2l;\n+    while (!a0.compare_exchange_weak(expected, .64l))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a0.load() == .64l );\n+    expected = 12.5l;\n+    while (!a1.compare_exchange_weak(expected, 1.6l, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a1.load() == 1.6l );\n+    expected = 0.5l;\n+    ok = a0.compare_exchange_weak(expected, 3.2l);\n+    VERIFY( !ok && a0.load() == .64l && expected == .64l );\n+    expected = 0.5l;\n+    ok = a1.compare_exchange_weak(expected, 3.2l, mo);\n+    VERIFY( !ok && a1.load() == 1.6l && expected == 1.6l );\n+\n+    expected = .64l;\n+    ok = a0.compare_exchange_strong(expected, 12.8l);\n+    VERIFY( ok && a0.load() == 12.8l );\n+    expected = 1.6l;\n+    ok = a1.compare_exchange_strong(expected, 2.56l, mo);\n+    VERIFY( ok && a1.load() == 2.56l );\n+    expected = 0.5l;\n+    ok = a0.compare_exchange_strong(expected, 3.2l);\n+    VERIFY( !ok && a0.load() == 12.8l && expected == 12.8l );\n+    expected = 0.5l;\n+    ok = a1.compare_exchange_strong(expected, 3.2l, mo);\n+    VERIFY( !ok && a1.load() == 2.56l && expected == 2.56l );\n+\n+    f0 = a0.fetch_add(1.2l);\n+    VERIFY( f0 == 12.8l );\n+    VERIFY( a0 == 14.0l );\n+    f1 = a1.fetch_add(2.4l, mo);\n+    VERIFY( f1 == 2.56l );\n+    VERIFY( a1 == 4.96l );\n+\n+    f0 = a0.fetch_sub(1.2l);\n+    VERIFY( f0 == 14.0l );\n+    VERIFY( a0 == 12.8l );\n+    f1 = a1.fetch_sub(3.5l, mo);\n+    VERIFY( f1 == 4.96l );\n+    VERIFY( a1 == 1.46l );\n+\n+    f0 = a0 += 1.2l;\n+    VERIFY( f0 == 14.0l );\n+    VERIFY( a0 == 14.0l );\n+\n+    f0 = a0 -= 0.8l;\n+    VERIFY( f0 == 13.2l );\n+    VERIFY( a0 == 13.2l );\n+  }\n+\n+  // Repeat for volatile std::atomic<double>\n+  if constexpr (std::atomic<long double>::is_always_lock_free)\n+  {\n+    volatile std::atomic<long double> a0;\n+    volatile std::atomic<long double> a1(1.0l);\n+    ok = a0.is_lock_free();\n+    a0 = a1.load();\n+    VERIFY( a0.load() == a1.load() );\n+    VERIFY( a0.load(mo) == a0.load() );\n+    a0.store(0.5l);\n+    a1.store(0.5l, mo);\n+    VERIFY( a0.load() == a1.load() );\n+    auto f0 = a0.exchange(12.5l);\n+    auto f1 = a1.exchange(12.5l, mo);\n+    VERIFY( a0 == 12.5l );\n+    VERIFY( a0.load() == a1.load() );\n+    VERIFY( f0 == 0.5l );\n+    VERIFY( f0 == f1 );\n+\n+    expected = 12.5l;\n+    while (!a0.compare_exchange_weak(expected, 1.6l, mo, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a0.load() == 1.6l );\n+    VERIFY( expected == 12.5l );\n+    expected = 1.5l;\n+    ok = a1.compare_exchange_weak(expected, 1.6l, mo, mo);\n+    VERIFY( !ok && a1.load() == 12.5l && expected == 12.5l );\n+    VERIFY( expected == 12.5l );\n+    expected = 1.6l;\n+    ok = a0.compare_exchange_strong(expected, 3.2l, mo, mo);\n+    VERIFY( ok && a0.load() == 3.2l );\n+    VERIFY( expected == 1.6l );\n+    expected = 1.5l;\n+    ok = a1.compare_exchange_strong(expected, 3.2l, mo, mo);\n+    VERIFY( !ok && a1.load() == 12.5l && expected == 12.5l );\n+\n+    expected = 3.2l;\n+    while (!a0.compare_exchange_weak(expected, .64l))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a0.load() == .64l );\n+    expected = 12.5l;\n+    while (!a1.compare_exchange_weak(expected, 1.6l, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a1.load() == 1.6l );\n+    expected = 0.5l;\n+    ok = a0.compare_exchange_weak(expected, 3.2l);\n+    VERIFY( !ok && a0.load() == .64l && expected == .64l );\n+    expected = 0.5l;\n+    ok = a1.compare_exchange_weak(expected, 3.2l, mo);\n+    VERIFY( !ok && a1.load() == 1.6l && expected == 1.6l );\n+\n+    expected = .64l;\n+    ok = a0.compare_exchange_strong(expected, 12.8l);\n+    VERIFY( ok && a0.load() == 12.8l );\n+    expected = 1.6l;\n+    ok = a1.compare_exchange_strong(expected, 2.56l, mo);\n+    VERIFY( ok && a1.load() == 2.56l );\n+    expected = 0.5l;\n+    ok = a0.compare_exchange_strong(expected, 3.2l);\n+    VERIFY( !ok && a0.load() == 12.8l && expected == 12.8l );\n+    expected = 0.5l;\n+    ok = a1.compare_exchange_strong(expected, 3.2l, mo);\n+    VERIFY( !ok && a1.load() == 2.56l && expected == 2.56l );\n+\n+    f0 = a0.fetch_add(1.2l);\n+    VERIFY( f0 == 12.8l );\n+    VERIFY( a0 == 14.0l );\n+    f1 = a1.fetch_add(2.4l, mo);\n+    VERIFY( f1 == 2.56l );\n+    VERIFY( a1 == 4.96l );\n+\n+    f0 = a0.fetch_sub(1.2l);\n+    VERIFY( f0 == 14.0l );\n+    VERIFY( a0 == 12.8l );\n+    f1 = a1.fetch_sub(3.5l, mo);\n+    VERIFY( f1 == 4.96l );\n+    VERIFY( a1 == 1.46l );\n+\n+    f0 = a0 += 1.2l;\n+    VERIFY( f0 == 14.0l );\n+    VERIFY( a0 == 14.0l );\n+\n+    f0 = a0 -= 0.8l;\n+    VERIFY( f0 == 13.2l );\n+    VERIFY( a0 == 13.2l );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "e52608c451da3310d2a0ffb34bc3eb3b6e9c24e8", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_float/requirements.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_float%2Frequirements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_float%2Frequirements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_float%2Frequirements.cc?ref=a90fe12c80a13ffed9d5c775703788275d8b7c42", "patch": "@@ -0,0 +1,69 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <atomic>\n+\n+void\n+test01()\n+{\n+  using A = std::atomic<float>;\n+  static_assert( std::is_standard_layout_v<A> );\n+  static_assert( std::is_trivially_default_constructible_v<A> );\n+  static_assert( std::is_trivially_destructible_v<A> );\n+  static_assert( std::is_same_v<A::value_type, float> );\n+  static_assert( std::is_same_v<A::difference_type, A::value_type> );\n+  static_assert( !std::is_copy_constructible_v<A> );\n+  static_assert( !std::is_move_constructible_v<A> );\n+  static_assert( !std::is_copy_assignable_v<A> );\n+  static_assert( !std::is_move_assignable_v<A> );\n+  static_assert( !std::is_assignable_v<volatile A&, const A&> );\n+}\n+\n+void\n+test02()\n+{\n+  using A = std::atomic<double>;\n+  static_assert( std::is_standard_layout_v<A> );\n+  static_assert( std::is_trivially_default_constructible_v<A> );\n+  static_assert( std::is_trivially_destructible_v<A> );\n+  static_assert( std::is_same_v<A::value_type, double> );\n+  static_assert( std::is_same_v<A::difference_type, A::value_type> );\n+  static_assert( !std::is_copy_constructible_v<A> );\n+  static_assert( !std::is_move_constructible_v<A> );\n+  static_assert( !std::is_copy_assignable_v<A> );\n+  static_assert( !std::is_move_assignable_v<A> );\n+  static_assert( !std::is_assignable_v<volatile A&, const A&> );\n+}\n+\n+void\n+test03()\n+{\n+  using A = std::atomic<long double>;\n+  static_assert( std::is_standard_layout_v<A> );\n+  static_assert( std::is_trivially_default_constructible_v<A> );\n+  static_assert( std::is_trivially_destructible_v<A> );\n+  static_assert( std::is_same_v<A::value_type, long double> );\n+  static_assert( std::is_same_v<A::difference_type, A::value_type> );\n+  static_assert( !std::is_copy_constructible_v<A> );\n+  static_assert( !std::is_move_constructible_v<A> );\n+  static_assert( !std::is_copy_assignable_v<A> );\n+  static_assert( !std::is_move_assignable_v<A> );\n+  static_assert( !std::is_assignable_v<volatile A&, const A&> );\n+}"}, {"sha": "231901cc4228851c7b1b87f33654f6adc6b53538", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_ref/deduction.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Fdeduction.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Fdeduction.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Fdeduction.cc?ref=a90fe12c80a13ffed9d5c775703788275d8b7c42", "patch": "@@ -0,0 +1,41 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <atomic>\n+\n+void\n+test01()\n+{\n+  int i = 0;\n+  std::atomic_ref a0(i);\n+  static_assert(std::is_same_v<decltype(a0), std::atomic_ref<int>>);\n+\n+  float f = 1.0f;\n+  std::atomic_ref a1(f);\n+  static_assert(std::is_same_v<decltype(a1), std::atomic_ref<float>>);\n+\n+  int* p = &i;\n+  std::atomic_ref a2(p);\n+  static_assert(std::is_same_v<decltype(a2), std::atomic_ref<int*>>);\n+\n+  struct X { } x;\n+  std::atomic_ref a3(x);\n+  static_assert(std::is_same_v<decltype(a3), std::atomic_ref<X>>);\n+}"}, {"sha": "0633f28e254bba885e74e4a65e137c93dbf5d869", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_ref/float.cc", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Ffloat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Ffloat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Ffloat.cc?ref=a90fe12c80a13ffed9d5c775703788275d8b7c42", "patch": "@@ -0,0 +1,320 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <atomic>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  float value;\n+  if constexpr (std::atomic_ref<float>::is_always_lock_free)\n+  {\n+    const auto mo = std::memory_order_relaxed;\n+    std::atomic_ref<float> a(value);\n+    bool ok = a.is_lock_free();\n+    if constexpr (std::atomic_ref<float>::is_always_lock_free)\n+      VERIFY( ok );\n+    a = 1.6f;\n+    VERIFY( a.load() == 1.6f );\n+    a.store(0.8f);\n+    VERIFY( a.load(mo) == 0.8f );\n+    a.store(3.2f, mo);\n+    VERIFY( a.load() == 3.2f );\n+    auto v = a.exchange(6.4f);\n+    VERIFY( a == 6.4f );\n+    VERIFY( v == 3.2f );\n+    v = a.exchange(1.28f, mo);\n+    VERIFY( a == 1.28f );\n+    VERIFY( v == 6.4f );\n+\n+    auto expected = a.load();\n+    while (!a.compare_exchange_weak(expected, 25.6f, mo, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == 25.6f );\n+    VERIFY( expected == 1.28f );\n+    expected = 3.2f;\n+    ok = a.compare_exchange_weak(expected, 51.2f, mo, mo);\n+    VERIFY( !ok && a.load() == 25.6f && expected == 25.6f );\n+    ok = a.compare_exchange_strong(expected, 51.2f, mo, mo);\n+    VERIFY( ok && a.load() == 51.2f && expected == 25.6f );\n+    expected = 0.0f;\n+    ok = a.compare_exchange_strong(expected, 1.28f, mo, mo);\n+    VERIFY( !ok && a.load() == 51.2f && expected == 51.2f );\n+\n+    while (!a.compare_exchange_weak(expected, 25.6f))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == 25.6f  && expected == 51.2f );\n+    expected = a.load();\n+    while (!a.compare_exchange_weak(expected, 10.24f, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == 10.24f && expected == 25.6f );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_weak(expected, 40.96f);\n+    VERIFY( !ok && a.load() == 10.24f && expected == 10.24f );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_weak(expected, 40.96f, mo);\n+    VERIFY( !ok && a.load() == 10.24f && expected == 10.24f );\n+\n+    ok = a.compare_exchange_strong(expected, 1.024f);\n+    VERIFY( ok && a.load() == 1.024f && expected == 10.24f );\n+    expected = a.load();\n+    ok = a.compare_exchange_strong(expected, 204.8f, mo);\n+    VERIFY( ok && a.load() == 204.8f && expected == 1.024f );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_strong(expected, 6.4f);\n+    VERIFY( !ok && a.load() == 204.8f && expected == 204.8f );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_strong(expected, 6.4f, mo);\n+    VERIFY( !ok && a.load() == 204.8f && expected == 204.8f );\n+\n+    v = a.fetch_add(3.2f);\n+    VERIFY( v == 204.8f );\n+    VERIFY( a == 208.0f );\n+    v = a.fetch_add(-8.5f, mo);\n+    VERIFY( v == 208.0f );\n+    VERIFY( a == 199.5f );\n+\n+    v = a.fetch_sub(109.5f);\n+    VERIFY( v == 199.5f );\n+    VERIFY( a == 90.0f );\n+    v = a.fetch_sub(2, mo);\n+    VERIFY( v == 90.0f );\n+    VERIFY( a == 88.0f );\n+\n+    v = a += 5.0f;\n+    VERIFY( v == 93.0f );\n+    VERIFY( a == 93.0f );\n+\n+    v = a -= 6.5f;\n+    VERIFY( v == 86.5f );\n+    VERIFY( a == 86.5f );\n+  }\n+\n+  if constexpr (std::atomic_ref<float>::is_always_lock_free)\n+    VERIFY( value == 86.5f );\n+}\n+\n+void\n+test02()\n+{\n+  double value;\n+  if constexpr (std::atomic_ref<double>::is_always_lock_free)\n+  {\n+    const auto mo = std::memory_order_relaxed;\n+    std::atomic_ref<double> a(value);\n+    bool ok = a.is_lock_free();\n+    if constexpr (std::atomic_ref<double>::is_always_lock_free)\n+      VERIFY( ok );\n+    a = 1.6;\n+    VERIFY( a.load() == 1.6 );\n+    a.store(0.8);\n+    VERIFY( a.load(mo) == 0.8 );\n+    a.store(3.2, mo);\n+    VERIFY( a.load() == 3.2 );\n+    auto v = a.exchange(6.4);\n+    VERIFY( a == 6.4 );\n+    VERIFY( v == 3.2 );\n+    v = a.exchange(1.28, mo);\n+    VERIFY( a == 1.28 );\n+    VERIFY( v == 6.4 );\n+\n+    auto expected = a.load();\n+    while (!a.compare_exchange_weak(expected, 25.6, mo, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == 25.6 );\n+    VERIFY( expected == 1.28 );\n+    expected = 3.2;\n+    ok = a.compare_exchange_weak(expected, 51.2, mo, mo);\n+    VERIFY( !ok && a.load() == 25.6 && expected == 25.6 );\n+    ok = a.compare_exchange_strong(expected, 51.2, mo, mo);\n+    VERIFY( ok && a.load() == 51.2 && expected == 25.6 );\n+    expected = 0.0;\n+    ok = a.compare_exchange_strong(expected, 1.28, mo, mo);\n+    VERIFY( !ok && a.load() == 51.2 && expected == 51.2 );\n+\n+    while (!a.compare_exchange_weak(expected, 25.6))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == 25.6  && expected == 51.2 );\n+    expected = a.load();\n+    while (!a.compare_exchange_weak(expected, 10.24, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == 10.24 && expected == 25.6 );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_weak(expected, 40.96);\n+    VERIFY( !ok && a.load() == 10.24 && expected == 10.24 );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_weak(expected, 40.96, mo);\n+    VERIFY( !ok && a.load() == 10.24 && expected == 10.24 );\n+\n+    ok = a.compare_exchange_strong(expected, 1.024);\n+    VERIFY( ok && a.load() == 1.024 && expected == 10.24 );\n+    expected = a.load();\n+    ok = a.compare_exchange_strong(expected, 204.8, mo);\n+    VERIFY( ok && a.load() == 204.8 && expected == 1.024 );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_strong(expected, 6.4);\n+    VERIFY( !ok && a.load() == 204.8 && expected == 204.8 );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_strong(expected, 6.4, mo);\n+    VERIFY( !ok && a.load() == 204.8 && expected == 204.8 );\n+\n+    v = a.fetch_add(3.2);\n+    VERIFY( v == 204.8 );\n+    VERIFY( a == 208.0 );\n+    v = a.fetch_add(-8.5, mo);\n+    VERIFY( v == 208.0 );\n+    VERIFY( a == 199.5 );\n+\n+    v = a.fetch_sub(109.5);\n+    VERIFY( v == 199.5 );\n+    VERIFY( a == 90.0 );\n+    v = a.fetch_sub(2, mo);\n+    VERIFY( v == 90.0 );\n+    VERIFY( a == 88.0 );\n+\n+    v = a += 5.0;\n+    VERIFY( v == 93.0 );\n+    VERIFY( a == 93.0 );\n+\n+    v = a -= 6.5;\n+    VERIFY( v == 86.5 );\n+    VERIFY( a == 86.5 );\n+  }\n+\n+  if constexpr (std::atomic_ref<double>::is_always_lock_free)\n+    VERIFY( value == 86.5 );\n+}\n+\n+void\n+test03()\n+{\n+  long double value;\n+  if constexpr (std::atomic_ref<long double>::is_always_lock_free)\n+  {\n+    const auto mo = std::memory_order_relaxed;\n+    std::atomic_ref<long double> a(value);\n+    bool ok = a.is_lock_free();\n+    if constexpr (std::atomic_ref<long double>::is_always_lock_free)\n+      VERIFY( ok );\n+    a = 1.6l;\n+    VERIFY( a.load() == 1.6l );\n+    a.store(0.8l);\n+    VERIFY( a.load(mo) == 0.8l );\n+    a.store(3.2l, mo);\n+    VERIFY( a.load() == 3.2l );\n+    auto v = a.exchange(6.4l);\n+    VERIFY( a == 6.4l );\n+    VERIFY( v == 3.2l );\n+    v = a.exchange(1.28l, mo);\n+    VERIFY( a == 1.28l );\n+    VERIFY( v == 6.4l );\n+\n+    auto expected = a.load();\n+    while (!a.compare_exchange_weak(expected, 25.6l, mo, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == 25.6l );\n+    VERIFY( expected == 1.28l );\n+    expected = 3.2l;\n+    ok = a.compare_exchange_weak(expected, 51.2l, mo, mo);\n+    VERIFY( !ok && a.load() == 25.6l && expected == 25.6l );\n+    ok = a.compare_exchange_strong(expected, 51.2l, mo, mo);\n+    VERIFY( ok && a.load() == 51.2l && expected == 25.6l );\n+    expected = 0.0l;\n+    ok = a.compare_exchange_strong(expected, 1.28l, mo, mo);\n+    VERIFY( !ok && a.load() == 51.2l && expected == 51.2l );\n+\n+    while (!a.compare_exchange_weak(expected, 25.6l))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == 25.6l  && expected == 51.2l );\n+    expected = a.load();\n+    while (!a.compare_exchange_weak(expected, 10.24l, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == 10.24l && expected == 25.6l );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_weak(expected, 40.96l);\n+    VERIFY( !ok && a.load() == 10.24l && expected == 10.24l );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_weak(expected, 40.96l, mo);\n+    VERIFY( !ok && a.load() == 10.24l && expected == 10.24l );\n+\n+    ok = a.compare_exchange_strong(expected, 1.024l);\n+    VERIFY( ok && a.load() == 1.024l && expected == 10.24l );\n+    expected = a.load();\n+    ok = a.compare_exchange_strong(expected, 204.8l, mo);\n+    VERIFY( ok && a.load() == 204.8l && expected == 1.024l );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_strong(expected, 6.4l);\n+    VERIFY( !ok && a.load() == 204.8l && expected == 204.8l );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_strong(expected, 6.4l, mo);\n+    VERIFY( !ok && a.load() == 204.8l && expected == 204.8l );\n+\n+    v = a.fetch_add(3.2l);\n+    VERIFY( v == 204.8l );\n+    VERIFY( a == 208.0l );\n+    v = a.fetch_add(-8.5l, mo);\n+    VERIFY( v == 208.0l );\n+    VERIFY( a == 199.5l );\n+\n+    v = a.fetch_sub(109.5l);\n+    VERIFY( v == 199.5l );\n+    VERIFY( a == 90.0l );\n+    v = a.fetch_sub(2, mo);\n+    VERIFY( v == 90.0l );\n+    VERIFY( a == 88.0l );\n+\n+    v = a += 5.0l;\n+    VERIFY( v == 93.0l );\n+    VERIFY( a == 93.0l );\n+\n+    v = a -= 6.5l;\n+    VERIFY( v == 86.5l );\n+    VERIFY( a == 86.5l );\n+  }\n+\n+  if constexpr (std::atomic_ref<long double>::is_always_lock_free)\n+    VERIFY( value == 86.5l );\n+}\n+\n+void\n+test04()\n+{\n+  if constexpr (std::atomic_ref<float>::is_always_lock_free)\n+  {\n+    float i = 0;\n+    float* ptr = 0;\n+    std::atomic_ref<float*> a0(ptr);\n+    std::atomic_ref<float*> a1(ptr);\n+    std::atomic_ref<float*> a2(a0);\n+    a0 = &i;\n+    VERIFY( a1 == &i );\n+    VERIFY( a2 == &i );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "61ae61bb3de8b93fbcd508bc800a57cf75c56b96", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_ref/generic.cc", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Fgeneric.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Fgeneric.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Fgeneric.cc?ref=a90fe12c80a13ffed9d5c775703788275d8b7c42", "patch": "@@ -0,0 +1,122 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+// { dg-add-options libatomic }\n+\n+#include <atomic>\n+#include <limits.h>\n+#include <testsuite_hooks.h>\n+\n+struct X\n+{\n+  X() = default;\n+  X(int i) : i(i) { }\n+  bool operator==(int rhs) const { return i == rhs; }\n+  int i;\n+};\n+\n+void\n+test01()\n+{\n+  X value;\n+\n+  {\n+    const auto mo = std::memory_order_relaxed;\n+    std::atomic_ref<X> a(value);\n+    bool ok = a.is_lock_free();\n+    if constexpr (std::atomic_ref<X>::is_always_lock_free)\n+      VERIFY( ok );\n+    a = X{};\n+    VERIFY( a.load() == 0 );\n+    VERIFY( a.load(mo) == 0 );\n+    a.store(1);\n+    VERIFY( a.load() == 1 );\n+    auto v = a.exchange(2);\n+    VERIFY( a.load() == 2 );\n+    VERIFY( v == 1 );\n+    v = a.exchange(3, mo);\n+    VERIFY( a.load() == 3 );\n+    VERIFY( v == 2 );\n+\n+    auto expected = a.load();\n+    while (!a.compare_exchange_weak(expected, 4, mo, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == 4 );\n+    VERIFY( expected == 3 );\n+    expected = 1;\n+    ok = a.compare_exchange_weak(expected, 5, mo, mo);\n+    VERIFY( !ok && a.load() == 4 && expected == 4 );\n+    ok = a.compare_exchange_strong(expected, 5, mo, mo);\n+    VERIFY( ok && a.load() == 5 && expected == 4 );\n+    expected = 0;\n+    ok = a.compare_exchange_strong(expected, 3, mo, mo);\n+    VERIFY( !ok && a.load() == 5 && expected == 5 );\n+\n+    while (!a.compare_exchange_weak(expected, 4))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == 4  && expected == 5 );\n+    expected = a.load();\n+    while (!a.compare_exchange_weak(expected, 6, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == 6 && expected == 4 );\n+    expected = a.load();\n+    expected.i += 1;\n+    ok = a.compare_exchange_weak(expected, -8);\n+    VERIFY( !ok && a.load() == 6 && expected == 6 );\n+    expected = a.load();\n+    expected.i += 1;\n+    ok = a.compare_exchange_weak(expected, 8, mo);\n+    VERIFY( !ok && a.load() == 6 && expected == 6 );\n+\n+    ok = a.compare_exchange_strong(expected, -6);\n+    VERIFY( ok && a.load() == -6 && expected == 6 );\n+    expected = a.load();\n+    ok = a.compare_exchange_strong(expected, 7, mo);\n+    VERIFY( ok && a.load() == 7 && expected == -6 );\n+    expected = a.load();\n+    expected.i += 1;\n+    ok = a.compare_exchange_strong(expected, 2);\n+    VERIFY( !ok && a.load() == 7 && expected == 7 );\n+    expected = a.load();\n+    expected.i += 1;\n+    ok = a.compare_exchange_strong(expected, 2, mo);\n+    VERIFY( !ok && a.load() == 7 && expected == 7 );\n+  }\n+\n+  VERIFY( value == 7 );\n+}\n+\n+void\n+test02()\n+{\n+  X i;\n+  std::atomic_ref<X> a0(i);\n+  std::atomic_ref<X> a1(i);\n+  std::atomic_ref<X> a2(a0);\n+  a0 = 42;\n+  VERIFY( a1.load() == 42 );\n+  VERIFY( a2.load() == 42 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "4b5b4d11fd8114165910777474c33cca9b3d3ca9", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_ref/integral.cc", "status": "added", "additions": 331, "deletions": 0, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Fintegral.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Fintegral.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Fintegral.cc?ref=a90fe12c80a13ffed9d5c775703788275d8b7c42", "patch": "@@ -0,0 +1,331 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+// { dg-add-options libatomic }\n+\n+#include <atomic>\n+#include <limits.h>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  int value;\n+\n+  {\n+    const auto mo = std::memory_order_relaxed;\n+    std::atomic_ref<int> a(value);\n+    bool ok = a.is_lock_free();\n+    if constexpr (std::atomic_ref<int>::is_always_lock_free)\n+      VERIFY( ok );\n+    a = 0;\n+    VERIFY( a.load() == 0 );\n+    VERIFY( a.load(mo) == 0 );\n+    a.store(1);\n+    VERIFY( a.load() == 1 );\n+    auto v = a.exchange(2);\n+    VERIFY( a == 2 );\n+    VERIFY( v == 1 );\n+    v = a.exchange(3, mo);\n+    VERIFY( a == 3 );\n+    VERIFY( v == 2 );\n+\n+    auto expected = a.load();\n+    while (!a.compare_exchange_weak(expected, 4, mo, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == 4 );\n+    VERIFY( expected == 3 );\n+    expected = 1;\n+    ok = a.compare_exchange_weak(expected, 5, mo, mo);\n+    VERIFY( !ok && a.load() == 4 && expected == 4 );\n+    ok = a.compare_exchange_strong(expected, 5, mo, mo);\n+    VERIFY( ok && a.load() == 5 && expected == 4 );\n+    expected = 0;\n+    ok = a.compare_exchange_strong(expected, 3, mo, mo);\n+    VERIFY( !ok && a.load() == 5 && expected == 5 );\n+\n+    while (!a.compare_exchange_weak(expected, 4))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == 4  && expected == 5 );\n+    expected = a.load();\n+    while (!a.compare_exchange_weak(expected, 6, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == 6 && expected == 4 );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_weak(expected, -8);\n+    VERIFY( !ok && a.load() == 6 && expected == 6 );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_weak(expected, 8, mo);\n+    VERIFY( !ok && a.load() == 6 && expected == 6 );\n+\n+    ok = a.compare_exchange_strong(expected, -6);\n+    VERIFY( ok && a.load() == -6 && expected == 6 );\n+    expected = a.load();\n+    ok = a.compare_exchange_strong(expected, 7, mo);\n+    VERIFY( ok && a.load() == 7 && expected == -6 );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_strong(expected, 2);\n+    VERIFY( !ok && a.load() == 7 && expected == 7 );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_strong(expected, 2, mo);\n+    VERIFY( !ok && a.load() == 7 && expected == 7 );\n+\n+    v = a.fetch_add(2);\n+    VERIFY( v == 7 );\n+    VERIFY( a == 9 );\n+    v = a.fetch_add(-30, mo);\n+    VERIFY( v == 9 );\n+    VERIFY( a == -21 );\n+\n+    v = a.fetch_sub(3);\n+    VERIFY( v == -21 );\n+    VERIFY( a == -24 );\n+    v = a.fetch_sub(-41, mo);\n+    VERIFY( v == -24 );\n+    VERIFY( a == 17 );\n+\n+    v = a.fetch_and(0x101);\n+    VERIFY( v == 17 );\n+    VERIFY( a == 1 );\n+    a = 0x17;\n+    v = a.fetch_and(0x23, mo);\n+    VERIFY( v == 0x17 );\n+    VERIFY( a == 3 );\n+\n+    v = a.fetch_or(0x101);\n+    VERIFY( v == 3 );\n+    VERIFY( a == 0x103 );\n+    v = a.fetch_or(0x23, mo);\n+    VERIFY( v == 0x103 );\n+    VERIFY( a == 0x123 );\n+\n+    v = a.fetch_xor(0x101);\n+    VERIFY( v == 0x123 );\n+    VERIFY( a == 0x022 );\n+    v = a.fetch_xor(0x123, mo);\n+    VERIFY( v == 0x022 );\n+    VERIFY( a == 0x101 );\n+\n+    v = a++;\n+    VERIFY( v == 0x101 );\n+    VERIFY( a == 0x102 );\n+    v = a--;\n+    VERIFY( v == 0x102 );\n+    VERIFY( a == 0x101 );\n+    v = ++a;\n+    VERIFY( v == 0x102 );\n+    VERIFY( a == 0x102 );\n+    v = --a;\n+    VERIFY( v == 0x101 );\n+    VERIFY( a == 0x101 );\n+\n+    v = a += -10;\n+    VERIFY( v == 247 );\n+    VERIFY( a == 247 );\n+\n+    v = a -= 250;\n+    VERIFY( v == -3 );\n+    VERIFY( a == -3 );\n+\n+    a = 0x17;\n+    v = a &= 0x102;\n+    VERIFY( v == 2 );\n+    VERIFY( a == 2 );\n+\n+    v = a |= 0x101;\n+    VERIFY( v == 0x103 );\n+    VERIFY( a == 0x103 );\n+\n+    v = a ^= 0x121;\n+    VERIFY( v == 0x022 );\n+    VERIFY( a == 0x022 );\n+  }\n+\n+  VERIFY( value == 0x022 );\n+}\n+\n+void\n+test02()\n+{\n+  unsigned short value;\n+\n+  {\n+    const auto mo = std::memory_order_relaxed;\n+    std::atomic_ref<unsigned short> a(value);\n+    bool ok = a.is_lock_free();\n+    if constexpr (std::atomic_ref<unsigned short>::is_always_lock_free)\n+      VERIFY( ok );\n+    a = 0;\n+    VERIFY( a.load() == 0 );\n+    VERIFY( a.load(mo) == 0 );\n+    a.store(1);\n+    VERIFY( a.load() == 1 );\n+    auto v = a.exchange(2);\n+    VERIFY( a == 2 );\n+    VERIFY( v == 1 );\n+    v = a.exchange(3, mo);\n+    VERIFY( a == 3 );\n+    VERIFY( v == 2 );\n+\n+    auto expected = a.load();\n+    while (!a.compare_exchange_weak(expected, 4, mo, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == 4 );\n+    VERIFY( expected == 3 );\n+    expected = 1;\n+    ok = a.compare_exchange_weak(expected, 5, mo, mo);\n+    VERIFY( !ok && a.load() == 4 && expected == 4 );\n+    ok = a.compare_exchange_strong(expected, 5, mo, mo);\n+    VERIFY( ok && a.load() == 5 && expected == 4 );\n+    expected = 0;\n+    ok = a.compare_exchange_strong(expected, 3, mo, mo);\n+    VERIFY( !ok && a.load() == 5 && expected == 5 );\n+\n+    while (!a.compare_exchange_weak(expected, 4))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == 4  && expected == 5 );\n+    expected = a.load();\n+    while (!a.compare_exchange_weak(expected, 6, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == 6 && expected == 4 );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_weak(expected, -8);\n+    VERIFY( !ok && a.load() == 6 && expected == 6 );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_weak(expected, 8, mo);\n+    VERIFY( !ok && a.load() == 6 && expected == 6 );\n+\n+    ok = a.compare_exchange_strong(expected, -6);\n+    VERIFY( ok && a.load() == (unsigned short)-6 && expected == 6 );\n+    expected = a.load();\n+    ok = a.compare_exchange_strong(expected, 7, mo);\n+    VERIFY( ok && a.load() == 7 && expected == (unsigned short)-6 );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_strong(expected, 2);\n+    VERIFY( !ok && a.load() == 7 && expected == 7 );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_strong(expected, 2, mo);\n+    VERIFY( !ok && a.load() == 7 && expected == 7 );\n+\n+    v = a.fetch_add(2);\n+    VERIFY( v == 7 );\n+    VERIFY( a == 9 );\n+    v = a.fetch_add(-30, mo);\n+    VERIFY( v == 9 );\n+    VERIFY( a == (unsigned short)-21 );\n+\n+    v = a.fetch_sub(3);\n+    VERIFY( v == (unsigned short)-21 );\n+    VERIFY( a == (unsigned short)-24 );\n+    v = a.fetch_sub((unsigned short)-41, mo);\n+    VERIFY( v == (unsigned short)-24 );\n+    VERIFY( a == 17 );\n+\n+    v = a.fetch_and(0x21);\n+    VERIFY( v == 17 );\n+    VERIFY( a == 1 );\n+    a = 0x17;\n+    v = a.fetch_and(0x23, mo);\n+    VERIFY( v == 0x17 );\n+    VERIFY( a == 3 );\n+\n+    v = a.fetch_or(0x21);\n+    VERIFY( v == 3 );\n+    VERIFY( a == 0x23 );\n+    v = a.fetch_or(0x44, mo);\n+    VERIFY( v == 0x23 );\n+    VERIFY( a == 0x67 );\n+\n+    v = a.fetch_xor(0x21);\n+    VERIFY( v == 0x67 );\n+    VERIFY( a == 0x46 );\n+    v = a.fetch_xor(0x12, mo);\n+    VERIFY( v == 0x46 );\n+    VERIFY( a == 0x54 );\n+\n+    v = a++;\n+    VERIFY( v == 0x54 );\n+    VERIFY( a == 0x55 );\n+    v = a--;\n+    VERIFY( v == 0x55 );\n+    VERIFY( a == 0x54 );\n+    v = ++a;\n+    VERIFY( v == 0x55 );\n+    VERIFY( a == 0x55 );\n+    v = --a;\n+    VERIFY( v == 0x54 );\n+    VERIFY( a == 0x54 );\n+\n+    v = a += -10;\n+    VERIFY( v == 0x4a );\n+    VERIFY( a == 0x4a );\n+\n+    v = a -= 15;\n+    VERIFY( v == 0x3b );\n+    VERIFY( a == 0x3b );\n+\n+    a = 0x17;\n+    v = a &= 0x12;\n+    VERIFY( v == 0x12 );\n+    VERIFY( a == 0x12 );\n+\n+    v = a |= 0x34;\n+    VERIFY( v == 0x36 );\n+    VERIFY( a == 0x36 );\n+\n+    v = a ^= 0x12;\n+    VERIFY( v == 0x24 );\n+    VERIFY( a == 0x24 );\n+  }\n+\n+  VERIFY( value == 0x24 );\n+}\n+void\n+test03()\n+{\n+  int i = 0;\n+  std::atomic_ref<int> a0(i);\n+  std::atomic_ref<int> a1(i);\n+  std::atomic_ref<int> a2(a0);\n+  a0 = 42;\n+  VERIFY( a1 == 42 );\n+  VERIFY( a2 == 42 );\n+}\n+\n+void\n+test04()\n+{\n+  int i = INT_MIN;\n+  std::atomic_ref<int> a(i);\n+  --a;\n+  VERIFY( a == INT_MAX );\n+  ++a;\n+  VERIFY( a == INT_MIN );\n+  a |= INT_MAX;\n+  VERIFY( a == -1 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "d5256d67622afdb0f7f44f8252069a96b961c36f", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_ref/pointer.cc", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Fpointer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Fpointer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Fpointer.cc?ref=a90fe12c80a13ffed9d5c775703788275d8b7c42", "patch": "@@ -0,0 +1,225 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+// { dg-add-options libatomic }\n+\n+#include <atomic>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  long arr[10] = { };\n+  long* value;\n+\n+  {\n+    const auto mo = std::memory_order_relaxed;\n+    std::atomic_ref<long*> a(value);\n+    bool ok = a.is_lock_free();\n+    if constexpr (std::atomic_ref<long*>::is_always_lock_free)\n+      VERIFY( ok );\n+    a = arr;\n+    VERIFY( a.load() == arr );\n+    VERIFY( a.load(mo) == arr );\n+    a.store(arr+1);\n+    VERIFY( a.load() == arr+1 );\n+    auto v = a.exchange(arr+2);\n+    VERIFY( a == arr+2 );\n+    VERIFY( v == arr+1 );\n+    v = a.exchange(arr+3, mo);\n+    VERIFY( a == arr+3 );\n+    VERIFY( v == arr+2 );\n+\n+    auto expected = a.load();\n+    while (!a.compare_exchange_weak(expected, arr+4, mo, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == arr+4 );\n+    VERIFY( expected == arr+3 );\n+    expected = arr+1;\n+    ok = a.compare_exchange_weak(expected, arr+5, mo, mo);\n+    VERIFY( !ok && a.load() == arr+4 && expected == arr+4 );\n+    ok = a.compare_exchange_strong(expected, arr+5, mo, mo);\n+    VERIFY( ok && a.load() == arr+5 && expected == arr+4 );\n+    expected = nullptr;\n+    ok = a.compare_exchange_strong(expected, arr+3, mo, mo);\n+    VERIFY( !ok && a.load() == arr+5 && expected == arr+5 );\n+\n+    while (!a.compare_exchange_weak(expected, arr+4))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == arr+4  && expected == arr+5 );\n+    expected = a.load();\n+    while (!a.compare_exchange_weak(expected, arr+6, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == arr+6 && expected == arr+4 );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_weak(expected, arr+8);\n+    VERIFY( !ok && a.load() == arr+6 && expected == arr+6 );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_weak(expected, arr+8, mo);\n+    VERIFY( !ok && a.load() == arr+6 && expected == arr+6 );\n+\n+    ok = a.compare_exchange_strong(expected, arr+5);\n+    VERIFY( ok && a.load() == arr+5 && expected == arr+6 );\n+    expected = a.load();\n+    ok = a.compare_exchange_strong(expected, arr+7, mo);\n+    VERIFY( ok && a.load() == arr+7 && expected == arr+5 );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_strong(expected, arr+2);\n+    VERIFY( !ok && a.load() == arr+7 && expected == arr+7 );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_strong(expected, arr+2, mo);\n+    VERIFY( !ok && a.load() == arr+7 && expected == arr+7 );\n+\n+    v = a.fetch_add(2);\n+    VERIFY( v == arr+7 );\n+    VERIFY( a == arr+9 );\n+    v = a.fetch_add(-3, mo);\n+    VERIFY( v == arr+9 );\n+    VERIFY( a == arr+6 );\n+\n+    v = a.fetch_sub(3);\n+    VERIFY( v == arr+6 );\n+    VERIFY( a == arr+3 );\n+    v = a.fetch_sub(2, mo);\n+    VERIFY( v == arr+3 );\n+    VERIFY( a == arr+1 );\n+\n+    v = a += 5;\n+    VERIFY( v == arr+6 );\n+    VERIFY( a == arr+6 );\n+\n+    v = a -= 5;\n+    VERIFY( v == arr+1 );\n+    VERIFY( a == arr+1 );\n+  }\n+\n+  VERIFY( value == arr+1 );\n+}\n+\n+void\n+test02()\n+{\n+  char arr[10] = { };\n+  char* value;\n+\n+  {\n+    const auto mo = std::memory_order_relaxed;\n+    std::atomic_ref<char*> a(value);\n+    bool ok = a.is_lock_free();\n+    if constexpr (std::atomic_ref<char*>::is_always_lock_free)\n+      VERIFY( ok );\n+    a = arr;\n+    VERIFY( a.load() == arr );\n+    a.store(arr+3);\n+    VERIFY( a.load(mo) == arr+3 );\n+    a.store(arr+1, mo);\n+    VERIFY( a.load() == arr+1 );\n+    auto v = a.exchange(arr+2);\n+    VERIFY( a == arr+2 );\n+    VERIFY( v == arr+1 );\n+    v = a.exchange(arr+3, mo);\n+    VERIFY( a == arr+3 );\n+    VERIFY( v == arr+2 );\n+\n+    auto expected = a.load();\n+    while (!a.compare_exchange_weak(expected, arr+4, mo, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == arr+4 );\n+    VERIFY( expected == arr+3 );\n+    expected = arr+1;\n+    ok = a.compare_exchange_weak(expected, arr+5, mo, mo);\n+    VERIFY( !ok && a.load() == arr+4 && expected == arr+4 );\n+    ok = a.compare_exchange_strong(expected, arr+5, mo, mo);\n+    VERIFY( ok && a.load() == arr+5 && expected == arr+4 );\n+    expected = nullptr;\n+    ok = a.compare_exchange_strong(expected, arr+3, mo, mo);\n+    VERIFY( !ok && a.load() == arr+5 && expected == arr+5 );\n+\n+    while (!a.compare_exchange_weak(expected, arr+4))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == arr+4  && expected == arr+5 );\n+    expected = a.load();\n+    while (!a.compare_exchange_weak(expected, arr+6, mo))\n+    { /* weak form can fail spuriously */ }\n+    VERIFY( a.load() == arr+6 && expected == arr+4 );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_weak(expected, arr+8);\n+    VERIFY( !ok && a.load() == arr+6 && expected == arr+6 );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_weak(expected, arr+8, mo);\n+    VERIFY( !ok && a.load() == arr+6 && expected == arr+6 );\n+\n+    ok = a.compare_exchange_strong(expected, arr+5);\n+    VERIFY( ok && a.load() == arr+5 && expected == arr+6 );\n+    expected = a.load();\n+    ok = a.compare_exchange_strong(expected, arr+7, mo);\n+    VERIFY( ok && a.load() == arr+7 && expected == arr+5 );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_strong(expected, arr+2);\n+    VERIFY( !ok && a.load() == arr+7 && expected == arr+7 );\n+    expected = a.load() + 1;\n+    ok = a.compare_exchange_strong(expected, arr+2, mo);\n+    VERIFY( !ok && a.load() == arr+7 && expected == arr+7 );\n+\n+    v = a.fetch_add(2);\n+    VERIFY( v == arr+7 );\n+    VERIFY( a == arr+9 );\n+    v = a.fetch_add(-3, mo);\n+    VERIFY( v == arr+9 );\n+    VERIFY( a == arr+6 );\n+\n+    v = a.fetch_sub(3);\n+    VERIFY( v == arr+6 );\n+    VERIFY( a == arr+3 );\n+    v = a.fetch_sub(2, mo);\n+    VERIFY( v == arr+3 );\n+    VERIFY( a == arr+1 );\n+\n+    v = a += 5;\n+    VERIFY( v == arr+6 );\n+    VERIFY( a == arr+6 );\n+\n+    v = a -= 5;\n+    VERIFY( v == arr+1 );\n+    VERIFY( a == arr+1 );\n+  }\n+\n+  VERIFY( value == arr+1 );\n+}\n+\n+void\n+test03()\n+{\n+  int i = 0;\n+  int* ptr = 0;\n+  std::atomic_ref<int*> a0(ptr);\n+  std::atomic_ref<int*> a1(ptr);\n+  std::atomic_ref<int*> a2(a0);\n+  a0 = &i;\n+  VERIFY( a1 == &i );\n+  VERIFY( a2 == &i );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "a3fd4505d0f7731ce3e2c0671bb93cee54cc3943", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_ref/requirements.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Frequirements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90fe12c80a13ffed9d5c775703788275d8b7c42/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Frequirements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Frequirements.cc?ref=a90fe12c80a13ffed9d5c775703788275d8b7c42", "patch": "@@ -0,0 +1,74 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <atomic>\n+\n+void\n+test01()\n+{\n+  struct X { int c; };\n+  using A = std::atomic_ref<X>;\n+  static_assert( std::is_standard_layout_v<A> );\n+  static_assert( std::is_nothrow_copy_constructible_v<A> );\n+  static_assert( std::is_trivially_destructible_v<A> );\n+  static_assert( std::is_same_v<A::value_type, X> );\n+  static_assert( !std::is_copy_assignable_v<A> );\n+  static_assert( !std::is_move_assignable_v<A> );\n+}\n+\n+void\n+test02()\n+{\n+  using A = std::atomic_ref<int>;\n+  static_assert( std::is_standard_layout_v<A> );\n+  static_assert( std::is_nothrow_copy_constructible_v<A> );\n+  static_assert( std::is_trivially_destructible_v<A> );\n+  static_assert( std::is_same_v<A::value_type, int> );\n+  static_assert( std::is_same_v<A::difference_type, A::value_type> );\n+  static_assert( !std::is_copy_assignable_v<A> );\n+  static_assert( !std::is_move_assignable_v<A> );\n+}\n+\n+void\n+test03()\n+{\n+  using A = std::atomic_ref<double>;\n+  static_assert( std::is_standard_layout_v<A> );\n+  static_assert( std::is_nothrow_copy_constructible_v<A> );\n+  static_assert( std::is_trivially_destructible_v<A> );\n+  static_assert( std::is_same_v<A::value_type, double> );\n+  static_assert( std::is_same_v<A::difference_type, A::value_type> );\n+  static_assert( !std::is_copy_assignable_v<A> );\n+  static_assert( !std::is_move_assignable_v<A> );\n+}\n+\n+void\n+test04()\n+{\n+  using A = std::atomic_ref<int*>;\n+  static_assert( std::is_standard_layout_v<A> );\n+  static_assert( std::is_nothrow_copy_constructible_v<A> );\n+  static_assert( std::is_trivially_destructible_v<A> );\n+  static_assert( std::is_same_v<A::value_type, int*> );\n+  static_assert( std::is_same_v<A::difference_type, std::ptrdiff_t> );\n+  static_assert( std::is_nothrow_copy_constructible_v<A> );\n+  static_assert( !std::is_copy_assignable_v<A> );\n+  static_assert( !std::is_move_assignable_v<A> );\n+}"}]}