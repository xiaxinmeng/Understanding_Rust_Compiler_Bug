{"sha": "b9365b93212041f14a7f71ba8da5af4d82240dc6", "node_id": "C_kwDOANBUbNoAKGI5MzY1YjkzMjEyMDQxZjE0YTdmNzFiYThkYTVhZjRkODIyNDBkYzY", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-05-26T19:47:23Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-11-13T14:27:26Z"}, "message": "analyzer: add four new taint-based warnings\n\nThe initial commit of the analyzer in GCC 10 had a single warning,\n  -Wanalyzer-tainted-array-index\nand required manually enabling the taint checker with\n-fanalyzer-checker=taint (due to scaling issues).\n\nThis patch extends the taint detection to add four new taint-based\nwarnings:\n\n  -Wanalyzer-tainted-allocation-size\n     for e.g. attacker-controlled malloc/alloca\n  -Wanalyzer-tainted-divisor\n     for detecting where an attacker can inject a divide-by-zero\n  -Wanalyzer-tainted-offset\n     for attacker-controlled pointer offsets\n  -Wanalyzer-tainted-size\n     for e.g. attacker-controlled memset\n\nand rewords all the warnings to talk about \"attacker-controlled\" values\nrather than \"tainted\" values.\n\nUnfortunately I haven't yet addressed the scaling issues, so all of\nthese still require -fanalyzer-checker=taint (in addition to -fanalyzer).\n\ngcc/analyzer/ChangeLog:\n\t* analyzer.opt (Wanalyzer-tainted-allocation-size): New.\n\t(Wanalyzer-tainted-divisor): New.\n\t(Wanalyzer-tainted-offset): New.\n\t(Wanalyzer-tainted-size): New.\n\t* engine.cc (impl_region_model_context::get_taint_map): New.\n\t* exploded-graph.h (impl_region_model_context::get_taint_map):\n\tNew decl.\n\t* program-state.cc (sm_state_map::get_state): Call\n\talt_get_inherited_state.\n\t(sm_state_map::impl_set_state): Modify states within\n\tcompound svalues.\n\t(program_state::impl_call_analyzer_dump_state): Undo casts.\n\t(selftest::test_program_state_1): Update for new context param of\n\tcreate_region_for_heap_alloc.\n\t(selftest::test_program_state_merging): Likewise.\n\t* region-model-impl-calls.cc (region_model::impl_call_alloca):\n\tLikewise.\n\t(region_model::impl_call_calloc): Likewise.\n\t(region_model::impl_call_malloc): Likewise.\n\t(region_model::impl_call_operator_new): Likewise.\n\t(region_model::impl_call_realloc): Likewise.\n\t* region-model.cc (region_model::check_region_access): Call\n\tcheck_region_for_taint.\n\t(region_model::get_representative_path_var_1): Handle binops.\n\t(region_model::create_region_for_heap_alloc): Add \"ctxt\" param and\n\tpass it to set_dynamic_extents.\n\t(region_model::create_region_for_alloca): Likewise.\n\t(region_model::set_dynamic_extents): Add \"ctxt\" param and use it\n\tto call check_dynamic_size_for_taint.\n\t(selftest::test_state_merging): Update for new context param of\n\tcreate_region_for_heap_alloc.\n\t(selftest::test_malloc_constraints): Likewise.\n\t(selftest::test_malloc): Likewise.\n\t(selftest::test_alloca): Likewise for create_region_for_alloca.\n\t* region-model.h (region_model::create_region_for_heap_alloc): Add\n\t\"ctxt\" param.\n\t(region_model::create_region_for_alloca): Likewise.\n\t(region_model::set_dynamic_extents): Likewise.\n\t(region_model::check_dynamic_size_for_taint): New decl.\n\t(region_model::check_region_for_taint): New decl.\n\t(region_model_context::get_taint_map): New vfunc.\n\t(noop_region_model_context::get_taint_map): New.\n\t* sm-taint.cc: Remove include of \"diagnostic-event-id.h\"; add\n\tincludes of \"gimple-iterator.h\", \"tristate.h\", \"selftest.h\",\n\t\"ordered-hash-map.h\", \"cgraph.h\", \"cfg.h\", \"digraph.h\",\n\t\"analyzer/supergraph.h\", \"analyzer/call-string.h\",\n\t\"analyzer/program-point.h\", \"analyzer/store.h\",\n\t\"analyzer/region-model.h\", and \"analyzer/program-state.h\".\n\t(enum bounds): Move to top of file.\n\t(class taint_diagnostic): New.\n\t(class tainted_array_index): Convert to subclass of taint_diagnostic.\n\t(tainted_array_index::emit): Add CWE-129.  Reword warning to use\n\t\"attacker-controlled\" rather than \"tainted\".\n\t(tainted_array_index::describe_state_change): Move to\n\ttaint_diagnostic::describe_state_change.\n\t(tainted_array_index::describe_final_event): Reword to use\n\t\"attacker-controlled\" rather than \"tainted\".\n\t(class tainted_offset): New.\n\t(class tainted_size): New.\n\t(class tainted_divisor): New.\n\t(class tainted_allocation_size): New.\n\t(taint_state_machine::alt_get_inherited_state): New.\n\t(taint_state_machine::on_stmt): In assignment handling, remove\n\tARRAY_REF handling in favor of check_region_for_taint.  Add\n\tdetection of tainted divisors.\n\t(taint_state_machine::get_taint): New.\n\t(taint_state_machine::combine_states): New.\n\t(region_model::check_region_for_taint): New.\n\t(region_model::check_dynamic_size_for_taint): New.\n\t* sm.h (state_machine::alt_get_inherited_state): New.\n\ngcc/ChangeLog:\n\t* doc/invoke.texi (Static Analyzer Options): Add\n\t-Wno-analyzer-tainted-allocation-size,\n\t-Wno-analyzer-tainted-divisor, -Wno-analyzer-tainted-offset, and\n\t-Wno-analyzer-tainted-size to list.  Add\n\t-Wanalyzer-tainted-allocation-size, -Wanalyzer-tainted-divisor,\n\t-Wanalyzer-tainted-offset, and -Wanalyzer-tainted-size to list\n\tof options effectively enabled by -fanalyzer.\n\t(-Wanalyzer-tainted-allocation-size): New.\n\t(-Wanalyzer-tainted-array-index): Tweak wording; add link to CWE.\n\t(-Wanalyzer-tainted-divisor): New.\n\t(-Wanalyzer-tainted-offset): New.\n\t(-Wanalyzer-tainted-size): New.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/analyzer/pr93382.c: Tweak expected wording.\n\t* gcc.dg/analyzer/taint-alloc-1.c: New test.\n\t* gcc.dg/analyzer/taint-alloc-2.c: New test.\n\t* gcc.dg/analyzer/taint-divisor-1.c: New test.\n\t* gcc.dg/analyzer/taint-1.c: Rename to...\n\t* gcc.dg/analyzer/taint-read-index-1.c: ...this.  Tweak expected\n\twording.  Mark some events as xfail.\n\t* gcc.dg/analyzer/taint-read-offset-1.c: New test.\n\t* gcc.dg/analyzer/taint-size-1.c: New test.\n\t* gcc.dg/analyzer/taint-write-index-1.c: New test.\n\t* gcc.dg/analyzer/taint-write-offset-1.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "3cc3fcc1a454a25b03b7bd62dcfb6d5e9add0058", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3cc3fcc1a454a25b03b7bd62dcfb6d5e9add0058"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9365b93212041f14a7f71ba8da5af4d82240dc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9365b93212041f14a7f71ba8da5af4d82240dc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9365b93212041f14a7f71ba8da5af4d82240dc6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9365b93212041f14a7f71ba8da5af4d82240dc6/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2dd12ab66d14ac76a92b4538af81f8361132ba0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2dd12ab66d14ac76a92b4538af81f8361132ba0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2dd12ab66d14ac76a92b4538af81f8361132ba0"}], "stats": {"total": 1615, "additions": 1492, "deletions": 123}, "files": [{"sha": "c85e30f8b116ee68893ca1de4be22fe93ff600fd", "filename": "gcc/analyzer/analyzer.opt", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Fanalyzer%2Fanalyzer.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Fanalyzer%2Fanalyzer.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.opt?ref=b9365b93212041f14a7f71ba8da5af4d82240dc6", "patch": "@@ -114,10 +114,26 @@ Wanalyzer-stale-setjmp-buffer\n Common Var(warn_analyzer_stale_setjmp_buffer) Init(1) Warning\n Warn about code paths in which a longjmp rewinds to a jmp_buf saved in a stack frame that has returned.\n \n+Wanalyzer-tainted-allocation-size\n+Common Var(warn_analyzer_tainted_allocation_size) Init(1) Warning\n+Warn about code paths in which an unsanitized value is used as an allocation size.\n+\n Wanalyzer-tainted-array-index\n Common Var(warn_analyzer_tainted_array_index) Init(1) Warning\n Warn about code paths in which an unsanitized value is used as an array index.\n \n+Wanalyzer-tainted-divisor\n+Common Var(warn_analyzer_tainted_divisor) Init(1) Warning\n+Warn about code paths in which an unsanitized value is used as a divisor.\n+\n+Wanalyzer-tainted-offset\n+Common Var(warn_analyzer_tainted_offset) Init(1) Warning\n+Warn about code paths in which an unsanitized value is used as a pointer offset.\n+\n+Wanalyzer-tainted-size\n+Common Var(warn_analyzer_tainted_size) Init(1) Warning\n+Warn about code paths in which an unsanitized value is used as a size.\n+\n Wanalyzer-use-after-free\n Common Var(warn_analyzer_use_after_free) Init(1) Warning\n Warn about code paths in which a freed value is used."}, {"sha": "096e219392da0852b6d0a2b0ee70638880091c42", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=b9365b93212041f14a7f71ba8da5af4d82240dc6", "patch": "@@ -220,6 +220,24 @@ impl_region_model_context::get_malloc_map (sm_state_map **out_smap,\n   return true;\n }\n \n+bool\n+impl_region_model_context::get_taint_map (sm_state_map **out_smap,\n+\t\t\t\t\t  const state_machine **out_sm,\n+\t\t\t\t\t  unsigned *out_sm_idx)\n+{\n+  if (!m_new_state)\n+    return false;\n+\n+  unsigned taint_sm_idx;\n+  if (!m_ext_state.get_sm_idx_by_name (\"taint\", &taint_sm_idx))\n+    return false;\n+\n+  *out_smap = m_new_state->m_checker_states[taint_sm_idx];\n+  *out_sm = &m_ext_state.get_sm (taint_sm_idx);\n+  *out_sm_idx = taint_sm_idx;\n+  return true;\n+}\n+\n /* struct setjmp_record.  */\n \n int"}, {"sha": "9b18b48799948c18f67bfcc6e0d672f3ecad543e", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=b9365b93212041f14a7f71ba8da5af4d82240dc6", "patch": "@@ -86,6 +86,9 @@ class impl_region_model_context : public region_model_context\n   bool get_malloc_map (sm_state_map **out_smap,\n \t\t       const state_machine **out_sm,\n \t\t       unsigned *out_sm_idx) FINAL OVERRIDE;\n+  bool get_taint_map (sm_state_map **out_smap,\n+\t\t       const state_machine **out_sm,\n+\t\t       unsigned *out_sm_idx) FINAL OVERRIDE;\n \n   exploded_graph *m_eg;\n   log_user m_logger;"}, {"sha": "1c87af0f00b1f7104db17131929025a4232dc9a5", "filename": "gcc/analyzer/program-state.cc", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=b9365b93212041f14a7f71ba8da5af4d82240dc6", "patch": "@@ -420,6 +420,10 @@ sm_state_map::get_state (const svalue *sval,\n \t  }\n       }\n \n+  if (state_machine::state_t state\n+      = m_sm.alt_get_inherited_state (*this, sval, ext_state))\n+    return state;\n+\n   return m_sm.get_default_state (sval);\n }\n \n@@ -495,6 +499,18 @@ sm_state_map::impl_set_state (const svalue *sval,\n \n   gcc_assert (sval->can_have_associated_state_p ());\n \n+  if (m_sm.inherited_state_p ())\n+    {\n+      if (const compound_svalue *compound_sval\n+\t    = sval->dyn_cast_compound_svalue ())\n+\tfor (auto iter : *compound_sval)\n+\t  {\n+\t    const svalue *inner_sval = iter.second;\n+\t    if (inner_sval->can_have_associated_state_p ())\n+\t      impl_set_state (inner_sval, state, origin, ext_state);\n+\t  }\n+    }\n+\n   /* Special-case state 0 as the default value.  */\n   if (state == 0)\n     {\n@@ -1384,6 +1400,10 @@ program_state::impl_call_analyzer_dump_state (const gcall *call,\n \n   const svalue *sval = cd.get_arg_svalue (1);\n \n+  /* Strip off cast to int (due to variadic args).  */\n+  if (const svalue *cast = sval->maybe_undo_cast ())\n+    sval = cast;\n+\n   state_machine::state_t state = smap->get_state (sval, ext_state);\n   warning_at (call->location, 0, \"state: %qs\", state->get_name ());\n }\n@@ -1543,7 +1563,8 @@ test_program_state_1 ()\n   region_model *model = s.m_region_model;\n   const svalue *size_in_bytes\n     = mgr->get_or_create_unknown_svalue (size_type_node);\n-  const region *new_reg = model->create_region_for_heap_alloc (size_in_bytes);\n+  const region *new_reg\n+    = model->create_region_for_heap_alloc (size_in_bytes, NULL);\n   const svalue *ptr_sval = mgr->get_ptr_svalue (ptr_type_node, new_reg);\n   model->set_value (model->get_lvalue (p, NULL),\n \t\t    ptr_sval, NULL);\n@@ -1599,7 +1620,8 @@ test_program_state_merging ()\n   region_model *model0 = s0.m_region_model;\n   const svalue *size_in_bytes\n     = mgr->get_or_create_unknown_svalue (size_type_node);\n-  const region *new_reg = model0->create_region_for_heap_alloc (size_in_bytes);\n+  const region *new_reg\n+    = model0->create_region_for_heap_alloc (size_in_bytes, NULL);\n   const svalue *ptr_sval = mgr->get_ptr_svalue (ptr_type_node, new_reg);\n   model0->set_value (model0->get_lvalue (p, &ctxt),\n \t\t     ptr_sval, &ctxt);"}, {"sha": "90d4cf9c2db9d9919707e2f68523f1906e932156", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=b9365b93212041f14a7f71ba8da5af4d82240dc6", "patch": "@@ -221,7 +221,7 @@ void\n region_model::impl_call_alloca (const call_details &cd)\n {\n   const svalue *size_sval = cd.get_arg_svalue (0);\n-  const region *new_reg = create_region_for_alloca (size_sval);\n+  const region *new_reg = create_region_for_alloca (size_sval, cd.get_ctxt ());\n   const svalue *ptr_sval\n     = m_mgr->get_ptr_svalue (cd.get_lhs_type (), new_reg);\n   cd.maybe_set_lhs (ptr_sval);\n@@ -302,7 +302,8 @@ region_model::impl_call_calloc (const call_details &cd)\n   const svalue *prod_sval\n     = m_mgr->get_or_create_binop (size_type_node, MULT_EXPR,\n \t\t\t\t  nmemb_sval, size_sval);\n-  const region *new_reg = create_region_for_heap_alloc (prod_sval);\n+  const region *new_reg\n+    = create_region_for_heap_alloc (prod_sval, cd.get_ctxt ());\n   zero_fill_region (new_reg);\n   if (cd.get_lhs_type ())\n     {\n@@ -408,7 +409,8 @@ void\n region_model::impl_call_malloc (const call_details &cd)\n {\n   const svalue *size_sval = cd.get_arg_svalue (0);\n-  const region *new_reg = create_region_for_heap_alloc (size_sval);\n+  const region *new_reg\n+    = create_region_for_heap_alloc (size_sval, cd.get_ctxt ());\n   if (cd.get_lhs_type ())\n     {\n       const svalue *ptr_sval\n@@ -471,7 +473,8 @@ void\n region_model::impl_call_operator_new (const call_details &cd)\n {\n   const svalue *size_sval = cd.get_arg_svalue (0);\n-  const region *new_reg = create_region_for_heap_alloc (size_sval);\n+  const region *new_reg\n+    = create_region_for_heap_alloc (size_sval, cd.get_ctxt ());\n   if (cd.get_lhs_type ())\n     {\n       const svalue *ptr_sval\n@@ -579,7 +582,7 @@ region_model::impl_call_realloc (const call_details &cd)\n       const svalue *size_sval = cd.get_arg_svalue (1);\n       if (const region *buffer_reg = ptr_sval->maybe_get_region ())\n \tif (compat_types_p (size_sval->get_type (), size_type_node))\n-\t  model->set_dynamic_extents (buffer_reg, size_sval);\n+\t  model->set_dynamic_extents (buffer_reg, size_sval, ctxt);\n       if (cd.get_lhs_region ())\n \t{\n \t  model->set_value (cd.get_lhs_region (), ptr_sval, cd.get_ctxt ());\n@@ -619,7 +622,7 @@ region_model::impl_call_realloc (const call_details &cd)\n \n       /* Create the new region.  */\n       const region *new_reg\n-\t= model->create_region_for_heap_alloc (new_size_sval);\n+\t= model->create_region_for_heap_alloc (new_size_sval, ctxt);\n       const svalue *new_ptr_sval\n \t= model->m_mgr->get_ptr_svalue (cd.get_lhs_type (), new_reg);\n       if (cd.get_lhs_type ())"}, {"sha": "416a5ac72491c621665a3522746578970bb795e8", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=b9365b93212041f14a7f71ba8da5af4d82240dc6", "patch": "@@ -2301,6 +2301,8 @@ region_model::check_region_access (const region *reg,\n   if (!ctxt)\n     return;\n \n+  check_region_for_taint (reg, dir, ctxt);\n+\n   switch (dir)\n     {\n     default:\n@@ -2862,6 +2864,17 @@ region_model::get_representative_path_var_1 (const svalue *sval,\n \t\t\t   parent_pv.m_stack_depth);\n     }\n \n+  /* Handle binops.  */\n+  if (const binop_svalue *binop_sval = sval->dyn_cast_binop_svalue ())\n+    if (path_var lhs_pv\n+\t= get_representative_path_var (binop_sval->get_arg0 (), visited))\n+      if (path_var rhs_pv\n+\t  = get_representative_path_var (binop_sval->get_arg1 (), visited))\n+\treturn path_var (build2 (binop_sval->get_op (),\n+\t\t\t\t sval->get_type (),\n+\t\t\t\t lhs_pv.m_tree, rhs_pv.m_tree),\n+\t\t\t lhs_pv.m_stack_depth);\n+\n   if (pvs.length () < 1)\n     return path_var (NULL_TREE, 0);\n \n@@ -3720,36 +3733,45 @@ region_model::append_ssa_names_cb (const region *base_reg,\n     }\n }\n \n-/* Return a new region describing a heap-allocated block of memory.  */\n+/* Return a new region describing a heap-allocated block of memory.\n+   Use CTXT to complain about tainted sizes.  */\n \n const region *\n-region_model::create_region_for_heap_alloc (const svalue *size_in_bytes)\n+region_model::create_region_for_heap_alloc (const svalue *size_in_bytes,\n+\t\t\t\t\t    region_model_context *ctxt)\n {\n   const region *reg = m_mgr->create_region_for_heap_alloc ();\n   if (compat_types_p (size_in_bytes->get_type (), size_type_node))\n-    set_dynamic_extents (reg, size_in_bytes);\n+    set_dynamic_extents (reg, size_in_bytes, ctxt);\n   return reg;\n }\n \n /* Return a new region describing a block of memory allocated within the\n-   current frame.  */\n+   current frame.\n+   Use CTXT to complain about tainted sizes.  */\n \n const region *\n-region_model::create_region_for_alloca (const svalue *size_in_bytes)\n+region_model::create_region_for_alloca (const svalue *size_in_bytes,\n+\t\t\t\t\tregion_model_context *ctxt)\n {\n   const region *reg = m_mgr->create_region_for_alloca (m_current_frame);\n   if (compat_types_p (size_in_bytes->get_type (), size_type_node))\n-    set_dynamic_extents (reg, size_in_bytes);\n+    set_dynamic_extents (reg, size_in_bytes, ctxt);\n   return reg;\n }\n \n-/* Record that the size of REG is SIZE_IN_BYTES.  */\n+/* Record that the size of REG is SIZE_IN_BYTES.\n+   Use CTXT to complain about tainted sizes.  */\n \n void\n region_model::set_dynamic_extents (const region *reg,\n-\t\t\t\t   const svalue *size_in_bytes)\n+\t\t\t\t   const svalue *size_in_bytes,\n+\t\t\t\t   region_model_context *ctxt)\n {\n   assert_compat_types (size_in_bytes->get_type (), size_type_node);\n+  if (ctxt)\n+    check_dynamic_size_for_taint (reg->get_memory_space (), size_in_bytes,\n+\t\t\t\t  ctxt);\n   m_dynamic_extents.put (reg, size_in_bytes);\n }\n \n@@ -5096,7 +5118,8 @@ test_state_merging ()\n     region_model model0 (&mgr);\n     tree size = build_int_cst (size_type_node, 1024);\n     const svalue *size_sval = mgr.get_or_create_constant_svalue (size);\n-    const region *new_reg = model0.create_region_for_heap_alloc (size_sval);\n+    const region *new_reg\n+      = model0.create_region_for_heap_alloc (size_sval, &ctxt);\n     const svalue *ptr_sval = mgr.get_ptr_svalue (ptr_type_node, new_reg);\n     model0.set_value (model0.get_lvalue (p, &ctxt),\n \t\t      ptr_sval, &ctxt);\n@@ -5484,7 +5507,7 @@ test_malloc_constraints ()\n \n   const svalue *size_in_bytes\n     = mgr.get_or_create_unknown_svalue (size_type_node);\n-  const region *reg = model.create_region_for_heap_alloc (size_in_bytes);\n+  const region *reg = model.create_region_for_heap_alloc (size_in_bytes, NULL);\n   const svalue *sval = mgr.get_ptr_svalue (ptr_type_node, reg);\n   model.set_value (model.get_lvalue (p, NULL), sval, NULL);\n   model.set_value (q, p, NULL);\n@@ -5705,7 +5728,7 @@ test_malloc ()\n \n   /* \"p = malloc (n * 4);\".  */\n   const svalue *size_sval = model.get_rvalue (n_times_4, &ctxt);\n-  const region *reg = model.create_region_for_heap_alloc (size_sval);\n+  const region *reg = model.create_region_for_heap_alloc (size_sval, &ctxt);\n   const svalue *ptr = mgr.get_ptr_svalue (int_star, reg);\n   model.set_value (model.get_lvalue (p, &ctxt), ptr, &ctxt);\n   ASSERT_EQ (model.get_capacity (reg), size_sval);\n@@ -5739,7 +5762,7 @@ test_alloca ()\n \t\t\tNULL, &ctxt);\n   /* \"p = alloca (n * 4);\".  */\n   const svalue *size_sval = model.get_rvalue (n_times_4, &ctxt);\n-  const region *reg = model.create_region_for_alloca (size_sval);\n+  const region *reg = model.create_region_for_alloca (size_sval, &ctxt);\n   ASSERT_EQ (reg->get_parent_region (), frame_reg);\n   const svalue *ptr = mgr.get_ptr_svalue (int_star, reg);\n   model.set_value (model.get_lvalue (p, &ctxt), ptr, &ctxt);"}, {"sha": "13e8109aa511b6a8a6751c572903684e774c3b32", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=b9365b93212041f14a7f71ba8da5af4d82240dc6", "patch": "@@ -676,8 +676,10 @@ class region_model\n \t\t       region_model_context *ctxt,\n \t\t       rejected_constraint **out);\n \n-  const region *create_region_for_heap_alloc (const svalue *size_in_bytes);\n-  const region *create_region_for_alloca (const svalue *size_in_bytes);\n+  const region *create_region_for_heap_alloc (const svalue *size_in_bytes,\n+\t\t\t\t\t      region_model_context *ctxt);\n+  const region *create_region_for_alloca (const svalue *size_in_bytes,\n+\t\t\t\t\t  region_model_context *ctxt);\n \n   tree get_representative_tree (const svalue *sval) const;\n   path_var\n@@ -703,7 +705,8 @@ class region_model\n   }\n   const svalue *get_dynamic_extents (const region *reg) const;\n   void set_dynamic_extents (const region *reg,\n-\t\t\t    const svalue *size_in_bytes);\n+\t\t\t    const svalue *size_in_bytes,\n+\t\t\t    region_model_context *ctxt);\n   void unset_dynamic_extents (const region *reg);\n \n   region_model_manager *get_manager () const { return m_mgr; }\n@@ -792,6 +795,14 @@ class region_model\n \t\t\t\t  tree expr,\n \t\t\t\t  region_model_context *ctxt) const;\n \n+  void check_dynamic_size_for_taint (enum memory_space mem_space,\n+\t\t\t\t     const svalue *size_in_bytes,\n+\t\t\t\t     region_model_context *ctxt) const;\n+\n+  void check_region_for_taint (const region *reg,\n+\t\t\t       enum access_direction dir,\n+\t\t\t       region_model_context *ctxt) const;\n+\n   void check_for_writable_region (const region* dest_reg,\n \t\t\t\t  region_model_context *ctxt) const;\n   void check_region_access (const region *reg,\n@@ -891,6 +902,10 @@ class region_model_context\n   virtual bool get_malloc_map (sm_state_map **out_smap,\n \t\t\t       const state_machine **out_sm,\n \t\t\t       unsigned *out_sm_idx) = 0;\n+  /* Likewise for the \"taint\" state machine.  */\n+  virtual bool get_taint_map (sm_state_map **out_smap,\n+\t\t\t      const state_machine **out_sm,\n+\t\t\t      unsigned *out_sm_idx) = 0;\n };\n \n /* A \"do nothing\" subclass of region_model_context.  */\n@@ -935,6 +950,12 @@ class noop_region_model_context : public region_model_context\n   {\n     return false;\n   }\n+  bool get_taint_map (sm_state_map **,\n+\t\t      const state_machine **,\n+\t\t      unsigned *) OVERRIDE\n+  {\n+    return false;\n+  }\n };\n \n /* A subclass of region_model_context for determining if operations fail"}, {"sha": "0a51a1fe2ea97026b08c8d19835fc6c6b7587043", "filename": "gcc/analyzer/sm-taint.cc", "status": "modified", "additions": 737, "deletions": 89, "changes": 826, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Fanalyzer%2Fsm-taint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Fanalyzer%2Fsm-taint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-taint.cc?ref=b9365b93212041f14a7f71ba8da5af4d82240dc6", "patch": "@@ -33,9 +33,21 @@ along with GCC; see the file COPYING3.  If not see\n #include \"function.h\"\n #include \"json.h\"\n #include \"analyzer/analyzer.h\"\n-#include \"diagnostic-event-id.h\"\n #include \"analyzer/analyzer-logging.h\"\n+#include \"gimple-iterator.h\"\n+#include \"tristate.h\"\n+#include \"selftest.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"cgraph.h\"\n+#include \"cfg.h\"\n+#include \"digraph.h\"\n+#include \"analyzer/supergraph.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/region-model.h\"\n #include \"analyzer/sm.h\"\n+#include \"analyzer/program-state.h\"\n #include \"analyzer/pending-diagnostic.h\"\n \n #if ENABLE_ANALYZER\n@@ -44,6 +56,20 @@ namespace ana {\n \n namespace {\n \n+/* An enum for describing tainted values.  */\n+\n+enum bounds\n+{\n+  /* This tainted value has no upper or lower bound.  */\n+  BOUNDS_NONE,\n+\n+  /* This tainted value has an upper bound but not lower bound.  */\n+  BOUNDS_UPPER,\n+\n+  /* This tainted value has a lower bound but no upper bound.  */\n+  BOUNDS_LOWER\n+};\n+\n /* An experimental state machine, for tracking \"taint\": unsanitized uses\n    of data potentially under an attacker's control.  */\n \n@@ -54,6 +80,11 @@ class taint_state_machine : public state_machine\n \n   bool inherited_state_p () const FINAL OVERRIDE { return true; }\n \n+  state_t alt_get_inherited_state (const sm_state_map &map,\n+\t\t\t\t   const svalue *sval,\n+\t\t\t\t   const extrinsic_state &ext_state)\n+    const FINAL OVERRIDE;\n+\n   bool on_stmt (sm_context *sm_ctxt,\n \t\tconst supernode *node,\n \t\tconst gimple *stmt) const FINAL OVERRIDE;\n@@ -67,6 +98,10 @@ class taint_state_machine : public state_machine\n \n   bool can_purge_p (state_t s) const FINAL OVERRIDE;\n \n+  bool get_taint (state_t s, tree type, enum bounds *out) const;\n+\n+  state_t combine_states (state_t s0, state_t s1) const;\n+\n   /* State for a \"tainted\" value: unsanitized data potentially under an\n      attacker's control.  */\n   state_t m_tainted;\n@@ -81,77 +116,263 @@ class taint_state_machine : public state_machine\n   state_t m_stop;\n };\n \n-enum bounds\n+/* Class for diagnostics relating to taint_state_machine.  */\n+\n+class taint_diagnostic : public pending_diagnostic\n {\n-  BOUNDS_NONE,\n-  BOUNDS_UPPER,\n-  BOUNDS_LOWER\n+public:\n+  taint_diagnostic (const taint_state_machine &sm, tree arg,\n+\t\t    enum bounds has_bounds)\n+  : m_sm (sm), m_arg (arg), m_has_bounds (has_bounds)\n+  {}\n+\n+  bool subclass_equal_p (const pending_diagnostic &base_other) const OVERRIDE\n+  {\n+    return same_tree_p (m_arg, ((const taint_diagnostic &)base_other).m_arg);\n+  }\n+\n+  label_text describe_state_change (const evdesc::state_change &change)\n+    FINAL OVERRIDE\n+  {\n+    if (change.m_new_state == m_sm.m_tainted)\n+      {\n+\tif (change.m_origin)\n+\t  return change.formatted_print (\"%qE has an unchecked value here\"\n+\t\t\t\t\t \" (from %qE)\",\n+\t\t\t\t\t change.m_expr, change.m_origin);\n+\telse\n+\t  return change.formatted_print (\"%qE gets an unchecked value here\",\n+\t\t\t\t\t change.m_expr);\n+      }\n+    else if (change.m_new_state == m_sm.m_has_lb)\n+      return change.formatted_print (\"%qE has its lower bound checked here\",\n+\t\t\t\t     change.m_expr);\n+    else if (change.m_new_state == m_sm.m_has_ub)\n+      return change.formatted_print (\"%qE has its upper bound checked here\",\n+\t\t\t\t     change.m_expr);\n+    return label_text ();\n+  }\n+protected:\n+  const taint_state_machine &m_sm;\n+  tree m_arg;\n+  enum bounds m_has_bounds;\n };\n \n-class tainted_array_index\n-  : public pending_diagnostic_subclass<tainted_array_index>\n+/* Concrete taint_diagnostic subclass for reporting attacker-controlled\n+   array index.  */\n+\n+class tainted_array_index : public taint_diagnostic\n {\n public:\n   tainted_array_index (const taint_state_machine &sm, tree arg,\n \t\t       enum bounds has_bounds)\n-  : m_sm (sm), m_arg (arg), m_has_bounds (has_bounds) {}\n+  : taint_diagnostic (sm, arg, has_bounds)\n+  {}\n \n   const char *get_kind () const FINAL OVERRIDE { return \"tainted_array_index\"; }\n \n-  bool operator== (const tainted_array_index &other) const\n-  {\n-    return same_tree_p (m_arg, other.m_arg);\n-  }\n-\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n     diagnostic_metadata m;\n+    /* CWE-129: \"Improper Validation of Array Index\".  */\n     m.add_cwe (129);\n     switch (m_has_bounds)\n       {\n       default:\n \tgcc_unreachable ();\n       case BOUNDS_NONE:\n \treturn warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_array_index,\n-\t\t\t     \"use of tainted value %qE in array lookup\"\n-\t\t\t     \" without bounds checking\",\n+\t\t\t     \"use of attacker-controlled value %qE\"\n+\t\t\t     \" in array lookup without bounds checking\",\n \t\t\t     m_arg);\n \tbreak;\n       case BOUNDS_UPPER:\n \treturn warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_array_index,\n-\t\t\t     \"use of tainted value %qE in array lookup\"\n-\t\t\t     \" without lower-bounds checking\",\n+\t\t\t     \"use of attacker-controlled value %qE\"\n+\t\t\t     \" in array lookup without checking for negative\",\n \t\t\t     m_arg);\n \tbreak;\n       case BOUNDS_LOWER:\n \treturn warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_array_index,\n-\t\t\t     \"use of tainted value %qE in array lookup\"\n-\t\t\t     \" without upper-bounds checking\",\n+\t\t\t     \"use of attacker-controlled value %qE\"\n+\t\t\t     \" in array lookup without upper-bounds checking\",\n \t\t\t     m_arg);\n \tbreak;\n       }\n   }\n \n-  label_text describe_state_change (const evdesc::state_change &change)\n-    FINAL OVERRIDE\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n   {\n-    if (change.m_new_state == m_sm.m_tainted)\n+    switch (m_has_bounds)\n       {\n-\tif (change.m_origin)\n-\t  return change.formatted_print (\"%qE has an unchecked value here\"\n-\t\t\t\t\t \" (from %qE)\",\n-\t\t\t\t\t change.m_expr, change.m_origin);\n-\telse\n-\t  return change.formatted_print (\"%qE gets an unchecked value here\",\n-\t\t\t\t\t change.m_expr);\n+      default:\n+\tgcc_unreachable ();\n+      case BOUNDS_NONE:\n+\treturn ev.formatted_print\n+\t  (\"use of attacker-controlled value %qE in array lookup\"\n+\t   \" without bounds checking\",\n+\t   m_arg);\n+      case BOUNDS_UPPER:\n+\treturn ev.formatted_print\n+\t  (\"use of attacker-controlled value %qE\"\n+\t   \" in array lookup without checking for negative\",\n+\t   m_arg);\n+      case BOUNDS_LOWER:\n+\treturn ev.formatted_print\n+\t  (\"use of attacker-controlled value %qE\"\n+\t   \" in array lookup without upper-bounds checking\",\n+\t   m_arg);\n+      }\n+  }\n+};\n+\n+/* Concrete taint_diagnostic subclass for reporting attacker-controlled\n+   pointer offset.  */\n+\n+class tainted_offset : public taint_diagnostic\n+{\n+public:\n+  tainted_offset (const taint_state_machine &sm, tree arg,\n+\t\t       enum bounds has_bounds)\n+  : taint_diagnostic (sm, arg, has_bounds)\n+  {}\n+\n+  const char *get_kind () const FINAL OVERRIDE { return \"tainted_offset\"; }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    diagnostic_metadata m;\n+    /* CWE-823: \"Use of Out-of-range Pointer Offset\".  */\n+    m.add_cwe (823);\n+    if (m_arg)\n+      switch (m_has_bounds)\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\tcase BOUNDS_NONE:\n+\t  return warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_offset,\n+\t\t\t       \"use of attacker-controlled value %qE as offset\"\n+\t\t\t       \" without bounds checking\",\n+\t\t\t       m_arg);\n+\t  break;\n+\tcase BOUNDS_UPPER:\n+\t  return warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_offset,\n+\t\t\t       \"use of attacker-controlled value %qE as offset\"\n+\t\t\t       \" without lower-bounds checking\",\n+\t\t\t       m_arg);\n+\t  break;\n+\tcase BOUNDS_LOWER:\n+\t  return warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_offset,\n+\t\t\t       \"use of attacker-controlled value %qE as offset\"\n+\t\t\t       \" without upper-bounds checking\",\n+\t\t\t       m_arg);\n+\t  break;\n+\t}\n+    else\n+      switch (m_has_bounds)\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\tcase BOUNDS_NONE:\n+\t  return warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_offset,\n+\t\t\t       \"use of attacker-controlled value as offset\"\n+\t\t\t       \" without bounds checking\");\n+\t  break;\n+\tcase BOUNDS_UPPER:\n+\t  return warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_offset,\n+\t\t\t       \"use of attacker-controlled value as offset\"\n+\t\t\t       \" without lower-bounds checking\");\n+\t  break;\n+\tcase BOUNDS_LOWER:\n+\t  return warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_offset,\n+\t\t\t       \"use of attacker-controlled value as offset\"\n+\t\t\t       \" without upper-bounds checking\");\n+\t  break;\n+\t}\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    if (m_arg)\n+      switch (m_has_bounds)\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\tcase BOUNDS_NONE:\n+\t  return ev.formatted_print (\"use of attacker-controlled value %qE\"\n+\t\t\t\t     \" as offset without bounds checking\",\n+\t\t\t\t     m_arg);\n+\tcase BOUNDS_UPPER:\n+\t  return ev.formatted_print (\"use of attacker-controlled value %qE\"\n+\t\t\t\t     \" as offset without lower-bounds checking\",\n+\t\t\t\t     m_arg);\n+\tcase BOUNDS_LOWER:\n+\t  return ev.formatted_print (\"use of attacker-controlled value %qE\"\n+\t\t\t\t     \" as offset without upper-bounds checking\",\n+\t\t\t\t     m_arg);\n+\t}\n+    else\n+      switch (m_has_bounds)\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\tcase BOUNDS_NONE:\n+\t  return ev.formatted_print (\"use of attacker-controlled value\"\n+\t\t\t\t     \" as offset without bounds checking\");\n+\tcase BOUNDS_UPPER:\n+\t  return ev.formatted_print (\"use of attacker-controlled value\"\n+\t\t\t\t     \" as offset without lower-bounds\"\n+\t\t\t\t     \" checking\");\n+\tcase BOUNDS_LOWER:\n+\t  return ev.formatted_print (\"use of attacker-controlled value\"\n+\t\t\t\t     \" as offset without upper-bounds\"\n+\t\t\t\t     \" checking\");\n+\t}\n+  }\n+};\n+\n+/* Concrete taint_diagnostic subclass for reporting attacker-controlled\n+   size.  */\n+\n+class tainted_size : public taint_diagnostic\n+{\n+public:\n+  tainted_size (const taint_state_machine &sm, tree arg,\n+\t\tenum bounds has_bounds,\n+\t\tenum access_direction dir)\n+  : taint_diagnostic (sm, arg, has_bounds),\n+    m_dir (dir)\n+  {}\n+\n+  const char *get_kind () const FINAL OVERRIDE { return \"tainted_size\"; }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    diagnostic_metadata m;\n+    m.add_cwe (129);\n+    switch (m_has_bounds)\n+      {\n+      default:\n+\tgcc_unreachable ();\n+      case BOUNDS_NONE:\n+\treturn warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_size,\n+\t\t\t     \"use of attacker-controlled value %qE as size\"\n+\t\t\t     \" without bounds checking\",\n+\t\t\t     m_arg);\n+\tbreak;\n+      case BOUNDS_UPPER:\n+\treturn warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_size,\n+\t\t\t     \"use of attacker-controlled value %qE as size\"\n+\t\t\t     \" without lower-bounds checking\",\n+\t\t\t     m_arg);\n+\tbreak;\n+      case BOUNDS_LOWER:\n+\treturn warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_size,\n+\t\t\t     \"use of attacker-controlled value %qE as size\"\n+\t\t\t     \" without upper-bounds checking\",\n+\t\t\t     m_arg);\n+\tbreak;\n       }\n-    else if (change.m_new_state == m_sm.m_has_lb)\n-      return change.formatted_print (\"%qE has its lower bound checked here\",\n-\t\t\t\t     change.m_expr);\n-    else if (change.m_new_state == m_sm.m_has_ub)\n-      return change.formatted_print (\"%qE has its upper bound checked here\",\n-\t\t\t\t     change.m_expr);\n-    return label_text ();\n   }\n \n   label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n@@ -161,24 +382,194 @@ class tainted_array_index\n       default:\n \tgcc_unreachable ();\n       case BOUNDS_NONE:\n-\treturn ev.formatted_print (\"use of tainted value %qE in array lookup\"\n-\t\t\t\t   \" without bounds checking\",\n+\treturn ev.formatted_print (\"use of attacker-controlled value %qE\"\n+\t\t\t\t   \" as size without bounds checking\",\n \t\t\t\t   m_arg);\n       case BOUNDS_UPPER:\n-\treturn ev.formatted_print (\"use of tainted value %qE in array lookup\"\n-\t\t\t\t   \" without lower-bounds checking\",\n+\treturn ev.formatted_print (\"use of attacker-controlled value %qE\"\n+\t\t\t\t   \" as size without lower-bounds checking\",\n \t\t\t\t   m_arg);\n       case BOUNDS_LOWER:\n-\treturn ev.formatted_print (\"use of tainted value %qE in array lookup\"\n-\t\t\t\t   \" without upper-bounds checking\",\n+\treturn ev.formatted_print (\"use of attacker-controlled value %qE\"\n+\t\t\t\t   \" as size without upper-bounds checking\",\n \t\t\t\t   m_arg);\n       }\n   }\n \n private:\n-  const taint_state_machine &m_sm;\n-  tree m_arg;\n-  enum bounds m_has_bounds;\n+  enum access_direction m_dir;\n+};\n+\n+/* Concrete taint_diagnostic subclass for reporting attacker-controlled\n+   divisor (so that an attacker can trigger a divide by zero).  */\n+\n+class tainted_divisor : public taint_diagnostic\n+{\n+public:\n+  tainted_divisor (const taint_state_machine &sm, tree arg,\n+\t\t   enum bounds has_bounds)\n+  : taint_diagnostic (sm, arg, has_bounds)\n+  {}\n+\n+  const char *get_kind () const FINAL OVERRIDE { return \"tainted_divisor\"; }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    diagnostic_metadata m;\n+    /* CWE-369: \"Divide By Zero\".  */\n+    m.add_cwe (369);\n+    if (m_arg)\n+      return warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_divisor,\n+\t\t\t   \"use of attacker-controlled value %qE as divisor\"\n+\t\t\t   \" without checking for zero\",\n+\t\t\t   m_arg);\n+    else\n+      return warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_divisor,\n+\t\t\t   \"use of attacker-controlled value as divisor\"\n+\t\t\t   \" without checking for zero\");\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    if (m_arg)\n+      return ev.formatted_print\n+\t(\"use of attacker-controlled value %qE as divisor\"\n+\t \" without checking for zero\",\n+\t m_arg);\n+    else\n+      return ev.formatted_print\n+\t(\"use of attacker-controlled value as divisor\"\n+\t \" without checking for zero\");\n+  }\n+};\n+\n+/* Concrete taint_diagnostic subclass for reporting attacker-controlled\n+   size of a dynamic allocation.  */\n+\n+class tainted_allocation_size : public taint_diagnostic\n+{\n+public:\n+  tainted_allocation_size (const taint_state_machine &sm, tree arg,\n+\t\t\t   enum bounds has_bounds, enum memory_space mem_space)\n+  : taint_diagnostic (sm, arg, has_bounds),\n+    m_mem_space (mem_space)\n+  {\n+    gcc_assert (mem_space == MEMSPACE_STACK || mem_space == MEMSPACE_HEAP);\n+  }\n+\n+  const char *get_kind () const FINAL OVERRIDE\n+  {\n+    return \"tainted_allocation_size\";\n+  }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    diagnostic_metadata m;\n+    /* \"CWE-789: Memory Allocation with Excessive Size Value\".  */\n+    m.add_cwe (789);\n+    gcc_assert (m_mem_space == MEMSPACE_STACK || m_mem_space == MEMSPACE_HEAP);\n+    // TODO: make use of m_mem_space\n+    if (m_arg)\n+      switch (m_has_bounds)\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\tcase BOUNDS_NONE:\n+\t  return warning_meta (rich_loc, m,\n+\t\t\t       OPT_Wanalyzer_tainted_allocation_size,\n+\t\t\t       \"use of attacker-controlled value %qE as\"\n+\t\t\t       \" allocation size without bounds checking\",\n+\t\t\t       m_arg);\n+\t  break;\n+\tcase BOUNDS_UPPER:\n+\t  return warning_meta (rich_loc, m,\n+\t\t\t       OPT_Wanalyzer_tainted_allocation_size,\n+\t\t\t       \"use of attacker-controlled value %qE as\"\n+\t\t\t       \" allocation size without lower-bounds checking\",\n+\t\t\t       m_arg);\n+\t  break;\n+\tcase BOUNDS_LOWER:\n+\t  return warning_meta (rich_loc, m,\n+\t\t\t       OPT_Wanalyzer_tainted_allocation_size,\n+\t\t\t       \"use of attacker-controlled value %qE as\"\n+\t\t\t       \" allocation size without upper-bounds checking\",\n+\t\t\t     m_arg);\n+\t  break;\n+\t}\n+    else\n+      switch (m_has_bounds)\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\tcase BOUNDS_NONE:\n+\t  return warning_meta (rich_loc, m,\n+\t\t\t       OPT_Wanalyzer_tainted_allocation_size,\n+\t\t\t       \"use of attacker-controlled value as\"\n+\t\t\t       \" allocation size without bounds\"\n+\t\t\t       \" checking\");\n+\t  break;\n+\tcase BOUNDS_UPPER:\n+\t  return warning_meta (rich_loc, m,\n+\t\t\t       OPT_Wanalyzer_tainted_allocation_size,\n+\t\t\t       \"use of attacker-controlled value as\"\n+\t\t\t       \" allocation size without lower-bounds\"\n+\t\t\t       \" checking\");\n+\t  break;\n+\tcase BOUNDS_LOWER:\n+\t  return warning_meta (rich_loc, m,\n+\t\t\t       OPT_Wanalyzer_tainted_allocation_size,\n+\t\t\t       \"use of attacker-controlled value as\"\n+\t\t\t       \" allocation size without upper-bounds\"\n+\t\t\t       \" checking\");\n+\t  break;\n+\t}\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    if (m_arg)\n+      switch (m_has_bounds)\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\tcase BOUNDS_NONE:\n+\t  return ev.formatted_print\n+\t    (\"use of attacker-controlled value %qE as allocation size\"\n+\t     \" without bounds checking\",\n+\t     m_arg);\n+\tcase BOUNDS_UPPER:\n+\t  return ev.formatted_print\n+\t    (\"use of attacker-controlled value %qE as allocation size\"\n+\t     \" without lower-bounds checking\",\n+\t     m_arg);\n+\tcase BOUNDS_LOWER:\n+\t  return ev.formatted_print\n+\t    (\"use of attacker-controlled value %qE as allocation size\"\n+\t     \" without upper-bounds checking\",\n+\t     m_arg);\n+\t}\n+    else\n+      switch (m_has_bounds)\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\tcase BOUNDS_NONE:\n+\t  return ev.formatted_print\n+\t    (\"use of attacker-controlled value as allocation size\"\n+\t     \" without bounds checking\");\n+\tcase BOUNDS_UPPER:\n+\t  return ev.formatted_print\n+\t    (\"use of attacker-controlled value as allocation size\"\n+\t     \" without lower-bounds checking\");\n+\tcase BOUNDS_LOWER:\n+\t  return ev.formatted_print\n+\t    (\"use of attacker-controlled value as allocation size\"\n+\t     \" without upper-bounds checking\");\n+\t}\n+  }\n+\n+private:\n+  enum memory_space m_mem_space;\n };\n \n /* taint_state_machine's ctor.  */\n@@ -192,6 +583,79 @@ taint_state_machine::taint_state_machine (logger *logger)\n   m_stop = add_state (\"stop\");\n }\n \n+state_machine::state_t\n+taint_state_machine::alt_get_inherited_state (const sm_state_map &map,\n+\t\t\t\t\t      const svalue *sval,\n+\t\t\t\t\t      const extrinsic_state &ext_state)\n+  const\n+{\n+  switch (sval->get_kind ())\n+    {\n+    default:\n+      break;\n+    case SK_UNARYOP:\n+      {\n+\tconst unaryop_svalue *unaryop_sval\n+\t  = as_a <const unaryop_svalue *> (sval);\n+\tenum tree_code op = unaryop_sval->get_op ();\n+\tconst svalue *arg = unaryop_sval->get_arg ();\n+\tswitch (op)\n+\t  {\n+\t  case NOP_EXPR:\n+\t    {\n+\t      state_t arg_state = map.get_state (arg, ext_state);\n+\t      return arg_state;\n+\t    }\n+\t  default:\n+\t    gcc_unreachable ();\n+\t    break;\n+\t  }\n+      }\n+      break;\n+    case SK_BINOP:\n+      {\n+\tconst binop_svalue *binop_sval = as_a <const binop_svalue *> (sval);\n+\tenum tree_code op = binop_sval->get_op ();\n+\tconst svalue *arg0 = binop_sval->get_arg0 ();\n+\tconst svalue *arg1 = binop_sval->get_arg1 ();\n+\tswitch (op)\n+\t  {\n+\t  default:\n+\t    break;\n+\t  case PLUS_EXPR:\n+\t  case MINUS_EXPR:\n+\t  case MULT_EXPR:\n+\t  case POINTER_PLUS_EXPR:\n+\t  case TRUNC_DIV_EXPR:\n+\t  case TRUNC_MOD_EXPR:\n+\t    {\n+\t      state_t arg0_state = map.get_state (arg0, ext_state);\n+\t      state_t arg1_state = map.get_state (arg1, ext_state);\n+\t      return combine_states (arg0_state, arg1_state);\n+\t    }\n+\t    break;\n+\n+\t  case EQ_EXPR:\n+\t  case GE_EXPR:\n+\t  case LE_EXPR:\n+\t  case NE_EXPR:\n+\t  case GT_EXPR:\n+\t  case LT_EXPR:\n+\t  case UNORDERED_EXPR:\n+\t  case ORDERED_EXPR:\n+\t    /* Comparisons are just booleans.  */\n+\t    return m_start;\n+\n+\t  case BIT_AND_EXPR:\n+\t  case RSHIFT_EXPR:\n+\t    return NULL;\n+\t  }\n+      }\n+      break;\n+    }\n+  return NULL;\n+}\n+\n /* Implementation of state_machine::on_stmt vfunc for taint_state_machine.  */\n \n bool\n@@ -220,53 +684,35 @@ taint_state_machine::on_stmt (sm_context *sm_ctxt,\n \n   if (const gassign *assign = dyn_cast <const gassign *> (stmt))\n     {\n-      tree rhs1 = gimple_assign_rhs1 (assign);\n       enum tree_code op = gimple_assign_rhs_code (assign);\n \n-      /* Check array accesses.  */\n-      if (op == ARRAY_REF)\n+      switch (op)\n \t{\n-\t  tree arg = TREE_OPERAND (rhs1, 1);\n-\n-\t  /* Unsigned types have an implicit lower bound.  */\n-\t  bool is_unsigned = false;\n-\t  if (INTEGRAL_TYPE_P (TREE_TYPE (arg)))\n-\t    is_unsigned = TYPE_UNSIGNED (TREE_TYPE (arg));\n-\n-\t  state_t state = sm_ctxt->get_state (stmt, arg);\n-\t  /* Can't use a switch as the states are non-const.  */\n-\t  if (state == m_tainted)\n-\t    {\n-\t      /* Complain about missing bounds.  */\n-\t      tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n-\t      pending_diagnostic *d\n-\t\t= new tainted_array_index (*this, diag_arg,\n-\t\t\t\t\t   is_unsigned\n-\t\t\t\t\t   ? BOUNDS_LOWER : BOUNDS_NONE);\n-\t      sm_ctxt->warn (node, stmt, arg, d);\n-\t      sm_ctxt->set_next_state (stmt, arg, m_stop);\n-\t    }\n-\t  else if (state == m_has_lb)\n-\t    {\n-\t      /* Complain about missing upper bound.  */\n-\t      tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n-\t      sm_ctxt->warn (node, stmt, arg,\n-\t\t\t      new tainted_array_index (*this, diag_arg,\n-\t\t\t\t\t\t       BOUNDS_LOWER));\n-\t      sm_ctxt->set_next_state (stmt, arg, m_stop);\n-\t    }\n-\t  else if (state == m_has_ub)\n-\t    {\n-\t      /* Complain about missing lower bound.  */\n-\t      if (!is_unsigned)\n-\t\t{\n-\t\t  tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n-\t\t  sm_ctxt->warn  (node, stmt, arg,\n-\t\t\t\t  new tainted_array_index (*this, diag_arg,\n-\t\t\t\t\t\t\t   BOUNDS_UPPER));\n-\t\t  sm_ctxt->set_next_state (stmt, arg, m_stop);\n-\t\t}\n-\t    }\n+\tdefault:\n+\t  break;\n+\tcase TRUNC_DIV_EXPR:\n+\tcase CEIL_DIV_EXPR:\n+\tcase FLOOR_DIV_EXPR:\n+\tcase ROUND_DIV_EXPR:\n+\tcase TRUNC_MOD_EXPR:\n+\tcase CEIL_MOD_EXPR:\n+\tcase FLOOR_MOD_EXPR:\n+\tcase ROUND_MOD_EXPR:\n+\tcase RDIV_EXPR:\n+\tcase EXACT_DIV_EXPR:\n+\t  {\n+\t    tree divisor = gimple_assign_rhs2 (assign);;\n+\t    state_t state = sm_ctxt->get_state (stmt, divisor);\n+\t    enum bounds b;\n+\t    if (get_taint (state, TREE_TYPE (divisor), &b))\n+\t      {\n+\t\ttree diag_divisor = sm_ctxt->get_diagnostic_tree (divisor);\n+\t\tsm_ctxt->warn  (node, stmt, divisor,\n+\t\t\t\tnew tainted_divisor (*this, diag_divisor, b));\n+\t\tsm_ctxt->set_next_state (stmt, divisor, m_stop);\n+\t      }\n+\t  }\n+\t  break;\n \t}\n     }\n \n@@ -324,6 +770,62 @@ taint_state_machine::can_purge_p (state_t s ATTRIBUTE_UNUSED) const\n   return true;\n }\n \n+/* If STATE is a tainted state, write the bounds to *OUT and return true.\n+   Otherwise return false.\n+   Use the signedness of TYPE to determine if \"has_ub\" is tainted.  */\n+\n+bool\n+taint_state_machine::get_taint (state_t state, tree type,\n+\t\t\t\tenum bounds *out) const\n+{\n+  /* Unsigned types have an implicit lower bound.  */\n+  bool is_unsigned = false;\n+  if (type)\n+    if (INTEGRAL_TYPE_P (type))\n+      is_unsigned = TYPE_UNSIGNED (type);\n+\n+  /* Can't use a switch as the states are non-const.  */\n+  if (state == m_tainted)\n+    {\n+      *out = is_unsigned ? BOUNDS_LOWER : BOUNDS_NONE;\n+      return true;\n+    }\n+  else if (state == m_has_lb)\n+    {\n+      *out = BOUNDS_LOWER;\n+      return true;\n+    }\n+  else if (state == m_has_ub && !is_unsigned)\n+    {\n+      /* Missing lower bound.  */\n+      *out = BOUNDS_UPPER;\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Find the most tainted state of S0 and S1.  */\n+\n+state_machine::state_t\n+taint_state_machine::combine_states (state_t s0, state_t s1) const\n+{\n+  gcc_assert (s0);\n+  gcc_assert (s1);\n+  if (s0 == s1)\n+    return s0;\n+  if (s0 == m_tainted || s1 == m_tainted)\n+    return m_tainted;\n+  if (s0 == m_stop)\n+    return s1;\n+  if (s1 == m_stop)\n+    return s0;\n+  if (s0 == m_start)\n+    return s1;\n+  if (s1 == m_start)\n+    return s0;\n+  gcc_unreachable ();\n+}\n+\n } // anonymous namespace\n \n /* Internal interface to this file. */\n@@ -334,6 +836,152 @@ make_taint_state_machine (logger *logger)\n   return new taint_state_machine (logger);\n }\n \n+/* Complain to CTXT if accessing REG leads could lead to arbitrary\n+   memory access under an attacker's control (due to taint).  */\n+\n+void\n+region_model::check_region_for_taint (const region *reg,\n+\t\t\t\t      enum access_direction dir,\n+\t\t\t\t      region_model_context *ctxt) const\n+{\n+  gcc_assert (reg);\n+  gcc_assert (ctxt);\n+\n+  LOG_SCOPE (ctxt->get_logger ());\n+\n+  sm_state_map *smap;\n+  const state_machine *sm;\n+  unsigned sm_idx;\n+  if (!ctxt->get_taint_map (&smap, &sm, &sm_idx))\n+    return;\n+\n+  gcc_assert (smap);\n+  gcc_assert (sm);\n+\n+  const taint_state_machine &taint_sm = (const taint_state_machine &)*sm;\n+\n+  const extrinsic_state *ext_state = ctxt->get_ext_state ();\n+  if (!ext_state)\n+    return;\n+\n+  const region *iter_region = reg;\n+  while (iter_region)\n+    {\n+      switch (iter_region->get_kind ())\n+\t{\n+\tdefault:\n+\t  break;\n+\n+\tcase RK_ELEMENT:\n+\t  {\n+\t    const element_region *element_reg\n+\t      = (const element_region *)iter_region;\n+\t    const svalue *index = element_reg->get_index ();\n+\t    const state_machine::state_t\n+\t      state = smap->get_state (index, *ext_state);\n+\t    gcc_assert (state);\n+\t    enum bounds b;\n+\t    if (taint_sm.get_taint (state, index->get_type (), &b))\n+\t    {\n+\t      tree arg = get_representative_tree (index);\n+\t      ctxt->warn (new tainted_array_index (taint_sm, arg, b));\n+\t    }\n+\t  }\n+\t  break;\n+\n+\tcase RK_OFFSET:\n+\t  {\n+\t    const offset_region *offset_reg\n+\t      = (const offset_region *)iter_region;\n+\t    const svalue *offset = offset_reg->get_byte_offset ();\n+\t    const state_machine::state_t\n+\t      state = smap->get_state (offset, *ext_state);\n+\t    gcc_assert (state);\n+\t    /* Handle implicit cast to sizetype.  */\n+\t    tree effective_type = offset->get_type ();\n+\t    if (const svalue *cast = offset->maybe_undo_cast ())\n+\t      if (cast->get_type ())\n+\t\teffective_type = cast->get_type ();\n+\t    enum bounds b;\n+\t    if (taint_sm.get_taint (state, effective_type, &b))\n+\t      {\n+\t\ttree arg = get_representative_tree (offset);\n+\t\tctxt->warn (new tainted_offset (taint_sm, arg, b));\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase RK_CAST:\n+\t  {\n+\t    const cast_region *cast_reg\n+\t      = as_a <const cast_region *> (iter_region);\n+\t    iter_region = cast_reg->get_original_region ();\n+\t    continue;\n+\t  }\n+\n+\tcase RK_SIZED:\n+\t  {\n+\t    const sized_region *sized_reg\n+\t      = (const sized_region *)iter_region;\n+\t    const svalue *size_sval = sized_reg->get_byte_size_sval (m_mgr);\n+\t    const state_machine::state_t\n+\t      state = smap->get_state (size_sval, *ext_state);\n+\t    gcc_assert (state);\n+\t    enum bounds b;\n+\t    if (taint_sm.get_taint (state, size_sval->get_type (), &b))\n+\t      {\n+\t\ttree arg = get_representative_tree (size_sval);\n+\t\tctxt->warn (new tainted_size (taint_sm, arg, b, dir));\n+\t      }\n+\t  }\n+\t  break;\n+\t}\n+\n+      iter_region = iter_region->get_parent_region ();\n+    }\n+}\n+\n+/* Complain to CTXT about a tainted allocation size if SIZE_IN_BYTES is\n+   under an attacker's control (due to taint), where the allocation\n+   is happening within MEM_SPACE.  */\n+\n+void\n+region_model::check_dynamic_size_for_taint (enum memory_space mem_space,\n+\t\t\t\t\t    const svalue *size_in_bytes,\n+\t\t\t\t\t    region_model_context *ctxt) const\n+{\n+  gcc_assert (mem_space == MEMSPACE_STACK || mem_space == MEMSPACE_HEAP);\n+  gcc_assert (size_in_bytes);\n+  gcc_assert (ctxt);\n+\n+  LOG_SCOPE (ctxt->get_logger ());\n+\n+  sm_state_map *smap;\n+  const state_machine *sm;\n+  unsigned sm_idx;\n+  if (!ctxt->get_taint_map (&smap, &sm, &sm_idx))\n+    return;\n+\n+  gcc_assert (smap);\n+  gcc_assert (sm);\n+\n+  const taint_state_machine &taint_sm = (const taint_state_machine &)*sm;\n+\n+  const extrinsic_state *ext_state = ctxt->get_ext_state ();\n+  if (!ext_state)\n+    return;\n+\n+  const state_machine::state_t\n+    state = smap->get_state (size_in_bytes, *ext_state);\n+  gcc_assert (state);\n+  enum bounds b;\n+  if (taint_sm.get_taint (state, size_in_bytes->get_type (), &b))\n+    {\n+      tree arg = get_representative_tree (size_in_bytes);\n+      ctxt->warn (new tainted_allocation_size (taint_sm, arg, b, mem_space));\n+    }\n+}\n+\n } // namespace ana\n \n #endif /* #if ENABLE_ANALYZER */"}, {"sha": "b8570e8a1ac5ddc3638ac5a190c92a332d252280", "filename": "gcc/analyzer/sm.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Fanalyzer%2Fsm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Fanalyzer%2Fsm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.h?ref=b9365b93212041f14a7f71ba8da5af4d82240dc6", "patch": "@@ -69,6 +69,15 @@ class state_machine : public log_user\n      within a heap-allocated struct.  */\n   virtual bool inherited_state_p () const = 0;\n \n+  /* A vfunc for more general handling of inheritance.  */\n+  virtual state_t\n+  alt_get_inherited_state (const sm_state_map &,\n+\t\t\t   const svalue *,\n+\t\t\t   const extrinsic_state &) const\n+  {\n+    return NULL;\n+  }\n+\n   virtual state_machine::state_t get_default_state (const svalue *) const\n   {\n     return m_start;"}, {"sha": "99cdeb90c7cbc641e1bc4488dfb4b379865a18ec", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b9365b93212041f14a7f71ba8da5af4d82240dc6", "patch": "@@ -449,7 +449,11 @@ Objective-C and Objective-C++ Dialects}.\n -Wno-analyzer-shift-count-negative @gol\n -Wno-analyzer-shift-count-overflow @gol\n -Wno-analyzer-stale-setjmp-buffer @gol\n+-Wno-analyzer-tainted-allocation-size @gol\n -Wno-analyzer-tainted-array-index @gol\n+-Wno-analyzer-tainted-divisor @gol\n+-Wno-analyzer-tainted-offset @gol\n+-Wno-analyzer-tainted-size @gol\n -Wanalyzer-too-complex @gol\n -Wno-analyzer-unsafe-call-within-signal-handler @gol\n -Wno-analyzer-use-after-free @gol\n@@ -9400,7 +9404,11 @@ Enabling this option effectively enables the following warnings:\n -Wanalyzer-shift-count-negative @gol\n -Wanalyzer-shift-count-overflow @gol\n -Wanalyzer-stale-setjmp-buffer @gol\n+-Wanalyzer-tainted-allocation-size @gol\n -Wanalyzer-tainted-array-index @gol\n+-Wanalyzer-tainted-divisor @gol\n+-Wanalyzer-tainted-offset @gol\n+-Wanalyzer-tainted-size @gol\n -Wanalyzer-unsafe-call-within-signal-handler @gol\n -Wanalyzer-use-after-free @gol\n -Wanalyzer-use-of-uninitialized-value @gol\n@@ -9583,6 +9591,21 @@ when the function containing the @code{setjmp} call returns.  Attempting\n to rewind to it via @code{longjmp} would reference a stack frame that\n no longer exists, and likely lead to a crash (or worse).\n \n+@item -Wno-analyzer-tainted-allocation-size\n+@opindex Wanalyzer-tainted-allocation-size\n+@opindex Wno-analyzer-tainted-allocation-size\n+This warning requires both @option{-fanalyzer} and\n+@option{-fanalyzer-checker=taint} to enable it;\n+use @option{-Wno-analyzer-tainted-allocation-size} to disable it.\n+\n+This diagnostic warns for paths through the code in which a value\n+that could be under an attacker's control is used as the size\n+of an allocation without being sanitized, so that an attacker could\n+inject an excessively large allocation and potentially cause a denial\n+of service attack.\n+\n+See @url{https://cwe.mitre.org/data/definitions/789.html, CWE-789: Memory Allocation with Excessive Size Value}.\n+\n @item -Wno-analyzer-tainted-array-index\n @opindex Wanalyzer-tainted-array-index\n @opindex Wno-analyzer-tainted-array-index\n@@ -9592,7 +9615,48 @@ use @option{-Wno-analyzer-tainted-array-index} to disable it.\n \n This diagnostic warns for paths through the code in which a value\n that could be under an attacker's control is used as the index\n-of an array access without being sanitized.\n+of an array access without being sanitized, so that an attacker\n+could inject an out-of-bounds access.\n+\n+See @url{https://cwe.mitre.org/data/definitions/129.html, CWE-129: Improper Validation of Array Index}.\n+\n+@item -Wno-analyzer-tainted-divisor\n+@opindex Wanalyzer-tainted-divisor\n+@opindex Wno-analyzer-tainted-divisor\n+This warning requires both @option{-fanalyzer} and\n+@option{-fanalyzer-checker=taint} to enable it;\n+use @option{-Wno-analyzer-tainted-divisor} to disable it.\n+\n+This diagnostic warns for paths through the code in which a value\n+that could be under an attacker's control is used as the divisor\n+in a division or modulus operation without being sanitized, so that\n+an attacker could inject a division-by-zero.\n+\n+@item -Wno-analyzer-tainted-offset\n+@opindex Wanalyzer-tainted-offset\n+@opindex Wno-analyzer-tainted-offset\n+This warning requires both @option{-fanalyzer} and\n+@option{-fanalyzer-checker=taint} to enable it;\n+use @option{-Wno-analyzer-tainted-offset} to disable it.\n+\n+This diagnostic warns for paths through the code in which a value\n+that could be under an attacker's control is used as a pointer offset\n+without being sanitized, so that an attacker could inject an out-of-bounds\n+access.\n+\n+See @url{https://cwe.mitre.org/data/definitions/823.html, CWE-823: Use of Out-of-range Pointer Offset}.\n+\n+@item -Wno-analyzer-tainted-size\n+@opindex Wanalyzer-tainted-size\n+@opindex Wno-analyzer-tainted-size\n+This warning requires both @option{-fanalyzer} and\n+@option{-fanalyzer-checker=taint} to enable it;\n+use @option{-Wno-analyzer-tainted-size} to disable it.\n+\n+This diagnostic warns for paths through the code in which a value\n+that could be under an attacker's control is used as the size of\n+an operation such as @code{memset} without being sanitized, so that an\n+attacker could inject an out-of-bounds access.\n \n @item -Wno-analyzer-unsafe-call-within-signal-handler\n @opindex Wanalyzer-unsafe-call-within-signal-handler"}, {"sha": "1e6612ddc050e3787bd0fbab44aaa736f977b787", "filename": "gcc/testsuite/gcc.dg/analyzer/pr93382.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93382.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93382.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93382.c?ref=b9365b93212041f14a7f71ba8da5af4d82240dc6", "patch": "@@ -23,5 +23,5 @@ int\n pl (void)\n {\n   ql ();\n-  return arr[idx]; /* { dg-warning \"use of tainted value 'idx' in array lookup without bounds checking\" \"\" { xfail *-*-* } } */\n+  return arr[idx]; /* { dg-warning \"use of attacker-controlled value 'idx' in array lookup without bounds checking\" \"\" { xfail *-*-* } } */\n }"}, {"sha": "102aa4b9220391dc23842ed8d870da35a1af03c0", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-alloc-1.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-alloc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-alloc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-alloc-1.c?ref=b9365b93212041f14a7f71ba8da5af4d82240dc6", "patch": "@@ -0,0 +1,64 @@\n+// TODO: remove need for this option\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+#include \"analyzer-decls.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+struct foo\n+{\n+  size_t sz;\n+};\n+\n+/* malloc with tainted size.  */\n+\n+void *test_1 (FILE *f)\n+{\n+  struct foo tmp;\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) { /* { dg-message \"\\\\(\\[0-9\\]+\\\\) 'tmp' gets an unchecked value here\" \"event: tmp gets unchecked value\" { xfail *-*-* } } */\n+                                             /* { dg-message \"\\\\(\\[0-9\\]+\\\\) following 'true' branch\\\\.\\\\.\\\\.\" \"event: following true branch\" { target *-*-* } .-1 } */\n+    __analyzer_dump_state (\"taint\", tmp.sz); /* { dg-warning \"state: 'tainted'\" } */\n+    /* { dg-message \"\\\\(\\[0-9\\]+\\\\) \\\\.\\\\.\\\\.to here\" \"event: to here\" { target *-*-* } .-1 } */\n+    \n+    return malloc (tmp.sz); /* { dg-warning \"use of attacker-controlled value 'tmp\\\\.sz' as allocation size without upper-bounds checking\" \"warning\" } */\n+    /* { dg-message \"23: \\\\(\\[0-9\\]+\\\\) 'tmp.i' has an unchecked value here \\\\(from 'tmp'\\\\)\" \"event: tmp.i has an unchecked value\" { xfail *-*-* } .-1 } */\n+    /* { dg-message \"\\\\(\\[0-9\\]+\\\\) use of attacker-controlled value 'tmp\\\\.sz' as allocation size without upper-bounds checking\" \"final event\" { target *-*-* } .-2 } */\n+    \n+    // TOOD: better messages for state changes\n+  }\n+  return 0;\n+}\n+\n+/* VLA with tainted size.  */\n+\n+void *test_2 (FILE *f)\n+{\n+  struct foo tmp;\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) { /* { dg-message \"\\\\(\\[0-9\\]+\\\\) 'tmp' gets an unchecked value here\" \"event: tmp gets unchecked value\" { xfail *-*-* } } */\n+                                             /* { dg-message \"\\\\(\\[0-9\\]+\\\\) following 'true' branch\\\\.\\\\.\\\\.\" \"event: following true branch\" { target *-*-* } .-1 } */\n+    __analyzer_dump_state (\"taint\", tmp.sz); /* { dg-warning \"state: 'tainted'\" } */\n+    /* { dg-message \"\\\\(\\[0-9\\]+\\\\) \\\\.\\\\.\\\\.to here\" \"event: to here\" { target *-*-* } .-1 } */\n+\n+    /* VLA with tainted size.  */\n+    {\n+      char buf[tmp.sz]; /* { dg-warning \"use of attacker-controlled value 'tmp\\\\.sz' as allocation size without upper-bounds checking\" \"warning\" } */\n+      /* { dg-message \"\\\\(\\[0-9\\]+\\\\) 'tmp.i' has an unchecked value here \\\\(from 'tmp'\\\\)\" \"event: tmp.i has an unchecked value\" { xfail *-*-* } .-1 } */\n+      /* { dg-message \"\\\\(\\[0-9\\]+\\\\) use of attacker-controlled value 'tmp\\\\.sz' as allocation size without upper-bounds checking\" \"final event\" { target *-*-* } .-2 } */\n+      fread (buf, tmp.sz, 1, f);\n+    }\n+    \n+    // TOOD: better messages for state changes\n+  }\n+  return 0;\n+}\n+\n+void *test_3 (FILE *f)\n+{\n+  int num;\n+  fread (&num, sizeof (int), 1, f);\n+  __analyzer_dump_state (\"taint\", num); /* { dg-warning \"state: 'tainted'\" } */\n+  __analyzer_dump_state (\"taint\", num * 16); /* { dg-warning \"state: 'tainted'\" } */\n+  __analyzer_dump_state (\"taint\", (size_t)(num * 16)); /* { dg-warning \"state: 'tainted'\" } */\n+  return malloc (num * 16); /* { dg-warning \"use of attacker-controlled value 'num \\\\* 16' as allocation size without upper-bounds checking\" } */\n+}"}, {"sha": "72dbca5cbf085277c89687750146acbbef297a75", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-alloc-2.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-alloc-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-alloc-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-alloc-2.c?ref=b9365b93212041f14a7f71ba8da5af4d82240dc6", "patch": "@@ -0,0 +1,27 @@\n+// TODO: remove need for this option:\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+#include \"analyzer-decls.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+struct foo\n+{\n+  int num;\n+};\n+\n+/* malloc with tainted size from a field.  */\n+\n+void *test_1 (FILE *f)\n+{\n+  struct foo tmp;\n+  fread(&tmp, sizeof(tmp), 1, f); /* { dg-message \"\\\\(\\[0-9\\]+\\\\) 'tmp' gets an unchecked value here\" \"event: tmp gets unchecked value\" { xfail *-*-* } } */\n+\n+  __analyzer_dump_state (\"taint\", tmp.num); /* { dg-warning \"state: 'tainted'\" } */\n+  __analyzer_dump_state (\"taint\", tmp.num * 16); /* { dg-warning \"state: 'tainted'\" } */\n+\n+  return malloc (tmp.num * 16); /* { dg-warning \"use of attacker-controlled value 'tmp\\\\.num \\\\* 16' as allocation size without upper-bounds checking\" \"warning\" } */\n+  /* { dg-message \"\\\\(\\[0-9\\]+\\\\) use of attacker-controlled value 'tmp\\\\.num \\\\* 16' as allocation size without upper-bounds checking\" \"final event with expr\" { target *-*-* } .-1 } */\n+  // TODO: show where tmp.num * 16 gets the bogus value\n+}"}, {"sha": "5a5a0b93ce09ad72cb8843aa4137d29313b1488d", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-divisor-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-divisor-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-divisor-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-divisor-1.c?ref=b9365b93212041f14a7f71ba8da5af4d82240dc6", "patch": "@@ -0,0 +1,26 @@\n+// TODO: remove need for this option:\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+#include \"analyzer-decls.h\"\n+#include <stdio.h>\n+\n+struct st1\n+{\n+  int a;\n+  int b;\n+};\n+\n+\n+int test_1 (FILE *f)\n+{\n+  struct st1 s;\n+  fread (&s, sizeof (s), 1, f);\n+  return s.a / s.b;  /* { dg-warning \"use of attacker-controlled value 's\\\\.b' as divisor without checking for zero\" } */\n+}\n+\n+int test_2 (FILE *f)\n+{\n+  struct st1 s;\n+  fread (&s, sizeof (s), 1, f);\n+  return s.a % s.b;  /* { dg-warning \"use of attacker-controlled value 's\\\\.b' as divisor without checking for zero\" } */\n+}"}, {"sha": "71c0816fd1febe76c734ab1bb52ac66ef4a466ab", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-read-index-1.c", "status": "renamed", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-read-index-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-read-index-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-read-index-1.c?ref=b9365b93212041f14a7f71ba8da5af4d82240dc6", "patch": "@@ -1,3 +1,4 @@\n+// TODO: remove need for this option:\n /* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n \n #include <stdio.h>\n@@ -18,10 +19,10 @@ char test_1(FILE *f)\n                                              /* { dg-message \"\\\\(\\[0-9\\]+\\\\) following 'true' branch\\\\.\\\\.\\\\.\" \"event: following true branch\" { target *-*-* } .-1 } */\n     /* BUG: the following array lookup trusts that the input data's index is\n        in the range 0 <= i < 256; otherwise it's accessing the stack */\n-    return tmp.buf[tmp.i]; // { dg-warning \"use of tainted value 'tmp.i' in array lookup without bounds checking\" \"warning\" } */\n+    return tmp.buf[tmp.i]; // { dg-warning \"use of attacker-controlled value 'tmp.i' in array lookup without bounds checking\" \"warning\" } */\n     /* { dg-message \"23: \\\\(\\[0-9\\]+\\\\) \\\\.\\\\.\\\\.to here\" \"event: to here\" { target *-*-* } .-1 } */\n     /* { dg-message \"23: \\\\(\\[0-9\\]+\\\\) 'tmp.i' has an unchecked value here \\\\(from 'tmp'\\\\)\" \"event: tmp.i has an unchecked value\" { xfail *-*-* } .-2 } */\n-    /* { dg-message \"\\\\(\\[0-9\\]+\\\\) use of tainted value 'tmp.i' in array lookup without bounds checking\" \"final event\" { target *-*-* } .-3 } */\n+    /* { dg-message \"\\\\(\\[0-9\\]+\\\\) use of attacker-controlled value 'tmp.i' in array lookup without bounds checking\" \"final event\" { target *-*-* } .-3 } */\n     \n     // TOOD: better messages for state changes\n   }\n@@ -53,8 +54,8 @@ char test_4(FILE *f)\n \n   if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n     if (tmp.i >= 0) { /* { dg-message \"'tmp.i' has an unchecked value here \\\\(from 'tmp'\\\\)\" \"event: tmp.i has an unchecked value\" { xfail *-*-* } } */\n-      /* { dg-message \"'tmp.i' has its lower bound checked here\" \"event: lower bound checked\" { target *-*-* } .-1 } */\n-      return tmp.buf[tmp.i]; /* { dg-warning \"use of tainted value 'tmp.i' in array lookup without upper-bounds checking\" \"warning\" } */\n+      /* { dg-message \"'tmp.i' has its lower bound checked here\" \"event: lower bound checked\" { xfail *-*-* } .-1 } */\n+      return tmp.buf[tmp.i]; /* { dg-warning \"use of attacker-controlled value 'tmp.i' in array lookup without upper-bounds checking\" \"warning\" } */\n     }\n   }\n   return 0;\n@@ -66,8 +67,8 @@ char test_5(FILE *f)\n \n   if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n     if (tmp.i < 256) { /* { dg-message \"'tmp.i' has an unchecked value here \\\\(from 'tmp'\\\\)\" \"event: tmp.i has an unchecked value\" { xfail *-*-* } } */\n-      /* { dg-message \"'tmp.i' has its upper bound checked here\" \"event: upper bound checked\" { target *-*-* } .-1 } */\n-      return tmp.buf[tmp.i]; /* { dg-warning \"use of tainted value 'tmp.i' in array lookup without lower-bounds checking\" \"warning\" } */\n+      /* { dg-message \"'tmp.i' has its upper bound checked here\" \"event: upper bound checked\" { xfail *-*-* } .-1 } */\n+      return tmp.buf[tmp.i]; /* { dg-warning \"use of attacker-controlled value 'tmp.i' in array lookup without checking for negative\" \"warning\" } */\n     }\n   }\n   return 0;\n@@ -85,7 +86,7 @@ char test_6(FILE *f)\n   struct bar tmp;\n \n   if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n-    return tmp.buf[tmp.i]; /* { dg-warning \"use of tainted value 'tmp.i' in array lookup without upper-bounds checking\" } */\n+    return tmp.buf[tmp.i]; /* { dg-warning \"use of attacker-controlled value 'tmp.i' in array lookup without upper-bounds checking\" } */\n   }\n   return 0;\n }\n@@ -96,7 +97,7 @@ char test_7(FILE *f)\n \n   if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n     if (tmp.i >= 0) {\n-      return tmp.buf[tmp.i]; /* { dg-warning \"use of tainted value 'tmp.i' in array lookup without upper-bounds checking\" } */\n+      return tmp.buf[tmp.i]; /* { dg-warning \"use of attacker-controlled value 'tmp.i' in array lookup without upper-bounds checking\" } */\n     }\n   }\n   return 0;\n@@ -122,7 +123,7 @@ char test_9(FILE *f)\n   if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n     if (tmp.i == 42) {\n       /* not a bug: tmp.i compared against a specific value: */\n-      return tmp.buf[tmp.i]; /* { dg-bogus \"tainted\" \"\" { xfail *-*-* } } */\n+      return tmp.buf[tmp.i]; /* { dg-bogus \"attacker-controlled\" \"\" { xfail *-*-* } } */\n       // TODO: xfail\n     }\n   }", "previous_filename": "gcc/testsuite/gcc.dg/analyzer/taint-1.c"}, {"sha": "6db59bcc61541fae759f701235d70b5b1f25f0df", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-read-offset-1.c", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-read-offset-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-read-offset-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-read-offset-1.c?ref=b9365b93212041f14a7f71ba8da5af4d82240dc6", "patch": "@@ -0,0 +1,128 @@\n+// TODO: remove need for this option:\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+struct foo\n+{\n+  ssize_t offset;\n+};\n+\n+char *p;\n+\n+char test_1(FILE *f)\n+{\n+  struct foo tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) { /* { dg-message \"\\\\(\\[0-9\\]+\\\\) 'tmp' gets an unchecked value here\" \"event: tmp gets unchecked value\" { xfail *-*-* } } */\n+                                             /* { dg-message \"\\\\(\\[0-9\\]+\\\\) following 'true' branch\\\\.\\\\.\\\\.\" \"event: following true branch\" { target *-*-* } .-1 } */\n+    return *(p + tmp.offset); // { dg-warning \"use of attacker-controlled value 'tmp.offset' as offset without bounds checking\" \"warning\" } */\n+    /* { dg-message \"\\\\(\\[0-9\\]+\\\\) \\\\.\\\\.\\\\.to here\" \"event: to here\" { target *-*-* } .-1 } */\n+    /* { dg-message \"\\\\(\\[0-9\\]+\\\\) 'tmp.offset' has an unchecked value here \\\\(from 'tmp'\\\\)\" \"event: tmp.offset has an unchecked value\" { xfail *-*-* } .-2 } */\n+    /* { dg-message \"\\\\(\\[0-9\\]+\\\\) use of attacker-controlled value 'tmp.offset' as offset without bounds checking\" \"final event\" { target *-*-* } .-3 } */\n+    \n+    // TOOD: better messages for state changes\n+  }\n+  return 0;\n+}\n+\n+char test_2(struct foo *f)\n+{\n+  /* not a bug: the data is not known to be tainted: */\n+  return *(p + f->offset);\n+}\n+\n+char test_3(FILE *f)\n+{\n+  struct foo tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n+    if (tmp.offset >= 0 && tmp.offset < 256) {\n+      /* not a bug: the access is guarded by upper and lower bounds: */\n+      return *(p + tmp.offset);\n+    }\n+  }\n+  return 0;\n+}\n+\n+char test_4(FILE *f)\n+{\n+  struct foo tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n+    if (tmp.offset >= 0) { /* { dg-message \"'tmp.offset' has an unchecked value here \\\\(from 'tmp'\\\\)\" \"event: tmp.offset has an unchecked value\" { xfail *-*-* } } */\n+      /* { dg-message \"'tmp.offset' has its lower bound checked here\" \"event: lower bound checked\" { xfail *-*-* } .-1 } */\n+      return *(p + tmp.offset); /* { dg-warning \"use of attacker-controlled value 'tmp.offset' as offset without upper-bounds checking\" \"warning\" } */\n+    }\n+  }\n+  return 0;\n+}\n+\n+char test_5(FILE *f)\n+{\n+  struct foo tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n+    if (tmp.offset < 256) { /* { dg-message \"'tmp.offset' has an unchecked value here \\\\(from 'tmp'\\\\)\" \"event: tmp.offset has an unchecked value\" { xfail *-*-* } } */\n+      /* { dg-message \"'tmp.offset' has its upper bound checked here\" \"event: upper bound checked\" { xfail *-*-* } .-1 } */\n+      return *(p + tmp.offset); /* { dg-warning \"use of attacker-controlled value 'tmp.offset' as offset without lower-bounds checking\" \"warning\" } */\n+    }\n+  }\n+  return 0;\n+}\n+\n+/* unsigned types have a natural lower bound of 0 */\n+struct bar\n+{\n+  size_t offset;\n+};\n+\n+char test_6(FILE *f)\n+{\n+  struct bar tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n+    return *(p + tmp.offset); /* { dg-warning \"use of attacker-controlled value 'tmp.offset' as offset without upper-bounds checking\" } */\n+  }\n+  return 0;\n+}\n+\n+char test_7(FILE *f)\n+{\n+  struct bar tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n+    if (tmp.offset >= 0) {\n+      return *(p + tmp.offset); /* { dg-warning \"use of attacker-controlled value 'tmp.offset' as offset without upper-bounds checking\" } */\n+    }\n+  }\n+  return 0;\n+}\n+\n+char test_8(FILE *f)\n+{\n+  struct bar tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n+    if (tmp.offset < 256) {\n+      /* not a bug: has an upper bound, and an implicit lower bound: */\n+      return *(p + tmp.offset);\n+    }\n+  }\n+  return 0;\n+}\n+\n+char test_9(FILE *f)\n+{\n+  struct foo tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n+    if (tmp.offset == 42) {\n+      /* not a bug: tmp.offset compared against a specific value: */\n+      return *(p + tmp.offset); /* { dg-bogus \"attacker-controlled\" \"\" { xfail *-*-* } } */\n+    }\n+  }\n+  return 0;\n+}"}, {"sha": "64c9c26aa2d5b5d319c1e6638ec017535362cb3d", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-size-1.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-size-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-size-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-size-1.c?ref=b9365b93212041f14a7f71ba8da5af4d82240dc6", "patch": "@@ -0,0 +1,32 @@\n+// TODO: remove need for this option:\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+#include \"analyzer-decls.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+struct foo\n+{\n+  size_t sz;\n+};\n+\n+char buf[100];\n+\n+/* memset with tainted size.  */\n+\n+void test_1 (FILE *f)\n+{\n+  struct foo tmp;\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) { /* { dg-message \"\\\\(\\[0-9\\]+\\\\) 'tmp' gets an unchecked value here\" \"event: tmp gets unchecked value\" { xfail *-*-* } } */\n+                                             /* { dg-message \"\\\\(\\[0-9\\]+\\\\) following 'true' branch\\\\.\\\\.\\\\.\" \"event: following true branch\" { target *-*-* } .-1 } */\n+    __analyzer_dump_state (\"taint\", tmp.sz); /* { dg-warning \"state: 'tainted'\" } */\n+    /* { dg-message \"\\\\(\\[0-9\\]+\\\\) \\\\.\\\\.\\\\.to here\" \"event: to here\" { target *-*-* } .-1 } */\n+\n+    memset (buf, 0, tmp.sz); /* { dg-warning \"use of attacker-controlled value 'tmp\\\\.sz' as size without upper-bounds checking\" \"warning\" } */\n+    /* { dg-message \"23: \\\\(\\[0-9\\]+\\\\) 'tmp.i' has an unchecked value here \\\\(from 'tmp'\\\\)\" \"event: tmp.i has an unchecked value\" { xfail *-*-* } .-1 } */\n+    /* { dg-message \"\\\\(\\[0-9\\]+\\\\) use of attacker-controlled value 'tmp\\\\.sz' as size without upper-bounds checking\" \"final event\" { target *-*-* } .-2 } */\n+    \n+    // TOOD: better messages for state changes\n+  }\n+}"}, {"sha": "cc7ab1ca4f6ecc5c24edbf49d545a5e2bd98c252", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-write-index-1.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-write-index-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-write-index-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-write-index-1.c?ref=b9365b93212041f14a7f71ba8da5af4d82240dc6", "patch": "@@ -0,0 +1,132 @@\n+// TODO: remove need for this option:\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+struct foo\n+{\n+  signed int i;\n+  char buf[256];\n+};\n+\n+struct foo g;\n+char test_1(FILE *f)\n+{\n+  struct foo tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) { /* { dg-message \"\\\\(\\[0-9\\]+\\\\) 'tmp' gets an unchecked value here\" \"event: tmp gets unchecked value\" { xfail *-*-* } } */\n+                                             /* { dg-message \"\\\\(\\[0-9\\]+\\\\) following 'true' branch\\\\.\\\\.\\\\.\" \"event: following true branch\" { target *-*-* } .-1 } */\n+    /* BUG: the following array lookup trusts that the input data's index is\n+       in the range 0 <= i < 256; otherwise it's accessing the stack */\n+    g.buf[tmp.i] = 42; // { dg-warning \"use of attacker-controlled value 'tmp.i' in array lookup without bounds checking\" \"warning\" } */\n+    /* { dg-message \"\\\\(\\[0-9\\]+\\\\) \\\\.\\\\.\\\\.to here\" \"event: to here\" { target *-*-* } .-1 } */\n+    /* { dg-message \"\\\\(\\[0-9\\]+\\\\) 'tmp.i' has an unchecked value here \\\\(from 'tmp'\\\\)\" \"event: tmp.i has an unchecked value\" { xfail *-*-* } .-2 } */\n+    /* { dg-message \"\\\\(\\[0-9\\]+\\\\) use of attacker-controlled value 'tmp.i' in array lookup without bounds checking\" \"final event\" { target *-*-* } .-3 } */\n+    \n+    // TOOD: better messages for state changes\n+  }\n+  return 0;\n+}\n+\n+char test_2(struct foo *f, int i)\n+{\n+  /* not a bug: the data is not known to be tainted: */\n+  return f->buf[f->i];\n+}\n+\n+char test_3(FILE *f)\n+{\n+  struct foo tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n+    if (tmp.i >= 0 && tmp.i < 256) {\n+      /* not a bug: the access is guarded by upper and lower bounds: */\n+      g.buf[tmp.i] = 42;\n+    }\n+  }\n+  return 0;\n+}\n+\n+char test_4(FILE *f)\n+{\n+  struct foo tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n+    if (tmp.i >= 0) { /* { dg-message \"'tmp.i' has an unchecked value here \\\\(from 'tmp'\\\\)\" \"event: tmp.i has an unchecked value\" { xfail *-*-* } } */\n+      /* { dg-message \"'tmp.i' has its lower bound checked here\" \"event: lower bound checked\" { xfail *-*-* } .-1 } */\n+      g.buf[tmp.i] = 42; /* { dg-warning \"use of attacker-controlled value 'tmp.i' in array lookup without upper-bounds checking\" \"warning\" } */\n+    }\n+  }\n+  return 0;\n+}\n+\n+char test_5(FILE *f)\n+{\n+  struct foo tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n+    if (tmp.i < 256) { /* { dg-message \"'tmp.i' has an unchecked value here \\\\(from 'tmp'\\\\)\" \"event: tmp.i has an unchecked value\" { xfail *-*-* } } */\n+      /* { dg-message \"'tmp.i' has its upper bound checked here\" \"event: upper bound checked\" { xfail *-*-* } .-1 } */\n+      g.buf[tmp.i] = 42; /* { dg-warning \"use of attacker-controlled value 'tmp.i' in array lookup without checking for negative\" \"warning\" } */\n+    }\n+  }\n+  return 0;\n+}\n+\n+/* unsigned types have a natural lower bound of 0 */\n+struct bar\n+{\n+  unsigned int i;\n+  char buf[256];\n+};\n+\n+char test_6(FILE *f)\n+{\n+  struct bar tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n+    g.buf[tmp.i] = 42; /* { dg-warning \"use of attacker-controlled value 'tmp.i' in array lookup without upper-bounds checking\" } */\n+  }\n+  return 0;\n+}\n+\n+char test_7(FILE *f)\n+{\n+  struct bar tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n+    if (tmp.i >= 0) {\n+      g.buf[tmp.i] = 42; /* { dg-warning \"use of attacker-controlled value 'tmp.i' in array lookup without upper-bounds checking\" } */\n+    }\n+  }\n+  return 0;\n+}\n+\n+char test_8(FILE *f)\n+{\n+  struct bar tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n+    if (tmp.i < 256) {\n+      /* not a bug: has an upper bound, and an implicit lower bound: */\n+      g.buf[tmp.i] = 42;\n+    }\n+  }\n+  return 0;\n+}\n+\n+char test_9(FILE *f)\n+{\n+  struct foo tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n+    if (tmp.i == 42) {\n+      /* not a bug: tmp.i compared against a specific value: */\n+      g.buf[tmp.i] = 42; /* { dg-bogus \"attacker-controlled\" \"\" { xfail *-*-* } } */\n+      // TODO: xfail\n+    }\n+  }\n+  return 0;\n+}"}, {"sha": "d0df62203156f407a2f711d9d2f9b626fc455283", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-write-offset-1.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-write-offset-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9365b93212041f14a7f71ba8da5af4d82240dc6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-write-offset-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-write-offset-1.c?ref=b9365b93212041f14a7f71ba8da5af4d82240dc6", "patch": "@@ -0,0 +1,132 @@\n+// TODO: remove need for this option:\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+struct foo\n+{\n+  ssize_t offset;\n+};\n+\n+char *p;\n+\n+char test_1(FILE *f)\n+{\n+  struct foo tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) { /* { dg-message \"\\\\(\\[0-9\\]+\\\\) 'tmp' gets an unchecked value here\" \"event: tmp gets unchecked value\" { xfail *-*-* } } */\n+                                             /* { dg-message \"\\\\(\\[0-9\\]+\\\\) following 'true' branch\\\\.\\\\.\\\\.\" \"event: following true branch\" { target *-*-* } .-1 } */\n+    /* BUG: the following array lookup trusts that the input data's index is\n+       in the range 0 <= i < 256; otherwise it's accessing the stack */\n+    *(p + tmp.offset) = 42; // { dg-warning \"use of attacker-controlled value 'tmp.offset' as offset without bounds checking\" \"warning\" } */\n+    /* { dg-message \"\\\\(\\[0-9\\]+\\\\) \\\\.\\\\.\\\\.to here\" \"event: to here\" { target *-*-* } .-1 } */\n+    /* { dg-message \"\\\\(\\[0-9\\]+\\\\) 'tmp.offset' has an unchecked value here \\\\(from 'tmp'\\\\)\" \"event: tmp.offset has an unchecked value\" { xfail *-*-* } .-2 } */\n+    /* { dg-message \"\\\\(\\[0-9\\]+\\\\) use of attacker-controlled value 'tmp.offset' as offset without bounds checking\" \"final event\" { target *-*-* } .-3 } */\n+    \n+    // TOOD: better messages for state changes\n+  }\n+  return 0;\n+}\n+\n+char test_2(struct foo *f)\n+{\n+  /* not a bug: the data is not known to be tainted: */\n+  *(p + f->offset) = 42;\n+}\n+\n+char test_3(FILE *f)\n+{\n+  struct foo tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n+    if (tmp.offset >= 0 && tmp.offset < 256) {\n+      /* not a bug: the access is guarded by upper and lower bounds: */\n+      *(p + tmp.offset) = 42;\n+    }\n+  }\n+  return 0;\n+}\n+\n+char test_4(FILE *f)\n+{\n+  struct foo tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n+    if (tmp.offset >= 0) { /* { dg-message \"'tmp.offset' has an unchecked value here \\\\(from 'tmp'\\\\)\" \"event: tmp.offset has an unchecked value\" { xfail *-*-* } } */\n+      /* { dg-message \"'tmp.offset' has its lower bound checked here\" \"event: lower bound checked\" { xfail *-*-* } .-1 } */\n+      *(p + tmp.offset) = 42; /* { dg-warning \"use of attacker-controlled value 'tmp.offset' as offset without upper-bounds checking\" \"warning\" } */\n+    }\n+  }\n+  return 0;\n+}\n+\n+char test_5(FILE *f)\n+{\n+  struct foo tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n+    if (tmp.offset < 256) { /* { dg-message \"'tmp.offset' has an unchecked value here \\\\(from 'tmp'\\\\)\" \"event: tmp.offset has an unchecked value\" { xfail *-*-* } } */\n+      /* { dg-message \"'tmp.offset' has its upper bound checked here\" \"event: upper bound checked\" { xfail *-*-* } .-1 } */\n+      *(p + tmp.offset) = 42; /* { dg-warning \"use of attacker-controlled value 'tmp.offset' as offset without lower-bounds checking\" \"warning\" } */\n+    }\n+  }\n+  return 0;\n+}\n+\n+/* unsigned types have a natural lower bound of 0 */\n+struct bar\n+{\n+  unsigned int offset;\n+  char buf[256];\n+};\n+\n+char test_6(FILE *f)\n+{\n+  struct bar tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n+    *(p + tmp.offset) = 42; /* { dg-warning \"use of attacker-controlled value 'tmp.offset' as offset without upper-bounds checking\" } */\n+  }\n+  return 0;\n+}\n+\n+char test_7(FILE *f)\n+{\n+  struct bar tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n+    if (tmp.offset >= 0) {\n+      *(p + tmp.offset) = 42; /* { dg-warning \"use of attacker-controlled value 'tmp.offset' as offset without upper-bounds checking\" } */\n+    }\n+  }\n+  return 0;\n+}\n+\n+char test_8(FILE *f)\n+{\n+  struct bar tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n+    if (tmp.offset < 256) {\n+      /* not a bug: has an upper bound, and an implicit lower bound: */\n+      *(p + tmp.offset) = 42;\n+    }\n+  }\n+  return 0;\n+}\n+\n+char test_9(FILE *f)\n+{\n+  struct foo tmp;\n+\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n+    if (tmp.offset == 42) {\n+      /* not a bug: tmp.offset compared against a specific value: */\n+      *(p + tmp.offset) = 42; /* { dg-bogus \"tainted\" \"\" { xfail *-*-* } } */\n+      // TODO: xfail\n+    }\n+  }\n+  return 0;\n+}"}]}