{"sha": "dedac3eb7331f441f24b192fa0d9d1e1162f57ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVkYWMzZWI3MzMxZjQ0MWYyNGIxOTJmYTBkOWQxZTExNjJmNTdiYQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2011-08-05T15:10:50Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-05T15:10:50Z"}, "message": "par_sco.adb, [...]: Minor reformatting.\n\n2011-08-05  Robert Dewar  <dewar@adacore.com>\n\n\t* par_sco.adb, sem_ch3.adb, scos.ads, a-iteint.ads, sem_ch12.adb,\n\ta-cimutr.adb, a-cimutr.ads, sem_util.ads, sem_res.adb, a-fihema.adb,\n\tsem_ch4.adb, lib-xref-alfa.adb, exp_disp.adb, a-comutr.adb,\n\ta-comutr.ads, lib-xref.adb: Minor reformatting.\n\n2011-08-05  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch11.adb (Analyze_Raise_Statement): Kill assignment to formal\n\twarning if there is an exception handler present.\n\nFrom-SVN: r177451", "tree": {"sha": "dbf7d77eccd6d83effd5cc41a4d0d61e74a759c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbf7d77eccd6d83effd5cc41a4d0d61e74a759c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dedac3eb7331f441f24b192fa0d9d1e1162f57ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dedac3eb7331f441f24b192fa0d9d1e1162f57ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dedac3eb7331f441f24b192fa0d9d1e1162f57ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/comments", "author": null, "committer": null, "parents": [{"sha": "7c62a85a8dcec50e474c02525c5f165ad30cf2d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c62a85a8dcec50e474c02525c5f165ad30cf2d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c62a85a8dcec50e474c02525c5f165ad30cf2d9"}], "stats": {"total": 921, "additions": 469, "deletions": 452}, "files": [{"sha": "c686c29da1be6e8b52d96c54f5f7296ee2e2fe4b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=dedac3eb7331f441f24b192fa0d9d1e1162f57ba", "patch": "@@ -1,3 +1,15 @@\n+2011-08-05  Robert Dewar  <dewar@adacore.com>\n+\n+\t* par_sco.adb, sem_ch3.adb, scos.ads, a-iteint.ads, sem_ch12.adb,\n+\ta-cimutr.adb, a-cimutr.ads, sem_util.ads, sem_res.adb, a-fihema.adb,\n+\tsem_ch4.adb, lib-xref-alfa.adb, exp_disp.adb, a-comutr.adb,\n+\ta-comutr.ads, lib-xref.adb: Minor reformatting.\n+\n+2011-08-05  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch11.adb (Analyze_Raise_Statement): Kill assignment to formal\n+\twarning if there is an exception handler present.\n+\n 2011-08-05  Pascal Obry  <obry@adacore.com>\n \n \t* a-iteint.ads: Fix copyright year."}, {"sha": "1e035ec62f785b6056bd256e40fadfdaa41b5c43", "filename": "gcc/ada/a-cimutr.adb", "status": "modified", "additions": 145, "deletions": 153, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fa-cimutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fa-cimutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cimutr.adb?ref=dedac3eb7331f441f24b192fa0d9d1e1162f57ba", "patch": "@@ -134,25 +134,24 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Target_Count : Count_Type;\n \n    begin\n-      --  We first restore the target container to its\n-      --  default-initialized state, before we attempt any\n-      --  allocation, to ensure that invariants are preserved\n-      --  in the event that the allocation fails.\n+      --  We first restore the target container to its default-initialized\n+      --  state, before we attempt any allocation, to ensure that invariants\n+      --  are preserved in the event that the allocation fails.\n \n       Container.Root.Children := Children_Type'(others => null);\n       Container.Busy := 0;\n       Container.Lock := 0;\n       Container.Count := 0;\n \n-      --  Copy_Children returns a count of the number of nodes\n-      --  that it allocates, but it works by incrementing the\n-      --  value that is passed in. We must therefore initialize\n-      --  the count value before calling Copy_Children.\n+      --  Copy_Children returns a count of the number of nodes that it\n+      --  allocates, but it works by incrementing the value that is passed in.\n+      --  We must therefore initialize the count value before calling\n+      --  Copy_Children.\n \n       Target_Count := 0;\n \n-      --  Now we attempt the allocation of subtrees. The invariants\n-      --  are satisfied even if the allocation fails.\n+      --  Now we attempt the allocation of subtrees. The invariants are\n+      --  satisfied even if the allocation fails.\n \n       Copy_Children (Source, Root_Node (Container), Target_Count);\n       pragma Assert (Target_Count = Source_Count);\n@@ -181,11 +180,10 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          raise Program_Error with \"Position cursor not in container\";\n       end if;\n \n-      --  AI-0136 says to raise PE if Position equals the root node.\n-      --  This does not seem correct, as this value is just the limiting\n-      --  condition of the search.  For now we omit this check,\n-      --  pending a ruling from the ARG.  ???\n-      --\n+      --  AI-0136 says to raise PE if Position equals the root node. This does\n+      --  not seem correct, as this value is just the limiting condition of the\n+      --  search. For now we omit this check pending a ruling from the ARG.???\n+\n       --  if Is_Root (Position) then\n       --     raise Program_Error with \"Position cursor designates root\";\n       --  end if;\n@@ -241,6 +239,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Last := First;\n \n       for J in Count_Type'(2) .. Count loop\n+\n          --  Reclaim other nodes if Storage_Error.  ???\n \n          Element := new Element_Type'(New_Item);\n@@ -258,10 +257,9 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          Parent => Parent.Node,\n          Before => null);  -- null means \"insert at end of list\"\n \n-      --  In order for operation Node_Count to complete\n-      --  in O(1) time, we cache the count value. Here we\n-      --  increment the total count by the number of nodes\n-      --  we just inserted.\n+      --  In order for operation Node_Count to complete in O(1) time, we cache\n+      --  the count value. Here we increment the total count by the number of\n+      --  nodes we just inserted.\n \n       Container.Count := Container.Count + Count;\n    end Append_Child;\n@@ -281,16 +279,15 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n \n       Target.Clear;  -- checks busy bit\n \n-      --  Copy_Children returns the number of nodes that it allocates,\n-      --  but it does this by incrementing the count value passed in,\n-      --  so we must initialize the count before calling Copy_Children.\n+      --  Copy_Children returns the number of nodes that it allocates, but it\n+      --  does this by incrementing the count value passed in, so we must\n+      --  initialize the count before calling Copy_Children.\n \n       Target_Count := 0;\n \n-      --  Note that Copy_Children inserts the newly-allocated children\n-      --  into their parent list only after the allocation of all the\n-      --  children has succeeded. This preserves invariants even if\n-      --  the allocation fails.\n+      --  Note that Copy_Children inserts the newly-allocated children into\n+      --  their parent list only after the allocation of all the children has\n+      --  succeeded. This preserves invariants even if the allocation fails.\n \n       Copy_Children (Source.Root.Children, Root_Node (Target), Target_Count);\n       pragma Assert (Target_Count = Source_Count);\n@@ -303,36 +300,33 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n    -----------\n \n    procedure Clear (Container : in out Tree) is\n-      Container_Count, Children_Count : Count_Type;\n+      Container_Count : Count_Type;\n+      Children_Count  : Count_Type;\n \n    begin\n       if Container.Busy > 0 then\n          raise Program_Error\n            with \"attempt to tamper with cursors (tree is busy)\";\n       end if;\n \n-      --  We first set the container count to 0, in order to\n-      --  preserve invariants in case the deallocation fails.\n-      --  (This works because Deallocate_Children immediately\n-      --  removes the children from their parent, and then\n-      --  does the actual deallocation.)\n+      --  We first set the container count to 0, in order to preserve\n+      --  invariants in case the deallocation fails. (This works because\n+      --  Deallocate_Children immediately removes the children from their\n+      --  parent, and then does the actual deallocation.)\n \n       Container_Count := Container.Count;\n       Container.Count := 0;\n \n-      --  Deallocate_Children returns the number of nodes that\n-      --  it deallocates, but it does this by incrementing the\n-      --  count value that is passed in, so we must first initialize\n-      --  the count return value before calling it.\n+      --  Deallocate_Children returns the number of nodes that it deallocates,\n+      --  but it does this by incrementing the count value that is passed in,\n+      --  so we must first initialize the count return value before calling it.\n \n       Children_Count := 0;\n \n-      --  See comment above.  Deallocate_Children immediately\n-      --  removes the children list from their parent node (here,\n-      --  the root of the tree), and only after that does it\n-      --  attempt the actual deallocation.  So even if the\n-      --  deallocation fails, the representation invariants\n-      --  for the tree are preserved.\n+      --  See comment above. Deallocate_Children immediately removes the\n+      --  children list from their parent node (here, the root of the tree),\n+      --  and only after that does it attempt the actual deallocation. So even\n+      --  if the deallocation fails, the representation invariants\n \n       Deallocate_Children (Root_Node (Container), Children_Count);\n       pragma Assert (Children_Count = Container_Count);\n@@ -383,9 +377,8 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       C  : Tree_Node_Access;\n \n    begin\n-      --  We special-case the first allocation, in order\n-      --  to establish the representation invariants\n-      --  for type Children_Type.\n+      --  We special-case the first allocation, in order to establish the\n+      --  representation invariants for type Children_Type.\n \n       C := Source.First;\n \n@@ -401,9 +394,8 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n \n       CC.Last := CC.First;\n \n-      --  The representation invariants for the Children_Type\n-      --  list have been established, so we can now copy\n-      --  the remaining children of Source.\n+      --  The representation invariants for the Children_Type list have been\n+      --  established, so we can now copy the remaining children of Source.\n \n       C := C.Next;\n       while C /= null loop\n@@ -419,9 +411,9 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          C := C.Next;\n       end loop;\n \n-      --  We add the newly-allocated children to their parent list\n-      --  only after the allocation has succeeded, in order to\n-      --  preserve invariants of the parent.\n+      --  We add the newly-allocated children to their parent list only after\n+      --  the allocation has succeeded, in order to preserve invariants of the\n+      --  parent.\n \n       Parent.Children := CC;\n    end Copy_Children;\n@@ -450,6 +442,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          Result := Result + 1;\n          Node := Node.Next;\n       end loop;\n+\n       return Result;\n    end Child_Count;\n \n@@ -484,6 +477,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n             raise Program_Error with \"Parent is not ancestor of Child\";\n          end if;\n       end loop;\n+\n       return Result;\n    end Child_Depth;\n \n@@ -527,10 +521,10 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          raise Constraint_Error with \"Source cursor designates root\";\n       end if;\n \n-      --  Copy_Subtree returns a count of the number of nodes\n-      --  that it allocates, but it works by incrementing the\n-      --  value that is passed in. We must therefore initialize\n-      --  the count value before calling Copy_Subtree.\n+      --  Copy_Subtree returns a count of the number of nodes that it\n+      --  allocates, but it works by incrementing the value that is passed in.\n+      --  We must therefore initialize the count value before calling\n+      --  Copy_Subtree.\n \n       Target_Count := 0;\n \n@@ -549,10 +543,9 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          Parent  => Parent.Node,\n          Before  => Before.Node);\n \n-      --  In order for operation Node_Count to complete\n-      --  in O(1) time, we cache the count value. Here we\n-      --  increment the total count by the number of nodes\n-      --  we just inserted.\n+      --  In order for operation Node_Count to complete in O(1) time, we cache\n+      --  the count value. Here we increment the total count by the number of\n+      --  nodes we just inserted.\n \n       Target.Count := Target.Count + Target_Count;\n    end Copy_Subtree;\n@@ -590,9 +583,8 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       C  : Tree_Node_Access;\n \n    begin\n-      --  We immediately remove the children from their\n-      --  parent, in order to preserve invariants in case\n-      --  the deallocation fails.\n+      --  We immediately remove the children from their parent, in order to\n+      --  preserve invariants in case the deallocation fails.\n \n       Subtree.Children := Children_Type'(others => null);\n \n@@ -707,16 +699,15 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       X := Position.Node;\n       Position := No_Element;\n \n-      --  Restore represention invariants before attempting the\n-      --  actual deallocation.\n+      --  Restore represention invariants before attempting the actual\n+      --  deallocation.\n \n       Remove_Subtree (X);\n       Container.Count := Container.Count - 1;\n \n-      --  It is now safe to attempt the deallocation.  This leaf\n-      --  node has been disassociated from the tree, so even if\n-      --  the deallocation fails, representation invariants\n-      --  will remain satisfied.\n+      --  It is now safe to attempt the deallocation. This leaf node has been\n+      --  disassociated from the tree, so even if the deallocation fails,\n+      --  representation invariants will remain satisfied.\n \n       Deallocate_Node (X);\n    end Delete_Leaf;\n@@ -753,38 +744,35 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       X := Position.Node;\n       Position := No_Element;\n \n-      --  Here is one case where a deallocation failure can\n-      --  result in the violation of a representation invariant.\n-      --  We disassociate the subtree from the tree now, but we\n-      --  only decrement the total node count after we attempt\n-      --  the deallocation. However, if the deallocation fails,\n-      --  the total node count will not get decremented.\n-      --\n-      --  One way around this dilemma is to count the nodes\n-      --  in the subtree before attempt to delete the subtree,\n-      --  but that is an O(n) operation, so it does not seem\n-      --  worth it.\n-      --\n-      --  Perhaps this is much ado about nothing, since the\n-      --  only way deallocation can fail is if Controlled\n-      --  Finalization fails: this propagates Program_Error\n-      --  so all bets are off anyway.  ???\n+      --  Here is one case where a deallocation failure can result in the\n+      --  violation of a representation invariant. We disassociate the subtree\n+      --  from the tree now, but we only decrement the total node count after\n+      --  we attempt the deallocation. However, if the deallocation fails, the\n+      --  total node count will not get decremented.\n+\n+      --  One way around this dilemma is to count the nodes in the subtree\n+      --  before attempt to delete the subtree, but that is an O(n) operation,\n+      --  so it does not seem worth it.\n+\n+      --  Perhaps this is much ado about nothing, since the only way\n+      --  deallocation can fail is if Controlled Finalization fails: this\n+      --  propagates Program_Error so all bets are off anyway. ???\n \n       Remove_Subtree (X);\n \n-      --  Deallocate_Subtree returns a count of the number of nodes\n-      --  that it deallocates, but it works by incrementing the\n-      --  value that is passed in. We must therefore initialize\n-      --  the count value before calling Deallocate_Subtree.\n+      --  Deallocate_Subtree returns a count of the number of nodes that it\n+      --  deallocates, but it works by incrementing the value that is passed\n+      --  in. We must therefore initialize the count value before calling\n+      --  Deallocate_Subtree.\n \n       Count := 0;\n \n       Deallocate_Subtree (X, Count);\n       pragma Assert (Count <= Container.Count);\n \n-      --  See comments above. We would prefer to do this\n-      --  sooner, but there's no way to satisfy that goal\n-      --  without an potentially severe execution penalty.\n+      --  See comments above. We would prefer to do this sooner, but there's no\n+      --  way to satisfy that goal without an potentially severe execution\n+      --  penalty.\n \n       Container.Count := Container.Count - Count;\n    end Delete_Subtree;\n@@ -804,6 +792,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          N := N.Parent;\n          Result := Result + 1;\n       end loop;\n+\n       return Result;\n    end Depth;\n \n@@ -1122,10 +1111,9 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          Parent => Parent.Node,\n          Before => Before.Node);\n \n-      --  In order for operation Node_Count to complete\n-      --  in O(1) time, we cache the count value. Here we\n-      --  increment the total count by the number of nodes\n-      --  we just inserted.\n+      --  In order for operation Node_Count to complete in O(1) time, we cache\n+      --  the count value. Here we increment the total count by the number of\n+      --  nodes we just inserted.\n \n       Container.Count := Container.Count + Count;\n    end Insert_Child;\n@@ -1144,11 +1132,10 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       C : Children_Type renames Parent.Children;\n \n    begin\n-      --  This is a simple utility operation to\n-      --  insert a list of nodes (from First..Last)\n-      --  as children of Parent. The Before node\n-      --  specifies where the new children should be\n-      --  inserted relative to the existing children.\n+      --  This is a simple utility operation to insert a list of nodes (from\n+      --  First..Last) as children of Parent. The Before node specifies where\n+      --  the new children should be inserted relative to the existing\n+      --  children.\n \n       if First = null then\n          pragma Assert (Last = null);\n@@ -1194,8 +1181,8 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Before  : Tree_Node_Access)\n    is\n    begin\n-      --  This is a simple wrapper operation to insert\n-      --  a single child into the Parent's children list.\n+      --  This is a simple wrapper operation to insert a single child into the\n+      --  Parent's children list.\n \n       Insert_Subtree_List\n         (First  => Subtree,\n@@ -1282,6 +1269,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          Process   => Process);\n \n       B := B - 1;\n+\n    exception\n       when others =>\n          B := B - 1;\n@@ -1315,6 +1303,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          end loop;\n \n          B := B - 1;\n+\n       exception\n          when others =>\n             B := B - 1;\n@@ -1330,13 +1319,11 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Node : Tree_Node_Access;\n \n    begin\n-      --  This is a helper function to recursively iterate over\n-      --  all the nodes in a subtree, in depth-first fashion.\n-      --  This particular helper just visits the children of this\n-      --  subtree, not the root of the subtree node itself.  This\n-      --  is useful when starting from the ultimate root of the\n-      --  entire tree (see Iterate), as that root does not have\n-      --  an element.\n+      --  This is a helper function to recursively iterate over all the nodes\n+      --  in a subtree, in depth-first fashion. This particular helper just\n+      --  visits the children of this subtree, not the root of the subtree node\n+      --  itself. This is useful when starting from the ultimate root of the\n+      --  entire tree (see Iterate), as that root does not have an element.\n \n       Node := Subtree.Children.First;\n       while Node /= null loop\n@@ -1366,12 +1353,12 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n \n          if Is_Root (Position) then\n             Iterate_Children (Position.Container, Position.Node, Process);\n-\n          else\n             Iterate_Subtree (Position.Container, Position.Node, Process);\n          end if;\n \n          B := B - 1;\n+\n       exception\n          when others =>\n             B := B - 1;\n@@ -1385,10 +1372,9 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Process   : not null access procedure (Position : Cursor))\n    is\n    begin\n-      --  This is a helper function to recursively iterate over\n-      --  all the nodes in a subtree, in depth-first fashion.\n-      --  It first visits the root of the subtree, then visits\n-      --  its children.\n+      --  This is a helper function to recursively iterate over all the nodes\n+      --  in a subtree, in depth-first fashion. It first visits the root of the\n+      --  subtree, then visits its children.\n \n       Process (Cursor'(Container, Subtree));\n       Iterate_Children (Container, Subtree, Process);\n@@ -1484,17 +1470,15 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n \n    function Node_Count (Container : Tree) return Count_Type is\n    begin\n-      --  Container.Count is the number of nodes we have actually\n-      --  allocated. We cache the value specifically so this Node_Count\n-      --  operation can execute in O(1) time, which makes it behave\n-      --  similarly to how the Length selector function behaves\n-      --  for other containers.\n+      --  Container.Count is the number of nodes we have actually allocated. We\n+      --  cache the value specifically so this Node_Count operation can execute\n+      --  in O(1) time, which makes it behave similarly to how the Length\n+      --  selector function behaves for other containers.\n       --\n-      --  The cached node count value only describes the nodes\n-      --  we have allocated; the root node itself is not included\n-      --  in that count. The Node_Count operation returns a value\n-      --  that includes the root node (because the RM says so), so we\n-      --  must add 1 to our cached value.\n+      --  The cached node count value only describes the nodes we have\n+      --  allocated; the root node itself is not included in that count. The\n+      --  Node_Count operation returns a value that includes the root node\n+      --  (because the RM says so), so we must add 1 to our cached value.\n \n       return 1 + Container.Count;\n    end Node_Count;\n@@ -1555,6 +1539,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Last := First;\n \n       for J in Count_Type'(2) .. Count loop\n+\n          --  Reclaim other nodes if Storage_Error.  ???\n \n          Element := new Element_Type'(New_Item);\n@@ -1572,10 +1557,9 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          Parent => Parent.Node,\n          Before => Parent.Node.Children.First);\n \n-      --  In order for operation Node_Count to complete\n-      --  in O(1) time, we cache the count value. Here we\n-      --  increment the total count by the number of nodes\n-      --  we just inserted.\n+      --  In order for operation Node_Count to complete in O(1) time, we cache\n+      --  the count value. Here we increment the total count by the number of\n+      --  nodes we just inserted.\n \n       Container.Count := Container.Count + Count;\n    end Prepend_Child;\n@@ -1632,6 +1616,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n \n          L := L - 1;\n          B := B - 1;\n+\n       exception\n          when others =>\n             L := L - 1;\n@@ -1653,7 +1638,8 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       function Read_Subtree\n         (Parent : Tree_Node_Access) return Tree_Node_Access;\n \n-      Total_Count, Read_Count : Count_Type;\n+      Total_Count : Count_Type;\n+      Read_Count  : Count_Type;\n \n       -------------------\n       -- Read_Children --\n@@ -1664,8 +1650,10 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          pragma Assert (Subtree.Children.First = null);\n          pragma Assert (Subtree.Children.Last = null);\n \n-         Count : Count_Type;  -- number of child subtrees\n-         C     : Children_Type;\n+         Count : Count_Type;\n+         --  Number of child subtrees\n+\n+         C : Children_Type;\n \n       begin\n          Count_Type'Read (Stream, Count);\n@@ -1687,8 +1675,8 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n             C.Last := C.Last.Next;\n          end loop;\n \n-         --  Now that the allocation and reads have completed successfully,\n-         --  it is safe to link the children to their parent.\n+         --  Now that the allocation and reads have completed successfully, it\n+         --  is safe to link the children to their parent.\n \n          Subtree.Children := C;\n       end Read_Children;\n@@ -1759,8 +1747,8 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       C : Children_Type renames Subtree.Parent.Children;\n \n    begin\n-      --  This is a utility operation to remove a subtree\n-      --  node from its parent's list of children.\n+      --  This is a utility operation to remove a subtree node from its\n+      --  parent's list of children.\n \n       if C.First = Subtree then\n          pragma Assert (Subtree.Prev = null);\n@@ -1850,6 +1838,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          end loop;\n \n          B := B - 1;\n+\n       exception\n          when others =>\n             B := B - 1;\n@@ -1954,10 +1943,10 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n            with \"attempt to tamper with cursors (Source tree is busy)\";\n       end if;\n \n-      --  We cache the count of the nodes we have allocated, so that\n-      --  operation Node_Count can execute in O(1) time. But that means\n-      --  we must count the nodes in the subtree we remove from Source\n-      --  and insert into Target, in order to keep the count accurate.\n+      --  We cache the count of the nodes we have allocated, so that operation\n+      --  Node_Count can execute in O(1) time. But that means we must count the\n+      --  nodes in the subtree we remove from Source and insert into Target, in\n+      --  order to keep the count accurate.\n \n       Count := Subtree_Node_Count (Source_Parent.Node);\n       pragma Assert (Count >= 1);\n@@ -2041,13 +2030,13 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       C  : Tree_Node_Access;\n \n    begin\n-      --  This is a utility operation to remove the children from\n-      --  Source parent and insert them into Target parent.\n+      --  This is a utility operation to remove the children from Source parent\n+      --  and insert them into Target parent.\n \n       Source_Parent.Children := Children_Type'(others => null);\n \n-      --  Fix up the Parent pointers of each child to designate\n-      --  its new Target parent.\n+      --  Fix up the Parent pointers of each child to designate its new Target\n+      --  parent.\n \n       C := CC.First;\n       while C /= null loop\n@@ -2140,17 +2129,16 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n            with \"attempt to tamper with cursors (Source tree is busy)\";\n       end if;\n \n-      --  This is an unfortunate feature of this API: we must count\n-      --  the nodes in the subtree that we remove from the source tree,\n-      --  which is an O(n) operation. It would have been better if\n-      --  the Tree container did not have a Node_Count selector; a\n-      --  user that wants the number of nodes in the tree could\n-      --  simply call Subtree_Node_Count, with the understanding that\n-      --  such an operation is O(n).\n+      --  This is an unfortunate feature of this API: we must count the nodes\n+      --  in the subtree that we remove from the source tree, which is an O(n)\n+      --  operation. It would have been better if the Tree container did not\n+      --  have a Node_Count selector; a user that wants the number of nodes in\n+      --  the tree could simply call Subtree_Node_Count, with the understanding\n+      --  that such an operation is O(n).\n       --\n-      --  Of course, we could choose to implement the Node_Count selector\n-      --  as an O(n) operation, which would turn this splice operation\n-      --  into an O(1) operation.  ???\n+      --  Of course, we could choose to implement the Node_Count selector as an\n+      --  O(n) operation, which would turn this splice operation into an O(1)\n+      --  operation. ???\n \n       Subtree_Count := Subtree_Node_Count (Position.Node);\n       pragma Assert (Subtree_Count <= Source.Count);\n@@ -2200,7 +2188,9 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       end if;\n \n       if Is_Root (Position) then\n+\n          --  Should this be PE instead?  Need ARG confirmation.  ???\n+\n          raise Constraint_Error with \"Position cursor designates root\";\n       end if;\n \n@@ -2251,6 +2241,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          Result := Result + Subtree_Node_Count (Node);\n          Node := Node.Next;\n       end loop;\n+\n       return Result;\n    end Subtree_Node_Count;\n \n@@ -2340,6 +2331,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n \n          L := L - 1;\n          B := B - 1;\n+\n       exception\n          when others =>\n             L := L - 1;"}, {"sha": "7e8e7c80b620476a77f7e5b10ffe67417b865415", "filename": "gcc/ada/a-cimutr.ads", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fa-cimutr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fa-cimutr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cimutr.ads?ref=dedac3eb7331f441f24b192fa0d9d1e1162f57ba", "patch": "@@ -231,8 +231,8 @@ package Ada.Containers.Indefinite_Multiway_Trees is\n    --     Parent    : Cursor;\n    --     Process   : not null access procedure (Position : Cursor));\n    --\n-   --  It seems that the Container parameter is there by mistake, but\n-   --  we need an official ruling from the ARG.  ???\n+   --  It seems that the Container parameter is there by mistake, but we need\n+   --  an official ruling from the ARG. ???\n \n    procedure Iterate_Children\n      (Parent  : Cursor;\n@@ -264,19 +264,17 @@ private\n \n    use Ada.Finalization;\n \n-   --  The Count component of type Tree represents the number of\n-   --  nodes that have been (dynamically) allocated.  It does not\n-   --  include the root node itself.  As implementors, we decide\n-   --  to cache this value, so that the selector function Node_Count\n-   --  can execute in O(1) time, in order to be consistent with\n-   --  the behavior of the Length selector function for other\n-   --  standard container library units. This does mean, however,\n-   --  that the two-container forms for Splice_XXX (that move subtrees\n-   --  across tree containers) will execute in O(n) time, because\n-   --  we must count the number of nodes in the subtree(s) that\n-   --  get moved.  (We resolve the tension between Node_Count\n-   --  and Splice_XXX in favor of Node_Count, under the assumption\n-   --  that Node_Count is the more common operation).\n+   --  The Count component of type Tree represents the number of nodes that\n+   --  have been (dynamically) allocated. It does not include the root node\n+   --  itself. As implementors, we decide to cache this value, so that the\n+   --  selector function Node_Count can execute in O(1) time, in order to be\n+   --  consistent with the behavior of the Length selector function for other\n+   --  standard container library units. This does mean, however, that the\n+   --  two-container forms for Splice_XXX (that move subtrees across tree\n+   --  containers) will execute in O(n) time, because we must count the number\n+   --  of nodes in the subtree(s) that get moved. (We resolve the tension\n+   --  between Node_Count and Splice_XXX in favor of Node_Count, under the\n+   --  assumption that Node_Count is the more common operation).\n \n    type Tree is new Controlled with record\n       Root  : aliased Tree_Node_Type;"}, {"sha": "7c7661d7e4f69d6461645c667721455defeddad2", "filename": "gcc/ada/a-comutr.adb", "status": "modified", "additions": 151, "deletions": 157, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fa-comutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fa-comutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comutr.adb?ref=dedac3eb7331f441f24b192fa0d9d1e1162f57ba", "patch": "@@ -133,25 +133,24 @@ package body Ada.Containers.Multiway_Trees is\n       Target_Count : Count_Type;\n \n    begin\n-      --  We first restore the target container to its\n-      --  default-initialized state, before we attempt any\n-      --  allocation, to ensure that invariants are preserved\n-      --  in the event that the allocation fails.\n+      --  We first restore the target container to its default-initialized\n+      --  state, before we attempt any allocation, to ensure that invariants\n+      --  are preserved in the event that the allocation fails.\n \n       Container.Root.Children := Children_Type'(others => null);\n       Container.Busy := 0;\n       Container.Lock := 0;\n       Container.Count := 0;\n \n-      --  Copy_Children returns a count of the number of nodes\n-      --  that it allocates, but it works by incrementing the\n-      --  value that is passed in. We must therefore initialize\n-      --  the count value before calling Copy_Children.\n+      --  Copy_Children returns a count of the number of nodes that it\n+      --  allocates, but it works by incrementing the value that is passed\n+      --  in. We must therefore initialize the count value before calling\n+      --  Copy_Children.\n \n       Target_Count := 0;\n \n-      --  Now we attempt the allocation of subtrees. The invariants\n-      --  are satisfied even if the allocation fails.\n+      --  Now we attempt the allocation of subtrees. The invariants are\n+      --  satisfied even if the allocation fails.\n \n       Copy_Children (Source, Root_Node (Container), Target_Count);\n       pragma Assert (Target_Count = Source_Count);\n@@ -180,11 +179,10 @@ package body Ada.Containers.Multiway_Trees is\n          raise Program_Error with \"Position cursor not in container\";\n       end if;\n \n-      --  AI-0136 says to raise PE if Position equals the root node.\n-      --  This does not seem correct, as this value is just the limiting\n-      --  condition of the search.  For now we omit this check,\n-      --  pending a ruling from the ARG.  ???\n-      --\n+      --  AI-0136 says to raise PE if Position equals the root node. This does\n+      --  not seem correct, as this value is just the limiting condition of the\n+      --  search. For now we omit this check, pending a ruling from the ARG.???\n+\n       --  if Is_Root (Position) then\n       --     raise Program_Error with \"Position cursor designates root\";\n       --  end if;\n@@ -238,7 +236,9 @@ package body Ada.Containers.Multiway_Trees is\n       Last := First;\n \n       for J in Count_Type'(2) .. Count loop\n+\n          --  Reclaim other nodes if Storage_Error.  ???\n+\n          Last.Next := new Tree_Node_Type'(Parent  => Parent.Node,\n                                           Prev    => Last,\n                                           Element => New_Item,\n@@ -253,10 +253,9 @@ package body Ada.Containers.Multiway_Trees is\n          Parent => Parent.Node,\n          Before => null);  -- null means \"insert at end of list\"\n \n-      --  In order for operation Node_Count to complete\n-      --  in O(1) time, we cache the count value. Here we\n-      --  increment the total count by the number of nodes\n-      --  we just inserted.\n+      --  In order for operation Node_Count to complete in O(1) time, we cache\n+      --  the count value. Here we increment the total count by the number of\n+      --  nodes we just inserted.\n \n       Container.Count := Container.Count + Count;\n    end Append_Child;\n@@ -276,16 +275,15 @@ package body Ada.Containers.Multiway_Trees is\n \n       Target.Clear;  -- checks busy bit\n \n-      --  Copy_Children returns the number of nodes that it allocates,\n-      --  but it does this by incrementing the count value passed in,\n-      --  so we must initialize the count before calling Copy_Children.\n+      --  Copy_Children returns the number of nodes that it allocates, but it\n+      --  does this by incrementing the count value passed in, so we must\n+      --  initialize the count before calling Copy_Children.\n \n       Target_Count := 0;\n \n-      --  Note that Copy_Children inserts the newly-allocated children\n-      --  into their parent list only after the allocation of all the\n-      --  children has succeeded. This preserves invariants even if\n-      --  the allocation fails.\n+      --  Note that Copy_Children inserts the newly-allocated children into\n+      --  their parent list only after the allocation of all the children has\n+      --  succeeded. This preserves invariants even if the allocation fails.\n \n       Copy_Children (Source.Root.Children, Root_Node (Target), Target_Count);\n       pragma Assert (Target_Count = Source_Count);\n@@ -306,28 +304,25 @@ package body Ada.Containers.Multiway_Trees is\n            with \"attempt to tamper with cursors (tree is busy)\";\n       end if;\n \n-      --  We first set the container count to 0, in order to\n-      --  preserve invariants in case the deallocation fails.\n-      --  (This works because Deallocate_Children immediately\n-      --  removes the children from their parent, and then\n-      --  does the actual deallocation.)\n+      --  We first set the container count to 0, in order to preserve\n+      --  invariants in case the deallocation fails. (This works because\n+      --  Deallocate_Children immediately removes the children from their\n+      --  parent, and then does the actual deallocation.)\n \n       Container_Count := Container.Count;\n       Container.Count := 0;\n \n-      --  Deallocate_Children returns the number of nodes that\n-      --  it deallocates, but it does this by incrementing the\n-      --  count value that is passed in, so we must first initialize\n-      --  the count return value before calling it.\n+      --  Deallocate_Children returns the number of nodes that it deallocates,\n+      --  but it does this by incrementing the count value that is passed in,\n+      --  so we must first initialize the count return value before calling it.\n \n       Children_Count := 0;\n \n-      --  See comment above.  Deallocate_Children immediately\n-      --  removes the children list from their parent node (here,\n-      --  the root of the tree), and only after that does it\n-      --  attempt the actual deallocation.  So even if the\n-      --  deallocation fails, the representation invariants\n-      --  for the tree are preserved.\n+      --  See comment above. Deallocate_Children immediately removes the\n+      --  children list from their parent node (here, the root of the tree),\n+      --  and only after that does it attempt the actual deallocation. So even\n+      --  if the deallocation fails, the representation invariants for the tree\n+      --  are preserved.\n \n       Deallocate_Children (Root_Node (Container), Children_Count);\n       pragma Assert (Children_Count = Container_Count);\n@@ -378,9 +373,8 @@ package body Ada.Containers.Multiway_Trees is\n       C  : Tree_Node_Access;\n \n    begin\n-      --  We special-case the first allocation, in order\n-      --  to establish the representation invariants\n-      --  for type Children_Type.\n+      --  We special-case the first allocation, in order to establish the\n+      --  representation invariants for type Children_Type.\n \n       C := Source.First;\n \n@@ -396,9 +390,8 @@ package body Ada.Containers.Multiway_Trees is\n \n       CC.Last := CC.First;\n \n-      --  The representation invariants for the Children_Type\n-      --  list have been established, so we can now copy\n-      --  the remaining children of Source.\n+      --  The representation invariants for the Children_Type list have been\n+      --  established, so we can now copy the remaining children of Source.\n \n       C := C.Next;\n       while C /= null loop\n@@ -414,9 +407,8 @@ package body Ada.Containers.Multiway_Trees is\n          C := C.Next;\n       end loop;\n \n-      --  We add the newly-allocated children to their parent list\n-      --  only after the allocation has succeeded, in order to\n-      --  preserve invariants of the parent.\n+      --  Add the newly-allocated children to their parent list only after the\n+      --  allocation has succeeded, so as to preserve invariants of the parent.\n \n       Parent.Children := CC;\n    end Copy_Children;\n@@ -445,6 +437,7 @@ package body Ada.Containers.Multiway_Trees is\n          Result := Result + 1;\n          Node := Node.Next;\n       end loop;\n+\n       return Result;\n    end Child_Count;\n \n@@ -479,6 +472,7 @@ package body Ada.Containers.Multiway_Trees is\n             raise Program_Error with \"Parent is not ancestor of Child\";\n          end if;\n       end loop;\n+\n       return Result;\n    end Child_Depth;\n \n@@ -522,10 +516,10 @@ package body Ada.Containers.Multiway_Trees is\n          raise Constraint_Error with \"Source cursor designates root\";\n       end if;\n \n-      --  Copy_Subtree returns a count of the number of nodes\n-      --  that it allocates, but it works by incrementing the\n-      --  value that is passed in. We must therefore initialize\n-      --  the count value before calling Copy_Subtree.\n+      --  Copy_Subtree returns a count of the number of nodes that it\n+      --  allocates, but it works by incrementing the value that is passed\n+      --  in. We must therefore initialize the count value before calling\n+      --  Copy_Subtree.\n \n       Target_Count := 0;\n \n@@ -544,10 +538,9 @@ package body Ada.Containers.Multiway_Trees is\n          Parent  => Parent.Node,\n          Before  => Before.Node);\n \n-      --  In order for operation Node_Count to complete\n-      --  in O(1) time, we cache the count value. Here we\n-      --  increment the total count by the number of nodes\n-      --  we just inserted.\n+      --  In order for operation Node_Count to complete in O(1) time, we cache\n+      --  the count value. Here we increment the total count by the number of\n+      --  nodes we just inserted.\n \n       Target.Count := Target.Count + Target_Count;\n    end Copy_Subtree;\n@@ -585,9 +578,8 @@ package body Ada.Containers.Multiway_Trees is\n       C  : Tree_Node_Access;\n \n    begin\n-      --  We immediately remove the children from their\n-      --  parent, in order to preserve invariants in case\n-      --  the deallocation fails.\n+      --  We immediately remove the children from their parent, in order to\n+      --  preserve invariants in case the deallocation fails.\n \n       Subtree.Children := Children_Type'(others => null);\n \n@@ -637,10 +629,10 @@ package body Ada.Containers.Multiway_Trees is\n            with \"attempt to tamper with cursors (tree is busy)\";\n       end if;\n \n-      --  Deallocate_Children returns a count of the number of nodes\n-      --  that it deallocates, but it works by incrementing the\n-      --  value that is passed in. We must therefore initialize\n-      --  the count value before calling Deallocate_Children.\n+      --  Deallocate_Children returns a count of the number of nodes that it\n+      --  deallocates, but it works by incrementing the value that is passed\n+      --  in. We must therefore initialize the count value before calling\n+      --  Deallocate_Children.\n \n       Count := 0;\n \n@@ -685,16 +677,15 @@ package body Ada.Containers.Multiway_Trees is\n       X := Position.Node;\n       Position := No_Element;\n \n-      --  Restore represention invariants before attempting the\n-      --  actual deallocation.\n+      --  Restore represention invariants before attempting the actual\n+      --  deallocation.\n \n       Remove_Subtree (X);\n       Container.Count := Container.Count - 1;\n \n-      --  It is now safe to attempt the deallocation.  This leaf\n-      --  node has been disassociated from the tree, so even if\n-      --  the deallocation fails, representation invariants\n-      --  will remain satisfied.\n+      --  It is now safe to attempt the deallocation. This leaf node has been\n+      --  disassociated from the tree, so even if the deallocation fails,\n+      --  representation invariants will remain satisfied.\n \n       Deallocate_Node (X);\n    end Delete_Leaf;\n@@ -731,38 +722,35 @@ package body Ada.Containers.Multiway_Trees is\n       X := Position.Node;\n       Position := No_Element;\n \n-      --  Here is one case where a deallocation failure can\n-      --  result in the violation of a representation invariant.\n-      --  We disassociate the subtree from the tree now, but we\n-      --  only decrement the total node count after we attempt\n-      --  the deallocation. However, if the deallocation fails,\n-      --  the total node count will not get decremented.\n-      --\n-      --  One way around this dilemma is to count the nodes\n-      --  in the subtree before attempt to delete the subtree,\n-      --  but that is an O(n) operation, so it does not seem\n-      --  worth it.\n-      --\n-      --  Perhaps this is much ado about nothing, since the\n-      --  only way deallocation can fail is if Controlled\n-      --  Finalization fails: this propagates Program_Error\n-      --  so all bets are off anyway.  ???\n+      --  Here is one case where a deallocation failure can result in the\n+      --  violation of a representation invariant. We disassociate the subtree\n+      --  from the tree now, but we only decrement the total node count after\n+      --  we attempt the deallocation. However, if the deallocation fails, the\n+      --  total node count will not get decremented.\n+\n+      --  One way around this dilemma is to count the nodes in the subtree\n+      --  before attempt to delete the subtree, but that is an O(n) operation,\n+      --  so it does not seem worth it.\n+\n+      --  Perhaps this is much ado about nothing, since the only way\n+      --  deallocation can fail is if Controlled Finalization fails: this\n+      --  propagates Program_Error so all bets are off anyway. ???\n \n       Remove_Subtree (X);\n \n-      --  Deallocate_Subtree returns a count of the number of nodes\n-      --  that it deallocates, but it works by incrementing the\n-      --  value that is passed in. We must therefore initialize\n-      --  the count value before calling Deallocate_Subtree.\n+      --  Deallocate_Subtree returns a count of the number of nodes that it\n+      --  deallocates, but it works by incrementing the value that is passed\n+      --  in. We must therefore initialize the count value before calling\n+      --  Deallocate_Subtree.\n \n       Count := 0;\n \n       Deallocate_Subtree (X, Count);\n       pragma Assert (Count <= Container.Count);\n \n-      --  See comments above. We would prefer to do this\n-      --  sooner, but there's no way to satisfy that goal\n-      --  without an potentially severe execution penalty.\n+      --  See comments above. We would prefer to do this sooner, but there's no\n+      --  way to satisfy that goal without a potentially severe execution\n+      --  penalty.\n \n       Container.Count := Container.Count - Count;\n    end Delete_Subtree;\n@@ -782,6 +770,7 @@ package body Ada.Containers.Multiway_Trees is\n          N := N.Parent;\n          Result := Result + 1;\n       end loop;\n+\n       return Result;\n    end Depth;\n \n@@ -1080,7 +1069,9 @@ package body Ada.Containers.Multiway_Trees is\n       Last := Position.Node;\n \n       for J in Count_Type'(2) .. Count loop\n+\n          --  Reclaim other nodes if Storage_Error.  ???\n+\n          Last.Next := new Tree_Node_Type'(Parent  => Parent.Node,\n                                           Prev    => Last,\n                                           Element => New_Item,\n@@ -1095,10 +1086,9 @@ package body Ada.Containers.Multiway_Trees is\n          Parent => Parent.Node,\n          Before => Before.Node);\n \n-      --  In order for operation Node_Count to complete\n-      --  in O(1) time, we cache the count value. Here we\n-      --  increment the total count by the number of nodes\n-      --  we just inserted.\n+      --  In order for operation Node_Count to complete in O(1) time, we cache\n+      --  the count value. Here we increment the total count by the number of\n+      --  nodes we just inserted.\n \n       Container.Count := Container.Count + Count;\n    end Insert_Child;\n@@ -1149,7 +1139,9 @@ package body Ada.Containers.Multiway_Trees is\n       Last := Position.Node;\n \n       for J in Count_Type'(2) .. Count loop\n+\n          --  Reclaim other nodes if Storage_Error.  ???\n+\n          Last.Next := new Tree_Node_Type'(Parent  => Parent.Node,\n                                           Prev    => Last,\n                                           Element => <>,\n@@ -1164,10 +1156,9 @@ package body Ada.Containers.Multiway_Trees is\n          Parent => Parent.Node,\n          Before => Before.Node);\n \n-      --  In order for operation Node_Count to complete\n-      --  in O(1) time, we cache the count value. Here we\n-      --  increment the total count by the number of nodes\n-      --  we just inserted.\n+      --  In order for operation Node_Count to complete in O(1) time, we cache\n+      --  the count value. Here we increment the total count by the number of\n+      --  nodes we just inserted.\n \n       Container.Count := Container.Count + Count;\n    end Insert_Child;\n@@ -1186,11 +1177,10 @@ package body Ada.Containers.Multiway_Trees is\n       C : Children_Type renames Parent.Children;\n \n    begin\n-      --  This is a simple utility operation to\n-      --  insert a list of nodes (from First..Last)\n-      --  as children of Parent. The Before node\n-      --  specifies where the new children should be\n-      --  inserted relative to the existing children.\n+      --  This is a simple utility operation to insert a list of nodes (from\n+      --  First..Last) as children of Parent. The Before node specifies where\n+      --  the new children should be inserted relative to the existing\n+      --  children.\n \n       if First = null then\n          pragma Assert (Last = null);\n@@ -1236,8 +1226,8 @@ package body Ada.Containers.Multiway_Trees is\n       Before  : Tree_Node_Access)\n    is\n    begin\n-      --  This is a simple wrapper operation to insert\n-      --  a single child into the Parent's children list.\n+      --  This is a simple wrapper operation to insert a single child into the\n+      --  Parent's children list.\n \n       Insert_Subtree_List\n         (First  => Subtree,\n@@ -1324,6 +1314,7 @@ package body Ada.Containers.Multiway_Trees is\n          Process   => Process);\n \n       B := B - 1;\n+\n    exception\n       when others =>\n          B := B - 1;\n@@ -1357,6 +1348,7 @@ package body Ada.Containers.Multiway_Trees is\n          end loop;\n \n          B := B - 1;\n+\n       exception\n          when others =>\n             B := B - 1;\n@@ -1372,13 +1364,11 @@ package body Ada.Containers.Multiway_Trees is\n       Node : Tree_Node_Access;\n \n    begin\n-      --  This is a helper function to recursively iterate over\n-      --  all the nodes in a subtree, in depth-first fashion.\n-      --  This particular helper just visits the children of this\n-      --  subtree, not the root of the subtree node itself.  This\n-      --  is useful when starting from the ultimate root of the\n-      --  entire tree (see Iterate), as that root does not have\n-      --  an element.\n+      --  This is a helper function to recursively iterate over all the nodes\n+      --  in a subtree, in depth-first fashion. This particular helper just\n+      --  visits the children of this subtree, not the root of the subtree node\n+      --  itself. This is useful when starting from the ultimate root of the\n+      --  entire tree (see Iterate), as that root does not have an element.\n \n       Node := Subtree.Children.First;\n       while Node /= null loop\n@@ -1414,6 +1404,7 @@ package body Ada.Containers.Multiway_Trees is\n          end if;\n \n          B := B - 1;\n+\n       exception\n          when others =>\n             B := B - 1;\n@@ -1427,10 +1418,9 @@ package body Ada.Containers.Multiway_Trees is\n       Process   : not null access procedure (Position : Cursor))\n    is\n    begin\n-      --  This is a helper function to recursively iterate over\n-      --  all the nodes in a subtree, in depth-first fashion.\n-      --  It first visits the root of the subtree, then visits\n-      --  its children.\n+      --  This is a helper function to recursively iterate over all the nodes\n+      --  in a subtree, in depth-first fashion. It first visits the root of the\n+      --  subtree, then visits its children.\n \n       Process (Cursor'(Container, Subtree));\n       Iterate_Children (Container, Subtree, Process);\n@@ -1526,17 +1516,15 @@ package body Ada.Containers.Multiway_Trees is\n \n    function Node_Count (Container : Tree) return Count_Type is\n    begin\n-      --  Container.Count is the number of nodes we have actually\n-      --  allocated. We cache the value specifically so this Node_Count\n-      --  operation can execute in O(1) time, which makes it behave\n-      --  similarly to how the Length selector function behaves\n-      --  for other containers.\n-      --\n-      --  The cached node count value only describes the nodes\n-      --  we have allocated; the root node itself is not included\n-      --  in that count. The Node_Count operation returns a value\n-      --  that includes the root node (because the RM says so), so we\n-      --  must add 1 to our cached value.\n+      --  Container.Count is the number of nodes we have actually allocated. We\n+      --  cache the value specifically so this Node_Count operation can execute\n+      --  in O(1) time, which makes it behave similarly to how the Length\n+      --  selector function behaves for other containers.\n+\n+      --  The cached node count value only describes the nodes we have\n+      --  allocated; the root node itself is not included in that count. The\n+      --  Node_Count operation returns a value that includes the root node\n+      --  (because the RM says so), so we must add 1 to our cached value.\n \n       return 1 + Container.Count;\n    end Node_Count;\n@@ -1595,7 +1583,9 @@ package body Ada.Containers.Multiway_Trees is\n       Last := First;\n \n       for J in Count_Type'(2) .. Count loop\n+\n          --  Reclaim other nodes if Storage_Error.  ???\n+\n          Last.Next := new Tree_Node_Type'(Parent  => Parent.Node,\n                                           Prev    => Last,\n                                           Element => New_Item,\n@@ -1610,10 +1600,9 @@ package body Ada.Containers.Multiway_Trees is\n          Parent => Parent.Node,\n          Before => Parent.Node.Children.First);\n \n-      --  In order for operation Node_Count to complete\n-      --  in O(1) time, we cache the count value. Here we\n-      --  increment the total count by the number of nodes\n-      --  we just inserted.\n+      --  In order for operation Node_Count to complete in O(1) time, we cache\n+      --  the count value. Here we increment the total count by the number of\n+      --  nodes we just inserted.\n \n       Container.Count := Container.Count + Count;\n    end Prepend_Child;\n@@ -1670,6 +1659,7 @@ package body Ada.Containers.Multiway_Trees is\n \n          L := L - 1;\n          B := B - 1;\n+\n       exception\n          when others =>\n             L := L - 1;\n@@ -1725,8 +1715,8 @@ package body Ada.Containers.Multiway_Trees is\n             C.Last := C.Last.Next;\n          end loop;\n \n-         --  Now that the allocation and reads have completed successfully,\n-         --  it is safe to link the children to their parent.\n+         --  Now that the allocation and reads have completed successfully, it\n+         --  is safe to link the children to their parent.\n \n          Subtree.Children := C;\n       end Read_Children;\n@@ -1878,6 +1868,7 @@ package body Ada.Containers.Multiway_Trees is\n          end loop;\n \n          B := B - 1;\n+\n       exception\n          when others =>\n             B := B - 1;\n@@ -1909,11 +1900,11 @@ package body Ada.Containers.Multiway_Trees is\n    --  Start of processing for Root_Node\n \n    begin\n-      --  This is a utility function for converting from an access type\n-      --  that designates the distinguished root node to an access type\n-      --  designating a non-root node. The representation of a root node\n-      --  does not have an element, but is otherwise identical to a\n-      --  non-root node, so the conversion itself is safe.\n+      --  This is a utility function for converting from an access type that\n+      --  designates the distinguished root node to an access type designating\n+      --  a non-root node. The representation of a root node does not have an\n+      --  element, but is otherwise identical to a non-root node, so the\n+      --  conversion itself is safe.\n \n       return To_Tree_Node_Access (Container.Root'Unrestricted_Access);\n    end Root_Node;\n@@ -1997,10 +1988,10 @@ package body Ada.Containers.Multiway_Trees is\n            with \"attempt to tamper with cursors (Source tree is busy)\";\n       end if;\n \n-      --  We cache the count of the nodes we have allocated, so that\n-      --  operation Node_Count can execute in O(1) time. But that means\n-      --  we must count the nodes in the subtree we remove from Source\n-      --  and insert into Target, in order to keep the count accurate.\n+      --  We cache the count of the nodes we have allocated, so that operation\n+      --  Node_Count can execute in O(1) time. But that means we must count the\n+      --  nodes in the subtree we remove from Source and insert into Target, in\n+      --  order to keep the count accurate.\n \n       Count := Subtree_Node_Count (Source_Parent.Node);\n       pragma Assert (Count >= 1);\n@@ -2183,17 +2174,16 @@ package body Ada.Containers.Multiway_Trees is\n            with \"attempt to tamper with cursors (Source tree is busy)\";\n       end if;\n \n-      --  This is an unfortunate feature of this API: we must count\n-      --  the nodes in the subtree that we remove from the source tree,\n-      --  which is an O(n) operation. It would have been better if\n-      --  the Tree container did not have a Node_Count selector; a\n-      --  user that wants the number of nodes in the tree could\n-      --  simply call Subtree_Node_Count, with the understanding that\n-      --  such an operation is O(n).\n-      --\n-      --  Of course, we could choose to implement the Node_Count selector\n-      --  as an O(n) operation, which would turn this splice operation\n-      --  into an O(1) operation.  ???\n+      --  This is an unfortunate feature of this API: we must count the nodes\n+      --  in the subtree that we remove from the source tree, which is an O(n)\n+      --  operation. It would have been better if the Tree container did not\n+      --  have a Node_Count selector; a user that wants the number of nodes in\n+      --  the tree could simply call Subtree_Node_Count, with the understanding\n+      --  that such an operation is O(n).\n+\n+      --  Of course, we could choose to implement the Node_Count selector as an\n+      --  O(n) operation, which would turn this splice operation into an O(1)\n+      --  operation. ???\n \n       Subtree_Count := Subtree_Node_Count (Position.Node);\n       pragma Assert (Subtree_Count <= Source.Count);\n@@ -2243,7 +2233,9 @@ package body Ada.Containers.Multiway_Trees is\n       end if;\n \n       if Is_Root (Position) then\n+\n          --  Should this be PE instead?  Need ARG confirmation.  ???\n+\n          raise Constraint_Error with \"Position cursor designates root\";\n       end if;\n \n@@ -2294,6 +2286,7 @@ package body Ada.Containers.Multiway_Trees is\n          Result := Result + Subtree_Node_Count (Node);\n          Node := Node.Next;\n       end loop;\n+\n       return Result;\n    end Subtree_Node_Count;\n \n@@ -2383,6 +2376,7 @@ package body Ada.Containers.Multiway_Trees is\n \n          L := L - 1;\n          B := B - 1;\n+\n       exception\n          when others =>\n             L := L - 1;"}, {"sha": "6a9cfdecee1c00bd513c8871c596b5c82fc6a406", "filename": "gcc/ada/a-comutr.ads", "status": "modified", "additions": 31, "deletions": 35, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fa-comutr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fa-comutr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comutr.ads?ref=dedac3eb7331f441f24b192fa0d9d1e1162f57ba", "patch": "@@ -238,8 +238,8 @@ package Ada.Containers.Multiway_Trees is\n    --     Parent    : Cursor;\n    --     Process   : not null access procedure (Position : Cursor));\n    --\n-   --  It seems that the Container parameter is there by mistake, but\n-   --  we need an official ruling from the ARG.  ???\n+   --  It seems that the Container parameter is there by mistake, but we need\n+   --  an official ruling from the ARG. ???\n \n    procedure Iterate_Children\n      (Parent  : Cursor;\n@@ -251,29 +251,29 @@ package Ada.Containers.Multiway_Trees is\n \n private\n \n-   --  A node of this multiway tree comprises an element and a list of\n-   --  children (that are themselves trees).  The root node is distinguished\n-   --  because it contains only children: it does not have an element itself.\n+   --  A node of this multiway tree comprises an element and a list of children\n+   --  (that are themselves trees). The root node is distinguished because it\n+   --  contains only children: it does not have an element itself.\n    --\n    --  This design feature puts two design goals in tension:\n    --   (1) treat the root node the same as any other node\n    --   (2) not declare any objects of type Element_Type unnecessarily\n    --\n-   --  To satisfy (1), we could simply declare the Root node of the tree\n-   --  using the normal Tree_Node_Type, but that would mean that (2) is not\n+   --  To satisfy (1), we could simply declare the Root node of the tree using\n+   --  the normal Tree_Node_Type, but that would mean that (2) is not\n    --  satisfied. To resolve the tension (in favor of (2)), we declare the\n    --  component Root as having a different node type, without an Element\n-   --  component (thus satisfying goal (2)) but otherwise identical to a\n-   --  normal node, and then use Unchecked_Conversion to convert an access\n-   --  object designating the Root node component to the access type\n-   --  designating a normal, non-root node (thus satisfying goal (1)). We make\n-   --  an explicit check for Root when there is any attempt to manipulate the\n-   --  Element component of the node (a check required by the RM anyway).\n+   --  component (thus satisfying goal (2)) but otherwise identical to a normal\n+   --  node, and then use Unchecked_Conversion to convert an access object\n+   --  designating the Root node component to the access type designating a\n+   --  normal, non-root node (thus satisfying goal (1)). We make an explicit\n+   --  check for Root when there is any attempt to manipulate the Element\n+   --  component of the node (a check required by the RM anyway).\n    --\n    --  In order to be explicit about node (and pointer) representation, we\n-   --  specify that the respective node types have convention C, to ensure\n-   --  that the layout of the components of the node records is the same,\n-   --  thus guaranteeing that (unchecked) conversions between access types\n+   --  specify that the respective node types have convention C, to ensure that\n+   --  the layout of the components of the node records is the same, thus\n+   --  guaranteeing that (unchecked) conversions between access types\n    --  designating each kind of node type is a meaningful conversion.\n \n    type Tree_Node_Type;\n@@ -285,9 +285,8 @@ private\n       Last  : Tree_Node_Access;\n    end record;\n \n-   --  See the comment above.  This declaration must exactly\n-   --  match the declaration of Root_Node_Type (except for\n-   --  the Element component).\n+   --  See the comment above. This declaration must exactly match the\n+   --  declaration of Root_Node_Type (except for the Element component).\n \n    type Tree_Node_Type is record\n       Parent   : Tree_Node_Access;\n@@ -298,9 +297,8 @@ private\n    end record;\n    pragma Convention (C, Tree_Node_Type);\n \n-   --  See the comment above.  This declaration must match\n-   --  the declaration of Tree_Node_Type (except for the\n-   --  Element component).\n+   --  See the comment above. This declaration must match the declaration of\n+   --  Tree_Node_Type (except for the Element component).\n \n    type Root_Node_Type is record\n       Parent   : Tree_Node_Access;\n@@ -312,19 +310,17 @@ private\n \n    use Ada.Finalization;\n \n-   --  The Count component of type Tree represents the number of\n-   --  nodes that have been (dynamically) allocated.  It does not\n-   --  include the root node itself.  As implementors, we decide\n-   --  to cache this value, so that the selector function Node_Count\n-   --  can execute in O(1) time, in order to be consistent with\n-   --  the behavior of the Length selector function for other\n-   --  standard container library units. This does mean, however,\n-   --  that the two-container forms for Splice_XXX (that move subtrees\n-   --  across tree containers) will execute in O(n) time, because\n-   --  we must count the number of nodes in the subtree(s) that\n-   --  get moved.  (We resolve the tension between Node_Count\n-   --  and Splice_XXX in favor of Node_Count, under the assumption\n-   --  that Node_Count is the more common operation).\n+   --  The Count component of type Tree represents the number of nodes that\n+   --  have been (dynamically) allocated. It does not include the root node\n+   --  itself. As implementors, we decide to cache this value, so that the\n+   --  selector function Node_Count can execute in O(1) time, in order to be\n+   --  consistent with the behavior of the Length selector function for other\n+   --  standard container library units. This does mean, however, that the\n+   --  two-container forms for Splice_XXX (that move subtrees across tree\n+   --  containers) will execute in O(n) time, because we must count the number\n+   --  of nodes in the subtree(s) that get moved. (We resolve the tension\n+   --  between Node_Count and Splice_XXX in favor of Node_Count, under the\n+   --  assumption that Node_Count is the more common operation).\n \n    type Tree is new Controlled with record\n       Root  : aliased Root_Node_Type;"}, {"sha": "3759e712e0b00c38e3cfb3f91b7f1b86dac6412c", "filename": "gcc/ada/a-fihema.adb", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fa-fihema.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fa-fihema.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-fihema.adb?ref=dedac3eb7331f441f24b192fa0d9d1e1162f57ba", "patch": "@@ -67,11 +67,10 @@ package body Ada.Finalization.Heap_Management is\n    procedure Fin_Assert (Condition : Boolean; Message : String);\n    --  Asserts that the condition is True. Used instead of pragma Assert in\n    --  delicate places where raising an exception would cause re-invocation of\n-   --  finalization. Instead of raising an exception, aborts the whole\n-   --  process.\n+   --  finalization. Instead of raising an exception, aborts the whole process.\n \n    function Is_Empty (Objects : Node_Ptr) return Boolean;\n-   --  True if the Objects list is empty.\n+   --  True if the Objects list is empty\n \n    ----------------\n    -- Fin_Assert --\n@@ -194,6 +193,7 @@ package body Ada.Finalization.Heap_Management is\n \n       --  Note: no need to unlock in case of exceptions; the above code cannot\n       --  raise any.\n+\n    end Attach;\n \n    ---------------\n@@ -279,8 +279,10 @@ package body Ada.Finalization.Heap_Management is\n       end if;\n \n       Unlock_Task.all;\n+\n       --  Note: no need to unlock in case of exceptions; the above code cannot\n       --  raise any.\n+\n    end Detach;\n \n    --------------\n@@ -305,9 +307,12 @@ package body Ada.Finalization.Heap_Management is\n       --  modified.\n \n       if Collection.Finalization_Started then\n-         --  ???Needed for shared libraries.\n+\n+         --  ???Needed for shared libraries\n+\n          return;\n       end if;\n+\n       pragma Debug (Fin_Assert (not Collection.Finalization_Started,\n                                 \"Finalize: already started\"));\n       Collection.Finalization_Started := True;\n@@ -340,7 +345,6 @@ package body Ada.Finalization.Heap_Management is\n \n                begin\n                   Collection.Finalize_Address (Object_Address);\n-\n                exception\n                   when Fin_Except : others =>\n                      if not Raised then\n@@ -403,7 +407,7 @@ package body Ada.Finalization.Heap_Management is\n    procedure pcol (Collection : Finalization_Collection) is\n       Head      : constant Node_Ptr := Collection.Objects'Unrestricted_Access;\n       --  \"Unrestricted\", because we are getting access-to-variable of a\n-      --  constant!  Normally worrisome, this is OK for debugging code.\n+      --  constant! Normally worrisome, this is OK for debugging code.\n \n       Head_Seen : Boolean := False;\n       N_Ptr     : Node_Ptr;"}, {"sha": "99dd304a4e9ec409e7ab57f19667932ac5b9306e", "filename": "gcc/ada/a-iteint.ads", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fa-iteint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fa-iteint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-iteint.ads?ref=dedac3eb7331f441f24b192fa0d9d1e1162f57ba", "patch": "@@ -6,41 +6,32 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2011, Free Software Foundation, Inc.           --\n---                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n generic\n    type Cursor is private;\n    No_Element : Cursor;\n    pragma Unreferenced (No_Element);\n+\n package Ada.Iterator_Interfaces is\n    type Forward_Iterator is limited interface;\n+\n    function First (Object : Forward_Iterator) return Cursor is abstract;\n-   function Next (Object : Forward_Iterator; Position : Cursor) return Cursor\n-     is abstract;\n+\n+   function Next\n+     (Object : Forward_Iterator;\n+      Position : Cursor) return Cursor is abstract;\n+\n    type Reversible_Iterator is limited interface and Forward_Iterator;\n+\n    function Last (Object : Reversible_Iterator) return Cursor is abstract;\n-   function Previous (Object : Reversible_Iterator; Position : Cursor)\n-     return Cursor is abstract;\n+\n+   function Previous\n+     (Object : Reversible_Iterator;\n+      Position : Cursor) return Cursor is abstract;\n end Ada.Iterator_Interfaces;"}, {"sha": "e7614aa8ac1feb0dd4897aa45dec7bac046a9ff5", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=dedac3eb7331f441f24b192fa0d9d1e1162f57ba", "patch": "@@ -7870,8 +7870,8 @@ package body Exp_Disp is\n       First_Prim : constant Elmt_Id := First_Elmt (Primitive_Operations (Typ));\n       The_Tag    : constant Entity_Id := First_Tag_Component (Typ);\n \n-      Adjusted   : Boolean := False;\n-      Finalized  : Boolean := False;\n+      Adjusted  : Boolean := False;\n+      Finalized : Boolean := False;\n \n       Count_Prim : Nat;\n       DT_Length  : Nat;"}, {"sha": "58c4eccadb848834305fdeafa09be3c90dc7ca97", "filename": "gcc/ada/lib-xref-alfa.adb", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Flib-xref-alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Flib-xref-alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-alfa.adb?ref=dedac3eb7331f441f24b192fa0d9d1e1162f57ba", "patch": "@@ -877,12 +877,11 @@ package body ALFA is\n \n    procedure Detect_And_Add_ALFA_Scope (N : Node_Id) is\n    begin\n-      if Nkind_In (N,\n-                   N_Subprogram_Declaration,\n-                   N_Subprogram_Body,\n-                   N_Subprogram_Body_Stub,\n-                   N_Package_Declaration,\n-                   N_Package_Body)\n+      if Nkind_In (N, N_Subprogram_Declaration,\n+                      N_Subprogram_Body,\n+                      N_Subprogram_Body_Stub,\n+                      N_Package_Declaration,\n+                      N_Package_Body)\n       then\n          Add_ALFA_Scope (N);\n       end if;"}, {"sha": "b50327304d2822867b2491d6fe420720a160af32", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=dedac3eb7331f441f24b192fa0d9d1e1162f57ba", "patch": "@@ -174,7 +174,8 @@ package body Lib.Xref is\n \n             when N_Pragma =>\n                if Get_Pragma_Id (Result) = Pragma_Precondition\n-                 or else Get_Pragma_Id (Result) = Pragma_Postcondition\n+                    or else\n+                  Get_Pragma_Id (Result) = Pragma_Postcondition\n                then\n                   return Empty;\n                else"}, {"sha": "5a8a6956d6082de64db20bd59673076a3d455b37", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=dedac3eb7331f441f24b192fa0d9d1e1162f57ba", "patch": "@@ -893,6 +893,7 @@ package body Par_SCO is\n       if Index /= 0 then\n          declare\n             T : SCO_Table_Entry renames SCO_Table.Table (Index);\n+\n          begin\n             --  Called multiple times for the same sloc (need to allow for\n             --  C2 = 'P') ???\n@@ -1080,7 +1081,7 @@ package body Par_SCO is\n                SCE         : SC_Entry renames SC.Table (J);\n                Pragma_Sloc : Source_Ptr := No_Location;\n             begin\n-               --  For the statement SCO for a pragma controlled by\n+               --  For the case of a statement SCO for a pragma controlled by\n                --  Set_SCO_Pragma_Enable, set Pragma_Sloc so that the SCO (and\n                --  those of any nested decision) is emitted only if the pragma\n                --  is enabled.\n@@ -1506,10 +1507,9 @@ package body Par_SCO is\n                         when N_Generic_Instantiation         =>\n                            Typ := 'i';\n \n-                        when\n-                          N_Representation_Clause            |\n-                          N_Use_Package_Clause               |\n-                          N_Use_Type_Clause                  =>\n+                        when N_Representation_Clause         |\n+                             N_Use_Package_Clause            |\n+                             N_Use_Type_Clause               =>\n                            Typ := ASCII.NUL;\n \n                         when others                          =>"}, {"sha": "61a675856b9b595a8a063615e0cdc669aa9acf67", "filename": "gcc/ada/scos.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fscos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fscos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscos.ads?ref=dedac3eb7331f441f24b192fa0d9d1e1162f57ba", "patch": "@@ -339,7 +339,7 @@ package SCOs is\n \n    --  Disabled pragmas\n \n-   --    No SCO is generated for disabled pragmas.\n+   --    No SCO is generated for disabled pragmas\n \n    ---------------------------------------------------------------------\n    -- Internal table used to store Source Coverage Obligations (SCOs) --"}, {"sha": "a393680094e505b467881df381c3b955f94d04e7", "filename": "gcc/ada/sem_ch11.adb", "status": "modified", "additions": 38, "deletions": 9, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fsem_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fsem_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch11.adb?ref=dedac3eb7331f441f24b192fa0d9d1e1162f57ba", "patch": "@@ -432,6 +432,7 @@ package body Sem_Ch11 is\n       Exception_Id   : constant Node_Id := Name (N);\n       Exception_Name : Entity_Id        := Empty;\n       P              : Node_Id;\n+      Par            : Node_Id;\n \n    begin\n       Check_SPARK_Restriction (\"raise statement is not allowed\", N);\n@@ -443,9 +444,9 @@ package body Sem_Ch11 is\n          Check_Restriction (No_Exceptions, N);\n       end if;\n \n-      --  Check for useless assignment to OUT or IN OUT scalar immediately\n-      --  preceding the raise. Right now we only look at assignment statements,\n-      --  we could do more.\n+      --  Check for useless assignment to OUT or IN OUT scalar preceding the\n+      --  raise. Right now we only look at assignment statements, we could do\n+      --  more.\n \n       if Is_List_Member (N) then\n          declare\n@@ -455,21 +456,49 @@ package body Sem_Ch11 is\n          begin\n             P := Prev (N);\n \n+            --  Skip past null statements and pragmas\n+\n+            while Present (P)\n+              and then Nkind_In (P, N_Null_Statement, N_Pragma)\n+            loop\n+               P := Prev (P);\n+            end loop;\n+\n+            --  See if preceding statement is an assignment\n+\n             if Present (P)\n               and then Nkind (P) = N_Assignment_Statement\n             then\n                L := Name (P);\n \n+               --  Give warning for assignment to scalar formal\n+\n                if Is_Scalar_Type (Etype (L))\n                  and then Is_Entity_Name (L)\n                  and then Is_Formal (Entity (L))\n                then\n-                  Error_Msg_N\n-                    (\"?assignment to pass-by-copy formal may have no effect\",\n-                      P);\n-                  Error_Msg_N\n-                    (\"\\?RAISE statement may result in abnormal return\" &\n-                     \" (RM 6.4.1(17))\", P);\n+                  --  Don't give warning if we are covered by an exception\n+                  --  handler, since this may result in false positives, since\n+                  --  the handler may handle the exception and return normally.\n+\n+                  --  First find enclosing sequence of statements\n+\n+                  Par := N;\n+                  loop\n+                     Par := Parent (Par);\n+                     exit when Nkind (Par) = N_Handled_Sequence_Of_Statements;\n+                  end loop;\n+\n+                  --  See if there is a handler, give message if not\n+\n+                  if No (Exception_Handlers (Par)) then\n+                     Error_Msg_N\n+                       (\"?assignment to pass-by-copy formal \" &\n+                        \"may have no effect\", P);\n+                     Error_Msg_N\n+                       (\"\\?RAISE statement may result in abnormal return\" &\n+                        \" (RM 6.4.1(17))\", P);\n+                  end if;\n                end if;\n             end if;\n          end;"}, {"sha": "4965938c011aebad86c356a7acc19242421fb602", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=dedac3eb7331f441f24b192fa0d9d1e1162f57ba", "patch": "@@ -3402,14 +3402,14 @@ package body Sem_Ch12 is\n                 and then not Inline_Now\n                 and then not ALFA_Mode\n                 and then (Operating_Mode = Generate_Code\n-                            or else (Operating_Mode = Check_Semantics\n-                                      and then ASIS_Mode));\n+                           or else (Operating_Mode = Check_Semantics\n+                                     and then ASIS_Mode));\n \n             --  If front_end_inlining is enabled, do not instantiate body if\n             --  within a generic context.\n \n             if (Front_End_Inlining\n-                  and then not Expander_Active)\n+                 and then not Expander_Active)\n               or else Is_Generic_Unit (Cunit_Entity (Main_Unit))\n             then\n                Needs_Body := False;\n@@ -3430,10 +3430,10 @@ package body Sem_Ch12 is\n                begin\n                   if Nkind (Decl) = N_Formal_Package_Declaration\n                     or else (Nkind (Decl) = N_Package_Declaration\n-                               and then Is_List_Member (Decl)\n-                               and then Present (Next (Decl))\n-                               and then\n-                                 Nkind (Next (Decl)) =\n+                              and then Is_List_Member (Decl)\n+                              and then Present (Next (Decl))\n+                              and then\n+                                Nkind (Next (Decl)) =\n                                                 N_Formal_Package_Declaration)\n                   then\n                      Needs_Body := False;\n@@ -4014,12 +4014,12 @@ package body Sem_Ch12 is\n    is\n    begin\n       if (Is_In_Main_Unit (N)\n-            or else Is_Inlined (Subp)\n-            or else Is_Inlined (Alias (Subp)))\n+           or else Is_Inlined (Subp)\n+           or else Is_Inlined (Alias (Subp)))\n         and then not ALFA_Mode\n         and then (Operating_Mode = Generate_Code\n-                    or else (Operating_Mode = Check_Semantics\n-                               and then ASIS_Mode))\n+                   or else (Operating_Mode = Check_Semantics\n+                             and then ASIS_Mode))\n         and then (Expander_Active or else ASIS_Mode)\n         and then not ABE_Is_Certain (N)\n         and then not Is_Eliminated (Subp)\n@@ -4033,6 +4033,7 @@ package body Sem_Ch12 is\n              Local_Suppress_Stack_Top => Local_Suppress_Stack_Top,\n              Version                  => Ada_Version));\n          return True;\n+\n       else\n          return False;\n       end if;\n@@ -11892,14 +11893,13 @@ package body Sem_Ch12 is\n          if Present (E) then\n \n             --  If the node is an entry call to an entry in an enclosing task,\n-            --  it is rewritten as a selected component. No global entity\n-            --  to preserve in this case, the expansion will be redone in the\n-            --  instance.\n-\n-            if not Nkind_In (E,\n-              N_Defining_Identifier,\n-              N_Defining_Character_Literal,\n-              N_Defining_Operator_Symbol)\n+            --  it is rewritten as a selected component. No global entity to\n+            --  preserve in this case, since the expansion will be redone in\n+            --  the instance.\n+\n+            if not Nkind_In (E, N_Defining_Identifier,\n+                                N_Defining_Character_Literal,\n+                                N_Defining_Operator_Symbol)\n             then\n                Set_Associated_Node (N, Empty);\n                Set_Etype  (N, Empty);"}, {"sha": "ea54583e7182ed2f738a9c9abb1c46a2b947ca2a", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=dedac3eb7331f441f24b192fa0d9d1e1162f57ba", "patch": "@@ -4243,24 +4243,24 @@ package body Sem_Ch3 is\n                end if;\n \n             when Private_Kind =>\n-               Set_Ekind              (Id, Subtype_Kind (Ekind   (T)));\n-               Set_Has_Discriminants  (Id, Has_Discriminants     (T));\n-               Set_Is_Constrained     (Id, Is_Constrained        (T));\n-               Set_First_Entity       (Id, First_Entity          (T));\n-               Set_Last_Entity        (Id, Last_Entity           (T));\n+               Set_Ekind              (Id, Subtype_Kind (Ekind        (T)));\n+               Set_Has_Discriminants  (Id, Has_Discriminants          (T));\n+               Set_Is_Constrained     (Id, Is_Constrained             (T));\n+               Set_First_Entity       (Id, First_Entity               (T));\n+               Set_Last_Entity        (Id, Last_Entity                (T));\n                Set_Private_Dependents (Id, New_Elmt_List);\n-               Set_Is_Limited_Record  (Id, Is_Limited_Record     (T));\n+               Set_Is_Limited_Record  (Id, Is_Limited_Record          (T));\n                Set_Has_Implicit_Dereference\n-                                        (Id, Has_Implicit_Dereference (T));\n+                                      (Id, Has_Implicit_Dereference   (T));\n                Set_Has_Unknown_Discriminants\n-                                      (Id, Has_Unknown_Discriminants (T));\n+                                      (Id, Has_Unknown_Discriminants  (T));\n                Set_Known_To_Have_Preelab_Init\n                                       (Id, Known_To_Have_Preelab_Init (T));\n \n                if Is_Tagged_Type (T) then\n                   Set_Is_Tagged_Type              (Id);\n                   Set_Is_Abstract_Type            (Id, Is_Abstract_Type (T));\n-                  Set_Class_Wide_Type             (Id, Class_Wide_Type (T));\n+                  Set_Class_Wide_Type             (Id, Class_Wide_Type  (T));\n                   Set_Direct_Primitive_Operations (Id,\n                     Direct_Primitive_Operations (T));\n                end if;\n@@ -4273,14 +4273,14 @@ package body Sem_Ch3 is\n \n                if Has_Discriminants (T) then\n                   Set_Discriminant_Constraint\n-                                     (Id, Discriminant_Constraint (T));\n+                    (Id, Discriminant_Constraint (T));\n                   Set_Stored_Constraint_From_Discriminant_Constraint (Id);\n \n                elsif Present (Full_View (T))\n                  and then Has_Discriminants (Full_View (T))\n                then\n                   Set_Discriminant_Constraint\n-                               (Id, Discriminant_Constraint (Full_View (T)));\n+                    (Id, Discriminant_Constraint (Full_View (T)));\n                   Set_Stored_Constraint_From_Discriminant_Constraint (Id);\n \n                   --  This would seem semantically correct, but apparently"}, {"sha": "21c7a89b938ba26ef6b061bb6c3e35c958fb1b6d", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=dedac3eb7331f441f24b192fa0d9d1e1162f57ba", "patch": "@@ -6303,26 +6303,27 @@ package body Sem_Ch4 is\n \n       Func_Name := Empty;\n       Is_Var := False;\n-      Ritem := First_Rep_Item (Etype (Prefix));\n \n+      Ritem := First_Rep_Item (Etype (Prefix));\n       while Present (Ritem) loop\n          if Nkind (Ritem) = N_Aspect_Specification then\n \n             --  Prefer Variable_Indexing, but will settle for Constant.\n \n             if Get_Aspect_Id (Chars (Identifier (Ritem))) =\n-              Aspect_Constant_Indexing\n+                                                 Aspect_Constant_Indexing\n             then\n                Func_Name := Expression (Ritem);\n \n             elsif Get_Aspect_Id (Chars (Identifier (Ritem))) =\n-              Aspect_Variable_Indexing\n+                                                 Aspect_Variable_Indexing\n             then\n                Func_Name :=  Expression (Ritem);\n                Is_Var := True;\n                exit;\n             end if;\n          end if;\n+\n          Next_Rep_Item (Ritem);\n       end loop;\n "}, {"sha": "4de5c3d6a684bbf9490f59e53e1096702b2276ce", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=dedac3eb7331f441f24b192fa0d9d1e1162f57ba", "patch": "@@ -1756,7 +1756,7 @@ package body Sem_Res is\n       procedure Build_Explicit_Dereference\n         (Expr : Node_Id;\n          Disc : Entity_Id);\n-      --  AI05-139 : names with implicit dereference. If the expression N is a\n+      --  AI05-139: Names with implicit dereference. If the expression N is a\n       --  reference type and the context imposes the corresponding designated\n       --  type, convert N into N.Disc.all. Such expressions are always over-\n       --  loaded with both interpretations, and the dereference interpretation\n@@ -2312,9 +2312,9 @@ package body Sem_Res is\n                elsif Nkind (N) = N_Conditional_Expression then\n                   Set_Etype (N, Expr_Type);\n \n-               --  AI05-0139-2 : expression is overloaded because\n-               --  type has implicit dereference. If type matches\n-               --  context, no implicit dereference is involved.\n+               --  AI05-0139-2: Expression is overloaded because type has\n+               --  implicit dereference. If type matches context, no implicit\n+               --  dereference is involved.\n \n                elsif Has_Implicit_Dereference (Expr_Type) then\n                   Set_Etype (N, Expr_Type);"}, {"sha": "ef2d35546716fb80bbd38d9b4d9dd39bb2559c4c", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dedac3eb7331f441f24b192fa0d9d1e1162f57ba/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=dedac3eb7331f441f24b192fa0d9d1e1162f57ba", "patch": "@@ -148,7 +148,7 @@ package Sem_Util is\n    --  means that for sure CE cannot be raised.\n \n    procedure Check_Implicit_Dereference (Nam : Node_Id; Typ : Entity_Id);\n-   --  AI05-139-2 : accessors and iterators for containers. This procedure\n+   --  AI05-139-2: Accessors and iterators for containers. This procedure\n    --  checks whether T is a reference type, and if so it adds an interprettion\n    --  to Expr whose type is the designated type of the reference_discriminant.\n "}]}