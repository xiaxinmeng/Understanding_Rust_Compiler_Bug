{"sha": "ee92cb46db85822084b56c4aeda885345821fb69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU5MmNiNDZkYjg1ODIyMDg0YjU2YzRhZWRhODg1MzQ1ODIxZmI2OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-06-09T21:30:50Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-06-09T21:30:50Z"}, "message": "predict.c (predict_insn, [...]): New static functions.\n\n\t* predict.c (predict_insn, predict_edge): New static functions.\n\t(estimate_probability): Revamp to use new functions;\n\tfix loop header heruistics; add loop exist heruistics\n\nFrom-SVN: r43109", "tree": {"sha": "fedaa83af479cb7f142327490f007b3d2b5ac6c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fedaa83af479cb7f142327490f007b3d2b5ac6c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee92cb46db85822084b56c4aeda885345821fb69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee92cb46db85822084b56c4aeda885345821fb69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee92cb46db85822084b56c4aeda885345821fb69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee92cb46db85822084b56c4aeda885345821fb69/comments", "author": null, "committer": null, "parents": [{"sha": "9dd7e9cf22dce5e8d8f058824d2ae9d8f9264d09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dd7e9cf22dce5e8d8f058824d2ae9d8f9264d09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dd7e9cf22dce5e8d8f058824d2ae9d8f9264d09"}], "stats": {"total": 168, "additions": 95, "deletions": 73}, "files": [{"sha": "166a4b30dc1b3b198e15dfde460383cbcac31efe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92cb46db85822084b56c4aeda885345821fb69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92cb46db85822084b56c4aeda885345821fb69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ee92cb46db85822084b56c4aeda885345821fb69", "patch": "@@ -1,3 +1,9 @@\n+Sat Jun  9 23:29:41 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* predict.c (predict_insn, predict_edge): New static functions.\n+\t(estimate_probability): Revamp to use new functions;\n+\tfix loop header heruistics; add loop exist heruistics\n+\n 2001-06-09  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* config.gcc: Re-enable bi-arch sparc on Solaris 7 and above."}, {"sha": "68b5b7cddb90e7d04dc730f844a74292f75e7390", "filename": "gcc/predict.c", "status": "modified", "additions": 89, "deletions": 73, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92cb46db85822084b56c4aeda885345821fb69/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92cb46db85822084b56c4aeda885345821fb69/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=ee92cb46db85822084b56c4aeda885345821fb69", "patch": "@@ -57,6 +57,50 @@\n #define PROB_VERY_LIKELY\t(REG_BR_PROB_BASE - PROB_VERY_UNLIKELY)\n #define PROB_ALWAYS\t\t(REG_BR_PROB_BASE)\n \n+static void predict_insn\tPARAMS ((rtx, int));\n+static void predict_edge\tPARAMS ((edge, int));\n+\n+static void\n+predict_insn (insn, probability)\n+     rtx insn;\n+     int probability;\n+{\n+  rtx note = find_reg_note (insn, REG_BR_PROB, 0);\n+\n+  /* Implement \"first match\" heruistics.  In case we already predicted\n+     insn somehow, keep it predicted that way.  In future we would like\n+     to rather store all predictions and then combine them.  */\n+  if (note)\n+    return;\n+\n+  if (!any_condjump_p (insn))\n+    abort ();\n+  REG_NOTES (insn)\n+    = gen_rtx_EXPR_LIST (REG_BR_PROB,\n+\t\t\t GEN_INT (probability), REG_NOTES (insn));\n+}\n+\n+/* Predict edge E with given probability if possible.  */\n+static void\n+predict_edge (e, probability)\n+     edge e;\n+     int probability;\n+{\n+  rtx last_insn;\n+  last_insn = e->src->end;\n+\n+  /* We can store the branch prediction information only about\n+     conditional jumps.  */\n+  if (!any_condjump_p (last_insn))\n+    return;\n+\n+  /* We always store probability of branching.  */\n+  if (e->flags & EDGE_FALLTHRU)\n+    probability = REG_BR_PROB_BASE - probability;\n+\n+  predict_insn (last_insn, probability);\n+}\n+\n /* Statically estimate the probability that a branch will be taken.\n    ??? In the next revision there will be a number of other predictors added\n    from the above references. Further, each heuristic will be factored out\n@@ -79,27 +123,27 @@ estimate_probability (loops_info)\n \t   j <= loops_info->array[i].last->index;\n \t   ++j)\n \t{\n-\t  edge e;\n+\t  if (TEST_BIT (loops_info->array[i].nodes, j))\n+\t    {\n+\t      int header_found = 0;\n+\t      edge e;\n \t  \n-\t  if (! TEST_BIT (loops_info->array[i].nodes, j))\n-\t    for (e = BASIC_BLOCK(j)->pred; e; e = e->pred_next)\n-\t      if (TEST_BIT (loops_info->array[i].nodes, e->src->index))\n-\t\t{\n-\t\t  rtx last_insn = BLOCK_END (e->src->index);\n-\t\t  rtx cond, earliest;\n-\n-\t\t  if (GET_CODE (last_insn) != JUMP_INSN\n-\t\t      || ! condjump_p (last_insn) || simplejump_p (last_insn))\n-\t\t    continue;\n-\t\t  cond = get_condition (last_insn, &earliest);\n-\t\t  if (! cond)\n-\t\t    continue;\n-\t\t  if (! find_reg_note (last_insn, REG_BR_PROB, 0))\n-\t\t    REG_NOTES (last_insn)\n-\t\t      = gen_rtx_EXPR_LIST (REG_BR_PROB,\n-\t\t\t\t\t   GEN_INT (PROB_VERY_LIKELY),\n-\t\t\t\t\t   REG_NOTES (last_insn));\n-\t\t}\n+\t      /* Loop branch heruistics - predict as taken an edge back to\n+\t         a loop's head.  */\n+\t      for (e = BASIC_BLOCK(j)->succ; e; e = e->succ_next)\n+\t\tif (e->dest == loops_info->array[i].header)\n+\t\t  {\n+\t\t    header_found = 1;\n+\t\t    predict_edge (e, PROB_VERY_LIKELY);\n+\t\t  }\n+\t      /* Loop exit heruistics - predict as not taken an edge exiting\n+\t         the loop if the conditinal has no loop header successors  */\n+\t      if (!header_found)\n+\t\tfor (e = BASIC_BLOCK(j)->succ; e; e = e->succ_next)\n+\t\t  if (e->dest->index <= 0\n+\t\t      || !TEST_BIT (loops_info->array[i].nodes, e->dest->index))\n+\t\t    predict_edge (e, PROB_UNLIKELY);\n+\t    }\n \t}\n     }\n \n@@ -111,32 +155,25 @@ estimate_probability (loops_info)\n     {\n       rtx last_insn = BLOCK_END (i);\n       rtx cond, earliest;\n-      int prob;\n       edge e;\n \n       if (GET_CODE (last_insn) != JUMP_INSN\n-\t  || ! condjump_p (last_insn) || simplejump_p (last_insn))\n+\t  || ! any_condjump_p (last_insn))\n \tcontinue;\n \n       if (find_reg_note (last_insn, REG_BR_PROB, 0))\n \tcontinue;\n \n-      cond = get_condition (last_insn, &earliest);\n-      if (! cond)\n-\tcontinue;\n-\n       /* If one of the successor blocks has no successors, predict\n \t that side not taken.  */\n       /* ??? Ought to do the same for any subgraph with no exit.  */\n       for (e = BASIC_BLOCK (i)->succ; e; e = e->succ_next)\n \tif (e->dest->succ == NULL)\n-\t  {\n-\t    if (e->flags & EDGE_FALLTHRU)\n-\t      prob = PROB_ALWAYS;\n-\t    else\n-\t      prob = PROB_NEVER;\n-\t    goto emitnote;\n-\t  }\n+\t  predict_edge (e, PROB_NEVER);\n+\n+      cond = get_condition (last_insn, &earliest);\n+      if (! cond)\n+\tcontinue;\n \n       /* Try \"pointer heuristic.\"\n \t A comparison ptr == 0 is predicted as false.\n@@ -149,21 +186,16 @@ estimate_probability (loops_info)\n \t      && (XEXP (cond, 1) == const0_rtx\n \t\t  || (GET_CODE (XEXP (cond, 1)) == REG\n \t\t      && REG_POINTER (XEXP (cond, 1)))))\n-\t    {\n-\t      prob = PROB_UNLIKELY;\n-\t      goto emitnote;\n-\t    }\n+\t    \n+\t    predict_insn (last_insn, PROB_UNLIKELY);\n \t  break;\n \tcase NE:\n \t  if (GET_CODE (XEXP (cond, 0)) == REG\n \t      && REG_POINTER (XEXP (cond, 0))\n \t      && (XEXP (cond, 1) == const0_rtx\n \t\t  || (GET_CODE (XEXP (cond, 1)) == REG\n \t\t      && REG_POINTER (XEXP (cond, 1)))))\n-\t    {\n-\t      prob = PROB_LIKELY;\n-\t      goto emitnote;\n-\t    }\n+\t    predict_insn (last_insn, PROB_LIKELY);\n \t  break;\n \n \tdefault:\n@@ -178,53 +210,40 @@ estimate_probability (loops_info)\n \t{\n \tcase CONST_INT:\n \t  /* Unconditional branch.  */\n-\t  prob = (cond == const0_rtx ? PROB_NEVER : PROB_ALWAYS);\n-\t  goto emitnote;\n+\t  predict_insn (last_insn,\n+\t\t\tcond == const0_rtx ? PROB_NEVER : PROB_ALWAYS);\n+\t  break;\n \n \tcase EQ:\n \tcase UNEQ:\n-\t  prob = PROB_UNLIKELY;\n-\t  goto emitnote;\n+\t  predict_insn (last_insn, PROB_UNLIKELY);\n+\t  break;\n \tcase NE:\n \tcase LTGT:\n-\t  prob = PROB_LIKELY;\n-\t  goto emitnote;\n+\t  predict_insn (last_insn, PROB_LIKELY);\n+\t  break;\n \tcase ORDERED:\n-\t  prob = PROB_LIKELY;\n-\t  goto emitnote;\n+\t  predict_insn (last_insn, PROB_LIKELY);\n+\t  break;\n \tcase UNORDERED:\n-\t  prob = PROB_UNLIKELY;\n-\t  goto emitnote;\n+\t  predict_insn (last_insn, PROB_UNLIKELY);\n+\t  break;\n \tcase LE:\n \tcase LT:\n \t  if (XEXP (cond, 1) == const0_rtx)\n-\t    {\n-\t      prob = PROB_UNLIKELY;\n-\t      goto emitnote;\n-\t    }\n+\t    predict_insn (last_insn, PROB_UNLIKELY);\n \t  break;\n \tcase GE:\n \tcase GT:\n \t  if (XEXP (cond, 1) == const0_rtx\n \t      || (GET_CODE (XEXP (cond, 1)) == CONST_INT\n \t\t  && INTVAL (XEXP (cond, 1)) == -1))\n-\t    {\n-\t      prob = PROB_LIKELY;\n-\t      goto emitnote;\n-\t    }\n+\t    predict_insn (last_insn, PROB_LIKELY);\n \t  break;\n \n \tdefault:\n \t  break;\n \t}\n-\n-      /* If we havn't chosen something by now, predict 50-50.  */\n-      prob = PROB_EVEN;\n-\n-    emitnote:\n-      REG_NOTES (last_insn)\n-\t= gen_rtx_EXPR_LIST (REG_BR_PROB, GEN_INT (prob),\n-\t\t\t     REG_NOTES (last_insn));\n     }\n }\n \f\n@@ -295,12 +314,9 @@ expected_value_to_br_prob ()\n       cond = simplify_rtx (cond);\n \n       /* Turn the condition into a scaled branch probability.  */\n-      if (cond == const1_rtx)\n-\tcond = GEN_INT (PROB_VERY_LIKELY);\n-      else if (cond == const0_rtx)\n-\tcond = GEN_INT (PROB_VERY_UNLIKELY);\n-      else\n+      if (cond != const1_rtx && cond != const0_rtx)\n \tabort ();\n-      REG_NOTES (insn) = alloc_EXPR_LIST (REG_BR_PROB, cond, REG_NOTES (insn));\n+      predict_insn (insn,\n+\t\t    cond == const1_rtx ? PROB_VERY_LIKELY : PROB_VERY_UNLIKELY);\n     }\n }"}]}