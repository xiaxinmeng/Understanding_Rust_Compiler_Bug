{"sha": "00e6775a5faa43702e96e315e7a1c22297983f2a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBlNjc3NWE1ZmFhNDM3MDJlOTZlMzE1ZTdhMWMyMjI5Nzk4M2YyYQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-11-05T13:35:56Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-11-05T13:35:56Z"}, "message": "Fix vector memory statistics.\n\n2018-11-05  Martin Liska  <mliska@suse.cz>\n\n\t* mem-stats.h (mem_alloc_description::release_instance_overhead):\n\tReturn T *.\n\t* vec.c (struct vec_usage): Register m_element_size.\n\t(vec_prefix::register_overhead): New arguments: elements and\n\telement_size.\n\t(vec_prefix::release_overhead): Subtract elements.\n\t* vec.h (struct vec_prefix): Change signature.\n\t(va_heap::reserve): Pass proper arguments.\n\t(va_heap::release): Likewise.\n\nFrom-SVN: r265799", "tree": {"sha": "bcf3354f255012a40df5a04906022748690bab09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcf3354f255012a40df5a04906022748690bab09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00e6775a5faa43702e96e315e7a1c22297983f2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00e6775a5faa43702e96e315e7a1c22297983f2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00e6775a5faa43702e96e315e7a1c22297983f2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00e6775a5faa43702e96e315e7a1c22297983f2a/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "93ef36dc6987e424e775ced165d9011c9b2477a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93ef36dc6987e424e775ced165d9011c9b2477a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93ef36dc6987e424e775ced165d9011c9b2477a8"}], "stats": {"total": 75, "additions": 51, "deletions": 24}, "files": [{"sha": "fd48d8fda965f998c0d3017129326b5cda31b234", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00e6775a5faa43702e96e315e7a1c22297983f2a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00e6775a5faa43702e96e315e7a1c22297983f2a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00e6775a5faa43702e96e315e7a1c22297983f2a", "patch": "@@ -1,3 +1,15 @@\n+2018-11-05  Martin Liska  <mliska@suse.cz>\n+\n+\t* mem-stats.h (mem_alloc_description::release_instance_overhead):\n+\tReturn T *.\n+\t* vec.c (struct vec_usage): Register m_element_size.\n+\t(vec_prefix::register_overhead): New arguments: elements and\n+\telement_size.\n+\t(vec_prefix::release_overhead): Subtract elements.\n+\t* vec.h (struct vec_prefix): Change signature.\n+\t(va_heap::reserve): Pass proper arguments.\n+\t(va_heap::release): Likewise.\n+\n 2018-11-05  Martin Liska  <mliska@suse.cz>\n \n \t* mem-stats.h (mem_alloc_description::get_list): Fix GNU coding"}, {"sha": "b7f7e06a1c7069332d8cea5bebbefb3a0a75be10", "filename": "gcc/mem-stats.h", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00e6775a5faa43702e96e315e7a1c22297983f2a/gcc%2Fmem-stats.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00e6775a5faa43702e96e315e7a1c22297983f2a/gcc%2Fmem-stats.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmem-stats.h?ref=00e6775a5faa43702e96e315e7a1c22297983f2a", "patch": "@@ -340,9 +340,10 @@ class mem_alloc_description\n   void register_object_overhead (T *usage, size_t size, const void *ptr);\n \n   /* Release PTR pointer of SIZE bytes. If REMOVE_FROM_MAP is set to true,\n-     remove the instance from reverse map.  */\n-  void release_instance_overhead (void *ptr, size_t size,\n-\t\t\t\t  bool remove_from_map = false);\n+     remove the instance from reverse map.  Return memory usage that belongs\n+     to this memory description.  */\n+  T * release_instance_overhead (void *ptr, size_t size,\n+\t\t\t\t bool remove_from_map = false);\n \n   /* Release intance object identified by PTR pointer.  */\n   void release_object_overhead (void *ptr);\n@@ -503,7 +504,7 @@ mem_alloc_description<T>::register_overhead (size_t size,\n /* Release PTR pointer of SIZE bytes.  */\n \n template <class T>\n-inline void\n+inline T *\n mem_alloc_description<T>::release_instance_overhead (void *ptr, size_t size,\n \t\t\t\t\t\t     bool remove_from_map)\n {\n@@ -512,14 +513,16 @@ mem_alloc_description<T>::release_instance_overhead (void *ptr, size_t size,\n   if (!slot)\n     {\n       /* Due to PCH, it can really happen.  */\n-      return;\n+      return NULL;\n     }\n \n-  mem_usage_pair<T> usage_pair = *slot;\n-  usage_pair.usage->release_overhead (size);\n+  T *usage = (*slot).usage;\n+  usage->release_overhead (size);\n \n   if (remove_from_map)\n     m_reverse_map->remove (ptr);\n+\n+  return usage;\n }\n \n /* Release intance object identified by PTR pointer.  */"}, {"sha": "bfd52856e4686ae7a8d4b0d2d2f71acf7b2930b2", "filename": "gcc/vec.c", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00e6775a5faa43702e96e315e7a1c22297983f2a/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00e6775a5faa43702e96e315e7a1c22297983f2a/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=00e6775a5faa43702e96e315e7a1c22297983f2a", "patch": "@@ -52,13 +52,14 @@ vnull vNULL;\n struct vec_usage: public mem_usage\n {\n   /* Default constructor.  */\n-  vec_usage (): m_items (0), m_items_peak (0) {}\n+  vec_usage (): m_items (0), m_items_peak (0), m_element_size (0) {}\n \n   /* Constructor.  */\n   vec_usage (size_t allocated, size_t times, size_t peak,\n-\t     size_t items, size_t items_peak)\n+\t     size_t items, size_t items_peak, size_t element_size)\n     : mem_usage (allocated, times, peak),\n-    m_items (items), m_items_peak (items_peak) {}\n+    m_items (items), m_items_peak (items_peak),\n+    m_element_size (element_size) {}\n \n   /* Sum the usage with SECOND usage.  */\n   vec_usage\n@@ -68,7 +69,7 @@ struct vec_usage: public mem_usage\n \t\t      m_times + second.m_times,\n \t\t      m_peak + second.m_peak,\n \t\t      m_items + second.m_items,\n-\t\t      m_items_peak + second.m_items_peak);\n+\t\t      m_items_peak + second.m_items_peak, 0);\n   }\n \n   /* Dump usage coupled to LOC location, where TOTAL is sum of all rows.  */\n@@ -81,7 +82,8 @@ struct vec_usage: public mem_usage\n \n     s[48] = '\\0';\n \n-    fprintf (stderr, \"%-48s %10li:%4.1f%%%10li%10li:%4.1f%%%11li%11li\\n\", s,\n+    fprintf (stderr, \"%-48s %10li%11li:%4.1f%%%10li%10li:%4.1f%%%11li%11li\\n\", s,\n+\t     (long)m_element_size,\n \t     (long)m_allocated, m_allocated * 100.0 / total.m_allocated,\n \t     (long)m_peak, (long)m_times, m_times * 100.0 / total.m_times,\n \t     (long)m_items, (long)m_items_peak);\n@@ -101,15 +103,17 @@ struct vec_usage: public mem_usage\n   static inline void\n   dump_header (const char *name)\n   {\n-    fprintf (stderr, \"%-48s %11s%15s%10s%17s%11s\\n\", name, \"Leak\", \"Peak\",\n-\t     \"Times\", \"Leak items\", \"Peak items\");\n+    fprintf (stderr, \"%-48s %10s%11s%16s%10s%17s%11s\\n\", name, \"sizeof(T)\",\n+\t     \"Leak\", \"Peak\", \"Times\", \"Leak items\", \"Peak items\");\n     print_dash_line ();\n   }\n \n   /* Current number of items allocated.  */\n   size_t m_items;\n   /* Peak value of number of allocated items.  */\n   size_t m_items_peak;\n+  /* Size of element of the vector.  */\n+  size_t m_element_size;\n };\n \n /* Vector memory description.  */\n@@ -118,12 +122,14 @@ static mem_alloc_description <vec_usage> vec_mem_desc;\n /* Account the overhead.  */\n \n void\n-vec_prefix::register_overhead (void *ptr, size_t size, size_t elements\n-\t\t\t       MEM_STAT_DECL)\n+vec_prefix::register_overhead (void *ptr, size_t elements,\n+\t\t\t       size_t element_size MEM_STAT_DECL)\n {\n   vec_mem_desc.register_descriptor (ptr, VEC_ORIGIN, false\n \t\t\t\t    FINAL_PASS_MEM_STAT);\n-  vec_usage *usage = vec_mem_desc.register_instance_overhead (size, ptr);\n+  vec_usage *usage\n+    = vec_mem_desc.register_instance_overhead (elements * element_size, ptr);\n+  usage->m_element_size = element_size;\n   usage->m_items += elements;\n   if (usage->m_items_peak < usage->m_items)\n     usage->m_items_peak = usage->m_items;\n@@ -132,13 +138,15 @@ vec_prefix::register_overhead (void *ptr, size_t size, size_t elements\n /* Notice that the memory allocated for the vector has been freed.  */\n \n void\n-vec_prefix::release_overhead (void *ptr, size_t size, bool in_dtor\n-\t\t\t      MEM_STAT_DECL)\n+vec_prefix::release_overhead (void *ptr, size_t size, size_t elements,\n+\t\t\t      bool in_dtor MEM_STAT_DECL)\n {\n   if (!vec_mem_desc.contains_descriptor_for_instance (ptr))\n     vec_mem_desc.register_descriptor (ptr, VEC_ORIGIN,\n \t\t\t\t      false FINAL_PASS_MEM_STAT);\n-  vec_mem_desc.release_instance_overhead (ptr, size, in_dtor);\n+  vec_usage *usage = vec_mem_desc.release_instance_overhead (ptr, size,\n+\t\t\t\t\t\t\t     in_dtor);\n+  usage->m_items -= elements;\n }\n \n /* Calculate the number of slots to reserve a vector, making sure that"}, {"sha": "f8c039754d2d105ff3d85805f0ea91d64940d9a1", "filename": "gcc/vec.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00e6775a5faa43702e96e315e7a1c22297983f2a/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00e6775a5faa43702e96e315e7a1c22297983f2a/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=00e6775a5faa43702e96e315e7a1c22297983f2a", "patch": "@@ -195,7 +195,7 @@ struct vec_prefix\n \n   /* Memory allocation support routines in vec.c.  */\n   void register_overhead (void *, size_t, size_t CXX_MEM_STAT_INFO);\n-  void release_overhead (void *, size_t, bool CXX_MEM_STAT_INFO);\n+  void release_overhead (void *, size_t, size_t, bool CXX_MEM_STAT_INFO);\n   static unsigned calculate_allocation (vec_prefix *, unsigned, bool);\n   static unsigned calculate_allocation_1 (unsigned, unsigned);\n \n@@ -276,20 +276,22 @@ inline void\n va_heap::reserve (vec<T, va_heap, vl_embed> *&v, unsigned reserve, bool exact\n \t\t  MEM_STAT_DECL)\n {\n+  size_t elt_size = sizeof (T);\n   unsigned alloc\n     = vec_prefix::calculate_allocation (v ? &v->m_vecpfx : 0, reserve, exact);\n   gcc_checking_assert (alloc);\n \n   if (GATHER_STATISTICS && v)\n-    v->m_vecpfx.release_overhead (v, v->allocated (), false);\n+    v->m_vecpfx.release_overhead (v, elt_size * v->allocated (),\n+\t\t\t\t  v->allocated (), false);\n \n   size_t size = vec<T, va_heap, vl_embed>::embedded_size (alloc);\n   unsigned nelem = v ? v->length () : 0;\n   v = static_cast <vec<T, va_heap, vl_embed> *> (xrealloc (v, size));\n   v->embedded_init (alloc, nelem);\n \n   if (GATHER_STATISTICS)\n-    v->m_vecpfx.register_overhead (v, alloc, nelem PASS_MEM_STAT);\n+    v->m_vecpfx.register_overhead (v, alloc, elt_size PASS_MEM_STAT);\n }\n \n \n@@ -299,11 +301,13 @@ template<typename T>\n void\n va_heap::release (vec<T, va_heap, vl_embed> *&v)\n {\n+  size_t elt_size = sizeof (T);\n   if (v == NULL)\n     return;\n \n   if (GATHER_STATISTICS)\n-    v->m_vecpfx.release_overhead (v, v->allocated (), true);\n+    v->m_vecpfx.release_overhead (v, elt_size * v->allocated (),\n+\t\t\t\t  v->allocated (), true);\n   ::free (v);\n   v = NULL;\n }"}]}