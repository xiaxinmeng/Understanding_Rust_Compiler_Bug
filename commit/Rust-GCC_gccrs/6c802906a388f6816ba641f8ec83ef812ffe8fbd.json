{"sha": "6c802906a388f6816ba641f8ec83ef812ffe8fbd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM4MDI5MDZhMzg4ZjY4MTZiYTY0MWY4ZWM4M2VmODEyZmZlOGZiZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-11-20T11:13:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-11-20T11:13:40Z"}, "message": "[multiple changes]\n\n2014-11-20  Pascal Obry  <obry@adacore.com>\n\n\t* initialize.c (ProcListCS): New extern variable (critical section).\n\t(ProcListEvt): New extern variable (handle).\n\t(__gnat_initialize)[Win32]: Initialize the ProcListCS critical\n\tsection object and the ProcListEvt event.\n\t* final.c (__gnat_finalize)[Win32]: Properly finalize the\n\tProcListCS critical section and the ProcListEvt event.\n\t* adaint.c (ProcListEvt): New Win32 event handle.\n\t(EnterCS): New routine to enter the critical section when dealing with\n\tchild processes chain list.\n\t(LeaveCS): As above to exit from the critical section.\n\t(SignalListChanged): Routine to signal that the chain process list has\n\tbeen updated.\n\t(add_handle): Use EnterCS/LeaveCS, also call SignalListChanged when the\n\thandle has been added.\n\t(__gnat_win32_remove_handle): Use EnterCS/LeaveCS,\n\talso call SignalListChanged if the handle has been found and removed.\n\t(remove_handle): Routine removed, implementation merged with the above.\n\t(win32_wait): Use EnterCS/LeaveCS for the critical section. Properly\n\tcopy the PID list locally to ensure that even if the list is updated\n\tthe local copy remains valid. Add into the hl (handle list) the\n\tProcListEvt handle. This handle is used to signal that a change has\n\tbeen made into the process chain list. This is to ensure that a waiting\n\tcall can be resumed to take into account new processes. We also make\n\tsure that if the handle was not found into the list we start over\n\tthe wait call. Indeed another concurrent call to win32_wait()\n\tcould already have handled this process.\n\n2014-11-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_res.adb (Resolve_Actuals): The legality rule concerning\n\tthe use of class-wide actuals for a non-controlling formal are\n\tnot rechecked in an instance.\n\n2014-11-20  Pascal Obry  <obry@adacore.com>\n\n\t* g-dirope.ads: Minor typo fix.\n\n2014-11-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference,\n\tExpand_Update_Attribute): Preserve the tag of a prefix by offering\n\ta specific view of the class-wide version of the prefix.\n\nFrom-SVN: r217837", "tree": {"sha": "935169c8313a4ed8a666888be5c53e913f041f63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/935169c8313a4ed8a666888be5c53e913f041f63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c802906a388f6816ba641f8ec83ef812ffe8fbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c802906a388f6816ba641f8ec83ef812ffe8fbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c802906a388f6816ba641f8ec83ef812ffe8fbd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c802906a388f6816ba641f8ec83ef812ffe8fbd/comments", "author": null, "committer": null, "parents": [{"sha": "4b963531a13ebfef4fd889df305d4037e7334fa0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b963531a13ebfef4fd889df305d4037e7334fa0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b963531a13ebfef4fd889df305d4037e7334fa0"}], "stats": {"total": 393, "additions": 310, "deletions": 83}, "files": [{"sha": "39c4e09817d9afece11647c2dc65459c653c9aa9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c802906a388f6816ba641f8ec83ef812ffe8fbd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c802906a388f6816ba641f8ec83ef812ffe8fbd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6c802906a388f6816ba641f8ec83ef812ffe8fbd", "patch": "@@ -1,3 +1,48 @@\n+2014-11-20  Pascal Obry  <obry@adacore.com>\n+\n+\t* initialize.c (ProcListCS): New extern variable (critical section).\n+\t(ProcListEvt): New extern variable (handle).\n+\t(__gnat_initialize)[Win32]: Initialize the ProcListCS critical\n+\tsection object and the ProcListEvt event.\n+\t* final.c (__gnat_finalize)[Win32]: Properly finalize the\n+\tProcListCS critical section and the ProcListEvt event.\n+\t* adaint.c (ProcListEvt): New Win32 event handle.\n+\t(EnterCS): New routine to enter the critical section when dealing with\n+\tchild processes chain list.\n+\t(LeaveCS): As above to exit from the critical section.\n+\t(SignalListChanged): Routine to signal that the chain process list has\n+\tbeen updated.\n+\t(add_handle): Use EnterCS/LeaveCS, also call SignalListChanged when the\n+\thandle has been added.\n+\t(__gnat_win32_remove_handle): Use EnterCS/LeaveCS,\n+\talso call SignalListChanged if the handle has been found and removed.\n+\t(remove_handle): Routine removed, implementation merged with the above.\n+\t(win32_wait): Use EnterCS/LeaveCS for the critical section. Properly\n+\tcopy the PID list locally to ensure that even if the list is updated\n+\tthe local copy remains valid. Add into the hl (handle list) the\n+\tProcListEvt handle. This handle is used to signal that a change has\n+\tbeen made into the process chain list. This is to ensure that a waiting\n+\tcall can be resumed to take into account new processes. We also make\n+\tsure that if the handle was not found into the list we start over\n+\tthe wait call. Indeed another concurrent call to win32_wait()\n+\tcould already have handled this process.\n+\n+2014-11-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Actuals): The legality rule concerning\n+\tthe use of class-wide actuals for a non-controlling formal are\n+\tnot rechecked in an instance.\n+\n+2014-11-20  Pascal Obry  <obry@adacore.com>\n+\n+\t* g-dirope.ads: Minor typo fix.\n+\n+2014-11-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_attr.adb (Expand_N_Attribute_Reference,\n+\tExpand_Update_Attribute): Preserve the tag of a prefix by offering\n+\ta specific view of the class-wide version of the prefix.\n+\n 2014-11-20  Javier Miranda  <miranda@adacore.com>\n \n \t* sem_ch6.adb (Analyze_Function_Return): For functions returning"}, {"sha": "36a11899618314173048c98bc8386c7105049f0f", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 77, "deletions": 31, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c802906a388f6816ba641f8ec83ef812ffe8fbd/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c802906a388f6816ba641f8ec83ef812ffe8fbd/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=6c802906a388f6816ba641f8ec83ef812ffe8fbd", "patch": "@@ -2311,20 +2311,29 @@ __gnat_number_of_cpus (void)\n    for locking and unlocking tasks since we do not support multiple\n    threads on this configuration (Cert run time on native Windows). */\n \n-static void dummy (void)\n-{\n-}\n-\n-void (*Lock_Task) ()   = &dummy;\n-void (*Unlock_Task) () = &dummy;\n+static void EnterCS (void) {}\n+static void LeaveCS (void) {}\n+static void SignalListChanged (void) {}\n \n #else\n \n-#define Lock_Task system__soft_links__lock_task\n-extern void (*Lock_Task) (void);\n+CRITICAL_SECTION ProcListCS;\n+HANDLE ProcListEvt;\n+\n+static void EnterCS (void)\n+{\n+  EnterCriticalSection(&ProcListCS);\n+}\n \n-#define Unlock_Task system__soft_links__unlock_task\n-extern void (*Unlock_Task) (void);\n+static void LeaveCS (void)\n+{\n+  LeaveCriticalSection(&ProcListCS);\n+}\n+\n+static void SignalListChanged (void)\n+{\n+  SetEvent (ProcListEvt);\n+}\n \n #endif\n \n@@ -2335,7 +2344,7 @@ static void\n add_handle (HANDLE h, int pid)\n {\n   /* -------------------- critical section -------------------- */\n-  (*Lock_Task) ();\n+  EnterCS();\n \n   if (plist_length == plist_max_length)\n     {\n@@ -2350,14 +2359,19 @@ add_handle (HANDLE h, int pid)\n   PID_LIST[plist_length] = pid;\n   ++plist_length;\n \n-  (*Unlock_Task) ();\n+  SignalListChanged();\n+  LeaveCS();\n   /* -------------------- critical section -------------------- */\n }\n \n-static void\n-remove_handle (HANDLE h, int pid)\n+int\n+__gnat_win32_remove_handle (HANDLE h, int pid)\n {\n   int j;\n+  int found = 0;\n+\n+  /* -------------------- critical section -------------------- */\n+  EnterCS();\n \n   for (j = 0; j < plist_length; j++)\n     {\n@@ -2367,21 +2381,18 @@ remove_handle (HANDLE h, int pid)\n           --plist_length;\n           HANDLES_LIST[j] = HANDLES_LIST[plist_length];\n           PID_LIST[j] = PID_LIST[plist_length];\n+          found = 1;\n           break;\n         }\n     }\n-}\n \n-void\n-__gnat_win32_remove_handle (HANDLE h, int pid)\n-{\n+  LeaveCS();\n   /* -------------------- critical section -------------------- */\n-  (*Lock_Task) ();\n \n-  remove_handle(h, pid);\n+  if (found)\n+    SignalListChanged();\n \n-  (*Unlock_Task) ();\n-  /* -------------------- critical section -------------------- */\n+  return found;\n }\n \n static void\n@@ -2466,35 +2477,70 @@ win32_wait (int *status)\n   DWORD exitcode, pid;\n   HANDLE *hl;\n   HANDLE h;\n+  int *pidl;\n   DWORD res;\n   int hl_len;\n+  int found;\n \n-  /* -------------------- critical section -------------------- */\n-  (*Lock_Task) ();\n+ START_WAIT:\n \n   if (plist_length == 0)\n     {\n       errno = ECHILD;\n-      (*Unlock_Task) ();\n       return -1;\n     }\n \n+  /* -------------------- critical section -------------------- */\n+  EnterCS();\n+\n   hl_len = plist_length;\n \n+#ifdef CERT\n   hl = (HANDLE *) xmalloc (sizeof (HANDLE) * hl_len);\n-\n   memmove (hl, HANDLES_LIST, sizeof (HANDLE) * hl_len);\n+  pidl = (int *) xmalloc (sizeof (int) * hl_len);\n+  memmove (pidl, PID_LIST, sizeof (int) * hl_len);\n+#else\n+  /* Note that index 0 contains the event hanlde that is signaled when the\n+     process list has changed */\n+  hl = (HANDLE *) xmalloc (sizeof (HANDLE) * hl_len + 1);\n+  hl[0] = ProcListEvt;\n+  memmove (&hl[1], HANDLES_LIST, sizeof (HANDLE) * hl_len);\n+  pidl = (int *) xmalloc (sizeof (int) * hl_len + 1);\n+  memmove (&pidl[1], PID_LIST, sizeof (int) * hl_len);\n+  hl_len++;\n+#endif\n+\n+  LeaveCS();\n+  /* -------------------- critical section -------------------- */\n \n   res = WaitForMultipleObjects (hl_len, hl, FALSE, INFINITE);\n-  h = hl[res - WAIT_OBJECT_0];\n \n+  /* if the ProcListEvt has been signaled then the list of processes has been\n+     updated to add or remove a handle, just loop over */\n+\n+  if (res - WAIT_OBJECT_0 == 0)\n+    {\n+      free (hl);\n+      free (pidl);\n+      goto START_WAIT;\n+    }\n+\n+  h = hl[res - WAIT_OBJECT_0];\n   GetExitCodeProcess (h, &exitcode);\n-  pid = PID_LIST [res - WAIT_OBJECT_0];\n-  remove_handle (h, -1);\n+  pid = pidl [res - WAIT_OBJECT_0];\n+\n+  found = __gnat_win32_remove_handle (h, -1);\n \n-  (*Unlock_Task) ();\n-  /* -------------------- critical section -------------------- */\n   free (hl);\n+  free (pidl);\n+\n+  /* if not found another process waiting has already handled this process */\n+\n+  if (!found)\n+    {\n+      goto START_WAIT;\n+    }\n \n   *status = (int) exitcode;\n   return (int) pid;"}, {"sha": "b0e66cc69b5b0a47f331eae2189d11d2ccd29458", "filename": "gcc/ada/adaint.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c802906a388f6816ba641f8ec83ef812ffe8fbd/gcc%2Fada%2Fadaint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c802906a388f6816ba641f8ec83ef812ffe8fbd/gcc%2Fada%2Fadaint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.h?ref=6c802906a388f6816ba641f8ec83ef812ffe8fbd", "patch": "@@ -299,7 +299,7 @@ extern void   __gnat_cpu_set                       (int, size_t, cpu_set_t *);\n #if defined (_WIN32)\n /* Interface to delete a handle from internally maintained list of child\n    process handles on Windows */\n-extern void\n+extern int\n __gnat_win32_remove_handle (HANDLE h, int pid);\n #endif\n "}, {"sha": "eb5f28f9e650e540be45d2ad9d80f2f3ffb607f4", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 157, "deletions": 49, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c802906a388f6816ba641f8ec83ef812ffe8fbd/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c802906a388f6816ba641f8ec83ef812ffe8fbd/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=6c802906a388f6816ba641f8ec83ef812ffe8fbd", "patch": "@@ -1021,6 +1021,9 @@ package body Exp_Attr is\n       Pref      : constant Node_Id   := Prefix (N);\n       Typ       : constant Entity_Id := Etype (Pref);\n       Blk       : Node_Id;\n+      CW_Decl   : Node_Id;\n+      CW_Temp   : Entity_Id;\n+      CW_Typ    : Entity_Id;\n       Decls     : List_Id;\n       Installed : Boolean;\n       Loc       : Source_Ptr;\n@@ -1338,18 +1341,55 @@ package body Exp_Attr is\n       --  Step 3: Create a constant to capture the value of the prefix at the\n       --  entry point into the loop.\n \n-      --  Generate:\n-      --    Temp : constant <type of Pref> := <Pref>;\n-\n       Temp_Id := Make_Temporary (Loc, 'P');\n \n-      Temp_Decl :=\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Temp_Id,\n-          Constant_Present    => True,\n-          Object_Definition   => New_Occurrence_Of (Typ, Loc),\n-          Expression          => Relocate_Node (Pref));\n-      Append_To (Decls, Temp_Decl);\n+      --  Preserve the tag of the prefix by offering a specific view of the\n+      --  class-wide version of the prefix.\n+\n+      if Is_Tagged_Type (Typ) then\n+\n+         --  Generate:\n+         --    CW_Temp : constant Typ'Class := Typ'Class (Pref);\n+\n+         CW_Temp := Make_Temporary (Loc, 'T');\n+         CW_Typ  := Class_Wide_Type (Typ);\n+\n+         CW_Decl :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => CW_Temp,\n+             Constant_Present    => True,\n+             Object_Definition   => New_Occurrence_Of (CW_Typ, Loc),\n+             Expression          =>\n+               Convert_To (CW_Typ, Relocate_Node (Pref)));\n+         Append_To (Decls, CW_Decl);\n+\n+         --  Generate:\n+         --    Temp : Typ renames Typ (CW_Temp);\n+\n+         Temp_Decl :=\n+           Make_Object_Renaming_Declaration (Loc,\n+             Defining_Identifier => Temp_Id,\n+             Subtype_Mark        => New_Occurrence_Of (Typ, Loc),\n+             Name                =>\n+               Convert_To (Typ, New_Occurrence_Of (CW_Temp, Loc)));\n+         Append_To (Decls, Temp_Decl);\n+\n+      --  Non-tagged case\n+\n+      else\n+         CW_Decl := Empty;\n+\n+         --  Generate:\n+         --    Temp : constant Typ := Pref;\n+\n+         Temp_Decl :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Temp_Id,\n+             Constant_Present    => True,\n+             Object_Definition   => New_Occurrence_Of (Typ, Loc),\n+             Expression          => Relocate_Node (Pref));\n+         Append_To (Decls, Temp_Decl);\n+      end if;\n \n       --  Step 4: Analyze all bits\n \n@@ -1374,6 +1414,10 @@ package body Exp_Attr is\n       --  the declaration of the constant.\n \n       else\n+         if Present (CW_Decl) then\n+            Analyze (CW_Decl);\n+         end if;\n+\n          Analyze (Temp_Decl);\n       end if;\n \n@@ -4358,19 +4402,13 @@ package body Exp_Attr is\n       ---------\n \n       when Attribute_Old => Old : declare\n-         Asn_Stm : Node_Id;\n+         Typ     : constant Entity_Id := Etype (N);\n+         CW_Temp : Entity_Id;\n+         CW_Typ  : Entity_Id;\n          Subp    : Node_Id;\n          Temp    : Entity_Id;\n \n       begin\n-         Temp := Make_Temporary (Loc, 'T', Pref);\n-\n-         --  Set the entity kind now in order to mark the temporary as a\n-         --  handler of attribute 'Old's prefix.\n-\n-         Set_Ekind (Temp, E_Constant);\n-         Set_Stores_Attribute_Old_Prefix (Temp);\n-\n          --  Climb the parent chain looking for subprogram _Postconditions\n \n          Subp := N;\n@@ -4395,28 +4433,63 @@ package body Exp_Attr is\n \n          pragma Assert (Present (Subp));\n \n-         --  Generate:\n-         --    Temp : constant <Pref type> := <Pref>;\n+         Temp := Make_Temporary (Loc, 'T', Pref);\n \n-         Asn_Stm :=\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Temp,\n-             Constant_Present    => True,\n-             Object_Definition   => New_Occurrence_Of (Etype (N), Loc),\n-             Expression          => Pref);\n+         --  Set the entity kind now in order to mark the temporary as a\n+         --  handler of attribute 'Old's prefix.\n+\n+         Set_Ekind (Temp, E_Constant);\n+         Set_Stores_Attribute_Old_Prefix (Temp);\n \n          --  Push the scope of the related subprogram where _Postcondition\n          --  resides as this ensures that the object will be analyzed in the\n          --  proper context.\n \n          Push_Scope (Scope (Defining_Entity (Subp)));\n \n-         --  The object declaration is inserted before the body of subprogram\n-         --  _Postconditions. This ensures that any precondition-like actions\n-         --  are still executed before any parameter values are captured and\n-         --  the multiple 'Old occurrences appear in order of declaration.\n+         --  Preserve the tag of the prefix by offering a specific view of the\n+         --  class-wide version of the prefix.\n+\n+         if Is_Tagged_Type (Typ) then\n+\n+            --  Generate:\n+            --    CW_Temp : constant Typ'Class := Typ'Class (Pref);\n+\n+            CW_Temp := Make_Temporary (Loc, 'T');\n+            CW_Typ  := Class_Wide_Type (Typ);\n+\n+            Insert_Before_And_Analyze (Subp,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => CW_Temp,\n+                Constant_Present    => True,\n+                Object_Definition   => New_Occurrence_Of (CW_Typ, Loc),\n+                Expression          =>\n+                  Convert_To (CW_Typ, Relocate_Node (Pref))));\n+\n+            --  Generate:\n+            --    Temp : Typ renames Typ (CW_Temp);\n+\n+            Insert_Before_And_Analyze (Subp,\n+              Make_Object_Renaming_Declaration (Loc,\n+                Defining_Identifier => Temp,\n+                Subtype_Mark        => New_Occurrence_Of (Typ, Loc),\n+                Name                =>\n+                  Convert_To (Typ, New_Occurrence_Of (CW_Temp, Loc))));\n+\n+         --  Non-tagged case\n+\n+         else\n+            --  Generate:\n+            --    Temp : constant Typ := Pref;\n+\n+            Insert_Before_And_Analyze (Subp,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Temp,\n+                Constant_Present    => True,\n+                Object_Definition   => New_Occurrence_Of (Typ, Loc),\n+                Expression          => Relocate_Node (Pref)));\n+         end if;\n \n-         Insert_Before_And_Analyze (Subp, Asn_Stm);\n          Pop_Scope;\n \n          --  Ensure that the prefix of attribute 'Old is valid. The check must\n@@ -7351,30 +7424,65 @@ package body Exp_Attr is\n \n       --  Local variables\n \n-      Aggr  : constant Node_Id    := First (Expressions (N));\n-      Loc   : constant Source_Ptr := Sloc (N);\n-      Pref  : constant Node_Id    := Prefix (N);\n-      Typ   : constant Entity_Id  := Etype (Pref);\n-      Assoc : Node_Id;\n-      Comp  : Node_Id;\n-      Expr  : Node_Id;\n-      Temp  : Entity_Id;\n+      Aggr    : constant Node_Id    := First (Expressions (N));\n+      Loc     : constant Source_Ptr := Sloc (N);\n+      Pref    : constant Node_Id    := Prefix (N);\n+      Typ     : constant Entity_Id  := Etype (Pref);\n+      Assoc   : Node_Id;\n+      Comp    : Node_Id;\n+      CW_Temp : Entity_Id;\n+      CW_Typ  : Entity_Id;\n+      Expr    : Node_Id;\n+      Temp    : Entity_Id;\n \n    --  Start of processing for Expand_Update_Attribute\n \n    begin\n-      --  Create the anonymous object that stores the value of the prefix and\n-      --  reflects subsequent changes in value. Generate:\n+      --  Create the anonymous object to store the value of the prefix and\n+      --  capture subsequent changes in value.\n+\n+      Temp := Make_Temporary (Loc, 'T', Pref);\n \n-      --    Temp : <type of Pref> := Pref;\n+      --  Preserve the tag of the prefix by offering a specific view of the\n+      --  class-wide version of the prefix.\n \n-      Temp := Make_Temporary (Loc, 'T');\n+      if Is_Tagged_Type (Typ) then\n \n-      Insert_Action (N,\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Temp,\n-          Object_Definition   => New_Occurrence_Of (Typ, Loc),\n-          Expression          => Relocate_Node (Pref)));\n+         --  Generate:\n+         --    CW_Temp : Typ'Class := Typ'Class (Pref);\n+\n+         CW_Temp := Make_Temporary (Loc, 'T');\n+         CW_Typ  := Class_Wide_Type (Typ);\n+\n+         Insert_Action (N,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => CW_Temp,\n+             Object_Definition   => New_Occurrence_Of (CW_Typ, Loc),\n+             Expression          =>\n+               Convert_To (CW_Typ, Relocate_Node (Pref))));\n+\n+         --  Generate:\n+         --    Temp : Typ renames Typ (CW_Temp);\n+\n+         Insert_Action (N,\n+           Make_Object_Renaming_Declaration (Loc,\n+             Defining_Identifier => Temp,\n+             Subtype_Mark        => New_Occurrence_Of (Typ, Loc),\n+             Name                =>\n+               Convert_To (Typ, New_Occurrence_Of (CW_Temp, Loc))));\n+\n+      --  Non-tagged case\n+\n+      else\n+         --  Generate:\n+         --    Temp : Typ := Pref;\n+\n+         Insert_Action (N,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Temp,\n+             Object_Definition   => New_Occurrence_Of (Typ, Loc),\n+             Expression          => Relocate_Node (Pref)));\n+      end if;\n \n       --  Process the update aggregate\n "}, {"sha": "dffc2b2225be03069fcedd8d8d574e82a7b2bb61", "filename": "gcc/ada/final.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c802906a388f6816ba641f8ec83ef812ffe8fbd/gcc%2Fada%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c802906a388f6816ba641f8ec83ef812ffe8fbd/gcc%2Fada%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffinal.c?ref=6c802906a388f6816ba641f8ec83ef812ffe8fbd", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2011, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2014, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -40,10 +40,28 @@ extern void __gnat_finalize (void);\n    at all, the intention is that this be replaced by system specific code\n    where finalization is required.  */\n \n+#if defined (__MINGW32__)\n+#include \"mingw32.h\"\n+#include <windows.h>\n+\n+extern CRITICAL_SECTION ProcListCS;\n+extern HANDLE ProcListEvt;\n+\n+void\n+__gnat_finalize (void)\n+{\n+  /* delete critical section and event handle used for the\n+     processes chain list */\n+  DeleteCriticalSection(&ProcListCS);\n+  CloseHandle (ProcListEvt);\n+}\n+\n+#else\n void\n __gnat_finalize (void)\n {\n }\n+#endif\n \n #ifdef __cplusplus\n }"}, {"sha": "c3c207f2e99e65a85a853242aa0d3d78d7ed56d0", "filename": "gcc/ada/g-dirope.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c802906a388f6816ba641f8ec83ef812ffe8fbd/gcc%2Fada%2Fg-dirope.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c802906a388f6816ba641f8ec83ef812ffe8fbd/gcc%2Fada%2Fg-dirope.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dirope.ads?ref=6c802906a388f6816ba641f8ec83ef812ffe8fbd", "patch": "@@ -175,7 +175,7 @@ package GNAT.Directory_Operations is\n    --  Returns Path with environment variables replaced by the current\n    --  environment variable value. For example, $HOME/mydir will be replaced\n    --  by /home/joe/mydir if $HOME environment variable is set to /home/joe and\n-   --  Mode is UNIX. If an environment variable does not exists the variable\n+   --  Mode is UNIX. If an environment variable does not exist the variable\n    --  will be replaced by the empty string. Two dollar or percent signs are\n    --  replaced by a single dollar/percent sign. Note that a variable must\n    --  start with a letter."}, {"sha": "9426c9e5aee868875c8153cfc683c99b8c737f4e", "filename": "gcc/ada/initialize.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c802906a388f6816ba641f8ec83ef812ffe8fbd/gcc%2Fada%2Finitialize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c802906a388f6816ba641f8ec83ef812ffe8fbd/gcc%2Fada%2Finitialize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finitialize.c?ref=6c802906a388f6816ba641f8ec83ef812ffe8fbd", "patch": "@@ -74,6 +74,8 @@ extern void __gnat_install_SEH_handler (void *);\n \n extern int gnat_argc;\n extern char **gnat_argv;\n+extern CRITICAL_SECTION ProcListCS;\n+extern HANDLE ProcListEvt;\n \n #ifdef GNAT_UNICODE_SUPPORT\n \n@@ -138,6 +140,11 @@ __gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n       given that we have set Max_Digits etc with this in mind */\n    __gnat_init_float ();\n \n+   /* Initialize the critical section and event handle for the win32_wait()\n+      implementation, see adaint.c */\n+   InitializeCriticalSection (&ProcListCS);\n+   ProcListEvt = CreateEvent (NULL, FALSE, FALSE, NULL);\n+\n #ifdef GNAT_UNICODE_SUPPORT\n    /* Set current code page for filenames handling. */\n    {"}, {"sha": "71f480f4a967a07d0c35af757a24d2d881bae2cc", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c802906a388f6816ba641f8ec83ef812ffe8fbd/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c802906a388f6816ba641f8ec83ef812ffe8fbd/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=6c802906a388f6816ba641f8ec83ef812ffe8fbd", "patch": "@@ -4520,9 +4520,12 @@ package body Sem_Res is\n                Validate_Remote_Access_To_Class_Wide_Type (A);\n             end if;\n \n+            --  Apply legality rule 3.9.2  (9/1)\n+\n             if (Is_Class_Wide_Type (A_Typ) or else Is_Dynamically_Tagged (A))\n               and then not Is_Class_Wide_Type (F_Typ)\n               and then not Is_Controlling_Formal (F)\n+              and then not In_Instance\n             then\n                Error_Msg_N (\"class-wide argument not allowed here!\", A);\n "}]}