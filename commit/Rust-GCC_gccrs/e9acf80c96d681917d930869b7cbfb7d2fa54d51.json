{"sha": "e9acf80c96d681917d930869b7cbfb7d2fa54d51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTlhY2Y4MGM5NmQ2ODE5MTdkOTMwODY5YjdjYmZiN2QyZmE1NGQ1MQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-16T11:40:22Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-16T11:40:22Z"}, "message": "Add flags to dr_with_seg_len_pair_t\n\nThis patch adds a bunch of flags to dr_with_seg_len_pair_t,\nfor use by later patches.  The update to tree-loop-distribution.c\nis conservatively correct, but might be tweakable later.\n\n2019-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-data-ref.h (DR_ALIAS_RAW, DR_ALIAS_WAR, DR_ALIAS_WAW)\n\t(DR_ALIAS_ARBITRARY, DR_ALIAS_SWAPPED, DR_ALIAS_UNSWAPPED): New flags.\n\t(dr_with_seg_len_pair_t::sequencing): New enum.\n\t(dr_with_seg_len_pair_t::flags): New member variable.\n\t(dr_with_seg_len_pair_t::dr_with_seg_len_pair_t): Take a sequencing\n\tparameter and initialize the flags member variable.\n\t* tree-loop-distribution.c (compute_alias_check_pairs): Update\n\tcall accordingly.\n\t* tree-vect-data-refs.c (vect_prune_runtime_alias_test_list): Likewise.\n\tEnsure the two data references in an alias pair are in statement\n\torder, if there is a defined order.\n\t* tree-data-ref.c (prune_runtime_alias_test_list): Use\n\tDR_ALIAS_SWAPPED and DR_ALIAS_UNSWAPPED to record whether we've\n\tswapped the references in a dr_with_seg_len_pair_t.  OR together\n\tthe flags when merging two dr_with_seg_len_pair_ts.  After merging,\n\ttry to restore the original dr_with_seg_len order, updating the\n\tflags if that fails.\n\nFrom-SVN: r278350", "tree": {"sha": "0ccbb5b5dbff8afd58730f89b2eaa07d16f54ac5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ccbb5b5dbff8afd58730f89b2eaa07d16f54ac5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9acf80c96d681917d930869b7cbfb7d2fa54d51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9acf80c96d681917d930869b7cbfb7d2fa54d51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9acf80c96d681917d930869b7cbfb7d2fa54d51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9acf80c96d681917d930869b7cbfb7d2fa54d51/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "97602450b04e94aff034381bf6ee4236b95727ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97602450b04e94aff034381bf6ee4236b95727ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97602450b04e94aff034381bf6ee4236b95727ed"}], "stats": {"total": 175, "additions": 161, "deletions": 14}, "files": [{"sha": "e3ece31b2bf0343d9beeb80490fdb918f940fdbd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9acf80c96d681917d930869b7cbfb7d2fa54d51/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9acf80c96d681917d930869b7cbfb7d2fa54d51/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9acf80c96d681917d930869b7cbfb7d2fa54d51", "patch": "@@ -1,3 +1,23 @@\n+2019-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-data-ref.h (DR_ALIAS_RAW, DR_ALIAS_WAR, DR_ALIAS_WAW)\n+\t(DR_ALIAS_ARBITRARY, DR_ALIAS_SWAPPED, DR_ALIAS_UNSWAPPED): New flags.\n+\t(dr_with_seg_len_pair_t::sequencing): New enum.\n+\t(dr_with_seg_len_pair_t::flags): New member variable.\n+\t(dr_with_seg_len_pair_t::dr_with_seg_len_pair_t): Take a sequencing\n+\tparameter and initialize the flags member variable.\n+\t* tree-loop-distribution.c (compute_alias_check_pairs): Update\n+\tcall accordingly.\n+\t* tree-vect-data-refs.c (vect_prune_runtime_alias_test_list): Likewise.\n+\tEnsure the two data references in an alias pair are in statement\n+\torder, if there is a defined order.\n+\t* tree-data-ref.c (prune_runtime_alias_test_list): Use\n+\tDR_ALIAS_SWAPPED and DR_ALIAS_UNSWAPPED to record whether we've\n+\tswapped the references in a dr_with_seg_len_pair_t.  OR together\n+\tthe flags when merging two dr_with_seg_len_pair_ts.  After merging,\n+\ttry to restore the original dr_with_seg_len order, updating the\n+\tflags if that fails.\n+\n 2019-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-data-ref.c (prune_runtime_alias_test_list): Delay"}, {"sha": "21cd2ad7bb04b80e9ddd2820088bc3e5fff9febb", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9acf80c96d681917d930869b7cbfb7d2fa54d51/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9acf80c96d681917d930869b7cbfb7d2fa54d51/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=e9acf80c96d681917d930869b7cbfb7d2fa54d51", "patch": "@@ -1502,7 +1502,12 @@ prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n       if (comp_res == 0)\n \tcomp_res = data_ref_compare_tree (DR_INIT (dr_a), DR_INIT (dr_b));\n       if (comp_res > 0)\n-\tstd::swap (alias_pair->first, alias_pair->second);\n+\t{\n+\t  std::swap (alias_pair->first, alias_pair->second);\n+\t  alias_pair->flags |= DR_ALIAS_SWAPPED;\n+\t}\n+      else\n+\talias_pair->flags |= DR_ALIAS_UNSWAPPED;\n     }\n \n   /* Sort the collected data ref pairs so that we can scan them once to\n@@ -1514,10 +1519,13 @@ prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n   for (i = 1; i < alias_pairs->length (); ++i)\n     {\n       /* Deal with two ddrs (dr_a1, dr_b1) and (dr_a2, dr_b2).  */\n-      dr_with_seg_len *dr_a1 = &(*alias_pairs)[i-1].first,\n-\t\t      *dr_b1 = &(*alias_pairs)[i-1].second,\n-\t\t      *dr_a2 = &(*alias_pairs)[i].first,\n-\t\t      *dr_b2 = &(*alias_pairs)[i].second;\n+      dr_with_seg_len_pair_t *alias_pair1 = &(*alias_pairs)[i - 1];\n+      dr_with_seg_len_pair_t *alias_pair2 = &(*alias_pairs)[i];\n+\n+      dr_with_seg_len *dr_a1 = &alias_pair1->first;\n+      dr_with_seg_len *dr_b1 = &alias_pair1->second;\n+      dr_with_seg_len *dr_a2 = &alias_pair2->first;\n+      dr_with_seg_len *dr_b2 = &alias_pair2->second;\n \n       /* Remove duplicate data ref pairs.  */\n       if (*dr_a1 == *dr_a2 && *dr_b1 == *dr_b2)\n@@ -1526,6 +1534,7 @@ prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n \t    dump_printf (MSG_NOTE, \"found equal ranges %T, %T and %T, %T\\n\",\n \t\t\t DR_REF (dr_a1->dr), DR_REF (dr_b1->dr),\n \t\t\t DR_REF (dr_a2->dr), DR_REF (dr_b2->dr));\n+\t  alias_pair1->flags |= alias_pair2->flags;\n \t  alias_pairs->ordered_remove (i--);\n \t  continue;\n \t}\n@@ -1631,10 +1640,26 @@ prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n \t    dump_printf (MSG_NOTE, \"merging ranges for %T, %T and %T, %T\\n\",\n \t\t\t DR_REF (dr_a1->dr), DR_REF (dr_b1->dr),\n \t\t\t DR_REF (dr_a2->dr), DR_REF (dr_b2->dr));\n+\t  alias_pair1->flags |= alias_pair2->flags;\n \t  alias_pairs->ordered_remove (i);\n \t  i--;\n \t}\n     }\n+\n+  /* Try to restore the original dr_with_seg_len order within each\n+     dr_with_seg_len_pair_t.  If we ended up combining swapped and\n+     unswapped pairs into the same check, we have to invalidate any\n+     RAW, WAR and WAW information for it.  */\n+  FOR_EACH_VEC_ELT (*alias_pairs, i, alias_pair)\n+    {\n+      unsigned int swap_mask = (DR_ALIAS_SWAPPED | DR_ALIAS_UNSWAPPED);\n+      unsigned int swapped = (alias_pair->flags & swap_mask);\n+      if (swapped == DR_ALIAS_SWAPPED)\n+\tstd::swap (alias_pair->first, alias_pair->second);\n+      else if (swapped != DR_ALIAS_UNSWAPPED)\n+\talias_pair->flags |= DR_ALIAS_ARBITRARY;\n+      alias_pair->flags &= ~swap_mask;\n+    }\n }\n \n /* Given LOOP's two data references and segment lengths described by DR_A"}, {"sha": "284672425f690e2f98aa4126bee1f824e741f0ba", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 90, "deletions": 3, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9acf80c96d681917d930869b7cbfb7d2fa54d51/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9acf80c96d681917d930869b7cbfb7d2fa54d51/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=e9acf80c96d681917d930869b7cbfb7d2fa54d51", "patch": "@@ -222,20 +222,107 @@ class dr_with_seg_len\n   unsigned int align;\n };\n \n+/* Flags that describe a potential alias between two dr_with_seg_lens.\n+   In general, each pair of dr_with_seg_lens represents a composite of\n+   multiple access pairs P, so testing flags like DR_IS_READ on the DRs\n+   does not give meaningful information.\n+\n+   DR_ALIAS_RAW:\n+\tThere is a pair in P for which the second reference is a read\n+\tand the first is a write.\n+\n+   DR_ALIAS_WAR:\n+\tThere is a pair in P for which the second reference is a write\n+\tand the first is a read.\n+\n+   DR_ALIAS_WAW:\n+\tThere is a pair in P for which both references are writes.\n+\n+   DR_ALIAS_ARBITRARY:\n+\tEither\n+\t(a) it isn't possible to classify one pair in P as RAW, WAW or WAR; or\n+\t(b) there is a pair in P that breaks the ordering assumption below.\n+\n+\tThis flag overrides the RAW, WAR and WAW flags above.\n+\n+   DR_ALIAS_UNSWAPPED:\n+   DR_ALIAS_SWAPPED:\n+\tTemporary flags that indicate whether there is a pair P whose\n+\tDRs have or haven't been swapped around.\n+\n+   The ordering assumption mentioned above is that for every pair\n+   (DR_A, DR_B) in P:\n+\n+   (1) The original code accesses n elements for DR_A and n elements for DR_B,\n+       interleaved as follows:\n+\n+\t one access of size DR_A.access_size at DR_A.dr\n+\t one access of size DR_B.access_size at DR_B.dr\n+\t one access of size DR_A.access_size at DR_A.dr + STEP_A\n+\t one access of size DR_B.access_size at DR_B.dr + STEP_B\n+\t one access of size DR_A.access_size at DR_A.dr + STEP_A * 2\n+\t one access of size DR_B.access_size at DR_B.dr + STEP_B * 2\n+\t ...\n+\n+   (2) The new code accesses the same data in exactly two chunks:\n+\n+\t one group of accesses spanning |DR_A.seg_len| + DR_A.access_size\n+\t one group of accesses spanning |DR_B.seg_len| + DR_B.access_size\n+\n+   A pair might break this assumption if the DR_A and DR_B accesses\n+   in the original or the new code are mingled in some way.  For example,\n+   if DR_A.access_size represents the effect of two individual writes\n+   to nearby locations, the pair breaks the assumption if those writes\n+   occur either side of the access for DR_B.\n+\n+   Note that DR_ALIAS_ARBITRARY describes whether the ordering assumption\n+   fails to hold for any individual pair in P.  If the assumption *does*\n+   hold for every pair in P, it doesn't matter whether it holds for the\n+   composite pair or not.  In other words, P should represent the complete\n+   set of pairs that the composite pair is testing, so only the ordering\n+   of two accesses in the same member of P matters.  */\n+const unsigned int DR_ALIAS_RAW = 1U << 0;\n+const unsigned int DR_ALIAS_WAR = 1U << 1;\n+const unsigned int DR_ALIAS_WAW = 1U << 2;\n+const unsigned int DR_ALIAS_ARBITRARY = 1U << 3;\n+const unsigned int DR_ALIAS_SWAPPED = 1U << 4;\n+const unsigned int DR_ALIAS_UNSWAPPED = 1U << 5;\n+\n /* This struct contains two dr_with_seg_len objects with aliasing data\n    refs.  Two comparisons are generated from them.  */\n \n class dr_with_seg_len_pair_t\n {\n public:\n-  dr_with_seg_len_pair_t (const dr_with_seg_len& d1,\n-\t\t\t       const dr_with_seg_len& d2)\n-    : first (d1), second (d2) {}\n+  /* WELL_ORDERED indicates that the ordering assumption described above\n+     DR_ALIAS_ARBITRARY holds.  REORDERED indicates that it doesn't.  */\n+  enum sequencing { WELL_ORDERED, REORDERED };\n+\n+  dr_with_seg_len_pair_t (const dr_with_seg_len &,\n+\t\t\t  const dr_with_seg_len &, sequencing);\n \n   dr_with_seg_len first;\n   dr_with_seg_len second;\n+  unsigned int flags;\n };\n \n+inline dr_with_seg_len_pair_t::\n+dr_with_seg_len_pair_t (const dr_with_seg_len &d1, const dr_with_seg_len &d2,\n+\t\t\tsequencing seq)\n+  : first (d1), second (d2), flags (0)\n+{\n+  if (DR_IS_READ (d1.dr) && DR_IS_WRITE (d2.dr))\n+    flags |= DR_ALIAS_WAR;\n+  else if (DR_IS_WRITE (d1.dr) && DR_IS_READ (d2.dr))\n+    flags |= DR_ALIAS_RAW;\n+  else if (DR_IS_WRITE (d1.dr) && DR_IS_WRITE (d2.dr))\n+    flags |= DR_ALIAS_WAW;\n+  else\n+    gcc_unreachable ();\n+  if (seq == REORDERED)\n+    flags |= DR_ALIAS_ARBITRARY;\n+}\n+\n enum data_dependence_direction {\n   dir_positive,\n   dir_negative,"}, {"sha": "28eeeb93174b9fafbfb7d24fb1007237cbd553bc", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9acf80c96d681917d930869b7cbfb7d2fa54d51/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9acf80c96d681917d930869b7cbfb7d2fa54d51/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=e9acf80c96d681917d930869b7cbfb7d2fa54d51", "patch": "@@ -2476,7 +2476,9 @@ compute_alias_check_pairs (class loop *loop, vec<ddr_p> *alias_ddrs,\n \n       dr_with_seg_len_pair_t dr_with_seg_len_pair\n \t(dr_with_seg_len (dr_a, seg_length_a, access_size_a, align_a),\n-\t dr_with_seg_len (dr_b, seg_length_b, access_size_b, align_b));\n+\t dr_with_seg_len (dr_b, seg_length_b, access_size_b, align_b),\n+\t /* ??? Would WELL_ORDERED be safe?  */\n+\t dr_with_seg_len_pair_t::REORDERED);\n \n       comp_alias_pairs->safe_push (dr_with_seg_len_pair);\n     }"}, {"sha": "72a70945f086191673175cd8384d23405b20fbd7", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9acf80c96d681917d930869b7cbfb7d2fa54d51/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9acf80c96d681917d930869b7cbfb7d2fa54d51/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=e9acf80c96d681917d930869b7cbfb7d2fa54d51", "patch": "@@ -3508,10 +3508,13 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n       dr_vec_info *dr_info_b = loop_vinfo->lookup_dr (DDR_B (ddr));\n       stmt_vec_info stmt_info_b = dr_info_b->stmt;\n \n+      bool preserves_scalar_order_p\n+\t= vect_preserves_scalar_order_p (dr_info_a, dr_info_b);\n+\n       /* Skip the pair if inter-iteration dependencies are irrelevant\n \t and intra-iteration dependencies are guaranteed to be honored.  */\n       if (ignore_step_p\n-\t  && (vect_preserves_scalar_order_p (dr_info_a, dr_info_b)\n+\t  && (preserves_scalar_order_p\n \t      || vectorizable_with_step_bound_p (dr_info_a, dr_info_b,\n \t\t\t\t\t\t &lower_bound)))\n \t{\n@@ -3629,11 +3632,21 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \t\t\t\t\t   stmt_info_b->stmt);\n \t}\n \n+      dr_with_seg_len dr_a (dr_info_a->dr, segment_length_a,\n+\t\t\t    access_size_a, align_a);\n+      dr_with_seg_len dr_b (dr_info_b->dr, segment_length_b,\n+\t\t\t    access_size_b, align_b);\n+      /* Canonicalize the order to be the one that's needed for accurate\n+\t RAW, WAR and WAW flags, in cases where the data references are\n+\t well-ordered.  The order doesn't really matter otherwise,\n+\t but we might as well be consistent.  */\n+      if (get_later_stmt (stmt_info_a, stmt_info_b) == stmt_info_a)\n+\tstd::swap (dr_a, dr_b);\n+\n       dr_with_seg_len_pair_t dr_with_seg_len_pair\n-\t(dr_with_seg_len (dr_info_a->dr, segment_length_a,\n-\t\t\t  access_size_a, align_a),\n-\t dr_with_seg_len (dr_info_b->dr, segment_length_b,\n-\t\t\t  access_size_b, align_b));\n+\t(dr_a, dr_b, (preserves_scalar_order_p\n+\t\t      ? dr_with_seg_len_pair_t::WELL_ORDERED\n+\t\t      : dr_with_seg_len_pair_t::REORDERED));\n \n       comp_alias_ddrs.safe_push (dr_with_seg_len_pair);\n     }"}]}