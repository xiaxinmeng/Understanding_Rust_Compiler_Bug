{"sha": "22854930b945f09487ca7947326d741ff6328377", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI4NTQ5MzBiOTQ1ZjA5NDg3Y2E3OTQ3MzI2ZDc0MWZmNjMyODM3Nw==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2012-09-05T10:14:37Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2012-09-05T10:14:37Z"}, "message": "re PR c++/54191 ([C++11] SFINAE does not handle conversion to inaccessible base)\n\n/cp\n2012-09-05  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/54191\n\t* search.c (lookup_base): Add tsubst_flags_t parameter.\n\t(adjust_result_of_qualified_name_lookup, check_final_overrider):\n\tAdjust.\n\t* name-lookup.c (do_class_using_decl): Adjust.\n\t* typeck2.c (binfo_or_else, build_scoped_ref, build_m_component_ref):\n\tLikewise.\n\t* cvt.c (cp_convert_to_pointer, convert_to_pointer_force,\n\tbuild_up_reference): Likewise.\n\t* rtti.c (build_dynamic_cast_1): Likewise.\n\t* tree.c (maybe_dummy_object): Likewise.\n\t* call.c (build_conditional_expr_1, build_over_call): Likewise.\n\t* cp-tree.h (UNIQUELY_DERIVED_FROM_P, PUBLICLY_UNIQUELY_DERIVED_P):\n\tRemove.\n\t(enum base_access_flags, ba_quiet): Remove.\n\t(uniquely_derived_from_p, publicly_uniquely_derived_p): Declare.\n\t* except.c (can_convert_eh): Adjust.\n\t* decl.c (grokdeclarator): Likewise.\n\t* typeck.c (comp_except_types, build_class_member_access_expr,\n\tfinish_class_member_access_expr, get_member_function_from_ptrfunc,\n\tbuild_static_cast_1, get_delta_difference_1): Likewise.\n\t* class.c (build_base_path, convert_to_base, build_vtbl_ref_1,\n\twarn_about_ambiguous_bases): Likewise.\n\t(uniquely_derived_from_p, publicly_uniquely_derived_p): Define.\n\n/testsuite\n2012-09-05  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/54191\n\t* g++.dg/cpp0x/sfinae39.C: New.\n\nFrom-SVN: r190969", "tree": {"sha": "2f95f089c2fa4d79dab5770ad9a8b5fa4956d54b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f95f089c2fa4d79dab5770ad9a8b5fa4956d54b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22854930b945f09487ca7947326d741ff6328377", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22854930b945f09487ca7947326d741ff6328377", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22854930b945f09487ca7947326d741ff6328377", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22854930b945f09487ca7947326d741ff6328377/comments", "author": null, "committer": null, "parents": [{"sha": "b588ae3074e258f5c736034c212e7499a565746f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b588ae3074e258f5c736034c212e7499a565746f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b588ae3074e258f5c736034c212e7499a565746f"}], "stats": {"total": 348, "additions": 268, "deletions": 80}, "files": [{"sha": "41c01601b561ed349ead24c0ab4b072ff33f759a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=22854930b945f09487ca7947326d741ff6328377", "patch": "@@ -1,3 +1,30 @@\n+2012-09-05  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/54191\n+\t* search.c (lookup_base): Add tsubst_flags_t parameter.\n+\t(adjust_result_of_qualified_name_lookup, check_final_overrider):\n+\tAdjust.\n+\t* name-lookup.c (do_class_using_decl): Adjust.\n+\t* typeck2.c (binfo_or_else, build_scoped_ref, build_m_component_ref):\n+\tLikewise.\n+\t* cvt.c (cp_convert_to_pointer, convert_to_pointer_force,\n+\tbuild_up_reference): Likewise.\n+\t* rtti.c (build_dynamic_cast_1): Likewise.\n+\t* tree.c (maybe_dummy_object): Likewise.\n+\t* call.c (build_conditional_expr_1, build_over_call): Likewise.\n+\t* cp-tree.h (UNIQUELY_DERIVED_FROM_P, PUBLICLY_UNIQUELY_DERIVED_P):\n+\tRemove.\n+\t(enum base_access_flags, ba_quiet): Remove.\n+\t(uniquely_derived_from_p, publicly_uniquely_derived_p): Declare.\n+\t* except.c (can_convert_eh): Adjust.\n+\t* decl.c (grokdeclarator): Likewise.\n+\t* typeck.c (comp_except_types, build_class_member_access_expr,\n+\tfinish_class_member_access_expr, get_member_function_from_ptrfunc,\n+\tbuild_static_cast_1, get_delta_difference_1): Likewise.\n+\t* class.c (build_base_path, convert_to_base, build_vtbl_ref_1,\n+\twarn_about_ambiguous_bases): Likewise.\n+\t(uniquely_derived_from_p, publicly_uniquely_derived_p): Define.\n+\n 2012-09-04  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/54441"}, {"sha": "159be6b7bca0d6bb6ed8a101559fce01bd3cd6e3", "filename": "gcc/cp/call.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=22854930b945f09487ca7947326d741ff6328377", "patch": "@@ -4758,6 +4758,9 @@ build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n       return error_mark_node;\n     }\n \n+  if (arg2 == error_mark_node || arg3 == error_mark_node)\n+    return error_mark_node;\n+\n  valid_operands:\n   result = build3 (COND_EXPR, result_type, arg1, arg2, arg3);\n   if (!cp_unevaluated_operand)\n@@ -6608,7 +6611,8 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t will be to the derived class, not the base declaring fn. We\n \t must convert from derived to base.  */\n       base_binfo = lookup_base (TREE_TYPE (TREE_TYPE (converted_arg)),\n-\t\t\t\tTREE_TYPE (parmtype), ba_unique, NULL);\n+\t\t\t\tTREE_TYPE (parmtype), ba_unique,\n+\t\t\t\tNULL, complain);\n       converted_arg = build_base_path (PLUS_EXPR, converted_arg,\n \t\t\t\t       base_binfo, 1, complain);\n \n@@ -6852,7 +6856,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       tree t;\n       tree binfo = lookup_base (TREE_TYPE (TREE_TYPE (argarray[0])),\n \t\t\t\tDECL_CONTEXT (fn),\n-\t\t\t\tba_any, NULL);\n+\t\t\t\tba_any, NULL, complain);\n       gcc_assert (binfo && binfo != error_mark_node);\n \n       /* Warn about deprecated virtual functions now, since we're about"}, {"sha": "13d9c768509ba1519f7280adb9bc53d594740d50", "filename": "gcc/cp/class.c", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=22854930b945f09487ca7947326d741ff6328377", "patch": "@@ -275,7 +275,7 @@ build_base_path (enum tree_code code,\n       if (complain & tf_error)\n \t{\n \t  tree base = lookup_base (probe, BINFO_TYPE (d_binfo),\n-\t\t\t\t   ba_unique, NULL);\n+\t\t\t\t   ba_unique, NULL, complain);\n \t  gcc_assert (base == error_mark_node);\n \t}\n       return error_mark_node;\n@@ -544,7 +544,6 @@ convert_to_base (tree object, tree type, bool check_access, bool nonnull,\n {\n   tree binfo;\n   tree object_type;\n-  base_access access;\n \n   if (TYPE_PTR_P (TREE_TYPE (object)))\n     {\n@@ -554,12 +553,8 @@ convert_to_base (tree object, tree type, bool check_access, bool nonnull,\n   else\n     object_type = TREE_TYPE (object);\n \n-  access = check_access ? ba_check : ba_unique;\n-  if (!(complain & tf_error))\n-    access |= ba_quiet;\n-  binfo = lookup_base (object_type, type,\n-\t\t       access,\n-\t\t       NULL);\n+  binfo = lookup_base (object_type, type, check_access ? ba_check : ba_unique,\n+\t\t       NULL, complain);\n   if (!binfo || binfo == error_mark_node)\n     return error_mark_node;\n \n@@ -652,8 +647,8 @@ build_vtbl_ref_1 (tree instance, tree idx)\n   if (fixed_type && !cdtorp)\n     {\n       tree binfo = lookup_base (fixed_type, basetype,\n-\t\t\t\tba_unique | ba_quiet, NULL);\n-      if (binfo)\n+\t\t\t\tba_unique, NULL, tf_none);\n+      if (binfo && binfo != error_mark_node)\n \tvtbl = unshare_expr (BINFO_VTABLE (binfo));\n     }\n \n@@ -5483,7 +5478,7 @@ warn_about_ambiguous_bases (tree t)\n     {\n       basetype = BINFO_TYPE (base_binfo);\n \n-      if (!lookup_base (t, basetype, ba_unique | ba_quiet, NULL))\n+      if (!uniquely_derived_from_p (basetype, t))\n \twarning (0, \"direct base %qT inaccessible in %qT due to ambiguity\",\n \t\t basetype, t);\n     }\n@@ -5495,9 +5490,9 @@ warn_about_ambiguous_bases (tree t)\n       {\n \tbasetype = BINFO_TYPE (binfo);\n \n-\tif (!lookup_base (t, basetype, ba_unique | ba_quiet, NULL))\n-\t  warning (OPT_Wextra, \"virtual base %qT inaccessible in %qT due to ambiguity\",\n-\t\t   basetype, t);\n+\tif (!uniquely_derived_from_p (basetype, t))\n+\t  warning (OPT_Wextra, \"virtual base %qT inaccessible in %qT due \"\n+\t\t   \"to ambiguity\", basetype, t);\n       }\n }\n \n@@ -8933,4 +8928,24 @@ build_rtti_vtbl_entries (tree binfo, vtbl_init_data* vid)\n   CONSTRUCTOR_APPEND_ELT (vid->inits, NULL_TREE, init);\n }\n \n+/* TRUE iff TYPE is uniquely derived from PARENT.  Ignores\n+   accessibility.  */\n+\n+bool\n+uniquely_derived_from_p (tree parent, tree type)\n+{\n+  tree base = lookup_base (type, parent, ba_unique, NULL, tf_none);\n+  return base && base != error_mark_node;\n+}\n+\n+/* TRUE iff TYPE is publicly & uniquely derived from PARENT.  */\n+\n+bool\n+publicly_uniquely_derived_p (tree parent, tree type)\n+{\n+  tree base = lookup_base (type, parent, ba_ignore_scope | ba_check,\n+\t\t\t   NULL, tf_none);\n+  return base && base != error_mark_node;\n+}\n+\n #include \"gt-cp-class.h\""}, {"sha": "3e0fc3f1ebc231b189f29764154f4edadfb9167c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=22854930b945f09487ca7947326d741ff6328377", "patch": "@@ -1278,15 +1278,8 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n /* Nonzero iff TYPE is derived from PARENT. Ignores accessibility and\n    ambiguity issues.  */\n #define DERIVED_FROM_P(PARENT, TYPE) \\\n-  (lookup_base ((TYPE), (PARENT), ba_any, NULL) != NULL_TREE)\n-/* Nonzero iff TYPE is uniquely derived from PARENT. Ignores\n-   accessibility.  */\n-#define UNIQUELY_DERIVED_FROM_P(PARENT, TYPE) \\\n-  (lookup_base ((TYPE), (PARENT), ba_unique | ba_quiet, NULL) != NULL_TREE)\n-/* Nonzero iff TYPE is publicly & uniquely derived from PARENT.  */\n-#define PUBLICLY_UNIQUELY_DERIVED_P(PARENT, TYPE) \\\n-  (lookup_base ((TYPE), (PARENT), ba_ignore_scope | ba_check | ba_quiet, \\\n-\t\tNULL) != NULL_TREE)\n+  (lookup_base ((TYPE), (PARENT), ba_any, NULL, tf_warning_or_error)\\\n+   != NULL_TREE)\n \n /* Gives the visibility specification for a class type.  */\n #define CLASSTYPE_VISIBILITY(TYPE)\t\t\\\n@@ -4187,8 +4180,7 @@ enum base_access_flags {\n   ba_unique = 1 << 0,  /* Must be a unique base.  */\n   ba_check_bit = 1 << 1,   /* Check access.  */\n   ba_check = ba_unique | ba_check_bit,\n-  ba_ignore_scope = 1 << 2, /* Ignore access allowed by local scope.  */\n-  ba_quiet = 1 << 3     /* Do not issue error messages.  */\n+  ba_ignore_scope = 1 << 2 /* Ignore access allowed by local scope.  */\n };\n \n /* This type is used for parameters and variables which hold\n@@ -5003,6 +4995,8 @@ extern void clone_function_decl\t\t\t(tree, int);\n extern void adjust_clone_args\t\t\t(tree);\n extern void deduce_noexcept_on_destructor       (tree);\n extern void insert_late_enum_def_into_classtype_sorted_fields (tree, tree);\n+extern bool uniquely_derived_from_p             (tree, tree);\n+extern bool publicly_uniquely_derived_p         (tree, tree);\n \n /* in cvt.c */\n extern tree convert_to_reference\t\t(tree, tree, int, int, tree,\n@@ -5438,8 +5432,8 @@ extern bool emit_tinfo_decl\t\t\t(tree);\n \n /* in search.c */\n extern bool accessible_base_p\t\t\t(tree, tree, bool);\n-extern tree lookup_base\t\t\t\t(tree, tree, base_access,\n-\t\t\t\t\t\t base_kind *);\n+extern tree lookup_base                         (tree, tree, base_access,\n+\t\t\t\t\t\t base_kind *, tsubst_flags_t);\n extern tree dcast_base_hint\t\t\t(tree, tree);\n extern int accessible_p\t\t\t\t(tree, tree, bool);\n extern tree lookup_field_1\t\t\t(tree, tree, bool);"}, {"sha": "86f01abf2f3757a69e79ca83f5ef951c04d07f98", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=22854930b945f09487ca7947326d741ff6328377", "patch": "@@ -149,11 +149,13 @@ cp_convert_to_pointer (tree type, tree expr, tsubst_flags_t complain)\n \t  binfo = NULL_TREE;\n \t  /* Try derived to base conversion.  */\n \t  if (!same_p)\n-\t    binfo = lookup_base (intype_class, type_class, ba_check, NULL);\n+\t    binfo = lookup_base (intype_class, type_class, ba_check,\n+\t\t\t\t NULL, complain);\n \t  if (!same_p && !binfo)\n \t    {\n \t      /* Try base to derived conversion.  */\n-\t      binfo = lookup_base (type_class, intype_class, ba_check, NULL);\n+\t      binfo = lookup_base (type_class, intype_class, ba_check,\n+\t\t\t\t   NULL, complain);\n \t      code = MINUS_EXPR;\n \t    }\n \t  if (binfo == error_mark_node)\n@@ -279,11 +281,11 @@ convert_to_pointer_force (tree type, tree expr, tsubst_flags_t complain)\n \t  tree binfo;\n \n \t  binfo = lookup_base (TREE_TYPE (intype), TREE_TYPE (type),\n-\t\t\t       ba_unique, NULL);\n+\t\t\t       ba_unique, NULL, complain);\n \t  if (!binfo)\n \t    {\n \t      binfo = lookup_base (TREE_TYPE (type), TREE_TYPE (intype),\n-\t\t\t\t   ba_unique, NULL);\n+\t\t\t\t   ba_unique, NULL, complain);\n \t      code = MINUS_EXPR;\n \t    }\n \t  if (binfo == error_mark_node)\n@@ -352,7 +354,8 @@ build_up_reference (tree type, tree arg, int flags, tree decl,\n       && MAYBE_CLASS_TYPE_P (target_type))\n     {\n       /* We go through lookup_base for the access control.  */\n-      tree binfo = lookup_base (argtype, target_type, ba_check, NULL);\n+      tree binfo = lookup_base (argtype, target_type, ba_check,\n+\t\t\t\tNULL, complain);\n       if (binfo == error_mark_node)\n \treturn error_mark_node;\n       if (binfo == NULL_TREE)"}, {"sha": "f86c54ffff6405b876975cc98138602e3ccb2762", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=22854930b945f09487ca7947326d741ff6328377", "patch": "@@ -8524,7 +8524,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t      }\n \t\t    else if (innermost_code != cdk_function\n \t\t\t     && current_class_type\n-\t\t\t     && !UNIQUELY_DERIVED_FROM_P (ctype,\n+\t\t\t     && !uniquely_derived_from_p (ctype,\n \t\t\t\t\t\t\t  current_class_type))\n \t\t      {\n \t\t\terror (\"type %qT is not derived from type %qT\","}, {"sha": "ff967de37f72bcf8490020564e0ec1c0c58daa0d", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=22854930b945f09487ca7947326d741ff6328377", "patch": "@@ -1052,7 +1052,7 @@ can_convert_eh (tree to, tree from)\n     }\n \n   if (CLASS_TYPE_P (to) && CLASS_TYPE_P (from)\n-      && PUBLICLY_UNIQUELY_DERIVED_P (to, from))\n+      && publicly_uniquely_derived_p (to, from))\n     return 1;\n \n   return 0;"}, {"sha": "9392c01dc94b368f634e6d73ed92bc5bcf51535a", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=22854930b945f09487ca7947326d741ff6328377", "patch": "@@ -3264,7 +3264,8 @@ do_class_using_decl (tree scope, tree name)\n   if (!scope_dependent_p)\n     {\n       base_kind b_kind;\n-      binfo = lookup_base (current_class_type, scope, ba_any, &b_kind);\n+      binfo = lookup_base (current_class_type, scope, ba_any, &b_kind,\n+\t\t\t   tf_warning_or_error);\n       if (b_kind < bk_proper_base)\n \t{\n \t  if (!bases_dependent_p)"}, {"sha": "e61918094a5b7f328632caf5273cdaece136e621", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=22854930b945f09487ca7947326d741ff6328377", "patch": "@@ -615,7 +615,7 @@ build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)\n     tree binfo;\n \n     binfo = lookup_base (TREE_TYPE (exprtype), TREE_TYPE (type),\n-\t\t\t ba_check, NULL);\n+\t\t\t ba_check, NULL, complain);\n \n     if (binfo)\n       {"}, {"sha": "7d358ef3a47dbdb446055071684a3d60b9740750", "filename": "gcc/cp/search.c", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=22854930b945f09487ca7947326d741ff6328377", "patch": "@@ -179,13 +179,13 @@ accessible_base_p (tree t, tree base, bool consider_local_p)\n    non-NULL, fill with information about what kind of base we\n    discovered.\n \n-   If the base is inaccessible, or ambiguous, and the ba_quiet bit is\n-   not set in ACCESS, then an error is issued and error_mark_node is\n-   returned.  If the ba_quiet bit is set, then no error is issued and\n-   NULL_TREE is returned.  */\n+   If the base is inaccessible, or ambiguous, then error_mark_node is\n+   returned.  If the tf_error bit of COMPLAIN is not set, no error\n+   is issued.  */\n \n tree\n-lookup_base (tree t, tree base, base_access access, base_kind *kind_ptr)\n+lookup_base (tree t, tree base, base_access access,\n+\t     base_kind *kind_ptr, tsubst_flags_t complain)\n {\n   tree binfo;\n   tree t_binfo;\n@@ -251,11 +251,9 @@ lookup_base (tree t, tree base, base_access access, base_kind *kind_ptr)\n \tbreak;\n \n       case bk_ambig:\n-\tif (!(access & ba_quiet))\n-\t  {\n-\t    error (\"%qT is an ambiguous base of %qT\", base, t);\n-\t    binfo = error_mark_node;\n-\t  }\n+\tif (complain & tf_error)\n+\t  error (\"%qT is an ambiguous base of %qT\", base, t);\n+\tbinfo = error_mark_node;\n \tbreak;\n \n       default:\n@@ -269,13 +267,9 @@ lookup_base (tree t, tree base, base_access access, base_kind *kind_ptr)\n \t    && COMPLETE_TYPE_P (base)\n \t    && !accessible_base_p (t, base, !(access & ba_ignore_scope)))\n \t  {\n-\t    if (!(access & ba_quiet))\n-\t      {\n-\t\terror (\"%qT is an inaccessible base of %qT\", base, t);\n-\t\tbinfo = error_mark_node;\n-\t      }\n-\t    else\n-\t      binfo = NULL_TREE;\n+\t    if (complain & tf_error)\n+\t      error (\"%qT is an inaccessible base of %qT\", base, t);\n+\t    binfo = error_mark_node;\n \t    bk = bk_inaccessible;\n \t  }\n \tbreak;\n@@ -1537,14 +1531,13 @@ adjust_result_of_qualified_name_lookup (tree decl,\n \t or ambiguity -- in either case, the choice of a static member\n \t function might make the usage valid.  */\n       base = lookup_base (context_class, qualifying_scope,\n-\t\t\t  ba_unique | ba_quiet, NULL);\n-      if (base)\n+\t\t\t  ba_unique, NULL, tf_none);\n+      if (base && base != error_mark_node)\n \t{\n \t  BASELINK_ACCESS_BINFO (decl) = base;\n \t  BASELINK_BINFO (decl)\n \t    = lookup_base (base, BINFO_TYPE (BASELINK_BINFO (decl)),\n-\t\t\t   ba_unique | ba_quiet,\n-\t\t\t   NULL);\n+\t\t\t   ba_unique, NULL, tf_none);\n \t}\n     }\n \n@@ -1875,12 +1868,13 @@ check_final_overrider (tree overrider, tree basefn)\n \t  /* Strictly speaking, the standard requires the return type to be\n \t     complete even if it only differs in cv-quals, but that seems\n \t     like a bug in the wording.  */\n-\t  if (!same_type_ignoring_top_level_qualifiers_p (base_return, over_return))\n+\t  if (!same_type_ignoring_top_level_qualifiers_p (base_return,\n+\t\t\t\t\t\t\t  over_return))\n \t    {\n \t      tree binfo = lookup_base (over_return, base_return,\n-\t\t\t\t\tba_check | ba_quiet, NULL);\n+\t\t\t\t\tba_check, NULL, tf_none);\n \n-\t      if (!binfo)\n+\t      if (!binfo || binfo == error_mark_node)\n \t\tfail = 1;\n \t    }\n \t}"}, {"sha": "ce1af73a16dbbe3bd7d1ab2d2277a34aceb74758", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=22854930b945f09487ca7947326d741ff6328377", "patch": "@@ -2772,7 +2772,8 @@ maybe_dummy_object (tree type, tree* binfop)\n   tree current = current_nonlambda_class_type ();\n \n   if (current\n-      && (binfo = lookup_base (current, type, ba_any, NULL)))\n+      && (binfo = lookup_base (current, type, ba_any, NULL,\n+\t\t\t       tf_warning_or_error)))\n     context = current;\n   else\n     {"}, {"sha": "f62532153fd175318ea4633948d2fb69b5797b42", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=22854930b945f09487ca7947326d741ff6328377", "patch": "@@ -975,7 +975,7 @@ comp_except_types (tree a, tree b, bool exact)\n \t  || TREE_CODE (b) != RECORD_TYPE)\n \treturn false;\n \n-      if (PUBLICLY_UNIQUELY_DERIVED_P (a, b))\n+      if (publicly_uniquely_derived_p (a, b))\n \treturn true;\n     }\n   return false;\n@@ -2247,7 +2247,7 @@ build_class_member_access_expr (tree object, tree member,\n \t  base_kind kind;\n \n \t  binfo = lookup_base (access_path ? access_path : object_type,\n-\t\t\t       member_scope, ba_unique,  &kind);\n+\t\t\t       member_scope, ba_unique, &kind, complain);\n \t  if (binfo == error_mark_node)\n \t    return error_mark_node;\n \n@@ -2630,7 +2630,8 @@ finish_class_member_access_expr (tree object, tree name, bool template_p,\n \t    }\n \n \t  /* Find the base of OBJECT_TYPE corresponding to SCOPE.  */\n-\t  access_path = lookup_base (object_type, scope, ba_check, NULL);\n+\t  access_path = lookup_base (object_type, scope, ba_check,\n+\t\t\t\t     NULL, complain);\n \t  if (access_path == error_mark_node)\n \t    return error_mark_node;\n \t  if (!access_path)\n@@ -3151,7 +3152,7 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function,\n \t  (basetype, TREE_TYPE (TREE_TYPE (instance_ptr))))\n \t{\n \t  basetype = lookup_base (TREE_TYPE (TREE_TYPE (instance_ptr)),\n-\t\t\t\t  basetype, ba_check, NULL);\n+\t\t\t\t  basetype, ba_check, NULL, complain);\n \t  instance_ptr = build_base_path (PLUS_EXPR, instance_ptr, basetype,\n \t\t\t\t\t  1, complain);\n \t  if (instance_ptr == error_mark_node)\n@@ -5997,7 +5998,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n \t not considered.  */\n       base = lookup_base (TREE_TYPE (type), intype,\n \t\t\t  c_cast_p ? ba_unique : ba_check,\n-\t\t\t  NULL);\n+\t\t\t  NULL, complain);\n \n       /* Convert from \"B*\" to \"D*\".  This function will check that \"B\"\n \t is not a virtual base of \"D\".  */\n@@ -6121,7 +6122,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n \treturn error_mark_node;\n       base = lookup_base (TREE_TYPE (type), TREE_TYPE (intype),\n \t\t\t  c_cast_p ? ba_unique : ba_check,\n-\t\t\t  NULL);\n+\t\t\t  NULL, complain);\n       expr = build_base_path (MINUS_EXPR, expr, base, /*nonnull=*/false,\n \t\t\t      complain);\n       return cp_fold_convert(type, expr);\n@@ -7181,16 +7182,11 @@ get_delta_difference_1 (tree from, tree to, bool c_cast_p,\n {\n   tree binfo;\n   base_kind kind;\n-  base_access access = c_cast_p ? ba_unique : ba_check;\n \n-  /* Note: ba_quiet does not distinguish between access control and\n-     ambiguity.  */\n-  if (!(complain & tf_error))\n-    access |= ba_quiet;\n+  binfo = lookup_base (to, from, c_cast_p ? ba_unique : ba_check,\n+\t\t       &kind, complain);\n \n-  binfo = lookup_base (to, from, access, &kind);\n-\n-  if (kind == bk_inaccessible || kind == bk_ambig)\n+  if (binfo == error_mark_node)\n     {\n       if (!(complain & tf_error))\n \treturn error_mark_node;"}, {"sha": "6faebb5d8644d984377c21c742166678e5e39a93", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22854930b945f09487ca7947326d741ff6328377/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=22854930b945f09487ca7947326d741ff6328377", "patch": "@@ -57,7 +57,8 @@ error_not_base_type (tree basetype, tree type)\n tree\n binfo_or_else (tree base, tree type)\n {\n-  tree binfo = lookup_base (type, base, ba_unique, NULL);\n+  tree binfo = lookup_base (type, base, ba_unique,\n+\t\t\t    NULL, tf_warning_or_error);\n \n   if (binfo == error_mark_node)\n     return NULL_TREE;\n@@ -1447,7 +1448,8 @@ build_scoped_ref (tree datum, tree basetype, tree* binfo_p)\n   if (*binfo_p)\n     binfo = *binfo_p;\n   else\n-    binfo = lookup_base (TREE_TYPE (datum), basetype, ba_check, NULL);\n+    binfo = lookup_base (TREE_TYPE (datum), basetype, ba_check,\n+\t\t\t NULL, tf_warning_or_error);\n \n   if (!binfo || binfo == error_mark_node)\n     {\n@@ -1600,7 +1602,7 @@ build_m_component_ref (tree datum, tree component, tsubst_flags_t complain)\n     }\n   else\n     {\n-      binfo = lookup_base (objtype, ctype, ba_check, NULL);\n+      binfo = lookup_base (objtype, ctype, ba_check, NULL, complain);\n \n       if (!binfo)\n \t{"}, {"sha": "26a82dba39fead2322ba40ad034f773a173141a6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22854930b945f09487ca7947326d741ff6328377/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22854930b945f09487ca7947326d741ff6328377/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=22854930b945f09487ca7947326d741ff6328377", "patch": "@@ -1,3 +1,8 @@\n+2012-09-05  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/54191\n+\t* g++.dg/cpp0x/sfinae39.C: New.\n+\n 2012-09-04  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/54441"}, {"sha": "8183bda39abee4dbd7b59b46c5c27f7eb7f99d8b", "filename": "gcc/testsuite/g++.dg/cpp0x/sfinae39.C", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22854930b945f09487ca7947326d741ff6328377/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae39.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22854930b945f09487ca7947326d741ff6328377/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae39.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae39.C?ref=22854930b945f09487ca7947326d741ff6328377", "patch": "@@ -0,0 +1,146 @@\n+// PR c++/54191\n+// { dg-do compile { target c++11 } }\n+\n+struct B\n+{};\n+\n+struct D\n+  : private B\n+{};\n+\n+template<typename T>\n+T &&declval();\n+\n+\n+template<typename From, typename = decltype(B{declval<From>()})>\n+constexpr bool test_braced_cast_to_base(int)\n+{ return true; }\n+\n+template<typename>\n+constexpr bool test_braced_cast_to_base(bool)\n+{ return false; }\n+\n+static_assert(!test_braced_cast_to_base<D>(0), \"\");\n+\n+\n+template<typename From, typename = decltype(D{declval<From>()})>\n+constexpr bool test_braced_cast_to_derived(int)\n+{ return true; }\n+\n+template<typename>\n+constexpr bool test_braced_cast_to_derived(bool)\n+{ return false; }\n+\n+static_assert(!test_braced_cast_to_derived<B>(0), \"\");\n+\n+\n+typedef B *PB;\n+\n+template<typename From, typename = decltype(PB{declval<From>()})>\n+constexpr bool test_braced_cast_to_ptr_to_base(int)\n+{ return true; }\n+\n+template<typename>\n+constexpr bool test_braced_cast_to_ptr_to_base(bool)\n+{ return false; }\n+\n+static_assert(!test_braced_cast_to_ptr_to_base<D *>(0), \"\");\n+\n+\n+typedef D *PD;\n+\n+template<typename From, typename = decltype(PD{declval<From>()})>\n+constexpr bool test_braced_cast_to_ptr_to_derived(int)\n+{ return true; }\n+\n+template<typename>\n+constexpr bool test_braced_cast_to_ptr_to_derived(bool)\n+{ return false; }\n+\n+static_assert(!test_braced_cast_to_ptr_to_derived<B *>(0), \"\");\n+\n+\n+template<typename From, typename To,\n+         typename = decltype(static_cast<To>(declval<From>()))>\n+constexpr bool test_static_cast(int)\n+{ return true; }\n+\n+template<typename, typename>\n+constexpr bool test_static_cast(bool)\n+{ return false; }\n+\n+static_assert(!test_static_cast<B &, D &>(0), \"\");\n+static_assert(!test_static_cast<B *, D *>(0), \"\");\n+\n+\n+template<typename From, typename To,\n+         typename = decltype(dynamic_cast<To>(declval<From>()))>\n+constexpr bool test_dynamic_cast(int)\n+{ return true; }\n+\n+template<typename, typename>\n+constexpr bool test_dynamic_cast(bool)\n+{ return false; }\n+\n+static_assert(!test_dynamic_cast<D &, B &>(0), \"\");\n+static_assert(!test_dynamic_cast<D *, B *>(0), \"\");\n+\n+\n+int B::*pm = 0;\n+\n+template<typename T, typename = decltype(declval<T>().*pm)>\n+constexpr bool test_member_ptr_dot(int)\n+{ return true; }\n+\n+template<typename>\n+constexpr bool test_member_ptr_dot(bool)\n+{ return false; }\n+\n+static_assert(!test_member_ptr_dot<D>(0), \"\");\n+\n+\n+template<typename T, typename = decltype(declval<T>()->*pm)>\n+constexpr bool test_member_ptr_arrow(int)\n+{ return true; }\n+\n+template<typename>\n+constexpr bool test_member_ptr_arrow(bool)\n+{ return false; }\n+\n+static_assert(!test_member_ptr_arrow<D *>(0), \"\");\n+\n+\n+template<typename T, typename U,\n+         typename = decltype(declval<T>() < declval<U>())>\n+constexpr bool test_rel_op(int)\n+{ return true; }\n+\n+template<typename, typename>\n+constexpr bool test_rel_op(bool)\n+{ return false; }\n+\n+static_assert(!test_rel_op<D *, B *>(0), \"\");\n+\n+\n+template<typename T, typename U,\n+         typename = decltype(declval<T>() == declval<U>())>\n+constexpr bool test_eq(int)\n+{ return true; }\n+\n+template<typename, typename>\n+constexpr bool test_eq(bool)\n+{ return false; }\n+\n+static_assert(!test_eq<D *, B *>(0), \"\");\n+\n+\n+template<typename T, typename U,\n+         typename = decltype(false ? declval<T>() : declval<U>())>\n+constexpr bool test_cond_op(int)\n+{ return true; }\n+\n+template<typename, typename>\n+constexpr bool test_cond_op(bool)\n+{ return false; }\n+\n+static_assert(!test_cond_op<B *, D *>(0), \"\");"}]}