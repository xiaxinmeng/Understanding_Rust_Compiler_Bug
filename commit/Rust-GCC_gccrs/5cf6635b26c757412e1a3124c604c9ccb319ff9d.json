{"sha": "5cf6635b26c757412e1a3124c604c9ccb319ff9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNmNjYzNWIyNmM3NTc0MTJlMWEzMTI0YzYwNGM5Y2NiMzE5ZmY5ZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2013-08-07T17:17:07Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-08-07T17:17:07Z"}, "message": "rtl.h (update_alignments): Declare.\n\n\t* rtl.h (update_alignments): Declare.\n\t* final.c (grow_label_align): New function extracted from...\n\t(shorten_branches): ...here.  Call it.\n\t(update_alignments): New function.\n\t* reorg.c (sibling_labels): New variable.\n\t(get_label_before): Add SIBLING parameter.  If it is non-zero, push\n\tthe new label along with it onto the sibling_labels vector.\n\t(fill_simple_delay_slots): Adjust call to get_label_before.\n\t(fill_slots_from_thread): Likewise.\n\t(relax_delay_slots): Likewise.\n\t(make_return_insns): Likewise.\n\t(dbr_schedule): Invoke update_alignment on the sibling_labels vector.\n\nFrom-SVN: r201575", "tree": {"sha": "bf69301266f96ab07cb8e81f040fa1c0f1d8b4cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf69301266f96ab07cb8e81f040fa1c0f1d8b4cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cf6635b26c757412e1a3124c604c9ccb319ff9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cf6635b26c757412e1a3124c604c9ccb319ff9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cf6635b26c757412e1a3124c604c9ccb319ff9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cf6635b26c757412e1a3124c604c9ccb319ff9d/comments", "author": null, "committer": null, "parents": [{"sha": "3c8ca1abdedb2c0663e24e9dc5942280a8c7820f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c8ca1abdedb2c0663e24e9dc5942280a8c7820f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c8ca1abdedb2c0663e24e9dc5942280a8c7820f"}], "stats": {"total": 111, "additions": 86, "deletions": 25}, "files": [{"sha": "798a89966b04d843a6651b768b357cb46f174071", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cf6635b26c757412e1a3124c604c9ccb319ff9d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cf6635b26c757412e1a3124c604c9ccb319ff9d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5cf6635b26c757412e1a3124c604c9ccb319ff9d", "patch": "@@ -1,3 +1,18 @@\n+2013-08-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* rtl.h (update_alignments): Declare.\n+\t* final.c (grow_label_align): New function extracted from...\n+\t(shorten_branches): ...here.  Call it.\n+\t(update_alignments): New function.\n+\t* reorg.c (sibling_labels): New variable.\n+\t(get_label_before): Add SIBLING parameter.  If it is non-zero, push\n+\tthe new label along with it onto the sibling_labels vector.\n+\t(fill_simple_delay_slots): Adjust call to get_label_before.\n+\t(fill_slots_from_thread): Likewise.\n+\t(relax_delay_slots): Likewise.\n+\t(make_return_insns): Likewise.\n+\t(dbr_schedule): Invoke update_alignment on the sibling_labels vector.\n+\n 2013-08-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* diagnostic.c (diagnostic_classify_diagnostic): Accept zero index and"}, {"sha": "31ced4f483be92157f34ce43b7ed358a563d6af7", "filename": "gcc/final.c", "status": "modified", "additions": 48, "deletions": 19, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cf6635b26c757412e1a3124c604c9ccb319ff9d/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cf6635b26c757412e1a3124c604c9ccb319ff9d/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=5cf6635b26c757412e1a3124c604c9ccb319ff9d", "patch": "@@ -795,6 +795,53 @@ compute_alignments (void)\n   return 0;\n }\n \n+/* Grow the LABEL_ALIGN array after new labels are created.  */\n+\n+static void \n+grow_label_align (void)\n+{\n+  int old = max_labelno;\n+  int n_labels;\n+  int n_old_labels;\n+\n+  max_labelno = max_label_num ();\n+\n+  n_labels = max_labelno - min_labelno + 1;\n+  n_old_labels = old - min_labelno + 1;\n+\n+  label_align = XRESIZEVEC (struct label_alignment, label_align, n_labels);\n+\n+  /* Range of labels grows monotonically in the function.  Failing here\n+     means that the initialization of array got lost.  */\n+  gcc_assert (n_old_labels <= n_labels);\n+\n+  memset (label_align + n_old_labels, 0,\n+          (n_labels - n_old_labels) * sizeof (struct label_alignment));\n+}\n+\n+/* Update the already computed alignment information.  LABEL_PAIRS is a vector\n+   made up of pairs of labels for which the alignment information of the first\n+   element will be copied from that of the second element.  */\n+\n+void\n+update_alignments (vec<rtx> &label_pairs)\n+{\n+  unsigned int i = 0;\n+  rtx iter, label;\n+\n+  if (max_labelno != max_label_num ())\n+    grow_label_align ();\n+\n+  FOR_EACH_VEC_ELT (label_pairs, i, iter)\n+    if (i & 1)\n+      {\n+\tLABEL_TO_ALIGNMENT (label) = LABEL_TO_ALIGNMENT (iter);\n+\tLABEL_TO_MAX_SKIP (label) = LABEL_TO_MAX_SKIP (iter);\n+      }\n+    else\n+      label = iter;\n+}\n+\n namespace {\n \n const pass_data pass_data_compute_alignments =\n@@ -869,25 +916,7 @@ shorten_branches (rtx first)\n   uid_shuid = XNEWVEC (int, max_uid);\n \n   if (max_labelno != max_label_num ())\n-    {\n-      int old = max_labelno;\n-      int n_labels;\n-      int n_old_labels;\n-\n-      max_labelno = max_label_num ();\n-\n-      n_labels = max_labelno - min_labelno + 1;\n-      n_old_labels = old - min_labelno + 1;\n-\n-      label_align = XRESIZEVEC (struct label_alignment, label_align, n_labels);\n-\n-      /* Range of labels grows monotonically in the function.  Failing here\n-         means that the initialization of array got lost.  */\n-      gcc_assert (n_old_labels <= n_labels);\n-\n-      memset (label_align + n_old_labels, 0,\n-\t      (n_labels - n_old_labels) * sizeof (struct label_alignment));\n-    }\n+    grow_label_align ();\n \n   /* Initialize label_align and set up uid_shuid to be strictly\n      monotonically rising with insn order.  */"}, {"sha": "d39cc7d8a4aa37d909cbd7e11deca4c0877b24c2", "filename": "gcc/reorg.c", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cf6635b26c757412e1a3124c604c9ccb319ff9d/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cf6635b26c757412e1a3124c604c9ccb319ff9d/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=5cf6635b26c757412e1a3124c604c9ccb319ff9d", "patch": "@@ -1856,10 +1856,15 @@ update_reg_unused_notes (rtx insn, rtx redundant_insn)\n     }\n }\n \f\n-/* Return the label before INSN, or put a new label there.  */\n+static vec <rtx> sibling_labels;\n+\n+/* Return the label before INSN, or put a new label there.  If SIBLING is\n+   non-zero, it is another label associated with the new label (if any),\n+   typically the former target of the jump that will be redirected to\n+   the new label.  */\n \n static rtx\n-get_label_before (rtx insn)\n+get_label_before (rtx insn, rtx sibling)\n {\n   rtx label;\n \n@@ -1874,6 +1879,11 @@ get_label_before (rtx insn)\n       label = gen_label_rtx ();\n       emit_label_after (label, prev);\n       LABEL_NUSES (label) = 0;\n+      if (sibling)\n+\t{\n+\t  sibling_labels.safe_push (label);\n+\t  sibling_labels.safe_push (sibling);\n+\t}\n     }\n   return label;\n }\n@@ -2219,7 +2229,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t      rtx new_label = next_real_insn (next_trial);\n \n \t      if (new_label != 0)\n-\t\tnew_label = get_label_before (new_label);\n+\t\tnew_label = get_label_before (new_label, JUMP_LABEL (trial));\n \t      else\n \t\tnew_label = find_end_label (simple_return_rtx);\n \n@@ -2770,7 +2780,7 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n       else if (LABEL_P (new_thread))\n \tlabel = new_thread;\n       else\n-\tlabel = get_label_before (new_thread);\n+\tlabel = get_label_before (new_thread, JUMP_LABEL (insn));\n \n       if (label)\n \t{\n@@ -3321,7 +3331,7 @@ relax_delay_slots (rtx first)\n \t      \n \t      /* Now emit a label before the special USE insn, and\n \t\t redirect our jump to the new label.  */\n-\t      target_label = get_label_before (PREV_INSN (tmp));\n+\t      target_label = get_label_before (PREV_INSN (tmp), target_label);\n \t      reorg_redirect_jump (delay_insn, target_label);\n \t      next = insn;\n \t      continue;\n@@ -3495,7 +3505,7 @@ make_return_insns (rtx first)\n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     if (JUMP_P (insn) && ANY_RETURN_P (PATTERN (insn)))\n       {\n-\trtx t = get_label_before (insn);\n+\trtx t = get_label_before (insn, NULL_RTX);\n \tif (PATTERN (insn) == ret_rtx)\n \t  real_return_label = t;\n \telse\n@@ -3825,6 +3835,12 @@ dbr_schedule (rtx first)\n       fprintf (dump_file, \"\\n\");\n     }\n \n+  if (!sibling_labels.is_empty ())\n+    {\n+      update_alignments (sibling_labels);\n+      sibling_labels.release ();\n+    }\n+\n   free_resource_info ();\n   free (uid_to_ruid);\n   crtl->dbr_scheduled_p = true;"}, {"sha": "b5bfdffebc1278991085816f60cff6435655a02a", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cf6635b26c757412e1a3124c604c9ccb319ff9d/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cf6635b26c757412e1a3124c604c9ccb319ff9d/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=5cf6635b26c757412e1a3124c604c9ccb319ff9d", "patch": "@@ -2749,6 +2749,7 @@ extern void simplify_using_condition (rtx, rtx *, bitmap);\n \n /* In final.c  */\n extern unsigned int compute_alignments (void);\n+extern void update_alignments (vec<rtx> &);\n extern int asm_str_count (const char *templ);\n \f\n struct rtl_hooks"}]}