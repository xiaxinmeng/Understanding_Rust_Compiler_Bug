{"sha": "ce64a8b4a2334fd6982a21d1ab020a1108562f6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2U2NGE4YjRhMjMzNGZkNjk4MmEyMWQxYWIwMjBhMTEwODU2MmY2Yg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-09-14T03:48:51Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-09-14T03:48:51Z"}, "message": "compiler, reflect: fix struct field names for embedded aliases\n    \n    This adds much of https://golang.org/cl/35731 and\n    https://golang.org/cl/35732 to the gofrontend code.\n    \n    This is a step toward updating libgo to the 1.9 release.  The\n    gofrontend already supports type aliases, and this is required for\n    correct support of type aliases when used as embedded fields.\n    \n    The change to expressions.cc is to handle the << 1, used for the\n    newly renamed offsetAnon field, in the constant context used for type\n    descriptor initialization.\n    \n    Reviewed-on: https://go-review.googlesource.com/62710\n\nFrom-SVN: r252746", "tree": {"sha": "83191e42d888f13aa922cfda85d4c7eafe051622", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83191e42d888f13aa922cfda85d4c7eafe051622"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce64a8b4a2334fd6982a21d1ab020a1108562f6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce64a8b4a2334fd6982a21d1ab020a1108562f6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce64a8b4a2334fd6982a21d1ab020a1108562f6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce64a8b4a2334fd6982a21d1ab020a1108562f6b/comments", "author": null, "committer": null, "parents": [{"sha": "ed52163bea1916404119f397e6f99a4b90477f37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed52163bea1916404119f397e6f99a4b90477f37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed52163bea1916404119f397e6f99a4b90477f37"}], "stats": {"total": 271, "additions": 140, "deletions": 131}, "files": [{"sha": "a905f583859972c02359377a49f3b259441176a4", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce64a8b4a2334fd6982a21d1ab020a1108562f6b/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce64a8b4a2334fd6982a21d1ab020a1108562f6b/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=ce64a8b4a2334fd6982a21d1ab020a1108562f6b", "patch": "@@ -1,4 +1,4 @@\n-8c6d9ff6f60b737d1e96c0dab0b4e67402bf3316\n+b0a46c2cdb915ddc4a4e401af9ef6eb2bcd4d4ea\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "1e4d90647b896b22df24b05566c4534c0cc913f9", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce64a8b4a2334fd6982a21d1ab020a1108562f6b/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce64a8b4a2334fd6982a21d1ab020a1108562f6b/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=ce64a8b4a2334fd6982a21d1ab020a1108562f6b", "patch": "@@ -6044,35 +6044,46 @@ Binary_expression::do_get_backend(Translate_context* context)\n     {\n       go_assert(left_type->integer_type() != NULL);\n \n-      mpz_t bitsval;\n       int bits = left_type->integer_type()->bits();\n-      mpz_init_set_ui(bitsval, bits);\n-      Bexpression* bits_expr =\n-          gogo->backend()->integer_constant_expression(right_btype, bitsval);\n-      Bexpression* compare =\n-          gogo->backend()->binary_expression(OPERATOR_LT,\n-                                             right, bits_expr, loc);\n-\n-      Bexpression* zero_expr =\n-          gogo->backend()->integer_constant_expression(left_btype, zero);\n-      overflow = zero_expr;\n-      Bfunction* bfn = context->function()->func_value()->get_decl();\n-      if (this->op_ == OPERATOR_RSHIFT\n-\t  && !left_type->integer_type()->is_unsigned())\n+\n+      Numeric_constant nc;\n+      unsigned long ul;\n+      if (!this->right_->numeric_constant_value(&nc)\n+\t  || nc.to_unsigned_long(&ul) != Numeric_constant::NC_UL_VALID\n+\t  || ul >= static_cast<unsigned long>(bits))\n \t{\n-          Bexpression* neg_expr =\n-              gogo->backend()->binary_expression(OPERATOR_LT, left,\n-                                                 zero_expr, loc);\n-          Bexpression* neg_one_expr =\n-              gogo->backend()->integer_constant_expression(left_btype, neg_one);\n-          overflow = gogo->backend()->conditional_expression(bfn,\n-                                                             btype, neg_expr,\n-                                                             neg_one_expr,\n-                                                             zero_expr, loc);\n+\t  mpz_t bitsval;\n+\t  mpz_init_set_ui(bitsval, bits);\n+\t  Bexpression* bits_expr =\n+\t    gogo->backend()->integer_constant_expression(right_btype, bitsval);\n+\t  Bexpression* compare =\n+\t    gogo->backend()->binary_expression(OPERATOR_LT,\n+\t\t\t\t\t       right, bits_expr, loc);\n+\n+\t  Bexpression* zero_expr =\n+\t    gogo->backend()->integer_constant_expression(left_btype, zero);\n+\t  overflow = zero_expr;\n+\t  Bfunction* bfn = context->function()->func_value()->get_decl();\n+\t  if (this->op_ == OPERATOR_RSHIFT\n+\t      && !left_type->integer_type()->is_unsigned())\n+\t    {\n+\t      Bexpression* neg_expr =\n+\t\tgogo->backend()->binary_expression(OPERATOR_LT, left,\n+\t\t\t\t\t\t   zero_expr, loc);\n+\t      Bexpression* neg_one_expr =\n+\t\tgogo->backend()->integer_constant_expression(left_btype,\n+\t\t\t\t\t\t\t     neg_one);\n+\t      overflow = gogo->backend()->conditional_expression(bfn,\n+\t\t\t\t\t\t\t\t btype,\n+\t\t\t\t\t\t\t\t neg_expr,\n+\t\t\t\t\t\t\t\t neg_one_expr,\n+\t\t\t\t\t\t\t\t zero_expr,\n+\t\t\t\t\t\t\t\t loc);\n+\t    }\n+\t  ret = gogo->backend()->conditional_expression(bfn, btype, compare,\n+\t\t\t\t\t\t\tret, overflow, loc);\n+\t  mpz_clear(bitsval);\n \t}\n-      ret = gogo->backend()->conditional_expression(bfn, btype, compare, ret,\n-                                                    overflow, loc);\n-      mpz_clear(bitsval);\n     }\n \n   // Add checks for division by zero and division overflow as needed."}, {"sha": "e91922c1cac8d21a8c1d2bdc4631f0fe9c814d54", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce64a8b4a2334fd6982a21d1ab020a1108562f6b/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce64a8b4a2334fd6982a21d1ab020a1108562f6b/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=ce64a8b4a2334fd6982a21d1ab020a1108562f6b", "patch": "@@ -6372,7 +6372,7 @@ Struct_type::make_struct_type_descriptor_type()\n \t\t\t\t       \"pkgPath\", pointer_string_type,\n \t\t\t\t       \"typ\", ptdt,\n \t\t\t\t       \"tag\", pointer_string_type,\n-\t\t\t\t       \"offset\", uintptr_type);\n+\t\t\t\t       \"offsetAnon\", uintptr_type);\n       Type* nsf = Type::make_builtin_named_type(\"structField\", sf);\n \n       Type* slice_type = Type::make_array_type(nsf, NULL);\n@@ -6429,14 +6429,9 @@ Struct_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n \n       Struct_field_list::const_iterator q = f->begin();\n       go_assert(q->is_field_name(\"name\"));\n-      if (pf->is_anonymous())\n-\tfvals->push_back(Expression::make_nil(bloc));\n-      else\n-\t{\n-\t  std::string n = Gogo::unpack_hidden_name(pf->field_name());\n-\t  Expression* s = Expression::make_string(n, bloc);\n-\t  fvals->push_back(Expression::make_unary(OPERATOR_AND, s, bloc));\n-\t}\n+      std::string n = Gogo::unpack_hidden_name(pf->field_name());\n+      Expression* s = Expression::make_string(n, bloc);\n+      fvals->push_back(Expression::make_unary(OPERATOR_AND, s, bloc));\n \n       ++q;\n       go_assert(q->is_field_name(\"pkgPath\"));\n@@ -6469,8 +6464,15 @@ Struct_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n \t}\n \n       ++q;\n-      go_assert(q->is_field_name(\"offset\"));\n-      fvals->push_back(Expression::make_struct_field_offset(this, &*pf));\n+      go_assert(q->is_field_name(\"offsetAnon\"));\n+      Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+      Expression* o = Expression::make_struct_field_offset(this, &*pf);\n+      Expression* one = Expression::make_integer_ul(1, uintptr_type, bloc);\n+      o = Expression::make_binary(OPERATOR_LSHIFT, o, one, bloc);\n+      int av = pf->is_anonymous() ? 1 : 0;\n+      Expression* anon = Expression::make_integer_ul(av, uintptr_type, bloc);\n+      o = Expression::make_binary(OPERATOR_OR, o, anon, bloc);\n+      fvals->push_back(o);\n \n       Expression* v = Expression::make_struct_composite_literal(element_type,\n \t\t\t\t\t\t\t\tfvals, bloc);"}, {"sha": "6ac33526774c0c4a7d3ae515cda89165b66c1a6f", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 45, "deletions": 50, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce64a8b4a2334fd6982a21d1ab020a1108562f6b/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce64a8b4a2334fd6982a21d1ab020a1108562f6b/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=ce64a8b4a2334fd6982a21d1ab020a1108562f6b", "patch": "@@ -4184,132 +4184,127 @@ func TestStructOfExportRules(t *testing.T) {\n \t\tf()\n \t}\n \n-\tfor i, test := range []struct {\n+\ttests := []struct {\n \t\tfield     StructField\n \t\tmustPanic bool\n \t\texported  bool\n \t}{\n \t\t{\n-\t\t\tfield:     StructField{Name: \"\", Type: TypeOf(S1{})},\n-\t\t\tmustPanic: false,\n-\t\t\texported:  true,\n+\t\t\tfield:    StructField{Name: \"S1\", Anonymous: true, Type: TypeOf(S1{})},\n+\t\t\texported: true,\n \t\t},\n \t\t{\n-\t\t\tfield:     StructField{Name: \"\", Type: TypeOf((*S1)(nil))},\n-\t\t\tmustPanic: false,\n-\t\t\texported:  true,\n+\t\t\tfield:    StructField{Name: \"S1\", Anonymous: true, Type: TypeOf((*S1)(nil))},\n+\t\t\texported: true,\n \t\t},\n \t\t{\n-\t\t\tfield:     StructField{Name: \"\", Type: TypeOf(s2{})},\n-\t\t\tmustPanic: false,\n-\t\t\texported:  false,\n+\t\t\tfield:     StructField{Name: \"s2\", Anonymous: true, Type: TypeOf(s2{})},\n+\t\t\tmustPanic: true,\n \t\t},\n \t\t{\n-\t\t\tfield:     StructField{Name: \"\", Type: TypeOf((*s2)(nil))},\n-\t\t\tmustPanic: false,\n-\t\t\texported:  false,\n+\t\t\tfield:     StructField{Name: \"s2\", Anonymous: true, Type: TypeOf((*s2)(nil))},\n+\t\t\tmustPanic: true,\n \t\t},\n \t\t{\n-\t\t\tfield:     StructField{Name: \"\", Type: TypeOf(S1{}), PkgPath: \"other/pkg\"},\n+\t\t\tfield:     StructField{Name: \"Name\", Type: nil, PkgPath: \"\"},\n \t\t\tmustPanic: true,\n-\t\t\texported:  true,\n \t\t},\n \t\t{\n-\t\t\tfield:     StructField{Name: \"\", Type: TypeOf((*S1)(nil)), PkgPath: \"other/pkg\"},\n+\t\t\tfield:     StructField{Name: \"\", Type: TypeOf(S1{}), PkgPath: \"\"},\n+\t\t\tmustPanic: true,\n+\t\t},\n+\t\t{\n+\t\t\tfield:     StructField{Name: \"S1\", Anonymous: true, Type: TypeOf(S1{}), PkgPath: \"other/pkg\"},\n+\t\t\tmustPanic: true,\n+\t\t},\n+\t\t{\n+\t\t\tfield:     StructField{Name: \"S1\", Anonymous: true, Type: TypeOf((*S1)(nil)), PkgPath: \"other/pkg\"},\n+\t\t\tmustPanic: true,\n+\t\t},\n+\t\t{\n+\t\t\tfield:     StructField{Name: \"s2\", Anonymous: true, Type: TypeOf(s2{}), PkgPath: \"other/pkg\"},\n \t\t\tmustPanic: true,\n-\t\t\texported:  true,\n \t\t},\n \t\t{\n-\t\t\tfield:     StructField{Name: \"\", Type: TypeOf(s2{}), PkgPath: \"other/pkg\"},\n+\t\t\tfield:     StructField{Name: \"s2\", Anonymous: true, Type: TypeOf((*s2)(nil)), PkgPath: \"other/pkg\"},\n \t\t\tmustPanic: true,\n-\t\t\texported:  false,\n \t\t},\n \t\t{\n-\t\t\tfield:     StructField{Name: \"\", Type: TypeOf((*s2)(nil)), PkgPath: \"other/pkg\"},\n+\t\t\tfield:     StructField{Name: \"s2\", Type: TypeOf(int(0)), PkgPath: \"other/pkg\"},\n+\t\t\tmustPanic: true,\n+\t\t},\n+\t\t{\n+\t\t\tfield:     StructField{Name: \"s2\", Type: TypeOf(int(0)), PkgPath: \"other/pkg\"},\n \t\t\tmustPanic: true,\n-\t\t\texported:  false,\n \t\t},\n \t\t{\n \t\t\tfield:     StructField{Name: \"S\", Type: TypeOf(S1{})},\n \t\t\tmustPanic: false,\n \t\t\texported:  true,\n \t\t},\n \t\t{\n-\t\t\tfield:     StructField{Name: \"S\", Type: TypeOf((*S1)(nil))},\n-\t\t\tmustPanic: false,\n-\t\t\texported:  true,\n+\t\t\tfield:    StructField{Name: \"S\", Type: TypeOf((*S1)(nil))},\n+\t\t\texported: true,\n \t\t},\n \t\t{\n-\t\t\tfield:     StructField{Name: \"S\", Type: TypeOf(s2{})},\n-\t\t\tmustPanic: false,\n-\t\t\texported:  true,\n+\t\t\tfield:    StructField{Name: \"S\", Type: TypeOf(s2{})},\n+\t\t\texported: true,\n \t\t},\n \t\t{\n-\t\t\tfield:     StructField{Name: \"S\", Type: TypeOf((*s2)(nil))},\n-\t\t\tmustPanic: false,\n-\t\t\texported:  true,\n+\t\t\tfield:    StructField{Name: \"S\", Type: TypeOf((*s2)(nil))},\n+\t\t\texported: true,\n \t\t},\n \t\t{\n \t\t\tfield:     StructField{Name: \"s\", Type: TypeOf(S1{})},\n \t\t\tmustPanic: true,\n-\t\t\texported:  false,\n \t\t},\n \t\t{\n \t\t\tfield:     StructField{Name: \"s\", Type: TypeOf((*S1)(nil))},\n \t\t\tmustPanic: true,\n-\t\t\texported:  false,\n \t\t},\n \t\t{\n \t\t\tfield:     StructField{Name: \"s\", Type: TypeOf(s2{})},\n \t\t\tmustPanic: true,\n-\t\t\texported:  false,\n \t\t},\n \t\t{\n \t\t\tfield:     StructField{Name: \"s\", Type: TypeOf((*s2)(nil))},\n \t\t\tmustPanic: true,\n-\t\t\texported:  false,\n \t\t},\n \t\t{\n \t\t\tfield:     StructField{Name: \"s\", Type: TypeOf(S1{}), PkgPath: \"other/pkg\"},\n \t\t\tmustPanic: true, // TODO(sbinet): creating a name with a package path\n-\t\t\texported:  false,\n \t\t},\n \t\t{\n \t\t\tfield:     StructField{Name: \"s\", Type: TypeOf((*S1)(nil)), PkgPath: \"other/pkg\"},\n \t\t\tmustPanic: true, // TODO(sbinet): creating a name with a package path\n-\t\t\texported:  false,\n \t\t},\n \t\t{\n \t\t\tfield:     StructField{Name: \"s\", Type: TypeOf(s2{}), PkgPath: \"other/pkg\"},\n \t\t\tmustPanic: true, // TODO(sbinet): creating a name with a package path\n-\t\t\texported:  false,\n \t\t},\n \t\t{\n \t\t\tfield:     StructField{Name: \"s\", Type: TypeOf((*s2)(nil)), PkgPath: \"other/pkg\"},\n \t\t\tmustPanic: true, // TODO(sbinet): creating a name with a package path\n-\t\t\texported:  false,\n \t\t},\n \t\t{\n \t\t\tfield:     StructField{Name: \"\", Type: TypeOf(\u03a6Type{})},\n-\t\t\tmustPanic: false,\n-\t\t\texported:  true,\n+\t\t\tmustPanic: true,\n \t\t},\n \t\t{\n \t\t\tfield:     StructField{Name: \"\", Type: TypeOf(\u03c6Type{})},\n-\t\t\tmustPanic: false,\n-\t\t\texported:  false,\n+\t\t\tmustPanic: true,\n \t\t},\n \t\t{\n-\t\t\tfield:     StructField{Name: \"\u03a6\", Type: TypeOf(0)},\n-\t\t\tmustPanic: false,\n-\t\t\texported:  true,\n+\t\t\tfield:    StructField{Name: \"\u03a6\", Type: TypeOf(0)},\n+\t\t\texported: true,\n \t\t},\n \t\t{\n-\t\t\tfield:     StructField{Name: \"\u03c6\", Type: TypeOf(0)},\n-\t\t\tmustPanic: false,\n-\t\t\texported:  false,\n+\t\t\tfield:    StructField{Name: \"\u03c6\", Type: TypeOf(0)},\n+\t\t\texported: false,\n \t\t},\n-\t} {\n+\t}\n+\n+\tfor i, test := range tests {\n \t\ttestPanic(i, test.mustPanic, func() {\n \t\t\ttyp := StructOf([]StructField{test.field})\n \t\t\tif typ == nil {\n@@ -4319,7 +4314,7 @@ func TestStructOfExportRules(t *testing.T) {\n \t\t\tfield := typ.Field(0)\n \t\t\tn := field.Name\n \t\t\tif n == \"\" {\n-\t\t\t\tn = field.Type.Name()\n+\t\t\t\tpanic(\"field.Name must not be empty\")\n \t\t\t}\n \t\t\texported := isExported(n)\n \t\t\tif exported != test.exported {"}, {"sha": "97b986a7bba81b2ad77a03a27c4242f7aa9993c1", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 42, "deletions": 41, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce64a8b4a2334fd6982a21d1ab020a1108562f6b/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce64a8b4a2334fd6982a21d1ab020a1108562f6b/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=ce64a8b4a2334fd6982a21d1ab020a1108562f6b", "patch": "@@ -370,11 +370,19 @@ type sliceType struct {\n \n // Struct field\n type structField struct {\n-\tname    *string // nil for embedded fields\n-\tpkgPath *string // nil for exported Names; otherwise import path\n-\ttyp     *rtype  // type of field\n-\ttag     *string // nil if no tag\n-\toffset  uintptr // byte offset of field within struct\n+\tname       *string // name is always non-empty\n+\tpkgPath    *string // nil for exported Names; otherwise import path\n+\ttyp        *rtype  // type of field\n+\ttag        *string // nil if no tag\n+\toffsetAnon uintptr // byte offset of field<<1 | isAnonymous\n+}\n+\n+func (f *structField) offset() uintptr {\n+\treturn f.offsetAnon >> 1\n+}\n+\n+func (f *structField) anon() bool {\n+\treturn f.offsetAnon&1 != 0\n }\n \n // structType represents a struct type.\n@@ -880,23 +888,15 @@ func (t *structType) Field(i int) (f StructField) {\n \t}\n \tp := &t.fields[i]\n \tf.Type = toType(p.typ)\n-\tif p.name != nil {\n-\t\tf.Name = *p.name\n-\t} else {\n-\t\tt := f.Type\n-\t\tif t.Kind() == Ptr {\n-\t\t\tt = t.Elem()\n-\t\t}\n-\t\tf.Name = t.Name()\n-\t\tf.Anonymous = true\n-\t}\n+\tf.Name = *p.name\n+\tf.Anonymous = p.anon()\n \tif p.pkgPath != nil {\n \t\tf.PkgPath = *p.pkgPath\n \t}\n \tif p.tag != nil {\n \t\tf.Tag = StructTag(*p.tag)\n \t}\n-\tf.Offset = p.offset\n+\tf.Offset = p.offset()\n \n \t// NOTE(rsc): This is the only allocation in the interface\n \t// presented by a reflect.Type. It would be nice to avoid,\n@@ -984,18 +984,15 @@ func (t *structType) FieldByNameFunc(match func(string) bool) (result StructFiel\n \t\t\tfor i := range t.fields {\n \t\t\t\tf := &t.fields[i]\n \t\t\t\t// Find name and type for field f.\n-\t\t\t\tvar fname string\n+\t\t\t\tfname := *f.name\n \t\t\t\tvar ntyp *rtype\n-\t\t\t\tif f.name != nil {\n-\t\t\t\t\tfname = *f.name\n-\t\t\t\t} else {\n+\t\t\t\tif f.anon() {\n \t\t\t\t\t// Anonymous field of type T or *T.\n \t\t\t\t\t// Name taken from type.\n \t\t\t\t\tntyp = f.typ\n \t\t\t\t\tif ntyp.Kind() == Ptr {\n \t\t\t\t\t\tntyp = ntyp.Elem().common()\n \t\t\t\t\t}\n-\t\t\t\t\tfname = ntyp.Name()\n \t\t\t\t}\n \n \t\t\t\t// Does it match?\n@@ -1053,13 +1050,12 @@ func (t *structType) FieldByName(name string) (f StructField, present bool) {\n \tif name != \"\" {\n \t\tfor i := range t.fields {\n \t\t\ttf := &t.fields[i]\n-\t\t\tif tf.name == nil {\n-\t\t\t\thasAnon = true\n-\t\t\t\tcontinue\n-\t\t\t}\n \t\t\tif *tf.name == name {\n \t\t\t\treturn t.Field(i), true\n \t\t\t}\n+\t\t\tif tf.anon() {\n+\t\t\t\thasAnon = true\n+\t\t\t}\n \t\t}\n \t}\n \tif !hasAnon {\n@@ -1390,7 +1386,7 @@ func haveIdenticalUnderlyingType(T, V *rtype, cmpTags bool) bool {\n \t\t\tif cmpTags && tf.tag != vf.tag && (tf.tag == nil || vf.tag == nil || *tf.tag != *vf.tag) {\n \t\t\t\treturn false\n \t\t\t}\n-\t\t\tif tf.offset != vf.offset {\n+\t\t\tif tf.offsetAnon != vf.offsetAnon {\n \t\t\t\treturn false\n \t\t\t}\n \t\t}\n@@ -1946,11 +1942,10 @@ func StructOf(fields []StructField) Type {\n \t\t\thasPtr = true\n \t\t}\n \n-\t\tname := \"\"\n \t\t// Update string and hash\n+\t\tname := *f.name\n \t\thash = (hash << 1) + ft.hash\n-\t\tif f.name != nil {\n-\t\t\tname = *f.name\n+\t\tif !f.anon() {\n \t\t\trepr = append(repr, (\" \" + name)...)\n \t\t} else {\n \t\t\t// Embedded field\n@@ -2009,11 +2004,12 @@ func StructOf(fields []StructField) Type {\n \t\tcomparable = comparable && (ft.equalfn != nil)\n \t\thashable = hashable && (ft.hashfn != nil)\n \n-\t\tf.offset = align(size, uintptr(ft.fieldAlign))\n+\t\toffset := align(size, uintptr(ft.fieldAlign))\n \t\tif int8(ft.fieldAlign) > typalign {\n \t\t\ttypalign = int8(ft.fieldAlign)\n \t\t}\n-\t\tsize = f.offset + ft.size\n+\t\tsize = offset + ft.size\n+\t\tf.offsetAnon |= offset << 1\n \n \t\tif ft.size == 0 {\n \t\t\tlastzero = size\n@@ -2148,7 +2144,7 @@ func StructOf(fields []StructField) Type {\n \t\ttyp.hashfn = func(p unsafe.Pointer, seed uintptr) uintptr {\n \t\t\to := seed\n \t\t\tfor _, ft := range typ.fields {\n-\t\t\t\tpi := unsafe.Pointer(uintptr(p) + ft.offset)\n+\t\t\t\tpi := unsafe.Pointer(uintptr(p) + ft.offset())\n \t\t\t\to = ft.typ.hashfn(pi, o)\n \t\t\t}\n \t\t\treturn o\n@@ -2160,8 +2156,8 @@ func StructOf(fields []StructField) Type {\n \tif comparable {\n \t\ttyp.equalfn = func(p, q unsafe.Pointer) bool {\n \t\t\tfor _, ft := range typ.fields {\n-\t\t\t\tpi := unsafe.Pointer(uintptr(p) + ft.offset)\n-\t\t\t\tqi := unsafe.Pointer(uintptr(q) + ft.offset)\n+\t\t\t\tpi := unsafe.Pointer(uintptr(p) + ft.offset())\n+\t\t\t\tqi := unsafe.Pointer(uintptr(q) + ft.offset())\n \t\t\t\tif !ft.typ.equalfn(pi, qi) {\n \t\t\t\t\treturn false\n \t\t\t\t}\n@@ -2196,6 +2192,11 @@ func runtimeStructField(field StructField) structField {\n \t\t}\n \t}\n \n+\toffsetAnon := uintptr(0)\n+\tif field.Anonymous {\n+\t\toffsetAnon |= 1\n+\t}\n+\n \tvar pkgPath *string\n \tif field.PkgPath != \"\" {\n \t\ts := field.PkgPath\n@@ -2212,11 +2213,11 @@ func runtimeStructField(field StructField) structField {\n \t}\n \n \treturn structField{\n-\t\tname:    name,\n-\t\tpkgPath: pkgPath,\n-\t\ttyp:     field.Type.common(),\n-\t\ttag:     tag,\n-\t\toffset:  0,\n+\t\tname:       name,\n+\t\tpkgPath:    pkgPath,\n+\t\ttyp:        field.Type.common(),\n+\t\ttag:        tag,\n+\t\toffsetAnon: offsetAnon,\n \t}\n }\n \n@@ -2239,7 +2240,7 @@ func typeptrdata(t *rtype) uintptr {\n \t\t\t}\n \t\t}\n \t\tf := st.fields[field]\n-\t\treturn f.offset + f.typ.ptrdata\n+\t\treturn f.offset() + f.typ.ptrdata\n \n \tdefault:\n \t\tpanic(\"reflect.typeptrdata: unexpected type, \" + t.String())\n@@ -2513,7 +2514,7 @@ func addTypeBits(bv *bitVector, offset uintptr, t *rtype) {\n \t\ttt := (*structType)(unsafe.Pointer(t))\n \t\tfor i := range tt.fields {\n \t\t\tf := &tt.fields[i]\n-\t\t\taddTypeBits(bv, offset+f.offset, f.typ)\n+\t\t\taddTypeBits(bv, offset+f.offset(), f.typ)\n \t\t}\n \t}\n }"}, {"sha": "208bb2f4c01b2a61da10e3759f8204aab45032c5", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce64a8b4a2334fd6982a21d1ab020a1108562f6b/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce64a8b4a2334fd6982a21d1ab020a1108562f6b/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=ce64a8b4a2334fd6982a21d1ab020a1108562f6b", "patch": "@@ -625,7 +625,7 @@ func (v Value) Field(i int) Value {\n \tfl := v.flag&(flagStickyRO|flagIndir|flagAddr) | flag(typ.Kind())\n \t// Using an unexported field forces flagRO.\n \tif field.pkgPath != nil {\n-\t\tif field.name == nil {\n+\t\tif field.anon() {\n \t\t\tfl |= flagEmbedRO\n \t\t} else {\n \t\t\tfl |= flagStickyRO\n@@ -636,7 +636,7 @@ func (v Value) Field(i int) Value {\n \t// In the former case, we want v.ptr + offset.\n \t// In the latter case, we must have field.offset = 0,\n \t// so v.ptr + field.offset is still okay.\n-\tptr := unsafe.Pointer(uintptr(v.ptr) + field.offset)\n+\tptr := unsafe.Pointer(uintptr(v.ptr) + field.offset())\n \treturn Value{typ, ptr, fl}\n }\n "}]}