{"sha": "5cb7516dca5acba3d3c4205bb4ce0f5e338015ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNiNzUxNmRjYTVhY2JhM2QzYzQyMDViYjRjZTBmNWUzMzgwMTVhZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2014-07-31T13:57:42Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-31T13:57:42Z"}, "message": "utils.c (lookup_and_insert_pad_type): New function extracted from...\n\n2014-07-31  Eric Botcazou  <ebotcazou@adacore.com>\n        \n        * gcc-interface/utils.c (lookup_and_insert_pad_type): New function\n        extracted from...\n        (maybe_pad_type): ...here.  Call it to canonicalize the pad type.\n        * gcc-interface/gigi.h: Update comment.\n\nFrom-SVN: r213374", "tree": {"sha": "e754fc94dca3c883d6d0d66d716729543a1e2c6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e754fc94dca3c883d6d0d66d716729543a1e2c6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cb7516dca5acba3d3c4205bb4ce0f5e338015ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cb7516dca5acba3d3c4205bb4ce0f5e338015ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cb7516dca5acba3d3c4205bb4ce0f5e338015ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cb7516dca5acba3d3c4205bb4ce0f5e338015ad/comments", "author": null, "committer": null, "parents": [{"sha": "6c26bac268904dcdf7719bdc073f288a2c06703d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c26bac268904dcdf7719bdc073f288a2c06703d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c26bac268904dcdf7719bdc073f288a2c06703d"}], "stats": {"total": 74, "additions": 46, "deletions": 28}, "files": [{"sha": "c10a9d98a226125e66a4c060dfdae8c7d939f46c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cb7516dca5acba3d3c4205bb4ce0f5e338015ad/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cb7516dca5acba3d3c4205bb4ce0f5e338015ad/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5cb7516dca5acba3d3c4205bb4ce0f5e338015ad", "patch": "@@ -1,3 +1,10 @@\n+2014-07-31  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/utils.c (lookup_and_insert_pad_type): New function\n+        extracted from...\n+        (maybe_pad_type): ...here.  Call it to canonicalize the pad type.\n+\t* gcc-interface/gigi.h: Update comment.\n+\n 2014-07-31  Javier Miranda  <miranda@adacore.com>\n \n \t* debug.adb Remove documentation of -gnatd.k (no longer needed)."}, {"sha": "15120d58f47013123b47815777a95b099494e181", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cb7516dca5acba3d3c4205bb4ce0f5e338015ad/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cb7516dca5acba3d3c4205bb4ce0f5e338015ad/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=5cb7516dca5acba3d3c4205bb4ce0f5e338015ad", "patch": "@@ -143,7 +143,7 @@ extern tree make_packable_type (tree type, bool in_record);\n extern tree make_type_from_size (tree type, tree size_tree, bool for_biased);\n \n /* Ensure that TYPE has SIZE and ALIGN.  Make and return a new padded type\n-   if needed.  We have already verified that SIZE and TYPE are large enough.\n+   if needed.  We have already verified that SIZE and ALIGN are large enough.\n    GNAT_ENTITY is used to name the resulting record and to issue a warning.\n    IS_COMPONENT_TYPE is true if this is being done for the component type of\n    an array.  IS_USER_TYPE is true if the original type needs to be completed."}, {"sha": "f2afc73fae33108602e90f90a0dc97163772c513", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 38, "deletions": 27, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cb7516dca5acba3d3c4205bb4ce0f5e338015ad/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cb7516dca5acba3d3c4205bb4ce0f5e338015ad/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=5cb7516dca5acba3d3c4205bb4ce0f5e338015ad", "patch": "@@ -1037,8 +1037,39 @@ pad_type_hash_eq (const void *p1, const void *p2)\n     && TYPE_ADA_SIZE (type1) == TYPE_ADA_SIZE (type2);\n }\n \n+/* Look up the padded TYPE in the hash table and return its canonical version\n+   if it exists; otherwise, insert it into the hash table.  */\n+\n+static tree\n+lookup_and_insert_pad_type (tree type)\n+{\n+  hashval_t hashcode;\n+  struct pad_type_hash in, *h;\n+  void **loc;\n+\n+  hashcode\n+    = iterative_hash_object (TYPE_HASH (TREE_TYPE (TYPE_FIELDS (type))), 0);\n+  hashcode = iterative_hash_expr (TYPE_SIZE (type), hashcode);\n+  hashcode = iterative_hash_hashval_t (TYPE_ALIGN (type), hashcode);\n+  hashcode = iterative_hash_expr (TYPE_ADA_SIZE (type), hashcode);\n+\n+  in.hash = hashcode;\n+  in.type = type;\n+  h = (struct pad_type_hash *)\n+\thtab_find_with_hash (pad_type_hash_table, &in, hashcode);\n+  if (h)\n+    return h->type;\n+\n+  h = ggc_alloc<pad_type_hash> ();\n+  h->hash = hashcode;\n+  h->type = type;\n+  loc = htab_find_slot_with_hash (pad_type_hash_table, h, hashcode, INSERT);\n+  *loc = (void *)h;\n+  return NULL_TREE;\n+}\n+\n /* Ensure that TYPE has SIZE and ALIGN.  Make and return a new padded type\n-   if needed.  We have already verified that SIZE and TYPE are large enough.\n+   if needed.  We have already verified that SIZE and ALIGN are large enough.\n    GNAT_ENTITY is used to name the resulting record and to issue a warning.\n    IS_COMPONENT_TYPE is true if this is being done for the component type of\n    an array.  IS_USER_TYPE is true if the original type needs to be completed.\n@@ -1158,39 +1189,19 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n   /* Set the RM size if requested.  */\n   if (set_rm_size)\n     {\n+      tree canonical_pad_type;\n+\n       SET_TYPE_ADA_SIZE (record, size ? size : orig_size);\n \n       /* If the padded type is complete and has constant size, we canonicalize\n \t it by means of the hash table.  This is consistent with the language\n \t semantics and ensures that gigi and the middle-end have a common view\n \t of these padded types.  */\n-      if (TREE_CONSTANT (TYPE_SIZE (record)))\n+      if (TREE_CONSTANT (TYPE_SIZE (record))\n+\t  && (canonical_pad_type = lookup_and_insert_pad_type (record)))\n \t{\n-\t  hashval_t hashcode;\n-\t  struct pad_type_hash in, *h;\n-\t  void **loc;\n-\n-\t  hashcode = iterative_hash_object (TYPE_HASH (type), 0);\n-\t  hashcode = iterative_hash_expr (TYPE_SIZE (record), hashcode);\n-\t  hashcode = iterative_hash_hashval_t (TYPE_ALIGN (record), hashcode);\n-\t  hashcode = iterative_hash_expr (TYPE_ADA_SIZE (record), hashcode);\n-\n-\t  in.hash = hashcode;\n-\t  in.type = record;\n-\t  h = (struct pad_type_hash *)\n-\t\thtab_find_with_hash (pad_type_hash_table, &in, hashcode);\n-\t  if (h)\n-\t    {\n-\t      record = h->type;\n-\t      goto built;\n-\t    }\n-\n-\t  h = ggc_alloc<pad_type_hash> ();\n-\t  h->hash = hashcode;\n-\t  h->type = record;\n-\t  loc = htab_find_slot_with_hash (pad_type_hash_table, h, hashcode,\n-\t\t\t\t\t  INSERT);\n-\t  *loc = (void *)h;\n+\t  record = canonical_pad_type;\n+\t  goto built;\n \t}\n     }\n "}]}