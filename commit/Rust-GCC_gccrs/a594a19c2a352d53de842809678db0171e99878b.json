{"sha": "a594a19c2a352d53de842809678db0171e99878b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU5NGExOWMyYTM1MmQ1M2RlODQyODA5Njc4ZGIwMTcxZTk5ODc4Yg==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2003-10-07T19:48:23Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2003-10-07T19:48:23Z"}, "message": "function.c (pad_to_arg_alignment): Take STACK_POINTER_OFFSET into account\twhen aligning arguments.\n\n2003-10-07  Geoffrey Keating  <geoffk@apple.com>\n\n\t* function.c (pad_to_arg_alignment): Take STACK_POINTER_OFFSET into\n\taccount\twhen aligning arguments.\n\t* calls.c (STACK_POINTER_OFFSET): Move default from here ...\n\t* defaults.h (STACK_POINTER_OFFSET): ... to here.\n\t* config/sparc/sparc.h (STACK_BOUNDARY): Add comment about how\n\tit's wrong when TARGET_ARCH64 && TARGET_STACK_BIAS.\n\t(SPARC_STACK_BOUNDARY_HACK): Define.\n\t* config/rs6000/rs6000.c (function_arg): On non-SVR4 systems,\n\tarrange for vector parameters to varargs functions to be passed\n\tin both memory and GPRs when appropriate.\n\t(rs6000_va_arg): Vector arguments passed in memory are 16-byte\n\taligned.\n\nIndex: testsuite/ChangeLog\n2003-10-07  Geoffrey Keating  <geoffk@apple.com>\n\n\t* gcc.dg/darwin-abi-2.c: New file.\n\t* gcc.c-torture/execute/va-arg-24.c: New file.\n\nFrom-SVN: r72199", "tree": {"sha": "c53a7e4a83374635bd98d065b41f34892f94f167", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c53a7e4a83374635bd98d065b41f34892f94f167"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a594a19c2a352d53de842809678db0171e99878b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a594a19c2a352d53de842809678db0171e99878b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a594a19c2a352d53de842809678db0171e99878b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a594a19c2a352d53de842809678db0171e99878b/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "da61a073057aea7ae3441f077bfd3a8d822e4d08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da61a073057aea7ae3441f077bfd3a8d822e4d08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da61a073057aea7ae3441f077bfd3a8d822e4d08"}], "stats": {"total": 359, "additions": 267, "deletions": 92}, "files": [{"sha": "54c7374e87d7f8faffd41f303b90dce21f096058", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a594a19c2a352d53de842809678db0171e99878b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a594a19c2a352d53de842809678db0171e99878b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a594a19c2a352d53de842809678db0171e99878b", "patch": "@@ -1,5 +1,18 @@\n 2003-10-07  Geoffrey Keating  <geoffk@apple.com>\n \n+\t* function.c (pad_to_arg_alignment): Take STACK_POINTER_OFFSET into\n+\taccount\twhen aligning arguments.\n+\t* calls.c (STACK_POINTER_OFFSET): Move default from here ...\n+\t* defaults.h (STACK_POINTER_OFFSET): ... to here.\n+\t* config/sparc/sparc.h (STACK_BOUNDARY): Add comment about how\n+\tit's wrong when TARGET_ARCH64 && TARGET_STACK_BIAS.\n+\t(SPARC_STACK_BOUNDARY_HACK): Define.\n+\t* config/rs6000/rs6000.c (function_arg): On non-SVR4 systems,\n+\tarrange for vector parameters to varargs functions to be passed\n+\tin both memory and GPRs when appropriate.\n+\t(rs6000_va_arg): Vector arguments passed in memory are 16-byte\n+\taligned.\n+\n \t* hooks.c (hook_bool_tree_true): New.\n \t(hook_rtx_tree_int_null): New.\n \t(hook_rtx_rtx_null): Use NULL, not 0."}, {"sha": "18df59a92c27f3e04b02c6d1d9fead4eca3286d6", "filename": "gcc/calls.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a594a19c2a352d53de842809678db0171e99878b/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a594a19c2a352d53de842809678db0171e99878b/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=a594a19c2a352d53de842809678db0171e99878b", "patch": "@@ -41,10 +41,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"cgraph.h\"\n #include \"except.h\"\n \n-#ifndef STACK_POINTER_OFFSET\n-#define STACK_POINTER_OFFSET    0\n-#endif\n-\n /* Like PREFERRED_STACK_BOUNDARY but in units of bytes, not bits.  */\n #define STACK_BYTES (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)\n "}, {"sha": "d6183b8c31afdc9fa06cbffa9801c48f2e471273", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 161, "deletions": 80, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a594a19c2a352d53de842809678db0171e99878b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a594a19c2a352d53de842809678db0171e99878b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a594a19c2a352d53de842809678db0171e99878b", "patch": "@@ -544,134 +544,149 @@ rs6000_override_options (const char *default_cpu)\n   /* Simplify the entries below by making a mask for any POWER\n      variant and any PowerPC variant.  */\n \n-#define POWER_MASKS (MASK_POWER | MASK_POWER2 | MASK_MULTIPLE | MASK_STRING)\n-#define POWERPC_MASKS (MASK_POWERPC | MASK_PPC_GPOPT \\\n-\t\t       | MASK_PPC_GFXOPT | MASK_POWERPC64)\n-#define POWERPC_OPT_MASKS (MASK_PPC_GPOPT | MASK_PPC_GFXOPT)\n+  enum {\n+    POWER_MASKS = MASK_POWER | MASK_POWER2 | MASK_MULTIPLE | MASK_STRING,\n+    POWERPC_BASE_MASK = MASK_POWERPC | MASK_NEW_MNEMONICS,\n+    POWERPC_MASKS = (POWERPC_BASE_MASK | MASK_PPC_GPOPT \n+\t\t     | MASK_PPC_GFXOPT | MASK_POWERPC64 | MASK_ALTIVEC),\n+    POWERPC_OPT_MASKS = MASK_PPC_GPOPT | MASK_PPC_GFXOPT | MASK_ALTIVEC,\n+    \n+    SET_MASKS = (POWER_MASKS | POWERPC_MASKS | MASK_SOFT_FLOAT)\n+  };\n+\n+  /* FIXME: In this table, there are a few places where SET_MASKS is\n+     used with MASK_POWERPC64 masked off; these indicate processors\n+     that are 64-bit but that don't yet have 64-bit switched on by\n+     default because it doesn't work in the rest of the backend.\n+     There are also some places that SET_MASKS is used with other\n+     flags, those are because earlier versions of this table didn't\n+     specifically set or clear those flags and I didn't know what the\n+     processor supported.  Please delete this comment when all of those\n+     cases are gone.  */\n \n   static struct ptt\n     {\n       const char *const name;\t\t/* Canonical processor name.  */\n       const enum processor_type processor; /* Processor type enum value.  */\n       const int target_enable;\t/* Target flags to enable.  */\n-      const int target_disable;\t/* Target flags to disable.  */\n+      const int target_set;\t/* Target flags to change.  */\n     } const processor_target_table[]\n       = {{\"common\", PROCESSOR_COMMON, MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS | POWERPC_MASKS},\n+\t    SET_MASKS},\n \t {\"power\", PROCESSOR_POWER,\n \t    MASK_POWER | MASK_MULTIPLE | MASK_STRING,\n-\t    MASK_POWER2 | POWERPC_MASKS | MASK_NEW_MNEMONICS},\n+\t    SET_MASKS},\n \t {\"power2\", PROCESSOR_POWER,\n \t    MASK_POWER | MASK_POWER2 | MASK_MULTIPLE | MASK_STRING,\n-\t    POWERPC_MASKS | MASK_NEW_MNEMONICS},\n+\t    SET_MASKS},\n \t {\"power3\", PROCESSOR_PPC630,\n-\t    MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS},\n+\t    POWERPC_BASE_MASK | MASK_PPC_GFXOPT,\n+\t    SET_MASKS & ~MASK_POWERPC64 & ~MASK_PPC_GPOPT},\n \t {\"power4\", PROCESSOR_POWER4,\n-            MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n-            POWER_MASKS},\n+            POWERPC_BASE_MASK | MASK_PPC_GFXOPT,\n+\t    SET_MASKS & ~MASK_POWERPC64 & ~MASK_PPC_GPOPT},\n \t {\"powerpc\", PROCESSOR_POWERPC,\n-\t    MASK_POWERPC | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS | POWERPC_OPT_MASKS | MASK_POWERPC64},\n+\t    POWERPC_BASE_MASK,\n+\t    SET_MASKS},\n \t {\"powerpc64\", PROCESSOR_POWERPC64,\n-\t    MASK_POWERPC | MASK_POWERPC64 | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS | POWERPC_OPT_MASKS},\n+\t    POWERPC_BASE_MASK | MASK_POWERPC64,\n+\t    SET_MASKS},\n \t {\"rios\", PROCESSOR_RIOS1,\n \t    MASK_POWER | MASK_MULTIPLE | MASK_STRING,\n-\t    MASK_POWER2 | POWERPC_MASKS | MASK_NEW_MNEMONICS},\n+\t    SET_MASKS},\n \t {\"rios1\", PROCESSOR_RIOS1,\n \t    MASK_POWER | MASK_MULTIPLE | MASK_STRING,\n-\t    MASK_POWER2 | POWERPC_MASKS | MASK_NEW_MNEMONICS},\n+\t    SET_MASKS},\n \t {\"rsc\", PROCESSOR_PPC601,\n \t    MASK_POWER | MASK_MULTIPLE | MASK_STRING,\n-\t    MASK_POWER2 | POWERPC_MASKS | MASK_NEW_MNEMONICS},\n+\t    SET_MASKS},\n \t {\"rsc1\", PROCESSOR_PPC601,\n \t    MASK_POWER | MASK_MULTIPLE | MASK_STRING,\n-\t    MASK_POWER2 | POWERPC_MASKS | MASK_NEW_MNEMONICS},\n+\t    SET_MASKS},\n \t {\"rios2\", PROCESSOR_RIOS2,\n \t    MASK_POWER | MASK_MULTIPLE | MASK_STRING | MASK_POWER2,\n-\t    POWERPC_MASKS | MASK_NEW_MNEMONICS},\n+\t    SET_MASKS},\n \t {\"rs64a\", PROCESSOR_RS64A,\n-\t    MASK_POWERPC | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS | POWERPC_OPT_MASKS},\n+\t    POWERPC_BASE_MASK,\n+\t    SET_MASKS},\n \t {\"401\", PROCESSOR_PPC403,\n-\t    MASK_POWERPC | MASK_SOFT_FLOAT | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS | POWERPC_OPT_MASKS | MASK_POWERPC64},\n+\t    POWERPC_BASE_MASK | MASK_SOFT_FLOAT,\n+\t    SET_MASKS},\n \t {\"403\", PROCESSOR_PPC403,\n-\t    MASK_POWERPC | MASK_SOFT_FLOAT | MASK_NEW_MNEMONICS | MASK_STRICT_ALIGN,\n-\t    POWER_MASKS | POWERPC_OPT_MASKS | MASK_POWERPC64},\n+\t    POWERPC_BASE_MASK | MASK_SOFT_FLOAT | MASK_STRICT_ALIGN,\n+\t    SET_MASKS},\n \t {\"405\", PROCESSOR_PPC405,\n-\t    MASK_POWERPC | MASK_SOFT_FLOAT | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS | POWERPC_OPT_MASKS | MASK_POWERPC64},\n+\t    POWERPC_BASE_MASK | MASK_SOFT_FLOAT,\n+\t    SET_MASKS},\n \t {\"405fp\", PROCESSOR_PPC405,\n-\t    MASK_POWERPC | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS | POWERPC_OPT_MASKS | MASK_POWERPC64},\n+\t    POWERPC_BASE_MASK,\n+\t    SET_MASKS},\n \t {\"440\", PROCESSOR_PPC440,\n-\t    MASK_POWERPC | MASK_SOFT_FLOAT | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS | POWERPC_OPT_MASKS | MASK_POWERPC64},\n+\t    POWERPC_BASE_MASK | MASK_SOFT_FLOAT,\n+\t    SET_MASKS},\n \t {\"440fp\", PROCESSOR_PPC440,\n-\t    MASK_POWERPC | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS | POWERPC_OPT_MASKS | MASK_POWERPC64},\n+\t    POWERPC_BASE_MASK,\n+\t    SET_MASKS},\n \t {\"505\", PROCESSOR_MPCCORE,\n-\t    MASK_POWERPC | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS | POWERPC_OPT_MASKS | MASK_POWERPC64},\n+\t    POWERPC_BASE_MASK,\n+\t    SET_MASKS},\n \t {\"601\", PROCESSOR_PPC601,\n-\t    MASK_POWER | MASK_POWERPC | MASK_NEW_MNEMONICS | MASK_MULTIPLE | MASK_STRING,\n-\t    MASK_POWER2 | POWERPC_OPT_MASKS | MASK_POWERPC64},\n+\t    MASK_POWER | POWERPC_BASE_MASK | MASK_MULTIPLE | MASK_STRING,\n+\t    SET_MASKS},\n \t {\"602\", PROCESSOR_PPC603,\n-\t    MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n+\t    POWERPC_BASE_MASK | MASK_PPC_GFXOPT,\n+\t    SET_MASKS},\n \t {\"603\", PROCESSOR_PPC603,\n-\t    MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n+\t    POWERPC_BASE_MASK | MASK_PPC_GFXOPT,\n+\t    SET_MASKS},\n \t {\"603e\", PROCESSOR_PPC603,\n-\t    MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n+\t    POWERPC_BASE_MASK | MASK_PPC_GFXOPT,\n+\t    SET_MASKS},\n \t {\"ec603e\", PROCESSOR_PPC603,\n-\t    MASK_POWERPC | MASK_SOFT_FLOAT | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS | POWERPC_OPT_MASKS | MASK_POWERPC64},\n+\t    POWERPC_BASE_MASK | MASK_SOFT_FLOAT,\n+\t    SET_MASKS},\n \t {\"604\", PROCESSOR_PPC604,\n-\t    MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n+\t    POWERPC_BASE_MASK | MASK_PPC_GFXOPT,\n+\t    SET_MASKS},\n \t {\"604e\", PROCESSOR_PPC604e,\n-\t    MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n+\t    POWERPC_BASE_MASK | MASK_PPC_GFXOPT,\n+\t    SET_MASKS},\n \t {\"620\", PROCESSOR_PPC620,\n-\t    MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS},\n+\t    POWERPC_BASE_MASK | MASK_PPC_GFXOPT,\n+\t    SET_MASKS & ~MASK_POWERPC64 & ~MASK_PPC_GPOPT},\n \t {\"630\", PROCESSOR_PPC630,\n-\t    MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS},\n+\t    POWERPC_BASE_MASK | MASK_PPC_GFXOPT,\n+\t    SET_MASKS & ~MASK_POWERPC64 & ~MASK_PPC_GPOPT},\n \t {\"740\", PROCESSOR_PPC750,\n- \t    MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n- \t    POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n+ \t    POWERPC_BASE_MASK | MASK_PPC_GFXOPT,\n+ \t    SET_MASKS},\n \t {\"750\", PROCESSOR_PPC750,\n- \t    MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n- \t    POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n+ \t    POWERPC_BASE_MASK | MASK_PPC_GFXOPT,\n+ \t    SET_MASKS},\n \t {\"7400\", PROCESSOR_PPC7400,\n-            MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n-            POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n+            POWERPC_BASE_MASK | MASK_PPC_GFXOPT | MASK_ALTIVEC,\n+            SET_MASKS},\n \t {\"7450\", PROCESSOR_PPC7450,\n-            MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n-            POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n+            POWERPC_BASE_MASK | MASK_PPC_GFXOPT | MASK_ALTIVEC,\n+            SET_MASKS},\n \t {\"8540\", PROCESSOR_PPC8540,\n-\t    MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n+\t    POWERPC_BASE_MASK | MASK_PPC_GFXOPT,\n+\t    SET_MASKS},\n \t {\"801\", PROCESSOR_MPCCORE,\n-\t    MASK_POWERPC | MASK_SOFT_FLOAT | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS | POWERPC_OPT_MASKS | MASK_POWERPC64},\n+\t    POWERPC_BASE_MASK | MASK_SOFT_FLOAT,\n+\t    SET_MASKS},\n \t {\"821\", PROCESSOR_MPCCORE,\n-\t    MASK_POWERPC | MASK_SOFT_FLOAT | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS | POWERPC_OPT_MASKS | MASK_POWERPC64},\n+\t    POWERPC_BASE_MASK | MASK_SOFT_FLOAT,\n+\t    SET_MASKS},\n \t {\"823\", PROCESSOR_MPCCORE,\n-\t    MASK_POWERPC | MASK_SOFT_FLOAT | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS | POWERPC_OPT_MASKS | MASK_POWERPC64},\n+\t    POWERPC_BASE_MASK | MASK_SOFT_FLOAT,\n+\t    SET_MASKS},\n \t {\"860\", PROCESSOR_MPCCORE,\n-\t    MASK_POWERPC | MASK_SOFT_FLOAT | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS | POWERPC_OPT_MASKS | MASK_POWERPC64},\n+\t    POWERPC_BASE_MASK | MASK_SOFT_FLOAT,\n+\t    SET_MASKS},\n \t {\"970\", PROCESSOR_POWER4,\n-\t    MASK_POWERPC | POWERPC_OPT_MASKS | MASK_NEW_MNEMONICS,\n-\t    POWER_MASKS}};\n+\t    POWERPC_BASE_MASK | POWERPC_OPT_MASKS | MASK_ALTIVEC,\n+\t    SET_MASKS & ~MASK_POWERPC64}};\n \n   const size_t ptt_size = ARRAY_SIZE (processor_target_table);\n \n@@ -697,8 +712,8 @@ rs6000_override_options (const char *default_cpu)\n \n \t\tif (ptr->set_arch_p)\n \t\t  {\n+\t\t    target_flags &= ~processor_target_table[j].target_set;\n \t\t    target_flags |= processor_target_table[j].target_enable;\n-\t\t    target_flags &= ~processor_target_table[j].target_disable;\n \t\t  }\n \t\tbreak;\n \t      }\n@@ -3732,10 +3747,25 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n   if (TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (mode))\n     {\n-      if (cum->vregno <= ALTIVEC_ARG_MAX_REG && cum->nargs_prototype >= 0)\n+      if (named && cum->vregno <= ALTIVEC_ARG_MAX_REG)\n \tcum->vregno++;\n       else\n-\tcum->words += RS6000_ARG_SIZE (mode, type);\n+\t{\n+\t  int align;\n+\t  \n+\t  /* Vector parameters must be 16-byte aligned.  This places them at\n+\t     2 mod 4 in terms of words (on both ABIs).  */\n+\t  align = ((6 - (cum->words & 3)) & 3);\n+\t  cum->words += align + RS6000_ARG_SIZE (mode, type);\n+\n+\t  if (TARGET_DEBUG_ARG)\n+\t    {\n+\t      fprintf (stderr, \"function_adv: words = %2d, align=%d, \", \n+\t\t       cum->words, align);\n+\t      fprintf (stderr, \"nargs = %4d, proto = %d, mode = %4s\\n\",\n+\t\t       cum->nargs_prototype, cum->prototype, GET_MODE_NAME (mode));\n+\t    }\n+\t}\n     }\n   else if (TARGET_SPE_ABI && TARGET_SPE && SPE_VECTOR_MODE (mode)\n \t   && !cum->stdarg\n@@ -3913,8 +3943,37 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n     {\n       if (named && cum->vregno <= ALTIVEC_ARG_MAX_REG)\n \treturn gen_rtx_REG (mode, cum->vregno);\n+      else if (named || abi == ABI_V4)\n+\treturn NULL_RTX;\n       else\n-\treturn NULL;\n+\t{\n+\t  /* Vector parameters to varargs functions under AIX or Darwin\n+\t     get passed in memory and possibly also in GPRs.  */\n+\t  int align, align_words;\n+\t  rtx reg;\n+\n+\t  /* Vector parameters must be 16-byte aligned.  This places them at\n+\t     2 mod 4 in terms of words.  */\n+\t  align = ((6 - (cum->words & 3)) & 3);\n+\t  align_words = cum->words + align;\n+\n+\t  /* Out of registers?  Memory, then.  */\n+\t  if (align_words >= GP_ARG_NUM_REG)\n+\t    return NULL_RTX;\n+\t  \n+\t  /* The vector value goes in both memory and GPRs.  Varargs\n+\t     vector regs will always be saved in R5-R8 or R9-R12.  */\n+\t  reg = gen_rtx_REG (mode, GP_ARG_MIN_REG + align_words);\n+\n+\t  return gen_rtx_PARALLEL (mode,\n+\t\t\t\t   gen_rtvec (2,\n+\t\t\t\t\t      gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t\t\t\t NULL_RTX, \n+\t\t\t\t\t\t\t\t const0_rtx),\n+\t\t\t\t\t      gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t\t\t\t reg, \n+\t\t\t\t\t\t\t\t const0_rtx)));\n+\t}\n     }\n   else if (TARGET_SPE_ABI && TARGET_SPE && SPE_VECTOR_MODE (mode))\n     return rs6000_spe_function_arg (cum, mode, type);\n@@ -4302,7 +4361,29 @@ rs6000_va_arg (tree valist, tree type)\n \t  return expand_expr (t, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n \t}\n       else\n-\treturn std_expand_builtin_va_arg (valist, type);\n+\t{\n+\t  /* Altivec arguments must be aligned to a 128-bit boundary.  */\n+\t  if (ALTIVEC_VECTOR_MODE (TYPE_MODE (type)))\n+\t    {\n+\t      tree vtype = TREE_TYPE (valist);\n+\t      tree new_valist, modify;\n+\t      \n+\t      /* Round address up to multiple of 16.  Computes\n+\t\t (addr+15)&~0xf.  */\n+\t      new_valist = fold (build (BIT_AND_EXPR, vtype,\n+\t\t\t\t\tfold (build (PLUS_EXPR, vtype, valist,\n+\t\t\t\t\t\t     build_int_2 (15, 0))),\n+\t\t\t\t\tbuild_int_2 (~15, -1)));\n+\n+\t      /* Update valist.  */\n+\t      modify = build (MODIFY_EXPR, TREE_TYPE (valist), valist,\n+\t\t\t      new_valist);\n+\t      TREE_SIDE_EFFECTS (modify) = 1;\n+\t      expand_expr (modify, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t    }\n+\t  \n+\t  return std_expand_builtin_va_arg (valist, type);\n+\t}\n     }\n \n   f_gpr = TYPE_FIELDS (TREE_TYPE (va_list_type_node));"}, {"sha": "d2a37f3cd60e1278fb9373a7b2f7720b5435a2ea", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a594a19c2a352d53de842809678db0171e99878b/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a594a19c2a352d53de842809678db0171e99878b/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=a594a19c2a352d53de842809678db0171e99878b", "patch": "@@ -780,7 +780,13 @@ if (TARGET_ARCH64\t\t\t\t\\\n #define PARM_BOUNDARY (TARGET_ARCH64 ? 64 : 32)\n \n /* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+/* FIXME, this is wrong when TARGET_ARCH64 and TARGET_STACK_BIAS, because\n+   then sp+2047 is 128-bit aligned so sp is really only byte-aligned.  */\n #define STACK_BOUNDARY (TARGET_ARCH64 ? 128 : 64)\n+/* Temporary hack until the FIXME above is fixed.  This macro is used\n+   only in pad_to_arg_alignment in function.c; see the comment there\n+   for details about what it does.  */\n+#define SPARC_STACK_BOUNDARY_HACK (TARGET_ARCH64 && TARGET_STACK_BIAS)\n \n /* ALIGN FRAMES on double word boundaries */\n "}, {"sha": "f2595b0be6740a233a2670798821141c23e9d017", "filename": "gcc/defaults.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a594a19c2a352d53de842809678db0171e99878b/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a594a19c2a352d53de842809678db0171e99878b/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=a594a19c2a352d53de842809678db0171e99878b", "patch": "@@ -679,4 +679,8 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n #define MOVE_MAX_PIECES   MOVE_MAX\n #endif\n \n+#ifndef STACK_POINTER_OFFSET\n+#define STACK_POINTER_OFFSET    0\n+#endif\n+\n #endif  /* ! GCC_DEFAULTS_H */"}, {"sha": "0f158ac8e1589ec436c868307418bc72de1cc2c4", "filename": "gcc/function.c", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a594a19c2a352d53de842809678db0171e99878b/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a594a19c2a352d53de842809678db0171e99878b/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a594a19c2a352d53de842809678db0171e99878b", "patch": "@@ -5511,6 +5511,16 @@ pad_to_arg_alignment (struct args_size *offset_ptr, int boundary,\n {\n   tree save_var = NULL_TREE;\n   HOST_WIDE_INT save_constant = 0;\n+  HOST_WIDE_INT sp_offset = STACK_POINTER_OFFSET;\n+\n+#ifdef SPARC_STACK_BOUNDARY_HACK\n+  /* The sparc port has a bug.  It sometimes claims a STACK_BOUNDARY\n+     higher than the real alignment of %sp.  However, when it does this,\n+     the alignment of %sp+STACK_POINTER_OFFSET will be STACK_BOUNDARY.\n+     This is a temporary hack while the sparc port is fixed.  */\n+  if (SPARC_STACK_BOUNDARY_HACK)\n+    sp_offset = 0;\n+#endif\n \n   int boundary_in_bytes = boundary / BITS_PER_UNIT;\n \n@@ -5527,14 +5537,17 @@ pad_to_arg_alignment (struct args_size *offset_ptr, int boundary,\n     {\n       if (offset_ptr->var)\n \t{\n-\t  offset_ptr->var =\n+\t  tree sp_offset_tree = ssize_int (sp_offset);\n+\t  tree offset = size_binop (PLUS_EXPR,\n+\t\t\t\t    ARGS_SIZE_TREE (*offset_ptr),\n+\t\t\t\t    sp_offset_tree);\n #ifdef ARGS_GROW_DOWNWARD\n-\t    round_down\n+\t  tree rounded = round_down (offset, boundary / BITS_PER_UNIT);\n #else\n-\t    round_up\n+\t  tree rounded = round_up   (offset, boundary / BITS_PER_UNIT);\n #endif\n-\t      (ARGS_SIZE_TREE (*offset_ptr),\n-\t       boundary / BITS_PER_UNIT);\n+\n+\t  offset_ptr->var = size_binop (MINUS_EXPR, rounded, sp_offset_tree);\n \t  /* ARGS_SIZE_TREE includes constant term.  */\n \t  offset_ptr->constant = 0;\n \t  if (boundary > PARM_BOUNDARY && boundary > STACK_BOUNDARY)\n@@ -5543,11 +5556,11 @@ pad_to_arg_alignment (struct args_size *offset_ptr, int boundary,\n \t}\n       else\n \t{\n-\t  offset_ptr->constant =\n+\t  offset_ptr->constant = -sp_offset +\n #ifdef ARGS_GROW_DOWNWARD\n-\t    FLOOR_ROUND (offset_ptr->constant, boundary_in_bytes);\n+\t    FLOOR_ROUND (offset_ptr->constant + sp_offset, boundary_in_bytes);\n #else\n-\t    CEIL_ROUND (offset_ptr->constant, boundary_in_bytes);\n+\t    CEIL_ROUND (offset_ptr->constant + sp_offset, boundary_in_bytes);\n #endif\n \t    if (boundary > PARM_BOUNDARY && boundary > STACK_BOUNDARY)\n \t      alignment_pad->constant = offset_ptr->constant - save_constant;"}, {"sha": "4cf077551584b49d71ab99bd439f8ef0acae6f2f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a594a19c2a352d53de842809678db0171e99878b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a594a19c2a352d53de842809678db0171e99878b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a594a19c2a352d53de842809678db0171e99878b", "patch": "@@ -1,3 +1,8 @@\n+2003-10-07  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* gcc.dg/darwin-abi-2.c: New file.\n+\t* gcc.c-torture/execute/va-arg-24.c: New file.\n+\n 2003-10-06  Bob Wilson  <bob.wilson@acm.org>\n \n \t* g++.dg/template/spec10.C: Set exit value to zero on success.  Fix"}, {"sha": "c8fdaf0f95cde1e6d8ec25a99d1f66f185f6fe59", "filename": "gcc/testsuite/gcc.c-torture/execute/va-arg-24.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a594a19c2a352d53de842809678db0171e99878b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fva-arg-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a594a19c2a352d53de842809678db0171e99878b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fva-arg-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fva-arg-24.c?ref=a594a19c2a352d53de842809678db0171e99878b", "patch": "@@ -0,0 +1,34 @@\n+/* Varargs and vectors!  */\n+\n+#include <stdarg.h>\n+\n+#define vector __attribute__((vector_size(16)))\n+\n+const vector unsigned int v1 = {10,11,12,13};\n+const vector unsigned int v2 = {20,21,22,23};\n+\n+void foo(int a, ...)\n+{\n+  va_list args;\n+  vector unsigned int v;\n+\n+  va_start (args, a);\n+  v = va_arg (args, vector unsigned int);\n+  if (a != 1 || memcmp (&v, &v1, sizeof (v)) != 0)\n+    abort ();\n+  a = va_arg (args, int);\n+  if (a != 2)\n+    abort ();\n+  v = va_arg (args, vector unsigned int);\n+  if (memcmp (&v, &v2, sizeof (v) != 0))\n+    abort ();\n+  va_end (args);\n+}\n+\n+int main(void)\n+{\n+  foo (1, (vector unsigned int){10,11,12,13}, 2,\n+       (vector unsigned int){14,15,16,17});\n+  return 0;\n+}\n+"}, {"sha": "81da83c424fe2909cb9c50ab494f65147ba98756", "filename": "gcc/testsuite/gcc.dg/darwin-abi-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a594a19c2a352d53de842809678db0171e99878b/gcc%2Ftestsuite%2Fgcc.dg%2Fdarwin-abi-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a594a19c2a352d53de842809678db0171e99878b/gcc%2Ftestsuite%2Fgcc.dg%2Fdarwin-abi-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdarwin-abi-2.c?ref=a594a19c2a352d53de842809678db0171e99878b", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do run { target powerpc*-*-darwin* } } */\n+\n+/* You might think you'd need -maltivec for this, but actually you\n+   don't; GCC will happily do everything in GPRs, and it still\n+   tests that the ABI is correct.  */\n+\n+#include <stdio.h>\n+\n+#define vector __attribute__((vector_size(16)))\n+\n+int main(void)\n+{\n+  vector unsigned int v = { 100, 200, 300, 400 };\n+  vector unsigned int w = { 4, 5, 6, 7 };\n+  char x[64];\n+  sprintf (x, \"%lvu,%d,%lvu\", v, 1, w);\n+  if (strcmp (x, \"100 200 300 400,1,4 5 6 7\") != 0)\n+    {\n+      puts (x);\n+      abort ();\n+    }\n+  return 0;\n+}"}]}