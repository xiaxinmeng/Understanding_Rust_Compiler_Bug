{"sha": "f09552335030433018fd5f7f6b9848339b5ca2da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA5NTUyMzM1MDMwNDMzMDE4ZmQ1ZjdmNmI5ODQ4MzM5YjVjYTJkYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-14T14:36:26Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-14T14:36:26Z"}, "message": "Add a targetm.vectorize.related_mode hook\n\nThis patch is the first of a series that tries to remove two\nassumptions:\n\n(1) that all vectors involved in vectorisation must be the same size\n\n(2) that there is only one vector mode for a given element mode and\n    number of elements\n\nRelaxing (1) helps with targets that support multiple vector sizes or\nthat require the number of elements to stay the same.  E.g. if we're\nvectorising code that operates on narrow and wide elements, and the\nnarrow elements use 64-bit vectors, then on AArch64 it would normally\nbe better to use 128-bit vectors rather than pairs of 64-bit vectors\nfor the wide elements.\n\nRelaxing (2) makes it possible for -msve-vector-bits=128 to produce\nfixed-length code for SVE.  It also allows unpacked/half-size SVE\nvectors to work with -msve-vector-bits=256.\n\nThe patch adds a new hook that targets can use to control how we\nmove from one vector mode to another.  The hook takes a starting vector\nmode, a new element mode, and (optionally) a new number of elements.\nThe flexibility needed for (1) comes in when the number of elements\nisn't specified.\n\nAll callers in this patch specify the number of elements, but a later\nvectoriser patch doesn't.\n\n2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* target.def (related_mode): New hook.\n\t* doc/tm.texi.in (TARGET_VECTORIZE_RELATED_MODE): New hook.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.h (default_vectorize_related_mode): Declare.\n\t* targhooks.c (default_vectorize_related_mode): New function.\n\t* machmode.h (related_vector_mode): Declare.\n\t* stor-layout.c (related_vector_mode): New function.\n\t* expmed.c (extract_bit_field_1): Use it instead of mode_for_vector.\n\t* optabs-query.c (qimode_for_vec_perm): Likewise.\n\t* tree-vect-stmts.c (get_group_load_store_type): Likewise.\n\t(vectorizable_store, vectorizable_load): Likewise\n\nFrom-SVN: r278229", "tree": {"sha": "78e267da95a352d5303bc66b513ab10e2f5979a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78e267da95a352d5303bc66b513ab10e2f5979a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f09552335030433018fd5f7f6b9848339b5ca2da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f09552335030433018fd5f7f6b9848339b5ca2da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f09552335030433018fd5f7f6b9848339b5ca2da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f09552335030433018fd5f7f6b9848339b5ca2da/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "89cd5050928afa2d2e9cf836ae39f6cb947f5602", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89cd5050928afa2d2e9cf836ae39f6cb947f5602", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89cd5050928afa2d2e9cf836ae39f6cb947f5602"}], "stats": {"total": 151, "additions": 126, "deletions": 25}, "files": [{"sha": "54f244902a22d8b3ce611f2e8b01fcbe8b9be8fd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f09552335030433018fd5f7f6b9848339b5ca2da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f09552335030433018fd5f7f6b9848339b5ca2da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f09552335030433018fd5f7f6b9848339b5ca2da", "patch": "@@ -1,3 +1,17 @@\n+2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* target.def (related_mode): New hook.\n+\t* doc/tm.texi.in (TARGET_VECTORIZE_RELATED_MODE): New hook.\n+\t* doc/tm.texi: Regenerate.\n+\t* targhooks.h (default_vectorize_related_mode): Declare.\n+\t* targhooks.c (default_vectorize_related_mode): New function.\n+\t* machmode.h (related_vector_mode): Declare.\n+\t* stor-layout.c (related_vector_mode): New function.\n+\t* expmed.c (extract_bit_field_1): Use it instead of mode_for_vector.\n+\t* optabs-query.c (qimode_for_vec_perm): Likewise.\n+\t* tree-vect-stmts.c (get_group_load_store_type): Likewise.\n+\t(vectorizable_store, vectorizable_load): Likewise\n+\n 2019-11-14  Richard Henderson  <richard.henderson@linaro.org>\n \n \t* config/arm/aarch-common-protos.h (arm_md_asm_adjust): Declare."}, {"sha": "5586e2edae26e4f42b5ec005cc26573acb042e6d", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f09552335030433018fd5f7f6b9848339b5ca2da/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f09552335030433018fd5f7f6b9848339b5ca2da/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=f09552335030433018fd5f7f6b9848339b5ca2da", "patch": "@@ -6021,6 +6021,30 @@ The hook does not need to do anything if the vector returned by\n for autovectorization.  The default implementation does nothing.\n @end deftypefn\n \n+@deftypefn {Target Hook} opt_machine_mode TARGET_VECTORIZE_RELATED_MODE (machine_mode @var{vector_mode}, scalar_mode @var{element_mode}, poly_uint64 @var{nunits})\n+If a piece of code is using vector mode @var{vector_mode} and also wants\n+to operate on elements of mode @var{element_mode}, return the vector mode\n+it should use for those elements.  If @var{nunits} is nonzero, ensure that\n+the mode has exactly @var{nunits} elements, otherwise pick whichever vector\n+size pairs the most naturally with @var{vector_mode}.  Return an empty\n+@code{opt_machine_mode} if there is no supported vector mode with the\n+required properties.\n+\n+There is no prescribed way of handling the case in which @var{nunits}\n+is zero.  One common choice is to pick a vector mode with the same size\n+as @var{vector_mode}; this is the natural choice if the target has a\n+fixed vector size.  Another option is to choose a vector mode with the\n+same number of elements as @var{vector_mode}; this is the natural choice\n+if the target has a fixed number of elements.  Alternatively, the hook\n+might choose a middle ground, such as trying to keep the number of\n+elements as similar as possible while applying maximum and minimum\n+vector sizes.\n+\n+The default implementation uses @code{mode_for_vector} to find the\n+requested mode, returning a mode with the same size as @var{vector_mode}\n+when @var{nunits} is zero.  This is the correct behavior for most targets.\n+@end deftypefn\n+\n @deftypefn {Target Hook} opt_machine_mode TARGET_VECTORIZE_GET_MASK_MODE (poly_uint64 @var{nunits}, poly_uint64 @var{length})\n A vector mask is a value that holds one boolean result for every element\n in a vector.  This hook returns the machine mode that should be used to"}, {"sha": "727b88c70ce25955c8c6f4ca7a781248660c4e5d", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f09552335030433018fd5f7f6b9848339b5ca2da/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f09552335030433018fd5f7f6b9848339b5ca2da/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=f09552335030433018fd5f7f6b9848339b5ca2da", "patch": "@@ -4177,6 +4177,8 @@ address;  but often a machine-dependent strategy can generate better code.\n \n @hook TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES\n \n+@hook TARGET_VECTORIZE_RELATED_MODE\n+\n @hook TARGET_VECTORIZE_GET_MASK_MODE\n \n @hook TARGET_VECTORIZE_EMPTY_MASK_IS_EXPENSIVE"}, {"sha": "512944ef418348b9dc50684b9f085c23206f9d8b", "filename": "gcc/expmed.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f09552335030433018fd5f7f6b9848339b5ca2da/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f09552335030433018fd5f7f6b9848339b5ca2da/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=f09552335030433018fd5f7f6b9848339b5ca2da", "patch": "@@ -1643,12 +1643,10 @@ extract_bit_field_1 (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n \t  poly_uint64 nunits;\n \t  if (!multiple_p (GET_MODE_BITSIZE (GET_MODE (op0)),\n \t\t\t   GET_MODE_UNIT_BITSIZE (tmode), &nunits)\n-\t      || !mode_for_vector (inner_mode, nunits).exists (&new_mode)\n-\t      || !VECTOR_MODE_P (new_mode)\n+\t      || !related_vector_mode (tmode, inner_mode,\n+\t\t\t\t       nunits).exists (&new_mode)\n \t      || maybe_ne (GET_MODE_SIZE (new_mode),\n-\t\t\t   GET_MODE_SIZE (GET_MODE (op0)))\n-\t      || GET_MODE_INNER (new_mode) != GET_MODE_INNER (tmode)\n-\t      || !targetm.vector_mode_supported_p (new_mode))\n+\t\t\t   GET_MODE_SIZE (GET_MODE (op0))))\n \t    new_mode = VOIDmode;\n \t}\n       poly_uint64 pos;"}, {"sha": "906b2161cfa1513b1a26603b15e772abc90b43d7", "filename": "gcc/machmode.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f09552335030433018fd5f7f6b9848339b5ca2da/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f09552335030433018fd5f7f6b9848339b5ca2da/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=f09552335030433018fd5f7f6b9848339b5ca2da", "patch": "@@ -880,6 +880,8 @@ extern opt_scalar_int_mode int_mode_for_mode (machine_mode);\n extern opt_machine_mode bitwise_mode_for_mode (machine_mode);\n extern opt_machine_mode mode_for_vector (scalar_mode, poly_uint64);\n extern opt_machine_mode mode_for_int_vector (unsigned int, poly_uint64);\n+extern opt_machine_mode related_vector_mode (machine_mode, scalar_mode,\n+\t\t\t\t\t     poly_uint64 = 0);\n \n /* Return the integer vector equivalent of MODE, if one exists.  In other\n    words, return the mode for an integer vector that has the same number"}, {"sha": "e610e969b78cb92093e20f65843ac7f3aaff01a8", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f09552335030433018fd5f7f6b9848339b5ca2da/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f09552335030433018fd5f7f6b9848339b5ca2da/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=f09552335030433018fd5f7f6b9848339b5ca2da", "patch": "@@ -354,11 +354,8 @@ can_conditionally_move_p (machine_mode mode)\n opt_machine_mode\n qimode_for_vec_perm (machine_mode mode)\n {\n-  machine_mode qimode;\n-  if (GET_MODE_INNER (mode) != QImode\n-      && mode_for_vector (QImode, GET_MODE_SIZE (mode)).exists (&qimode)\n-      && VECTOR_MODE_P (qimode))\n-    return qimode;\n+  if (GET_MODE_INNER (mode) != QImode)\n+    return related_vector_mode (mode, QImode, GET_MODE_SIZE (mode));\n   return opt_machine_mode ();\n }\n "}, {"sha": "c1b724f682c79ae10c1a90af6e9ff934af3b7c4d", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f09552335030433018fd5f7f6b9848339b5ca2da/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f09552335030433018fd5f7f6b9848339b5ca2da/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=f09552335030433018fd5f7f6b9848339b5ca2da", "patch": "@@ -530,6 +530,26 @@ mode_for_int_vector (unsigned int int_bits, poly_uint64 nunits)\n   return opt_machine_mode ();\n }\n \n+/* If a piece of code is using vector mode VECTOR_MODE and also wants\n+   to operate on elements of mode ELEMENT_MODE, return the vector mode\n+   it should use for those elements.  If NUNITS is nonzero, ensure that\n+   the mode has exactly NUNITS elements, otherwise pick whichever vector\n+   size pairs the most naturally with VECTOR_MODE; this may mean choosing\n+   a mode with a different size and/or number of elements, depending on\n+   what the target prefers.  Return an empty opt_machine_mode if there\n+   is no supported vector mode with the required properties.\n+\n+   Unlike mode_for_vector. any returned mode is guaranteed to satisfy\n+   both VECTOR_MODE_P and targetm.vector_mode_supported_p.  */\n+\n+opt_machine_mode\n+related_vector_mode (machine_mode vector_mode, scalar_mode element_mode,\n+\t\t     poly_uint64 nunits)\n+{\n+  gcc_assert (VECTOR_MODE_P (vector_mode));\n+  return targetm.vectorize.related_mode (vector_mode, element_mode, nunits);\n+}\n+\n /* Return the alignment of MODE. This will be bounded by 1 and\n    BIGGEST_ALIGNMENT.  */\n "}, {"sha": "569aaa5da8ec4e4db14558f9ff126a6c51076b7d", "filename": "gcc/target.def", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f09552335030433018fd5f7f6b9848339b5ca2da/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f09552335030433018fd5f7f6b9848339b5ca2da/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=f09552335030433018fd5f7f6b9848339b5ca2da", "patch": "@@ -1924,6 +1924,33 @@ for autovectorization.  The default implementation does nothing.\",\n  (vector_sizes *sizes, bool all),\n  default_autovectorize_vector_sizes)\n \n+DEFHOOK\n+(related_mode,\n+ \"If a piece of code is using vector mode @var{vector_mode} and also wants\\n\\\n+to operate on elements of mode @var{element_mode}, return the vector mode\\n\\\n+it should use for those elements.  If @var{nunits} is nonzero, ensure that\\n\\\n+the mode has exactly @var{nunits} elements, otherwise pick whichever vector\\n\\\n+size pairs the most naturally with @var{vector_mode}.  Return an empty\\n\\\n+@code{opt_machine_mode} if there is no supported vector mode with the\\n\\\n+required properties.\\n\\\n+\\n\\\n+There is no prescribed way of handling the case in which @var{nunits}\\n\\\n+is zero.  One common choice is to pick a vector mode with the same size\\n\\\n+as @var{vector_mode}; this is the natural choice if the target has a\\n\\\n+fixed vector size.  Another option is to choose a vector mode with the\\n\\\n+same number of elements as @var{vector_mode}; this is the natural choice\\n\\\n+if the target has a fixed number of elements.  Alternatively, the hook\\n\\\n+might choose a middle ground, such as trying to keep the number of\\n\\\n+elements as similar as possible while applying maximum and minimum\\n\\\n+vector sizes.\\n\\\n+\\n\\\n+The default implementation uses @code{mode_for_vector} to find the\\n\\\n+requested mode, returning a mode with the same size as @var{vector_mode}\\n\\\n+when @var{nunits} is zero.  This is the correct behavior for most targets.\",\n+ opt_machine_mode,\n+ (machine_mode vector_mode, scalar_mode element_mode, poly_uint64 nunits),\n+ default_vectorize_related_mode)\n+\n /* Function to get a target mode for a vector mask.  */\n DEFHOOK\n (get_mask_mode,"}, {"sha": "dcecd81e54d831647e7005492ec8727b90b0f820", "filename": "gcc/targhooks.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f09552335030433018fd5f7f6b9848339b5ca2da/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f09552335030433018fd5f7f6b9848339b5ca2da/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=f09552335030433018fd5f7f6b9848339b5ca2da", "patch": "@@ -1306,6 +1306,25 @@ default_autovectorize_vector_sizes (vector_sizes *, bool)\n {\n }\n \n+/* The default implementation of TARGET_VECTORIZE_RELATED_MODE.  */\n+\n+opt_machine_mode\n+default_vectorize_related_mode (machine_mode vector_mode,\n+\t\t\t\tscalar_mode element_mode,\n+\t\t\t\tpoly_uint64 nunits)\n+{\n+  machine_mode result_mode;\n+  if ((maybe_ne (nunits, 0U)\n+       || multiple_p (GET_MODE_SIZE (vector_mode),\n+\t\t      GET_MODE_SIZE (element_mode), &nunits))\n+      && mode_for_vector (element_mode, nunits).exists (&result_mode)\n+      && VECTOR_MODE_P (result_mode)\n+      && targetm.vector_mode_supported_p (result_mode))\n+    return result_mode;\n+\n+  return opt_machine_mode ();\n+}\n+\n /* By default a vector of integers is used as a mask.  */\n \n opt_machine_mode"}, {"sha": "12e6ad49cf0ed5dbaaede8f1a943f68148b2d6b2", "filename": "gcc/targhooks.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f09552335030433018fd5f7f6b9848339b5ca2da/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f09552335030433018fd5f7f6b9848339b5ca2da/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=f09552335030433018fd5f7f6b9848339b5ca2da", "patch": "@@ -114,6 +114,9 @@ default_builtin_support_vector_misalignment (machine_mode mode,\n extern machine_mode default_preferred_simd_mode (scalar_mode mode);\n extern machine_mode default_split_reduction (machine_mode);\n extern void default_autovectorize_vector_sizes (vector_sizes *, bool);\n+extern opt_machine_mode default_vectorize_related_mode (machine_mode,\n+\t\t\t\t\t\t\tscalar_mode,\n+\t\t\t\t\t\t\tpoly_uint64);\n extern opt_machine_mode default_get_mask_mode (poly_uint64, poly_uint64);\n extern bool default_empty_mask_is_expensive (unsigned);\n extern void *default_init_cost (class loop *);"}, {"sha": "73fe573ea3eb14c6c7e809555b7bdb02e5a82c88", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f09552335030433018fd5f7f6b9848339b5ca2da/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f09552335030433018fd5f7f6b9848339b5ca2da/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=f09552335030433018fd5f7f6b9848339b5ca2da", "patch": "@@ -2309,9 +2309,8 @@ get_group_load_store_type (stmt_vec_info stmt_info, tree vectype, bool slp,\n \t\t  || alignment_support_scheme == dr_unaligned_supported)\n \t      && known_eq (nunits, (group_size - gap) * 2)\n \t      && known_eq (nunits, group_size)\n-\t      && mode_for_vector (elmode, (group_size - gap)).exists (&vmode)\n-\t      && VECTOR_MODE_P (vmode)\n-\t      && targetm.vector_mode_supported_p (vmode)\n+\t      && related_vector_mode (TYPE_MODE (vectype), elmode,\n+\t\t\t\t      group_size - gap).exists (&vmode)\n \t      && (convert_optab_handler (vec_init_optab,\n \t\t\t\t\t TYPE_MODE (vectype), vmode)\n \t\t  != CODE_FOR_nothing))\n@@ -7811,9 +7810,8 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t of vector elts directly.  */\n \t      scalar_mode elmode = SCALAR_TYPE_MODE (elem_type);\n \t      machine_mode vmode;\n-\t      if (!mode_for_vector (elmode, group_size).exists (&vmode)\n-\t\t  || !VECTOR_MODE_P (vmode)\n-\t\t  || !targetm.vector_mode_supported_p (vmode)\n+\t      if (!related_vector_mode (TYPE_MODE (vectype), elmode,\n+\t\t\t\t\tgroup_size).exists (&vmode)\n \t\t  || (convert_optab_handler (vec_extract_optab,\n \t\t\t\t\t     TYPE_MODE (vectype), vmode)\n \t\t      == CODE_FOR_nothing))\n@@ -7830,9 +7828,8 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t     element extracts from the original vector type and\n \t\t     element size stores.  */\n \t\t  if (int_mode_for_size (lsize, 0).exists (&elmode)\n-\t\t      && mode_for_vector (elmode, lnunits).exists (&vmode)\n-\t\t      && VECTOR_MODE_P (vmode)\n-\t\t      && targetm.vector_mode_supported_p (vmode)\n+\t\t      && related_vector_mode (TYPE_MODE (vectype), elmode,\n+\t\t\t\t\t      lnunits).exists (&vmode)\n \t\t      && (convert_optab_handler (vec_extract_optab,\n \t\t\t\t\t\t vmode, elmode)\n \t\t\t  != CODE_FOR_nothing))\n@@ -8913,9 +8910,8 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t vector elts directly.  */\n \t      scalar_mode elmode = SCALAR_TYPE_MODE (TREE_TYPE (vectype));\n \t      machine_mode vmode;\n-\t      if (mode_for_vector (elmode, group_size).exists (&vmode)\n-\t\t  && VECTOR_MODE_P (vmode)\n-\t\t  && targetm.vector_mode_supported_p (vmode)\n+\t      if (related_vector_mode (TYPE_MODE (vectype), elmode,\n+\t\t\t\t       group_size).exists (&vmode)\n \t\t  && (convert_optab_handler (vec_init_optab,\n \t\t\t\t\t     TYPE_MODE (vectype), vmode)\n \t\t      != CODE_FOR_nothing))\n@@ -8939,9 +8935,8 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t  /* If we can't construct such a vector fall back to\n \t\t     element loads of the original vector type.  */\n \t\t  if (int_mode_for_size (lsize, 0).exists (&elmode)\n-\t\t      && mode_for_vector (elmode, lnunits).exists (&vmode)\n-\t\t      && VECTOR_MODE_P (vmode)\n-\t\t      && targetm.vector_mode_supported_p (vmode)\n+\t\t      && related_vector_mode (TYPE_MODE (vectype), elmode,\n+\t\t\t\t\t      lnunits).exists (&vmode)\n \t\t      && (convert_optab_handler (vec_init_optab, vmode, elmode)\n \t\t\t  != CODE_FOR_nothing))\n \t\t    {"}]}