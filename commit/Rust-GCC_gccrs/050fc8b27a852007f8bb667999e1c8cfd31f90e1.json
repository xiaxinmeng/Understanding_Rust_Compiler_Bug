{"sha": "050fc8b27a852007f8bb667999e1c8cfd31f90e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUwZmM4YjI3YTg1MjAwN2Y4YmI2Njc5OTllMWM4Y2ZkMzFmOTBlMQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2020-08-25T18:02:45Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2020-08-25T18:02:45Z"}, "message": "hppa: PR middle-end/87256: Improved hppa_rtx_costs avoids synth_mult madness.\n\nThis is my proposed fix to PR middle-end/87256 where synth_mult takes an\nunreasonable amount of CPU time determining an optimal sequence of\ninstructions to perform multiplication by (large) integer constants on hppa.\nOne workaround proposed in bugzilla, is to increase the hash table used\nto cache/reuse intermediate results. This helps but is a workaround for\nthe (hidden) underlying problem.\n\nThe real issue is that the hppa_rtx_costs function is providing wildly\ninaccurate values (estimates) to the middle-end.  For example, (p*q)+(r*s)\nwould appear to be cheaper than a single multiplication.  Another\nexample is that \"(ashiftrt:di regA regB)\" is claimed to be only be\nCOST_N_INSNS(1) when in fact the hppa backend actually generates\nslightly more than a single instruction.\n\nIt turns out that simply tightening up the logic in hppa_rtx_costs to\nreturn more reasonable values, dramatically reduces the number of recursive\ninvocations in synth_mult for the test case in PR87256, and presumably\nalso produces faster code (that should be observable in benchmarks).\n\n2020-08-25  Roger Sayle  <roger@nextmovesoftware.com>\n\ngcc/ChangeLog\n\tPR middle-end/87256\n\t* config/pa/pa.c (hppa_rtx_costs_shadd_p): New helper function\n\tto check for coefficients supported by shNadd and shladd,l.\n\t(hppa_rtx_costs):  Rewrite to avoid using estimates based upon\n\tFACTOR and enable recursing deeper into RTL expressions.", "tree": {"sha": "04f80d4457fdd9c755bc50342c1ad73051e4750e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04f80d4457fdd9c755bc50342c1ad73051e4750e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/050fc8b27a852007f8bb667999e1c8cfd31f90e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/050fc8b27a852007f8bb667999e1c8cfd31f90e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/050fc8b27a852007f8bb667999e1c8cfd31f90e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/050fc8b27a852007f8bb667999e1c8cfd31f90e1/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f410cd248566febad02edacee3ec5f13ae3fc990", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f410cd248566febad02edacee3ec5f13ae3fc990", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f410cd248566febad02edacee3ec5f13ae3fc990"}], "stats": {"total": 172, "additions": 138, "deletions": 34}, "files": [{"sha": "cb888528765b731dd1586a01a905d98041281bfe", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 138, "deletions": 34, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050fc8b27a852007f8bb667999e1c8cfd31f90e1/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050fc8b27a852007f8bb667999e1c8cfd31f90e1/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=050fc8b27a852007f8bb667999e1c8cfd31f90e1", "patch": "@@ -1492,22 +1492,50 @@ hppa_address_cost (rtx X, machine_mode mode ATTRIBUTE_UNUSED,\n     }\n }\n \n+/* Return true if X represents a (possibly non-canonical) shNadd pattern.\n+   The machine mode of X is known to be SImode or DImode.  */\n+\n+static bool\n+hppa_rtx_costs_shadd_p (rtx x)\n+{\n+  if (GET_CODE (x) != PLUS\n+      || !REG_P (XEXP (x, 1)))\n+    return false;\n+  rtx op0 = XEXP (x, 0);\n+  if (GET_CODE (op0) == ASHIFT\n+      && CONST_INT_P (XEXP (op0, 1))\n+      && REG_P (XEXP (op0, 0)))\n+    {\n+      unsigned HOST_WIDE_INT x = UINTVAL (XEXP (op0, 1));\n+      return x == 1 || x == 2 || x == 3;\n+    }\n+  if (GET_CODE (op0) == MULT\n+      && CONST_INT_P (XEXP (op0, 1))\n+      && REG_P (XEXP (op0, 0)))\n+    {\n+      unsigned HOST_WIDE_INT x = UINTVAL (XEXP (op0, 1));\n+      return x == 2 || x == 4 || x == 8;\n+    }\n+  return false;\n+}\n+\n /* Compute a (partial) cost for rtx X.  Return true if the complete\n    cost has been computed, and false if subexpressions should be\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n hppa_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \t\tint opno ATTRIBUTE_UNUSED,\n-\t\tint *total, bool speed ATTRIBUTE_UNUSED)\n+\t\tint *total, bool speed)\n {\n-  int factor;\n   int code = GET_CODE (x);\n \n   switch (code)\n     {\n     case CONST_INT:\n-      if (INTVAL (x) == 0)\n+      if (outer_code == SET)\n+\t*total = COSTS_N_INSNS (1);\n+      else if (INTVAL (x) == 0)\n \t*total = 0;\n       else if (INT_14_BITS (x))\n \t*total = 1;\n@@ -1530,67 +1558,143 @@ hppa_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \t  && outer_code != SET)\n \t*total = 0;\n       else\n-        *total = 8;\n+\t*total = 8;\n       return true;\n \n     case MULT:\n       if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \t{\n \t  *total = COSTS_N_INSNS (3);\n-\t  return true;\n \t}\n-\n-      /* A mode size N times larger than SImode needs O(N*N) more insns.  */\n-      factor = GET_MODE_SIZE (mode) / 4;\n-      if (factor == 0)\n-\tfactor = 1;\n-\n-      if (TARGET_PA_11 && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT)\n-\t*total = factor * factor * COSTS_N_INSNS (8);\n+      else if (mode == DImode)\n+\t{\n+\t  if (TARGET_PA_11 && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT)\n+\t    *total = COSTS_N_INSNS (32);\n+\t  else\n+\t    *total = COSTS_N_INSNS (80);\n+\t}\n       else\n-\t*total = factor * factor * COSTS_N_INSNS (20);\n-      return true;\n+\t{\n+\t  if (TARGET_PA_11 && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT)\n+\t    *total = COSTS_N_INSNS (8);\n+\t  else\n+\t    *total = COSTS_N_INSNS (20);\n+\t}\n+      return REG_P (XEXP (x, 0)) && REG_P (XEXP (x, 1));\n \n     case DIV:\n       if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \t{\n \t  *total = COSTS_N_INSNS (14);\n-\t  return true;\n+\t  return false;\n \t}\n       /* FALLTHRU */\n \n     case UDIV:\n     case MOD:\n     case UMOD:\n       /* A mode size N times larger than SImode needs O(N*N) more insns.  */\n-      factor = GET_MODE_SIZE (mode) / 4;\n-      if (factor == 0)\n-\tfactor = 1;\n-\n-      *total = factor * factor * COSTS_N_INSNS (60);\n-      return true;\n+      if (mode == DImode)\n+\t*total = COSTS_N_INSNS (240);\n+      else\n+\t*total = COSTS_N_INSNS (60);\n+      return REG_P (XEXP (x, 0)) && REG_P (XEXP (x, 1));\n \n     case PLUS: /* this includes shNadd insns */\n     case MINUS:\n       if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\t*total = COSTS_N_INSNS (3);\n+      else if (mode == DImode)\n \t{\n-\t  *total = COSTS_N_INSNS (3);\n-\t  return true;\n+\t  if (TARGET_64BIT)\n+\t    {\n+\t      *total = COSTS_N_INSNS (1);\n+\t      /* Handle shladd,l instructions.  */\n+\t      if (hppa_rtx_costs_shadd_p (x))\n+\t\treturn true;\n+\t    }\n+\t  else\n+\t    *total = COSTS_N_INSNS (2);\n \t}\n-\n-      /* A size N times larger than UNITS_PER_WORD needs N times as\n-\t many insns, taking N times as long.  */\n-      factor = GET_MODE_SIZE (mode) / UNITS_PER_WORD;\n-      if (factor == 0)\n-\tfactor = 1;\n-      *total = factor * COSTS_N_INSNS (1);\n-      return true;\n+      else\n+\t{\n+\t  *total = COSTS_N_INSNS (1);\n+\t  /* Handle shNadd instructions.  */\n+\t  if (hppa_rtx_costs_shadd_p (x))\n+\t    return true;\n+\t}\n+      return REG_P (XEXP (x, 0))\n+\t     && (REG_P (XEXP (x, 1))\n+\t\t || CONST_INT_P (XEXP (x, 1)));\n \n     case ASHIFT:\n+      if (mode == DImode)\n+\t{\n+\t  if (TARGET_64BIT)\n+\t    *total = COSTS_N_INSNS (3);\n+\t  else if (REG_P (XEXP (x, 0)) && CONST_INT_P (XEXP (x, 1)))\n+\t    {\n+\t      *total = COSTS_N_INSNS (2);\n+\t      return true;\n+\t    }\n+\t  else if (speed)\n+\t    *total = COSTS_N_INSNS (13);\n+\t  else\n+\t    *total = COSTS_N_INSNS (18);\n+\t}\n+      else if (TARGET_64BIT)\n+\t*total = COSTS_N_INSNS (4);\n+      else\n+\t*total = COSTS_N_INSNS (2);\n+      return REG_P (XEXP (x, 0))\n+\t     && (REG_P (XEXP (x, 1))\n+\t\t || CONST_INT_P (XEXP (x, 1)));\n+\n     case ASHIFTRT:\n+      if (mode == DImode)\n+\t{\n+\t  if (TARGET_64BIT)\n+\t    *total = COSTS_N_INSNS (3);\n+\t  else if (REG_P (XEXP (x, 0)) && CONST_INT_P (XEXP (x, 1)))\n+\t    {\n+\t      *total = COSTS_N_INSNS (2);\n+\t      return true;\n+\t    }\n+\t  else if (speed)\n+\t    *total = COSTS_N_INSNS (14);\n+\t  else\n+\t    *total = COSTS_N_INSNS (19);\n+\t}\n+      else if (TARGET_64BIT)\n+\t*total = COSTS_N_INSNS (4);\n+      else\n+\t*total = COSTS_N_INSNS (2);\n+      return REG_P (XEXP (x, 0))\n+\t     && (REG_P (XEXP (x, 1))\n+\t\t || CONST_INT_P (XEXP (x, 1)));\n+\n     case LSHIFTRT:\n-      *total = COSTS_N_INSNS (1);\n-      return true;\n+      if (mode == DImode)\n+\t{\n+\t  if (TARGET_64BIT)\n+\t    *total = COSTS_N_INSNS (2);\n+\t  else if (REG_P (XEXP (x, 0)) && CONST_INT_P (XEXP (x, 1)))\n+\t    {\n+\t      *total = COSTS_N_INSNS (2);\n+\t      return true;\n+\t    }\n+\t  else if (speed)\n+\t    *total = COSTS_N_INSNS (12);\n+\t  else\n+\t    *total = COSTS_N_INSNS (15);\n+\t}\n+      else if (TARGET_64BIT)\n+\t*total = COSTS_N_INSNS (3);\n+      else\n+\t*total = COSTS_N_INSNS (2);\n+      return REG_P (XEXP (x, 0))\n+\t     && (REG_P (XEXP (x, 1))\n+\t\t || CONST_INT_P (XEXP (x, 1)));\n \n     default:\n       return false;"}]}