{"sha": "d29de1bf2836e4f06f32f7271192d7f92ba9235c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI5ZGUxYmYyODM2ZTRmMDZmMzJmNzI3MTE5MmQ3ZjkyYmE5MjM1Yw==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@il.ibm.com", "date": "2007-08-19T09:39:50Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2007-08-19T09:39:50Z"}, "message": "tree-vectorizer.h (vect_is_simple_reduction): Takes a loop_vec_info as argument instead of struct loop.\n\n        * tree-vectorizer.h (vect_is_simple_reduction): Takes a loop_vec_info\n        as argument instead of struct loop.\n        (nested_in_vect_loop_p): New function.\n        (vect_relevant): Add enum values vect_used_in_outer_by_reduction and\n        vect_used_in_outer.\n        (is_loop_header_bb_p): New. Used to differentiate loop-header phis\n        from other phis in the loop.\n        (destroy_loop_vec_info): Add additional argument to declaration.\n\n        * tree-vectorizer.c (supportable_widening_operation): Also check if\n        nested_in_vect_loop_p (don't allow changing the order in this case).\n        (vect_is_simple_reduction): Takes a loop_vec_info as argument instead\n        of struct loop. Call nested_in_vect_loop_p and don't require\n        flag_unsafe_math_optimizations if it returns true.\n        (new_stmt_vec_info): When setting def_type for phis differentiate\n        loop-header phis from other phis.\n        (bb_in_loop_p): New function.\n        (new_loop_vec_info): Inner-loop phis already have a stmt_vinfo, so just\n        update their loop_vinfo.  Order of BB traversal now matters - call\n        dfs_enumerate_from with bb_in_loop_p.\n        (destroy_loop_vec_info): Takes additional argument to control whether\n        stmt_vinfo of the loop stmts should be destroyed as well.\n        (vect_is_simple_reduction): Allow the \"non-reduction\" use of a\n        reduction stmt to be defines by a non loop-header phi.\n        (vectorize_loops): Call destroy_loop_vec_info with additional argument.\n\n        * tree-vect-transform.c (vectorizable_reduction): Call\n        nested_in_vect_loop_p. Check for multitypes in the inner-loop.\n        (vectorizable_call): Likewise.\n        (vectorizable_conversion): Likewise.\n        (vectorizable_operation): Likewise.\n        (vectorizable_type_promotion): Likewise.\n        (vectorizable_type_demotion): Likewise.\n        (vectorizable_store): Likewise.\n        (vectorizable_live_operation): Likewise.\n        (vectorizable_reduction): Likewise. Also pass loop_info to\n        vect_is_simple_reduction instead of loop.\n        (vect_init_vector): Call nested_in_vect_loop_p.\n        (get_initial_def_for_reduction): Likewise.\n        (vect_create_epilog_for_reduction): Likewise.\n        (vect_init_vector): Check which loop to work with, in case there's an\n        inner-loop.\n        (get_initial_def_for_inducion): Extend to handle outer-loop\n        vectorization. Fix indentation.\n        (vect_get_vec_def_for_operand): Support phis in the case vect_loop_def.\n        In the case vect_induction_def get the vector def from the induction\n        phi node, instead of calling get_initial_def_for_inducion.\n        (get_initial_def_for_reduction): Extend to handle outer-loop\n        vectorization.\n        (vect_create_epilog_for_reduction): Extend to handle outer-loop\n        vectorization.\n        (vect_transform_loop): Change assert to just skip this case.  Add a\n        dump printout.\n        (vect_finish_stmt_generation): Add a couple asserts.\n\n        (vect_estimate_min_profitable_iters): Multiply\n        cost of inner-loop stmts (in outer-loop vectorization) by estimated\n        inner-loop bound.\n        (vect_model_reduction_cost): Don't add reduction epilogue cost in case\n        this is an inner-loop reduction in outer-loop vectorization.\n\n        * tree-vect-analyze.c (vect_analyze_scalar_cycles_1): New function.\n        Same code as what used to be vect_analyze_scalar_cycles, only with\n        additional argument loop, and loop_info passed to\n        vect_is_simple_reduction instead of loop.\n        (vect_analyze_scalar_cycles): Code factored out into\n        vect_analyze_scalar_cycles_1. Call it for each relevant loop-nest.\n        Updated documentation.\n        (analyze_operations): Check for inner-loop loop-closed exit-phis during\n        outer-loop vectorization that are live or not used in the outerloop,\n        cause this requires special handling.\n        (vect_enhance_data_refs_alignment): Don't consider versioning for\n        nested-loops.\n        (vect_analyze_data_refs): Check that there are no datarefs in the\n        inner-loop.\n        (vect_mark_stmts_to_be_vectorized): Also consider vect_used_in_outer\n        and vect_used_in_outer_by_reduction cases.\n        (process_use): Also consider the case of outer-loop stmt defining an\n        inner-loop stmt and vice versa.\n        (vect_analyze_loop_1): New function.\n        (vect_analyze_loop_form): Extend, to allow a restricted form of nested\n        loops.  Call vect_analyze_loop_1.\n        (vect_analyze_loop): Skip (inner-)loops within outer-loops that have\n        been vectorized.  Call destroy_loop_vec_info with additional argument.\n\n        * tree-vect-patterns.c (vect_recog_widen_sum_pattern): Don't allow\n        in the inner-loop when doing outer-loop vectorization. Add\n        documentation and printout.\n        (vect_recog_dot_prod_pattern): Likewise. Also add check for\n        GIMPLE_MODIFY_STMT (in case we encounter a phi in the loop).\n\nFrom-SVN: r127623", "tree": {"sha": "1440005827d5c910ba6597f144fa3292c95f2032", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1440005827d5c910ba6597f144fa3292c95f2032"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d29de1bf2836e4f06f32f7271192d7f92ba9235c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d29de1bf2836e4f06f32f7271192d7f92ba9235c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d29de1bf2836e4f06f32f7271192d7f92ba9235c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d29de1bf2836e4f06f32f7271192d7f92ba9235c/comments", "author": null, "committer": null, "parents": [{"sha": "66d229b83597da5a73035cd2e13b7d5dd3a1d3d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66d229b83597da5a73035cd2e13b7d5dd3a1d3d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66d229b83597da5a73035cd2e13b7d5dd3a1d3d2"}], "stats": {"total": 3034, "additions": 2720, "deletions": 314}, "files": [{"sha": "9470bc3fd99acdc56d2d9d760f4f5d210858a5d2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -1,3 +1,96 @@\n+2007-08-19  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* tree-vectorizer.h (vect_is_simple_reduction): Takes a loop_vec_info\n+\tas argument instead of struct loop.\n+\t(nested_in_vect_loop_p): New function.\n+\t(vect_relevant): Add enum values vect_used_in_outer_by_reduction and\n+\tvect_used_in_outer.\n+\t(is_loop_header_bb_p): New. Used to differentiate loop-header phis\n+\tfrom other phis in the loop.\n+\t(destroy_loop_vec_info): Add additional argument to declaration.\n+\n+\t* tree-vectorizer.c (supportable_widening_operation): Also check if\n+\tnested_in_vect_loop_p (don't allow changing the order in this case).\n+\t(vect_is_simple_reduction): Takes a loop_vec_info as argument instead\n+\tof struct loop. Call nested_in_vect_loop_p and don't require\n+\tflag_unsafe_math_optimizations if it returns true.\n+\t(new_stmt_vec_info): When setting def_type for phis differentiate \n+\tloop-header phis from other phis.\n+\t(bb_in_loop_p): New function.\n+\t(new_loop_vec_info): Inner-loop phis already have a stmt_vinfo, so just\n+\tupdate their loop_vinfo.  Order of BB traversal now matters - call\n+\tdfs_enumerate_from with bb_in_loop_p.\n+\t(destroy_loop_vec_info): Takes additional argument to control whether\n+\tstmt_vinfo of the loop stmts should be destroyed as well.\n+\t(vect_is_simple_reduction): Allow the \"non-reduction\" use of a\n+\treduction stmt to be defines by a non loop-header phi.\n+\t(vectorize_loops): Call destroy_loop_vec_info with additional argument.\n+\n+\t* tree-vect-transform.c (vectorizable_reduction): Call\n+\tnested_in_vect_loop_p. Check for multitypes in the inner-loop.\n+\t(vectorizable_call): Likewise.\n+\t(vectorizable_conversion): Likewise.\n+\t(vectorizable_operation): Likewise.\n+\t(vectorizable_type_promotion): Likewise.\n+\t(vectorizable_type_demotion): Likewise.\n+\t(vectorizable_store): Likewise.\n+\t(vectorizable_live_operation): Likewise.\n+\t(vectorizable_reduction): Likewise. Also pass loop_info to\n+\tvect_is_simple_reduction instead of loop.\n+\t(vect_init_vector): Call nested_in_vect_loop_p.\n+\t(get_initial_def_for_reduction): Likewise.\n+\t(vect_create_epilog_for_reduction): Likewise.\n+\t(vect_init_vector): Check which loop to work with, in case there's an\n+\tinner-loop.\n+\t(get_initial_def_for_inducion): Extend to handle outer-loop\n+\tvectorization. Fix indentation.\n+\t(vect_get_vec_def_for_operand): Support phis in the case vect_loop_def.\n+\tIn the case vect_induction_def get the vector def from the induction\n+\tphi node, instead of calling get_initial_def_for_inducion.\n+\t(get_initial_def_for_reduction): Extend to handle outer-loop \n+\tvectorization.\n+\t(vect_create_epilog_for_reduction): Extend to handle outer-loop\n+\tvectorization.\n+\t(vect_transform_loop): Change assert to just skip this case.  Add a\n+\tdump printout.\n+\t(vect_finish_stmt_generation): Add a couple asserts.\n+\n+\t(vect_estimate_min_profitable_iters): Multiply\n+\tcost of inner-loop stmts (in outer-loop vectorization) by estimated\n+\tinner-loop bound.\n+\t(vect_model_reduction_cost): Don't add reduction epilogue cost in case\n+\tthis is an inner-loop reduction in outer-loop vectorization.\n+\n+\t* tree-vect-analyze.c (vect_analyze_scalar_cycles_1): New function.\n+\tSame code as what used to be vect_analyze_scalar_cycles, only with\n+\tadditional argument loop, and loop_info passed to\n+\tvect_is_simple_reduction instead of loop.\n+\t(vect_analyze_scalar_cycles): Code factored out into\n+\tvect_analyze_scalar_cycles_1. Call it for each relevant loop-nest.\n+\tUpdated documentation.\n+\t(analyze_operations): Check for inner-loop loop-closed exit-phis during\n+\touter-loop vectorization that are live or not used in the outerloop,\n+\tcause this requires special handling.\n+\t(vect_enhance_data_refs_alignment): Don't consider versioning for\n+\tnested-loops.\n+\t(vect_analyze_data_refs): Check that there are no datarefs in the\n+\tinner-loop.\n+\t(vect_mark_stmts_to_be_vectorized): Also consider vect_used_in_outer\n+\tand vect_used_in_outer_by_reduction cases.\n+\t(process_use): Also consider the case of outer-loop stmt defining an\n+\tinner-loop stmt and vice versa.\n+\t(vect_analyze_loop_1): New function.\n+\t(vect_analyze_loop_form): Extend, to allow a restricted form of nested\n+\tloops.  Call vect_analyze_loop_1.\n+\t(vect_analyze_loop): Skip (inner-)loops within outer-loops that have\n+\tbeen vectorized.  Call destroy_loop_vec_info with additional argument.\n+\n+\t* tree-vect-patterns.c (vect_recog_widen_sum_pattern): Don't allow\n+\tin the inner-loop when doing outer-loop vectorization. Add\n+\tdocumentation and printout.\n+\t(vect_recog_dot_prod_pattern): Likewise. Also add check for\n+\tGIMPLE_MODIFY_STMT (in case we encounter a phi in the loop).\n+\n 2007-08-18  Andrew Pinski  <pinskia@gmail.com>\n \n \t* tree-affine.h (print_aff): New prototype."}, {"sha": "1a34a13b70956c0df48e53cfcf6622fc0909a9bc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -1,3 +1,45 @@\n+2007-08-19  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect.exp: Compile tests with -fno-tree-scev-cprop\n+\tand -fno-tree-reassoc.\n+\t* gcc.dg/vect/no-tree-scev-cprop-vect-iv-1.c: Moved to...\n+\t* gcc.dg/vect/no-scevccp-vect-iv-1.c: New test.\n+\t* gcc.dg/vect/no-tree-scev-cprop-vect-iv-2.c: Moved to...\n+\t* gcc.dg/vect/no-scevccp-vect-iv-2.c: New test.\n+\t* gcc.dg/vect/no-tree-scev-cprop-vect-iv-3.c: Moved to...\n+\t* gcc.dg/vect/no-scevccp-vect-iv-3.c: New test.\n+\t* gcc.dg/vect/no-scevccp-noreassoc-outer-1.c: New test.\n+\t* gcc.dg/vect/no-scevccp-noreassoc-outer-2.c: New test.\n+\t* gcc.dg/vect/no-scevccp-noreassoc-outer-3.c: New test.\n+\t* gcc.dg/vect/no-scevccp-noreassoc-outer-4.c: New test.\n+\t* gcc.dg/vect/no-scevccp-noreassoc-outer-5.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-1.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-2.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-3.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-4.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-5.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-6.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-7.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-8.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-9.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-9a.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-9b.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-10.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-10a.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-10b.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-11.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-12.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-13.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-14.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-15.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-16.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-17.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-18.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-19.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-20.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-21.c: New test.\n+\t* gcc.dg/vect/no-scevccp-outer-22.c: New test.\n+\n 2007-08-19  Dorit Nuzman  <dorit@il.ibm.com>\n \n \t* testsuite/gcc.dg/vect/pr20122.c: Fix test (now vectorized, with"}, {"sha": "7c5b27a24cd8a5b5bd040225f1c4a5709910b0c1", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-noreassoc-outer-1.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-noreassoc-outer-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-noreassoc-outer-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-noreassoc-outer-1.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+\n+int a[N];\n+\n+int\n+foo (){\n+  int i,j,k=0;\n+  int sum,x;\n+\n+  for (i = 0; i < N; i++) {\n+    sum = 0;\n+    for (j = 0; j < N; j++) {\n+      sum += (i + j);\n+      i++;\n+    }\n+    a[k++] = sum;\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i,j,k=0;\n+  int sum;\n+\n+  check_vect ();\n+\n+  foo ();\n+\n+    /* check results:  */\n+  for (i=0; i<N; i++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < N; j++){\n+        sum += (j + i);\n+\ti++;\n+      }\n+      if (a[k++] != sum)\n+        abort();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "109ec248091450c7e9e84e92bd8822d97ecd9a16", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-noreassoc-outer-2.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-noreassoc-outer-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-noreassoc-outer-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-noreassoc-outer-2.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+int a[200*N];\n+\n+void\n+foo (){\n+  int i,j;\n+  int sum,s=0;\n+\n+  for (i = 0; i < 200*N; i++) {\n+    sum = 0;\n+    for (j = 0; j < N; j++) {\n+      sum += (i + j);\n+      i++;\n+    }\n+    a[i] = sum;\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i,j,k=0;\n+  int sum,s=0;\n+\n+  check_vect ();\n+\n+  foo ();\n+\n+    /* check results:  */\n+  for (i=0; i<200*N; i++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < N; j++){\n+        sum += (j + i);\n+\ti++;\n+      }\n+      if (a[i] != sum)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "831baceba7cb72dcd590a97ed1d819f0b35fdcba", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-noreassoc-outer-3.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-noreassoc-outer-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-noreassoc-outer-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-noreassoc-outer-3.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+\n+int a[N];\n+\n+int\n+foo (){\n+  int i,j;\n+  int sum,x;\n+\n+  for (i = 0; i < N; i++) {\n+    sum = 0;\n+    for (j = 0; j < N; j++) {\n+      sum += (i + j);\n+    }\n+    a[i] = sum;\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i,j;\n+  int sum;\n+\n+  check_vect ();\n+\n+  foo ();\n+\n+    /* check results:  */\n+  for (i=0; i<N; i++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < N; j++){\n+        sum += (j + i);\n+      }\n+      if (a[i] != sum)\n+        abort();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "1a8cf637992aec9d8e467d7a2b483ce599ac7262", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-noreassoc-outer-4.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-noreassoc-outer-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-noreassoc-outer-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-noreassoc-outer-4.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+\n+int\n+foo (){\n+  int i,j;\n+  int sum,s=0;\n+\n+  for (i = 0; i < 200*N; i++) {\n+    sum = 0;\n+    for (j = 0; j < N; j++) {\n+      sum += (i + j);\n+      i++;\n+    }\n+    s += sum;\n+  }\n+  return s;\n+}\n+\n+int bar (int i, int j)\n+{\n+return (i + j);\n+}\n+\n+int main (void)\n+{\n+  int i,j,k=0;\n+  int sum,s=0;\n+  int res; \n+\n+  check_vect ();\n+\n+  res = foo ();\n+\n+    /* check results:  */\n+  for (i=0; i<200*N; i++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < N; j++){\n+        sum += bar (i, j);\n+\ti++;\n+      }\n+      s += sum;\n+    }\n+  if (res != s)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "59c93b9bb68d20c7275672df1b47146805c578df", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-noreassoc-outer-5.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-noreassoc-outer-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-noreassoc-outer-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-noreassoc-outer-5.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+\n+int a[N];\n+\n+int\n+foo (){\n+  int i,j;\n+  int sum,x;\n+\n+  for (i = 0; i < N; i++) {\n+    sum = 0;\n+    x = a[i];\n+    for (j = 0; j < N; j++) {\n+      sum += (x + j);\n+    }\n+    a[i] = sum + i + x;\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i,j;\n+  int sum;\n+  int aa[N];\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++){\n+    a[i] = i;\n+    aa[i] = i;\n+  }\n+ \n+  foo ();\n+\n+    /* check results:  */\n+  for (i=0; i<N; i++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < N; j++)\n+        sum += (j + aa[i]);\n+      if (a[i] != sum + i + aa[i])\n+        abort();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "02c89c26b6a21390e25b3364d7189b8acd19bade", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-1.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+\n+#define N 40\n+signed short image[N][N];\n+signed short block[N][N];\n+\n+/* memory references in the inner-loop */\n+\n+unsigned int\n+foo (){\n+  int i,j;\n+  unsigned int diff = 0;\n+\n+  for (i = 0; i < N; i++) {\n+    for (j = 0; j < N; j++) {\n+      diff += (image[i][j] - block[i][j]);\n+    }\n+  }\n+  return diff;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "a4ff8565c7a679009e4796cd610925a1e7ac5000", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-10.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-10.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+\n+int a[N];\n+int b[N];\n+\n+int\n+foo (int n){\n+  int i,j;\n+  int sum,x,y;\n+\n+  for (i = 0; i < N/2; i++) {\n+    sum = 0;\n+    x = b[2*i];\n+    y = b[2*i+1];\n+    for (j = 0; j < n; j++) {\n+      sum += j;\n+    }\n+    a[2*i] = sum + x;\n+    a[2*i+1] = sum + y;\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i,j;\n+  int sum;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++)\n+    b[i] = i;\n+ \n+  foo (N-1);\n+\n+    /* check results:  */\n+  for (i=0; i<N/2; i++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < N-1; j++)\n+        sum += j;\n+      if (a[2*i] != sum + b[2*i] || a[2*i+1] != sum + b[2*i+1])\n+        abort();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ff3333d0301ee33bcd25ab8b5df6ef4407abea64", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-10a.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-10a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-10a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-10a.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+\n+int a[N];\n+int b[N];\n+\n+int\n+foo (int n){\n+  int i,j;\n+  int sum,x,y;\n+\n+  if (n<=0)\n+    return 0;\n+\n+  for (i = 0; i < N/2; i++) {\n+    sum = 0;\n+    x = b[2*i];\n+    y = b[2*i+1];\n+    j = 0;\n+    do {\n+      sum += j;\n+    } while (++j < n);\n+    a[2*i] = sum + x;\n+    a[2*i+1] = sum + y;\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i,j;\n+  int sum;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++)\n+    b[i] = i;\n+ \n+  foo (N-1);\n+\n+    /* check results:  */\n+  for (i=0; i<N/2; i++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < N-1; j++)\n+        sum += j;\n+      if (a[2*i] != sum + b[2*i] || a[2*i+1] != sum + b[2*i+1])\n+        abort();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "4aba6d8216a8a89f6bd2f893c07121930dbcc217", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-10b.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-10b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-10b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-10b.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+\n+int a[N];\n+int b[N];\n+\n+int\n+foo (int n){\n+  int i,j;\n+  int sum,x,y;\n+\n+  if (n<=0)\n+    return 0;\n+\n+  for (i = 0; i < N/2; i++) {\n+    sum = 0;\n+    x = b[2*i];\n+    y = b[2*i+1];\n+    for (j = 0; j < n; j++) {\n+      sum += j;\n+    }\n+    a[2*i] = sum + x;\n+    a[2*i+1] = sum + y;\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i,j;\n+  int sum;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++)\n+    b[i] = i;\n+ \n+  foo (N-1);\n+\n+    /* check results:  */\n+  for (i=0; i<N/2; i++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < N-1; j++)\n+        sum += j;\n+      if (a[2*i] != sum + b[2*i] || a[2*i+1] != sum + b[2*i+1])\n+        abort();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ebc1735288ad846ea462544deb7e589938031504", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-11.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-11.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+\n+int a[N];\n+\n+int\n+foo (int n){\n+  int i,j;\n+  int sum;\n+\n+  for (i = 0; i < n; i++) {\n+    sum = 0;\n+    for (j = 0; j < N; j++) {\n+      sum += j;\n+    }\n+    a[i] = sum;\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i,j;\n+  int sum;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++)\n+    a[i] = i;\n+ \n+  foo (N);\n+\n+    /* check results:  */\n+  for (i=0; i<N; i++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < N; j++)\n+        sum += j;\n+      if (a[i] != sum)\n+        abort();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "85d4ec1486e4a039a59078934a554567c5e542c6", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-12.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-12.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+int a[N];\n+short b[N];\n+\n+int\n+foo (){\n+  int i,j;\n+  int sum;\n+\n+  for (i = 0; i < N; i++) {\n+    sum = 0;\n+    for (j = 0; j < N; j++) {\n+      sum += j;\n+    }\n+    a[i] = sum;\n+    b[i] = (short)sum;\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i,j;\n+  int sum;\n+\n+  check_vect ();\n+\n+  foo ();\n+\n+    /* check results:  */\n+  for (i=0; i<N; i++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < N; j++)\n+        sum += j;\n+      if (a[i] != sum  || b[i] != (short)sum)\n+        abort();\n+    }\n+\n+  return 0;\n+}\n+\n+/* Until we support multiple types in the inner loop  */\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "3e491a1045c3dab3b23e2d431507ecd935dfc4d3", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-13.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-13.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+\n+unsigned short in[N];\n+\n+unsigned int\n+foo (short scale){\n+  int i;\n+  unsigned short j;\n+  unsigned int sum = 0;\n+  unsigned short sum_j;\n+\n+  for (i = 0; i < N; i++) {\n+    sum_j = 0;\n+    for (j = 0; j < N; j++) {\n+      sum_j += j;\n+    }\n+    sum += ((unsigned int) in[i] * (unsigned int) sum_j) >> scale;\n+  }\n+  return sum;\n+}\n+\n+unsigned short\n+bar (void)\n+{\n+  unsigned short j;\n+  unsigned short sum_j;\n+    sum_j = 0;\n+    for (j = 0; j < N; j++) {\n+      sum_j += j;\n+    }\n+  return sum_j;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  unsigned short j, sum_j;\n+  unsigned int sum = 0;\n+  unsigned int res;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++){\n+    in[i] = i;\n+  }\n+ \n+  res = foo (2);\n+\n+  /* check results:  */\n+  for (i=0; i<N; i++)\n+    {\n+      sum_j = bar ();\n+      sum += ((unsigned int) in[i] * (unsigned int) sum_j) >> 2;\n+    }\n+  if (res != sum)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" { target vect_widen_mult_hi_to_si } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ea115453a2f1683c6926abdd41637f618ea68c2c", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-14.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-14.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+unsigned short\n+foo (short scale){\n+  int i;\n+  unsigned short j;\n+  unsigned short sum = 0;\n+  unsigned short sum_j;\n+\n+  for (i = 0; i < N; i++) {\n+    sum_j = 0;\n+    for (j = 0; j < N; j++) {\n+      sum_j += j;\n+    }\n+    sum += sum_j;\n+  }\n+  return sum;\n+}\n+\n+unsigned short\n+bar (void)\n+{\n+  unsigned short j;\n+  unsigned short sum_j;\n+    sum_j = 0;\n+    for (j = 0; j < N; j++) {\n+      sum_j += j;\n+    }\n+  return sum_j;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  unsigned short j, sum_j;\n+  unsigned short sum = 0;\n+  unsigned short res;\n+\n+  check_vect ();\n+\n+  res = foo (2);\n+\n+  /* check results:  */\n+  for (i=0; i<N; i++)\n+    {\n+      sum_j = bar();\n+      sum += sum_j;\n+    }\n+  if (res != sum)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" { target vect_widen_mult_hi_to_si } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "7eb5ff5d4e1956c1fd42541f8c72a8312735955a", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-15.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-15.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+\n+int a[N];\n+\n+int\n+foo (int x){\n+  int i,j;\n+  int sum;\n+\n+  for (i = 0; i < N; i++) {\n+    sum = 0;\n+    for (j = 0; j < N; j++) {\n+      sum += j;\n+    }\n+    a[i] = sum + i + x;\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i,j;\n+  int sum;\n+  int aa[N];\n+\n+  check_vect ();\n+ \n+  foo (3);\n+\n+    /* check results:  */\n+  for (i=0; i<N; i++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < N; j++)\n+        sum += j;\n+      if (a[i] != sum + i + 3)\n+        abort();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "73045044ffa7a9eb360b0202b0dc54fa72153a67", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-16.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-16.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+\n+int a[N];\n+\n+int\n+foo (){\n+  int i;\n+  unsigned short j;\n+  int sum = 0;\n+  unsigned short sum_j;\n+\n+  for (i = 0; i < N; i++) {\n+    sum += i;\n+\n+    sum_j = 0;\n+    for (j = 0; j < N; j++) {\n+      sum_j += j;\n+    }\n+    a[i] = sum_j + 5;\n+  }\n+  return sum;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  unsigned short j, sum_j;\n+  int sum = 0;\n+  int res;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++)\n+    a[i] = i;\n+ \n+  res = foo ();\n+\n+  /* check results:  */\n+  for (i=0; i<N; i++)\n+    {\n+      sum += i;\n+\n+      sum_j = 0;\n+      for (j = 0; j < N; j++){\n+        sum_j += j;\n+      }\n+      if (a[i] != sum_j + 5)\n+        abort();\n+    }\n+  if (res != sum)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "3ddea5ff0e9572f0d773b982478e04f8807ba832", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-17.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-17.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+\n+int a[N];\n+int b[N];\n+int c[N];\n+\n+int\n+foo (){\n+  int i;\n+  unsigned short j;\n+  int sum = 0;\n+  unsigned short sum_j;\n+\n+  for (i = 0; i < N; i++) {\n+    int diff = b[i] - c[i];\n+\n+    sum_j = 0;\n+    for (j = 0; j < N; j++) {\n+      sum_j += j;\n+    }\n+    a[i] = sum_j + 5;\n+\n+    sum += diff;\n+  }\n+  return sum;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  unsigned short j, sum_j;\n+  int sum = 0;\n+  int res;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++){\n+    b[i] = i;\n+    c[i] = 2*i;\n+  }\n+ \n+  res = foo ();\n+\n+  /* check results:  */\n+  for (i=0; i<N; i++)\n+    {\n+      sum += (b[i] - c[i]);\n+\n+      sum_j = 0;\n+      for (j = 0; j < N; j++){\n+        sum_j += j;\n+      }\n+      if (a[i] != sum_j + 5)\n+        abort();\n+    }\n+  if (res != sum)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "f069a98bd91b32e979a81b6d95cdeecaf7e33656", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-18.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-18.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+\n+int a[N];\n+\n+int\n+foo (){\n+  int i,j;\n+  int sum;\n+\n+  for (i = 0; i < N/2; i++) {\n+    sum = 0;\n+    for (j = 0; j < N; j++) {\n+      sum += j;\n+    }\n+    a[2*i] = sum;\n+    a[2*i+1] = 2*sum;\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i,j;\n+  int sum;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++)\n+    a[i] = i;\n+ \n+  foo ();\n+\n+    /* check results:  */\n+  for (i=0; i<N/2; i++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < N; j++)\n+        sum += j;\n+      if (a[2*i] != sum || a[2*i+1] != 2*sum)\n+        abort();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "3a5f6cd719fa529521459bb7d36153447cc6fb91", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-19.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-19.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+unsigned short a[N];\n+unsigned int b[N];\n+\n+int\n+foo (){\n+  unsigned short i,j;\n+  unsigned short sum;\n+\n+  for (i = 0; i < N; i++) {\n+    sum = 0;\n+    for (j = 0; j < N; j++) {\n+      sum += j;\n+    }\n+    a[i] = sum;\n+    b[i] = (unsigned int)sum;\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i,j;\n+  short sum;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++)\n+    a[i] = i;\n+ \n+  foo ();\n+\n+    /* check results:  */\n+  for (i=0; i<N; i++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < N; j++)\n+        sum += j;\n+      if (a[i] != sum  || b[i] != (unsigned int)sum)\n+        abort();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "a9ac09c4a2b044f7cc67f210099515207e8dfad6", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-2.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+#define N 40\n+\n+int\n+foo (){\n+  int i,j;\n+  int diff = 0;\n+\n+  for (i = 0; i < N; i++) {\n+    for (j = 0; j < N; j++) {\n+      diff += j;\n+    }\n+  }\n+  return diff;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "be2b85f4c0e7cf65a6b7584b1a37a3d1e2d54dca", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-20.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-20.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+\n+int a[N];\n+int b[N];\n+\n+int\n+foo (){\n+  int i,j;\n+  int sum,x,y;\n+\n+  for (i = 0; i < N/2; i++) {\n+    sum = 0;\n+    x = b[2*i];\n+    y = b[2*i+1];\n+    for (j = 0; j < N; j++) {\n+      sum += j;\n+    }\n+    a[2*i] = sum + x;\n+    a[2*i+1] = sum + y;\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i,j;\n+  int sum;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++)\n+    b[i] = i;\n+ \n+  foo ();\n+\n+    /* check results:  */\n+  for (i=0; i<N/2; i++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < N; j++)\n+        sum += j;\n+      if (a[2*i] != sum + b[2*i] || a[2*i+1] != sum + b[2*i+1])\n+        abort();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "30f76fa7d7a65b7e0d6ec5ead68292c8e8ea88b7", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-21.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-21.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+\n+int a[N];\n+\n+int\n+foo (){\n+  int i;\n+  unsigned short j;\n+  int sum = 0;\n+  unsigned short sum_j;\n+\n+  for (i = 0; i < N; i++) {\n+    sum += i;\n+\n+    sum_j = i;\n+    for (j = 0; j < N; j++) {\n+      sum_j += j;\n+    }\n+    a[i] = sum_j + 5;\n+  }\n+  return sum;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  unsigned short j, sum_j;\n+  int sum = 0;\n+  int res;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++)\n+    a[i] = i;\n+ \n+  res = foo ();\n+\n+  /* check results:  */\n+  for (i=0; i<N; i++)\n+    {\n+      sum += i;\n+\n+      sum_j = i;\n+      for (j = 0; j < N; j++){\n+        sum_j += j;\n+      }\n+      if (a[i] != sum_j + 5)\n+        abort();\n+    }\n+  if (res != sum)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "659420f94f7ca816361b709990b74b079abc4fe6", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-22.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-22.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+\n+int a[N];\n+\n+int\n+foo (int n){\n+  int i,j;\n+  int sum;\n+\n+  if (n<=0)\n+    return 0;\n+\n+  /* inner-loop index j used after the inner-loop */\n+  for (i = 0; i < N; i++) {\n+    sum = 0;\n+    for (j = 0; j < n; j+=2) {\n+      sum += j;\n+    }\n+    a[i] = sum + j;\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i,j;\n+  int sum;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++)\n+    a[i] = i;\n+ \n+  foo (N);\n+\n+    /* check results:  */\n+  for (i=0; i<N; i++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < N; j+=2)\n+        sum += j;\n+      if (a[i] != sum + j)\n+        abort();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ba15ecf3265639c3fa1a2c278c9c48d434cb5d89", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-3.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-3.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+\n+int a[N];\n+\n+int\n+foo (){\n+  int i,j;\n+  int sum;\n+\n+  /* inner-loop step > 1 */\n+  for (i = 0; i < N; i++) {\n+    sum = 0;\n+    for (j = 0; j < N; j+=2) {\n+      sum += j;\n+    }\n+    a[i] = sum;\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i,j;\n+  int sum;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++)\n+    a[i] = i;\n+ \n+  foo ();\n+\n+    /* check results:  */\n+  for (i=0; i<N; i++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < N; j+=2)\n+        sum += j;\n+      if (a[i] != sum)\n+        abort();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "c206587f175fcdac5ab3b6490133d83623cb234d", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-4.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-4.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+\n+int a[N];\n+\n+/* induction variable k advances through inner and outer loops.  */\n+\n+int\n+foo (int n){\n+  int i,j,k=0;\n+  int sum;\n+\n+  if (n<=0)\n+    return 0;\n+\n+  for (i = 0; i < N; i++) {\n+    sum = 0;\n+    for (j = 0; j < n; j+=2) {\n+      sum += k++;\n+    }\n+    a[i] = sum + j;\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i,j,k=0;\n+  int sum;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++)\n+    a[i] = i;\n+ \n+  foo (N);\n+\n+    /* check results:  */\n+  for (i=0; i<N; i++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < N; j+=2)\n+        sum += k++;\n+      if (a[i] != sum + j)\n+        abort();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "4b609ca255a86b2aadc668f9d1baa1def3ee9aee", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-5.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-5.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+\n+int a[N];\n+\n+int\n+foo (){\n+  int i,j;\n+  int sum;\n+\n+  for (i = 0; i < N; i++) {\n+    sum = 0;\n+    for (j = 0; j < N; j++) {\n+      sum += j;\n+    }\n+    a[i] += sum + i;\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i,j;\n+  int sum;\n+  int aa[N];\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++){\n+    a[i] = i;\n+    aa[i] = i;\n+  }\n+ \n+  foo ();\n+\n+    /* check results:  */\n+  for (i=0; i<N; i++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < N; j++)\n+        sum += j;\n+      if (a[i] != aa[i] + sum + i)\n+        abort();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "d90857b106aa1a7ee529fee5fc0fe7c4b15e4524", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-6.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-6.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+\n+int\n+foo (int * __restrict__ b, int k){\n+  int i,j;\n+  int sum,x;\n+  int a[N];\n+\n+  for (i = 0; i < N; i++) {\n+    sum = b[i];\n+    for (j = 0; j < N; j++) {\n+      sum += j;\n+    }\n+    a[i] = sum;\n+  }\n+  \n+  return a[k];\n+}\n+\n+int main (void)\n+{\n+  int i,j;\n+  int sum;\n+  int b[N];\n+  int a[N];\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++)\n+    b[i] = i + 2;\n+\n+  for (i=0; i<N; i++)\n+    a[i] = foo (b,i);\n+\n+    /* check results:  */\n+  for (i=0; i<N; i++)\n+    {\n+      sum = b[i];\n+      for (j = 0; j < N; j++){\n+        sum += j;\n+      }\n+      if (a[i] != sum)\n+        abort();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_mult_pattern: detected\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ff0dc0dbd5bf21b7835b8cf44152e6dcc1ff0c33", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-7.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-7.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,75 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+\n+unsigned short in[N];\n+unsigned short coef[N];\n+unsigned short a[N];\n+\n+unsigned int\n+foo (short scale){\n+  int i;\n+  unsigned short j;\n+  unsigned int sum = 0;\n+  unsigned short sum_j;\n+\n+  for (i = 0; i < N; i++) {\n+    sum_j = 0;\n+    for (j = 0; j < N; j++) {\n+      sum_j += j;\n+    }\n+    a[i] = sum_j;\n+    sum += ((unsigned int) in[i] * (unsigned int) coef[i]) >> scale;\n+  }\n+  return sum;\n+}\n+\n+unsigned short\n+bar (void)\n+{\n+  unsigned short j;\n+  unsigned short sum_j;\n+\n+  sum_j = 0;\n+  for (j = 0; j < N; j++) {\n+    sum_j += j;\n+  }\n+\n+  return sum_j;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  unsigned short j, sum_j;\n+  unsigned int sum = 0;\n+  unsigned int res;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++){\n+    in[i] = 2*i;\n+    coef[i] = i;\n+  }\n+ \n+  res = foo (2);\n+\n+  /* check results:  */\n+  for (i=0; i<N; i++)\n+    {\n+      if (a[i] != bar ())\n+\tabort ();\n+      sum += ((unsigned int) in[i] * (unsigned int) coef[i]) >> 2;\n+    }\n+  if (res != sum)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" { target vect_widen_mult_hi_to_si } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_mult_pattern: detected\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "44026dd92c68f71ea4cfd8f854393815b3658afa", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-8.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-8.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+\n+\n+int\n+foo (int *a){\n+  int i,j;\n+  int sum;\n+\n+  for (i = 0; i < N; i++) {\n+    sum = 0;\n+    for (j = 0; j < N; j++) {\n+      sum += j;\n+    }\n+    a[i] = sum;\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i,j;\n+  int sum;\n+  int a[N];\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++)\n+    a[i] = i;\n+ \n+  foo (a);\n+\n+    /* check results:  */\n+  for (i=0; i<N; i++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < N; j++)\n+        sum += j;\n+      if (a[i] != sum)\n+        abort();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "16b014c097db975513d5e96d4543bd12716433ff", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-9.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-9.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+\n+int a[N];\n+\n+int\n+foo (int n){\n+  int i,j;\n+  int sum;\n+\n+  for (i = 0; i < N; i++) {\n+    sum = 0;\n+    for (j = 0; j < n; j++) {\n+      sum += j;\n+    }\n+    a[i] = sum;\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i,j;\n+  int sum;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++)\n+    a[i] = i;\n+ \n+  foo (N);\n+\n+    /* check results:  */\n+  for (i=0; i<N; i++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < N; j++)\n+        sum += j;\n+      if (a[i] != sum)\n+        abort();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "93b0864a055da1b8764e3b83602dc34b4a685661", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-9a.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-9a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-9a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-9a.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+\n+int a[N];\n+\n+int\n+foo (int n){\n+  int i,j;\n+  int sum;\n+\n+  if (n<=0)\n+    return 0;\n+\n+  for (i = 0; i < N; i++) {\n+    sum = 0;\n+    j = 0;\n+    do {\n+      sum += j;\n+    }while (++j < n);\n+    a[i] = sum;\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i,j;\n+  int sum;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++)\n+    a[i] = i;\n+ \n+  foo (N);\n+\n+    /* check results:  */\n+  for (i=0; i<N; i++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < N; j++)\n+        sum += j;\n+      if (a[i] != sum)\n+        abort();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "5935599e7597b7da2e8ef459e5b936b2d28485eb", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-9b.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-9b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-9b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-9b.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+\n+int a[N];\n+\n+int\n+foo (int n){\n+  int i,j;\n+  int sum;\n+\n+  if (n<=0)\n+    return 0;\n+\n+  for (i = 0; i < N; i++) {\n+    sum = 0;\n+    for (j = 0; j < n; j++) {\n+      sum += j;\n+    }\n+    a[i] = sum;\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i,j;\n+  int sum;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++)\n+    a[i] = i;\n+ \n+  foo (N);\n+\n+    /* check results:  */\n+  for (i=0; i<N; i++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < N; j++)\n+        sum += j;\n+      if (a[i] != sum)\n+        abort();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/testsuite/gcc.dg/vect/no-tree-scev-cprop-vect-iv-1.c", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-scev-cprop-vect-iv-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-scev-cprop-vect-iv-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-scev-cprop-vect-iv-1.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -1,34 +0,0 @@\n-/* { dg-require-effective-target vect_int } */\n-\n-#include <stdarg.h>\n-#include \"tree-vect.h\"\n-\n-#define N 26\n- \n-int main1 (int X)\n-{  \n-  int s = X;\n-  int i;\n-\n-  /* vectorization of reduction with induction. \n-     Need -fno-tree-scev-cprop or else the loop is eliminated.  */\n-  for (i = 0; i < N; i++)\n-    s += i;\n-\n-  return s;\n-}\n-\n-int main (void)\n-{ \n-  int s;\n-  check_vect ();\n-  \n-  s = main1 (3);\n-  if (s != 328)\n-    abort ();\n-\n-  return 0;\n-} \n-\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n-/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/testsuite/gcc.dg/vect/no-tree-scev-cprop-vect-iv-2.c", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-scev-cprop-vect-iv-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-scev-cprop-vect-iv-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-scev-cprop-vect-iv-2.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -1,49 +0,0 @@\n-/* { dg-require-effective-target vect_int } */\n-\n-#include <stdarg.h>\n-#include \"tree-vect.h\"\n-\n-#define N 16\n- \n-int main1 ()\n-{  \n-  int arr1[N];\n-  int k = 0;\n-  int m = 3, i = 0;\n-  \n-  /* Vectorization of induction that is used after the loop.  \n-     Currently vectorizable because scev_ccp disconnects the\n-     use-after-the-loop from the iv def inside the loop.  */\n-\n-   do { \n-        k = k + 2;\n-        arr1[i] = k;\n-\tm = m + k;\n-\ti++;\n-   } while (i < N);\n-\n-  /* check results:  */\n-  for (i = 0; i < N; i++)\n-    { \n-      if (arr1[i] != 2+2*i)\n-        abort ();\n-    }\n-\n-  return m + k;\n-}\n-\n-int main (void)\n-{ \n-  int res;\n-\n-  check_vect ();\n-  \n-  res = main1 ();\n-  if (res != 32 + 275)\n-    abort ();\n-\n-  return 0;\n-} \n-\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/testsuite/gcc.dg/vect/no-tree-scev-cprop-vect-iv-3.c", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-scev-cprop-vect-iv-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-scev-cprop-vect-iv-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-scev-cprop-vect-iv-3.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -1,27 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-require-effective-target vect_int } */\n-\n-#include <stdarg.h>\n-#include \"tree-vect.h\"\n-\n-#define N 26\n- \n-unsigned int main1 ()\n-{  \n-  unsigned short i;\n-  unsigned int intsum = 0;\n-\n-  /* vectorization of reduction with induction, and widenning sum: \n-     sum shorts into int. \n-     Need -fno-tree-scev-cprop or else the loop is eliminated.  */\n-  for (i = 0; i < N; i++)\n-    {\n-      intsum += i;\n-    } \n-\n-  return intsum;\n-}\n-\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_widen_sum_hi_to_si } } } */\n-/* { dg-final { scan-tree-dump-times \"vect_recog_widen_sum_pattern: detected\" 1 \"vect\" { target vect_widen_sum_hi_to_si } } } */\n-/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "d86dafe9505ac09121f1627678e45df925789735", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-sum.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-sum.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-sum.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-sum.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -42,4 +42,5 @@ int main (void)\n \n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_widen_mult_hi_to_si } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_mult_pattern: detected\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "fba5aa8f5913ee9ceffefe2a519068cbb15366fc", "filename": "gcc/testsuite/gcc.dg/vect/vect.exp", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -182,8 +182,20 @@ dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-trapping-math-*.\\[cS\\]]]\n # -fno-tree-scev-cprop\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fno-tree-scev-cprop\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-tree-scev-cprop-*.\\[cS\\]]]  \\\n-\t\"\" $DEFAULT_VECTCFLAGS\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-scevccp-vect-*.\\[cS\\]]]  \\\n+        \"\" $DEFAULT_VECTCFLAGS\n+\n+# -fno-tree-scev-cprop\n+set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n+lappend DEFAULT_VECTCFLAGS \"-fno-tree-scev-cprop\"\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-scevccp-outer-*.\\[cS\\]]]  \\\n+        \"\" $DEFAULT_VECTCFLAGS\n+\n+# -fno-tree-scev-cprop -fno-tree-reassoc\n+set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n+lappend DEFAULT_VECTCFLAGS \"-fno-tree-scev-cprop\" \"-fno-tree-reassoc\"\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-scevccp-noreassoc-*.\\[cS\\]]]  \\\n+        \"\" $DEFAULT_VECTCFLAGS\n \n # -fno-tree-dominator-opts\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS"}, {"sha": "5fb546213599c3301257b5cd628ec86da2b4f07c", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 380, "deletions": 83, "changes": 463, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -325,6 +325,24 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t      print_generic_expr (vect_dump, phi, TDF_SLIM);\n \t    }\n \n+\t  if (! is_loop_header_bb_p (bb))\n+\t    {\n+\t      /* inner-loop loop-closed exit phi in outer-loop vectorization\n+\t\t (i.e. a phi in the tail of the outer-loop). \n+\t\t FORNOW: we currently don't support the case that these phis\n+\t\t are not used in the outerloop, cause this case requires\n+\t\t to actually do something here.  */\n+\t      if (!STMT_VINFO_RELEVANT_P (stmt_info) \n+\t\t  || STMT_VINFO_LIVE_P (stmt_info))\n+\t\t{\n+\t\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t\t    fprintf (vect_dump, \n+\t\t\t     \"Unsupported loop-closed phi in outer-loop.\");\n+\t\t  return false;\n+\t\t}\n+\t      continue;\n+\t    }\n+\n \t  gcc_assert (stmt_info);\n \n \t  if (STMT_VINFO_LIVE_P (stmt_info))\n@@ -398,7 +416,9 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t      break;\n \t\n \t    case vect_reduction_def:\n-\t      gcc_assert (relevance == vect_unused_in_loop);\n+\t      gcc_assert (relevance == vect_used_in_outer\n+\t\t\t  || relevance == vect_used_in_outer_by_reduction\n+\t\t\t  || relevance == vect_unused_in_loop);\n \t      break;\t\n \n \t    case vect_induction_def:\n@@ -589,50 +609,17 @@ exist_non_indexing_operands_for_use_p (tree use, tree stmt)\n }\n \n \n-/* Function vect_analyze_scalar_cycles.\n-\n-   Examine the cross iteration def-use cycles of scalar variables, by\n-   analyzing the loop (scalar) PHIs; Classify each cycle as one of the\n-   following: invariant, induction, reduction, unknown.\n-   \n-   Some forms of scalar cycles are not yet supported.\n-\n-   Example1: reduction: (unsupported yet)\n-\n-              loop1:\n-              for (i=0; i<N; i++)\n-                 sum += a[i];\n-\n-   Example2: induction: (unsupported yet)\n-\n-              loop2:\n-              for (i=0; i<N; i++)\n-                 a[i] = i;\n-\n-   Note: the following loop *is* vectorizable:\n-\n-              loop3:\n-              for (i=0; i<N; i++)\n-                 a[i] = b[i];\n-\n-         even though it has a def-use cycle caused by the induction variable i:\n-\n-              loop: i_2 = PHI (i_0, i_1)\n-                    a[i_2] = ...;\n-                    i_1 = i_2 + 1;\n-                    GOTO loop;\n+/* Function vect_analyze_scalar_cycles_1.\n \n-         because the def-use cycle in loop3 is considered \"not relevant\" - i.e.,\n-         it does not need to be vectorized because it is only used for array\n-         indexing (see 'mark_stmts_to_be_vectorized'). The def-use cycle in\n-         loop2 on the other hand is relevant (it is being written to memory).\n-*/\n+   Examine the cross iteration def-use cycles of scalar variables\n+   in LOOP. LOOP_VINFO represents the loop that is noe being\n+   considered for vectorization (can be LOOP, or an outer-loop\n+   enclosing LOOP).  */\n \n static void\n-vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n+vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n {\n   tree phi;\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block bb = loop->header;\n   tree dumy;\n   VEC(tree,heap) *worklist = VEC_alloc (tree, heap, 64);\n@@ -698,7 +685,7 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n       gcc_assert (is_gimple_reg (SSA_NAME_VAR (def)));\n       gcc_assert (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_unknown_def_type);\n \n-      reduc_stmt = vect_is_simple_reduction (loop, phi);\n+      reduc_stmt = vect_is_simple_reduction (loop_vinfo, phi);\n       if (reduc_stmt)\n         {\n           if (vect_print_dump_info (REPORT_DETAILS))\n@@ -717,6 +704,48 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n }\n \n \n+/* Function vect_analyze_scalar_cycles.\n+\n+   Examine the cross iteration def-use cycles of scalar variables, by\n+   analyzing the loop-header PHIs of scalar variables; Classify each \n+   cycle as one of the following: invariant, induction, reduction, unknown.\n+   We do that for the loop represented by LOOP_VINFO, and also to its\n+   inner-loop, if exists.\n+   Examples for scalar cycles:\n+\n+   Example1: reduction:\n+\n+              loop1:\n+              for (i=0; i<N; i++)\n+                 sum += a[i];\n+\n+   Example2: induction:\n+\n+              loop2:\n+              for (i=0; i<N; i++)\n+                 a[i] = i;  */\n+\n+static void\n+vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n+{\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+\n+  vect_analyze_scalar_cycles_1 (loop_vinfo, loop);\n+\n+  /* When vectorizing an outer-loop, the inner-loop is executed sequentially.\n+     Reductions in such inner-loop therefore have different properties than\n+     the reductions in the nest that gets vectorized:\n+     1. When vectorized, they are executed in the same order as in the original\n+        scalar loop, so we can't change the order of computation when\n+        vectorizing them.\n+     2. FIXME: Inner-loop reductions can be used in the inner-loop, so the \n+        current checks are too strict.  */\n+\n+  if (loop->inner)\n+    vect_analyze_scalar_cycles_1 (loop_vinfo, loop->inner);\n+}\n+\n+\n /* Function vect_insert_into_interleaving_chain.\n \n    Insert DRA into the interleaving chain of DRB according to DRA's INIT.  */\n@@ -1166,6 +1195,8 @@ vect_is_duplicate_ddr (VEC (ddr_p, heap) * may_alias_ddrs, ddr_p ddr_new)\n static bool\n vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n {\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+\n   if (vect_print_dump_info (REPORT_DR_DETAILS))\n     {\n       fprintf (vect_dump, \"mark for run-time aliasing test between \");\n@@ -1174,6 +1205,14 @@ vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n       print_generic_expr (vect_dump, DR_REF (DDR_B (ddr)), TDF_SLIM);\n     }\n \n+  /* FORNOW: We don't support versioning with outer-loop vectorization.  */\n+  if (loop->inner)\n+    {\n+      if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\tfprintf (vect_dump, \"versioning not yet supported for outer-loops.\");\n+      return false;\n+    }\n+\n   /* Do not add to the list duplicate ddrs.  */\n   if (vect_is_duplicate_ddr (LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo), ddr))\n     return true;\n@@ -1805,7 +1844,10 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n      4) all misaligned data refs with a known misalignment are supported, and\n      5) the number of runtime alignment checks is within reason.  */\n \n-  do_versioning = flag_tree_vect_loop_version && (!optimize_size);\n+  do_versioning = \n+\tflag_tree_vect_loop_version \n+\t&& (!optimize_size)\n+\t&& (!loop->inner); /* FORNOW */\n \n   if (do_versioning)\n     {\n@@ -2188,6 +2230,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n     {\n       tree stmt;\n       stmt_vec_info stmt_info;\n+      basic_block bb;\n    \n       if (!dr || !DR_REF (dr))\n         {\n@@ -2200,6 +2243,16 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n       stmt = DR_STMT (dr);\n       stmt_info = vinfo_for_stmt (stmt);\n \n+      /* If outer-loop vectorization: we don't yet support datarefs\n+\t in the innermost loop.  */\n+      bb = bb_for_stmt (stmt);\n+      if (bb->loop_father != LOOP_VINFO_LOOP (loop_vinfo))\n+\t{\n+\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+\t    fprintf (vect_dump, \"not vectorized: data-ref in nested loop\");\n+\t  return false;\n+\t}\n+\n       if (STMT_VINFO_DATA_REF (stmt_info))\n         {\n           if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n@@ -2287,11 +2340,13 @@ vect_mark_relevant (VEC(tree,heap) **worklist, tree stmt,\n \n       /* This is the last stmt in a sequence that was detected as a \n          pattern that can potentially be vectorized.  Don't mark the stmt\n-         as relevant/live because it's not going to vectorized.\n+         as relevant/live because it's not going to be vectorized.\n          Instead mark the pattern-stmt that replaces it.  */\n+\n+      pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n+\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"last stmt in pattern. don't mark relevant/live.\");\n-      pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n       stmt_info = vinfo_for_stmt (pattern_stmt);\n       gcc_assert (STMT_VINFO_RELATED_STMT (stmt_info) == stmt);\n       save_relevant = STMT_VINFO_RELEVANT (stmt_info);\n@@ -2341,7 +2396,8 @@ vect_stmt_relevant_p (tree stmt, loop_vec_info loop_vinfo,\n   *live_p = false;\n \n   /* cond stmt other than loop exit cond.  */\n-  if (is_ctrl_stmt (stmt) && (stmt != LOOP_VINFO_EXIT_COND (loop_vinfo)))\n+  if (is_ctrl_stmt (stmt) \n+      && STMT_VINFO_TYPE (vinfo_for_stmt (stmt)) != loop_exit_ctrl_vec_info_type) \n     *relevant = vect_used_in_loop;\n \n   /* changing memory.  */\n@@ -2398,6 +2454,8 @@ vect_stmt_relevant_p (tree stmt, loop_vec_info loop_vinfo,\n    of the respective DEF_STMT is left unchanged.\n    - case 2: If STMT is a reduction phi and DEF_STMT is a reduction stmt, we \n    skip DEF_STMT cause it had already been processed.  \n+   - case 3: If DEF_STMT and STMT are in different nests, then  \"relevant\" will\n+   be modified accordingly.\n \n    Return true if everything is as expected. Return false otherwise.  */\n \n@@ -2408,7 +2466,7 @@ process_use (tree stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n   stmt_vec_info dstmt_vinfo;\n-  basic_block def_bb;\n+  basic_block bb, def_bb;\n   tree def, def_stmt;\n   enum vect_def_type dt;\n \n@@ -2429,17 +2487,27 @@ process_use (tree stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n \n   def_bb = bb_for_stmt (def_stmt);\n   if (!flow_bb_inside_loop_p (loop, def_bb))\n-    return true;\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"def_stmt is out of loop.\");\n+      return true;\n+    }\n \n-  /* case 2: A reduction phi defining a reduction stmt (DEF_STMT). DEF_STMT \n-     must have already been processed, so we just check that everything is as \n-     expected, and we are done.  */\n+  /* case 2: A reduction phi (STMT) defined by a reduction stmt (DEF_STMT). \n+     DEF_STMT must have already been processed, because this should be the \n+     only way that STMT, which is a reduction-phi, was put in the worklist, \n+     as there should be no other uses for DEF_STMT in the loop.  So we just \n+     check that everything is as expected, and we are done.  */\n   dstmt_vinfo = vinfo_for_stmt (def_stmt);\n+  bb = bb_for_stmt (stmt);\n   if (TREE_CODE (stmt) == PHI_NODE\n       && STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def\n       && TREE_CODE (def_stmt) != PHI_NODE\n-      && STMT_VINFO_DEF_TYPE (dstmt_vinfo) == vect_reduction_def)\n+      && STMT_VINFO_DEF_TYPE (dstmt_vinfo) == vect_reduction_def\n+      && bb->loop_father == def_bb->loop_father)\n     {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"reduc-stmt defining reduc-phi in the same nest.\");\n       if (STMT_VINFO_IN_PATTERN_P (dstmt_vinfo))\n \tdstmt_vinfo = vinfo_for_stmt (STMT_VINFO_RELATED_STMT (dstmt_vinfo));\n       gcc_assert (STMT_VINFO_RELEVANT (dstmt_vinfo) < vect_used_by_reduction);\n@@ -2448,6 +2516,73 @@ process_use (tree stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n       return true;\n     }\n \n+  /* case 3a: outer-loop stmt defining an inner-loop stmt:\n+\touter-loop-header-bb:\n+\t\td = def_stmt\n+\tinner-loop:\n+\t\tstmt # use (d)\n+\touter-loop-tail-bb:\n+\t\t...\t\t  */\n+  if (flow_loop_nested_p (def_bb->loop_father, bb->loop_father))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"outer-loop def-stmt defining inner-loop stmt.\");\n+      switch (relevant)\n+\t{\n+\tcase vect_unused_in_loop:\n+\t  relevant = (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def) ?\n+\t\t\tvect_used_by_reduction : vect_unused_in_loop;\n+\t  break;\n+\tcase vect_used_in_outer_by_reduction:\n+\t  relevant = vect_used_by_reduction;\n+\t  break;\n+\tcase vect_used_in_outer:\n+\t  relevant = vect_used_in_loop;\n+\t  break;\n+\tcase vect_used_by_reduction: \n+\tcase vect_used_in_loop:\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}   \n+    }\n+\n+  /* case 3b: inner-loop stmt defining an outer-loop stmt:\n+\touter-loop-header-bb:\n+\t\t...\n+\tinner-loop:\n+\t\td = def_stmt\n+\touter-loop-tail-bb:\n+\t\tstmt # use (d)\t\t*/\n+  else if (flow_loop_nested_p (bb->loop_father, def_bb->loop_father))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"inner-loop def-stmt defining outer-loop stmt.\");\n+      switch (relevant)\n+        {\n+        case vect_unused_in_loop:\n+          relevant = (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def) ?\n+                        vect_used_in_outer_by_reduction : vect_unused_in_loop;\n+          break;\n+\n+        case vect_used_in_outer_by_reduction:\n+        case vect_used_in_outer:\n+          break;\n+\n+        case vect_used_by_reduction:\n+          relevant = vect_used_in_outer_by_reduction;\n+          break;\n+\n+        case vect_used_in_loop:\n+          relevant = vect_used_in_outer;\n+          break;\n+\n+        default:\n+          gcc_unreachable ();\n+        }\n+    }\n+\n   vect_mark_relevant (worklist, def_stmt, relevant, live_p);\n   return true;\n }\n@@ -2556,33 +2691,45 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t identify stmts that are used solely by a reduction, and therefore the \n \t order of the results that they produce does not have to be kept.\n \n-         Reduction phis are expected to be used by a reduction stmt;  Other \n-\t reduction stmts are expected to be unused in the loop.  These are the \n-\t expected values of \"relevant\" for reduction phis/stmts in the loop:\n+\t Reduction phis are expected to be used by a reduction stmt, or by\n+\t in an outer loop;  Other reduction stmts are expected to be\n+\t in the loop, and possibly used by a stmt in an outer loop. \n+\t Here are the expected values of \"relevant\" for reduction phis/stmts:\n \n \t relevance:\t\t\t\tphi\tstmt\n \t vect_unused_in_loop\t\t\t\tok\n+\t vect_used_in_outer_by_reduction\tok\tok\n+\t vect_used_in_outer\t\t\tok\tok\n \t vect_used_by_reduction\t\t\tok\n \t vect_used_in_loop \t\t\t\t\t\t  */\n \n       if (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def)\n         {\n-\t  switch (relevant)\n+\t  enum vect_relevant tmp_relevant = relevant;\n+\t  switch (tmp_relevant)\n \t    {\n \t    case vect_unused_in_loop:\n \t      gcc_assert (TREE_CODE (stmt) != PHI_NODE);\n+\t      relevant = vect_used_by_reduction;\n \t      break;\n+\n+\t    case vect_used_in_outer_by_reduction:\n+\t    case vect_used_in_outer:\n+\t      gcc_assert (TREE_CODE (stmt) != WIDEN_SUM_EXPR\n+\t\t\t  && TREE_CODE (stmt) != DOT_PROD_EXPR);\n+\t      break;\n+\n \t    case vect_used_by_reduction:\n \t      if (TREE_CODE (stmt) == PHI_NODE)\n \t\tbreak;\n+\t      /* fall through */\n \t    case vect_used_in_loop:\n \t    default:\n \t      if (vect_print_dump_info (REPORT_DETAILS))\n \t        fprintf (vect_dump, \"unsupported use of reduction.\");\n \t      VEC_free (tree, heap, worklist);\n \t      return false;\n \t    }\n-\t  relevant = vect_used_by_reduction;\n \t  live_p = false;\t\n \t}\n \n@@ -2724,11 +2871,39 @@ vect_get_loop_niters (struct loop *loop, tree *number_of_iterations)\n }\n \n \n+/* Function vect_analyze_loop_1.\n+\n+   Apply a set of analyses on LOOP, and create a loop_vec_info struct\n+   for it. The different analyses will record information in the\n+   loop_vec_info struct.  This is a subset of the analyses applied in\n+   vect_analyze_loop, to be applied on an inner-loop nested in the loop\n+   that is now considered for (outer-loop) vectorization.  */\n+\n+static loop_vec_info\n+vect_analyze_loop_1 (struct loop *loop)\n+{\n+  loop_vec_info loop_vinfo;\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"===== analyze_loop_nest_1 =====\");\n+\n+  /* Check the CFG characteristics of the loop (nesting, entry/exit, etc.  */\n+\n+  loop_vinfo = vect_analyze_loop_form (loop);\n+  if (!loop_vinfo)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"bad inner-loop form.\");\n+      return NULL;\n+    }\n+\n+  return loop_vinfo;\n+}\n+\n+\n /* Function vect_analyze_loop_form.\n \n-   Verify the following restrictions (some may be relaxed in the future):\n-   - it's an inner-most loop\n-   - number of BBs = 2 (which are the loop header and the latch)\n+   Verify that certain CFG restrictions hold, including:\n    - the loop has a pre-header\n    - the loop has a single entry and exit\n    - the loop exit condition is simple enough, and the number of iterations\n@@ -2740,31 +2915,134 @@ vect_analyze_loop_form (struct loop *loop)\n   loop_vec_info loop_vinfo;\n   tree loop_cond;\n   tree number_of_iterations = NULL;\n+  loop_vec_info inner_loop_vinfo = NULL;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_loop_form ===\");\n \n-  if (loop->inner)\n+  /* Different restrictions apply when we are considering an inner-most loop,\n+     vs. an outer (nested) loop.  \n+     (FORNOW. May want to relax some of these restrictions in the future).  */\n+\n+  if (!loop->inner)\n     {\n-      if (vect_print_dump_info (REPORT_OUTER_LOOPS))\n-        fprintf (vect_dump, \"not vectorized: nested loop.\");\n+      /* Inner-most loop.  We currently require that the number of BBs is \n+\t exactly 2 (the header and latch).  Vectorizable inner-most loops \n+\t look like this:\n+\n+                        (pre-header)\n+                           |\n+                          header <--------+\n+                           | |            |\n+                           | +--> latch --+\n+                           |\n+                        (exit-bb)  */\n+\n+      if (loop->num_nodes != 2)\n+        {\n+          if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n+            fprintf (vect_dump, \"not vectorized: too many BBs in loop.\");\n+          return NULL;\n+        }\n+\n+      if (empty_block_p (loop->header))\n+    {\n+          if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n+            fprintf (vect_dump, \"not vectorized: empty loop.\");\n       return NULL;\n     }\n+    }\n+  else\n+    {\n+      struct loop *innerloop = loop->inner;\n+      edge backedge, entryedge;\n+\n+      /* Nested loop. We currently require that the loop is doubly-nested,\n+\t contains a single inner loop, and the number of BBs is exactly 5. \n+\t Vectorizable outer-loops look like this:\n+\n+\t\t\t(pre-header)\n+\t\t\t   |\n+\t\t\t  header <---+\n+\t\t\t   |         |\n+\t\t          inner-loop |\n+\t\t\t   |         |\n+\t\t\t  tail ------+\n+\t\t\t   | \n+\t\t        (exit-bb)\n+\n+\t The inner-loop has the properties expected of inner-most loops\n+\t as described above.  */\n+\n+      if ((loop->inner)->inner || (loop->inner)->next)\n+\t{\n+\t  if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n+\t    fprintf (vect_dump, \"not vectorized: multiple nested loops.\");\n+\t  return NULL;\n+\t}\n+\n+      /* Analyze the inner-loop.  */\n+      inner_loop_vinfo = vect_analyze_loop_1 (loop->inner);\n+      if (!inner_loop_vinfo)\n+\t{\n+\t  if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n+            fprintf (vect_dump, \"not vectorized: Bad inner loop.\");\n+\t  return NULL;\n+\t}\n+\n+      if (!expr_invariant_in_loop_p (loop,\n+\t\t\t\t\tLOOP_VINFO_NITERS (inner_loop_vinfo)))\n+\t{\n+\t  if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n+\t    fprintf (vect_dump,\n+\t\t     \"not vectorized: inner-loop count not invariant.\");\n+\t  destroy_loop_vec_info (inner_loop_vinfo, true);\n+\t  return NULL;\n+\t}\n+\n+      if (loop->num_nodes != 5) \n+        {\n+\t  if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n+\t    fprintf (vect_dump, \"not vectorized: too many BBs in loop.\");\n+\t  destroy_loop_vec_info (inner_loop_vinfo, true);\n+\t  return NULL;\n+        }\n+\n+      gcc_assert (EDGE_COUNT (innerloop->header->preds) == 2);\n+      backedge = EDGE_PRED (innerloop->header, 1);\t  \n+      entryedge = EDGE_PRED (innerloop->header, 0);\n+      if (EDGE_PRED (innerloop->header, 0)->src == innerloop->latch)\n+\t{\n+\t  backedge = EDGE_PRED (innerloop->header, 0);\n+\t  entryedge = EDGE_PRED (innerloop->header, 1);\t\n+\t}\n+\t\n+      if (entryedge->src != loop->header\n+\t  || !single_exit (innerloop)\n+\t  || single_exit (innerloop)->dest !=  EDGE_PRED (loop->latch, 0)->src)\n+\t{\n+\t  if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n+\t    fprintf (vect_dump, \"not vectorized: unsupported outerloop form.\");\n+\t  destroy_loop_vec_info (inner_loop_vinfo, true);\n+\t  return NULL;\n+\t}\n+\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"Considering outer-loop vectorization.\");\n+    }\n   \n   if (!single_exit (loop) \n-      || loop->num_nodes != 2\n       || EDGE_COUNT (loop->header->preds) != 2)\n     {\n       if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n         {\n           if (!single_exit (loop))\n             fprintf (vect_dump, \"not vectorized: multiple exits.\");\n-          else if (loop->num_nodes != 2)\n-            fprintf (vect_dump, \"not vectorized: too many BBs in loop.\");\n           else if (EDGE_COUNT (loop->header->preds) != 2)\n             fprintf (vect_dump, \"not vectorized: too many incoming edges.\");\n         }\n-\n+      if (inner_loop_vinfo)\n+\tdestroy_loop_vec_info (inner_loop_vinfo, true);\n       return NULL;\n     }\n \n@@ -2777,6 +3055,8 @@ vect_analyze_loop_form (struct loop *loop)\n     {\n       if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n         fprintf (vect_dump, \"not vectorized: unexpected loop form.\");\n+      if (inner_loop_vinfo)\n+\tdestroy_loop_vec_info (inner_loop_vinfo, true);\n       return NULL;\n     }\n \n@@ -2794,22 +3074,19 @@ vect_analyze_loop_form (struct loop *loop)\n \t{\n \t  if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n \t    fprintf (vect_dump, \"not vectorized: abnormal loop exit edge.\");\n+\t  if (inner_loop_vinfo)\n+\t    destroy_loop_vec_info (inner_loop_vinfo, true);\n \t  return NULL;\n \t}\n     }\n \n-  if (empty_block_p (loop->header))\n-    {\n-      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n-        fprintf (vect_dump, \"not vectorized: empty loop.\");\n-      return NULL;\n-    }\n-\n   loop_cond = vect_get_loop_niters (loop, &number_of_iterations);\n   if (!loop_cond)\n     {\n       if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n \tfprintf (vect_dump, \"not vectorized: complicated exit condition.\");\n+      if (inner_loop_vinfo)\n+\tdestroy_loop_vec_info (inner_loop_vinfo, true);\n       return NULL;\n     }\n   \n@@ -2818,14 +3095,18 @@ vect_analyze_loop_form (struct loop *loop)\n       if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n \tfprintf (vect_dump, \n \t\t \"not vectorized: number of iterations cannot be computed.\");\n+      if (inner_loop_vinfo)\n+\tdestroy_loop_vec_info (inner_loop_vinfo, true);\n       return NULL;\n     }\n \n   if (chrec_contains_undetermined (number_of_iterations))\n     {\n       if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n         fprintf (vect_dump, \"Infinite number of iterations.\");\n-      return false;\n+      if (inner_loop_vinfo)\n+\tdestroy_loop_vec_info (inner_loop_vinfo, true);\n+      return NULL;\n     }\n \n   if (!NITERS_KNOWN_P (number_of_iterations))\n@@ -2840,12 +3121,19 @@ vect_analyze_loop_form (struct loop *loop)\n     {\n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n         fprintf (vect_dump, \"not vectorized: number of iterations = 0.\");\n+      if (inner_loop_vinfo)\n+        destroy_loop_vec_info (inner_loop_vinfo, false);\n       return NULL;\n     }\n \n   loop_vinfo = new_loop_vec_info (loop);\n   LOOP_VINFO_NITERS (loop_vinfo) = number_of_iterations;\n-  LOOP_VINFO_EXIT_COND (loop_vinfo) = loop_cond;\n+\n+  STMT_VINFO_TYPE (vinfo_for_stmt (loop_cond)) = loop_exit_ctrl_vec_info_type;\n+\n+  /* CHECKME: May want to keep it around it in the future.  */\n+  if (inner_loop_vinfo)\n+    destroy_loop_vec_info (inner_loop_vinfo, false);\n \n   gcc_assert (!loop->aux);\n   loop->aux = loop_vinfo;\n@@ -2867,6 +3155,15 @@ vect_analyze_loop (struct loop *loop)\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"===== analyze_loop_nest =====\");\n \n+  if (loop_outer (loop) \n+      && loop_vec_info_for_loop (loop_outer (loop))\n+      && LOOP_VINFO_VECTORIZABLE_P (loop_vec_info_for_loop (loop_outer (loop))))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"outer-loop already vectorized.\");\n+      return NULL;\n+    }\n+\n   /* Check the CFG characteristics of the loop (nesting, entry/exit, etc.  */\n \n   loop_vinfo = vect_analyze_loop_form (loop);\n@@ -2888,7 +3185,7 @@ vect_analyze_loop (struct loop *loop)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"bad data references.\");\n-      destroy_loop_vec_info (loop_vinfo);\n+      destroy_loop_vec_info (loop_vinfo, true);\n       return NULL;\n     }\n \n@@ -2906,7 +3203,7 @@ vect_analyze_loop (struct loop *loop)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"unexpected pattern.\");\n-      destroy_loop_vec_info (loop_vinfo);\n+      destroy_loop_vec_info (loop_vinfo, true);\n       return NULL;\n     }\n \n@@ -2918,7 +3215,7 @@ vect_analyze_loop (struct loop *loop)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"bad data alignment.\");\n-      destroy_loop_vec_info (loop_vinfo);\n+      destroy_loop_vec_info (loop_vinfo, true);\n       return NULL;\n     }\n \n@@ -2927,7 +3224,7 @@ vect_analyze_loop (struct loop *loop)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"can't determine vectorization factor.\");\n-      destroy_loop_vec_info (loop_vinfo);\n+      destroy_loop_vec_info (loop_vinfo, true);\n       return NULL;\n     }\n \n@@ -2939,7 +3236,7 @@ vect_analyze_loop (struct loop *loop)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"bad data dependence.\");\n-      destroy_loop_vec_info (loop_vinfo);\n+      destroy_loop_vec_info (loop_vinfo, true);\n       return NULL;\n     }\n \n@@ -2951,7 +3248,7 @@ vect_analyze_loop (struct loop *loop)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"bad data access.\");\n-      destroy_loop_vec_info (loop_vinfo);\n+      destroy_loop_vec_info (loop_vinfo, true);\n       return NULL;\n     }\n \n@@ -2963,7 +3260,7 @@ vect_analyze_loop (struct loop *loop)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"bad data alignment.\");\n-      destroy_loop_vec_info (loop_vinfo);\n+      destroy_loop_vec_info (loop_vinfo, true);\n       return NULL;\n     }\n \n@@ -2975,7 +3272,7 @@ vect_analyze_loop (struct loop *loop)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"bad operation or unsupported loop bound.\");\n-      destroy_loop_vec_info (loop_vinfo);\n+      destroy_loop_vec_info (loop_vinfo, true);\n       return NULL;\n     }\n "}, {"sha": "cfae6e026f4ebef498dfebbaec941904ec7f9e5e", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -148,7 +148,14 @@ widened_name_p (tree name, tree use_stmt, tree *half_type, tree *def_stmt)\n    * Return value: A new stmt that will be used to replace the sequence of\n    stmts that constitute the pattern. In this case it will be:\n         WIDEN_DOT_PRODUCT <x_t, y_t, sum_0>\n-*/\n+\n+   Note: The dot-prod idiom is a widening reduction pattern that is\n+         vectorized without preserving all the intermediate results. It\n+         produces only N/2 (widened) results (by summing up pairs of\n+         intermediate results) rather than all N results.  Therefore, we\n+         cannot allow this pattern when we want to get all the results and in\n+         the correct order (as is the case when this computation is in an\n+         inner-loop nested in an outer-loop that us being vectorized).  */\n \n static tree\n vect_recog_dot_prod_pattern (tree last_stmt, tree *type_in, tree *type_out)\n@@ -160,6 +167,8 @@ vect_recog_dot_prod_pattern (tree last_stmt, tree *type_in, tree *type_out)\n   tree type, half_type;\n   tree pattern_expr;\n   tree prod_type;\n+  loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_info);\n \n   if (TREE_CODE (last_stmt) != GIMPLE_MODIFY_STMT)\n     return NULL;\n@@ -242,6 +251,10 @@ vect_recog_dot_prod_pattern (tree last_stmt, tree *type_in, tree *type_out)\n   gcc_assert (stmt_vinfo);\n   if (STMT_VINFO_DEF_TYPE (stmt_vinfo) != vect_loop_def)\n     return NULL;\n+  /* FORNOW. Can continue analyzing the def-use chain when this stmt in a phi \n+     inside the loop (in case we are analyzing an outer-loop).  */\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n+    return NULL; \n   expr = GIMPLE_STMT_OPERAND (stmt, 1);\n   if (TREE_CODE (expr) != MULT_EXPR)\n     return NULL;\n@@ -295,6 +308,16 @@ vect_recog_dot_prod_pattern (tree last_stmt, tree *type_in, tree *type_out)\n       fprintf (vect_dump, \"vect_recog_dot_prod_pattern: detected: \");\n       print_generic_expr (vect_dump, pattern_expr, TDF_SLIM);\n     }\n+\n+  /* We don't allow changing the order of the computation in the inner-loop\n+     when doing outer-loop vectorization.  */\n+  if (nested_in_vect_loop_p (loop, last_stmt))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"vect_recog_dot_prod_pattern: not allowed.\");\n+      return NULL;\n+    }\n+\n   return pattern_expr;\n }\n \n@@ -521,7 +544,14 @@ vect_recog_pow_pattern (tree last_stmt, tree *type_in, tree *type_out)\n    * Return value: A new stmt that will be used to replace the sequence of\n    stmts that constitute the pattern. In this case it will be:\n         WIDEN_SUM <x_t, sum_0>\n-*/\n+\n+   Note: The widneing-sum idiom is a widening reduction pattern that is \n+\t vectorized without preserving all the intermediate results. It\n+         produces only N/2 (widened) results (by summing up pairs of \n+\t intermediate results) rather than all N results.  Therefore, we \n+\t cannot allow this pattern when we want to get all the results and in \n+\t the correct order (as is the case when this computation is in an \n+\t inner-loop nested in an outer-loop that us being vectorized).  */\n \n static tree\n vect_recog_widen_sum_pattern (tree last_stmt, tree *type_in, tree *type_out)\n@@ -531,6 +561,8 @@ vect_recog_widen_sum_pattern (tree last_stmt, tree *type_in, tree *type_out)\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n   tree type, half_type;\n   tree pattern_expr;\n+  loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_info);\n \n   if (TREE_CODE (last_stmt) != GIMPLE_MODIFY_STMT)\n     return NULL;\n@@ -580,6 +612,16 @@ vect_recog_widen_sum_pattern (tree last_stmt, tree *type_in, tree *type_out)\n       fprintf (vect_dump, \"vect_recog_widen_sum_pattern: detected: \");\n       print_generic_expr (vect_dump, pattern_expr, TDF_SLIM);\n     }\n+\n+  /* We don't allow changing the order of the computation in the inner-loop\n+     when doing outer-loop vectorization.  */\n+  if (nested_in_vect_loop_p (loop, last_stmt))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"vect_recog_widen_sum_pattern: not allowed.\");\n+      return NULL;\n+    }\n+\n   return pattern_expr;\n }\n "}, {"sha": "6e88fa976344e1f44767f016d85de5b9a4c9841d", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 356, "deletions": 80, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -124,6 +124,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n   int nbbs = loop->num_nodes;\n   int byte_misalign;\n+  int innerloop_iters, factor;\n \n   /* Cost model disabled.  */\n   if (!flag_vect_cost_model)\n@@ -152,20 +153,31 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n      TODO: Consider assigning different costs to different scalar\n      statements.  */\n \n+  /* FORNOW.  */\n+  if (loop->inner)\n+    innerloop_iters = 50; /* FIXME */\n+\n   for (i = 0; i < nbbs; i++)\n     {\n       block_stmt_iterator si;\n       basic_block bb = bbs[i];\n \n+      if (bb->loop_father == loop->inner)\n+ \tfactor = innerloop_iters;\n+      else\n+ \tfactor = 1;\n+\n       for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n         {\n           tree stmt = bsi_stmt (si);\n           stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n           if (!STMT_VINFO_RELEVANT_P (stmt_info)\n               && !STMT_VINFO_LIVE_P (stmt_info))\n             continue;\n-          scalar_single_iter_cost += cost_for_stmt (stmt);\n-          vec_inside_cost += STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info);\n+          scalar_single_iter_cost += cost_for_stmt (stmt) * factor;\n+          vec_inside_cost += STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) * factor;\n+\t  /* FIXME: for stmts in the inner-loop in outer-loop vectorization,\n+\t     some of the \"outside\" costs are generated inside the outer-loop.  */\n           vec_outside_cost += STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info);\n         }\n     }\n@@ -1071,6 +1083,9 @@ vect_init_vector (tree stmt, tree vector_var, tree vector_type)\n   tree new_temp;\n   basic_block new_bb;\n  \n+  if (nested_in_vect_loop_p (loop, stmt))\n+    loop = loop->inner;\n+\n   new_var = vect_get_new_vect_var (vector_type, vect_simple_var, \"cst_\");\n   add_referenced_var (new_var); \n  \n@@ -1096,6 +1111,7 @@ vect_init_vector (tree stmt, tree vector_var, tree vector_type)\n /* Function get_initial_def_for_induction\n \n    Input:\n+   STMT - a stmt that performs an induction operation in the loop.\n    IV_PHI - the initial value of the induction variable\n \n    Output:\n@@ -1114,8 +1130,8 @@ get_initial_def_for_induction (tree iv_phi)\n   tree vectype = get_vectype_for_scalar_type (scalar_type);\n   int nunits =  TYPE_VECTOR_SUBPARTS (vectype);\n   edge pe = loop_preheader_edge (loop);\n+  struct loop *iv_loop;\n   basic_block new_bb;\n-  block_stmt_iterator bsi;\n   tree vec, vec_init, vec_step, t;\n   tree access_fn;\n   tree new_var;\n@@ -1129,8 +1145,13 @@ get_initial_def_for_induction (tree iv_phi)\n   int ncopies = vf / nunits;\n   tree expr;\n   stmt_vec_info phi_info = vinfo_for_stmt (iv_phi);\n+  bool nested_in_vect_loop = false;\n   tree stmts;\n-  tree stmt = NULL_TREE;\n+  imm_use_iterator imm_iter;\n+  use_operand_p use_p;\n+  tree exit_phi;\n+  edge latch_e;\n+  tree loop_arg;\n   block_stmt_iterator si;\n   basic_block bb = bb_for_stmt (iv_phi);\n \n@@ -1139,65 +1160,107 @@ get_initial_def_for_induction (tree iv_phi)\n \n   /* Find the first insertion point in the BB.  */\n   si = bsi_after_labels (bb);\n-  stmt = bsi_stmt (si);\n \n-  access_fn = analyze_scalar_evolution (loop, PHI_RESULT (iv_phi));\n+  if (INTEGRAL_TYPE_P (scalar_type))\n+    step_expr = build_int_cst (scalar_type, 0);\n+  else\n+    step_expr = build_real (scalar_type, dconst0);\n+\n+  /* Is phi in an inner-loop, while vectorizing an enclosing outer-loop?  */\n+  if (nested_in_vect_loop_p (loop, iv_phi))\n+    {\n+      nested_in_vect_loop = true;\n+      iv_loop = loop->inner;\n+    }\n+  else\n+    iv_loop = loop;\n+  gcc_assert (iv_loop == (bb_for_stmt (iv_phi))->loop_father);\n+\n+  latch_e = loop_latch_edge (iv_loop);\n+  loop_arg = PHI_ARG_DEF_FROM_EDGE (iv_phi, latch_e);\n+\n+  access_fn = analyze_scalar_evolution (iv_loop, PHI_RESULT (iv_phi));\n   gcc_assert (access_fn);\n-  ok = vect_is_simple_iv_evolution (loop->num, access_fn,\n-\t\t\t\t    &init_expr, &step_expr);\n+  ok = vect_is_simple_iv_evolution (iv_loop->num, access_fn,\n+                                  &init_expr, &step_expr);\n   gcc_assert (ok);\n+  pe = loop_preheader_edge (iv_loop);\n \n   /* Create the vector that holds the initial_value of the induction.  */\n-  new_var = vect_get_new_vect_var (scalar_type, vect_scalar_var, \"var_\");\n-  add_referenced_var (new_var);\n-\n-  new_name = force_gimple_operand (init_expr, &stmts, false, new_var);\n-  if (stmts)\n+  if (nested_in_vect_loop)\n     {\n-      new_bb = bsi_insert_on_edge_immediate (pe, stmts);\n-      gcc_assert (!new_bb);\n+      /* iv_loop is nested in the loop to be vectorized.  init_expr had already\n+\t been created during vectorization of previous stmts; We obtain it from\n+\t the STMT_VINFO_VEC_STMT of the defining stmt. */\n+      tree iv_def = PHI_ARG_DEF_FROM_EDGE (iv_phi, loop_preheader_edge (iv_loop));\n+      vec_init = vect_get_vec_def_for_operand (iv_def, iv_phi, NULL);\n     }\n-\n-  t = NULL_TREE;\n-  t = tree_cons (NULL_TREE, new_name, t);\n-  for (i = 1; i < nunits; i++)\n+  else\n     {\n-      tree tmp;\n+      /* iv_loop is the loop to be vectorized. Create:\n+\t vec_init = [X, X+S, X+2*S, X+3*S] (S = step_expr, X = init_expr)  */\n+      new_var = vect_get_new_vect_var (scalar_type, vect_scalar_var, \"var_\");\n+      add_referenced_var (new_var);\n \n-      /* Create: new_name = new_name + step_expr  */\n-      tmp = fold_build2 (PLUS_EXPR, scalar_type, new_name, step_expr);\n-      init_stmt = build_gimple_modify_stmt (new_var, tmp);\n-      new_name = make_ssa_name (new_var, init_stmt);\n-      GIMPLE_STMT_OPERAND (init_stmt, 0) = new_name;\n+      new_name = force_gimple_operand (init_expr, &stmts, false, new_var);\n+      if (stmts)\n+\t{\n+\t  new_bb = bsi_insert_on_edge_immediate (pe, stmts);\n+\t  gcc_assert (!new_bb);\n+\t}\n \n-      new_bb = bsi_insert_on_edge_immediate (pe, init_stmt);\n-      gcc_assert (!new_bb);\n+      t = NULL_TREE;\n+      t = tree_cons (NULL_TREE, init_expr, t);\n+      for (i = 1; i < nunits; i++)\n+\t{\n+\t  tree tmp;\n \n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        {\n-          fprintf (vect_dump, \"created new init_stmt: \");\n-          print_generic_expr (vect_dump, init_stmt, TDF_SLIM);\n-        }\n-      t = tree_cons (NULL_TREE, new_name, t);\n+\t  /* Create: new_name_i = new_name + step_expr  */\n+\t  tmp = fold_build2 (PLUS_EXPR, scalar_type, new_name, step_expr);\n+\t  init_stmt = build_gimple_modify_stmt (new_var, tmp);\n+\t  new_name = make_ssa_name (new_var, init_stmt);\n+\t  GIMPLE_STMT_OPERAND (init_stmt, 0) = new_name;\n+\n+\t  new_bb = bsi_insert_on_edge_immediate (pe, init_stmt);\n+\t  gcc_assert (!new_bb);\n+\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    {\n+\t      fprintf (vect_dump, \"created new init_stmt: \");\n+\t      print_generic_expr (vect_dump, init_stmt, TDF_SLIM);\n+\t    }\n+\t  t = tree_cons (NULL_TREE, new_name, t);\n+\t}\n+      /* Create a vector from [new_name_0, new_name_1, ..., new_name_nunits-1]  */\n+      vec = build_constructor_from_list (vectype, nreverse (t));\n+      vec_init = vect_init_vector (iv_phi, vec, vectype);\n     }\n-  vec = build_constructor_from_list (vectype, nreverse (t));\n-  vec_init = vect_init_vector (stmt, vec, vectype);\n \n \n   /* Create the vector that holds the step of the induction.  */\n-  expr = build_int_cst (scalar_type, vf);\n-  new_name = fold_build2 (MULT_EXPR, scalar_type, expr, step_expr);\n+  if (nested_in_vect_loop)\n+    /* iv_loop is nested in the loop to be vectorized. Generate:\n+       vec_step = [S, S, S, S]  */\n+    new_name = step_expr;\n+  else\n+    {\n+      /* iv_loop is the loop to be vectorized. Generate:\n+\t  vec_step = [VF*S, VF*S, VF*S, VF*S]  */\n+      expr = build_int_cst (scalar_type, vf);\n+      new_name = fold_build2 (MULT_EXPR, scalar_type, expr, step_expr);\n+    }\n+\n   t = NULL_TREE;\n   for (i = 0; i < nunits; i++)\n     t = tree_cons (NULL_TREE, unshare_expr (new_name), t);\n   vec = build_constructor_from_list (vectype, t);\n-  vec_step = vect_init_vector (stmt, vec, vectype);\n+  vec_step = vect_init_vector (iv_phi, vec, vectype);\n \n \n   /* Create the following def-use cycle:\n      loop prolog:\n-         vec_init = [X, X+S, X+2*S, X+3*S]\n-\t vec_step = [VF*S, VF*S, VF*S, VF*S]\n+         vec_init = ...\n+\t vec_step = ...\n      loop:\n          vec_iv = PHI <vec_init, vec_loop>\n          ...\n@@ -1208,7 +1271,7 @@ get_initial_def_for_induction (tree iv_phi)\n   /* Create the induction-phi that defines the induction-operand.  */\n   vec_dest = vect_get_new_vect_var (vectype, vect_simple_var, \"vec_iv_\");\n   add_referenced_var (vec_dest);\n-  induction_phi = create_phi_node (vec_dest, loop->header);\n+  induction_phi = create_phi_node (vec_dest, iv_loop->header);\n   set_stmt_info (get_stmt_ann (induction_phi),\n                  new_stmt_vec_info (induction_phi, loop_vinfo));\n   induc_def = PHI_RESULT (induction_phi);\n@@ -1219,15 +1282,16 @@ get_initial_def_for_induction (tree iv_phi)\n \t\t\t\t\t       induc_def, vec_step));\n   vec_def = make_ssa_name (vec_dest, new_stmt);\n   GIMPLE_STMT_OPERAND (new_stmt, 0) = vec_def;\n-  bsi = bsi_for_stmt (stmt);\n-  vect_finish_stmt_generation (stmt, new_stmt, &bsi);\n+  bsi_insert_before (&si, new_stmt, BSI_SAME_STMT);\n+  set_stmt_info (get_stmt_ann (new_stmt),\n+\t\t new_stmt_vec_info (new_stmt, loop_vinfo));\n \n   /* Set the arguments of the phi node:  */\n-  add_phi_arg (induction_phi, vec_init, loop_preheader_edge (loop));\n-  add_phi_arg (induction_phi, vec_def, loop_latch_edge (loop));\n+  add_phi_arg (induction_phi, vec_init, pe);\n+  add_phi_arg (induction_phi, vec_def, loop_latch_edge (iv_loop));\n \n \n-  /* In case the vectorization factor (VF) is bigger than the number\n+  /* In case that vectorization factor (VF) is bigger than the number\n      of elements that we can fit in a vectype (nunits), we have to generate\n      more than one vector stmt - i.e - we need to \"unroll\" the\n      vector stmt by a factor VF/nunits.  For more details see documentation\n@@ -1236,6 +1300,8 @@ get_initial_def_for_induction (tree iv_phi)\n   if (ncopies > 1)\n     {\n       stmt_vec_info prev_stmt_vinfo;\n+      /* FORNOW. This restriction should be relaxed.  */\n+      gcc_assert (!nested_in_vect_loop);\n \n       /* Create the vector that holds the step of the induction.  */\n       expr = build_int_cst (scalar_type, nunits);\n@@ -1244,27 +1310,58 @@ get_initial_def_for_induction (tree iv_phi)\n       for (i = 0; i < nunits; i++)\n \tt = tree_cons (NULL_TREE, unshare_expr (new_name), t);\n       vec = build_constructor_from_list (vectype, t);\n-      vec_step = vect_init_vector (stmt, vec, vectype);\n+      vec_step = vect_init_vector (iv_phi, vec, vectype);\n \n       vec_def = induc_def;\n       prev_stmt_vinfo = vinfo_for_stmt (induction_phi);\n       for (i = 1; i < ncopies; i++)\n \t{\n \t  tree tmp;\n \n-\t  /* vec_i = vec_prev + vec_{step*nunits}  */\n+\t  /* vec_i = vec_prev + vec_step  */\n \t  tmp = build2 (PLUS_EXPR, vectype, vec_def, vec_step);\n \t  new_stmt = build_gimple_modify_stmt (NULL_TREE, tmp);\n \t  vec_def = make_ssa_name (vec_dest, new_stmt);\n \t  GIMPLE_STMT_OPERAND (new_stmt, 0) = vec_def;\n-\t  bsi = bsi_for_stmt (stmt);\n-\t  vect_finish_stmt_generation (stmt, new_stmt, &bsi);\n-\n+\t  bsi_insert_before (&si, new_stmt, BSI_SAME_STMT);\n+\t  set_stmt_info (get_stmt_ann (new_stmt),\n+\t\t\t new_stmt_vec_info (new_stmt, loop_vinfo));\n \t  STMT_VINFO_RELATED_STMT (prev_stmt_vinfo) = new_stmt;\n \t  prev_stmt_vinfo = vinfo_for_stmt (new_stmt); \n \t}\n     }\n \n+  if (nested_in_vect_loop)\n+    {\n+      /* Find the loop-closed exit-phi of the induction, and record\n+         the final vector of induction results:  */\n+      exit_phi = NULL;\n+      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, loop_arg)\n+        {\n+\t  if (!flow_bb_inside_loop_p (iv_loop, bb_for_stmt (USE_STMT (use_p))))\n+\t    {\n+\t      exit_phi = USE_STMT (use_p);\n+\t      break;\n+\t    }\n+        }\n+      if (exit_phi) \n+\t{\n+\t  stmt_vec_info stmt_vinfo = vinfo_for_stmt (exit_phi);\n+\t  /* FORNOW. Currently not supporting the case that an inner-loop induction\n+\t     is not used in the outer-loop (i.e. only outside the outer-loop).  */\n+\t  gcc_assert (STMT_VINFO_RELEVANT_P (stmt_vinfo)\n+\t\t      && !STMT_VINFO_LIVE_P (stmt_vinfo));\n+\n+\t  STMT_VINFO_VEC_STMT (stmt_vinfo) = new_stmt;\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    {\n+\t      fprintf (vect_dump, \"vector of inductions after inner-loop:\");\n+\t      print_generic_expr (vect_dump, new_stmt, TDF_SLIM);\n+\t    }\n+\t}\n+    }\n+\n+\n   if (vect_print_dump_info (REPORT_DETAILS))\n     {\n       fprintf (vect_dump, \"transform induction: created def-use cycle:\");\n@@ -1300,7 +1397,6 @@ vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n   tree vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n   int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree vec_inv;\n   tree vec_cst;\n   tree t = NULL_TREE;\n@@ -1386,14 +1482,20 @@ vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n         def_stmt_info = vinfo_for_stmt (def_stmt);\n         vec_stmt = STMT_VINFO_VEC_STMT (def_stmt_info);\n         gcc_assert (vec_stmt);\n-        vec_oprnd = GIMPLE_STMT_OPERAND (vec_stmt, 0);\n+\tif (TREE_CODE (vec_stmt) == PHI_NODE)\n+\t  vec_oprnd = PHI_RESULT (vec_stmt);\n+\telse\n+\t  vec_oprnd = GIMPLE_STMT_OPERAND (vec_stmt, 0);\n         return vec_oprnd;\n       }\n \n     /* Case 4: operand is defined by a loop header phi - reduction  */\n     case vect_reduction_def:\n       {\n+\tstruct loop *loop;\n+\n         gcc_assert (TREE_CODE (def_stmt) == PHI_NODE);\n+\tloop = (bb_for_stmt (def_stmt))->loop_father; \n \n         /* Get the def before the loop  */\n         op = PHI_ARG_DEF_FROM_EDGE (def_stmt, loop_preheader_edge (loop));\n@@ -1405,8 +1507,12 @@ vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n       {\n \tgcc_assert (TREE_CODE (def_stmt) == PHI_NODE);\n \n-\t/* Get the def before the loop  */\n-\treturn get_initial_def_for_induction (def_stmt);\n+        /* Get the def from the vectorized stmt.  */\n+        def_stmt_info = vinfo_for_stmt (def_stmt);\n+        vec_stmt = STMT_VINFO_VEC_STMT (def_stmt_info);\n+        gcc_assert (vec_stmt && (TREE_CODE (vec_stmt) == PHI_NODE));\n+        vec_oprnd = PHI_RESULT (vec_stmt);\n+        return vec_oprnd;\n       }\n \n     default:\n@@ -1487,7 +1593,6 @@ vect_get_vec_def_for_stmt_copy (enum vect_def_type dt, tree vec_oprnd)\n   vec_stmt_for_operand = STMT_VINFO_RELATED_STMT (def_stmt_info);\n   gcc_assert (vec_stmt_for_operand);\n   vec_oprnd = GIMPLE_STMT_OPERAND (vec_stmt_for_operand, 0);\n-\n   return vec_oprnd;\n }\n \n@@ -1503,7 +1608,11 @@ vect_finish_stmt_generation (tree stmt, tree vec_stmt,\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n \n+  gcc_assert (stmt == bsi_stmt (*bsi));\n+  gcc_assert (TREE_CODE (stmt) != LABEL_EXPR);\n+\n   bsi_insert_before (bsi, vec_stmt, BSI_SAME_STMT);\n+\n   set_stmt_info (get_stmt_ann (vec_stmt), \n \t\t new_stmt_vec_info (vec_stmt, loop_vinfo)); \n \n@@ -1571,6 +1680,8 @@ static tree\n get_initial_def_for_reduction (tree stmt, tree init_val, tree *adjustment_def)\n {\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n   int nunits =  TYPE_VECTOR_SUBPARTS (vectype);\n   enum tree_code code = TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1));\n@@ -1581,16 +1692,25 @@ get_initial_def_for_reduction (tree stmt, tree init_val, tree *adjustment_def)\n   tree t = NULL_TREE;\n   int i;\n   tree vector_type;\n+  bool nested_in_vect_loop = false; \n \n   gcc_assert (INTEGRAL_TYPE_P (type) || SCALAR_FLOAT_TYPE_P (type));\n+  if (nested_in_vect_loop_p (loop, stmt))\n+    nested_in_vect_loop = true;\n+  else\n+    gcc_assert (loop == (bb_for_stmt (stmt))->loop_father);\n+\n   vecdef = vect_get_vec_def_for_operand (init_val, stmt, NULL);\n \n   switch (code)\n   {\n   case WIDEN_SUM_EXPR:\n   case DOT_PROD_EXPR:\n   case PLUS_EXPR:\n-    *adjustment_def = init_val;\n+      if (nested_in_vect_loop)\n+\t*adjustment_def = vecdef;\n+      else\n+\t*adjustment_def = init_val;\n     /* Create a vector of zeros for init_def.  */\n     if (INTEGRAL_TYPE_P (type))\n       def_for_init = build_int_cst (type, 0);\n@@ -1679,24 +1799,31 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n   tree new_phi;\n   block_stmt_iterator exit_bsi;\n   tree vec_dest;\n-  tree new_temp;\n+  tree new_temp = NULL_TREE;\n   tree new_name;\n-  tree epilog_stmt;\n-  tree new_scalar_dest, exit_phi;\n+  tree epilog_stmt = NULL_TREE;\n+  tree new_scalar_dest, exit_phi, new_dest;\n   tree bitsize, bitpos, bytesize; \n   enum tree_code code = TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1));\n-  tree scalar_initial_def;\n+  tree adjustment_def;\n   tree vec_initial_def;\n   tree orig_name;\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n-  bool extract_scalar_result;\n-  tree reduction_op;\n+  bool extract_scalar_result = false;\n+  tree reduction_op, expr;\n   tree orig_stmt;\n   tree use_stmt;\n   tree operation = GIMPLE_STMT_OPERAND (stmt, 1);\n+  bool nested_in_vect_loop = false;\n   int op_type;\n   \n+  if (nested_in_vect_loop_p (loop, stmt))\n+    {\n+      loop = loop->inner;\n+      nested_in_vect_loop = true;\n+    }\n+  \n   op_type = TREE_OPERAND_LENGTH (operation);\n   reduction_op = TREE_OPERAND (operation, op_type-1);\n   vectype = get_vectype_for_scalar_type (TREE_TYPE (reduction_op));\n@@ -1709,7 +1836,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n      the scalar def before the loop, that defines the initial value\n      of the reduction variable.  */\n   vec_initial_def = vect_get_vec_def_for_operand (reduction_op, stmt,\n-\t\t\t\t\t\t  &scalar_initial_def);\n+\t\t\t\t\t\t  &adjustment_def);\n   add_phi_arg (reduction_phi, vec_initial_def, loop_preheader_edge (loop));\n \n   /* 1.2 set the loop-latch arg for the reduction-phi:  */\n@@ -1788,6 +1915,15 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n   bitsize = TYPE_SIZE (scalar_type);\n   bytesize = TYPE_SIZE_UNIT (scalar_type);\n \n+\n+  /* In case this is a reduction in an inner-loop while vectorizing an outer\n+     loop - we don't need to extract a single scalar result at the end of the\n+     inner-loop.  The final vector of partial results will be used in the\n+     vectorized outer-loop, or reduced to a scalar result at the end of the\n+     outer-loop.  */\n+  if (nested_in_vect_loop)\n+    goto vect_finalize_reduction;\n+\n   /* 2.3 Create the reduction code, using one of the three schemes described\n          above.  */\n \n@@ -1934,6 +2070,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n     {\n       tree rhs;\n \n+      gcc_assert (!nested_in_vect_loop);\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"extract scalar result\");\n \n@@ -1952,25 +2089,42 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n       bsi_insert_before (&exit_bsi, epilog_stmt, BSI_SAME_STMT);\n     }\n \n-  /* 2.4 Adjust the final result by the initial value of the reduction\n+vect_finalize_reduction:\n+\n+  /* 2.5 Adjust the final result by the initial value of the reduction\n \t variable. (When such adjustment is not needed, then\n-\t 'scalar_initial_def' is zero).\n+\t 'adjustment_def' is zero).  For example, if code is PLUS we create:\n+\t new_temp = loop_exit_def + adjustment_def  */\n \n-\t Create: \n-\t s_out4 = scalar_expr <s_out3, scalar_initial_def>  */\n-  \n-  if (scalar_initial_def)\n+  if (adjustment_def)\n     {\n-      tree tmp = build2 (code, scalar_type, new_temp, scalar_initial_def);\n-      epilog_stmt = build_gimple_modify_stmt (new_scalar_dest, tmp);\n-      new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n+      if (nested_in_vect_loop)\n+\t{\n+\t  gcc_assert (TREE_CODE (TREE_TYPE (adjustment_def)) == VECTOR_TYPE);\n+\t  expr = build2 (code, vectype, PHI_RESULT (new_phi), adjustment_def);\n+\t  new_dest = vect_create_destination_var (scalar_dest, vectype);\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (TREE_CODE (TREE_TYPE (adjustment_def)) != VECTOR_TYPE);\n+\t  expr = build2 (code, scalar_type, new_temp, adjustment_def);\n+\t  new_dest = vect_create_destination_var (scalar_dest, scalar_type);\n+\t}\n+      epilog_stmt = build_gimple_modify_stmt (new_dest, expr);\n+      new_temp = make_ssa_name (new_dest, epilog_stmt);\n       GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_temp;\n+#if 0\n+      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n+#else\n       bsi_insert_before (&exit_bsi, epilog_stmt, BSI_SAME_STMT);\n+#endif\n     }\n \n-  /* 2.6 Replace uses of s_out0 with uses of s_out3  */\n \n-  /* Find the loop-closed-use at the loop exit of the original scalar result.  \n+  /* 2.6  Handle the loop-exit phi  */\n+\n+  /* Replace uses of s_out0 with uses of s_out3:\n+     Find the loop-closed-use at the loop exit of the original scalar result.\n      (The reduction result is expected to have two immediate uses - one at the \n      latch block, and one at the loop exit).  */\n   exit_phi = NULL;\n@@ -1984,6 +2138,29 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n     }\n   /* We expect to have found an exit_phi because of loop-closed-ssa form.  */\n   gcc_assert (exit_phi);\n+\n+  if (nested_in_vect_loop)\n+    {\n+      stmt_vec_info stmt_vinfo = vinfo_for_stmt (exit_phi);\n+\n+      /* FORNOW. Currently not supporting the case that an inner-loop reduction\n+\t is not used in the outer-loop (but only outside the outer-loop).  */\n+      gcc_assert (STMT_VINFO_RELEVANT_P (stmt_vinfo) \n+\t\t  && !STMT_VINFO_LIVE_P (stmt_vinfo));\n+\n+      epilog_stmt = adjustment_def ? epilog_stmt :  new_phi;\n+      STMT_VINFO_VEC_STMT (stmt_vinfo) = epilog_stmt;\n+      set_stmt_info (get_stmt_ann (epilog_stmt),\n+                     new_stmt_vec_info (epilog_stmt, loop_vinfo));\n+\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        {\n+          fprintf (vect_dump, \"vector of partial results after inner-loop:\");\n+          print_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n+        }\n+      return;\n+    }\n+\n   /* Replace the uses:  */\n   orig_name = PHI_RESULT (exit_phi);\n   FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, orig_name)\n@@ -2065,15 +2242,30 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   tree new_stmt = NULL_TREE;\n   int j;\n \n+  if (nested_in_vect_loop_p (loop, stmt))\n+    {\n+      loop = loop->inner;\n+      /* FORNOW. This restriction should be relaxed.  */\n+      if (ncopies > 1)\n+\t{\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    fprintf (vect_dump, \"multiple types in nested loop.\");\n+\t  return false;\n+\t}\n+    }\n+\n   gcc_assert (ncopies >= 1);\n \n   /* 1. Is vectorizable reduction?  */\n \n   /* Not supportable if the reduction variable is used in the loop.  */\n-  if (STMT_VINFO_RELEVANT_P (stmt_info))\n+  if (STMT_VINFO_RELEVANT (stmt_info) > vect_used_in_outer)\n     return false;\n \n-  if (!STMT_VINFO_LIVE_P (stmt_info))\n+  /* Reductions that are not used even in an enclosing outer-loop,\n+     are expected to be \"live\" (used out of the loop).  */\n+  if (STMT_VINFO_RELEVANT (stmt_info) == vect_unused_in_loop\n+      && !STMT_VINFO_LIVE_P (stmt_info))\n     return false;\n \n   /* Make sure it was already recognized as a reduction computation.  */\n@@ -2130,9 +2322,9 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   gcc_assert (dt == vect_reduction_def);\n   gcc_assert (TREE_CODE (def_stmt) == PHI_NODE);\n   if (orig_stmt) \n-    gcc_assert (orig_stmt == vect_is_simple_reduction (loop, def_stmt));\n+    gcc_assert (orig_stmt == vect_is_simple_reduction (loop_vinfo, def_stmt));\n   else\n-    gcc_assert (stmt == vect_is_simple_reduction (loop, def_stmt));\n+    gcc_assert (stmt == vect_is_simple_reduction (loop_vinfo, def_stmt));\n   \n   if (STMT_VINFO_LIVE_P (vinfo_for_stmt (def_stmt)))\n     return false;\n@@ -2357,6 +2549,7 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   int nunits_in;\n   int nunits_out;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree fndecl, rhs, new_temp, def, def_stmt, rhs_type, lhs_type;\n   enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n   tree new_stmt;\n@@ -2466,6 +2659,14 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n      needs to be generated.  */\n   gcc_assert (ncopies >= 1);\n \n+  /* FORNOW. This restriction should be relaxed.  */\n+  if (nested_in_vect_loop_p (loop, stmt) && ncopies > 1)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+      fprintf (vect_dump, \"multiple types in nested loop.\");\n+      return false;\n+    }\n+\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = call_vec_info_type;\n@@ -2480,6 +2681,14 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"transform operation.\");\n \n+  /* FORNOW. This restriction should be relaxed.  */\n+  if (nested_in_vect_loop_p (loop, stmt) && ncopies > 1)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"multiple types in nested loop.\");\n+      return false;\n+    }\n+\n   /* Handle def.  */\n   scalar_dest = GIMPLE_STMT_OPERAND (stmt, 0);\n   vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n@@ -2671,6 +2880,7 @@ vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n   tree vec_oprnd0 = NULL_TREE, vec_oprnd1 = NULL_TREE;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   enum tree_code code, code1 = ERROR_MARK, code2 = ERROR_MARK;\n   tree decl1 = NULL_TREE, decl2 = NULL_TREE;\n   tree new_temp;\n@@ -2752,6 +2962,14 @@ vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n      needs to be generated.  */\n   gcc_assert (ncopies >= 1);\n \n+  /* FORNOW. This restriction should be relaxed.  */\n+  if (nested_in_vect_loop_p (loop, stmt) && ncopies > 1)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+      fprintf (vect_dump, \"multiple types in nested loop.\");\n+      return false;\n+    }\n+\n   /* Check the operands of the operation.  */\n   if (!vect_is_simple_use (op0, loop_vinfo, &def_stmt, &def, &dt0))\n     {\n@@ -3093,6 +3311,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   enum tree_code code;\n   enum machine_mode vec_mode;\n   tree new_temp;\n@@ -3111,6 +3330,13 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   int j;\n \n   gcc_assert (ncopies >= 1);\n+  /* FORNOW. This restriction should be relaxed.  */\n+  if (nested_in_vect_loop_p (loop, stmt) && ncopies > 1)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"multiple types in nested loop.\");\n+      return false;\n+    }\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n@@ -3373,6 +3599,7 @@ vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n   tree vec_oprnd0=NULL, vec_oprnd1=NULL;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   enum tree_code code, code1 = ERROR_MARK;\n   tree new_temp;\n   tree def, def_stmt;\n@@ -3425,6 +3652,13 @@ vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n \n   ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_out;\n   gcc_assert (ncopies >= 1);\n+  /* FORNOW. This restriction should be relaxed.  */\n+  if (nested_in_vect_loop_p (loop, stmt) && ncopies > 1)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"multiple types in nested loop.\");\n+      return false;\n+    }\n \n   if (! ((INTEGRAL_TYPE_P (TREE_TYPE (scalar_dest))\n \t  && INTEGRAL_TYPE_P (TREE_TYPE (op0)))\n@@ -3522,6 +3756,7 @@ vectorizable_type_promotion (tree stmt, block_stmt_iterator *bsi,\n   tree vec_oprnd0=NULL, vec_oprnd1=NULL;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   enum tree_code code, code1 = ERROR_MARK, code2 = ERROR_MARK;\n   tree decl1 = NULL_TREE, decl2 = NULL_TREE;\n   int op_type; \n@@ -3575,6 +3810,13 @@ vectorizable_type_promotion (tree stmt, block_stmt_iterator *bsi,\n \n   ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n   gcc_assert (ncopies >= 1);\n+  /* FORNOW. This restriction should be relaxed.  */\n+  if (nested_in_vect_loop_p (loop, stmt) && ncopies > 1)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"multiple types in nested loop.\");\n+      return false;\n+    }\n \n   if (! ((INTEGRAL_TYPE_P (TREE_TYPE (scalar_dest))\n \t  && INTEGRAL_TYPE_P (TREE_TYPE (op0)))\n@@ -3867,6 +4109,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info), *first_dr = NULL;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   enum machine_mode vec_mode;\n   tree dummy;\n   enum dr_alignment_support alignment_support_cheme;\n@@ -3882,6 +4125,13 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   unsigned int group_size, i;\n   VEC(tree,heap) *dr_chain = NULL, *oprnds = NULL, *result_chain = NULL;\n   gcc_assert (ncopies >= 1);\n+  /* FORNOW. This restriction should be relaxed.  */\n+  if (nested_in_vect_loop_p (loop, stmt) && ncopies > 1)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"multiple types in nested loop.\");\n+      return false;\n+    }\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n@@ -4517,6 +4767,15 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   bool strided_load = false;\n   tree first_stmt;\n \n+  gcc_assert (ncopies >= 1);\n+  /* FORNOW. This restriction should be relaxed.  */\n+  if (nested_in_vect_loop_p (loop, stmt) && ncopies > 1)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"multiple types in nested loop.\");\n+      return false;\n+    }\n+\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n@@ -4812,6 +5071,7 @@ vectorizable_live_operation (tree stmt,\n   tree operation;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   int i;\n   int op_type;\n   tree op;\n@@ -4829,6 +5089,10 @@ vectorizable_live_operation (tree stmt,\n   if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) != SSA_NAME)\n     return false;\n \n+  /* FORNOW. CHECKME. */\n+  if (nested_in_vect_loop_p (loop, stmt))\n+    return false;\n+\n   operation = GIMPLE_STMT_OPERAND (stmt, 1);\n   op_type = TREE_OPERAND_LENGTH (operation);\n \n@@ -6124,8 +6388,18 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t      fprintf (vect_dump, \"------>vectorizing statement: \");\n \t      print_generic_expr (vect_dump, stmt, TDF_SLIM);\n \t    }\t\n+\n \t  stmt_info = vinfo_for_stmt (stmt);\n-\t  gcc_assert (stmt_info);\n+\n+\t  /* vector stmts created in the outer-loop during vectorization of\n+\t     stmts in an inner-loop may not have a stmt_info, and do not\n+\t     need to be vectorized.  */\n+\t  if (!stmt_info)\n+\t    {\n+\t      bsi_next (&si);\n+\t      continue;\n+\t    }\n+\n \t  if (!STMT_VINFO_RELEVANT_P (stmt_info)\n \t      && !STMT_VINFO_LIVE_P (stmt_info))\n \t    {\n@@ -6197,4 +6471,6 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \n   if (vect_print_dump_info (REPORT_VECTORIZED_LOOPS))\n     fprintf (vect_dump, \"LOOP VECTORIZED.\");\n+  if (loop->inner && vect_print_dump_info (REPORT_VECTORIZED_LOOPS))\n+    fprintf (vect_dump, \"OUTER LOOP VECTORIZED.\");\n }"}, {"sha": "20c867c708baac7324a8b886a9cc02b1600288eb", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 119, "deletions": 30, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -1345,7 +1345,7 @@ new_stmt_vec_info (tree stmt, loop_vec_info loop_vinfo)\n   STMT_VINFO_IN_PATTERN_P (res) = false;\n   STMT_VINFO_RELATED_STMT (res) = NULL;\n   STMT_VINFO_DATA_REF (res) = NULL;\n-  if (TREE_CODE (stmt) == PHI_NODE)\n+  if (TREE_CODE (stmt) == PHI_NODE && is_loop_header_bb_p (bb_for_stmt (stmt)))\n     STMT_VINFO_DEF_TYPE (res) = vect_unknown_def_type;\n   else\n     STMT_VINFO_DEF_TYPE (res) = vect_loop_def;\n@@ -1364,6 +1364,20 @@ new_stmt_vec_info (tree stmt, loop_vec_info loop_vinfo)\n }\n \n \n+/* Function bb_in_loop_p\n+\n+   Used as predicate for dfs order traversal of the loop bbs.  */\n+\n+static bool\n+bb_in_loop_p (const_basic_block bb, const void *data)\n+{\n+  struct loop *loop = (struct loop *)data;\n+  if (flow_bb_inside_loop_p (loop, bb))\n+    return true;\n+  return false;\n+}\n+\n+\n /* Function new_loop_vec_info.\n \n    Create and initialize a new loop_vec_info struct for LOOP, as well as\n@@ -1375,37 +1389,76 @@ new_loop_vec_info (struct loop *loop)\n   loop_vec_info res;\n   basic_block *bbs;\n   block_stmt_iterator si;\n-  unsigned int i;\n+  unsigned int i, nbbs;\n \n   res = (loop_vec_info) xcalloc (1, sizeof (struct _loop_vec_info));\n+  LOOP_VINFO_LOOP (res) = loop;\n \n   bbs = get_loop_body (loop);\n \n-  /* Create stmt_info for all stmts in the loop.  */\n+  /* Create/Update stmt_info for all stmts in the loop.  */\n   for (i = 0; i < loop->num_nodes; i++)\n     {\n       basic_block bb = bbs[i];\n       tree phi;\n \n-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-        {\n-          stmt_ann_t ann = get_stmt_ann (phi);\n-          set_stmt_info (ann, new_stmt_vec_info (phi, res));\n-        }\n-\n-      for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n+      /* BBs in a nested inner-loop will have been already processed (because \n+\t we will have called vect_analyze_loop_form for any nested inner-loop).\n+\t Therefore, for stmts in an inner-loop we just want to update the \n+\t STMT_VINFO_LOOP_VINFO field of their stmt_info to point to the new \n+\t loop_info of the outer-loop we are currently considering to vectorize \n+\t (instead of the loop_info of the inner-loop).\n+\t For stmts in other BBs we need to create a stmt_info from scratch.  */\n+      if (bb->loop_father != loop)\n \t{\n-\t  tree stmt = bsi_stmt (si);\n-\t  stmt_ann_t ann;\n+\t  /* Inner-loop bb.  */\n+\t  gcc_assert (loop->inner && bb->loop_father == loop->inner);\n+\t  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\t    {\n+\t      stmt_vec_info stmt_info = vinfo_for_stmt (phi);\n+\t      loop_vec_info inner_loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+\t      gcc_assert (loop->inner == LOOP_VINFO_LOOP (inner_loop_vinfo));\n+\t      STMT_VINFO_LOOP_VINFO (stmt_info) = res;\n+\t    }\n+\t  for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n+\t   {\n+\t      tree stmt = bsi_stmt (si);\n+\t      stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\t      loop_vec_info inner_loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+\t      gcc_assert (loop->inner == LOOP_VINFO_LOOP (inner_loop_vinfo));\n+\t      STMT_VINFO_LOOP_VINFO (stmt_info) = res;\n+\t   }\n+\t}\n+      else\n+\t{\n+\t  /* bb in current nest.  */\n+\t  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\t    {\n+\t      stmt_ann_t ann = get_stmt_ann (phi);\n+\t      set_stmt_info (ann, new_stmt_vec_info (phi, res));\n+\t    }\n \n-\t  ann = stmt_ann (stmt);\n-\t  set_stmt_info (ann, new_stmt_vec_info (stmt, res));\n+\t  for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n+\t    {\n+\t      tree stmt = bsi_stmt (si);\n+\t      stmt_ann_t ann = stmt_ann (stmt);\n+\t      set_stmt_info (ann, new_stmt_vec_info (stmt, res));\n+\t    }\n \t}\n     }\n \n-  LOOP_VINFO_LOOP (res) = loop;\n+  /* CHECKME: We want to visit all BBs before their successors (except for \n+     latch blocks, for which this assertion wouldn't hold).  In the simple \n+     case of the loop forms we allow, a dfs order of the BBs would the same \n+     as reversed postorder traversal, so we are safe.  */\n+\n+   free (bbs);\n+   bbs = XCNEWVEC (basic_block, loop->num_nodes);\n+   nbbs = dfs_enumerate_from (loop->header, 0, bb_in_loop_p, \n+\t\t\t      bbs, loop->num_nodes, loop);\n+   gcc_assert (nbbs == loop->num_nodes);\n+\n   LOOP_VINFO_BBS (res) = bbs;\n-  LOOP_VINFO_EXIT_COND (res) = NULL;\n   LOOP_VINFO_NITERS (res) = NULL;\n   LOOP_VINFO_COST_MODEL_MIN_ITERS (res) = 0;\n   LOOP_VINFO_VECTORIZABLE_P (res) = 0;\n@@ -1430,7 +1483,7 @@ new_loop_vec_info (struct loop *loop)\n    stmts in the loop.  */\n \n void\n-destroy_loop_vec_info (loop_vec_info loop_vinfo)\n+destroy_loop_vec_info (loop_vec_info loop_vinfo, bool clean_stmts)\n {\n   struct loop *loop;\n   basic_block *bbs;\n@@ -1446,6 +1499,18 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo)\n   bbs = LOOP_VINFO_BBS (loop_vinfo);\n   nbbs = loop->num_nodes;\n \n+  if (!clean_stmts)\n+    {\n+      free (LOOP_VINFO_BBS (loop_vinfo));\n+      free_data_refs (LOOP_VINFO_DATAREFS (loop_vinfo));\n+      free_dependence_relations (LOOP_VINFO_DDRS (loop_vinfo));\n+      VEC_free (tree, heap, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo));\n+\n+      free (loop_vinfo);\n+      loop->aux = NULL;\n+      return;\n+    }\n+\n   for (j = 0; j < nbbs; j++)\n     {\n       basic_block bb = bbs[j];\n@@ -1597,7 +1662,6 @@ vect_supportable_dr_alignment (struct data_reference *dr)\n     return dr_aligned;\n \n   /* Possibly unaligned access.  */\n-  \n   if (DR_IS_READ (dr))\n     {\n       if (optab_handler (vec_realign_load_optab, mode)->insn_code != CODE_FOR_nothing\n@@ -1718,8 +1782,6 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def_stmt,\n     {\n     case PHI_NODE:\n       *def = PHI_RESULT (*def_stmt);\n-      gcc_assert (*dt == vect_induction_def || *dt == vect_reduction_def\n-\t\t  || *dt == vect_invariant_def);\n       break;\n \n     case GIMPLE_MODIFY_STMT:\n@@ -1760,6 +1822,8 @@ supportable_widening_operation (enum tree_code code, tree stmt, tree vectype,\n                                 enum tree_code *code1, enum tree_code *code2)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *vect_loop = LOOP_VINFO_LOOP (loop_info);\n   bool ordered_p;\n   enum machine_mode vec_mode;\n   enum insn_code icode1, icode2;\n@@ -1782,9 +1846,15 @@ supportable_widening_operation (enum tree_code code, tree stmt, tree vectype,\n      Some targets can take advantage of this and generate more efficient code.\n      For example, targets like Altivec, that support widen_mult using a sequence\n      of {mult_even,mult_odd} generate the following vectors:\n-        vect1: [res1,res3,res5,res7], vect2: [res2,res4,res6,res8].  */\n+        vect1: [res1,res3,res5,res7], vect2: [res2,res4,res6,res8].\n+\n+     When vectorizaing outer-loops, we execute the inner-loop sequentially\n+     (each vectorized inner-loop iteration contributes to VF outer-loop \n+     iterations in parallel). We therefore don't allow to change the order \n+     of the computation in the inner-loop during outer-loop vectorization.  */\n \n-   if (STMT_VINFO_RELEVANT (stmt_info) == vect_used_by_reduction)\n+   if (STMT_VINFO_RELEVANT (stmt_info) == vect_used_by_reduction\n+       && !nested_in_vect_loop_p (vect_loop, stmt))\n      ordered_p = false;\n    else\n      ordered_p = true;\n@@ -2008,8 +2078,10 @@ reduction_code_for_scalar_code (enum tree_code code,\n    Conditions 2,3 are tested in vect_mark_stmts_to_be_vectorized.  */\n \n tree\n-vect_is_simple_reduction (struct loop *loop, tree phi)\n+vect_is_simple_reduction (loop_vec_info loop_info, tree phi)\n {\n+  struct loop *loop = (bb_for_stmt (phi))->loop_father;\n+  struct loop *vect_loop = LOOP_VINFO_LOOP (loop_info);\n   edge latch_e = loop_latch_edge (loop);\n   tree loop_arg = PHI_ARG_DEF_FROM_EDGE (phi, latch_e);\n   tree def_stmt, def1, def2;\n@@ -2022,6 +2094,8 @@ vect_is_simple_reduction (struct loop *loop, tree phi)\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n \n+  gcc_assert (loop == vect_loop || flow_loop_nested_p (vect_loop, loop));\n+\n   name = PHI_RESULT (phi);\n   nloop_uses = 0;\n   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, name)\n@@ -2133,8 +2207,16 @@ vect_is_simple_reduction (struct loop *loop, tree phi)\n       return NULL_TREE;\n     }\n \n+  /* Generally, when vectorizing a reduction we change the order of the\n+     computation.  This may change the behavior of the program in some\n+     cases, so we need to check that this is ok.  One exception is when \n+     vectorizing an outer-loop: the inner-loop is executed sequentially,\n+     and therefore vectorizing reductions in the inner-loop durint \n+     outer-loop vectorization is safe.  */\n+\n   /* CHECKME: check for !flag_finite_math_only too?  */\n-  if (SCALAR_FLOAT_TYPE_P (type) && !flag_unsafe_math_optimizations)\n+  if (SCALAR_FLOAT_TYPE_P (type) && !flag_unsafe_math_optimizations\n+      && !nested_in_vect_loop_p (vect_loop, def_stmt)) \n     {\n       /* Changing the order of operations changes the semantics.  */\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -2144,7 +2226,8 @@ vect_is_simple_reduction (struct loop *loop, tree phi)\n         }\n       return NULL_TREE;\n     }\n-  else if (INTEGRAL_TYPE_P (type) && TYPE_OVERFLOW_TRAPS (type))\n+  else if (INTEGRAL_TYPE_P (type) && TYPE_OVERFLOW_TRAPS (type)\n+\t   && !nested_in_vect_loop_p (vect_loop, def_stmt))\n     {\n       /* Changing the order of operations changes the semantics.  */\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -2183,13 +2266,16 @@ vect_is_simple_reduction (struct loop *loop, tree phi)\n \n \n   /* Check that one def is the reduction def, defined by PHI,\n-     the other def is either defined in the loop by a GIMPLE_MODIFY_STMT,\n-     or it's an induction (defined by some phi node).  */\n+     the other def is either defined in the loop (\"vect_loop_def\"),\n+     or it's an induction (defined by a loop-header phi-node).  */\n \n   if (def2 == phi\n       && flow_bb_inside_loop_p (loop, bb_for_stmt (def1))\n       && (TREE_CODE (def1) == GIMPLE_MODIFY_STMT \n-\t  || STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def1)) == vect_induction_def))\n+\t  || STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def1)) == vect_induction_def\n+\t  || (TREE_CODE (def1) == PHI_NODE \n+\t      && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def1)) == vect_loop_def\n+\t      && !is_loop_header_bb_p (bb_for_stmt (def1)))))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         {\n@@ -2201,7 +2287,10 @@ vect_is_simple_reduction (struct loop *loop, tree phi)\n   else if (def1 == phi\n \t   && flow_bb_inside_loop_p (loop, bb_for_stmt (def2))\n \t   && (TREE_CODE (def2) == GIMPLE_MODIFY_STMT \n-\t       || STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def2)) == vect_induction_def))\n+\t       || STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def2)) == vect_induction_def\n+\t       || (TREE_CODE (def2) == PHI_NODE\n+\t\t   && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def2)) == vect_loop_def\n+\t\t   && !is_loop_header_bb_p (bb_for_stmt (def2)))))\n     {\n       /* Swap operands (just for simplicity - so that the rest of the code\n \t can assume that the reduction variable is always the last (second)\n@@ -2340,7 +2429,7 @@ vectorize_loops (void)\n       if (!loop)\n \tcontinue;\n       loop_vinfo = loop->aux;\n-      destroy_loop_vec_info (loop_vinfo);\n+      destroy_loop_vec_info (loop_vinfo, true);\n       loop->aux = NULL;\n     }\n "}, {"sha": "e9f208af25c1db1ace64cc7780186a18d76fd6ce", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29de1bf2836e4f06f32f7271192d7f92ba9235c/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=d29de1bf2836e4f06f32f7271192d7f92ba9235c", "patch": "@@ -92,9 +92,6 @@ typedef struct _loop_vec_info {\n   /* The loop basic blocks.  */\n   basic_block *bbs;\n \n-  /* The loop exit_condition.  */\n-  tree exit_cond;\n-\n   /* Number of iterations.  */\n   tree num_iters;\n \n@@ -148,7 +145,6 @@ typedef struct _loop_vec_info {\n /* Access Functions.  */\n #define LOOP_VINFO_LOOP(L)            (L)->loop\n #define LOOP_VINFO_BBS(L)             (L)->bbs\n-#define LOOP_VINFO_EXIT_COND(L)       (L)->exit_cond\n #define LOOP_VINFO_NITERS(L)          (L)->num_iters\n #define LOOP_VINFO_COST_MODEL_MIN_ITERS(L)\t(L)->min_profitable_iters\n #define LOOP_VINFO_VECTORIZABLE_P(L)  (L)->vectorizable\n@@ -170,6 +166,19 @@ typedef struct _loop_vec_info {\n #define LOOP_VINFO_NITERS_KNOWN_P(L)                     \\\n NITERS_KNOWN_P((L)->num_iters)\n \n+static inline loop_vec_info\n+loop_vec_info_for_loop (struct loop *loop)\n+{\n+  return (loop_vec_info) loop->aux;\n+}\n+\n+static inline bool\n+nested_in_vect_loop_p (struct loop *loop, tree stmt)\n+{\n+  return (loop->inner \n+          && (loop->inner == (bb_for_stmt (stmt))->loop_father));\n+}\n+\n /*-----------------------------------------------------------------*/\n /* Info on vectorized defs.                                        */\n /*-----------------------------------------------------------------*/\n@@ -185,12 +194,15 @@ enum stmt_vec_info_type {\n   induc_vec_info_type,\n   type_promotion_vec_info_type,\n   type_demotion_vec_info_type,\n-  type_conversion_vec_info_type\n+  type_conversion_vec_info_type,\n+  loop_exit_ctrl_vec_info_type\n };\n \n /* Indicates whether/how a variable is used in the loop.  */\n enum vect_relevant {\n   vect_unused_in_loop = 0,\n+  vect_used_in_outer_by_reduction,\n+  vect_used_in_outer,\n \n   /* defs that feed computations that end up (only) in a reduction. These\n      defs may be used by non-reduction stmts, but eventually, any \n@@ -408,6 +420,15 @@ is_pattern_stmt_p (stmt_vec_info stmt_info)\n   return false;\n }\n \n+static inline bool\n+is_loop_header_bb_p (basic_block bb)\n+{\n+  if (bb == (bb->loop_father)->header)\n+    return true;\n+  gcc_assert (EDGE_COUNT (bb->preds) == 1);\n+  return false;\n+}\n+\n /*-----------------------------------------------------------------*/\n /* Info on data references alignment.                              */\n /*-----------------------------------------------------------------*/\n@@ -467,7 +488,7 @@ extern tree get_vectype_for_scalar_type (tree);\n extern bool vect_is_simple_use (tree, loop_vec_info, tree *, tree *,\n \t\t\t\tenum vect_def_type *);\n extern bool vect_is_simple_iv_evolution (unsigned, tree, tree *, tree *);\n-extern tree vect_is_simple_reduction (struct loop *, tree);\n+extern tree vect_is_simple_reduction (loop_vec_info, tree);\n extern bool vect_can_force_dr_alignment_p (tree, unsigned int);\n extern enum dr_alignment_support vect_supportable_dr_alignment\n   (struct data_reference *);\n@@ -479,7 +500,7 @@ extern bool supportable_narrowing_operation (enum tree_code, tree, tree,\n \n /* Creation and deletion of loop and stmt info structs.  */\n extern loop_vec_info new_loop_vec_info (struct loop *loop);\n-extern void destroy_loop_vec_info (loop_vec_info);\n+extern void destroy_loop_vec_info (loop_vec_info, bool);\n extern stmt_vec_info new_stmt_vec_info (tree stmt, loop_vec_info);\n \n "}]}