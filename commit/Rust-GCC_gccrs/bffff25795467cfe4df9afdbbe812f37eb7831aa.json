{"sha": "bffff25795467cfe4df9afdbbe812f37eb7831aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZmZmYyNTc5NTQ2N2NmZTRkZjlhZmRiYmU4MTJmMzdlYjc4MzFhYQ==", "commit": {"author": {"name": "Scott Gilbertson", "email": "scottg@mantatest.com", "date": "2004-01-29T19:28:26Z"}, "committer": {"name": "Scott Gilbertson", "email": "sgilbertson@gcc.gnu.org", "date": "2004-01-29T19:28:26Z"}, "message": "Makefile.am: Added gnu/awt/xlib/XFontPeer.java.\n\n\t* Makefile.am: Added gnu/awt/xlib/XFontPeer.java.\n\t* Makefile.in: Re-generated.\n\t* gnu/awt/xlib/XFontPeer.java: New file.\n\t* gnu/awt/xlib/XGraphics.java (setFont): Test for null font.\n\t(setClip): Commented out debug printout.\n\t* gnu/awt/xlib/XToolkit.java: Change superclass to ClasspathToolkit.\n\t(getFontPeer): Return XFontPeer.\n\t(getLocalGraphicsEnvironment): New method.\n\t(getClasspathFontPeer): New method.\n\t(createFont): New method.\n\nFrom-SVN: r76891", "tree": {"sha": "28771b4b5061c5190439e976d20f2f6ffd1a1310", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28771b4b5061c5190439e976d20f2f6ffd1a1310"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bffff25795467cfe4df9afdbbe812f37eb7831aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bffff25795467cfe4df9afdbbe812f37eb7831aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bffff25795467cfe4df9afdbbe812f37eb7831aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bffff25795467cfe4df9afdbbe812f37eb7831aa/comments", "author": null, "committer": null, "parents": [{"sha": "64fc7c0047fdf1ec82f68ac6636cc41bfb6f752e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64fc7c0047fdf1ec82f68ac6636cc41bfb6f752e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64fc7c0047fdf1ec82f68ac6636cc41bfb6f752e"}], "stats": {"total": 402, "additions": 393, "deletions": 9}, "files": [{"sha": "26db264f2be29712026b9edcbd04ba8f6608ca0b", "filename": "libjava/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffff25795467cfe4df9afdbbe812f37eb7831aa/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffff25795467cfe4df9afdbbe812f37eb7831aa/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=bffff25795467cfe4df9afdbbe812f37eb7831aa", "patch": "@@ -1,3 +1,16 @@\n+2004-01-29  Scott Gilbertson  <scottg@mantatest.com>\n+\n+\t* Makefile.am: Added gnu/awt/xlib/XFontPeer.java.\n+\t* Makefile.in: Re-generated.\n+\t* gnu/awt/xlib/XFontPeer.java: New file.\n+\t* gnu/awt/xlib/XGraphics.java (setFont): Test for null font.\n+\t(setClip): Commented out debug printout.\n+\t* gnu/awt/xlib/XToolkit.java: Change superclass to ClasspathToolkit.\n+\t(getFontPeer): Return XFontPeer.\n+\t(getLocalGraphicsEnvironment): New method.\n+\t(getClasspathFontPeer): New method.\n+\t(createFont): New method.\n+\n 2004-01-29  Scott Gilbertson  <scottg@mantatest.com>\n \n \t* gnu/java/awt/peer/ClasspathFontPeer.java (getTransform): Never"}, {"sha": "07c996511f0052173cef34fd10e2e4795cac5ad7", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffff25795467cfe4df9afdbbe812f37eb7831aa/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffff25795467cfe4df9afdbbe812f37eb7831aa/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=bffff25795467cfe4df9afdbbe812f37eb7831aa", "patch": "@@ -2870,6 +2870,7 @@ gnu/awt/xlib/XGraphics.java \\\n gnu/awt/xlib/XGraphicsConfiguration.java \\\n gnu/awt/xlib/XOffScreenImage.java \\\n gnu/awt/xlib/XPanelPeer.java \\\n+gnu/awt/xlib/XFontPeer.java \\\n gnu/awt/xlib/XToolkit.java\n \n x_nat_source_files = \\"}, {"sha": "7c0ef87cc2b3fc200b8a66e8f0ca5881d154008b", "filename": "libjava/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffff25795467cfe4df9afdbbe812f37eb7831aa/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffff25795467cfe4df9afdbbe812f37eb7831aa/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=bffff25795467cfe4df9afdbbe812f37eb7831aa", "patch": "@@ -2568,6 +2568,7 @@ gnu/awt/xlib/XGraphics.java \\\n gnu/awt/xlib/XGraphicsConfiguration.java \\\n gnu/awt/xlib/XOffScreenImage.java \\\n gnu/awt/xlib/XPanelPeer.java \\\n+gnu/awt/xlib/XFontPeer.java \\\n gnu/awt/xlib/XToolkit.java\n \n \n@@ -2947,8 +2948,8 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/awt/j2d/IntegerGraphicsState.P \\\n .deps/gnu/awt/j2d/MappedRaster.P .deps/gnu/awt/xlib/XCanvasPeer.P \\\n .deps/gnu/awt/xlib/XEventLoop.P .deps/gnu/awt/xlib/XEventQueue.P \\\n-.deps/gnu/awt/xlib/XFontMetrics.P .deps/gnu/awt/xlib/XFramePeer.P \\\n-.deps/gnu/awt/xlib/XGraphics.P \\\n+.deps/gnu/awt/xlib/XFontMetrics.P .deps/gnu/awt/xlib/XFontPeer.P \\\n+.deps/gnu/awt/xlib/XFramePeer.P .deps/gnu/awt/xlib/XGraphics.P \\\n .deps/gnu/awt/xlib/XGraphicsConfiguration.P \\\n .deps/gnu/awt/xlib/XOffScreenImage.P .deps/gnu/awt/xlib/XPanelPeer.P \\\n .deps/gnu/awt/xlib/XToolkit.P .deps/gnu/classpath/Configuration.P \\"}, {"sha": "523cc22795f197af440ec862c90da74190f11d01", "filename": "libjava/gnu/awt/xlib/XFontPeer.java", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffff25795467cfe4df9afdbbe812f37eb7831aa/libjava%2Fgnu%2Fawt%2Fxlib%2FXFontPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffff25795467cfe4df9afdbbe812f37eb7831aa/libjava%2Fgnu%2Fawt%2Fxlib%2FXFontPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fxlib%2FXFontPeer.java?ref=bffff25795467cfe4df9afdbbe812f37eb7831aa", "patch": "@@ -0,0 +1,277 @@\n+/* Copyright (C) 2000, 2002, 2003  Free Software Foundation\n+ \n+   This file is part of libgcj.\n+ \n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.awt.xlib;\n+\n+import java.awt.*;\n+import gnu.java.awt.ClasspathToolkit;\n+import gnu.java.awt.peer.ClasspathFontPeer;\n+import java.util.Locale;\n+import java.awt.font.*;\n+import java.awt.geom.*;\n+import java.text.CharacterIterator;\n+\n+/**\n+ * Classpath-compatible peer for a font\n+ */\n+public class XFontPeer extends ClasspathFontPeer\n+{\n+  public XFontPeer (String name, int style)\n+  {\n+    this (name, style, 12 /* kludge */);\n+  }\n+  \n+  public XFontPeer (String name, int style, float size)\n+  {\n+    super (name, style, (int)size);\n+  }\n+  \n+  /**\n+   * Implementation of {@link Font#canDisplay(char)}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+  public boolean canDisplay (Font font, char c)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+  \n+  /**\n+   * Implementation of {@link Font#canDisplay(String)},\n+   * {@link Font#canDisplay(char [], int, int)}, and\n+   * {@link Font#canDisplay(CharacterIterator, int, int)}.\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+  public int canDisplayUpTo (Font font, CharacterIterator i, int start, int limit)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+  \n+  /**\n+   * Implementation of {@link\n+   * Font#createGlyphVector(FontRenderContext, String)}, {@link\n+   * Font#createGlyphVector(FontRenderContext, char[])}, and {@link\n+   * Font#createGlyphVector(FontRenderContext, CharacterIterator)}.\n+   *\n+   * @param font the font object that the created GlyphVector will return\n+   * when it gets asked for its font. This argument is needed because the\n+   * public API of {@link GlyphVector} works with {@link java.awt.Font},\n+   * not with font peers.\n+   */\n+  public GlyphVector createGlyphVector (Font font, FontRenderContext frc, CharacterIterator ci)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+  \n+  /**\n+   * Implementation of {@link Font#createGlyphVector(FontRenderContext,\n+   * int[])}.\n+   *\n+   * @param font the font object that the created GlyphVector will return\n+   * when it gets asked for its font. This argument is needed because the\n+   * public API of {@link GlyphVector} works with {@link java.awt.Font},\n+   * not with font peers.\n+   */\n+  public GlyphVector createGlyphVector (Font font, FontRenderContext ctx, int[] glyphCodes)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+  \n+  /**\n+   * Implementation of {@link Font#getBaselineFor(char)}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+  public byte getBaselineFor (Font font, char c)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+  \n+  /**\n+   * Implementation of {@link Font#getFontMetrics()}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+  public FontMetrics getFontMetrics (Font font)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+  \n+  /** Returns a name for the specified glyph. This is useful for\n+   * generating PostScript or PDF files that embed some glyphs of a\n+   * font. If the implementation follows glyph naming conventions\n+   * specified by Adobe, search engines can extract the original text\n+   * from the generated PostScript and PDF files.\n+   *\n+   * <p>This method is currently not used by GNU Classpath. However,\n+   * it would be very useful for someone wishing to write a good\n+   * PostScript or PDF stream provider for the\n+   * <code>javax.print</code> package.\n+   *\n+   * <p><b>Names are not unique:</b> Under some rare circumstances,\n+   * the same name can be returned for different glyphs. It is\n+   * therefore recommended that printer drivers check whether the same\n+   * name has already been returned for antoher glyph, and make the\n+   * name unique by adding the string \".alt\" followed by the glyph\n+   * index.</p>\n+   *\n+   * <p>This situation would occur for an OpenType or TrueType font\n+   * that has a <code>post</code> table of format 3 and provides a\n+   * mapping from glyph IDs to Unicode sequences through a\n+   * <code>Zapf</code> table. If the same sequence of Unicode\n+   * codepoints leads to different glyphs (depending on contextual\n+   * position, for example, or on typographic sophistication level),\n+   * the same name would get synthesized for those glyphs. To avoid\n+   * this, the font peer would have to go through the names of all\n+   * glyphs, which would make this operation very inefficient with\n+   * large fonts.\n+   *\n+   * @param font the font containing the glyph whose name is\n+   * requested.\n+   *\n+   * @param glyphIndex the glyph whose name the caller wants to\n+   * retrieve.\n+   *\n+   * @return the glyph name, or <code>null</code> if a font does not\n+   * provide glyph names.\n+   */\n+  public String getGlyphName (Font font, int glyphIndex)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+  \n+  /**\n+   * Implementation of {@link Font#getLineMetrics(CharacterIterator, int,\n+   * int, FontRenderContext)}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+  public LineMetrics getLineMetrics (Font font, CharacterIterator ci, int begin, int limit, FontRenderContext rc)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+  \n+  /**\n+   * Implementation of {@link Font#getMaxCharBounds(FontRenderContext)}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+  public Rectangle2D getMaxCharBounds (Font font, FontRenderContext rc)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+  \n+  /**\n+   * Implementation of {@link Font#getMissingGlyphCode()}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+  public int getMissingGlyphCode (Font font)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+  \n+  /**\n+   * Implementation of {@link Font#getNumGlyphs()}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+  public int getNumGlyphs (Font font)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+  \n+  /**\n+   * Implementation of {@link Font#getPSName()}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+  public String getPostScriptName (Font font)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+  \n+  /**\n+   * Implementation of {@link Font#getStringBounds(CharacterIterator, int,\n+   * int, FontRenderContext)}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+  public Rectangle2D getStringBounds (Font font, CharacterIterator ci, int begin, int limit, FontRenderContext frc)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+  \n+  /** Returns the name of this font face inside the family, for example\n+   * <i>&#x201c;Light&#x201d;</i>.\n+   *\n+   * <p>This method is currently not used by {@link Font}. However,\n+   * this name would be needed by any serious desktop publishing\n+   * application.\n+   *\n+   * @param font the font whose sub-family name is requested.\n+   *\n+   * @param locale the locale for which to localize the name.  If\n+   * <code>locale</code> is <code>null</code>, the returned name is\n+   * localized to the user&#x2019;s default locale.\n+   *\n+   * @return the name of the face inside its family, or\n+   * <code>null</code> if the font does not provide a sub-family name.\n+   */\n+  public String getSubFamilyName (Font font, Locale locale)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+  \n+  /**\n+   * Implementation of {@link Font#hasUniformLineMetrics()}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+  public boolean hasUniformLineMetrics (Font font)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+  \n+  /**\n+   * Implementation of {@link Font#layoutGlyphVector(FontRenderContext,\n+   * char[], int, int, int)}.\n+   *\n+   * @param font the font object that the created GlyphVector will return\n+   * when it gets asked for its font. This argument is needed because the\n+   * public API of {@link GlyphVector} works with {@link java.awt.Font},\n+   * not with font peers.\n+   */\n+  public GlyphVector layoutGlyphVector (Font font, FontRenderContext frc, char[] chars, int start, int limit, int flags)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+}"}, {"sha": "0e14e25bc71a6320375eaa30765c6500a2fe0c05", "filename": "libjava/gnu/awt/xlib/XGraphics.java", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffff25795467cfe4df9afdbbe812f37eb7831aa/libjava%2Fgnu%2Fawt%2Fxlib%2FXGraphics.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffff25795467cfe4df9afdbbe812f37eb7831aa/libjava%2Fgnu%2Fawt%2Fxlib%2FXGraphics.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fxlib%2FXGraphics.java?ref=bffff25795467cfe4df9afdbbe812f37eb7831aa", "patch": "@@ -98,10 +98,13 @@ public void setXORMode(Color c1)\n     \n   public void setFont(Font font)\n   {\n-    if ((metrics != null) && font.equals(metrics.getFont())) return;\n-\n+    if (font == null)\n+      return;\n+    if ((metrics != null) && font.equals(metrics.getFont()))\n+      return;\n     metrics = config.getXFontMetrics(font);\n-    context.setFont(metrics.xfont);\n+    if (metrics != null)\n+      context.setFont(metrics.xfont);\n   }\n     \n   public FontMetrics getFontMetrics(Font font)\n@@ -130,12 +133,15 @@ public void setClip(Shape clip)\n        expose. */\n     Rectangle newClipBounds = clip.getBounds();\n     \n+    /* FIXME: decide whether this test code is worth anything\n+     * (as of 2004-01-29, it prints frequently)\n     if ((clipBounds != null) && !clipBounds.contains(newClipBounds))\n       {\n \tSystem.err.println(\"warning: old clip (\"+ clipBounds +\") does \" +\n \t\t\t   \"not fully contain new clip (\" +\n \t\t\t   newClipBounds + \")\");\n       }\n+     */\n     clipBounds = newClipBounds;\n     Rectangle[] rects = { clipBounds };\n     context.setClipRectangles(rects);"}, {"sha": "1856d97fe5392fba97afe6f309a5c55ea0c302dc", "filename": "libjava/gnu/awt/xlib/XToolkit.java", "status": "modified", "additions": 90, "deletions": 4, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffff25795467cfe4df9afdbbe812f37eb7831aa/libjava%2Fgnu%2Fawt%2Fxlib%2FXToolkit.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffff25795467cfe4df9afdbbe812f37eb7831aa/libjava%2Fgnu%2Fawt%2Fxlib%2FXToolkit.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fxlib%2FXToolkit.java?ref=bffff25795467cfe4df9afdbbe812f37eb7831aa", "patch": "@@ -11,20 +11,23 @@\n import java.awt.*;\n import java.awt.dnd.*;\n import java.awt.dnd.peer.*;\n+import java.awt.font.*;\n import java.awt.im.*;\n import java.awt.peer.*;\n import java.awt.image.ImageProducer;\n import java.awt.image.ImageObserver;\n import java.net.*;\n import java.awt.datatransfer.Clipboard;\n-import java.util.Properties;\n+import java.io.InputStream;\n import java.util.Map;\n-\n+import java.util.Properties;\n import gnu.gcj.xlib.Display;\n import gnu.gcj.xlib.Screen;\n import gnu.gcj.xlib.Visual;\n+import gnu.java.awt.ClasspathToolkit;\n+import gnu.java.awt.peer.ClasspathFontPeer;\n \n-public class XToolkit extends Toolkit\n+public class XToolkit extends ClasspathToolkit\n {\n   static XToolkit INSTANCE;\n   \n@@ -158,7 +161,7 @@ protected FileDialogPeer createFileDialog(FileDialog frontend)\n \n   protected java.awt.peer.FontPeer getFontPeer(String name, int style) \n   {\n-    return null;\n+    return new XFontPeer (name,style);\n   }\n \n   public Dimension getScreenSize()\n@@ -345,4 +348,87 @@ public Map mapInputMethodHighlight(InputMethodHighlight highlight)\n   {\n     throw new UnsupportedOperationException(\"not implemented\");\n   }\n+  \n+  /** Returns a shared instance of the local, platform-specific\n+   * graphics environment.\n+   *\n+   * <p>This method is specific to GNU Classpath. It gets called by\n+   * the Classpath implementation of {@link\n+   * GraphicsEnvironment.getLocalGraphcisEnvironment()}.\n+   */\n+  public GraphicsEnvironment getLocalGraphicsEnvironment ()\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+  \n+  /** Acquires an appropriate {@link ClasspathFontPeer}, for use in\n+   * classpath's implementation of {@link java.awt.Font}.\n+   *\n+   * @param name The logical name of the font. This may be either a face\n+   * name or a logical font name, or may even be null. A default\n+   * implementation of name decoding is provided in\n+   * {@link ClasspathFontPeer}, but may be overridden in other toolkits.\n+   *\n+   * @param attrs Any extra {@link java.awt.font.TextAttribute} attributes\n+   * this font peer should have, such as size, weight, family name, or\n+   * transformation.\n+   */\n+  public ClasspathFontPeer getClasspathFontPeer (String name, Map attrs)\n+  {\n+    int style = Font.PLAIN;\n+    float size = 12;\n+\n+    if (attrs.containsKey (TextAttribute.WEIGHT))\n+      {\n+        Float weight = (Float) attrs.get (TextAttribute.WEIGHT);\n+        if (weight.floatValue () >= TextAttribute.WEIGHT_BOLD.floatValue ())\n+          style += Font.BOLD;\n+      }\n+\n+    if (attrs.containsKey (TextAttribute.POSTURE))\n+      {\n+        Float posture = (Float) attrs.get (TextAttribute.POSTURE);\n+        if (posture.floatValue () >= TextAttribute.POSTURE_OBLIQUE.floatValue ())\n+          style += Font.ITALIC;\n+      }\n+\n+    if (attrs.containsKey (TextAttribute.SIZE))\n+      {\n+        Float fsize = (Float) attrs.get (TextAttribute.SIZE);\n+        size = fsize.floatValue ();\n+      }\n+\n+    return new XFontPeer (name,style,size);\n+  }\n+  \n+  /** Creates a font, reading the glyph definitions from a stream.\n+   *\n+   * <p>This method provides the platform-specific implementation for\n+   * the static factory method {@link Font#createFont(int,\n+   * java.io.InputStream)}.\n+   *\n+   * @param format the format of the font data, such as {@link\n+   * Font#TRUETYPE_FONT}. An implementation may ignore this argument\n+   * if it is able to automatically recognize the font format from the\n+   * provided data.\n+   *\n+   * @param stream an input stream from where the font data is read\n+   * in. The stream will be advanced to the position after the font\n+   * data, but not closed.\n+   *\n+   * @throws IllegalArgumentException if <code>format</code> is\n+   * not supported.\n+   *\n+   * @throws FontFormatException if <code>stream</code> does not\n+   * contain data in the expected format, or if required tables are\n+   * missing from a font.\n+   *\n+   * @throws IOException if a problem occurs while reading in the\n+   * contents of <code>stream</code>.\n+   */\n+  public Font createFont (int format, InputStream stream)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+  \n }"}]}