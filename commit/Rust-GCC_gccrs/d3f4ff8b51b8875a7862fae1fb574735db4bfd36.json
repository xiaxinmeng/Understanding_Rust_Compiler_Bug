{"sha": "d3f4ff8b51b8875a7862fae1fb574735db4bfd36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNmNGZmOGI1MWI4ODc1YTc4NjJmYWUxZmI1NzQ3MzVkYjRiZmQzNg==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2013-11-16T00:05:08Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2013-11-16T00:05:08Z"}, "message": "ucnid-2011-1.c: New test.\n\ngcc/testsuite:\n\t* c-c++-common/cpp/ucnid-2011-1.c: New test.\n\nlibcpp:\n\t* ucnid.tab: Add C11 and C11NOSTART data.\n\t* makeucnid.c (digit): Rename enum value to N99.\n\t(C11, N11, all_languages): New enum values.\n\t(NUM_CODE_POINTS, MAX_CODE_POINT): New macros.\n\t(flags, decomp, combining_value): Use NUM_CODE_POINTS as array\n\tsize.\n\t(decomp): Use unsigned int as element type.\n\t(all_decomp): New array.\n\t(read_ucnid): Handle C11 and C11NOSTART.  Use MAX_CODE_POINT.\n\t(read_table): Use MAX_CODE_POINT.  Store all decompositions in\n\tall_decomp.\n\t(read_derived): Use MAX_CODE_POINT.\n\t(write_table): Use NUM_CODE_POINTS.  Print N99, C11 and N11\n\tflags.  Print whole array variable declaration rather than just\n\tarray contents.\n\t(char_id_valid, write_context_switch): New functions.\n\t(main): Call write_context_switch.\n\t* ucnid.h: Regenerate.\n\t* include/cpplib.h (struct cpp_options): Add c11_identifiers.\n\t* init.c (struct lang_flags): Add c11_identifiers.\n\t(cpp_set_lang): Set c11_identifiers option from selected language.\n\t* internal.h (struct normalize_state): Document \"previous\" as\n\tprevious starter character.\n\t(NORMALIZE_STATE_UPDATE_IDNUM): Take character as argument.\n\t* charset.c (DIG): Rename enum value to N99.\n\t(C11, N11): New enum values.\n\t(struct ucnrange): Give name to struct.  Use short for flags and\n\tunsigned int for end of range.  Include ucnid.h for whole variable\n\tdeclaration.\n\t(ucn_valid_in_identifier): Allow for characters up to 0x10FFFF.\n\tAllow for C11 in determining valid characters and valid start\n\tcharacters.  Use check_nfc for non-Hangul context-dependent\n\tchecks.  Only store starter characters in nst->previous.\n\t(_cpp_valid_ucn): Pass new argument to\n\tNORMALIZE_STATE_UPDATE_IDNUM.\n\t* lex.c (lex_identifier): Pass new argument to\n\tNORMALIZE_STATE_UPDATE_IDNUM.  Call NORMALIZE_STATE_UPDATE_IDNUM\n\tafter initial non-UCN part of identifier.\n\t(lex_number): Pass new argument to NORMALIZE_STATE_UPDATE_IDNUM.\n\nFrom-SVN: r204886", "tree": {"sha": "ddce12237d1c0fb641f1d74daf972657ec50caca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddce12237d1c0fb641f1d74daf972657ec50caca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3f4ff8b51b8875a7862fae1fb574735db4bfd36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3f4ff8b51b8875a7862fae1fb574735db4bfd36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3f4ff8b51b8875a7862fae1fb574735db4bfd36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3f4ff8b51b8875a7862fae1fb574735db4bfd36/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d053a5f72d60cc868defb5108ac0b28bdd9ef4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d053a5f72d60cc868defb5108ac0b28bdd9ef4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d053a5f72d60cc868defb5108ac0b28bdd9ef4c"}], "stats": {"total": 5623, "additions": 4783, "deletions": 840}, "files": [{"sha": "066ee011915728b24fecde3e8c4b4f5a3f90e980", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f4ff8b51b8875a7862fae1fb574735db4bfd36/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f4ff8b51b8875a7862fae1fb574735db4bfd36/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d3f4ff8b51b8875a7862fae1fb574735db4bfd36", "patch": "@@ -1,3 +1,7 @@\n+2013-11-15  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-c++-common/cpp/ucnid-2011-1.c: New test.\n+\n 2013-11-15  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/58188"}, {"sha": "e3c6d260855ea23ba2c950a8f4934d3972fce284", "filename": "gcc/testsuite/c-c++-common/cpp/ucnid-2011-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f4ff8b51b8875a7862fae1fb574735db4bfd36/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fucnid-2011-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f4ff8b51b8875a7862fae1fb574735db4bfd36/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fucnid-2011-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fucnid-2011-1.c?ref=d3f4ff8b51b8875a7862fae1fb574735db4bfd36", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do preprocess } */\n+/* { dg-options \"-std=c11 -pedantic -fextended-identifiers\" { target c } } */\n+/* { dg-options \"-std=c++11 -pedantic -fextended-identifiers\" { target c++ } } */\n+\n+\\u00A8\n+\n+B\\u0300\n+\n+\\u0300 /* { dg-error \"not valid at the start of an identifier\" } */\n+\n+A\\u0300 /* { dg-warning \"not in NFC\" } */\n+\n+\\U00010000\n+\\U0001FFFD\n+\\U000E1234"}, {"sha": "5e38c4b5dff2939879879db4f642a111c13c7063", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f4ff8b51b8875a7862fae1fb574735db4bfd36/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f4ff8b51b8875a7862fae1fb574735db4bfd36/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=d3f4ff8b51b8875a7862fae1fb574735db4bfd36", "patch": "@@ -1,3 +1,45 @@\n+2013-11-15  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* ucnid.tab: Add C11 and C11NOSTART data.\n+\t* makeucnid.c (digit): Rename enum value to N99.\n+\t(C11, N11, all_languages): New enum values.\n+\t(NUM_CODE_POINTS, MAX_CODE_POINT): New macros.\n+\t(flags, decomp, combining_value): Use NUM_CODE_POINTS as array\n+\tsize.\n+\t(decomp): Use unsigned int as element type.\n+\t(all_decomp): New array.\n+\t(read_ucnid): Handle C11 and C11NOSTART.  Use MAX_CODE_POINT.\n+\t(read_table): Use MAX_CODE_POINT.  Store all decompositions in\n+\tall_decomp.\n+\t(read_derived): Use MAX_CODE_POINT.\n+\t(write_table): Use NUM_CODE_POINTS.  Print N99, C11 and N11\n+\tflags.  Print whole array variable declaration rather than just\n+\tarray contents.\n+\t(char_id_valid, write_context_switch): New functions.\n+\t(main): Call write_context_switch.\n+\t* ucnid.h: Regenerate.\n+\t* include/cpplib.h (struct cpp_options): Add c11_identifiers.\n+\t* init.c (struct lang_flags): Add c11_identifiers.\n+\t(cpp_set_lang): Set c11_identifiers option from selected language.\n+\t* internal.h (struct normalize_state): Document \"previous\" as\n+\tprevious starter character.\n+\t(NORMALIZE_STATE_UPDATE_IDNUM): Take character as argument.\n+\t* charset.c (DIG): Rename enum value to N99.\n+\t(C11, N11): New enum values.\n+\t(struct ucnrange): Give name to struct.  Use short for flags and\n+\tunsigned int for end of range.  Include ucnid.h for whole variable\n+\tdeclaration.\n+\t(ucn_valid_in_identifier): Allow for characters up to 0x10FFFF.\n+\tAllow for C11 in determining valid characters and valid start\n+\tcharacters.  Use check_nfc for non-Hangul context-dependent\n+\tchecks.  Only store starter characters in nst->previous.\n+\t(_cpp_valid_ucn): Pass new argument to\n+\tNORMALIZE_STATE_UPDATE_IDNUM.\n+\t* lex.c (lex_identifier): Pass new argument to\n+\tNORMALIZE_STATE_UPDATE_IDNUM.  Call NORMALIZE_STATE_UPDATE_IDNUM\n+\tafter initial non-UCN part of identifier.\n+\t(lex_number): Pass new argument to NORMALIZE_STATE_UPDATE_IDNUM.\n+\n 2013-11-15  Joseph Myers  <joseph@codesourcery.com>\n \n \t* ucnid.tab: Mark C99 digits as [C99DIG]."}, {"sha": "c48e64aa4b56c5f485e60dae08a3794a6c12fe45", "filename": "libcpp/charset.c", "status": "modified", "additions": 46, "deletions": 42, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f4ff8b51b8875a7862fae1fb574735db4bfd36/libcpp%2Fcharset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f4ff8b51b8875a7862fae1fb574735db4bfd36/libcpp%2Fcharset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fcharset.c?ref=d3f4ff8b51b8875a7862fae1fb574735db4bfd36", "patch": "@@ -828,29 +828,32 @@ enum {\n   /* Valid in a C99 identifier?  */\n   C99 = 1,\n   /* Valid in a C99 identifier, but not as the first character?  */\n-  DIG = 2,\n+  N99 = 2,\n   /* Valid in a C++ identifier?  */\n   CXX = 4,\n+  /* Valid in a C11/C++11 identifier?  */\n+  C11 = 8,\n+  /* Valid in a C11/C++11 identifier, but not as the first character?  */\n+  N11 = 16,\n   /* NFC representation is not valid in an identifier?  */\n-  CID = 8,\n+  CID = 32,\n   /* Might be valid NFC form?  */\n-  NFC = 16,\n+  NFC = 64,\n   /* Might be valid NFKC form?  */\n-  NKC = 32,\n+  NKC = 128,\n   /* Certain preceding characters might make it not valid NFC/NKFC form?  */\n-  CTX = 64\n+  CTX = 256\n };\n \n-static const struct {\n+struct ucnrange {\n   /* Bitmap of flags above.  */\n-  unsigned char flags;\n+  unsigned short flags;\n   /* Combining class of the character.  */\n   unsigned char combine;\n   /* Last character in the range described by this entry.  */\n-  unsigned short end;\n-} ucnranges[] = {\n-#include \"ucnid.h\"\n+  unsigned int end;\n };\n+#include \"ucnid.h\"\n \n /* Returns 1 if C is valid in an identifier, 2 if C is valid except at\n    the start of an identifier, and 0 if C is not valid in an\n@@ -864,8 +867,9 @@ ucn_valid_in_identifier (cpp_reader *pfile, cppchar_t c,\n \t\t\t struct normalize_state *nst)\n {\n   int mn, mx, md;\n+  unsigned short valid_flags, invalid_start_flags;\n \n-  if (c > 0xFFFF)\n+  if (c > 0x10FFFF)\n     return 0;\n \n   mn = 0;\n@@ -881,15 +885,25 @@ ucn_valid_in_identifier (cpp_reader *pfile, cppchar_t c,\n \n   /* When -pedantic, we require the character to have been listed by\n      the standard for the current language.  Otherwise, we accept the\n-     union of the acceptable sets for C++98 and C99.  */\n-  if (! (ucnranges[mn].flags & (C99 | CXX)))\n+     union of the acceptable sets for all supported language versions.  */\n+  valid_flags = C99 | CXX | C11;\n+  if (CPP_PEDANTIC (pfile))\n+    {\n+      if (CPP_OPTION (pfile, c11_identifiers))\n+\tvalid_flags = C11;\n+      else if (CPP_OPTION (pfile, c99))\n+\tvalid_flags = C99;\n+      else if (CPP_OPTION (pfile, cplusplus))\n+\tvalid_flags = CXX;\n+    }\n+  if (! (ucnranges[mn].flags & valid_flags))\n       return 0;\n-\n-  if (CPP_PEDANTIC (pfile)\n-      && ((CPP_OPTION (pfile, c99) && !(ucnranges[mn].flags & C99))\n-\t  || (CPP_OPTION (pfile, cplusplus)\n-\t      && !(ucnranges[mn].flags & CXX))))\n-    return 0;\n+  if (CPP_OPTION (pfile, c11_identifiers))\n+    invalid_start_flags = N11;\n+  else if (CPP_OPTION (pfile, c99))\n+    invalid_start_flags = N99;\n+  else\n+    invalid_start_flags = 0;\n \n   /* Update NST.  */\n   if (ucnranges[mn].combine != 0 && ucnranges[mn].combine < nst->prev_class)\n@@ -899,38 +913,26 @@ ucn_valid_in_identifier (cpp_reader *pfile, cppchar_t c,\n       bool safe;\n       cppchar_t p = nst->previous;\n \n-      /* Easy cases from Bengali, Oriya, Tamil, Jannada, and Malayalam.  */\n-      if (c == 0x09BE)\n-\tsafe = p != 0x09C7;  /* Use 09CB instead of 09C7 09BE.  */\n-      else if (c == 0x0B3E)\n-\tsafe = p != 0x0B47;  /* Use 0B4B instead of 0B47 0B3E.  */\n-      else if (c == 0x0BBE)\n-\tsafe = p != 0x0BC6 && p != 0x0BC7;  /* Use 0BCA/0BCB instead.  */\n-      else if (c == 0x0CC2)\n-\tsafe = p != 0x0CC6;  /* Use 0CCA instead of 0CC6 0CC2.  */\n-      else if (c == 0x0D3E)\n-\tsafe = p != 0x0D46 && p != 0x0D47;  /* Use 0D4A/0D4B instead.  */\n       /* For Hangul, characters in the range AC00-D7A3 are NFC/NFKC,\n \t and are combined algorithmically from a sequence of the form\n \t 1100-1112 1161-1175 11A8-11C2\n \t (if the third is not present, it is treated as 11A7, which is not\n \t really a valid character).\n \t Unfortunately, C99 allows (only) the NFC form, but C++ allows\n \t only the combining characters.  */\n-      else if (c >= 0x1161 && c <= 0x1175)\n+      if (c >= 0x1161 && c <= 0x1175)\n \tsafe = p < 0x1100 || p > 0x1112;\n       else if (c >= 0x11A8 && c <= 0x11C2)\n \tsafe = (p < 0xAC00 || p > 0xD7A3 || (p - 0xAC00) % 28 != 0);\n       else\n+\tsafe = check_nfc (pfile, c, p);\n+      if (!safe)\n \t{\n-\t  /* Uh-oh, someone updated ucnid.h without updating this code.  */\n-\t  cpp_error (pfile, CPP_DL_ICE, \"Character %x might not be NFKC\", c);\n-\t  safe = true;\n+\t  if ((c >= 0x1161 && c <= 0x1175) || (c >= 0x11A8 && c <= 0x11C2))\n+\t    nst->level = MAX (nst->level, normalized_identifier_C);\n+\t  else\n+\t    nst->level = normalized_none;\n \t}\n-      if (!safe && c < 0x1161)\n-\tnst->level = normalized_none;\n-      else if (!safe)\n-\tnst->level = MAX (nst->level, normalized_identifier_C);\n     }\n   else if (ucnranges[mn].flags & NKC)\n     ;\n@@ -940,11 +942,13 @@ ucn_valid_in_identifier (cpp_reader *pfile, cppchar_t c,\n     nst->level = MAX (nst->level, normalized_identifier_C);\n   else\n     nst->level = normalized_none;\n-  nst->previous = c;\n+  if (ucnranges[mn].combine == 0)\n+    nst->previous = c;\n   nst->prev_class = ucnranges[mn].combine;\n \n-  /* In C99, UCN digits may not begin identifiers.  */\n-  if (CPP_OPTION (pfile, c99) && (ucnranges[mn].flags & DIG))\n+  /* In C99, UCN digits may not begin identifiers.  In C11 and C++11,\n+     UCN combining characters may not begin identifiers.  */\n+  if (ucnranges[mn].flags & invalid_start_flags)\n     return 2;\n \n   return 1;\n@@ -1054,7 +1058,7 @@ _cpp_valid_ucn (cpp_reader *pfile, const uchar **pstr,\n \t  CPP_OPTION (pfile, warn_dollars) = 0;\n \t  cpp_error (pfile, CPP_DL_PEDWARN, \"'$' in identifier or number\");\n \t}\n-      NORMALIZE_STATE_UPDATE_IDNUM (nst);\n+      NORMALIZE_STATE_UPDATE_IDNUM (nst, result);\n     }\n   else if (identifier_pos)\n     {"}, {"sha": "7540e05383f35888b950df69b146d57fade4f11a", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f4ff8b51b8875a7862fae1fb574735db4bfd36/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f4ff8b51b8875a7862fae1fb574735db4bfd36/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=d3f4ff8b51b8875a7862fae1fb574735db4bfd36", "patch": "@@ -437,6 +437,10 @@ struct cpp_options\n      literal number suffixes as user-defined literal number suffixes.  */\n   unsigned char ext_numeric_literals;\n \n+  /* Nonzero means extended identifiers allow the characters specified\n+     in C11 and C++11.  */\n+  unsigned char c11_identifiers;\n+\n   /* Nonzero for C++ 2014 Standard binary constants.  */\n   unsigned char binary_constants;\n "}, {"sha": "aba295cd1bed2ba3be3a890eecc4a37159758a68", "filename": "libcpp/init.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f4ff8b51b8875a7862fae1fb574735db4bfd36/libcpp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f4ff8b51b8875a7862fae1fb574735db4bfd36/libcpp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finit.c?ref=d3f4ff8b51b8875a7862fae1fb574735db4bfd36", "patch": "@@ -77,6 +77,7 @@ struct lang_flags\n   char cplusplus;\n   char extended_numbers;\n   char extended_identifiers;\n+  char c11_identifiers;\n   char std;\n   char cplusplus_comments;\n   char digraphs;\n@@ -88,21 +89,21 @@ struct lang_flags\n };\n \n static const struct lang_flags lang_defaults[] =\n-{ /*              c99 c++ xnum xid std  //   digr ulit rlit udlit bin_cst dig_sep */\n-  /* GNUC89   */  { 0,  0,  1,   0,  0,   1,   1,   0,   0,   0,    0,      0 },\n-  /* GNUC99   */  { 1,  0,  1,   0,  0,   1,   1,   1,   1,   0,    0,      0 },\n-  /* GNUC11   */  { 1,  0,  1,   0,  0,   1,   1,   1,   1,   0,    0,      0 },\n-  /* STDC89   */  { 0,  0,  0,   0,  1,   0,   0,   0,   0,   0,    0,      0 },\n-  /* STDC94   */  { 0,  0,  0,   0,  1,   0,   1,   0,   0,   0,    0,      0 },\n-  /* STDC99   */  { 1,  0,  1,   0,  1,   1,   1,   0,   0,   0,    0,      0 },\n-  /* STDC11   */  { 1,  0,  1,   0,  1,   1,   1,   1,   0,   0,    0,      0 },\n-  /* GNUCXX   */  { 0,  1,  1,   0,  0,   1,   1,   0,   0,   0,    0,      0 },\n-  /* CXX98    */  { 0,  1,  1,   0,  1,   1,   1,   0,   0,   0,    0,      0 },\n-  /* GNUCXX11 */  { 1,  1,  1,   0,  0,   1,   1,   1,   1,   1,    0,      0 },\n-  /* CXX11    */  { 1,  1,  1,   0,  1,   1,   1,   1,   1,   1,    0,      0 },\n-  /* GNUCXX1Y */  { 1,  1,  1,   0,  0,   1,   1,   1,   1,   1,    1,      1 },\n-  /* CXX1Y    */  { 1,  1,  1,   0,  1,   1,   1,   1,   1,   1,    1,      1 },\n-  /* ASM      */  { 0,  0,  1,   0,  0,   1,   0,   0,   0,   0,    0,      0 }\n+{ /*              c99 c++ xnum xid c11 std  //   digr ulit rlit udlit bin_cst dig_sep */\n+  /* GNUC89   */  { 0,  0,  1,   0,  0,  0,   1,   1,   0,   0,   0,    0,      0 },\n+  /* GNUC99   */  { 1,  0,  1,   0,  0,  0,   1,   1,   1,   1,   0,    0,      0 },\n+  /* GNUC11   */  { 1,  0,  1,   0,  1,  0,   1,   1,   1,   1,   0,    0,      0 },\n+  /* STDC89   */  { 0,  0,  0,   0,  0,  1,   0,   0,   0,   0,   0,    0,      0 },\n+  /* STDC94   */  { 0,  0,  0,   0,  0,  1,   0,   1,   0,   0,   0,    0,      0 },\n+  /* STDC99   */  { 1,  0,  1,   0,  0,  1,   1,   1,   0,   0,   0,    0,      0 },\n+  /* STDC11   */  { 1,  0,  1,   0,  1,  1,   1,   1,   1,   0,   0,    0,      0 },\n+  /* GNUCXX   */  { 0,  1,  1,   0,  0,  0,   1,   1,   0,   0,   0,    0,      0 },\n+  /* CXX98    */  { 0,  1,  1,   0,  0,  1,   1,   1,   0,   0,   0,    0,      0 },\n+  /* GNUCXX11 */  { 1,  1,  1,   0,  1,  0,   1,   1,   1,   1,   1,    0,      0 },\n+  /* CXX11    */  { 1,  1,  1,   0,  1,  1,   1,   1,   1,   1,   1,    0,      0 },\n+  /* GNUCXX1Y */  { 1,  1,  1,   0,  1,  0,   1,   1,   1,   1,   1,    1,      1 },\n+  /* CXX1Y    */  { 1,  1,  1,   0,  1,  1,   1,   1,   1,   1,   1,    1,      1 },\n+  /* ASM      */  { 0,  0,  1,   0,  0,  0,   1,   0,   0,   0,   0,    0,      0 }\n   /* xid should be 1 for GNUC99, STDC99, GNUCXX, CXX98, GNUCXX11, CXX11,\n      GNUCXX1Y, and CXX1Y when no longer experimental (when all uses of\n      identifiers in the compiler have been audited for correct handling\n@@ -121,6 +122,7 @@ cpp_set_lang (cpp_reader *pfile, enum c_lang lang)\n   CPP_OPTION (pfile, cplusplus)\t\t\t = l->cplusplus;\n   CPP_OPTION (pfile, extended_numbers)\t\t = l->extended_numbers;\n   CPP_OPTION (pfile, extended_identifiers)\t = l->extended_identifiers;\n+  CPP_OPTION (pfile, c11_identifiers)\t\t = l->c11_identifiers;\n   CPP_OPTION (pfile, std)\t\t\t = l->std;\n   CPP_OPTION (pfile, trigraphs)\t\t\t = l->std;\n   CPP_OPTION (pfile, cplusplus_comments)\t = l->cplusplus_comments;"}, {"sha": "532145824c80d0505e8d11e275ebc4ae54e499b1", "filename": "libcpp/internal.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f4ff8b51b8875a7862fae1fb574735db4bfd36/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f4ff8b51b8875a7862fae1fb574735db4bfd36/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=d3f4ff8b51b8875a7862fae1fb574735db4bfd36", "patch": "@@ -713,20 +713,21 @@ extern size_t _cpp_replacement_text_len (const cpp_macro *);\n \n struct normalize_state \n {\n-  /* The previous character.  */\n+  /* The previous starter character.  */\n   cppchar_t previous;\n-  /* The combining class of the previous character.  */\n+  /* The combining class of the previous character (whether or not a\n+     starter).  */\n   unsigned char prev_class;\n   /* The lowest normalization level so far.  */\n   enum cpp_normalize_level level;\n };\n #define INITIAL_NORMALIZE_STATE { 0, 0, normalized_KC }\n #define NORMALIZE_STATE_RESULT(st) ((st)->level)\n \n-/* We saw a character that matches ISIDNUM(), update a\n+/* We saw a character C that matches ISIDNUM(), update a\n    normalize_state appropriately.  */\n-#define NORMALIZE_STATE_UPDATE_IDNUM(st) \\\n-  ((st)->previous = 0, (st)->prev_class = 0)\n+#define NORMALIZE_STATE_UPDATE_IDNUM(st, c)\t\\\n+  ((st)->previous = (c), (st)->prev_class = 0)\n \n extern cppchar_t _cpp_valid_ucn (cpp_reader *, const unsigned char **,\n \t\t\t\t const unsigned char *, int,"}, {"sha": "99c2140c357af8c0bfc5dc4b2a1037380759cafc", "filename": "libcpp/lex.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f4ff8b51b8875a7862fae1fb574735db4bfd36/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f4ff8b51b8875a7862fae1fb574735db4bfd36/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=d3f4ff8b51b8875a7862fae1fb574735db4bfd36", "patch": "@@ -1204,20 +1204,23 @@ lex_identifier (cpp_reader *pfile, const uchar *base, bool starts_ucn,\n \n   cur = pfile->buffer->cur;\n   if (! starts_ucn)\n-    while (ISIDNUM (*cur))\n-      {\n-\thash = HT_HASHSTEP (hash, *cur);\n-\tcur++;\n-      }\n+    {\n+      while (ISIDNUM (*cur))\n+\t{\n+\t  hash = HT_HASHSTEP (hash, *cur);\n+\t  cur++;\n+\t}\n+      NORMALIZE_STATE_UPDATE_IDNUM (nst, *(cur - 1));\n+    }\n   pfile->buffer->cur = cur;\n   if (starts_ucn || forms_identifier_p (pfile, false, nst))\n     {\n       /* Slower version for identifiers containing UCNs (or $).  */\n       do {\n \twhile (ISIDNUM (*pfile->buffer->cur))\n \t  {\n+\t    NORMALIZE_STATE_UPDATE_IDNUM (nst, *pfile->buffer->cur);\n \t    pfile->buffer->cur++;\n-\t    NORMALIZE_STATE_UPDATE_IDNUM (nst);\n \t  }\n       } while (forms_identifier_p (pfile, false, nst));\n       result = _cpp_interpret_identifier (pfile, base,\n@@ -1277,8 +1280,8 @@ lex_number (cpp_reader *pfile, cpp_string *number,\n       while (ISIDNUM (*cur) || *cur == '.' || DIGIT_SEP (*cur)\n \t     || VALID_SIGN (*cur, cur[-1]))\n \t{\n+\t  NORMALIZE_STATE_UPDATE_IDNUM (nst, *cur);\n \t  cur++;\n-\t  NORMALIZE_STATE_UPDATE_IDNUM (nst);\n \t}\n \n       pfile->buffer->cur = cur;"}, {"sha": "2697c6b7cac8d6a1623f7861d80f3ea7f40c7ed5", "filename": "libcpp/makeucnid.c", "status": "modified", "additions": 136, "deletions": 24, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f4ff8b51b8875a7862fae1fb574735db4bfd36/libcpp%2Fmakeucnid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f4ff8b51b8875a7862fae1fb574735db4bfd36/libcpp%2Fmakeucnid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmakeucnid.c?ref=d3f4ff8b51b8875a7862fae1fb574735db4bfd36", "patch": "@@ -29,15 +29,22 @@ along with this program; see the file COPYING3.  If not see\n enum {\n   C99 = 1,\n   CXX = 2,\n-  digit = 4,\n-  not_NFC = 8,\n-  not_NFKC = 16,\n-  maybe_not_NFC = 32\n+  N99 = 4,\n+  C11 = 8,\n+  N11 = 16,\n+  all_languages = C99 | CXX | C11,\n+  not_NFC = 32,\n+  not_NFKC = 64,\n+  maybe_not_NFC = 128\n };\n \n-static unsigned flags[65536];\n-static unsigned short decomp[65536][2];\n-static unsigned char combining_value[65536];\n+#define NUM_CODE_POINTS 0x110000\n+#define MAX_CODE_POINT 0x10ffff\n+\n+static unsigned flags[NUM_CODE_POINTS];\n+static unsigned int all_decomp[NUM_CODE_POINTS][2];\n+static unsigned int decomp[NUM_CODE_POINTS][2];\n+static unsigned char combining_value[NUM_CODE_POINTS];\n \n /* Die!  */\n \n@@ -48,7 +55,7 @@ fail (const char *s)\n   exit (1);\n }\n \n-/* Read ucnid.tab and set the C99 and CXX flags in header[].  */\n+/* Read ucnid.tab and set the flags for language versions in header[].  */\n \n static void\n read_ucnid (const char *fname)\n@@ -66,10 +73,14 @@ read_ucnid (const char *fname)\n \tbreak;\n       if (strcmp (line, \"[C99]\\n\") == 0)\n \tfl = C99;\n-      if (strcmp (line, \"[C99DIG]\\n\") == 0)\n-\tfl = C99|digit;\n+      else if (strcmp (line, \"[C99DIG]\\n\") == 0)\n+\tfl = C99|N99;\n       else if (strcmp (line, \"[CXX]\\n\") == 0)\n \tfl = CXX;\n+      else if (strcmp (line, \"[C11]\\n\") == 0)\n+\tfl = C11;\n+      else if (strcmp (line, \"[C11NOSTART]\\n\") == 0)\n+\tfl = C11|N11;\n       else if (isxdigit (line[0]))\n \t{\n \t  char *l = line;\n@@ -94,7 +105,7 @@ read_ucnid (const char *fname)\n \t\t}\n \t      while (isspace (*l))\n \t\tl++;\n-\t      if (end > 0xFFFF)\n+\t      if (end > MAX_CODE_POINT)\n \t\tfail (\"parsing ucnid.tab, end too large\");\n \t      while (start <= end)\n \t\tflags[start++] |= fl;\n@@ -108,8 +119,10 @@ read_ucnid (const char *fname)\n \n /* Read UnicodeData.txt and fill in the 'decomp' table to be the\n    decompositions of characters for which both the character\n-   decomposed and all the code points in the decomposition are either\n-   C99 or CXX.  */\n+   decomposed and all the code points in the decomposition are valid\n+   for some supported language version, and the 'all_decomp' table to\n+   be the decompositions of all characters without those\n+   constraints.  */\n \n static void\n read_table (char *fname)\n@@ -123,16 +136,16 @@ read_table (char *fname)\n       char line[256];\n       unsigned long codepoint, this_decomp[4];\n       char *l;\n-      int i;\n+      int i, j;\n       int decomp_useful;\n \n       if (!fgets (line, sizeof (line), f))\n \tbreak;\n       codepoint = strtoul (line, &l, 16);\n       if (l == line || *l != ';')\n \tfail (\"parsing UnicodeData.txt, reading code point\");\n-      if (codepoint > 0xffff || ! (flags[codepoint] & (C99 | CXX)))\n-\tcontinue;\n+      if (codepoint > MAX_CODE_POINT)\n+\tfail (\"parsing UnicodeData.txt, code point too large\");\n \n       do {\n \tl++;\n@@ -171,7 +184,9 @@ read_table (char *fname)\n \t}\n       if (i > 2)  /* Decomposition too long.  */\n \tfail (\"parsing UnicodeData.txt, decomposition too long\");\n-      if (decomp_useful)\n+      for (j = 0; j < i; j++)\n+\tall_decomp[codepoint][j] = this_decomp[j];\n+      if ((flags[codepoint] & all_languages) && decomp_useful)\n \twhile (--i >= 0)\n \t  decomp[codepoint][i] = this_decomp[i];\n     }\n@@ -208,8 +223,8 @@ read_derived (const char *fname)\n       start = strtoul (line, &l, 16);\n       if (l == line)\n \tfail (\"parsing DerivedNormalizationProps.txt, reading start\");\n-      if (start > 0xffff)\n-\tcontinue;\n+      if (start > MAX_CODE_POINT)\n+\tfail (\"parsing DerivedNormalizationProps.txt, code point too large\");\n       if (*l == '.' && l[1] == '.')\n \tend = strtoul (l + 2, &l, 16);\n       else\n@@ -237,17 +252,21 @@ write_table (void)\n   unsigned last_flag = flags[0];\n   bool really_safe = decomp[0][0] == 0;\n   unsigned char last_combine = combining_value[0];\n+\n+  printf (\"static const struct ucnrange ucnranges[] = {\\n\");\n   \n-  for (i = 1; i <= 65536; i++)\n-    if (i == 65536\n-\t|| (flags[i] != last_flag && ((flags[i] | last_flag) & (C99 | CXX)))\n+  for (i = 1; i <= NUM_CODE_POINTS; i++)\n+    if (i == NUM_CODE_POINTS\n+\t|| (flags[i] != last_flag && ((flags[i] | last_flag) & all_languages))\n \t|| really_safe != (decomp[i][0] == 0)\n \t|| combining_value[i] != last_combine)\n       {\n-\tprintf (\"{ %s|%s|%s|%s|%s|%s|%s, %3d, %#06x },\\n\",\n+\tprintf (\"{ %s|%s|%s|%s|%s|%s|%s|%s|%s, %3d, %#06x },\\n\",\n \t\tlast_flag & C99 ? \"C99\" : \"  0\",\n-\t\tlast_flag & digit ? \"DIG\" : \"  0\",\n+\t\tlast_flag & N99 ? \"N99\" : \"  0\",\n \t\tlast_flag & CXX ? \"CXX\" : \"  0\",\n+\t\tlast_flag & C11 ? \"C11\" : \"  0\",\n+\t\tlast_flag & N11 ? \"N11\" : \"  0\",\n \t\treally_safe ? \"CID\" : \"  0\",\n \t\tlast_flag & not_NFC ? \"  0\" : \"NFC\",\n \t\tlast_flag & not_NFKC ? \"  0\" : \"NKC\",\n@@ -258,6 +277,98 @@ write_table (void)\n \tlast_combine = combining_value[0];\n \treally_safe = decomp[i][0] == 0;\n       }\n+\n+  printf (\"};\\n\");\n+}\n+\n+/* Return whether a given character is valid in an identifier for some\n+   supported language, either as itself or as a UCN.  */\n+\n+static bool\n+char_id_valid (unsigned int c)\n+{\n+  return ((flags[c] & all_languages)\n+\t  || (c == 0x24)\n+\t  || (c >= 0x30 && c <= 0x39)\n+\t  || (c >= 0x41 && c <= 0x5a)\n+\t  || (c >= 0x61 && c <= 0x7a));\n+}\n+\n+/* Write out the switch statement over characters for which it is\n+   context-dependent whether they are in NFC.  */\n+\n+static void\n+write_context_switch (void)\n+{\n+  unsigned i;\n+  printf (\"static bool\\n\"\n+\t  \"check_nfc (cpp_reader *pfile, cppchar_t c, cppchar_t p)\\n\"\n+\t  \"{\\n\"\n+\t  \"  switch (c)\\n\"\n+\t  \"    {\\n\");\n+  for (i = 0; i < NUM_CODE_POINTS; i++)\n+    {\n+      bool found_case = false;\n+      unsigned j;\n+      if (!(flags[i] & all_languages) || !(flags[i] & maybe_not_NFC))\n+\tcontinue;\n+      if ((i >= 0x1161 && i <= 0x1175) || (i >= 0x11A8 && i <= 0x11C2))\n+\tcontinue; /* Hangul handled algorithmically.  */\n+      printf (\"    case %#06x:\\n\"\n+\t      \"      switch (p)\\n\"\n+\t      \"\\t{\\n\", i);\n+      /* If an NFC starter character decomposes with this character I\n+\t as the second character and an NFC starter character S as the\n+\t first character, that latter character as a previous\n+\t character means this character is not NFC.  Furthermore, any\n+\t NFC starter character K made by a series of compositions of S\n+\t with combining characters whose combining class is greater\n+\t than that of I also means this character is not NFC.  */\n+      for (j = 0; j < NUM_CODE_POINTS; j++)\n+\t{\n+\t  unsigned s, k;\n+\t  if (all_decomp[j][1] != i)\n+\t    continue;\n+\t  s = all_decomp[j][0];\n+\t  if (combining_value[s] != 0 || (flags[s] & not_NFC) != 0)\n+\t    continue;\n+\t  if (char_id_valid (s))\n+\t    {\n+\t      found_case = true;\n+\t      printf (\"\\tcase %#06x:\\n\", s);\n+\t    }\n+\t  for (k = 0; k < NUM_CODE_POINTS; k++)\n+\t    {\n+\t      unsigned t = k;\n+\t      if (k == s || !char_id_valid (k))\n+\t\tcontinue;\n+\t      while (all_decomp[t][1] != 0\n+\t\t     && combining_value[all_decomp[t][1]] > combining_value[i])\n+\t\t{\n+\t\t  if (combining_value[t] != 0 || (flags[t] & not_NFC) != 0)\n+\t\t    break;\n+\t\t  t = all_decomp[t][0];\n+\t\t}\n+\t      if (t == s)\n+\t\t{\n+\t\t  found_case = true;\n+\t\t  printf (\"\\tcase %#06x:\\n\", k);\n+\t\t}\n+\t    }\n+\t}\n+      if (found_case)\n+\tprintf (\"\\t  return false;\\n\");\n+      else\n+\tprintf (\"\\t/* Non-NFC cases not applicable to C/C++.  */\\n\");\n+      printf (\"\\tdefault:\\n\"\n+\t      \"\\t  return true;\\n\"\n+\t      \"\\t}\\n\\n\");\n+    }\n+  printf (\"    default:\\n\"\n+\t  \"      cpp_error (pfile, CPP_DL_ICE, \\\"Character %%x might not be NFKC\\\", c);\\n\"\n+\t  \"      return true;\\n\"\n+\t  \"  }\\n\"\n+\t  \"}\\n\");\n }\n \n /* Print out the huge copyright notice.  */\n@@ -336,5 +447,6 @@ main(int argc, char ** argv)\n \n   write_copyright ();\n   write_table ();\n+  write_context_switch ();\n   return 0;\n }"}, {"sha": "352e95cb206aa9d83c4e3360aedeefc17bd8fd92", "filename": "libcpp/ucnid.h", "status": "modified", "additions": 4470, "deletions": 746, "changes": 5216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f4ff8b51b8875a7862fae1fb574735db4bfd36/libcpp%2Fucnid.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f4ff8b51b8875a7862fae1fb574735db4bfd36/libcpp%2Fucnid.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fucnid.h?ref=d3f4ff8b51b8875a7862fae1fb574735db4bfd36"}, {"sha": "68d9e068b317a2d0ef19629cc6f5efd632853cc3", "filename": "libcpp/ucnid.tab", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f4ff8b51b8875a7862fae1fb574735db4bfd36/libcpp%2Fucnid.tab", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f4ff8b51b8875a7862fae1fb574735db4bfd36/libcpp%2Fucnid.tab", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fucnid.tab?ref=d3f4ff8b51b8875a7862fae1fb574735db4bfd36", "patch": "@@ -19,7 +19,8 @@\n ; D, which is itself a reproduction from ISO/IEC TR 10176:1998, and\n ; the similar table from ISO/IEC 14882:1988 (C++98) Annex E, which is\n ; a reproduction of ISO/IEC PDTR 10176.  Unfortunately these tables\n-; are not identical.\n+; are not identical.  It also reproduces the somewhat different tables\n+; in C11 and C++11, which are identical to each other.\n \n [C99]\n \n@@ -209,3 +210,34 @@ fbd3-fd3f fd50-fd8f fd92-fdc7 fdf0-fdfb fe70-fe72 fe74 fe76-fefc\n ff21-ff3a ff41-ff5a ff66-ffbe ffc2-ffc7 ffca-ffcf ffd2-ffd7\n ffda-ffdc 4e00-9fa5\n \n+[C11]\n+; Group 1\n+00a8 00aa 00ad 00af 00b2-00b5 00b7-00ba 00bc-00be 00c0-00d6 00d8-00f6\n+00f8-00ff\n+\n+; Group 2, minus characters under C11NOSTART\n+0100-02ff 0370-167f 1681-180d 180f-1dbf 1e00-1fff\n+\n+; Group 3\n+200b-200d 202a-202e 203f-2040 2054 2060-206f\n+\n+; Group 4, minus characters under C11NOSTART\n+2070-20cf 2100-218f 2460-24ff 2776-2793 2c00-2dff 2e80-2fff\n+\n+; Group 5\n+3004-3007 3021-302f 3031-303f\n+\n+; Group 6\n+3040-d7ff\n+\n+; Group 7, minus characters under C11NOSTART\n+f900-fd3d fd40-fdcf fdf0-fe1f fe30-fe44 fe47-fffd\n+\n+; Group 8\n+10000-1fffd 20000-2fffd 30000-3fffd 40000-4fffd 50000-5fffd\n+60000-6fffd 70000-7fffd 80000-8fffd 90000-9fffd a0000-afffd\n+b0000-bfffd c0000-cfffd d0000-dfffd e0000-efffd\n+\n+[C11NOSTART]\n+; Group 1\n+0300-036f 1dc0-1dff 20d0-20ff fe20-fe2f"}]}