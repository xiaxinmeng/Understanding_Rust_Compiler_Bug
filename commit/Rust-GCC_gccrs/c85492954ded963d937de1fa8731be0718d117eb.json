{"sha": "c85492954ded963d937de1fa8731be0718d117eb", "node_id": "C_kwDOANBUbNoAKGM4NTQ5Mjk1NGRlZDk2M2Q5MzdkZTFmYTg3MzFiZTA3MThkMTE3ZWI", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-10-14T09:31:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-14T09:31:25Z"}, "message": "Merge #1587\n\n1587: Method resolution must support multiple candidates r=philberty a=philberty\n\nThis patch fixes bad method resolution in our operator_overload_9 case.\r\nWhen we have a &mut reference to something and we deref we must resolve to\r\nthe mutable reference impl block. The interface we are using to resolve\r\nmethods is the can_eq interface which allows for permissive mutability\r\nwhich means allowing for mutable reference being unified with an immutable\r\none. This meant we actual match against both the immutable and mutable\r\nversion leading to multiple candidate error.\r\n\r\nFixes #1588\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "e8ff7ab3eff4e48ce02f8084547ad31d73fb8c5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8ff7ab3eff4e48ce02f8084547ad31d73fb8c5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c85492954ded963d937de1fa8731be0718d117eb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjSSxtCRBK7hj4Ov3rIwAAjIUIAHyI3Yi8YJs50Z60kJzpR9Uv\nteFdbAOB+HB+j5CHrvgj2QmqsuehxPDR+CJwfoCL7q66gcvVBTMihQWFmWc5Lf60\nYdNAdgr0xJW4VZPtzzZt+RXtNgqtL9Lcp6xr67W3cStuuK2sGBThkA32zZTJff4R\n4xDX+ix49g5CRvUhcwrX84a5a8mFLb6Tbufqmkjp42zo5EF9+MlKfobkTi5bijCL\ntUXL1FzgWQKpHu3Kmap4zmkn4cQw6kQvpicbz3psBgnY6LlZoEr2UTNq21peqFt2\nOUiYyPS6ZfvUVw4754ZzvPUzGX+59PHXiE0aTucQ9thABf6UxiJYgVo9T7rHzTE=\n=4stU\n-----END PGP SIGNATURE-----\n", "payload": "tree e8ff7ab3eff4e48ce02f8084547ad31d73fb8c5a\nparent 84ca2f9123a7d5206d70d5b3bdc18d98c0cee2e0\nparent 9bac2dbfe999b0dffea65b9a1b6ed0a257edf3c8\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1665739885 +0000\ncommitter GitHub <noreply@github.com> 1665739885 +0000\n\nMerge #1587\n\n1587: Method resolution must support multiple candidates r=philberty a=philberty\n\nThis patch fixes bad method resolution in our operator_overload_9 case.\r\nWhen we have a &mut reference to something and we deref we must resolve to\r\nthe mutable reference impl block. The interface we are using to resolve\r\nmethods is the can_eq interface which allows for permissive mutability\r\nwhich means allowing for mutable reference being unified with an immutable\r\none. This meant we actual match against both the immutable and mutable\r\nversion leading to multiple candidate error.\r\n\r\nFixes #1588\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c85492954ded963d937de1fa8731be0718d117eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c85492954ded963d937de1fa8731be0718d117eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c85492954ded963d937de1fa8731be0718d117eb/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84ca2f9123a7d5206d70d5b3bdc18d98c0cee2e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84ca2f9123a7d5206d70d5b3bdc18d98c0cee2e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84ca2f9123a7d5206d70d5b3bdc18d98c0cee2e0"}, {"sha": "9bac2dbfe999b0dffea65b9a1b6ed0a257edf3c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bac2dbfe999b0dffea65b9a1b6ed0a257edf3c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bac2dbfe999b0dffea65b9a1b6ed0a257edf3c8"}], "stats": {"total": 188, "additions": 157, "deletions": 31}, "files": [{"sha": "7b176beaaeb712509a6bf0096e522257922630ec", "filename": "gcc/rust/typecheck/rust-autoderef.cc", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85492954ded963d937de1fa8731be0718d117eb/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85492954ded963d937de1fa8731be0718d117eb/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc?ref=c85492954ded963d937de1fa8731be0718d117eb", "patch": "@@ -139,15 +139,23 @@ resolve_operator_overload_fn (\n     return false;\n \n   auto segment = HIR::PathIdentSegment (associated_item_name);\n-  auto candidate\n+  auto candidates\n     = MethodResolver::Probe (ty, HIR::PathIdentSegment (associated_item_name),\n \t\t\t     true);\n \n-  bool have_implementation_for_lang_item = !candidate.is_error ();\n+  bool have_implementation_for_lang_item = !candidates.empty ();\n   if (!have_implementation_for_lang_item)\n     return false;\n \n+  // multiple candidates?\n+  if (candidates.size () > 1)\n+    {\n+      // error out? probably not for this case\n+      return false;\n+    }\n+\n   // Get the adjusted self\n+  auto candidate = *candidates.begin ();\n   Adjuster adj (ty);\n   TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n "}, {"sha": "46547aa20e069c21235e0270c45ef2c8eaa80554", "filename": "gcc/rust/typecheck/rust-hir-dot-operator.cc", "status": "modified", "additions": 67, "deletions": 13, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85492954ded963d937de1fa8731be0718d117eb/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85492954ded963d937de1fa8731be0718d117eb/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc?ref=c85492954ded963d937de1fa8731be0718d117eb", "patch": "@@ -25,18 +25,17 @@ namespace Resolver {\n \n MethodResolver::MethodResolver (bool autoderef_flag,\n \t\t\t\tconst HIR::PathIdentSegment &segment_name)\n-  : AutoderefCycle (autoderef_flag), segment_name (segment_name),\n-    try_result (MethodCandidate::get_error ())\n+  : AutoderefCycle (autoderef_flag), segment_name (segment_name), result ()\n {}\n \n-MethodCandidate\n+std::set<MethodCandidate>\n MethodResolver::Probe (const TyTy::BaseType *receiver,\n \t\t       const HIR::PathIdentSegment &segment_name,\n \t\t       bool autoderef_flag)\n {\n   MethodResolver resolver (autoderef_flag, segment_name);\n-  bool ok = resolver.cycle (receiver);\n-  return ok ? resolver.try_result : MethodCandidate::get_error ();\n+  resolver.cycle (receiver);\n+  return resolver.result;\n }\n \n void\n@@ -177,8 +176,18 @@ MethodResolver::select (const TyTy::BaseType &receiver)\n \t      (unsigned long) trait_fns.size (),\n \t      (unsigned long) predicate_items.size ());\n \n-  for (auto impl_item : inherent_impl_fns)\n+  // see the follow for the proper fix to get rid of this we need to assemble\n+  // candidates based on a match expression gathering the relevant impl blocks\n+  // https://github.com/rust-lang/rust/blob/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/compiler/rustc_typeck/src/check/method/probe.rs#L580-L694\n+  TyTy::set_cmp_autoderef_mode ();\n+\n+  bool found_possible_candidate = false;\n+  for (auto &impl_item : inherent_impl_fns)\n     {\n+      bool is_trait_impl_block = impl_item.impl_block->has_trait_ref ();\n+      if (is_trait_impl_block)\n+\tcontinue;\n+\n       TyTy::FnType *fn = impl_item.ty;\n       rust_assert (fn->is_method ());\n \n@@ -190,13 +199,50 @@ MethodResolver::select (const TyTy::BaseType &receiver)\n \t{\n \t  PathProbeCandidate::ImplItemCandidate c{impl_item.item,\n \t\t\t\t\t\t  impl_item.impl_block};\n-\t  try_result = MethodCandidate{\n+\t  auto try_result = MethodCandidate{\n \t    PathProbeCandidate (PathProbeCandidate::CandidateType::IMPL_FUNC,\n \t\t\t\tfn, impl_item.item->get_locus (), c),\n \t    adjustments};\n-\t  return true;\n+\t  result.insert (std::move (try_result));\n+\t  found_possible_candidate = true;\n \t}\n     }\n+  if (found_possible_candidate)\n+    {\n+      TyTy::reset_cmp_autoderef_mode ();\n+      return true;\n+    }\n+\n+  for (auto &impl_item : inherent_impl_fns)\n+    {\n+      bool is_trait_impl_block = impl_item.impl_block->has_trait_ref ();\n+      if (!is_trait_impl_block)\n+\tcontinue;\n+\n+      TyTy::FnType *fn = impl_item.ty;\n+      rust_assert (fn->is_method ());\n+\n+      TyTy::BaseType *fn_self = fn->get_self_type ();\n+      rust_debug (\n+\t\"dot-operator trait_impl_item fn_self={%s} can_eq receiver={%s}\",\n+\tfn_self->debug_str ().c_str (), receiver.debug_str ().c_str ());\n+      if (fn_self->can_eq (&receiver, false))\n+\t{\n+\t  PathProbeCandidate::ImplItemCandidate c{impl_item.item,\n+\t\t\t\t\t\t  impl_item.impl_block};\n+\t  auto try_result = MethodCandidate{\n+\t    PathProbeCandidate (PathProbeCandidate::CandidateType::IMPL_FUNC,\n+\t\t\t\tfn, impl_item.item->get_locus (), c),\n+\t    adjustments};\n+\t  result.insert (std::move (try_result));\n+\t  found_possible_candidate = true;\n+\t}\n+    }\n+  if (found_possible_candidate)\n+    {\n+      TyTy::reset_cmp_autoderef_mode ();\n+      return true;\n+    }\n \n   for (auto trait_item : trait_fns)\n     {\n@@ -212,13 +258,19 @@ MethodResolver::select (const TyTy::BaseType &receiver)\n \t  PathProbeCandidate::TraitItemCandidate c{trait_item.reference,\n \t\t\t\t\t\t   trait_item.item_ref,\n \t\t\t\t\t\t   nullptr};\n-\t  try_result = MethodCandidate{\n+\t  auto try_result = MethodCandidate{\n \t    PathProbeCandidate (PathProbeCandidate::CandidateType::TRAIT_FUNC,\n \t\t\t\tfn, trait_item.item->get_locus (), c),\n \t    adjustments};\n-\t  return true;\n+\t  result.insert (std::move (try_result));\n+\t  found_possible_candidate = true;\n \t}\n     }\n+  if (found_possible_candidate)\n+    {\n+      TyTy::reset_cmp_autoderef_mode ();\n+      return true;\n+    }\n \n   for (const auto &predicate : predicate_items)\n     {\n@@ -238,15 +290,17 @@ MethodResolver::select (const TyTy::BaseType &receiver)\n \n \t  PathProbeCandidate::TraitItemCandidate c{trait_ref, trait_item,\n \t\t\t\t\t\t   nullptr};\n-\t  try_result = MethodCandidate{\n+\t  auto try_result = MethodCandidate{\n \t    PathProbeCandidate (PathProbeCandidate::CandidateType::TRAIT_FUNC,\n \t\t\t\tfn->clone (), trait_item->get_locus (), c),\n \t    adjustments};\n-\t  return true;\n+\t  result.insert (std::move (try_result));\n+\t  found_possible_candidate = true;\n \t}\n     }\n \n-  return false;\n+  TyTy::reset_cmp_autoderef_mode ();\n+  return found_possible_candidate;\n }\n \n std::vector<MethodResolver::predicate_candidate>"}, {"sha": "4cf7217ea0ba8c51365512dd19ebb3f4963ddfcc", "filename": "gcc/rust/typecheck/rust-hir-dot-operator.h", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85492954ded963d937de1fa8731be0718d117eb/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85492954ded963d937de1fa8731be0718d117eb/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h?ref=c85492954ded963d937de1fa8731be0718d117eb", "patch": "@@ -35,6 +35,13 @@ struct MethodCandidate\n   }\n \n   bool is_error () const { return candidate.is_error (); }\n+\n+  DefId get_defid () const { return candidate.get_defid (); }\n+\n+  bool operator< (const MethodCandidate &c) const\n+  {\n+    return get_defid () < c.get_defid ();\n+  }\n };\n \n class MethodResolver : private TypeCheckBase, protected AutoderefCycle\n@@ -46,9 +53,10 @@ class MethodResolver : private TypeCheckBase, protected AutoderefCycle\n     TyTy::FnType *fntype;\n   };\n \n-  static MethodCandidate Probe (const TyTy::BaseType *receiver,\n-\t\t\t\tconst HIR::PathIdentSegment &segment_name,\n-\t\t\t\tbool autoderef_flag = false);\n+  static std::set<MethodCandidate>\n+  Probe (const TyTy::BaseType *receiver,\n+\t const HIR::PathIdentSegment &segment_name,\n+\t bool autoderef_flag = false);\n \n   static std::vector<predicate_candidate> get_predicate_items (\n     const HIR::PathIdentSegment &segment_name, const TyTy::BaseType &receiver,\n@@ -68,7 +76,7 @@ class MethodResolver : private TypeCheckBase, protected AutoderefCycle\n   std::vector<MethodResolver::predicate_candidate> predicate_items;\n \n   // mutable fields\n-  MethodCandidate try_result;\n+  std::set<MethodCandidate> result;\n };\n \n } // namespace Resolver"}, {"sha": "823431eab4dca1d503cb37a074adbdfc404230c6", "filename": "gcc/rust/typecheck/rust-hir-inherent-impl-overlap.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85492954ded963d937de1fa8731be0718d117eb/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85492954ded963d937de1fa8731be0718d117eb/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h?ref=c85492954ded963d937de1fa8731be0718d117eb", "patch": "@@ -93,8 +93,9 @@ class OverlappingImplItemPass : public TypeCheckBase\n \n     HirId impl_type_id = impl->get_type ()->get_mappings ().get_hirid ();\n     TyTy::BaseType *impl_type = nullptr;\n-    bool ok = context->lookup_type (impl_type_id, &impl_type);\n-    rust_assert (ok);\n+    bool ok = query_type (impl_type_id, &impl_type);\n+    if (!ok)\n+      return;\n \n     std::string impl_item_name;\n     ok = ImplItemToName::resolve (impl_item, impl_item_name);"}, {"sha": "3411a2daccb5e5532e931490892d8e934e477228", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.cc", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85492954ded963d937de1fa8731be0718d117eb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85492954ded963d937de1fa8731be0718d117eb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc?ref=c85492954ded963d937de1fa8731be0718d117eb", "patch": "@@ -1015,10 +1015,10 @@ TypeCheckExpr::visit (HIR::MethodCallExpr &expr)\n \n   context->insert_receiver (expr.get_mappings ().get_hirid (), receiver_tyty);\n \n-  auto candidate\n+  auto candidates\n     = MethodResolver::Probe (receiver_tyty,\n \t\t\t     expr.get_method_name ().get_segment ());\n-  if (candidate.is_error ())\n+  if (candidates.empty ())\n     {\n       rust_error_at (\n \texpr.get_method_name ().get_locus (),\n@@ -1027,6 +1027,19 @@ TypeCheckExpr::visit (HIR::MethodCallExpr &expr)\n       return;\n     }\n \n+  if (candidates.size () > 1)\n+    {\n+      RichLocation r (expr.get_method_name ().get_locus ());\n+      for (auto &c : candidates)\n+\tr.add_range (c.candidate.locus);\n+\n+      rust_error_at (\n+\tr, \"multiple candidates found for method %<%s%>\",\n+\texpr.get_method_name ().get_segment ().as_string ().c_str ());\n+      return;\n+    }\n+\n+  auto candidate = *candidates.begin ();\n   rust_debug_loc (expr.get_method_name ().get_locus (),\n \t\t  \"resolved method to: {%u} {%s}\",\n \t\t  candidate.candidate.ty->get_ref (),\n@@ -1422,14 +1435,28 @@ TypeCheckExpr::resolve_operator_overload (\n     return false;\n \n   auto segment = HIR::PathIdentSegment (associated_item_name);\n-  auto candidate\n+  auto candidates\n     = MethodResolver::Probe (lhs, HIR::PathIdentSegment (associated_item_name));\n \n-  bool have_implementation_for_lang_item = !candidate.is_error ();\n+  bool have_implementation_for_lang_item = candidates.size () > 0;\n   if (!have_implementation_for_lang_item)\n     return false;\n \n+  if (candidates.size () > 1)\n+    {\n+      // mutliple candidates\n+      RichLocation r (expr.get_locus ());\n+      for (auto &c : candidates)\n+\tr.add_range (c.candidate.locus);\n+\n+      rust_error_at (\n+\tr, \"multiple candidates found for possible operator overload\");\n+\n+      return false;\n+    }\n+\n   // Get the adjusted self\n+  auto candidate = *candidates.begin ();\n   Adjuster adj (lhs);\n   TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n "}, {"sha": "cc8a180bdb097f8628a82bd6082f71dc7ab484a8", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85492954ded963d937de1fa8731be0718d117eb/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85492954ded963d937de1fa8731be0718d117eb/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=c85492954ded963d937de1fa8731be0718d117eb", "patch": "@@ -28,6 +28,10 @@\n namespace Rust {\n namespace TyTy {\n \n+// we need to fix this properly by implementing the match for assembling\n+// candidates\n+extern bool autoderef_cmp_flag;\n+\n class BaseCmp : public TyConstVisitor\n {\n public:\n@@ -1244,6 +1248,9 @@ class ReferenceCmp : public BaseCmp\n     auto other_base_type = type.get_base ();\n \n     bool mutability_ok = base->is_mutable () ? type.is_mutable () : true;\n+    if (autoderef_cmp_flag)\n+      mutability_ok = base->mutability () == type.mutability ();\n+\n     if (!mutability_ok)\n       {\n \tBaseCmp::visit (type);\n@@ -1289,9 +1296,10 @@ class PointerCmp : public BaseCmp\n     auto base_type = base->get_base ();\n     auto other_base_type = type.get_base ();\n \n-    // rust is permissive about mutablity here you can always go from mutable to\n-    // immutable but not the otherway round\n     bool mutability_ok = base->is_mutable () ? type.is_mutable () : true;\n+    if (autoderef_cmp_flag)\n+      mutability_ok = base->mutability () == type.mutability ();\n+\n     if (!mutability_ok)\n       {\n \tBaseCmp::visit (type);\n@@ -1370,7 +1378,7 @@ class ParamCmp : public BaseCmp\n \n   void visit (const ArrayType &) override { ok = true; }\n \n-  void visit (const SliceType &) override { ok = true; }\n+  void visit (const SliceType &) override { ok = !autoderef_cmp_flag; }\n \n   void visit (const BoolType &) override { ok = true; }\n "}, {"sha": "366de800b261616a417e4dbabcbcdececeed080f", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85492954ded963d937de1fa8731be0718d117eb/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85492954ded963d937de1fa8731be0718d117eb/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=c85492954ded963d937de1fa8731be0718d117eb", "patch": "@@ -32,6 +32,19 @@\n namespace Rust {\n namespace TyTy {\n \n+bool autoderef_cmp_flag = false;\n+\n+void\n+set_cmp_autoderef_mode ()\n+{\n+  autoderef_cmp_flag = true;\n+}\n+void\n+reset_cmp_autoderef_mode ()\n+{\n+  autoderef_cmp_flag = false;\n+}\n+\n std::string\n TypeKindFormat::to_string (TypeKind kind)\n {"}, {"sha": "998ed63ff27b3301aed1425c68301ac5578f7031", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85492954ded963d937de1fa8731be0718d117eb/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85492954ded963d937de1fa8731be0718d117eb/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=c85492954ded963d937de1fa8731be0718d117eb", "patch": "@@ -135,6 +135,11 @@ class TypeBoundsMappings\n   std::vector<TypeBoundPredicate> specified_bounds;\n };\n \n+extern void\n+set_cmp_autoderef_mode ();\n+extern void\n+reset_cmp_autoderef_mode ();\n+\n class TyVisitor;\n class TyConstVisitor;\n class BaseType : public TypeBoundsMappings"}, {"sha": "2789c30ee38421bea4c81b9f3fc44bc6de4f63aa", "filename": "gcc/testsuite/rust/compile/generics7.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85492954ded963d937de1fa8731be0718d117eb/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics7.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85492954ded963d937de1fa8731be0718d117eb/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics7.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics7.rs?ref=c85492954ded963d937de1fa8731be0718d117eb", "patch": "@@ -3,13 +3,13 @@ struct Foo<A> {\n }\n \n impl Foo<isize> {\n-    fn bar(self) -> isize { // { dg-error \"duplicate definitions with name bar\" }\n+    fn bar(self) -> isize {\n         self.a\n     }\n }\n \n impl Foo<char> {\n-    fn bar(self) -> char { // { dg-error \"duplicate definitions with name bar\" }\n+    fn bar(self) -> char {\n         self.a\n     }\n }\n@@ -23,4 +23,6 @@ impl<T> Foo<T> {\n fn main() {\n     let a = Foo { a: 123 };\n     a.bar();\n+    // { dg-error \"multiple candidates found for method .bar.\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"failed to type resolve expression\" \"\" { target *-*-* } .-2 }\n }"}, {"sha": "fd972e28ab35fb08558f0a13b3ebebc347446a22", "filename": "gcc/testsuite/rust/execute/torture/operator_overload_9.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85492954ded963d937de1fa8731be0718d117eb/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_9.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85492954ded963d937de1fa8731be0718d117eb/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_9.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_9.rs?ref=c85492954ded963d937de1fa8731be0718d117eb", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-output \"imm_deref\\n123\\n\" } */\n+/* { dg-output \"mut_deref\\n123\\n\" } */\n extern \"C\" {\n     fn printf(s: *const i8, ...);\n }"}]}