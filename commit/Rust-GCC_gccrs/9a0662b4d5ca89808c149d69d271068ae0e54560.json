{"sha": "9a0662b4d5ca89808c149d69d271068ae0e54560", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWEwNjYyYjRkNWNhODk4MDhjMTQ5ZDY5ZDI3MTA2OGFlMGU1NDU2MA==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@redhat.com", "date": "2000-11-09T17:38:20Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2000-11-09T17:38:20Z"}, "message": "sparc.c (sparc_va_arg): When the required alignment is more than that provided, copy to a temporary.\n\n\t* config/sparc/sparc.c (sparc_va_arg): When the required alignment\n\tis more than that provided, copy to a temporary.\n\nFrom-SVN: r37344", "tree": {"sha": "591da3e5a035add693d8ea50a5fdceea98190cf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/591da3e5a035add693d8ea50a5fdceea98190cf5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a0662b4d5ca89808c149d69d271068ae0e54560", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a0662b4d5ca89808c149d69d271068ae0e54560", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a0662b4d5ca89808c149d69d271068ae0e54560", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a0662b4d5ca89808c149d69d271068ae0e54560/comments", "author": null, "committer": null, "parents": [{"sha": "1caa7aba31c9ff1c1b40eaef4837a55ccf3ff298", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1caa7aba31c9ff1c1b40eaef4837a55ccf3ff298", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1caa7aba31c9ff1c1b40eaef4837a55ccf3ff298"}], "stats": {"total": 42, "additions": 36, "deletions": 6}, "files": [{"sha": "1d81a64fb9b950c41f51bb366c3bf256e521b5fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0662b4d5ca89808c149d69d271068ae0e54560/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0662b4d5ca89808c149d69d271068ae0e54560/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a0662b4d5ca89808c149d69d271068ae0e54560", "patch": "@@ -1,3 +1,8 @@\n+2000-11-08  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* config/sparc/sparc.c (sparc_va_arg): When the required alignment\n+\tis more than that provided, copy to a temporary.\n+\n 2000-11-09  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* mklibgcc.in (EXTRA_MULTILIB_PARTS): Prevent `make' from"}, {"sha": "85707e4c31f96072aa98a98e8458bb65aa381a3b", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0662b4d5ca89808c149d69d271068ae0e54560/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0662b4d5ca89808c149d69d271068ae0e54560/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=9a0662b4d5ca89808c149d69d271068ae0e54560", "patch": "@@ -4793,12 +4793,6 @@ sparc_va_arg (valist, type)\n \t  indirect = 1;\n \t  size = rsize = UNITS_PER_WORD;\n \t}\n-      else\n-\t{\n-\t  /* ??? The old va-sparc.h implementation, for 8 byte objects\n-\t     copied stuff to a temporary -- I don't see that that \n-\t     provides any more alignment than the stack slot did.  */\n-\t}\n     }\n \n   incr = valist;\n@@ -4825,6 +4819,37 @@ sparc_va_arg (valist, type)\n \n   addr_rtx = expand_expr (addr, NULL, Pmode, EXPAND_NORMAL);\n \n+  /* If the address isn't aligned properly for the type,\n+     we may need to copy to a temporary.  \n+     FIXME: This is inefficient.  Usually we can do this\n+     in registers.  */\n+  if (align == 0\n+      && TYPE_ALIGN (type) > BITS_PER_WORD\n+      && !indirect)\n+    {\n+      /* FIXME: We really need to specify that the temporary is live\n+\t for the whole function because expand_builtin_va_arg wants\n+\t the alias set to be get_varargs_alias_set (), but in this\n+\t case the alias set is that for TYPE and if the memory gets\n+\t reused it will be reused with alias set TYPE.  */\n+      rtx tmp = assign_temp (type, 0, 1, 0);\n+      rtx dest_addr;\n+\n+      addr_rtx = force_reg (Pmode, addr_rtx);\n+      addr_rtx = gen_rtx_MEM (BLKmode, addr_rtx);\n+      MEM_ALIAS_SET (addr_rtx) = get_varargs_alias_set ();\n+      tmp = shallow_copy_rtx (tmp);\n+      PUT_MODE (tmp, BLKmode);\n+      MEM_ALIAS_SET (tmp) = 0;\n+      \n+      dest_addr = emit_block_move (tmp, addr_rtx, GEN_INT (rsize), \n+\t\t\t\t   BITS_PER_WORD);\n+      if (dest_addr != NULL_RTX)\n+\taddr_rtx = dest_addr;\n+      else\n+\taddr_rtx = XCEXP (tmp, 0, MEM);\n+    }\n+\n   if (indirect)\n     {\n       addr_rtx = force_reg (Pmode, addr_rtx);"}]}