{"sha": "09a2806fb2ec1286df2ef3ab3ff4e8674ca01fad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDlhMjgwNmZiMmVjMTI4NmRmMmVmM2FiM2ZmNGU4Njc0Y2EwMWZhZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-04-18T18:39:39Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-04-18T18:39:39Z"}, "message": "ipa-inline.c: Fix comment typos; do not inline gt-ipa-inline.h\n\n\t* ipa-inline.c: Fix comment typos; do not inline gt-ipa-inline.h\n\t(want_inline_function_called_once_p): Break out the logic from\n\tipa_inline.\n\t(edge_badness): Ensure that profile is not misupdated.\n\t(lookup_recursive_calls): Prioritize by call frequencies.\n\t(inline_small_functions): Move program size estimates here;\n\tactually process whole queue even when unit growth has been\n\tmet. (to properly compute inline_failed reasons and for the\n\tcase unit size decrease.) Revisit comments on recursive\n\tinlining.\n\t(ipa_inline): Remove unit summary code; first inline hot calls\n\tof functions called once, cold calls next.\n\t(order, nnodes): Remove unused variables.\n\t* Makefile.in (ipa-inline.o): No longer depent on ggc files.\n\t(GTFILES): Remove ipa-inline.c\n\t* sel-sched.c (fill_insns): Silence uninitialized var warning.\n\nFrom-SVN: r172663", "tree": {"sha": "b5147e1ac1b38e8c51a963484ffe54057942c691", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5147e1ac1b38e8c51a963484ffe54057942c691"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09a2806fb2ec1286df2ef3ab3ff4e8674ca01fad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09a2806fb2ec1286df2ef3ab3ff4e8674ca01fad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09a2806fb2ec1286df2ef3ab3ff4e8674ca01fad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09a2806fb2ec1286df2ef3ab3ff4e8674ca01fad/comments", "author": null, "committer": null, "parents": [{"sha": "3eea52efc8ba92e60b11ca681d6aa4ad01134adf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eea52efc8ba92e60b11ca681d6aa4ad01134adf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3eea52efc8ba92e60b11ca681d6aa4ad01134adf"}], "stats": {"total": 311, "additions": 179, "deletions": 132}, "files": [{"sha": "4240755328aa3c1aa2bd3c9acf397b3c73d99f8f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09a2806fb2ec1286df2ef3ab3ff4e8674ca01fad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09a2806fb2ec1286df2ef3ab3ff4e8674ca01fad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09a2806fb2ec1286df2ef3ab3ff4e8674ca01fad", "patch": "@@ -1,3 +1,22 @@\n+2011-04-18  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline.c: Fix comment typos; do not inline gt-ipa-inline.h\n+\t(want_inline_function_called_once_p): Break out the logic from\n+\tipa_inline.\n+\t(edge_badness): Ensure that profile is not misupdated.\n+\t(lookup_recursive_calls): Prioritize by call frequencies.\n+\t(inline_small_functions): Move program size estimates here;\n+\tactually process whole queue even when unit growth has been\n+\tmet. (to properly compute inline_failed reasons and for the\n+\tcase unit size decrease.) Revisit comments on recursive\n+\tinlining.\n+\t(ipa_inline): Remove unit summary code; first inline hot calls\n+\tof functions called once, cold calls next.\n+\t(order, nnodes): Remove unused variables.\n+\t* Makefile.in (ipa-inline.o): No longer depent on ggc files.\n+\t(GTFILES): Remove ipa-inline.c\n+\t* sel-sched.c (fill_insns): Silence uninitialized var warning.\n+\n 2011-04-18  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* dwarf2out.c (is_redundant_typedef): Add 'inline' to prototype."}, {"sha": "b2d91a39c1c8a6becda910fd0aca6a031ed90c28", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09a2806fb2ec1286df2ef3ab3ff4e8674ca01fad/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09a2806fb2ec1286df2ef3ab3ff4e8674ca01fad/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=09a2806fb2ec1286df2ef3ab3ff4e8674ca01fad", "patch": "@@ -3025,7 +3025,7 @@ matrix-reorg.o : matrix-reorg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n    $(PARAMS_H) $(FIBHEAP_H) intl.h $(FUNCTION_H) $(BASIC_BLOCK_H) \\\n    $(CFGLOOP_H) tree-iterator.h $(TREE_PASS_H) $(OPTS_H) $(TREE_DATA_REF_H) \\\n    tree-ssa-sccvn.h\n-ipa-inline.o : ipa-inline.c gt-ipa-inline.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+ipa-inline.o : ipa-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(TREE_INLINE_H) $(FLAGS_H) $(CGRAPH_H) intl.h \\\n    $(DIAGNOSTIC_H) $(FIBHEAP_H) $(PARAMS_H) $(TIMEVAR_H) $(TREE_PASS_H) \\\n    $(COVERAGE_H) $(GGC_H) $(TREE_FLOW_H) $(RTL_H) $(IPA_PROP_H) \\\n@@ -3736,7 +3736,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/cselib.h $(srcdir)/basic-block.h  $(srcdir)/ipa-ref.h $(srcdir)/cgraph.h \\\n   $(srcdir)/reload.h $(srcdir)/caller-save.c \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \\\n-  $(srcdir)/ipa-prop.c $(srcdir)/ipa-cp.c $(srcdir)/ipa-inline.c $(srcdir)/matrix-reorg.c \\\n+  $(srcdir)/ipa-prop.c $(srcdir)/ipa-cp.c $(srcdir)/matrix-reorg.c \\\n   $(srcdir)/dbxout.c $(srcdir)/dwarf2out.c $(srcdir)/dwarf2asm.c \\\n   $(srcdir)/tree-vect-generic.c \\\n   $(srcdir)/dojump.c \\"}, {"sha": "23a72c730b7fafb288992b13befd8ee0b0efaa97", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 157, "deletions": 129, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09a2806fb2ec1286df2ef3ab3ff4e8674ca01fad/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09a2806fb2ec1286df2ef3ab3ff4e8674ca01fad/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=09a2806fb2ec1286df2ef3ab3ff4e8674ca01fad", "patch": "@@ -29,7 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n       all applied later.\n \n       To mark given call inline, use cgraph_mark_inline function.\n-      The function marks the edge inlinable and, if neccesary, produces\n+      The function marks the edge inlinable and, if necessary, produces\n       virtual clone in the callgraph representing the new copy of callee's\n       function body.\n \n@@ -60,10 +60,10 @@ along with GCC; see the file COPYING3.  If not see\n \t (reverse postorder) on the callgraph. Functions are converted into SSA\n \t form just before this pass and optimized subsequently. As a result, the\n \t callees of the function seen by the early inliner was already optimized\n-\t and results of early inlining adds a lot of optimization oppurtunities\n+\t and results of early inlining adds a lot of optimization opportunities\n \t for the local optimization.\n \n-\t The pass handle the obvious inlining decisions within the copmilation\n+\t The pass handle the obvious inlining decisions within the compilation\n \t unit - inlining auto inline functions, inlining for size and\n \t flattening.\n \n@@ -75,8 +75,8 @@ along with GCC; see the file COPYING3.  If not see\n \t Because of lack of whole unit knowledge, the pass can not really make\n \t good code size/performance tradeoffs.  It however does very simple\n \t speculative inlining allowing code size to grow by\n-\t EARLY_INLINING_INSNS when calee is leaf function.  In this case the\n-\t optimizations perfomed later are very likely to eliminate the cost.\n+\t EARLY_INLINING_INSNS when callee is leaf function.  In this case the\n+\t optimizations performed later are very likely to eliminate the cost.\n \n        pass_ipa_inline\n \n@@ -289,7 +289,7 @@ cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original,\n    limits on function unit growth or stack usage growth.  \n \n    The relative function body growth limit is present generally\n-   to avoid problems with non-linear behaviour of the compiler.\n+   to avoid problems with non-linear behavior of the compiler.\n    To allow inlining huge functions into tiny wrapper, the limit\n    is always based on the bigger of the two functions considered.\n \n@@ -346,8 +346,8 @@ caller_growth_limits (struct cgraph_edge *e)\n       return false;\n     }\n \n-  /* FIXME: Stack size limit often prevents inlining in fortran programs\n-     due to large i/o datastructures used by the fortran frontend.\n+  /* FIXME: Stack size limit often prevents inlining in Fortran programs\n+     due to large i/o datastructures used by the Fortran front-end.\n      We ought to ignore this limit when we know that the edge is executed\n      on every invocation of the caller (i.e. its call statement dominates\n      exit block).  We do not track this information, yet.  */\n@@ -360,7 +360,7 @@ caller_growth_limits (struct cgraph_edge *e)\n   /* Check new stack consumption with stack consumption at the place\n      stack is used.  */\n   if (inlined_stack > stack_size_limit\n-      /* If function already has large stack usage from sibbling\n+      /* If function already has large stack usage from sibling\n \t inline call, we can inline, too.\n \t This bit overoptimistically assume that we are good at stack\n \t packing.  */\n@@ -444,7 +444,7 @@ can_inline_edge_p (struct cgraph_edge *e, bool report)\n       e->inline_failed = CIF_NON_CALL_EXCEPTIONS;\n       inlinable = false;\n     }\n-  /* Check compatibility of target optimizatio noptions.  */\n+  /* Check compatibility of target optimization options.  */\n   else if (!targetm.target_option.can_inline_p (e->caller->decl,\n \t\t\t\t\t\te->callee->decl))\n     {\n@@ -655,6 +655,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \n    In both cases we want to be extra selective since\n    inlining the call will just introduce new recursive calls to appear.  */\n+\n static bool\n want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n \t\t\t\t   struct cgraph_node *outer_node,\n@@ -693,12 +694,12 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n   /* Inlining of self recursive function into copy of itself within other function\n      is transformation similar to loop peeling.\n \n-     Peeling is profitable if we can inline enough copies to make probablility\n+     Peeling is profitable if we can inline enough copies to make probability\n      of actual call to the self recursive function very small.  Be sure that\n      the probability of recursion is small.\n \n-     We ensure that the frequency of recusing is at most 1 - (1/max_depth).\n-     This way the expected number of recusion is at most max_depth.  */\n+     We ensure that the frequency of recursing is at most 1 - (1/max_depth).\n+     This way the expected number of recision is at most max_depth.  */\n   else if (peeling)\n     {\n       int max_prob = CGRAPH_FREQ_BASE - ((CGRAPH_FREQ_BASE + max_depth - 1)\n@@ -721,15 +722,15 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n \t  want_inline = false;\n \t}\n     }\n-  /* Recusive inlining, i.e. equivalent of unrolling, is profitable if recusion\n+  /* Recursive inlining, i.e. equivalent of unrolling, is profitable if recursion\n      depth is large.  We reduce function call overhead and increase chances that\n      things fit in hardware return predictor.\n \n      Recursive inlining might however increase cost of stack frame setup\n      actually slowing down functions whose recursion tree is wide rather than\n      deep.\n \n-     Deciding reliably on when to do recursive inlining withthout profile feedback\n+     Deciding reliably on when to do recursive inlining without profile feedback\n      is tricky.  For now we disable recursive inlining when probability of self\n      recursion is low. \n \n@@ -759,6 +760,35 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n   return want_inline;\n }\n \n+\n+/* Decide if NODE is called once inlining it would eliminate need\n+   for the offline copy of function.  */\n+\n+static bool\n+want_inline_function_called_once_p (struct cgraph_node *node)\n+{\n+   /* Already inlined?  */\n+   if (node->global.inlined_to)\n+     return false;\n+   /* Zero or more then one callers?  */\n+   if (!node->callers\n+       || node->callers->next_caller)\n+     return false;\n+   /* Recursive call makes no sense to inline.  */\n+   if (node->callers->caller == node)\n+     return false;\n+   /* External functions are not really in the unit, so inlining\n+      them when called once would just increase the program size.  */\n+   if (DECL_EXTERNAL (node->decl))\n+     return false;\n+   /* Offline body must be optimized out.  */\n+   if (!cgraph_will_be_removed_from_program_if_no_direct_calls (node))\n+     return false;\n+   if (!can_inline_edge_p (node->callers, true))\n+     return false;\n+   return true;\n+}\n+\n /* A cost model driving the inlining heuristics in a way so the edges with\n    smallest badness are inlined first.  After each inlining is performed\n    the costs of all caller edges of nodes affected are recomputed so the\n@@ -810,6 +840,10 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t ((double) edge->count * INT_MIN / max_count / (max_benefit + 1)) *\n \t (callee_info->time_inlining_benefit\n \t  + edge->call_stmt_time + 1)) / growth;\n+      \n+      /* Be sure that insanity of the profile won't lead to increasing counts\n+\t in the scalling and thus to overflow in the computation above.  */\n+      gcc_assert (max_count >= edge->count);\n       if (dump)\n \t{\n \t  fprintf (dump_file,\n@@ -988,6 +1022,7 @@ update_callee_keys (fibheap_t heap, struct cgraph_node *node,\n \t\t    bitmap updated_nodes)\n {\n   struct cgraph_edge *e = node->callees;\n+\n   inline_summary (node)->estimated_growth = INT_MIN;\n \n   if (!e)\n@@ -1029,6 +1064,7 @@ update_all_callee_keys (fibheap_t heap, struct cgraph_node *node,\n \t\t\tbitmap updated_nodes)\n {\n   struct cgraph_edge *e = node->callees;\n+\n   inline_summary (node)->estimated_growth = INT_MIN;\n \n   if (!e)\n@@ -1063,16 +1099,14 @@ static void\n lookup_recursive_calls (struct cgraph_node *node, struct cgraph_node *where,\n \t\t\tfibheap_t heap)\n {\n-  static int priority;\n   struct cgraph_edge *e;\n   for (e = where->callees; e; e = e->next_callee)\n     if (e->callee == node)\n       {\n \t/* When profile feedback is available, prioritize by expected number\n-\t   of calls.  Without profile feedback we maintain simple queue\n-\t   to order candidates via recursive depths.  */\n+\t   of calls.  */\n         fibheap_insert (heap,\n-\t\t\t!max_count ? priority++\n+\t\t\t!max_count ? -e->frequency\n \t\t        : -(e->count / ((max_count + (1<<24) - 1) / (1<<24))),\n \t\t        e);\n       }\n@@ -1199,8 +1233,10 @@ recursive_inlining (struct cgraph_edge *edge,\n   return true;\n }\n \n+\n /* Given whole compilation unit estimate of INSNS, compute how large we can\n    allow the unit to grow.  */\n+\n static int\n compute_max_insns (int insns)\n {\n@@ -1212,7 +1248,9 @@ compute_max_insns (int insns)\n \t  * (100 + PARAM_VALUE (PARAM_INLINE_UNIT_GROWTH)) / 100);\n }\n \n+\n /* Compute badness of all edges in NEW_EDGES and add them to the HEAP.  */\n+\n static void\n add_new_edges_to_heap (fibheap_t heap, VEC (cgraph_edge_p, heap) *new_edges)\n {\n@@ -1231,11 +1269,10 @@ add_new_edges_to_heap (fibheap_t heap, VEC (cgraph_edge_p, heap) *new_edges)\n \n \n /* We use greedy algorithm for inlining of small functions:\n-   All inline candidates are put into prioritized heap based on estimated\n-   growth of the overall number of instructions and then update the estimates.\n+   All inline candidates are put into prioritized heap ordered in\n+   increasing badness.\n \n-   INLINED and INLINED_CALLEES are just pointers to arrays large enough\n-   to be passed to cgraph_inlined_into and cgraph_inlined_callees.  */\n+   The inlining of small functions is bounded by unit growth parameters.  */\n \n static void\n inline_small_functions (void)\n@@ -1246,17 +1283,25 @@ inline_small_functions (void)\n   bitmap updated_nodes = BITMAP_ALLOC (NULL);\n   int min_size, max_size;\n   VEC (cgraph_edge_p, heap) *new_indirect_edges = NULL;\n+  int initial_size = 0;\n \n   if (flag_indirect_inlining)\n     new_indirect_edges = VEC_alloc (cgraph_edge_p, heap, 8);\n \n   if (dump_file)\n-    fprintf (dump_file, \"\\nDeciding on smaller functions:\\n\");\n+    fprintf (dump_file,\n+\t     \"\\nDeciding on inlining of small functions.  Starting with size %i.\\n\",\n+\t     initial_size);\n \n-  /* Put all inline candidates into the heap.  */\n+  /* Populate the heeap with all edges we might inline.\n+     While doing so compute overall unit size and other global\n+     parameters used by badness metrics.  */\n \n+  max_count = 0;\n+  max_benefit = 0;\n   for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed)\n+    if (node->analyzed\n+\t&& !node->global.inlined_to)\n       {\n \tstruct inline_summary *info = inline_summary (node);\n \n@@ -1266,22 +1311,36 @@ inline_small_functions (void)\n \n \tinfo->estimated_growth = INT_MIN;\n \n+\tif (!DECL_EXTERNAL (node->decl))\n+\t  initial_size += info->size;\n+\n \tfor (edge = node->callers; edge; edge = edge->next_caller)\n-\t  if (edge->inline_failed\n-\t      && can_inline_edge_p (edge, true)\n-\t      && want_inline_small_function_p (edge, true)\n-\t      && edge->inline_failed)\n-\t    {\n-\t      gcc_assert (!edge->aux);\n-\t      update_edge_key (heap, edge);\n-\t    }\n+\t  {\n+\t    int benefit = (info->time_inlining_benefit\n+\t\t\t   + edge->call_stmt_time);\n+\t    if (max_count < edge->count)\n+\t      max_count = edge->count;\n+\t    if (max_benefit < benefit)\n+\t      max_benefit = benefit;\n+\t    if (edge->inline_failed\n+\t\t&& can_inline_edge_p (edge, true)\n+\t\t&& want_inline_small_function_p (edge, true)\n+\t\t&& edge->inline_failed)\n+\t      {\n+\t\tgcc_assert (!edge->aux);\n+\t\tupdate_edge_key (heap, edge);\n+\t      }\n+\t   }\n       }\n \n   max_size = compute_max_insns (overall_size);\n   min_size = overall_size;\n+  gcc_assert (in_lto_p\n+\t      || !max_count\n+\t      || (profile_info && flag_branch_probabilities));\n+  overall_size = initial_size;\n \n-  while (overall_size <= max_size\n-\t && !fibheap_empty (heap))\n+  while (!fibheap_empty (heap))\n     {\n       int old_size = overall_size;\n       struct cgraph_node *where, *callee;\n@@ -1296,8 +1355,8 @@ inline_small_functions (void)\n \tcontinue;\n \n       /* When updating the edge costs, we only decrease badness in the keys.\n-\t When the badness increase, we keep the heap as it is and re-insert\n-\t key now.  */\n+\t Increases of badness are handled lazilly; when we see key with out\n+\t of date value on it, we re-insert it now.  */\n       current_badness = edge_badness (edge, false);\n       gcc_assert (current_badness >= badness);\n       if (current_badness != badness)\n@@ -1345,12 +1404,12 @@ inline_small_functions (void)\n \t}\n \n       if (!want_inline_small_function_p (edge, true))\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \" inline_failed:%s.\\n\",\n-\t\t     cgraph_inline_failed_string (edge->inline_failed));\n-\t  continue;\n-\t}\n+\tcontinue;\n+\n+      /* Heuristics for inlining small functions works poorly for\n+\t recursive calls where we do efect similar to loop unrolling.\n+\t When inliing such edge seems profitable, leave decision on\n+\t specific inliner.  */\n       if (cgraph_edge_recursive_p (edge))\n \t{\n \t  where = edge->caller;\n@@ -1363,6 +1422,8 @@ inline_small_functions (void)\n \t      edge->inline_failed = CIF_RECURSIVE_INLINING;\n \t      continue;\n \t    }\n+\t  /* Recursive inliner inlines all recursive calls of the function\n+\t     at once. Consequently we need to update all callee keys.  */\n \t  if (flag_indirect_inlining)\n \t    add_new_edges_to_heap (heap, new_indirect_edges);\n           update_all_callee_keys (heap, where, updated_nodes);\n@@ -1452,10 +1513,16 @@ inline_small_functions (void)\n   if (new_indirect_edges)\n     VEC_free (cgraph_edge_p, heap, new_indirect_edges);\n   fibheap_delete (heap);\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"Unit growth for small function inlining: %i->%i (%i%%)\\n\",\n+\t     overall_size, initial_size,\n+\t     overall_size * 100 / (initial_size + 1) - 100);\n   BITMAP_FREE (updated_nodes);\n }\n \n-/* Flatten NODE from the IPA inliner.  */\n+/* Flatten NODE.  Performed both during early inlining and\n+   at IPA inlining time.  */\n \n static void\n flatten_function (struct cgraph_node *node)\n@@ -1542,51 +1609,18 @@ ipa_inline (void)\n   int nnodes;\n   struct cgraph_node **order =\n     XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n-  int old_size = 0;\n   int i;\n-  int initial_size = 0;\n \n   if (in_lto_p && flag_indirect_inlining)\n     ipa_update_after_lto_read ();\n   if (flag_indirect_inlining)\n     ipa_create_all_structures_for_iinln ();\n \n-  max_count = 0;\n-  max_benefit = 0;\n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed)\n-      {\n-\tstruct cgraph_edge *e;\n-\tstruct inline_summary *info = inline_summary (node);\n-\n-\tgcc_assert (info->self_size == info->size);\n-\tif (!DECL_EXTERNAL (node->decl))\n-\t  initial_size += info->size;\n-\tfor (e = node->callees; e; e = e->next_callee)\n-\t  {\n-\t    int benefit = (info->time_inlining_benefit\n-\t\t\t   + e->call_stmt_time);\n-\t    if (max_count < e->count)\n-\t      max_count = e->count;\n-\t    if (max_benefit < benefit)\n-\t      max_benefit = benefit;\n-\t  }\n-      }\n-\n   if (dump_file)\n     dump_inline_summaries (dump_file);\n-  gcc_assert (in_lto_p\n-\t      || !max_count\n-\t      || (profile_info && flag_branch_probabilities));\n-  overall_size = initial_size;\n \n   nnodes = cgraph_postorder (order);\n \n-  if (dump_file)\n-    fprintf (dump_file,\n-\t     \"\\nDeciding on inlining.  Starting with size %i.\\n\",\n-\t     initial_size);\n-\n   for (node = cgraph_nodes; node; node = node->next)\n     node->aux = 0;\n \n@@ -1599,10 +1633,7 @@ ipa_inline (void)\n     {\n       node = order[i];\n \n-      /* Handle nodes to be flattened, but don't update overall unit\n-\t size.  Calling the incremental inliner here is lame,\n-\t a simple worklist should be enough.  What should be left\n-\t here from the early inliner (if it runs) is cyclic cases.\n+      /* Handle nodes to be flattened.\n \t Ideally when processing callees we stop inlining at the\n \t entry of cycles, possibly cloning that entry point and\n \t try to flatten itself turning it into a self-recursive\n@@ -1626,46 +1657,53 @@ ipa_inline (void)\n      we still might do a quick check that nothing new is found.  */\n   if (flag_inline_functions_called_once)\n     {\n+      int cold;\n       if (dump_file)\n \tfprintf (dump_file, \"\\nDeciding on functions called once:\\n\");\n \n-      /* And finally decide what functions are called once.  */\n-      for (node = cgraph_nodes; node; node = node->next)\n+      /* Inlining one function called once has good chance of preventing\n+\t inlining other function into the same callee.  Ideally we should\n+\t work in priority order, but probably inlining hot functions first\n+\t is good cut without the extra pain of maintaining the queue.\n+\n+\t ??? this is not really fitting the bill perfectly: inlining function\n+\t into callee often leads to better optimization of callee due to\n+\t increased context for optimization.\n+\t For example if main() function calls a function that outputs help\n+\t and then function that does the main optmization, we should inline\n+\t the second with priority even if both calls are cold by themselves.\n+\n+\t We probably want to implement new predicate replacing our use of\n+\t maybe_hot_edge interpreted as maybe_hot_edge || callee is known\n+\t to be hot.  */\n+      for (cold = 0; cold <= 1; cold ++)\n \t{\n-\t  if (node->callers\n-\t      && !node->callers->next_caller\n-\t      && !node->global.inlined_to\n-\t      && node->callers->inline_failed\n-\t      && node->callers->caller != node\n-\t      && node->callers->caller->global.inlined_to != node\n-\t      && cgraph_will_be_removed_from_program_if_no_direct_calls (node)\n-\t      && inline_summary (node)->inlinable\n-\t      && cgraph_function_body_availability (node) >= AVAIL_AVAILABLE\n-\t      && !DECL_EXTERNAL (node->decl)\n-\t      && can_inline_edge_p (node->callers, true))\n+\t  for (node = cgraph_nodes; node; node = node->next)\n \t    {\n-\t      struct cgraph_node *caller = node->callers->caller;\n-\n-\t      old_size = overall_size;\n-\t      if (dump_file)\n+\t      if (want_inline_function_called_once_p (node)\n+\t\t  && (cold\n+\t\t      || cgraph_maybe_hot_edge_p (node->callers)))\n \t\t{\n-\t\t  fprintf (dump_file,\n-\t\t\t   \"\\nInlining %s size %i.\\n\",\n-\t\t\t   cgraph_node_name (node), inline_summary (node)->size);\n-\t\t  fprintf (dump_file,\n-\t\t\t   \" Called once from %s %i insns.\\n\",\n-\t\t\t   cgraph_node_name (node->callers->caller),\n-\t\t\t   inline_summary (node->callers->caller)->size);\n+\t\t  struct cgraph_node *caller = node->callers->caller;\n+\n+\t\t  if (dump_file)\n+\t\t    {\n+\t\t      fprintf (dump_file,\n+\t\t\t       \"\\nInlining %s size %i.\\n\",\n+\t\t\t       cgraph_node_name (node), inline_summary (node)->size);\n+\t\t      fprintf (dump_file,\n+\t\t\t       \" Called once from %s %i insns.\\n\",\n+\t\t\t       cgraph_node_name (node->callers->caller),\n+\t\t\t       inline_summary (node->callers->caller)->size);\n+\t\t    }\n+\n+\t\t  cgraph_mark_inline_edge (node->callers, true, NULL);\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n+\t\t\t     \" Inlined into %s which now has %i size\\n\",\n+\t\t\t     cgraph_node_name (caller),\n+\t\t\t     inline_summary (caller)->size);\n \t\t}\n-\n-\t      cgraph_mark_inline_edge (node->callers, true, NULL);\n-\t      if (dump_file)\n-\t\tfprintf (dump_file,\n-\t\t\t \" Inlined into %s which now has %i size\"\n-\t\t\t \" for a net change of %+i size.\\n\",\n-\t\t\t cgraph_node_name (caller),\n-\t\t\t inline_summary (caller)->size,\n-\t\t\t overall_size - old_size);\n \t    }\n \t}\n     }\n@@ -1676,10 +1714,9 @@ ipa_inline (void)\n \n   if (dump_file)\n     fprintf (dump_file,\n-\t     \"\\nInlined %i calls, eliminated %i functions, \"\n-\t     \"size %i turned to %i size.\\n\\n\",\n-\t     ncalls_inlined, nfunctions_inlined, initial_size,\n-\t     overall_size);\n+\t     \"\\nInlined %i calls, eliminated %i functions\\n\\n\",\n+\t     ncalls_inlined, nfunctions_inlined);\n+\n   /* In WPA we use inline summaries for partitioning process.  */\n   if (!flag_wpa)\n     inline_free_summary ();\n@@ -1771,12 +1808,6 @@ early_inline_small_functions (struct cgraph_node *node)\n   return inlined;\n }\n \n-/* Because inlining might remove no-longer reachable nodes, we need to\n-   keep the array visible to garbage collector to avoid reading collected\n-   out nodes.  */\n-static int nnodes;\n-static GTY ((length (\"nnodes\"))) struct cgraph_node **order;\n-\n /* Do inlining of small functions.  Doing so early helps profiling and other\n    passes to be somewhat more effective and avoids some code duplication in\n    later real inlining pass for testcases with very many function calls.  */\n@@ -1807,7 +1838,7 @@ early_inliner (void)\n \t during incremental inlining.  This sucks as functions calling\n \t always inline functions will get less optimized, but at the\n \t same time inlining of functions calling always inline\n-\t functoin into an always inline function might introduce\n+\t function into an always inline function might introduce\n \t cycles of edges to be always inlined in the callgraph.\n \n \t We might want to be smarter and just avoid this type of inlining.  */\n@@ -1963,6 +1994,3 @@ struct ipa_opt_pass_d pass_ipa_inline =\n  inline_transform,\t\t\t/* function_transform */\n  NULL,\t\t\t\t\t/* variable_transform */\n };\n-\n-\n-#include \"gt-ipa-inline.h\""}, {"sha": "b176deaaef3b39c8272a383fc651a9e90afd1e2d", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09a2806fb2ec1286df2ef3ab3ff4e8674ca01fad/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09a2806fb2ec1286df2ef3ab3ff4e8674ca01fad/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=09a2806fb2ec1286df2ef3ab3ff4e8674ca01fad", "patch": "@@ -5517,7 +5517,7 @@ fill_insns (fence_t fence, int seqno, ilist_t **scheduled_insns_tailpp)\n     {\n       blist_t *bnds_tailp1, *bndsp;\n       expr_t expr_vliw;\n-      int need_stall;\n+      int need_stall = false;\n       int was_stall = 0, scheduled_insns = 0;\n       int max_insns = pipelining_p ? issue_rate : 2 * issue_rate;\n       int max_stall = pipelining_p ? 1 : 3;"}]}