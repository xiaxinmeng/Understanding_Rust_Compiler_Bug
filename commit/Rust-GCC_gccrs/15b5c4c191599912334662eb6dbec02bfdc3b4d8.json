{"sha": "15b5c4c191599912334662eb6dbec02bfdc3b4d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTViNWM0YzE5MTU5OTkxMjMzNDY2MmViNmRiZWMwMmJmZGMzYjRkOA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2005-04-01T11:02:26Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2005-04-01T11:02:26Z"}, "message": "arm.c (adjacent_mem_locations): Reject volatile memory refs.\n\n\t* arm.c (adjacent_mem_locations): Reject volatile memory refs.\n\tAlso reject cases where this pattern will cause load delay stalls\n\tunless optimizing for size and it will produce a shorter sequence.\n\t* arm.md (arith_adjacent_mem): Make better use of ldm addressing\n\tvariants to avoid pre-adjusting the base when possible.\n\nFrom-SVN: r97381", "tree": {"sha": "ce60104a96134fa4b842e1570d72c6e48259f9f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce60104a96134fa4b842e1570d72c6e48259f9f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15b5c4c191599912334662eb6dbec02bfdc3b4d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15b5c4c191599912334662eb6dbec02bfdc3b4d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15b5c4c191599912334662eb6dbec02bfdc3b4d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15b5c4c191599912334662eb6dbec02bfdc3b4d8/comments", "author": null, "committer": null, "parents": [{"sha": "7fac69e5b3a6a544dbb80e04434067b0a67aaf33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fac69e5b3a6a544dbb80e04434067b0a67aaf33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fac69e5b3a6a544dbb80e04434067b0a67aaf33"}], "stats": {"total": 73, "additions": 57, "deletions": 16}, "files": [{"sha": "f9bc5a9b885e45730bd1c8aeef5ba2eb2336a42b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15b5c4c191599912334662eb6dbec02bfdc3b4d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15b5c4c191599912334662eb6dbec02bfdc3b4d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15b5c4c191599912334662eb6dbec02bfdc3b4d8", "patch": "@@ -1,3 +1,11 @@\n+2005-04-01  Richard Earnshaw  <richard.earnshaw@arm.com>\n+\n+\t* arm.c (adjacent_mem_locations): Reject volatile memory refs.\n+\tAlso reject cases where this pattern will cause load delay stalls\n+\tunless optimizing for size and it will produce a shorter sequence.\n+\t* arm.md (arith_adjacent_mem): Make better use of ldm addressing\n+\tvariants to avoid pre-adjusting the base when possible.\n+\n 2005-04-01  Richard Earnshaw  <richard.earnshaw@arm.com>\n \n \t* arm.md (minmax_arithsi): Reject all eliminable registers, not just"}, {"sha": "66c36fb9a39bb3bfcf8f5fa61c003c5101c37b74", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15b5c4c191599912334662eb6dbec02bfdc3b4d8/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15b5c4c191599912334662eb6dbec02bfdc3b4d8/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=15b5c4c191599912334662eb6dbec02bfdc3b4d8", "patch": "@@ -5139,6 +5139,10 @@ minmax_code (rtx x)\n int\n adjacent_mem_locations (rtx a, rtx b)\n {\n+  /* We don't guarantee to preserve the order of these memory refs.  */\n+  if (volatile_refs_p (a) || volatile_refs_p (b))\n+    return 0;\n+\n   if ((GET_CODE (XEXP (a, 0)) == REG\n        || (GET_CODE (XEXP (a, 0)) == PLUS\n \t   && GET_CODE (XEXP (XEXP (a, 0), 1)) == CONST_INT))\n@@ -5178,6 +5182,17 @@ adjacent_mem_locations (rtx a, rtx b)\n \treturn 0;\n \n       val_diff = val1 - val0;\n+\n+      if (arm_ld_sched)\n+\t{\n+\t  /* If the target has load delay slots, then there's no benefit\n+\t     to using an ldm instruction unless the offset is zero and\n+\t     we are optimizing for size.  */\n+\t  return (optimize_size && (REGNO (reg0) == REGNO (reg1))\n+\t\t  && (val0 == 0 || val1 == 0 || val0 == 4 || val1 == 4)\n+\t\t  && (val_diff == 4 || val_diff == -4));\n+\t}\n+\n       return ((REGNO (reg0) == REGNO (reg1))\n \t      && (val_diff == 4 || val_diff == -4));\n     }"}, {"sha": "1a1c06a039887ddeccb4b780cf6e6f0c0cbaefd2", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15b5c4c191599912334662eb6dbec02bfdc3b4d8/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15b5c4c191599912334662eb6dbec02bfdc3b4d8/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=15b5c4c191599912334662eb6dbec02bfdc3b4d8", "patch": "@@ -9246,7 +9246,8 @@\n   {\n     rtx ldm[3];\n     rtx arith[4];\n-    int val1 = 0, val2 = 0;\n+    rtx base_reg;\n+    HOST_WIDE_INT val1 = 0, val2 = 0;\n \n     if (REGNO (operands[0]) > REGNO (operands[4]))\n       {\n@@ -9258,12 +9259,21 @@\n \tldm[1] = operands[0];\n \tldm[2] = operands[4];\n       }\n-    if (GET_CODE (XEXP (operands[2], 0)) != REG)\n-      val1 = INTVAL (XEXP (XEXP (operands[2], 0), 1));\n-    if (GET_CODE (XEXP (operands[3], 0)) != REG)\n+\n+    base_reg = XEXP (operands[2], 0);\n+\n+    if (!REG_P (base_reg))\n+      {\n+\tval1 = INTVAL (XEXP (base_reg, 1));\n+\tbase_reg = XEXP (base_reg, 0);\n+      }\n+\n+    if (!REG_P (XEXP (operands[3], 0)))\n       val2 = INTVAL (XEXP (XEXP (operands[3], 0), 1));\n+\n     arith[0] = operands[0];\n     arith[3] = operands[1];\n+\n     if (val1 < val2)\n       {\n \tarith[1] = ldm[1];\n@@ -9274,29 +9284,37 @@\n \tarith[1] = ldm[2];\n \tarith[2] = ldm[1];\n       }\n-   if (val1 && val2)\n+\n+    ldm[0] = base_reg;\n+    if (val1 !=0 && val2 != 0)\n       {\n-\trtx ops[3];\n-\tldm[0] = ops[0] = operands[4];\n-\tops[1] = XEXP (XEXP (operands[2], 0), 0);\n-\tops[2] = XEXP (XEXP (operands[2], 0), 1);\n-\toutput_add_immediate (ops);\n-\tif (val1 < val2)\n-\t  output_asm_insn (\\\"ldm%?ia\\\\t%0, {%1, %2}\\\", ldm);\n+\tif (val1 == 4 || val2 == 4)\n+\t  /* Other val must be 8, since we know they are adjacent and neither\n+\t     is zero.  */\n+\t  output_asm_insn (\\\"ldm%?ib\\\\t%0, {%1, %2}\\\", ldm);\n \telse\n-\t  output_asm_insn (\\\"ldm%?da\\\\t%0, {%1, %2}\\\", ldm);\n+\t  {\n+\t    rtx ops[3];\n+\n+\t    ldm[0] = ops[0] = operands[4];\n+\t    ops[1] = base_reg;\n+\t    ops[2] = GEN_INT (val1);\n+\t    output_add_immediate (ops);\n+\t    if (val1 < val2)\n+\t      output_asm_insn (\\\"ldm%?ia\\\\t%0, {%1, %2}\\\", ldm);\n+\t    else\n+\t      output_asm_insn (\\\"ldm%?da\\\\t%0, {%1, %2}\\\", ldm);\n+\t  }\n       }\n-    else if (val1)\n+    else if (val1 != 0)\n       {\n-\tldm[0] = XEXP (operands[3], 0);\n \tif (val1 < val2)\n \t  output_asm_insn (\\\"ldm%?da\\\\t%0, {%1, %2}\\\", ldm);\n \telse\n \t  output_asm_insn (\\\"ldm%?ia\\\\t%0, {%1, %2}\\\", ldm);\n       }\n     else\n       {\n-\tldm[0] = XEXP (operands[2], 0);\n \tif (val1 < val2)\n \t  output_asm_insn (\\\"ldm%?ia\\\\t%0, {%1, %2}\\\", ldm);\n \telse"}]}