{"sha": "456f0dfa1c8975b3d456dc6ad06e998d8eed22ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU2ZjBkZmExYzg5NzViM2Q0NTZkYzZhZDA2ZTk5OGQ4ZWVkMjJlZA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2016-11-10T19:38:33Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-11-10T19:38:33Z"}, "message": "rs6000.c (rs6000_hard_regno_mode_ok): If ISA 3.0...\n\n[gcc]\n2016-11-10  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_hard_regno_mode_ok): If ISA 3.0,\n\tenable HImode and QImode to go in vector registers by default if\n\tthe -mvsx-small-integer option is enabled.\n\t(rs6000_secondary_reload_simple_move): Likewise.\n\t(rs6000_preferred_reload_class): Don't force integer constants to\n\tbe loaded into vector registers that we can easily make into\n\tmemory (or being created in the GPRs and moved over with direct\n\tmove).\n\t* config/rs6000/vsx.md (UNSPEC_P9_MEMORY): Delete, no longer\n\tused.\n\t(vsx_extract_<mode>): Rework V4SImode, V8HImode, and V16QImode\n\tvector extraction on ISA 3.0 when the scalar integer can be\n\tallocated in vector registers.  Generate the VEC_SELECT directy,\n\tand don't use UNSPEC's to avoid having the scalar type in a vector\n\tregister.  Make the expander target registers, and let the\n\tcombiner fold in results storing to memory, if the machine\n\tsupports stores.\n\t(vsx_extract_<mode>_di): Likewise.\n\t(vsx_extract_<mode>_p9): Likewise.\n\t(vsx_extract_<mode>_di_p9): Likewise.\n\t(vsx_extract_<mode>_store_p9): Likewise.\n\t(vsx_extract_si): Likewise.\n\t(vsx_extract_<mode>_p8): Likewise.\n\t(p9_lxsi<wd>zx): Delete, no longer used.\n\t(p9_stxsi<wd>x): Likewise.\n\t* config/rs6000/rs6000.md (INT_ISA3): New mode iterator for\n\tintegers in vector registers for ISA 3.0.\n\t(QHI): Update comment.\n\t(zero_extendqi<mode>2): Add support for ISA 3.0 scalar load or\n\tvector extract instructions in sign/zero extend.\n\t(zero_extendhi<mode>): Likewise.\n\t(extendqi<mode>): Likewise.\n\t(extendhi<mode>2): Likewise.\n\t(HImode splitter for load/sign extend in vector register):\n\tLikewise.\n\t(float<QHI:mode><FP_ISA3:mode>2): Eliminate old method of\n\toptimizing floating point conversions to/from small data types and\n\trewrite it to support QImode/HImode being allowed in vector\n\tregisters on ISA 3.0.\n\t(float<QHI:mode><FP_ISA3:mode>2_internal): Likewise.\n\t(floatuns<QHI:mode><FP_ISA3:mode>2): Likewise.\n\t(floatuns<QHI:mode><FP_ISA3:mode>2_internal): Likewise.\n\t(fix_trunc<SFDF:mode><QHI:mode>2): Likewise.\n\t(fix_trunc<SFDF:mode><QHI:mode>2_internal): Likewise.\n\t(fixuns_trunc<SFDF:mode><QHI:mode>2): Likewise.\n\t(fixuns_trunc<SFDF:mode><QHI:mode>2_internal): Likewise.\n\tVSPLITISW on ISA 2.07.\n\t(movhi_internal): Combine movhi_internal and movqi_internal into\n\tone mov<mode>_internal with an iterator.  Add support for QImode\n\tand HImode being allowed in vector registers.  Make large number\n\tof attributes and constraints easier to read.\n\t(movqi_internal): Likewise.\n\t(mov<mode>_internal): Likewise.\n\t(movdi_internal64): Fix constraint to allow loading -16..15 with\n\tVSPLITISW on ISA 2.07.\n\t(integer XXSPLTIB splitter): Add support for QI, HI, and SImode as\n\twell as DImode.\n\n[gcc/testsuite]\n2016-11-10  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/vsx-qimode.c: New test for QImode, HImode\n\tbeing allowed in vector registers.\n\t* gcc.target/powerpc/vsx-qimode2.c: Likewise.\n\t* gcc.target/powerpc/vsx-qimode3.c: Likewise.\n\t* gcc.target/powerpc/vsx-himode.c: Likewise.\n\t* gcc.target/powerpc/vsx-himode2.c: Likewise.\n\t* gcc.target/powerpc/vsx-himode3.c: Likewise.\n\t* gcc.target/powerpc/p9-extract-1.c: Change MFVSRD to just MFVSR,\n\tto allow matching MFVSRD or MFVSRW.\n\nFrom-SVN: r242048", "tree": {"sha": "bf33bd795b170e9fbbdf268a4d21fc2415e857fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf33bd795b170e9fbbdf268a4d21fc2415e857fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/comments", "author": null, "committer": null, "parents": [{"sha": "8d34bfa865fb527b6a3569528656e2dc8af592e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d34bfa865fb527b6a3569528656e2dc8af592e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d34bfa865fb527b6a3569528656e2dc8af592e0"}], "stats": {"total": 702, "additions": 504, "deletions": 198}, "files": [{"sha": "5fed9715531c9ebfb796fa5e47d099cb61932392", "filename": "gcc/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=456f0dfa1c8975b3d456dc6ad06e998d8eed22ed", "patch": "@@ -1,3 +1,63 @@\n+2016-11-10  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_hard_regno_mode_ok): If ISA 3.0,\n+\tenable HImode and QImode to go in vector registers by default if\n+\tthe -mvsx-small-integer option is enabled.\n+\t(rs6000_secondary_reload_simple_move): Likewise.\n+\t(rs6000_preferred_reload_class): Don't force integer constants to\n+\tbe loaded into vector registers that we can easily make into\n+\tmemory (or being created in the GPRs and moved over with direct\n+\tmove).\n+\t* config/rs6000/vsx.md (UNSPEC_P9_MEMORY): Delete, no longer\n+\tused.\n+\t(vsx_extract_<mode>): Rework V4SImode, V8HImode, and V16QImode\n+\tvector extraction on ISA 3.0 when the scalar integer can be\n+\tallocated in vector registers.  Generate the VEC_SELECT directy,\n+\tand don't use UNSPEC's to avoid having the scalar type in a vector\n+\tregister.  Make the expander target registers, and let the\n+\tcombiner fold in results storing to memory, if the machine\n+\tsupports stores.\n+\t(vsx_extract_<mode>_di): Likewise.\n+\t(vsx_extract_<mode>_p9): Likewise.\n+\t(vsx_extract_<mode>_di_p9): Likewise.\n+\t(vsx_extract_<mode>_store_p9): Likewise.\n+\t(vsx_extract_si): Likewise.\n+\t(vsx_extract_<mode>_p8): Likewise.\n+\t(p9_lxsi<wd>zx): Delete, no longer used.\n+\t(p9_stxsi<wd>x): Likewise.\n+\t* config/rs6000/rs6000.md (INT_ISA3): New mode iterator for\n+\tintegers in vector registers for ISA 3.0.\n+\t(QHI): Update comment.\n+\t(zero_extendqi<mode>2): Add support for ISA 3.0 scalar load or\n+\tvector extract instructions in sign/zero extend.\n+\t(zero_extendhi<mode>): Likewise.\n+\t(extendqi<mode>): Likewise.\n+\t(extendhi<mode>2): Likewise.\n+\t(HImode splitter for load/sign extend in vector register):\n+\tLikewise.\n+\t(float<QHI:mode><FP_ISA3:mode>2): Eliminate old method of\n+\toptimizing floating point conversions to/from small data types and\n+\trewrite it to support QImode/HImode being allowed in vector\n+\tregisters on ISA 3.0.\n+\t(float<QHI:mode><FP_ISA3:mode>2_internal): Likewise.\n+\t(floatuns<QHI:mode><FP_ISA3:mode>2): Likewise.\n+\t(floatuns<QHI:mode><FP_ISA3:mode>2_internal): Likewise.\n+\t(fix_trunc<SFDF:mode><QHI:mode>2): Likewise.\n+\t(fix_trunc<SFDF:mode><QHI:mode>2_internal): Likewise.\n+\t(fixuns_trunc<SFDF:mode><QHI:mode>2): Likewise.\n+\t(fixuns_trunc<SFDF:mode><QHI:mode>2_internal): Likewise.\n+\tVSPLITISW on ISA 2.07.\n+\t(movhi_internal): Combine movhi_internal and movqi_internal into\n+\tone mov<mode>_internal with an iterator.  Add support for QImode\n+\tand HImode being allowed in vector registers.  Make large number\n+\tof attributes and constraints easier to read.\n+\t(movqi_internal): Likewise.\n+\t(mov<mode>_internal): Likewise.\n+\t(movdi_internal64): Fix constraint to allow loading -16..15 with\n+\tVSPLITISW on ISA 2.07.\n+\t(integer XXSPLTIB splitter): Add support for QI, HI, and SImode as\n+\twell as DImode.\n+\n 2016-11-10  Pat Haugen  <pthaugen@us.ibm.com>\n \n \tPR rtl-optimization/78241"}, {"sha": "ac0bcbdcd5002d9cfe9aff95abb8e14effcfd65d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 51, "deletions": 5, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=456f0dfa1c8975b3d456dc6ad06e998d8eed22ed", "patch": "@@ -2019,8 +2019,14 @@ rs6000_hard_regno_mode_ok (int regno, machine_mode mode)\n \t  if(GET_MODE_SIZE (mode) == UNITS_PER_FP_WORD)\n \t    return 1;\n \n-\t  if (TARGET_VSX_SMALL_INTEGER && mode == SImode)\n-\t    return 1;\n+\t  if (TARGET_VSX_SMALL_INTEGER)\n+\t    {\n+\t      if (mode == SImode)\n+\t\treturn 1;\n+\n+\t      if (TARGET_P9_VECTOR && (mode == HImode || mode == QImode))\n+\t\treturn 1;\n+\t    }\n \t}\n \n       if (PAIRED_SIMD_REGNO_P (regno) && TARGET_PAIRED_FLOAT\n@@ -3403,7 +3409,14 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \treg_addr[SFmode].scalar_in_vmx_p = true;\n \n       if (TARGET_VSX_SMALL_INTEGER)\n-\treg_addr[SImode].scalar_in_vmx_p = true;\n+\t{\n+\t  reg_addr[SImode].scalar_in_vmx_p = true;\n+\t  if (TARGET_P9_VECTOR)\n+\t    {\n+\t      reg_addr[HImode].scalar_in_vmx_p = true;\n+\t      reg_addr[QImode].scalar_in_vmx_p = true;\n+\t    }\n+\t}\n     }\n \n   /* Setup the fusion operations.  */\n@@ -20606,8 +20619,14 @@ rs6000_secondary_reload_simple_move (enum rs6000_reg_type to_type,\n \t}\n \n       /* ISA 2.07: MTVSRWZ or  MFVSRWZ.  */\n-      if (TARGET_VSX_SMALL_INTEGER && mode == SImode)\n-\treturn true;\n+      if (TARGET_VSX_SMALL_INTEGER)\n+\t{\n+\t  if (mode == SImode)\n+\t    return true;\n+\n+\t  if (TARGET_P9_VECTOR && (mode == HImode || mode == QImode))\n+\t    return true;\n+\t}\n \n       /* ISA 2.07: MTVSRWZ or  MFVSRWZ.  */\n       if (mode == SDmode)\n@@ -21412,6 +21431,33 @@ rs6000_preferred_reload_class (rtx x, enum reg_class rclass)\n \t  if (GET_CODE (x) == CONST_VECTOR && easy_vector_constant (x, mode))\n \t    return ALTIVEC_REGS;\n \n+\t  /* If this is an integer constant that can easily be loaded into\n+\t     vector registers, allow it.  */\n+\t  if (CONST_INT_P (x))\n+\t    {\n+\t      HOST_WIDE_INT value = INTVAL (x);\n+\n+\t      /* ISA 2.07 can generate -1 in all registers with XXLORC.  ISA\n+\t\t 2.06 can generate it in the Altivec registers with\n+\t\t VSPLTI<x>.  */\n+\t      if (value == -1)\n+\t\t{\n+\t\t  if (TARGET_P8_VECTOR)\n+\t\t    return rclass;\n+\t\t  else if (rclass == ALTIVEC_REGS || rclass == VSX_REGS)\n+\t\t    return ALTIVEC_REGS;\n+\t\t  else\n+\t\t    return NO_REGS;\n+\t\t}\n+\n+\t      /* ISA 3.0 can load -128..127 using the XXSPLTIB instruction and\n+\t\t a sign extend in the Altivec registers.  */\n+\t      if (IN_RANGE (value, -128, 127) && TARGET_P9_VECTOR\n+\t\t  && TARGET_VSX_SMALL_INTEGER\n+\t\t  && (rclass == ALTIVEC_REGS || rclass == VSX_REGS))\n+\t\treturn ALTIVEC_REGS;\n+\t    }\n+\n \t  /* Force constant to memory.  */\n \t  return NO_REGS;\n \t}"}, {"sha": "b3fe92a899cda27279b93ce831905d09efa7b1f6", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 203, "deletions": 108, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=456f0dfa1c8975b3d456dc6ad06e998d8eed22ed", "patch": "@@ -325,6 +325,9 @@\n ; Any supported integer mode that fits in one register.\n (define_mode_iterator INT1 [QI HI SI (DI \"TARGET_POWERPC64\")])\n \n+; Integer modes supported in VSX registers with ISA 3.0 instructions\n+(define_mode_iterator INT_ISA3 [QI HI SI DI])\n+\n ; Everything we can extend QImode to.\n (define_mode_iterator EXTQI [SI (DI \"TARGET_POWERPC64\")])\n \n@@ -334,7 +337,7 @@\n ; Everything we can extend SImode to.\n (define_mode_iterator EXTSI [(DI \"TARGET_POWERPC64\")])\n \n-; QImode or HImode for small atomic ops\n+; QImode or HImode for small integer moves and small atomic ops\n (define_mode_iterator QHI [QI HI])\n \n ; QImode, HImode, SImode for fused ops only for GPR loads\n@@ -735,13 +738,15 @@\n ;; complex forms.  Basic data transfer is done later.\n \n (define_insn \"zero_extendqi<mode>2\"\n-  [(set (match_operand:EXTQI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(zero_extend:EXTQI (match_operand:QI 1 \"reg_or_mem_operand\" \"m,r\")))]\n+  [(set (match_operand:EXTQI 0 \"gpc_reg_operand\" \"=r,r,?*wJwK,?*wK\")\n+\t(zero_extend:EXTQI (match_operand:QI 1 \"reg_or_mem_operand\" \"m,r,Z,*wK\")))]\n   \"\"\n   \"@\n    lbz%U1%X1 %0,%1\n-   rlwinm %0,%1,0,0xff\"\n-  [(set_attr \"type\" \"load,shift\")])\n+   rlwinm %0,%1,0,0xff\n+   lxsibzx %x0,%y1\n+   vextractub %0,%1,7\"\n+  [(set_attr \"type\" \"load,shift,fpload,vecperm\")])\n \n (define_insn_and_split \"*zero_extendqi<mode>2_dot\"\n   [(set (match_operand:CC 2 \"cc_reg_operand\" \"=x,?y\")\n@@ -786,13 +791,15 @@\n \n \n (define_insn \"zero_extendhi<mode>2\"\n-  [(set (match_operand:EXTHI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(zero_extend:EXTHI (match_operand:HI 1 \"reg_or_mem_operand\" \"m,r\")))]\n+  [(set (match_operand:EXTHI 0 \"gpc_reg_operand\" \"=r,r,?*wJwK,?*wK\")\n+\t(zero_extend:EXTHI (match_operand:HI 1 \"reg_or_mem_operand\" \"m,r,Z,wK\")))]\n   \"\"\n   \"@\n    lhz%U1%X1 %0,%1\n-   rlwinm %0,%1,0,0xffff\"\n-  [(set_attr \"type\" \"load,shift\")])\n+   rlwinm %0,%1,0,0xffff\n+   lxsihzx %x0,%y1\n+   vextractuh %0,%1,6\"\n+  [(set_attr \"type\" \"load,shift,fpload,vecperm\")])\n \n (define_insn_and_split \"*zero_extendhi<mode>2_dot\"\n   [(set (match_operand:CC 2 \"cc_reg_operand\" \"=x,?y\")\n@@ -893,11 +900,13 @@\n \n \n (define_insn \"extendqi<mode>2\"\n-  [(set (match_operand:EXTQI 0 \"gpc_reg_operand\" \"=r\")\n-\t(sign_extend:EXTQI (match_operand:QI 1 \"gpc_reg_operand\" \"r\")))]\n+  [(set (match_operand:EXTQI 0 \"gpc_reg_operand\" \"=r,?*wK\")\n+\t(sign_extend:EXTQI (match_operand:QI 1 \"gpc_reg_operand\" \"r,?*wK\")))]\n   \"\"\n-  \"extsb %0,%1\"\n-  [(set_attr \"type\" \"exts\")])\n+  \"@\n+   extsb %0,%1\n+   vextsb2d %0,%1\"\n+  [(set_attr \"type\" \"exts,vecperm\")])\n \n (define_insn_and_split \"*extendqi<mode>2_dot\"\n   [(set (match_operand:CC 2 \"cc_reg_operand\" \"=x,?y\")\n@@ -942,20 +951,36 @@\n \n \n (define_expand \"extendhi<mode>2\"\n-  [(set (match_operand:EXTHI 0 \"gpc_reg_operand\" \"\")\n-\t(sign_extend:EXTHI (match_operand:HI 1 \"gpc_reg_operand\" \"\")))]\n+  [(set (match_operand:EXTHI 0 \"gpc_reg_operand\")\n+\t(sign_extend:EXTHI (match_operand:HI 1 \"gpc_reg_operand\")))]\n   \"\"\n   \"\")\n \n (define_insn \"*extendhi<mode>2\"\n-  [(set (match_operand:EXTHI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(sign_extend:EXTHI (match_operand:HI 1 \"reg_or_mem_operand\" \"m,r\")))]\n+  [(set (match_operand:EXTHI 0 \"gpc_reg_operand\" \"=r,r,?*wK,?*wK\")\n+\t(sign_extend:EXTHI (match_operand:HI 1 \"reg_or_mem_operand\" \"m,r,Z,wK\")))]\n   \"rs6000_gen_cell_microcode\"\n   \"@\n    lha%U1%X1 %0,%1\n-   extsh %0,%1\"\n-  [(set_attr \"type\" \"load,exts\")\n-   (set_attr \"sign_extend\" \"yes\")])\n+   extsh %0,%1\n+   #\n+   vextsh2d %0,%1\"\n+  [(set_attr \"type\" \"load,exts,fpload,vecperm\")\n+   (set_attr \"sign_extend\" \"yes\")\n+   (set_attr \"length\" \"4,4,8,4\")])\n+\n+(define_split\n+  [(set (match_operand:EXTHI 0 \"altivec_register_operand\")\n+\t(sign_extend:EXTHI\n+\t (match_operand:HI 1 \"indexed_or_indirect_operand\")))]\n+  \"TARGET_P9_VECTOR && reload_completed\"\n+  [(set (match_dup 2)\n+\t(match_dup 1))\n+   (set (match_dup 0)\n+\t(sign_extend:EXTHI (match_dup 2)))]\n+{\n+  operands[2] = gen_rtx_REG (HImode, REGNO (operands[1]));\n+})\n \n (define_insn \"*extendhi<mode>2_noload\"\n   [(set (match_operand:EXTHI 0 \"gpc_reg_operand\" \"=r\")\n@@ -5307,30 +5332,33 @@\n    (set_attr \"type\" \"fp\")])\n \n ;; ISA 3.0 adds instructions lxsi[bh]zx to directly load QImode and HImode to\n-;; vector registers.  At the moment, QI/HImode are not allowed in floating\n-;; point or vector registers, so we use UNSPEC's to use the load byte and\n-;; half-word instructions.\n+;; vector registers.  These insns favor doing the sign/zero extension in\n+;; the vector registers, rather then loading up a GPR, doing a sign/zero\n+;; extension and then a direct move.\n \n (define_expand \"float<QHI:mode><FP_ISA3:mode>2\"\n   [(parallel [(set (match_operand:FP_ISA3 0 \"vsx_register_operand\")\n \t\t   (float:FP_ISA3\n \t\t    (match_operand:QHI 1 \"input_operand\")))\n \t      (clobber (match_scratch:DI 2))\n-\t      (clobber (match_scratch:DI 3))])]\n-  \"TARGET_P9_VECTOR && TARGET_DIRECT_MOVE && TARGET_POWERPC64\"\n+\t      (clobber (match_scratch:DI 3))\n+\t      (clobber (match_scratch:<QHI:MODE> 4))])]\n+  \"TARGET_P9_VECTOR && TARGET_DIRECT_MOVE && TARGET_POWERPC64\n+   && TARGET_VSX_SMALL_INTEGER\"\n {\n   if (MEM_P (operands[1]))\n     operands[1] = rs6000_address_for_fpconvert (operands[1]);\n })\n \n (define_insn_and_split \"*float<QHI:mode><FP_ISA3:mode>2_internal\"\n-  [(set (match_operand:FP_ISA3 0 \"vsx_register_operand\" \"=<Fv>,<Fv>\")\n+  [(set (match_operand:FP_ISA3 0 \"vsx_register_operand\" \"=<Fv>,<Fv>,<Fv>\")\n \t(float:FP_ISA3\n-\t (match_operand:QHI 1 \"reg_or_indexed_operand\" \"r,Z\")))\n-   (clobber (match_scratch:DI 2 \"=wi,v\"))\n-   (clobber (match_scratch:DI 3 \"=r,X\"))]\n+\t (match_operand:QHI 1 \"reg_or_indexed_operand\" \"wK,r,Z\")))\n+   (clobber (match_scratch:DI 2 \"=wK,wi,wK\"))\n+   (clobber (match_scratch:DI 3 \"=X,r,X\"))\n+   (clobber (match_scratch:<QHI:MODE> 4 \"=X,X,wK\"))]\n   \"TARGET_P9_VECTOR && TARGET_DIRECT_MOVE && TARGET_POWERPC64\n-   && TARGET_UPPER_REGS_DI\"\n+   && TARGET_UPPER_REGS_DI && TARGET_VSX_SMALL_INTEGER\"\n   \"#\"\n   \"&& reload_completed\"\n   [(const_int 0)]\n@@ -5341,67 +5369,63 @@\n \n   if (!MEM_P (input))\n     {\n-      rtx tmp = operands[3];\n-      emit_insn (gen_extend<QHI:mode>di2 (tmp, input));\n-      emit_move_insn (di, tmp);\n+      if (altivec_register_operand (input, <QHI:MODE>mode))\n+\temit_insn (gen_extend<QHI:mode>di2 (di, input));\n+      else\n+\t{\n+\t  rtx tmp = operands[3];\n+\t  emit_insn (gen_extend<QHI:mode>di2 (tmp, input));\n+\t  emit_move_insn (di, tmp);\n+\t}\n     }\n   else\n     {\n-      machine_mode vmode;\n-      rtx di_vector;\n-\n-      emit_insn (gen_p9_lxsi<QHI:wd>zx (di, input));\n-\n-      if (<MODE>mode == QImode)\n-\tvmode = V16QImode;\n-      else if (<MODE>mode == HImode)\n-\tvmode = V8HImode;\n-      else\n-\tgcc_unreachable ();\n-\n-      di_vector = gen_rtx_REG (vmode, REGNO (di));\n-      emit_insn (gen_vsx_sign_extend_<QHI:mode>_di (di, di_vector));\n+      rtx tmp = operands[4];\n+      emit_move_insn (tmp, input);\n+      emit_insn (gen_extend<QHI:mode>di2 (di, tmp));\n     }\n \n   emit_insn (gen_floatdi<FP_ISA3:mode>2 (result, di));\n   DONE;\n })\n \n (define_expand \"floatuns<QHI:mode><FP_ISA3:mode>2\"\n-  [(parallel [(set (match_operand:FP_ISA3 0 \"vsx_register_operand\" \"\")\n+  [(parallel [(set (match_operand:FP_ISA3 0 \"vsx_register_operand\")\n \t\t   (unsigned_float:FP_ISA3\n \t\t    (match_operand:QHI 1 \"input_operand\" \"\")))\n \t      (clobber (match_scratch:DI 2 \"\"))\n \t      (clobber (match_scratch:DI 3 \"\"))])]\n-  \"TARGET_P9_VECTOR && TARGET_DIRECT_MOVE && TARGET_POWERPC64\"\n+  \"TARGET_P9_VECTOR && TARGET_DIRECT_MOVE && TARGET_POWERPC64\n+   && TARGET_VSX_SMALL_INTEGER\"\n {\n   if (MEM_P (operands[1]))\n     operands[1] = rs6000_address_for_fpconvert (operands[1]);\n })\n \n (define_insn_and_split \"*floatuns<QHI:mode><FP_ISA3:mode>2_internal\"\n-  [(set (match_operand:FP_ISA3 0 \"vsx_register_operand\" \"=<Fv>,<Fv>\")\n+  [(set (match_operand:FP_ISA3 0 \"vsx_register_operand\" \"=<Fv>,<Fv>,<Fv>\")\n \t(unsigned_float:FP_ISA3\n-\t (match_operand:QHI 1 \"reg_or_indexed_operand\" \"r,Z\")))\n-   (clobber (match_scratch:DI 2 \"=wi,wi\"))\n-   (clobber (match_scratch:DI 3 \"=r,X\"))]\n-  \"TARGET_P9_VECTOR && TARGET_DIRECT_MOVE && TARGET_POWERPC64\"\n+\t (match_operand:QHI 1 \"reg_or_indexed_operand\" \"wJwK,r,Z\")))\n+   (clobber (match_scratch:DI 2 \"=wK,wi,wJwK\"))\n+   (clobber (match_scratch:DI 3 \"=X,r,X\"))]\n+  \"TARGET_P9_VECTOR && TARGET_DIRECT_MOVE && TARGET_POWERPC64\n+   && TARGET_VSX_SMALL_INTEGER\"\n   \"#\"\n   \"&& reload_completed\"\n   [(const_int 0)]\n {\n   rtx result = operands[0];\n   rtx input = operands[1];\n   rtx di = operands[2];\n-  rtx tmp = operands[3];\n \n-  if (!MEM_P (input))\n+  if (MEM_P (input) || altivec_register_operand (input, <QHI:MODE>mode))\n+    emit_insn (gen_zero_extend<QHI:mode>di2 (di, input));\n+  else\n     {\n+      rtx tmp = operands[3];\n       emit_insn (gen_zero_extend<QHI:mode>di2 (tmp, input));\n       emit_move_insn (di, tmp);\n     }\n-  else\n-    emit_insn (gen_p9_lxsi<QHI:wd>zx (di, input));\n \n   emit_insn (gen_floatdi<FP_ISA3:mode>2 (result, di));\n   DONE;\n@@ -5516,19 +5540,43 @@\n   [(set_attr \"type\" \"fp\")])\n \n (define_expand \"fix_trunc<SFDF:mode><QHI:mode>2\"\n-  [(use (match_operand:QHI 0 \"rs6000_nonimmediate_operand\" \"\"))\n-   (use (match_operand:SFDF 1 \"vsx_register_operand\" \"\"))]\n-  \"TARGET_P9_VECTOR && TARGET_DIRECT_MOVE && TARGET_POWERPC64\"\n+  [(parallel [(set (match_operand:<QHI:MODE> 0 \"nonimmediate_operand\")\n+\t\t   (fix:QHI (match_operand:SFDF 1 \"gpc_reg_operand\")))\n+\t      (clobber (match_scratch:DI 2))])]\n+  \"TARGET_P9_VECTOR && TARGET_DIRECT_MOVE_64BIT\n+   && TARGET_VSX_SMALL_INTEGER\"\n+{\n+  if (MEM_P (operands[0]))\n+    operands[0] = rs6000_address_for_fpconvert (operands[0]);\n+})\n+\n+(define_insn_and_split \"*fix_trunc<SFDF:mode><QHI:mode>2_internal\"\n+  [(set (match_operand:<QHI:MODE> 0 \"reg_or_indexed_operand\" \"=wIwJ,rZ\")\n+\t(fix:QHI\n+\t (match_operand:SFDF 1 \"gpc_reg_operand\" \"<SFDF:Fv>,<SFDF:Fv>\")))\n+   (clobber (match_scratch:DI 2 \"=X,wi\"))]\n+  \"TARGET_P9_VECTOR && TARGET_DIRECT_MOVE_64BIT\n+   && TARGET_VSX_SMALL_INTEGER\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n {\n-  rtx op0 = operands[0];\n-  rtx op1 = operands[1];\n-  rtx di_tmp = gen_reg_rtx (DImode);\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n \n-  if (MEM_P (op0))\n-    op0 = rs6000_address_for_fpconvert (op0);\n+  if (vsx_register_operand (dest, <QHI:MODE>mode))\n+    {\n+      rtx di_dest = gen_rtx_REG (DImode, REGNO (dest));\n+      emit_insn (gen_fix_trunc<SFDF:mode>di2 (di_dest, src));\n+    }\n+  else\n+    {\n+      rtx tmp = operands[2];\n+      rtx tmp2 = gen_rtx_REG (<QHI:MODE>mode, REGNO (tmp));\n \n-  emit_insn (gen_fctiwz_<SFDF:mode> (di_tmp, op1));\n-  emit_insn (gen_p9_stxsi<QHI:wd>x (op0, di_tmp));\n+      emit_insn (gen_fix_trunc<SFDF:mode>di2 (tmp, src));\n+      emit_move_insn (dest, tmp2);\n+    }\n   DONE;\n })\n \n@@ -5605,22 +5653,45 @@\n   [(set_attr \"type\" \"fp\")])\n \n (define_expand \"fixuns_trunc<SFDF:mode><QHI:mode>2\"\n-  [(use (match_operand:QHI 0 \"rs6000_nonimmediate_operand\" \"\"))\n-   (use (match_operand:SFDF 1 \"vsx_register_operand\" \"\"))]\n-  \"TARGET_P9_VECTOR && TARGET_DIRECT_MOVE && TARGET_POWERPC64\"\n+  [(parallel [(set (match_operand:<QHI:MODE> 0 \"nonimmediate_operand\")\n+\t\t   (unsigned_fix:QHI (match_operand:SFDF 1 \"gpc_reg_operand\")))\n+\t      (clobber (match_scratch:DI 2))])]\n+  \"TARGET_P9_VECTOR && TARGET_DIRECT_MOVE_64BIT\n+   && TARGET_VSX_SMALL_INTEGER\"\n+{\n+  if (MEM_P (operands[0]))\n+    operands[0] = rs6000_address_for_fpconvert (operands[0]);\n+})\n+\n+(define_insn_and_split \"*fixuns_trunc<SFDF:mode><QHI:mode>2_internal\"\n+  [(set (match_operand:<QHI:MODE> 0 \"reg_or_indexed_operand\" \"=wIwJ,rZ\")\n+\t(unsigned_fix:QHI\n+\t (match_operand:SFDF 1 \"gpc_reg_operand\" \"<SFDF:Fv>,<SFDF:Fv>\")))\n+   (clobber (match_scratch:DI 2 \"=X,wi\"))]\n+  \"TARGET_P9_VECTOR && TARGET_DIRECT_MOVE_64BIT\n+   && TARGET_VSX_SMALL_INTEGER\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n {\n-  rtx op0 = operands[0];\n-  rtx op1 = operands[1];\n-  rtx di_tmp = gen_reg_rtx (DImode);\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n \n-  if (MEM_P (op0))\n-    op0 = rs6000_address_for_fpconvert (op0);\n+  if (vsx_register_operand (dest, <QHI:MODE>mode))\n+    {\n+      rtx di_dest = gen_rtx_REG (DImode, REGNO (dest));\n+      emit_insn (gen_fixuns_trunc<SFDF:mode>di2 (di_dest, src));\n+    }\n+  else\n+    {\n+      rtx tmp = operands[2];\n+      rtx tmp2 = gen_rtx_REG (<QHI:MODE>mode, REGNO (tmp));\n \n-  emit_insn (gen_fctiwuz_<SFDF:mode> (di_tmp, op1));\n-  emit_insn (gen_p9_stxsi<QHI:wd>x (op0, di_tmp));\n+      emit_insn (gen_fixuns_trunc<SFDF:mode>di2 (tmp, src));\n+      emit_move_insn (dest, tmp2);\n+    }\n   DONE;\n })\n-\n ; Here, we use (set (reg) (unspec:DI [(fix:SI ...)] UNSPEC_FCTIWZ))\n ; rather than (set (subreg:SI (reg)) (fix:SI ...))\n ; because the first makes it clear that operand 0 is not live\n@@ -6643,8 +6714,8 @@\n \n ;; Split loading -128..127 to use XXSPLITB and VEXTSW2D\n (define_split\n-  [(set (match_operand:DI 0 \"altivec_register_operand\" \"\")\n-\t(match_operand:DI 1 \"xxspltib_constant_split\" \"\"))]\n+  [(set (match_operand:DI 0 \"altivec_register_operand\")\n+\t(match_operand:DI 1 \"xxspltib_constant_split\"))]\n   \"TARGET_VSX_SMALL_INTEGER && TARGET_P9_VECTOR && reload_completed\"\n   [(const_int 0)]\n {\n@@ -6684,41 +6755,55 @@\n \t\t    (const_int 0)))]\n   \"\")\n \f\n-(define_insn \"*movhi_internal\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,m,r,r,*c*l,*h\")\n-\t(match_operand:HI 1 \"input_operand\" \"r,m,r,i,*h,r,0\"))]\n-  \"gpc_reg_operand (operands[0], HImode)\n-   || gpc_reg_operand (operands[1], HImode)\"\n-  \"@\n-   mr %0,%1\n-   lhz%U1%X1 %0,%1\n-   sth%U0%X0 %1,%0\n-   li %0,%w1\n-   mf%1 %0\n-   mt%0 %1\n-   nop\"\n-  [(set_attr \"type\" \"*,load,store,*,mfjmpr,mtjmpr,*\")])\n-\n (define_expand \"mov<mode>\"\n   [(set (match_operand:INT 0 \"general_operand\" \"\")\n \t(match_operand:INT 1 \"any_operand\" \"\"))]\n   \"\"\n   \"{ rs6000_emit_move (operands[0], operands[1], <MODE>mode); DONE; }\")\n \n-(define_insn \"*movqi_internal\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r,m,r,r,*c*l,*h\")\n-\t(match_operand:QI 1 \"input_operand\" \"r,m,r,i,*h,r,0\"))]\n-  \"gpc_reg_operand (operands[0], QImode)\n-   || gpc_reg_operand (operands[1], QImode)\"\n+;;\t\tMR          LHZ/LBZ    LXSI*ZX    STH/STB    STXSI*X    LI\n+;;\t\tXXLOR       load 0     load -1    VSPLTI*    #          MFVSRWZ\n+;;\t\tMTVSRWZ     MF%1       MT%1       NOP\n+(define_insn \"*mov<mode>_internal\"\n+  [(set (match_operand:QHI 0 \"nonimmediate_operand\"\n+\t\t\"=r,        r,         ?*wJwK,    m,         Z,         r,\n+\t\t ?*wJwK,    ?*wJwK,    ?*wJwK,    ?*wK,      ?*wK,      r,\n+\t\t ?*wJwK,    r,         *c*l,      *h\")\n+\n+\t(match_operand:QHI 1 \"input_operand\"\n+\t\t\"r,         m,         Z,         r,         wJwK,      i,\n+\t\t wJwK,      O,         wM,        wB,        wS,        ?*wJwK,\n+\t\t r,         *h,        r,         0\"))]\n+\n+  \"gpc_reg_operand (operands[0], <MODE>mode)\n+   || gpc_reg_operand (operands[1], <MODE>mode)\"\n   \"@\n    mr %0,%1\n-   lbz%U1%X1 %0,%1\n-   stb%U0%X0 %1,%0\n+   l<wd>z%U1%X1 %0,%1\n+   lxsi<wd>zx %x0,%y1\n+   st<wd>%U0%X0 %1,%0\n+   stxsi<wd>x %1,%y0\n    li %0,%1\n+   xxlor %x0,%x1,%x1\n+   xxspltib %x0,0\n+   xxspltib %x0,255\n+   vspltis<wd> %0,%1\n+   #\n+   mfvsrwz %0,%x1\n+   mtvsrwz %x0,%1\n    mf%1 %0\n    mt%0 %1\n    nop\"\n-  [(set_attr \"type\" \"*,load,store,*,mfjmpr,mtjmpr,*\")])\n+  [(set_attr \"type\"\n+\t\t\"*,         load,      fpload,    store,     fpstore,   *,\n+\t\t vecsimple, vecperm,   vecperm,   vecperm,   vecperm,   mftgpr,\n+\t\t mffgpr,    mfjmpr,    mtjmpr,    *\")\n+\n+   (set_attr \"length\"\n+\t\t\"4,         4,         4,         4,         4,         4,\n+\t\t 4,         4,         4,         4,         8,         4,\n+\t\t 4,         4,         4,         4\")])\n+\n \f\n ;; Here is how to move condition codes around.  When we store CC data in\n ;; an integer register or memory, we store just the high-order 4 bits.\n@@ -8142,7 +8227,7 @@\n    xxlor %x0,%x1,%x1\n    xxspltib %x0,0\n    xxspltib %x0,255\n-   vspltisw %0,%1\n+   #\n    xxlxor %x0,%x0,%x0\n    xxlorc %x0,%x0,%x0\n    #\n@@ -8236,9 +8321,11 @@\n   DONE;\n })\n \n+;; Split integer constants that can be loaded with XXSPLTIB and a\n+;; sign extend operation.\n (define_split\n-  [(set (match_operand:DI 0 \"altivec_register_operand\" \"\")\n-\t(match_operand:DI 1 \"xxspltib_constant_split\" \"\"))]\n+  [(set (match_operand:INT_ISA3 0 \"altivec_register_operand\" \"\")\n+\t(match_operand:INT_ISA3 1 \"xxspltib_constant_split\" \"\"))]\n   \"TARGET_UPPER_REGS_DI && TARGET_P9_VECTOR && reload_completed\"\n   [(const_int 0)]\n {\n@@ -8248,7 +8335,15 @@\n   rtx op0_v16qi = gen_rtx_REG (V16QImode, r);\n \n   emit_insn (gen_xxspltib_v16qi (op0_v16qi, op1));\n-  emit_insn (gen_vsx_sign_extend_qi_di (operands[0], op0_v16qi));\n+  if (<MODE>mode == DImode)\n+    emit_insn (gen_vsx_sign_extend_qi_di (operands[0], op0_v16qi));\n+  else if (<MODE>mode == SImode)\n+    emit_insn (gen_vsx_sign_extend_qi_si (operands[0], op0_v16qi));\n+  else if (<MODE>mode == HImode)\n+    {\n+      rtx op0_v8hi = gen_rtx_REG (V8HImode, r);\n+      emit_insn (gen_altivec_vupkhsb (op0_v8hi, op0_v16qi));\n+    }\n   DONE;\n })\n "}, {"sha": "ebb0f6dc09966729d73b16238803d3e51efa203b", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 59, "deletions": 84, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=456f0dfa1c8975b3d456dc6ad06e998d8eed22ed", "patch": "@@ -338,7 +338,6 @@\n    UNSPEC_VSX_XVCVDPSXDS\n    UNSPEC_VSX_XVCVDPUXDS\n    UNSPEC_VSX_SIGN_EXTEND\n-   UNSPEC_P9_MEMORY\n    UNSPEC_VSX_VSLO\n    UNSPEC_VSX_EXTRACT\n    UNSPEC_VSX_SXEXPDP\n@@ -2519,72 +2518,29 @@\n ;; types are currently allowed in a vector register, so we extract to a DImode\n ;; and either do a direct move or store.\n (define_expand  \"vsx_extract_<mode>\"\n-  [(parallel [(set (match_operand:<VS_scalar> 0 \"nonimmediate_operand\")\n+  [(parallel [(set (match_operand:<VS_scalar> 0 \"gpc_reg_operand\")\n \t\t   (vec_select:<VS_scalar>\n \t\t    (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\")\n \t\t    (parallel [(match_operand:QI 2 \"const_int_operand\")])))\n-\t      (clobber (match_dup 3))])]\n+\t      (clobber (match_scratch:VSX_EXTRACT_I 3))])]\n   \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_DIRECT_MOVE_64BIT\"\n {\n-  machine_mode smode = ((<MODE>mode != V4SImode && TARGET_VEXTRACTUB)\n-\t\t\t? DImode : <MODE>mode);\n-  operands[3] = gen_rtx_SCRATCH (smode);\n-})\n-\n-;; Under ISA 3.0, we can use the byte/half-word/word integer stores if we are\n-;; extracting a vector element and storing it to memory, rather than using\n-;; direct move to a GPR and a GPR store.\n-(define_insn_and_split  \"*vsx_extract_<mode>_p9\"\n-  [(set (match_operand:<VS_scalar> 0 \"nonimmediate_operand\" \"=r,Z\")\n-\t(vec_select:<VS_scalar>\n-\t (match_operand:VSX_EXTRACT_I2 1 \"gpc_reg_operand\" \"v,v\")\n-\t (parallel [(match_operand:QI 2 \"<VSX_EXTRACT_PREDICATE>\" \"n,n\")])))\n-   (clobber (match_scratch:DI 3 \"=v,v\"))]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_VEXTRACTUB\"\n-  \"#\"\n-  \"&& (reload_completed || MEM_P (operands[0]))\"\n-  [(const_int 0)]\n-{\n-  rtx dest = operands[0];\n-  rtx src = operands[1];\n-  rtx element = operands[2];\n-  rtx di_tmp = operands[3];\n-\n-  if (GET_CODE (di_tmp) == SCRATCH)\n-    di_tmp = gen_reg_rtx (DImode);\n-\n-  emit_insn (gen_vsx_extract_<mode>_di (di_tmp, src, element));\n-\n-  if (REG_P (dest))\n-    emit_move_insn (gen_rtx_REG (DImode, REGNO (dest)), di_tmp);\n-  else if (SUBREG_P (dest))\n-    emit_move_insn (gen_rtx_REG (DImode, subreg_regno (dest)), di_tmp);\n-  else if (MEM_P (operands[0]))\n+  /* If we have ISA 3.0, we can do a xxextractuw/vextractu{b,h}.  */\n+  if (TARGET_VSX_SMALL_INTEGER && TARGET_P9_VECTOR)\n     {\n-      if (can_create_pseudo_p ())\n-\tdest = rs6000_address_for_fpconvert (dest);\n-\n-      if (<MODE>mode == V16QImode)\n-\temit_insn (gen_p9_stxsibx (dest, di_tmp));\n-      else if (<MODE>mode == V8HImode)\n-\temit_insn (gen_p9_stxsihx (dest, di_tmp));\n-      else\n-\tgcc_unreachable ();\n+      emit_insn (gen_vsx_extract_<mode>_p9 (operands[0], operands[1],\n+\t\t\t\t\t    operands[2]));\n+      DONE;\n     }\n-  else\n-    gcc_unreachable ();\n-\n-  DONE;\n-}\n-  [(set_attr \"type\" \"vecsimple,fpstore\")])\n+})\n \n-(define_insn  \"vsx_extract_<mode>_di\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=<VSX_EX>\")\n-\t(zero_extend:DI\n-\t (vec_select:<VS_scalar>\n-\t  (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"<VSX_EX>\")\n-\t  (parallel [(match_operand:QI 2 \"<VSX_EXTRACT_PREDICATE>\" \"n\")]))))]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_VEXTRACTUB\"\n+(define_insn \"vsx_extract_<mode>_p9\"\n+  [(set (match_operand:<VS_scalar> 0 \"gpc_reg_operand\" \"=<VSX_EX>\")\n+\t(vec_select:<VS_scalar>\n+\t (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"<VSX_EX>\")\n+\t (parallel [(match_operand:QI 2 \"<VSX_EXTRACT_PREDICATE>\" \"n\")])))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_VEXTRACTUB\n+   && TARGET_VSX_SMALL_INTEGER\"\n {\n   /* Note, the element number has already been adjusted for endianness, so we\n      don't have to adjust it here.  */\n@@ -2599,13 +2555,51 @@\n }\n   [(set_attr \"type\" \"vecsimple\")])\n \n+;; Optimize zero extracts to eliminate the AND after the extract.\n+(define_insn_and_split \"*vsx_extract_<mode>_di_p9\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=<VSX_EX>\")\n+\t(zero_extend:DI\n+\t (vec_select:<VS_scalar>\n+\t  (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"<VSX_EX>\")\n+\t  (parallel [(match_operand:QI 2 \"const_int_operand\" \"n\")]))))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_VEXTRACTUB\n+   && TARGET_VSX_SMALL_INTEGER\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 3)\n+\t(vec_select:<VS_scalar>\n+\t (match_dup 1)\n+\t (parallel [(match_dup 2)])))]\n+{\n+  operands[3] = gen_rtx_REG (<VS_scalar>mode, REGNO (operands[0]));\n+})\n+\n+;; Optimize stores to use the ISA 3.0 scalar store instructions\n+(define_insn_and_split \"*vsx_extract_<mode>_store_p9\"\n+  [(set (match_operand:<VS_scalar> 0 \"memory_operand\" \"=Z\")\n+\t(vec_select:<VS_scalar>\n+\t (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"<VSX_EX>\")\n+\t (parallel [(match_operand:QI 2 \"const_int_operand\" \"n\")])))\n+   (clobber (match_scratch:<VS_scalar> 3 \"=<VSX_EX>\"))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_VEXTRACTUB\n+   && TARGET_VSX_SMALL_INTEGER\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 3)\n+\t(vec_select:<VS_scalar>\n+\t (match_dup 1)\n+\t (parallel [(match_dup 2)])))\n+   (set (match_dup 0)\n+\t(match_dup 3))])\n+\n (define_insn_and_split  \"*vsx_extract_si\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,wHwI,Z\")\n \t(vec_select:SI\n \t (match_operand:V4SI 1 \"gpc_reg_operand\" \"wJv,wJv,wJv\")\n \t (parallel [(match_operand:QI 2 \"const_0_to_3_operand\" \"n,n,n\")])))\n    (clobber (match_scratch:V4SI 3 \"=wJv,wJv,wJv\"))]\n-  \"VECTOR_MEM_VSX_P (V4SImode) && TARGET_DIRECT_MOVE_64BIT\"\n+  \"VECTOR_MEM_VSX_P (V4SImode) && TARGET_DIRECT_MOVE_64BIT\n+   && (!TARGET_P9_VECTOR || !TARGET_VSX_SMALL_INTEGER)\"\n   \"#\"\n   \"&& reload_completed\"\n   [(const_int 0)]\n@@ -2624,10 +2618,10 @@\n   value = INTVAL (element);\n   if (value != 1)\n     {\n-      if (TARGET_VEXTRACTUB)\n+      if (TARGET_P9_VECTOR && TARGET_VSX_SMALL_INTEGER)\n \t{\n-\t  rtx di_tmp = gen_rtx_REG (DImode, REGNO (vec_tmp));\n-\t  emit_insn (gen_vsx_extract_v4si_di (di_tmp,src, element));\n+\t  rtx si_tmp = gen_rtx_REG (SImode, REGNO (vec_tmp));\n+\t  emit_insn (gen_vsx_extract_v4si_p9 (si_tmp,src, element));\n \t}\n       else\n \temit_insn (gen_altivec_vspltw_direct (vec_tmp, src, element));\n@@ -2663,7 +2657,8 @@\n \t (match_operand:VSX_EXTRACT_I2 1 \"gpc_reg_operand\" \"v\")\n \t (parallel [(match_operand:QI 2 \"<VSX_EXTRACT_PREDICATE>\" \"n\")])))\n    (clobber (match_scratch:VSX_EXTRACT_I2 3 \"=v\"))]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_DIRECT_MOVE_64BIT\"\n+  \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_DIRECT_MOVE_64BIT\n+   && (!TARGET_P9_VECTOR || !TARGET_VSX_SMALL_INTEGER)\"\n   \"#\"\n   \"&& reload_completed\"\n   [(const_int 0)]\n@@ -3253,26 +3248,6 @@\n   [(set_attr \"type\" \"vecexts\")])\n \n \f\n-;; ISA 3.0 memory operations\n-(define_insn \"p9_lxsi<wd>zx\"\n-  [(set (match_operand:DI 0 \"vsx_register_operand\" \"=wi\")\n-\t(unspec:DI [(zero_extend:DI\n-\t\t     (match_operand:QHI 1 \"indexed_or_indirect_operand\" \"Z\"))]\n-\t\t   UNSPEC_P9_MEMORY))]\n-  \"TARGET_P9_VECTOR\"\n-  \"lxsi<wd>zx %x0,%y1\"\n-  [(set_attr \"type\" \"fpload\")])\n-\n-(define_insn \"p9_stxsi<wd>x\"\n-  [(set (match_operand:QHI 0 \"reg_or_indexed_operand\" \"=r,Z\")\n-\t(unspec:QHI [(match_operand:DI 1 \"vsx_register_operand\" \"wi,wi\")]\n-\t\t    UNSPEC_P9_MEMORY))]\n-  \"TARGET_P9_VECTOR\"\n-  \"@\n-   mfvsrd %0,%x1\n-   stxsi<wd>x %x1,%y0\"\n-  [(set_attr \"type\" \"mffgpr,fpstore\")])\n-\n ;; ISA 3.0 Binary Floating-Point Support\n \n ;; VSX Scalar Extract Exponent Double-Precision"}, {"sha": "6c82dbf281299749b445e9ab00f4257be304f669", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=456f0dfa1c8975b3d456dc6ad06e998d8eed22ed", "patch": "@@ -1,3 +1,15 @@\n+2016-11-10  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/vsx-qimode.c: New test for QImode, HImode\n+\tbeing allowed in vector registers.\n+\t* gcc.target/powerpc/vsx-qimode2.c: Likewise.\n+\t* gcc.target/powerpc/vsx-qimode3.c: Likewise.\n+\t* gcc.target/powerpc/vsx-himode.c: Likewise.\n+\t* gcc.target/powerpc/vsx-himode2.c: Likewise.\n+\t* gcc.target/powerpc/vsx-himode3.c: Likewise.\n+\t* gcc.target/powerpc/p9-extract-1.c: Change MFVSRD to just MFVSR,\n+\tto allow matching MFVSRD or MFVSRW.\n+\n 2016-11-10  Pat Haugen  <pthaugen@us.ibm.com>\n \n \tPR rtl-optimization/78241"}, {"sha": "fceb334195eaec648b6dce3958d1449c6d6d9554", "filename": "gcc/testsuite/gcc.target/powerpc/p9-extract-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-extract-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-extract-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-extract-1.c?ref=456f0dfa1c8975b3d456dc6ad06e998d8eed22ed", "patch": "@@ -17,7 +17,7 @@ int extract_schar_3 (vector signed char a) { return vec_extract (a, 15); }\n /* { dg-final { scan-assembler     \"vextractub\"  } } */\n /* { dg-final { scan-assembler     \"vextractuh\"  } } */\n /* { dg-final { scan-assembler     \"xxextractuw\" } } */\n-/* { dg-final { scan-assembler     \"mfvsrd\"      } } */\n+/* { dg-final { scan-assembler     \"mfvsr\"       } } */\n /* { dg-final { scan-assembler-not \"stxvd2x\"     } } */\n /* { dg-final { scan-assembler-not \"stxv\"        } } */\n /* { dg-final { scan-assembler-not \"lwa\"         } } */"}, {"sha": "883864e58855dfbce9817178423d0f29116d002d", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-himode.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-himode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-himode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-himode.c?ref=456f0dfa1c8975b3d456dc6ad06e998d8eed22ed", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2 -mvsx-small-integer\" } */\n+\n+double load_asm_d_constraint (short *p)\n+{\n+  double ret;\n+  __asm__ (\"xxlor %x0,%x1,%x1\\t# load d constraint\" : \"=d\" (ret) : \"d\" (*p));\n+  return ret;\n+}\n+\n+void store_asm_d_constraint (short *p, double x)\n+{\n+  short i;\n+  __asm__ (\"xxlor %x0,%x1,%x1\\t# store d constraint\" : \"=d\" (i) : \"d\" (x));\n+  *p = i;\n+}\n+\n+/* { dg-final { scan-assembler \"lxsihzx\" } } */\n+/* { dg-final { scan-assembler \"stxsihx\" } } */"}, {"sha": "96de758e988465787d9d79fc4943c0f3c14be4d7", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-himode2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-himode2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-himode2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-himode2.c?ref=456f0dfa1c8975b3d456dc6ad06e998d8eed22ed", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2 -mvsx-small-integer\" } */\n+\n+unsigned int foo (unsigned short u)\n+{\n+  unsigned int ret;\n+  __asm__ (\"xxlor %x0,%x1,%x1\\t# v, v constraints\" : \"=v\" (ret) : \"v\" (u));\n+  return ret;\n+}\n+\n+/* { dg-final { scan-assembler \"mtvsrwz\" } } */\n+/* { dg-final { scan-assembler \"mfvsrwz\" } } */"}, {"sha": "2f4a858d3d8871fe67dd40d06d36120ad6b0815a", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-himode3.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-himode3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-himode3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-himode3.c?ref=456f0dfa1c8975b3d456dc6ad06e998d8eed22ed", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2 -mvsx-small-integer\" } */\n+\n+double load_asm_v_constraint (short *p)\n+{\n+  double ret;\n+  __asm__ (\"xxlor %x0,%x1,%x1\\t# load v constraint\" : \"=d\" (ret) : \"v\" (*p));\n+  return ret;\n+}\n+\n+void store_asm_v_constraint (short *p, double x)\n+{\n+  short i;\n+  __asm__ (\"xxlor %x0,%x1,%x1\\t# store v constraint\" : \"=v\" (i) : \"d\" (x));\n+  *p = i;\n+}\n+\n+/* { dg-final { scan-assembler \"lxsihzx\" } } */\n+/* { dg-final { scan-assembler \"stxsihx\" } } */"}, {"sha": "eb82c56c29b2c6eb144bb45cf0d6e85a4083e893", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-qimode.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-qimode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-qimode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-qimode.c?ref=456f0dfa1c8975b3d456dc6ad06e998d8eed22ed", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2 -mvsx-small-integer\" } */\n+\n+double load_asm_d_constraint (signed char *p)\n+{\n+  double ret;\n+  __asm__ (\"xxlor %x0,%x1,%x1\\t# load d constraint\" : \"=d\" (ret) : \"d\" (*p));\n+  return ret;\n+}\n+\n+void store_asm_d_constraint (signed char *p, double x)\n+{\n+  signed char i;\n+  __asm__ (\"xxlor %x0,%x1,%x1\\t# store d constraint\" : \"=d\" (i) : \"d\" (x));\n+  *p = i;\n+}\n+\n+/* { dg-final { scan-assembler \"lxsibzx\" } } */\n+/* { dg-final { scan-assembler \"stxsibx\" } } */"}, {"sha": "02aa2072836890973b03c2147d543c31229073d7", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-qimode2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-qimode2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-qimode2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-qimode2.c?ref=456f0dfa1c8975b3d456dc6ad06e998d8eed22ed", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2 -mvsx-small-integer\" } */\n+\n+unsigned int foo (unsigned char u)\n+{\n+  unsigned int ret;\n+  __asm__ (\"xxlor %x0,%x1,%x1\\t# v, v constraints\" : \"=v\" (ret) : \"v\" (u));\n+  return ret;\n+}\n+\n+/* { dg-final { scan-assembler \"mtvsrwz\" } } */\n+/* { dg-final { scan-assembler \"mfvsrwz\" } } */"}, {"sha": "0e1da3291057bf518193bc5a3b36d744936ec130", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-qimode3.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-qimode3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456f0dfa1c8975b3d456dc6ad06e998d8eed22ed/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-qimode3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-qimode3.c?ref=456f0dfa1c8975b3d456dc6ad06e998d8eed22ed", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2 -mvsx-small-integer\" } */\n+\n+double load_asm_v_constraint (signed char *p)\n+{\n+  double ret;\n+  __asm__ (\"xxlor %x0,%x1,%x1\\t# load v constraint\" : \"=d\" (ret) : \"v\" (*p));\n+  return ret;\n+}\n+\n+void store_asm_v_constraint (signed char *p, double x)\n+{\n+  signed char i;\n+  __asm__ (\"xxlor %x0,%x1,%x1\\t# store v constraint\" : \"=v\" (i) : \"d\" (x));\n+  *p = i;\n+}\n+\n+/* { dg-final { scan-assembler \"lxsibzx\" } } */\n+/* { dg-final { scan-assembler \"stxsibx\" } } */"}]}