{"sha": "35fbda430dff88d550d1c73d4499f0c6aceece4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzVmYmRhNDMwZGZmODhkNTUwZDFjNzNkNDQ5OWYwYzZhY2VlY2U0ZQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2016-04-11T19:45:35Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-04-11T19:45:35Z"}, "message": "re PR target/70381 (On powerpc, -mfloat128 is on by default for all VSX systems)\n\n[gcc]\n2016-04-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/70381\n\t* config/rs6000/rs6000.c (rs6000_opt_masks): Disable using the\n\ttarget attribute and pragma from changing the -mfloat128\n\tand -mfloat128-hardware options.\n\n\t* doc/extend.texi (Additional Floating Types): Document PowerPC\n\t__float128 restrictions.\n\n[libgcc]\n2016-04-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/70381\n\t* configure.ac (powerpc*-*-linux*): Rework tests to build\n\t__float128 emulation routines to not depend on using #pragma GCC\n\ttarget to enable -mfloat128.\n\t* configure: Regnerate.\n\n[gcc/testsuite]\n2016-04-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/70381\n\t* gcc.target/powerpc/float128-1.c: New tests to make sure the\n\t__float128 emulator is built and runs.\n\t* gcc.target/powerpc/float128-1.c: Likewise.\n\n\t* lib/target-supports.exp (check_ppc_float128_sw_available):\n\tRework tests for __float128 software and hardware\n\tavailability. Fix exit condition to return 0 on success.\n\nFrom-SVN: r234884", "tree": {"sha": "17fc7642002652c4807a5bd71789fcefe83fb7db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17fc7642002652c4807a5bd71789fcefe83fb7db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35fbda430dff88d550d1c73d4499f0c6aceece4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35fbda430dff88d550d1c73d4499f0c6aceece4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35fbda430dff88d550d1c73d4499f0c6aceece4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35fbda430dff88d550d1c73d4499f0c6aceece4e/comments", "author": null, "committer": null, "parents": [{"sha": "a9c2f3d9af1ba5ef57d98bd48b5f1689b42082e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9c2f3d9af1ba5ef57d98bd48b5f1689b42082e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9c2f3d9af1ba5ef57d98bd48b5f1689b42082e5"}], "stats": {"total": 462, "additions": 438, "deletions": 24}, "files": [{"sha": "a01ee426005ca900822019db77c1877c3c7d1a3e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fbda430dff88d550d1c73d4499f0c6aceece4e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fbda430dff88d550d1c73d4499f0c6aceece4e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=35fbda430dff88d550d1c73d4499f0c6aceece4e", "patch": "@@ -1,3 +1,13 @@\n+2016-04-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/70381\n+\t* config/rs6000/rs6000.c (rs6000_opt_masks): Disable using the\n+\ttarget attribute and pragma from changing the -mfloat128\n+\tand -mfloat128-hardware options.\n+\n+\t* doc/extend.texi (Additional Floating Types): Document PowerPC\n+\t__float128 restrictions.\n+\n 2016-04-11  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \tPR target/70133"}, {"sha": "c63fa06aa1a07a0728c59175024b4fbb4608c141", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fbda430dff88d550d1c73d4499f0c6aceece4e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fbda430dff88d550d1c73d4499f0c6aceece4e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=35fbda430dff88d550d1c73d4499f0c6aceece4e", "patch": "@@ -34381,8 +34381,8 @@ static struct rs6000_opt_mask const rs6000_opt_masks[] =\n   { \"dlmzb\",\t\t\tOPTION_MASK_DLMZB,\t\tfalse, true  },\n   { \"efficient-unaligned-vsx\",\tOPTION_MASK_EFFICIENT_UNALIGNED_VSX,\n \t\t\t\t\t\t\t\tfalse, true  },\n-  { \"float128\",\t\t\tOPTION_MASK_FLOAT128,\t\tfalse, true  },\n-  { \"float128-hardware\",\tOPTION_MASK_FLOAT128_HW,\tfalse, true  },\n+  { \"float128\",\t\t\tOPTION_MASK_FLOAT128,\t\tfalse, false },\n+  { \"float128-hardware\",\tOPTION_MASK_FLOAT128_HW,\tfalse, false },\n   { \"fprnd\",\t\t\tOPTION_MASK_FPRND,\t\tfalse, true  },\n   { \"hard-dfp\",\t\t\tOPTION_MASK_DFP,\t\tfalse, true  },\n   { \"htm\",\t\t\tOPTION_MASK_HTM,\t\tfalse, true  },"}, {"sha": "a5a8b23df275b70f047a3af9f79fa18a8542dcc0", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fbda430dff88d550d1c73d4499f0c6aceece4e/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fbda430dff88d550d1c73d4499f0c6aceece4e/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=35fbda430dff88d550d1c73d4499f0c6aceece4e", "patch": "@@ -954,9 +954,13 @@ typedef _Complex float __attribute__((mode(TC))) _Complex128;\n typedef _Complex float __attribute__((mode(XC))) _Complex80;\n @end smallexample\n \n-On PowerPC 64-bit Linux systems there are currently problems in using\n-the complex @code{__float128} type.  When these problems are fixed,\n-you would use:\n+In order to use @code{__float128} and @code{__ibm128} on PowerPC Linux\n+systems, you must use the @option{-mfloat128}. It is expected in\n+future versions of GCC that @code{__float128} will be enabled\n+automatically.  In addition, there are currently problems in using the\n+complex @code{__float128} type.  When these problems are fixed, you\n+would use the following syntax to declare @code{_Complex128} to be a\n+complex @code{__float128} type:\n \n @smallexample\n typedef _Complex float __attribute__((mode(KC))) _Complex128;"}, {"sha": "aa5c77c6bc66d7a8753ead2fb26d03dc4418ab7b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fbda430dff88d550d1c73d4499f0c6aceece4e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fbda430dff88d550d1c73d4499f0c6aceece4e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=35fbda430dff88d550d1c73d4499f0c6aceece4e", "patch": "@@ -1,3 +1,14 @@\n+2016-04-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/70381\n+\t* gcc.target/powerpc/float128-1.c: New tests to make sure the\n+\t__float128 emulator is built and runs.\n+\t* gcc.target/powerpc/float128-1.c: Likewise.\n+\n+\t* lib/target-supports.exp (check_ppc_float128_sw_available):\n+\tRework tests for __float128 software and hardware\n+\tavailability. Fix exit condition to return 0 on success.\n+\n 2016-04-11  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \tPR target/70133"}, {"sha": "b8e71ceaaae87c4855145bdb32726959c14a3280", "filename": "gcc/testsuite/gcc.target/powerpc/float128-1.c", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fbda430dff88d550d1c73d4499f0c6aceece4e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fbda430dff88d550d1c73d4499f0c6aceece4e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-1.c?ref=35fbda430dff88d550d1c73d4499f0c6aceece4e", "patch": "@@ -0,0 +1,147 @@\n+/* { dg-do run { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target ppc_float128_sw } */\n+/* { dg-options \"-mcpu=power7 -O2 -mfloat128 -static-libgcc\" } */\n+\n+#ifdef DEBUG\n+#include <stdio.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <inttypes.h>\n+#endif\n+\n+#if !defined(__FLOAT128__) || !defined(_ARCH_PPC)\n+static __float128\n+pass_through (__float128 x)\n+{\n+  return x;\n+}\n+\n+__float128 (*no_optimize) (__float128) = pass_through;\n+#endif\n+\n+#ifdef DEBUG\n+__attribute__((__noinline__))\n+static void\n+print_f128 (__float128 x)\n+{\n+  unsigned sign;\n+  unsigned exponent;\n+  uint64_t mantissa1;\n+  uint64_t mantissa2;\n+  uint64_t upper;\n+  uint64_t lower;\n+\n+#if defined(_ARCH_PPC) && defined(__BIG_ENDIAN__)\n+  struct ieee128 {\n+    uint64_t upper;\n+    uint64_t lower;\n+  };\n+\n+#elif (defined(_ARCH_PPC) && defined(__LITTLE_ENDIAN__)) || defined(__x86_64__)\n+  struct ieee128 {\n+    uint64_t lower;\n+    uint64_t upper;\n+  };\n+\n+#else\n+#error \"Unknown system\"\n+#endif\n+\n+  union {\n+    __float128 f128;\n+    struct ieee128 s128;\n+  } u;\n+\n+  u.f128 = x;\n+  upper  = u.s128.upper;\n+  lower  = u.s128.lower;\n+\n+  sign      = (unsigned)((upper >> 63) & 1);\n+  exponent  = (unsigned)((upper >> 48) & ((((uint64_t)1) << 16) - 1));\n+  mantissa1 = (upper & ((((uint64_t)1) << 48) - 1));\n+  mantissa2 = lower;\n+\n+  printf (\"%c 0x%.4x 0x%.12\" PRIx64 \" 0x%.16\" PRIx64,\n+\t  sign ? '-' : '+',\n+\t  exponent,\n+\t  mantissa1,\n+\t  mantissa2);\n+}\n+#endif\n+\n+__attribute__((__noinline__))\n+static void\n+do_test (__float128 expected, __float128 got, const char *name)\n+{\n+  int equal_p = (expected == got);\n+\n+#ifdef DEBUG\n+  printf (\"Test %s, expected: \", name);\n+  print_f128 (expected);\n+  printf (\" %5g, got: \", (double) expected);\n+  print_f128 (got);\n+  printf (\" %5g, result %s\\n\",\n+\t  (double) got,\n+\t  (equal_p) ? \"equal\" : \"not equal\");\n+#endif\n+\n+  if (!equal_p)\n+    __builtin_abort ();\n+}\n+\n+\n+int\n+main (void)\n+{\n+  __float128 one\t= 1.0q;\n+  __float128 two\t= 2.0q;\n+  __float128 three\t= 3.0q;\n+  __float128 four\t= 4.0q;\n+  __float128 five\t= 5.0q;\n+  __float128 add_result = (1.0q + 2.0q);\n+  __float128 mul_result = ((1.0q + 2.0q) * 3.0q);\n+  __float128 div_result = (((1.0q + 2.0q) * 3.0q) / 4.0q);\n+  __float128 sub_result = ((((1.0q + 2.0q) * 3.0q) / 4.0q) - 5.0q);\n+  __float128 neg_result = - sub_result;\n+  __float128 add_xresult;\n+  __float128 mul_xresult;\n+  __float128 div_xresult;\n+  __float128 sub_xresult;\n+  __float128 neg_xresult;\n+\n+#if defined(__FLOAT128__) && defined(_ARCH_PPC)\n+  __asm__ (\" #prevent constant folding, %x0\" : \"+wa\" (one));\n+  __asm__ (\" #prevent constant folding, %x0\" : \"+wa\" (two));\n+  __asm__ (\" #prevent constant folding, %x0\" : \"+wa\" (three));\n+  __asm__ (\" #prevent constant folding, %x0\" : \"+wa\" (four));\n+  __asm__ (\" #prevent constant folding, %x0\" : \"+wa\" (five));\n+\n+#else\n+  one   = no_optimize (one);\n+  two   = no_optimize (two);\n+  three = no_optimize (three);\n+  four  = no_optimize (four);\n+  five  = no_optimize (five);\n+#endif\n+\n+  add_xresult = (one + two);\n+  do_test (add_result, add_xresult, \"add\");\n+\n+  mul_xresult = add_xresult * three;\n+  do_test (mul_result, mul_xresult, \"mul\");\n+\n+  div_xresult = mul_xresult / four;\n+  do_test (div_result, div_xresult, \"div\");\n+\n+  sub_xresult = div_xresult - five;\n+  do_test (sub_result, sub_xresult, \"sub\");\n+\n+  neg_xresult = - sub_xresult;\n+  do_test (neg_result, neg_xresult, \"neg\");\n+\n+#ifdef DEBUG\n+  printf (\"Passed\\n\");\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "f517686bd25af7ffcae48b0610bc67235aca6dcc", "filename": "gcc/testsuite/gcc.target/powerpc/float128-2.c", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fbda430dff88d550d1c73d4499f0c6aceece4e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fbda430dff88d550d1c73d4499f0c6aceece4e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-2.c?ref=35fbda430dff88d550d1c73d4499f0c6aceece4e", "patch": "@@ -0,0 +1,226 @@\n+/* { dg-do run { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target ppc_float128_sw } */\n+/* { dg-options \"-mcpu=power7 -O2 -mfloat128 -static-libgcc\" } */\n+\n+/*\n+ * Test program to make sure we are getting more precision than the 53 bits we\n+ * get with IEEE double.\n+ */\n+\n+#include <stdio.h>\n+#include <math.h>\n+#include <stdlib.h>\n+#include <stddef.h>\n+\n+#ifndef TYPE\n+#define TYPE __float128\n+#endif\n+\n+#ifndef NO_INLINE\n+#define NO_INLINE __attribute__((__noinline__))\n+#endif\n+\n+static TYPE power_of_two (ssize_t) NO_INLINE;\n+static TYPE calc1 (TYPE) NO_INLINE;\n+static TYPE calc2 (TYPE) NO_INLINE;\n+static TYPE calc3 (TYPE) NO_INLINE;\n+\n+#ifndef POWER2\n+#define POWER2 60\n+#endif\n+\n+\f\n+/*\n+ * Print TYPE in hex.\n+ */\n+\n+\n+#if defined(DEBUG) || defined(DEBUG2)\n+static void print_hex (const char *prefix, TYPE, const char *suffix) NO_INLINE;\n+\n+#if defined (__i386__) || defined (__x86_64__) || defined (__LITTLE_ENDIAN__)\n+#define ENDIAN_REVERSE(N, MAX)        ((MAX) - 1 - (N))\n+\n+#else\n+#define ENDIAN_REVERSE(N, MAX)        (N)\n+#endif\n+\n+static void\n+print_hex (const char *prefix, TYPE value, const char *suffix)\n+{\n+  union {\n+    TYPE f128;\n+    unsigned char uc[sizeof (TYPE)];\n+  } u;\n+\n+  size_t i;\n+\n+  u.f128 = value;\n+  printf (\"%s0x\", prefix);\n+  for (i = 0; i < sizeof (TYPE); i++)\n+    printf (\"%.2x\", u.uc[ ENDIAN_REVERSE (i, sizeof (TYPE)) ]);\n+\n+  printf (\", %24.2Lf%s\", (long double)value, suffix);\n+}\n+#endif\n+\n+\f\n+/*\n+ * Return a power of two.\n+ */\n+\n+static TYPE\n+power_of_two (ssize_t num)\n+{\n+  TYPE ret = (TYPE) 1.0;\n+  ssize_t i;\n+\n+  if (num >= 0)\n+    {\n+      for (i = 0; i < num; i++)\n+\tret *= (TYPE) 2.0;\n+    }\n+  else\n+    {\n+      ssize_t num2 = -num;\n+      for (i = 0; i < num2; i++)\n+\tret /= (TYPE) 2.0;\n+    }\n+\n+#ifdef DEBUG\n+  printf (\"power_of_two (%2ld)   = \", (long) num);\n+  print_hex (\"\", ret, \"\\n\");\n+#endif\n+\n+  return ret;\n+}\n+\n+\f\n+#ifdef ADDSUB\n+static TYPE add (TYPE a, TYPE b) NO_INLINE;\n+static TYPE sub (TYPE a, TYPE b) NO_INLINE;\n+\n+static TYPE\n+add (TYPE a, TYPE b)\n+{\n+  TYPE c;\n+#ifdef DEBUG\n+  print_hex (\"add, arg1           = \", a, \"\\n\");\n+  print_hex (\"add, arg2           = \", b, \"\\n\");\n+#endif\n+  c = a + b;\n+#ifdef DEBUG\n+  print_hex (\"add, result         = \", c, \"\\n\");\n+#endif\n+  return c;\n+}\n+\n+static TYPE\n+sub (TYPE a, TYPE b)\n+{\n+  TYPE c;\n+#ifdef DEBUG\n+  print_hex (\"sub, arg1           = \", a, \"\\n\");\n+  print_hex (\"sub, arg2           = \", b, \"\\n\");\n+#endif\n+  c = a - b;\n+#ifdef DEBUG\n+  print_hex (\"sub, result         = \", c, \"\\n\");\n+#endif\n+  return c;\n+}\n+\n+#else\n+#define add(x, y) ((x) + (y))\n+#define sub(x, y) ((x) - (y))\n+#endif\n+\n+/*\n+ * Various calculations.  Add in 2**POWER2, and subtract 2**(POWER2-1) twice, and we should\n+ * get the original value.\n+ */\n+\n+static TYPE\n+calc1 (TYPE num)\n+{\n+  TYPE num2 = add (power_of_two (POWER2), num);\n+  TYPE ret;\n+\n+#ifdef DEBUG\n+  print_hex (\"calc1 (before call) = \", num2, \"\\n\");\n+#endif\n+\n+  ret = calc2 (num2);\n+\n+#ifdef DEBUG\n+  print_hex (\"calc1 (after call)  = \", ret, \"\\n\");\n+#endif\n+\n+  return ret;\n+}\n+\n+static TYPE\n+calc2 (TYPE num)\n+{\n+  TYPE num2 = sub (num, power_of_two (POWER2-1));\n+  TYPE ret;\n+\n+#ifdef DEBUG\n+  print_hex (\"calc2 (before call) = \", num2, \"\\n\");\n+#endif\n+\n+  ret = calc3 (num2);\n+\n+#ifdef DEBUG\n+  print_hex (\"calc2 (after call)  = \", ret, \"\\n\");\n+#endif\n+\n+  return ret;\n+}\n+\n+static TYPE\n+calc3 (TYPE num)\n+{\n+  TYPE ret = sub (num, (((TYPE) 2.0) * power_of_two (POWER2-2)));\n+\n+#ifdef DEBUG\n+  print_hex (\"calc3               = \", ret, \"\\n\");\n+#endif\n+\n+  return ret;\n+}\n+\n+\f\n+int\n+main (void)\n+{\n+  TYPE input, output;\n+\n+#ifdef DEBUG\n+  printf (\"Testing, %ld bytes\\n\", (long) sizeof (TYPE));\n+#endif\n+\n+  input = power_of_two (-1);\n+  if ((double)input != 0.5)\n+    {\n+#if defined(DEBUG) || defined(DEBUG2)\n+      print_hex (\"Input should be 0.5:  \", output, \"\\n\");\n+      return 1;\n+#else\n+      __builtin_abort ();\n+#endif\n+    }\n+\n+  output = calc1 (input);\n+  if ((double)output != 0.5)\n+    {\n+#if defined(DEBUG) || defined(DEBUG2)\n+      print_hex (\"Output should be 0.5: \", output, \"\\n\");\n+      return 1;\n+#else\n+      __builtin_abort ();\n+#endif\n+    }\n+\n+  return 0;\n+}"}, {"sha": "3d44e1721dd69145696e9c275fa93ee1757a95a0", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fbda430dff88d550d1c73d4499f0c6aceece4e/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fbda430dff88d550d1c73d4499f0c6aceece4e/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=35fbda430dff88d550d1c73d4499f0c6aceece4e", "patch": "@@ -1740,7 +1740,7 @@ proc check_ppc_float128_sw_available { } {\n \t\tint main()\n \t\t{\n \t\t    __float128 z = x + y;\n-\t\t    return (z == 3.0q);\n+\t\t    return (z != 3.0q);\n \t\t}\n \t    } $options\n \t}\n@@ -1759,7 +1759,7 @@ proc check_ppc_float128_hw_available { } {\n \t     || [istarget *-*-darwin*]} {\n \t    expr 0\n \t} else {\n-\t    set options \"-mfloat128-hardware\"\n+\t    set options \"-mfloat128 -mvsx -mfloat128-hardware -mpower9-vector\"\n \t    check_runtime_nocache ppc_float128_hw_available {\n \t\tvolatile __float128 x = 1.0q;\n \t\tvolatile __float128 y = 2.0q;\n@@ -1769,7 +1769,7 @@ proc check_ppc_float128_hw_available { } {\n \t\t    __float128 w = -1.0q;\n \n \t\t    __asm__ (\"xsaddqp %0,%1,%2\" : \"+v\" (w) : \"v\" (x), \"v\" (y));\n-\t\t    return ((z == 3.0q) && (z == w);\n+\t\t    return ((z != 3.0q) || (z != w);\n \t\t}\n \t    } $options\n \t}"}, {"sha": "2a1386283262ce827eee8ef2de2b5cf50b90978d", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fbda430dff88d550d1c73d4499f0c6aceece4e/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fbda430dff88d550d1c73d4499f0c6aceece4e/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=35fbda430dff88d550d1c73d4499f0c6aceece4e", "patch": "@@ -1,3 +1,11 @@\n+2016-04-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/70381\n+\t* configure.ac (powerpc*-*-linux*): Rework tests to build\n+\t__float128 emulation routines to not depend on using #pragma GCC\n+\ttarget to enable -mfloat128.\n+\t* configure: Regnerate.\n+\n 2016-04-04  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR target/67172"}, {"sha": "e7d6c75a6f76eff959dde7136a5775c42a0fde19", "filename": "libgcc/configure", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fbda430dff88d550d1c73d4499f0c6aceece4e/libgcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fbda430dff88d550d1c73d4499f0c6aceece4e/libgcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfigure?ref=35fbda430dff88d550d1c73d4499f0c6aceece4e", "patch": "@@ -4767,16 +4767,20 @@ esac\n esac\n \n case ${host} in\n+# At present, we cannot turn -mfloat128 on via #pragma GCC target,\n+# so just check if we have VSX (ISA 2.06) support to build the\n+# software libraries, and whether the assembler can handle xsaddqp\n+# for hardware support.\n powerpc*-*-linux*)\n-  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether the PowerPC compiler can do __float128\" >&5\n-$as_echo_n \"checking whether the PowerPC compiler can do __float128... \" >&6; }\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for PowerPC ISA 2.06 to build __float128 libraries\" >&5\n+$as_echo_n \"checking for PowerPC ISA 2.06 to build __float128 libraries... \" >&6; }\n if test \"${libgcc_cv_powerpc_float128+set}\" = set; then :\n   $as_echo_n \"(cached) \" >&6\n else\n   cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n /* end confdefs.h.  */\n-#pragma GCC target (\"vsx,float128\")\n-     __float128 add (__float128 *a) { return *a + *(a+1); }\n+#pragma GCC target (\"vsx\")\n+     vector double dadd (vector double a, vector double b) { return a + b; }\n _ACEOF\n if ac_fn_c_try_compile \"$LINENO\"; then :\n   libgcc_cv_powerpc_float128=yes\n@@ -4788,21 +4792,21 @@ fi\n { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libgcc_cv_powerpc_float128\" >&5\n $as_echo \"$libgcc_cv_powerpc_float128\" >&6; }\n \n-  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether the PowerPC compiler can do hardware __float128\" >&5\n-$as_echo_n \"checking whether the PowerPC compiler can do hardware __float128... \" >&6; }\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for PowerPC ISA 3.0 to build hardware __float128 libraries\" >&5\n+$as_echo_n \"checking for PowerPC ISA 3.0 to build hardware __float128 libraries... \" >&6; }\n if test \"${libgcc_cv_powerpc_float128_hw+set}\" = set; then :\n   $as_echo_n \"(cached) \" >&6\n else\n   cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n /* end confdefs.h.  */\n-#pragma GCC target (\"cpu=power9,float128,float128-hardware\")\n+#pragma GCC target (\"vsx,power9-vector\")\n      #include <sys/auxv.h>\n      #ifndef AT_PLATFORM\n      #error \"AT_PLATFORM is not defined\"\n      #endif\n-     __float128 add (__float128 a, __float128 b)\n+     vector unsigned char (vector unsigned char a, vector unsigned char b)\n      {\n-       __float128 ret;\n+       vector unsigned char ret;\n        __asm__ (\"xsaddqp %0,%1,%2\" : \"=v\" (ret) : \"v\" (a), \"v\" (b));\n        return ret;\n      }"}, {"sha": "269997f23e25ef9253f799afdfee616e04699265", "filename": "libgcc/configure.ac", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fbda430dff88d550d1c73d4499f0c6aceece4e/libgcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fbda430dff88d550d1c73d4499f0c6aceece4e/libgcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfigure.ac?ref=35fbda430dff88d550d1c73d4499f0c6aceece4e", "patch": "@@ -374,26 +374,30 @@ esac\n esac\n \n case ${host} in\n+# At present, we cannot turn -mfloat128 on via #pragma GCC target,\n+# so just check if we have VSX (ISA 2.06) support to build the\n+# software libraries, and whether the assembler can handle xsaddqp\n+# for hardware support.\n powerpc*-*-linux*)\n-  AC_CACHE_CHECK([whether the PowerPC compiler can do __float128],\n+  AC_CACHE_CHECK([for PowerPC ISA 2.06 to build __float128 libraries],\n \t\t [libgcc_cv_powerpc_float128],\n \t\t [AC_COMPILE_IFELSE(\n-    [#pragma GCC target (\"vsx,float128\")\n-     __float128 add (__float128 *a) { return *a + *(a+1); }],\n+    [#pragma GCC target (\"vsx\")\n+     vector double dadd (vector double a, vector double b) { return a + b; }],\n     [libgcc_cv_powerpc_float128=yes],\n     [libgcc_cv_powerpc_float128=no])])\n \n-  AC_CACHE_CHECK([whether the PowerPC compiler can do hardware __float128],\n+  AC_CACHE_CHECK([for PowerPC ISA 3.0 to build hardware __float128 libraries],\n \t\t [libgcc_cv_powerpc_float128_hw],\n \t\t [AC_COMPILE_IFELSE(\n-    [#pragma GCC target (\"cpu=power9,float128,float128-hardware\")\n+    [#pragma GCC target (\"vsx,power9-vector\")\n      #include <sys/auxv.h>\n      #ifndef AT_PLATFORM\n      #error \"AT_PLATFORM is not defined\"\n      #endif\n-     __float128 add (__float128 a, __float128 b)\n+     vector unsigned char (vector unsigned char a, vector unsigned char b)\n      {\n-       __float128 ret;\n+       vector unsigned char ret;\n        __asm__ (\"xsaddqp %0,%1,%2\" : \"=v\" (ret) : \"v\" (a), \"v\" (b));\n        return ret;\n      }"}]}