{"sha": "8ef376a9b55cbcf39150f27466e28eea5312b610", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGVmMzc2YTliNTVjYmNmMzkxNTBmMjc0NjZlMjhlZWE1MzEyYjYxMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-01-16T12:05:47Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-01-16T12:05:47Z"}, "message": "(convert_for_assignment): Don't automatically convert from a union\nmember to the union.\n\nFrom-SVN: r11015", "tree": {"sha": "5bd7f5641fb3c2c89d8e27fc8444b517845e46b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bd7f5641fb3c2c89d8e27fc8444b517845e46b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ef376a9b55cbcf39150f27466e28eea5312b610", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ef376a9b55cbcf39150f27466e28eea5312b610", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ef376a9b55cbcf39150f27466e28eea5312b610", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ef376a9b55cbcf39150f27466e28eea5312b610/comments", "author": null, "committer": null, "parents": [{"sha": "96f158f7bd2f8d4f6a1b2aa48a907ec7eea581e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96f158f7bd2f8d4f6a1b2aa48a907ec7eea581e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96f158f7bd2f8d4f6a1b2aa48a907ec7eea581e1"}], "stats": {"total": 78, "additions": 0, "deletions": 78}, "files": [{"sha": "a602f7f8fdf21db964bbc8dbbb2d4c68398eb930", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ef376a9b55cbcf39150f27466e28eea5312b610/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ef376a9b55cbcf39150f27466e28eea5312b610/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=8ef376a9b55cbcf39150f27466e28eea5312b610", "patch": "@@ -3996,84 +3996,6 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t  || coder == COMPLEX_TYPE))\n     return convert_and_check (type, rhs);\n \n-  /* Conversion to a union from its member types.  */\n-  else if (codel == UNION_TYPE)\n-    {\n-      tree memb_types;\n-\n-      for (memb_types = TYPE_FIELDS (type); memb_types;\n-\t   memb_types = TREE_CHAIN (memb_types))\n-\t{\n-\t  if (comptypes (TREE_TYPE (memb_types), TREE_TYPE (rhs)))\n-\t    {\n-\t      if (pedantic\n-\t\t  && !(fundecl != 0 && DECL_IN_SYSTEM_HEADER (fundecl)))\n-\t\tpedwarn (\"ANSI C prohibits argument conversion to union type\");\n-\t      return build1 (NOP_EXPR, type, rhs);\n-\t    }\n-\n-\t  else if (coder == POINTER_TYPE\n-\t\t   && TREE_CODE (TREE_TYPE (memb_types)) == POINTER_TYPE)\n-\t    {\n-\t      tree memb_type = TREE_TYPE (memb_types);\n-\t      register tree ttl = TREE_TYPE (memb_type);\n-\t      register tree ttr = TREE_TYPE (rhstype);\n-\n-\t      /* Any non-function converts to a [const][volatile] void *\n-\t\t and vice versa; otherwise, targets must be the same.\n-\t\t Meanwhile, the lhs target must have all the qualifiers of\n-\t\t the rhs.  */\n-\t      if (TYPE_MAIN_VARIANT (ttl) == void_type_node\n-\t\t  || TYPE_MAIN_VARIANT (ttr) == void_type_node\n-\t\t  || comp_target_types (memb_type, rhstype))\n-\t\t{\n-\t\t  /* Const and volatile mean something different for function\n-\t\t     types, so the usual warnings are not appropriate.  */\n-\t\t  if (TREE_CODE (ttr) != FUNCTION_TYPE\n-\t\t      || TREE_CODE (ttl) != FUNCTION_TYPE)\n-\t\t    {\n-\t\t      if (! TYPE_READONLY (ttl) && TYPE_READONLY (ttr))\n-\t\t\twarn_for_assignment (\"%s discards `const' from pointer target type\",\n-\t\t\t\t\t     get_spelling (errtype), funname,\n-\t\t\t\t\t     parmnum);\n-\t\t      if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr))\n-\t\t\twarn_for_assignment (\"%s discards `volatile' from pointer target type\",\n-\t\t\t\t\t     get_spelling (errtype), funname,\n-\t\t\t\t\t     parmnum);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      /* Because const and volatile on functions are\n-\t\t\t restrictions that say the function will not do\n-\t\t\t certain things, it is okay to use a const or volatile\n-\t\t\t function where an ordinary one is wanted, but not\n-\t\t\t vice-versa.  */\n-\t\t      if (TYPE_READONLY (ttl) && ! TYPE_READONLY (ttr))\n-\t\t\twarn_for_assignment (\"%s makes `const *' function pointer from non-const\",\n-\t\t\t\t\t     get_spelling (errtype), funname,\n-\t\t\t\t\t     parmnum);\n-\t\t      if (TYPE_VOLATILE (ttl) && ! TYPE_VOLATILE (ttr))\n-\t\t\twarn_for_assignment (\"%s makes `volatile *' function pointer from non-volatile\",\n-\t\t\t\t\t     get_spelling (errtype), funname,\n-\t\t\t\t\t     parmnum);\n-\t\t    }\n-\n-\t\t  if (pedantic\n-\t\t      && !(fundecl != 0 && DECL_IN_SYSTEM_HEADER (fundecl)))\n-\t\t    pedwarn (\"ANSI C prohibits argument conversion to union type\");\n-\t\t  return build1 (NOP_EXPR, type, rhs);\n-\t\t}\n-\t    }\n-\n-\t  /* Can convert integer zero to any pointer type.  */\n-\t  else if (TREE_CODE (TREE_TYPE (memb_types)) == POINTER_TYPE\n-\t\t   && (integer_zerop (rhs)\n-\t\t       || (TREE_CODE (rhs) == NOP_EXPR\n-\t\t\t   && integer_zerop (TREE_OPERAND (rhs, 0)))))\n-\t    return build1 (NOP_EXPR, type, null_pointer_node);\n-\t}\n-    }\n-\n   /* Conversions among pointers */\n   else if (codel == POINTER_TYPE && coder == POINTER_TYPE)\n     {"}]}