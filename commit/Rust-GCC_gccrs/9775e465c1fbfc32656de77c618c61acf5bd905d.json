{"sha": "9775e465c1fbfc32656de77c618c61acf5bd905d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc3NWU0NjVjMWZiZmMzMjY1NmRlNzdjNjE4YzYxYWNmNWJkOTA1ZA==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2021-07-27T14:46:04Z"}, "committer": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2021-07-28T14:15:48Z"}, "message": "x86: Don't set AVX_U128_DIRTY when zeroing YMM/ZMM register\n\nThere is no SSE <-> AVX transition penalty if the upper bits of YMM/ZMM\nregisters are unchanged and YMM/ZMM store doesn't change the upper bits\nof YMM/ZMM registers.\n\n1. Since zeroing YMM/ZMM register is implemented with zeroing XMM\nregister, don't set AVX_U128_DIRTY when zeroing YMM/ZMM register.\n2. Since store doesn't change the INIT state on the upper bits of\nYMM/ZMM register, don't set AVX_U128_DIRTY on store if the source\nof store was never non-zero.\n\nHere are the vzeroupper count differences on SPEC CPU 2017 with\n\n-Ofast -march=skylake-avx512\n\n                Before  After    Diff\n500.perlbench_r\t226\t225\t-0.44%\n502.gcc_r      \t1263\t1103\t-12.67%\n503.bwaves_r   \t14\t14\t0.00%\n505.mcf_r      \t29\t28\t-3.45%\n507.cactuBSSN_r\t4651\t4628\t-0.49%\n508.namd_r     \t433\t432\t-0.23%\n510.parest_r   \t20380\t19347\t-5.07%\n511.povray_r   \t495\t452\t-8.69%\n519.lbm_r      \t2\t2\t0.00%\n520.omnetpp_r  \t5954\t5677\t-4.65%\n521.wrf_r      \t12353\t12339\t-0.11%\n523.xalancbmk_r\t13137\t13001\t-1.04%\n525.x264_r     \t192\t191\t-0.52%\n526.blender_r  \t2515\t2366\t-5.92%\n527.cam4_r     \t4601\t4583\t-0.39%\n531.deepsjeng_r\t20\t19\t-5.00%\n538.imagick_r  \t898\t805\t-10.36%\n541.leela_r    \t427\t399\t-6.56%\n544.nab_r      \t74\t74\t0.00%\n548.exchange2_r\t72\t72\t0.00%\n549.fotonik3d_r\t318\t318\t0.00%\n554.roms_r     \t558\t554\t-0.72%\n557.xz_r       \t79\t52\t-34.18%\n\nand performance differences are within noise range.\n\ngcc/\n\n\tPR target/101456\n\t* config/i386/i386.c (ix86_avx_u128_mode_needed): Don't set\n\tAVX_U128_DIRTY when all bits are zero.\n\ngcc/testsuite/\n\n\tPR target/101456\n\t* gcc.target/i386/pr101456-1.c: New test.\n\t* gcc.target/i386/pr101456-2.c: Likewise.", "tree": {"sha": "a57313edad398284ea3e2a55a7f1f05e437cfb43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a57313edad398284ea3e2a55a7f1f05e437cfb43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9775e465c1fbfc32656de77c618c61acf5bd905d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9775e465c1fbfc32656de77c618c61acf5bd905d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9775e465c1fbfc32656de77c618c61acf5bd905d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9775e465c1fbfc32656de77c618c61acf5bd905d/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bb6e2044ced33d08175361b8e39a9c5d4a868a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bb6e2044ced33d08175361b8e39a9c5d4a868a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bb6e2044ced33d08175361b8e39a9c5d4a868a6"}], "stats": {"total": 154, "additions": 154, "deletions": 0}, "files": [{"sha": "12ae37e7103052748b6dfc75457a355e55772eeb", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9775e465c1fbfc32656de77c618c61acf5bd905d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9775e465c1fbfc32656de77c618c61acf5bd905d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=9775e465c1fbfc32656de77c618c61acf5bd905d", "patch": "@@ -14149,6 +14149,94 @@ ix86_avx_u128_mode_needed (rtx_insn *insn)\n       return AVX_U128_CLEAN;\n     }\n \n+  rtx set = single_set (insn);\n+  if (set)\n+    {\n+      rtx dest = SET_DEST (set);\n+      rtx src = SET_SRC (set);\n+      if (ix86_check_avx_upper_register (dest))\n+\t{\n+\t  /* This is an YMM/ZMM load.  Return AVX_U128_DIRTY if the\n+\t     source isn't zero.  */\n+\t  if (standard_sse_constant_p (src, GET_MODE (dest)) != 1)\n+\t    return AVX_U128_DIRTY;\n+\t  else\n+\t    return AVX_U128_ANY;\n+\t}\n+      else if (ix86_check_avx_upper_register (src))\n+\t{\n+\t  /* This is an YMM/ZMM store.  Check for the source operand\n+\t     of SRC DEFs in the same basic block before INSN.  */\n+\t  basic_block bb = BLOCK_FOR_INSN (insn);\n+\t  rtx_insn *end = BB_END (bb);\n+\n+\t  /* Return AVX_U128_DIRTY if there is no DEF in the same basic\n+\t     block.  */\n+\t  int status = AVX_U128_DIRTY;\n+\n+\t  for (df_ref def = DF_REG_DEF_CHAIN (REGNO (src));\n+\t       def; def = DF_REF_NEXT_REG (def))\n+\t    if (DF_REF_BB (def) == bb)\n+\t      {\n+\t\t/* Ignore DEF from different basic blocks.  */\n+\t\trtx_insn *def_insn = DF_REF_INSN (def);\n+\n+\t\t/* Check if DEF_INSN is before INSN.  */\n+\t\trtx_insn *next;\n+\t\tfor (next = NEXT_INSN (def_insn);\n+\t\t     next != nullptr && next != end && next != insn;\n+\t\t     next = NEXT_INSN (next))\n+\t\t  ;\n+\n+\t\t/* Skip if DEF_INSN isn't before INSN.  */\n+\t\tif (next != insn)\n+\t\t  continue;\n+\n+\t\t/* Return AVX_U128_DIRTY if the source operand of\n+\t\t   DEF_INSN isn't constant zero.  */\n+\n+\t\tif (CALL_P (def_insn))\n+\t\t  {\n+\t\t    bool avx_upper_reg_found = false;\n+\t\t    note_stores (def_insn, ix86_check_avx_upper_stores,\n+\t\t\t\t &avx_upper_reg_found);\n+\n+\t\t    /* Return AVX_U128_DIRTY if call returns AVX.  */\n+\t\t    if (avx_upper_reg_found)\n+\t\t      return AVX_U128_DIRTY;\n+\n+\t\t    continue;\n+\t\t  }\n+\n+\t\tset = single_set (def_insn);\n+\t\tif (!set)\n+\t\t  return AVX_U128_DIRTY;\n+\n+\t\tdest = SET_DEST (set);\n+\n+\t\t/* Skip if DEF_INSN is not an AVX load.  */\n+\t\tif (ix86_check_avx_upper_register (dest))\n+\t\t  {\n+\t\t    src = SET_SRC (set);\n+\t\t    /* Return AVX_U128_DIRTY if the source operand isn't\n+\t\t       constant zero.  */\n+\t\t    if (standard_sse_constant_p (src, GET_MODE (dest))\n+\t\t\t!= 1)\n+\t\t      return AVX_U128_DIRTY;\n+\t\t  }\n+\n+\t\t/* We get here only if all AVX loads are from constant\n+\t\t   zero.  */\n+\t\tstatus = AVX_U128_ANY;\n+\t      }\n+\n+\t  return status;\n+\t}\n+\n+      /* This isn't YMM/ZMM load/store.  */\n+      return AVX_U128_ANY;\n+    }\n+\n   /* Require DIRTY mode if a 256bit or 512bit AVX register is referenced.\n      Hardware changes state only when a 256bit register is written to,\n      but we need to prevent the compiler from moving optimal insertion"}, {"sha": "803fc6e0207d37ded3bc2b0d8a72b1335bba83d9", "filename": "gcc/testsuite/gcc.target/i386/pr101456-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9775e465c1fbfc32656de77c618c61acf5bd905d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101456-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9775e465c1fbfc32656de77c618c61acf5bd905d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101456-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101456-1.c?ref=9775e465c1fbfc32656de77c618c61acf5bd905d", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=skylake\" } */\n+\n+#include <x86intrin.h>\n+\n+extern __m256 x1;\n+extern __m256d x2;\n+extern __m256i x3;\n+\n+extern void bar (void);\n+\n+void\n+foo1 (void)\n+{\n+  x1 = _mm256_setzero_ps ();\n+  bar ();\n+}\n+\n+void\n+foo2 (void)\n+{\n+  x2 = _mm256_setzero_pd ();\n+  bar ();\n+}\n+\n+void\n+foo3 (void)\n+{\n+  x3 = _mm256_setzero_si256 ();\n+  bar ();\n+}\n+\n+/* { dg-final { scan-assembler-not \"vzeroupper\" } } */"}, {"sha": "554a0f1702c3014cd2ad98a3a354510b1e4a22ee", "filename": "gcc/testsuite/gcc.target/i386/pr101456-2.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9775e465c1fbfc32656de77c618c61acf5bd905d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101456-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9775e465c1fbfc32656de77c618c61acf5bd905d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101456-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101456-2.c?ref=9775e465c1fbfc32656de77c618c61acf5bd905d", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=skylake\" } */\n+\n+#include <x86intrin.h>\n+\n+extern __m256 x1;\n+extern __m256d x2;\n+extern __m256i x3;\n+\n+extern __m256 bar (void);\n+\n+void\n+foo1 (void)\n+{\n+  bar ();\n+  x1 = _mm256_setzero_ps ();\n+}\n+\n+void\n+foo2 (void)\n+{\n+  bar ();\n+  x2 = _mm256_setzero_pd ();\n+}\n+\n+void\n+foo3 (void)\n+{\n+  bar ();\n+  x3 = _mm256_setzero_si256 ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"vzeroupper\" 3 } } */"}]}