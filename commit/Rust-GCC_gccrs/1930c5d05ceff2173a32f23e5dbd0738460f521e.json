{"sha": "1930c5d05ceff2173a32f23e5dbd0738460f521e", "node_id": "C_kwDOANBUbNoAKDE5MzBjNWQwNWNlZmYyMTczYTMyZjIzZTVkYmQwNzM4NDYwZjUyMWU", "commit": {"author": {"name": "Robin Dapp", "email": "rdapp@linux.ibm.com", "date": "2022-02-03T11:50:04Z"}, "committer": {"name": "Robin Dapp", "email": "rdapp@linux.ibm.com", "date": "2022-08-29T09:15:10Z"}, "message": "s390: Change SET rtx_cost handling.\n\nThe IF_THEN_ELSE detection currently prevents us from properly costing\nregister-register moves which causes the lower-subreg pass to assume that\na VR-VR move is as expensive as two GPR-GPR moves.\n\nThis patch adds handling for SETs containing REGs as well as MEMs and is\ninspired by the aarch64 implementation.\n\ngcc/ChangeLog:\n\n\t* config/s390/s390.cc (s390_address_cost): Declare.\n\t(s390_hard_regno_nregs): Declare.\n\t(s390_rtx_costs): Add handling for REG and MEM in SET.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/s390/vector/vec-sum-across-no-lower-subreg-1.c: New test.", "tree": {"sha": "e04d205c3a2d528bdd10888a37cbc4470ac1e6f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e04d205c3a2d528bdd10888a37cbc4470ac1e6f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1930c5d05ceff2173a32f23e5dbd0738460f521e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1930c5d05ceff2173a32f23e5dbd0738460f521e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1930c5d05ceff2173a32f23e5dbd0738460f521e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1930c5d05ceff2173a32f23e5dbd0738460f521e/comments", "author": {"login": "rdapp-ibm", "id": 80318053, "node_id": "MDQ6VXNlcjgwMzE4MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/80318053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp-ibm", "html_url": "https://github.com/rdapp-ibm", "followers_url": "https://api.github.com/users/rdapp-ibm/followers", "following_url": "https://api.github.com/users/rdapp-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp-ibm/subscriptions", "organizations_url": "https://api.github.com/users/rdapp-ibm/orgs", "repos_url": "https://api.github.com/users/rdapp-ibm/repos", "events_url": "https://api.github.com/users/rdapp-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp-ibm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rdapp-ibm", "id": 80318053, "node_id": "MDQ6VXNlcjgwMzE4MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/80318053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp-ibm", "html_url": "https://github.com/rdapp-ibm", "followers_url": "https://api.github.com/users/rdapp-ibm/followers", "following_url": "https://api.github.com/users/rdapp-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp-ibm/subscriptions", "organizations_url": "https://api.github.com/users/rdapp-ibm/orgs", "repos_url": "https://api.github.com/users/rdapp-ibm/repos", "events_url": "https://api.github.com/users/rdapp-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp-ibm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34895b6606561a36ffded81efee2904feb9c1bfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34895b6606561a36ffded81efee2904feb9c1bfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34895b6606561a36ffded81efee2904feb9c1bfd"}], "stats": {"total": 148, "additions": 111, "deletions": 37}, "files": [{"sha": "076c97a8b225907c86904c7bc38c352d768413d3", "filename": "gcc/config/s390/s390.cc", "status": "modified", "additions": 93, "deletions": 37, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1930c5d05ceff2173a32f23e5dbd0738460f521e/gcc%2Fconfig%2Fs390%2Fs390.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1930c5d05ceff2173a32f23e5dbd0738460f521e/gcc%2Fconfig%2Fs390%2Fs390.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.cc?ref=1930c5d05ceff2173a32f23e5dbd0738460f521e", "patch": "@@ -430,6 +430,14 @@ struct s390_address\n    bytes on a z10 (or higher) CPU.  */\n #define PREDICT_DISTANCE (TARGET_Z10 ? 384 : 2048)\n \n+static int\n+s390_address_cost (rtx addr, machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t   addr_space_t as ATTRIBUTE_UNUSED,\n+\t\t   bool speed ATTRIBUTE_UNUSED);\n+\n+static unsigned int\n+s390_hard_regno_nregs (unsigned int regno, machine_mode mode);\n+\n /* Masks per jump target register indicating which thunk need to be\n    generated.  */\n static GTY(()) int indirect_branch_prez10thunk_mask = 0;\n@@ -3639,49 +3647,97 @@ s390_rtx_costs (rtx x, machine_mode mode, int outer_code,\n     case MEM:\n       *total = 0;\n       return true;\n+      case SET: {\n+\trtx dest = SET_DEST (x);\n+\trtx src = SET_SRC (x);\n \n-    case SET:\n-      {\n-\t/* Without this a conditional move instruction would be\n-\t   accounted as 3 * COSTS_N_INSNS (set, if_then_else,\n-\t   comparison operator).  That's a bit pessimistic.  */\n+\tswitch (GET_CODE (src))\n+\t  {\n+\t    case IF_THEN_ELSE: {\n+\t      /* Without this a conditional move instruction would be\n+\t\t accounted as 3 * COSTS_N_INSNS (set, if_then_else,\n+\t\t comparison operator).  That's a bit pessimistic.  */\n \n-\tif (!TARGET_Z196 || GET_CODE (SET_SRC (x)) != IF_THEN_ELSE)\n-\t  return false;\n+\t      if (!TARGET_Z196)\n+\t\treturn false;\n \n-\trtx cond = XEXP (SET_SRC (x), 0);\n+\t      rtx cond = XEXP (src, 0);\n+\t      if (!CC_REG_P (XEXP (cond, 0)) || !CONST_INT_P (XEXP (cond, 1)))\n+\t\treturn false;\n \n-\tif (!CC_REG_P (XEXP (cond, 0)) || !CONST_INT_P (XEXP (cond, 1)))\n-\t  return false;\n+\t      /* It is going to be a load/store on condition.  Make it\n+\t\t slightly more expensive than a normal load.  */\n+\t      *total = COSTS_N_INSNS (1) + 2;\n \n-\t/* It is going to be a load/store on condition.  Make it\n-\t   slightly more expensive than a normal load.  */\n-\t*total = COSTS_N_INSNS (1) + 2;\n-\n-\trtx dst = SET_DEST (x);\n-\trtx then = XEXP (SET_SRC (x), 1);\n-\trtx els = XEXP (SET_SRC (x), 2);\n-\n-\t/* It is a real IF-THEN-ELSE.  An additional move will be\n-\t   needed to implement that.  */\n-\tif (!TARGET_Z15\n-\t    && reload_completed\n-\t    && !rtx_equal_p (dst, then)\n-\t    && !rtx_equal_p (dst, els))\n-\t  *total += COSTS_N_INSNS (1) / 2;\n-\n-\t/* A minor penalty for constants we cannot directly handle.  */\n-\tif ((CONST_INT_P (then) || CONST_INT_P (els))\n-\t    && (!TARGET_Z13 || MEM_P (dst)\n-\t\t|| (CONST_INT_P (then) && !satisfies_constraint_K (then))\n-\t\t|| (CONST_INT_P (els) && !satisfies_constraint_K (els))))\n-\t  *total += COSTS_N_INSNS (1) / 2;\n-\n-\t/* A store on condition can only handle register src operands.  */\n-\tif (MEM_P (dst) && (!REG_P (then) || !REG_P (els)))\n-\t  *total += COSTS_N_INSNS (1) / 2;\n+\t      rtx dst = SET_DEST (src);\n+\t      rtx then = XEXP (src, 1);\n+\t      rtx els = XEXP (src, 2);\n \n-\treturn true;\n+\t      /* It is a real IF-THEN-ELSE.  An additional move will be\n+\t\t needed to implement that.  */\n+\t      if (!TARGET_Z15 && reload_completed && !rtx_equal_p (dst, then)\n+\t\t  && !rtx_equal_p (dst, els))\n+\t\t*total += COSTS_N_INSNS (1) / 2;\n+\n+\t      /* A minor penalty for constants we cannot directly handle.  */\n+\t      if ((CONST_INT_P (then) || CONST_INT_P (els))\n+\t\t  && (!TARGET_Z13 || MEM_P (dst)\n+\t\t      || (CONST_INT_P (then) && !satisfies_constraint_K (then))\n+\t\t      || (CONST_INT_P (els) && !satisfies_constraint_K (els))))\n+\t\t*total += COSTS_N_INSNS (1) / 2;\n+\n+\t      /* A store on condition can only handle register src operands.  */\n+\t      if (MEM_P (dst) && (!REG_P (then) || !REG_P (els)))\n+\t\t*total += COSTS_N_INSNS (1) / 2;\n+\n+\t      return true;\n+\t    }\n+\t  default:\n+\t    break;\n+\t  }\n+\n+\tswitch (GET_CODE (dest))\n+\t  {\n+\t  case SUBREG:\n+\t    if (!REG_P (SUBREG_REG (dest)))\n+\t      *total += rtx_cost (SUBREG_REG (src), VOIDmode, SET, 0, speed);\n+\t    /* fallthrough */\n+\t  case REG:\n+\t    /* If this is a VR -> VR copy, count the number of\n+\t       registers.  */\n+\t    if (VECTOR_MODE_P (GET_MODE (dest)) && REG_P (src))\n+\t      {\n+\t\tint nregs = s390_hard_regno_nregs (VR0_REGNUM, GET_MODE (dest));\n+\t\t*total = COSTS_N_INSNS (nregs);\n+\t      }\n+\t    /* Same for GPRs.  */\n+\t    else if (REG_P (src))\n+\t      {\n+\t\tint nregs\n+\t\t  = s390_hard_regno_nregs (GPR0_REGNUM, GET_MODE (dest));\n+\t\t*total = COSTS_N_INSNS (nregs);\n+\t      }\n+\t    else\n+\t      /* Otherwise just cost the src.  */\n+\t      *total += rtx_cost (src, mode, SET, 1, speed);\n+\t    return true;\n+\t    case MEM: {\n+\t      rtx address = XEXP (dest, 0);\n+\t      rtx tmp;\n+\t      long tmp2;\n+\t      if (s390_loadrelative_operand_p (address, &tmp, &tmp2))\n+\t\t*total = COSTS_N_INSNS (1);\n+\t      else\n+\t\t*total = s390_address_cost (address, mode, 0, speed);\n+\t      return true;\n+\t    }\n+\t  default:\n+\t    /* Not handled for now, assume default costs.  */\n+\t    *total = COSTS_N_INSNS (1);\n+\t    return false;\n+\t  }\n+\n+\treturn false;\n       }\n     case IOR:\n "}, {"sha": "8d63e8c85958e0bed01f7bc2907e83ab6fc4f646", "filename": "gcc/testsuite/gcc.target/s390/vector/vec-sum-across-no-lower-subreg-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1930c5d05ceff2173a32f23e5dbd0738460f521e/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fvec-sum-across-no-lower-subreg-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1930c5d05ceff2173a32f23e5dbd0738460f521e/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fvec-sum-across-no-lower-subreg-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fvec-sum-across-no-lower-subreg-1.c?ref=1930c5d05ceff2173a32f23e5dbd0738460f521e", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target { s390*-*-* } } } */\n+/* { dg-options \"-O3 -mzarch -mzvector -march=z15 -fdump-rtl-subreg1\" } */\n+\n+/* { dg-final { scan-rtl-dump-times \"Skipping mode V2DI for copy lowering\" 2 \"subreg1\" } } */\n+\n+#include <vecintrin.h>\n+\n+#define STYPE long long\n+#define VTYPE __attribute__ ((vector_size (16))) STYPE\n+\n+STYPE\n+foo1 (VTYPE a)\n+{\n+  /* { dg-final { scan-assembler-not \"vst\\t.*\" } } */\n+  /* { dg-final { scan-assembler-not \"lg\\t.*\" } } */\n+  /* { dg-final { scan-assembler-not \"lgr\\t.*\" } } */\n+  return a[0] + a[1];\n+}"}]}