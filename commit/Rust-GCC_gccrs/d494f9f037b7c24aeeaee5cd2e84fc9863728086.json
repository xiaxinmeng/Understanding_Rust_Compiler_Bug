{"sha": "d494f9f037b7c24aeeaee5cd2e84fc9863728086", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ5NGY5ZjAzN2I3YzI0YWVlYWVlNWNkMmU4NGZjOTg2MzcyODA4Ng==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-11-17T08:21:19Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-12-14T15:51:49Z"}, "message": "[Ada] Tidy up implementation of System.Fat_Gen.Valid and inline it again\n\ngcc/ada/\n\n\t* libgnat/s-fatgen.ads (Valid): Add again pragma Inline.\n\t* libgnat/s-fatgen.adb (Valid): Improve commentary, tidy up left\n\tand right, and remove superfluous trick for denormalized numbers.", "tree": {"sha": "9b9f6a169b142e117be5211528827b1b94969be7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b9f6a169b142e117be5211528827b1b94969be7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d494f9f037b7c24aeeaee5cd2e84fc9863728086", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d494f9f037b7c24aeeaee5cd2e84fc9863728086", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d494f9f037b7c24aeeaee5cd2e84fc9863728086", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d494f9f037b7c24aeeaee5cd2e84fc9863728086/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efec136240f464eaa89d75c3d68f1f51627e931d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efec136240f464eaa89d75c3d68f1f51627e931d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efec136240f464eaa89d75c3d68f1f51627e931d"}], "stats": {"total": 149, "additions": 63, "deletions": 86}, "files": [{"sha": "e59019842c1b7885548dd700f685802d5a9dd350", "filename": "gcc/ada/libgnat/s-fatgen.adb", "status": "modified", "additions": 62, "deletions": 81, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d494f9f037b7c24aeeaee5cd2e84fc9863728086/gcc%2Fada%2Flibgnat%2Fs-fatgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d494f9f037b7c24aeeaee5cd2e84fc9863728086/gcc%2Fada%2Flibgnat%2Fs-fatgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-fatgen.adb?ref=d494f9f037b7c24aeeaee5cd2e84fc9863728086", "patch": "@@ -38,6 +38,7 @@\n \n with Ada.Unchecked_Conversion;\n with System;\n+\n package body System.Fat_Gen is\n \n    Float_Radix        : constant T := T (T'Machine_Radix);\n@@ -807,130 +808,110 @@ package body System.Fat_Gen is\n    function Valid (X : not null access T) return Boolean is\n       IEEE_Emin : constant Integer := T'Machine_Emin - 1;\n       IEEE_Emax : constant Integer := T'Machine_Emax - 1;\n+      --  The mantissa is a fraction with first digit set in Ada whereas it is\n+      --  shifted by 1 digit to the left in the IEEE floating-point format.\n \n-      IEEE_Bias : constant Integer := -(IEEE_Emin - 1);\n+      subtype IEEE_Erange is Integer range IEEE_Emin - 1 .. IEEE_Emax + 1;\n+      --  The IEEE floating-point format extends the machine range by 1 to the\n+      --  left for denormalized numbers and 1 to the right for infinities/NaNs.\n \n-      subtype IEEE_Exponent_Range is\n-        Integer range IEEE_Emin - 1 .. IEEE_Emax + 1;\n+      IEEE_Ebias : constant Integer := -(IEEE_Emin - 1);\n+      --  The exponent is biased such that denormalized numbers have it zero\n \n-      --  The implementation of this floating point attribute uses a\n-      --  representation type Float_Rep that allows direct access to the\n-      --  exponent and mantissa parts of a floating point number.\n+      --  The implementation uses a representation type Float_Rep that allows\n+      --  direct access to exponent and mantissa of the floating point number.\n \n-      --  The Float_Rep type is an array of Float_Word elements. This\n+      --  The Float_Rep type is a simple array of Float_Word elements. This\n       --  representation is chosen to make it possible to size the type based\n       --  on a generic parameter. Since the array size is known at compile\n       --  time, efficient code can still be generated. The size of Float_Word\n       --  elements should be large enough to allow accessing the exponent in\n-      --  one read, but small enough so that all floating point object sizes\n-      --  are a multiple of the Float_Word'Size.\n+      --  one read, but small enough so that all floating-point object sizes\n+      --  are a multiple of Float_Word'Size.\n \n       --  The following conditions must be met for all possible instantiations\n-      --  of the attributes package:\n+      --  of the attribute package:\n \n       --    - T'Size is an integral multiple of Float_Word'Size\n \n       --    - The exponent and sign are completely contained in a single\n-      --      component of Float_Rep, named Most_Significant_Word (MSW).\n+      --      component of Float_Rep, named Most Significant Word (MSW).\n \n       --    - The sign occupies the most significant bit of the MSW and the\n-      --      exponent is in the following bits. Unused bits (if any) are in\n-      --      the least significant part.\n-\n-      type Float_Word is mod 2**Positive'Min (System.Word_Size, 32);\n-      type Rep_Index is range 0 .. 7;\n-\n-      Rep_Words : constant Positive :=\n-                    (T'Size + Float_Word'Size - 1) / Float_Word'Size;\n-      Rep_Last  : constant Rep_Index :=\n-                    Rep_Index'Min\n-                      (Rep_Index (Rep_Words - 1),\n-                       (T'Mantissa + 16) / Float_Word'Size);\n+      --      exponent is in the following bits. The exception is 80-bit\n+      --      double extended, where they occupy the low 16-bit halfword.\n+\n+      Siz : constant :=\n+              (if System.Word_Size > 32 then 32 else System.Word_Size);\n+      type Float_Word is mod 2**Siz;\n+\n+      N : constant Natural := (T'Size + Siz - 1) / Siz;\n+      Rep_Last : constant Natural :=\n+                   Natural'Min (N - 1, (T'Machine_Mantissa + 16) / Siz);\n       --  Determine the number of Float_Words needed for representing the\n       --  entire floating-point value. Do not take into account excessive\n       --  padding, as occurs on IA-64 where 80 bits floats get padded to 128\n       --  bits. In general, the exponent field cannot be larger than 15 bits,\n       --  even for 128-bit floating-point types, so the final format size\n-      --  won't be larger than T'Mantissa + 16.\n-\n-      type Float_Rep is\n-         array (Rep_Index range 0 .. Rep_Index (Rep_Words - 1)) of Float_Word;\n+      --  won't be larger than T'Machine_Mantissa + 16.\n \n+      type Float_Rep is array (Natural range 0 .. N - 1) of Float_Word;\n       pragma Suppress_Initialization (Float_Rep);\n       --  This pragma suppresses the generation of an initialization procedure\n       --  for type Float_Rep when operating in Initialize/Normalize_Scalars\n-      --  mode. This is not just a matter of efficiency, but of functionality,\n-      --  since Valid has a pragma Inline_Always, which is not permitted if\n-      --  there are nested subprograms present.\n+      --  mode, which would be annoying since Valid has got a pragma Inline.\n \n-      Most_Significant_Word : constant Rep_Index :=\n-                                Rep_Last * Standard'Default_Bit_Order;\n+      MSW : constant Natural := Rep_Last * Standard'Default_Bit_Order;\n       --  Finding the location of the Exponent_Word is a bit tricky. In general\n       --  we assume Word_Order = Bit_Order.\n \n-      Exponent_Factor : constant Float_Word :=\n-                          2**(Float_Word'Size - 1) /\n-                            Float_Word (IEEE_Emax - IEEE_Emin + 3) *\n-                              Boolean'Pos (Most_Significant_Word /= 2) +\n-                                Boolean'Pos (Most_Significant_Word = 2);\n+      Exp_Factor : constant Float_Word :=\n+                     (if T'Machine_Mantissa = 64\n+                       then 1\n+                       else 2**(Siz - 1) /\n+                              Float_Word (IEEE_Emax - IEEE_Emin + 3));\n       --  Factor that the extracted exponent needs to be divided by to be in\n-      --  range 0 .. IEEE_Emax - IEEE_Emin + 2. Special case: Exponent_Factor\n-      --  is 1 for x86/IA64 double extended (GCC adds unused bits to the type).\n+      --  range 0 .. IEEE_Emax - IEEE_Emin + 2. The special case is 80-bit\n+      --  double extended, where the exponent starts the 3rd float word.\n \n-      Exponent_Mask : constant Float_Word :=\n-                        Float_Word (IEEE_Emax - IEEE_Emin + 2) *\n-                          Exponent_Factor;\n+      Exp_Mask : constant Float_Word :=\n+                   Float_Word (IEEE_Emax - IEEE_Emin + 2) * Exp_Factor;\n       --  Value needed to mask out the exponent field. This assumes that the\n-      --  range IEEE_Emin - 1 .. IEEE_Emax + contains 2**N values, for some N\n-      --  in Natural.\n-\n-      function To_Float is new Ada.Unchecked_Conversion (Float_Rep, T);\n+      --  range 0 .. IEEE_Emax - IEEE_Emin + 2 contains 2**N values, for some\n+      --  N in Natural.\n \n-      type Float_Access is access all T;\n+      type Access_T is access all T;\n       function To_Address is\n-         new Ada.Unchecked_Conversion (Float_Access, System.Address);\n-\n-      XA : constant System.Address := To_Address (Float_Access (X));\n+        new Ada.Unchecked_Conversion (Access_T, System.Address);\n \n-      R : Float_Rep;\n-      pragma Import (Ada, R);\n-      for R'Address use XA;\n-      --  R is a view of the input floating-point parameter. Note that we\n-      --  must avoid copying the actual bits of this parameter in float\n-      --  form (since it may be a signalling NaN).\n+      Rep : Float_Rep;\n+      pragma Import (Ada, Rep);\n+      for Rep'Address use To_Address (Access_T (X));\n+      --  Rep is a view of the input floating-point parameter. Note that we\n+      --  must avoid reading the actual bits of this parameter in float form\n+      --  since it may be a signalling NaN.\n \n-      E  : constant IEEE_Exponent_Range :=\n-             Integer ((R (Most_Significant_Word) and Exponent_Mask) /\n-                                                        Exponent_Factor)\n-               - IEEE_Bias;\n-      --  Mask/Shift T to only get bits from the exponent. Then convert biased\n-      --  value to integer value.\n-\n-      SR : Float_Rep;\n-      --  Float_Rep representation of significant of X.all\n+      Exp : constant IEEE_Erange :=\n+              Integer ((Rep (MSW) and Exp_Mask) / Exp_Factor) - IEEE_Ebias;\n+      --  Mask/Shift X to only get bits from the exponent. Then convert biased\n+      --  value to final value.\n \n    begin\n-      if T'Denorm then\n-\n-         --  All denormalized numbers are valid, so the only invalid numbers\n-         --  are overflows and NaNs, both with exponent = Emax + 1.\n+      if Exp = IEEE_Emax + 1 then\n+         --  This is an infinity or a NaN, i.e. always invalid\n \n-         return E /= IEEE_Emax + 1;\n+         return False;\n \n-      end if;\n+      elsif Exp in IEEE_Emin .. IEEE_Emax then\n+         --  This is a normalized number, i.e. always valid\n \n-      --  All denormalized numbers except 0.0 are invalid\n+         return True;\n \n-      --  Set exponent of X to zero, so we end up with the significand, which\n-      --  definitely is a valid number and can be converted back to a float.\n+      else pragma Assert (Exp = IEEE_Emin - 1);\n+         --  This is a denormalized number, valid if T'Denorm is True or 0.0\n \n-      SR := R;\n-      SR (Most_Significant_Word) :=\n-           (SR (Most_Significant_Word)\n-             and not Exponent_Mask) + Float_Word (IEEE_Bias) * Exponent_Factor;\n-\n-      return (E in IEEE_Emin .. IEEE_Emax) or else\n-         ((E = IEEE_Emin - 1) and then abs To_Float (SR) = 1.0);\n+         return T'Denorm or else X.all = 0.0;\n+      end if;\n    end Valid;\n \n end System.Fat_Gen;"}, {"sha": "b8bdf2d2cd9929e3587f46355ea2c3646eff3d47", "filename": "gcc/ada/libgnat/s-fatgen.ads", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d494f9f037b7c24aeeaee5cd2e84fc9863728086/gcc%2Fada%2Flibgnat%2Fs-fatgen.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d494f9f037b7c24aeeaee5cd2e84fc9863728086/gcc%2Fada%2Flibgnat%2Fs-fatgen.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-fatgen.ads?ref=d494f9f037b7c24aeeaee5cd2e84fc9863728086", "patch": "@@ -109,10 +109,6 @@ package System.Fat_Gen is\n private\n    pragma Inline (Machine);\n    pragma Inline (Model);\n-\n-   --  Note: previously the validity checking subprograms (Unaligned_Valid and\n-   --  Valid) were also inlined, but this was changed since there were some\n-   --  problems with this inlining in optimized mode, and in any case it seems\n-   --  better to avoid this inlining (space and robustness considerations).\n+   pragma Inline (Valid);\n \n end System.Fat_Gen;"}]}