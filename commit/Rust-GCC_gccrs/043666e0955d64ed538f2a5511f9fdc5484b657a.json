{"sha": "043666e0955d64ed538f2a5511f9fdc5484b657a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQzNjY2ZTA5NTVkNjRlZDUzOGYyYTU1MTFmOWZkYzU0ODRiNjU3YQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2019-06-18T16:08:23Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-06-18T16:08:23Z"}, "message": "Consolidate constexpr array handling.\n\n\t* constexpr.c (eval_and_check_array_index): Split out from...\n\t(cxx_eval_array_reference): ...here.\n\t(cxx_eval_store_expression): Use it here, too.\n\t(diag_array_subscript): Take location.  Strip location wrapper.\n\nFrom-SVN: r272430", "tree": {"sha": "c32eb7673616c65c1916a5157f9594d6f0673e3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c32eb7673616c65c1916a5157f9594d6f0673e3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/043666e0955d64ed538f2a5511f9fdc5484b657a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/043666e0955d64ed538f2a5511f9fdc5484b657a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/043666e0955d64ed538f2a5511f9fdc5484b657a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/043666e0955d64ed538f2a5511f9fdc5484b657a/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "02a8575c0cc6cc0004afaee095185775cd61f080", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02a8575c0cc6cc0004afaee095185775cd61f080", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02a8575c0cc6cc0004afaee095185775cd61f080"}], "stats": {"total": 229, "additions": 115, "deletions": 114}, "files": [{"sha": "1071a52a5586f22fdbe7b1b554d2dc7bbf7fb6b2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/043666e0955d64ed538f2a5511f9fdc5484b657a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/043666e0955d64ed538f2a5511f9fdc5484b657a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=043666e0955d64ed538f2a5511f9fdc5484b657a", "patch": "@@ -1,3 +1,10 @@\n+2019-06-18  Jason Merrill  <jason@redhat.com>\n+\n+\t* constexpr.c (eval_and_check_array_index): Split out from...\n+\t(cxx_eval_array_reference): ...here.\n+\t(cxx_eval_store_expression): Use it here, too.\n+\t(diag_array_subscript): Take location.  Strip location wrapper.\n+\n 2019-06-18  Jason Merrill  <jason@redhat.com>\n \n \t* constexpr.c (cxx_eval_constant_expression): Handle conversion from"}, {"sha": "7c733d78b5b6a7ef5d3a5c6a0eae8838d3144f92", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 98, "deletions": 104, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/043666e0955d64ed538f2a5511f9fdc5484b657a/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/043666e0955d64ed538f2a5511f9fdc5484b657a/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=043666e0955d64ed538f2a5511f9fdc5484b657a", "patch": "@@ -2488,7 +2488,7 @@ find_array_ctor_elt (tree ary, tree dindex, bool insert)\n    an out-of-bounds subscript INDEX into the expression ARRAY.  */\n \n static void\n-diag_array_subscript (const constexpr_ctx *ctx, tree array, tree index)\n+diag_array_subscript (location_t loc, const constexpr_ctx *ctx, tree array, tree index)\n {\n   if (!ctx->quiet)\n     {\n@@ -2497,22 +2497,23 @@ diag_array_subscript (const constexpr_ctx *ctx, tree array, tree index)\n       /* Convert the unsigned array subscript to a signed integer to avoid\n \t printing huge numbers for small negative values.  */\n       tree sidx = fold_convert (ssizetype, index);\n+      STRIP_ANY_LOCATION_WRAPPER (array);\n       if (DECL_P (array))\n \t{\n \t  if (TYPE_DOMAIN (arraytype))\n-\t    error (\"array subscript value %qE is outside the bounds \"\n-\t           \"of array %qD of type %qT\", sidx, array, arraytype);\n+\t    error_at (loc, \"array subscript value %qE is outside the bounds \"\n+\t\t      \"of array %qD of type %qT\", sidx, array, arraytype);\n \t  else\n-\t    error (\"nonzero array subscript %qE is used with array %qD of \"\n-\t\t   \"type %qT with unknown bounds\", sidx, array, arraytype);\n+\t    error_at (loc, \"nonzero array subscript %qE is used with array %qD of \"\n+\t\t      \"type %qT with unknown bounds\", sidx, array, arraytype);\n \t  inform (DECL_SOURCE_LOCATION (array), \"declared here\");\n \t}\n       else if (TYPE_DOMAIN (arraytype))\n-\terror (\"array subscript value %qE is outside the bounds \"\n-\t       \"of array type %qT\", sidx, arraytype);\n+\terror_at (loc, \"array subscript value %qE is outside the bounds \"\n+\t\t  \"of array type %qT\", sidx, arraytype);\n       else\n-\terror (\"nonzero array subscript %qE is used with array of type %qT \"\n-\t       \"with unknown bounds\", sidx, arraytype);\n+\terror_at (loc, \"nonzero array subscript %qE is used with array of type %qT \"\n+\t\t  \"with unknown bounds\", sidx, arraytype);\n     }\n }\n \n@@ -2563,6 +2564,44 @@ extract_string_elt (tree string, unsigned chars_per_elt, unsigned index)\n   return r;\n }\n \n+/* Subroutine of cxx_eval_array_reference.  T is an ARRAY_REF; evaluate the\n+   subscript, diagnose any problems with it, and return the result.  */\n+\n+static tree\n+eval_and_check_array_index (const constexpr_ctx *ctx,\n+\t\t\t    tree t, bool allow_one_past,\n+\t\t\t    bool *non_constant_p, bool *overflow_p)\n+{\n+  location_t loc = cp_expr_loc_or_loc (t, input_location);\n+  tree ary = TREE_OPERAND (t, 0);\n+  t = TREE_OPERAND (t, 1);\n+  tree index = cxx_eval_constant_expression (ctx, t, false,\n+\t\t\t\t\t     non_constant_p, overflow_p);\n+  VERIFY_CONSTANT (index);\n+\n+  if (!tree_fits_shwi_p (index)\n+      || tree_int_cst_sgn (index) < 0)\n+    {\n+      diag_array_subscript (loc, ctx, ary, index);\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n+  tree nelts = get_array_or_vector_nelts (ctx, TREE_TYPE (ary), non_constant_p,\n+\t\t\t\t\t  overflow_p);\n+  VERIFY_CONSTANT (nelts);\n+  if (allow_one_past\n+      ? !tree_int_cst_le (index, nelts)\n+      : !tree_int_cst_lt (index, nelts))\n+    {\n+      diag_array_subscript (loc, ctx, ary, index);\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n+  return index;\n+}\n+\n /* Subroutine of cxx_eval_constant_expression.\n    Attempt to reduce a reference to an array slot.  */\n \n@@ -2575,71 +2614,47 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n   tree ary = cxx_eval_constant_expression (ctx, oldary,\n \t\t\t\t\t   lval,\n \t\t\t\t\t   non_constant_p, overflow_p);\n-  tree index, oldidx;\n-  HOST_WIDE_INT i = 0;\n-  tree elem_type = NULL_TREE;\n-  unsigned len = 0, elem_nchars = 1;\n   if (*non_constant_p)\n     return t;\n-  oldidx = TREE_OPERAND (t, 1);\n-  index = cxx_eval_constant_expression (ctx, oldidx,\n-\t\t\t\t\tfalse,\n-\t\t\t\t\tnon_constant_p, overflow_p);\n-  VERIFY_CONSTANT (index);\n-  if (!lval)\n-    {\n-      elem_type = TREE_TYPE (TREE_TYPE (ary));\n-      if (TREE_CODE (ary) == VIEW_CONVERT_EXPR\n-\t  && VECTOR_TYPE_P (TREE_TYPE (TREE_OPERAND (ary, 0)))\n-\t  && TREE_TYPE (t) == TREE_TYPE (TREE_TYPE (TREE_OPERAND (ary, 0))))\n-\tary = TREE_OPERAND (ary, 0);\n-      if (TREE_CODE (ary) == CONSTRUCTOR)\n-\tlen = CONSTRUCTOR_NELTS (ary);\n-      else if (TREE_CODE (ary) == STRING_CST)\n-\t{\n-\t  elem_nchars = (TYPE_PRECISION (elem_type)\n-\t\t\t / TYPE_PRECISION (char_type_node));\n-\t  len = (unsigned) TREE_STRING_LENGTH (ary) / elem_nchars;\n-\t}\n-      else if (TREE_CODE (ary) == VECTOR_CST)\n-\t/* We don't create variable-length VECTOR_CSTs.  */\n-\tlen = VECTOR_CST_NELTS (ary).to_constant ();\n-      else\n-\t{\n-\t  /* We can't do anything with other tree codes, so use\n-\t     VERIFY_CONSTANT to complain and fail.  */\n-\t  VERIFY_CONSTANT (ary);\n-\t  gcc_unreachable ();\n-\t}\n+  if (TREE_CODE (ary) == VIEW_CONVERT_EXPR\n+      && VECTOR_TYPE_P (TREE_TYPE (TREE_OPERAND (ary, 0)))\n+      && TREE_TYPE (t) == TREE_TYPE (TREE_TYPE (TREE_OPERAND (ary, 0))))\n+    ary = TREE_OPERAND (ary, 0);\n \n-      if (!tree_fits_shwi_p (index)\n-\t  || (i = tree_to_shwi (index)) < 0)\n-\t{\n-\t  diag_array_subscript (ctx, ary, index);\n-\t  *non_constant_p = true;\n-\t  return t;\n-\t}\n-    }\n-\n-  tree nelts = get_array_or_vector_nelts (ctx, TREE_TYPE (ary), non_constant_p,\n-\t\t\t\t\t  overflow_p);\n-  VERIFY_CONSTANT (nelts);\n-  if ((lval\n-       ? !tree_int_cst_le (index, nelts)\n-       : !tree_int_cst_lt (index, nelts))\n-      || tree_int_cst_sgn (index) < 0)\n-    {\n-      diag_array_subscript (ctx, ary, index);\n-      *non_constant_p = true;\n-      return t;\n-    }\n+  tree oldidx = TREE_OPERAND (t, 1);\n+  tree index = eval_and_check_array_index (ctx, t, lval,\n+\t\t\t\t\t   non_constant_p, overflow_p);\n+  if (*non_constant_p)\n+    return t;\n \n   if (lval && ary == oldary && index == oldidx)\n     return t;\n   else if (lval)\n     return build4 (ARRAY_REF, TREE_TYPE (t), ary, index, NULL, NULL);\n \n+  unsigned len = 0, elem_nchars = 1;\n+  tree elem_type = TREE_TYPE (TREE_TYPE (ary));\n+  if (TREE_CODE (ary) == CONSTRUCTOR)\n+    len = CONSTRUCTOR_NELTS (ary);\n+  else if (TREE_CODE (ary) == STRING_CST)\n+    {\n+      elem_nchars = (TYPE_PRECISION (elem_type)\n+\t\t     / TYPE_PRECISION (char_type_node));\n+      len = (unsigned) TREE_STRING_LENGTH (ary) / elem_nchars;\n+    }\n+  else if (TREE_CODE (ary) == VECTOR_CST)\n+    /* We don't create variable-length VECTOR_CSTs.  */\n+    len = VECTOR_CST_NELTS (ary).to_constant ();\n+  else\n+    {\n+      /* We can't do anything with other tree codes, so use\n+\t VERIFY_CONSTANT to complain and fail.  */\n+      VERIFY_CONSTANT (ary);\n+      gcc_unreachable ();\n+    }\n+\n   bool found;\n+  HOST_WIDE_INT i = 0;\n   if (TREE_CODE (ary) == CONSTRUCTOR)\n     {\n       HOST_WIDE_INT ix = find_array_ctor_elt (ary, index);\n@@ -2648,7 +2663,10 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n \ti = ix;\n     }\n   else\n-    found = (i < len);\n+    {\n+      i = tree_to_shwi (index);\n+      found = (i < len);\n+    }\n \n   if (found)\n     {\n@@ -3735,41 +3753,6 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n   if (*non_constant_p)\n     return t;\n \n-  /* cxx_eval_array_reference for lval = true allows references one past\n-     end of array, because it does not know if it is just taking address\n-     (which is valid), or actual dereference.  Here we know it is\n-     a dereference, so diagnose it here.  */\n-  for (tree probe = target; probe; )\n-    {\n-      switch (TREE_CODE (probe))\n-\t{\n-\tcase ARRAY_REF:\n-\t  tree nelts, ary;\n-\t  ary = TREE_OPERAND (probe, 0);\n-\t  nelts = get_array_or_vector_nelts (ctx, TREE_TYPE (ary),\n-\t\t\t\t\t     non_constant_p, overflow_p);\n-\t  VERIFY_CONSTANT (nelts);\n-\t  gcc_assert (TREE_CODE (nelts) == INTEGER_CST\n-\t\t      && TREE_CODE (TREE_OPERAND (probe, 1)) == INTEGER_CST);\n-\t  if (wi::to_widest (TREE_OPERAND (probe, 1)) == wi::to_widest (nelts))\n-\t    {\n-\t      diag_array_subscript (ctx, ary, TREE_OPERAND (probe, 1));\n-\t      *non_constant_p = true;\n-\t      return t;\n-\t    }\n-\t  /* FALLTHRU */\n-\n-\tcase BIT_FIELD_REF:\n-\tcase COMPONENT_REF:\n-\t  probe = TREE_OPERAND (probe, 0);\n-\t  continue;\n-\n-\tdefault:\n-\t  probe = NULL_TREE;\n-\t  continue;\n-\t}\n-    }\n-\n   if (!same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (target), type))\n     {\n       /* For initialization of an empty base, the original target will be\n@@ -3782,7 +3765,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t\t\t   non_constant_p, overflow_p);\n     }\n \n-  /* And then find the underlying variable.  */\n+  /* Find the underlying variable.  */\n   releasing_vec refs;\n   tree object = NULL_TREE;\n   for (tree probe = target; object == NULL_TREE; )\n@@ -3792,9 +3775,20 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \tcase BIT_FIELD_REF:\n \tcase COMPONENT_REF:\n \tcase ARRAY_REF:\n-\t  vec_safe_push (refs, TREE_OPERAND (probe, 1));\n-\t  vec_safe_push (refs, TREE_TYPE (probe));\n-\t  probe = TREE_OPERAND (probe, 0);\n+\t  {\n+\t    tree ob = TREE_OPERAND (probe, 0);\n+\t    tree elt = TREE_OPERAND (probe, 1);\n+\t    if (TREE_CODE (probe) == ARRAY_REF)\n+\t      {\n+\t\telt = eval_and_check_array_index (ctx, probe, false,\n+\t\t\t\t\t\t  non_constant_p, overflow_p);\n+\t\tif (*non_constant_p)\n+\t\t  return t;\n+\t      }\n+\t    vec_safe_push (refs, elt);\n+\t    vec_safe_push (refs, TREE_TYPE (probe));\n+\t    probe = ob;\n+\t  }\n \t  break;\n \n \tdefault:"}, {"sha": "063d556871d6f41cef8f429b587dba8f990519fc", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-79655.C", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/043666e0955d64ed538f2a5511f9fdc5484b657a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-79655.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/043666e0955d64ed538f2a5511f9fdc5484b657a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-79655.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-79655.C?ref=043666e0955d64ed538f2a5511f9fdc5484b657a", "patch": "@@ -5,14 +5,14 @@ constexpr int\n foo (int x, int y)\n {\n   int a[6] = { 1, 2, 3, 4, 5, 6 };\n-  a[x] = 0;\n-  return a[y];\n+  a[x] = 0;\t\t\t   // { dg-error \"is outside the bounds\" }\n+  return a[y];\t\t\t   // { dg-error \"is outside the bounds\" }\n }\n \n-constexpr int b = foo (0, -1);\t// { dg-error \"is outside the bounds|in .constexpr. expansion of \" }\n-constexpr int c = foo (0, 6);\t// { dg-error \"is outside the bounds|in .constexpr. expansion of \" }\n-constexpr int d = foo (6, 0);\t// { dg-error \"is outside the bounds|in .constexpr. expansion of \" }\n-constexpr int e = foo (-1, 0);\t// { dg-error \"is outside the bounds|in .constexpr. expansion of \" }\n+constexpr int b = foo (0, -1);\t// { dg-message \"in .constexpr. expansion of \" }\n+constexpr int c = foo (0, 6);\t// { dg-message \"in .constexpr. expansion of \" }\n+constexpr int d = foo (6, 0);\t// { dg-message \"in .constexpr. expansion of \" }\n+constexpr int e = foo (-1, 0);\t// { dg-message \"in .constexpr. expansion of \" }\n static_assert (foo (5, 5) == 0, \"\");\n static_assert (foo (4, 5) == 6, \"\");\n static_assert (foo (5, 4) == 5, \"\");"}, {"sha": "21eeda3c940aa24538440a750e8e55a97a883edf", "filename": "gcc/testsuite/g++.dg/cpp1y/pr77830.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/043666e0955d64ed538f2a5511f9fdc5484b657a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr77830.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/043666e0955d64ed538f2a5511f9fdc5484b657a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr77830.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr77830.C?ref=043666e0955d64ed538f2a5511f9fdc5484b657a", "patch": "@@ -13,7 +13,7 @@ constexpr void\n P<N>::foo (const char *, int i)\n {\n   for (auto j = 0; j < 2; ++j)\n-    arr[i][j] = true;\n+    arr[i][j] = true;\t\t// { dg-error \"outside the bounds of array type\" }\n }\n \n template <typename... T>\n@@ -30,5 +30,5 @@ bar (T... a)\n int\n main ()\n {\n-  constexpr auto a = bar (\"\", \"\");\t// { dg-error \"outside the bounds of array type|in .constexpr. expansion of \" }\n+  constexpr auto a = bar (\"\", \"\");\t// { dg-message \"in .constexpr. expansion of \" }\n }"}, {"sha": "62832725a59b8f2713f59257bf83196d9e6bbd4c", "filename": "gcc/testsuite/g++.dg/ext/constexpr-vla1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/043666e0955d64ed538f2a5511f9fdc5484b657a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconstexpr-vla1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/043666e0955d64ed538f2a5511f9fdc5484b657a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconstexpr-vla1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconstexpr-vla1.C?ref=043666e0955d64ed538f2a5511f9fdc5484b657a", "patch": "@@ -21,10 +21,10 @@ fn_not_ok (int n)\n     int z = 0;\n \n     for (unsigned i = 0; i < sizeof (a); ++i)\n-      z += a[i];\n+      z += a[i];\t\t// { dg-error \"array subscript\" }\n \n     return z;\n }\n \n constexpr int n1 = fn_ok (3);\n-constexpr int n2 = fn_not_ok (3); // { dg-error \"array subscript|in .constexpr. expansion of \" }\n+constexpr int n2 = fn_not_ok (3); // { dg-message \"in .constexpr. expansion of \" }"}]}