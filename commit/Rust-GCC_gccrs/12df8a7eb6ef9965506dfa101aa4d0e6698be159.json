{"sha": "12df8a7eb6ef9965506dfa101aa4d0e6698be159", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJkZjhhN2ViNmVmOTk2NTUwNmRmYTEwMWFhNGQwZTY2OThiZTE1OQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2007-03-02T20:09:31Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2007-03-02T20:09:31Z"}, "message": "Used signed infinities in VRP.\n\n\t* tree-vrp.c (uses_overflow_infinity): New static function.\n\t(supports_overflow_infinity): New static function.\n\t(make_overflow_infinity): New static function.\n\t(negative_overflow_infinity): New static function.\n\t(positive_overflow_infinity): New static function.\n\t(is_negative_overflow_infinity): New static function.\n\t(is_positive_overflow_infinity): New static function.\n\t(is_overflow_infinity): New static function.\n\t(overflow_infinity_range_p): New static function.\n\t(compare_values_warnv): New function split out of compare_values.\n\t(compare_value): Call it.\n\t(set_value_range_to_nonnegative): Add overflow_infinity\n\tparameter.  Change caller.\n\t(vrp_expr_computes_nonnegative): Add strict_overflow_p parameter.\n\tChange callers.\n\t(vrp_expr_computes_nonzero): Likewise.\n\t(compare_ranges, compare_range_with_value): Likewise.\n\t(compare_name_with_value, compare_names): Likewise.\n\t(vrp_evaluate_conditional): Likewise.\n\t(set_value_range): Handle infinity\n\t(vrp_operand_equal_p, operand_less_p): Likewise.\n\t(extract_range_from_assert): Likewise.\n\t(vrp_int_const_binop): Likewise.\n\t(extract_range_from_binary_expr): Likewise.\n\t(extract_range_from_unary_expr): Likewise.\n\t(extract_range_from_comparison): Likewise.\n\t(extract_range_from_expr): Likewise.\n\t(dump_value_range): Likewise.\n\t(vrp_visit_cond_stmt, vrp_visit_phi_node): Likewise.\n\t(test_for_singularity): Likewise.\n\t(vrp_int_const_binop): Remove inline qualifier.\n\t(adjust_range_with_scev): Add comment.\n\t* tree-flow.h (vrp_evaluate_conditional): Update declaration.\n\nFrom-SVN: r122487", "tree": {"sha": "08d9af36c26e8904e6735ae169f37837147cbdc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08d9af36c26e8904e6735ae169f37837147cbdc7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12df8a7eb6ef9965506dfa101aa4d0e6698be159", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12df8a7eb6ef9965506dfa101aa4d0e6698be159", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12df8a7eb6ef9965506dfa101aa4d0e6698be159", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12df8a7eb6ef9965506dfa101aa4d0e6698be159/comments", "author": null, "committer": null, "parents": [{"sha": "386e9d408b56891b27b419e89f67320ff36f71aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/386e9d408b56891b27b419e89f67320ff36f71aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/386e9d408b56891b27b419e89f67320ff36f71aa"}], "stats": {"total": 993, "additions": 789, "deletions": 204}, "files": [{"sha": "0976767deed6e1c5f06fcf78d2e4ff267e85679c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12df8a7eb6ef9965506dfa101aa4d0e6698be159/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12df8a7eb6ef9965506dfa101aa4d0e6698be159/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=12df8a7eb6ef9965506dfa101aa4d0e6698be159", "patch": "@@ -1,3 +1,40 @@\n+2007-03-03  Ian Lance Taylor  <iant@google.com>\n+\n+\tUsed signed infinities in VRP.\n+\t* tree-vrp.c (uses_overflow_infinity): New static function.\n+\t(supports_overflow_infinity): New static function.\n+\t(make_overflow_infinity): New static function.\n+\t(negative_overflow_infinity): New static function.\n+\t(positive_overflow_infinity): New static function.\n+\t(is_negative_overflow_infinity): New static function.\n+\t(is_positive_overflow_infinity): New static function.\n+\t(is_overflow_infinity): New static function.\n+\t(overflow_infinity_range_p): New static function.\n+\t(compare_values_warnv): New function split out of compare_values.\n+\t(compare_value): Call it.\n+\t(set_value_range_to_nonnegative): Add overflow_infinity\n+\tparameter.  Change caller.\n+\t(vrp_expr_computes_nonnegative): Add strict_overflow_p parameter.\n+\tChange callers.\n+\t(vrp_expr_computes_nonzero): Likewise.\n+\t(compare_ranges, compare_range_with_value): Likewise.\n+\t(compare_name_with_value, compare_names): Likewise.\n+\t(vrp_evaluate_conditional): Likewise.\n+\t(set_value_range): Handle infinity\n+\t(vrp_operand_equal_p, operand_less_p): Likewise.\n+\t(extract_range_from_assert): Likewise.\n+\t(vrp_int_const_binop): Likewise.\n+\t(extract_range_from_binary_expr): Likewise.\n+\t(extract_range_from_unary_expr): Likewise.\n+\t(extract_range_from_comparison): Likewise.\n+\t(extract_range_from_expr): Likewise.\n+\t(dump_value_range): Likewise.\n+\t(vrp_visit_cond_stmt, vrp_visit_phi_node): Likewise.\n+\t(test_for_singularity): Likewise.\n+\t(vrp_int_const_binop): Remove inline qualifier.\n+\t(adjust_range_with_scev): Add comment.\n+\t* tree-flow.h (vrp_evaluate_conditional): Update declaration.\n+\n 2007-03-02  Diego Novillo  <dnovillo@redhat.com>\n \n \t* tree-ssa-structalias.c (could_have_pointers): Tidy."}, {"sha": "87b655bda6716d101f06bfd92dcf1a7ade4d3878", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12df8a7eb6ef9965506dfa101aa4d0e6698be159/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12df8a7eb6ef9965506dfa101aa4d0e6698be159/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=12df8a7eb6ef9965506dfa101aa4d0e6698be159", "patch": "@@ -776,7 +776,7 @@ bool fold_stmt_inplace (tree);\n tree widen_bitfield (tree, tree, tree);\n \n /* In tree-vrp.c  */\n-tree vrp_evaluate_conditional (tree, bool);\n+tree vrp_evaluate_conditional (tree, bool, bool *);\n void simplify_stmt_using_ranges (tree);\n \n /* In tree-ssa-dom.c  */"}, {"sha": "3cc3239f3becb8afc675474db47c105abe78180d", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12df8a7eb6ef9965506dfa101aa4d0e6698be159/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12df8a7eb6ef9965506dfa101aa4d0e6698be159/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=12df8a7eb6ef9965506dfa101aa4d0e6698be159", "patch": "@@ -1100,6 +1100,7 @@ fold_predicate_in (tree stmt)\n   tree *pred_p = NULL;\n   bool modify_stmt_p = false;\n   tree val;\n+  bool sop;\n \n   if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n       && COMPARISON_CLASS_P (GIMPLE_STMT_OPERAND (stmt, 1)))\n@@ -1112,7 +1113,8 @@ fold_predicate_in (tree stmt)\n   else\n     return false;\n \n-  val = vrp_evaluate_conditional (*pred_p, true);\n+  sop = false;\n+  val = vrp_evaluate_conditional (*pred_p, true, &sop);\n   if (val)\n     {\n       if (modify_stmt_p)"}, {"sha": "d3785a427e1ec11ce6f47847803fdead3b7f55ac", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 748, "deletions": 202, "changes": 950, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12df8a7eb6ef9965506dfa101aa4d0e6698be159/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12df8a7eb6ef9965506dfa101aa4d0e6698be159/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=12df8a7eb6ef9965506dfa101aa4d0e6698be159", "patch": "@@ -44,6 +44,7 @@ static sbitmap found_in_subgraph;\n \n /* Local functions.  */\n static int compare_values (tree val1, tree val2);\n+static int compare_values_warnv (tree val1, tree val2, bool *);\n static void vrp_meet (value_range_t *, value_range_t *);\n \n /* Location information for ASSERT_EXPRs.  Each instance of this\n@@ -93,6 +94,107 @@ static sbitmap blocks_visited;\n static value_range_t **vr_value;\n \n \n+/* Return whether TYPE should use an overflow infinity distinct from\n+   TYPE_{MIN,MAX}_VALUE.  We use an overflow infinity value to\n+   represent a signed overflow during VRP computations.  An infinity\n+   is distinct from a half-range, which will go from some number to\n+   TYPE_{MIN,MAX}_VALUE.  */\n+\n+static inline bool\n+needs_overflow_infinity (tree type)\n+{\n+  return INTEGRAL_TYPE_P (type) && !TYPE_OVERFLOW_WRAPS (type);\n+}\n+\n+/* Return whether TYPE can support our overflow infinity\n+   representation: we use the TREE_OVERFLOW flag, which only exists\n+   for constants.  If TYPE doesn't support this, we don't optimize\n+   cases which would require signed overflow--we drop them to\n+   VARYING.  */\n+\n+static inline bool\n+supports_overflow_infinity (tree type)\n+{\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (needs_overflow_infinity (type));\n+#endif\n+  return (TYPE_MIN_VALUE (type) != NULL_TREE\n+\t  && CONSTANT_CLASS_P (TYPE_MIN_VALUE (type))\n+\t  && TYPE_MAX_VALUE (type) != NULL_TREE\n+\t  && CONSTANT_CLASS_P (TYPE_MAX_VALUE (type)));\n+}\n+\n+/* VAL is the maximum or minimum value of a type.  Return a\n+   corresponding overflow infinity.  */\n+\n+static inline tree\n+make_overflow_infinity (tree val)\n+{\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (val != NULL_TREE && CONSTANT_CLASS_P (val));\n+#endif\n+  val = copy_node (val);\n+  TREE_OVERFLOW (val) = 1;\n+  return val;\n+}\n+\n+/* Return a negative overflow infinity for TYPE.  */\n+\n+static inline tree\n+negative_overflow_infinity (tree type)\n+{\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (supports_overflow_infinity (type));\n+#endif\n+  return make_overflow_infinity (TYPE_MIN_VALUE (type));\n+}\n+\n+/* Return a positive overflow infinity for TYPE.  */\n+\n+static inline tree\n+positive_overflow_infinity (tree type)\n+{\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (supports_overflow_infinity (type));\n+#endif\n+  return make_overflow_infinity (TYPE_MAX_VALUE (type));\n+}\n+\n+/* Return whether VAL is a negative overflow infinity.  */\n+\n+static inline bool\n+is_negative_overflow_infinity (tree val)\n+{\n+  return (needs_overflow_infinity (TREE_TYPE (val))\n+\t  && CONSTANT_CLASS_P (val)\n+\t  && TREE_OVERFLOW (val)\n+\t  && operand_equal_p (val, TYPE_MIN_VALUE (TREE_TYPE (val)), 0));\n+}\n+\n+/* Return whether VAL is a positive overflow infinity.  */\n+\n+static inline bool\n+is_positive_overflow_infinity (tree val)\n+{\n+  return (needs_overflow_infinity (TREE_TYPE (val))\n+\t  && CONSTANT_CLASS_P (val)\n+\t  && TREE_OVERFLOW (val)\n+\t  && operand_equal_p (val, TYPE_MAX_VALUE (TREE_TYPE (val)), 0));\n+}\n+\n+/* Return whether VAL is a positive or negative overflow infinity.  */\n+\n+static inline bool\n+is_overflow_infinity (tree val)\n+{\n+  return (needs_overflow_infinity (TREE_TYPE (val))\n+\t  && CONSTANT_CLASS_P (val)\n+\t  && TREE_OVERFLOW (val)\n+\t  && (operand_equal_p (val, TYPE_MAX_VALUE (TREE_TYPE (val)), 0)\n+\t      || operand_equal_p (val, TYPE_MIN_VALUE (TREE_TYPE (val)), 0)));\n+}\n+\n+\n /* Return true if ARG is marked with the nonnull attribute in the\n    current function signature.  */\n \n@@ -156,8 +258,10 @@ set_value_range (value_range_t *vr, enum value_range_type t, tree min,\n       gcc_assert (min && max);\n \n       if (INTEGRAL_TYPE_P (TREE_TYPE (min)) && t == VR_ANTI_RANGE)\n-\tgcc_assert (min != TYPE_MIN_VALUE (TREE_TYPE (min))\n-\t\t    || max != TYPE_MAX_VALUE (TREE_TYPE (max)));\n+\tgcc_assert ((min != TYPE_MIN_VALUE (TREE_TYPE (min))\n+\t\t     && !is_negative_overflow_infinity (min))\n+\t\t    || (max != TYPE_MAX_VALUE (TREE_TYPE (max))\n+\t\t\t&& !is_positive_overflow_infinity (max)));\n \n       cmp = compare_values (min, max);\n       gcc_assert (cmp == 0 || cmp == -1 || cmp == -2);\n@@ -197,13 +301,42 @@ copy_value_range (value_range_t *to, value_range_t *from)\n   set_value_range (to, from->type, from->min, from->max, from->equiv);\n }\n \n-/* Set value range VR to a non-negative range of type TYPE.  */\n+\n+/* Set value range VR to VR_VARYING.  */\n \n static inline void\n-set_value_range_to_nonnegative (value_range_t *vr, tree type)\n+set_value_range_to_varying (value_range_t *vr)\n {\n-  tree zero = build_int_cst (type, 0);\n-  set_value_range (vr, VR_RANGE, zero, TYPE_MAX_VALUE (type), vr->equiv);\n+  vr->type = VR_VARYING;\n+  vr->min = vr->max = NULL_TREE;\n+  if (vr->equiv)\n+    bitmap_clear (vr->equiv);\n+}\n+\n+/* Set value range VR to a non-negative range of type TYPE.\n+   OVERFLOW_INFINITY indicates whether to use a overflow infinity\n+   rather than TYPE_MAX_VALUE; this should be true if we determine\n+   that the range is nonnegative based on the assumption that signed\n+   overflow does not occur.  */\n+\n+static inline void\n+set_value_range_to_nonnegative (value_range_t *vr, tree type,\n+\t\t\t\tbool overflow_infinity)\n+{\n+  tree zero;\n+\n+  if (overflow_infinity && !supports_overflow_infinity (type))\n+    {\n+      set_value_range_to_varying (vr);\n+      return;\n+    }\n+\n+  zero = build_int_cst (type, 0);\n+  set_value_range (vr, VR_RANGE, zero,\n+\t\t   (overflow_infinity\n+\t\t    ? positive_overflow_infinity (type)\n+\t\t    : TYPE_MAX_VALUE (type)),\n+\t\t   vr->equiv);\n }\n \n /* Set value range VR to a non-NULL range of type TYPE.  */\n@@ -226,18 +359,6 @@ set_value_range_to_null (value_range_t *vr, tree type)\n }\n \n \n-/* Set value range VR to VR_VARYING.  */\n-\n-static inline void\n-set_value_range_to_varying (value_range_t *vr)\n-{\n-  vr->type = VR_VARYING;\n-  vr->min = vr->max = NULL_TREE;\n-  if (vr->equiv)\n-    bitmap_clear (vr->equiv);\n-}\n-\n-\n /* Set value range VR to a range of a truthvalue of type TYPE.  */\n \n static inline void\n@@ -314,9 +435,13 @@ get_value_range (tree var)\n static inline bool\n vrp_operand_equal_p (tree val1, tree val2)\n {\n-  return (val1 == val2\n-\t  || (val1 && val2\n-\t      && operand_equal_p (val1, val2, 0)));\n+  if (val1 == val2)\n+    return true;\n+  if (!val1 || !val2 || !operand_equal_p (val1, val2, 0))\n+    return false;\n+  if (is_overflow_infinity (val1))\n+    return is_overflow_infinity (val2);\n+  return true;\n }\n \n /* Return true, if the bitmaps B1 and B2 are equal.  */\n@@ -408,28 +533,32 @@ symbolic_range_p (value_range_t *vr)\n           || !is_gimple_min_invariant (vr->max));\n }\n \n-/* Like tree_expr_nonnegative_p, but this function uses value ranges\n-   obtained so far.  */\n+/* Return true if value range VR uses a overflow infinity.  */\n \n-static bool\n-vrp_expr_computes_nonnegative (tree expr)\n+static inline bool\n+overflow_infinity_range_p (value_range_t *vr)\n {\n-  bool ovf;\n+  return (vr->type == VR_RANGE\n+\t  && (is_overflow_infinity (vr->min)\n+\t      || is_overflow_infinity (vr->max)));\n+}\n \n-  /* FIXME: May need to record overflow information here.  */\n-  return tree_expr_nonnegative_warnv_p (expr, &ovf);\n+/* Like tree_expr_nonnegative_warnv_p, but this function uses value\n+   ranges obtained so far.  */\n+\n+static bool\n+vrp_expr_computes_nonnegative (tree expr, bool *strict_overflow_p)\n+{\n+  return tree_expr_nonnegative_warnv_p (expr, strict_overflow_p);\n }\n \n-/* Like tree_expr_nonzero_p, but this function uses value ranges\n+/* Like tree_expr_nonzero_warnv_p, but this function uses value ranges\n    obtained so far.  */\n \n static bool\n-vrp_expr_computes_nonzero (tree expr)\n+vrp_expr_computes_nonzero (tree expr, bool *strict_overflow_p)\n {\n-  bool ovf;\n-\n-  /* FIXME: May need to record overflow information here.  */\n-  if (tree_expr_nonzero_warnv_p (expr, &ovf))\n+  if (tree_expr_nonzero_warnv_p (expr, strict_overflow_p))\n     return true;\n \n   /* If we have an expression of the form &X->a, then the expression\n@@ -475,20 +604,36 @@ valid_value_p (tree expr)\n static inline int\n operand_less_p (tree val, tree val2)\n {\n-  tree tcmp;\n   /* LT is folded faster than GE and others.  Inline the common case.  */\n   if (TREE_CODE (val) == INTEGER_CST && TREE_CODE (val2) == INTEGER_CST)\n     {\n       if (TYPE_UNSIGNED (TREE_TYPE (val)))\n \treturn INT_CST_LT_UNSIGNED (val, val2);\n       else\n-\treturn INT_CST_LT (val, val2);\n+\t{\n+\t  if (INT_CST_LT (val, val2))\n+\t    return 1;\n+\t}\n     }\n   else\n-    tcmp = fold_binary_to_constant (LT_EXPR, boolean_type_node, val, val2);\n-  if (!tcmp)\n-    return -2;\n-  return !integer_zerop (tcmp);\n+    {\n+      tree tcmp;\n+\n+      tcmp = fold_binary_to_constant (LT_EXPR, boolean_type_node, val, val2);\n+      if (!tcmp)\n+\treturn -2;\n+\n+      if (!integer_zerop (tcmp))\n+\treturn 1;\n+    }\n+\n+  /* val >= val2, not considering overflow infinity.  */\n+  if (is_negative_overflow_infinity (val))\n+    return is_negative_overflow_infinity (val2) ? 0 : 1;\n+  else if (is_positive_overflow_infinity (val2))\n+    return is_positive_overflow_infinity (val) ? 0 : 1;\n+\n+  return 0;\n }\n \n /* Compare two values VAL1 and VAL2.  Return\n@@ -500,10 +645,14 @@ operand_less_p (tree val, tree val2)\n \t+2 if VAL1 != VAL2\n \n    This is similar to tree_int_cst_compare but supports pointer values\n-   and values that cannot be compared at compile time.  */\n+   and values that cannot be compared at compile time.\n+\n+   If STRICT_OVERFLOW_P is not NULL, then set *STRICT_OVERFLOW_P to\n+   true if the return value is only valid if we assume that signed\n+   overflow is undefined.  */\n \n static int\n-compare_values (tree val1, tree val2)\n+compare_values_warnv (tree val1, tree val2, bool *strict_overflow_p)\n {\n   if (val1 == val2)\n     return 0;\n@@ -539,6 +688,8 @@ compare_values (tree val1, tree val2)\n \t  c1 = TREE_OPERAND (val1, 1);\n \t  if (tree_int_cst_sgn (c1) == -1)\n \t    {\n+\t      if (is_negative_overflow_infinity (c1))\n+\t\treturn -2;\n \t      c1 = fold_unary_to_constant (NEGATE_EXPR, TREE_TYPE (c1), c1);\n \t      if (!c1)\n \t\treturn -2;\n@@ -559,6 +710,8 @@ compare_values (tree val1, tree val2)\n \t  c2 = TREE_OPERAND (val2, 1);\n \t  if (tree_int_cst_sgn (c2) == -1)\n \t    {\n+\t      if (is_negative_overflow_infinity (c2))\n+\t\treturn -2;\n \t      c2 = fold_unary_to_constant (NEGATE_EXPR, TREE_TYPE (c2), c2);\n \t      if (!c2)\n \t\treturn -2;\n@@ -579,6 +732,9 @@ compare_values (tree val1, tree val2)\n       if (!TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (val1)))\n \treturn -2;\n \n+      if (strict_overflow_p != NULL)\n+\t*strict_overflow_p = true;\n+\n       if (code1 == SSA_NAME)\n \t{\n \t  if (code2 == PLUS_EXPR)\n@@ -595,7 +751,7 @@ compare_values (tree val1, tree val2)\n \t    return 1;\n \t  else if (code2 == PLUS_EXPR)\n \t    /* NAME + CST1 > NAME + CST2, if CST1 > CST2  */\n-\t    return compare_values (c1, c2);\n+\t    return compare_values_warnv (c1, c2, strict_overflow_p);\n \t  else if (code2 == MINUS_EXPR)\n \t    /* NAME + CST1 > NAME - CST2  */\n \t    return 1;\n@@ -611,7 +767,7 @@ compare_values (tree val1, tree val2)\n \t  else if (code2 == MINUS_EXPR)\n \t    /* NAME - CST1 > NAME - CST2, if CST1 < CST2.  Notice that\n \t       C1 and C2 are swapped in the call to compare_values.  */\n-\t    return compare_values (c2, c1);\n+\t    return compare_values_warnv (c2, c1, strict_overflow_p);\n \t}\n \n       gcc_unreachable ();\n@@ -623,9 +779,23 @@ compare_values (tree val1, tree val2)\n \n   if (!POINTER_TYPE_P (TREE_TYPE (val1)))\n     {\n-      /* We cannot compare overflowed values.  */\n+      /* We cannot compare overflowed values, except for overflow\n+\t infinities.  */\n       if (TREE_OVERFLOW (val1) || TREE_OVERFLOW (val2))\n-\treturn -2;\n+\t{\n+\t  if (!TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (val1)))\n+\t    return -2;\n+\n+\t  if (is_negative_overflow_infinity (val1))\n+\t    return is_negative_overflow_infinity (val2) ? 0 : -1;\n+\t  else if (is_negative_overflow_infinity (val2))\n+\t    return 1;\n+\t  else if (is_positive_overflow_infinity (val1))\n+\t    return is_positive_overflow_infinity (val2) ? 0 : 1;\n+\t  else if (is_positive_overflow_infinity (val2))\n+\t    return -1;\n+\t  return -2;\n+\t}\n \n       return tree_int_cst_compare (val1, val2);\n     }\n@@ -661,6 +831,22 @@ compare_values (tree val1, tree val2)\n     }\n }\n \n+/* Compare values like compare_values_warnv, but treat comparisons\n+   which rely on undefined overflow as incomparable.  */\n+\n+static int\n+compare_values (tree val1, tree val2)\n+{\n+  bool sop;\n+  int ret;\n+\n+  sop = false;\n+  ret = compare_values_warnv (val1, val2, &sop);\n+  if (sop)\n+    ret = -2;\n+  return ret;\n+}\n+\n \n /* Return 1 if VAL is inside value range VR (VR->MIN <= VAL <= VR->MAX),\n           0 if VAL is not inside VR,\n@@ -926,8 +1112,10 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n       /* If MIN and MAX cover the whole range for their type, then\n \t just use the original LIMIT.  */\n       if (INTEGRAL_TYPE_P (type)\n-\t  && min == TYPE_MIN_VALUE (type)\n-\t  && max == TYPE_MAX_VALUE (type))\n+\t  && (min == TYPE_MIN_VALUE (type)\n+\t      || is_negative_overflow_infinity (min))\n+\t  && (max == TYPE_MAX_VALUE (type)\n+\t      || is_positive_overflow_infinity (max)))\n \tmin = max = limit;\n \n       set_value_range (vr_p, VR_ANTI_RANGE, min, max, vr_p->equiv);\n@@ -954,7 +1142,8 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n       else\n \t{\n \t  /* For LT_EXPR, we create the range [MIN, MAX - 1].  */\n-\t  if (cond_code == LT_EXPR)\n+\t  if (cond_code == LT_EXPR\n+\t      && !is_positive_overflow_infinity (max))\n \t    {\n \t      tree one = build_int_cst (type, 1);\n \t      max = fold_build2 (MINUS_EXPR, type, max, one);\n@@ -985,7 +1174,8 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n       else\n \t{\n \t  /* For GT_EXPR, we create the range [MIN + 1, MAX].  */\n-\t  if (cond_code == GT_EXPR)\n+\t  if (cond_code == GT_EXPR\n+\t      && !is_negative_overflow_infinity (min))\n \t    {\n \t      tree one = build_int_cst (type, 1);\n \t      min = fold_build2 (PLUS_EXPR, type, min, one);\n@@ -1156,9 +1346,21 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n \t\t    || cmp == 0)\n \t\t   && compare_values (anti_max, real_max) == -1)\n \t    {\n-\t      min = fold_build2 (PLUS_EXPR, TREE_TYPE (var_vr->min),\n-\t\t\t\t anti_max,\n-\t\t\t\t build_int_cst (TREE_TYPE (var_vr->min), 1));\n+\t      gcc_assert (!is_positive_overflow_infinity (anti_max));\n+\t      if (needs_overflow_infinity (TREE_TYPE (anti_max))\n+\t\t  && anti_max == TYPE_MAX_VALUE (TREE_TYPE (anti_max)))\n+\t\t{\n+\t\t  if (!supports_overflow_infinity (TREE_TYPE (var_vr->min)))\n+\t\t    {\n+\t\t      set_value_range_to_varying (vr_p);\n+\t\t      return;\n+\t\t    }\n+\t\t  min = positive_overflow_infinity (TREE_TYPE (var_vr->min));\n+\t\t}\n+\t      else\n+\t\tmin = fold_build2 (PLUS_EXPR, TREE_TYPE (var_vr->min),\n+\t\t\t\t   anti_max,\n+\t\t\t\t   build_int_cst (TREE_TYPE (var_vr->min), 1));\n \t      max = real_max;\n \t      set_value_range (vr_p, VR_RANGE, min, max, vr_p->equiv);\n \t    }\n@@ -1169,9 +1371,21 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n \t\t   && ((cmp = compare_values (anti_min, real_max)) == -1\n \t\t       || cmp == 0))\n \t    {\n-\t      max = fold_build2 (MINUS_EXPR, TREE_TYPE (var_vr->min),\n-\t\t\t\t anti_min,\n-\t\t\t\t build_int_cst (TREE_TYPE (var_vr->min), 1));\n+\t      gcc_assert (!is_negative_overflow_infinity (anti_min));\n+\t      if (needs_overflow_infinity (TREE_TYPE (anti_min))\n+\t\t  && anti_min == TYPE_MIN_VALUE (TREE_TYPE (anti_min)))\n+\t\t{\n+\t\t  if (!supports_overflow_infinity (TREE_TYPE (var_vr->min)))\n+\t\t    {\n+\t\t      set_value_range_to_varying (vr_p);\n+\t\t      return;\n+\t\t    }\n+\t\t  max = negative_overflow_infinity (TREE_TYPE (var_vr->min));\n+\t\t}\n+\t      else\n+\t\tmax = fold_build2 (MINUS_EXPR, TREE_TYPE (var_vr->min),\n+\t\t\t\t   anti_min,\n+\t\t\t\t   build_int_cst (TREE_TYPE (var_vr->min), 1));\n \t      min = real_min;\n \t      set_value_range (vr_p, VR_RANGE, min, max, vr_p->equiv);\n \t    }\n@@ -1209,9 +1423,11 @@ extract_range_from_ssa_name (value_range_t *vr, tree var)\n \n /* Wrapper around int_const_binop.  If the operation overflows and we\n    are not using wrapping arithmetic, then adjust the result to be\n-   -INF or +INF depending on CODE, VAL1 and VAL2.  */\n+   -INF or +INF depending on CODE, VAL1 and VAL2.  This can return\n+   NULL_TREE if we need to use an overflow infinity representation but\n+   the type does not support it.  */\n \n-static inline tree\n+static tree\n vrp_int_const_binop (enum tree_code code, tree val1, tree val2)\n {\n   tree res;\n@@ -1257,16 +1473,31 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2)\n \t}\n \n     }\n-  else if (TREE_OVERFLOW (res)\n-\t   && !TREE_OVERFLOW (val1)\n-\t   && !TREE_OVERFLOW (val2))\n+  else if ((TREE_OVERFLOW (res)\n+\t    && !TREE_OVERFLOW (val1)\n+\t    && !TREE_OVERFLOW (val2))\n+\t   || is_overflow_infinity (val1)\n+\t   || is_overflow_infinity (val2))\n     {\n       /* If the operation overflowed but neither VAL1 nor VAL2 are\n \t overflown, return -INF or +INF depending on the operation\n \t and the combination of signs of the operands.  */\n       int sgn1 = tree_int_cst_sgn (val1);\n       int sgn2 = tree_int_cst_sgn (val2);\n \n+      if (needs_overflow_infinity (TREE_TYPE (res))\n+\t  && !supports_overflow_infinity (TREE_TYPE (res)))\n+\treturn NULL_TREE;\n+\n+      /* We have to punt on subtracting infinities of the same sign,\n+\t since we can't tell what the sign of the result should\n+\t be.  */\n+      if (code == MINUS_EXPR\n+\t  && sgn1 == sgn2\n+\t  && is_overflow_infinity (val1)\n+\t  && is_overflow_infinity (val2))\n+\treturn NULL_TREE;\n+\n       /* Notice that we only need to handle the restricted set of\n \t operations handled by extract_range_from_binary_expr.\n \t Among them, only multiplication, addition and subtraction\n@@ -1282,22 +1513,30 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2)\n \t     to yield an overflow.  Its sign is therefore that\n \t     of one of the operands, for example the first.  */\n \t  || (code == PLUS_EXPR && sgn1 > 0)\n-\t  /* For subtraction, the operands must be of different\n-\t     signs to yield an overflow.  Its sign is therefore\n-\t     that of the first operand or the opposite of that\n-\t     of the second operand.  A first operand of 0 counts\n-\t     as positive here, for the corner case 0 - (-INF),\n-\t     which overflows, but must yield +INF.  */\n-\t  || (code == MINUS_EXPR && sgn1 >= 0)\n+\t  /* For subtraction, non-infinite operands must be of\n+\t     different signs to yield an overflow.  Its sign is\n+\t     therefore that of the first operand or the opposite of\n+\t     that of the second operand.  A first operand of 0 counts\n+\t     as positive here, for the corner case 0 - (-INF), which\n+\t     overflows, but must yield +INF.  For infinite operands 0\n+\t     - INF is negative, not positive.  */\n+\t  || (code == MINUS_EXPR\n+\t      && (sgn1 >= 0\n+\t\t  ? !is_positive_overflow_infinity (val2)\n+\t\t  : is_negative_overflow_infinity (val2)))\n \t  /* For division, the only case is -INF / -1 = +INF.  */\n \t  || code == TRUNC_DIV_EXPR\n \t  || code == FLOOR_DIV_EXPR\n \t  || code == CEIL_DIV_EXPR\n \t  || code == EXACT_DIV_EXPR\n \t  || code == ROUND_DIV_EXPR)\n-\treturn TYPE_MAX_VALUE (TREE_TYPE (res));\n+\treturn (needs_overflow_infinity (TREE_TYPE (res))\n+\t\t? positive_overflow_infinity (TREE_TYPE (res))\n+\t\t: TYPE_MAX_VALUE (TREE_TYPE (res)));\n       else\n-\treturn TYPE_MIN_VALUE (TREE_TYPE (res));\n+\treturn (needs_overflow_infinity (TREE_TYPE (res))\n+\t\t? negative_overflow_infinity (TREE_TYPE (res))\n+\t\t: TYPE_MIN_VALUE (TREE_TYPE (res)));\n     }\n \n   return res;\n@@ -1451,7 +1690,9 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n \t       && vr1.type != VR_VARYING\n \t       && vr0.type == vr1.type\n \t       && !symbolic_range_p (&vr0)\n-\t       && !symbolic_range_p (&vr1))\n+\t       && !overflow_infinity_range_p (&vr0)\n+\t       && !symbolic_range_p (&vr1)\n+\t       && !overflow_infinity_range_p (&vr1))\n \t{\n \t  /* Boolean expressions cannot be folded with int_const_binop.  */\n \t  min = fold_binary (code, TREE_TYPE (expr), vr0.min, vr1.min);\n@@ -1496,6 +1737,7 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n     {\n       tree val[4];\n       size_t i;\n+      bool sop;\n \n       /* If we have an unsigned MULT_EXPR with two VR_ANTI_RANGEs,\n \t drop to VR_VARYING.  It would take more effort to compute a\n@@ -1535,33 +1777,61 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n \t}\n \n       /* Compute the 4 cross operations.  */\n+      sop = false;\n       val[0] = vrp_int_const_binop (code, vr0.min, vr1.min);\n+      if (val[0] == NULL_TREE)\n+\tsop = true;\n+\n+      if (vr1.max == vr1.min)\n+\tval[1] = NULL_TREE;\n+      else\n+\t{\n+\t  val[1] = vrp_int_const_binop (code, vr0.min, vr1.max);\n+\t  if (val[1] == NULL_TREE)\n+\t    sop = true;\n+\t}\n \n-      val[1] = (vr1.max != vr1.min)\n-\t       ? vrp_int_const_binop (code, vr0.min, vr1.max)\n-\t       : NULL_TREE;\n+      if (vr0.max == vr0.min)\n+\tval[2] = NULL_TREE;\n+      else\n+\t{\n+\t  val[2] = vrp_int_const_binop (code, vr0.max, vr1.min);\n+\t  if (val[2] == NULL_TREE)\n+\t    sop = true;\n+\t}\n \n-      val[2] = (vr0.max != vr0.min)\n-\t       ? vrp_int_const_binop (code, vr0.max, vr1.min)\n-\t       : NULL_TREE;\n+      if (vr0.min == vr0.max || vr1.min == vr1.max)\n+\tval[3] = NULL_TREE;\n+      else\n+\t{\n+\t  val[3] = vrp_int_const_binop (code, vr0.max, vr1.max);\n+\t  if (val[3] == NULL_TREE)\n+\t    sop = true;\n+\t}\n \n-      val[3] = (vr0.min != vr0.max && vr1.min != vr1.max)\n-\t       ? vrp_int_const_binop (code, vr0.max, vr1.max)\n-\t       : NULL_TREE;\n+      if (sop)\n+\t{\n+\t  set_value_range_to_varying (vr);\n+\t  return;\n+\t}\n \n       /* Set MIN to the minimum of VAL[i] and MAX to the maximum\n \t of VAL[i].  */\n       min = val[0];\n       max = val[0];\n       for (i = 1; i < 4; i++)\n \t{\n-\t  if (!is_gimple_min_invariant (min) || TREE_OVERFLOW (min)\n-\t      || !is_gimple_min_invariant (max) || TREE_OVERFLOW (max))\n+\t  if (!is_gimple_min_invariant (min)\n+\t      || (TREE_OVERFLOW (min) && !is_overflow_infinity (min))\n+\t      || !is_gimple_min_invariant (max)\n+\t      || (TREE_OVERFLOW (max) && !is_overflow_infinity (max)))\n \t    break;\n \n \t  if (val[i])\n \t    {\n-\t      if (!is_gimple_min_invariant (val[i]) || TREE_OVERFLOW (val[i]))\n+\t      if (!is_gimple_min_invariant (val[i])\n+\t\t  || (TREE_OVERFLOW (val[i])\n+\t\t      && !is_overflow_infinity (val[i])))\n \t\t{\n \t\t  /* If we found an overflowed value, set MIN and MAX\n \t\t     to it so that we set the resulting range to\n@@ -1602,16 +1872,18 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n     {\n       if (vr0.type == VR_RANGE\n \t  && vr0.min == vr0.max\n-\t  && tree_expr_nonnegative_p (vr0.max)\n-\t  && TREE_CODE (vr0.max) == INTEGER_CST)\n+\t  && TREE_CODE (vr0.max) == INTEGER_CST\n+\t  && !TREE_OVERFLOW (vr0.max)\n+\t  && tree_int_cst_sgn (vr0.max) >= 0)\n \t{\n \t  min = build_int_cst (TREE_TYPE (expr), 0);\n \t  max = vr0.max;\n \t}\n       else if (vr1.type == VR_RANGE\n-\t  && vr1.min == vr1.max\n-\t  && tree_expr_nonnegative_p (vr1.max)\n-\t  && TREE_CODE (vr1.max) == INTEGER_CST)\n+\t       && vr1.min == vr1.max\n+\t       && TREE_CODE (vr1.max) == INTEGER_CST\n+\t       && !TREE_OVERFLOW (vr1.max)\n+\t       && tree_int_cst_sgn (vr1.max) >= 0)\n \t{\n \t  type = VR_RANGE;\n \t  min = build_int_cst (TREE_TYPE (expr), 0);\n@@ -1627,9 +1899,23 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n     gcc_unreachable ();\n \n   /* If either MIN or MAX overflowed, then set the resulting range to\n-     VARYING.  */\n-  if (!is_gimple_min_invariant (min) || TREE_OVERFLOW (min)\n-      || !is_gimple_min_invariant (max) || TREE_OVERFLOW (max))\n+     VARYING.  But we do accept an overflow infinity\n+     representation.  */\n+  if (min == NULL_TREE\n+      || !is_gimple_min_invariant (min)\n+      || (TREE_OVERFLOW (min) && !is_overflow_infinity (min))\n+      || max == NULL_TREE\n+      || !is_gimple_min_invariant (max)\n+      || (TREE_OVERFLOW (max) && !is_overflow_infinity (max)))\n+    {\n+      set_value_range_to_varying (vr);\n+      return;\n+    }\n+\n+  if ((min == TYPE_MIN_VALUE (TREE_TYPE (min))\n+       || is_negative_overflow_infinity (min))\n+      && (max == TYPE_MAX_VALUE (TREE_TYPE (max))\n+\t  || is_positive_overflow_infinity (max)))\n     {\n       set_value_range_to_varying (vr);\n       return;\n@@ -1703,10 +1989,12 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n      determining if it evaluates to NULL [0, 0] or non-NULL (~[0, 0]).  */\n   if (POINTER_TYPE_P (TREE_TYPE (expr)) || POINTER_TYPE_P (TREE_TYPE (op0)))\n     {\n-      bool ovf;\n+      bool sop;\n \n-      /* FIXME: May need to record overflow information here.  */\n-      if (range_is_nonnull (&vr0) || tree_expr_nonzero_warnv_p (expr, &ovf))\n+      sop = false;\n+      if (range_is_nonnull (&vr0)\n+\t  || (tree_expr_nonzero_warnv_p (expr, &sop)\n+\t      && !sop))\n \tset_value_range_to_nonnull (vr, TREE_TYPE (expr));\n       else if (range_is_null (&vr0))\n \tset_value_range_to_null (vr, TREE_TYPE (expr));\n@@ -1729,7 +2017,8 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n \t or equal to the new max, then we can safely use the newly\n \t computed range for EXPR.  This allows us to compute\n \t accurate ranges through many casts.  */\n-      if (vr0.type == VR_RANGE\n+      if ((vr0.type == VR_RANGE\n+\t   && !overflow_infinity_range_p (&vr0))\n \t  || (vr0.type == VR_VARYING\n \t      && TYPE_PRECISION (outer_type) > TYPE_PRECISION (inner_type)))\n \t{\n@@ -1797,22 +2086,44 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n       && !TYPE_UNSIGNED (TREE_TYPE (expr)))\n     {\n       /* NEGATE_EXPR flips the range around.  We need to treat\n-\t TYPE_MIN_VALUE specially dependent on wrapping, range type\n-\t and if it was used as minimum or maximum value:  \n-\t  -~[MIN, MIN] == ~[MIN, MIN]\n-\t  -[MIN, 0] == [0, MAX]  for -fno-wrapv\n-\t  -[MIN, 0] == [0, MIN]  for -fwrapv (will be set to varying later)  */\n-      min = vr0.max == TYPE_MIN_VALUE (TREE_TYPE (expr))\n-\t    ? TYPE_MIN_VALUE (TREE_TYPE (expr))\n-\t    : fold_unary_to_constant (code, TREE_TYPE (expr), vr0.max);\n-\n-      max = (vr0.min == TYPE_MIN_VALUE (TREE_TYPE (expr))\n-\t     ? ((vr0.type == VR_ANTI_RANGE\n-\t\t || TYPE_OVERFLOW_WRAPS (TREE_TYPE (expr)))\n-\t\t? TYPE_MIN_VALUE (TREE_TYPE (expr))\n-\t\t: TYPE_MAX_VALUE (TREE_TYPE (expr)))\n-\t     : fold_unary_to_constant (code, TREE_TYPE (expr), vr0.min));\n-\n+\t TYPE_MIN_VALUE specially.  */\n+      if (is_positive_overflow_infinity (vr0.max))\n+\tmin = negative_overflow_infinity (TREE_TYPE (expr));\n+      else if (is_negative_overflow_infinity (vr0.max))\n+\tmin = positive_overflow_infinity (TREE_TYPE (expr));\n+      else if (vr0.max != TYPE_MIN_VALUE (TREE_TYPE (expr)))\n+\tmin = fold_unary_to_constant (code, TREE_TYPE (expr), vr0.max);\n+      else if (needs_overflow_infinity (TREE_TYPE (expr)))\n+\t{\n+\t  if (supports_overflow_infinity (TREE_TYPE (expr)))\n+\t    min = positive_overflow_infinity (TREE_TYPE (expr));\n+\t  else\n+\t    {\n+\t      set_value_range_to_varying (vr);\n+\t      return;\n+\t    }\n+\t}\n+      else\n+\tmin = TYPE_MIN_VALUE (TREE_TYPE (expr));\n+\n+      if (is_positive_overflow_infinity (vr0.min))\n+\tmax = negative_overflow_infinity (TREE_TYPE (expr));\n+      else if (is_negative_overflow_infinity (vr0.min))\n+\tmax = positive_overflow_infinity (TREE_TYPE (expr));\n+      else if (vr0.min != TYPE_MIN_VALUE (TREE_TYPE (expr)))\n+\tmax = fold_unary_to_constant (code, TREE_TYPE (expr), vr0.min);\n+      else if (needs_overflow_infinity (TREE_TYPE (expr)))\n+\t{\n+\t  if (supports_overflow_infinity (TREE_TYPE (expr)))\n+\t    max = positive_overflow_infinity (TREE_TYPE (expr));\n+\t  else\n+\t    {\n+\t      set_value_range_to_varying (vr);\n+\t      return;\n+\t    }\n+\t}\n+      else\n+\tmax = TYPE_MIN_VALUE (TREE_TYPE (expr));\n     }\n   else if (code == NEGATE_EXPR\n \t   && TYPE_UNSIGNED (TREE_TYPE (expr)))\n@@ -1849,11 +2160,33 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n \t\n       /* ABS_EXPR may flip the range around, if the original range\n \t included negative values.  */\n-      min = (vr0.min == TYPE_MIN_VALUE (TREE_TYPE (expr)))\n-\t    ? TYPE_MAX_VALUE (TREE_TYPE (expr))\n-\t    : fold_unary_to_constant (code, TREE_TYPE (expr), vr0.min);\n+      if (is_overflow_infinity (vr0.min))\n+\tmin = positive_overflow_infinity (TREE_TYPE (expr));\n+      else if (vr0.min != TYPE_MIN_VALUE (TREE_TYPE (expr)))\n+\tmin = fold_unary_to_constant (code, TREE_TYPE (expr), vr0.min);\n+      else if (!needs_overflow_infinity (TREE_TYPE (expr)))\n+\tmin = TYPE_MAX_VALUE (TREE_TYPE (expr));\n+      else if (supports_overflow_infinity (TREE_TYPE (expr)))\n+\tmin = positive_overflow_infinity (TREE_TYPE (expr));\n+      else\n+\t{\n+\t  set_value_range_to_varying (vr);\n+\t  return;\n+\t}\n \n-      max = fold_unary_to_constant (code, TREE_TYPE (expr), vr0.max);\n+      if (is_overflow_infinity (vr0.max))\n+\tmax = positive_overflow_infinity (TREE_TYPE (expr));\n+      else if (vr0.max != TYPE_MIN_VALUE (TREE_TYPE (expr)))\n+\tmax = fold_unary_to_constant (code, TREE_TYPE (expr), vr0.max);\n+      else if (!needs_overflow_infinity (TREE_TYPE (expr)))\n+\tmax = TYPE_MAX_VALUE (TREE_TYPE (expr));\n+      else if (supports_overflow_infinity (TREE_TYPE (expr)))\n+\tmax = positive_overflow_infinity (TREE_TYPE (expr));\n+      else\n+\t{\n+\t  set_value_range_to_varying (vr);\n+\t  return;\n+\t}\n \n       cmp = compare_values (min, max);\n \n@@ -1863,8 +2196,6 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n \t{ \n \t  if (range_includes_zero_p (&vr0))\n \t    {\n-\t      tree type_min_value = TYPE_MIN_VALUE (TREE_TYPE (expr));\n-\n \t      /* Take the lower of the two values.  */\n \t      if (cmp != 1)\n \t\tmax = min;\n@@ -1873,12 +2204,22 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n \t         or ~[-INF + 1, min (abs(MIN), abs(MAX))] when\n \t\t flag_wrapv is set and the original anti-range doesn't include\n \t         TYPE_MIN_VALUE, remember -TYPE_MIN_VALUE = TYPE_MIN_VALUE.  */\n-\t      min = ((TYPE_OVERFLOW_WRAPS (TREE_TYPE (expr))\n-\t\t      && vr0.min != type_min_value)\n-\t\t     ? int_const_binop (PLUS_EXPR,\n-\t\t\t\t\ttype_min_value,\n-\t\t\t\t\tinteger_one_node, 0)\n-\t\t     : type_min_value);\n+\t      if (TYPE_OVERFLOW_WRAPS (TREE_TYPE (expr)))\n+\t\t{\n+\t\t  tree type_min_value = TYPE_MIN_VALUE (TREE_TYPE (expr));\n+\n+\t\t  min = (vr0.min != type_min_value\n+\t\t\t ? int_const_binop (PLUS_EXPR, type_min_value,\n+\t\t\t\t\t    integer_one_node, 0)\n+\t\t\t : type_min_value);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (overflow_infinity_range_p (&vr0))\n+\t\t    min = negative_overflow_infinity (TREE_TYPE (expr));\n+\t\t  else\n+\t\t    min = TYPE_MIN_VALUE (TREE_TYPE (expr));\n+\t\t}\n \t    }\n \t  else\n \t    {\n@@ -1887,7 +2228,18 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n \t         anti-range.  */\n \t      vr0.type = VR_RANGE;\n \t      min = build_int_cst (TREE_TYPE (expr), 0);\n-\t      max = TYPE_MAX_VALUE (TREE_TYPE (expr));\n+\t      if (needs_overflow_infinity (TREE_TYPE (expr)))\n+\t\t{\n+\t\t  if (supports_overflow_infinity (TREE_TYPE (expr)))\n+\t\t    max = positive_overflow_infinity (TREE_TYPE (expr));\n+\t\t  else\n+\t\t    {\n+\t\t      set_value_range_to_varying (vr);\n+\t\t      return;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tmax = TYPE_MAX_VALUE (TREE_TYPE (expr));\n \t    }\n \t}\n \n@@ -1915,6 +2267,40 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n       /* Otherwise, operate on each end of the range.  */\n       min = fold_unary_to_constant (code, TREE_TYPE (expr), vr0.min);\n       max = fold_unary_to_constant (code, TREE_TYPE (expr), vr0.max);\n+\n+      if (needs_overflow_infinity (TREE_TYPE (expr)))\n+\t{\n+\t  gcc_assert (code != NEGATE_EXPR && code != ABS_EXPR);\n+\t  if (is_overflow_infinity (vr0.min))\n+\t    min = vr0.min;\n+\t  else if (TREE_OVERFLOW (min))\n+\t    {\n+\t      if (supports_overflow_infinity (TREE_TYPE (expr)))\n+\t\tmin = (tree_int_cst_sgn (min) >= 0\n+\t\t       ? positive_overflow_infinity (TREE_TYPE (min))\n+\t\t       : negative_overflow_infinity (TREE_TYPE (min)));\n+\t      else\n+\t\t{\n+\t\t  set_value_range_to_varying (vr);\n+\t\t  return;\n+\t\t}\n+\t    }\n+\n+\t  if (is_overflow_infinity (vr0.max))\n+\t    max = vr0.max;\n+\t  else if (TREE_OVERFLOW (max))\n+\t    {\n+\t      if (supports_overflow_infinity (TREE_TYPE (expr)))\n+\t\tmax = (tree_int_cst_sgn (max) >= 0\n+\t\t       ? positive_overflow_infinity (TREE_TYPE (max))\n+\t\t       : negative_overflow_infinity (TREE_TYPE (max)));\n+\t      else\n+\t\t{\n+\t\t  set_value_range_to_varying (vr);\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t}\n     }\n \n   cmp = compare_values (min, max);\n@@ -1970,8 +2356,15 @@ extract_range_from_cond_expr (value_range_t *vr, tree expr)\n static void\n extract_range_from_comparison (value_range_t *vr, tree expr)\n {\n-  tree val = vrp_evaluate_conditional (expr, false);\n-  if (val)\n+  bool sop = false;\n+  tree val = vrp_evaluate_conditional (expr, false, &sop);\n+\n+  /* A disadvantage of using a special infinity as an overflow\n+     representation is that we lose the ability to record overflow\n+     when we don't have an infinity.  So we have to ignore a result\n+     which relies on overflow.  */\n+\n+  if (val && !is_overflow_infinity (val) && !sop)\n     {\n       /* Since this expression was found on the RHS of an assignment,\n \t its type may be different from _Bool.  Convert VAL to EXPR's\n@@ -2021,10 +2414,14 @@ extract_range_from_expr (value_range_t *vr, tree expr)\n      with range data.  */\n   if (vr->type == VR_VARYING)\n     {\n+      bool sop = false;\n+\n       if (INTEGRAL_TYPE_P (TREE_TYPE (expr))\n-\t  && vrp_expr_computes_nonnegative (expr))\n-        set_value_range_to_nonnegative (vr, TREE_TYPE (expr));\n-      else if (vrp_expr_computes_nonzero (expr))\n+\t  && vrp_expr_computes_nonnegative (expr, &sop))\n+\tset_value_range_to_nonnegative (vr, TREE_TYPE (expr),\n+\t\t\t\t\tsop || is_overflow_infinity (expr));\n+      else if (vrp_expr_computes_nonzero (expr, &sop)\n+\t       && !sop)\n         set_value_range_to_nonnull (vr, TREE_TYPE (expr));\n     }\n }\n@@ -2070,6 +2467,11 @@ adjust_range_with_scev (value_range_t *vr, struct loop *loop, tree stmt,\n \t\t\t\ttrue))\n     return;\n \n+  /* We use TYPE_MIN_VALUE and TYPE_MAX_VALUE here instead of\n+     negative_overflow_infinity and positive_overflow_infinity,\n+     because we have concluded that the loop probably does not\n+     wrap.  */\n+\n   type = TREE_TYPE (var);\n   if (POINTER_TYPE_P (type) || !TYPE_MIN_VALUE (type))\n     tmin = lower_bound_in_type (type, type);\n@@ -2149,11 +2551,15 @@ adjust_range_with_scev (value_range_t *vr, struct loop *loop, tree stmt,\n    - Return BOOLEAN_FALSE_NODE if the comparison always returns false.\n \n    - Return NULL_TREE if it is not always possible to determine the\n-     value of the comparison.  */\n+     value of the comparison.\n+\n+   Also set *STRICT_OVERFLOW_P to indicate whether a range with an\n+   overflow infinity was used in the test.  */\n \n \n static tree\n-compare_ranges (enum tree_code comp, value_range_t *vr0, value_range_t *vr1)\n+compare_ranges (enum tree_code comp, value_range_t *vr0, value_range_t *vr1,\n+\t\tbool *strict_overflow_p)\n {\n   /* VARYING or UNDEFINED ranges cannot be compared.  */\n   if (vr0->type == VR_VARYING\n@@ -2189,8 +2595,8 @@ compare_ranges (enum tree_code comp, value_range_t *vr0, value_range_t *vr1)\n \n       gcc_assert (comp == NE_EXPR || comp == EQ_EXPR);\n \n-      if (compare_values (vr0->min, vr1->min) == 0\n-\t  && compare_values (vr0->max, vr1->max) == 0)\n+      if (compare_values_warnv (vr0->min, vr1->min, strict_overflow_p) == 0\n+\t  && compare_values_warnv (vr0->max, vr1->max, strict_overflow_p) == 0)\n \treturn (comp == NE_EXPR) ? boolean_true_node : boolean_false_node;\n \n       return NULL_TREE;\n@@ -2211,19 +2617,23 @@ compare_ranges (enum tree_code comp, value_range_t *vr0, value_range_t *vr1)\n     {\n       /* Equality may only be computed if both ranges represent\n \t exactly one value.  */\n-      if (compare_values (vr0->min, vr0->max) == 0\n-\t  && compare_values (vr1->min, vr1->max) == 0)\n+      if (compare_values_warnv (vr0->min, vr0->max, strict_overflow_p) == 0\n+\t  && compare_values_warnv (vr1->min, vr1->max, strict_overflow_p) == 0)\n \t{\n-\t  int cmp_min = compare_values (vr0->min, vr1->min);\n-\t  int cmp_max = compare_values (vr0->max, vr1->max);\n+\t  int cmp_min = compare_values_warnv (vr0->min, vr1->min,\n+\t\t\t\t\t      strict_overflow_p);\n+\t  int cmp_max = compare_values_warnv (vr0->max, vr1->max,\n+\t\t\t\t\t      strict_overflow_p);\n \t  if (cmp_min == 0 && cmp_max == 0)\n \t    return boolean_true_node;\n \t  else if (cmp_min != -2 && cmp_max != -2)\n \t    return boolean_false_node;\n \t}\n       /* If [V0_MIN, V1_MAX] < [V1_MIN, V1_MAX] then V0 != V1.  */\n-      else if (compare_values (vr0->min, vr1->max) == 1\n-\t       || compare_values (vr1->min, vr0->max) == 1)\n+      else if (compare_values_warnv (vr0->min, vr1->max,\n+\t\t\t\t     strict_overflow_p) == 1\n+\t       || compare_values_warnv (vr1->min, vr0->max,\n+\t\t\t\t\tstrict_overflow_p) == 1)\n \treturn boolean_false_node;\n \n       return NULL_TREE;\n@@ -2237,17 +2647,21 @@ compare_ranges (enum tree_code comp, value_range_t *vr0, value_range_t *vr1)\n \t make sure that both comparisons yield similar results to\n \t avoid comparing values that cannot be compared at\n \t compile-time.  */\n-      cmp1 = compare_values (vr0->max, vr1->min);\n-      cmp2 = compare_values (vr0->min, vr1->max);\n+      cmp1 = compare_values_warnv (vr0->max, vr1->min, strict_overflow_p);\n+      cmp2 = compare_values_warnv (vr0->min, vr1->max, strict_overflow_p);\n       if ((cmp1 == -1 && cmp2 == -1) || (cmp1 == 1 && cmp2 == 1))\n \treturn boolean_true_node;\n \n       /* If VR0 and VR1 represent a single value and are identical,\n \t return false.  */\n-      else if (compare_values (vr0->min, vr0->max) == 0\n-\t       && compare_values (vr1->min, vr1->max) == 0\n-\t       && compare_values (vr0->min, vr1->min) == 0\n-\t       && compare_values (vr0->max, vr1->max) == 0)\n+      else if (compare_values_warnv (vr0->min, vr0->max,\n+\t\t\t\t     strict_overflow_p) == 0\n+\t       && compare_values_warnv (vr1->min, vr1->max,\n+\t\t\t\t\tstrict_overflow_p) == 0\n+\t       && compare_values_warnv (vr0->min, vr1->min,\n+\t\t\t\t\tstrict_overflow_p) == 0\n+\t       && compare_values_warnv (vr0->max, vr1->max,\n+\t\t\t\t\tstrict_overflow_p) == 0)\n \treturn boolean_false_node;\n \n       /* Otherwise, they may or may not be different.  */\n@@ -2259,16 +2673,26 @@ compare_ranges (enum tree_code comp, value_range_t *vr0, value_range_t *vr1)\n       int tst;\n \n       /* If VR0 is to the left of VR1, return true.  */\n-      tst = compare_values (vr0->max, vr1->min);\n+      tst = compare_values_warnv (vr0->max, vr1->min, strict_overflow_p);\n       if ((comp == LT_EXPR && tst == -1)\n \t  || (comp == LE_EXPR && (tst == -1 || tst == 0)))\n-\treturn boolean_true_node;\n+\t{\n+\t  if (overflow_infinity_range_p (vr0)\n+\t      || overflow_infinity_range_p (vr1))\n+\t    *strict_overflow_p = true;\n+\t  return boolean_true_node;\n+\t}\n \n       /* If VR0 is to the right of VR1, return false.  */\n-      tst = compare_values (vr0->min, vr1->max);\n+      tst = compare_values_warnv (vr0->min, vr1->max, strict_overflow_p);\n       if ((comp == LT_EXPR && (tst == 0 || tst == 1))\n \t  || (comp == LE_EXPR && tst == 1))\n-\treturn boolean_false_node;\n+\t{\n+\t  if (overflow_infinity_range_p (vr0)\n+\t      || overflow_infinity_range_p (vr1))\n+\t    *strict_overflow_p = true;\n+\t  return boolean_false_node;\n+\t}\n \n       /* Otherwise, we don't know.  */\n       return NULL_TREE;\n@@ -2282,10 +2706,13 @@ compare_ranges (enum tree_code comp, value_range_t *vr0, value_range_t *vr1)\n    BOOLEAN_TRUE_NODE if VR COMP VAL always returns true for all the\n    values in VR.  Return BOOLEAN_FALSE_NODE if the comparison\n    always returns false.  Return NULL_TREE if it is not always\n-   possible to determine the value of the comparison.  */\n+   possible to determine the value of the comparison.  Also set\n+   *STRICT_OVERFLOW_P to indicate whether a range with an overflow\n+   infinity was used in the test.  */\n \n static tree\n-compare_range_with_value (enum tree_code comp, value_range_t *vr, tree val)\n+compare_range_with_value (enum tree_code comp, value_range_t *vr, tree val,\n+\t\t\t  bool *strict_overflow_p)\n {\n   if (vr->type == VR_VARYING || vr->type == VR_UNDEFINED)\n     return NULL_TREE;\n@@ -2312,31 +2739,31 @@ compare_range_with_value (enum tree_code comp, value_range_t *vr, tree val)\n     {\n       /* EQ_EXPR may only be computed if VR represents exactly\n \t one value.  */\n-      if (compare_values (vr->min, vr->max) == 0)\n+      if (compare_values_warnv (vr->min, vr->max, strict_overflow_p) == 0)\n \t{\n-\t  int cmp = compare_values (vr->min, val);\n+\t  int cmp = compare_values_warnv (vr->min, val, strict_overflow_p);\n \t  if (cmp == 0)\n \t    return boolean_true_node;\n \t  else if (cmp == -1 || cmp == 1 || cmp == 2)\n \t    return boolean_false_node;\n \t}\n-      else if (compare_values (val, vr->min) == -1\n-\t       || compare_values (vr->max, val) == -1)\n+      else if (compare_values_warnv (val, vr->min, strict_overflow_p) == -1\n+\t       || compare_values_warnv (vr->max, val, strict_overflow_p) == -1)\n \treturn boolean_false_node;\n \n       return NULL_TREE;\n     }\n   else if (comp == NE_EXPR)\n     {\n       /* If VAL is not inside VR, then they are always different.  */\n-      if (compare_values (vr->max, val) == -1\n-\t  || compare_values (vr->min, val) == 1)\n+      if (compare_values_warnv (vr->max, val, strict_overflow_p) == -1\n+\t  || compare_values_warnv (vr->min, val, strict_overflow_p) == 1)\n \treturn boolean_true_node;\n \n       /* If VR represents exactly one value equal to VAL, then return\n \t false.  */\n-      if (compare_values (vr->min, vr->max) == 0\n-\t  && compare_values (vr->min, val) == 0)\n+      if (compare_values_warnv (vr->min, vr->max, strict_overflow_p) == 0\n+\t  && compare_values_warnv (vr->min, val, strict_overflow_p) == 0)\n \treturn boolean_false_node;\n \n       /* Otherwise, they may or may not be different.  */\n@@ -2347,16 +2774,24 @@ compare_range_with_value (enum tree_code comp, value_range_t *vr, tree val)\n       int tst;\n \n       /* If VR is to the left of VAL, return true.  */\n-      tst = compare_values (vr->max, val);\n+      tst = compare_values_warnv (vr->max, val, strict_overflow_p);\n       if ((comp == LT_EXPR && tst == -1)\n \t  || (comp == LE_EXPR && (tst == -1 || tst == 0)))\n-\treturn boolean_true_node;\n+\t{\n+\t  if (overflow_infinity_range_p (vr))\n+\t    *strict_overflow_p = true;\n+\t  return boolean_true_node;\n+\t}\n \n       /* If VR is to the right of VAL, return false.  */\n-      tst = compare_values (vr->min, val);\n+      tst = compare_values_warnv (vr->min, val, strict_overflow_p);\n       if ((comp == LT_EXPR && (tst == 0 || tst == 1))\n \t  || (comp == LE_EXPR && tst == 1))\n-\treturn boolean_false_node;\n+\t{\n+\t  if (overflow_infinity_range_p (vr))\n+\t    *strict_overflow_p = true;\n+\t  return boolean_false_node;\n+\t}\n \n       /* Otherwise, we don't know.  */\n       return NULL_TREE;\n@@ -2366,16 +2801,24 @@ compare_range_with_value (enum tree_code comp, value_range_t *vr, tree val)\n       int tst;\n \n       /* If VR is to the right of VAL, return true.  */\n-      tst = compare_values (vr->min, val);\n+      tst = compare_values_warnv (vr->min, val, strict_overflow_p);\n       if ((comp == GT_EXPR && tst == 1)\n \t  || (comp == GE_EXPR && (tst == 0 || tst == 1)))\n-\treturn boolean_true_node;\n+\t{\n+\t  if (overflow_infinity_range_p (vr))\n+\t    *strict_overflow_p = true;\n+\t  return boolean_true_node;\n+\t}\n \n       /* If VR is to the left of VAL, return false.  */\n-      tst = compare_values (vr->max, val);\n+      tst = compare_values_warnv (vr->max, val, strict_overflow_p);\n       if ((comp == GT_EXPR && (tst == -1 || tst == 0))\n \t  || (comp == GE_EXPR && tst == -1))\n-\treturn boolean_false_node;\n+\t{\n+\t  if (overflow_infinity_range_p (vr))\n+\t    *strict_overflow_p = true;\n+\t  return boolean_false_node;\n+\t}\n \n       /* Otherwise, we don't know.  */\n       return NULL_TREE;\n@@ -2414,6 +2857,9 @@ dump_value_range (FILE *file, value_range_t *vr)\n \t  && !TYPE_UNSIGNED (type)\n \t  && vr->min == TYPE_MIN_VALUE (type))\n \tfprintf (file, \"-INF\");\n+      else if (needs_overflow_infinity (type)\n+\t       && is_negative_overflow_infinity (vr->min))\n+\tfprintf (file, \"-INF(OVF)\");\n       else\n \tprint_generic_expr (file, vr->min, 0);\n \n@@ -2422,6 +2868,9 @@ dump_value_range (FILE *file, value_range_t *vr)\n       if (INTEGRAL_TYPE_P (type)\n \t  && vr->max == TYPE_MAX_VALUE (type))\n \tfprintf (file, \"+INF\");\n+      else if (needs_overflow_infinity (type)\n+\t       && is_positive_overflow_infinity (vr->max))\n+\tfprintf (file, \"+INF(OVF)\");\n       else\n \tprint_generic_expr (file, vr->max, 0);\n \n@@ -3871,15 +4320,18 @@ vrp_visit_assignment (tree stmt, tree *output_p)\n \n /* Compare all the value ranges for names equivalent to VAR with VAL\n    using comparison code COMP.  Return the same value returned by\n-   compare_range_with_value.  */\n+   compare_range_with_value, including the setting of\n+   *STRICT_OVERFLOW_P.  */\n \n static tree\n-compare_name_with_value (enum tree_code comp, tree var, tree val)\n+compare_name_with_value (enum tree_code comp, tree var, tree val,\n+\t\t\t bool *strict_overflow_p)\n {\n   bitmap_iterator bi;\n   unsigned i;\n   bitmap e;\n   tree retval, t;\n+  int used_strict_overflow;\n   \n   t = retval = NULL_TREE;\n \n@@ -3891,8 +4343,14 @@ compare_name_with_value (enum tree_code comp, tree var, tree val)\n      the body of the loop just to check VAR's value range).  */\n   bitmap_set_bit (e, SSA_NAME_VERSION (var));\n \n+  /* Start at -1.  Set it to 0 if we do a comparison without relying\n+     on overflow, or 1 if all comparisons rely on overflow.  */\n+  used_strict_overflow = -1;\n+\n   EXECUTE_IF_SET_IN_BITMAP (e, 0, i, bi)\n     {\n+      bool sop;\n+\n       value_range_t equiv_vr = *(vr_value[i]);\n \n       /* If name N_i does not have a valid range, use N_i as its own\n@@ -3905,7 +4363,8 @@ compare_name_with_value (enum tree_code comp, tree var, tree val)\n \t  equiv_vr.max = ssa_name (i);\n \t}\n \n-      t = compare_range_with_value (comp, &equiv_vr, val);\n+      sop = false;\n+      t = compare_range_with_value (comp, &equiv_vr, val, &sop);\n       if (t)\n \t{\n \t  /* If we get different answers from different members\n@@ -3919,14 +4378,23 @@ compare_name_with_value (enum tree_code comp, tree var, tree val)\n \t      break;\n \t    }\n \t  retval = t;\n+\n+\t  if (!sop)\n+\t    used_strict_overflow = 0;\n+\t  else if (used_strict_overflow < 0)\n+\t    used_strict_overflow = 1;\n \t}\n     }\n \n   /* Remove VAR from its own equivalence set.  */\n   bitmap_clear_bit (e, SSA_NAME_VERSION (var));\n \n   if (retval)\n-    return retval;\n+    {\n+      if (used_strict_overflow > 0)\n+\t*strict_overflow_p = true;\n+      return retval;\n+    }\n \n   /* We couldn't find a non-NULL value for the predicate.  */\n   return NULL_TREE;\n@@ -3936,15 +4404,19 @@ compare_name_with_value (enum tree_code comp, tree var, tree val)\n /* Given a comparison code COMP and names N1 and N2, compare all the\n    ranges equivalent to N1 against all the ranges equivalent to N2\n    to determine the value of N1 COMP N2.  Return the same value\n-   returned by compare_ranges.  */\n+   returned by compare_ranges.  Set *STRICT_OVERFLOW_P to indicate\n+   whether we relied on an overflow infinity in the comparison.  */\n+\n \n static tree\n-compare_names (enum tree_code comp, tree n1, tree n2)\n+compare_names (enum tree_code comp, tree n1, tree n2,\n+\t       bool *strict_overflow_p)\n {\n   tree t, retval;\n   bitmap e1, e2;\n   bitmap_iterator bi1, bi2;\n   unsigned i1, i2;\n+  int used_strict_overflow;\n \n   /* Compare the ranges of every name equivalent to N1 against the\n      ranges of every name equivalent to N2.  */\n@@ -3969,6 +4441,10 @@ compare_names (enum tree_code comp, tree n1, tree n2)\n \t     : boolean_false_node;\n     }\n \n+  /* Start at -1.  Set it to 0 if we do a comparison without relying\n+     on overflow, or 1 if all comparisons rely on overflow.  */\n+  used_strict_overflow = -1;\n+\n   /* Otherwise, compare all the equivalent ranges.  First, add N1 and\n      N2 to their own set of equivalences to avoid duplicating the body\n      of the loop just to check N1 and N2 ranges.  */\n@@ -3987,6 +4463,8 @@ compare_names (enum tree_code comp, tree n1, tree n2)\n       t = retval = NULL_TREE;\n       EXECUTE_IF_SET_IN_BITMAP (e2, 0, i2, bi2)\n \t{\n+\t  bool sop;\n+\n \t  value_range_t vr2 = *(vr_value[i2]);\n \n \t  if (vr2.type == VR_VARYING || vr2.type == VR_UNDEFINED)\n@@ -3996,7 +4474,7 @@ compare_names (enum tree_code comp, tree n1, tree n2)\n \t      vr2.max = ssa_name (i2);\n \t    }\n \n-\t  t = compare_ranges (comp, &vr1, &vr2);\n+\t  t = compare_ranges (comp, &vr1, &vr2, &sop);\n \t  if (t)\n \t    {\n \t      /* If we get different answers from different members\n@@ -4011,13 +4489,20 @@ compare_names (enum tree_code comp, tree n1, tree n2)\n \t\t  return NULL_TREE;\n \t\t}\n \t      retval = t;\n+\n+\t      if (!sop)\n+\t\tused_strict_overflow = 0;\n+\t      else if (used_strict_overflow < 0)\n+\t\tused_strict_overflow = 1;\n \t    }\n \t}\n \n       if (retval)\n \t{\n \t  bitmap_clear_bit (e1, SSA_NAME_VERSION (n1));\n \t  bitmap_clear_bit (e2, SSA_NAME_VERSION (n2));\n+\t  if (used_strict_overflow > 0)\n+\t    *strict_overflow_p = true;\n \t  return retval;\n \t}\n     }\n@@ -4039,10 +4524,13 @@ compare_names (enum tree_code comp, tree n1, tree n2)\n    If USE_EQUIV_P is true, the ranges of all the names equivalent with\n    the operands in COND are used when trying to compute its value.\n    This is only used during final substitution.  During propagation,\n-   we only check the range of each variable and not its equivalents.  */\n+   we only check the range of each variable and not its equivalents.\n+\n+   Set *STRICT_OVERFLOW_P to indicate whether we relied on an overflow\n+   infinity to produce the result.  */\n \n tree\n-vrp_evaluate_conditional (tree cond, bool use_equiv_p)\n+vrp_evaluate_conditional (tree cond, bool use_equiv_p, bool *strict_overflow_p)\n {\n   gcc_assert (TREE_CODE (cond) == SSA_NAME\n               || TREE_CODE_CLASS (TREE_CODE (cond)) == tcc_comparison);\n@@ -4053,11 +4541,13 @@ vrp_evaluate_conditional (tree cond, bool use_equiv_p)\n       tree retval;\n \n       if (use_equiv_p)\n-\tretval = compare_name_with_value (NE_EXPR, cond, boolean_false_node);\n+\tretval = compare_name_with_value (NE_EXPR, cond, boolean_false_node,\n+\t\t\t\t\t  strict_overflow_p);\n       else\n \t{\n \t  value_range_t *vr = get_value_range (cond);\n-\t  retval = compare_range_with_value (NE_EXPR, vr, boolean_false_node);\n+\t  retval = compare_range_with_value (NE_EXPR, vr, boolean_false_node,\n+\t\t\t\t\t     strict_overflow_p);\n \t}\n \n       /* If COND has a known boolean range, return it.  */\n@@ -4083,12 +4573,15 @@ vrp_evaluate_conditional (tree cond, bool use_equiv_p)\n       if (use_equiv_p)\n \t{\n \t  if (TREE_CODE (op0) == SSA_NAME && TREE_CODE (op1) == SSA_NAME)\n-\t    return compare_names (TREE_CODE (cond), op0, op1);\n+\t    return compare_names (TREE_CODE (cond), op0, op1,\n+\t\t\t\t  strict_overflow_p);\n \t  else if (TREE_CODE (op0) == SSA_NAME)\n-\t    return compare_name_with_value (TREE_CODE (cond), op0, op1);\n+\t    return compare_name_with_value (TREE_CODE (cond), op0, op1,\n+\t\t\t\t\t    strict_overflow_p);\n \t  else if (TREE_CODE (op1) == SSA_NAME)\n-\t    return compare_name_with_value (\n-\t\t    swap_tree_comparison (TREE_CODE (cond)), op1, op0);\n+\t    return (compare_name_with_value\n+\t\t    (swap_tree_comparison (TREE_CODE (cond)), op1, op0,\n+\t\t     strict_overflow_p));\n \t}\n       else\n \t{\n@@ -4098,12 +4591,15 @@ vrp_evaluate_conditional (tree cond, bool use_equiv_p)\n \t  vr1 = (TREE_CODE (op1) == SSA_NAME) ? get_value_range (op1) : NULL;\n \n \t  if (vr0 && vr1)\n-\t    return compare_ranges (TREE_CODE (cond), vr0, vr1);\n+\t    return compare_ranges (TREE_CODE (cond), vr0, vr1,\n+\t\t\t\t   strict_overflow_p);\n \t  else if (vr0 && vr1 == NULL)\n-\t    return compare_range_with_value (TREE_CODE (cond), vr0, op1);\n+\t    return compare_range_with_value (TREE_CODE (cond), vr0, op1,\n+\t\t\t\t\t     strict_overflow_p);\n \t  else if (vr0 == NULL && vr1)\n-\t    return compare_range_with_value (\n-\t\t    swap_tree_comparison (TREE_CODE (cond)), vr1, op0);\n+\t    return (compare_range_with_value\n+\t\t    (swap_tree_comparison (TREE_CODE (cond)), vr1, op0,\n+\t\t     strict_overflow_p));\n \t}\n     }\n \n@@ -4121,6 +4617,7 @@ static enum ssa_prop_result\n vrp_visit_cond_stmt (tree stmt, edge *taken_edge_p)\n {\n   tree cond, val;\n+  bool sop;\n \n   *taken_edge_p = NULL;\n \n@@ -4193,9 +4690,21 @@ vrp_visit_cond_stmt (tree stmt, edge *taken_edge_p)\n      additional checking.  Testing on several code bases (GCC, DLV,\n      MICO, TRAMP3D and SPEC2000) showed that doing this results in\n      4 more predicates folded in SPEC.  */\n-  val = vrp_evaluate_conditional (cond, false);\n+  sop = false;\n+  val = vrp_evaluate_conditional (cond, false, &sop);\n   if (val)\n-    *taken_edge_p = find_taken_edge (bb_for_stmt (stmt), val);\n+    {\n+      if (!sop)\n+\t*taken_edge_p = find_taken_edge (bb_for_stmt (stmt), val);\n+      else\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"\\nIgnoring predicate evaluation because \"\n+\t\t     \"it assumes that signed overflow is undefined\");\n+\t  val = NULL_TREE;\n+\t}\n+    }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -4487,18 +4996,42 @@ vrp_visit_phi_node (tree phi)\n \t     other case to avoid infinite bouncing between different\n \t     minimums.  */\n \t  if (cmp_min > 0 || cmp_min < 0)\n-\t    vr_result.min = TYPE_MIN_VALUE (TREE_TYPE (vr_result.min));\n+\t    {\n+\t      /* If we will end up with a (-INF, +INF) range, set it\n+\t\t to VARYING.  */\n+\t      if (is_positive_overflow_infinity (vr_result.max)\n+\t\t  || (vr_result.max\n+\t\t      == TYPE_MAX_VALUE (TREE_TYPE (vr_result.max))))\n+\t\tgoto varying;\n+\n+\t      if (!needs_overflow_infinity (TREE_TYPE (vr_result.min)))\n+\t\tvr_result.min = TYPE_MIN_VALUE (TREE_TYPE (vr_result.min));\n+\t      else if (supports_overflow_infinity (TREE_TYPE (vr_result.min)))\n+\t\tvr_result.min =\n+\t\t  negative_overflow_infinity (TREE_TYPE (vr_result.min));\n+\t      else\n+\t\tgoto varying;\n+\t    }\n \n \t  /* Similarly, if the new maximum is smaller or larger than\n \t     the previous one, go all the way to +INF.  */\n \t  if (cmp_max < 0 || cmp_max > 0)\n-\t    vr_result.max = TYPE_MAX_VALUE (TREE_TYPE (vr_result.max));\n-\n-\t  /* If we ended up with a (-INF, +INF) range, set it to\n-\t     VARYING.  */\n-\t  if (vr_result.min == TYPE_MIN_VALUE (TREE_TYPE (vr_result.min))\n-\t      && vr_result.max == TYPE_MAX_VALUE (TREE_TYPE (vr_result.max)))\n-\t    goto varying;\n+\t    {\n+\t      /* If we will end up with a (-INF, +INF) range, set it\n+\t\t to VARYING.  */\n+\t      if (is_negative_overflow_infinity (vr_result.min)\n+\t\t  || (vr_result.min\n+\t\t      == TYPE_MIN_VALUE (TREE_TYPE (vr_result.min))))\n+\t\tgoto varying;\n+\n+\t      if (!needs_overflow_infinity (TREE_TYPE (vr_result.max)))\n+\t\tvr_result.max = TYPE_MAX_VALUE (TREE_TYPE (vr_result.max));\n+\t      else if (supports_overflow_infinity (TREE_TYPE (vr_result.max)))\n+\t\tvr_result.max =\n+\t\t  positive_overflow_infinity (TREE_TYPE (vr_result.max));\n+\t      else\n+\t\tgoto varying;\n+\t    }\n \t}\n     }\n \n@@ -4533,7 +5066,9 @@ simplify_div_or_mod_using_ranges (tree stmt, tree rhs, enum tree_code rhs_code)\n     }\n   else\n     {\n-      val = compare_range_with_value (GT_EXPR, vr, integer_zero_node);\n+      bool sop = false;\n+\n+      val = compare_range_with_value (GT_EXPR, vr, integer_zero_node, &sop);\n     }\n \n   if (val && integer_onep (val))\n@@ -4578,10 +5113,14 @@ simplify_abs_using_ranges (tree stmt, tree rhs)\n     }\n   else if (vr)\n     {\n-      val = compare_range_with_value (LE_EXPR, vr, integer_zero_node);\n+      bool sop = false;\n+\n+      val = compare_range_with_value (LE_EXPR, vr, integer_zero_node, &sop);\n       if (!val)\n \t{\n-\t  val = compare_range_with_value (GE_EXPR, vr, integer_zero_node);\n+\t  sop = false;\n+\t  val = compare_range_with_value (GE_EXPR, vr, integer_zero_node,\n+\t\t\t\t\t  &sop);\n \n \t  if (val)\n \t    {\n@@ -4625,21 +5164,25 @@ test_for_singularity (enum tree_code cond_code, tree op0,\n      the conditional as it was written.  */\n   if (cond_code == LE_EXPR || cond_code == LT_EXPR)\n     {\n+      /* This should not be negative infinity; there is no overflow\n+\t here.  */\n       min = TYPE_MIN_VALUE (TREE_TYPE (op0));\n \n       max = op1;\n-      if (cond_code == LT_EXPR)\n+      if (cond_code == LT_EXPR && !is_overflow_infinity (max))\n \t{\n \t  tree one = build_int_cst (TREE_TYPE (op0), 1);\n \t  max = fold_build2 (MINUS_EXPR, TREE_TYPE (op0), max, one);\n \t}\n     }\n   else if (cond_code == GE_EXPR || cond_code == GT_EXPR)\n     {\n+      /* This should not be positive infinity; there is no overflow\n+\t here.  */\n       max = TYPE_MAX_VALUE (TREE_TYPE (op0));\n \n       min = op1;\n-      if (cond_code == GT_EXPR)\n+      if (cond_code == GT_EXPR && !is_overflow_infinity (min))\n \t{\n \t  tree one = build_int_cst (TREE_TYPE (op0), 1);\n \t  min = fold_build2 (PLUS_EXPR, TREE_TYPE (op0), min, one);\n@@ -4790,13 +5333,16 @@ static VEC(tree,heap) *stack;\n static tree\n simplify_stmt_for_jump_threading (tree stmt)\n {\n+  bool sop;\n+\n   /* We only use VRP information to simplify conditionals.  This is\n      overly conservative, but it's unclear if doing more would be\n      worth the compile time cost.  */\n   if (TREE_CODE (stmt) != COND_EXPR)\n     return NULL;\n \n-  return vrp_evaluate_conditional (COND_EXPR_COND (stmt), true);\n+  sop = false;\n+  return vrp_evaluate_conditional (COND_EXPR_COND (stmt), true, &sop);\n }\n \n /* Blocks which have more than one predecessor and more than"}]}