{"sha": "d5363590597572228d4e0d0ae13f3469176ceb14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDUzNjM1OTA1OTc1NzIyMjhkNGUwZDBhZTEzZjM0NjkxNzZjZWIxNA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-12-14T15:41:54Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-12-14T15:41:54Z"}, "message": "libgo: Update to weekly.2011-12-06.\n\nFrom-SVN: r182338", "tree": {"sha": "e3de46cbc89d82ca1f49843fe2e1e670db67795e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3de46cbc89d82ca1f49843fe2e1e670db67795e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5363590597572228d4e0d0ae13f3469176ceb14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5363590597572228d4e0d0ae13f3469176ceb14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5363590597572228d4e0d0ae13f3469176ceb14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5363590597572228d4e0d0ae13f3469176ceb14/comments", "author": null, "committer": null, "parents": [{"sha": "ef0d4c4d9937276c8ff818ecb0b92925d322d3bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef0d4c4d9937276c8ff818ecb0b92925d322d3bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef0d4c4d9937276c8ff818ecb0b92925d322d3bd"}], "stats": {"total": 2746, "additions": 1428, "deletions": 1318}, "files": [{"sha": "bf401bf3048275994c2519f89b9f1929e57b3ff7", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug120.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug120.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug120.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug120.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -41,16 +41,16 @@ func main() {\n \tok := true\n \tfor i := 0; i < len(tests); i++ {\n \t\tt := tests[i]\n-\t\tv := strconv.Ftoa64(t.f, 'g', -1)\n+\t\tv := strconv.FormatFloat(t.f, 'g', -1, 64)\n \t\tif v != t.out {\n \t\t\tprintln(\"Bad float64 const:\", t.in, \"want\", t.out, \"got\", v)\n-\t\t\tx, err := strconv.Atof64(t.out)\n+\t\t\tx, err := strconv.ParseFloat(t.out, 64)\n \t\t\tif err != nil {\n \t\t\t\tprintln(\"bug120: strconv.Atof64\", t.out)\n \t\t\t\tpanic(\"fail\")\n \t\t\t}\n-\t\t\tprintln(\"\\twant exact:\", strconv.Ftoa64(x, 'g', 1000))\n-\t\t\tprintln(\"\\tgot exact: \", strconv.Ftoa64(t.f, 'g', 1000))\n+\t\t\tprintln(\"\\twant exact:\", strconv.FormatFloat(x, 'g', 1000, 64))\n+\t\t\tprintln(\"\\tgot exact: \", strconv.FormatFloat(t.f, 'g', 1000, 64))\n \t\t\tok = false\n \t\t}\n \t}"}, {"sha": "91dc89f77a5b85e2b91628f0879215124c46d23b", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug260.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug260.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug260.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug260.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -24,8 +24,8 @@ func main() {\n \treport := len(os.Args) > 1\n \tstatus := 0\n \tvar b1 [10]T1\n-\ta0, _ := strconv.Btoui64(fmt.Sprintf(\"%p\", &b1[0])[2:], 16)\n-\ta1, _ := strconv.Btoui64(fmt.Sprintf(\"%p\", &b1[1])[2:], 16)\n+\ta0, _ := strconv.ParseUint(fmt.Sprintf(\"%p\", &b1[0])[2:], 16, 64)\n+\ta1, _ := strconv.ParseUint(fmt.Sprintf(\"%p\", &b1[1])[2:], 16, 64)\n \tif a1 != a0+1 {\n \t\tfmt.Println(\"FAIL\")\n \t\tif report {\n@@ -34,8 +34,8 @@ func main() {\n \t\tstatus = 1\n \t}\n \tvar b2 [10]T2\n-\ta0, _ = strconv.Btoui64(fmt.Sprintf(\"%p\", &b2[0])[2:], 16)\n-\ta1, _ = strconv.Btoui64(fmt.Sprintf(\"%p\", &b2[1])[2:], 16)\n+\ta0, _ = strconv.ParseUint(fmt.Sprintf(\"%p\", &b2[0])[2:], 16, 64)\n+\ta1, _ = strconv.ParseUint(fmt.Sprintf(\"%p\", &b2[1])[2:], 16, 64)\n \tif a1 != a0+2 {\n \t\tif status == 0 {\n \t\t\tfmt.Println(\"FAIL\")\n@@ -46,8 +46,8 @@ func main() {\n \t\t}\n \t}\n \tvar b4 [10]T4\n-\ta0, _ = strconv.Btoui64(fmt.Sprintf(\"%p\", &b4[0])[2:], 16)\n-\ta1, _ = strconv.Btoui64(fmt.Sprintf(\"%p\", &b4[1])[2:], 16)\n+\ta0, _ = strconv.ParseUint(fmt.Sprintf(\"%p\", &b4[0])[2:], 16, 64)\n+\ta1, _ = strconv.ParseUint(fmt.Sprintf(\"%p\", &b4[1])[2:], 16, 64)\n \tif a1 != a0+4 {\n \t\tif status == 0 {\n \t\t\tfmt.Println(\"FAIL\")"}, {"sha": "0bcb056063c206e52d9fd0b85b05a1f5bb2fd3e8", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -1,4 +1,4 @@\n-0beb796b4ef8\n+0c39eee85b0d\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "13fe2700f9bf1603b80fe40c2dc91b32cbbbc4cd", "filename": "libgo/go/archive/tar/reader.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -80,7 +80,7 @@ func (tr *Reader) octal(b []byte) int64 {\n \tfor len(b) > 0 && (b[len(b)-1] == ' ' || b[len(b)-1] == '\\x00') {\n \t\tb = b[0 : len(b)-1]\n \t}\n-\tx, err := strconv.Btoui64(cString(b), 8)\n+\tx, err := strconv.ParseUint(cString(b), 8, 64)\n \tif err != nil {\n \t\ttr.err = err\n \t}"}, {"sha": "5829d03faa63072e7c5a638796b33aed957bc213", "filename": "libgo/go/archive/tar/reader_test.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -24,7 +24,7 @@ type untarTest struct {\n var gnuTarTest = &untarTest{\n \tfile: \"testdata/gnu.tar\",\n \theaders: []*Header{\n-\t\t&Header{\n+\t\t{\n \t\t\tName:     \"small.txt\",\n \t\t\tMode:     0640,\n \t\t\tUid:      73025,\n@@ -35,7 +35,7 @@ var gnuTarTest = &untarTest{\n \t\t\tUname:    \"dsymonds\",\n \t\t\tGname:    \"eng\",\n \t\t},\n-\t\t&Header{\n+\t\t{\n \t\t\tName:     \"small2.txt\",\n \t\t\tMode:     0640,\n \t\t\tUid:      73025,\n@@ -55,10 +55,10 @@ var gnuTarTest = &untarTest{\n \n var untarTests = []*untarTest{\n \tgnuTarTest,\n-\t&untarTest{\n+\t{\n \t\tfile: \"testdata/star.tar\",\n \t\theaders: []*Header{\n-\t\t\t&Header{\n+\t\t\t{\n \t\t\t\tName:       \"small.txt\",\n \t\t\t\tMode:       0640,\n \t\t\t\tUid:        73025,\n@@ -71,7 +71,7 @@ var untarTests = []*untarTest{\n \t\t\t\tAccessTime: time.Unix(1244592783, 0),\n \t\t\t\tChangeTime: time.Unix(1244592783, 0),\n \t\t\t},\n-\t\t\t&Header{\n+\t\t\t{\n \t\t\t\tName:       \"small2.txt\",\n \t\t\t\tMode:       0640,\n \t\t\t\tUid:        73025,\n@@ -86,10 +86,10 @@ var untarTests = []*untarTest{\n \t\t\t},\n \t\t},\n \t},\n-\t&untarTest{\n+\t{\n \t\tfile: \"testdata/v7.tar\",\n \t\theaders: []*Header{\n-\t\t\t&Header{\n+\t\t\t{\n \t\t\t\tName:     \"small.txt\",\n \t\t\t\tMode:     0444,\n \t\t\t\tUid:      73025,\n@@ -98,7 +98,7 @@ var untarTests = []*untarTest{\n \t\t\t\tModTime:  time.Unix(1244593104, 0),\n \t\t\t\tTypeflag: '\\x00',\n \t\t\t},\n-\t\t\t&Header{\n+\t\t\t{\n \t\t\t\tName:     \"small2.txt\",\n \t\t\t\tMode:     0444,\n \t\t\t\tUid:      73025,"}, {"sha": "d35726bf9d83ba93d2ffb8f8ffa91b02d31e2d76", "filename": "libgo/go/archive/tar/writer.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -79,7 +79,7 @@ func (tw *Writer) cString(b []byte, s string) {\n \n // Encode x as an octal ASCII string and write it into b with leading zeros.\n func (tw *Writer) octal(b []byte, x int64) {\n-\ts := strconv.Itob64(x, 8)\n+\ts := strconv.FormatInt(x, 8)\n \t// leading zeros, but leave room for a NUL.\n \tfor len(s)+1 < len(b) {\n \t\ts = \"0\" + s\n@@ -90,7 +90,7 @@ func (tw *Writer) octal(b []byte, x int64) {\n // Write x into b, either as octal or as binary (GNUtar/star extension).\n func (tw *Writer) numeric(b []byte, x int64) {\n \t// Try octal first.\n-\ts := strconv.Itob64(x, 8)\n+\ts := strconv.FormatInt(x, 8)\n \tif len(s) < len(b) {\n \t\ttw.octal(b, x)\n \t\treturn"}, {"sha": "0b413722dd34da1166a59567f33bfe63436cbbff", "filename": "libgo/go/archive/tar/writer_test.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -29,10 +29,10 @@ var writerTests = []*writerTest{\n \t// tar (GNU tar) 1.26\n \t//   ln -s small.txt link.txt\n \t//   tar -b 1 --format=ustar -c -f writer.tar small.txt small2.txt link.txt\n-\t&writerTest{\n+\t{\n \t\tfile: \"testdata/writer.tar\",\n \t\tentries: []*writerTestEntry{\n-\t\t\t&writerTestEntry{\n+\t\t\t{\n \t\t\t\theader: &Header{\n \t\t\t\t\tName:     \"small.txt\",\n \t\t\t\t\tMode:     0640,\n@@ -46,7 +46,7 @@ var writerTests = []*writerTest{\n \t\t\t\t},\n \t\t\t\tcontents: \"Kilts\",\n \t\t\t},\n-\t\t\t&writerTestEntry{\n+\t\t\t{\n \t\t\t\theader: &Header{\n \t\t\t\t\tName:     \"small2.txt\",\n \t\t\t\t\tMode:     0640,\n@@ -60,7 +60,7 @@ var writerTests = []*writerTest{\n \t\t\t\t},\n \t\t\t\tcontents: \"Google.com\\n\",\n \t\t\t},\n-\t\t\t&writerTestEntry{\n+\t\t\t{\n \t\t\t\theader: &Header{\n \t\t\t\t\tName:     \"link.txt\",\n \t\t\t\t\tMode:     0777,\n@@ -80,10 +80,10 @@ var writerTests = []*writerTest{\n \t// The truncated test file was produced using these commands:\n \t//   dd if=/dev/zero bs=1048576 count=16384 > /tmp/16gig.txt\n \t//   tar -b 1 -c -f- /tmp/16gig.txt | dd bs=512 count=8 > writer-big.tar\n-\t&writerTest{\n+\t{\n \t\tfile: \"testdata/writer-big.tar\",\n \t\tentries: []*writerTestEntry{\n-\t\t\t&writerTestEntry{\n+\t\t\t{\n \t\t\t\theader: &Header{\n \t\t\t\t\tName:     \"tmp/16gig.txt\",\n \t\t\t\t\tMode:     0640,"}, {"sha": "1188103568e16ee17bfb780c8ab241a6c32d3e78", "filename": "libgo/go/archive/zip/writer_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -21,12 +21,12 @@ type WriteTest struct {\n }\n \n var writeTests = []WriteTest{\n-\tWriteTest{\n+\t{\n \t\tName:   \"foo\",\n \t\tData:   []byte(\"Rabbits, guinea pigs, gophers, marsupial rats, and quolls.\"),\n \t\tMethod: Store,\n \t},\n-\tWriteTest{\n+\t{\n \t\tName:   \"bar\",\n \t\tData:   nil, // large data set in the test\n \t\tMethod: Deflate,"}, {"sha": "b35c69a1ccaa6d75c40cbb680db77acab1457a2b", "filename": "libgo/go/compress/bzip2/bit_reader.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbit_reader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbit_reader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbit_reader.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -20,7 +20,7 @@ type bitReader struct {\n \terr  error\n }\n \n-// bitReader needs to read bytes from an io.Reader. We attempt to cast the\n+// bitReader needs to read bytes from an io.Reader. We attempt to convert the\n // given io.Reader to this interface and, if it doesn't already fit, we wrap in\n // a bufio.Reader.\n type byteReader interface {"}, {"sha": "b4876b0f8b3d25da89469df8677bd6e90e39dcd7", "filename": "libgo/go/compress/flate/deflate_test.go", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -30,44 +30,44 @@ type reverseBitsTest struct {\n }\n \n var deflateTests = []*deflateTest{\n-\t&deflateTest{[]byte{}, 0, []byte{1, 0, 0, 255, 255}},\n-\t&deflateTest{[]byte{0x11}, -1, []byte{18, 4, 4, 0, 0, 255, 255}},\n-\t&deflateTest{[]byte{0x11}, DefaultCompression, []byte{18, 4, 4, 0, 0, 255, 255}},\n-\t&deflateTest{[]byte{0x11}, 4, []byte{18, 4, 4, 0, 0, 255, 255}},\n-\n-\t&deflateTest{[]byte{0x11}, 0, []byte{0, 1, 0, 254, 255, 17, 1, 0, 0, 255, 255}},\n-\t&deflateTest{[]byte{0x11, 0x12}, 0, []byte{0, 2, 0, 253, 255, 17, 18, 1, 0, 0, 255, 255}},\n-\t&deflateTest{[]byte{0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11}, 0,\n+\t{[]byte{}, 0, []byte{1, 0, 0, 255, 255}},\n+\t{[]byte{0x11}, -1, []byte{18, 4, 4, 0, 0, 255, 255}},\n+\t{[]byte{0x11}, DefaultCompression, []byte{18, 4, 4, 0, 0, 255, 255}},\n+\t{[]byte{0x11}, 4, []byte{18, 4, 4, 0, 0, 255, 255}},\n+\n+\t{[]byte{0x11}, 0, []byte{0, 1, 0, 254, 255, 17, 1, 0, 0, 255, 255}},\n+\t{[]byte{0x11, 0x12}, 0, []byte{0, 2, 0, 253, 255, 17, 18, 1, 0, 0, 255, 255}},\n+\t{[]byte{0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11}, 0,\n \t\t[]byte{0, 8, 0, 247, 255, 17, 17, 17, 17, 17, 17, 17, 17, 1, 0, 0, 255, 255},\n \t},\n-\t&deflateTest{[]byte{}, 1, []byte{1, 0, 0, 255, 255}},\n-\t&deflateTest{[]byte{0x11}, 1, []byte{18, 4, 4, 0, 0, 255, 255}},\n-\t&deflateTest{[]byte{0x11, 0x12}, 1, []byte{18, 20, 2, 4, 0, 0, 255, 255}},\n-\t&deflateTest{[]byte{0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11}, 1, []byte{18, 132, 2, 64, 0, 0, 0, 255, 255}},\n-\t&deflateTest{[]byte{}, 9, []byte{1, 0, 0, 255, 255}},\n-\t&deflateTest{[]byte{0x11}, 9, []byte{18, 4, 4, 0, 0, 255, 255}},\n-\t&deflateTest{[]byte{0x11, 0x12}, 9, []byte{18, 20, 2, 4, 0, 0, 255, 255}},\n-\t&deflateTest{[]byte{0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11}, 9, []byte{18, 132, 2, 64, 0, 0, 0, 255, 255}},\n+\t{[]byte{}, 1, []byte{1, 0, 0, 255, 255}},\n+\t{[]byte{0x11}, 1, []byte{18, 4, 4, 0, 0, 255, 255}},\n+\t{[]byte{0x11, 0x12}, 1, []byte{18, 20, 2, 4, 0, 0, 255, 255}},\n+\t{[]byte{0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11}, 1, []byte{18, 132, 2, 64, 0, 0, 0, 255, 255}},\n+\t{[]byte{}, 9, []byte{1, 0, 0, 255, 255}},\n+\t{[]byte{0x11}, 9, []byte{18, 4, 4, 0, 0, 255, 255}},\n+\t{[]byte{0x11, 0x12}, 9, []byte{18, 20, 2, 4, 0, 0, 255, 255}},\n+\t{[]byte{0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11}, 9, []byte{18, 132, 2, 64, 0, 0, 0, 255, 255}},\n }\n \n var deflateInflateTests = []*deflateInflateTest{\n-\t&deflateInflateTest{[]byte{}},\n-\t&deflateInflateTest{[]byte{0x11}},\n-\t&deflateInflateTest{[]byte{0x11, 0x12}},\n-\t&deflateInflateTest{[]byte{0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11}},\n-\t&deflateInflateTest{[]byte{0x11, 0x10, 0x13, 0x41, 0x21, 0x21, 0x41, 0x13, 0x87, 0x78, 0x13}},\n-\t&deflateInflateTest{largeDataChunk()},\n+\t{[]byte{}},\n+\t{[]byte{0x11}},\n+\t{[]byte{0x11, 0x12}},\n+\t{[]byte{0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11}},\n+\t{[]byte{0x11, 0x10, 0x13, 0x41, 0x21, 0x21, 0x41, 0x13, 0x87, 0x78, 0x13}},\n+\t{largeDataChunk()},\n }\n \n var reverseBitsTests = []*reverseBitsTest{\n-\t&reverseBitsTest{1, 1, 1},\n-\t&reverseBitsTest{1, 2, 2},\n-\t&reverseBitsTest{1, 3, 4},\n-\t&reverseBitsTest{1, 4, 8},\n-\t&reverseBitsTest{1, 5, 16},\n-\t&reverseBitsTest{17, 5, 17},\n-\t&reverseBitsTest{257, 9, 257},\n-\t&reverseBitsTest{29, 5, 23},\n+\t{1, 1, 1},\n+\t{1, 2, 2},\n+\t{1, 3, 4},\n+\t{1, 4, 8},\n+\t{1, 5, 16},\n+\t{17, 5, 17},\n+\t{257, 9, 257},\n+\t{29, 5, 23},\n }\n \n func largeDataChunk() []byte {"}, {"sha": "94efc90acfa24f5903fd728039ec87ca12ff1f9d", "filename": "libgo/go/compress/flate/flate_test.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcompress%2Fflate%2Fflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcompress%2Fflate%2Fflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fflate_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -52,7 +52,7 @@ type InitDecoderTest struct {\n \n var initDecoderTests = []*InitDecoderTest{\n \t// Example from Connell 1973,\n-\t&InitDecoderTest{\n+\t{\n \t\t[]int{3, 5, 2, 4, 3, 5, 5, 4, 4, 3, 4, 5},\n \t\thuffmanDecoder{\n \t\t\t2, 5,\n@@ -68,7 +68,7 @@ var initDecoderTests = []*InitDecoderTest{\n \t},\n \n \t// Example from RFC 1951 section 3.2.2\n-\t&InitDecoderTest{\n+\t{\n \t\t[]int{2, 1, 3, 3},\n \t\thuffmanDecoder{\n \t\t\t1, 3,\n@@ -80,7 +80,7 @@ var initDecoderTests = []*InitDecoderTest{\n \t},\n \n \t// Second example from RFC 1951 section 3.2.2\n-\t&InitDecoderTest{\n+\t{\n \t\t[]int{3, 3, 3, 3, 3, 2, 4, 4},\n \t\thuffmanDecoder{\n \t\t\t2, 4,\n@@ -92,21 +92,21 @@ var initDecoderTests = []*InitDecoderTest{\n \t},\n \n \t// Static Huffman codes (RFC 1951 section 3.2.6)\n-\t&InitDecoderTest{\n+\t{\n \t\tfixedHuffmanBits[0:],\n \t\tfixedHuffmanDecoder,\n \t\ttrue,\n \t},\n \n \t// Illegal input.\n-\t&InitDecoderTest{\n+\t{\n \t\t[]int{},\n \t\thuffmanDecoder{},\n \t\tfalse,\n \t},\n \n \t// Illegal input.\n-\t&InitDecoderTest{\n+\t{\n \t\t[]int{0, 0, 0, 0, 0, 0, 0},\n \t\thuffmanDecoder{},\n \t\tfalse,"}, {"sha": "8d0b4f9c1e8d8f3f1757cba9d1daee6085b3be3d", "filename": "libgo/go/compress/flate/huffman_bit_writer.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -106,8 +106,8 @@ func newHuffmanBitWriter(w io.Writer) *huffmanBitWriter {\n }\n \n func (err WrongValueError) Error() string {\n-\treturn \"huffmanBitWriter: \" + err.name + \" should belong to [\" + strconv.Itoa64(int64(err.from)) + \";\" +\n-\t\tstrconv.Itoa64(int64(err.to)) + \"] but actual value is \" + strconv.Itoa64(int64(err.value))\n+\treturn \"huffmanBitWriter: \" + err.name + \" should belong to [\" + strconv.FormatInt(int64(err.from), 10) + \";\" +\n+\t\tstrconv.FormatInt(int64(err.to), 10) + \"] but actual value is \" + strconv.FormatInt(int64(err.value), 10)\n }\n \n func (w *huffmanBitWriter) flushBits() {"}, {"sha": "3f2042bfe92fd9f90addc256f7512c338ddcd6bb", "filename": "libgo/go/compress/flate/inflate.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -25,7 +25,7 @@ const (\n type CorruptInputError int64\n \n func (e CorruptInputError) Error() string {\n-\treturn \"flate: corrupt input before offset \" + strconv.Itoa64(int64(e))\n+\treturn \"flate: corrupt input before offset \" + strconv.FormatInt(int64(e), 10)\n }\n \n // An InternalError reports an error in the flate code itself.\n@@ -40,7 +40,7 @@ type ReadError struct {\n }\n \n func (e *ReadError) Error() string {\n-\treturn \"flate: read error at offset \" + strconv.Itoa64(e.Offset) + \": \" + e.Err.Error()\n+\treturn \"flate: read error at offset \" + strconv.FormatInt(e.Offset, 10) + \": \" + e.Err.Error()\n }\n \n // A WriteError reports an error encountered while writing output.\n@@ -50,7 +50,7 @@ type WriteError struct {\n }\n \n func (e *WriteError) Error() string {\n-\treturn \"flate: write error at offset \" + strconv.Itoa64(e.Offset) + \": \" + e.Err.Error()\n+\treturn \"flate: write error at offset \" + strconv.FormatInt(e.Offset, 10) + \": \" + e.Err.Error()\n }\n \n // Huffman decoder is based on"}, {"sha": "3505d33e960844af1c7542a7c2faa54bbcf6285d", "filename": "libgo/go/crypto/aes/aes_test.go", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Faes%2Faes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Faes%2Faes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Faes_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -348,3 +348,17 @@ func TestCipherDecrypt(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func BenchmarkEncrypt(b *testing.B) {\n+\tb.StopTimer()\n+\ttt := encryptTests[0]\n+\tc, err := NewCipher(tt.key)\n+\tif err != nil {\n+\t\tpanic(\"NewCipher\")\n+\t}\n+\tout := make([]byte, len(tt.in))\n+\tb.StartTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tc.Encrypt(out, tt.in)\n+\t}\n+}"}, {"sha": "37b0dd05841f3a8e8ff643e4ce2e673de2b11de7", "filename": "libgo/go/crypto/aes/block.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Faes%2Fblock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Faes%2Fblock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fblock.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -56,10 +56,10 @@ func encryptBlock(xk []uint32, dst, src []byte) {\n \tnr := len(xk)/4 - 2 // - 2: one above, one more below\n \tk := 4\n \tfor r := 0; r < nr; r++ {\n-\t\tt0 = xk[k+0] ^ te[0][s0>>24] ^ te[1][s1>>16&0xff] ^ te[2][s2>>8&0xff] ^ te[3][s3&0xff]\n-\t\tt1 = xk[k+1] ^ te[0][s1>>24] ^ te[1][s2>>16&0xff] ^ te[2][s3>>8&0xff] ^ te[3][s0&0xff]\n-\t\tt2 = xk[k+2] ^ te[0][s2>>24] ^ te[1][s3>>16&0xff] ^ te[2][s0>>8&0xff] ^ te[3][s1&0xff]\n-\t\tt3 = xk[k+3] ^ te[0][s3>>24] ^ te[1][s0>>16&0xff] ^ te[2][s1>>8&0xff] ^ te[3][s2&0xff]\n+\t\tt0 = xk[k+0] ^ te[0][uint8(s0>>24)] ^ te[1][uint8(s1>>16)] ^ te[2][uint8(s2>>8)] ^ te[3][uint8(s3)]\n+\t\tt1 = xk[k+1] ^ te[0][uint8(s1>>24)] ^ te[1][uint8(s2>>16)] ^ te[2][uint8(s3>>8)] ^ te[3][uint8(s0)]\n+\t\tt2 = xk[k+2] ^ te[0][uint8(s2>>24)] ^ te[1][uint8(s3>>16)] ^ te[2][uint8(s0>>8)] ^ te[3][uint8(s1)]\n+\t\tt3 = xk[k+3] ^ te[0][uint8(s3>>24)] ^ te[1][uint8(s0>>16)] ^ te[2][uint8(s1>>8)] ^ te[3][uint8(s2)]\n \t\tk += 4\n \t\ts0, s1, s2, s3 = t0, t1, t2, t3\n \t}\n@@ -101,10 +101,10 @@ func decryptBlock(xk []uint32, dst, src []byte) {\n \tnr := len(xk)/4 - 2 // - 2: one above, one more below\n \tk := 4\n \tfor r := 0; r < nr; r++ {\n-\t\tt0 = xk[k+0] ^ td[0][s0>>24] ^ td[1][s3>>16&0xff] ^ td[2][s2>>8&0xff] ^ td[3][s1&0xff]\n-\t\tt1 = xk[k+1] ^ td[0][s1>>24] ^ td[1][s0>>16&0xff] ^ td[2][s3>>8&0xff] ^ td[3][s2&0xff]\n-\t\tt2 = xk[k+2] ^ td[0][s2>>24] ^ td[1][s1>>16&0xff] ^ td[2][s0>>8&0xff] ^ td[3][s3&0xff]\n-\t\tt3 = xk[k+3] ^ td[0][s3>>24] ^ td[1][s2>>16&0xff] ^ td[2][s1>>8&0xff] ^ td[3][s0&0xff]\n+\t\tt0 = xk[k+0] ^ td[0][uint8(s0>>24)] ^ td[1][uint8(s3>>16)] ^ td[2][uint8(s2>>8)] ^ td[3][uint8(s1)]\n+\t\tt1 = xk[k+1] ^ td[0][uint8(s1>>24)] ^ td[1][uint8(s0>>16)] ^ td[2][uint8(s3>>8)] ^ td[3][uint8(s2)]\n+\t\tt2 = xk[k+2] ^ td[0][uint8(s2>>24)] ^ td[1][uint8(s1>>16)] ^ td[2][uint8(s0>>8)] ^ td[3][uint8(s3)]\n+\t\tt3 = xk[k+3] ^ td[0][uint8(s3>>24)] ^ td[1][uint8(s2>>16)] ^ td[2][uint8(s1>>8)] ^ td[3][uint8(s0)]\n \t\tk += 4\n \t\ts0, s1, s2, s3 = t0, t1, t2, t3\n \t}"}, {"sha": "6e7dd8762c814c0fd50ae774801d85163851fc83", "filename": "libgo/go/crypto/hmac/hmac.go", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -49,14 +49,13 @@ func (h *hmac) tmpPad(xor byte) {\n }\n \n func (h *hmac) Sum(in []byte) []byte {\n-\tsum := h.inner.Sum(nil)\n+\torigLen := len(in)\n+\tin = h.inner.Sum(in)\n \th.tmpPad(0x5c)\n-\tfor i, b := range sum {\n-\t\th.tmp[padSize+i] = b\n-\t}\n+\tcopy(h.tmp[padSize:], in[origLen:])\n \th.outer.Reset()\n \th.outer.Write(h.tmp)\n-\treturn h.outer.Sum(in)\n+\treturn h.outer.Sum(in[:origLen])\n }\n \n func (h *hmac) Write(p []byte) (n int, err error) {"}, {"sha": "f4e7b09ebf2c023aefaae417205fbbd945f07df5", "filename": "libgo/go/crypto/md5/md5.go", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -79,8 +79,7 @@ func (d *digest) Write(p []byte) (nn int, err error) {\n \n func (d0 *digest) Sum(in []byte) []byte {\n \t// Make a copy of d0 so that caller can keep writing and summing.\n-\td := new(digest)\n-\t*d = *d0\n+\td := *d0\n \n \t// Padding.  Add a 1 bit and 0 bits until 56 bytes mod 64.\n \tlen := d.len\n@@ -103,11 +102,13 @@ func (d0 *digest) Sum(in []byte) []byte {\n \t\tpanic(\"d.nx != 0\")\n \t}\n \n-\tfor _, s := range d.s {\n-\t\tin = append(in, byte(s>>0))\n-\t\tin = append(in, byte(s>>8))\n-\t\tin = append(in, byte(s>>16))\n-\t\tin = append(in, byte(s>>24))\n+\tvar digest [Size]byte\n+\tfor i, s := range d.s {\n+\t\tdigest[i*4] = byte(s)\n+\t\tdigest[i*4+1] = byte(s >> 8)\n+\t\tdigest[i*4+2] = byte(s >> 16)\n+\t\tdigest[i*4+3] = byte(s >> 24)\n \t}\n-\treturn in\n+\n+\treturn append(in, digest[:]...)\n }"}, {"sha": "8bc0bb320bb675d9e6f33e0009aa6bf469c7935e", "filename": "libgo/go/crypto/openpgp/s2k/s2k.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -26,6 +26,7 @@ var zero [1]byte\n // 4880, section 3.7.1.2) using the given hash, input passphrase and salt.\n func Salted(out []byte, h hash.Hash, in []byte, salt []byte) {\n \tdone := 0\n+\tvar digest []byte\n \n \tfor i := 0; done < len(out); i++ {\n \t\th.Reset()\n@@ -34,7 +35,8 @@ func Salted(out []byte, h hash.Hash, in []byte, salt []byte) {\n \t\t}\n \t\th.Write(salt)\n \t\th.Write(in)\n-\t\tn := copy(out[done:], h.Sum(nil))\n+\t\tdigest = h.Sum(digest[:0])\n+\t\tn := copy(out[done:], digest)\n \t\tdone += n\n \t}\n }\n@@ -52,6 +54,7 @@ func Iterated(out []byte, h hash.Hash, in []byte, salt []byte, count int) {\n \t}\n \n \tdone := 0\n+\tvar digest []byte\n \tfor i := 0; done < len(out); i++ {\n \t\th.Reset()\n \t\tfor j := 0; j < i; j++ {\n@@ -68,7 +71,8 @@ func Iterated(out []byte, h hash.Hash, in []byte, salt []byte, count int) {\n \t\t\t\twritten += len(combined)\n \t\t\t}\n \t\t}\n-\t\tn := copy(out[done:], h.Sum(nil))\n+\t\tdigest = h.Sum(digest[:0])\n+\t\tn := copy(out[done:], digest)\n \t\tdone += n\n \t}\n }"}, {"sha": "bdee57d767c4977e225ae960cdd98b43530bdd42", "filename": "libgo/go/crypto/openpgp/write.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -183,7 +183,7 @@ func Encrypt(ciphertext io.Writer, to []*Entity, signed *Entity, hints *FileHint\n \tfor i := range to {\n \t\tencryptKeys[i] = to[i].encryptionKey()\n \t\tif encryptKeys[i].PublicKey == nil {\n-\t\t\treturn nil, error_.InvalidArgumentError(\"cannot encrypt a message to key id \" + strconv.Uitob64(to[i].PrimaryKey.KeyId, 16) + \" because it has no encryption keys\")\n+\t\t\treturn nil, error_.InvalidArgumentError(\"cannot encrypt a message to key id \" + strconv.FormatUint(to[i].PrimaryKey.KeyId, 16) + \" because it has no encryption keys\")\n \t\t}\n \n \t\tsig := to[i].primaryIdentity().SelfSignature"}, {"sha": "cd2cc39dbd170a2a0429164f7a9376cd9217ece3", "filename": "libgo/go/crypto/ripemd160/ripemd160.go", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -83,8 +83,7 @@ func (d *digest) Write(p []byte) (nn int, err error) {\n \n func (d0 *digest) Sum(in []byte) []byte {\n \t// Make a copy of d0 so that caller can keep writing and summing.\n-\td := new(digest)\n-\t*d = *d0\n+\td := *d0\n \n \t// Padding.  Add a 1 bit and 0 bits until 56 bytes mod 64.\n \ttc := d.tc\n@@ -107,11 +106,13 @@ func (d0 *digest) Sum(in []byte) []byte {\n \t\tpanic(\"d.nx != 0\")\n \t}\n \n-\tfor _, s := range d.s {\n-\t\tin = append(in, byte(s))\n-\t\tin = append(in, byte(s>>8))\n-\t\tin = append(in, byte(s>>16))\n-\t\tin = append(in, byte(s>>24))\n+\tvar digest [Size]byte\n+\tfor i, s := range d.s {\n+\t\tdigest[i*4] = byte(s)\n+\t\tdigest[i*4+1] = byte(s >> 8)\n+\t\tdigest[i*4+2] = byte(s >> 16)\n+\t\tdigest[i*4+3] = byte(s >> 24)\n \t}\n-\treturn in\n+\n+\treturn append(in, digest[:]...)\n }"}, {"sha": "c07e8f90db7796f4bf5ae852ab5e9dff6882abf2", "filename": "libgo/go/crypto/rsa/rsa.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -189,12 +189,13 @@ func incCounter(c *[4]byte) {\n // specified in PKCS#1 v2.1.\n func mgf1XOR(out []byte, hash hash.Hash, seed []byte) {\n \tvar counter [4]byte\n+\tvar digest []byte\n \n \tdone := 0\n \tfor done < len(out) {\n \t\thash.Write(seed)\n \t\thash.Write(counter[0:4])\n-\t\tdigest := hash.Sum(nil)\n+\t\tdigest = hash.Sum(digest[:0])\n \t\thash.Reset()\n \n \t\tfor i := 0; i < len(digest) && done < len(out); i++ {"}, {"sha": "7bb68bbdbc8ab5d467436bb9d08216ce13d04f58", "filename": "libgo/go/crypto/sha1/sha1.go", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -81,8 +81,7 @@ func (d *digest) Write(p []byte) (nn int, err error) {\n \n func (d0 *digest) Sum(in []byte) []byte {\n \t// Make a copy of d0 so that caller can keep writing and summing.\n-\td := new(digest)\n-\t*d = *d0\n+\td := *d0\n \n \t// Padding.  Add a 1 bit and 0 bits until 56 bytes mod 64.\n \tlen := d.len\n@@ -105,11 +104,13 @@ func (d0 *digest) Sum(in []byte) []byte {\n \t\tpanic(\"d.nx != 0\")\n \t}\n \n-\tfor _, s := range d.h {\n-\t\tin = append(in, byte(s>>24))\n-\t\tin = append(in, byte(s>>16))\n-\t\tin = append(in, byte(s>>8))\n-\t\tin = append(in, byte(s))\n+\tvar digest [Size]byte\n+\tfor i, s := range d.h {\n+\t\tdigest[i*4] = byte(s >> 24)\n+\t\tdigest[i*4+1] = byte(s >> 16)\n+\t\tdigest[i*4+2] = byte(s >> 8)\n+\t\tdigest[i*4+3] = byte(s)\n \t}\n-\treturn in\n+\n+\treturn append(in, digest[:]...)\n }"}, {"sha": "4525541a79caea0c61f53d811c1b6e57fbe84b38", "filename": "libgo/go/crypto/sha256/sha256.go", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -125,8 +125,7 @@ func (d *digest) Write(p []byte) (nn int, err error) {\n \n func (d0 *digest) Sum(in []byte) []byte {\n \t// Make a copy of d0 so that caller can keep writing and summing.\n-\td := new(digest)\n-\t*d = *d0\n+\td := *d0\n \n \t// Padding.  Add a 1 bit and 0 bits until 56 bytes mod 64.\n \tlen := d.len\n@@ -150,14 +149,19 @@ func (d0 *digest) Sum(in []byte) []byte {\n \t}\n \n \th := d.h[:]\n+\tsize := Size\n \tif d.is224 {\n \t\th = d.h[:7]\n+\t\tsize = Size224\n \t}\n-\tfor _, s := range h {\n-\t\tin = append(in, byte(s>>24))\n-\t\tin = append(in, byte(s>>16))\n-\t\tin = append(in, byte(s>>8))\n-\t\tin = append(in, byte(s))\n+\n+\tvar digest [Size]byte\n+\tfor i, s := range h {\n+\t\tdigest[i*4] = byte(s >> 24)\n+\t\tdigest[i*4+1] = byte(s >> 16)\n+\t\tdigest[i*4+2] = byte(s >> 8)\n+\t\tdigest[i*4+3] = byte(s)\n \t}\n-\treturn in\n+\n+\treturn append(in, digest[:size]...)\n }"}, {"sha": "927f28a28d84c2b9ac3a98f6dfe8590a2fa504c6", "filename": "libgo/go/crypto/sha512/sha512.go", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -150,18 +150,23 @@ func (d0 *digest) Sum(in []byte) []byte {\n \t}\n \n \th := d.h[:]\n+\tsize := Size\n \tif d.is384 {\n \t\th = d.h[:6]\n+\t\tsize = Size384\n \t}\n-\tfor _, s := range h {\n-\t\tin = append(in, byte(s>>56))\n-\t\tin = append(in, byte(s>>48))\n-\t\tin = append(in, byte(s>>40))\n-\t\tin = append(in, byte(s>>32))\n-\t\tin = append(in, byte(s>>24))\n-\t\tin = append(in, byte(s>>16))\n-\t\tin = append(in, byte(s>>8))\n-\t\tin = append(in, byte(s))\n+\n+\tvar digest [Size]byte\n+\tfor i, s := range h {\n+\t\tdigest[i*8] = byte(s >> 56)\n+\t\tdigest[i*8+1] = byte(s >> 48)\n+\t\tdigest[i*8+2] = byte(s >> 40)\n+\t\tdigest[i*8+3] = byte(s >> 32)\n+\t\tdigest[i*8+4] = byte(s >> 24)\n+\t\tdigest[i*8+5] = byte(s >> 16)\n+\t\tdigest[i*8+6] = byte(s >> 8)\n+\t\tdigest[i*8+7] = byte(s)\n \t}\n-\treturn in\n+\n+\treturn append(in, digest[:size]...)\n }"}, {"sha": "914491d6b4a84f4eb68272213b8b349e69efb6cc", "filename": "libgo/go/crypto/tls/cipher_suites.go", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -52,12 +52,12 @@ type cipherSuite struct {\n }\n \n var cipherSuites = []*cipherSuite{\n-\t&cipherSuite{TLS_RSA_WITH_RC4_128_SHA, 16, 20, 0, rsaKA, false, cipherRC4, macSHA1},\n-\t&cipherSuite{TLS_RSA_WITH_3DES_EDE_CBC_SHA, 24, 20, 8, rsaKA, false, cipher3DES, macSHA1},\n-\t&cipherSuite{TLS_RSA_WITH_AES_128_CBC_SHA, 16, 20, 16, rsaKA, false, cipherAES, macSHA1},\n-\t&cipherSuite{TLS_ECDHE_RSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheRSAKA, true, cipherRC4, macSHA1},\n-\t&cipherSuite{TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, 24, 20, 8, ecdheRSAKA, true, cipher3DES, macSHA1},\n-\t&cipherSuite{TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, 16, 20, 16, ecdheRSAKA, true, cipherAES, macSHA1},\n+\t{TLS_RSA_WITH_RC4_128_SHA, 16, 20, 0, rsaKA, false, cipherRC4, macSHA1},\n+\t{TLS_RSA_WITH_3DES_EDE_CBC_SHA, 24, 20, 8, rsaKA, false, cipher3DES, macSHA1},\n+\t{TLS_RSA_WITH_AES_128_CBC_SHA, 16, 20, 16, rsaKA, false, cipherAES, macSHA1},\n+\t{TLS_ECDHE_RSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheRSAKA, true, cipherRC4, macSHA1},\n+\t{TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, 24, 20, 8, ecdheRSAKA, true, cipher3DES, macSHA1},\n+\t{TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, 16, 20, 16, ecdheRSAKA, true, cipherAES, macSHA1},\n }\n \n func cipherRC4(key, iv []byte, isRead bool) interface{} {\n@@ -96,7 +96,7 @@ func macSHA1(version uint16, key []byte) macFunction {\n \n type macFunction interface {\n \tSize() int\n-\tMAC(seq, data []byte) []byte\n+\tMAC(digestBuf, seq, data []byte) []byte\n }\n \n // ssl30MAC implements the SSLv3 MAC function, as defined in\n@@ -114,7 +114,7 @@ var ssl30Pad1 = [48]byte{0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0\n \n var ssl30Pad2 = [48]byte{0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c}\n \n-func (s ssl30MAC) MAC(seq, record []byte) []byte {\n+func (s ssl30MAC) MAC(digestBuf, seq, record []byte) []byte {\n \tpadLength := 48\n \tif s.h.Size() == 20 {\n \t\tpadLength = 40\n@@ -127,13 +127,13 @@ func (s ssl30MAC) MAC(seq, record []byte) []byte {\n \ts.h.Write(record[:1])\n \ts.h.Write(record[3:5])\n \ts.h.Write(record[recordHeaderLen:])\n-\tdigest := s.h.Sum(nil)\n+\tdigestBuf = s.h.Sum(digestBuf[:0])\n \n \ts.h.Reset()\n \ts.h.Write(s.key)\n \ts.h.Write(ssl30Pad2[:padLength])\n-\ts.h.Write(digest)\n-\treturn s.h.Sum(nil)\n+\ts.h.Write(digestBuf)\n+\treturn s.h.Sum(digestBuf[:0])\n }\n \n // tls10MAC implements the TLS 1.0 MAC function. RFC 2246, section 6.2.3.\n@@ -145,11 +145,11 @@ func (s tls10MAC) Size() int {\n \treturn s.h.Size()\n }\n \n-func (s tls10MAC) MAC(seq, record []byte) []byte {\n+func (s tls10MAC) MAC(digestBuf, seq, record []byte) []byte {\n \ts.h.Reset()\n \ts.h.Write(seq)\n \ts.h.Write(record)\n-\treturn s.h.Sum(nil)\n+\treturn s.h.Sum(digestBuf[:0])\n }\n \n func rsaKA() keyAgreement {"}, {"sha": "6a03fa8042ae964979af5f8393ca69e635a2a98d", "filename": "libgo/go/crypto/tls/conn.go", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -118,6 +118,9 @@ type halfConn struct {\n \n \tnextCipher interface{} // next encryption state\n \tnextMac    macFunction // next MAC algorithm\n+\n+\t// used to save allocating a new buffer for each MAC.\n+\tinDigestBuf, outDigestBuf []byte\n }\n \n // prepareCipherSpec sets the encryption and MAC states\n@@ -280,12 +283,13 @@ func (hc *halfConn) decrypt(b *block) (bool, alert) {\n \t\tb.data[4] = byte(n)\n \t\tb.resize(recordHeaderLen + n)\n \t\tremoteMAC := payload[n:]\n-\t\tlocalMAC := hc.mac.MAC(hc.seq[0:], b.data)\n+\t\tlocalMAC := hc.mac.MAC(hc.inDigestBuf, hc.seq[0:], b.data)\n \t\thc.incSeq()\n \n \t\tif subtle.ConstantTimeCompare(localMAC, remoteMAC) != 1 || paddingGood != 255 {\n \t\t\treturn false, alertBadRecordMAC\n \t\t}\n+\t\thc.inDigestBuf = localMAC\n \t}\n \n \treturn true, 0\n@@ -312,12 +316,13 @@ func padToBlockSize(payload []byte, blockSize int) (prefix, finalBlock []byte) {\n func (hc *halfConn) encrypt(b *block) (bool, alert) {\n \t// mac\n \tif hc.mac != nil {\n-\t\tmac := hc.mac.MAC(hc.seq[0:], b.data)\n+\t\tmac := hc.mac.MAC(hc.outDigestBuf, hc.seq[0:], b.data)\n \t\thc.incSeq()\n \n \t\tn := len(b.data)\n \t\tb.resize(n + len(mac))\n \t\tcopy(b.data[n:], mac)\n+\t\thc.outDigestBuf = mac\n \t}\n \n \tpayload := b.data[recordHeaderLen:]"}, {"sha": "e39e59cd5a1d05505bb92f63b67da4e2ab600466", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -231,10 +231,10 @@ func (c *Conn) clientHandshake() error {\n \n \tif cert != nil {\n \t\tcertVerify := new(certificateVerifyMsg)\n-\t\tvar digest [36]byte\n-\t\tcopy(digest[0:16], finishedHash.serverMD5.Sum(nil))\n-\t\tcopy(digest[16:36], finishedHash.serverSHA1.Sum(nil))\n-\t\tsigned, err := rsa.SignPKCS1v15(c.config.rand(), c.config.Certificates[0].PrivateKey, crypto.MD5SHA1, digest[0:])\n+\t\tdigest := make([]byte, 0, 36)\n+\t\tdigest = finishedHash.serverMD5.Sum(digest)\n+\t\tdigest = finishedHash.serverSHA1.Sum(digest)\n+\t\tsigned, err := rsa.SignPKCS1v15(c.config.rand(), c.config.Certificates[0].PrivateKey, crypto.MD5SHA1, digest)\n \t\tif err != nil {\n \t\t\treturn c.sendAlert(alertInternalError)\n \t\t}"}, {"sha": "89c000dd6e9b04fed616564dc864843b842d9e92", "filename": "libgo/go/crypto/tls/handshake_server.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -234,9 +234,9 @@ FindCipherSuite:\n \t\t\treturn c.sendAlert(alertUnexpectedMessage)\n \t\t}\n \n-\t\tdigest := make([]byte, 36)\n-\t\tcopy(digest[0:16], finishedHash.serverMD5.Sum(nil))\n-\t\tcopy(digest[16:36], finishedHash.serverSHA1.Sum(nil))\n+\t\tdigest := make([]byte, 0, 36)\n+\t\tdigest = finishedHash.serverMD5.Sum(digest)\n+\t\tdigest = finishedHash.serverSHA1.Sum(digest)\n \t\terr = rsa.VerifyPKCS1v15(pub, crypto.MD5SHA1, digest, certVerify.signature)\n \t\tif err != nil {\n \t\t\tc.sendAlert(alertBadCertificate)"}, {"sha": "d98e13decf677596ee8bcf77c2a75ad533ef9922", "filename": "libgo/go/crypto/tls/handshake_server_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -159,7 +159,7 @@ func TestHandshakeServerSSLv3(t *testing.T) {\n \n var serve = flag.Bool(\"serve\", false, \"run a TLS server on :10443\")\n var testCipherSuites = flag.String(\"ciphersuites\",\n-\t\"0x\"+strconv.Itob(int(TLS_RSA_WITH_RC4_128_SHA), 16),\n+\t\"0x\"+strconv.FormatInt(int64(TLS_RSA_WITH_RC4_128_SHA), 16),\n \t\"cipher suites to accept in serving mode\")\n \n func TestRunServer(t *testing.T) {\n@@ -170,7 +170,7 @@ func TestRunServer(t *testing.T) {\n \tsuites := strings.Split(*testCipherSuites, \",\")\n \ttestConfig.CipherSuites = make([]uint16, len(suites))\n \tfor i := range suites {\n-\t\tsuite, err := strconv.Btoui64(suites[i], 0)\n+\t\tsuite, err := strconv.ParseUint(suites[i], 0, 64)\n \t\tif err != nil {\n \t\t\tpanic(err)\n \t\t}"}, {"sha": "65ca31580035595f1a9d417f8276b97c86281dc6", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -927,10 +927,15 @@ func CreateCertificate(rand io.Reader, template, parent *Certificate, pub *rsa.P\n \t\treturn\n \t}\n \n-\tasn1Issuer, err := asn1.Marshal(parent.Subject.ToRDNSequence())\n-\tif err != nil {\n-\t\treturn\n+\tvar asn1Issuer []byte\n+\tif len(parent.RawSubject) > 0 {\n+\t\tasn1Issuer = parent.RawSubject\n+\t} else {\n+\t\tif asn1Issuer, err = asn1.Marshal(parent.Subject.ToRDNSequence()); err != nil {\n+\t\t\treturn\n+\t\t}\n \t}\n+\n \tasn1Subject, err := asn1.Marshal(template.Subject.ToRDNSequence())\n \tif err != nil {\n \t\treturn"}, {"sha": "6dc28d2568c39ba5dac17eb2bb1387e1b6844168", "filename": "libgo/go/debug/dwarf/buf.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fdebug%2Fdwarf%2Fbuf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fdebug%2Fdwarf%2Fbuf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fbuf.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -149,5 +149,5 @@ type DecodeError struct {\n }\n \n func (e DecodeError) Error() string {\n-\treturn \"decoding dwarf section \" + e.Name + \" at offset 0x\" + strconv.Itob64(int64(e.Offset), 16) + \": \" + e.Err\n+\treturn \"decoding dwarf section \" + e.Name + \" at offset 0x\" + strconv.FormatInt(int64(e.Offset), 16) + \": \" + e.Err\n }"}, {"sha": "918b153d07895d3c551bfe5a26c3e793a3c380e7", "filename": "libgo/go/debug/dwarf/const.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fdebug%2Fdwarf%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fdebug%2Fdwarf%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fconst.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -178,7 +178,7 @@ func (a Attr) GoString() string {\n \t\t\treturn \"dwarf.Attr\" + s\n \t\t}\n \t}\n-\treturn \"dwarf.Attr(\" + strconv.Itoa64(int64(a)) + \")\"\n+\treturn \"dwarf.Attr(\" + strconv.FormatInt(int64(a), 10) + \")\"\n }\n \n // A format is a DWARF data encoding format.\n@@ -347,7 +347,7 @@ func (t Tag) GoString() string {\n \t\t\treturn \"dwarf.Tag\" + s\n \t\t}\n \t}\n-\treturn \"dwarf.Tag(\" + strconv.Itoa64(int64(t)) + \")\"\n+\treturn \"dwarf.Tag(\" + strconv.FormatInt(int64(t), 10) + \")\"\n }\n \n // Location expression operators."}, {"sha": "9be66658fe9fa0242e69fca787284bbd6c255f14", "filename": "libgo/go/debug/dwarf/type.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -110,7 +110,7 @@ type ArrayType struct {\n }\n \n func (t *ArrayType) String() string {\n-\treturn \"[\" + strconv.Itoa64(t.Count) + \"]\" + t.Type.String()\n+\treturn \"[\" + strconv.FormatInt(t.Count, 10) + \"]\" + t.Type.String()\n }\n \n func (t *ArrayType) Size() int64 { return t.Count * t.Type.Size() }\n@@ -171,10 +171,10 @@ func (t *StructType) Defn() string {\n \t\t\ts += \"; \"\n \t\t}\n \t\ts += f.Name + \" \" + f.Type.String()\n-\t\ts += \"@\" + strconv.Itoa64(f.ByteOffset)\n+\t\ts += \"@\" + strconv.FormatInt(f.ByteOffset, 10)\n \t\tif f.BitSize > 0 {\n-\t\t\ts += \" : \" + strconv.Itoa64(f.BitSize)\n-\t\t\ts += \"@\" + strconv.Itoa64(f.BitOffset)\n+\t\t\ts += \" : \" + strconv.FormatInt(f.BitSize, 10)\n+\t\t\ts += \"@\" + strconv.FormatInt(f.BitOffset, 10)\n \t\t}\n \t}\n \ts += \"}\"\n@@ -206,7 +206,7 @@ func (t *EnumType) String() string {\n \t\tif i > 0 {\n \t\t\ts += \"; \"\n \t\t}\n-\t\ts += v.Name + \"=\" + strconv.Itoa64(v.Val)\n+\t\ts += v.Name + \"=\" + strconv.FormatInt(v.Val, 10)\n \t}\n \ts += \"}\"\n \treturn s"}, {"sha": "03e42b034657c049cb52fcac5cfdea96d547b68e", "filename": "libgo/go/debug/elf/elf.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fdebug%2Felf%2Felf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fdebug%2Felf%2Felf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Felf.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -1490,11 +1490,11 @@ func stringName(i uint32, names []intName, goSyntax bool) string {\n \t\t\tif goSyntax {\n \t\t\t\ts = \"elf.\" + s\n \t\t\t}\n-\t\t\treturn s + \"+\" + strconv.Uitoa64(uint64(i-n.i))\n+\t\t\treturn s + \"+\" + strconv.FormatUint(uint64(i-n.i), 10)\n \t\t}\n \t}\n \n-\treturn strconv.Uitoa64(uint64(i))\n+\treturn strconv.FormatUint(uint64(i), 10)\n }\n \n func flagName(i uint32, names []intName, goSyntax bool) string {\n@@ -1512,10 +1512,10 @@ func flagName(i uint32, names []intName, goSyntax bool) string {\n \t\t}\n \t}\n \tif len(s) == 0 {\n-\t\treturn \"0x\" + strconv.Uitob64(uint64(i), 16)\n+\t\treturn \"0x\" + strconv.FormatUint(uint64(i), 16)\n \t}\n \tif i != 0 {\n-\t\ts += \"+0x\" + strconv.Uitob64(uint64(i), 16)\n+\t\ts += \"+0x\" + strconv.FormatUint(uint64(i), 16)\n \t}\n \treturn s\n }"}, {"sha": "640225b3291b138c6462107d5b62adf3024c98f1", "filename": "libgo/go/debug/macho/file_test.go", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -21,11 +21,11 @@ var fileTests = []fileTest{\n \t\t\"testdata/gcc-386-darwin-exec\",\n \t\tFileHeader{0xfeedface, Cpu386, 0x3, 0x2, 0xc, 0x3c0, 0x85},\n \t\t[]*SegmentHeader{\n-\t\t\t&SegmentHeader{LoadCmdSegment, 0x38, \"__PAGEZERO\", 0x0, 0x1000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},\n-\t\t\t&SegmentHeader{LoadCmdSegment, 0xc0, \"__TEXT\", 0x1000, 0x1000, 0x0, 0x1000, 0x7, 0x5, 0x2, 0x0},\n-\t\t\t&SegmentHeader{LoadCmdSegment, 0xc0, \"__DATA\", 0x2000, 0x1000, 0x1000, 0x1000, 0x7, 0x3, 0x2, 0x0},\n-\t\t\t&SegmentHeader{LoadCmdSegment, 0x7c, \"__IMPORT\", 0x3000, 0x1000, 0x2000, 0x1000, 0x7, 0x7, 0x1, 0x0},\n-\t\t\t&SegmentHeader{LoadCmdSegment, 0x38, \"__LINKEDIT\", 0x4000, 0x1000, 0x3000, 0x12c, 0x7, 0x1, 0x0, 0x0},\n+\t\t\t{LoadCmdSegment, 0x38, \"__PAGEZERO\", 0x0, 0x1000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},\n+\t\t\t{LoadCmdSegment, 0xc0, \"__TEXT\", 0x1000, 0x1000, 0x0, 0x1000, 0x7, 0x5, 0x2, 0x0},\n+\t\t\t{LoadCmdSegment, 0xc0, \"__DATA\", 0x2000, 0x1000, 0x1000, 0x1000, 0x7, 0x3, 0x2, 0x0},\n+\t\t\t{LoadCmdSegment, 0x7c, \"__IMPORT\", 0x3000, 0x1000, 0x2000, 0x1000, 0x7, 0x7, 0x1, 0x0},\n+\t\t\t{LoadCmdSegment, 0x38, \"__LINKEDIT\", 0x4000, 0x1000, 0x3000, 0x12c, 0x7, 0x1, 0x0, 0x0},\n \t\t\tnil,\n \t\t\tnil,\n \t\t\tnil,\n@@ -35,21 +35,21 @@ var fileTests = []fileTest{\n \t\t\tnil,\n \t\t},\n \t\t[]*SectionHeader{\n-\t\t\t&SectionHeader{\"__text\", \"__TEXT\", 0x1f68, 0x88, 0xf68, 0x2, 0x0, 0x0, 0x80000400},\n-\t\t\t&SectionHeader{\"__cstring\", \"__TEXT\", 0x1ff0, 0xd, 0xff0, 0x0, 0x0, 0x0, 0x2},\n-\t\t\t&SectionHeader{\"__data\", \"__DATA\", 0x2000, 0x14, 0x1000, 0x2, 0x0, 0x0, 0x0},\n-\t\t\t&SectionHeader{\"__dyld\", \"__DATA\", 0x2014, 0x1c, 0x1014, 0x2, 0x0, 0x0, 0x0},\n-\t\t\t&SectionHeader{\"__jump_table\", \"__IMPORT\", 0x3000, 0xa, 0x2000, 0x6, 0x0, 0x0, 0x4000008},\n+\t\t\t{\"__text\", \"__TEXT\", 0x1f68, 0x88, 0xf68, 0x2, 0x0, 0x0, 0x80000400},\n+\t\t\t{\"__cstring\", \"__TEXT\", 0x1ff0, 0xd, 0xff0, 0x0, 0x0, 0x0, 0x2},\n+\t\t\t{\"__data\", \"__DATA\", 0x2000, 0x14, 0x1000, 0x2, 0x0, 0x0, 0x0},\n+\t\t\t{\"__dyld\", \"__DATA\", 0x2014, 0x1c, 0x1014, 0x2, 0x0, 0x0, 0x0},\n+\t\t\t{\"__jump_table\", \"__IMPORT\", 0x3000, 0xa, 0x2000, 0x6, 0x0, 0x0, 0x4000008},\n \t\t},\n \t},\n \t{\n \t\t\"testdata/gcc-amd64-darwin-exec\",\n \t\tFileHeader{0xfeedfacf, CpuAmd64, 0x80000003, 0x2, 0xb, 0x568, 0x85},\n \t\t[]*SegmentHeader{\n-\t\t\t&SegmentHeader{LoadCmdSegment64, 0x48, \"__PAGEZERO\", 0x0, 0x100000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},\n-\t\t\t&SegmentHeader{LoadCmdSegment64, 0x1d8, \"__TEXT\", 0x100000000, 0x1000, 0x0, 0x1000, 0x7, 0x5, 0x5, 0x0},\n-\t\t\t&SegmentHeader{LoadCmdSegment64, 0x138, \"__DATA\", 0x100001000, 0x1000, 0x1000, 0x1000, 0x7, 0x3, 0x3, 0x0},\n-\t\t\t&SegmentHeader{LoadCmdSegment64, 0x48, \"__LINKEDIT\", 0x100002000, 0x1000, 0x2000, 0x140, 0x7, 0x1, 0x0, 0x0},\n+\t\t\t{LoadCmdSegment64, 0x48, \"__PAGEZERO\", 0x0, 0x100000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},\n+\t\t\t{LoadCmdSegment64, 0x1d8, \"__TEXT\", 0x100000000, 0x1000, 0x0, 0x1000, 0x7, 0x5, 0x5, 0x0},\n+\t\t\t{LoadCmdSegment64, 0x138, \"__DATA\", 0x100001000, 0x1000, 0x1000, 0x1000, 0x7, 0x3, 0x3, 0x0},\n+\t\t\t{LoadCmdSegment64, 0x48, \"__LINKEDIT\", 0x100002000, 0x1000, 0x2000, 0x140, 0x7, 0x1, 0x0, 0x0},\n \t\t\tnil,\n \t\t\tnil,\n \t\t\tnil,\n@@ -59,41 +59,41 @@ var fileTests = []fileTest{\n \t\t\tnil,\n \t\t},\n \t\t[]*SectionHeader{\n-\t\t\t&SectionHeader{\"__text\", \"__TEXT\", 0x100000f14, 0x6d, 0xf14, 0x2, 0x0, 0x0, 0x80000400},\n-\t\t\t&SectionHeader{\"__symbol_stub1\", \"__TEXT\", 0x100000f81, 0xc, 0xf81, 0x0, 0x0, 0x0, 0x80000408},\n-\t\t\t&SectionHeader{\"__stub_helper\", \"__TEXT\", 0x100000f90, 0x18, 0xf90, 0x2, 0x0, 0x0, 0x0},\n-\t\t\t&SectionHeader{\"__cstring\", \"__TEXT\", 0x100000fa8, 0xd, 0xfa8, 0x0, 0x0, 0x0, 0x2},\n-\t\t\t&SectionHeader{\"__eh_frame\", \"__TEXT\", 0x100000fb8, 0x48, 0xfb8, 0x3, 0x0, 0x0, 0x6000000b},\n-\t\t\t&SectionHeader{\"__data\", \"__DATA\", 0x100001000, 0x1c, 0x1000, 0x3, 0x0, 0x0, 0x0},\n-\t\t\t&SectionHeader{\"__dyld\", \"__DATA\", 0x100001020, 0x38, 0x1020, 0x3, 0x0, 0x0, 0x0},\n-\t\t\t&SectionHeader{\"__la_symbol_ptr\", \"__DATA\", 0x100001058, 0x10, 0x1058, 0x2, 0x0, 0x0, 0x7},\n+\t\t\t{\"__text\", \"__TEXT\", 0x100000f14, 0x6d, 0xf14, 0x2, 0x0, 0x0, 0x80000400},\n+\t\t\t{\"__symbol_stub1\", \"__TEXT\", 0x100000f81, 0xc, 0xf81, 0x0, 0x0, 0x0, 0x80000408},\n+\t\t\t{\"__stub_helper\", \"__TEXT\", 0x100000f90, 0x18, 0xf90, 0x2, 0x0, 0x0, 0x0},\n+\t\t\t{\"__cstring\", \"__TEXT\", 0x100000fa8, 0xd, 0xfa8, 0x0, 0x0, 0x0, 0x2},\n+\t\t\t{\"__eh_frame\", \"__TEXT\", 0x100000fb8, 0x48, 0xfb8, 0x3, 0x0, 0x0, 0x6000000b},\n+\t\t\t{\"__data\", \"__DATA\", 0x100001000, 0x1c, 0x1000, 0x3, 0x0, 0x0, 0x0},\n+\t\t\t{\"__dyld\", \"__DATA\", 0x100001020, 0x38, 0x1020, 0x3, 0x0, 0x0, 0x0},\n+\t\t\t{\"__la_symbol_ptr\", \"__DATA\", 0x100001058, 0x10, 0x1058, 0x2, 0x0, 0x0, 0x7},\n \t\t},\n \t},\n \t{\n \t\t\"testdata/gcc-amd64-darwin-exec-debug\",\n \t\tFileHeader{0xfeedfacf, CpuAmd64, 0x80000003, 0xa, 0x4, 0x5a0, 0},\n \t\t[]*SegmentHeader{\n \t\t\tnil,\n-\t\t\t&SegmentHeader{LoadCmdSegment64, 0x1d8, \"__TEXT\", 0x100000000, 0x1000, 0x0, 0x0, 0x7, 0x5, 0x5, 0x0},\n-\t\t\t&SegmentHeader{LoadCmdSegment64, 0x138, \"__DATA\", 0x100001000, 0x1000, 0x0, 0x0, 0x7, 0x3, 0x3, 0x0},\n-\t\t\t&SegmentHeader{LoadCmdSegment64, 0x278, \"__DWARF\", 0x100002000, 0x1000, 0x1000, 0x1bc, 0x7, 0x3, 0x7, 0x0},\n+\t\t\t{LoadCmdSegment64, 0x1d8, \"__TEXT\", 0x100000000, 0x1000, 0x0, 0x0, 0x7, 0x5, 0x5, 0x0},\n+\t\t\t{LoadCmdSegment64, 0x138, \"__DATA\", 0x100001000, 0x1000, 0x0, 0x0, 0x7, 0x3, 0x3, 0x0},\n+\t\t\t{LoadCmdSegment64, 0x278, \"__DWARF\", 0x100002000, 0x1000, 0x1000, 0x1bc, 0x7, 0x3, 0x7, 0x0},\n \t\t},\n \t\t[]*SectionHeader{\n-\t\t\t&SectionHeader{\"__text\", \"__TEXT\", 0x100000f14, 0x0, 0x0, 0x2, 0x0, 0x0, 0x80000400},\n-\t\t\t&SectionHeader{\"__symbol_stub1\", \"__TEXT\", 0x100000f81, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80000408},\n-\t\t\t&SectionHeader{\"__stub_helper\", \"__TEXT\", 0x100000f90, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0},\n-\t\t\t&SectionHeader{\"__cstring\", \"__TEXT\", 0x100000fa8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2},\n-\t\t\t&SectionHeader{\"__eh_frame\", \"__TEXT\", 0x100000fb8, 0x0, 0x0, 0x3, 0x0, 0x0, 0x6000000b},\n-\t\t\t&SectionHeader{\"__data\", \"__DATA\", 0x100001000, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0},\n-\t\t\t&SectionHeader{\"__dyld\", \"__DATA\", 0x100001020, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0},\n-\t\t\t&SectionHeader{\"__la_symbol_ptr\", \"__DATA\", 0x100001058, 0x0, 0x0, 0x2, 0x0, 0x0, 0x7},\n-\t\t\t&SectionHeader{\"__debug_abbrev\", \"__DWARF\", 0x100002000, 0x36, 0x1000, 0x0, 0x0, 0x0, 0x0},\n-\t\t\t&SectionHeader{\"__debug_aranges\", \"__DWARF\", 0x100002036, 0x30, 0x1036, 0x0, 0x0, 0x0, 0x0},\n-\t\t\t&SectionHeader{\"__debug_frame\", \"__DWARF\", 0x100002066, 0x40, 0x1066, 0x0, 0x0, 0x0, 0x0},\n-\t\t\t&SectionHeader{\"__debug_info\", \"__DWARF\", 0x1000020a6, 0x54, 0x10a6, 0x0, 0x0, 0x0, 0x0},\n-\t\t\t&SectionHeader{\"__debug_line\", \"__DWARF\", 0x1000020fa, 0x47, 0x10fa, 0x0, 0x0, 0x0, 0x0},\n-\t\t\t&SectionHeader{\"__debug_pubnames\", \"__DWARF\", 0x100002141, 0x1b, 0x1141, 0x0, 0x0, 0x0, 0x0},\n-\t\t\t&SectionHeader{\"__debug_str\", \"__DWARF\", 0x10000215c, 0x60, 0x115c, 0x0, 0x0, 0x0, 0x0},\n+\t\t\t{\"__text\", \"__TEXT\", 0x100000f14, 0x0, 0x0, 0x2, 0x0, 0x0, 0x80000400},\n+\t\t\t{\"__symbol_stub1\", \"__TEXT\", 0x100000f81, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80000408},\n+\t\t\t{\"__stub_helper\", \"__TEXT\", 0x100000f90, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0},\n+\t\t\t{\"__cstring\", \"__TEXT\", 0x100000fa8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2},\n+\t\t\t{\"__eh_frame\", \"__TEXT\", 0x100000fb8, 0x0, 0x0, 0x3, 0x0, 0x0, 0x6000000b},\n+\t\t\t{\"__data\", \"__DATA\", 0x100001000, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0},\n+\t\t\t{\"__dyld\", \"__DATA\", 0x100001020, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0},\n+\t\t\t{\"__la_symbol_ptr\", \"__DATA\", 0x100001058, 0x0, 0x0, 0x2, 0x0, 0x0, 0x7},\n+\t\t\t{\"__debug_abbrev\", \"__DWARF\", 0x100002000, 0x36, 0x1000, 0x0, 0x0, 0x0, 0x0},\n+\t\t\t{\"__debug_aranges\", \"__DWARF\", 0x100002036, 0x30, 0x1036, 0x0, 0x0, 0x0, 0x0},\n+\t\t\t{\"__debug_frame\", \"__DWARF\", 0x100002066, 0x40, 0x1066, 0x0, 0x0, 0x0, 0x0},\n+\t\t\t{\"__debug_info\", \"__DWARF\", 0x1000020a6, 0x54, 0x10a6, 0x0, 0x0, 0x0, 0x0},\n+\t\t\t{\"__debug_line\", \"__DWARF\", 0x1000020fa, 0x47, 0x10fa, 0x0, 0x0, 0x0, 0x0},\n+\t\t\t{\"__debug_pubnames\", \"__DWARF\", 0x100002141, 0x1b, 0x1141, 0x0, 0x0, 0x0, 0x0},\n+\t\t\t{\"__debug_str\", \"__DWARF\", 0x10000215c, 0x60, 0x115c, 0x0, 0x0, 0x0, 0x0},\n \t\t},\n \t},\n }"}, {"sha": "bc14226c565a0c8045d8dcd68f95a4f5dd21b55a", "filename": "libgo/go/debug/macho/macho.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fdebug%2Fmacho%2Fmacho.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fdebug%2Fmacho%2Fmacho.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fmacho%2Fmacho.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -278,7 +278,7 @@ func stringName(i uint32, names []intName, goSyntax bool) string {\n \t\t\treturn n.s\n \t\t}\n \t}\n-\treturn strconv.Uitoa64(uint64(i))\n+\treturn strconv.FormatUint(uint64(i), 10)\n }\n \n func flagName(i uint32, names []intName, goSyntax bool) string {\n@@ -296,10 +296,10 @@ func flagName(i uint32, names []intName, goSyntax bool) string {\n \t\t}\n \t}\n \tif len(s) == 0 {\n-\t\treturn \"0x\" + strconv.Uitob64(uint64(i), 16)\n+\t\treturn \"0x\" + strconv.FormatUint(uint64(i), 16)\n \t}\n \tif i != 0 {\n-\t\ts += \"+0x\" + strconv.Uitob64(uint64(i), 16)\n+\t\ts += \"+0x\" + strconv.FormatUint(uint64(i), 16)\n \t}\n \treturn s\n }"}, {"sha": "2815d720bb613d24b316b71d2ea7eb1110e7b01d", "filename": "libgo/go/debug/pe/file_test.go", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -20,39 +20,39 @@ var fileTests = []fileTest{\n \t\t\"testdata/gcc-386-mingw-obj\",\n \t\tFileHeader{0x014c, 0x000c, 0x0, 0x64a, 0x1e, 0x0, 0x104},\n \t\t[]*SectionHeader{\n-\t\t\t&SectionHeader{\".text\", 0, 0, 36, 500, 1440, 0, 3, 0, 0x60300020},\n-\t\t\t&SectionHeader{\".data\", 0, 0, 0, 0, 0, 0, 0, 0, 3224371264},\n-\t\t\t&SectionHeader{\".bss\", 0, 0, 0, 0, 0, 0, 0, 0, 3224371328},\n-\t\t\t&SectionHeader{\".debug_abbrev\", 0, 0, 137, 536, 0, 0, 0, 0, 0x42100000},\n-\t\t\t&SectionHeader{\".debug_info\", 0, 0, 418, 673, 1470, 0, 7, 0, 1108344832},\n-\t\t\t&SectionHeader{\".debug_line\", 0, 0, 128, 1091, 1540, 0, 1, 0, 1108344832},\n-\t\t\t&SectionHeader{\".rdata\", 0, 0, 16, 1219, 0, 0, 0, 0, 1076887616},\n-\t\t\t&SectionHeader{\".debug_frame\", 0, 0, 52, 1235, 1550, 0, 2, 0, 1110441984},\n-\t\t\t&SectionHeader{\".debug_loc\", 0, 0, 56, 1287, 0, 0, 0, 0, 1108344832},\n-\t\t\t&SectionHeader{\".debug_pubnames\", 0, 0, 27, 1343, 1570, 0, 1, 0, 1108344832},\n-\t\t\t&SectionHeader{\".debug_pubtypes\", 0, 0, 38, 1370, 1580, 0, 1, 0, 1108344832},\n-\t\t\t&SectionHeader{\".debug_aranges\", 0, 0, 32, 1408, 1590, 0, 2, 0, 1108344832},\n+\t\t\t{\".text\", 0, 0, 36, 500, 1440, 0, 3, 0, 0x60300020},\n+\t\t\t{\".data\", 0, 0, 0, 0, 0, 0, 0, 0, 3224371264},\n+\t\t\t{\".bss\", 0, 0, 0, 0, 0, 0, 0, 0, 3224371328},\n+\t\t\t{\".debug_abbrev\", 0, 0, 137, 536, 0, 0, 0, 0, 0x42100000},\n+\t\t\t{\".debug_info\", 0, 0, 418, 673, 1470, 0, 7, 0, 1108344832},\n+\t\t\t{\".debug_line\", 0, 0, 128, 1091, 1540, 0, 1, 0, 1108344832},\n+\t\t\t{\".rdata\", 0, 0, 16, 1219, 0, 0, 0, 0, 1076887616},\n+\t\t\t{\".debug_frame\", 0, 0, 52, 1235, 1550, 0, 2, 0, 1110441984},\n+\t\t\t{\".debug_loc\", 0, 0, 56, 1287, 0, 0, 0, 0, 1108344832},\n+\t\t\t{\".debug_pubnames\", 0, 0, 27, 1343, 1570, 0, 1, 0, 1108344832},\n+\t\t\t{\".debug_pubtypes\", 0, 0, 38, 1370, 1580, 0, 1, 0, 1108344832},\n+\t\t\t{\".debug_aranges\", 0, 0, 32, 1408, 1590, 0, 2, 0, 1108344832},\n \t\t},\n \t},\n \t{\n \t\t\"testdata/gcc-386-mingw-exec\",\n \t\tFileHeader{0x014c, 0x000f, 0x4c6a1b60, 0x3c00, 0x282, 0xe0, 0x107},\n \t\t[]*SectionHeader{\n-\t\t\t&SectionHeader{Name: \".text\", VirtualSize: 0xcd8, VirtualAddress: 0x1000, Size: 0xe00, Offset: 0x400, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0x60500060},\n-\t\t\t&SectionHeader{Name: \".data\", VirtualSize: 0x10, VirtualAddress: 0x2000, Size: 0x200, Offset: 0x1200, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0xc0300040},\n-\t\t\t&SectionHeader{Name: \".rdata\", VirtualSize: 0x120, VirtualAddress: 0x3000, Size: 0x200, Offset: 0x1400, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0x40300040},\n-\t\t\t&SectionHeader{Name: \".bss\", VirtualSize: 0xdc, VirtualAddress: 0x4000, Size: 0x0, Offset: 0x0, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0xc0400080},\n-\t\t\t&SectionHeader{Name: \".idata\", VirtualSize: 0x3c8, VirtualAddress: 0x5000, Size: 0x400, Offset: 0x1600, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0xc0300040},\n-\t\t\t&SectionHeader{Name: \".CRT\", VirtualSize: 0x18, VirtualAddress: 0x6000, Size: 0x200, Offset: 0x1a00, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0xc0300040},\n-\t\t\t&SectionHeader{Name: \".tls\", VirtualSize: 0x20, VirtualAddress: 0x7000, Size: 0x200, Offset: 0x1c00, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0xc0300040},\n-\t\t\t&SectionHeader{Name: \".debug_aranges\", VirtualSize: 0x20, VirtualAddress: 0x8000, Size: 0x200, Offset: 0x1e00, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0x42100000},\n-\t\t\t&SectionHeader{Name: \".debug_pubnames\", VirtualSize: 0x51, VirtualAddress: 0x9000, Size: 0x200, Offset: 0x2000, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0x42100000},\n-\t\t\t&SectionHeader{Name: \".debug_pubtypes\", VirtualSize: 0x91, VirtualAddress: 0xa000, Size: 0x200, Offset: 0x2200, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0x42100000},\n-\t\t\t&SectionHeader{Name: \".debug_info\", VirtualSize: 0xe22, VirtualAddress: 0xb000, Size: 0x1000, Offset: 0x2400, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0x42100000},\n-\t\t\t&SectionHeader{Name: \".debug_abbrev\", VirtualSize: 0x157, VirtualAddress: 0xc000, Size: 0x200, Offset: 0x3400, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0x42100000},\n-\t\t\t&SectionHeader{Name: \".debug_line\", VirtualSize: 0x144, VirtualAddress: 0xd000, Size: 0x200, Offset: 0x3600, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0x42100000},\n-\t\t\t&SectionHeader{Name: \".debug_frame\", VirtualSize: 0x34, VirtualAddress: 0xe000, Size: 0x200, Offset: 0x3800, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0x42300000},\n-\t\t\t&SectionHeader{Name: \".debug_loc\", VirtualSize: 0x38, VirtualAddress: 0xf000, Size: 0x200, Offset: 0x3a00, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0x42100000},\n+\t\t\t{Name: \".text\", VirtualSize: 0xcd8, VirtualAddress: 0x1000, Size: 0xe00, Offset: 0x400, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0x60500060},\n+\t\t\t{Name: \".data\", VirtualSize: 0x10, VirtualAddress: 0x2000, Size: 0x200, Offset: 0x1200, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0xc0300040},\n+\t\t\t{Name: \".rdata\", VirtualSize: 0x120, VirtualAddress: 0x3000, Size: 0x200, Offset: 0x1400, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0x40300040},\n+\t\t\t{Name: \".bss\", VirtualSize: 0xdc, VirtualAddress: 0x4000, Size: 0x0, Offset: 0x0, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0xc0400080},\n+\t\t\t{Name: \".idata\", VirtualSize: 0x3c8, VirtualAddress: 0x5000, Size: 0x400, Offset: 0x1600, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0xc0300040},\n+\t\t\t{Name: \".CRT\", VirtualSize: 0x18, VirtualAddress: 0x6000, Size: 0x200, Offset: 0x1a00, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0xc0300040},\n+\t\t\t{Name: \".tls\", VirtualSize: 0x20, VirtualAddress: 0x7000, Size: 0x200, Offset: 0x1c00, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0xc0300040},\n+\t\t\t{Name: \".debug_aranges\", VirtualSize: 0x20, VirtualAddress: 0x8000, Size: 0x200, Offset: 0x1e00, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0x42100000},\n+\t\t\t{Name: \".debug_pubnames\", VirtualSize: 0x51, VirtualAddress: 0x9000, Size: 0x200, Offset: 0x2000, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0x42100000},\n+\t\t\t{Name: \".debug_pubtypes\", VirtualSize: 0x91, VirtualAddress: 0xa000, Size: 0x200, Offset: 0x2200, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0x42100000},\n+\t\t\t{Name: \".debug_info\", VirtualSize: 0xe22, VirtualAddress: 0xb000, Size: 0x1000, Offset: 0x2400, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0x42100000},\n+\t\t\t{Name: \".debug_abbrev\", VirtualSize: 0x157, VirtualAddress: 0xc000, Size: 0x200, Offset: 0x3400, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0x42100000},\n+\t\t\t{Name: \".debug_line\", VirtualSize: 0x144, VirtualAddress: 0xd000, Size: 0x200, Offset: 0x3600, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0x42100000},\n+\t\t\t{Name: \".debug_frame\", VirtualSize: 0x34, VirtualAddress: 0xe000, Size: 0x200, Offset: 0x3800, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0x42300000},\n+\t\t\t{Name: \".debug_loc\", VirtualSize: 0x38, VirtualAddress: 0xf000, Size: 0x200, Offset: 0x3a00, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0x42100000},\n \t\t},\n \t},\n }"}, {"sha": "7d004b5e5d74eb0c73d86de59770edf1c58d207d", "filename": "libgo/go/encoding/ascii85/ascii85.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fascii85%2Fascii85.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fascii85%2Fascii85.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fascii85%2Fascii85.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -168,7 +168,7 @@ func (e *encoder) Close() error {\n type CorruptInputError int64\n \n func (e CorruptInputError) Error() string {\n-\treturn \"illegal ascii85 data at input byte \" + strconv.Itoa64(int64(e))\n+\treturn \"illegal ascii85 data at input byte \" + strconv.FormatInt(int64(e), 10)\n }\n \n // Decode decodes src into dst, returning both the number"}, {"sha": "09f94139f906218200b69f4e6cceef1c0c5647bf", "filename": "libgo/go/encoding/asn1/asn1_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -225,19 +225,19 @@ func TestUTCTime(t *testing.T) {\n \t\tret, err := parseUTCTime([]byte(test.in))\n \t\tif err != nil {\n \t\t\tif test.ok {\n-\t\t\t\tt.Errorf(\"#%d: parseUTCTime(%q) = error %v\", i, err)\n+\t\t\t\tt.Errorf(\"#%d: parseUTCTime(%q) = error %v\", i, test.in, err)\n \t\t\t}\n \t\t\tcontinue\n \t\t}\n \t\tif !test.ok {\n-\t\t\tt.Errorf(\"#%d: parseUTCTime(%q) succeeded, should have failed\", i)\n+\t\t\tt.Errorf(\"#%d: parseUTCTime(%q) succeeded, should have failed\", i, test.in)\n \t\t\tcontinue\n \t\t}\n \t\tconst format = \"Jan _2 15:04:05 -0700 2006\" // ignore zone name, just offset\n \t\thave := ret.Format(format)\n \t\twant := test.out.Format(format)\n \t\tif have != want {\n-\t\t\tt.Errorf(\"#%d: parseUTCTime(%q) = %s, want %s\", test.in, have, want)\n+\t\t\tt.Errorf(\"#%d: parseUTCTime(%q) = %s, want %s\", i, test.in, have, want)\n \t\t}\n \t}\n }"}, {"sha": "f7cb3acbb8693b919389caa74ba66565264c8b3b", "filename": "libgo/go/encoding/asn1/common.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fasn1%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fasn1%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fcommon.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -98,7 +98,7 @@ func parseFieldParameters(str string) (ret fieldParameters) {\n \t\tcase part == \"printable\":\n \t\t\tret.stringType = tagPrintableString\n \t\tcase strings.HasPrefix(part, \"default:\"):\n-\t\t\ti, err := strconv.Atoi64(part[8:])\n+\t\t\ti, err := strconv.ParseInt(part[8:], 10, 64)\n \t\t\tif err == nil {\n \t\t\t\tret.defaultValue = new(int64)\n \t\t\t\t*ret.defaultValue = i"}, {"sha": "c75c7c19d15d15dccb74536bec4420a3e1b6c614", "filename": "libgo/go/encoding/base32/base32.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -216,7 +216,7 @@ func (enc *Encoding) EncodedLen(n int) int { return (n + 4) / 5 * 8 }\n type CorruptInputError int64\n \n func (e CorruptInputError) Error() string {\n-\treturn \"illegal base32 data at input byte \" + strconv.Itoa64(int64(e))\n+\treturn \"illegal base32 data at input byte \" + strconv.FormatInt(int64(e), 10)\n }\n \n // decode is like Decode but returns an additional 'end' value, which"}, {"sha": "889b565e3f5a475b6c86672b5af6184c030c2c4c", "filename": "libgo/go/encoding/base64/base64.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -203,7 +203,7 @@ func (enc *Encoding) EncodedLen(n int) int { return (n + 2) / 3 * 4 }\n type CorruptInputError int64\n \n func (e CorruptInputError) Error() string {\n-\treturn \"illegal base64 data at input byte \" + strconv.Itoa64(int64(e))\n+\treturn \"illegal base64 data at input byte \" + strconv.FormatInt(int64(e), 10)\n }\n \n // decode is like Decode but returns an additional 'end' value, which"}, {"sha": "d383213ce8734084ace0e94f13a117a754a256ea", "filename": "libgo/go/encoding/git85/git.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fgit85%2Fgit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fgit85%2Fgit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgit85%2Fgit.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -15,7 +15,7 @@ import (\n type CorruptInputError int64\n \n func (e CorruptInputError) Error() string {\n-\treturn \"illegal git85 data at input byte \" + strconv.Itoa64(int64(e))\n+\treturn \"illegal git85 data at input byte \" + strconv.FormatInt(int64(e), 10)\n }\n \n const encode = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{|}~\""}, {"sha": "a15b5a1f9a1ee20abbb6e3d8b7eb2d05e453250d", "filename": "libgo/go/encoding/gob/encoder.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -119,7 +119,9 @@ func (enc *Encoder) sendActualType(w io.Writer, state *encoderState, ut *userTyp\n \tswitch st := actual; st.Kind() {\n \tcase reflect.Struct:\n \t\tfor i := 0; i < st.NumField(); i++ {\n-\t\t\tenc.sendType(w, state, st.Field(i).Type)\n+\t\t\tif isExported(st.Field(i).Name) {\n+\t\t\t\tenc.sendType(w, state, st.Field(i).Type)\n+\t\t\t}\n \t\t}\n \tcase reflect.Array, reflect.Slice:\n \t\tenc.sendType(w, state, st.Elem())"}, {"sha": "5bc957bb37011eb144eaf6248da2e776f1d84f8c", "filename": "libgo/go/encoding/gob/encoder_test.go", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -662,3 +662,19 @@ func TestSequentialDecoder(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+// Should be able to have unrepresentable fields (chan, func) as long as they\n+// are unexported.\n+type Bug2 struct {\n+\tA int\n+\tb chan int\n+}\n+\n+func TestUnexportedChan(t *testing.T) {\n+\tb := Bug2{23, make(chan int)}\n+\tvar stream bytes.Buffer\n+\tenc := NewEncoder(&stream)\n+\tif err := enc.Encode(b); err != nil {\n+\t\tt.Fatalf(\"error encoding unexported channel: %s\", err)\n+\t}\n+}"}, {"sha": "0a700926296fe9f37c3099e35f0b19512f3aa96b", "filename": "libgo/go/encoding/json/decode.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -642,31 +642,31 @@ func (d *decodeState) literalStore(item []byte, v reflect.Value) {\n \t\tdefault:\n \t\t\td.error(&UnmarshalTypeError{\"number\", v.Type()})\n \t\tcase reflect.Interface:\n-\t\t\tn, err := strconv.Atof64(s)\n+\t\t\tn, err := strconv.ParseFloat(s, 64)\n \t\t\tif err != nil {\n \t\t\t\td.saveError(&UnmarshalTypeError{\"number \" + s, v.Type()})\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tv.Set(reflect.ValueOf(n))\n \n \t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n-\t\t\tn, err := strconv.Atoi64(s)\n+\t\t\tn, err := strconv.ParseInt(s, 10, 64)\n \t\t\tif err != nil || v.OverflowInt(n) {\n \t\t\t\td.saveError(&UnmarshalTypeError{\"number \" + s, v.Type()})\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tv.SetInt(n)\n \n \t\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n-\t\t\tn, err := strconv.Atoui64(s)\n+\t\t\tn, err := strconv.ParseUint(s, 10, 64)\n \t\t\tif err != nil || v.OverflowUint(n) {\n \t\t\t\td.saveError(&UnmarshalTypeError{\"number \" + s, v.Type()})\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tv.SetUint(n)\n \n \t\tcase reflect.Float32, reflect.Float64:\n-\t\t\tn, err := strconv.AtofN(s, v.Type().Bits())\n+\t\t\tn, err := strconv.ParseFloat(s, v.Type().Bits())\n \t\t\tif err != nil || v.OverflowFloat(n) {\n \t\t\t\td.saveError(&UnmarshalTypeError{\"number \" + s, v.Type()})\n \t\t\t\tbreak\n@@ -798,7 +798,7 @@ func (d *decodeState) literalInterface() interface{} {\n \t\tif c != '-' && (c < '0' || c > '9') {\n \t\t\td.error(errPhase)\n \t\t}\n-\t\tn, err := strconv.Atof64(string(item))\n+\t\tn, err := strconv.ParseFloat(string(item), 64)\n \t\tif err != nil {\n \t\t\td.saveError(&UnmarshalTypeError{\"number \" + string(item), reflect.TypeOf(0.0)})\n \t\t}\n@@ -813,7 +813,7 @@ func getu4(s []byte) rune {\n \tif len(s) < 6 || s[0] != '\\\\' || s[1] != 'u' {\n \t\treturn -1\n \t}\n-\tr, err := strconv.Btoui64(string(s[2:6]), 16)\n+\tr, err := strconv.ParseUint(string(s[2:6]), 16, 64)\n \tif err != nil {\n \t\treturn -1\n \t}"}, {"sha": "bf3953eb051f908ee9299f318afec1654408cf55", "filename": "libgo/go/encoding/json/decode_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -345,12 +345,12 @@ var allValue = All{\n \t\t\"18\": {Tag: \"tag18\"},\n \t},\n \tMapP: map[string]*Small{\n-\t\t\"19\": &Small{Tag: \"tag19\"},\n+\t\t\"19\": {Tag: \"tag19\"},\n \t\t\"20\": nil,\n \t},\n \tEmptyMap:    map[string]Small{},\n \tSlice:       []Small{{Tag: \"tag20\"}, {Tag: \"tag21\"}},\n-\tSliceP:      []*Small{&Small{Tag: \"tag22\"}, nil, &Small{Tag: \"tag23\"}},\n+\tSliceP:      []*Small{{Tag: \"tag22\"}, nil, {Tag: \"tag23\"}},\n \tEmptySlice:  []Small{},\n \tStringSlice: []string{\"str24\", \"str25\", \"str26\"},\n \tByteSlice:   []byte{27, 28, 29},"}, {"sha": "69deaf2a40d3ee0458abb0c70e40853b9a571521", "filename": "libgo/go/encoding/json/encode.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -275,13 +275,13 @@ func (e *encodeState) reflectValueQuoted(v reflect.Value, quoted bool) {\n \t\t}\n \n \tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n-\t\twriteString(e, strconv.Itoa64(v.Int()))\n+\t\twriteString(e, strconv.FormatInt(v.Int(), 10))\n \n \tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n-\t\twriteString(e, strconv.Uitoa64(v.Uint()))\n+\t\twriteString(e, strconv.FormatUint(v.Uint(), 10))\n \n \tcase reflect.Float32, reflect.Float64:\n-\t\twriteString(e, strconv.FtoaN(v.Float(), 'g', -1, v.Type().Bits()))\n+\t\twriteString(e, strconv.FormatFloat(v.Float(), 'g', -1, v.Type().Bits()))\n \n \tcase reflect.String:\n \t\tif quoted {"}, {"sha": "e94fdbc531f29f0f43025279df7e34175cd45e85", "filename": "libgo/go/encoding/xml/marshal.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -173,15 +173,15 @@ func (p *printer) marshalValue(val reflect.Value, name string) error {\n \n \tswitch k := val.Kind(); k {\n \tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n-\t\tp.WriteString(strconv.Itoa64(val.Int()))\n+\t\tp.WriteString(strconv.FormatInt(val.Int(), 10))\n \tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n-\t\tp.WriteString(strconv.Uitoa64(val.Uint()))\n+\t\tp.WriteString(strconv.FormatUint(val.Uint(), 10))\n \tcase reflect.Float32, reflect.Float64:\n-\t\tp.WriteString(strconv.Ftoa64(val.Float(), 'g', -1))\n+\t\tp.WriteString(strconv.FormatFloat(val.Float(), 'g', -1, 64))\n \tcase reflect.String:\n \t\tEscape(p, []byte(val.String()))\n \tcase reflect.Bool:\n-\t\tp.WriteString(strconv.Btoa(val.Bool()))\n+\t\tp.WriteString(strconv.FormatBool(val.Bool()))\n \tcase reflect.Array:\n \t\t// will be [...]byte\n \t\tbytes := make([]byte, val.Len())"}, {"sha": "804076580155a77dd22ea07bcf028905a2be4ac4", "filename": "libgo/go/encoding/xml/marshal_test.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -160,19 +160,19 @@ var marshalTests = []struct {\n \t\t\tAge:   1,\n \t\t\tDrive: ImprobabilityDrive,\n \t\t\tPassenger: []*Passenger{\n-\t\t\t\t&Passenger{\n+\t\t\t\t{\n \t\t\t\t\tName:   []string{\"Zaphod\", \"Beeblebrox\"},\n \t\t\t\t\tWeight: 7.25,\n \t\t\t\t},\n-\t\t\t\t&Passenger{\n+\t\t\t\t{\n \t\t\t\t\tName:   []string{\"Trisha\", \"McMillen\"},\n \t\t\t\t\tWeight: 5.5,\n \t\t\t\t},\n-\t\t\t\t&Passenger{\n+\t\t\t\t{\n \t\t\t\t\tName:   []string{\"Ford\", \"Prefect\"},\n \t\t\t\t\tWeight: 7,\n \t\t\t\t},\n-\t\t\t\t&Passenger{\n+\t\t\t\t{\n \t\t\t\t\tName:   []string{\"Arthur\", \"Dent\"},\n \t\t\t\t\tWeight: 6.75,\n \t\t\t\t},\n@@ -326,12 +326,12 @@ var marshalErrorTests = []struct {\n \t\t\t\"question\": \"What do you get when you multiply six by nine?\",\n \t\t\t\"answer\":   \"42\",\n \t\t},\n-\t\tErr:  \"xml: unsupported type: map[string] string\",\n+\t\tErr:  \"xml: unsupported type: map[string]string\",\n \t\tKind: reflect.Map,\n \t},\n \t{\n \t\tValue: map[*Ship]bool{nil: false},\n-\t\tErr:   \"xml: unsupported type: map[*xml.Ship] bool\",\n+\t\tErr:   \"xml: unsupported type: map[*xml.Ship]bool\",\n \t\tKind:  reflect.Map,\n \t},\n }"}, {"sha": "6dd36541000820c0ec16aeec89ac3a21864fc3cd", "filename": "libgo/go/encoding/xml/read.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -486,19 +486,19 @@ func copyValue(dst reflect.Value, src []byte) (err error) {\n \t// Helper functions for integer and unsigned integer conversions\n \tvar itmp int64\n \tgetInt64 := func() bool {\n-\t\titmp, err = strconv.Atoi64(string(src))\n+\t\titmp, err = strconv.ParseInt(string(src), 10, 64)\n \t\t// TODO: should check sizes\n \t\treturn err == nil\n \t}\n \tvar utmp uint64\n \tgetUint64 := func() bool {\n-\t\tutmp, err = strconv.Atoui64(string(src))\n+\t\tutmp, err = strconv.ParseUint(string(src), 10, 64)\n \t\t// TODO: check for overflow?\n \t\treturn err == nil\n \t}\n \tvar ftmp float64\n \tgetFloat64 := func() bool {\n-\t\tftmp, err = strconv.Atof64(string(src))\n+\t\tftmp, err = strconv.ParseFloat(string(src), 64)\n \t\t// TODO: check for overflow?\n \t\treturn err == nil\n \t}\n@@ -525,7 +525,7 @@ func copyValue(dst reflect.Value, src []byte) (err error) {\n \t\t}\n \t\tt.SetFloat(ftmp)\n \tcase reflect.Bool:\n-\t\tvalue, err := strconv.Atob(strings.TrimSpace(string(src)))\n+\t\tvalue, err := strconv.ParseBool(strings.TrimSpace(string(src)))\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}"}, {"sha": "d001c4089236aad6156c4193a3e920f51d6c8b96", "filename": "libgo/go/encoding/xml/xml.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -889,9 +889,9 @@ Input:\n \t\t\t\tvar n uint64\n \t\t\t\tvar err error\n \t\t\t\tif i >= 3 && s[1] == 'x' {\n-\t\t\t\t\tn, err = strconv.Btoui64(s[2:], 16)\n+\t\t\t\t\tn, err = strconv.ParseUint(s[2:], 16, 64)\n \t\t\t\t} else {\n-\t\t\t\t\tn, err = strconv.Btoui64(s[1:], 10)\n+\t\t\t\t\tn, err = strconv.ParseUint(s[1:], 10, 64)\n \t\t\t\t}\n \t\t\t\tif err == nil && n <= unicode.MaxRune {\n \t\t\t\t\ttext = string(n)"}, {"sha": "9a97831716b473067fbfaab95876bd9822cc3d27", "filename": "libgo/go/exp/norm/maketables.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -226,7 +226,7 @@ func parseDecomposition(s string, skipfirst bool) (a []rune, e error) {\n \t\tdecomp = decomp[1:]\n \t}\n \tfor _, d := range decomp {\n-\t\tpoint, err := strconv.Btoui64(d, 16)\n+\t\tpoint, err := strconv.ParseUint(d, 16, 64)\n \t\tif err != nil {\n \t\t\treturn a, err\n \t\t}\n@@ -240,7 +240,7 @@ func parseCharacter(line string) {\n \tif len(field) != NumField {\n \t\tlogger.Fatalf(\"%5s: %d fields (expected %d)\\n\", line, len(field), NumField)\n \t}\n-\tx, err := strconv.Btoui64(field[FCodePoint], 16)\n+\tx, err := strconv.ParseUint(field[FCodePoint], 16, 64)\n \tpoint := int(x)\n \tif err != nil {\n \t\tlogger.Fatalf(\"%.5s...: %s\", line, err)\n@@ -264,7 +264,7 @@ func parseCharacter(line string) {\n \tif state != SLast {\n \t\tfirstChar = lastChar\n \t}\n-\tx, err = strconv.Atoui64(field[FCanonicalCombiningClass])\n+\tx, err = strconv.ParseUint(field[FCanonicalCombiningClass], 10, 64)\n \tif err != nil {\n \t\tlogger.Fatalf(\"%U: bad ccc field: %s\", int(x), err)\n \t}\n@@ -336,7 +336,7 @@ func parseExclusion(line string) int {\n \tif len(matches) != 2 {\n \t\tlogger.Fatalf(\"%s: %d matches (expected 1)\\n\", line, len(matches))\n \t}\n-\tpoint, err := strconv.Btoui64(matches[1], 16)\n+\tpoint, err := strconv.ParseUint(matches[1], 16, 64)\n \tif err != nil {\n \t\tlogger.Fatalf(\"%.5s...: %s\", line, err)\n \t}\n@@ -792,13 +792,13 @@ func testDerived() {\n \t\t\tcontinue\n \t\t}\n \t\trng := strings.Split(qc[1], \"..\")\n-\t\ti, err := strconv.Btoui64(rng[0], 16)\n+\t\ti, err := strconv.ParseUint(rng[0], 16, 64)\n \t\tif err != nil {\n \t\t\tlog.Fatal(err)\n \t\t}\n \t\tj := i\n \t\tif len(rng) > 1 {\n-\t\t\tj, err = strconv.Btoui64(rng[1], 16)\n+\t\t\tj, err = strconv.ParseUint(rng[1], 16, 64)\n \t\t\tif err != nil {\n \t\t\t\tlog.Fatal(err)\n \t\t\t}"}, {"sha": "d214ce11bc2b02a4534f75d8e4b64fa9f9c0b009", "filename": "libgo/go/exp/norm/normregtest.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -171,7 +171,7 @@ func loadTestData() {\n \t\tcounter++\n \t\tfor j := 1; j < len(m)-1; j++ {\n \t\t\tfor _, split := range strings.Split(m[j], \" \") {\n-\t\t\t\tr, err := strconv.Btoui64(split, 16)\n+\t\t\t\tr, err := strconv.ParseUint(split, 16, 64)\n \t\t\t\tif err != nil {\n \t\t\t\t\tlogger.Fatal(err)\n \t\t\t\t}"}, {"sha": "24315a0d35136beefa1781d3c817f4fa560e531f", "filename": "libgo/go/exp/sql/convert.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fsql%2Fconvert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fsql%2Fconvert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fconvert.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -95,7 +95,7 @@ func convertAssign(dest, src interface{}) error {\n \tswitch dv.Kind() {\n \tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n \t\ts := asString(src)\n-\t\ti64, err := strconv.Atoi64(s)\n+\t\ti64, err := strconv.ParseInt(s, 10, 64)\n \t\tif err != nil {\n \t\t\treturn fmt.Errorf(\"converting string %q to a %s: %v\", s, dv.Kind(), err)\n \t\t}\n@@ -106,7 +106,7 @@ func convertAssign(dest, src interface{}) error {\n \t\treturn nil\n \tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n \t\ts := asString(src)\n-\t\tu64, err := strconv.Atoui64(s)\n+\t\tu64, err := strconv.ParseUint(s, 10, 64)\n \t\tif err != nil {\n \t\t\treturn fmt.Errorf(\"converting string %q to a %s: %v\", s, dv.Kind(), err)\n \t\t}\n@@ -117,7 +117,7 @@ func convertAssign(dest, src interface{}) error {\n \t\treturn nil\n \tcase reflect.Float32, reflect.Float64:\n \t\ts := asString(src)\n-\t\tf64, err := strconv.Atof64(s)\n+\t\tf64, err := strconv.ParseFloat(s, 64)\n \t\tif err != nil {\n \t\t\treturn fmt.Errorf(\"converting string %q to a %s: %v\", s, dv.Kind(), err)\n \t\t}"}, {"sha": "086b529c84f1d74525ea891e6314f2039e41a5eb", "filename": "libgo/go/exp/sql/driver/types.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Ftypes.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -54,13 +54,13 @@ func (boolType) ConvertValue(src interface{}) (interface{}, error) {\n \tcase bool:\n \t\treturn s, nil\n \tcase string:\n-\t\tb, err := strconv.Atob(s)\n+\t\tb, err := strconv.ParseBool(s)\n \t\tif err != nil {\n \t\t\treturn nil, fmt.Errorf(\"sql/driver: couldn't convert %q into type bool\", s)\n \t\t}\n \t\treturn b, nil\n \tcase []byte:\n-\t\tb, err := strconv.Atob(string(s))\n+\t\tb, err := strconv.ParseBool(string(s))\n \t\tif err != nil {\n \t\t\treturn nil, fmt.Errorf(\"sql/driver: couldn't convert %q into type bool\", s)\n \t\t}"}, {"sha": "d91929aa99adb5e001aec5e7603804acd698fc89", "filename": "libgo/go/exp/ssh/cipher.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fssh%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fssh%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fcipher.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -77,12 +77,12 @@ var DefaultCipherOrder = []string{\n var cipherModes = map[string]*cipherMode{\n \t// Ciphers from RFC4344, which introduced many CTR-based ciphers. Algorithms\n \t// are defined in the order specified in the RFC.\n-\t\"aes128-ctr\": &cipherMode{16, aes.BlockSize, 0, newAESCTR},\n-\t\"aes192-ctr\": &cipherMode{24, aes.BlockSize, 0, newAESCTR},\n-\t\"aes256-ctr\": &cipherMode{32, aes.BlockSize, 0, newAESCTR},\n+\t\"aes128-ctr\": {16, aes.BlockSize, 0, newAESCTR},\n+\t\"aes192-ctr\": {24, aes.BlockSize, 0, newAESCTR},\n+\t\"aes256-ctr\": {32, aes.BlockSize, 0, newAESCTR},\n \n \t// Ciphers from RFC4345, which introduces security-improved arcfour ciphers.\n \t// They are defined in the order specified in the RFC.\n-\t\"arcfour128\": &cipherMode{16, 0, 1536, newRC4},\n-\t\"arcfour256\": &cipherMode{32, 0, 1536, newRC4},\n+\t\"arcfour128\": {16, 0, 1536, newRC4},\n+\t\"arcfour256\": {32, 0, 1536, newRC4},\n }"}, {"sha": "d89b908cdcf47ddb952da9a35c5a05c3bccb96c1", "filename": "libgo/go/exp/ssh/client.go", "status": "modified", "additions": 53, "deletions": 26, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -200,7 +200,7 @@ func (c *ClientConn) mainLoop() {\n \t\t\tpeersId := uint32(packet[1])<<24 | uint32(packet[2])<<16 | uint32(packet[3])<<8 | uint32(packet[4])\n \t\t\tif length := int(packet[5])<<24 | int(packet[6])<<16 | int(packet[7])<<8 | int(packet[8]); length > 0 {\n \t\t\t\tpacket = packet[9:]\n-\t\t\t\tc.getChan(peersId).data <- packet[:length]\n+\t\t\t\tc.getChan(peersId).stdout.data <- packet[:length]\n \t\t\t}\n \t\tcase msgChannelExtendedData:\n \t\t\tif len(packet) < 13 {\n@@ -215,7 +215,7 @@ func (c *ClientConn) mainLoop() {\n \t\t\t\t// for stderr on interactive sessions. Other data types are\n \t\t\t\t// silently discarded.\n \t\t\t\tif datatype == 1 {\n-\t\t\t\t\tc.getChan(peersId).dataExt <- packet[:length]\n+\t\t\t\t\tc.getChan(peersId).stderr.data <- packet[:length]\n \t\t\t\t}\n \t\t\t}\n \t\tdefault:\n@@ -228,9 +228,9 @@ func (c *ClientConn) mainLoop() {\n \t\t\t\tc.getChan(msg.PeersId).msg <- msg\n \t\t\tcase *channelCloseMsg:\n \t\t\t\tch := c.getChan(msg.PeersId)\n-\t\t\t\tclose(ch.win)\n-\t\t\t\tclose(ch.data)\n-\t\t\t\tclose(ch.dataExt)\n+\t\t\t\tclose(ch.stdin.win)\n+\t\t\t\tclose(ch.stdout.data)\n+\t\t\t\tclose(ch.stderr.data)\n \t\t\t\tc.chanlist.remove(msg.PeersId)\n \t\t\tcase *channelEOFMsg:\n \t\t\t\tc.getChan(msg.PeersId).msg <- msg\n@@ -241,7 +241,7 @@ func (c *ClientConn) mainLoop() {\n \t\t\tcase *channelRequestMsg:\n \t\t\t\tc.getChan(msg.PeersId).msg <- msg\n \t\t\tcase *windowAdjustMsg:\n-\t\t\t\tc.getChan(msg.PeersId).win <- int(msg.AdditionalBytes)\n+\t\t\t\tc.getChan(msg.PeersId).stdin.win <- int(msg.AdditionalBytes)\n \t\t\tdefault:\n \t\t\t\tfmt.Printf(\"mainLoop: unhandled message %T: %v\\n\", msg, msg)\n \t\t\t}\n@@ -290,21 +290,49 @@ func (c *ClientConfig) rand() io.Reader {\n type clientChan struct {\n \tpacketWriter\n \tid, peersId uint32\n-\tdata        chan []byte      // receives the payload of channelData messages\n-\tdataExt     chan []byte      // receives the payload of channelExtendedData messages\n-\twin         chan int         // receives window adjustments\n+\tstdin       *chanWriter      // receives window adjustments\n+\tstdout      *chanReader      // receives the payload of channelData messages\n+\tstderr      *chanReader      // receives the payload of channelExtendedData messages\n \tmsg         chan interface{} // incoming messages\n }\n \n+// newClientChan returns a partially constructed *clientChan\n+// using the local id provided. To be usable clientChan.peersId \n+// needs to be assigned once known.\n func newClientChan(t *transport, id uint32) *clientChan {\n-\treturn &clientChan{\n+\tc := &clientChan{\n \t\tpacketWriter: t,\n \t\tid:           id,\n-\t\tdata:         make(chan []byte, 16),\n-\t\tdataExt:      make(chan []byte, 16),\n-\t\twin:          make(chan int, 16),\n \t\tmsg:          make(chan interface{}, 16),\n \t}\n+\tc.stdin = &chanWriter{\n+\t\twin:        make(chan int, 16),\n+\t\tclientChan: c,\n+\t}\n+\tc.stdout = &chanReader{\n+\t\tdata:       make(chan []byte, 16),\n+\t\tclientChan: c,\n+\t}\n+\tc.stderr = &chanReader{\n+\t\tdata:       make(chan []byte, 16),\n+\t\tclientChan: c,\n+\t}\n+\treturn c\n+}\n+\n+// waitForChannelOpenResponse, if successful, fills out \n+// the peerId and records any initial window advertisement. \n+func (c *clientChan) waitForChannelOpenResponse() error {\n+\tswitch msg := (<-c.msg).(type) {\n+\tcase *channelOpenConfirmMsg:\n+\t\t// fixup peersId field\n+\t\tc.peersId = msg.MyId\n+\t\tc.stdin.win <- int(msg.MyWindow)\n+\t\treturn nil\n+\tcase *channelOpenFailureMsg:\n+\t\treturn errors.New(safeString(msg.Message))\n+\t}\n+\treturn errors.New(\"unexpected packet\")\n }\n \n // Close closes the channel. This does not close the underlying connection.\n@@ -355,10 +383,9 @@ func (c *chanlist) remove(id uint32) {\n \n // A chanWriter represents the stdin of a remote process.\n type chanWriter struct {\n-\twin          chan int // receives window adjustments\n-\tpeersId      uint32   // the peer's id\n-\trwin         int      // current rwin size\n-\tpacketWriter          // for sending channelDataMsg\n+\twin        chan int    // receives window adjustments\n+\trwin       int         // current rwin size\n+\tclientChan *clientChan // the channel backing this writer\n }\n \n // Write writes data to the remote process's standard input.\n@@ -372,31 +399,31 @@ func (w *chanWriter) Write(data []byte) (n int, err error) {\n \t\t\tw.rwin += win\n \t\t\tcontinue\n \t\t}\n+\t\tpeersId := w.clientChan.peersId\n \t\tn = len(data)\n \t\tpacket := make([]byte, 0, 9+n)\n \t\tpacket = append(packet, msgChannelData,\n-\t\t\tbyte(w.peersId>>24), byte(w.peersId>>16), byte(w.peersId>>8), byte(w.peersId),\n+\t\t\tbyte(peersId>>24), byte(peersId>>16), byte(peersId>>8), byte(peersId),\n \t\t\tbyte(n>>24), byte(n>>16), byte(n>>8), byte(n))\n-\t\terr = w.writePacket(append(packet, data...))\n+\t\terr = w.clientChan.writePacket(append(packet, data...))\n \t\tw.rwin -= n\n \t\treturn\n \t}\n \tpanic(\"unreachable\")\n }\n \n func (w *chanWriter) Close() error {\n-\treturn w.writePacket(marshal(msgChannelEOF, channelEOFMsg{w.peersId}))\n+\treturn w.clientChan.writePacket(marshal(msgChannelEOF, channelEOFMsg{w.clientChan.peersId}))\n }\n \n // A chanReader represents stdout or stderr of a remote process.\n type chanReader struct {\n \t// TODO(dfc) a fixed size channel may not be the right data structure.\n \t// If writes to this channel block, they will block mainLoop, making\n \t// it unable to receive new messages from the remote side.\n-\tdata         chan []byte // receives data from remote\n-\tpeersId      uint32      // the peer's id\n-\tpacketWriter             // for sending windowAdjustMsg\n-\tbuf          []byte\n+\tdata       chan []byte // receives data from remote\n+\tclientChan *clientChan // the channel backing this reader\n+\tbuf        []byte\n }\n \n // Read reads data from the remote process's stdout or stderr.\n@@ -407,10 +434,10 @@ func (r *chanReader) Read(data []byte) (int, error) {\n \t\t\tn := copy(data, r.buf)\n \t\t\tr.buf = r.buf[n:]\n \t\t\tmsg := windowAdjustMsg{\n-\t\t\t\tPeersId:         r.peersId,\n+\t\t\t\tPeersId:         r.clientChan.peersId,\n \t\t\t\tAdditionalBytes: uint32(n),\n \t\t\t}\n-\t\t\treturn n, r.writePacket(marshal(msgChannelWindowAdjust, msg))\n+\t\t\treturn n, r.clientChan.writePacket(marshal(msgChannelWindowAdjust, msg))\n \t\t}\n \t\tr.buf, ok = <-r.data\n \t\tif !ok {"}, {"sha": "1a382357b46e7100e3657d8d26d03dde93269134", "filename": "libgo/go/exp/ssh/client_auth.go", "status": "modified", "additions": 102, "deletions": 81, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -9,7 +9,7 @@ import (\n \t\"io\"\n )\n \n-// authenticate authenticates with the remote server. See RFC 4252. \n+// authenticate authenticates with the remote server. See RFC 4252.\n func (c *ClientConn) authenticate(session []byte) error {\n \t// initiate user auth session\n \tif err := c.writePacket(marshal(msgServiceRequest, serviceRequestMsg{serviceUserAuth})); err != nil {\n@@ -24,7 +24,7 @@ func (c *ClientConn) authenticate(session []byte) error {\n \t\treturn err\n \t}\n \t// during the authentication phase the client first attempts the \"none\" method\n-\t// then any untried methods suggested by the server. \n+\t// then any untried methods suggested by the server.\n \ttried, remain := make(map[string]bool), make(map[string]bool)\n \tfor auth := ClientAuth(new(noneAuth)); auth != nil; {\n \t\tok, methods, err := auth.auth(session, c.config.User, c.transport, c.config.rand())\n@@ -57,9 +57,9 @@ func (c *ClientConn) authenticate(session []byte) error {\n \n // A ClientAuth represents an instance of an RFC 4252 authentication method.\n type ClientAuth interface {\n-\t// auth authenticates user over transport t. \n+\t// auth authenticates user over transport t.\n \t// Returns true if authentication is successful.\n-\t// If authentication is not successful, a []string of alternative \n+\t// If authentication is not successful, a []string of alternative\n \t// method names is returned.\n \tauth(session []byte, user string, t *transport, rand io.Reader) (bool, []string, error)\n \n@@ -79,19 +79,7 @@ func (n *noneAuth) auth(session []byte, user string, t *transport, rand io.Reade\n \t\treturn false, nil, err\n \t}\n \n-\tpacket, err := t.readPacket()\n-\tif err != nil {\n-\t\treturn false, nil, err\n-\t}\n-\n-\tswitch packet[0] {\n-\tcase msgUserAuthSuccess:\n-\t\treturn true, nil, nil\n-\tcase msgUserAuthFailure:\n-\t\tmsg := decode(packet).(*userAuthFailureMsg)\n-\t\treturn false, msg.Methods, nil\n-\t}\n-\treturn false, nil, UnexpectedMessageError{msgUserAuthSuccess, packet[0]}\n+\treturn handleAuthResponse(t)\n }\n \n func (n *noneAuth) method() string {\n@@ -127,19 +115,7 @@ func (p *passwordAuth) auth(session []byte, user string, t *transport, rand io.R\n \t\treturn false, nil, err\n \t}\n \n-\tpacket, err := t.readPacket()\n-\tif err != nil {\n-\t\treturn false, nil, err\n-\t}\n-\n-\tswitch packet[0] {\n-\tcase msgUserAuthSuccess:\n-\t\treturn true, nil, nil\n-\tcase msgUserAuthFailure:\n-\t\tmsg := decode(packet).(*userAuthFailureMsg)\n-\t\treturn false, msg.Methods, nil\n-\t}\n-\treturn false, nil, UnexpectedMessageError{msgUserAuthSuccess, packet[0]}\n+\treturn handleAuthResponse(t)\n }\n \n func (p *passwordAuth) method() string {\n@@ -159,7 +135,7 @@ func ClientAuthPassword(impl ClientPassword) ClientAuth {\n \n // ClientKeyring implements access to a client key ring.\n type ClientKeyring interface {\n-\t// Key returns the i'th rsa.Publickey or dsa.Publickey, or nil if \n+\t// Key returns the i'th rsa.Publickey or dsa.Publickey, or nil if\n \t// no key exists at i.\n \tKey(i int) (key interface{}, err error)\n \n@@ -173,27 +149,28 @@ type publickeyAuth struct {\n \tClientKeyring\n }\n \n+type publickeyAuthMsg struct {\n+\tUser    string\n+\tService string\n+\tMethod  string\n+\t// HasSig indicates to the reciver packet that the auth request is signed and\n+\t// should be used for authentication of the request.\n+\tHasSig   bool\n+\tAlgoname string\n+\tPubkey   string\n+\t// Sig is defined as []byte so marshal will exclude it during validateKey\n+\tSig []byte `ssh:\"rest\"`\n+}\n+\n func (p *publickeyAuth) auth(session []byte, user string, t *transport, rand io.Reader) (bool, []string, error) {\n-\ttype publickeyAuthMsg struct {\n-\t\tUser    string\n-\t\tService string\n-\t\tMethod  string\n-\t\t// HasSig indicates to the reciver packet that the auth request is signed and\n-\t\t// should be used for authentication of the request.\n-\t\tHasSig   bool\n-\t\tAlgoname string\n-\t\tPubkey   string\n-\t\t// Sig is defined as []byte so marshal will exclude it during the query phase\n-\t\tSig []byte `ssh:\"rest\"`\n-\t}\n \n \t// Authentication is performed in two stages. The first stage sends an\n \t// enquiry to test if each key is acceptable to the remote. The second\n-\t// stage attempts to authenticate with the valid keys obtained in the \n+\t// stage attempts to authenticate with the valid keys obtained in the\n \t// first stage.\n \n \tvar index int\n-\t// a map of public keys to their index in the keyring \n+\t// a map of public keys to their index in the keyring\n \tvalidKeys := make(map[int]interface{})\n \tfor {\n \t\tkey, err := p.Key(index)\n@@ -204,33 +181,13 @@ func (p *publickeyAuth) auth(session []byte, user string, t *transport, rand io.\n \t\t\t// no more keys in the keyring\n \t\t\tbreak\n \t\t}\n-\t\tpubkey := serializePublickey(key)\n-\t\talgoname := algoName(key)\n-\t\tmsg := publickeyAuthMsg{\n-\t\t\tUser:     user,\n-\t\t\tService:  serviceSSH,\n-\t\t\tMethod:   p.method(),\n-\t\t\tHasSig:   false,\n-\t\t\tAlgoname: algoname,\n-\t\t\tPubkey:   string(pubkey),\n-\t\t}\n-\t\tif err := t.writePacket(marshal(msgUserAuthRequest, msg)); err != nil {\n-\t\t\treturn false, nil, err\n-\t\t}\n-\t\tpacket, err := t.readPacket()\n-\t\tif err != nil {\n-\t\t\treturn false, nil, err\n-\t\t}\n-\t\tswitch packet[0] {\n-\t\tcase msgUserAuthPubKeyOk:\n-\t\t\tmsg := decode(packet).(*userAuthPubKeyOkMsg)\n-\t\t\tif msg.Algo != algoname || msg.PubKey != string(pubkey) {\n-\t\t\t\tcontinue\n-\t\t\t}\n+\n+\t\tif ok, err := p.validateKey(key, user, t); ok {\n \t\t\tvalidKeys[index] = key\n-\t\tcase msgUserAuthFailure:\n-\t\tdefault:\n-\t\t\treturn false, nil, UnexpectedMessageError{msgUserAuthSuccess, packet[0]}\n+\t\t} else {\n+\t\t\tif err != nil {\n+\t\t\t\treturn false, nil, err\n+\t\t\t}\n \t\t}\n \t\tindex++\n \t}\n@@ -265,24 +222,61 @@ func (p *publickeyAuth) auth(session []byte, user string, t *transport, rand io.\n \t\tif err := t.writePacket(p); err != nil {\n \t\t\treturn false, nil, err\n \t\t}\n-\t\tpacket, err := t.readPacket()\n+\t\tsuccess, methods, err := handleAuthResponse(t)\n \t\tif err != nil {\n \t\t\treturn false, nil, err\n \t\t}\n+\t\tif success {\n+\t\t\treturn success, methods, err\n+\t\t}\n+\t}\n+\treturn false, methods, nil\n+}\n+\n+// validateKey validates the key provided it is acceptable to the server.\n+func (p *publickeyAuth) validateKey(key interface{}, user string, t *transport) (bool, error) {\n+\tpubkey := serializePublickey(key)\n+\talgoname := algoName(key)\n+\tmsg := publickeyAuthMsg{\n+\t\tUser:     user,\n+\t\tService:  serviceSSH,\n+\t\tMethod:   p.method(),\n+\t\tHasSig:   false,\n+\t\tAlgoname: algoname,\n+\t\tPubkey:   string(pubkey),\n+\t}\n+\tif err := t.writePacket(marshal(msgUserAuthRequest, msg)); err != nil {\n+\t\treturn false, err\n+\t}\n+\n+\treturn p.confirmKeyAck(key, t)\n+}\n+\n+func (p *publickeyAuth) confirmKeyAck(key interface{}, t *transport) (bool, error) {\n+\tpubkey := serializePublickey(key)\n+\talgoname := algoName(key)\n+\n+\tfor {\n+\t\tpacket, err := t.readPacket()\n+\t\tif err != nil {\n+\t\t\treturn false, err\n+\t\t}\n \t\tswitch packet[0] {\n-\t\tcase msgUserAuthSuccess:\n-\t\t\treturn true, nil, nil\n+\t\tcase msgUserAuthBanner:\n+\t\t\t// TODO(gpaul): add callback to present the banner to the user\n+\t\tcase msgUserAuthPubKeyOk:\n+\t\t\tmsg := decode(packet).(*userAuthPubKeyOkMsg)\n+\t\t\tif msg.Algo != algoname || msg.PubKey != string(pubkey) {\n+\t\t\t\treturn false, nil\n+\t\t\t}\n+\t\t\treturn true, nil\n \t\tcase msgUserAuthFailure:\n-\t\t\tmsg := decode(packet).(*userAuthFailureMsg)\n-\t\t\tmethods = msg.Methods\n-\t\t\tcontinue\n-\t\tcase msgDisconnect:\n-\t\t\treturn false, nil, io.EOF\n+\t\t\treturn false, nil\n \t\tdefault:\n-\t\t\treturn false, nil, UnexpectedMessageError{msgUserAuthSuccess, packet[0]}\n+\t\t\treturn false, UnexpectedMessageError{msgUserAuthSuccess, packet[0]}\n \t\t}\n \t}\n-\treturn false, methods, nil\n+\tpanic(\"unreachable\")\n }\n \n func (p *publickeyAuth) method() string {\n@@ -293,3 +287,30 @@ func (p *publickeyAuth) method() string {\n func ClientAuthPublickey(impl ClientKeyring) ClientAuth {\n \treturn &publickeyAuth{impl}\n }\n+\n+// handleAuthResponse returns whether the preceding authentication request succeeded\n+// along with a list of remaining authentication methods to try next and\n+// an error if an unexpected response was received.\n+func handleAuthResponse(t *transport) (bool, []string, error) {\n+\tfor {\n+\t\tpacket, err := t.readPacket()\n+\t\tif err != nil {\n+\t\t\treturn false, nil, err\n+\t\t}\n+\n+\t\tswitch packet[0] {\n+\t\tcase msgUserAuthBanner:\n+\t\t\t// TODO: add callback to present the banner to the user\n+\t\tcase msgUserAuthFailure:\n+\t\t\tmsg := decode(packet).(*userAuthFailureMsg)\n+\t\t\treturn false, msg.Methods, nil\n+\t\tcase msgUserAuthSuccess:\n+\t\t\treturn true, nil, nil\n+\t\tcase msgDisconnect:\n+\t\t\treturn false, nil, io.EOF\n+\t\tdefault:\n+\t\t\treturn false, nil, UnexpectedMessageError{msgUserAuthSuccess, packet[0]}\n+\t\t}\n+\t}\n+\tpanic(\"unreachable\")\n+}"}, {"sha": "2b89e9728c783397ba049775362e1e58e6b93eca", "filename": "libgo/go/exp/ssh/client_auth_test.go", "status": "modified", "additions": 121, "deletions": 112, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -7,17 +7,20 @@ package ssh\n import (\n \t\"bytes\"\n \t\"crypto\"\n-\t\"crypto/rand\"\n+\t\"crypto/dsa\"\n \t\"crypto/rsa\"\n+\t_ \"crypto/sha1\"\n \t\"crypto/x509\"\n \t\"encoding/pem\"\n \t\"errors\"\n \t\"io\"\n \t\"io/ioutil\"\n+\t\"math/big\"\n \t\"testing\"\n )\n \n-const _pem = `-----BEGIN RSA PRIVATE KEY-----\n+// private key for mock server\n+const testServerPrivateKey = `-----BEGIN RSA PRIVATE KEY-----\n MIIEpAIBAAKCAQEA19lGVsTqIT5iiNYRgnoY1CwkbETW5cq+Rzk5v/kTlf31XpSU\n 70HVWkbTERECjaYdXM2gGcbb+sxpq6GtXf1M3kVomycqhxwhPv4Cr6Xp4WT/jkFx\n 9z+FFzpeodGJWjOH6L2H5uX1Cvr9EDdQp9t9/J32/qBFntY8GwoUI/y/1MSTmMiF\n@@ -45,33 +48,44 @@ gqnBycHj6AhEycjda75cs+0zybZvN4x65KZHOGW/O/7OAWEcZP5TPb3zf9ned3Hl\n NsZoFj52ponUM6+99A2CmezFCN16c4mbA//luWF+k3VVqR6BpkrhKw==\n -----END RSA PRIVATE KEY-----`\n \n-// reused internally by tests\n-var serverConfig = new(ServerConfig)\n-\n-func init() {\n-\tif err := serverConfig.SetRSAPrivateKey([]byte(_pem)); err != nil {\n-\t\tpanic(\"unable to set private key: \" + err.Error())\n-\t}\n-}\n+const testClientPrivateKey = `-----BEGIN RSA PRIVATE KEY-----\n+MIIBOwIBAAJBALdGZxkXDAjsYk10ihwU6Id2KeILz1TAJuoq4tOgDWxEEGeTrcld\n+r/ZwVaFzjWzxaf6zQIJbfaSEAhqD5yo72+sCAwEAAQJBAK8PEVU23Wj8mV0QjwcJ\n+tZ4GcTUYQL7cF4+ezTCE9a1NrGnCP2RuQkHEKxuTVrxXt+6OF15/1/fuXnxKjmJC\n+nxkCIQDaXvPPBi0c7vAxGwNY9726x01/dNbHCE0CBtcotobxpwIhANbbQbh3JHVW\n+2haQh4fAG5mhesZKAGcxTyv4mQ7uMSQdAiAj+4dzMpJWdSzQ+qGHlHMIBvVHLkqB\n+y2VdEyF7DPCZewIhAI7GOI/6LDIFOvtPo6Bj2nNmyQ1HU6k/LRtNIXi4c9NJAiAr\n+rrxx26itVhJmcvoUhOjwuzSlP2bE5VHAvkGB352YBg==\n+-----END RSA PRIVATE KEY-----`\n \n // keychain implements the ClientPublickey interface\n type keychain struct {\n-\tkeys []*rsa.PrivateKey\n+\tkeys []interface{}\n }\n \n func (k *keychain) Key(i int) (interface{}, error) {\n \tif i < 0 || i >= len(k.keys) {\n \t\treturn nil, nil\n \t}\n-\treturn k.keys[i].PublicKey, nil\n+\tswitch key := k.keys[i].(type) {\n+\tcase *rsa.PrivateKey:\n+\t\treturn key.PublicKey, nil\n+\tcase *dsa.PrivateKey:\n+\t\treturn key.PublicKey, nil\n+\t}\n+\tpanic(\"unknown key type\")\n }\n \n func (k *keychain) Sign(i int, rand io.Reader, data []byte) (sig []byte, err error) {\n \thashFunc := crypto.SHA1\n \th := hashFunc.New()\n \th.Write(data)\n \tdigest := h.Sum(nil)\n-\treturn rsa.SignPKCS1v15(rand, k.keys[i], hashFunc, digest)\n+\tswitch key := k.keys[i].(type) {\n+\tcase *rsa.PrivateKey:\n+\t\treturn rsa.SignPKCS1v15(rand, key, hashFunc, digest)\n+\t}\n+\treturn nil, errors.New(\"unknown key type\")\n }\n \n func (k *keychain) loadPEM(file string) error {\n@@ -91,158 +105,153 @@ func (k *keychain) loadPEM(file string) error {\n \treturn nil\n }\n \n-var pkey *rsa.PrivateKey\n+// password implements the ClientPassword interface\n+type password string\n \n-func init() {\n-\tvar err error\n-\tpkey, err = rsa.GenerateKey(rand.Reader, 512)\n-\tif err != nil {\n-\t\tpanic(\"unable to generate public key\")\n-\t}\n+func (p password) Password(user string) (string, error) {\n+\treturn string(p), nil\n }\n \n-func TestClientAuthPublickey(t *testing.T) {\n-\tk := new(keychain)\n-\tk.keys = append(k.keys, pkey)\n+// reused internally by tests\n+var (\n+\trsakey         *rsa.PrivateKey\n+\tdsakey         *dsa.PrivateKey\n+\tclientKeychain = new(keychain)\n+\tclientPassword = password(\"tiger\")\n+\tserverConfig   = &ServerConfig{\n+\t\tPasswordCallback: func(user, pass string) bool {\n+\t\t\treturn user == \"testuser\" && pass == string(clientPassword)\n+\t\t},\n+\t\tPubKeyCallback: func(user, algo string, pubkey []byte) bool {\n+\t\t\tkey := clientKeychain.keys[0].(*rsa.PrivateKey).PublicKey\n+\t\t\texpected := []byte(serializePublickey(key))\n+\t\t\talgoname := algoName(key)\n+\t\t\treturn user == \"testuser\" && algo == algoname && bytes.Equal(pubkey, expected)\n+\t\t},\n+\t}\n+)\n \n-\tserverConfig.PubKeyCallback = func(user, algo string, pubkey []byte) bool {\n-\t\texpected := []byte(serializePublickey(k.keys[0].PublicKey))\n-\t\talgoname := algoName(k.keys[0].PublicKey)\n-\t\treturn user == \"testuser\" && algo == algoname && bytes.Equal(pubkey, expected)\n+func init() {\n+\tif err := serverConfig.SetRSAPrivateKey([]byte(testServerPrivateKey)); err != nil {\n+\t\tpanic(\"unable to set private key: \" + err.Error())\n \t}\n-\tserverConfig.PasswordCallback = nil\n \n+\tblock, _ := pem.Decode([]byte(testClientPrivateKey))\n+\trsakey, _ = x509.ParsePKCS1PrivateKey(block.Bytes)\n+\n+\tclientKeychain.keys = append(clientKeychain.keys, rsakey)\n+\tdsakey = new(dsa.PrivateKey)\n+\t// taken from crypto/dsa/dsa_test.go\n+\tdsakey.P, _ = new(big.Int).SetString(\"A9B5B793FB4785793D246BAE77E8FF63CA52F442DA763C440259919FE1BC1D6065A9350637A04F75A2F039401D49F08E066C4D275A5A65DA5684BC563C14289D7AB8A67163BFBF79D85972619AD2CFF55AB0EE77A9002B0EF96293BDD0F42685EBB2C66C327079F6C98000FBCB79AACDE1BC6F9D5C7B1A97E3D9D54ED7951FEF\", 16)\n+\tdsakey.Q, _ = new(big.Int).SetString(\"E1D3391245933D68A0714ED34BBCB7A1F422B9C1\", 16)\n+\tdsakey.G, _ = new(big.Int).SetString(\"634364FC25248933D01D1993ECABD0657CC0CB2CEED7ED2E3E8AECDFCDC4A25C3B15E9E3B163ACA2984B5539181F3EFF1A5E8903D71D5B95DA4F27202B77D2C44B430BB53741A8D59A8F86887525C9F2A6A5980A195EAA7F2FF910064301DEF89D3AA213E1FAC7768D89365318E370AF54A112EFBA9246D9158386BA1B4EEFDA\", 16)\n+\tdsakey.Y, _ = new(big.Int).SetString(\"32969E5780CFE1C849A1C276D7AEB4F38A23B591739AA2FE197349AEEBD31366AEE5EB7E6C6DDB7C57D02432B30DB5AA66D9884299FAA72568944E4EEDC92EA3FBC6F39F53412FBCC563208F7C15B737AC8910DBC2D9C9B8C001E72FDC40EB694AB1F06A5A2DBD18D9E36C66F31F566742F11EC0A52E9F7B89355C02FB5D32D2\", 16)\n+\tdsakey.X, _ = new(big.Int).SetString(\"5078D4D29795CBE76D3AACFE48C9AF0BCDBEE91A\", 16)\n+}\n+\n+// newMockAuthServer creates a new Server bound to \n+// the loopback interface. The server exits after \n+// processing one handshake.\n+func newMockAuthServer(t *testing.T) string {\n \tl, err := Listen(\"tcp\", \"127.0.0.1:0\", serverConfig)\n \tif err != nil {\n-\t\tt.Fatalf(\"unable to listen: %s\", err)\n+\t\tt.Fatalf(\"unable to newMockAuthServer: %s\", err)\n \t}\n-\tdefer l.Close()\n-\n-\tdone := make(chan bool, 1)\n \tgo func() {\n+\t\tdefer l.Close()\n \t\tc, err := l.Accept()\n+\t\tdefer c.Close()\n \t\tif err != nil {\n-\t\t\tt.Fatal(err)\n+\t\t\tt.Errorf(\"Unable to accept incoming connection: %v\", err)\n+\t\t\treturn\n \t\t}\n-\t\tdefer c.Close()\n \t\tif err := c.Handshake(); err != nil {\n-\t\t\tt.Error(err)\n+\t\t\t// not Errorf because this is expected to\n+\t\t\t// fail for some tests.\n+\t\t\tt.Logf(\"Handshaking error: %v\", err)\n+\t\t\treturn\n \t\t}\n-\t\tdone <- true\n \t}()\n+\treturn l.Addr().String()\n+}\n \n+func TestClientAuthPublickey(t *testing.T) {\n \tconfig := &ClientConfig{\n \t\tUser: \"testuser\",\n \t\tAuth: []ClientAuth{\n-\t\t\tClientAuthPublickey(k),\n+\t\t\tClientAuthPublickey(clientKeychain),\n \t\t},\n \t}\n-\n-\tc, err := Dial(\"tcp\", l.Addr().String(), config)\n+\tc, err := Dial(\"tcp\", newMockAuthServer(t), config)\n \tif err != nil {\n \t\tt.Fatalf(\"unable to dial remote side: %s\", err)\n \t}\n-\tdefer c.Close()\n-\t<-done\n-}\n-\n-// password implements the ClientPassword interface\n-type password string\n-\n-func (p password) Password(user string) (string, error) {\n-\treturn string(p), nil\n+\tc.Close()\n }\n \n func TestClientAuthPassword(t *testing.T) {\n-\tpw := password(\"tiger\")\n-\n-\tserverConfig.PasswordCallback = func(user, pass string) bool {\n-\t\treturn user == \"testuser\" && pass == string(pw)\n+\tconfig := &ClientConfig{\n+\t\tUser: \"testuser\",\n+\t\tAuth: []ClientAuth{\n+\t\t\tClientAuthPassword(clientPassword),\n+\t\t},\n \t}\n-\tserverConfig.PubKeyCallback = nil\n \n-\tl, err := Listen(\"tcp\", \"127.0.0.1:0\", serverConfig)\n+\tc, err := Dial(\"tcp\", newMockAuthServer(t), config)\n \tif err != nil {\n-\t\tt.Fatalf(\"unable to listen: %s\", err)\n+\t\tt.Fatalf(\"unable to dial remote side: %s\", err)\n \t}\n-\tdefer l.Close()\n-\n-\tdone := make(chan bool)\n-\tgo func() {\n-\t\tc, err := l.Accept()\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\t\tif err := c.Handshake(); err != nil {\n-\t\t\tt.Error(err)\n-\t\t}\n-\t\tdefer c.Close()\n-\t\tdone <- true\n-\t}()\n+\tc.Close()\n+}\n \n+func TestClientAuthWrongPassword(t *testing.T) {\n+\twrongPw := password(\"wrong\")\n \tconfig := &ClientConfig{\n \t\tUser: \"testuser\",\n \t\tAuth: []ClientAuth{\n-\t\t\tClientAuthPassword(pw),\n+\t\t\tClientAuthPassword(wrongPw),\n+\t\t\tClientAuthPublickey(clientKeychain),\n \t\t},\n \t}\n \n-\tc, err := Dial(\"tcp\", l.Addr().String(), config)\n+\tc, err := Dial(\"tcp\", newMockAuthServer(t), config)\n \tif err != nil {\n \t\tt.Fatalf(\"unable to dial remote side: %s\", err)\n \t}\n-\tdefer c.Close()\n-\t<-done\n+\tc.Close()\n }\n \n-func TestClientAuthPasswordAndPublickey(t *testing.T) {\n-\tpw := password(\"tiger\")\n-\n-\tserverConfig.PasswordCallback = func(user, pass string) bool {\n-\t\treturn user == \"testuser\" && pass == string(pw)\n-\t}\n-\n-\tk := new(keychain)\n-\tk.keys = append(k.keys, pkey)\n-\n-\tserverConfig.PubKeyCallback = func(user, algo string, pubkey []byte) bool {\n-\t\texpected := []byte(serializePublickey(k.keys[0].PublicKey))\n-\t\talgoname := algoName(k.keys[0].PublicKey)\n-\t\treturn user == \"testuser\" && algo == algoname && bytes.Equal(pubkey, expected)\n+// the mock server will only authenticate ssh-rsa keys\n+func TestClientAuthInvalidPublickey(t *testing.T) {\n+\tkc := new(keychain)\n+\tkc.keys = append(kc.keys, dsakey)\n+\tconfig := &ClientConfig{\n+\t\tUser: \"testuser\",\n+\t\tAuth: []ClientAuth{\n+\t\t\tClientAuthPublickey(kc),\n+\t\t},\n \t}\n \n-\tl, err := Listen(\"tcp\", \"127.0.0.1:0\", serverConfig)\n-\tif err != nil {\n-\t\tt.Fatalf(\"unable to listen: %s\", err)\n+\tc, err := Dial(\"tcp\", newMockAuthServer(t), config)\n+\tif err == nil {\n+\t\tc.Close()\n+\t\tt.Fatalf(\"dsa private key should not have authenticated with rsa public key\")\n \t}\n-\tdefer l.Close()\n-\n-\tdone := make(chan bool)\n-\tgo func() {\n-\t\tc, err := l.Accept()\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\t\tif err := c.Handshake(); err != nil {\n-\t\t\tt.Error(err)\n-\t\t}\n-\t\tdefer c.Close()\n-\t\tdone <- true\n-\t}()\n+}\n \n-\twrongPw := password(\"wrong\")\n+// the client should authenticate with the second key\n+func TestClientAuthRSAandDSA(t *testing.T) {\n+\tkc := new(keychain)\n+\tkc.keys = append(kc.keys, dsakey, rsakey)\n \tconfig := &ClientConfig{\n \t\tUser: \"testuser\",\n \t\tAuth: []ClientAuth{\n-\t\t\tClientAuthPassword(wrongPw),\n-\t\t\tClientAuthPublickey(k),\n+\t\t\tClientAuthPublickey(kc),\n \t\t},\n \t}\n-\n-\tc, err := Dial(\"tcp\", l.Addr().String(), config)\n+\tc, err := Dial(\"tcp\", newMockAuthServer(t), config)\n \tif err != nil {\n-\t\tt.Fatalf(\"unable to dial remote side: %s\", err)\n+\t\tt.Fatalf(\"client could not authenticate with rsa key: %v\", err)\n \t}\n-\tdefer c.Close()\n-\t<-done\n+\tc.Close()\n }"}, {"sha": "058fb04fe1b482bc751180eedfa613f05f0b3384", "filename": "libgo/go/exp/ssh/common_test.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fssh%2Fcommon_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fssh%2Fcommon_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fcommon_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -8,15 +8,15 @@ import (\n \t\"testing\"\n )\n \n-var strings = map[string]string{\n-\t\"\\x20\\x0d\\x0a\":  \"\\x20\\x0d\\x0a\",\n-\t\"flibble\":       \"flibble\",\n-\t\"new\\x20line\":   \"new\\x20line\",\n-\t\"123456\\x07789\": \"123456 789\",\n-\t\"\\t\\t\\x10\\r\\n\":  \"\\t\\t \\r\\n\",\n-}\n-\n func TestSafeString(t *testing.T) {\n+\tstrings := map[string]string{\n+\t\t\"\\x20\\x0d\\x0a\":  \"\\x20\\x0d\\x0a\",\n+\t\t\"flibble\":       \"flibble\",\n+\t\t\"new\\x20line\":   \"new\\x20line\",\n+\t\t\"123456\\x07789\": \"123456 789\",\n+\t\t\"\\t\\t\\x10\\r\\n\":  \"\\t\\t \\r\\n\",\n+\t}\n+\n \tfor s, expected := range strings {\n \t\tactual := safeString(s)\n \t\tif expected != actual {"}, {"sha": "23ea18c29ae697e01f3651dfca0df7f3978b7f26", "filename": "libgo/go/exp/ssh/session.go", "status": "modified", "additions": 9, "deletions": 32, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fssh%2Fsession.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fssh%2Fsession.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fsession.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -285,13 +285,8 @@ func (s *Session) stdin() error {\n \t\ts.Stdin = new(bytes.Buffer)\n \t}\n \ts.copyFuncs = append(s.copyFuncs, func() error {\n-\t\tw := &chanWriter{\n-\t\t\tpacketWriter: s,\n-\t\t\tpeersId:      s.peersId,\n-\t\t\twin:          s.win,\n-\t\t}\n-\t\t_, err := io.Copy(w, s.Stdin)\n-\t\tif err1 := w.Close(); err == nil {\n+\t\t_, err := io.Copy(s.clientChan.stdin, s.Stdin)\n+\t\tif err1 := s.clientChan.stdin.Close(); err == nil {\n \t\t\terr = err1\n \t\t}\n \t\treturn err\n@@ -304,12 +299,7 @@ func (s *Session) stdout() error {\n \t\ts.Stdout = ioutil.Discard\n \t}\n \ts.copyFuncs = append(s.copyFuncs, func() error {\n-\t\tr := &chanReader{\n-\t\t\tpacketWriter: s,\n-\t\t\tpeersId:      s.peersId,\n-\t\t\tdata:         s.data,\n-\t\t}\n-\t\t_, err := io.Copy(s.Stdout, r)\n+\t\t_, err := io.Copy(s.Stdout, s.clientChan.stdout)\n \t\treturn err\n \t})\n \treturn nil\n@@ -320,12 +310,7 @@ func (s *Session) stderr() error {\n \t\ts.Stderr = ioutil.Discard\n \t}\n \ts.copyFuncs = append(s.copyFuncs, func() error {\n-\t\tr := &chanReader{\n-\t\t\tpacketWriter: s,\n-\t\t\tpeersId:      s.peersId,\n-\t\t\tdata:         s.dataExt,\n-\t\t}\n-\t\t_, err := io.Copy(s.Stderr, r)\n+\t\t_, err := io.Copy(s.Stderr, s.clientChan.stderr)\n \t\treturn err\n \t})\n \treturn nil\n@@ -398,19 +383,11 @@ func (c *ClientConn) NewSession() (*Session, error) {\n \t\tc.chanlist.remove(ch.id)\n \t\treturn nil, err\n \t}\n-\t// wait for response\n-\tmsg := <-ch.msg\n-\tswitch msg := msg.(type) {\n-\tcase *channelOpenConfirmMsg:\n-\t\tch.peersId = msg.MyId\n-\t\tch.win <- int(msg.MyWindow)\n-\t\treturn &Session{\n-\t\t\tclientChan: ch,\n-\t\t}, nil\n-\tcase *channelOpenFailureMsg:\n+\tif err := ch.waitForChannelOpenResponse(); err != nil {\n \t\tc.chanlist.remove(ch.id)\n-\t\treturn nil, fmt.Errorf(\"ssh: channel open failed: %s\", msg.Message)\n+\t\treturn nil, fmt.Errorf(\"ssh: unable to open session: %v\", err)\n \t}\n-\tc.chanlist.remove(ch.id)\n-\treturn nil, fmt.Errorf(\"ssh: unexpected message %T: %v\", msg, msg)\n+\treturn &Session{\n+\t\tclientChan: ch,\n+\t}, nil\n }"}, {"sha": "d4818c29f7051a8bdf6318a02c1f5e48f0f199e1", "filename": "libgo/go/exp/ssh/session_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fssh%2Fsession_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fssh%2Fsession_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fsession_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -61,7 +61,7 @@ func dial(t *testing.T) *ClientConn {\n \t\t\t\t\tWantReply bool\n \t\t\t\t\tStatus    uint32\n \t\t\t\t}\n-\t\t\t\t// TODO(dfc) casting to the concrete type should not be\n+\t\t\t\t// TODO(dfc) converting to the concrete type should not be\n \t\t\t\t// necessary to send a packet.\n \t\t\t\tmsg := exitMsg{\n \t\t\t\t\tPeersId:   ch.(*channel).theirId,"}, {"sha": "a85044ace9cecc2c6ee2b3b29ae292de5590989b", "filename": "libgo/go/exp/ssh/tcpip.go", "status": "modified", "additions": 17, "deletions": 31, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -6,6 +6,7 @@ package ssh\n \n import (\n \t\"errors\"\n+\t\"fmt\"\n \t\"io\"\n \t\"net\"\n )\n@@ -42,20 +43,21 @@ func (c *ClientConn) DialTCP(n string, laddr, raddr *net.TCPAddr) (net.Conn, err\n \t}, nil\n }\n \n+// RFC 4254 7.2\n+type channelOpenDirectMsg struct {\n+\tChanType      string\n+\tPeersId       uint32\n+\tPeersWindow   uint32\n+\tMaxPacketSize uint32\n+\traddr         string\n+\trport         uint32\n+\tladdr         string\n+\tlport         uint32\n+}\n+\n // dial opens a direct-tcpip connection to the remote server. laddr and raddr are passed as\n // strings and are expected to be resolveable at the remote end.\n func (c *ClientConn) dial(laddr string, lport int, raddr string, rport int) (*tcpchan, error) {\n-\t// RFC 4254 7.2\n-\ttype channelOpenDirectMsg struct {\n-\t\tChanType      string\n-\t\tPeersId       uint32\n-\t\tPeersWindow   uint32\n-\t\tMaxPacketSize uint32\n-\t\traddr         string\n-\t\trport         uint32\n-\t\tladdr         string\n-\t\tlport         uint32\n-\t}\n \tch := c.newChan(c.transport)\n \tif err := c.writePacket(marshal(msgChannelOpen, channelOpenDirectMsg{\n \t\tChanType:      \"direct-tcpip\",\n@@ -70,30 +72,14 @@ func (c *ClientConn) dial(laddr string, lport int, raddr string, rport int) (*tc\n \t\tc.chanlist.remove(ch.id)\n \t\treturn nil, err\n \t}\n-\t// wait for response\n-\tswitch msg := (<-ch.msg).(type) {\n-\tcase *channelOpenConfirmMsg:\n-\t\tch.peersId = msg.MyId\n-\t\tch.win <- int(msg.MyWindow)\n-\tcase *channelOpenFailureMsg:\n-\t\tc.chanlist.remove(ch.id)\n-\t\treturn nil, errors.New(\"ssh: error opening remote TCP connection: \" + msg.Message)\n-\tdefault:\n+\tif err := ch.waitForChannelOpenResponse(); err != nil {\n \t\tc.chanlist.remove(ch.id)\n-\t\treturn nil, errors.New(\"ssh: unexpected packet\")\n+\t\treturn nil, fmt.Errorf(\"ssh: unable to open direct tcpip connection: %v\", err)\n \t}\n \treturn &tcpchan{\n \t\tclientChan: ch,\n-\t\tReader: &chanReader{\n-\t\t\tpacketWriter: ch,\n-\t\t\tpeersId:      ch.peersId,\n-\t\t\tdata:         ch.data,\n-\t\t},\n-\t\tWriter: &chanWriter{\n-\t\t\tpacketWriter: ch,\n-\t\t\tpeersId:      ch.peersId,\n-\t\t\twin:          ch.win,\n-\t\t},\n+\t\tReader:     ch.stdout,\n+\t\tWriter:     ch.stdin,\n \t}, nil\n }\n "}, {"sha": "6adcc2a9ad2018db5b46ea4eb56effd480880de6", "filename": "libgo/go/exp/types/gcimporter.go", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -305,7 +305,7 @@ func (p *gcParser) parseArrayType() Type {\n \tlit := p.expect(scanner.Int)\n \tp.expect(']')\n \telt := p.parseType()\n-\tn, err := strconv.Atoui64(lit)\n+\tn, err := strconv.ParseUint(lit, 10, 64)\n \tif err != nil {\n \t\tp.error(err)\n \t}\n@@ -323,7 +323,7 @@ func (p *gcParser) parseMapType() Type {\n \treturn &Map{Key: key, Elt: elt}\n }\n \n-// Name = identifier | \"?\" .\n+// Name = identifier | \"?\" | ExportedName  .\n //\n func (p *gcParser) parseName() (name string) {\n \tswitch p.tok {\n@@ -333,6 +333,9 @@ func (p *gcParser) parseName() (name string) {\n \tcase '?':\n \t\t// anonymous\n \t\tp.next()\n+\tcase '@':\n+\t\t// exported name prefixed with package path\n+\t\t_, name = p.parseExportedName()\n \tdefault:\n \t\tp.error(\"name expected\")\n \t}\n@@ -619,10 +622,11 @@ func (p *gcParser) parseNumber() Const {\n \t\t// exponent (base 2)\n \t\tp.next()\n \t\tsign, val = p.parseInt()\n-\t\texp, err := strconv.Atoui(val)\n+\t\texp64, err := strconv.ParseUint(val, 10, 0)\n \t\tif err != nil {\n \t\t\tp.error(err)\n \t\t}\n+\t\texp := uint(exp64)\n \t\tif sign == \"-\" {\n \t\t\tdenom := big.NewInt(1)\n \t\t\tdenom.Lsh(denom, exp)\n@@ -747,15 +751,15 @@ func (p *gcParser) parseFuncDecl() {\n \t}\n }\n \n-// MethodDecl = \"func\" Receiver identifier Signature .\n+// MethodDecl = \"func\" Receiver Name Signature .\n // Receiver   = \"(\" ( identifier | \"?\" ) [ \"*\" ] ExportedName \")\" [ FuncBody ].\n //\n func (p *gcParser) parseMethodDecl() {\n \t// \"func\" already consumed\n \tp.expect('(')\n \tp.parseParameter() // receiver\n \tp.expect(')')\n-\tp.expect(scanner.Ident)\n+\tp.parseName() // unexported method names in imports are qualified with their package.\n \tp.parseSignature()\n \tif p.tok == '{' {\n \t\tp.parseFuncBody()"}, {"sha": "40f5441ddcb4f0800c2fa09f6b87e7dbf01a6f1b", "filename": "libgo/go/expvar/expvar.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexpvar%2Fexpvar.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fexpvar%2Fexpvar.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexpvar%2Fexpvar.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -44,7 +44,7 @@ type Int struct {\n \tmu sync.Mutex\n }\n \n-func (v *Int) String() string { return strconv.Itoa64(v.i) }\n+func (v *Int) String() string { return strconv.FormatInt(v.i, 10) }\n \n func (v *Int) Add(delta int64) {\n \tv.mu.Lock()\n@@ -64,7 +64,7 @@ type Float struct {\n \tmu sync.Mutex\n }\n \n-func (v *Float) String() string { return strconv.Ftoa64(v.f, 'g', -1) }\n+func (v *Float) String() string { return strconv.FormatFloat(v.f, 'g', -1, 64) }\n \n // Add adds delta to v.\n func (v *Float) Add(delta float64) {"}, {"sha": "406ea77799d4358f47ac5183a85073b95a78d50f", "filename": "libgo/go/flag/flag.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fflag%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fflag%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -79,7 +79,7 @@ func newBoolValue(val bool, p *bool) *boolValue {\n }\n \n func (b *boolValue) Set(s string) bool {\n-\tv, err := strconv.Atob(s)\n+\tv, err := strconv.ParseBool(s)\n \t*b = boolValue(v)\n \treturn err == nil\n }\n@@ -95,7 +95,7 @@ func newIntValue(val int, p *int) *intValue {\n }\n \n func (i *intValue) Set(s string) bool {\n-\tv, err := strconv.Btoi64(s, 0)\n+\tv, err := strconv.ParseInt(s, 0, 64)\n \t*i = intValue(v)\n \treturn err == nil\n }\n@@ -111,7 +111,7 @@ func newInt64Value(val int64, p *int64) *int64Value {\n }\n \n func (i *int64Value) Set(s string) bool {\n-\tv, err := strconv.Btoi64(s, 0)\n+\tv, err := strconv.ParseInt(s, 0, 64)\n \t*i = int64Value(v)\n \treturn err == nil\n }\n@@ -127,7 +127,7 @@ func newUintValue(val uint, p *uint) *uintValue {\n }\n \n func (i *uintValue) Set(s string) bool {\n-\tv, err := strconv.Btoui64(s, 0)\n+\tv, err := strconv.ParseUint(s, 0, 64)\n \t*i = uintValue(v)\n \treturn err == nil\n }\n@@ -143,7 +143,7 @@ func newUint64Value(val uint64, p *uint64) *uint64Value {\n }\n \n func (i *uint64Value) Set(s string) bool {\n-\tv, err := strconv.Btoui64(s, 0)\n+\tv, err := strconv.ParseUint(s, 0, 64)\n \t*i = uint64Value(v)\n \treturn err == nil\n }\n@@ -174,7 +174,7 @@ func newFloat64Value(val float64, p *float64) *float64Value {\n }\n \n func (f *float64Value) Set(s string) bool {\n-\tv, err := strconv.Atof64(s)\n+\tv, err := strconv.ParseFloat(s, 64)\n \t*f = float64Value(v)\n \treturn err == nil\n }"}, {"sha": "11e9f19f8995be1e5e119bf41107b312c9fad4b4", "filename": "libgo/go/fmt/doc.go", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Ffmt%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Ffmt%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fdoc.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -89,18 +89,22 @@\n \tIf an operand implements interface Formatter, that interface\n \tcan be used for fine control of formatting.\n \n-\tNext, if an operand implements the error interface, the Error method\n+\tIf the format (which is implicitly %v for Println etc.) is valid\n+\tfor a string (%s %q %v %x %X), the following two rules also apply:\n+\n+\t1. If an operand implements the error interface, the Error method\n \twill be used to convert the object to a string, which will then\n \tbe formatted as required by the verb (if any).\n \n-\tFinally, if an operand implements method String() string that method\n+\t2. If an operand implements method String() string, that method\n \twill be used to convert the object to a string, which will then\n \tbe formatted as required by the verb (if any).\n+\n \tTo avoid recursion in cases such as\n-\t\ttype X int\n-\t\tfunc (x X) String() string { return Sprintf(\"%d\", x) }\n-\tcast the value before recurring:\n-\t\tfunc (x X) String() string { return Sprintf(\"%d\", int(x)) }\n+\t\ttype X string\n+\t\tfunc (x X) String() string { return Sprintf(\"<%s>\", x) }\n+\tconvert the value before recurring:\n+\t\tfunc (x X) String() string { return Sprintf(\"<%s>\", string(x)) }\n \n \tFormat errors:\n "}, {"sha": "63c33380a25a307a60ef93752bfa402a1510259c", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 42, "deletions": 22, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -12,6 +12,7 @@ import (\n \t\"runtime\" // for the malloc count test only\n \t\"strings\"\n \t\"testing\"\n+\t\"time\"\n )\n \n type (\n@@ -352,7 +353,7 @@ var fmttests = []struct {\n \t{\"%s\", I(23), `<23>`},\n \t{\"%q\", I(23), `\"<23>\"`},\n \t{\"%x\", I(23), `3c32333e`},\n-\t{\"%d\", I(23), `%!d(string=<23>)`},\n+\t{\"%d\", I(23), `23`}, // Stringer applies only to string formats.\n \n \t// go syntax\n \t{\"%#v\", A{1, 2, \"a\", []int{1, 2}}, `fmt_test.A{i:1, j:0x2, s:\"a\", x:[]int{1, 2}}`},\n@@ -361,8 +362,8 @@ var fmttests = []struct {\n \t{\"%#v\", make(chan int), \"(chan int)(0xPTR)\"},\n \t{\"%#v\", uint64(1<<64 - 1), \"0xffffffffffffffff\"},\n \t{\"%#v\", 1000000000, \"1000000000\"},\n-\t{\"%#v\", map[string]int{\"a\": 1}, `map[string] int{\"a\":1}`},\n-\t{\"%#v\", map[string]B{\"a\": {1, 2}}, `map[string] fmt_test.B{\"a\":fmt_test.B{I:1, j:2}}`},\n+\t{\"%#v\", map[string]int{\"a\": 1}, `map[string]int{\"a\":1}`},\n+\t{\"%#v\", map[string]B{\"a\": {1, 2}}, `map[string]fmt_test.B{\"a\":fmt_test.B{I:1, j:2}}`},\n \t{\"%#v\", []string{\"a\", \"b\"}, `[]string{\"a\", \"b\"}`},\n \t{\"%#v\", SI{}, `fmt_test.SI{I:interface {}(nil)}`},\n \t{\"%#v\", []int(nil), `[]int(nil)`},\n@@ -371,8 +372,8 @@ var fmttests = []struct {\n \t{\"%#v\", &array, `&[5]int{1, 2, 3, 4, 5}`},\n \t{\"%#v\", iarray, `[4]interface {}{1, \"hello\", 2.5, interface {}(nil)}`},\n \t{\"%#v\", &iarray, `&[4]interface {}{1, \"hello\", 2.5, interface {}(nil)}`},\n-\t{\"%#v\", map[int]byte(nil), `map[int] uint8(nil)`},\n-\t{\"%#v\", map[int]byte{}, `map[int] uint8{}`},\n+\t{\"%#v\", map[int]byte(nil), `map[int]uint8(nil)`},\n+\t{\"%#v\", map[int]byte{}, `map[int]uint8{}`},\n \n \t// slices with other formats\n \t{\"%#x\", []int{1, 2, 15}, `[0x1 0x2 0xf]`},\n@@ -430,6 +431,10 @@ var fmttests = []struct {\n \t{\"%p\", make([]int, 1), \"0xPTR\"},\n \t{\"%p\", 27, \"%!p(int=27)\"}, // not a pointer at all\n \n+\t// %d on Stringer should give integer if possible\n+\t{\"%s\", time.Time{}.Month(), \"January\"},\n+\t{\"%d\", time.Time{}.Month(), \"1\"},\n+\n \t// erroneous things\n \t{\"%s %\", \"hello\", \"hello %!(NOVERB)\"},\n \t{\"%s %.2\", \"hello\", \"hello %!(NOVERB)\"},\n@@ -495,69 +500,84 @@ func BenchmarkSprintfPrefixedInt(b *testing.B) {\n \t}\n }\n \n+func BenchmarkSprintfFloat(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tSprintf(\"%g\", 5.23184)\n+\t}\n+}\n+\n func TestCountMallocs(t *testing.T) {\n \tif testing.Short() {\n \t\treturn\n \t}\n+\tconst N = 100\n \truntime.UpdateMemStats()\n \tmallocs := 0 - runtime.MemStats.Mallocs\n-\tfor i := 0; i < 100; i++ {\n+\tfor i := 0; i < N; i++ {\n \t\tSprintf(\"\")\n \t}\n \truntime.UpdateMemStats()\n \tmallocs += runtime.MemStats.Mallocs\n-\tPrintf(\"mallocs per Sprintf(\\\"\\\"): %d\\n\", mallocs/100)\n+\tPrintf(\"mallocs per Sprintf(\\\"\\\"): %d\\n\", mallocs/N)\n \truntime.UpdateMemStats()\n \tmallocs = 0 - runtime.MemStats.Mallocs\n-\tfor i := 0; i < 100; i++ {\n+\tfor i := 0; i < N; i++ {\n \t\tSprintf(\"xxx\")\n \t}\n \truntime.UpdateMemStats()\n \tmallocs += runtime.MemStats.Mallocs\n-\tPrintf(\"mallocs per Sprintf(\\\"xxx\\\"): %d\\n\", mallocs/100)\n+\tPrintf(\"mallocs per Sprintf(\\\"xxx\\\"): %d\\n\", mallocs/N)\n \truntime.UpdateMemStats()\n \tmallocs = 0 - runtime.MemStats.Mallocs\n-\tfor i := 0; i < 100; i++ {\n+\tfor i := 0; i < N; i++ {\n \t\tSprintf(\"%x\", i)\n \t}\n \truntime.UpdateMemStats()\n \tmallocs += runtime.MemStats.Mallocs\n-\tPrintf(\"mallocs per Sprintf(\\\"%%x\\\"): %d\\n\", mallocs/100)\n+\tPrintf(\"mallocs per Sprintf(\\\"%%x\\\"): %d\\n\", mallocs/N)\n \truntime.UpdateMemStats()\n \tmallocs = 0 - runtime.MemStats.Mallocs\n-\tfor i := 0; i < 100; i++ {\n+\tfor i := 0; i < N; i++ {\n \t\tSprintf(\"%s\", \"hello\")\n \t}\n \truntime.UpdateMemStats()\n \tmallocs += runtime.MemStats.Mallocs\n-\tPrintf(\"mallocs per Sprintf(\\\"%%s\\\"): %d\\n\", mallocs/100)\n+\tPrintf(\"mallocs per Sprintf(\\\"%%s\\\"): %d\\n\", mallocs/N)\n \truntime.UpdateMemStats()\n \tmallocs = 0 - runtime.MemStats.Mallocs\n-\tfor i := 0; i < 100; i++ {\n+\tfor i := 0; i < N; i++ {\n \t\tSprintf(\"%x %x\", i, i)\n \t}\n \truntime.UpdateMemStats()\n \tmallocs += runtime.MemStats.Mallocs\n-\tPrintf(\"mallocs per Sprintf(\\\"%%x %%x\\\"): %d\\n\", mallocs/100)\n+\tPrintf(\"mallocs per Sprintf(\\\"%%x %%x\\\"): %d\\n\", mallocs/N)\n+\truntime.UpdateMemStats()\n+\tmallocs = 0 - runtime.MemStats.Mallocs\n+\tfor i := 0; i < N; i++ {\n+\t\tSprintf(\"%g\", 3.14159)\n+\t}\n+\truntime.UpdateMemStats()\n+\tmallocs += runtime.MemStats.Mallocs\n+\tPrintf(\"mallocs per Sprintf(\\\"%%g\\\"): %d\\n\", mallocs/N)\n \tbuf := new(bytes.Buffer)\n \truntime.UpdateMemStats()\n \tmallocs = 0 - runtime.MemStats.Mallocs\n-\tfor i := 0; i < 100; i++ {\n+\tfor i := 0; i < N; i++ {\n \t\tbuf.Reset()\n \t\tFprintf(buf, \"%x %x %x\", i, i, i)\n \t}\n \truntime.UpdateMemStats()\n \tmallocs += runtime.MemStats.Mallocs\n-\tPrintf(\"mallocs per Fprintf(buf, \\\"%%x %%x %%x\\\"): %d\\n\", mallocs/100)\n+\tPrintf(\"mallocs per Fprintf(buf, \\\"%%x %%x %%x\\\"): %d\\n\", mallocs/N)\n \truntime.UpdateMemStats()\n \tmallocs = 0 - runtime.MemStats.Mallocs\n-\tfor i := 0; i < 100; i++ {\n+\tfor i := 0; i < N; i++ {\n \t\tbuf.Reset()\n \t\tFprintf(buf, \"%s\", \"hello\")\n \t}\n \truntime.UpdateMemStats()\n \tmallocs += runtime.MemStats.Mallocs\n-\tPrintf(\"mallocs per Fprintf(buf, \\\"%%s\\\"): %d\\n\", mallocs/100)\n+\tPrintf(\"mallocs per Fprintf(buf, \\\"%%s\\\"): %d\\n\", mallocs/N)\n }\n \n type flagPrinter struct{}\n@@ -772,9 +792,9 @@ var panictests = []struct {\n \tout string\n }{\n \t// String\n-\t{\"%d\", (*Panic)(nil), \"<nil>\"}, // nil pointer special case\n-\t{\"%d\", Panic{io.ErrUnexpectedEOF}, \"%d(PANIC=unexpected EOF)\"},\n-\t{\"%d\", Panic{3}, \"%d(PANIC=3)\"},\n+\t{\"%s\", (*Panic)(nil), \"<nil>\"}, // nil pointer special case\n+\t{\"%s\", Panic{io.ErrUnexpectedEOF}, \"%s(PANIC=unexpected EOF)\"},\n+\t{\"%s\", Panic{3}, \"%s(PANIC=3)\"},\n \t// GoString\n \t{\"%#v\", (*Panic)(nil), \"<nil>\"}, // nil pointer special case\n \t{\"%#v\", Panic{io.ErrUnexpectedEOF}, \"%v(PANIC=unexpected EOF)\"},"}, {"sha": "fbafa9d9ad99c15053cef2c80255bc50f163d4df", "filename": "libgo/go/fmt/format.go", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Ffmt%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Ffmt%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fformat.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -360,44 +360,44 @@ func (f *fmt) plusSpace(s string) {\n }\n \n // fmt_e64 formats a float64 in the form -1.23e+12.\n-func (f *fmt) fmt_e64(v float64) { f.plusSpace(strconv.Ftoa64(v, 'e', doPrec(f, 6))) }\n+func (f *fmt) fmt_e64(v float64) { f.plusSpace(strconv.FormatFloat(v, 'e', doPrec(f, 6), 64)) }\n \n // fmt_E64 formats a float64 in the form -1.23E+12.\n-func (f *fmt) fmt_E64(v float64) { f.plusSpace(strconv.Ftoa64(v, 'E', doPrec(f, 6))) }\n+func (f *fmt) fmt_E64(v float64) { f.plusSpace(strconv.FormatFloat(v, 'E', doPrec(f, 6), 64)) }\n \n // fmt_f64 formats a float64 in the form -1.23.\n-func (f *fmt) fmt_f64(v float64) { f.plusSpace(strconv.Ftoa64(v, 'f', doPrec(f, 6))) }\n+func (f *fmt) fmt_f64(v float64) { f.plusSpace(strconv.FormatFloat(v, 'f', doPrec(f, 6), 64)) }\n \n // fmt_g64 formats a float64 in the 'f' or 'e' form according to size.\n-func (f *fmt) fmt_g64(v float64) { f.plusSpace(strconv.Ftoa64(v, 'g', doPrec(f, -1))) }\n+func (f *fmt) fmt_g64(v float64) { f.plusSpace(strconv.FormatFloat(v, 'g', doPrec(f, -1), 64)) }\n \n // fmt_g64 formats a float64 in the 'f' or 'E' form according to size.\n-func (f *fmt) fmt_G64(v float64) { f.plusSpace(strconv.Ftoa64(v, 'G', doPrec(f, -1))) }\n+func (f *fmt) fmt_G64(v float64) { f.plusSpace(strconv.FormatFloat(v, 'G', doPrec(f, -1), 64)) }\n \n // fmt_fb64 formats a float64 in the form -123p3 (exponent is power of 2).\n-func (f *fmt) fmt_fb64(v float64) { f.plusSpace(strconv.Ftoa64(v, 'b', 0)) }\n+func (f *fmt) fmt_fb64(v float64) { f.plusSpace(strconv.FormatFloat(v, 'b', 0, 64)) }\n \n // float32\n // cannot defer to float64 versions\n // because it will get rounding wrong in corner cases.\n \n // fmt_e32 formats a float32 in the form -1.23e+12.\n-func (f *fmt) fmt_e32(v float32) { f.plusSpace(strconv.Ftoa32(v, 'e', doPrec(f, 6))) }\n+func (f *fmt) fmt_e32(v float32) { f.plusSpace(strconv.FormatFloat(float64(v), 'e', doPrec(f, 6), 32)) }\n \n // fmt_E32 formats a float32 in the form -1.23E+12.\n-func (f *fmt) fmt_E32(v float32) { f.plusSpace(strconv.Ftoa32(v, 'E', doPrec(f, 6))) }\n+func (f *fmt) fmt_E32(v float32) { f.plusSpace(strconv.FormatFloat(float64(v), 'E', doPrec(f, 6), 32)) }\n \n // fmt_f32 formats a float32 in the form -1.23.\n-func (f *fmt) fmt_f32(v float32) { f.plusSpace(strconv.Ftoa32(v, 'f', doPrec(f, 6))) }\n+func (f *fmt) fmt_f32(v float32) { f.plusSpace(strconv.FormatFloat(float64(v), 'f', doPrec(f, 6), 32)) }\n \n // fmt_g32 formats a float32 in the 'f' or 'e' form according to size.\n-func (f *fmt) fmt_g32(v float32) { f.plusSpace(strconv.Ftoa32(v, 'g', doPrec(f, -1))) }\n+func (f *fmt) fmt_g32(v float32) { f.plusSpace(strconv.FormatFloat(float64(v), 'g', doPrec(f, -1), 32)) }\n \n // fmt_G32 formats a float32 in the 'f' or 'E' form according to size.\n-func (f *fmt) fmt_G32(v float32) { f.plusSpace(strconv.Ftoa32(v, 'G', doPrec(f, -1))) }\n+func (f *fmt) fmt_G32(v float32) { f.plusSpace(strconv.FormatFloat(float64(v), 'G', doPrec(f, -1), 32)) }\n \n // fmt_fb32 formats a float32 in the form -123p3 (exponent is power of 2).\n-func (f *fmt) fmt_fb32(v float32) { f.padString(strconv.Ftoa32(v, 'b', 0)) }\n+func (f *fmt) fmt_fb32(v float32) { f.padString(strconv.FormatFloat(float64(v), 'b', 0, 32)) }\n \n // fmt_c64 formats a complex64 according to the verb.\n func (f *fmt) fmt_c64(v complex64, verb rune) {"}, {"sha": "8b15a82e773b69b3d9e97351bac9990ba712569d", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -631,24 +631,30 @@ func (p *pp) handleMethods(verb rune, plus, goSyntax bool, depth int) (wasString\n \t\t\treturn\n \t\t}\n \t} else {\n-\t\t// Is it an error or Stringer?\n-\t\t// The duplication in the bodies is necessary:\n-\t\t// setting wasString and handled and deferring catchPanic\n-\t\t// must happen before calling the method.\n-\t\tswitch v := p.field.(type) {\n-\t\tcase error:\n-\t\t\twasString = false\n-\t\t\thandled = true\n-\t\t\tdefer p.catchPanic(p.field, verb)\n-\t\t\tp.printField(v.Error(), verb, plus, false, depth)\n-\t\t\treturn\n-\n-\t\tcase Stringer:\n-\t\t\twasString = false\n-\t\t\thandled = true\n-\t\t\tdefer p.catchPanic(p.field, verb)\n-\t\t\tp.printField(v.String(), verb, plus, false, depth)\n-\t\t\treturn\n+\t\t// If a string is acceptable according to the format, see if\n+\t\t// the value satisfies one of the string-valued interfaces.\n+\t\t// Println etc. set verb to %v, which is \"stringable\".\n+\t\tswitch verb {\n+\t\tcase 'v', 's', 'x', 'X', 'q':\n+\t\t\t// Is it an error or Stringer?\n+\t\t\t// The duplication in the bodies is necessary:\n+\t\t\t// setting wasString and handled, and deferring catchPanic,\n+\t\t\t// must happen before calling the method.\n+\t\t\tswitch v := p.field.(type) {\n+\t\t\tcase error:\n+\t\t\t\twasString = false\n+\t\t\t\thandled = true\n+\t\t\t\tdefer p.catchPanic(p.field, verb)\n+\t\t\t\tp.printField(v.Error(), verb, plus, false, depth)\n+\t\t\t\treturn\n+\n+\t\t\tcase Stringer:\n+\t\t\t\twasString = false\n+\t\t\t\thandled = true\n+\t\t\t\tdefer p.catchPanic(p.field, verb)\n+\t\t\t\tp.printField(v.String(), verb, plus, false, depth)\n+\t\t\t\treturn\n+\t\t\t}\n \t\t}\n \t}\n \thandled = false"}, {"sha": "281525112e14bea7c6fa0cee6dfd95f884fb92d3", "filename": "libgo/go/fmt/scan.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Ffmt%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Ffmt%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -613,7 +613,7 @@ func (s *ss) scanInt(verb rune, bitSize int) int64 {\n \t\t}\n \t}\n \ttok := s.scanNumber(digits, haveDigits)\n-\ti, err := strconv.Btoi64(tok, base)\n+\ti, err := strconv.ParseInt(tok, base, 64)\n \tif err != nil {\n \t\ts.error(err)\n \t}\n@@ -643,7 +643,7 @@ func (s *ss) scanUint(verb rune, bitSize int) uint64 {\n \t\tbase, digits, haveDigits = s.scanBasePrefix()\n \t}\n \ttok := s.scanNumber(digits, haveDigits)\n-\ti, err := strconv.Btoui64(tok, base)\n+\ti, err := strconv.ParseUint(tok, base, 64)\n \tif err != nil {\n \t\ts.error(err)\n \t}\n@@ -719,7 +719,7 @@ func (s *ss) convertFloat(str string, n int) float64 {\n \tif p := strings.Index(str, \"p\"); p >= 0 {\n \t\t// Atof doesn't handle power-of-2 exponents,\n \t\t// but they're easy to evaluate.\n-\t\tf, err := strconv.AtofN(str[:p], n)\n+\t\tf, err := strconv.ParseFloat(str[:p], n)\n \t\tif err != nil {\n \t\t\t// Put full string into error.\n \t\t\tif e, ok := err.(*strconv.NumError); ok {\n@@ -737,7 +737,7 @@ func (s *ss) convertFloat(str string, n int) float64 {\n \t\t}\n \t\treturn math.Ldexp(f, n)\n \t}\n-\tf, err := strconv.AtofN(str, n)\n+\tf, err := strconv.ParseFloat(str, n)\n \tif err != nil {\n \t\ts.error(err)\n \t}"}, {"sha": "89d5af1541e23c7906a92050a329bab5f4302d13", "filename": "libgo/go/go/ast/print_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fgo%2Fast%2Fprint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fgo%2Fast%2Fprint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fprint_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -24,7 +24,7 @@ var tests = []struct {\n \n \t// maps\n \t{map[string]int{\"a\": 1},\n-\t\t`0  map[string] int (len = 1) {\n+\t\t`0  map[string]int (len = 1) {\n \t\t1  .  \"a\": 1\n \t\t2  }`},\n "}, {"sha": "c9fb55bd54ef1cd4715e70442e1d987943eee0a8", "filename": "libgo/go/go/doc/comment.go", "status": "modified", "additions": 33, "deletions": 70, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -7,7 +7,6 @@\n package doc\n \n import (\n-\t\"bytes\"\n \t\"go/ast\"\n \t\"io\"\n \t\"regexp\"\n@@ -85,53 +84,20 @@ func CommentText(comment *ast.CommentGroup) string {\n \treturn strings.Join(lines, \"\\n\")\n }\n \n-// Split bytes into lines.\n-func split(text []byte) [][]byte {\n-\t// count lines\n-\tn := 0\n-\tlast := 0\n-\tfor i, c := range text {\n-\t\tif c == '\\n' {\n-\t\t\tlast = i + 1\n-\t\t\tn++\n-\t\t}\n-\t}\n-\tif last < len(text) {\n-\t\tn++\n-\t}\n-\n-\t// split\n-\tout := make([][]byte, n)\n-\tlast = 0\n-\tn = 0\n-\tfor i, c := range text {\n-\t\tif c == '\\n' {\n-\t\t\tout[n] = text[last : i+1]\n-\t\t\tlast = i + 1\n-\t\t\tn++\n-\t\t}\n-\t}\n-\tif last < len(text) {\n-\t\tout[n] = text[last:]\n-\t}\n-\n-\treturn out\n-}\n-\n var (\n \tldquo = []byte(\"&ldquo;\")\n \trdquo = []byte(\"&rdquo;\")\n )\n \n // Escape comment text for HTML. If nice is set,\n // also turn `` into &ldquo; and '' into &rdquo;.\n-func commentEscape(w io.Writer, s []byte, nice bool) {\n+func commentEscape(w io.Writer, text string, nice bool) {\n \tlast := 0\n \tif nice {\n-\t\tfor i := 0; i < len(s)-1; i++ {\n-\t\t\tch := s[i]\n-\t\t\tif ch == s[i+1] && (ch == '`' || ch == '\\'') {\n-\t\t\t\ttemplate.HTMLEscape(w, s[last:i])\n+\t\tfor i := 0; i < len(text)-1; i++ {\n+\t\t\tch := text[i]\n+\t\t\tif ch == text[i+1] && (ch == '`' || ch == '\\'') {\n+\t\t\t\ttemplate.HTMLEscape(w, []byte(text[last:i]))\n \t\t\t\tlast = i + 2\n \t\t\t\tswitch ch {\n \t\t\t\tcase '`':\n@@ -143,7 +109,7 @@ func commentEscape(w io.Writer, s []byte, nice bool) {\n \t\t\t}\n \t\t}\n \t}\n-\ttemplate.HTMLEscape(w, s[last:])\n+\ttemplate.HTMLEscape(w, []byte(text[last:]))\n }\n \n const (\n@@ -183,9 +149,9 @@ var (\n // and the word is converted into a link. If nice is set, the remaining text's\n // appearance is improved where it makes sense (e.g., `` is turned into &ldquo;\n // and '' into &rdquo;).\n-func emphasize(w io.Writer, line []byte, words map[string]string, nice bool) {\n+func emphasize(w io.Writer, line string, words map[string]string, nice bool) {\n \tfor {\n-\t\tm := matchRx.FindSubmatchIndex(line)\n+\t\tm := matchRx.FindStringSubmatchIndex(line)\n \t\tif m == nil {\n \t\t\tbreak\n \t\t}\n@@ -233,25 +199,27 @@ func emphasize(w io.Writer, line []byte, words map[string]string, nice bool) {\n \tcommentEscape(w, line, nice)\n }\n \n-func indentLen(s []byte) int {\n+func indentLen(s string) int {\n \ti := 0\n \tfor i < len(s) && (s[i] == ' ' || s[i] == '\\t') {\n \t\ti++\n \t}\n \treturn i\n }\n \n-func isBlank(s []byte) bool { return len(s) == 0 || (len(s) == 1 && s[0] == '\\n') }\n+func isBlank(s string) bool {\n+\treturn len(s) == 0 || (len(s) == 1 && s[0] == '\\n')\n+}\n \n-func commonPrefix(a, b []byte) []byte {\n+func commonPrefix(a, b string) string {\n \ti := 0\n \tfor i < len(a) && i < len(b) && a[i] == b[i] {\n \t\ti++\n \t}\n \treturn a[0:i]\n }\n \n-func unindent(block [][]byte) {\n+func unindent(block []string) {\n \tif len(block) == 0 {\n \t\treturn\n \t}\n@@ -273,44 +241,39 @@ func unindent(block [][]byte) {\n \t}\n }\n \n-// heading returns the (possibly trimmed) line if it passes as a valid section\n-// heading; otherwise it returns nil. \n-func heading(line []byte) []byte {\n-\tline = bytes.TrimSpace(line)\n+// heading returns the trimmed line if it passes as a section heading;\n+// otherwise it returns the empty string. \n+func heading(line string) string {\n+\tline = strings.TrimSpace(line)\n \tif len(line) == 0 {\n-\t\treturn nil\n+\t\treturn \"\"\n \t}\n \n \t// a heading must start with an uppercase letter\n-\tr, _ := utf8.DecodeRune(line)\n+\tr, _ := utf8.DecodeRuneInString(line)\n \tif !unicode.IsLetter(r) || !unicode.IsUpper(r) {\n-\t\treturn nil\n-\t}\n-\n-\t// it must end in a letter, digit or ':'\n-\tr, _ = utf8.DecodeLastRune(line)\n-\tif !unicode.IsLetter(r) && !unicode.IsDigit(r) && r != ':' {\n-\t\treturn nil\n+\t\treturn \"\"\n \t}\n \n-\t// strip trailing ':', if any\n-\tif r == ':' {\n-\t\tline = line[0 : len(line)-1]\n+\t// it must end in a letter or digit:\n+\tr, _ = utf8.DecodeLastRuneInString(line)\n+\tif !unicode.IsLetter(r) && !unicode.IsDigit(r) {\n+\t\treturn \"\"\n \t}\n \n \t// exclude lines with illegal characters\n-\tif bytes.IndexAny(line, \",.;:!?+*/=()[]{}_^\u00b0&\u00a7~%#@<\\\">\\\\\") >= 0 {\n-\t\treturn nil\n+\tif strings.IndexAny(line, \",.;:!?+*/=()[]{}_^\u00b0&\u00a7~%#@<\\\">\\\\\") >= 0 {\n+\t\treturn \"\"\n \t}\n \n \t// allow \"'\" for possessive \"'s\" only\n \tfor b := line; ; {\n-\t\ti := bytes.IndexRune(b, '\\'')\n+\t\ti := strings.IndexRune(b, '\\'')\n \t\tif i < 0 {\n \t\t\tbreak\n \t\t}\n \t\tif i+1 >= len(b) || b[i+1] != 's' || (i+2 < len(b) && b[i+2] != ' ') {\n-\t\t\treturn nil // not followed by \"s \"\n+\t\t\treturn \"\" // not followed by \"s \"\n \t\t}\n \t\tb = b[i+2:]\n \t}\n@@ -335,7 +298,7 @@ func heading(line []byte) []byte {\n // Go identifiers that appear in the words map are italicized; if the corresponding\n // map value is not the empty string, it is considered a URL and the word is converted\n // into a link.\n-func ToHTML(w io.Writer, s []byte, words map[string]string) {\n+func ToHTML(w io.Writer, text string, words map[string]string) {\n \tinpara := false\n \tlastWasBlank := false\n \tlastWasHeading := false\n@@ -353,7 +316,7 @@ func ToHTML(w io.Writer, s []byte, words map[string]string) {\n \t\t}\n \t}\n \n-\tlines := split(s)\n+\tlines := strings.SplitAfter(text, \"\\n\")\n \tunindent(lines)\n \tfor i := 0; i < len(lines); {\n \t\tline := lines[i]\n@@ -397,10 +360,10 @@ func ToHTML(w io.Writer, s []byte, words map[string]string) {\n \t\t\t// current line is non-blank, sourounded by blank lines\n \t\t\t// and the next non-blank line is not indented: this\n \t\t\t// might be a heading.\n-\t\t\tif head := heading(line); head != nil {\n+\t\t\tif head := heading(line); head != \"\" {\n \t\t\t\tclose()\n \t\t\t\tw.Write(html_h)\n-\t\t\t\ttemplate.HTMLEscape(w, head)\n+\t\t\t\tcommentEscape(w, head, true) // nice text formatting\n \t\t\t\tw.Write(html_endh)\n \t\t\t\ti += 2\n \t\t\t\tlastWasHeading = true"}, {"sha": "6424053ac9debc47f917ee92a2fa6b97055fef6f", "filename": "libgo/go/go/doc/comment_test.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -18,21 +18,22 @@ var headingTests = []struct {\n \t{\"Foo 42\", true},\n \t{\"\", false},\n \t{\"section\", false},\n-\t{\"A typical usage:\", true},\n+\t{\"A typical usage:\", false},\n+\t{\"This code:\", false},\n \t{\"\u03b4 is Greek\", false},\n \t{\"Foo \u00a7\", false},\n \t{\"Fermat's Last Sentence\", true},\n \t{\"Fermat's\", true},\n \t{\"'sX\", false},\n \t{\"Ted 'Too' Bar\", false},\n \t{\"Use n+m\", false},\n-\t{\"Scanning:\", true},\n+\t{\"Scanning:\", false},\n \t{\"N:M\", false},\n }\n \n func TestIsHeading(t *testing.T) {\n \tfor _, tt := range headingTests {\n-\t\tif h := heading([]byte(tt.line)); (h != nil) != tt.ok {\n+\t\tif h := heading(tt.line); (len(h) > 0) != tt.ok {\n \t\t\tt.Errorf(\"isHeading(%q) = %v, want %v\", tt.line, h, tt.ok)\n \t\t}\n \t}"}, {"sha": "838223be745f9eb1492172ab5ac4666977e3d6c4", "filename": "libgo/go/go/doc/headscan.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fgo%2Fdoc%2Fheadscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fgo%2Fdoc%2Fheadscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fheadscan.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -43,7 +43,7 @@ func isGoFile(fi os.FileInfo) bool {\n \n func appendHeadings(list []string, comment string) []string {\n \tvar buf bytes.Buffer\n-\tdoc.ToHTML(&buf, []byte(comment), nil)\n+\tdoc.ToHTML(&buf, comment, nil)\n \tfor s := buf.String(); ; {\n \t\ti := strings.Index(s, html_h)\n \t\tif i < 0 {"}, {"sha": "f0a8055f4c1227cf211969395e5a890b35ba92b1", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -2026,7 +2026,7 @@ func (p *parser) parseReceiver(scope *ast.Scope) *ast.FieldList {\n \t// must have exactly one receiver\n \tif par.NumFields() != 1 {\n \t\tp.errorExpected(par.Opening, \"exactly one receiver\")\n-\t\tpar.List = []*ast.Field{&ast.Field{Type: &ast.BadExpr{par.Opening, par.Closing + 1}}}\n+\t\tpar.List = []*ast.Field{{Type: &ast.BadExpr{par.Opening, par.Closing + 1}}}\n \t\treturn par\n \t}\n \n@@ -2035,7 +2035,7 @@ func (p *parser) parseReceiver(scope *ast.Scope) *ast.FieldList {\n \tbase := deref(recv.Type)\n \tif _, isIdent := base.(*ast.Ident); !isIdent {\n \t\tp.errorExpected(base.Pos(), \"(unqualified) identifier\")\n-\t\tpar.List = []*ast.Field{&ast.Field{Type: &ast.BadExpr{recv.Pos(), recv.End()}}}\n+\t\tpar.List = []*ast.Field{{Type: &ast.BadExpr{recv.Pos(), recv.End()}}}\n \t}\n \n \treturn par"}, {"sha": "b2a48c28a733bbe4d4431927055398b7f320ce37", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -354,7 +354,7 @@ func (p *printer) isOneLineFieldList(list []*ast.Field) bool {\n }\n \n func (p *printer) setLineComment(text string) {\n-\tp.setComment(&ast.CommentGroup{[]*ast.Comment{&ast.Comment{token.NoPos, text}}})\n+\tp.setComment(&ast.CommentGroup{[]*ast.Comment{{token.NoPos, text}}})\n }\n \n func (p *printer) fieldList(fields *ast.FieldList, isStruct, isIncomplete bool) {"}, {"sha": "89e341c5f97f9d42f4a255c47f1ee2f8e337aa2b", "filename": "libgo/go/go/printer/testdata/parser.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fparser.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -1999,7 +1999,7 @@ func (p *parser) parseReceiver(scope *ast.Scope) *ast.FieldList {\n \tif par.NumFields() != 1 {\n \t\tp.errorExpected(pos, \"exactly one receiver\")\n \t\t// TODO determine a better range for BadExpr below\n-\t\tpar.List = []*ast.Field{&ast.Field{Type: &ast.BadExpr{pos, pos}}}\n+\t\tpar.List = []*ast.Field{{Type: &ast.BadExpr{pos, pos}}}\n \t\treturn par\n \t}\n \n@@ -2008,7 +2008,7 @@ func (p *parser) parseReceiver(scope *ast.Scope) *ast.FieldList {\n \tbase := deref(recv.Type)\n \tif _, isIdent := base.(*ast.Ident); !isIdent {\n \t\tp.errorExpected(base.Pos(), \"(unqualified) identifier\")\n-\t\tpar.List = []*ast.Field{&ast.Field{Type: &ast.BadExpr{recv.Pos(), recv.End()}}}\n+\t\tpar.List = []*ast.Field{{Type: &ast.BadExpr{recv.Pos(), recv.End()}}}\n \t}\n \n \treturn par"}, {"sha": "8598f4e1b83ec242a8823f45775b5a66570599b7", "filename": "libgo/go/hash/hash.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fhash%2Fhash.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fhash%2Fhash.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fhash.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -13,9 +13,9 @@ type Hash interface {\n \t// It never returns an error.\n \tio.Writer\n \n-\t// Sum appends the current hash in the same manner as append(), without\n-\t// changing the underlying hash state.\n-\tSum(in []byte) []byte\n+\t// Sum appends the current hash to b and returns the resulting slice.\n+\t// It does not change the underlying hash state.\n+\tSum(b []byte) []byte\n \n \t// Reset resets the hash to one with zero bytes written.\n \tReset()"}, {"sha": "dd2d8165bdb3d732d4998285af62c5d992b37d47", "filename": "libgo/go/html/parse.go", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fhtml%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fhtml%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -515,7 +515,19 @@ func afterHeadIM(p *parser) bool {\n \t\timplied    bool\n \t)\n \tswitch p.tok.Type {\n-\tcase ErrorToken, TextToken:\n+\tcase ErrorToken:\n+\t\timplied = true\n+\t\tframesetOK = true\n+\tcase TextToken:\n+\t\ts := strings.TrimLeft(p.tok.Data, whitespace)\n+\t\tif len(s) < len(p.tok.Data) {\n+\t\t\t// Add the initial whitespace to the current node.\n+\t\t\tp.addText(p.tok.Data[:len(p.tok.Data)-len(s)])\n+\t\t\tif s == \"\" {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t\tp.tok.Data = s\n+\t\t}\n \t\timplied = true\n \t\tframesetOK = true\n \tcase StartTagToken:\n@@ -535,7 +547,8 @@ func afterHeadIM(p *parser) bool {\n \t\t\tdefer p.oe.pop()\n \t\t\treturn inHeadIM(p)\n \t\tcase \"head\":\n-\t\t\t// TODO.\n+\t\t\t// Ignore the token.\n+\t\t\treturn true\n \t\tdefault:\n \t\t\timplied = true\n \t\t\tframesetOK = true"}, {"sha": "5062a6edcb88f29e63c3cead6df3f44e87a73654", "filename": "libgo/go/html/parse_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fhtml%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fhtml%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -167,6 +167,7 @@ func TestParser(t *testing.T) {\n \t\t{\"tests3.dat\", -1},\n \t\t{\"tests4.dat\", -1},\n \t\t{\"tests5.dat\", -1},\n+\t\t{\"tests6.dat\", 7},\n \t}\n \tfor _, tf := range testFiles {\n \t\tf, err := os.Open(\"testdata/webkit/\" + tf.filename)"}, {"sha": "0584f35abdb264de4d0c18a5bef7b9cd2572292d", "filename": "libgo/go/html/render_test.go", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fhtml%2Frender_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fhtml%2Frender_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Frender_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -14,83 +14,83 @@ func TestRenderer(t *testing.T) {\n \t\tType: ElementNode,\n \t\tData: \"html\",\n \t\tChild: []*Node{\n-\t\t\t&Node{\n+\t\t\t{\n \t\t\t\tType: ElementNode,\n \t\t\t\tData: \"head\",\n \t\t\t},\n-\t\t\t&Node{\n+\t\t\t{\n \t\t\t\tType: ElementNode,\n \t\t\t\tData: \"body\",\n \t\t\t\tChild: []*Node{\n-\t\t\t\t\t&Node{\n+\t\t\t\t\t{\n \t\t\t\t\t\tType: TextNode,\n \t\t\t\t\t\tData: \"0<1\",\n \t\t\t\t\t},\n-\t\t\t\t\t&Node{\n+\t\t\t\t\t{\n \t\t\t\t\t\tType: ElementNode,\n \t\t\t\t\t\tData: \"p\",\n \t\t\t\t\t\tAttr: []Attribute{\n-\t\t\t\t\t\t\tAttribute{\n+\t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\tKey: \"id\",\n \t\t\t\t\t\t\t\tVal: \"A\",\n \t\t\t\t\t\t\t},\n-\t\t\t\t\t\t\tAttribute{\n+\t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\tKey: \"foo\",\n \t\t\t\t\t\t\t\tVal: `abc\"def`,\n \t\t\t\t\t\t\t},\n \t\t\t\t\t\t},\n \t\t\t\t\t\tChild: []*Node{\n-\t\t\t\t\t\t\t&Node{\n+\t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\tType: TextNode,\n \t\t\t\t\t\t\t\tData: \"2\",\n \t\t\t\t\t\t\t},\n-\t\t\t\t\t\t\t&Node{\n+\t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\tType: ElementNode,\n \t\t\t\t\t\t\t\tData: \"b\",\n \t\t\t\t\t\t\t\tAttr: []Attribute{\n-\t\t\t\t\t\t\t\t\tAttribute{\n+\t\t\t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\t\t\tKey: \"empty\",\n \t\t\t\t\t\t\t\t\t\tVal: \"\",\n \t\t\t\t\t\t\t\t\t},\n \t\t\t\t\t\t\t\t},\n \t\t\t\t\t\t\t\tChild: []*Node{\n-\t\t\t\t\t\t\t\t\t&Node{\n+\t\t\t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\t\t\tType: TextNode,\n \t\t\t\t\t\t\t\t\t\tData: \"3\",\n \t\t\t\t\t\t\t\t\t},\n \t\t\t\t\t\t\t\t},\n \t\t\t\t\t\t\t},\n-\t\t\t\t\t\t\t&Node{\n+\t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\tType: ElementNode,\n \t\t\t\t\t\t\t\tData: \"i\",\n \t\t\t\t\t\t\t\tAttr: []Attribute{\n-\t\t\t\t\t\t\t\t\tAttribute{\n+\t\t\t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\t\t\tKey: \"backslash\",\n \t\t\t\t\t\t\t\t\t\tVal: `\\`,\n \t\t\t\t\t\t\t\t\t},\n \t\t\t\t\t\t\t\t},\n \t\t\t\t\t\t\t\tChild: []*Node{\n-\t\t\t\t\t\t\t\t\t&Node{\n+\t\t\t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\t\t\tType: TextNode,\n \t\t\t\t\t\t\t\t\t\tData: \"&4\",\n \t\t\t\t\t\t\t\t\t},\n \t\t\t\t\t\t\t\t},\n \t\t\t\t\t\t\t},\n \t\t\t\t\t\t},\n \t\t\t\t\t},\n-\t\t\t\t\t&Node{\n+\t\t\t\t\t{\n \t\t\t\t\t\tType: TextNode,\n \t\t\t\t\t\tData: \"5\",\n \t\t\t\t\t},\n-\t\t\t\t\t&Node{\n+\t\t\t\t\t{\n \t\t\t\t\t\tType: ElementNode,\n \t\t\t\t\t\tData: \"blockquote\",\n \t\t\t\t\t},\n-\t\t\t\t\t&Node{\n+\t\t\t\t\t{\n \t\t\t\t\t\tType: ElementNode,\n \t\t\t\t\t\tData: \"br\",\n \t\t\t\t\t},\n-\t\t\t\t\t&Node{\n+\t\t\t\t\t{\n \t\t\t\t\t\tType: TextNode,\n \t\t\t\t\t\tData: \"6\",\n \t\t\t\t\t},"}, {"sha": "a735638b0314f6694931d48cd529f615f5aed748", "filename": "libgo/go/html/template/css_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcss_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcss_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcss_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -113,7 +113,7 @@ func TestDecodeCSS(t *testing.T) {\n \n func TestHexDecode(t *testing.T) {\n \tfor i := 0; i < 0x200000; i += 101 /* coprime with 16 */ {\n-\t\ts := strconv.Itob(i, 16)\n+\t\ts := strconv.FormatInt(int64(i), 16)\n \t\tif got := int(hexDecode([]byte(s))); got != i {\n \t\t\tt.Errorf(\"%s: want %d but got %d\", s, i, got)\n \t\t}"}, {"sha": "2f6be3b6c21feee57319a5d3a7436635fdc4c7b6", "filename": "libgo/go/html/template/escape.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -716,7 +716,7 @@ func (e *escaper) editTextNode(n *parse.TextNode, text []byte) {\n // commit applies changes to actions and template calls needed to contextually\n // autoescape content and adds any derived templates to the set.\n func (e *escaper) commit() {\n-\tfor name, _ := range e.output {\n+\tfor name := range e.output {\n \t\te.template(name).Funcs(funcMap)\n \t}\n \tfor _, t := range e.derived {"}, {"sha": "cdeed48b822f68e30af2970db7118aff2589ce13", "filename": "libgo/go/html/template/escape_test.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -689,11 +689,11 @@ func TestEscapeSet(t *testing.T) {\n \n \tdata := dataItem{\n \t\tChildren: []*dataItem{\n-\t\t\t&dataItem{X: \"foo\"},\n-\t\t\t&dataItem{X: \"<bar>\"},\n-\t\t\t&dataItem{\n+\t\t\t{X: \"foo\"},\n+\t\t\t{X: \"<bar>\"},\n+\t\t\t{\n \t\t\t\tChildren: []*dataItem{\n-\t\t\t\t\t&dataItem{X: \"baz\"},\n+\t\t\t\t\t{X: \"baz\"},\n \t\t\t\t},\n \t\t\t},\n \t\t},\n@@ -1597,7 +1597,7 @@ func TestRedundantFuncs(t *testing.T) {\n \n \tfor n0, m := range redundantFuncs {\n \t\tf0 := funcMap[n0].(func(...interface{}) string)\n-\t\tfor n1, _ := range m {\n+\t\tfor n1 := range m {\n \t\t\tf1 := funcMap[n1].(func(...interface{}) string)\n \t\t\tfor _, input := range inputs {\n \t\t\t\twant := f0(input)"}, {"sha": "fa2ed18874cc9f26f73b231e18ceda987d3aa409", "filename": "libgo/go/html/template/template.go", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -47,23 +47,22 @@ func (t *Template) Execute(wr io.Writer, data interface{}) (err error) {\n \treturn t.text.Execute(wr, data)\n }\n \n-// ExecuteTemplate applies the template associated with t that has the given name\n-// to the specified data object and writes the output to wr.\n+// ExecuteTemplate applies the template associated with t that has the given\n+// name to the specified data object and writes the output to wr.\n func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) (err error) {\n \tt.nameSpace.mu.Lock()\n \ttmpl := t.set[name]\n-\tif tmpl == nil {\n-\t\tt.nameSpace.mu.Unlock()\n-\t\treturn fmt.Errorf(\"template: no template %q associated with template %q\", name, t.Name())\n+\tif (tmpl == nil) != (t.text.Lookup(name) == nil) {\n+\t\tpanic(\"html/template internal error: template escaping out of sync\")\n \t}\n-\tif !tmpl.escaped {\n+\tif tmpl != nil && !tmpl.escaped {\n \t\terr = escapeTemplates(tmpl, name)\n \t}\n \tt.nameSpace.mu.Unlock()\n \tif err != nil {\n \t\treturn\n \t}\n-\treturn tmpl.text.ExecuteTemplate(wr, name, data)\n+\treturn t.text.ExecuteTemplate(wr, name, data)\n }\n \n // Parse parses a string into a template. Nested template definitions\n@@ -106,7 +105,7 @@ func (t *Template) AddParseTree(name string, tree *parse.Tree) error {\n \n // Clone is unimplemented.\n func (t *Template) Clone(name string) error {\n-\treturn fmt.Errorf(\"html/template: Add unimplemented\")\n+\treturn fmt.Errorf(\"html/template: Clone unimplemented\")\n }\n \n // New allocates a new HTML template with the given name."}, {"sha": "2948db7f38cc49ac61a1aa989caf082bdac03328", "filename": "libgo/go/image/color/color.go", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fimage%2Fcolor%2Fcolor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fimage%2Fcolor%2Fcolor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fcolor%2Fcolor.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -134,13 +134,22 @@ type Model interface {\n \tConvert(c Color) Color\n }\n \n-// ModelFunc is an adapter type to allow the use of a color conversion\n-// function as a Model. If f is such a function, ModelFunc(f) is a Model that\n-// invokes f to implement the conversion.\n-type ModelFunc func(Color) Color\n+// ModelFunc returns a Model that invokes f to implement the conversion.\n+func ModelFunc(f func(Color) Color) Model {\n+\t// Note: using *modelFunc as the implementation\n+\t// means that callers can still use comparisons\n+\t// like m == RGBAModel.  This is not possible if\n+\t// we use the func value directly, because funcs\n+\t// are no longer comparable.\n+\treturn &modelFunc{f}\n+}\n+\n+type modelFunc struct {\n+\tf func(Color) Color\n+}\n \n-func (f ModelFunc) Convert(c Color) Color {\n-\treturn f(c)\n+func (m *modelFunc) Convert(c Color) Color {\n+\treturn m.f(c)\n }\n \n // RGBAModel is the Model for RGBA colors."}, {"sha": "a7d1a5798315d35b0cce25004b35695acf123485", "filename": "libgo/go/image/names.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fimage%2Fnames.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fimage%2Fnames.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fnames.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -20,7 +20,7 @@ var (\n )\n \n // Uniform is an infinite-sized Image of uniform color.\n-// It implements both the color.Color and Image interfaces.\n+// It implements the color.Color, color.ColorModel, and Image interfaces.\n type Uniform struct {\n \tC color.Color\n }\n@@ -30,7 +30,11 @@ func (c *Uniform) RGBA() (r, g, b, a uint32) {\n }\n \n func (c *Uniform) ColorModel() color.Model {\n-\treturn color.ModelFunc(func(color.Color) color.Color { return c.C })\n+\treturn c\n+}\n+\n+func (c *Uniform) Convert(color.Color) color.Color {\n+\treturn c.C\n }\n \n func (c *Uniform) Bounds() Rectangle { return Rectangle{Point{-1e9, -1e9}, Point{1e9, 1e9}} }"}, {"sha": "641eae1bb8e8c0cb88c1ecc7d8f2db4d05095fe4", "filename": "libgo/go/image/png/writer.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fimage%2Fpng%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fimage%2Fpng%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Fwriter.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -429,7 +429,7 @@ func Encode(w io.Writer, m image.Image) error {\n \t// also rejected.\n \tmw, mh := int64(m.Bounds().Dx()), int64(m.Bounds().Dy())\n \tif mw <= 0 || mh <= 0 || mw >= 1<<32 || mh >= 1<<32 {\n-\t\treturn FormatError(\"invalid image size: \" + strconv.Itoa64(mw) + \"x\" + strconv.Itoa64(mw))\n+\t\treturn FormatError(\"invalid image size: \" + strconv.FormatInt(mw, 10) + \"x\" + strconv.FormatInt(mw, 10))\n \t}\n \n \tvar e encoder"}, {"sha": "b2a3f8a4e0e3e119c8e748907dd0df8afa67c800", "filename": "libgo/go/math/sin.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fmath%2Fsin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fmath%2Fsin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fsin.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -110,7 +110,7 @@ var _cos = [...]float64{\n \n // Cos returns the cosine of x.\n //\n-// Special conditions are:\n+// Special cases are:\n //\tCos(\u00b1Inf) = NaN\n //\tCos(NaN) = NaN\n func Cos(x float64) float64 {"}, {"sha": "74294256bebde0ab5c0983c38318e89d0b6cc9f7", "filename": "libgo/go/math/sincos.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fmath%2Fsincos.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fmath%2Fsincos.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fsincos.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -8,7 +8,7 @@ package math\n \n // Sincos(x) returns Sin(x), Cos(x).\n //\n-// Special conditions are:\n+// Special cases are:\n //\tSincos(\u00b10) = \u00b10, 1\n //\tSincos(\u00b1Inf) = NaN, NaN\n //\tSincos(NaN) = NaN, NaN"}, {"sha": "139b911fe6564d93f6d54a5b85beb9599c3cc368", "filename": "libgo/go/math/sinh.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fmath%2Fsinh.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fmath%2Fsinh.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fsinh.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -17,6 +17,11 @@ package math\n */\n \n // Sinh returns the hyperbolic sine of x.\n+//\n+// Special cases are:\n+//\tSinh(\u00b10) = \u00b10\n+//\tSinh(\u00b1Inf) = \u00b1Inf\n+//\tSinh(NaN) = NaN\n func Sinh(x float64) float64 {\n \t// The coefficients are #2029 from Hart & Cheney. (20.36D)\n \tconst (\n@@ -56,6 +61,11 @@ func Sinh(x float64) float64 {\n }\n \n // Cosh returns the hyperbolic cosine of x.\n+//\n+// Special cases are:\n+//\tCosh(\u00b10) = 1\n+//\tCosh(\u00b1Inf) = +Inf\n+//\tCosh(NaN) = NaN\n func Cosh(x float64) float64 {\n \tif x < 0 {\n \t\tx = -x"}, {"sha": "76131fcd935d18c13c263d800d666a0ed6e078df", "filename": "libgo/go/math/tan.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fmath%2Ftan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fmath%2Ftan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Ftan.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -75,7 +75,7 @@ var _tanQ = [...]float64{\n \n // Tan returns the tangent of x.\n //\n-// Special conditions are:\n+// Special cases are:\n //\tTan(\u00b10) = \u00b10\n //\tTan(\u00b1Inf) = NaN\n //\tTan(NaN) = NaN"}, {"sha": "03a641b4da036c4d7382ca4189f779841e676cff", "filename": "libgo/go/math/tanh.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fmath%2Ftanh.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fmath%2Ftanh.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Ftanh.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -12,6 +12,11 @@ package math\n */\n \n // Tanh computes the hyperbolic tangent of x.\n+//\n+// Special cases are:\n+//\tTanh(\u00b10) = \u00b10\n+//\tTanh(\u00b1Inf) = \u00b11\n+//\tTanh(NaN) = NaN\n func Tanh(x float64) float64 {\n \tif x < 0 {\n \t\tx = -x"}, {"sha": "e6c3ef911ab8f1cc9a5e76b97394cf7da659fc93", "filename": "libgo/go/net/http/cgi/child.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fchild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fchild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fchild.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -70,7 +70,7 @@ func RequestFromMap(params map[string]string) (*http.Request, error) {\n \tr.Host = params[\"HTTP_HOST\"]\n \n \tif lenstr := params[\"CONTENT_LENGTH\"]; lenstr != \"\" {\n-\t\tclen, err := strconv.Atoi64(lenstr)\n+\t\tclen, err := strconv.ParseInt(lenstr, 10, 64)\n \t\tif err != nil {\n \t\t\treturn nil, errors.New(\"cgi: bad CONTENT_LENGTH in environment: \" + lenstr)\n \t\t}"}, {"sha": "60a478fd8faf7b65c18cd8a67cd019443f53bf8b", "filename": "libgo/go/net/http/chunked.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fhttp%2Fchunked.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fhttp%2Fchunked.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fchunked.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -48,7 +48,7 @@ func (cr *chunkedReader) beginChunk() {\n \tif cr.err != nil {\n \t\treturn\n \t}\n-\tcr.n, cr.err = strconv.Btoui64(line, 16)\n+\tcr.n, cr.err = strconv.ParseUint(line, 16, 64)\n \tif cr.err != nil {\n \t\treturn\n \t}\n@@ -147,7 +147,7 @@ func (cw *chunkedWriter) Write(data []byte) (n int, err error) {\n \t\treturn 0, nil\n \t}\n \n-\thead := strconv.Itob(len(data), 16) + \"\\r\\n\"\n+\thead := strconv.FormatInt(int64(len(data)), 16) + \"\\r\\n\"\n \n \tif _, err = io.WriteString(cw.Wire, head); err != nil {\n \t\treturn 0, err"}, {"sha": "712350dfcef7b00885f6672e0cfbca9922fd6e15", "filename": "libgo/go/net/http/cookie_test.go", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -81,14 +81,14 @@ var addCookieTests = []struct {\n \t\t\"\",\n \t},\n \t{\n-\t\t[]*Cookie{&Cookie{Name: \"cookie-1\", Value: \"v$1\"}},\n+\t\t[]*Cookie{{Name: \"cookie-1\", Value: \"v$1\"}},\n \t\t\"cookie-1=v$1\",\n \t},\n \t{\n \t\t[]*Cookie{\n-\t\t\t&Cookie{Name: \"cookie-1\", Value: \"v$1\"},\n-\t\t\t&Cookie{Name: \"cookie-2\", Value: \"v$2\"},\n-\t\t\t&Cookie{Name: \"cookie-3\", Value: \"v$3\"},\n+\t\t\t{Name: \"cookie-1\", Value: \"v$1\"},\n+\t\t\t{Name: \"cookie-2\", Value: \"v$2\"},\n+\t\t\t{Name: \"cookie-3\", Value: \"v$3\"},\n \t\t},\n \t\t\"cookie-1=v$1; cookie-2=v$2; cookie-3=v$3\",\n \t},\n@@ -113,11 +113,11 @@ var readSetCookiesTests = []struct {\n }{\n \t{\n \t\tHeader{\"Set-Cookie\": {\"Cookie-1=v$1\"}},\n-\t\t[]*Cookie{&Cookie{Name: \"Cookie-1\", Value: \"v$1\", Raw: \"Cookie-1=v$1\"}},\n+\t\t[]*Cookie{{Name: \"Cookie-1\", Value: \"v$1\", Raw: \"Cookie-1=v$1\"}},\n \t},\n \t{\n \t\tHeader{\"Set-Cookie\": {\"NID=99=YsDT5i3E-CXax-; expires=Wed, 23-Nov-2011 01:05:03 GMT; path=/; domain=.google.ch; HttpOnly\"}},\n-\t\t[]*Cookie{&Cookie{\n+\t\t[]*Cookie{{\n \t\t\tName:       \"NID\",\n \t\t\tValue:      \"99=YsDT5i3E-CXax-\",\n \t\t\tPath:       \"/\",\n@@ -159,30 +159,30 @@ var readCookiesTests = []struct {\n \t\tHeader{\"Cookie\": {\"Cookie-1=v$1\", \"c2=v2\"}},\n \t\t\"\",\n \t\t[]*Cookie{\n-\t\t\t&Cookie{Name: \"Cookie-1\", Value: \"v$1\"},\n-\t\t\t&Cookie{Name: \"c2\", Value: \"v2\"},\n+\t\t\t{Name: \"Cookie-1\", Value: \"v$1\"},\n+\t\t\t{Name: \"c2\", Value: \"v2\"},\n \t\t},\n \t},\n \t{\n \t\tHeader{\"Cookie\": {\"Cookie-1=v$1\", \"c2=v2\"}},\n \t\t\"c2\",\n \t\t[]*Cookie{\n-\t\t\t&Cookie{Name: \"c2\", Value: \"v2\"},\n+\t\t\t{Name: \"c2\", Value: \"v2\"},\n \t\t},\n \t},\n \t{\n \t\tHeader{\"Cookie\": {\"Cookie-1=v$1; c2=v2\"}},\n \t\t\"\",\n \t\t[]*Cookie{\n-\t\t\t&Cookie{Name: \"Cookie-1\", Value: \"v$1\"},\n-\t\t\t&Cookie{Name: \"c2\", Value: \"v2\"},\n+\t\t\t{Name: \"Cookie-1\", Value: \"v$1\"},\n+\t\t\t{Name: \"c2\", Value: \"v2\"},\n \t\t},\n \t},\n \t{\n \t\tHeader{\"Cookie\": {\"Cookie-1=v$1; c2=v2\"}},\n \t\t\"c2\",\n \t\t[]*Cookie{\n-\t\t\t&Cookie{Name: \"c2\", Value: \"v2\"},\n+\t\t\t{Name: \"c2\", Value: \"v2\"},\n \t\t},\n \t},\n }"}, {"sha": "1392ca68ad680547304d9ef158e8b42209f03c92", "filename": "libgo/go/net/http/fs.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fhttp%2Ffs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fhttp%2Ffs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffs.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -220,7 +220,7 @@ func serveFile(w ResponseWriter, r *Request, fs FileSystem, name string, redirec\n \n \tw.Header().Set(\"Accept-Ranges\", \"bytes\")\n \tif w.Header().Get(\"Content-Encoding\") == \"\" {\n-\t\tw.Header().Set(\"Content-Length\", strconv.Itoa64(size))\n+\t\tw.Header().Set(\"Content-Length\", strconv.FormatInt(size, 10))\n \t}\n \n \tw.WriteHeader(code)\n@@ -295,7 +295,7 @@ func parseRange(s string, size int64) ([]httpRange, error) {\n \t\tif start == \"\" {\n \t\t\t// If no start is specified, end specifies the\n \t\t\t// range start relative to the end of the file.\n-\t\t\ti, err := strconv.Atoi64(end)\n+\t\t\ti, err := strconv.ParseInt(end, 10, 64)\n \t\t\tif err != nil {\n \t\t\t\treturn nil, errors.New(\"invalid range\")\n \t\t\t}\n@@ -305,7 +305,7 @@ func parseRange(s string, size int64) ([]httpRange, error) {\n \t\t\tr.start = size - i\n \t\t\tr.length = size - r.start\n \t\t} else {\n-\t\t\ti, err := strconv.Atoi64(start)\n+\t\t\ti, err := strconv.ParseInt(start, 10, 64)\n \t\t\tif err != nil || i > size || i < 0 {\n \t\t\t\treturn nil, errors.New(\"invalid range\")\n \t\t\t}\n@@ -314,7 +314,7 @@ func parseRange(s string, size int64) ([]httpRange, error) {\n \t\t\t\t// If no end is specified, range extends to end of the file.\n \t\t\t\tr.length = size - r.start\n \t\t\t} else {\n-\t\t\t\ti, err := strconv.Atoi64(end)\n+\t\t\t\ti, err := strconv.ParseInt(end, 10, 64)\n \t\t\t\tif err != nil || r.start > i {\n \t\t\t\t\treturn nil, errors.New(\"invalid range\")\n \t\t\t\t}"}, {"sha": "29eaf3475f12cc4b577dfc7da2ecc7e172de6951", "filename": "libgo/go/net/http/httputil/chunked.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fchunked.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fchunked.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fchunked.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -50,7 +50,7 @@ func (cr *chunkedReader) beginChunk() {\n \tif cr.err != nil {\n \t\treturn\n \t}\n-\tcr.n, cr.err = strconv.Btoui64(line, 16)\n+\tcr.n, cr.err = strconv.ParseUint(line, 16, 64)\n \tif cr.err != nil {\n \t\treturn\n \t}\n@@ -149,7 +149,7 @@ func (cw *chunkedWriter) Write(data []byte) (n int, err error) {\n \t\treturn 0, nil\n \t}\n \n-\thead := strconv.Itob(len(data), 16) + \"\\r\\n\"\n+\thead := strconv.FormatInt(int64(len(data)), 16) + \"\\r\\n\"\n \n \tif _, err = io.WriteString(cw.Wire, head); err != nil {\n \t\treturn 0, err"}, {"sha": "21eac4743ace34f59452243b14f388b7b5579e25", "filename": "libgo/go/net/http/pprof/pprof.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -63,7 +63,7 @@ func Heap(w http.ResponseWriter, r *http.Request) {\n // Profile responds with the pprof-formatted cpu profile.\n // The package initialization registers it as /debug/pprof/profile.\n func Profile(w http.ResponseWriter, r *http.Request) {\n-\tsec, _ := strconv.Atoi64(r.FormValue(\"seconds\"))\n+\tsec, _ := strconv.ParseInt(r.FormValue(\"seconds\"), 10, 64)\n \tif sec == 0 {\n \t\tsec = 30\n \t}\n@@ -111,7 +111,7 @@ func Symbol(w http.ResponseWriter, r *http.Request) {\n \t\tif err == nil {\n \t\t\tword = word[0 : len(word)-1] // trim +\n \t\t}\n-\t\tpc, _ := strconv.Btoui64(string(word), 0)\n+\t\tpc, _ := strconv.ParseUint(string(word), 0, 64)\n \t\tif pc != 0 {\n \t\t\tf := runtime.FuncForPC(uintptr(pc))\n \t\t\tif f != nil {"}, {"sha": "c100e4d5c6d5a62ac1d513c2f7a9d0e86c033174", "filename": "libgo/go/net/http/server.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -288,7 +288,7 @@ func (w *response) WriteHeader(code int) {\n \tvar contentLength int64\n \tif clenStr := w.header.Get(\"Content-Length\"); clenStr != \"\" {\n \t\tvar err error\n-\t\tcontentLength, err = strconv.Atoi64(clenStr)\n+\t\tcontentLength, err = strconv.ParseInt(clenStr, 10, 64)\n \t\tif err == nil {\n \t\t\thasCL = true\n \t\t} else {"}, {"sha": "ef9564af9c58b71a34d0f8bdddc0109f7a6f3dc3", "filename": "libgo/go/net/http/transfer.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -147,7 +147,7 @@ func (t *transferWriter) WriteHeader(w io.Writer) (err error) {\n \t// TransferEncoding)\n \tif t.shouldSendContentLength() {\n \t\tio.WriteString(w, \"Content-Length: \")\n-\t\t_, err = io.WriteString(w, strconv.Itoa64(t.ContentLength)+\"\\r\\n\")\n+\t\t_, err = io.WriteString(w, strconv.FormatInt(t.ContentLength, 10)+\"\\r\\n\")\n \t\tif err != nil {\n \t\t\treturn\n \t\t}\n@@ -432,7 +432,7 @@ func fixLength(isResponse bool, status int, requestMethod string, header Header,\n \t// Logic based on Content-Length\n \tcl := strings.TrimSpace(header.Get(\"Content-Length\"))\n \tif cl != \"\" {\n-\t\tn, err := strconv.Atoi64(cl)\n+\t\tn, err := strconv.ParseInt(cl, 10, 64)\n \t\tif err != nil || n < 0 {\n \t\t\treturn -1, &badStringError{\"bad Content-Length\", cl}\n \t\t}"}, {"sha": "dc70be43f2d7bb48c1bb0a4eeccd14edd1fd2a24", "filename": "libgo/go/net/http/transport.go", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -519,17 +519,11 @@ func (pc *persistConn) readLoop() {\n \n \tfor alive {\n \t\tpb, err := pc.br.Peek(1)\n-\t\tif err != nil {\n-\t\t\tif remoteSideClosed(err) && !pc.expectingResponse() {\n-\t\t\t\t// Remote side closed on us.  (We probably hit their\n-\t\t\t\t// max idle timeout)\n-\t\t\t\tpc.close()\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t}\n \t\tif !pc.expectingResponse() {\n-\t\t\tlog.Printf(\"Unsolicited response received on idle HTTP channel starting with %q; err=%v\",\n-\t\t\t\tstring(pb), err)\n+\t\t\tif len(pb) > 0 {\n+\t\t\t\tlog.Printf(\"Unsolicited response received on idle HTTP channel starting with %q; err=%v\",\n+\t\t\t\t\tstring(pb), err)\n+\t\t\t}\n \t\t\tpc.close()\n \t\t\treturn\n \t\t}"}, {"sha": "c9ef2c2ab6ea511219a05ce897cef116470ef461", "filename": "libgo/go/net/http/transport_windows.go", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef0d4c4d9937276c8ff818ecb0b92925d322d3bd/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef0d4c4d9937276c8ff818ecb0b92925d322d3bd/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_windows.go?ref=ef0d4c4d9937276c8ff818ecb0b92925d322d3bd", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package http\n-\n-import (\n-\t\"net\"\n-\t\"syscall\"\n-)\n-\n-func init() {\n-\tremoteSideClosedFunc = func(err error) (out bool) {\n-\t\top, ok := err.(*net.OpError)\n-\t\tif ok && op.Op == \"WSARecv\" && op.Net == \"tcp\" && op.Err == syscall.Errno(10058) {\n-\t\t\t// TODO(brainman,rsc): Fix whatever is generating this.\n-\t\t\treturn true\n-\t\t}\n-\t\treturn false\n-\t}\n-}"}, {"sha": "d3cb38a6517bd784e6962fb8fbcdd9c27b7998b5", "filename": "libgo/go/net/iprawsock_posix.go", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -267,16 +267,6 @@ func ListenIP(netProto string, laddr *IPAddr) (c *IPConn, err error) {\n \treturn newIPConn(fd), nil\n }\n \n-// BindToDevice binds an IPConn to a network interface.\n-func (c *IPConn) BindToDevice(device string) error {\n-\tif !c.ok() {\n-\t\treturn os.EINVAL\n-\t}\n-\tc.fd.incref()\n-\tdefer c.fd.decref()\n-\treturn os.NewSyscallError(\"setsockopt\", syscall.BindToDevice(c.fd.sysfd, device))\n-}\n-\n // File returns a copy of the underlying os.File, set to blocking mode.\n // It is the caller's responsibility to close f when finished.\n // Closing c does not affect f, and closing f does not affect c."}, {"sha": "bf22c711e49602ab3c1b62340e3a6b657ea9749f", "filename": "libgo/go/net/mail/message.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fmail%2Fmessage.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fmail%2Fmessage.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fmail%2Fmessage.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -481,7 +481,7 @@ func (qd qDecoder) Read(p []byte) (n int, err error) {\n \t\tif _, err := io.ReadFull(qd.r, qd.scratch[:2]); err != nil {\n \t\t\treturn 0, err\n \t\t}\n-\t\tx, err := strconv.Btoi64(string(qd.scratch[:2]), 16)\n+\t\tx, err := strconv.ParseInt(string(qd.scratch[:2]), 16, 64)\n \t\tif err != nil {\n \t\t\treturn 0, fmt.Errorf(\"mail: invalid RFC 2047 encoding: %q\", qd.scratch[:2])\n \t\t}"}, {"sha": "671ff2efacbee5674b496ef510883ba27ceff649", "filename": "libgo/go/net/mail/message_test.go", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fmail%2Fmessage_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fmail%2Fmessage_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fmail%2Fmessage_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -105,7 +105,7 @@ func TestDateParsing(t *testing.T) {\n \t\t\tt.Errorf(\"Failed parsing %q: %v\", test.dateStr, err)\n \t\t\tcontinue\n \t\t}\n-\t\tif !reflect.DeepEqual(date, test.exp) {\n+\t\tif !date.Equal(test.exp) {\n \t\t\tt.Errorf(\"Parse of %q: got %+v, want %+v\", test.dateStr, date, test.exp)\n \t\t}\n \t}\n@@ -119,37 +119,37 @@ func TestAddressParsing(t *testing.T) {\n \t\t// Bare address\n \t\t{\n \t\t\t`jdoe@machine.example`,\n-\t\t\t[]*Address{&Address{\n+\t\t\t[]*Address{{\n \t\t\t\tAddress: \"jdoe@machine.example\",\n \t\t\t}},\n \t\t},\n \t\t// RFC 5322, Appendix A.1.1\n \t\t{\n \t\t\t`John Doe <jdoe@machine.example>`,\n-\t\t\t[]*Address{&Address{\n+\t\t\t[]*Address{{\n \t\t\t\tName:    \"John Doe\",\n \t\t\t\tAddress: \"jdoe@machine.example\",\n \t\t\t}},\n \t\t},\n \t\t// RFC 5322, Appendix A.1.2\n \t\t{\n \t\t\t`\"Joe Q. Public\" <john.q.public@example.com>`,\n-\t\t\t[]*Address{&Address{\n+\t\t\t[]*Address{{\n \t\t\t\tName:    \"Joe Q. Public\",\n \t\t\t\tAddress: \"john.q.public@example.com\",\n \t\t\t}},\n \t\t},\n \t\t{\n \t\t\t`Mary Smith <mary@x.test>, jdoe@example.org, Who? <one@y.test>`,\n \t\t\t[]*Address{\n-\t\t\t\t&Address{\n+\t\t\t\t{\n \t\t\t\t\tName:    \"Mary Smith\",\n \t\t\t\t\tAddress: \"mary@x.test\",\n \t\t\t\t},\n-\t\t\t\t&Address{\n+\t\t\t\t{\n \t\t\t\t\tAddress: \"jdoe@example.org\",\n \t\t\t\t},\n-\t\t\t\t&Address{\n+\t\t\t\t{\n \t\t\t\t\tName:    \"Who?\",\n \t\t\t\t\tAddress: \"one@y.test\",\n \t\t\t\t},\n@@ -158,10 +158,10 @@ func TestAddressParsing(t *testing.T) {\n \t\t{\n \t\t\t`<boss@nil.test>, \"Giant; \\\"Big\\\" Box\" <sysservices@example.net>`,\n \t\t\t[]*Address{\n-\t\t\t\t&Address{\n+\t\t\t\t{\n \t\t\t\t\tAddress: \"boss@nil.test\",\n \t\t\t\t},\n-\t\t\t\t&Address{\n+\t\t\t\t{\n \t\t\t\t\tName:    `Giant; \"Big\" Box`,\n \t\t\t\t\tAddress: \"sysservices@example.net\",\n \t\t\t\t},\n@@ -174,7 +174,7 @@ func TestAddressParsing(t *testing.T) {\n \t\t{\n \t\t\t`=?iso-8859-1?q?J=F6rg_Doe?= <joerg@example.com>`,\n \t\t\t[]*Address{\n-\t\t\t\t&Address{\n+\t\t\t\t{\n \t\t\t\t\tName:    `J\u00f6rg Doe`,\n \t\t\t\t\tAddress: \"joerg@example.com\",\n \t\t\t\t},\n@@ -184,7 +184,7 @@ func TestAddressParsing(t *testing.T) {\n \t\t{\n \t\t\t`=?utf-8?q?J=C3=B6rg_Doe?= <joerg@example.com>`,\n \t\t\t[]*Address{\n-\t\t\t\t&Address{\n+\t\t\t\t{\n \t\t\t\t\tName:    `J\u00f6rg Doe`,\n \t\t\t\t\tAddress: \"joerg@example.com\",\n \t\t\t\t},\n@@ -194,7 +194,7 @@ func TestAddressParsing(t *testing.T) {\n \t\t{\n \t\t\t`=?ISO-8859-1?Q?Andr=E9?= Pirard <PIRARD@vm1.ulg.ac.be>`,\n \t\t\t[]*Address{\n-\t\t\t\t&Address{\n+\t\t\t\t{\n \t\t\t\t\tName:    `Andr\u00e9 Pirard`,\n \t\t\t\t\tAddress: \"PIRARD@vm1.ulg.ac.be\",\n \t\t\t\t},\n@@ -204,7 +204,7 @@ func TestAddressParsing(t *testing.T) {\n \t\t{\n \t\t\t`=?ISO-8859-1?B?SvZyZw==?= <joerg@example.com>`,\n \t\t\t[]*Address{\n-\t\t\t\t&Address{\n+\t\t\t\t{\n \t\t\t\t\tName:    `J\u00f6rg`,\n \t\t\t\t\tAddress: \"joerg@example.com\",\n \t\t\t\t},\n@@ -214,7 +214,7 @@ func TestAddressParsing(t *testing.T) {\n \t\t{\n \t\t\t`=?UTF-8?B?SsO2cmc=?= <joerg@example.com>`,\n \t\t\t[]*Address{\n-\t\t\t\t&Address{\n+\t\t\t\t{\n \t\t\t\t\tName:    `J\u00f6rg`,\n \t\t\t\t\tAddress: \"joerg@example.com\",\n \t\t\t\t},"}, {"sha": "777f204b18601005bf621ca3872953ce758e8dfe", "filename": "libgo/go/net/sock.go", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -111,11 +111,6 @@ func setReuseAddr(fd *netFD, reuse bool) error {\n \treturn setsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, boolint(reuse))\n }\n \n-func bindToDevice(fd *netFD, dev string) error {\n-\t// TODO(rsc): call setsockopt with null-terminated string pointer\n-\treturn os.EINVAL\n-}\n-\n func setDontRoute(fd *netFD, dontroute bool) error {\n \tfd.incref()\n \tdefer fd.decref()"}, {"sha": "c25ec9c506ac3fc3374482a9045a518d2636abc8", "filename": "libgo/go/net/udpsock_posix.go", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fudpsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fnet%2Fudpsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock_posix.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -240,16 +240,6 @@ func ListenUDP(net string, laddr *UDPAddr) (c *UDPConn, err error) {\n \treturn newUDPConn(fd), nil\n }\n \n-// BindToDevice binds a UDPConn to a network interface.\n-func (c *UDPConn) BindToDevice(device string) error {\n-\tif !c.ok() {\n-\t\treturn os.EINVAL\n-\t}\n-\tc.fd.incref()\n-\tdefer c.fd.decref()\n-\treturn os.NewSyscallError(\"setsockopt\", syscall.BindToDevice(c.fd.sysfd, device))\n-}\n-\n // File returns a copy of the underlying os.File, set to blocking mode.\n // It is the caller's responsibility to close f when finished.\n // Closing c does not affect f, and closing f does not affect c."}, {"sha": "e1bfa4724996f1bd791b6f0e1e35801ae4729718", "filename": "libgo/go/old/template/parse.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fold%2Ftemplate%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fold%2Ftemplate%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fold%2Ftemplate%2Fparse.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -424,11 +424,11 @@ func (t *Template) newVariable(words []string) *variableElement {\n \t\t\t}\n \n \t\tcase '.', '+', '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n-\t\t\tv, err := strconv.Btoi64(word, 0)\n+\t\t\tv, err := strconv.ParseInt(word, 0, 64)\n \t\t\tif err == nil {\n \t\t\t\targs[i] = v\n \t\t\t} else {\n-\t\t\t\tv, err := strconv.Atof64(word)\n+\t\t\t\tv, err := strconv.ParseFloat(word, 64)\n \t\t\t\targs[i], lerr = v, err\n \t\t\t}\n "}, {"sha": "a6e0c3e1b4e23915637628aa0481a592f724f000", "filename": "libgo/go/old/template/template_test.go", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fold%2Ftemplate%2Ftemplate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fold%2Ftemplate%2Ftemplate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fold%2Ftemplate%2Ftemplate_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -105,108 +105,108 @@ var formatters = FormatterMap{\n \n var tests = []*Test{\n \t// Simple\n-\t&Test{\"\", \"\", \"\"},\n-\t&Test{\"abc\", \"abc\", \"\"},\n-\t&Test{\"abc\\ndef\\n\", \"abc\\ndef\\n\", \"\"},\n-\t&Test{\" {.meta-left}   \\n\", \"{\", \"\"},\n-\t&Test{\" {.meta-right}   \\n\", \"}\", \"\"},\n-\t&Test{\" {.space}   \\n\", \" \", \"\"},\n-\t&Test{\" {.tab}   \\n\", \"\\t\", \"\"},\n-\t&Test{\"     {#comment}   \\n\", \"\", \"\"},\n-\t&Test{\"\\tSome Text\\t\\n\", \"\\tSome Text\\t\\n\", \"\"},\n-\t&Test{\" {.meta-right} {.meta-right} {.meta-right} \\n\", \" } } } \\n\", \"\"},\n+\t{\"\", \"\", \"\"},\n+\t{\"abc\", \"abc\", \"\"},\n+\t{\"abc\\ndef\\n\", \"abc\\ndef\\n\", \"\"},\n+\t{\" {.meta-left}   \\n\", \"{\", \"\"},\n+\t{\" {.meta-right}   \\n\", \"}\", \"\"},\n+\t{\" {.space}   \\n\", \" \", \"\"},\n+\t{\" {.tab}   \\n\", \"\\t\", \"\"},\n+\t{\"     {#comment}   \\n\", \"\", \"\"},\n+\t{\"\\tSome Text\\t\\n\", \"\\tSome Text\\t\\n\", \"\"},\n+\t{\" {.meta-right} {.meta-right} {.meta-right} \\n\", \" } } } \\n\", \"\"},\n \n \t// Variables at top level\n-\t&Test{\n+\t{\n \t\tin: \"{Header}={Integer}\\n\",\n \n \t\tout: \"Header=77\\n\",\n \t},\n \n-\t&Test{\n+\t{\n \t\tin: \"Pointers: {*HeaderPtr}={*IntegerPtr}\\n\",\n \n \t\tout: \"Pointers: Header=77\\n\",\n \t},\n \n-\t&Test{\n+\t{\n \t\tin: \"Stars but not pointers: {*Header}={*Integer}\\n\",\n \n \t\tout: \"Stars but not pointers: Header=77\\n\",\n \t},\n \n-\t&Test{\n+\t{\n \t\tin: \"nil pointer: {*NilPtr}={*Integer}\\n\",\n \n \t\tout: \"nil pointer: <nil>=77\\n\",\n \t},\n \n-\t&Test{\n+\t{\n \t\tin: `{\"Strings\" \":\"} {\"\"} {\"|\"} {\"\\t\\u0123 \\x23\\\\\"} {\"\\\"}{\\\\\"}`,\n \n \t\tout: \"Strings:  | \\t\\u0123 \\x23\\\\ \\\"}{\\\\\",\n \t},\n \n-\t&Test{\n+\t{\n \t\tin: \"{`Raw strings` `:`} {``} {`|`} {`\\\\t\\\\u0123 \\\\x23\\\\`} {`}{\\\\`}\",\n \n \t\tout: \"Raw strings:  | \\\\t\\\\u0123 \\\\x23\\\\ }{\\\\\",\n \t},\n \n-\t&Test{\n+\t{\n \t\tin: \"Characters: {'a'} {'\\\\u0123'} {' '} {'{'} {'|'} {'}'}\",\n \n \t\tout: \"Characters: 97 291 32 123 124 125\",\n \t},\n \n-\t&Test{\n+\t{\n \t\tin: \"Integers: {1} {-2} {+42} {0777} {0x0a}\",\n \n \t\tout: \"Integers: 1 -2 42 511 10\",\n \t},\n \n-\t&Test{\n+\t{\n \t\tin: \"Floats: {.5} {-.5} {1.1} {-2.2} {+42.1} {1e10} {1.2e-3} {1.2e3} {-1.2e3}\",\n \n \t\tout: \"Floats: 0.5 -0.5 1.1 -2.2 42.1 1e+10 0.0012 1200 -1200\",\n \t},\n \n \t// Method at top level\n-\t&Test{\n+\t{\n \t\tin: \"ptrmethod={PointerMethod}\\n\",\n \n \t\tout: \"ptrmethod=ptrmethod!\\n\",\n \t},\n \n-\t&Test{\n+\t{\n \t\tin: \"valmethod={ValueMethod}\\n\",\n \n \t\tout: \"valmethod=valmethod!\\n\",\n \t},\n \n \t// Section\n-\t&Test{\n+\t{\n \t\tin: \"{.section Data }\\n\" +\n \t\t\t\"some text for the section\\n\" +\n \t\t\t\"{.end}\\n\",\n \n \t\tout: \"some text for the section\\n\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{.section Data }\\n\" +\n \t\t\t\"{Header}={Integer}\\n\" +\n \t\t\t\"{.end}\\n\",\n \n \t\tout: \"Header=77\\n\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{.section Pdata }\\n\" +\n \t\t\t\"{Header}={Integer}\\n\" +\n \t\t\t\"{.end}\\n\",\n \n \t\tout: \"Header=77\\n\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{.section Pdata }\\n\" +\n \t\t\t\"data present\\n\" +\n \t\t\t\"{.or}\\n\" +\n@@ -215,7 +215,7 @@ var tests = []*Test{\n \n \t\tout: \"data present\\n\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{.section Empty }\\n\" +\n \t\t\t\"data present\\n\" +\n \t\t\t\"{.or}\\n\" +\n@@ -224,7 +224,7 @@ var tests = []*Test{\n \n \t\tout: \"data not present\\n\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{.section Null }\\n\" +\n \t\t\t\"data present\\n\" +\n \t\t\t\"{.or}\\n\" +\n@@ -233,7 +233,7 @@ var tests = []*Test{\n \n \t\tout: \"data not present\\n\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{.section Pdata }\\n\" +\n \t\t\t\"{Header}={Integer}\\n\" +\n \t\t\t\"{.section @ }\\n\" +\n@@ -245,20 +245,20 @@ var tests = []*Test{\n \t\t\t\"Header=77\\n\",\n \t},\n \n-\t&Test{\n+\t{\n \t\tin: \"{.section Data}{.end} {Header}\\n\",\n \n \t\tout: \" Header\\n\",\n \t},\n \n-\t&Test{\n+\t{\n \t\tin: \"{.section Integer}{@}{.end}\",\n \n \t\tout: \"77\",\n \t},\n \n \t// Repeated\n-\t&Test{\n+\t{\n \t\tin: \"{.section Pdata }\\n\" +\n \t\t\t\"{.repeated section @ }\\n\" +\n \t\t\t\"{Item}={Value}\\n\" +\n@@ -268,7 +268,7 @@ var tests = []*Test{\n \t\tout: \"ItemNumber1=ValueNumber1\\n\" +\n \t\t\t\"ItemNumber2=ValueNumber2\\n\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{.section Pdata }\\n\" +\n \t\t\t\"{.repeated section @ }\\n\" +\n \t\t\t\"{Item}={Value}\\n\" +\n@@ -280,7 +280,7 @@ var tests = []*Test{\n \t\tout: \"ItemNumber1=ValueNumber1\\n\" +\n \t\t\t\"ItemNumber2=ValueNumber2\\n\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{.section @ }\\n\" +\n \t\t\t\"{.repeated section Empty }\\n\" +\n \t\t\t\"{Item}={Value}\\n\" +\n@@ -291,7 +291,7 @@ var tests = []*Test{\n \n \t\tout: \"this should appear: empty field\\n\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{.repeated section Pdata }\\n\" +\n \t\t\t\"{Item}\\n\" +\n \t\t\t\"{.alternates with}\\n\" +\n@@ -302,7 +302,7 @@ var tests = []*Test{\n \t\t\t\"is\\nover\\nmultiple\\nlines\\n\" +\n \t\t\t\"ItemNumber2\\n\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{.repeated section Pdata }\\n\" +\n \t\t\t\"{Item}\\n\" +\n \t\t\t\"{.alternates with}\\n\" +\n@@ -313,7 +313,7 @@ var tests = []*Test{\n \t\t\t\"is\\nover\\nmultiple\\nlines\\n\" +\n \t\t\t\"ItemNumber2\\n\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{.section Pdata }\\n\" +\n \t\t\t\"{.repeated section @ }\\n\" +\n \t\t\t\"{Item}={Value}\\n\" +\n@@ -327,7 +327,7 @@ var tests = []*Test{\n \t\t\t\"DIVIDER\\n\" +\n \t\t\t\"ItemNumber2=ValueNumber2\\n\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{.repeated section Vec }\\n\" +\n \t\t\t\"{@}\\n\" +\n \t\t\t\"{.end}\\n\",\n@@ -336,42 +336,42 @@ var tests = []*Test{\n \t\t\t\"elt2\\n\",\n \t},\n \t// Same but with a space before {.end}: was a bug.\n-\t&Test{\n+\t{\n \t\tin: \"{.repeated section Vec }\\n\" +\n \t\t\t\"{@} {.end}\\n\",\n \n \t\tout: \"elt1 elt2 \\n\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{.repeated section Integer}{.end}\",\n \n \t\terr: \"line 1: .repeated: cannot repeat Integer (type int)\",\n \t},\n \n \t// Nested names\n-\t&Test{\n+\t{\n \t\tin: \"{.section @ }\\n\" +\n \t\t\t\"{InnerT.Item}={InnerT.Value}\\n\" +\n \t\t\t\"{.end}\",\n \n \t\tout: \"ItemNumber1=ValueNumber1\\n\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{.section @ }\\n\" +\n \t\t\t\"{InnerT.Item}={.section InnerT}{.section Value}{@}{.end}{.end}\\n\" +\n \t\t\t\"{.end}\",\n \n \t\tout: \"ItemNumber1=ValueNumber1\\n\",\n \t},\n \n-\t&Test{\n+\t{\n \t\tin: \"{.section Emptystring}emptystring{.end}\\n\" +\n \t\t\t\"{.section Header}header{.end}\\n\",\n \n \t\tout: \"\\nheader\\n\",\n \t},\n \n-\t&Test{\n+\t{\n \t\tin: \"{.section True}1{.or}2{.end}\\n\" +\n \t\t\t\"{.section False}3{.or}4{.end}\\n\",\n \n@@ -380,53 +380,53 @@ var tests = []*Test{\n \n \t// Maps\n \n-\t&Test{\n+\t{\n \t\tin: \"{Mp.mapkey}\\n\",\n \n \t\tout: \"Ahoy!\\n\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{Innermap.Mp.innerkey}\\n\",\n \n \t\tout: \"55\\n\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{.section Innermap}{.section Mp}{innerkey}{.end}{.end}\\n\",\n \n \t\tout: \"55\\n\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{.section JSON}{.repeated section maps}{a}{b}{.end}{.end}\\n\",\n \n \t\tout: \"1234\\n\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{Stringmap.stringkey1}\\n\",\n \n \t\tout: \"stringresult\\n\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{.repeated section Stringmap}\\n\" +\n \t\t\t\"{@}\\n\" +\n \t\t\t\"{.end}\",\n \n \t\tout: \"stringresult\\n\" +\n \t\t\t\"stringresult\\n\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{.repeated section Stringmap}\\n\" +\n \t\t\t\"\\t{@}\\n\" +\n \t\t\t\"{.end}\",\n \n \t\tout: \"\\tstringresult\\n\" +\n \t\t\t\"\\tstringresult\\n\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{*Ptrmap.stringkey1}\\n\",\n \n \t\tout: \"pointedToString\\n\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{.repeated section Ptrmap}\\n\" +\n \t\t\t\"{*@}\\n\" +\n \t\t\t\"{.end}\",\n@@ -437,22 +437,22 @@ var tests = []*Test{\n \n \t// Interface values\n \n-\t&Test{\n+\t{\n \t\tin: \"{Iface}\",\n \n \t\tout: \"[1 2 3]\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{.repeated section Iface}{@}{.alternates with} {.end}\",\n \n \t\tout: \"1 2 3\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{.section Iface}{@}{.end}\",\n \n \t\tout: \"[1 2 3]\",\n \t},\n-\t&Test{\n+\t{\n \t\tin: \"{.section Ifaceptr}{Item} {Value}{.end}\",\n \n \t\tout: \"Item Value\","}, {"sha": "d09e839a397693502c2e492bf5fbcb6713a5eb9d", "filename": "libgo/go/os/exec/lp_windows.go", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fos%2Fexec%2Flp_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fos%2Fexec%2Flp_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Flp_windows.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -63,11 +63,10 @@ func LookPath(file string) (f string, err error) {\n \t\t}\n \t\treturn ``, &Error{file, err}\n \t}\n-\tif pathenv := os.Getenv(`PATH`); pathenv == `` {\n-\t\tif f, err = findExecutable(`.\\`+file, exts); err == nil {\n-\t\t\treturn\n-\t\t}\n-\t} else {\n+\tif f, err = findExecutable(`.\\`+file, exts); err == nil {\n+\t\treturn\n+\t}\n+\tif pathenv := os.Getenv(`PATH`); pathenv != `` {\n \t\tfor _, dir := range strings.Split(pathenv, `;`) {\n \t\t\tif f, err = findExecutable(dir+`\\`+file, exts); err == nil {\n \t\t\t\treturn"}, {"sha": "b5b0dedcd40970e9a985e77f09d3fa4e25239b12", "filename": "libgo/go/path/filepath/path_test.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -259,19 +259,19 @@ type Node struct {\n var tree = &Node{\n \t\"testdata\",\n \t[]*Node{\n-\t\t&Node{\"a\", nil, 0},\n-\t\t&Node{\"b\", []*Node{}, 0},\n-\t\t&Node{\"c\", nil, 0},\n-\t\t&Node{\n+\t\t{\"a\", nil, 0},\n+\t\t{\"b\", []*Node{}, 0},\n+\t\t{\"c\", nil, 0},\n+\t\t{\n \t\t\t\"d\",\n \t\t\t[]*Node{\n-\t\t\t\t&Node{\"x\", nil, 0},\n-\t\t\t\t&Node{\"y\", []*Node{}, 0},\n-\t\t\t\t&Node{\n+\t\t\t\t{\"x\", nil, 0},\n+\t\t\t\t{\"y\", []*Node{}, 0},\n+\t\t\t\t{\n \t\t\t\t\t\"z\",\n \t\t\t\t\t[]*Node{\n-\t\t\t\t\t\t&Node{\"u\", nil, 0},\n-\t\t\t\t\t\t&Node{\"v\", nil, 0},\n+\t\t\t\t\t\t{\"u\", nil, 0},\n+\t\t\t\t\t\t{\"v\", nil, 0},\n \t\t\t\t\t},\n \t\t\t\t\t0,\n \t\t\t\t},"}, {"sha": "7d1cb094e5cf4b5d95a0956301fad3723526744e", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -64,7 +64,7 @@ var typeTests = []pair{\n \t{struct{ x (**integer) }{}, \"**reflect_test.integer\"},\n \t{struct{ x ([32]int32) }{}, \"[32]int32\"},\n \t{struct{ x ([]int8) }{}, \"[]int8\"},\n-\t{struct{ x (map[string]int32) }{}, \"map[string] int32\"},\n+\t{struct{ x (map[string]int32) }{}, \"map[string]int32\"},\n \t{struct{ x (chan<- string) }{}, \"chan<- string\"},\n \t{struct {\n \t\tx struct {\n@@ -180,7 +180,7 @@ var valueTests = []pair{\n \t{new(**int8), \"**int8(0)\"},\n \t{new([5]int32), \"[5]int32{0, 0, 0, 0, 0}\"},\n \t{new(**integer), \"**reflect_test.integer(0)\"},\n-\t{new(map[string]int32), \"map[string] int32{<can't iterate on maps>}\"},\n+\t{new(map[string]int32), \"map[string]int32{<can't iterate on maps>}\"},\n \t{new(chan<- string), \"chan<- string\"},\n \t{new(func(a int8, b int32)), \"func(int8, int32)(0)\"},\n \t{new(struct {\n@@ -419,7 +419,7 @@ func TestAll(t *testing.T) {\n \ttestType(t, 8, typ.Elem(), \"int32\")\n \n \ttyp = TypeOf((map[string]*int32)(nil))\n-\ttestType(t, 9, typ, \"map[string] *int32\")\n+\ttestType(t, 9, typ, \"map[string]*int32\")\n \tmtyp := typ\n \ttestType(t, 10, mtyp.Key(), \"string\")\n \ttestType(t, 11, mtyp.Elem(), \"*int32\")\n@@ -468,8 +468,8 @@ func TestInterfaceValue(t *testing.T) {\n func TestFunctionValue(t *testing.T) {\n \tvar x interface{} = func() {}\n \tv := ValueOf(x)\n-\tif v.Interface() != v.Interface() || v.Interface() != x {\n-\t\tt.Fatalf(\"TestFunction != itself\")\n+\tif fmt.Sprint(v.Interface()) != fmt.Sprint(x) {\n+\t\tt.Fatalf(\"TestFunction returned wrong pointer\")\n \t}\n \tassert(t, v.Type().String(), \"func()\")\n }"}, {"sha": "7486a9bfca3e935471de18bdaa14493d94519b5a", "filename": "libgo/go/reflect/tostring_test.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Freflect%2Ftostring_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Freflect%2Ftostring_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftostring_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -23,14 +23,14 @@ func valueToString(val Value) string {\n \ttyp := val.Type()\n \tswitch val.Kind() {\n \tcase Int, Int8, Int16, Int32, Int64:\n-\t\treturn strconv.Itoa64(val.Int())\n+\t\treturn strconv.FormatInt(val.Int(), 10)\n \tcase Uint, Uint8, Uint16, Uint32, Uint64, Uintptr:\n-\t\treturn strconv.Uitoa64(val.Uint())\n+\t\treturn strconv.FormatUint(val.Uint(), 10)\n \tcase Float32, Float64:\n-\t\treturn strconv.Ftoa64(val.Float(), 'g', -1)\n+\t\treturn strconv.FormatFloat(val.Float(), 'g', -1, 64)\n \tcase Complex64, Complex128:\n \t\tc := val.Complex()\n-\t\treturn strconv.Ftoa64(real(c), 'g', -1) + \"+\" + strconv.Ftoa64(imag(c), 'g', -1) + \"i\"\n+\t\treturn strconv.FormatFloat(real(c), 'g', -1, 64) + \"+\" + strconv.FormatFloat(imag(c), 'g', -1, 64) + \"i\"\n \tcase String:\n \t\treturn val.String()\n \tcase Bool:\n@@ -88,7 +88,7 @@ func valueToString(val Value) string {\n \t\treturn typ.String() + \"(\" + valueToString(val.Elem()) + \")\"\n \tcase Func:\n \t\tv := val\n-\t\treturn typ.String() + \"(\" + strconv.Uitoa64(uint64(v.Pointer())) + \")\"\n+\t\treturn typ.String() + \"(\" + strconv.FormatUint(uint64(v.Pointer()), 10) + \")\"\n \tdefault:\n \t\tpanic(\"valueToString: can't print type \" + typ.String())\n \t}"}, {"sha": "84ebb835581c2f2d64574bf58c0f462c1bf7b435", "filename": "libgo/go/regexp/syntax/prog.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fregexp%2Fsyntax%2Fprog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fregexp%2Fsyntax%2Fprog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fprog.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -267,7 +267,7 @@ func dumpProg(b *bytes.Buffer, p *Prog) {\n }\n \n func u32(i uint32) string {\n-\treturn strconv.Uitoa64(uint64(i))\n+\treturn strconv.FormatUint(uint64(i), 10)\n }\n \n func dumpInst(b *bytes.Buffer, i *Inst) {"}, {"sha": "adcfe294495445301b950851e830a10293bca8ab", "filename": "libgo/go/regexp/syntax/regexp.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fregexp%2Fsyntax%2Fregexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fregexp%2Fsyntax%2Fregexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fregexp.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -277,15 +277,15 @@ func escape(b *bytes.Buffer, r rune, force bool) {\n \tdefault:\n \t\tif r < 0x100 {\n \t\t\tb.WriteString(`\\x`)\n-\t\t\ts := strconv.Itob(int(r), 16)\n+\t\t\ts := strconv.FormatInt(int64(r), 16)\n \t\t\tif len(s) == 1 {\n \t\t\t\tb.WriteRune('0')\n \t\t\t}\n \t\t\tb.WriteString(s)\n \t\t\tbreak\n \t\t}\n \t\tb.WriteString(`\\x{`)\n-\t\tb.WriteString(strconv.Itob(int(r), 16))\n+\t\tb.WriteString(strconv.FormatInt(int64(r), 16))\n \t\tb.WriteString(`}`)\n \t}\n }"}, {"sha": "1508118d2acf7423b9e4d4139756c6f5804d5970", "filename": "libgo/go/strconv/atob.go", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fatob.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fatob.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fatob.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -4,10 +4,10 @@\n \n package strconv\n \n-// Atob returns the boolean value represented by the string.\n+// ParseBool returns the boolean value represented by the string.\n // It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False.\n // Any other value returns an error.\n-func Atob(str string) (value bool, err error) {\n+func ParseBool(str string) (value bool, err error) {\n \tswitch str {\n \tcase \"1\", \"t\", \"T\", \"true\", \"TRUE\", \"True\":\n \t\treturn true, nil\n@@ -17,10 +17,19 @@ func Atob(str string) (value bool, err error) {\n \treturn false, &NumError{str, ErrSyntax}\n }\n \n-// Btoa returns \"true\" or \"false\" according to the value of the boolean argument\n-func Btoa(b bool) string {\n+// FormatBool returns \"true\" or \"false\" according to the value of b\n+func FormatBool(b bool) string {\n \tif b {\n \t\treturn \"true\"\n \t}\n \treturn \"false\"\n }\n+\n+// AppendBool appends \"true\" or \"false\", according to the value of b,\n+// to dst and returns the extended buffer.\n+func AppendBool(dst []byte, b bool) []byte {\n+\tif b {\n+\t\treturn append(dst, \"true\"...)\n+\t}\n+\treturn append(dst, \"false\"...)\n+}"}, {"sha": "a7c1454eb1ef9390d63b7f5048181b1ebb05dcf9", "filename": "libgo/go/strconv/atob_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fatob_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fatob_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fatob_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -32,9 +32,9 @@ var atobtests = []atobTest{\n \t{\"True\", true, nil},\n }\n \n-func TestAtob(t *testing.T) {\n+func TestParseBool(t *testing.T) {\n \tfor _, test := range atobtests {\n-\t\tb, e := Atob(test.in)\n+\t\tb, e := ParseBool(test.in)\n \t\tif test.err != nil {\n \t\t\t// expect an error\n \t\t\tif e == nil {"}, {"sha": "1642c18d74888a475364c45982d7e8ce4aa00c3f", "filename": "libgo/go/strconv/atof.go", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fatof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fatof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fatof.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -338,21 +338,7 @@ func (d *decimal) atof32() (f float32, ok bool) {\n \treturn\n }\n \n-// Atof32 converts the string s to a 32-bit floating-point number.\n-//\n-// If s is well-formed and near a valid floating point number,\n-// Atof32 returns the nearest floating point number rounded\n-// using IEEE754 unbiased rounding.\n-//\n-// The errors that Atof32 returns have concrete type *NumError\n-// and include err.Num = s.\n-//\n-// If s is not syntactically well-formed, Atof32 returns err.Error = ErrSyntax.\n-//\n-// If s is syntactically well-formed but is more than 1/2 ULP\n-// away from the largest floating point number of the given size,\n-// Atof32 returns f = \u00b1Inf, err.Error = ErrRange.\n-func Atof32(s string) (f float32, err error) {\n+func atof32(s string) (f float32, err error) {\n \tif val, ok := special(s); ok {\n \t\treturn float32(val), nil\n \t}\n@@ -374,10 +360,7 @@ func Atof32(s string) (f float32, err error) {\n \treturn f, err\n }\n \n-// Atof64 converts the string s to a 64-bit floating-point number.\n-// Except for the type of its result, its definition is the same as that\n-// of Atof32.\n-func Atof64(s string) (f float64, err error) {\n+func atof64(s string) (f float64, err error) {\n \tif val, ok := special(s); ok {\n \t\treturn val, nil\n \t}\n@@ -399,14 +382,28 @@ func Atof64(s string) (f float64, err error) {\n \treturn f, err\n }\n \n-// AtofN converts the string s to a 64-bit floating-point number,\n-// but it rounds the result assuming that it will be stored in a value\n-// of n bits (32 or 64).\n-func AtofN(s string, n int) (f float64, err error) {\n-\tif n == 32 {\n-\t\tf1, err1 := Atof32(s)\n+// ParseFloat converts the string s to a floating-point number\n+// with the precision specified by bitSize: 32 for float32, or 64 for float64.\n+// When bitSize=32, the result still has type float64, but it will be\n+// convertible to float32 without changing its value.\n+//\n+// If s is well-formed and near a valid floating point number,\n+// ParseFloat returns the nearest floating point number rounded\n+// using IEEE754 unbiased rounding.\n+//\n+// The errors that ParseFloat returns have concrete type *NumError\n+// and include err.Num = s.\n+//\n+// If s is not syntactically well-formed, ParseFloat returns err.Error = ErrSyntax.\n+//\n+// If s is syntactically well-formed but is more than 1/2 ULP\n+// away from the largest floating point number of the given size,\n+// ParseFloat returns f = \u00b1Inf, err.Error = ErrRange.\n+func ParseFloat(s string, bitSize int) (f float64, err error) {\n+\tif bitSize == 32 {\n+\t\tf1, err1 := atof32(s)\n \t\treturn float64(f1), err1\n \t}\n-\tf1, err1 := Atof64(s)\n+\tf1, err1 := atof64(s)\n \treturn f1, err1\n }"}, {"sha": "a9820d1bbad96bea4d36b61d66e4a3beb2b4af36", "filename": "libgo/go/strconv/atof_test.go", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fatof_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fatof_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fatof_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -128,33 +128,23 @@ func testAtof(t *testing.T, opt bool) {\n \toldopt := SetOptimize(opt)\n \tfor i := 0; i < len(atoftests); i++ {\n \t\ttest := &atoftests[i]\n-\t\tout, err := Atof64(test.in)\n-\t\touts := Ftoa64(out, 'g', -1)\n+\t\tout, err := ParseFloat(test.in, 64)\n+\t\touts := FormatFloat(out, 'g', -1, 64)\n \t\tif outs != test.out || !reflect.DeepEqual(err, test.err) {\n-\t\t\tt.Errorf(\"Atof64(%v) = %v, %v want %v, %v\",\n-\t\t\t\ttest.in, out, err, test.out, test.err)\n-\t\t}\n-\n-\t\tout, err = AtofN(test.in, 64)\n-\t\touts = FtoaN(out, 'g', -1, 64)\n-\t\tif outs != test.out || !reflect.DeepEqual(err, test.err) {\n-\t\t\tt.Errorf(\"AtofN(%v, 64) = %v, %v want %v, %v\",\n+\t\t\tt.Errorf(\"ParseFloat(%v, 64) = %v, %v want %v, %v\",\n \t\t\t\ttest.in, out, err, test.out, test.err)\n \t\t}\n \n \t\tif float64(float32(out)) == out {\n-\t\t\tout32, err := Atof32(test.in)\n-\t\t\touts := Ftoa32(out32, 'g', -1)\n-\t\t\tif outs != test.out || !reflect.DeepEqual(err, test.err) {\n-\t\t\t\tt.Errorf(\"Atof32(%v) = %v, %v want %v, %v  # %v\",\n-\t\t\t\t\ttest.in, out32, err, test.out, test.err, out)\n+\t\t\tout, err := ParseFloat(test.in, 32)\n+\t\t\tout32 := float32(out)\n+\t\t\tif float64(out32) != out {\n+\t\t\t\tt.Errorf(\"ParseFloat(%v, 32) = %v, not a float32 (closest is %v)\", test.in, out, float64(out32))\n+\t\t\t\tcontinue\n \t\t\t}\n-\n-\t\t\tout, err := AtofN(test.in, 32)\n-\t\t\tout32 = float32(out)\n-\t\t\touts = FtoaN(float64(out32), 'g', -1, 32)\n+\t\t\touts := FormatFloat(float64(out32), 'g', -1, 32)\n \t\t\tif outs != test.out || !reflect.DeepEqual(err, test.err) {\n-\t\t\t\tt.Errorf(\"AtofN(%v, 32) = %v, %v want %v, %v  # %v\",\n+\t\t\t\tt.Errorf(\"ParseFloat(%v, 32) = %v, %v want %v, %v  # %v\",\n \t\t\t\t\ttest.in, out32, err, test.out, test.err, out)\n \t\t\t}\n \t\t}\n@@ -168,24 +158,24 @@ func TestAtofSlow(t *testing.T) { testAtof(t, false) }\n \n func BenchmarkAtof64Decimal(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tAtof64(\"33909\")\n+\t\tParseFloat(\"33909\", 64)\n \t}\n }\n \n func BenchmarkAtof64Float(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tAtof64(\"339.7784\")\n+\t\tParseFloat(\"339.7784\", 64)\n \t}\n }\n \n func BenchmarkAtof64FloatExp(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tAtof64(\"-5.09e75\")\n+\t\tParseFloat(\"-5.09e75\", 64)\n \t}\n }\n \n func BenchmarkAtof64Big(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tAtof64(\"123456789123456789123456789\")\n+\t\tParseFloat(\"123456789123456789123456789\", 64)\n \t}\n }"}, {"sha": "438d496948d4522958f27a260fef6f7d4be7e0cc", "filename": "libgo/go/strconv/atoi.go", "status": "modified", "additions": 37, "deletions": 65, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fatoi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fatoi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fatoi.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -20,15 +20,9 @@ type NumError struct {\n \n func (e *NumError) Error() string { return `parsing \"` + e.Num + `\": ` + e.Err.Error() }\n \n-func computeIntsize() uint {\n-\tsiz := uint(8)\n-\tfor 1<<siz != 0 {\n-\t\tsiz *= 2\n-\t}\n-\treturn siz\n-}\n+const intSize = 32 << uint(^uint(0)>>63)\n \n-var IntSize = computeIntsize()\n+const IntSize = intSize // number of bits in int, uint (32 or 64)\n \n // Return the first number n such that n*base >= 1<<64.\n func cutoff64(base int) uint64 {\n@@ -38,17 +32,13 @@ func cutoff64(base int) uint64 {\n \treturn (1<<64-1)/uint64(base) + 1\n }\n \n-// Btoui64 interprets a string s in an arbitrary base b (2 to 36)\n-// and returns the corresponding value n.  If b == 0, the base\n-// is taken from the string prefix: base 16 for \"0x\", base 8 for \"0\",\n-// and base 10 otherwise.\n-//\n-// The errors that Btoui64 returns have concrete type *NumError\n-// and include err.Num = s.  If s is empty or contains invalid\n-// digits, err.Error = ErrSyntax; if the value corresponding\n-// to s cannot be represented by a uint64, err.Error = ErrRange.\n-func Btoui64(s string, b int) (n uint64, err error) {\n-\tvar cutoff uint64\n+// ParseUint is like ParseInt but for unsigned numbers.\n+func ParseUint(s string, b int, bitSize int) (n uint64, err error) {\n+\tvar cutoff, maxVal uint64\n+\n+\tif bitSize == 0 {\n+\t\tbitSize = int(IntSize)\n+\t}\n \n \ts0 := s\n \tswitch {\n@@ -82,6 +72,7 @@ func Btoui64(s string, b int) (n uint64, err error) {\n \n \tn = 0\n \tcutoff = cutoff64(b)\n+\tmaxVal = 1<<uint(bitSize) - 1\n \n \tfor i := 0; i < len(s); i++ {\n \t\tvar v byte\n@@ -113,7 +104,7 @@ func Btoui64(s string, b int) (n uint64, err error) {\n \t\tn *= uint64(b)\n \n \t\tn1 := n + uint64(v)\n-\t\tif n1 < n {\n+\t\tif n1 < n || n1 > maxVal {\n \t\t\t// n+v overflows\n \t\t\tn = 1<<64 - 1\n \t\t\terr = ErrRange\n@@ -128,18 +119,25 @@ Error:\n \treturn n, &NumError{s0, err}\n }\n \n-// Atoui64 interprets a string s as a decimal number and\n-// returns the corresponding value n.\n+// ParseInt interprets a string s in an arbitrary base b (2 to 36)\n+// and returns the corresponding value n.  If b == 0, the base\n+// is taken from the string prefix: base 16 for \"0x\", base 8 for \"0\",\n+// and base 10 otherwise.\n //\n-// Atoui64 returns err.Error = ErrSyntax if s is empty or contains invalid digits.\n-// It returns err.Error = ErrRange if s cannot be represented by a uint64.\n-func Atoui64(s string) (n uint64, err error) {\n-\treturn Btoui64(s, 10)\n-}\n+// The bitSize argument specifies the integer type\n+// that the result must fit into.  Bit sizes 0, 8, 16, 32, and 64\n+// correspond to int, int8, int16, int32, and int64.\n+//\n+// The errors that ParseInt returns have concrete type *NumError\n+// and include err.Num = s.  If s is empty or contains invalid\n+// digits, err.Error = ErrSyntax; if the value corresponding\n+// to s cannot be represented by a signed integer of the\n+// given size, err.Error = ErrRange.\n+func ParseInt(s string, base int, bitSize int) (i int64, err error) {\n+\tif bitSize == 0 {\n+\t\tbitSize = int(IntSize)\n+\t}\n \n-// Btoi64 is like Btoui64 but allows signed numbers and\n-// returns its result in an int64.\n-func Btoi64(s string, base int) (i int64, err error) {\n \t// Empty string bad.\n \tif len(s) == 0 {\n \t\treturn 0, &NumError{s, ErrSyntax}\n@@ -157,16 +155,17 @@ func Btoi64(s string, base int) (i int64, err error) {\n \n \t// Convert unsigned and check range.\n \tvar un uint64\n-\tun, err = Btoui64(s, base)\n+\tun, err = ParseUint(s, base, bitSize)\n \tif err != nil && err.(*NumError).Err != ErrRange {\n \t\terr.(*NumError).Num = s0\n \t\treturn 0, err\n \t}\n-\tif !neg && un >= 1<<63 {\n-\t\treturn 1<<63 - 1, &NumError{s0, ErrRange}\n+\tcutoff := uint64(1 << uint(bitSize-1))\n+\tif !neg && un >= cutoff {\n+\t\treturn int64(cutoff - 1), &NumError{s0, ErrRange}\n \t}\n-\tif neg && un > 1<<63 {\n-\t\treturn -1 << 63, &NumError{s0, ErrRange}\n+\tif neg && un > cutoff {\n+\t\treturn -int64(cutoff), &NumError{s0, ErrRange}\n \t}\n \tn := int64(un)\n \tif neg {\n@@ -175,35 +174,8 @@ func Btoi64(s string, base int) (i int64, err error) {\n \treturn n, nil\n }\n \n-// Atoi64 is like Atoui64 but allows signed numbers and\n-// returns its result in an int64.\n-func Atoi64(s string) (i int64, err error) { return Btoi64(s, 10) }\n-\n-// Atoui is like Atoui64 but returns its result as a uint.\n-func Atoui(s string) (i uint, err error) {\n-\ti1, e1 := Atoui64(s)\n-\tif e1 != nil && e1.(*NumError).Err != ErrRange {\n-\t\treturn 0, e1\n-\t}\n-\ti = uint(i1)\n-\tif uint64(i) != i1 {\n-\t\treturn ^uint(0), &NumError{s, ErrRange}\n-\t}\n-\treturn i, nil\n-}\n-\n-// Atoi is like Atoi64 but returns its result as an int.\n+// Atoi is shorthand for ParseInt(s, 10, 0).\n func Atoi(s string) (i int, err error) {\n-\ti1, e1 := Atoi64(s)\n-\tif e1 != nil && e1.(*NumError).Err != ErrRange {\n-\t\treturn 0, e1\n-\t}\n-\ti = int(i1)\n-\tif int64(i) != i1 {\n-\t\tif i1 < 0 {\n-\t\t\treturn -1 << (IntSize - 1), &NumError{s, ErrRange}\n-\t\t}\n-\t\treturn 1<<(IntSize-1) - 1, &NumError{s, ErrRange}\n-\t}\n-\treturn i, nil\n+\ti64, err := ParseInt(s, 10, 0)\n+\treturn int(i64), err\n }"}, {"sha": "2d06efed0def09c96223c368b6b66dd70d927722", "filename": "libgo/go/strconv/atoi_test.go", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fatoi_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fatoi_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fatoi_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -187,56 +187,56 @@ func init() {\n \t}\n }\n \n-func TestAtoui64(t *testing.T) {\n+func TestParseUint64(t *testing.T) {\n \tfor i := range atoui64tests {\n \t\ttest := &atoui64tests[i]\n-\t\tout, err := Atoui64(test.in)\n+\t\tout, err := ParseUint(test.in, 10, 64)\n \t\tif test.out != out || !reflect.DeepEqual(test.err, err) {\n \t\t\tt.Errorf(\"Atoui64(%q) = %v, %v want %v, %v\",\n \t\t\t\ttest.in, out, err, test.out, test.err)\n \t\t}\n \t}\n }\n \n-func TestBtoui64(t *testing.T) {\n+func TestParseUint64Base(t *testing.T) {\n \tfor i := range btoui64tests {\n \t\ttest := &btoui64tests[i]\n-\t\tout, err := Btoui64(test.in, 0)\n+\t\tout, err := ParseUint(test.in, 0, 64)\n \t\tif test.out != out || !reflect.DeepEqual(test.err, err) {\n-\t\t\tt.Errorf(\"Btoui64(%q) = %v, %v want %v, %v\",\n+\t\t\tt.Errorf(\"ParseUint(%q) = %v, %v want %v, %v\",\n \t\t\t\ttest.in, out, err, test.out, test.err)\n \t\t}\n \t}\n }\n \n-func TestAtoi64(t *testing.T) {\n+func TestParseInt64(t *testing.T) {\n \tfor i := range atoi64tests {\n \t\ttest := &atoi64tests[i]\n-\t\tout, err := Atoi64(test.in)\n+\t\tout, err := ParseInt(test.in, 10, 64)\n \t\tif test.out != out || !reflect.DeepEqual(test.err, err) {\n \t\t\tt.Errorf(\"Atoi64(%q) = %v, %v want %v, %v\",\n \t\t\t\ttest.in, out, err, test.out, test.err)\n \t\t}\n \t}\n }\n \n-func TestBtoi64(t *testing.T) {\n+func TestParseInt64Base(t *testing.T) {\n \tfor i := range btoi64tests {\n \t\ttest := &btoi64tests[i]\n-\t\tout, err := Btoi64(test.in, 0)\n+\t\tout, err := ParseInt(test.in, 0, 64)\n \t\tif test.out != out || !reflect.DeepEqual(test.err, err) {\n-\t\t\tt.Errorf(\"Btoi64(%q) = %v, %v want %v, %v\",\n+\t\t\tt.Errorf(\"ParseInt(%q) = %v, %v want %v, %v\",\n \t\t\t\ttest.in, out, err, test.out, test.err)\n \t\t}\n \t}\n }\n \n-func TestAtoui(t *testing.T) {\n+func TestParseUint(t *testing.T) {\n \tswitch IntSize {\n \tcase 32:\n \t\tfor i := range atoui32tests {\n \t\t\ttest := &atoui32tests[i]\n-\t\t\tout, err := Atoui(test.in)\n+\t\t\tout, err := ParseUint(test.in, 10, 0)\n \t\t\tif test.out != uint32(out) || !reflect.DeepEqual(test.err, err) {\n \t\t\t\tt.Errorf(\"Atoui(%q) = %v, %v want %v, %v\",\n \t\t\t\t\ttest.in, out, err, test.out, test.err)\n@@ -245,7 +245,7 @@ func TestAtoui(t *testing.T) {\n \tcase 64:\n \t\tfor i := range atoui64tests {\n \t\t\ttest := &atoui64tests[i]\n-\t\t\tout, err := Atoui(test.in)\n+\t\t\tout, err := ParseUint(test.in, 10, 0)\n \t\t\tif test.out != uint64(out) || !reflect.DeepEqual(test.err, err) {\n \t\t\t\tt.Errorf(\"Atoui(%q) = %v, %v want %v, %v\",\n \t\t\t\t\ttest.in, out, err, test.out, test.err)\n@@ -254,12 +254,12 @@ func TestAtoui(t *testing.T) {\n \t}\n }\n \n-func TestAtoi(t *testing.T) {\n+func TestParseInt(t *testing.T) {\n \tswitch IntSize {\n \tcase 32:\n \t\tfor i := range atoi32tests {\n \t\t\ttest := &atoi32tests[i]\n-\t\t\tout, err := Atoi(test.in)\n+\t\t\tout, err := ParseInt(test.in, 10, 0)\n \t\t\tif test.out != int32(out) || !reflect.DeepEqual(test.err, err) {\n \t\t\t\tt.Errorf(\"Atoi(%q) = %v, %v want %v, %v\",\n \t\t\t\t\ttest.in, out, err, test.out, test.err)\n@@ -268,7 +268,7 @@ func TestAtoi(t *testing.T) {\n \tcase 64:\n \t\tfor i := range atoi64tests {\n \t\t\ttest := &atoi64tests[i]\n-\t\t\tout, err := Atoi(test.in)\n+\t\t\tout, err := ParseInt(test.in, 10, 0)\n \t\t\tif test.out != int64(out) || !reflect.DeepEqual(test.err, err) {\n \t\t\t\tt.Errorf(\"Atoi(%q) = %v, %v want %v, %v\",\n \t\t\t\t\ttest.in, out, err, test.out, test.err)\n@@ -279,24 +279,24 @@ func TestAtoi(t *testing.T) {\n \n func BenchmarkAtoi(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tAtoi(\"12345678\")\n+\t\tParseInt(\"12345678\", 10, 0)\n \t}\n }\n \n func BenchmarkAtoiNeg(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tAtoi(\"-12345678\")\n+\t\tParseInt(\"-12345678\", 10, 0)\n \t}\n }\n \n func BenchmarkAtoi64(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tAtoi64(\"12345678901234\")\n+\t\tParseInt(\"12345678901234\", 10, 64)\n \t}\n }\n \n func BenchmarkAtoi64Neg(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tAtoi64(\"-12345678901234\")\n+\t\tParseInt(\"-12345678901234\", 10, 64)\n \t}\n }"}, {"sha": "47877e373aaecc68c53a8897dabc6a1019999710", "filename": "libgo/go/strconv/fp_test.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Ffp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Ffp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Ffp_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -31,7 +31,7 @@ func pow2(i int) float64 {\n func myatof64(s string) (f float64, ok bool) {\n \ta := strings.SplitN(s, \"p\", 2)\n \tif len(a) == 2 {\n-\t\tn, err := strconv.Atoi64(a[0])\n+\t\tn, err := strconv.ParseInt(a[0], 10, 64)\n \t\tif err != nil {\n \t\t\treturn 0, false\n \t\t}\n@@ -63,7 +63,7 @@ func myatof64(s string) (f float64, ok bool) {\n \t\t}\n \t\treturn v * pow2(e), true\n \t}\n-\tf1, err := strconv.Atof64(s)\n+\tf1, err := strconv.ParseFloat(s, 64)\n \tif err != nil {\n \t\treturn 0, false\n \t}\n@@ -87,7 +87,8 @@ func myatof32(s string) (f float32, ok bool) {\n \t\t}\n \t\treturn float32(float64(n) * pow2(e)), true\n \t}\n-\tf1, err1 := strconv.Atof32(s)\n+\tf64, err1 := strconv.ParseFloat(s, 32)\n+\tf1 := float32(f64)\n \tif err1 != nil {\n \t\treturn 0, false\n \t}"}, {"sha": "e1ea0a350383d46b84b76443557e16f3248740c9", "filename": "libgo/go/strconv/ftoa.go", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fftoa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fftoa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fftoa.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -22,8 +22,10 @@ type floatInfo struct {\n var float32info = floatInfo{23, 8, -127}\n var float64info = floatInfo{52, 11, -1023}\n \n-// Ftoa32 converts the 32-bit floating-point number f to a string,\n-// according to the format fmt and precision prec.\n+// FormatFloat converts the floating-point number f to a string,\n+// according to the format fmt and precision prec.  It rounds the\n+// result assuming that the original was obtained from a floating-point\n+// value of bitSize bits (32 for float32, 64 for float64).\n //\n // The format fmt is one of\n // 'b' (-ddddp\u00b1ddd, a binary exponent),\n@@ -43,24 +45,17 @@ var float64info = floatInfo{52, 11, -1023}\n // Ftoa32(f) is not the same as Ftoa64(float32(f)),\n // because correct rounding and the number of digits\n // needed to identify f depend on the precision of the representation.\n-func Ftoa32(f float32, fmt byte, prec int) string {\n-\treturn genericFtoa(uint64(math.Float32bits(f)), fmt, prec, &float32info)\n-}\n-\n-// Ftoa64 is like Ftoa32 but converts a 64-bit floating-point number.\n-func Ftoa64(f float64, fmt byte, prec int) string {\n+func FormatFloat(f float64, fmt byte, prec int, n int) string {\n+\tif n == 32 {\n+\t\treturn genericFtoa(uint64(math.Float32bits(float32(f))), fmt, prec, &float32info)\n+\t}\n \treturn genericFtoa(math.Float64bits(f), fmt, prec, &float64info)\n }\n \n-// FtoaN converts the 64-bit floating-point number f to a string,\n-// according to the format fmt and precision prec, but it rounds the\n-// result assuming that it was obtained from a floating-point value\n-// of n bits (32 or 64).\n-func FtoaN(f float64, fmt byte, prec int, n int) string {\n-\tif n == 32 {\n-\t\treturn Ftoa32(float32(f), fmt, prec)\n-\t}\n-\treturn Ftoa64(f, fmt, prec)\n+// AppendFloat appends the string form of the floating-point number f,\n+// as generated by FormatFloat, to dst and returns the extended buffer.\n+func AppendFloat(dst []byte, f float64, fmt byte, prec int, n int) []byte {\n+\treturn append(dst, FormatFloat(f, fmt, prec, n)...)\n }\n \n func genericFtoa(bits uint64, fmt byte, prec int, flt *floatInfo) string {"}, {"sha": "02206d5ad25351044c6b4936d99c0d71ebe387db", "filename": "libgo/go/strconv/ftoa_test.go", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fftoa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fftoa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fftoa_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -128,47 +128,47 @@ var ftoatests = []ftoaTest{\n func TestFtoa(t *testing.T) {\n \tfor i := 0; i < len(ftoatests); i++ {\n \t\ttest := &ftoatests[i]\n-\t\ts := Ftoa64(test.f, test.fmt, test.prec)\n-\t\tif s != test.s {\n-\t\t\tt.Error(\"test\", test.f, string(test.fmt), test.prec, \"want\", test.s, \"got\", s)\n-\t\t}\n-\t\ts = FtoaN(test.f, test.fmt, test.prec, 64)\n+\t\ts := FormatFloat(test.f, test.fmt, test.prec, 64)\n \t\tif s != test.s {\n \t\t\tt.Error(\"testN=64\", test.f, string(test.fmt), test.prec, \"want\", test.s, \"got\", s)\n \t\t}\n+\t\tx := AppendFloat([]byte(\"abc\"), test.f, test.fmt, test.prec, 64)\n+\t\tif string(x) != \"abc\"+test.s {\n+\t\t\tt.Error(\"AppendFloat testN=64\", test.f, string(test.fmt), test.prec, \"want\", \"abc\"+test.s, \"got\", string(x))\n+\t\t}\n \t\tif float64(float32(test.f)) == test.f && test.fmt != 'b' {\n-\t\t\ts := Ftoa32(float32(test.f), test.fmt, test.prec)\n-\t\t\tif s != test.s {\n-\t\t\t\tt.Error(\"test32\", test.f, string(test.fmt), test.prec, \"want\", test.s, \"got\", s)\n-\t\t\t}\n-\t\t\ts = FtoaN(test.f, test.fmt, test.prec, 32)\n+\t\t\ts := FormatFloat(test.f, test.fmt, test.prec, 32)\n \t\t\tif s != test.s {\n \t\t\t\tt.Error(\"testN=32\", test.f, string(test.fmt), test.prec, \"want\", test.s, \"got\", s)\n \t\t\t}\n+\t\t\tx := AppendFloat([]byte(\"abc\"), test.f, test.fmt, test.prec, 32)\n+\t\t\tif string(x) != \"abc\"+test.s {\n+\t\t\t\tt.Error(\"AppendFloat testN=32\", test.f, string(test.fmt), test.prec, \"want\", \"abc\"+test.s, \"got\", string(x))\n+\t\t\t}\n \t\t}\n \t}\n }\n \n func BenchmarkFtoa64Decimal(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tFtoa64(33909, 'g', -1)\n+\t\tFormatFloat(33909, 'g', -1, 64)\n \t}\n }\n \n func BenchmarkFtoa64Float(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tFtoa64(339.7784, 'g', -1)\n+\t\tFormatFloat(339.7784, 'g', -1, 64)\n \t}\n }\n \n func BenchmarkFtoa64FloatExp(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tFtoa64(-5.09e75, 'g', -1)\n+\t\tFormatFloat(-5.09e75, 'g', -1, 64)\n \t}\n }\n \n func BenchmarkFtoa64Big(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tFtoa64(123456789123456789123456789, 'g', -1)\n+\t\tFormatFloat(123456789123456789123456789, 'g', -1, 64)\n \t}\n }"}, {"sha": "65229f704b8f4e6fcde0a65155e6ecd6f3ade34d", "filename": "libgo/go/strconv/itoa.go", "status": "modified", "additions": 94, "deletions": 38, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fitoa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fitoa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fitoa.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -4,54 +4,110 @@\n \n package strconv\n \n-// Uitob64 returns the string representation of i in the given base.\n-func Uitob64(u uint64, base uint) string {\n-\tif base < 2 || 36 < base {\n-\t\tpanic(\"invalid base \" + Uitoa(base))\n-\t}\n-\tif u == 0 {\n-\t\treturn \"0\"\n-\t}\n+// FormatUint returns the string representation of i in the given base.\n+func FormatUint(i uint64, base int) string {\n+\t_, s := formatBits(nil, i, base, false, false)\n+\treturn s\n+}\n \n-\t// Assemble decimal in reverse order.\n-\tvar buf [64]byte\n-\tj := len(buf)\n-\tb := uint64(base)\n-\tfor u > 0 {\n-\t\tj--\n-\t\tbuf[j] = \"0123456789abcdefghijklmnopqrstuvwxyz\"[u%b]\n-\t\tu /= b\n-\t}\n+// FormatInt returns the string representation of i in the given base.\n+func FormatInt(i int64, base int) string {\n+\t_, s := formatBits(nil, uint64(i), base, i < 0, false)\n+\treturn s\n+}\n+\n+// Itoa is shorthand for FormatInt(i, 10).\n+func Itoa(i int) string {\n+\treturn FormatInt(int64(i), 10)\n+}\n+\n+// AppendInt appends the string form of the integer i,\n+// as generated by FormatInt, to dst and returns the extended buffer.\n+func AppendInt(dst []byte, i int64, base int) []byte {\n+\tdst, _ = formatBits(dst, uint64(i), base, i < 0, true)\n+\treturn dst\n+}\n \n-\treturn string(buf[j:])\n+// AppendUint appends the string form of the unsigned integer i,\n+// as generated by FormatUint, to dst and returns the extended buffer.\n+func AppendUint(dst []byte, i uint64, base int) []byte {\n+\tdst, _ = formatBits(dst, i, base, false, true)\n+\treturn dst\n }\n \n-// Itob64 returns the string representation of i in the given base.\n-func Itob64(i int64, base uint) string {\n-\tif i == 0 {\n-\t\treturn \"0\"\n+const digits = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n+\n+var shifts = [len(digits) + 1]uint{\n+\t1 << 1: 1,\n+\t1 << 2: 2,\n+\t1 << 3: 3,\n+\t1 << 4: 4,\n+\t1 << 5: 5,\n+}\n+\n+// formatBits computes the string representation of u in the given base.\n+// If negative is set, u is treated as negative int64 value. If append_\n+// is set, the string is appended to dst and the resulting byte slice is\n+// returned as the first result value; otherwise the string is returned\n+// as the second result value.\n+//\n+func formatBits(dst []byte, u uint64, base int, negative, append_ bool) (d []byte, s string) {\n+\tif base < 2 || base > len(digits) {\n+\t\tpanic(\"invalid base\")\n \t}\n+\t// 2 <= base && base <= len(digits)\n \n-\tif i < 0 {\n-\t\treturn \"-\" + Uitob64(-uint64(i), base)\n+\tvar a [64 + 1]byte // +1 for sign of 64bit value in base 2\n+\ti := len(a)\n+\n+\tif negative {\n+\t\tu = -u\n \t}\n-\treturn Uitob64(uint64(i), base)\n-}\n \n-// Itoa64 returns the decimal string representation of i.\n-func Itoa64(i int64) string { return Itob64(i, 10) }\n+\t// convert bits\n+\tif base == 10 {\n+\t\t// common case: use constant 10 for / and % because\n+\t\t// the compiler can optimize it into a multiply+shift\n+\t\tfor u >= 10 {\n+\t\t\ti--\n+\t\t\ta[i] = digits[u%10]\n+\t\t\tu /= 10\n+\t\t}\n \n-// Uitoa64 returns the decimal string representation of i.\n-func Uitoa64(i uint64) string { return Uitob64(i, 10) }\n+\t} else if s := shifts[base]; s > 0 {\n+\t\t// base is power of 2: use shifts and masks instead of / and %\n+\t\tb := uint64(base)\n+\t\tm := uintptr(b) - 1 // == 1<<s - 1\n+\t\tfor u >= b {\n+\t\t\ti--\n+\t\t\ta[i] = digits[uintptr(u)&m]\n+\t\t\tu >>= s\n+\t\t}\n \n-// Uitob returns the string representation of i in the given base.\n-func Uitob(i uint, base uint) string { return Uitob64(uint64(i), base) }\n+\t} else {\n+\t\t// general case\n+\t\tb := uint64(base)\n+\t\tfor u >= b {\n+\t\t\ti--\n+\t\t\ta[i] = digits[u%b]\n+\t\t\tu /= b\n+\t\t}\n+\t}\n \n-// Itob returns the string representation of i in the given base.\n-func Itob(i int, base uint) string { return Itob64(int64(i), base) }\n+\t// u < base\n+\ti--\n+\ta[i] = digits[uintptr(u)]\n \n-// Itoa returns the decimal string representation of i.\n-func Itoa(i int) string { return Itob64(int64(i), 10) }\n+\t// add sign, if any\n+\tif negative {\n+\t\ti--\n+\t\ta[i] = '-'\n+\t}\n \n-// Uitoa returns the decimal string representation of i.\n-func Uitoa(i uint) string { return Uitob64(uint64(i), 10) }\n+\tif append_ {\n+\t\td = append(dst, a[i:]...)\n+\t\treturn\n+\t}\n+\ts = string(a[i:])\n+\treturn\n+}"}, {"sha": "e0213ae9afecd4d1540b2644f9a255abaa321cd7", "filename": "libgo/go/strconv/itoa_test.go", "status": "modified", "additions": 55, "deletions": 69, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fitoa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fitoa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fitoa_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -11,7 +11,7 @@ import (\n \n type itob64Test struct {\n \tin   int64\n-\tbase uint\n+\tbase int\n \tout  string\n }\n \n@@ -60,73 +60,43 @@ var itob64tests = []itob64Test{\n \n func TestItoa(t *testing.T) {\n \tfor _, test := range itob64tests {\n-\t\ts := Itob64(test.in, test.base)\n+\t\ts := FormatInt(test.in, test.base)\n \t\tif s != test.out {\n-\t\t\tt.Errorf(\"Itob64(%v, %v) = %v want %v\",\n+\t\t\tt.Errorf(\"FormatInt(%v, %v) = %v want %v\",\n \t\t\t\ttest.in, test.base, s, test.out)\n \t\t}\n-\n-\t\tif test.in >= 0 {\n-\t\t\ts := Uitob64(uint64(test.in), test.base)\n-\t\t\tif s != test.out {\n-\t\t\t\tt.Errorf(\"Uitob64(%v, %v) = %v want %v\",\n-\t\t\t\t\ttest.in, test.base, s, test.out)\n-\t\t\t}\n+\t\tx := AppendInt([]byte(\"abc\"), test.in, test.base)\n+\t\tif string(x) != \"abc\"+test.out {\n+\t\t\tt.Errorf(\"AppendInt(%q, %v, %v) = %q want %v\",\n+\t\t\t\t\"abc\", test.in, test.base, x, test.out)\n \t\t}\n \n-\t\tif int64(int(test.in)) == test.in {\n-\t\t\ts := Itob(int(test.in), test.base)\n+\t\tif test.in >= 0 {\n+\t\t\ts := FormatUint(uint64(test.in), test.base)\n \t\t\tif s != test.out {\n-\t\t\t\tt.Errorf(\"Itob(%v, %v) = %v want %v\",\n+\t\t\t\tt.Errorf(\"FormatUint(%v, %v) = %v want %v\",\n \t\t\t\t\ttest.in, test.base, s, test.out)\n \t\t\t}\n-\n-\t\t\tif test.in >= 0 {\n-\t\t\t\ts := Uitob(uint(test.in), test.base)\n-\t\t\t\tif s != test.out {\n-\t\t\t\t\tt.Errorf(\"Uitob(%v, %v) = %v want %v\",\n-\t\t\t\t\t\ttest.in, test.base, s, test.out)\n-\t\t\t\t}\n+\t\t\tx := AppendUint(nil, uint64(test.in), test.base)\n+\t\t\tif string(x) != test.out {\n+\t\t\t\tt.Errorf(\"AppendUint(%q, %v, %v) = %q want %v\",\n+\t\t\t\t\t\"abc\", uint64(test.in), test.base, x, test.out)\n \t\t\t}\n \t\t}\n \n-\t\tif test.base == 10 {\n-\t\t\ts := Itoa64(test.in)\n+\t\tif test.base == 10 && int64(int(test.in)) == test.in {\n+\t\t\ts := Itoa(int(test.in))\n \t\t\tif s != test.out {\n-\t\t\t\tt.Errorf(\"Itoa64(%v) = %v want %v\",\n+\t\t\t\tt.Errorf(\"Itoa(%v) = %v want %v\",\n \t\t\t\t\ttest.in, s, test.out)\n \t\t\t}\n-\n-\t\t\tif test.in >= 0 {\n-\t\t\t\ts := Uitob64(uint64(test.in), test.base)\n-\t\t\t\tif s != test.out {\n-\t\t\t\t\tt.Errorf(\"Uitob64(%v, %v) = %v want %v\",\n-\t\t\t\t\t\ttest.in, test.base, s, test.out)\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif int64(int(test.in)) == test.in {\n-\t\t\t\ts := Itoa(int(test.in))\n-\t\t\t\tif s != test.out {\n-\t\t\t\t\tt.Errorf(\"Itoa(%v) = %v want %v\",\n-\t\t\t\t\t\ttest.in, s, test.out)\n-\t\t\t\t}\n-\n-\t\t\t\tif test.in >= 0 {\n-\t\t\t\t\ts := Uitoa(uint(test.in))\n-\t\t\t\t\tif s != test.out {\n-\t\t\t\t\t\tt.Errorf(\"Uitoa(%v) = %v want %v\",\n-\t\t\t\t\t\t\ttest.in, s, test.out)\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n \t\t}\n \t}\n }\n \n type uitob64Test struct {\n \tin   uint64\n-\tbase uint\n+\tbase int\n \tout  string\n }\n \n@@ -141,34 +111,50 @@ var uitob64tests = []uitob64Test{\n \n func TestUitoa(t *testing.T) {\n \tfor _, test := range uitob64tests {\n-\t\ts := Uitob64(test.in, test.base)\n+\t\ts := FormatUint(test.in, test.base)\n \t\tif s != test.out {\n-\t\t\tt.Errorf(\"Uitob64(%v, %v) = %v want %v\",\n+\t\t\tt.Errorf(\"FormatUint(%v, %v) = %v want %v\",\n \t\t\t\ttest.in, test.base, s, test.out)\n \t\t}\n+\t\tx := AppendUint([]byte(\"abc\"), test.in, test.base)\n+\t\tif string(x) != \"abc\"+test.out {\n+\t\t\tt.Errorf(\"AppendUint(%q, %v, %v) = %q want %v\",\n+\t\t\t\t\"abc\", test.in, test.base, x, test.out)\n+\t\t}\n \n-\t\tif uint64(uint(test.in)) == test.in {\n-\t\t\ts := Uitob(uint(test.in), test.base)\n-\t\t\tif s != test.out {\n-\t\t\t\tt.Errorf(\"Uitob(%v, %v) = %v want %v\",\n-\t\t\t\t\ttest.in, test.base, s, test.out)\n-\t\t\t}\n+\t}\n+}\n+\n+func BenchmarkFormatInt(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tfor _, test := range itob64tests {\n+\t\t\tFormatInt(test.in, test.base)\n \t\t}\n+\t}\n+}\n \n-\t\tif test.base == 10 {\n-\t\t\ts := Uitoa64(test.in)\n-\t\t\tif s != test.out {\n-\t\t\t\tt.Errorf(\"Uitoa64(%v) = %v want %v\",\n-\t\t\t\t\ttest.in, s, test.out)\n-\t\t\t}\n+func BenchmarkAppendInt(b *testing.B) {\n+\tdst := make([]byte, 0, 30)\n+\tfor i := 0; i < b.N; i++ {\n+\t\tfor _, test := range itob64tests {\n+\t\t\tAppendInt(dst, test.in, test.base)\n+\t\t}\n+\t}\n+}\n \n-\t\t\tif uint64(uint(test.in)) == test.in {\n-\t\t\t\ts := Uitoa(uint(test.in))\n-\t\t\t\tif s != test.out {\n-\t\t\t\t\tt.Errorf(\"Uitoa(%v) = %v want %v\",\n-\t\t\t\t\t\ttest.in, s, test.out)\n-\t\t\t\t}\n-\t\t\t}\n+func BenchmarkFormatUint(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tfor _, test := range uitob64tests {\n+\t\t\tFormatUint(test.in, test.base)\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkAppendUint(b *testing.B) {\n+\tdst := make([]byte, 0, 30)\n+\tfor i := 0; i < b.N; i++ {\n+\t\tfor _, test := range uitob64tests {\n+\t\t\tAppendUint(dst, test.in, test.base)\n \t\t}\n \t}\n }"}, {"sha": "30b384df8e3541a497cd6b10c93fd2a8b48478cb", "filename": "libgo/go/strconv/quote.go", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fquote.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fquote.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fquote.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -92,6 +92,12 @@ func Quote(s string) string {\n \treturn quoteWith(s, '\"', false)\n }\n \n+// AppendQuote appends a double-quoted Go string literal representing s,\n+// as generated by Quote, to dst and returns the extended buffer.\n+func AppendQuote(dst []byte, s string) []byte {\n+\treturn append(dst, Quote(s)...)\n+}\n+\n // QuoteToASCII returns a double-quoted Go string literal representing s.\n // The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\n // non-ASCII characters and non-printable characters as defined by\n@@ -100,6 +106,12 @@ func QuoteToASCII(s string) string {\n \treturn quoteWith(s, '\"', true)\n }\n \n+// AppendQuoteToASCII appends a double-quoted Go string literal representing s,\n+// as generated by QuoteToASCII, to dst and returns the extended buffer.\n+func AppendQuoteToASCII(dst []byte, s string) []byte {\n+\treturn append(dst, QuoteToASCII(s)...)\n+}\n+\n // QuoteRune returns a single-quoted Go character literal representing the\n // rune.  The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100)\n // for control characters and non-printable characters as defined by\n@@ -109,6 +121,12 @@ func QuoteRune(rune int) string {\n \treturn quoteWith(string(rune), '\\'', false)\n }\n \n+// AppendQuoteRune appends a single-quoted Go character literal representing the rune,\n+// as generated by QuoteRune, to dst and returns the extended buffer.\n+func AppendQuoteRune(dst []byte, rune int) []byte {\n+\treturn append(dst, QuoteRune(rune)...)\n+}\n+\n // QuoteRuneToASCII returns a single-quoted Go character literal representing\n // the rune.  The returned string uses Go escape sequences (\\t, \\n, \\xFF,\n // \\u0100) for non-ASCII characters and non-printable characters as defined\n@@ -118,6 +136,12 @@ func QuoteRuneToASCII(rune int) string {\n \treturn quoteWith(string(rune), '\\'', true)\n }\n \n+// AppendQuoteRune appends a single-quoted Go character literal representing the rune,\n+// as generated by QuoteRuneToASCII, to dst and returns the extended buffer.\n+func AppendQuoteRuneToASCII(dst []byte, rune int) []byte {\n+\treturn append(dst, QuoteRuneToASCII(rune)...)\n+}\n+\n // CanBackquote returns whether the string s would be\n // a valid Go string literal if enclosed in backquotes.\n func CanBackquote(s string) bool {"}, {"sha": "e440797162b32e5cfd14b1a1a2f522118dfbacac", "filename": "libgo/go/strconv/quote_test.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fquote_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fstrconv%2Fquote_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fquote_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -29,6 +29,9 @@ func TestQuote(t *testing.T) {\n \t\tif out := Quote(tt.in); out != tt.out {\n \t\t\tt.Errorf(\"Quote(%s) = %s, want %s\", tt.in, out, tt.out)\n \t\t}\n+\t\tif out := AppendQuote([]byte(\"abc\"), tt.in); string(out) != \"abc\"+tt.out {\n+\t\t\tt.Errorf(\"AppendQuote(%q, %s) = %s, want %s\", \"abc\", tt.in, out, \"abc\"+tt.out)\n+\t\t}\n \t}\n }\n \n@@ -37,6 +40,9 @@ func TestQuoteToASCII(t *testing.T) {\n \t\tif out := QuoteToASCII(tt.in); out != tt.ascii {\n \t\t\tt.Errorf(\"QuoteToASCII(%s) = %s, want %s\", tt.in, out, tt.ascii)\n \t\t}\n+\t\tif out := AppendQuoteToASCII([]byte(\"abc\"), tt.in); string(out) != \"abc\"+tt.ascii {\n+\t\t\tt.Errorf(\"AppendQuoteToASCII(%q, %s) = %s, want %s\", \"abc\", tt.in, out, \"abc\"+tt.ascii)\n+\t\t}\n \t}\n }\n \n@@ -63,6 +69,9 @@ func TestQuoteRune(t *testing.T) {\n \t\tif out := QuoteRune(tt.in); out != tt.out {\n \t\t\tt.Errorf(\"QuoteRune(%U) = %s, want %s\", tt.in, out, tt.out)\n \t\t}\n+\t\tif out := AppendQuoteRune([]byte(\"abc\"), tt.in); string(out) != \"abc\"+tt.out {\n+\t\t\tt.Errorf(\"AppendQuoteRune(%q, %U) = %s, want %s\", \"abc\", tt.in, out, \"abc\"+tt.out)\n+\t\t}\n \t}\n }\n \n@@ -71,6 +80,9 @@ func TestQuoteRuneToASCII(t *testing.T) {\n \t\tif out := QuoteRuneToASCII(tt.in); out != tt.ascii {\n \t\t\tt.Errorf(\"QuoteRuneToASCII(%U) = %s, want %s\", tt.in, out, tt.ascii)\n \t\t}\n+\t\tif out := AppendQuoteRuneToASCII([]byte(\"abc\"), tt.in); string(out) != \"abc\"+tt.ascii {\n+\t\t\tt.Errorf(\"AppendQuoteRuneToASCII(%q, %U) = %s, want %s\", \"abc\", tt.in, out, \"abc\"+tt.ascii)\n+\t\t}\n \t}\n }\n "}, {"sha": "3abb51f3383b9d9c8a074108269517331e031117", "filename": "libgo/go/text/template/multi_test.go", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Ftext%2Ftemplate%2Fmulti_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Ftext%2Ftemplate%2Fmulti_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fmulti_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -13,35 +13,6 @@ import (\n \t\"text/template/parse\"\n )\n \n-type isEmptyTest struct {\n-\tname  string\n-\tinput string\n-\tempty bool\n-}\n-\n-var isEmptyTests = []isEmptyTest{\n-\t{\"empty\", ``, true},\n-\t{\"nonempty\", `hello`, false},\n-\t{\"spaces only\", \" \\t\\n \\t\\n\", true},\n-\t{\"definition\", `{{define \"x\"}}something{{end}}`, true},\n-\t{\"definitions and space\", \"{{define `x`}}something{{end}}\\n\\n{{define `y`}}something{{end}}\\n\\n\", true},\n-\t{\"definitions and text\", \"{{define `x`}}something{{end}}\\nx\\n{{define `y`}}something{{end}}\\ny\\n}}\", false},\n-\t{\"definition and action\", \"{{define `x`}}something{{end}}{{if 3}}foo{{end}}\", false},\n-}\n-\n-func TestIsEmpty(t *testing.T) {\n-\tfor _, test := range isEmptyTests {\n-\t\ttemplate, err := New(\"root\").Parse(test.input)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"%q: unexpected error: %v\", test.name, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif empty := isEmpty(template.Root); empty != test.empty {\n-\t\t\tt.Errorf(\"%q: expected %t got %t\", test.name, test.empty, empty)\n-\t\t}\n-\t}\n-}\n-\n const (\n \tnoError  = true\n \thasError = false"}, {"sha": "4f43424239a0340fbe3d25999bad6eeb646c5ef0", "filename": "libgo/go/text/template/parse/node.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fnode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fnode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fnode.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -267,7 +267,7 @@ func newNumber(text string, typ itemType) (*NumberNode, error) {\n \t}\n \t// Imaginary constants can only be complex unless they are zero.\n \tif len(text) > 0 && text[len(text)-1] == 'i' {\n-\t\tf, err := strconv.Atof64(text[:len(text)-1])\n+\t\tf, err := strconv.ParseFloat(text[:len(text)-1], 64)\n \t\tif err == nil {\n \t\t\tn.IsComplex = true\n \t\t\tn.Complex128 = complex(0, f)\n@@ -276,12 +276,12 @@ func newNumber(text string, typ itemType) (*NumberNode, error) {\n \t\t}\n \t}\n \t// Do integer test first so we get 0x123 etc.\n-\tu, err := strconv.Btoui64(text, 0) // will fail for -0; fixed below.\n+\tu, err := strconv.ParseUint(text, 0, 64) // will fail for -0; fixed below.\n \tif err == nil {\n \t\tn.IsUint = true\n \t\tn.Uint64 = u\n \t}\n-\ti, err := strconv.Btoi64(text, 0)\n+\ti, err := strconv.ParseInt(text, 0, 64)\n \tif err == nil {\n \t\tn.IsInt = true\n \t\tn.Int64 = i\n@@ -298,7 +298,7 @@ func newNumber(text string, typ itemType) (*NumberNode, error) {\n \t\tn.IsFloat = true\n \t\tn.Float64 = float64(n.Uint64)\n \t} else {\n-\t\tf, err := strconv.Atof64(text)\n+\t\tf, err := strconv.ParseFloat(text, 64)\n \t\tif err == nil {\n \t\t\tn.IsFloat = true\n \t\t\tn.Float64 = f"}, {"sha": "4da756657d5201c152a42b13050c628407603bce", "filename": "libgo/go/text/template/parse/parse.go", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -7,6 +7,7 @@\n package parse\n \n import (\n+\t\"bytes\"\n \t\"fmt\"\n \t\"runtime\"\n \t\"strconv\"\n@@ -177,10 +178,37 @@ func (t *Tree) Parse(s, leftDelim, rightDelim string, treeSet map[string]*Tree,\n \n // add adds tree to the treeSet.\n func (t *Tree) add(treeSet map[string]*Tree) {\n-\tif _, present := treeSet[t.Name]; present {\n+\ttree := treeSet[t.Name]\n+\tif tree == nil || IsEmptyTree(tree.Root) {\n+\t\ttreeSet[t.Name] = t\n+\t\treturn\n+\t}\n+\tif !IsEmptyTree(t.Root) {\n \t\tt.errorf(\"template: multiple definition of template %q\", t.Name)\n \t}\n-\ttreeSet[t.Name] = t\n+}\n+\n+// IsEmptyTree reports whether this tree (node) is empty of everything but space.\n+func IsEmptyTree(n Node) bool {\n+\tswitch n := n.(type) {\n+\tcase *ActionNode:\n+\tcase *IfNode:\n+\tcase *ListNode:\n+\t\tfor _, node := range n.Nodes {\n+\t\t\tif !IsEmptyTree(node) {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t}\n+\t\treturn true\n+\tcase *RangeNode:\n+\tcase *TemplateNode:\n+\tcase *TextNode:\n+\t\treturn len(bytes.TrimSpace(n.Text)) == 0\n+\tcase *WithNode:\n+\tdefault:\n+\t\tpanic(\"unknown node: \" + n.String())\n+\t}\n+\treturn false\n }\n \n // parse is the top-level parser for a template, essentially the same"}, {"sha": "b70c2143d3de186bd900e8213fa49a864fa1327e", "filename": "libgo/go/text/template/parse/parse_test.go", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -257,3 +257,32 @@ func TestParse(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+type isEmptyTest struct {\n+\tname  string\n+\tinput string\n+\tempty bool\n+}\n+\n+var isEmptyTests = []isEmptyTest{\n+\t{\"empty\", ``, true},\n+\t{\"nonempty\", `hello`, false},\n+\t{\"spaces only\", \" \\t\\n \\t\\n\", true},\n+\t{\"definition\", `{{define \"x\"}}something{{end}}`, true},\n+\t{\"definitions and space\", \"{{define `x`}}something{{end}}\\n\\n{{define `y`}}something{{end}}\\n\\n\", true},\n+\t{\"definitions and text\", \"{{define `x`}}something{{end}}\\nx\\n{{define `y`}}something{{end}}\\ny\\n}}\", false},\n+\t{\"definition and action\", \"{{define `x`}}something{{end}}{{if 3}}foo{{end}}\", false},\n+}\n+\n+func TestIsEmpty(t *testing.T) {\n+\tfor _, test := range isEmptyTests {\n+\t\ttree, err := New(\"root\").Parse(test.input, \"\", \"\", make(map[string]*Tree), nil)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%q: unexpected error: %v\", test.name, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif empty := IsEmptyTree(tree.Root); empty != test.empty {\n+\t\t\tt.Errorf(\"%q: expected %t got %t\", test.name, test.empty, empty)\n+\t\t}\n+\t}\n+}"}, {"sha": "cbc68081748e46650ca5e3d8cad7ee0c41cc01d0", "filename": "libgo/go/text/template/template.go", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Ftext%2Ftemplate%2Ftemplate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Ftext%2Ftemplate%2Ftemplate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Ftemplate.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -5,7 +5,6 @@\n package template\n \n import (\n-\t\"bytes\"\n \t\"fmt\"\n \t\"reflect\"\n \t\"text/template/parse\"\n@@ -198,8 +197,8 @@ func (t *Template) associate(new *Template) error {\n \t}\n \tname := new.name\n \tif old := t.tmpl[name]; old != nil {\n-\t\toldIsEmpty := isEmpty(old.Root)\n-\t\tnewIsEmpty := isEmpty(new.Root)\n+\t\toldIsEmpty := parse.IsEmptyTree(old.Root)\n+\t\tnewIsEmpty := parse.IsEmptyTree(new.Root)\n \t\tif !oldIsEmpty && !newIsEmpty {\n \t\t\treturn fmt.Errorf(\"template: redefinition of template %q\", name)\n \t\t}\n@@ -211,26 +210,3 @@ func (t *Template) associate(new *Template) error {\n \tt.tmpl[name] = new\n \treturn nil\n }\n-\n-// isEmpty reports whether this tree (node) is empty of everything but space.\n-func isEmpty(n parse.Node) bool {\n-\tswitch n := n.(type) {\n-\tcase *parse.ActionNode:\n-\tcase *parse.IfNode:\n-\tcase *parse.ListNode:\n-\t\tfor _, node := range n.Nodes {\n-\t\t\tif !isEmpty(node) {\n-\t\t\t\treturn false\n-\t\t\t}\n-\t\t}\n-\t\treturn true\n-\tcase *parse.RangeNode:\n-\tcase *parse.TemplateNode:\n-\tcase *parse.TextNode:\n-\t\treturn len(bytes.TrimSpace(n.Text)) == 0\n-\tcase *parse.WithNode:\n-\tdefault:\n-\t\tpanic(\"unknown node: \" + n.String())\n-\t}\n-\treturn false\n-}"}, {"sha": "6d1e79b542bb28c770846f777dbee9402d54ae24", "filename": "libgo/go/time/time_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Ftime%2Ftime_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Ftime%2Ftime_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime_test.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -339,7 +339,7 @@ func checkTime(time Time, test *ParseTest, t *testing.T) {\n \t\tt.Errorf(\"%s: bad second: %d not %d\", test.name, time.Second(), 57)\n \t}\n \t// Nanoseconds must be checked against the precision of the input.\n-\tnanosec, err := strconv.Atoui(\"012345678\"[:test.fracDigits] + \"000000000\"[:9-test.fracDigits])\n+\tnanosec, err := strconv.ParseUint(\"012345678\"[:test.fracDigits]+\"000000000\"[:9-test.fracDigits], 10, 0)\n \tif err != nil {\n \t\tpanic(err)\n \t}"}, {"sha": "2904da6c6d96d7866a887ed2a4c0c74e5f05766e", "filename": "libgo/go/unicode/graphic.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Funicode%2Fgraphic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Funicode%2Fgraphic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Fgraphic.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -32,8 +32,8 @@ var PrintRanges = []*RangeTable{\n // Such characters include letters, marks, numbers, punctuation, symbols, and\n // spaces, from categories L, M, N, P, S, Zs.\n func IsGraphic(r rune) bool {\n-\t// We cast to uint32 to avoid the extra test for negative,\n-\t// and in the index we cast to uint8 to avoid the range check.\n+\t// We convert to uint32 to avoid the extra test for negative,\n+\t// and in the index we convert to uint8 to avoid the range check.\n \tif uint32(r) <= MaxLatin1 {\n \t\treturn properties[uint8(r)]&pg != 0\n \t}"}, {"sha": "d0ddbeeb484dc5d9ca425737b046b6b4db87bebc", "filename": "libgo/go/websocket/hixie.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fwebsocket%2Fhixie.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5363590597572228d4e0d0ae13f3469176ceb14/libgo%2Fgo%2Fwebsocket%2Fhixie.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fhixie.go?ref=d5363590597572228d4e0d0ae13f3469176ceb14", "patch": "@@ -365,13 +365,13 @@ func hixie76ClientHandshake(config *Config, br *bufio.Reader, bw *bufio.Writer)\n \tkey2, number2 := generateKeyNumber()\n \tif config.handshakeData != nil {\n \t\tkey1 = config.handshakeData[\"key1\"]\n-\t\tn, err := strconv.Atoui(config.handshakeData[\"number1\"])\n+\t\tn, err := strconv.ParseUint(config.handshakeData[\"number1\"], 10, 32)\n \t\tif err != nil {\n \t\t\tpanic(err)\n \t\t}\n \t\tnumber1 = uint32(n)\n \t\tkey2 = config.handshakeData[\"key2\"]\n-\t\tn, err = strconv.Atoui(config.handshakeData[\"number2\"])\n+\t\tn, err = strconv.ParseUint(config.handshakeData[\"number2\"], 10, 32)\n \t\tif err != nil {\n \t\t\tpanic(err)\n \t\t}"}]}