{"sha": "2aef4695708f807f44ff531f0c489907f92e05ad", "node_id": "C_kwDOANBUbNoAKDJhZWY0Njk1NzA4ZjgwN2Y0NGZmNTMxZjBjNDg5OTA3ZjkyZTA1YWQ", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2022-08-17T17:13:55Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-09-06T07:14:22Z"}, "message": "[Ada] Improve documentation of validation checking control switches\n\nCorrect incorrect text and clarify unclear text that has been identified\nin the \"Validity Checking\" section of the GNAT UG.\n\ngcc/ada/\n\n\t* doc/gnat_ugn/building_executable_programs_with_gnat.rst:\n\tImprove -gnatVa, -gnatVc, -gnatVd, -gnatVe, -gnatVf, -gnatVo,\n\t-gnatVp, -gnatVr, and -gnatVs switch descriptions.\n\t* gnat_ugn.texi: Regenerate.", "tree": {"sha": "6e3244e6afd3561abcd9505b29d424b9430cfd51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e3244e6afd3561abcd9505b29d424b9430cfd51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2aef4695708f807f44ff531f0c489907f92e05ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aef4695708f807f44ff531f0c489907f92e05ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2aef4695708f807f44ff531f0c489907f92e05ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aef4695708f807f44ff531f0c489907f92e05ad/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c66e69f33744e897c64a16e78ba893d1ea439139", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c66e69f33744e897c64a16e78ba893d1ea439139", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c66e69f33744e897c64a16e78ba893d1ea439139"}], "stats": {"total": 160, "additions": 88, "deletions": 72}, "files": [{"sha": "6a478095cfcb700821d635fb17a1abc9e1139315", "filename": "gcc/ada/doc/gnat_ugn/building_executable_programs_with_gnat.rst", "status": "modified", "additions": 44, "deletions": 37, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aef4695708f807f44ff531f0c489907f92e05ad/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aef4695708f807f44ff531f0c489907f92e05ad/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst?ref=2aef4695708f807f44ff531f0c489907f92e05ad", "patch": "@@ -4455,29 +4455,31 @@ to the default checks required by Ada as described above.\n \n   All validity checks are turned on.\n   That is, :switch:`-gnatVa` is\n-  equivalent to ``gnatVcdfimoprst``.\n+  equivalent to ``gnatVcdefimoprst``.\n \n \n .. index:: -gnatVc  (gcc)\n \n :switch:`-gnatVc`\n   *Validity checks for copies.*\n \n-  The right hand side of assignments, and the initializing values of\n-  object declarations are validity checked.\n+  The right-hand side of assignments, and the (explicit) initializing values\n+  of object declarations are validity checked.\n \n \n .. index:: -gnatVd  (gcc)\n \n :switch:`-gnatVd`\n   *Default (RM) validity checks.*\n \n-  Some validity checks are done by default following normal Ada semantics\n-  (RM 13.9.1 (9-11)).\n-  A check is done in case statements that the expression is within the range\n-  of the subtype. If it is not, Constraint_Error is raised.\n-  For assignments to array components, a check is done that the expression used\n-  as index is within the range. If it is not, Constraint_Error is raised.\n+  Some validity checks are required by Ada (see RM 13.9.1 (9-11)); these\n+  (and only these) validity checks are enabled by default.\n+  For case statements (and case expressions) that lack a \"when others =>\"\n+  choice, a check is made that the value of the selector expression\n+  belongs to its nominal subtype. If it does not, Constraint_Error is raised.\n+  For assignments to array components (and for indexed components in some\n+  other contexts), a check is made that each index expression belongs to the\n+  corresponding index subtype. If it does not, Constraint_Error is raised.\n   Both these validity checks may be turned off using switch :switch:`-gnatVD`.\n   They are turned on by default. If :switch:`-gnatVD` is specified, a subsequent\n   switch :switch:`-gnatVd` will leave the checks turned on.\n@@ -4490,28 +4492,31 @@ to the default checks required by Ada as described above.\n .. index:: -gnatVe  (gcc)\n \n :switch:`-gnatVe`\n-  *Validity checks for elementary components.*\n-\n-  In the absence of this switch, assignments to record or array components are\n-  not validity checked, even if validity checks for assignments generally\n-  (:switch:`-gnatVc`) are turned on. In Ada, assignment of composite values do not\n-  require valid data, but assignment of individual components does. So for\n-  example, there is a difference between copying the elements of an array with a\n-  slice assignment, compared to assigning element by element in a loop. This\n-  switch allows you to turn off validity checking for components, even when they\n-  are assigned component by component.\n+  *Validity checks for scalar components.*\n \n+  In the absence of this switch, assignments to scalar components of\n+  enclosing record or array objects are not validity checked, even if\n+  validity checks for assignments generally (:switch:`-gnatVc`) are turned on.\n+  Specifying this switch enables such checks.\n+  This switch has no effect if the :switch:`-gnatVc` switch is not specified.\n \n .. index:: -gnatVf  (gcc)\n \n :switch:`-gnatVf`\n   *Validity checks for floating-point values.*\n \n-  In the absence of this switch, validity checking occurs only for discrete\n-  values. If :switch:`-gnatVf` is specified, then validity checking also applies\n+  Specifying this switch enables validity checking for floating-point\n+  values in the same contexts where validity checking is enabled for\n+  other scalar values.\n+  In the absence of this switch, validity checking is not performed for\n+  floating-point values. This takes precedence over other statements about\n+  performing validity checking for scalar objects in various scenarios.\n+  One way to look at it is that if this switch is not set, then whenever\n+  any of the other rules in this section use the word \"scalar\" they\n+  really mean \"scalar and not floating-point\".\n+  If :switch:`-gnatVf` is specified, then validity checking also applies\n   for floating-point values, and NaNs and infinities are considered invalid,\n-  as well as out of range values for constrained types. Note that this means\n-  that standard IEEE infinity mode is not allowed. The exact contexts\n+  as well as out-of-range values for constrained types. The exact contexts\n   in which floating-point values are checked depends on the setting of other\n   options. For example, :switch:`-gnatVif` or :switch:`-gnatVfi`\n   (the order does not matter) specifies that floating-point parameters of mode\n@@ -4558,7 +4563,8 @@ to the default checks required by Ada as described above.\n :switch:`-gnatVo`\n   *Validity checks for operator and attribute operands.*\n \n-  Arguments for predefined operators and attributes are validity checked.\n+  Scalar arguments for predefined operators and for attributes are\n+  validity checked.\n   This includes all operators in package ``Standard``,\n   the shift operators defined as intrinsic in package ``Interfaces``\n   and operands for attributes such as ``Pos``. Checks are also made\n@@ -4572,22 +4578,22 @@ to the default checks required by Ada as described above.\n :switch:`-gnatVp`\n   *Validity checks for parameters.*\n \n-  This controls the treatment of parameters within a subprogram (as opposed\n-  to :switch:`-gnatVi` and :switch:`-gnatVm` which control validity testing\n-  of parameters on a call. If either of these call options is used, then\n-  normally an assumption is made within a subprogram that the input arguments\n-  have been validity checking at the point of call, and do not need checking\n-  again within a subprogram). If :switch:`-gnatVp` is set, then this assumption\n-  is not made, and parameters are not assumed to be valid, so their validity\n-  will be checked (or rechecked) within the subprogram.\n-\n+  This controls the treatment of formal parameters within a subprogram (as\n+  opposed to :switch:`-gnatVi` and :switch:`-gnatVm`, which control validity\n+  testing of actual parameters of a call). If either of these call options is\n+  specified, then normally an assumption is made within a subprogram that\n+  the validity of any incoming formal parameters of the corresponding mode(s)\n+  has already been checked at the point of call and does not need rechecking.\n+  If :switch:`-gnatVp` is set, then this assumption is not made and so their\n+  validity may be checked (or rechecked) within the subprogram. If neither of\n+  the two call-related options is specified, then this switch has no effect.\n \n .. index:: -gnatVr  (gcc)\n \n :switch:`-gnatVr`\n   *Validity checks for function returns.*\n \n-  The expression in ``return`` statements in functions is validity\n+  The expression in simple ``return`` statements in functions is validity\n   checked.\n \n \n@@ -4596,9 +4602,10 @@ to the default checks required by Ada as described above.\n :switch:`-gnatVs`\n   *Validity checks for subscripts.*\n \n-  All subscripts expressions are checked for validity, whether they appear\n-  on the right side or left side (in default mode only left side subscripts\n-  are validity checked).\n+  All subscript expressions are checked for validity, whatever context\n+  they occur in (in default mode some subscripts are not validity checked;\n+  for example, validity checking may be omitted in some cases involving\n+  a read of a component of an array).\n \n \n .. index:: -gnatVt  (gcc)"}, {"sha": "7f3d312c9a4c3718d9ebcf2d47b1fe7fe54d67e3", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 44, "deletions": 35, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aef4695708f807f44ff531f0c489907f92e05ad/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aef4695708f807f44ff531f0c489907f92e05ad/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=2aef4695708f807f44ff531f0c489907f92e05ad", "patch": "@@ -12984,7 +12984,7 @@ to the default checks required by Ada as described above.\n \n All validity checks are turned on.\n That is, @code{-gnatVa} is\n-equivalent to @code{gnatVcdfimoprst}.\n+equivalent to @code{gnatVcdefimoprst}.\n @end table\n \n @geindex -gnatVc (gcc)\n@@ -12996,8 +12996,8 @@ equivalent to @code{gnatVcdfimoprst}.\n \n `Validity checks for copies.'\n \n-The right hand side of assignments, and the initializing values of\n-object declarations are validity checked.\n+The right-hand side of assignments, and the (explicit) initializing values\n+of object declarations are validity checked.\n @end table\n \n @geindex -gnatVd (gcc)\n@@ -13009,12 +13009,14 @@ object declarations are validity checked.\n \n `Default (RM) validity checks.'\n \n-Some validity checks are done by default following normal Ada semantics\n-(RM 13.9.1 (9-11)).\n-A check is done in case statements that the expression is within the range\n-of the subtype. If it is not, Constraint_Error is raised.\n-For assignments to array components, a check is done that the expression used\n-as index is within the range. If it is not, Constraint_Error is raised.\n+Some validity checks are required by Ada (see RM 13.9.1 (9-11)); these\n+(and only these) validity checks are enabled by default.\n+For case statements (and case expressions) that lack a \u201cwhen others =>\u201d\n+choice, a check is made that the value of the selector expression\n+belongs to its nominal subtype. If it does not, Constraint_Error is raised.\n+For assignments to array components (and for indexed components in some\n+other contexts), a check is made that each index expression belongs to the\n+corresponding index subtype. If it does not, Constraint_Error is raised.\n Both these validity checks may be turned off using switch @code{-gnatVD}.\n They are turned on by default. If @code{-gnatVD} is specified, a subsequent\n switch @code{-gnatVd} will leave the checks turned on.\n@@ -13031,16 +13033,13 @@ overwriting may occur.\n \n @item @code{-gnatVe}\n \n-`Validity checks for elementary components.'\n+`Validity checks for scalar components.'\n \n-In the absence of this switch, assignments to record or array components are\n-not validity checked, even if validity checks for assignments generally\n-(@code{-gnatVc}) are turned on. In Ada, assignment of composite values do not\n-require valid data, but assignment of individual components does. So for\n-example, there is a difference between copying the elements of an array with a\n-slice assignment, compared to assigning element by element in a loop. This\n-switch allows you to turn off validity checking for components, even when they\n-are assigned component by component.\n+In the absence of this switch, assignments to scalar components of\n+enclosing record or array objects are not validity checked, even if\n+validity checks for assignments generally (@code{-gnatVc}) are turned on.\n+Specifying this switch enables such checks.\n+This switch has no effect if the @code{-gnatVc} switch is not specified.\n @end table\n \n @geindex -gnatVf (gcc)\n@@ -13052,11 +13051,18 @@ are assigned component by component.\n \n `Validity checks for floating-point values.'\n \n-In the absence of this switch, validity checking occurs only for discrete\n-values. If @code{-gnatVf} is specified, then validity checking also applies\n+Specifying this switch enables validity checking for floating-point\n+values in the same contexts where validity checking is enabled for\n+other scalar values.\n+In the absence of this switch, validity checking is not performed for\n+floating-point values. This takes precedence over other statements about\n+performing validity checking for scalar objects in various scenarios.\n+One way to look at it is that if this switch is not set, then whenever\n+any of the other rules in this section use the word \u201cscalar\u201d they\n+really mean \u201cscalar and not floating-point\u201d.\n+If @code{-gnatVf} is specified, then validity checking also applies\n for floating-point values, and NaNs and infinities are considered invalid,\n-as well as out of range values for constrained types. Note that this means\n-that standard IEEE infinity mode is not allowed. The exact contexts\n+as well as out-of-range values for constrained types. The exact contexts\n in which floating-point values are checked depends on the setting of other\n options. For example, @code{-gnatVif} or @code{-gnatVfi}\n (the order does not matter) specifies that floating-point parameters of mode\n@@ -13119,7 +13125,8 @@ is used, it cancels any other @code{-gnatV} previously issued.\n \n `Validity checks for operator and attribute operands.'\n \n-Arguments for predefined operators and attributes are validity checked.\n+Scalar arguments for predefined operators and for attributes are\n+validity checked.\n This includes all operators in package @code{Standard},\n the shift operators defined as intrinsic in package @code{Interfaces}\n and operands for attributes such as @code{Pos}. Checks are also made\n@@ -13137,14 +13144,15 @@ also made on explicit ranges using @code{..} (e.g., slices, loops etc).\n \n `Validity checks for parameters.'\n \n-This controls the treatment of parameters within a subprogram (as opposed\n-to @code{-gnatVi} and @code{-gnatVm} which control validity testing\n-of parameters on a call. If either of these call options is used, then\n-normally an assumption is made within a subprogram that the input arguments\n-have been validity checking at the point of call, and do not need checking\n-again within a subprogram). If @code{-gnatVp} is set, then this assumption\n-is not made, and parameters are not assumed to be valid, so their validity\n-will be checked (or rechecked) within the subprogram.\n+This controls the treatment of formal parameters within a subprogram (as\n+opposed to @code{-gnatVi} and @code{-gnatVm}, which control validity\n+testing of actual parameters of a call). If either of these call options is\n+specified, then normally an assumption is made within a subprogram that\n+the validity of any incoming formal parameters of the corresponding mode(s)\n+has already been checked at the point of call and does not need rechecking.\n+If @code{-gnatVp} is set, then this assumption is not made and so their\n+validity may be checked (or rechecked) within the subprogram. If neither of\n+the two call-related options is specified, then this switch has no effect.\n @end table\n \n @geindex -gnatVr (gcc)\n@@ -13156,7 +13164,7 @@ will be checked (or rechecked) within the subprogram.\n \n `Validity checks for function returns.'\n \n-The expression in @code{return} statements in functions is validity\n+The expression in simple @code{return} statements in functions is validity\n checked.\n @end table\n \n@@ -13169,9 +13177,10 @@ checked.\n \n `Validity checks for subscripts.'\n \n-All subscripts expressions are checked for validity, whether they appear\n-on the right side or left side (in default mode only left side subscripts\n-are validity checked).\n+All subscript expressions are checked for validity, whatever context\n+they occur in (in default mode some subscripts are not validity checked;\n+for example, validity checking may be omitted in some cases involving\n+a read of a component of an array).\n @end table\n \n @geindex -gnatVt (gcc)"}]}