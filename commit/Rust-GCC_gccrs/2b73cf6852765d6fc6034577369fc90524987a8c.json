{"sha": "2b73cf6852765d6fc6034577369fc90524987a8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI3M2NmNjg1Mjc2NWQ2ZmM2MDM0NTc3MzY5ZmM5MDUyNDk4N2E4Yw==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2007-06-06T10:39:14Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:39:14Z"}, "message": "sem_ch3.adb (Process_Full_View): Propagate the CPP_Class attribute to the full type declaration.\n\n2007-04-20  Javier Miranda  <miranda@adacore.com>\n\t    Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Process_Full_View): Propagate the CPP_Class attribute to\n\tthe full type declaration.\n\t(Analyze_Component_Declaration): Add local variable E to capture the\n\tinitialization expression of the declaration. Replace the occurences of\n\tExpression (N) with E.\n\t(OK_For_Limited_Init_In_05): Allow initialization of class-wide\n\tlimited interface object with a function call.\n\t(Array_Type_Declaration): If the declaration lacks subtype marks for\n\tindices, create a simple index list to prevent cascaded errors.\n\t(Is_Null_Extension): Ignore internal components created for secondary\n\ttags when checking whether a record extension is a null extension.\n\t(Check_Abstract_Interfaces): Add missing support for interface subtypes\n\tand generic formals.\n\t(Derived_Type_Declaration): Add missing support for interface subtypes\n\tand generic formals.\n\t(Analyze_Object_Declaration): If an initialization expression is\n\tpresent, traverse its subtree and mark all allocators as static\n\tcoextensions.\n\t(Add_Interface_Tag_Component): When looking for components that may be\n\tsecondary tags, ignore pragmas that can appear within a record\n\tdeclaration.\n\t(Check_Abstract_Overriding): an inherited function that dispatches on\n\tresult does not need to be overriden if the controlling type is a null\n\textension.\n\t(Mentions_T): Handle properly a 'class attribute in an anonymous access\n\tcomponent declaration, when the prefix is an expanded name.\n\t(Inherit_Component): If the derivation is for a private extension,\n\tinherited components remain visible and their ekind should not be set\n\tto Void.\n\t(Find_Type_Of_Object): In the case of an access definition, always set\n\tIs_Local_Anonymous_Access. We were previously not marking the anonymous\n\taccess type of a return object as a local anonymous type.\n\t(Make_Index): Use Ambiguous_Character to report ambiguity on a discrete\n\trange with character literal bounds.\n\t(Constrain_Array): Initialize the Packed_Array_Type field to Empty.\n\t(Access_Subprogram_Declaration): Indicate that the type declaration\n\tdepends on an incomplete type only if the incomplete type is declared\n\tin an open scope.\n\t(Analyze_Subtype_Declaration): Handle properly subtypes of\n\tsynchronized types that are tagged, and that may appear as generic\n\tactuals.\n\t(Access_Subprogram_Declaration): An anonymous access to subprogram can\n\tappear as an access discriminant in a private type declaration.\n\t(Add_Interface_Tag_Components): Complete decoration of the component\n\tcontaining the tag of a secondary dispatch table and the component\n\tcontaining the offset to the base of the object (this latter component\n\tis only generated when the parent type has discriminants --as documented\n\tin this routine).\n\t(Inherit_Components): Use the new decoration of the tag components to\n\timprove the condition that avoids inheriting the components associated\n\twith secondary tags of the parent.\n\t(Build_Discriminanted_Subtype): Indicate to the backend that the\n\tsize of record types associated with dispatch tables is known at\n\tcompile time.\n\t(Analyze_Subtype_Declaration): Propagate Is_Interface flag when needed.\n\t(Analyze_Interface_Declaration): Change setting of Is_Limited_Interface\n\tto include task, protected, and synchronized interfaces as limited\n\tinterfaces.\n\t(Process_Discriminants): Remove the setting of\n\tIs_Local_Anonymous_Access on the type of (anonymous) access\n\tdiscriminants of nonlimited types.\n\t(Analyze_Interface_Type_Declaration): Complete the decoration of the\n\tclass-wide entity it is is already present. This situation occurs if\n\tthe limited-view has been previously built.\n\t(Enumeration_Type_Declaration): Initialize properly the Enum_Pos_To_Rep\n\tfield.\n\t(Add_Interface_Tag_Components.Add_Tag): Set the value of the attribute\n\tRelated_Interface.\n\nFrom-SVN: r125437", "tree": {"sha": "219db3bd26b4540d437293eb6c5ada7e7f7e5ff2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/219db3bd26b4540d437293eb6c5ada7e7f7e5ff2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b73cf6852765d6fc6034577369fc90524987a8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b73cf6852765d6fc6034577369fc90524987a8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b73cf6852765d6fc6034577369fc90524987a8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b73cf6852765d6fc6034577369fc90524987a8c/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "717809895b889a8fb39866d5ace71544b5d65945", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/717809895b889a8fb39866d5ace71544b5d65945", "html_url": "https://github.com/Rust-GCC/gccrs/commit/717809895b889a8fb39866d5ace71544b5d65945"}], "stats": {"total": 738, "additions": 511, "deletions": 227}, "files": [{"sha": "f72104c5e4626b6573c6473424278a18a5ace8a7", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 511, "deletions": 227, "changes": 738, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b73cf6852765d6fc6034577369fc90524987a8c/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b73cf6852765d6fc6034577369fc90524987a8c/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=2b73cf6852765d6fc6034577369fc90524987a8c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -184,16 +184,15 @@ package body Sem_Ch3 is\n      (T           : Entity_Id;\n       Def         : Node_Id;\n       Derived_Def : Boolean := False) return Elist_Id;\n-   --  Validate discriminant constraints, and return the list of the\n-   --  constraints in order of discriminant declarations. T is the\n-   --  discriminated unconstrained type. Def is the N_Subtype_Indication node\n-   --  where the discriminants constraints for T are specified. Derived_Def is\n-   --  True if we are building the discriminant constraints in a derived type\n-   --  definition of the form \"type D (...) is new T (xxx)\". In this case T is\n-   --  the parent type and Def is the constraint \"(xxx)\" on T and this routine\n-   --  sets the Corresponding_Discriminant field of the discriminants in the\n-   --  derived type D to point to the corresponding discriminants in the parent\n-   --  type T.\n+   --  Validate discriminant constraints and return the list of the constraints\n+   --  in order of discriminant declarations, where T is the discriminated\n+   --  unconstrained type. Def is the N_Subtype_Indication node where the\n+   --  discriminants constraints for T are specified. Derived_Def is True\n+   --  when building the discriminant constraints in a derived type definition\n+   --  of the form \"type D (...) is new T (xxx)\". In this case T is the parent\n+   --  type and Def is the constraint \"(xxx)\" on T and this routine sets the\n+   --  Corresponding_Discriminant field of the discriminants in the derived\n+   --  type D to point to the corresponding discriminants in the parent type T.\n \n    procedure Build_Discriminated_Subtype\n      (T           : Entity_Id;\n@@ -706,6 +705,7 @@ package body Sem_Ch3 is\n    is\n       Loc        : constant Source_Ptr := Sloc (Related_Nod);\n       Anon_Type  : Entity_Id;\n+      Anon_Scope : Entity_Id;\n       Desig_Type : Entity_Id;\n       Decl       : Entity_Id;\n \n@@ -727,10 +727,7 @@ package body Sem_Ch3 is\n       if Nkind (Related_Nod) = N_Object_Declaration\n         or else Nkind (Related_Nod) = N_Access_Function_Definition\n       then\n-         Anon_Type :=\n-           Create_Itype\n-            (E_Anonymous_Access_Type, Related_Nod,\n-               Scope_Id => Current_Scope);\n+         Anon_Scope := Current_Scope;\n \n       --  For the anonymous function result case, retrieve the scope of the\n       --  function specification's associated entity rather than using the\n@@ -743,22 +740,28 @@ package body Sem_Ch3 is\n       elsif Nkind (Related_Nod) = N_Function_Specification\n          and then Nkind (Parent (N)) /= N_Parameter_Specification\n       then\n-         Anon_Type :=\n-           Create_Itype\n-             (E_Anonymous_Access_Type,\n-              Related_Nod,\n-              Scope_Id => Scope (Defining_Entity (Related_Nod)));\n+         --  If the current scope is a protected type, the anonymous access\n+         --  is associated with one of the protected operations, and must\n+         --  be available in the scope that encloses the protected declaration.\n+         --  Otherwise the type is is in the scope enclosing the subprogram.\n+\n+         if Ekind (Current_Scope) = E_Protected_Type then\n+            Anon_Scope := Scope (Scope (Defining_Entity (Related_Nod)));\n+         else\n+            Anon_Scope := Scope (Defining_Entity (Related_Nod));\n+         end if;\n \n       else\n          --  For access formals, access components, and access discriminants,\n          --  the scope is that of the enclosing declaration,\n \n-         Anon_Type :=\n-           Create_Itype\n-            (E_Anonymous_Access_Type, Related_Nod,\n-               Scope_Id => Scope (Current_Scope));\n+         Anon_Scope := Scope (Current_Scope);\n       end if;\n \n+      Anon_Type :=\n+        Create_Itype\n+         (E_Anonymous_Access_Type, Related_Nod, Scope_Id =>  Anon_Scope);\n+\n       if All_Present (N)\n         and then Ada_Version >= Ada_05\n       then\n@@ -781,6 +784,14 @@ package body Sem_Ch3 is\n               (Anon_Type, E_Anonymous_Access_Subprogram_Type);\n          end if;\n \n+         --  If the anonymous access is associated with a protected operation\n+         --  create a reference to it after the enclosing protected definition\n+         --  because the itype will be used in the subsequent bodies.\n+\n+         if Ekind (Current_Scope) = E_Protected_Type then\n+            Build_Itype_Reference (Anon_Type, Parent (Current_Scope));\n+         end if;\n+\n          return Anon_Type;\n       end if;\n \n@@ -810,7 +821,7 @@ package body Sem_Ch3 is\n       Set_Is_Public (Anon_Type, Is_Public (Scope (Anon_Type)));\n \n       --  Ada 2005 (AI-50217): Propagate the attribute that indicates that the\n-      --  designated type comes from the limited view (for back-end purposes).\n+      --  designated type comes from the limited view.\n \n       Set_From_With_Type (Anon_Type, From_With_Type (Desig_Type));\n \n@@ -917,6 +928,8 @@ package body Sem_Ch3 is\n \n       D_Ityp := Associated_Node_For_Itype (Desig_Type);\n       while Nkind (D_Ityp) /= N_Full_Type_Declaration\n+         and then Nkind (D_Ityp) /= N_Private_Type_Declaration\n+         and then Nkind (D_Ityp) /= N_Private_Extension_Declaration\n          and then Nkind (D_Ityp) /= N_Procedure_Specification\n          and then Nkind (D_Ityp) /= N_Function_Specification\n          and then Nkind (D_Ityp) /= N_Object_Declaration\n@@ -944,9 +957,27 @@ package body Sem_Ch3 is\n \n       if Nkind (T_Def) = N_Access_Function_Definition then\n          if Nkind (Result_Definition (T_Def)) = N_Access_Definition then\n-            Set_Etype\n-              (Desig_Type,\n-               Access_Definition (T_Def, Result_Definition (T_Def)));\n+\n+            declare\n+               Acc : constant Node_Id := Result_Definition (T_Def);\n+\n+            begin\n+               if Present (Access_To_Subprogram_Definition (Acc))\n+                 and then\n+                   Protected_Present (Access_To_Subprogram_Definition (Acc))\n+               then\n+                  Set_Etype\n+                    (Desig_Type,\n+                       Replace_Anonymous_Access_To_Protected_Subprogram\n+                         (T_Def));\n+\n+               else\n+                  Set_Etype\n+                    (Desig_Type,\n+                       Access_Definition (T_Def, Result_Definition (T_Def)));\n+               end if;\n+            end;\n+\n          else\n             Analyze (Result_Definition (T_Def));\n             Set_Etype (Desig_Type, Entity (Result_Definition (T_Def)));\n@@ -963,7 +994,7 @@ package body Sem_Ch3 is\n       end if;\n \n       if Present (Formals) then\n-         New_Scope (Desig_Type);\n+         Push_Scope (Desig_Type);\n          Process_Formals (Formals, Parent (T_Def));\n \n          --  A bit of a kludge here, End_Scope requires that the parent\n@@ -979,7 +1010,9 @@ package body Sem_Ch3 is\n \n       --  The return type and/or any parameter type may be incomplete. Mark\n       --  the subprogram_type as depending on the incomplete type, so that\n-      --  it can be updated when the full type declaration is seen.\n+      --  it can be updated when the full type declaration is seen. This\n+      --  only applies to incomplete types declared in some enclosing scope,\n+      --  not to limited views from other packages.\n \n       if Present (Formals) then\n          Formal := First_Formal (Desig_Type);\n@@ -990,7 +1023,9 @@ package body Sem_Ch3 is\n                Error_Msg_N (\"functions can only have IN parameters\", Formal);\n             end if;\n \n-            if Ekind (Etype (Formal)) = E_Incomplete_Type then\n+            if Ekind (Etype (Formal)) = E_Incomplete_Type\n+              and then In_Open_Scopes (Scope (Etype (Formal)))\n+            then\n                Append_Elmt (Desig_Type, Private_Dependents (Etype (Formal)));\n                Set_Has_Delayed_Freeze (Desig_Type);\n             end if;\n@@ -1088,8 +1123,6 @@ package body Sem_Ch3 is\n          Init_Size_Align (T);\n       end if;\n \n-      Set_Is_Access_Constant (T, Constant_Present (Def));\n-\n       Desig := Designated_Type (T);\n \n       --  If designated type is an imported tagged type, indicate that the\n@@ -1100,30 +1133,11 @@ package body Sem_Ch3 is\n       --  is available, use it as the designated type of the access type, so\n       --  that the back-end gets a usable entity.\n \n-      declare\n-         N_Desig : Entity_Id;\n-\n-      begin\n-         if From_With_Type (Desig)\n-           and then Ekind (Desig) /= E_Access_Type\n-         then\n-            Set_From_With_Type (T);\n-\n-            if Is_Incomplete_Type (Desig) then\n-               N_Desig := Non_Limited_View (Desig);\n-\n-            else pragma Assert (Ekind (Desig) = E_Class_Wide_Type);\n-               if From_With_Type (Etype (Desig)) then\n-                  N_Desig := Non_Limited_View (Etype (Desig));\n-               else\n-                  N_Desig := Etype (Desig);\n-               end if;\n-            end if;\n-\n-            pragma Assert (Present (N_Desig));\n-            Set_Directly_Designated_Type (T, N_Desig);\n-         end if;\n-      end;\n+      if From_With_Type (Desig)\n+        and then Ekind (Desig) /= E_Access_Type\n+      then\n+         Set_From_With_Type (T);\n+      end if;\n \n       --  Note that Has_Task is always false, since the access type itself\n       --  is not a task type. See Einfo for more description on this point.\n@@ -1206,8 +1220,9 @@ package body Sem_Ch3 is\n \n          Set_Analyzed (Decl);\n          Set_Ekind               (Tag, E_Component);\n-         Set_Is_Limited_Record   (Tag);\n          Set_Is_Tag              (Tag);\n+         Set_Is_Aliased          (Tag);\n+         Set_Related_Interface   (Tag, Iface);\n          Init_Component_Location (Tag);\n \n          pragma Assert (Is_Frozen (Iface));\n@@ -1248,6 +1263,8 @@ package body Sem_Ch3 is\n \n             Set_Analyzed (Decl);\n             Set_Ekind               (Offset, E_Component);\n+            Set_Is_Aliased          (Offset);\n+            Set_Related_Interface   (Offset, Iface);\n             Init_Component_Location (Offset);\n             Insert_After (Last_Tag, Decl);\n             Last_Tag := Decl;\n@@ -1261,8 +1278,14 @@ package body Sem_Ch3 is\n    --  Start of processing for Add_Interface_Tag_Components\n \n    begin\n+      if not RTE_Available (RE_Interface_Tag) then\n+         Error_Msg\n+           (\"(Ada 2005) interface types not supported by this run-time!\",\n+            Sloc (N));\n+         return;\n+      end if;\n+\n       if Ekind (Typ) /= E_Record_Type\n-        or else not RTE_Available (RE_Interface_Tag)\n         or else (Is_Concurrent_Record_Type (Typ)\n                   and then Is_Empty_List (Abstract_Interface_List (Typ)))\n         or else (not Is_Concurrent_Record_Type (Typ)\n@@ -1306,7 +1329,9 @@ package body Sem_Ch3 is\n \n          Comp := First (L);\n          while Present (Comp) loop\n-            if Is_Tag (Defining_Identifier (Comp)) then\n+            if Nkind (Comp) = N_Component_Declaration\n+              and then Is_Tag (Defining_Identifier (Comp))\n+            then\n                Last_Tag := Comp;\n             end if;\n \n@@ -1342,6 +1367,7 @@ package body Sem_Ch3 is\n \n    procedure Analyze_Component_Declaration (N : Node_Id) is\n       Id : constant Entity_Id := Defining_Identifier (N);\n+      E  : constant Node_Id   := Expression (N);\n       T  : Entity_Id;\n       P  : Entity_Id;\n \n@@ -1360,11 +1386,17 @@ package body Sem_Ch3 is\n \n       function Contains_POC (Constr : Node_Id) return Boolean is\n       begin\n+         --  Prevent cascaded errors.\n+\n+         if Error_Posted (Constr) then\n+            return False;\n+         end if;\n+\n          case Nkind (Constr) is\n             when N_Attribute_Reference =>\n-               return Attribute_Name (Constr) = Name_Access\n-                        and\n-                      Prefix (Constr) = Scope (Entity (Prefix (Constr)));\n+               return\n+                 Attribute_Name (Constr) = Name_Access\n+                   and then Prefix (Constr) = Scope (Entity (Prefix (Constr)));\n \n             when N_Discriminant_Association =>\n                return Denotes_Discriminant (Expression (Constr));\n@@ -1500,12 +1532,11 @@ package body Sem_Ch3 is\n       --  \"Handling of Default and Per-Object Expressions\" in the spec of\n       --  package Sem).\n \n-      if Present (Expression (N)) then\n-         Analyze_Per_Use_Expression (Expression (N), T);\n-         Check_Initialization (T, Expression (N));\n+      if Present (E) then\n+         Analyze_Per_Use_Expression (E, T);\n+         Check_Initialization (T, E);\n \n          if Ada_Version >= Ada_05\n-           and then Is_Access_Type (T)\n            and then Ekind (T) = E_Anonymous_Access_Type\n          then\n             --  Check RM 3.9.2(9): \"if the expected type for an expression is\n@@ -1518,25 +1549,35 @@ package body Sem_Ch3 is\n               and then\n                 Ekind (Directly_Designated_Type (T)) /= E_Class_Wide_Type\n               and then\n-                Ekind (Directly_Designated_Type (Etype (Expression (N)))) =\n-                                                        E_Class_Wide_Type\n+                Ekind (Directly_Designated_Type (Etype (E))) =\n+                  E_Class_Wide_Type\n             then\n                Error_Msg_N\n                  (\"access to specific tagged type required ('R'M 3.9.2(9))\",\n-                  Expression (N));\n+                  E);\n             end if;\n \n             --  (Ada 2005: AI-230): Accessibility check for anonymous\n             --  components\n \n-            --  Missing barrier Ada_Version >= Ada_05???\n+            if Type_Access_Level (Etype (E)) > Type_Access_Level (T) then\n+               Error_Msg_N\n+                 (\"expression has deeper access level than component \" &\n+                  \"('R'M 3.10.2 (12.2))\", E);\n+            end if;\n+\n+            --  The initialization expression is a reference to an access\n+            --  discriminant. The type of the discriminant is always deeper\n+            --  than any access type.\n \n-            if Type_Access_Level (Etype (Expression (N))) >\n-               Type_Access_Level (T)\n+            if Ekind (Etype (E)) = E_Anonymous_Access_Type\n+              and then Is_Entity_Name (E)\n+              and then Ekind (Entity (E)) = E_In_Parameter\n+              and then Present (Discriminal_Link (Entity (E)))\n             then\n                Error_Msg_N\n-                 (\"expression has deeper access level than component \" &\n-                  \"('R'M 3.10.2 (12.2))\", Expression (N));\n+                 (\"discriminant has deeper accessibility level than target\",\n+                  E);\n             end if;\n          end if;\n       end if;\n@@ -1813,7 +1854,7 @@ package body Sem_Ch3 is\n          Set_Primitive_Operations (T, New_Elmt_List);\n       end if;\n \n-      New_Scope (T);\n+      Push_Scope (T);\n \n       Set_Stored_Constraint (T, No_Elist);\n \n@@ -1836,6 +1877,8 @@ package body Sem_Ch3 is\n    -----------------------------------\n \n    procedure Analyze_Interface_Declaration (T : Entity_Id; Def : Node_Id) is\n+      CW : constant Entity_Id := Class_Wide_Type (T);\n+\n    begin\n       Set_Is_Tagged_Type      (T);\n \n@@ -1844,18 +1887,45 @@ package body Sem_Ch3 is\n                                    or else Protected_Present (Def)\n                                    or else Synchronized_Present (Def));\n \n-      --  Type is abstract if full declaration carries keyword, or if\n-      --  previous partial view did.\n+      --  Type is abstract if full declaration carries keyword, or if previous\n+      --  partial view did.\n \n       Set_Is_Abstract_Type (T);\n       Set_Is_Interface     (T);\n \n-      Set_Is_Limited_Interface      (T, Limited_Present (Def));\n+      --  Type is a limited interface if it includes the keyword limited, task,\n+      --  protected, or synchronized.\n+\n+      Set_Is_Limited_Interface\n+        (T, Limited_Present (Def)\n+              or else Protected_Present (Def)\n+              or else Synchronized_Present (Def)\n+              or else Task_Present (Def));\n+\n       Set_Is_Protected_Interface    (T, Protected_Present (Def));\n-      Set_Is_Synchronized_Interface (T, Synchronized_Present (Def));\n       Set_Is_Task_Interface         (T, Task_Present (Def));\n+\n+      --  Type is a synchronized interface if it includes the keyword task,\n+      --  protected, or synchronized.\n+\n+      Set_Is_Synchronized_Interface\n+        (T, Synchronized_Present (Def)\n+              or else Protected_Present (Def)\n+              or else Task_Present (Def));\n+\n       Set_Abstract_Interfaces       (T, New_Elmt_List);\n       Set_Primitive_Operations      (T, New_Elmt_List);\n+\n+      --  Complete the decoration of the class-wide entity if it was already\n+      --  built (ie. during the creation of the limited view)\n+\n+      if Present (CW) then\n+         Set_Is_Interface (CW);\n+         Set_Is_Limited_Interface      (CW, Is_Limited_Interface (T));\n+         Set_Is_Protected_Interface    (CW, Is_Protected_Interface (T));\n+         Set_Is_Synchronized_Interface (CW, Is_Synchronized_Interface (T));\n+         Set_Is_Task_Interface         (CW, Is_Task_Interface (T));\n+      end if;\n    end Analyze_Interface_Declaration;\n \n    -----------------------------\n@@ -2260,6 +2330,7 @@ package body Sem_Ch3 is\n       --  Process initialization expression if present and not in error\n \n       if Present (E) and then E /= Error then\n+         Mark_Static_Coextensions (E);\n          Analyze (E);\n \n          --  In case of errors detected in the analysis of the expression,\n@@ -2288,6 +2359,7 @@ package body Sem_Ch3 is\n          if not Assignment_OK (N) then\n             Check_Initialization (T, E);\n          end if;\n+\n          Check_Unset_Reference (E);\n \n          --  If this is a variable, then set current value\n@@ -3130,6 +3202,11 @@ package body Sem_Ch3 is\n                   Set_Primitive_Operations\n                                         (Id, Primitive_Operations (T));\n                   Set_Class_Wide_Type   (Id, Class_Wide_Type (T));\n+\n+                  if Is_Interface (T) then\n+                     Set_Is_Interface (Id);\n+                     Set_Is_Limited_Interface (Id, Is_Limited_Interface (T));\n+                  end if;\n                end if;\n \n             when Private_Kind =>\n@@ -3205,6 +3282,7 @@ package body Sem_Ch3 is\n                Set_First_Private_Entity (Id, First_Private_Entity  (T));\n                Set_Has_Discriminants    (Id, Has_Discriminants     (T));\n                Set_Is_Constrained       (Id, Is_Constrained        (T));\n+               Set_Is_Tagged_Type       (Id, Is_Tagged_Type        (T));\n                Set_Last_Entity          (Id, Last_Entity           (T));\n \n                if Has_Discriminants (T) then\n@@ -3261,6 +3339,10 @@ package body Sem_Ch3 is\n       Set_Is_Immediately_Visible (Id, True);\n       Set_Depends_On_Private     (Id, Has_Private_Component (T));\n \n+      if Is_Interface (T) then\n+         Set_Is_Interface (Id);\n+      end if;\n+\n       if Present (Generic_Parent_Type (N))\n         and then\n           (Nkind\n@@ -3270,7 +3352,14 @@ package body Sem_Ch3 is\n                 /=  N_Formal_Private_Type_Definition)\n       then\n          if Is_Tagged_Type (Id) then\n-            if Is_Class_Wide_Type (Id) then\n+\n+            --  If this is a generic actual subtype for a synchronized type,\n+            --  the primitive operations are those of the corresponding record\n+            --  for which there is a separate subtype declaration.\n+\n+            if Is_Concurrent_Type (Id) then\n+               null;\n+            elsif Is_Class_Wide_Type (Id) then\n                Derive_Subprograms (Generic_Parent_Type (N), Id, Etype (T));\n             else\n                Derive_Subprograms (Generic_Parent_Type (N), Id, T);\n@@ -3718,7 +3807,13 @@ package body Sem_Ch3 is\n       Discr_Name := Name (N);\n       Analyze (Discr_Name);\n \n-      if Ekind (Entity (Discr_Name)) /= E_Discriminant then\n+      if Etype (Discr_Name) = Any_Type then\n+\n+         --  Prevent cascaded errors\n+\n+         return;\n+\n+      elsif Ekind (Entity (Discr_Name)) /= E_Discriminant then\n          Error_Msg_N (\"invalid discriminant name in variant part\", Discr_Name);\n       end if;\n \n@@ -3964,7 +4059,7 @@ package body Sem_Ch3 is\n            and then not Is_Itype (Element_Type)\n          then\n             Error_Msg_N\n-              (\"null-exclusion cannot be applied to a null excluding type\",\n+              (\"`NOT NULL` not allowed (null already excluded)\",\n                Subtype_Indication (Component_Definition (Def)));\n          end if;\n       end if;\n@@ -3993,6 +4088,23 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n+      --  A syntax error in the declaration itself may lead to an empty\n+      --  index list, in which case do a minimal patch.\n+\n+      if No (First_Index (T)) then\n+         Error_Msg_N (\"missing index definition in array type declaration\", T);\n+\n+         declare\n+            Indices : constant List_Id :=\n+              New_List (New_Occurrence_Of (Any_Id, Sloc (T)));\n+\n+         begin\n+            Set_Discrete_Subtype_Definitions (Def, Indices);\n+            Set_First_Index (T, First (Indices));\n+            return;\n+         end;\n+      end if;\n+\n       --  Create a concatenation operator for the new type. Internal\n       --  array types created for packed entities do not need such, they\n       --  are compatible with the user-defined type.\n@@ -4059,6 +4171,10 @@ package body Sem_Ch3 is\n             Comp := Parameter_Type (N);\n             Acc  := Comp;\n \n+         when N_Access_Function_Definition  =>\n+            Comp := Result_Definition (N);\n+            Acc  := Comp;\n+\n          when N_Object_Declaration  =>\n             Comp := Object_Definition (N);\n             Acc  := Comp;\n@@ -4104,6 +4220,9 @@ package body Sem_Ch3 is\n          Rewrite (Comp, New_Occurrence_Of (Anon, Loc));\n          Set_Etype (Defining_Identifier (N), Anon);\n \n+      elsif Nkind (N) = N_Access_Function_Definition then\n+         Rewrite (Comp, New_Occurrence_Of (Anon, Loc));\n+\n       else\n          Rewrite (Comp,\n            Make_Component_Definition (Loc,\n@@ -4115,12 +4234,16 @@ package body Sem_Ch3 is\n       --  Temporarily remove the current scope from the stack to add the new\n       --  declarations to the enclosing scope\n \n-      if Nkind (N) /= N_Object_Declaration then\n-         Scope_Stack.Decrement_Last;\n+      if Nkind (N) = N_Object_Declaration\n+        or else Nkind (N) = N_Access_Function_Definition\n+      then\n          Analyze (Decl);\n-         Scope_Stack.Append (Curr_Scope);\n+\n       else\n+         Scope_Stack.Decrement_Last;\n          Analyze (Decl);\n+         Set_Is_Itype (Anon);\n+         Scope_Stack.Append (Curr_Scope);\n       end if;\n \n       Set_Ekind (Anon, E_Anonymous_Access_Protected_Subprogram_Type);\n@@ -4356,7 +4479,7 @@ package body Sem_Ch3 is\n       end if;\n \n       if Present (Discriminant_Specifications (N)) then\n-         New_Scope (Derived_Type);\n+         Push_Scope (Derived_Type);\n          Check_Or_Process_Discriminants (N, Derived_Type);\n          End_Scope;\n \n@@ -6170,15 +6293,15 @@ package body Sem_Ch3 is\n       --  be limited in that case the type must be explicitly declared as\n       --  limited.\n \n-      Set_Is_Tagged_Type    (Derived_Type, Is_Tagged);\n-      Set_Is_Limited_Record (Derived_Type,\n-        Limited_Present (Type_Def)\n-          or else (Is_Limited_Record (Parent_Type)\n-                    and then not Is_Interface (Parent_Type)));\n+      Set_Is_Limited_Record\n+        (Derived_Type,\n+         Limited_Present (Type_Def)\n+           or else (Is_Limited_Record (Parent_Type)\n+                     and then not Is_Interface (Parent_Type)));\n \n       --  STEP 2a: process discriminants of derived type if any\n \n-      New_Scope (Derived_Type);\n+      Push_Scope (Derived_Type);\n \n       if Discriminant_Specs then\n          Set_Has_Unknown_Discriminants (Derived_Type, False);\n@@ -6362,13 +6485,6 @@ package body Sem_Ch3 is\n       Set_Is_Private_Composite\n         (Derived_Type, Is_Private_Composite     (Parent_Type));\n \n-      if not Is_Limited_Record (Derived_Type) then\n-         Set_Is_Limited_Record\n-           (Derived_Type,\n-              Is_Limited_Record (Parent_Type)\n-                and then not Is_Interface (Parent_Type));\n-      end if;\n-\n       --  Fields inherited from the Parent_Base\n \n       Set_Has_Controlled_Component\n@@ -6613,6 +6729,29 @@ package body Sem_Ch3 is\n            (Class_Wide_Type (Derived_Type), Last_Entity (Derived_Type));\n       end if;\n \n+      --  Update the scope of anonymous access types of discriminants and other\n+      --  components, to prevent scope anomalies in gigi, when the derivation\n+      --  appears in a scope nested within that of the parent.\n+\n+      declare\n+         D : Entity_Id;\n+\n+      begin\n+         D := First_Entity (Derived_Type);\n+         while Present (D) loop\n+            if Ekind (D) = E_Discriminant\n+              or else Ekind (D) = E_Component\n+            then\n+               if Is_Itype (Etype (D))\n+                  and then Ekind (Etype (D)) = E_Anonymous_Access_Type\n+               then\n+                  Set_Scope (Etype (D), Current_Scope);\n+               end if;\n+            end if;\n+\n+            Next_Entity (D);\n+         end loop;\n+      end;\n    end Build_Derived_Record_Type;\n \n    ------------------------\n@@ -7214,6 +7353,19 @@ package body Sem_Ch3 is\n          elsif not For_Access then\n             Set_Cloned_Subtype (Def_Id, T);\n          end if;\n+\n+         --  Handle subtypes associated with statically allocated dispatch\n+         --  tables.\n+\n+         if Static_Dispatch_Tables\n+           and then VM_Target = No_VM\n+           and then RTU_Loaded (Ada_Tags)\n+           and then (T = RTE (RE_Dispatch_Table_Wrapper)\n+                       or else\n+                     T = RTE (RE_Type_Specific_Data))\n+         then\n+            Set_Size_Known_At_Compile_Time (Def_Id);\n+         end if;\n       end if;\n    end Build_Discriminated_Subtype;\n \n@@ -7458,9 +7610,10 @@ package body Sem_Ch3 is\n \n       --  Local variables\n \n-      Iface     : Node_Id;\n-      Iface_Def : Node_Id;\n-      Iface_Typ : Entity_Id;\n+      Iface       : Node_Id;\n+      Iface_Def   : Node_Id;\n+      Iface_Typ   : Entity_Id;\n+      Parent_Node : Node_Id;\n \n    --  Start of processing for Check_Abstract_Interfaces\n \n@@ -7476,16 +7629,19 @@ package body Sem_Ch3 is\n       if Nkind (Type_Definition (N)) = N_Derived_Type_Definition\n         and then Is_Interface (Etype (Defining_Identifier (N)))\n       then\n+         Parent_Node := Parent (Etype (Defining_Identifier (N)));\n+\n          Check_Ifaces\n-           (Iface_Def  => Type_Definition\n-                            (Parent (Etype (Defining_Identifier (N)))),\n+           (Iface_Def  => Type_Definition (Parent_Node),\n             Error_Node => Subtype_Indication (Type_Definition (N)));\n       end if;\n \n       Iface := First (Interface_List (Def));\n       while Present (Iface) loop\n          Iface_Typ := Find_Type_Of_Subtype_Indic (Iface);\n-         Iface_Def := Type_Definition (Parent (Iface_Typ));\n+\n+         Parent_Node := Parent (Base_Type (Iface_Typ));\n+         Iface_Def   := Type_Definition (Parent_Node);\n \n          if not Is_Interface (Iface_Typ) then\n             Error_Msg_NE (\"(Ada 2005) & must be an interface\",\n@@ -7536,6 +7692,25 @@ package body Sem_Ch3 is\n          --  operations used in dispatching selects since we always provide\n          --  automatic overridings for these subprograms.\n \n+         --  Also ignore this rule for convention CIL since .NET libraries\n+         --  do bizarre things with interfaces???\n+\n+         --  The partial view of T may have been a private extension, for\n+         --  which inherited functions dispatching on result are abstract.\n+         --  If the full view is a null extension, there is no need for\n+         --  overriding in Ada2005, but wrappers need to be built for them\n+         --  (see exp_ch3, Build_Controlling_Function_Wrappers).\n+\n+         if Is_Null_Extension (T)\n+           and then Has_Controlling_Result (Subp)\n+           and then Ada_Version >= Ada_05\n+           and then Present (Alias (Subp))\n+           and then not Comes_From_Source (Subp)\n+           and then not Is_Abstract_Subprogram (Alias (Subp))\n+         then\n+            goto Next_Subp;\n+         end if;\n+\n          if (Is_Abstract_Subprogram (Subp)\n               or else Requires_Overriding (Subp)\n               or else (Has_Controlling_Result (Subp)\n@@ -7545,6 +7720,7 @@ package body Sem_Ch3 is\n            and then not Is_TSS (Subp, TSS_Stream_Input)\n            and then not Is_TSS (Subp, TSS_Stream_Output)\n            and then not Is_Abstract_Type (T)\n+           and then Convention (T) /= Convention_CIL\n            and then Chars (Subp) /= Name_uDisp_Asynchronous_Select\n            and then Chars (Subp) /= Name_uDisp_Conditional_Select\n            and then Chars (Subp) /= Name_uDisp_Get_Prim_Op_Kind\n@@ -7663,7 +7839,8 @@ package body Sem_Ch3 is\n             end if;\n          end if;\n \n-         Next_Elmt (Elmt);\n+         <<Next_Subp>>\n+            Next_Elmt (Elmt);\n       end loop;\n    end Check_Abstract_Overriding;\n \n@@ -8847,14 +9024,21 @@ package body Sem_Ch3 is\n       Set_Is_Private_Composite (Def_Id, Is_Private_Composite (T));\n       Set_Is_Limited_Composite (Def_Id, Is_Limited_Composite (T));\n \n-      --  Build a freeze node if parent still needs one. Also, make sure\n-      --  that the Depends_On_Private status is set because the subtype\n-      --  will need reprocessing at the time the base type does.\n-      --  and also that a conditional delay is set.\n+      --  A subtype does not inherit the packed_array_type of is parent. We\n+      --  need to initialize the attribute because if Def_Id is previously\n+      --  analyzed through a limited_with clause, it will have the attributes\n+      --  of an incomplete type, one of which is an Elist that overlaps the\n+      --  Packed_Array_Type field.\n+\n+      Set_Packed_Array_Type (Def_Id, Empty);\n+\n+      --  Build a freeze node if parent still needs one. Also make sure that\n+      --  the Depends_On_Private status is set because the subtype will need\n+      --  reprocessing at the time the base type does, and also we must set a\n+      --  conditional delay.\n \n       Set_Depends_On_Private (Def_Id, Depends_On_Private (T));\n       Conditional_Delay (Def_Id, T);\n-\n    end Constrain_Array;\n \n    ------------------------------\n@@ -10175,7 +10359,6 @@ package body Sem_Ch3 is\n          if Ekind (Old_Compon) = E_Discriminant\n            and then Is_Completely_Hidden (Old_Compon)\n          then\n-\n             --  This is a shadow discriminant created for a discriminant of\n             --  the parent type that is one of several renamed by the same\n             --  new discriminant. Give the shadow discriminant an internal\n@@ -10232,8 +10415,9 @@ package body Sem_Ch3 is\n          return Nkind (Parent (T)) = N_Full_Type_Declaration\n            and then Nkind (Type_Definition (Parent (T))) = N_Record_Definition\n            and then Present (Component_List (Type_Definition (Parent (T))))\n-           and then Present (\n-             Variant_Part (Component_List (Type_Definition (Parent (T)))));\n+           and then\n+             Present\n+               (Variant_Part (Component_List (Type_Definition (Parent (T)))));\n       end Is_Variant_Record;\n \n    --  Start of processing for Create_Constrained_Components\n@@ -10260,7 +10444,7 @@ package body Sem_Ch3 is\n \n       Set_Has_Static_Discriminants (Subt, Is_Static);\n \n-      New_Scope (Subt);\n+      Push_Scope (Subt);\n \n       --  Inherit the discriminants of the parent type\n \n@@ -10788,6 +10972,13 @@ package body Sem_Ch3 is\n                                           Is_Abstract_Subprogram (E));\n             Remove_Homonym               (Iface_Subp);\n \n+            --  Hidden entities associated with interfaces must have set the\n+            --  Has_Delay_Freeze attribute to ensure that the corresponding\n+            --  entry of the secondary dispatch table is filled when such\n+            --  entity is frozen.\n+\n+            Set_Has_Delayed_Freeze (Iface_Subp);\n+\n             Next_Elmt (Elmt);\n          end loop;\n       end if;\n@@ -11179,7 +11370,7 @@ package body Sem_Ch3 is\n       then\n          Set_Is_Abstract_Subprogram (New_Subp);\n \n-      --  Finally, if the parent type is abstract  we must verify that all\n+      --  Finally, if the parent type is abstract we must verify that all\n       --  inherited operations are either non-abstract or overridden, or\n       --  that the derived type itself is abstract (this check is performed\n       --  at the end of a package declaration, in Check_Abstract_Overriding).\n@@ -11193,8 +11384,18 @@ package body Sem_Ch3 is\n         and then Is_Private_Overriding\n         and then Is_Abstract_Subprogram (Visible_Subp)\n       then\n-         Set_Alias (New_Subp, Visible_Subp);\n-         Set_Is_Abstract_Subprogram (New_Subp);\n+         if No (Actual_Subp) then\n+            Set_Alias (New_Subp, Visible_Subp);\n+            Set_Is_Abstract_Subprogram\n+              (New_Subp, True);\n+         else\n+            --  If this is a derivation for an instance of a formal derived\n+            --  type, abstractness comes from the primitive operation of the\n+            --  actual, not from the operation inherited from the ancestor.\n+\n+            Set_Is_Abstract_Subprogram\n+              (New_Subp, Is_Abstract_Subprogram (Actual_Subp));\n+         end if;\n       end if;\n \n       New_Overloaded_Entity (New_Subp, Derived_Type);\n@@ -11296,17 +11497,58 @@ package body Sem_Ch3 is\n                end if;\n \n             else\n+\n+               --  If the generic parent type is present, the derived type\n+               --  is an instance of a formal derived type, and within the\n+               --  instance its operations are those of the actual. We derive\n+               --  from the formal type but make the inherited operations\n+               --  aliases of the corresponding operations of the actual.\n+\n+               if Is_Interface (Parent_Type) then\n+\n+                  --  Find the corresponding operation in the generic actual.\n+                  --  Given that the actual is not a direct descendant of the\n+                  --  parent, as in Ada 95, the primitives are not necessarily\n+                  --  in the same order, so we have to traverse the list of\n+                  --  primitive operations of the actual to find the one that\n+                  --  implements the interface operation.\n+\n+                  Act_Elmt := First_Elmt (Act_List);\n+\n+                  while Present (Act_Elmt) loop\n+                     exit when\n+                       Abstract_Interface_Alias (Node (Act_Elmt)) = Subp;\n+                     Next_Elmt (Act_Elmt);\n+                  end loop;\n+               end if;\n+\n+               --  If the formal is not an interface, the actual is a direct\n+               --  descendant and the common  primitive operations appear in\n+               --  the same order.\n+\n                Derive_Subprogram\n                  (New_Subp, Subp, Derived_Type, Parent_Base, Node (Act_Elmt));\n-               Next_Elmt (Act_Elmt);\n+\n+               if Present (Act_Elmt) then\n+                  Next_Elmt (Act_Elmt);\n+               end if;\n             end if;\n          end if;\n \n          Next_Elmt (Elmt);\n       end loop;\n \n+      --  Inherit additional operations from progenitor interfaces.\n+      --  However, if the derived type is a generic actual, there\n+      --  are not new primitive operations for the type, because\n+      --  it has those of the actual, so nothing needs to be done.\n+      --  The renamings generated above are not primitive operations,\n+      --  and their purpose is simply to make the proper operations\n+      --  visible within an instantiation.\n+\n       if Ada_Version >= Ada_05\n         and then Is_Tagged_Type (Derived_Type)\n+        and then No (Generic_Actual)\n       then\n          Derive_Interface_Subprograms (Parent_Type, Derived_Type, Ifaces_List);\n       end if;\n@@ -11397,13 +11639,7 @@ package body Sem_Ch3 is\n       N             : Node_Id;\n       Is_Completion : Boolean)\n    is\n-      Def          : constant Node_Id := Type_Definition (N);\n-      Iface_Def    : Node_Id;\n-      Indic        : constant Node_Id := Subtype_Indication (Def);\n-      Extension    : constant Node_Id := Record_Extension_Part (Def);\n       Parent_Type  : Entity_Id;\n-      Parent_Scope : Entity_Id;\n-      Taggd        : Boolean;\n \n       function Comes_From_Generic (Typ : Entity_Id) return Boolean;\n       --  Check whether the parent type is a generic formal, or derives\n@@ -11435,6 +11671,16 @@ package body Sem_Ch3 is\n          end if;\n       end Comes_From_Generic;\n \n+      --  Local variables\n+\n+      Def          : constant Node_Id := Type_Definition (N);\n+      Iface_Def    : Node_Id;\n+      Indic        : constant Node_Id := Subtype_Indication (Def);\n+      Extension    : constant Node_Id := Record_Extension_Part (Def);\n+      Parent_Node  : Node_Id;\n+      Parent_Scope : Entity_Id;\n+      Taggd        : Boolean;\n+\n    --  Start of processing for Derived_Type_Declaration\n \n    begin\n@@ -11449,7 +11695,8 @@ package body Sem_Ch3 is\n                           Indic, Parent_Type);\n \n          else\n-            Iface_Def := Type_Definition (Parent (Parent_Type));\n+            Parent_Node := Parent (Base_Type (Parent_Type));\n+            Iface_Def   := Type_Definition (Parent_Node);\n \n             --  Ada 2005 (AI-251): Limited interfaces can only inherit from\n             --  other limited interfaces.\n@@ -11535,7 +11782,12 @@ package body Sem_Ch3 is\n                if not Is_Interface (T) then\n                   Error_Msg_NE (\"(Ada 2005) & must be an interface\", Intf, T);\n \n-               elsif Limited_Present (Def)\n+               --  Check the rules of 3.9.4(12/2) and 7.5(2/2) that disallow\n+               --  a limited type from having a nonlimited progenitor.\n+\n+               elsif (Limited_Present (Def)\n+                       or else (not Is_Interface (Parent_Type)\n+                                 and then Is_Limited_Type (Parent_Type)))\n                  and then not Is_Limited_Interface (T)\n                then\n                   Error_Msg_NE\n@@ -11906,9 +12158,14 @@ package body Sem_Ch3 is\n       Set_Is_Static_Expression (B_Node, True);\n \n       Set_High_Bound (R_Node, B_Node);\n-      Set_Scalar_Range (T, R_Node);\n-      Set_RM_Size (T, UI_From_Int (Minimum_Size (T)));\n-      Set_Enum_Esize (T);\n+\n+      --  Initialize various fields of the type. Some of this information\n+      --  may be overwritten later through rep.clauses.\n+\n+      Set_Scalar_Range    (T, R_Node);\n+      Set_RM_Size         (T, UI_From_Int (Minimum_Size (T)));\n+      Set_Enum_Esize      (T);\n+      Set_Enum_Pos_To_Rep (T, Empty);\n \n       --  Set Discard_Names if configuration pragma set, or if there is\n       --  a parameterless pragma in the current declarative region\n@@ -12290,10 +12547,7 @@ package body Sem_Ch3 is\n \n       elsif Def_Kind = N_Access_Definition then\n          T := Access_Definition (Related_Nod, Obj_Def);\n-\n-         if Nkind (Parent (Related_Nod)) /= N_Extended_Return_Statement then\n-            Set_Is_Local_Anonymous_Access (T);\n-         end if;\n+         Set_Is_Local_Anonymous_Access (T);\n \n       --  Otherwise, the object definition is just a subtype_mark\n \n@@ -12848,35 +13102,10 @@ package body Sem_Ch3 is\n                --        type T_2 is new Pack_1.T_1 with ...;\n                --     end Pack_2;\n \n-               --  When Comp is being duplicated for type T_2, its designated\n-               --  type must be set to point to the non-limited view of T_2.\n-\n-               if Ada_Version >= Ada_05\n-                 and then\n-                   Ekind (Etype (New_C)) = E_Anonymous_Access_Type\n-                 and then\n-                   Ekind (Directly_Designated_Type\n-                           (Etype (New_C))) = E_Incomplete_Type\n-                 and then\n-                   From_With_Type (Directly_Designated_Type (Etype (New_C)))\n-                 and then\n-                   Present (Non_Limited_View\n-                             (Directly_Designated_Type (Etype (New_C))))\n-                 and then\n-                   Non_Limited_View (Directly_Designated_Type\n-                                      (Etype (New_C))) = Derived_Base\n-               then\n-                  Set_Directly_Designated_Type\n-                    (Etype (New_C),\n-                     Non_Limited_View\n-                       (Directly_Designated_Type (Etype (New_C))));\n-\n-               else\n-                  Set_Etype\n-                    (New_C,\n-                     Constrain_Component_Type\n-                       (Old_C, Derived_Base, N, Parent_Base, Discs));\n-               end if;\n+               Set_Etype\n+                 (New_C,\n+                  Constrain_Component_Type\n+                  (Old_C, Derived_Base, N, Parent_Base, Discs));\n             end if;\n          end if;\n \n@@ -12886,7 +13115,13 @@ package body Sem_Ch3 is\n          --  Record_Type_Definition after processing the record extension of\n          --  the derived type.\n \n-         if Is_Tagged and then Ekind (New_C) = E_Component then\n+         --  If the declaration is a private extension, there is no further\n+         --  record extension to process, and the components retain their\n+         --  current kind, because they are visible at this point.\n+\n+         if Is_Tagged and then Ekind (New_C) = E_Component\n+           and then Nkind (N) /= N_Private_Extension_Declaration\n+         then\n             Set_Ekind (New_C, E_Void);\n          end if;\n \n@@ -13006,13 +13241,11 @@ package body Sem_Ch3 is\n       Component := First_Entity (Parent_Base);\n       while Present (Component) loop\n \n-         --  Ada 2005 (AI-251): Do not inherit tags corresponding with the\n-         --  interfaces of the parent\n+         --  Ada 2005 (AI-251): Do not inherit components associated with\n+         --  secondary tags of the parent.\n \n          if Ekind (Component) = E_Component\n-           and then Is_Tag (Component)\n-           and then RTE_Available (RE_Interface_Tag)\n-           and then Etype  (Component) = RTE (RE_Interface_Tag)\n+           and then Present (Related_Interface (Component))\n          then\n             null;\n \n@@ -13064,9 +13297,9 @@ package body Sem_Ch3 is\n    -----------------------\n \n    function Is_Null_Extension (T : Entity_Id) return Boolean is\n-      Type_Decl  : constant Node_Id := Parent (T);\n-      Comp_List  : Node_Id;\n-      First_Comp : Node_Id;\n+      Type_Decl : constant Node_Id := Parent (T);\n+      Comp_List : Node_Id;\n+      Comp      : Node_Id;\n \n    begin\n       if Nkind (Type_Decl) /= N_Full_Type_Declaration\n@@ -13087,11 +13320,22 @@ package body Sem_Ch3 is\n       elsif Present (Comp_List)\n         and then Is_Non_Empty_List (Component_Items (Comp_List))\n       then\n-         First_Comp := First (Component_Items (Comp_List));\n+         Comp := First (Component_Items (Comp_List));\n+\n+         --  Only user-defined components are relevant. The component list\n+         --  may also contain a parent component and internal components\n+         --  corresponding to secondary tags, but these do not determine\n+         --  whether this is a null extension.\n+\n+         while Present (Comp) loop\n+            if Comes_From_Source (Comp) then\n+               return False;\n+            end if;\n \n-         return Chars (Defining_Identifier (First_Comp)) = Name_uParent\n-           and then No (Next (First_Comp));\n+            Next (Comp);\n+         end loop;\n \n+         return True;\n       else\n          return True;\n       end if;\n@@ -13405,19 +13649,13 @@ package body Sem_Ch3 is\n          if not Is_Overloaded (I) then\n             T := Etype (I);\n \n-            --  If the bounds are universal, choose the specific predefined\n-            --  type.\n+            --  For universal bounds, choose the specific predefined type\n \n             if T = Universal_Integer then\n                T := Standard_Integer;\n \n             elsif T = Any_Character then\n-\n-               if Ada_Version >= Ada_95 then\n-                  Error_Msg_N\n-                    (\"ambiguous character literals (could be Wide_Character)\",\n-                      I);\n-               end if;\n+               Ambiguous_Character (Low_Bound (I));\n \n                T := Standard_Character;\n             end if;\n@@ -13742,7 +13980,7 @@ package body Sem_Ch3 is\n             if Bits > System_Max_Nonbinary_Modulus_Power then\n                Error_Msg_Uint_1 :=\n                  UI_From_Int (System_Max_Nonbinary_Modulus_Power);\n-               Error_Msg_N\n+               Error_Msg_F\n                  (\"nonbinary modulus exceeds limit (2 '*'*^ - 1)\", Mod_Expr);\n                Set_Modular_Size (System_Max_Binary_Modulus_Power);\n                return;\n@@ -13761,11 +13999,10 @@ package body Sem_Ch3 is\n       --  so we just signal an error and set the maximum size.\n \n       Error_Msg_Uint_1 := UI_From_Int (System_Max_Binary_Modulus_Power);\n-      Error_Msg_N (\"modulus exceeds limit (2 '*'*^)\", Mod_Expr);\n+      Error_Msg_F (\"modulus exceeds limit (2 '*'*^)\", Mod_Expr);\n \n       Set_Modular_Size (System_Max_Binary_Modulus_Power);\n       Init_Alignment (T);\n-\n    end Modular_Type_Declaration;\n \n    --------------------------\n@@ -13844,16 +14081,25 @@ package body Sem_Ch3 is\n \n       --  Ada 2005 (AI-287, AI-318): Relax the strictness of the front-end in\n       --  case of limited aggregates (including extension aggregates),\n-      --  and function calls.\n+      --  and function calls. The function call may have been give in prefixed\n+      --  notation, in which case the original node is an indexed component.\n \n       case Nkind (Original_Node (Exp)) is\n-         when N_Aggregate | N_Extension_Aggregate | N_Function_Call =>\n+         when N_Aggregate | N_Extension_Aggregate | N_Function_Call | N_Op =>\n             return True;\n \n-         when N_Qualified_Expression =>\n+         --  Ada 2005 (AI-251): If a class-wide interface object is initialized\n+         --  with a function call, the expander has rewriten the call into an\n+         --  N_Type_Conversion node to force displacement of the pointer to\n+         --  reference the component containing the secondary dispatch table.\n+\n+         when N_Qualified_Expression | N_Type_Conversion =>\n             return OK_For_Limited_Init_In_05\n                      (Expression (Original_Node (Exp)));\n \n+         when N_Indexed_Component =>\n+            return Nkind (Exp) = N_Function_Call;\n+\n          when others =>\n             return False;\n       end case;\n@@ -14071,18 +14317,6 @@ package body Sem_Ch3 is\n          if Nkind (Discriminant_Type (Discr)) = N_Access_Definition then\n             Discr_Type := Access_Definition (Discr, Discriminant_Type (Discr));\n \n-            --  Ada 2005 (AI-230): Access discriminants are now allowed for\n-            --  nonlimited types, and are treated like other components of\n-            --  anonymous access types in terms of accessibility.\n-\n-            if not Is_Concurrent_Type (Current_Scope)\n-              and then not Is_Concurrent_Record_Type (Current_Scope)\n-              and then not Is_Limited_Record (Current_Scope)\n-              and then Ekind (Current_Scope) /= E_Limited_Private_Type\n-            then\n-               Set_Is_Local_Anonymous_Access (Discr_Type);\n-            end if;\n-\n             --  Ada 2005 (AI-254)\n \n             if Present (Access_To_Subprogram_Definition\n@@ -14186,9 +14420,10 @@ package body Sem_Ch3 is\n               and then not Is_Itype (Discr_Type)\n             then\n                if Can_Never_Be_Null (Discr_Type) then\n-                  Error_Msg_N\n-                    (\"null-exclusion cannot be applied to \" &\n-                     \"a null excluding type\", Discr);\n+                  Error_Msg_NE\n+                    (\"`NOT NULL` not allowed (& already excludes null)\",\n+                     Discr,\n+                     Discr_Type);\n                end if;\n \n                Set_Etype (Defining_Identifier (Discr),\n@@ -14755,8 +14990,8 @@ package body Sem_Ch3 is\n          end loop;\n       end;\n \n-      --  If the private view was tagged, copy the new Primitive\n-      --  operations from the private view to the full view.\n+      --  If the private view was tagged, copy the new primitive operations\n+      --  from the private view to the full view.\n \n       if Is_Tagged_Type (Full_T)\n         and then not Is_Concurrent_Type (Full_T)\n@@ -14876,6 +15111,14 @@ package body Sem_Ch3 is\n             Set_Must_Have_Preelab_Init (Full_T);\n          end if;\n       end if;\n+\n+      --  If pragma CPP_Class was applied to the private type declaration,\n+      --  propagate it now to the full type declaration.\n+\n+      if Is_CPP_Class (Priv_T) then\n+         Set_Is_CPP_Class (Full_T);\n+         Set_Convention   (Full_T, Convention_CPP);\n+      end if;\n    end Process_Full_View;\n \n    -----------------------------------\n@@ -15308,8 +15551,7 @@ package body Sem_Ch3 is\n            and then Nkind (P) /= N_Access_To_Object_Definition\n            and then not Is_Access_Type (Entity (S))\n          then\n-            Error_Msg_N\n-              (\"null-exclusion must be applied to an access type\", S);\n+            Error_Msg_N (\"`NOT NULL` only allowed for an access type\", S);\n          end if;\n \n          May_Have_Null_Exclusion :=\n@@ -15371,9 +15613,10 @@ package body Sem_Ch3 is\n                      Error_Node := Related_Nod;\n                end case;\n \n-               Error_Msg_N\n-                 (\"null-exclusion cannot be applied to \" &\n-                  \"a null excluding type\", Error_Node);\n+               Error_Msg_NE\n+                 (\"`NOT NULL` not allowed (& already excludes null)\",\n+                  Error_Node,\n+                  Entity (S));\n             end if;\n \n             Set_Etype  (S,\n@@ -15680,6 +15923,37 @@ package body Sem_Ch3 is\n          Subt : Node_Id;\n          Type_Id : constant Name_Id := Chars (Typ);\n \n+         function Names_T (Nam : Node_Id) return Boolean;\n+\n+         --  The record type has not been introduced in the current scope\n+         --  yet, so we must examine the name of the type itself, either\n+         --  an identifier T, or an expanded name of the form P.T, where\n+         --  P denotes the current scope.\n+\n+         function Names_T (Nam : Node_Id) return Boolean is\n+         begin\n+            if Nkind (Nam) = N_Identifier then\n+               return Chars (Nam) = Type_Id;\n+\n+            elsif Nkind (Nam) = N_Selected_Component then\n+               if Chars (Selector_Name (Nam)) = Type_Id then\n+                  if Nkind (Prefix (Nam)) = N_Identifier then\n+                     return Chars (Prefix (Nam)) = Chars (Current_Scope);\n+\n+                  elsif Nkind (Prefix (Nam)) = N_Selected_Component then\n+                     return Chars (Selector_Name (Prefix (Nam)))\n+                       = Chars (Current_Scope);\n+                  else\n+                     return False;\n+                  end if;\n+               else\n+                  return False;\n+               end if;\n+            else\n+               return False;\n+            end if;\n+         end Names_T;\n+\n       begin\n          if No (Access_To_Subprogram_Definition (Acc_Def)) then\n             Subt := Subtype_Mark (Acc_Def);\n@@ -15688,15 +15962,13 @@ package body Sem_Ch3 is\n                return Chars (Subt) = Type_Id;\n \n             --  Reference can be through an expanded name which has not been\n-            --  analyzed yet, and designates enclosing scopes.\n+            --  analyzed yet, and which designates enclosing scopes.\n \n             elsif Nkind (Subt) = N_Selected_Component then\n-               Analyze (Prefix (Subt));\n-\n-               if Chars (Selector_Name (Subt)) = Type_Id then\n-                  return Is_Entity_Name (Prefix (Subt))\n-                    and then Entity (Prefix (Subt)) = Current_Scope;\n+               if Names_T (Subt) then\n+                  return True;\n \n+               --  Otherwise it must denote an entity that is already visible.\n                --  The access definition may name a subtype of the enclosing\n                --  type, if there is a previous incomplete declaration for it.\n \n@@ -15717,10 +15989,9 @@ package body Sem_Ch3 is\n             --  a 'Class attribute.\n \n             elsif Nkind (Subt) = N_Attribute_Reference\n-               and then Attribute_Name (Subt) = Name_Class\n-               and then Is_Entity_Name (Prefix (Subt))\n+              and then Attribute_Name (Subt) = Name_Class\n             then\n-               return (Chars (Prefix (Subt))) = Type_Id;\n+               return Names_T (Prefix (Subt));\n             else\n                return False;\n             end if;\n@@ -15801,11 +16072,21 @@ package body Sem_Ch3 is\n                       Relocate_Node\n                         (Subtype_Mark\n                           (Access_Definition (Comp_Def))));\n+\n+               Set_Constant_Present\n+                 (Type_Def, Constant_Present (Access_Definition (Comp_Def)));\n+               Set_All_Present\n+                 (Type_Def, All_Present (Access_Definition (Comp_Def)));\n             end if;\n \n-            Decl := Make_Full_Type_Declaration (Loc,\n-               Defining_Identifier => Anon_Access,\n-               Type_Definition => Type_Def);\n+            Set_Null_Exclusion_Present\n+              (Type_Def,\n+               Null_Exclusion_Present (Access_Definition (Comp_Def)));\n+\n+            Decl :=\n+              Make_Full_Type_Declaration (Loc,\n+                Defining_Identifier => Anon_Access,\n+                Type_Definition     => Type_Def);\n \n             Insert_Before (Typ_Decl, Decl);\n             Analyze (Decl);\n@@ -15951,7 +16232,7 @@ package body Sem_Ch3 is\n \n       --  Enter record scope\n \n-      New_Scope (T);\n+      Push_Scope (T);\n \n       --  If an incomplete or private type declaration was already given for\n       --  the type, then this scope already exists, and the discriminants have\n@@ -16082,11 +16363,14 @@ package body Sem_Ch3 is\n \n       --  After completing the semantic analysis of the record definition,\n       --  record components, both new and inherited, are accessible. Set their\n-      --  kind accordingly.\n+      --  kind accordingly. Exclude malformed itypes from illegal declarations,\n+      --  whose Ekind may be void.\n \n       Component := First_Entity (Current_Scope);\n       while Present (Component) loop\n-         if Ekind (Component) = E_Void then\n+         if Ekind (Component) = E_Void\n+           and then not Is_Itype (Component)\n+         then\n             Set_Ekind (Component, E_Component);\n             Init_Component_Location (Component);\n          end if;"}]}