{"sha": "0618dee54e14e37e88ab4cf47e7372da8f333719", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDYxOGRlZTU0ZTE0ZTM3ZTg4YWI0Y2Y0N2U3MzcyZGE4ZjMzMzcxOQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2014-02-28T12:57:40Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2014-02-28T12:57:40Z"}, "message": "re PR debug/59992 (Compilation of insn-recog.c too slow due to var-tracking)\n\nPR debug/59992\n* cselib.c (cselib_hasher::equal): Special-case VALUE lookup.\n(cselib_preserved_hash_table): New.\n(preserve_constants_and_equivs): Move preserved vals to it.\n(cselib_find_slot): Look it up first.\n(cselib_init): Initialize it.\n(cselib_finish): Release it.\n(dump_cselib_table): Dump it.\n\nFrom-SVN: r208221", "tree": {"sha": "6ecb38916d40fb864e3cb37d0a87a9c6886bfe08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ecb38916d40fb864e3cb37d0a87a9c6886bfe08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0618dee54e14e37e88ab4cf47e7372da8f333719", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0618dee54e14e37e88ab4cf47e7372da8f333719", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0618dee54e14e37e88ab4cf47e7372da8f333719", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0618dee54e14e37e88ab4cf47e7372da8f333719/comments", "author": null, "committer": null, "parents": [{"sha": "22414f3ffcc916cf5fdaa5d3b0d180c197b6d848", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22414f3ffcc916cf5fdaa5d3b0d180c197b6d848", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22414f3ffcc916cf5fdaa5d3b0d180c197b6d848"}], "stats": {"total": 45, "additions": 41, "deletions": 4}, "files": [{"sha": "f90cc91371bccaf4f4dacdffd78a4f9ce358e348", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0618dee54e14e37e88ab4cf47e7372da8f333719/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0618dee54e14e37e88ab4cf47e7372da8f333719/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0618dee54e14e37e88ab4cf47e7372da8f333719", "patch": "@@ -1,3 +1,14 @@\n+2014-02-28  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR debug/59992\n+\t* cselib.c (cselib_hasher::equal): Special-case VALUE lookup.\n+\t(cselib_preserved_hash_table): New.\n+\t(preserve_constants_and_equivs): Move preserved vals to it.\n+\t(cselib_find_slot): Look it up first.\n+\t(cselib_init): Initialize it.\n+\t(cselib_finish): Release it.\n+\t(dump_cselib_table): Dump it.\n+\n 2014-02-28  Alexandre Oliva <aoliva@redhat.com>\n \n \tPR debug/59992"}, {"sha": "0fcfe285eb515373f35e4da68d552936e2604dfe", "filename": "gcc/cselib.c", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0618dee54e14e37e88ab4cf47e7372da8f333719/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0618dee54e14e37e88ab4cf47e7372da8f333719/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=0618dee54e14e37e88ab4cf47e7372da8f333719", "patch": "@@ -132,6 +132,9 @@ cselib_hasher::equal (const value_type *v, const compare_type *x_arg)\n \t  || GET_CODE (XEXP (x, 0)) == CONST_FIXED))\n     x = XEXP (x, 0);\n \n+  if (GET_CODE (x) == VALUE)\n+    return x == v->val_rtx;\n+\n   /* We don't guarantee that distinct rtx's have different hash values,\n      so we need to do a comparison.  */\n   for (l = v->locs; l; l = l->next)\n@@ -147,6 +150,9 @@ cselib_hasher::equal (const value_type *v, const compare_type *x_arg)\n /* A table that enables us to look up elts by their value.  */\n static hash_table <cselib_hasher> cselib_hash_table;\n \n+/* A table to hold preserved values.  */\n+static hash_table <cselib_hasher> cselib_preserved_hash_table;\n+\n /* This is a global so we don't have to pass this through every function.\n    It is used in new_elt_loc_list to set SETTING_INSN.  */\n static rtx cselib_current_insn;\n@@ -490,8 +496,17 @@ preserve_constants_and_equivs (cselib_val **x, void *info ATTRIBUTE_UNUSED)\n {\n   cselib_val *v = *x;\n \n-  if (!invariant_or_equiv_p (v))\n-    cselib_hash_table.clear_slot (x);\n+  if (invariant_or_equiv_p (v))\n+    {\n+      cselib_val **slot\n+\t= cselib_preserved_hash_table.find_slot_with_hash (v->val_rtx,\n+\t\t\t\t\t\t\t   v->hash, INSERT);\n+      gcc_assert (!*slot);\n+      *slot = v;\n+    }\n+\n+  cselib_hash_table.clear_slot (x);\n+\n   return 1;\n }\n \n@@ -565,9 +580,13 @@ static cselib_val **\n cselib_find_slot (rtx x, hashval_t hash, enum insert_option insert,\n \t\t  enum machine_mode memmode)\n {\n-  cselib_val **slot;\n+  cselib_val **slot = NULL;\n   find_slot_memmode = memmode;\n-  slot = cselib_hash_table.find_slot_with_hash (x, hash, insert);\n+  if (cselib_preserve_constants)\n+    slot = cselib_preserved_hash_table.find_slot_with_hash (x, hash,\n+\t\t\t\t\t\t\t    NO_INSERT);\n+  if (!slot)\n+    slot = cselib_hash_table.find_slot_with_hash (x, hash, insert);\n   find_slot_memmode = VOIDmode;\n   return slot;\n }\n@@ -2742,6 +2761,8 @@ cselib_init (int record_what)\n   used_regs = XNEWVEC (unsigned int, cselib_nregs);\n   n_used_regs = 0;\n   cselib_hash_table.create (31);\n+  if (cselib_preserve_constants)\n+    cselib_preserved_hash_table.create (31);\n   next_uid = 1;\n }\n \n@@ -2750,6 +2771,7 @@ cselib_init (int record_what)\n void\n cselib_finish (void)\n {\n+  bool preserved = cselib_preserve_constants;\n   cselib_discard_hook = NULL;\n   cselib_preserve_constants = false;\n   cselib_any_perm_equivs = false;\n@@ -2761,6 +2783,8 @@ cselib_finish (void)\n   free_alloc_pool (value_pool);\n   cselib_clear_table ();\n   cselib_hash_table.dispose ();\n+  if (preserved)\n+    cselib_preserved_hash_table.dispose ();\n   free (used_regs);\n   used_regs = 0;\n   n_useless_values = 0;\n@@ -2850,6 +2874,8 @@ dump_cselib_table (FILE *out)\n {\n   fprintf (out, \"cselib hash table:\\n\");\n   cselib_hash_table.traverse <FILE *, dump_cselib_val> (out);\n+  fprintf (out, \"cselib preserved hash table:\\n\");\n+  cselib_preserved_hash_table.traverse <FILE *, dump_cselib_val> (out);\n   if (first_containing_mem != &dummy_val)\n     {\n       fputs (\"first mem \", out);"}]}