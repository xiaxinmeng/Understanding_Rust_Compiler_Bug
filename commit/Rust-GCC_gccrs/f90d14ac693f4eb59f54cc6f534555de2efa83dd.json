{"sha": "f90d14ac693f4eb59f54cc6f534555de2efa83dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkwZDE0YWM2OTNmNGViNTlmNTRjYzZmNTM0NTU1ZGUyZWZhODNkZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-29T15:19:01Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-29T15:19:01Z"}, "message": "[multiple changes]\n\n2014-01-29  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch4.adb (Find_Component_In_Instance): Update comment.\n\n2014-01-29  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_util.adb (Build_Task_Image_Prefix): Indicate that the\n\tresulting string is an internal entity. and thus requires no\n\tinitialization. This is relevant when Initialize_ Scalars is\n\tenabled, because the resultant spurious initialization may lead to\n\tsecondary stack anomalies that produce a mangled name for a task.\n\n2014-01-29  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): SPARK_Mode\n\tnot inherited from spec anymore. Check consistency\n\trules after processing of declarations.\n\t* sem_ch7.adb (Analyze_Package_Body_Helper): SPARK_Mode not inherited\n\tfrom spec anymore. Check consistency rules after processing of\n\tdeclarations.\n\t(Analyze_Package_Declaration): Set SPARK_Mode only for non-generic\n\tpackages.\n\t* sem_prag.adb (Analyze_Pragma/Pragma_SPARK_Mode): Implement new\n\tconsistency rules.\n\nFrom-SVN: r207242", "tree": {"sha": "901dea19bd1e814db8e43571431198eab23c616f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/901dea19bd1e814db8e43571431198eab23c616f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f90d14ac693f4eb59f54cc6f534555de2efa83dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f90d14ac693f4eb59f54cc6f534555de2efa83dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f90d14ac693f4eb59f54cc6f534555de2efa83dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f90d14ac693f4eb59f54cc6f534555de2efa83dd/comments", "author": null, "committer": null, "parents": [{"sha": "8a972abdd98acac11c9882957ebf5e68d532948e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a972abdd98acac11c9882957ebf5e68d532948e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a972abdd98acac11c9882957ebf5e68d532948e"}], "stats": {"total": 299, "additions": 205, "deletions": 94}, "files": [{"sha": "8987a17b60bb4156fd31b389aa8aff900c959f38", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90d14ac693f4eb59f54cc6f534555de2efa83dd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90d14ac693f4eb59f54cc6f534555de2efa83dd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f90d14ac693f4eb59f54cc6f534555de2efa83dd", "patch": "@@ -1,3 +1,28 @@\n+2014-01-29  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch4.adb (Find_Component_In_Instance): Update comment.\n+\n+2014-01-29  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_util.adb (Build_Task_Image_Prefix): Indicate that the\n+\tresulting string is an internal entity. and thus requires no\n+\tinitialization. This is relevant when Initialize_ Scalars is\n+\tenabled, because the resultant spurious initialization may lead to\n+\tsecondary stack anomalies that produce a mangled name for a task.\n+\n+2014-01-29  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): SPARK_Mode\n+\tnot inherited from spec anymore. Check consistency\n+\trules after processing of declarations.\n+\t* sem_ch7.adb (Analyze_Package_Body_Helper): SPARK_Mode not inherited\n+\tfrom spec anymore. Check consistency rules after processing of\n+\tdeclarations.\n+\t(Analyze_Package_Declaration): Set SPARK_Mode only for non-generic\n+\tpackages.\n+\t* sem_prag.adb (Analyze_Pragma/Pragma_SPARK_Mode): Implement new\n+\tconsistency rules.\n+\n 2014-01-27  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_res.adb (Resolve_Comparison_Op): Add type name/location"}, {"sha": "f6fff6cff7d7acd195a1fb65e8dcc48114819177", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90d14ac693f4eb59f54cc6f534555de2efa83dd/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90d14ac693f4eb59f54cc6f534555de2efa83dd/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=f90d14ac693f4eb59f54cc6f534555de2efa83dd", "patch": "@@ -1403,6 +1403,12 @@ package body Exp_Util is\n                          Low_Bound => Make_Integer_Literal (Loc, 1),\n                          High_Bound => New_Occurrence_Of (Len, Loc)))))));\n \n+      --  Indicate that the result is an internal temporary, so it does not\n+      --  receive a bogus initialization when declaration is expanded. This\n+      --  is both efficient, and prevents anomalies in the handling of\n+      --  dynamic objects on the secondary stack.\n+\n+      Set_Is_Internal (Res);\n       Pos := Make_Temporary (Loc, 'P');\n \n       Append_To (Decls,"}, {"sha": "7c0a0cc81c4a28e0a6714a2550e8ccd14a82b37e", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90d14ac693f4eb59f54cc6f534555de2efa83dd/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90d14ac693f4eb59f54cc6f534555de2efa83dd/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=f90d14ac693f4eb59f54cc6f534555de2efa83dd", "patch": "@@ -3940,10 +3940,10 @@ package body Sem_Ch4 is\n       --  In an instance, a component of a private extension may not be visible\n       --  while it was visible in the generic. Search candidate scope for a\n       --  component with the proper identifier. This is only done if all other\n-      --  searches have failed. When the match is found (it always will be),\n-      --  the Etype of both N and Sel are set from this component, and the\n-      --  entity of Sel is set to reference this component.\n-      --  ??? no longer true that a match is found ???\n+      --  searches have failed. If a match is found, the Etype of both N and\n+      --  Sel are set from this component, and the entity of Sel is set to\n+      --  reference this component. If no match is found, Entity (Sel) remains\n+      --  unset.\n \n       function Has_Mode_Conformant_Spec (Comp : Entity_Id) return Boolean;\n       --  It is known that the parent of N denotes a subprogram call. Comp"}, {"sha": "77108b25bde0de8ab520b94cdc99fae708994da1", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 39, "deletions": 46, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90d14ac693f4eb59f54cc6f534555de2efa83dd/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90d14ac693f4eb59f54cc6f534555de2efa83dd/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=f90d14ac693f4eb59f54cc6f534555de2efa83dd", "patch": "@@ -2999,34 +2999,10 @@ package body Sem_Ch6 is\n \n             Push_Scope (Spec_Id);\n \n-            --  Set SPARK_Mode\n+            --  Set SPARK_Mode from context\n \n-            --  For internally generated subprogram, always off. But generic\n-            --  instances are not generated implicitly, so are never considered\n-            --  as internal, even though Comes_From_Source is false.\n-\n-            if not Comes_From_Source (Spec_Id)\n-              and then not Is_Generic_Instance (Spec_Id)\n-            then\n-               SPARK_Mode := Off;\n-               SPARK_Mode_Pragma := Empty;\n-\n-            --  Inherited from spec\n-\n-            elsif Present (SPARK_Pragma (Spec_Id))\n-              and then not SPARK_Pragma_Inherited (Spec_Id)\n-            then\n-               SPARK_Mode_Pragma := SPARK_Pragma (Spec_Id);\n-               SPARK_Mode := Get_SPARK_Mode_From_Pragma (SPARK_Mode_Pragma);\n-               Set_SPARK_Pragma (Body_Id, SPARK_Pragma (Spec_Id));\n-               Set_SPARK_Pragma_Inherited (Body_Id, True);\n-\n-            --  Otherwise set from context\n-\n-            else\n-               Set_SPARK_Pragma (Body_Id, SPARK_Mode_Pragma);\n-               Set_SPARK_Pragma_Inherited (Body_Id, True);\n-            end if;\n+            Set_SPARK_Pragma (Body_Id, SPARK_Mode_Pragma);\n+            Set_SPARK_Pragma_Inherited (Body_Id, True);\n \n             --  Make sure that the subprogram is immediately visible. For\n             --  child units that have no separate spec this is indispensable.\n@@ -3076,17 +3052,10 @@ package body Sem_Ch6 is\n \n             Push_Scope (Body_Id);\n \n-            --  Set SPARK_Mode from context or OFF for internal routine\n+            --  Set SPARK_Mode from context\n \n-            if Comes_From_Source (Body_Id) then\n-               Set_SPARK_Pragma (Body_Id, SPARK_Mode_Pragma);\n-               Set_SPARK_Pragma_Inherited (Body_Id, True);\n-            else\n-               Set_SPARK_Pragma (Body_Id, Empty);\n-               Set_SPARK_Pragma_Inherited (Body_Id, False);\n-               SPARK_Mode := Off;\n-               SPARK_Mode_Pragma := Empty;\n-            end if;\n+            Set_SPARK_Pragma (Body_Id, SPARK_Mode_Pragma);\n+            Set_SPARK_Pragma_Inherited (Body_Id, True);\n          end if;\n \n          --  For stubs and bodies with no previous spec, generate references to\n@@ -3277,6 +3246,35 @@ package body Sem_Ch6 is\n \n       Analyze_Declarations (Declarations (N));\n \n+      --  After declarations have been analyzed, the body has been set\n+      --  its final value of SPARK_Mode. Check that SPARK_Mode for body\n+      --  is consistent with SPARK_Mode for spec.\n+\n+      if Present (Spec_Id) and then Present (SPARK_Pragma (Body_Id)) then\n+         if Present (SPARK_Pragma (Spec_Id)) then\n+            if Get_SPARK_Mode_From_Pragma (SPARK_Pragma (Spec_Id)) = Off\n+                 and then\n+               Get_SPARK_Mode_From_Pragma (SPARK_Pragma (Body_Id)) = On\n+            then\n+               Error_Msg_Sloc := Sloc (SPARK_Pragma (Body_Id));\n+               Error_Msg_N (\"incorrect application of SPARK_Mode#\", N);\n+               Error_Msg_Sloc := Sloc (SPARK_Pragma (Spec_Id));\n+               Error_Msg_NE\n+                 (\"\\value Off was set for SPARK_Mode on & #\", N, Spec_Id);\n+            end if;\n+\n+         elsif Nkind (Parent (Parent (Spec_Id))) = N_Subprogram_Body_Stub then\n+            null;\n+\n+         else\n+            Error_Msg_Sloc := Sloc (SPARK_Pragma (Body_Id));\n+            Error_Msg_N (\"incorrect application of SPARK_Mode#\", N);\n+            Error_Msg_Sloc := Sloc (Spec_Id);\n+            Error_Msg_NE\n+              (\"\\no value was set for SPARK_Mode on & #\", N, Spec_Id);\n+         end if;\n+      end if;\n+\n       --  Check completion, and analyze the statements\n \n       Check_Completion;\n@@ -3632,16 +3630,11 @@ package body Sem_Ch6 is\n \n       Generate_Definition (Designator);\n \n-      --  Set SPARK mode, always off for internal routines, otherwise set\n-      --  from current context (may be overwritten later with explicit pragma)\n+      --  Set SPARK mode from current context (may be overwritten later with\n+      --  explicit pragma).\n \n-      if Comes_From_Source (Designator) then\n-         Set_SPARK_Pragma (Designator, SPARK_Mode_Pragma);\n-         Set_SPARK_Pragma_Inherited (Designator, True);\n-      else\n-         Set_SPARK_Pragma (Designator, Empty);\n-         Set_SPARK_Pragma_Inherited (Designator, False);\n-      end if;\n+      Set_SPARK_Pragma (Designator, SPARK_Mode_Pragma);\n+      Set_SPARK_Pragma_Inherited (Designator, True);\n \n       if Debug_Flag_C then\n          Write_Str (\"==> subprogram spec \");"}, {"sha": "79cd31a3d4bd44584a8d7e41b943ba0ca501c3fb", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 40, "deletions": 21, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90d14ac693f4eb59f54cc6f534555de2efa83dd/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90d14ac693f4eb59f54cc6f534555de2efa83dd/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=f90d14ac693f4eb59f54cc6f534555de2efa83dd", "patch": "@@ -346,28 +346,19 @@ package body Sem_Ch7 is\n \n       Push_Scope (Spec_Id);\n \n-      --  Set SPARK_Mode from private part of spec if it has a SPARK pragma.\n-      --  Note that in the default case, SPARK_Aux_Pragma will be a copy of\n-      --  SPARK_Pragma in the spec, so this properly handles the case where\n-      --  there is no explicit SPARK_Pragma mode in the private part.\n-\n-      if Present (SPARK_Pragma (Spec_Id)) then\n-         SPARK_Mode_Pragma := SPARK_Aux_Pragma (Spec_Id);\n-         SPARK_Mode := Get_SPARK_Mode_From_Pragma (SPARK_Mode_Pragma);\n-         Set_SPARK_Pragma (Body_Id, SPARK_Mode_Pragma);\n-         Set_SPARK_Pragma_Inherited (Body_Id, True);\n+      --  Set SPARK_Mode only for non-generic package\n \n-      --  Otherwise set from context\n+      if Ekind (Spec_Id) = E_Package then\n+         --  Set SPARK_Mode from context\n \n-      else\n          Set_SPARK_Pragma (Body_Id, SPARK_Mode_Pragma);\n          Set_SPARK_Pragma_Inherited (Body_Id, True);\n-      end if;\n \n-      --  Set elaboration code SPARK mode the same for now\n+         --  Set elaboration code SPARK mode the same for now\n \n-      Set_SPARK_Aux_Pragma (Body_Id, SPARK_Pragma (Body_Id));\n-      Set_SPARK_Aux_Pragma_Inherited (Body_Id, True);\n+         Set_SPARK_Aux_Pragma (Body_Id, SPARK_Pragma (Body_Id));\n+         Set_SPARK_Aux_Pragma_Inherited (Body_Id, True);\n+      end if;\n \n       Set_Categorization_From_Pragmas (N);\n \n@@ -400,6 +391,32 @@ package body Sem_Ch7 is\n          Inspect_Deferred_Constant_Completion (Declarations (N));\n       end if;\n \n+      --  After declarations have been analyzed, the body has been set\n+      --  its final value of SPARK_Mode. Check that SPARK_Mode for body\n+      --  is consistent with SPARK_Mode for spec.\n+\n+      if Present (SPARK_Pragma (Body_Id)) then\n+         if Present (SPARK_Aux_Pragma (Spec_Id)) then\n+            if Get_SPARK_Mode_From_Pragma (SPARK_Aux_Pragma (Spec_Id)) = Off\n+                 and then\n+               Get_SPARK_Mode_From_Pragma (SPARK_Pragma (Body_Id)) = On\n+            then\n+               Error_Msg_Sloc := Sloc (SPARK_Pragma (Body_Id));\n+               Error_Msg_N (\"incorrect application of SPARK_Mode#\", N);\n+               Error_Msg_Sloc := Sloc (SPARK_Aux_Pragma (Spec_Id));\n+               Error_Msg_NE (\"\\value Off was set for SPARK_Mode on & #\",\n+                             N, Spec_Id);\n+            end if;\n+\n+         else\n+            Error_Msg_Sloc := Sloc (SPARK_Pragma (Body_Id));\n+            Error_Msg_N (\"incorrect application of SPARK_Mode#\", N);\n+            Error_Msg_Sloc := Sloc (Spec_Id);\n+            Error_Msg_NE (\"\\no value was set for SPARK_Mode on & #\",\n+                          N, Spec_Id);\n+         end if;\n+      end if;\n+\n       --  Analyze_Declarations has caused freezing of all types. Now generate\n       --  bodies for RACW primitives and stream attributes, if any.\n \n@@ -814,12 +831,14 @@ package body Sem_Ch7 is\n       Set_Etype    (Id, Standard_Void_Type);\n       Set_Contract (Id, Make_Contract (Sloc (Id)));\n \n-      --  Inherit spark mode from context for now\n+      --  Set SPARK_Mode from context only for non-generic package\n \n-      Set_SPARK_Pragma               (Id, SPARK_Mode_Pragma);\n-      Set_SPARK_Aux_Pragma           (Id, SPARK_Mode_Pragma);\n-      Set_SPARK_Pragma_Inherited     (Id, True);\n-      Set_SPARK_Aux_Pragma_Inherited (Id, True);\n+      if Ekind (Id) = E_Package then\n+         Set_SPARK_Pragma               (Id, SPARK_Mode_Pragma);\n+         Set_SPARK_Aux_Pragma           (Id, SPARK_Mode_Pragma);\n+         Set_SPARK_Pragma_Inherited     (Id, True);\n+         Set_SPARK_Aux_Pragma_Inherited (Id, True);\n+      end if;\n \n       --  Analyze aspect specifications immediately, since we need to recognize\n       --  things like Pure early enough to diagnose violations during analysis."}, {"sha": "1cc7fd2460c9a2f2c1a7547f1bc02d35e483bf1f", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 91, "deletions": 23, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90d14ac693f4eb59f54cc6f534555de2efa83dd/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90d14ac693f4eb59f54cc6f534555de2efa83dd/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=f90d14ac693f4eb59f54cc6f534555de2efa83dd", "patch": "@@ -18597,14 +18597,26 @@ package body Sem_Prag is\n             Spec_Id : Entity_Id;\n             Stmt    : Node_Id;\n \n-            procedure Check_Pragma_Conformance (Old_Pragma : Node_Id);\n-            --  Verify the monotonicity of SPARK modes between the new pragma\n-            --  N, and the old pragma, Old_Pragma, that was inherited. If\n-            --  Old_Pragma is Empty, the call has no effect, otherwise we\n-            --  verify that the new mode is less restrictive than the old mode.\n-            --  For example, if the old mode is ON, then the new mode can be\n-            --  anything. But if the old mode is OFF, then the only allowed\n-            --  new mode is also OFF.\n+            procedure Check_Pragma_Conformance\n+              (Context_Pragma : Node_Id;\n+               Entity_Pragma  : Node_Id;\n+               Entity         : Entity_Id);\n+            --  If Context_Pragma is not Empty, verify that the new pragma N\n+            --  is compatible with the pragma Context_Pragma that was inherited\n+            --  from the context:\n+            --  . if Context_Pragma is ON, then the new mode can be anything\n+            --  . if Context_Pragma is OFF, then the only allowed new mode is\n+            --    also OFF.\n+            --\n+            --  If Entity is not Empty, verify that the new pragma N is\n+            --  compatible with Entity_Pragma, the SPARK_Mode previously set\n+            --  for Entity (which may be Empty):\n+            --  . if Entity_Pragma is ON, then the new mode can be anything\n+            --  . if Entity_Pragma is OFF, then the only allowed new mode is\n+            --    also OFF.\n+            --  . if Entity_Pragma is Empty, we always issue an error, as this\n+            --    corresponds to a case where a previous section of Entity\n+            --    had no SPARK_Mode set.\n \n             procedure Check_Library_Level_Entity (E : Entity_Id);\n             --  Verify that pragma is applied to library-level entity E\n@@ -18613,20 +18625,44 @@ package body Sem_Prag is\n             -- Check_Pragma_Conformance --\n             ------------------------------\n \n-            procedure Check_Pragma_Conformance (Old_Pragma : Node_Id) is\n+            procedure Check_Pragma_Conformance\n+              (Context_Pragma : Node_Id;\n+               Entity_Pragma  : Node_Id;\n+               Entity         : Entity_Id) is\n             begin\n-               if Present (Old_Pragma) then\n-                  pragma Assert (Nkind (Old_Pragma) = N_Pragma);\n+               if Present (Context_Pragma) then\n+                  pragma Assert (Nkind (Context_Pragma) = N_Pragma);\n \n                   --  New mode less restrictive than the established mode\n \n-                  if Get_SPARK_Mode_From_Pragma (Old_Pragma) = Off\n+                  if Get_SPARK_Mode_From_Pragma (Context_Pragma) = Off\n                     and then Mode_Id = On\n                   then\n                      Error_Msg_N\n-                       (\"cannot change 'S'P'A'R'K_Mode from Off to On\", Arg1);\n+                       (\"cannot change SPARK_Mode from Off to On\", Arg1);\n                      Error_Msg_Sloc := Sloc (SPARK_Mode_Pragma);\n-                     Error_Msg_N (\"\\'S'P'A'R'K_Mode was set to Off#\", Arg1);\n+                     Error_Msg_N (\"\\SPARK_Mode was set to Off#\", Arg1);\n+                     raise Pragma_Exit;\n+                  end if;\n+               end if;\n+\n+               if Present (Entity) then\n+                  if Present (Entity_Pragma) then\n+                     if Get_SPARK_Mode_From_Pragma (Entity_Pragma) = Off\n+                       and then Mode_Id = On\n+                     then\n+                        Error_Msg_N (\"incorrect use of SPARK_Mode\", Arg1);\n+                        Error_Msg_Sloc := Sloc (Entity_Pragma);\n+                        Error_Msg_NE\n+                          (\"\\value Off was set for SPARK_Mode on & #\",\n+                           Arg1, Entity);\n+                        raise Pragma_Exit;\n+                     end if;\n+                  else\n+                     Error_Msg_N (\"incorrect use of SPARK_Mode\", Arg1);\n+                     Error_Msg_Sloc := Sloc (Entity);\n+                     Error_Msg_NE (\"\\no value was set for SPARK_Mode on & #\",\n+                                   Arg1, Entity);\n                      raise Pragma_Exit;\n                   end if;\n                end if;\n@@ -18733,7 +18769,10 @@ package body Sem_Prag is\n                   then\n                      Spec_Id := Defining_Entity (Stmt);\n                      Check_Library_Level_Entity (Spec_Id);\n-                     Check_Pragma_Conformance (SPARK_Pragma (Spec_Id));\n+                     Check_Pragma_Conformance\n+                       (Context_Pragma => SPARK_Pragma (Spec_Id),\n+                        Entity_Pragma  => Empty,\n+                        Entity         => Empty);\n \n                      Set_SPARK_Pragma               (Spec_Id, N);\n                      Set_SPARK_Pragma_Inherited     (Spec_Id, False);\n@@ -18748,7 +18787,10 @@ package body Sem_Prag is\n                   then\n                      Spec_Id := Defining_Entity (Stmt);\n                      Check_Library_Level_Entity (Spec_Id);\n-                     Check_Pragma_Conformance (SPARK_Pragma (Spec_Id));\n+                     Check_Pragma_Conformance\n+                       (Context_Pragma => SPARK_Pragma (Spec_Id),\n+                        Entity_Pragma  => Empty,\n+                        Entity         => Empty);\n \n                      Set_SPARK_Pragma               (Spec_Id, N);\n                      Set_SPARK_Pragma_Inherited     (Spec_Id, False);\n@@ -18804,7 +18846,10 @@ package body Sem_Prag is\n \n                   if List_Containing (N) = Private_Declarations (Context) then\n                      Check_Library_Level_Entity (Spec_Id);\n-                     Check_Pragma_Conformance (SPARK_Aux_Pragma (Spec_Id));\n+                     Check_Pragma_Conformance\n+                       (Context_Pragma => Empty,\n+                        Entity_Pragma  => SPARK_Pragma (Spec_Id),\n+                        Entity         => Spec_Id);\n                      SPARK_Mode_Pragma := N;\n                      SPARK_Mode := Mode_Id;\n \n@@ -18815,7 +18860,10 @@ package body Sem_Prag is\n \n                   else\n                      Check_Library_Level_Entity (Spec_Id);\n-                     Check_Pragma_Conformance (SPARK_Pragma (Spec_Id));\n+                     Check_Pragma_Conformance\n+                       (Context_Pragma => SPARK_Pragma (Spec_Id),\n+                        Entity_Pragma  => Empty,\n+                        Entity         => Empty);\n                      SPARK_Mode_Pragma := N;\n                      SPARK_Mode := Mode_Id;\n \n@@ -18834,8 +18882,10 @@ package body Sem_Prag is\n                then\n                   Spec_Id := Defining_Entity (Context);\n                   Check_Library_Level_Entity (Spec_Id);\n-                  Check_Pragma_Conformance (SPARK_Pragma (Spec_Id));\n-\n+                  Check_Pragma_Conformance\n+                    (Context_Pragma => SPARK_Pragma (Spec_Id),\n+                     Entity_Pragma  => Empty,\n+                     Entity         => Empty);\n                   Set_SPARK_Pragma           (Spec_Id, N);\n                   Set_SPARK_Pragma_Inherited (Spec_Id, False);\n \n@@ -18848,7 +18898,10 @@ package body Sem_Prag is\n                   Spec_Id := Corresponding_Spec (Context);\n                   Body_Id := Defining_Entity (Context);\n                   Check_Library_Level_Entity (Body_Id);\n-                  Check_Pragma_Conformance (SPARK_Pragma (Body_Id));\n+                  Check_Pragma_Conformance\n+                    (Context_Pragma => SPARK_Pragma (Body_Id),\n+                     Entity_Pragma  => SPARK_Aux_Pragma (Spec_Id),\n+                     Entity         => Spec_Id);\n                   SPARK_Mode_Pragma := N;\n                   SPARK_Mode := Mode_Id;\n \n@@ -18867,7 +18920,19 @@ package body Sem_Prag is\n                   Context := Specification (Context);\n                   Body_Id := Defining_Entity (Context);\n                   Check_Library_Level_Entity (Body_Id);\n-                  Check_Pragma_Conformance (SPARK_Pragma (Body_Id));\n+\n+                  if Present (Spec_Id) then\n+                     Check_Pragma_Conformance\n+                       (Context_Pragma => SPARK_Pragma (Body_Id),\n+                        Entity_Pragma  => SPARK_Pragma (Spec_Id),\n+                        Entity         => Spec_Id);\n+                  else\n+                     Check_Pragma_Conformance\n+                       (Context_Pragma => SPARK_Pragma (Body_Id),\n+                        Entity_Pragma  => Empty,\n+                        Entity         => Empty);\n+                  end if;\n+\n                   SPARK_Mode_Pragma := N;\n                   SPARK_Mode := Mode_Id;\n \n@@ -18887,7 +18952,10 @@ package body Sem_Prag is\n                   Spec_Id := Corresponding_Spec (Context);\n                   Body_Id := Defining_Entity (Context);\n                   Check_Library_Level_Entity (Body_Id);\n-                  Check_Pragma_Conformance (SPARK_Aux_Pragma (Body_Id));\n+                  Check_Pragma_Conformance\n+                    (Context_Pragma => Empty,\n+                     Entity_Pragma  => SPARK_Pragma (Body_Id),\n+                     Entity         => Body_Id);\n                   SPARK_Mode_Pragma := N;\n                   SPARK_Mode := Mode_Id;\n "}]}