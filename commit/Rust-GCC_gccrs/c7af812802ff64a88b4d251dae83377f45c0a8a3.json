{"sha": "c7af812802ff64a88b4d251dae83377f45c0a8a3", "node_id": "C_kwDOANBUbNoAKGM3YWY4MTI4MDJmZjY0YTg4YjRkMjUxZGFlODMzNzdmNDVjMGE4YTM", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-11-24T18:45:34Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-11-26T09:14:10Z"}, "message": "Support dereference operator overloading\n\nThis adds in support for deref lang-item operator overloads. Deref operator\noverloading is an interesting case of the libcore interaction with the\ncompiler. The deref operator lang item is:\n\n```rust\npub trait Deref {\n    type Target;\n\n    fn deref(&self) -> &Self::Target;\n}\n```\n\nIt has two default impl's one for '&T' and '&mut T' to apply genericly.\nThe reason it is interesting is from the prototype the deref lang item\nalways returns &Self::Target in all cases regardless of mutability, the\nlang item here is designed to wrap up any dereference such that when\napplied it guarentees the type system you will get back an immutable\nreference to something. The reason for doing this is more clear when\nthinking about autoderef and method-resolution and how you apply\ndereference operations to custom types and a test case is included for\nthat.\n\nThe autoderef mechanism will now need to be updated to support drefs fully.\n\nFixes #809", "tree": {"sha": "8996e916a4375af6f33d1a835218a0e1fb003fd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8996e916a4375af6f33d1a835218a0e1fb003fd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7af812802ff64a88b4d251dae83377f45c0a8a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7af812802ff64a88b4d251dae83377f45c0a8a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7af812802ff64a88b4d251dae83377f45c0a8a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7af812802ff64a88b4d251dae83377f45c0a8a3/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b8cbff816c969aa43aca9c611b3c3f9ef5a1af5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b8cbff816c969aa43aca9c611b3c3f9ef5a1af5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b8cbff816c969aa43aca9c611b3c3f9ef5a1af5"}], "stats": {"total": 344, "additions": 321, "deletions": 23}, "files": [{"sha": "6051f50fdc5a57b91c16d97fe9494513b7d10910", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7af812802ff64a88b4d251dae83377f45c0a8a3/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7af812802ff64a88b4d251dae83377f45c0a8a3/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=c7af812802ff64a88b4d251dae83377f45c0a8a3", "patch": "@@ -117,6 +117,43 @@ CompileExpr::visit (HIR::NegationExpr &expr)\n     = ctx->get_backend ()->negation_expression (op, negated_expr, location);\n }\n \n+void\n+CompileExpr::visit (HIR::DereferenceExpr &expr)\n+{\n+  TyTy::BaseType *tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &tyty))\n+    {\n+      rust_fatal_error (expr.get_locus (),\n+\t\t\t\"did not resolve type for this TupleExpr\");\n+      return;\n+    }\n+\n+  tree main_expr = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n+\n+  // this might be an operator overload situation lets check\n+  TyTy::FnType *fntype;\n+  bool is_op_overload = ctx->get_tyctx ()->lookup_operator_overload (\n+    expr.get_mappings ().get_hirid (), &fntype);\n+  if (is_op_overload)\n+    {\n+      auto lang_item_type = Analysis::RustLangItem::ItemType::DEREF;\n+      tree operator_overload_call\n+\t= resolve_operator_overload (lang_item_type, expr, main_expr, nullptr,\n+\t\t\t\t     expr.get_expr ().get (), nullptr);\n+\n+      // rust deref always returns a reference from this overload then we can\n+      // actually do the indirection\n+      main_expr = operator_overload_call;\n+    }\n+\n+  tree expected_type = TyTyResolveCompile::compile (ctx, tyty);\n+  bool known_valid = true;\n+  translated\n+    = ctx->get_backend ()->indirect_expression (expected_type, main_expr,\n+\t\t\t\t\t\tknown_valid, expr.get_locus ());\n+}\n+\n tree\n CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n \t\t\t\t\tTyTy::BaseType *receiver,"}, {"sha": "1e8e1f6183c97ad903bc76c2f48f7c26107b550e", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7af812802ff64a88b4d251dae83377f45c0a8a3/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7af812802ff64a88b4d251dae83377f45c0a8a3/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=c7af812802ff64a88b4d251dae83377f45c0a8a3", "patch": "@@ -979,26 +979,7 @@ class CompileExpr : public HIRCompileBase\n       = ctx->get_backend ()->address_expression (main_expr, expr.get_locus ());\n   }\n \n-  void visit (HIR::DereferenceExpr &expr) override\n-  {\n-    tree main_expr = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n-\n-    TyTy::BaseType *tyty = nullptr;\n-    if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t &tyty))\n-      {\n-\trust_fatal_error (expr.get_locus (),\n-\t\t\t  \"did not resolve type for this TupleExpr\");\n-\treturn;\n-      }\n-\n-    tree expected_type = TyTyResolveCompile::compile (ctx, tyty);\n-    bool known_valid = true;\n-    translated\n-      = ctx->get_backend ()->indirect_expression (expected_type, main_expr,\n-\t\t\t\t\t\t  known_valid,\n-\t\t\t\t\t\t  expr.get_locus ());\n-  }\n+  void visit (HIR::DereferenceExpr &expr) override;\n \n protected:\n   tree compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,"}, {"sha": "1015cc2edc027bcd0490b312b5e02d5147e5b40e", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7af812802ff64a88b4d251dae83377f45c0a8a3/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7af812802ff64a88b4d251dae83377f45c0a8a3/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=c7af812802ff64a88b4d251dae83377f45c0a8a3", "patch": "@@ -1219,6 +1219,18 @@ class TypeCheckExpr : public TypeCheckBase\n     TyTy::BaseType *resolved_base\n       = TypeCheckExpr::Resolve (expr.get_expr ().get (), false);\n \n+    auto lang_item_type = Analysis::RustLangItem::ItemType::DEREF;\n+    bool operator_overloaded\n+      = resolve_operator_overload (lang_item_type, expr, resolved_base,\n+\t\t\t\t   nullptr);\n+    if (operator_overloaded)\n+      {\n+\t// operator overloaded deref always refurns a reference type lets assert\n+\t// this\n+\trust_assert (infered->get_kind () == TyTy::TypeKind::REF);\n+\tresolved_base = infered;\n+      }\n+\n     bool is_valid_type\n       = resolved_base->get_kind () == TyTy::TypeKind::REF\n \t|| resolved_base->get_kind () == TyTy::TypeKind::POINTER;\n@@ -1281,9 +1293,24 @@ class TypeCheckExpr : public TypeCheckBase\n     bool probe_impls = !receiver_is_generic;\n     bool ignore_mandatory_trait_items = !receiver_is_generic;\n \n-    auto candidates = PathProbeType::Probe (\n-      root, HIR::PathIdentSegment (associated_item_name), probe_impls,\n-      probe_bounds, ignore_mandatory_trait_items, respective_lang_item_id);\n+    auto probe_type = probe_impls ? lhs : root;\n+    auto candidates\n+      = PathProbeType::Probe (probe_type,\n+\t\t\t      HIR::PathIdentSegment (associated_item_name),\n+\t\t\t      probe_impls, probe_bounds,\n+\t\t\t      ignore_mandatory_trait_items);\n+    if (candidates.empty ())\n+      {\n+\tif (probe_impls)\n+\t  {\n+\t    candidates = PathProbeType::Probe (\n+\t      root, HIR::PathIdentSegment (associated_item_name), probe_impls,\n+\t      probe_bounds, ignore_mandatory_trait_items);\n+\t  }\n+\n+\tif (candidates.empty ())\n+\t  return false;\n+      }\n \n     // autoderef to find the relevant method\n     std::vector<Adjustment> adjustments;"}, {"sha": "77a4cafb4df6c81566fe34f0315f8967c9300e21", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7af812802ff64a88b4d251dae83377f45c0a8a3/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7af812802ff64a88b4d251dae83377f45c0a8a3/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=c7af812802ff64a88b4d251dae83377f45c0a8a3", "patch": "@@ -51,6 +51,8 @@ class RustLangItem\n     DIV_ASSIGN,\n     REM_ASSIGN,\n \n+    DEREF,\n+\n     UNKNOWN,\n   };\n \n@@ -104,6 +106,10 @@ class RustLangItem\n       {\n \treturn ItemType::REM_ASSIGN;\n       }\n+    else if (item.compare (\"deref\") == 0)\n+      {\n+\treturn ItemType::DEREF;\n+      }\n \n     return ItemType::UNKNOWN;\n   }\n@@ -136,6 +142,8 @@ class RustLangItem\n \treturn \"div_assign\";\n       case REM_ASSIGN:\n \treturn \"rem_assign\";\n+      case DEREF:\n+\treturn \"deref\";\n \n       case UNKNOWN:\n \tbreak;"}, {"sha": "23ae778a3a2bec717c8ee146c2f6c52683d133dd", "filename": "gcc/testsuite/rust/execute/torture/operator_overload_10.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7af812802ff64a88b4d251dae83377f45c0a8a3/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_10.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7af812802ff64a88b4d251dae83377f45c0a8a3/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_10.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_10.rs?ref=c7af812802ff64a88b4d251dae83377f45c0a8a3", "patch": "@@ -0,0 +1,79 @@\n+/* { dg-output \"foo_deref\\n123\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"deref\"]\n+pub trait Deref {\n+    type Target;\n+\n+    fn deref(&self) -> &Self::Target;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .Deref::deref.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+impl<T> Deref for &T {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        unsafe {\n+            let a = \"imm_deref\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+\n+        *self\n+    }\n+}\n+\n+impl<T> Deref for &mut T {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        unsafe {\n+            let a = \"mut_deref\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+\n+        *self\n+    }\n+}\n+\n+struct Foo<T>(T);\n+impl<T> Deref for Foo<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &Self::Target {\n+        unsafe {\n+            let a = \"foo_deref\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+\n+        &self.0\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let foo: Foo<i32> = Foo(123);\n+    let bar: i32 = *foo;\n+\n+    unsafe {\n+        let a = \"%i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, bar);\n+    }\n+\n+    0\n+}"}, {"sha": "6ff3a8711d2fb22bc540baa1134df4abb8e72672", "filename": "gcc/testsuite/rust/execute/torture/operator_overload_7.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7af812802ff64a88b4d251dae83377f45c0a8a3/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_7.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7af812802ff64a88b4d251dae83377f45c0a8a3/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_7.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_7.rs?ref=c7af812802ff64a88b4d251dae83377f45c0a8a3", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-output \"imm_deref\\n123\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"deref\"]\n+pub trait Deref {\n+    type Target;\n+\n+    fn deref(&self) -> &Self::Target;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .Deref::deref.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+impl<T> Deref for &T {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        unsafe {\n+            let a = \"imm_deref\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+\n+        *self\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let foo: &i32 = &123;\n+    let res: i32 = *foo;\n+\n+    unsafe {\n+        let a = \"%i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, res);\n+    }\n+\n+    0\n+}"}, {"sha": "d853d71587408c9c94f2fb7f17308ee70d61d8ce", "filename": "gcc/testsuite/rust/execute/torture/operator_overload_8.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7af812802ff64a88b4d251dae83377f45c0a8a3/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_8.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7af812802ff64a88b4d251dae83377f45c0a8a3/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_8.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_8.rs?ref=c7af812802ff64a88b4d251dae83377f45c0a8a3", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-output \"imm_deref\\n123\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"deref\"]\n+pub trait Deref {\n+    type Target;\n+\n+    fn deref(&self) -> &Self::Target;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .Deref::deref.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+impl<T> Deref for &T {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        unsafe {\n+            let a = \"imm_deref\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+\n+        *self\n+    }\n+}\n+\n+impl<T> Deref for &mut T {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        unsafe {\n+            let a = \"mut_deref\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+\n+        *self\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let foo: &i32 = &123;\n+    let res: i32 = *foo;\n+\n+    unsafe {\n+        let a = \"%i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, res);\n+    }\n+\n+    0\n+}"}, {"sha": "5c770e7a77282e2955a664aa348ad70eaa3aa3f3", "filename": "gcc/testsuite/rust/execute/torture/operator_overload_9.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7af812802ff64a88b4d251dae83377f45c0a8a3/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_9.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7af812802ff64a88b4d251dae83377f45c0a8a3/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_9.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_9.rs?ref=c7af812802ff64a88b4d251dae83377f45c0a8a3", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-output \"mut_deref\\n123\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"deref\"]\n+pub trait Deref {\n+    type Target;\n+\n+    fn deref(&self) -> &Self::Target;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .Deref::deref.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+impl<T> Deref for &T {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        unsafe {\n+            let a = \"imm_deref\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+\n+        *self\n+    }\n+}\n+\n+impl<T> Deref for &mut T {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        unsafe {\n+            let a = \"mut_deref\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+\n+        *self\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let foo = &mut 123;\n+    let res: i32 = *foo;\n+\n+    unsafe {\n+        let a = \"%i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, res);\n+    }\n+\n+    0\n+}"}]}