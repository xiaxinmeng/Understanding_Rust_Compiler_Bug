{"sha": "469b759e8cd3b6e0f8dd25e5099f89533b663310", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY5Yjc1OWU4Y2QzYjZlMGY4ZGQyNWU1MDk5Zjg5NTMzYjY2MzMxMA==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1997-04-24T07:25:19Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1997-04-24T07:25:19Z"}, "message": "Formerly extend.texi.~114~\n\nFrom-SVN: r13976", "tree": {"sha": "de34b39d7eae701af6e70acc5c5996ffd0efdef5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de34b39d7eae701af6e70acc5c5996ffd0efdef5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/469b759e8cd3b6e0f8dd25e5099f89533b663310", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/469b759e8cd3b6e0f8dd25e5099f89533b663310", "html_url": "https://github.com/Rust-GCC/gccrs/commit/469b759e8cd3b6e0f8dd25e5099f89533b663310", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/469b759e8cd3b6e0f8dd25e5099f89533b663310/comments", "author": null, "committer": null, "parents": [{"sha": "9e148ceb90467f15aedd11194a071489810e9c0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e148ceb90467f15aedd11194a071489810e9c0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e148ceb90467f15aedd11194a071489810e9c0f"}], "stats": {"total": 60, "additions": 36, "deletions": 24}, "files": [{"sha": "49a7afc44d8581796678d2fd1ccd54d179826b50", "filename": "gcc/extend.texi", "status": "modified", "additions": 36, "deletions": 24, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/469b759e8cd3b6e0f8dd25e5099f89533b663310/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/469b759e8cd3b6e0f8dd25e5099f89533b663310/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=469b759e8cd3b6e0f8dd25e5099f89533b663310", "patch": "@@ -3183,38 +3183,50 @@ problem, which I will refer to as the Borland model and the Cfront model.\n @table @asis\n @item Borland model\n Borland C++ solved the template instantiation problem by adding the code\n-equivalent of common blocks to their linker; template instances\n-are emitted in each translation unit that uses them, and they are\n-collapsed together at run time.  The advantage of this model is that the\n-linker only has to consider the object files themselves; there is no\n-external complexity to worry about.  This disadvantage is that\n-compilation time is increased because the template code is being\n-compiled repeatedly.  Code written for this model tends to include\n-definitions of all member templates in the header file, since they must\n-be seen to be compiled.\n+equivalent of common blocks to their linker; the compiler emits template\n+instances in each translation unit that uses them, and the linker\n+collapses them together.  The advantage of this model is that the linker\n+only has to consider the object files themselves; there is no external\n+complexity to worry about.  This disadvantage is that compilation time\n+is increased because the template code is being compiled repeatedly.\n+Code written for this model tends to include definitions of all\n+templates in the header file, since they must be seen to be\n+instantiated.\n \n @item Cfront model\n The AT&T C++ translator, Cfront, solved the template instantiation\n problem by creating the notion of a template repository, an\n-automatically maintained place where template instances are stored.  As\n-individual object files are built, notes are placed in the repository to\n-record where templates and potential type arguments were seen so that\n-the subsequent instantiation step knows where to find them.  At link\n-time, any needed instances are generated and linked in.  The advantages\n-of this model are more optimal compilation speed and the ability to use\n-the system linker; to implement the Borland model a compiler vendor also\n+automatically maintained place where template instances are stored.  A\n+more modern version of the repository works as follows: As individual\n+object files are built, the compiler places any template definitions and\n+instantiations encountered in the repository.  At link time, the link\n+wrapper adds in the objects in the repository and compiles any needed\n+instances that were not previously emitted.  The advantages of this\n+model are more optimal compilation speed and the ability to use the\n+system linker; to implement the Borland model a compiler vendor also\n needs to replace the linker.  The disadvantages are vastly increased\n-complexity, and thus potential for error; theoretically, this should be\n-just as transparent, but in practice it has been very difficult to build\n+complexity, and thus potential for error; for some code this can be\n+just as transparent, but in practice it can been very difficult to build\n multiple programs in one directory and one program in multiple\n-directories using Cfront.  Code written for this model tends to separate\n-definitions of non-inline member templates into a separate file, which\n-is magically found by the link preprocessor when a template needs to be\n-instantiated.\n+directories.  Code written for this model tends to separate definitions\n+of non-inline member templates into a separate file, which should be\n+compiled separately.\n @end table\n \n-Currently, g++ implements neither automatic model.  In the mean time,\n-you have three options for dealing with template instantiations:\n+When used with GNU ld version 2.8 or later on an ELF system such as\n+GNU/Linux or Solaris 2, g++ supports the Borland model.  On other systems,\n+g++ implements neither automatic model.\n+\n+A future version of g++ will support a hybrid model whereby the compiler\n+will emit any instantiations for which the template definition is\n+included in the compile, and store template definitions and\n+instantiation context information into the object file for the rest.\n+The link wrapper will extract that information as necessary and invoke\n+the compiler to produce the remaining instantiations.  The linker will\n+then combine duplicate instantiations.\n+\n+In the mean time, you have the following options for dealing with\n+template instantiations:\n \n @enumerate\n @item"}]}