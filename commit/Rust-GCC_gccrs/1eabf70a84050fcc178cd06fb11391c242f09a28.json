{"sha": "1eabf70a84050fcc178cd06fb11391c242f09a28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVhYmY3MGE4NDA1MGZjYzE3OGNkMDZmYjExMzkxYzI0MmYwOWEyOA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2007-11-30T12:16:35Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2007-11-30T12:16:35Z"}, "message": "re PR fortran/34133 (Bind(c,name=\"\") should be rejected for dummies; F2008: allow bind(c) for internal procs)\n\n2007-11-20  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/34133\n        * match.h: Add bool allow_binding_name to gfc_match_bind_c.\n        * decl.c\n        * (match_attr_spec,gfc_match_bind_c_stmt,gfc_match_entry):\n        Adjust accordingly.\n        (gfc_match_bind_c): Add allow_binding_name argument, reject\n        binding name for dummy arguments.\n        (gfc_match_suffix,gfc_match_subroutine): Make use of\n        allow_binding_name.\n\n2007-11-20  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/34133\n        * gfortran.dg/bind_c_usage_9.f03: Fixes; add -std=f2003.\n        * gfortran.dg/bind_c_usage_11.f03: New.\n        * gfortran.dg/bind_c_usage_12.f03: New.\n\nFrom-SVN: r130535", "tree": {"sha": "d4f2c1d1ab74a0ce0f88e31dc99507d1e23dfbd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4f2c1d1ab74a0ce0f88e31dc99507d1e23dfbd5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1eabf70a84050fcc178cd06fb11391c242f09a28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eabf70a84050fcc178cd06fb11391c242f09a28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eabf70a84050fcc178cd06fb11391c242f09a28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eabf70a84050fcc178cd06fb11391c242f09a28/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e6ef7325b82cf4fd0fd431deada1b37e29542230", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6ef7325b82cf4fd0fd431deada1b37e29542230", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6ef7325b82cf4fd0fd431deada1b37e29542230"}], "stats": {"total": 232, "additions": 199, "deletions": 33}, "files": [{"sha": "564b7382a8777709f785bdda88e02b2794651f53", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eabf70a84050fcc178cd06fb11391c242f09a28/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eabf70a84050fcc178cd06fb11391c242f09a28/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1eabf70a84050fcc178cd06fb11391c242f09a28", "patch": "@@ -1,3 +1,14 @@\n+2007-11-30  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/34133\n+\t* match.h: Add bool allow_binding_name to gfc_match_bind_c.\n+\t* decl.c (match_attr_spec,gfc_match_bind_c_stmt,gfc_match_entry):\n+\tAdjust accordingly.\n+\t(gfc_match_bind_c): Add allow_binding_name argument, reject\n+\tbinding name for dummy arguments.\n+\t(gfc_match_suffix,gfc_match_subroutine): Make use of\n+\tallow_binding_name.\n+\n 2007-11-30  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/34186"}, {"sha": "e9b7651c534a3ab8cf952fa1c95ef7475cc2b450", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 62, "deletions": 29, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eabf70a84050fcc178cd06fb11391c242f09a28/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eabf70a84050fcc178cd06fb11391c242f09a28/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=1eabf70a84050fcc178cd06fb11391c242f09a28", "patch": "@@ -2720,7 +2720,7 @@ match_attr_spec (void)\n \n \t    case 'b':\n \t      /* Try and match the bind(c).  */\n-\t      m = gfc_match_bind_c (NULL);\n+\t      m = gfc_match_bind_c (NULL, true);\n \t      if (m == MATCH_YES)\n \t\td = DECL_IS_BIND_C;\n \t      else if (m == MATCH_ERROR)\n@@ -3508,7 +3508,7 @@ gfc_match_bind_c_stmt (void)\n   curr_binding_label[0] = '\\0';\n \n   /* Look for the bind(c).  */\n-  found_match = gfc_match_bind_c (NULL);\n+  found_match = gfc_match_bind_c (NULL, true);\n \n   if (found_match == MATCH_YES)\n     {\n@@ -3870,6 +3870,7 @@ gfc_match_suffix (gfc_symbol *sym, gfc_symbol **result)\n   match is_result;   /* Found result clause.  */\n   match found_match; /* Status of whether we've found a good match.  */\n   int peek_char;     /* Character we're going to peek at.  */\n+  bool allow_binding_name;\n \n   /* Initialize to having found nothing.  */\n   found_match = MATCH_NO;\n@@ -3880,6 +3881,13 @@ gfc_match_suffix (gfc_symbol *sym, gfc_symbol **result)\n   gfc_gobble_whitespace ();\n   peek_char = gfc_peek_char ();\n \n+  /* C binding names are not allowed for internal procedures.  */\n+  if (gfc_current_state () == COMP_CONTAINS\n+      && sym->ns->proc_name->attr.flavor != FL_MODULE)\n+    allow_binding_name = false;\n+  else\n+    allow_binding_name = true;\n+\n   switch (peek_char)\n     {\n     case 'r':\n@@ -3888,7 +3896,7 @@ gfc_match_suffix (gfc_symbol *sym, gfc_symbol **result)\n       if (is_result == MATCH_YES)\n \t{\n \t  /* Now see if there is a bind(c) after it.  */\n-\t  is_bind_c = gfc_match_bind_c (sym);\n+\t  is_bind_c = gfc_match_bind_c (sym, allow_binding_name);\n \t  /* We've found the result clause and possibly bind(c).  */\n \t  found_match = MATCH_YES;\n \t}\n@@ -3898,7 +3906,7 @@ gfc_match_suffix (gfc_symbol *sym, gfc_symbol **result)\n       break;\n     case 'b':\n       /* Look for bind(c) first.  */\n-      is_bind_c = gfc_match_bind_c (sym);\n+      is_bind_c = gfc_match_bind_c (sym, allow_binding_name);\n       if (is_bind_c == MATCH_YES)\n \t{\n \t  /* Now see if a result clause followed it.  */\n@@ -3919,13 +3927,15 @@ gfc_match_suffix (gfc_symbol *sym, gfc_symbol **result)\n \n   if (is_bind_c == MATCH_YES)\n     {\n+      /* Fortran 2008 draft allows BIND(C) for internal procedures.  */\n       if (gfc_current_state () == COMP_CONTAINS\n-\t  && sym->ns->proc_name->attr.flavor != FL_MODULE)\n-\t{\n-          gfc_error (\"BIND(C) attribute at %L may not be specified for an \"\n-\t\t     \"internal procedure\", &gfc_current_locus);\n-\t  return MATCH_ERROR;\n-\t}\n+\t  && sym->ns->proc_name->attr.flavor != FL_MODULE\n+\t  && gfc_notify_std (GFC_STD_GNU, \"Extension: BIND(C) attribute at %L \"\n+\t\t\t     \"may not be specified for an internal procedure\",\n+\t\t\t     &gfc_current_locus)\n+\t     == FAILURE)\n+\treturn MATCH_ERROR;\n+\n       if (gfc_add_is_bind_c (&(sym->attr), sym->name, &gfc_current_locus, 1)\n \t  == FAILURE)\n      \treturn MATCH_ERROR;\n@@ -4453,7 +4463,9 @@ gfc_match_entry (void)\n       if (m != MATCH_YES)\n \treturn MATCH_ERROR;\n \n-      is_bind_c = gfc_match_bind_c (entry);\n+      /* Call gfc_match_bind_c with allow_binding_name = true as ENTRY can\n+\t never be an internal procedure.  */\n+      is_bind_c = gfc_match_bind_c (entry, true);\n       if (is_bind_c == MATCH_ERROR)\n \treturn MATCH_ERROR;\n       if (is_bind_c == MATCH_YES)\n@@ -4573,6 +4585,7 @@ gfc_match_subroutine (void)\n   match m;\n   match is_bind_c;\n   char peek_char;\n+  bool allow_binding_name;\n \n   if (gfc_current_state () != COMP_NONE\n       && gfc_current_state () != COMP_INTERFACE\n@@ -4616,11 +4629,18 @@ gfc_match_subroutine (void)\n         gfc_error_now (\"BIND(C) attribute at %L can only be used for \"\n                        \"variables or common blocks\", &gfc_current_locus);\n     }\n-  \n+\n+  /* C binding names are not allowed for internal procedures.  */\n+  if (gfc_current_state () == COMP_CONTAINS\n+      && sym->ns->proc_name->attr.flavor != FL_MODULE)\n+    allow_binding_name = false;\n+  else\n+    allow_binding_name = true;\n+\n   /* Here, we are just checking if it has the bind(c) attribute, and if\n      so, then we need to make sure it's all correct.  If it doesn't,\n      we still need to continue matching the rest of the subroutine line.  */\n-  is_bind_c = gfc_match_bind_c (sym);\n+  is_bind_c = gfc_match_bind_c (sym, allow_binding_name);\n   if (is_bind_c == MATCH_ERROR)\n     {\n       /* There was an attempt at the bind(c), but it was wrong.\t An\n@@ -4631,13 +4651,15 @@ gfc_match_subroutine (void)\n \n   if (is_bind_c == MATCH_YES)\n     {\n+      /* The following is allowed in the Fortran 2008 draft.  */\n       if (gfc_current_state () == COMP_CONTAINS\n-\t  && sym->ns->proc_name->attr.flavor != FL_MODULE)\n-\t{\n-          gfc_error (\"BIND(C) attribute at %L may not be specified for an \"\n-\t\t     \"internal procedure\", &gfc_current_locus);\n-\t  return MATCH_ERROR;\n-\t}\n+\t  && sym->ns->proc_name->attr.flavor != FL_MODULE\n+\t  && gfc_notify_std (GFC_STD_GNU, \"Extension: BIND(C) attribute at \"\n+\t\t\t     \"%L may not be specified for an internal procedure\",\n+\t\t\t     &gfc_current_locus)\n+\t     == FAILURE)\n+\treturn MATCH_ERROR;\n+\n       if (peek_char != '(')\n         {\n           gfc_error (\"Missing required parentheses before BIND(C) at %C\");\n@@ -4669,10 +4691,11 @@ gfc_match_subroutine (void)\n    MATCH_ERROR if it is a BIND(C) clause but an error was encountered,\n    or MATCH_YES if the specifier was correct and the binding label and\n    bind(c) fields were set correctly for the given symbol or the\n-   current_ts.  */\n+   current_ts. If allow_binding_name is false, no binding name may be\n+   given.  */\n \n match\n-gfc_match_bind_c (gfc_symbol *sym)\n+gfc_match_bind_c (gfc_symbol *sym, bool allow_binding_name)\n {\n   /* binding label, if exists */   \n   char binding_label[GFC_MAX_SYMBOL_LEN + 1];\n@@ -4752,6 +4775,20 @@ gfc_match_bind_c (gfc_symbol *sym)\n       return MATCH_ERROR;\n     }\n \n+  if (has_name_equals && !allow_binding_name)\n+    {\n+      gfc_error (\"No binding name is allowed in BIND(C) at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  if (has_name_equals && sym != NULL && sym->attr.dummy)\n+    {\n+      gfc_error (\"For dummy procedure %s, no binding name is \"\n+\t\t \"allowed in BIND(C) at %C\", sym->name);\n+      return MATCH_ERROR;\n+    }\n+\n+\n   /* Save the binding label to the symbol.  If sym is null, we're\n      probably matching the typespec attributes of a declaration and\n      haven't gotten the name yet, and therefore, no symbol yet.\t */\n@@ -4764,16 +4801,12 @@ gfc_match_bind_c (gfc_symbol *sym)\n       else\n \tstrcpy (curr_binding_label, binding_label);\n     }\n-  else\n+  else if (allow_binding_name)\n     {\n       /* No binding label, but if symbol isn't null, we\n-\t can set the label for it here.\t */\n-      /* TODO: If the name= was given and no binding label (name=\"\"), we simply\n-         will let fortran mangle the symbol name as it usually would.\n-         However, this could still let C call it if the user looked up the\n-         symbol in the object file.  Should the name set during mangling in\n-         trans-decl.c be marked with characters that are invalid for C to\n-         prevent this?  */\n+\t can set the label for it here.\n+\t If name=\"\" or allow_binding_name is false, no C binding name is\n+\t created. */\n       if (sym != NULL && sym->name != NULL && has_name_equals == 0)\n \tstrncpy (sym->binding_label, sym->name, strlen (sym->name) + 1);\n     }"}, {"sha": "5c4053cc7ecfebaf3afd6d785c28f49d06c00964", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eabf70a84050fcc178cd06fb11391c242f09a28/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eabf70a84050fcc178cd06fb11391c242f09a28/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=1eabf70a84050fcc178cd06fb11391c242f09a28", "patch": "@@ -175,7 +175,7 @@ try set_verify_bind_c_com_block (gfc_common_head *, int);\n try get_bind_c_idents (void);\n match gfc_match_bind_c_stmt (void);\n match gfc_match_suffix (gfc_symbol *, gfc_symbol **);\n-match gfc_match_bind_c (gfc_symbol *);\n+match gfc_match_bind_c (gfc_symbol *, bool);\n match gfc_get_type_attr_spec (symbol_attribute *);\n \n /* primary.c.  */"}, {"sha": "309fdecd19ee9c97e5fc0e1969ae3046ff2b82ee", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eabf70a84050fcc178cd06fb11391c242f09a28/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eabf70a84050fcc178cd06fb11391c242f09a28/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1eabf70a84050fcc178cd06fb11391c242f09a28", "patch": "@@ -1,3 +1,10 @@\n+2007-11-30  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/34133\n+\t* gfortran.dg/bind_c_usage_9.f03: Fixes; add -std=f2003.\n+\t* gfortran.dg/bind_c_usage_11.f03: New.\n+\t* gfortran.dg/bind_c_usage_12.f03: New.\n+\n 2007-11-30  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/34275"}, {"sha": "466b71e7029df87a1e2de58609be748c252572f8", "filename": "gcc/testsuite/gfortran.dg/bind_c_usage_11.f03", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eabf70a84050fcc178cd06fb11391c242f09a28/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_11.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eabf70a84050fcc178cd06fb11391c242f09a28/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_11.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_11.f03?ref=1eabf70a84050fcc178cd06fb11391c242f09a28", "patch": "@@ -0,0 +1,50 @@\n+! { dg-do compile }\n+! { dg-options \"-std=gnu\" }\n+! PR fortran/34133\n+!\n+! The compiler should accept internal procedures with BIND(c) attribute\n+! for STD GNU / Fortran 2008.\n+!\n+subroutine foo() bind(c)\n+contains\n+  subroutine bar() bind (c)\n+  end subroutine bar\n+end subroutine foo\n+\n+subroutine foo2() bind(c)\n+  use iso_c_binding\n+contains\n+  integer(c_int) function barbar() bind (c)\n+    barbar = 1\n+  end function barbar\n+end subroutine foo2\n+\n+function one() bind(c)\n+  use iso_c_binding\n+  integer(c_int) :: one\n+  one = 1\n+contains\n+  integer(c_int) function two() bind (c)\n+    two = 1\n+  end function two\n+end function one\n+\n+function one2() bind(c)\n+  use iso_c_binding\n+  integer(c_int) :: one2\n+  one2 = 1\n+contains\n+  subroutine three() bind (c)\n+  end subroutine three\n+end function one2\n+\n+program main\n+  use iso_c_binding\n+  implicit none\n+contains\n+  subroutine test() bind(c)\n+  end subroutine test\n+  integer(c_int) function test2() bind (c)\n+    test2 = 1\n+  end function test2\n+end program main"}, {"sha": "8519c664ec843023fe7c3f6f3f568d9aa06583bb", "filename": "gcc/testsuite/gfortran.dg/bind_c_usage_12.f03", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eabf70a84050fcc178cd06fb11391c242f09a28/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_12.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eabf70a84050fcc178cd06fb11391c242f09a28/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_12.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_12.f03?ref=1eabf70a84050fcc178cd06fb11391c242f09a28", "patch": "@@ -0,0 +1,63 @@\n+! { dg-do compile }\n+! { dg-options \"-std=gnu\" }\n+! PR fortran/34133\n+!\n+! bind(C,name=\"...\") is invalid for dummy procedures\n+! and for internal procedures.\n+!\n+subroutine dummy1(a,b)\n+!  implicit none\n+  interface\n+    function b() bind(c,name=\"jakl\") ! { dg-error \"no binding name is allowed\" }\n+!     use iso_c_binding\n+!     integer(c_int) :: b       \n+    end function b ! { dg-error \"Expecting END INTERFACE\" }\n+  end interface\n+  interface\n+    subroutine a() bind(c,name=\"\") ! { dg-error \"no binding name is allowed\" }\n+    end subroutine a ! { dg-error \"Expecting END INTERFACE\" }\n+  end interface\n+end subroutine dummy1\n+\n+subroutine internal()\n+  implicit none\n+contains\n+  subroutine int1() bind(c, name=\"jj\") ! { dg-error \"No binding name is allowed\" }\n+  end subroutine int1 ! { dg-error \"Expected label\" }\n+end subroutine internal\n+\n+subroutine internal1()\n+  use iso_c_binding\n+  implicit none\n+contains\n+  integer(c_int) function int2() bind(c, name=\"jjj\") ! { dg-error \"No binding name is allowed\" }\n+  end function int2 ! { dg-error \"Expecting END SUBROUTINE\" }\n+end subroutine internal1\n+\n+integer(c_int) function internal2()\n+  use iso_c_binding\n+  implicit none\n+  internal2 = 0\n+contains\n+  subroutine int1() bind(c, name=\"kk\") ! { dg-error \"No binding name is allowed\" }\n+  end subroutine int1 ! { dg-error \"Expecting END FUNCTION\" }\n+end function internal2\n+\n+integer(c_int) function internal3()\n+  use iso_c_binding\n+  implicit none\n+  internal3 = 0\n+contains\n+  integer(c_int) function int2() bind(c, name=\"kkk\") ! { dg-error \"No binding name is allowed\" }\n+  end function int2 ! { dg-error \"Expected label\" }\n+end function internal3\n+\n+program internal_prog\n+  use iso_c_binding\n+  implicit none\n+contains\n+  subroutine int1() bind(c, name=\"mm\") ! { dg-error \"No binding name is allowed\" }\n+  end subroutine int1 ! { dg-error \"Expecting END PROGRAM statement\" }\n+  integer(c_int) function int2() bind(c, name=\"mmm\") ! { dg-error \"No binding name is allowed\" }\n+  end function int2 ! { dg-error \"Expecting END PROGRAM statement\" } \n+end program"}, {"sha": "0ab782e8c6a7c38cbdba921e6f6e4e0c87ba3169", "filename": "gcc/testsuite/gfortran.dg/bind_c_usage_9.f03", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eabf70a84050fcc178cd06fb11391c242f09a28/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_9.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eabf70a84050fcc178cd06fb11391c242f09a28/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_9.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_9.f03?ref=1eabf70a84050fcc178cd06fb11391c242f09a28", "patch": "@@ -1,7 +1,9 @@\n ! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n ! PR fortran/34133\n !\n-! The compiler should reject internal procedures with BIND(c) attribute.\n+! The compiler should reject internal procedures with BIND(c) attribute\n+! for Fortran 2003.\n !\n subroutine foo() bind(c)\n contains\n@@ -31,7 +33,7 @@ function one2() bind(c)\n   one2 = 1\n contains\n   subroutine three() bind (c) ! { dg-error \"may not be specified for an internal\" }\n-  end function three ! { dg-error \"Expected label\" }\n+  end subroutine three ! { dg-error \"Expecting END FUNCTION statement\" }\n end function one2 ! { dg-warning \"Extension: CONTAINS statement\" }\n \n program main\n@@ -40,6 +42,6 @@ program main\n contains\n   subroutine test() bind(c) ! { dg-error \"may not be specified for an internal\" }\n   end subroutine test ! { dg-error \"Expecting END PROGRAM\" }\n-  function test2() bind (c) ! { dg-error \"may not be specified for an internal\" }\n+  integer(c_int) function test2() bind (c) ! { dg-error \"may not be specified for an internal\" }\n   end function test2  ! { dg-error \"Expecting END PROGRAM\" }\n end program main ! { dg-warning \"Extension: CONTAINS statement\" }"}]}