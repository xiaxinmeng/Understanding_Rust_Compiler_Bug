{"sha": "1c4d457e82695db889b52f62e4d45dec83e1d7f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWM0ZDQ1N2U4MjY5NWRiODg5YjUyZjYyZTRkNDVkZWM4M2UxZDdmMQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-08-08T18:10:54Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-08-08T18:10:54Z"}, "message": "c-format.c: cleanup of check_format_info_main\n\ngcc/c-family/ChangeLog:\n\t* c-format.c (class flag_chars_t): New class.\n\t(struct length_modifier): New struct.\n\t(class argument_parser): New class.\n\t(flag_chars_t::flag_chars_t): New ctor.\n\t(flag_chars_t::has_char_p): New method.\n\t(flag_chars_t::add_char): New method.\n\t(flag_chars_t::validate): New method.\n\t(flag_chars_t::get_alloc_flag): New method.\n\t(flag_chars_t::assignment_suppression_p): New method.\n\t(argument_parser::argument_parser): New ctor.\n\t(argument_parser::read_any_dollar): New method.\n\t(argument_parser::read_format_flags): New method.\n\t(argument_parser::read_any_format_width): New method.\n\t(argument_parser::read_any_format_left_precision): New method.\n\t(argument_parser::read_any_format_precision): New method.\n\t(argument_parser::handle_alloc_chars): New method.\n\t(argument_parser::read_any_length_modifier): New method.\n\t(argument_parser::read_any_other_modifier): New method.\n\t(argument_parser::find_format_char_info): New method.\n\t(argument_parser::validate_flag_pairs): New method.\n\t(argument_parser::give_y2k_warnings): New method.\n\t(argument_parser::parse_any_scan_set): New method.\n\t(argument_parser::handle_conversions): New method.\n\t(argument_parser::check_argument_type): New method.\n\t(check_format_info_main): Introduce classes argument_parser\n\tand flag_chars_t, moving the code within the loop into methods\n\tof these classes.  Make various locals \"const\".\n\nFrom-SVN: r239247", "tree": {"sha": "663ab8e6b537e7e88f55ea4ae185dac2a4da75c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/663ab8e6b537e7e88f55ea4ae185dac2a4da75c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c4d457e82695db889b52f62e4d45dec83e1d7f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c4d457e82695db889b52f62e4d45dec83e1d7f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c4d457e82695db889b52f62e4d45dec83e1d7f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c4d457e82695db889b52f62e4d45dec83e1d7f1/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "66c3dd8c1b53072d64bcbee48a4aec4d10612356", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66c3dd8c1b53072d64bcbee48a4aec4d10612356", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66c3dd8c1b53072d64bcbee48a4aec4d10612356"}], "stats": {"total": 1685, "additions": 1049, "deletions": 636}, "files": [{"sha": "4374dbfb1b407b5ab5496dd06af41e1a17553a8b", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c4d457e82695db889b52f62e4d45dec83e1d7f1/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c4d457e82695db889b52f62e4d45dec83e1d7f1/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=1c4d457e82695db889b52f62e4d45dec83e1d7f1", "patch": "@@ -1,3 +1,33 @@\n+2016-08-08  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-format.c (class flag_chars_t): New class.\n+\t(struct length_modifier): New struct.\n+\t(class argument_parser): New class.\n+\t(flag_chars_t::flag_chars_t): New ctor.\n+\t(flag_chars_t::has_char_p): New method.\n+\t(flag_chars_t::add_char): New method.\n+\t(flag_chars_t::validate): New method.\n+\t(flag_chars_t::get_alloc_flag): New method.\n+\t(flag_chars_t::assignment_suppression_p): New method.\n+\t(argument_parser::argument_parser): New ctor.\n+\t(argument_parser::read_any_dollar): New method.\n+\t(argument_parser::read_format_flags): New method.\n+\t(argument_parser::read_any_format_width): New method.\n+\t(argument_parser::read_any_format_left_precision): New method.\n+\t(argument_parser::read_any_format_precision): New method.\n+\t(argument_parser::handle_alloc_chars): New method.\n+\t(argument_parser::read_any_length_modifier): New method.\n+\t(argument_parser::read_any_other_modifier): New method.\n+\t(argument_parser::find_format_char_info): New method.\n+\t(argument_parser::validate_flag_pairs): New method.\n+\t(argument_parser::give_y2k_warnings): New method.\n+\t(argument_parser::parse_any_scan_set): New method.\n+\t(argument_parser::handle_conversions): New method.\n+\t(argument_parser::check_argument_type): New method.\n+\t(check_format_info_main): Introduce classes argument_parser\n+\tand flag_chars_t, moving the code within the loop into methods\n+\tof these classes.  Make various locals \"const\".\n+\n 2016-08-05  David Malcolm  <dmalcolm@redhat.com>\n \n \t* c-common.c: Include \"substring-locations.h\"."}, {"sha": "92d2c1cf5bea9895331ac6e39063545f19789582", "filename": "gcc/c-family/c-format.c", "status": "modified", "additions": 1019, "deletions": 636, "changes": 1655, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c4d457e82695db889b52f62e4d45dec83e1d7f1/gcc%2Fc-family%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c4d457e82695db889b52f62e4d45dec83e1d7f1/gcc%2Fc-family%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.c?ref=1c4d457e82695db889b52f62e4d45dec83e1d7f1", "patch": "@@ -1688,740 +1688,1123 @@ check_format_arg (void *ctx, tree format_tree,\n \t\t\t  params, arg_num, fwt_pool);\n }\n \n+/* Support class for argument_parser and check_format_info_main.\n+   Tracks any flag characters that have been applied to the\n+   current argument.  */\n \n-/* Do the main part of checking a call to a format function.  FORMAT_CHARS\n-   is the NUL-terminated format string (which at this point may contain\n-   internal NUL characters); FORMAT_LENGTH is its length (excluding the\n-   terminating NUL character).  ARG_NUM is one less than the number of\n-   the first format argument to check; PARAMS points to that format\n-   argument in the list of arguments.  */\n+class flag_chars_t\n+{\n+ public:\n+  flag_chars_t ();\n+  bool has_char_p (char ch) const;\n+  void add_char (char ch);\n+  void validate (const format_kind_info *fki,\n+\t\t const format_char_info *fci,\n+\t\t const format_flag_spec *flag_specs,\n+\t\t const char * const format_chars,\n+\t\t location_t format_string_loc,\n+\t\t const char * const orig_format_chars,\n+\t\t char format_char);\n+  int get_alloc_flag (const format_kind_info *fki);\n+  int assignment_suppression_p (const format_kind_info *fki);\n+\n+ private:\n+  char m_flag_chars[256];\n+};\n \n-static void\n-check_format_info_main (format_check_results *res,\n-\t\t\tfunction_format_info *info, const char *format_chars,\n-\t\t\tint format_length, tree params,\n-\t\t\tunsigned HOST_WIDE_INT arg_num,\n-\t\t\tobject_allocator <format_wanted_type> &fwt_pool)\n+/* Support struct for argument_parser and check_format_info_main.\n+   Encapsulates any length modifier applied to the current argument.  */\n+\n+struct length_modifier\n {\n-  const char *orig_format_chars = format_chars;\n-  tree first_fillin_param = params;\n+  length_modifier ()\n+  : chars (NULL), val (FMT_LEN_none), std (STD_C89),\n+    scalar_identity_flag (0)\n+  {\n+  }\n \n-  const format_kind_info *fki = &format_types[info->format_type];\n-  const format_flag_spec *flag_specs = fki->flag_specs;\n-  const format_flag_pair *bad_flag_pairs = fki->bad_flag_pairs;\n-  location_t format_string_loc = res->format_string_loc;\n+  length_modifier (const char *chars_,\n+\t\t   enum format_lengths val_,\n+\t\t   enum format_std_version std_,\n+\t\t   int scalar_identity_flag_)\n+  : chars (chars_), val (val_), std (std_),\n+    scalar_identity_flag (scalar_identity_flag_)\n+  {\n+  }\n \n-  /* -1 if no conversions taking an operand have been found; 0 if one has\n-     and it didn't use $; 1 if $ formats are in use.  */\n-  int has_operand_number = -1;\n+  const char *chars;\n+  enum format_lengths val;\n+  enum format_std_version std;\n+  int scalar_identity_flag;\n+};\n \n-  init_dollar_format_checking (info->first_arg_num, first_fillin_param);\n+/* Parsing one argument within a format string.  */\n \n-  while (*format_chars != 0)\n-    {\n-      int i;\n-      int suppressed = FALSE;\n-      const char *length_chars = NULL;\n-      enum format_lengths length_chars_val = FMT_LEN_none;\n-      enum format_std_version length_chars_std = STD_C89;\n-      int format_char;\n-      tree cur_param;\n-      tree wanted_type;\n-      int main_arg_num = 0;\n-      tree main_arg_params = 0;\n-      enum format_std_version wanted_type_std;\n-      const char *wanted_type_name;\n-      format_wanted_type width_wanted_type;\n-      format_wanted_type precision_wanted_type;\n-      format_wanted_type main_wanted_type;\n-      format_wanted_type *first_wanted_type = NULL;\n-      format_wanted_type *last_wanted_type = NULL;\n-      const format_length_info *fli = NULL;\n-      const format_char_info *fci = NULL;\n-      char flag_chars[256];\n-      int alloc_flag = 0;\n-      int scalar_identity_flag = 0;\n-      const char *format_start;\n+class argument_parser\n+{\n+ public:\n+  argument_parser (function_format_info *info, const char *&format_chars,\n+\t\t   const char * const orig_format_chars,\n+\t\t   location_t format_string_loc, flag_chars_t &flag_chars,\n+\t\t   int &has_operand_number, tree first_fillin_param,\n+\t\t   object_allocator <format_wanted_type> &fwt_pool_);\n+\n+  bool read_any_dollar ();\n+\n+  bool read_format_flags ();\n+\n+  bool\n+  read_any_format_width (tree &params,\n+\t\t\t unsigned HOST_WIDE_INT &arg_num);\n+\n+  void\n+  read_any_format_left_precision ();\n+\n+  bool\n+  read_any_format_precision (tree &params,\n+\t\t\t     unsigned HOST_WIDE_INT &arg_num);\n+\n+  void handle_alloc_chars ();\n+\n+  length_modifier read_any_length_modifier ();\n+\n+  void read_any_other_modifier ();\n+\n+  const format_char_info *find_format_char_info (char format_char);\n+\n+  void\n+  validate_flag_pairs (const format_char_info *fci,\n+\t\t       char format_char);\n+\n+  void\n+  give_y2k_warnings (const format_char_info *fci,\n+\t\t     char format_char);\n+\n+  void parse_any_scan_set (const format_char_info *fci);\n+\n+  bool handle_conversions (const format_char_info *fci,\n+\t\t\t   const length_modifier &len_modifier,\n+\t\t\t   tree &wanted_type,\n+\t\t\t   const char *&wanted_type_name,\n+\t\t\t   unsigned HOST_WIDE_INT &arg_num,\n+\t\t\t   tree &params,\n+\t\t\t   char format_char);\n+\n+  bool\n+  check_argument_type (const format_char_info *fci,\n+\t\t       const length_modifier &len_modifier,\n+\t\t       tree &wanted_type,\n+\t\t       const char *&wanted_type_name,\n+\t\t       const bool suppressed,\n+\t\t       unsigned HOST_WIDE_INT &arg_num,\n+\t\t       tree &params,\n+\t\t       const int alloc_flag,\n+\t\t       const char * const format_start);\n+\n+ private:\n+  const function_format_info *const info;\n+  const format_kind_info * const fki;\n+  const format_flag_spec * const flag_specs;\n+  const char *&format_chars;\n+  const char * const orig_format_chars;\n+  const location_t format_string_loc;\n+  object_allocator <format_wanted_type> &fwt_pool;\n+  flag_chars_t &flag_chars;\n+  int main_arg_num;\n+  tree main_arg_params;\n+  int &has_operand_number;\n+  const tree first_fillin_param;\n+  format_wanted_type width_wanted_type;\n+  format_wanted_type precision_wanted_type;\n+ public:\n+  format_wanted_type main_wanted_type;\n+ private:\n+  format_wanted_type *first_wanted_type;\n+  format_wanted_type *last_wanted_type;\n+};\n \n-      if (*format_chars++ != '%')\n+/* flag_chars_t's constructor.  */\n+\n+flag_chars_t::flag_chars_t ()\n+{\n+  m_flag_chars[0] = 0;\n+}\n+\n+/* Has CH been seen as a flag within the current argument?  */\n+\n+bool\n+flag_chars_t::has_char_p (char ch) const\n+{\n+  return strchr (m_flag_chars, ch) != 0;\n+}\n+\n+/* Add CH to the flags seen within the current argument.  */\n+\n+void\n+flag_chars_t::add_char (char ch)\n+{\n+  int i = strlen (m_flag_chars);\n+  m_flag_chars[i++] = ch;\n+  m_flag_chars[i] = 0;\n+}\n+\n+/* Validate the individual flags used, removing any that are invalid.  */\n+\n+void\n+flag_chars_t::validate (const format_kind_info *fki,\n+\t\t\tconst format_char_info *fci,\n+\t\t\tconst format_flag_spec *flag_specs,\n+\t\t\tconst char * const format_chars,\n+\t\t\tlocation_t format_string_loc,\n+\t\t\tconst char * const orig_format_chars,\n+\t\t\tchar format_char)\n+{\n+  int i;\n+  int d = 0;\n+  for (i = 0; m_flag_chars[i] != 0; i++)\n+    {\n+      const format_flag_spec *s = get_flag_spec (flag_specs,\n+\t\t\t\t\t\t m_flag_chars[i], NULL);\n+      m_flag_chars[i - d] = m_flag_chars[i];\n+      if (m_flag_chars[i] == fki->length_code_char)\n \tcontinue;\n-      if (*format_chars == 0)\n+      if (strchr (fci->flag_chars, m_flag_chars[i]) == 0)\n \t{\n-          warning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\t    format_chars - orig_format_chars),\n-\t\t      OPT_Wformat_,\n-\t\t      \"spurious trailing %<%%%> in format\");\n+\t  warning_at (location_from_offset (format_string_loc,\n+\t\t\t\t\t    format_chars\n+\t\t\t\t\t    - orig_format_chars),\n+\t\t      OPT_Wformat_, \"%s used with %<%%%c%> %s format\",\n+\t\t      _(s->name), format_char, fki->name);\n+\t  d++;\n \t  continue;\n \t}\n-      if (*format_chars == '%')\n+      if (pedantic)\n+\t{\n+\t  const format_flag_spec *t;\n+\t  if (ADJ_STD (s->std) > C_STD_VER)\n+\t    warning_at (format_string_loc, OPT_Wformat_,\n+\t\t\t\"%s does not support %s\",\n+\t\t\tC_STD_NAME (s->std), _(s->long_name));\n+\t  t = get_flag_spec (flag_specs, m_flag_chars[i], fci->flags2);\n+\t  if (t != NULL && ADJ_STD (t->std) > ADJ_STD (s->std))\n+\t    {\n+\t      const char *long_name = (t->long_name != NULL\n+\t\t\t\t       ? t->long_name\n+\t\t\t\t       : s->long_name);\n+\t      if (ADJ_STD (t->std) > C_STD_VER)\n+\t\twarning_at (format_string_loc, OPT_Wformat_,\n+\t\t\t    \"%s does not support %s with\"\n+\t\t\t    \" the %<%%%c%> %s format\",\n+\t\t\t    C_STD_NAME (t->std), _(long_name),\n+\t\t\t    format_char, fki->name);\n+\t    }\n+\t}\n+    }\n+  m_flag_chars[i - d] = 0;\n+}\n+\n+/* Determine if an assignment-allocation has been set, requiring\n+   an extra char ** for writing back a dynamically-allocated char *.\n+   This is for handling the optional 'm' character in scanf.  */\n+\n+int\n+flag_chars_t::get_alloc_flag (const format_kind_info *fki)\n+{\n+  if ((fki->flags & (int) FMT_FLAG_SCANF_A_KLUDGE)\n+      && has_char_p ('a'))\n+    return 1;\n+  if (fki->alloc_char && has_char_p (fki->alloc_char))\n+    return 1;\n+  return 0;\n+}\n+\n+/* Determine if an assignment-suppression character was seen.\n+   ('*' in scanf, for discarding the converted input).  */\n+\n+int\n+flag_chars_t::assignment_suppression_p (const format_kind_info *fki)\n+{\n+  if (fki->suppression_char\n+      && has_char_p (fki->suppression_char))\n+    return 1;\n+  return 0;\n+}\n+\n+/* Constructor for argument_parser.  Initialize for parsing one\n+   argument within a format string.  */\n+\n+argument_parser::\n+argument_parser (function_format_info *info_, const char *&format_chars_,\n+\t\t const char * const orig_format_chars_,\n+\t\t location_t format_string_loc_,\n+\t\t flag_chars_t &flag_chars_,\n+\t\t int &has_operand_number_,\n+\t\t tree first_fillin_param_,\n+\t\t object_allocator <format_wanted_type> &fwt_pool_)\n+: info (info_),\n+  fki (&format_types[info->format_type]),\n+  flag_specs (fki->flag_specs),\n+  format_chars (format_chars_),\n+  orig_format_chars (orig_format_chars_),\n+  format_string_loc (format_string_loc_),\n+  fwt_pool (fwt_pool_),\n+  flag_chars (flag_chars_),\n+  main_arg_num (0),\n+  main_arg_params (NULL),\n+  has_operand_number (has_operand_number_),\n+  first_fillin_param (first_fillin_param_),\n+  first_wanted_type (NULL),\n+  last_wanted_type (NULL)\n+{\n+}\n+\n+/* Handle dollars at the start of format arguments, setting up main_arg_params\n+   and main_arg_num.\n+\n+   Return true if format parsing is to continue, false otherwise.  */\n+\n+bool\n+argument_parser::read_any_dollar ()\n+{\n+  if ((fki->flags & (int) FMT_FLAG_USE_DOLLAR) && has_operand_number != 0)\n+    {\n+      /* Possibly read a $ operand number at the start of the format.\n+\t If one was previously used, one is required here.  If one\n+\t is not used here, we can't immediately conclude this is a\n+\t format without them, since it could be printf %m or scanf %*.  */\n+      int opnum;\n+      opnum = maybe_read_dollar_number (&format_chars, 0,\n+\t\t\t\t\tfirst_fillin_param,\n+\t\t\t\t\t&main_arg_params, fki);\n+      if (opnum == -1)\n+\treturn false;\n+      else if (opnum > 0)\n+\t{\n+\t  has_operand_number = 1;\n+\t  main_arg_num = opnum + info->first_arg_num - 1;\n+\t}\n+    }\n+  else if (fki->flags & FMT_FLAG_USE_DOLLAR)\n+    {\n+      if (avoid_dollar_number (format_chars))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Read any format flags, but do not yet validate them beyond removing\n+   duplicates, since in general validation depends on the rest of\n+   the format.\n+\n+   Return true if format parsing is to continue, false otherwise.  */\n+\n+bool\n+argument_parser::read_format_flags ()\n+{\n+  while (*format_chars != 0\n+\t && strchr (fki->flag_chars, *format_chars) != 0)\n+    {\n+      const format_flag_spec *s = get_flag_spec (flag_specs,\n+\t\t\t\t\t\t *format_chars, NULL);\n+      if (flag_chars.has_char_p (*format_chars))\n+\t{\n+\t  warning_at (location_from_offset (format_string_loc,\n+\t\t\t\t\t    format_chars + 1\n+\t\t\t\t\t    - orig_format_chars),\n+\t\t      OPT_Wformat_,\n+\t\t      \"repeated %s in format\", _(s->name));\n+\t}\n+      else\n+\tflag_chars.add_char (*format_chars);\n+\n+      if (s->skip_next_char)\n \t{\n \t  ++format_chars;\n-\t  continue;\n+\t  if (*format_chars == 0)\n+\t    {\n+\t      warning_at (format_string_loc, OPT_Wformat_,\n+\t\t\t  \"missing fill character at end of strfmon format\");\n+\t      return false;\n+\t    }\n \t}\n-      flag_chars[0] = 0;\n+      ++format_chars;\n+    }\n+\n+  return true;\n+}\n+\n+/* Read any format width, possibly * or *m$.\n+\n+   Return true if format parsing is to continue, false otherwise.  */\n+\n+bool\n+argument_parser::\n+read_any_format_width (tree &params,\n+\t\t       unsigned HOST_WIDE_INT &arg_num)\n+{\n+  if (!fki->width_char)\n+    return true;\n \n-      if ((fki->flags & (int) FMT_FLAG_USE_DOLLAR) && has_operand_number != 0)\n+  if (fki->width_type != NULL && *format_chars == '*')\n+    {\n+      flag_chars.add_char (fki->width_char);\n+      /* \"...a field width...may be indicated by an asterisk.\n+\t In this case, an int argument supplies the field width...\"  */\n+      ++format_chars;\n+      if (has_operand_number != 0)\n \t{\n-\t  /* Possibly read a $ operand number at the start of the format.\n-\t     If one was previously used, one is required here.  If one\n-\t     is not used here, we can't immediately conclude this is a\n-\t     format without them, since it could be printf %m or scanf %*.  */\n \t  int opnum;\n-\t  opnum = maybe_read_dollar_number (&format_chars, 0,\n+\t  opnum = maybe_read_dollar_number (&format_chars,\n+\t\t\t\t\t    has_operand_number == 1,\n \t\t\t\t\t    first_fillin_param,\n-\t\t\t\t\t    &main_arg_params, fki);\n+\t\t\t\t\t    &params, fki);\n \t  if (opnum == -1)\n-\t    return;\n+\t    return false;\n \t  else if (opnum > 0)\n \t    {\n \t      has_operand_number = 1;\n-\t      main_arg_num = opnum + info->first_arg_num - 1;\n+\t      arg_num = opnum + info->first_arg_num - 1;\n \t    }\n+\t  else\n+\t    has_operand_number = 0;\n \t}\n-      else if (fki->flags & FMT_FLAG_USE_DOLLAR)\n+      else\n \t{\n \t  if (avoid_dollar_number (format_chars))\n-\t    return;\n+\t    return false;\n \t}\n-\n-      /* Read any format flags, but do not yet validate them beyond removing\n-\t duplicates, since in general validation depends on the rest of\n-\t the format.  */\n-      while (*format_chars != 0\n-\t     && strchr (fki->flag_chars, *format_chars) != 0)\n+      if (info->first_arg_num != 0)\n \t{\n-\t  const format_flag_spec *s = get_flag_spec (flag_specs,\n-\t\t\t\t\t\t     *format_chars, NULL);\n-\t  if (strchr (flag_chars, *format_chars) != 0)\n-\t    {\n-\t      warning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\t\tformat_chars + 1\n-\t\t\t\t\t\t- orig_format_chars),\n-\t\t\t  OPT_Wformat_,\n-\t\t\t  \"repeated %s in format\", _(s->name));\n-\t    }\n+\t  tree cur_param;\n+\t  if (params == 0)\n+\t    cur_param = NULL;\n \t  else\n \t    {\n-\t      i = strlen (flag_chars);\n-\t      flag_chars[i++] = *format_chars;\n-\t      flag_chars[i] = 0;\n-\t    }\n-\t  if (s->skip_next_char)\n-\t    {\n-\t      ++format_chars;\n-\t      if (*format_chars == 0)\n+\t      cur_param = TREE_VALUE (params);\n+\t      if (has_operand_number <= 0)\n \t\t{\n-\t\t  warning_at (format_string_loc, OPT_Wformat_,\n-\t\t\t      \"missing fill character at end of strfmon format\");\n-\t\t  return;\n+\t\t  params = TREE_CHAIN (params);\n+\t\t  ++arg_num;\n \t\t}\n \t    }\n+\t  width_wanted_type.wanted_type = *fki->width_type;\n+\t  width_wanted_type.wanted_type_name = NULL;\n+\t  width_wanted_type.pointer_count = 0;\n+\t  width_wanted_type.char_lenient_flag = 0;\n+\t  width_wanted_type.scalar_identity_flag = 0;\n+\t  width_wanted_type.writing_in_flag = 0;\n+\t  width_wanted_type.reading_from_flag = 0;\n+\t  width_wanted_type.kind = CF_KIND_FIELD_WIDTH;\n+\t  width_wanted_type.format_start = format_chars - 1;\n+\t  width_wanted_type.format_length = 1;\n+\t  width_wanted_type.param = cur_param;\n+\t  width_wanted_type.arg_num = arg_num;\n+\t  width_wanted_type.offset_loc =\n+\t    format_chars - orig_format_chars;\n+\t  width_wanted_type.next = NULL;\n+\t  if (last_wanted_type != 0)\n+\t    last_wanted_type->next = &width_wanted_type;\n+\t  if (first_wanted_type == 0)\n+\t    first_wanted_type = &width_wanted_type;\n+\t  last_wanted_type = &width_wanted_type;\n+\t}\n+    }\n+  else\n+    {\n+      /* Possibly read a numeric width.  If the width is zero,\n+\t we complain if appropriate.  */\n+      int non_zero_width_char = FALSE;\n+      int found_width = FALSE;\n+      while (ISDIGIT (*format_chars))\n+\t{\n+\t  found_width = TRUE;\n+\t  if (*format_chars != '0')\n+\t    non_zero_width_char = TRUE;\n \t  ++format_chars;\n \t}\n+      if (found_width && !non_zero_width_char &&\n+\t  (fki->flags & (int) FMT_FLAG_ZERO_WIDTH_BAD))\n+\twarning_at (format_string_loc, OPT_Wformat_,\n+\t\t    \"zero width in %s format\", fki->name);\n+      if (found_width)\n+\tflag_chars.add_char (fki->width_char);\n+    }\n \n-      /* Read any format width, possibly * or *m$.  */\n-      if (fki->width_char != 0)\n+  return true;\n+}\n+\n+/* Read any format left precision (must be a number, not *).  */\n+void\n+argument_parser::read_any_format_left_precision ()\n+{\n+  if (fki->left_precision_char == 0)\n+    return;\n+  if (*format_chars != '#')\n+    return;\n+\n+  ++format_chars;\n+  flag_chars.add_char (fki->left_precision_char);\n+  if (!ISDIGIT (*format_chars))\n+    warning_at (location_from_offset (format_string_loc,\n+\t\t\t\t      format_chars - orig_format_chars),\n+\t\tOPT_Wformat_,\n+\t\t\"empty left precision in %s format\", fki->name);\n+  while (ISDIGIT (*format_chars))\n+    ++format_chars;\n+}\n+\n+/* Read any format precision, possibly * or *m$.\n+\n+   Return true if format parsing is to continue, false otherwise.  */\n+\n+bool\n+argument_parser::\n+read_any_format_precision (tree &params,\n+\t\t\t   unsigned HOST_WIDE_INT &arg_num)\n+{\n+  if (fki->precision_char == 0)\n+    return true;\n+  if (*format_chars != '.')\n+    return true;\n+\n+  ++format_chars;\n+  flag_chars.add_char (fki->precision_char);\n+  if (fki->precision_type != NULL && *format_chars == '*')\n+    {\n+      /* \"...a...precision...may be indicated by an asterisk.\n+\t In this case, an int argument supplies the...precision.\"  */\n+      ++format_chars;\n+      if (has_operand_number != 0)\n \t{\n-\t  if (fki->width_type != NULL && *format_chars == '*')\n+\t  int opnum;\n+\t  opnum = maybe_read_dollar_number (&format_chars,\n+\t\t\t\t\t    has_operand_number == 1,\n+\t\t\t\t\t    first_fillin_param,\n+\t\t\t\t\t    &params, fki);\n+\t  if (opnum == -1)\n+\t    return false;\n+\t  else if (opnum > 0)\n \t    {\n-\t      i = strlen (flag_chars);\n-\t      flag_chars[i++] = fki->width_char;\n-\t      flag_chars[i] = 0;\n-\t      /* \"...a field width...may be indicated by an asterisk.\n-\t\t In this case, an int argument supplies the field width...\"  */\n-\t      ++format_chars;\n-\t      if (has_operand_number != 0)\n-\t\t{\n-\t\t  int opnum;\n-\t\t  opnum = maybe_read_dollar_number (&format_chars,\n-\t\t\t\t\t\t    has_operand_number == 1,\n-\t\t\t\t\t\t    first_fillin_param,\n-\t\t\t\t\t\t    &params, fki);\n-\t\t  if (opnum == -1)\n-\t\t    return;\n-\t\t  else if (opnum > 0)\n-\t\t    {\n-\t\t      has_operand_number = 1;\n-\t\t      arg_num = opnum + info->first_arg_num - 1;\n-\t\t    }\n-\t\t  else\n-\t\t    has_operand_number = 0;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (avoid_dollar_number (format_chars))\n-\t\t    return;\n-\t\t}\n-\t      if (info->first_arg_num != 0)\n-\t\t{\n-\t\t  if (params == 0)\n-                    cur_param = NULL;\n-                  else\n-                    {\n-                      cur_param = TREE_VALUE (params);\n-                      if (has_operand_number <= 0)\n-                        {\n-                          params = TREE_CHAIN (params);\n-                          ++arg_num;\n-                        }\n-                    }\n-\t\t  width_wanted_type.wanted_type = *fki->width_type;\n-\t\t  width_wanted_type.wanted_type_name = NULL;\n-\t\t  width_wanted_type.pointer_count = 0;\n-\t\t  width_wanted_type.char_lenient_flag = 0;\n-\t\t  width_wanted_type.scalar_identity_flag = 0;\n-\t\t  width_wanted_type.writing_in_flag = 0;\n-\t\t  width_wanted_type.reading_from_flag = 0;\n-                  width_wanted_type.kind = CF_KIND_FIELD_WIDTH;\n-\t\t  width_wanted_type.format_start = format_chars - 1;\n-\t\t  width_wanted_type.format_length = 1;\n-\t\t  width_wanted_type.param = cur_param;\n-\t\t  width_wanted_type.arg_num = arg_num;\n-\t\t  width_wanted_type.offset_loc =\n-\t\t    format_chars - orig_format_chars;\n-\t\t  width_wanted_type.next = NULL;\n-\t\t  if (last_wanted_type != 0)\n-\t\t    last_wanted_type->next = &width_wanted_type;\n-\t\t  if (first_wanted_type == 0)\n-\t\t    first_wanted_type = &width_wanted_type;\n-\t\t  last_wanted_type = &width_wanted_type;\n-\t\t}\n+\t      has_operand_number = 1;\n+\t      arg_num = opnum + info->first_arg_num - 1;\n \t    }\n \t  else\n-\t    {\n-\t      /* Possibly read a numeric width.  If the width is zero,\n-\t\t we complain if appropriate.  */\n-\t      int non_zero_width_char = FALSE;\n-\t      int found_width = FALSE;\n-\t      while (ISDIGIT (*format_chars))\n-\t\t{\n-\t\t  found_width = TRUE;\n-\t\t  if (*format_chars != '0')\n-\t\t    non_zero_width_char = TRUE;\n-\t\t  ++format_chars;\n-\t\t}\n-\t      if (found_width && !non_zero_width_char &&\n-\t\t  (fki->flags & (int) FMT_FLAG_ZERO_WIDTH_BAD))\n-\t\twarning_at (format_string_loc, OPT_Wformat_,\n-\t\t\t    \"zero width in %s format\", fki->name);\n-\t      if (found_width)\n-\t\t{\n-\t\t  i = strlen (flag_chars);\n-\t\t  flag_chars[i++] = fki->width_char;\n-\t\t  flag_chars[i] = 0;\n-\t\t}\n-\t    }\n+\t    has_operand_number = 0;\n \t}\n-\n-      /* Read any format left precision (must be a number, not *).  */\n-      if (fki->left_precision_char != 0 && *format_chars == '#')\n+      else\n \t{\n-\t  ++format_chars;\n-\t  i = strlen (flag_chars);\n-\t  flag_chars[i++] = fki->left_precision_char;\n-\t  flag_chars[i] = 0;\n-\t  if (!ISDIGIT (*format_chars))\n-\t    warning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\t      format_chars - orig_format_chars),\n-\t\t\tOPT_Wformat_,\n-\t\t\t\"empty left precision in %s format\", fki->name);\n-\t  while (ISDIGIT (*format_chars))\n-\t    ++format_chars;\n+\t  if (avoid_dollar_number (format_chars))\n+\t    return false;\n \t}\n-\n-      /* Read any format precision, possibly * or *m$.  */\n-      if (fki->precision_char != 0 && *format_chars == '.')\n+      if (info->first_arg_num != 0)\n \t{\n-\t  ++format_chars;\n-\t  i = strlen (flag_chars);\n-\t  flag_chars[i++] = fki->precision_char;\n-\t  flag_chars[i] = 0;\n-\t  if (fki->precision_type != NULL && *format_chars == '*')\n+\t  tree cur_param;\n+\t  if (params == 0)\n+\t    cur_param = NULL;\n+\t  else\n \t    {\n-\t      /* \"...a...precision...may be indicated by an asterisk.\n-\t\t In this case, an int argument supplies the...precision.\"  */\n-\t      ++format_chars;\n-\t      if (has_operand_number != 0)\n+\t      cur_param = TREE_VALUE (params);\n+\t      if (has_operand_number <= 0)\n \t\t{\n-\t\t  int opnum;\n-\t\t  opnum = maybe_read_dollar_number (&format_chars,\n-\t\t\t\t\t\t    has_operand_number == 1,\n-\t\t\t\t\t\t    first_fillin_param,\n-\t\t\t\t\t\t    &params, fki);\n-\t\t  if (opnum == -1)\n-\t\t    return;\n-\t\t  else if (opnum > 0)\n-\t\t    {\n-\t\t      has_operand_number = 1;\n-\t\t      arg_num = opnum + info->first_arg_num - 1;\n-\t\t    }\n-\t\t  else\n-\t\t    has_operand_number = 0;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (avoid_dollar_number (format_chars))\n-\t\t    return;\n-\t\t}\n-\t      if (info->first_arg_num != 0)\n-\t\t{\n-\t\t  if (params == 0)\n-                    cur_param = NULL;\n-                  else\n-                    {\n-                      cur_param = TREE_VALUE (params);\n-                      if (has_operand_number <= 0)\n-                        {\n-                          params = TREE_CHAIN (params);\n-                          ++arg_num;\n-                        }\n-                    }\n-\t\t  precision_wanted_type.wanted_type = *fki->precision_type;\n-\t\t  precision_wanted_type.wanted_type_name = NULL;\n-\t\t  precision_wanted_type.pointer_count = 0;\n-\t\t  precision_wanted_type.char_lenient_flag = 0;\n-\t\t  precision_wanted_type.scalar_identity_flag = 0;\n-\t\t  precision_wanted_type.writing_in_flag = 0;\n-\t\t  precision_wanted_type.reading_from_flag = 0;\n-                  precision_wanted_type.kind = CF_KIND_FIELD_PRECISION;\n-\t\t  precision_wanted_type.param = cur_param;\n-\t\t  precision_wanted_type.format_start = format_chars - 2;\n-\t\t  precision_wanted_type.format_length = 2;\n-\t\t  precision_wanted_type.arg_num = arg_num;\n-\t\t  precision_wanted_type.offset_loc =\n-\t\t    format_chars - orig_format_chars;\n-\t\t  precision_wanted_type.next = NULL;\n-\t\t  if (last_wanted_type != 0)\n-\t\t    last_wanted_type->next = &precision_wanted_type;\n-\t\t  if (first_wanted_type == 0)\n-\t\t    first_wanted_type = &precision_wanted_type;\n-\t\t  last_wanted_type = &precision_wanted_type;\n+\t\t  params = TREE_CHAIN (params);\n+\t\t  ++arg_num;\n \t\t}\n \t    }\n-\t  else\n-\t    {\n-\t      if (!(fki->flags & (int) FMT_FLAG_EMPTY_PREC_OK)\n-\t\t  && !ISDIGIT (*format_chars))\n-\t\twarning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\t\t  format_chars - orig_format_chars),\n-\t\t\t    OPT_Wformat_,\n-\t\t\t    \"empty precision in %s format\", fki->name);\n-\t      while (ISDIGIT (*format_chars))\n-\t\t++format_chars;\n-\t    }\n+\t  precision_wanted_type.wanted_type = *fki->precision_type;\n+\t  precision_wanted_type.wanted_type_name = NULL;\n+\t  precision_wanted_type.pointer_count = 0;\n+\t  precision_wanted_type.char_lenient_flag = 0;\n+\t  precision_wanted_type.scalar_identity_flag = 0;\n+\t  precision_wanted_type.writing_in_flag = 0;\n+\t  precision_wanted_type.reading_from_flag = 0;\n+\t  precision_wanted_type.kind = CF_KIND_FIELD_PRECISION;\n+\t  precision_wanted_type.param = cur_param;\n+\t  precision_wanted_type.format_start = format_chars - 2;\n+\t  precision_wanted_type.format_length = 2;\n+\t  precision_wanted_type.arg_num = arg_num;\n+\t  precision_wanted_type.offset_loc =\n+\t    format_chars - orig_format_chars;\n+\t  precision_wanted_type.next = NULL;\n+\t  if (last_wanted_type != 0)\n+\t    last_wanted_type->next = &precision_wanted_type;\n+\t  if (first_wanted_type == 0)\n+\t    first_wanted_type = &precision_wanted_type;\n+\t  last_wanted_type = &precision_wanted_type;\n \t}\n+    }\n+  else\n+    {\n+      if (!(fki->flags & (int) FMT_FLAG_EMPTY_PREC_OK)\n+\t  && !ISDIGIT (*format_chars))\n+\twarning_at (location_from_offset (format_string_loc,\n+\t\t\t\t\t  format_chars - orig_format_chars),\n+\t\t    OPT_Wformat_,\n+\t\t    \"empty precision in %s format\", fki->name);\n+      while (ISDIGIT (*format_chars))\n+\t++format_chars;\n+    }\n \n-      format_start = format_chars;\n-      if (fki->alloc_char && fki->alloc_char == *format_chars)\n-\t{\n-\t  i = strlen (flag_chars);\n-\t  flag_chars[i++] = fki->alloc_char;\n-\t  flag_chars[i] = 0;\n-\t  format_chars++;\n-\t}\n+  return true;\n+}\n \n-      /* Handle the scanf allocation kludge.  */\n-      if (fki->flags & (int) FMT_FLAG_SCANF_A_KLUDGE)\n+/* Parse any assignment-allocation flags, which request an extra\n+   char ** for writing back a dynamically-allocated char *.\n+   This is for handling the optional 'm' character in scanf,\n+   and, before C99, 'a' (for compatibility with a non-standard\n+   GNU libc extension).  */\n+\n+void\n+argument_parser::handle_alloc_chars ()\n+{\n+  if (fki->alloc_char && fki->alloc_char == *format_chars)\n+    {\n+      flag_chars.add_char (fki->alloc_char);\n+      format_chars++;\n+    }\n+\n+  /* Handle the scanf allocation kludge.  */\n+  if (fki->flags & (int) FMT_FLAG_SCANF_A_KLUDGE)\n+    {\n+      if (*format_chars == 'a' && !flag_isoc99)\n \t{\n-\t  if (*format_chars == 'a' && !flag_isoc99)\n+\t  if (format_chars[1] == 's' || format_chars[1] == 'S'\n+\t      || format_chars[1] == '[')\n \t    {\n-\t      if (format_chars[1] == 's' || format_chars[1] == 'S'\n-\t\t  || format_chars[1] == '[')\n-\t\t{\n-\t\t  /* 'a' is used as a flag.  */\n-\t\t  i = strlen (flag_chars);\n-\t\t  flag_chars[i++] = 'a';\n-\t\t  flag_chars[i] = 0;\n-\t\t  format_chars++;\n-\t\t}\n+\t      /* 'a' is used as a flag.  */\n+\t      flag_chars.add_char ('a');\n+\t      format_chars++;\n \t    }\n \t}\n+    }\n+}\n \n-      /* Read any length modifier, if this kind of format has them.  */\n-      fli = fki->length_char_specs;\n-      length_chars = NULL;\n-      length_chars_val = FMT_LEN_none;\n-      length_chars_std = STD_C89;\n-      scalar_identity_flag = 0;\n-      if (fli)\n+/* Look for length modifiers within the current format argument,\n+   returning a length_modifier instance describing it (or the\n+   default if one is not found).\n+\n+   Issue warnings about non-standard modifiers.  */\n+\n+length_modifier\n+argument_parser::read_any_length_modifier ()\n+{\n+  length_modifier result;\n+\n+  const format_length_info *fli = fki->length_char_specs;\n+  if (!fli)\n+    return result;\n+\n+  while (fli->name != 0\n+\t && strncmp (fli->name, format_chars, strlen (fli->name)))\n+    fli++;\n+  if (fli->name != 0)\n+    {\n+      format_chars += strlen (fli->name);\n+      if (fli->double_name != 0 && fli->name[0] == *format_chars)\n \t{\n-\t  while (fli->name != 0\n- \t\t && strncmp (fli->name, format_chars, strlen (fli->name)))\n-\t      fli++;\n-\t  if (fli->name != 0)\n-\t    {\n- \t      format_chars += strlen (fli->name);\n-\t      if (fli->double_name != 0 && fli->name[0] == *format_chars)\n-\t\t{\n-\t\t  format_chars++;\n-\t\t  length_chars = fli->double_name;\n-\t\t  length_chars_val = fli->double_index;\n-\t\t  length_chars_std = fli->double_std;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  length_chars = fli->name;\n-\t\t  length_chars_val = fli->index;\n-\t\t  length_chars_std = fli->std;\n-\t\t  scalar_identity_flag = fli->scalar_identity_flag;\n-\t\t}\n-\t      i = strlen (flag_chars);\n-\t      flag_chars[i++] = fki->length_code_char;\n-\t      flag_chars[i] = 0;\n-\t    }\n-\t  if (pedantic)\n-\t    {\n-\t      /* Warn if the length modifier is non-standard.  */\n-\t      if (ADJ_STD (length_chars_std) > C_STD_VER)\n-\t\twarning_at (format_string_loc, OPT_Wformat_,\n-\t\t\t    \"%s does not support the %qs %s length modifier\",\n-\t\t\t    C_STD_NAME (length_chars_std), length_chars,\n-\t\t\t    fki->name);\n-\t    }\n+\t  format_chars++;\n+\t  result = length_modifier (fli->double_name, fli->double_index,\n+\t\t\t\t    fli->double_std, 0);\n \t}\n-\n-      /* Read any modifier (strftime E/O).  */\n-      if (fki->modifier_chars != NULL)\n+      else\n \t{\n-\t  while (*format_chars != 0\n-\t\t && strchr (fki->modifier_chars, *format_chars) != 0)\n-\t    {\n-\t      if (strchr (flag_chars, *format_chars) != 0)\n-\t\t{\n-\t\t  const format_flag_spec *s = get_flag_spec (flag_specs,\n-\t\t\t\t\t\t\t     *format_chars, NULL);\n-\t\t  warning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\t\t    format_chars \n-\t\t\t\t\t\t    - orig_format_chars),\n-\t\t\t      OPT_Wformat_,\n-\t\t\t      \"repeated %s in format\", _(s->name));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  i = strlen (flag_chars);\n-\t\t  flag_chars[i++] = *format_chars;\n-\t\t  flag_chars[i] = 0;\n-\t\t}\n-\t      ++format_chars;\n-\t    }\n+\t  result = length_modifier (fli->name, fli->index, fli->std,\n+\t\t\t\t    fli->scalar_identity_flag);\n \t}\n+      flag_chars.add_char (fki->length_code_char);\n+    }\n+  if (pedantic)\n+    {\n+      /* Warn if the length modifier is non-standard.  */\n+      if (ADJ_STD (result.std) > C_STD_VER)\n+\twarning_at (format_string_loc, OPT_Wformat_,\n+\t\t    \"%s does not support the %qs %s length modifier\",\n+\t\t    C_STD_NAME (result.std), result.chars,\n+\t\t    fki->name);\n+    }\n \n-      format_char = *format_chars;\n-      if (format_char == 0\n-\t  || (!(fki->flags & (int) FMT_FLAG_FANCY_PERCENT_OK)\n-\t      && format_char == '%'))\n+  return result;\n+}\n+\n+/* Read any other modifier (strftime E/O).  */\n+\n+void\n+argument_parser::read_any_other_modifier ()\n+{\n+  if (fki->modifier_chars == NULL)\n+    return;\n+\n+  while (*format_chars != 0\n+\t && strchr (fki->modifier_chars, *format_chars) != 0)\n+    {\n+      if (flag_chars.has_char_p (*format_chars))\n \t{\n+\t  const format_flag_spec *s = get_flag_spec (flag_specs,\n+\t\t\t\t\t\t     *format_chars, NULL);\n \t  warning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\t    format_chars - orig_format_chars),\n+\t\t\t\t\t    format_chars\n+\t\t\t\t\t    - orig_format_chars),\n \t\t      OPT_Wformat_,\n-\t\t      \"conversion lacks type at end of format\");\n-\t  continue;\n+\t\t      \"repeated %s in format\", _(s->name));\n \t}\n-      format_chars++;\n-      fci = fki->conversion_specs;\n-      while (fci->format_chars != 0\n-\t     && strchr (fci->format_chars, format_char) == 0)\n-\t  ++fci;\n-      if (fci->format_chars == 0)\n+      else\n+\tflag_chars.add_char (*format_chars);\n+      ++format_chars;\n+    }\n+}\n+\n+/* Return the format_char_info corresponding to FORMAT_CHAR,\n+   potentially issuing a warning if the format char is\n+   not supported in the C standard version we are checking\n+   against.\n+\n+   Issue a warning and return NULL if it is not found.\n+\n+   Issue warnings about non-standard modifiers.  */\n+\n+const format_char_info *\n+argument_parser::find_format_char_info (char format_char)\n+{\n+  const format_char_info *fci = fki->conversion_specs;\n+\n+  while (fci->format_chars != 0\n+\t && strchr (fci->format_chars, format_char) == 0)\n+    ++fci;\n+  if (fci->format_chars == 0)\n+    {\n+      if (ISGRAPH (format_char))\n+\twarning_at (location_from_offset (format_string_loc,\n+\t\t\t\t\t  format_chars - orig_format_chars),\n+\t\t    OPT_Wformat_,\n+\t\t    \"unknown conversion type character %qc in format\",\n+\t\t    format_char);\n+      else\n+\twarning_at (location_from_offset (format_string_loc,\n+\t\t\t\t\t  format_chars - orig_format_chars),\n+\t\t    OPT_Wformat_,\n+\t\t    \"unknown conversion type character 0x%x in format\",\n+\t\t    format_char);\n+      return NULL;\n+    }\n+\n+  if (pedantic)\n+    {\n+      if (ADJ_STD (fci->std) > C_STD_VER)\n+\twarning_at (location_from_offset (format_string_loc,\n+\t\t\t\t\t  format_chars - orig_format_chars),\n+\t\t    OPT_Wformat_,\n+\t\t    \"%s does not support the %<%%%c%> %s format\",\n+\t\t    C_STD_NAME (fci->std), format_char, fki->name);\n+    }\n+\n+  return fci;\n+}\n+\n+/* Validate the pairs of flags used.\n+   Issue warnings about incompatible combinations of flags.  */\n+\n+void\n+argument_parser::validate_flag_pairs (const format_char_info *fci,\n+\t\t\t\t      char format_char)\n+{\n+  const format_flag_pair * const bad_flag_pairs = fki->bad_flag_pairs;\n+\n+  for (int i = 0; bad_flag_pairs[i].flag_char1 != 0; i++)\n+    {\n+      const format_flag_spec *s, *t;\n+      if (!flag_chars.has_char_p (bad_flag_pairs[i].flag_char1))\n+\tcontinue;\n+      if (!flag_chars.has_char_p (bad_flag_pairs[i].flag_char2))\n+\tcontinue;\n+      if (bad_flag_pairs[i].predicate != 0\n+\t  && strchr (fci->flags2, bad_flag_pairs[i].predicate) == 0)\n+\tcontinue;\n+      s = get_flag_spec (flag_specs, bad_flag_pairs[i].flag_char1, NULL);\n+      t = get_flag_spec (flag_specs, bad_flag_pairs[i].flag_char2, NULL);\n+      if (bad_flag_pairs[i].ignored)\n \t{\n-\t  if (ISGRAPH (format_char))\n-\t    warning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\t      format_chars - orig_format_chars),\n-\t\t\tOPT_Wformat_,\n-\t\t\t\"unknown conversion type character %qc in format\",\n-\t\t\tformat_char);\n+\t  if (bad_flag_pairs[i].predicate != 0)\n+\t    warning_at (format_string_loc, OPT_Wformat_,\n+\t\t\t\"%s ignored with %s and %<%%%c%> %s format\",\n+\t\t\t_(s->name), _(t->name), format_char,\n+\t\t\tfki->name);\n \t  else\n-\t    warning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\t      format_chars - orig_format_chars),\n-\t\t\tOPT_Wformat_,\n-\t\t\t\"unknown conversion type character 0x%x in format\",\n-\t\t\tformat_char);\n-\t  continue;\n+\t    warning_at (format_string_loc, OPT_Wformat_,\n+\t\t\t\"%s ignored with %s in %s format\",\n+\t\t\t_(s->name), _(t->name), fki->name);\n \t}\n-      if (pedantic)\n+      else\n \t{\n-\t  if (ADJ_STD (fci->std) > C_STD_VER)\n-\t    warning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\t      format_chars - orig_format_chars),\n-\t\t\tOPT_Wformat_,\n-\t\t\t\"%s does not support the %<%%%c%> %s format\",\n-\t\t\tC_STD_NAME (fci->std), format_char, fki->name);\n+\t  if (bad_flag_pairs[i].predicate != 0)\n+\t    warning_at (format_string_loc, OPT_Wformat_,\n+\t\t\t\"use of %s and %s together with %<%%%c%> %s format\",\n+\t\t\t_(s->name), _(t->name), format_char,\n+\t\t\tfki->name);\n+\t  else\n+\t    warning_at (format_string_loc, OPT_Wformat_,\n+\t\t\t\"use of %s and %s together in %s format\",\n+\t\t\t_(s->name), _(t->name), fki->name);\n \t}\n+    }\n+}\n \n-      /* Validate the individual flags used, removing any that are invalid.  */\n-      {\n-\tint d = 0;\n-\tfor (i = 0; flag_chars[i] != 0; i++)\n-\t  {\n-\t    const format_flag_spec *s = get_flag_spec (flag_specs,\n-\t\t\t\t\t\t       flag_chars[i], NULL);\n-\t    flag_chars[i - d] = flag_chars[i];\n-\t    if (flag_chars[i] == fki->length_code_char)\n-\t      continue;\n-\t    if (strchr (fci->flag_chars, flag_chars[i]) == 0)\n-\t      {\n-\t\twarning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\t\t  format_chars \n-\t\t\t\t\t\t  - orig_format_chars),\n-\t\t\t    OPT_Wformat_, \"%s used with %<%%%c%> %s format\",\n-\t\t\t    _(s->name), format_char, fki->name);\n-\t\td++;\n-\t\tcontinue;\n-\t      }\n-\t    if (pedantic)\n-\t      {\n-\t\tconst format_flag_spec *t;\n-\t\tif (ADJ_STD (s->std) > C_STD_VER)\n-\t\t  warning_at (format_string_loc, OPT_Wformat_,\n-\t\t\t      \"%s does not support %s\",\n-                              C_STD_NAME (s->std), _(s->long_name));\n-\t\tt = get_flag_spec (flag_specs, flag_chars[i], fci->flags2);\n-\t\tif (t != NULL && ADJ_STD (t->std) > ADJ_STD (s->std))\n-\t\t  {\n-\t\t    const char *long_name = (t->long_name != NULL\n-\t\t\t\t\t     ? t->long_name\n-\t\t\t\t\t     : s->long_name);\n-\t\t    if (ADJ_STD (t->std) > C_STD_VER)\n-\t\t      warning_at (format_string_loc, OPT_Wformat_,\n-\t\t\t\t  \"%s does not support %s with the %<%%%c%> %s format\",\n-\t\t\t\t  C_STD_NAME (t->std), _(long_name),\n-\t\t\t\t  format_char, fki->name);\n-\t\t  }\n-\t      }\n-\t  }\n-\tflag_chars[i - d] = 0;\n-      }\n-\n-      if ((fki->flags & (int) FMT_FLAG_SCANF_A_KLUDGE)\n-\t  && strchr (flag_chars, 'a') != 0)\n-\talloc_flag = 1;\n-      if (fki->alloc_char && strchr (flag_chars, fki->alloc_char) != 0)\n-\talloc_flag = 1;\n-\n-      if (fki->suppression_char\n-\t  && strchr (flag_chars, fki->suppression_char) != 0)\n-\tsuppressed = 1;\n+/* Give Y2K warnings.  */\n \n-      /* Validate the pairs of flags used.  */\n-      for (i = 0; bad_flag_pairs[i].flag_char1 != 0; i++)\n+void\n+argument_parser::give_y2k_warnings (const format_char_info *fci,\n+\t\t\t\t    char format_char)\n+{\n+  if (!warn_format_y2k)\n+    return;\n+\n+  int y2k_level = 0;\n+  if (strchr (fci->flags2, '4') != 0)\n+    if (flag_chars.has_char_p ('E'))\n+      y2k_level = 3;\n+    else\n+      y2k_level = 2;\n+  else if (strchr (fci->flags2, '3') != 0)\n+    y2k_level = 3;\n+  else if (strchr (fci->flags2, '2') != 0)\n+    y2k_level = 2;\n+  if (y2k_level == 3)\n+    warning_at (format_string_loc, OPT_Wformat_y2k,\n+\t\t\"%<%%%c%> yields only last 2 digits of \"\n+\t\t\"year in some locales\", format_char);\n+  else if (y2k_level == 2)\n+    warning_at (format_string_loc, OPT_Wformat_y2k,\n+\t\t\"%<%%%c%> yields only last 2 digits of year\",\n+\t\tformat_char);\n+}\n+\n+/* Parse any \"scan sets\" enclosed in square brackets, e.g.\n+   for scanf-style calls.  */\n+\n+void\n+argument_parser::parse_any_scan_set (const format_char_info *fci)\n+{\n+  if (strchr (fci->flags2, '[') == NULL)\n+    return;\n+\n+  /* Skip over scan set, in case it happens to have '%' in it.  */\n+  if (*format_chars == '^')\n+    ++format_chars;\n+  /* Find closing bracket; if one is hit immediately, then\n+     it's part of the scan set rather than a terminator.  */\n+  if (*format_chars == ']')\n+    ++format_chars;\n+  while (*format_chars && *format_chars != ']')\n+    ++format_chars;\n+  if (*format_chars != ']')\n+    /* The end of the format string was reached.  */\n+    warning_at (location_from_offset (format_string_loc,\n+\t\t\t\t      format_chars - orig_format_chars),\n+\t\tOPT_Wformat_,\n+\t\t\"no closing %<]%> for %<%%[%> format\");\n+}\n+\n+/* Return true if this argument is to be continued to be parsed,\n+   false to skip to next argument.  */\n+\n+bool\n+argument_parser::handle_conversions (const format_char_info *fci,\n+\t\t\t\t     const length_modifier &len_modifier,\n+\t\t\t\t     tree &wanted_type,\n+\t\t\t\t     const char *&wanted_type_name,\n+\t\t\t\t     unsigned HOST_WIDE_INT &arg_num,\n+\t\t\t\t     tree &params,\n+\t\t\t\t     char format_char)\n+{\n+  enum format_std_version wanted_type_std;\n+\n+  if (!(fki->flags & (int) FMT_FLAG_ARG_CONVERT))\n+    return true;\n+\n+  wanted_type = (fci->types[len_modifier.val].type\n+\t\t ? *fci->types[len_modifier.val].type : 0);\n+  wanted_type_name = fci->types[len_modifier.val].name;\n+  wanted_type_std = fci->types[len_modifier.val].std;\n+  if (wanted_type == 0)\n+    {\n+      warning_at (location_from_offset (format_string_loc,\n+\t\t\t\t\tformat_chars - orig_format_chars),\n+\t\t  OPT_Wformat_,\n+\t\t  \"use of %qs length modifier with %qc type character\"\n+\t\t  \" has either no effect or undefined behavior\",\n+\t\t  len_modifier.chars, format_char);\n+      /* Heuristic: skip one argument when an invalid length/type\n+\t combination is encountered.  */\n+      arg_num++;\n+      if (params != 0)\n+\tparams = TREE_CHAIN (params);\n+      return false;\n+    }\n+  else if (pedantic\n+\t   /* Warn if non-standard, provided it is more non-standard\n+\t      than the length and type characters that may already\n+\t      have been warned for.  */\n+\t   && ADJ_STD (wanted_type_std) > ADJ_STD (len_modifier.std)\n+\t   && ADJ_STD (wanted_type_std) > ADJ_STD (fci->std))\n+    {\n+      if (ADJ_STD (wanted_type_std) > C_STD_VER)\n+\twarning_at (location_from_offset (format_string_loc,\n+\t\t\t\t\t  format_chars - orig_format_chars),\n+\t\t    OPT_Wformat_,\n+\t\t    \"%s does not support the %<%%%s%c%> %s format\",\n+\t\t    C_STD_NAME (wanted_type_std), len_modifier.chars,\n+\t\t    format_char, fki->name);\n+    }\n+\n+  return true;\n+}\n+\n+/* Check type of argument against desired type.\n+\n+   Return true if format parsing is to continue, false otherwise.  */\n+\n+bool\n+argument_parser::\n+check_argument_type (const format_char_info *fci,\n+\t\t     const length_modifier &len_modifier,\n+\t\t     tree &wanted_type,\n+\t\t     const char *&wanted_type_name,\n+\t\t     const bool suppressed,\n+\t\t     unsigned HOST_WIDE_INT &arg_num,\n+\t\t     tree &params,\n+\t\t     const int alloc_flag,\n+\t\t     const char * const format_start)\n+{\n+  if (info->first_arg_num == 0)\n+    return true;\n+\n+  if ((fci->pointer_count == 0 && wanted_type == void_type_node)\n+      || suppressed)\n+    {\n+      if (main_arg_num != 0)\n \t{\n-\t  const format_flag_spec *s, *t;\n-\t  if (strchr (flag_chars, bad_flag_pairs[i].flag_char1) == 0)\n-\t    continue;\n-\t  if (strchr (flag_chars, bad_flag_pairs[i].flag_char2) == 0)\n-\t    continue;\n-\t  if (bad_flag_pairs[i].predicate != 0\n-\t      && strchr (fci->flags2, bad_flag_pairs[i].predicate) == 0)\n-\t    continue;\n-\t  s = get_flag_spec (flag_specs, bad_flag_pairs[i].flag_char1, NULL);\n-\t  t = get_flag_spec (flag_specs, bad_flag_pairs[i].flag_char2, NULL);\n-\t  if (bad_flag_pairs[i].ignored)\n-\t    {\n-\t      if (bad_flag_pairs[i].predicate != 0)\n-\t\twarning_at (format_string_loc, OPT_Wformat_,\n-\t\t\t    \"%s ignored with %s and %<%%%c%> %s format\",\n-\t\t\t    _(s->name), _(t->name), format_char,\n-\t\t\t    fki->name);\n-\t      else\n-\t\twarning_at (format_string_loc, OPT_Wformat_,\n-\t\t\t    \"%s ignored with %s in %s format\",\n-\t\t\t    _(s->name), _(t->name), fki->name);\n-\t    }\n+\t  if (suppressed)\n+\t    warning_at (format_string_loc, OPT_Wformat_,\n+\t\t\t\"operand number specified with \"\n+\t\t\t\"suppressed assignment\");\n \t  else\n-\t    {\n-\t      if (bad_flag_pairs[i].predicate != 0)\n-\t\twarning_at (format_string_loc, OPT_Wformat_,\n-\t\t\t    \"use of %s and %s together with %<%%%c%> %s format\",\n-\t\t\t    _(s->name), _(t->name), format_char,\n-\t\t\t    fki->name);\n-\t      else\n-\t\twarning_at (format_string_loc, OPT_Wformat_,\n-\t\t\t    \"use of %s and %s together in %s format\",\n-\t\t\t    _(s->name), _(t->name), fki->name);\n-\t    }\n+\t    warning_at (format_string_loc, OPT_Wformat_,\n+\t\t\t\"operand number specified for format \"\n+\t\t\t\"taking no argument\");\n \t}\n+    }\n+  else\n+    {\n+      format_wanted_type *wanted_type_ptr;\n \n-      /* Give Y2K warnings.  */\n-      if (warn_format_y2k)\n+      if (main_arg_num != 0)\n \t{\n-\t  int y2k_level = 0;\n-\t  if (strchr (fci->flags2, '4') != 0)\n-\t    if (strchr (flag_chars, 'E') != 0)\n-\t      y2k_level = 3;\n-\t    else\n-\t      y2k_level = 2;\n-\t  else if (strchr (fci->flags2, '3') != 0)\n-\t    y2k_level = 3;\n-\t  else if (strchr (fci->flags2, '2') != 0)\n-\t    y2k_level = 2;\n-\t  if (y2k_level == 3)\n-\t    warning_at (format_string_loc, OPT_Wformat_y2k,\n-\t\t\t\"%<%%%c%> yields only last 2 digits of \"\n-\t\t\t\"year in some locales\", format_char);\n-\t  else if (y2k_level == 2)\n-\t    warning_at (format_string_loc, OPT_Wformat_y2k,\n-\t\t\t\"%<%%%c%> yields only last 2 digits of year\",\n-\t\t\tformat_char);\n+\t  arg_num = main_arg_num;\n+\t  params = main_arg_params;\n \t}\n-\n-      if (strchr (fci->flags2, '[') != 0)\n+      else\n \t{\n-\t  /* Skip over scan set, in case it happens to have '%' in it.  */\n-\t  if (*format_chars == '^')\n-\t    ++format_chars;\n-\t  /* Find closing bracket; if one is hit immediately, then\n-\t     it's part of the scan set rather than a terminator.  */\n-\t  if (*format_chars == ']')\n-\t    ++format_chars;\n-\t  while (*format_chars && *format_chars != ']')\n-\t    ++format_chars;\n-\t  if (*format_chars != ']')\n-\t    /* The end of the format string was reached.  */\n-\t    warning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\t      format_chars - orig_format_chars),\n-\t\t\tOPT_Wformat_,\n-\t\t\t\"no closing %<]%> for %<%%[%> format\");\n+\t  ++arg_num;\n+\t  if (has_operand_number > 0)\n+\t    {\n+\t      warning_at (format_string_loc, OPT_Wformat_,\n+\t\t\t  \"missing $ operand number in format\");\n+\t      return false;\n+\t    }\n+\t  else\n+\t    has_operand_number = 0;\n \t}\n \n-      wanted_type = 0;\n-      wanted_type_name = 0;\n-      if (fki->flags & (int) FMT_FLAG_ARG_CONVERT)\n+      wanted_type_ptr = &main_wanted_type;\n+      while (fci)\n \t{\n-\t  wanted_type = (fci->types[length_chars_val].type\n-\t\t\t ? *fci->types[length_chars_val].type : 0);\n-\t  wanted_type_name = fci->types[length_chars_val].name;\n-\t  wanted_type_std = fci->types[length_chars_val].std;\n-\t  if (wanted_type == 0)\n+\t  tree cur_param;\n+\t  if (params == 0)\n+\t    cur_param = NULL;\n+\t  else\n \t    {\n-\t      warning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\t\tformat_chars - orig_format_chars),\n-\t\t\t  OPT_Wformat_,\n-\t\t\t  \"use of %qs length modifier with %qc type character\"\n-\t\t\t  \" has either no effect or undefined behavior\",\n-\t\t\t  length_chars, format_char);\n-\t      /* Heuristic: skip one argument when an invalid length/type\n-\t\t combination is encountered.  */\n-\t      arg_num++;\n-\t      if (params != 0)\n-                params = TREE_CHAIN (params);\n-\t      continue;\n+\t      cur_param = TREE_VALUE (params);\n+\t      params = TREE_CHAIN (params);\n \t    }\n-\t  else if (pedantic\n-\t\t   /* Warn if non-standard, provided it is more non-standard\n-\t\t      than the length and type characters that may already\n-\t\t      have been warned for.  */\n-\t\t   && ADJ_STD (wanted_type_std) > ADJ_STD (length_chars_std)\n-\t\t   && ADJ_STD (wanted_type_std) > ADJ_STD (fci->std))\n+\n+\t  wanted_type_ptr->wanted_type = wanted_type;\n+\t  wanted_type_ptr->wanted_type_name = wanted_type_name;\n+\t  wanted_type_ptr->pointer_count = fci->pointer_count + alloc_flag;\n+\t  wanted_type_ptr->char_lenient_flag = 0;\n+\t  if (strchr (fci->flags2, 'c') != 0)\n+\t    wanted_type_ptr->char_lenient_flag = 1;\n+\t  wanted_type_ptr->scalar_identity_flag = 0;\n+\t  if (len_modifier.scalar_identity_flag)\n+\t    wanted_type_ptr->scalar_identity_flag = 1;\n+\t  wanted_type_ptr->writing_in_flag = 0;\n+\t  wanted_type_ptr->reading_from_flag = 0;\n+\t  if (alloc_flag)\n+\t    wanted_type_ptr->writing_in_flag = 1;\n+\t  else\n \t    {\n-\t      if (ADJ_STD (wanted_type_std) > C_STD_VER)\n-\t\twarning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\t\t  format_chars - orig_format_chars),\n-\t\t\t    OPT_Wformat_,\n-\t\t\t    \"%s does not support the %<%%%s%c%> %s format\",\n-\t\t\t    C_STD_NAME (wanted_type_std), length_chars,\n-\t\t\t    format_char, fki->name);\n+\t      if (strchr (fci->flags2, 'W') != 0)\n+\t\twanted_type_ptr->writing_in_flag = 1;\n+\t      if (strchr (fci->flags2, 'R') != 0)\n+\t\twanted_type_ptr->reading_from_flag = 1;\n+\t    }\n+\t  wanted_type_ptr->kind = CF_KIND_FORMAT;\n+\t  wanted_type_ptr->param = cur_param;\n+\t  wanted_type_ptr->arg_num = arg_num;\n+\t  wanted_type_ptr->format_start = format_start;\n+\t  wanted_type_ptr->format_length = format_chars - format_start;\n+\t  wanted_type_ptr->offset_loc = format_chars - orig_format_chars;\n+\t  wanted_type_ptr->next = NULL;\n+\t  if (last_wanted_type != 0)\n+\t    last_wanted_type->next = wanted_type_ptr;\n+\t  if (first_wanted_type == 0)\n+\t    first_wanted_type = wanted_type_ptr;\n+\t  last_wanted_type = wanted_type_ptr;\n+\n+\t  fci = fci->chain;\n+\t  if (fci)\n+\t    {\n+\t      wanted_type_ptr = fwt_pool.allocate ();\n+\t      arg_num++;\n+\t      wanted_type = *fci->types[len_modifier.val].type;\n+\t      wanted_type_name = fci->types[len_modifier.val].name;\n \t    }\n \t}\n+    }\n \n-      main_wanted_type.next = NULL;\n+  if (first_wanted_type != 0)\n+    check_format_types (format_string_loc, first_wanted_type);\n \n-      /* Finally. . .check type of argument against desired type!  */\n-      if (info->first_arg_num == 0)\n+  return true;\n+}\n+\n+/* Do the main part of checking a call to a format function.  FORMAT_CHARS\n+   is the NUL-terminated format string (which at this point may contain\n+   internal NUL characters); FORMAT_LENGTH is its length (excluding the\n+   terminating NUL character).  ARG_NUM is one less than the number of\n+   the first format argument to check; PARAMS points to that format\n+   argument in the list of arguments.  */\n+\n+static void\n+check_format_info_main (format_check_results *res,\n+\t\t\tfunction_format_info *info, const char *format_chars,\n+\t\t\tint format_length, tree params,\n+\t\t\tunsigned HOST_WIDE_INT arg_num,\n+\t\t\tobject_allocator <format_wanted_type> &fwt_pool)\n+{\n+  const char * const orig_format_chars = format_chars;\n+  const tree first_fillin_param = params;\n+\n+  const format_kind_info * const fki = &format_types[info->format_type];\n+  const format_flag_spec * const flag_specs = fki->flag_specs;\n+  const location_t format_string_loc = res->format_string_loc;\n+\n+  /* -1 if no conversions taking an operand have been found; 0 if one has\n+     and it didn't use $; 1 if $ formats are in use.  */\n+  int has_operand_number = -1;\n+\n+  init_dollar_format_checking (info->first_arg_num, first_fillin_param);\n+\n+  while (*format_chars != 0)\n+    {\n+      if (*format_chars++ != '%')\n \tcontinue;\n-      if ((fci->pointer_count == 0 && wanted_type == void_type_node)\n-\t  || suppressed)\n+      if (*format_chars == 0)\n \t{\n-\t  if (main_arg_num != 0)\n-\t    {\n-\t      if (suppressed)\n-\t\twarning_at (format_string_loc, OPT_Wformat_,\n-\t\t\t    \"operand number specified with \"\n-\t\t\t    \"suppressed assignment\");\n-\t      else\n-\t\twarning_at (format_string_loc, OPT_Wformat_,\n-\t\t\t    \"operand number specified for format \"\n-\t\t\t    \"taking no argument\");\n-\t    }\n+          warning_at (location_from_offset (format_string_loc,\n+\t\t\t\t\t    format_chars - orig_format_chars),\n+\t\t      OPT_Wformat_,\n+\t\t      \"spurious trailing %<%%%> in format\");\n+\t  continue;\n \t}\n-      else\n+      if (*format_chars == '%')\n \t{\n-\t  format_wanted_type *wanted_type_ptr;\n+\t  ++format_chars;\n+\t  continue;\n+\t}\n \n-\t  if (main_arg_num != 0)\n-\t    {\n-\t      arg_num = main_arg_num;\n-\t      params = main_arg_params;\n-\t    }\n-\t  else\n-\t    {\n-\t      ++arg_num;\n-\t      if (has_operand_number > 0)\n-\t\t{\n-\t\t  warning_at (format_string_loc, OPT_Wformat_,\n-\t\t\t      \"missing $ operand number in format\");\n-\t\t  return;\n-\t\t}\n-\t      else\n-\t\thas_operand_number = 0;\n-\t    }\n+      flag_chars_t flag_chars;\n+      argument_parser arg_parser (info, format_chars, orig_format_chars,\n+\t\t\t\t  format_string_loc,\n+\t\t\t\t  flag_chars, has_operand_number,\n+\t\t\t\t  first_fillin_param, fwt_pool);\n \n-\t  wanted_type_ptr = &main_wanted_type;\n-\t  while (fci)\n-\t    {\n-\t      if (params == 0)\n-                cur_param = NULL;\n-              else\n-                {\n-                  cur_param = TREE_VALUE (params);\n-                  params = TREE_CHAIN (params);\n-                }\n-\n-\t      wanted_type_ptr->wanted_type = wanted_type;\n-\t      wanted_type_ptr->wanted_type_name = wanted_type_name;\n-\t      wanted_type_ptr->pointer_count = fci->pointer_count + alloc_flag;\n-\t      wanted_type_ptr->char_lenient_flag = 0;\n-\t      if (strchr (fci->flags2, 'c') != 0)\n-\t\twanted_type_ptr->char_lenient_flag = 1;\n-\t      wanted_type_ptr->scalar_identity_flag = 0;\n-\t      if (scalar_identity_flag)\n-\t\twanted_type_ptr->scalar_identity_flag = 1;\n-\t      wanted_type_ptr->writing_in_flag = 0;\n-\t      wanted_type_ptr->reading_from_flag = 0;\n-\t      if (alloc_flag)\n-\t\twanted_type_ptr->writing_in_flag = 1;\n-\t      else\n-\t\t{\n-\t\t  if (strchr (fci->flags2, 'W') != 0)\n-\t\t    wanted_type_ptr->writing_in_flag = 1;\n-\t\t  if (strchr (fci->flags2, 'R') != 0)\n-\t\t    wanted_type_ptr->reading_from_flag = 1;\n-\t\t}\n-              wanted_type_ptr->kind = CF_KIND_FORMAT;\n-\t      wanted_type_ptr->param = cur_param;\n-\t      wanted_type_ptr->arg_num = arg_num;\n-\t      wanted_type_ptr->format_start = format_start;\n-\t      wanted_type_ptr->format_length = format_chars - format_start;\n-\t      wanted_type_ptr->offset_loc = format_chars - orig_format_chars;\n-\t      wanted_type_ptr->next = NULL;\n-\t      if (last_wanted_type != 0)\n-\t\tlast_wanted_type->next = wanted_type_ptr;\n-\t      if (first_wanted_type == 0)\n-\t\tfirst_wanted_type = wanted_type_ptr;\n-\t      last_wanted_type = wanted_type_ptr;\n-\n-\t      fci = fci->chain;\n-\t      if (fci)\n-\t\t{\n-\t\t  wanted_type_ptr = fwt_pool.allocate ();\n-\t\t  arg_num++;\n-\t\t  wanted_type = *fci->types[length_chars_val].type;\n-\t\t  wanted_type_name = fci->types[length_chars_val].name;\n-\t\t}\n-\t    }\n+      if (!arg_parser.read_any_dollar ())\n+\treturn;\n+\n+      if (!arg_parser.read_format_flags ())\n+\treturn;\n+\n+      /* Read any format width, possibly * or *m$.  */\n+      if (!arg_parser.read_any_format_width (params, arg_num))\n+\treturn;\n+\n+      /* Read any format left precision (must be a number, not *).  */\n+      arg_parser.read_any_format_left_precision ();\n+\n+      /* Read any format precision, possibly * or *m$.  */\n+      if (!arg_parser.read_any_format_precision (params, arg_num))\n+\treturn;\n+\n+      const char *format_start = format_chars;\n+\n+      arg_parser.handle_alloc_chars ();\n+\n+      /* Read any length modifier, if this kind of format has them.  */\n+      const length_modifier len_modifier\n+\t= arg_parser.read_any_length_modifier ();\n+\n+      /* Read any modifier (strftime E/O).  */\n+      arg_parser.read_any_other_modifier ();\n+\n+      char format_char = *format_chars;\n+      if (format_char == 0\n+\t  || (!(fki->flags & (int) FMT_FLAG_FANCY_PERCENT_OK)\n+\t      && format_char == '%'))\n+\t{\n+\t  warning_at (location_from_offset (format_string_loc,\n+\t\t\t\t\t    format_chars - orig_format_chars),\n+\t\t      OPT_Wformat_,\n+\t\t      \"conversion lacks type at end of format\");\n+\t  continue;\n \t}\n+      format_chars++;\n \n-      if (first_wanted_type != 0)\n-        check_format_types (format_string_loc, first_wanted_type);\n+      const format_char_info * const fci\n+\t= arg_parser.find_format_char_info (format_char);\n+      if (!fci)\n+\tcontinue;\n+\n+      flag_chars.validate (fki, fci, flag_specs, format_chars,\n+\t\t\t   format_string_loc, orig_format_chars, format_char);\n+\n+      const int alloc_flag = flag_chars.get_alloc_flag (fki);\n+      const bool suppressed = flag_chars.assignment_suppression_p (fki);\n+\n+      /* Validate the pairs of flags used.  */\n+      arg_parser.validate_flag_pairs (fci, format_char);\n+\n+      arg_parser.give_y2k_warnings (fci, format_char);\n+\n+      arg_parser.parse_any_scan_set (fci);\n+\n+      tree wanted_type = NULL;\n+      const char *wanted_type_name = NULL;\n+\n+      if (!arg_parser.handle_conversions (fci, len_modifier,\n+\t\t\t\t\t  wanted_type, wanted_type_name,\n+\t\t\t\t\t  arg_num,\n+\t\t\t\t\t  params,\n+\t\t\t\t\t  format_char))\n+\tcontinue;\n+\n+      arg_parser.main_wanted_type.next = NULL;\n+\n+      /* Finally. . .check type of argument against desired type!  */\n+      if (!arg_parser.check_argument_type (fci, len_modifier,\n+\t\t\t\t\t   wanted_type, wanted_type_name,\n+\t\t\t\t\t   suppressed,\n+\t\t\t\t\t   arg_num, params,\n+\t\t\t\t\t   alloc_flag,\n+\t\t\t\t\t   format_start))\n+\treturn;\n     }\n \n   if (format_chars - orig_format_chars != format_length)"}]}