{"sha": "2223a9984d66e956e23a3b09c5ef8b4219ec1286", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjIyM2E5OTg0ZDY2ZTk1NmUyM2EzYjA5YzVlZjhiNDIxOWVjMTI4Ng==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-11-09T17:41:23Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-11-09T17:41:23Z"}, "message": "conflict.c (mark_reg, [...]): Remove.\n\n\t* conflict.c (mark_reg, conflict_graph_compute): Remove.\n\t* basic-block.h: Remove the prototype for\n\tconflict_graph_compute.\n\nFrom-SVN: r90354", "tree": {"sha": "8fee64000e007e346136c014c6f073922d15fa0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fee64000e007e346136c014c6f073922d15fa0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2223a9984d66e956e23a3b09c5ef8b4219ec1286", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2223a9984d66e956e23a3b09c5ef8b4219ec1286", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2223a9984d66e956e23a3b09c5ef8b4219ec1286", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2223a9984d66e956e23a3b09c5ef8b4219ec1286/comments", "author": null, "committer": null, "parents": [{"sha": "9965c9c737652dbb0f20aba9daec516288aa5999", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9965c9c737652dbb0f20aba9daec516288aa5999", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9965c9c737652dbb0f20aba9daec516288aa5999"}], "stats": {"total": 143, "additions": 6, "deletions": 137}, "files": [{"sha": "17310974d2a81cdb71b1c6a413d2e4138ae4cd92", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2223a9984d66e956e23a3b09c5ef8b4219ec1286/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2223a9984d66e956e23a3b09c5ef8b4219ec1286/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2223a9984d66e956e23a3b09c5ef8b4219ec1286", "patch": "@@ -1,3 +1,9 @@\n+2004-11-09  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* conflict.c (mark_reg, conflict_graph_compute): Remove.\n+\t* basic-block.h: Remove the prototype for\n+\tconflict_graph_compute.\n+\n 2004-11-09  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* tree-if-conv.c (add_to_dst_predicate_list): Change the"}, {"sha": "7e61a1ad33e7a753cc4903e12a8bd147b32e97c5", "filename": "gcc/basic-block.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2223a9984d66e956e23a3b09c5ef8b4219ec1286/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2223a9984d66e956e23a3b09c5ef8b4219ec1286/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=2223a9984d66e956e23a3b09c5ef8b4219ec1286", "patch": "@@ -796,7 +796,6 @@ extern void conflict_graph_enum (conflict_graph, int, conflict_graph_enum_fn,\n \t\t\t\t void *);\n extern void conflict_graph_merge_regs (conflict_graph, int, int);\n extern void conflict_graph_print (conflict_graph, FILE*);\n-extern conflict_graph conflict_graph_compute (regset, partition);\n extern bool mark_dfs_back_edges (void);\n extern void set_edge_can_fallthru_flag (void);\n extern void update_br_prob_note (basic_block);"}, {"sha": "1cd58600b1eaf32a9345d84d63533fb0038d001b", "filename": "gcc/conflict.c", "status": "modified", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2223a9984d66e956e23a3b09c5ef8b4219ec1286/gcc%2Fconflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2223a9984d66e956e23a3b09c5ef8b4219ec1286/gcc%2Fconflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconflict.c?ref=2223a9984d66e956e23a3b09c5ef8b4219ec1286", "patch": "@@ -117,7 +117,6 @@ struct conflict_graph_def\n static hashval_t arc_hash (const void *);\n static int arc_eq (const void *, const void *);\n static int print_conflict (int, int, void *);\n-static void mark_reg (rtx, rtx, void *);\n \f\n /* Callback function to compute the hash value of an arc.  Uses\n    current_graph to locate the graph to which the arc belongs.  */\n@@ -364,138 +363,3 @@ conflict_graph_print (conflict_graph graph, FILE *fp)\n \tfputc ('\\n', fp);\n     }\n }\n-\n-/* Callback function for note_stores.  */\n-\n-static void\n-mark_reg (rtx reg, rtx setter ATTRIBUTE_UNUSED, void *data)\n-{\n-  regset set = (regset) data;\n-\n-  if (GET_CODE (reg) == SUBREG)\n-    reg = SUBREG_REG (reg);\n-\n-  /* We're only interested in regs.  */\n-  if (!REG_P (reg))\n-    return;\n-\n-  SET_REGNO_REG_SET (set, REGNO (reg));\n-}\n-\n-/* Allocates a conflict graph and computes conflicts over the current\n-   function for the registers set in REGS.  The caller is responsible\n-   for deallocating the return value.  \n-\n-   Preconditions: the flow graph must be in SSA form, and life\n-   analysis (specifically, regs live at exit from each block) must be\n-   up-to-date.  \n-\n-   This algorithm determines conflicts by walking the insns in each\n-   block backwards.  We maintain the set of live regs at each insn,\n-   starting with the regs live on exit from the block.  For each insn:\n- \n-     1. If a reg is set in this insns, it must be born here, since\n-        we're in SSA.  Therefore, it was not live before this insns,\n-\tso remove it from the set of live regs.  \n-\n-     2. For each reg born in this insn, record a conflict between it\n-\tand every other reg live coming into this insn.  For each\n-\texisting conflict, one of the two regs must be born while the\n-\tother is alive.  See Morgan or elsewhere for a proof of this.\n-\n-     3. Regs clobbered by this insn must have been live coming into\n-        it, so record them as such.  \n-\n-   The resulting conflict graph is not built for regs in REGS\n-   themselves; rather, partition P is used to obtain the canonical reg\n-   for each of these.  The nodes of the conflict graph are these\n-   canonical regs instead.  */\n-\n-conflict_graph\n-conflict_graph_compute (regset regs, partition p)\n-{\n-  conflict_graph graph = conflict_graph_new (max_reg_num ());\n-  regset_head live_head;\n-  regset live = &live_head;\n-  regset_head born_head;\n-  regset born = &born_head;\n-  basic_block bb;\n-\n-  INIT_REG_SET (live);\n-  INIT_REG_SET (born);\n-\n-  FOR_EACH_BB_REVERSE (bb)\n-    {\n-      rtx insn;\n-      rtx head;\n-\n-      /* Start with the regs that are live on exit, limited to those\n-\t we're interested in.  */\n-      COPY_REG_SET (live, bb->global_live_at_end);\n-      AND_REG_SET (live, regs);\n-\n-      /* Walk the instruction stream backwards.  */\n-      head = BB_HEAD (bb);\n-      insn = BB_END (bb);\n-      for (insn = BB_END (bb); insn != head; insn = PREV_INSN (insn))\n-\t{\n-\t  unsigned born_reg;\n-\t  unsigned live_reg;\n-\t  rtx link;\n-\n-\t  /* Are we interested in this insn? */\n-\t  if (INSN_P (insn))\n-\t    {\n-\t      reg_set_iterator rsi;\n-\n-\t      /* Determine which regs are set in this insn.  Since\n-  \t         we're in SSA form, if a reg is set here it isn't set\n-  \t         anywhere else, so this insn is where the reg is born.  */\n-\t      CLEAR_REG_SET (born);\n-\t      note_stores (PATTERN (insn), mark_reg, born);\n-\t      AND_REG_SET (born, regs);\n-\t  \n-\t      /* Regs born here were not live before this insn.  */\n-\t      AND_COMPL_REG_SET (live, born);\n-\n-\t      /* For every reg born here, add a conflict with every other\n-  \t         reg live coming into this insn.  */\n-\t      EXECUTE_IF_SET_IN_REG_SET\n-\t\t(born, FIRST_PSEUDO_REGISTER, born_reg, rsi)\n-\t\t{\n-\t\t  reg_set_iterator rsj;\n-\n-\t\t  EXECUTE_IF_SET_IN_REG_SET\n-\t\t    (live, FIRST_PSEUDO_REGISTER, live_reg, rsj)\n-\t\t    {\n-\t\t      /* Build the conflict graph in terms of canonical\n-\t\t\t regnos.  */\n-\t\t      int b = partition_find (p, born_reg);\n-\t\t      int l = partition_find (p, live_reg);\n-\n-\t\t      if (b != l)\n-\t\t\tconflict_graph_add (graph, b, l);\n-\t\t    }\n-\t\t}\n-\n-\t      /* Morgan's algorithm checks the operands of the insn\n-\t         and adds them to the set of live regs.  Instead, we\n-\t         use death information added by life analysis.  Regs\n-\t         dead after this instruction were live before it.  */\n-\t      for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-\t\tif (REG_NOTE_KIND (link) == REG_DEAD)\n-\t\t  {\n-\t\t    unsigned int regno = REGNO (XEXP (link, 0));\n-\n-\t\t    if (REGNO_REG_SET_P (regs, regno))\n-\t\t      SET_REGNO_REG_SET (live, regno);\n-\t\t  }\n-\t    }\n-\t}\n-    }\n-\n-  FREE_REG_SET (live);\n-  FREE_REG_SET (born);\n-\n-  return graph;\n-}"}]}