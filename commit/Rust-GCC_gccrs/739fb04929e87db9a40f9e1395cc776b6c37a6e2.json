{"sha": "739fb04929e87db9a40f9e1395cc776b6c37a6e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM5ZmIwNDkyOWU4N2RiOWE0MGY5ZTEzOTVjYzc3NmI2YzM3YTZlMg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-04-27T16:44:23Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-04-27T16:44:23Z"}, "message": "calls.c (combine_pending_stack_adjustment_and_call): New function.\n\n\t* calls.c (combine_pending_stack_adjustment_and_call): New function.\n\t(expand_call): Use it.\n\nFrom-SVN: r33491", "tree": {"sha": "593de391f75b1c5b997b7e601a34cd90c8ec1b1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/593de391f75b1c5b997b7e601a34cd90c8ec1b1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/739fb04929e87db9a40f9e1395cc776b6c37a6e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/739fb04929e87db9a40f9e1395cc776b6c37a6e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/739fb04929e87db9a40f9e1395cc776b6c37a6e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/739fb04929e87db9a40f9e1395cc776b6c37a6e2/comments", "author": null, "committer": null, "parents": [{"sha": "d582732678033c905dc1fd09665b9ac835e9bf28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d582732678033c905dc1fd09665b9ac835e9bf28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d582732678033c905dc1fd09665b9ac835e9bf28"}], "stats": {"total": 92, "additions": 77, "deletions": 15}, "files": [{"sha": "fc52ec72e139ff28bbc83d92082d203a4f986569", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/739fb04929e87db9a40f9e1395cc776b6c37a6e2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/739fb04929e87db9a40f9e1395cc776b6c37a6e2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=739fb04929e87db9a40f9e1395cc776b6c37a6e2", "patch": "@@ -1,3 +1,8 @@\n+2000-04-27  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* calls.c (combine_pending_stack_adjustment_and_call): New function.\n+\t(expand_call): Use it.\n+\t\n 2000-04-27  Jan Hubicka  <jh@suse.cz>\n \n \t* flow.c (mark_set_1):  Handle MEMs in ZERO_EXTRACT/SIGN_EXTRACT"}, {"sha": "56e18f8f2313f77a93ab3eb905c833d5b2627bab", "filename": "gcc/calls.c", "status": "modified", "additions": 72, "deletions": 15, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/739fb04929e87db9a40f9e1395cc776b6c37a6e2/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/739fb04929e87db9a40f9e1395cc776b6c37a6e2/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=739fb04929e87db9a40f9e1395cc776b6c37a6e2", "patch": "@@ -210,6 +210,8 @@ static int special_function_p\t\t\tPARAMS ((tree, int));\n static int flags_from_decl_or_type \t\tPARAMS ((tree));\n static rtx try_to_integrate\t\t\tPARAMS ((tree, tree, rtx,\n \t\t\t\t\t\t\t int, tree, rtx));\n+static void combine_pending_stack_adjustment_and_call\n+                                                PARAMS ((int, struct args_size *, int));\n \n #ifdef REG_PARM_STACK_SPACE\n static rtx save_fixed_argument_area\tPARAMS ((int, rtx, int *, int *));\n@@ -1855,6 +1857,64 @@ try_to_integrate (fndecl, actparms, target, ignore, type, structure_value_addr)\n   return (rtx) (HOST_WIDE_INT) - 1;\n }\n \n+/* We need to pop PENDING_STACK_ADJUST bytes.  But, if the arguments\n+   wouldn't fill up an even multiple of PREFERRED_UNIT_STACK_BOUNDARY\n+   bytes, then we would need to push some additional bytes to pad the\n+   arguments.  So, we adjust the stack pointer by an amount that will\n+   leave the stack under-aligned by UNADJUSTED_ARGS_SIZE bytes.  Then,\n+   when the arguments are pushed the stack will be perfectly aligned.\n+   ARGS_SIZE->CONSTANT is set to the number of bytes that should be\n+   popped after the call.  */\n+\n+static void\n+combine_pending_stack_adjustment_and_call (unadjusted_args_size,\n+\t\t\t\t\t   args_size,\n+\t\t\t\t\t   preferred_unit_stack_boundary)\n+     int unadjusted_args_size;\n+     struct args_size *args_size;\n+     int preferred_unit_stack_boundary;\n+{\n+  /* The number of bytes to pop so that the stack will be\n+     under-aligned by UNADJUSTED_ARGS_SIZE bytes.  */\n+  HOST_WIDE_INT adjustment;\n+  /* The alignment of the stack after the arguments are pushed, if we\n+     just pushed the arguments without adjust the stack here.  */\n+  HOST_WIDE_INT unadjusted_alignment;\n+\n+  unadjusted_alignment \n+    = ((stack_pointer_delta + unadjusted_args_size)\n+       % preferred_unit_stack_boundary);\n+\n+  /* We want to get rid of as many of the PENDING_STACK_ADJUST bytes\n+     as possible -- leaving just enough left to cancel out the\n+     UNADJUSTED_ALIGNMENT.  In other words, we want to ensure that the\n+     PENDING_STACK_ADJUST is non-negative, and congruent to\n+     -UNADJUSTED_ALIGNMENT modulo the PREFERRED_UNIT_STACK_BOUNDARY.  */\n+\n+  /* Begin by trying to pop all the bytes.  */\n+  unadjusted_alignment \n+    = (unadjusted_alignment \n+       - (pending_stack_adjust % preferred_unit_stack_boundary));\n+  adjustment = pending_stack_adjust;\n+  /* Push enough additional bytes that the stack will be aligned\n+     after the arguments are pushed.  */\n+  if (unadjusted_alignment >= 0)\n+    adjustment -= preferred_unit_stack_boundary - unadjusted_alignment;\n+  else\n+    adjustment += unadjusted_alignment;\n+  \n+  /* Now, sets ARGS_SIZE->CONSTANT so that we pop the right number of\n+     bytes after the call.  The right number is the entire\n+     PENDING_STACK_ADJUST less our ADJUSTMENT plus the amount required\n+     by the arguments in the first place.  */\n+  args_size->constant \n+    = pending_stack_adjust - adjustment + unadjusted_args_size;\n+\n+  /* Push the right number of bytes.  */\n+  pending_stack_adjust = adjustment;\n+  do_pending_stack_adjust ();\n+}\n+\n /* Generate all the code for a function call\n    and return an rtx for its value.\n    Store the value in TARGET (specified as an rtx) if convenient.\n@@ -1966,7 +2026,10 @@ expand_call (exp, target, ignore)\n   rtx call_fusage;\n   register tree p;\n   register int i;\n-  int preferred_stack_boundary;\n+  /* The alignment of the stack, in bits.  */\n+  HOST_WIDE_INT preferred_stack_boundary;\n+  /* The alignment of the stack, in bytes.  */\n+  HOST_WIDE_INT preferred_unit_stack_boundary;\n \n   /* The value of the function call can be put in a hard register.  But\n      if -fcheck-memory-usage, code which invokes functions (and thus\n@@ -2207,11 +2270,13 @@ expand_call (exp, target, ignore)\n   if (fndecl && DECL_NAME (fndecl))\n     name = IDENTIFIER_POINTER (DECL_NAME (fndecl));\n \n+  /* Figure out the amount to which the stack should be aligned.  */\n #ifdef PREFERRED_STACK_BOUNDARY\n   preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;\n #else\n   preferred_stack_boundary = STACK_BOUNDARY;\n #endif\n+  preferred_unit_stack_boundary = preferred_stack_boundary / BITS_PER_UNIT;\n \n   /* Ensure current function's preferred stack boundary is at least\n      what we need.  We don't have to increase alignment for recursive\n@@ -2657,21 +2722,13 @@ expand_call (exp, target, ignore)\n \t{\n \t  /* When the stack adjustment is pending, we get better code\n \t     by combining the adjustments.  */\n-\t  if (pending_stack_adjust && ! (flags & (ECF_CONST | ECF_PURE))\n+\t  if (pending_stack_adjust \n+\t      && ! (flags & (ECF_CONST | ECF_PURE))\n \t      && ! inhibit_defer_pop)\n-\t    {\n-\t      int adjust;\n-\t      args_size.constant = (unadjusted_args_size\n-\t\t\t\t    + ((pending_stack_adjust\n-\t\t\t\t\t+ args_size.constant\n-\t\t\t\t\t- unadjusted_args_size)\n-\t\t\t\t       % (preferred_stack_boundary\n-\t\t\t\t\t  / BITS_PER_UNIT)));\n-\t      adjust = (pending_stack_adjust - args_size.constant\n-\t\t        + unadjusted_args_size);\n-\t      adjust_stack (GEN_INT (adjust));\n-\t      pending_stack_adjust = 0;\n-\t    }\n+\t    combine_pending_stack_adjustment_and_call \n+\t      (unadjusted_args_size,\n+\t       &args_size,\n+\t       preferred_unit_stack_boundary);\n \t  else if (argblock == 0)\n \t    anti_adjust_stack (GEN_INT (args_size.constant\n \t\t\t\t\t- unadjusted_args_size));"}]}