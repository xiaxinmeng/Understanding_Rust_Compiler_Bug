{"sha": "114bf3f172d0f215a576d8964b95c0a4608563e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE0YmYzZjE3MmQwZjIxNWE1NzZkODk2NGI5NWMwYTQ2MDg1NjNlMA==", "commit": {"author": {"name": "Matthias Klose", "email": "doko@ubuntu.com", "date": "2016-11-30T00:12:45Z"}, "committer": {"name": "Matthias Klose", "email": "doko@gcc.gnu.org", "date": "2016-11-30T00:12:45Z"}, "message": "Makefile.def: Remove reference to boehm-gc target module.\n\n<toplevel>\n\n2016-11-30  Matthias Klose  <doko@ubuntu.com>\n\n        * Makefile.def: Remove reference to boehm-gc target module.\n        * configure.ac: Include pkg.m4, check for --with-target-bdw-gc\n        options and for the bdw-gc pkg-config module.\n        * configure: Regenerate.\n        * Makefile.in: Regenerate.\n\ngcc/\n\n2016-11-30  Matthias Klose  <doko@ubuntu.com>\n\n        * doc/install.texi: Document configure options --enable-objc-gc\n        and --with-target-bdw-gc.\n\nconfig/\n\n2016-11-30  Matthias Klose  <doko@ubuntu.com>\n\n        * pkg.m4: New file.\n\nlibobjc/\n\n2016-11-30  Matthias Klose  <doko@ubuntu.com>\n\n        * configure.ac (--enable-objc-gc): Allow to configure with a\n        system provided boehm-gc.\n        * configure: Regenerate.\n        * Makefile.in (OBJC_BOEHM_GC_LIBS): Get value from configure.\n        * gc.c: Include system bdw-gc headers.\n        * memory.c: Likewise\n        * objects.c: Likewise\n\nboehm-gc/\n\n2016-11-30  Matthias Klose  <doko@ubuntu.com>\n\n        Remove\n\nFrom-SVN: r242985", "tree": {"sha": "612b3ff1d05c431b7d883db262d72acacab4b0d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/612b3ff1d05c431b7d883db262d72acacab4b0d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/114bf3f172d0f215a576d8964b95c0a4608563e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/114bf3f172d0f215a576d8964b95c0a4608563e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/114bf3f172d0f215a576d8964b95c0a4608563e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/114bf3f172d0f215a576d8964b95c0a4608563e0/comments", "author": {"login": "doko42", "id": 11258518, "node_id": "MDQ6VXNlcjExMjU4NTE4", "avatar_url": "https://avatars.githubusercontent.com/u/11258518?v=4", "gravatar_id": "", "url": "https://api.github.com/users/doko42", "html_url": "https://github.com/doko42", "followers_url": "https://api.github.com/users/doko42/followers", "following_url": "https://api.github.com/users/doko42/following{/other_user}", "gists_url": "https://api.github.com/users/doko42/gists{/gist_id}", "starred_url": "https://api.github.com/users/doko42/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/doko42/subscriptions", "organizations_url": "https://api.github.com/users/doko42/orgs", "repos_url": "https://api.github.com/users/doko42/repos", "events_url": "https://api.github.com/users/doko42/events{/privacy}", "received_events_url": "https://api.github.com/users/doko42/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a2b403c8bb69250b321c9d56e38f5f3537a1e696", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2b403c8bb69250b321c9d56e38f5f3537a1e696", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2b403c8bb69250b321c9d56e38f5f3537a1e696"}], "stats": {"total": 85347, "additions": 1616, "deletions": 83731}, "files": [{"sha": "7876d60d93ff97cfef1ee868fdfce63c6d0a6eb9", "filename": "ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114bf3f172d0f215a576d8964b95c0a4608563e0/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114bf3f172d0f215a576d8964b95c0a4608563e0/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=114bf3f172d0f215a576d8964b95c0a4608563e0", "patch": "@@ -1,3 +1,11 @@\n+2016-11-30  Matthias Klose  <doko@ubuntu.com>\n+\n+\t* Makefile.def: Remove reference to boehm-gc target module.\n+  \t* configure.ac: Include pkg.m4, check for --with-target-bdw-gc\n+\toptions and for the bdw-gc pkg-config module.\n+\t* configure: Regenerate.\n+\t* Makefile.in: Regenerate.\n+\n 2016-11-28  Nathan Sidwell  <nathan@acm.org>\n \n \t* MAINTAINERS (nvptx): Remove self."}, {"sha": "7aa4cb33ae3b751e65f1e2f7daa5841b35c1c14b", "filename": "Makefile.def", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114bf3f172d0f215a576d8964b95c0a4608563e0/Makefile.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114bf3f172d0f215a576d8964b95c0a4608563e0/Makefile.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.def?ref=114bf3f172d0f215a576d8964b95c0a4608563e0", "patch": "@@ -166,7 +166,6 @@ target_modules = { module= winsup; };\n target_modules = { module= libgloss; no_check=true; };\n target_modules = { module= libffi; no_install=true; };\n target_modules = { module= zlib; };\n-target_modules = { module= boehm-gc; };\n target_modules = { module= rda; };\n target_modules = { module= libada; };\n target_modules = { module= libgomp; bootstrap= true; lib_path=.libs; };\n@@ -543,16 +542,13 @@ lang_env_dependencies = { module=libgcc; no_gcc=true; no_c=true; };\n // a dependency on libgcc for native targets to configure.\n lang_env_dependencies = { module=libiberty; no_c=true; };\n \n-dependencies = { module=configure-target-boehm-gc; on=all-target-libstdc++-v3; };\n dependencies = { module=configure-target-fastjar; on=configure-target-zlib; };\n dependencies = { module=all-target-fastjar; on=all-target-zlib; };\n dependencies = { module=configure-target-libgo; on=configure-target-libffi; };\n dependencies = { module=configure-target-libgo; on=all-target-libstdc++-v3; };\n dependencies = { module=all-target-libgo; on=all-target-libbacktrace; };\n dependencies = { module=all-target-libgo; on=all-target-libffi; };\n dependencies = { module=all-target-libgo; on=all-target-libatomic; };\n-dependencies = { module=configure-target-libobjc; on=configure-target-boehm-gc; };\n-dependencies = { module=all-target-libobjc; on=all-target-boehm-gc; };\n dependencies = { module=configure-target-libstdc++-v3; on=configure-target-libgomp; };\n dependencies = { module=configure-target-liboffloadmic; on=configure-target-libgomp; };\n dependencies = { module=configure-target-libsanitizer; on=all-target-libstdc++-v3; };"}, {"sha": "66f6c68b167f8ba515dacfe90a86d9fda8afca59", "filename": "Makefile.in", "status": "modified", "additions": 0, "deletions": 484, "changes": 484, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114bf3f172d0f215a576d8964b95c0a4608563e0/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114bf3f172d0f215a576d8964b95c0a4608563e0/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=114bf3f172d0f215a576d8964b95c0a4608563e0", "patch": "@@ -998,7 +998,6 @@ configure-target:  \\\n     maybe-configure-target-libgloss \\\n     maybe-configure-target-libffi \\\n     maybe-configure-target-zlib \\\n-    maybe-configure-target-boehm-gc \\\n     maybe-configure-target-rda \\\n     maybe-configure-target-libada \\\n     maybe-configure-target-libgomp \\\n@@ -1164,7 +1163,6 @@ all-target: maybe-all-target-winsup\n all-target: maybe-all-target-libgloss\n all-target: maybe-all-target-libffi\n all-target: maybe-all-target-zlib\n-all-target: maybe-all-target-boehm-gc\n all-target: maybe-all-target-rda\n all-target: maybe-all-target-libada\n @if target-libgomp-no-bootstrap\n@@ -1257,7 +1255,6 @@ info-target: maybe-info-target-winsup\n info-target: maybe-info-target-libgloss\n info-target: maybe-info-target-libffi\n info-target: maybe-info-target-zlib\n-info-target: maybe-info-target-boehm-gc\n info-target: maybe-info-target-rda\n info-target: maybe-info-target-libada\n info-target: maybe-info-target-libgomp\n@@ -1343,7 +1340,6 @@ dvi-target: maybe-dvi-target-winsup\n dvi-target: maybe-dvi-target-libgloss\n dvi-target: maybe-dvi-target-libffi\n dvi-target: maybe-dvi-target-zlib\n-dvi-target: maybe-dvi-target-boehm-gc\n dvi-target: maybe-dvi-target-rda\n dvi-target: maybe-dvi-target-libada\n dvi-target: maybe-dvi-target-libgomp\n@@ -1429,7 +1425,6 @@ pdf-target: maybe-pdf-target-winsup\n pdf-target: maybe-pdf-target-libgloss\n pdf-target: maybe-pdf-target-libffi\n pdf-target: maybe-pdf-target-zlib\n-pdf-target: maybe-pdf-target-boehm-gc\n pdf-target: maybe-pdf-target-rda\n pdf-target: maybe-pdf-target-libada\n pdf-target: maybe-pdf-target-libgomp\n@@ -1515,7 +1510,6 @@ html-target: maybe-html-target-winsup\n html-target: maybe-html-target-libgloss\n html-target: maybe-html-target-libffi\n html-target: maybe-html-target-zlib\n-html-target: maybe-html-target-boehm-gc\n html-target: maybe-html-target-rda\n html-target: maybe-html-target-libada\n html-target: maybe-html-target-libgomp\n@@ -1601,7 +1595,6 @@ TAGS-target: maybe-TAGS-target-winsup\n TAGS-target: maybe-TAGS-target-libgloss\n TAGS-target: maybe-TAGS-target-libffi\n TAGS-target: maybe-TAGS-target-zlib\n-TAGS-target: maybe-TAGS-target-boehm-gc\n TAGS-target: maybe-TAGS-target-rda\n TAGS-target: maybe-TAGS-target-libada\n TAGS-target: maybe-TAGS-target-libgomp\n@@ -1687,7 +1680,6 @@ install-info-target: maybe-install-info-target-winsup\n install-info-target: maybe-install-info-target-libgloss\n install-info-target: maybe-install-info-target-libffi\n install-info-target: maybe-install-info-target-zlib\n-install-info-target: maybe-install-info-target-boehm-gc\n install-info-target: maybe-install-info-target-rda\n install-info-target: maybe-install-info-target-libada\n install-info-target: maybe-install-info-target-libgomp\n@@ -1773,7 +1765,6 @@ install-pdf-target: maybe-install-pdf-target-winsup\n install-pdf-target: maybe-install-pdf-target-libgloss\n install-pdf-target: maybe-install-pdf-target-libffi\n install-pdf-target: maybe-install-pdf-target-zlib\n-install-pdf-target: maybe-install-pdf-target-boehm-gc\n install-pdf-target: maybe-install-pdf-target-rda\n install-pdf-target: maybe-install-pdf-target-libada\n install-pdf-target: maybe-install-pdf-target-libgomp\n@@ -1859,7 +1850,6 @@ install-html-target: maybe-install-html-target-winsup\n install-html-target: maybe-install-html-target-libgloss\n install-html-target: maybe-install-html-target-libffi\n install-html-target: maybe-install-html-target-zlib\n-install-html-target: maybe-install-html-target-boehm-gc\n install-html-target: maybe-install-html-target-rda\n install-html-target: maybe-install-html-target-libada\n install-html-target: maybe-install-html-target-libgomp\n@@ -1945,7 +1935,6 @@ installcheck-target: maybe-installcheck-target-winsup\n installcheck-target: maybe-installcheck-target-libgloss\n installcheck-target: maybe-installcheck-target-libffi\n installcheck-target: maybe-installcheck-target-zlib\n-installcheck-target: maybe-installcheck-target-boehm-gc\n installcheck-target: maybe-installcheck-target-rda\n installcheck-target: maybe-installcheck-target-libada\n installcheck-target: maybe-installcheck-target-libgomp\n@@ -2031,7 +2020,6 @@ mostlyclean-target: maybe-mostlyclean-target-winsup\n mostlyclean-target: maybe-mostlyclean-target-libgloss\n mostlyclean-target: maybe-mostlyclean-target-libffi\n mostlyclean-target: maybe-mostlyclean-target-zlib\n-mostlyclean-target: maybe-mostlyclean-target-boehm-gc\n mostlyclean-target: maybe-mostlyclean-target-rda\n mostlyclean-target: maybe-mostlyclean-target-libada\n mostlyclean-target: maybe-mostlyclean-target-libgomp\n@@ -2117,7 +2105,6 @@ clean-target: maybe-clean-target-winsup\n clean-target: maybe-clean-target-libgloss\n clean-target: maybe-clean-target-libffi\n clean-target: maybe-clean-target-zlib\n-clean-target: maybe-clean-target-boehm-gc\n clean-target: maybe-clean-target-rda\n clean-target: maybe-clean-target-libada\n clean-target: maybe-clean-target-libgomp\n@@ -2203,7 +2190,6 @@ distclean-target: maybe-distclean-target-winsup\n distclean-target: maybe-distclean-target-libgloss\n distclean-target: maybe-distclean-target-libffi\n distclean-target: maybe-distclean-target-zlib\n-distclean-target: maybe-distclean-target-boehm-gc\n distclean-target: maybe-distclean-target-rda\n distclean-target: maybe-distclean-target-libada\n distclean-target: maybe-distclean-target-libgomp\n@@ -2289,7 +2275,6 @@ maintainer-clean-target: maybe-maintainer-clean-target-winsup\n maintainer-clean-target: maybe-maintainer-clean-target-libgloss\n maintainer-clean-target: maybe-maintainer-clean-target-libffi\n maintainer-clean-target: maybe-maintainer-clean-target-zlib\n-maintainer-clean-target: maybe-maintainer-clean-target-boehm-gc\n maintainer-clean-target: maybe-maintainer-clean-target-rda\n maintainer-clean-target: maybe-maintainer-clean-target-libada\n maintainer-clean-target: maybe-maintainer-clean-target-libgomp\n@@ -2431,7 +2416,6 @@ check-target:  \\\n     maybe-check-target-libgloss \\\n     maybe-check-target-libffi \\\n     maybe-check-target-zlib \\\n-    maybe-check-target-boehm-gc \\\n     maybe-check-target-rda \\\n     maybe-check-target-libada \\\n     maybe-check-target-libgomp \\\n@@ -2613,7 +2597,6 @@ install-target:  \\\n     maybe-install-target-libgloss \\\n     maybe-install-target-libffi \\\n     maybe-install-target-zlib \\\n-    maybe-install-target-boehm-gc \\\n     maybe-install-target-rda \\\n     maybe-install-target-libada \\\n     maybe-install-target-libgomp \\\n@@ -2719,7 +2702,6 @@ install-strip-target:  \\\n     maybe-install-strip-target-libgloss \\\n     maybe-install-strip-target-libffi \\\n     maybe-install-strip-target-zlib \\\n-    maybe-install-strip-target-boehm-gc \\\n     maybe-install-strip-target-rda \\\n     maybe-install-strip-target-libada \\\n     maybe-install-strip-target-libgomp \\\n@@ -48324,464 +48306,6 @@ maintainer-clean-target-zlib:\n \n \n \n-.PHONY: configure-target-boehm-gc maybe-configure-target-boehm-gc\n-maybe-configure-target-boehm-gc:\n-@if gcc-bootstrap\n-configure-target-boehm-gc: stage_current\n-@endif gcc-bootstrap\n-@if target-boehm-gc\n-maybe-configure-target-boehm-gc: configure-target-boehm-gc\n-configure-target-boehm-gc: \n-\t@: $(MAKE); $(unstage)\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\techo \"Checking multilib configuration for boehm-gc...\"; \\\n-\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/boehm-gc; \\\n-\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/boehm-gc/multilib.tmp 2> /dev/null; \\\n-\tif test -r $(TARGET_SUBDIR)/boehm-gc/multilib.out; then \\\n-\t  if cmp -s $(TARGET_SUBDIR)/boehm-gc/multilib.tmp $(TARGET_SUBDIR)/boehm-gc/multilib.out; then \\\n-\t    rm -f $(TARGET_SUBDIR)/boehm-gc/multilib.tmp; \\\n-\t  else \\\n-\t    rm -f $(TARGET_SUBDIR)/boehm-gc/Makefile; \\\n-\t    mv $(TARGET_SUBDIR)/boehm-gc/multilib.tmp $(TARGET_SUBDIR)/boehm-gc/multilib.out; \\\n-\t  fi; \\\n-\telse \\\n-\t  mv $(TARGET_SUBDIR)/boehm-gc/multilib.tmp $(TARGET_SUBDIR)/boehm-gc/multilib.out; \\\n-\tfi; \\\n-\ttest ! -f $(TARGET_SUBDIR)/boehm-gc/Makefile || exit 0; \\\n-\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/boehm-gc; \\\n-\t$(NORMAL_TARGET_EXPORTS)  \\\n-\techo Configuring in $(TARGET_SUBDIR)/boehm-gc; \\\n-\tcd \"$(TARGET_SUBDIR)/boehm-gc\" || exit 1; \\\n-\tcase $(srcdir) in \\\n-\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n-\t  *) topdir=`echo $(TARGET_SUBDIR)/boehm-gc/ | \\\n-\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n-\tesac; \\\n-\tmodule_srcdir=boehm-gc; \\\n-\trm -f no-such-file || : ; \\\n-\tCONFIG_SITE=no-such-file $(SHELL) \\\n-\t  $$s/$$module_srcdir/configure \\\n-\t  --srcdir=$${topdir}/$$module_srcdir \\\n-\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n-\t  --target=${target_alias}  \\\n-\t  || exit 1\n-@endif target-boehm-gc\n-\n-\n-\n-\n-\n-.PHONY: all-target-boehm-gc maybe-all-target-boehm-gc\n-maybe-all-target-boehm-gc:\n-@if gcc-bootstrap\n-all-target-boehm-gc: stage_current\n-@endif gcc-bootstrap\n-@if target-boehm-gc\n-TARGET-target-boehm-gc=all\n-maybe-all-target-boehm-gc: all-target-boehm-gc\n-all-target-boehm-gc: configure-target-boehm-gc\n-\t@: $(MAKE); $(unstage)\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS)  \\\n-\t(cd $(TARGET_SUBDIR)/boehm-gc && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) $(EXTRA_TARGET_FLAGS)   \\\n-\t\t$(TARGET-target-boehm-gc))\n-@endif target-boehm-gc\n-\n-\n-\n-\n-\n-.PHONY: check-target-boehm-gc maybe-check-target-boehm-gc\n-maybe-check-target-boehm-gc:\n-@if target-boehm-gc\n-maybe-check-target-boehm-gc: check-target-boehm-gc\n-\n-check-target-boehm-gc:\n-\t@: $(MAKE); $(unstage)\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\t(cd $(TARGET_SUBDIR)/boehm-gc && \\\n-\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)   check)\n-\n-@endif target-boehm-gc\n-\n-.PHONY: install-target-boehm-gc maybe-install-target-boehm-gc\n-maybe-install-target-boehm-gc:\n-@if target-boehm-gc\n-maybe-install-target-boehm-gc: install-target-boehm-gc\n-\n-install-target-boehm-gc: installdirs\n-\t@: $(MAKE); $(unstage)\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\t(cd $(TARGET_SUBDIR)/boehm-gc && \\\n-\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install)\n-\n-@endif target-boehm-gc\n-\n-.PHONY: install-strip-target-boehm-gc maybe-install-strip-target-boehm-gc\n-maybe-install-strip-target-boehm-gc:\n-@if target-boehm-gc\n-maybe-install-strip-target-boehm-gc: install-strip-target-boehm-gc\n-\n-install-strip-target-boehm-gc: installdirs\n-\t@: $(MAKE); $(unstage)\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\t(cd $(TARGET_SUBDIR)/boehm-gc && \\\n-\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install-strip)\n-\n-@endif target-boehm-gc\n-\n-# Other targets (info, dvi, pdf, etc.)\n-\n-.PHONY: maybe-info-target-boehm-gc info-target-boehm-gc\n-maybe-info-target-boehm-gc:\n-@if target-boehm-gc\n-maybe-info-target-boehm-gc: info-target-boehm-gc\n-\n-info-target-boehm-gc: \\\n-    configure-target-boehm-gc \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/boehm-gc/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing info in $(TARGET_SUBDIR)/boehm-gc\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/boehm-gc && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           info) \\\n-\t  || exit 1\n-\n-@endif target-boehm-gc\n-\n-.PHONY: maybe-dvi-target-boehm-gc dvi-target-boehm-gc\n-maybe-dvi-target-boehm-gc:\n-@if target-boehm-gc\n-maybe-dvi-target-boehm-gc: dvi-target-boehm-gc\n-\n-dvi-target-boehm-gc: \\\n-    configure-target-boehm-gc \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/boehm-gc/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing dvi in $(TARGET_SUBDIR)/boehm-gc\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/boehm-gc && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           dvi) \\\n-\t  || exit 1\n-\n-@endif target-boehm-gc\n-\n-.PHONY: maybe-pdf-target-boehm-gc pdf-target-boehm-gc\n-maybe-pdf-target-boehm-gc:\n-@if target-boehm-gc\n-maybe-pdf-target-boehm-gc: pdf-target-boehm-gc\n-\n-pdf-target-boehm-gc: \\\n-    configure-target-boehm-gc \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/boehm-gc/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing pdf in $(TARGET_SUBDIR)/boehm-gc\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/boehm-gc && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           pdf) \\\n-\t  || exit 1\n-\n-@endif target-boehm-gc\n-\n-.PHONY: maybe-html-target-boehm-gc html-target-boehm-gc\n-maybe-html-target-boehm-gc:\n-@if target-boehm-gc\n-maybe-html-target-boehm-gc: html-target-boehm-gc\n-\n-html-target-boehm-gc: \\\n-    configure-target-boehm-gc \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/boehm-gc/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing html in $(TARGET_SUBDIR)/boehm-gc\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/boehm-gc && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           html) \\\n-\t  || exit 1\n-\n-@endif target-boehm-gc\n-\n-.PHONY: maybe-TAGS-target-boehm-gc TAGS-target-boehm-gc\n-maybe-TAGS-target-boehm-gc:\n-@if target-boehm-gc\n-maybe-TAGS-target-boehm-gc: TAGS-target-boehm-gc\n-\n-TAGS-target-boehm-gc: \\\n-    configure-target-boehm-gc \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/boehm-gc/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing TAGS in $(TARGET_SUBDIR)/boehm-gc\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/boehm-gc && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           TAGS) \\\n-\t  || exit 1\n-\n-@endif target-boehm-gc\n-\n-.PHONY: maybe-install-info-target-boehm-gc install-info-target-boehm-gc\n-maybe-install-info-target-boehm-gc:\n-@if target-boehm-gc\n-maybe-install-info-target-boehm-gc: install-info-target-boehm-gc\n-\n-install-info-target-boehm-gc: \\\n-    configure-target-boehm-gc \\\n-    info-target-boehm-gc \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/boehm-gc/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing install-info in $(TARGET_SUBDIR)/boehm-gc\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/boehm-gc && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           install-info) \\\n-\t  || exit 1\n-\n-@endif target-boehm-gc\n-\n-.PHONY: maybe-install-pdf-target-boehm-gc install-pdf-target-boehm-gc\n-maybe-install-pdf-target-boehm-gc:\n-@if target-boehm-gc\n-maybe-install-pdf-target-boehm-gc: install-pdf-target-boehm-gc\n-\n-install-pdf-target-boehm-gc: \\\n-    configure-target-boehm-gc \\\n-    pdf-target-boehm-gc \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/boehm-gc/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing install-pdf in $(TARGET_SUBDIR)/boehm-gc\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/boehm-gc && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           install-pdf) \\\n-\t  || exit 1\n-\n-@endif target-boehm-gc\n-\n-.PHONY: maybe-install-html-target-boehm-gc install-html-target-boehm-gc\n-maybe-install-html-target-boehm-gc:\n-@if target-boehm-gc\n-maybe-install-html-target-boehm-gc: install-html-target-boehm-gc\n-\n-install-html-target-boehm-gc: \\\n-    configure-target-boehm-gc \\\n-    html-target-boehm-gc \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/boehm-gc/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing install-html in $(TARGET_SUBDIR)/boehm-gc\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/boehm-gc && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           install-html) \\\n-\t  || exit 1\n-\n-@endif target-boehm-gc\n-\n-.PHONY: maybe-installcheck-target-boehm-gc installcheck-target-boehm-gc\n-maybe-installcheck-target-boehm-gc:\n-@if target-boehm-gc\n-maybe-installcheck-target-boehm-gc: installcheck-target-boehm-gc\n-\n-installcheck-target-boehm-gc: \\\n-    configure-target-boehm-gc \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/boehm-gc/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing installcheck in $(TARGET_SUBDIR)/boehm-gc\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/boehm-gc && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           installcheck) \\\n-\t  || exit 1\n-\n-@endif target-boehm-gc\n-\n-.PHONY: maybe-mostlyclean-target-boehm-gc mostlyclean-target-boehm-gc\n-maybe-mostlyclean-target-boehm-gc:\n-@if target-boehm-gc\n-maybe-mostlyclean-target-boehm-gc: mostlyclean-target-boehm-gc\n-\n-mostlyclean-target-boehm-gc: \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/boehm-gc/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing mostlyclean in $(TARGET_SUBDIR)/boehm-gc\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/boehm-gc && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           mostlyclean) \\\n-\t  || exit 1\n-\n-@endif target-boehm-gc\n-\n-.PHONY: maybe-clean-target-boehm-gc clean-target-boehm-gc\n-maybe-clean-target-boehm-gc:\n-@if target-boehm-gc\n-maybe-clean-target-boehm-gc: clean-target-boehm-gc\n-\n-clean-target-boehm-gc: \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/boehm-gc/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing clean in $(TARGET_SUBDIR)/boehm-gc\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/boehm-gc && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           clean) \\\n-\t  || exit 1\n-\n-@endif target-boehm-gc\n-\n-.PHONY: maybe-distclean-target-boehm-gc distclean-target-boehm-gc\n-maybe-distclean-target-boehm-gc:\n-@if target-boehm-gc\n-maybe-distclean-target-boehm-gc: distclean-target-boehm-gc\n-\n-distclean-target-boehm-gc: \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/boehm-gc/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing distclean in $(TARGET_SUBDIR)/boehm-gc\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/boehm-gc && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           distclean) \\\n-\t  || exit 1\n-\n-@endif target-boehm-gc\n-\n-.PHONY: maybe-maintainer-clean-target-boehm-gc maintainer-clean-target-boehm-gc\n-maybe-maintainer-clean-target-boehm-gc:\n-@if target-boehm-gc\n-maybe-maintainer-clean-target-boehm-gc: maintainer-clean-target-boehm-gc\n-\n-maintainer-clean-target-boehm-gc: \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/boehm-gc/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing maintainer-clean in $(TARGET_SUBDIR)/boehm-gc\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/boehm-gc && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           maintainer-clean) \\\n-\t  || exit 1\n-\n-@endif target-boehm-gc\n-\n-\n-\n-\n-\n .PHONY: configure-target-rda maybe-configure-target-rda\n maybe-configure-target-rda:\n @if gcc-bootstrap\n@@ -54740,7 +54264,6 @@ configure-target-winsup: stage_last\n configure-target-libgloss: stage_last\n configure-target-libffi: stage_last\n configure-target-zlib: stage_last\n-configure-target-boehm-gc: stage_last\n configure-target-rda: stage_last\n configure-target-libada: stage_last\n configure-stage1-target-libgomp: maybe-all-stage1-gcc\n@@ -54775,7 +54298,6 @@ configure-target-winsup: maybe-all-gcc\n configure-target-libgloss: maybe-all-gcc\n configure-target-libffi: maybe-all-gcc\n configure-target-zlib: maybe-all-gcc\n-configure-target-boehm-gc: maybe-all-gcc\n configure-target-rda: maybe-all-gcc\n configure-target-libada: maybe-all-gcc\n configure-target-libgomp: maybe-all-gcc\n@@ -55790,16 +55312,13 @@ all-flex: maybe-all-m4\n all-flex: maybe-all-build-texinfo\n all-m4: maybe-all-intl\n all-m4: maybe-all-build-texinfo\n-configure-target-boehm-gc: maybe-all-target-libstdc++-v3\n configure-target-fastjar: maybe-configure-target-zlib\n all-target-fastjar: maybe-all-target-zlib\n configure-target-libgo: maybe-configure-target-libffi\n configure-target-libgo: maybe-all-target-libstdc++-v3\n all-target-libgo: maybe-all-target-libbacktrace\n all-target-libgo: maybe-all-target-libffi\n all-target-libgo: maybe-all-target-libatomic\n-configure-target-libobjc: maybe-configure-target-boehm-gc\n-all-target-libobjc: maybe-all-target-boehm-gc\n configure-target-libstdc++-v3: maybe-configure-target-libgomp\n \n configure-stage1-target-libstdc++-v3: maybe-configure-stage1-target-libgomp\n@@ -55931,7 +55450,6 @@ configure-target-winsup: maybe-all-target-libgcc\n configure-target-libgloss: maybe-all-target-libgcc\n configure-target-libffi: maybe-all-target-libgcc\n configure-target-zlib: maybe-all-target-libgcc\n-configure-target-boehm-gc: maybe-all-target-libgcc\n configure-target-rda: maybe-all-target-libgcc\n configure-target-libada: maybe-all-target-libgcc\n configure-target-libgomp: maybe-all-target-libgcc\n@@ -55978,8 +55496,6 @@ configure-target-libffi: maybe-all-target-libstdc++-v3\n \n configure-target-zlib: maybe-all-target-newlib maybe-all-target-libgloss\n \n-configure-target-boehm-gc: maybe-all-target-newlib maybe-all-target-libgloss\n-\n configure-target-rda: maybe-all-target-newlib maybe-all-target-libgloss\n \n configure-target-libada: maybe-all-target-newlib maybe-all-target-libgloss"}, {"sha": "f4024a7978fe283bb095b668e90a195253902ce0", "filename": "boehm-gc/AmigaOS.c", "status": "removed", "additions": 0, "deletions": 623, "changes": 623, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FAmigaOS.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FAmigaOS.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FAmigaOS.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,623 +0,0 @@\n-\n-\n-/******************************************************************\n-\n-  AmigaOS-spesific routines for GC.\n-  This file is normally included from os_dep.c\n-\n-******************************************************************/\n-\n-\n-#if !defined(GC_AMIGA_DEF) && !defined(GC_AMIGA_SB) && !defined(GC_AMIGA_DS) && !defined(GC_AMIGA_AM)\n-# include \"gc_priv.h\"\n-# include <stdio.h>\n-# include <signal.h>\n-# define GC_AMIGA_DEF\n-# define GC_AMIGA_SB\n-# define GC_AMIGA_DS\n-# define GC_AMIGA_AM\n-#endif\n-\n-\n-#ifdef GC_AMIGA_DEF\n-\n-# ifndef __GNUC__\n-#   include <exec/exec.h>\n-# endif\n-# include <proto/exec.h>\n-# include <proto/dos.h>\n-# include <dos/dosextens.h>\n-# include <workbench/startup.h>\n-\n-#endif\n-\n-\n-\n-\n-#ifdef GC_AMIGA_SB\n-\n-/******************************************************************\n-   Find the base of the stack.\n-******************************************************************/\n-\n-ptr_t GC_get_stack_base()\n-{\n-    struct Process *proc = (struct Process*)SysBase->ThisTask;\n- \n-    /* Reference: Amiga Guru Book Pages: 42,567,574 */\n-    if (proc->pr_Task.tc_Node.ln_Type==NT_PROCESS\n-        && proc->pr_CLI != NULL) {\n-\t/* first ULONG is StackSize */\n-\t/*longPtr = proc->pr_ReturnAddr;\n-\tsize = longPtr[0];*/\n-\n-\treturn (char *)proc->pr_ReturnAddr + sizeof(ULONG);\n-    } else {\n-\treturn (char *)proc->pr_Task.tc_SPUpper;\n-    }\n-}\n-\n-#if 0 /* old version */\n-ptr_t GC_get_stack_base()\n-{\n-    extern struct WBStartup *_WBenchMsg;\n-    extern long __base;\n-    extern long __stack;\n-    struct Task *task;\n-    struct Process *proc;\n-    struct CommandLineInterface *cli;\n-    long size;\n-\n-    if ((task = FindTask(0)) == 0) {\n-\tGC_err_puts(\"Cannot find own task structure\\n\");\n-\tABORT(\"task missing\");\n-    }\n-    proc = (struct Process *)task;\n-    cli = BADDR(proc->pr_CLI);\n-\n-    if (_WBenchMsg != 0 || cli == 0) {\n-\tsize = (char *)task->tc_SPUpper - (char *)task->tc_SPLower;\n-    } else {\n-\tsize = cli->cli_DefaultStack * 4;\n-    }\n-    return (ptr_t)(__base + GC_max(size, __stack));\n-}\n-#endif\n-\n-\n-#endif\n-\n-\n-#ifdef GC_AMIGA_DS\n-/******************************************************************\n-   Register data segments.\n-******************************************************************/\n-\n-   void GC_register_data_segments()\n-   {\n-     struct Process\t*proc;\n-     struct CommandLineInterface *cli;\n-     BPTR myseglist;\n-     ULONG *data;\n- \n-     int\tnum;\n-\n-\n-#    ifdef __GNUC__\n-        ULONG dataSegSize;\n-        GC_bool found_segment = FALSE;\n-\textern char __data_size[];\n-\n-\tdataSegSize=__data_size+8;\n-\t/* Can`t find the Location of __data_size, because\n-           it`s possible that is it, inside the segment. */\n-\n-#     endif\n-\n-\tproc= (struct Process*)SysBase->ThisTask;\n-\n-\t/* Reference: Amiga Guru Book Pages: 538ff,565,573\n-\t\t     and XOper.asm */\n-\tif (proc->pr_Task.tc_Node.ln_Type==NT_PROCESS) {\n-\t  if (proc->pr_CLI == NULL) {\n-\t    myseglist = proc->pr_SegList;\n-\t  } else {\n-\t    /* ProcLoaded\t'Loaded as a command: '*/\n-\t    cli = BADDR(proc->pr_CLI);\n-\t    myseglist = cli->cli_Module;\n-\t  }\n-\t} else {\n-\t  ABORT(\"Not a Process.\");\n- \t}\n-\n-\tif (myseglist == NULL) {\n-\t    ABORT(\"Arrrgh.. can't find segments, aborting\");\n- \t}\n-\n-\t/* xoper hunks Shell Process */\n-\n-\tnum=0;\n-        for (data = (ULONG *)BADDR(myseglist); data != NULL;\n-             data = (ULONG *)BADDR(data[0])) {\n-\t  if (((ULONG) GC_register_data_segments < (ULONG) &data[1]) ||\n-\t      ((ULONG) GC_register_data_segments > (ULONG) &data[1] + data[-1])) {\n-#             ifdef __GNUC__\n-\t\tif (dataSegSize == data[-1]) {\n-\t\t  found_segment = TRUE;\n-\t\t}\n-# \t      endif\n-\t      GC_add_roots_inner((char *)&data[1],\n-\t\t\t\t ((char *)&data[1]) + data[-1], FALSE);\n-          }\n-          ++num;\n-        } /* for */\n-# \tifdef __GNUC__\n-\t   if (!found_segment) {\n-\t     ABORT(\"Can`t find correct Segments.\\nSolution: Use an newer version of ixemul.library\");\n-\t   }\n-# \tendif\n-  }\n-\n-#if 0 /* old version */\n-  void GC_register_data_segments()\n-  {\n-    extern struct WBStartup *_WBenchMsg;\n-    struct Process\t*proc;\n-    struct CommandLineInterface *cli;\n-    BPTR myseglist;\n-    ULONG *data;\n-\n-    if ( _WBenchMsg != 0 ) {\n-\tif ((myseglist = _WBenchMsg->sm_Segment) == 0) {\n-\t    GC_err_puts(\"No seglist from workbench\\n\");\n-\t    return;\n-\t}\n-    } else {\n-\tif ((proc = (struct Process *)FindTask(0)) == 0) {\n-\t    GC_err_puts(\"Cannot find process structure\\n\");\n-\t    return;\n-\t}\n-\tif ((cli = BADDR(proc->pr_CLI)) == 0) {\n-\t    GC_err_puts(\"No CLI\\n\");\n-\t    return;\n-\t}\n-\tif ((myseglist = cli->cli_Module) == 0) {\n-\t    GC_err_puts(\"No seglist from CLI\\n\");\n-\t    return;\n-\t}\n-    }\n-\n-    for (data = (ULONG *)BADDR(myseglist); data != 0;\n-         data = (ULONG *)BADDR(data[0])) {\n-#        ifdef AMIGA_SKIP_SEG\n-           if (((ULONG) GC_register_data_segments < (ULONG) &data[1]) ||\n-           ((ULONG) GC_register_data_segments > (ULONG) &data[1] + data[-1])) {\n-#\t else\n-      \t   {\n-#\t endif /* AMIGA_SKIP_SEG */\n-          GC_add_roots_inner((char *)&data[1],\n-          \t\t     ((char *)&data[1]) + data[-1], FALSE);\n-         }\n-    }\n-  }\n-#endif /* old version */\n-\n-\n-#endif\n-\n-\n-\n-#ifdef GC_AMIGA_AM\n-\n-#ifndef GC_AMIGA_FASTALLOC\n-\n-void *GC_amiga_allocwrapper(size_t size,void *(*AllocFunction)(size_t size2)){\n-\treturn (*AllocFunction)(size);\n-}\n-\n-void *(*GC_amiga_allocwrapper_do)(size_t size,void *(*AllocFunction)(size_t size2))\n-\t=GC_amiga_allocwrapper;\n-\n-#else\n-\n-\n-\n-\n-void *GC_amiga_allocwrapper_firsttime(size_t size,void *(*AllocFunction)(size_t size2));\n-\n-void *(*GC_amiga_allocwrapper_do)(size_t size,void *(*AllocFunction)(size_t size2))\n-\t=GC_amiga_allocwrapper_firsttime;\n-\n-\n-/******************************************************************\n-   Amiga-spesific routines to obtain memory, and force GC to give\n-   back fast-mem whenever possible.\n-\tThese hacks makes gc-programs go many times faster when\n-   the amiga is low on memory, and are therefore strictly necesarry.\n-\n-   -Kjetil S. Matheussen, 2000.\n-******************************************************************/\n-\n-\n-\n-/* List-header for all allocated memory. */\n-\n-struct GC_Amiga_AllocedMemoryHeader{\n-\tULONG size;\n-\tstruct GC_Amiga_AllocedMemoryHeader *next;\n-};\n-struct GC_Amiga_AllocedMemoryHeader *GC_AMIGAMEM=(struct GC_Amiga_AllocedMemoryHeader *)(int)~(NULL);\n-\n-\n-\n-/* Type of memory. Once in the execution of a program, this might change to MEMF_ANY|MEMF_CLEAR */\n-\n-ULONG GC_AMIGA_MEMF = MEMF_FAST | MEMF_CLEAR;\n-\n-\n-/* Prevents GC_amiga_get_mem from allocating memory if this one is TRUE. */\n-#ifndef GC_AMIGA_ONLYFAST\n-BOOL GC_amiga_dontalloc=FALSE;\n-#endif\n-\n-#ifdef GC_AMIGA_PRINTSTATS\n-int succ=0,succ2=0;\n-int nsucc=0,nsucc2=0;\n-int nullretries=0;\n-int numcollects=0;\n-int chipa=0;\n-int allochip=0;\n-int allocfast=0;\n-int cur0=0;\n-int cur1=0;\n-int cur10=0;\n-int cur50=0;\n-int cur150=0;\n-int cur151=0;\n-int ncur0=0;\n-int ncur1=0;\n-int ncur10=0;\n-int ncur50=0;\n-int ncur150=0;\n-int ncur151=0;\n-#endif\n-\n-/* Free everything at program-end. */\n-\n-void GC_amiga_free_all_mem(void){\n-\tstruct GC_Amiga_AllocedMemoryHeader *gc_am=(struct GC_Amiga_AllocedMemoryHeader *)(~(int)(GC_AMIGAMEM));\n-\tstruct GC_Amiga_AllocedMemoryHeader *temp;\n-\n-#ifdef GC_AMIGA_PRINTSTATS\n-\tprintf(\"\\n\\n\"\n-\t\t\"%d bytes of chip-mem, and %d bytes of fast-mem where allocated from the OS.\\n\",\n-\t\tallochip,allocfast\n-\t);\n-\tprintf(\n-\t\t\"%d bytes of chip-mem were returned from the GC_AMIGA_FASTALLOC supported allocating functions.\\n\",\n-\t\tchipa\n-\t);\n-\tprintf(\"\\n\");\n-\tprintf(\"GC_gcollect was called %d times to avoid returning NULL or start allocating with the MEMF_ANY flag.\\n\",numcollects);\n-\tprintf(\"%d of them was a success. (the others had to use allocation from the OS.)\\n\",nullretries);\n-\tprintf(\"\\n\");\n-\tprintf(\"Succeded forcing %d gc-allocations (%d bytes) of chip-mem to be fast-mem.\\n\",succ,succ2);\n-\tprintf(\"Failed forcing %d gc-allocations (%d bytes) of chip-mem to be fast-mem.\\n\",nsucc,nsucc2);\n-\tprintf(\"\\n\");\n-\tprintf(\n-\t\t\"Number of retries before succeding a chip->fast force:\\n\"\n-\t\t\"0: %d, 1: %d, 2-9: %d, 10-49: %d, 50-149: %d, >150: %d\\n\",\n-\t\tcur0,cur1,cur10,cur50,cur150,cur151\n-\t);\n-\tprintf(\n-\t\t\"Number of retries before giving up a chip->fast force:\\n\"\n-\t\t\"0: %d, 1: %d, 2-9: %d, 10-49: %d, 50-149: %d, >150: %d\\n\",\n-\t\tncur0,ncur1,ncur10,ncur50,ncur150,ncur151\n-\t);\n-#endif\n-\n-\twhile(gc_am!=NULL){\n-\t\ttemp=gc_am->next;\n-\t\tFreeMem(gc_am,gc_am->size);\n-\t\tgc_am=(struct GC_Amiga_AllocedMemoryHeader *)(~(int)(temp));\n-\t}\n-}\n-\n-#ifndef GC_AMIGA_ONLYFAST\n-\n-/* All memory with address lower than this one is chip-mem. */\n-\n-char *chipmax;\n-\n-\n-/*\n- * Allways set to the last size of memory tried to be allocated.\n- * Needed to ensure allocation when the size is bigger than 100000.\n- *\n- */\n-size_t latestsize;\n-\n-#endif\n-\n-\n-/*\n- * The actual function that is called with the GET_MEM macro.\n- *\n- */\n-\n-void *GC_amiga_get_mem(size_t size){\n-\tstruct GC_Amiga_AllocedMemoryHeader *gc_am;\n-\n-#ifndef GC_AMIGA_ONLYFAST\n-\tif(GC_amiga_dontalloc==TRUE){\n-//\t\tprintf(\"rejected, size: %d, latestsize: %d\\n\",size,latestsize);\n-\t\treturn NULL;\n-\t}\n-\n-\t// We really don't want to use chip-mem, but if we must, then as little as possible.\n-\tif(GC_AMIGA_MEMF==(MEMF_ANY|MEMF_CLEAR) && size>100000 && latestsize<50000) return NULL;\n-#endif\n-\n-\tgc_am=AllocMem((ULONG)(size + sizeof(struct GC_Amiga_AllocedMemoryHeader)),GC_AMIGA_MEMF);\n-\tif(gc_am==NULL) return NULL;\n-\n-\tgc_am->next=GC_AMIGAMEM;\n-\tgc_am->size=size + sizeof(struct GC_Amiga_AllocedMemoryHeader);\n-\tGC_AMIGAMEM=(struct GC_Amiga_AllocedMemoryHeader *)(~(int)(gc_am));\n-\n-//\tprintf(\"Allocated %d (%d) bytes at address: %x. Latest: %d\\n\",size,tot,gc_am,latestsize);\n-\n-#ifdef GC_AMIGA_PRINTSTATS\n-\tif((char *)gc_am<chipmax){\n-\t\tallochip+=size;\n-\t}else{\n-\t\tallocfast+=size;\n-\t}\n-#endif\n-\n-\treturn gc_am+1;\n-\n-}\n-\n-\n-\n-\n-#ifndef GC_AMIGA_ONLYFAST\n-\n-/* Tries very hard to force GC to find fast-mem to return. Done recursively\n- * to hold the rejected memory-pointers reachable from the collector in an\n- * easy way.\n- *\n- */\n-#ifdef GC_AMIGA_RETRY\n-void *GC_amiga_rec_alloc(size_t size,void *(*AllocFunction)(size_t size2),const int rec){\n-\tvoid *ret;\n-\n-\tret=(*AllocFunction)(size);\n-\n-#ifdef GC_AMIGA_PRINTSTATS\n-\tif((char *)ret>chipmax || ret==NULL){\n-\t\tif(ret==NULL){\n-\t\t\tnsucc++;\n-\t\t\tnsucc2+=size;\n-\t\t\tif(rec==0) ncur0++;\n-\t\t\tif(rec==1) ncur1++;\n-\t\t\tif(rec>1 && rec<10) ncur10++;\n-\t\t\tif(rec>=10 && rec<50) ncur50++;\n-\t\t\tif(rec>=50 && rec<150) ncur150++;\n-\t\t\tif(rec>=150) ncur151++;\n-\t\t}else{\n-\t\t\tsucc++;\n-\t\t\tsucc2+=size;\n-\t\t\tif(rec==0) cur0++;\n-\t\t\tif(rec==1) cur1++;\n-\t\t\tif(rec>1 && rec<10) cur10++;\n-\t\t\tif(rec>=10 && rec<50) cur50++;\n-\t\t\tif(rec>=50 && rec<150) cur150++;\n-\t\t\tif(rec>=150) cur151++;\n-\t\t}\n-\t}\n-#endif\n-\n-\tif (((char *)ret)<=chipmax && ret!=NULL && (rec<(size>500000?9:size/5000))){\n-\t\tret=GC_amiga_rec_alloc(size,AllocFunction,rec+1);\n-//\t\tGC_free(ret2);\n-\t}\n-\n-\treturn ret;\n-}\n-#endif\n-\n-\n-/* The allocating-functions defined inside the amiga-blocks in gc.h is called\n- * via these functions.\n- */\n-\n-\n-void *GC_amiga_allocwrapper_any(size_t size,void *(*AllocFunction)(size_t size2)){\n-\tvoid *ret,*ret2;\n-\n-\tGC_amiga_dontalloc=TRUE;\t// Pretty tough thing to do, but its indeed necesarry.\n-\tlatestsize=size;\n-\n-\tret=(*AllocFunction)(size);\n-\n-\tif(((char *)ret) <= chipmax){\n-\t\tif(ret==NULL){\n-\t\t\t//Give GC access to allocate memory.\n-#ifdef GC_AMIGA_GC\n-\t\t\tif(!GC_dont_gc){\n-\t\t\t\tGC_gcollect();\n-#ifdef GC_AMIGA_PRINTSTATS\n-\t\t\t\tnumcollects++;\n-#endif\n-\t\t\t\tret=(*AllocFunction)(size);\n-\t\t\t}\n-#endif\n-\t\t\tif(ret==NULL){\n-\t\t\t\tGC_amiga_dontalloc=FALSE;\n-\t\t\t\tret=(*AllocFunction)(size);\n-\t\t\t\tif(ret==NULL){\n-\t\t\t\t\tWARN(\"Out of Memory!  Returning NIL!\\n\", 0);\n-\t\t\t\t}\n-\t\t\t}\n-#ifdef GC_AMIGA_PRINTSTATS\n-\t\t\telse{\n-\t\t\t\tnullretries++;\n-\t\t\t}\n-\t\t\tif(ret!=NULL && (char *)ret<=chipmax) chipa+=size;\n-#endif\n-\t\t}\n-#ifdef GC_AMIGA_RETRY\n-\t\telse{\n-\t\t\t/* We got chip-mem. Better try again and again and again etc., we might get fast-mem sooner or later... */\n-\t\t\t/* Using gctest to check the effectiviness of doing this, does seldom give a very good result. */\n-\t\t\t/* However, real programs doesn't normally rapidly allocate and deallocate. */\n-//\t\t\tprintf(\"trying to force... %d bytes... \",size);\n-\t\t\tif(\n-\t\t\t\tAllocFunction!=GC_malloc_uncollectable\n-#ifdef ATOMIC_UNCOLLECTABLE\n-\t\t\t\t&& AllocFunction!=GC_malloc_atomic_uncollectable\n-#endif\n-\t\t\t){\n-\t\t\t\tret2=GC_amiga_rec_alloc(size,AllocFunction,0);\n-\t\t\t}else{\n-\t\t\t\tret2=(*AllocFunction)(size);\n-#ifdef GC_AMIGA_PRINTSTATS\n-\t\t\t\tif((char *)ret2<chipmax || ret2==NULL){\n-\t\t\t\t\tnsucc++;\n-\t\t\t\t\tnsucc2+=size;\n-\t\t\t\t\tncur0++;\n-\t\t\t\t}else{\n-\t\t\t\t\tsucc++;\n-\t\t\t\t\tsucc2+=size;\n-\t\t\t\t\tcur0++;\n-\t\t\t\t}\n-#endif\n-\t\t\t}\n-\t\t\tif(((char *)ret2)>chipmax){\n-//\t\t\t\tprintf(\"Succeeded.\\n\");\n-\t\t\t\tGC_free(ret);\n-\t\t\t\tret=ret2;\n-\t\t\t}else{\n-\t\t\t\tGC_free(ret2);\n-//\t\t\t\tprintf(\"But did not succeed.\\n\");\n-\t\t\t}\n-\t\t}\n-#endif\n-\t}\n-\n-\tGC_amiga_dontalloc=FALSE;\n-\n-\treturn ret;\n-}\n-\n-\n-\n-void (*GC_amiga_toany)(void)=NULL;\n-\n-void GC_amiga_set_toany(void (*func)(void)){\n-\tGC_amiga_toany=func;\n-}\n-\n-#endif // !GC_AMIGA_ONLYFAST\n-\n-\n-void *GC_amiga_allocwrapper_fast(size_t size,void *(*AllocFunction)(size_t size2)){\n-\tvoid *ret;\n-\n-\tret=(*AllocFunction)(size);\n-\n-\tif(ret==NULL){\n-\t\t// Enable chip-mem allocation.\n-//\t\tprintf(\"ret==NULL\\n\");\n-#ifdef GC_AMIGA_GC\n-\t\tif(!GC_dont_gc){\n-\t\t\tGC_gcollect();\n-#ifdef GC_AMIGA_PRINTSTATS\n-\t\t\tnumcollects++;\n-#endif\n-\t\t\tret=(*AllocFunction)(size);\n-\t\t}\n-#endif\n-\t\tif(ret==NULL){\n-#ifndef GC_AMIGA_ONLYFAST\n-\t\t\tGC_AMIGA_MEMF=MEMF_ANY | MEMF_CLEAR;\n-\t\t\tif(GC_amiga_toany!=NULL) (*GC_amiga_toany)();\n-\t\t\tGC_amiga_allocwrapper_do=GC_amiga_allocwrapper_any;\n-\t\t\treturn GC_amiga_allocwrapper_any(size,AllocFunction);\n-#endif\n-\t\t}\n-#ifdef GC_AMIGA_PRINTSTATS\n-\t\telse{\n-\t\t\tnullretries++;\n-\t\t}\n-#endif\n-\t}\n-\n-\treturn ret;\n-}\n-\n-void *GC_amiga_allocwrapper_firsttime(size_t size,void *(*AllocFunction)(size_t size2)){\n-\tatexit(&GC_amiga_free_all_mem);\n-\tchipmax=(char *)SysBase->MaxLocMem;\t\t// For people still having SysBase in chip-mem, this might speed up a bit.\n-\tGC_amiga_allocwrapper_do=GC_amiga_allocwrapper_fast;\n-\treturn GC_amiga_allocwrapper_fast(size,AllocFunction);\n-}\n-\n-\n-#endif //GC_AMIGA_FASTALLOC\n-\n-\n-\n-/*\n- * The wrapped realloc function.\n- *\n- */\n-void *GC_amiga_realloc(void *old_object,size_t new_size_in_bytes){\n-#ifndef GC_AMIGA_FASTALLOC\n-\treturn GC_realloc(old_object,new_size_in_bytes);\n-#else\n-\tvoid *ret;\n-\tlatestsize=new_size_in_bytes;\n-\tret=GC_realloc(old_object,new_size_in_bytes);\n-\tif(ret==NULL && GC_AMIGA_MEMF==(MEMF_FAST | MEMF_CLEAR)){\n-\t\t/* Out of fast-mem. */\n-#ifdef GC_AMIGA_GC\n-\t\tif(!GC_dont_gc){\n-\t\t\tGC_gcollect();\n-#ifdef GC_AMIGA_PRINTSTATS\n-\t\t\tnumcollects++;\n-#endif\n-\t\t\tret=GC_realloc(old_object,new_size_in_bytes);\n-\t\t}\n-#endif\n-\t\tif(ret==NULL){\n-#ifndef GC_AMIGA_ONLYFAST\n-\t\t\tGC_AMIGA_MEMF=MEMF_ANY | MEMF_CLEAR;\n-\t\t\tif(GC_amiga_toany!=NULL) (*GC_amiga_toany)();\n-\t\t\tGC_amiga_allocwrapper_do=GC_amiga_allocwrapper_any;\n-\t\t\tret=GC_realloc(old_object,new_size_in_bytes);\n-#endif\n-\t\t}\n-#ifdef GC_AMIGA_PRINTSTATS\n-\t\telse{\n-\t\t\tnullretries++;\n-\t\t}\n-#endif\n-\t}\n-\tif(ret==NULL){\n-\t\tWARN(\"Out of Memory!  Returning NIL!\\n\", 0);\n-\t}\n-#ifdef GC_AMIGA_PRINTSTATS\n-\tif(((char *)ret)<chipmax && ret!=NULL){\n-\t\tchipa+=new_size_in_bytes;\n-\t}\n-#endif\n-\treturn ret;\n-#endif\n-}\n-\n-#endif //GC_AMIGA_AM\n-\n-"}, {"sha": "e21bc3d8dfe22efeef43bca48e5b9360c624af8c", "filename": "boehm-gc/BCC_MAKEFILE", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FBCC_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FBCC_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FBCC_MAKEFILE?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,88 +0,0 @@\n-# Makefile for Borland C++ 5.5 on NT\r\n-# If you have the Borland assembler, remove \"-DUSE_GENERIC\"\r\n-#\r\n-bc=\t   c:\\Borland\\BCC55\r\n-bcbin=\t   $(bc)\\bin\r\n-bclib=\t   $(bc)\\lib\r\n-bcinclude= $(bc)\\include\r\n-\r\n-gcinclude1 = $(bc)\\gc6.2\\include\r\n-gcinclude2 = $(bc)\\gc6.2\\cord\r\n-\r\n-cc=\t $(bcbin)\\bcc32\r\n-rc=\t $(bcbin)\\brc32\r\n-lib=\t $(bcbin)\\tlib\r\n-link=\t $(bcbin)\\ilink32\r\n-cflags=  -O2 -R -v- -vi -H -H=gc.csm -I$(bcinclude);$(gcinclude1);$(gcinclude2) -L$(bclib) \\\r\n-\t -w-pro -w-aus -w-par -w-ccc -w-rch -a4 -D__STDC__=0\r\n-#defines= -DSILENT\r\n-defines= -DSILENT -DALL_INTERIOR_POINTERS -DUSE_GENERIC -DNO_GETENV -DJAVA_FINALIZATION -DGC_OPERATOR_NEW_ARRAY\r\n-\r\n-.c.obj:\r\n-\t$(cc) @&&|\r\n-\t$(cdebug) $(cflags) $(cvars) $(defines) -o$* -c $*.c\r\n-|\r\n-\r\n-.cpp.obj:\r\n-\t$(cc) @&&|\r\n-\t$(cdebug) $(cflags) $(cvars) $(defines) -o$* -c $*.cpp\r\n-|\r\n-\r\n-.rc.res:\r\n-    $(rc) -i$(bcinclude) -r -fo$* $*.rc\r\n-\r\n-XXXOBJS= XXXalloc.obj XXXreclaim.obj XXXallchblk.obj XXXmisc.obj \\\r\n-    XXXmach_dep.obj XXXos_dep.obj XXXmark_rts.obj XXXheaders.obj XXXmark.obj \\\r\n-    XXXobj_map.obj XXXblacklst.obj XXXfinalize.obj XXXnew_hblk.obj \\\r\n-    XXXdbg_mlc.obj XXXmalloc.obj XXXstubborn.obj XXXdyn_load.obj \\\r\n-    XXXtypd_mlc.obj XXXptr_chck.obj XXXgc_cpp.obj XXXmallocx.obj\r\n-\r\n-OBJS= $(XXXOBJS:XXX=)\r\n-\r\n-all: gctest.exe cord\\de.exe test_cpp.exe\r\n-\r\n-$(OBJS) test.obj: include\\private\\gc_priv.h include\\private\\gc_hdrs.h include\\gc.h include\\private\\gcconfig.h MAKEFILE\r\n-\r\n-gc.lib: $(OBJS)\r\n-\tdel gc.lib\r\n-\t$(lib) $* @&&|\r\n-\t$(XXXOBJS:XXX=+)\r\n-|\r\n-\r\n-gctest.exe: tests\\test.obj gc.lib\r\n-    $(cc) @&&|\r\n-\t$(cflags) -W -e$* tests\\test.obj gc.lib\r\n-|\r\n-\r\n-cord\\de.obj cord\\de_win.obj: include\\cord.h include\\private\\cord_pos.h cord\\de_win.h \\\r\n-    cord\\de_cmds.h\r\n-\r\n-cord\\de.exe: cord\\cordbscs.obj cord\\cordxtra.obj cord\\de.obj cord\\de_win.obj \\\r\n-\tcord\\de_win.res gc.lib\r\n-\t$(cc) @&&|\r\n-\t$(cflags) -W -e$* cord\\cordbscs.obj cord\\cordxtra.obj \\\r\n-\tcord\\de.obj cord\\de_win.obj gc.lib\r\n-|\r\n-    $(rc) cord\\de_win.res cord\\de.exe\r\n-\r\n-gc_cpp.obj: include\\gc_cpp.h include\\gc.h\r\n-\r\n-gc_cpp.cpp: gc_cpp.cc\r\n-\tcopy gc_cpp.cc gc_cpp.cpp\r\n-\r\n-test_cpp.cpp: tests\\test_cpp.cc\r\n-\tcopy tests\\test_cpp.cc test_cpp.cpp\r\n-\r\n-test_cpp.exe: test_cpp.obj include\\gc_cpp.h include\\gc.h gc.lib\r\n-    $(cc) @&&|\r\n-\t$(cflags) -W -e$* test_cpp.obj gc.lib\r\n-|\r\n-\r\n-scratch:\r\n-    -del *.obj *.res *.exe *.csm cord\\*.obj cord\\*.res cord\\*.exe cord\\*.csm\r\n-\r\n-clean:\r\n-      del gc.lib\r\n-      del *.obj\r\n-      del tests\\test.obj\r\n-\r"}, {"sha": "2cb91b44c976d080275615d57b075faaa28964d3", "filename": "boehm-gc/ChangeLog", "status": "removed", "additions": 0, "deletions": 2679, "changes": 2679, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,2679 +0,0 @@\n-2016-11-15  Matthias Klose  <doko@ubuntu.com>\n-\n-\t* configure: Regenerate.\n-\n-2016-03-29  Samuel Thibault  <samuel.thibault@ens-lyon.org>\n-\n-\t* configure.host: Set gc_use_mmap on *-kfreebsd-gnu* and *-gnu*.\n-\t* include/private/gcconfig.h [HURD && USE_MMAP]: Define\n-\tUSE_MMAP_ANON.\n-\n-2016-03-16  Andreas Schwab  <schwab@suse.de>\n-\n-\t* include/private/gcconfig.h [AARCH64] (ALIGNMENT, CPP_WORDSZ):\n-\tDefine for __ILP32__.\n-\n-2015-10-09  David Malcolm  <dmalcolm@redhat.com>\n-\n-\t* testsuite/lib/boehm-gc.exp: Load multiline.exp before\n-\tprune.exp, using load_gcc_lib.\n-\n-2015-08-27  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\n-\t* os_dep.c [GC_SOLARIS_THREADS] (GC_dirty_init): Use\n-\t/proc/<pid>/pagedata instead of PIOCOPENPD.\n-\n-2015-07-24  Michael Darling  <darlingm@gmail.com>\n-\n-\tPR other/66259\n-\t* Makefile.direct: Reflects renaming of configure.in to configure.ac\n-\t* Makefile.dist: Likewise\n-\t* version.h: Likewise\n-\t* doc/README: Likewise\n-\n-2015-05-13  Michael Haubenwallner  <michael.haubenwallner@ssi-schaefer.com>\n-\n-\t* Makefile.in: Regenerated with automake-1.11.6.\n-\t* aclocal.m4: Likewise.\n-\t* configure: Likewise.\n-\t* include/Makefile.in: Likewise.\n-\t* include/gc_config.h.in: Likewise.\n-\t* testsuite/Makefile.in: Likewise.\n-\n-2014-12-18  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\n-\t* testsuite/lib/boehm-gc.exp: Load target-utils.exp.\n-\n-2014-11-21  H.J. Lu  <hongjiu.lu@intel.com>\n-\n-\tPR bootstrap/63784\n-\t* configure: Regenerated.\n-\n-2014-11-11  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n-\n-\tPR target/63610\n-\t* configure: Regenerate.\n-\n-2014-10-23  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\n-\t* include/gc.h [(sparc || __sparc) && sun] (GC_INIT): Remove\n-\tcomment and definition.\n-\n-2014-10-06  Marek Polacek  <polacek@redhat.com>\n-\n-\t* testsuite/boehm-gc.c/gctest.c: Fix defaulting to int.\n-\n-2014-05-13  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n-\n-\tFix current cygwin-64 build problems.\n-\t* include/gc_config_macros.h (GC_PTHREADS): Use __CYGWIN__ instead\n-\tof __CYGWIN32__ here.\n-\t* win32_threads.c (GC_push_all_stacks): Push all X86_64 registers.\n-\t(GC_get_thread_stack_base): Get the stack base for X86_64.\n-\n-2014-04-22  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR other/43620\n-\t* Makefile.am (AUTOMAKE_OPTIONS): Add no-dist.\n-\t* include/Makefile.am (AUTOMAKE_OPTIONS): Likewise.\n-\t* testsuite/Makefile.am (AUTOMAKE_OPTIONS): Likewise.\n-\t* Makefile.in: Regenerated.\n-\t* include/Makefile.in: Regenerated.\n-\t* testsuite/Makefile.in: Regenerated.\n-\n-2013-12-21  Andreas Tobler  <andreast@gcc.gnu.org>\n-\n-\t* include/private/gcconfig.h: Add FreeBSD powerpc64 defines.\n-\n-2013-09-20  Alan Modra  <amodra@gmail.com>\n-\n-\t* configure: Regenerate.\n-\n-2013-09-04  Matthias Klose  <doko@ubuntu.com>\n-\n-\t* Makefile.am (libgcjgc_la_LIBADD): Add EXTRA_TEST_LIBS.\n-\t* Makefile.in: Regenerate.\n-\n-2013-03-16  Yvan Roux <yvan.roux@linaro.org>\n-\n-\t* include/private/gcconfig.h (AARCH64): New macro (defined only if\n-\t__aarch64__).\n-\t(CPP_WORDSZ): Define for AArch64.\n-\t(MACH_TYPE): Likewise.\n-\t(ALIGNMENT): Likewise.\n-\t(HBLKSIZE): Likewise.\n-\t(OS_TYPE): Likewise.\n-\t(LINUX_STACKBOTTOM): Likewise.\n-\t(USE_GENERIC_PUSH_REGS): Likewise.\n-\t(DYNAMIC_LOADING): Likewise.\n-\t(DATASTART): Likewise.\n-\t(DATAEND): Likewise.\n-\t(STACKBOTTOM): Likewise.\n-\t(NOSYS): Likewise.\n-\t(mach_type_known): Define for AArch64 and comment update.\n-\n-2013-03-06  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\n-\t* os_dep.c [SOLARIS_STACKBOTTOM] (GC_solaris_stack_base): New\n-\tfunction.\n-\t[!BEOS && !AMIGA && !MSWIN32 && !MSWINCE && !OS2 && !NOSYS &&\n-\t!ECOS] (GC_get_stack_base): Use it.\n-\t* include/private/gcconfig.h [SPARC && SUNOS5]\n-\t(SOLARIS_STACKBOTTOM): Define.\n-\t(STACKBOTTOM, HEURISTIC2): Remove.\n-\t[I386 && SUNOS5]\n-\t(SOLARIS_STACKBOTTOM): Define.\n-\t(STACKBOTTOM): Remove.\n-\n-2012-11-04  Samuel Thibault  <samuel.thibault@gnu.org>\n-\n-\t* configure.ac: Add stanza for *-*-gnu* threads configuration.\n-\t* configure: Regenerate.\n-\t* include/gc_config.h.in: Likewise.\n-\t* dyn_load.c (_GNU_SOURCE): Define for __GNU__.\n-\t* include/gc_config_macros.h (_REENTRANT, GC_PTHREADS): Define for\n-\tGC_GNU_THREADS.\n-\t* include/private/gcconfig.h (DATASTART): Don't define for I386 &&\n-\tHURD.\n-\t(SIG_SUSPEND, SIG_THR_RESTART, SEARCH_FOR_DATA_START): Define for\n-\tI386 && HURD.\n-\t(UNIX_LIKE, REGISTER_LIBRARIES_EARLY): Define for HURD.\n-\t* os_dep.c (GC_init_linux_data_start): Handle for HURD.\n-\t* pthread_support.c (GC_thr_init): Add case for GC_GNU_THREADS.\n-\t* specific.c: Use for GC_GNU_THREADS.\n-\t* threadlibs.c: Add case for GC_GNU_THREADS.\n-\n-2012-09-14  David Edelsohn  <dje.gcc@gmail.com>\n-\n-\t* configure: Regenerated.\n-\n-2012-05-16  H.J. Lu  <hongjiu.lu@intel.com>\n-\n-\t* configure: Regenerated.\n-\n-2012-05-11  H.J. Lu  <hongjiu.lu@intel.com>\n-\n-\tMerge upstream changes\n-\t* include/private/gcconfig.h: (ALIGNMENT): Set to 4 for x32.\n-\t(CPP_WORDSZ): Set to 32 for x32.\n-\n-2012-02-27  Jack Howarth  <howarth@bromo.med.uc.edu>\n-\t    Patrick Marlier  <patrick.marlier@gmail.com>\n-\n-\tPR boehm-gc/48299\n-\t* testsuite/boehm-gc.c/thread_leak_test.c: Merge upstream changes.\n-\n-2012-02-23  Patrick Marlier  <patrick.marlier@gmail.com>\n-\t    Jack Howarth  <howarth@bromo.med.uc.edu>\n-\n-\tPR boehm-gc/52179\n-\t* include/gc_config.h.in: Undefine HAVE_PTHREAD_GET_STACKADDR_NP.\n-\t* include/private/gcconfig.h (DARWIN): Define STACKBOTTOM with\n-\tpthread_get_stackaddr_np when available.\n-\t* configure.ac (THREADS): Check availability of pthread_get_stackaddr_np.\n-\t* configure: Regenerate.\n-\n-2012-02-10  Kai Tietz  <ktietz@redhat.com>\n-\n-\tPR boehm-gc/48514\n-\t* include/gc_config_macros.h (GC_DLL): Define it for mingw-targets\n-\tonly, if we are actual in boehm-gc's build and DLL_EXPORT\n-\tis defined.\n-\n-2011-11-21  Andreas Tobler  <andreast@fgznet.ch>\n-\n-\t* configure: Regenerate.\n-\n-2011-08-08  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\n-\t* configure.ac (THREADS): Remove posix95.\n-\t* configure: Regenerate.\n-\n-2011-07-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\n-\tPR target/39150\n-\t* configure.ac (i?86-*-solaris2.[89]): Also accept\n-\tx86_64-*-solaris2.1?.\n-\t* configure: Regenerate.\n-\n-2011-06-29  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\n-\tPR libgcj/49451\n-\t* include/private/gcconfig.h [IRIX5 && _MIPS_SZPTR == 64]\n-\t(ELF_CLASS): Define.\n-\t* dyn_load.c [IRIX5]: Include <elf.h>.\n-\tInclude <obj.h> for O32, <objlist.h> for N32, N64.\n-\t[SUNOS5DL && USE_PROC_FOR_LIBRARIES] (obj_offset): Define.\n-\t[SUNOS4 && USE_PROC_FOR_LIBRARIES] (obj_offset): Define.\n-\t[IRIX5 && !USE_PROC_FOR_LIBRARIES] (struct link_map): Define.\n-\t(__rld_obj_head): Declare.\n-\t(l_next, l_addr, obj_offset): Define.\n-\t(GC_FirstDLOpenedLinkMap): New function.\n-\t[SUNOS4 || SUNOS5DL] (GC_register_dynamic_libraries): Also use on\n-\tIRIX5.\n-\tUse obj_offset.\n-\t[IRIX5 || (USE_PROC_FOR_LIBRARIES && !LINUX]\n-\t(GC_register_dynamic_libraries): Don't use /proc version on IRIX5.\n-\n-2011-04-19  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\n-\t* configure.ac (THREADS): Remove decosf1, irix, mach, os2.\n-\t* configure: Regenerate\n-\n-2011-04-06  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\n-\tPR testsuite/48480\n-\t* testsuite/lib/boehm-gc.exp (boehm-gc-dg-prune): Allow for path\n-\tto ranlib.\n-\n-2011-03-25  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\n-\tPR boehm-gc/11412\n-\t* configure.ac (THREADCFLAGS): New variable.\n-\tUse it instead of INCLUDES, AM_CPPFLAGS.\n-\t<*-*-kfreebsd*-gnu> (THREADDLLIBS): Rename to THREADLIBS.\n-\tRemove DG/UX support.\n-\t(AC_CONFIG_FILES): Add testsuite/Makefile.\n-\t* Makefile.am (AUTOMAKE_OPTIONS): Use foreign instead of cygnus.\n-\t(SUBDIRS): Add testsuite.\n-\t(libgcjgc_la_LIBADD): Remove $(UNWINDLIBS).\n-\t(AM_CXXFLAGS): Add $(THREADCFLAGS).\n-\t(AM_CFLAGS): Likewise.\n-\tRemove TESTS related variables.\n-\t* Makefile.in: Regenerate.\n-\t* configure: Regenerate.\n-\t* testsuite/Makefile.am: New file.\n-\t* testsuite/Makefile.in: New file.\n-\t* testsuite/lib/boehm-gc.exp: New file.\n-\t* testsuite/config/default.exp: New file.\n-\t* testsuite/boehm-gc.c/c.exp: New file.\n-\t* testsuite/boehm-gc.lib/lib.exp: New file.\n-\t* tests/test.c: Move ...\n-\t* testsuite/boehm-gc.c/gctest.c: ... here.\n-\t* tests/leak_test.c, tests/middle.c, tests/thread_leak_test.c,\n-\ttests/trace_test.c: Move ...\n-\t* testsuite/boehm-gc.c: ... here.\n-\t* testsuite/boehm-gc.c/trace_test.c: Skip everywhere.\n-\t* tests/staticrootslib.c, tests/staticrootstest.c: Move ...\n-\t* testsuite/boehm-gc.lib: ... here.\n-\t* testsuite/boehm-gc.lib/staticrootstest.c: Use dg-add-shlib\n-\tstaticrootslib.c.\n-\t* tests/test_cpp.cc: Move ...\n-\t* testsuite/boehm-gc.c++: ... here.\n-\n-2011-03-21  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\n-\t* configure.ac (THREADS): Remove solaris.\n-\t* configure: Regenerate.\n-\n-2011-02-13  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n-\n-\t* configure: Regenerate.\n-\n-2011-02-02  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\n-\t* configure.ac: Don't use libdl on mips-sgi-irix6*.\n-\t* configure: Regenerate.\n-\n-2011-01-31  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\n-\t* configure.ac (*-*-solaris2*): Add -lrt to THREADLIBS.\n-\t* configure: Regenerate.\n-\n-2010-12-10  Iain Sandoe  <iains@gcc.gnu.org>\n-\n-\t* powerpc_darwin_mach_dep.s:  Update for m64.  Add eh frames.\n-\tDo not build or use the picsymbol stub for Darwin >= 9.\n-\t* tests/test.c (reverse_test):  Modify count for ppc64-darwin.\n-\t* pthread_support.c (GC_get_thread_stack_base): Correct a debug\n-\tstatement.\n-\n-2010-11-29  Iain Sandoe  <iains@gcc.gnu.org>\n-\t    Mike Stump  <mrs@gcc.gnu.org>\n-\n-\tPR target/26427\n-\tPR target/33120\n-\tPR testsuite/35710\n-\t* dyn_load.c (GC_register_dynamic_libraries/DARWIN):  Add new writable\n-\tdata section names.\n-\t(GC_dyld_name_for_hdr): Adjust layout.\n-\t(GC_dyld_image_add): Adjust layout, add new Darwin sections, adjust\n-\tdebug to name the sections.\n-\t(GC_dyld_image_remove): Adjust layout, remove new Darwin sections,\n-\tadjust debug to name the sections.\n-\t(GC_register_dynamic_libraries): Adjust layout.\n-\t(GC_init_dyld): Likewise.\n-\t(GC_register_main_static_data): Likewise.\n-\n-2010-10-29  Paolo Bonzini  <bonzini@gnu.org>\n-\n-\t* configure: Regenerate.\n-\n-2010-10-28  Paolo Bonzini  <bonzini@gnu.org>\n-\n-\t* configure.ac: Rewrite DGUX check to use GC_CFLAGS, and -O0 check\n-\tto remove the need for MY_CFLAGS.\n-\t* Makefile.am: Do not use @...@ substitutions.  Use AM_CXXFLAGS,\n-\tAM_CFLAGS and AM_LDFLAGS instead of redefining LTCOMPILE and LINK.\n-\tUse \"override\" to disable -O2 when required.\n-\t* configure: Regenerate.\n-\t* Makefile.in: Regenerate.\n-\t* include/Makefile.in: Regenerate.\n-\n-2010-10-11  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\n-\t* dyn_load.c: Fix typo.\n-\t* pthread_support.c (GC_get_thread_stack_base) [DEBUG_THREADS]:\n-\tUse GC_printf0.\n-\n-2010-06-15  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\n-\t* configure.ac (*-*-solaris2.8*): Only usr alternate thread\n-\tlibrary on Solaris 8.\n-\t(*-*-solaris2*): Use regular thread library otherwise.\n-\t* configure: Regenerate.\n-\n-2010-05-13  Uros Bizjak  <ubizjak@gmail.com>\n-\n-\t* tests/leak_test.c (main): Declare as int.  Return 0.\n-\t* tests/thread_leak_test.c (main): Ditto.\n-\t* tests/trace_test.c (main): Ditto.\n-\n-2010-05-06  Dave Korn  <dave.korn.cygwin@gmail.com>\n-\n-\tPR target/42811\n-\t* tests/staticrootstest.c: New test source file.\n-\t* tests/staticrootslib.c: New test library source file.\n-\t* Makefile.am (test_ldadd): New variable.\n-\t(gctest_LDADD): Use it.\n-\t(TESTS): Add leaktest, middletest and staticrootstest.\n-\t(check_PROGRAMS): Likewise.\n-\t(leaktest_SOURCES): New libtool variable definition.\n-\t(leaktest_LDADD): Likewise.\n-\t(leaktest_LDFLAGS): Likewise.\n-\t(leaktest_LINK): Likewise.\n-\t(middletest_SOURCES): Likewise.\n-\t(middletest_LDADD): Likewise.\n-\t(middletest_LDFLAGS): Likewise.\n-\t(middletest_LINK): Likewise.\n-\t(staticrootstest_SOURCES): Likewise.\n-\t(staticrootstest_LDADD): Likewise.\n-\t(staticrootstest_LDFLAGS): Likewise.\n-\t(staticrootstest_LINK): Likewise.\n-\t(check_LTLIBRARIES): Likewise.\n-\t(libstaticrootslib_la_SOURCES): Likewise.\n-\t(libstaticrootslib_la_LIBADD): Likewise.\n-\t(libstaticrootslib_la_LDFLAGS): Likewise.\n-\t(libstaticrootslib_la_DEPENDENCIES): Likewise.\n-\t* Makefile.in: Regenerate.\n-\n-2010-04-02  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n-\n-\t* Makefile.in: Regenerate.\n-\t* aclocal.m4: Regenerate.\n-\t* include/Makefile.in: Regenerate.\n-\n-2010-03-21  Dave Korn  <dave.korn.cygwin@gmail.com>\n-\n-\tPR target/42811 (prerequisite)\n-\t* include/private/gc_priv.h (struct roots) [CYGWIN32]: Don't\n-\tdeclare r_next member on Cygwin as on other windows hosts.\n-\t(LOG_RT_SIZE) [CYGWIN32]: Don't define likewise.\n-\t(RT_SIZE) [CYGWIN32]: Likewise.\n-\t(struct _GC_arrays) [CYGWIN32]: Do declare _heap_bases[] member\n-\tlikewise.\n-\t(GC_heap_bases) [CYGWIN32]: Do define likewise.\n-\t(struct _SYSTEM_INFO) [CYGWIN32]: Do forward-declare likewise.\n-\t(GC_sysinfo) [CYGWIN32]: Do declare extern likewise.\n-\t(GC_n_heap_bases) [CYGWIN32]: Likewise.\n-\t(GC_is_tmp_root) [CYGWIN32]: Do prototype likewise.\n-\t* include/private/gcconfig.h (GC_win32_get_mem) [CYGWIN32]: Likewise.\n-\t(GET_MEM) [CYGWIN32]: Do define likewise.\n-\t* boehm-gc/ptr_chck.c (GC_is_visible) [CYGWIN32]: Do handle dynamic\n-\tregistration likewise.\n-\t* boehm-gc/os_dep.c (GC_setpagesize) [CYGWIN32]: Do define likewise.\n-\t(GC_no_win32_dlls) [CYGWIN32]: Define as constant false, unlike\n-\tother windows hosts.\n-\t(GC_sysinfo) [CYGWIN32]: Define as on other windows hosts.\n-\t(GC_n_heap_bases) [CYGWIN32]: Likewise.\n-\t(GLOBAL_ALLOC_TEST) [CYGWIN32]: Likewise.\n-\t(GC_win32_get_mem) [CYGWIN32]: Likewise, but wrapping GC_unix_get_mem\n-\trather than GlobalAlloc/VirtualAlloc.\n-\t(GC_win32_free_heap) [CYGWIN32]: Likewise, but wrapping free instead\n-\tof GlobalFree (even though the function body is optimised away).\n-\t* boehm-gc/mark_rts.c (add_roots_to_index) [CYGWIN32]: Define as on\n-\tother windows hosts.\n-\t(GC_add_roots_inner) [CYGWIN32]: Avoid overlapping or adjacent\n-\tintervals likewise.\n-\t(GC_clear_roots) [CYGWIN32]: Clear GC_root_index[] likewise.\n-\t(GC_rebuild_root_index) [CYGWIN32]: Define as on other windows hosts.\n-\t(GC_remove_tmp_roots) [CYGWIN32]: Call it likewise.\n-\t(GC_remove_roots) [CYGWIN32]: Don't define, as on other windows hosts.\n-\t(GC_is_tmp_root) [CYGWIN32]: Define, as on other windows hosts.\n-\t(GC_cond_register_dynamic_libraries) [CYGWIN32]: Handle temporary\n-\troots and dynamic registration likewise.\n-\t* boehm-gc/dyn_load.c (GC_has_static_roots) [CYGWIN32]: Define as on\n-\tother windows hosts.\n-\t(GC_register_has_static_roots_callback) [CYGWIN32]: Likewise.\n-\t(GC_cond_add_roots) [CYGWIN32]: Likewise.\n-\t(GC_register_main_static_data) [CYGWIN32]: Define to always return\n-\tfalse, as on MSWINCE\n-\t(HAVE_REGISTER_MAIN_STATIC_DATA) [CYGWIN32]: Define as on other\n-\twindows hosts.\n-\t(GC_warn_fb) [CYGWIN32]: Likewise.\n-\t(GC_disallow_ignore_fb) [CYGWIN32]: Likewise.\n-\t(GC_ignore_fb_mb) [CYGWIN32]: Likewise.\n-\t(GC_ignore_fb) [CYGWIN32]: Likewise.\n-\t(is_frame_buffer) [CYGWIN32]: Likewise.\n-\t(GC_dump_meminfo) [CYGWIN32]: Likewise.\n-\t(GC_wnt) [CYGWIN32]: Define to constant true.\n-\t(GC_register_dynamic_libraries) [CYGWIN32]: Define as on other\n-\twindows hosts.\n-\n-2009-12-09  Matthias Klose  <doko@ubuntu.com> \n-\n-\t* include/private/gc_locks.h: For __ARM_EABI__ define\n-\tGC_test_and_set  GC_clear to use the atomic builtins.\n-\n-2009-12-05  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n-\n-\t* Makefile.in: Regenerate.\n-\t* configure: Regenerate.\n-\t* include/Makefile.in: Regenerate.\n-\n-2009-11-30  Ben Elliston  <bje@au.ibm.com>\n-\n-\t* mark_rts.c (GC_approx_sp): Use __builtin_frame_address when\n-\tcompiling with GCC rather than taking the address of a local\n-\tvariable.\n-\n-2009-11-30  Ben Elliston  <bje@au.ibm.com>\n-\n-\t* os_dep.c: Use the POSIX signal API in preference to the BSD API.\n-\tGenerate a compilation error if neither the POSIX nor BSD APIs can\n-\tbe detected.\n-\n-2009-09-11  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n-\n-\t* Makefile.am (libgcjgc_la_LINK, gctest_LINK): New.\n-\t(gctest_LDADD): Depend on libgcjgc.la instead of ./libgcjgc.la,\n-\tso that library dependency resolution works with portable make.\n-\t* Makefile.in: Regenerate.\n-\n-2009-09-08  Alexandre Oliva  <aoliva@redhat.com>\n-\n-\t* configure: Rebuilt with modified libtool.m4.\n-\n-2009-09-03  Loren J. Rittle  <ljrittle@acm.org>\n-\n-\t* dyn_load.c (HAVE_DL_ITERATE_PHDR): Break definition from use.\n-\tDefine for FreeBSD 7.0+.\n-\n-2009-08-24  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n-\n-\t* configure.ac (AC_PREREQ): Bump to 2.64.\n-\n-2009-08-22  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n-\n-\t* Makefile.am (install-html, install-pdf): Remove.\n-\t* Makefile.in: Regenerate.\n-\n-\t* Makefile.in: Regenerate.\n-\t* aclocal.m4: Regenerate.\n-\t* configure: Regenerate.\n-\t* include/Makefile.in: Regenerate.\n-\t* include/gc_config.h.in: Regenerate.\n-\n-2009-08-22  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n-\n-\t* Makefile.am (LTCOMPILE, LTLINK): Add $(AM_LIBTOOLFLAGS)\n-\tand $(LIBTOOLFLAGS).\n-\t* Makefile.in: Regenerate.\n-\n-2009-07-30  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n-\n-\t* configure.ac (_AC_ARG_VAR_PRECIOUS): Use m4_rename_force.\n-\n-2009-07-17  Michael Meissner  <meissner@linux.vnet.ibm.com>\n-\n-\tPR boehm-gc/40785\n-\t* include/private/gc_locks.h (GC_test_and_set): If GCC 4.4, use\n-\tthe __sync_lock_test_and _set and __sync_lock_release builtins on\n-\tthe powerpc.  If not GCC 4.4, fix up the constraints so that it\n-\tbuilds without error.\n-\t(GC_clear): Ditto.\n-\n-2009-07-17  Kai Tietz  <kai.tietz@onevision.com>\n-\n-\t* configure.ac: Add rule for mingw targets to add -DGC_BUILD=1 to\n-\tcflags.\n-\t* configure: Regenerated.\n-\n-2009-05-17  Dave Korn  <dave.korn.cygwin@gmail.com>\n-\n-\t* win32_threads.c (GC_get_thread_stack_base):  Implement for Cygwin.\n-\n-2009-03-01  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n-\n-\t* configure: Regenerate.\n-\n-2009-02-09  Mark Mitchell  <mark@codesourcery.com>\n-\n-\t* Makefile.am (LTLDFLAGS): New variable.\n-\t(LINK): Use it.\n-\t* Makefile.in: Regenerated.\n-\n-2008-12-18  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n-\n-\t* configure: Regenerate.\n-\n-2008-09-26  Peter O'Gorman  <pogma@thewrittenword.com>\n-\t    Steve Ellcey  <sje@cup.hp.com>\n-\n-\t* configure: Regenerate for new libtool.\n-\t* Makefile.in: Ditto.\n-\t* include/Makefile.in: Ditto.\n-\t* aclocal.m4: Ditto.\n-\n-2008-07-18  Matthias Klose  <doko@ubuntu.com> \n- \n-\t* configure.ac (AC_CONFIG_FILES): Add threads.mk. \n-\t* threads.mk.in: New. \n-\t* Makefile.in, configure: Regenerate. \n-\n-2008-06-17  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n-\n-\t* Makefile.in: Regenerate.\n-\t* configure: Regenerate.\n-\t* include/Makefile.in: Regenerate.\n-\t* include/gc_config.h.in: Regenerate.\n-\n-2008-04-18  Paolo Bonzini  <bonzini@gnu.org>\n-\n-\tPR bootstrap/35457\n-\t* aclocal.m4: Regenerate.\n-\t* configure: Regenerate.\n-\n-2008-03-16  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n-\n-\t* aclocal.m4: Regenerate.\n-\t* configure: Likewise.\n-\t* Makefile.in: Likewise.\n-\t* include/Makefile.in: Likewise.\n-\n-2007-02-19  Andreas Tobler  <a.tobler@schweiz.org>\n-\n-\t* dyn_load.c (GC_dyld_image_add): Remove ifdef clause and use the macro\n-\tGC_GETSECTBYNAME instead.\n-\t* include/private/gc_priv.h: Define GC_GETSECTBYNAME according to the\n-\tarchitecture (Darwin).\n-\n-2008-01-26  Richard Sandiford  <rsandifo@nildram.co.uk>\n-\n-\t* include/private/gcconfig.h (HBLKSIZE): Define for MIPS.\n-\n-2008-01-24  David Edelsohn  <edelsohn@gnu.org>\n-\n-\t* configure: Regenerate.\n-\n-2007-10-10  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n-\n-\tPR boehm-gc/33442\n-\t* pthread_support.c (GC_PTR GC_get_thread_stack_base): If stack grows\n-\tup, return stack_addr instead of stack_addr - stack_size.\n-\n-2007-08-14  David Daney  <ddaney@avtrex.com>\n-\n-\t* include/private/gcconfig.h: Handle mips64-linux n64 ABI.\n-\n-2007-07-05  H.J. Lu  <hongjiu.lu@intel.com>\n-\n-\t* aclocal.m4: Regenerated.\n-\n-2007-07-02  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n-\n-\tPR boehm-gc/21940\n-\tPR boehm-gc/21942\n-\t* configure.ac (GC_SOLARIS_THREADS): Don't define on *-*-solaris*.\n-\tUse alternate thread library in /usr/lib/lwp.\n-\t* configure: Regenerate.\n-\t* dyn_load.c: Use GC_SOLARIS_PTHREADS.\n-\t* include/gc_config_macros.h (GC_SOLARIS_THREADS): Don't define.\n-\t* include/private/gcconfig.h: Handle 64-bit Solaris 2/x86.\n-\t(GC_SOLARIS_THREADS): Don't define.\n-\t* include/private/solaris_threads.h: Remove.\n-\t* pthread_support.c (GC_thr_init) [GC_SOLARIS_PTHREADS]: Determine\n-\tGC_nprocs via sysconf().\n-\t* Makefile.am (libgcjgc_la_SOURCES): Remove solaris_pthreads.c and\n-\tsolaris_threads.c.\n-\t(gctest_LDADD): Use THREADLIBS instead of THREADDLLIBS.\n-\t* Makefile.in: Regenerate.\t \n-\t* solaris_pthreads.c: Remove.\n-\t* solaris_threads.c: Remove.\n-\n-2007-06-22  Jakub Jelinek  <jakub@redhat.com>\n-\n-\t* pthread_support.c (GC_get_thread_stack_base): Handle\n-\tpthread_getattr_np failures.\n-\n-2007-06-02  Paolo Bonzini  <bonzini@gnu.org>\n-\n-\t* configure: Regenerate.\n-\n-2007-05-23  Steve Ellcey  <sje@cup.hp.com>\n-\n-\t* Makefile.in: Regenerate.\n-\t* configure: Regenerate.\n-\t* aclocal.m4: Regenerate.\n-\t* include/Makefile.in: Regenerate.\n-\n-2007-05-20  Andreas Tobler  <a.tobler@schweiz.org>\n-\n-\t* configure.ac: Introduce extra_ldflags_libgc. Use it for Darwin.\n-\t* configure: Regenerate.\n-\t* Makefile.am (libgc_la_LDFLAGS): Use extra_ldflags_libgc.\n-\t* Makefile.in: Regenerate.\n-\t* include/Makefile.in: Regenerate.\n-\t* include/private/gcconfig.h: Enable MPROTECT_VDB for all Darwin\n-\ttargets. Remove comments. Prepare ppc64 support for Darwin.\n-\n-2007-04-23  Keith Seitz  <keiths@redhat.com>\n-\n-\t* include/gc.h (GC_is_thread_suspended): Declare.\n-\t* pthread_stop_world.c (GC_is_thread_suspended): New function.\n-\n-2007-04-03  Jakub Jelinek  <jakub@redhat.com>\n-\n-\t* configure.ac (NO_EXECUTE_PERMISSION): Set by default.\n-\t* configure: Rebuilt.\n-\n-2007-03-07  Alexandre Oliva  <aoliva@redhat.com>\n-\n-\t* include/gc.h (GC_REGISTER_FINALIZER_UNREACHABLE): New.\n-\t(GC_register_finalizer_unreachable): Declare.\n-\t(GC_debug_register_finalizer_unreachable): Declare.\n-\t* finalize.c (GC_unreachable_finalize_mark_proc): New.\n-\t(GC_register_finalizer_unreachable): New.\n-\t(GC_finalize): Handle it.\n-\t* dbg_mlc.c (GC_debug_register_finalizer_unreachable): New.\n-\t(GC_debug_register_finalizer_no_order): Fix whitespace.\n-\n-2007-03-01  Brooks Moses  <brooks.moses@codesourcery.com>\n-\n-\t* Makefile.am: Add dummy install-pdf target.\n-\t* Makefile.in: Regenerate\n-\n-2007-02-05  Roman Zippel <zippel@linux-m68k.org>\n-\n-\t* boehm-gc/include/private/gcconfig.h: use LINUX_STACKBOTTOM so\n-\tit works with Linux 2.6, reactivate MPROTECT_VDB\n-\t* boehm-gc/pthread_stop_world.c: save all register\n-\ton signal entry\n-\n-2007-01-24  Andreas Tobler  <a.tobler@schweiz.org>\n-\n-\t* os_dep.c (defined(MPROTECT_VDB) && defined(DARWIN)): Moved recently\n-\tadded defines to include/private/gc_priv.h\n-\t(catch_exception_raise): Added THREAD_FLD in exc_state for POWERPC too.\n-\t* darwin_stop_world.c: Removed the above defines.\n-\t* include/private/gc_priv.h: Moved definitions from darwin_stop_world.c\n-\tand os_dep.c to here. Fixed THREAD definition fixes for ppc64.\n-\n-2007-01-17  David Daney  <ddaney@avtrex.com>\n-\n-\t* configure.ac: Don't define NO_SIGSET and NO_DEBUGGING while\n-\tcross-compiling.\n-\t* configure: Regenerated.\n-\t* include/gc_config.h.in: Regenerated.\n-\n-2007-01-17  Mike Stump  <mrs@apple.com>\n-\n-\t* os_dep.c: Fix i686-apple-darwin9 builds.\n-\n-2007-01-16  Jack Howarth  <howarth@bromo.med.uc.edu>\n-\n-\t* aclocal.m4: Regenerate to use multi.m4.\n-\t* configure: Regenerate.\n-\t* Makefile.in: Regenerate.\n-\n-2007-01-17  Andreas Tobler  <a.tobler@schweiz.org>\n-\n-\t* include/gc_config.h.in: Regenerate.\n-\n-2007-01-16  Petr Salinger  <Petr.Salinger@seznam.cz>\n-\n-\t* include/private/gcconfig.h: Handle amd64/x86-64 cpu under\n-\t GNU/kFreeBSD.\n-\t* os_dep.c: Likewise.\n-\n-2007-01-15  Andreas Tobler  <a.tobler@schweiz.org>\n-\n-\t* os_dep.c (defined(MPROTECT_VDB) && defined(DARWIN)): Adjust mail\n-\treference.\n-\t(catch_exception_raise): Fix typo in the I386 exc_state.\n-\n-2007-01-11  Andreas Tobler  <a.tobler@schweiz.org>\n-\n-\t* configure.ac: Replaced HAS_I386_THREAD_STATE_* with\n-\tHAS_X86_THREAD_STATE32_* and HAS_X86_THREAD_STATE64_* respectively.\n-\t* configure: Regenerated.\n-\t* include/private/gcconfig.h (DARWIN): Added X86_64 define for Darwin.\n-\tAdded base definitions for the X86_64 Darwin port.\n-\t* include/private/gc_priv.h: Added definitions for Darwin MACH thread\n-\toperations. Moved existing THREAD_STATE info from darwin_stop_world.c.\n-\t* darwin_stop_world.c: Removed THREAD_STATE info. Added\n-\tHAS_X86_THREAD_STATE64___RAX. And replaced HAS_I386_THREAD_STATE___EAX\n-\twith HAS_X86_THREAD_STATE32___EAX.\n-\t(GC_push_all_stacks): Use GC_MACH_THREAD_STATE_COUNT. Add code for\n-\tX86_64 Darwin.\n-\t* dyn_load.c (GC_dyld_name_for_hdr): Use GC_MACH_HEADER.\n-\t(GC_dyld_image_add): Use GC_MACH_HEADER and GC_MACH_SECTION.\n-\tDistinguish between getsectbynamefromheader_64 and\n-\tgetsectbynamefromheader.\n-\t(GC_dyld_image_remove): Likewise.\n-\t* os_dep.c (GC_dirty_init): Use GC_MACH_THREAD_STATE.\n-\t(catch_exception_raise): Introduce exception information for I386 and\n-\tX86_64 Darwin. Add X86_64 for exc_state.faultvaddr.\n-\n-2006-12-08  Mike Stump  <mrs@apple.com>\n-\n-\t* configure.ac: Fix x86 darwin builds.\n-\t* darwin_stop_world.c: Likewise.\n-\t* include/private/gcconfig.h: Likewise.\n-\t* connfigure: Regenerate.\n-\t\n-2006-09-26  Jack Howarth  <howarth@bromo.med.uc.edu>\n-\n-\tPR target/29180\n-\t* darwin_stop_world.c: Make stack_start unsigned long.\n-\n-2006-09-21  Sandro Tolaini  <tolaini@libero.it>\n-\n-\t* os_dep.c: Port to Darwin/i386\n-\t* darwin_stop_world.c: Likewise\n-\t* include/private/gcconfig.h: Likewise\n-\t\n-2006-06-07  Petr Salinger  <Petr.Salinger@seznam.cz>\n-\n-\t* configure.ac: add support for GNU/kFreeBSD, accepted by upstream\n-\tfor gc 6.8.\n-\t* dyn_load.c: Likewise.\n-\t* include/gc.h: Likewise.\n-\t* private/gcconfig.h: Likewise.\n-\t* configure: Regenerate.\n-\t* include/gc_config.h.in: Regenerate.\n-\n-2006-09-14  Tom Tromey  <tromey@redhat.com>\n-\n-\tPR boehm-gc/29068.\n-\t* misc.c (GC_init_inner): Don't use GC_get_thread_stack_base on\n-\tSolaris.\n-\n-2006-08-21  Bryce McKinlay  <mckinlay@redhat.com>\n-\t\n-\tPR libgcj/13212:\n-\t* configure.ac: Check for pthread_getattr_np(). Remove\n-\tGC_PTHREAD_SYM_VERSION detection.\n-\t* include/gc.h (GC_register_my_thread, GC_unregister_my_thread,\n-\tGC_get_thread_stack_base): New declarations.\n-\t* pthread_support.c (GC_register_my_thread, GC_unregister_my_thread,\n-\tGC_get_thread_stack_base): New functions.\n-\t(GC_delete_thread): Don't try to free the first_thread.\n-\t* misc.c (GC_init_inner): Use GC_get_thread_stack_base() if possible.\n-\t(pthread_create_, constr): Removed.\n-\t(pthread_create): Don't rename.\n-\t* include/gc_ext_config.h.in: Rebuilt.\n-\t* include/gc_pthread_redirects.h (pthread_create): Define \n-\tunconditionally.\n-\t* include/gc_config.h.in: Rebuilt.\n-\t* configure: Rebuilt.\n-\n-2006-06-21  Keith Seitz  <keiths@redhat.com>\n-\n-\t* pthread_stop_world.c (GC_suspend_handler): Redirect to suspension\n-\troutine if signal is received and thread is flagged SUSPENDED.\n-\t(suspend_self): New function.\n-\t(GC_suspend_thread): New function.\n-\t(GC_resume_thread): New function.\n-\t* include/gc.h (GC_suspend_thread): Declare.\n-\t(GC_resumet_thread): Declare.\n-\t* include/private/pthread_support.h (SUSPENDED): New GC_thread\n-\tflag.\n-\n-2006-06-20  Ranjit Mathew  <rmathew@gcc.gnu.org>\n-\t\n-\tBackport Windows 9x/ME VirtualQuery() fix from GC 6.7.\n-\t* os_dep.c (GC_wnt): Define.\n-\t(GC_init_win32): Set GC_wnt.\n-\t* dyn_load.c (GC_register_dynamic_libraries): Consider MEM_PRIVATE\n-\tsections also on Windows 9x/ME.\n-\n-2006-06-02  Geoffrey Keating  <geoffk@apple.com>\n-\n-\t* configure.ac: Define HAS_PPC_THREAD_STATE_R0,\n-\tHAS_PPC_THREAD_STATE___R0, HAS_PPC_THREAD_STATE64_R0,\n-\tHAS_PPC_THREAD_STATE64___R0, HAS_I386_THREAD_STATE_EAX,\n-\tHAS_I386_THREAD_STATE___EAX.\n-\t* configure: Regenerate.\n-\t* include/gc_config.h.in: Regenerate.\n-\t* darwin_stop_world.c (PPC_RED_ZONE_SIZE): Use standard Darwin\n-\tmacro names to determine value.\n-\t(THREAD_STATE): New.\n-\t(THREAD_FLD): New.\n-\t(GC_push_all_stacks): Use THREAD_STATE and THREAD_FLD in both versions.\n-\n-2006-05-24  Carlos O'Donell  <carlos@codesourcery.com>\n-\n-\t* Makefile.am: Add install-html target. \n-\t* Makefile.in: Regenerate.\n-\t* aclocal.m4: Regenerate.\n-\t* include/Makefile.in: Regenerate.\n-\n-2006-03-07  Andrew Haley  <aph@redhat.com>\n-\n-\t* dyn_load.c (GC_has_static_roots): Declare.\n-\t(GC_register_dynlib_callback): Call GC_has_static_roots.\n-\n-2006-04-11  Bryce McKinlay  <mckinlay@redhat.com>\n-\n-\t* darwin_stop_world.c (GC_push_all_stacks, GC_stop_world,\n-\tGC_start_world): Call vm_deallocate to free act_list. Fix from\n-\tBruce Mitchener.\n-\n-2006-03-24  Andreas Tobler  <a.tobler@schweiz.ch>\n-\tJohn David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n-\n-\t* configure.ac (THREADS): Add REENTRANT for *-*-hpux11*.\n-\tWarn about POSIX threads not being supported for *-*-hpux10*.\n-\t* configure: Regenerate.\n-\n-2006-02-09  Tom Tromey  <tromey@redhat.com>\n-\n-\t* pthread_support.c: Conditionally include dlfcn.h.\n-\n-2006-02-06  Jakub Jelinek  <jakub@redhat.com>\n-\t    Anthony Green  <green@redhat.com>\n-\t    Tom Tromey  <tromey@redhat.com>\n-\n-\t* include/gc_ext_config.h.in: Added GC_PTHREAD_SYM_VERSION.\n-\t* include/gc_config.h.in: Rebuilt.\n-\t* include/gc_pthread_redirects.h (pthread_create): Conditionally\n-\tdefine.\n-\t* pthread_support.c (pthread_create_): New global.\n-\t(constr): New function.\n-\t(pthread_create): Conditionally renamed.\n-\t* configure: Rebuilt.\n-\t* configure.ac (GC_PTHREAD_SYM_VERSION): Define.\n-\n-2006-02-04  Alan Modra  <amodra@bigpond.net.au>\n-\n-\t* include/private/gc_locks.h (GC_test_and_set <POWERPC>): Don't\n-\tuse broken 64-bit version.\n-\n-2006-01-25  Andreas Tobler  <a.tobler@schweiz.ch>\n-\n-\t* darwin_stop_world.c: Change inline asm instruction to ld as ldz\n-\tis wrong.\n-\n-\t* Makefile.am (asm_libgcjgc_sources): Rename to asm_libgcjgc_sources.\n-\t* Makefile.in: Regenerate.\n-\n-2006-01-25  Bryce McKinlay  <mckinlay@redhat.com>\n-\n-\t* include/private/gcconfig.h: Revert to GC 6.6 version, removing\n-\tall local changes.\n-\n-2006-01-24  Bryce McKinlay  <mckinlay@redhat.com>\n-\n-\tImport Boehm GC version 6.6.\n-\n-2006-01-24  David Ayers  <d.ayers@inode.at>\n-\n-\tPR libobjc/13946\n-\t* include/gc.h: Fix prototype declarations for bootstrap.\n-\n-2005-11-01  Bryce McKinlay  <mckinlay@redhat.com>\n-\n-\t* include/private/gc_priv.h: Increase MAX_ROOT_SETS to 1024.\n-\n-2005-09-15  Kazu Hirata  <kazu@codesourcery.com>\n-\n-\t* include/private/gc_locks.h (GC_test_and_set): Change the\n-\tconstraint of the first operand to '0'.\n-\n-2005-09-06  Tom Tromey  <tromey@redhat.com>\n-\n-\tPR libgcj/23662:\n-\t* include/private/gcconfig.h (LINUX_STACKBOTTOM): Use instead of\n-\tHEURISTIC1 on ARM.\n-\n-2005-07-17  SUGIOKA Toshinobu  <sugioka@itonet.co.jp>\n-\n-\t* include/private/gcconfig.h (sh-linux): Use LINUX_STACKBOTTOM.\n-\n-2005-06-15  Andreas Tobler  <a.tobler@schweiz.ch>\n-\n-\t* os_dep.c: Add FreeBSD/PowerPC bits.\n-\t(GC_SysVGetDataStart): Likewise.\n-\t* include/private/gcconfig.h: Likewise.\n-\n-2005-05-25  Andrew Haley  <aph@redhat.com>\n-\n-\t* include/private/gcconfig.h (HBLKSIZE): Define to 4096 on\n-\tpowerpc64-linux.\n-\n-2005-05-09  Mike Stump  <mrs@apple.com>\n-\n-\t* configure: Regenerate.\n-\n-2005-04-19  Hans-Peter Nilsson  <hp@axis.com>\n-\n-\t* os_dep.c, include/private/gc_locks.h: Import CRIS port by\n-\tSimon Posnjak from gc6.4.\n-\t* include/private/gcconfig.h: Ditto.  Add M32R note from gc6.4.\n-\n-2005-04-17  David S. Miller  <davem@davemloft.net>\n-\n-\t* include/private/gcconfig.h (sparc-linux): Use LINUX_STACKBOTTOM.\n-\t* os_dep.c (GC_linux_stack_base): Check for bug present in some\n-\tSparc glibc variants where __libc_stack_end is erroneously set\n-\tto \"1\".  Fallback to procfs code in that case.\n-\n-2005-04-12  Mike Stump  <mrs@apple.com>\n-\n-\t* configure: Regenerate.\n-\n-2005-04-12  Richard Henderson  <rth@redhat.com>\n-\n-\t* include/private/gcconfig.h (alpha-linux): Use LINUX_STACKBOTTOM.\n-\n-2005-03-23  Mike Stump  <mrs@apple.com>\n-\n-\t* darwin_stop_world.c: Update for -m64 multilib.\n-\t* include/private/gcconfig.h: Likewise.\n-\t* powerpc_darwin_mach_dep.s: Likewise.\n-\n-2005-03-01  Kelley Cook  <kcook@gcc.gnu.org>\n-\n-\t* Makefile.in, include/Makefile.in: Regenerate.\n-\n-2005-02-26  Richard Earnshaw  <rearnsha@arm.com>\n-\n-\t* dyn_load.c: On NetBSD, include machine/elf_machdep.h and define\n-\tELFSIZE in terms of ARCH_ELFSIZE (back-ported from gc7.0alpha1).\n-\n-2005-02-15  Bryce McKinlay  <mckinlay@redhat.com>\n-\n-\tPR libgcj/19823\n-\t* configure.host: Set gc_use_mmap on *-linux*.\n-\t* configure.ac: Define USE_MMAP if gc_use_mmap is set.\n-\t* include/private/gc_priv.h: Include gc_config.h.\n-\t* configure, include/gc_config.h.in: Rebuilt.\n-\n-2005-02-07  Hans Boehm  <Hans.Boehm@hp.com>\n-\n-\t* allchblk.c (GC_allochblk_nth): Dont overlook available space if\n-\t  GC disabled, correctly convert GC_finalizer_mem_freed to byte,\n-\t  total_size to words.\n-\t* dyn_load.c (win32 GC_register_dynamic_libraries): Consider only\n-\t  MEM_IMAGE regions.\n-\t* mach_dep.c (GC_with_callee_saves_pushed): separate into new function,\n-\t  and indent appropriately.\n-\t* mark_rts.c (GC_approx_sp): Access stack.\n-\t* pthread_stop_world.c: (GC_suspend_handler): Explicitly push\n-\t  callee-saves registers when appropriate.\n-\t  (GC_stop_world): Handle EINTR from sem_wait (sync with Mono GC).\n-\n-2005-01-01  Bryce McKinlay  <mckinlay@redhat.com>\n-\n-\t* configure.ac (AC_CONFIG_HEADERS): Build both include/gc_config.h \n-\tand include/gc_ext_config.h.\n-\t* include/gc_ext_config.h: New file. Define only THREAD_LOCAL_ALLOC.\n-\t* include/gc.h: Undef PACKAGE_* before including gc_config.h.\n-\n-2004-12-13  Kelley Cook  <kcook@gcc.gnu.org>\n-\n-\t* configure: Regenerate.\n-\n-2004-11-29  Bryce McKinlay  <mckinlay@redhat.com>\n-\n-\tPR libgcj/18699\n-\tRevert patches of 2004-11-26 and 2004-11-27.\n-\n-2004-11-29  Kelley Cook  <kcook@gcc.gnu.org>\n-\n-\t* configure: Regenerate for libtool change.\n-\n-2004-11-27  Bryce McKinlay  <mckinlay@redhat.com>\n-\n-\t* include/gc_config.h.in: Add comment. Define only THREAD_LOCAL_ALLOC.\n-\n-2004-11-26  Bryce McKinlay  <mckinlay@redhat.com>\n-\n-\tFix \"PACKAGE_NAME redefined\" errors.\n-\t* configure.ac (AC_CONFIG_HEADERS): Build both include/config.h \n-\tand include/gc_config.h.\n-\t* configure: Regenerated.\n-\t* include/gc_config.h.in: No longer auto-generated. Define only the\n-\tmacros needed by libjava.\n-\t* include/config.h.in: Generated by autoheader.\n-\t* include/gc.h: Include config.h, not gc_config.h.\n-\n-2004-11-25  Kelley Cook  <kcook@gcc.gnu.org>\n-\n-\t* configure: Regenerate for libtool reversion.\n-\n-2004-11-24  Kelley Cook  <kcook@gcc.gnu.org>\n-\n-\t* configure: Regenerate for libtool change.\n-\n-2004-11-22  Eric Botcazou  <ebotcazou@libertysurf.fr>\n-\n-\t* configure.ac (machdep): Use sparc_mach_dep.lo on\n-\tsparc64-sun-solaris2.* too.\n-\t(Solaris gcc optimization fix): Disable on sparc*-sun-solaris2.*.\n-\t* configure: Regenerate.\n-\n-2004-11-22  Eric Botcazou  <ebotcazou@libertysurf.fr>\n-\n-\tPR target/18444\n-\t* configure.ac (threading): Accept 'posix95'.\n-\t* configure: Regenerate.\n-\n-2004-11-04  Kelley Cook  <kcook@gcc.gnu.org>\n-\n-\t* Makefile.am: Define ACLOCAL_AMFLAGS.\n-\t* configure.ac: Remove redundant sinclude.\n-\t* acinclude.m4: Delete file.\n-\t* aclocal.m4: Regenerate.\n-\t* Makefile.in, include/Makefile.in: Regenerate.\n-\t* configure: Regenerate.\n-\n-2004-10-19  Ulrich Weigand  <uweigand@de.ibm.com>\n-\n-\t* include/private/gc_priv.h (GC_generic_malloc_words_small_inner):\n-\tAdd prototype.\n-\n-2004-10-13  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>\n-\n-\t* include/private/gcconfig.h: Add m32r-linux target.\n-\n-2004-09-27  Kelley Cook  <kcook@gcc.gnu.org>\n-\n-\t* configure.ac: Update all AC_DEFINEs to newer style.\n-\t* configure: Regenerate.\n-\t* include/gc_config.h.in: Regenerate.\n-\n-2004-08-27  Hans Boehm  <Hans.Boehm@hp.com>\n-\n-\t* backgraph.c, gc_priv.h (GC_traverse_back_graph,\n-\tGC_print_back_graph_stats): split GC_traverse_back_graph.\n-\t* backgraph.c: Dynamically grow in_progress_space.\n-\t* finalize.c (GC_notify_or_invoke_finalizers): also call\n-\tGC_print_back_graph_stats.\n-\t* alloc.c, finalize.c, gc_priv.h (GC_generate_random_backtrace_no_gc,\n-\tGC_print_back_height): Move delarations to header file.\n-\t* configure.ac: rename --enable-full-debug to --enable-gc-debug.\n-\t* configure: Regenerate.\n-\t\n-2004-08-23  Hans Boehm  <Hans.Boehm@hp.com>\n-\n-\t* aix_irix_threads.c: Move _THREADS checks after gc_priv.h include.\n-\t* backgraph.c, include/private/gc_pmark.h: Always include gc.h.\n-\n-2004-08-23  Bryce McKinlay  <mckinlay@redhat.com>\n-\n-\t* win32_threads.c: Move GC_WIN32_THREADS check after gc_priv.h include.\n-\tReported by Danny Smith.\n-\n-2004-08-21  Danny Smith  <dannysmith@users.sourceforge.net>\n-\n-\t* misc.c (GC_init): Replace lhs cast with rhs cast.\n-\n-2004-08-16  Bryce McKinlay  <mckinlay@redhat.com>\n-\n-\t* specific.c: Check GC_LINUX_THREADS before including \n-\tprivate/specific.h. From Richard Earnshaw.\n-\n-2004-08-16  Nathanael Nerode  <neroden@gcc.gnu.org>\n-\n-\t* aclocal.m4: Remove obsolete construct for old automake.\n-\t* acinclude.m4: Regenerate with aclocal 1.9.1.\n-\t* configure.ac:  Remove duplicate AC_WITH calls.  Replace\n-\tAC_CANONICAL_SYSTEM with AC_CANONICAL_HOST, AC_CANONICAL_TARGET.\n-\tReplace _GCC_TOPLEV_NONCANONICAL calls with ACX_NONCANONICAL_TARGET.\n-\tRemove now-redundant subst of target_noncanonical.  Remove\n-\tnow-gratuitous m4 quoting around $.  Replace AM_PROG_LIBTOOL with\n-\tAC_PROG_LIBTOOL and remove second, redundant AC_PROG_LIBTOOL.\n-\tUse slightly more modern form of AC_INIT.\n-\t* configure: Rebuild with autoconf 2.59.\n-\t* Makefile.in, include/Makefile.in: Rebuild with automake 1.9.1.\n-\n-2004-08-16  Andreas Tobler  <a.tobler@schweiz.ch>\n-\n-\t* solaris_threads.c: Remove ifdef around #include \"private/gc_priv.h\"\n-\tsince they're not known at this time.\n-\t* solaris_pthreads.c: Likewise.\n-\n-2004-08-15  Andreas Tobler  <a.tobler@schweiz.ch>\n-\n-\tPR target/14931\n-\t* powerpc_darwin_mach_dep.s (_GC_push_regs): Change to new stub style.\n-\n-2004-08-13  Bryce McKinlay  <mckinlay@redhat.com>\n-\n-\t* configure.ac (gc_cflags): Add -Iinclude.\n-\t(AC_CONFIG_HEADERS): New. Configure gc_config.h header.\n-\tDon't write DEFS to boehm-cflags file.\n-\t* configure: Rebuilt.\n-\t* gcj_mlc.c: Check #ifdef GC_GCJ_SUPPORT after including headers.\n-\t* specific.c: Check #ifdef GC_LINUX_THREADS after including headers.\n-\t* include/gc_config_macros.h: Remove backward-compatibility \n-\tredefinitions of GC_ names.\n-\t* include/gc.h: Include <gc_config.h>.\n-\n-2004-08-13  Bryce McKinlay  <mckinlay@redhat.com>\n-\n-\tImport Boehm GC version 6.3.\n-\n-2004-08-12  Kelley Cook  <kcook@gcc.gnu.org>\n-\n-\t* include/Makefile.in: Regenerate\n-\n-2004-07-06  Andrew Pinski  <apinski@apple.com>\n-\n-\t* os-dep.c (GC_task_self): Declare as static\n-\tand remove the second declaration.\n-\n-2004-06-20  Andreas Tobler  <a.tobler@schweiz.ch>\n-\n-\t* Makefile.am: Add rule for .S files to fix bootstrap on\n-\tsolaris and alpha.\n-\t* Makefile.in: Regenerate.\n-\n-2004-06-16  Paolo Bonzini  <bonzini@gnu.org>\n-\n-\t* boehm-gc/configure.ac: New name of configure.in.\n-\tRemove useless multilib stuff.  Change uses of\n-\tINCLUDES and CXXINCLUDES to AM_CPPFLAGS.\n-\t* boehm-gc/configure.in: New name of configure.in.\n-\t* boehm-gc/Makefile.am: Update for automake 1.8.5.\n-\t* boehm-gc/acinclude.m4: Include ../config/acx.m4.\n-\t* boehm-gc/aclocal.m4: Regenerate.\n-\t* boehm-gc/configure: Regenerate.\n-\t* boehm-gc/Makefile.in: Regenerate.\n-\n-2004-06-15  Paolo Bonzini  <bonzini@gnu.org>\n-\n-\t* .cvsignore: New file.\n-\n-2004-04-25  Andreas Jaeger  <aj@suse.de>\n-\n-\t* mark.c (GC_mark_from): Use pointer as prefetch argument.\n-\n-2004-04-06  H.J. Lu  <hongjiu.lu@intel.com>\n-\n-\t* include/private/gcconfig.h (PREFETCH): Use __builtin_prefetch\n-\tfor gcc >= 3.0.\n-\t(PREFETCH_FOR_WRITE): Likewise.\n-\n-2004-03-10  Kelley Cook  <kcook@gcc.gnu.org>\n-\n-\t* configure.ac: Bump AC_PREREQ to 2.59.\n-\t* configure: Regenerate.\n-\t* config.in: Regenerate.\n-\n-2004-02-26  Nathanael Nerode  <neroden@gcc.gnu.org>\n-\n-\t* ltconfig, ltmain.sh: Remove unused files.\n-\t* configure.in: Remove bogus extra early invocation of\n-\tAC_CONFIG_AUX_DIR.\n-\t* configure: Regenerate.\n-\t* mkinstalldirs, install-sh, config.sub, config.guess:\n-\tRemove (now) unused files.\n-\t* Makefile.in: Regenerate (losing references to vanished\n-\tfiles).\n-\n-\t* configure.in: Add CCAS, CCASFLAGS for future automakes.\n-\t* configure, Makefile.in, include/Makefile.in: Regenerate.\n-\n-\t* Makefile.am: Remove bogus duplicate setting of AM_CFLAGS.\n-\t* Makefile.in: Regenerate.\n-\n-\t* configure.in: Remove bogus duplicate invocation of\n-\tAM_MAINTAINER_MODE.  Remove obsolete comment.\n-\t* configure: Regenerate.\n-\n-\t* acinclude.m4: Remove GC_CONFIGURE macro; move contents\n-\tto configure.in.\n-\t* aclocal.m4: Regenerate.\n-\t* configure.in: Receive contents of GC_CONFIGURE macro.\n-\t* configure: Regenerate.\n-\n-\t* configure.in: Remove more obsolete, bogus code.\n-\t* configure: Regenerate.\n-\n-\t* acinclude.m4: Remove obsolete and bogus constructs.\n-\t* aclocal.m4: Regenerate.\n-\t* configure: Regnerate.\n-\n-2004-02-23  Nathanael Nerode  <neroden@gcc.gnu.org>\n-\n-\t* acinclude.m4: De-precious CC and CXX so that the right flags\n-\tare passed down to multilibs.\n-\t* aclocal.m4: Regenerate.\n-\t* configure: Regenerate.\n-\n-2004-02-22  Zack Weinberg <zack@codesourcery.com>\n-\t    Nathanael Nerode <neroden@twcny.rr.com>\n-\t    Alexandre Oliva <aoliva@redhat.com>\n-\n-\t* config.sub, config.guess: Replace with forwarding scripts\n-\twhich invoke the master copies in the top level.\n-\n-2004-02-23  Nathanael Nerode  <neroden@gcc.gnu.org>\n-\n-\t* acinclude.m4: Remove old no-executables workaround;\n-\tadd new no-executables workaround.\n-\t* aclocal.m4: Regenerate.\n-\t* configure.in: Change prereqs to autoconf 2.57.\n-\t* configure: Regenerate with autoconf 2.57.\n-\n-\t* configure.in: Use NCN_TARGET_NONCANONICAL and friends.\n-\t* configure: Regenerate.\n-\t* Makefile.am: Use target_noncanonical variable from configure.\n-\t* Makefile.in: Regenerate.\n-\t* include/Makefile.in: Regenerate.\n-\n-2004-02-20  Andrew Cagney  <cagney@redhat.com>\n-\n-\t* config.guess: Update from version 2002-01-10 to 2004-02-16.\n-\t* config.sub: Update from version 2002-01-02 to 2004-02-16.\n-\n-2004-02-19  Nathanael Nerode  <neroden@gcc.gnu.org>\n-\n-\t* acinclude.m4: Remove bogus duplicate call to AC_CANONICAL_BUILD.\n-\t* aclocal.m4: Rebuild.\n-\t* configure: Regenerate.\n-\n-\t* acinclude.m4: Move certain code to configure.in.\n-\t* configure.in: Receive code from acinclude.m4.\n-\t* aclocal.m4: Rebuild.\n-\t* configure: Regenerate.\n-\n-\t* Makefile.direct, alloc.c: Resync to upstream 6.3 alpha 1.\n-\n-2004-01-20  Andrew Haley  <aph@redhat.com>\n-\n-\t* include/private/gcconfig.h (USE_MMAP): Define for all Linux.\n-\n-\t* configure.in: Comment change.\n-\n-2004-01-16  Andrew Haley  <aph@redhat.com>\n-\n-\t* configure.in (NO_EXECUTE_PERMISSION): Remove global declaration;\n-\tadd for ia64; remove for MIPS.\n-\t* configure: Regnerated.\n-\n-2004-01-14  Kelley Cook  <kcook@gcc.gnu.org>\n-\n-\t* configure.in: Add in AC_PREREQ(2.13)\n-\n-2004-01-07  Dave Jones <davej@redhat.com>\n-\n-\t* malloc.c (GC_generic_malloc): Correct initialization typo.\n-\t* mallocx.c (GC_generic_malloc_ignore_off_page): Ditto.\n-\n-2003-10-31  Richard Earnshaw  <rearnsha@arm.com>\n-\n-\t* include/private/gcconfig.h: Re-install change of 2003-04-16.\n-\n-2003-10-20  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n-\n-\t* mips_sgi_mach_dep.s: Use _ABIO32 instead of external\n-\t_MIPS_SIM_ABI32.\n-\n-2003-10-18  Alan Modra  <amodra@bigpond.net.au>\n-\n-\t* include/private/gcconfig.h (ALIGNMENT <powerpc linux>): Remove\n-\tunsure comment.\n-\n-2003-10-03  Jeff Sturm  <jsturm@one-point.com>\n-\n-\t* configure: Rebuild.\n-\n-2003-10-03  Hans Boehm  <Hans.Boehm@hp.com>\n-\n-\t* configure.in: Remove NO_GETENV definition for win32.\n-\t* mach_dep.c (GC_generic_push_regs): Prevent tail call optimization.\n-\t* misc.c (GC_init_inner): Call GC_thr_init for win32.\n-\t  (GC_set_warn_proc): Add assertion.\n-\t* win32_threads.c: Import 6.3alpha2 version.\n-\t* include/private/gc_priv.h: Add support for EMPTY_GETENV_RESULTS.\n-\n-2003-09-29  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n-\n-\t* configure.in: Remove wildcard from Solaris 8-9/Intel and Solaris\n-\t2.3/SPARC, there are no micro versions.\n-\tTreat Solaris 10 and up alike.\n-\t* configure: Regenerate.\n-\n-2003-09-22  Anthony Green  <green@redhat.com>\n-\n-\t* os_dep.c: Fix GC_get_stack_base build problem for vanilla elf\n-\t\"NOSYS\" targets.\n-\n-2003-09-20    <green@redhat.com>\n-\n-\t* include/private/gcconfig.h: Don't check for __XSCALE__.  Instead\n-\tcheck for __arm__ or __thumb__.\n-\n-2003-09-09  Alan Modra  <amodra@bigpond.net.au>\n-\n-\t* configure: Regenerate.\n-\n-2003-08-07  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n-\t    Roger Sayle <roger@eyesopen.com>\n-\n-\t* configure.in: Set INCLUDES to absolute path.\n-\tSave $INCLUDES in boehm-cflags, too.\n-\tSet INCLUDES so it's available to config.status.\n-\t* configure: Regenerate.\n-\n-2003-07-31  Danny Smith  <dannysmith@users.sourceforge.net>\n-\n-\t* include/gc.h (GC_CreateThread): Declare with WINAPI\n-\tattribute.\n-\t* win32_threads.c (GC_CreateThread): Make definitions consistent\n-\twith declaration.  Cast &thread_table[i].handle to PHANDLE\n-\tin call to DuplicateHandle\n-\t(thread_start): Declare as static.\n-\n-2003-07-30  Andreas Tobler  <a.tobler@schweiz.ch>\n-\n-\t* dyn_load.c: Define __private_extern__ to match Apple's system\n-\theader.\n-\n-2003-07-28  Loren J. Rittle  <ljrittle@acm.org>\n-\n-\t* os_dep.c: Remove redundancy introduced in last merge.\n-\n-2003-07-28  Jeff Sturm  <jsturm@one-point.com>\n-\n-\tImport GC 6.3alpha1.\n-\t* BCC_MAKEFILE: Merge with GC 6.3alpha1 release.\n-\t* ChangeLog: Likewise.\n-\t* Makefile.am: Likewise.\n-\t* Makefile.direct: Likewise.\n-\t* Makefile.dj: Likewise.\n-\t* allchblk.c: Likewise.\n-\t* alloc.c: Likewise.\n-\t* backgraph.c: Likewise.\n-\t* configure.host: Likewise.\n-\t* configure.in: Likewise.\n-\t* dbg_mlc.c: Likewise.\n-\t* dyn_load.c: Likewise.\n-\t* finalize.c: Likewise.\n-\t* gc_cpp.cc: Likewise.\n-\t* gc_dlopen.c: Likewise.\n-\t* gcj_mlc.c: Likewise.\n-\t* if_mach.c: Likewise.\n-\t* mach_dep.c: Likewise.\n-\t* malloc.c: Likewise.\n-\t* mallocx.c: Likewise.\n-\t* mark.c: Likewise.\n-\t* mark_rts.c: Likewise.\n-\t* misc.c: Likewise.\n-\t* os_dep.c: Likewise.\n-\t* ptr_chck.c: Likewise.\n-\t* reclaim.c: Likewise.\n-\t* solaris_pthreads.c: Likewise.\n-\t* solaris_threads.c: Likewise.\n-\t* sparc_mach_dep.S: Likewise.\n-\t* threadlibs.c: Likewise.\n-\t* typd_mlc.c: Likewise.\n-\t* version.h: Likewise.\n-\t* win32_threads.c: Likewise.\n-\t* Mac_files/MacOS_Test_config.h: Likewise.\n-\t* Mac_files/MacOS_config.h: Likewise.\n-\t* cord/cordbscs.c: Likewise.\n-\t* cord/cordprnt.c: Likewise.\n-\t* cord/de_win.c: Likewise.\n-\t* doc/README: Likewise.\n-\t* doc/README.MacOSX: Likewise.\n-\t* doc/README.changes: Likewise.\n-\t* doc/README.environment: Likewise.\n-\t* doc/README.ews4800: Likewise.\n-\t* doc/README.linux: Likewise.\n-\t* doc/README.macros: Likewise.\n-\t* doc/README.win32: Likewise.\n-\t* doc/debugging.html: Likewise.\n-\t* doc/gcdescr.html: Likewise.\n-\t* doc/tree.html: Likewise.\n-\t* include/Makefile.in: Likewise.\n-\t* include/gc.h: Likewise.\n-\t* include/gc_cpp.h: Likewise.\n-\t* include/gc_local_alloc.h: Likewise.\n-\t* include/gc_mark.h: Likewise.\n-\t* include/gc_pthread_redirects.h: Likewise.\n-\t* include/gc_typed.h: Likewise.\n-\t* include/new_gc_alloc.h: Likewise.\n-\t* include/private/dbg_mlc.h: Likewise.\n-\t* include/private/gc_hdrs.h: Likewise.\n-\t* include/private/gc_locks.h: Likewise.\n-\t* include/private/gc_pmark.h: Likewise.\n-\t* include/private/gc_priv.h: Likewise.\n-\t* include/private/gcconfig.h: Likewise.\n-\t* include/private/solaris_threads.h: Likewise.\n-\t* include/private/specific.h: Likewise.\n-\t* tests/test.c: Likewise.\n-\t* tests/test_cpp.cc: Likewise.\n-\n-\t* configure: Rebuild.\n-\t* Makefile.in: Rebuild.\n-\n-\t* mips_sgi_mach_dep.s: Add.\n-\n-\t* alpha_mach_dep.s: Remove.\n-\t* irix_threads.c: Remove.\n-\t* linux_threads.c: Remove.\n-\t* mips_sgi_mach_dep.S: Remove.\n-\t* missing: Remove.\n-\t* powerpc_macosx_mach_dep.s: Remove.\n-\t* doc/Makefile.am: Remove.\n-\t* doc/Makefile.in: Remove.\n-\n-2003-07-25  Roger Sayle  <roger@eyesopen.com>\n-\n-\t* configure.host: Only use +ESdbgasm when using the HPUX native\n-\tcompiler on PA-Risc.  It isn't recognized by GCC and is silently\n-\tignored by HP's compilers on ia64.\n-\n-2003-04-28  Mohan Embar  <gnustuff@thisiscool.com>\n-\n-\t* configure.in: define GC_DLL under mingw if --enable-shared\n-\t* configure: rebuilt\n-\t* win32_threads.c: add #ifdef GC_DLL around DllMain\n-\n-2003-04-16  Richard Earnshaw  <rearnsha@arm.com>\n-\n-\t* include/private/gcconfig.h: Add support for arm-netbsdelf.\n-\n-2003-04-09  Tom Tromey  <tromey@redhat.com>\n-\n-\t* include/private/gcconfig.h (LINUX_STACKBOTTOM): Define for\n-\tPOWERPC.\n-\t(STACK_GRAN, HEURISTIC1): Don't define for POWERPC.\n-\n-2003-03-22  Richard Henderson  <rth@redhat.com>\n-\n-\t* include/private/gc_locks.h [IA64]: Include ia64intrin.h.\n-\t(GC_test_and_set): Use __sync_lock_test_and_set.\n-\t(GC_clear): Use volatile assignment.\n-\t(GC_compare_and_exchange): Use __sync_bool_compare_and_swap.\n-\t(GC_memory_write_barrier): Use __sync_synchronize.\n-\n-2003-03-12  Andreas Schwab  <schwab@suse.de>\n-\n-\t* configure.in: Avoid trailing /. in toolexeclibdir.\n-\t* configure: Rebuilt.\n-\n-2003-03-04  Hans Boehm <Hans.Boehm@hp.com>\n-\t* include/private/gcconfig.h (GC_data_start): declare when needed.\n-\t* include/private/gc_priv.h: Include gcconfig.h after ptr_t\n-\tdeclaration.\n-\t* dyn_load.c (GC_register_dynamic_libraries_dl_iterate_phdr,\n-\tGC_register_dynlib_callback): Register main data for static\n-\texecutable if dl_iterate_phdr() didn't.\n-\t* misc.c (GC_init_inner): Call GC_init_linux_data_start() even\n-\tif we don't expect to register main static data.\n-\n-2003-03-03  Hans Boehm  <Hans.Boehm@hp.com>\n-\t* mark_rts.c (GC_cond_register_dynamic_libraries): add.\n-\t(GC_push_roots): explicitly mark free list headers, register\n-\tdynamic libraries only if !REGISTER_LIBRARIES_EARLY.\n-\t* alloc.c (GC_stopped_mark): Conditionally call\n-\tGC_cond_register_dynamic_libraries().\n-\t(GC_collect_a_little_inner, GC_try_to_collect_inner): Check GC_dont_gc.\n-\t* dyn_load.c (GC_register_main_static_data): define.\n-\t(GC_register_dyn_libraries (Linux /proc, Linux ELF versions)):\n-\tno longer skip main data.\n-\t* misc.c (GC_REGISTER_MAIN_STATIC_DATA): define.\n-\t(GC_init_inner): Make main data registration conditional.\n-\t* include/private/gc_priv.h (GC_register_main_static_data): declare.\n-\t* include/private/gcconfig.h (REGISTER_LIBRARIES_EARLY): define\n-\tfor LINUX.\n-\n-2003-02-20  Alexandre Oliva  <aoliva@redhat.com>\n-\n-\t* configure.in: Propagate ORIGINAL_LD_FOR_MULTILIBS to\n-\tconfig.status.\n-\t* configure: Rebuilt.\n-\n-2003-02-11  Andreas Tobler  <a.tobler@schweiz.ch>\n-\n-\t* include/private/gcconfig.h: undefine MPROTECT_VDB for MACOSX\n-\n-2003-01-27  Alexandre Oliva  <aoliva@redhat.com>\n-\n-\t* configure.in (toolexecdir, toolexeclibdir): Set and AC_SUBST.\n-\tRemove USE_LIBDIR conditional.\n-\t* Makefile.am (toolexecdir, toolexeclibdir): Don't override.\n-\t* Makefile.in, configure: Rebuilt.\n-\n-2002-12-31  Tom Tromey  <tromey@redhat.com>\n-\n-\tFor PR libgcj/8933:\n-\t* include/Makefile.in: Rebuilt.\n-\t* include/Makefile.am (noinst_HEADERS): Renamed from\n-\tinclude_HEADERS.\n-\n-2002-11-19  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n-\n-\t* ltconfig (osf[345]): Append $major to soname_spec.\n-\tReflect this in library_names_spec.\n-\t* ltmain.sh (osf): Prefix $major with . for use as extension.\n-\n-2002-10-02  Andreas Jaeger  <aj@suse.de>\n-\n-\t* include/private/gcconfig.h (HBLKSIZE): Define for x86-64.\n-\n-2002-09-28  Richard Earnshaw  <rearnsha@arm.com>\n-\n-\t* include/private/gcconfig.h: Don't check for __XSCALE__.  Instead\n-\tcheck for __arm__ or __thumb__.\n-\n-2002-09-27  Ulrich Weigand  <uweigand@de.ibm.com>\n-\n-\t* include/private/gcconfig: Add machine type S390.  Add s390x support.\n-\t* include/private/gc_locks.h (GC_test_and_set): Implement for s390.\n-\t(GC_compare_and_exchange): Likewise.\n-\n-2002-09-24  Jason Thorpe  <thorpej@wasabisystems.com>\n-\n-\t* include/private/gcconfig.h: Fix NetBSD/mips parameters.\n-\n-2002-08-23  Adam Megacz <adam@xwt.org>\n-\n-\t* win32_threads.cc: Removed extraneous ABORT()\n-\n-2002-09-22  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n-\n-\t* Makefile.am (all-multi): Fix multilib parallel build.\n-\n-2002-07-18  Bo Thorsen  <bo@suse.de>\n-\n-\t* include/private/gcconfig.h: Add x86-64 definitions.\n-\t* os_dep.c: Add x86-64 support.\n-\t* configure.in: Likewise.\n-\t* configure: Regenerate.\n-\n-2002-07-18  H.J. Lu <hjl@gnu.org>\n-\n-\t* mach_dep.c (GC_push_regs): Remove the unused Linux/mips code.\n-\n-2002-07-18  H.J. Lu  (hjl@gnu.org)\n-\n-\t* configure.in (machdep): Don't add mips_sgi_mach_dep.lo for\n-\tLinux/mips.\n-\n-2002-06-28  Hans Boehm <Hans_Boehm@hp.com>\n-\t    Jonathan Clark\n-\n-\t* win32_threads.c (GC_push_all_stacks): Tolerate bad sp.\n-\n-2002-06-09  H.J. Lu  (hjl@gnu.org)\n-\n-\t* include/private/gc_locks.h (GC_test_and_set): Support\n-\tLinux/mips.\n-\t(GC_TEST_AND_SET_DEFINED): Likewise.\n-\n-\t* include/private/gcconfig.h (DYNAMIC_LOADING): Defined for\n-\tLinux/mips.\n-\t(DATAEND): Likewise.\n-\t(LINUX_STACKBOTTOM): Likewise.\n-\t(STACKBOTTOM): Removed for Linux/mips.\n-\n-Sun May 19 11:32:03 2002  Mark P Mitchell  <mark@codesourcery.com>\n-\n-\t* irix_threads.cc (GC_pthread_detach): Do not use REAL_FUNC.\n-\t(GC_pthread_create): Fix typo.\n-\t(GC_TRY_LOCK): Likewise.\n-\t* include/private/gc_locks.h (GC_test_and_set): Only take one\n-\tone argument.\n-\t(LOCK): Adjust appropriately.\n-\t* include/private/gc_priv.h (SIG_SUSPEND): Use SIGRTMIN if\n-\t_SIGRTMIN is unavailable.\n-\n-2002-05-16  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n-\n-\t* acinclude.m4: Allow for PWDCMD to override hardcoded pwd.\n-\t* aclocal.m4: Regenerate.\n-\t* configure: Regenerate.\n-\n-2002-05-08  Alexandre Oliva  <aoliva@redhat.com>\n-\n-\t* configure.in (ORIGINAL_LD_FOR_MULTILIBS): Preserve LD at\n-\tscript entry, and set LD to it when configuring multilibs.\n-\t* configure: Rebuilt.\n-\n-2002-04-22  Jeff Sturm  <jsturm@one-point.com>\n-\n-\t* Makefile.am (toolexeclib_LTLIBRARIES): Remove.\n-\t(noinst_LTLIBRARIES): Add libgcjgc.la.\n-\n-\t* Makefile.in: Rebuild.\n-\n-2002-04-22  David S. Miller  <davem@redhat.com>\n-\n-\t* include/private/gcconfig.h: Hard-code STACKBOTTOM on\n-\t64-bit SPARC Linux, the __libc_stack_end technique does\n-\tnot work in this case.\n-\n-2002-04-22  Jeff Sturm  <jsturm@one-point.com>\n-\n-\t* gcconfig.h: Enable DYNAMIC_LOADING for all sparc-solaris ABIs.\n-\n-2002-04-17  Hans Boehm  <Hans_Boehm@hp.com>\n-\n-\t* include/private/gcconfig.h: Use LINUX_STACKBOTTOM for\n-\tSPARC Linux.\n-\n-2002-04-09  Loren J. Rittle  <ljrittle@acm.org>\n-\n-\t* include/private/gcconfig.h (DATAEND): Update comment example\n-\tto match reality.\n-\n-2002-04-08  Loren J. Rittle  <ljrittle@acm.org>\n-\n-\t* include/private/gcconfig.h (DATAEND): Clarify comment.\n-\n-2002-04-08  Hans Boehm  <Hans_Boehm@hp.com>\n-\n-\t* include/private/gc_priv.h (WARN macro): Add \"GC warning:\" prefix.\n-\t(GC_large_alloc_warn_interval, GC_large_alloc_warn_suppressed):\n-\tdeclare.\n-\t* allchblk.c (GC_allchblk_nth): Change text and support reduced\n-\tfrequency for blacklist warning message.\n-\t* misc.c (GC_large_alloc_warn_interval,\n-\tGC_large_alloc_warn_suppressed): define.\n-\t(GC_init_inner): Check GC_NO_BLACKLIST_WARNING and\n-\tGC_LARGE_ALLOC_WARN_INTERVAL environment variables.\n-\t* doc/README.environment (GC_NO_BLACKLIST_WARNING): Deprecate.\n-\t(GC_LARGE_ALLOC_WARN_INTERVAL): Add documentation.\n-\n-\t* dyn_load.c (_DYNAMIC): Move declaration to file scope.\n-\n-2002-04-04  Loren J. Rittle  <ljrittle@acm.org>\n-\n-\t* include/private/gcconfig.h: Add support for an unmapped\n-\tmemory hole between the end of the initialized data segment\n-\tand the start of the BSS on FreeBSD/i386.\n-\n-2002-03-30  Krister Walfridsson  <cato@df.lth.se>\n-\n-\t* include/private/gcconfig.h: define DYNAMIC_LOADING for ELF\n-\tNetBSD/i386.\n-\n-2002-03-29  Hans Boehm  <Hans_Boehm@hp.com>\n-\n-\t* linux_threads.c (return_free_lists): Clear fl[i] unconditionally.\n-\t(GC_local_gcj_malloc): Add assertion.\n-\t(start_mark_threads): Fix abort message.\n-\t* mark.c (GC_mark_from): Generalize assertion.\n-\t* reclaim.c (GC_clear_fl_links): New function.\n-\t(GC_start_reclaim): Must clear some freelist links.\n-\t* include/private/specific.h, specific.c: Add assertions.\n-\tSafer definition for INVALID_QTID, quick_thread_id.  Fix/add comments.\n-\tRearrange tse fields.\n-\n-2002-03-27  Richard Henderson  <rth@redhat.com>\n-\n-\t* os_dep.c (GC_init_linux_data_start): Fix references to\n-\t__data_start and _end.\n-\n-2002-03-25  Loren J. Rittle  <ljrittle@acm.org>\n-\n-\t* include/private/gcconfig.h: Change all likely references\n-\tto linker script synthesized symbols to use this idiom:\n-\textern int etext[]; etext\n-\n-2002-03-25  Jeff Sturm  <jsturm@one-point.com>\n-\n-\t* linux_threads.c (GC_get_nprocs): Close file descriptor.\n-\n-2002-03-21  Loren J. Rittle  <ljrittle@acm.org>\n-\n-\t* include/private/gcconfig.h: Add unified test for FreeBSD.\n-\tSupport FreeBSD/alpha.\n-\t* os_dep.c: Do not include <machine/trap.h> unless available.\n-\t(GC_freebsd_stack_base): Fix types.\n-\n-2002-03-17  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n-\n-\t* Makefile.am: Make a convenience library.\n-\t* Makefile.in: Rebuilt.\n-\n-2002-03-15  Anthony Green  <green@redhat.com>\n-\n-\t* misc.c (GC_init_inner): Initialize GC_write_cs before use.\n-\t* configure.in: Disable use of getenv for win32 targets (some of\n-\twhich have broken implementations).\n-\t* configure: Rebuilt.\n-\n-2002-03-12  Adam Megacz  <adam@xwt.org>\n-\n-\t* dyn_load.c: Renamed GC_win32s to GC_no_win32_dlls.\n-\t* misc.c: Renamed GC_is_win32s() to GC_no_win32_dlls\n-\t* os_dep.c: Renamed GC_win32s to GC_no_win32_dlls and\n-\tstatically initialized it to TRUE if compiling with GCC.\n-\t* win32_threads.c (thread_start): We no longer use SEH if\n-\tcompiling with GCC.\n-\t* mark.c (GC_mark_some): We no longer use SEH if\n-\tcompiling with GCC.\n-\n-2002-03-09  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n-\n-\t* include/gc_priv.h: Define ALIGN_DOUBLE on 32 bit targets if GCJ\n-\tsupport is enabled, for hash synchronization.\n-\n-2002-02-24  Adam Megacz  <adam@xwt.org>\n-\n-\t* Makefile.am: Added win32_threads.c to sources list.\n-\t* win32_threads.c: Added two */'s which I had neglected.\n-\n-2002-02-20  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n-\n-\t* Makefile.am: Re-add SUBDIRS parameter which was lost in merge.\n-\t* Makefile.in: Rebuilt.\n-\n-2002-02-13  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n-\n-\t* dbg_mlc.c (GC_debug_generic_malloc): Removed.\n-\n-\t* sparc_mach_dep.S: Rename from sparc_mach_dep.s as it is a\n-\tpreprocessor file.\n-\t* mips_sgi_mach_dep.S: Likewise.\n-\t* Makefile.am: Update for above changes.\n-\t* Makefile.in: Rebuilt.\n-\n-2002-02-12  Richard Henderson  <rth@redhat.com>\n-\n-\t* configure.in: Re-apply 2001-06-26 configure change.\n-\t* configure: Rebuild.\n-\n-2002-02-12  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n-\n-\tImported GC 6.1 Alpha 3.\n-\n-\t* sparc_mach_dep.S: Delete incorrectly named file.\n-\n-2001-02-11  Adam Megacz <adam@xwt.org\n-\n-\t* configure.in: support for win32, saner\n-\tcross-compile options\n-\n-2001-02-08  Anthony Green  <green@redhat.com>\n-\n-\t* include/private/gcconfig.h: Add XSCALE NOSYS support for bare\n-\t  board embedded targets.\n-\t* os_dep.c: Avoid signal handling code for NOSYS/ECOS targets.\n-\t  Use GC_get_stack_base for NOSYS/ECOS targets.  Clean up some\n-\t  redundant uses of ECOS.\n-\t* misc.c: Use NOSYS where ECOS is being used.\n-\t  Don't define GC_write twice for ECOS systems.\n-\t  (GC_write): New function for NOSYS targets.\n-\n-2002-02-06  Adam Megacz <adam@xwt.org>\n-\n-\t* boehm-gc/include/gc.h: (GC_CreateThread) This function is\n-\tnow exposed on all Win32 platforms.\n-\t* boehm-gc/win32_threads.c: (GC_CreateThread) This now\n-\tcompiles on Win32; it invokes CreateThread() if GC is built\n-\tas a DLL; otherwise it registers the thread.\n-\t* boehm-gc/misc.c (GC_init): Initialize GC_allocate_ml in case\n-\tlibgcjgc was not built as a DLL.\n-\n-2002-02-01  Adam Megacz <adam@xwt.org>\n-\n-\t* boehm-gc on win32 now automatically detects if it is being built\n-\tas a DLL; see http://gcc.gnu.org/ml/java/2001-12/msg00240.html\n-\n-2002-01-25  David Edelsohn  <edelsohn@gnu.org>\n-\n-\t* include/gc.h (GC_INIT): Add DATASTART and DATAEND roots on AIX.\n-\t* include/private/gcconfig.h (RS6000): Add 64-bit AIX support.\n-\tDefine USE_GENERIC_PUSH_REGS.  Use AIX _data and _end symbols for\n-\tDATASTART and DATAEND roots.\n-\t* rs6000_mach_dep.s: Add function descriptor and traceback table.\n-\n-2001-12-16  Jeff Sturm  <jsturm@one-point.com>\n-\n-\t* dyn_load.c: Define ElfW (if needed) for all targets,\n-\tnot just GNU/Linux.\n-\t(GC_FirstDLOpenedLinkMap): Use it.\n-\t(GC_register_dynamic_libraries_dl): Use it.\n-\t* include/private/gcconfig.h: Define CPP_WORDSZ, ELF_CLASS\n-\tfor sparcv9.\n-\n-2001-12-16  Craig Rodrigues  <rodrigc@gcc.gnu.org>\n-\n-\tPR other/3725\n-\t* configure.in: Add AC_SUBST(target_alias).\n-\t* configure: Regenerated.\n-\n-2001-11-26  Loren J. Rittle  <ljrittle@acm.org>\n-\n-\t* linux_threads.c (WRAP_FUNC(pthread_join)): Remove special\n-\tcase for GC_FREEBSD_THREADS.\n-\t* configure.in (*-*-freebsd*): Clarify warning.\n-\t* configure: Rebuilt.\n-\n-2001-10-23  Loren J. Rittle  <ljrittle@acm.org>\n-\t    Andreas Tobler <toa@pop.agri.ch>\n-\n-\t* include/private/solaris_threads.h: Update to use GC_SOLARIS_THREADS.\n-\n-2001-10-22  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n-\n-\t* linux_threads.c (GC_init_parallel): Do not declare as a static\n-\tconstructor.\n-\t* include/gc.h (GC_init): Declare here. Add description.\n-\t* include/private/gc_priv.h (GC_init): Remove declaration.\n-\n-2001-10-16  Loren J. Rittle  <ljrittle@acm.org>\n-\n-\t* include/gc_pthread_redirects.h: Generalize test to use GC_PTHREADS.\n-\t* linux_threads.c (WRAP_FUNC(pthread_join)): Conditionalized on\n-\tGC_FREEBSD_THREADS, handle strange interaction between system\n-\tpthread implementation and boehm-gc signal-handler architecture.\n-\t* tests/test.c (main): Conditionalized on GC_FREEBSD_THREADS,\n-\tset stack.\n-\t* include/private/gcconfig.h (configuration keyed off FREEBSD):\n-\tDefine SIG_SUSPEND, SIG_THR_RESTART.  Do not define\n-\tMPROTECT_VDB when GC_FREEBSD_THREADS is defined.\n-\n-2001-10-16  Loren J. Rittle  <ljrittle@acm.org>\n-\n-\t* Makefile.am (test.o): Find tests/test.c in $(srcdir).\n-\t* Makefile.in: Rebuilt.\n-\n-2001-10-16  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n-\n-\t* Makefile.am, acinclude.m4, configure.in: Imported GC 6.1 Alpha 1 and\n-\tmerged local changes.\n-\n-2001-09-26  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n-\n-\t* solaris_threads.c (MAX_ORIG_STACK_SIZE) [I386]: Provide special\n-\tSolaris 2/Intel definition.\n-\n-\t* configure.in (i?86-*-solaris2.[89]*): Define\n-\tSOLARIS25_PROC_VDB_BUG_FIXED.\n-\t* include/private/gcconfig.h [I386 && SUNOS5]: Use it.\n-\t* configure: Regenerate.\n-\n-\t* include/private/gcconfig.h [I386 && SUNOS5] (DATASTART): Use _etext.\n-\t(DATAEND): Define using _end.\n-\n-2001-09-11  Per Bothner  <per@bothner.com>\n-\n-\t* include/Makefile.am:  New file.  It defines include_HEADERS.\n-\t* Makefile.am (SUBDIRS):  New macro, set to include.\n-\t* configure.in (AC_OUTPUT):  Add include/Makefile.\n-\n-2001-08-20  Tom Tromey  <tromey@redhat.com>\n-\n-\t* configure: Rebuilt.\n-\t* configure.in: Always ask gcc for threads package.\n-\n-2001-08-17  Tom Tromey  <tromey@redhat.com>\n-\n-\t* Makefile.am, acinclude.m4, configure.in: Imported GC 6.0 and\n-\tmerged local changes.\n-\n-2001-08-02  David Billinghurst <David.Billinghurst>\n-\n-\t* configure: Rebuilt.\n-\t* configure.in:  POSIX threads on cygwin does not link with\n-\t-lpthreads.\n-\n-2001-07-03  Tom Tromey  <tromey@redhat.com>\n-\n-\tFix for PR bootstrap/3281:\n-\t* aclocal.m4, configure, Makefile.in: Rebuilt.\n-\t* acinclude.m4: Set mkinstalldirs for in-tree build.\n-\n-2001-06-26  Richard Henderson  <rth@redhat.com>\n-\n-\t* alpha_mach_dep.s: Mark call-saved FP registers.\n-\t* include/private/gcconfig.h (ALPHA): Remove USE_GENERIC_PUSH_REGS.\n-\t* configure.in (alpha*): Re-enable alpha_mach_dep.s\n-\t* configure: Rebuild.\n-\n-2001-06-12  Tom Tromey  <tromey@redhat.com>\n-\n-\t* aclocal.m4, configure: Rebuilt.\n-\t* acinclude.m4: Find configure.host in srcdir.\n-\n-2001-06-09  Alexandre Oliva  <aoliva@redhat.com>, Stephen L Moshier  <moshier@mediaone.net>\n-\n-\t* configure.in (AC_EXEEXT): Work around in case it expands to\n-\tnothing, as in autoconf 2.50.\n-\t* acinclude.m4: Likewise.\n-\t* aclocal.m4, configure: Rebuilt.\n-\n-2001-06-07  Tom Tromey  <tromey@redhat.com>\n-\n-\tFor PR bootstrap/3075:\n-\t* configure, aclocal.m4, Makefile.in: Rebuilt.\n-\t* configure.in: Don't call AC_CONFIG_AUX_DIR or\n-\tAC_CANONICAL_SYSTEM.\n-\t* acinclude.m4 (BOEHM_CONFIGURE): Call AC_CONFIG_AUX_DIR and\n-\tAC_CANONICAL_SYSTEM here.\n-\t* Makefile.am (CONFIG_STATUS_DEPENDENCIES): Use srcdir, not\n-\tboehm_gc_basedir.\n-\n-2001-05-24  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n-\n-\t* Makefile.am: Override gctest_OBJECTS so tests/test.c can be built.\n-\t(libgcjgc_la_SOURCES): Remove typo.\n-\t* tests/test.c: Fix struct names and includes for GC_GCJ_SUPPORT case.\n-\t* Makefile.in: Rebuilt.\n-\n-2001-05-21  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n-\n-\tImported version version 6.0alpha7.\n-\n-\t* README, README.Mac, README.OS2, README.QUICK, README.alpha,\n-\tREADME.amiga, README.debugging, README.dj, README.hp, README.linux,\n-\tREADME.rs6000, README.sgi, README.solaris2, README.uts,\n-\tREADME.win32, SCoptions.amiga, backptr.h, barrett_diagram,\n-\tdbg_mlc.h, gc.h, gc.man, gc_alloc.h, gc_cpp.h, gc_hdrs.h, gc_mark.h,\n-\tgc_priv.h, gc_private.h, gc_typed.h, gcconfig.h,\n-\thpux_irix_threads.c, makefile.depend, nursery.c,\n-\tsolaris_threads.h, test.c, test_cpp.cc, weakpointer.h, cord/README,\n-\tcord/SCOPTIONS.amiga, cord/SMakefile.amiga, cord/cord.h,\n-\tcord/ec.h, cord/gc.h, cord/private/cord_pos.h, include/backptr.h,\n-\tinclude/gc_copy_descr.h, include/gc_nursery.h: Remove obsolete/moved\n-\tfiles.\n-\n-2001-05-19  Hans Boehm  <hans_boehm@hp.com>\n-\n-\t* configure.host: Build with -fexceptions.\n-\t* linux_threads.c: Remember which thread stopped world for\n-\n-2001-05-04  Loren J. Rittle  <ljrittle@acm.org>\n-\t    with final tuning by Bryce McKinlay\n-\n-\t* configure.in: Add support for --enable-threads=posix on FreeBSD.\n-\t* configure: Rebuilt.\n-\n-2001-05-01  Jeffrey Oldham  <oldham@codesourcery.com>\n-\n-\t* gc_priv.h (UNLOCK): Change type of GC_noop1 argument.\n-\t(GC_noop1): Change declaration to take one argument.\n-\n-2001-04-26  Alexandre Oliva  <aoliva@redhat.com>\n-\n-\t* configure.in: Obtain THREADS with `gcc -v'.\n-\t* configure: Rebuilt.\n-\n-2001-04-05  Hans Boehm  <hans_boehm@hp.com>\n-\n-\t* misc.c: Back out buggy changes to stack clearing code.\n-\tReduce CLEAR_SIZE to 1/4 of original value to reduce time\n-\tspent clearing memory.\n-\n-2001-04-04  Hans Boehm  <hans_boehm@hp.com>\n-\n-\t* finalize.c:\n-\t- Accomodate finalization requests for static objects.\n-\t  (Will be required by hash synchronization.  May be needed\n-\t  in some configurations now.)\n-\n-\t* gc_priv.h:\n-\t- Define MIN_WORDS.  All allocation requests are rounded\n-\t  up to at least this size.  Removes a subtle assumption that\n-\t  Java objects have a 2 word header.\n-\n-\t* gcconfig.h:\n-\t- Adjust Linux/IA64 configuration for non-ancient kernels.\n-\t  (Necessary fix for IA64.)\n-\n-\t* linux_threads.c:\n-\t- Fix syntax error in currently unused code.  Will be needed\n-\t  for Linux/PA-RISC.\n-\n-\t* malloc.c:\n-\t- Handle MIN_WORDS.\n-\n-\t* misc.c:\n-\t- Handle MIN_WORDS.\n-\t- Change stack cleaning code to typically clear about one tenth\n-\t  the memory it used to in the threads configuration.  Occasionally\n-\t  still clear more.  (This is really a fix for a long-standing\n-\t  and fairly significant performance bug with threads.)\n-\n-\t* os_dep.c:\n-\t- Fix the code for finding the beginning of the data segment under\n-\t  Linux.  I believe this is necessary for some IA64 Linux\n-\t  distributions.  It will also helo other platforms, though those\n-\t  may additionally require a gcconfig.h adjustment.  (This basically\n-\t  works around the absence of a data_start or __data_start\n-\t  definition in glibc.)\n-\n-\t* test.c:\n-\t- Handle rounding due to MIN_WORDS.\n-\n-2001-03-22  Tom Tromey  <tromey@redhat.com>\n-\n-\t* Makefile.am (gctest_LDFLAGS): Use -shared-libgcc.\n-\n-2001-03-19  Tom Tromey  <tromey@redhat.com>\n-\n-\t* Makefile.in: Rebuilt.\n-\t* Makefile.am (gctest_LDFLAGS): new macro.\n-\n-2001-03-16  Tom Tromey  <tromey@redhat.com>\n-\n-\t* Makefile.in: Rebuilt.\n-\t* Makefile.am (TESTS_ENVIRONMENT): New macro.\n-\n-2001-01-23  Rod Stewart <stewart@lab43.org>\n-\n-\t* gcconfig.h: Check for `__arm__', not `arm'.\n-\n-2000-12-30  Bryce McKinlay  <bryce@albatross.co.nz>\n-\n-\t* configure.in: Rename THREADLIB to THREADLIBS.\n-\t* Makefile.am (LINK): Add $(THREADLIBS) to libtool command line. This\n-\tensures that we link the correct version of the linuxthreads semaphore\n-\tfunctions.\n-\t* Makefile.in: Rebuilt.\n-\t* configure: Rebuilt.\n-\n-\t* linux_thread.c (GC_thr_init, GC_suspend_handler): Add SIGABRT to the\n-\tlist of signals which are not blocked during suspend in the NO_SIGNALS\n-\tcase.\n-\n-2000-12-23  Hans Boehm  <Hans_Boehm@hp.com>\n-\n-\t* gcj_mlc.c (GC_gcj_malloc): Don't release allocation lock twice.\n-\n-2000-12-15  Bryce McKinlay  <bryce@albatross.co.nz>\n-\n-\t* Makefile.dist: Renamed from Makefile.orig.\n-\n-2000-12-11  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n-\n-\t* Makefile.am (gctest_LDADD): Added EXTRA_TEST_LIBS.\n-\t* configure.in (EXTRA_TEST_LIBS): Check for `dlopen' in -ldl and\n-\tset accordingly.\n-\t* Makefile.in: Rebuilt.\n-\t* configure: Likewise.\n-\n-2000-12-10  Geoffrey Keating  <geoffk@redhat.com>\n-\n-\t* gcconfig.h: Add new case for powerpc EABI.\n-\t[PPC]: Handle embedded OS for powerpc simulator.\n-\n-2000-09-30  Bryce McKinlay  <bryce@albatross.co.nz>\n-\n-\t* configure.in: Define GC_GCJ_SUPPORT. Define NO_DEBUGGING in\n-\tcross-compile configuration only.\n-\t* Makefile.am: Build gcj_mlc.c.\n-\t* configure, Makefile.in: Rebuilt.\n-\n-2000-09-10  Alexandre Oliva  <aoliva@redhat.com>\n-\n-\t* acinclude.m4: Include libtool macros from the top level.\n-\t* aclocal.m4, configure: Rebuilt.\n-\n-2000-09-04  Anthony Green  <green@redhat.com>\n-\n-\tFix for PR libgcj/230:\n-\t* mark.c (GC_mark_from_mark_stack): Remove call to\n-\tGC_debug_object_start.\n-\t* gc_priv.h (GC_debug_object_start): Remove prototype.\n-\n-2000-08-16  Alexandre Oliva  <aoliva@redhat.com>\n-\n-\t* gcconfig.h [OSF1] (_end): Declare as `int'.\n-\n-2000-08-02  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* gc_priv.h (GC_generic_malloc_inner): Prototype.\n-\t(GC_generic_malloc): Likewise.\n-\t(GC_add_to_black_list_normal): Likewise.\n-\t(GC_find_header): Likewise.\n-\t(GC_ADD_TO_BLACK_LIST_NORMAL): Cast bits argument to word.\n-\t* gc_mark.h (GC_find_start): Prototype.\n-\t(GC_signal_mark_stack_overflow): Likewise.\n-\n-2000-07-24  Alexandre Oliva  <aoliva@redhat.com>\n-\n-\t* configure.in (THREADS): Don't --enable-threads on IRIX <= 5.*.\n-\t* configure: Rebuilt.\n-\n-\t* dyn_load.c (GC_scratch_last_end_ptr): Don't declare a #define.\n-\n-2000-06-20  Bryce McKinlay  <bryce@albatross.co.nz>\n-\n-\tImported version 5.1.\n-\t* acinclude.m4: Push version to 5.1.\n-\n-2000-06-19  Andrew Haley  <aph@cygnus.com>\n-\n-\t* os_dep.c (read): Pass two dummy args to syscall().\n-\n-2000-05-11  Bryce McKinlay  <bryce@albatross.co.nz>\n-\n-\tImported 5.0 release version.\n-\t* acinclude.m4: Increment version to 5.0.\n-\n-2000-05-07  Bryce McKinlay  <bryce@albatross.co.nz>\n-\n-\tImported version 5.0alpha7.\n-\t* acinclude.m4: Update version to 5.0a7.\n-\n-2000-04-26  Jakub Jelinek  <jakub@redhat.com>\n-\n-\t* gcconfig.h (SPARC): Define ALIGNMENT to 8 for 64bit SPARC.\n-\t(SPARC/LINUX): Use GC_SysVGetDataStart instead of LINUX_DATA_START\n-\t- sparc glibc does not provide it.\n-\t(SAVE_CALL_CHAIN, ASM_CLEAR_CODE): Define on sparc*-linux*.\n-\tMake STACKBOTTOM depend on the wordsize.\n-\t* os_dep.c (GC_SysVGetDataStart): Compile in on sparc*-linux*.\n-\t(struct frame): Declare on sparc*-linux*.\n-\t(GC_save_callers): Bias the frame pointers if needed (sparc64).\n-\t* mach_dep.c (GC_save_regs_in_stack): Optimize on sparc32.\n-\tImplement on sparc64.\n-\t(GC_clear_stack_inner): Implement on sparc64.\n-\t* gc_priv.h (GC_test_and_set): Implement for sparc.\n-\t* linux_threads.c (GC_suspend_handler, GC_push_all_stacks): Use\n-\tGC_save_regs_in_stack on sparc.\n-\n-2000-04-23  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* gcconfig.h (DYNAMIC_LOADING): Define for PPC Linux.\n-\n-2000-04-19  Bryce McKinlay  <bryce@albatross.co.nz>\n-\n-\tImported version version 5.0alpha6.\n-\t* acinclude.m4: Bump version to 5.0a6.\n-\t* configure.in: Don't use alpha_mach_dep.s.\n-\t* include/private/config.h, irix_threads.c gc_watcom.asm: Delete\n-\tobsolete files.\n-\t* Makefile.am, Makefile.in: irix_threads.c is now\n-\thpux_irix_threads.c.\n-\t* Makefile.orig: Updated from gc distribution Makefile.\n-\n-2000-03-26  Anthony Green  <green@redhat.com>\n-\n-\t* misc.c (GC_enable): Always define GC_enable and GC_disable.\n-\n-2000-02-14  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* gc.h (dlopen): Define as GC_dlopen on Linux.\n-\t(GC_dlopen): Declare on Linux.\n-\t* dyn_load.c (GC_dlopen): Define for Linux.\n-\n-Fri Jan 28 17:13:20 2000  Anthony Green  <green@cygnus.com>\n-\n-\t* gcconfig.h (DATASTART): Add missing extern declaration\n-\tfor data_start on powerpc.\n-\n-1999-12-22  Bryce McKinlay  <bryce@albatross.co.nz>\n-\n-\t* linux_threads.c: Don't block SIGINT, SIGQUIT, SIGTERM in the\n-\tNO_SIGNALS case.\n-\n-1999-12-19  Jeff Sturm  <jsturm@sigma6.com>\n-\n-\t* gcconfig.h: Define DATASTART for Alpha Linux.\n-\n-1999-12-19  Anthony Green  <green@cygnus.com>\n-\n-\t* gcconfig.h: Use libgcj hack for Alpha Linux.\n-\tUndefine MPROTEXT_VDB (from Jeff Sturm).\n-\t* os_dep.c: Remove Alpha Linux hacks.\n-\t* misc.c: Ditto.\n-\n-1999-12-13  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* aclocal.m4, configure: Rebuilt.\n-\t* acinclude.m4: Changed version to 5.0a4.\n-\t* Makefile.in: Rebuilt.\n-\t* Makefile.am (libgcjgc_la_LDFLAGS): Changed version to 1:1:0.\n-\n-1999-12-12  Anthony Green  <green@cygnus.com>\n-\n-\t* gcconfig.h (DATASTART): Define as (&data_start) for PowerPC\n-\tLinux.\n-\t(DYNAMIC_LOADING): Define for PowerPC Linux.\n-\t* os_dep.c: Remove some special cases for PowerPC Linux.\n-\t* misc.c (GC_init_inner): Don't call GC_init_linux_data_start\n-\tfor PowerPC Linux.\n-\n-1999-11-04  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* Makefile.in: Rebuilt.\n-\t* Makefile.am (libgcjgc_la_SOURCES): Removed quick_threads.c.\n-\n-\t* misc.c (GC_init_inner): Don't call GC_init_linuxppc().\n-\t(GC_thr_init): Don't declare.\n-\n-\t* configure: Rebuilt.\n-\t* configure.in: Removed qt threads case.\n-\t* dyn_load.c: Don't mention QUICK_THREADS.\n-\t* os_dep.c: Don't mention QUICK_THREADS.\n-\t* misc.c: Don't mention QUICK_THREADS.\n-\t* gcconfig.h: Don't mention QUICK_THREADS.\n-\t* gc_priv.h: Removed QUICK_THREADS code.\n-\t* quick_threads.c: Removed.\n-\n-1999-11-03  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* gcconfig.h: Merged in local changes from old config.h.\n-\n-1999-11-02  Bryce McKinlay  <bryce@albatross.co.nz>\n-\n-\t* gcconfig.h: Don't define MPROTECT_VDB on Linux/i386.\n-\n-1999-11-02  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* quick_threads.c: Include gcconfig.h, not boehm-config.h.\n-\n-\t* configure: Rebuilt.\n-\t* configure.in: Don't create boehm-config.h.\n-\t* Makefile.in: Rebuilt.\n-\t* Makefile.am (libgcjgc_la_SOURCES): Reference gcconfig.h, not\n-\tconfig.h.\n-\t($(all_objs)): Depend on gcconfig.h.\n-\t* gc_priv.h: Reference GCCONFIG_H, not CONFIG_H.\n-\t* gcconfig.h: Define GCCONFIG_H, not CONFIG_H.\n-\t* config.h: Removed.\n-\n-1999-11-01  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* Makefile.in: Rebuilt.\n-\t* Makefile.am (gctest_LDADD): Added THREADLIB.\n-\t(TESTS): New macro.\n-\t* configure: Rebuilt.\n-\t* configure.in (INCLUDES): New subst.\n-\n-1999-09-29  Steve Chamberlain  <sac@pobox.com>\n-\n-\t* config.h: Added picoJava target.\n-\t* mach_dep.h (GC_push_regs):  New code for picoJava.\n-\n-1999-09-28  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* aclocal.m4, configure: Rebuilt.\n-\t* acinclude.m4 (LIB_AC_PROG_CC, LIB_AC_PROG_CXX): Provide\n-\tappropriate AC_PROG_ symbol.\n-\n-Tue Aug 10 00:08:29 1999  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n-\n-\t* gc_priv.h:  IRIX thread changes from\n-\tinclude/private/gc_priv.h.\n-\n-Mon Aug  9 18:33:38 1999  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n-\n-\t* Makefile.in: Rebuilt.\n-\t* Makefile.am (toolexeclibdir): Add $(MULTISUBDIR) even for native\n-\tbuilds.\n-\n-\t* configure: Rebuilt.\n-\t* configure.in: Properly align --help output, fix capitalization\n-\tand punctuation.\n-\t* acinclude.m4: Likewise.\n-\n-1999-08-04  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* configure.in: Added missing `;;'.  From Anthony Green.\n-\n-Mon Aug  2 23:09:41 1999  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n-\n-\t* configure.in (machdep): Use mips_ultrix_mach_dep.s on Ultrix V4.\n-\n-1999-08-03  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* gc_priv.h (GC_test_and_set): Implementation for Linux PPC from\n-\tFranz Sirl <Franz.Sirl-kernel@lauterbach.com>.\n-\n-1999-08-02  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* aclocal.m4, configure: Rebuilt for new libtool.\n-\n-1999-07-31  Alexandre Oliva  <oliva@dcc.unicamp.br>\n-\n-\t* mips_sgi_mach_dep.s: Enable PIC option.\n-\n-1999-07-19  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* config.h (MPROTECT_VDB): Don't define on Linux.\n-\n-1999-07-19  Alexandre Oliva  <oliva@dcc.unicamp.br>\n-\n-\t* Makefile.am (.s.lo): Avoid `#line' directives.\n-\t* Makefile.in: Rebuilt.\n-\n-1999-07-19  Alexandre Oliva  <oliva@dcc.unicamp.br>\n-\n-\t* Makefile.am (*-recursive, *-am, *-multi): Automake does not\n-\tgenerate *-recursive for this Makefile, use *-am instead.\n-\t* Makefile.in: Rebuilt.\n-\n-1999-06-30  Alexandre Oliva  <oliva@dcc.unicamp.br>\n-\n-\t* Makefile.am (.s.lo): Renamed from `.s.o'.\n-\t* Makefile.in: Rebuilt.\n-\n-1999-06-21  Tom Tromey  <tromey@cygnus.com>\n-\n-\tAlpha patch from Jeff Sturm:\n-\t* os_dep.c (GC_init_linuxalpha): New function.\n-\t* misc.c: Initialize for alpha linux.\n-\t* gc_priv.h (GC_test_and_set): Define for alpha.\n-\t* config.h: Don't assume __data_start on alpha.\n-\n-\t* Makefile.in: Rebuilt.\n-\t* Makefile.am (libgcjgc_la_LDFLAGS): Use -version-info, not\n-\t-release.\n-\n-\t* Makefile.in: Rebuilt.\n-\t* Makefile.am (toolexeclibdir): Define as libdir when\n-\tappropriate.\n-\t* configure: Rebuilt.\n-\t* configure.in (USE_LIBDIR): New conditional.\n-\n-\t* configure: Rebuilt.\n-\t* configure.in: Recognize all forms of alpha.\n-\n-1999-06-17  Anthony Green  <green@cygnus.com>\n-\n-\t* mach_dep.c (GC_push_regs): FreeBSD-elf support (from\n-\tCarlo Dapor <carlo@vis.ethz.ch>).\n-\n-1999-05-05  Gilles Zunino  <Gilles.Zunino@hei.fr>\n-\n-\t* configure.in: Switch from irix threads to posix threads\n-\tDefined IRIX_THREADS. Put mips_sgi_mach_dep.lo into machdep\n-\tfor mips architecture.\n-\t* configure: Regenerate.\n-\n-1999-04-30  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* linux_threads.c: Don't reference __pthread_initial_thread_bos.\n-\n-1999-04-26  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* dyn_load.c (GC_FirstDLOpenedLinkMap): Declare _DYNAMIC as\n-\t`weak'.\n-\n-1999-04-23  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* Makefile.in, configure: Rebuilt.\n-\t* Makefile.am (EXTRA_LIBRARIES): Mention libgcjgc.la.\n-\t(libgcjgc_la_SOURCES): Renamed.\n-\t(libgcjgc_la_LIBADD): Likewise.\n-\t(libgcjgc_la_DEPENDENCIES): Likewise.\n-\t(EXTRA_libgcjgc_la_SOURCES): Likewise.\n-\t(gctest_LDADD): Use libgcjgc.la.\n-\t(all_objs): Mention libgcj_la_OBJECTS.\n-\t(EXTRA_LTLIBRARIES): Renamed.\n-\t(toollib_LTLIBRARIES): Likewise.\n-\t(libgcjgc_la_LDFLAGS): New macro\n-\t(toolexecdir): Renamed.\n-\t(toolexeclibdir): Likewise.\n-\t(toolexeclib_LTLIBRARIES): Likewise.\n-\t(LTCOMPILE): Renamed; added libtool invocation.\n-\t(LINK): Added libtool invocation.\n-\t(.s.o): use LTCOMPILE.\n-\t* configure.in: Call AM_PROG_LIBTOOL.\n-\t(target_all): Set to libgcjgc.la.\n-\tMention `.lo' forms of object files.\n-\n-1999-04-21  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* misc.c (GC_init_inner): If QUICK_THREADS defined, compute\n-\tGC_stackbottom.\n-\n-\t* os_dep.c: glibc 2.1 requires asm/sigcontext.h, not\n-\tsigcontext.h.  From Matthias Klose <doko@itso.de>.\n-\n-1999-04-16  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* config.h (__start): Declare as `int' in alpha/OSF1 case.  From\n-\tDavid Pettersson <dapet@mai.liu.se>\n-\n-1999-04-14  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* configure: Rebuilt.\n-\t* configure.in: Don't use sparc_mach_dep.o for Solaris.  Reverts\n-\tincorrect patch of 199-04-09.\n-\n-\t* configure: Rebuilt.\n-\t* configure.in: Added support for alpha.\n-\tFrom David Pettersson <dapet@mai.liu.se>.\n-\n-1999-04-13  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* Makefile.in: Rebuilt.\n-\t* Makefile.am (libgcjgc_a_SOURCES): Added solaris-threads.c and\n-\tsolaris-threads.h.\n-\n-1999-04-09  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* configure: Rebuilt.\n-\t* configure.in: Use sparc_mach_dep.s when building on Solaris.\n-\n-1999-02-23  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* configure: Rebuilt.\n-\t* configure.in: For Linux, define _REENTRANT.  For Solaris, define\n-\tSOLARIS_THREADS and _SOLARIS_PTHREADS.\n-\n-1999-02-18  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* quick_threads.c (GC_push_all_stacks): Change order of arguments\n-\tto GC_push_all_stacks depending on STACK_GROWS_DOWN define.  Check\n-\tfor case where LO is NULL.\n-\n-1999-02-10  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* aclocal.m4, configure, Makefile.in: Rebuilt.\n-\t* acinclude.m4: Updated to be used with automake 1.4.\n-\t* configure.in: Renamed libgc to libgcjgc.  Updated to be used\n-\twith automake 1.4.\n-\t* Makefile.am (EXTRA_LIBRARIES): Renamed libgc to libgcjgc.\n-\t(libgcjgc_a_SOURCES): Likewise.\n-\t(libgcjgc_a_LIBADD): Likewise.\n-\t(libgcjgc_a_DEPENDENCIES): Likewise.\n-\t(EXTRA_libgcjgc_a_SOURCES): Likewise.\n-\t(gctest_LDADD): Likewise.\n-\t(all_objs): Likewise.\n-\n-1999-01-08  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* configure: Rebuilt.\n-\t* configure.in: Define LINUX_THREADS if using POSIX threads on\n-\tLinux.\n-\n-\t* gc_priv.h (GC_test_and_set): Put return type into definition.\n-\n-1998-11-24  Andrew Haley  <aph@viagra.cygnus.co.uk>\n-\n-\t* Makefile.am: add support for eCos.  In particular, add C++\n-\tsupport for compiling the file ecos.cc.\n-\t* ecos.cc: new file.\n-\t* acinclude.m4: add C++ support.\n-\t* aclocal.m4: likewise\n-\t* config.h: add eCos support.\n-\t* configure: likewise\n-\t* configure.in: likewise\n-\t* misc.c (GC_write): add eCos support.\n-\t* os_dep.c (tiny_sbrk): add eCos support.\n-\n-Thu Dec 10 18:24:34 1998  Warren Levy  <warrenl@cygnus.com>\n-\n-\t* misc.c (GC_init_inner): Moved STACKBASE code to os_dep.c.\n-\t* os_dep.c (GC_get_stack_base): Moved STACKBASE code from misc.c.\n-\n-1998-11-23  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* configure.host (boehm_gc_cflags): Don't add `-O2'.\n-\n-1998-11-20  Andrew Haley  <aph@viagra.cygnus.co.uk>\n-\n-\t* Makefile.am, Makefile.in, configure.host: tx39 build option\n-\t\"-G 0\" added.\n-\n-1998-11-17  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* configure: Rebuilt.\n-\t* configure.in: Switch on host, not target.\n-\n-1998-11-16  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* gc_priv.h (GC_debug_object_start): Declare.\n-\t* mark.c (GC_mark_from_mark_stack): Call GC_debug_object_start.\n-\t* gc.h (GC_debug_register_finalizer_no_order,\n-\tGC_register_finalizer_no_order): Declare.\n-\t(GC_REGISTER_FINALIZER_NO_ORDER): New macro.\n-\t* dbg_mlc.c (GC_debug_register_finalizer_no_order): New function.\n-\t(GC_debug_generic_malloc): Likewise.\n-\t(GC_debug_object_start): new function.\n-\n-1998-11-11  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* configure: Rebuilt.\n-\t* configure.in: Recognize --enable-java-gc, not --enable-gc.\n-\n-Tue Nov  3 18:01:12 1998  Tom Tromey  <tromey@sanguine.cygnus.com>\n-\n-\t* dyn_load.c: Handle QUICK_THREADS case.\n-\n-1998-10-21  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* configure: Rebuilt.\n-\t* configure.in: Put cpp defines here, not in config.h.  Recognize\n-\t--enable-threads.  Set INCLUDES.  Create boehm-cflags file.  Don't\n-\tdefine PACKAGE or VERSION.\n-\t* config.h (SILENT, NO_SIGNALS, NO_DEBUGGING, JAVA_FINALIZATION):\n-\tDon't define.\n-\n-\t* os_dep.c (GC_default_push_other_roots): Define when\n-\tQUICK_THREADS defined.\n-\t* misc.c: Added QUICK_THREADS case.\n-\t* gc_priv.h: Added QUICK_THREADS case to define LOCK and UNLOCK.\n-\t* config.h (THREADS): Define if QUICK_THREADS defined.\n-\t* Makefile.in: Rebuilt.\n-\t* Makefile.am (libgc_a_SOURCES): Added linux_threads.c,\n-\tquick_threads.c.\n-\t* quick_threads.c: New file.\n-\n-1998-10-20  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* aclocal.m4, configure: Rebuilt.\n-\t* acinclude.m4: Don't subst machine_dir or sys_dir.\n-\t* configure.host: Removed unused code.\n-\n-Sun Oct 11 08:18:02 1998  Anthony Green  <green@cygnus.com>\n-\n-\t* configure: Rebuilt.\n-\t* configure.in: Fix typo in previous patch.\n-\n-Sun Oct 11 08:06:11 1998  Anthony Green  <green@cygnus.com>\n-\n-\t* Makefile.in, aclocal.m4, configure: Rebuilt.\n-\t* Makefile.am, acinclude.m4, configure.in: Add multilib support.\n-\t* configure.host: Created.\n-\n-Tue Sep  1 10:58:15 1998  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* Makefile.in: Rebuilt.\n-\t* Makefile.am (lib_LIBRARIES): Use target_all.\n-\t(EXTRA_LIBRARIES): New macro.\n-\t* configure: Rebuilt.\n-\t* configure.in: Recognize --enable-gc.\n-\n-Thu Aug 13 10:52:45 1998  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* Makefile.in: Rebuilt.\n-\t* Makefile.am (COMPILE): Define.\n-\t(LINK): Likewise.\n-\t(.s.o): Use MY_CFLAGS.\n-\t* configure: Rebuilt.\n-\t* configure.in (MY_CFLAGS): Define and subst.\n-\n-Wed Aug 12 11:41:43 1998  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* configure: Rebuilt.\n-\t* configure.in: Added --with-cross-host argument.  Use\n-\t$with_cross_host to determine when cross-compiling.\n-\n-\t* config.h (SMALL_CONFIG): Don't define.\n-\t* configure: Rebuilt.\n-\t* configure.in: Define SMALL_CONFIG when cross-compiling.\n-\n-Tue Aug 11 11:41:25 1998  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* solaris_pthreads.c, misc.c, gc_priv.h, config.h, alloc.c,\n-\tallchblk.c: Merged with 4.13a2 while preserving local changes.\n-\n-\t* Makefile.orig: Updated from Makefile in 4.13a2.\n-\n-\t* configure: Rebuilt.\n-\t* configure.in: Updated version number to 4.13a2.  On Solaris,\n-\tdon't build with -O when using gcc.\n-\n-\tMerged in version 4.13alpha2:\n-\t* config.h (USE_MMAP): Re-enable on Solaris.\n-\t* solaris_pthreads.c: Removed RCS Id line.\n-\t* alpha_mach_dep.s: Removed RCS Id line.\n-\n-Wed Jul 22 15:38:12 1998  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* config.h (USE_MMAP): Don't define for Solaris.\n-\n-Wed Jun 10 12:51:41 1998  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* Makefile.in: Rebuilt.\n-\t* Makefile.am (libgc_a_SOURCES): Removed setjmp_t.c.\n-\n-\t* Makefile.in: Rebuilt.\n-\t* Makefile.am (libgc_a_SOURCES): Removed add_gc_prefix.c.\n-\n-Thu May 14 15:32:58 1998  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* Makefile.in: Rebuilt.\n-\t* Makefile.am ($(all_objs)): Depend on config.h.\n-\n-\t* config.h: [MIPS] If DATASTART_IS_ETEXT defined then define\n-\tDATASTART as &_etext.\n-\t* misc.c (GC_init_inner): If STACKBASE defined, then use it.\n-\t* configure: Rebuilt.\n-\t* configure.in: Define STACKBASE and DATASTART_IS_ETEXT for the\n-\ttx39.\n-\n-Tue May 12 13:15:45 1998  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* alloc.c: Don't call GET_TIME if NO_CLOCK defined.\n-\t(GC_maybe_gc): Likewise.\n-\t* os_dep.c: If NO_SIGSET defined, then have empty\n-\tGC_disable_signals and GC_enable_signals.\n-\t* configure: Rebuilt.\n-\t* configure.in: Added --with-target-subdir option.  If\n-\tcross-compiling, define NO_SIGSET and NO_CLOCK.\n-\n-Wed May  6 16:40:28 1998  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* Makefile.in: Rebuilt.\n-\t* Makefile.am (.s.o): Directly use CC -x assembler-with-cpp.\n-\t(AS): Removed.\n-\t* aclocal.m4, configure: Rebuilt.\n-\t* acinclude.m4: New file.\n-\t* configure.in: Don't run AM_EXEEXT.  Use LIB_AC_PROG_CC.\n-\n-Thu Apr 30 14:51:12 1998  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* configure: Rebuilt.\n-\t* configure.in: Link boehm-config.h to config.h.\n-\t* Makefile.in: Rebuilt.\n-\t* Makefile.am (INCLUDES): Removed.\n-\t* config.h (SILENT, SMALL_CONFIG, NO_SIGNALS, NO_DEBUGGING,\n-\tJAVA_FINALIZATION): Define\n-\n-Wed Apr 29 11:03:14 1998  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* Many files: Use GC_bool, not bool.\n-\t* gc_priv.h: Define GC_bool, not bool.\n-\n-\t* misc.c (GC_dont_gc): Define as int.\n-\t(GC_quiet): Likewise.\n-\t* gc_priv.h (GC_never_stop_func): Declare as returning bool.\n-\t* alloc.c (GC_dont_expand): Define as int.\n-\t* gc_priv.h: For gcc, define bool as char.\n-\n-Tue Apr 28 22:44:16 1998  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* Makefile.in: Rebuilt.\n-\t* Makefile.am (check_PROGRAMS): New macro.\n-\t(gctest_SOURCES): Likewise.\n-\t(gctest_LDADD): Likewise.\n-\n-Mon Apr 27 23:53:24 1998  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* Makefile.in: Rebuilt.\n-\t* Makefile.am (libgc_a_SOURCES): Added dyn_load.c.\n-\t* configure: Rebuilt.\n-\t* configure.in: Define SUNOS53_SHARED_LIB on Solaris 2.3.\n-\n-Wed Apr 15 11:40:56 1998  Tom Tromey  <tromey@sanguine.cygnus.com>\n-\n-\t* Makefile.am, Makefile.in, configure.in, configure, aclocal.m4:\n-\tNew files.\n-\t* Makefile.orig: Renamed from Makefile."}, {"sha": "d7674b3a3e9328fca2414b27e56ad9f646ee9efa", "filename": "boehm-gc/EMX_MAKEFILE", "status": "removed", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FEMX_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FEMX_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FEMX_MAKEFILE?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,141 +0,0 @@\n-#\n-#  OS/2 specific Makefile for the EMX environment\n-#\n-#  You need GNU Make 3.71, gcc 2.5.7, emx 0.8h and GNU fileutils 3.9\n-#  or similar tools. C++ interface and de.exe weren't tested.\n-#\n-#  Rename this file \"Makefile\".\n-#\n-\n-# Primary targets:\n-# gc.a - builds basic library\n-# c++ - adds C++ interface to library and include directory\n-# cords - adds cords (heavyweight strings) to library and include directory\n-# test - prints porting information, then builds basic version of gc.a, and runs\n-#        some tests of collector and cords.  Does not add cords or c++ interface to gc.a\n-# cord/de.exe - builds dumb editor based on cords.\n-CC= gcc\n-CXX=g++\n-# Needed only for \"make c++\", which adds the c++ interface\n-\n-CFLAGS= -O -DALL_INTERIOR_POINTERS -DSILENT\n-# Setjmp_test may yield overly optimistic results when compiled\n-# without optimization.\n-# -DSILENT disables statistics printing, and improves performance.\n-# -DCHECKSUMS reports on erroneously clear dirty bits, and unexpectedly\n-#   altered stubborn objects, at substantial performance cost.\n-# -DFIND_LEAK causes the collector to assume that all inaccessible\n-#   objects should have been explicitly deallocated, and reports exceptions\n-# -DSOLARIS_THREADS enables support for Solaris (thr_) threads.\n-#   (Clients should also define SOLARIS_THREADS and then include\n-#   gc.h before performing thr_ or GC_ operations.)\n-# -DALL_INTERIOR_POINTERS allows all pointers to the interior\n-#   of objects to be recognized.  (See gc_private.h for consequences.)\n-# -DSMALL_CONFIG tries to tune the collector for small heap sizes,\n-#   usually causing it to use less space in such situations.\n-#   Incremental collection no longer works in this case.\n-# -DDONT_ADD_BYTE_AT_END is meaningful only with\n-#   -DALL_INTERIOR_POINTERS.  Normally -DALL_INTERIOR_POINTERS\n-#   causes all objects to be padded so that pointers just past the end of\n-#   an object can be recognized.  This can be expensive.  (The padding\n-#   is normally more than one byte due to alignment constraints.)\n-#   -DDONT_ADD_BYTE_AT_END disables the padding.\n-\n-AR= ar\n-RANLIB= ar s\n-\n-# Redefining srcdir allows object code for the nonPCR version of the collector\n-# to be generated in different directories\n-srcdir = .\n-VPATH = $(srcdir)\n-\n-OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dyn_load.o dbg_mlc.o malloc.o stubborn.o checksums.o typd_mlc.o ptr_chck.o mallocx.o\n-\n-CORD_OBJS=  cord/cordbscs.o cord/cordxtra.o cord/cordprnt.o\n-\n-CORD_INCLUDE_FILES= $(srcdir)/gc.h $(srcdir)/cord/cord.h $(srcdir)/cord/ec.h \\\n-           $(srcdir)/cord/cord_pos.h\n-\n-# Libraries needed for curses applications.  Only needed for de.\n-CURSES= -lcurses -ltermlib\n-\n-# The following is irrelevant on most systems.  But a few\n-# versions of make otherwise fork the shell specified in\n-# the SHELL environment variable.\n-SHELL= bash\n-\n-SPECIALCFLAGS = \n-# Alternative flags to the C compiler for mach_dep.c.\n-# Mach_dep.c often doesn't like optimization, and it's\n-# not time-critical anyway.\n-\n-all: gc.a gctest.exe\n-\n-$(OBJS) test.o: $(srcdir)/gc_priv.h $(srcdir)/gc_hdrs.h $(srcdir)/gc.h \\\n-    $(srcdir)/gcconfig.h $(srcdir)/gc_typed.h\n-# The dependency on Makefile is needed.  Changing\n-# options such as -DSILENT affects the size of GC_arrays,\n-# invalidating all .o files that rely on gc_priv.h\n-\n-mark.o typd_mlc.o finalize.o: $(srcdir)/include/gc_mark.h $(srcdir)/include/private/gc_pmark.h\n-\n-gc.a: $(OBJS)\n-\t$(AR) ru gc.a $(OBJS)\n-\t$(RANLIB) gc.a\n-\n-cords: $(CORD_OBJS) cord/cordtest.exe\n-\t$(AR) ru gc.a $(CORD_OBJS)\n-\t$(RANLIB) gc.a\n-\tcp $(srcdir)/cord/cord.h include/cord.h\n-\tcp $(srcdir)/cord/ec.h include/ec.h\n-\tcp $(srcdir)/cord/cord_pos.h include/cord_pos.h\n-\n-gc_cpp.o: $(srcdir)/gc_cpp.cc $(srcdir)/gc_cpp.h\n-\t$(CXX) -c -O $(srcdir)/gc_cpp.cc\n-\t\n-c++: gc_cpp.o $(srcdir)/gc_cpp.h\n-\t$(AR) ru gc.a gc_cpp.o\n-\t$(RANLIB) gc.a\n-\tcp $(srcdir)/gc_cpp.h include/gc_cpp.h \n-\n-mach_dep.o: $(srcdir)/mach_dep.c\n-\t$(CC) -o mach_dep.o -c $(SPECIALCFLAGS) $(srcdir)/mach_dep.c\n-\n-mark_rts.o: $(srcdir)/mark_rts.c\n-\t$(CC) -o mark_rts.o -c $(CFLAGS) $(srcdir)/mark_rts.c\n-\n-cord/cordbscs.o: $(srcdir)/cord/cordbscs.c $(CORD_INCLUDE_FILES)\n-\t$(CC) $(CFLAGS) -c $(srcdir)/cord/cordbscs.c -o  cord/cordbscs.o\n-\n-cord/cordxtra.o: $(srcdir)/cord/cordxtra.c $(CORD_INCLUDE_FILES)\n-\t$(CC) $(CFLAGS) -c $(srcdir)/cord/cordxtra.c -o  cord/cordxtra.o\n-\n-cord/cordprnt.o: $(srcdir)/cord/cordprnt.c $(CORD_INCLUDE_FILES)\n-\t$(CC) $(CFLAGS) -c $(srcdir)/cord/cordprnt.c -o cord/cordprnt.o\n-\n-cord/cordtest.exe: $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a\n-\t$(CC) $(CFLAGS) -o cord/cordtest.exe $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a\n-\n-cord/de.exe: $(srcdir)/cord/de.c $(srcdir)/cord/cordbscs.o $(srcdir)/cord/cordxtra.o gc.a\n-\t$(CC) $(CFLAGS) -o cord/de.exe $(srcdir)/cord/de.c $(srcdir)/cord/cordbscs.o $(srcdir)/cord/cordxtra.o gc.a $(CURSES)\n-\n-clean: \n-\trm -f gc.a tests/test.o gctest.exe output-local output-diff $(OBJS) \\\n-\t      setjmp_test  mon.out gmon.out a.out core \\\n-\t      $(CORD_OBJS) cord/cordtest.exe cord/de.exe\n-\t-rm -f *~\n-\n-gctest.exe: tests/test.o gc.a\n-\t$(CC) $(CFLAGS) -o gctest.exe tests/test.o gc.a\n-\n-# If an optimized setjmp_test generates a segmentation fault,\n-# odds are your compiler is broken.  Gctest may still work.\n-# Try compiling setjmp_t.c unoptimized.\n-setjmp_test.exe: $(srcdir)/setjmp_t.c $(srcdir)/gc.h\n-\t$(CC) $(CFLAGS) -o setjmp_test.exe $(srcdir)/setjmp_t.c\n-\n-test: setjmp_test.exe gctest.exe\n-\t./setjmp_test\n-\t./gctest\n-\tmake cord/cordtest.exe\n-\tcord/cordtest"}, {"sha": "cc12cd15d988c8665caf0c358fc18cb84ecd9a76", "filename": "boehm-gc/MacOS.c", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMacOS.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMacOS.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMacOS.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,154 +0,0 @@\n-/*\n-\tMacOS.c\n-\t\n-\tSome routines for the Macintosh OS port of the Hans-J. Boehm, Alan J. Demers\n-\tgarbage collector.\n-\t\n-\t<Revision History>\n-\t\n-\t11/22/94  pcb  StripAddress the temporary memory handle for 24-bit mode.\n-\t11/30/94  pcb  Tracking all memory usage so we can deallocate it all at once.\n-\t02/10/96  pcb  Added routine to perform a final collection when\n-unloading shared library.\n-\t\n-\tby Patrick C. Beard.\n- */\n-/* Boehm, February 15, 1996 2:55 pm PST */\n-\n-#include <Resources.h>\n-#include <Memory.h>\n-#include <LowMem.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-#include \"gc.h\"\n-#include \"gc_priv.h\"\n-\n-// use 'CODE' resource 0 to get exact location of the beginning of global space.\n-\n-typedef struct {\n-\tunsigned long aboveA5;\n-\tunsigned long belowA5;\n-\tunsigned long JTSize;\n-\tunsigned long JTOffset;\n-} *CodeZeroPtr, **CodeZeroHandle;\n-\n-void* GC_MacGetDataStart()\n-{\n-\tCodeZeroHandle code0 = (CodeZeroHandle)GetResource('CODE', 0);\n-\tif (code0) {\n-\t\tlong belowA5Size = (**code0).belowA5;\n-\t\tReleaseResource((Handle)code0);\n-\t\treturn (LMGetCurrentA5() - belowA5Size);\n-\t}\n-\tfprintf(stderr, \"Couldn't load the jump table.\");\n-\texit(-1);\n-\treturn 0;\n-}\n-\n-/* track the use of temporary memory so it can be freed all at once. */\n-\n-typedef struct TemporaryMemoryBlock TemporaryMemoryBlock, **TemporaryMemoryHandle;\n-\n-struct TemporaryMemoryBlock {\n-\tTemporaryMemoryHandle nextBlock;\n-\tchar data[];\n-};\n-\n-static TemporaryMemoryHandle theTemporaryMemory = NULL;\n-static Boolean firstTime = true;\n-\n-void GC_MacFreeTemporaryMemory(void);\n-\n-Ptr GC_MacTemporaryNewPtr(size_t size, Boolean clearMemory)\n-{\n-\tstatic Boolean firstTime = true;\n-\tOSErr result;\n-\tTemporaryMemoryHandle tempMemBlock;\n-\tPtr tempPtr = nil;\n-\n-\ttempMemBlock = (TemporaryMemoryHandle)TempNewHandle(size + sizeof(TemporaryMemoryBlock), &result);\n-\tif (tempMemBlock && result == noErr) {\n-\t\tHLockHi((Handle)tempMemBlock);\n-\t\ttempPtr = (**tempMemBlock).data;\n-\t\tif (clearMemory) memset(tempPtr, 0, size);\n-\t\ttempPtr = StripAddress(tempPtr);\n-\n-\t\t// keep track of the allocated blocks.\n-\t\t(**tempMemBlock).nextBlock = theTemporaryMemory;\n-\t\ttheTemporaryMemory = tempMemBlock;\n-\t}\n-\t\n-#     if !defined(SHARED_LIBRARY_BUILD)\n-\t// install an exit routine to clean up the memory used at the end.\n-\tif (firstTime) {\n-\t\tatexit(&GC_MacFreeTemporaryMemory);\n-\t\tfirstTime = false;\n-\t}\n-#     endif\n-\t\n-\treturn tempPtr;\n-}\n-\n-extern word GC_fo_entries; \n-\n-static void perform_final_collection()\n-{\n-  unsigned i;\n-  word last_fo_entries = 0;\n-  \n-  /* adjust the stack bottom, because CFM calls us from another stack\n-     location. */\n-     GC_stackbottom = (ptr_t)&i;\n-\n-  /* try to collect and finalize everything in sight */\n-    for (i = 0; i < 2 || GC_fo_entries < last_fo_entries; i++) {\n-        last_fo_entries = GC_fo_entries;\n-        GC_gcollect();\n-    }\n-}\n-\n-\n-void GC_MacFreeTemporaryMemory()\n-{\n-# if defined(SHARED_LIBRARY_BUILD)\n-    /* if possible, collect all memory, and invoke all finalizers. */\n-      perform_final_collection();\n-# endif\n-\n-    if (theTemporaryMemory != NULL) {\n-\tlong totalMemoryUsed = 0;\n-\tTemporaryMemoryHandle tempMemBlock = theTemporaryMemory;\n-\twhile (tempMemBlock != NULL) {\n-\t\tTemporaryMemoryHandle nextBlock = (**tempMemBlock).nextBlock;\n-\t\ttotalMemoryUsed += GetHandleSize((Handle)tempMemBlock);\n-\t\tDisposeHandle((Handle)tempMemBlock);\n-\t\ttempMemBlock = nextBlock;\n-\t}\n-\ttheTemporaryMemory = NULL;\n-\n-#       if !defined(SILENT) && !defined(SHARED_LIBRARY_BUILD)\n-          fprintf(stdout, \"[total memory used:  %ld bytes.]\\n\",\n-                  totalMemoryUsed);\n-          fprintf(stdout, \"[total collections:  %ld.]\\n\", GC_gc_no);\n-#       endif\n-    }\n-}\n-\n-#if __option(far_data)\n-\n-  void* GC_MacGetDataEnd()\n-  {\n-\tCodeZeroHandle code0 = (CodeZeroHandle)GetResource('CODE', 0);\n-\tif (code0) {\n-\t\tlong aboveA5Size = (**code0).aboveA5;\n-\t\tReleaseResource((Handle)code0);\n-\t\treturn (LMGetCurrentA5() + aboveA5Size);\n-\t}\n-\tfprintf(stderr, \"Couldn't load the jump table.\");\n-\texit(-1);\n-\treturn 0;\n-  }\n-\n-#endif /* __option(far_data) */"}, {"sha": "99dff88b4cfbc1d2946cf9ec2ae82610e6139056", "filename": "boehm-gc/MacProjects.sit.hqx", "status": "removed", "additions": 0, "deletions": 886, "changes": 886, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMacProjects.sit.hqx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMacProjects.sit.hqx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMacProjects.sit.hqx?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,886 +0,0 @@\n-(This file must be converted with BinHex 4.0)\n-\n-:$deKBe\"bEfTPBh4c,R0TG!\"6594%8dP8)3#3\"&)e!!!\"4UiT8dP8)3!(!!\"50A*\n-\n--BA8#ZJ#3!aB\"#3d0#'GM,MBi5bkjBf038%-ZZ3#3%)Zi!*!8\"@`!N!6rN!4069\"\n-\n-568e$3`%!UbqAD+X`19S!!!Ba!!!,*J!!!F%!!!-PfTmj1`#3\"PET)d31)LTH6H4\n-\n-#*AqG5b5HI*)QjY$IIb00%ReTJSi6rG$jG(bZ,\"Rc,9Umf[IRj)6FZ-j`GfGR)#!\n-\n-m-#qLqB#cj'G%46qffB3q8AppLXKc+P&*il4FMJMq3N32r[U,(PlSNdrQm-J(4!p\n-\n-jK)NHmKJSHY!,&chS$4)pk%8mL3I)B0'$AU6S3'q)k%%[5[5J&ffa#68)0ZM&#T!\n-\n-!*fHC-2dFZ3i83[Vr[4Xh'+DNQrm'J)rrpqe%ST`,FeVi6b,*qHH\")4eQc28NFMN\n-\n-ZT*m,L\"Y%-`pdAk6RLHDaeVV0a,,@P(4UUK66rUM'8bf91llS(\"lTh81)MBQ+4*q\n-\n-rfHENEhD)Ke#3!09'M%bL[P1+G88fa$3e)5Gpf0kARpBf*6eIH*0`ZBHR%ii\"PbN\n-\n-+D&*)688M)Sm$Bm[cCdDjh2YIjmAc`(TVpi*Vka((A*&Yl@'LTSH1M*AMP#,2[A$\n-\n-(FHA@S\"dL4dER#3b!EfBYem(C9P5iGH\"a-bb-AL(F\"bb-AL,F6)%a9pJUL,(hf%B\n-\n-TeQb[\"X5ib4DQXV!-fa6&mZf&3,(C&UDd-((SpeMBEIB`8Zc,BcZR3A5'X+jYj$'\n-\n-6)6HVV+R[!`#3!`X!(E@*MFQ%R4d\"))`m[3JM[c)bBS54Tj'M(AP+MK&f%VD5SdG\n-\n-SANFB@3Rqc$Am83(+)`\"G(D%A'9!bBQ6!b)b4Sq3SH8D1NDGNX$)bBi54!51--$*\n-\n-Kj0L!M\"KKK\"dC--,)-h+-6#KKC-$)-F)NamL!!Z06#X!!b&%bBUHp8RcN'%%6!b,\n-\n-i!!kV\"`\"DLHFaK*!!\"Ym4K,,2i2X4c[,`c5!GIPf!ZcNi'8'VfJFpSfdpq+CY$8j\n-\n--V'f-DZr2[36#1(ael5hmfT@1cSU66D5pqDSA89pdTP-`Z[jj6T&!PmZBFZjal\"&\n-\n-5iG6#blE$+&kLh#QZ118&(0T1J(hZ,9)5MJ9ic*qPI!ac'RJ96QMZjSbkMq()Ui6\n-\n-B+f,,#'N1icbM4N\"aaBr1`3Z9U'8RY'XAiVXFKp#&k2D5Be%VCdh4%,+2QS'b\"Q2\n-\n-%0PNT4rE#%kTUFqYDM56bVjfe!p8MqmL)1VmjVkJY`U[*$&*L3AMSpB@LCQ*U&l%\n-\n-T+3890rL,V9klFN*4@f0UTf8Z&&afN!\"4GC6G8p3fN9$4+4[-@DAeK%lej\"@eAAL\n-\n-eU@&4[Tm28%mqqUkS(F+VDa#lB&'rlRAllRP&l460Qc,)MHR$jMh@$8Y4Xc'e`cd\n-\n-ZE2AUUiH+fK96feb$epq&'RAQeLG&lCDjmP+\"Kr8k9#qp'eI8RPf[6R$dS+$UcqI\n-\n-ELYSV[*ETFL&j[@lr803qd9I2A#bi4Vei3*d[+@Urk*!!&abe0HTVm%44\"i4A6JN\n-\n-c(2I!kjRl6a9e813DK\"A6p(LjRZZGaGH+1L5SiBT[(6ekd2*ILMSXU(l)#m3QMDB\n-\n-V+QTG!r*NG#RQai#DNh4,l0&!Ie`dYi98Y1%1A$5hKP4,`d9cHdKP'LkD@q4hYC*\n-\n-%dfdLeCCNN@i9UIBNLh5l5(8N68qhM&4R`d9cfdKP'bkD@dHU+qe&XRfNZSqc10j\n-\n-#8Me*&ZNfNZT0hSYd+dP&ri-FGM6G6P,p5D,rPNT0`dQLk5+6'NLb5\"HDe'$L)Pe\n-\n-X8N2bj-Z'$r$6-$NZjLGC)1lB-\"jQSff@[ak%LJ[rI#%p2ddAGREN(@\"V+,S6CI!\n-\n-I!!!0$3KRBbj38%-ZZ@0M8&\"$,VN!N\"#$BJ#3%4B!!!d'!*!%rj!%68e38Ne33d-\n-\n-\"!+X[PfqV-$P*!!!'-3!!&UB!!!(&!!!&C80(jji!N!BMM#0%$L)UANhN3L9rV@9\n-\n-B`f#c2p$XpAVVCc-[`k20Y5bJ+CTHPScj`Z'!lmr*#EPaRH(ZcR!J!!rqMKG\"q)#\n-\n-cj'G%46qffB3q8Aqp4R6FA83PM6`KUjaYD&IlZ@jDrY\"pk[b&AZrdH*kFbb9PM*S\n-\n-`4Kh$c8Lf0bVe+Y`Q$amM6mc%*C1(jF&1bFSdGIlLpc*04b#X&D8[&6R%+-#6HhJ\n-\n-kX\"#A+Bp6%6RGkB&kM%'jh$ZLmam[1Irq,r82rGM\"5H4bh1ZB+b\"Z%&-pD)5CL9(\n-\n-AP(4UUK6$!(lkH+UPFXFARF-MIHHMXf!5Nd%SZYRQj'pfL)G3N!$94X#(q25G8U`\n-\n-VXL'QU3Njk8[phV2@0Q92J#d6rA2N1[\"[!%c(M4X-8p,0IcYJf2lRBmD2c)*RQEF\n-\n-68m'9jqq*MjHTji&GqDp$kh501r9fqVPJe4iQDRS)L!)ELqiX08i#@40jpP1+F@p\n-\n-iC&))L)Qq4Bk-cK-i*h`cDlN1cMBUbZA3+beKhX*-&UD`X%ME%F91fHB3BaCC''Y\n-\n-KNba-C@(,\"-40Yl\"l,#c8`YCDf%#\"XGD%F4m3'*i'k\"iah[Ddam+k\"Xd3eV@02'B\n-\n-bj'D90I9p!!!-q)[jAU2HhQ[NiCQC&f(Ne`JR!hlN1''4Sjc`)hcL5IK+f(@8(q&\n-\n-(1&Nj2XreTBI[M!0dGB4'MK01#CFF2c,JK\"*1MNZ1(q&(11@5ii5EKimF*ja``Np\n-\n-#bA(#bBL6BpQ6jq5imT-m2mQ!dq2N'H&2RT2M%Nii'6$J,PF!#N#jGS3IS9Uba%G\n-\n-'A-)*8[#%!j-9'#r3@EpUPQ9+NL6$ldj*kVS6INIK@`*q'q$hGRJCPb,`pUJm(fQ\n-\n-3!#mGrdQqe$Nm22hkJ2cerNp\"i3$m4Z62S5YA40V([V`MbHF@)QPT2IN@3@$ceHm\n-\n-I&dT3GqF9K,'&&8[6LKMTbQ6@-*%bJE#4RM,b'FA*'VC5`0BBdTa\"@aNXM#)mU'\"\n-\n-N@d@XSIKMMiMh#RbbLSjLT49GG9\"F84)Q8QfN&![N1hK\"A'V5F,,dJIF@+`iNJEb\n-\n-H-(5Nar84j!\"*Q54MH+j&08dYQc,(ipT9I+aFqIQc-XP313&803UUPPD4*+UAIlj\n-\n-$U+jMAP1QUSfEYV2Qp4HKfZ#TYQTCT)hEaCbp+ZXH0\"m5USfHDV1HbL4cCT@41rr\n-\n-5+d+eL4&+'hR90)iLRp$LYcm)e5McQN@UMR#&$kKqr%eHU-DBejbUCC-k+P4N5r%\n-\n-Iha+Uc5aj)kVfm*'ej*8Dali5ULfHDLah-l$Zfer1#G9@6l8TTf*r,RKTZ2#Q8'h\n-\n-MA2&i%MYq(0aCicHKfPlfDYLeJ3*FFEG3l@\"HmfJbqFrdHU&IU+jRHE95BmQFkJF\n-\n-29)qp)93hX!aCGLfYP0!jSEU4HF9)-e8M9rADGfC4U(BbVVC66+8XR2Hj2RAmGk'\n-\n-kLDNk8`@p0[6F\"hrG,e3h`kmm(BhDMQjBm@`ejDH1pG)YbUXYM'Y'5aD`-H(VPZ)\n-\n-,*i6A,Nqe)D1Y'5@UV@HM3VAE)a3$3MT+9jAGa)HI#%*E@9ie+jmf-PA9dY#66`Z\n-\n-[fkMA!l&$eZ3)bP996crcal6`ZRdT$9NG0S#+V([`rRZ&eae,A%dMGB2V4H%9YPL\n-\n-LfZ3B194,NC[ik!QKZSYlaE\"deVc1$3[9(XVeFJIG0T,9**@'AVXJZ2Db$%'!,$a\n-\n-e+d2+8SES`Z&RD1(C`m,VlM*Aj)cP#M@ZlJI#Djp(U28`fl)VL9dKY+IXeFM!HRJ\n-\n-MVc0#YCpj6@!,M0VrHYh,CMQN!FBjl1ZVEPhjaCK)``\"6,6JiU@@ekMjdmEEPI@M\n-\n-3DpXKj3pi+f`LFFpIUPrF058)N4X)f4ZQ*P5c1[&!pGhC4i@Ue2BCE\"bRL&haLRk\n-\n-Thb#ZUK&ZK-Kc9k4Z-[QKhdaf&1KhN!#*#IdZ-XfJhdPQ)I6l#![SYjD'HXp$hdA\n-\n-f$1LhNlN-r4DbV8$I8iS[RSEqj#URqY@$9b3dJG1XG))%khUHJMX,Vh896Z%\"I%B\n-\n-PFK1MejpP2[@,$LpbTe[Q%h#[hhai0BBHF+r-MrTeL9G6k!!IKHa1rmf2qMf,9c6\n-\n-d)%I[5Hq$1hVVq60(`H@-9fb&cfkb$BBDc1-Ck@@#jrVH%0cXH$@cIK[C#F&2Q9X\n-\n-[qpl(HTpEQ9F`KqVA3&iYS3Pl6#ARpIXMVpCP6[+ma`PkbJPkbJPkbJPkbJPkbJP\n-\n-kbJPkbJPkbJPk1MHKTlbJTlbJpqGlF2RNe4CD`1XDTfUZEYjDHE@[F0T$,KbK\"Vc\n-\n-mA!9AAPiGS3Qjm[HQi+l-LraVj'p1i3&mcNKce1@eZ4pFX(PY@1(66rD18)Im\"eF\n-\n-YAJ1K#AYcK92peXpVBfM#AZAIKi*r&r$U$\"h)dkhp2[JI!kp0S3GjhdZZV))A!43\n-\n-jH4kk(TLQKF4pTXhHI!ITRb%hcX3KfeN#**1EI54a\"'@Z8(9Dm%D@b\"Y#qhm!N!-\n-\n-0!!PRBfaTBLda,VPM8&\"$,VN!N\"#ah3#3%!9X!!!I``#3\"2q3\"&\"56dT,38K-!3#\n-\n-TY1))Uc!eD!!!@F-!N!B563#3\"2$I!*!)22J1`2KbNQaPEr+hGEX``Jk!Vpa0&eT\n-\n-RDl*eSGZ&%EEAc@iGG+hAYBDRapHZd6ETQH'lV2AbpMVJ4lN,ck0G4lMb)fcKAQi\n-\n-*AeLhm1)VRfPGM,\"Zi8pBG1%a3VYZi@m,@rM#2'iAfhjHacE,K\"[bJGYB,ZcNP&#\n-\n-\"$cqJ[fRG`SmXR'aMC-H6r-)AXTaNHE+Fj\"HkN!\"0\"R[G!H4jITB&`!(!dKX\"PZ#\n-\n-Z+PX+S(dCS&YGZI3,cN3L+P4H)V5R@D3p,54$JD\"3'!j')mhRcl%mUJ)9e2PVUaF\n-\n-j[6lNX)ll!4,jajb6UrZK!hSTX[caD`$ZIHl,pdeVm&EaLeKG-YjQB6AKT)84pF,\n-\n-kB$+55%ID`b-4QF0T19ckfSl,d['15$X-4cTr0\"2!dIR5%1j[S4JQa0,J4lT!pkc\n-\n-\"EjcQ2ZmmNDF36,1DH)X!8($N3ihbR+mcX1GC!E!0fi)+ra)rCUL`#HU&V9)ke`6\n-\n-IhTB!b&RK%B!&4fA8Ecr8+8IBcr)4Z8L+$bmVaA0$-Lr)$3+SMf0Xkh!%1L(hiM$\n-\n-H56i!P'Q(V3ZXrmCRE,f[6f'0N!\"Z$E6%fl(AqCL20Ka-#kRdjh`qA&CRACe[!5i\n-\n-+PSiKjh)6PJM4H$#5%&U%HF#GqF0F$MM6fH)T68dFSQ!hQ*[\"e3hGME'TS#e`Fmq\n-\n-Sl`'0qRTZMfEcM@b8M`(hV,a,kqB4N8iZ[4Sh5b!9ddQpT9YP#5UK!NX`BDbr,\"E\n-\n-!TME)X#08Bm,*$)fP2Ci@G1bTGUbETe@@q%4QL60h[2d5)BQGX-U5,*6)q)99'NX\n-\n-bP3a1pJZTH#BC&\"!P%4'5XP`!Fm82LidDE@#h&eejC#m'cSQd\"k1C&S(CD`*\"Va\"\n-\n-S%C+TmmkE6aJ*6S3kTd8)4GS&PNjQ\"#DY1419T&!JQT+cV-0*5@'9$$5+K-58Y\"%\n-\n-N8Ea'&)q3!*!!UeBZ'qd'!&14D\",LQVJ'$qTI1DUU3$%0cAD!e9HMkl`KaGAASBj\n-\n-TJ#pMhSb5Rq0c+LJ3l3LJkD2dcrJM2Q%3Kh&mZL-JR(&m+L$L-)j29b,%B4br8)j\n-\n-X!Y$j4ZUh`)[eI!A!R(d!4AHG`LH[d[f@re6*b2mAI`)H5F0aI+2XYq2iC)+N`6M\n-\n-qC$b5\"Z2ij,N%KHI*24K!$k@Plm*Hm'Rd8-bci0h@*rK6m%JDM[-[aZ1Nhq+IKNH\n-\n-UJA&mE-V&'KM(2a129!2Mq2,5(2qIrSHmNfTSR2rTH+3D'XHRfL81irM8FE,Ep4r\n-\n-eTUeM[5Ra8bilkJJ6f!)lF0e(0'p*Cke+2Nq9ccEjh#UIZq6c&[RmM(3ZV*!!cL0\n-\n-k&5l\"Jp4$Ilc)-m$9BDMqeV0m$l6LhM(EAX9A,10lG,aR)2GNb6Sm29&b0@CfmMd\n-\n-&Mr!pHLh'hX&p\"qiPVV#h)jIcaN(YAHVY!-im,lH&lp&Fc$pX!KD$+,qKqbMQh\",\n-\n-@BjDAX[M-KFF0&bH!le%r'GC@E`LVXP9mKXdeG)3QcED[U18Vq4jY2c-fD8XFl$a\n-\n-Jb0pEdXPRCYXVR!e1c(f%qF`GKAUQcPT3T6E-YjCF2GYHhq#[aqa0'*p@XJl4r*8\n-\n-qM(Fa(e1(MAb2DUZDVTq-SD2mJ+kFAj*ldAQmX-KFQf\"C5i,E1fA&P2jHj`!8*c4\n-\n-Cbq,eU+LUqmriLrQ-H$8\"RJ(GXC,YKXYCKk(M!EcN!3MV-HG3b@DB@MEAd\"P5,9[\n-\n-2CjDYplkH1ckr$1D5aNf'jH[,p0ehXaPCKe@(eI0#11SC',UQT)X9K3qD(G8hK#c\n-\n-C@GQUfADhU*AQPE#2X\"A&i-9KaAUdDe$\"bpQU)@mfJNfL,U61YQ4RBFiKFac+[hC\n-\n-Y@49Fi(Ye4UjKII9Fl[b`UM[(Ca+6ZhF[@mq`0Seer)R3*#Y$$IcK`pPc%EI6FKZ\n-\n-I`IV\"'%bLZK'Mdl!5jqQ+3J!feU'k*f(FZf(EGY@@N!!CGAmMqd9@CrDD68d'jf(\n-\n-3TlQV6AYhAEJlGh4$epjV3bSqBiDXKA!BPjeTVUYp1pI,DPfESAK1\"2eSD[B-elh\n-\n-H#\"KCEIFl0K-Um0E-CFr[,$HC6Hhc`fDr-eb-HmN5*`iSE-8)!#TL+mfKpUV\"jrc\n-\n-$X6fMXIlRYZ5'5$I94YXX-&C(`\"\"L$Dkf)VmVe*%)GZr'mh(#3i3EqlYKNKblRf*\n-\n-'9fi`h\"aV43`ejERI0DPfA\"MDB``XX)HHa#bYS3h1c!hCcPlQ0+mDh0Yr`mEU8Hk\n-\n-YrAmUXCIMj8SFBkA%6iNVCjRI%C(IMj&E3@l3G[C&a#hGId-rBQbXrT)c0e6q'2p\n-\n-eC)89`[fJmPd62,qrh\"5fBCA-$%rb1d1R5hbj`ddQ1G,60%Q1l'T#EqB1)110@)h\n-\n-%i!95M+ekEiM0HfqSHM1k9UQY&%V$jTQPB&VZFVm*4FmG\"[Acbff$#qbZ,a3IKUr\n-\n-B\"VZ2A1J-[B%elK$paa&k8Z63JaakNVNdL$c1fP%+A`QGIJ'bm6iH0ZklkX(0S\"E\n-\n-8jP*3Mb,[3pbE@&fLD'2RS@ZY1`pG\"kj1X1j#2R9*X*QX*TAMbYcVef*YX2)T6FA\n-\n-Q@D$Hf'AE5@VBGSP+2*elSqN#9T4Gc\"`I)\"SMr!P3K8hPL)Se--@E+!*#j8qBAdA\n-\n-F)f`H'*JMT!TSH@V*`'V2IZI1K@DpeEljYRXA2YJ9eU,IcfjLaVQJjXS%LTUELM'\n-\n-UNU1Q*M@HTVX(FV[-AA`QqadqFr3i9[JU81PlSB$r%d$A3iqhZfXV+KG!GjBeeU(\n-\n-[-cfI+9deX0(XqqDqeeCrEqGcqm6iUPf$i$#AQd`B@p0rSjJ6NR2d'hX'fX5-\"MQ\n-\n-MU,pRS%(-F-NCDZeUk[$*BA*h$2XG9RaZHj-D6bq3!1YJC6AD61@QEFZ@lXi09,[\n-\n-#3r`40LMRE\"V0'C!!FecYKJh1Q(D[`hN%90BLbX@@Y!c8C8j3QmY!ApD)[GhVGTJ\n-\n-**CcApF6MTA!ZjkemqUrh9AKG,PI[cVeVI+q#h6`$QIm$kKcXmZ\"@c&ph+[pbaRf\n-\n-+-2[6I1-)JqV1YQR9UpZ-&Cd9Uc'6i5P6JCdV6\"8c-TKV%$1eQ*@af2(L22GJCe\"\n-\n-VaTDFcfaEffcXh1Pef-$Pm$Vic)0VQmqbL$(+mRVQJpGcr8kVcZZakIJ-9F5\"VJ2\n-\n-A)XVacTfpDfd&ZhSY\"9l2XleH6rpD3Epa6E1D10FlQJjH!G34SPGS&qM3*fC3Pe2\n-\n-L`2L%lVY,CV!*T39qcpXH[fHHVQRU'%UAhk2&Qk`VKaD[,i2ZHk`cX2[6K&iQRrQ\n-\n-lbPXmS@QX)1Y!&RH`da\"Y\"8BfPYDc4GPC#3lV4AhlG+E(2&HTGaMM!VD)&65CaPL\n-\n-Dr4lQB&J09`k9kE(,mhf[0f[T[[2#[mfpH2-6*6k4bk,U5Z`kcd%Ia$UcfEZ2Z!G\n-\n-1&'%PEF2B1aKl$'0hBH`R',X1BjX`pP1-h6AD-aHa8TJD0Z\"T@[KdIJ$5L*0!R+1\n-\n-)NmCi#mDEj(J5i`fS4KaV[49[Y[ASjjGJCfSIkdaR)f+)e-#cLpMMH4iTJQFE+B$\n-\n-RFiN4RXfXNFpBZGXAc[3QM,G2Yh*CMh@3!(q8lFE6#ID-P'YZ\"AefKT9M99N2Re%\n-\n-Z5UJ[cKd0UjR$Y@%N5eQr[bVdDANH1X3[2[#XjcJ0%Se1!jKa'U#f[M%BE`p&`TC\n-\n-@-mfEF*1J\"\"c`J'Sc4b0!`0Q1cH9X!e(3aCl!)H`k4qIhpfYS1)*',+EMMLJR'JM\n-\n-*XAVRp4,L3*6EFHJLENI+bThcfZ@BBX$BV8U1Sr-@+@iljX&F'M+D6*J-'5#(%1k\n-\n-[1&EhlT'(\"@L3!%(&RA-a6V0,2#9X9%3D8*&8fT'k`V(k5V),NCZX$kh*MY@GDYV\n-\n-4Y-8%c[bAlh!l-U6&69c*e@N4Mj-C)C2d+XbiMLZjUSJ3--Aq8HQ-$[R0RcMaPa8\n-\n-e&lLqlpUj[TGS[iMVqri'VZr9AUl[KhZi[J-YA0r\"GUl[d&eFhq'YA0rr0h*pEml\n-\n-RqYlHa2Ap\"212)[Ba!pGh2-6e$Gc+p3dqbr80[FMe`hbZAjA&I4IA2aN0'##DQ-I\n-\n-F0B%8$M1bX*!!6V&dUi!$KD&N2-DNDAZFBic&F2BrKF2r6-!j%\"D+4)8c'q,aD,f\n-\n-3!-3j51B9SJP@RdlLA(j+(8X++A@L25E3BD9ki@,HV9l@i1F0$6KDbP$RC(bL'2*\n-\n-%ikP8)(QCZL15MXe30%\"dDAVbI)DMURqBCV&i5b4dfDrbrk!LN!!@@#SGL#9B+*j\n-\n-N3JH#Y3HLV#@5r\"fhhq@IS5Jp9LM&BLQF6+PSMTk2cbS%9c)KQ@5a90K#Sf4N5PN\n-\n-S5M[3da4hiQK)k+XiA(ND$YpSYSe-m)LIZ,6N5rL%!p$M\"e)Z2G@JJJ8FXU,((EM\n-\n-pQ)@$C4*&(*ZN6`SqKSGP)q02Q+F@[iqA@RaFJFBHbCM4qfMF%h!%89`D('LN6e`\n-\n-k'KDkIh4i5)XM8r4*4)JcM9hKZ+)%Kcj2Rl4%aj+pAcSALTmN,qQmF&6[3Z`$k*0\n-\n-%H%M18RJEF-b22R&0qM&+6,@P[&-a!BIik*1U!BGKe64B611lY)`iBNHI9\"S+Ab9\n-\n-l)JjKd5HT3V25,H+!P%`9Z`rkT%9kNCS1THY!pHQ6Q&%@$8)T99L%Sfhd5H*hI$J\n-\n-64C28Y,C`Djl#m$6b!XGfTmrR*X8$d@L`Y6QkdK+%4i(E8[b59GP&,\"cqQPC3ih4\n-\n-MlA''N6k&X1iVfl4IfC%6%hNG3kaD8[4Nmd+LGcpXR+[Xb-XNFZZYEkLS`Q4G+Yd\n-\n-5L413!'S-T`$1NR'U9P55`+R)+U%aM8!K9-\"b-+[Xk$GR5FTkh)hN*rJB5@-L'EP\n-\n-%j(6IK+GdbSlH-e9\"XT!!TkM$335*3-%BFqd`miD+#P4)M`VKJ,5STAS-5DFJ,A9\n-\n-lRF6mdQ\"V)#Q+K-c,[YUNl&M9XNEZ@PkXmY(k8'eCj+P3G[5T%69*)e+cY5@CqV\"\n-\n-#$%SP0969B)9`fR3N*L#-jAfF#50kqURL8%pU-)M3+FmipZBILqkTH!E9YJip)aj\n-\n-%`mKhi\"GMeDhkeqSZq1IU*VIi[,SeRcM3\"dM$M['C$j!!BhcZ!m11mCN2&2k,$aK\n-\n-qi32[Hr5%Rh[d,hX-I&T(k6&F2UIBBc4(!m'9d93k(d+2NBr*-djj`D*SpBJAZ,f\n-\n-9j!86F'3iZ$+9LDAqShqJf[jh,cLPbr2V[SPKZ8BUA*j'UT'@jR\"M,2UIAFerUC*\n-\n-hbU&Hqqk24KaUB492qKV`$C4!&+Z\"V#$rQ\"GJ24rmKPrCa6X4KAZ0c$d@5+lmTal\n-\n-hVejS(qNI[*91V#iSP&p#b,2@2paR1A6E52mJe6FBBMJ1dGJL*2+9p3qIhj!![Bp\n-\n-M('C8fB\"h)XK)5,I&%TpfThIZ`BHa&(9Vm2+9kL#QA,kQIZdYiIaLYrARRVV2f2q\n-\n-YNG[k'UGr%8DeBN-EK0EmEAlarTd(p5,rIHIa&j&hIpETLXk#R@jbC@-b,9jkj$[\n-\n-SG20dc3jaep#MG,*Rm*9,kClGd#jFfLM2Qq@TmibVrRcNcU2@95h1CX5Efl\"&%5r\n-\n-8mURGV@U5ZdHGS,k4EYRemG4[EPCrFjZ4PqYQYFV$Li`LB4cI%5Ak4CIabTc4cV5\n-\n-Z`5pfTSPdXM(B'Xb,d*RQlCVl-6rbfNK(iUpddhemB9))4J14@\"k%hM42efh'efl\n-\n-%*i192U1qBE',qSa81Y2F(%qfjbIV-mbRlM2Dk!QiiGN-X@CeBXhQjHJG2R%#l)P\n-\n-%*m$r!\"'46R)DGS+2k[XNTp(qiGGq@r81$FI)IYZ`[)lZM!cTba)YbQKh2VHq(T'\n-\n-iYATPahXMf583L9i#-b!5'SA3JP$LMk5FV\"eL5P&e,)!2AM(fqq[&rAqqJEX3ZJ0\n-\n-4GUAcq1#I[$MlrpXrj3jb$ZiY+2BkkdRM@qKR3r\"mcb,mia%m2lM89dZ[Vqh!-,f\n-\n-QqNbpVjjZ29qJCq04M`2d!b+N'UT5MqGLqX832%q[Aej$mA2Gr%)2D,J,T!VQVUK\n-\n-`%6jhAB9V+HAI4,rjJHFl+Pb,m4eQEZZ5@KrPp5aF@N9GqC2+ql1S&YkPdTmG6Gr\n-\n-!qEV`09U+&4c&223NLQNk-DpALZNdR1mDqVXNM'QAB`crlBKL%mp(M*G\"*FCZ`&J\n-\n-DZ&cZG*Ki-f,J@mmLMhX`*R29E-FB[Qe,XDNr4DlPFZc[1GrDKlkqQYkKeBBaYUl\n-\n-YEqK(@E3aM+N[HKM14ThU%2X*Hb(-`McNHXhpB\"3j2BDaPJB6I!Ne%&qEaD`r`V`\n-\n-YU-G\"k\"3ar)MaKKaEKl'$NQC6hd1-Lq4B$Q0G-XB+e-BRajCJ,+'*V3bd4NrqAp,\n-\n-B[bJT[kddmXG*R(e#AIa5)9RRT[cr!`!!$3!*Cf0XD@)Y-LkjBe\"33bkj!*!3qL)\n-\n-!N\"!0\"J!!,h3!N!6rN!438Np+5d&)6!%!UE6L#+X`0A!!!#*k!*!'$d%!N!43[J#\n-\n-3#1j\"$F$iCXbcEQ9ffFS2dS@*jbZl63NYVcACZY$0##1XPDZ$V[@ke[$dmVQ6K5h\n-\n-FYGEmE+(Rmc@246PGf0D9hF)@VNAi`VhS`KGM(GQA+lmmdfiI)f`c`Tq`63P23V[\n-\n-Y`VEH`KHqX)9f(@(E*!Zrf-)@IZi)AhKXi3[E,M3j*432\"&!HrHaD@&$M#f(,qq3\n-\n-@XL1hN!$\"3Rk6AcKCb%+1%di@J&@\"\"TeG+a&(42abSQ*m9@@VL(4[%29TUPEGj%S\n-\n-NfN09'd1a&\"q0T8,*F(-`0#85E)pZZ-eZrEB+Z[80G6A,A6ir2'5jYd$i*mlPdrI\n-\n--@8-1XA6I6r6dUG[h&cAjUSAPI(dbhQEPDb0*+mqX6fN-*U1*9$3@'8GN$c0%(%0\n-\n-GelfTH&Fd4Q0)jLrR%MNc2aM&pcf8d``Y,Ak!B(cHb*GQH1E2Phb'JLQq0Yi5)P*\n-\n-IZ&DMccNrDX`mDiN1BLbSE&MC!)B+3p!!(FM4Z3\"pmf##5,64Fd39&fA9Eck6N4(\n-\n-q-Kr+TK`qGQ`-&dGPAb51%'Q'J\"dB3bK$iZYMHPIm%$'QJ`j8f2l6cq5j@TmTYD&\n-\n-8Dh0,2)CCjkGqG*&J+Y5CqU@IDmIQUUrh9q!`X*4GG$59b(1#DBYLrXT3Hc`B6B4\n-\n-D3NZ)Zr'(SNLFq4ETPX+0#01J@-c9Mci&E\"ETe\"lZK'B2D682F5pVpcl#6cM0`cF\n-\n-VIh2RdI%LA6N'$6l@jXi1I@kfp+LX3395@i-*Bq1p(FdBDS-m*N)0#&FB@QXXRJV\n-\n-TqHr&d$F[UDca!YiDjchaf-C3%T1`bTUFNM26%1V@@T1GbH#dKP\"R2*d-KU#5L)D\n-\n-5FVQ)&NXr0\"XEY)Prh,6j`NN!Fk+aB(Zk*F3lDTZ$[P\"c5bMC1Arq8UD4i#5T15f\n-\n-KF$3@iP2*G)M2RB8&#LRFh0iTXfaMT'5S@aDD8))aK6DZ*\"9[2BV(P+51c4hG,L+\n-\n-c53S*k44Xa8Acmd49U9R$Xk-p6,4P'e,Rh4bZH3\"e6\"(G$Pjab5Ikh&MNk*3JKBH\n-\n-am`[rd,p4KJ)IdrpGAkQ!SYrdArSB+K6p(4q-kaYR%DeiK@MHTTrT+airpFpf(!c\n-\n-C6D6hMrH[fSGq[SpSi@NLdj2ApC8!q05rrM0pH5A%p,FGr*AqP!RpYPrTjl,kIr)\n-\n-Mrc0p)kiXJcl9Cb(1%'6hP`BRQ0MP'EU4U`lF@CCrSLp0(%#3!\"HAp98B52*lSGq\n-\n-&ZrfkrM3CD5@kEp'%2R+m!*ldPFM#f(9p0R-`C#rdT5&)cLr`#Kk#rMULrlIXZ[j\n-\n-d'6P$Y0N+!(Y!54rDdc&h'$\"brDYqB3l4$[hhr$0$4PE$2eXNb2ieb2fErJLM)1T\n-\n-RZCa*(rQIH68r2Xk[*I+#iKreEj!!r52r-kc1XRmYjSpI3ai@B(RaKIqI,BSqG$#\n-\n-E'MkH69X[ckB'iJEe$Qi`RhhAFB-&cq&lKKZFKRc\"-D9m50)#'Z6Fp%2+jFLffS0\n-\n-N5Tj%4@C5\"GI&cC(ZFcD,h$e838lFZmM*m-eX'F$dP%A,,mqff[SF8$&N-KPiM91\n-\n-9NF2XSa0J@f1fH(J8\"hGPCVYkTSRLJ,V55r6R486P'%J,\"U5PdFrVi(p*UM20Z#1\n-\n-AjGIGE[0r\"EdLeqdcjp[mNSplX,Y)hCYJ5aj0I@@G*jb-Gm65lHf-'iiR1d+aG!I\n-\n-M4Q-YACfKpTEfZ,40CpQLY-XkZ5B+lNFp6BS(cVppFXHLm)JE3biI%jRZ4TD29iR\n-\n-SY!R1P$QEBbjeBD*lqi'1GccMbIje'bEC1H@a56dI1a@*I@9pEqBF-qYcdaaAM`b\n-\n-5FjP9B(QLVT*e4Aa$'kXN*T*FX[j[jrbLXcJ8Me@X&Eh%AL-JTT!!Gd4B3#S&rjI\n-\n-6(0UBDSje*M'BT4+G-9BhC9*@-5jcH$[1@!XpJKl'$ZGDCHXmRb03ICB4reapCC!\n-\n-!(Mqj(\"6&rGSNfp+B@FQGKfZV'cfXb6ZLR8&V%2h\"l5[mJ8hjJPR%eT0&kPUA\"r-\n-\n-MPcHq*D-)FI[,GTp4[[$$5jiqJ&BGP+G#UkjaI6!H#dFM9NbNa28pDebXI1(,,(N\n-\n-ED'bUV!CChjPULFDCN!\"U8NG00mXke@ZV@1Ge4VY$ke-3#PpeT\"PAmJT`\"+9)V,N\n-\n-pTl6IHLkVI,'RZ6PAIkpR2HXM[+GCRdK'0dVZpqGr6kpmXC'CT5KCd3'NL33K%LA\n-\n-eT(2pQ21Q5[3dR+GDX116UUkC9$)S5UXm2KGcINq`Y6NTP421bhiMS(ba5j&Vj+N\n-\n-6f#aTQ1JNeElPhNVPLj`GVbDV%DYQDdZbmeS[j5Xpee4GLelLG+PS4`JbeUXka[&\n-\n-k0V$H4$f6H2FMHFHjNP0bI\"Sd(Fh4'2DERk5`R-%10TmaEFjrI`$I68b$mrG)kq6\n-\n-aHBBP*&LlQC0%8Xl9HQQfr9b!L@&XcMHPT*eJ*QI3,1Ibj`$iNqZ&q@YbPJ1Ha&!\n-\n-Tc3P+,rc(E-IjIaGE%9QEH@4l\"'92bccba&FiN!#)&l6[jHikPAbI*GrYmVe9[[I\n-\n-)phhbr86Z2U8bGeIk!)'b%TGV)mAiNDCMGeGHc9GI%IUT&GqZ\"BjUSA+ed+mA[-2\n-\n-LXC)(FAZaC\"ZB'D&IrCc3Ep!\"HarI&r!YF8GmAD,SLj2'YmVA4CaPLEK2k0IH*6a\n-\n-V*Vk$fS9GI4I\"H5aL!-[(@%*ka9$HA3N5qMA()VUDA4&9YPT)mi[cZX*6&cM@eJP\n-\n-93VpZN!!h\"R3P6RiqmI$[+mN)k3@15PH6#pcRH,qPD`T@&9NVUY3'[UeNf`)(%Um\n-\n-4l0h!LdSHK&T$P4pi$qrR04'Md+mkS'(0E3aI&)EejF*+mAAAd\"56T5l\"Ckd*lZ6\n-\n-dYG-(\"ec$9*M3CUehlN4&9Aer+0`PT+AR#H3GeRp3FMK[%pq9er8Y223JLKM!HEY\n-\n-N,mdU@jbA#DY@la65UhIkhK'(PTE4BPEM30kDR@@'[UIiiUc6TNIh[\"CTp`k2hPr\n-\n-5`jXLjbc1QSI$eZbmE28#KdHUPIB[)RkQV95-AKqV@,pZ+bUiLHmHp@@M''(eB8f\n-\n-f*6X2R,FYF5Vrc4ePeE6)rfDaf,5cCM&h@d69*`VTa,5qikYhmZK0Ble`+6c9aU-\n-\n-'$C(cf9ZKQl&q68LMIi$490Bh%PU%6PbL0f'aB1Hl9(X5aT1l$Kj@l3YE82GhXer\n-\n-JkbdqLcQ3!1Fk6iB8YmemmZL+iq,&A6dRGi493YT#@5[6iERXA%YphBr&!El1[CF\n-\n-+&dD44l1b0lLIpNA*b0Ie[@mhS`,[c9hpkT&bXm8F@aUa0,JLKIL@V(3KLJm!)8*\n-\n-&l+8LDUmD1G8`KVdmJ3fHfLH1XVUTHZhcb&J6TE``hq4Z-c@i`ef*B0pah)HB(K3\n-\n-H'HbMU6,f$BBChH*)C%0(+c3dM1IjL9Re`SV`bmEQ#NIi'&Lk[$Dk84behl,DCHN\n-\n-H16RiF'r0K2I@`Gr,ZCIaFJ8(9XVm+EKbPreGN!$mr6@mUF84qbhVQ,I8i-1$d1L\n-\n-YqD*,(#erAVJEVY!Kh&Y92c(6UfI+c4%lZQ4ZC'U$+c`cjjFl(c$,5(pJUS`F$5#\n-\n-EZE0`h)YZC!jHBaAMZcmFjCGm1&U$M9+Ne&j+T4(,h&)bVh&lrSC-Tmk6jY8epT%\n-\n-+KrZQ`[0dKhfNlm)+9rKGp,K6bKpRq*MNS4mHqT0LLL3I0lp35RH%Cbk#'pph)mE\n-\n-6[h0S,fP#'NXTD5D86d2hbhap`Y5EHAZ(lFME$j!!1d1fSr\"6Rb5lf@C@BB2jcJl\n-\n-d\"Pmq29\"SQ8HDhKll%9B0qe'T%Lq*l`B@mDEXREcc)d9M9,K%USLj(+VSJHQqK)Q\n-\n-BUR$*mLCd,r\",+)phKPA01S'YCFRQb(lRkmXX\"TYMlpHHARDS*k*$hLm)m'`$`C@\n-\n-&''S*&!*9bDJjS-&YYQGB2'VT%G,Cl`MTLd2Sm'j5'3C),I`f)I@3!2%1,)HU+UJ\n-\n-[bkq[4qlc\"L&GfMhFDr(rrZQrf[,p)kG15hMhd4&b@XV0CQ\"E\"aq41''CBqMY(fk\n-\n-6'%db`c6B2p`N-G`b3k2E`LC4PM$L%f0jKiiA$`FdZ,h'8JHGYGjZ,MFIA,hUZ$K\n-\n-Fiik-#KIi%CQcHi)c,(2FXEaGVJlG5DIV!UPX*XE&5&T'QM)AD5aPC#KEMpRZ(3F\n-\n-@d#@FcrhLGd[T9XjApG)IRkldZGhZJ5-RYrVI*)HP'-lr3A8KTMck#[J2AZG[`VV\n-\n-Jha3@r)a[((G3NfNVUYR5CUc-9'i\"NmFYABR*P@C*M$5iH4*6\"eEDLVfl+\"l+\"(8\n-\n-@M14#qZ$f$FE-%Cr66QkRcbQN$fhIF,09`KM,jee+2Zp$4fakRpHZ&p+X)mlfR0d\n-\n-\"PD(-NB(YG[A4!D[DjheP`1FGh\"ibp'lGS''H'jf\"FrF4Q`L4&ES+2A+LQ%dj*8l\n-\n-JqAe2P46cqDAU\"Zq2[3hH*IV!V%Q9RJD[$Y[IcD0hlLbM[MffBNarf[!E,'IqV1S\n-\n-aElL)9fHGF2%%2`0UDi(dPMEbbl2c%Kck4I2iE0i!RV[80kDaL&r1U`2Q5CH@\"Lr\n-\n-[j0%0QdI,$*Mbr0mIb&Vl[VlL6mAA(hfaa#pj@9j6KDPc$R)3I@Chp&h`$&mbSC-\n-\n-1!RXIf22!RJ6fYm!H!,BEf0m\"Hh*LCMEaT63VNSGE8@5Q-%`Tk#5JFa%k+H!Y`!-\n-\n-bRJ6HK'V%dHZYf,SBN!$R'c'C1LBRd`93$,0Ui1jQlR&I`LU#Zje9!2GEQ52F,Ia\n-\n-k)@hM(PmfejF`2MlEaQ@pYK(Kfraah#la*h*F5bXCXX8fMUr1HS@dXLKKFl&i-D,\n-\n-KRHjGikbVar'Y9la$l2RB6pmR,LdS'+0CVLaC,H`\"dT@r%Z!F2cScr3P3LVMhU0$\n-\n-RDQ6lXmIBIJ6h2FZaT-(pd#Tr(GX$[`!BEfIS4+1rNEepHBe0*1LCXfaR!QFkYKh\n-\n-\"[C!!E89`RpfiTTEKYhU%C9l5FSYb1eVZ[NShdqFHU(5[B[`[Xmd%lNp8ZZr%``V\n-\n-Z`-Sk2q2e,eY9c6DeamCH2MPq\"\"hf),AJ0Z`'mAk4BHU,`2\"fN@(D$$6B3eKJHLe\n-\n-ijh+BEJhfCmrNX\"X@BR0iMP35pJI3b\"!RLM2TKUm#`jj4mR%B@%X1Qrhh`&k8X3q\n-\n-\"I82'4(M5h,f&[F[64H#l[1e2f\"XKA3FdhPMh,0f#,XX(PR*-SARJ23cXC6*+rTj\n-\n-($GBeQHQ,U+Ad,JkXA`G[(hJpP*%d'S#PC1a\"B'rNDPDX\"RC'a[6!hT)eeX&I3XE\n-\n-f-%rDMYpUEQfrmLafmJQYmYTfr+%XjmL[Mpm65YCl'2rr!!d!#'GMG'9cG#kjZ@0\n-\n-38%-ZZ3#3%%0D!*!3(m-!!%+&!*!%rj!%8&*25NY\"5%`\"!+QdiJLV-$9B!!\"5l3#\n-\n-3\"K+K!*!%$I3!N!Me\"!i!pCQCc1abX2*Ef-,&mj8EA@KjV4fRQfkf--,fZP@[Eld\n-\n-Z$dq2VmN'A5Bp-hbAY9lHAJFXfQdl+AG,Z2)ME*&GEJRrA-libQIDl@-,fic`*fc\n-\n-6K5HKhAEKE`YIq-)mEQiRK(pXXmb@iapGq-+kKCfFELT3q1c,IZ&ZXPf1@pl#b%)\n-\n-ffjdZC,)F@FK#&m,)B+r,!D4[CPq-FBbaqZ@-eH&@A,@%-I9,M(@V+THFE3i'I@,\n-\n-PFV%p`R[E)f,)lA5*'SmV)SBMaKm`\"H(DkkSAQQdeb1%*lP8%I\"Kcj(3rX&H6m0M\n-\n-IZTkaqjrj`UCT$PZ9X*!!V`m&fSamV5GNj#ReR!CAb\"Z-H0XpDBqF`ePa(%eGaiT\n-\n-)S-2EcP+HcTr1B+bXmm9Kh'q$6Mf`X[$\"KF4R$RhYV2*CXk3m49H%V`fdL)`T\"cl\n-\n-J+-2j13Fpcq@-E8&E8'&IE%H%!Ne3,pZF#1HDf2Hf\"\"Q,&l1('*Yr8%EphJ1GXSF\n-\n-r%JrNr)3rGBV*(aq@mf,a)FC8Kq$ER2+`6KCr)B9h0\"r'+0,%0Xm[rQdqSqFB2cQ\n-\n-eBU69f4*S4krcbhc8LClZG$iIR'*cIAh0I\"abUXM3iXkAEq$(ilQ,49r!j3f+,H)\n-\n-maNhp56c112ejNK@\"P6JkPXIB&fjK8aKcR!drZX6iG+jqq&li[TdQiqM4U(!CR@&\n-\n-rGU+(,&FBA8QAdZJ+kKT@q*eSAPdm1Mm9!Sj'C\"RE!a%aQhqm(IAaK-)B'-FE!ha\n-\n-jS(fj'%,(Uc#'FK,*f-@9@FC3113DEaI$J@M)*3)Pk\"9$i'!+Qm`pccf[0,(*#J2\n-\n-h%ZcNS8*JE#k(6ij38,[0q$[cVaRB\"FIjhRDA,pSLmUCDTmXQ1P[%8(M@V%X))mK\n-\n-*81HhL'j[ZmK(3P'46jb,ab@$h%jI@)iU6J@&a*8bd!J5%NZ'TC%NDKY\",5%K9lA\n-\n-%%1kQ%f8Z9IE(4kQ5X*9Mq!UPK%dirih2+53-k[E(m!QELQ!-Rl#ccq$6B)6Z-I`\n-\n-FQ(52iC0Hd6f'2a&QlKPm`YDG`5GX%V)aI-*'%r+rq)3prJ`qB9260)C2f\"21i\"-\n-\n-feI!B2QRI@@I`#A[5'Ic*-1NH`dIV+GeMrFY8Q(52j8mG(mdXar#TGUKe(X1R`pq\n-\n-T1G'EYSlfTT4IFZ446jL-RfpLA2G!eYX*@kf3!1dTXPdLfkfbh5AE'fAlbB5G8j'\n-\n-`4rJkCZFXKT(SUhpj-0jKc0+KVIl1dd)2DmAG-GY8*93X&AUb\"HYJr,'#0E!H,EJ\n-\n-1NCe#Mr)KS8HMKZmGh)rJ,V\"iE\"haZ#h!9,BPYJl''HE&0`Sp@9F+$qSClfFqB9h\n-\n-h3F6FlY%JbNC43[653pSVJdcS86hQ89H[mbKL98+8Rk[YF1I00PeH*e3+2HTqAYH\n-\n-N,LMMCc%HqGX+1SASE&1&f@&'l%0mMD%M4m1VBND`e)EiiS,VCTXD(2B'40m'rl5\n-\n-#08#c9pE!hmAAm#U26ZK4E&E48%VR2LJ-CTF+Lq-[Q!rPj\"[UJRc-'14f6EKm3Rq\n-\n-[HC!!63aQaBb,eS*44IHY`T9#9\"TN-1YJpRX&fl4AmahDMZpMp-1B4i1Br38Ef*5\n-\n-LZGT1Yf,T@L'kG+hYpILK5iVBA1+i5A[CfL*0plhmp&KCF6DUCir(CadF[VkJLmr\n-\n-hl$189GrN0XCQaUTQQmSPVV*HpY33GT)apN++X4le+M\"i0Epbf\"EcSZR0GUYL,E'\n-\n-CL0P[#,$5,pp39-AQe,`b2HjB@cfAZmLMk)i,dH$ilTe,er+S69fpF0LG9mb$!l[\n-\n-R31a#i(BDla#LU\"ri@\"l9MH5GKNUFPjh[CUb%le$F&p6Y@VGPQf+Mf`$HhiaG`0F\n-\n-EE!CpNpCmJ'NLh(AkA6XZh4NrZ+jVe`eZK4!eX*L4F(JZ0X03ArHcH#pICpR!*Pl\n-\n-XK4j0L8ffh'rc-KeIere1L4i-[$eMkE2E5r8'IIXP(S2Gl*Q)Zf#a'@X,Qq&K$)b\n-\n-8&-E\"[@,S'A[+pp5)VrqCMI&KiNfa[Q3Qde9lQGE01baYqAD,Zb2SkYi*qa$K!H(\n-\n-QrQk@*rZq5ckG*6lNDIDh!N0&FHA[kK@2A1Tq5ZHFEh)rKLLeYSe0M3qAR,I8E&J\n-\n-jY+[rT[A9)lQhp[p4)R[CAjVd`eG)q5Ap59[1Ed$+lfq3!*Xb2P4bhK@8@k6rTRj\n-\n-JV+rq[$NqA2U`m\"9NK3VKAUem9mqHIDj8lbP\"PFc`j0R0lNQ*I,N$6AVCdp18*hY\n-\n-f0%'EZEh)H$fUN6,B3ica+pmIjZHp2ebp!DT9@&,)#Mf''B9-IjQPr#f@rm`\"TRV\n-\n-fXT+Kq5E,f4-2X#q@$(82A'Tf[iND,j2dTmcpQ*4$$h,S#F8M6-VMR%F+f4IGNqB\n-\n-J'pZ22,VGhpLkJDP%PD'3!+P'N!\"h!rF@[MkB[ljcr`h&frIIb#bGV(J(mUN2X4*\n-\n-pX9j4GNhmp4Y3'hcTK+D*KTP-YEkVC$Za8E*$BZ+*q*Y0FrMmf#+ql$LLcLXFCJU\n-\n-2[K5SU)%*YQ!q)e6KX1%9i!l`mjL@,h-VR'U\"@M4@E)Vpm1i&\"NfaDF-GpbrBfZ9\n-\n-43qpR0r'kZ8c&&BRN0640K&FKHr90+PMRPJr'GaLkK'MXKd,di#&8q%UQd23bTI\"\n-\n-9\"Y@$aT[+kbSUjl2Z'0pB$phR08+dF1AJHN20YhDrGZhcfjrC,IPAlKKLCBC5[4k\n-\n-q9Idh5c&Z18Dc[QH`6BT`b\"(jr6f$$LR#)NHSe0H#a(a5Q2KG+Ee$aFHh0DPJl5(\n-\n-93@8ePZK,p9Z@,YNC(kbfH)D&!Aj)MVPY*'C3MV'dDpHCrHTGCHB\"TLM1TeLdU%9\n-\n--9@4Q+N-4da3eSVGlhF4QX!,1CRRd4iAX3Xj@qF4Il+k`@5b@hZfl9Y@m`Nb'kFM\n-\n-m(e%[4TI(rJ6aDdl'AmecRb,-rM4HPmkJZV0Y@[@eEEU+cSTV%FR$LPDJFf96T)J\n-\n-SBV95T\"T4851Qcr(ieNkAfS!@ABKZ@GfXkpaZ+bYKPM*EQ4$GZVVj(+2NSbLEp4*\n-\n-QXhjcHh'fc9U5,85T)[CflEd\"+)FkYrHZ,P(Zk$8UEGDRHfh@rY@LC[fUCKAPh&$\n-\n-@Y1rVM$T#D)9kIMCdBMTe139Pm1GfheX`RFmY90UY2l2DVI1bQkD-SR6CVHVV',Y\n-\n-QH0(D)YCpAr&dG(pClTG)CrkkmRDVHaU[M*8KLl[iXi\"f16cV#a[iKE'C33leSVV\n-\n-cA&k$1%ZK,B8aKer)+j[dSeNDl&DqM%FeA$0FT%'A9r0mEmcBIIHPIa9riGZ2&Y4\n-\n-)Z5bXVN6AH6jd%(9@BZSH+\"mmR)p+fJ,I1r!p$0mpm2dGI$I#GaYmI`rI25-pFcj\n-\n-Ib+CiY,#QH5B*Jb`#R#\"`$J)R!Rm,r%fb2`5r!f`%81ZYQ*CVS1I,dCQD4M[6f8\"\n-\n-d%aZ`,C3pl(R%#1`5BJ$fKC34E!2I+%5,Z6XAc,!&GAHH@mc&V-9$`JriRE!1mdm\n-\n-QBJfY6\"1EAXca96'V%%d15UJ[MKrdU2JbblTde+I(r2fRV)GU*0F[GKFZ'6FZ&@C\n-\n-!@&e$S`1V*BfZ3,[Ekc'f'QM#1TGaI6mfFAd[dRd&lTYa2mhe[DcQqPkGarAYVFD\n-\n-pRq[EGj!!kh[Gb2@pdFVerHebVZqYjlLqJ6bZladIehI`(Ul[(a4Fhf(J[@rMqRk\n-\n-qJHZ,jh2ph!,FAqIkPGrNqY@YA,rQDG`$A2piD5R$)dE#I+49a0+%1a6`miQp3Qa\n-\n-bq2hBFJaMcC%A-H[Lh9kI1084#2JDa\"!f3ALEk![b$C%30K$$+Rp)$+Z#lAk4M'@\n-\n-U\"BZ%FY95Keh3%Y-m5!m&aNNZUbm3$MY$+e3GhSKrHRQY-ib9%UaRb2XM&r&Bb[Q\n-\n-$#1m2Y(MG+riPr[FUR\"'4$dHFrL$[$S4iX30Jl8iIhq)0r5khhm926M)p@LJ6T9)\n-\n-i'P,4l,[)jI1kP[&L+-6l`aiMMHaaP!k@(kR(!$5jIF64)2HV9c\"fkm2Bb8M[NA,\n-\n-5*ahe$KKB9T9'TSPBKI4**`H4UR2Kk*+M&9J[`FHC*Q&NUD#pVUA83F[45Jadk'0\n-\n-F3Yf1$dpTM65,Hfl&AGM3!#1U'a&eQabGKF82I&eA%c-D$%HjjT%\"U4TMFAb*[&A\n-\n-h)@)HETXFRBf&$h`V0NVHj1U3!,`K#cY(qL511H*j`3MI14L%iN0H')LU%pY@kEb\n-\n-e@+I!ap@!&jDr$K6[395bNR+a,%&ISM6!LST@Uj*V5MUX3Y#A)\"$4+kM@NKY`il$\n-\n-S30pF$R`T#q@S*(BHeKMSieHp#Flf)`,0AQTaDcb@&2)PHQQ)5fb5Xdb1cXF+!Vj\n-\n-N8DB2,Ic5f4Kjid'T!M!XRlE0,$48%8&NcjVeLhiPLG[pfVbedR#BF'qX0CFl+(-\n-\n-SP#2N$)DCki1*FLTMEYAMF%qMfLlECUkT+5IZR$kIUlACYmcS)YhC12(&iZ3YB9'\n-\n-@5Q5*+ZHdkID)X$BCAmp+hXKTKT6AHm#U3r4C*hSQB(BrU*ZE[*&EJ[hH\"NF&f1H\n-\n-b`j%@Ei\"`&+-i5TRYhSDUbbZ*lE\"hTGJB!9#%@0JA5pj3Yh-5l&V,'fQFRq0a03C\n-\n-$hZ956TYb(mp1hP#k+8NN)bQBbZ-#L*FT4c0ATc*h9&5!)3dB`XSCTF08SdMC5D3\n-\n-Pj6BcCAk9Up8CNNK#jN9IDNVH8!QCSr)k39+0G(N`aFD&eSVN$99-XdNF%CZY,D(\n-\n-`\"a@L69D5SkS@&F+T)ekr#\"MM-CcF0*pfUMM`5Hd-*A450pjlk`mPT8VU\"Y9h0R3\n-\n-Mi#,4b)#J'D-9V[Mh#PIqZX**-8jAH0BrUp\"aT*4UR0)#8Sh6@T!!8Se6@T!!maX\n-\n-Yd(kN\"FGd1[HIG2TA[3DH,8Mf'TBDXp4V02ZFVQ8q2,U3!#'KemM%T\"XRp@#KVcU\n-\n-Y\"q@f5Y+$A#aMZCD&Srj`4S3qiL3hckljPY445pa8@+b09#FYcCj'[bpc@BGcr'Q\n-\n-!%69iq@)m[C*8URU(RG4!'ib%'PfYVS`*8j,-6\"h[aReIXbG[D8k5c,e@cYh[$#h\n-\n-lT)pilFFr65[(JLU\"+N',p`QF2Y40KM[Pq2-plHN1e&CT4R@a((P61@0C\"rU4'Q`\n-\n-blVmMh8FNDTaTr9MRD@`4JjR-qSM6-pGM1,T84T8160L3!*%BDI-(2jh'hIh8YR5\n-\n-r8BZ42Y@\"2cR5GhfQ,m$+0,B(FZ(*qFCchdR[JG5Dl3[K98[0EFBhc6Jf!k'Hj$p\n-\n-R)(rUIIG)ebZT#lVHd,,'8%3DJQ5UfdlEP\"@LKiU5A8P9!ff@U2hH-(@biF`FQ[(\n-\n-KV+6++NJeiI9JS(a#A@K@FPTGe,p@Pj4QR&)AdSc6kT,5M&2U3T15dqU5QT4mULl\n-\n-T5FPrl#eaeipXJ`L95k4YN!\"fmDV'M(FlXp`hrMJpBDZc9%XlCB(Q0M6#dJJhdpT\n-\n-%2bZdFd30'KTT[d-6#2rA22prCQFCZHEjar[pNj2C69PYp)K@DM)V+8'fT!3C%RU\n-\n-0$!Sc%%F&0K8NII&jQb@NScQPp1@%DKc0DD4,rDbV-ccd@PV(lCAPY$H4%a*G2UI\n-\n-ARl'MdM)(c3+5MpDF8)f1Rr4*kNc)faB*9I4DMcVDlZfJPej1UXfAEck8RMde1\"C\n-\n-Ci0@')p(QjN#S(A*Mr%a[J*8\"E)T3G!%pL5YhHBl+\"RVj4bhpa)5,Y@G#d)*M[FH\n-\n-rp@3IGap(N9*kF+TlbrUSQrlA5IIaD[aidXeYj&CVNMH83&CM+!&9RaC+%&Q\"[`%\n-\n-!PM5C'9(,)ph(*fUTr9!YMqT9DV2iP&iGfErj4+r'r8D[mMkHFibb02iMPNjf1PA\n-\n-[d(\"$VLh(CI8d(p1LX&VN*cJbP(8k[pfF2kE#ZPqTX(51-%LC%ZXU[a22)[*i8[E\n-\n-rZJ[cIcUGL4G#pHMBk,e2kCF0VX,2PP#E5Iik[#T1$qmHrqXJc[6'Fa2`XLUETTM\n-\n-$*YV-$D3cYp12%m#qEb(qhJ$feL8eGE5PqJMF0!YqXU&'QZAY39+9b(8[r8`\"-MX\n-\n-Ah$6![T!!ITF!pTb'bfV*EbNA&PMaKL[H#UA+i@kTX\"!qGeH&C3R&EkCI&X\"$k6d\n-\n-9PN9@f#m[VUY\"R%+aB%N90%@4PhahPUZj([c3IkY-$A%eUr''+[Q8\"m(LQS3[kcE\n-\n-1G+!PiF[1j8b6mBiYqG4I![EZK'rFji\"Ab\"55leDmdYV+9*,[$[MHa&2kj,XIH(K\n-\n-90KkIa-Ep'I$!Tj5(&h&2b4cN`,G2pSf$$kqZ5Vi*m(hh+pHLCV(B#pqMEAp*2`L\n-\n-K$S-ce482X[1!F4&mDd`jE#EL`-(e-DD6q,X(FCd12IXm1+#IdU#-2SFi1q)HB*d\n-\n-54KI`ANVie'C`8jVJFZTNa%85A%ip'ebqP1\"bkZr$jj-acJ0'8-Di!,i@'@-Q-2E\n-\n-*q68KTiMXZ`ja[9RqCFj@hp%rG\"RpQjINMlqNrpQ&-qA@\"ki53rAP&2rr!!!0$3p\n-\n-YGbpRBh4PFh3Z0MK,,VN!N\"\"453#3%#pd!!\"+8`#3\"2q3\"%e08&*0680$!3#V,jH\n-\n-ZUc!jB!!!\"M%!!\"R%!!!\"V3!!\"E(*MaZS!*!'[VXM4!iL+Pj0j%)PIdhl9fbRBC!\n-\n-!DR1(JAFp3hUJ2KNcZ@(k&LeHlIYc*cMM1X2GRCf\"!*`N(81C&iAQNTm4&Ifii1\"\n-\n-EpGII4h6#PiP+'R-jb[e$&IeM12rA3hh-XBk+D2XK9#@U!P9e!@eRU22XRT!!%ar\n-\n-%6jaP3[FjFKhiIjQ@hidE$&25cAm$`-IrIXai*1U*jZd88q%pXX1%F$M`RNJbAQS\n-\n-ih%%N0J*@A\"\"6p[pE#%1,cL9X%K8j[Z%i38$F)*'R%8!QpTQQT&06TCMf4amme9+\n-\n-jii[1iC(HE43E%aa#QlrCjZ4[GSL(8*!!e8D-E\"#r6LR@&GN3aF6F'028K*cdTGk\n-\n-aT$fkUhhK6F,P(Tj11!CFTLJ+QQSXDINp,M$RL-+Cm9q6j\"VK+Hr'rhrjXB16b1@\n-\n-iec&AC&Z,)bAP)A[QZNkT`brFF9bj0@L(b*(4H3)$i*YCbh9`YK90aj%$0a!Gm&!\n-\n-,de[B3!XlC'%$\"-Eme,D0'(Z229-8DlB`9Q$FC!Y6@9L'KA%@PQm[\")V0YM#PKBP\n-\n-$[mI#m!L#i#MfjAH50i4eE512Q3bj@@90I4m!N!--!'XcXfpJlh2Ij$4lRaZHF-P\n-\n-a`Tr-D)4&@%FjIAiV9hi5rZ3i@3NqRhV5`hI'm8m[3MNjENHi%AjN`!NMR\"`rbB$\n-\n-bTrc)FA,m$%r*F51Fm*03FTa`FTa`-Q#%%hlN'4R`Pa`RA(+FF+mMamRa)mq2m$2\n-\n-#bB!#GjN8B'@Y6-+0iUpN*rl)-F)*2m)*8[#%!j-9H\"9SN!!()1QkKK#+`Hm@K$S\n-\n-HJ&m,rN[#E`hmIJLEJ,q0bk)PQTCS@&q4J@q@4d\"9U,FU)md-(0Yrf-'kLSC3Ech\n-\n-QTZ6PDfM!,6kXTJh48\"8c3%-B$Af2ZR8CG9Ip2$-35k-p#&9[4Zd)$4`EE%%G46!\n-\n-,R0\"9-23T99CN34j4,-#2%@HJ4P(6T'aDQa#N[iMDX5G2a3J5j8hqU`G8AI)J-HU\n-\n-[2pc+8DXTel3Q5K1DDDe`rC'MeMLS#5QV5\"2QC-jFKV@(Y,XiDUf$'TI6Q941+fY\n-\n-NIrEXmabeMLSdTZC&6Ae8m48krm8h(,@HFXdUSU`BRMk!q[lRHBlD3,RQ4#QENT@\n-\n-#\"cXRI2X+4ie6jif)dMfM+mkEUadrc9%E(G5'h+TKlGFqRHHS#3He,LFDrPe`h($\n-\n-QCBlDa(3e*P+'jG[\"RP9riDM0,PI9V\"`8d09SikJYP'YH1C5kHVfHlZ'SDkKIpI4\n-\n-i+LIkaJ28)bpbe,88e9!N694cCG6ZNqFjkMUUN!\"T6DE6ZT(h&AViKGmikRVU\"NX\n-\n-TAdR(H9q1FY4@bY@D,XL9SfF2rY6286HiPp,*+'9G,aJIFG50p#Uce14Gj3Y'd81\n-\n-Ek\"h5cFV&)blrQ+1f8B8b8UTJU&0#eN-9cVh+8GXGe*U-j!-kU)P6p4b9*UB'dj*\n-\n-PCDb-E#IIrF$K4qBkCkfIRK)eFi@ZrFEXr4ae-h@$T1I(e%`C&K,!AUi3T&L#1U`\n-\n-I'P&bCG3h(rRp#Fje+d8&50fBrKHeFp&j@4Q5M3GV$pea1eGSfk+(0$9pa80R1GF\n-\n-ZCkfce*a5FDbGI1mKMRSpifUSq482fFRj!BlD6Id+#UPkaDr(MfcMU0YGVSSeRLY\n-\n-8Z0V[F05H43q4)19lk0aM\"lL(GMKViS\"LkT1'T(MH+rPeTkZ3!*U\"!([&H8FjkLl\n-\n-+0@RS306mKfX[64ZJ+`31D\"5@fGUaCaUiVRd8Y@!C+5NVP42Ef6h&a0E[S,D5e*Z\n-\n-k$e*4k[,4R\"1qUq@S0cKV-k$Hk86c@fiEqT2V*rYSlLHcfePEppip1YM9Hl2Del9\n-\n-2!&`\"@TQ,U#F1&[Z''jdelZ4b1(ZHmdimH\"0(45eR)(&!*q9f)f6q6PCX0VTUBad\n-\n-IAd$pf!@`[ik1Br'KUlR)+fakrN\"cHF(H36)2h%jb&H(+NrX0&jMF9VMIj$*$&L)\n-\n-T\"p)0cLf`Yq1%\"AXR6JQ`Yq'FKMf0GB,GdbRXPYLiZ+lq4#IBL8k`%jeJ*cV\"6R5\n-\n-#RHJ%1p%*GU)6l%3Rf)P1h%qc#+[@Y15RS-eL8qhT&\"fJcd&k4dVkK,dC'pb'AVi\n-\n-MRZjKXmB'HccD3(IrcJ8G(KYmfk)&p1R\"5Hkrqa'fKQc`$Bdfm0&Ek'dF5*Cm&25\n-\n-6E\"T+qQc(16M5i\"iI4FpKHCCb3p#-XSR6I3[1YF$(e@dVrAm(hAhGA,f#1a4fVQ`\n-\n-D)a0bM1IcX19PNiJXd-QrQrjp$rTP0Nh4$ljDEE6C0*GdfSPEQNJ$[AaI\"9dkQjE\n-\n-)\"&rjZ5PSlpQXL6c)65I42'&jkHi((6HE659pGY(F%GhJrk#CBp-AQC!!QcfG`RF\n-\n-BE0C'2GbTm18(Qh@4\"hI+cbI\"'a-fkb-2I05,Qq*VI86`ZS90Dq6\"IEUNPpZrZ6d\n-\n-IkmP@hp@`f9$5UmK,\"LjZ2dGjKIdd'pTRSrf,Re6[[[HdcbYXX0R3aK[KcVI)#mr\n-\n-A-dm\"R8jJFcLjAc2T0r!1Xr%Ph(NRKdhm\"Y1PM9qd9#9(PFc#![X)[SNKr!e@jAm\n-\n-!N!-0$3pYGbpRBh4PFh3Z8&\"$,VN!N\"!4c!#3%%+&!*!)rj!%68e38Ne33d-\"!+X\n-\n-[PkkV-$P&!!!'-3!!'Z!!!!'T!!!&bE5F%03!N!B\"fL0%$L)UANhN3L9r6IYAE+G\n-\n-KN!\"UFiH\"Gce$HU!q'61jBIV#iB$[cjhJM1X-GhH'!`%ib6Q'-Lm+c58r)bVkFF(\n-\n-\"YqU[[irS4$#9MENFjIkKL[iaR2rVS6lQ@%G&Y2d3UK*9JDUkJ,Bce(Pf6fJm&6R\n-\n-b2Z8HRJiXa'A+ir\"\"h#2TreqK*11PKX-G4'@dI[MrP@fl(cXiL9b1Haec4BbeKmP\n-\n-aeJj\"iNA$iL1d#Y1J+HR89#QQrG%86l98l[LLFhLNlhad)NaL2JK&0pZFr-d1m4!\n-\n-+XYS)fcSm[diTeKAC%-A8h\"M6e)5Fp+AHXD3p1ZNm1FY%rabj$[`E!$0bi`E$P26\n-\n-rG@!p\"$aQr-JXH*CjLX,-Um9UPGj1-5VH)fY@`*(4VHaDSf,&r6CPrlq&--R1K6X\n-\n-*#r!9a`Q#\"HZ@0$hdcLR&Z$Fm-LN%a%6I)NG'j`NF&EkCY9`(CaX9iFL4(fpK!IC\n-\n-B8#c-*P,XP1dG-@D4KE%@0XR#9\"C'PcdhhF,ZXE\"3#eYVB3-&a[CDHNU\"FB-@YXI\n-\n-#PPJD!bcX5f0T(aH0)DaV'hR-C-M0+Q[Uq``!Da0l'f3fmMSr\"jhCCQZ%N3NRNdf\n-\n-14LJRP\"rPR[a@3Sqr%8D1NjAJmk5Hp2#G-Ic6Le\"1MJm)Pachb(2###I(6c*J%8k\n-\n-j%8k1RiHRj,J46[K*+$P11$P11\"P3`JNrmS`-q)!-Z'6!D6eKj2L4C`f-F$+J`(8\n-\n-Q\"D$m9QE4e,T1r\"&qK,q%%k6J#3FQ+c!qS%%HJ+LU#N)S\",rE%'S`i2Fjq\"D$ha,\n-\n-iI4qf+2P[K53BJQi)Q['&0I#IjBQL)Y4CP\"42pjcUHm,'ZSf'8'HBF--Ck@qdLS0\n-\n-b3K-d'HXH'L*+S#ZS9C93Dp(hThY##E32SH*'Y!@KRP2p0@MV!TJ\"6QM*DZUi,'%\n-\n-T+JeJ!r\"$PM03TD!SBLUKM%E&Qd60d0-c)3Z*mVDqK3&9&I13!!6eTfr[iUM&P'Y\n-\n-#%F4446G@Z(l(88YXe)LB`Z+S2TE@Pf(0!mTp(,A84Uf3!\",*H&STD'4qmZcc(,@\n-\n--+M3XC`4&IJbl#Phql%Z1'UCF8eL3!,#@e`G3hrdd`e(,+GHd)+EL%XlQBDHLAlh\n-\n--85ZSm`B%mB'K&HG0PBjFj+L90QTjHXf`jUXI6h28L)eDPKBdpblBE[Mm*BjDaA6\n-\n-94Z1DiGV\"R*4rj+M9$PGCAcdSS+ZfQD2@8+iCI$4qqhSpdmj4DkPIeF4)2#fiaJ2\n-\n-8Bbpbe(889F1L)XMT!QVVKFXFYBiUT\"YMLB5UC9b&(RhKCikkRVV\"`)8VDEQKZf-\n-\n-V4kfRA)f*V,4kp-cqUedFGB0c+Hf-8Y$eQ[B\"4pe)Vc*,6IQVI%eEm0!QHSG8IIA\n-\n-L@5lrN!#MEUCQhhrr8(p,Ec3@kie#4,V\"pIbK)a`9-T!!GBlk-`E@KJ84,f%LG'i\n-\n-f[T!!!'KLUKNie$XiPM(N0&lQH[KU'dGYS\"j+L['X*Sp(8hPGSl0R1'UMM9U5&&e\n-\n-!'c8b%qDSN!\"L,3rTKL6Ki3+b'A[l2CZI0G[Y06`a,LMk#PhcpFQ(1'S6pDZSCSE\n-\n-PC!&fUR[r&Uj3-eASS(Td!+F,U1H1r2)8jpT#83&5e5EZS1kBGej+JZb9Kc82h(-\n-\n-h9kKehN1+R,MPS8ZFDjZpPPPABF@aCZbG`abeRA(9j-b+KmcBG!p(lD\"q\"B9NGG@\n-\n-[CimeFp5G$PGXM+5cUec0YcMUVRN2@9(2pG$Xii2F3jhf'KR%ZMUQL6M[[CaIGcX\n-\n-+b8Q)f,HFGj+MGP'Z-8d&S[SrA2I32!5k3L5#cQ1CV4NkAXjer4pehS\"JT*BMJmh\n-\n-eq+jHMVUAFXdD@Pa-LB8NHQRI3K)PI3p-0D6jHqhb!-,0lkJIrAq#kpTYIkZh1S$\n-\n-iJj!!%H0,\"hSUqR8TjiTU6d$LH!3qd\"l'QVp5(*Z0MQj%N5IR8$IK#2YVk#b4%AU\n-\n-KAhRjVG*[D*cA0T*HB1mJp`hf9R+*B@mR9a,f0R*MBGp1mJVX655\"`0j)XK,X1mL\n-\n-pKlf\"*+irG2*l,$B1E[#\"6T2S$,#X@[56ejba+FlV&\"bJcm2dMZ6dm6Xk0U4jAES\n-\n-MHGhp&Sp0DH#\"lZkGmrT#0Q@\"!rVX)TRXhr[K0j4X`S%(2RS$[3RXDKCpj(@KE-T\n-\n-cqZ`NL6E3i\"kI4160319LE[\"D@$B9G'mQ#4Ai1,Ued1qGG(GeFr6blT!!hqqbU3a\n-\n--b$&jRrZ0-TY)B)&1lYedll[ACE1T#Rl`e9TlcUBkTp0ZdVF%-H4Z[lGR8a1Bi#X\n-\n-h0hN[\"GM8\"KlNTJYSfQ*jrHjlI6UE66PpZQMZ#'l`[pH@XGNEQ*!!Qr-kq@mqf+`\n-\n-,HVK6rLX60R@\"\"hI+c5IHHaBfk`-2I,5(G,jrpK(H5aSfpB%(pqQkANlrj[4mV#G\n-\n-EHm2$CN01V`9H%R\"aqMR+bhpj`iDqe%&p8bAIR!qTj%[4$kpFY(MK'lcmYcPXk&Z\n-\n-H1lcmlTi0lIT[mPVbJIFUL!elGjRM4BM8c8\"+#$@\"@kr%qK5GrJGH8d5JeDSp%6Z\n-\n-S`aY94TZmpLQ+$H(Nh\"cl%r`RK-KrL#Vr!3#3!aq$!!!\"!*!$!43!N!-8!*!$-Tr\n-\n-lRLe!rr#`!,K[$#eZd!6rm2rdd\"lm`FAKdkSV8FY+$deKBe\"bEfTPBh4c,R0TG!)\n-\n-!N!06594%8dP8)3#3\"P0*9%46593K!*!BUc!jI3!!8M8!!!&'\"1\"2l'mDG@6JrHc\n-\n-K@5U#NI*HN@GK!Z\"2kQ`FG&2UN!\"S!!,L@5[48(adA`CdC!EJ6qj[8hJS!!EJEHl\n-\n-LEe5!)D$!FJC1ANl!*IrX51FI-#D`jL63G!*&0K!+1Li!&Ri!)VX-S\"lbUKQJ(Z`\n-\n-3!+SDI!$!#3ZT8,aIE!!!Q$!'8!6\"aG!!N!-3!#X!\"3%B!J#3\"`-!N!-\"!*!$!43\n-\n-!N!-8!*!$-J$j(l!@#J#3!a`!-J!!8f9dC`#3!`S!!2rr!*!&q@G%'@B:\n-"}, {"sha": "4e5d25277887c68405027cb48657b7c88ca6d366", "filename": "boehm-gc/Mac_files/MacOS_Test_config.h", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMac_files%2FMacOS_Test_config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMac_files%2FMacOS_Test_config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMac_files%2FMacOS_Test_config.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,91 +0,0 @@\n-/*\n-\tMacOS_Test_config.h\n-\t\n-\tConfiguration flags for Macintosh development systems.\n-\t\n-\tTest version.\n-\t\n- \t<Revision History>\n-\n- \t11/16/95  pcb  Updated compilation flags to reflect latest 4.6 Makefile.\n-\t\n-\tby Patrick C. Beard.\n- */\n-/* Boehm, November 17, 1995 12:05 pm PST */\n-\n-#ifdef __MWERKS__\n-\n-// for CodeWarrior Pro with Metrowerks Standard Library (MSL).\n-// #define MSL_USE_PRECOMPILED_HEADERS 0\n-#include <ansi_prefix.mac.h>\n-#ifndef __STDC__\n-#define __STDC__ 0\n-#endif\n-\n-#endif\n-\n-// these are defined again in gc_priv.h.\n-#undef TRUE\n-#undef FALSE\n-\n-#define ALL_INTERIOR_POINTERS\t// follows interior pointers.\n-//#define SILENT\t\t\t\t// want collection messages.\n-//#define DONT_ADD_BYTE_AT_END\t// no padding.\n-//#define SMALL_CONFIG\t\t\t// whether to a smaller heap.\n-#define NO_SIGNALS\t\t\t\t// signals aren't real on the Macintosh.\n-#define USE_TEMPORARY_MEMORY\t// use Macintosh temporary memory.\n-\n-// CFLAGS= -O -DNO_SIGNALS -DALL_INTERIOR_POINTERS -DSILENT\n-//\n-//LIBGC_CFLAGS= -O -DNO_SIGNALS -DSILENT \\\n-//    -DREDIRECT_MALLOC=GC_malloc_uncollectable \\\n-//    -DDONT_ADD_BYTE_AT_END -DALL_INTERIOR_POINTERS\n-//   Flags for building libgc.a -- the last two are required.\n-//\n-// Setjmp_test may yield overly optimistic results when compiled\n-// without optimization.\n-// -DSILENT disables statistics printing, and improves performance.\n-// -DCHECKSUMS reports on erroneously clear dirty bits, and unexpectedly\n-//   altered stubborn objects, at substantial performance cost.\n-//   Use only for incremental collector debugging.\n-// -DFIND_LEAK causes the collector to assume that all inaccessible\n-//   objects should have been explicitly deallocated, and reports exceptions.\n-//   Finalization and the test program are not usable in this mode.\n-// -DSOLARIS_THREADS enables support for Solaris (thr_) threads.\n-//   (Clients should also define SOLARIS_THREADS and then include\n-//   gc.h before performing thr_ or GC_ operations.)\n-//   This is broken on nonSPARC machines.\n-// -DALL_INTERIOR_POINTERS allows all pointers to the interior\n-//   of objects to be recognized.  (See gc_priv.h for consequences.)\n-// -DSMALL_CONFIG tries to tune the collector for small heap sizes,\n-//   usually causing it to use less space in such situations.\n-//   Incremental collection no longer works in this case.\n-// -DLARGE_CONFIG tunes the collector for unusually large heaps.\n-//   Necessary for heaps larger than about 500 MB on most machines.\n-//   Recommended for heaps larger than about 64 MB.\n-// -DDONT_ADD_BYTE_AT_END is meaningful only with\n-//   -DALL_INTERIOR_POINTERS.  Normally -DALL_INTERIOR_POINTERS\n-//   causes all objects to be padded so that pointers just past the end of\n-//   an object can be recognized.  This can be expensive.  (The padding\n-//   is normally more than one byte due to alignment constraints.)\n-//   -DDONT_ADD_BYTE_AT_END disables the padding.\n-// -DNO_SIGNALS does not disable signals during critical parts of\n-//   the GC process.  This is no less correct than many malloc \n-//   implementations, and it sometimes has a significant performance\n-//   impact.  However, it is dangerous for many not-quite-ANSI C\n-//   programs that call things like printf in asynchronous signal handlers.\n-// -DGC_OPERATOR_NEW_ARRAY declares that the C++ compiler supports the\n-//   new syntax \"operator new[]\" for allocating and deleting arrays.\n-//   See gc_cpp.h for details.  No effect on the C part of the collector.\n-//   This is defined implicitly in a few environments.\n-// -DREDIRECT_MALLOC=X causes malloc, realloc, and free to be defined\n-//   as aliases for X, GC_realloc, and GC_free, respectively.\n-//   Calloc is redefined in terms of the new malloc.  X should\n-//   be either GC_malloc or GC_malloc_uncollectable.\n-//   The former is occasionally useful for working around leaks in code\n-//   you don't want to (or can't) look at.  It may not work for\n-//   existing code, but it often does.  Neither works on all platforms,\n-//   since some ports use malloc or calloc to obtain system memory.\n-//   (Probably works for UNIX, and win32.)\n-// -DNO_DEBUG removes GC_dump and the debugging routines it calls.\n-//   Reduces code size slightly at the expense of debuggability."}, {"sha": "407bdf154a272aa034ad8455f60358ad5bbeacfe", "filename": "boehm-gc/Mac_files/MacOS_config.h", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMac_files%2FMacOS_config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMac_files%2FMacOS_config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMac_files%2FMacOS_config.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,89 +0,0 @@\n-/*\n-\tMacOS_config.h\n-\t\n-\tConfiguration flags for Macintosh development systems.\n-\t\n- \t<Revision History>\n- \t\n- \t11/16/95  pcb  Updated compilation flags to reflect latest 4.6 Makefile.\n-\t\n-\tby Patrick C. Beard.\n- */\n-/* Boehm, November 17, 1995 12:10 pm PST */\n-\n-#ifdef __MWERKS__\n-\n-// for CodeWarrior Pro with Metrowerks Standard Library (MSL).\n-// #define MSL_USE_PRECOMPILED_HEADERS 0\n-#include <ansi_prefix.mac.h>\n-#ifndef __STDC__\n-#define __STDC__ 0\n-#endif\n-\n-#endif /* __MWERKS__ */\n-\n-// these are defined again in gc_priv.h.\n-#undef TRUE\n-#undef FALSE\n-\n-#define ALL_INTERIOR_POINTERS\t// follows interior pointers.\n-#define SILENT\t\t\t// no collection messages.\n-//#define DONT_ADD_BYTE_AT_END\t// no padding.\n-//#define SMALL_CONFIG\t\t// whether to use a smaller heap.\n-#define NO_SIGNALS\t\t// signals aren't real on the Macintosh.\n-#define USE_TEMPORARY_MEMORY\t// use Macintosh temporary memory.\n-\n-// CFLAGS= -O -DNO_SIGNALS -DSILENT -DALL_INTERIOR_POINTERS\n-//\n-//LIBGC_CFLAGS= -O -DNO_SIGNALS -DSILENT \\\n-//    -DREDIRECT_MALLOC=GC_malloc_uncollectable \\\n-//    -DDONT_ADD_BYTE_AT_END -DALL_INTERIOR_POINTERS\n-//   Flags for building libgc.a -- the last two are required.\n-//\n-// Setjmp_test may yield overly optimistic results when compiled\n-// without optimization.\n-// -DSILENT disables statistics printing, and improves performance.\n-// -DCHECKSUMS reports on erroneously clear dirty bits, and unexpectedly\n-//   altered stubborn objects, at substantial performance cost.\n-//   Use only for incremental collector debugging.\n-// -DFIND_LEAK causes the collector to assume that all inaccessible\n-//   objects should have been explicitly deallocated, and reports exceptions.\n-//   Finalization and the test program are not usable in this mode.\n-// -DSOLARIS_THREADS enables support for Solaris (thr_) threads.\n-//   (Clients should also define SOLARIS_THREADS and then include\n-//   gc.h before performing thr_ or GC_ operations.)\n-//   This is broken on nonSPARC machines.\n-// -DALL_INTERIOR_POINTERS allows all pointers to the interior\n-//   of objects to be recognized.  (See gc_priv.h for consequences.)\n-// -DSMALL_CONFIG tries to tune the collector for small heap sizes,\n-//   usually causing it to use less space in such situations.\n-//   Incremental collection no longer works in this case.\n-// -DLARGE_CONFIG tunes the collector for unusually large heaps.\n-//   Necessary for heaps larger than about 500 MB on most machines.\n-//   Recommended for heaps larger than about 64 MB.\n-// -DDONT_ADD_BYTE_AT_END is meaningful only with\n-//   -DALL_INTERIOR_POINTERS.  Normally -DALL_INTERIOR_POINTERS\n-//   causes all objects to be padded so that pointers just past the end of\n-//   an object can be recognized.  This can be expensive.  (The padding\n-//   is normally more than one byte due to alignment constraints.)\n-//   -DDONT_ADD_BYTE_AT_END disables the padding.\n-// -DNO_SIGNALS does not disable signals during critical parts of\n-//   the GC process.  This is no less correct than many malloc \n-//   implementations, and it sometimes has a significant performance\n-//   impact.  However, it is dangerous for many not-quite-ANSI C\n-//   programs that call things like printf in asynchronous signal handlers.\n-// -DGC_OPERATOR_NEW_ARRAY declares that the C++ compiler supports the\n-//   new syntax \"operator new[]\" for allocating and deleting arrays.\n-//   See gc_cpp.h for details.  No effect on the C part of the collector.\n-//   This is defined implicitly in a few environments.\n-// -DREDIRECT_MALLOC=X causes malloc, realloc, and free to be defined\n-//   as aliases for X, GC_realloc, and GC_free, respectively.\n-//   Calloc is redefined in terms of the new malloc.  X should\n-//   be either GC_malloc or GC_malloc_uncollectable.\n-//   The former is occasionally useful for working around leaks in code\n-//   you don't want to (or can't) look at.  It may not work for\n-//   existing code, but it often does.  Neither works on all platforms,\n-//   since some ports use malloc or calloc to obtain system memory.\n-//   (Probably works for UNIX, and win32.)\n-// -DNO_DEBUG removes GC_dump and the debugging routines it calls.\n-//   Reduces code size slightly at the expense of debuggability."}, {"sha": "a3e3fe8446ffcfac74811b86cfe2050934b6aca2", "filename": "boehm-gc/Mac_files/dataend.c", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMac_files%2Fdataend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMac_files%2Fdataend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMac_files%2Fdataend.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,9 +0,0 @@\n-/*\n-\tdataend.c\n-\t\n-\tA hack to get the extent of global data for the Macintosh.\n-\t\n-\tby Patrick C. Beard.\n- */\n-\n-long __dataend;"}, {"sha": "a9e0dd59410813c10891c3b9963c6e2ecf791333", "filename": "boehm-gc/Mac_files/datastart.c", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMac_files%2Fdatastart.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMac_files%2Fdatastart.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMac_files%2Fdatastart.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,9 +0,0 @@\n-/*\n-\tdatastart.c\n-\t\n-\tA hack to get the extent of global data for the Macintosh.\n-\t\n-\tby Patrick C. Beard.\n- */\n-\n-long __datastart;"}, {"sha": "011f49d3bcf033a9cf8886fdf21e8f43084ea90b", "filename": "boehm-gc/Makefile.DLLs", "status": "removed", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMakefile.DLLs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMakefile.DLLs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.DLLs?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,107 +0,0 @@\n-#-----------------------------------------------------------------------------#\n-\n-# Makefile.DLLs, version 0.4.\n-\n-# Contributed by Fergus Henderson.\n-\n-# This Makefile contains rules for creating DLLs on Windows using gnu-win32.\n-\n-#-----------------------------------------------------------------------------#\n-\n-# This rule creates a `.def' file, which lists the symbols that are exported\n-# from the DLL.  We use `nm' to get a list of all the exported text (`T')\n-# symbols and data symbols -- including uninitialized data (`B'),\n-# initialized data (`D'), read-only data (`R'), and common blocks (`C').\n-%.def: %.a\n-\techo EXPORTS > $@\n-\tnm $< | grep '^........ [BCDRT] _' | sed 's/[^_]*_//' >> $@\n-\n-# We need to use macros to access global data:\n-# the user of the DLL must refer to `foo' as `(*__imp_foo)'.\n-# This rule creates a `_globals.h' file, which contains macros\n-# for doing this.\n-\n-SYM_PREFIX = $(firstword $(SYM_PREFIX-$*) $*)\n-DLL_MACRO = $(SYM_PREFIX)_USE_DLL\n-IMP_MACRO = $(SYM_PREFIX)_IMP\n-GLOBAL_MACRO = $(SYM_PREFIX)_GLOBAL\n-\n-%_globals.h: %.a\n-\techo \"/* automatically generated by Makefile.DLLs */\"\t> $@\n-\techo \"#if defined(__GNUC__) && defined(_WIN32) \\\\\"\t>> $@\n-\techo \"\t&& defined($(DLL_MACRO))\"\t\t\t>> $@\n-\techo \"#  define $(IMP_MACRO)(name)\t__imp_##name\" \t>> $@\n-\techo \"#  define $(GLOBAL_MACRO)(name)\t(*$(IMP_MACRO)(name))\" >> $@\n-\techo \"#else\"\t\t\t\t\t\t>> $@\n-\techo \"#  define $(GLOBAL_MACRO)(name)\tname\"\t\t>> $@\n-\techo \"#endif\"\t\t\t\t\t\t>> $@\n-\techo \"\"\t\t\t\t\t\t\t>> $@\n-\tfor sym in `nm $< | grep '^........ [BCDR] _' | sed 's/[^_]*_//'`; do \\\n-\t\techo \"#define $$sym\t$(GLOBAL_MACRO)($$sym)\"\t>> $@; \\\n-\tdone\n-\n-# This rule creates the export object file (`foo.exp') which contains the\n-# jump table array; this export object file becomes part of the DLL. \n-# This rule also creates the import library (`foo_dll.a') which contains small\n-# stubs for all the functions exported by the DLL which jump to them via the\n-# jump table.  Executables that will use the DLL must be linked against this\n-# stub library.\n-%.exp %_dll.a : %.def\n-\tdlltool $(DLLTOOLFLAGS) $(DLLTOOLFLAGS-$*)\t\t\\\n-\t\t--def $<\t\t\t\t\t\\\n-\t\t--dllname $*.dll\t\t\t\t\\\n-\t\t--output-exp $*.exp\t\t\t\t\\\n-\t\t--output-lib $*_dll.a\n-\n-# The `sed' commands below are to convert DOS-style `C:\\foo\\bar'\n-# pathnames into Unix-style `//c/foo/bar' pathnames.\n-CYGWIN32_LIBS = $(shell echo\t\t\t\t\t\\\n-\t-L`dirname \\`gcc -print-file-name=libgcc.a |\t\t\\\n-\tsed -e 's@^\\\\\\\\([A-Za-z]\\\\\\\\):@//\\\\\\\\1@g' -e 's@\\\\\\\\\\\\\\\\@/@g' \\` ` \\\n-\t-L`dirname \\`gcc -print-file-name=libcygwin.a |\t\\\n-\tsed -e 's@^\\\\\\\\([A-Za-z]\\\\\\\\):@//\\\\\\\\1@g' -e 's@\\\\\\\\\\\\\\\\@/@g' \\` ` \\\n-\t-L`dirname \\`gcc -print-file-name=libkernel32.a | \\\n-\tsed -e 's@^\\\\\\\\([A-Za-z]\\\\\\\\):@//\\\\\\\\1@g' -e 's@\\\\\\\\\\\\\\\\@/@g' \\` ` \\\n-\t-lgcc -lcygwin -lkernel32 -lgcc)\n-\n-RELOCATABLE=yes\n-\n-ifeq \"$(strip $(RELOCATABLE))\" \"yes\"\n-\n-# to create relocatable DLLs, we need to do two passes\n-%.dll: %.exp %.a dll_fixup.o dll_init.o\n-\t$(LD) $(LDFLAGS) $(LDFLAGS-$*) --dll -o $*.base\t\t\t\\\n-\t\t-e _dll_entry@12 dll_init.o\t\t\t\t\\\n-\t\tdll_fixup.o $*.exp $*.a\t\t\t\t\t\\\n-\t\t$(LDLIBS) $(LDLIBS-$*)\t\t\t\t\t\\\n-\t\t$(CYGWIN32_LIBS)\n-\t$(LD) $(LDFLAGS) $(LDFLAGS-$*) --dll --base-file $*.base -o $@\t\\\n-\t\t-e _dll_entry@12 dll_init.o\t\t\t\t\\\n-\t\tdll_fixup.o $*.exp $*.a\t\t\t\t\t\\\n-\t\t$(LDLIBS) $(LDLIBS-$*)\t\t\t\t\t\\\n-\t\t$(CYGWIN32_LIBS)\n-\trm -f $*.base\n-else\n-\n-%.dll: %.exp %.a dll_fixup.o dll_init.o\n-\t$(LD) $(LDFLAGS) $(LDFLAGS-$*) --dll -o $@\t\t\t\\\n-\t\t-e _dll_entry@12 dll_init.o\t\t\t\t\\\n-\t\tdll_fixup.o $*.exp $*.a\t\t\t\t\t\\\n-\t\t$(LDLIBS) $(LDLIBS-$*)\t\t\t\t\t\\\n-\t\t$(CYGWIN32_LIBS)\n-\n-endif\n-\n-# This black magic piece of assembler needs to be linked in in order to\n-# properly terminate the list of imported DLLs.\n-dll_fixup.s:\n-\techo '.section .idata$$3' \t> dll_fixup.s\n-\techo '.long 0,0,0,0, 0,0,0,0'\t>> dll_fixup.s\n-\n-# This bit is necessary to provide an initialization function for the DLL.\n-dll_init.c:\n-\techo '__attribute__((stdcall))' > dll_init.c\n-\techo 'int dll_entry(int handle, int reason, void *ptr)' >> dll_init.c\n-\techo '{return 1; }' >> dll_init.c\n-\n-dont_throw_away: dll_fixup.o dll_init.o"}, {"sha": "fa187ef31ee241632e016d5d8f46a8b02b2327e9", "filename": "boehm-gc/Makefile.am", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.am?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,102 +0,0 @@\n-## Process this file with automake to produce Makefile.in.\n-\n-## FIXME: `make dist' in this directory will not currently work.  Many\n-## files that should be in the distribution are not mentioned in this\n-## Makefile.am.\n-\n-AUTOMAKE_OPTIONS = foreign subdir-objects no-dist\n-ACLOCAL_AMFLAGS = -I .. -I ../config\n-\n-SUBDIRS = include testsuite\n-\n-noinst_LTLIBRARIES = libgcjgc.la libgcjgc_convenience.la\n-\n-if POWERPC_DARWIN\n-asm_libgcjgc_sources = powerpc_darwin_mach_dep.s\n-else\n-asm_libgcjgc_sources = \n-endif\n-\n-libgcjgc_la_SOURCES = allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c \\\n-dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c \\\n-malloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c \\\n-obj_map.c os_dep.c pcr_interface.c ptr_chck.c real_malloc.c reclaim.c \\\n-specific.c stubborn.c typd_mlc.c \\\n-backgraph.c win32_threads.c \\\n-pthread_support.c pthread_stop_world.c darwin_stop_world.c \\\n-$(asm_libgcjgc_sources)\n-\n-libgcjgc_convenience_la_SOURCES = $(libgcjgc_la_SOURCES)\n-\n-EXTRA_DIST = alpha_mach_dep.S \\\n-mips_sgi_mach_dep.s mips_ultrix_mach_dep.s powerpc_darwin_mach_dep.s \\\n-rs6000_mach_dep.s sparc_mach_dep.S sparc_netbsd_mach_dep.s \\\n-sparc_sunos4_mach_dep.s ia64_save_regs_in_stack.s\n-\n-# Include THREADLIBS here to ensure that the correct versions of\n-# linuxthread semaphore functions get linked:\n-libgcjgc_la_LIBADD = $(addobjs) $(THREADLIBS) $(EXTRA_TEST_LIBS)\n-libgcjgc_la_DEPENDENCIES = $(addobjs)\n-libgcjgc_la_LDFLAGS = $(extra_ldflags_libgc) -version-info 1:2:0 -rpath $(toolexeclibdir)\n-libgcjgc_la_LINK = $(LINK) $(libgcjgc_la_LDFLAGS)\n-\n-libgcjgc_convenience_la_LIBADD = $(addobjs)\n-libgcjgc_convenience_la_DEPENDENCIES = $(addobjs)\n-\n-AM_CXXFLAGS = $(GC_CFLAGS) $(THREADCFLAGS)\n-AM_CFLAGS = $(GC_CFLAGS) $(THREADCFLAGS)\n-AM_LDFLAGS = $(shell $(top_srcdir)/../libtool-ldflags $(LDFLAGS))\n-override CFLAGS := $(filter-out $(O0_CFLAGS), $(CFLAGS)) $(O0_CFLAGS)\n-\n-## FIXME: we shouldn't have to do this, but automake forces us to.\n-.s.lo:\n-## We use -Wp,-P to strip #line directives.  Irix `as' chokes on\n-## these.\n-\t$(LTCOMPILE) -Wp,-P -x assembler-with-cpp -c $<\n-.S.lo:\n-\t$(LTCOMPILE) -Wp,-P -x assembler-with-cpp -c $<\n-\n-# Work around what appears to be a GNU make bug handling MAKEFLAGS\n-# values defined in terms of make variables, as is the case for CC and\n-# friends when we are called from the top level Makefile.\n-AM_MAKEFLAGS = \\\n-\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n-\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n-\t\"CFLAGS=$(CFLAGS)\" \\\n-\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n-\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n-\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n-\t\"INSTALL=$(INSTALL)\" \\\n-\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n-\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n-\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n-\t\"LDFLAGS=$(LDFLAGS)\" \\\n-\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\"MAKE=$(MAKE)\" \\\n-\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n-\t\"PICFLAG=$(PICFLAG)\" \\\n-\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n-\t\"SHELL=$(SHELL)\" \\\n-\t\"EXPECT=$(EXPECT)\" \\\n-\t\"RUNTEST=$(RUNTEST)\" \\\n-\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n-\t\"exec_prefix=$(exec_prefix)\" \\\n-\t\"infodir=$(infodir)\" \\\n-\t\"libdir=$(libdir)\" \\\n-\t\"prefix=$(prefix)\" \\\n-\t\"tooldir=$(tooldir)\" \\\n-\t\"AR=$(AR)\" \\\n-\t\"AS=$(AS)\" \\\n-\t\"CC=$(CC)\" \\\n-\t\"CXX=$(CXX)\" \\\n-\t\"LD=$(LD)\" \\\n-\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-\t\"NM=$(NM)\" \\\n-\t\"PICFLAG=$(PICFLAG)\" \\\n-\t\"RANLIB=$(RANLIB)\" \\\n-\t\"DESTDIR=$(DESTDIR)\"\n-\n-CONFIG_STATUS_DEPENDENCIES = $(srcdir)/configure.host\n-\n-MAKEOVERRIDES="}, {"sha": "8b4dff1fb73f4d315793d370fc99b8b9a9fa3e6f", "filename": "boehm-gc/Makefile.direct", "status": "removed", "additions": 0, "deletions": 685, "changes": 685, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMakefile.direct", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMakefile.direct", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.direct?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,685 +0,0 @@\n-# This is the original manually generated Makefile.  It may still be used\n-# to build the collector.\n-#\n-# Primary targets:\n-# gc.a - builds basic library\n-# c++ - adds C++ interface to library\n-# cords - adds cords (heavyweight strings) to library\n-# test - prints porting information, then builds basic version of gc.a,\n-#      \t and runs some tests of collector and cords.  Does not add cords or\n-#\t c++ interface to gc.a\n-# cord/de - builds dumb editor based on cords.\n-ABI_FLAG= \n-# ABI_FLAG should be the cc flag that specifies the ABI.  On most\n-# platforms this will be the empty string.  Possible values:\n-# +DD64 for 64-bit executable on HP/UX.\n-# -n32, -n64, -o32 for SGI/MIPS ABIs.\n-\n-AS_ABI_FLAG=$(ABI_FLAG)\n-# ABI flag for assembler.  On HP/UX this is +A64 for 64 bit\n-# executables.\n-\n-CC=cc $(ABI_FLAG)\n-CXX=g++ $(ABI_FLAG)\n-AS=as $(AS_ABI_FLAG)\n-#  The above doesn't work with gas, which doesn't run cpp.\n-#  Define AS as `gcc -c -x assembler-with-cpp' instead.\n-\n-# Redefining srcdir allows object code for the nonPCR version of the collector\n-# to be generated in different directories.\n-srcdir= .\n-VPATH= $(srcdir)\n-\n-CFLAGS= -O -I$(srcdir)/include -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DNO_EXECUTE_PERMISSION -DSILENT -DALL_INTERIOR_POINTERS\n-\n-# To build the parallel collector on Linux, add to the above:\n-# -DGC_LINUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC\n-# To build the parallel collector in a static library on HP/UX,\n-# add to the above:\n-# -DGC_HPUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC -D_POSIX_C_SOURCE=199506L -mt\n-# To build the thread-safe collector on Tru64, add to the above:\n-# -pthread -DGC_OSF1_THREADS\n-\n-# HOSTCC and HOSTCFLAGS are used to build executables that will be run as\n-# part of the build process, i.e. on the build machine.  These will usually\n-# be the same as CC and CFLAGS, except in a cross-compilation environment.\n-# Note that HOSTCFLAGS should include any -D flags that affect thread support.\n-HOSTCC=$(CC)\n-HOSTCFLAGS=$(CFLAGS)\n-\n-# For dynamic library builds, it may be necessary to add flags to generate\n-# PIC code, e.g. -fPIC on Linux.\n-\n-# Setjmp_test may yield overly optimistic results when compiled\n-# without optimization.\n-\n-# These define arguments influence the collector configuration:\n-# -DSILENT disables statistics printing, and improves performance.\n-# -DFIND_LEAK causes GC_find_leak to be initially set.\n-#   This causes the collector to assume that all inaccessible\n-#   objects should have been explicitly deallocated, and reports exceptions.\n-#   Finalization and the test program are not usable in this mode.\n-# -DGC_SOLARIS_THREADS enables support for Solaris (thr_) threads.\n-#   (Clients should also define GC_SOLARIS_THREADS and then include\n-#   gc.h before performing thr_ or dl* or GC_ operations.)\n-#   Must also define -D_REENTRANT.\n-# -DGC_SOLARIS_PTHREADS enables support for Solaris pthreads.\n-#   (Internally this define GC_SOLARIS_THREADS as well.)\n-# -DGC_IRIX_THREADS enables support for Irix pthreads.  See README.irix.\n-# -DGC_HPUX_THREADS enables support for HP/UX 11 pthreads.\n-#   Also requires -D_REENTRANT or -D_POSIX_C_SOURCE=199506L. See README.hp.\n-# -DGC_LINUX_THREADS enables support for Xavier Leroy's Linux threads.\n-#   see README.linux.  -D_REENTRANT may also be required.\n-# -DGC_OSF1_THREADS enables support for Tru64 pthreads.\n-# -DGC_FREEBSD_THREADS enables support for FreeBSD pthreads.\n-#   Appeared to run into some underlying thread problems.\n-# -DGC_DARWIN_THREADS enables support for Mac OS X pthreads.\n-# -DGC_AIX_THREADS enables support for IBM AIX threads.\n-# -DGC_DGUX386_THREADS enables support for DB/UX on I386 threads.\n-#   See README.DGUX386.\n-# -DGC_WIN32_THREADS enables support for win32 threads.  That makes sense\n-#   for this Makefile only under Cygwin.\n-# -DGC_THREADS should set the appropriate one of the above macros.\n-#   It assumes pthreads for Solaris.\n-# -DALL_INTERIOR_POINTERS allows all pointers to the interior\n-#   of objects to be recognized.  (See gc_priv.h for consequences.)\n-#   Alternatively, GC_all_interior_pointers can be set at process\n-#   initialization time.\n-# -DSMALL_CONFIG tries to tune the collector for small heap sizes,\n-#   usually causing it to use less space in such situations.\n-#   Incremental collection no longer works in this case.\n-# -DLARGE_CONFIG tunes the collector for unusually large heaps.\n-#   Necessary for heaps larger than about 500 MB on most machines.\n-#   Recommended for heaps larger than about 64 MB.\n-# -DDONT_ADD_BYTE_AT_END is meaningful only with -DALL_INTERIOR_POINTERS or\n-#   GC_all_interior_pointers = 1.  Normally -DALL_INTERIOR_POINTERS\n-#   causes all objects to be padded so that pointers just past the end of\n-#   an object can be recognized.  This can be expensive.  (The padding\n-#   is normally more than one byte due to alignment constraints.)\n-#   -DDONT_ADD_BYTE_AT_END disables the padding.\n-# -DNO_SIGNALS does not disable signals during critical parts of\n-#   the GC process.  This is no less correct than many malloc \n-#   implementations, and it sometimes has a significant performance\n-#   impact.  However, it is dangerous for many not-quite-ANSI C\n-#   programs that call things like printf in asynchronous signal handlers.\n-#   This is on by default.  Turning it off has not been extensively tested with\n-#   compilers that reorder stores.  It should have been.\n-# -DNO_EXECUTE_PERMISSION may cause some or all of the heap to not\n-#   have execute permission, i.e. it may be impossible to execute\n-#   code from the heap.  Currently this only affects the incremental\n-#   collector on UNIX machines.  It may greatly improve its performance,\n-#   since this may avoid some expensive cache synchronization.\n-# -DGC_NO_OPERATOR_NEW_ARRAY declares that the C++ compiler does not support\n-#   the  new syntax \"operator new[]\" for allocating and deleting arrays.\n-#   See gc_cpp.h for details.  No effect on the C part of the collector.\n-#   This is defined implicitly in a few environments.  Must also be defined\n-#   by clients that use gc_cpp.h.\n-# -DREDIRECT_MALLOC=X causes malloc to be defined as alias for X.\n-#   Unless the following macros are defined, realloc is also redirected\n-#   to GC_realloc, and free is redirected to GC_free.\n-#   Calloc and strdup are redefined in terms of the new malloc.  X should\n-#   be either GC_malloc or GC_malloc_uncollectable, or\n-#   GC_debug_malloc_replacement.  (The latter invokes GC_debug_malloc\n-#   with dummy source location information, but still results in\n-#   properly remembered call stacks on Linux/X86 and Solaris/SPARC.\n-#   It requires that the following two macros also be used.)\n-#   The former is occasionally useful for working around leaks in code\n-#   you don't want to (or can't) look at.  It may not work for\n-#   existing code, but it often does.  Neither works on all platforms,\n-#   since some ports use malloc or calloc to obtain system memory.\n-#   (Probably works for UNIX, and win32.)  If you build with DBG_HDRS_ALL,\n-#   you should only use GC_debug_malloc_replacement as a malloc\n-#   replacement.\n-# -DREDIRECT_REALLOC=X causes GC_realloc to be redirected to X.\n-#   The canonical use is -DREDIRECT_REALLOC=GC_debug_realloc_replacement,\n-#   together with -DREDIRECT_MALLOC=GC_debug_malloc_replacement to\n-#   generate leak reports with call stacks for both malloc and realloc.\n-#   This also requires the following:\n-# -DREDIRECT_FREE=X causes free to be redirected to X.  The\n-#   canonical use is -DREDIRECT_FREE=GC_debug_free.\n-# -DIGNORE_FREE turns calls to free into a noop.  Only useful with\n-#   -DREDIRECT_MALLOC.\n-# -DNO_DEBUGGING removes GC_dump and the debugging routines it calls.\n-#   Reduces code size slightly at the expense of debuggability.\n-# -DJAVA_FINALIZATION makes it somewhat safer to finalize objects out of\n-#   order by specifying a nonstandard finalization mark procedure  (see\n-#   finalize.c).  Objects reachable from finalizable objects will be marked\n-#   in a sepearte postpass, and hence their memory won't be reclaimed.\n-#   Not recommended unless you are implementing a language that specifies\n-#   these semantics.  Since 5.0, determines only only the initial value\n-#   of GC_java_finalization variable.\n-# -DFINALIZE_ON_DEMAND causes finalizers to be run only in response\n-#   to explicit GC_invoke_finalizers() calls.\n-#   In 5.0 this became runtime adjustable, and this only determines the\n-#   initial value of GC_finalize_on_demand.\n-# -DATOMIC_UNCOLLECTABLE includes code for GC_malloc_atomic_uncollectable.\n-#   This is useful if either the vendor malloc implementation is poor,\n-#   or if REDIRECT_MALLOC is used.\n-# -DHBLKSIZE=ddd, where ddd is a power of 2 between 512 and 16384, explicitly\n-#   sets the heap block size.  Each heap block is devoted to a single size and\n-#   kind of object.  For the incremental collector it makes sense to match\n-#   the most likely page size.  Otherwise large values result in more\n-#   fragmentation, but generally better performance for large heaps.\n-# -DUSE_MMAP use MMAP instead of sbrk to get new memory.\n-#   Works for Solaris and Irix.\n-# -DUSE_MUNMAP causes memory to be returned to the OS under the right\n-#   circumstances.  This currently disables VM-based incremental collection.\n-#   This is currently experimental, and works only under some Unix,\n-#   Linux and Windows versions.\n-# -DMMAP_STACKS (for Solaris threads) Use mmap from /dev/zero rather than\n-#   GC_scratch_alloc() to get stack memory.\n-# -DPRINT_BLACK_LIST Whenever a black list entry is added, i.e. whenever\n-#   the garbage collector detects a value that looks almost, but not quite,\n-#   like a pointer, print both the address containing the value, and the\n-#   value of the near-bogus-pointer.  Can be used to identifiy regions of\n-#   memory that are likely to contribute misidentified pointers.\n-# -DKEEP_BACK_PTRS Add code to save back pointers in debugging headers\n-#   for objects allocated with the debugging allocator.  If all objects\n-#   through GC_MALLOC with GC_DEBUG defined, this allows the client\n-#   to determine how particular or randomly chosen objects are reachable\n-#   for debugging/profiling purposes.  The gc_backptr.h interface is\n-#   implemented only if this is defined.\n-# -DGC_ASSERTIONS Enable some internal GC assertion checking.  Currently\n-#   this facility is only used in a few places.  It is intended primarily\n-#   for debugging of the garbage collector itself, but could also\n-# -DDBG_HDRS_ALL Make sure that all objects have debug headers.  Increases\n-#   the reliability (from 99.9999% to 100% mod. bugs) of some of the debugging\n-#   code (especially KEEP_BACK_PTRS).  Makes -DSHORT_DBG_HDRS possible.\n-#   Assumes that all client allocation is done through debugging\n-#   allocators.\n-# -DSHORT_DBG_HDRS Assume that all objects have debug headers.  Shorten\n-#   the headers to minimize object size, at the expense of checking for\n-#   writes past the end of an object.  This is intended for environments\n-#   in which most client code is written in a \"safe\" language, such as\n-#   Scheme or Java.  Assumes that all client allocation is done using\n-#   the GC_debug_ functions, or through the macros that expand to these,\n-#   or by redirecting malloc to GC_debug_malloc_replacement.\n-#   (Also eliminates the field for the requested object size.)\n-#   occasionally be useful for debugging of client code.  Slows down the\n-#   collector somewhat, but not drastically.\n-# -DSAVE_CALL_COUNT=<n> Set the number of call frames saved with objects\n-#   allocated through the debugging interface.  Affects the amount of\n-#   information generated in leak reports.  Only matters on platforms\n-#   on which we can quickly generate call stacks, currently Linux/(X86 & SPARC)\n-#   and Solaris/SPARC and platforms that provide execinfo.h.\n-#   Default is zero.  On X86, client\n-#   code should NOT be compiled with -fomit-frame-pointer.\n-# -DSAVE_CALL_NARGS=<n> Set the number of functions arguments to be\n-#   saved with each call frame.  Default is zero.  Ignored if we\n-#   don't know how to retrieve arguments on the platform.\n-# -DCHECKSUMS reports on erroneously clear dirty bits, and unexpectedly\n-#   altered stubborn objects, at substantial performance cost.\n-#   Use only for debugging of the incremental collector.\n-# -DGC_GCJ_SUPPORT includes support for gcj (and possibly other systems\n-#   that include a pointer to a type descriptor in each allocated object).\n-#   Building this way requires an ANSI C compiler.\n-# -DUSE_I686_PREFETCH causes the collector to issue Pentium III style\n-#   prefetch instructions.  No effect except on X86 Linux platforms.\n-#   Assumes a very recent gcc-compatible compiler and assembler.\n-#   (Gas prefetcht0 support was added around May 1999.)\n-#   Empirically the code appears to still run correctly on Pentium II\n-#   processors, though with no performance benefit.  May not run on other\n-#   X86 processors?  In some cases this improves performance by\n-#   15% or so.\n-# -DUSE_3DNOW_PREFETCH causes the collector to issue AMD 3DNow style\n-#   prefetch instructions.  Same restrictions as USE_I686_PREFETCH.\n-#   Minimally tested.  Didn't appear to be an obvious win on a K6-2/500.\n-# -DUSE_PPC_PREFETCH causes the collector to issue PowerPC style\n-#   prefetch instructions.  No effect except on PowerPC OS X platforms.\n-#   Performance impact untested.\n-# -DGC_USE_LD_WRAP in combination with the old flags listed in README.linux\n-#   causes the collector some system and pthread calls in a more transparent\n-#   fashion than the usual macro-based approach.  Requires GNU ld, and\n-#   currently probably works only with Linux.\n-# -DTHREAD_LOCAL_ALLOC defines GC_local_malloc(), GC_local_malloc_atomic()\n-#   and GC_local_gcj_malloc().  Needed for gc_gcj.h interface.  These allocate\n-#   in a way that usually does not involve acquisition of a global lock.\n-#   Currently works only on platforms such as Linux which use pthread_support.c.\n-#   Recommended for multiprocessors.\n-# -DUSE_COMPILER_TLS causes thread local allocation to use compiler-supported\n-#   \"__thread\" thread-local variables.  This is the default in HP/UX.  It\n-#   may help performance on recent Linux installations.  (It failed for\n-#   me on RedHat 8, but appears to work on RedHat 9.)\n-# -DPARALLEL_MARK allows the marker to run in multiple threads.  Recommended\n-#   for multiprocessors.  Currently requires Linux on X86 or IA64, though\n-#   support for other Posix platforms should be fairly easy to add,\n-#   if the thread implementation is otherwise supported.\n-# -DNO_GETENV prevents the collector from looking at environment variables.\n-#   These may otherwise alter its configuration, or turn off GC altogether.\n-#   I don't know of a reason to disable this, except possibly if the\n-#   resulting process runs as a privileged user?\n-# -DUSE_GLOBAL_ALLOC.  Win32 only.  Use GlobalAlloc instead of\n-#   VirtualAlloc to allocate the heap.  May be needed to work around\n-#   a Windows NT/2000 issue.  Incompatible with USE_MUNMAP.\n-#   See README.win32 for details.\n-# -DMAKE_BACK_GRAPH. Enable GC_PRINT_BACK_HEIGHT environment variable.\n-#   See README.environment for details.  Experimental. Limited platform\n-#   support.  Implies DBG_HDRS_ALL.  All allocation should be done using\n-#   the debug interface.\n-# -DSTUBBORN_ALLOC allows allocation of \"hard to change\" objects, and thus\n-#   makes incremental collection easier.  Was enabled by default until 6.0.\n-#   Rarely used, to my knowledge.\n-# -DHANDLE_FORK attempts to make GC_malloc() work in a child process fork()ed\n-#   from a multithreaded parent.  Currently only supported by pthread_support.c.\n-#   (Similar code should work on Solaris or Irix, but it hasn't been tried.)\n-# -DTEST_WITH_SYSTEM_MALLOC causes gctest to allocate (and leak) large chunks\n-#   of memory with the standard system malloc.  This will cause the root\n-#   set and collected heap to grow significantly if malloced memory is\n-#   somehow getting traced by the collector.  This has no impact on the\n-#   generated library; it only affects the test.\n-# -DPOINTER_MASK=0x... causes candidate pointers to be ANDed with the\n-#   given mask before being considered.  If either this or the following\n-#   macro is defined, it will be assumed that all pointers stored in\n-#   the heap need to be processed this way.  Stack and register pointers\n-#   will be considered both with and without processing.\n-#   These macros are normally needed only to support systems that use\n-#   high-order pointer tags. EXPERIMENTAL.\n-# -DPOINTER_SHIFT=n causes the collector to left shift candidate pointers\n-#   by the indicated amount before trying to interpret them.  Applied\n-#   after POINTER_MASK. EXPERIMENTAL.  See also the preceding macro.\n-# -DDARWIN_DONT_PARSE_STACK Causes the Darwin port to discover thread\n-#   stack bounds in the same way as other pthread ports, without trying to\n-#   walk the frames onthe stack.  This is recommended only as a fallback\n-#   for applications that don't support proper stack unwinding.\n-#\n-\n-CXXFLAGS= $(CFLAGS) \n-AR= ar\n-RANLIB= ranlib\n-\n-\n-OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o pthread_support.o pthread_stop_world.o darwin_stop_world.o typd_mlc.o ptr_chck.o mallocx.o solaris_pthreads.o gcj_mlc.o specific.o gc_dlopen.o backgraph.o win32_threads.o\n-\n-CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c pthread_support.c pthread_stop_world.c darwin_stop_world.c typd_mlc.c ptr_chck.c mallocx.c solaris_pthreads.c gcj_mlc.c specific.c gc_dlopen.c backgraph.c win32_threads.c\n-\n-CORD_SRCS=  cord/cordbscs.c cord/cordxtra.c cord/cordprnt.c cord/de.c cord/cordtest.c include/cord.h include/ec.h include/private/cord_pos.h cord/de_win.c cord/de_win.h cord/de_cmds.h cord/de_win.ICO cord/de_win.RC\n-\n-CORD_OBJS=  cord/cordbscs.o cord/cordxtra.o cord/cordprnt.o\n-\n-SRCS= $(CSRCS) mips_sgi_mach_dep.s rs6000_mach_dep.s alpha_mach_dep.S \\\n-    sparc_mach_dep.S include/gc.h include/gc_typed.h \\\n-    include/private/gc_hdrs.h include/private/gc_priv.h \\\n-    include/private/gcconfig.h include/private/gc_pmark.h \\\n-    include/gc_inl.h include/gc_inline.h include/gc_mark.h \\\n-    threadlibs.c if_mach.c if_not_there.c gc_cpp.cc include/gc_cpp.h \\\n-    gcname.c include/weakpointer.h include/private/gc_locks.h \\\n-    gcc_support.c mips_ultrix_mach_dep.s include/gc_alloc.h \\\n-    include/new_gc_alloc.h include/gc_allocator.h \\\n-    include/javaxfc.h sparc_sunos4_mach_dep.s sparc_netbsd_mach_dep.s \\\n-    include/private/solaris_threads.h include/gc_backptr.h \\\n-    hpux_test_and_clear.s include/gc_gcj.h \\\n-    include/gc_local_alloc.h include/private/dbg_mlc.h \\\n-    include/private/specific.h powerpc_darwin_mach_dep.s \\\n-    include/leak_detector.h include/gc_amiga_redirects.h \\\n-    include/gc_pthread_redirects.h ia64_save_regs_in_stack.s \\\n-    include/gc_config_macros.h include/private/pthread_support.h \\\n-    include/private/pthread_stop_world.h include/private/darwin_semaphore.h \\\n-    include/private/darwin_stop_world.h $(CORD_SRCS)\n-\n-DOC_FILES= README.QUICK doc/README.Mac doc/README.MacOSX doc/README.OS2 \\\n-\tdoc/README.amiga doc/README.cords doc/debugging.html \\\n-\tdoc/README.dj doc/README.hp doc/README.linux doc/README.rs6000 \\\n-\tdoc/README.sgi doc/README.solaris2 doc/README.uts \\\n-\tdoc/README.win32 doc/barrett_diagram doc/README \\\n-        doc/README.contributors doc/README.changes doc/gc.man \\\n-\tdoc/README.environment doc/tree.html doc/gcdescr.html \\\n-\tdoc/README.autoconf doc/README.macros doc/README.ews4800 \\\n-\tdoc/README.DGUX386 doc/README.arm.cross doc/leak.html \\\n-\tdoc/scale.html doc/gcinterface.html doc/README.darwin \\\n-\tdoc/simple_example.html\n-\n-TESTS= tests/test.c tests/test_cpp.cc tests/trace_test.c \\\n-\ttests/leak_test.c tests/thread_leak_test.c tests/middle.c\n-\n-GNU_BUILD_FILES= configure.ac Makefile.am configure acinclude.m4 \\\n-\t\t libtool.m4 install-sh configure.host Makefile.in \\\n-\t\t aclocal.m4 config.sub config.guess \\\n-\t\t include/Makefile.am include/Makefile.in \\\n-\t\t doc/Makefile.am doc/Makefile.in \\\n-\t\t ltmain.sh mkinstalldirs depcomp missing\n-\n-OTHER_MAKEFILES= OS2_MAKEFILE NT_MAKEFILE NT_THREADS_MAKEFILE gc.mak \\\n-\t\t BCC_MAKEFILE EMX_MAKEFILE WCC_MAKEFILE Makefile.dj \\\n-\t\t PCR-Makefile SMakefile.amiga Makefile.DLLs \\\n-\t\t digimars.mak Makefile.direct NT_STATIC_THREADS_MAKEFILE\n-#\tMakefile and Makefile.direct are copies of each other.\n-\n-OTHER_FILES= Makefile setjmp_t.c callprocs pc_excludes \\\n-           MacProjects.sit.hqx MacOS.c \\\n-           Mac_files/datastart.c Mac_files/dataend.c \\\n-           Mac_files/MacOS_config.h Mac_files/MacOS_Test_config.h \\\n-           add_gc_prefix.c gc_cpp.cpp \\\n-\t   version.h AmigaOS.c \\\n-\t   $(TESTS) $(GNU_BUILD_FILES) $(OTHER_MAKEFILES)\n-\n-CORD_INCLUDE_FILES= $(srcdir)/include/gc.h $(srcdir)/include/cord.h \\\n-\t$(srcdir)/include/ec.h $(srcdir)/include/private/cord_pos.h\n-\n-UTILS= if_mach if_not_there threadlibs\n-\n-# Libraries needed for curses applications.  Only needed for de.\n-CURSES= -lcurses -ltermlib\n-\n-# The following is irrelevant on most systems.  But a few\n-# versions of make otherwise fork the shell specified in\n-# the SHELL environment variable.\n-SHELL= /bin/sh\n-\n-SPECIALCFLAGS = -I$(srcdir)/include\n-# Alternative flags to the C compiler for mach_dep.c.\n-# Mach_dep.c often doesn't like optimization, and it's\n-# not time-critical anyway.\n-# Set SPECIALCFLAGS to -q nodirect_code on Encore.\n-\n-all: gc.a gctest\n-\n-LEAKFLAGS=$(CFLAGS) -DFIND_LEAK\n-\n-BSD-pkg-all: bsd-libgc.a bsd-libleak.a\n-\n-bsd-libgc.a:\n-\t$(MAKE) CFLAGS=\"$(CFLAGS)\" clean c++-t\n-\tmv gc.a bsd-libgc.a\n-\n-bsd-libleak.a:\n-\t$(MAKE) -f Makefile.direct CFLAGS=\"$(LEAKFLAGS)\" clean c++-nt\n-\tmv gc.a bsd-libleak.a\n-\n-BSD-pkg-install: BSD-pkg-all\n-\t${CP} bsd-libgc.a libgc.a\n-\t${INSTALL_DATA} libgc.a ${PREFIX}/lib\n-\t${INSTALL_DATA} gc.h gc_cpp.h ${PREFIX}/include\n-\t${INSTALL_MAN} doc/gc.man ${PREFIX}/man/man3/gc.3\n-\n-pcr: PCR-Makefile include/private/gc_private.h include/private/gc_hdrs.h \\\n-include/private/gc_locks.h include/gc.h include/private/gcconfig.h \\\n-mach_dep.o $(SRCS)\n-\t$(MAKE) -f PCR-Makefile depend\n-\t$(MAKE) -f PCR-Makefile\n-\n-$(OBJS) tests/test.o dyn_load.o dyn_load_sunos53.o: \\\n-    $(srcdir)/include/private/gc_priv.h \\\n-    $(srcdir)/include/private/gc_hdrs.h $(srcdir)/include/private/gc_locks.h \\\n-    $(srcdir)/include/gc.h $(srcdir)/include/gc_pthread_redirects.h \\\n-    $(srcdir)/include/private/gcconfig.h $(srcdir)/include/gc_typed.h \\\n-    $(srcdir)/include/gc_config_macros.h Makefile\n-# The dependency on Makefile is needed.  Changing\n-# options such as -DSILENT affects the size of GC_arrays,\n-# invalidating all .o files that rely on gc_priv.h\n-\n-mark.o typd_mlc.o finalize.o ptr_chck.o: $(srcdir)/include/gc_mark.h $(srcdir)/include/private/gc_pmark.h\n-\n-specific.o pthread_support.o: $(srcdir)/include/private/specific.h\n-\n-solaris_threads.o solaris_pthreads.o: $(srcdir)/include/private/solaris_threads.h\n-\n-dbg_mlc.o gcj_mlc.o: $(srcdir)/include/private/dbg_mlc.h\n-\n-tests/test.o: tests $(srcdir)/tests/test.c\n-\t$(CC) $(CFLAGS) -c $(srcdir)/tests/test.c\n-\tmv test.o tests/test.o\n-\n-tests:\n-\tmkdir tests\n-\n-base_lib gc.a: $(OBJS) dyn_load.o $(UTILS)\n-\techo > base_lib\n-\trm -f dont_ar_1\n-\t./if_mach SPARC SUNOS5 touch dont_ar_1\n-\t./if_mach SPARC SUNOS5 $(AR) rus gc.a $(OBJS) dyn_load.o\n-\t./if_mach M68K AMIGA touch dont_ar_1\n-\t./if_mach M68K AMIGA $(AR) -vrus gc.a $(OBJS) dyn_load.o\n-\t./if_not_there dont_ar_1 $(AR) ru gc.a $(OBJS) dyn_load.o\n-\t./if_not_there dont_ar_1 $(RANLIB) gc.a || cat /dev/null\n-#\tignore ranlib failure; that usually means it doesn't exist, and isn't needed\n-\n-cords: $(CORD_OBJS) cord/cordtest $(UTILS)\n-\trm -f dont_ar_3\n-\t./if_mach SPARC SUNOS5 touch dont_ar_3\n-\t./if_mach SPARC SUNOS5 $(AR) rus gc.a $(CORD_OBJS)\n-\t./if_mach M68K AMIGA touch dont_ar_3\n-\t./if_mach M68K AMIGA $(AR) -vrus gc.a $(CORD_OBJS)\n-\t./if_not_there dont_ar_3 $(AR) ru gc.a $(CORD_OBJS)\n-\t./if_not_there dont_ar_3 $(RANLIB) gc.a || cat /dev/null\n-\n-gc_cpp.o: $(srcdir)/gc_cpp.cc $(srcdir)/include/gc_cpp.h $(srcdir)/include/gc.h Makefile\n-\t$(CXX) -c $(CXXFLAGS) $(srcdir)/gc_cpp.cc\n-\n-test_cpp: $(srcdir)/tests/test_cpp.cc $(srcdir)/include/gc_cpp.h gc_cpp.o $(srcdir)/include/gc.h \\\n-base_lib $(UTILS)\n-\trm -f test_cpp\n-\t./if_mach HP_PA HPUX $(CXX) $(CXXFLAGS) -o test_cpp $(srcdir)/tests/test_cpp.cc gc_cpp.o gc.a -ldld `./threadlibs`\n-\t./if_not_there test_cpp $(CXX) $(CXXFLAGS) -o test_cpp $(srcdir)/tests/test_cpp.cc gc_cpp.o gc.a `./threadlibs`\n-\n-c++-t: c++\n-\t./test_cpp 1\n-\n-c++-nt: c++\n-\t@echo \"Use ./test_cpp 1 to test the leak library\"\n-\n-c++: gc_cpp.o $(srcdir)/include/gc_cpp.h test_cpp\n-\trm -f dont_ar_4\n-\t./if_mach SPARC SUNOS5 touch dont_ar_4\n-\t./if_mach SPARC SUNOS5 $(AR) rus gc.a gc_cpp.o\n-\t./if_mach M68K AMIGA touch dont_ar_4\n-\t./if_mach M68K AMIGA $(AR) -vrus gc.a gc_cpp.o\n-\t./if_not_there dont_ar_4 $(AR) ru gc.a gc_cpp.o\n-\t./if_not_there dont_ar_4 $(RANLIB) gc.a || cat /dev/null\n-\t./test_cpp 1\n-\techo > c++\n-\n-dyn_load_sunos53.o: dyn_load.c\n-\t$(CC) $(CFLAGS) -DSUNOS53_SHARED_LIB -c $(srcdir)/dyn_load.c -o $@\n-\n-# SunOS5 shared library version of the collector\n-sunos5gc.so: $(OBJS) dyn_load_sunos53.o\n-\t$(CC) -G -o sunos5gc.so $(OBJS) dyn_load_sunos53.o -ldl\n-\tln sunos5gc.so libgc.so\n-\n-# Alpha/OSF shared library version of the collector\n-libalphagc.so: $(OBJS)\n-\tld -shared -o libalphagc.so $(OBJS) dyn_load.o -lc\n-\tln libalphagc.so libgc.so\n-\n-# IRIX shared library version of the collector\n-libirixgc.so: $(OBJS) dyn_load.o\n-\tld -shared $(ABI_FLAG) -o libirixgc.so $(OBJS) dyn_load.o -lc\n-\tln libirixgc.so libgc.so\n-\n-# Linux shared library version of the collector\n-liblinuxgc.so: $(OBJS) dyn_load.o\n-\tgcc -shared -o liblinuxgc.so $(OBJS) dyn_load.o\n-\tln liblinuxgc.so libgc.so\n-\n-# Alternative Linux rule.  This is preferable, but is likely to break the\n-# Makefile for some non-linux platforms.\n-# LIBOBJS= $(patsubst %.o, %.lo, $(OBJS))\n-#\n-#.SUFFIXES: .lo $(SUFFIXES)\n-#\n-#.c.lo:\n-#\t$(CC) $(CFLAGS) $(CPPFLAGS) -fPIC -c $< -o $@\n-#\n-# liblinuxgc.so: $(LIBOBJS) dyn_load.lo\n-# \tgcc -shared -Wl,-soname=libgc.so.0 -o libgc.so.0 $(LIBOBJS) dyn_load.lo\n-#\ttouch liblinuxgc.so\n-\n-mach_dep.o: $(srcdir)/mach_dep.c $(srcdir)/mips_sgi_mach_dep.s \\\n-\t    $(srcdir)/mips_ultrix_mach_dep.s \\\n-            $(srcdir)/rs6000_mach_dep.s $(srcdir)/powerpc_darwin_mach_dep.s \\\n-\t    $(srcdir)/sparc_mach_dep.S $(srcdir)/sparc_sunos4_mach_dep.s \\\n-\t    $(srcdir)/ia64_save_regs_in_stack.s \\\n-\t    $(srcdir)/sparc_netbsd_mach_dep.s $(UTILS)\n-\trm -f mach_dep.o\n-\t./if_mach MIPS IRIX5 $(CC) -c -o mach_dep.o $(srcdir)/mips_sgi_mach_dep.s\n-\t./if_mach MIPS RISCOS $(AS) -o mach_dep.o $(srcdir)/mips_ultrix_mach_dep.s\n-\t./if_mach MIPS ULTRIX $(AS) -o mach_dep.o $(srcdir)/mips_ultrix_mach_dep.s\n-\t./if_mach POWERPC DARWIN $(AS) -o mach_dep.o $(srcdir)/powerpc_darwin_mach_dep.s\n-\t./if_mach ALPHA LINUX $(CC) -c -o mach_dep.o $(srcdir)/alpha_mach_dep.S\n-\t./if_mach SPARC SUNOS5 $(CC) -c -o mach_dep.o $(srcdir)/sparc_mach_dep.S\n-\t./if_mach SPARC SUNOS4 $(AS) -o mach_dep.o $(srcdir)/sparc_sunos4_mach_dep.s\n-\t./if_mach SPARC OPENBSD $(AS) -o mach_dep.o $(srcdir)/sparc_sunos4_mach_dep.s\n-\t./if_mach SPARC NETBSD $(AS) -o mach_dep.o $(srcdir)/sparc_netbsd_mach_dep.s\n-\t./if_mach IA64 \"\" as $(AS_ABI_FLAG) -o ia64_save_regs_in_stack.o $(srcdir)/ia64_save_regs_in_stack.s\n-\t./if_mach IA64 \"\" $(CC) -c -o mach_dep1.o $(SPECIALCFLAGS) $(srcdir)/mach_dep.c\n-\t./if_mach IA64 \"\" ld -r -o mach_dep.o mach_dep1.o ia64_save_regs_in_stack.o\n-\t./if_not_there mach_dep.o $(CC) -c $(SPECIALCFLAGS) $(srcdir)/mach_dep.c\n-\n-mark_rts.o: $(srcdir)/mark_rts.c $(UTILS)\n-\trm -f mark_rts.o\n-\t-./if_mach ALPHA OSF1 $(CC) -c $(CFLAGS) -Wo,-notail $(srcdir)/mark_rts.c\n-\t./if_not_there mark_rts.o $(CC) -c $(CFLAGS) $(srcdir)/mark_rts.c\n-#\tWork-around for DEC optimizer tail recursion elimination bug.\n-#  The ALPHA-specific line should be removed if gcc is used.\n-\n-alloc.o: version.h\n-\n-cord:\n-\tmkdir cord\n-\n-cord/cordbscs.o: cord $(srcdir)/cord/cordbscs.c $(CORD_INCLUDE_FILES)\n-\t$(CC) $(CFLAGS) -c -I$(srcdir) $(srcdir)/cord/cordbscs.c\n-\tmv cordbscs.o cord/cordbscs.o\n-#  not all compilers understand -o filename\n-\n-cord/cordxtra.o: cord $(srcdir)/cord/cordxtra.c $(CORD_INCLUDE_FILES)\n-\t$(CC) $(CFLAGS) -c -I$(srcdir) $(srcdir)/cord/cordxtra.c\n-\tmv cordxtra.o cord/cordxtra.o\n-\n-cord/cordprnt.o: cord $(srcdir)/cord/cordprnt.c $(CORD_INCLUDE_FILES)\n-\t$(CC) $(CFLAGS) -c -I$(srcdir) $(srcdir)/cord/cordprnt.c\n-\tmv cordprnt.o cord/cordprnt.o\n-\n-cord/cordtest: $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a $(UTILS)\n-\trm -f cord/cordtest\n-\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a -lucb\n-\t./if_mach HP_PA HPUX $(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a -ldld `./threadlibs`\n-\t./if_mach M68K AMIGA $(CC) $(CFLAGS) -UGC_AMIGA_MAKINGLIB -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a `./threadlibs`\n-\t./if_not_there cord/cordtest $(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a `./threadlibs`\n-\n-cord/de: $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(UTILS)\n-\trm -f cord/de\n-\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -lucb `./threadlibs`\n-\t./if_mach HP_PA HPUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -ldld `./threadlibs`\n-\t./if_mach RS6000 \"\" $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses\n-\t./if_mach POWERPC DARWIN $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a\n-\t./if_mach I386 LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses `./threadlibs`\n-\t./if_mach ALPHA LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses `./threadlibs`\n-\t./if_mach IA64 LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses `./threadlibs`\n-\t./if_mach M68K AMIGA $(CC) $(CFLAGS) -UGC_AMIGA_MAKINGLIB -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses\n-\t./if_not_there cord/de $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) `./threadlibs`\n-\n-if_mach: $(srcdir)/if_mach.c $(srcdir)/include/private/gcconfig.h\n-\t$(HOSTCC) $(HOSTCFLAGS) -o if_mach $(srcdir)/if_mach.c\n-\n-threadlibs: $(srcdir)/threadlibs.c $(srcdir)/include/private/gcconfig.h Makefile\n-\t$(HOSTCC) $(HOSTCFLAGS) -o threadlibs $(srcdir)/threadlibs.c\n-\n-if_not_there: $(srcdir)/if_not_there.c\n-\t$(HOSTCC) $(HOSTCFLAGS) -o if_not_there $(srcdir)/if_not_there.c\n-\n-clean: \n-\trm -f gc.a *.o *.exe tests/*.o gctest gctest_dyn_link test_cpp \\\n-\t      setjmp_test  mon.out gmon.out a.out core if_not_there if_mach \\\n-\t      threadlibs $(CORD_OBJS) cord/cordtest cord/de \n-\t-rm -f *~\n-\n-gctest: tests/test.o gc.a $(UTILS)\n-\trm -f gctest\n-\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o gctest  tests/test.o gc.a -lucb\n-\t./if_mach HP_PA HPUX $(CC) $(CFLAGS) -o gctest  tests/test.o gc.a -ldld `./threadlibs`\n-\t./if_mach M68K AMIGA $(CC) $(CFLAGS) -UGC_AMIGA_MAKINGLIB -o gctest  tests/test.o gc.a `./threadlibs`\n-\t./if_not_there gctest $(CC) $(CFLAGS) -o gctest tests/test.o gc.a `./threadlibs`\n-\n-# If an optimized setjmp_test generates a segmentation fault,\n-# odds are your compiler is broken.  Gctest may still work.\n-# Try compiling setjmp_t.c unoptimized.\n-setjmp_test: $(srcdir)/setjmp_t.c $(srcdir)/include/gc.h $(UTILS)\n-\t$(CC) $(CFLAGS) -o setjmp_test $(srcdir)/setjmp_t.c\n-\n-test:  KandRtest cord/cordtest\n-\tcord/cordtest\n-\n-# Those tests that work even with a K&R C compiler:\n-KandRtest: setjmp_test gctest\n-\t./setjmp_test\n-\t./gctest\n-\n-add_gc_prefix: $(srcdir)/add_gc_prefix.c $(srcdir)/version.h\n-\t$(CC) -o add_gc_prefix $(srcdir)/add_gc_prefix.c\n-\n-gcname: $(srcdir)/gcname.c $(srcdir)/version.h\n-\t$(CC) -o gcname $(srcdir)/gcname.c\n-\n-gc.tar: $(SRCS) $(DOC_FILES) $(OTHER_FILES) add_gc_prefix gcname\n-\tcp Makefile Makefile.old\n-\tcp Makefile.direct Makefile\n-\trm -f `./gcname`\n-\tln -s . `./gcname`\n-\t./add_gc_prefix $(SRCS) $(DOC_FILES) $(OTHER_FILES) > /tmp/gc.tar-files\n-\ttar cvfh gc.tar `cat /tmp/gc.tar-files`\n-\tcp gc.tar `./gcname`.tar\n-\tgzip `./gcname`.tar\n-\trm `./gcname`\n-\n-pc_gc.tar: $(SRCS) $(OTHER_FILES)\n-\ttar cvfX pc_gc.tar pc_excludes $(SRCS) $(OTHER_FILES)\n-\n-floppy: pc_gc.tar\n-\t-mmd a:/cord\n-\t-mmd a:/cord/private\n-\t-mmd a:/include\n-\t-mmd a:/include/private\n-\tmkdir /tmp/pc_gc\n-\tcat pc_gc.tar | (cd /tmp/pc_gc; tar xvf -)\n-\t-mcopy -tmn /tmp/pc_gc/* a:\n-\t-mcopy -tmn /tmp/pc_gc/cord/* a:/cord\n-\t-mcopy -mn /tmp/pc_gc/cord/de_win.ICO a:/cord\n-\t-mcopy -tmn /tmp/pc_gc/cord/private/* a:/cord/private\n-\t-mcopy -tmn /tmp/pc_gc/include/* a:/include\n-\t-mcopy -tmn /tmp/pc_gc/include/private/* a:/include/private\n-\trm -r /tmp/pc_gc\n-\n-gc.tar.Z: gc.tar\n-\tcompress gc.tar\n-\n-gc.tar.gz: gc.tar\n-\tgzip gc.tar\n-\n-lint: $(CSRCS) tests/test.c\n-\tlint -DLINT $(CSRCS) tests/test.c | egrep -v \"possible pointer alignment problem|abort|exit|sbrk|mprotect|syscall|change in ANSI|improper alignment\"\n-\n-# BTL: added to test shared library version of collector.\n-# Currently works only under SunOS5.  Requires GC_INIT call from statically\n-# loaded client code.\n-ABSDIR = `pwd`\n-gctest_dyn_link: tests/test.o libgc.so\n-\t$(CC) -L$(ABSDIR) -R$(ABSDIR) -o gctest_dyn_link tests/test.o -lgc -ldl -lthread\n-\n-gctest_irix_dyn_link: tests/test.o libirixgc.so\n-\t$(CC) -L$(ABSDIR) -o gctest_irix_dyn_link tests/test.o -lirixgc\n-\n-# The following appear to be dead, especially since libgc_globals.h\n-# is apparently lost.\n-test_dll.o: tests/test.c libgc_globals.h\n-\t$(CC) $(CFLAGS) -DGC_USE_DLL -c tests/test.c -o test_dll.o\n-\n-test_dll: test_dll.o libgc_dll.a libgc.dll\n-\t$(CC) test_dll.o -L$(ABSDIR) -lgc_dll -o test_dll\n-\n-SYM_PREFIX-libgc=GC\n-\n-# Uncomment the following line to build a GNU win32 DLL\n-# include Makefile.DLLs\n-\n-reserved_namespace: $(SRCS)\n-\tfor file in $(SRCS) tests/test.c tests/test_cpp.cc; do \\\n-\t\tsed s/GC_/_GC_/g < $$file > tmp; \\\n-\t\tcp tmp $$file; \\\n-\t\tdone\n-\n-user_namespace: $(SRCS)\n-\tfor file in $(SRCS) tests/test.c tests/test_cpp.cc; do \\\n-\t\tsed s/_GC_/GC_/g < $$file > tmp; \\\n-\t\tcp tmp $$file; \\\n-\t\tdone"}, {"sha": "7105f9353d42f4639e862f12c283ed348e775951", "filename": "boehm-gc/Makefile.dist", "status": "removed", "additions": 0, "deletions": 680, "changes": 680, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMakefile.dist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMakefile.dist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.dist?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,680 +0,0 @@\n-# This is the original manually generated Makefile.  It may still be used\n-# to build the collector.\n-#\n-# Primary targets:\n-# gc.a - builds basic library\n-# c++ - adds C++ interface to library\n-# cords - adds cords (heavyweight strings) to library\n-# test - prints porting information, then builds basic version of gc.a,\n-#      \t and runs some tests of collector and cords.  Does not add cords or\n-#\t c++ interface to gc.a\n-# cord/de - builds dumb editor based on cords.\n-ABI_FLAG= \n-# ABI_FLAG should be the cc flag that specifies the ABI.  On most\n-# platforms this will be the empty string.  Possible values:\n-# +DD64 for 64-bit executable on HP/UX.\n-# -n32, -n64, -o32 for SGI/MIPS ABIs.\n-\n-AS_ABI_FLAG=$(ABI_FLAG)\n-# ABI flag for assembler.  On HP/UX this is +A64 for 64 bit\n-# executables.\n-\n-CC=cc $(ABI_FLAG)\n-CXX=g++ $(ABI_FLAG)\n-AS=as $(AS_ABI_FLAG)\n-#  The above doesn't work with gas, which doesn't run cpp.\n-#  Define AS as `gcc -c -x assembler-with-cpp' instead.\n-\n-# Redefining srcdir allows object code for the nonPCR version of the collector\n-# to be generated in different directories.\n-srcdir= .\n-VPATH= $(srcdir)\n-\n-CFLAGS= -O -I$(srcdir)/include -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DNO_EXECUTE_PERMISSION -DSILENT -DALL_INTERIOR_POINTERS\n-\n-# To build the parallel collector on Linux, add to the above:\n-# -DGC_LINUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC\n-# To build the parallel collector in a static library on HP/UX,\n-# add to the above:\n-# -DGC_HPUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC -D_POSIX_C_SOURCE=199506L\n-# To build the thread-safe collector on Tru64, add to the above:\n-# -pthread -DGC_OSF1_THREADS\n-\n-# HOSTCC and HOSTCFLAGS are used to build executables that will be run as\n-# part of the build process, i.e. on the build machine.  These will usually\n-# be the same as CC and CFLAGS, except in a cross-compilation environment.\n-# Note that HOSTCFLAGS should include any -D flags that affect thread support.\n-HOSTCC=$(CC)\n-HOSTCFLAGS=$(CFLAGS)\n-\n-# For dynamic library builds, it may be necessary to add flags to generate\n-# PIC code, e.g. -fPIC on Linux.\n-\n-# Setjmp_test may yield overly optimistic results when compiled\n-# without optimization.\n-\n-# These define arguments influence the collector configuration:\n-# -DSILENT disables statistics printing, and improves performance.\n-# -DFIND_LEAK causes GC_find_leak to be initially set.\n-#   This causes the collector to assume that all inaccessible\n-#   objects should have been explicitly deallocated, and reports exceptions.\n-#   Finalization and the test program are not usable in this mode.\n-# -DGC_SOLARIS_THREADS enables support for Solaris (thr_) threads.\n-#   (Clients should also define GC_SOLARIS_THREADS and then include\n-#   gc.h before performing thr_ or dl* or GC_ operations.)\n-#   Must also define -D_REENTRANT.\n-# -DGC_SOLARIS_PTHREADS enables support for Solaris pthreads.\n-#   (Internally this define GC_SOLARIS_THREADS as well.)\n-# -DGC_IRIX_THREADS enables support for Irix pthreads.  See README.irix.\n-# -DGC_HPUX_THREADS enables support for HP/UX 11 pthreads.\n-#   Also requires -D_REENTRANT or -D_POSIX_C_SOURCE=199506L. See README.hp.\n-# -DGC_LINUX_THREADS enables support for Xavier Leroy's Linux threads.\n-#   see README.linux.  -D_REENTRANT may also be required.\n-# -DGC_OSF1_THREADS enables support for Tru64 pthreads.  Untested.\n-# -DGC_FREEBSD_THREADS enables support for FreeBSD pthreads.  Untested.\n-#   Appeared to run into some underlying thread problems.\n-# -DGC_DARWIN_THREADS enables support for Mac OS X pthreads.  Untested.\n-# -DGC_DGUX386_THREADS enables support for DB/UX on I386 threads.\n-#   See README.DGUX386.\n-# -DGC_WIN32_THREADS enables support for win32 threads.  That makes sense\n-#   for this Makefile only under Cygwin.\n-# -DGC_THREADS should set the appropriate one of the above macros.\n-#   It assumes pthreads for Solaris.\n-# -DALL_INTERIOR_POINTERS allows all pointers to the interior\n-#   of objects to be recognized.  (See gc_priv.h for consequences.)\n-#   Alternatively, GC_all_interior_pointers can be set at process\n-#   initialization time.\n-# -DSMALL_CONFIG tries to tune the collector for small heap sizes,\n-#   usually causing it to use less space in such situations.\n-#   Incremental collection no longer works in this case.\n-# -DLARGE_CONFIG tunes the collector for unusually large heaps.\n-#   Necessary for heaps larger than about 500 MB on most machines.\n-#   Recommended for heaps larger than about 64 MB.\n-# -DDONT_ADD_BYTE_AT_END is meaningful only with -DALL_INTERIOR_POINTERS or\n-#   GC_all_interior_pointers = 1.  Normally -DALL_INTERIOR_POINTERS\n-#   causes all objects to be padded so that pointers just past the end of\n-#   an object can be recognized.  This can be expensive.  (The padding\n-#   is normally more than one byte due to alignment constraints.)\n-#   -DDONT_ADD_BYTE_AT_END disables the padding.\n-# -DNO_SIGNALS does not disable signals during critical parts of\n-#   the GC process.  This is no less correct than many malloc \n-#   implementations, and it sometimes has a significant performance\n-#   impact.  However, it is dangerous for many not-quite-ANSI C\n-#   programs that call things like printf in asynchronous signal handlers.\n-#   This is on by default.  Turning it off has not been extensively tested with\n-#   compilers that reorder stores.  It should have been.\n-# -DNO_EXECUTE_PERMISSION may cause some or all of the heap to not\n-#   have execute permission, i.e. it may be impossible to execute\n-#   code from the heap.  Currently this only affects the incremental\n-#   collector on UNIX machines.  It may greatly improve its performance,\n-#   since this may avoid some expensive cache synchronization.\n-# -DGC_NO_OPERATOR_NEW_ARRAY declares that the C++ compiler does not support\n-#   the  new syntax \"operator new[]\" for allocating and deleting arrays.\n-#   See gc_cpp.h for details.  No effect on the C part of the collector.\n-#   This is defined implicitly in a few environments.  Must also be defined\n-#   by clients that use gc_cpp.h.\n-# -DREDIRECT_MALLOC=X causes malloc to be defined as alias for X.\n-#   Unless the following macros are defined, realloc is also redirected\n-#   to GC_realloc, and free is redirected to GC_free.\n-#   Calloc and strdup are redefined in terms of the new malloc.  X should\n-#   be either GC_malloc or GC_malloc_uncollectable, or\n-#   GC_debug_malloc_replacement.  (The latter invokes GC_debug_malloc\n-#   with dummy source location information, but still results in\n-#   properly remembered call stacks on Linux/X86 and Solaris/SPARC.\n-#   It requires that the following two macros also be used.)\n-#   The former is occasionally useful for working around leaks in code\n-#   you don't want to (or can't) look at.  It may not work for\n-#   existing code, but it often does.  Neither works on all platforms,\n-#   since some ports use malloc or calloc to obtain system memory.\n-#   (Probably works for UNIX, and win32.)  If you build with DBG_HDRS_ALL,\n-#   you should only use GC_debug_malloc_replacement as a malloc\n-#   replacement.\n-# -DREDIRECT_REALLOC=X causes GC_realloc to be redirected to X.\n-#   The canonical use is -DREDIRECT_REALLOC=GC_debug_realloc_replacement,\n-#   together with -DREDIRECT_MALLOC=GC_debug_malloc_replacement to\n-#   generate leak reports with call stacks for both malloc and realloc.\n-#   This also requires the following:\n-# -DREDIRECT_FREE=X causes free to be redirected to X.  The\n-#   canonical use is -DREDIRECT_FREE=GC_debug_free.\n-# -DIGNORE_FREE turns calls to free into a noop.  Only useful with\n-#   -DREDIRECT_MALLOC.\n-# -DNO_DEBUGGING removes GC_dump and the debugging routines it calls.\n-#   Reduces code size slightly at the expense of debuggability.\n-# -DJAVA_FINALIZATION makes it somewhat safer to finalize objects out of\n-#   order by specifying a nonstandard finalization mark procedure  (see\n-#   finalize.c).  Objects reachable from finalizable objects will be marked\n-#   in a sepearte postpass, and hence their memory won't be reclaimed.\n-#   Not recommended unless you are implementing a language that specifies\n-#   these semantics.  Since 5.0, determines only only the initial value\n-#   of GC_java_finalization variable.\n-# -DFINALIZE_ON_DEMAND causes finalizers to be run only in response\n-#   to explicit GC_invoke_finalizers() calls.\n-#   In 5.0 this became runtime adjustable, and this only determines the\n-#   initial value of GC_finalize_on_demand.\n-# -DATOMIC_UNCOLLECTABLE includes code for GC_malloc_atomic_uncollectable.\n-#   This is useful if either the vendor malloc implementation is poor,\n-#   or if REDIRECT_MALLOC is used.\n-# -DHBLKSIZE=ddd, where ddd is a power of 2 between 512 and 16384, explicitly\n-#   sets the heap block size.  Each heap block is devoted to a single size and\n-#   kind of object.  For the incremental collector it makes sense to match\n-#   the most likely page size.  Otherwise large values result in more\n-#   fragmentation, but generally better performance for large heaps.\n-# -DUSE_MMAP use MMAP instead of sbrk to get new memory.\n-#   Works for Solaris and Irix.\n-# -DUSE_MUNMAP causes memory to be returned to the OS under the right\n-#   circumstances.  This currently disables VM-based incremental collection.\n-#   This is currently experimental, and works only under some Unix,\n-#   Linux and Windows versions.\n-# -DMMAP_STACKS (for Solaris threads) Use mmap from /dev/zero rather than\n-#   GC_scratch_alloc() to get stack memory.\n-# -DPRINT_BLACK_LIST Whenever a black list entry is added, i.e. whenever\n-#   the garbage collector detects a value that looks almost, but not quite,\n-#   like a pointer, print both the address containing the value, and the\n-#   value of the near-bogus-pointer.  Can be used to identifiy regions of\n-#   memory that are likely to contribute misidentified pointers.\n-# -DKEEP_BACK_PTRS Add code to save back pointers in debugging headers\n-#   for objects allocated with the debugging allocator.  If all objects\n-#   through GC_MALLOC with GC_DEBUG defined, this allows the client\n-#   to determine how particular or randomly chosen objects are reachable\n-#   for debugging/profiling purposes.  The gc_backptr.h interface is\n-#   implemented only if this is defined.\n-# -DGC_ASSERTIONS Enable some internal GC assertion checking.  Currently\n-#   this facility is only used in a few places.  It is intended primarily\n-#   for debugging of the garbage collector itself, but could also\n-# -DDBG_HDRS_ALL Make sure that all objects have debug headers.  Increases\n-#   the reliability (from 99.9999% to 100% mod. bugs) of some of the debugging\n-#   code (especially KEEP_BACK_PTRS).  Makes -DSHORT_DBG_HDRS possible.\n-#   Assumes that all client allocation is done through debugging\n-#   allocators.\n-# -DSHORT_DBG_HDRS Assume that all objects have debug headers.  Shorten\n-#   the headers to minimize object size, at the expense of checking for\n-#   writes past the end of an object.  This is intended for environments\n-#   in which most client code is written in a \"safe\" language, such as\n-#   Scheme or Java.  Assumes that all client allocation is done using\n-#   the GC_debug_ functions, or through the macros that expand to these,\n-#   or by redirecting malloc to GC_debug_malloc_replacement.\n-#   (Also eliminates the field for the requested object size.)\n-#   occasionally be useful for debugging of client code.  Slows down the\n-#   collector somewhat, but not drastically.\n-# -DSAVE_CALL_COUNT=<n> Set the number of call frames saved with objects\n-#   allocated through the debugging interface.  Affects the amount of\n-#   information generated in leak reports.  Only matters on platforms\n-#   on which we can quickly generate call stacks, currently Linux/(X86 & SPARC)\n-#   and Solaris/SPARC and platforms that provide execinfo.h.\n-#   Default is zero.  On X86, client\n-#   code should NOT be compiled with -fomit-frame-pointer.\n-# -DSAVE_CALL_NARGS=<n> Set the number of functions arguments to be\n-#   saved with each call frame.  Default is zero.  Ignored if we\n-#   don't know how to retrieve arguments on the platform.\n-# -DCHECKSUMS reports on erroneously clear dirty bits, and unexpectedly\n-#   altered stubborn objects, at substantial performance cost.\n-#   Use only for debugging of the incremental collector.\n-# -DGC_GCJ_SUPPORT includes support for gcj (and possibly other systems\n-#   that include a pointer to a type descriptor in each allocated object).\n-#   Building this way requires an ANSI C compiler.\n-# -DUSE_I686_PREFETCH causes the collector to issue Pentium III style\n-#   prefetch instructions.  No effect except on X86 Linux platforms.\n-#   Assumes a very recent gcc-compatible compiler and assembler.\n-#   (Gas prefetcht0 support was added around May 1999.)\n-#   Empirically the code appears to still run correctly on Pentium II\n-#   processors, though with no performance benefit.  May not run on other\n-#   X86 processors?  In some cases this improves performance by\n-#   15% or so.\n-# -DUSE_3DNOW_PREFETCH causes the collector to issue AMD 3DNow style\n-#   prefetch instructions.  Same restrictions as USE_I686_PREFETCH.\n-#   Minimally tested.  Didn't appear to be an obvious win on a K6-2/500.\n-# -DUSE_PPC_PREFETCH causes the collector to issue PowerPC style\n-#   prefetch instructions.  No effect except on PowerPC OS X platforms.\n-#   Performance impact untested.\n-# -DGC_USE_LD_WRAP in combination with the old flags listed in README.linux\n-#   causes the collector some system and pthread calls in a more transparent\n-#   fashion than the usual macro-based approach.  Requires GNU ld, and\n-#   currently probably works only with Linux.\n-# -DTHREAD_LOCAL_ALLOC defines GC_local_malloc(), GC_local_malloc_atomic()\n-#   and GC_local_gcj_malloc().  Needed for gc_gcj.h interface.  These allocate\n-#   in a way that usually does not involve acquisition of a global lock.\n-#   Currently requires -DGC_LINUX_THREADS, but should be easy to port to\n-#   other pthreads environments.  Recommended for multiprocessors.\n-# -DUSE_COMPILER_TLS causes thread local allocation to use compiler-supported\n-#   \"__thread\" thread-local variables.  This is the default in HP/UX.  It\n-#   may help performance on recent Linux installations.  (It failed for\n-#   me on RedHat 8, but appears to work on RedHat 9.)\n-# -DPARALLEL_MARK allows the marker to run in multiple threads.  Recommended\n-#   for multiprocessors.  Currently requires Linux on X86 or IA64, though\n-#   support for other Posix platforms should be fairly easy to add,\n-#   if the thread implementation is otherwise supported.\n-# -DNO_GETENV prevents the collector from looking at environment variables.\n-#   These may otherwise alter its configuration, or turn off GC altogether.\n-#   I don't know of a reason to disable this, except possibly if the\n-#   resulting process runs as a privileged user?\n-# -DUSE_GLOBAL_ALLOC.  Win32 only.  Use GlobalAlloc instead of\n-#   VirtualAlloc to allocate the heap.  May be needed to work around\n-#   a Windows NT/2000 issue.  Incompatible with USE_MUNMAP.\n-#   See README.win32 for details.\n-# -DMAKE_BACK_GRAPH. Enable GC_PRINT_BACK_HEIGHT environment variable.\n-#   See README.environment for details.  Experimental. Limited platform\n-#   support.  Implies DBG_HDRS_ALL.  All allocation should be done using\n-#   the debug interface.\n-# -DSTUBBORN_ALLOC allows allocation of \"hard to change\" objects, and thus\n-#   makes incremental collection easier.  Was enabled by default until 6.0.\n-#   Rarely used, to my knowledge.\n-# -DHANDLE_FORK attempts to make GC_malloc() work in a child process fork()ed\n-#   from a multithreaded parent.  Currently only supported by pthread_support.c.\n-#   (Similar code should work on Solaris or Irix, but it hasn't been tried.)\n-# -DTEST_WITH_SYSTEM_MALLOC causes gctest to allocate (and leak) large chunks\n-#   of memory with the standard system malloc.  This will cause the root\n-#   set and collected heap to grow significantly if malloced memory is\n-#   somehow getting traced by the collector.  This has no impact on the\n-#   generated library; it only affects the test.\n-# -DPOINTER_MASK=0x... causes candidate pointers to be ANDed with the\n-#   given mask before being considered.  If either this or the following\n-#   macro is defined, it will be assumed that all pointers stored in\n-#   the heap need to be processed this way.  Stack and register pointers\n-#   will be considered both with and without processing.\n-#   These macros are normally needed only to support systems that use\n-#   high-order pointer tags. EXPERIMENTAL.\n-# -DPOINTER_SHIFT=n causes the collector to left shift candidate pointers\n-#   by the indicated amount before trying to interpret them.  Applied\n-#   after POINTER_MASK. EXPERIMENTAL.  See also the preceding macro.\n-#\n-\n-CXXFLAGS= $(CFLAGS) \n-AR= ar\n-RANLIB= ranlib\n-\n-\n-OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o aix_irix_threads.o pthread_support.o pthread_stop_world.o darwin_stop_world.o typd_mlc.o ptr_chck.o mallocx.o solaris_pthreads.o gcj_mlc.o specific.o gc_dlopen.o backgraph.o win32_threads.o\n-\n-CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c aix_irix_threads.c pthread_support.c pthread_stop_world.c darwin_stop_world.c typd_mlc.c ptr_chck.c mallocx.c solaris_pthreads.c gcj_mlc.c specific.c gc_dlopen.c backgraph.c win32_threads.c\n-\n-CORD_SRCS=  cord/cordbscs.c cord/cordxtra.c cord/cordprnt.c cord/de.c cord/cordtest.c include/cord.h include/ec.h include/private/cord_pos.h cord/de_win.c cord/de_win.h cord/de_cmds.h cord/de_win.ICO cord/de_win.RC\n-\n-CORD_OBJS=  cord/cordbscs.o cord/cordxtra.o cord/cordprnt.o\n-\n-SRCS= $(CSRCS) mips_sgi_mach_dep.s rs6000_mach_dep.s alpha_mach_dep.S \\\n-    sparc_mach_dep.S include/gc.h include/gc_typed.h \\\n-    include/private/gc_hdrs.h include/private/gc_priv.h \\\n-    include/private/gcconfig.h include/private/gc_pmark.h \\\n-    include/gc_inl.h include/gc_inline.h include/gc_mark.h \\\n-    threadlibs.c if_mach.c if_not_there.c gc_cpp.cc include/gc_cpp.h \\\n-    gcname.c include/weakpointer.h include/private/gc_locks.h \\\n-    gcc_support.c mips_ultrix_mach_dep.s include/gc_alloc.h \\\n-    include/new_gc_alloc.h include/gc_allocator.h \\\n-    include/javaxfc.h sparc_sunos4_mach_dep.s sparc_netbsd_mach_dep.s \\\n-    include/private/solaris_threads.h include/gc_backptr.h \\\n-    hpux_test_and_clear.s include/gc_gcj.h \\\n-    include/gc_local_alloc.h include/private/dbg_mlc.h \\\n-    include/private/specific.h powerpc_darwin_mach_dep.s \\\n-    include/leak_detector.h include/gc_amiga_redirects.h \\\n-    include/gc_pthread_redirects.h ia64_save_regs_in_stack.s \\\n-    include/gc_config_macros.h include/private/pthread_support.h \\\n-    include/private/pthread_stop_world.h include/private/darwin_semaphore.h \\\n-    include/private/darwin_stop_world.h $(CORD_SRCS)\n-\n-DOC_FILES= README.QUICK doc/README.Mac doc/README.MacOSX doc/README.OS2 \\\n-\tdoc/README.amiga doc/README.cords doc/debugging.html \\\n-\tdoc/README.dj doc/README.hp doc/README.linux doc/README.rs6000 \\\n-\tdoc/README.sgi doc/README.solaris2 doc/README.uts \\\n-\tdoc/README.win32 doc/barrett_diagram doc/README \\\n-        doc/README.contributors doc/README.changes doc/gc.man \\\n-\tdoc/README.environment doc/tree.html doc/gcdescr.html \\\n-\tdoc/README.autoconf doc/README.macros doc/README.ews4800 \\\n-\tdoc/README.DGUX386 doc/README.arm.cross doc/leak.html \\\n-\tdoc/scale.html doc/gcinterface.html doc/README.darwin \\\n-\tdoc/simple_example.html\n-\n-TESTS= tests/test.c tests/test_cpp.cc tests/trace_test.c \\\n-\ttests/leak_test.c tests/thread_leak_test.c tests/middle.c\n-\n-GNU_BUILD_FILES= configure.ac Makefile.am configure acinclude.m4 \\\n-\t\t libtool.m4 install-sh configure.host Makefile.in \\\n-\t\t aclocal.m4 config.sub config.guess \\\n-\t\t include/Makefile.am include/Makefile.in \\\n-\t\t doc/Makefile.am doc/Makefile.in \\\n-\t\t ltmain.sh mkinstalldirs depcomp missing\n-\n-OTHER_MAKEFILES= OS2_MAKEFILE NT_MAKEFILE NT_THREADS_MAKEFILE gc.mak \\\n-\t\t BCC_MAKEFILE EMX_MAKEFILE WCC_MAKEFILE Makefile.dj \\\n-\t\t PCR-Makefile SMakefile.amiga Makefile.DLLs \\\n-\t\t digimars.mak Makefile.direct NT_STATIC_THREADS_MAKEFILE\n-#\tMakefile and Makefile.direct are copies of each other.\n-\n-OTHER_FILES= Makefile setjmp_t.c callprocs pc_excludes \\\n-           MacProjects.sit.hqx MacOS.c \\\n-           Mac_files/datastart.c Mac_files/dataend.c \\\n-           Mac_files/MacOS_config.h Mac_files/MacOS_Test_config.h \\\n-           add_gc_prefix.c gc_cpp.cpp \\\n-\t   version.h AmigaOS.c \\\n-\t   $(TESTS) $(GNU_BUILD_FILES) $(OTHER_MAKEFILES)\n-\n-CORD_INCLUDE_FILES= $(srcdir)/include/gc.h $(srcdir)/include/cord.h \\\n-\t$(srcdir)/include/ec.h $(srcdir)/include/private/cord_pos.h\n-\n-UTILS= if_mach if_not_there threadlibs\n-\n-# Libraries needed for curses applications.  Only needed for de.\n-CURSES= -lcurses -ltermlib\n-\n-# The following is irrelevant on most systems.  But a few\n-# versions of make otherwise fork the shell specified in\n-# the SHELL environment variable.\n-SHELL= /bin/sh\n-\n-SPECIALCFLAGS = -I$(srcdir)/include\n-# Alternative flags to the C compiler for mach_dep.c.\n-# Mach_dep.c often doesn't like optimization, and it's\n-# not time-critical anyway.\n-# Set SPECIALCFLAGS to -q nodirect_code on Encore.\n-\n-all: gc.a gctest\n-\n-LEAKFLAGS=$(CFLAGS) -DFIND_LEAK\n-\n-BSD-pkg-all: bsd-libgc.a bsd-libleak.a\n-\n-bsd-libgc.a:\n-\t$(MAKE) CFLAGS=\"$(CFLAGS)\" clean c++-t\n-\tmv gc.a bsd-libgc.a\n-\n-bsd-libleak.a:\n-\t$(MAKE) -f Makefile.direct CFLAGS=\"$(LEAKFLAGS)\" clean c++-nt\n-\tmv gc.a bsd-libleak.a\n-\n-BSD-pkg-install: BSD-pkg-all\n-\t${CP} bsd-libgc.a libgc.a\n-\t${INSTALL_DATA} libgc.a ${PREFIX}/lib\n-\t${INSTALL_DATA} gc.h gc_cpp.h ${PREFIX}/include\n-\t${INSTALL_MAN} doc/gc.man ${PREFIX}/man/man3/gc.3\n-\n-pcr: PCR-Makefile include/private/gc_private.h include/private/gc_hdrs.h \\\n-include/private/gc_locks.h include/gc.h include/private/gcconfig.h \\\n-mach_dep.o $(SRCS)\n-\t$(MAKE) -f PCR-Makefile depend\n-\t$(MAKE) -f PCR-Makefile\n-\n-$(OBJS) tests/test.o dyn_load.o dyn_load_sunos53.o: \\\n-    $(srcdir)/include/private/gc_priv.h \\\n-    $(srcdir)/include/private/gc_hdrs.h $(srcdir)/include/private/gc_locks.h \\\n-    $(srcdir)/include/gc.h $(srcdir)/include/gc_pthread_redirects.h \\\n-    $(srcdir)/include/private/gcconfig.h $(srcdir)/include/gc_typed.h \\\n-    $(srcdir)/include/gc_config_macros.h Makefile\n-# The dependency on Makefile is needed.  Changing\n-# options such as -DSILENT affects the size of GC_arrays,\n-# invalidating all .o files that rely on gc_priv.h\n-\n-mark.o typd_mlc.o finalize.o ptr_chck.o: $(srcdir)/include/gc_mark.h $(srcdir)/include/private/gc_pmark.h\n-\n-specific.o pthread_support.o: $(srcdir)/include/private/specific.h\n-\n-solaris_threads.o solaris_pthreads.o: $(srcdir)/include/private/solaris_threads.h\n-\n-dbg_mlc.o gcj_mlc.o: $(srcdir)/include/private/dbg_mlc.h\n-\n-tests/test.o: tests $(srcdir)/tests/test.c\n-\t$(CC) $(CFLAGS) -c $(srcdir)/tests/test.c\n-\tmv test.o tests/test.o\n-\n-tests:\n-\tmkdir tests\n-\n-base_lib gc.a: $(OBJS) dyn_load.o $(UTILS)\n-\techo > base_lib\n-\trm -f dont_ar_1\n-\t./if_mach SPARC SUNOS5 touch dont_ar_1\n-\t./if_mach SPARC SUNOS5 $(AR) rus gc.a $(OBJS) dyn_load.o\n-\t./if_mach M68K AMIGA touch dont_ar_1\n-\t./if_mach M68K AMIGA $(AR) -vrus gc.a $(OBJS) dyn_load.o\n-\t./if_not_there dont_ar_1 $(AR) ru gc.a $(OBJS) dyn_load.o\n-\t./if_not_there dont_ar_1 $(RANLIB) gc.a || cat /dev/null\n-#\tignore ranlib failure; that usually means it doesn't exist, and isn't needed\n-\n-cords: $(CORD_OBJS) cord/cordtest $(UTILS)\n-\trm -f dont_ar_3\n-\t./if_mach SPARC SUNOS5 touch dont_ar_3\n-\t./if_mach SPARC SUNOS5 $(AR) rus gc.a $(CORD_OBJS)\n-\t./if_mach M68K AMIGA touch dont_ar_3\n-\t./if_mach M68K AMIGA $(AR) -vrus gc.a $(CORD_OBJS)\n-\t./if_not_there dont_ar_3 $(AR) ru gc.a $(CORD_OBJS)\n-\t./if_not_there dont_ar_3 $(RANLIB) gc.a || cat /dev/null\n-\n-gc_cpp.o: $(srcdir)/gc_cpp.cc $(srcdir)/include/gc_cpp.h $(srcdir)/include/gc.h Makefile\n-\t$(CXX) -c $(CXXFLAGS) $(srcdir)/gc_cpp.cc\n-\n-test_cpp: $(srcdir)/tests/test_cpp.cc $(srcdir)/include/gc_cpp.h gc_cpp.o $(srcdir)/include/gc.h \\\n-base_lib $(UTILS)\n-\trm -f test_cpp\n-\t./if_mach HP_PA HPUX $(CXX) $(CXXFLAGS) -o test_cpp $(srcdir)/tests/test_cpp.cc gc_cpp.o gc.a -ldld `./threadlibs`\n-\t./if_not_there test_cpp $(CXX) $(CXXFLAGS) -o test_cpp $(srcdir)/tests/test_cpp.cc gc_cpp.o gc.a `./threadlibs`\n-\n-c++-t: c++\n-\t./test_cpp 1\n-\n-c++-nt: c++\n-\t@echo \"Use ./test_cpp 1 to test the leak library\"\n-\n-c++: gc_cpp.o $(srcdir)/include/gc_cpp.h test_cpp\n-\trm -f dont_ar_4\n-\t./if_mach SPARC SUNOS5 touch dont_ar_4\n-\t./if_mach SPARC SUNOS5 $(AR) rus gc.a gc_cpp.o\n-\t./if_mach M68K AMIGA touch dont_ar_4\n-\t./if_mach M68K AMIGA $(AR) -vrus gc.a gc_cpp.o\n-\t./if_not_there dont_ar_4 $(AR) ru gc.a gc_cpp.o\n-\t./if_not_there dont_ar_4 $(RANLIB) gc.a || cat /dev/null\n-\t./test_cpp 1\n-\techo > c++\n-\n-dyn_load_sunos53.o: dyn_load.c\n-\t$(CC) $(CFLAGS) -DSUNOS53_SHARED_LIB -c $(srcdir)/dyn_load.c -o $@\n-\n-# SunOS5 shared library version of the collector\n-sunos5gc.so: $(OBJS) dyn_load_sunos53.o\n-\t$(CC) -G -o sunos5gc.so $(OBJS) dyn_load_sunos53.o -ldl\n-\tln sunos5gc.so libgc.so\n-\n-# Alpha/OSF shared library version of the collector\n-libalphagc.so: $(OBJS)\n-\tld -shared -o libalphagc.so $(OBJS) dyn_load.o -lc\n-\tln libalphagc.so libgc.so\n-\n-# IRIX shared library version of the collector\n-libirixgc.so: $(OBJS) dyn_load.o\n-\tld -shared $(ABI_FLAG) -o libirixgc.so $(OBJS) dyn_load.o -lc\n-\tln libirixgc.so libgc.so\n-\n-# Linux shared library version of the collector\n-liblinuxgc.so: $(OBJS) dyn_load.o\n-\tgcc -shared -o liblinuxgc.so $(OBJS) dyn_load.o\n-\tln liblinuxgc.so libgc.so\n-\n-# Alternative Linux rule.  This is preferable, but is likely to break the\n-# Makefile for some non-linux platforms.\n-# LIBOBJS= $(patsubst %.o, %.lo, $(OBJS))\n-#\n-#.SUFFIXES: .lo $(SUFFIXES)\n-#\n-#.c.lo:\n-#\t$(CC) $(CFLAGS) $(CPPFLAGS) -fPIC -c $< -o $@\n-#\n-# liblinuxgc.so: $(LIBOBJS) dyn_load.lo\n-# \tgcc -shared -Wl,-soname=libgc.so.0 -o libgc.so.0 $(LIBOBJS) dyn_load.lo\n-#\ttouch liblinuxgc.so\n-\n-mach_dep.o: $(srcdir)/mach_dep.c $(srcdir)/mips_sgi_mach_dep.s \\\n-\t    $(srcdir)/mips_ultrix_mach_dep.s \\\n-            $(srcdir)/rs6000_mach_dep.s $(srcdir)/powerpc_darwin_mach_dep.s \\\n-\t    $(srcdir)/sparc_mach_dep.S $(srcdir)/sparc_sunos4_mach_dep.s \\\n-\t    $(srcdir)/ia64_save_regs_in_stack.s \\\n-\t    $(srcdir)/sparc_netbsd_mach_dep.s $(UTILS)\n-\trm -f mach_dep.o\n-\t./if_mach MIPS IRIX5 $(CC) -c -o mach_dep.o $(srcdir)/mips_sgi_mach_dep.s\n-\t./if_mach MIPS RISCOS $(AS) -o mach_dep.o $(srcdir)/mips_ultrix_mach_dep.s\n-\t./if_mach MIPS ULTRIX $(AS) -o mach_dep.o $(srcdir)/mips_ultrix_mach_dep.s\n-\t./if_mach POWERPC DARWIN $(AS) -o mach_dep.o $(srcdir)/powerpc_darwin_mach_dep.s\n-\t./if_mach ALPHA LINUX $(CC) -c -o mach_dep.o $(srcdir)/alpha_mach_dep.S\n-\t./if_mach SPARC SUNOS5 $(CC) -c -o mach_dep.o $(srcdir)/sparc_mach_dep.S\n-\t./if_mach SPARC SUNOS4 $(AS) -o mach_dep.o $(srcdir)/sparc_sunos4_mach_dep.s\n-\t./if_mach SPARC OPENBSD $(AS) -o mach_dep.o $(srcdir)/sparc_sunos4_mach_dep.s\n-\t./if_mach SPARC NETBSD $(AS) -o mach_dep.o $(srcdir)/sparc_netbsd_mach_dep.s\n-\t./if_mach IA64 \"\" as $(AS_ABI_FLAG) -o ia64_save_regs_in_stack.o $(srcdir)/ia64_save_regs_in_stack.s\n-\t./if_mach IA64 \"\" $(CC) -c -o mach_dep1.o $(SPECIALCFLAGS) $(srcdir)/mach_dep.c\n-\t./if_mach IA64 \"\" ld -r -o mach_dep.o mach_dep1.o ia64_save_regs_in_stack.o\n-\t./if_not_there mach_dep.o $(CC) -c $(SPECIALCFLAGS) $(srcdir)/mach_dep.c\n-\n-mark_rts.o: $(srcdir)/mark_rts.c $(UTILS)\n-\trm -f mark_rts.o\n-\t-./if_mach ALPHA OSF1 $(CC) -c $(CFLAGS) -Wo,-notail $(srcdir)/mark_rts.c\n-\t./if_not_there mark_rts.o $(CC) -c $(CFLAGS) $(srcdir)/mark_rts.c\n-#\tWork-around for DEC optimizer tail recursion elimination bug.\n-#  The ALPHA-specific line should be removed if gcc is used.\n-\n-alloc.o: version.h\n-\n-cord:\n-\tmkdir cord\n-\n-cord/cordbscs.o: cord $(srcdir)/cord/cordbscs.c $(CORD_INCLUDE_FILES)\n-\t$(CC) $(CFLAGS) -c -I$(srcdir) $(srcdir)/cord/cordbscs.c\n-\tmv cordbscs.o cord/cordbscs.o\n-#  not all compilers understand -o filename\n-\n-cord/cordxtra.o: cord $(srcdir)/cord/cordxtra.c $(CORD_INCLUDE_FILES)\n-\t$(CC) $(CFLAGS) -c -I$(srcdir) $(srcdir)/cord/cordxtra.c\n-\tmv cordxtra.o cord/cordxtra.o\n-\n-cord/cordprnt.o: cord $(srcdir)/cord/cordprnt.c $(CORD_INCLUDE_FILES)\n-\t$(CC) $(CFLAGS) -c -I$(srcdir) $(srcdir)/cord/cordprnt.c\n-\tmv cordprnt.o cord/cordprnt.o\n-\n-cord/cordtest: $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a $(UTILS)\n-\trm -f cord/cordtest\n-\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a -lucb\n-\t./if_mach HP_PA HPUX $(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a -ldld `./threadlibs`\n-\t./if_mach M68K AMIGA $(CC) $(CFLAGS) -UGC_AMIGA_MAKINGLIB -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a `./threadlibs`\n-\t./if_not_there cord/cordtest $(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a `./threadlibs`\n-\n-cord/de: $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(UTILS)\n-\trm -f cord/de\n-\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -lucb `./threadlibs`\n-\t./if_mach HP_PA HPUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -ldld `./threadlibs`\n-\t./if_mach RS6000 \"\" $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses\n-\t./if_mach POWERPC DARWIN $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a\n-\t./if_mach I386 LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses `./threadlibs`\n-\t./if_mach ALPHA LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses `./threadlibs`\n-\t./if_mach IA64 LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses `./threadlibs`\n-\t./if_mach M68K AMIGA $(CC) $(CFLAGS) -UGC_AMIGA_MAKINGLIB -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses\n-\t./if_not_there cord/de $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) `./threadlibs`\n-\n-if_mach: $(srcdir)/if_mach.c $(srcdir)/include/private/gcconfig.h\n-\t$(HOSTCC) $(HOSTCFLAGS) -o if_mach $(srcdir)/if_mach.c\n-\n-threadlibs: $(srcdir)/threadlibs.c $(srcdir)/include/private/gcconfig.h Makefile\n-\t$(HOSTCC) $(HOSTCFLAGS) -o threadlibs $(srcdir)/threadlibs.c\n-\n-if_not_there: $(srcdir)/if_not_there.c\n-\t$(HOSTCC) $(HOSTCFLAGS) -o if_not_there $(srcdir)/if_not_there.c\n-\n-clean: \n-\trm -f gc.a *.o *.exe tests/*.o gctest gctest_dyn_link test_cpp \\\n-\t      setjmp_test  mon.out gmon.out a.out core if_not_there if_mach \\\n-\t      threadlibs $(CORD_OBJS) cord/cordtest cord/de \n-\t-rm -f *~\n-\n-gctest: tests/test.o gc.a $(UTILS)\n-\trm -f gctest\n-\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o gctest  tests/test.o gc.a -lucb\n-\t./if_mach HP_PA HPUX $(CC) $(CFLAGS) -o gctest  tests/test.o gc.a -ldld `./threadlibs`\n-\t./if_mach M68K AMIGA $(CC) $(CFLAGS) -UGC_AMIGA_MAKINGLIB -o gctest  tests/test.o gc.a `./threadlibs`\n-\t./if_not_there gctest $(CC) $(CFLAGS) -o gctest tests/test.o gc.a `./threadlibs`\n-\n-# If an optimized setjmp_test generates a segmentation fault,\n-# odds are your compiler is broken.  Gctest may still work.\n-# Try compiling setjmp_t.c unoptimized.\n-setjmp_test: $(srcdir)/setjmp_t.c $(srcdir)/include/gc.h $(UTILS)\n-\t$(CC) $(CFLAGS) -o setjmp_test $(srcdir)/setjmp_t.c\n-\n-test:  KandRtest cord/cordtest\n-\tcord/cordtest\n-\n-# Those tests that work even with a K&R C compiler:\n-KandRtest: setjmp_test gctest\n-\t./setjmp_test\n-\t./gctest\n-\n-add_gc_prefix: $(srcdir)/add_gc_prefix.c $(srcdir)/version.h\n-\t$(CC) -o add_gc_prefix $(srcdir)/add_gc_prefix.c\n-\n-gcname: $(srcdir)/gcname.c $(srcdir)/version.h\n-\t$(CC) -o gcname $(srcdir)/gcname.c\n-\n-gc.tar: $(SRCS) $(DOC_FILES) $(OTHER_FILES) add_gc_prefix gcname\n-\tcp Makefile Makefile.old\n-\tcp Makefile.direct Makefile\n-\trm -f `./gcname`\n-\tln -s . `./gcname`\n-\t./add_gc_prefix $(SRCS) $(DOC_FILES) $(OTHER_FILES) > /tmp/gc.tar-files\n-\ttar cvfh gc.tar `cat /tmp/gc.tar-files`\n-\tcp gc.tar `./gcname`.tar\n-\tgzip `./gcname`.tar\n-\trm `./gcname`\n-\n-pc_gc.tar: $(SRCS) $(OTHER_FILES)\n-\ttar cvfX pc_gc.tar pc_excludes $(SRCS) $(OTHER_FILES)\n-\n-floppy: pc_gc.tar\n-\t-mmd a:/cord\n-\t-mmd a:/cord/private\n-\t-mmd a:/include\n-\t-mmd a:/include/private\n-\tmkdir /tmp/pc_gc\n-\tcat pc_gc.tar | (cd /tmp/pc_gc; tar xvf -)\n-\t-mcopy -tmn /tmp/pc_gc/* a:\n-\t-mcopy -tmn /tmp/pc_gc/cord/* a:/cord\n-\t-mcopy -mn /tmp/pc_gc/cord/de_win.ICO a:/cord\n-\t-mcopy -tmn /tmp/pc_gc/cord/private/* a:/cord/private\n-\t-mcopy -tmn /tmp/pc_gc/include/* a:/include\n-\t-mcopy -tmn /tmp/pc_gc/include/private/* a:/include/private\n-\trm -r /tmp/pc_gc\n-\n-gc.tar.Z: gc.tar\n-\tcompress gc.tar\n-\n-gc.tar.gz: gc.tar\n-\tgzip gc.tar\n-\n-lint: $(CSRCS) tests/test.c\n-\tlint -DLINT $(CSRCS) tests/test.c | egrep -v \"possible pointer alignment problem|abort|exit|sbrk|mprotect|syscall|change in ANSI|improper alignment\"\n-\n-# BTL: added to test shared library version of collector.\n-# Currently works only under SunOS5.  Requires GC_INIT call from statically\n-# loaded client code.\n-ABSDIR = `pwd`\n-gctest_dyn_link: tests/test.o libgc.so\n-\t$(CC) -L$(ABSDIR) -R$(ABSDIR) -o gctest_dyn_link tests/test.o -lgc -ldl -lthread\n-\n-gctest_irix_dyn_link: tests/test.o libirixgc.so\n-\t$(CC) -L$(ABSDIR) -o gctest_irix_dyn_link tests/test.o -lirixgc\n-\n-# The following appear to be dead, especially since libgc_globals.h\n-# is apparently lost.\n-test_dll.o: tests/test.c libgc_globals.h\n-\t$(CC) $(CFLAGS) -DGC_USE_DLL -c tests/test.c -o test_dll.o\n-\n-test_dll: test_dll.o libgc_dll.a libgc.dll\n-\t$(CC) test_dll.o -L$(ABSDIR) -lgc_dll -o test_dll\n-\n-SYM_PREFIX-libgc=GC\n-\n-# Uncomment the following line to build a GNU win32 DLL\n-# include Makefile.DLLs\n-\n-reserved_namespace: $(SRCS)\n-\tfor file in $(SRCS) tests/test.c tests/test_cpp.cc; do \\\n-\t\tsed s/GC_/_GC_/g < $$file > tmp; \\\n-\t\tcp tmp $$file; \\\n-\t\tdone\n-\n-user_namespace: $(SRCS)\n-\tfor file in $(SRCS) tests/test.c tests/test_cpp.cc; do \\\n-\t\tsed s/_GC_/GC_/g < $$file > tmp; \\\n-\t\tcp tmp $$file; \\\n-\t\tdone"}, {"sha": "7757f15133d5117f2d79f61395a640911f2df31e", "filename": "boehm-gc/Makefile.dj", "status": "removed", "additions": 0, "deletions": 430, "changes": 430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMakefile.dj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMakefile.dj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.dj?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,430 +0,0 @@\n-# This Makefile is intended only for DJGPP use.\n-# It is mainly a copy of the main Makefile, but tends to get out of sync\n-# with it.  A merge would probably be appropriate.\n-\n-# Primary targets:\n-# gc.a - builds basic library\n-# libgc.a - builds library for use with g++ \"-fgc-keyword\" extension\n-#\t    -fgc-keyword was never really available.  Historical\n-#\t    interest only.\n-# c++ - adds C++ interface to library\n-# cords - adds cords (heavyweight strings) to library\n-# test - prints porting information, then builds basic version of gc.a,\n-#      \t and runs some tests of collector and cords.  Does not add cords or\n-#\t c++ interface to gc.a\n-# cord/de$(EXE_SUFFIX) - builds dumb editor based on cords.\n-ABI_FLAG=\n-CC=gcc $(ABI_FLAG)\n-CXX=gxx $(ABI_FLAG)\n-AS=gcc -c -x assembler-with-cpp $(ABI_FLAG)\n-#  The above doesn't work with gas, which doesn't run cpp.\n-#  Define AS as `gcc -c -x assembler-with-cpp' instead.\n-#  Under Irix 6, you will have to specify the ABI (-o32, -n32, or -64)\n-#  if you use something other than the default ABI on your machine.\n-\n-# special defines for DJGPP\n-CXXLD=gxx $(ABI_FLAG)\n-EXE_SUFFIX=.exe\n-\n-srcdir= .\n-VPATH= $(srcdir)\n-\n-CFLAGS= -gstabs+ -O2 -I$(srcdir)/include -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DALL_INTERIOR_POINTERS -DNO_EXECUTE_PERMISSION -DSILENT\n-\n-# Setjmp_test may yield overly optimistic results when compiled\n-# without optimization.\n-# -DSILENT disables statistics printing, and improves performance.\n-# -DFIND_LEAK causes GC_find_leak to be initially set.\n-#   This causes the collector to assume that all inaccessible\n-#   objects should have been explicitly deallocated, and reports exceptions.\n-#   Finalization and the test program are not usable in this mode.\n-# -DALL_INTERIOR_POINTERS allows all pointers to the interior\n-#   of objects to be recognized.  (See gc_priv.h for consequences.)\n-# -DSMALL_CONFIG tries to tune the collector for small heap sizes,\n-#   usually causing it to use less space in such situations.\n-#   Incremental collection no longer works in this case.\n-# -DLARGE_CONFIG tunes the collector for unusually large heaps.\n-#   Necessary for heaps larger than about 500 MB on most machines.\n-#   Recommended for heaps larger than about 64 MB.\n-# -DDONT_ADD_BYTE_AT_END is meaningful only with\n-#   -DALL_INTERIOR_POINTERS.  Normally -DALL_INTERIOR_POINTERS\n-#   causes all objects to be padded so that pointers just past the end of\n-#   an object can be recognized.  This can be expensive.  (The padding\n-#   is normally more than one byte due to alignment constraints.)\n-#   -DDONT_ADD_BYTE_AT_END disables the padding.\n-# -DNO_SIGNALS does not disable signals during critical parts of\n-#   the GC process.  This is no less correct than many malloc \n-#   implementations, and it sometimes has a significant performance\n-#   impact.  However, it is dangerous for many not-quite-ANSI C\n-#   programs that call things like printf in asynchronous signal handlers.\n-#   This is on by default.  Turning it off has not been extensively tested with\n-#   compilers that reorder stores.  It should have been.\n-# -DNO_EXECUTE_PERMISSION may cause some or all of the heap to not\n-#   have execute permission, i.e. it may be impossible to execute\n-#   code from the heap.  Currently this only affects the incremental\n-#   collector on UNIX machines.  It may greatly improve its performance,\n-#   since this may avoid some expensive cache synchronization.\n-# -DGC_NO_OPERATOR_NEW_ARRAY declares that the C++ compiler does not support\n-#   the  new syntax \"operator new[]\" for allocating and deleting arrays.\n-#   See gc_cpp.h for details.  No effect on the C part of the collector.\n-#   This is defined implicitly in a few environments.  Must also be defined\n-#   by clients that use gc_cpp.h.\n-# -DREDIRECT_MALLOC=X causes malloc, realloc, and free to be defined\n-#   as aliases for X, GC_realloc, and GC_free, respectively.\n-#   Calloc is redefined in terms of the new malloc.  X should\n-#   be either GC_malloc or GC_malloc_uncollectable.\n-#   The former is occasionally useful for working around leaks in code\n-#   you don't want to (or can't) look at.  It may not work for\n-#   existing code, but it often does.  Neither works on all platforms,\n-#   since some ports use malloc or calloc to obtain system memory.\n-#   (Probably works for UNIX, and win32.)\n-# -DIGNORE_FREE turns calls to free into a noop.  Only useful with\n-#   -DREDIRECT_MALLOC.\n-# -DNO_DEBUGGING removes GC_dump and the debugging routines it calls.\n-#   Reduces code size slightly at the expense of debuggability.\n-# -DJAVA_FINALIZATION makes it somewhat safer to finalize objects out of\n-#   order by specifying a nonstandard finalization mark procedure  (see\n-#   finalize.c).  Objects reachable from finalizable objects will be marked\n-#   in a sepearte postpass, and hence their memory won't be reclaimed.\n-#   Not recommended unless you are implementing a language that specifies\n-#   these semantics.  Since 5.0, determines only only the initial value\n-#   of GC_java_finalization variable.\n-# -DFINALIZE_ON_DEMAND causes finalizers to be run only in response\n-#   to explicit GC_invoke_finalizers() calls.\n-#   In 5.0 this became runtime adjustable, and this only determines the\n-#   initial value of GC_finalize_on_demand.\n-# -DATOMIC_UNCOLLECTABLE includes code for GC_malloc_atomic_uncollectable.\n-#   This is useful if either the vendor malloc implementation is poor,\n-#   or if REDIRECT_MALLOC is used.\n-# -DHBLKSIZE=ddd, where ddd is a power of 2 between 512 and 16384, explicitly\n-#   sets the heap block size.  Each heap block is devoted to a single size and\n-#   kind of object.  For the incremental collector it makes sense to match\n-#   the most likely page size.  Otherwise large values result in more\n-#   fragmentation, but generally better performance for large heaps.\n-# -DPRINT_BLACK_LIST Whenever a black list entry is added, i.e. whenever\n-#   the garbage collector detects a value that looks almost, but not quite,\n-#   like a pointer, print both the address containing the value, and the\n-#   value of the near-bogus-pointer.  Can be used to identifiy regions of\n-#   memory that are likely to contribute misidentified pointers.\n-# -DKEEP_BACK_PTRS Add code to save back pointers in debugging headers\n-#   for objects allocated with the debugging allocator.  If all objects\n-#   through GC_MALLOC with GC_DEBUG defined, this allows the client\n-#   to determine how particular or randomly chosen objects are reachable\n-#   for debugging/profiling purposes.  The gc_backptr.h interface is\n-#   implemented only if this is defined.\n-# -DGC_ASSERTIONS Enable some internal GC assertion checking.  Currently\n-#   this facility is only used in a few places.  It is intended primarily\n-#   for debugging of the garbage collector itself, but could also\n-# -DDBG_HDRS_ALL Make sure that all objects have debug headers.  Increases\n-#   the reliability (from 99.9999% to 100%) of some of the debugging\n-#   code (especially KEEP_BACK_PTRS).  Makes -DSHORT_DBG_HDRS possible.\n-#   Assumes that all client allocation is done through debugging\n-#   allocators.\n-# -DSHORT_DBG_HDRS Assume that all objects have debug headers.  Shorten\n-#   the headers to minimize object size, at the expense of checking for\n-#   writes past the end of an object.  This is intended for environments\n-#   in which most client code is written in a \"safe\" language, such as\n-#   Scheme or Java.  Assumes that all client allocation is done using\n-#   the GC_debug_ functions (or through the macros that expand to these.\n-#   (Also eliminates the field for the requested object size.)\n-#   occasionally be useful for debugging of client code.  Slows down the\n-#   collector somewhat, but not drastically.\n-# -DCHECKSUMS reports on erroneously clear dirty bits, and unexpectedly\n-#   altered stubborn objects, at substantial performance cost.\n-#   Use only for debugging of the incremental collector.\n-# -DGC_GCJ_SUPPORT includes support for gcj (and possibly other systems\n-#   that include a pointer to a type descriptor in each allocated object).\n-#   Building this way requires an ANSI C compiler.\n-# -DUSE_I686_PREFETCH causes the collector to issue Pentium III style\n-#   prefetch instructions.  No effect except on X86 Linux platforms.\n-#   Assumes a very recent gcc-compatible compiler and assembler.\n-#   (Gas prefetcht0 support was added around May 1999.)\n-#   Empirically the code appears to still run correctly on Pentium II\n-#   processors, though with no performance benefit.  May not run on other\n-#   X86 processors?  In some cases this improves performance by\n-#   15% or so.\n-# -DUSE_3DNOW_PREFETCH causes the collector to issue AMD 3DNow style\n-#   prefetch instructions.  Same restrictions as USE_I686_PREFETCH.\n-#   UNTESTED!!\n-# -DGC_USE_LD_WRAP in combination with the gld flags listed in README.linux\n-#   causes the collector some system and pthread calls in a more transparent\n-#   fashion than the usual macro-based approach.  Requires GNU ld, and\n-#   currently probably works only with Linux.\n-\n-\n-CXXFLAGS= $(CFLAGS) -DGC_OPERATOR_NEW_ARRAY\n-AR= ar\n-RANLIB= ranlib\n-\n-\n-OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o typd_mlc.o ptr_chck.o mallocx.o solaris_pthreads.o gcj_mlc.o specific.o\n-\n-CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c typd_mlc.c ptr_chck.c mallocx.c solaris_pthreads.c gcj_mlc.c specific.c\n-\n-CORD_SRCS=  cord/cordbscs.c cord/cordxtra.c cord/cordprnt.c cord/de.c cord/cordtest.c include/cord.h include/ec.h include/private/cord_pos.h cord/de_win.c cord/de_win.h cord/de_cmds.h cord/de_win.ICO cord/de_win.RC cord/SCOPTIONS.amiga cord/SMakefile.amiga\n-\n-CORD_OBJS=  cord/cordbscs.o cord/cordxtra.o cord/cordprnt.o\n-\n-SRCS= $(CSRCS) mips_sgi_mach_dep.S rs6000_mach_dep.s alpha_mach_dep.S \\\n-    sparc_mach_dep.S include/gc.h include/gc_typed.h \\\n-    include/private/gc_hdrs.h include/private/gc_priv.h \\\n-    include/private/gcconfig.h include/private/gc_mark.h \\\n-    include/gc_inl.h include/gc_inline.h gc.man \\\n-    threadlibs.c if_mach.c if_not_there.c gc_cpp.cc include/gc_cpp.h \\\n-    include/weakpointer.h include/private/gc_locks.h \\\n-    gcc_support.c mips_ultrix_mach_dep.s include/gc_alloc.h \\\n-    include/new_gc_alloc.h include/javaxfc.h sparc_sunos4_mach_dep.s \\\n-    include/private/solaris_threads.h include/gc_backptr.h \\\n-    hpux_test_and_clear.s include/gc_gcj.h \\\n-    include/gc_local_alloc.h include/private/dbg_mlc.h \\\n-    include/private/specific.h powerpc_darwin_mach_dep.s \\\n-    include/leak_detector.h $(CORD_SRCS)\n-\n-OTHER_FILES= Makefile PCR-Makefile OS2_MAKEFILE NT_MAKEFILE BCC_MAKEFILE \\\n-           README tests/test.c test_cpp.cc setjmp_t.c SMakefile.amiga \\\n-           SCoptions.amiga README.amiga README.win32 cord/README \\\n-\t   README.rs6000 README.QUICK callprocs pc_excludes \\\n-           barrett_diagram README.OS2 README.Mac MacProjects.sit.hqx \\\n-           MacOS.c EMX_MAKEFILE README.debugging \\\n-           Mac_files/datastart.c Mac_files/dataend.c \\\n-           Mac_files/MacOS_config.h Mac_files/MacOS_Test_config.h \\\n-           add_gc_prefix.c README.solaris2 README.sgi README.hp README.uts \\\n-\t   win32_threads.c NT_THREADS_MAKEFILE gc.mak README.dj Makefile.dj \\\n-\t   README.alpha README.linux README.MacOSX version.h Makefile.DLLs \\\n-\t   WCC_MAKEFILE nursery.c include/gc_nursery.h include/gc_copy_descr.h\n-\n-CORD_INCLUDE_FILES= $(srcdir)/include/gc.h $(srcdir)/include/cord.h \\\n-\t$(srcdir)/include/ec.h $(srcdir)/include/private/cord_pos.h\n-\n-UTILS= if_mach$(EXE_SUFFIX) if_not_there$(EXE_SUFFIX)\n-\n-# Libraries needed for curses applications.  Only needed for de.\n-CURSES= -lcurses -ltermlib\n-\n-# The following is irrelevant on most systems.  But a few\n-# versions of make otherwise fork the shell specified in\n-# the SHELL environment variable.\n-SHELL= /bin/sh\n-\n-SPECIALCFLAGS = -I$(srcdir)/include\n-# Alternative flags to the C compiler for mach_dep.c.\n-# Mach_dep.c often doesn't like optimization, and it's\n-# not time-critical anyway.\n-# Set SPECIALCFLAGS to -q nodirect_code on Encore.\n-\n-all: gc.a gctest$(EXE_SUFFIX)\n-\n-$(OBJS) test.o dyn_load.o dyn_load_sunos53.o: \\\n-    $(srcdir)/include/private/gc_priv.h \\\n-    $(srcdir)/include/private/gc_hdrs.h $(srcdir)/include/private/gc_locks.h \\\n-    $(srcdir)/include/gc.h \\\n-    $(srcdir)/include/private/gcconfig.h $(srcdir)/include/gc_typed.h \\\n-    Makefile\n-# The dependency on Makefile is needed.  Changing\n-# options such as -DSILENT affects the size of GC_arrays,\n-# invalidating all .o files that rely on gc_priv.h\n-\n-mark.o typd_mlc.o finalize.o: $(srcdir)/include/gc_mark.h\n-\n-base_lib gc.a: $(OBJS) dyn_load.o $(UTILS)\n-\techo > base_lib\n-\trm -f on_sparc_sunos5_1\n-\t./if_mach SPARC SUNOS5 touch on_sparc_sunos5_1\n-\t./if_mach SPARC SUNOS5 $(AR) rus gc.a $(OBJS) dyn_load.o\n-\t./if_not_there on_sparc_sunos5_1 $(AR) ru gc.a $(OBJS) dyn_load.o\n-\t-./if_not_there on_sparc_sunos5_1 $(RANLIB) gc.a\n-#\tignore ranlib failure; that usually means it doesn't exist, and isn't needed\n-\n-cords: $(CORD_OBJS) cord/cordtest$(EXE_SUFFIX) $(UTILS)\n-\trm -f on_sparc_sunos5_3\n-\t./if_mach SPARC SUNOS5 touch on_sparc_sunos5_3\n-\t./if_mach SPARC SUNOS5 $(AR) rus gc.a $(CORD_OBJS)\n-\t./if_not_there on_sparc_sunos5_3 $(AR) ru gc.a $(CORD_OBJS)\n-\t-./if_not_there on_sparc_sunos5_3 $(RANLIB) gc.a\n-\n-gc_cpp.o: $(srcdir)/gc_cpp.cc $(srcdir)/include/gc_cpp.h $(srcdir)/include/gc.h Makefile\n-\t$(CXX) -c $(CXXFLAGS) $(srcdir)/gc_cpp.cc\n-\n-test_cpp$(EXE_SUFFIX): $(srcdir)/test_cpp.cc $(srcdir)/include/gc_cpp.h gc_cpp.o $(srcdir)/include/gc.h \\\n-base_lib $(UTILS)\n-\trm -f test_cpp test_cpp$(EXE_SUFFIX)\n-\t./if_mach HP_PA \"\" $(CXX) $(CXXFLAGS) -o test_cpp $(srcdir)/test_cpp.cc gc_cpp.o gc.a -ldld\n-\t./if_not_there test_cpp$(EXE_SUFFIX) $(CXXLD) $(CXXFLAGS) -o test_cpp$(EXE_SUFFIX) $(srcdir)/test_cpp.cc gc_cpp.o gc.a\n-\trm -f test_cpp\n-\n-c++: gc_cpp.o $(srcdir)/include/gc_cpp.h test_cpp$(EXE_SUFFIX)\n-\trm -f on_sparc_sunos5_4\n-\t./if_mach SPARC SUNOS5 touch on_sparc_sunos5_4\n-\t./if_mach SPARC SUNOS5 $(AR) rus gc.a gc_cpp.o\n-\t./if_not_there on_sparc_sunos5_4 $(AR) ru gc.a gc_cpp.o\n-\t-./if_not_there on_sparc_sunos5_4 $(RANLIB) gc.a\n-\t./test_cpp$(EXE_SUFFIX) 1\n-\techo > c++\n-\n-dyn_load_sunos53.o: dyn_load.c\n-\t$(CC) $(CFLAGS) -DSUNOS53_SHARED_LIB -c $(srcdir)/dyn_load.c -o $@\n-\n-# SunOS5 shared library version of the collector\n-sunos5gc.so: $(OBJS) dyn_load_sunos53.o\n-\t$(CC) -G -o sunos5gc.so $(OBJS) dyn_load_sunos53.o -ldl\n-\tln sunos5gc.so libgc.so\n-\n-# Alpha/OSF shared library version of the collector\n-libalphagc.so: $(OBJS)\n-\tld -shared -o libalphagc.so $(OBJS) dyn_load.o -lc\n-\tln libalphagc.so libgc.so\n-\n-# IRIX shared library version of the collector\n-libirixgc.so: $(OBJS) dyn_load.o\n-\tld -shared $(ABI_FLAG) -o libirixgc.so $(OBJS) dyn_load.o -lc\n-\tln libirixgc.so libgc.so\n-\n-# Linux shared library version of the collector\n-liblinuxgc.so: $(OBJS) dyn_load.o\n-\tgcc -shared -o liblinuxgc.so $(OBJS) dyn_load.o -lo\n-\tln liblinuxgc.so libgc.so\n-\n-mach_dep.o: $(srcdir)/mach_dep.c $(srcdir)/mips_sgi_mach_dep.S $(srcdir)/mips_ultrix_mach_dep.s \\\n-            $(srcdir)/rs6000_mach_dep.s $(srcdir)/powerpc_darwin_mach_dep.s $(UTILS)\n-\trm -f mach_dep.o\n-\t./if_mach MIPS IRIX5 $(AS) -o mach_dep.o $(srcdir)/mips_sgi_mach_dep.S\n-\t./if_mach MIPS RISCOS $(AS) -o mach_dep.o $(srcdir)/mips_ultrix_mach_dep.s\n-\t./if_mach MIPS ULTRIX $(AS) -o mach_dep.o $(srcdir)/mips_ultrix_mach_dep.s\n-\t./if_mach RS6000 \"\" $(AS) -o mach_dep.o $(srcdir)/rs6000_mach_dep.s\n-\t./if_mach POWERPC MACOSX $(AS) -o mach_dep.o $(srcdir)/powerpc_darwin_mach_dep.s\n-\t./if_mach ALPHA \"\" $(AS) -o mach_dep.o $(srcdir)/alpha_mach_dep.S\n-\t./if_mach SPARC SUNOS5 $(AS) -o mach_dep.o $(srcdir)/sparc_mach_dep.S\n-\t./if_mach SPARC SUNOS4 $(AS) -o mach_dep.o $(srcdir)/sparc_sunos4_mach_dep.s\n-\t./if_not_there mach_dep.o $(CC) -c $(SPECIALCFLAGS) $(srcdir)/mach_dep.c\n-\n-mark_rts.o: $(srcdir)/mark_rts.c if_mach if_not_there $(UTILS)\n-\trm -f mark_rts.o\n-\t-./if_mach ALPHA OSF1 $(CC) -c $(CFLAGS) -Wo,-notail $(srcdir)/mark_rts.c\n-\t./if_not_there mark_rts.o $(CC) -c $(CFLAGS) $(srcdir)/mark_rts.c\n-#\tWork-around for DEC optimizer tail recursion elimination bug.\n-#  The ALPHA-specific line should be removed if gcc is used.\n-\n-alloc.o: version.h\n-\n-cord/cordbscs.o: $(srcdir)/cord/cordbscs.c $(CORD_INCLUDE_FILES)\n-\t$(CC) $(CFLAGS) -c -I$(srcdir) $(srcdir)/cord/cordbscs.c\n-\tmv cordbscs.o cord/cordbscs.o\n-#  not all compilers understand -o filename\n-\n-cord/cordxtra.o: $(srcdir)/cord/cordxtra.c $(CORD_INCLUDE_FILES)\n-\t$(CC) $(CFLAGS) -c -I$(srcdir) $(srcdir)/cord/cordxtra.c\n-\tmv cordxtra.o cord/cordxtra.o\n-\n-cord/cordprnt.o: $(srcdir)/cord/cordprnt.c $(CORD_INCLUDE_FILES)\n-\t$(CC) $(CFLAGS) -c -I$(srcdir) $(srcdir)/cord/cordprnt.c\n-\tmv cordprnt.o cord/cordprnt.o\n-\n-cord/cordtest$(EXE_SUFFIX): $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a $(UTILS) /tmp\n-\trm -f cord/cordtest$(EXE_SUFFIX)\n-\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o cord/cordtest$(EXE_SUFFIX) $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a -lucb\n-\t./if_mach HP_PA \"\" $(CC) $(CFLAGS) -o cord/cordtest$(EXE_SUFFIX) $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a -ldld\n-\t./if_not_there cord/cordtest$(EXE_SUFFIX) $(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a\n-\trm -f cord/cordtest cordtest\n-\t-mv cordtest$(EXE_SUFFIX) cord/\n-\n-/tmp: $(UTILS)\n-\t./if_not_there /tmp mkdir /tmp\n-\n-cord/de$(EXE_SUFFIX): $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(UTILS)\n-\trm -f cord/de cord/de$(EXE_SUFFIX)\n-\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -lucb `./threadlibs`\n-\t./if_mach HP_PA \"\" $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -ldld\n-\t./if_mach RS6000 \"\" $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses\n-\t./if_mach I386 LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses `./threadlibs`\n-\t./if_mach ALPHA LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses\n-\t./if_not_there cord/de$(EXE_SUFFIX) $(CC) $(CFLAGS) -o cord/de$(EXE_SUFFIX) $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES)\n-\n-if_mach$(EXE_SUFFIX): $(srcdir)/if_mach.c $(srcdir)/include/private/gcconfig.h\n-\trm -f if_mach if_mach$(EXE_SUFFIX)\n-\t$(CC) $(CFLAGS) -o if_mach $(srcdir)/if_mach.c\n-\n-threadlibs$(EXE_SUFFIX): $(srcdir)/threadlibs.c $(srcdir)include/private/gcconfig.h Makefile\n-\trm -f threadlibs threadlibs$(EXE_SUFFIX)\n-\t$(CC) $(CFLAGS) -o threadlibs $(srcdir)/threadlibs.c\n-\n-if_not_there$(EXE_SUFFIX): $(srcdir)/if_not_there.c\n-\trm -f if_not_there if_not_there$(EXE_SUFFIX)\n-\t$(CC) $(CFLAGS) -o if_not_there $(srcdir)/if_not_there.c\n-\n-# Clean removes *.o several times,\n-# because as the first one doesn't seem to get them all!\n-clean: \n-\trm -f gc.a *.o\n-\trm -f *.o\n-\trm -f *.o\n-\trm -f cord/*.o\n-\trm -f gctest gctest_dyn_link test_cpp\n-\trm -f setjmp_test  mon.out gmon.out a.out core if_not_there if_mach\n-\trm -f threadlibs $(CORD_OBJS) cordtest cord/cordtest de cord/de\n-\trm -f gctest$(EXE_SUFFIX) gctest_dyn_link$(EXE_SUFFIX) test_cpp$(EXE_SUFFIX)\n-\trm -f setjmp_test$(EXE_SUFFIX) if_not_there$(EXE_SUFFIX) if_mach$(EXE_SUFFIX)\n-\trm -f threadlibs$(EXE_SUFFIX) cord/cordtest$(EXE_SUFFIX)\n-\t-rm -f *~\n-\n-gctest$(EXE_SUFFIX): tests/test.o gc.a if_mach$(EXE_SUFFIX) if_not_there$(EXE_SUFFIX)\n-\trm -f gctest gctest$(EXE_SUFFIX)\n-\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o gctest  tests/test.o gc.a -lucb\n-\t./if_mach HP_PA \"\" $(CC) $(CFLAGS) -o gctest  tests/test.o gc.a -ldld\n-\t./if_not_there gctest$(EXE_SUFFIX) $(CC) $(CFLAGS) -o gctest$(EXE_SUFFIX) tests/test.o gc.a\n-\trm -f gctest\n-\n-# If an optimized setjmp_test generates a segmentation fault,\n-# odds are your compiler is broken.  Gctest may still work.\n-# Try compiling setjmp_t.c unoptimized.\n-setjmp_test$(EXE_SUFFIX): $(srcdir)/setjmp_t.c $(srcdir)/include/gc.h \\\n-\t\tif_mach$(EXE_SUFFIX) if_not_there$(EXE_SUFFIX)\n-\trm -f setjmp_test$(EXE_SUFFIX)\n-\t$(CC) $(CFLAGS) -o setjmp_test $(srcdir)/setjmp_t.c\n-\trm -f setjmp_test\n-\n-test:  KandRtest cord/cordtest$(EXE_SUFFIX)\n-\t./cord/cordtest$(EXE_SUFFIX)\n-\n-# Those tests that work even with a K&R C compiler:\n-KandRtest: setjmp_test$(EXE_SUFFIX) gctest$(EXE_SUFFIX)\n-\t./setjmp_test$(EXE_SUFFIX)\n-\t./gctest$(EXE_SUFFIX)\n-\n-add_gc_prefix$(EXE_SUFFIX): add_gc_prefix.c\n-\t$(CC) -o add_gc_prefix$(EXE_SUFFIX) $(srcdir)/add_gc_prefix.c\n-\trm -f add_gc_prefix\n-\n-gc.tar: $(SRCS) $(OTHER_FILES) add_gc_prefix\n-\t./add_gc_prefix$(EXE_SUFFIX) $(SRCS) $(OTHER_FILES) > /tmp/gc.tar-files\n-\t(cd $(srcdir)/.. ; tar cvfh - `cat /tmp/gc.tar-files`) > gc.tar\n-\n-pc_gc.tar: $(SRCS) $(OTHER_FILES)\n-\ttar cvfX pc_gc.tar pc_excludes $(SRCS) $(OTHER_FILES)\n-\n-gc.tar.Z: gc.tar\n-\tcompress gc.tar\n-\n-gc.tar.gz: gc.tar\n-\tgzip gc.tar\n-\n-lint: $(CSRCS) tests/test.c\n-\tlint -DLINT $(CSRCS) tests/test.c | egrep -v \"possible pointer alignment problem|abort|exit|sbrk|mprotect|syscall\"\n-\n-# BTL: added to test shared library version of collector.\n-# Currently works only under SunOS5.  Requires GC_INIT call from statically\n-# loaded client code.\n-ABSDIR = `pwd`\n-gctest_dyn_link: test.o libgc.so\n-\t$(CC) -L$(ABSDIR) -R$(ABSDIR) -o gctest_dyn_link test.o -lgc -ldl -lthread\n-\n-test_dll.o: tests/test.c libgc_globals.h\n-\t$(CC) $(CFLAGS) -DGC_USE_DLL -c tests/test.c -o test_dll.o\n-\n-test_dll: test_dll.o libgc_dll.a libgc.dll\n-\t$(CC) test_dll.o -L$(ABSDIR) -lgc_dll -o test_dll\n-\n-SYM_PREFIX-libgc=GC\n-\n-# Uncomment the following line to build a GNU win32 DLL\n-# include Makefile.DLLs\n-"}, {"sha": "6105441197662df8dd6429741f12ebabcf7e2e61", "filename": "boehm-gc/Makefile.in", "status": "removed", "additions": 0, "deletions": 779, "changes": 779, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.in?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,779 +0,0 @@\n-# Makefile.in generated by automake 1.11.6 from Makefile.am.\n-# @configure_input@\n-\n-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software\n-# Foundation, Inc.\n-# This Makefile.in is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-@SET_MAKE@\n-\n-VPATH = @srcdir@\n-am__make_dryrun = \\\n-  { \\\n-    am__dry=no; \\\n-    case $$MAKEFLAGS in \\\n-      *\\\\[\\ \\\t]*) \\\n-        echo 'am--echo: ; @echo \"AM\"  OK' | $(MAKE) -f - 2>/dev/null \\\n-          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \\\n-      *) \\\n-        for am__flg in $$MAKEFLAGS; do \\\n-          case $$am__flg in \\\n-            *=*|--*) ;; \\\n-            *n*) am__dry=yes; break;; \\\n-          esac; \\\n-        done;; \\\n-    esac; \\\n-    test $$am__dry = yes; \\\n-  }\n-pkgdatadir = $(datadir)/@PACKAGE@\n-pkgincludedir = $(includedir)/@PACKAGE@\n-pkglibdir = $(libdir)/@PACKAGE@\n-pkglibexecdir = $(libexecdir)/@PACKAGE@\n-am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n-install_sh_DATA = $(install_sh) -c -m 644\n-install_sh_PROGRAM = $(install_sh) -c\n-install_sh_SCRIPT = $(install_sh) -c\n-INSTALL_HEADER = $(INSTALL_DATA)\n-transform = $(program_transform_name)\n-NORMAL_INSTALL = :\n-PRE_INSTALL = :\n-POST_INSTALL = :\n-NORMAL_UNINSTALL = :\n-PRE_UNINSTALL = :\n-POST_UNINSTALL = :\n-build_triplet = @build@\n-host_triplet = @host@\n-target_triplet = @target@\n-subdir = .\n-DIST_COMMON = ChangeLog $(srcdir)/Makefile.in $(srcdir)/Makefile.am \\\n-\t$(top_srcdir)/configure $(am__configure_deps) \\\n-\t$(srcdir)/../mkinstalldirs $(srcdir)/threads.mk.in \\\n-\t$(srcdir)/../depcomp\n-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n-am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \\\n-\t$(top_srcdir)/../config/depstand.m4 \\\n-\t$(top_srcdir)/../config/lead-dot.m4 \\\n-\t$(top_srcdir)/../config/multi.m4 \\\n-\t$(top_srcdir)/../config/no-executables.m4 \\\n-\t$(top_srcdir)/../config/override.m4 \\\n-\t$(top_srcdir)/../libtool.m4 $(top_srcdir)/../ltoptions.m4 \\\n-\t$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \\\n-\t$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/configure.ac\n-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n-\t$(ACLOCAL_M4)\n-am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n- configure.lineno config.status.lineno\n-CONFIG_HEADER = $(top_builddir)/include/gc_config.h \\\n-\t$(top_builddir)/include/gc_ext_config.h\n-CONFIG_CLEAN_FILES = threads.mk\n-CONFIG_CLEAN_VPATH_FILES =\n-LTLIBRARIES = $(noinst_LTLIBRARIES)\n-am__DEPENDENCIES_1 =\n-@POWERPC_DARWIN_TRUE@am__objects_1 = powerpc_darwin_mach_dep.lo\n-am_libgcjgc_la_OBJECTS = allchblk.lo alloc.lo blacklst.lo checksums.lo \\\n-\tdbg_mlc.lo dyn_load.lo finalize.lo gc_dlopen.lo gcj_mlc.lo \\\n-\theaders.lo malloc.lo mallocx.lo mark.lo mark_rts.lo misc.lo \\\n-\tnew_hblk.lo obj_map.lo os_dep.lo pcr_interface.lo ptr_chck.lo \\\n-\treal_malloc.lo reclaim.lo specific.lo stubborn.lo typd_mlc.lo \\\n-\tbackgraph.lo win32_threads.lo pthread_support.lo \\\n-\tpthread_stop_world.lo darwin_stop_world.lo $(am__objects_1)\n-libgcjgc_la_OBJECTS = $(am_libgcjgc_la_OBJECTS)\n-am__objects_2 = allchblk.lo alloc.lo blacklst.lo checksums.lo \\\n-\tdbg_mlc.lo dyn_load.lo finalize.lo gc_dlopen.lo gcj_mlc.lo \\\n-\theaders.lo malloc.lo mallocx.lo mark.lo mark_rts.lo misc.lo \\\n-\tnew_hblk.lo obj_map.lo os_dep.lo pcr_interface.lo ptr_chck.lo \\\n-\treal_malloc.lo reclaim.lo specific.lo stubborn.lo typd_mlc.lo \\\n-\tbackgraph.lo win32_threads.lo pthread_support.lo \\\n-\tpthread_stop_world.lo darwin_stop_world.lo $(am__objects_1)\n-am_libgcjgc_convenience_la_OBJECTS = $(am__objects_2)\n-libgcjgc_convenience_la_OBJECTS =  \\\n-\t$(am_libgcjgc_convenience_la_OBJECTS)\n-DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)/include\n-depcomp = $(SHELL) $(top_srcdir)/../depcomp\n-am__depfiles_maybe = depfiles\n-am__mv = mv -f\n-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n-\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n-LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n-\t--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n-\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n-CCLD = $(CC)\n-LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n-\t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n-\t$(LDFLAGS) -o $@\n-CCASCOMPILE = $(CCAS) $(AM_CCASFLAGS) $(CCASFLAGS)\n-LTCCASCOMPILE = $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n-\t--mode=compile $(CCAS) $(AM_CCASFLAGS) $(CCASFLAGS)\n-SOURCES = $(libgcjgc_la_SOURCES) $(libgcjgc_convenience_la_SOURCES)\n-MULTISRCTOP = \n-MULTIBUILDTOP = \n-MULTIDIRS = \n-MULTISUBDIR = \n-MULTIDO = true\n-MULTICLEAN = true\n-RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \\\n-\thtml-recursive info-recursive install-data-recursive \\\n-\tinstall-dvi-recursive install-exec-recursive \\\n-\tinstall-html-recursive install-info-recursive \\\n-\tinstall-pdf-recursive install-ps-recursive install-recursive \\\n-\tinstallcheck-recursive installdirs-recursive pdf-recursive \\\n-\tps-recursive uninstall-recursive\n-am__can_run_installinfo = \\\n-  case $$AM_UPDATE_INFO_DIR in \\\n-    n|no|NO) false;; \\\n-    *) (install-info --version) >/dev/null 2>&1;; \\\n-  esac\n-RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n-  distclean-recursive maintainer-clean-recursive\n-AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \\\n-\t$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS\n-ETAGS = etags\n-CTAGS = ctags\n-DIST_SUBDIRS = $(SUBDIRS)\n-ACLOCAL = @ACLOCAL@\n-AMTAR = @AMTAR@\n-AM_CPPFLAGS = @AM_CPPFLAGS@\n-AR = @AR@\n-AS = @AS@\n-AUTOCONF = @AUTOCONF@\n-AUTOHEADER = @AUTOHEADER@\n-AUTOMAKE = @AUTOMAKE@\n-AWK = @AWK@\n-CC = @CC@\n-CCAS = @CCAS@\n-CCASFLAGS = @CCASFLAGS@\n-CCDEPMODE = @CCDEPMODE@\n-CFLAGS = @CFLAGS@\n-CPP = @CPP@\n-CPPFLAGS = @CPPFLAGS@\n-CXX = @CXX@\n-CXXCPP = @CXXCPP@\n-CXXDEPMODE = @CXXDEPMODE@\n-CXXFLAGS = @CXXFLAGS@\n-CYGPATH_W = @CYGPATH_W@\n-DEFS = @DEFS@\n-DEPDIR = @DEPDIR@\n-DSYMUTIL = @DSYMUTIL@\n-DUMPBIN = @DUMPBIN@\n-ECHO_C = @ECHO_C@\n-ECHO_N = @ECHO_N@\n-ECHO_T = @ECHO_T@\n-EGREP = @EGREP@\n-EXEEXT = @EXEEXT@\n-EXTRA_TEST_LIBS = @EXTRA_TEST_LIBS@\n-FGREP = @FGREP@\n-GC_CFLAGS = @GC_CFLAGS@\n-GREP = @GREP@\n-INSTALL = @INSTALL@\n-INSTALL_DATA = @INSTALL_DATA@\n-INSTALL_PROGRAM = @INSTALL_PROGRAM@\n-INSTALL_SCRIPT = @INSTALL_SCRIPT@\n-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n-LD = @LD@\n-LDFLAGS = @LDFLAGS@\n-LIBOBJS = @LIBOBJS@\n-LIBS = @LIBS@\n-LIBTOOL = @LIBTOOL@\n-LIPO = @LIPO@\n-LN_S = @LN_S@\n-LTLIBOBJS = @LTLIBOBJS@\n-MAINT = @MAINT@\n-MAKEINFO = @MAKEINFO@\n-MKDIR_P = @MKDIR_P@\n-NM = @NM@\n-NMEDIT = @NMEDIT@\n-O0_CFLAGS = @O0_CFLAGS@\n-OBJDUMP = @OBJDUMP@\n-OBJEXT = @OBJEXT@\n-OTOOL = @OTOOL@\n-OTOOL64 = @OTOOL64@\n-PACKAGE = @PACKAGE@\n-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n-PACKAGE_NAME = @PACKAGE_NAME@\n-PACKAGE_STRING = @PACKAGE_STRING@\n-PACKAGE_TARNAME = @PACKAGE_TARNAME@\n-PACKAGE_URL = @PACKAGE_URL@\n-PACKAGE_VERSION = @PACKAGE_VERSION@\n-PATH_SEPARATOR = @PATH_SEPARATOR@\n-RANLIB = @RANLIB@\n-SED = @SED@\n-SET_MAKE = @SET_MAKE@\n-SHELL = @SHELL@\n-STRIP = @STRIP@\n-THREADCFLAGS = @THREADCFLAGS@\n-THREADLIBS = @THREADLIBS@\n-VERSION = @VERSION@\n-abs_builddir = @abs_builddir@\n-abs_srcdir = @abs_srcdir@\n-abs_top_builddir = @abs_top_builddir@\n-abs_top_srcdir = @abs_top_srcdir@\n-ac_ct_CC = @ac_ct_CC@\n-ac_ct_CXX = @ac_ct_CXX@\n-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n-addincludes = @addincludes@\n-addlibs = @addlibs@\n-addobjs = @addobjs@\n-addtests = @addtests@\n-am__include = @am__include@\n-am__leading_dot = @am__leading_dot@\n-am__quote = @am__quote@\n-am__tar = @am__tar@\n-am__untar = @am__untar@\n-bindir = @bindir@\n-build = @build@\n-build_alias = @build_alias@\n-build_cpu = @build_cpu@\n-build_os = @build_os@\n-build_vendor = @build_vendor@\n-builddir = @builddir@\n-datadir = @datadir@\n-datarootdir = @datarootdir@\n-docdir = @docdir@\n-dvidir = @dvidir@\n-exec_prefix = @exec_prefix@\n-extra_ldflags_libgc = @extra_ldflags_libgc@\n-host = @host@\n-host_alias = @host_alias@\n-host_cpu = @host_cpu@\n-host_os = @host_os@\n-host_vendor = @host_vendor@\n-htmldir = @htmldir@\n-includedir = @includedir@\n-infodir = @infodir@\n-install_sh = @install_sh@\n-libdir = @libdir@\n-libexecdir = @libexecdir@\n-localedir = @localedir@\n-localstatedir = @localstatedir@\n-mandir = @mandir@\n-mkdir_p = @mkdir_p@\n-mkinstalldirs = @mkinstalldirs@\n-multi_basedir = @multi_basedir@\n-oldincludedir = @oldincludedir@\n-pdfdir = @pdfdir@\n-prefix = @prefix@\n-program_transform_name = @program_transform_name@\n-psdir = @psdir@\n-sbindir = @sbindir@\n-sharedstatedir = @sharedstatedir@\n-srcdir = @srcdir@\n-sysconfdir = @sysconfdir@\n-target = @target@\n-target_alias = @target_alias@\n-target_all = @target_all@\n-target_cpu = @target_cpu@\n-target_noncanonical = @target_noncanonical@\n-target_os = @target_os@\n-target_vendor = @target_vendor@\n-toolexecdir = @toolexecdir@\n-toolexeclibdir = @toolexeclibdir@\n-top_build_prefix = @top_build_prefix@\n-top_builddir = @top_builddir@\n-top_srcdir = @top_srcdir@\n-AUTOMAKE_OPTIONS = foreign subdir-objects no-dist\n-ACLOCAL_AMFLAGS = -I .. -I ../config\n-SUBDIRS = include testsuite\n-noinst_LTLIBRARIES = libgcjgc.la libgcjgc_convenience.la\n-@POWERPC_DARWIN_FALSE@asm_libgcjgc_sources = \n-@POWERPC_DARWIN_TRUE@asm_libgcjgc_sources = powerpc_darwin_mach_dep.s\n-libgcjgc_la_SOURCES = allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c \\\n-dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c \\\n-malloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c \\\n-obj_map.c os_dep.c pcr_interface.c ptr_chck.c real_malloc.c reclaim.c \\\n-specific.c stubborn.c typd_mlc.c \\\n-backgraph.c win32_threads.c \\\n-pthread_support.c pthread_stop_world.c darwin_stop_world.c \\\n-$(asm_libgcjgc_sources)\n-\n-libgcjgc_convenience_la_SOURCES = $(libgcjgc_la_SOURCES)\n-EXTRA_DIST = alpha_mach_dep.S \\\n-mips_sgi_mach_dep.s mips_ultrix_mach_dep.s powerpc_darwin_mach_dep.s \\\n-rs6000_mach_dep.s sparc_mach_dep.S sparc_netbsd_mach_dep.s \\\n-sparc_sunos4_mach_dep.s ia64_save_regs_in_stack.s\n-\n-\n-# Include THREADLIBS here to ensure that the correct versions of\n-# linuxthread semaphore functions get linked:\n-libgcjgc_la_LIBADD = $(addobjs) $(THREADLIBS) $(EXTRA_TEST_LIBS)\n-libgcjgc_la_DEPENDENCIES = $(addobjs)\n-libgcjgc_la_LDFLAGS = $(extra_ldflags_libgc) -version-info 1:2:0 -rpath $(toolexeclibdir)\n-libgcjgc_la_LINK = $(LINK) $(libgcjgc_la_LDFLAGS)\n-libgcjgc_convenience_la_LIBADD = $(addobjs)\n-libgcjgc_convenience_la_DEPENDENCIES = $(addobjs)\n-AM_CXXFLAGS = $(GC_CFLAGS) $(THREADCFLAGS)\n-AM_CFLAGS = $(GC_CFLAGS) $(THREADCFLAGS)\n-AM_LDFLAGS = $(shell $(top_srcdir)/../libtool-ldflags $(LDFLAGS))\n-\n-# Work around what appears to be a GNU make bug handling MAKEFLAGS\n-# values defined in terms of make variables, as is the case for CC and\n-# friends when we are called from the top level Makefile.\n-AM_MAKEFLAGS = \\\n-\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n-\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n-\t\"CFLAGS=$(CFLAGS)\" \\\n-\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n-\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n-\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n-\t\"INSTALL=$(INSTALL)\" \\\n-\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n-\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n-\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n-\t\"LDFLAGS=$(LDFLAGS)\" \\\n-\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\"MAKE=$(MAKE)\" \\\n-\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n-\t\"PICFLAG=$(PICFLAG)\" \\\n-\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n-\t\"SHELL=$(SHELL)\" \\\n-\t\"EXPECT=$(EXPECT)\" \\\n-\t\"RUNTEST=$(RUNTEST)\" \\\n-\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n-\t\"exec_prefix=$(exec_prefix)\" \\\n-\t\"infodir=$(infodir)\" \\\n-\t\"libdir=$(libdir)\" \\\n-\t\"prefix=$(prefix)\" \\\n-\t\"tooldir=$(tooldir)\" \\\n-\t\"AR=$(AR)\" \\\n-\t\"AS=$(AS)\" \\\n-\t\"CC=$(CC)\" \\\n-\t\"CXX=$(CXX)\" \\\n-\t\"LD=$(LD)\" \\\n-\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-\t\"NM=$(NM)\" \\\n-\t\"PICFLAG=$(PICFLAG)\" \\\n-\t\"RANLIB=$(RANLIB)\" \\\n-\t\"DESTDIR=$(DESTDIR)\"\n-\n-CONFIG_STATUS_DEPENDENCIES = $(srcdir)/configure.host\n-MAKEOVERRIDES = \n-all: all-recursive\n-\n-.SUFFIXES:\n-.SUFFIXES: .S .c .lo .o .obj .s\n-am--refresh: Makefile\n-\t@:\n-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n-\t@for dep in $?; do \\\n-\t  case '$(am__configure_deps)' in \\\n-\t    *$$dep*) \\\n-\t      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \\\n-\t      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \\\n-\t\t&& exit 0; \\\n-\t      exit 1;; \\\n-\t  esac; \\\n-\tdone; \\\n-\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \\\n-\t$(am__cd) $(top_srcdir) && \\\n-\t  $(AUTOMAKE) --foreign Makefile\n-.PRECIOUS: Makefile\n-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n-\t@case '$?' in \\\n-\t  *config.status*) \\\n-\t    echo ' $(SHELL) ./config.status'; \\\n-\t    $(SHELL) ./config.status;; \\\n-\t  *) \\\n-\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n-\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n-\tesac;\n-\n-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n-\t$(SHELL) ./config.status --recheck\n-\n-$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n-\t$(am__cd) $(srcdir) && $(AUTOCONF)\n-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n-\t$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)\n-$(am__aclocal_m4_deps):\n-threads.mk: $(top_builddir)/config.status $(srcdir)/threads.mk.in\n-\tcd $(top_builddir) && $(SHELL) ./config.status $@\n-\n-clean-noinstLTLIBRARIES:\n-\t-test -z \"$(noinst_LTLIBRARIES)\" || rm -f $(noinst_LTLIBRARIES)\n-\t@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \\\n-\t  dir=\"`echo $$p | sed -e 's|/[^/]*$$||'`\"; \\\n-\t  test \"$$dir\" != \"$$p\" || dir=.; \\\n-\t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n-\t  rm -f \"$${dir}/so_locations\"; \\\n-\tdone\n-libgcjgc.la: $(libgcjgc_la_OBJECTS) $(libgcjgc_la_DEPENDENCIES) $(EXTRA_libgcjgc_la_DEPENDENCIES) \n-\t$(libgcjgc_la_LINK)  $(libgcjgc_la_OBJECTS) $(libgcjgc_la_LIBADD) $(LIBS)\n-libgcjgc_convenience.la: $(libgcjgc_convenience_la_OBJECTS) $(libgcjgc_convenience_la_DEPENDENCIES) $(EXTRA_libgcjgc_convenience_la_DEPENDENCIES) \n-\t$(LINK)  $(libgcjgc_convenience_la_OBJECTS) $(libgcjgc_convenience_la_LIBADD) $(LIBS)\n-\n-mostlyclean-compile:\n-\t-rm -f *.$(OBJEXT)\n-\n-distclean-compile:\n-\t-rm -f *.tab.c\n-\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/allchblk.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/alloc.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/backgraph.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/blacklst.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/checksums.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/darwin_stop_world.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dbg_mlc.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dyn_load.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/finalize.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gc_dlopen.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gcj_mlc.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/headers.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/malloc.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mallocx.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mark.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mark_rts.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/misc.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/new_hblk.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/obj_map.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/os_dep.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pcr_interface.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pthread_stop_world.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pthread_support.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ptr_chck.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/real_malloc.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/reclaim.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/specific.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/stubborn.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/typd_mlc.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/win32_threads.Plo@am__quote@\n-\n-.c.o:\n-@am__fastdepCC_TRUE@\tdepbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\\.o$$||'`;\\\n-@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\\\n-@am__fastdepCC_TRUE@\t$(am__mv) $$depbase.Tpo $$depbase.Po\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(COMPILE) -c -o $@ $<\n-\n-.c.obj:\n-@am__fastdepCC_TRUE@\tdepbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\\.obj$$||'`;\\\n-@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ `$(CYGPATH_W) '$<'` &&\\\n-@am__fastdepCC_TRUE@\t$(am__mv) $$depbase.Tpo $$depbase.Po\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n-\n-.c.lo:\n-@am__fastdepCC_TRUE@\tdepbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\\.lo$$||'`;\\\n-@am__fastdepCC_TRUE@\t$(LTCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\\\n-@am__fastdepCC_TRUE@\t$(am__mv) $$depbase.Tpo $$depbase.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LTCOMPILE) -c -o $@ $<\n-\n-.s.o:\n-\t$(CCASCOMPILE) -c -o $@ $<\n-\n-.s.obj:\n-\t$(CCASCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n-\n-mostlyclean-libtool:\n-\t-rm -f *.lo\n-\n-clean-libtool:\n-\t-rm -rf .libs _libs\n-\n-distclean-libtool:\n-\t-rm -f libtool config.lt\n-\n-# GNU Make needs to see an explicit $(MAKE) variable in the command it\n-# runs to enable its job server during parallel builds.  Hence the\n-# comments below.\n-all-multi:\n-\t$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)\n-install-multi:\n-\t$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do # $(MAKE)\n-\n-mostlyclean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean # $(MAKE)\n-clean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean # $(MAKE)\n-distclean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean # $(MAKE)\n-maintainer-clean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean # $(MAKE)\n-\n-# This directory's subdirectories are mostly independent; you can cd\n-# into them and run `make' without going through this Makefile.\n-# To change the values of `make' variables: instead of editing Makefiles,\n-# (1) if the variable is set in `config.status', edit `config.status'\n-#     (which will cause the Makefiles to be regenerated when you run `make');\n-# (2) otherwise, pass the desired values on the `make' command line.\n-$(RECURSIVE_TARGETS):\n-\t@fail= failcom='exit 1'; \\\n-\tfor f in x $$MAKEFLAGS; do \\\n-\t  case $$f in \\\n-\t    *=* | --[!k]*);; \\\n-\t    *k*) failcom='fail=yes';; \\\n-\t  esac; \\\n-\tdone; \\\n-\tdot_seen=no; \\\n-\ttarget=`echo $@ | sed s/-recursive//`; \\\n-\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n-\t  echo \"Making $$target in $$subdir\"; \\\n-\t  if test \"$$subdir\" = \".\"; then \\\n-\t    dot_seen=yes; \\\n-\t    local_target=\"$$target-am\"; \\\n-\t  else \\\n-\t    local_target=\"$$target\"; \\\n-\t  fi; \\\n-\t  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n-\t  || eval $$failcom; \\\n-\tdone; \\\n-\tif test \"$$dot_seen\" = \"no\"; then \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) \"$$target-am\" || exit 1; \\\n-\tfi; test -z \"$$fail\"\n-\n-$(RECURSIVE_CLEAN_TARGETS):\n-\t@fail= failcom='exit 1'; \\\n-\tfor f in x $$MAKEFLAGS; do \\\n-\t  case $$f in \\\n-\t    *=* | --[!k]*);; \\\n-\t    *k*) failcom='fail=yes';; \\\n-\t  esac; \\\n-\tdone; \\\n-\tdot_seen=no; \\\n-\tcase \"$@\" in \\\n-\t  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \\\n-\t  *) list='$(SUBDIRS)' ;; \\\n-\tesac; \\\n-\trev=''; for subdir in $$list; do \\\n-\t  if test \"$$subdir\" = \".\"; then :; else \\\n-\t    rev=\"$$subdir $$rev\"; \\\n-\t  fi; \\\n-\tdone; \\\n-\trev=\"$$rev .\"; \\\n-\ttarget=`echo $@ | sed s/-recursive//`; \\\n-\tfor subdir in $$rev; do \\\n-\t  echo \"Making $$target in $$subdir\"; \\\n-\t  if test \"$$subdir\" = \".\"; then \\\n-\t    local_target=\"$$target-am\"; \\\n-\t  else \\\n-\t    local_target=\"$$target\"; \\\n-\t  fi; \\\n-\t  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n-\t  || eval $$failcom; \\\n-\tdone && test -z \"$$fail\"\n-tags-recursive:\n-\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n-\t  test \"$$subdir\" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \\\n-\tdone\n-ctags-recursive:\n-\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n-\t  test \"$$subdir\" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \\\n-\tdone\n-\n-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n-\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n-\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n-\tmkid -fID $$unique\n-tags: TAGS\n-\n-TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n-\t\t$(TAGS_FILES) $(LISP)\n-\tset x; \\\n-\there=`pwd`; \\\n-\tif ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \\\n-\t  include_option=--etags-include; \\\n-\t  empty_fix=.; \\\n-\telse \\\n-\t  include_option=--include; \\\n-\t  empty_fix=; \\\n-\tfi; \\\n-\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n-\t  if test \"$$subdir\" = .; then :; else \\\n-\t    test ! -f $$subdir/TAGS || \\\n-\t      set \"$$@\" \"$$include_option=$$here/$$subdir/TAGS\"; \\\n-\t  fi; \\\n-\tdone; \\\n-\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n-\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n-\tshift; \\\n-\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n-\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n-\t  if test $$# -gt 0; then \\\n-\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n-\t      \"$$@\" $$unique; \\\n-\t  else \\\n-\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n-\t      $$unique; \\\n-\t  fi; \\\n-\tfi\n-ctags: CTAGS\n-CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n-\t\t$(TAGS_FILES) $(LISP)\n-\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n-\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n-\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n-\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n-\t     $$unique\n-\n-GTAGS:\n-\there=`$(am__cd) $(top_builddir) && pwd` \\\n-\t  && $(am__cd) $(top_srcdir) \\\n-\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n-\n-distclean-tags:\n-\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n-check-am: all-am\n-check: check-recursive\n-all-am: Makefile $(LTLIBRARIES) all-multi\n-installdirs: installdirs-recursive\n-installdirs-am:\n-install: install-recursive\n-install-exec: install-exec-recursive\n-install-data: install-data-recursive\n-uninstall: uninstall-recursive\n-\n-install-am: all-am\n-\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n-\n-installcheck: installcheck-recursive\n-install-strip:\n-\tif test -z '$(STRIP)'; then \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t      install; \\\n-\telse \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t    \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\" install; \\\n-\tfi\n-mostlyclean-generic:\n-\n-clean-generic:\n-\n-distclean-generic:\n-\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n-\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n-\n-maintainer-clean-generic:\n-\t@echo \"This command is intended for maintainers to use\"\n-\t@echo \"it deletes files that may require special tools to rebuild.\"\n-clean: clean-multi clean-recursive\n-\n-clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \\\n-\tmostlyclean-am\n-\n-distclean: distclean-multi distclean-recursive\n-\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf ./$(DEPDIR)\n-\t-rm -f Makefile\n-distclean-am: clean-am distclean-compile distclean-generic \\\n-\tdistclean-libtool distclean-tags\n-\n-dvi: dvi-recursive\n-\n-dvi-am:\n-\n-html: html-recursive\n-\n-html-am:\n-\n-info: info-recursive\n-\n-info-am:\n-\n-install-data-am:\n-\n-install-dvi: install-dvi-recursive\n-\n-install-dvi-am:\n-\n-install-exec-am: install-multi\n-\n-install-html: install-html-recursive\n-\n-install-html-am:\n-\n-install-info: install-info-recursive\n-\n-install-info-am:\n-\n-install-man:\n-\n-install-pdf: install-pdf-recursive\n-\n-install-pdf-am:\n-\n-install-ps: install-ps-recursive\n-\n-install-ps-am:\n-\n-installcheck-am:\n-\n-maintainer-clean: maintainer-clean-multi maintainer-clean-recursive\n-\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf $(top_srcdir)/autom4te.cache\n-\t-rm -rf ./$(DEPDIR)\n-\t-rm -f Makefile\n-maintainer-clean-am: distclean-am maintainer-clean-generic\n-\n-mostlyclean: mostlyclean-multi mostlyclean-recursive\n-\n-mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n-\tmostlyclean-libtool\n-\n-pdf: pdf-recursive\n-\n-pdf-am:\n-\n-ps: ps-recursive\n-\n-ps-am:\n-\n-uninstall-am:\n-\n-.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) all-multi \\\n-\tclean-multi ctags-recursive distclean-multi install-am \\\n-\tinstall-multi install-strip maintainer-clean-multi \\\n-\tmostlyclean-multi tags-recursive\n-\n-.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \\\n-\tall all-am all-multi am--refresh check check-am clean \\\n-\tclean-generic clean-libtool clean-multi \\\n-\tclean-noinstLTLIBRARIES ctags ctags-recursive distclean \\\n-\tdistclean-compile distclean-generic distclean-libtool \\\n-\tdistclean-multi distclean-tags dvi dvi-am html html-am info \\\n-\tinfo-am install install-am install-data install-data-am \\\n-\tinstall-dvi install-dvi-am install-exec install-exec-am \\\n-\tinstall-html install-html-am install-info install-info-am \\\n-\tinstall-man install-multi install-pdf install-pdf-am \\\n-\tinstall-ps install-ps-am install-strip installcheck \\\n-\tinstallcheck-am installdirs installdirs-am maintainer-clean \\\n-\tmaintainer-clean-generic maintainer-clean-multi mostlyclean \\\n-\tmostlyclean-compile mostlyclean-generic mostlyclean-libtool \\\n-\tmostlyclean-multi pdf pdf-am ps ps-am tags tags-recursive \\\n-\tuninstall uninstall-am\n-\n-override CFLAGS := $(filter-out $(O0_CFLAGS), $(CFLAGS)) $(O0_CFLAGS)\n-\n-.s.lo:\n-\t$(LTCOMPILE) -Wp,-P -x assembler-with-cpp -c $<\n-.S.lo:\n-\t$(LTCOMPILE) -Wp,-P -x assembler-with-cpp -c $<\n-\n-# Tell versions [3.59,3.63) of GNU make to not export all variables.\n-# Otherwise a system limit (for SysV at least) may be exceeded.\n-.NOEXPORT:"}, {"sha": "d1b6a5d6f1f78496805dab22cc8c29cd49ea46b8", "filename": "boehm-gc/NT_MAKEFILE", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FNT_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FNT_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FNT_MAKEFILE?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,60 +0,0 @@\n-# Makefile for Windows NT.  Assumes Microsoft compiler, and a single thread.\n-# DLLs are included in the root set under NT, but not under win32S.\n-# Use \"nmake nodebug=1 all\" for optimized versions of library, gctest and editor.\n-\n-MY_CPU=X86\n-CPU=$(MY_CPU)\n-!include <ntwin32.mak>\n-\n-OBJS= alloc.obj reclaim.obj allchblk.obj misc.obj mach_dep.obj os_dep.obj mark_rts.obj headers.obj mark.obj obj_map.obj blacklst.obj finalize.obj new_hblk.obj dbg_mlc.obj malloc.obj stubborn.obj dyn_load.obj typd_mlc.obj ptr_chck.obj gc_cpp.obj mallocx.obj\n-\n-all: gctest.exe cord\\de.exe test_cpp.exe\n-\n-.c.obj:\n-\t$(cc) $(cdebug) $(cflags) $(cvars) -Iinclude -DSILENT -DALL_INTERIOR_POINTERS -D__STDC__ -DGC_NOT_DLL -DGC_BUILD $*.c /Fo$*.obj\n-\n-.cpp.obj:\n-\t$(cc) $(cdebug) $(cflags) $(cvars) -Iinclude -DSILENT -DALL_INTERIOR_POINTERS -DGC_NOT_DLL -DGC_BUILD $*.CPP /Fo$*.obj\n-\n-$(OBJS) tests\\test.obj: include\\private\\gc_priv.h include\\private\\gc_hdrs.h include\\gc.h include\\private\\gcconfig.h include\\private\\gc_locks.h include\\private\\gc_pmark.h include\\gc_mark.h\n-\n-gc.lib: $(OBJS)\n-\tlib /MACHINE:i386 /out:gc.lib $(OBJS)\n-# The original NT SDK used lib32 instead of lib\n-\n-gctest.exe: tests\\test.obj gc.lib\n-#\tThe following works for win32 debugging.  For win32s debugging use debugtype:coff\n-#\tand add mapsympe line.\n-#  This produces a \"GUI\" applications that opens no windows and writes to the log file\n-#  \"gc.log\".  This is done to make the result runnable under win32s.\n-\t$(link) -debug:full -debugtype:cv $(guiflags) -stack:131072 -out:$*.exe tests\\test.obj $(guilibs) gc.lib\n-#\tmapsympe -n -o gctest.sym gctest.exe\n-\n-cord\\de_win.rbj: cord\\de_win.res\n-\tcvtres /MACHINE:$(MY_CPU) /OUT:cord\\de_win.rbj cord\\de_win.res\n-\n-cord\\de.obj cord\\de_win.obj: include\\cord.h include\\private\\cord_pos.h cord\\de_win.h cord\\de_cmds.h\n-\n-cord\\de_win.res: cord\\de_win.rc cord\\de_win.h cord\\de_cmds.h\n-\t$(rc) $(rcvars) -r -fo cord\\de_win.res $(cvars) cord\\de_win.rc\n-\n-# Cord/de is a real win32 gui application.\n-cord\\de.exe: cord\\cordbscs.obj cord\\cordxtra.obj cord\\de.obj cord\\de_win.obj cord\\de_win.rbj gc.lib\n-\t$(link) -debug:full -debugtype:cv $(guiflags) -stack:16384 -out:cord\\de.exe  cord\\cordbscs.obj cord\\cordxtra.obj cord\\de.obj cord\\de_win.obj cord\\de_win.rbj gc.lib $(guilibs)\n-\n-gc_cpp.obj: include\\gc_cpp.h include\\gc.h\n-\n-gc_cpp.cpp: gc_cpp.cc\n-\tcopy gc_cpp.cc gc_cpp.cpp\n-\n-test_cpp.cpp: tests\\test_cpp.cc\n-\tcopy tests\\test_cpp.cc test_cpp.cpp\n-\n-# This generates the C++ test executable.  The executable expects\n-# a single numeric argument, which is the number of iterations.\n-# The output appears in the file \"gc.log\".\n-test_cpp.exe: test_cpp.obj include\\gc_cpp.h include\\gc.h gc.lib\n-\t$(link) -debug:full -debugtype:cv $(guiflags) -stack:16384 -out:test_cpp.exe test_cpp.obj gc.lib $(guilibs)\n-\n-\n-"}, {"sha": "a7582af620b821f7d7fca00e9c875a2a7e1c7a9b", "filename": "boehm-gc/NT_STATIC_THREADS_MAKEFILE", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FNT_STATIC_THREADS_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FNT_STATIC_THREADS_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FNT_STATIC_THREADS_MAKEFILE?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,60 +0,0 @@\n-# Makefile for Windows NT.  Assumes Microsoft compiler.\n-# DLLs are included in the root set under NT, but not under win32S.\n-# Use \"nmake nodebug=1 all\" for optimized versions of library, gctest and editor.\n-\n-MY_CPU=X86\n-CPU=$(MY_CPU)\n-!include <ntwin32.mak>\n-\n-OBJS= alloc.obj reclaim.obj allchblk.obj misc.obj mach_dep.obj os_dep.obj mark_rts.obj headers.obj mark.obj obj_map.obj blacklst.obj finalize.obj new_hblk.obj dbg_mlc.obj malloc.obj stubborn.obj dyn_load.obj typd_mlc.obj ptr_chck.obj gc_cpp.obj mallocx.obj win32_threads.obj\n-\n-all: gctest.exe cord\\de.exe test_cpp.exe\n-\n-.c.obj:\n-\t$(cc) $(cdebug) $(cflags) $(cvars) -Iinclude -DSILENT -DALL_INTERIOR_POINTERS -D__STDC__ -DGC_NOT_DLL -DGC_WIN32_THREADS $*.c /Fo$*.obj\n-\n-.cpp.obj:\n-\t$(cc) $(cdebug) $(cflags) $(cvars) -Iinclude -DSILENT -DALL_INTERIOR_POINTERS -DGC_NOT_DLL $*.CPP -DGC_WIN32_THREADS /Fo$*.obj\n-\n-$(OBJS) tests\\test.obj: include\\private\\gc_priv.h include\\private\\gc_hdrs.h include\\gc.h include\\private\\gcconfig.h include\\private\\gc_locks.h include\\private\\gc_pmark.h include\\gc_mark.h\n-\n-gc.lib: $(OBJS)\n-\tlib /MACHINE:i386 /out:gc.lib $(OBJS)\n-# The original NT SDK used lib32 instead of lib\n-\n-gctest.exe: tests\\test.obj gc.lib\n-#\tThe following works for win32 debugging.  For win32s debugging use debugtype:coff\n-#\tand add mapsympe line.\n-#  This produces a \"GUI\" applications that opens no windows and writes to the log file\n-#  \"gc.log\".  This is done to make the result runnable under win32s.\n-\t$(link) -debug:full -debugtype:cv $(guiflags) -stack:131072 -out:$*.exe tests\\test.obj $(guilibs) gc.lib\n-#\tmapsympe -n -o gctest.sym gctest.exe\n-\n-cord\\de_win.rbj: cord\\de_win.res\n-\tcvtres /MACHINE:$(MY_CPU) /OUT:cord\\de_win.rbj cord\\de_win.res\n-\n-cord\\de.obj cord\\de_win.obj: include\\cord.h include\\private\\cord_pos.h cord\\de_win.h cord\\de_cmds.h\n-\n-cord\\de_win.res: cord\\de_win.rc cord\\de_win.h cord\\de_cmds.h\n-\t$(rc) $(rcvars) -r -fo cord\\de_win.res $(cvars) cord\\de_win.rc\n-\n-# Cord/de is a real win32 gui application.\n-cord\\de.exe: cord\\cordbscs.obj cord\\cordxtra.obj cord\\de.obj cord\\de_win.obj cord\\de_win.rbj gc.lib\n-\t$(link) -debug:full -debugtype:cv $(guiflags) -stack:16384 -out:cord\\de.exe  cord\\cordbscs.obj cord\\cordxtra.obj cord\\de.obj cord\\de_win.obj cord\\de_win.rbj gc.lib $(guilibs)\n-\n-gc_cpp.obj: include\\gc_cpp.h include\\gc.h\n-\n-gc_cpp.cpp: gc_cpp.cc\n-\tcopy gc_cpp.cc gc_cpp.cpp\n-\n-test_cpp.cpp: tests\\test_cpp.cc\n-\tcopy tests\\test_cpp.cc test_cpp.cpp\n-\n-# This generates the C++ test executable.  The executable expects\n-# a single numeric argument, which is the number of iterations.\n-# The output appears in the file \"gc.log\".\n-test_cpp.exe: test_cpp.obj include\\gc_cpp.h include\\gc.h gc.lib\n-\t$(link) -debug:full -debugtype:cv $(guiflags) -stack:16384 -out:test_cpp.exe test_cpp.obj gc.lib $(guilibs)\n-\n-\n-"}, {"sha": "5f0b5462427db7a24abf786c844b8ba97ecb2e29", "filename": "boehm-gc/NT_THREADS_MAKEFILE", "status": "removed", "additions": 0, "deletions": 2158, "changes": 2158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FNT_THREADS_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FNT_THREADS_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FNT_THREADS_MAKEFILE?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,2158 +0,0 @@\n-# Microsoft Developer Studio Generated NMAKE File, Format Version 4.10\n-# This has been hand-edited way too many times.\n-# A clean, manually generated makefile would be an improvement.\n-\n-# TARGTYPE \"Win32 (x86) Application\" 0x0101\n-# TARGTYPE \"Win32 (x86) Dynamic-Link Library\" 0x0102\n-\n-!IF \"$(CFG)\" == \"\"\n-CFG=gctest - Win32 Release\n-!MESSAGE No configuration specified.  Defaulting to cord - Win32 Debug.\n-!ENDIF \n-\n-!IF \"$(CFG)\" != \"gc - Win32 Release\" && \"$(CFG)\" != \"gc - Win32 Debug\" &&\\\n- \"$(CFG)\" != \"gctest - Win32 Release\" && \"$(CFG)\" != \"gctest - Win32 Debug\" &&\\\n- \"$(CFG)\" != \"cord - Win32 Release\" && \"$(CFG)\" != \"cord - Win32 Debug\"\n-!MESSAGE Invalid configuration \"$(CFG)\" specified.\n-!MESSAGE You can specify a configuration when running NMAKE on this makefile\n-!MESSAGE by defining the macro CFG on the command line.  For example:\n-!MESSAGE \n-!MESSAGE NMAKE /f \"gc.mak\" CFG=\"cord - Win32 Debug\"\n-!MESSAGE \n-!MESSAGE Possible choices for configuration are:\n-!MESSAGE \n-!MESSAGE \"gc - Win32 Release\" (based on \"Win32 (x86) Dynamic-Link Library\")\n-!MESSAGE \"gc - Win32 Debug\" (based on \"Win32 (x86) Dynamic-Link Library\")\n-!MESSAGE \"gctest - Win32 Release\" (based on \"Win32 (x86) Application\")\n-!MESSAGE \"gctest - Win32 Debug\" (based on \"Win32 (x86) Application\")\n-!MESSAGE \"cord - Win32 Release\" (based on \"Win32 (x86) Application\")\n-!MESSAGE \"cord - Win32 Debug\" (based on \"Win32 (x86) Application\")\n-!MESSAGE \n-!ERROR An invalid configuration is specified.\n-!ENDIF \n-\n-!IF \"$(OS)\" == \"Windows_NT\"\n-NULL=\n-!ELSE \n-NULL=nul\n-!ENDIF \n-################################################################################\n-# Begin Project\n-# PROP Target_Last_Scanned \"gctest - Win32 Debug\"\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-# PROP BASE Use_MFC 0\n-# PROP BASE Use_Debug_Libraries 0\n-# PROP BASE Output_Dir \"Release\"\n-# PROP BASE Intermediate_Dir \"Release\"\n-# PROP BASE Target_Dir \"\"\n-# PROP Use_MFC 0\n-# PROP Use_Debug_Libraries 0\n-# PROP Output_Dir \"Release\"\n-# PROP Intermediate_Dir \"Release\"\n-# PROP Target_Dir \"\"\n-OUTDIR=.\\Release\n-INTDIR=.\\Release\n-\n-ALL : \".\\Release\\gc.dll\" \".\\Release\\gc.bsc\"\n-\n-CLEAN : \n-\t-@erase \".\\Release\\allchblk.obj\"\n-\t-@erase \".\\Release\\allchblk.sbr\"\n-\t-@erase \".\\Release\\alloc.obj\"\n-\t-@erase \".\\Release\\alloc.sbr\"\n-\t-@erase \".\\Release\\blacklst.obj\"\n-\t-@erase \".\\Release\\blacklst.sbr\"\n-\t-@erase \".\\Release\\checksums.obj\"\n-\t-@erase \".\\Release\\checksums.sbr\"\n-\t-@erase \".\\Release\\dbg_mlc.obj\"\n-\t-@erase \".\\Release\\dbg_mlc.sbr\"\n-\t-@erase \".\\Release\\dyn_load.obj\"\n-\t-@erase \".\\Release\\dyn_load.sbr\"\n-\t-@erase \".\\Release\\finalize.obj\"\n-\t-@erase \".\\Release\\finalize.sbr\"\n-\t-@erase \".\\Release\\gc.bsc\"\n-\t-@erase \".\\Release\\gc_cpp.obj\"\n-\t-@erase \".\\Release\\gc_cpp.sbr\"\n-\t-@erase \".\\Release\\gc.dll\"\n-\t-@erase \".\\Release\\gc.exp\"\n-\t-@erase \".\\Release\\gc.lib\"\n-\t-@erase \".\\Release\\headers.obj\"\n-\t-@erase \".\\Release\\headers.sbr\"\n-\t-@erase \".\\Release\\mach_dep.obj\"\n-\t-@erase \".\\Release\\mach_dep.sbr\"\n-\t-@erase \".\\Release\\malloc.obj\"\n-\t-@erase \".\\Release\\malloc.sbr\"\n-\t-@erase \".\\Release\\mallocx.obj\"\n-\t-@erase \".\\Release\\mallocx.sbr\"\n-\t-@erase \".\\Release\\mark.obj\"\n-\t-@erase \".\\Release\\mark.sbr\"\n-\t-@erase \".\\Release\\mark_rts.obj\"\n-\t-@erase \".\\Release\\mark_rts.sbr\"\n-\t-@erase \".\\Release\\misc.obj\"\n-\t-@erase \".\\Release\\misc.sbr\"\n-\t-@erase \".\\Release\\new_hblk.obj\"\n-\t-@erase \".\\Release\\new_hblk.sbr\"\n-\t-@erase \".\\Release\\obj_map.obj\"\n-\t-@erase \".\\Release\\obj_map.sbr\"\n-\t-@erase \".\\Release\\os_dep.obj\"\n-\t-@erase \".\\Release\\os_dep.sbr\"\n-\t-@erase \".\\Release\\ptr_chck.obj\"\n-\t-@erase \".\\Release\\ptr_chck.sbr\"\n-\t-@erase \".\\Release\\reclaim.obj\"\n-\t-@erase \".\\Release\\reclaim.sbr\"\n-\t-@erase \".\\Release\\stubborn.obj\"\n-\t-@erase \".\\Release\\stubborn.sbr\"\n-\t-@erase \".\\Release\\typd_mlc.obj\"\n-\t-@erase \".\\Release\\typd_mlc.sbr\"\n-\t-@erase \".\\Release\\win32_threads.obj\"\n-\t-@erase \".\\Release\\win32_threads.sbr\"\n-\n-\"$(OUTDIR)\" :\n-    if not exist \"$(OUTDIR)/$(NULL)\" mkdir \"$(OUTDIR)\"\n-\n-CPP=cl.exe\n-# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"GC_WIN32_THREADS\" /FR /YX /c\n-CPP_PROJ=/nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D\\\n- \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D\\\n- \"GC_WIN32_THREADS\" /FR\"$(INTDIR)/\" /Fp\"$(INTDIR)/gc.pch\" /YX /Fo\"$(INTDIR)/\" /c \n-CPP_OBJS=.\\Release/\n-CPP_SBRS=.\\Release/\n-\n-.c{$(CPP_OBJS)}.obj:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cpp{$(CPP_OBJS)}.obj:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cxx{$(CPP_OBJS)}.obj:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.c{$(CPP_SBRS)}.sbr:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cpp{$(CPP_SBRS)}.sbr:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cxx{$(CPP_SBRS)}.sbr:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-MTL=mktyplib.exe\n-# ADD BASE MTL /nologo /D \"NDEBUG\" /win32\n-# ADD MTL /nologo /D \"NDEBUG\" /win32\n-MTL_PROJ=/nologo /D \"NDEBUG\" /win32 \n-RSC=rc.exe\n-# ADD BASE RSC /l 0x809 /d \"NDEBUG\"\n-# ADD RSC /l 0x809 /d \"NDEBUG\"\n-BSC32=bscmake.exe\n-# ADD BASE BSC32 /nologo\n-# ADD BSC32 /nologo\n-BSC32_FLAGS=/nologo /o\"$(OUTDIR)/gc.bsc\" \n-BSC32_SBRS= \\\n-\t\".\\Release\\allchblk.sbr\" \\\n-\t\".\\Release\\alloc.sbr\" \\\n-\t\".\\Release\\blacklst.sbr\" \\\n-\t\".\\Release\\checksums.sbr\" \\\n-\t\".\\Release\\dbg_mlc.sbr\" \\\n-\t\".\\Release\\dyn_load.sbr\" \\\n-\t\".\\Release\\finalize.sbr\" \\\n-\t\".\\Release\\gc_cpp.sbr\" \\\n-\t\".\\Release\\headers.sbr\" \\\n-\t\".\\Release\\mach_dep.sbr\" \\\n-\t\".\\Release\\malloc.sbr\" \\\n-\t\".\\Release\\mallocx.sbr\" \\\n-\t\".\\Release\\mark.sbr\" \\\n-\t\".\\Release\\mark_rts.sbr\" \\\n-\t\".\\Release\\misc.sbr\" \\\n-\t\".\\Release\\new_hblk.sbr\" \\\n-\t\".\\Release\\obj_map.sbr\" \\\n-\t\".\\Release\\os_dep.sbr\" \\\n-\t\".\\Release\\ptr_chck.sbr\" \\\n-\t\".\\Release\\reclaim.sbr\" \\\n-\t\".\\Release\\stubborn.sbr\" \\\n-\t\".\\Release\\typd_mlc.sbr\" \\\n-\t\".\\Release\\win32_threads.sbr\"\n-\n-\".\\Release\\gc.bsc\" : \"$(OUTDIR)\" $(BSC32_SBRS)\n-    $(BSC32) @<<\n-  $(BSC32_FLAGS) $(BSC32_SBRS)\n-<<\n-\n-LINK32=link.exe\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /machine:I386\n-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /machine:I386\n-LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\\\n- advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\\\n- odbccp32.lib /nologo /subsystem:windows /dll /incremental:no\\\n- /pdb:\"$(OUTDIR)/gc.pdb\" /machine:I386 /out:\"$(OUTDIR)/gc.dll\"\\\n- /implib:\"$(OUTDIR)/gc.lib\" \n-LINK32_OBJS= \\\n-\t\".\\Release\\allchblk.obj\" \\\n-\t\".\\Release\\alloc.obj\" \\\n-\t\".\\Release\\blacklst.obj\" \\\n-\t\".\\Release\\checksums.obj\" \\\n-\t\".\\Release\\dbg_mlc.obj\" \\\n-\t\".\\Release\\dyn_load.obj\" \\\n-\t\".\\Release\\finalize.obj\" \\\n-\t\".\\Release\\gc_cpp.obj\" \\\n-\t\".\\Release\\headers.obj\" \\\n-\t\".\\Release\\mach_dep.obj\" \\\n-\t\".\\Release\\malloc.obj\" \\\n-\t\".\\Release\\mallocx.obj\" \\\n-\t\".\\Release\\mark.obj\" \\\n-\t\".\\Release\\mark_rts.obj\" \\\n-\t\".\\Release\\misc.obj\" \\\n-\t\".\\Release\\new_hblk.obj\" \\\n-\t\".\\Release\\obj_map.obj\" \\\n-\t\".\\Release\\os_dep.obj\" \\\n-\t\".\\Release\\ptr_chck.obj\" \\\n-\t\".\\Release\\reclaim.obj\" \\\n-\t\".\\Release\\stubborn.obj\" \\\n-\t\".\\Release\\typd_mlc.obj\" \\\n-\t\".\\Release\\win32_threads.obj\"\n-\n-\".\\Release\\gc.dll\" : \"$(OUTDIR)\" $(DEF_FILE) $(LINK32_OBJS)\n-    $(LINK32) @<<\n-  $(LINK32_FLAGS) $(LINK32_OBJS)\n-<<\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-# PROP BASE Use_MFC 0\n-# PROP BASE Use_Debug_Libraries 1\n-# PROP BASE Output_Dir \"Debug\"\n-# PROP BASE Intermediate_Dir \"Debug\"\n-# PROP BASE Target_Dir \"\"\n-# PROP Use_MFC 0\n-# PROP Use_Debug_Libraries 1\n-# PROP Output_Dir \"Debug\"\n-# PROP Intermediate_Dir \"Debug\"\n-# PROP Target_Dir \"\"\n-OUTDIR=.\\Debug\n-INTDIR=.\\Debug\n-\n-ALL : \".\\Debug\\gc.dll\" \".\\Debug\\gc.bsc\"\n-\n-CLEAN : \n-\t-@erase \".\\Debug\\allchblk.obj\"\n-\t-@erase \".\\Debug\\allchblk.sbr\"\n-\t-@erase \".\\Debug\\alloc.obj\"\n-\t-@erase \".\\Debug\\alloc.sbr\"\n-\t-@erase \".\\Debug\\blacklst.obj\"\n-\t-@erase \".\\Debug\\blacklst.sbr\"\n-\t-@erase \".\\Debug\\checksums.obj\"\n-\t-@erase \".\\Debug\\checksums.sbr\"\n-\t-@erase \".\\Debug\\dbg_mlc.obj\"\n-\t-@erase \".\\Debug\\dbg_mlc.sbr\"\n-\t-@erase \".\\Debug\\dyn_load.obj\"\n-\t-@erase \".\\Debug\\dyn_load.sbr\"\n-\t-@erase \".\\Debug\\finalize.obj\"\n-\t-@erase \".\\Debug\\finalize.sbr\"\n-\t-@erase \".\\Debug\\gc_cpp.obj\"\n-\t-@erase \".\\Debug\\gc_cpp.sbr\"\n-\t-@erase \".\\Debug\\gc.bsc\"\n-\t-@erase \".\\Debug\\gc.dll\"\n-\t-@erase \".\\Debug\\gc.exp\"\n-\t-@erase \".\\Debug\\gc.lib\"\n-\t-@erase \".\\Debug\\gc.map\"\n-\t-@erase \".\\Debug\\gc.pdb\"\n-\t-@erase \".\\Debug\\headers.obj\"\n-\t-@erase \".\\Debug\\headers.sbr\"\n-\t-@erase \".\\Debug\\mach_dep.obj\"\n-\t-@erase \".\\Debug\\mach_dep.sbr\"\n-\t-@erase \".\\Debug\\malloc.obj\"\n-\t-@erase \".\\Debug\\malloc.sbr\"\n-\t-@erase \".\\Debug\\mallocx.obj\"\n-\t-@erase \".\\Debug\\mallocx.sbr\"\n-\t-@erase \".\\Debug\\mark.obj\"\n-\t-@erase \".\\Debug\\mark.sbr\"\n-\t-@erase \".\\Debug\\mark_rts.obj\"\n-\t-@erase \".\\Debug\\mark_rts.sbr\"\n-\t-@erase \".\\Debug\\misc.obj\"\n-\t-@erase \".\\Debug\\misc.sbr\"\n-\t-@erase \".\\Debug\\new_hblk.obj\"\n-\t-@erase \".\\Debug\\new_hblk.sbr\"\n-\t-@erase \".\\Debug\\obj_map.obj\"\n-\t-@erase \".\\Debug\\obj_map.sbr\"\n-\t-@erase \".\\Debug\\os_dep.obj\"\n-\t-@erase \".\\Debug\\os_dep.sbr\"\n-\t-@erase \".\\Debug\\ptr_chck.obj\"\n-\t-@erase \".\\Debug\\ptr_chck.sbr\"\n-\t-@erase \".\\Debug\\reclaim.obj\"\n-\t-@erase \".\\Debug\\reclaim.sbr\"\n-\t-@erase \".\\Debug\\stubborn.obj\"\n-\t-@erase \".\\Debug\\stubborn.sbr\"\n-\t-@erase \".\\Debug\\typd_mlc.obj\"\n-\t-@erase \".\\Debug\\typd_mlc.sbr\"\n-\t-@erase \".\\Debug\\vc40.idb\"\n-\t-@erase \".\\Debug\\vc40.pdb\"\n-\t-@erase \".\\Debug\\win32_threads.obj\"\n-\t-@erase \".\\Debug\\win32_threads.sbr\"\n-\n-\"$(OUTDIR)\" :\n-    if not exist \"$(OUTDIR)/$(NULL)\" mkdir \"$(OUTDIR)\"\n-\n-CPP=cl.exe\n-# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /D \"WIN32\" /D \"_DEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I include /D \"_DEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"GC_WIN32_THREADS\" /FR /YX /c\n-CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /I include /D \"_DEBUG\" /D \"SILENT\" /D \"GC_BUILD\"\\\n- /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D\\\n- \"GC_WIN32_THREADS\" /FR\"$(INTDIR)/\" /Fp\"$(INTDIR)/gc.pch\" /YX /Fo\"$(INTDIR)/\"\\\n- /Fd\"$(INTDIR)/\" /c \n-CPP_OBJS=.\\Debug/\n-CPP_SBRS=.\\Debug/\n-\n-.c{$(CPP_OBJS)}.obj:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cpp{$(CPP_OBJS)}.obj:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cxx{$(CPP_OBJS)}.obj:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.c{$(CPP_SBRS)}.sbr:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cpp{$(CPP_SBRS)}.sbr:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cxx{$(CPP_SBRS)}.sbr:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-MTL=mktyplib.exe\n-# ADD BASE MTL /nologo /D \"_DEBUG\" /win32\n-# ADD MTL /nologo /D \"_DEBUG\" /win32\n-MTL_PROJ=/nologo /D \"_DEBUG\" /win32 \n-RSC=rc.exe\n-# ADD BASE RSC /l 0x809 /d \"_DEBUG\"\n-# ADD RSC /l 0x809 /d \"_DEBUG\"\n-BSC32=bscmake.exe\n-# ADD BASE BSC32 /nologo\n-# ADD BSC32 /nologo\n-BSC32_FLAGS=/nologo /o\"$(OUTDIR)/gc.bsc\" \n-BSC32_SBRS= \\\n-\t\".\\Debug\\allchblk.sbr\" \\\n-\t\".\\Debug\\alloc.sbr\" \\\n-\t\".\\Debug\\blacklst.sbr\" \\\n-\t\".\\Debug\\checksums.sbr\" \\\n-\t\".\\Debug\\dbg_mlc.sbr\" \\\n-\t\".\\Debug\\dyn_load.sbr\" \\\n-\t\".\\Debug\\finalize.sbr\" \\\n-\t\".\\Debug\\gc_cpp.sbr\" \\\n-\t\".\\Debug\\headers.sbr\" \\\n-\t\".\\Debug\\mach_dep.sbr\" \\\n-\t\".\\Debug\\malloc.sbr\" \\\n-\t\".\\Debug\\mallocx.sbr\" \\\n-\t\".\\Debug\\mark.sbr\" \\\n-\t\".\\Debug\\mark_rts.sbr\" \\\n-\t\".\\Debug\\misc.sbr\" \\\n-\t\".\\Debug\\new_hblk.sbr\" \\\n-\t\".\\Debug\\obj_map.sbr\" \\\n-\t\".\\Debug\\os_dep.sbr\" \\\n-\t\".\\Debug\\ptr_chck.sbr\" \\\n-\t\".\\Debug\\reclaim.sbr\" \\\n-\t\".\\Debug\\stubborn.sbr\" \\\n-\t\".\\Debug\\typd_mlc.sbr\" \\\n-\t\".\\Debug\\win32_threads.sbr\"\n-\n-\".\\Debug\\gc.bsc\" : \"$(OUTDIR)\" $(BSC32_SBRS)\n-    $(BSC32) @<<\n-  $(BSC32_FLAGS) $(BSC32_SBRS)\n-<<\n-\n-LINK32=link.exe\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /debug /machine:I386\n-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /incremental:no /map /debug /machine:I386\n-LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\\\n- advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\\\n- odbccp32.lib /nologo /subsystem:windows /dll /incremental:no\\\n- /pdb:\"$(OUTDIR)/gc.pdb\" /map:\"$(INTDIR)/gc.map\" /debug /machine:I386\\\n- /out:\"$(OUTDIR)/gc.dll\" /implib:\"$(OUTDIR)/gc.lib\" \n-LINK32_OBJS= \\\n-\t\".\\Debug\\allchblk.obj\" \\\n-\t\".\\Debug\\alloc.obj\" \\\n-\t\".\\Debug\\blacklst.obj\" \\\n-\t\".\\Debug\\checksums.obj\" \\\n-\t\".\\Debug\\dbg_mlc.obj\" \\\n-\t\".\\Debug\\dyn_load.obj\" \\\n-\t\".\\Debug\\finalize.obj\" \\\n-\t\".\\Debug\\gc_cpp.obj\" \\\n-\t\".\\Debug\\headers.obj\" \\\n-\t\".\\Debug\\mach_dep.obj\" \\\n-\t\".\\Debug\\malloc.obj\" \\\n-\t\".\\Debug\\mallocx.obj\" \\\n-\t\".\\Debug\\mark.obj\" \\\n-\t\".\\Debug\\mark_rts.obj\" \\\n-\t\".\\Debug\\misc.obj\" \\\n-\t\".\\Debug\\new_hblk.obj\" \\\n-\t\".\\Debug\\obj_map.obj\" \\\n-\t\".\\Debug\\os_dep.obj\" \\\n-\t\".\\Debug\\ptr_chck.obj\" \\\n-\t\".\\Debug\\reclaim.obj\" \\\n-\t\".\\Debug\\stubborn.obj\" \\\n-\t\".\\Debug\\typd_mlc.obj\" \\\n-\t\".\\Debug\\win32_threads.obj\"\n-\n-\".\\Debug\\gc.dll\" : \"$(OUTDIR)\" $(DEF_FILE) $(LINK32_OBJS)\n-    $(LINK32) @<<\n-  $(LINK32_FLAGS) $(LINK32_OBJS)\n-<<\n-\n-!ELSEIF  \"$(CFG)\" == \"gctest - Win32 Release\"\n-\n-# PROP BASE Use_MFC 0\n-# PROP BASE Use_Debug_Libraries 0\n-# PROP BASE Output_Dir \"gctest\\Release\"\n-# PROP BASE Intermediate_Dir \"gctest\\Release\"\n-# PROP BASE Target_Dir \"gctest\"\n-# PROP Use_MFC 0\n-# PROP Use_Debug_Libraries 0\n-# PROP Output_Dir \"gctest\\Release\"\n-# PROP Intermediate_Dir \"gctest\\Release\"\n-# PROP Target_Dir \"gctest\"\n-OUTDIR=.\\gctest\\Release\n-INTDIR=.\\gctest\\Release\n-\n-ALL : \"gc - Win32 Release\" \".\\Release\\gctest.exe\"\n-\n-CLEAN : \n-\t-@erase \".\\gctest\\Release\\test.obj\"\n-\t-@erase \".\\Release\\gctest.exe\"\n-\n-\"$(OUTDIR)\" :\n-    if not exist \"$(OUTDIR)/$(NULL)\" mkdir \"$(OUTDIR)\"\n-\n-test.c : tests\\test.c\n-\tcopy tests\\test.c test.c\n-\n-CPP=cl.exe\n-# ADD BASE CPP /nologo /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"GC_WIN32_THREADS\" /YX /c\n-CPP_PROJ=/nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D\\\n- \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"GC_WIN32_THREADS\"\\\n- /Fp\"$(INTDIR)/gctest.pch\" /YX /Fo\"$(INTDIR)/\" /c \n-CPP_OBJS=.\\gctest\\Release/\n-CPP_SBRS=.\\.\n-\n-.c{$(CPP_OBJS)}.obj:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cpp{$(CPP_OBJS)}.obj:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cxx{$(CPP_OBJS)}.obj:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.c{$(CPP_SBRS)}.sbr:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cpp{$(CPP_SBRS)}.sbr:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cxx{$(CPP_SBRS)}.sbr:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-MTL=mktyplib.exe\n-# ADD BASE MTL /nologo /D \"NDEBUG\" /win32\n-# ADD MTL /nologo /D \"NDEBUG\" /win32\n-MTL_PROJ=/nologo /D \"NDEBUG\" /win32 \n-RSC=rc.exe\n-# ADD BASE RSC /l 0x809 /d \"NDEBUG\"\n-# ADD RSC /l 0x809 /d \"NDEBUG\"\n-BSC32=bscmake.exe\n-# ADD BASE BSC32 /nologo\n-# ADD BSC32 /nologo\n-BSC32_FLAGS=/nologo /o\"$(OUTDIR)/gctest.bsc\" \n-BSC32_SBRS= \\\n-\t\n-LINK32=link.exe\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /machine:I386\n-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /machine:I386 /out:\"Release/gctest.exe\"\n-LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\\\n- advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\\\n- odbccp32.lib /nologo /subsystem:windows /incremental:no\\\n- /pdb:\"$(OUTDIR)/gctest.pdb\" /machine:I386 /out:\"Release/gctest.exe\" \n-LINK32_OBJS= \\\n-\t\".\\gctest\\Release\\test.obj\" \\\n-\t\".\\Release\\gc.lib\"\n-\n-\".\\Release\\gctest.exe\" : \"$(OUTDIR)\" $(DEF_FILE) $(LINK32_OBJS)\n-    $(LINK32) @<<\n-  $(LINK32_FLAGS) $(LINK32_OBJS)\n-<<\n-\n-!ELSEIF  \"$(CFG)\" == \"gctest - Win32 Debug\"\n-\n-# PROP BASE Use_MFC 0\n-# PROP BASE Use_Debug_Libraries 1\n-# PROP BASE Output_Dir \"gctest\\Debug\"\n-# PROP BASE Intermediate_Dir \"gctest\\Debug\"\n-# PROP BASE Target_Dir \"gctest\"\n-# PROP Use_MFC 0\n-# PROP Use_Debug_Libraries 1\n-# PROP Output_Dir \"gctest\\Debug\"\n-# PROP Intermediate_Dir \"gctest\\Debug\"\n-# PROP Target_Dir \"gctest\"\n-OUTDIR=.\\gctest\\Debug\n-INTDIR=.\\gctest\\Debug\n-\n-ALL : \"gc - Win32 Debug\" \".\\Debug\\gctest.exe\" \".\\gctest\\Debug\\gctest.bsc\"\n-\n-CLEAN : \n-\t-@erase \".\\Debug\\gctest.exe\"\n-\t-@erase \".\\gctest\\Debug\\gctest.bsc\"\n-\t-@erase \".\\gctest\\Debug\\gctest.map\"\n-\t-@erase \".\\gctest\\Debug\\gctest.pdb\"\n-\t-@erase \".\\gctest\\Debug\\test.obj\"\n-\t-@erase \".\\gctest\\Debug\\test.sbr\"\n-\t-@erase \".\\gctest\\Debug\\vc40.idb\"\n-\t-@erase \".\\gctest\\Debug\\vc40.pdb\"\n-\n-\"$(OUTDIR)\" :\n-    if not exist \"$(OUTDIR)/$(NULL)\" mkdir \"$(OUTDIR)\"\n-\n-CPP=cl.exe\n-# ADD BASE CPP /nologo /W3 /Gm /GX /Zi /Od /D \"WIN32\" /D \"_DEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"GC_WIN32_THREADS\" /FR /YX /c\n-CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /I include /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\"\\\n- /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"GC_WIN32_THREADS\" /FR\"$(INTDIR)/\"\\\n- /Fp\"$(INTDIR)/gctest.pch\" /YX /Fo\"$(INTDIR)/\" /Fd\"$(INTDIR)/\" /c \n-CPP_OBJS=.\\gctest\\Debug/\n-CPP_SBRS=.\\gctest\\Debug/\n-\n-.c{$(CPP_OBJS)}.obj:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cpp{$(CPP_OBJS)}.obj:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cxx{$(CPP_OBJS)}.obj:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.c{$(CPP_SBRS)}.sbr:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cpp{$(CPP_SBRS)}.sbr:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cxx{$(CPP_SBRS)}.sbr:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-MTL=mktyplib.exe\n-# ADD BASE MTL /nologo /D \"_DEBUG\" /win32\n-# ADD MTL /nologo /D \"_DEBUG\" /win32\n-MTL_PROJ=/nologo /D \"_DEBUG\" /win32 \n-RSC=rc.exe\n-# ADD BASE RSC /l 0x809 /d \"_DEBUG\"\n-# ADD RSC /l 0x809 /d \"_DEBUG\"\n-BSC32=bscmake.exe\n-# ADD BASE BSC32 /nologo\n-# ADD BSC32 /nologo\n-BSC32_FLAGS=/nologo /o\"$(OUTDIR)/gctest.bsc\" \n-BSC32_SBRS= \\\n-\t\".\\gctest\\Debug\\test.sbr\"\n-\n-\".\\gctest\\Debug\\gctest.bsc\" : \"$(OUTDIR)\" $(BSC32_SBRS)\n-    $(BSC32) @<<\n-  $(BSC32_FLAGS) $(BSC32_SBRS)\n-<<\n-\n-LINK32=link.exe\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /debug /machine:I386\n-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /incremental:no /map /debug /machine:I386 /out:\"Debug/gctest.exe\"\n-LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\\\n- advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\\\n- odbccp32.lib /nologo /subsystem:windows /incremental:no\\\n- /pdb:\"$(OUTDIR)/gctest.pdb\" /map:\"$(INTDIR)/gctest.map\" /debug /machine:I386\\\n- /out:\"Debug/gctest.exe\" \n-LINK32_OBJS= \\\n-\t\".\\Debug\\gc.lib\" \\\n-\t\".\\gctest\\Debug\\test.obj\"\n-\n-\".\\Debug\\gctest.exe\" : \"$(OUTDIR)\" $(DEF_FILE) $(LINK32_OBJS)\n-    $(LINK32) @<<\n-  $(LINK32_FLAGS) $(LINK32_OBJS)\n-<<\n-\n-!ELSEIF  \"$(CFG)\" == \"cord - Win32 Release\"\n-\n-# PROP BASE Use_MFC 0\n-# PROP BASE Use_Debug_Libraries 0\n-# PROP BASE Output_Dir \"cord\\Release\"\n-# PROP BASE Intermediate_Dir \"cord\\Release\"\n-# PROP BASE Target_Dir \"cord\"\n-# PROP Use_MFC 0\n-# PROP Use_Debug_Libraries 0\n-# PROP Output_Dir \"cord\\Release\"\n-# PROP Intermediate_Dir \"cord\\Release\"\n-# PROP Target_Dir \"cord\"\n-OUTDIR=.\\cord\\Release\n-INTDIR=.\\cord\\Release\n-\n-ALL : \"gc - Win32 Release\" \".\\Release\\de.exe\"\n-\n-CLEAN : \n-\t-@erase \".\\cord\\Release\\cordbscs.obj\"\n-\t-@erase \".\\cord\\Release\\cordxtra.obj\"\n-\t-@erase \".\\cord\\Release\\de.obj\"\n-\t-@erase \".\\cord\\Release\\de_win.obj\"\n-\t-@erase \".\\cord\\Release\\de_win.res\"\n-\t-@erase \".\\Release\\de.exe\"\n-\n-\"$(OUTDIR)\" :\n-    if not exist \"$(OUTDIR)/$(NULL)\" mkdir \"$(OUTDIR)\"\n-\n-CPP=cl.exe\n-# ADD BASE CPP /nologo /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MD /W3 /GX /O2 /I \".\" /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /YX /c\n-CPP_PROJ=/nologo /MD /W3 /GX /O2 /I \".\" /I include /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D\\\n- \"ALL_INTERIOR_POINTERS\" /Fp\"$(INTDIR)/cord.pch\" /YX /Fo\"$(INTDIR)/\" /c \n-CPP_OBJS=.\\cord\\Release/\n-CPP_SBRS=.\\.\n-\n-.c{$(CPP_OBJS)}.obj:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cpp{$(CPP_OBJS)}.obj:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cxx{$(CPP_OBJS)}.obj:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.c{$(CPP_SBRS)}.sbr:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cpp{$(CPP_SBRS)}.sbr:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cxx{$(CPP_SBRS)}.sbr:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-MTL=mktyplib.exe\n-# ADD BASE MTL /nologo /D \"NDEBUG\" /win32\n-# ADD MTL /nologo /D \"NDEBUG\" /win32\n-MTL_PROJ=/nologo /D \"NDEBUG\" /win32 \n-RSC=rc.exe\n-# ADD BASE RSC /l 0x809 /d \"NDEBUG\"\n-# ADD RSC /l 0x809 /d \"NDEBUG\"\n-RSC_PROJ=/l 0x809 /fo\"$(INTDIR)/de_win.res\" /d \"NDEBUG\" \n-BSC32=bscmake.exe\n-# ADD BASE BSC32 /nologo\n-# ADD BSC32 /nologo\n-BSC32_FLAGS=/nologo /o\"$(OUTDIR)/cord.bsc\" \n-BSC32_SBRS= \\\n-\t\n-LINK32=link.exe\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /machine:I386\n-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /machine:I386 /out:\"Release/de.exe\"\n-LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\\\n- advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\\\n- odbccp32.lib /nologo /subsystem:windows /incremental:no /pdb:\"$(OUTDIR)/de.pdb\"\\\n- /machine:I386 /out:\"Release/de.exe\" \n-LINK32_OBJS= \\\n-\t\".\\cord\\Release\\cordbscs.obj\" \\\n-\t\".\\cord\\Release\\cordxtra.obj\" \\\n-\t\".\\cord\\Release\\de.obj\" \\\n-\t\".\\cord\\Release\\de_win.obj\" \\\n-\t\".\\cord\\Release\\de_win.res\" \\\n-\t\".\\Release\\gc.lib\"\n-\n-\".\\Release\\de.exe\" : \"$(OUTDIR)\" $(DEF_FILE) $(LINK32_OBJS)\n-    $(LINK32) @<<\n-  $(LINK32_FLAGS) $(LINK32_OBJS)\n-<<\n-\n-!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n-\n-# PROP BASE Use_MFC 0\n-# PROP BASE Use_Debug_Libraries 1\n-# PROP BASE Output_Dir \"cord\\Debug\"\n-# PROP BASE Intermediate_Dir \"cord\\Debug\"\n-# PROP BASE Target_Dir \"cord\"\n-# PROP Use_MFC 0\n-# PROP Use_Debug_Libraries 1\n-# PROP Output_Dir \"cord\\Debug\"\n-# PROP Intermediate_Dir \"cord\\Debug\"\n-# PROP Target_Dir \"cord\"\n-OUTDIR=.\\cord\\Debug\n-INTDIR=.\\cord\\Debug\n-\n-ALL : \"gc - Win32 Debug\" \".\\Debug\\de.exe\"\n-\n-CLEAN : \n-\t-@erase \".\\cord\\Debug\\cordbscs.obj\"\n-\t-@erase \".\\cord\\Debug\\cordxtra.obj\"\n-\t-@erase \".\\cord\\Debug\\de.obj\"\n-\t-@erase \".\\cord\\Debug\\de.pdb\"\n-\t-@erase \".\\cord\\Debug\\de_win.obj\"\n-\t-@erase \".\\cord\\Debug\\de_win.res\"\n-\t-@erase \".\\cord\\Debug\\vc40.idb\"\n-\t-@erase \".\\cord\\Debug\\vc40.pdb\"\n-\t-@erase \".\\Debug\\de.exe\"\n-\t-@erase \".\\Debug\\de.ilk\"\n-\n-\"$(OUTDIR)\" :\n-    if not exist \"$(OUTDIR)/$(NULL)\" mkdir \"$(OUTDIR)\"\n-\n-CPP=cl.exe\n-# ADD BASE CPP /nologo /W3 /Gm /GX /Zi /Od /D \"WIN32\" /D \"_DEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I \".\" /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /YX /c\n-CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /I \".\" /I include /D \"_DEBUG\" /D \"WIN32\" /D\\\n- \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /Fp\"$(INTDIR)/cord.pch\" /YX\\\n- /Fo\"$(INTDIR)/\" /Fd\"$(INTDIR)/\" /c \n-CPP_OBJS=.\\cord\\Debug/\n-CPP_SBRS=.\\.\n-\n-.c{$(CPP_OBJS)}.obj:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cpp{$(CPP_OBJS)}.obj:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cxx{$(CPP_OBJS)}.obj:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.c{$(CPP_SBRS)}.sbr:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cpp{$(CPP_SBRS)}.sbr:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-.cxx{$(CPP_SBRS)}.sbr:\n-   $(CPP) $(CPP_PROJ) $<  \n-\n-MTL=mktyplib.exe\n-# ADD BASE MTL /nologo /D \"_DEBUG\" /win32\n-# ADD MTL /nologo /D \"_DEBUG\" /win32\n-MTL_PROJ=/nologo /D \"_DEBUG\" /win32 \n-RSC=rc.exe\n-# ADD BASE RSC /l 0x809 /d \"_DEBUG\"\n-# ADD RSC /l 0x809 /d \"_DEBUG\"\n-RSC_PROJ=/l 0x809 /fo\"$(INTDIR)/de_win.res\" /d \"_DEBUG\" \n-BSC32=bscmake.exe\n-# ADD BASE BSC32 /nologo\n-# ADD BSC32 /nologo\n-BSC32_FLAGS=/nologo /o\"$(OUTDIR)/cord.bsc\" \n-BSC32_SBRS= \\\n-\t\n-LINK32=link.exe\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /debug /machine:I386\n-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /debug /machine:I386 /out:\"Debug/de.exe\"\n-LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\\\n- advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\\\n- odbccp32.lib /nologo /subsystem:windows /incremental:yes\\\n- /pdb:\"$(OUTDIR)/de.pdb\" /debug /machine:I386 /out:\"Debug/de.exe\" \n-LINK32_OBJS= \\\n-\t\".\\cord\\Debug\\cordbscs.obj\" \\\n-\t\".\\cord\\Debug\\cordxtra.obj\" \\\n-\t\".\\cord\\Debug\\de.obj\" \\\n-\t\".\\cord\\Debug\\de_win.obj\" \\\n-\t\".\\cord\\Debug\\de_win.res\" \\\n-\t\".\\Debug\\gc.lib\"\n-\n-\".\\Debug\\de.exe\" : \"$(OUTDIR)\" $(DEF_FILE) $(LINK32_OBJS)\n-    $(LINK32) @<<\n-  $(LINK32_FLAGS) $(LINK32_OBJS)\n-<<\n-\n-!ENDIF \n-\n-################################################################################\n-# Begin Target\n-\n-# Name \"gc - Win32 Release\"\n-# Name \"gc - Win32 Debug\"\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-!ENDIF \n-\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\gc_cpp.cpp\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-DEP_CPP_RECLA=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t\".\\include\\gc_cpp.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_RECLA=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Release\\gc_cpp.obj\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n-\n-\".\\Release\\gc_cpp.sbr\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-DEP_CPP_RECLA=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t\".\\include\\gc_cpp.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_RECLA=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Debug\\gc_cpp.obj\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n-\n-\".\\Debug\\gc_cpp.sbr\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\reclaim.c\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-DEP_CPP_RECLA=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_RECLA=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Release\\reclaim.obj\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n-\n-\".\\Release\\reclaim.sbr\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-DEP_CPP_RECLA=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_RECLA=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Debug\\reclaim.obj\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n-\n-\".\\Debug\\reclaim.sbr\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\os_dep.c\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-DEP_CPP_OS_DE=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\STAT.H\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_OS_DE=\\\n-\t\".\\il\\PCR_IL.h\"\\\n-\t\".\\mm\\PCR_MM.h\"\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\".\\vd\\PCR_VD.h\"\\\n-\t\n-\n-\".\\Release\\os_dep.obj\" : $(SOURCE) $(DEP_CPP_OS_DE) \"$(INTDIR)\"\n-\n-\".\\Release\\os_dep.sbr\" : $(SOURCE) $(DEP_CPP_OS_DE) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-DEP_CPP_OS_DE=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\STAT.H\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_OS_DE=\\\n-\t\".\\il\\PCR_IL.h\"\\\n-\t\".\\mm\\PCR_MM.h\"\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\".\\vd\\PCR_VD.h\"\\\n-\t\n-\n-\".\\Debug\\os_dep.obj\" : $(SOURCE) $(DEP_CPP_OS_DE) \"$(INTDIR)\"\n-\n-\".\\Debug\\os_dep.sbr\" : $(SOURCE) $(DEP_CPP_OS_DE) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\misc.c\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-DEP_CPP_MISC_=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_MISC_=\\\n-\t\".\\il\\PCR_IL.h\"\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Release\\misc.obj\" : $(SOURCE) $(DEP_CPP_MISC_) \"$(INTDIR)\"\n-\n-\".\\Release\\misc.sbr\" : $(SOURCE) $(DEP_CPP_MISC_) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-DEP_CPP_MISC_=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_MISC_=\\\n-\t\".\\il\\PCR_IL.h\"\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Debug\\misc.obj\" : $(SOURCE) $(DEP_CPP_MISC_) \"$(INTDIR)\"\n-\n-\".\\Debug\\misc.sbr\" : $(SOURCE) $(DEP_CPP_MISC_) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\mark_rts.c\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-DEP_CPP_MARK_=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_MARK_=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Release\\mark_rts.obj\" : $(SOURCE) $(DEP_CPP_MARK_) \"$(INTDIR)\"\n-\n-\".\\Release\\mark_rts.sbr\" : $(SOURCE) $(DEP_CPP_MARK_) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-DEP_CPP_MARK_=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_MARK_=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Debug\\mark_rts.obj\" : $(SOURCE) $(DEP_CPP_MARK_) \"$(INTDIR)\"\n-\n-\".\\Debug\\mark_rts.sbr\" : $(SOURCE) $(DEP_CPP_MARK_) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\mach_dep.c\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-DEP_CPP_MACH_=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_MACH_=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Release\\mach_dep.obj\" : $(SOURCE) $(DEP_CPP_MACH_) \"$(INTDIR)\"\n-\n-\".\\Release\\mach_dep.sbr\" : $(SOURCE) $(DEP_CPP_MACH_) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-DEP_CPP_MACH_=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_MACH_=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Debug\\mach_dep.obj\" : $(SOURCE) $(DEP_CPP_MACH_) \"$(INTDIR)\"\n-\n-\".\\Debug\\mach_dep.sbr\" : $(SOURCE) $(DEP_CPP_MACH_) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\headers.c\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-DEP_CPP_HEADE=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_HEADE=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Release\\headers.obj\" : $(SOURCE) $(DEP_CPP_HEADE) \"$(INTDIR)\"\n-\n-\".\\Release\\headers.sbr\" : $(SOURCE) $(DEP_CPP_HEADE) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-DEP_CPP_HEADE=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_HEADE=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Debug\\headers.obj\" : $(SOURCE) $(DEP_CPP_HEADE) \"$(INTDIR)\"\n-\n-\".\\Debug\\headers.sbr\" : $(SOURCE) $(DEP_CPP_HEADE) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\alloc.c\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-DEP_CPP_ALLOC=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_ALLOC=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Release\\alloc.obj\" : $(SOURCE) $(DEP_CPP_ALLOC) \"$(INTDIR)\"\n-\n-\".\\Release\\alloc.sbr\" : $(SOURCE) $(DEP_CPP_ALLOC) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-DEP_CPP_ALLOC=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_ALLOC=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Debug\\alloc.obj\" : $(SOURCE) $(DEP_CPP_ALLOC) \"$(INTDIR)\"\n-\n-\".\\Debug\\alloc.sbr\" : $(SOURCE) $(DEP_CPP_ALLOC) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\allchblk.c\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-DEP_CPP_ALLCH=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_ALLCH=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Release\\allchblk.obj\" : $(SOURCE) $(DEP_CPP_ALLCH) \"$(INTDIR)\"\n-\n-\".\\Release\\allchblk.sbr\" : $(SOURCE) $(DEP_CPP_ALLCH) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-DEP_CPP_ALLCH=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_ALLCH=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Debug\\allchblk.obj\" : $(SOURCE) $(DEP_CPP_ALLCH) \"$(INTDIR)\"\n-\n-\".\\Debug\\allchblk.sbr\" : $(SOURCE) $(DEP_CPP_ALLCH) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\stubborn.c\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-DEP_CPP_STUBB=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_STUBB=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Release\\stubborn.obj\" : $(SOURCE) $(DEP_CPP_STUBB) \"$(INTDIR)\"\n-\n-\".\\Release\\stubborn.sbr\" : $(SOURCE) $(DEP_CPP_STUBB) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-DEP_CPP_STUBB=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_STUBB=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Debug\\stubborn.obj\" : $(SOURCE) $(DEP_CPP_STUBB) \"$(INTDIR)\"\n-\n-\".\\Debug\\stubborn.sbr\" : $(SOURCE) $(DEP_CPP_STUBB) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\obj_map.c\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-DEP_CPP_OBJ_M=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_OBJ_M=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Release\\obj_map.obj\" : $(SOURCE) $(DEP_CPP_OBJ_M) \"$(INTDIR)\"\n-\n-\".\\Release\\obj_map.sbr\" : $(SOURCE) $(DEP_CPP_OBJ_M) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-DEP_CPP_OBJ_M=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_OBJ_M=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Debug\\obj_map.obj\" : $(SOURCE) $(DEP_CPP_OBJ_M) \"$(INTDIR)\"\n-\n-\".\\Debug\\obj_map.sbr\" : $(SOURCE) $(DEP_CPP_OBJ_M) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\new_hblk.c\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-DEP_CPP_NEW_H=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_NEW_H=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Release\\new_hblk.obj\" : $(SOURCE) $(DEP_CPP_NEW_H) \"$(INTDIR)\"\n-\n-\".\\Release\\new_hblk.sbr\" : $(SOURCE) $(DEP_CPP_NEW_H) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-DEP_CPP_NEW_H=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_NEW_H=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Debug\\new_hblk.obj\" : $(SOURCE) $(DEP_CPP_NEW_H) \"$(INTDIR)\"\n-\n-\".\\Debug\\new_hblk.sbr\" : $(SOURCE) $(DEP_CPP_NEW_H) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\mark.c\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-DEP_CPP_MARK_C=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_pmark.h\"\\\n-\t\".\\include\\gc_mark.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_MARK_C=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Release\\mark.obj\" : $(SOURCE) $(DEP_CPP_MARK_C) \"$(INTDIR)\"\n-\n-\".\\Release\\mark.sbr\" : $(SOURCE) $(DEP_CPP_MARK_C) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-DEP_CPP_MARK_C=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_pmark.h\"\\\n-\t\".\\include\\gc_mark.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_MARK_C=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Debug\\mark.obj\" : $(SOURCE) $(DEP_CPP_MARK_C) \"$(INTDIR)\"\n-\n-\".\\Debug\\mark.sbr\" : $(SOURCE) $(DEP_CPP_MARK_C) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\malloc.c\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-DEP_CPP_MALLO=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_MALLO=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Release\\malloc.obj\" : $(SOURCE) $(DEP_CPP_MALLO) \"$(INTDIR)\"\n-\n-\".\\Release\\malloc.sbr\" : $(SOURCE) $(DEP_CPP_MALLO) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-DEP_CPP_MALLO=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_MALLO=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Debug\\malloc.obj\" : $(SOURCE) $(DEP_CPP_MALLO) \"$(INTDIR)\"\n-\n-\".\\Debug\\malloc.sbr\" : $(SOURCE) $(DEP_CPP_MALLO) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\mallocx.c\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-DEP_CPP_MALLX=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_MALLX=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Release\\mallocx.obj\" : $(SOURCE) $(DEP_CPP_MALLX) \"$(INTDIR)\"\n-\n-\".\\Release\\mallocx.sbr\" : $(SOURCE) $(DEP_CPP_MALLX) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-DEP_CPP_MALLX=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_MALLX=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Debug\\mallocx.obj\" : $(SOURCE) $(DEP_CPP_MALLX) \"$(INTDIR)\"\n-\n-\".\\Debug\\mallocx.sbr\" : $(SOURCE) $(DEP_CPP_MALLX) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\finalize.c\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-DEP_CPP_FINAL=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_pmark.h\"\\\n-\t\".\\include\\gc_mark.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_FINAL=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Release\\finalize.obj\" : $(SOURCE) $(DEP_CPP_FINAL) \"$(INTDIR)\"\n-\n-\".\\Release\\finalize.sbr\" : $(SOURCE) $(DEP_CPP_FINAL) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-DEP_CPP_FINAL=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_pmark.h\"\\\n-\t\".\\include\\gc_mark.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_FINAL=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Debug\\finalize.obj\" : $(SOURCE) $(DEP_CPP_FINAL) \"$(INTDIR)\"\n-\n-\".\\Debug\\finalize.sbr\" : $(SOURCE) $(DEP_CPP_FINAL) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\dbg_mlc.c\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-DEP_CPP_DBG_M=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_DBG_M=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Release\\dbg_mlc.obj\" : $(SOURCE) $(DEP_CPP_DBG_M) \"$(INTDIR)\"\n-\n-\".\\Release\\dbg_mlc.sbr\" : $(SOURCE) $(DEP_CPP_DBG_M) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-DEP_CPP_DBG_M=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_DBG_M=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Debug\\dbg_mlc.obj\" : $(SOURCE) $(DEP_CPP_DBG_M) \"$(INTDIR)\"\n-\n-\".\\Debug\\dbg_mlc.sbr\" : $(SOURCE) $(DEP_CPP_DBG_M) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\blacklst.c\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-DEP_CPP_BLACK=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_BLACK=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Release\\blacklst.obj\" : $(SOURCE) $(DEP_CPP_BLACK) \"$(INTDIR)\"\n-\n-\".\\Release\\blacklst.sbr\" : $(SOURCE) $(DEP_CPP_BLACK) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-DEP_CPP_BLACK=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_BLACK=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Debug\\blacklst.obj\" : $(SOURCE) $(DEP_CPP_BLACK) \"$(INTDIR)\"\n-\n-\".\\Debug\\blacklst.sbr\" : $(SOURCE) $(DEP_CPP_BLACK) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\typd_mlc.c\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-DEP_CPP_TYPD_=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_pmark.h\"\\\n-\t\".\\include\\gc_mark.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t\".\\include\\gc_typed.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_TYPD_=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Release\\typd_mlc.obj\" : $(SOURCE) $(DEP_CPP_TYPD_) \"$(INTDIR)\"\n-\n-\".\\Release\\typd_mlc.sbr\" : $(SOURCE) $(DEP_CPP_TYPD_) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-DEP_CPP_TYPD_=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_pmark.h\"\\\n-\t\".\\include\\gc_mark.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t\".\\include\\gc_typed.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_TYPD_=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Debug\\typd_mlc.obj\" : $(SOURCE) $(DEP_CPP_TYPD_) \"$(INTDIR)\"\n-\n-\".\\Debug\\typd_mlc.sbr\" : $(SOURCE) $(DEP_CPP_TYPD_) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\ptr_chck.c\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-DEP_CPP_PTR_C=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_pmark.h\"\\\n-\t\".\\include\\gc_mark.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_PTR_C=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Release\\ptr_chck.obj\" : $(SOURCE) $(DEP_CPP_PTR_C) \"$(INTDIR)\"\n-\n-\".\\Release\\ptr_chck.sbr\" : $(SOURCE) $(DEP_CPP_PTR_C) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-DEP_CPP_PTR_C=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_pmark.h\"\\\n-\t\".\\include\\gc_mark.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_PTR_C=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Debug\\ptr_chck.obj\" : $(SOURCE) $(DEP_CPP_PTR_C) \"$(INTDIR)\"\n-\n-\".\\Debug\\ptr_chck.sbr\" : $(SOURCE) $(DEP_CPP_PTR_C) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\dyn_load.c\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-DEP_CPP_DYN_L=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\STAT.H\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_DYN_L=\\\n-\t\".\\il\\PCR_IL.h\"\\\n-\t\".\\mm\\PCR_MM.h\"\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Release\\dyn_load.obj\" : $(SOURCE) $(DEP_CPP_DYN_L) \"$(INTDIR)\"\n-\n-\".\\Release\\dyn_load.sbr\" : $(SOURCE) $(DEP_CPP_DYN_L) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-DEP_CPP_DYN_L=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\STAT.H\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_DYN_L=\\\n-\t\".\\il\\PCR_IL.h\"\\\n-\t\".\\mm\\PCR_MM.h\"\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Debug\\dyn_load.obj\" : $(SOURCE) $(DEP_CPP_DYN_L) \"$(INTDIR)\"\n-\n-\".\\Debug\\dyn_load.sbr\" : $(SOURCE) $(DEP_CPP_DYN_L) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\win32_threads.c\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-DEP_CPP_WIN32=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_WIN32=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Release\\win32_threads.obj\" : $(SOURCE) $(DEP_CPP_WIN32) \"$(INTDIR)\"\n-\n-\".\\Release\\win32_threads.sbr\" : $(SOURCE) $(DEP_CPP_WIN32) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-DEP_CPP_WIN32=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_WIN32=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Debug\\win32_threads.obj\" : $(SOURCE) $(DEP_CPP_WIN32) \"$(INTDIR)\"\n-\n-\".\\Debug\\win32_threads.sbr\" : $(SOURCE) $(DEP_CPP_WIN32) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\checksums.c\n-\n-!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n-\n-DEP_CPP_CHECK=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_CHECK=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Release\\checksums.obj\" : $(SOURCE) $(DEP_CPP_CHECK) \"$(INTDIR)\"\n-\n-\".\\Release\\checksums.sbr\" : $(SOURCE) $(DEP_CPP_CHECK) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n-\n-DEP_CPP_CHECK=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_CHECK=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-\".\\Debug\\checksums.obj\" : $(SOURCE) $(DEP_CPP_CHECK) \"$(INTDIR)\"\n-\n-\".\\Debug\\checksums.sbr\" : $(SOURCE) $(DEP_CPP_CHECK) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-# End Target\n-################################################################################\n-# Begin Target\n-\n-# Name \"gctest - Win32 Release\"\n-# Name \"gctest - Win32 Debug\"\n-\n-!IF  \"$(CFG)\" == \"gctest - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"gctest - Win32 Debug\"\n-\n-!ENDIF \n-\n-################################################################################\n-# Begin Project Dependency\n-\n-# Project_Dep_Name \"gc\"\n-\n-!IF  \"$(CFG)\" == \"gctest - Win32 Release\"\n-\n-\"gc - Win32 Release\" : \n-   $(MAKE) /$(MAKEFLAGS) /F \".\\gc.mak\" CFG=\"gc - Win32 Release\" \n-\n-!ELSEIF  \"$(CFG)\" == \"gctest - Win32 Debug\"\n-\n-\"gc - Win32 Debug\" : \n-   $(MAKE) /$(MAKEFLAGS) /F \".\\gc.mak\" CFG=\"gc - Win32 Debug\" \n-\n-!ENDIF \n-\n-# End Project Dependency\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\tests\\test.c\n-DEP_CPP_TEST_=\\\n-\t\".\\include\\private\\gcconfig.h\"\\\n-\t\".\\include\\gc.h\"\\\n-\t\".\\include\\private\\gc_hdrs.h\"\\\n-\t\".\\include\\private\\gc_priv.h\"\\\n-\t\".\\include\\gc_typed.h\"\\\n-\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n-\t\n-NODEP_CPP_TEST_=\\\n-\t\".\\th\\PCR_Th.h\"\\\n-\t\".\\th\\PCR_ThCrSec.h\"\\\n-\t\".\\th\\PCR_ThCtl.h\"\\\n-\t\n-\n-!IF  \"$(CFG)\" == \"gctest - Win32 Release\"\n-\n-\n-\".\\gctest\\Release\\test.obj\" : $(SOURCE) $(DEP_CPP_TEST_) \"$(INTDIR)\"\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"gctest - Win32 Debug\"\n-\n-\n-\".\\gctest\\Debug\\test.obj\" : $(SOURCE) $(DEP_CPP_TEST_) \"$(INTDIR)\"\n-\n-\".\\gctest\\Debug\\test.sbr\" : $(SOURCE) $(DEP_CPP_TEST_) \"$(INTDIR)\"\n-\n-\n-!ENDIF \n-\n-# End Source File\n-# End Target\n-################################################################################\n-# Begin Target\n-\n-# Name \"cord - Win32 Release\"\n-# Name \"cord - Win32 Debug\"\n-\n-!IF  \"$(CFG)\" == \"cord - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n-\n-!ENDIF \n-\n-################################################################################\n-# Begin Project Dependency\n-\n-# Project_Dep_Name \"gc\"\n-\n-!IF  \"$(CFG)\" == \"cord - Win32 Release\"\n-\n-\"gc - Win32 Release\" : \n-   $(MAKE) /$(MAKEFLAGS) /F \".\\gc.mak\" CFG=\"gc - Win32 Release\" \n-\n-!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n-\n-\"gc - Win32 Debug\" : \n-   $(MAKE) /$(MAKEFLAGS) /F \".\\gc.mak\" CFG=\"gc - Win32 Debug\" \n-\n-!ENDIF \n-\n-# End Project Dependency\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\cord\\de_win.c\n-DEP_CPP_DE_WI=\\\n-\t\".\\include\\cord.h\"\\\n-\t\".\\cord\\de_cmds.h\"\\\n-\t\".\\cord\\de_win.h\"\\\n-\t\".\\include\\private\\cord_pos.h\"\\\n-\t\n-NODEP_CPP_DE_WI=\\\n-\t\".\\include\\gc.h\"\\\n-\t\n-\n-!IF  \"$(CFG)\" == \"cord - Win32 Release\"\n-\n-\n-\".\\cord\\Release\\de_win.obj\" : $(SOURCE) $(DEP_CPP_DE_WI) \"$(INTDIR)\"\n-   $(CPP) $(CPP_PROJ) $(SOURCE)\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n-\n-\n-\".\\cord\\Debug\\de_win.obj\" : $(SOURCE) $(DEP_CPP_DE_WI) \"$(INTDIR)\"\n-   $(CPP) $(CPP_PROJ) $(SOURCE)\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\cord\\de.c\n-DEP_CPP_DE_C2e=\\\n-\t\".\\include\\cord.h\"\\\n-\t\".\\cord\\de_cmds.h\"\\\n-\t\".\\cord\\de_win.h\"\\\n-\t\".\\include\\private\\cord_pos.h\"\\\n-\t\n-NODEP_CPP_DE_C2e=\\\n-\t\".\\include\\gc.h\"\\\n-\t\n-\n-!IF  \"$(CFG)\" == \"cord - Win32 Release\"\n-\n-\n-\".\\cord\\Release\\de.obj\" : $(SOURCE) $(DEP_CPP_DE_C2e) \"$(INTDIR)\"\n-   $(CPP) $(CPP_PROJ) $(SOURCE)\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n-\n-\n-\".\\cord\\Debug\\de.obj\" : $(SOURCE) $(DEP_CPP_DE_C2e) \"$(INTDIR)\"\n-   $(CPP) $(CPP_PROJ) $(SOURCE)\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\cord\\cordxtra.c\n-DEP_CPP_CORDX=\\\n-\t\".\\include\\cord.h\"\\\n-\t\".\\include\\ec.h\"\\\n-\t\".\\include\\private\\cord_pos.h\"\\\n-\t\n-NODEP_CPP_CORDX=\\\n-\t\".\\include\\gc.h\"\\\n-\t\n-\n-!IF  \"$(CFG)\" == \"cord - Win32 Release\"\n-\n-\n-\".\\cord\\Release\\cordxtra.obj\" : $(SOURCE) $(DEP_CPP_CORDX) \"$(INTDIR)\"\n-   $(CPP) $(CPP_PROJ) $(SOURCE)\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n-\n-\n-\".\\cord\\Debug\\cordxtra.obj\" : $(SOURCE) $(DEP_CPP_CORDX) \"$(INTDIR)\"\n-   $(CPP) $(CPP_PROJ) $(SOURCE)\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\cord\\cordbscs.c\n-DEP_CPP_CORDB=\\\n-\t\".\\include\\cord.h\"\\\n-\t\".\\include\\private\\cord_pos.h\"\\\n-\t\n-NODEP_CPP_CORDB=\\\n-\t\".\\include\\gc.h\"\\\n-\t\n-\n-!IF  \"$(CFG)\" == \"cord - Win32 Release\"\n-\n-\n-\".\\cord\\Release\\cordbscs.obj\" : $(SOURCE) $(DEP_CPP_CORDB) \"$(INTDIR)\"\n-   $(CPP) $(CPP_PROJ) $(SOURCE)\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n-\n-\n-\".\\cord\\Debug\\cordbscs.obj\" : $(SOURCE) $(DEP_CPP_CORDB) \"$(INTDIR)\"\n-   $(CPP) $(CPP_PROJ) $(SOURCE)\n-\n-\n-!ENDIF \n-\n-# End Source File\n-################################################################################\n-# Begin Source File\n-\n-SOURCE=.\\cord\\de_win.RC\n-\n-!IF  \"$(CFG)\" == \"cord - Win32 Release\"\n-\n-\n-\".\\cord\\Release\\de_win.res\" : $(SOURCE) \"$(INTDIR)\"\n-   $(RSC) /l 0x809 /fo\"$(INTDIR)/de_win.res\" /i \"cord\" /d \"NDEBUG\" $(SOURCE)\n-\n-\n-!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n-\n-\n-\".\\cord\\Debug\\de_win.res\" : $(SOURCE) \"$(INTDIR)\"\n-   $(RSC) /l 0x809 /fo\"$(INTDIR)/de_win.res\" /i \"cord\" /d \"_DEBUG\" $(SOURCE)\n-\n-\n-!ENDIF \n-\n-# End Source File\n-# End Target\n-# End Project\n-################################################################################"}, {"sha": "690598d69d4ad1ba21cdb38e34c65cf9b852b234", "filename": "boehm-gc/OS2_MAKEFILE", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FOS2_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FOS2_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FOS2_MAKEFILE?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,45 +0,0 @@\n-# Makefile for OS/2.  Assumes IBM's compiler, static linking, and a single thread.\n-# Adding dynamic linking support seems easy, but takes a little bit of work.\n-# Adding thread support may be nontrivial, since we haven't yet figured out how to\n-# look at another thread's registers.\n-\n-# Significantly revised for GC version 4.4 by Mark Boulter (Jan 1994).\n-\n-OBJS= alloc.obj reclaim.obj allchblk.obj misc.obj mach_dep.obj os_dep.obj mark_rts.obj headers.obj mark.obj obj_map.obj blacklst.obj finalize.obj new_hblk.obj dbg_mlc.obj malloc.obj stubborn.obj typd_mlc.obj ptr_chck.obj mallocx.obj\n-\n-CORDOBJS= cord\\cordbscs.obj cord\\cordxtra.obj cord\\cordprnt.obj\n-\n-CC= icc\n-CFLAGS= /O /Q /DSILENT /DSMALL_CONFIG /DALL_INTERIOR_POINTERS\n-# Use /Ti instead of /O for debugging\n-# Setjmp_test may yield overly optimistic results when compiled\n-# without optimization.\n-\n-all: $(OBJS) gctest.exe cord\\cordtest.exe\n-\n-$(OBJS) test.obj: include\\private\\gc_priv.h include\\private\\gc_hdrs.h include\\gc.h include\\private\\gcconfig.h\n-\n-## ERASE THE LIB FIRST - if it is already there then this command will fail\n-## (make sure its there or erase will fail!)\n-gc.lib: $(OBJS)\n-        echo . > gc.lib\n-        erase gc.lib\n-        LIB gc.lib $(OBJS), gc.lst\n-\n-mach_dep.obj: mach_dep.c\n-        $(CC) $(CFLAGS) /C mach_dep.c\n-\n-gctest.exe: test.obj gc.lib\n-        $(CC) $(CFLAGS) /B\"/STACK:524288\" /Fegctest test.obj gc.lib\n-\n-cord\\cordbscs.obj: cord\\cordbscs.c include\\cord.h include\\private\\cord_pos.h\n-        $(CC) $(CFLAGS) /C /Focord\\cordbscs cord\\cordbscs.c\n-\n-cord\\cordxtra.obj: cord\\cordxtra.c include\\cord.h include\\private\\cord_pos.h include\\ec.h\n-        $(CC) $(CFLAGS) /C /Focord\\cordxtra cord\\cordxtra.c\n-\n-cord\\cordprnt.obj: cord\\cordprnt.c include\\cord.h include\\private\\cord_pos.h include\\ec.h\n-        $(CC) $(CFLAGS) /C /Focord\\cordprnt cord\\cordprnt.c\n-\n-cord\\cordtest.exe: cord\\cordtest.c include\\cord.h include\\private\\cord_pos.h include\\ec.h $(CORDOBJS) gc.lib\n-        $(CC) $(CFLAGS) /B\"/STACK:65536\" /Fecord\\cordtest cord\\cordtest.c gc.lib $(CORDOBJS)"}, {"sha": "1eae36725569152a535fc8574f34eb276269dd82", "filename": "boehm-gc/PCR-Makefile", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FPCR-Makefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FPCR-Makefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FPCR-Makefile?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,68 +0,0 @@\n-#\n-# Default target\n-#\n-\n-default: gc.o\n-\n-include ../config/common.mk\n-\n-#\n-# compilation flags, etc.\n-#\n-\n-\n-CPPFLAGS = $(INCLUDE) $(CONFIG_CPPFLAGS) \\\n-\t-DPCR_NO_RENAME -DPCR_NO_HOSTDEP_ERR\n-#CFLAGS\t= -DPCR -DSILENT $(CONFIG_CFLAGS)\n-CFLAGS\t= -DPCR $(CONFIG_CFLAGS)\n-SPECIALCFLAGS = \t# For code involving asm's\n-\n-ASPPFLAGS  = $(INCLUDE) $(CONFIG_ASPPFLAGS) \\\n-\t-DPCR_NO_RENAME -DPCR_NO_HOSTDEP_ERR -DASM\n-\n-ASFLAGS\t= $(CONFIG_ASFLAGS)\n-\n-LDRFLAGS = $(CONFIG_LDRFLAGS)\n-\n-LDFLAGS = $(CONFIG_LDFLAGS)\n-\n-#\n-#\n-#\n-#\n-# BEGIN PACKAGE-SPECIFIC PART\n-#\n-#\n-#\n-#\n-\n-# Fix to point to local pcr installation directory.\n-PCRDIR= ..\n-\n-COBJ= alloc.o reclaim.o allchblk.o misc.o os_dep.o mark_rts.o headers.o mark.o obj_map.o pcr_interface.o blacklst.o finalize.o new_hblk.o real_malloc.o dyn_load.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o typd_mlc.o ptr_chck.o mallocx.o\n-\n-CSRC= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c typd_mlc.c ptr_chck.c mallocx.c\n-\n-SHELL= /bin/sh\n-\n-default: gc.o\n-\n-gc.o: $(COBJ) mach_dep.o\n-\t$(LDR) $(CONFIG_LDRFLAGS) -o gc.o $(COBJ) mach_dep.o\n-\n-\n-mach_dep.o: mach_dep.c mips_mach_dep.s rs6000_mach_dep.s if_mach if_not_there\n-\trm -f mach_dep.o\n-\t./if_mach MIPS \"\" as -o mach_dep.o mips_mach_dep.s\n-\t./if_mach RS6000 \"\" as -o mach_dep.o rs6000_mach_dep.s\n-\t./if_mach ALPHA \"\" as -o mach_dep.o alpha_mach_dep.s\n-\t./if_mach SPARC SUNOS5 as -o mach_dep.o sparc_mach_dep.s\n-\t./if_not_there mach_dep.o $(CC) -c $(SPECIALCFLAGS) mach_dep.c\n-\n-if_mach: if_mach.c gcconfig.h\n-\t$(CC) $(CFLAGS) -o if_mach if_mach.c\n-\n-if_not_there: if_not_there.c\n-\t$(CC) $(CFLAGS) -o if_not_there if_not_there.c\n-\n-"}, {"sha": "e2085051bbc940ee976e05b8ea1cbc0f07e303d2", "filename": "boehm-gc/SMakefile.amiga", "status": "removed", "additions": 0, "deletions": 178, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FSMakefile.amiga", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FSMakefile.amiga", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FSMakefile.amiga?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,178 +0,0 @@\n-\n-# Rewritten smakefile for amiga / sas/c. -Kjetil M.\n-# Dont use the cord-package if you define parm=both or parm=reg.\n-\n-\n-#----------------TOOLS--------------------------------\n-CC=sc\n-LINKER=slink\n-LIBER=oml\n-\n-#----------------CPU OPTIONS--------------------------\n-\n-CPU=68060\n-\n-#----------------FPU OPTIONS--------------------------\n-\n-MATH=8\n-MATHLIB=LIB:scm881.lib\n-\n-#----------------COMPILER OPTIONS---------------------\n-\n-IGNORE= IGNORE=85 IGNORE=154 IGNORE=161 IGNORE=100 \n-\n-OPTIMIZE=optimize optimizetime optglobal optimizerdepth=100 optimizerpeephole optloop OPTSCHED optimizerinlocal optimizerrecurdepth=100\n-# optimizerinline optimizercomplexity=100\n-\n-OPT= $(OPTIMIZE) CPU=$(CPU) math=$(MATH) NOSTACKCHECK VERBOSE \\\n-MAPHUNK NOVERSION NOICONS nodebug \\\n-DEFINE SILENT \\\n-parm=reg \\\n-DEFINE __USE_SYSBASE\n-\n-\n-SOPT= $(OPT) $(IGNORE) \\\n-DEFINE AMIGA_SKIP_SEG \\\n-DEFINE ATOMIC_UNCOLLECTABLE \\\n-DEFINE GC_AMIGA_FASTALLOC \\\n-DEFINE GC_AMIGA_RETRY \\\n-DEFINE GC_AMIGA_PRINTSTATS \\\n-DEFINE GC_AMIGA_GC\n-\n-\n-#DEFINE ALL_INTERIOR_POINTERS \\\n-\n-\n-SCOPT= $(SOPT) define GC_AMIGA_MAKINGLIB\n-\n-CSCOPT= $(OPT) DEFINE AMIGA IGNORE=100 IGNORE=161 \n-\n-#------------------LINKING----------------------------\n-\n-\n-all: gctest setjmp_t cord/cordtest\n-\n-clean:\n-   delete *.lib gctest setjmp_t *.o *.lnk cord/*.o cord/*.lib cord/*.lnk cord/cordtest\n-\tsmake\n-\n-test: setjmp_t gctest cord/cordtest\n-   setjmp_t\n-   gctest\n-   cord/cordtest\n-\n-gctest: gc$(CPU).lib GCAmigaOS$(CPU).lib test.o\n-   $(LINKER) LIB:c.o test.o TO gctest LIB gc$(CPU).lib LIB:sc.lib $(MATHLIB)\n-\n-setjmp_t: setjmp_t.o gc.h\n-   $(LINKER) LIB:c.o setjmp_t.o to setjmp_t lib LIB:sc.lib\n-\n-cord/cordtest: cord/cordtest.o cord/cord$(CPU).lib gc$(CPU).lib\n-\tslink LIB:c.o cord/cordtest.o LIB $(MATHLIB) gc$(CPU).lib cord/cord$(CPU).lib LIB:sc.lib TO cord/cordtest\n-\n-\n-#------------------LIBBING----------------------------\n-\n-OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o real_malloc.o dyn_load.o dbg_mlc.o malloc.o stubborn.o checksums.o typd_mlc.o ptr_chck.o mallocx.o\n-\n-gc$(CPU).lib: $(OBJS)\n-   $(LIBER) gc$(CPU).lib r $(OBJS)\n-\n-\n-COBJS = cord/cordbscs.o cord/cordprnt.o cord/cordxtra.o\n-\n-cord/cord$(CPU).lib: $(COBJS)\n-\toml cord/cord$(CPU).lib r $(COBJS)\n-\n-#------------------COMPILING--------------------------\n-\n-INC=  gc_private.h gc_hdrs.h gc.h gcconfig.h\n-\n-alloc.o : alloc.c $(INC)\n-\t$(CC) alloc.c $(SCOPT) ignore=7\n-\n-reclaim.o : reclaim.c $(INC)\n-\t$(CC) reclaim.c $(SCOPT)\n-\n-allchblk.o : allchblk.c $(INC)\n-\t$(CC) allchblk.c $(SCOPT)\n-\n-misc.o : misc.c $(INC)\n-\t$(CC) misc.c $(SCOPT)\n-\n-os_dep.o : os_dep.c $(INC) AmigaOS.c\n-\t$(CC) os_dep.c $(SCOPT)\n-\n-mark_rts.o : mark_rts.c $(INC)\n-\t$(CC) mark_rts.c $(SCOPT)\n-\n-headers.o : headers.c $(INC)\n-\t$(CC) headers.c $(SCOPT)\n-\n-mark.o : mark.c $(INC)\n-\t$(CC) mark.c $(SCOPT)\n-\n-obj_map.o : obj_map.c $(INC)\n-\t$(CC) obj_map.c $(SCOPT)\n-\n-blacklst.o : blacklst.c $(INC)\n-\t$(CC) blacklst.c $(SCOPT)\n-\n-finalize.o : finalize.c $(INC)\n-\t$(CC) finalize.c $(SCOPT) noopt\t#Could sas/c still have problems with this one? Gctest sometimes fails to finalize all.\n-\n-new_hblk.o : new_hblk.c $(INC)\n-\t$(CC) new_hblk.c $(SCOPT)\n-\n-real_malloc.o : real_malloc.c $(INC)\n-\t$(CC) real_malloc.c $(SCOPT)\n-\n-dyn_load.o : dyn_load.c $(INC)\n-\t$(CC) dyn_load.c $(SCOPT)\n-\n-dbg_mlc.o : dbg_mlc.c $(INC)\n-\t$(CC) dbg_mlc.c $(SCOPT)\n-\n-malloc.o : malloc.c $(INC)\n-\t$(CC) malloc.c $(SCOPT)\n-\n-mallocx.o : mallocx.c $(INC)\n-\t$(CC) mallocx.c $(SCOPT)\n-\n-stubborn.o : stubborn.c $(INC)\n-\t$(CC) stubborn.c $(SCOPT)\n-\n-checksums.o : checksums.c $(INC)\n-\t$(CC) checksums.c $(SCOPT)\n-\n-typd_mlc.o: typd_mlc.c $(INC)\n-\t$(CC) typd_mlc.c $(SCOPT)\n-\n-mach_dep.o : mach_dep.c $(INC)\n-\t$(CC) mach_dep.c $(SCOPT)\n-\n-ptr_chck.o: ptr_chck.c $(INC)\n-\t$(CC) ptr_chck.c $(SCOPT)\n-\n-test.o : test.c $(INC)\n-\t$(CC) test.c $(SOPT)\n-\n-setjmp_t: setjmp_t.c gc.h\n-   $(CC) setjmp_t.c $(SOPT)\n-\n-\n-# cords:\n-\n-cord/cordbscs.o: cord/cordbscs.c\n-\tsc cord/cordbscs.c $(CSCOPT)\n-\n-cord/cordprnt.o: cord/cordprnt.c\n-\tsc cord/cordprnt.c $(CSCOPT)\n-\n-cord/cordxtra.o: cord/cordxtra.c\n-\tsc cord/cordxtra.c $(CSCOPT)\n-\n-cord/cordtest.o: cord/cordtest.c\n-\tsc cord/cordtest.c $(CSCOPT)\n-\n-"}, {"sha": "32b01df175415432a1d76f1bca8f25045c6779dd", "filename": "boehm-gc/WCC_MAKEFILE", "status": "removed", "additions": 0, "deletions": 196, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FWCC_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2FWCC_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FWCC_MAKEFILE?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,196 +0,0 @@\n-# Makefile for Watcom C/C++ 10.5, 10.6, 11.0 on NT, OS2 and DOS4GW.\n-# May work with Watcom 10.0.\n-\n-# Uncoment one of the lines below for cross compilation.\n-SYSTEM=MSWIN32\n-#SYSTEM=DOS4GW\n-#SYSTEM=OS2\n-\n-# The collector can be built either as dynamic or as static library.\n-# Select the library type you need.\n-#MAKE_AS_DLL=1\n-MAKE_AS_LIB=1\n-\n-# Select calling conventions.\n-# Possible choices are r and s.\n-CALLING=s\n-\n-# Select target CPU.\n-# Possible choices are 3, 4, 5, and 6.\n-# The last choice available only since version 11.0.\n-CPU=5\n-\n-# Set optimization options.\n-# Watcom before 11.0 does not support option \"-oh\".\n-OPTIM=-oneatx -s\n-#OPTIM=-ohneatx -s\n-\n-DEFS=-DALL_INTERIOR_POINTERS -DSILENT -DNO_SIGNALS #-DSMALL_CONFIG #-DGC_DEBUG\n-\n-\n-#####\n-\n-!ifndef SYSTEM\n-!ifdef __MSDOS__\n-SYSTEM=DOS4GW\n-!else ifdef __NT__\n-SYSTEM=MSWIN32\n-!else ifdef __OS2__\n-SYSTEM=OS2\n-!else\n-SYSTEM=Unknown\n-!endif\n-!endif\n-\n-!define $(SYSTEM)\n-\n-!ifdef DOS4GW\n-SYSFLAG=-DDOS4GW -bt=dos\n-!else ifdef MSWIN32\n-SYSFLAG=-DMSWIN32 -bt=nt\n-!else ifdef OS2\n-SYSFLAG=-DOS2 -bt=os2\n-!else\n-!error undefined or unsupported target platform: $(SYSTEM)\n-!endif\n-!ifdef MAKE_AS_DLL\n-DLLFLAG=-bd -DGC_DLL\n-TEST_DLLFLAG=-DGC_DLL\n-!else ifdef MAKE_AS_LIB\n-DLLFLAG=\n-TEST_DLLFLAG=\n-!else\n-!error Either MAKE_AS_LIB or MAKE_AS_DLL should be defined\n-!endif\n-\n-CC=wcc386\n-CXX=wpp386\n-\n-# -DUSE_GENERIC is required !\n-CFLAGS=-$(CPU)$(CALLING) $(OPTIM) -zp4 -zc $(SYSFLAG) $(DLLFLAG) -DGC_BUILD -DUSE_GENERIC $(DEFS)\n-CXXFLAGS= $(CFLAGS)\n-TEST_CFLAGS=-$(CPU)$(CALLING) $(OPTIM) -zp4 -zc $(SYSFLAG) $(TEST_DLLFLAG) $(DEFS)\n-TEST_CXXFLAGS= $(TEST_CFLAGS)\n-\n-OBJS= alloc.obj reclaim.obj allchblk.obj misc.obj &\n-      mach_dep.obj os_dep.obj mark_rts.obj headers.obj mark.obj &\n-      obj_map.obj blacklst.obj finalize.obj new_hblk.obj &\n-      dbg_mlc.obj malloc.obj stubborn.obj dyn_load.obj &\n-      typd_mlc.obj ptr_chck.obj mallocx.obj\n-\n-all: gc.lib gctest.exe test_cpp.exe\n-\n-!ifdef MAKE_AS_DLL\n-\n-gc.lib: gc.dll gc_cpp.obj\n-        *wlib -b -c -n -p=512 $@ +gc.dll +gc_cpp.obj\n-\n-gc.dll: $(OBJS) .AUTODEPEND\n-        @%create $*.lnk\n-!ifdef DOS4GW\n-        @%append $*.lnk sys os2v2_dll\n-!else ifdef MSWIN32\n-        @%append $*.lnk sys nt_dll\n-!else ifdef OS2\n-        @%append $*.lnk sys os2v2_dll\n-!endif\n-        @%append $*.lnk name $*\n-        @for %i in ($(OBJS)) do @%append $*.lnk file '%i'\n-!ifeq CALLING s\n-      @%append $*.lnk export GC_is_marked\n-      @%append $*.lnk export GC_incr_words_allocd\n-      @%append $*.lnk export GC_incr_mem_freed\n-      @%append $*.lnk export GC_generic_malloc_words_small\n-!else\n-      @%append $*.lnk export GC_is_marked_\n-      @%append $*.lnk export GC_incr_words_allocd_\n-      @%append $*.lnk export GC_incr_mem_freed_\n-      @%append $*.lnk export GC_generic_malloc_words_small_\n-!endif\n-        *wlink @$*.lnk\n-!else\n-gc.lib: $(OBJS) gc_cpp.obj\n-        @%create $*.lb1\n-        @for %i in ($(OBJS)) do @%append $*.lb1 +'%i'\n-      @%append $*.lb1 +'gc_cpp.obj'\n-        *wlib -b -c -n -p=512 $@ @$*.lb1\n-\n-!endif\n-\n-\n-gctest.exe: test.obj gc.lib\n-        %create $*.lnk\n-!ifdef DOS4GW\n-        @%append $*.lnk sys dos4g\n-!else ifdef MSWIN32\n-        @%append $*.lnk sys nt\n-!else ifdef OS2\n-        @%append $*.lnk sys os2v2\n-!endif\n-        @%append $*.lnk op case\n-        @%append $*.lnk op stack=256K\n-        @%append $*.lnk name $*\n-        @%append $*.lnk file test.obj\n-        @%append $*.lnk library gc.lib\n-!ifdef MAKE_AS_DLL\n-!ifeq CALLING s\n-      @%append $*.lnk import GC_is_marked gc\n-!else\n-      @%append $*.lnk import GC_is_marked_ gc\n-!endif\n-!endif\n-        *wlink @$*.lnk\n-test_cpp.exe: test_cpp.obj gc.lib\n-        %create $*.lnk\n-!ifdef DOS4GW\n-        @%append $*.lnk sys dos4g\n-!else ifdef MSWIN32\n-        @%append $*.lnk sys nt\n-!else ifdef OS2\n-        @%append $*.lnk sys os2v2\n-!endif\n-        @%append $*.lnk op case\n-        @%append $*.lnk op stack=256K\n-        @%append $*.lnk name $*\n-        @%append $*.lnk file test_cpp.obj\n-        @%append $*.lnk library gc.lib\n-!ifdef MAKE_AS_DLL\n-!ifeq CALLING s\n-      @%append $*.lnk import GC_incr_words_allocd gc\n-      @%append $*.lnk import GC_incr_mem_freed gc\n-      @%append $*.lnk import GC_generic_malloc_words_small gc\n-!else\n-      @%append $*.lnk import GC_incr_words_allocd_ gc\n-      @%append $*.lnk import GC_incr_mem_freed_ gc\n-      @%append $*.lnk import GC_generic_malloc_words_small_ gc\n-!endif\n-!endif\n-        *wlink @$*.lnk\n-\n-gc_cpp.obj: gc_cpp.cc .AUTODEPEND\n-        $(CXX) $(TEST_CXXFLAGS) -iinclude $*.cc\n-test.obj: tests\\test.c .AUTODEPEND\n-        $(CC) $(TEST_CFLAGS) $*.c\n-test_cpp.obj: tests\\test_cpp.cc .AUTODEPEND\n-        $(CXX) $(TEST_CXXFLAGS) -iinclude $*.cc\n-\n-\n-.c.obj: .AUTODEPEND\n-        $(CC) $(CFLAGS) $*.c\n-\n-.cc.obj: .AUTODEPEND\n-        $(CXX) $(CXXFLAGS) $*.cc\n-\n-clean : .SYMBOLIC\n-    @if exist *.obj del *.obj\n-    @if exist *.map del *.map\n-    @if exist *.lnk del *.lnk\n-    @if exist *.lb1 del *.lb1\n-    @if exist *.sym del *.sym\n-    @if exist *.err del *.err\n-    @if exist *.tmp del *.tmp\n-    @if exist *.lst del *.lst\n-    @if exist *.exe del *.exe\n-    @if exist *.log del *.log\n-    @if exist *.lib del *.lib\n-    @if exist *.dll del *.dll"}, {"sha": "da7badc9fb841000460e1c3ce0bc402435fac4dd", "filename": "boehm-gc/aclocal.m4", "status": "removed", "additions": 0, "deletions": 1036, "changes": 1036, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Faclocal.m4?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,1036 +0,0 @@\n-# generated automatically by aclocal 1.11.6 -*- Autoconf -*-\n-\n-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-# 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation,\n-# Inc.\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-m4_ifndef([AC_AUTOCONF_VERSION],\n-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n-m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.64],,\n-[m4_warning([this file was generated for autoconf 2.64.\n-You have another version of autoconf.  It may work, but is not guaranteed to.\n-If you have problems, you may need to regenerate the build system entirely.\n-To do so, use the procedure documented by the package, typically `autoreconf'.])])\n-\n-# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008, 2011 Free Software\n-# Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 1\n-\n-# AM_AUTOMAKE_VERSION(VERSION)\n-# ----------------------------\n-# Automake X.Y traces this macro to ensure aclocal.m4 has been\n-# generated from the m4 files accompanying Automake X.Y.\n-# (This private macro should not be called outside this file.)\n-AC_DEFUN([AM_AUTOMAKE_VERSION],\n-[am__api_version='1.11'\n-dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\n-dnl require some minimum version.  Point them to the right macro.\n-m4_if([$1], [1.11.6], [],\n-      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n-])\n-\n-# _AM_AUTOCONF_VERSION(VERSION)\n-# -----------------------------\n-# aclocal traces this macro to find the Autoconf version.\n-# This is a private macro too.  Using m4_define simplifies\n-# the logic in aclocal, which can simply ignore this definition.\n-m4_define([_AM_AUTOCONF_VERSION], [])\n-\n-# AM_SET_CURRENT_AUTOMAKE_VERSION\n-# -------------------------------\n-# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n-# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\n-AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n-[AM_AUTOMAKE_VERSION([1.11.6])dnl\n-m4_ifndef([AC_AUTOCONF_VERSION],\n-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n-_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n-\n-# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n-\n-# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 1\n-\n-# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n-# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to\n-# `$srcdir', `$srcdir/..', or `$srcdir/../..'.\n-#\n-# Of course, Automake must honor this variable whenever it calls a\n-# tool from the auxiliary directory.  The problem is that $srcdir (and\n-# therefore $ac_aux_dir as well) can be either absolute or relative,\n-# depending on how configure is run.  This is pretty annoying, since\n-# it makes $ac_aux_dir quite unusable in subdirectories: in the top\n-# source directory, any form will work fine, but in subdirectories a\n-# relative path needs to be adjusted first.\n-#\n-# $ac_aux_dir/missing\n-#    fails when called from a subdirectory if $ac_aux_dir is relative\n-# $top_srcdir/$ac_aux_dir/missing\n-#    fails if $ac_aux_dir is absolute,\n-#    fails when called from a subdirectory in a VPATH build with\n-#          a relative $ac_aux_dir\n-#\n-# The reason of the latter failure is that $top_srcdir and $ac_aux_dir\n-# are both prefixed by $srcdir.  In an in-source build this is usually\n-# harmless because $srcdir is `.', but things will broke when you\n-# start a VPATH build or use an absolute $srcdir.\n-#\n-# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,\n-# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:\n-#   am_aux_dir='\\$(top_srcdir)/'`expr \"$ac_aux_dir\" : \"$srcdir//*\\(.*\\)\"`\n-# and then we would define $MISSING as\n-#   MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n-# This will work as long as MISSING is not called from configure, because\n-# unfortunately $(top_srcdir) has no meaning in configure.\n-# However there are other variables, like CC, which are often used in\n-# configure, and could therefore not use this \"fixed\" $ac_aux_dir.\n-#\n-# Another solution, used here, is to always expand $ac_aux_dir to an\n-# absolute PATH.  The drawback is that using absolute paths prevent a\n-# configured tree to be moved without reconfiguration.\n-\n-AC_DEFUN([AM_AUX_DIR_EXPAND],\n-[dnl Rely on autoconf to set up CDPATH properly.\n-AC_PREREQ([2.50])dnl\n-# expand $ac_aux_dir to an absolute path\n-am_aux_dir=`cd $ac_aux_dir && pwd`\n-])\n-\n-# AM_CONDITIONAL                                            -*- Autoconf -*-\n-\n-# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008\n-# Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 9\n-\n-# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n-# -------------------------------------\n-# Define a conditional.\n-AC_DEFUN([AM_CONDITIONAL],\n-[AC_PREREQ(2.52)dnl\n- ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n-\t[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\n-AC_SUBST([$1_TRUE])dnl\n-AC_SUBST([$1_FALSE])dnl\n-_AM_SUBST_NOTMAKE([$1_TRUE])dnl\n-_AM_SUBST_NOTMAKE([$1_FALSE])dnl\n-m4_define([_AM_COND_VALUE_$1], [$2])dnl\n-if $2; then\n-  $1_TRUE=\n-  $1_FALSE='#'\n-else\n-  $1_TRUE='#'\n-  $1_FALSE=\n-fi\n-AC_CONFIG_COMMANDS_PRE(\n-[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n-  AC_MSG_ERROR([[conditional \"$1\" was never defined.\n-Usually this means the macro was only invoked conditionally.]])\n-fi])])\n-\n-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009,\n-# 2010, 2011 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 12\n-\n-# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be\n-# written in clear, in which case automake, when reading aclocal.m4,\n-# will think it sees a *use*, and therefore will trigger all it's\n-# C support machinery.  Also note that it means that autoscan, seeing\n-# CC etc. in the Makefile, will ask for an AC_PROG_CC use...\n-\n-\n-# _AM_DEPENDENCIES(NAME)\n-# ----------------------\n-# See how the compiler implements dependency checking.\n-# NAME is \"CC\", \"CXX\", \"GCJ\", or \"OBJC\".\n-# We try a few techniques and use that to set a single cache variable.\n-#\n-# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was\n-# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular\n-# dependency, and given that the user is not expected to run this macro,\n-# just rely on AC_PROG_CC.\n-AC_DEFUN([_AM_DEPENDENCIES],\n-[AC_REQUIRE([AM_SET_DEPDIR])dnl\n-AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl\n-AC_REQUIRE([AM_MAKE_INCLUDE])dnl\n-AC_REQUIRE([AM_DEP_TRACK])dnl\n-\n-ifelse([$1], CC,   [depcc=\"$CC\"   am_compiler_list=],\n-       [$1], CXX,  [depcc=\"$CXX\"  am_compiler_list=],\n-       [$1], OBJC, [depcc=\"$OBJC\" am_compiler_list='gcc3 gcc'],\n-       [$1], UPC,  [depcc=\"$UPC\"  am_compiler_list=],\n-       [$1], GCJ,  [depcc=\"$GCJ\"  am_compiler_list='gcc3 gcc'],\n-                   [depcc=\"$$1\"   am_compiler_list=])\n-\n-AC_CACHE_CHECK([dependency style of $depcc],\n-               [am_cv_$1_dependencies_compiler_type],\n-[if test -z \"$AMDEP_TRUE\" && test -f \"$am_depcomp\"; then\n-  # We make a subdir and do the tests there.  Otherwise we can end up\n-  # making bogus files that we don't know about and never remove.  For\n-  # instance it was reported that on HP-UX the gcc test will end up\n-  # making a dummy file named `D' -- because `-MD' means `put the output\n-  # in D'.\n-  rm -rf conftest.dir\n-  mkdir conftest.dir\n-  # Copy depcomp to subdir because otherwise we won't find it if we're\n-  # using a relative directory.\n-  cp \"$am_depcomp\" conftest.dir\n-  cd conftest.dir\n-  # We will build objects and dependencies in a subdirectory because\n-  # it helps to detect inapplicable dependency modes.  For instance\n-  # both Tru64's cc and ICC support -MD to output dependencies as a\n-  # side effect of compilation, but ICC will put the dependencies in\n-  # the current directory while Tru64 will put them in the object\n-  # directory.\n-  mkdir sub\n-\n-  am_cv_$1_dependencies_compiler_type=none\n-  if test \"$am_compiler_list\" = \"\"; then\n-     am_compiler_list=`sed -n ['s/^#*\\([a-zA-Z0-9]*\\))$/\\1/p'] < ./depcomp`\n-  fi\n-  am__universal=false\n-  m4_case([$1], [CC],\n-    [case \" $depcc \" in #(\n-     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n-     esac],\n-    [CXX],\n-    [case \" $depcc \" in #(\n-     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n-     esac])\n-\n-  for depmode in $am_compiler_list; do\n-    # Setup a source with many dependencies, because some compilers\n-    # like to wrap large dependency lists on column 80 (with \\), and\n-    # we should not choose a depcomp mode which is confused by this.\n-    #\n-    # We need to recreate these files for each test, as the compiler may\n-    # overwrite some of them when testing with obscure command lines.\n-    # This happens at least with the AIX C compiler.\n-    : > sub/conftest.c\n-    for i in 1 2 3 4 5 6; do\n-      echo '#include \"conftst'$i'.h\"' >> sub/conftest.c\n-      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with\n-      # Solaris 8's {/usr,}/bin/sh.\n-      touch sub/conftst$i.h\n-    done\n-    echo \"${am__include} ${am__quote}sub/conftest.Po${am__quote}\" > confmf\n-\n-    # We check with `-c' and `-o' for the sake of the \"dashmstdout\"\n-    # mode.  It turns out that the SunPro C++ compiler does not properly\n-    # handle `-M -o', and we need to detect this.  Also, some Intel\n-    # versions had trouble with output in subdirs\n-    am__obj=sub/conftest.${OBJEXT-o}\n-    am__minus_obj=\"-o $am__obj\"\n-    case $depmode in\n-    gcc)\n-      # This depmode causes a compiler race in universal mode.\n-      test \"$am__universal\" = false || continue\n-      ;;\n-    nosideeffect)\n-      # after this tag, mechanisms are not by side-effect, so they'll\n-      # only be used when explicitly requested\n-      if test \"x$enable_dependency_tracking\" = xyes; then\n-\tcontinue\n-      else\n-\tbreak\n-      fi\n-      ;;\n-    msvc7 | msvc7msys | msvisualcpp | msvcmsys)\n-      # This compiler won't grok `-c -o', but also, the minuso test has\n-      # not run yet.  These depmodes are late enough in the game, and\n-      # so weak that their functioning should not be impacted.\n-      am__obj=conftest.${OBJEXT-o}\n-      am__minus_obj=\n-      ;;\n-    none) break ;;\n-    esac\n-    if depmode=$depmode \\\n-       source=sub/conftest.c object=$am__obj \\\n-       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \\\n-       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \\\n-         >/dev/null 2>conftest.err &&\n-       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&\n-       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&\n-       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&\n-       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then\n-      # icc doesn't choke on unknown options, it will just issue warnings\n-      # or remarks (even with -Werror).  So we grep stderr for any message\n-      # that says an option was ignored or not supported.\n-      # When given -MP, icc 7.0 and 7.1 complain thusly:\n-      #   icc: Command line warning: ignoring option '-M'; no argument required\n-      # The diagnosis changed in icc 8.0:\n-      #   icc: Command line remark: option '-MP' not supported\n-      if (grep 'ignoring option' conftest.err ||\n-          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else\n-        am_cv_$1_dependencies_compiler_type=$depmode\n-        break\n-      fi\n-    fi\n-  done\n-\n-  cd ..\n-  rm -rf conftest.dir\n-else\n-  am_cv_$1_dependencies_compiler_type=none\n-fi\n-])\n-AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])\n-AM_CONDITIONAL([am__fastdep$1], [\n-  test \"x$enable_dependency_tracking\" != xno \\\n-  && test \"$am_cv_$1_dependencies_compiler_type\" = gcc3])\n-])\n-\n-\n-# AM_SET_DEPDIR\n-# -------------\n-# Choose a directory name for dependency files.\n-# This macro is AC_REQUIREd in _AM_DEPENDENCIES\n-AC_DEFUN([AM_SET_DEPDIR],\n-[AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n-AC_SUBST([DEPDIR], [\"${am__leading_dot}deps\"])dnl\n-])\n-\n-\n-# AM_DEP_TRACK\n-# ------------\n-AC_DEFUN([AM_DEP_TRACK],\n-[AC_ARG_ENABLE(dependency-tracking,\n-[  --disable-dependency-tracking  speeds up one-time build\n-  --enable-dependency-tracking   do not reject slow dependency extractors])\n-if test \"x$enable_dependency_tracking\" != xno; then\n-  am_depcomp=\"$ac_aux_dir/depcomp\"\n-  AMDEPBACKSLASH='\\'\n-  am__nodep='_no'\n-fi\n-AM_CONDITIONAL([AMDEP], [test \"x$enable_dependency_tracking\" != xno])\n-AC_SUBST([AMDEPBACKSLASH])dnl\n-_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl\n-AC_SUBST([am__nodep])dnl\n-_AM_SUBST_NOTMAKE([am__nodep])dnl\n-])\n-\n-# Generate code to set up dependency tracking.              -*- Autoconf -*-\n-\n-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008\n-# Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-#serial 5\n-\n-# _AM_OUTPUT_DEPENDENCY_COMMANDS\n-# ------------------------------\n-AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n-[{\n-  # Autoconf 2.62 quotes --file arguments for eval, but not when files\n-  # are listed without --file.  Let's play safe and only enable the eval\n-  # if we detect the quoting.\n-  case $CONFIG_FILES in\n-  *\\'*) eval set x \"$CONFIG_FILES\" ;;\n-  *)   set x $CONFIG_FILES ;;\n-  esac\n-  shift\n-  for mf\n-  do\n-    # Strip MF so we end up with the name of the file.\n-    mf=`echo \"$mf\" | sed -e 's/:.*$//'`\n-    # Check whether this is an Automake generated Makefile or not.\n-    # We used to match only the files named `Makefile.in', but\n-    # some people rename them; so instead we look at the file content.\n-    # Grep'ing the first line is not enough: some people post-process\n-    # each Makefile.in and add a new line on top of each file to say so.\n-    # Grep'ing the whole file is not good either: AIX grep has a line\n-    # limit of 2048, but all sed's we know have understand at least 4000.\n-    if sed -n 's,^#.*generated by automake.*,X,p' \"$mf\" | grep X >/dev/null 2>&1; then\n-      dirpart=`AS_DIRNAME(\"$mf\")`\n-    else\n-      continue\n-    fi\n-    # Extract the definition of DEPDIR, am__include, and am__quote\n-    # from the Makefile without running `make'.\n-    DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n-    test -z \"$DEPDIR\" && continue\n-    am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n-    test -z \"am__include\" && continue\n-    am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n-    # When using ansi2knr, U may be empty or an underscore; expand it\n-    U=`sed -n 's/^U = //p' < \"$mf\"`\n-    # Find all dependency output files, they are included files with\n-    # $(DEPDIR) in their names.  We invoke sed twice because it is the\n-    # simplest approach to changing $(DEPDIR) to its actual value in the\n-    # expansion.\n-    for file in `sed -n \"\n-      s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n-\t sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g' -e 's/\\$U/'\"$U\"'/g'`; do\n-      # Make sure the directory exists.\n-      test -f \"$dirpart/$file\" && continue\n-      fdir=`AS_DIRNAME([\"$file\"])`\n-      AS_MKDIR_P([$dirpart/$fdir])\n-      # echo \"creating $dirpart/$file\"\n-      echo '# dummy' > \"$dirpart/$file\"\n-    done\n-  done\n-}\n-])# _AM_OUTPUT_DEPENDENCY_COMMANDS\n-\n-\n-# AM_OUTPUT_DEPENDENCY_COMMANDS\n-# -----------------------------\n-# This macro should only be invoked once -- use via AC_REQUIRE.\n-#\n-# This code is only required when automatic dependency tracking\n-# is enabled.  FIXME.  This creates each `.P' file that we will\n-# need in order to bootstrap the dependency handling code.\n-AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n-[AC_CONFIG_COMMANDS([depfiles],\n-     [test x\"$AMDEP_TRUE\" != x\"\" || _AM_OUTPUT_DEPENDENCY_COMMANDS],\n-     [AMDEP_TRUE=\"$AMDEP_TRUE\" ac_aux_dir=\"$ac_aux_dir\"])\n-])\n-\n-# Do all the work for Automake.                             -*- Autoconf -*-\n-\n-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 16\n-\n-# This macro actually does too much.  Some checks are only needed if\n-# your package does certain things.  But this isn't really a big deal.\n-\n-# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n-# AM_INIT_AUTOMAKE([OPTIONS])\n-# -----------------------------------------------\n-# The call with PACKAGE and VERSION arguments is the old style\n-# call (pre autoconf-2.50), which is being phased out.  PACKAGE\n-# and VERSION should now be passed to AC_INIT and removed from\n-# the call to AM_INIT_AUTOMAKE.\n-# We support both call styles for the transition.  After\n-# the next Automake release, Autoconf can make the AC_INIT\n-# arguments mandatory, and then we can depend on a new Autoconf\n-# release and drop the old call support.\n-AC_DEFUN([AM_INIT_AUTOMAKE],\n-[AC_PREREQ([2.62])dnl\n-dnl Autoconf wants to disallow AM_ names.  We explicitly allow\n-dnl the ones we care about.\n-m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl\n-AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\n-AC_REQUIRE([AC_PROG_INSTALL])dnl\n-if test \"`cd $srcdir && pwd`\" != \"`pwd`\"; then\n-  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output\n-  # is not polluted with repeated \"-I.\"\n-  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl\n-  # test to see if srcdir already configured\n-  if test -f $srcdir/config.status; then\n-    AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n-  fi\n-fi\n-\n-# test whether we have cygpath\n-if test -z \"$CYGPATH_W\"; then\n-  if (cygpath --version) >/dev/null 2>/dev/null; then\n-    CYGPATH_W='cygpath -w'\n-  else\n-    CYGPATH_W=echo\n-  fi\n-fi\n-AC_SUBST([CYGPATH_W])\n-\n-# Define the identity of the package.\n-dnl Distinguish between old-style and new-style calls.\n-m4_ifval([$2],\n-[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl\n- AC_SUBST([PACKAGE], [$1])dnl\n- AC_SUBST([VERSION], [$2])],\n-[_AM_SET_OPTIONS([$1])dnl\n-dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.\n-m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,\n-  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl\n- AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl\n- AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl\n-\n-_AM_IF_OPTION([no-define],,\n-[AC_DEFINE_UNQUOTED(PACKAGE, \"$PACKAGE\", [Name of package])\n- AC_DEFINE_UNQUOTED(VERSION, \"$VERSION\", [Version number of package])])dnl\n-\n-# Some tools Automake needs.\n-AC_REQUIRE([AM_SANITY_CHECK])dnl\n-AC_REQUIRE([AC_ARG_PROGRAM])dnl\n-AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})\n-AM_MISSING_PROG(AUTOCONF, autoconf)\n-AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})\n-AM_MISSING_PROG(AUTOHEADER, autoheader)\n-AM_MISSING_PROG(MAKEINFO, makeinfo)\n-AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n-AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl\n-AC_REQUIRE([AM_PROG_MKDIR_P])dnl\n-# We need awk for the \"check\" target.  The system \"awk\" is bad on\n-# some platforms.\n-AC_REQUIRE([AC_PROG_AWK])dnl\n-AC_REQUIRE([AC_PROG_MAKE_SET])dnl\n-AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n-_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n-\t      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n-\t\t\t     [_AM_PROG_TAR([v7])])])\n-_AM_IF_OPTION([no-dependencies],,\n-[AC_PROVIDE_IFELSE([AC_PROG_CC],\n-\t\t  [_AM_DEPENDENCIES(CC)],\n-\t\t  [define([AC_PROG_CC],\n-\t\t\t  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl\n-AC_PROVIDE_IFELSE([AC_PROG_CXX],\n-\t\t  [_AM_DEPENDENCIES(CXX)],\n-\t\t  [define([AC_PROG_CXX],\n-\t\t\t  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl\n-AC_PROVIDE_IFELSE([AC_PROG_OBJC],\n-\t\t  [_AM_DEPENDENCIES(OBJC)],\n-\t\t  [define([AC_PROG_OBJC],\n-\t\t\t  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl\n-])\n-_AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl\n-dnl The `parallel-tests' driver may need to know about EXEEXT, so add the\n-dnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro\n-dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.\n-AC_CONFIG_COMMANDS_PRE(dnl\n-[m4_provide_if([_AM_COMPILER_EXEEXT],\n-  [AM_CONDITIONAL([am__EXEEXT], [test -n \"$EXEEXT\"])])])dnl\n-])\n-\n-dnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not\n-dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further\n-dnl mangled by Autoconf and run in a shell conditional statement.\n-m4_define([_AC_COMPILER_EXEEXT],\n-m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])\n-\n-\n-# When config.status generates a header, we must update the stamp-h file.\n-# This file resides in the same directory as the config header\n-# that is generated.  The stamp files are numbered to have different names.\n-\n-# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n-# loop where config.status creates the headers, so we can generate\n-# our stamp files there.\n-AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n-[# Compute $1's index in $config_headers.\n-_am_arg=$1\n-_am_stamp_count=1\n-for _am_header in $config_headers :; do\n-  case $_am_header in\n-    $_am_arg | $_am_arg:* )\n-      break ;;\n-    * )\n-      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n-  esac\n-done\n-echo \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n-\n-# Copyright (C) 2001, 2003, 2005, 2008, 2011 Free Software Foundation,\n-# Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 1\n-\n-# AM_PROG_INSTALL_SH\n-# ------------------\n-# Define $install_sh.\n-AC_DEFUN([AM_PROG_INSTALL_SH],\n-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n-if test x\"${install_sh}\" != xset; then\n-  case $am_aux_dir in\n-  *\\ * | *\\\t*)\n-    install_sh=\"\\${SHELL} '$am_aux_dir/install-sh'\" ;;\n-  *)\n-    install_sh=\"\\${SHELL} $am_aux_dir/install-sh\"\n-  esac\n-fi\n-AC_SUBST(install_sh)])\n-\n-# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-\n-# From Jim Meyering\n-\n-# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008,\n-# 2011 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 5\n-\n-# AM_MAINTAINER_MODE([DEFAULT-MODE])\n-# ----------------------------------\n-# Control maintainer-specific portions of Makefiles.\n-# Default is to disable them, unless `enable' is passed literally.\n-# For symmetry, `disable' may be passed as well.  Anyway, the user\n-# can override the default with the --enable/--disable switch.\n-AC_DEFUN([AM_MAINTAINER_MODE],\n-[m4_case(m4_default([$1], [disable]),\n-       [enable], [m4_define([am_maintainer_other], [disable])],\n-       [disable], [m4_define([am_maintainer_other], [enable])],\n-       [m4_define([am_maintainer_other], [enable])\n-        m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])\n-AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])\n-  dnl maintainer-mode's default is 'disable' unless 'enable' is passed\n-  AC_ARG_ENABLE([maintainer-mode],\n-[  --][am_maintainer_other][-maintainer-mode  am_maintainer_other make rules and dependencies not useful\n-\t\t\t  (and sometimes confusing) to the casual installer],\n-      [USE_MAINTAINER_MODE=$enableval],\n-      [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))\n-  AC_MSG_RESULT([$USE_MAINTAINER_MODE])\n-  AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])\n-  MAINT=$MAINTAINER_MODE_TRUE\n-  AC_SUBST([MAINT])dnl\n-]\n-)\n-\n-AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])\n-\n-# Check to see how 'make' treats includes.\t            -*- Autoconf -*-\n-\n-# Copyright (C) 2001, 2002, 2003, 2005, 2009  Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 4\n-\n-# AM_MAKE_INCLUDE()\n-# -----------------\n-# Check to see how make treats includes.\n-AC_DEFUN([AM_MAKE_INCLUDE],\n-[am_make=${MAKE-make}\n-cat > confinc << 'END'\n-am__doit:\n-\t@echo this is the am__doit target\n-.PHONY: am__doit\n-END\n-# If we don't find an include directive, just comment out the code.\n-AC_MSG_CHECKING([for style of include used by $am_make])\n-am__include=\"#\"\n-am__quote=\n-_am_result=none\n-# First try GNU make style include.\n-echo \"include confinc\" > confmf\n-# Ignore all kinds of additional output from `make'.\n-case `$am_make -s -f confmf 2> /dev/null` in #(\n-*the\\ am__doit\\ target*)\n-  am__include=include\n-  am__quote=\n-  _am_result=GNU\n-  ;;\n-esac\n-# Now try BSD make style include.\n-if test \"$am__include\" = \"#\"; then\n-   echo '.include \"confinc\"' > confmf\n-   case `$am_make -s -f confmf 2> /dev/null` in #(\n-   *the\\ am__doit\\ target*)\n-     am__include=.include\n-     am__quote=\"\\\"\"\n-     _am_result=BSD\n-     ;;\n-   esac\n-fi\n-AC_SUBST([am__include])\n-AC_SUBST([am__quote])\n-AC_MSG_RESULT([$_am_result])\n-rm -f confinc confmf\n-])\n-\n-# Copyright (C) 1999, 2000, 2001, 2003, 2004, 2005, 2008\n-# Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 6\n-\n-# AM_PROG_CC_C_O\n-# --------------\n-# Like AC_PROG_CC_C_O, but changed for automake.\n-AC_DEFUN([AM_PROG_CC_C_O],\n-[AC_REQUIRE([AC_PROG_CC_C_O])dnl\n-AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n-AC_REQUIRE_AUX_FILE([compile])dnl\n-# FIXME: we rely on the cache variable name because\n-# there is no other way.\n-set dummy $CC\n-am_cc=`echo $[2] | sed ['s/[^a-zA-Z0-9_]/_/g;s/^[0-9]/_/']`\n-eval am_t=\\$ac_cv_prog_cc_${am_cc}_c_o\n-if test \"$am_t\" != yes; then\n-   # Losing compiler, so override with the script.\n-   # FIXME: It is wrong to rewrite CC.\n-   # But if we don't then we get into trouble of one sort or another.\n-   # A longer-term fix would be to have automake use am__CC in this case,\n-   # and then we could set am__CC=\"\\$(top_srcdir)/compile \\$(CC)\"\n-   CC=\"$am_aux_dir/compile $CC\"\n-fi\n-dnl Make sure AC_PROG_CC is never called again, or it will override our\n-dnl setting of CC.\n-m4_define([AC_PROG_CC],\n-          [m4_fatal([AC_PROG_CC cannot be called after AM_PROG_CC_C_O])])\n-])\n-\n-# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n-\n-# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008\n-# Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 6\n-\n-# AM_MISSING_PROG(NAME, PROGRAM)\n-# ------------------------------\n-AC_DEFUN([AM_MISSING_PROG],\n-[AC_REQUIRE([AM_MISSING_HAS_RUN])\n-$1=${$1-\"${am_missing_run}$2\"}\n-AC_SUBST($1)])\n-\n-\n-# AM_MISSING_HAS_RUN\n-# ------------------\n-# Define MISSING if not defined so far and test if it supports --run.\n-# If it does, set am_missing_run to use it, otherwise, to nothing.\n-AC_DEFUN([AM_MISSING_HAS_RUN],\n-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n-AC_REQUIRE_AUX_FILE([missing])dnl\n-if test x\"${MISSING+set}\" != xset; then\n-  case $am_aux_dir in\n-  *\\ * | *\\\t*)\n-    MISSING=\"\\${SHELL} \\\"$am_aux_dir/missing\\\"\" ;;\n-  *)\n-    MISSING=\"\\${SHELL} $am_aux_dir/missing\" ;;\n-  esac\n-fi\n-# Use eval to expand $SHELL\n-if eval \"$MISSING --run true\"; then\n-  am_missing_run=\"$MISSING --run \"\n-else\n-  am_missing_run=\n-  AC_MSG_WARN([`missing' script is too old or missing])\n-fi\n-])\n-\n-# Copyright (C) 2003, 2004, 2005, 2006, 2011 Free Software Foundation,\n-# Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 1\n-\n-# AM_PROG_MKDIR_P\n-# ---------------\n-# Check for `mkdir -p'.\n-AC_DEFUN([AM_PROG_MKDIR_P],\n-[AC_PREREQ([2.60])dnl\n-AC_REQUIRE([AC_PROG_MKDIR_P])dnl\n-dnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,\n-dnl while keeping a definition of mkdir_p for backward compatibility.\n-dnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.\n-dnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of\n-dnl Makefile.ins that do not define MKDIR_P, so we do our own\n-dnl adjustment using top_builddir (which is defined more often than\n-dnl MKDIR_P).\n-AC_SUBST([mkdir_p], [\"$MKDIR_P\"])dnl\n-case $mkdir_p in\n-  [[\\\\/$]]* | ?:[[\\\\/]]*) ;;\n-  */*) mkdir_p=\"\\$(top_builddir)/$mkdir_p\" ;;\n-esac\n-])\n-\n-# Helper functions for option handling.                     -*- Autoconf -*-\n-\n-# Copyright (C) 2001, 2002, 2003, 2005, 2008, 2010 Free Software\n-# Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 5\n-\n-# _AM_MANGLE_OPTION(NAME)\n-# -----------------------\n-AC_DEFUN([_AM_MANGLE_OPTION],\n-[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n-\n-# _AM_SET_OPTION(NAME)\n-# --------------------\n-# Set option NAME.  Presently that only means defining a flag for this option.\n-AC_DEFUN([_AM_SET_OPTION],\n-[m4_define(_AM_MANGLE_OPTION([$1]), 1)])\n-\n-# _AM_SET_OPTIONS(OPTIONS)\n-# ------------------------\n-# OPTIONS is a space-separated list of Automake options.\n-AC_DEFUN([_AM_SET_OPTIONS],\n-[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n-\n-# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])\n-# -------------------------------------------\n-# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\n-AC_DEFUN([_AM_IF_OPTION],\n-[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n-\n-# Check to make sure that the build environment is sane.    -*- Autoconf -*-\n-\n-# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008\n-# Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 5\n-\n-# AM_SANITY_CHECK\n-# ---------------\n-AC_DEFUN([AM_SANITY_CHECK],\n-[AC_MSG_CHECKING([whether build environment is sane])\n-# Just in case\n-sleep 1\n-echo timestamp > conftest.file\n-# Reject unsafe characters in $srcdir or the absolute working directory\n-# name.  Accept space and tab only in the latter.\n-am_lf='\n-'\n-case `pwd` in\n-  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf]]*)\n-    AC_MSG_ERROR([unsafe absolute working directory name]);;\n-esac\n-case $srcdir in\n-  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf\\ \\\t]]*)\n-    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;\n-esac\n-\n-# Do `set' in a subshell so we don't clobber the current shell's\n-# arguments.  Must try -L first in case configure is actually a\n-# symlink; some systems play weird games with the mod time of symlinks\n-# (eg FreeBSD returns the mod time of the symlink's containing\n-# directory).\n-if (\n-   set X `ls -Lt \"$srcdir/configure\" conftest.file 2> /dev/null`\n-   if test \"$[*]\" = \"X\"; then\n-      # -L didn't work.\n-      set X `ls -t \"$srcdir/configure\" conftest.file`\n-   fi\n-   rm -f conftest.file\n-   if test \"$[*]\" != \"X $srcdir/configure conftest.file\" \\\n-      && test \"$[*]\" != \"X conftest.file $srcdir/configure\"; then\n-\n-      # If neither matched, then we have a broken ls.  This can happen\n-      # if, for instance, CONFIG_SHELL is bash and it inherits a\n-      # broken ls alias from the environment.  This has actually\n-      # happened.  Such a system could not be considered \"sane\".\n-      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\n-alias in your environment])\n-   fi\n-\n-   test \"$[2]\" = conftest.file\n-   )\n-then\n-   # Ok.\n-   :\n-else\n-   AC_MSG_ERROR([newly created file is older than distributed files!\n-Check your system clock])\n-fi\n-AC_MSG_RESULT(yes)])\n-\n-# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 1\n-\n-# AM_PROG_INSTALL_STRIP\n-# ---------------------\n-# One issue with vendor `install' (even GNU) is that you can't\n-# specify the program used to strip binaries.  This is especially\n-# annoying in cross-compiling environments, where the build's strip\n-# is unlikely to handle the host's binaries.\n-# Fortunately install-sh will honor a STRIPPROG variable, so we\n-# always use install-sh in `make install-strip', and initialize\n-# STRIPPROG with the value of the STRIP variable (set by the user).\n-AC_DEFUN([AM_PROG_INSTALL_STRIP],\n-[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n-# Installed binaries are usually stripped using `strip' when the user\n-# run `make install-strip'.  However `strip' might not be the right\n-# tool to use in cross-compilation environments, therefore Automake\n-# will honor the `STRIP' environment variable to overrule this program.\n-dnl Don't test for $cross_compiling = yes, because it might be `maybe'.\n-if test \"$cross_compiling\" != no; then\n-  AC_CHECK_TOOL([STRIP], [strip], :)\n-fi\n-INSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\n-AC_SUBST([INSTALL_STRIP_PROGRAM])])\n-\n-# Copyright (C) 2006, 2008, 2010 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 3\n-\n-# _AM_SUBST_NOTMAKE(VARIABLE)\n-# ---------------------------\n-# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.\n-# This macro is traced by Automake.\n-AC_DEFUN([_AM_SUBST_NOTMAKE])\n-\n-# AM_SUBST_NOTMAKE(VARIABLE)\n-# --------------------------\n-# Public sister of _AM_SUBST_NOTMAKE.\n-AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n-\n-# Check how to create a tarball.                            -*- Autoconf -*-\n-\n-# Copyright (C) 2004, 2005, 2012 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 2\n-\n-# _AM_PROG_TAR(FORMAT)\n-# --------------------\n-# Check how to create a tarball in format FORMAT.\n-# FORMAT should be one of `v7', `ustar', or `pax'.\n-#\n-# Substitute a variable $(am__tar) that is a command\n-# writing to stdout a FORMAT-tarball containing the directory\n-# $tardir.\n-#     tardir=directory && $(am__tar) > result.tar\n-#\n-# Substitute a variable $(am__untar) that extract such\n-# a tarball read from stdin.\n-#     $(am__untar) < result.tar\n-AC_DEFUN([_AM_PROG_TAR],\n-[# Always define AMTAR for backward compatibility.  Yes, it's still used\n-# in the wild :-(  We should find a proper way to deprecate it ...\n-AC_SUBST([AMTAR], ['$${TAR-tar}'])\n-m4_if([$1], [v7],\n-     [am__tar='$${TAR-tar} chof - \"$$tardir\"' am__untar='$${TAR-tar} xf -'],\n-     [m4_case([$1], [ustar],, [pax],,\n-              [m4_fatal([Unknown tar format])])\n-AC_MSG_CHECKING([how to create a $1 tar archive])\n-# Loop over all known methods to create a tar archive until one works.\n-_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n-_am_tools=${am_cv_prog_tar_$1-$_am_tools}\n-# Do not fold the above two line into one, because Tru64 sh and\n-# Solaris sh will not grok spaces in the rhs of `-'.\n-for _am_tool in $_am_tools\n-do\n-  case $_am_tool in\n-  gnutar)\n-    for _am_tar in tar gnutar gtar;\n-    do\n-      AM_RUN_LOG([$_am_tar --version]) && break\n-    done\n-    am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n-    am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n-    am__untar=\"$_am_tar -xf -\"\n-    ;;\n-  plaintar)\n-    # Must skip GNU tar: if it does not support --format= it doesn't create\n-    # ustar tarball either.\n-    (tar --version) >/dev/null 2>&1 && continue\n-    am__tar='tar chf - \"$$tardir\"'\n-    am__tar_='tar chf - \"$tardir\"'\n-    am__untar='tar xf -'\n-    ;;\n-  pax)\n-    am__tar='pax -L -x $1 -w \"$$tardir\"'\n-    am__tar_='pax -L -x $1 -w \"$tardir\"'\n-    am__untar='pax -r'\n-    ;;\n-  cpio)\n-    am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n-    am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n-    am__untar='cpio -i -H $1 -d'\n-    ;;\n-  none)\n-    am__tar=false\n-    am__tar_=false\n-    am__untar=false\n-    ;;\n-  esac\n-\n-  # If the value was cached, stop now.  We just wanted to have am__tar\n-  # and am__untar set.\n-  test -n \"${am_cv_prog_tar_$1}\" && break\n-\n-  # tar/untar a dummy directory, and stop if the command works\n-  rm -rf conftest.dir\n-  mkdir conftest.dir\n-  echo GrepMe > conftest.dir/file\n-  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n-  rm -rf conftest.dir\n-  if test -s conftest.tar; then\n-    AM_RUN_LOG([$am__untar <conftest.tar])\n-    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n-  fi\n-done\n-rm -rf conftest.dir\n-\n-AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\n-AC_MSG_RESULT([$am_cv_prog_tar_$1])])\n-AC_SUBST([am__tar])\n-AC_SUBST([am__untar])\n-]) # _AM_PROG_TAR\n-\n-m4_include([../config/acx.m4])\n-m4_include([../config/depstand.m4])\n-m4_include([../config/lead-dot.m4])\n-m4_include([../config/multi.m4])\n-m4_include([../config/no-executables.m4])\n-m4_include([../config/override.m4])\n-m4_include([../libtool.m4])\n-m4_include([../ltoptions.m4])\n-m4_include([../ltsugar.m4])\n-m4_include([../ltversion.m4])\n-m4_include([../lt~obsolete.m4])"}, {"sha": "59515c7866e2506c80d829ae57968f063bb5e578", "filename": "boehm-gc/add_gc_prefix.c", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fadd_gc_prefix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fadd_gc_prefix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fadd_gc_prefix.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,20 +0,0 @@\n-# include <stdio.h>\n-# include \"version.h\"\n- \n-int main(argc, argv, envp)\n-int argc;\n-char ** argv;\n-char ** envp;\n-{\n-    int i;\n-    \n-    for (i = 1; i < argc; i++) {\n-      if (GC_ALPHA_VERSION == GC_NOT_ALPHA) {\n-\tprintf(\"gc%d.%d/%s \", GC_VERSION_MAJOR, GC_VERSION_MINOR, argv[i]);\n-      } else {\n-\tprintf(\"gc%d.%dalpha%d/%s \", GC_VERSION_MAJOR,\n-\t       GC_VERSION_MINOR, GC_ALPHA_VERSION, argv[i]);\n-      }\n-    }\n-    return(0);\n-}"}, {"sha": "1a1efc6b91b920dcdacdf1582394eb63ee461443", "filename": "boehm-gc/allchblk.c", "status": "removed", "additions": 0, "deletions": 838, "changes": 838, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fallchblk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fallchblk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fallchblk.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,838 +0,0 @@\n-/* \n- * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n- * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n- * Copyright (c) 1998-1999 by Silicon Graphics.  All rights reserved.\n- * Copyright (c) 1999 by Hewlett-Packard Company. All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n-\n-/* #define DEBUG */\n-#include <stdio.h>\n-#include \"private/gc_priv.h\"\n-\n-GC_bool GC_use_entire_heap = 0;\n-\n-/*\n- * Free heap blocks are kept on one of several free lists,\n- * depending on the size of the block.  Each free list is doubly linked.\n- * Adjacent free blocks are coalesced.\n- */\n-\n- \n-# define MAX_BLACK_LIST_ALLOC (2*HBLKSIZE)\n-\t\t/* largest block we will allocate starting on a black   */\n-\t\t/* listed block.  Must be >= HBLKSIZE.\t\t\t*/\n-\n-\n-# define UNIQUE_THRESHOLD 32\n-\t/* Sizes up to this many HBLKs each have their own free list    */\n-# define HUGE_THRESHOLD 256\n-\t/* Sizes of at least this many heap blocks are mapped to a\t*/\n-\t/* single free list.\t\t\t\t\t\t*/\n-# define FL_COMPRESSION 8\n-\t/* In between sizes map this many distinct sizes to a single\t*/\n-\t/* bin.\t\t\t\t\t\t\t\t*/\n-\n-# define N_HBLK_FLS (HUGE_THRESHOLD - UNIQUE_THRESHOLD)/FL_COMPRESSION \\\n-\t\t\t\t + UNIQUE_THRESHOLD\n-\n-struct hblk * GC_hblkfreelist[N_HBLK_FLS+1] = { 0 };\n-\n-#ifndef USE_MUNMAP\n-\n-  word GC_free_bytes[N_HBLK_FLS+1] = { 0 };\n-\t/* Number of free bytes on each list.\t*/\n-\n-  /* Is bytes + the number of free bytes on lists n .. N_HBLK_FLS \t*/\n-  /* > GC_max_large_allocd_bytes?\t\t\t\t\t*/\n-# ifdef __GNUC__\n-  __inline__\n-# endif\n-  static GC_bool GC_enough_large_bytes_left(bytes,n)\n-  word bytes;\n-  int n;\n-  {\n-    int i;\n-    for (i = N_HBLK_FLS; i >= n; --i) {\n-\tbytes += GC_free_bytes[i];\n-\tif (bytes > GC_max_large_allocd_bytes) return TRUE;\n-    }\n-    return FALSE;\n-  }\n-\n-# define INCR_FREE_BYTES(n, b) GC_free_bytes[n] += (b);\n-\n-# define FREE_ASSERT(e) GC_ASSERT(e)\n-\n-#else /* USE_MUNMAP */\n-\n-# define INCR_FREE_BYTES(n, b)\n-# define FREE_ASSERT(e)\n-\n-#endif /* USE_MUNMAP */\n-\n-/* Map a number of blocks to the appropriate large block free list index. */\n-int GC_hblk_fl_from_blocks(blocks_needed)\n-word blocks_needed;\n-{\n-    if (blocks_needed <= UNIQUE_THRESHOLD) return blocks_needed;\n-    if (blocks_needed >= HUGE_THRESHOLD) return N_HBLK_FLS;\n-    return (blocks_needed - UNIQUE_THRESHOLD)/FL_COMPRESSION\n-\t\t\t\t\t+ UNIQUE_THRESHOLD;\n-    \n-}\n-\n-# define PHDR(hhdr) HDR(hhdr -> hb_prev)\n-# define NHDR(hhdr) HDR(hhdr -> hb_next)\n-\n-# ifdef USE_MUNMAP\n-#   define IS_MAPPED(hhdr) (((hhdr) -> hb_flags & WAS_UNMAPPED) == 0)\n-# else  /* !USE_MMAP */\n-#   define IS_MAPPED(hhdr) 1\n-# endif /* USE_MUNMAP */\n-\n-# if !defined(NO_DEBUGGING)\n-void GC_print_hblkfreelist()\n-{\n-    struct hblk * h;\n-    word total_free = 0;\n-    hdr * hhdr;\n-    word sz;\n-    int i;\n-    \n-    for (i = 0; i <= N_HBLK_FLS; ++i) {\n-      h = GC_hblkfreelist[i];\n-#     ifdef USE_MUNMAP\n-        if (0 != h) GC_printf1(\"Free list %ld:\\n\",\n-\t\t               (unsigned long)i);\n-#     else\n-        if (0 != h) GC_printf2(\"Free list %ld (Total size %ld):\\n\",\n-\t\t               (unsigned long)i,\n-\t\t\t       (unsigned long)GC_free_bytes[i]);\n-#     endif\n-      while (h != 0) {\n-        hhdr = HDR(h);\n-        sz = hhdr -> hb_sz;\n-    \tGC_printf2(\"\\t0x%lx size %lu \", (unsigned long)h, (unsigned long)sz);\n-    \ttotal_free += sz;\n-        if (GC_is_black_listed(h, HBLKSIZE) != 0) {\n-             GC_printf0(\"start black listed\\n\");\n-        } else if (GC_is_black_listed(h, hhdr -> hb_sz) != 0) {\n-             GC_printf0(\"partially black listed\\n\");\n-        } else {\n-             GC_printf0(\"not black listed\\n\");\n-        }\n-        h = hhdr -> hb_next;\n-      }\n-    }\n-#   ifndef USE_MUNMAP\n-      if (total_free != GC_large_free_bytes) {\n-\tGC_printf1(\"GC_large_free_bytes = %lu (INCONSISTENT!!)\\n\",\n-\t\t   (unsigned long) GC_large_free_bytes);\n-      }\n-#   endif\n-    GC_printf1(\"Total of %lu bytes on free list\\n\", (unsigned long)total_free);\n-}\n-\n-/* Return the free list index on which the block described by the header */\n-/* appears, or -1 if it appears nowhere.\t\t\t\t */\n-int free_list_index_of(wanted)\n-hdr * wanted;\n-{\n-    struct hblk * h;\n-    hdr * hhdr;\n-    int i;\n-    \n-    for (i = 0; i <= N_HBLK_FLS; ++i) {\n-      h = GC_hblkfreelist[i];\n-      while (h != 0) {\n-        hhdr = HDR(h);\n-\tif (hhdr == wanted) return i;\n-        h = hhdr -> hb_next;\n-      }\n-    }\n-    return -1;\n-}\n-\n-void GC_dump_regions()\n-{\n-    unsigned i;\n-    ptr_t start, end;\n-    ptr_t p;\n-    size_t bytes;\n-    hdr *hhdr;\n-    for (i = 0; i < GC_n_heap_sects; ++i) {\n-\tstart = GC_heap_sects[i].hs_start;\n-\tbytes = GC_heap_sects[i].hs_bytes;\n-\tend = start + bytes;\n-\t/* Merge in contiguous sections.\t*/\n-\t  while (i+1 < GC_n_heap_sects && GC_heap_sects[i+1].hs_start == end) {\n-\t    ++i;\n-\t    end = GC_heap_sects[i].hs_start + GC_heap_sects[i].hs_bytes;\n-\t  }\n-\tGC_printf2(\"***Section from 0x%lx to 0x%lx\\n\", start, end);\n-\tfor (p = start; p < end;) {\n-\t    hhdr = HDR(p);\n-\t    GC_printf1(\"\\t0x%lx \", (unsigned long)p);\n-\t    if (IS_FORWARDING_ADDR_OR_NIL(hhdr)) {\n-\t\tGC_printf1(\"Missing header!!(%ld)\\n\", hhdr);\n-\t\tp += HBLKSIZE;\n-\t\tcontinue;\n-\t    }\n-\t    if (HBLK_IS_FREE(hhdr)) {\n-                int correct_index = GC_hblk_fl_from_blocks(\n-\t\t\t\t\tdivHBLKSZ(hhdr -> hb_sz));\n-\t        int actual_index;\n-\t\t\n-\t\tGC_printf1(\"\\tfree block of size 0x%lx bytes\",\n-\t\t\t   (unsigned long)(hhdr -> hb_sz));\n-\t \tif (IS_MAPPED(hhdr)) {\n-\t\t    GC_printf0(\"\\n\");\n-\t\t} else {\n-\t\t    GC_printf0(\"(unmapped)\\n\");\n-\t\t}\n-\t\tactual_index = free_list_index_of(hhdr);\n-\t\tif (-1 == actual_index) {\n-\t\t    GC_printf1(\"\\t\\tBlock not on free list %ld!!\\n\",\n-\t\t\t\tcorrect_index);\n-\t\t} else if (correct_index != actual_index) {\n-\t\t    GC_printf2(\"\\t\\tBlock on list %ld, should be on %ld!!\\n\",\n-\t\t\t       actual_index, correct_index);\n-\t\t}\n-\t\tp += hhdr -> hb_sz;\n-\t    } else {\n-\t\tGC_printf1(\"\\tused for blocks of size 0x%lx bytes\\n\",\n-\t\t\t   (unsigned long)WORDS_TO_BYTES(hhdr -> hb_sz));\n-\t\tp += HBLKSIZE * OBJ_SZ_TO_BLOCKS(hhdr -> hb_sz);\n-\t    }\n-\t}\n-    }\n-}\n-\n-# endif /* NO_DEBUGGING */\n-\n-/* Initialize hdr for a block containing the indicated size and \t*/\n-/* kind of objects.\t\t\t\t\t\t\t*/\n-/* Return FALSE on failure.\t\t\t\t\t\t*/\n-static GC_bool setup_header(hhdr, sz, kind, flags)\n-register hdr * hhdr;\n-word sz;\t/* object size in words */\n-int kind;\n-unsigned char flags;\n-{\n-    register word descr;\n-    \n-    /* Add description of valid object pointers */\n-      if (!GC_add_map_entry(sz)) return(FALSE);\n-      hhdr -> hb_map = GC_obj_map[sz > MAXOBJSZ? 0 : sz];\n-      \n-    /* Set size, kind and mark proc fields */\n-      hhdr -> hb_sz = sz;\n-      hhdr -> hb_obj_kind = kind;\n-      hhdr -> hb_flags = flags;\n-      descr = GC_obj_kinds[kind].ok_descriptor;\n-      if (GC_obj_kinds[kind].ok_relocate_descr) descr += WORDS_TO_BYTES(sz);\n-      hhdr -> hb_descr = descr;\n-      \n-    /* Clear mark bits */\n-      GC_clear_hdr_marks(hhdr);\n-      \n-    hhdr -> hb_last_reclaimed = (unsigned short)GC_gc_no;\n-    return(TRUE);\n-}\n-\n-#define FL_UNKNOWN -1\n-/*\n- * Remove hhdr from the appropriate free list.\n- * We assume it is on the nth free list, or on the size\n- * appropriate free list if n is FL_UNKNOWN.\n- */\n-void GC_remove_from_fl(hhdr, n)\n-hdr * hhdr;\n-int n;\n-{\n-    int index;\n-\n-    GC_ASSERT(((hhdr -> hb_sz) & (HBLKSIZE-1)) == 0);\n-#   ifndef USE_MUNMAP\n-      /* We always need index to mainatin free counts.\t*/\n-      if (FL_UNKNOWN == n) {\n-          index = GC_hblk_fl_from_blocks(divHBLKSZ(hhdr -> hb_sz));\n-      } else {\n-\t  index = n;\n-      }\n-#   endif\n-    if (hhdr -> hb_prev == 0) {\n-#\tifdef USE_MUNMAP\n-\t  if (FL_UNKNOWN == n) {\n-            index = GC_hblk_fl_from_blocks(divHBLKSZ(hhdr -> hb_sz));\n-\t  } else {\n-\t    index = n;\n-\t  }\n-#\tendif\n-\tGC_ASSERT(HDR(GC_hblkfreelist[index]) == hhdr);\n-\tGC_hblkfreelist[index] = hhdr -> hb_next;\n-    } else {\n-\thdr *phdr;\n-\tGET_HDR(hhdr -> hb_prev, phdr);\n-\tphdr -> hb_next = hhdr -> hb_next;\n-    }\n-    FREE_ASSERT(GC_free_bytes[index] >= hhdr -> hb_sz);\n-    INCR_FREE_BYTES(index, - (signed_word)(hhdr -> hb_sz));\n-    if (0 != hhdr -> hb_next) {\n-\thdr * nhdr;\n-\tGC_ASSERT(!IS_FORWARDING_ADDR_OR_NIL(NHDR(hhdr)));\n-\tGET_HDR(hhdr -> hb_next, nhdr);\n-\tnhdr -> hb_prev = hhdr -> hb_prev;\n-    }\n-}\n-\n-/*\n- * Return a pointer to the free block ending just before h, if any.\n- */\n-struct hblk * GC_free_block_ending_at(h)\n-struct hblk *h;\n-{\n-    struct hblk * p = h - 1;\n-    hdr * phdr;\n-\n-    GET_HDR(p, phdr);\n-    while (0 != phdr && IS_FORWARDING_ADDR_OR_NIL(phdr)) {\n-\tp = FORWARDED_ADDR(p,phdr);\n-\tphdr = HDR(p);\n-    }\n-    if (0 != phdr) {\n-        if(HBLK_IS_FREE(phdr)) {\n-\t    return p;\n-\t} else {\n-\t    return 0;\n-\t}\n-    }\n-    p = GC_prev_block(h - 1);\n-    if (0 != p) {\n-      phdr = HDR(p);\n-      if (HBLK_IS_FREE(phdr) && (ptr_t)p + phdr -> hb_sz == (ptr_t)h) {\n-\treturn p;\n-      }\n-    }\n-    return 0;\n-}\n-\n-/*\n- * Add hhdr to the appropriate free list.\n- * We maintain individual free lists sorted by address.\n- */\n-void GC_add_to_fl(h, hhdr)\n-struct hblk *h;\n-hdr * hhdr;\n-{\n-    int index = GC_hblk_fl_from_blocks(divHBLKSZ(hhdr -> hb_sz));\n-    struct hblk *second = GC_hblkfreelist[index];\n-    hdr * second_hdr;\n-#   ifdef GC_ASSERTIONS\n-      struct hblk *next = (struct hblk *)((word)h + hhdr -> hb_sz);\n-      hdr * nexthdr = HDR(next);\n-      struct hblk *prev = GC_free_block_ending_at(h);\n-      hdr * prevhdr = HDR(prev);\n-      GC_ASSERT(nexthdr == 0 || !HBLK_IS_FREE(nexthdr) || !IS_MAPPED(nexthdr));\n-      GC_ASSERT(prev == 0 || !HBLK_IS_FREE(prevhdr) || !IS_MAPPED(prevhdr));\n-#   endif\n-    GC_ASSERT(((hhdr -> hb_sz) & (HBLKSIZE-1)) == 0);\n-    GC_hblkfreelist[index] = h;\n-    INCR_FREE_BYTES(index, hhdr -> hb_sz);\n-    FREE_ASSERT(GC_free_bytes[index] <= GC_large_free_bytes)\n-    hhdr -> hb_next = second;\n-    hhdr -> hb_prev = 0;\n-    if (0 != second) {\n-      GET_HDR(second, second_hdr);\n-      second_hdr -> hb_prev = h;\n-    }\n-    GC_invalidate_map(hhdr);\n-}\n-\n-#ifdef USE_MUNMAP\n-\n-/* Unmap blocks that haven't been recently touched.  This is the only way */\n-/* way blocks are ever unmapped.\t\t\t\t\t  */\n-void GC_unmap_old(void)\n-{\n-    struct hblk * h;\n-    hdr * hhdr;\n-    word sz;\n-    unsigned short last_rec, threshold;\n-    int i;\n-#   define UNMAP_THRESHOLD 6\n-    \n-    for (i = 0; i <= N_HBLK_FLS; ++i) {\n-      for (h = GC_hblkfreelist[i]; 0 != h; h = hhdr -> hb_next) {\n-        hhdr = HDR(h);\n-\tif (!IS_MAPPED(hhdr)) continue;\n-\tthreshold = (unsigned short)(GC_gc_no - UNMAP_THRESHOLD);\n-\tlast_rec = hhdr -> hb_last_reclaimed;\n-\tif ((last_rec > GC_gc_no || last_rec < threshold)\n-\t    && threshold < GC_gc_no /* not recently wrapped */) {\n-          sz = hhdr -> hb_sz;\n-\t  GC_unmap((ptr_t)h, sz);\n-\t  hhdr -> hb_flags |= WAS_UNMAPPED;\n-    \t}\n-      }\n-    }  \n-}\n-\n-/* Merge all unmapped blocks that are adjacent to other free\t\t*/\n-/* blocks.  This may involve remapping, since all blocks are either\t*/\n-/* fully mapped or fully unmapped.\t\t\t\t\t*/\n-void GC_merge_unmapped(void)\n-{\n-    struct hblk * h, *next;\n-    hdr * hhdr, *nexthdr;\n-    word size, nextsize;\n-    int i;\n-    \n-    for (i = 0; i <= N_HBLK_FLS; ++i) {\n-      h = GC_hblkfreelist[i];\n-      while (h != 0) {\n-\tGET_HDR(h, hhdr);\n-\tsize = hhdr->hb_sz;\n-\tnext = (struct hblk *)((word)h + size);\n-\tGET_HDR(next, nexthdr);\n-\t/* Coalesce with successor, if possible */\n-\t  if (0 != nexthdr && HBLK_IS_FREE(nexthdr)) {\n-\t    nextsize = nexthdr -> hb_sz;\n-\t    if (IS_MAPPED(hhdr)) {\n-\t      GC_ASSERT(!IS_MAPPED(nexthdr));\n-\t      /* make both consistent, so that we can merge */\n-\t        if (size > nextsize) {\n-\t\t  GC_remap((ptr_t)next, nextsize);\n-\t\t} else {\n-\t\t  GC_unmap((ptr_t)h, size);\n-\t\t  hhdr -> hb_flags |= WAS_UNMAPPED;\n-\t\t}\n-\t    } else if (IS_MAPPED(nexthdr)) {\n-\t      GC_ASSERT(!IS_MAPPED(hhdr));\n-\t      if (size > nextsize) {\n-\t\tGC_unmap((ptr_t)next, nextsize);\n-\t      } else {\n-\t\tGC_remap((ptr_t)h, size);\n-\t\thhdr -> hb_flags &= ~WAS_UNMAPPED;\n-\t\thhdr -> hb_last_reclaimed = nexthdr -> hb_last_reclaimed;\n-\t      }\n-\t    } else {\n-\t      /* Unmap any gap in the middle */\n-\t\tGC_unmap_gap((ptr_t)h, size, (ptr_t)next, nexthdr -> hb_sz);\n-\t    }\n-\t    /* If they are both unmapped, we merge, but leave unmapped. */\n-\t    GC_remove_from_fl(hhdr, i);\n-\t    GC_remove_from_fl(nexthdr, FL_UNKNOWN);\n-\t    hhdr -> hb_sz += nexthdr -> hb_sz; \n-\t    GC_remove_header(next);\n-\t    GC_add_to_fl(h, hhdr); \n-\t    /* Start over at beginning of list */\n-\t    h = GC_hblkfreelist[i];\n-\t  } else /* not mergable with successor */ {\n-\t    h = hhdr -> hb_next;\n-\t  }\n-      } /* while (h != 0) ... */\n-    } /* for ... */\n-}\n-\n-#endif /* USE_MUNMAP */\n-\n-/*\n- * Return a pointer to a block starting at h of length bytes.\n- * Memory for the block is mapped.\n- * Remove the block from its free list, and return the remainder (if any)\n- * to its appropriate free list.\n- * May fail by returning 0.\n- * The header for the returned block must be set up by the caller.\n- * If the return value is not 0, then hhdr is the header for it.\n- */\n-struct hblk * GC_get_first_part(h, hhdr, bytes, index)\n-struct hblk *h;\n-hdr * hhdr;\n-word bytes;\n-int index;\n-{\n-    word total_size = hhdr -> hb_sz;\n-    struct hblk * rest;\n-    hdr * rest_hdr;\n-\n-    GC_ASSERT((total_size & (HBLKSIZE-1)) == 0);\n-    GC_remove_from_fl(hhdr, index);\n-    if (total_size == bytes) return h;\n-    rest = (struct hblk *)((word)h + bytes);\n-    rest_hdr = GC_install_header(rest);\n-    if (0 == rest_hdr) {\n-\t/* This may be very bad news ... */\n-\tWARN(\"Header allocation failed: Dropping block.\\n\", 0);\n-\treturn(0);\n-    }\n-    rest_hdr -> hb_sz = total_size - bytes;\n-    rest_hdr -> hb_flags = 0;\n-#   ifdef GC_ASSERTIONS\n-      /* Mark h not free, to avoid assertion about adjacent free blocks. */\n-        hhdr -> hb_map = 0;\n-#   endif\n-    GC_add_to_fl(rest, rest_hdr);\n-    return h;\n-}\n-\n-/*\n- * H is a free block.  N points at an address inside it.\n- * A new header for n has already been set up.  Fix up h's header\n- * to reflect the fact that it is being split, move it to the\n- * appropriate free list.\n- * N replaces h in the original free list.\n- *\n- * Nhdr is not completely filled in, since it is about to allocated.\n- * It may in fact end up on the wrong free list for its size.\n- * (Hence adding it to a free list is silly.  But this path is hopefully\n- * rare enough that it doesn't matter.  The code is cleaner this way.)\n- */\n-void GC_split_block(h, hhdr, n, nhdr, index)\n-struct hblk *h;\n-hdr * hhdr;\n-struct hblk *n;\n-hdr * nhdr;\n-int index;\t/* Index of free list */\n-{\n-    word total_size = hhdr -> hb_sz;\n-    word h_size = (word)n - (word)h;\n-    struct hblk *prev = hhdr -> hb_prev;\n-    struct hblk *next = hhdr -> hb_next;\n-\n-    /* Replace h with n on its freelist */\n-      nhdr -> hb_prev = prev;\n-      nhdr -> hb_next = next;\n-      nhdr -> hb_sz = total_size - h_size;\n-      nhdr -> hb_flags = 0;\n-      if (0 != prev) {\n-\tHDR(prev) -> hb_next = n;\n-      } else {\n-        GC_hblkfreelist[index] = n;\n-      }\n-      if (0 != next) {\n-\tHDR(next) -> hb_prev = n;\n-      }\n-      INCR_FREE_BYTES(index, -(signed_word)h_size);\n-      FREE_ASSERT(GC_free_bytes[index] > 0);\n-#     ifdef GC_ASSERTIONS\n-\tnhdr -> hb_map = 0;\t/* Don't fail test for consecutive\t*/\n-\t\t\t\t/* free blocks in GC_add_to_fl.\t\t*/\n-#     endif\n-#   ifdef USE_MUNMAP\n-      hhdr -> hb_last_reclaimed = GC_gc_no;\n-#   endif\n-    hhdr -> hb_sz = h_size;\n-    GC_add_to_fl(h, hhdr);\n-    GC_invalidate_map(nhdr);\n-}\n-\t\n-struct hblk * GC_allochblk_nth();\n-\n-/*\n- * Allocate (and return pointer to) a heap block\n- *   for objects of size sz words, searching the nth free list.\n- *\n- * NOTE: We set obj_map field in header correctly.\n- *       Caller is responsible for building an object freelist in block.\n- *\n- * Unlike older versions of the collectors, the client is responsible\n- * for clearing the block, if necessary.\n- */\n-struct hblk *\n-GC_allochblk(sz, kind, flags)\n-word sz;\n-int kind;\n-unsigned flags;  /* IGNORE_OFF_PAGE or 0 */\n-{\n-    word blocks = OBJ_SZ_TO_BLOCKS(sz);\n-    int start_list = GC_hblk_fl_from_blocks(blocks);\n-    int i;\n-    for (i = start_list; i <= N_HBLK_FLS; ++i) {\n-\tstruct hblk * result = GC_allochblk_nth(sz, kind, flags, i);\n-\tif (0 != result) {\n-\t    return result;\n-\t}\n-    }\n-    return 0;\n-}\n-/*\n- * The same, but with search restricted to nth free list.\n- */\n-struct hblk *\n-GC_allochblk_nth(sz, kind, flags, n)\n-word sz;\n-int kind;\n-unsigned char flags;  /* IGNORE_OFF_PAGE or 0 */\n-int n;\n-{\n-    register struct hblk *hbp;\n-    register hdr * hhdr;\t\t/* Header corr. to hbp */\n-    register struct hblk *thishbp;\n-    register hdr * thishdr;\t\t/* Header corr. to hbp */\n-    signed_word size_needed;    /* number of bytes in requested objects */\n-    signed_word size_avail;\t/* bytes available in this block\t*/\n-\n-    size_needed = HBLKSIZE * OBJ_SZ_TO_BLOCKS(sz);\n-\n-    /* search for a big enough block in free list */\n-\thbp = GC_hblkfreelist[n];\n-\tfor(; 0 != hbp; hbp = hhdr -> hb_next) {\n-\t    GET_HDR(hbp, hhdr);\n-\t    size_avail = hhdr->hb_sz;\n-\t    if (size_avail < size_needed) continue;\n-\t    if (size_avail != size_needed\n-\t\t&& !GC_use_entire_heap\n-\t\t&& !GC_dont_gc\n-\t\t&& USED_HEAP_SIZE >= GC_requested_heapsize\n-\t\t&& !TRUE_INCREMENTAL && GC_should_collect()) {\n-#\t\tifdef USE_MUNMAP\n-\t\t    continue;\n-#\t\telse\n-\t\t    /* If we have enough large blocks left to cover any\t*/\n-\t\t    /* previous request for large blocks, we go ahead\t*/\n-\t\t    /* and split.  Assuming a steady state, that should\t*/\n-\t\t    /* be safe.  It means that we can use the full \t*/\n-\t\t    /* heap if we allocate only small objects.\t\t*/\n-\t\t    if (!GC_enough_large_bytes_left(GC_large_allocd_bytes, n)) {\n-\t\t      continue;\n-\t\t    } \n-\t\t    /* If we are deallocating lots of memory from\t*/\n-\t\t    /* finalizers, fail and collect sooner rather\t*/\n-\t\t    /* than later.\t\t\t\t\t*/\n-\t\t    if (WORDS_TO_BYTES(GC_finalizer_mem_freed)\n-\t\t\t> (GC_heapsize >> 4))  {\n-\t\t      continue;\n-\t\t    }\n-#\t\tendif /* !USE_MUNMAP */\n-\t    }\n-\t    /* If the next heap block is obviously better, go on.\t*/\n-\t    /* This prevents us from disassembling a single large block */\n-\t    /* to get tiny blocks.\t\t\t\t\t*/\n-\t    {\n-\t      signed_word next_size;\n-\t      \n-\t      thishbp = hhdr -> hb_next;\n-\t      if (thishbp != 0) {\n-\t\tGET_HDR(thishbp, thishdr);\n-\t        next_size = (signed_word)(thishdr -> hb_sz);\n-\t        if (next_size < size_avail\n-\t          && next_size >= size_needed\n-\t          && !GC_is_black_listed(thishbp, (word)size_needed)) {\n-\t          continue;\n-\t        }\n-\t      }\n-\t    }\n-\t    if ( !IS_UNCOLLECTABLE(kind) &&\n-\t         (kind != PTRFREE || size_needed > MAX_BLACK_LIST_ALLOC)) {\n-\t      struct hblk * lasthbp = hbp;\n-\t      ptr_t search_end = (ptr_t)hbp + size_avail - size_needed;\n-\t      signed_word orig_avail = size_avail;\n-\t      signed_word eff_size_needed = ((flags & IGNORE_OFF_PAGE)?\n-\t      \t\t\t\t\tHBLKSIZE\n-\t      \t\t\t\t\t: size_needed);\n-\t      \n-\t      \n-\t      while ((ptr_t)lasthbp <= search_end\n-\t             && (thishbp = GC_is_black_listed(lasthbp,\n-\t             \t\t\t\t      (word)eff_size_needed))\n-\t\t        != 0) {\n-\t        lasthbp = thishbp;\n-\t      }\n-\t      size_avail -= (ptr_t)lasthbp - (ptr_t)hbp;\n-\t      thishbp = lasthbp;\n-\t      if (size_avail >= size_needed) {\n-\t        if (thishbp != hbp &&\n-\t\t    0 != (thishdr = GC_install_header(thishbp))) {\n-\t\t  /* Make sure it's mapped before we mangle it. */\n-#\t\t    ifdef USE_MUNMAP\n-\t\t      if (!IS_MAPPED(hhdr)) {\n-\t\t        GC_remap((ptr_t)hbp, hhdr -> hb_sz);\n-\t\t        hhdr -> hb_flags &= ~WAS_UNMAPPED;\n-\t\t      }\n-#\t\t    endif\n-\t          /* Split the block at thishbp */\n-\t\t      GC_split_block(hbp, hhdr, thishbp, thishdr, n);\n-\t\t  /* Advance to thishbp */\n-\t\t      hbp = thishbp;\n-\t\t      hhdr = thishdr;\n-\t\t      /* We must now allocate thishbp, since it may\t*/\n-\t\t      /* be on the wrong free list.\t\t\t*/\n-\t\t}\n-\t      } else if (size_needed > (signed_word)BL_LIMIT\n-\t                 && orig_avail - size_needed\n-\t\t\t    > (signed_word)BL_LIMIT) {\n-\t        /* Punt, since anything else risks unreasonable heap growth. */\n-\t\tif (++GC_large_alloc_warn_suppressed\n-\t\t    >= GC_large_alloc_warn_interval) {\n-\t          WARN(\"Repeated allocation of very large block \"\n-\t\t       \"(appr. size %ld):\\n\"\n-\t\t       \"\\tMay lead to memory leak and poor performance.\\n\",\n-\t\t       size_needed);\n-\t\t  GC_large_alloc_warn_suppressed = 0;\n-\t\t}\n-\t        size_avail = orig_avail;\n-\t      } else if (size_avail == 0 && size_needed == HBLKSIZE\n-\t\t\t && IS_MAPPED(hhdr)) {\n-\t\tif (!GC_find_leak) {\n-\t      \t  static unsigned count = 0;\n-\t      \t  \n-\t      \t  /* The block is completely blacklisted.  We need \t*/\n-\t      \t  /* to drop some such blocks, since otherwise we spend */\n-\t      \t  /* all our time traversing them if pointerfree\t*/\n-\t      \t  /* blocks are unpopular.\t\t\t\t*/\n-\t          /* A dropped block will be reconsidered at next GC.\t*/\n-\t          if ((++count & 3) == 0) {\n-\t            /* Allocate and drop the block in small chunks, to\t*/\n-\t            /* maximize the chance that we will recover some\t*/\n-\t            /* later.\t\t\t\t\t\t*/\n-\t\t      word total_size = hhdr -> hb_sz;\n-\t              struct hblk * limit = hbp + divHBLKSZ(total_size);\n-\t              struct hblk * h;\n-\t\t      struct hblk * prev = hhdr -> hb_prev;\n-\t              \n-\t\t      GC_words_wasted += BYTES_TO_WORDS(total_size);\n-\t\t      GC_large_free_bytes -= total_size;\n-\t\t      GC_remove_from_fl(hhdr, n);\n-\t              for (h = hbp; h < limit; h++) {\n-\t                if (h == hbp || 0 != (hhdr = GC_install_header(h))) {\n-\t                  (void) setup_header(\n-\t                \t  hhdr,\n-\t              \t\t  BYTES_TO_WORDS(HBLKSIZE),\n-\t              \t\t  PTRFREE, 0); /* Cant fail */\n-\t              \t  if (GC_debugging_started) {\n-\t              \t    BZERO(h, HBLKSIZE);\n-\t              \t  }\n-\t                }\n-\t              }\n-\t            /* Restore hbp to point at free block */\n-\t\t      hbp = prev;\n-\t\t      if (0 == hbp) {\n-\t\t\treturn GC_allochblk_nth(sz, kind, flags, n);\n-\t\t      }\n-\t   \t      hhdr = HDR(hbp);\n-\t          }\n-\t\t}\n-\t      }\n-\t    }\n-\t    if( size_avail >= size_needed ) {\n-#\t\tifdef USE_MUNMAP\n-\t\t  if (!IS_MAPPED(hhdr)) {\n-\t\t    GC_remap((ptr_t)hbp, hhdr -> hb_sz);\n-\t\t    hhdr -> hb_flags &= ~WAS_UNMAPPED;\n-\t\t  }\n-#\t        endif\n-\t\t/* hbp may be on the wrong freelist; the parameter n\t*/\n-\t\t/* is important.\t\t\t\t\t*/\n-\t\thbp = GC_get_first_part(hbp, hhdr, size_needed, n);\n-\t\tbreak;\n-\t    }\n-\t}\n-\n-    if (0 == hbp) return 0;\n-\t\n-    /* Add it to map of valid blocks */\n-    \tif (!GC_install_counts(hbp, (word)size_needed)) return(0);\n-    \t/* This leaks memory under very rare conditions. */\n-    \t\t\n-    /* Set up header */\n-        if (!setup_header(hhdr, sz, kind, flags)) {\n-            GC_remove_counts(hbp, (word)size_needed);\n-            return(0); /* ditto */\n-        }\n-\n-    /* Notify virtual dirty bit implementation that we are about to write.  */\n-    /* Ensure that pointerfree objects are not protected if it's avoidable. */\n-    \tGC_remove_protection(hbp, divHBLKSZ(size_needed),\n-\t\t\t     (hhdr -> hb_descr == 0) /* pointer-free */);\n-        \n-    /* We just successfully allocated a block.  Restart count of\t*/\n-    /* consecutive failures.\t\t\t\t\t\t*/\n-    {\n-\textern unsigned GC_fail_count;\n-\t\n-\tGC_fail_count = 0;\n-    }\n-\n-    GC_large_free_bytes -= size_needed;\n-    \n-    GC_ASSERT(IS_MAPPED(hhdr));\n-    return( hbp );\n-}\n- \n-struct hblk * GC_freehblk_ptr = 0;  /* Search position hint for GC_freehblk */\n-\n-/*\n- * Free a heap block.\n- *\n- * Coalesce the block with its neighbors if possible.\n- *\n- * All mark words are assumed to be cleared.\n- */\n-void\n-GC_freehblk(hbp)\n-struct hblk *hbp;\n-{\n-struct hblk *next, *prev;\n-hdr *hhdr, *prevhdr, *nexthdr;\n-signed_word size;\n-\n-\n-    GET_HDR(hbp, hhdr);\n-    size = hhdr->hb_sz;\n-    size = HBLKSIZE * OBJ_SZ_TO_BLOCKS(size);\n-    GC_remove_counts(hbp, (word)size);\n-    hhdr->hb_sz = size;\n-#   ifdef USE_MUNMAP\n-      hhdr -> hb_last_reclaimed = GC_gc_no;\n-#   endif\n-    \n-    /* Check for duplicate deallocation in the easy case */\n-      if (HBLK_IS_FREE(hhdr)) {\n-        GC_printf1(\"Duplicate large block deallocation of 0x%lx\\n\",\n-        \t   (unsigned long) hbp);\n-\tABORT(\"Duplicate large block deallocation\");\n-      }\n-\n-    GC_ASSERT(IS_MAPPED(hhdr));\n-    GC_invalidate_map(hhdr);\n-    next = (struct hblk *)((word)hbp + size);\n-    GET_HDR(next, nexthdr);\n-    prev = GC_free_block_ending_at(hbp);\n-    /* Coalesce with successor, if possible */\n-      if(0 != nexthdr && HBLK_IS_FREE(nexthdr) && IS_MAPPED(nexthdr)) {\n-\tGC_remove_from_fl(nexthdr, FL_UNKNOWN);\n-\thhdr -> hb_sz += nexthdr -> hb_sz; \n-\tGC_remove_header(next);\n-      }\n-    /* Coalesce with predecessor, if possible. */\n-      if (0 != prev) {\n-\tprevhdr = HDR(prev);\n-\tif (IS_MAPPED(prevhdr)) {\n-\t  GC_remove_from_fl(prevhdr, FL_UNKNOWN);\n-\t  prevhdr -> hb_sz += hhdr -> hb_sz;\n-#\t  ifdef USE_MUNMAP\n-\t    prevhdr -> hb_last_reclaimed = GC_gc_no;\n-#\t  endif\n-\t  GC_remove_header(hbp);\n-\t  hbp = prev;\n-\t  hhdr = prevhdr;\n-\t}\n-      }\n-    /* FIXME: It is not clear we really always want to do these merges\t*/\n-    /* with -DUSE_MUNMAP, since it updates ages and hence prevents\t*/\n-    /* unmapping. \t\t\t\t\t\t\t*/\n-\n-    GC_large_free_bytes += size;\n-    GC_add_to_fl(hbp, hhdr);    \n-}\n-"}, {"sha": "9b4869f91b28066cbe3dc933adf7f9e97941c6ab", "filename": "boehm-gc/alloc.c", "status": "removed", "additions": 0, "deletions": 1099, "changes": 1099, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Falloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Falloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Falloc.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,1099 +0,0 @@\n-/*\n- * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n- * Copyright (c) 1991-1996 by Xerox Corporation.  All rights reserved.\n- * Copyright (c) 1998 by Silicon Graphics.  All rights reserved.\n- * Copyright (c) 1999 by Hewlett-Packard Company. All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- *\n- */\n-\n-\n-# include \"private/gc_priv.h\"\n-\n-# include <stdio.h>\n-# if !defined(MACOS) && !defined(MSWINCE)\n-#   include <signal.h>\n-#   include <sys/types.h>\n-# endif\n-\n-/*\n- * Separate free lists are maintained for different sized objects\n- * up to MAXOBJSZ.\n- * The call GC_allocobj(i,k) ensures that the freelist for\n- * kind k objects of size i points to a non-empty\n- * free list. It returns a pointer to the first entry on the free list.\n- * In a single-threaded world, GC_allocobj may be called to allocate\n- * an object of (small) size i as follows:\n- *\n- *            opp = &(GC_objfreelist[i]);\n- *            if (*opp == 0) GC_allocobj(i, NORMAL);\n- *            ptr = *opp;\n- *            *opp = obj_link(ptr);\n- *\n- * Note that this is very fast if the free list is non-empty; it should\n- * only involve the execution of 4 or 5 simple instructions.\n- * All composite objects on freelists are cleared, except for\n- * their first word.\n- */\n-\n-/*\n- *  The allocator uses GC_allochblk to allocate large chunks of objects.\n- * These chunks all start on addresses which are multiples of\n- * HBLKSZ.   Each allocated chunk has an associated header,\n- * which can be located quickly based on the address of the chunk.\n- * (See headers.c for details.) \n- * This makes it possible to check quickly whether an\n- * arbitrary address corresponds to an object administered by the\n- * allocator.\n- */\n-\n-word GC_non_gc_bytes = 0;  /* Number of bytes not intended to be collected */\n-\n-word GC_gc_no = 0;\n-\n-#ifndef SMALL_CONFIG\n-  int GC_incremental = 0;  /* By default, stop the world.\t*/\n-#endif\n-\n-int GC_parallel = FALSE;   /* By default, parallel GC is off.\t*/\n-\n-int GC_full_freq = 19;\t   /* Every 20th collection is a full\t*/\n-\t\t\t   /* collection, whether we need it \t*/\n-\t\t\t   /* or not.\t\t\t        */\n-\n-GC_bool GC_need_full_gc = FALSE;\n-\t\t\t   /* Need full GC do to heap growth.\t*/\n-\n-#ifdef THREADS\n-  GC_bool GC_world_stopped = FALSE;\n-# define IF_THREADS(x) x\n-#else\n-# define IF_THREADS(x)\n-#endif\n-\n-word GC_used_heap_size_after_full = 0;\n-\n-char * GC_copyright[] =\n-{\"Copyright 1988,1989 Hans-J. Boehm and Alan J. Demers \",\n-\"Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved. \",\n-\"Copyright (c) 1996-1998 by Silicon Graphics.  All rights reserved. \",\n-\"Copyright (c) 1999-2001 by Hewlett-Packard Company.  All rights reserved. \",\n-\"THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY\",\n-\" EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\",\n-\"See source code for details.\" };\n-\n-# include \"version.h\"\n-\n-#if defined(SAVE_CALL_CHAIN) && \\\n-\t!(defined(REDIRECT_MALLOC) && defined(GC_HAVE_BUILTIN_BACKTRACE))\n-#   define SAVE_CALL_CHAIN_IN_GC\n-    /* This is only safe if the call chain save mechanism won't end up\t*/\n-    /* calling GC_malloc.  The GNU C library documentation suggests \t*/\n-    /* that backtrace doesn't use malloc, but at least the initial\t*/\n-    /* call in some versions does seem to invoke the dynamic linker,\t*/\n-    /* which uses malloc.\t\t\t\t\t\t*/\n-#endif\n-\n-/* some more variables */\n-\n-extern signed_word GC_mem_found;  /* Number of reclaimed longwords\t*/\n-\t\t\t\t  /* after garbage collection      \t*/\n-\n-GC_bool GC_dont_expand = 0;\n-\n-word GC_free_space_divisor = 3;\n-\n-extern GC_bool GC_collection_in_progress();\n-\t\t/* Collection is in progress, or was abandoned.\t*/\n-\n-int GC_never_stop_func GC_PROTO((void)) { return(0); }\n-\n-unsigned long GC_time_limit = TIME_LIMIT;\n-\n-CLOCK_TYPE GC_start_time;  \t/* Time at which we stopped world.\t*/\n-\t\t\t\t/* used only in GC_timeout_stop_func.\t*/\n-\n-int GC_n_attempts = 0;\t\t/* Number of attempts at finishing\t*/\n-\t\t\t\t/* collection within GC_time_limit.\t*/\n-\n-#if defined(SMALL_CONFIG) || defined(NO_CLOCK)\n-#   define GC_timeout_stop_func GC_never_stop_func\n-#else\n-  int GC_timeout_stop_func GC_PROTO((void))\n-  {\n-    CLOCK_TYPE current_time;\n-    static unsigned count = 0;\n-    unsigned long time_diff;\n-    \n-    if ((count++ & 3) != 0) return(0);\n-    GET_TIME(current_time);\n-    time_diff = MS_TIME_DIFF(current_time,GC_start_time);\n-    if (time_diff >= GC_time_limit) {\n-#   \tifdef CONDPRINT\n-\t  if (GC_print_stats) {\n-\t    GC_printf0(\"Abandoning stopped marking after \");\n-\t    GC_printf1(\"%lu msecs\", (unsigned long)time_diff);\n-\t    GC_printf1(\"(attempt %ld)\\n\", (unsigned long) GC_n_attempts);\n-\t  }\n-#\tendif\n-    \treturn(1);\n-    }\n-    return(0);\n-  }\n-#endif /* !SMALL_CONFIG */\n-\n-/* Return the minimum number of words that must be allocated between\t*/\n-/* collections to amortize the collection cost.\t\t\t\t*/\n-static word min_words_allocd()\n-{\n-#   ifdef THREADS\n- \t/* We punt, for now. */\n- \tregister signed_word stack_size = 10000;\n-#   else\n-        int dummy;\n-        register signed_word stack_size = (ptr_t)(&dummy) - GC_stackbottom;\n-#   endif\n-    word total_root_size;  \t    /* includes double stack size,\t*/\n-    \t\t\t\t    /* since the stack is expensive\t*/\n-    \t\t\t\t    /* to scan.\t\t\t\t*/\n-    word scan_size;\t\t/* Estimate of memory to be scanned \t*/\n-\t\t\t\t/* during normal GC.\t\t\t*/\n-    \n-    if (stack_size < 0) stack_size = -stack_size;\n-    total_root_size = 2 * stack_size + GC_root_size;\n-    scan_size = BYTES_TO_WORDS(GC_heapsize - GC_large_free_bytes\n-\t\t\t       + (GC_large_free_bytes >> 2)\n-\t\t\t\t   /* use a bit more of large empty heap */\n-\t\t\t       + total_root_size);\n-    if (TRUE_INCREMENTAL) {\n-        return scan_size / (2 * GC_free_space_divisor);\n-    } else {\n-        return scan_size / GC_free_space_divisor;\n-    }\n-}\n-\n-/* Return the number of words allocated, adjusted for explicit storage\t*/\n-/* management, etc..  This number is used in deciding when to trigger\t*/\n-/* collections.\t\t\t\t\t\t\t\t*/\n-word GC_adj_words_allocd()\n-{\n-    register signed_word result;\n-    register signed_word expl_managed =\n-    \t\tBYTES_TO_WORDS((long)GC_non_gc_bytes\n-    \t\t\t\t- (long)GC_non_gc_bytes_at_gc);\n-    \n-    /* Don't count what was explicitly freed, or newly allocated for\t*/\n-    /* explicit management.  Note that deallocating an explicitly\t*/\n-    /* managed object should not alter result, assuming the client\t*/\n-    /* is playing by the rules.\t\t\t\t\t\t*/\n-    result = (signed_word)GC_words_allocd\n-    \t     - (signed_word)GC_mem_freed \n-\t     + (signed_word)GC_finalizer_mem_freed - expl_managed;\n-    if (result > (signed_word)GC_words_allocd) {\n-        result = GC_words_allocd;\n-    \t/* probably client bug or unfortunate scheduling */\n-    }\n-    result += GC_words_finalized;\n-    \t/* We count objects enqueued for finalization as though they\t*/\n-    \t/* had been reallocated this round. Finalization is user\t*/\n-    \t/* visible progress.  And if we don't count this, we have\t*/\n-    \t/* stability problems for programs that finalize all objects.\t*/\n-    if ((GC_words_wasted >> 3) < result)\n-        result += GC_words_wasted;\n-     \t/* This doesn't reflect useful work.  But if there is lots of\t*/\n-     \t/* new fragmentation, the same is probably true of the heap,\t*/\n-     \t/* and the collection will be correspondingly cheaper.\t\t*/\n-    if (result < (signed_word)(GC_words_allocd >> 3)) {\n-    \t/* Always count at least 1/8 of the allocations.  We don't want\t*/\n-    \t/* to collect too infrequently, since that would inhibit\t*/\n-    \t/* coalescing of free storage blocks.\t\t\t\t*/\n-    \t/* This also makes us partially robust against client bugs.\t*/\n-        return(GC_words_allocd >> 3);\n-    } else {\n-        return(result);\n-    }\n-}\n-\n-\n-/* Clear up a few frames worth of garbage left at the top of the stack.\t*/\n-/* This is used to prevent us from accidentally treating garbade left\t*/\n-/* on the stack by other parts of the collector as roots.  This \t*/\n-/* differs from the code in misc.c, which actually tries to keep the\t*/\n-/* stack clear of long-lived, client-generated garbage.\t\t\t*/\n-void GC_clear_a_few_frames()\n-{\n-#   define NWORDS 64\n-    word frames[NWORDS];\n-    /* Some compilers will warn that frames was set but never used.\t*/\n-    /* That's the whole idea ...\t\t\t\t\t*/\n-    register int i;\n-    \n-    for (i = 0; i < NWORDS; i++) frames[i] = 0;\n-}\n-\n-/* Heap size at which we need a collection to avoid expanding past\t*/\n-/* limits used by blacklisting.\t\t\t\t\t\t*/\n-static word GC_collect_at_heapsize = (word)(-1);\n-\n-/* Have we allocated enough to amortize a collection? */\n-GC_bool GC_should_collect()\n-{\n-    return(GC_adj_words_allocd() >= min_words_allocd()\n-\t   || GC_heapsize >= GC_collect_at_heapsize);\n-}\n-\n-\n-void GC_notify_full_gc()\n-{\n-    if (GC_start_call_back != (void (*) GC_PROTO((void)))0) {\n-\t(*GC_start_call_back)();\n-    }\n-}\n-\n-GC_bool GC_is_full_gc = FALSE;\n-\n-/* \n- * Initiate a garbage collection if appropriate.\n- * Choose judiciously\n- * between partial, full, and stop-world collections.\n- * Assumes lock held, signals disabled.\n- */\n-void GC_maybe_gc()\n-{\n-    static int n_partial_gcs = 0;\n-\n-    if (GC_should_collect()) {\n-        if (!GC_incremental) {\n-            GC_gcollect_inner();\n-            n_partial_gcs = 0;\n-            return;\n-        } else {\n-#   \t  ifdef PARALLEL_MARK\n-\t    GC_wait_for_reclaim();\n-#   \t  endif\n-\t  if (GC_need_full_gc || n_partial_gcs >= GC_full_freq) {\n-#   \t    ifdef CONDPRINT\n-\t      if (GC_print_stats) {\n-\t        GC_printf2(\n-\t          \"***>Full mark for collection %lu after %ld allocd bytes\\n\",\n-     \t\t  (unsigned long) GC_gc_no+1,\n-\t   \t  (long)WORDS_TO_BYTES(GC_words_allocd));\n-\t      }\n-#           endif\n-\t    GC_promote_black_lists();\n-\t    (void)GC_reclaim_all((GC_stop_func)0, TRUE);\n-\t    GC_clear_marks();\n-            n_partial_gcs = 0;\n-\t    GC_notify_full_gc();\n- \t    GC_is_full_gc = TRUE;\n-          } else {\n-            n_partial_gcs++;\n-          }\n-\t}\n-        /* We try to mark with the world stopped.\t*/\n-        /* If we run out of time, this turns into\t*/\n-        /* incremental marking.\t\t\t*/\n-#\tifndef NO_CLOCK\n-          if (GC_time_limit != GC_TIME_UNLIMITED) { GET_TIME(GC_start_time); }\n-#\tendif\n-        if (GC_stopped_mark(GC_time_limit == GC_TIME_UNLIMITED? \n-\t\t\t    GC_never_stop_func : GC_timeout_stop_func)) {\n-#           ifdef SAVE_CALL_CHAIN_IN_GC\n-                GC_save_callers(GC_last_stack);\n-#           endif\n-            GC_finish_collection();\n-        } else {\n-\t    if (!GC_is_full_gc) {\n-\t\t/* Count this as the first attempt */\n-\t        GC_n_attempts++;\n-\t    }\n-\t}\n-    }\n-}\n-\n-\n-/*\n- * Stop the world garbage collection.  Assumes lock held, signals disabled.\n- * If stop_func is not GC_never_stop_func, then abort if stop_func returns TRUE.\n- * Return TRUE if we successfully completed the collection.\n- */\n-GC_bool GC_try_to_collect_inner(stop_func)\n-GC_stop_func stop_func;\n-{\n-#   ifdef CONDPRINT\n-        CLOCK_TYPE start_time, current_time;\n-#   endif\n-    if (GC_dont_gc) return FALSE;\n-    if (GC_incremental && GC_collection_in_progress()) {\n-#   ifdef CONDPRINT\n-      if (GC_print_stats) {\n-\tGC_printf0(\n-\t    \"GC_try_to_collect_inner: finishing collection in progress\\n\");\n-      }\n-#   endif /* CONDPRINT */\n-      /* Just finish collection already in progress.\t*/\n-    \twhile(GC_collection_in_progress()) {\n-    \t    if (stop_func()) return(FALSE);\n-    \t    GC_collect_a_little_inner(1);\n-    \t}\n-    }\n-    if (stop_func == GC_never_stop_func) GC_notify_full_gc();\n-#   ifdef CONDPRINT\n-      if (GC_print_stats) {\n-        if (GC_print_stats) GET_TIME(start_time);\n-\tGC_printf2(\n-\t   \"Initiating full world-stop collection %lu after %ld allocd bytes\\n\",\n-\t   (unsigned long) GC_gc_no+1,\n-\t   (long)WORDS_TO_BYTES(GC_words_allocd));\n-      }\n-#   endif\n-    GC_promote_black_lists();\n-    /* Make sure all blocks have been reclaimed, so sweep routines\t*/\n-    /* don't see cleared mark bits.\t\t\t\t\t*/\n-    /* If we're guaranteed to finish, then this is unnecessary.\t\t*/\n-    /* In the find_leak case, we have to finish to guarantee that \t*/\n-    /* previously unmarked objects are not reported as leaks.\t\t*/\n-#       ifdef PARALLEL_MARK\n-\t    GC_wait_for_reclaim();\n-#       endif\n- \tif ((GC_find_leak || stop_func != GC_never_stop_func)\n-\t    && !GC_reclaim_all(stop_func, FALSE)) {\n-\t    /* Aborted.  So far everything is still consistent.\t*/\n-\t    return(FALSE);\n-\t}\n-    GC_invalidate_mark_state();  /* Flush mark stack.\t*/\n-    GC_clear_marks();\n-#   ifdef SAVE_CALL_CHAIN_IN_GC\n-        GC_save_callers(GC_last_stack);\n-#   endif\n-    GC_is_full_gc = TRUE;\n-    if (!GC_stopped_mark(stop_func)) {\n-      if (!GC_incremental) {\n-    \t/* We're partially done and have no way to complete or use \t*/\n-    \t/* current work.  Reestablish invariants as cheaply as\t\t*/\n-    \t/* possible.\t\t\t\t\t\t\t*/\n-    \tGC_invalidate_mark_state();\n-\tGC_unpromote_black_lists();\n-      } /* else we claim the world is already still consistent.  We'll \t*/\n-        /* finish incrementally.\t\t\t\t\t*/\n-      return(FALSE);\n-    }\n-    GC_finish_collection();\n-#   if defined(CONDPRINT)\n-      if (GC_print_stats) {\n-        GET_TIME(current_time);\n-        GC_printf1(\"Complete collection took %lu msecs\\n\",\n-                   MS_TIME_DIFF(current_time,start_time));\n-      }\n-#   endif\n-    return(TRUE);\n-}\n-\n-\n-\n-/*\n- * Perform n units of garbage collection work.  A unit is intended to touch\n- * roughly GC_RATE pages.  Every once in a while, we do more than that.\n- * This needa to be a fairly large number with our current incremental\n- * GC strategy, since otherwise we allocate too much during GC, and the\n- * cleanup gets expensive.\n- */\n-# define GC_RATE 10 \n-# define MAX_PRIOR_ATTEMPTS 1\n- \t/* Maximum number of prior attempts at world stop marking\t*/\n- \t/* A value of 1 means that we finish the second time, no matter */\n- \t/* how long it takes.  Doesn't count the initial root scan\t*/\n- \t/* for a full GC.\t\t\t\t\t\t*/\n-\n-int GC_deficit = 0;\t/* The number of extra calls to GC_mark_some\t*/\n-\t\t\t/* that we have made.\t\t\t\t*/\n-\n-void GC_collect_a_little_inner(n)\n-int n;\n-{\n-    register int i;\n-    \n-    if (GC_dont_gc) return;\n-    if (GC_incremental && GC_collection_in_progress()) {\n-    \tfor (i = GC_deficit; i < GC_RATE*n; i++) {\n-    \t    if (GC_mark_some((ptr_t)0)) {\n-    \t        /* Need to finish a collection */\n-#     \t\tifdef SAVE_CALL_CHAIN_IN_GC\n-        \t    GC_save_callers(GC_last_stack);\n-#     \t\tendif\n-#\t\tifdef PARALLEL_MARK\n-\t\t    GC_wait_for_reclaim();\n-#\t\tendif\n-\t\tif (GC_n_attempts < MAX_PRIOR_ATTEMPTS\n-\t\t    && GC_time_limit != GC_TIME_UNLIMITED) {\n-\t\t  GET_TIME(GC_start_time);\n-\t\t  if (!GC_stopped_mark(GC_timeout_stop_func)) {\n-\t\t    GC_n_attempts++;\n-\t\t    break;\n-\t\t  }\n-\t\t} else {\n-\t\t  (void)GC_stopped_mark(GC_never_stop_func);\n-\t\t}\n-    \t        GC_finish_collection();\n-    \t        break;\n-    \t    }\n-    \t}\n-    \tif (GC_deficit > 0) GC_deficit -= GC_RATE*n;\n-\tif (GC_deficit < 0) GC_deficit = 0;\n-    } else {\n-        GC_maybe_gc();\n-    }\n-}\n-\n-int GC_collect_a_little GC_PROTO(())\n-{\n-    int result;\n-    DCL_LOCK_STATE;\n-\n-    DISABLE_SIGNALS();\n-    LOCK();\n-    GC_collect_a_little_inner(1);\n-    result = (int)GC_collection_in_progress();\n-    UNLOCK();\n-    ENABLE_SIGNALS();\n-    if (!result && GC_debugging_started) GC_print_all_smashed();\n-    return(result);\n-}\n-\n-/*\n- * Assumes lock is held, signals are disabled.\n- * We stop the world.\n- * If stop_func() ever returns TRUE, we may fail and return FALSE.\n- * Increment GC_gc_no if we succeed.\n- */\n-GC_bool GC_stopped_mark(stop_func)\n-GC_stop_func stop_func;\n-{\n-    register int i;\n-    int dummy;\n-#   if defined(PRINTTIMES) || defined(CONDPRINT)\n-\tCLOCK_TYPE start_time, current_time;\n-#   endif\n-\t\n-#   ifdef PRINTTIMES\n-\tGET_TIME(start_time);\n-#   endif\n-#   if defined(CONDPRINT) && !defined(PRINTTIMES)\n-\tif (GC_print_stats) GET_TIME(start_time);\n-#   endif\n-#   if defined(REGISTER_LIBRARIES_EARLY)\n-        GC_cond_register_dynamic_libraries();\n-#   endif\n-    STOP_WORLD();\n-    IF_THREADS(GC_world_stopped = TRUE);\n-#   ifdef CONDPRINT\n-      if (GC_print_stats) {\n-\tGC_printf1(\"--> Marking for collection %lu \",\n-\t           (unsigned long) GC_gc_no + 1);\n-\tGC_printf2(\"after %lu allocd bytes + %lu wasted bytes\\n\",\n-\t   \t   (unsigned long) WORDS_TO_BYTES(GC_words_allocd),\n-\t   \t   (unsigned long) WORDS_TO_BYTES(GC_words_wasted));\n-      }\n-#   endif\n-#   ifdef MAKE_BACK_GRAPH\n-      if (GC_print_back_height) {\n-        GC_build_back_graph();\n-      }\n-#   endif\n-\n-    /* Mark from all roots.  */\n-        /* Minimize junk left in my registers and on the stack */\n-            GC_clear_a_few_frames();\n-            GC_noop(0,0,0,0,0,0);\n-\tGC_initiate_gc();\n-\tfor(i = 0;;i++) {\n-\t    if ((*stop_func)()) {\n-#   \t\t    ifdef CONDPRINT\n-\t\t      if (GC_print_stats) {\n-\t\t    \tGC_printf0(\"Abandoned stopped marking after \");\n-\t\t\tGC_printf1(\"%lu iterations\\n\",\n-\t\t\t\t   (unsigned long)i);\n-\t\t      }\n-#\t\t    endif\n-\t\t    GC_deficit = i; /* Give the mutator a chance. */\n-                    IF_THREADS(GC_world_stopped = FALSE);\n-\t            START_WORLD();\n-\t            return(FALSE);\n-\t    }\n-\t    if (GC_mark_some((ptr_t)(&dummy))) break;\n-\t}\n-\t\n-    GC_gc_no++;\n-#   ifdef PRINTSTATS\n-      GC_printf2(\"Collection %lu reclaimed %ld bytes\",\n-\t\t  (unsigned long) GC_gc_no - 1,\n-\t   \t  (long)WORDS_TO_BYTES(GC_mem_found));\n-#   else\n-#     ifdef CONDPRINT\n-        if (GC_print_stats) {\n-\t  GC_printf1(\"Collection %lu finished\", (unsigned long) GC_gc_no - 1);\n-\t}\n-#     endif\n-#   endif /* !PRINTSTATS */\n-#   ifdef CONDPRINT\n-      if (GC_print_stats) {\n-        GC_printf1(\" ---> heapsize = %lu bytes\\n\",\n-      \t           (unsigned long) GC_heapsize);\n-        /* Printf arguments may be pushed in funny places.  Clear the\t*/\n-        /* space.\t\t\t\t\t\t\t*/\n-        GC_printf0(\"\");\n-      }\n-#   endif  /* CONDPRINT  */\n-\n-    /* Check all debugged objects for consistency */\n-        if (GC_debugging_started) {\n-            (*GC_check_heap)();\n-        }\n-    \n-    IF_THREADS(GC_world_stopped = FALSE);\n-    START_WORLD();\n-#   ifdef PRINTTIMES\n-\tGET_TIME(current_time);\n-\tGC_printf1(\"World-stopped marking took %lu msecs\\n\",\n-\t           MS_TIME_DIFF(current_time,start_time));\n-#   else\n-#     ifdef CONDPRINT\n-\tif (GC_print_stats) {\n-\t  GET_TIME(current_time);\n-\t  GC_printf1(\"World-stopped marking took %lu msecs\\n\",\n-\t             MS_TIME_DIFF(current_time,start_time));\n-\t}\n-#     endif\n-#   endif\n-    return(TRUE);\n-}\n-\n-/* Set all mark bits for the free list whose first entry is q\t*/\n-#ifdef __STDC__\n-  void GC_set_fl_marks(ptr_t q)\n-#else\n-  void GC_set_fl_marks(q)\n-  ptr_t q;\n-#endif\n-{\n-   ptr_t p;\n-   struct hblk * h, * last_h = 0;\n-   hdr *hhdr;\n-   int word_no;\n-\n-   for (p = q; p != 0; p = obj_link(p)){\n-\th = HBLKPTR(p);\n-\tif (h != last_h) {\n-\t  last_h = h; \n-\t  hhdr = HDR(h);\n-\t}\n-\tword_no = (((word *)p) - ((word *)h));\n-\tset_mark_bit_from_hdr(hhdr, word_no);\n-   }\n-}\n-\n-/* Clear all mark bits for the free list whose first entry is q\t*/\n-/* Decrement GC_mem_found by number of words on free list.\t*/\n-#ifdef __STDC__\n-  void GC_clear_fl_marks(ptr_t q)\n-#else\n-  void GC_clear_fl_marks(q)\n-  ptr_t q;\n-#endif\n-{\n-   ptr_t p;\n-   struct hblk * h, * last_h = 0;\n-   hdr *hhdr;\n-   int word_no;\n-\n-   for (p = q; p != 0; p = obj_link(p)){\n-\th = HBLKPTR(p);\n-\tif (h != last_h) {\n-\t  last_h = h; \n-\t  hhdr = HDR(h);\n-\t}\n-\tword_no = (((word *)p) - ((word *)h));\n-\tclear_mark_bit_from_hdr(hhdr, word_no);\n-#\tifdef GATHERSTATS\n-\t    GC_mem_found -= hhdr -> hb_sz;\n-#\tendif\n-   }\n-}\n-\n-/* Finish up a collection.  Assumes lock is held, signals are disabled,\t*/\n-/* but the world is otherwise running.\t\t\t\t\t*/\n-void GC_finish_collection()\n-{\n-#   ifdef PRINTTIMES\n-\tCLOCK_TYPE start_time;\n-\tCLOCK_TYPE finalize_time;\n-\tCLOCK_TYPE done_time;\n-\t\n-\tGET_TIME(start_time);\n-\tfinalize_time = start_time;\n-#   endif\n-\n-#   ifdef GATHERSTATS\n-        GC_mem_found = 0;\n-#   endif\n-#   if defined(LINUX) && defined(__ELF__) && !defined(SMALL_CONFIG)\n-\tif (getenv(\"GC_PRINT_ADDRESS_MAP\") != 0) {\n-\t  GC_print_address_map();\n-\t}\n-#   endif\n-    COND_DUMP;\n-    if (GC_find_leak) {\n-      /* Mark all objects on the free list.  All objects should be */\n-      /* marked when we're done.\t\t\t\t   */\n-\t{\n-\t  register word size;\t\t/* current object size\t\t*/\n-\t  int kind;\n-\t  ptr_t q;\n-\n-\t  for (kind = 0; kind < GC_n_kinds; kind++) {\n-\t    for (size = 1; size <= MAXOBJSZ; size++) {\n-\t      q = GC_obj_kinds[kind].ok_freelist[size];\n-\t      if (q != 0) GC_set_fl_marks(q);\n-\t    }\n-\t  }\n-\t}\n-\tGC_start_reclaim(TRUE);\n-\t  /* The above just checks; it doesn't really reclaim anything. */\n-    }\n-\n-    GC_finalize();\n-#   ifdef STUBBORN_ALLOC\n-      GC_clean_changing_list();\n-#   endif\n-\n-#   ifdef PRINTTIMES\n-      GET_TIME(finalize_time);\n-#   endif\n-\n-    if (GC_print_back_height) {\n-#     ifdef MAKE_BACK_GRAPH\n-\tGC_traverse_back_graph();\n-#     else\n-#\tifndef SMALL_CONFIG\n-\t  GC_err_printf0(\"Back height not available: \"\n-\t\t         \"Rebuild collector with -DMAKE_BACK_GRAPH\\n\");\n-#  \tendif\n-#     endif\n-    }\n-\n-    /* Clear free list mark bits, in case they got accidentally marked   */\n-    /* (or GC_find_leak is set and they were intentionally marked).\t */\n-    /* Also subtract memory remaining from GC_mem_found count.           */\n-    /* Note that composite objects on free list are cleared.             */\n-    /* Thus accidentally marking a free list is not a problem;  only     */\n-    /* objects on the list itself will be marked, and that's fixed here. */\n-      {\n-\tregister word size;\t\t/* current object size\t\t*/\n-\tregister ptr_t q;\t/* pointer to current object\t*/\n-\tint kind;\n-\n-\tfor (kind = 0; kind < GC_n_kinds; kind++) {\n-\t  for (size = 1; size <= MAXOBJSZ; size++) {\n-\t    q = GC_obj_kinds[kind].ok_freelist[size];\n-\t    if (q != 0) GC_clear_fl_marks(q);\n-\t  }\n-\t}\n-      }\n-\n-\n-#   ifdef PRINTSTATS\n-\tGC_printf1(\"Bytes recovered before sweep - f.l. count = %ld\\n\",\n-\t          (long)WORDS_TO_BYTES(GC_mem_found));\n-#   endif\n-    /* Reconstruct free lists to contain everything not marked */\n-        GC_start_reclaim(FALSE);\n-        if (GC_is_full_gc)  {\n-\t    GC_used_heap_size_after_full = USED_HEAP_SIZE;\n-\t    GC_need_full_gc = FALSE;\n-\t} else {\n-\t    GC_need_full_gc =\n-\t\t BYTES_TO_WORDS(USED_HEAP_SIZE - GC_used_heap_size_after_full)\n-\t\t > min_words_allocd();\n-\t}\n-\n-#   ifdef PRINTSTATS\n-\tGC_printf2(\n-\t\t  \"Immediately reclaimed %ld bytes in heap of size %lu bytes\",\n-\t          (long)WORDS_TO_BYTES(GC_mem_found),\n-\t          (unsigned long)GC_heapsize);\n-#\tifdef USE_MUNMAP\n-\t  GC_printf1(\"(%lu unmapped)\", GC_unmapped_bytes);\n-#\tendif\n-\tGC_printf2(\n-\t\t\"\\n%lu (atomic) + %lu (composite) collectable bytes in use\\n\",\n-\t        (unsigned long)WORDS_TO_BYTES(GC_atomic_in_use),\n-\t        (unsigned long)WORDS_TO_BYTES(GC_composite_in_use));\n-#   endif\n-\n-      GC_n_attempts = 0;\n-      GC_is_full_gc = FALSE;\n-    /* Reset or increment counters for next cycle */\n-      GC_words_allocd_before_gc += GC_words_allocd;\n-      GC_non_gc_bytes_at_gc = GC_non_gc_bytes;\n-      GC_words_allocd = 0;\n-      GC_words_wasted = 0;\n-      GC_mem_freed = 0;\n-      GC_finalizer_mem_freed = 0;\n-      \n-#   ifdef USE_MUNMAP\n-      GC_unmap_old();\n-#   endif\n-#   ifdef PRINTTIMES\n-\tGET_TIME(done_time);\n-\tGC_printf2(\"Finalize + initiate sweep took %lu + %lu msecs\\n\",\n-\t           MS_TIME_DIFF(finalize_time,start_time),\n-\t           MS_TIME_DIFF(done_time,finalize_time));\n-#   endif\n-}\n-\n-/* Externally callable routine to invoke full, stop-world collection */\n-# if defined(__STDC__) || defined(__cplusplus)\n-    int GC_try_to_collect(GC_stop_func stop_func)\n-# else\n-    int GC_try_to_collect(stop_func)\n-    GC_stop_func stop_func;\n-# endif\n-{\n-    int result;\n-    DCL_LOCK_STATE;\n-    \n-    if (GC_debugging_started) GC_print_all_smashed();\n-    GC_INVOKE_FINALIZERS();\n-    DISABLE_SIGNALS();\n-    LOCK();\n-    ENTER_GC();\n-    if (!GC_is_initialized) GC_init_inner();\n-    /* Minimize junk left in my registers */\n-      GC_noop(0,0,0,0,0,0);\n-    result = (int)GC_try_to_collect_inner(stop_func);\n-    EXIT_GC();\n-    UNLOCK();\n-    ENABLE_SIGNALS();\n-    if(result) {\n-        if (GC_debugging_started) GC_print_all_smashed();\n-        GC_INVOKE_FINALIZERS();\n-    }\n-    return(result);\n-}\n-\n-void GC_gcollect GC_PROTO(())\n-{\n-    (void)GC_try_to_collect(GC_never_stop_func);\n-    if (GC_have_errors) GC_print_all_errors();\n-}\n-\n-word GC_n_heap_sects = 0;\t/* Number of sections currently in heap. */\n-\n-/*\n- * Use the chunk of memory starting at p of size bytes as part of the heap.\n- * Assumes p is HBLKSIZE aligned, and bytes is a multiple of HBLKSIZE.\n- */\n-void GC_add_to_heap(p, bytes)\n-struct hblk *p;\n-word bytes;\n-{\n-    word words;\n-    hdr * phdr;\n-    \n-    if (GC_n_heap_sects >= MAX_HEAP_SECTS) {\n-    \tABORT(\"Too many heap sections: Increase MAXHINCR or MAX_HEAP_SECTS\");\n-    }\n-    phdr = GC_install_header(p);\n-    if (0 == phdr) {\n-    \t/* This is extremely unlikely. Can't add it.  This will\t\t*/\n-    \t/* almost certainly result in a\t0 return from the allocator,\t*/\n-    \t/* which is entirely appropriate.\t\t\t\t*/\n-    \treturn;\n-    }\n-    GC_heap_sects[GC_n_heap_sects].hs_start = (ptr_t)p;\n-    GC_heap_sects[GC_n_heap_sects].hs_bytes = bytes;\n-    GC_n_heap_sects++;\n-    words = BYTES_TO_WORDS(bytes);\n-    phdr -> hb_sz = words;\n-    phdr -> hb_map = (unsigned char *)1;   /* A value != GC_invalid_map\t*/\n-    phdr -> hb_flags = 0;\n-    GC_freehblk(p);\n-    GC_heapsize += bytes;\n-    if ((ptr_t)p <= (ptr_t)GC_least_plausible_heap_addr\n-        || GC_least_plausible_heap_addr == 0) {\n-        GC_least_plausible_heap_addr = (GC_PTR)((ptr_t)p - sizeof(word));\n-        \t/* Making it a little smaller than necessary prevents\t*/\n-        \t/* us from getting a false hit from the variable\t*/\n-        \t/* itself.  There's some unintentional reflection\t*/\n-        \t/* here.\t\t\t\t\t\t*/\n-    }\n-    if ((ptr_t)p + bytes >= (ptr_t)GC_greatest_plausible_heap_addr) {\n-        GC_greatest_plausible_heap_addr = (GC_PTR)((ptr_t)p + bytes);\n-    }\n-}\n-\n-# if !defined(NO_DEBUGGING)\n-void GC_print_heap_sects()\n-{\n-    register unsigned i;\n-    \n-    GC_printf1(\"Total heap size: %lu\\n\", (unsigned long) GC_heapsize);\n-    for (i = 0; i < GC_n_heap_sects; i++) {\n-        unsigned long start = (unsigned long) GC_heap_sects[i].hs_start;\n-        unsigned long len = (unsigned long) GC_heap_sects[i].hs_bytes;\n-        struct hblk *h;\n-        unsigned nbl = 0;\n-        \n-    \tGC_printf3(\"Section %ld from 0x%lx to 0x%lx \", (unsigned long)i,\n-    \t\t   start, (unsigned long)(start + len));\n-    \tfor (h = (struct hblk *)start; h < (struct hblk *)(start + len); h++) {\n-    \t    if (GC_is_black_listed(h, HBLKSIZE)) nbl++;\n-    \t}\n-    \tGC_printf2(\"%lu/%lu blacklisted\\n\", (unsigned long)nbl,\n-    \t\t   (unsigned long)(len/HBLKSIZE));\n-    }\n-}\n-# endif\n-\n-GC_PTR GC_least_plausible_heap_addr = (GC_PTR)ONES;\n-GC_PTR GC_greatest_plausible_heap_addr = 0;\n-\n-ptr_t GC_max(x,y)\n-ptr_t x, y;\n-{\n-    return(x > y? x : y);\n-}\n-\n-ptr_t GC_min(x,y)\n-ptr_t x, y;\n-{\n-    return(x < y? x : y);\n-}\n-\n-# if defined(__STDC__) || defined(__cplusplus)\n-    void GC_set_max_heap_size(GC_word n)\n-# else\n-    void GC_set_max_heap_size(n)\n-    GC_word n;\n-# endif\n-{\n-    GC_max_heapsize = n;\n-}\n-\n-GC_word GC_max_retries = 0;\n-\n-/*\n- * this explicitly increases the size of the heap.  It is used\n- * internally, but may also be invoked from GC_expand_hp by the user.\n- * The argument is in units of HBLKSIZE.\n- * Tiny values of n are rounded up.\n- * Returns FALSE on failure.\n- */\n-GC_bool GC_expand_hp_inner(n)\n-word n;\n-{\n-    word bytes;\n-    struct hblk * space;\n-    word expansion_slop;\t/* Number of bytes by which we expect the */\n-    \t\t\t\t/* heap to expand soon.\t\t\t  */\n-\n-    if (n < MINHINCR) n = MINHINCR;\n-    bytes = n * HBLKSIZE;\n-    /* Make sure bytes is a multiple of GC_page_size */\n-      {\n-\tword mask = GC_page_size - 1;\n-\tbytes += mask;\n-\tbytes &= ~mask;\n-      }\n-    \n-    if (GC_max_heapsize != 0 && GC_heapsize + bytes > GC_max_heapsize) {\n-        /* Exceeded self-imposed limit */\n-        return(FALSE);\n-    }\n-    space = GET_MEM(bytes);\n-    if( space == 0 ) {\n-#\tifdef CONDPRINT\n-\t  if (GC_print_stats) {\n-\t    GC_printf1(\"Failed to expand heap by %ld bytes\\n\",\n-\t\t       (unsigned long)bytes);\n-\t  }\n-#       endif\n-\treturn(FALSE);\n-    }\n-#   ifdef CONDPRINT\n-      if (GC_print_stats) {\n-\tGC_printf2(\"Increasing heap size by %lu after %lu allocated bytes\\n\",\n-\t           (unsigned long)bytes,\n-\t           (unsigned long)WORDS_TO_BYTES(GC_words_allocd));\n-# \tifdef UNDEFINED\n-\t  GC_printf1(\"Root size = %lu\\n\", GC_root_size);\n-\t  GC_print_block_list(); GC_print_hblkfreelist();\n-\t  GC_printf0(\"\\n\");\n-#\tendif\n-      }\n-#   endif\n-    expansion_slop = WORDS_TO_BYTES(min_words_allocd()) + 4*MAXHINCR*HBLKSIZE;\n-    if (GC_last_heap_addr == 0 && !((word)space & SIGNB)\n-        || (GC_last_heap_addr != 0 && GC_last_heap_addr < (ptr_t)space)) {\n-        /* Assume the heap is growing up */\n-        GC_greatest_plausible_heap_addr =\n-            (GC_PTR)GC_max((ptr_t)GC_greatest_plausible_heap_addr,\n-                           (ptr_t)space + bytes + expansion_slop);\n-    } else {\n-        /* Heap is growing down */\n-        GC_least_plausible_heap_addr =\n-            (GC_PTR)GC_min((ptr_t)GC_least_plausible_heap_addr,\n-                           (ptr_t)space - expansion_slop);\n-    }\n-#   if defined(LARGE_CONFIG)\n-      if (((ptr_t)GC_greatest_plausible_heap_addr <= (ptr_t)space + bytes\n-           || (ptr_t)GC_least_plausible_heap_addr >= (ptr_t)space)\n-\t  && GC_heapsize > 0) {\n-\t/* GC_add_to_heap will fix this, but ... */\n-\tWARN(\"Too close to address space limit: blacklisting ineffective\\n\", 0);\n-      }\n-#   endif\n-    GC_prev_heap_addr = GC_last_heap_addr;\n-    GC_last_heap_addr = (ptr_t)space;\n-    GC_add_to_heap(space, bytes);\n-    /* Force GC before we are likely to allocate past expansion_slop */\n-      GC_collect_at_heapsize =\n-\t  GC_heapsize + expansion_slop - 2*MAXHINCR*HBLKSIZE;\n-#     if defined(LARGE_CONFIG)\n-        if (GC_collect_at_heapsize < GC_heapsize /* wrapped */)\n-\t  GC_collect_at_heapsize = (word)(-1);\n-#     endif\n-    return(TRUE);\n-}\n-\n-/* Really returns a bool, but it's externally visible, so that's clumsy. */\n-/* Arguments is in bytes.\t\t\t\t\t\t*/\n-# if defined(__STDC__) || defined(__cplusplus)\n-  int GC_expand_hp(size_t bytes)\n-# else\n-  int GC_expand_hp(bytes)\n-  size_t bytes;\n-# endif\n-{\n-    int result;\n-    DCL_LOCK_STATE;\n-    \n-    DISABLE_SIGNALS();\n-    LOCK();\n-    if (!GC_is_initialized) GC_init_inner();\n-    result = (int)GC_expand_hp_inner(divHBLKSZ((word)bytes));\n-    if (result) GC_requested_heapsize += bytes;\n-    UNLOCK();\n-    ENABLE_SIGNALS();\n-    return(result);\n-}\n-\n-unsigned GC_fail_count = 0;  \n-\t\t\t/* How many consecutive GC/expansion failures?\t*/\n-\t\t\t/* Reset by GC_allochblk.\t\t\t*/\n-\n-GC_bool GC_collect_or_expand(needed_blocks, ignore_off_page)\n-word needed_blocks;\n-GC_bool ignore_off_page;\n-{\n-    if (!GC_incremental && !GC_dont_gc &&\n-\t((GC_dont_expand && GC_words_allocd > 0) || GC_should_collect())) {\n-      GC_gcollect_inner();\n-    } else {\n-      word blocks_to_get = GC_heapsize/(HBLKSIZE*GC_free_space_divisor)\n-      \t\t\t   + needed_blocks;\n-      \n-      if (blocks_to_get > MAXHINCR) {\n-          word slop;\n-          \n-\t  /* Get the minimum required to make it likely that we\t\t*/\n-\t  /* can satisfy the current request in the presence of black-\t*/\n-\t  /* listing.  This will probably be more than MAXHINCR.\t*/\n-          if (ignore_off_page) {\n-              slop = 4;\n-          } else {\n-\t      slop = 2*divHBLKSZ(BL_LIMIT);\n-\t      if (slop > needed_blocks) slop = needed_blocks;\n-\t  }\n-          if (needed_blocks + slop > MAXHINCR) {\n-              blocks_to_get = needed_blocks + slop;\n-          } else {\n-              blocks_to_get = MAXHINCR;\n-          }\n-      }\n-      if (!GC_expand_hp_inner(blocks_to_get)\n-        && !GC_expand_hp_inner(needed_blocks)) {\n-      \tif (GC_fail_count++ < GC_max_retries) {\n-      \t    WARN(\"Out of Memory!  Trying to continue ...\\n\", 0);\n-\t    GC_gcollect_inner();\n-\t} else {\n-#\t    if !defined(AMIGA) || !defined(GC_AMIGA_FASTALLOC)\n-\t      WARN(\"Out of Memory!  Returning NIL!\\n\", 0);\n-#\t    endif\n-\t    return(FALSE);\n-\t}\n-      } else {\n-#\t  ifdef CONDPRINT\n-            if (GC_fail_count && GC_print_stats) {\n-\t      GC_printf0(\"Memory available again ...\\n\");\n-\t    }\n-#\t  endif\n-      }\n-    }\n-    return(TRUE);\n-}\n-\n-/*\n- * Make sure the object free list for sz is not empty.\n- * Return a pointer to the first object on the free list.\n- * The object MUST BE REMOVED FROM THE FREE LIST BY THE CALLER.\n- * Assumes we hold the allocator lock and signals are disabled.\n- *\n- */\n-ptr_t GC_allocobj(sz, kind)\n-word sz;\n-int kind;\n-{\n-    ptr_t * flh = &(GC_obj_kinds[kind].ok_freelist[sz]);\n-    GC_bool tried_minor = FALSE;\n-    \n-    if (sz == 0) return(0);\n-\n-    while (*flh == 0) {\n-      ENTER_GC();\n-      /* Do our share of marking work */\n-        if(TRUE_INCREMENTAL) GC_collect_a_little_inner(1);\n-      /* Sweep blocks for objects of this size */\n-        GC_continue_reclaim(sz, kind);\n-      EXIT_GC();\n-      if (*flh == 0) {\n-        GC_new_hblk(sz, kind);\n-      }\n-      if (*flh == 0) {\n-        ENTER_GC();\n-\tif (GC_incremental && GC_time_limit == GC_TIME_UNLIMITED\n-\t    && ! tried_minor ) {\n-\t    GC_collect_a_little_inner(1);\n-\t    tried_minor = TRUE;\n-\t} else {\n-          if (!GC_collect_or_expand((word)1,FALSE)) {\n-\t    EXIT_GC();\n-\t    return(0);\n-\t  }\n-\t}\n-\tEXIT_GC();\n-      }\n-    }\n-    /* Successful allocation; reset failure count.\t*/\n-    GC_fail_count = 0;\n-    \n-    return(*flh);\n-}"}, {"sha": "d4def2405f9edf6cde19cfdc0a4d7d642d7e5738", "filename": "boehm-gc/alpha_mach_dep.S", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Falpha_mach_dep.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Falpha_mach_dep.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Falpha_mach_dep.S?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,86 +0,0 @@\n-\t.arch ev6\n-\n-        .text\n-        .align  4\n-        .globl  GC_push_regs\n-        .ent    GC_push_regs 2\n-GC_push_regs:\n-\tldgp    $gp, 0($27)\n-\tlda     $sp, -16($sp)\n-\tstq     $26, 0($sp)\n-        .mask   0x04000000, 0\n-        .frame  $sp, 16, $26, 0\n-\n-/* $0\t\tinteger result                                                */\n-/* $1-$8\ttemp regs - not preserved cross calls                         */\n-/* $9-$15\tcall saved regs                                               */\n-/* $16-$21\targument regs - not preserved cross calls                     */\n-/* $22-$28\ttemp regs - not preserved cross calls                         */\n-/* $29\t\tglobal pointer - not preserved cross calls                    */\n-/* $30\t\tstack pointer                                                 */\n-\n-# define call_push(x)\t\t\t\\\n-\tmov   x, $16;\t\t\t\\\n-\tjsr   $26, GC_push_one;\t\t\\\n-\tldgp  $gp, 0($26)\n-\t\n-        call_push($9)\n-        call_push($10)\n-        call_push($11)\n-        call_push($12)\n-        call_push($13)\n-        call_push($14)\n-        call_push($15)\n-\n-/* $f0-$f1\tfloating point results                                        */\n-/* $f2-$f9\tcall saved regs                                               */\n-/* $f10-$f30\ttemp regs - not preserved cross calls                         */\n-\n-\t/* Use the most efficient transfer method for this hardware. */\n-\t/* Bit 1 detects the FIX extension, which includes ftoit. */\n-\tamask\t2, $0\n-\tbne\t$0, $use_stack\n-\n-#undef call_push\n-#define call_push(x)\t\t\t\\\n-\tftoit\tx, $16;\t\t\t\\\n-\tjsr\t$26, GC_push_one;\t\\\n-\tldgp\t$gp, 0($26)\n-\n-\tcall_push($f2)\n-\tcall_push($f3)\n-\tcall_push($f4)\n-\tcall_push($f5)\n-\tcall_push($f6)\n-\tcall_push($f7)\n-\tcall_push($f8)\n-\tcall_push($f9)\n-\n-\tldq     $26, 0($sp)\n-\tlda     $sp, 16($sp)\n-\tret     $31, ($26), 1\n-\n-\t.align\t4\n-$use_stack:\n-\n-#undef call_push\n-#define call_push(x)\t\t\t\\\n-\tstt\tx, 8($sp);\t\t\\\n-\tldq\t$16, 8($sp);\t\t\\\n-\tjsr\t$26, GC_push_one;\t\\\n-\tldgp\t$gp, 0($26)\n-\n-\tcall_push($f2)\n-\tcall_push($f3)\n-\tcall_push($f4)\n-\tcall_push($f5)\n-\tcall_push($f6)\n-\tcall_push($f7)\n-\tcall_push($f8)\n-\tcall_push($f9)\n-\n-\tldq     $26, 0($sp)\n-\tlda     $sp, 16($sp)\n-\tret     $31, ($26), 1\n-\n-\t.end    GC_push_regs"}, {"sha": "94757c89158a573669b0875ecf212dc26eeaa7da", "filename": "boehm-gc/backgraph.c", "status": "removed", "additions": 0, "deletions": 469, "changes": 469, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fbackgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fbackgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fbackgraph.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,469 +0,0 @@\n-/*\n- * Copyright (c) 2001 by Hewlett-Packard Company. All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- *\n- */\n-\n-/*\n- * This implements a full, though not well-tuned, representation of the\n- * backwards points-to graph.  This is used to test for non-GC-robust\n- * data structures; the code is not used during normal garbage collection.\n- *\n- * One restriction is that we drop all back-edges from nodes with very\n- * high in-degree, and simply add them add them to a list of such\n- * nodes.  They are then treated as permanent roots.  Id this by itself\n- * doesn't introduce a space leak, then such nodes can't contribute to\n- * a growing space leak.\n- */\n-\n-#include \"gc.h\"\t/* For configuration information. */\n-\n-#ifdef MAKE_BACK_GRAPH\n-\n-#define MAX_IN\t10\t/* Maximum in-degree we handle directly */\n-\n-#include \"private/dbg_mlc.h\"\n-#include <unistd.h>\n-\n-#if !defined(DBG_HDRS_ALL) || (ALIGNMENT != CPP_WORDSZ/8) || !defined(UNIX_LIKE)\n-# error Configuration doesnt support MAKE_BACK_GRAPH\n-#endif\n-\n-/* We store single back pointers directly in the object's oh_bg_ptr field.   */\n-/* If there is more than one ptr to an object, we store q | FLAG_MANY, \t     */\n-/* where q is a pointer to a back_edges object.\t\t\t\t     */\n-/* Every once in a while we use a back_edges object even for a single\t     */\n-/* pointer, since we need the other fields in the back_edges structure to    */\n-/* be present in some fraction of the objects.  Otherwise we get serious     */\n-/* performance issues.\t\t\t\t\t\t\t     */\n-#define FLAG_MANY 2\n-\n-typedef struct back_edges_struct {\n-  word n_edges;\t/* Number of edges, including those in continuation\t*/\n-  \t\t/* structures.\t\t\t\t\t\t*/\n-  unsigned short flags;\n-#\tdefine RETAIN 1\t/* Directly points to a reachable object;\t*/\n-  \t\t\t/* retain for next GC.\t\t\t\t*/\n-  unsigned short height_gc_no;\n-  \t\t/* If height > 0, then the GC_gc_no value when it\t*/\n-  \t\t/* was computed.  If it was computed this cycle, then\t*/\n-  \t\t/* it is current.  If it was computed during the\t*/\n-  \t\t/* last cycle, then it represents the old height,\t*/\n-  \t\t/* which is only saved for live objects referenced by\t*/\n-  \t\t/* dead ones.  This may grow due to refs from newly\t*/\n-\t\t/* dead objects.\t\t\t\t        */\n-  signed_word height;\n-  \t\t/* Longest path through unreachable nodes to this node\t*/\n-  \t\t/* that we found using depth first search.\t\t*/\n-  \n-#   define HEIGHT_UNKNOWN ((signed_word)(-2))\n-#   define HEIGHT_IN_PROGRESS ((signed_word)(-1))\n-  ptr_t edges[MAX_IN];\n-  struct back_edges_struct *cont;\n-  \t\t/* Pointer to continuation structure; we use only the\t*/\n-  \t\t/* edges field in the continuation.\t\t\t*/\n-  \t\t/* also used as free list link.\t\t\t\t*/\n-} back_edges;\n-\n-/* Allocate a new back edge structure.  Should be more sophisticated\t*/\n-/* if this were production code.\t\t\t\t\t*/\n-#define MAX_BACK_EDGE_STRUCTS 100000\n-static back_edges *back_edge_space = 0;\n-int GC_n_back_edge_structs = 0;\t/* Serves as pointer to never used\t*/\n-\t\t\t\t/* back_edges space.\t\t\t*/\n-static back_edges *avail_back_edges = 0;\n-\t\t\t\t/* Pointer to free list of deallocated\t*/\n-\t\t\t\t/* back_edges structures.\t\t*/\n-\n-static back_edges * new_back_edges(void)\n-{\n-  if (0 == back_edge_space) {\n-    back_edge_space = (back_edges *)\n-\t    \t\tGET_MEM(MAX_BACK_EDGE_STRUCTS*sizeof(back_edges));\n-  }\n-  if (0 != avail_back_edges) {\n-    back_edges * result = avail_back_edges;\n-    avail_back_edges = result -> cont;\n-    result -> cont = 0;\n-    return result;\n-  }\n-  if (GC_n_back_edge_structs >= MAX_BACK_EDGE_STRUCTS - 1) {\n-    ABORT(\"needed too much space for back edges: adjust \"\n-\t  \"MAX_BACK_EDGE_STRUCTS\");\n-  }\n-  return back_edge_space + (GC_n_back_edge_structs++);\n-}\n-\n-/* Deallocate p and its associated continuation structures.\t*/\n-static void deallocate_back_edges(back_edges *p)\n-{\n-   back_edges *last = p;\n-\n-   while (0 != last -> cont) last = last -> cont;\n-   last -> cont = avail_back_edges;\n-   avail_back_edges = p;\n-}\n-\n-/* Table of objects that are currently on the depth-first search\t*/\n-/* stack.  Only objects with in-degree one are in this table.\t\t*/\n-/* Other objects are identified using HEIGHT_IN_PROGRESS.\t\t*/\n-/* FIXME: This data structure NEEDS IMPROVEMENT.\t\t\t*/\n-#define INITIAL_IN_PROGRESS 10000\n-static ptr_t * in_progress_space = 0;\n-static size_t in_progress_size = 0;\n-static size_t n_in_progress = 0;\n-\n-static void push_in_progress(ptr_t p)\n-{\n-  if (n_in_progress >= in_progress_size) \n-    if (in_progress_size == 0) {\n-      in_progress_size = INITIAL_IN_PROGRESS;\n-      in_progress_space = (ptr_t *)GET_MEM(in_progress_size * sizeof(ptr_t));\n-    } else {\n-      ptr_t * new_in_progress_space;\n-      in_progress_size *= 2;\n-      new_in_progress_space = (ptr_t *)\n-\t      \t\t\tGET_MEM(in_progress_size * sizeof(ptr_t));\n-      BCOPY(in_progress_space, new_in_progress_space,\n-\t    n_in_progress * sizeof(ptr_t));\n-      in_progress_space = new_in_progress_space;\n-      /* FIXME: This just drops the old space.\t*/\n-    }\n-  if (in_progress_space == 0)\n-      ABORT(\"MAKE_BACK_GRAPH: Out of in-progress space: \"\n-\t    \"Huge linear data structure?\");\n-  in_progress_space[n_in_progress++] = p;\n-}\n-\n-static GC_bool is_in_progress(ptr_t p)\n-{\n-  int i;\n-  for (i = 0; i < n_in_progress; ++i) {\n-    if (in_progress_space[i] == p) return TRUE;\n-  }\n-  return FALSE;\n-}\n-\n-static void pop_in_progress(ptr_t p)\n-{\n-  --n_in_progress;\n-  GC_ASSERT(in_progress_space[n_in_progress] == p);\n-}\n-\n-#define GET_OH_BG_PTR(p) \\\n-\t\t(ptr_t)REVEAL_POINTER(((oh *)(p)) -> oh_bg_ptr)\n-#define SET_OH_BG_PTR(p,q) (((oh *)(p)) -> oh_bg_ptr) = HIDE_POINTER(q)\n-\n-/* Execute s once for each predecessor q of p in the points-to graph. \t*/\n-/* s should be a bracketed statement.  We declare q.\t\t\t*/\n-#define FOR_EACH_PRED(q, p, s) \\\n-  { \\\n-    ptr_t q = GET_OH_BG_PTR(p); \\\n-    if (!((word)q & FLAG_MANY)) { \\\n-      if (q && !((word)q & 1)) s \\\n-\t      /* !((word)q & 1) checks for a misnterpreted freelist link */ \\\n-    } else { \\\n-      back_edges *orig_be_ = (back_edges *)((word)q & ~FLAG_MANY); \\\n-      back_edges *be_ = orig_be_; \\\n-      int total_, local_; \\\n-      int n_edges_ = be_ -> n_edges; \\\n-      for (total_ = 0, local_ = 0; total_ < n_edges_; ++local_, ++total_) { \\\n-\t  if (local_ == MAX_IN) { \\\n-\t      be_ = be_ -> cont; \\\n-\t      local_ = 0; \\\n-\t  } \\\n-\t  q = be_ -> edges[local_]; s \\\n-      } \\\n-    } \\\n-  }\n-\n-/* Ensure that p has a back_edges structure associated with it.\t*/\n-static void ensure_struct(ptr_t p)\n-{\n-  ptr_t old_back_ptr = GET_OH_BG_PTR(p);\n-\n-  if (!((word)old_back_ptr & FLAG_MANY)) {\n-    back_edges *be = new_back_edges();\n-    be -> flags = 0;\n-    if (0 == old_back_ptr) {\n-      be -> n_edges = 0;\n-    } else {\n-      be -> n_edges = 1;\n-      be -> edges[0] = old_back_ptr;\n-    }\n-    be -> height = HEIGHT_UNKNOWN;\n-    be -> height_gc_no = GC_gc_no - 1;\n-    GC_ASSERT(be >= back_edge_space);\n-    SET_OH_BG_PTR(p, (word)be | FLAG_MANY);\n-  }\n-}\n-\n-/* Add the (forward) edge from p to q to the backward graph.  Both p\t*/\n-/* q are pointers to the object base, i.e. pointers to an oh.\t\t*/\n-static void add_edge(ptr_t p,  ptr_t q)\n-{\n-    ptr_t old_back_ptr = GET_OH_BG_PTR(q);\n-    back_edges * be, *be_cont;\n-    word i;\n-    static unsigned random_number = 13;\n-#   define GOT_LUCKY_NUMBER (((++random_number) & 0x7f) == 0)\n-      /* A not very random number we use to occasionally allocate a\t*/\n-      /* back_edges structure even for a single backward edge.  This\t*/\n-      /* prevents us from repeatedly tracing back through very long\t*/\n-      /* chains, since we will have some place to store height and\t*/\n-      /* in_progress flags along the way.\t\t\t\t*/\n-\n-    GC_ASSERT(p == GC_base(p) && q == GC_base(q));\n-    if (!GC_HAS_DEBUG_INFO(q) || !GC_HAS_DEBUG_INFO(p)) {\n-      /* This is really a misinterpreted free list link, since we saw */\n-      /* a pointer to a free list.  Dont overwrite it!\t\t      */\n-      return;\n-    }\n-    if (0 == old_back_ptr) {\n-\tSET_OH_BG_PTR(q, p);\n-\tif (GOT_LUCKY_NUMBER) ensure_struct(q);\n-\treturn;\n-    }\n-    /* Check whether it was already in the list of predecessors. */\n-      FOR_EACH_PRED(pred, q, { if (p == pred) return; });\n-    ensure_struct(q);\n-    old_back_ptr = GET_OH_BG_PTR(q);\n-    be = (back_edges *)((word)old_back_ptr & ~FLAG_MANY);\n-    for (i = be -> n_edges, be_cont = be; i > MAX_IN;\n-\tbe_cont = be_cont -> cont, i -= MAX_IN) {}\n-    if (i == MAX_IN) {\n-\tbe_cont -> cont = new_back_edges();\n-\tbe_cont = be_cont -> cont;\n-\ti = 0;\n-    }\n-    be_cont -> edges[i] = p;\n-    be -> n_edges++;\n-    if (be -> n_edges == 100) {\n-#       if 0\n-\t  if (GC_print_stats) {\n-\t    GC_err_printf0(\"The following object has in-degree >= 100:\\n\");\n-\t    GC_print_heap_obj(q);\n-\t  }\n-#\tendif\n-    }\n-}\n-\n-typedef void (*per_object_func)(ptr_t p, word n_words, word gc_descr);\n-\n-static void per_object_helper(struct hblk *h, word fn)\n-{\n-  hdr * hhdr = HDR(h);\n-  word sz = hhdr -> hb_sz;\n-  word descr = hhdr -> hb_descr;\n-  per_object_func f = (per_object_func)fn;\n-  int i = 0;\n-\n-  do {\n-    f((ptr_t)(h -> hb_body + i), sz, descr);\n-    i += sz;\n-  } while (i + sz <= BYTES_TO_WORDS(HBLKSIZE));\n-}\n-\n-void GC_apply_to_each_object(per_object_func f)\n-{\n-  GC_apply_to_all_blocks(per_object_helper, (word)f);\n-}\n-\n-static void reset_back_edge(ptr_t p, word n_words, word gc_descr)\n-{\n-  /* Skip any free list links, or dropped blocks */\n-  if (GC_HAS_DEBUG_INFO(p)) {\n-    ptr_t old_back_ptr = GET_OH_BG_PTR(p);\n-    if ((word)old_back_ptr & FLAG_MANY) {\n-      back_edges *be = (back_edges *)((word)old_back_ptr & ~FLAG_MANY);\n-      if (!(be -> flags & RETAIN)) {\n-\tdeallocate_back_edges(be);\n-        SET_OH_BG_PTR(p, 0); \n-      } else {\n-        word *currentp;\n-\n-\tGC_ASSERT(GC_is_marked(p));\n-\n-\t/* Back edges may point to objects that will not be retained. \t*/\n-\t/* Delete them for now, but remember the height.\t\t*/\n-\t/* Some will be added back at next GC.\t\t\t\t*/\n-\t  be -> n_edges = 0;\n-\t  if (0 != be -> cont) {\n-\t    deallocate_back_edges(be -> cont);\n-\t    be -> cont = 0;\n-\t  }\n-\n-\tGC_ASSERT(GC_is_marked(p));\n-\n-\t/* We only retain things for one GC cycle at a time.\t\t*/\n-\t  be -> flags &= ~RETAIN;\n-      }\n-    } else /* Simple back pointer */ {\n-      /* Clear to avoid dangling pointer. */\n-      SET_OH_BG_PTR(p, 0);\n-    }\n-  }\n-}\n-\n-static void add_back_edges(ptr_t p, word n_words, word gc_descr)\n-{\n-  word *currentp = (word *)(p + sizeof(oh));\n-\n-  /* For now, fix up non-length descriptors conservatively.\t*/\n-    if((gc_descr & GC_DS_TAGS) != GC_DS_LENGTH) {\n-      gc_descr = WORDS_TO_BYTES(n_words);\n-    }\n-  while (currentp < (word *)(p + gc_descr)) {\n-    word current = *currentp++;\n-    FIXUP_POINTER(current);\n-    if (current >= (word)GC_least_plausible_heap_addr && \n-\tcurrent <= (word)GC_greatest_plausible_heap_addr) {\n-       ptr_t target = GC_base((GC_PTR)current);\n-       if (0 != target) {\n-\t add_edge(p, target);\n-       }\n-    }\n-  }\n-}\n-\n-/* Rebuild the representation of the backward reachability graph.\t*/\n-/* Does not examine mark bits.  Can be called before GC.\t\t*/\n-void GC_build_back_graph(void)\n-{\n-  GC_apply_to_each_object(add_back_edges);\n-}\n-\n-/* Return an approximation to the length of the longest simple path\t*/\n-/* through unreachable objects to p.  We refer to this as the height\t*/\n-/* of p.\t\t\t\t\t\t\t\t*/\n-static word backwards_height(ptr_t p)\n-{\n-  word result;\n-  ptr_t back_ptr = GET_OH_BG_PTR(p);\n-  back_edges *be;\n-\n-  if (0 == back_ptr) return 1;\n-  if (!((word)back_ptr & FLAG_MANY)) {\n-    if (is_in_progress(p)) return 0;  /* DFS back edge, i.e. we followed  */\n-    \t\t\t\t      /* an edge to an object already\t  */\n-    \t\t\t\t      /* on our stack: ignore\t\t  */\n-    push_in_progress(p);\n-    result = backwards_height(back_ptr)+1;\n-    pop_in_progress(p);\n-    return result;\n-  }\n-  be = (back_edges *)((word)back_ptr & ~FLAG_MANY);\n-  if (be -> height >= 0 && be -> height_gc_no == GC_gc_no)\n-      return be -> height;\n-  /* Ignore back edges in DFS */\n-    if (be -> height == HEIGHT_IN_PROGRESS) return 0;\n-  result = (be -> height > 0? be -> height : 1);\n-  be -> height = HEIGHT_IN_PROGRESS;\n-  FOR_EACH_PRED(q, p, {\n-    word this_height;\n-    if (GC_is_marked(q) && !(FLAG_MANY & (word)GET_OH_BG_PTR(p))) {\n-      if (GC_print_stats)\n-\t  GC_printf2(\"Found bogus pointer from 0x%lx to 0x%lx\\n\", q, p);\n-\t/* Reachable object \"points to\" unreachable one.\t\t*/\n-\t/* Could be caused by our lax treatment of GC descriptors.\t*/\n-      this_height = 1;\n-    } else {\n-        this_height = backwards_height(q);\n-    }\n-    if (this_height >= result) result = this_height + 1;\n-  });\n-  be -> height = result;\n-  be -> height_gc_no = GC_gc_no;\n-  return result;\n-}\n-\n-word GC_max_height;\n-ptr_t GC_deepest_obj;\n-\n-/* Compute the maximum height of every unreachable predecessor p of  a \t*/\n-/* reachable object.  Arrange to save the heights of all such objects p\t*/\n-/* so that they can be used in calculating the height of objects in the\t*/\n-/* next GC.\t\t\t\t\t\t\t\t*/\n-/* Set GC_max_height to be the maximum height we encounter, and \t*/\n-/* GC_deepest_obj to be the corresponding object.\t\t\t*/\n-static void update_max_height(ptr_t p, word n_words, word gc_descr)\n-{\n-  if (GC_is_marked(p) && GC_HAS_DEBUG_INFO(p)) {\n-    int i;\n-    word p_height = 0;\n-    ptr_t p_deepest_obj = 0;\n-    ptr_t back_ptr;\n-    back_edges *be = 0;\n-\n-    /* If we remembered a height last time, use it as a minimum.\t*/\n-    /* It may have increased due to newly unreachable chains pointing\t*/\n-    /* to p, but it can't have decreased.\t\t\t\t*/\n-    back_ptr = GET_OH_BG_PTR(p);\n-    if (0 != back_ptr && ((word)back_ptr & FLAG_MANY)) {\n-      be = (back_edges *)((word)back_ptr & ~FLAG_MANY);\n-      if (be -> height != HEIGHT_UNKNOWN) p_height = be -> height;\n-    }\n-    FOR_EACH_PRED(q, p, {\n-      if (!GC_is_marked(q) && GC_HAS_DEBUG_INFO(q)) {\n-        word q_height;\n-\n-        q_height = backwards_height(q);\n-\tif (q_height > p_height) {\n-\t  p_height = q_height;\n-\t  p_deepest_obj = q;\n-\t}\n-      }\n-    });\n-    if (p_height > 0) {\n-      /* Remember the height for next time. */\n-\tif (be == 0) {\n-    \t  ensure_struct(p);\n-    \t  back_ptr = GET_OH_BG_PTR(p);\n-  \t  be = (back_edges *)((word)back_ptr & ~FLAG_MANY);\n-\t}\n-\tbe -> flags |= RETAIN;\n-\tbe -> height = p_height;\n-\tbe -> height_gc_no = GC_gc_no;\n-    }\n-    if (p_height > GC_max_height) {\n-\tGC_max_height = p_height;\n-\tGC_deepest_obj = p_deepest_obj;\n-    }\n-  }\n-}\n-\n-word GC_max_max_height = 0;\n-\n-void GC_traverse_back_graph(void)\n-{\n-  GC_max_height = 0;\n-  GC_apply_to_each_object(update_max_height);\n-}\n-\n-void GC_print_back_graph_stats(void)\n-{\n-  GC_printf2(\"Maximum backwards height of reachable objects at GC %lu is %ld\\n\",\n-\t     (unsigned long) GC_gc_no, GC_max_height);\n-  if (GC_max_height > GC_max_max_height) {\n-    GC_max_max_height = GC_max_height;\n-    GC_printf0(\"The following unreachable object is last in a longest chain \"\n-\t       \"of unreachable objects:\\n\");\n-    GC_print_heap_obj(GC_deepest_obj);\n-  }\n-  if (GC_print_stats) {\n-    GC_printf1(\"Needed max total of %ld back-edge structs\\n\",\n-\t       GC_n_back_edge_structs);\n-  }\n-  GC_apply_to_each_object(reset_back_edge);\n-  GC_deepest_obj = 0;\n-}\n-\n-#endif /* MAKE_BACK_GRAPH */"}, {"sha": "ae2f95cb3fe207d911dade789078327631f59aad", "filename": "boehm-gc/blacklst.c", "status": "removed", "additions": 0, "deletions": 300, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fblacklst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fblacklst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fblacklst.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,300 +0,0 @@\n-/* \n- * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n- * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n-/* Boehm, August 9, 1995 6:09 pm PDT */\n-# include \"private/gc_priv.h\"\n-\n-/*\n- * We maintain several hash tables of hblks that have had false hits.\n- * Each contains one bit per hash bucket;  If any page in the bucket\n- * has had a false hit, we assume that all of them have.\n- * See the definition of page_hash_table in gc_private.h.\n- * False hits from the stack(s) are much more dangerous than false hits\n- * from elsewhere, since the former can pin a large object that spans the\n- * block, eventhough it does not start on the dangerous block.\n- */\n- \n-/*\n- * Externally callable routines are:\n- \n- * GC_add_to_black_list_normal\n- * GC_add_to_black_list_stack\n- * GC_promote_black_lists\n- * GC_is_black_listed\n- *\n- * All require that the allocator lock is held.\n- */\n-\n-/* Pointers to individual tables.  We replace one table by another by \t*/\n-/* switching these pointers. \t\t\t\t\t\t*/\n-word * GC_old_normal_bl;\n-\t\t/* Nonstack false references seen at last full\t\t*/\n-\t\t/* collection.\t\t\t\t\t\t*/\n-word * GC_incomplete_normal_bl;\n-\t\t/* Nonstack false references seen since last\t\t*/\n-\t\t/* full collection.\t\t\t\t\t*/\n-word * GC_old_stack_bl;\n-word * GC_incomplete_stack_bl;\n-\n-word GC_total_stack_black_listed;\n-\n-word GC_black_list_spacing = MINHINCR*HBLKSIZE;  /* Initial rough guess */\n-\n-void GC_clear_bl();\n-\n-# if defined(__STDC__) || defined(__cplusplus)\n-    void GC_default_print_heap_obj_proc(ptr_t p)\n-# else\n-    void GC_default_print_heap_obj_proc(p)\n-    ptr_t p;\n-# endif\n-{\n-    ptr_t base = GC_base(p);\n-\n-    GC_err_printf2(\"start: 0x%lx, appr. length: %ld\", base, GC_size(base));\n-}\n-\n-void (*GC_print_heap_obj) GC_PROTO((ptr_t p)) =\n-\t\t\t\tGC_default_print_heap_obj_proc;\n-\n-void GC_print_source_ptr(p)\n-ptr_t p;\n-{\n-    ptr_t base = GC_base(p);\n-    if (0 == base) {\n-\tif (0 == p) {\n-\t    GC_err_printf0(\"in register\");\n-\t} else {\n-\t    GC_err_printf0(\"in root set\");\n-\t}\n-    } else {\n-\tGC_err_printf0(\"in object at \");\n-\t(*GC_print_heap_obj)(base);\n-    }\n-}\n-\n-void GC_bl_init()\n-{\n-    if (!GC_all_interior_pointers) {\n-      GC_old_normal_bl = (word *)\n-    \t\t\t GC_scratch_alloc((word)(sizeof (page_hash_table)));\n-      GC_incomplete_normal_bl = (word *)GC_scratch_alloc\n-    \t\t\t\t\t((word)(sizeof(page_hash_table)));\n-      if (GC_old_normal_bl == 0 || GC_incomplete_normal_bl == 0) {\n-        GC_err_printf0(\"Insufficient memory for black list\\n\");\n-        EXIT();\n-      }\n-      GC_clear_bl(GC_old_normal_bl);\n-      GC_clear_bl(GC_incomplete_normal_bl);\n-    }\n-    GC_old_stack_bl = (word *)GC_scratch_alloc((word)(sizeof(page_hash_table)));\n-    GC_incomplete_stack_bl = (word *)GC_scratch_alloc\n-    \t\t\t\t\t((word)(sizeof(page_hash_table)));\n-    if (GC_old_stack_bl == 0 || GC_incomplete_stack_bl == 0) {\n-        GC_err_printf0(\"Insufficient memory for black list\\n\");\n-        EXIT();\n-    }\n-    GC_clear_bl(GC_old_stack_bl);\n-    GC_clear_bl(GC_incomplete_stack_bl);\n-}\n-\t\t\n-void GC_clear_bl(doomed)\n-word *doomed;\n-{\n-    BZERO(doomed, sizeof(page_hash_table));\n-}\n-\n-void GC_copy_bl(old, new)\n-word *new, *old;\n-{\n-    BCOPY(old, new, sizeof(page_hash_table));\n-}\n-\n-static word total_stack_black_listed();\n-\n-/* Signal the completion of a collection.  Turn the incomplete black\t*/\n-/* lists into new black lists, etc.\t\t\t\t\t*/\t\t\t \n-void GC_promote_black_lists()\n-{\n-    word * very_old_normal_bl = GC_old_normal_bl;\n-    word * very_old_stack_bl = GC_old_stack_bl;\n-    \n-    GC_old_normal_bl = GC_incomplete_normal_bl;\n-    GC_old_stack_bl = GC_incomplete_stack_bl;\n-    if (!GC_all_interior_pointers) {\n-      GC_clear_bl(very_old_normal_bl);\n-    }\n-    GC_clear_bl(very_old_stack_bl);\n-    GC_incomplete_normal_bl = very_old_normal_bl;\n-    GC_incomplete_stack_bl = very_old_stack_bl;\n-    GC_total_stack_black_listed = total_stack_black_listed();\n-#   ifdef PRINTSTATS\n-  \tGC_printf1(\"%ld bytes in heap blacklisted for interior pointers\\n\",\n-  \t\t   (unsigned long)GC_total_stack_black_listed);\n-#   endif\n-    if (GC_total_stack_black_listed != 0) {\n-        GC_black_list_spacing =\n-\t\tHBLKSIZE*(GC_heapsize/GC_total_stack_black_listed);\n-    }\n-    if (GC_black_list_spacing < 3 * HBLKSIZE) {\n-    \tGC_black_list_spacing = 3 * HBLKSIZE;\n-    }\n-    if (GC_black_list_spacing > MAXHINCR * HBLKSIZE) {\n-\tGC_black_list_spacing = MAXHINCR * HBLKSIZE;\n-\t/* Makes it easier to allocate really huge blocks, which otherwise */\n-\t/* may have problems with nonuniform blacklist distributions.\t   */\n-\t/* This way we should always succeed immediately after growing the */ \n-\t/* heap.\t\t\t\t\t\t\t   */\n-    }\n-}\n-\n-void GC_unpromote_black_lists()\n-{\n-    if (!GC_all_interior_pointers) {\n-      GC_copy_bl(GC_old_normal_bl, GC_incomplete_normal_bl);\n-    }\n-    GC_copy_bl(GC_old_stack_bl, GC_incomplete_stack_bl);\n-}\n-\n-/* P is not a valid pointer reference, but it falls inside\t*/\n-/* the plausible heap bounds.\t\t\t\t\t*/\n-/* Add it to the normal incomplete black list if appropriate.\t*/\n-#ifdef PRINT_BLACK_LIST\n-  void GC_add_to_black_list_normal(p, source)\n-  ptr_t source;\n-#else\n-  void GC_add_to_black_list_normal(p)\n-#endif\n-word p;\n-{\n-    if (!(GC_modws_valid_offsets[p & (sizeof(word)-1)])) return;\n-    {\n-        register int index = PHT_HASH(p);\n-        \n-        if (HDR(p) == 0 || get_pht_entry_from_index(GC_old_normal_bl, index)) {\n-#   \t    ifdef PRINT_BLACK_LIST\n-\t\tif (!get_pht_entry_from_index(GC_incomplete_normal_bl, index)) {\n-\t    \t  GC_err_printf2(\n-\t\t\t\"Black listing (normal) 0x%lx referenced from 0x%lx \",\n-\t    \t        (unsigned long) p, (unsigned long) source);\n-\t\t  GC_print_source_ptr(source);\n-\t\t  GC_err_puts(\"\\n\");\n-\t    \t}\n-#           endif\n-            set_pht_entry_from_index(GC_incomplete_normal_bl, index);\n-        } /* else this is probably just an interior pointer to an allocated */\n-          /* object, and isn't worth black listing.\t\t\t    */\n-    }\n-}\n-\n-/* And the same for false pointers from the stack. */\n-#ifdef PRINT_BLACK_LIST\n-  void GC_add_to_black_list_stack(p, source)\n-  ptr_t source;\n-#else\n-  void GC_add_to_black_list_stack(p)\n-#endif\n-word p;\n-{\n-    register int index = PHT_HASH(p);\n-        \n-    if (HDR(p) == 0 || get_pht_entry_from_index(GC_old_stack_bl, index)) {\n-#   \tifdef PRINT_BLACK_LIST\n-\t    if (!get_pht_entry_from_index(GC_incomplete_stack_bl, index)) {\n-\t    \t  GC_err_printf2(\n-\t\t\t\"Black listing (stack) 0x%lx referenced from 0x%lx \",\n-\t    \t        (unsigned long)p, (unsigned long)source);\n-\t\t  GC_print_source_ptr(source);\n-\t\t  GC_err_puts(\"\\n\");\n-\t    }\n-#       endif\n-\tset_pht_entry_from_index(GC_incomplete_stack_bl, index);\n-    }\n-}\n-\n-/*\n- * Is the block starting at h of size len bytes black listed?   If so,\n- * return the address of the next plausible r such that (r, len) might not\n- * be black listed.  (R may not actually be in the heap.  We guarantee only\n- * that every smaller value of r after h is also black listed.)\n- * If (h,len) is not black listed, return 0.\n- * Knows about the structure of the black list hash tables.\n- */\n-struct hblk * GC_is_black_listed(h, len)\n-struct hblk * h;\n-word len;\n-{\n-    register int index = PHT_HASH((word)h);\n-    register word i;\n-    word nblocks = divHBLKSZ(len);\n-\n-    if (!GC_all_interior_pointers) {\n-      if (get_pht_entry_from_index(GC_old_normal_bl, index)\n-          || get_pht_entry_from_index(GC_incomplete_normal_bl, index)) {\n-        return(h+1);\n-      }\n-    }\n-    \n-    for (i = 0; ; ) {\n-        if (GC_old_stack_bl[divWORDSZ(index)] == 0\n-            && GC_incomplete_stack_bl[divWORDSZ(index)] == 0) {\n-            /* An easy case */\n-            i += WORDSZ - modWORDSZ(index);\n-        } else {\n-          if (get_pht_entry_from_index(GC_old_stack_bl, index)\n-              || get_pht_entry_from_index(GC_incomplete_stack_bl, index)) {\n-            return(h+i+1);\n-          }\n-          i++;\n-        }\n-        if (i >= nblocks) break;\n-        index = PHT_HASH((word)(h+i));\n-    }\n-    return(0);\n-}\n-\n-\n-/* Return the number of blacklisted blocks in a given range.\t*/\n-/* Used only for statistical purposes.\t\t\t\t*/\n-/* Looks only at the GC_incomplete_stack_bl.\t\t\t*/\n-word GC_number_stack_black_listed(start, endp1)\n-struct hblk *start, *endp1;\n-{\n-    register struct hblk * h;\n-    word result = 0;\n-    \n-    for (h = start; h < endp1; h++) {\n-        register int index = PHT_HASH((word)h);\n-        \n-        if (get_pht_entry_from_index(GC_old_stack_bl, index)) result++;\n-    }\n-    return(result);\n-}\n-\n-\n-/* Return the total number of (stack) black-listed bytes. */\n-static word total_stack_black_listed()\n-{\n-    register unsigned i;\n-    word total = 0;\n-    \n-    for (i = 0; i < GC_n_heap_sects; i++) {\n-    \tstruct hblk * start = (struct hblk *) GC_heap_sects[i].hs_start;\n-    \tword len = (word) GC_heap_sects[i].hs_bytes;\n-    \tstruct hblk * endp1 = start + len/HBLKSIZE;\n-    \t\n-    \ttotal += GC_number_stack_black_listed(start, endp1);\n-    }\n-    return(total * HBLKSIZE);\n-}\n-"}, {"sha": "a8793f0b728193b52f202270c5dadf7f4c6d811c", "filename": "boehm-gc/callprocs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fcallprocs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fcallprocs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcallprocs?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,4 +0,0 @@\n-#!/bin/sh\n-GC_DEBUG=1\n-export GC_DEBUG\n-$* 2>&1 | awk '{print \"0x3e=c\\\"\"$0\"\\\"\"};/^\\t##PC##=/ {if ($2 != 0) {print $2\"?i\"}}' | adb $1 | sed \"s/^\t\t>/>/\""}, {"sha": "57a6ebc2160f5ad4a9c726c8a9ccf0eb17cc9af0", "filename": "boehm-gc/checksums.c", "status": "removed", "additions": 0, "deletions": 199, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fchecksums.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fchecksums.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fchecksums.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,199 +0,0 @@\n-/*\n- * Copyright (c) 1992-1994 by Xerox Corporation.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n-/* Boehm, March 29, 1995 12:51 pm PST */\n-# ifdef CHECKSUMS\n-\n-# include \"private/gc_priv.h\"\n-\n-/* This is debugging code intended to verify the results of dirty bit\t*/\n-/* computations. Works only in a single threaded environment.\t\t*/\n-/* We assume that stubborn objects are changed only when they are \t*/\n-/* enabled for writing.  (Certain kinds of writing are actually\t\t*/\n-/* safe under other conditions.)\t\t\t\t\t*/\n-# define NSUMS 10000\n-\n-# define OFFSET 0x10000\n-\n-typedef struct {\n-\tGC_bool new_valid;\n-\tword old_sum;\n-\tword new_sum;\n-\tstruct hblk * block;\t/* Block to which this refers + OFFSET  */\n-\t\t\t\t/* to hide it from collector.\t\t*/\n-} page_entry;\n-\n-page_entry GC_sums [NSUMS];\n-\n-word GC_checksum(h)\n-struct hblk *h;\n-{\n-    register word *p = (word *)h;\n-    register word *lim = (word *)(h+1);\n-    register word result = 0;\n-    \n-    while (p < lim) {\n-        result += *p++;\n-    }\n-    return(result | 0x80000000 /* doesn't look like pointer */);\n-}\n-\n-# ifdef STUBBORN_ALLOC\n-/* Check whether a stubborn object from the given block appears on\t*/\n-/* the appropriate free list.\t\t\t\t\t\t*/\n-GC_bool GC_on_free_list(h)\n-struct hblk *h;\n-{\n-    register hdr * hhdr = HDR(h);\n-    register int sz = hhdr -> hb_sz;\n-    ptr_t p;\n-    \n-    if (sz > MAXOBJSZ) return(FALSE);\n-    for (p = GC_sobjfreelist[sz]; p != 0; p = obj_link(p)) {\n-        if (HBLKPTR(p) == h) return(TRUE);\n-    }\n-    return(FALSE);\n-}\n-# endif\n- \n-int GC_n_dirty_errors;\n-int GC_n_changed_errors;\n-int GC_n_clean;\n-int GC_n_dirty;\n-\n-void GC_update_check_page(h, index)\n-struct hblk *h;\n-int index;\n-{\n-    page_entry *pe = GC_sums + index;\n-    register hdr * hhdr = HDR(h);\n-    struct hblk *b;\n-    \n-    if (pe -> block != 0 && pe -> block != h + OFFSET) ABORT(\"goofed\");\n-    pe -> old_sum = pe -> new_sum;\n-    pe -> new_sum = GC_checksum(h);\n-#   if !defined(MSWIN32) && !defined(MSWINCE)\n-        if (pe -> new_sum != 0x80000000 && !GC_page_was_ever_dirty(h)) {\n-            GC_printf1(\"GC_page_was_ever_dirty(0x%lx) is wrong\\n\",\n-        \t       (unsigned long)h);\n-        }\n-#   endif\n-    if (GC_page_was_dirty(h)) {\n-    \tGC_n_dirty++;\n-    } else {\n-    \tGC_n_clean++;\n-    }\n-    b = h;\n-    while (IS_FORWARDING_ADDR_OR_NIL(hhdr) && hhdr != 0) {\n-\tb -= (word)hhdr;\n-\thhdr = HDR(b);\n-    }\n-    if (pe -> new_valid\n-\t&& hhdr != 0 && hhdr -> hb_descr != 0 /* may contain pointers */\n-\t&& pe -> old_sum != pe -> new_sum) {\n-    \tif (!GC_page_was_dirty(h) || !GC_page_was_ever_dirty(h)) {\n-    \t    /* Set breakpoint here */GC_n_dirty_errors++;\n-    \t}\n-#\tifdef STUBBORN_ALLOC\n-    \t  if ( hhdr -> hb_map != GC_invalid_map\n-    \t    && hhdr -> hb_obj_kind == STUBBORN\n-    \t    && !GC_page_was_changed(h)\n-    \t    && !GC_on_free_list(h)) {\n-    \t    /* if GC_on_free_list(h) then reclaim may have touched it\t*/\n-    \t    /* without any allocations taking place.\t\t\t*/\n-    \t    /* Set breakpoint here */GC_n_changed_errors++;\n-    \t  }\n-#\tendif\n-    }\n-    pe -> new_valid = TRUE;\n-    pe -> block = h + OFFSET;\n-}\n-\n-word GC_bytes_in_used_blocks;\n-\n-void GC_add_block(h, dummy)\n-struct hblk *h;\n-word dummy;\n-{\n-   register hdr * hhdr = HDR(h);\n-   register bytes = WORDS_TO_BYTES(hhdr -> hb_sz);\n-   \n-   bytes += HBLKSIZE-1;\n-   bytes &= ~(HBLKSIZE-1);\n-   GC_bytes_in_used_blocks += bytes;\n-}\n-\n-void GC_check_blocks()\n-{\n-    word bytes_in_free_blocks = GC_large_free_bytes;\n-    \n-    GC_bytes_in_used_blocks = 0;\n-    GC_apply_to_all_blocks(GC_add_block, (word)0);\n-    GC_printf2(\"GC_bytes_in_used_blocks = %ld, bytes_in_free_blocks = %ld \",\n-    \t\tGC_bytes_in_used_blocks, bytes_in_free_blocks);\n-    GC_printf1(\"GC_heapsize = %ld\\n\", GC_heapsize);\n-    if (GC_bytes_in_used_blocks + bytes_in_free_blocks != GC_heapsize) {\n-    \tGC_printf0(\"LOST SOME BLOCKS!!\\n\");\n-    }\n-}\n-\n-/* Should be called immediately after GC_read_dirty and GC_read_changed. */\n-void GC_check_dirty()\n-{\n-    register int index;\n-    register unsigned i;\n-    register struct hblk *h;\n-    register ptr_t start;\n-    \n-    GC_check_blocks();\n-    \n-    GC_n_dirty_errors = 0;\n-    GC_n_changed_errors = 0;\n-    GC_n_clean = 0;\n-    GC_n_dirty = 0;\n-    \n-    index = 0;\n-    for (i = 0; i < GC_n_heap_sects; i++) {\n-    \tstart = GC_heap_sects[i].hs_start;\n-        for (h = (struct hblk *)start;\n-             h < (struct hblk *)(start + GC_heap_sects[i].hs_bytes);\n-             h++) {\n-             GC_update_check_page(h, index);\n-             index++;\n-             if (index >= NSUMS) goto out;\n-        }\n-    }\n-out:\n-    GC_printf2(\"Checked %lu clean and %lu dirty pages\\n\",\n-    \t      (unsigned long) GC_n_clean, (unsigned long) GC_n_dirty);\n-    if (GC_n_dirty_errors > 0) {\n-        GC_printf1(\"Found %lu dirty bit errors\\n\",\n-        \t   (unsigned long)GC_n_dirty_errors);\n-    }\n-    if (GC_n_changed_errors > 0) {\n-    \tGC_printf1(\"Found %lu changed bit errors\\n\",\n-        \t   (unsigned long)GC_n_changed_errors);\n-\tGC_printf0(\"These may be benign (provoked by nonpointer changes)\\n\");\n-#\tifdef THREADS\n-\t    GC_printf0(\n-\t    \"Also expect 1 per thread currently allocating a stubborn obj.\\n\");\n-#\tendif\n-    }\n-}\n-\n-# else\n-\n-extern int GC_quiet;\n-\t/* ANSI C doesn't allow translation units to be empty.\t*/\n-\t/* So we guarantee this one is nonempty.\t\t*/\n-\n-# endif /* CHECKSUMS */"}, {"sha": "b2ae9e8401bd194546b831ea0ab3241a7de9654d", "filename": "boehm-gc/configure", "status": "removed", "additions": 0, "deletions": 17997, "changes": 17997, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "1ccfe37e9d8622388d725a87bade72900b3b3b42", "filename": "boehm-gc/configure.ac", "status": "removed", "additions": 0, "deletions": 526, "changes": 526, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure.ac?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,526 +0,0 @@\n-# Copyright (c) 1999, 2000, 2001, 2002, 2003, 2006, 2010, 2011 by Red Hat, Inc.\n-# All rights reserved.\n-# Copyright 2004 Nathanael Nerode\n-# \n-# THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n-# OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n-# \n-# Permission is hereby granted to use or copy this program\n-# for any purpose,  provided the above notices are retained on all copies.\n-# Permission to modify the code and to distribute modified code is granted,\n-# provided the above notices are retained, and a notice that the code was\n-# modified is included with the above copyright notice.\n-#\n-# Original author: Tom Tromey\n-# Modified by Nathanael Nerode\n-\n-dnl Process this file with autoconf to produce configure.\n-\n-AC_PREREQ(2.64)\n-AC_INIT\n-AC_CONFIG_SRCDIR(gcj_mlc.c)\n-# This works around the fact that libtool configuration may change LD\n-# for this particular configuration, but some shells, instead of\n-# keeping the changes in LD private, export them just because LD is\n-# exported.\n-ORIGINAL_LD_FOR_MULTILIBS=$LD\n-\n-AM_ENABLE_MULTILIB(, ..)\n-\n-AC_CANONICAL_HOST\n-AC_CANONICAL_TARGET\n-\n-# Get the 'noncanonical' system names.\n-ACX_NONCANONICAL_TARGET\n-\n-# This works around an automake problem.\n-mkinstalldirs=\"`cd $ac_aux_dir && ${PWDCMD-pwd}`/mkinstalldirs\"\n-AC_SUBST(mkinstalldirs)\n-\n-AM_INIT_AUTOMAKE(gc, 6.6, no-define)\n-\n-# The autoconf 2.5x version of the no-executables hack.\n-GCC_NO_EXECUTABLES\n-\n-# Yak.  We must force CC and CXX to /not/ be precious variables; otherwise\n-# the wrong, non-multilib-adjusted value will be used in multilibs.\n-# As a side effect, we have to subst CFLAGS and CXXFLAGS ourselves.\n-\n-m4_rename([_AC_ARG_VAR_PRECIOUS],[real_PRECIOUS])\n-m4_define([_AC_ARG_VAR_PRECIOUS],[])\n-AC_PROG_CC\n-AC_PROG_CXX\n-m4_rename_force([real_PRECIOUS],[_AC_ARG_VAR_PRECIOUS])\n-\n-AM_PROG_CC_C_O\n-\n-AC_SUBST(CFLAGS)\n-AC_SUBST(CXXFLAGS)\n-\n-# Newer automakes demand CCAS and CCASFLAGS.\n-: ${CCAS='$(CC)'}\n-: ${CCASFLAGS='$(CFLAGS)'}\n-AC_SUBST(CCAS)\n-AC_SUBST(CCASFLAGS)\n-\n-AC_CHECK_TOOL(AS, as)\n-AC_CHECK_TOOL(AR, ar)\n-AC_CHECK_TOOL(RANLIB, ranlib, :)\n-\n-AC_PROG_INSTALL\n-\n-AM_MAINTAINER_MODE\n-\n-. ${srcdir}/configure.host\n-\n-case ${gc_basedir} in\n-/* | [A-Za-z]:[/\\\\]*) gc_flagbasedir=${gc_basedir} ;;\n-*) gc_flagbasedir='$(top_builddir)/'${gc_basedir} ;;\n-esac\n-\n-gc_cflags=\"${gc_cflags} -Iinclude -I\"'$(top_builddir)'\"/./targ-include -I${gc_flagbasedir}/libc/include\"\n-case \"${host}\" in\n-  *-*-cygwin32*)\n-    gc_cflags=\"${gc_cflags} -I${gc_flagbasedir}/../winsup/include\"\n-    ;;\n-esac\n-\n-dnl Add for mingw targets GC_BUILD option\n-case \"${host}\" in\n-  *-*-mingw*)\n-    gc_cflags=\"${gc_cflags} -DGC_BUILD=1\"\n-    ;;\n-esac\n-\n-dnl gc_cflags=\"${gc_cflags} -fno-builtin\"\n-\n-GC_CFLAGS=${gc_cflags}\n-AC_SUBST(GC_CFLAGS)\n-\n-AC_PROG_LIBTOOL\n-\n-dnl We use these options to decide which functions to include.\n-AC_ARG_WITH(target-subdir,\n-[  --with-target-subdir=SUBDIR\n-                          configuring with a cross compiler])\n-AC_ARG_WITH(cross-host,\n-[  --with-cross-host=HOST  configuring with a cross compiler])\n-\n-AC_MSG_CHECKING([for thread model used by GCC])\n-THREADS=`$CC -v 2>&1 | sed -n 's/^Thread model: //p'`\n-if test -z \"$THREADS\"; then\n-   THREADS=no\n-fi\n-AC_MSG_RESULT([$THREADS])\n-\n-AC_ARG_ENABLE(parallel-mark,\n-[  --enable-parallel-mark\tparallelize marking and free list construction],\n-   [case \"$THREADS\" in\n-      no | none | single)\n-\tAC_MSG_ERROR([Parallel mark requires --enable-threads=x spec])\n-\t;;\n-    esac]\n-)\n-\n-AM_CPPFLAGS=\"-I`cd $srcdir && ${PWDCMD-pwd}`/include\"\n-THREADCFLAGS=\n-THREADLIBS=\n-case \"$THREADS\" in\n- no | none | single)\n-    THREADS=none\n-    ;;\n- posix | pthreads)\n-    THREADS=posix\n-    THREADLIBS=-lpthread\n-    case \"$host\" in\n-     x86-*-linux* | ia64-*-linux* | i586-*-linux* | i686-*-linux* | x86_64-*-linux* | alpha-*-linux*)\n-\tAC_DEFINE(GC_LINUX_THREADS,1,[support for Xavier Leroy's Linux threads])\n-\tAC_DEFINE(_REENTRANT,1,[Use reentrant code])\n-        if test \"${enable_parallel_mark}\" = yes; then\n-\t  AC_DEFINE(PARALLEL_MARK,1,[allow the marker to run in multiple threads])\n-\tfi\n-\tAC_DEFINE(THREAD_LOCAL_ALLOC,1,[define GC_local_malloc() & GC_local_malloc_atomic()])\n-\t;;\n-     *-*-linux*)\n-\tAC_DEFINE(GC_LINUX_THREADS,1)\n-\tAC_DEFINE(_REENTRANT,1)\n-\t;;\n-     *-*-aix*)\n-\tAC_DEFINE(GC_AIX_THREADS,1,[support AIX threads])\n-\tAC_DEFINE(_REENTRANT,1)\n-\t;;\n-     *-*-hpux11*)\n-\tAC_MSG_WARN(\"Only HP-UX 11 POSIX threads are supported.\")\n-\tAC_DEFINE(GC_HPUX_THREADS,1,[enables support for HP/UX 11 pthreads])\n-\tAC_DEFINE(_POSIX_C_SOURCE,199506L,[POSIX version of C Source])\n-\tif test \"${enable_parallel_mark}\" = yes; then\n-\t  AC_DEFINE(PARALLEL_MARK,1)\n-\tfi\n-\tAC_DEFINE(THREAD_LOCAL_ALLOC,1)\n-\tTHREADLIBS=\"-lpthread -lrt\"\n-\t# HPUX needs REENTRANT for the _r calls.\n-\tAC_DEFINE(_REENTRANT, 1, [Required define if using POSIX threads])\n-\t;;\n-     *-*-hpux10*)\n-\tAC_MSG_WARN(\"Only HP-UX 11 POSIX threads are supported.\")\n-\t;;\n-     *-*-kfreebsd*-gnu)\n-       AC_DEFINE(GC_FREEBSD_THREADS)\n-       THREADCFLAGS=-pthread\n-       THREADLIBS=-pthread\n-       AC_DEFINE(_REENTRANT)\n-         if test \"${enable_parallel_mark}\" = yes; then\n-         AC_DEFINE(PARALLEL_MARK)\n-       fi\n-       AC_DEFINE(THREAD_LOCAL_ALLOC)\n-       AC_DEFINE(USE_COMPILER_TLS, 1,[use tls for boehm])\n-       ;;\n-     *-*-gnu*)\n-\tAC_DEFINE(GC_GNU_THREADS,1,[support GNU threads])\n-\tAC_DEFINE(_REENTRANT)\n-\tAC_DEFINE(THREAD_LOCAL_ALLOC)\n-\t;;\n-     *-*-freebsd*)\n-\tAC_MSG_WARN(\"FreeBSD does not yet fully support threads with Boehm GC.\")\n-\tAC_DEFINE(GC_FREEBSD_THREADS,1,[support FreeBSD threads])\n-\tTHREADCFLAGS=-pthread\n-\tTHREADLIBS=-pthread\n-      \t;;\n-     *-*-solaris2.8*)\n-\tAC_DEFINE(GC_SOLARIS_PTHREADS,1,[support for Solaris pthreads])\n-\t# Need to use alternate thread library, otherwise gctest hangs\n-\t# on Solaris 8.\n-\tmulti_os_directory=`$CC -print-multi-os-directory`\n-\tTHREADLIBS=\"-L/usr/lib/lwp/$multi_os_directory \\\n-\t\t    -R/usr/lib/lwp/$multi_os_directory -lpthread -lthread -lrt\"\n-\t;;\n-     *-*-solaris2*)\n-\tAC_DEFINE(GC_SOLARIS_PTHREADS,1,[support for Solaris pthreads])\n-\t# The alternate thread library was only introduced in Solaris 8 and\n-\t# became the default in Solaris 9, so no need for the special code\n-\t# above otherwise.\n-\t# nanosleep, sched_yield, and sem_* only live in librt before\n-\t# Solaris 11.\n-\tTHREADLIBS=\"-lpthread -lrt\"\n-\t;;\n-     *-*-irix*)\n-\tAC_DEFINE(GC_IRIX_THREADS,1,[support for Irix pthreads])\n-\t;;\n-     *-*-cygwin*)\n-\tAC_DEFINE(GC_WIN32_THREADS,1,[support for win32 threads])\n-\t;;\n-     *-*-darwin*)\n-\tAC_DEFINE(GC_DARWIN_THREADS,1,[support for Mac OS X pthreads])\n-\tAC_DEFINE(THREAD_LOCAL_ALLOC,1)\n-\tif test \"${enable_parallel_mark}\" = yes; then\n-\t  AC_DEFINE(PARALLEL_MARK,1)\n-\tfi\n-\t;;\n-     *-*-osf*)\n-\tAC_DEFINE(GC_OSF1_THREADS,1,[support for Tru64 pthreads])\n-        if test \"${enable_parallel_mark}\" = yes; then\n-\t  AC_DEFINE(PARALLEL_MARK,1)\n-\t  AC_DEFINE(THREAD_LOCAL_ALLOC,1)\n-\t  # May want to enable it in other cases, too.\n-\t  # Measurements havent yet been done.\n-\tfi\n-\tTHREADCFLAGS=-pthread\n-\tTHREADLIBS=\"-lpthread -lrt\"\n-\t;;\n-    esac\n-    ;;\n- win32)\n-    AC_DEFINE(GC_WIN32_THREADS,1)\n-    dnl Old wine getenv may not return NULL for missing entry.\n-    dnl Define EMPTY_GETENV_RESULTS here to work around the bug.\n-    ;;\n- aix)\n-    THREADS=posix\n-    THREADLIBS=-lpthread\n-    AC_DEFINE(GC_AIX_THREADS,1)\n-    AC_DEFINE(_REENTRANT,1)\n-    ;;\n- dce | vxworks)\n-    AC_MSG_ERROR(thread package $THREADS not yet supported)\n-    ;;\n- *)\n-    AC_MSG_ERROR($THREADS is an unknown thread package)\n-    ;;\n-esac\n-AC_SUBST(THREADCFLAGS)\n-AC_SUBST(THREADLIBS)\n-\n-case \"$host\" in\n-   powerpc-*-darwin*)\n-      powerpc_darwin=true\n-      ;;\n-esac\n-AM_CONDITIONAL(POWERPC_DARWIN,test x$powerpc_darwin = xtrue)\n-\n-# Darwin needs a few extra special tests to deal with variation in the\n-# system headers.\n-case \"$host\" in\n-  powerpc*-*-darwin*)\n-    AC_CHECK_MEMBER(ppc_thread_state_t.r0,\n-      AC_DEFINE(HAS_PPC_THREAD_STATE_R0,1,\n-\t[ppc_thread_state_t has field r0]),,\n-      [#include <mach/thread_status.h>])\n-    AC_CHECK_MEMBER(ppc_thread_state_t.__r0,\n-      AC_DEFINE(HAS_PPC_THREAD_STATE___R0,1,dnl\n-\t[ppc_thread_state_t has field __r0]),,\n-      [#include <mach/thread_status.h>])\n-    AC_CHECK_MEMBER(ppc_thread_state64_t.r0,\n-      AC_DEFINE(HAS_PPC_THREAD_STATE64_R0,1,dnl\n-\t[ppc_thread_state64_t has field r0]),,\n-      [#include <mach/thread_status.h>])\n-    AC_CHECK_MEMBER(ppc_thread_state64_t.__r0,\n-      AC_DEFINE(HAS_PPC_THREAD_STATE64___R0,1,dnl\n-\t[ppc_thread_state64_t has field __r0]),,\n-      [#include <mach/thread_status.h>])\n-    ;;\n-  i?86*-*-darwin*)\n-    AC_CHECK_MEMBER(x86_thread_state32_t.eax,\n-      AC_DEFINE(HAS_X86_THREAD_STATE32_EAX,1,dnl\n-\t[x86_thread_state32_t has field eax]),,\n-      [#include <sys/cdefs.h>\n-      #include <mach/thread_status.h>])\n-    AC_CHECK_MEMBER(x86_thread_state32_t.__eax,\n-      AC_DEFINE(HAS_X86_THREAD_STATE32___EAX,1,dnl\n-\t[x86_thread_state32_t has field __eax]),,\n-      [#include <sys/cdefs.h>\n-      #include <mach/thread_status.h>])\n-    ;;\n-  x86_64-*-darwin*)\n-    AC_CHECK_MEMBER(x86_thread_state64_t.rax,\n-      AC_DEFINE(HAS_X86_THREAD_STATE64_RAX,1,dnl\n-\t[x86_thread_state64_t has field rax]),,\n-      [#include <sys/cdefs.h>\n-      #include <mach/thread_status.h>])\n-    AC_CHECK_MEMBER(x86_thread_state64_t.__rax,\n-      AC_DEFINE(HAS_X86_THREAD_STATE64___RAX,1,dnl\n-\t[x86_thread_state64_t has field __rax]),,\n-      [#include <sys/cdefs.h>\n-      #include <mach/thread_status.h>])\n-     ;;\n-  *) ;;\n-esac\n-\n-case \"$host\" in\n-  # While IRIX 6 has libdl for the O32 and N32 ABIs, it's missing for N64\n-  # and unnecessary everywhere.\n-  mips-sgi-irix6*) ;;\n-  # We never want libdl on darwin. It is a fake libdl that just ends up making\n-  # dyld calls anyway\n-  *-*-darwin*) ;;\n-  *)\n-    AC_CHECK_LIB(dl, dlopen, EXTRA_TEST_LIBS=\"$EXTRA_TEST_LIBS -ldl\")\n-    ;;\n-esac\n-\n-# extra LD Flags which are required for targets\n-case \"${host}\" in\n-  *-*-darwin*)\n-    extra_ldflags_libgc=-Wl,-single_module\n-    ;;\n-esac\n-AC_SUBST(extra_ldflags_libgc)\n-\n-AC_SUBST(EXTRA_TEST_LIBS)\n-\n-target_all=libgcjgc.la\n-AC_SUBST(target_all)\n-\n-dnl If the target is an eCos system, use the appropriate eCos\n-dnl I/O routines.\n-dnl FIXME: this should not be a local option but a global target\n-dnl system; at present there is no eCos target.\n-TARGET_ECOS=\"no\"\n-AC_ARG_WITH(ecos,\n-[  --with-ecos             enable runtime eCos target support],\n-TARGET_ECOS=\"$with_ecos\"\n-)\n-\n-addobjs=\n-addlibs=\n-addincludes=\n-addtests=\n-case \"$TARGET_ECOS\" in\n-   no)\n-      ;;\n-   *)\n-      AC_DEFINE(ECOS,1,[Target is ECOS])\n-      AM_CPPFLAGS=\"${AM_CPPFLAGS} -I${TARGET_ECOS}/include\"\n-      addobjs=\"$addobjs ecos.lo\"\n-      ;;\n-esac\n-\n-if test \"${enable_cplusplus}\" = yes; then\n-      addincludes=\"$addincludes include/gc_cpp.h include/gc_allocator.h\"\n-      addtests=\"$addtests test_cpp\"\n-fi\n-\n-AM_CONDITIONAL(CPLUSPLUS, test \"${enable_cplusplus}\" = yes)\n-\n-AC_SUBST(CXX)\n-\n-AC_SUBST(AM_CPPFLAGS)\n-\n-# Configuration of shared libraries\n-#\n-AC_MSG_CHECKING(whether to build shared libraries)\n-AC_ENABLE_SHARED\n-\n-case \"$host\" in\n- alpha-*-openbsd*)\n-     enable_shared=no\n-     AC_MSG_RESULT(no)\n-     ;;\n- *)\n-     AC_MSG_RESULT(yes)\n-     ;;\n-esac\n-\n-# Checks for pthreads functions\n-#\n-oldLIBS=\"$LIBS\"\n-LIBS=\"$LIBS $THREADLIBS\"\n-AC_CHECK_FUNCS([pthread_getattr_np])\n-AC_CHECK_FUNCS([pthread_get_stackaddr_np])\n-LIBS=\"$oldLIBS\"\n-\n-# Configuration of machine-dependent code\n-#\n-# Set NO_EXECUTE_PERMISSION by default because gcj already uses\n-# ffi_closure_{alloc,free} which takes care of allocating trampolines\n-# in executable memory.\n-#\n-AC_MSG_CHECKING(which machine-dependent code should be used)\n-machdep=\n-case \"$host\" in\n- alpha*-*-openbsd*)\n-    machdep=\"alpha_mach_dep.lo\"\n-    if test x\"${ac_cv_lib_dl_dlopen}\" != xyes ; then\n-       AC_MSG_WARN(OpenBSD/Alpha without dlopen(). Shared library support is disabled)\n-    fi\n-    ;;\n- alpha*-*-linux*)\n-    machdep=\"alpha_mach_dep.lo\"\n-    ;;\n- i?86-*-solaris2.[[89]] | i?86-*-solaris2.1? | x86_64-*-solaris2.1?)\n-    AC_DEFINE(SOLARIS25_PROC_VDB_BUG_FIXED,1,[PROC_VDB in Solaris 2.5 gives wrong values for dirty bits])\n-    ;;\n- mipstx39-*-elf*)\n-    machdep=\"mips_ultrix_mach_dep.lo\"\n-    AC_DEFINE(STACKBASE, __stackbase,[No description])\n-    AC_DEFINE(DATASTART_IS_ETEXT,1,[No description])\n-    ;;\n- mips-dec-ultrix*)\n-    machdep=\"mips_ultrix_mach-dep.lo\"\n-    ;;\n- mips-nec-sysv*|mips-unknown-sysv*)\n-    ;;\n- mips*-*-linux*)\n-    ;;\n- mips-*-*)\n-    machdep=\"mips_sgi_mach_dep.lo\"\n-    ;;\n- sparc-*-netbsd*)\n-    machdep=\"sparc_netbsd_mach_dep.lo\"\n-    ;;\n- sparc-sun-solaris2.3)\n-    machdep=\"sparc_mach_dep.lo\"\n-    AC_DEFINE(SUNOS53_SHARED_LIB,1,[Avoid Solaris 5.3 dynamic library bug])\n-    ;;\n- sparc*-sun-solaris2.*)\n-    machdep=\"sparc_mach_dep.lo\"\n-    ;;\n- ia64-*-*)\n-    machdep=\"mach_dep.lo ia64_save_regs_in_stack.lo\"\n-    ;;\n-esac\n-AC_DEFINE(NO_EXECUTE_PERMISSION,1,[cause some or all of the heap to not have execute permission])\n-if test x\"$machdep\" = x; then\n-AC_MSG_RESULT($machdep)\n-   machdep=\"mach_dep.lo\"\n-fi\n-addobjs=\"$addobjs $machdep\"\n-AC_SUBST(addobjs)\n-AC_SUBST(addincludes)\n-AC_SUBST(addlibs)\n-AC_SUBST(addtests)\n-\n-dnl As of 4.13a2, the collector will not properly work on Solaris when\n-dnl built with gcc and -O.  So we remove -O in the appropriate case.\n-dnl Not needed anymore on Solaris.\n-AC_MSG_CHECKING([whether GCC optimization should be disabled])\n-O0_CFLAGS=\n-case \"$host\" in\n- *aix*) test \"$GCC\" = yes && O0_CFLAGS=-O0 ;;\n- *) ;;\n-esac\n-if test x\"$O0_CFLAGS\" != x; then\n-   AC_MSG_RESULT(yes)\n-else\n-   AC_MSG_RESULT(no)\n-fi\n-AC_SUBST([O0_CFLAGS])\n-\n-dnl Include defines that have become de facto standard.\n-dnl ALL_INTERIOR_POINTERS can be overridden in startup code.\n-AC_DEFINE(SILENT,1,[disables statistics printing])\n-AC_DEFINE(NO_SIGNALS,1,[does not disable signals])\n-AC_DEFINE(ALL_INTERIOR_POINTERS,1,[allows all pointers to the interior of objects to be recognized])\n-\n-dnl By default, make the library as general as possible.\n-AC_DEFINE(JAVA_FINALIZATION,1,[make it somewhat safer to finalize objects out of order])\n-AC_DEFINE(GC_GCJ_SUPPORT,1,[include support for gcj])\n-AC_DEFINE(ATOMIC_UNCOLLECTABLE,1,[include code for GC_malloc_atomic_uncollectable])\n-\n-AC_ARG_ENABLE(gc-debug,\n-[  --enable-gc-debug\tinclude full support for pointer backtracing etc.],\n-[ if test \"$enable_gc_debug\" = \"yes\"; then\n-    AC_MSG_WARN(\"Must define GC_DEBUG and use debug alloc. in clients.\")\n-    AC_DEFINE(KEEP_BACK_PTRS,1,[Add code to save back pointers])\n-    AC_DEFINE(DBG_HDRS_ALL,1,[Make sure that all objects have debug headers])\n-    case $host in\n-      ia64-*-linux* )\n-\tAC_DEFINE(MAKE_BACK_GRAPH,1,[Enable GC_PRINT_BACK_HEIGHT environment variable])\n-      ;;\n-      x86-*-linux* | i586-*-linux* | i686-*-linux* | x86_64-*-linux* )\n-\tAC_DEFINE(MAKE_BACK_GRAPH,1)\n-\tAC_MSG_WARN(\"Client must not use -fomit-frame-pointer.\")\n-\tAC_DEFINE(SAVE_CALL_COUNT, 8, [number of call frames saved with objects allocated through the debugging interface])\n-      ;;\n-    esac \n-  fi])\n-\n-if test \"${gc_use_mmap}\" = \"yes\"; then\n-  AC_DEFINE(USE_MMAP, 1, [use MMAP instead of sbrk to get new memory])\n-fi\n-\n-if test -n \"$with_cross_host\" &&\n-   test x\"$with_cross_host\" != x\"no\"; then\n-  toolexecdir='$(exec_prefix)/$(target_noncanonical)'\n-  toolexeclibdir='$(toolexecdir)/lib'\n-else\n-  toolexecdir='$(libdir)/gcc-lib/$(target_noncanonical)'\n-  toolexeclibdir='$(libdir)'\n-fi\n-multi_os_directory=`$CC -print-multi-os-directory`\n-case $multi_os_directory in\n-  .) ;; # Avoid trailing /.\n-  *) toolexeclibdir=$toolexeclibdir/$multi_os_directory ;;\n-esac\n-AC_SUBST(toolexecdir)\n-AC_SUBST(toolexeclibdir)\n-\n-if test \"${multilib}\" = \"yes\"; then\n-  multilib_arg=\"--enable-multilib\"\n-else\n-  multilib_arg=\n-fi\n-\n-AC_CONFIG_HEADERS([include/gc_config.h include/gc_ext_config.h])\n-\n-AC_CONFIG_FILES(Makefile include/Makefile testsuite/Makefile threads.mk)\n-AC_OUTPUT"}, {"sha": "229a03877b9681c7066c96b2d7bb44d0d24b46d8", "filename": "boehm-gc/configure.host", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fconfigure.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fconfigure.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure.host?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,70 +0,0 @@\n-# configure.host\n-\n-# This shell script handles all host based configuration for the garbage\n-# collector.\n-# It sets various shell variables based on the the host and the\n-# configuration options.  You can modify this shell script without\n-# needing to rerun autoconf.\n-\n-# This shell script should be invoked as\n-#   . configure.host\n-# If it encounters an error, it will exit with a message.\n-\n-# It uses the following shell variables:\n-#   host\t\tThe configuration host\n-#   host_cpu\t\tThe configuration host CPU\n-#   target_optspace\t--enable-target-optspace (\"yes\", \"no\", \"\")\n-#   GCC                 should be \"yes\" if using gcc\n-\n-# It sets the following shell variables:\n-#   gc_cflags\tSpecial CFLAGS to use when building\n-#   gc_use_mmap  Set to \"yes\" on platforms where mmap should be used instead\n-#\t\t of sbrk. This will define USE_MMAP.\n-\n-gc_cflags=\"\"\n-gc_use_mmap=\n-\n-# We should set -fexceptions if we are using gcc and might be used\n-# inside something like gcj.  This is the zeroth approximation:\n-if test :\"$GCC\": = :yes: ; then\n-    gc_cflags=\"${gc_cflags} -fexceptions\"\n-else\n-    case \"$host\" in \n-        hppa*-*-hpux* )\n-\tif test :$GCC: != :\"yes\": ; then\n-            gc_cflags=\"${gc_flags} +ESdbgasm\"\n-\tfi\n-        # :TODO: actaully we should check using Autoconf if\n-        #     the compiler supports this option.\n-        ;;\n-    esac\n-fi\n-\n-case \"${host}\" in\n-  *-linux*|*-kfreebsd-gnu*|*-gnu*)\n-    gc_use_mmap=yes\n-    ;;\n-esac\n-\n-case \"${target_optspace}:${host}\" in\n-  yes:*)\n-    gc_cflags=\"${gc_cflags} -Os\"\n-    ;;\n-  :m32r-* | :d10v-* | :d30v-*)\n-    gc_cflags=\"${gc_cflags} -Os\"\n-    ;;\n-  no:* | :*)\n-    # Nothing.\n-    ;;\n-esac\n-\n-# Set any host dependent compiler flags.\n-# THIS TABLE IS SORTED.  KEEP IT THAT WAY.\n-\n-case \"${host}\" in\n-  mips-tx39-*|mipstx39-unknown-*)\n-\tgc_cflags=\"${gc_cflags} -G 0\"\n-\t;;\n-  *)\n-\t;;\n-esac"}, {"sha": "d83f4067de76dda23893f0f9575db9f084bb6fea", "filename": "boehm-gc/cord/cordbscs.c", "status": "removed", "additions": 0, "deletions": 919, "changes": 919, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fcord%2Fcordbscs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fcord%2Fcordbscs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fcordbscs.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,919 +0,0 @@\n-/*\n- * Copyright (c) 1993-1994 by Xerox Corporation.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- *\n- * Author: Hans-J. Boehm (boehm@parc.xerox.com)\n- */\n-/* Boehm, October 3, 1994 5:19 pm PDT */\n-# include \"gc.h\"\n-# include \"cord.h\"\n-# include <stdlib.h>\n-# include <stdio.h>\n-# include <string.h>\n-\n-/* An implementation of the cord primitives.  These are the only \t*/\n-/* Functions that understand the representation.  We perform only\t*/\n-/* minimal checks on arguments to these functions.  Out of bounds\t*/\n-/* arguments to the iteration functions may result in client functions\t*/\n-/* invoked on garbage data.  In most cases, client functions should be\t*/\n-/* programmed defensively enough that this does not result in memory\t*/\n-/* smashes.\t\t\t\t\t\t\t\t*/ \n-\n-typedef void (* oom_fn)(void);\n-\n-oom_fn CORD_oom_fn = (oom_fn) 0;\n-\n-# define OUT_OF_MEMORY {  if (CORD_oom_fn != (oom_fn) 0) (*CORD_oom_fn)(); \\\n-\t\t\t  ABORT(\"Out of memory\\n\"); }\n-# define ABORT(msg) { fprintf(stderr, \"%s\\n\", msg); abort(); }\n-\n-typedef unsigned long word;\n-\n-typedef union {\n-    struct Concatenation {\n-    \tchar null;\n-\tchar header;\n-\tchar depth;\t/* concatenation nesting depth. */\n-\tunsigned char left_len;\n-\t\t\t/* Length of left child if it is sufficiently\t*/\n-\t\t\t/* short; 0 otherwise.\t\t\t\t*/\n-#\t    define MAX_LEFT_LEN 255\n-\tword len;\n-\tCORD left;\t/* length(left) > 0\t*/\n-\tCORD right;\t/* length(right) > 0\t*/\n-    } concatenation;\n-    struct Function {\n-\tchar null;\n-\tchar header;\n-\tchar depth;\t/* always 0\t*/\n-\tchar left_len;\t/* always 0\t*/\n-\tword len;\n-\tCORD_fn fn;\n-\tvoid * client_data;\n-    } function;\n-    struct Generic {\n-    \tchar null;\n-\tchar header;\n-\tchar depth;\n-\tchar left_len;\n-\tword len;\n-    } generic;\n-    char string[1];\n-} CordRep;\n-\n-# define CONCAT_HDR 1\n-\t\n-# define FN_HDR 4\n-# define SUBSTR_HDR 6\n-\t/* Substring nodes are a special case of function nodes.  \t*/\n-\t/* The client_data field is known to point to a substr_args\t*/\n-\t/* structure, and the function is either CORD_apply_access_fn \t*/\n-\t/* or CORD_index_access_fn.\t\t\t\t\t*/\n-\n-/* The following may be applied only to function and concatenation nodes: */\n-#define IS_CONCATENATION(s)  (((CordRep *)s)->generic.header == CONCAT_HDR)\n-\n-#define IS_FUNCTION(s)  ((((CordRep *)s)->generic.header & FN_HDR) != 0)\n-\n-#define IS_SUBSTR(s) (((CordRep *)s)->generic.header == SUBSTR_HDR)\n-\n-#define LEN(s) (((CordRep *)s) -> generic.len)\n-#define DEPTH(s) (((CordRep *)s) -> generic.depth)\n-#define GEN_LEN(s) (CORD_IS_STRING(s) ? strlen(s) : LEN(s))\n-\n-#define LEFT_LEN(c) ((c) -> left_len != 0? \\\n-\t\t\t\t(c) -> left_len \\\n-\t\t\t\t: (CORD_IS_STRING((c) -> left) ? \\\n-\t\t\t\t\t(c) -> len - GEN_LEN((c) -> right) \\\n-\t\t\t\t\t: LEN((c) -> left)))\n-\n-#define SHORT_LIMIT (sizeof(CordRep) - 1)\n-\t/* Cords shorter than this are C strings */\n-\n-\n-/* Dump the internal representation of x to stdout, with initial \t*/\n-/* indentation level n.\t\t\t\t\t\t\t*/\n-void CORD_dump_inner(CORD x, unsigned n)\n-{\n-    register size_t i;\n-    \n-    for (i = 0; i < (size_t)n; i++) {\n-        fputs(\"  \", stdout);\n-    }\n-    if (x == 0) {\n-      \tfputs(\"NIL\\n\", stdout);\n-    } else if (CORD_IS_STRING(x)) {\n-        for (i = 0; i <= SHORT_LIMIT; i++) {\n-            if (x[i] == '\\0') break;\n-            putchar(x[i]);\n-        }\n-        if (x[i] != '\\0') fputs(\"...\", stdout);\n-        putchar('\\n');\n-    } else if (IS_CONCATENATION(x)) {\n-        register struct Concatenation * conc =\n-        \t\t\t&(((CordRep *)x) -> concatenation);\n-        printf(\"Concatenation: %p (len: %d, depth: %d)\\n\",\n-               x, (int)(conc -> len), (int)(conc -> depth));\n-        CORD_dump_inner(conc -> left, n+1);\n-        CORD_dump_inner(conc -> right, n+1);\n-    } else /* function */{\n-        register struct Function * func =\n-        \t\t\t&(((CordRep *)x) -> function);\n-        if (IS_SUBSTR(x)) printf(\"(Substring) \");\n-        printf(\"Function: %p (len: %d): \", x, (int)(func -> len));\n-        for (i = 0; i < 20 && i < func -> len; i++) {\n-            putchar((*(func -> fn))(i, func -> client_data));\n-        }\n-        if (i < func -> len) fputs(\"...\", stdout);\n-        putchar('\\n');\n-    }\n-}\n-\n-/* Dump the internal representation of x to stdout\t*/\n-void CORD_dump(CORD x)\n-{\n-    CORD_dump_inner(x, 0);\n-    fflush(stdout);\n-}\n-\n-CORD CORD_cat_char_star(CORD x, const char * y, size_t leny)\n-{\n-    register size_t result_len;\n-    register size_t lenx;\n-    register int depth;\n-    \n-    if (x == CORD_EMPTY) return(y);\n-    if (leny == 0) return(x);\n-    if (CORD_IS_STRING(x)) {\n-        lenx = strlen(x);\n-        result_len = lenx + leny;\n-        if (result_len <= SHORT_LIMIT) {\n-            register char * result = GC_MALLOC_ATOMIC(result_len+1);\n-        \n-            if (result == 0) OUT_OF_MEMORY;\n-            memcpy(result, x, lenx);\n-            memcpy(result + lenx, y, leny);\n-            result[result_len] = '\\0';\n-            return((CORD) result);\n-        } else {\n-            depth = 1;\n-        }\n-    } else {\n-    \tregister CORD right;\n-    \tregister CORD left;\n-    \tregister char * new_right;\n-    \tregister size_t right_len;\n-    \t\n-    \tlenx = LEN(x);\n-    \t\n-        if (leny <= SHORT_LIMIT/2\n-    \t    && IS_CONCATENATION(x)\n-            && CORD_IS_STRING(right = ((CordRep *)x) -> concatenation.right)) {\n-            /* Merge y into right part of x. */\n-            if (!CORD_IS_STRING(left = ((CordRep *)x) -> concatenation.left)) {\n-            \tright_len = lenx - LEN(left);\n-            } else if (((CordRep *)x) -> concatenation.left_len != 0) {\n-                right_len = lenx - ((CordRep *)x) -> concatenation.left_len;\n-            } else {\n-            \tright_len = strlen(right);\n-            }\n-            result_len = right_len + leny;  /* length of new_right */\n-            if (result_len <= SHORT_LIMIT) {\n-            \tnew_right = GC_MALLOC_ATOMIC(result_len + 1);\n-            \tmemcpy(new_right, right, right_len);\n-            \tmemcpy(new_right + right_len, y, leny);\n-            \tnew_right[result_len] = '\\0';\n-            \ty = new_right;\n-            \tleny = result_len;\n-            \tx = left;\n-            \tlenx -= right_len;\n-            \t/* Now fall through to concatenate the two pieces: */\n-            }\n-            if (CORD_IS_STRING(x)) {\n-                depth = 1;\n-            } else {\n-                depth = DEPTH(x) + 1;\n-            }\n-        } else {\n-            depth = DEPTH(x) + 1;\n-        }\n-        result_len = lenx + leny;\n-    }\n-    {\n-      /* The general case; lenx, result_len is known: */\n-    \tregister struct Concatenation * result;\n-    \t\n-    \tresult = GC_NEW(struct Concatenation);\n-    \tif (result == 0) OUT_OF_MEMORY;\n-    \tresult->header = CONCAT_HDR;\n-    \tresult->depth = depth;\n-    \tif (lenx <= MAX_LEFT_LEN) result->left_len = lenx;\n-    \tresult->len = result_len;\n-    \tresult->left = x;\n-    \tresult->right = y;\n-    \tif (depth >= MAX_DEPTH) {\n-    \t    return(CORD_balance((CORD)result));\n-    \t} else {\n-    \t    return((CORD) result);\n-    \t}\n-    }\n-}\n-\n-\n-CORD CORD_cat(CORD x, CORD y)\n-{\n-    register size_t result_len;\n-    register int depth;\n-    register size_t lenx;\n-    \n-    if (x == CORD_EMPTY) return(y);\n-    if (y == CORD_EMPTY) return(x);\n-    if (CORD_IS_STRING(y)) {\n-        return(CORD_cat_char_star(x, y, strlen(y)));\n-    } else if (CORD_IS_STRING(x)) {\n-        lenx = strlen(x);\n-        depth = DEPTH(y) + 1;\n-    } else {\n-        register int depthy = DEPTH(y);\n-        \n-        lenx = LEN(x);\n-        depth = DEPTH(x) + 1;\n-        if (depthy >= depth) depth = depthy + 1;\n-    }\n-    result_len = lenx + LEN(y);\n-    {\n-    \tregister struct Concatenation * result;\n-    \t\n-    \tresult = GC_NEW(struct Concatenation);\n-    \tif (result == 0) OUT_OF_MEMORY;\n-    \tresult->header = CONCAT_HDR;\n-    \tresult->depth = depth;\n-    \tif (lenx <= MAX_LEFT_LEN) result->left_len = lenx;\n-    \tresult->len = result_len;\n-    \tresult->left = x;\n-    \tresult->right = y;\n-    \tif (depth >= MAX_DEPTH) {\n-    \t    return(CORD_balance((CORD)result));\n-    \t} else {\n-    \t    return((CORD) result);\n-    \t}\n-    }\n-}\n-\n-\n-\n-CORD CORD_from_fn(CORD_fn fn, void * client_data, size_t len)\n-{\n-    if (len <= 0) return(0);\n-    if (len <= SHORT_LIMIT) {\n-        register char * result;\n-        register size_t i;\n-        char buf[SHORT_LIMIT+1];\n-        register char c;\n-        \n-        for (i = 0; i < len; i++) {\n-            c = (*fn)(i, client_data);\n-            if (c == '\\0') goto gen_case;\n-            buf[i] = c;\n-        }\n-        buf[i] = '\\0';\n-        result = GC_MALLOC_ATOMIC(len+1);\n-        if (result == 0) OUT_OF_MEMORY;\n-        strcpy(result, buf);\n-        result[len] = '\\0';\n-        return((CORD) result);\n-    }\n-  gen_case:\n-    {\n-    \tregister struct Function * result;\n-    \t\n-    \tresult = GC_NEW(struct Function);\n-    \tif (result == 0) OUT_OF_MEMORY;\n-    \tresult->header = FN_HDR;\n-    \t/* depth is already 0 */\n-    \tresult->len = len;\n-    \tresult->fn = fn;\n-    \tresult->client_data = client_data;\n-    \treturn((CORD) result);\n-    }\n-}\n-\n-size_t CORD_len(CORD x)\n-{\n-    if (x == 0) {\n-     \treturn(0);\n-    } else {\n-\treturn(GEN_LEN(x));\n-    }\n-}\n-\n-struct substr_args {\n-    CordRep * sa_cord;\n-    size_t sa_index;\n-};\n-\n-char CORD_index_access_fn(size_t i, void * client_data)\n-{\n-    register struct substr_args *descr = (struct substr_args *)client_data;\n-    \n-    return(((char *)(descr->sa_cord))[i + descr->sa_index]);\n-}\n-\n-char CORD_apply_access_fn(size_t i, void * client_data)\n-{\n-    register struct substr_args *descr = (struct substr_args *)client_data;\n-    register struct Function * fn_cord = &(descr->sa_cord->function);\n-    \n-    return((*(fn_cord->fn))(i + descr->sa_index, fn_cord->client_data));\n-}\n-\n-/* A version of CORD_substr that simply returns a function node, thus\t*/\n-/* postponing its work.\tThe fourth argument is a function that may\t*/\n-/* be used for efficient access to the ith character.\t\t\t*/\n-/* Assumes i >= 0 and i + n < length(x).\t\t\t\t*/\n-CORD CORD_substr_closure(CORD x, size_t i, size_t n, CORD_fn f)\n-{\n-    register struct substr_args * sa = GC_NEW(struct substr_args);\n-    CORD result;\n-    \n-    if (sa == 0) OUT_OF_MEMORY;\n-    sa->sa_cord = (CordRep *)x;\n-    sa->sa_index = i;\n-    result = CORD_from_fn(f, (void *)sa, n);\n-    ((CordRep *)result) -> function.header = SUBSTR_HDR;\n-    return (result);\n-}\n-\n-# define SUBSTR_LIMIT (10 * SHORT_LIMIT)\n-\t/* Substrings of function nodes and flat strings shorter than \t*/\n-\t/* this are flat strings.  Othewise we use a functional \t*/\n-\t/* representation, which is significantly slower to access.\t*/\n-\n-/* A version of CORD_substr that assumes i >= 0, n > 0, and i + n < length(x).*/\n-CORD CORD_substr_checked(CORD x, size_t i, size_t n)\n-{\n-    if (CORD_IS_STRING(x)) {\n-        if (n > SUBSTR_LIMIT) {\n-            return(CORD_substr_closure(x, i, n, CORD_index_access_fn));\n-        } else {\n-            register char * result = GC_MALLOC_ATOMIC(n+1);\n-            \n-            if (result == 0) OUT_OF_MEMORY;\n-            strncpy(result, x+i, n);\n-            result[n] = '\\0';\n-            return(result);\n-        }\n-    } else if (IS_CONCATENATION(x)) {\n-    \tregister struct Concatenation * conc\n-    \t\t\t= &(((CordRep *)x) -> concatenation);\n-    \tregister size_t left_len;\n-    \tregister size_t right_len;\n-    \t\n-    \tleft_len = LEFT_LEN(conc);\n-    \tright_len = conc -> len - left_len;\n-    \tif (i >= left_len) {\n-    \t    if (n == right_len) return(conc -> right);\n-    \t    return(CORD_substr_checked(conc -> right, i - left_len, n));\n-    \t} else if (i+n <= left_len) {\n-    \t    if (n == left_len) return(conc -> left);\n-    \t    return(CORD_substr_checked(conc -> left, i, n));\n-    \t} else {\n-    \t    /* Need at least one character from each side. */\n-    \t    register CORD left_part;\n-    \t    register CORD right_part;\n-    \t    register size_t left_part_len = left_len - i;\n-     \t\n-    \t    if (i == 0) {\n-    \t        left_part = conc -> left;\n-    \t    } else {\n-    \t        left_part = CORD_substr_checked(conc -> left, i, left_part_len);\n-    \t    }\n-    \t    if (i + n == right_len + left_len) {\n-    \t         right_part = conc -> right;\n-    \t    } else {\n-    \t         right_part = CORD_substr_checked(conc -> right, 0,\n-    \t    \t\t\t\t          n - left_part_len);\n-    \t    }\n-    \t    return(CORD_cat(left_part, right_part));\n-    \t}\n-    } else /* function */ {\n-        if (n > SUBSTR_LIMIT) {\n-            if (IS_SUBSTR(x)) {\n-            \t/* Avoid nesting substring nodes.\t*/\n-            \tregister struct Function * f = &(((CordRep *)x) -> function);\n-            \tregister struct substr_args *descr =\n-            \t\t\t(struct substr_args *)(f -> client_data);\n-            \t\n-            \treturn(CORD_substr_closure((CORD)descr->sa_cord,\n-            \t\t\t\t   i + descr->sa_index,\n-            \t\t\t\t   n, f -> fn));\n-            } else {\n-                return(CORD_substr_closure(x, i, n, CORD_apply_access_fn));\n-            }\n-        } else {\n-            char * result;\n-            register struct Function * f = &(((CordRep *)x) -> function);\n-            char buf[SUBSTR_LIMIT+1];\n-            register char * p = buf;\n-            register char c;\n-            register int j;\n-            register int lim = i + n;\n-            \n-            for (j = i; j < lim; j++) {\n-            \tc = (*(f -> fn))(j, f -> client_data);\n-            \tif (c == '\\0') {\n-            \t    return(CORD_substr_closure(x, i, n, CORD_apply_access_fn));\n-            \t}\n-            \t*p++ = c;\n-            }\n-            *p = '\\0';\n-            result = GC_MALLOC_ATOMIC(n+1);\n-            if (result == 0) OUT_OF_MEMORY;\n-            strcpy(result, buf);\n-            return(result);\n-        }\n-    }\n-}\n-\n-CORD CORD_substr(CORD x, size_t i, size_t n)\n-{\n-    register size_t len = CORD_len(x);\n-    \n-    if (i >= len || n <= 0) return(0);\n-    \t/* n < 0 is impossible in a correct C implementation, but\t*/\n-    \t/* quite possible  under SunOS 4.X.\t\t\t\t*/\n-    if (i + n > len) n = len - i;\n-#   ifndef __STDC__\n-      if (i < 0) ABORT(\"CORD_substr: second arg. negative\");\n-    \t/* Possible only if both client and C implementation are buggy.\t*/\n-    \t/* But empirically this happens frequently.\t\t\t*/\n-#   endif\n-    return(CORD_substr_checked(x, i, n));\n-}\n-\n-/* See cord.h for definition.  We assume i is in range.\t*/\n-int CORD_iter5(CORD x, size_t i, CORD_iter_fn f1,\n-\t\t\t CORD_batched_iter_fn f2, void * client_data)\n-{\n-    if (x == 0) return(0);\n-    if (CORD_IS_STRING(x)) {\n-    \tregister const char *p = x+i;\n-    \t\n-    \tif (*p == '\\0') ABORT(\"2nd arg to CORD_iter5 too big\");\n-        if (f2 != CORD_NO_FN) {\n-            return((*f2)(p, client_data));\n-        } else {\n-\t    while (*p) {\n-                if ((*f1)(*p, client_data)) return(1);\n-                p++;\n-\t    }\n-\t    return(0);\n-        }\n-    } else if (IS_CONCATENATION(x)) {\n-    \tregister struct Concatenation * conc\n-    \t\t\t= &(((CordRep *)x) -> concatenation);\n-    \t\n-    \t\n-    \tif (i > 0) {\n-    \t    register size_t left_len = LEFT_LEN(conc);\n-    \t    \n-    \t    if (i >= left_len) {\n-    \t        return(CORD_iter5(conc -> right, i - left_len, f1, f2,\n-    \t        \t\t  client_data));\n-    \t    }\n-    \t}\n-    \tif (CORD_iter5(conc -> left, i, f1, f2, client_data)) {\n-    \t    return(1);\n-    \t}\n-    \treturn(CORD_iter5(conc -> right, 0, f1, f2, client_data));\n-    } else /* function */ {\n-        register struct Function * f = &(((CordRep *)x) -> function);\n-        register size_t j;\n-        register size_t lim = f -> len;\n-        \n-        for (j = i; j < lim; j++) {\n-            if ((*f1)((*(f -> fn))(j, f -> client_data), client_data)) {\n-                return(1);\n-            }\n-        }\n-        return(0);\n-    }\n-}\n-\t\t\t\n-#undef CORD_iter\n-int CORD_iter(CORD x, CORD_iter_fn f1, void * client_data)\n-{\n-    return(CORD_iter5(x, 0, f1, CORD_NO_FN, client_data));\n-}\n-\n-int CORD_riter4(CORD x, size_t i, CORD_iter_fn f1, void * client_data)\n-{\n-    if (x == 0) return(0);\n-    if (CORD_IS_STRING(x)) {\n-\tregister const char *p = x + i;\n-\tregister char c;\n-               \n-\tfor(;;) {\n-\t    c = *p;\n-\t    if (c == '\\0') ABORT(\"2nd arg to CORD_riter4 too big\");\n-            if ((*f1)(c, client_data)) return(1);\n-\t    if (p == x) break;\n-            p--;\n-\t}\n-\treturn(0);\n-    } else if (IS_CONCATENATION(x)) {\n-    \tregister struct Concatenation * conc\n-    \t\t\t= &(((CordRep *)x) -> concatenation);\n-    \tregister CORD left_part = conc -> left;\n-    \tregister size_t left_len;\n-    \t\n-    \tleft_len = LEFT_LEN(conc);\n-    \tif (i >= left_len) {\n-    \t    if (CORD_riter4(conc -> right, i - left_len, f1, client_data)) {\n-    \t    \treturn(1);\n-    \t    }\n-    \t    return(CORD_riter4(left_part, left_len - 1, f1, client_data));\n-    \t} else {\n-    \t    return(CORD_riter4(left_part, i, f1, client_data));\n-    \t}\n-    } else /* function */ {\n-        register struct Function * f = &(((CordRep *)x) -> function);\n-        register size_t j;\n-        \n-        for (j = i; ; j--) {\n-            if ((*f1)((*(f -> fn))(j, f -> client_data), client_data)) {\n-                return(1);\n-            }\n-            if (j == 0) return(0);\n-        }\n-    }\n-}\n-\n-int CORD_riter(CORD x, CORD_iter_fn f1, void * client_data)\n-{\n-    return(CORD_riter4(x, CORD_len(x) - 1, f1, client_data));\n-}\n-\n-/*\n- * The following functions are concerned with balancing cords.\n- * Strategy:\n- * Scan the cord from left to right, keeping the cord scanned so far\n- * as a forest of balanced trees of exponentialy decreasing length.\n- * When a new subtree needs to be added to the forest, we concatenate all\n- * shorter ones to the new tree in the appropriate order, and then insert\n- * the result into the forest.\n- * Crucial invariants:\n- * 1. The concatenation of the forest (in decreasing order) with the\n- *     unscanned part of the rope is equal to the rope being balanced.\n- * 2. All trees in the forest are balanced.\n- * 3. forest[i] has depth at most i.\n- */\n-\n-typedef struct {\n-    CORD c;\n-    size_t len;\t\t/* Actual length of c \t*/\n-} ForestElement;\n-\n-static size_t min_len [ MAX_DEPTH ];\n-\n-static int min_len_init = 0;\n-\n-int CORD_max_len;\n-\n-typedef ForestElement Forest [ MAX_DEPTH ];\n-\t\t\t/* forest[i].len >= fib(i+1)\t        */\n-\t\t\t/* The string is the concatenation\t*/\n-\t\t\t/* of the forest in order of DECREASING */\n-\t\t\t/* indices.\t\t\t\t*/\n-\n-void CORD_init_min_len()\n-{\n-    register int i;\n-    register size_t last, previous, current;\n-        \n-    min_len[0] = previous = 1;\n-    min_len[1] = last = 2;\n-    for (i = 2; i < MAX_DEPTH; i++) {\n-    \tcurrent = last + previous;\n-    \tif (current < last) /* overflow */ current = last;\n-    \tmin_len[i] = current;\n-    \tprevious = last;\n-    \tlast = current;\n-    }\n-    CORD_max_len = last - 1;\n-    min_len_init = 1;\n-}\n-\n-\n-void CORD_init_forest(ForestElement * forest, size_t max_len)\n-{\n-    register int i;\n-    \n-    for (i = 0; i < MAX_DEPTH; i++) {\n-    \tforest[i].c = 0;\n-    \tif (min_len[i] > max_len) return;\n-    }\n-    ABORT(\"Cord too long\");\n-}\n-\n-/* Add a leaf to the appropriate level in the forest, cleaning\t\t*/\n-/* out lower levels as necessary.\t\t\t\t\t*/\n-/* Also works if x is a balanced tree of concatenations; however\t*/\n-/* in this case an extra concatenation node may be inserted above x;\t*/\n-/* This node should not be counted in the statement of the invariants.\t*/\n-void CORD_add_forest(ForestElement * forest, CORD x, size_t len)\n-{\n-    register int i = 0;\n-    register CORD sum = CORD_EMPTY;\n-    register size_t sum_len = 0;\n-    \n-    while (len > min_len[i + 1]) {\n-    \tif (forest[i].c != 0) {\n-    \t    sum = CORD_cat(forest[i].c, sum);\n-    \t    sum_len += forest[i].len;\n-    \t    forest[i].c = 0;\n-    \t}\n-        i++;\n-    }\n-    /* Sum has depth at most 1 greter than what would be required \t*/\n-    /* for balance.\t\t\t\t\t\t\t*/\n-    sum = CORD_cat(sum, x);\n-    sum_len += len;\n-    /* If x was a leaf, then sum is now balanced.  To see this\t\t*/\n-    /* consider the two cases in which forest[i-1] either is or is \t*/\n-    /* not empty.\t\t\t\t\t\t\t*/\n-    while (sum_len >= min_len[i]) {\n-    \tif (forest[i].c != 0) {\n-    \t    sum = CORD_cat(forest[i].c, sum);\n-    \t    sum_len += forest[i].len;\n-    \t    /* This is again balanced, since sum was balanced, and has\t*/\n-    \t    /* allowable depth that differs from i by at most 1.\t*/\n-    \t    forest[i].c = 0;\n-    \t}\n-        i++;\n-    }\n-    i--;\n-    forest[i].c = sum;\n-    forest[i].len = sum_len;\n-}\n-\n-CORD CORD_concat_forest(ForestElement * forest, size_t expected_len)\n-{\n-    register int i = 0;\n-    CORD sum = 0;\n-    size_t sum_len = 0;\n-    \n-    while (sum_len != expected_len) {\n-    \tif (forest[i].c != 0) {\n-    \t    sum = CORD_cat(forest[i].c, sum);\n-    \t    sum_len += forest[i].len;\n-    \t}\n-        i++;\n-    }\n-    return(sum);\n-}\n-\n-/* Insert the frontier of x into forest.  Balanced subtrees are\t*/\n-/* treated as leaves.  This potentially adds one to the depth\t*/\n-/* of the final tree.\t\t\t\t\t\t*/\n-void CORD_balance_insert(CORD x, size_t len, ForestElement * forest)\n-{\n-    register int depth;\n-    \n-    if (CORD_IS_STRING(x)) {\n-        CORD_add_forest(forest, x, len);\n-    } else if (IS_CONCATENATION(x)\n-               && ((depth = DEPTH(x)) >= MAX_DEPTH\n-                   || len < min_len[depth])) {\n-    \tregister struct Concatenation * conc\n-    \t\t\t= &(((CordRep *)x) -> concatenation);\n-    \tsize_t left_len = LEFT_LEN(conc);\n-    \t\n-    \tCORD_balance_insert(conc -> left, left_len, forest);\n-    \tCORD_balance_insert(conc -> right, len - left_len, forest);\n-    } else /* function or balanced */ {\n-    \tCORD_add_forest(forest, x, len);\n-    }\n-}\n-\n-\n-CORD CORD_balance(CORD x)\n-{\n-    Forest forest;\n-    register size_t len;\n-    \n-    if (x == 0) return(0);\n-    if (CORD_IS_STRING(x)) return(x);\n-    if (!min_len_init) CORD_init_min_len();\n-    len = LEN(x);\n-    CORD_init_forest(forest, len);\n-    CORD_balance_insert(x, len, forest);\n-    return(CORD_concat_forest(forest, len));\n-}\n-\n-\n-/* Position primitives\t*/\n-\n-/* Private routines to deal with the hard cases only: */\n-\n-/* P contains a prefix of the  path to cur_pos.\tExtend it to a full\t*/\n-/* path and set up leaf info.\t\t\t\t\t\t*/\n-/* Return 0 if past the end of cord, 1 o.w.\t\t\t\t*/\n-void CORD__extend_path(register CORD_pos p)\n-{\n-     register struct CORD_pe * current_pe = &(p[0].path[p[0].path_len]);\n-     register CORD top = current_pe -> pe_cord;\n-     register size_t pos = p[0].cur_pos;\n-     register size_t top_pos = current_pe -> pe_start_pos;\n-     register size_t top_len = GEN_LEN(top);\n-     \n-     /* Fill in the rest of the path. */\n-       while(!CORD_IS_STRING(top) && IS_CONCATENATION(top)) {\n-     \t register struct Concatenation * conc =\n-     \t \t\t&(((CordRep *)top) -> concatenation);\n-     \t register size_t left_len;\n-     \t \n-     \t left_len = LEFT_LEN(conc);\n-     \t current_pe++;\n-     \t if (pos >= top_pos + left_len) {\n-     \t     current_pe -> pe_cord = top = conc -> right;\n-     \t     current_pe -> pe_start_pos = top_pos = top_pos + left_len;\n-     \t     top_len -= left_len;\n-     \t } else {\n-     \t     current_pe -> pe_cord = top = conc -> left;\n-     \t     current_pe -> pe_start_pos = top_pos;\n-     \t     top_len = left_len;\n-     \t }\n-     \t p[0].path_len++;\n-       }\n-     /* Fill in leaf description for fast access. */\n-       if (CORD_IS_STRING(top)) {\n-         p[0].cur_leaf = top;\n-         p[0].cur_start = top_pos;\n-         p[0].cur_end = top_pos + top_len;\n-       } else {\n-         p[0].cur_end = 0;\n-       }\n-       if (pos >= top_pos + top_len) p[0].path_len = CORD_POS_INVALID;\n-}\n-\n-char CORD__pos_fetch(register CORD_pos p)\n-{\n-    /* Leaf is a function node */\n-    struct CORD_pe * pe = &((p)[0].path[(p)[0].path_len]);\n-    CORD leaf = pe -> pe_cord;\n-    register struct Function * f = &(((CordRep *)leaf) -> function);\n-    \n-    if (!IS_FUNCTION(leaf)) ABORT(\"CORD_pos_fetch: bad leaf\");\n-    return ((*(f -> fn))(p[0].cur_pos - pe -> pe_start_pos, f -> client_data));\n-}\n-\n-void CORD__next(register CORD_pos p)\n-{\n-    register size_t cur_pos = p[0].cur_pos + 1;\n-    register struct CORD_pe * current_pe = &((p)[0].path[(p)[0].path_len]);\n-    register CORD leaf = current_pe -> pe_cord;\n-    \n-    /* Leaf is not a string or we're at end of leaf */\n-    p[0].cur_pos = cur_pos;\n-    if (!CORD_IS_STRING(leaf)) {\n-    \t/* Function leaf\t*/\n-    \tregister struct Function * f = &(((CordRep *)leaf) -> function);\n-    \tregister size_t start_pos = current_pe -> pe_start_pos;\n-    \tregister size_t end_pos = start_pos + f -> len;\n-    \t\n-    \tif (cur_pos < end_pos) {\n-    \t  /* Fill cache and return. */\n-    \t    register size_t i;\n-    \t    register size_t limit = cur_pos + FUNCTION_BUF_SZ;\n-    \t    register CORD_fn fn = f -> fn;\n-    \t    register void * client_data = f -> client_data;\n-    \t    \n-    \t    if (limit > end_pos) {\n-    \t        limit = end_pos;\n-    \t    }\n-    \t    for (i = cur_pos; i < limit; i++) {\n-    \t        p[0].function_buf[i - cur_pos] =\n-    \t        \t(*fn)(i - start_pos, client_data);\n-    \t    }\n-    \t    p[0].cur_start = cur_pos;\n-    \t    p[0].cur_leaf = p[0].function_buf;\n-    \t    p[0].cur_end = limit;\n-    \t    return;\n-    \t}\n-    }\n-    /* End of leaf\t*/\n-    /* Pop the stack until we find two concatenation nodes with the \t*/\n-    /* same start position: this implies we were in left part.\t\t*/\n-    {\n-    \twhile (p[0].path_len > 0\n-    \t       && current_pe[0].pe_start_pos != current_pe[-1].pe_start_pos) {\n-    \t    p[0].path_len--;\n-    \t    current_pe--;\n-    \t}\n-    \tif (p[0].path_len == 0) {\n-\t    p[0].path_len = CORD_POS_INVALID;\n-            return;\n-\t}\n-    }\n-    p[0].path_len--;\n-    CORD__extend_path(p);\n-}\n-\n-void CORD__prev(register CORD_pos p)\n-{\n-    register struct CORD_pe * pe = &(p[0].path[p[0].path_len]);\n-    \n-    if (p[0].cur_pos == 0) {\n-        p[0].path_len = CORD_POS_INVALID;\n-        return;\n-    }\n-    p[0].cur_pos--;\n-    if (p[0].cur_pos >= pe -> pe_start_pos) return;\n-    \n-    /* Beginning of leaf\t*/\n-    \n-    /* Pop the stack until we find two concatenation nodes with the \t*/\n-    /* different start position: this implies we were in right part.\t*/\n-    {\n-    \tregister struct CORD_pe * current_pe = &((p)[0].path[(p)[0].path_len]);\n-    \t\n-    \twhile (p[0].path_len > 0\n-    \t       && current_pe[0].pe_start_pos == current_pe[-1].pe_start_pos) {\n-    \t    p[0].path_len--;\n-    \t    current_pe--;\n-    \t}\n-    }\n-    p[0].path_len--;\n-    CORD__extend_path(p);\n-}\n-\n-#undef CORD_pos_fetch\n-#undef CORD_next\n-#undef CORD_prev\n-#undef CORD_pos_to_index\n-#undef CORD_pos_to_cord\n-#undef CORD_pos_valid\n-\n-char CORD_pos_fetch(register CORD_pos p)\n-{\n-    if (p[0].cur_start <= p[0].cur_pos && p[0].cur_pos < p[0].cur_end) {\n-    \treturn(p[0].cur_leaf[p[0].cur_pos - p[0].cur_start]);\n-    } else {\n-        return(CORD__pos_fetch(p));\n-    }\n-}\n-\n-void CORD_next(CORD_pos p)\n-{\n-    if (p[0].cur_pos < p[0].cur_end - 1) {\n-    \tp[0].cur_pos++;\n-    } else {\n-    \tCORD__next(p);\n-    }\n-}\n-\n-void CORD_prev(CORD_pos p)\n-{\n-    if (p[0].cur_end != 0 && p[0].cur_pos > p[0].cur_start) {\n-    \tp[0].cur_pos--;\n-    } else {\n-    \tCORD__prev(p);\n-    }\n-}\n-\n-size_t CORD_pos_to_index(CORD_pos p)\n-{\n-    return(p[0].cur_pos);\n-}\n-\n-CORD CORD_pos_to_cord(CORD_pos p)\n-{\n-    return(p[0].path[0].pe_cord);\n-}\n-\n-int CORD_pos_valid(CORD_pos p)\n-{\n-    return(p[0].path_len != CORD_POS_INVALID);\n-}\n-\n-void CORD_set_pos(CORD_pos p, CORD x, size_t i)\n-{\n-    if (x == CORD_EMPTY) {\n-    \tp[0].path_len = CORD_POS_INVALID;\n-    \treturn;\n-    }\n-    p[0].path[0].pe_cord = x;\n-    p[0].path[0].pe_start_pos = 0;\n-    p[0].path_len = 0;\n-    p[0].cur_pos = i;\n-    CORD__extend_path(p);\n-}"}, {"sha": "6d278feda65b55dbfee6217c21588903aa6ef2ae", "filename": "boehm-gc/cord/cordprnt.c", "status": "removed", "additions": 0, "deletions": 396, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fcord%2Fcordprnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fcord%2Fcordprnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fcordprnt.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,396 +0,0 @@\n-/* \n- * Copyright (c) 1993-1994 by Xerox Corporation.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n-/* An sprintf implementation that understands cords.  This is probably\t*/\n-/* not terribly portable.  It assumes an ANSI stdarg.h.  It further\t*/\n-/* assumes that I can make copies of va_list variables, and read \t*/\n-/* arguments repeatedly by applyting va_arg to the copies.  This\t*/\n-/* could be avoided at some performance cost.\t\t\t\t*/\n-/* We also assume that unsigned and signed integers of various kinds\t*/\n-/* have the same sizes, and can be cast back and forth.\t\t\t*/\n-/* We assume that void * and char * have the same size.\t\t\t*/\n-/* All this cruft is needed because we want to rely on the underlying\t*/\n-/* sprintf implementation whenever possible.\t\t\t\t*/\n-/* Boehm, September 21, 1995 6:00 pm PDT */\n-\n-#include \"cord.h\"\n-#include \"ec.h\"\n-#include <stdio.h>\n-#include <stdarg.h>\n-#include <string.h>\n-#include \"gc.h\"\n-\n-#define CONV_SPEC_LEN 50\t/* Maximum length of a single\t*/\n-\t\t\t\t/* conversion specification.\t*/\n-#define CONV_RESULT_LEN 50\t/* Maximum length of any \t*/\n-\t\t\t\t/* conversion with default\t*/\n-\t\t\t\t/* width and prec.\t\t*/\n-\n-\n-static int ec_len(CORD_ec x)\n-{\n-    return(CORD_len(x[0].ec_cord) + (x[0].ec_bufptr - x[0].ec_buf));\n-}\n-\n-/* Possible nonumeric precision values.\t*/\n-# define NONE -1\n-# define VARIABLE -2\n-/* Copy the conversion specification from CORD_pos into the buffer buf\t*/\n-/* Return negative on error.\t\t\t\t\t\t*/\n-/* Source initially points one past the leading %.\t\t\t*/\n-/* It is left pointing at the conversion type.\t\t\t\t*/\n-/* Assign field width and precision to *width and *prec.\t\t*/\n-/* If width or prec is *, VARIABLE is assigned.\t\t\t\t*/\n-/* Set *left to 1 if left adjustment flag is present.\t\t\t*/\n-/* Set *long_arg to 1 if long flag ('l' or 'L') is present, or to\t*/\n-/* -1 if 'h' is present.\t\t\t\t\t\t*/\n-static int extract_conv_spec(CORD_pos source, char *buf,\n-\t\t\t     int * width, int *prec, int *left, int * long_arg)\n-{\n-    register int result = 0;\n-    register int current_number = 0;\n-    register int saw_period = 0;\n-    register int saw_number = 0;\n-    register int chars_so_far = 0;\n-    register char current;\n-    \n-    *width = NONE;\n-    buf[chars_so_far++] = '%';\n-    while(CORD_pos_valid(source)) {\n-        if (chars_so_far >= CONV_SPEC_LEN) return(-1);\n-        current = CORD_pos_fetch(source);\n-        buf[chars_so_far++] = current;\n-        switch(current) {\n-\t  case '*':\n-\t    saw_number = 1;\n-\t    current_number = VARIABLE;\n-\t    break;\n-          case '0':\n-            if (!saw_number) {\n-                /* Zero fill flag; ignore */\n-                break;\n-            } /* otherwise fall through: */\n-          case '1':\n-\t  case '2':\n-\t  case '3':\n-\t  case '4':\n-\t  case '5':\n-          case '6':\n-\t  case '7':\n-\t  case '8':\n-\t  case '9':\n-\t    saw_number = 1;\n-\t    current_number *= 10;\n-\t    current_number += current - '0';\n-\t    break;\n-\t  case '.':\n-\t    saw_period = 1;\n-\t    if(saw_number) {\n-\t        *width = current_number;\n-\t        saw_number = 0;\n-\t    }\n-\t    current_number = 0;\n-\t    break;\n-\t  case 'l':\n-\t  case 'L':\n-\t    *long_arg = 1;\n-\t    current_number = 0;\n-\t    break;\n-\t  case 'h':\n-\t    *long_arg = -1;\n-\t    current_number = 0;\n-\t    break;\n-\t  case ' ':\n-\t  case '+':\n-\t  case '#':\n-\t    current_number = 0;\n-\t    break;\n-\t  case '-':\n-\t    *left = 1;\n-\t    current_number = 0;\n-\t    break;\n-\t  case 'd':\n-\t  case 'i':\n-\t  case 'o':\n-\t  case 'u':\n-\t  case 'x':\n-\t  case 'X':\n-\t  case 'f':\n-\t  case 'e':\n-\t  case 'E':\n-\t  case 'g':\n-\t  case 'G':\n-\t  case 'c':\n-\t  case 'C':\n-\t  case 's':\n-\t  case 'S':\n-\t  case 'p':\n-\t  case 'n':\n-\t  case 'r':\n-\t    goto done;          \n-          default:\n-            return(-1);\n-        }\n-        CORD_next(source);\n-    }\n-    return(-1);\n-  done:\n-    if (saw_number) {\n-    \tif (saw_period) {\n-    \t    *prec = current_number;\n-    \t} else {\n-    \t    *prec = NONE;\n-    \t    *width = current_number;\n-    \t}\n-    } else {\n-    \t*prec = NONE;\n-    }\n-    buf[chars_so_far] = '\\0';\n-    return(result);\n-}\n-\n-int CORD_vsprintf(CORD * out, CORD format, va_list args)\n-{\n-    CORD_ec result;\n-    register int count;\n-    register char current;\n-    CORD_pos pos;\n-    char conv_spec[CONV_SPEC_LEN + 1];\n-    \n-    CORD_ec_init(result);\n-    for (CORD_set_pos(pos, format, 0); CORD_pos_valid(pos); CORD_next(pos)) {\n-       \tcurrent = CORD_pos_fetch(pos);\n-       \tif (current == '%') {\n-            CORD_next(pos);\n-            if (!CORD_pos_valid(pos)) return(-1);\n-            current = CORD_pos_fetch(pos);\n-            if (current == '%') {\n-               \tCORD_ec_append(result, current);\n-            } else {\n-             \tint width, prec;\n-             \tint left_adj = 0;\n-             \tint long_arg = 0;\n-\t\tCORD arg;\n-\t\tsize_t len;\n-               \n-              \tif (extract_conv_spec(pos, conv_spec,\n-              \t\t\t      &width, &prec,\n-              \t\t\t      &left_adj, &long_arg) < 0) {\n-              \t    return(-1);\n-              \t}\n-              \tcurrent = CORD_pos_fetch(pos);\n-            \tswitch(current) {\n-            \t    case 'n':\n-            \t    \t/* Assign length to next arg */\n-            \t    \tif (long_arg == 0) {\n-            \t    \t    int * pos_ptr;\n-            \t    \t    pos_ptr = va_arg(args, int *);\n-            \t    \t    *pos_ptr = ec_len(result);\n-            \t    \t} else if (long_arg > 0) {\n-            \t    \t    long * pos_ptr;\n-            \t    \t    pos_ptr = va_arg(args, long *);\n-            \t    \t    *pos_ptr = ec_len(result);\n-            \t    \t} else {\n-            \t    \t    short * pos_ptr;\n-            \t    \t    pos_ptr = va_arg(args, short *);\n-            \t    \t    *pos_ptr = ec_len(result);\n-            \t    \t}\n-            \t    \tgoto done;\n-            \t    case 'r':\n-            \t    \t/* Append cord and any padding\t*/\n-            \t    \tif (width == VARIABLE) width = va_arg(args, int);\n-            \t    \tif (prec == VARIABLE) prec = va_arg(args, int);\n-\t\t\targ = va_arg(args, CORD);\n-\t\t\tlen = CORD_len(arg);\n-\t\t\tif (prec != NONE && len > prec) {\n-\t\t\t  if (prec < 0) return(-1);\n-\t\t\t  arg = CORD_substr(arg, 0, prec);\n-\t\t\t  len = prec;\n-\t\t\t}\n-\t\t\tif (width != NONE && len < width) {\n-\t\t\t  char * blanks = GC_MALLOC_ATOMIC(width-len+1);\n-\n-\t\t\t  memset(blanks, ' ', width-len);\n-\t\t\t  blanks[width-len] = '\\0';\n-\t\t\t  if (left_adj) {\n-\t\t\t    arg = CORD_cat(arg, blanks);\n-\t\t\t  } else {\n-\t\t\t    arg = CORD_cat(blanks, arg);\n-\t\t\t  }\n-\t\t\t}\n-\t\t\tCORD_ec_append_cord(result, arg);\n-            \t    \tgoto done;\n-\t\t    case 'c':\n-\t\t\tif (width == NONE && prec == NONE) {\n-\t\t\t    register char c;\n-\n-\t\t\t    c = (char)va_arg(args, int);\n-\t\t\t    CORD_ec_append(result, c);\n-\t\t\t    goto done;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t    case 's':\n-\t\t        if (width == NONE && prec == NONE) {\n-\t\t\t    char * str = va_arg(args, char *);\n-\t\t\t    register char c;\n-\n-\t\t\t    while ((c = *str++)) {\n-\t\t\t        CORD_ec_append(result, c);\n-\t\t\t    }\n-\t\t\t    goto done;\n-\t\t\t}\n-\t\t\tbreak;\n-            \t    default:\n-            \t        break;\n-            \t}\n-            \t/* Use standard sprintf to perform conversion */\n-            \t{\n-            \t    register char * buf;\n-            \t    va_list vsprintf_args;\n-            \t    int max_size = 0;\n-            \t    int res;\n-#\t\t    ifdef __va_copy\n-                      __va_copy(vsprintf_args, args);\n-#\t\t    else\n-#\t\t      if defined(__GNUC__) && !defined(__DJGPP__) /* and probably in other cases */\n-                        va_copy(vsprintf_args, args);\n-#\t\t      else\n-\t\t\tvsprintf_args = args;\n-#\t\t      endif\n-#\t\t    endif\n-            \t    if (width == VARIABLE) width = va_arg(args, int);\n-            \t    if (prec == VARIABLE) prec = va_arg(args, int);\n-            \t    if (width != NONE) max_size = width;\n-            \t    if (prec != NONE && prec > max_size) max_size = prec;\n-            \t    max_size += CONV_RESULT_LEN;\n-            \t    if (max_size >= CORD_BUFSZ) {\n-            \t        buf = GC_MALLOC_ATOMIC(max_size + 1);\n-            \t    } else {\n-            \t        if (CORD_BUFSZ - (result[0].ec_bufptr-result[0].ec_buf)\n-            \t            < max_size) {\n-            \t            CORD_ec_flush_buf(result);\n-            \t        }\n-            \t        buf = result[0].ec_bufptr;\n-            \t    }\n-            \t    switch(current) {\n-            \t        case 'd':\n-            \t        case 'i':\n-            \t        case 'o':\n-            \t        case 'u':\n-            \t        case 'x':\n-            \t        case 'X':\n-            \t        case 'c':\n-            \t            if (long_arg <= 0) {\n-            \t              (void) va_arg(args, int);\n-            \t            } else if (long_arg > 0) {\n-            \t              (void) va_arg(args, long);\n-            \t            }\n-            \t            break;\n-            \t        case 's':\n-            \t        case 'p':\n-            \t            (void) va_arg(args, char *);\n-            \t            break;\n-            \t        case 'f':\n-            \t        case 'e':\n-            \t        case 'E':\n-            \t        case 'g':\n-            \t        case 'G':\n-            \t            (void) va_arg(args, double);\n-            \t            break;\n-            \t        default:\n-            \t            return(-1);\n-            \t    }\n-            \t    res = vsprintf(buf, conv_spec, vsprintf_args);\n-            \t    len = (size_t)res;\n-            \t    if ((char *)(GC_word)res == buf) {\n-            \t    \t/* old style vsprintf */\n-            \t    \tlen = strlen(buf);\n-            \t    } else if (res < 0) {\n-            \t        return(-1);\n-            \t    }\n-            \t    if (buf != result[0].ec_bufptr) {\n-            \t        register char c;\n-\n-\t\t\twhile ((c = *buf++)) {\n-\t\t\t    CORD_ec_append(result, c);\n-\t\t        }\n-\t\t    } else {\n-\t\t        result[0].ec_bufptr = buf + len;\n-\t\t    }\n-            \t}\n-              done:;\n-            }\n-        } else {\n-            CORD_ec_append(result, current);\n-        }\n-    }\n-    count = ec_len(result);\n-    *out = CORD_balance(CORD_ec_to_cord(result));\n-    return(count);\n-}\n-\n-int CORD_sprintf(CORD * out, CORD format, ...)\n-{\n-    va_list args;\n-    int result;\n-    \n-    va_start(args, format);\n-    result = CORD_vsprintf(out, format, args);\n-    va_end(args);\n-    return(result);\n-}\n-\n-int CORD_fprintf(FILE * f, CORD format, ...)\n-{\n-    va_list args;\n-    int result;\n-    CORD out;\n-    \n-    va_start(args, format);\n-    result = CORD_vsprintf(&out, format, args);\n-    va_end(args);\n-    if (result > 0) CORD_put(out, f);\n-    return(result);\n-}\n-\n-int CORD_vfprintf(FILE * f, CORD format, va_list args)\n-{\n-    int result;\n-    CORD out;\n-    \n-    result = CORD_vsprintf(&out, format, args);\n-    if (result > 0) CORD_put(out, f);\n-    return(result);\n-}\n-\n-int CORD_printf(CORD format, ...)\n-{\n-    va_list args;\n-    int result;\n-    CORD out;\n-    \n-    va_start(args, format);\n-    result = CORD_vsprintf(&out, format, args);\n-    va_end(args);\n-    if (result > 0) CORD_put(out, stdout);\n-    return(result);\n-}\n-\n-int CORD_vprintf(CORD format, va_list args)\n-{\n-    int result;\n-    CORD out;\n-    \n-    result = CORD_vsprintf(&out, format, args);\n-    if (result > 0) CORD_put(out, stdout);\n-    return(result);\n-}"}, {"sha": "08333ca043406ac596f636f06af7ff6fc68fa499", "filename": "boehm-gc/cord/cordtest.c", "status": "removed", "additions": 0, "deletions": 235, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fcord%2Fcordtest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fcord%2Fcordtest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fcordtest.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,235 +0,0 @@\n-/* \n- * Copyright (c) 1993-1994 by Xerox Corporation.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n-/* Boehm, August 24, 1994 11:58 am PDT */\n-# include \"gc.h\"\t/* For GC_INIT() only */\n-# include \"cord.h\"\n-# include <string.h>\n-# include <stdio.h>\n-# include <stdlib.h>\n-/* This is a very incomplete test of the cord package.  It knows about\t*/\n-/* a few internals of the package (e.g. when C strings are returned)\t*/\n-/* that real clients shouldn't rely on.\t\t\t\t\t*/\n-\n-# define ABORT(string) \\\n-{ int x = 0; fprintf(stderr, \"FAILED: %s\\n\", string); x = 1 / x; abort(); }\n-\n-int count;\n-\n-int test_fn(char c, void * client_data)\n-{\n-    if (client_data != (void *)13) ABORT(\"bad client data\");\n-    if (count < 64*1024+1) {\n-        if ((count & 1) == 0) {\n-            if (c != 'b') ABORT(\"bad char\");\n-        } else {\n-            if (c != 'a') ABORT(\"bad char\");\n-        }\n-        count++;\n-        return(0);\n-    } else {\n-        if (c != 'c') ABORT(\"bad char\");\n-        count++;\n-        return(1);\n-    }\n-}\n-\n-char id_cord_fn(size_t i, void * client_data)\n-{\n-    return((char)i);\n-}\n-\n-void test_basics()\n-{\n-    CORD x = CORD_from_char_star(\"ab\");\n-    register int i;\n-    char c;\n-    CORD y;\n-    CORD_pos p;\n-    \n-    x = CORD_cat(x,x);\n-    if (!CORD_IS_STRING(x)) ABORT(\"short cord should usually be a string\");\n-    if (strcmp(x, \"abab\") != 0) ABORT(\"bad CORD_cat result\");\n-    \n-    for (i = 1; i < 16; i++) {\n-        x = CORD_cat(x,x);\n-    }\n-    x = CORD_cat(x,\"c\");\n-    if (CORD_len(x) != 128*1024+1) ABORT(\"bad length\");\n-    \n-    count = 0;\n-    if (CORD_iter5(x, 64*1024-1, test_fn, CORD_NO_FN, (void *)13) == 0) {\n-        ABORT(\"CORD_iter5 failed\");\n-    }\n-    if (count != 64*1024 + 2) ABORT(\"CORD_iter5 failed\");\n-    \n-    count = 0;\n-    CORD_set_pos(p, x, 64*1024-1);\n-    while(CORD_pos_valid(p)) {\n-       \t(void) test_fn(CORD_pos_fetch(p), (void *)13);\n-\tCORD_next(p);\n-    }\n-    if (count != 64*1024 + 2) ABORT(\"Position based iteration failed\");\n-    \n-    y = CORD_substr(x, 1023, 5);\n-    if (!CORD_IS_STRING(y)) ABORT(\"short cord should usually be a string\");\n-    if (strcmp(y, \"babab\") != 0) ABORT(\"bad CORD_substr result\");\n-    \n-    y = CORD_substr(x, 1024, 8);\n-    if (!CORD_IS_STRING(y)) ABORT(\"short cord should usually be a string\");\n-    if (strcmp(y, \"abababab\") != 0) ABORT(\"bad CORD_substr result\");\n-    \n-    y = CORD_substr(x, 128*1024-1, 8);\n-    if (!CORD_IS_STRING(y)) ABORT(\"short cord should usually be a string\");\n-    if (strcmp(y, \"bc\") != 0) ABORT(\"bad CORD_substr result\");\n-    \n-    x = CORD_balance(x);\n-    if (CORD_len(x) != 128*1024+1) ABORT(\"bad length\");\n-    \n-    count = 0;\n-    if (CORD_iter5(x, 64*1024-1, test_fn, CORD_NO_FN, (void *)13) == 0) {\n-        ABORT(\"CORD_iter5 failed\");\n-    }\n-    if (count != 64*1024 + 2) ABORT(\"CORD_iter5 failed\");\n-    \n-    y = CORD_substr(x, 1023, 5);\n-    if (!CORD_IS_STRING(y)) ABORT(\"short cord should usually be a string\");\n-    if (strcmp(y, \"babab\") != 0) ABORT(\"bad CORD_substr result\");\n-    y = CORD_from_fn(id_cord_fn, 0, 13);\n-    i = 0;\n-    CORD_set_pos(p, y, i);\n-    while(CORD_pos_valid(p)) {\n-        c = CORD_pos_fetch(p);\n-       \tif(c != i) ABORT(\"Traversal of function node failed\");\n-\tCORD_next(p); i++;\n-    }\n-    if (i != 13) ABORT(\"Bad apparent length for function node\");\n-}\n-\n-void test_extras()\n-{\n-#   if defined(__OS2__) || defined(__DJGPP__)\n-#\tdefine FNAME1 \"tmp1\"\n-#\tdefine FNAME2 \"tmp2\"\n-#   elif defined(AMIGA)\n-#\tdefine FNAME1 \"T:tmp1\"\n-#\tdefine FNAME2 \"T:tmp2\"\n-#   else\n-#\tdefine FNAME1 \"/tmp/cord_test\"\n-#\tdefine FNAME2 \"/tmp/cord_test2\"\n-#   endif\n-    register int i;\n-    CORD y = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n-    CORD x = \"{}\";\n-    CORD w, z;\n-    FILE *f;\n-    FILE *f1a, *f1b, *f2;\n-    \n-    w = CORD_cat(CORD_cat(y,y),y);\n-    z = CORD_catn(3,y,y,y);\n-    if (CORD_cmp(w,z) != 0) ABORT(\"CORD_catn comparison wrong\");\n-    for (i = 1; i < 100; i++) {\n-        x = CORD_cat(x, y);\n-    }\n-    z = CORD_balance(x);\n-    if (CORD_cmp(x,z) != 0) ABORT(\"balanced string comparison wrong\");\n-    if (CORD_cmp(x,CORD_cat(z, CORD_nul(13))) >= 0) ABORT(\"comparison 2\");\n-    if (CORD_cmp(CORD_cat(x, CORD_nul(13)), z) <= 0) ABORT(\"comparison 3\");\n-    if (CORD_cmp(x,CORD_cat(z, \"13\")) >= 0) ABORT(\"comparison 4\");\n-    if ((f = fopen(FNAME1, \"w\")) == 0) ABORT(\"open failed\");\n-    if (CORD_put(z,f) == EOF) ABORT(\"CORD_put failed\");\n-    if (fclose(f) == EOF) ABORT(\"fclose failed\");\n-    w = CORD_from_file(f1a = fopen(FNAME1, \"rb\"));\n-    if (CORD_len(w) != CORD_len(z)) ABORT(\"file length wrong\");\n-    if (CORD_cmp(w,z) != 0) ABORT(\"file comparison wrong\");\n-    if (CORD_cmp(CORD_substr(w, 50*36+2, 36), y) != 0)\n-    \tABORT(\"file substr wrong\");\n-    z = CORD_from_file_lazy(f1b = fopen(FNAME1, \"rb\"));\n-    if (CORD_cmp(w,z) != 0) ABORT(\"File conversions differ\");\n-    if (CORD_chr(w, 0, '9') != 37) ABORT(\"CORD_chr failed 1\");\n-    if (CORD_chr(w, 3, 'a') != 38) ABORT(\"CORD_chr failed 2\");\n-    if (CORD_rchr(w, CORD_len(w) - 1, '}') != 1) ABORT(\"CORD_rchr failed\");\n-    x = y;\n-    for (i = 1; i < 14; i++) {\n-        x = CORD_cat(x,x);\n-    }\n-    if ((f = fopen(FNAME2, \"w\")) == 0) ABORT(\"2nd open failed\");\n-#   ifdef __DJGPP__\n-      /* FIXME: DJGPP workaround.  Why does this help? */\n-      if (fflush(f) != 0) ABORT(\"fflush failed\");\n-#   endif\n-    if (CORD_put(x,f) == EOF) ABORT(\"CORD_put failed\");\n-    if (fclose(f) == EOF) ABORT(\"fclose failed\");\n-    w = CORD_from_file(f2 = fopen(FNAME2, \"rb\"));\n-    if (CORD_len(w) != CORD_len(x)) ABORT(\"file length wrong\");\n-    if (CORD_cmp(w,x) != 0) ABORT(\"file comparison wrong\");\n-    if (CORD_cmp(CORD_substr(w, 1000*36, 36), y) != 0)\n-    \tABORT(\"file substr wrong\");\n-    if (strcmp(CORD_to_char_star(CORD_substr(w, 1000*36, 36)), y) != 0)\n-    \tABORT(\"char * file substr wrong\");\n-    if (strcmp(CORD_substr(w, 1000*36, 2), \"ab\") != 0)\n-    \tABORT(\"short file substr wrong\");\n-    if (CORD_str(x,1,\"9a\") != 35) ABORT(\"CORD_str failed 1\");\n-    if (CORD_str(x,0,\"9abcdefghijk\") != 35) ABORT(\"CORD_str failed 2\");\n-    if (CORD_str(x,0,\"9abcdefghijx\") != CORD_NOT_FOUND)\n-    \tABORT(\"CORD_str failed 3\");\n-    if (CORD_str(x,0,\"9>\") != CORD_NOT_FOUND) ABORT(\"CORD_str failed 4\");\n-    if (remove(FNAME1) != 0) {\n-    \t/* On some systems, e.g. OS2, this may fail if f1 is still open. */\n-    \tif ((fclose(f1a) == EOF) & (fclose(f1b) == EOF))\n-    \t\tABORT(\"fclose(f1) failed\");\n-    \tif (remove(FNAME1) != 0) ABORT(\"remove 1 failed\");\n-    }\n-    if (remove(FNAME2) != 0) {\n-    \tif (fclose(f2) == EOF) ABORT(\"fclose(f2) failed\");\n-    \tif (remove(FNAME2) != 0) ABORT(\"remove 2 failed\");\n-    }\n-}\n-\n-void test_printf()\n-{\n-    CORD result;\n-    char result2[200];\n-    long l;\n-    short s;\n-    CORD x;\n-    \n-    if (CORD_sprintf(&result, \"%7.2f%ln\", 3.14159F, &l) != 7)\n-    \tABORT(\"CORD_sprintf failed 1\");\n-    if (CORD_cmp(result, \"   3.14\") != 0)ABORT(\"CORD_sprintf goofed 1\");\n-    if (l != 7) ABORT(\"CORD_sprintf goofed 2\");\n-    if (CORD_sprintf(&result, \"%-7.2s%hn%c%s\", \"abcd\", &s, 'x', \"yz\") != 10)\n-    \tABORT(\"CORD_sprintf failed 2\");\n-    if (CORD_cmp(result, \"ab     xyz\") != 0)ABORT(\"CORD_sprintf goofed 3\");\n-    if (s != 7) ABORT(\"CORD_sprintf goofed 4\");\n-    x = \"abcdefghij\";\n-    x = CORD_cat(x,x);\n-    x = CORD_cat(x,x);\n-    x = CORD_cat(x,x);\n-    if (CORD_sprintf(&result, \"->%-120.78r!\\n\", x) != 124)\n-    \tABORT(\"CORD_sprintf failed 3\");\n-    (void) sprintf(result2, \"->%-120.78s!\\n\", CORD_to_char_star(x));\n-    if (CORD_cmp(result, result2) != 0)ABORT(\"CORD_sprintf goofed 5\");\n-}\n-\n-int main()\n-{\n-#   ifdef THINK_C\n-        printf(\"cordtest:\\n\");\n-#   endif\n-    GC_INIT();\n-    test_basics();\n-    test_extras();\n-    test_printf();\n-    CORD_fprintf(stderr, \"SUCCEEDED\\n\");\n-    return(0);\n-}"}, {"sha": "b0a746226cb6ed87ca77866f98f3ead7b34a2109", "filename": "boehm-gc/cord/cordxtra.c", "status": "removed", "additions": 0, "deletions": 621, "changes": 621, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fcord%2Fcordxtra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fcord%2Fcordxtra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fcordxtra.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,621 +0,0 @@\n-/*\n- * Copyright (c) 1993-1994 by Xerox Corporation.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- *\n- * Author: Hans-J. Boehm (boehm@parc.xerox.com)\n- */\n-/*\n- * These are functions on cords that do not need to understand their\n- * implementation.  They serve also serve as example client code for\n- * cord_basics.\n- */\n-/* Boehm, December 8, 1995 1:53 pm PST */\n-# include <stdio.h>\n-# include <string.h>\n-# include <stdlib.h>\n-# include <stdarg.h>\n-# include \"cord.h\"\n-# include \"ec.h\"\n-# define I_HIDE_POINTERS\t/* So we get access to allocation lock.\t*/\n-\t\t\t\t/* We use this for lazy file reading, \t*/\n-\t\t\t\t/* so that we remain independent \t*/\n-\t\t\t\t/* of the threads primitives.\t\t*/\n-# include \"gc.h\"\n-\n-/* For now we assume that pointer reads and writes are atomic, \t*/\n-/* i.e. another thread always sees the state before or after\t*/\n-/* a write.  This might be false on a Motorola M68K with\t*/\n-/* pointers that are not 32-bit aligned.  But there probably\t*/\n-/* aren't too many threads packages running on those.\t\t*/\n-# define ATOMIC_WRITE(x,y) (x) = (y)\n-# define ATOMIC_READ(x) (*(x))\n-\n-/* The standard says these are in stdio.h, but they aren't always: */\n-# ifndef SEEK_SET\n-#   define SEEK_SET 0\n-# endif\n-# ifndef SEEK_END\n-#   define SEEK_END 2\n-# endif\n-\n-# define BUFSZ 2048\t/* Size of stack allocated buffers when\t\t*/\n-\t\t\t/* we want large buffers.\t\t\t*/\n-\n-typedef void (* oom_fn)(void);\n-\n-# define OUT_OF_MEMORY {  if (CORD_oom_fn != (oom_fn) 0) (*CORD_oom_fn)(); \\\n-\t\t\t  ABORT(\"Out of memory\\n\"); }\n-# define ABORT(msg) { fprintf(stderr, \"%s\\n\", msg); abort(); }\n-\n-CORD CORD_cat_char(CORD x, char c)\n-{\n-    register char * string;\n-    \n-    if (c == '\\0') return(CORD_cat(x, CORD_nul(1)));\n-    string = GC_MALLOC_ATOMIC(2);\n-    if (string == 0) OUT_OF_MEMORY;\n-    string[0] = c;\n-    string[1] = '\\0';\n-    return(CORD_cat_char_star(x, string, 1));\n-}\n-\n-CORD CORD_catn(int nargs, ...)\n-{\n-    register CORD result = CORD_EMPTY;\n-    va_list args;\n-    register int i;\n-\n-    va_start(args, nargs);\n-    for (i = 0; i < nargs; i++) {\n-        register CORD next = va_arg(args, CORD);\n-        result = CORD_cat(result, next);\n-    }\n-    va_end(args);\n-    return(result);\n-}\n-\n-typedef struct {\n-\tsize_t len;\n-\tsize_t count;\n-\tchar * buf;\n-} CORD_fill_data;\n-\n-int CORD_fill_proc(char c, void * client_data)\n-{\n-    register CORD_fill_data * d = (CORD_fill_data *)client_data;\n-    register size_t count = d -> count;\n-    \n-    (d -> buf)[count] = c;\n-    d -> count = ++count;\n-    if (count >= d -> len) {\n-    \treturn(1);\n-    } else {\n-    \treturn(0);\n-    }\n-}\n-\n-int CORD_batched_fill_proc(const char * s, void * client_data)\n-{\n-    register CORD_fill_data * d = (CORD_fill_data *)client_data;\n-    register size_t count = d -> count;\n-    register size_t max = d -> len;\n-    register char * buf = d -> buf;\n-    register const char * t = s;\n-    \n-    while((buf[count] = *t++) != '\\0') {\n-        count++;\n-        if (count >= max) {\n-            d -> count = count;\n-            return(1);\n-        }\n-    }\n-    d -> count = count;\n-    return(0);\n-}\n-\n-/* Fill buf with len characters starting at i.  \t\t\t*/\n-/* Assumes len characters are available.\t\t\t\t*/ \n-void CORD_fill_buf(CORD x, size_t i, size_t len, char * buf)\n-{\n-    CORD_fill_data fd;\n-    \n-    fd.len = len;\n-    fd.buf = buf;\n-    fd.count = 0;\n-    (void)CORD_iter5(x, i, CORD_fill_proc, CORD_batched_fill_proc, &fd);\n-}\n-\n-int CORD_cmp(CORD x, CORD y)\n-{\n-    CORD_pos xpos;\n-    CORD_pos ypos;\n-    register size_t avail, yavail;\n-    \n-    if (y == CORD_EMPTY) return(x != CORD_EMPTY);\n-    if (x == CORD_EMPTY) return(-1);\n-    if (CORD_IS_STRING(y) && CORD_IS_STRING(x)) return(strcmp(x,y));\n-    CORD_set_pos(xpos, x, 0);\n-    CORD_set_pos(ypos, y, 0);\n-    for(;;) {\n-        if (!CORD_pos_valid(xpos)) {\n-            if (CORD_pos_valid(ypos)) {\n-            \treturn(-1);\n-            } else {\n-                return(0);\n-            }\n-        }\n-        if (!CORD_pos_valid(ypos)) {\n-            return(1);\n-        }\n-        if ((avail = CORD_pos_chars_left(xpos)) <= 0\n-            || (yavail = CORD_pos_chars_left(ypos)) <= 0) {\n-            register char xcurrent = CORD_pos_fetch(xpos);\n-            register char ycurrent = CORD_pos_fetch(ypos);\n-            if (xcurrent != ycurrent) return(xcurrent - ycurrent);\n-            CORD_next(xpos);\n-            CORD_next(ypos);\n-        } else {\n-            /* process as many characters as we can\t*/\n-            register int result;\n-            \n-            if (avail > yavail) avail = yavail;\n-            result = strncmp(CORD_pos_cur_char_addr(xpos),\n-            \t\t     CORD_pos_cur_char_addr(ypos), avail);\n-            if (result != 0) return(result);\n-            CORD_pos_advance(xpos, avail);\n-            CORD_pos_advance(ypos, avail);\n-        }\n-    }\n-}\n-\n-int CORD_ncmp(CORD x, size_t x_start, CORD y, size_t y_start, size_t len)\n-{\n-    CORD_pos xpos;\n-    CORD_pos ypos;\n-    register size_t count;\n-    register long avail, yavail;\n-    \n-    CORD_set_pos(xpos, x, x_start);\n-    CORD_set_pos(ypos, y, y_start);\n-    for(count = 0; count < len;) {\n-        if (!CORD_pos_valid(xpos)) {\n-            if (CORD_pos_valid(ypos)) {\n-            \treturn(-1);\n-            } else {\n-                return(0);\n-            }\n-        }\n-        if (!CORD_pos_valid(ypos)) {\n-            return(1);\n-        }\n-        if ((avail = CORD_pos_chars_left(xpos)) <= 0\n-            || (yavail = CORD_pos_chars_left(ypos)) <= 0) {\n-            register char xcurrent = CORD_pos_fetch(xpos);\n-            register char ycurrent = CORD_pos_fetch(ypos);\n-            if (xcurrent != ycurrent) return(xcurrent - ycurrent);\n-            CORD_next(xpos);\n-            CORD_next(ypos);\n-            count++;\n-        } else {\n-            /* process as many characters as we can\t*/\n-            register int result;\n-            \n-            if (avail > yavail) avail = yavail;\n-            count += avail;\n-            if (count > len) avail -= (count - len);\n-            result = strncmp(CORD_pos_cur_char_addr(xpos),\n-            \t\t     CORD_pos_cur_char_addr(ypos), (size_t)avail);\n-            if (result != 0) return(result);\n-            CORD_pos_advance(xpos, (size_t)avail);\n-            CORD_pos_advance(ypos, (size_t)avail);\n-        }\n-    }\n-    return(0);\n-}\n-\n-char * CORD_to_char_star(CORD x)\n-{\n-    register size_t len = CORD_len(x);\n-    char * result = GC_MALLOC_ATOMIC(len + 1);\n-    \n-    if (result == 0) OUT_OF_MEMORY;\n-    CORD_fill_buf(x, 0, len, result);\n-    result[len] = '\\0';\n-    return(result);\n-}\n-\n-CORD CORD_from_char_star(const char *s)\n-{\n-    char * result;\n-    size_t len = strlen(s);\n-\n-    if (0 == len) return(CORD_EMPTY);\n-    result = GC_MALLOC_ATOMIC(len + 1);\n-    if (result == 0) OUT_OF_MEMORY;\n-    memcpy(result, s, len+1);\n-    return(result);\n-}\n-\n-const char * CORD_to_const_char_star(CORD x)\n-{\n-    if (x == 0) return(\"\");\n-    if (CORD_IS_STRING(x)) return((const char *)x);\n-    return(CORD_to_char_star(x));\n-}\n-\n-char CORD_fetch(CORD x, size_t i)\n-{\n-    CORD_pos xpos;\n-    \n-    CORD_set_pos(xpos, x, i);\n-    if (!CORD_pos_valid(xpos)) ABORT(\"bad index?\");\n-    return(CORD_pos_fetch(xpos));\n-}\n-\n-\n-int CORD_put_proc(char c, void * client_data)\n-{\n-    register FILE * f = (FILE *)client_data;\n-    \n-    return(putc(c, f) == EOF);\n-}\n-\n-int CORD_batched_put_proc(const char * s, void * client_data)\n-{\n-    register FILE * f = (FILE *)client_data;\n-    \n-    return(fputs(s, f) == EOF);\n-}\n-    \n-\n-int CORD_put(CORD x, FILE * f)\n-{\n-    if (CORD_iter5(x, 0, CORD_put_proc, CORD_batched_put_proc, f)) {\n-        return(EOF);\n-    } else {\n-    \treturn(1);\n-    }\n-}\n-\n-typedef struct {\n-    size_t pos;\t\t/* Current position in the cord */\n-    char target;\t/* Character we're looking for\t*/\n-} chr_data;\n-\n-int CORD_chr_proc(char c, void * client_data)\n-{\n-    register chr_data * d = (chr_data *)client_data;\n-    \n-    if (c == d -> target) return(1);\n-    (d -> pos) ++;\n-    return(0);\n-}\n-\n-int CORD_rchr_proc(char c, void * client_data)\n-{\n-    register chr_data * d = (chr_data *)client_data;\n-    \n-    if (c == d -> target) return(1);\n-    (d -> pos) --;\n-    return(0);\n-}\n-\n-int CORD_batched_chr_proc(const char *s, void * client_data)\n-{\n-    register chr_data * d = (chr_data *)client_data;\n-    register char * occ = strchr(s, d -> target);\n-    \n-    if (occ == 0) {\n-      \td -> pos += strlen(s);\n-      \treturn(0);\n-    } else {\n-    \td -> pos += occ - s;\n-    \treturn(1);\n-    }\n-}\n-\n-size_t CORD_chr(CORD x, size_t i, int c)\n-{\n-    chr_data d;\n-    \n-    d.pos = i;\n-    d.target = c;\n-    if (CORD_iter5(x, i, CORD_chr_proc, CORD_batched_chr_proc, &d)) {\n-        return(d.pos);\n-    } else {\n-    \treturn(CORD_NOT_FOUND);\n-    }\n-}\n-\n-size_t CORD_rchr(CORD x, size_t i, int c)\n-{\n-    chr_data d;\n-    \n-    d.pos = i;\n-    d.target = c;\n-    if (CORD_riter4(x, i, CORD_rchr_proc, &d)) {\n-        return(d.pos);\n-    } else {\n-    \treturn(CORD_NOT_FOUND);\n-    }\n-}\n-\n-/* Find the first occurrence of s in x at position start or later.\t*/\n-/* This uses an asymptotically poor algorithm, which should typically \t*/\n-/* perform acceptably.  We compare the first few characters directly,\t*/\n-/* and call CORD_ncmp whenever there is a partial match.\t\t*/\n-/* This has the advantage that we allocate very little, or not at all.\t*/\n-/* It's very fast if there are few close misses.\t\t\t*/\n-size_t CORD_str(CORD x, size_t start, CORD s)\n-{\n-    CORD_pos xpos;\n-    size_t xlen = CORD_len(x);\n-    size_t slen;\n-    register size_t start_len;\n-    const char * s_start;\n-    unsigned long s_buf = 0;\t/* The first few characters of s\t*/\n-    unsigned long x_buf = 0;\t/* Start of candidate substring.\t*/\n-    \t\t\t\t/* Initialized only to make compilers\t*/\n-    \t\t\t\t/* happy.\t\t\t\t*/\n-    unsigned long mask = 0;\n-    register size_t i;\n-    register size_t match_pos;\n-    \n-    if (s == CORD_EMPTY) return(start);\n-    if (CORD_IS_STRING(s)) {\n-        s_start = s;\n-        slen = strlen(s);\n-    } else {\n-        s_start = CORD_to_char_star(CORD_substr(s, 0, sizeof(unsigned long)));\n-        slen = CORD_len(s);\n-    }\n-    if (xlen < start || xlen - start < slen) return(CORD_NOT_FOUND);\n-    start_len = slen;\n-    if (start_len > sizeof(unsigned long)) start_len = sizeof(unsigned long);\n-    CORD_set_pos(xpos, x, start);\n-    for (i = 0; i < start_len; i++) {\n-        mask <<= 8;\n-        mask |= 0xff;\n-        s_buf <<= 8;\n-        s_buf |= (unsigned char)s_start[i];\n-        x_buf <<= 8;\n-        x_buf |= (unsigned char)CORD_pos_fetch(xpos);\n-        CORD_next(xpos);\n-    }\n-    for (match_pos = start; ; match_pos++) {\n-    \tif ((x_buf & mask) == s_buf) {\n-    \t    if (slen == start_len ||\n-    \t     \tCORD_ncmp(x, match_pos + start_len,\n-    \t     \t \t  s, start_len, slen - start_len) == 0) {\n-    \t        return(match_pos);\n-    \t    }\n-    \t}\n-\tif ( match_pos == xlen - slen ) {\n-\t    return(CORD_NOT_FOUND);\n-\t}\n-    \tx_buf <<= 8;\n-        x_buf |= (unsigned char)CORD_pos_fetch(xpos);\n-        CORD_next(xpos);\n-    }\n-}\n-\n-void CORD_ec_flush_buf(CORD_ec x)\n-{\n-    register size_t len = x[0].ec_bufptr - x[0].ec_buf;\n-    char * s;\n-\n-    if (len == 0) return;\n-    s = GC_MALLOC_ATOMIC(len+1);\n-    memcpy(s, x[0].ec_buf, len);\n-    s[len] = '\\0';\n-    x[0].ec_cord = CORD_cat_char_star(x[0].ec_cord, s, len);\n-    x[0].ec_bufptr = x[0].ec_buf;\n-}\n-\n-void CORD_ec_append_cord(CORD_ec x, CORD s)\n-{\n-    CORD_ec_flush_buf(x);\n-    x[0].ec_cord = CORD_cat(x[0].ec_cord, s);\n-}\n-\n-/*ARGSUSED*/\n-char CORD_nul_func(size_t i, void * client_data)\n-{\n-    return((char)(unsigned long)client_data);\n-}\n-\n-\n-CORD CORD_chars(char c, size_t i)\n-{\n-    return(CORD_from_fn(CORD_nul_func, (void *)(unsigned long)c, i));\n-}\n-\n-CORD CORD_from_file_eager(FILE * f)\n-{\n-    register int c;\n-    CORD_ec ecord;\n-    \n-    CORD_ec_init(ecord);\n-    for(;;) {\n-        c = getc(f);\n-        if (c == 0) {\n-          /* Append the right number of NULs\t*/\n-          /* Note that any string of NULs is rpresented in 4 words,\t*/\n-          /* independent of its length.\t\t\t\t\t*/\n-            register size_t count = 1;\n-            \n-            CORD_ec_flush_buf(ecord);\n-            while ((c = getc(f)) == 0) count++;\n-            ecord[0].ec_cord = CORD_cat(ecord[0].ec_cord, CORD_nul(count));\n-        }\n-        if (c == EOF) break;\n-        CORD_ec_append(ecord, c);\n-    }\n-    (void) fclose(f);\n-    return(CORD_balance(CORD_ec_to_cord(ecord)));\n-}\n-\n-/* The state maintained for a lazily read file consists primarily\t*/\n-/* of a large direct-mapped cache of previously read values.\t\t*/\n-/* We could rely more on stdio buffering.  That would have 2\t\t*/\n-/* disadvantages:\t\t\t\t\t\t\t*/\n-/*  \t1) Empirically, not all fseek implementations preserve the\t*/\n-/*\t   buffer whenever they could.\t\t\t\t\t*/\n-/*\t2) It would fail if 2 different sections of a long cord\t\t*/\n-/*\t   were being read alternately.\t\t\t\t\t*/\n-/* We do use the stdio buffer for read ahead.\t\t\t\t*/\n-/* To guarantee thread safety in the presence of atomic pointer\t\t*/\n-/* writes, cache lines are always replaced, and never modified in\t*/\n-/* place.\t\t\t\t\t\t\t\t*/\n-\n-# define LOG_CACHE_SZ 14\n-# define CACHE_SZ (1 << LOG_CACHE_SZ)\n-# define LOG_LINE_SZ 9\n-# define LINE_SZ (1 << LOG_LINE_SZ)\n-\n-typedef struct {\n-    size_t tag;\n-    char data[LINE_SZ];\n-    \t/* data[i%LINE_SZ] = ith char in file if tag = i/LINE_SZ\t*/\n-} cache_line;\n-\n-typedef struct {\n-    FILE * lf_file;\n-    size_t lf_current;\t/* Current file pointer value */\n-    cache_line * volatile lf_cache[CACHE_SZ/LINE_SZ];\n-} lf_state;\n-\n-# define MOD_CACHE_SZ(n) ((n) & (CACHE_SZ - 1))\n-# define DIV_CACHE_SZ(n) ((n) >> LOG_CACHE_SZ)\n-# define MOD_LINE_SZ(n) ((n) & (LINE_SZ - 1))\n-# define DIV_LINE_SZ(n) ((n) >> LOG_LINE_SZ)\n-# define LINE_START(n) ((n) & ~(LINE_SZ - 1))\n-\n-typedef struct {\n-    lf_state * state;\n-    size_t file_pos;\t/* Position of needed character. */\n-    cache_line * new_cache;\n-} refill_data;\n-\n-/* Executed with allocation lock. */\n-static char refill_cache(client_data)\n-refill_data * client_data;\n-{\n-    register lf_state * state = client_data -> state;\n-    register size_t file_pos = client_data -> file_pos;\n-    FILE *f = state -> lf_file;\n-    size_t line_start = LINE_START(file_pos);\n-    size_t line_no = DIV_LINE_SZ(MOD_CACHE_SZ(file_pos));\n-    cache_line * new_cache = client_data -> new_cache;\n-    \n-    if (line_start != state -> lf_current\n-        && fseek(f, line_start, SEEK_SET) != 0) {\n-    \t    ABORT(\"fseek failed\");\n-    }\n-    if (fread(new_cache -> data, sizeof(char), LINE_SZ, f)\n-    \t<= file_pos - line_start) {\n-    \tABORT(\"fread failed\");\n-    }\n-    new_cache -> tag = DIV_LINE_SZ(file_pos);\n-    /* Store barrier goes here. */\n-    ATOMIC_WRITE(state -> lf_cache[line_no], new_cache);\n-    state -> lf_current = line_start + LINE_SZ;\n-    return(new_cache->data[MOD_LINE_SZ(file_pos)]);\n-}\n-\n-char CORD_lf_func(size_t i, void * client_data)\n-{\n-    register lf_state * state = (lf_state *)client_data;\n-    register cache_line * volatile * cl_addr =\n-\t\t&(state -> lf_cache[DIV_LINE_SZ(MOD_CACHE_SZ(i))]);\n-    register cache_line * cl = (cache_line *)ATOMIC_READ(cl_addr);\n-    \n-    if (cl == 0 || cl -> tag != DIV_LINE_SZ(i)) {\n-    \t/* Cache miss */\n-    \trefill_data rd;\n-    \t\n-        rd.state = state;\n-        rd.file_pos =  i;\n-        rd.new_cache = GC_NEW_ATOMIC(cache_line);\n-        if (rd.new_cache == 0) OUT_OF_MEMORY;\n-        return((char)(GC_word)\n-        \t  GC_call_with_alloc_lock((GC_fn_type) refill_cache, &rd));\n-    }\n-    return(cl -> data[MOD_LINE_SZ(i)]);\n-}    \n-\n-/*ARGSUSED*/\n-void CORD_lf_close_proc(void * obj, void * client_data)  \n-{\n-    if (fclose(((lf_state *)obj) -> lf_file) != 0) {\n-    \tABORT(\"CORD_lf_close_proc: fclose failed\");\n-    }\n-}\t\t\t\n-\n-CORD CORD_from_file_lazy_inner(FILE * f, size_t len)\n-{\n-    register lf_state * state = GC_NEW(lf_state);\n-    register int i;\n-    \n-    if (state == 0) OUT_OF_MEMORY;\n-    if (len != 0) {\n-\t/* Dummy read to force buffer allocation.  \t*/\n-\t/* This greatly increases the probability\t*/\n-\t/* of avoiding deadlock if buffer allocation\t*/\n-\t/* is redirected to GC_malloc and the\t\t*/\n-\t/* world is multithreaded.\t\t\t*/\n-\tchar buf[1];\n-\n-\t(void) fread(buf, 1, 1, f); \n-\trewind(f);\n-    }\n-    state -> lf_file = f;\n-    for (i = 0; i < CACHE_SZ/LINE_SZ; i++) {\n-        state -> lf_cache[i] = 0;\n-    }\n-    state -> lf_current = 0;\n-    GC_REGISTER_FINALIZER(state, CORD_lf_close_proc, 0, 0, 0);\n-    return(CORD_from_fn(CORD_lf_func, state, len));\n-}\n-\n-CORD CORD_from_file_lazy(FILE * f)\n-{\n-    register long len;\n-    \n-    if (fseek(f, 0l, SEEK_END) != 0) {\n-        ABORT(\"Bad fd argument - fseek failed\");\n-    }\n-    if ((len = ftell(f)) < 0) {\n-        ABORT(\"Bad fd argument - ftell failed\");\n-    }\n-    rewind(f);\n-    return(CORD_from_file_lazy_inner(f, (size_t)len));\n-}\n-\n-# define LAZY_THRESHOLD (128*1024 + 1)\n-\n-CORD CORD_from_file(FILE * f)\n-{\n-    register long len;\n-    \n-    if (fseek(f, 0l, SEEK_END) != 0) {\n-        ABORT(\"Bad fd argument - fseek failed\");\n-    }\n-    if ((len = ftell(f)) < 0) {\n-        ABORT(\"Bad fd argument - ftell failed\");\n-    }\n-    rewind(f);\n-    if (len < LAZY_THRESHOLD) {\n-        return(CORD_from_file_eager(f));\n-    } else {\n-        return(CORD_from_file_lazy_inner(f, (size_t)len));\n-    }\n-}"}, {"sha": "989e19a8881c0801699d2b9d2ecad1ef49151d53", "filename": "boehm-gc/cord/de.c", "status": "removed", "additions": 0, "deletions": 603, "changes": 603, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fcord%2Fde.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fcord%2Fde.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fde.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,603 +0,0 @@\n-/*\n- * Copyright (c) 1993-1994 by Xerox Corporation.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- *\n- * Author: Hans-J. Boehm (boehm@parc.xerox.com)\n- */\n-/*\n- * A really simple-minded text editor based on cords.\n- * Things it does right:\n- * \tNo size bounds.\n- *\tInbounded undo.\n- *\tShouldn't crash no matter what file you invoke it on (e.g. /vmunix)\n- *\t\t(Make sure /vmunix is not writable before you try this.)\n- *\tScrolls horizontally.\n- * Things it does wrong:\n- *\tIt doesn't handle tabs reasonably (use \"expand\" first).\n- *\tThe command set is MUCH too small.\n- *\tThe redisplay algorithm doesn't let curses do the scrolling.\n- *\tThe rule for moving the window over the file is suboptimal.\n- */\n-/* Boehm, February 6, 1995 12:27 pm PST */\n-\n-/* Boehm, May 19, 1994 2:20 pm PDT */\n-#include <stdio.h>\n-#include \"gc.h\"\n-#include \"cord.h\"\n-\n-#ifdef THINK_C\n-#define MACINTOSH\n-#include <ctype.h>\n-#endif\n-\n-#if defined(__BORLANDC__) && !defined(WIN32)\n-    /* If this is DOS or win16, we'll fail anyway.\t*/\n-    /* Might as well assume win32.\t\t\t*/\n-#   define WIN32\n-#endif\n-\n-#if defined(WIN32)\n-#  include <windows.h>\n-#  include \"de_win.h\"\n-#elif defined(MACINTOSH)\n-#\tinclude <console.h>\n-/* curses emulation. */\n-#\tdefine initscr()\n-#\tdefine endwin()\n-#\tdefine nonl()\n-#\tdefine noecho() csetmode(C_NOECHO, stdout)\n-#\tdefine cbreak() csetmode(C_CBREAK, stdout)\n-#\tdefine refresh()\n-#\tdefine addch(c) putchar(c)\n-#\tdefine standout() cinverse(1, stdout)\n-#\tdefine standend() cinverse(0, stdout)\n-#\tdefine move(line,col) cgotoxy(col + 1, line + 1, stdout)\n-#\tdefine clrtoeol() ccleol(stdout)\n-#\tdefine de_error(s) { fprintf(stderr, s); getchar(); }\n-#\tdefine LINES 25\n-#\tdefine COLS 80\n-#else\n-#  include <curses.h>\n-#  define de_error(s) { fprintf(stderr, s); sleep(2); }\n-#endif\n-#include \"de_cmds.h\"\n-\n-/* List of line number to position mappings, in descending order. */\n-/* There may be holes.\t\t\t\t\t\t  */\n-typedef struct LineMapRep {\n-    int line;\n-    size_t pos;\n-    struct LineMapRep * previous;\n-} * line_map;\n-\n-/* List of file versions, one per edit operation */\n-typedef struct HistoryRep {\n-    CORD file_contents;\n-    struct HistoryRep * previous;\n-    line_map map;\t/* Invalid for first record \"now\" */\n-} * history;\n-\n-history now = 0;\n-CORD current;\t\t/* == now -> file_contents.\t*/\n-size_t current_len;\t/* Current file length.\t\t*/\n-line_map current_map = 0;\t/* Current line no. to pos. map\t */\n-size_t current_map_size = 0;\t/* Number of current_map entries.\t*/\n-\t\t\t\t/* Not always accurate, but reset\t*/\n-\t\t\t\t/* by prune_map.\t\t\t*/\n-# define MAX_MAP_SIZE 3000\n-\n-/* Current display position */\n-int dis_line = 0;\n-int dis_col = 0;\n-\n-# define ALL -1\n-# define NONE - 2\n-int need_redisplay = 0;\t/* Line that needs to be redisplayed.\t*/\n-\n-\n-/* Current cursor position. Always within file. */\n-int line = 0; \n-int col = 0;\n-size_t file_pos = 0;\t/* Character position corresponding to cursor.\t*/\n-\n-/* Invalidate line map for lines > i */\n-void invalidate_map(int i)\n-{\n-    while(current_map -> line > i) {\n-        current_map = current_map -> previous;\n-        current_map_size--;\n-    }\n-}\n-\n-/* Reduce the number of map entries to save space for huge files. */\n-/* This also affects maps in histories.\t\t\t\t  */\n-void prune_map()\n-{\n-    line_map map = current_map;\n-    int start_line = map -> line;\n-    \n-    current_map_size = 0;\n-    for(; map != 0; map = map -> previous) {\n-    \tcurrent_map_size++;\n-    \tif (map -> line < start_line - LINES && map -> previous != 0) {\n-    \t    map -> previous = map -> previous -> previous;\n-    \t}\n-    }\n-}\n-/* Add mapping entry */\n-void add_map(int line, size_t pos)\n-{\n-    line_map new_map = GC_NEW(struct LineMapRep);\n-    \n-    if (current_map_size >= MAX_MAP_SIZE) prune_map();\n-    new_map -> line = line;\n-    new_map -> pos = pos;\n-    new_map -> previous = current_map;\n-    current_map = new_map;\n-    current_map_size++;\n-}\n-\n-\n-\n-/* Return position of column *c of ith line in   */\n-/* current file. Adjust *c to be within the line.*/\n-/* A 0 pointer is taken as 0 column.\t\t */\n-/* Returns CORD_NOT_FOUND if i is too big.\t */\n-/* Assumes i > dis_line.\t\t\t */\n-size_t line_pos(int i, int *c)\n-{\n-    int j;\n-    size_t cur;\n-    size_t next;\n-    line_map map = current_map;\n-    \n-    while (map -> line > i) map = map -> previous;\n-    if (map -> line < i - 2) /* rebuild */ invalidate_map(i);\n-    for (j = map -> line, cur = map -> pos; j < i;) {\n-\tcur = CORD_chr(current, cur, '\\n');\n-        if (cur == current_len-1) return(CORD_NOT_FOUND);\n-        cur++;\n-        if (++j > current_map -> line) add_map(j, cur);\n-    }\n-    if (c != 0) {\n-        next = CORD_chr(current, cur, '\\n');\n-        if (next == CORD_NOT_FOUND) next = current_len - 1;\n-        if (next < cur + *c) {\n-            *c = next - cur;\n-        }\n-        cur += *c;\n-    }\n-    return(cur);\n-}\n-\n-void add_hist(CORD s)\n-{\n-    history new_file = GC_NEW(struct HistoryRep);\n-    \n-    new_file -> file_contents = current = s;\n-    current_len = CORD_len(s);\n-    new_file -> previous = now;\n-    if (now != 0) now -> map = current_map;\n-    now = new_file;\n-}\n-\n-void del_hist(void)\n-{\n-    now = now -> previous;\n-    current = now -> file_contents;\n-    current_map = now -> map;\n-    current_len = CORD_len(current);\n-}\n-\n-/* Current screen_contents; a dynamically allocated array of CORDs\t*/\n-CORD * screen = 0;\n-int screen_size = 0;\n-\n-# ifndef WIN32\n-/* Replace a line in the curses stdscr.\tAll control characters are\t*/\n-/* displayed as upper case characters in standout mode.  This isn't\t*/\n-/* terribly appropriate for tabs.\t\t\t\t\t\t\t\t\t*/\n-void replace_line(int i, CORD s)\n-{\n-    register int c;\n-    CORD_pos p;\n-    size_t len = CORD_len(s);\n-    \n-    if (screen == 0 || LINES > screen_size) {\n-        screen_size = LINES;\n-    \tscreen = (CORD *)GC_MALLOC(screen_size * sizeof(CORD));\n-    }\n-#   if !defined(MACINTOSH)\n-        /* A gross workaround for an apparent curses bug: */\n-        if (i == LINES-1 && len == COLS) {\n-            s = CORD_substr(s, 0, CORD_len(s) - 1);\n-        }\n-#   endif\n-    if (CORD_cmp(screen[i], s) != 0) {\n-        move(i, 0); clrtoeol(); move(i,0);\n-\n-        CORD_FOR (p, s) {\n-            c = CORD_pos_fetch(p) & 0x7f;\n-            if (iscntrl(c)) {\n-            \tstandout(); addch(c + 0x40); standend();\n-            } else {\n-    \t        addch(c);\n-    \t    }\n-    \t}\n-    \tscreen[i] = s;\n-    }\n-}\n-#else\n-# define replace_line(i,s) invalidate_line(i)\n-#endif\n-\n-/* Return up to COLS characters of the line of s starting at pos,\t*/\n-/* returning only characters after the given column.\t\t\t*/\n-CORD retrieve_line(CORD s, size_t pos, unsigned column)\n-{\n-    CORD candidate = CORD_substr(s, pos, column + COLS);\n-    \t\t\t/* avoids scanning very long lines\t*/\n-    int eol = CORD_chr(candidate, 0, '\\n');\n-    int len;\n-    \n-    if (eol == CORD_NOT_FOUND) eol = CORD_len(candidate);\n-    len = (int)eol - (int)column;\n-    if (len < 0) len = 0;\n-    return(CORD_substr(s, pos + column, len));\n-}\n-\n-# ifdef WIN32\n-#   define refresh();\n-\n-    CORD retrieve_screen_line(int i)\n-    {\n-    \tregister size_t pos;\n-    \t\n-    \tinvalidate_map(dis_line + LINES);\t/* Prune search */\n-    \tpos = line_pos(dis_line + i, 0);\n-    \tif (pos == CORD_NOT_FOUND) return(CORD_EMPTY);\n-    \treturn(retrieve_line(current, pos, dis_col));\n-    }\n-# endif\n-\n-/* Display the visible section of the current file\t */\n-void redisplay(void)\n-{\n-    register int i;\n-    \n-    invalidate_map(dis_line + LINES);\t/* Prune search */\n-    for (i = 0; i < LINES; i++) {\n-        if (need_redisplay == ALL || need_redisplay == i) {\n-            register size_t pos = line_pos(dis_line + i, 0);\n-            \n-            if (pos == CORD_NOT_FOUND) break;\n-            replace_line(i, retrieve_line(current, pos, dis_col));\n-            if (need_redisplay == i) goto done;\n-        }\n-    }\n-    for (; i < LINES; i++) replace_line(i, CORD_EMPTY);\n-done:\n-    refresh();\n-    need_redisplay = NONE;\n-}\n-\n-int dis_granularity;\n-\n-/* Update dis_line, dis_col, and dis_pos to make cursor visible.\t*/\n-/* Assumes line, col, dis_line, dis_pos are in bounds.\t\t\t*/\n-void normalize_display()\n-{\n-    int old_line = dis_line;\n-    int old_col = dis_col;\n-    \n-    dis_granularity = 1;\n-    if (LINES > 15 && COLS > 15) dis_granularity = 2;\n-    while (dis_line > line) dis_line -= dis_granularity;\n-    while (dis_col > col) dis_col -= dis_granularity;\n-    while (line >= dis_line + LINES) dis_line += dis_granularity;\n-    while (col >= dis_col + COLS) dis_col += dis_granularity;\n-    if (old_line != dis_line || old_col != dis_col) {\n-        need_redisplay = ALL;\n-    }\n-}\n-\n-# if defined(WIN32)\n-# elif defined(MACINTOSH)\n-#\t\tdefine move_cursor(x,y) cgotoxy(x + 1, y + 1, stdout)\n-# else\n-#\t\tdefine move_cursor(x,y) move(y,x)\n-# endif\n-\n-/* Adjust display so that cursor is visible; move cursor into position\t*/\n-/* Update screen if necessary.\t\t\t\t\t\t*/\n-void fix_cursor(void)\n-{\n-    normalize_display();\n-    if (need_redisplay != NONE) redisplay();\n-    move_cursor(col - dis_col, line - dis_line);\n-    refresh();\n-#   ifndef WIN32\n-      fflush(stdout);\n-#   endif\n-}\n-\n-/* Make sure line, col, and dis_pos are somewhere inside file.\t*/\n-/* Recompute file_pos.\tAssumes dis_pos is accurate or past eof\t*/\n-void fix_pos()\n-{\n-    int my_col = col;\n-    \n-    if ((size_t)line > current_len) line = current_len;\n-    file_pos = line_pos(line, &my_col);\n-    if (file_pos == CORD_NOT_FOUND) {\n-        for (line = current_map -> line, file_pos = current_map -> pos;\n-             file_pos < current_len;\n-             line++, file_pos = CORD_chr(current, file_pos, '\\n') + 1);\n-    \tline--;\n-        file_pos = line_pos(line, &col);\n-    } else {\n-    \tcol = my_col;\n-    }\n-}\n-\n-#if defined(WIN32)\n-#  define beep() Beep(1000 /* Hz */, 300 /* msecs */) \n-#elif defined(MACINTOSH)\n-#\tdefine beep() SysBeep(1)\n-#else\n-/*\n- * beep() is part of some curses packages and not others.\n- * We try to match the type of the builtin one, if any.\n- */\n-#ifdef __STDC__\n-    int beep(void)\n-#else\n-    int beep()\n-#endif\n-{\n-    putc('\\007', stderr);\n-    return(0);\n-}\n-#endif\n-\n-#   define NO_PREFIX -1\n-#   define BARE_PREFIX -2\n-int repeat_count = NO_PREFIX;\t/* Current command prefix. */\n-\n-int locate_mode = 0;\t\t\t/* Currently between 2 ^Ls\t*/\n-CORD locate_string = CORD_EMPTY;\t/* Current search string.\t*/\n-\n-char * arg_file_name;\n-\n-#ifdef WIN32\n-/* Change the current position to whatever is currently displayed at\t*/\n-/* the given SCREEN coordinates.\t\t\t\t\t*/\n-void set_position(int c, int l)\n-{\n-    line = l + dis_line;\n-    col = c + dis_col;\n-    fix_pos();\n-    move_cursor(col - dis_col, line - dis_line);\n-}\n-#endif /* WIN32 */\n-\n-/* Perform the command associated with character c.  C may be an\t*/\n-/* integer > 256 denoting a windows command, one of the above control\t*/\n-/* characters, or another ASCII character to be used as either a \t*/\n-/* character to be inserted, a repeat count, or a search string, \t*/\n-/* depending on the current state.\t\t\t\t\t*/\n-void do_command(int c)\n-{\n-    int i;\n-    int need_fix_pos;\n-    FILE * out;\n-    \n-    if ( c == '\\r') c = '\\n';\n-    if (locate_mode) {\n-        size_t new_pos;\n-          \n-        if (c == LOCATE) {\n-              locate_mode = 0;\n-              locate_string = CORD_EMPTY;\n-              return;\n-        }\n-        locate_string = CORD_cat_char(locate_string, (char)c);\n-        new_pos = CORD_str(current, file_pos - CORD_len(locate_string) + 1,\n-          \t\t   locate_string);\n-        if (new_pos != CORD_NOT_FOUND) {\n-            need_redisplay = ALL;\n-            new_pos += CORD_len(locate_string);\n-            for (;;) {\n-              \tfile_pos = line_pos(line + 1, 0);\n-              \tif (file_pos > new_pos) break;\n-              \tline++;\n-            }\n-            col = new_pos - line_pos(line, 0);\n-            file_pos = new_pos;\n-            fix_cursor();\n-        } else {\n-            locate_string = CORD_substr(locate_string, 0,\n-              \t\t\t\tCORD_len(locate_string) - 1);\n-            beep();\n-        }\n-        return;\n-    }\n-    if (c == REPEAT) {\n-      \trepeat_count = BARE_PREFIX; return;\n-    } else if (c < 0x100 && isdigit(c)){\n-        if (repeat_count == BARE_PREFIX) {\n-          repeat_count = c - '0'; return;\n-        } else if (repeat_count != NO_PREFIX) {\n-          repeat_count = 10 * repeat_count + c - '0'; return;\n-        }\n-    }\n-    if (repeat_count == NO_PREFIX) repeat_count = 1;\n-    if (repeat_count == BARE_PREFIX && (c == UP || c == DOWN)) {\n-      \trepeat_count = LINES - dis_granularity;\n-    }\n-    if (repeat_count == BARE_PREFIX) repeat_count = 8;\n-    need_fix_pos = 0;\n-    for (i = 0; i < repeat_count; i++) {\n-        switch(c) {\n-          case LOCATE:\n-            locate_mode = 1;\n-            break;\n-          case TOP:\n-            line = col = file_pos = 0;\n-            break;\n-     \t  case UP:\n-     \t    if (line != 0) {\n-     \t        line--;\n-     \t        need_fix_pos = 1;\n-     \t    }\n-     \t    break;\n-     \t  case DOWN:\n-     \t    line++;\n-     \t    need_fix_pos = 1;\n-     \t    break;\n-     \t  case LEFT:\n-     \t    if (col != 0) {\n-     \t        col--; file_pos--;\n-     \t    }\n-     \t    break;\n-     \t  case RIGHT:\n-     \t    if (CORD_fetch(current, file_pos) == '\\n') break;\n-     \t    col++; file_pos++;\n-     \t    break;\n-     \t  case UNDO:\n-     \t    del_hist();\n-     \t    need_redisplay = ALL; need_fix_pos = 1;\n-     \t    break;\n-     \t  case BS:\n-     \t    if (col == 0) {\n-     \t        beep();\n-     \t        break;\n-     \t    }\n-     \t    col--; file_pos--;\n-     \t    /* fall through: */\n-     \t  case DEL:\n-     \t    if (file_pos == current_len-1) break;\n-     \t    \t/* Can't delete trailing newline */\n-     \t    if (CORD_fetch(current, file_pos) == '\\n') {\n-     \t        need_redisplay = ALL; need_fix_pos = 1;\n-     \t    } else {\n-     \t        need_redisplay = line - dis_line;\n-     \t    }\n-     \t    add_hist(CORD_cat(\n-     \t    \t\tCORD_substr(current, 0, file_pos),\n-     \t    \t\tCORD_substr(current, file_pos+1, current_len)));\n-     \t    invalidate_map(line);\n-     \t    break;\n-     \t  case WRITE:\n-\t    {\n-  \t\tCORD name = CORD_cat(CORD_from_char_star(arg_file_name),\n-\t\t\t\t     \".new\");\n-\n-    \t        if ((out = fopen(CORD_to_const_char_star(name), \"wb\")) == NULL\n-  \t            || CORD_put(current, out) == EOF) {\n-        \t    de_error(\"Write failed\\n\");\n-        \t    need_redisplay = ALL;\n-                } else {\n-                    fclose(out);\n-                }\n-\t    }\n-            break;\n-     \t  default:\n-     \t    {\n-     \t        CORD left_part = CORD_substr(current, 0, file_pos);\n-     \t        CORD right_part = CORD_substr(current, file_pos, current_len);\n-     \t        \n-     \t        add_hist(CORD_cat(CORD_cat_char(left_part, (char)c),\n-     \t        \t\t  right_part));\n-     \t        invalidate_map(line);\n-     \t        if (c == '\\n') {\n-     \t            col = 0; line++; file_pos++;\n-     \t            need_redisplay = ALL;\n-     \t        } else {\n-     \t            col++; file_pos++;\n-     \t            need_redisplay = line - dis_line;\n-     \t    \t}\n-     \t        break;\n-     \t    }\n-        }\n-    }\n-    if (need_fix_pos) fix_pos();\n-    fix_cursor();\n-    repeat_count = NO_PREFIX;\n-}\n-\n-/* OS independent initialization */\n-\n-void generic_init(void)\n-{\n-    FILE * f;\n-    CORD initial;\n-    \n-    if ((f = fopen(arg_file_name, \"rb\")) == NULL) {\n-     \tinitial = \"\\n\";\n-    } else {\n-        initial = CORD_from_file(f);\n-        if (initial == CORD_EMPTY\n-            || CORD_fetch(initial, CORD_len(initial)-1) != '\\n') {\n-            initial = CORD_cat(initial, \"\\n\");\n-        }\n-    }\n-    add_map(0,0);\n-    add_hist(initial);\n-    now -> map = current_map;\n-    now -> previous = now;  /* Can't back up further: beginning of the world */\n-    need_redisplay = ALL;\n-    fix_cursor();\n-}\n-\n-#ifndef WIN32\n-\n-main(argc, argv)\n-int argc;\n-char ** argv;\n-{\n-    int c;\n-\n-#if defined(MACINTOSH)\n-\tconsole_options.title = \"\\pDumb Editor\";\n-\tcshow(stdout);\n-\targc = ccommand(&argv);\n-#endif\n-    GC_INIT();\n-    \n-    if (argc != 2) goto usage;\n-    arg_file_name = argv[1];\n-    setvbuf(stdout, GC_MALLOC_ATOMIC(8192), _IOFBF, 8192);\n-    initscr();\n-    noecho(); nonl(); cbreak();\n-    generic_init();\n-    while ((c = getchar()) != QUIT) {\n-\t\tif (c == EOF) break;\n-\t    do_command(c);\n-    }\n-done:\n-    move(LINES-1, 0);\n-    clrtoeol();\n-    refresh();\n-    nl();\n-    echo();\n-    endwin();\n-    exit(0);\n-usage:\n-    fprintf(stderr, \"Usage: %s file\\n\", argv[0]);\n-    fprintf(stderr, \"Cursor keys: ^B(left) ^F(right) ^P(up) ^N(down)\\n\");\n-    fprintf(stderr, \"Undo: ^U    Write to <file>.new: ^W\");\n-    fprintf(stderr, \"Quit:^D  Repeat count: ^R[n]\\n\");\n-    fprintf(stderr, \"Top: ^T   Locate (search, find): ^L text ^L\\n\");\n-    exit(1);\n-}\n-\n-#endif  /* !WIN32 */"}, {"sha": "f42ddcf2da73a604ec06aed74fe3c85be33fb1ca", "filename": "boehm-gc/cord/de_cmds.h", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fcord%2Fde_cmds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fcord%2Fde_cmds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fde_cmds.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,33 +0,0 @@\n-/*\n- * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n-/* Boehm, May 19, 1994 2:24 pm PDT */\n-\n-#ifndef DE_CMDS_H\n-\n-# define DE_CMDS_H\n-\n-# define UP     16\t/* ^P */\n-# define DOWN   14\t/* ^N */\n-# define LEFT   2\t/* ^B */\n-# define RIGHT  6\t/* ^F */\n-# define DEL\t127\t/* ^? */\n-# define BS     8\t/* ^H */\n-# define UNDO   21\t/* ^U */\n-# define WRITE  23\t/* ^W */\n-# define QUIT   4\t/* ^D */\n-# define REPEAT 18\t/* ^R */\n-# define LOCATE 12\t/* ^L */\n-# define TOP    20\t/* ^T */\n-\n-#endif\n-"}, {"sha": "b20ac3ee16a9c8751e2ee6ce3c757dfb1f687258", "filename": "boehm-gc/cord/de_win.ICO", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fcord%2Fde_win.ICO", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fcord%2Fde_win.ICO", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fde_win.ICO?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "554a300438911826f4151aebcae89dccf264b2a3", "filename": "boehm-gc/cord/de_win.RC", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fcord%2Fde_win.RC", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fcord%2Fde_win.RC", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fde_win.RC?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,78 +0,0 @@\n-/*\n- * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to copy this garbage collector for any purpose,\n- * provided the above notices are retained on all copies.\n- */\n-/* Boehm, May 13, 1994 9:50 am PDT */\n-\n-#include \"windows.h\"\n-#include \"de_cmds.h\"\n-#include \"de_win.h\"\n-\n-\n-\n-ABOUTBOX DIALOG 19, 21, 163, 47\n-STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU\n-CAPTION \"About Demonstration Text Editor\"\n-BEGIN\n-\tICON \"DE\", -1, 8, 8, 13, 13, WS_CHILD | WS_VISIBLE\n-\tLTEXT \"Demonstration Text Editor\", -1, 44, 8, 118, 8, WS_CHILD | WS_VISIBLE | WS_GROUP\n-\tLTEXT \"Version 4.1\", -1, 44, 16, 60, 8, WS_CHILD | WS_VISIBLE | WS_GROUP\n-\tPUSHBUTTON \"OK\", IDOK, 118, 27, 24, 14, WS_CHILD | WS_VISIBLE | WS_TABSTOP\n-END\n-\n-\n-DE MENU \n-BEGIN\n-\tPOPUP \"&File\"\n-\tBEGIN\n-\t\tMENUITEM \"&Save\\t^W\", IDM_FILESAVE\n-\t\tMENUITEM \"E&xit\\t^D\", IDM_FILEEXIT\n-\tEND\n-\n-\tPOPUP \"&Edit\"\n-\tBEGIN\n-\t    MENUITEM \"Page &Down\\t^R^N\", IDM_EDITPDOWN\n-\t    MENUITEM \"Page &Up\\t^R^P\", IDM_EDITPUP\n-\t\tMENUITEM \"U&ndo\\t^U\", IDM_EDITUNDO\n-\t\tMENUITEM \"&Locate\\t^L ... ^L\", IDM_EDITLOCATE\n-\t\tMENUITEM \"D&own\\t^N\", IDM_EDITDOWN\n-\t    MENUITEM \"U&p\\t^P\", IDM_EDITUP\n-\t    MENUITEM \"Le&ft\\t^B\", IDM_EDITLEFT\n-\t    MENUITEM \"&Right\\t^F\", IDM_EDITRIGHT\n-\t    MENUITEM \"Delete &Backward\\tBS\", IDM_EDITBS\n-\t    MENUITEM \"Delete F&orward\\tDEL\", IDM_EDITDEL\n-\t    MENUITEM \"&Top\\t^T\", IDM_EDITTOP\n-\tEND\n-\t\n-\tPOPUP \"&Help\"\n-\tBEGIN\n-\t\tMENUITEM \"&Contents\", IDM_HELPCONTENTS\n-\t\tMENUITEM \"&About...\", IDM_HELPABOUT\n-\tEND\n-\t\n-\tMENUITEM \"Page_&Down\", IDM_EDITPDOWN\n-\tMENUITEM \"Page_&Up\", IDM_EDITPUP\n-END\n-\n-\n-DE ACCELERATORS \n-BEGIN\n-    \"^R\", IDM_EDITREPEAT\n-    \"^N\", IDM_EDITDOWN\n-    \"^P\", IDM_EDITUP\n-    \"^L\", IDM_EDITLOCATE\n-    \"^B\", IDM_EDITLEFT\n-    \"^F\", IDM_EDITRIGHT\n-    \"^T\", IDM_EDITTOP\n-\tVK_DELETE, IDM_EDITDEL, VIRTKEY\n-\tVK_BACK, IDM_EDITBS, VIRTKEY\n-END\n-\n-\n-DE ICON cord\\de_win.ICO\n-"}, {"sha": "0bbd676a3355d226eaf9e3d56895c7b9f6c95340", "filename": "boehm-gc/cord/de_win.c", "status": "removed", "additions": 0, "deletions": 366, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fcord%2Fde_win.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fcord%2Fde_win.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fde_win.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,366 +0,0 @@\n-/*\n- * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n-/* Boehm, February 6, 1995 12:29 pm PST */\n-\n-/*\n- * The MS Windows specific part of de.  \n- * This started as the generic Windows application template\n- * made available by Rob Haack (rhaack@polaris.unm.edu), but\n- * significant parts didn't survive to the final version.\n- *\n- * This was written by a nonexpert windows programmer.\n- */\n-\n-\n-#include \"windows.h\"\n-#include \"gc.h\"\n-#include \"cord.h\"\n-#include \"de_cmds.h\"\n-#include \"de_win.h\"\n-\n-int LINES = 0;\n-int COLS = 0;\n-\n-char       szAppName[]     = \"DE\";\n-char       FullAppName[]   = \"Demonstration Editor\";\n-\n-HWND        hwnd;\n-\n-void de_error(char *s)\n-{\n-    MessageBox( hwnd, (LPSTR) s,\n-                (LPSTR) FullAppName,\n-                MB_ICONINFORMATION | MB_OK );\n-    InvalidateRect(hwnd, NULL, TRUE);\n-}\n-\n-int APIENTRY WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,\n-                      LPSTR command_line, int nCmdShow)\n-{\n-   MSG         msg;\n-   WNDCLASS    wndclass;\n-   HANDLE      hAccel;\n-\n-   if (!hPrevInstance)\n-   {\n-      wndclass.style          = CS_HREDRAW | CS_VREDRAW;\n-      wndclass.lpfnWndProc    = WndProc;\n-      wndclass.cbClsExtra     = 0;\n-      wndclass.cbWndExtra     = DLGWINDOWEXTRA;\n-      wndclass.hInstance      = hInstance;\n-      wndclass.hIcon          = LoadIcon (hInstance, szAppName);\n-      wndclass.hCursor        = LoadCursor (NULL, IDC_ARROW);\n-      wndclass.hbrBackground  = GetStockObject(WHITE_BRUSH);\n-      wndclass.lpszMenuName   = \"DE\";\n-      wndclass.lpszClassName  = szAppName;\n-\n-      if (RegisterClass (&wndclass) == 0) {\n-          char buf[50];\n-   \t\n-   \t  sprintf(buf, \"RegisterClass: error code: 0x%X\", GetLastError());\n-   \t  de_error(buf);\n-   \t  return(0);\n-      }\n-   }\n-   \n-   /* Empirically, the command line does not include the command name ...\n-   if (command_line != 0) {\n-       while (isspace(*command_line)) command_line++;\n-       while (*command_line != 0 && !isspace(*command_line)) command_line++;\n-       while (isspace(*command_line)) command_line++;\n-   } */\n-   \n-   if (command_line == 0 || *command_line == 0) {\n-        de_error(\"File name argument required\");\n-        return( 0 );\n-   } else {\n-        char *p = command_line;\n-        \n-        while (*p != 0 && !isspace(*p)) p++;\n-   \targ_file_name = CORD_to_char_star(\n-   \t\t\t    CORD_substr(command_line, 0, p - command_line));\n-   }\n-\n-   hwnd = CreateWindow (szAppName,\n-   \t\t\tFullAppName,\n-   \t\t\tWS_OVERLAPPEDWINDOW | WS_CAPTION, /* Window style */\n-   \t\t\tCW_USEDEFAULT, 0, /* default pos. */\n-   \t\t\tCW_USEDEFAULT, 0, /* default width, height */\n-   \t\t\tNULL,\t/* No parent */\n-   \t\t\tNULL, \t/* Window class menu */\n-   \t\t\thInstance, NULL);\n-   if (hwnd == NULL) {\n-   \tchar buf[50];\n-   \t\n-   \tsprintf(buf, \"CreateWindow: error code: 0x%X\", GetLastError());\n-   \tde_error(buf);\n-   \treturn(0);\n-   }\n-\n-   ShowWindow (hwnd, nCmdShow);\n-\n-   hAccel = LoadAccelerators( hInstance, szAppName );\n-   \n-   while (GetMessage (&msg, NULL, 0, 0))\n-   {\n-      if( !TranslateAccelerator( hwnd, hAccel, &msg ) )\n-      {\n-         TranslateMessage (&msg);\n-         DispatchMessage (&msg);\n-      }\n-   }\n-   return msg.wParam;\n-}\n-\n-/* Return the argument with all control characters replaced by blanks.\t*/\n-char * plain_chars(char * text, size_t len)\n-{\n-    char * result = GC_MALLOC_ATOMIC(len + 1);\n-    register size_t i;\n-    \n-    for (i = 0; i < len; i++) {\n-       if (iscntrl(text[i])) {\n-           result[i] = ' ';\n-       } else {\n-           result[i] = text[i];\n-       }\n-    }\n-    result[len] = '\\0';\n-    return(result);\n-}\n-\n-/* Return the argument with all non-control-characters replaced by \t*/\n-/* blank, and all control characters c replaced by c + 32.\t\t*/\n-char * control_chars(char * text, size_t len)\n-{\n-    char * result = GC_MALLOC_ATOMIC(len + 1);\n-    register size_t i;\n-    \n-    for (i = 0; i < len; i++) {\n-       if (iscntrl(text[i])) {\n-           result[i] = text[i] + 0x40;\n-       } else {\n-           result[i] = ' ';\n-       }\n-    }\n-    result[len] = '\\0';\n-    return(result);\n-}\n-\n-int char_width;\n-int char_height;\n-\n-void get_line_rect(int line, int win_width, RECT * rectp)\n-{\n-    rectp -> top = line * char_height;\n-    rectp -> bottom = rectp->top + char_height;\n-    rectp -> left = 0;\n-    rectp -> right = win_width;\n-}\n-\n-int caret_visible = 0;\t/* Caret is currently visible.\t*/\n-\n-int screen_was_painted = 0;/* Screen has been painted at least once.\t*/\n-\n-void update_cursor(void);\n-\n-LRESULT CALLBACK WndProc (HWND hwnd, UINT message,\n-                          WPARAM wParam, LPARAM lParam)\n-{\n-   static FARPROC lpfnAboutBox;\n-   static HANDLE  hInstance;\n-   HDC dc;\n-   PAINTSTRUCT ps;\n-   RECT client_area;\n-   RECT this_line;\n-   RECT dummy;\n-   TEXTMETRIC tm;\n-   register int i;\n-   int id;\n-\n-   switch (message)\n-   {\n-      case WM_CREATE:\n-           hInstance = ( (LPCREATESTRUCT) lParam)->hInstance;\n-           lpfnAboutBox = MakeProcInstance( (FARPROC) AboutBox, hInstance );\n-           dc = GetDC(hwnd);\n-           SelectObject(dc, GetStockObject(SYSTEM_FIXED_FONT));\n-           GetTextMetrics(dc, &tm);\n-           ReleaseDC(hwnd, dc);\n-           char_width = tm.tmAveCharWidth;\n-           char_height = tm.tmHeight + tm.tmExternalLeading;\n-           GetClientRect(hwnd, &client_area);\n-      \t   COLS = (client_area.right - client_area.left)/char_width;\n-      \t   LINES = (client_area.bottom - client_area.top)/char_height;\n-      \t   generic_init();\n-           return(0);\n-\n-      case WM_CHAR:\n-      \t   if (wParam == QUIT) {\n-      \t       SendMessage( hwnd, WM_CLOSE, 0, 0L );\n-      \t   } else {\n-      \t       do_command(wParam);\n-      \t   }\n-      \t   return(0);\n-      \n-      case WM_SETFOCUS:\n-      \t   CreateCaret(hwnd, NULL, char_width, char_height);\n-      \t   ShowCaret(hwnd);\n-      \t   caret_visible = 1;\n-      \t   update_cursor();\n-      \t   return(0);\n-      \t   \n-      case WM_KILLFOCUS:\n-      \t   HideCaret(hwnd);\n-      \t   DestroyCaret();\n-      \t   caret_visible = 0;\n-      \t   return(0);\n-      \t   \n-      case WM_LBUTTONUP:\n-      \t   {\n-      \t       unsigned xpos = LOWORD(lParam);\t/* From left\t*/\n-      \t       unsigned ypos = HIWORD(lParam);\t/* from top */\n-      \t       \n-      \t       set_position( xpos/char_width, ypos/char_height );\n-      \t       return(0);\n-      \t   }\n-      \t   \n-      case WM_COMMAND:\n-      \t   id = LOWORD(wParam);\n-      \t   if (id & EDIT_CMD_FLAG) {\n-               if (id & REPEAT_FLAG) do_command(REPEAT);\n-               do_command(CHAR_CMD(id));\n-               return( 0 );\n-           } else {\n-             switch(id) {\n-               case IDM_FILEEXIT:\n-                  SendMessage( hwnd, WM_CLOSE, 0, 0L );\n-                  return( 0 );\n-\n-               case IDM_HELPABOUT:\n-                  if( DialogBox( hInstance, \"ABOUTBOX\",\n-                                 hwnd, lpfnAboutBox ) )\n-                     InvalidateRect( hwnd, NULL, TRUE );\n-                  return( 0 );\n-\t       case IDM_HELPCONTENTS:\n-\t     \t  de_error(\n-\t     \t       \"Cursor keys: ^B(left) ^F(right) ^P(up) ^N(down)\\n\"\n-\t     \t       \"Undo: ^U    Write: ^W   Quit:^D  Repeat count: ^R[n]\\n\"\n-\t     \t       \"Top: ^T   Locate (search, find): ^L text ^L\\n\");\n-\t     \t  return( 0 );\n-\t     }\n-\t   }\n-           break;\n-\n-      case WM_CLOSE:\n-           DestroyWindow( hwnd );\n-           return 0;\n-\n-      case WM_DESTROY:\n-           PostQuitMessage (0);\n-\t   GC_win32_free_heap();\n-           return 0;\n-      \n-      case WM_PAINT:\n-      \t   dc = BeginPaint(hwnd, &ps);\n-      \t   GetClientRect(hwnd, &client_area);\n-      \t   COLS = (client_area.right - client_area.left)/char_width;\n-      \t   LINES = (client_area.bottom - client_area.top)/char_height;\n-      \t   SelectObject(dc, GetStockObject(SYSTEM_FIXED_FONT));\n-      \t   for (i = 0; i < LINES; i++) {\n-      \t       get_line_rect(i, client_area.right, &this_line);\n-      \t       if (IntersectRect(&dummy, &this_line, &ps.rcPaint)) {\n-      \t           CORD raw_line = retrieve_screen_line(i);\n-      \t           size_t len = CORD_len(raw_line);\n-      \t           char * text = CORD_to_char_star(raw_line);\n-      \t           \t\t/* May contain embedded NULLs\t*/\n-      \t           char * plain = plain_chars(text, len);\n-      \t           char * blanks = CORD_to_char_star(CORD_chars(' ',\n-      \t           \t\t\t\t                COLS - len));\n-      \t           char * control = control_chars(text, len);\n-#\t\t   define RED RGB(255,0,0)\n-      \t           \n-      \t           SetBkMode(dc, OPAQUE);\n-      \t           SetTextColor(dc, GetSysColor(COLOR_WINDOWTEXT));\n-      \t           \n-      \t           TextOut(dc, this_line.left, this_line.top,\n-      \t           \t   plain, len);\n-      \t           TextOut(dc, this_line.left + len * char_width, this_line.top,\n-      \t           \t   blanks, COLS - len);\n-      \t           SetBkMode(dc, TRANSPARENT);\n-      \t           SetTextColor(dc, RED);\n-      \t           TextOut(dc, this_line.left, this_line.top,\n-      \t           \t   control, strlen(control));\n-      \t       }\n-      \t   }\n-      \t   EndPaint(hwnd, &ps);\n-      \t   screen_was_painted = 1;\n-      \t   return 0;\n-   }\n-   return DefWindowProc (hwnd, message, wParam, lParam);\n-}\n-\n-int last_col;\n-int last_line;\n-\n-void move_cursor(int c, int l)\n-{\n-    last_col = c;\n-    last_line = l;\n-    \n-    if (caret_visible) update_cursor();\n-}\n-\n-void update_cursor(void)\n-{\n-    SetCaretPos(last_col * char_width, last_line * char_height);\n-    ShowCaret(hwnd);\n-}\n-\n-void invalidate_line(int i)\n-{\n-    RECT line;\n-    \n-    if (!screen_was_painted) return;\n-    \t/* Invalidating a rectangle before painting seems result in a\t*/\n-    \t/* major performance problem.\t\t\t\t\t*/\n-    get_line_rect(i, COLS*char_width, &line);\n-    InvalidateRect(hwnd, &line, FALSE);\n-}\n-\n-LRESULT CALLBACK AboutBox( HWND hDlg, UINT message,\n-                           WPARAM wParam, LPARAM lParam )\n-{\n-   switch( message )\n-   {\n-      case WM_INITDIALOG:\n-           SetFocus( GetDlgItem( hDlg, IDOK ) );\n-           break;\n-\n-      case WM_COMMAND:\n-           switch( wParam )\n-           {\n-              case IDOK:\n-                   EndDialog( hDlg, TRUE );\n-                   break;\n-           }\n-           break;\n-\n-      case WM_CLOSE:\n-           EndDialog( hDlg, TRUE );\n-           return TRUE;\n-\n-   }\n-   return FALSE;\n-}\n-"}, {"sha": "57a47b45c4170d0ef8eadd0c1c07d3027a0a9a1a", "filename": "boehm-gc/cord/de_win.h", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fcord%2Fde_win.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fcord%2Fde_win.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fde_win.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,103 +0,0 @@\n-/*\n- * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n-/* Boehm, May 19, 1994 2:25 pm PDT */\n-\n-/* cord.h, de_cmds.h, and windows.h should be included before this. */\n-\n-\n-# define OTHER_FLAG\t0x100\n-# define EDIT_CMD_FLAG\t0x200\n-# define REPEAT_FLAG\t0x400\n-\n-# define CHAR_CMD(i) ((i) & 0xff)\n-\n-/* MENU: DE */\n-#define IDM_FILESAVE\t\t(EDIT_CMD_FLAG + WRITE)\n-#define IDM_FILEEXIT\t\t(OTHER_FLAG + 1)\n-#define IDM_HELPABOUT\t\t(OTHER_FLAG + 2)\n-#define IDM_HELPCONTENTS\t(OTHER_FLAG + 3)\n-\n-#define IDM_EDITPDOWN\t\t(REPEAT_FLAG + EDIT_CMD_FLAG + DOWN)\n-#define IDM_EDITPUP\t\t(REPEAT_FLAG + EDIT_CMD_FLAG + UP)\n-#define IDM_EDITUNDO\t\t(EDIT_CMD_FLAG + UNDO)\n-#define IDM_EDITLOCATE\t\t(EDIT_CMD_FLAG + LOCATE)\n-#define IDM_EDITDOWN\t\t(EDIT_CMD_FLAG + DOWN)\n-#define IDM_EDITUP\t\t(EDIT_CMD_FLAG + UP)\n-#define IDM_EDITLEFT\t\t(EDIT_CMD_FLAG + LEFT)\n-#define IDM_EDITRIGHT\t\t(EDIT_CMD_FLAG + RIGHT)\n-#define IDM_EDITBS\t\t(EDIT_CMD_FLAG + BS)\n-#define IDM_EDITDEL\t\t(EDIT_CMD_FLAG + DEL)\n-#define IDM_EDITREPEAT\t\t(EDIT_CMD_FLAG + REPEAT)\n-#define IDM_EDITTOP\t\t(EDIT_CMD_FLAG + TOP)\n-\n-\n-\n-\n-/* Windows UI stuff\t*/\n-\n-LRESULT CALLBACK WndProc (HWND hwnd, UINT message,\n-\t\t\t  UINT wParam, LONG lParam);\n-\n-LRESULT CALLBACK AboutBox( HWND hDlg, UINT message,\n-\t\t\t   UINT wParam, LONG lParam );\n-\n-\n-/* Screen dimensions.  Maintained by de_win.c.\t*/\n-extern int LINES;\n-extern int COLS;\n-\n-/* File being edited.\t*/\n-extern char * arg_file_name;\n-\n-/* Current display position in file.  Maintained by de.c\t*/\n-extern int dis_line;\n-extern int dis_col;\n-\n-/* Current cursor position in file.\t\t\t\t*/\n-extern int line;\n-extern int col;\n-\n-/*\n- *  Calls from de_win.c to de.c\n- */\n-  \n-CORD retrieve_screen_line(int i);\n-\t\t\t/* Get the contents of i'th screen line.\t*/\n-\t\t\t/* Relies on COLS.\t\t\t\t*/\n-\n-void set_position(int x, int y);\n-\t\t\t/* Set column, row.  Upper left of window = (0,0). */\n-\n-void do_command(int);\n-\t\t\t/* Execute an editor command.\t\t\t*/\n-\t\t\t/* Agument is a command character or one\t*/\n-\t\t\t/* of the IDM_ commands.\t\t\t*/\n-\n-void generic_init(void);\n-\t\t\t/* OS independent initialization */\n-\n-\n-/*\n- * Calls from de.c to de_win.c\n- */\n- \n-void move_cursor(int column, int line);\n-\t\t\t/* Physically move the cursor on the display,\t*/\n-\t\t\t/* so that it appears at\t\t\t*/\n-\t\t\t/* (column, line).\t\t\t\t*/\n-\n-void invalidate_line(int line);\n-\t\t\t/* Invalidate line i on the screen.\t*/\n-\n-void de_error(char *s);\n-\t\t\t/* Display error message.\t*/\n\\ No newline at end of file"}, {"sha": "719b1b02d35ee474f7e4b0d9242c410fa59dc559", "filename": "boehm-gc/darwin_stop_world.c", "status": "removed", "additions": 0, "deletions": 510, "changes": 510, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdarwin_stop_world.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdarwin_stop_world.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdarwin_stop_world.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696", "patch": "@@ -1,510 +0,0 @@\n-#include \"private/pthread_support.h\"\n-\n-/* This probably needs more porting work to ppc64. */\n-\n-# if defined(GC_DARWIN_THREADS)\n-\n-/* From \"Inside Mac OS X - Mach-O Runtime Architecture\" published by Apple\n-   Page 49:\n-   \"The space beneath the stack pointer, where a new stack frame would normally\n-   be allocated, is called the red zone. This area as shown in Figure 3-2 may\n-   be used for any purpose as long as a new stack frame does not need to be\n-   added to the stack.\"\n-\n-   Page 50: \"If a leaf procedure's red zone usage would exceed 224 bytes, then\n-   it must set up a stack frame just like routines that call other routines.\"\n-*/\n-#if defined(__ppc__)\n-# define PPC_RED_ZONE_SIZE 224\n-#elif defined(__ppc64__)\n-# define PPC_RED_ZONE_SIZE 320\n-#endif\n-\n-typedef struct StackFrame {\n-  unsigned long\tsavedSP;\n-  unsigned long\tsavedCR;\n-  unsigned long\tsavedLR;\n-  unsigned long\treserved[2];\n-  unsigned long\tsavedRTOC;\n-} StackFrame;\n-\n-unsigned long FindTopOfStack(unsigned long stack_start) {\n-  StackFrame\t*frame;\n-  \n-  if (stack_start == 0) {\n-# ifdef POWERPC\n-#   if CPP_WORDSZ == 32\n-      __asm__ volatile(\"lwz\t%0,0(r1)\" : \"=r\" (frame));\n-#   else\n-      __asm__ volatile(\"ld\t%0,0(r1)\" : \"=r\" (frame));\n-#   endif\n-# endif\n-  } else {\n-    frame = (StackFrame *)stack_start;\n-  }\n-\n-# ifdef DEBUG_THREADS\n-    /* GC_printf1(\"FindTopOfStack start at sp = %p\\n\", frame); */\n-# endif\n-  do {\n-    if (frame->savedSP == 0) break;\n-    \t\t/* if there are no more stack frames, stop */\n-\n-    frame = (StackFrame*)frame->savedSP;\n-\n-    /* we do these next two checks after going to the next frame\n-       because the LR for the first stack frame in the loop\n-       is not set up on purpose, so we shouldn't check it. */\n-    if ((frame->savedLR & ~3) == 0) break; /* if the next LR is bogus, stop */\n-    if ((~(frame->savedLR) & ~3) == 0) break; /* ditto */\n-  } while (1); \n-\n-# ifdef DEBUG_THREADS\n-    /* GC_printf1(\"FindTopOfStack finish at sp = %p\\n\", frame); */\n-# endif\n-\n-  return (unsigned long)frame;\n-}\t\n-\n-#ifdef DARWIN_DONT_PARSE_STACK\n-void GC_push_all_stacks() {\n-  int i;\n-  kern_return_t r;\n-  GC_thread p;\n-  pthread_t me;\n-  ptr_t lo, hi;\n-  GC_THREAD_STATE_T state;\n-  mach_msg_type_number_t thread_state_count = GC_MACH_THREAD_STATE_COUNT;\n-  \n-  me = pthread_self();\n-  if (!GC_thr_initialized) GC_thr_init();\n-  \n-  for(i=0;i<THREAD_TABLE_SZ;i++) {\n-    for(p=GC_threads[i];p!=0;p=p->next) {\n-      if(p -> flags & FINISHED) continue;\n-      if(pthread_equal(p->id,me)) {\n-\tlo = GC_approx_sp();\n-      } else {\n-\t/* Get the thread state (registers, etc) */\n-\tr = thread_get_state(p->stop_info.mach_thread, GC_MACH_THREAD_STATE,\n-\t\t\t     (natural_t*)&state, &thread_state_count);\n-\tif(r != KERN_SUCCESS) ABORT(\"thread_get_state failed\");\n-\n-#if defined(I386)\n-\tlo = (void*)state . THREAD_FLD (esp);\n-\n-\tGC_push_one(state . THREAD_FLD (eax)); \n-\tGC_push_one(state . THREAD_FLD (ebx)); \n-\tGC_push_one(state . THREAD_FLD (ecx)); \n-\tGC_push_one(state . THREAD_FLD (edx)); \n-\tGC_push_one(state . THREAD_FLD (edi)); \n-\tGC_push_one(state . THREAD_FLD (esi)); \n-\tGC_push_one(state . THREAD_FLD (ebp));\n-\n-#elif defined(X86_64)\n-\tlo = (void*)state . THREAD_FLD (rsp);\n-\n-\tGC_push_one(state . THREAD_FLD (rax));\n-\tGC_push_one(state . THREAD_FLD (rbx));\n-\tGC_push_one(state . THREAD_FLD (rcx));\n-\tGC_push_one(state . THREAD_FLD (rdx));\n-\tGC_push_one(state . THREAD_FLD (rdi));\n-\tGC_push_one(state . THREAD_FLD (rsi));\n-\tGC_push_one(state . THREAD_FLD (rbp));\n-\tGC_push_one(state . THREAD_FLD (rsp));\n-\tGC_push_one(state . THREAD_FLD (r8));\n-\tGC_push_one(state . THREAD_FLD (r9));\n-\tGC_push_one(state . THREAD_FLD (r10));\n-\tGC_push_one(state . THREAD_FLD (r11));\n-\tGC_push_one(state . THREAD_FLD (r12));\n-\tGC_push_one(state . THREAD_FLD (r13));\n-\tGC_push_one(state . THREAD_FLD (r14));\n-\tGC_push_one(state . THREAD_FLD (r15));\n-\tGC_push_one(state . THREAD_FLD (rip));\n-\tGC_push_one(state . THREAD_FLD (rflags));\n-\tGC_push_one(state . THREAD_FLD (cs));\n-\tGC_push_one(state . THREAD_FLD (fs));\n-\tGC_push_one(state . THREAD_FLD (gs));\n-\n-#elif defined(POWERPC)\n-\tlo = (void*)(state . THREAD_FLD (r1) - PPC_RED_ZONE_SIZE);\n-        \n-\tGC_push_one(state . THREAD_FLD (r0)); \n-\tGC_push_one(state . THREAD_FLD (r2)); \n-\tGC_push_one(state . THREAD_FLD (r3)); \n-\tGC_push_one(state . THREAD_FLD (r4)); \n-\tGC_push_one(state . THREAD_FLD (r5)); \n-\tGC_push_one(state . THREAD_FLD (r6)); \n-\tGC_push_one(state . THREAD_FLD (r7)); \n-\tGC_push_one(state . THREAD_FLD (r8)); \n-\tGC_push_one(state . THREAD_FLD (r9)); \n-\tGC_push_one(state . THREAD_FLD (r10)); \n-\tGC_push_one(state . THREAD_FLD (r11)); \n-\tGC_push_one(state . THREAD_FLD (r12)); \n-\tGC_push_one(state . THREAD_FLD (r13)); \n-\tGC_push_one(state . THREAD_FLD (r14)); \n-\tGC_push_one(state . THREAD_FLD (r15)); \n-\tGC_push_one(state . THREAD_FLD (r16)); \n-\tGC_push_one(state . THREAD_FLD (r17)); \n-\tGC_push_one(state . THREAD_FLD (r18)); \n-\tGC_push_one(state . THREAD_FLD (r19)); \n-\tGC_push_one(state . THREAD_FLD (r20)); \n-\tGC_push_one(state . THREAD_FLD (r21)); \n-\tGC_push_one(state . THREAD_FLD (r22)); \n-\tGC_push_one(state . THREAD_FLD (r23)); \n-\tGC_push_one(state . THREAD_FLD (r24)); \n-\tGC_push_one(state . THREAD_FLD (r25)); \n-\tGC_push_one(state . THREAD_FLD (r26)); \n-\tGC_push_one(state . THREAD_FLD (r27)); \n-\tGC_push_one(state . THREAD_FLD (r28)); \n-\tGC_push_one(state . THREAD_FLD (r29)); \n-\tGC_push_one(state . THREAD_FLD (r30)); \n-\tGC_push_one(state . THREAD_FLD (r31));\n-#else\n-# error FIXME for non-x86 || ppc architectures\n-#endif\n-      } /* p != me */\n-      if(p->flags & MAIN_THREAD)\n-\thi = GC_stackbottom;\n-      else\n-\thi = p->stack_end;\n-#if DEBUG_THREADS\n-      GC_printf3(\"Darwin: Stack for thread 0x%lx = [%lx,%lx)\\n\",\n-\t\t (unsigned long) p -> id,\n-\t\t (unsigned long) lo,\n-\t\t (unsigned long) hi\n-\t\t );\n-#endif\n-      GC_push_all_stack(lo,hi);\n-    } /* for(p=GC_threads[i]...) */\n-  } /* for(i=0;i<THREAD_TABLE_SZ...) */\n-}\n-\n-#else /* !DARWIN_DONT_PARSE_STACK; Use FindTopOfStack() */\n-\n-void GC_push_all_stacks() {\n-    int i;\n-    kern_return_t r;\n-    mach_port_t me;\n-    ptr_t lo, hi;\n-    thread_act_array_t act_list = 0;\n-    mach_msg_type_number_t listcount = 0;\n-\n-    me = mach_thread_self();\n-    if (!GC_thr_initialized) GC_thr_init();\n-    \n-    r = task_threads(current_task(), &act_list, &listcount);\n-    if(r != KERN_SUCCESS) ABORT(\"task_threads failed\");\n-    for(i = 0; i < listcount; i++) {\n-      thread_act_t thread = act_list[i];\n-      if (thread == me) {\n-\tlo = GC_approx_sp();\n-\thi = (ptr_t)FindTopOfStack(0);\n-      } else {\n-#     if defined(__ppc__) || defined(__ppc64__)\n-\tGC_THREAD_STATE_T info;\n-\tmach_msg_type_number_t outCount = THREAD_STATE_MAX;\n-\tr = thread_get_state(thread, GC_MACH_THREAD_STATE,\n-\t\t\t     (natural_t *)&info, &outCount);\n-\tif(r != KERN_SUCCESS) ABORT(\"task_get_state failed\");\n-\n-\tlo = (void*)(info . THREAD_FLD (r1) - PPC_RED_ZONE_SIZE);\n-\thi = (ptr_t)FindTopOfStack(info . THREAD_FLD (r1));\n-\n-\tGC_push_one(info . THREAD_FLD (r0)); \n-\tGC_push_one(info . THREAD_FLD (r2)); \n-\tGC_push_one(info . THREAD_FLD (r3)); \n-\tGC_push_one(info . THREAD_FLD (r4)); \n-\tGC_push_one(info . THREAD_FLD (r5)); \n-\tGC_push_one(info . THREAD_FLD (r6)); \n-\tGC_push_one(info . THREAD_FLD (r7)); \n-\tGC_push_one(info . THREAD_FLD (r8)); \n-\tGC_push_one(info . THREAD_FLD (r9)); \n-\tGC_push_one(info . THREAD_FLD (r10)); \n-\tGC_push_one(info . THREAD_FLD (r11)); \n-\tGC_push_one(info . THREAD_FLD (r12)); \n-\tGC_push_one(info . THREAD_FLD (r13)); \n-\tGC_push_one(info . THREAD_FLD (r14)); \n-\tGC_push_one(info . THREAD_FLD (r15)); \n-\tGC_push_one(info . THREAD_FLD (r16)); \n-\tGC_push_one(info . THREAD_FLD (r17)); \n-\tGC_push_one(info . THREAD_FLD (r18)); \n-\tGC_push_one(info . THREAD_FLD (r19)); \n-\tGC_push_one(info . THREAD_FLD (r20)); \n-\tGC_push_one(info . THREAD_FLD (r21)); \n-\tGC_push_one(info . THREAD_FLD (r22)); \n-\tGC_push_one(info . THREAD_FLD (r23)); \n-\tGC_push_one(info . THREAD_FLD (r24)); \n-\tGC_push_one(info . THREAD_FLD (r25)); \n-\tGC_push_one(info . THREAD_FLD (r26)); \n-\tGC_push_one(info . THREAD_FLD (r27)); \n-\tGC_push_one(info . THREAD_FLD (r28)); \n-\tGC_push_one(info . THREAD_FLD (r29)); \n-\tGC_push_one(info . THREAD_FLD (r30)); \n-\tGC_push_one(info . THREAD_FLD (r31));\n-#      else\n-\t/* FIXME: Remove after testing:\t*/\n-\tWARN(\"This is completely untested and likely will not work\\n\", 0);\n-\tGC_THREAD_STATE_T info;\n-\tmach_msg_type_number_t outCount = THREAD_STATE_MAX;\n-\tr = thread_get_state(thread, GC_MACH_THREAD_STATE, (natural_t *)&info,\n-\t\t\t     &outCount);\n-\tif(r != KERN_SUCCESS) ABORT(\"task_get_state failed\");\n-\n-\tlo = (void*)info . THREAD_FLD (esp);\n-\thi = (ptr_t)FindTopOfStack(info . THREAD_FLD (esp));\n-\n-\tGC_push_one(info . THREAD_FLD (eax)); \n-\tGC_push_one(info . THREAD_FLD (ebx)); \n-\tGC_push_one(info . THREAD_FLD (ecx)); \n-\tGC_push_one(info . THREAD_FLD (edx)); \n-\tGC_push_one(info . THREAD_FLD (edi)); \n-\tGC_push_one(info . THREAD_FLD (esi)); \n-\t/* GC_push_one(info . THREAD_FLD (ebp));  */\n-\t/* GC_push_one(info . THREAD_FLD (esp));  */\n-\tGC_push_one(info . THREAD_FLD (ss)); \n-\tGC_push_one(info . THREAD_FLD (eip)); \n-\tGC_push_one(info . THREAD_FLD (cs)); \n-\tGC_push_one(info . THREAD_FLD (ds)); \n-\tGC_push_one(info . THREAD_FLD (es)); \n-\tGC_push_one(info . THREAD_FLD (fs)); \n-\tGC_push_one(info . THREAD_FLD (gs)); \n-#      endif /* !POWERPC */\n-      }\n-#     if DEBUG_THREADS\n-       GC_printf3(\"Darwin: Stack for thread 0x%lx = [%lx,%lx)\\n\",\n-\t\t  (unsigned long) thread,\n-\t\t  (unsigned long) lo,\n-\t\t  (unsigned long) hi\n-\t\t );\n-#     endif\n-      GC_push_all_stack(lo, hi); \n-    } /* for(p=GC_threads[i]...) */\n-    vm_deallocate(current_task(), (vm_address_t)act_list, sizeof(thread_t) * listcount);\n-}\n-#endif /* !DARWIN_DONT_PARSE_STACK */\n-\n-static mach_port_t GC_mach_handler_thread;\n-static int GC_use_mach_handler_thread = 0;\n-\n-static struct GC_mach_thread GC_mach_threads[THREAD_TABLE_SZ];\n-static int GC_mach_threads_count;\n-\n-void GC_stop_init() {\n-  int i;\n-\n-  for (i = 0; i < THREAD_TABLE_SZ; i++) {\n-    GC_mach_threads[i].thread = 0;\n-    GC_mach_threads[i].already_suspended = 0;\n-  }\n-  GC_mach_threads_count = 0;\n-}\n-\n-/* returns true if there's a thread in act_list that wasn't in old_list */\n-int GC_suspend_thread_list(thread_act_array_t act_list, int count, \n-\t\t\t   thread_act_array_t old_list, int old_count) {\n-  mach_port_t my_thread = mach_thread_self();\n-  int i, j;\n-\n-  int changed = 0;\n-\n-  for(i = 0; i < count; i++) {\n-    thread_act_t thread = act_list[i];\n-#   if DEBUG_THREADS \n-      GC_printf1(\"Attempting to suspend thread %p\\n\", thread);\n-#   endif\n-    /* find the current thread in the old list */\n-    int found = 0;\n-    for(j = 0; j < old_count; j++) {\n-      thread_act_t old_thread = old_list[j];\n-      if (old_thread == thread) {\n-\tfound = 1;\n-\tbreak;\n-      }\n-    }\n-    if (!found) {\n-      /* add it to the GC_mach_threads list */\n-      GC_mach_threads[GC_mach_threads_count].thread = thread;\n-      /* default is not suspended */\n-      GC_mach_threads[GC_mach_threads_count].already_suspended = 0;\n-      changed = 1;\n-    }      \n-\n-    if (thread != my_thread &&\n-\t(!GC_use_mach_handler_thread\n-\t || (GC_use_mach_handler_thread\n-\t     && GC_mach_handler_thread != thread))) {\n-      struct thread_basic_info info;\n-      mach_msg_type_number_t outCount = THREAD_INFO_MAX;\n-      kern_return_t kern_result = thread_info(thread, THREAD_BASIC_INFO,\n-\t\t\t\t(thread_info_t)&info, &outCount);\n-      if(kern_result != KERN_SUCCESS) {\n-\t/* the thread may have quit since the thread_threads () call \n-\t * we mark already_suspended so it's not dealt with anymore later\n-\t */\n-        if (!found) {\n-\t  GC_mach_threads[GC_mach_threads_count].already_suspended = TRUE;\n-    \t  GC_mach_threads_count++;\n-\t}\n-\tcontinue;\n-      }\n-#     if DEBUG_THREADS\n-        GC_printf2(\"Thread state for 0x%lx = %d\\n\", thread, info.run_state);\n-#     endif\n-      if (!found) {\n-\tGC_mach_threads[GC_mach_threads_count].already_suspended = info.suspend_count;\n-      }\n-      if (info.suspend_count) continue;\n-      \n-#     if DEBUG_THREADS\n-        GC_printf1(\"Suspending 0x%lx\\n\", thread);\n-#     endif\n-      /* Suspend the thread */\n-      kern_result = thread_suspend(thread);\n-      if(kern_result != KERN_SUCCESS) {\n-\t/* the thread may have quit since the thread_threads () call \n-\t * we mark already_suspended so it's not dealt with anymore later\n-\t */\n-        if (!found) {\n-\t  GC_mach_threads[GC_mach_threads_count].already_suspended = TRUE;\n-    \t  GC_mach_threads_count++;\n-\t}\n-\tcontinue;\n-      }\n-    } \n-    if (!found) GC_mach_threads_count++;\n-  }\n-  return changed;\n-}\n-\n-\n-/* Caller holds allocation lock.\t*/\n-void GC_stop_world()\n-{\n-  int i, changes;\n-    GC_thread p;\n-    mach_port_t my_thread = mach_thread_self();\n-    kern_return_t kern_result;\n-    thread_act_array_t act_list, prev_list;\n-    mach_msg_type_number_t listcount, prevcount;\n-    \n-#   if DEBUG_THREADS\n-      GC_printf1(\"Stopping the world from 0x%lx\\n\", mach_thread_self());\n-#   endif\n-\n-    /* clear out the mach threads list table */\n-    GC_stop_init(); \n-       \n-    /* Make sure all free list construction has stopped before we start. */\n-    /* No new construction can start, since free list construction is\t*/\n-    /* required to acquire and release the GC lock before it starts,\t*/\n-    /* and we have the lock.\t\t\t\t\t\t*/\n-#   ifdef PARALLEL_MARK\n-      GC_acquire_mark_lock();\n-      GC_ASSERT(GC_fl_builder_count == 0);\n-      /* We should have previously waited for it to become zero. */\n-#   endif /* PARALLEL_MARK */\n-\n-      /* Loop stopping threads until you have gone over the whole list\n-\t twice without a new one appearing. thread_create() won't\n-\t return (and thus the thread stop) until the new thread\n-\t exists, so there is no window whereby you could stop a\n-\t thread, recognise it is stopped, but then have a new thread\n-\t it created before stopping show up later.\n-      */\n-      \n-      changes = 1;\n-      prev_list = NULL;\n-      prevcount = 0;\n-      do {\n-\tint result;\n-\tkern_result = task_threads(current_task(), &act_list, &listcount);\n-\tresult = GC_suspend_thread_list(act_list, listcount,\n-\t\t\t\t\tprev_list, prevcount);\n-\tchanges = result;\n-\tprev_list = act_list;\n-\tprevcount = listcount;\n-        vm_deallocate(current_task(), (vm_address_t)act_list, sizeof(thread_t) * listcount);\n-      } while (changes);\n-      \n- \n-#   ifdef MPROTECT_VDB\n-      if(GC_incremental) {\n-        extern void GC_mprotect_stop();\n-        GC_mprotect_stop();\n-      }\n-#   endif\n-    \n-#   ifdef PARALLEL_MARK\n-      GC_release_mark_lock();\n-#   endif\n-    #if DEBUG_THREADS\n-      GC_printf1(\"World stopped from 0x%lx\\n\", my_thread);\n-    #endif\n-}\n-\n-/* Caller holds allocation lock, and has held it continuously since\t*/\n-/* the world stopped.\t\t\t\t\t\t\t*/\n-void GC_start_world()\n-{\n-  mach_port_t my_thread = mach_thread_self();\n-  int i, j;\n-  GC_thread p;\n-  kern_return_t kern_result;\n-  thread_act_array_t act_list;\n-  mach_msg_type_number_t listcount;\n-  struct thread_basic_info info;\n-  mach_msg_type_number_t outCount = THREAD_INFO_MAX;\n-  \n-#   if DEBUG_THREADS\n-      GC_printf0(\"World starting\\n\");\n-#   endif\n-\n-#   ifdef MPROTECT_VDB\n-      if(GC_incremental) {\n-        extern void GC_mprotect_resume();\n-        GC_mprotect_resume();\n-      }\n-#   endif\n-\n-    kern_result = task_threads(current_task(), &act_list, &listcount);\n-    for(i = 0; i < listcount; i++) {\n-      thread_act_t thread = act_list[i];\n-      if (thread != my_thread &&\n-\t  (!GC_use_mach_handler_thread ||\n-\t   (GC_use_mach_handler_thread && GC_mach_handler_thread != thread))) {\n-\tfor(j = 0; j < GC_mach_threads_count; j++) {\n-\t  if (thread == GC_mach_threads[j].thread) {\n-\t    if (GC_mach_threads[j].already_suspended) {\n-#             if DEBUG_THREADS\n-\t        GC_printf1(\"Not resuming already suspended thread %p\\n\", thread);\n-#             endif\n-\t      continue;\n-\t    }\n-\t    kern_result = thread_info(thread, THREAD_BASIC_INFO,\n-\t\t\t\t      (thread_info_t)&info, &outCount);\n-\t    if(kern_result != KERN_SUCCESS) ABORT(\"thread_info failed\");\n-#           if DEBUG_THREADS\n-\t      GC_printf2(\"Thread state for 0x%lx = %d\\n\", thread,\n-\t\t\t info.run_state);\n-\t      GC_printf1(\"Resuming 0x%lx\\n\", thread);\n-#           endif\n-\t    /* Resume the thread */\n-\t    kern_result = thread_resume(thread);\n-\t    if(kern_result != KERN_SUCCESS) ABORT(\"thread_resume failed\");\n-\t  } \n-\t}\n-      }\n-    }\n-    vm_deallocate(current_task(), (vm_address_t)act_list, sizeof(thread_t) * listcount);\n-#   if DEBUG_THREADS\n-     GC_printf0(\"World started\\n\");\n-#   endif\n-}\n-\n-void GC_darwin_register_mach_handler_thread(mach_port_t thread) {\n-  GC_mach_handler_thread = thread;\n-  GC_use_mach_handler_thread = 1;\n-}\n-\n-#endif"}, {"sha": "061a6a537b76d213dfc756a5bcc9d84c00279d55", "filename": "boehm-gc/dbg_mlc.c", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdbg_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdbg_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdbg_mlc.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "3480ce4e96d431f9d70162fd1cd79366c714996b", "filename": "boehm-gc/depcomp", "status": "removed", "additions": 0, "deletions": 436, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdepcomp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdepcomp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdepcomp?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "9778feee97624ea5745e384fe7148259c6a52d27", "filename": "boehm-gc/digimars.mak", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdigimars.mak", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdigimars.mak", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdigimars.mak?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "eaba6e509d36612d6258fbd20f6f56f8b2fff744", "filename": "boehm-gc/doc/README", "status": "removed", "additions": 0, "deletions": 622, "changes": 622, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "9d6d84788ef4219e8779cc4711377914962be09b", "filename": "boehm-gc/doc/README.DGUX386", "status": "removed", "additions": 0, "deletions": 215, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.DGUX386", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.DGUX386", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.DGUX386?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "04f468251a1e5f4b94181f9e6ad085b96e8ff442", "filename": "boehm-gc/doc/README.Mac", "status": "removed", "additions": 0, "deletions": 385, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.Mac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.Mac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.Mac?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "f5333d51ad6771b17bfe28e6b881583c5ad40f8d", "filename": "boehm-gc/doc/README.MacOSX", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.MacOSX", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.MacOSX", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.MacOSX?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "5345bbd0f654592d01fcb0f4a6ae5fb1cac0170a", "filename": "boehm-gc/doc/README.OS2", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.OS2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.OS2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.OS2?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "730dce3fe96f6950b82f79c6a3a1ecda08a4b122", "filename": "boehm-gc/doc/README.amiga", "status": "removed", "additions": 0, "deletions": 322, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.amiga", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.amiga", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.amiga?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "96744edaf67e930ddf693675997549df7edde458", "filename": "boehm-gc/doc/README.arm.cross", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.arm.cross", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.arm.cross", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.arm.cross?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "53fcf5a50b3f8abb71468c521590e02036d75a59", "filename": "boehm-gc/doc/README.autoconf", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.autoconf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.autoconf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.autoconf?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "97b0b684dde5b556750993056e3240d3bee1c2f5", "filename": "boehm-gc/doc/README.changes", "status": "removed", "additions": 0, "deletions": 2278, "changes": 2278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.changes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.changes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.changes?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "fd5c95f2297723c2b52f5b234ef6eb773e57ff05", "filename": "boehm-gc/doc/README.contributors", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.contributors", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.contributors", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.contributors?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "3485e0145af2cf9db44a3849593befae70046396", "filename": "boehm-gc/doc/README.cords", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.cords", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.cords", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.cords?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "70954971fc05abc9f234ca1af16bc344609516b6", "filename": "boehm-gc/doc/README.darwin", "status": "removed", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.darwin", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.darwin", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.darwin?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "613bc423cb147d95368108f3fe233047d632d0d4", "filename": "boehm-gc/doc/README.dj", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.dj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.dj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.dj?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "686e948250b6332c89b452ee703d86e19b5d50f2", "filename": "boehm-gc/doc/README.environment", "status": "removed", "additions": 0, "deletions": 151, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.environment", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.environment", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.environment?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "80bca2b3d9524463ecc69628b826d197b74b69b8", "filename": "boehm-gc/doc/README.ews4800", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.ews4800", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.ews4800", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.ews4800?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "caa8bdd19f540afe9e9f404a38998791d5af47cc", "filename": "boehm-gc/doc/README.hp", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.hp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.hp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.hp?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "ec4e7e641a067bfa6e46a6b2475ddf4fff57060c", "filename": "boehm-gc/doc/README.linux", "status": "removed", "additions": 0, "deletions": 132, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.linux?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "df0ef2cda933f68b5f2b37552a000182d38b1a5d", "filename": "boehm-gc/doc/README.macros", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.macros", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.macros", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.macros?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "f5630b20a3290a25903980435838bd935878372a", "filename": "boehm-gc/doc/README.rs6000", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.rs6000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.rs6000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.rs6000?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "7bdb50a4ef9c5e2ebbcbb1120be435d9f07acfba", "filename": "boehm-gc/doc/README.sgi", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.sgi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.sgi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.sgi?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "31e7500382dd6984fea151583664902d20abcf52", "filename": "boehm-gc/doc/README.solaris2", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.solaris2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.solaris2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.solaris2?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "6be49667d7b8852c8b38845514ad597e08a01184", "filename": "boehm-gc/doc/README.uts", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.uts", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.uts", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.uts?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "6f57db117647407369b0059a8a91dc12c4454821", "filename": "boehm-gc/doc/README.win32", "status": "removed", "additions": 0, "deletions": 215, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.win32", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2FREADME.win32", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.win32?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "27e80dc15cd103b5c3ad02a2cc60972370bd2842", "filename": "boehm-gc/doc/barrett_diagram", "status": "removed", "additions": 0, "deletions": 106, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2Fbarrett_diagram", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2Fbarrett_diagram", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2Fbarrett_diagram?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "7c65f2bb40a088acbef94a330b7ee9dcad45ea18", "filename": "boehm-gc/doc/debugging.html", "status": "removed", "additions": 0, "deletions": 306, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2Fdebugging.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2Fdebugging.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2Fdebugging.html?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "2a550c71247e399ddbd36137a3aad57e9e915d7c", "filename": "boehm-gc/doc/gc.man", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2Fgc.man", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2Fgc.man", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2Fgc.man?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "cab6bde4fbab9682471022bca6b098a69af86486", "filename": "boehm-gc/doc/gcdescr.html", "status": "removed", "additions": 0, "deletions": 560, "changes": 560, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2Fgcdescr.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2Fgcdescr.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2Fgcdescr.html?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "1716514bec164376f768bcedb4889f54e74f8758", "filename": "boehm-gc/doc/gcinterface.html", "status": "removed", "additions": 0, "deletions": 248, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2Fgcinterface.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2Fgcinterface.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2Fgcinterface.html?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "91fa8ea840236fa3f6b76e2ba9dbf25f78cbda0b", "filename": "boehm-gc/doc/leak.html", "status": "removed", "additions": 0, "deletions": 197, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2Fleak.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2Fleak.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2Fleak.html?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "2e70148dfb782fa877e75034368a8cbd3123c3b6", "filename": "boehm-gc/doc/scale.html", "status": "removed", "additions": 0, "deletions": 210, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2Fscale.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2Fscale.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2Fscale.html?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "0bc0953ef032d608cbaef5d0ac13f54313f1ddbc", "filename": "boehm-gc/doc/simple_example.html", "status": "removed", "additions": 0, "deletions": 202, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2Fsimple_example.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2Fsimple_example.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2Fsimple_example.html?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "c46a281cc6751195db7fe163285c60a1999836b1", "filename": "boehm-gc/doc/tree.html", "status": "removed", "additions": 0, "deletions": 199, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2Ftree.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdoc%2Ftree.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2Ftree.html?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "eac2e71673fbd07d033de23e8cd0dea96cc57bf2", "filename": "boehm-gc/dyn_load.c", "status": "removed", "additions": 0, "deletions": 1505, "changes": 1505, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdyn_load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fdyn_load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdyn_load.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "484d421d1d68c2e6659612acd49c87e04e825a0e", "filename": "boehm-gc/finalize.c", "status": "removed", "additions": 0, "deletions": 959, "changes": 959, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ffinalize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ffinalize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ffinalize.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "5f0b5462427db7a24abf786c844b8ba97ecb2e29", "filename": "boehm-gc/gc.mak", "status": "removed", "additions": 0, "deletions": 2158, "changes": 2158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fgc.mak", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fgc.mak", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc.mak?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "f8b803a8baa42a1f59583e48cd7120866be31090", "filename": "boehm-gc/gc_cpp.cc", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fgc_cpp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fgc_cpp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_cpp.cc?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "f6bd95e59a5f5b62d8ebf5ba3eb9811160ebff09", "filename": "boehm-gc/gc_cpp.cpp", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fgc_cpp.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fgc_cpp.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_cpp.cpp?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "4c690edcfe49c3c923722a34349aba2bb7576978", "filename": "boehm-gc/gc_dlopen.c", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fgc_dlopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fgc_dlopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_dlopen.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "e8a7b8201db64d023a450690db4b7b21be950cdd", "filename": "boehm-gc/gcc_support.c", "status": "removed", "additions": 0, "deletions": 516, "changes": 516, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fgcc_support.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fgcc_support.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgcc_support.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "2aaef795d923ef33a64825661faf4dff5ffdf3c0", "filename": "boehm-gc/gcj_mlc.c", "status": "removed", "additions": 0, "deletions": 321, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fgcj_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fgcj_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgcj_mlc.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "e2119d7996402c70352796c363867d7841118b87", "filename": "boehm-gc/gcname.c", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fgcname.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fgcname.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgcname.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "b7be1d84930be9fb4d54fd59b70572815deb8eda", "filename": "boehm-gc/headers.c", "status": "removed", "additions": 0, "deletions": 358, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fheaders.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fheaders.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fheaders.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "f09b211404bf7cbb6f58d88e369b9f0794074f6c", "filename": "boehm-gc/hpux_test_and_clear.s", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fhpux_test_and_clear.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fhpux_test_and_clear.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fhpux_test_and_clear.s?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "3b18c0841d0597a0751d9ee82e3a09f1047ee766", "filename": "boehm-gc/ia64_save_regs_in_stack.s", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fia64_save_regs_in_stack.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fia64_save_regs_in_stack.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fia64_save_regs_in_stack.s?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "3dcccf21f5a86099e809475d5cd3303c9a61f2b0", "filename": "boehm-gc/if_mach.c", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fif_mach.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fif_mach.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fif_mach.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "8691e925920eabc542710ca22c9dc9247485cf69", "filename": "boehm-gc/if_not_there.c", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fif_not_there.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fif_not_there.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fif_not_there.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "63aec076056056a623622b70e1de56b01f89361a", "filename": "boehm-gc/include/Makefile.am", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2FMakefile.am?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "ad7bbda296fb4d05d91a71b413dae542eb9d564a", "filename": "boehm-gc/include/Makefile.in", "status": "removed", "additions": 0, "deletions": 459, "changes": 459, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2FMakefile.in?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "926089e86fbb18567aa48981aa68dc152f1e7b76", "filename": "boehm-gc/include/cord.h", "status": "removed", "additions": 0, "deletions": 327, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fcord.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fcord.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fcord.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "c829b83ad110579334a525a9c964e53e155b2462", "filename": "boehm-gc/include/ec.h", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fec.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "6b38f2d0e6caf9671e861d38da217845f7acaa8a", "filename": "boehm-gc/include/gc.h", "status": "removed", "additions": 0, "deletions": 1083, "changes": 1083, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "c50a758964606169f3aab1486d4d193af41dc682", "filename": "boehm-gc/include/gc_alloc.h", "status": "removed", "additions": 0, "deletions": 383, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_alloc.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "200f181efa6f17261b8187570389c50c96ae2814", "filename": "boehm-gc/include/gc_allocator.h", "status": "removed", "additions": 0, "deletions": 243, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_allocator.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "9e975c8c832246808e7ad39e622c38e2eaa95dee", "filename": "boehm-gc/include/gc_amiga_redirects.h", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_amiga_redirects.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_amiga_redirects.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_amiga_redirects.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "5899496e0fe59db1065ca13d3b681abffdba8499", "filename": "boehm-gc/include/gc_backptr.h", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_backptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_backptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_backptr.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "7ef9822c578e55383c97d4ab484f4a515c9bec44", "filename": "boehm-gc/include/gc_config.h.in", "status": "removed", "additions": 0, "deletions": 186, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_config.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_config.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_config.h.in?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "a01da4a1342d177b0401f9396c62d2924edc22d4", "filename": "boehm-gc/include/gc_config_macros.h", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_config_macros.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_config_macros.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_config_macros.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "4f56f0d965fcf360112686fb0cdfb86fe315a468", "filename": "boehm-gc/include/gc_cpp.h", "status": "removed", "additions": 0, "deletions": 367, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_cpp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_cpp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_cpp.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "219ba2fb8c8e9e2040ab5f3f8cd8f49daaf0116d", "filename": "boehm-gc/include/gc_ext_config.h.in", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_ext_config.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_ext_config.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_ext_config.h.in?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "5e79e27b821606f267944e7da5df840fe56cd0be", "filename": "boehm-gc/include/gc_gcj.h", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_gcj.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_gcj.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_gcj.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "c535cfd73fcf9e782fdc02cf96f9f13298d28f60", "filename": "boehm-gc/include/gc_inl.h", "status": "removed", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_inl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_inl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_inl.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "db62d1d58a815eaef9a376d0627873eacaf938d8", "filename": "boehm-gc/include/gc_inline.h", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_inline.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "1874c7b6d209564102cf4cf0651c70ad36bbff1e", "filename": "boehm-gc/include/gc_local_alloc.h", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_local_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_local_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_local_alloc.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "953bb74dc084c0e1870c05d203a5a3493ffebc73", "filename": "boehm-gc/include/gc_mark.h", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_mark.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_mark.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_mark.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "842518cfcc48c2a0657b1cc6581994abf5cd8a44", "filename": "boehm-gc/include/gc_pthread_redirects.h", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_pthread_redirects.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_pthread_redirects.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_pthread_redirects.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "905734b8da0f550c3833c8dd21f09b7c23828bb2", "filename": "boehm-gc/include/gc_typed.h", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_typed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fgc_typed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_typed.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "23e01005afed3f7303029b42aa4d5ca200393652", "filename": "boehm-gc/include/javaxfc.h", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fjavaxfc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fjavaxfc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fjavaxfc.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "0674ab4d09f6d1db7bc625b058145186cee75df6", "filename": "boehm-gc/include/leak_detector.h", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fleak_detector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fleak_detector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fleak_detector.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "7546638c981a5060523cd6bafc5a52cc956aaf96", "filename": "boehm-gc/include/new_gc_alloc.h", "status": "removed", "additions": 0, "deletions": 480, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fnew_gc_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fnew_gc_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fnew_gc_alloc.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "d2b24bb8ab6d728608c4821ba93053d794f3ec34", "filename": "boehm-gc/include/private/cord_pos.h", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fcord_pos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fcord_pos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fcord_pos.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "0f43982d5c1e1b3af86126400ab5b281aecfcd20", "filename": "boehm-gc/include/private/darwin_semaphore.h", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fdarwin_semaphore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fdarwin_semaphore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fdarwin_semaphore.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "f6f5314ee315a5410cade12e06a7045214bfda05", "filename": "boehm-gc/include/private/darwin_stop_world.h", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fdarwin_stop_world.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fdarwin_stop_world.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fdarwin_stop_world.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "e0a994de5e2a64c1d095cc7e2c3b4d1a2fea9b34", "filename": "boehm-gc/include/private/dbg_mlc.h", "status": "removed", "additions": 0, "deletions": 175, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fdbg_mlc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fdbg_mlc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fdbg_mlc.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "70dfefe8fa7dc2725d2b14a409abe2fd7447a507", "filename": "boehm-gc/include/private/gc_hdrs.h", "status": "removed", "additions": 0, "deletions": 233, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fgc_hdrs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fgc_hdrs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_hdrs.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "54cfdb92d374e8634ef4f06bda6fb5b75c475d1d", "filename": "boehm-gc/include/private/gc_locks.h", "status": "removed", "additions": 0, "deletions": 684, "changes": 684, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fgc_locks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fgc_locks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_locks.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "6b15d8ad242194dff1b224aba60bc07db4b22ebe", "filename": "boehm-gc/include/private/gc_pmark.h", "status": "removed", "additions": 0, "deletions": 394, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fgc_pmark.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fgc_pmark.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_pmark.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "4dbfa7d1fedb18e992178fd6b7b11fd9a582902e", "filename": "boehm-gc/include/private/gc_priv.h", "status": "removed", "additions": 0, "deletions": 2015, "changes": 2015, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "44b9d7d86c38839bba544d456d3091ddcf735a01", "filename": "boehm-gc/include/private/gcconfig.h", "status": "removed", "additions": 0, "deletions": 2477, "changes": 2477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "6f9197a1f6f103615d59040c0b0a728726b95da3", "filename": "boehm-gc/include/private/pthread_stop_world.h", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fpthread_stop_world.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fpthread_stop_world.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fpthread_stop_world.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "2186c079039f5ef27e270742946c24e1c1454cea", "filename": "boehm-gc/include/private/pthread_support.h", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fpthread_support.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fpthread_support.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fpthread_support.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "d04e19f5a4b5dcd9c60f66a24d7ff7e626402250", "filename": "boehm-gc/include/private/specific.h", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fspecific.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fprivate%2Fspecific.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fspecific.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "84906b00a68489f158f12c9e86dba9eb0d73a2a9", "filename": "boehm-gc/include/weakpointer.h", "status": "removed", "additions": 0, "deletions": 221, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fweakpointer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Finclude%2Fweakpointer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fweakpointer.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "ba1e0b6fe506d35692c0de98f1bfaa2eff9917fc", "filename": "boehm-gc/mach_dep.c", "status": "removed", "additions": 0, "deletions": 627, "changes": 627, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fmach_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fmach_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmach_dep.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "cb3f37663861a634d0bf100c0f15a4831b0d21f3", "filename": "boehm-gc/malloc.c", "status": "removed", "additions": 0, "deletions": 502, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fmalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fmalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmalloc.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "5ad593dabb9961d1a1792428744f214ac61132e2", "filename": "boehm-gc/mallocx.c", "status": "removed", "additions": 0, "deletions": 695, "changes": 695, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fmallocx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fmallocx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmallocx.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "09dfe92af3152d01289982c667a6ee6d14ed5759", "filename": "boehm-gc/mark.c", "status": "removed", "additions": 0, "deletions": 1817, "changes": 1817, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fmark.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fmark.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmark.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "94eb0ddb37f3e81f70260e9361e67f517cce81f7", "filename": "boehm-gc/mark_rts.c", "status": "removed", "additions": 0, "deletions": 658, "changes": 658, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fmark_rts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fmark_rts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmark_rts.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "cadacf5ed4d8888bec58bc8d9fd72041f51b574a", "filename": "boehm-gc/mips_sgi_mach_dep.s", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fmips_sgi_mach_dep.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fmips_sgi_mach_dep.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmips_sgi_mach_dep.s?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "178224e31c8d6b6ad96d42a01e5373380222c5ec", "filename": "boehm-gc/mips_ultrix_mach_dep.s", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fmips_ultrix_mach_dep.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fmips_ultrix_mach_dep.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmips_ultrix_mach_dep.s?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "069c7d57ad0086e7c4b413dc157a62f67aa1ae40", "filename": "boehm-gc/misc.c", "status": "removed", "additions": 0, "deletions": 1185, "changes": 1185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmisc.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "e5580e4ca218d9770f7dcf171bf4cc61420852c2", "filename": "boehm-gc/new_hblk.c", "status": "removed", "additions": 0, "deletions": 263, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fnew_hblk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fnew_hblk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fnew_hblk.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "d002d65b4dda05092dc23a6b74bf1f1e451f0063", "filename": "boehm-gc/obj_map.c", "status": "removed", "additions": 0, "deletions": 147, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fobj_map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fobj_map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fobj_map.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "60cbc2b29765e5abb6aff052ee30dbea4c89f449", "filename": "boehm-gc/os_dep.c", "status": "removed", "additions": 0, "deletions": 4344, "changes": 4344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fos_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fos_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fos_dep.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "15c904551be78a62c9a181af0cda0bc8c7759247", "filename": "boehm-gc/pc_excludes", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fpc_excludes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fpc_excludes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fpc_excludes?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "7bf02a45c69e177ea4d988cb63fcc61604ec05a3", "filename": "boehm-gc/pcr_interface.c", "status": "removed", "additions": 0, "deletions": 178, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fpcr_interface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fpcr_interface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fpcr_interface.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "d61acc034c42d9f51892136f6bff9fad491048ea", "filename": "boehm-gc/powerpc_darwin_mach_dep.s", "status": "removed", "additions": 0, "deletions": 178, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fpowerpc_darwin_mach_dep.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fpowerpc_darwin_mach_dep.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fpowerpc_darwin_mach_dep.s?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "bc3c901dccfd39919f11bffa3bd9337912903a95", "filename": "boehm-gc/pthread_stop_world.c", "status": "removed", "additions": 0, "deletions": 580, "changes": 580, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fpthread_stop_world.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fpthread_stop_world.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fpthread_stop_world.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "6d8f020e076c13af730e219dd18f93bbf67d8628", "filename": "boehm-gc/pthread_support.c", "status": "removed", "additions": 0, "deletions": 1715, "changes": 1715, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fpthread_support.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fpthread_support.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fpthread_support.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "09c86cb599d183d8f5e344e388ef9de1817dea57", "filename": "boehm-gc/ptr_chck.c", "status": "removed", "additions": 0, "deletions": 328, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fptr_chck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fptr_chck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fptr_chck.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "dece9fdc09cd419f4f99868d011bc67934ef7591", "filename": "boehm-gc/real_malloc.c", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Freal_malloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Freal_malloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Freal_malloc.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "864c0cad8afa40c5cf61cb1b47fff170036316dd", "filename": "boehm-gc/reclaim.c", "status": "removed", "additions": 0, "deletions": 1061, "changes": 1061, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Freclaim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Freclaim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Freclaim.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "12bf9a84d51ce8bfbf83cd7153b47a2f7fe537eb", "filename": "boehm-gc/rs6000_mach_dep.s", "status": "removed", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Frs6000_mach_dep.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Frs6000_mach_dep.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Frs6000_mach_dep.s?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "07686ef0808db48d17858c6930fc2b5da53e5f95", "filename": "boehm-gc/setjmp_t.c", "status": "removed", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fsetjmp_t.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fsetjmp_t.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsetjmp_t.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "06a0f3b4673a01a91cf1a4c4c3a49e032c6088dd", "filename": "boehm-gc/sparc_mach_dep.S", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fsparc_mach_dep.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fsparc_mach_dep.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsparc_mach_dep.S?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "bc3f1603735f1b7790fde8c22013e2a0dd6ae994", "filename": "boehm-gc/sparc_netbsd_mach_dep.s", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fsparc_netbsd_mach_dep.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fsparc_netbsd_mach_dep.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsparc_netbsd_mach_dep.s?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "41858073ef9b051f7b5dde16540053368b2ba3e0", "filename": "boehm-gc/sparc_sunos4_mach_dep.s", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fsparc_sunos4_mach_dep.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fsparc_sunos4_mach_dep.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsparc_sunos4_mach_dep.s?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "e78cf7ac912ac3b707898d11d315d175f4fcade3", "filename": "boehm-gc/specific.c", "status": "removed", "additions": 0, "deletions": 128, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fspecific.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fspecific.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fspecific.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "bb137616fa8bbab4ca8a951ce7d56d7f23f69347", "filename": "boehm-gc/stubborn.c", "status": "removed", "additions": 0, "deletions": 326, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fstubborn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fstubborn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fstubborn.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "f1eac3b16663fa1526e476f499b63273721a5994", "filename": "boehm-gc/testsuite/Makefile.am", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftestsuite%2FMakefile.am?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "5133b1fb05891d13e456035b3d26e35dad78f24b", "filename": "boehm-gc/testsuite/Makefile.in", "status": "removed", "additions": 0, "deletions": 436, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftestsuite%2FMakefile.in?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "6661e411927fba49ccc3d45dac85756ad4ad2d21", "filename": "boehm-gc/testsuite/boehm-gc.c++/test_cpp.cc", "status": "removed", "additions": 0, "deletions": 288, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2B%2B%2Ftest_cpp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2B%2B%2Ftest_cpp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2B%2B%2Ftest_cpp.cc?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "fea4660034886b813b342cfda590311baa83a183", "filename": "boehm-gc/testsuite/boehm-gc.c/c.exp", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2Fc.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2Fc.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2Fc.exp?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "cc03e96e554220ddf90376507182f0b28c3ee4cc", "filename": "boehm-gc/testsuite/boehm-gc.c/gctest.c", "status": "removed", "additions": 0, "deletions": 1858, "changes": 1858, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2Fgctest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2Fgctest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2Fgctest.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "bf563ac1c16c0301d94dbfe59cae10774e0ee111", "filename": "boehm-gc/testsuite/boehm-gc.c/leak_test.c", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2Fleak_test.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2Fleak_test.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2Fleak_test.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "5d9360af521dfe1839667dc8c6dc748dec39b090", "filename": "boehm-gc/testsuite/boehm-gc.c/middle.c", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2Fmiddle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2Fmiddle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2Fmiddle.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "89014651261bc02ec30ecf9f14c504af90c21b55", "filename": "boehm-gc/testsuite/boehm-gc.c/thread_leak_test.c", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2Fthread_leak_test.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2Fthread_leak_test.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2Fthread_leak_test.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "00bcadf19ad3a4763626f21d8e47d29dac77323e", "filename": "boehm-gc/testsuite/boehm-gc.c/trace_test.c", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2Ftrace_test.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2Ftrace_test.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2Ftrace_test.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "f7b83d85ed5739ad390941128d740769e7d68ab3", "filename": "boehm-gc/testsuite/boehm-gc.lib/lib.exp", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Fboehm-gc.lib%2Flib.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Fboehm-gc.lib%2Flib.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftestsuite%2Fboehm-gc.lib%2Flib.exp?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "6e13278a6c0858382938ad9d5a54f63e93647b96", "filename": "boehm-gc/testsuite/boehm-gc.lib/staticrootslib.c", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Fboehm-gc.lib%2Fstaticrootslib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Fboehm-gc.lib%2Fstaticrootslib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftestsuite%2Fboehm-gc.lib%2Fstaticrootslib.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "a029ccf4276b9c7a3229b75719028d21d2d64ce5", "filename": "boehm-gc/testsuite/boehm-gc.lib/staticrootstest.c", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Fboehm-gc.lib%2Fstaticrootstest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Fboehm-gc.lib%2Fstaticrootstest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftestsuite%2Fboehm-gc.lib%2Fstaticrootstest.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "90967cccc18afeb470c705244f4cb9e44f15eb0d", "filename": "boehm-gc/testsuite/config/default.exp", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Fconfig%2Fdefault.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Fconfig%2Fdefault.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftestsuite%2Fconfig%2Fdefault.exp?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "d162035b63b2a7a6e80374def2d2fed7cf8689d1", "filename": "boehm-gc/testsuite/lib/boehm-gc.exp", "status": "removed", "additions": 0, "deletions": 336, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Flib%2Fboehm-gc.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftestsuite%2Flib%2Fboehm-gc.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftestsuite%2Flib%2Fboehm-gc.exp?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "69fcc5e90ab588eed22913b99f6b5891337d20a9", "filename": "boehm-gc/threadlibs.c", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fthreadlibs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fthreadlibs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fthreadlibs.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "31119df20188cdf47d6ce8211bed6ad8ede9d940", "filename": "boehm-gc/threads.mk.in", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fthreads.mk.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fthreads.mk.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fthreads.mk.in?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "373257cd260dc7f97a10964a7fd0c9c21a3c0943", "filename": "boehm-gc/typd_mlc.c", "status": "removed", "additions": 0, "deletions": 809, "changes": 809, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftypd_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Ftypd_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftypd_mlc.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "9fcbb7b651fb0e5be116c17ecbf954b19c90c8d6", "filename": "boehm-gc/version.h", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fversion.h?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "2de1c6953b870f1a1df07927f87da32dd43e0fde", "filename": "boehm-gc/win32_threads.c", "status": "removed", "additions": 0, "deletions": 819, "changes": 819, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fwin32_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b403c8bb69250b321c9d56e38f5f3537a1e696/boehm-gc%2Fwin32_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fwin32_threads.c?ref=a2b403c8bb69250b321c9d56e38f5f3537a1e696"}, {"sha": "ed597876e90b33e3cd5e56d9938914cd5e1d483a", "filename": "config/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114bf3f172d0f215a576d8964b95c0a4608563e0/config%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114bf3f172d0f215a576d8964b95c0a4608563e0/config%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2FChangeLog?ref=114bf3f172d0f215a576d8964b95c0a4608563e0"}, {"sha": "0301d2785ad2f8e208eed3270a1ca873dbdf50cb", "filename": "config/pkg.m4", "status": "added", "additions": 825, "deletions": 0, "changes": 825, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114bf3f172d0f215a576d8964b95c0a4608563e0/config%2Fpkg.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114bf3f172d0f215a576d8964b95c0a4608563e0/config%2Fpkg.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpkg.m4?ref=114bf3f172d0f215a576d8964b95c0a4608563e0"}, {"sha": "cec133e171c38c52c9b7d166aaf6d9d74d72c7c8", "filename": "configure", "status": "modified", "additions": 186, "deletions": 13, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114bf3f172d0f215a576d8964b95c0a4608563e0/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114bf3f172d0f215a576d8964b95c0a4608563e0/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=114bf3f172d0f215a576d8964b95c0a4608563e0"}, {"sha": "ed89ea22c2457aea11b4fff8044fc2c7e77a7d8f", "filename": "configure.ac", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114bf3f172d0f215a576d8964b95c0a4608563e0/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114bf3f172d0f215a576d8964b95c0a4608563e0/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=114bf3f172d0f215a576d8964b95c0a4608563e0"}, {"sha": "6c37db0f22da4fd5bebb8c8617904a807c6cc3fa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114bf3f172d0f215a576d8964b95c0a4608563e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114bf3f172d0f215a576d8964b95c0a4608563e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=114bf3f172d0f215a576d8964b95c0a4608563e0"}, {"sha": "5d96e5fd62cf9fd85a84dd7ecdd7ebd4ef0a3ac2", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114bf3f172d0f215a576d8964b95c0a4608563e0/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114bf3f172d0f215a576d8964b95c0a4608563e0/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=114bf3f172d0f215a576d8964b95c0a4608563e0"}, {"sha": "d38ac75e9501e130aca3046fb114796a0a27ddf1", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114bf3f172d0f215a576d8964b95c0a4608563e0/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114bf3f172d0f215a576d8964b95c0a4608563e0/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=114bf3f172d0f215a576d8964b95c0a4608563e0"}, {"sha": "3329a5cb3fb0c1df8ae58d079148ac1898f41945", "filename": "libobjc/Makefile.in", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114bf3f172d0f215a576d8964b95c0a4608563e0/libobjc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114bf3f172d0f215a576d8964b95c0a4608563e0/libobjc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FMakefile.in?ref=114bf3f172d0f215a576d8964b95c0a4608563e0"}, {"sha": "43a68de99774231344e7dc0902da580c5261f814", "filename": "libobjc/configure", "status": "modified", "additions": 354, "deletions": 31, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114bf3f172d0f215a576d8964b95c0a4608563e0/libobjc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114bf3f172d0f215a576d8964b95c0a4608563e0/libobjc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fconfigure?ref=114bf3f172d0f215a576d8964b95c0a4608563e0"}, {"sha": "0497836a964ee8d880a1c933c144f56234aa7456", "filename": "libobjc/configure.ac", "status": "modified", "additions": 156, "deletions": 20, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114bf3f172d0f215a576d8964b95c0a4608563e0/libobjc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114bf3f172d0f215a576d8964b95c0a4608563e0/libobjc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fconfigure.ac?ref=114bf3f172d0f215a576d8964b95c0a4608563e0"}, {"sha": "d3ff1bc251796ab75014b0eba5ddb12de24a890c", "filename": "libobjc/gc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114bf3f172d0f215a576d8964b95c0a4608563e0/libobjc%2Fgc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114bf3f172d0f215a576d8964b95c0a4608563e0/libobjc%2Fgc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fgc.c?ref=114bf3f172d0f215a576d8964b95c0a4608563e0"}, {"sha": "a439e587ab295dc36fea9dd65c5812091af02019", "filename": "libobjc/memory.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114bf3f172d0f215a576d8964b95c0a4608563e0/libobjc%2Fmemory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114bf3f172d0f215a576d8964b95c0a4608563e0/libobjc%2Fmemory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fmemory.c?ref=114bf3f172d0f215a576d8964b95c0a4608563e0"}, {"sha": "09aa049000ed18692c6d825097603a9a21907804", "filename": "libobjc/objects.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114bf3f172d0f215a576d8964b95c0a4608563e0/libobjc%2Fobjects.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114bf3f172d0f215a576d8964b95c0a4608563e0/libobjc%2Fobjects.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjects.c?ref=114bf3f172d0f215a576d8964b95c0a4608563e0"}]}