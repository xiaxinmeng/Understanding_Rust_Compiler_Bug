{"sha": "6e2dc028a3b428c47f5b6975359fcf4390ab9f45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUyZGMwMjhhM2I0MjhjNDdmNWI2OTc1MzU5ZmNmNDM5MGFiOWY0NQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2007-05-29T13:09:30Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2007-05-29T13:09:30Z"}, "message": "tree-ssa-alias.c: Add aliasing overview.\n\n2007-05-29  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* tree-ssa-alias.c: Add aliasing overview.\n\nFrom-SVN: r125162", "tree": {"sha": "f5c8e06b564fb6d5785236de7981b95dac8947a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5c8e06b564fb6d5785236de7981b95dac8947a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e2dc028a3b428c47f5b6975359fcf4390ab9f45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e2dc028a3b428c47f5b6975359fcf4390ab9f45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e2dc028a3b428c47f5b6975359fcf4390ab9f45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e2dc028a3b428c47f5b6975359fcf4390ab9f45/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fd2157ce0928a9b0fd89182b111af1c6bb9940ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd2157ce0928a9b0fd89182b111af1c6bb9940ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd2157ce0928a9b0fd89182b111af1c6bb9940ab"}], "stats": {"total": 121, "additions": 121, "deletions": 0}, "files": [{"sha": "3dec250c4b42459d25ffa4be40e510cfd437668e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2dc028a3b428c47f5b6975359fcf4390ab9f45/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2dc028a3b428c47f5b6975359fcf4390ab9f45/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e2dc028a3b428c47f5b6975359fcf4390ab9f45", "patch": "@@ -1,3 +1,7 @@\n+2007-05-29  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* tree-ssa-alias.c: Add aliasing overview.\n+\n 2007-05-29  Zuxy Meng  <zuxy.meng@gmail.com>\n             Danny Smith  <dannysmith@users.sourceforge.net>\n "}, {"sha": "9fa312919c740771589b997df227d049e32661b5", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2dc028a3b428c47f5b6975359fcf4390ab9f45/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2dc028a3b428c47f5b6975359fcf4390ab9f45/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=6e2dc028a3b428c47f5b6975359fcf4390ab9f45", "patch": "@@ -49,6 +49,123 @@ Boston, MA 02110-1301, USA.  */\n #include \"vecprim.h\"\n #include \"pointer-set.h\"\n \n+/* Broad overview of how aliasing works:\n+   \n+   First we compute points-to sets, which is done in\n+   tree-ssa-structalias.c\n+      \n+   During points-to set constraint finding, a bunch of little bits of\n+   information is collected.\n+   This is not done because it is necessary for points-to, but because\n+   points-to has to walk every statement anyway.  The function performing\n+   this collecting is update_alias_info.\n+\n+   Bits update_alias_info collects include:\n+   1. Directly escaping variables and variables whose value escapes\n+   (using is_escape_site).  This is the set of variables and values that\n+   escape prior to transitive closure of the clobbers.\n+   2.  The set of variables dereferenced on the LHS (into\n+   dereferenced_ptr_stores) \n+   3. The set of variables dereferenced on the RHS (into\n+   dereferenced_ptr_loads) \n+   4. The set of all pointers we saw.\n+   5. The number of loads and stores for each variable\n+   6. The number of statements touching memory\n+   7. The set of address taken variables.\n+   \n+   \n+   #1 is computed by a combination of is_escape_site, and counting the\n+   number of uses/deref operators.  This function properly accounts for\n+   situations like &ptr->field, which is *not* a dereference.\n+   \n+   After points-to sets are computed, the sets themselves still\n+   contain points-to specific variables, such as a variable that says\n+   the pointer points to anything, a variable that says the pointer\n+   points to readonly memory, etc.\n+\n+   These are eliminated in a later phase, as we will see.\n+\n+   The rest of the phases are located in tree-ssa-alias.c\n+\n+   The next phase after points-to set computation is called\n+   \"setup_pointers_and_addressables\"\n+\n+   This pass does 3 main things:\n+   \n+   1. All variables that can have TREE_ADDRESSABLE removed safely (IE\n+   non-globals whose address is not taken), have TREE_ADDRESSABLE\n+   removed.\n+   2. All variables that may be aliased (which is the set of addressable\n+   variables and globals) at all, are marked for renaming, and have\n+   symbol memory tags created for them.\n+   3. All variables which are stored into have their SMT's added to\n+   written vars. \n+\n+\n+   After this function is run, all variables that will ever have an\n+   SMT, have one, though its aliases are not filled in.\n+\n+   The next phase is to compute flow-insensitive aliasing, which in\n+   our case, is a misnomer.  it is really computing aliasing that\n+   requires no transitive closure to be correct.  In particular, it\n+   uses stack vs non-stack, TBAA, etc, to determine whether two\n+   symbols could *ever* alias .  This phase works by going through all\n+   the pointers we collected during update_alias_info, and for every\n+   addressable variable in the program, seeing if they alias.  If so,\n+   the addressable variable is added to the symbol memory tag for the\n+   pointer.\n+\n+   As part of this, we handle symbol memory tags that conflict but\n+   have no aliases in common, by forcing them to have a symbol in\n+   common (through unioning alias sets or adding one as an alias of\n+   the other), or by adding one as an alias of another.  The case of\n+   conflicts with no aliases in common occurs mainly due to aliasing\n+   we cannot see.  In particular, it generally means we have a load\n+   through a pointer whose value came from outside the function.\n+   Without an addressable symbol to point to, they would get the wrong\n+   answer.\n+\n+   After flow insensitive aliasing is computed, we compute name tags\n+   (called compute_flow_sensitive_info).  We walk each pointer we\n+   collected and see if it has a usable points-to set.  If so, we\n+   generate a name tag using that pointer, and make an alias bitmap for\n+   it.  Name tags are shared between all things with the same alias\n+   bitmap.  The alias bitmap will be translated from what points-to\n+   computed.  In particular, the \"anything\" variable in points-to will be\n+   transformed into a pruned set of SMT's and their aliases that\n+   compute_flow_insensitive_aliasing computed.\n+   Note that since 4.3, every pointer that points-to computed a solution for\n+   will get a name tag (whereas before 4.3, only those whose set did\n+   *not* include the anything variable would).  At the point where name\n+   tags are all assigned, symbol memory tags are dead, and could be\n+   deleted, *except* on global variables.  Global variables still use\n+   symbol memory tags as of right now.\n+\n+   After name tags are computed, the set of clobbered variables is\n+   transitively closed.  In particular, we compute the set of clobbered\n+   variables based on the initial set of clobbers, plus the aliases of\n+   pointers which either escape, or have their value escape.\n+\n+   After this, maybe_create_global_var is run, which handles a corner\n+   case where we have no call clobbered variables, but have pure and\n+   non-pure functions.\n+   \n+   Staring at this function, I now remember it is a hack for the fact\n+   that we do not mark all globals in the program as call clobbered for a\n+   function unless they are actually used in that function.  Instead,  we\n+   only mark the set that is actually clobbered.  As a result, you can\n+   end up with situations where you have no call clobbered vars set.\n+   \n+   After maybe_create_global_var, we set pointers with the REF_ALL flag\n+   to have alias sets that include all clobbered\n+   memory tags and variables.\n+   \n+   After this, memory partitioning is computed (by the function\n+   compute_memory_partitions) and alias sets are reworked accordingly.\n+\n+   Lastly, we delete partitions with no symbols, and clean up after\n+   ourselves.  */\n+\n /* Structure to map a variable to its alias set.  */\n struct alias_map_d\n {"}]}