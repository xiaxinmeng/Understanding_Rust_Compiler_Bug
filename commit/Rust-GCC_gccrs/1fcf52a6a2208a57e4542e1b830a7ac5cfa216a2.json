{"sha": "1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZjZjUyYTZhMjIwOGE1N2U0NTQyZTFiODMwYTdhYzVjZmEyMTZhMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-10-11T08:59:16Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-10-11T08:59:16Z"}, "message": "Do not allocate ggc during streaming.\n\n\t* gimple-streamer-out.c (output_gimple_stmt): Add explicit function\n\tparameter.\n\t* lto-streamer-out.c: Include tree-dfa.h.\n\t(output_cfg): Do not use cfun.\n\t(lto_prepare_function_for_streaming): New.\n\t(output_function): Do not push cfun; do not initialize loop optimizer.\n\t* lto-streamer.h (lto_prepare_function_for_streaming): Declare.\n\t* passes.c (ipa_write_summaries): Use it.\n\t(ipa_write_optimization_summaries): Do not modify bodies.\n\t* tree-dfa.c (renumber_gimple_stmt_uids): Add function parameter.\n\t* tree.dfa.h (renumber_gimple_stmt_uids): Update prototype.\n\t* tree-ssa-dse.c (pass_dse::execute): Update use of\n\trenumber_gimple_stmt_uids.\n\t* tree-ssa-math-opts.c (pass_optimize_widening_mul::execute): Likewise.\n\n\t* lto.c (lto_wpa_write_files): Prepare all bodies for streaming.\n\nFrom-SVN: r276870", "tree": {"sha": "ef9cac22b1e7b08c43bf2ff06a8714ed61dbcc77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef9cac22b1e7b08c43bf2ff06a8714ed61dbcc77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2/comments", "author": null, "committer": null, "parents": [{"sha": "05626b02e8d02720771d361677b1d6cc38df9ddc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05626b02e8d02720771d361677b1d6cc38df9ddc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05626b02e8d02720771d361677b1d6cc38df9ddc"}], "stats": {"total": 135, "additions": 73, "deletions": 62}, "files": [{"sha": "667ada73375496d370394b442ae022eac4c23584", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2", "patch": "@@ -1,3 +1,20 @@\n+2019-10-11  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gimple-streamer-out.c (output_gimple_stmt): Add explicit function\n+\tparameter.\n+\t* lto-streamer-out.c: Include tree-dfa.h.\n+\t(output_cfg): Do not use cfun.\n+\t(lto_prepare_function_for_streaming): New.\n+\t(output_function): Do not push cfun; do not initialize loop optimizer.\n+\t* lto-streamer.h (lto_prepare_function_for_streaming): Declare.\n+\t* passes.c (ipa_write_summaries): Use it.\n+\t(ipa_write_optimization_summaries): Do not modify bodies.\n+\t* tree-dfa.c (renumber_gimple_stmt_uids): Add function parameter.\n+\t* tree.dfa.h (renumber_gimple_stmt_uids): Update prototype.\n+\t* tree-ssa-dse.c (pass_dse::execute): Update use of\n+\trenumber_gimple_stmt_uids.\n+\t* tree-ssa-math-opts.c (pass_optimize_widening_mul::execute): Likewise.\n+\n 2019-10-11  Kewen Lin  <linkw@gcc.gnu.org>\n \n \t* config/rs6000/rs6000.c (rs6000_builtin_vectorization_cost): Lower"}, {"sha": "7185c07f36b2b71d150c2a96f035cd2ba5d37ec2", "filename": "gcc/gimple-streamer-out.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2/gcc%2Fgimple-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2/gcc%2Fgimple-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-out.c?ref=1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2", "patch": "@@ -57,7 +57,7 @@ output_phi (struct output_block *ob, gphi *phi)\n /* Emit statement STMT on the main stream of output block OB.  */\n \n static void\n-output_gimple_stmt (struct output_block *ob, gimple *stmt)\n+output_gimple_stmt (struct output_block *ob, struct function *fn, gimple *stmt)\n {\n   unsigned i;\n   enum gimple_code code;\n@@ -80,7 +80,7 @@ output_gimple_stmt (struct output_block *ob, gimple *stmt)\n \t\t     as_a <gassign *> (stmt)),\n \t\t   1);\n   bp_pack_value (&bp, gimple_has_volatile_ops (stmt), 1);\n-  hist = gimple_histogram_value (cfun, stmt);\n+  hist = gimple_histogram_value (fn, stmt);\n   bp_pack_value (&bp, hist != NULL, 1);\n   bp_pack_var_len_unsigned (&bp, stmt->subcode);\n \n@@ -139,15 +139,15 @@ output_gimple_stmt (struct output_block *ob, gimple *stmt)\n \t     so that we do not have to deal with type mismatches on\n \t     merged symbols during IL read in.  The first operand\n \t     of GIMPLE_DEBUG must be a decl, not MEM_REF, though.  */\n-\t  if (op && (i || !is_gimple_debug (stmt)))\n+\t  if (!flag_wpa && op && (i || !is_gimple_debug (stmt)))\n \t    {\n \t      basep = &op;\n \t      if (TREE_CODE (*basep) == ADDR_EXPR)\n \t\tbasep = &TREE_OPERAND (*basep, 0);\n \t      while (handled_component_p (*basep))\n \t\tbasep = &TREE_OPERAND (*basep, 0);\n \t      if (VAR_P (*basep)\n-\t\t  && !auto_var_in_fn_p (*basep, current_function_decl)\n+\t\t  && !auto_var_in_fn_p (*basep, fn->decl)\n \t\t  && !DECL_REGISTER (*basep))\n \t\t{\n \t\t  bool volatilep = TREE_THIS_VOLATILE (*basep);\n@@ -228,7 +228,7 @@ output_bb (struct output_block *ob, basic_block bb, struct function *fn)\n \t      print_gimple_stmt (streamer_dump_file, stmt, 0, TDF_SLIM);\n \t    }\n \n-\t  output_gimple_stmt (ob, stmt);\n+\t  output_gimple_stmt (ob, fn, stmt);\n \n \t  /* Emit the EH region holding STMT.  */\n \t  region = lookup_stmt_eh_lp_fn (fn, stmt);"}, {"sha": "c494c73f4f7fcc3255f3f753b0e381a8fc0b2c63", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"debug.h\"\n #include \"omp-offload.h\"\n #include \"print-tree.h\"\n+#include \"tree-dfa.h\"\n \n \n static void lto_write_tree (struct output_block*, tree, bool);\n@@ -1893,7 +1894,7 @@ output_cfg (struct output_block *ob, struct function *fn)\n \n   streamer_write_hwi (ob, -1);\n \n-  bb = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n+  bb = ENTRY_BLOCK_PTR_FOR_FN (fn);\n   while (bb->next_bb)\n     {\n       streamer_write_hwi (ob, bb->next_bb->index);\n@@ -1902,9 +1903,6 @@ output_cfg (struct output_block *ob, struct function *fn)\n \n   streamer_write_hwi (ob, -1);\n \n-  /* ???  The cfgloop interface is tied to cfun.  */\n-  gcc_assert (cfun == fn);\n-\n   /* Output the number of loops.  */\n   streamer_write_uhwi (ob, number_of_loops (fn));\n \n@@ -2062,6 +2060,22 @@ collect_block_tree_leafs (tree root, vec<tree> &leafs)\n       collect_block_tree_leafs (BLOCK_SUBBLOCKS (root), leafs);\n }\n \n+/* This performs function body modifications that are needed for streaming\n+   to work.  */\n+\n+void\n+lto_prepare_function_for_streaming (struct cgraph_node *node)\n+{\n+  if (number_of_loops (DECL_STRUCT_FUNCTION (node->decl)))\n+    {\n+      push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+      loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n+      loop_optimizer_finalize ();\n+      pop_cfun ();\n+    }\n+  renumber_gimple_stmt_uids (DECL_STRUCT_FUNCTION (node->decl));\n+}\n+\n /* Output the body of function NODE->DECL.  */\n \n static void\n@@ -2085,9 +2099,6 @@ output_function (struct cgraph_node *node)\n \n   gcc_assert (current_function_decl == NULL_TREE && cfun == NULL);\n \n-  /* Set current_function_decl and cfun.  */\n-  push_cfun (fn);\n-\n   /* Make string 0 be a NULL string.  */\n   streamer_write_char_stream (ob->string_stream, 0);\n \n@@ -2124,9 +2135,6 @@ output_function (struct cgraph_node *node)\n      debug info.  */\n   if (gimple_has_body_p (function))\n     {\n-      /* Fixup loops if required to match discovery done in the reader.  */\n-      loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n-\n       streamer_write_uhwi (ob, 1);\n       output_struct_function_base (ob, fn);\n \n@@ -2143,8 +2151,8 @@ output_function (struct cgraph_node *node)\n \t statement numbers.  We do not assign UIDs to PHIs here because\n \t virtual PHIs get re-computed on-the-fly which would make numbers\n \t inconsistent.  */\n-      set_gimple_stmt_max_uid (cfun, 0);\n-      FOR_ALL_BB_FN (bb, cfun)\n+      set_gimple_stmt_max_uid (fn, 0);\n+      FOR_ALL_BB_FN (bb, fn)\n \t{\n \t  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n \t       gsi_next (&gsi))\n@@ -2153,25 +2161,25 @@ output_function (struct cgraph_node *node)\n \n \t      /* Virtual PHIs are not going to be streamed.  */\n \t      if (!virtual_operand_p (gimple_phi_result (stmt)))\n-\t        gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));\n+\t        gimple_set_uid (stmt, inc_gimple_stmt_max_uid (fn));\n \t    }\n \t  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n \t       gsi_next (&gsi))\n \t    {\n \t      gimple *stmt = gsi_stmt (gsi);\n-\t      gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));\n+\t      gimple_set_uid (stmt, inc_gimple_stmt_max_uid (fn));\n \t    }\n \t}\n       /* To avoid keeping duplicate gimple IDs in the statements, renumber\n \t virtual phis now.  */\n-      FOR_ALL_BB_FN (bb, cfun)\n+      FOR_ALL_BB_FN (bb, fn)\n \t{\n \t  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n \t       gsi_next (&gsi))\n \t    {\n \t      gphi *stmt = gsi.phi ();\n \t      if (virtual_operand_p (gimple_phi_result (stmt)))\n-\t        gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));\n+\t        gimple_set_uid (stmt, inc_gimple_stmt_max_uid (fn));\n \t    }\n \t}\n \n@@ -2183,9 +2191,6 @@ output_function (struct cgraph_node *node)\n       streamer_write_record_start (ob, LTO_null);\n \n       output_cfg (ob, fn);\n-\n-      loop_optimizer_finalize ();\n-      pop_cfun ();\n    }\n   else\n     streamer_write_uhwi (ob, 0);"}, {"sha": "9f787c4bd1efcce93736a1f3538f3cbc91f1fe93", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2", "patch": "@@ -909,6 +909,7 @@ void lto_output_decl_state_refs (struct output_block *,\n \t\t\t         struct lto_out_decl_state *);\n void lto_output_location (struct output_block *, struct bitpack_d *, location_t);\n void lto_output_init_mode_table (void);\n+void lto_prepare_function_for_streaming (cgraph_node *);\n \n \n /* In lto-cgraph.c  */"}, {"sha": "5fd02dff7cd161a6314e2c030414eae7b2ea9b47", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2", "patch": "@@ -1,3 +1,7 @@\n+2019-10-11  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto.c (lto_wpa_write_files): Prepare all bodies for streaming.\n+\n 2019-10-10  Richard Biener  <rguenther@suse.de>\n \n \t* lto-common.c (unify_scc): Do not merge anonymous NAMESPACE_DECLs."}, {"sha": "f7452c232fe4176e14ca3b14efe09fd77039a8f6", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2", "patch": "@@ -304,6 +304,13 @@ lto_wpa_write_files (void)\n \n   timevar_push (TV_WHOPR_WPA_IO);\n \n+  cgraph_node *node;\n+  /* Do body modifications needed for streaming before we fork out\n+     worker processes.  */\n+  FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n+    if (gimple_has_body_p (node->decl))\n+      lto_prepare_function_for_streaming (node);\n+\n   /* Generate a prefix for the LTRANS unit files.  */\n   blen = strlen (ltrans_output_list);\n   temp_filename = (char *) xmalloc (blen + sizeof (\"2147483648.o\"));"}, {"sha": "863605da2922fa6a0b197ffe2ca7e2a155511e3e", "filename": "gcc/passes.c", "status": "modified", "additions": 7, "deletions": 30, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2", "patch": "@@ -2705,20 +2705,12 @@ ipa_write_summaries (void)\n     {\n       struct cgraph_node *node = order[i];\n \n-      if (gimple_has_body_p (node->decl))\n+      if (node->definition && node->need_lto_streaming)\n \t{\n-\t  /* When streaming out references to statements as part of some IPA\n-\t     pass summary, the statements need to have uids assigned and the\n-\t     following does that for all the IPA passes here. Naturally, this\n-\t     ordering then matches the one IPA-passes get in their stmt_fixup\n-\t     hooks.  */\n-\n-\t  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n-\t  renumber_gimple_stmt_uids ();\n-\t  pop_cfun ();\n+\t  if (gimple_has_body_p (node->decl))\n+\t    lto_prepare_function_for_streaming (node);\n+\t  lto_set_symtab_encoder_in_partition (encoder, node);\n \t}\n-      if (node->definition && node->need_lto_streaming)\n-        lto_set_symtab_encoder_in_partition (encoder, node);\n     }\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n@@ -2786,28 +2778,13 @@ void\n ipa_write_optimization_summaries (lto_symtab_encoder_t encoder)\n {\n   struct lto_out_decl_state *state = lto_new_out_decl_state ();\n-  lto_symtab_encoder_iterator lsei;\n   state->symtab_node_encoder = encoder;\n \n   lto_output_init_mode_table ();\n   lto_push_out_decl_state (state);\n-  for (lsei = lsei_start_function_in_partition (encoder);\n-       !lsei_end_p (lsei); lsei_next_function_in_partition (&lsei))\n-    {\n-      struct cgraph_node *node = lsei_cgraph_node (lsei);\n-      /* When streaming out references to statements as part of some IPA\n-\t pass summary, the statements need to have uids assigned.\n-\n-\t For functions newly born at WPA stage we need to initialize\n-\t the uids here.  */\n-      if (node->definition\n-\t  && gimple_has_body_p (node->decl))\n-\t{\n-\t  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n-\t  renumber_gimple_stmt_uids ();\n-\t  pop_cfun ();\n-\t}\n-    }\n+\n+  /* Be sure that we did not forget to renumber stmt uids.  */\n+  gcc_checking_assert (flag_wpa);\n \n   gcc_assert (flag_wpa);\n   pass_manager *passes = g->get_passes ();"}, {"sha": "64991ba92fa7bf4eea1ab7d121e088b4208dffba", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2", "patch": "@@ -61,23 +61,23 @@ static void collect_dfa_stats (struct dfa_stats_d *);\n /* Renumber all of the gimple stmt uids.  */\n \n void\n-renumber_gimple_stmt_uids (void)\n+renumber_gimple_stmt_uids (struct function *fun)\n {\n   basic_block bb;\n \n-  set_gimple_stmt_max_uid (cfun, 0);\n-  FOR_ALL_BB_FN (bb, cfun)\n+  set_gimple_stmt_max_uid (fun, 0);\n+  FOR_ALL_BB_FN (bb, fun)\n     {\n       gimple_stmt_iterator bsi;\n       for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n \t{\n \t  gimple *stmt = gsi_stmt (bsi);\n-\t  gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));\n+\t  gimple_set_uid (stmt, inc_gimple_stmt_max_uid (fun));\n \t}\n       for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n \t{\n \t  gimple *stmt = gsi_stmt (bsi);\n-\t  gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));\n+\t  gimple_set_uid (stmt, inc_gimple_stmt_max_uid (fun));\n \t}\n     }\n }"}, {"sha": "aa4ab7eb9462640cfa8d8cf2bede653e30d7a875", "filename": "gcc/tree-dfa.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2/gcc%2Ftree-dfa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2/gcc%2Ftree-dfa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.h?ref=1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2", "patch": "@@ -20,7 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_TREE_DFA_H\n #define GCC_TREE_DFA_H\n \n-extern void renumber_gimple_stmt_uids (void);\n+extern void renumber_gimple_stmt_uids (struct function *);\n extern void renumber_gimple_stmt_uids_in_blocks (basic_block *, int);\n extern void dump_variable (FILE *, tree);\n extern void debug_variable (tree);"}, {"sha": "25cd4709b3111b300de80b06b59034e2a6e655a4", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2", "patch": "@@ -1113,7 +1113,7 @@ pass_dse::execute (function *fun)\n {\n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n \n-  renumber_gimple_stmt_uids ();\n+  renumber_gimple_stmt_uids (cfun);\n \n   /* We might consider making this a property of each pass so that it\n      can be [re]computed on an as-needed basis.  Particularly since"}, {"sha": "013ef93e7ad00c40b357db094c4824b8e4c15bb3", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=1fcf52a6a2208a57e4542e1b830a7ac5cfa216a2", "patch": "@@ -3850,7 +3850,7 @@ pass_optimize_widening_mul::execute (function *fun)\n \n   memset (&widen_mul_stats, 0, sizeof (widen_mul_stats));\n   calculate_dominance_info (CDI_DOMINATORS);\n-  renumber_gimple_stmt_uids ();\n+  renumber_gimple_stmt_uids (cfun);\n \n   math_opts_dom_walker (&cfg_changed).walk (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n "}]}