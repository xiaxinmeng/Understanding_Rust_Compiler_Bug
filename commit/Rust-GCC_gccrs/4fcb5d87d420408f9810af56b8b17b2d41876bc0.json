{"sha": "4fcb5d87d420408f9810af56b8b17b2d41876bc0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZjYjVkODdkNDIwNDA4Zjk4MTBhZjU2YjhiMTdiMmQ0MTg3NmJjMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2013-05-22T10:39:03Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-05-22T10:39:03Z"}, "message": "sol2-unwind.h (sparc64_frob_update_context): Do it for signal frames as well.\n\n\t* config/sparc/sol2-unwind.h (sparc64_frob_update_context): Do it for\n\tsignal frames as well.\n\t(MD_FALLBACK_FRAME_STATE_FOR): Do minor cleanups throughout and add the\n\tSTACK_BIAS to the CFA offset.\n\nFrom-SVN: r199191", "tree": {"sha": "7548e1ba9721293c6bf1e352e1d0edbe58ea1a3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7548e1ba9721293c6bf1e352e1d0edbe58ea1a3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fcb5d87d420408f9810af56b8b17b2d41876bc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fcb5d87d420408f9810af56b8b17b2d41876bc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fcb5d87d420408f9810af56b8b17b2d41876bc0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fcb5d87d420408f9810af56b8b17b2d41876bc0/comments", "author": null, "committer": null, "parents": [{"sha": "2ac2f83d0ad51d386ecec48f12b685a2d244cdff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ac2f83d0ad51d386ecec48f12b685a2d244cdff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ac2f83d0ad51d386ecec48f12b685a2d244cdff"}], "stats": {"total": 31, "additions": 16, "deletions": 15}, "files": [{"sha": "a1bd0bffc3b4025a4729ea95487c42c453c5e0b6", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fcb5d87d420408f9810af56b8b17b2d41876bc0/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fcb5d87d420408f9810af56b8b17b2d41876bc0/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=4fcb5d87d420408f9810af56b8b17b2d41876bc0", "patch": "@@ -1,3 +1,10 @@\n+2013-05-22  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/sparc/sol2-unwind.h (sparc64_frob_update_context): Do it for\n+\tsignal frames as well.\n+\t(MD_FALLBACK_FRAME_STATE_FOR): Do minor cleanups throughout and add the\n+\tSTACK_BIAS to the CFA offset.\n+\n 2013-05-17  Richard Henderson  <rth@redhat.com>\n \n \tPR target/49146"}, {"sha": "584a9b09666d79d05511ff8c826e2edddcbc303f", "filename": "libgcc/config/sparc/sol2-unwind.h", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fcb5d87d420408f9810af56b8b17b2d41876bc0/libgcc%2Fconfig%2Fsparc%2Fsol2-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fcb5d87d420408f9810af56b8b17b2d41876bc0/libgcc%2Fconfig%2Fsparc%2Fsol2-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fsparc%2Fsol2-unwind.h?ref=4fcb5d87d420408f9810af56b8b17b2d41876bc0", "patch": "@@ -155,12 +155,10 @@ sparc64_frob_update_context (struct _Unwind_Context *context,\n {\n   /* The column of %sp contains the old CFA, not the old value of %sp.\n      The CFA offset already comprises the stack bias so, when %sp is the\n-     CFA register, we must avoid counting the stack bias twice.  Do not\n-     do that for signal frames as the offset is artificial for them.  */\n+     CFA register, we must avoid counting the stack bias twice.  */\n   if (fs->regs.cfa_reg == __builtin_dwarf_sp_column ()\n       && fs->regs.cfa_how == CFA_REG_OFFSET\n-      && fs->regs.cfa_offset != 0\n-      && !fs->signal_frame)\n+      && fs->regs.cfa_offset != 0)\n     {\n       long i;\n \n@@ -296,9 +294,8 @@ MD_FALLBACK_FRAME_STATE_FOR (struct _Unwind_Context *context,\n \t\t\t     _Unwind_FrameState *fs)\n {\n   void *pc = context->ra;\n-  struct frame *fp = (struct frame *) context->cfa;\n-  int nframes;\n   void *this_cfa = context->cfa;\n+  int nframes = 0;\n   long new_cfa;\n   void *ra_location, *shifted_ra_location;\n   mcontext_t *mctx;\n@@ -318,41 +315,38 @@ MD_FALLBACK_FRAME_STATE_FOR (struct _Unwind_Context *context,\n       return _URC_NO_REASON;\n     }\n \n+  /* Do some pattern matching at the return address.  */\n   if (IS_SIGHANDLER (pc, this_cfa, &nframes))\n     {\n+      struct frame *fp = (struct frame *) this_cfa;\n       struct handler_args {\n \tstruct frame frwin;\n \tucontext_t ucontext;\n       } *handler_args;\n       ucontext_t *ucp;\n \n-      /* context->cfa points into the frame after the saved frame pointer and\n+      /* this_cfa points into the frame after the saved frame pointer and\n          saved pc (struct frame).\n \n          The ucontext_t structure is in the kernel frame after a struct\n          frame.  Since the frame sizes vary even within OS releases, we\n          need to walk the stack to get there.  */\n-\n       for (i = 0; i < nframes; i++)\n \tfp = (struct frame *) ((char *)fp->fr_savfp + STACK_BIAS);\n \n       handler_args = (struct handler_args *) fp;\n       ucp = &handler_args->ucontext;\n       mctx = &ucp->uc_mcontext;\n     }\n-\n-  /* Exit if the pattern at the return address does not match the\n-     previous three patterns.  */\n   else\n     return _URC_END_OF_STACK;\n \n-  new_cfa = mctx->gregs[REG_SP];\n   /* The frame address is %sp + STACK_BIAS in 64-bit mode.  */\n-  new_cfa += STACK_BIAS;\n+  new_cfa = mctx->gregs[REG_SP] + STACK_BIAS;\n \n   fs->regs.cfa_how = CFA_REG_OFFSET;\n   fs->regs.cfa_reg = __builtin_dwarf_sp_column ();\n-  fs->regs.cfa_offset = new_cfa - (long) this_cfa;\n+  fs->regs.cfa_offset = new_cfa - (long) this_cfa + STACK_BIAS;\n \n   /* Restore global and out registers (in this order) from the\n      ucontext_t structure, uc_mcontext.gregs field.  */\n@@ -372,7 +366,7 @@ MD_FALLBACK_FRAME_STATE_FOR (struct _Unwind_Context *context,\n   for (i = 0; i < 16; i++)\n     {\n       fs->regs.reg[i + 16].how = REG_SAVED_OFFSET;\n-      fs->regs.reg[i + 16].loc.offset = i*sizeof(long);\n+      fs->regs.reg[i + 16].loc.offset = i * sizeof(long);\n     }\n \n   /* Check whether we need to restore FPU registers.  */"}]}