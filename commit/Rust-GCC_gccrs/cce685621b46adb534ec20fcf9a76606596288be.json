{"sha": "cce685621b46adb534ec20fcf9a76606596288be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NlNjg1NjIxYjQ2YWRiNTM0ZWMyMGZjZjlhNzY2MDY1OTYyODhiZQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2006-10-31T17:51:38Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T17:51:38Z"}, "message": "clean.adb, [...]: Fix bad table increment values (much too small)\n\n2006-10-31  Robert Dewar  <dewar@adacore.com>\n\n\t* clean.adb, gnatname.adb, gnatsym.adb, prep.adb, prep.ads,\n\tprepcomp.adb, prj.ads, prj-strt.adb, sem_maps.ads,\n\tvms_conv.adb: Fix bad table increment values (much too small)\n\n\t* table.adb (Realloc): Make sure we get at least some new elements\n\tDefends against silly small values for table increment\n\nFrom-SVN: r118249", "tree": {"sha": "82f467f6771df85b9ce495a5af4527dc1f9635c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82f467f6771df85b9ce495a5af4527dc1f9635c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cce685621b46adb534ec20fcf9a76606596288be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cce685621b46adb534ec20fcf9a76606596288be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cce685621b46adb534ec20fcf9a76606596288be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cce685621b46adb534ec20fcf9a76606596288be/comments", "author": null, "committer": null, "parents": [{"sha": "c064e066027cb688449ce4e3fd28126fe45b0e11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c064e066027cb688449ce4e3fd28126fe45b0e11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c064e066027cb688449ce4e3fd28126fe45b0e11"}], "stats": {"total": 1233, "additions": 619, "deletions": 614}, "files": [{"sha": "0897c27e6c13c2ec7c9456b95d0cbe9c52432848", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce685621b46adb534ec20fcf9a76606596288be/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce685621b46adb534ec20fcf9a76606596288be/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=cce685621b46adb534ec20fcf9a76606596288be", "patch": "@@ -120,7 +120,7 @@ package body Clean is\n       Table_Index_Type     => Natural,\n       Table_Low_Bound      => 0,\n       Table_Initial        => 10,\n-      Table_Increment      => 10,\n+      Table_Increment      => 100,\n       Table_Name           => \"Clean.Processed_Projects\");\n    --  Table to keep track of what project files have been processed, when\n    --  switch -r is specified.\n@@ -130,7 +130,7 @@ package body Clean is\n       Table_Index_Type     => Natural,\n       Table_Low_Bound      => 0,\n       Table_Initial        => 10,\n-      Table_Increment      => 10,\n+      Table_Increment      => 100,\n       Table_Name           => \"Clean.Processed_Projects\");\n    --  Table to store all the source files of a library unit: spec, body and\n    --  subunits, to detect .dg files and delete them."}, {"sha": "714ba42f589fad90e8c32cf2988c2b7944a6a146", "filename": "gcc/ada/gnatname.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce685621b46adb534ec20fcf9a76606596288be/gcc%2Fada%2Fgnatname.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce685621b46adb534ec20fcf9a76606596288be/gcc%2Fada%2Fgnatname.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatname.adb?ref=cce685621b46adb534ec20fcf9a76606596288be", "patch": "@@ -66,7 +66,7 @@ procedure Gnatname is\n       Table_Index_Type     => Natural,\n       Table_Low_Bound      => 0,\n       Table_Initial        => 10,\n-      Table_Increment      => 10,\n+      Table_Increment      => 100,\n       Table_Name           => \"Gnatname.Excluded_Patterns\");\n    --  Table to accumulate the negative patterns\n \n@@ -75,7 +75,7 @@ procedure Gnatname is\n       Table_Index_Type     => Natural,\n       Table_Low_Bound      => 0,\n       Table_Initial        => 10,\n-      Table_Increment      => 10,\n+      Table_Increment      => 100,\n       Table_Name           => \"Gnatname.Foreign_Patterns\");\n    --  Table to accumulate the foreign patterns\n \n@@ -84,7 +84,7 @@ procedure Gnatname is\n       Table_Index_Type     => Natural,\n       Table_Low_Bound      => 0,\n       Table_Initial        => 10,\n-      Table_Increment      => 10,\n+      Table_Increment      => 100,\n       Table_Name           => \"Gnatname.Patterns\");\n    --  Table to accumulate the name patterns\n \n@@ -93,7 +93,7 @@ procedure Gnatname is\n       Table_Index_Type     => Natural,\n       Table_Low_Bound      => 0,\n       Table_Initial        => 10,\n-      Table_Increment      => 10,\n+      Table_Increment      => 100,\n       Table_Name           => \"Gnatname.Source_Directories\");\n    --  Table to accumulate the source directories specified directly with -d\n    --  or indirectly with -D.\n@@ -102,8 +102,8 @@ procedure Gnatname is\n      (Table_Component_Type => String_Access,\n       Table_Index_Type     => Natural,\n       Table_Low_Bound      => 0,\n-      Table_Initial        => 2,\n-      Table_Increment      => 50,\n+      Table_Initial        => 10,\n+      Table_Increment      => 100,\n       Table_Name           => \"Gnatname.Preprocessor_Switches\");\n    --  Table to store the preprocessor switches to be used in the call\n    --  to the compiler."}, {"sha": "f05ad9c0f27a99def71f041be8e306052f801d62", "filename": "gcc/ada/gnatsym.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce685621b46adb534ec20fcf9a76606596288be/gcc%2Fada%2Fgnatsym.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce685621b46adb534ec20fcf9a76606596288be/gcc%2Fada%2Fgnatsym.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatsym.adb?ref=cce685621b46adb534ec20fcf9a76606596288be", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2003-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2003-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -85,7 +85,7 @@ procedure Gnatsym is\n       Table_Index_Type     => Natural,\n       Table_Low_Bound      => 0,\n       Table_Initial        => 10,\n-      Table_Increment      => 10,\n+      Table_Increment      => 100,\n       Table_Name           => \"Gnatsymb.Object_Files\");\n    --  A table to store the object file names\n "}, {"sha": "09ba3bfb197ac5d7e9196d52b548895b498e6621", "filename": "gcc/ada/prep.adb", "status": "modified", "additions": 577, "deletions": 577, "changes": 1154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce685621b46adb534ec20fcf9a76606596288be/gcc%2Fada%2Fprep.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce685621b46adb534ec20fcf9a76606596288be/gcc%2Fada%2Fprep.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprep.adb?ref=cce685621b46adb534ec20fcf9a76606596288be", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2002-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2002-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -178,7 +178,7 @@ package body Prep is\n       Table_Index_Type     => Pp_Depth,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 10,\n-      Table_Increment      => 10,\n+      Table_Increment      => 100,\n       Table_Name           => \"Prep.Pp_States\");\n    --  A stack of the states of the preprocessor, for nested #if\n \n@@ -675,768 +675,768 @@ package body Prep is\n    end Index_Of;\n \n    ----------------\n-   -- Preprocess --\n+   -- Initialize --\n    ----------------\n \n-   procedure Preprocess is\n-      Start_Of_Processing : Source_Ptr;\n-      Cond : Boolean;\n-      Preprocessor_Line : Boolean := False;\n+   procedure Initialize\n+     (Error_Msg         : Error_Msg_Proc;\n+      Scan              : Scan_Proc;\n+      Set_Ignore_Errors : Set_Ignore_Errors_Proc;\n+      Put_Char          : Put_Char_Proc;\n+      New_EOL           : New_EOL_Proc)\n+   is\n+   begin\n+      if not Already_Initialized then\n+         Start_String;\n+         Store_String_Chars (\"True\");\n+         True_Value.Value := End_String;\n \n-      procedure Output (From, To : Source_Ptr);\n-      --  Output the characters with indices From .. To in the buffer\n-      --  to the output file.\n+         Start_String;\n+         Empty_String := End_String;\n \n-      procedure Output_Line (From, To : Source_Ptr);\n-      --  Output a line or the end of a line from the buffer to the output\n-      --  file, followed by an end of line terminator. Depending on the value\n-      --  of Deleting and the switches, the line may be commented out, blank or\n-      --  not output at all.\n+         Name_Len := 7;\n+         Name_Buffer (1 .. Name_Len) := \"defined\";\n+         Name_Defined := Name_Find;\n \n-      ------------\n-      -- Output --\n-      ------------\n+         Start_String;\n+         Store_String_Chars (\"False\");\n+         String_False := End_String;\n \n-      procedure Output (From, To : Source_Ptr) is\n-      begin\n-         for J in From .. To loop\n-            Put_Char (Sinput.Source (J));\n-         end loop;\n-      end Output;\n+         Already_Initialized := True;\n+      end if;\n \n-      -----------------\n-      -- Output_Line --\n-      -----------------\n+      Prep.Error_Msg         := Error_Msg;\n+      Prep.Scan              := Scan;\n+      Prep.Set_Ignore_Errors := Set_Ignore_Errors;\n+      Prep.Put_Char          := Put_Char;\n+      Prep.New_EOL           := New_EOL;\n+   end Initialize;\n+\n+   ------------------\n+   -- List_Symbols --\n+   ------------------\n+\n+   procedure List_Symbols (Foreword : String) is\n+      Order : array (0 ..  Integer (Symbol_Table.Last (Mapping)))\n+                 of Symbol_Id;\n+      --  After alphabetical sorting, this array stores thehe indices of\n+      --  the symbols in the order they are displayed.\n+\n+      function Lt (Op1, Op2 : Natural) return Boolean;\n+      --  Comparison routine for sort call\n+\n+      procedure Move (From : Natural; To : Natural);\n+      --  Move routine for sort call\n+\n+      --------\n+      -- Lt --\n+      --------\n+\n+      function Lt (Op1, Op2 : Natural) return Boolean is\n+         S1 : constant String :=\n+                Get_Name_String (Mapping.Table (Order (Op1)).Symbol);\n+         S2 : constant String :=\n+                Get_Name_String (Mapping.Table (Order (Op2)).Symbol);\n \n-      procedure Output_Line (From, To : Source_Ptr) is\n       begin\n-         if Deleting or Preprocessor_Line then\n-            if Blank_Deleted_Lines then\n-               New_EOL.all;\n+         return S1 < S2;\n+      end Lt;\n \n-            elsif Comment_Deleted_Lines then\n-               Put_Char ('-');\n-               Put_Char ('-');\n-               Put_Char ('!');\n+      ----------\n+      -- Move --\n+      ----------\n \n-               if From < To then\n-                  Put_Char (' ');\n-                  Output (From, To);\n-               end if;\n+      procedure Move (From : Natural; To : Natural) is\n+      begin\n+         Order (To) := Order (From);\n+      end Move;\n \n-               New_EOL.all;\n-            end if;\n+      package Sort_Syms is new GNAT.Heap_Sort_G (Move, Lt);\n \n-         else\n-            Output (From, To);\n-            New_EOL.all;\n-         end if;\n-      end Output_Line;\n+      Max_L : Natural;\n+      --  Maximum length of any symbol\n \n-   --  Start of processing for Preprocess\n+   --  Start of processing for List_Symbols_Case\n \n    begin\n-      Start_Of_Processing := Scan_Ptr;\n+      if Symbol_Table.Last (Mapping) = 0 then\n+         return;\n+      end if;\n \n-      --  We need to call Scan for the first time, because Initialize_Scanner\n-      --  is no longer doing it.\n+      if Foreword'Length > 0 then\n+         Write_Eol;\n+         Write_Line (Foreword);\n \n-      Scan.all;\n+         for J in Foreword'Range loop\n+            Write_Char ('=');\n+         end loop;\n+      end if;\n \n-      Input_Line_Loop : loop\n-         exit Input_Line_Loop when Token = Tok_EOF;\n+      --  Initialize the order\n \n-         Preprocessor_Line := False;\n+      for J in Order'Range loop\n+         Order (J) := Symbol_Id (J);\n+      end loop;\n \n-         if Token /= Tok_End_Of_Line then\n+      --  Sort alphabetically\n \n-            --  Preprocessor line\n+      Sort_Syms.Sort (Order'Last);\n \n-            if Token = Tok_Special and then Special_Character = '#' then\n-                  Preprocessor_Line := True;\n-                  Scan.all;\n+      Max_L := 7;\n \n-                  case Token is\n+      for J in 1 .. Symbol_Table.Last (Mapping) loop\n+         Get_Name_String (Mapping.Table (J).Original);\n+         Max_L := Integer'Max (Max_L, Name_Len);\n+      end loop;\n \n-                     --  #if\n+      Write_Eol;\n+      Write_Str (\"Symbol\");\n \n-                     when Tok_If =>\n-                        declare\n-                           If_Ptr : constant Source_Ptr := Token_Ptr;\n+      for J in 1 .. Max_L - 5 loop\n+         Write_Char (' ');\n+      end loop;\n \n-                        begin\n-                           Scan.all;\n-                           Cond := Expression (not Deleting);\n+      Write_Line (\"Value\");\n \n-                           --  Check for an eventual \"then\"\n+      Write_Str (\"------\");\n \n-                           if Token = Tok_Then then\n-                              Scan.all;\n-                           end if;\n+      for J in 1 .. Max_L - 5 loop\n+         Write_Char (' ');\n+      end loop;\n \n-                           --  It is an error to have trailing characters after\n-                           --  the condition or \"then\".\n+      Write_Line (\"------\");\n \n-                           if Token /= Tok_End_Of_Line\n-                             and then Token /= Tok_EOF\n-                           then\n-                              Error_Msg\n-                                (\"extraneous text on preprocessor line\",\n-                                 Token_Ptr);\n-                              Go_To_End_Of_Line;\n-                           end if;\n+      for J in 1 .. Order'Last loop\n+         declare\n+            Data : constant Symbol_Data := Mapping.Table (Order (J));\n \n-                           declare\n-                              --  Set the initial state of this new \"#if\".\n-                              --  This must be done before incrementing the\n-                              --  Last of the table, otherwise function\n-                              --  Deleting does not report the correct value.\n+         begin\n+            Get_Name_String (Data.Original);\n+            Write_Str (Name_Buffer (1 .. Name_Len));\n \n-                              New_State : constant Pp_State :=\n-                                (If_Ptr     => If_Ptr,\n-                                 Else_Ptr   => 0,\n-                                 Deleting   => Deleting or (not Cond),\n-                                 Match_Seen => Deleting or Cond);\n+            for K in Name_Len .. Max_L loop\n+               Write_Char (' ');\n+            end loop;\n \n-                           begin\n-                              Pp_States.Increment_Last;\n-                              Pp_States.Table (Pp_States.Last) := New_State;\n-                           end;\n-                        end;\n+            String_To_Name_Buffer (Data.Value);\n \n-                     --  #elsif\n+            if Data.Is_A_String then\n+               Write_Char ('\"');\n \n-                     when Tok_Elsif =>\n-                        Cond := False;\n+               for J in 1 .. Name_Len loop\n+                  Write_Char (Name_Buffer (J));\n \n-                        if Pp_States.Last = 0\n-                          or else Pp_States.Table (Pp_States.Last).Else_Ptr\n-                                                                        /= 0\n-                        then\n-                           Error_Msg (\"no IF for this ELSIF\", Token_Ptr);\n+                  if Name_Buffer (J) = '\"' then\n+                     Write_Char ('\"');\n+                  end if;\n+               end loop;\n \n-                        else\n-                           Cond :=\n-                             not Pp_States.Table (Pp_States.Last).Match_Seen;\n-                        end if;\n+               Write_Char ('\"');\n \n-                        Scan.all;\n-                        Cond := Expression (Cond);\n+            else\n+               Write_Str (Name_Buffer (1 .. Name_Len));\n+            end if;\n+         end;\n \n-                        --  Check for an eventual \"then\"\n+         Write_Eol;\n+      end loop;\n \n-                        if Token = Tok_Then then\n-                           Scan.all;\n-                        end if;\n+      Write_Eol;\n+   end List_Symbols;\n \n-                        --  It is an error to have trailing characters after\n-                        --  the condition or \"then\".\n+   ----------------------\n+   -- Matching_Strings --\n+   ----------------------\n \n-                        if Token /= Tok_End_Of_Line\n-                          and then Token /= Tok_EOF\n-                        then\n-                           Error_Msg\n-                             (\"extraneous text on preprocessor line\",\n-                              Token_Ptr);\n+   function Matching_Strings (S1, S2 : String_Id) return Boolean is\n+   begin\n+      String_To_Name_Buffer (S1);\n \n-                           Go_To_End_Of_Line;\n-                        end if;\n+      for Index in 1 .. Name_Len loop\n+         Name_Buffer (Index) := Fold_Lower (Name_Buffer (Index));\n+      end loop;\n \n-                        --  Depending on the value of the condition, set the\n-                        --  new values of Deleting and Match_Seen.\n-                        if Pp_States.Last > 0 then\n-                           if Pp_States.Table (Pp_States.Last).Match_Seen then\n-                              Pp_States.Table (Pp_States.Last).Deleting :=\n-                                True;\n-                           else\n-                              if Cond then\n-                                 Pp_States.Table (Pp_States.Last).Match_Seen :=\n-                                   True;\n-                                 Pp_States.Table (Pp_States.Last).Deleting :=\n-                                   False;\n-                              end if;\n-                           end if;\n-                        end if;\n+      declare\n+         String1 : constant String := Name_Buffer (1 .. Name_Len);\n \n-                     --  #else\n+      begin\n+         String_To_Name_Buffer (S2);\n \n-                     when Tok_Else =>\n-                        if Pp_States.Last = 0 then\n-                           Error_Msg (\"no IF for this ELSE\", Token_Ptr);\n+         for Index in 1 .. Name_Len loop\n+            Name_Buffer (Index) := Fold_Lower (Name_Buffer (Index));\n+         end loop;\n \n-                        elsif\n-                           Pp_States.Table (Pp_States.Last).Else_Ptr /= 0\n-                        then\n-                           Error_Msg (\"duplicate ELSE line\", Token_Ptr);\n-                        end if;\n+         return String1 = Name_Buffer (1 .. Name_Len);\n+      end;\n+   end Matching_Strings;\n \n-                        --  Set the possibly new values of Deleting and\n-                        --  Match_Seen.\n+   --------------------\n+   -- Parse_Def_File --\n+   --------------------\n \n-                        if Pp_States.Last > 0 then\n-                           if Pp_States.Table (Pp_States.Last).Match_Seen then\n-                              Pp_States.Table (Pp_States.Last).Deleting :=\n-                                True;\n+   procedure Parse_Def_File is\n+      Symbol        : Symbol_Id;\n+      Symbol_Name   : Name_Id;\n+      Original_Name : Name_Id;\n+      Data          : Symbol_Data;\n+      Value_Start   : Source_Ptr;\n+      Value_End     : Source_Ptr;\n+      Ch            : Character;\n \n-                           else\n-                              Pp_States.Table (Pp_States.Last).Match_Seen :=\n-                                True;\n-                              Pp_States.Table (Pp_States.Last).Deleting :=\n-                                False;\n-                           end if;\n+      use ASCII;\n \n-                           --  Set the Else_Ptr to check for illegal #elsif\n-                           --  later.\n+   begin\n+      Def_Line_Loop :\n+      loop\n+         Scan.all;\n \n-                           Pp_States.Table (Pp_States.Last).Else_Ptr :=\n-                             Token_Ptr;\n-                        end if;\n+         exit Def_Line_Loop when Token = Tok_EOF;\n \n-                        Scan.all;\n+         if Token /= Tok_End_Of_Line then\n+            Change_Reserved_Keyword_To_Symbol;\n \n-                        --  It is an error to have characters after \"#else\"\n-                        if Token /= Tok_End_Of_Line\n-                          and then Token /= Tok_EOF\n-                        then\n-                           Error_Msg\n-                             (\"extraneous text on preprocessor line\",\n-                              Token_Ptr);\n-                           Go_To_End_Of_Line;\n-                        end if;\n+            if Token /= Tok_Identifier then\n+               Error_Msg (\"identifier expected\", Token_Ptr);\n+               goto Cleanup;\n+            end if;\n \n-                     --  #end if;\n+            Symbol_Name := Token_Name;\n+            Name_Len := 0;\n \n-                     when Tok_End =>\n-                        if Pp_States.Last = 0 then\n-                           Error_Msg (\"no IF for this END\", Token_Ptr);\n-                        end if;\n+            for Ptr in Token_Ptr .. Scan_Ptr - 1 loop\n+               Name_Len := Name_Len + 1;\n+               Name_Buffer (Name_Len) := Sinput.Source (Ptr);\n+            end loop;\n \n-                        Scan.all;\n+            Original_Name := Name_Find;\n+            Scan.all;\n \n-                        if Token /= Tok_If then\n-                           Error_Msg (\"IF expected\", Token_Ptr);\n+            if Token /= Tok_Colon_Equal then\n+               Error_Msg (\"`:=` expected\", Token_Ptr);\n+               goto Cleanup;\n+            end if;\n \n-                        else\n-                           Scan.all;\n+            Scan.all;\n \n-                           if Token /= Tok_Semicolon then\n-                              Error_Msg (\"`;` Expected\", Token_Ptr);\n+            if Token = Tok_String_Literal then\n+               Data := (Symbol              => Symbol_Name,\n+                        Original            => Original_Name,\n+                        On_The_Command_Line => False,\n+                        Is_A_String         => True,\n+                        Value               => String_Literal_Id);\n \n-                           else\n-                              Scan.all;\n+               Scan.all;\n \n-                              --  It is an error to have character after\n-                              --  \"#end if;\".\n-                              if Token /= Tok_End_Of_Line\n-                                and then Token /= Tok_EOF\n-                              then\n-                                 Error_Msg\n-                                   (\"extraneous text on preprocessor line\",\n-                                    Token_Ptr);\n-                              end if;\n-                           end if;\n-                        end if;\n+               if Token /= Tok_End_Of_Line and then Token /= Tok_EOF then\n+                  Error_Msg (\"extraneous text in definition\", Token_Ptr);\n+                  goto Cleanup;\n+               end if;\n \n-                        --  In case of one of the errors above, skip the tokens\n-                        --  until the end of line is reached.\n+            elsif Token = Tok_End_Of_Line or Token = Tok_EOF then\n+               Data := (Symbol              => Symbol_Name,\n+                        Original            => Original_Name,\n+                        On_The_Command_Line => False,\n+                        Is_A_String         => False,\n+                        Value               => Empty_String);\n \n-                        Go_To_End_Of_Line;\n+            else\n+               Value_Start := Token_Ptr;\n+               Value_End   := Token_Ptr - 1;\n+               Scan_Ptr    := Token_Ptr;\n \n-                        --  Decrement the depth of the #if stack\n+               Value_Chars_Loop :\n+               loop\n+                  Ch := Sinput.Source (Scan_Ptr);\n \n-                        if Pp_States.Last > 0 then\n-                           Pp_States.Decrement_Last;\n-                        end if;\n+                  case Ch is\n+                     when '_' | '.' | '0' .. '9' | 'a' .. 'z' | 'A' .. 'Z' =>\n+                        Value_End := Scan_Ptr;\n+                        Scan_Ptr := Scan_Ptr + 1;\n \n-                     --  Illegal preprocessor line\n+                     when ' ' | HT | VT | CR | LF | FF =>\n+                        exit Value_Chars_Loop;\n \n                      when others =>\n-                        if Pp_States.Last = 0 then\n-                           Error_Msg (\"IF expected\", Token_Ptr);\n-\n-                        elsif\n-                          Pp_States.Table (Pp_States.Last).Else_Ptr = 0\n-                        then\n-                           Error_Msg (\"IF, ELSIF, ELSE, or `END IF` expected\",\n-                                      Token_Ptr);\n-\n-                        else\n-                           Error_Msg (\"IF or `END IF` expected\", Token_Ptr);\n-                        end if;\n-\n-                        --  Skip to the end of this illegal line\n-\n-                        Go_To_End_Of_Line;\n+                        Error_Msg (\"illegal character\", Scan_Ptr);\n+                        goto Cleanup;\n                   end case;\n+               end loop Value_Chars_Loop;\n \n-            --  Not a preprocessor line\n-\n-            else\n-               --  Do not report errors for those lines, even if there are\n-               --  Ada parsing errors.\n-\n-               Set_Ignore_Errors (To => True);\n-\n-               if Deleting then\n-                  Go_To_End_Of_Line;\n-\n-               else\n-                  while Token /= Tok_End_Of_Line\n-                    and then Token /= Tok_EOF\n-                  loop\n-                     if Token = Tok_Special\n-                       and then Special_Character = '$'\n-                     then\n-                        declare\n-                           Dollar_Ptr : constant Source_Ptr := Token_Ptr;\n-                           Symbol     : Symbol_Id;\n-\n-                        begin\n-                           Scan.all;\n-                           Change_Reserved_Keyword_To_Symbol;\n-\n-                           if Token = Tok_Identifier\n-                             and then Token_Ptr = Dollar_Ptr + 1\n-                           then\n-                              --  $symbol\n-\n-                              Symbol := Index_Of (Token_Name);\n-\n-                              --  If symbol exists, replace by its value\n+               Scan.all;\n \n-                              if Symbol /= No_Symbol then\n-                                 Output (Start_Of_Processing, Dollar_Ptr - 1);\n-                                 Start_Of_Processing := Scan_Ptr;\n-                                 String_To_Name_Buffer\n-                                   (Mapping.Table (Symbol).Value);\n+               if Token /= Tok_End_Of_Line and then Token /= Tok_EOF then\n+                  Error_Msg (\"extraneous text in definition\", Token_Ptr);\n+                  goto Cleanup;\n+               end if;\n \n-                                 if Mapping.Table (Symbol).Is_A_String then\n+               Start_String;\n \n-                                    --  Value is an Ada string\n+               while Value_Start <= Value_End loop\n+                  Store_String_Char (Sinput.Source (Value_Start));\n+                  Value_Start := Value_Start + 1;\n+               end loop;\n \n-                                    Put_Char ('\"');\n+               Data := (Symbol              => Symbol_Name,\n+                        Original            => Original_Name,\n+                        On_The_Command_Line => False,\n+                        Is_A_String         => False,\n+                        Value               => End_String);\n+            end if;\n \n-                                    for J in 1 .. Name_Len loop\n-                                       Put_Char (Name_Buffer (J));\n+            --  Now that we have the value, get the symbol index\n \n-                                       if Name_Buffer (J) = '\"' then\n-                                          Put_Char ('\"');\n-                                       end if;\n-                                    end loop;\n+            Symbol := Index_Of (Symbol_Name);\n \n-                                    Put_Char ('\"');\n+            if Symbol /= No_Symbol then\n+               --  If we already have an entry for this symbol, replace it\n+               --  with the new value, except if the symbol was declared\n+               --  on the command line.\n \n-                                 else\n-                                    --  Value is a sequence of characters, not\n-                                    --  an Ada string.\n+               if Mapping.Table (Symbol).On_The_Command_Line then\n+                  goto Continue;\n+               end if;\n \n-                                    for J in 1 .. Name_Len loop\n-                                       Put_Char (Name_Buffer (J));\n-                                    end loop;\n-                                 end if;\n-                              end if;\n-                           end if;\n-                        end;\n-                     end if;\n+            else\n+               --  As it is the first time we see this symbol, create a new\n+               --  entry in the table.\n \n-                     Scan.all;\n-                  end loop;\n+               if Mapping.Table = null then\n+                  Symbol_Table.Init (Mapping);\n                end if;\n \n-               Set_Ignore_Errors (To => False);\n+               Symbol_Table.Increment_Last (Mapping);\n+               Symbol := Symbol_Table.Last (Mapping);\n             end if;\n-         end if;\n \n-         pragma Assert (Token = Tok_End_Of_Line or Token = Tok_EOF);\n+            Mapping.Table (Symbol) := Data;\n+            goto Continue;\n \n-         --  At this point, the token is either end of line or EOF.\n-         --  The line to possibly output stops just before the token.\n+            <<Cleanup>>\n+               Set_Ignore_Errors (To => True);\n \n-         Output_Line (Start_Of_Processing, Token_Ptr - 1);\n+               while Token /= Tok_End_Of_Line and Token /= Tok_EOF loop\n+                  Scan.all;\n+               end loop;\n \n-         --  If we are at the end of a line, the scan pointer is at the first\n-         --  non blank character, not necessarily the first character of the\n-         --  line; so, we have to deduct Start_Of_Processing from the token\n-         --  pointer.\n+               Set_Ignore_Errors (To => False);\n \n-         if Token = Tok_End_Of_Line then\n-            if (Sinput.Source (Token_Ptr) = ASCII.CR\n-                  and then Sinput.Source (Token_Ptr + 1) = ASCII.LF)\n-              or else\n-               (Sinput.Source (Token_Ptr) = ASCII.CR\n-                  and then Sinput.Source (Token_Ptr + 1) = ASCII.LF)\n-            then\n-               Start_Of_Processing := Token_Ptr + 2;\n-            else\n-               Start_Of_Processing := Token_Ptr + 1;\n-            end if;\n+            <<Continue>>\n+               null;\n          end if;\n+      end loop Def_Line_Loop;\n+   end Parse_Def_File;\n \n-         --  Now, scan the first token of the next line. If the token is EOF,\n-         --  the scan ponter will not move, and the token will still be EOF.\n+   ----------------\n+   -- Preprocess --\n+   ----------------\n \n-         Set_Ignore_Errors (To => True);\n-         Scan.all;\n-         Set_Ignore_Errors (To => False);\n-      end loop Input_Line_Loop;\n+   procedure Preprocess is\n+      Start_Of_Processing : Source_Ptr;\n+      Cond                : Boolean;\n+      Preprocessor_Line   : Boolean := False;\n \n-      --  Report an error for any missing some \"#end if;\"\n+      procedure Output (From, To : Source_Ptr);\n+      --  Output the characters with indices From .. To in the buffer\n+      --  to the output file.\n \n-      for Level in reverse 1 .. Pp_States.Last loop\n-         Error_Msg (\"no `END IF` for this IF\", Pp_States.Table (Level).If_Ptr);\n-      end loop;\n-   end Preprocess;\n+      procedure Output_Line (From, To : Source_Ptr);\n+      --  Output a line or the end of a line from the buffer to the output\n+      --  file, followed by an end of line terminator. Depending on the value\n+      --  of Deleting and the switches, the line may be commented out, blank or\n+      --  not output at all.\n \n-   ----------------\n-   -- Initialize --\n-   ----------------\n+      ------------\n+      -- Output --\n+      ------------\n \n-   procedure Initialize\n-     (Error_Msg         : Error_Msg_Proc;\n-      Scan              : Scan_Proc;\n-      Set_Ignore_Errors : Set_Ignore_Errors_Proc;\n-      Put_Char          : Put_Char_Proc;\n-      New_EOL           : New_EOL_Proc)\n-   is\n-   begin\n-      if not Already_Initialized then\n-         Start_String;\n-         Store_String_Chars (\"True\");\n-         True_Value.Value := End_String;\n+      procedure Output (From, To : Source_Ptr) is\n+      begin\n+         for J in From .. To loop\n+            Put_Char (Sinput.Source (J));\n+         end loop;\n+      end Output;\n \n-         Start_String;\n-         Empty_String := End_String;\n+      -----------------\n+      -- Output_Line --\n+      -----------------\n \n-         Name_Len := 7;\n-         Name_Buffer (1 .. Name_Len) := \"defined\";\n-         Name_Defined := Name_Find;\n+      procedure Output_Line (From, To : Source_Ptr) is\n+      begin\n+         if Deleting or Preprocessor_Line then\n+            if Blank_Deleted_Lines then\n+               New_EOL.all;\n \n-         Start_String;\n-         Store_String_Chars (\"False\");\n-         String_False := End_String;\n+            elsif Comment_Deleted_Lines then\n+               Put_Char ('-');\n+               Put_Char ('-');\n+               Put_Char ('!');\n+\n+               if From < To then\n+                  Put_Char (' ');\n+                  Output (From, To);\n+               end if;\n \n-         Already_Initialized := True;\n-      end if;\n+               New_EOL.all;\n+            end if;\n \n-      Prep.Error_Msg         := Error_Msg;\n-      Prep.Scan              := Scan;\n-      Prep.Set_Ignore_Errors := Set_Ignore_Errors;\n-      Prep.Put_Char          := Put_Char;\n-      Prep.New_EOL           := New_EOL;\n-   end Initialize;\n+         else\n+            Output (From, To);\n+            New_EOL.all;\n+         end if;\n+      end Output_Line;\n \n-   ------------------\n-   -- List_Symbols --\n-   ------------------\n+   --  Start of processing for Preprocess\n \n-   procedure List_Symbols (Foreword : String) is\n-      Order : array (0 ..  Integer (Symbol_Table.Last (Mapping)))\n-                 of Symbol_Id;\n-      --  After alphabetical sorting, this array stores thehe indices of\n-      --  the symbols in the order they are displayed.\n+   begin\n+      Start_Of_Processing := Scan_Ptr;\n \n-      function Lt (Op1, Op2 : Natural) return Boolean;\n-      --  Comparison routine for sort call\n+      --  We need to call Scan for the first time, because Initialize_Scanner\n+      --  is no longer doing it.\n \n-      procedure Move (From : Natural; To : Natural);\n-      --  Move routine for sort call\n+      Scan.all;\n \n-      --------\n-      -- Lt --\n-      --------\n+      Input_Line_Loop : loop\n+         exit Input_Line_Loop when Token = Tok_EOF;\n \n-      function Lt (Op1, Op2 : Natural) return Boolean is\n-         S1 : constant String :=\n-                Get_Name_String (Mapping.Table (Order (Op1)).Symbol);\n-         S2 : constant String :=\n-                Get_Name_String (Mapping.Table (Order (Op2)).Symbol);\n+         Preprocessor_Line := False;\n \n-      begin\n-         return S1 < S2;\n-      end Lt;\n+         if Token /= Tok_End_Of_Line then\n \n-      ----------\n-      -- Move --\n-      ----------\n+            --  Preprocessor line\n \n-      procedure Move (From : Natural; To : Natural) is\n-      begin\n-         Order (To) := Order (From);\n-      end Move;\n+            if Token = Tok_Special and then Special_Character = '#' then\n+                  Preprocessor_Line := True;\n+                  Scan.all;\n \n-      package Sort_Syms is new GNAT.Heap_Sort_G (Move, Lt);\n+                  case Token is\n \n-      Max_L : Natural;\n-      --  Maximum length of any symbol\n+                     --  #if\n \n-   --  Start of processing for List_Symbols_Case\n+                     when Tok_If =>\n+                        declare\n+                           If_Ptr : constant Source_Ptr := Token_Ptr;\n \n-   begin\n-      if Symbol_Table.Last (Mapping) = 0 then\n-         return;\n-      end if;\n+                        begin\n+                           Scan.all;\n+                           Cond := Expression (not Deleting);\n \n-      if Foreword'Length > 0 then\n-         Write_Eol;\n-         Write_Line (Foreword);\n+                           --  Check for an eventual \"then\"\n \n-         for J in Foreword'Range loop\n-            Write_Char ('=');\n-         end loop;\n-      end if;\n+                           if Token = Tok_Then then\n+                              Scan.all;\n+                           end if;\n \n-      --  Initialize the order\n+                           --  It is an error to have trailing characters after\n+                           --  the condition or \"then\".\n \n-      for J in Order'Range loop\n-         Order (J) := Symbol_Id (J);\n-      end loop;\n+                           if Token /= Tok_End_Of_Line\n+                             and then Token /= Tok_EOF\n+                           then\n+                              Error_Msg\n+                                (\"extraneous text on preprocessor line\",\n+                                 Token_Ptr);\n+                              Go_To_End_Of_Line;\n+                           end if;\n \n-      --  Sort alphabetically\n+                           declare\n+                              --  Set the initial state of this new \"#if\".\n+                              --  This must be done before incrementing the\n+                              --  Last of the table, otherwise function\n+                              --  Deleting does not report the correct value.\n \n-      Sort_Syms.Sort (Order'Last);\n+                              New_State : constant Pp_State :=\n+                                (If_Ptr     => If_Ptr,\n+                                 Else_Ptr   => 0,\n+                                 Deleting   => Deleting or (not Cond),\n+                                 Match_Seen => Deleting or Cond);\n \n-      Max_L := 7;\n+                           begin\n+                              Pp_States.Increment_Last;\n+                              Pp_States.Table (Pp_States.Last) := New_State;\n+                           end;\n+                        end;\n \n-      for J in 1 .. Symbol_Table.Last (Mapping) loop\n-         Get_Name_String (Mapping.Table (J).Original);\n-         Max_L := Integer'Max (Max_L, Name_Len);\n-      end loop;\n+                     --  #elsif\n \n-      Write_Eol;\n-      Write_Str (\"Symbol\");\n+                     when Tok_Elsif =>\n+                        Cond := False;\n \n-      for J in 1 .. Max_L - 5 loop\n-         Write_Char (' ');\n-      end loop;\n+                        if Pp_States.Last = 0\n+                          or else Pp_States.Table (Pp_States.Last).Else_Ptr\n+                                                                        /= 0\n+                        then\n+                           Error_Msg (\"no IF for this ELSIF\", Token_Ptr);\n \n-      Write_Line (\"Value\");\n+                        else\n+                           Cond :=\n+                             not Pp_States.Table (Pp_States.Last).Match_Seen;\n+                        end if;\n \n-      Write_Str (\"------\");\n+                        Scan.all;\n+                        Cond := Expression (Cond);\n \n-      for J in 1 .. Max_L - 5 loop\n-         Write_Char (' ');\n-      end loop;\n+                        --  Check for an eventual \"then\"\n \n-      Write_Line (\"------\");\n+                        if Token = Tok_Then then\n+                           Scan.all;\n+                        end if;\n \n-      for J in 1 .. Order'Last loop\n-         declare\n-            Data : constant Symbol_Data := Mapping.Table (Order (J));\n+                        --  It is an error to have trailing characters after\n+                        --  the condition or \"then\".\n \n-         begin\n-            Get_Name_String (Data.Original);\n-            Write_Str (Name_Buffer (1 .. Name_Len));\n+                        if Token /= Tok_End_Of_Line\n+                          and then Token /= Tok_EOF\n+                        then\n+                           Error_Msg\n+                             (\"extraneous text on preprocessor line\",\n+                              Token_Ptr);\n \n-            for K in Name_Len .. Max_L loop\n-               Write_Char (' ');\n-            end loop;\n+                           Go_To_End_Of_Line;\n+                        end if;\n \n-            String_To_Name_Buffer (Data.Value);\n+                        --  Depending on the value of the condition, set the\n+                        --  new values of Deleting and Match_Seen.\n+                        if Pp_States.Last > 0 then\n+                           if Pp_States.Table (Pp_States.Last).Match_Seen then\n+                              Pp_States.Table (Pp_States.Last).Deleting :=\n+                                True;\n+                           else\n+                              if Cond then\n+                                 Pp_States.Table (Pp_States.Last).Match_Seen :=\n+                                   True;\n+                                 Pp_States.Table (Pp_States.Last).Deleting :=\n+                                   False;\n+                              end if;\n+                           end if;\n+                        end if;\n \n-            if Data.Is_A_String then\n-               Write_Char ('\"');\n+                     --  #else\n \n-               for J in 1 .. Name_Len loop\n-                  Write_Char (Name_Buffer (J));\n+                     when Tok_Else =>\n+                        if Pp_States.Last = 0 then\n+                           Error_Msg (\"no IF for this ELSE\", Token_Ptr);\n \n-                  if Name_Buffer (J) = '\"' then\n-                     Write_Char ('\"');\n-                  end if;\n-               end loop;\n+                        elsif\n+                           Pp_States.Table (Pp_States.Last).Else_Ptr /= 0\n+                        then\n+                           Error_Msg (\"duplicate ELSE line\", Token_Ptr);\n+                        end if;\n \n-               Write_Char ('\"');\n+                        --  Set the possibly new values of Deleting and\n+                        --  Match_Seen.\n \n-            else\n-               Write_Str (Name_Buffer (1 .. Name_Len));\n-            end if;\n-         end;\n+                        if Pp_States.Last > 0 then\n+                           if Pp_States.Table (Pp_States.Last).Match_Seen then\n+                              Pp_States.Table (Pp_States.Last).Deleting :=\n+                                True;\n \n-         Write_Eol;\n-      end loop;\n+                           else\n+                              Pp_States.Table (Pp_States.Last).Match_Seen :=\n+                                True;\n+                              Pp_States.Table (Pp_States.Last).Deleting :=\n+                                False;\n+                           end if;\n \n-      Write_Eol;\n-   end List_Symbols;\n+                           --  Set the Else_Ptr to check for illegal #elsif\n+                           --  later.\n \n-   ----------------------\n-   -- Matching_Strings --\n-   ----------------------\n+                           Pp_States.Table (Pp_States.Last).Else_Ptr :=\n+                             Token_Ptr;\n+                        end if;\n \n-   function Matching_Strings (S1, S2 : String_Id) return Boolean is\n-   begin\n-      String_To_Name_Buffer (S1);\n+                        Scan.all;\n \n-      for Index in 1 .. Name_Len loop\n-         Name_Buffer (Index) := Fold_Lower (Name_Buffer (Index));\n-      end loop;\n+                        --  It is an error to have characters after \"#else\"\n+                        if Token /= Tok_End_Of_Line\n+                          and then Token /= Tok_EOF\n+                        then\n+                           Error_Msg\n+                             (\"extraneous text on preprocessor line\",\n+                              Token_Ptr);\n+                           Go_To_End_Of_Line;\n+                        end if;\n \n-      declare\n-         String1 : constant String := Name_Buffer (1 .. Name_Len);\n+                     --  #end if;\n+\n+                     when Tok_End =>\n+                        if Pp_States.Last = 0 then\n+                           Error_Msg (\"no IF for this END\", Token_Ptr);\n+                        end if;\n \n-      begin\n-         String_To_Name_Buffer (S2);\n+                        Scan.all;\n \n-         for Index in 1 .. Name_Len loop\n-            Name_Buffer (Index) := Fold_Lower (Name_Buffer (Index));\n-         end loop;\n+                        if Token /= Tok_If then\n+                           Error_Msg (\"IF expected\", Token_Ptr);\n \n-         return String1 = Name_Buffer (1 .. Name_Len);\n-      end;\n-   end Matching_Strings;\n+                        else\n+                           Scan.all;\n \n-   --------------------\n-   -- Parse_Def_File --\n-   --------------------\n+                           if Token /= Tok_Semicolon then\n+                              Error_Msg (\"`;` Expected\", Token_Ptr);\n \n-   procedure Parse_Def_File is\n-      Symbol        : Symbol_Id;\n-      Symbol_Name   : Name_Id;\n-      Original_Name : Name_Id;\n-      Data          : Symbol_Data;\n-      Value_Start   : Source_Ptr;\n-      Value_End     : Source_Ptr;\n-      Ch            : Character;\n+                           else\n+                              Scan.all;\n \n-      use ASCII;\n+                              --  It is an error to have character after\n+                              --  \"#end if;\".\n+                              if Token /= Tok_End_Of_Line\n+                                and then Token /= Tok_EOF\n+                              then\n+                                 Error_Msg\n+                                   (\"extraneous text on preprocessor line\",\n+                                    Token_Ptr);\n+                              end if;\n+                           end if;\n+                        end if;\n \n-   begin\n-      Def_Line_Loop :\n-      loop\n-         Scan.all;\n+                        --  In case of one of the errors above, skip the tokens\n+                        --  until the end of line is reached.\n \n-         exit Def_Line_Loop when Token = Tok_EOF;\n+                        Go_To_End_Of_Line;\n \n-         if Token /= Tok_End_Of_Line then\n-            Change_Reserved_Keyword_To_Symbol;\n+                        --  Decrement the depth of the #if stack\n \n-            if Token /= Tok_Identifier then\n-               Error_Msg (\"identifier expected\", Token_Ptr);\n-               goto Cleanup;\n-            end if;\n+                        if Pp_States.Last > 0 then\n+                           Pp_States.Decrement_Last;\n+                        end if;\n \n-            Symbol_Name := Token_Name;\n-            Name_Len := 0;\n+                     --  Illegal preprocessor line\n \n-            for Ptr in Token_Ptr .. Scan_Ptr - 1 loop\n-               Name_Len := Name_Len + 1;\n-               Name_Buffer (Name_Len) := Sinput.Source (Ptr);\n-            end loop;\n+                     when others =>\n+                        if Pp_States.Last = 0 then\n+                           Error_Msg (\"IF expected\", Token_Ptr);\n \n-            Original_Name := Name_Find;\n-            Scan.all;\n+                        elsif\n+                          Pp_States.Table (Pp_States.Last).Else_Ptr = 0\n+                        then\n+                           Error_Msg (\"IF, ELSIF, ELSE, or `END IF` expected\",\n+                                      Token_Ptr);\n \n-            if Token /= Tok_Colon_Equal then\n-               Error_Msg (\"`:=` expected\", Token_Ptr);\n-               goto Cleanup;\n-            end if;\n+                        else\n+                           Error_Msg (\"IF or `END IF` expected\", Token_Ptr);\n+                        end if;\n \n-            Scan.all;\n+                        --  Skip to the end of this illegal line\n \n-            if Token = Tok_String_Literal then\n-               Data := (Symbol              => Symbol_Name,\n-                        Original            => Original_Name,\n-                        On_The_Command_Line => False,\n-                        Is_A_String         => True,\n-                        Value               => String_Literal_Id);\n+                        Go_To_End_Of_Line;\n+                  end case;\n \n-               Scan.all;\n+            --  Not a preprocessor line\n \n-               if Token /= Tok_End_Of_Line and then Token /= Tok_EOF then\n-                  Error_Msg (\"extraneous text in definition\", Token_Ptr);\n-                  goto Cleanup;\n-               end if;\n+            else\n+               --  Do not report errors for those lines, even if there are\n+               --  Ada parsing errors.\n \n-            elsif Token = Tok_End_Of_Line or Token = Tok_EOF then\n-               Data := (Symbol              => Symbol_Name,\n-                        Original            => Original_Name,\n-                        On_The_Command_Line => False,\n-                        Is_A_String         => False,\n-                        Value               => Empty_String);\n+               Set_Ignore_Errors (To => True);\n \n-            else\n-               Value_Start := Token_Ptr;\n-               Value_End   := Token_Ptr - 1;\n-               Scan_Ptr    := Token_Ptr;\n+               if Deleting then\n+                  Go_To_End_Of_Line;\n \n-               Value_Chars_Loop :\n-               loop\n-                  Ch := Sinput.Source (Scan_Ptr);\n+               else\n+                  while Token /= Tok_End_Of_Line\n+                    and then Token /= Tok_EOF\n+                  loop\n+                     if Token = Tok_Special\n+                       and then Special_Character = '$'\n+                     then\n+                        declare\n+                           Dollar_Ptr : constant Source_Ptr := Token_Ptr;\n+                           Symbol     : Symbol_Id;\n \n-                  case Ch is\n-                     when '_' | '.' | '0' .. '9' | 'a' .. 'z' | 'A' .. 'Z' =>\n-                        Value_End := Scan_Ptr;\n-                        Scan_Ptr := Scan_Ptr + 1;\n+                        begin\n+                           Scan.all;\n+                           Change_Reserved_Keyword_To_Symbol;\n \n-                     when ' ' | HT | VT | CR | LF | FF =>\n-                        exit Value_Chars_Loop;\n+                           if Token = Tok_Identifier\n+                             and then Token_Ptr = Dollar_Ptr + 1\n+                           then\n+                              --  $symbol\n \n-                     when others =>\n-                        Error_Msg (\"illegal character\", Scan_Ptr);\n-                        goto Cleanup;\n-                  end case;\n-               end loop Value_Chars_Loop;\n+                              Symbol := Index_Of (Token_Name);\n \n-               Scan.all;\n+                              --  If symbol exists, replace by its value\n \n-               if Token /= Tok_End_Of_Line and then Token /= Tok_EOF then\n-                  Error_Msg (\"extraneous text in definition\", Token_Ptr);\n-                  goto Cleanup;\n-               end if;\n+                              if Symbol /= No_Symbol then\n+                                 Output (Start_Of_Processing, Dollar_Ptr - 1);\n+                                 Start_Of_Processing := Scan_Ptr;\n+                                 String_To_Name_Buffer\n+                                   (Mapping.Table (Symbol).Value);\n \n-               Start_String;\n+                                 if Mapping.Table (Symbol).Is_A_String then\n \n-               while Value_Start <= Value_End loop\n-                  Store_String_Char (Sinput.Source (Value_Start));\n-                  Value_Start := Value_Start + 1;\n-               end loop;\n+                                    --  Value is an Ada string\n \n-               Data := (Symbol              => Symbol_Name,\n-                        Original            => Original_Name,\n-                        On_The_Command_Line => False,\n-                        Is_A_String         => False,\n-                        Value               => End_String);\n-            end if;\n+                                    Put_Char ('\"');\n \n-            --  Now that we have the value, get the symbol index\n+                                    for J in 1 .. Name_Len loop\n+                                       Put_Char (Name_Buffer (J));\n \n-            Symbol := Index_Of (Symbol_Name);\n+                                       if Name_Buffer (J) = '\"' then\n+                                          Put_Char ('\"');\n+                                       end if;\n+                                    end loop;\n \n-            if Symbol /= No_Symbol then\n-               --  If we already have an entry for this symbol, replace it\n-               --  with the new value, except if the symbol was declared\n-               --  on the command line.\n+                                    Put_Char ('\"');\n \n-               if Mapping.Table (Symbol).On_The_Command_Line then\n-                  goto Continue;\n-               end if;\n+                                 else\n+                                    --  Value is a sequence of characters, not\n+                                    --  an Ada string.\n \n-            else\n-               --  As it is the first time we see this symbol, create a new\n-               --  entry in the table.\n+                                    for J in 1 .. Name_Len loop\n+                                       Put_Char (Name_Buffer (J));\n+                                    end loop;\n+                                 end if;\n+                              end if;\n+                           end if;\n+                        end;\n+                     end if;\n \n-               if Mapping.Table = null then\n-                  Symbol_Table.Init (Mapping);\n+                     Scan.all;\n+                  end loop;\n                end if;\n \n-               Symbol_Table.Increment_Last (Mapping);\n-               Symbol := Symbol_Table.Last (Mapping);\n+               Set_Ignore_Errors (To => False);\n             end if;\n+         end if;\n \n-            Mapping.Table (Symbol) := Data;\n-            goto Continue;\n+         pragma Assert (Token = Tok_End_Of_Line or Token = Tok_EOF);\n \n-            <<Cleanup>>\n-               Set_Ignore_Errors (To => True);\n+         --  At this point, the token is either end of line or EOF.\n+         --  The line to possibly output stops just before the token.\n \n-               while Token /= Tok_End_Of_Line and Token /= Tok_EOF loop\n-                  Scan.all;\n-               end loop;\n+         Output_Line (Start_Of_Processing, Token_Ptr - 1);\n \n-               Set_Ignore_Errors (To => False);\n+         --  If we are at the end of a line, the scan pointer is at the first\n+         --  non blank character, not necessarily the first character of the\n+         --  line; so, we have to deduct Start_Of_Processing from the token\n+         --  pointer.\n \n-            <<Continue>>\n-               null;\n+         if Token = Tok_End_Of_Line then\n+            if (Sinput.Source (Token_Ptr) = ASCII.CR\n+                  and then Sinput.Source (Token_Ptr + 1) = ASCII.LF)\n+              or else\n+               (Sinput.Source (Token_Ptr) = ASCII.CR\n+                  and then Sinput.Source (Token_Ptr + 1) = ASCII.LF)\n+            then\n+               Start_Of_Processing := Token_Ptr + 2;\n+            else\n+               Start_Of_Processing := Token_Ptr + 1;\n+            end if;\n          end if;\n-      end loop Def_Line_Loop;\n-   end Parse_Def_File;\n+\n+         --  Now, scan the first token of the next line. If the token is EOF,\n+         --  the scan ponter will not move, and the token will still be EOF.\n+\n+         Set_Ignore_Errors (To => True);\n+         Scan.all;\n+         Set_Ignore_Errors (To => False);\n+      end loop Input_Line_Loop;\n+\n+      --  Report an error for any missing some \"#end if;\"\n+\n+      for Level in reverse 1 .. Pp_States.Last loop\n+         Error_Msg (\"no `END IF` for this IF\", Pp_States.Table (Level).If_Ptr);\n+      end loop;\n+   end Preprocess;\n \n end Prep;"}, {"sha": "ab45ef2804bb1f0b07da74db87821875b4b9b9df", "filename": "gcc/ada/prep.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce685621b46adb534ec20fcf9a76606596288be/gcc%2Fada%2Fprep.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce685621b46adb534ec20fcf9a76606596288be/gcc%2Fada%2Fprep.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprep.ads?ref=cce685621b46adb534ec20fcf9a76606596288be", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2002, Free Software Foundation, Inc.              --\n+--          Copyright (C) 2002-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -71,7 +71,7 @@ package Prep is\n       Table_Index_Type     => Symbol_Id,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 10,\n-      Table_Increment      => 10);\n+      Table_Increment      => 100);\n    --  The table of all symbols\n \n    Mapping : Symbol_Table.Instance;"}, {"sha": "763654ca3eb4191b62811a4fff2479b5c856934c", "filename": "gcc/ada/prepcomp.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce685621b46adb534ec20fcf9a76606596288be/gcc%2Fada%2Fprepcomp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce685621b46adb534ec20fcf9a76606596288be/gcc%2Fada%2Fprepcomp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprepcomp.adb?ref=cce685621b46adb534ec20fcf9a76606596288be", "patch": "@@ -105,7 +105,7 @@ package body Prepcomp is\n       Table_Index_Type     => Int,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 5,\n-      Table_Increment      => 5,\n+      Table_Increment      => 100,\n       Table_Name           => \"Prepcomp.Preproc_Data_Table\");\n    --  Table to store the specific preprocessing data\n \n@@ -117,8 +117,8 @@ package body Prepcomp is\n      (Table_Component_Type => Source_File_Index,\n       Table_Index_Type     => Int,\n       Table_Low_Bound      => 1,\n-      Table_Initial        => 5,\n-      Table_Increment      => 5,\n+      Table_Initial        => 10,\n+      Table_Increment      => 100,\n       Table_Name           => \"Prepcomp.Dependencies\");\n    --  Table to store the dependencies on preprocessing files\n "}, {"sha": "0fdc21cc1d5cfd83284fa84f698da3c416dbb855", "filename": "gcc/ada/prj-strt.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce685621b46adb534ec20fcf9a76606596288be/gcc%2Fada%2Fprj-strt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce685621b46adb534ec20fcf9a76606596288be/gcc%2Fada%2Fprj-strt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-strt.adb?ref=cce685621b46adb534ec20fcf9a76606596288be", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -45,7 +45,7 @@ package body Prj.Strt is\n    --  been used (to avoid duplicate case labels).\n \n    Choices_Initial   : constant := 10;\n-   Choices_Increment : constant := 50;\n+   Choices_Increment : constant := 100;\n \n    Choice_Node_Low_Bound  : constant := 0;\n    Choice_Node_High_Bound : constant := 099_999_999;"}, {"sha": "416635f537a28269d3411cb4d65920818a7b3aac", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce685621b46adb534ec20fcf9a76606596288be/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce685621b46adb534ec20fcf9a76606596288be/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=cce685621b46adb534ec20fcf9a76606596288be", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2001-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -316,7 +316,7 @@ package Prj is\n    type String_Element is record\n       Value         : Name_Id        := No_Name;\n       Index         : Int            := 0;\n-      Display_Value : Name_Id   := No_Name;\n+      Display_Value : Name_Id        := No_Name;\n       Location      : Source_Ptr     := No_Location;\n       Flag          : Boolean        := False;\n       Next          : String_List_Id := Nil_String;\n@@ -840,13 +840,13 @@ package Prj is\n      (Specification, Body_Part);\n \n    type File_Name_Data is record\n-      Name         : Name_Id := No_Name;\n-      Index        : Int     := 0;\n-      Display_Name : Name_Id := No_Name;\n-      Path         : Name_Id := No_Name;\n-      Display_Path : Name_Id := No_Name;\n+      Name         : Name_Id    := No_Name;\n+      Index        : Int        := 0;\n+      Display_Name : Name_Id    := No_Name;\n+      Path         : Name_Id    := No_Name;\n+      Display_Path : Name_Id    := No_Name;\n       Project      : Project_Id := No_Project;\n-      Needs_Pragma : Boolean := False;\n+      Needs_Pragma : Boolean    := False;\n    end record;\n    --  File and Path name of a spec or body\n \n@@ -1057,7 +1057,7 @@ private\n       Table_Index_Type     => Natural,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 50,\n-      Table_Increment      => 50);\n+      Table_Increment      => 100);\n    --  Table storing all the temp path file names.\n    --  Used by Delete_All_Path_Files.\n \n@@ -1066,15 +1066,15 @@ private\n       Table_Index_Type     => Natural,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 50,\n-      Table_Increment      => 50);\n+      Table_Increment      => 100);\n    --  A table to store the source dirs before creating the source path file\n \n    package Object_Path_Table is new GNAT.Dynamic_Tables\n      (Table_Component_Type => Name_Id,\n       Table_Index_Type     => Natural,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 50,\n-      Table_Increment      => 50);\n+      Table_Increment      => 100);\n    --  A table to store the object dirs, before creating the object path file\n \n    type Private_Project_Tree_Data is record"}, {"sha": "d6f51859651ce4790b346c16d5ae4bb9b5ab29a9", "filename": "gcc/ada/sem_maps.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce685621b46adb534ec20fcf9a76606596288be/gcc%2Fada%2Fsem_maps.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce685621b46adb534ec20fcf9a76606596288be/gcc%2Fada%2Fsem_maps.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_maps.ads?ref=cce685621b46adb534ec20fcf9a76606596288be", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1996-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1996-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -140,7 +140,7 @@ private\n       Table_Index_Type     => Map,\n       Table_Low_Bound      => 0,\n       Table_Initial        => 100,\n-      Table_Increment      => 10,\n+      Table_Increment      => 100,\n       Table_Name           => \"Maps_Table\");\n \n    --  All headers for hash tables are allocated in one global table. Each\n@@ -151,7 +151,7 @@ private\n       Table_Index_Type     => Header_Index,\n       Table_Low_Bound      => 0,\n       Table_Initial        => 1000,\n-      Table_Increment      => 10,\n+      Table_Increment      => 100,\n       Table_Name           => \"Headers_Table\");\n \n    --  All associations are allocated in one global table. Each map stores\n@@ -162,7 +162,7 @@ private\n       Table_Index_Type     => Assoc_Index,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 1000,\n-      Table_Increment      => 10,\n+      Table_Increment      => 100,\n       Table_Name           => \"Associations_Table\");\n \n end Sem_Maps;"}, {"sha": "7897378a1d028654f80ae9f4a627ecaa605a083a", "filename": "gcc/ada/table.adb", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce685621b46adb534ec20fcf9a76606596288be/gcc%2Fada%2Ftable.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce685621b46adb534ec20fcf9a76606596288be/gcc%2Fada%2Ftable.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftable.adb?ref=cce685621b46adb534ec20fcf9a76606596288be", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -163,7 +163,7 @@ package body Table is\n       ----------------\n \n       procedure Reallocate is\n-         New_Size : Memory.size_t;\n+         New_Size   : Memory.size_t;\n \n       begin\n          if Max < Last_Val then\n@@ -174,10 +174,15 @@ package body Table is\n \n             Length := Int'Max (Length, Table_Initial);\n \n-            --  Now increment table length until it is sufficiently large\n+            --  Now increment table length until it is sufficiently large. Use\n+            --  the increment value or 10, which ever is larger (the reason\n+            --  for the use of 10 here is to ensure that the table does really\n+            --  increase in size (which would not be the case for a table of\n+            --  length 10 increased by 3% for instance).\n \n             while Max < Last_Val loop\n-               Length := Length * (100 + Table_Increment) / 100;\n+               Length := Int'Max (Length * (100 + Table_Increment) / 100,\n+                                  Length + 10);\n                Max := Min + Length - 1;\n             end loop;\n "}, {"sha": "c5e53d7e11384922bd9eaea00345c9417bf70670", "filename": "gcc/ada/vms_conv.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce685621b46adb534ec20fcf9a76606596288be/gcc%2Fada%2Fvms_conv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce685621b46adb534ec20fcf9a76606596288be/gcc%2Fada%2Fvms_conv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_conv.adb?ref=cce685621b46adb534ec20fcf9a76606596288be", "patch": "@@ -78,7 +78,7 @@ package body VMS_Conv is\n       Table_Index_Type     => Integer,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 4096,\n-      Table_Increment      => 2,\n+      Table_Increment      => 100,\n       Table_Name           => \"Buffer\");\n \n    function Init_Object_Dirs return Argument_List;"}]}