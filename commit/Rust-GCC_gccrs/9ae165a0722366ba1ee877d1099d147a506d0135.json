{"sha": "9ae165a0722366ba1ee877d1099d147a506d0135", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFlMTY1YTA3MjIzNjZiYTFlZTg3N2QxMDk5ZDE0N2E1MDZkMDEzNQ==", "commit": {"author": {"name": "Douglas Gregor", "email": "doug.gregor@gmail.com", "date": "2007-11-06T14:39:41Z"}, "committer": {"name": "Doug Gregor", "email": "dgregor@gcc.gnu.org", "date": "2007-11-06T14:39:41Z"}, "message": "re PR c++/33977 (internal compiler error: canonical types differ for identical types const char [5] and const sal_Char [5])\n\n2007-11-06  Douglas Gregor  <doug.gregor@gmail.com>\n\n\tPR c++/33977\n\tPR c++/33886\n\t* tree.c (c_build_qualified_type): Define bridge to\n\tcp_build_qualified_type.\n\n2007-11-06  Douglas Gregor  <doug.gregor@gmail.com>\n\n\tPR c++/33977\n\tPR c++/33886\n\t* c-common.c (c_build_qualified_type): Moved to c-typeck.c.\n\t(complete_array_type): Set canonical type appropriately.\n\t* c-typeck.c (c_build_qualified_type): Moved from c-common.c. The\n\tC and C++ front ends now have different versions of this function,\n\tbecause the C++ version needs to maintain canonical types here.\n\n2007-11-06  Douglas Gregor  <doug.gregor@gmail.com>\n\n\tPR c++/33977\n\tPR c++/33886\n\t* g++.dg/other/canon-array.C: New.\n\nFrom-SVN: r129929", "tree": {"sha": "24adf8f3c491cb12e5443e2f7b4ae5687c9ed263", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24adf8f3c491cb12e5443e2f7b4ae5687c9ed263"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ae165a0722366ba1ee877d1099d147a506d0135", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ae165a0722366ba1ee877d1099d147a506d0135", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ae165a0722366ba1ee877d1099d147a506d0135", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ae165a0722366ba1ee877d1099d147a506d0135/comments", "author": {"login": "DougGregor", "id": 989428, "node_id": "MDQ6VXNlcjk4OTQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/989428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DougGregor", "html_url": "https://github.com/DougGregor", "followers_url": "https://api.github.com/users/DougGregor/followers", "following_url": "https://api.github.com/users/DougGregor/following{/other_user}", "gists_url": "https://api.github.com/users/DougGregor/gists{/gist_id}", "starred_url": "https://api.github.com/users/DougGregor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DougGregor/subscriptions", "organizations_url": "https://api.github.com/users/DougGregor/orgs", "repos_url": "https://api.github.com/users/DougGregor/repos", "events_url": "https://api.github.com/users/DougGregor/events{/privacy}", "received_events_url": "https://api.github.com/users/DougGregor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1ad8aeeb962a281f654be3bc0a7a2dd4015d317b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ad8aeeb962a281f654be3bc0a7a2dd4015d317b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ad8aeeb962a281f654be3bc0a7a2dd4015d317b"}], "stats": {"total": 173, "additions": 109, "deletions": 64}, "files": [{"sha": "6c8c5700e29ca619e1af3a580926b732fcc2e537", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae165a0722366ba1ee877d1099d147a506d0135/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae165a0722366ba1ee877d1099d147a506d0135/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ae165a0722366ba1ee877d1099d147a506d0135", "patch": "@@ -1,3 +1,13 @@\n+2007-11-06  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+\tPR c++/33977\n+\tPR c++/33886\n+\t* c-common.c (c_build_qualified_type): Moved to c-typeck.c.\n+\t(complete_array_type): Set canonical type appropriately.\n+\t* c-typeck.c (c_build_qualified_type): Moved from c-common.c. The\n+\tC and C++ front ends now have different versions of this function,\n+\tbecause the C++ version needs to maintain canonical types here.\n+\n 2007-11-04  Razya Ladelsky  <razya@il.ibm.com>\n \t\n \t* tree-parloops.c (reduction_info): Remove reduction_init field."}, {"sha": "763745a4937d002025dd7fa1004512b008e74c12", "filename": "gcc/c-common.c", "status": "modified", "additions": 13, "deletions": 64, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae165a0722366ba1ee877d1099d147a506d0135/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae165a0722366ba1ee877d1099d147a506d0135/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=9ae165a0722366ba1ee877d1099d147a506d0135", "patch": "@@ -3086,70 +3086,6 @@ static void def_builtin_1  (enum built_in_function fncode,\n \t\t\t    bool both_p, bool fallback_p, bool nonansi_p,\n \t\t\t    tree fnattrs, bool implicit_p);\n \n-/* Make a variant type in the proper way for C/C++, propagating qualifiers\n-   down to the element type of an array.  */\n-\n-tree\n-c_build_qualified_type (tree type, int type_quals)\n-{\n-  if (type == error_mark_node)\n-    return type;\n-\n-  if (TREE_CODE (type) == ARRAY_TYPE)\n-    {\n-      tree t;\n-      tree element_type = c_build_qualified_type (TREE_TYPE (type),\n-\t\t\t\t\t\t  type_quals);\n-\n-      /* See if we already have an identically qualified type.  */\n-      for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))\n-\t{\n-\t  if (TYPE_QUALS (strip_array_types (t)) == type_quals\n-\t      && TYPE_NAME (t) == TYPE_NAME (type)\n-\t      && TYPE_CONTEXT (t) == TYPE_CONTEXT (type)\n-\t      && attribute_list_equal (TYPE_ATTRIBUTES (t),\n-\t\t\t\t       TYPE_ATTRIBUTES (type)))\n-\t    break;\n-\t}\n-      if (!t)\n-\t{\n-          tree domain = TYPE_DOMAIN (type);\n-\n-\t  t = build_variant_type_copy (type);\n-\t  TREE_TYPE (t) = element_type;\n-\n-          if (TYPE_STRUCTURAL_EQUALITY_P (element_type)\n-              || (domain && TYPE_STRUCTURAL_EQUALITY_P (domain)))\n-            SET_TYPE_STRUCTURAL_EQUALITY (t);\n-          else if (TYPE_CANONICAL (element_type) != element_type\n-                   || (domain && TYPE_CANONICAL (domain) != domain))\n-            {\n-              tree unqualified_canon \n-                = build_array_type (TYPE_CANONICAL (element_type),\n-                                    domain? TYPE_CANONICAL (domain) \n-                                          : NULL_TREE);\n-              TYPE_CANONICAL (t) \n-                = c_build_qualified_type (unqualified_canon, type_quals);\n-            }\n-          else\n-            TYPE_CANONICAL (t) = t;\n-\t}\n-      return t;\n-    }\n-\n-  /* A restrict-qualified pointer type must be a pointer to object or\n-     incomplete type.  Note that the use of POINTER_TYPE_P also allows\n-     REFERENCE_TYPEs, which is appropriate for C++.  */\n-  if ((type_quals & TYPE_QUAL_RESTRICT)\n-      && (!POINTER_TYPE_P (type)\n-\t  || !C_TYPE_OBJECT_OR_INCOMPLETE_P (TREE_TYPE (type))))\n-    {\n-      error (\"invalid use of %<restrict%>\");\n-      type_quals &= ~TYPE_QUAL_RESTRICT;\n-    }\n-\n-  return build_qualified_type (type, type_quals);\n-}\n \n /* Apply the TYPE_QUALS to the new DECL.  */\n \n@@ -7044,6 +6980,19 @@ complete_array_type (tree *ptype, tree initial_value, bool do_default)\n \t\t\t\t    hashcode);\n   main_type = type_hash_canon (hashcode, main_type);\n \n+  /* Fix the canonical type.  */\n+  if (TYPE_STRUCTURAL_EQUALITY_P (TREE_TYPE (main_type))\n+      || TYPE_STRUCTURAL_EQUALITY_P (TYPE_DOMAIN (main_type)))\n+    SET_TYPE_STRUCTURAL_EQUALITY (main_type);\n+  else if (TYPE_CANONICAL (TREE_TYPE (main_type)) != TREE_TYPE (main_type)\n+\t   || (TYPE_CANONICAL (TYPE_DOMAIN (main_type))\n+\t       != TYPE_DOMAIN (main_type)))\n+    TYPE_CANONICAL (main_type) \n+      = build_array_type (TYPE_CANONICAL (TREE_TYPE (main_type)),\n+\t\t\t  TYPE_CANONICAL (TYPE_DOMAIN (main_type)));\n+  else\n+    TYPE_CANONICAL (main_type) = main_type;\n+\n   if (quals == 0)\n     type = main_type;\n   else"}, {"sha": "eee57892b662f742dd652d06cd7082faeeba7a32", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae165a0722366ba1ee877d1099d147a506d0135/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae165a0722366ba1ee877d1099d147a506d0135/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=9ae165a0722366ba1ee877d1099d147a506d0135", "patch": "@@ -8896,3 +8896,68 @@ c_finish_omp_clauses (tree clauses)\n   bitmap_obstack_release (NULL);\n   return clauses;\n }\n+\n+/* Make a variant type in the proper way for C/C++, propagating qualifiers\n+   down to the element type of an array.  */\n+\n+tree\n+c_build_qualified_type (tree type, int type_quals)\n+{\n+  if (type == error_mark_node)\n+    return type;\n+\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      tree t;\n+      tree element_type = c_build_qualified_type (TREE_TYPE (type),\n+\t\t\t\t\t\t  type_quals);\n+\n+      /* See if we already have an identically qualified type.  */\n+      for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))\n+\t{\n+\t  if (TYPE_QUALS (strip_array_types (t)) == type_quals\n+\t      && TYPE_NAME (t) == TYPE_NAME (type)\n+\t      && TYPE_CONTEXT (t) == TYPE_CONTEXT (type)\n+\t      && attribute_list_equal (TYPE_ATTRIBUTES (t),\n+\t\t\t\t       TYPE_ATTRIBUTES (type)))\n+\t    break;\n+\t}\n+      if (!t)\n+\t{\n+          tree domain = TYPE_DOMAIN (type);\n+\n+\t  t = build_variant_type_copy (type);\n+\t  TREE_TYPE (t) = element_type;\n+\n+          if (TYPE_STRUCTURAL_EQUALITY_P (element_type)\n+              || (domain && TYPE_STRUCTURAL_EQUALITY_P (domain)))\n+            SET_TYPE_STRUCTURAL_EQUALITY (t);\n+          else if (TYPE_CANONICAL (element_type) != element_type\n+                   || (domain && TYPE_CANONICAL (domain) != domain))\n+            {\n+              tree unqualified_canon \n+                = build_array_type (TYPE_CANONICAL (element_type),\n+                                    domain? TYPE_CANONICAL (domain) \n+                                          : NULL_TREE);\n+              TYPE_CANONICAL (t) \n+                = c_build_qualified_type (unqualified_canon, type_quals);\n+            }\n+          else\n+            TYPE_CANONICAL (t) = t;\n+\t}\n+      return t;\n+    }\n+\n+  /* A restrict-qualified pointer type must be a pointer to object or\n+     incomplete type.  Note that the use of POINTER_TYPE_P also allows\n+     REFERENCE_TYPEs, which is appropriate for C++.  */\n+  if ((type_quals & TYPE_QUAL_RESTRICT)\n+      && (!POINTER_TYPE_P (type)\n+\t  || !C_TYPE_OBJECT_OR_INCOMPLETE_P (TREE_TYPE (type))))\n+    {\n+      error (\"invalid use of %<restrict%>\");\n+      type_quals &= ~TYPE_QUAL_RESTRICT;\n+    }\n+\n+  return build_qualified_type (type, type_quals);\n+}"}, {"sha": "96d2dd7ee3f8f8e0a9ca12f65589e9050ace10a7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae165a0722366ba1ee877d1099d147a506d0135/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae165a0722366ba1ee877d1099d147a506d0135/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9ae165a0722366ba1ee877d1099d147a506d0135", "patch": "@@ -1,3 +1,10 @@\n+2007-11-06  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+\tPR c++/33977\n+\tPR c++/33886\n+\t* tree.c (c_build_qualified_type): Define bridge to\n+\tcp_build_qualified_type.\n+\n 2007-11-06  Douglas Gregor  <doug.gregor@gmail.com>\n \n \tPR c++/31439"}, {"sha": "c2b4af04086b6d80d3cdf0e89710a139e36a121d", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae165a0722366ba1ee877d1099d147a506d0135/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae165a0722366ba1ee877d1099d147a506d0135/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=9ae165a0722366ba1ee877d1099d147a506d0135", "patch": "@@ -649,6 +649,14 @@ cp_build_reference_type (tree to_type, bool rval)\n \n }\n \n+/* Used by the C++ front end to build qualified array types.  However,\n+   the C version of this function does not properly maintain canonical\n+   types (which are not used in C).  */\n+tree\n+c_build_qualified_type (tree type, int type_quals)\n+{\n+  return cp_build_qualified_type (type, type_quals);\n+}\n \n \f\n /* Make a variant of TYPE, qualified with the TYPE_QUALS.  Handles"}, {"sha": "76b42c924eebf6f1f50e99a62a9add9f48c82a35", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae165a0722366ba1ee877d1099d147a506d0135/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae165a0722366ba1ee877d1099d147a506d0135/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9ae165a0722366ba1ee877d1099d147a506d0135", "patch": "@@ -1,3 +1,9 @@\n+2007-11-06  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+\tPR c++/33977\n+\tPR c++/33886\n+\t* g++.dg/other/canon-array.C: New.\n+\t\n 2007-11-06  Douglas Gregor  <doug.gregor@gmail.com>\n \n \t* testsuite/g++.dg/parser/crash36.C: Tweak expected errors."}]}