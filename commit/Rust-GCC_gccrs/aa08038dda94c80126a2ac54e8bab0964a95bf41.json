{"sha": "aa08038dda94c80126a2ac54e8bab0964a95bf41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWEwODAzOGRkYTk0YzgwMTI2YTJhYzU0ZThiYWIwOTY0YTk1YmY0MQ==", "commit": {"author": {"name": "Erik Edelmann", "email": "eedelman@gcc.gnu.org", "date": "2006-03-05T19:24:48Z"}, "committer": {"name": "Erik Edelmann", "email": "eedelman@gcc.gnu.org", "date": "2006-03-05T19:24:48Z"}, "message": "re PR fortran/16136 (Conflicting attributes ALLOCATABLE, DUMMY (F2003))\n\nfortran/\n2005-03-05  Erik Edelmann  <eedelman@gcc.gnu.org>\n\n        PR fortran/16136\n        * symbol.c (conf_std): New macro.\n        (check_conflict): Use it to allow ALLOCATABLE dummy\n        arguments for F2003.\n        * trans-expr.c (gfc_conv_function_call): Pass the\n        address of the array descriptor when dummy argument is\n        ALLOCATABLE.\n        * interface.c (compare_allocatable): New function.\n        (compare_actual_formal): Use it.\n        resolve.c (resolve_deallocate_expr,\n        resolve_allocate_expr): Check that INTENT(IN) variables\n        aren't (de)allocated.\n        * gfortran.texi (Fortran 2003 status): List ALLOCATABLE\n        dummy arguments as supported.\n\ntestsuite/\n2005-03-05  Erik Edelmann  <eedelman@gcc.gnu.org>\n\n        PR fortran/16136\n        * allocatable_dummy_1.f90: New.\n        * allocatable_dummy_2.f90: New.\n\nFrom-SVN: r111741", "tree": {"sha": "d1b0048a6e28bab0dfa55b141c9b8fb3793db643", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1b0048a6e28bab0dfa55b141c9b8fb3793db643"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa08038dda94c80126a2ac54e8bab0964a95bf41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa08038dda94c80126a2ac54e8bab0964a95bf41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa08038dda94c80126a2ac54e8bab0964a95bf41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa08038dda94c80126a2ac54e8bab0964a95bf41/comments", "author": null, "committer": null, "parents": [{"sha": "68c9b7d60a71b8ab9e0ebe692f74aedb61a95af1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68c9b7d60a71b8ab9e0ebe692f74aedb61a95af1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68c9b7d60a71b8ab9e0ebe692f74aedb61a95af1"}], "stats": {"total": 170, "additions": 161, "deletions": 9}, "files": [{"sha": "e3fb42c97b365ac446cc10fdaeee75489a8f14a2", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa08038dda94c80126a2ac54e8bab0964a95bf41/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa08038dda94c80126a2ac54e8bab0964a95bf41/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=aa08038dda94c80126a2ac54e8bab0964a95bf41", "patch": "@@ -1,3 +1,20 @@\n+2005-03-05  Erik Edelmann  <eedelman@gcc.gnu.org>\n+\n+\tPR fortran/16136\n+\t* symbol.c (conf_std): New macro.\n+\t(check_conflict): Use it to allow ALLOCATABLE dummy\n+\targuments for F2003.\n+\t* trans-expr.c (gfc_conv_function_call): Pass the\n+\taddress of the array descriptor when dummy argument is\n+\tALLOCATABLE.\n+\t* interface.c (compare_allocatable): New function.\n+\t(compare_actual_formal): Use it.\n+\t* resolve.c (resolve_deallocate_expr,\n+\tresolve_allocate_expr): Check that INTENT(IN) variables\n+\taren't (de)allocated.\n+\t* gfortran.texi (Fortran 2003 status): List ALLOCATABLE\n+\tdummy arguments as supported.\n+\n 2006-03-03  Roger Sayle  <roger@eyesopen.com>\n \n \t* dependency.c (gfc_check_element_vs_element): Revert last change."}, {"sha": "769696263910f09f862f41c024b1202ee7bfbbde", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa08038dda94c80126a2ac54e8bab0964a95bf41/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa08038dda94c80126a2ac54e8bab0964a95bf41/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=aa08038dda94c80126a2ac54e8bab0964a95bf41", "patch": "@@ -1331,6 +1331,10 @@ Support for the declaration of enumeration constants via the\n @command{gcc} is guaranteed also for the case where the\n @command{-fshort-enums} command line option is given.\n \n+@item\n+@cindex @code{ALLOCATABLE} dummy arguments\n+The @code{ALLOCATABLE} attribute for dummy arguments.\n+\n @end itemize\n \n "}, {"sha": "f4e522aadd95bed282ca2f14aa43065ca3e8e659", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa08038dda94c80126a2ac54e8bab0964a95bf41/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa08038dda94c80126a2ac54e8bab0964a95bf41/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=aa08038dda94c80126a2ac54e8bab0964a95bf41", "patch": "@@ -1064,6 +1064,26 @@ symbol_rank (gfc_symbol * sym)\n }\n \n \n+/* Given a symbol of a formal argument list and an expression, if the\n+   formal argument is allocatable, check that the actual argument is\n+   allocatable. Returns nonzero if compatible, zero if not compatible.  */\n+\n+static int\n+compare_allocatable (gfc_symbol * formal, gfc_expr * actual)\n+{\n+  symbol_attribute attr;\n+\n+  if (formal->attr.allocatable)\n+    {\n+      attr = gfc_expr_attr (actual);\n+      if (!attr.allocatable)\n+\treturn 0;\n+    }\n+\n+  return 1;\n+}\n+\n+\n /* Given a symbol of a formal argument list and an expression, if the\n    formal argument is a pointer, see if the actual argument is a\n    pointer. Returns nonzero if compatible, zero if not compatible.  */\n@@ -1276,6 +1296,15 @@ compare_actual_formal (gfc_actual_arglist ** ap,\n \t  return 0;\n \t}\n \n+      if (a->expr->expr_type != EXPR_NULL\n+\t  && compare_allocatable (f->sym, a->expr) == 0)\n+\t{\n+\t  if (where)\n+\t    gfc_error (\"Actual argument for '%s' must be ALLOCATABLE at %L\",\n+\t\t       f->sym->name, &a->expr->where);\n+\t  return 0;\n+\t}\n+\n       /* Check intent = OUT/INOUT for definable actual argument.  */\n       if (a->expr->expr_type != EXPR_VARIABLE\n \t     && (f->sym->attr.intent == INTENT_OUT"}, {"sha": "4bf394a1ff69dc4e9c65c30cf4bd921ed8cdffdf", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa08038dda94c80126a2ac54e8bab0964a95bf41/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa08038dda94c80126a2ac54e8bab0964a95bf41/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=aa08038dda94c80126a2ac54e8bab0964a95bf41", "patch": "@@ -2914,6 +2914,13 @@ resolve_deallocate_expr (gfc_expr * e)\n \t\t \"ALLOCATABLE or a POINTER\", &e->where);\n     }\n \n+  if (e->symtree->n.sym->attr.intent == INTENT_IN)\n+    {\n+      gfc_error (\"Can't deallocate INTENT(IN) variable '%s' at %L\",\n+                 e->symtree->n.sym->name, &e->where);\n+      return FAILURE;\n+    }\n+\n   return SUCCESS;\n }\n \n@@ -3015,6 +3022,13 @@ resolve_allocate_expr (gfc_expr * e, gfc_code * code)\n       return FAILURE;\n     }\n \n+  if (e->symtree->n.sym->attr.intent == INTENT_IN)\n+    {\n+      gfc_error (\"Can't allocate INTENT(IN) variable '%s' at %L\",\n+                 e->symtree->n.sym->name, &e->where);\n+      return FAILURE;\n+    }\n+\n   /* Add default initializer for those derived types that need them.  */\n   if (e->ts.type == BT_DERIVED && (init_e = gfc_default_initializer (&e->ts)))\n     {"}, {"sha": "e98556d2e1a13752af3f15f2e1cdd0757ad9b8fc", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa08038dda94c80126a2ac54e8bab0964a95bf41/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa08038dda94c80126a2ac54e8bab0964a95bf41/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=aa08038dda94c80126a2ac54e8bab0964a95bf41", "patch": "@@ -251,6 +251,13 @@ gfc_set_default_type (gfc_symbol * sym, int error_flag, gfc_namespace * ns)\n \n #define conf(a, b) if (attr->a && attr->b) { a1 = a; a2 = b; goto conflict; }\n #define conf2(a) if (attr->a) { a2 = a; goto conflict; }\n+#define conf_std(a, b, std) if (attr->a && attr->b)\\\n+                              {\\\n+                                a1 = a;\\\n+                                a2 = b;\\\n+                                standard = std;\\\n+                                goto conflict_std;\\\n+                              }\n \n static try\n check_conflict (symbol_attribute * attr, const char * name, locus * where)\n@@ -268,6 +275,7 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n   static const char *threadprivate = \"THREADPRIVATE\";\n \n   const char *a1, *a2;\n+  int standard;\n \n   if (where == NULL)\n     where = &gfc_current_locus;\n@@ -328,7 +336,7 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n     }\n \n   conf (allocatable, pointer);\n-  conf (allocatable, dummy);\t/* TODO: Allowed in Fortran 200x.  */\n+  conf_std (allocatable, dummy, GFC_STD_F2003);\n   conf (allocatable, function);\t/* TODO: Allowed in Fortran 200x.  */\n   conf (allocatable, result);\t/* TODO: Allowed in Fortran 200x.  */\n   conf (elemental, recursive);\n@@ -519,10 +527,25 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n \t       a1, a2, name, where);\n \n   return FAILURE;\n+\n+conflict_std:\n+  if (name == NULL)\n+    {\n+      return gfc_notify_std (standard, \"In the selected standard, %s attribute \"\n+                             \"conflicts with %s attribute at %L\", a1, a2,\n+                             where);\n+    }\n+  else\n+    {\n+      return gfc_notify_std (standard, \"In the selected standard, %s attribute \"\n+                             \"conflicts with %s attribute in '%s' at %L\",\n+                             a1, a2, name, where);\n+    }\n }\n \n #undef conf\n #undef conf2\n+#undef conf_std\n \n \n /* Mark a symbol as referenced.  */"}, {"sha": "1fc7f06feb0350e4776b29b117eeeecd8b8cd094", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa08038dda94c80126a2ac54e8bab0964a95bf41/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa08038dda94c80126a2ac54e8bab0964a95bf41/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=aa08038dda94c80126a2ac54e8bab0964a95bf41", "patch": "@@ -1870,16 +1870,15 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n             }\n \t  else\n \t    {\n-\t      /* If the procedure requires an explicit interface, the\n-\t\t actual argument is passed according to the\n-\t\t corresponding formal argument.  If the corresponding\n-\t\t formal argument is a POINTER or assumed shape, we do\n-\t\t not use g77's calling convention, and pass the\n-\t\t address of the array descriptor instead. Otherwise we\n-\t\t use g77's calling convention.  */\n+              /* If the procedure requires an explicit interface, the actual\n+                 argument is passed according to the corresponding formal\n+                 argument.  If the corresponding formal argument is a POINTER,\n+                 ALLOCATABLE or assumed shape, we do not use g77's calling\n+                 convention, and pass the address of the array descriptor\n+                 instead. Otherwise we use g77's calling convention.  */\n \t      int f;\n \t      f = (formal != NULL)\n-\t\t  && !formal->sym->attr.pointer\n+\t\t  && !(formal->sym->attr.pointer || formal->sym->attr.allocatable)\n \t\t  && formal->sym->as->type != AS_ASSUMED_SHAPE;\n \t      f = f || !sym->attr.always_explicit;\n \t      if (arg->expr->expr_type == EXPR_VARIABLE"}, {"sha": "d38d9599825c1ce175ee0ce9b6dcc60a12fcd12c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa08038dda94c80126a2ac54e8bab0964a95bf41/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa08038dda94c80126a2ac54e8bab0964a95bf41/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aa08038dda94c80126a2ac54e8bab0964a95bf41", "patch": "@@ -1,3 +1,9 @@\n+2005-03-05  Erik Edelmann  <eedelman@gcc.gnu.org>\n+\n+\tPR fortran/16136\n+\t* allocatable_dummy_1.f90: New.\n+\t* allocatable_dummy_2.f90: New.\n+\n 2006-03-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/26554"}, {"sha": "f0581adf1e210945a9fa8175701f7ecf1cfb6992", "filename": "gcc/testsuite/gfortran.dg/allocatable_dummy_1.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa08038dda94c80126a2ac54e8bab0964a95bf41/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_dummy_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa08038dda94c80126a2ac54e8bab0964a95bf41/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_dummy_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_dummy_1.f90?ref=aa08038dda94c80126a2ac54e8bab0964a95bf41", "patch": "@@ -0,0 +1,32 @@\n+! { dg-do run }\n+! Test procedures with allocatable dummy arguments\n+program alloc_dummy\n+\n+    implicit none\n+    integer, allocatable :: a(:)\n+\n+    call init(a)\n+    if (.NOT.allocated(a)) call abort()\n+    if (.NOT.all(a == [ 1, 2, 3 ])) call abort()\n+\n+    call kill(a)\n+    if (allocated(a)) call abort()\n+\n+\n+contains\n+\n+    subroutine init(x)\n+        integer, allocatable, intent(out) :: x(:)\n+\n+        allocate(x(3))\n+        x = [ 1, 2, 3 ]\n+    end subroutine init\n+\n+    \n+    subroutine kill(x)\n+        integer, allocatable, intent(out) :: x(:)\n+\n+        deallocate(x)\n+    end subroutine kill\n+\n+end program alloc_dummy"}, {"sha": "46a6f4fa671947cd3de7f133b5f1c9703286a00b", "filename": "gcc/testsuite/gfortran.dg/allocatable_dummy_2.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa08038dda94c80126a2ac54e8bab0964a95bf41/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_dummy_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa08038dda94c80126a2ac54e8bab0964a95bf41/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_dummy_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_dummy_2.f90?ref=aa08038dda94c80126a2ac54e8bab0964a95bf41", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do compile }\n+! Check a few constraints for ALLOCATABLE dummy arguments.\n+program alloc_dummy\n+\n+    implicit none\n+    integer :: a(5)\n+\n+    call init(a) ! { dg-error \"must be ALLOCATABLE\" }\n+\n+contains\n+\n+    subroutine init(x)\n+        integer, allocatable, intent(out) :: x(:)\n+    end subroutine init\n+\n+    subroutine init2(x)\n+        integer, allocatable, intent(in) :: x(:)\n+\n+        allocate(x(3)) ! { dg-error \"Can't allocate\" }\n+    end subroutine init2\n+\n+    subroutine kill(x)\n+        integer, allocatable, intent(in) :: x(:)\n+        \n+        deallocate(x) ! { dg-error \"Can't deallocate\" }\n+    end subroutine kill\n+\n+end program alloc_dummy"}]}