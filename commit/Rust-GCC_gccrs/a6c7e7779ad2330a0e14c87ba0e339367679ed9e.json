{"sha": "a6c7e7779ad2330a0e14c87ba0e339367679ed9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZjN2U3Nzc5YWQyMzMwYTBlMTRjODdiYTBlMzM5MzY3Njc5ZWQ5ZQ==", "commit": {"author": {"name": "Monk Chiang", "email": "sh.chiang04@gmail.com", "date": "2018-03-12T01:21:57Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2018-03-12T01:21:57Z"}, "message": "[NDS32] Refine prologue and epilogue code generation.\n\ngcc/\n\t* config/nds32/nds32.c (nds32_compute_stack_frame,\n\tnds32_emit_stack_push_multiple, nds32_emit_stack_pop_multiple,\n\tnds32_emit_stack_v3push, nds32_emit_stack_v3pop,\n\tnds32_emit_adjust_frame, nds32_expand_prologue, nds32_expand_epilogue,\n\tnds32_expand_prologue_v3push, nds32_expand_epilogue_v3pop): Refine.\n\t* config/nds32/nds32.h (NDS32_FIRST_CALLEE_SAVE_GPR_REGNUM,\n\tNDS32_LAST_CALLEE_SAVE_GPR_REGNUM, NDS32_V3PUSH_AVAILABLE_P): New.\n\t* config/nds32/nds32.md (prologue, epilogue): Use macro\n\tNDS32_V3PUSH_AVAILABLE_P to do checking.\n\nCo-Authored-By: Chung-Ju Wu <jasonwucj@gmail.com>\nCo-Authored-By: Kito Cheng <kito.cheng@gmail.com>\n\nFrom-SVN: r258442", "tree": {"sha": "6b0eb6a8d947dd718adb5c3b41c4b4a914480296", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b0eb6a8d947dd718adb5c3b41c4b4a914480296"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6c7e7779ad2330a0e14c87ba0e339367679ed9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6c7e7779ad2330a0e14c87ba0e339367679ed9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6c7e7779ad2330a0e14c87ba0e339367679ed9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6c7e7779ad2330a0e14c87ba0e339367679ed9e/comments", "author": {"login": "monkchiang", "id": 62004175, "node_id": "MDQ6VXNlcjYyMDA0MTc1", "avatar_url": "https://avatars.githubusercontent.com/u/62004175?v=4", "gravatar_id": "", "url": "https://api.github.com/users/monkchiang", "html_url": "https://github.com/monkchiang", "followers_url": "https://api.github.com/users/monkchiang/followers", "following_url": "https://api.github.com/users/monkchiang/following{/other_user}", "gists_url": "https://api.github.com/users/monkchiang/gists{/gist_id}", "starred_url": "https://api.github.com/users/monkchiang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/monkchiang/subscriptions", "organizations_url": "https://api.github.com/users/monkchiang/orgs", "repos_url": "https://api.github.com/users/monkchiang/repos", "events_url": "https://api.github.com/users/monkchiang/events{/privacy}", "received_events_url": "https://api.github.com/users/monkchiang/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1fdffa310b8ec30ba048c9857316e7f54432d992", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fdffa310b8ec30ba048c9857316e7f54432d992", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fdffa310b8ec30ba048c9857316e7f54432d992"}], "stats": {"total": 561, "additions": 252, "deletions": 309}, "files": [{"sha": "aad7f0e0697fe317bc01852e9617cdb5f22ecaf6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c7e7779ad2330a0e14c87ba0e339367679ed9e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c7e7779ad2330a0e14c87ba0e339367679ed9e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6c7e7779ad2330a0e14c87ba0e339367679ed9e", "patch": "@@ -1,3 +1,17 @@\n+2018-03-11  Monk Chiang  <sh.chiang04@gmail.com>\n+\t    Kito Cheng  <kito.cheng@gmail.com>\n+\t    Chung-Ju Wu  <jasonwucj@gmail.com>\n+\n+\t* config/nds32/nds32.c (nds32_compute_stack_frame,\n+\tnds32_emit_stack_push_multiple, nds32_emit_stack_pop_multiple,\n+\tnds32_emit_stack_v3push, nds32_emit_stack_v3pop,\n+\tnds32_emit_adjust_frame, nds32_expand_prologue, nds32_expand_epilogue,\n+\tnds32_expand_prologue_v3push, nds32_expand_epilogue_v3pop): Refine.\n+\t* config/nds32/nds32.h (NDS32_FIRST_CALLEE_SAVE_GPR_REGNUM,\n+\tNDS32_LAST_CALLEE_SAVE_GPR_REGNUM, NDS32_V3PUSH_AVAILABLE_P): New.\n+\t* config/nds32/nds32.md (prologue, epilogue): Use macro\n+\tNDS32_V3PUSH_AVAILABLE_P to do checking.\n+\n 2018-03-11  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/58150"}, {"sha": "2d644b77d159f6b7f3e65e053322bc1775e37f09", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 216, "deletions": 295, "changes": 511, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c7e7779ad2330a0e14c87ba0e339367679ed9e/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c7e7779ad2330a0e14c87ba0e339367679ed9e/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=a6c7e7779ad2330a0e14c87ba0e339367679ed9e", "patch": "@@ -144,6 +144,7 @@ nds32_compute_stack_frame (void)\n {\n   int r;\n   int block_size;\n+  bool v3pushpop_p;\n \n   /* Because nds32_compute_stack_frame() will be called from different place,\n      everytime we enter this function, we have to assume this function\n@@ -264,16 +265,16 @@ nds32_compute_stack_frame (void)\n       return;\n     }\n \n+  v3pushpop_p = NDS32_V3PUSH_AVAILABLE_P;\n+\n   /* Adjustment for v3push instructions:\n      If we are using v3push (push25/pop25) instructions,\n      we need to make sure Rb is $r6 and Re is\n      located on $r6, $r8, $r10, or $r14.\n      Some results above will be discarded and recomputed.\n      Note that it is only available under V3/V3M ISA and we\n      DO NOT setup following stuff for isr or variadic function.  */\n-  if (TARGET_V3PUSH\n-      && !nds32_isr_function_p (current_function_decl)\n-      && (cfun->machine->va_args_size == 0))\n+  if (v3pushpop_p)\n     {\n       /* Recompute:\n \t   cfun->machine->fp_size\n@@ -323,6 +324,39 @@ nds32_compute_stack_frame (void)\n \t}\n     }\n \n+  int sp_adjust = cfun->machine->local_size\n+\t\t  + cfun->machine->out_args_size\n+\t\t  + cfun->machine->callee_saved_area_gpr_padding_bytes;\n+\n+  if (!v3pushpop_p\n+      && sp_adjust == 0\n+      && !frame_pointer_needed)\n+    {\n+      block_size = cfun->machine->fp_size\n+\t\t   + cfun->machine->gp_size\n+\t\t   + cfun->machine->lp_size\n+\t\t   + (4 * (cfun->machine->callee_saved_last_gpr_regno\n+\t\t\t   - cfun->machine->callee_saved_first_gpr_regno\n+\t\t\t   + 1));\n+\n+      if (!NDS32_DOUBLE_WORD_ALIGN_P (block_size))\n+\t{\n+\t  /* $r14 is last callee save register.  */\n+\t  if (cfun->machine->callee_saved_last_gpr_regno\n+\t      < NDS32_LAST_CALLEE_SAVE_GPR_REGNUM)\n+\t    {\n+\t      cfun->machine->callee_saved_last_gpr_regno++;\n+\t    }\n+\t  else if (cfun->machine->callee_saved_first_gpr_regno == SP_REGNUM)\n+\t    {\n+\t      cfun->machine->callee_saved_first_gpr_regno\n+\t\t= NDS32_FIRST_CALLEE_SAVE_GPR_REGNUM;\n+\t      cfun->machine->callee_saved_last_gpr_regno\n+\t\t= NDS32_FIRST_CALLEE_SAVE_GPR_REGNUM;\n+\t    }\n+\t}\n+    }\n+\n   /* We have correctly set callee_saved_first_gpr_regno\n      and callee_saved_last_gpr_regno.\n      Initially, the callee_saved_gpr_regs_size is supposed to be 0.\n@@ -368,14 +402,15 @@ nds32_compute_stack_frame (void)\n      \"push registers to memory\",\n      \"adjust stack pointer\".  */\n static void\n-nds32_emit_stack_push_multiple (rtx Rb, rtx Re, rtx En4, bool vaarg_p)\n+nds32_emit_stack_push_multiple (unsigned Rb, unsigned Re,\n+\t\t\t\tbool save_fp_p, bool save_gp_p, bool save_lp_p,\n+\t\t\t\tbool vaarg_p)\n {\n-  int regno;\n+  unsigned regno;\n   int extra_count;\n   int num_use_regs;\n   int par_index;\n   int offset;\n-  int save_fp, save_gp, save_lp;\n \n   rtx reg;\n   rtx mem;\n@@ -403,24 +438,19 @@ nds32_emit_stack_push_multiple (rtx Rb, rtx Re, rtx En4, bool vaarg_p)\n \t\t(set (reg:SI SP_REGNUM)\n \t\t     (plus (reg:SI SP_REGNUM) (const_int -32)))]) */\n \n-  /* Determine whether we need to save $fp, $gp, or $lp.  */\n-  save_fp = INTVAL (En4) & 0x8;\n-  save_gp = INTVAL (En4) & 0x4;\n-  save_lp = INTVAL (En4) & 0x2;\n-\n   /* Calculate the number of registers that will be pushed.  */\n   extra_count = 0;\n-  if (save_fp)\n+  if (save_fp_p)\n     extra_count++;\n-  if (save_gp)\n+  if (save_gp_p)\n     extra_count++;\n-  if (save_lp)\n+  if (save_lp_p)\n     extra_count++;\n   /* Note that Rb and Re may be SP_REGNUM.  DO NOT count it in.  */\n-  if (REGNO (Rb) == SP_REGNUM && REGNO (Re) == SP_REGNUM)\n+  if (Rb == SP_REGNUM && Re == SP_REGNUM)\n     num_use_regs = extra_count;\n   else\n-    num_use_regs = REGNO (Re) - REGNO (Rb) + 1 + extra_count;\n+    num_use_regs = Re - Rb + 1 + extra_count;\n \n   /* In addition to used registers,\n      we need one more space for (set sp sp-x) rtx.  */\n@@ -432,7 +462,7 @@ nds32_emit_stack_push_multiple (rtx Rb, rtx Re, rtx En4, bool vaarg_p)\n   offset = -(num_use_regs * 4);\n \n   /* Create (set mem regX) from Rb, Rb+1 up to Re.  */\n-  for (regno = REGNO (Rb); regno <= (int) REGNO (Re); regno++)\n+  for (regno = Rb; regno <= Re; regno++)\n     {\n       /* Rb and Re may be SP_REGNUM.\n \t We need to break this loop immediately.  */\n@@ -451,7 +481,7 @@ nds32_emit_stack_push_multiple (rtx Rb, rtx Re, rtx En4, bool vaarg_p)\n     }\n \n   /* Create (set mem fp), (set mem gp), and (set mem lp) if necessary.  */\n-  if (save_fp)\n+  if (save_fp_p)\n     {\n       reg = gen_rtx_REG (SImode, FP_REGNUM);\n       mem = gen_frame_mem (SImode, plus_constant (Pmode,\n@@ -463,7 +493,7 @@ nds32_emit_stack_push_multiple (rtx Rb, rtx Re, rtx En4, bool vaarg_p)\n       offset = offset + 4;\n       par_index++;\n     }\n-  if (save_gp)\n+  if (save_gp_p)\n     {\n       reg = gen_rtx_REG (SImode, GP_REGNUM);\n       mem = gen_frame_mem (SImode, plus_constant (Pmode,\n@@ -475,7 +505,7 @@ nds32_emit_stack_push_multiple (rtx Rb, rtx Re, rtx En4, bool vaarg_p)\n       offset = offset + 4;\n       par_index++;\n     }\n-  if (save_lp)\n+  if (save_lp_p)\n     {\n       reg = gen_rtx_REG (SImode, LP_REGNUM);\n       mem = gen_frame_mem (SImode, plus_constant (Pmode,\n@@ -521,14 +551,14 @@ nds32_emit_stack_push_multiple (rtx Rb, rtx Re, rtx En4, bool vaarg_p)\n      \"pop registers from memory\",\n      \"adjust stack pointer\".  */\n static void\n-nds32_emit_stack_pop_multiple (rtx Rb, rtx Re, rtx En4)\n+nds32_emit_stack_pop_multiple (unsigned Rb, unsigned Re,\n+\t\t\t       bool save_fp_p, bool save_gp_p, bool save_lp_p)\n {\n-  int regno;\n+  unsigned regno;\n   int extra_count;\n   int num_use_regs;\n   int par_index;\n   int offset;\n-  int save_fp, save_gp, save_lp;\n \n   rtx reg;\n   rtx mem;\n@@ -556,24 +586,19 @@ nds32_emit_stack_pop_multiple (rtx Rb, rtx Re, rtx En4)\n \t\t(set (reg:SI SP_REGNUM)\n \t\t     (plus (reg:SI SP_REGNUM) (const_int 32)))]) */\n \n-  /* Determine whether we need to restore $fp, $gp, or $lp.  */\n-  save_fp = INTVAL (En4) & 0x8;\n-  save_gp = INTVAL (En4) & 0x4;\n-  save_lp = INTVAL (En4) & 0x2;\n-\n   /* Calculate the number of registers that will be poped.  */\n   extra_count = 0;\n-  if (save_fp)\n+  if (save_fp_p)\n     extra_count++;\n-  if (save_gp)\n+  if (save_gp_p)\n     extra_count++;\n-  if (save_lp)\n+  if (save_lp_p)\n     extra_count++;\n   /* Note that Rb and Re may be SP_REGNUM.  DO NOT count it in.  */\n-  if (REGNO (Rb) == SP_REGNUM && REGNO (Re) == SP_REGNUM)\n+  if (Rb == SP_REGNUM && Re == SP_REGNUM)\n     num_use_regs = extra_count;\n   else\n-    num_use_regs = REGNO (Re) - REGNO (Rb) + 1 + extra_count;\n+    num_use_regs = Re - Rb + 1 + extra_count;\n \n   /* In addition to used registers,\n      we need one more space for (set sp sp+x) rtx.  */\n@@ -585,7 +610,7 @@ nds32_emit_stack_pop_multiple (rtx Rb, rtx Re, rtx En4)\n   offset = 0;\n \n   /* Create (set regX mem) from Rb, Rb+1 up to Re.  */\n-  for (regno = REGNO (Rb); regno <= (int) REGNO (Re); regno++)\n+  for (regno = Rb; regno <= Re; regno++)\n     {\n       /* Rb and Re may be SP_REGNUM.\n \t We need to break this loop immediately.  */\n@@ -606,7 +631,7 @@ nds32_emit_stack_pop_multiple (rtx Rb, rtx Re, rtx En4)\n     }\n \n   /* Create (set fp mem), (set gp mem), and (set lp mem) if necessary.  */\n-  if (save_fp)\n+  if (save_fp_p)\n     {\n       reg = gen_rtx_REG (SImode, FP_REGNUM);\n       mem = gen_frame_mem (SImode, plus_constant (Pmode,\n@@ -620,7 +645,7 @@ nds32_emit_stack_pop_multiple (rtx Rb, rtx Re, rtx En4)\n \n       dwarf = alloc_reg_note (REG_CFA_RESTORE, reg, dwarf);\n     }\n-  if (save_gp)\n+  if (save_gp_p)\n     {\n       reg = gen_rtx_REG (SImode, GP_REGNUM);\n       mem = gen_frame_mem (SImode, plus_constant (Pmode,\n@@ -634,7 +659,7 @@ nds32_emit_stack_pop_multiple (rtx Rb, rtx Re, rtx En4)\n \n       dwarf = alloc_reg_note (REG_CFA_RESTORE, reg, dwarf);\n     }\n-  if (save_lp)\n+  if (save_lp_p)\n     {\n       reg = gen_rtx_REG (SImode, LP_REGNUM);\n       mem = gen_frame_mem (SImode, plus_constant (Pmode,\n@@ -677,12 +702,11 @@ nds32_emit_stack_pop_multiple (rtx Rb, rtx Re, rtx En4)\n      \"push registers to memory\",\n      \"adjust stack pointer\".  */\n static void\n-nds32_emit_stack_v3push (rtx Rb,\n-\t\t\t rtx Re,\n-\t\t\t rtx En4 ATTRIBUTE_UNUSED,\n-\t\t\t rtx imm8u)\n+nds32_emit_stack_v3push (unsigned Rb,\n+\t\t\t unsigned Re,\n+\t\t\t unsigned imm8u)\n {\n-  int regno;\n+  unsigned regno;\n   int num_use_regs;\n   int par_index;\n   int offset;\n@@ -717,7 +741,7 @@ nds32_emit_stack_v3push (rtx Rb,\n      we need to count these three registers.\n      Under v3push, Rb is $r6, while Re is $r6, $r8, $r10, or $r14.\n      So there is no need to worry about Rb=Re=SP_REGNUM case.  */\n-  num_use_regs = REGNO (Re) - REGNO (Rb) + 1 + 3;\n+  num_use_regs = Re - Rb + 1 + 3;\n \n   /* In addition to used registers,\n      we need one more space for (set sp sp-x-imm8u) rtx.  */\n@@ -731,7 +755,7 @@ nds32_emit_stack_v3push (rtx Rb,\n   /* Create (set mem regX) from Rb, Rb+1 up to Re.\n      Under v3push, Rb is $r6, while Re is $r6, $r8, $r10, or $r14.\n      So there is no need to worry about Rb=Re=SP_REGNUM case.  */\n-  for (regno = REGNO (Rb); regno <= (int) REGNO (Re); regno++)\n+  for (regno = Rb; regno <= Re; regno++)\n     {\n       reg = gen_rtx_REG (SImode, regno);\n       mem = gen_frame_mem (SImode, plus_constant (Pmode,\n@@ -783,7 +807,7 @@ nds32_emit_stack_v3push (rtx Rb,\n     = gen_rtx_SET (stack_pointer_rtx,\n \t\t   plus_constant (Pmode,\n \t\t\t\t  stack_pointer_rtx,\n-\t\t\t\t  offset - INTVAL (imm8u)));\n+\t\t\t\t  offset - imm8u));\n   XVECEXP (parallel_insn, 0, par_index) = adjust_sp_rtx;\n   RTX_FRAME_RELATED_P (adjust_sp_rtx) = 1;\n \n@@ -801,12 +825,11 @@ nds32_emit_stack_v3push (rtx Rb,\n      \"pop registers from memory\",\n      \"adjust stack pointer\".  */\n static void\n-nds32_emit_stack_v3pop (rtx Rb,\n-\t\t\trtx Re,\n-\t\t\trtx En4 ATTRIBUTE_UNUSED,\n-\t\t\trtx imm8u)\n+nds32_emit_stack_v3pop (unsigned Rb,\n+\t\t\tunsigned Re,\n+\t\t\tunsigned imm8u)\n {\n-  int regno;\n+  unsigned regno;\n   int num_use_regs;\n   int par_index;\n   int offset;\n@@ -842,7 +865,7 @@ nds32_emit_stack_v3pop (rtx Rb,\n      we need to count these three registers.\n      Under v3push, Rb is $r6, while Re is $r6, $r8, $r10, or $r14.\n      So there is no need to worry about Rb=Re=SP_REGNUM case.  */\n-  num_use_regs = REGNO (Re) - REGNO (Rb) + 1 + 3;\n+  num_use_regs = Re - Rb + 1 + 3;\n \n   /* In addition to used registers,\n      we need one more space for (set sp sp+x+imm8u) rtx.  */\n@@ -856,7 +879,7 @@ nds32_emit_stack_v3pop (rtx Rb,\n   /* Create (set regX mem) from Rb, Rb+1 up to Re.\n      Under v3pop, Rb is $r6, while Re is $r6, $r8, $r10, or $r14.\n      So there is no need to worry about Rb=Re=SP_REGNUM case.  */\n-  for (regno = REGNO (Rb); regno <= (int) REGNO (Re); regno++)\n+  for (regno = Rb; regno <= Re; regno++)\n     {\n       reg = gen_rtx_REG (SImode, regno);\n       mem = gen_frame_mem (SImode, plus_constant (Pmode,\n@@ -914,11 +937,24 @@ nds32_emit_stack_v3pop (rtx Rb,\n     = gen_rtx_SET (stack_pointer_rtx,\n \t\t   plus_constant (Pmode,\n \t\t\t\t  stack_pointer_rtx,\n-\t\t\t\t  offset + INTVAL (imm8u)));\n+\t\t\t\t  offset + imm8u));\n   XVECEXP (parallel_insn, 0, par_index) = adjust_sp_rtx;\n \n-  /* Tell gcc we adjust SP in this insn.  */\n-  dwarf = alloc_reg_note (REG_CFA_ADJUST_CFA, copy_rtx (adjust_sp_rtx), dwarf);\n+  if (frame_pointer_needed)\n+    {\n+      /* (expr_list:REG_CFA_DEF_CFA (plus:SI (reg/f:SI $sp)\n+\t\t\t\t\t     (const_int 0))\n+\t mean reset frame pointer to $sp and reset to offset 0.  */\n+      rtx cfa_adjust_rtx = gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t const0_rtx);\n+      dwarf = alloc_reg_note (REG_CFA_DEF_CFA, cfa_adjust_rtx, dwarf);\n+    }\n+  else\n+    {\n+      /* Tell gcc we adjust SP in this insn.  */\n+      dwarf = alloc_reg_note (REG_CFA_ADJUST_CFA,\n+\t\t\t      copy_rtx (adjust_sp_rtx), dwarf);\n+    }\n \n   parallel_insn = emit_insn (parallel_insn);\n \n@@ -940,18 +976,18 @@ nds32_emit_stack_v3pop (rtx Rb,\n    the adjustment value is not able to be fit in the 'addi' instruction.\n    One solution is to move value into a register\n    and then use 'add' instruction.\n-   In practice, we use TA_REGNUM ($r15) to accomplish this purpose.\n-   Also, we need to return zero for sp adjustment so that\n-   proglogue/epilogue knows there is no need to create 'addi' instruction.  */\n-static int\n-nds32_force_addi_stack_int (int full_value)\n+   In practice, we use TA_REGNUM ($r15) to accomplish this purpose.  */\n+static void\n+nds32_emit_adjust_frame (rtx to_reg, rtx from_reg, int adjust_value)\n {\n-  int adjust_value;\n-\n   rtx tmp_reg;\n-  rtx sp_adjust_insn;\n+  rtx frame_adjust_insn;\n+  rtx adjust_value_rtx = GEN_INT (adjust_value);\n \n-  if (!satisfies_constraint_Is15 (GEN_INT (full_value)))\n+  if (adjust_value == 0)\n+    return;\n+\n+  if (!satisfies_constraint_Is15 (adjust_value_rtx))\n     {\n       /* The value is not able to fit in single addi instruction.\n \t Create more instructions of moving value into a register\n@@ -962,52 +998,43 @@ nds32_force_addi_stack_int (int full_value)\n \n       /* Create one more instruction to move value\n \t into the temporary register.  */\n-      emit_move_insn (tmp_reg, GEN_INT (full_value));\n+      emit_move_insn (tmp_reg, adjust_value_rtx);\n \n       /* Create new 'add' rtx.  */\n-      sp_adjust_insn = gen_addsi3 (stack_pointer_rtx,\n-\t\t\t\t   stack_pointer_rtx,\n-\t\t\t\t   tmp_reg);\n+      frame_adjust_insn = gen_addsi3 (to_reg,\n+\t\t\t\t      from_reg,\n+\t\t\t\t      tmp_reg);\n       /* Emit rtx into insn list and receive its transformed insn rtx.  */\n-      sp_adjust_insn = emit_insn (sp_adjust_insn);\n+      frame_adjust_insn = emit_insn (frame_adjust_insn);\n \n-      /* At prologue, we need to tell GCC that this is frame related insn,\n-         so that we can consider this instruction to output debug information.\n-         If full_value is NEGATIVE, it means this function\n-         is invoked by expand_prologue.  */\n-      if (full_value < 0)\n-\t{\n-\t  /* Because (tmp_reg <- full_value) may be split into two\n-\t     rtl patterns, we can not set its RTX_FRAME_RELATED_P.\n-\t     We need to construct another (sp <- sp + full_value)\n-\t     and then insert it into sp_adjust_insn's reg note to\n-\t     represent a frame related expression.\n-\t     GCC knows how to refer it and output debug information.  */\n-\n-\t  rtx plus_rtx;\n-\t  rtx set_rtx;\n+      /* Because (tmp_reg <- full_value) may be split into two\n+\t rtl patterns, we can not set its RTX_FRAME_RELATED_P.\n+\t We need to construct another (sp <- sp + full_value)\n+\t and then insert it into sp_adjust_insn's reg note to\n+\t represent a frame related expression.\n+\t GCC knows how to refer it and output debug information.  */\n \n-\t  plus_rtx = plus_constant (Pmode, stack_pointer_rtx, full_value);\n-\t  set_rtx = gen_rtx_SET (stack_pointer_rtx, plus_rtx);\n-\t  add_reg_note (sp_adjust_insn, REG_FRAME_RELATED_EXPR, set_rtx);\n+      rtx plus_rtx;\n+      rtx set_rtx;\n \n-\t  RTX_FRAME_RELATED_P (sp_adjust_insn) = 1;\n-\t}\n-\n-      /* We have used alternative way to adjust stack pointer value.\n-         Return zero so that prologue/epilogue\n-         will not generate other instructions.  */\n-      return 0;\n+      plus_rtx = plus_constant (Pmode, from_reg, adjust_value);\n+      set_rtx = gen_rtx_SET (to_reg, plus_rtx);\n+      add_reg_note (frame_adjust_insn, REG_FRAME_RELATED_EXPR, set_rtx);\n     }\n   else\n     {\n-      /* The value is able to fit in addi instruction.\n-         However, remember to make it to be positive value\n-         because we want to return 'adjustment' result.  */\n-      adjust_value = (full_value < 0) ? (-full_value) : (full_value);\n-\n-      return adjust_value;\n+      /* Generate sp adjustment instruction if and only if sp_adjust != 0.  */\n+      frame_adjust_insn = gen_addsi3 (to_reg,\n+\t\t\t\t      from_reg,\n+\t\t\t\t      adjust_value_rtx);\n+      /* Emit rtx into instructions list and receive INSN rtx form.  */\n+      frame_adjust_insn = emit_insn (frame_adjust_insn);\n     }\n+\n+    /* The insn rtx 'sp_adjust_insn' will change frame layout.\n+       We need to use RTX_FRAME_RELATED_P so that GCC is able to\n+       generate CFI (Call Frame Information) stuff.  */\n+    RTX_FRAME_RELATED_P (frame_adjust_insn) = 1;\n }\n \n /* Return true if MODE/TYPE need double word alignment.  */\n@@ -2965,10 +2992,7 @@ nds32_expand_prologue (void)\n {\n   int fp_adjust;\n   int sp_adjust;\n-  int en4_const;\n-\n-  rtx Rb, Re;\n-  rtx fp_adjust_insn, sp_adjust_insn;\n+  unsigned Rb, Re;\n \n   /* Compute and setup stack frame size.\n      The result will be in cfun->machine.  */\n@@ -2978,28 +3002,21 @@ nds32_expand_prologue (void)\n      registers that hold the unnamed argument value.  */\n   if (cfun->machine->va_args_size != 0)\n     {\n-      Rb = gen_rtx_REG (SImode, cfun->machine->va_args_first_regno);\n-      Re = gen_rtx_REG (SImode, cfun->machine->va_args_last_regno);\n-      /* No need to push $fp, $gp, or $lp, so use GEN_INT(0).  */\n-      nds32_emit_stack_push_multiple (Rb, Re, GEN_INT (0), true);\n+      Rb = cfun->machine->va_args_first_regno;\n+      Re = cfun->machine->va_args_last_regno;\n+      /* No need to push $fp, $gp, or $lp.  */\n+      nds32_emit_stack_push_multiple (Rb, Re, false, false, false, true);\n \n       /* We may also need to adjust stack pointer for padding bytes\n          because varargs may cause $sp not 8-byte aligned.  */\n       if (cfun->machine->va_args_area_padding_bytes)\n \t{\n \t  /* Generate sp adjustment instruction.  */\n \t  sp_adjust = cfun->machine->va_args_area_padding_bytes;\n-\t  sp_adjust_insn = gen_addsi3 (stack_pointer_rtx,\n-\t\t\t\t       stack_pointer_rtx,\n-\t\t\t\t       GEN_INT (-1 * sp_adjust));\n-\n-\t  /* Emit rtx into instructions list and receive INSN rtx form.  */\n-\t  sp_adjust_insn = emit_insn (sp_adjust_insn);\n \n-\t  /* The insn rtx 'sp_adjust_insn' will change frame layout.\n-\t     We need to use RTX_FRAME_RELATED_P so that GCC is able to\n-\t     generate CFI (Call Frame Information) stuff.  */\n-\t  RTX_FRAME_RELATED_P (sp_adjust_insn) = 1;\n+\t  nds32_emit_adjust_frame (stack_pointer_rtx,\n+\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t   -1 * sp_adjust);\n \t}\n     }\n \n@@ -3009,28 +3026,22 @@ nds32_expand_prologue (void)\n     return;\n \n   /* Get callee_first_regno and callee_last_regno.  */\n-  Rb = gen_rtx_REG (SImode, cfun->machine->callee_saved_first_gpr_regno);\n-  Re = gen_rtx_REG (SImode, cfun->machine->callee_saved_last_gpr_regno);\n-\n-  /* nds32_emit_stack_push_multiple(first_regno, last_regno),\n-     the pattern 'stack_push_multiple' is implemented in nds32.md.\n-     For En4 field, we have to calculate its constant value.\n-     Refer to Andes ISA for more information.  */\n-  en4_const = 0;\n-  if (cfun->machine->fp_size)\n-    en4_const += 8;\n-  if (cfun->machine->gp_size)\n-    en4_const += 4;\n-  if (cfun->machine->lp_size)\n-    en4_const += 2;\n+  Rb = cfun->machine->callee_saved_first_gpr_regno;\n+  Re = cfun->machine->callee_saved_last_gpr_regno;\n \n   /* If $fp, $gp, $lp, and all callee-save registers are NOT required\n      to be saved, we don't have to create multiple push instruction.\n      Otherwise, a multiple push instruction is needed.  */\n-  if (!(REGNO (Rb) == SP_REGNUM && REGNO (Re) == SP_REGNUM && en4_const == 0))\n+  if (!(Rb == SP_REGNUM && Re == SP_REGNUM\n+\t&& cfun->machine->fp_size == 0\n+\t&& cfun->machine->gp_size == 0\n+\t&& cfun->machine->lp_size == 0))\n     {\n       /* Create multiple push instruction rtx.  */\n-      nds32_emit_stack_push_multiple (Rb, Re, GEN_INT (en4_const), false);\n+      nds32_emit_stack_push_multiple (\n+\tRb, Re,\n+\tcfun->machine->fp_size, cfun->machine->gp_size, cfun->machine->lp_size,\n+\tfalse);\n     }\n \n   /* Check frame_pointer_needed to see\n@@ -3047,14 +3058,10 @@ nds32_expand_prologue (void)\n \t\t  + cfun->machine->gp_size\n \t\t  + cfun->machine->lp_size\n \t\t  + cfun->machine->callee_saved_gpr_regs_size;\n-      fp_adjust_insn = gen_addsi3 (hard_frame_pointer_rtx,\n-\t\t\t\t   stack_pointer_rtx,\n-\t\t\t\t   GEN_INT (fp_adjust));\n-      /* Emit rtx into instructions list and receive INSN rtx form.  */\n-      fp_adjust_insn = emit_insn (fp_adjust_insn);\n \n-      /* The insn rtx 'fp_adjust_insn' will change frame layout.  */\n-      RTX_FRAME_RELATED_P (fp_adjust_insn) = 1;\n+      nds32_emit_adjust_frame (hard_frame_pointer_rtx,\n+\t\t\t       stack_pointer_rtx,\n+\t\t\t       fp_adjust);\n     }\n \n   /* Adjust $sp = $sp - local_size - out_args_size\n@@ -3065,21 +3072,9 @@ nds32_expand_prologue (void)\n   /* sp_adjust value may be out of range of the addi instruction,\n      create alternative add behavior with TA_REGNUM if necessary,\n      using NEGATIVE value to tell that we are decreasing address.  */\n-  sp_adjust = nds32_force_addi_stack_int ( (-1) * sp_adjust);\n-  if (sp_adjust)\n-    {\n-      /* Generate sp adjustment instruction if and only if sp_adjust != 0.  */\n-      sp_adjust_insn = gen_addsi3 (stack_pointer_rtx,\n-\t\t\t\t   stack_pointer_rtx,\n-\t\t\t\t   GEN_INT (-1 * sp_adjust));\n-      /* Emit rtx into instructions list and receive INSN rtx form.  */\n-      sp_adjust_insn = emit_insn (sp_adjust_insn);\n-\n-      /* The insn rtx 'sp_adjust_insn' will change frame layout.\n-         We need to use RTX_FRAME_RELATED_P so that GCC is able to\n-         generate CFI (Call Frame Information) stuff.  */\n-      RTX_FRAME_RELATED_P (sp_adjust_insn) = 1;\n-    }\n+  nds32_emit_adjust_frame (stack_pointer_rtx,\n+\t\t\t   stack_pointer_rtx,\n+\t\t\t   -1 * sp_adjust);\n \n   /* Prevent the instruction scheduler from\n      moving instructions across the boundary.  */\n@@ -3091,10 +3086,7 @@ void\n nds32_expand_epilogue (bool sibcall_p)\n {\n   int sp_adjust;\n-  int en4_const;\n-\n-  rtx Rb, Re;\n-  rtx sp_adjust_insn;\n+  unsigned Rb, Re;\n \n   /* Compute and setup stack frame size.\n      The result will be in cfun->machine.  */\n@@ -3119,16 +3111,10 @@ nds32_expand_epilogue (bool sibcall_p)\n \t     We  need to consider padding bytes here.  */\n \t  sp_adjust = cfun->machine->va_args_size\n \t\t      + cfun->machine->va_args_area_padding_bytes;\n-\t  sp_adjust_insn = gen_addsi3 (stack_pointer_rtx,\n-\t\t\t\t       stack_pointer_rtx,\n-\t\t\t\t       GEN_INT (sp_adjust));\n-\t  /* Emit rtx into instructions list and receive INSN rtx form.  */\n-\t  sp_adjust_insn = emit_insn (sp_adjust_insn);\n-\n-\t  /* The insn rtx 'sp_adjust_insn' will change frame layout.\n-\t     We need to use RTX_FRAME_RELATED_P so that GCC is able to\n-\t     generate CFI (Call Frame Information) stuff.  */\n-\t  RTX_FRAME_RELATED_P (sp_adjust_insn) = 1;\n+\n+\t  nds32_emit_adjust_frame (stack_pointer_rtx,\n+\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t   sp_adjust);\n \t}\n \n       /* Generate return instruction by using 'return_internal' pattern.\n@@ -3150,71 +3136,47 @@ nds32_expand_epilogue (bool sibcall_p)\n \t\t  + cfun->machine->gp_size\n \t\t  + cfun->machine->lp_size\n \t\t  + cfun->machine->callee_saved_gpr_regs_size;\n-      sp_adjust_insn = gen_addsi3 (stack_pointer_rtx,\n-\t\t\t\t   hard_frame_pointer_rtx,\n-\t\t\t\t   GEN_INT (-1 * sp_adjust));\n-      /* Emit rtx into instructions list and receive INSN rtx form.  */\n-      sp_adjust_insn = emit_insn (sp_adjust_insn);\n \n-      /* The insn rtx 'sp_adjust_insn' will change frame layout.  */\n-      RTX_FRAME_RELATED_P (sp_adjust_insn) = 1;\n+      nds32_emit_adjust_frame (stack_pointer_rtx,\n+\t\t\t       hard_frame_pointer_rtx,\n+\t\t\t       -1 * sp_adjust);\n     }\n   else\n     {\n       /* If frame pointer is NOT needed,\n \t we cannot calculate the sp adjustment from frame pointer.\n \t Instead, we calculate the adjustment by local_size,\n-\t out_args_size, and callee_saved_area_padding_bytes.\n+\t out_args_size, and callee_saved_area_gpr_padding_bytes.\n \t Notice that such sp adjustment value may be out of range,\n \t so we have to deal with it as well.  */\n \n       /* Adjust $sp = $sp + local_size + out_args_size\n-\t\t\t  + callee_saved_area_padding_bytes.  */\n+\t                  + callee_saved_area_gpr_padding_bytes.  */\n       sp_adjust = cfun->machine->local_size\n \t\t  + cfun->machine->out_args_size\n \t\t  + cfun->machine->callee_saved_area_gpr_padding_bytes;\n-      /* sp_adjust value may be out of range of the addi instruction,\n-\t create alternative add behavior with TA_REGNUM if necessary,\n-\t using POSITIVE value to tell that we are increasing address.  */\n-      sp_adjust = nds32_force_addi_stack_int (sp_adjust);\n-      if (sp_adjust)\n-\t{\n-\t  /* Generate sp adjustment instruction\n-\t     if and only if sp_adjust != 0.  */\n-\t  sp_adjust_insn = gen_addsi3 (stack_pointer_rtx,\n-\t\t\t\t       stack_pointer_rtx,\n-\t\t\t\t       GEN_INT (sp_adjust));\n-\t  /* Emit rtx into instructions list and receive INSN rtx form.  */\n-\t  sp_adjust_insn = emit_insn (sp_adjust_insn);\n-\n-\t  /* The insn rtx 'sp_adjust_insn' will change frame layout.  */\n-\t  RTX_FRAME_RELATED_P (sp_adjust_insn) = 1;\n-\t}\n+\n+      nds32_emit_adjust_frame (stack_pointer_rtx,\n+\t\t\t       stack_pointer_rtx,\n+\t\t\t       sp_adjust);\n     }\n \n   /* Get callee_first_regno and callee_last_regno.  */\n-  Rb = gen_rtx_REG (SImode, cfun->machine->callee_saved_first_gpr_regno);\n-  Re = gen_rtx_REG (SImode, cfun->machine->callee_saved_last_gpr_regno);\n-\n-  /* nds32_emit_stack_pop_multiple(first_regno, last_regno),\n-     the pattern 'stack_pop_multiple' is implementad in nds32.md.\n-     For En4 field, we have to calculate its constant value.\n-     Refer to Andes ISA for more information.  */\n-  en4_const = 0;\n-  if (cfun->machine->fp_size)\n-    en4_const += 8;\n-  if (cfun->machine->gp_size)\n-    en4_const += 4;\n-  if (cfun->machine->lp_size)\n-    en4_const += 2;\n+  Rb = cfun->machine->callee_saved_first_gpr_regno;\n+  Re = cfun->machine->callee_saved_last_gpr_regno;\n \n   /* If $fp, $gp, $lp, and all callee-save registers are NOT required\n      to be saved, we don't have to create multiple pop instruction.\n      Otherwise, a multiple pop instruction is needed.  */\n-  if (!(REGNO (Rb) == SP_REGNUM && REGNO (Re) == SP_REGNUM && en4_const == 0))\n+  if (!(Rb == SP_REGNUM && Re == SP_REGNUM\n+\t&& cfun->machine->fp_size == 0\n+\t&& cfun->machine->gp_size == 0\n+\t&& cfun->machine->lp_size == 0))\n     {\n       /* Create multiple pop instruction rtx.  */\n-      nds32_emit_stack_pop_multiple (Rb, Re, GEN_INT (en4_const));\n+      nds32_emit_stack_pop_multiple (\n+\tRb, Re,\n+\tcfun->machine->fp_size, cfun->machine->gp_size, cfun->machine->lp_size);\n     }\n \n   /* If this is a variadic function, we do not have to restore argument\n@@ -3226,16 +3188,10 @@ nds32_expand_epilogue (bool sibcall_p)\n \t We need to consider padding bytes here.  */\n       sp_adjust = cfun->machine->va_args_size\n \t\t  + cfun->machine->va_args_area_padding_bytes;\n-      sp_adjust_insn = gen_addsi3 (stack_pointer_rtx,\n-\t\t\t\t   stack_pointer_rtx,\n-\t\t\t\t   GEN_INT (sp_adjust));\n-      /* Emit rtx into instructions list and receive INSN rtx form.  */\n-      sp_adjust_insn = emit_insn (sp_adjust_insn);\n \n-      /* The insn rtx 'sp_adjust_insn' will change frame layout.\n-\t We need to use RTX_FRAME_RELATED_P so that GCC is able to\n-\t generate CFI (Call Frame Information) stuff.  */\n-      RTX_FRAME_RELATED_P (sp_adjust_insn) = 1;\n+      nds32_emit_adjust_frame (stack_pointer_rtx,\n+\t\t\t       stack_pointer_rtx,\n+\t\t\t       sp_adjust);\n     }\n \n   /* Generate return instruction.  */\n@@ -3249,22 +3205,23 @@ nds32_expand_prologue_v3push (void)\n {\n   int fp_adjust;\n   int sp_adjust;\n-\n-  rtx Rb, Re;\n-  rtx fp_adjust_insn, sp_adjust_insn;\n+  unsigned Rb, Re;\n \n   /* Compute and setup stack frame size.\n      The result will be in cfun->machine.  */\n   nds32_compute_stack_frame ();\n \n+  if (cfun->machine->callee_saved_gpr_regs_size > 0)\n+    df_set_regs_ever_live (FP_REGNUM, 1);\n+\n   /* If the function is 'naked',\n      we do not have to generate prologue code fragment.  */\n   if (cfun->machine->naked_p)\n     return;\n \n   /* Get callee_first_regno and callee_last_regno.  */\n-  Rb = gen_rtx_REG (SImode, cfun->machine->callee_saved_first_gpr_regno);\n-  Re = gen_rtx_REG (SImode, cfun->machine->callee_saved_last_gpr_regno);\n+  Rb = cfun->machine->callee_saved_first_gpr_regno;\n+  Re = cfun->machine->callee_saved_last_gpr_regno;\n \n   /* Calculate sp_adjust first to test if 'push25 Re,imm8u' is available,\n      where imm8u has to be 8-byte alignment.  */\n@@ -3278,11 +3235,8 @@ nds32_expand_prologue_v3push (void)\n       /* We can use 'push25 Re,imm8u'.  */\n \n       /* nds32_emit_stack_v3push(last_regno, sp_adjust),\n-\t the pattern 'stack_v3push' is implemented in nds32.md.\n-         The (const_int 14) means v3push always push { $fp $gp $lp }.  */\n-      nds32_emit_stack_v3push (Rb, Re,\n-\t\t\t       GEN_INT (14), GEN_INT (sp_adjust));\n-\n+\t the pattern 'stack_v3push' is implemented in nds32.md.  */\n+      nds32_emit_stack_v3push (Rb, Re, sp_adjust);\n       /* Check frame_pointer_needed to see\n \t if we shall emit fp adjustment instruction.  */\n       if (frame_pointer_needed)\n@@ -3302,11 +3256,10 @@ nds32_expand_prologue_v3push (void)\n \t\t      + cfun->machine->lp_size\n \t\t      + cfun->machine->callee_saved_gpr_regs_size\n \t\t      + sp_adjust;\n-\t  fp_adjust_insn = gen_addsi3 (hard_frame_pointer_rtx,\n-\t\t\t\t       stack_pointer_rtx,\n-\t\t\t\t       GEN_INT (fp_adjust));\n-\t  /* Emit rtx into instructions list and receive INSN rtx form.  */\n-\t  fp_adjust_insn = emit_insn (fp_adjust_insn);\n+\n+\t  nds32_emit_adjust_frame (hard_frame_pointer_rtx,\n+\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t   fp_adjust);\n \t}\n     }\n   else\n@@ -3315,10 +3268,8 @@ nds32_expand_prologue_v3push (void)\n \t expand one more instruction to adjust $sp later.  */\n \n       /* nds32_emit_stack_v3push(last_regno, sp_adjust),\n-\t the pattern 'stack_v3push' is implemented in nds32.md.\n-\t The (const_int 14) means v3push always push { $fp $gp $lp }.  */\n-      nds32_emit_stack_v3push (Rb, Re,\n-\t\t\t       GEN_INT (14), GEN_INT (0));\n+\t the pattern 'stack_v3push' is implemented in nds32.md.  */\n+      nds32_emit_stack_v3push (Rb, Re, 0);\n \n       /* Check frame_pointer_needed to see\n \t if we shall emit fp adjustment instruction.  */\n@@ -3336,34 +3287,18 @@ nds32_expand_prologue_v3push (void)\n \t\t      + cfun->machine->gp_size\n \t\t      + cfun->machine->lp_size\n \t\t      + cfun->machine->callee_saved_gpr_regs_size;\n-\t  fp_adjust_insn = gen_addsi3 (hard_frame_pointer_rtx,\n-\t\t\t\t       stack_pointer_rtx,\n-\t\t\t\t       GEN_INT (fp_adjust));\n-\t  /* Emit rtx into instructions list and receive INSN rtx form.  */\n-\t  fp_adjust_insn = emit_insn (fp_adjust_insn);\n+\n+\t  nds32_emit_adjust_frame (hard_frame_pointer_rtx,\n+\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t   fp_adjust);\n \t}\n \n       /* Because we use 'push25 Re,0',\n \t we need to expand one more instruction to adjust $sp.\n-\t However, sp_adjust value may be out of range of the addi instruction,\n-\t create alternative add behavior with TA_REGNUM if necessary,\n \t using NEGATIVE value to tell that we are decreasing address.  */\n-      sp_adjust = nds32_force_addi_stack_int ( (-1) * sp_adjust);\n-      if (sp_adjust)\n-\t{\n-\t  /* Generate sp adjustment instruction\n-\t     if and only if sp_adjust != 0.  */\n-\t  sp_adjust_insn = gen_addsi3 (stack_pointer_rtx,\n-\t\t\t\t       stack_pointer_rtx,\n-\t\t\t\t       GEN_INT (-1 * sp_adjust));\n-\t  /* Emit rtx into instructions list and receive INSN rtx form.  */\n-\t  sp_adjust_insn = emit_insn (sp_adjust_insn);\n-\n-\t  /* The insn rtx 'sp_adjust_insn' will change frame layout.\n-\t     We need to use RTX_FRAME_RELATED_P so that GCC is able to\n-\t     generate CFI (Call Frame Information) stuff.  */\n-\t  RTX_FRAME_RELATED_P (sp_adjust_insn) = 1;\n-\t}\n+      nds32_emit_adjust_frame (stack_pointer_rtx,\n+\t\t\t       stack_pointer_rtx,\n+\t\t\t       -1 * sp_adjust);\n     }\n \n   /* Prevent the instruction scheduler from\n@@ -3376,9 +3311,7 @@ void\n nds32_expand_epilogue_v3pop (bool sibcall_p)\n {\n   int sp_adjust;\n-\n-  rtx Rb, Re;\n-  rtx sp_adjust_insn;\n+  unsigned Rb, Re;\n \n   /* Compute and setup stack frame size.\n      The result will be in cfun->machine.  */\n@@ -3400,8 +3333,8 @@ nds32_expand_epilogue_v3pop (bool sibcall_p)\n     }\n \n   /* Get callee_first_regno and callee_last_regno.  */\n-  Rb = gen_rtx_REG (SImode, cfun->machine->callee_saved_first_gpr_regno);\n-  Re = gen_rtx_REG (SImode, cfun->machine->callee_saved_last_gpr_regno);\n+  Rb = cfun->machine->callee_saved_first_gpr_regno;\n+  Re = cfun->machine->callee_saved_last_gpr_regno;\n \n   /* Calculate sp_adjust first to test if 'pop25 Re,imm8u' is available,\n      where imm8u has to be 8-byte alignment.  */\n@@ -3423,10 +3356,8 @@ nds32_expand_epilogue_v3pop (bool sibcall_p)\n       /* We can use 'pop25 Re,imm8u'.  */\n \n       /* nds32_emit_stack_v3pop(last_regno, sp_adjust),\n-\t the pattern 'stack_v3pop' is implementad in nds32.md.\n-         The (const_int 14) means v3pop always pop { $fp $gp $lp }.  */\n-      nds32_emit_stack_v3pop (Rb, Re,\n-\t\t\t      GEN_INT (14), GEN_INT (sp_adjust));\n+\t the pattern 'stack_v3pop' is implementad in nds32.md.  */\n+      nds32_emit_stack_v3pop (Rb, Re, sp_adjust);\n     }\n   else\n     {\n@@ -3447,11 +3378,10 @@ nds32_expand_epilogue_v3pop (bool sibcall_p)\n \t\t      + cfun->machine->gp_size\n \t\t      + cfun->machine->lp_size\n \t\t      + cfun->machine->callee_saved_gpr_regs_size;\n-\t  sp_adjust_insn = gen_addsi3 (stack_pointer_rtx,\n-\t\t\t\t       hard_frame_pointer_rtx,\n-\t\t\t\t       GEN_INT (-1 * sp_adjust));\n-\t  /* Emit rtx into instructions list and receive INSN rtx form.  */\n-\t  sp_adjust_insn = emit_insn (sp_adjust_insn);\n+\n+\t  nds32_emit_adjust_frame (stack_pointer_rtx,\n+\t\t\t\t   hard_frame_pointer_rtx,\n+\t\t\t\t   -1 * sp_adjust);\n \t}\n       else\n \t{\n@@ -3463,31 +3393,22 @@ nds32_expand_epilogue_v3pop (bool sibcall_p)\n \t     so we have to deal with it as well.  */\n \n \t  /* Adjust $sp = $sp + local_size + out_args_size\n-\t\t\t      + callee_saved_area_gpr_padding_bytes.  */\n+                              + callee_saved_area_gpr_padding_bytes.  */\n \t  sp_adjust = cfun->machine->local_size\n \t\t      + cfun->machine->out_args_size\n \t\t      + cfun->machine->callee_saved_area_gpr_padding_bytes;\n-\t  /* sp_adjust value may be out of range of the addi instruction,\n-\t     create alternative add behavior with TA_REGNUM if necessary,\n-\t     using POSITIVE value to tell that we are increasing address.  */\n-\t  sp_adjust = nds32_force_addi_stack_int (sp_adjust);\n-\t  if (sp_adjust)\n-\t    {\n-\t      /* Generate sp adjustment instruction\n-\t\t if and only if sp_adjust != 0.  */\n-\t      sp_adjust_insn = gen_addsi3 (stack_pointer_rtx,\n-\t\t\t\t\t   stack_pointer_rtx,\n-\t\t\t\t\t   GEN_INT (sp_adjust));\n-\t      /* Emit rtx into instructions list and receive INSN rtx form.  */\n-\t      sp_adjust_insn = emit_insn (sp_adjust_insn);\n-\t    }\n+\t   /* sp_adjust value may be out of range of the addi instruction,\n+\t      create alternative add behavior with TA_REGNUM if necessary,\n+\t      using POSITIVE value to tell that we are increasing\n+\t      address.  */\n+\t  nds32_emit_adjust_frame (stack_pointer_rtx,\n+\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t   sp_adjust);\n \t}\n \n       /* nds32_emit_stack_v3pop(last_regno, sp_adjust),\n \t the pattern 'stack_v3pop' is implementad in nds32.md.  */\n-      /* The (const_int 14) means v3pop always pop { $fp $gp $lp }.  */\n-      nds32_emit_stack_v3pop (Rb, Re,\n-\t\t\t      GEN_INT (14), GEN_INT (0));\n+      nds32_emit_stack_v3pop (Rb, Re, 0);\n     }\n \n   /* Generate return instruction.  */"}, {"sha": "dc40735700a69549b954d503398fbf1c9627c75f", "filename": "gcc/config/nds32/nds32.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c7e7779ad2330a0e14c87ba0e339367679ed9e/gcc%2Fconfig%2Fnds32%2Fnds32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c7e7779ad2330a0e14c87ba0e339367679ed9e/gcc%2Fconfig%2Fnds32%2Fnds32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.h?ref=a6c7e7779ad2330a0e14c87ba0e339367679ed9e", "patch": "@@ -130,6 +130,10 @@ enum nds32_16bit_address_type\n /* Define the last integer register number.  */\n #define NDS32_LAST_GPR_REGNUM 31\n \n+#define NDS32_FIRST_CALLEE_SAVE_GPR_REGNUM 6\n+#define NDS32_LAST_CALLEE_SAVE_GPR_REGNUM \\\n+  (TARGET_REDUCED_REGS ? 10 : 14)\n+\n /* Define double word alignment bits.  */\n #define NDS32_DOUBLE_WORD_ALIGNMENT 64\n \n@@ -196,6 +200,19 @@ enum nds32_16bit_address_type\n #define NDS32_REQUIRED_CALLEE_SAVED_P(regno)                  \\\n   ((!call_used_regs[regno]) && (df_regs_ever_live_p (regno)))\n \n+/* This macro is to check if the push25/pop25 are available to be used\n+   for code generation.  Because pop25 also performs return behavior,\n+   the instructions may not be available for some cases.\n+   If we want to use push25/pop25, all the following conditions must\n+   be satisfied:\n+     1. TARGET_V3PUSH is set.\n+     2. Current function is not an ISR function.\n+     3. Current function is not a variadic function.*/\n+#define NDS32_V3PUSH_AVAILABLE_P  \\\n+  (TARGET_V3PUSH \\\n+   && !nds32_isr_function_p (current_function_decl) \\\n+   && (cfun->machine->va_args_size == 0))\n+\n /* ------------------------------------------------------------------------ */\n \n /* A C structure for machine-specific, per-function data."}, {"sha": "58a13c1abfd83227c44540e872ed75146865892d", "filename": "gcc/config/nds32/nds32.md", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c7e7779ad2330a0e14c87ba0e339367679ed9e/gcc%2Fconfig%2Fnds32%2Fnds32.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c7e7779ad2330a0e14c87ba0e339367679ed9e/gcc%2Fconfig%2Fnds32%2Fnds32.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.md?ref=a6c7e7779ad2330a0e14c87ba0e339367679ed9e", "patch": "@@ -2093,11 +2093,8 @@ create_template:\n   \"\"\n {\n   /* Note that only under V3/V3M ISA, we could use v3push prologue.\n-     In addition, we do not want to use v3push for isr function\n-     and variadic function.  */\n-  if (TARGET_V3PUSH\n-      && !nds32_isr_function_p (current_function_decl)\n-      && (cfun->machine->va_args_size == 0))\n+     In addition, we need to check if v3push is indeed available.  */\n+  if (NDS32_V3PUSH_AVAILABLE_P)\n     nds32_expand_prologue_v3push ();\n   else\n     nds32_expand_prologue ();\n@@ -2108,11 +2105,8 @@ create_template:\n   \"\"\n {\n   /* Note that only under V3/V3M ISA, we could use v3pop epilogue.\n-     In addition, we do not want to use v3pop for isr function\n-     and variadic function.  */\n-  if (TARGET_V3PUSH\n-      && !nds32_isr_function_p (current_function_decl)\n-      && (cfun->machine->va_args_size == 0))\n+     In addition, we need to check if v3push is indeed available.  */\n+  if (NDS32_V3PUSH_AVAILABLE_P)\n     nds32_expand_epilogue_v3pop (false);\n   else\n     nds32_expand_epilogue (false);\n@@ -2125,10 +2119,7 @@ create_template:\n   /* Pass true to indicate that this is sibcall epilogue and\n      exit from a function without the final branch back to the\n      calling function.  */\n-  if (TARGET_V3PUSH && !nds32_isr_function_p (current_function_decl))\n-    nds32_expand_epilogue_v3pop (true);\n-  else\n-    nds32_expand_epilogue (true);\n+  nds32_expand_epilogue (true);\n \n   DONE;\n })"}]}