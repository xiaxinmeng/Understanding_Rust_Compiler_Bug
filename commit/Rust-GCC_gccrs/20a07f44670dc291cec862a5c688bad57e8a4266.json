{"sha": "20a07f44670dc291cec862a5c688bad57e8a4266", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBhMDdmNDQ2NzBkYzI5MWNlYzg2MmE1YzY4OGJhZDU3ZThhNDI2Ng==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2009-03-28T00:43:26Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2009-03-28T00:43:26Z"}, "message": "genautomata.c: Add a new year to the copyright.\n\n2009-03-27  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* genautomata.c: Add a new year to the copyright.  Add a new\n\treference.\n\t(struct insn_reserv_decl): Add comments for member bypass_list.\n\t(find_bypass): Remove.\n\t(insert_bypass): New.\n\t(process_decls): Use insert_bypass.\n\t(output_internal_insn_latency_func): Output all bypasses with the\n\tsame input insn in one switch case.\n\n\t* rtl.def (define_bypass): Describe bypass choice.\n\t* doc/md.texi (define_bypass): Ditto.\n\nFrom-SVN: r145152", "tree": {"sha": "665f23f43ed41e7874cc2b369ea0e3f460aec4ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/665f23f43ed41e7874cc2b369ea0e3f460aec4ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20a07f44670dc291cec862a5c688bad57e8a4266", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20a07f44670dc291cec862a5c688bad57e8a4266", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20a07f44670dc291cec862a5c688bad57e8a4266", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20a07f44670dc291cec862a5c688bad57e8a4266/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b9605c6cd4ee61bec1db4883c798e526ce75d77c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9605c6cd4ee61bec1db4883c798e526ce75d77c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9605c6cd4ee61bec1db4883c798e526ce75d77c"}], "stats": {"total": 184, "additions": 123, "deletions": 61}, "files": [{"sha": "ad0c1f09c21d0e54bdafebcaac402ef15e2f80eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a07f44670dc291cec862a5c688bad57e8a4266/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a07f44670dc291cec862a5c688bad57e8a4266/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=20a07f44670dc291cec862a5c688bad57e8a4266", "patch": "@@ -1,3 +1,17 @@\n+2009-03-27  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* genautomata.c: Add a new year to the copyright.  Add a new\n+\treference.\n+\t(struct insn_reserv_decl): Add comments for member bypass_list.\n+\t(find_bypass): Remove.\n+\t(insert_bypass): New.\n+\t(process_decls): Use insert_bypass.\n+\t(output_internal_insn_latency_func): Output all bypasses with the\n+\tsame input insn in one switch case.\n+\n+\t* rtl.def (define_bypass): Describe bypass choice.\n+\t* doc/md.texi (define_bypass): Ditto.\n+\n 2009-03-27  Richard Guenther  <rguenther@suse.de>\n \n \t* gimplify.c (mark_addressable): Export."}, {"sha": "18a1a4df27d21ba0727113d8a62f4fe107ef5c26", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a07f44670dc291cec862a5c688bad57e8a4266/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a07f44670dc291cec862a5c688bad57e8a4266/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=20a07f44670dc291cec862a5c688bad57e8a4266", "patch": "@@ -7506,6 +7506,11 @@ be ignored for this case.  The additional guard is necessary to\n recognize complicated bypasses, e.g.@: when the consumer is only an address\n of insn @samp{store} (not a stored value).\n \n+If there are more one bypass with the same output and input insns, the\n+chosen bypass is the first bypass with a guard in description whose\n+guard function returns nonzero.  If there is no such bypass, then\n+bypass without the guard function is chosen.\n+\n @findex exclusion_set\n @findex presence_set\n @findex final_presence_set"}, {"sha": "1d742f4dcb69e1d14e60cf9fef5c53747ba32592", "filename": "gcc/genautomata.c", "status": "modified", "additions": 99, "deletions": 60, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a07f44670dc291cec862a5c688bad57e8a4266/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a07f44670dc291cec862a5c688bad57e8a4266/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=20a07f44670dc291cec862a5c688bad57e8a4266", "patch": "@@ -1,5 +1,5 @@\n /* Pipeline hazard description translator.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n \n    Written by Vladimir Makarov <vmakarov@redhat.com>\n@@ -22,21 +22,25 @@ along with GCC; see the file COPYING3.  If not see\n \n /* References:\n \n-   1. Detecting pipeline structural hazards quickly. T. Proebsting,\n+   1. The finite state automaton based pipeline hazard recognizer and\n+      instruction scheduler in GCC.  V. Makarov.  Proceedings of GCC\n+      summit, 2003.\n+\n+   2. Detecting pipeline structural hazards quickly. T. Proebsting,\n       C. Fraser. Proceedings of ACM SIGPLAN-SIGACT Symposium on\n       Principles of Programming Languages, pages 280--286, 1994.\n \n       This article is a good start point to understand usage of finite\n       state automata for pipeline hazard recognizers.  But I'd\n-      recommend the 2nd article for more deep understanding.\n+      recommend the 1st and 3rd article for more deep understanding.\n \n-   2. Efficient Instruction Scheduling Using Finite State Automata:\n+   3. Efficient Instruction Scheduling Using Finite State Automata:\n       V. Bala and N. Rubin, Proceedings of MICRO-28.  This is the best\n       article about usage of finite state automata for pipeline hazard\n       recognizers.\n \n-   The current implementation is different from the 2nd article in the\n-   following:\n+   The current implementation is described in the 1st article and it\n+   is different from the 3rd article in the following:\n \n    1. New operator `|' (alternative) is permitted in functional unit\n       reservation which can be treated deterministically and\n@@ -463,7 +467,10 @@ struct insn_reserv_decl\n      insn.  */\n   int insn_num;\n   /* The following field value is list of bypasses in which given insn\n-     is output insn.  */\n+     is output insn.  Bypasses with the same input insn stay one after\n+     another in the list in the same order as their occurrences in the\n+     description but the bypass without a guard stays always the last\n+     in a row of bypasses with the same input insn.  */\n   struct bypass_decl *bypass_list;\n \n   /* The following fields are defined by automaton generator.  */\n@@ -2367,18 +2374,67 @@ add_presence_absence (unit_set_el_t dest_list,\n }\n \n \n-/* The function searches for bypass with given IN_INSN_RESERV in given\n-   BYPASS_LIST.  */\n-static struct bypass_decl *\n-find_bypass (struct bypass_decl *bypass_list,\n-\t     struct insn_reserv_decl *in_insn_reserv)\n+/* The function inserts BYPASS in the list of bypasses of the\n+   corresponding output insn.  The order of bypasses in the list is\n+   decribed in a comment for member `bypass_list' (see above).  If\n+   there is already the same bypass in the list the function reports\n+   this and does nothing.  */\n+static void\n+insert_bypass (struct bypass_decl *bypass)\n {\n-  struct bypass_decl *bypass;\n-\n-  for (bypass = bypass_list; bypass != NULL; bypass = bypass->next)\n-    if (bypass->in_insn_reserv == in_insn_reserv)\n-      break;\n-  return bypass;\n+  struct bypass_decl *curr, *last;\n+  struct insn_reserv_decl *out_insn_reserv = bypass->out_insn_reserv;\n+  struct insn_reserv_decl *in_insn_reserv = bypass->in_insn_reserv;\n+  \n+  for (curr = out_insn_reserv->bypass_list, last = NULL;\n+       curr != NULL;\n+       last = curr, curr = curr->next)\n+    if (curr->in_insn_reserv == in_insn_reserv)\n+      {\n+\tif ((bypass->bypass_guard_name != NULL\n+\t     && curr->bypass_guard_name != NULL\n+\t     && ! strcmp (bypass->bypass_guard_name, curr->bypass_guard_name))\n+\t    || bypass->bypass_guard_name == curr->bypass_guard_name)\n+\t  {\n+\t    if (bypass->bypass_guard_name == NULL)\n+\t      {\n+\t\tif (!w_flag)\n+\t\t  error (\"the same bypass `%s - %s' is already defined\",\n+\t\t\t bypass->out_insn_name, bypass->in_insn_name);\n+\t\telse\n+\t\t  warning (0, \"the same bypass `%s - %s' is already defined\",\n+\t\t\t   bypass->out_insn_name, bypass->in_insn_name);\n+\t      }\n+\t    else if (!w_flag)\n+\t      error (\"the same bypass `%s - %s' (guard %s) is already defined\",\n+\t\t     bypass->out_insn_name, bypass->in_insn_name,\n+\t\t     bypass->bypass_guard_name);\n+\t    else\n+\t      warning\n+\t\t(0, \"the same bypass `%s - %s' (guard %s) is already defined\",\n+\t\t bypass->out_insn_name, bypass->in_insn_name,\n+\t\t bypass->bypass_guard_name);\n+\t    return;\n+\t  }\n+\tif (curr->bypass_guard_name == NULL)\n+\t  break;\n+\tif (curr->next == NULL || curr->next->in_insn_reserv != in_insn_reserv)\n+\t  {\n+\t    last = curr;\n+\t    break;\n+\t  }\n+\t  \n+      }\n+  if (last == NULL)\n+    {\n+      bypass->next = out_insn_reserv->bypass_list;\n+      out_insn_reserv->bypass_list = bypass;\n+    }\n+  else\n+    {\n+      bypass->next = last->next;\n+      last->next = bypass;\n+    }\n }\n \n /* The function processes pipeline description declarations, checks\n@@ -2391,7 +2447,6 @@ process_decls (void)\n   decl_t decl_in_table;\n   decl_t out_insn_reserv;\n   decl_t in_insn_reserv;\n-  struct bypass_decl *bypass;\n   int automaton_presence;\n   int i;\n \n@@ -2514,36 +2569,7 @@ process_decls (void)\n \t\t= DECL_INSN_RESERV (out_insn_reserv);\n \t      DECL_BYPASS (decl)->in_insn_reserv\n \t\t= DECL_INSN_RESERV (in_insn_reserv);\n-\t      bypass\n-\t\t= find_bypass (DECL_INSN_RESERV (out_insn_reserv)->bypass_list,\n-\t\t\t       DECL_BYPASS (decl)->in_insn_reserv);\n-\t      if (bypass != NULL)\n-\t\t{\n-\t\t  if (DECL_BYPASS (decl)->latency == bypass->latency)\n-\t\t    {\n-\t\t      if (!w_flag)\n-\t\t\terror\n-\t\t\t  (\"the same bypass `%s - %s' is already defined\",\n-\t\t\t   DECL_BYPASS (decl)->out_insn_name,\n-\t\t\t   DECL_BYPASS (decl)->in_insn_name);\n-\t\t      else\n-\t\t\twarning\n-\t\t\t  (0, \"the same bypass `%s - %s' is already defined\",\n-\t\t\t   DECL_BYPASS (decl)->out_insn_name,\n-\t\t\t   DECL_BYPASS (decl)->in_insn_name);\n-\t\t    }\n-\t\t  else\n-\t\t    error (\"bypass `%s - %s' is already defined\",\n-\t\t\t   DECL_BYPASS (decl)->out_insn_name,\n-\t\t\t   DECL_BYPASS (decl)->in_insn_name);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  DECL_BYPASS (decl)->next\n-\t\t    = DECL_INSN_RESERV (out_insn_reserv)->bypass_list;\n-\t\t  DECL_INSN_RESERV (out_insn_reserv)->bypass_list\n-\t\t    = DECL_BYPASS (decl);\n-\t\t}\n+\t      insert_bypass (DECL_BYPASS (decl));\n \t    }\n \t}\n     }\n@@ -8159,19 +8185,32 @@ output_internal_insn_latency_func (void)\n \t\t\t    (advance_cycle_insn_decl)->insn_num));\n \t    fprintf (output_file, \"        case %d:\\n\",\n \t\t     bypass->in_insn_reserv->insn_num);\n-\t    if (bypass->bypass_guard_name == NULL)\n-\t      fprintf (output_file, \"          return %d;\\n\",\n-\t\t       bypass->latency);\n-\t    else\n+\t    for (;;)\n \t      {\n-\t\tfprintf (output_file,\n-\t\t\t \"          if (%s (%s, %s))\\n\",\n-\t\t\t bypass->bypass_guard_name, INSN_PARAMETER_NAME,\n-\t\t\t INSN2_PARAMETER_NAME);\n-\t\tfprintf (output_file,\n-\t\t\t \"            return %d;\\n          break;\\n\",\n-\t\t\t bypass->latency);\n+\t\tif (bypass->bypass_guard_name == NULL)\n+\t\t  {\n+\t\t    gcc_assert (bypass->next == NULL\n+\t\t\t\t|| (bypass->in_insn_reserv\n+\t\t\t\t    != bypass->next->in_insn_reserv));\n+\t\t    fprintf (output_file, \"          return %d;\\n\",\n+\t\t\t     bypass->latency);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    fprintf (output_file,\n+\t\t\t     \"          if (%s (%s, %s))\\n\",\n+\t\t\t     bypass->bypass_guard_name, INSN_PARAMETER_NAME,\n+\t\t\t     INSN2_PARAMETER_NAME);\n+\t\t    fprintf (output_file, \"            return %d;\\n\",\n+\t\t\t     bypass->latency);\n+\t\t  }\n+\t\tif (bypass->next == NULL\n+\t\t    || bypass->in_insn_reserv != bypass->next->in_insn_reserv)\n+\t\t  break;\n+\t\tbypass = bypass->next;\n \t      }\n+\t    if (bypass->bypass_guard_name != NULL)\n+\t      fprintf (output_file, \"          break;\\n\");\n \t  }\n \tfputs (\"        }\\n      break;\\n\", output_file);\n       }"}, {"sha": "662a9f0c8b79c10a977c86cdb619a7e7e88e80ad", "filename": "gcc/rtl.def", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a07f44670dc291cec862a5c688bad57e8a4266/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a07f44670dc291cec862a5c688bad57e8a4266/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=20a07f44670dc291cec862a5c688bad57e8a4266", "patch": "@@ -1088,7 +1088,11 @@ DEF_RTL_EXPR(FINAL_ABSENCE_SET, \"final_absence_set\", \"ss\", RTX_EXTRA)\n    guard for the bypass.  The function will get the two insns as\n    parameters.  If the function returns zero the bypass will be\n    ignored for this case.  Additional guard is necessary to recognize\n-   complicated bypasses, e.g. when consumer is load address.  */\n+   complicated bypasses, e.g. when consumer is load address.  If there\n+   are more one bypass with the same output and input insns, the\n+   chosen bypass is the first bypass with a guard in description whose\n+   guard function returns nonzero.  If there is no such bypass, then\n+   bypass without the guard function is chosen.  */\n DEF_RTL_EXPR(DEFINE_BYPASS, \"define_bypass\", \"issS\", RTX_EXTRA)\n \n /* (define_automaton string) describes names of automata generated and"}]}