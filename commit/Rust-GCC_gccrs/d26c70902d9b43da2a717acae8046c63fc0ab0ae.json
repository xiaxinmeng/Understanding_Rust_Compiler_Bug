{"sha": "d26c70902d9b43da2a717acae8046c63fc0ab0ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI2YzcwOTAyZDliNDNkYTJhNzE3YWNhZTgwNDZjNjNmYzBhYjBhZQ==", "commit": {"author": {"name": "Easwaran Raman", "email": "eraman@google.com", "date": "2011-06-14T22:58:20Z"}, "committer": {"name": "Easwaran Raman", "email": "eraman@gcc.gnu.org", "date": "2011-06-14T22:58:20Z"}, "message": "re PR rtl-optimization/44194 (struct returned by value generates useless stores)\n\n2011-06-14  Easwaran Raman  <eraman@google.com>\n\n       PR rtl-optimization/44194\n       * dse.c: Include tree-flow.h\n       (insn_info): Add new field non_frame_wild_read.\n       (group_info): Add new fields escaped_n and escaped_p.\n       (kill_on_calls): New variable.\n       (get_group_info): Initialize gi->escaped_n and gi->escaped_p.\n       (dse_step0): Initialize kill_on_calls.\n       (can_escape): New function.\n       (set_usage_bits): Add additional parameter; record information\n       about escaped locations.\n       (record_store): Pass EXPR corresponding to MEM to\n       set_usage_bits.\n       (dse_step2_nospill): Set kill_on_calls based on\n       group->escaped_n and group->escaped_n.\n       (add_wild_read): Refactor into...\n       (reset_active_stores): ... New method, and\n       (free_read_records): ... New method.\n       (add_non_frame_wild_read): New method.\n       (scan_insn): Call add_non_frame_wild_read on non-const calls.\n       (scan_reads_nospill): Handle instructions with\n       non_frame_wild_read.\n       (dse_step5_nospill): Call scan_reads_nospill for instructions\n       marked as non_frame_wild_read.\n       (dse_step7): Free escaped_n, escaped_p and kill_on_calls\n       bitmaps.\n\ntestsuite/ChangeLog\n\n2011-06-14  Easwaran Raman  <eraman@google.com>\n\n       PR rtl-optimization/44194\n       * gcc.dg/pr44194-1.c: New test.\n       * gcc.dg/pr44194-2.c: New test.\n\nFrom-SVN: r175063", "tree": {"sha": "662b41a9892d0c4bf66e9033dbc6f4d7251dc841", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/662b41a9892d0c4bf66e9033dbc6f4d7251dc841"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d26c70902d9b43da2a717acae8046c63fc0ab0ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d26c70902d9b43da2a717acae8046c63fc0ab0ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d26c70902d9b43da2a717acae8046c63fc0ab0ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d26c70902d9b43da2a717acae8046c63fc0ab0ae/comments", "author": null, "committer": null, "parents": [{"sha": "d2393b3adbf064b100eab5050278d71302ce7d1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2393b3adbf064b100eab5050278d71302ce7d1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2393b3adbf064b100eab5050278d71302ce7d1d"}], "stats": {"total": 179, "additions": 163, "deletions": 16}, "files": [{"sha": "ad5664b19a8996435ea1e351c907a88f57f57a0a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d26c70902d9b43da2a717acae8046c63fc0ab0ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d26c70902d9b43da2a717acae8046c63fc0ab0ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d26c70902d9b43da2a717acae8046c63fc0ab0ae", "patch": "@@ -1,3 +1,31 @@\n+2011-06-14  Easwaran Raman  <eraman@google.com>\n+\n+\tPR rtl-optimization/44194\n+\t* dse.c: Include tree-flow.h\n+\t(insn_info): Add new field non_frame_wild_read.\n+\t(group_info): Add new fields escaped_n and escaped_p.\n+\t(kill_on_calls): New variable.\n+\t(get_group_info): Initialize gi->escaped_n and gi->escaped_p.\n+\t(dse_step0): Initialize kill_on_calls.\n+\t(can_escape): New function.\n+\t(set_usage_bits): Add additional parameter; record information\n+\tabout escaped locations.\n+\t(record_store): Pass EXPR corresponding to MEM to\n+\tset_usage_bits.\n+\t(dse_step2_nospill): Set kill_on_calls based on\n+\tgroup->escaped_n and group->escaped_n.\n+\t(add_wild_read): Refactor into...\n+\t(reset_active_stores): ... New function, and\n+\t(free_read_records): ... New function.\n+\t(add_non_frame_wild_read): New function.\n+\t(scan_insn): Call add_non_frame_wild_read on non-const calls.\n+\t(scan_reads_nospill): Handle instructions with\n+\tnon_frame_wild_read.\n+\t(dse_step5_nospill): Call scan_reads_nospill for instructions\n+\tmarked as non_frame_wild_read.\n+\t(dse_step7): Free escaped_n, escaped_p and kill_on_calls\n+\tbitmaps.\n+\n 2011-06-14  Joseph Myers  <joseph@codesourcery.com>\n \n \t* common/common-target-def.h, common/common-target.def,"}, {"sha": "b6c9a384fe16966640086fc9ae348efe0f02687b", "filename": "gcc/dse.c", "status": "modified", "additions": 103, "deletions": 16, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d26c70902d9b43da2a717acae8046c63fc0ab0ae/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d26c70902d9b43da2a717acae8046c63fc0ab0ae/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=d26c70902d9b43da2a717acae8046c63fc0ab0ae", "patch": "@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dbgcnt.h\"\n #include \"target.h\"\n #include \"params.h\"\n+#include \"tree-flow.h\"\n \n /* This file contains three techniques for performing Dead Store\n    Elimination (dse).\n@@ -326,6 +327,11 @@ struct insn_info\n      contains a wild read, the use_rec will be null.  */\n   bool wild_read;\n \n+  /* This is true only for CALL instructions which could potentially read\n+     any non-frame memory location. This field is used by the global\n+     algorithm.  */\n+  bool non_frame_wild_read;\n+\n   /* This field is only used for the processing of const functions.\n      These functions cannot read memory, but they can read the stack\n      because that is where they may get their parms.  We need to be\n@@ -501,6 +507,11 @@ struct group_info\n      deleted.  */\n   bitmap store1_n, store1_p, store2_n, store2_p;\n \n+  /* These bitmaps keep track of offsets in this group escape this function.\n+     An offset escapes if it corresponds to a named variable whose\n+     addressable flag is set.  */\n+  bitmap escaped_n, escaped_p;\n+\n   /* The positions in this bitmap have the same assignments as the in,\n      out, gen and kill bitmaps.  This bitmap is all zeros except for\n      the positions that are occupied by stores for this group.  */\n@@ -588,6 +599,9 @@ static int spill_deleted;\n \n static bitmap all_blocks;\n \n+/* Locations that are killed by calls in the global phase.  */\n+static bitmap kill_on_calls;\n+\n /* The number of bits used in the global bitmaps.  */\n static unsigned int current_position;\n \n@@ -692,6 +706,8 @@ get_group_info (rtx base)\n \t  gi->store1_p = BITMAP_ALLOC (NULL);\n \t  gi->store2_n = BITMAP_ALLOC (NULL);\n \t  gi->store2_p = BITMAP_ALLOC (NULL);\n+\t  gi->escaped_p = BITMAP_ALLOC (NULL);\n+\t  gi->escaped_n = BITMAP_ALLOC (NULL);\n \t  gi->group_kill = BITMAP_ALLOC (NULL);\n \t  gi->process_globally = false;\n \t  gi->offset_map_size_n = 0;\n@@ -714,6 +730,8 @@ get_group_info (rtx base)\n       gi->store1_p = BITMAP_ALLOC (NULL);\n       gi->store2_n = BITMAP_ALLOC (NULL);\n       gi->store2_p = BITMAP_ALLOC (NULL);\n+      gi->escaped_p = BITMAP_ALLOC (NULL);\n+      gi->escaped_n = BITMAP_ALLOC (NULL);\n       gi->group_kill = BITMAP_ALLOC (NULL);\n       gi->process_globally = false;\n       gi->frame_related =\n@@ -739,6 +757,7 @@ dse_step0 (void)\n   spill_deleted = 0;\n \n   scratch = BITMAP_ALLOC (NULL);\n+  kill_on_calls = BITMAP_ALLOC (NULL);\n \n   rtx_store_info_pool\n     = create_alloc_pool (\"rtx_store_info_pool\",\n@@ -881,31 +900,48 @@ delete_dead_store_insn (insn_info_t insn_info)\n   insn_info->wild_read = false;\n }\n \n+/* Check if EXPR can possibly escape the current function scope.  */\n+static bool\n+can_escape (tree expr)\n+{\n+  tree base;\n+  if (!expr)\n+    return true;\n+  base = get_base_address (expr);\n+  if (DECL_P (base)\n+      && !may_be_aliased (base))\n+    return false;\n+  return true;\n+}\n \n /* Set the store* bitmaps offset_map_size* fields in GROUP based on\n    OFFSET and WIDTH.  */\n \n static void\n-set_usage_bits (group_info_t group, HOST_WIDE_INT offset, HOST_WIDE_INT width)\n+set_usage_bits (group_info_t group, HOST_WIDE_INT offset, HOST_WIDE_INT width,\n+                tree expr)\n {\n   HOST_WIDE_INT i;\n-\n+  bool expr_escapes = can_escape (expr);\n   if (offset > -MAX_OFFSET && offset + width < MAX_OFFSET)\n     for (i=offset; i<offset+width; i++)\n       {\n \tbitmap store1;\n \tbitmap store2;\n+        bitmap escaped;\n \tint ai;\n \tif (i < 0)\n \t  {\n \t    store1 = group->store1_n;\n \t    store2 = group->store2_n;\n+\t    escaped = group->escaped_n;\n \t    ai = -i;\n \t  }\n \telse\n \t  {\n \t    store1 = group->store1_p;\n \t    store2 = group->store2_p;\n+\t    escaped = group->escaped_p;\n \t    ai = i;\n \t  }\n \n@@ -924,34 +960,60 @@ set_usage_bits (group_info_t group, HOST_WIDE_INT offset, HOST_WIDE_INT width)\n \t\t  group->offset_map_size_p = ai;\n \t      }\n \t  }\n+        if (expr_escapes)\n+          bitmap_set_bit (escaped, ai);\n       }\n }\n \n+static void\n+reset_active_stores (void)\n+{\n+  active_local_stores = NULL;\n+  active_local_stores_len = 0;\n+}\n \n-/* Set the BB_INFO so that the last insn is marked as a wild read.  */\n+/* Free all READ_REC of the LAST_INSN of BB_INFO.  */\n \n static void\n-add_wild_read (bb_info_t bb_info)\n+free_read_records (bb_info_t bb_info)\n {\n   insn_info_t insn_info = bb_info->last_insn;\n   read_info_t *ptr = &insn_info->read_rec;\n-\n   while (*ptr)\n     {\n       read_info_t next = (*ptr)->next;\n       if ((*ptr)->alias_set == 0)\n         {\n           pool_free (read_info_pool, *ptr);\n           *ptr = next;\n-\t}\n+        }\n       else\n-\tptr = &(*ptr)->next;\n+        ptr = &(*ptr)->next;\n     }\n+}\n+\n+/* Set the BB_INFO so that the last insn is marked as a wild read.  */\n+\n+static void\n+add_wild_read (bb_info_t bb_info)\n+{\n+  insn_info_t insn_info = bb_info->last_insn;\n   insn_info->wild_read = true;\n-  active_local_stores = NULL;\n-  active_local_stores_len = 0;\n+  free_read_records (bb_info);\n+  reset_active_stores ();\n }\n \n+/* Set the BB_INFO so that the last insn is marked as a wild read of\n+   non-frame locations.  */\n+\n+static void\n+add_non_frame_wild_read (bb_info_t bb_info)\n+{\n+  insn_info_t insn_info = bb_info->last_insn;\n+  insn_info->non_frame_wild_read = true;\n+  free_read_records (bb_info);\n+  reset_active_stores ();\n+}\n \n /* Return true if X is a constant or one of the registers that behave\n    as a constant over the life of a function.  This is equivalent to\n@@ -1355,9 +1417,10 @@ record_store (rtx body, bb_info_t bb_info)\n \n       group_info_t group\n \t= VEC_index (group_info_t, rtx_group_vec, group_id);\n+      tree expr = MEM_EXPR (mem);\n \n       store_info = (store_info_t) pool_alloc (rtx_store_info_pool);\n-      set_usage_bits (group, offset, width);\n+      set_usage_bits (group, offset, width, expr);\n \n       if (dump_file)\n \tfprintf (dump_file, \" processing const base store gid=%d[%d..%d)\\n\",\n@@ -2474,8 +2537,9 @@ scan_insn (bb_info_t bb_info, rtx insn)\n \t}\n \n       else\n-\t/* Every other call, including pure functions, may read memory.  */\n-\tadd_wild_read (bb_info);\n+\t/* Every other call, including pure functions, may read any memory\n+           that is not relative to the frame.  */\n+        add_non_frame_wild_read (bb_info);\n \n       return;\n     }\n@@ -2788,7 +2852,6 @@ dse_step2_nospill (void)\n   /* Position 0 is unused because 0 is used in the maps to mean\n      unused.  */\n   current_position = 1;\n-\n   FOR_EACH_VEC_ELT (group_info_t, rtx_group_vec, i, group)\n     {\n       bitmap_iterator bi;\n@@ -2804,12 +2867,16 @@ dse_step2_nospill (void)\n       EXECUTE_IF_SET_IN_BITMAP (group->store2_n, 0, j, bi)\n \t{\n \t  bitmap_set_bit (group->group_kill, current_position);\n+          if (bitmap_bit_p (group->escaped_n, j))\n+\t    bitmap_set_bit (kill_on_calls, current_position);\n \t  group->offset_map_n[j] = current_position++;\n \t  group->process_globally = true;\n \t}\n       EXECUTE_IF_SET_IN_BITMAP (group->store2_p, 0, j, bi)\n \t{\n \t  bitmap_set_bit (group->group_kill, current_position);\n+          if (bitmap_bit_p (group->escaped_p, j))\n+\t    bitmap_set_bit (kill_on_calls, current_position);\n \t  group->offset_map_p[j] = current_position++;\n \t  group->process_globally = true;\n \t}\n@@ -3040,7 +3107,21 @@ scan_reads_nospill (insn_info_t insn_info, bitmap gen, bitmap kill)\n \t    bitmap_and_compl_into (gen, group->group_kill);\n \t  }\n     }\n-\n+  if (insn_info->non_frame_wild_read)\n+    {\n+      /* Kill all non-frame related stores.  Kill all stores of variables that\n+         escape.  */\n+      if (kill)\n+        bitmap_ior_into (kill, kill_on_calls);\n+      bitmap_and_compl_into (gen, kill_on_calls);\n+      FOR_EACH_VEC_ELT (group_info_t, rtx_group_vec, i, group)\n+\tif (group->process_globally && !group->frame_related)\n+\t  {\n+\t    if (kill)\n+\t      bitmap_ior_into (kill, group->group_kill);\n+\t    bitmap_and_compl_into (gen, group->group_kill);\n+\t  }\n+    }\n   while (read_info)\n     {\n       FOR_EACH_VEC_ELT (group_info_t, rtx_group_vec, i, group)\n@@ -3564,10 +3645,13 @@ dse_step5_nospill (void)\n \t\t    fprintf (dump_file, \"wild read\\n\");\n \t\t  bitmap_clear (v);\n \t\t}\n-\t      else if (insn_info->read_rec)\n+\t      else if (insn_info->read_rec\n+                       || insn_info->non_frame_wild_read)\n \t\t{\n-\t\t  if (dump_file)\n+\t\t  if (dump_file && !insn_info->non_frame_wild_read)\n \t\t    fprintf (dump_file, \"regular read\\n\");\n+                  else if (dump_file)\n+\t\t    fprintf (dump_file, \"non-frame wild read\\n\");\n \t\t  scan_reads_nospill (insn_info, v, NULL);\n \t\t}\n \t    }\n@@ -3716,6 +3800,8 @@ dse_step7 (bool global_done)\n       BITMAP_FREE (group->store1_p);\n       BITMAP_FREE (group->store2_n);\n       BITMAP_FREE (group->store2_p);\n+      BITMAP_FREE (group->escaped_n);\n+      BITMAP_FREE (group->escaped_p);\n       BITMAP_FREE (group->group_kill);\n     }\n \n@@ -3746,6 +3832,7 @@ dse_step7 (bool global_done)\n   VEC_free (group_info_t, heap, rtx_group_vec);\n   BITMAP_FREE (all_blocks);\n   BITMAP_FREE (scratch);\n+  BITMAP_FREE (kill_on_calls);\n \n   free_alloc_pool (rtx_store_info_pool);\n   free_alloc_pool (read_info_pool);"}, {"sha": "cecd85bc3f4b7915ba88693ac426a4b9063999c0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d26c70902d9b43da2a717acae8046c63fc0ab0ae/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d26c70902d9b43da2a717acae8046c63fc0ab0ae/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d26c70902d9b43da2a717acae8046c63fc0ab0ae", "patch": "@@ -1,3 +1,9 @@\n+2011-06-14  Easwaran Raman  <eraman@google.com>\n+\n+\tPR rtl-optimization/44194\n+\t* gcc.dg/pr44194-1.c: New test.\n+\t* gcc.dg/pr44194-2.c: New test.\n+\n 2011-06-14  Janis Johnson  <janisjo@codesourcery.com>\n \n \t* gcc.target/arm/pr45701-1.c: Ignore warnings about conflicting switches."}, {"sha": "a03aa5a3508a73a94309acc35903d376f9da8e33", "filename": "gcc/testsuite/gcc.dg/pr44194-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d26c70902d9b43da2a717acae8046c63fc0ab0ae/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44194-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d26c70902d9b43da2a717acae8046c63fc0ab0ae/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44194-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44194-1.c?ref=d26c70902d9b43da2a717acae8046c63fc0ab0ae", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-rtl-dse1\" } */\n+#include <stdint.h>\n+\n+struct ints { int a, b, c; } foo();\n+void bar(int a, int b);\n+\n+void func() {\n+  struct ints s = foo();\n+  bar(s.a, s.b);\n+}\n+/* { dg-final { scan-rtl-dump \"global deletions = 2\"  \"dse1\" } } */\n+/* { dg-final { cleanup-rtl-dump \"dse1\" } } */"}, {"sha": "3548542c40f5cc2942548cc9a42bba0b4e8a14e0", "filename": "gcc/testsuite/gcc.dg/pr44194-2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d26c70902d9b43da2a717acae8046c63fc0ab0ae/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44194-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d26c70902d9b43da2a717acae8046c63fc0ab0ae/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44194-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44194-2.c?ref=d26c70902d9b43da2a717acae8046c63fc0ab0ae", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-rtl-dse1\" } */\n+#include <stdint.h>\n+\n+struct ints { int a, b, c; } foo();\n+void bar(int a, int b);\n+\n+void func() {\n+  volatile struct ints s = foo();\n+  bar(s.a, s.b);\n+}\n+/* { dg-final { scan-rtl-dump \"global deletions = 0\"  \"dse1\" } } */\n+/* { dg-final { cleanup-rtl-dump \"dse1\" } } */"}]}