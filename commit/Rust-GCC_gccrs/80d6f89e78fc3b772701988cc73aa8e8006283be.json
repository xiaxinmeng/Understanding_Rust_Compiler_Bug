{"sha": "80d6f89e78fc3b772701988cc73aa8e8006283be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBkNmY4OWU3OGZjM2I3NzI3MDE5ODhjYzczYWE4ZTgwMDYyODNiZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-06-04T11:44:58Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-06-05T06:35:44Z"}, "message": "middle-end/95493 - bogus MEM_ATTRS for variable array access\n\nThe following patch avoids keeping the inherited MEM_ATTRS when\nset_mem_attributes_minus_bitpos is called with a variable ARRAY_REF.\nThe inherited ones may not reflect the correct offset and neither\ndoes the updated alias-set match the inherited MEM_EXPR.  This all\nends up confusing path-based alias-analysis, causing wrong-code.\n\nThe fix is to stop not adopting a MEM_EXPR for certain kinds of\nexpressions and instead handle everything we can.  There's still\nthe constant kind trees case which I'm too lazy to look into right\nnow.  I did refrain from adding SSA_NAME there and instead avoided\ncalling set_mem_attributes_minus_bitpos when debug expression\nexpansion ended up expanding a SSA definition RHS which should\nalready have taken care of setting the appropriate MEM_ATTRS.\n\n2020-06-04  Richard Biener  <rguenther@suse.de>\n\n\tPR middle-end/95493\n\t* cfgexpand.c (expand_debug_expr): Avoid calling\n\tset_mem_attributes_minus_bitpos when we were expanding\n\tan SSA name.\n\t* emit-rtl.c (set_mem_attributes_minus_bitpos): Remove\n\tARRAY_REF special-casing, add CONSTRUCTOR to the set of\n\tspecial-cases we do not want MEM_EXPRs for.  Assert\n\twe end up with reasonable MEM_EXPRs.\n\n\t* g++.dg/torture/pr95493.C: New testcase.", "tree": {"sha": "fe41e78187e7dc97dbb204546c0e8572c1f944ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe41e78187e7dc97dbb204546c0e8572c1f944ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80d6f89e78fc3b772701988cc73aa8e8006283be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80d6f89e78fc3b772701988cc73aa8e8006283be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80d6f89e78fc3b772701988cc73aa8e8006283be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80d6f89e78fc3b772701988cc73aa8e8006283be/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c6931a353a6c41b2c9eb4bd2abec540104e940f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c6931a353a6c41b2c9eb4bd2abec540104e940f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c6931a353a6c41b2c9eb4bd2abec540104e940f"}], "stats": {"total": 128, "additions": 73, "deletions": 55}, "files": [{"sha": "b270a4ddb9db469ba52e42f36a1bc2f02d8f03fc", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80d6f89e78fc3b772701988cc73aa8e8006283be/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80d6f89e78fc3b772701988cc73aa8e8006283be/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=80d6f89e78fc3b772701988cc73aa8e8006283be", "patch": "@@ -4616,7 +4616,8 @@ expand_debug_expr (tree exp)\n \t      op0 = copy_rtx (op0);\n \t    if (op0 == orig_op0)\n \t      op0 = shallow_copy_rtx (op0);\n-\t    set_mem_attributes (op0, exp, 0);\n+\t    if (TREE_CODE (tem) != SSA_NAME)\n+\t      set_mem_attributes (op0, exp, 0);\n \t  }\n \n \tif (known_eq (bitpos, 0) && mode == GET_MODE (op0))"}, {"sha": "f9b0e9714d9e5c8b11a0d16a81d1d9609aba90eb", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 9, "deletions": 54, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80d6f89e78fc3b772701988cc73aa8e8006283be/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80d6f89e78fc3b772701988cc73aa8e8006283be/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=80d6f89e78fc3b772701988cc73aa8e8006283be", "patch": "@@ -2067,8 +2067,10 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t  new_size = DECL_SIZE_UNIT (t);\n \t}\n \n-      /* ???  If we end up with a constant here do record a MEM_EXPR.  */\n-      else if (CONSTANT_CLASS_P (t))\n+      /* ???  If we end up with a constant or a descriptor do not\n+\t record a MEM_EXPR.  */\n+      else if (CONSTANT_CLASS_P (t)\n+\t       || TREE_CODE (t) == CONSTRUCTOR)\n \t;\n \n       /* If this is a field reference, record it.  */\n@@ -2082,59 +2084,12 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t    new_size = DECL_SIZE_UNIT (TREE_OPERAND (t, 1));\n \t}\n \n-      /* If this is an array reference, look for an outer field reference.  */\n-      else if (TREE_CODE (t) == ARRAY_REF)\n-\t{\n-\t  tree off_tree = size_zero_node;\n-\t  /* We can't modify t, because we use it at the end of the\n-\t     function.  */\n-\t  tree t2 = t;\n-\n-\t  do\n-\t    {\n-\t      tree index = TREE_OPERAND (t2, 1);\n-\t      tree low_bound = array_ref_low_bound (t2);\n-\t      tree unit_size = array_ref_element_size (t2);\n-\n-\t      /* We assume all arrays have sizes that are a multiple of a byte.\n-\t\t First subtract the lower bound, if any, in the type of the\n-\t\t index, then convert to sizetype and multiply by the size of\n-\t\t the array element.  */\n-\t      if (! integer_zerop (low_bound))\n-\t\tindex = fold_build2 (MINUS_EXPR, TREE_TYPE (index),\n-\t\t\t\t     index, low_bound);\n-\n-\t      off_tree = size_binop (PLUS_EXPR,\n-\t\t\t\t     size_binop (MULT_EXPR,\n-\t\t\t\t\t\t fold_convert (sizetype,\n-\t\t\t\t\t\t\t       index),\n-\t\t\t\t\t\t unit_size),\n-\t\t\t\t     off_tree);\n-\t      t2 = TREE_OPERAND (t2, 0);\n-\t    }\n-\t  while (TREE_CODE (t2) == ARRAY_REF);\n-\n-\t  if (DECL_P (t2)\n-\t      || (TREE_CODE (t2) == COMPONENT_REF\n-\t\t  /* For trailing arrays t2 doesn't have a size that\n-\t\t     covers all valid accesses.  */\n-\t\t  && ! array_at_struct_end_p (t)))\n-\t    {\n-\t      attrs.expr = t2;\n-\t      attrs.offset_known_p = false;\n-\t      if (poly_int_tree_p (off_tree, &attrs.offset))\n-\t\t{\n-\t\t  attrs.offset_known_p = true;\n-\t\t  apply_bitpos = bitpos;\n-\t\t}\n-\t    }\n-\t  /* Else do not record a MEM_EXPR.  */\n-\t}\n-\n-      /* If this is an indirect reference, record it.  */\n-      else if (TREE_CODE (t) == MEM_REF \n-\t       || TREE_CODE (t) == TARGET_MEM_REF)\n+      /* Else record it.  */\n+      else\n \t{\n+\t  gcc_assert (handled_component_p (t)\n+\t\t      || TREE_CODE (t) == MEM_REF\n+\t\t      || TREE_CODE (t) == TARGET_MEM_REF);\n \t  attrs.expr = t;\n \t  attrs.offset_known_p = true;\n \t  attrs.offset = 0;"}, {"sha": "5e05056854dc6105388517eb62a587e713936622", "filename": "gcc/testsuite/g++.dg/torture/pr95493.C", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80d6f89e78fc3b772701988cc73aa8e8006283be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr95493.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80d6f89e78fc3b772701988cc73aa8e8006283be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr95493.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr95493.C?ref=80d6f89e78fc3b772701988cc73aa8e8006283be", "patch": "@@ -0,0 +1,62 @@\n+// { dg-do run }\n+// { dg-additional-options \"-std=c++17\" }\n+\n+struct verify\n+{\n+  const bool m_failed = false;\n+\n+  [[gnu::noinline]] void print_hex(const void* x, int n) const\n+  {\n+    const auto* bytes = static_cast<const unsigned char*>(x);\n+    for (int i = 0; i < n; ++i)\n+      __builtin_printf((i && i % 4 == 0) ? \"'%02x\" : \"%02x\", bytes[i]);\n+    __builtin_printf(\"\\n\");\n+  }\n+\n+  template <typename... Ts>\n+  verify(bool ok, const Ts&... extra_info) : m_failed(!ok)\n+  {\n+    if (m_failed)\n+      (print_hex(&extra_info, sizeof(extra_info)), ...);\n+  }\n+\n+  ~verify()\n+  {\n+    if (m_failed)\n+      __builtin_abort();\n+  }\n+};\n+\n+using K [[gnu::vector_size(16)]] = int;\n+\n+int\n+main()\n+{\n+  int count = 1;\n+  asm(\"\" : \"+m\"(count));\n+  verify(count == 1, 0, \"\", 0);\n+\n+  {\n+    struct SW\n+    {\n+      K d;\n+    };\n+    struct\n+    {\n+      SW d;\n+    } xx;\n+    SW& x = xx.d;\n+    x = SW(); // [0, 0, 0, 0]\n+    for (int i = 3; i >= 2; --i)\n+      {\n+        x.d[i] = -1; // [0, 0, 0, -1] ...\n+        int a = [](K y) {\n+          for (int j = 0; j < 4; ++j)\n+            if (y[j] != 0)\n+              return j;\n+          return -1;\n+        }(x.d);\n+        verify(a == i, 0, 0, 0, 0, i, x);\n+      }\n+  }\n+}"}]}