{"sha": "85a8fe00f805e7889b4e67a98ae1d435c042166b", "node_id": "C_kwDOANBUbNoAKDg1YThmZTAwZjgwNWU3ODg5YjRlNjdhOThhZTFkNDM1YzA0MjE2NmI", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-23T15:19:04Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:04Z"}, "message": "gccrs: Add name resolution pass to the Rust front-end\n\nThe name resolution is split into two phases, one toplevel pass which scans\nthe whole \"Crate\" which iterates all items and nested items in modules to\ngenerate a context class full of CanonicalPath items. It also generates\na hierarchy of parent->child and child->parent relationships using the AST\nNodeId for PathResolution in the second phase.\n\nThe second phase drills into each item like functions and creates a stack\nof canonical paths for variables etc so that we can store information in\na side table of usage variable 'a' resolves to NodeId '123' which refers\nto the NodeId of the \"let a;\" statement.\n\n\tgcc/rust/\n\t* resolve/rust-ast-resolve-base.cc: New.\n\t* resolve/rust-ast-resolve-base.h: New.\n\t* resolve/rust-ast-resolve-expr.cc: New.\n\t* resolve/rust-ast-resolve-expr.h: New.\n\t* resolve/rust-ast-resolve-implitem.h: New.\n\t* resolve/rust-ast-resolve-item.cc: New.\n\t* resolve/rust-ast-resolve-item.h: New.\n\t* resolve/rust-ast-resolve-path.cc: New.\n\t* resolve/rust-ast-resolve-path.h: New.\n\t* resolve/rust-ast-resolve-pattern.cc: New.\n\t* resolve/rust-ast-resolve-pattern.h: New.\n\t* resolve/rust-ast-resolve-stmt.cc: New.\n\t* resolve/rust-ast-resolve-stmt.h: New.\n\t* resolve/rust-ast-resolve-struct-expr-field.cc: New.\n\t* resolve/rust-ast-resolve-struct-expr-field.h: New.\n\t* resolve/rust-ast-resolve-toplevel.h: New.\n\t* resolve/rust-ast-resolve-type.cc: New.\n\t* resolve/rust-ast-resolve-type.h: New.\n\t* resolve/rust-ast-resolve.cc: New.\n\t* resolve/rust-ast-resolve.h: New.\n\t* resolve/rust-ast-verify-assignee.h: New.\n\t* resolve/rust-name-resolver.cc: New.\n\t* resolve/rust-name-resolver.h: New.", "tree": {"sha": "d034c272bdd63d7c63132e816e63f284c0076b82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d034c272bdd63d7c63132e816e63f284c0076b82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85a8fe00f805e7889b4e67a98ae1d435c042166b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85a8fe00f805e7889b4e67a98ae1d435c042166b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85a8fe00f805e7889b4e67a98ae1d435c042166b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85a8fe00f805e7889b4e67a98ae1d435c042166b/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1841081a8a306c1a220694a5ddb3a927cb4b2db3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1841081a8a306c1a220694a5ddb3a927cb4b2db3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1841081a8a306c1a220694a5ddb3a927cb4b2db3"}], "stats": {"total": 6772, "additions": 6772, "deletions": 0}, "files": [{"sha": "2a78918fbdbc402aa1a13ec4f557cbcf393d65b7", "filename": "gcc/rust/resolve/rust-ast-resolve-base.cc", "status": "added", "additions": 658, "deletions": 0, "changes": 658, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.cc?ref=85a8fe00f805e7889b4e67a98ae1d435c042166b", "patch": "@@ -0,0 +1,658 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-resolve-expr.h\"\n+#include \"rust-ast-resolve-path.h\"\n+#include \"rust-item.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+bool\n+ResolverBase::resolve_visibility (const AST::Visibility &vis)\n+{\n+  if (vis.has_path ())\n+    {\n+      auto path = vis.get_path ();\n+      ResolvePath::go (&path);\n+\n+      // Do we need to lookup something here?\n+      // Is it just about resolving the names correctly so we can look them up\n+      // later?\n+    }\n+\n+  return true;\n+}\n+\n+// Default visitors implementations\n+\n+void\n+ResolverBase::visit (AST::Token &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::DelimTokenTree &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::AttrInputMetaItemContainer &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::IdentifierExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::Lifetime &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::LifetimeParam &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ConstGenericParam &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::PathInExpression &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TypePathSegment &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TypePathSegmentGeneric &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TypePathSegmentFunction &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TypePath &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::QualifiedPathInExpression &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::QualifiedPathInType &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::LiteralExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::AttrInputLiteral &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::MetaItemLitExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::MetaItemPathLit &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::BorrowExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::DereferenceExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ErrorPropagationExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::NegationExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ArithmeticOrLogicalExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ComparisonExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::LazyBooleanExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TypeCastExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::AssignmentExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::CompoundAssignmentExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::GroupedExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ArrayElemsValues &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ArrayElemsCopied &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ArrayExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ArrayIndexExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TupleExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TupleIndexExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::StructExprStruct &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::StructExprFieldIdentifier &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::StructExprFieldIdentifierValue &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::StructExprFieldIndexValue &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::StructExprStructFields &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::StructExprStructBase &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::CallExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::MethodCallExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::FieldAccessExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ClosureExprInner &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::BlockExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ClosureExprInnerTyped &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ContinueExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::BreakExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::RangeFromToExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::RangeFromExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::RangeToExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::RangeFullExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::RangeFromToInclExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::RangeToInclExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ReturnExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::UnsafeBlockExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::LoopExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::WhileLoopExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::WhileLetLoopExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ForLoopExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::IfExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::IfExprConseqElse &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::IfExprConseqIf &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::IfExprConseqIfLet &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::IfLetExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::IfLetExprConseqElse &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::IfLetExprConseqIf &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::IfLetExprConseqIfLet &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::MatchExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::AwaitExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::AsyncBlockExpr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TypeParam &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::LifetimeWhereClauseItem &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TypeBoundWhereClauseItem &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::Method &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::Module &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ExternCrate &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::UseTreeGlob &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::UseTreeList &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::UseTreeRebind &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::UseDeclaration &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::Function &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TypeAlias &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::StructStruct &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TupleStruct &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::EnumItem &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::EnumItemTuple &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::EnumItemStruct &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::EnumItemDiscriminant &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::Enum &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::Union &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ConstantItem &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::StaticItem &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TraitItemFunc &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TraitItemMethod &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TraitItemConst &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TraitItemType &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::Trait &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::InherentImpl &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TraitImpl &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ExternalStaticItem &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ExternalFunctionItem &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ExternBlock &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::MacroMatchFragment &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::MacroMatchRepetition &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::MacroMatcher &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::MacroRulesDefinition &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::MacroInvocation &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::MetaItemPath &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::MetaItemSeq &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::MetaWord &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::MetaNameValueStr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::MetaListPaths &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::MetaListNameValueStr &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::LiteralPattern &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::IdentifierPattern &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::WildcardPattern &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::RangePatternBoundLiteral &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::RangePatternBoundPath &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::RangePatternBoundQualPath &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::RangePattern &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ReferencePattern &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::StructPatternFieldTuplePat &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::StructPatternFieldIdentPat &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::StructPatternFieldIdent &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::StructPattern &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TupleStructItemsNoRange &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TupleStructItemsRange &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TupleStructPattern &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TuplePatternItemsMultiple &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TuplePatternItemsRanged &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TuplePattern &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::GroupedPattern &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::SlicePattern &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::EmptyStmt &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::LetStmt &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ExprStmtWithoutBlock &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ExprStmtWithBlock &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TraitBound &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ImplTraitType &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TraitObjectType &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ParenthesisedType &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ImplTraitTypeOneBound &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TraitObjectTypeOneBound &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::TupleType &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::NeverType &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::RawPointerType &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ReferenceType &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::ArrayType &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::SliceType &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::InferredType &)\n+{}\n+\n+void\n+ResolverBase::visit (AST::BareFunctionType &)\n+{}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "32f30bcea62508342d7e3517d48b6517636f8fa3", "filename": "gcc/rust/resolve/rust-ast-resolve-base.h", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h?ref=85a8fe00f805e7889b4e67a98ae1d435c042166b", "patch": "@@ -0,0 +1,221 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_BASE_H\n+#define RUST_AST_RESOLVE_BASE_H\n+\n+#include \"rust-ast-visitor.h\"\n+#include \"rust-name-resolver.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"rust-location.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolverBase : public AST::ASTVisitor\n+{\n+public:\n+  virtual ~ResolverBase () {}\n+\n+  void visit (AST::Token &);\n+  void visit (AST::DelimTokenTree &);\n+  void visit (AST::AttrInputMetaItemContainer &);\n+  void visit (AST::IdentifierExpr &);\n+  void visit (AST::Lifetime &);\n+  void visit (AST::LifetimeParam &);\n+  void visit (AST::ConstGenericParam &);\n+  void visit (AST::PathInExpression &);\n+  void visit (AST::TypePathSegment &);\n+  void visit (AST::TypePathSegmentGeneric &);\n+  void visit (AST::TypePathSegmentFunction &);\n+  void visit (AST::TypePath &);\n+  void visit (AST::QualifiedPathInExpression &);\n+  void visit (AST::QualifiedPathInType &);\n+  void visit (AST::LiteralExpr &);\n+  void visit (AST::AttrInputLiteral &);\n+  void visit (AST::MetaItemLitExpr &);\n+  void visit (AST::MetaItemPathLit &);\n+  void visit (AST::BorrowExpr &);\n+  void visit (AST::DereferenceExpr &);\n+  void visit (AST::ErrorPropagationExpr &);\n+  void visit (AST::NegationExpr &);\n+  void visit (AST::ArithmeticOrLogicalExpr &);\n+  void visit (AST::ComparisonExpr &);\n+  void visit (AST::LazyBooleanExpr &);\n+  void visit (AST::TypeCastExpr &);\n+  void visit (AST::AssignmentExpr &);\n+  void visit (AST::CompoundAssignmentExpr &);\n+  void visit (AST::GroupedExpr &);\n+  void visit (AST::ArrayElemsValues &);\n+  void visit (AST::ArrayElemsCopied &);\n+  void visit (AST::ArrayExpr &);\n+  void visit (AST::ArrayIndexExpr &);\n+  void visit (AST::TupleExpr &);\n+  void visit (AST::TupleIndexExpr &);\n+  void visit (AST::StructExprStruct &);\n+  void visit (AST::StructExprFieldIdentifier &);\n+  void visit (AST::StructExprFieldIdentifierValue &);\n+  void visit (AST::StructExprFieldIndexValue &);\n+  void visit (AST::StructExprStructFields &);\n+  void visit (AST::StructExprStructBase &);\n+  void visit (AST::CallExpr &);\n+  void visit (AST::MethodCallExpr &);\n+  void visit (AST::FieldAccessExpr &);\n+  void visit (AST::ClosureExprInner &);\n+  void visit (AST::BlockExpr &);\n+  void visit (AST::ClosureExprInnerTyped &);\n+  void visit (AST::ContinueExpr &);\n+  void visit (AST::BreakExpr &);\n+  void visit (AST::RangeFromToExpr &);\n+  void visit (AST::RangeFromExpr &);\n+  void visit (AST::RangeToExpr &);\n+  void visit (AST::RangeFullExpr &);\n+  void visit (AST::RangeFromToInclExpr &);\n+  void visit (AST::RangeToInclExpr &);\n+  void visit (AST::ReturnExpr &);\n+  void visit (AST::UnsafeBlockExpr &);\n+  void visit (AST::LoopExpr &);\n+  void visit (AST::WhileLoopExpr &);\n+  void visit (AST::WhileLetLoopExpr &);\n+  void visit (AST::ForLoopExpr &);\n+  void visit (AST::IfExpr &);\n+  void visit (AST::IfExprConseqElse &);\n+  void visit (AST::IfExprConseqIf &);\n+  void visit (AST::IfExprConseqIfLet &);\n+  void visit (AST::IfLetExpr &);\n+  void visit (AST::IfLetExprConseqElse &);\n+  void visit (AST::IfLetExprConseqIf &);\n+  void visit (AST::IfLetExprConseqIfLet &);\n+\n+  void visit (AST::MatchExpr &);\n+  void visit (AST::AwaitExpr &);\n+  void visit (AST::AsyncBlockExpr &);\n+\n+  void visit (AST::TypeParam &);\n+\n+  void visit (AST::LifetimeWhereClauseItem &);\n+  void visit (AST::TypeBoundWhereClauseItem &);\n+  void visit (AST::Method &);\n+  void visit (AST::Module &);\n+  void visit (AST::ExternCrate &);\n+\n+  void visit (AST::UseTreeGlob &);\n+  void visit (AST::UseTreeList &);\n+  void visit (AST::UseTreeRebind &);\n+  void visit (AST::UseDeclaration &);\n+  void visit (AST::Function &);\n+  void visit (AST::TypeAlias &);\n+  void visit (AST::StructStruct &);\n+  void visit (AST::TupleStruct &);\n+  void visit (AST::EnumItem &);\n+  void visit (AST::EnumItemTuple &);\n+  void visit (AST::EnumItemStruct &);\n+  void visit (AST::EnumItemDiscriminant &);\n+  void visit (AST::Enum &);\n+  void visit (AST::Union &);\n+  void visit (AST::ConstantItem &);\n+  void visit (AST::StaticItem &);\n+  void visit (AST::TraitItemFunc &);\n+  void visit (AST::TraitItemMethod &);\n+  void visit (AST::TraitItemConst &);\n+  void visit (AST::TraitItemType &);\n+  void visit (AST::Trait &);\n+  void visit (AST::InherentImpl &);\n+  void visit (AST::TraitImpl &);\n+\n+  void visit (AST::ExternalStaticItem &);\n+  void visit (AST::ExternalFunctionItem &);\n+  void visit (AST::ExternBlock &);\n+\n+  void visit (AST::MacroMatchFragment &);\n+  void visit (AST::MacroMatchRepetition &);\n+  void visit (AST::MacroMatcher &);\n+  void visit (AST::MacroRulesDefinition &);\n+  void visit (AST::MacroInvocation &);\n+  void visit (AST::MetaItemPath &);\n+  void visit (AST::MetaItemSeq &);\n+  void visit (AST::MetaWord &);\n+  void visit (AST::MetaNameValueStr &);\n+  void visit (AST::MetaListPaths &);\n+  void visit (AST::MetaListNameValueStr &);\n+\n+  void visit (AST::LiteralPattern &);\n+  void visit (AST::IdentifierPattern &);\n+  void visit (AST::WildcardPattern &);\n+\n+  void visit (AST::RangePatternBoundLiteral &);\n+  void visit (AST::RangePatternBoundPath &);\n+  void visit (AST::RangePatternBoundQualPath &);\n+  void visit (AST::RangePattern &);\n+  void visit (AST::ReferencePattern &);\n+\n+  void visit (AST::StructPatternFieldTuplePat &);\n+  void visit (AST::StructPatternFieldIdentPat &);\n+  void visit (AST::StructPatternFieldIdent &);\n+  void visit (AST::StructPattern &);\n+\n+  void visit (AST::TupleStructItemsNoRange &);\n+  void visit (AST::TupleStructItemsRange &);\n+  void visit (AST::TupleStructPattern &);\n+\n+  void visit (AST::TuplePatternItemsMultiple &);\n+  void visit (AST::TuplePatternItemsRanged &);\n+  void visit (AST::TuplePattern &);\n+  void visit (AST::GroupedPattern &);\n+  void visit (AST::SlicePattern &);\n+\n+  void visit (AST::EmptyStmt &);\n+  void visit (AST::LetStmt &);\n+  void visit (AST::ExprStmtWithoutBlock &);\n+  void visit (AST::ExprStmtWithBlock &);\n+\n+  void visit (AST::TraitBound &);\n+  void visit (AST::ImplTraitType &);\n+  void visit (AST::TraitObjectType &);\n+  void visit (AST::ParenthesisedType &);\n+  void visit (AST::ImplTraitTypeOneBound &);\n+  void visit (AST::TraitObjectTypeOneBound &);\n+  void visit (AST::TupleType &);\n+  void visit (AST::NeverType &);\n+  void visit (AST::RawPointerType &);\n+  void visit (AST::ReferenceType &);\n+  void visit (AST::ArrayType &);\n+  void visit (AST::SliceType &);\n+  void visit (AST::InferredType &);\n+  void visit (AST::BareFunctionType &);\n+\n+protected:\n+  ResolverBase ()\n+    : resolver (Resolver::get ()), mappings (Analysis::Mappings::get ()),\n+      resolved_node (UNKNOWN_NODEID)\n+  {}\n+\n+  /**\n+   * Resolve a visibility's path through the name resolver\n+   */\n+  bool resolve_visibility (const AST::Visibility &vis);\n+\n+  Resolver *resolver;\n+  Analysis::Mappings *mappings;\n+  NodeId resolved_node;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_BASE_H"}, {"sha": "4cc4e26e3e94bbff6496b96834f35a70830e089a", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.cc", "status": "added", "additions": 574, "deletions": 0, "changes": 574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc?ref=85a8fe00f805e7889b4e67a98ae1d435c042166b", "patch": "@@ -0,0 +1,574 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-resolve-expr.h\"\n+#include \"rust-ast-resolve-stmt.h\"\n+#include \"rust-ast-resolve-struct-expr-field.h\"\n+#include \"rust-ast-verify-assignee.h\"\n+#include \"rust-ast-resolve-type.h\"\n+#include \"rust-ast-resolve-pattern.h\"\n+#include \"rust-ast-resolve-path.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+ResolveExpr::go (AST::Expr *expr, const CanonicalPath &prefix,\n+\t\t const CanonicalPath &canonical_prefix)\n+{\n+  ResolveExpr resolver (prefix, canonical_prefix);\n+  expr->accept_vis (resolver);\n+}\n+\n+void\n+ResolveExpr::visit (AST::TupleIndexExpr &expr)\n+{\n+  ResolveExpr::go (expr.get_tuple_expr ().get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::TupleExpr &expr)\n+{\n+  if (expr.is_unit ())\n+    return;\n+\n+  for (auto &elem : expr.get_tuple_elems ())\n+    ResolveExpr::go (elem.get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::PathInExpression &expr)\n+{\n+  ResolvePath::go (&expr);\n+}\n+\n+void\n+ResolveExpr::visit (AST::QualifiedPathInExpression &expr)\n+{\n+  ResolvePath::go (&expr);\n+}\n+\n+void\n+ResolveExpr::visit (AST::ReturnExpr &expr)\n+{\n+  if (expr.has_returned_expr ())\n+    ResolveExpr::go (expr.get_returned_expr ().get (), prefix,\n+\t\t     canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::CallExpr &expr)\n+{\n+  ResolveExpr::go (expr.get_function_expr ().get (), prefix, canonical_prefix);\n+  for (auto &param : expr.get_params ())\n+    ResolveExpr::go (param.get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::MethodCallExpr &expr)\n+{\n+  ResolveExpr::go (expr.get_receiver_expr ().get (), prefix, canonical_prefix);\n+\n+  if (expr.get_method_name ().has_generic_args ())\n+    {\n+      AST::GenericArgs &args = expr.get_method_name ().get_generic_args ();\n+      ResolveGenericArgs::go (args, prefix, canonical_prefix);\n+    }\n+\n+  auto const &in_params = expr.get_params ();\n+  for (auto &param : in_params)\n+    ResolveExpr::go (param.get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::AssignmentExpr &expr)\n+{\n+  ResolveExpr::go (expr.get_left_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_right_expr ().get (), prefix, canonical_prefix);\n+\n+  // need to verify the assignee\n+  VerifyAsignee::go (expr.get_left_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::IdentifierExpr &expr)\n+{\n+  if (resolver->get_name_scope ().lookup (\n+\tCanonicalPath::new_seg (expr.get_node_id (), expr.as_string ()),\n+\t&resolved_node))\n+    {\n+      resolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n+    }\n+  else if (resolver->get_type_scope ().lookup (\n+\t     CanonicalPath::new_seg (expr.get_node_id (), expr.as_string ()),\n+\t     &resolved_node))\n+    {\n+      resolver->insert_resolved_type (expr.get_node_id (), resolved_node);\n+    }\n+  else\n+    {\n+      rust_error_at (expr.get_locus (), \"failed to find name: %s\",\n+\t\t     expr.as_string ().c_str ());\n+    }\n+}\n+\n+void\n+ResolveExpr::visit (AST::ArithmeticOrLogicalExpr &expr)\n+{\n+  ResolveExpr::go (expr.get_left_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_right_expr ().get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::CompoundAssignmentExpr &expr)\n+{\n+  ResolveExpr::go (expr.get_left_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_right_expr ().get (), prefix, canonical_prefix);\n+\n+  // need to verify the assignee\n+  VerifyAsignee::go (expr.get_left_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::ComparisonExpr &expr)\n+{\n+  ResolveExpr::go (expr.get_left_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_right_expr ().get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::LazyBooleanExpr &expr)\n+{\n+  ResolveExpr::go (expr.get_left_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_right_expr ().get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::NegationExpr &expr)\n+{\n+  ResolveExpr::go (expr.get_negated_expr ().get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::TypeCastExpr &expr)\n+{\n+  ResolveType::go (expr.get_type_to_cast_to ().get ());\n+  ResolveExpr::go (expr.get_casted_expr ().get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::IfExpr &expr)\n+{\n+  ResolveExpr::go (expr.get_condition_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_if_block ().get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::IfExprConseqElse &expr)\n+{\n+  ResolveExpr::go (expr.get_condition_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_if_block ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_else_block ().get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::IfExprConseqIf &expr)\n+{\n+  ResolveExpr::go (expr.get_condition_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_if_block ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_conseq_if_expr ().get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::IfLetExpr &expr)\n+{\n+  ResolveExpr::go (expr.get_value_expr ().get (), prefix, canonical_prefix);\n+\n+  NodeId scope_node_id = expr.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  for (auto &pattern : expr.get_patterns ())\n+    {\n+      PatternDeclaration::go (pattern.get ());\n+    }\n+\n+  ResolveExpr::go (expr.get_if_block ().get (), prefix, canonical_prefix);\n+\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveExpr::visit (AST::BlockExpr &expr)\n+{\n+  NodeId scope_node_id = expr.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  for (auto &s : expr.get_statements ())\n+    {\n+      if (s->is_item ())\n+\tResolveStmt::go (s.get (), prefix, canonical_prefix,\n+\t\t\t CanonicalPath::create_empty ());\n+    }\n+\n+  for (auto &s : expr.get_statements ())\n+    {\n+      if (!s->is_item ())\n+\tResolveStmt::go (s.get (), prefix, canonical_prefix,\n+\t\t\t CanonicalPath::create_empty ());\n+    }\n+\n+  if (expr.has_tail_expr ())\n+    ResolveExpr::go (expr.get_tail_expr ().get (), prefix, canonical_prefix);\n+\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveExpr::visit (AST::UnsafeBlockExpr &expr)\n+{\n+  expr.get_block_expr ()->accept_vis (*this);\n+}\n+\n+void\n+ResolveExpr::visit (AST::ArrayElemsValues &elems)\n+{\n+  for (auto &elem : elems.get_values ())\n+    ResolveExpr::go (elem.get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::ArrayExpr &expr)\n+{\n+  expr.get_array_elems ()->accept_vis (*this);\n+}\n+\n+void\n+ResolveExpr::visit (AST::ArrayIndexExpr &expr)\n+{\n+  ResolveExpr::go (expr.get_array_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_index_expr ().get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::ArrayElemsCopied &expr)\n+{\n+  ResolveExpr::go (expr.get_num_copies ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_elem_to_copy ().get (), prefix, canonical_prefix);\n+}\n+\n+// this this an empty struct constructor like 'S {}'\n+void\n+ResolveExpr::visit (AST::StructExprStruct &struct_expr)\n+{\n+  ResolveExpr::go (&struct_expr.get_struct_name (), prefix, canonical_prefix);\n+}\n+\n+// this this a struct constructor with fields\n+void\n+ResolveExpr::visit (AST::StructExprStructFields &struct_expr)\n+{\n+  ResolveExpr::go (&struct_expr.get_struct_name (), prefix, canonical_prefix);\n+\n+  if (struct_expr.has_struct_base ())\n+    {\n+      AST::StructBase &base = struct_expr.get_struct_base ();\n+      ResolveExpr::go (base.get_base_struct ().get (), prefix,\n+\t\t       canonical_prefix);\n+    }\n+\n+  auto const &struct_fields = struct_expr.get_fields ();\n+  for (auto &struct_field : struct_fields)\n+    {\n+      ResolveStructExprField::go (struct_field.get (), prefix,\n+\t\t\t\t  canonical_prefix);\n+    }\n+}\n+\n+void\n+ResolveExpr::visit (AST::GroupedExpr &expr)\n+{\n+  ResolveExpr::go (expr.get_expr_in_parens ().get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::FieldAccessExpr &expr)\n+{\n+  ResolveExpr::go (expr.get_receiver_expr ().get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::LoopExpr &expr)\n+{\n+  if (expr.has_loop_label ())\n+    {\n+      auto label = expr.get_loop_label ();\n+      if (label.get_lifetime ().get_lifetime_type ()\n+\t  != AST::Lifetime::LifetimeType::NAMED)\n+\t{\n+\t  rust_error_at (label.get_locus (),\n+\t\t\t \"Labels must be a named lifetime value\");\n+\t  return;\n+\t}\n+\n+      auto label_name = label.get_lifetime ().get_lifetime_name ();\n+      auto label_lifetime_node_id = label.get_lifetime ().get_node_id ();\n+      resolver->get_label_scope ().insert (\n+\tCanonicalPath::new_seg (expr.get_node_id (), label_name),\n+\tlabel_lifetime_node_id, label.get_locus (), false,\n+\t[&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\t  rust_error_at (label.get_locus (), \"label redefined multiple times\");\n+\t  rust_error_at (locus, \"was defined here\");\n+\t});\n+    }\n+  ResolveExpr::go (expr.get_loop_block ().get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::BreakExpr &expr)\n+{\n+  if (expr.has_label ())\n+    {\n+      auto label = expr.get_label ();\n+      if (label.get_lifetime_type () != AST::Lifetime::LifetimeType::NAMED)\n+\t{\n+\t  rust_error_at (label.get_locus (),\n+\t\t\t \"Labels must be a named lifetime value\");\n+\t  return;\n+\t}\n+\n+      NodeId resolved_node = UNKNOWN_NODEID;\n+      if (!resolver->get_label_scope ().lookup (\n+\t    CanonicalPath::new_seg (label.get_node_id (),\n+\t\t\t\t    label.get_lifetime_name ()),\n+\t    &resolved_node))\n+\t{\n+\t  rust_error_at (expr.get_label ().get_locus (),\n+\t\t\t \"failed to resolve label\");\n+\t  return;\n+\t}\n+      resolver->insert_resolved_label (label.get_node_id (), resolved_node);\n+    }\n+\n+  if (expr.has_break_expr ())\n+    ResolveExpr::go (expr.get_break_expr ().get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::WhileLoopExpr &expr)\n+{\n+  if (expr.has_loop_label ())\n+    {\n+      auto label = expr.get_loop_label ();\n+      if (label.get_lifetime ().get_lifetime_type ()\n+\t  != AST::Lifetime::LifetimeType::NAMED)\n+\t{\n+\t  rust_error_at (label.get_locus (),\n+\t\t\t \"Labels must be a named lifetime value\");\n+\t  return;\n+\t}\n+\n+      auto label_name = label.get_lifetime ().get_lifetime_name ();\n+      auto label_lifetime_node_id = label.get_lifetime ().get_node_id ();\n+      resolver->get_label_scope ().insert (\n+\tCanonicalPath::new_seg (label.get_node_id (), label_name),\n+\tlabel_lifetime_node_id, label.get_locus (), false,\n+\t[&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\t  rust_error_at (label.get_locus (), \"label redefined multiple times\");\n+\t  rust_error_at (locus, \"was defined here\");\n+\t});\n+    }\n+\n+  ResolveExpr::go (expr.get_predicate_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_loop_block ().get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::ForLoopExpr &expr)\n+{\n+  if (expr.has_loop_label ())\n+    {\n+      auto label = expr.get_loop_label ();\n+      if (label.get_lifetime ().get_lifetime_type ()\n+\t  != AST::Lifetime::LifetimeType::NAMED)\n+\t{\n+\t  rust_error_at (label.get_locus (),\n+\t\t\t \"Labels must be a named lifetime value\");\n+\t  return;\n+\t}\n+\n+      auto label_name = label.get_lifetime ().get_lifetime_name ();\n+      auto label_lifetime_node_id = label.get_lifetime ().get_node_id ();\n+      resolver->get_label_scope ().insert (\n+\tCanonicalPath::new_seg (label.get_node_id (), label_name),\n+\tlabel_lifetime_node_id, label.get_locus (), false,\n+\t[&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\t  rust_error_at (label.get_locus (), \"label redefined multiple times\");\n+\t  rust_error_at (locus, \"was defined here\");\n+\t});\n+    }\n+\n+  // this needs a new rib to contain the pattern\n+  NodeId scope_node_id = expr.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  // resolve the expression\n+  PatternDeclaration::go (expr.get_pattern ().get ());\n+  ResolveExpr::go (expr.get_iterator_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_loop_block ().get (), prefix, canonical_prefix);\n+\n+  // done\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveExpr::visit (AST::ContinueExpr &expr)\n+{\n+  if (expr.has_label ())\n+    {\n+      auto label = expr.get_label ();\n+      if (label.get_lifetime_type () != AST::Lifetime::LifetimeType::NAMED)\n+\t{\n+\t  rust_error_at (label.get_locus (),\n+\t\t\t \"Labels must be a named lifetime value\");\n+\t  return;\n+\t}\n+\n+      NodeId resolved_node = UNKNOWN_NODEID;\n+      if (!resolver->get_label_scope ().lookup (\n+\t    CanonicalPath::new_seg (label.get_node_id (),\n+\t\t\t\t    label.get_lifetime_name ()),\n+\t    &resolved_node))\n+\t{\n+\t  rust_error_at (expr.get_label ().get_locus (),\n+\t\t\t \"failed to resolve label\");\n+\t  return;\n+\t}\n+      resolver->insert_resolved_label (label.get_node_id (), resolved_node);\n+    }\n+}\n+\n+void\n+ResolveExpr::visit (AST::BorrowExpr &expr)\n+{\n+  ResolveExpr::go (expr.get_borrowed_expr ().get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::DereferenceExpr &expr)\n+{\n+  ResolveExpr::go (expr.get_dereferenced_expr ().get (), prefix,\n+\t\t   canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::MatchExpr &expr)\n+{\n+  ResolveExpr::go (expr.get_scrutinee_expr ().get (), prefix, canonical_prefix);\n+  for (auto &match_case : expr.get_match_cases ())\n+    {\n+      // each arm is in its own scope\n+      NodeId scope_node_id = match_case.get_node_id ();\n+      resolver->get_name_scope ().push (scope_node_id);\n+      resolver->get_type_scope ().push (scope_node_id);\n+      resolver->get_label_scope ().push (scope_node_id);\n+      resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+      resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+      resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+      // resolve\n+      AST::MatchArm &arm = match_case.get_arm ();\n+      if (arm.has_match_arm_guard ())\n+\tResolveExpr::go (arm.get_guard_expr ().get (), prefix,\n+\t\t\t canonical_prefix);\n+\n+      // insert any possible new patterns\n+      for (auto &pattern : arm.get_patterns ())\n+\t{\n+\t  PatternDeclaration::go (pattern.get ());\n+\t}\n+\n+      // resolve the body\n+      ResolveExpr::go (match_case.get_expr ().get (), prefix, canonical_prefix);\n+\n+      // done\n+      resolver->get_name_scope ().pop ();\n+      resolver->get_type_scope ().pop ();\n+      resolver->get_label_scope ().pop ();\n+    }\n+}\n+\n+void\n+ResolveExpr::visit (AST::RangeFromToExpr &expr)\n+{\n+  ResolveExpr::go (expr.get_from_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_to_expr ().get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::RangeFromExpr &expr)\n+{\n+  ResolveExpr::go (expr.get_from_expr ().get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::RangeToExpr &expr)\n+{\n+  ResolveExpr::go (expr.get_to_expr ().get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveExpr::visit (AST::RangeFullExpr &expr)\n+{\n+  // nothing to do\n+}\n+\n+void\n+ResolveExpr::visit (AST::RangeFromToInclExpr &expr)\n+{\n+  ResolveExpr::go (expr.get_from_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_to_expr ().get (), prefix, canonical_prefix);\n+}\n+\n+ResolveExpr::ResolveExpr (const CanonicalPath &prefix,\n+\t\t\t  const CanonicalPath &canonical_prefix)\n+  : ResolverBase (), prefix (prefix), canonical_prefix (canonical_prefix)\n+{}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "11a846ac8cd87fda6031405532249c9c1dd3686e", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=85a8fe00f805e7889b4e67a98ae1d435c042166b", "patch": "@@ -0,0 +1,133 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_EXPR_H\n+#define RUST_AST_RESOLVE_EXPR_H\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolveExpr : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static void go (AST::Expr *expr, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix);\n+\n+  void visit (AST::TupleIndexExpr &expr) override;\n+\n+  void visit (AST::TupleExpr &expr) override;\n+\n+  void visit (AST::PathInExpression &expr) override;\n+\n+  void visit (AST::QualifiedPathInExpression &expr) override;\n+\n+  void visit (AST::ReturnExpr &expr) override;\n+\n+  void visit (AST::CallExpr &expr) override;\n+\n+  void visit (AST::MethodCallExpr &expr) override;\n+\n+  void visit (AST::AssignmentExpr &expr) override;\n+\n+  void visit (AST::IdentifierExpr &expr) override;\n+\n+  void visit (AST::ArithmeticOrLogicalExpr &expr) override;\n+\n+  void visit (AST::CompoundAssignmentExpr &expr) override;\n+\n+  void visit (AST::ComparisonExpr &expr) override;\n+\n+  void visit (AST::LazyBooleanExpr &expr) override;\n+\n+  void visit (AST::NegationExpr &expr) override;\n+\n+  void visit (AST::TypeCastExpr &expr) override;\n+\n+  void visit (AST::IfExpr &expr) override;\n+\n+  void visit (AST::IfExprConseqElse &expr) override;\n+\n+  void visit (AST::IfExprConseqIf &expr) override;\n+\n+  void visit (AST::IfLetExpr &expr) override;\n+\n+  void visit (AST::BlockExpr &expr) override;\n+\n+  void visit (AST::UnsafeBlockExpr &expr) override;\n+\n+  void visit (AST::ArrayElemsValues &elems) override;\n+\n+  void visit (AST::ArrayExpr &expr) override;\n+\n+  void visit (AST::ArrayIndexExpr &expr) override;\n+\n+  void visit (AST::ArrayElemsCopied &elems) override;\n+\n+  // this this an empty struct constructor like 'S {}'\n+  void visit (AST::StructExprStruct &struct_expr) override;\n+\n+  // this this a struct constructor with fields\n+  void visit (AST::StructExprStructFields &struct_expr) override;\n+\n+  void visit (AST::GroupedExpr &expr) override;\n+\n+  void visit (AST::FieldAccessExpr &expr) override;\n+\n+  void visit (AST::LoopExpr &expr) override;\n+\n+  void visit (AST::BreakExpr &expr) override;\n+\n+  void visit (AST::WhileLoopExpr &expr) override;\n+\n+  void visit (AST::ForLoopExpr &expr) override;\n+\n+  void visit (AST::ContinueExpr &expr) override;\n+\n+  void visit (AST::BorrowExpr &expr) override;\n+\n+  void visit (AST::DereferenceExpr &expr) override;\n+\n+  void visit (AST::MatchExpr &expr) override;\n+\n+  void visit (AST::RangeFromToExpr &expr) override;\n+\n+  void visit (AST::RangeFromExpr &expr) override;\n+\n+  void visit (AST::RangeToExpr &expr) override;\n+\n+  void visit (AST::RangeFullExpr &expr) override;\n+\n+  void visit (AST::RangeFromToInclExpr &expr) override;\n+\n+private:\n+  ResolveExpr (const CanonicalPath &prefix,\n+\t       const CanonicalPath &canonical_prefix);\n+\n+  const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_EXPR_H"}, {"sha": "29dbe3436f5e067a09f9e39f07747cf9cbe33ddb", "filename": "gcc/rust/resolve/rust-ast-resolve-implitem.h", "status": "added", "additions": 275, "deletions": 0, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h?ref=85a8fe00f805e7889b4e67a98ae1d435c042166b", "patch": "@@ -0,0 +1,275 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_IMPLITEM_H\n+#define RUST_AST_RESOLVE_IMPLITEM_H\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-resolve-type.h\"\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolveToplevelImplItem : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static void go (AST::InherentImplItem *item, const CanonicalPath &prefix)\n+  {\n+    if (item->is_marked_for_strip ())\n+      return;\n+\n+    ResolveToplevelImplItem resolver (prefix);\n+    item->accept_vis (resolver);\n+  }\n+\n+  static void go (AST::TraitImplItem *item, const CanonicalPath &prefix)\n+  {\n+    if (item->is_marked_for_strip ())\n+      return;\n+\n+    ResolveToplevelImplItem resolver (prefix);\n+    item->accept_vis (resolver);\n+  }\n+\n+  void visit (AST::TypeAlias &type) override\n+  {\n+    auto decl\n+      = CanonicalPath::new_seg (type.get_node_id (), type.get_new_type_name ());\n+    auto path = prefix.append (decl);\n+\n+    resolver->get_type_scope ().insert (\n+      path, type.get_node_id (), type.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (type.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+  }\n+\n+  void visit (AST::ConstantItem &constant) override\n+  {\n+    auto decl = CanonicalPath::new_seg (constant.get_node_id (),\n+\t\t\t\t\tconstant.get_identifier ());\n+    auto path = prefix.append (decl);\n+\n+    resolver->get_name_scope ().insert (\n+      path, constant.get_node_id (), constant.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (constant.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+  }\n+\n+  void visit (AST::Function &function) override\n+  {\n+    auto decl = CanonicalPath::new_seg (function.get_node_id (),\n+\t\t\t\t\tfunction.get_function_name ());\n+    auto path = prefix.append (decl);\n+\n+    resolver->get_name_scope ().insert (\n+      path, function.get_node_id (), function.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (function.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+  }\n+\n+  void visit (AST::Method &method) override\n+  {\n+    auto decl = CanonicalPath::new_seg (method.get_node_id (),\n+\t\t\t\t\tmethod.get_method_name ());\n+    auto path = prefix.append (decl);\n+\n+    resolver->get_name_scope ().insert (\n+      path, method.get_node_id (), method.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (method.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+  }\n+\n+private:\n+  ResolveToplevelImplItem (const CanonicalPath &prefix)\n+    : ResolverBase (), prefix (prefix)\n+  {\n+    rust_assert (!prefix.is_empty ());\n+  }\n+\n+  const CanonicalPath &prefix;\n+};\n+\n+class ResolveTopLevelTraitItems : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static void go (AST::TraitItem *item, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix)\n+  {\n+    ResolveTopLevelTraitItems resolver (prefix, canonical_prefix);\n+    item->accept_vis (resolver);\n+  };\n+\n+  void visit (AST::TraitItemFunc &function) override\n+  {\n+    auto decl = CanonicalPath::new_seg (\n+      function.get_node_id (),\n+      function.get_trait_function_decl ().get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n+    resolver->get_name_scope ().insert (\n+      path, function.get_node_id (), function.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (function.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    mappings->insert_canonical_path (function.get_node_id (), cpath);\n+  }\n+\n+  void visit (AST::TraitItemMethod &method) override\n+  {\n+    auto decl = CanonicalPath::new_seg (\n+      method.get_node_id (), method.get_trait_method_decl ().get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n+    resolver->get_name_scope ().insert (\n+      path, method.get_node_id (), method.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (method.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    mappings->insert_canonical_path (method.get_node_id (), cpath);\n+  }\n+\n+  void visit (AST::TraitItemConst &constant) override\n+  {\n+    auto decl = CanonicalPath::new_seg (constant.get_node_id (),\n+\t\t\t\t\tconstant.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n+    resolver->get_name_scope ().insert (\n+      path, constant.get_node_id (), constant.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (constant.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    mappings->insert_canonical_path (constant.get_node_id (), cpath);\n+  }\n+\n+  void visit (AST::TraitItemType &type) override\n+  {\n+    auto decl\n+      = CanonicalPath::new_seg (type.get_node_id (), type.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n+    resolver->get_type_scope ().insert (\n+      path, type.get_node_id (), type.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (type.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    mappings->insert_canonical_path (type.get_node_id (), cpath);\n+  }\n+\n+private:\n+  ResolveTopLevelTraitItems (const CanonicalPath &prefix,\n+\t\t\t     const CanonicalPath &canonical_prefix)\n+    : ResolverBase (), prefix (prefix), canonical_prefix (canonical_prefix)\n+  {}\n+\n+  const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n+};\n+\n+class ResolveToplevelExternItem : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static void go (AST::ExternalItem *item, const CanonicalPath &prefix)\n+  {\n+    ResolveToplevelExternItem resolver (prefix);\n+    item->accept_vis (resolver);\n+  };\n+\n+  void visit (AST::ExternalFunctionItem &function) override\n+  {\n+    auto decl = CanonicalPath::new_seg (function.get_node_id (),\n+\t\t\t\t\tfunction.get_identifier ());\n+    auto path = prefix.append (decl);\n+\n+    resolver->get_name_scope ().insert (\n+      path, function.get_node_id (), function.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (function.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    NodeId current_module = resolver->peek_current_module_scope ();\n+    mappings->insert_module_child_item (current_module, decl);\n+  }\n+\n+  void visit (AST::ExternalStaticItem &item) override\n+  {\n+    auto decl\n+      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+    auto path = prefix.append (decl);\n+\n+    resolver->get_name_scope ().insert (\n+      path, item.get_node_id (), item.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (item.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    NodeId current_module = resolver->peek_current_module_scope ();\n+    mappings->insert_module_child_item (current_module, decl);\n+  }\n+\n+private:\n+  ResolveToplevelExternItem (const CanonicalPath &prefix)\n+    : ResolverBase (), prefix (prefix)\n+  {}\n+\n+  const CanonicalPath &prefix;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_IMPLITEM_H"}, {"sha": "0c38f28d5306678a83c35f176015a28cc5ec9bbf", "filename": "gcc/rust/resolve/rust-ast-resolve-item.cc", "status": "added", "additions": 1237, "deletions": 0, "changes": 1237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc?ref=85a8fe00f805e7889b4e67a98ae1d435c042166b", "patch": "@@ -0,0 +1,1237 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-resolve-item.h\"\n+#include \"rust-ast-resolve-path.h\"\n+#include \"selftest.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+ResolveTraitItems::ResolveTraitItems (const CanonicalPath &prefix,\n+\t\t\t\t      const CanonicalPath &canonical_prefix)\n+  : ResolverBase (), prefix (prefix), canonical_prefix (canonical_prefix)\n+{}\n+\n+void\n+ResolveTraitItems::go (AST::TraitItem *item, const CanonicalPath &prefix,\n+\t\t       const CanonicalPath &canonical_prefix)\n+{\n+  if (item->is_marked_for_strip ())\n+    return;\n+\n+  ResolveTraitItems resolver (prefix, canonical_prefix);\n+  item->accept_vis (resolver);\n+}\n+\n+void\n+ResolveTraitItems::visit (AST::TraitItemType &type)\n+{\n+  auto decl\n+    = CanonicalPath::new_seg (type.get_node_id (), type.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (type.get_node_id (), cpath);\n+\n+  for (auto &bound : type.get_type_param_bounds ())\n+    ResolveTypeBound::go (bound.get ());\n+}\n+\n+void\n+ResolveTraitItems::visit (AST::TraitItemFunc &func)\n+{\n+  auto decl = CanonicalPath::new_seg (\n+    func.get_node_id (), func.get_trait_function_decl ().get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (func.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = func.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  AST::TraitFunctionDecl &function = func.get_trait_function_decl ();\n+  if (function.has_generics ())\n+    for (auto &generic : function.get_generic_params ())\n+      ResolveGenericParam::go (generic.get (), prefix, canonical_prefix);\n+\n+  if (function.has_return_type ())\n+    ResolveType::go (function.get_return_type ().get ());\n+\n+  // we make a new scope so the names of parameters are resolved and shadowed\n+  // correctly\n+  for (auto &param : function.get_function_params ())\n+    {\n+      ResolveType::go (param.get_type ().get ());\n+      PatternDeclaration::go (param.get_pattern ().get ());\n+    }\n+\n+  if (function.has_where_clause ())\n+    ResolveWhereClause::Resolve (function.get_where_clause ());\n+\n+  // trait items have an optional body\n+  if (func.has_definition ())\n+    ResolveExpr::go (func.get_definition ().get (), path, cpath);\n+\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveTraitItems::visit (AST::TraitItemMethod &func)\n+{\n+  auto decl\n+    = CanonicalPath::new_seg (func.get_node_id (),\n+\t\t\t      func.get_trait_method_decl ().get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (func.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = func.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  AST::TraitMethodDecl &function = func.get_trait_method_decl ();\n+  if (function.has_generics ())\n+    for (auto &generic : function.get_generic_params ())\n+      ResolveGenericParam::go (generic.get (), prefix, canonical_prefix);\n+\n+  if (function.has_return_type ())\n+    ResolveType::go (function.get_return_type ().get ());\n+\n+  // self turns into (self: Self) as a function param\n+  AST::SelfParam &self_param = function.get_self_param ();\n+  AST::IdentifierPattern self_pattern (self_param.get_node_id (), \"self\",\n+\t\t\t\t       self_param.get_locus (),\n+\t\t\t\t       self_param.get_has_ref (),\n+\t\t\t\t       self_param.get_is_mut (),\n+\t\t\t\t       std::unique_ptr<AST::Pattern> (nullptr));\n+\n+  std::vector<std::unique_ptr<AST::TypePathSegment>> segments;\n+  segments.push_back (std::unique_ptr<AST::TypePathSegment> (\n+    new AST::TypePathSegment (\"Self\", false, self_param.get_locus ())));\n+\n+  AST::TypePath self_type_path (std::move (segments), self_param.get_locus ());\n+\n+  ResolveType::go (&self_type_path);\n+  PatternDeclaration::go (&self_pattern);\n+\n+  // we make a new scope so the names of parameters are resolved and shadowed\n+  // correctly\n+  for (auto &param : function.get_function_params ())\n+    {\n+      ResolveType::go (param.get_type ().get ());\n+      PatternDeclaration::go (param.get_pattern ().get ());\n+    }\n+\n+  if (function.has_where_clause ())\n+    ResolveWhereClause::Resolve (function.get_where_clause ());\n+\n+  // trait items have an optional body\n+  if (func.has_definition ())\n+    ResolveExpr::go (func.get_definition ().get (), path, cpath);\n+\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveTraitItems::visit (AST::TraitItemConst &constant)\n+{\n+  auto decl = CanonicalPath::new_seg (constant.get_node_id (),\n+\t\t\t\t      constant.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (constant.get_node_id (), cpath);\n+\n+  ResolveType::go (constant.get_type ().get ());\n+\n+  if (constant.has_expr ())\n+    ResolveExpr::go (constant.get_expr ().get (), path, cpath);\n+}\n+\n+ResolveItem::ResolveItem (const CanonicalPath &prefix,\n+\t\t\t  const CanonicalPath &canonical_prefix)\n+  : ResolverBase (), prefix (prefix), canonical_prefix (canonical_prefix)\n+{}\n+\n+void\n+ResolveItem::go (AST::Item *item, const CanonicalPath &prefix,\n+\t\t const CanonicalPath &canonical_prefix)\n+{\n+  ResolveItem resolver (prefix, canonical_prefix);\n+  item->accept_vis (resolver);\n+}\n+\n+void\n+ResolveItem::visit (AST::TypeAlias &alias)\n+{\n+  auto talias\n+    = CanonicalPath::new_seg (alias.get_node_id (), alias.get_new_type_name ());\n+  auto path = prefix.append (talias);\n+  auto cpath = canonical_prefix.append (talias);\n+  mappings->insert_canonical_path (alias.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = alias.get_node_id ();\n+  resolver->get_type_scope ().push (scope_node_id);\n+\n+  if (alias.has_generics ())\n+    for (auto &generic : alias.get_generic_params ())\n+      ResolveGenericParam::go (generic.get (), prefix, canonical_prefix);\n+\n+  if (alias.has_where_clause ())\n+    ResolveWhereClause::Resolve (alias.get_where_clause ());\n+\n+  ResolveType::go (alias.get_type_aliased ().get ());\n+\n+  resolver->get_type_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::Module &module)\n+{\n+  auto mod = CanonicalPath::new_seg (module.get_node_id (), module.get_name ());\n+  auto path = prefix.append (mod);\n+  auto cpath = canonical_prefix.append (mod);\n+  mappings->insert_canonical_path (module.get_node_id (), cpath);\n+\n+  resolve_visibility (module.get_visibility ());\n+\n+  NodeId scope_node_id = module.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  // FIXME: Should we reinsert a child here? Any reason we ResolveTopLevel::go\n+  // in ResolveTopLevel::visit (AST::Module) as well as here?\n+  for (auto &item : module.get_items ())\n+    ResolveTopLevel::go (item.get (), CanonicalPath::create_empty (), cpath);\n+\n+  resolver->push_new_module_scope (module.get_node_id ());\n+  for (auto &item : module.get_items ())\n+    ResolveItem::go (item.get (), path, cpath);\n+\n+  resolver->pop_module_scope ();\n+\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::TupleStruct &struct_decl)\n+{\n+  auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+\t\t\t\t      struct_decl.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (struct_decl.get_node_id (), cpath);\n+\n+  resolve_visibility (struct_decl.get_visibility ());\n+\n+  NodeId scope_node_id = struct_decl.get_node_id ();\n+  resolver->get_type_scope ().push (scope_node_id);\n+\n+  if (struct_decl.has_generics ())\n+    for (auto &generic : struct_decl.get_generic_params ())\n+      ResolveGenericParam::go (generic.get (), prefix, canonical_prefix);\n+\n+  if (struct_decl.has_where_clause ())\n+    ResolveWhereClause::Resolve (struct_decl.get_where_clause ());\n+\n+  for (AST::TupleField &field : struct_decl.get_fields ())\n+    {\n+      if (field.get_field_type ()->is_marked_for_strip ())\n+\tcontinue;\n+\n+      resolve_visibility (field.get_visibility ());\n+\n+      ResolveType::go (field.get_field_type ().get ());\n+    }\n+\n+  resolver->get_type_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::Enum &enum_decl)\n+{\n+  auto decl = CanonicalPath::new_seg (enum_decl.get_node_id (),\n+\t\t\t\t      enum_decl.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (enum_decl.get_node_id (), cpath);\n+\n+  resolve_visibility (enum_decl.get_visibility ());\n+\n+  NodeId scope_node_id = enum_decl.get_node_id ();\n+  resolver->get_type_scope ().push (scope_node_id);\n+\n+  if (enum_decl.has_generics ())\n+    for (auto &generic : enum_decl.get_generic_params ())\n+      ResolveGenericParam::go (generic.get (), prefix, cpath);\n+\n+  if (enum_decl.has_where_clause ())\n+    ResolveWhereClause::Resolve (enum_decl.get_where_clause ());\n+\n+  /* The actual fields are inside the variants.  */\n+  for (auto &variant : enum_decl.get_variants ())\n+    ResolveItem::go (variant.get (), path, cpath);\n+\n+  resolver->get_type_scope ().pop ();\n+}\n+\n+/* EnumItem doesn't need to be handled, no fields.  */\n+void\n+ResolveItem::visit (AST::EnumItem &item)\n+{\n+  // Since at this point we cannot have visibilities on enum items anymore, we\n+  // can skip handling them\n+\n+  auto decl\n+    = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (item.get_node_id (), cpath);\n+}\n+\n+void\n+ResolveItem::visit (AST::EnumItemTuple &item)\n+{\n+  auto decl\n+    = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (item.get_node_id (), cpath);\n+\n+  for (auto &field : item.get_tuple_fields ())\n+    {\n+      if (field.get_field_type ()->is_marked_for_strip ())\n+\tcontinue;\n+\n+      ResolveType::go (field.get_field_type ().get ());\n+    }\n+}\n+\n+void\n+ResolveItem::visit (AST::EnumItemStruct &item)\n+{\n+  auto decl\n+    = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (item.get_node_id (), cpath);\n+\n+  for (auto &field : item.get_struct_fields ())\n+    {\n+      if (field.get_field_type ()->is_marked_for_strip ())\n+\tcontinue;\n+\n+      ResolveType::go (field.get_field_type ().get ());\n+    }\n+}\n+\n+void\n+ResolveItem::visit (AST::EnumItemDiscriminant &item)\n+{\n+  auto decl\n+    = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+\n+  mappings->insert_canonical_path (item.get_node_id (), cpath);\n+}\n+\n+void\n+ResolveItem::visit (AST::StructStruct &struct_decl)\n+{\n+  auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+\t\t\t\t      struct_decl.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (struct_decl.get_node_id (), cpath);\n+\n+  resolve_visibility (struct_decl.get_visibility ());\n+\n+  NodeId scope_node_id = struct_decl.get_node_id ();\n+  resolver->get_type_scope ().push (scope_node_id);\n+\n+  if (struct_decl.has_generics ())\n+    for (auto &generic : struct_decl.get_generic_params ())\n+      ResolveGenericParam::go (generic.get (), prefix, canonical_prefix);\n+\n+  if (struct_decl.has_where_clause ())\n+    ResolveWhereClause::Resolve (struct_decl.get_where_clause ());\n+\n+  for (AST::StructField &field : struct_decl.get_fields ())\n+    {\n+      if (field.get_field_type ()->is_marked_for_strip ())\n+\tcontinue;\n+\n+      resolve_visibility (field.get_visibility ());\n+\n+      ResolveType::go (field.get_field_type ().get ());\n+    }\n+\n+  resolver->get_type_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::Union &union_decl)\n+{\n+  auto decl = CanonicalPath::new_seg (union_decl.get_node_id (),\n+\t\t\t\t      union_decl.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (union_decl.get_node_id (), cpath);\n+\n+  resolve_visibility (union_decl.get_visibility ());\n+\n+  NodeId scope_node_id = union_decl.get_node_id ();\n+  resolver->get_type_scope ().push (scope_node_id);\n+\n+  if (union_decl.has_generics ())\n+    for (auto &generic : union_decl.get_generic_params ())\n+      ResolveGenericParam::go (generic.get (), prefix, canonical_prefix);\n+\n+  if (union_decl.has_where_clause ())\n+    ResolveWhereClause::Resolve (union_decl.get_where_clause ());\n+\n+  for (AST::StructField &field : union_decl.get_variants ())\n+    {\n+      if (field.get_field_type ()->is_marked_for_strip ())\n+\tcontinue;\n+\n+      ResolveType::go (field.get_field_type ().get ());\n+    }\n+\n+  resolver->get_type_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::StaticItem &var)\n+{\n+  auto decl\n+    = CanonicalPath::new_seg (var.get_node_id (), var.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (var.get_node_id (), cpath);\n+\n+  ResolveType::go (var.get_type ().get ());\n+  ResolveExpr::go (var.get_expr ().get (), path, cpath);\n+}\n+\n+void\n+ResolveItem::visit (AST::ConstantItem &constant)\n+{\n+  auto decl = CanonicalPath::new_seg (constant.get_node_id (),\n+\t\t\t\t      constant.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (constant.get_node_id (), cpath);\n+\n+  resolve_visibility (constant.get_visibility ());\n+\n+  ResolveType::go (constant.get_type ().get ());\n+  ResolveExpr::go (constant.get_expr ().get (), path, cpath);\n+}\n+\n+void\n+ResolveItem::visit (AST::Function &function)\n+{\n+  auto decl = CanonicalPath::new_seg (function.get_node_id (),\n+\t\t\t\t      function.get_function_name ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+\n+  mappings->insert_canonical_path (function.get_node_id (), cpath);\n+\n+  resolve_visibility (function.get_visibility ());\n+\n+  NodeId scope_node_id = function.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  if (function.has_generics ())\n+    for (auto &generic : function.get_generic_params ())\n+      ResolveGenericParam::go (generic.get (), prefix, canonical_prefix);\n+\n+  // resolve any where clause items\n+  if (function.has_where_clause ())\n+    ResolveWhereClause::Resolve (function.get_where_clause ());\n+\n+  if (function.has_return_type ())\n+    ResolveType::go (function.get_return_type ().get ());\n+\n+  // we make a new scope so the names of parameters are resolved and shadowed\n+  // correctly\n+  for (auto &param : function.get_function_params ())\n+    {\n+      ResolveType::go (param.get_type ().get ());\n+      PatternDeclaration::go (param.get_pattern ().get ());\n+\n+      // the mutability checker needs to verify for immutable decls the number\n+      // of assignments are <1. This marks an implicit assignment\n+    }\n+\n+  // resolve the function body\n+  ResolveExpr::go (function.get_definition ().get (), path, cpath);\n+\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::InherentImpl &impl_block)\n+{\n+  NodeId scope_node_id = impl_block.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+\n+  resolve_visibility (impl_block.get_visibility ());\n+\n+  if (impl_block.has_generics ())\n+    for (auto &generic : impl_block.get_generic_params ())\n+      ResolveGenericParam::go (generic.get (), prefix, canonical_prefix);\n+\n+  // resolve any where clause items\n+  if (impl_block.has_where_clause ())\n+    ResolveWhereClause::Resolve (impl_block.get_where_clause ());\n+\n+  // FIXME this needs to be protected behind nominal type-checks see:\n+  // rustc --explain E0118\n+  ResolveType::go (impl_block.get_type ().get ());\n+\n+  // Setup paths\n+  CanonicalPath self_cpath = CanonicalPath::create_empty ();\n+  bool ok = ResolveTypeToCanonicalPath::go (impl_block.get_type ().get (),\n+\t\t\t\t\t    self_cpath);\n+  rust_assert (ok);\n+  rust_debug (\"AST::InherentImpl resolve Self: {%s}\",\n+\t      self_cpath.get ().c_str ());\n+\n+  CanonicalPath impl_type = self_cpath;\n+  CanonicalPath impl_prefix = prefix.append (impl_type);\n+\n+  // see https://godbolt.org/z/a3vMbsT6W\n+  CanonicalPath cpath = CanonicalPath::create_empty ();\n+  if (canonical_prefix.size () <= 1)\n+    {\n+      cpath = self_cpath;\n+    }\n+  else\n+    {\n+      std::string seg_buf = \"<impl \" + self_cpath.get () + \">\";\n+      CanonicalPath seg\n+\t= CanonicalPath::new_seg (impl_block.get_node_id (), seg_buf);\n+      cpath = canonical_prefix.append (seg);\n+    }\n+\n+  // done setup paths\n+\n+  auto Self\n+    = CanonicalPath::get_big_self (impl_block.get_type ()->get_node_id ());\n+\n+  resolver->get_type_scope ().insert (Self,\n+\t\t\t\t      impl_block.get_type ()->get_node_id (),\n+\t\t\t\t      impl_block.get_type ()->get_locus ());\n+\n+  for (auto &impl_item : impl_block.get_impl_items ())\n+    {\n+      rust_debug (\n+\t\"AST::InherentImpl resolve_impl_item: impl_prefix={%s} cpath={%s}\",\n+\timpl_prefix.get ().c_str (), cpath.get ().c_str ());\n+      resolve_impl_item (impl_item.get (), impl_prefix, cpath);\n+    }\n+\n+  resolver->get_type_scope ().peek ()->clear_name (\n+    Self, impl_block.get_type ()->get_node_id ());\n+\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_name_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::Method &method)\n+{\n+  auto decl\n+    = CanonicalPath::new_seg (method.get_node_id (), method.get_method_name ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (method.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = method.get_node_id ();\n+\n+  resolve_visibility (method.get_visibility ());\n+\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  if (method.has_generics ())\n+    for (auto &generic : method.get_generic_params ())\n+      ResolveGenericParam::go (generic.get (), prefix, canonical_prefix);\n+\n+  // resolve any where clause items\n+  if (method.has_where_clause ())\n+    ResolveWhereClause::Resolve (method.get_where_clause ());\n+\n+  if (method.has_return_type ())\n+    ResolveType::go (method.get_return_type ().get ());\n+\n+  // self turns into (self: Self) as a function param\n+  AST::SelfParam &self_param = method.get_self_param ();\n+  AST::IdentifierPattern self_pattern (self_param.get_node_id (), \"self\",\n+\t\t\t\t       self_param.get_locus (),\n+\t\t\t\t       self_param.get_has_ref (),\n+\t\t\t\t       self_param.get_is_mut (),\n+\t\t\t\t       std::unique_ptr<AST::Pattern> (nullptr));\n+\n+  std::vector<std::unique_ptr<AST::TypePathSegment>> segments;\n+  segments.push_back (std::unique_ptr<AST::TypePathSegment> (\n+    new AST::TypePathSegment (\"Self\", false, self_param.get_locus ())));\n+\n+  AST::TypePath self_type_path (std::move (segments), self_param.get_locus ());\n+\n+  ResolveType::go (&self_type_path);\n+  PatternDeclaration::go (&self_pattern);\n+\n+  // we make a new scope so the names of parameters are resolved and shadowed\n+  // correctly\n+  for (auto &param : method.get_function_params ())\n+    {\n+      ResolveType::go (param.get_type ().get ());\n+      PatternDeclaration::go (param.get_pattern ().get ());\n+    }\n+\n+  // resolve any where clause items\n+  if (method.has_where_clause ())\n+    ResolveWhereClause::Resolve (method.get_where_clause ());\n+\n+  // resolve the function body\n+  ResolveExpr::go (method.get_definition ().get (), path, cpath);\n+\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::TraitImpl &impl_block)\n+{\n+  NodeId scope_node_id = impl_block.get_node_id ();\n+\n+  resolve_visibility (impl_block.get_visibility ());\n+\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+\n+  if (impl_block.has_generics ())\n+    for (auto &generic : impl_block.get_generic_params ())\n+      ResolveGenericParam::go (generic.get (), prefix, canonical_prefix);\n+\n+  // resolve any where clause items\n+  if (impl_block.has_where_clause ())\n+    ResolveWhereClause::Resolve (impl_block.get_where_clause ());\n+\n+  // CanonicalPath canonical_trait_type = CanonicalPath::create_empty ();\n+  NodeId trait_resolved_node = ResolveType::go (&impl_block.get_trait_path ());\n+  if (trait_resolved_node == UNKNOWN_NODEID)\n+    {\n+      resolver->get_type_scope ().pop ();\n+      resolver->get_name_scope ().pop ();\n+      return;\n+    }\n+\n+  //   CanonicalPath canonical_impl_type = CanonicalPath::create_empty ();\n+  NodeId type_resolved_node = ResolveType::go (impl_block.get_type ().get ());\n+  if (type_resolved_node == UNKNOWN_NODEID)\n+    {\n+      resolver->get_type_scope ().pop ();\n+      resolver->get_name_scope ().pop ();\n+      return;\n+    }\n+\n+  bool ok;\n+  // setup paths\n+  CanonicalPath canonical_trait_type = CanonicalPath::create_empty ();\n+  ok = ResolveTypeToCanonicalPath::go (&impl_block.get_trait_path (),\n+\t\t\t\t       canonical_trait_type);\n+  rust_assert (ok);\n+\n+  rust_debug (\"AST::TraitImpl resolve trait type: {%s}\",\n+\t      canonical_trait_type.get ().c_str ());\n+\n+  CanonicalPath canonical_impl_type = CanonicalPath::create_empty ();\n+  ok = ResolveTypeToCanonicalPath::go (impl_block.get_type ().get (),\n+\t\t\t\t       canonical_impl_type);\n+  rust_assert (ok);\n+\n+  rust_debug (\"AST::TraitImpl resolve self: {%s}\",\n+\t      canonical_impl_type.get ().c_str ());\n+\n+  // raw paths\n+  CanonicalPath impl_type_seg = canonical_impl_type;\n+  CanonicalPath trait_type_seg = canonical_trait_type;\n+  CanonicalPath projection\n+    = CanonicalPath::trait_impl_projection_seg (impl_block.get_node_id (),\n+\t\t\t\t\t\ttrait_type_seg, impl_type_seg);\n+  CanonicalPath impl_prefix = prefix.append (projection);\n+\n+  // setup canonical-path\n+  CanonicalPath canonical_projection\n+    = CanonicalPath::trait_impl_projection_seg (impl_block.get_node_id (),\n+\t\t\t\t\t\tcanonical_trait_type,\n+\t\t\t\t\t\tcanonical_impl_type);\n+  CanonicalPath cpath = CanonicalPath::create_empty ();\n+  if (canonical_prefix.size () <= 1)\n+    {\n+      cpath = canonical_projection;\n+    }\n+  else\n+    {\n+      std::string projection_str = canonical_projection.get ();\n+      std::string seg_buf\n+\t= \"<impl \" + projection_str.substr (1, projection_str.size () - 2)\n+\t  + \">\";\n+      CanonicalPath seg\n+\t= CanonicalPath::new_seg (impl_block.get_node_id (), seg_buf);\n+      cpath = canonical_prefix.append (seg);\n+    }\n+\n+  // DONE setup canonical-path\n+\n+  auto Self\n+    = CanonicalPath::get_big_self (impl_block.get_type ()->get_node_id ());\n+\n+  resolver->get_type_scope ().insert (Self,\n+\t\t\t\t      impl_block.get_type ()->get_node_id (),\n+\t\t\t\t      impl_block.get_type ()->get_locus ());\n+\n+  for (auto &impl_item : impl_block.get_impl_items ())\n+    {\n+      rust_debug (\n+\t\"AST::TraitImpl resolve_impl_item: impl_prefix={%s} cpath={%s}\",\n+\timpl_prefix.get ().c_str (), cpath.get ().c_str ());\n+      resolve_impl_item (impl_item.get (), impl_prefix, cpath);\n+    }\n+\n+  resolver->get_type_scope ().peek ()->clear_name (\n+    Self, impl_block.get_type ()->get_node_id ());\n+  resolver->get_type_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::Trait &trait)\n+{\n+  NodeId scope_node_id = trait.get_node_id ();\n+\n+  resolve_visibility (trait.get_visibility ());\n+\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+\n+  // we need to inject an implicit self TypeParam here\n+  AST::TypeParam *implicit_self\n+    = new AST::TypeParam (\"Self\", trait.get_locus ());\n+  trait.insert_implict_self (\n+    std::unique_ptr<AST::GenericParam> (implicit_self));\n+  CanonicalPath Self = CanonicalPath::get_big_self (trait.get_node_id ());\n+\n+  for (auto &generic : trait.get_generic_params ())\n+    ResolveGenericParam::go (generic.get (), prefix, canonical_prefix);\n+\n+  // Self is an implicit TypeParam so lets mark it as such\n+  resolver->get_type_scope ().append_reference_for_def (\n+    Self.get_node_id (), implicit_self->get_node_id ());\n+\n+  if (trait.has_type_param_bounds ())\n+    {\n+      for (auto &bound : trait.get_type_param_bounds ())\n+\t{\n+\t  ResolveTypeBound::go (bound.get ());\n+\t}\n+    }\n+\n+  // resolve any where clause items\n+  if (trait.has_where_clause ())\n+    ResolveWhereClause::Resolve (trait.get_where_clause ());\n+\n+  // resolve the paths\n+  CanonicalPath path = CanonicalPath::create_empty ();\n+  CanonicalPath cpath = CanonicalPath::create_empty ();\n+  //\n+\n+  for (auto &item : trait.get_trait_items ())\n+    {\n+      ResolveTraitItems::go (item.get (), path, cpath);\n+    }\n+\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_name_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::ExternBlock &extern_block)\n+{\n+  resolve_visibility (extern_block.get_visibility ());\n+\n+  for (auto &item : extern_block.get_extern_items ())\n+    {\n+      resolve_extern_item (item.get ());\n+    }\n+}\n+\n+void\n+ResolveItem::resolve_impl_item (AST::TraitImplItem *item,\n+\t\t\t\tconst CanonicalPath &prefix,\n+\t\t\t\tconst CanonicalPath &canonical_prefix)\n+{\n+  ResolveImplItems::go (item, prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveItem::resolve_impl_item (AST::InherentImplItem *item,\n+\t\t\t\tconst CanonicalPath &prefix,\n+\t\t\t\tconst CanonicalPath &canonical_prefix)\n+{\n+  ResolveImplItems::go (item, prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveItem::resolve_extern_item (AST::ExternalItem *item)\n+{\n+  ResolveExternItem::go (item, prefix, canonical_prefix);\n+}\n+\n+static void\n+flatten_glob (const AST::UseTreeGlob &glob,\n+\t      std::vector<AST::SimplePath> &paths);\n+static void\n+flatten_rebind (const AST::UseTreeRebind &glob,\n+\t\tstd::vector<AST::SimplePath> &paths);\n+static void\n+flatten_list (const AST::UseTreeList &glob,\n+\t      std::vector<AST::SimplePath> &paths);\n+\n+static void\n+flatten (const AST::UseTree *tree, std::vector<AST::SimplePath> &paths)\n+{\n+  switch (tree->get_kind ())\n+    {\n+      case AST::UseTree::Glob: {\n+\tauto glob = static_cast<const AST::UseTreeGlob *> (tree);\n+\tflatten_glob (*glob, paths);\n+\tbreak;\n+      }\n+      case AST::UseTree::Rebind: {\n+\tauto rebind = static_cast<const AST::UseTreeRebind *> (tree);\n+\tflatten_rebind (*rebind, paths);\n+\tbreak;\n+      }\n+      case AST::UseTree::List: {\n+\tauto list = static_cast<const AST::UseTreeList *> (tree);\n+\tflatten_list (*list, paths);\n+\tbreak;\n+      }\n+      break;\n+    }\n+}\n+\n+static void\n+flatten_glob (const AST::UseTreeGlob &glob, std::vector<AST::SimplePath> &paths)\n+{\n+  if (glob.has_path ())\n+    paths.emplace_back (glob.get_path ());\n+}\n+\n+static void\n+flatten_rebind (const AST::UseTreeRebind &rebind,\n+\t\tstd::vector<AST::SimplePath> &paths)\n+{\n+  auto path = rebind.get_path ();\n+  if (rebind.has_path ())\n+    paths.emplace_back (path);\n+\n+  // FIXME: Do we want to emplace the rebind here as well?\n+  if (rebind.has_identifier ())\n+    {\n+      auto rebind_path = path;\n+      auto new_seg = rebind.get_identifier ();\n+\n+      // Add the identifier as a new path\n+      rebind_path.get_segments ().back ()\n+\t= AST::SimplePathSegment (new_seg, Location ());\n+\n+      paths.emplace_back (rebind_path);\n+    }\n+}\n+\n+static void\n+flatten_list (const AST::UseTreeList &list, std::vector<AST::SimplePath> &paths)\n+{\n+  auto prefix = AST::SimplePath::create_empty ();\n+  if (list.has_path ())\n+    prefix = list.get_path ();\n+\n+  for (const auto &tree : list.get_trees ())\n+    {\n+      auto sub_paths = std::vector<AST::SimplePath> ();\n+      flatten (tree.get (), sub_paths);\n+\n+      for (auto &sub_path : sub_paths)\n+\t{\n+\t  auto new_path = prefix;\n+\t  std::copy (sub_path.get_segments ().begin (),\n+\t\t     sub_path.get_segments ().end (),\n+\t\t     std::back_inserter (new_path.get_segments ()));\n+\n+\t  paths.emplace_back (new_path);\n+\t}\n+    }\n+}\n+\n+/**\n+ * Flatten a UseDeclaration's UseTree into multiple simple paths to resolve.\n+ *\n+ * Given the following use declarations:\n+ * ```\n+ * use some::path::to_resolve; #1\n+ * use some::path::to_glob::*; #2\n+ * use some::path::{one, two}; #2\n+ * ```\n+ *\n+ * In the first case, we simply want to return a vector with a single\n+ * SimplePath:\n+ * [some::path::to_resolve]\n+ *\n+ * In the second case, we want to resolve the glob's \"origin path\":\n+ * [some::path::to_glob]\n+ *\n+ * Finally in the third case, we want to create two SimplePaths to resolve:\n+ * [some::path::one, some::path::two]\n+ */\n+static std::vector<AST::SimplePath>\n+flatten_use_dec_to_paths (const AST::UseDeclaration &use_item)\n+{\n+  auto paths = std::vector<AST::SimplePath> ();\n+\n+  const auto &tree = use_item.get_tree ();\n+  flatten (tree.get (), paths);\n+\n+  return paths;\n+}\n+\n+void\n+ResolveItem::visit (AST::UseDeclaration &use_item)\n+{\n+  auto to_resolve = flatten_use_dec_to_paths (use_item);\n+\n+  for (auto &path : to_resolve)\n+    ResolvePath::go (&path);\n+}\n+\n+ResolveImplItems::ResolveImplItems (const CanonicalPath &prefix,\n+\t\t\t\t    const CanonicalPath &canonical_prefix)\n+  : ResolveItem (prefix, canonical_prefix)\n+{}\n+\n+void\n+ResolveImplItems::go (AST::InherentImplItem *item, const CanonicalPath &prefix,\n+\t\t      const CanonicalPath &canonical_prefix)\n+{\n+  if (item->is_marked_for_strip ())\n+    return;\n+\n+  ResolveImplItems resolver (prefix, canonical_prefix);\n+  item->accept_vis (resolver);\n+}\n+\n+void\n+ResolveImplItems::go (AST::TraitImplItem *item, const CanonicalPath &prefix,\n+\t\t      const CanonicalPath &canonical_prefix)\n+{\n+  if (item->is_marked_for_strip ())\n+    return;\n+\n+  ResolveImplItems resolver (prefix, canonical_prefix);\n+  item->accept_vis (resolver);\n+}\n+\n+void\n+ResolveImplItems::visit (AST::TypeAlias &alias)\n+{\n+  ResolveItem::visit (alias);\n+\n+  resolve_visibility (alias.get_visibility ());\n+\n+  // FIXME this stops the erronious unused decls which will be fixed later on\n+  resolver->get_type_scope ().append_reference_for_def (alias.get_node_id (),\n+\t\t\t\t\t\t\talias.get_node_id ());\n+}\n+\n+void\n+ResolveExternItem::go (AST::ExternalItem *item, const CanonicalPath &prefix,\n+\t\t       const CanonicalPath &canonical_prefix)\n+{\n+  ResolveExternItem resolver (prefix, canonical_prefix);\n+  item->accept_vis (resolver);\n+}\n+\n+void\n+ResolveExternItem::visit (AST::ExternalFunctionItem &function)\n+{\n+  NodeId scope_node_id = function.get_node_id ();\n+  auto decl = CanonicalPath::new_seg (function.get_node_id (),\n+\t\t\t\t      function.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+\n+  mappings->insert_canonical_path (function.get_node_id (), cpath);\n+\n+  resolve_visibility (function.get_visibility ());\n+\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  // resolve the generics\n+  if (function.has_generics ())\n+    for (auto &generic : function.get_generic_params ())\n+      ResolveGenericParam::go (generic.get (), prefix, canonical_prefix);\n+\n+  if (function.has_return_type ())\n+    ResolveType::go (function.get_return_type ().get ());\n+\n+  // we make a new scope so the names of parameters are resolved and shadowed\n+  // correctly\n+  for (auto &param : function.get_function_params ())\n+    {\n+      ResolveType::go (param.get_type ().get ());\n+    }\n+\n+  // done\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveExternItem::visit (AST::ExternalStaticItem &item)\n+{\n+  resolve_visibility (item.get_visibility ());\n+\n+  ResolveType::go (item.get_type ().get ());\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+static void\n+rust_flatten_nested_glob (void)\n+{\n+  auto foo = Rust::AST::SimplePathSegment (\"foo\", Location ());\n+  auto bar = Rust::AST::SimplePathSegment (\"bar\", Location ());\n+  auto foobar = Rust::AST::SimplePath ({foo, bar});\n+\n+  auto glob\n+    = Rust::AST::UseTreeGlob (Rust::AST::UseTreeGlob::PathType::PATH_PREFIXED,\n+\t\t\t      foobar, Location ());\n+\n+  auto paths = std::vector<Rust::AST::SimplePath> ();\n+  Rust::Resolver::flatten_glob (glob, paths);\n+\n+  ASSERT_TRUE (!paths.empty ());\n+  ASSERT_EQ (paths.size (), 1);\n+  ASSERT_EQ (paths[0].get_segments ()[0].as_string (), \"foo\");\n+  ASSERT_EQ (paths[0].get_segments ()[1].as_string (), \"bar\");\n+}\n+\n+static void\n+rust_flatten_glob (void)\n+{\n+  auto frob = Rust::AST::SimplePath::from_str (\"frobulator\", Location ());\n+\n+  auto glob\n+    = Rust::AST::UseTreeGlob (Rust::AST::UseTreeGlob::PathType::PATH_PREFIXED,\n+\t\t\t      frob, Location ());\n+\n+  auto paths = std::vector<Rust::AST::SimplePath> ();\n+  Rust::Resolver::flatten_glob (glob, paths);\n+\n+  ASSERT_TRUE (!paths.empty ());\n+  ASSERT_EQ (paths.size (), 1);\n+  ASSERT_EQ (paths[0], \"frobulator\");\n+}\n+\n+static void\n+rust_flatten_rebind_none (void)\n+{\n+  auto foo = Rust::AST::SimplePathSegment (\"foo\", Location ());\n+  auto bar = Rust::AST::SimplePathSegment (\"bar\", Location ());\n+  auto foobar = Rust::AST::SimplePath ({foo, bar});\n+\n+  auto rebind = Rust::AST::UseTreeRebind (Rust::AST::UseTreeRebind::NONE,\n+\t\t\t\t\t  foobar, Location ());\n+\n+  auto paths = std::vector<Rust::AST::SimplePath> ();\n+  Rust::Resolver::flatten_rebind (rebind, paths);\n+\n+  ASSERT_TRUE (!paths.empty ());\n+  ASSERT_EQ (paths.size (), 1);\n+  ASSERT_EQ (paths[0].get_segments ()[0].as_string (), \"foo\");\n+  ASSERT_EQ (paths[0].get_segments ()[1].as_string (), \"bar\");\n+}\n+\n+static void\n+rust_flatten_rebind (void)\n+{\n+  auto frob = Rust::AST::SimplePath::from_str (\"frobulator\", Location ());\n+\n+  auto rebind = Rust::AST::UseTreeRebind (Rust::AST::UseTreeRebind::IDENTIFIER,\n+\t\t\t\t\t  frob, Location (), \"saindoux\");\n+\n+  auto paths = std::vector<Rust::AST::SimplePath> ();\n+  Rust::Resolver::flatten_rebind (rebind, paths);\n+\n+  ASSERT_TRUE (!paths.empty ());\n+  ASSERT_EQ (paths.size (), 2);\n+  ASSERT_EQ (paths[0], \"frobulator\");\n+  ASSERT_EQ (paths[1], \"saindoux\");\n+}\n+\n+static void\n+rust_flatten_rebind_nested (void)\n+{\n+  auto foo = Rust::AST::SimplePathSegment (\"foo\", Location ());\n+  auto bar = Rust::AST::SimplePathSegment (\"bar\", Location ());\n+  auto baz = Rust::AST::SimplePathSegment (\"baz\", Location ());\n+\n+  auto foo_bar_baz = Rust::AST::SimplePath ({foo, bar, baz});\n+\n+  auto rebind = Rust::AST::UseTreeRebind (Rust::AST::UseTreeRebind::IDENTIFIER,\n+\t\t\t\t\t  foo_bar_baz, Location (), \"saindoux\");\n+\n+  auto paths = std::vector<Rust::AST::SimplePath> ();\n+  Rust::Resolver::flatten_rebind (rebind, paths);\n+\n+  ASSERT_TRUE (!paths.empty ());\n+  ASSERT_EQ (paths.size (), 2);\n+  ASSERT_EQ (paths[0].get_segments ()[0].as_string (), \"foo\");\n+  ASSERT_EQ (paths[0].get_segments ()[1].as_string (), \"bar\");\n+  ASSERT_EQ (paths[0].get_segments ()[2].as_string (), \"baz\");\n+  ASSERT_EQ (paths[1].get_segments ()[0].as_string (), \"foo\");\n+  ASSERT_EQ (paths[1].get_segments ()[1].as_string (), \"bar\");\n+  ASSERT_EQ (paths[1].get_segments ()[2].as_string (), \"saindoux\");\n+}\n+\n+static void\n+rust_flatten_list (void)\n+{\n+  auto foo = Rust::AST::SimplePathSegment (\"foo\", Location ());\n+  auto bar = Rust::AST::SimplePathSegment (\"bar\", Location ());\n+  auto foo_bar = Rust::AST::SimplePath ({foo, bar});\n+\n+  auto baz = Rust::AST::SimplePath::from_str (\"baz\", Location ());\n+  auto bul = Rust::AST::SimplePath::from_str (\"bul\", Location ());\n+\n+  // use foo::bar::{baz, bul};\n+\n+  auto use0 = std::unique_ptr<Rust::AST::UseTree> (\n+    new Rust::AST::UseTreeRebind (Rust::AST::UseTreeRebind::NONE, baz,\n+\t\t\t\t  Location ()));\n+  auto use1 = std::unique_ptr<Rust::AST::UseTree> (\n+    new Rust::AST::UseTreeRebind (Rust::AST::UseTreeRebind::NONE, bul,\n+\t\t\t\t  Location ()));\n+\n+  auto uses = std::vector<std::unique_ptr<Rust::AST::UseTree>> ();\n+  uses.emplace_back (std::move (use0));\n+  uses.emplace_back (std::move (use1));\n+\n+  auto list = Rust::AST::UseTreeList (Rust::AST::UseTreeList::PATH_PREFIXED,\n+\t\t\t\t      foo_bar, std::move (uses), Location ());\n+\n+  auto paths = std::vector<Rust::AST::SimplePath> ();\n+  Rust::Resolver::flatten_list (list, paths);\n+\n+  for (auto &path : paths)\n+    fprintf (stderr, \"%s\\n\", path.as_string ().c_str ());\n+\n+  ASSERT_TRUE (!paths.empty ());\n+  ASSERT_EQ (paths.size (), 2);\n+  ASSERT_EQ (paths[0].get_segments ()[0].as_string (), \"foo\");\n+  ASSERT_EQ (paths[0].get_segments ()[1].as_string (), \"bar\");\n+  ASSERT_EQ (paths[0].get_segments ()[2].as_string (), \"baz\");\n+  ASSERT_EQ (paths[1].get_segments ()[0].as_string (), \"foo\");\n+  ASSERT_EQ (paths[1].get_segments ()[1].as_string (), \"bar\");\n+  ASSERT_EQ (paths[1].get_segments ()[2].as_string (), \"bul\");\n+}\n+\n+static void\n+rust_use_dec_flattening (void)\n+{\n+  rust_flatten_glob ();\n+  rust_flatten_nested_glob ();\n+  rust_flatten_rebind_none ();\n+  rust_flatten_rebind ();\n+  rust_flatten_rebind_nested ();\n+  rust_flatten_list ();\n+}\n+\n+void\n+rust_simple_path_resolve_test (void)\n+{\n+  rust_use_dec_flattening ();\n+}\n+\n+} // namespace selftest\n+\n+#endif // CHECKING_P"}, {"sha": "ce521f057f6846bc7247cee3967c97f238854d63", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=85a8fe00f805e7889b4e67a98ae1d435c042166b", "patch": "@@ -0,0 +1,149 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_ITEM_H\n+#define RUST_AST_RESOLVE_ITEM_H\n+\n+#include \"rust-ast-full-decls.h\"\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-ast-resolve-toplevel.h\"\n+#include \"rust-ast-resolve-type.h\"\n+#include \"rust-ast-resolve-pattern.h\"\n+#include \"rust-ast-resolve-stmt.h\"\n+#include \"config.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolveTraitItems : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static void go (AST::TraitItem *item, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix);\n+\n+  void visit (AST::TraitItemType &type) override;\n+  void visit (AST::TraitItemFunc &func) override;\n+  void visit (AST::TraitItemMethod &func) override;\n+  void visit (AST::TraitItemConst &constant) override;\n+\n+private:\n+  ResolveTraitItems (const CanonicalPath &prefix,\n+\t\t     const CanonicalPath &canonical_prefix);\n+\n+  const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n+};\n+\n+class ResolveItem : public ResolverBase\n+{\n+public:\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+  static void go (AST::Item *item, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix);\n+\n+  void visit (AST::TypeAlias &alias) override;\n+  void visit (AST::Module &module) override;\n+  void visit (AST::TupleStruct &struct_decl) override;\n+  void visit (AST::Enum &enum_decl) override;\n+  /* EnumItem doesn't need to be handled, no fields.  */\n+  void visit (AST::EnumItem &item) override;\n+  void visit (AST::EnumItemTuple &item) override;\n+  void visit (AST::EnumItemStruct &item) override;\n+  void visit (AST::EnumItemDiscriminant &item) override;\n+  void visit (AST::StructStruct &struct_decl) override;\n+  void visit (AST::Union &union_decl) override;\n+  void visit (AST::StaticItem &var) override;\n+  void visit (AST::ConstantItem &constant) override;\n+  void visit (AST::Function &function) override;\n+  void visit (AST::InherentImpl &impl_block) override;\n+  void visit (AST::Method &method) override;\n+  void visit (AST::TraitImpl &impl_block) override;\n+  void visit (AST::Trait &trait) override;\n+  void visit (AST::ExternBlock &extern_block) override;\n+  void visit (AST::UseDeclaration &) override;\n+\n+protected:\n+  void resolve_impl_item (AST::TraitImplItem *item, const CanonicalPath &prefix,\n+\t\t\t  const CanonicalPath &canonical_prefix);\n+  void resolve_impl_item (AST::InherentImplItem *item,\n+\t\t\t  const CanonicalPath &prefix,\n+\t\t\t  const CanonicalPath &canonical_prefix);\n+  void resolve_extern_item (AST::ExternalItem *item);\n+\n+  ResolveItem (const CanonicalPath &prefix,\n+\t       const CanonicalPath &canonical_prefix);\n+\n+  const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n+};\n+\n+class ResolveImplItems : public ResolveItem\n+{\n+  using Rust::Resolver::ResolveItem::visit;\n+\n+public:\n+  static void go (AST::InherentImplItem *item, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix);\n+  static void go (AST::TraitImplItem *item, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix);\n+\n+  void visit (AST::TypeAlias &alias) override;\n+\n+private:\n+  ResolveImplItems (const CanonicalPath &prefix,\n+\t\t    const CanonicalPath &canonical_prefix);\n+};\n+\n+class ResolveExternItem : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static void go (AST::ExternalItem *item, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix);\n+\n+  void visit (AST::ExternalFunctionItem &function) override;\n+  void visit (AST::ExternalStaticItem &item) override;\n+\n+private:\n+  ResolveExternItem (const CanonicalPath &prefix,\n+\t\t     const CanonicalPath &canonical_prefix)\n+    : ResolverBase (), prefix (prefix), canonical_prefix (canonical_prefix)\n+  {}\n+\n+  const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+extern void\n+rust_simple_path_resolve_test (void);\n+} // namespace selftest\n+\n+#endif // CHECKING_P\n+\n+#endif // RUST_AST_RESOLVE_ITEM_H"}, {"sha": "b139c6a87202664bf45875c57b16bde7aec69db2", "filename": "gcc/rust/resolve/rust-ast-resolve-path.cc", "status": "added", "additions": 384, "deletions": 0, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc?ref=85a8fe00f805e7889b4e67a98ae1d435c042166b", "patch": "@@ -0,0 +1,384 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-resolve-path.h\"\n+#include \"rust-ast-resolve-type.h\"\n+#include \"rust-path.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+ResolvePath::ResolvePath () : ResolverBase () {}\n+\n+void\n+ResolvePath::go (AST::PathInExpression *expr)\n+{\n+  ResolvePath resolver;\n+  resolver.resolve_path (expr);\n+}\n+\n+void\n+ResolvePath::go (AST::QualifiedPathInExpression *expr)\n+{\n+  ResolvePath resolver;\n+  resolver.resolve_path (expr);\n+}\n+\n+void\n+ResolvePath::go (AST::SimplePath *expr)\n+{\n+  ResolvePath resolver;\n+  resolver.resolve_path (expr);\n+}\n+\n+void\n+ResolvePath::resolve_path (AST::PathInExpression *expr)\n+{\n+  NodeId resolved_node_id = UNKNOWN_NODEID;\n+  NodeId module_scope_id = resolver->peek_current_module_scope ();\n+  NodeId previous_resolved_node_id = module_scope_id;\n+  for (size_t i = 0; i < expr->get_segments ().size (); i++)\n+    {\n+      auto &segment = expr->get_segments ().at (i);\n+      const AST::PathIdentSegment &ident_seg = segment.get_ident_segment ();\n+      bool is_first_segment = i == 0;\n+      resolved_node_id = UNKNOWN_NODEID;\n+\n+      bool in_middle_of_path = i > 0;\n+      if (in_middle_of_path && segment.is_lower_self_seg ())\n+\t{\n+\t  // error[E0433]: failed to resolve: `self` in paths can only be used\n+\t  // in start position\n+\t  rust_error_at (segment.get_locus (),\n+\t\t\t \"failed to resolve: %<%s%> in paths can only be used \"\n+\t\t\t \"in start position\",\n+\t\t\t segment.as_string ().c_str ());\n+\t  return;\n+\t}\n+\n+      NodeId crate_scope_id = resolver->peek_crate_module_scope ();\n+      if (segment.is_crate_path_seg ())\n+\t{\n+\t  // what is the current crate scope node id?\n+\t  module_scope_id = crate_scope_id;\n+\t  previous_resolved_node_id = module_scope_id;\n+\t  resolver->insert_resolved_name (segment.get_node_id (),\n+\t\t\t\t\t  module_scope_id);\n+\t  continue;\n+\t}\n+      else if (segment.is_super_path_seg ())\n+\t{\n+\t  if (module_scope_id == crate_scope_id)\n+\t    {\n+\t      rust_error_at (segment.get_locus (),\n+\t\t\t     \"cannot use %<super%> at the crate scope\");\n+\t      return;\n+\t    }\n+\n+\t  module_scope_id = resolver->peek_parent_module_scope ();\n+\t  previous_resolved_node_id = module_scope_id;\n+\t  resolver->insert_resolved_name (segment.get_node_id (),\n+\t\t\t\t\t  module_scope_id);\n+\t  continue;\n+\t}\n+\n+      // resolve any generic args\n+      if (segment.has_generic_args ())\n+\tResolveGenericArgs::go (segment.get_generic_args ());\n+\n+      // logic is awkward here there are a few cases\n+      //\n+      // T::Default\n+      // mod::foo::impl_item\n+      // super::super::module::item\n+      // self\n+      // self::foo\n+      // self::foo::baz\n+      //\n+      // T::Default we can only resolve the T and cant do anything about Default\n+      // its dependant on associated types\n+      //\n+      // mod::foo::impl_item\n+      // we can resolve mod::foo but nothing about impl_item but we need to\n+      // _always resolve generic arguments\n+      //\n+      // self is a simple single lookup\n+      //\n+      // we have module_scope_id for the next module_scope to lookup\n+      // resolved_node_id is the thing we have resolve this segment to\n+      //\n+      // new algo?\n+      // we can only use module resolution when the previous segment is either\n+      // unknown or equal to this module_scope_id\n+      //\n+      // can only use old resolution when previous segment is unkown\n+\n+      if (is_first_segment)\n+\t{\n+\t  // name scope first\n+\t  NodeId resolved_node = UNKNOWN_NODEID;\n+\t  const CanonicalPath path\n+\t    = CanonicalPath::new_seg (segment.get_node_id (),\n+\t\t\t\t      ident_seg.as_string ());\n+\t  if (resolver->get_name_scope ().lookup (path, &resolved_node))\n+\t    {\n+\t      resolver->insert_resolved_name (segment.get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t      resolved_node_id = resolved_node;\n+\t    }\n+\t  // check the type scope\n+\t  else if (resolver->get_type_scope ().lookup (path, &resolved_node))\n+\t    {\n+\t      resolver->insert_resolved_type (segment.get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t      resolved_node_id = resolved_node;\n+\t    }\n+\t  else if (segment.is_lower_self_seg ())\n+\t    {\n+\t      module_scope_id = crate_scope_id;\n+\t      previous_resolved_node_id = module_scope_id;\n+\t      resolver->insert_resolved_name (segment.get_node_id (),\n+\t\t\t\t\t      module_scope_id);\n+\t      continue;\n+\t    }\n+\t  else\n+\t    {\n+\t      // no error handling here since we might be able to resolve via\n+\t      // the module hierarchy and handle errors at the end\n+\t    }\n+\t}\n+\n+      if (resolved_node_id == UNKNOWN_NODEID\n+\t  && previous_resolved_node_id == module_scope_id)\n+\t{\n+\t  Optional<CanonicalPath &> resolved_child\n+\t    = mappings->lookup_module_child (module_scope_id,\n+\t\t\t\t\t     ident_seg.as_string ());\n+\t  if (resolved_child.is_some ())\n+\t    {\n+\t      NodeId resolved_node = resolved_child->get_node_id ();\n+\t      if (resolver->get_name_scope ().decl_was_declared_here (\n+\t\t    resolved_node))\n+\t\t{\n+\t\t  resolved_node_id = resolved_node;\n+\t\t  resolver->insert_resolved_name (segment.get_node_id (),\n+\t\t\t\t\t\t  resolved_node);\n+\t\t}\n+\t      else if (resolver->get_type_scope ().decl_was_declared_here (\n+\t\t\t resolved_node))\n+\t\t{\n+\t\t  resolved_node_id = resolved_node;\n+\t\t  resolver->insert_resolved_type (segment.get_node_id (),\n+\t\t\t\t\t\t  resolved_node);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  rust_error_at (segment.get_locus (),\n+\t\t\t\t \"Cannot find path %<%s%> in this scope\",\n+\t\t\t\t segment.as_string ().c_str ());\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t}\n+\n+      bool did_resolve_segment = resolved_node_id != UNKNOWN_NODEID;\n+      if (did_resolve_segment)\n+\t{\n+\t  if (mappings->node_is_module (resolved_node_id)\n+\t      || mappings->node_is_crate (resolved_node_id))\n+\t    {\n+\t      module_scope_id = resolved_node_id;\n+\t    }\n+\t  previous_resolved_node_id = resolved_node_id;\n+\t}\n+      else if (is_first_segment)\n+\t{\n+\t  rust_error_at (segment.get_locus (),\n+\t\t\t \"Cannot find path %<%s%> in this scope\",\n+\t\t\t segment.as_string ().c_str ());\n+\t  return;\n+\t}\n+    }\n+\n+  resolved_node = resolved_node_id;\n+  if (resolved_node_id != UNKNOWN_NODEID)\n+    {\n+      // name scope first\n+      if (resolver->get_name_scope ().decl_was_declared_here (resolved_node_id))\n+\t{\n+\t  resolver->insert_resolved_name (expr->get_node_id (),\n+\t\t\t\t\t  resolved_node_id);\n+\t}\n+      // check the type scope\n+      else if (resolver->get_type_scope ().decl_was_declared_here (\n+\t\t resolved_node_id))\n+\t{\n+\t  resolver->insert_resolved_type (expr->get_node_id (),\n+\t\t\t\t\t  resolved_node_id);\n+\t}\n+      else\n+\t{\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+}\n+\n+void\n+ResolvePath::resolve_path (AST::QualifiedPathInExpression *expr)\n+{\n+  AST::QualifiedPathType &root_segment = expr->get_qualified_path_type ();\n+  ResolveType::go (root_segment.get_type ().get ());\n+  if (root_segment.has_as_clause ())\n+    ResolveType::go (&root_segment.get_as_type_path ());\n+\n+  for (auto &segment : expr->get_segments ())\n+    {\n+      // we cant actually do anything with the segment itself since this is all\n+      // the job of the type system to figure it out but we can resolve any\n+      // generic arguments used\n+      if (segment.has_generic_args ())\n+\tResolveGenericArgs::go (segment.get_generic_args ());\n+    }\n+}\n+\n+void\n+ResolvePath::resolve_path (AST::SimplePath *expr)\n+{\n+  NodeId crate_scope_id = resolver->peek_crate_module_scope ();\n+  NodeId module_scope_id = resolver->peek_current_module_scope ();\n+\n+  NodeId resolved_node_id = UNKNOWN_NODEID;\n+  for (size_t i = 0; i < expr->get_segments ().size (); i++)\n+    {\n+      auto &segment = expr->get_segments ().at (i);\n+      bool is_first_segment = i == 0;\n+      resolved_node_id = UNKNOWN_NODEID;\n+\n+      if (segment.is_crate_path_seg ())\n+\t{\n+\t  // what is the current crate scope node id?\n+\t  module_scope_id = crate_scope_id;\n+\t  resolver->insert_resolved_name (segment.get_node_id (),\n+\t\t\t\t\t  module_scope_id);\n+\t  continue;\n+\t}\n+      else if (segment.is_super_path_seg ())\n+\t{\n+\t  if (module_scope_id == crate_scope_id)\n+\t    {\n+\t      rust_error_at (segment.get_locus (),\n+\t\t\t     \"cannot use %<super%> at the crate scope\");\n+\t      return;\n+\t    }\n+\n+\t  module_scope_id = resolver->peek_parent_module_scope ();\n+\t  resolver->insert_resolved_name (segment.get_node_id (),\n+\t\t\t\t\t  module_scope_id);\n+\t  continue;\n+\t}\n+\n+      Optional<CanonicalPath &> resolved_child\n+\t= mappings->lookup_module_child (module_scope_id,\n+\t\t\t\t\t segment.get_segment_name ());\n+      if (resolved_child.is_some ())\n+\t{\n+\t  NodeId resolved_node = resolved_child->get_node_id ();\n+\t  if (resolver->get_name_scope ().decl_was_declared_here (\n+\t\tresolved_node))\n+\t    {\n+\t      resolved_node_id = resolved_node;\n+\t      resolver->insert_resolved_name (segment.get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t    }\n+\t  else if (resolver->get_type_scope ().decl_was_declared_here (\n+\t\t     resolved_node))\n+\t    {\n+\t      resolved_node_id = resolved_node;\n+\t      resolver->insert_resolved_type (segment.get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t    }\n+\t  else\n+\t    {\n+\t      rust_error_at (segment.get_locus (),\n+\t\t\t     \"Cannot find path %<%s%> in this scope\",\n+\t\t\t     segment.as_string ().c_str ());\n+\t      return;\n+\t    }\n+\t}\n+\n+      if (resolved_node_id == UNKNOWN_NODEID && is_first_segment)\n+\t{\n+\t  // name scope first\n+\t  NodeId resolved_node = UNKNOWN_NODEID;\n+\t  const CanonicalPath path\n+\t    = CanonicalPath::new_seg (segment.get_node_id (),\n+\t\t\t\t      segment.get_segment_name ());\n+\t  if (resolver->get_name_scope ().lookup (path, &resolved_node))\n+\t    {\n+\t      resolved_node_id = resolved_node;\n+\t      resolver->insert_resolved_name (segment.get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t    }\n+\t  // check the type scope\n+\t  else if (resolver->get_type_scope ().lookup (path, &resolved_node))\n+\t    {\n+\t      resolved_node_id = resolved_node;\n+\t      resolver->insert_resolved_type (segment.get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t    }\n+\t}\n+\n+      if (resolved_node_id == UNKNOWN_NODEID)\n+\t{\n+\t  rust_error_at (segment.get_locus (),\n+\t\t\t \"cannot find simple path segment %<%s%> in this scope\",\n+\t\t\t segment.as_string ().c_str ());\n+\t  return;\n+\t}\n+\n+      if (mappings->node_is_module (resolved_node_id))\n+\t{\n+\t  module_scope_id = resolved_node_id;\n+\t}\n+    }\n+\n+  resolved_node = resolved_node_id;\n+  if (resolved_node_id != UNKNOWN_NODEID)\n+    {\n+      // name scope first\n+      if (resolver->get_name_scope ().decl_was_declared_here (resolved_node_id))\n+\t{\n+\t  resolver->insert_resolved_name (expr->get_node_id (),\n+\t\t\t\t\t  resolved_node_id);\n+\t}\n+      // check the type scope\n+      else if (resolver->get_type_scope ().decl_was_declared_here (\n+\t\t resolved_node_id))\n+\t{\n+\t  resolver->insert_resolved_type (expr->get_node_id (),\n+\t\t\t\t\t  resolved_node_id);\n+\t}\n+      else\n+\t{\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "a9af0c5819c025b0d93f5b5b2cf822b69a48a1cb", "filename": "gcc/rust/resolve/rust-ast-resolve-path.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.h?ref=85a8fe00f805e7889b4e67a98ae1d435c042166b", "patch": "@@ -0,0 +1,52 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_PATH_H\n+#define RUST_AST_RESOLVE_PATH_H\n+\n+#include \"rust-ast-resolve-base.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolvePath : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static void go (AST::PathInExpression *expr);\n+  static void go (AST::QualifiedPathInExpression *expr);\n+  static void go (AST::SimplePath *expr);\n+\n+private:\n+  ResolvePath ();\n+\n+  void resolve_path (AST::PathInExpression *expr);\n+  void resolve_path (AST::QualifiedPathInExpression *expr);\n+  void resolve_path (AST::SimplePath *expr);\n+\n+  void\n+  resolve_simple_path_segments (CanonicalPath prefix, size_t offs,\n+\t\t\t\tconst std::vector<AST::SimplePathSegment> &segs,\n+\t\t\t\tNodeId expr_node_id, Location expr_locus);\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // !RUST_AST_RESOLVE_PATH_H"}, {"sha": "9386d36d25eb69f078a5f8219c997ef1d278f471", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.cc", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc?ref=85a8fe00f805e7889b4e67a98ae1d435c042166b", "patch": "@@ -0,0 +1,163 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-resolve-pattern.h\"\n+#include \"rust-ast-resolve-path.h\"\n+#include \"rust-ast-resolve-expr.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+PatternDeclaration::visit (AST::PathInExpression &pattern)\n+{\n+  ResolvePath::go (&pattern);\n+}\n+\n+void\n+PatternDeclaration::visit (AST::TupleStructPattern &pattern)\n+{\n+  ResolvePath::go (&pattern.get_path ());\n+\n+  std::unique_ptr<AST::TupleStructItems> &items = pattern.get_items ();\n+  switch (items->get_item_type ())\n+    {\n+      case AST::TupleStructItems::RANGE: {\n+\t// TODO\n+\tgcc_unreachable ();\n+      }\n+      break;\n+\n+      case AST::TupleStructItems::NO_RANGE: {\n+\tAST::TupleStructItemsNoRange &items_no_range\n+\t  = static_cast<AST::TupleStructItemsNoRange &> (*items.get ());\n+\n+\tfor (auto &inner_pattern : items_no_range.get_patterns ())\n+\t  {\n+\t    PatternDeclaration::go (inner_pattern.get ());\n+\t  }\n+      }\n+      break;\n+    }\n+}\n+\n+void\n+PatternDeclaration::visit (AST::StructPattern &pattern)\n+{\n+  ResolvePath::go (&pattern.get_path ());\n+\n+  auto &struct_pattern_elems = pattern.get_struct_pattern_elems ();\n+  for (auto &field : struct_pattern_elems.get_struct_pattern_fields ())\n+    {\n+      switch (field->get_item_type ())\n+\t{\n+\t  case AST::StructPatternField::ItemType::TUPLE_PAT: {\n+\t    // TODO\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\t  case AST::StructPatternField::ItemType::IDENT_PAT: {\n+\t    // TODO\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\t  case AST::StructPatternField::ItemType::IDENT: {\n+\t    AST::StructPatternFieldIdent &ident\n+\t      = static_cast<AST::StructPatternFieldIdent &> (*field.get ());\n+\n+\t    resolver->get_name_scope ().insert (\n+\t      CanonicalPath::new_seg (ident.get_node_id (),\n+\t\t\t\t      ident.get_identifier ()),\n+\t      ident.get_node_id (), ident.get_locus ());\n+\t  }\n+\t  break;\n+\t}\n+    }\n+\n+  // TODO\n+  rust_assert (!struct_pattern_elems.has_etc ());\n+}\n+\n+void\n+PatternDeclaration::visit (AST::TuplePattern &pattern)\n+{\n+  std::unique_ptr<AST::TuplePatternItems> &items = pattern.get_items ();\n+  switch (items->get_pattern_type ())\n+    {\n+      case AST::TuplePatternItems::TuplePatternItemType::MULTIPLE: {\n+\tAST::TuplePatternItemsMultiple &ref\n+\t  = *static_cast<AST::TuplePatternItemsMultiple *> (\n+\t    pattern.get_items ().get ());\n+\n+\tfor (auto &p : ref.get_patterns ())\n+\t  p->accept_vis (*this);\n+      }\n+      break;\n+\n+      case AST::TuplePatternItems::TuplePatternItemType::RANGED: {\n+\tAST::TuplePatternItemsRanged &ref\n+\t  = *static_cast<AST::TuplePatternItemsRanged *> (\n+\t    pattern.get_items ().get ());\n+\n+\tfor (auto &p : ref.get_lower_patterns ())\n+\t  p->accept_vis (*this);\n+\tfor (auto &p : ref.get_upper_patterns ())\n+\t  p->accept_vis (*this);\n+      }\n+      break;\n+    }\n+}\n+\n+static void\n+resolve_range_pattern_bound (AST::RangePatternBound *bound)\n+{\n+  switch (bound->get_bound_type ())\n+    {\n+    case AST::RangePatternBound::RangePatternBoundType::LITERAL:\n+      // Nothing to resolve for a literal.\n+      break;\n+\n+      case AST::RangePatternBound::RangePatternBoundType::PATH: {\n+\tAST::RangePatternBoundPath &ref\n+\t  = *static_cast<AST::RangePatternBoundPath *> (bound);\n+\n+\tResolvePath::go (&ref.get_path ());\n+      }\n+      break;\n+\n+      case AST::RangePatternBound::RangePatternBoundType::QUALPATH: {\n+\tAST::RangePatternBoundQualPath &ref\n+\t  = *static_cast<AST::RangePatternBoundQualPath *> (bound);\n+\n+\tResolvePath::go (&ref.get_qualified_path ());\n+      }\n+      break;\n+    }\n+}\n+\n+void\n+PatternDeclaration::visit (AST::RangePattern &pattern)\n+{\n+  resolve_range_pattern_bound (pattern.get_upper_bound ().get ());\n+  resolve_range_pattern_bound (pattern.get_lower_bound ().get ());\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "fcbb23fdf088ff5eb1be18bd16fb7c175be4ac0a", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.h", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h?ref=85a8fe00f805e7889b4e67a98ae1d435c042166b", "patch": "@@ -0,0 +1,98 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_PATTERN_H\n+#define RUST_AST_RESOLVE_PATTERN_H\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolvePattern : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static void go (AST::Pattern *pattern)\n+  {\n+    ResolvePattern resolver;\n+    pattern->accept_vis (resolver);\n+  }\n+\n+  void visit (AST::IdentifierPattern &pattern) override\n+  {\n+    if (resolver->get_name_scope ().lookup (\n+\t  CanonicalPath::new_seg (pattern.get_node_id (), pattern.get_ident ()),\n+\t  &resolved_node))\n+      {\n+\tresolver->insert_resolved_name (pattern.get_node_id (), resolved_node);\n+      }\n+  }\n+\n+private:\n+  ResolvePattern () : ResolverBase () {}\n+};\n+\n+class PatternDeclaration : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static void go (AST::Pattern *pattern)\n+  {\n+    PatternDeclaration resolver;\n+    pattern->accept_vis (resolver);\n+  };\n+\n+  void visit (AST::IdentifierPattern &pattern) override\n+  {\n+    // if we have a duplicate id this then allows for shadowing correctly\n+    // as new refs to this decl will match back here so it is ok to overwrite\n+    resolver->get_name_scope ().insert (\n+      CanonicalPath::new_seg (pattern.get_node_id (), pattern.get_ident ()),\n+      pattern.get_node_id (), pattern.get_locus ());\n+  }\n+\n+  void visit (AST::WildcardPattern &pattern) override\n+  {\n+    resolver->get_name_scope ().insert (\n+      CanonicalPath::new_seg (pattern.get_node_id (), \"_\"),\n+      pattern.get_node_id (), pattern.get_locus ());\n+  }\n+\n+  // cases in a match expression\n+  void visit (AST::PathInExpression &pattern) override;\n+\n+  void visit (AST::StructPattern &pattern) override;\n+\n+  void visit (AST::TupleStructPattern &pattern) override;\n+\n+  void visit (AST::TuplePattern &pattern) override;\n+\n+  void visit (AST::RangePattern &pattern) override;\n+\n+private:\n+  PatternDeclaration () : ResolverBase () {}\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_PATTERN_H"}, {"sha": "1ce3df0891c5c278532862f9d830e8800351392d", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.cc?ref=85a8fe00f805e7889b4e67a98ae1d435c042166b", "patch": "@@ -0,0 +1,38 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-resolve-item.h\"\n+#include \"rust-ast-resolve-stmt.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+ResolveStmt::visit (AST::ExternBlock &extern_block)\n+{\n+  resolve_visibility (extern_block.get_visibility ());\n+  for (auto &item : extern_block.get_extern_items ())\n+    {\n+      ResolveToplevelExternItem::go (item.get (),\n+\t\t\t\t     CanonicalPath::create_empty ());\n+      ResolveExternItem::go (item.get (), prefix, canonical_prefix);\n+    }\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "6f21bc35a333e84345720a3bf73e6e676ac23625", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "added", "additions": 378, "deletions": 0, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=85a8fe00f805e7889b4e67a98ae1d435c042166b", "patch": "@@ -0,0 +1,378 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_STMT_H\n+#define RUST_AST_RESOLVE_STMT_H\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-ast-resolve-type.h\"\n+#include \"rust-ast-resolve-pattern.h\"\n+#include \"rust-ast-resolve-expr.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolveStmt : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static void go (AST::Stmt *stmt, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix,\n+\t\t  const CanonicalPath &enum_prefix)\n+  {\n+    if (stmt->is_marked_for_strip ())\n+      return;\n+\n+    ResolveStmt resolver (prefix, canonical_prefix, enum_prefix);\n+    stmt->accept_vis (resolver);\n+  }\n+\n+  void visit (AST::ExprStmtWithBlock &stmt) override\n+  {\n+    ResolveExpr::go (stmt.get_expr ().get (), prefix, canonical_prefix);\n+  }\n+\n+  void visit (AST::ExprStmtWithoutBlock &stmt) override\n+  {\n+    ResolveExpr::go (stmt.get_expr ().get (), prefix, canonical_prefix);\n+  }\n+\n+  void visit (AST::ConstantItem &constant) override\n+  {\n+    auto decl = CanonicalPath::new_seg (constant.get_node_id (),\n+\t\t\t\t\tconstant.get_identifier ());\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (constant.get_node_id (), cpath);\n+\n+    resolver->get_name_scope ().insert (\n+      path, constant.get_node_id (), constant.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (constant.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    ResolveType::go (constant.get_type ().get ());\n+    ResolveExpr::go (constant.get_expr ().get (), prefix, canonical_prefix);\n+  }\n+\n+  void visit (AST::LetStmt &stmt) override\n+  {\n+    if (stmt.has_init_expr ())\n+      {\n+\tResolveExpr::go (stmt.get_init_expr ().get (), prefix,\n+\t\t\t canonical_prefix);\n+      }\n+\n+    PatternDeclaration::go (stmt.get_pattern ().get ());\n+    if (stmt.has_type ())\n+      ResolveType::go (stmt.get_type ().get ());\n+  }\n+\n+  void visit (AST::TupleStruct &struct_decl) override\n+  {\n+    auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+\t\t\t\t\tstruct_decl.get_identifier ());\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (struct_decl.get_node_id (), cpath);\n+\n+    resolver->get_type_scope ().insert (\n+      path, struct_decl.get_node_id (), struct_decl.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (struct_decl.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    NodeId scope_node_id = struct_decl.get_node_id ();\n+    resolver->get_type_scope ().push (scope_node_id);\n+\n+    if (struct_decl.has_generics ())\n+      {\n+\tfor (auto &generic : struct_decl.get_generic_params ())\n+\t  ResolveGenericParam::go (generic.get (), prefix, canonical_prefix);\n+      }\n+\n+    for (AST::TupleField &field : struct_decl.get_fields ())\n+      ResolveType::go (field.get_field_type ().get ());\n+\n+    resolver->get_type_scope ().pop ();\n+  }\n+\n+  void visit (AST::Enum &enum_decl) override\n+  {\n+    auto decl = CanonicalPath::new_seg (enum_decl.get_node_id (),\n+\t\t\t\t\tenum_decl.get_identifier ());\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (enum_decl.get_node_id (), cpath);\n+\n+    resolver->get_type_scope ().insert (\n+      path, enum_decl.get_node_id (), enum_decl.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (enum_decl.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    NodeId scope_node_id = enum_decl.get_node_id ();\n+    resolver->get_type_scope ().push (scope_node_id);\n+\n+    if (enum_decl.has_generics ())\n+      {\n+\tfor (auto &generic : enum_decl.get_generic_params ())\n+\t  ResolveGenericParam::go (generic.get (), prefix, canonical_prefix);\n+      }\n+\n+    for (auto &variant : enum_decl.get_variants ())\n+      ResolveStmt::go (variant.get (), path, canonical_prefix, path);\n+\n+    resolver->get_type_scope ().pop ();\n+  }\n+\n+  void visit (AST::EnumItem &item) override\n+  {\n+    auto decl = enum_prefix.append (\n+      CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (item.get_node_id (), cpath);\n+\n+    resolver->get_type_scope ().insert (\n+      path, item.get_node_id (), item.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (item.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    // Done, no fields.\n+  }\n+\n+  void visit (AST::EnumItemTuple &item) override\n+  {\n+    auto decl = enum_prefix.append (\n+      CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (item.get_node_id (), cpath);\n+\n+    resolver->get_type_scope ().insert (\n+      path, item.get_node_id (), item.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (item.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    for (auto &field : item.get_tuple_fields ())\n+      {\n+\tif (field.get_field_type ()->is_marked_for_strip ())\n+\t  continue;\n+\n+\tResolveType::go (field.get_field_type ().get ());\n+      }\n+  }\n+\n+  void visit (AST::EnumItemStruct &item) override\n+  {\n+    auto decl = enum_prefix.append (\n+      CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (item.get_node_id (), cpath);\n+\n+    resolver->get_type_scope ().insert (\n+      path, item.get_node_id (), item.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (item.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    for (auto &field : item.get_struct_fields ())\n+      {\n+\tif (field.get_field_type ()->is_marked_for_strip ())\n+\t  continue;\n+\n+\tResolveType::go (field.get_field_type ().get ());\n+      }\n+  }\n+\n+  void visit (AST::EnumItemDiscriminant &item) override\n+  {\n+    auto decl = enum_prefix.append (\n+      CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (item.get_node_id (), cpath);\n+\n+    resolver->get_type_scope ().insert (\n+      path, item.get_node_id (), item.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (item.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    // Done, no fields.\n+  }\n+\n+  void visit (AST::StructStruct &struct_decl) override\n+  {\n+    auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+\t\t\t\t\tstruct_decl.get_identifier ());\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (struct_decl.get_node_id (), cpath);\n+\n+    resolver->get_type_scope ().insert (\n+      path, struct_decl.get_node_id (), struct_decl.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (struct_decl.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    NodeId scope_node_id = struct_decl.get_node_id ();\n+    resolver->get_type_scope ().push (scope_node_id);\n+\n+    if (struct_decl.has_generics ())\n+      {\n+\tfor (auto &generic : struct_decl.get_generic_params ())\n+\t  ResolveGenericParam::go (generic.get (), prefix, canonical_prefix);\n+      }\n+\n+    for (AST::StructField &field : struct_decl.get_fields ())\n+      {\n+\tif (field.get_field_type ()->is_marked_for_strip ())\n+\t  continue;\n+\n+\tResolveType::go (field.get_field_type ().get ());\n+      }\n+\n+    resolver->get_type_scope ().pop ();\n+  }\n+\n+  void visit (AST::Union &union_decl) override\n+  {\n+    auto decl = CanonicalPath::new_seg (union_decl.get_node_id (),\n+\t\t\t\t\tunion_decl.get_identifier ());\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (union_decl.get_node_id (), cpath);\n+\n+    resolver->get_type_scope ().insert (\n+      path, union_decl.get_node_id (), union_decl.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (union_decl.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    NodeId scope_node_id = union_decl.get_node_id ();\n+    resolver->get_type_scope ().push (scope_node_id);\n+\n+    if (union_decl.has_generics ())\n+      for (auto &generic : union_decl.get_generic_params ())\n+\tResolveGenericParam::go (generic.get (), prefix, canonical_prefix);\n+\n+    for (AST::StructField &field : union_decl.get_variants ())\n+      {\n+\tif (field.get_field_type ()->is_marked_for_strip ())\n+\t  continue;\n+\n+\tResolveType::go (field.get_field_type ().get ());\n+      }\n+\n+    resolver->get_type_scope ().pop ();\n+  }\n+\n+  void visit (AST::Function &function) override\n+  {\n+    auto decl = CanonicalPath::new_seg (function.get_node_id (),\n+\t\t\t\t\tfunction.get_function_name ());\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (function.get_node_id (), cpath);\n+\n+    resolver->get_name_scope ().insert (\n+      path, function.get_node_id (), function.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (function.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    NodeId scope_node_id = function.get_node_id ();\n+    resolver->get_name_scope ().push (scope_node_id);\n+    resolver->get_type_scope ().push (scope_node_id);\n+    resolver->get_label_scope ().push (scope_node_id);\n+    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+    if (function.has_generics ())\n+      for (auto &generic : function.get_generic_params ())\n+\tResolveGenericParam::go (generic.get (), prefix, canonical_prefix);\n+\n+    if (function.has_return_type ())\n+      ResolveType::go (function.get_return_type ().get ());\n+\n+    // we make a new scope so the names of parameters are resolved and shadowed\n+    // correctly\n+    for (auto &param : function.get_function_params ())\n+      {\n+\tResolveType::go (param.get_type ().get ());\n+\tPatternDeclaration::go (param.get_pattern ().get ());\n+      }\n+\n+    // resolve the function body\n+    ResolveExpr::go (function.get_definition ().get (), path, cpath);\n+\n+    resolver->get_name_scope ().pop ();\n+    resolver->get_type_scope ().pop ();\n+    resolver->get_label_scope ().pop ();\n+  }\n+\n+  void visit (AST::ExternBlock &extern_block) override;\n+\n+private:\n+  ResolveStmt (const CanonicalPath &prefix,\n+\t       const CanonicalPath &canonical_prefix,\n+\t       const CanonicalPath &enum_prefix)\n+    : ResolverBase (), prefix (prefix), canonical_prefix (canonical_prefix),\n+      enum_prefix (enum_prefix)\n+  {}\n+\n+  const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n+\n+  /* item declaration statements are not given a canonical path, but enum items\n+   * (variants) do inherit the enum path/identifier name.  */\n+  const CanonicalPath &enum_prefix;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_STMT_H"}, {"sha": "4d8b6c788f323e09efb1ea99f7a3f87236b32f25", "filename": "gcc/rust/resolve/rust-ast-resolve-struct-expr-field.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.cc?ref=85a8fe00f805e7889b4e67a98ae1d435c042166b", "patch": "@@ -0,0 +1,61 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-resolve-struct-expr-field.h\"\n+#include \"rust-ast-resolve-expr.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+ResolveStructExprField::go (AST::StructExprField *field,\n+\t\t\t    const CanonicalPath &prefix,\n+\t\t\t    const CanonicalPath &canonical_prefix)\n+{\n+  ResolveStructExprField resolver (prefix, canonical_prefix);\n+  field->accept_vis (resolver);\n+}\n+\n+ResolveStructExprField::ResolveStructExprField (\n+  const CanonicalPath &prefix, const CanonicalPath &canonical_prefix)\n+  : ResolverBase (), prefix (prefix), canonical_prefix (canonical_prefix)\n+{}\n+\n+void\n+ResolveStructExprField::visit (AST::StructExprFieldIdentifierValue &field)\n+{\n+  ResolveExpr::go (field.get_value ().get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveStructExprField::visit (AST::StructExprFieldIndexValue &field)\n+{\n+  ResolveExpr::go (field.get_value ().get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveStructExprField::visit (AST::StructExprFieldIdentifier &field)\n+{\n+  AST::IdentifierExpr expr (field.get_field_name (), {}, field.get_locus ());\n+  expr.set_node_id (field.get_node_id ());\n+\n+  ResolveExpr::go (&expr, prefix, canonical_prefix);\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "ce60b136e4be1c4c5482b85a3dc6af04a200de7f", "filename": "gcc/rust/resolve/rust-ast-resolve-struct-expr-field.h", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h?ref=85a8fe00f805e7889b4e67a98ae1d435c042166b", "patch": "@@ -0,0 +1,55 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_STRUCT_EXPR_FIELD\n+#define RUST_AST_RESOLVE_STRUCT_EXPR_FIELD\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+// this resolves values being assigned not that the field actually exists yet.\n+\n+class ResolveStructExprField : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static void go (AST::StructExprField *field, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix);\n+\n+  void visit (AST::StructExprFieldIdentifierValue &field) override;\n+\n+  void visit (AST::StructExprFieldIndexValue &field) override;\n+\n+  void visit (AST::StructExprFieldIdentifier &field) override;\n+\n+private:\n+  ResolveStructExprField (const CanonicalPath &prefix,\n+\t\t\t  const CanonicalPath &canonical_prefix);\n+\n+  const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_STRUCT_EXPR_FIELD"}, {"sha": "43ae8e476733c713b9ae77b201456a5f40b1c0a8", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "added", "additions": 460, "deletions": 0, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=85a8fe00f805e7889b4e67a98ae1d435c042166b", "patch": "@@ -0,0 +1,460 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_TOPLEVEL_H\n+#define RUST_AST_RESOLVE_TOPLEVEL_H\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-resolve-type.h\"\n+#include \"rust-ast-resolve-implitem.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-name-resolver.h\"\n+#include \"rust-session-manager.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolveTopLevel : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static void go (AST::Item *item, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix)\n+  {\n+    if (item->is_marked_for_strip ())\n+      return;\n+\n+    ResolveTopLevel resolver (prefix, canonical_prefix);\n+    item->accept_vis (resolver);\n+\n+    NodeId current_module = resolver.resolver->peek_current_module_scope ();\n+    resolver.mappings->insert_child_item_to_parent_module_mapping (\n+      item->get_node_id (), current_module);\n+  }\n+\n+  void visit (AST::Module &module) override\n+  {\n+    auto mod\n+      = CanonicalPath::new_seg (module.get_node_id (), module.get_name ());\n+    auto path = prefix.append (mod);\n+    auto cpath = canonical_prefix.append (mod);\n+\n+    resolver->get_name_scope ().insert (\n+      path, module.get_node_id (), module.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (module.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    NodeId current_module = resolver->peek_current_module_scope ();\n+    mappings->insert_module_child_item (current_module, mod);\n+    mappings->insert_module_child (current_module, module.get_node_id ());\n+\n+    resolver->push_new_module_scope (module.get_node_id ());\n+    for (auto &item : module.get_items ())\n+      ResolveTopLevel::go (item.get (), path, cpath);\n+\n+    resolver->pop_module_scope ();\n+\n+    mappings->insert_canonical_path (module.get_node_id (), cpath);\n+  }\n+\n+  void visit (AST::TypeAlias &alias) override\n+  {\n+    auto talias = CanonicalPath::new_seg (alias.get_node_id (),\n+\t\t\t\t\t  alias.get_new_type_name ());\n+    auto path = prefix.append (talias);\n+    auto cpath = canonical_prefix.append (talias);\n+\n+    resolver->get_type_scope ().insert (\n+      path, alias.get_node_id (), alias.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (alias.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    NodeId current_module = resolver->peek_current_module_scope ();\n+    mappings->insert_module_child_item (current_module, talias);\n+    mappings->insert_canonical_path (alias.get_node_id (), cpath);\n+  }\n+\n+  void visit (AST::TupleStruct &struct_decl) override\n+  {\n+    auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+\t\t\t\t\tstruct_decl.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n+    resolver->get_type_scope ().insert (\n+      path, struct_decl.get_node_id (), struct_decl.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (struct_decl.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    NodeId current_module = resolver->peek_current_module_scope ();\n+    mappings->insert_module_child_item (current_module, decl);\n+    mappings->insert_canonical_path (struct_decl.get_node_id (), cpath);\n+  }\n+\n+  void visit (AST::Enum &enum_decl) override\n+  {\n+    auto decl = CanonicalPath::new_seg (enum_decl.get_node_id (),\n+\t\t\t\t\tenum_decl.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n+    resolver->get_type_scope ().insert (\n+      path, enum_decl.get_node_id (), enum_decl.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (enum_decl.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    for (auto &variant : enum_decl.get_variants ())\n+      ResolveTopLevel::go (variant.get (), path, cpath);\n+\n+    NodeId current_module = resolver->peek_current_module_scope ();\n+    mappings->insert_module_child_item (current_module, decl);\n+    mappings->insert_canonical_path (enum_decl.get_node_id (), cpath);\n+  }\n+\n+  void visit (AST::EnumItem &item) override\n+  {\n+    auto decl\n+      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n+    resolver->get_type_scope ().insert (\n+      path, item.get_node_id (), item.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (item.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    mappings->insert_canonical_path (item.get_node_id (), cpath);\n+  }\n+\n+  void visit (AST::EnumItemTuple &item) override\n+  {\n+    auto decl\n+      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n+    resolver->get_type_scope ().insert (\n+      path, item.get_node_id (), item.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (item.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    mappings->insert_canonical_path (item.get_node_id (), cpath);\n+  }\n+\n+  void visit (AST::EnumItemStruct &item) override\n+  {\n+    auto decl\n+      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n+    resolver->get_type_scope ().insert (\n+      path, item.get_node_id (), item.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (item.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    mappings->insert_canonical_path (item.get_node_id (), cpath);\n+  }\n+\n+  void visit (AST::EnumItemDiscriminant &item) override\n+  {\n+    auto decl\n+      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n+    resolver->get_type_scope ().insert (\n+      path, item.get_node_id (), item.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (item.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    mappings->insert_canonical_path (item.get_node_id (), cpath);\n+  }\n+\n+  void visit (AST::StructStruct &struct_decl) override\n+  {\n+    auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+\t\t\t\t\tstruct_decl.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n+    resolver->get_type_scope ().insert (\n+      path, struct_decl.get_node_id (), struct_decl.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (struct_decl.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    NodeId current_module = resolver->peek_current_module_scope ();\n+    mappings->insert_module_child_item (current_module, decl);\n+    mappings->insert_canonical_path (struct_decl.get_node_id (), cpath);\n+  }\n+\n+  void visit (AST::Union &union_decl) override\n+  {\n+    auto decl = CanonicalPath::new_seg (union_decl.get_node_id (),\n+\t\t\t\t\tunion_decl.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n+    resolver->get_type_scope ().insert (\n+      path, union_decl.get_node_id (), union_decl.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (union_decl.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    NodeId current_module = resolver->peek_current_module_scope ();\n+    mappings->insert_module_child_item (current_module, decl);\n+    mappings->insert_canonical_path (union_decl.get_node_id (), cpath);\n+  }\n+\n+  void visit (AST::StaticItem &var) override\n+  {\n+    auto decl\n+      = CanonicalPath::new_seg (var.get_node_id (), var.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n+    resolver->get_name_scope ().insert (\n+      path, var.get_node_id (), var.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (var.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    NodeId current_module = resolver->peek_current_module_scope ();\n+    mappings->insert_module_child_item (current_module, decl);\n+    mappings->insert_canonical_path (var.get_node_id (), cpath);\n+  }\n+\n+  void visit (AST::ConstantItem &constant) override\n+  {\n+    auto decl = CanonicalPath::new_seg (constant.get_node_id (),\n+\t\t\t\t\tconstant.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n+    resolver->get_name_scope ().insert (\n+      path, constant.get_node_id (), constant.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (constant.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    NodeId current_module = resolver->peek_current_module_scope ();\n+    mappings->insert_module_child_item (current_module, decl);\n+    mappings->insert_canonical_path (constant.get_node_id (), cpath);\n+  }\n+\n+  void visit (AST::Function &function) override\n+  {\n+    auto decl = CanonicalPath::new_seg (function.get_node_id (),\n+\t\t\t\t\tfunction.get_function_name ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n+    resolver->get_name_scope ().insert (\n+      path, function.get_node_id (), function.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (function.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    NodeId current_module = resolver->peek_current_module_scope ();\n+    mappings->insert_module_child_item (current_module, decl);\n+    mappings->insert_canonical_path (function.get_node_id (), cpath);\n+  }\n+\n+  void visit (AST::InherentImpl &impl_block) override\n+  {\n+    std::string raw_impl_type_path = impl_block.get_type ()->as_string ();\n+    CanonicalPath impl_type\n+      = CanonicalPath::new_seg (impl_block.get_type ()->get_node_id (),\n+\t\t\t\traw_impl_type_path);\n+    CanonicalPath impl_prefix = prefix.append (impl_type);\n+\n+    for (auto &impl_item : impl_block.get_impl_items ())\n+      ResolveToplevelImplItem::go (impl_item.get (), impl_prefix);\n+  }\n+\n+  void visit (AST::TraitImpl &impl_block) override\n+  {\n+    std::string raw_impl_type_path = impl_block.get_type ()->as_string ();\n+    CanonicalPath impl_type_seg\n+      = CanonicalPath::new_seg (impl_block.get_type ()->get_node_id (),\n+\t\t\t\traw_impl_type_path);\n+\n+    std::string raw_trait_type_path = impl_block.get_trait_path ().as_string ();\n+    CanonicalPath trait_type_seg\n+      = CanonicalPath::new_seg (impl_block.get_trait_path ().get_node_id (),\n+\t\t\t\traw_trait_type_path);\n+\n+    CanonicalPath projection\n+      = CanonicalPath::trait_impl_projection_seg (impl_block.get_node_id (),\n+\t\t\t\t\t\t  trait_type_seg,\n+\t\t\t\t\t\t  impl_type_seg);\n+    CanonicalPath impl_prefix = prefix.append (projection);\n+\n+    resolver->get_name_scope ().insert (\n+      impl_prefix, impl_block.get_node_id (), impl_block.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (impl_block.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    for (auto &impl_item : impl_block.get_impl_items ())\n+      ResolveToplevelImplItem::go (impl_item.get (), impl_prefix);\n+  }\n+\n+  void visit (AST::Trait &trait) override\n+  {\n+    auto decl\n+      = CanonicalPath::new_seg (trait.get_node_id (), trait.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n+    resolver->get_type_scope ().insert (\n+      path, trait.get_node_id (), trait.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (trait.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    for (auto &item : trait.get_trait_items ())\n+      ResolveTopLevelTraitItems::go (item.get (), path, cpath);\n+\n+    NodeId current_module = resolver->peek_current_module_scope ();\n+    mappings->insert_module_child_item (current_module, decl);\n+    mappings->insert_canonical_path (trait.get_node_id (), cpath);\n+  }\n+\n+  void visit (AST::ExternBlock &extern_block) override\n+  {\n+    for (auto &item : extern_block.get_extern_items ())\n+      {\n+\tResolveToplevelExternItem::go (item.get (), prefix);\n+      }\n+  }\n+\n+  void visit (AST::ExternCrate &extern_crate) override\n+  {\n+    if (extern_crate.is_marked_for_strip ())\n+      return;\n+\n+    NodeId resolved_crate = UNKNOWN_NODEID;\n+    if (extern_crate.references_self ())\n+      {\n+\tCrateNum crate_num = mappings->get_current_crate ();\n+\tbool ok = mappings->crate_num_to_nodeid (crate_num, resolved_crate);\n+\trust_assert (ok);\n+      }\n+    else\n+      {\n+\tCrateNum found_crate_num = UNKNOWN_CREATENUM;\n+\tbool found\n+\t  = mappings->lookup_crate_name (extern_crate.get_referenced_crate (),\n+\t\t\t\t\t found_crate_num);\n+\tif (!found)\n+\t  {\n+\t    rust_error_at (extern_crate.get_locus (), \"unknown crate %<%s%>\",\n+\t\t\t   extern_crate.get_referenced_crate ().c_str ());\n+\t    return;\n+\t  }\n+\n+\tbool ok\n+\t  = mappings->crate_num_to_nodeid (found_crate_num, resolved_crate);\n+\tif (!ok)\n+\t  {\n+\t    rust_internal_error_at (extern_crate.get_locus (),\n+\t\t\t\t    \"failed to resolve crate to nodeid\");\n+\t    return;\n+\t  }\n+      }\n+\n+    if (resolved_crate == UNKNOWN_NODEID)\n+      {\n+\trust_error_at (extern_crate.get_locus (), \"failed to resolve crate\");\n+\treturn;\n+      }\n+\n+    // mark the node as resolved\n+    resolver->insert_resolved_name (extern_crate.get_node_id (),\n+\t\t\t\t    resolved_crate);\n+    CanonicalPath decl\n+      = extern_crate.has_as_clause ()\n+\t  ? CanonicalPath::new_seg (extern_crate.get_node_id (),\n+\t\t\t\t    extern_crate.get_as_clause ())\n+\t  : CanonicalPath::new_seg (extern_crate.get_node_id (),\n+\t\t\t\t    extern_crate.get_referenced_crate ());\n+\n+    resolver->get_type_scope ().insert (\n+      decl, resolved_crate, extern_crate.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (extern_crate.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+  }\n+\n+private:\n+  ResolveTopLevel (const CanonicalPath &prefix,\n+\t\t   const CanonicalPath &canonical_prefix)\n+    : ResolverBase (), prefix (prefix), canonical_prefix (canonical_prefix)\n+  {}\n+\n+  const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_TOPLEVEL_H"}, {"sha": "6b08613755a04ed7ca919a895311948e55557b68", "filename": "gcc/rust/resolve/rust-ast-resolve-type.cc", "status": "added", "additions": 582, "deletions": 0, "changes": 582, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc?ref=85a8fe00f805e7889b4e67a98ae1d435c042166b", "patch": "@@ -0,0 +1,582 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-resolve-type.h\"\n+#include \"rust-ast-resolve-expr.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+// rust-ast-resolve-type.h\n+\n+void\n+ResolveType::visit (AST::ArrayType &type)\n+{\n+  type.get_elem_type ()->accept_vis (*this);\n+  ResolveExpr::go (type.get_size_expr ().get (), CanonicalPath::create_empty (),\n+\t\t   CanonicalPath::create_empty ());\n+}\n+\n+void\n+ResolveType::visit (AST::TraitObjectTypeOneBound &type)\n+{\n+  ResolveTypeBound::go (&type.get_trait_bound ());\n+}\n+\n+void\n+ResolveType::visit (AST::TraitObjectType &type)\n+{\n+  for (auto &bound : type.get_type_param_bounds ())\n+    {\n+      /* NodeId bound_resolved_id = */\n+      ResolveTypeBound::go (bound.get ());\n+    }\n+}\n+\n+void\n+ResolveType::visit (AST::ReferenceType &type)\n+{\n+  resolved_node = ResolveType::go (type.get_type_referenced ().get ());\n+}\n+\n+void\n+ResolveType::visit (AST::RawPointerType &type)\n+{\n+  resolved_node = ResolveType::go (type.get_type_pointed_to ().get ());\n+}\n+\n+void\n+ResolveType::visit (AST::InferredType &type)\n+{\n+  // FIXME\n+}\n+\n+void\n+ResolveType::visit (AST::NeverType &type)\n+{\n+  // FIXME\n+}\n+\n+void\n+ResolveType::visit (AST::SliceType &type)\n+{\n+  resolved_node = ResolveType::go (type.get_elem_type ().get ());\n+}\n+\n+// resolve relative type-paths\n+\n+bool\n+ResolveRelativeTypePath::go (AST::TypePath &path, NodeId &resolved_node_id)\n+{\n+  auto resolver = Resolver::get ();\n+  auto mappings = Analysis::Mappings::get ();\n+\n+  NodeId module_scope_id = resolver->peek_current_module_scope ();\n+  NodeId previous_resolved_node_id = module_scope_id;\n+  for (size_t i = 0; i < path.get_segments ().size (); i++)\n+    {\n+      auto &segment = path.get_segments ().at (i);\n+      const AST::PathIdentSegment &ident_seg = segment->get_ident_segment ();\n+      bool is_first_segment = i == 0;\n+      resolved_node_id = UNKNOWN_NODEID;\n+\n+      bool in_middle_of_path = i > 0;\n+      if (in_middle_of_path && segment->is_lower_self_seg ())\n+\t{\n+\t  // error[E0433]: failed to resolve: `self` in paths can only be used\n+\t  // in start position\n+\t  rust_error_at (segment->get_locus (),\n+\t\t\t \"failed to resolve: %<%s%> in paths can only be used \"\n+\t\t\t \"in start position\",\n+\t\t\t segment->as_string ().c_str ());\n+\t  return false;\n+\t}\n+\n+      NodeId crate_scope_id = resolver->peek_crate_module_scope ();\n+      if (segment->is_crate_path_seg ())\n+\t{\n+\t  // what is the current crate scope node id?\n+\t  module_scope_id = crate_scope_id;\n+\t  previous_resolved_node_id = module_scope_id;\n+\t  resolver->insert_resolved_name (segment->get_node_id (),\n+\t\t\t\t\t  module_scope_id);\n+\n+\t  continue;\n+\t}\n+      else if (segment->is_super_path_seg ())\n+\t{\n+\t  if (module_scope_id == crate_scope_id)\n+\t    {\n+\t      rust_error_at (segment->get_locus (),\n+\t\t\t     \"cannot use super at the crate scope\");\n+\t      return false;\n+\t    }\n+\n+\t  module_scope_id = resolver->peek_parent_module_scope ();\n+\t  previous_resolved_node_id = module_scope_id;\n+\t  resolver->insert_resolved_name (segment->get_node_id (),\n+\t\t\t\t\t  module_scope_id);\n+\t  continue;\n+\t}\n+\n+      switch (segment->get_type ())\n+\t{\n+\t  case AST::TypePathSegment::SegmentType::GENERIC: {\n+\t    AST::TypePathSegmentGeneric *s\n+\t      = static_cast<AST::TypePathSegmentGeneric *> (segment.get ());\n+\t    if (s->has_generic_args ())\n+\t      ResolveGenericArgs::go (s->get_generic_args ());\n+\t  }\n+\t  break;\n+\n+\tcase AST::TypePathSegment::SegmentType::REG:\n+\t  // nothing to do\n+\t  break;\n+\n+\tcase AST::TypePathSegment::SegmentType::FUNCTION:\n+\t  gcc_unreachable ();\n+\t  break;\n+\t}\n+\n+      if (is_first_segment)\n+\t{\n+\t  // name scope first\n+\t  NodeId resolved_node = UNKNOWN_NODEID;\n+\t  const CanonicalPath path\n+\t    = CanonicalPath::new_seg (segment->get_node_id (),\n+\t\t\t\t      ident_seg.as_string ());\n+\t  if (resolver->get_type_scope ().lookup (path, &resolved_node))\n+\t    {\n+\t      resolver->insert_resolved_type (segment->get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t      resolved_node_id = resolved_node;\n+\t    }\n+\t  else if (resolver->get_name_scope ().lookup (path, &resolved_node))\n+\t    {\n+\t      resolver->insert_resolved_name (segment->get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t      resolved_node_id = resolved_node;\n+\t    }\n+\t  else if (segment->is_lower_self_seg ())\n+\t    {\n+\t      // what is the current crate scope node id?\n+\t      module_scope_id = crate_scope_id;\n+\t      previous_resolved_node_id = module_scope_id;\n+\t      resolver->insert_resolved_name (segment->get_node_id (),\n+\t\t\t\t\t      module_scope_id);\n+\n+\t      continue;\n+\t    }\n+\t}\n+\n+      if (resolved_node_id == UNKNOWN_NODEID\n+\t  && previous_resolved_node_id == module_scope_id)\n+\t{\n+\t  Optional<CanonicalPath &> resolved_child\n+\t    = mappings->lookup_module_child (module_scope_id,\n+\t\t\t\t\t     ident_seg.as_string ());\n+\t  if (resolved_child.is_some ())\n+\t    {\n+\t      NodeId resolved_node = resolved_child->get_node_id ();\n+\t      if (resolver->get_name_scope ().decl_was_declared_here (\n+\t\t    resolved_node))\n+\t\t{\n+\t\t  resolved_node_id = resolved_node;\n+\t\t  resolver->insert_resolved_name (segment->get_node_id (),\n+\t\t\t\t\t\t  resolved_node);\n+\t\t}\n+\t      else if (resolver->get_type_scope ().decl_was_declared_here (\n+\t\t\t resolved_node))\n+\t\t{\n+\t\t  resolved_node_id = resolved_node;\n+\t\t  resolver->insert_resolved_type (segment->get_node_id (),\n+\t\t\t\t\t\t  resolved_node);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  rust_error_at (segment->get_locus (),\n+\t\t\t\t \"Cannot find path %<%s%> in this scope\",\n+\t\t\t\t segment->as_string ().c_str ());\n+\t\t  return false;\n+\t\t}\n+\t    }\n+\t}\n+\n+      bool did_resolve_segment = resolved_node_id != UNKNOWN_NODEID;\n+      if (did_resolve_segment)\n+\t{\n+\t  if (mappings->node_is_module (resolved_node_id)\n+\t      || mappings->node_is_crate (resolved_node_id))\n+\t    {\n+\t      module_scope_id = resolved_node_id;\n+\t    }\n+\t  previous_resolved_node_id = resolved_node_id;\n+\t}\n+      else if (is_first_segment)\n+\t{\n+\t  rust_error_at (segment->get_locus (),\n+\t\t\t \"failed to resolve TypePath: %s in this scope\",\n+\t\t\t segment->as_string ().c_str ());\n+\t  return false;\n+\t}\n+    }\n+\n+  if (resolved_node_id != UNKNOWN_NODEID)\n+    {\n+      // name scope first\n+      if (resolver->get_name_scope ().decl_was_declared_here (resolved_node_id))\n+\t{\n+\t  resolver->insert_resolved_name (path.get_node_id (),\n+\t\t\t\t\t  resolved_node_id);\n+\t}\n+      // check the type scope\n+      else if (resolver->get_type_scope ().decl_was_declared_here (\n+\t\t resolved_node_id))\n+\t{\n+\t  resolver->insert_resolved_type (path.get_node_id (),\n+\t\t\t\t\t  resolved_node_id);\n+\t}\n+      else\n+\t{\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+// qualified type paths\n+\n+ResolveRelativeQualTypePath::ResolveRelativeQualTypePath ()\n+  : failure_flag (false)\n+{}\n+\n+bool\n+ResolveRelativeQualTypePath::go (AST::QualifiedPathInType &path)\n+{\n+  ResolveRelativeQualTypePath o;\n+\n+  // resolve the type and trait path\n+  auto &qualified_path = path.get_qualified_path_type ();\n+  if (!o.resolve_qual_seg (qualified_path))\n+    return false;\n+\n+  // qualified types are similar to other paths in that we cannot guarantee\n+  // that we can resolve the path at name resolution. We must look up\n+  // associated types and type information to figure this out properly\n+\n+  std::unique_ptr<AST::TypePathSegment> &associated\n+    = path.get_associated_segment ();\n+\n+  associated->accept_vis (o);\n+  if (o.failure_flag)\n+    return false;\n+\n+  for (auto &seg : path.get_segments ())\n+    {\n+      seg->accept_vis (o);\n+      if (o.failure_flag)\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+bool\n+ResolveRelativeQualTypePath::resolve_qual_seg (AST::QualifiedPathType &seg)\n+{\n+  if (seg.is_error ())\n+    {\n+      rust_error_at (seg.get_locus (), \"segment has error: %s\",\n+\t\t     seg.as_string ().c_str ());\n+      return false;\n+    }\n+\n+  auto type = seg.get_type ().get ();\n+  NodeId type_resolved_node = ResolveType::go (type);\n+  if (type_resolved_node == UNKNOWN_NODEID)\n+    return false;\n+\n+  if (!seg.has_as_clause ())\n+    return true;\n+\n+  NodeId trait_resolved_node = ResolveType::go (&seg.get_as_type_path ());\n+  if (trait_resolved_node == UNKNOWN_NODEID)\n+    return false;\n+\n+  return true;\n+}\n+\n+void\n+ResolveRelativeQualTypePath::visit (AST::TypePathSegmentGeneric &seg)\n+{\n+  if (seg.is_error ())\n+    {\n+      failure_flag = true;\n+      rust_error_at (seg.get_locus (), \"segment has error: %s\",\n+\t\t     seg.as_string ().c_str ());\n+      return;\n+    }\n+\n+  ResolveGenericArgs::go (seg.get_generic_args ());\n+}\n+\n+void\n+ResolveRelativeQualTypePath::visit (AST::TypePathSegment &seg)\n+{\n+  if (seg.is_error ())\n+    {\n+      failure_flag = true;\n+      rust_error_at (seg.get_locus (), \"segment has error: %s\",\n+\t\t     seg.as_string ().c_str ());\n+      return;\n+    }\n+}\n+\n+// resolve to canonical path\n+\n+bool\n+ResolveTypeToCanonicalPath::go (AST::Type *type, CanonicalPath &result)\n+{\n+  ResolveTypeToCanonicalPath resolver;\n+  type->accept_vis (resolver);\n+  result = resolver.result;\n+  return !resolver.result.is_empty ();\n+}\n+\n+void\n+ResolveTypeToCanonicalPath::visit (AST::TypePath &path)\n+{\n+  NodeId resolved_node = UNKNOWN_NODEID;\n+  if (!resolver->lookup_resolved_name (path.get_node_id (), &resolved_node))\n+    {\n+      resolver->lookup_resolved_type (path.get_node_id (), &resolved_node);\n+    }\n+\n+  if (resolved_node == UNKNOWN_NODEID)\n+    return;\n+\n+  const CanonicalPath *type_path = nullptr;\n+  if (mappings->lookup_canonical_path (resolved_node, &type_path))\n+    {\n+      auto &final_seg = path.get_segments ().back ();\n+      switch (final_seg->get_type ())\n+\t{\n+\t  case AST::TypePathSegment::SegmentType::GENERIC: {\n+\t    AST::TypePathSegmentGeneric *s\n+\t      = static_cast<AST::TypePathSegmentGeneric *> (final_seg.get ());\n+\n+\t    std::vector<CanonicalPath> args;\n+\t    if (s->has_generic_args ())\n+\t      {\n+\t\tResolveGenericArgs::go (s->get_generic_args ());\n+\t\tfor (auto &generic : s->get_generic_args ().get_generic_args ())\n+\t\t  {\n+\t\t    // FIXME: What do we want to do here in case there is a\n+\t\t    // constant or an ambiguous const generic?\n+\t\t    // TODO: At that point, will all generics have been\n+\t\t    // disambiguated? Can we thus canonical resolve types and\n+\t\t    // const and `gcc_unreachable` on ambiguous types?\n+\t\t    // This is probably fine as we just want to canonicalize\n+\t\t    // types, right?\n+\t\t    if (generic.get_kind () == AST::GenericArg::Kind::Type)\n+\t\t      {\n+\t\t\tCanonicalPath arg = CanonicalPath::create_empty ();\n+\t\t\tbool ok = ResolveTypeToCanonicalPath::go (\n+\t\t\t  generic.get_type ().get (), arg);\n+\t\t\tif (ok)\n+\t\t\t  args.push_back (std::move (arg));\n+\t\t      }\n+\t\t  }\n+\t      }\n+\n+\t    result = *type_path;\n+\t    if (!args.empty ())\n+\t      {\n+\t\t// append this onto the path\n+\t\tstd::string buf;\n+\t\tfor (size_t i = 0; i < args.size (); i++)\n+\t\t  {\n+\t\t    bool has_next = (i + 1) < args.size ();\n+\t\t    const auto &arg = args.at (i);\n+\n+\t\t    buf += arg.get ();\n+\t\t    if (has_next)\n+\t\t      buf += \", \";\n+\t\t  }\n+\n+\t\tstd::string arg_seg = \"<\" + buf + \">\";\n+\t\tCanonicalPath argument_seg\n+\t\t  = CanonicalPath::new_seg (s->get_node_id (), arg_seg);\n+\t\tresult = result.append (argument_seg);\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  result = *type_path;\n+\t  break;\n+\t}\n+    }\n+}\n+\n+void\n+ResolveTypeToCanonicalPath::visit (AST::ReferenceType &type)\n+{\n+  CanonicalPath path = CanonicalPath::create_empty ();\n+  bool ok\n+    = ResolveTypeToCanonicalPath::go (type.get_type_referenced ().get (), path);\n+  if (ok)\n+    {\n+      std::string ref_type_str = type.is_mut () ? \"mut\" : \"\";\n+      std::string ref_path = \"&\" + ref_type_str + \" \" + path.get ();\n+      result = CanonicalPath::new_seg (type.get_node_id (), ref_path);\n+    }\n+}\n+\n+void\n+ResolveTypeToCanonicalPath::visit (AST::RawPointerType &type)\n+{\n+  CanonicalPath path = CanonicalPath::create_empty ();\n+  bool ok\n+    = ResolveTypeToCanonicalPath::go (type.get_type_pointed_to ().get (), path);\n+  if (ok)\n+    {\n+      std::string ptr_type_str\n+\t= type.get_pointer_type () == AST::RawPointerType::CONST ? \"const\"\n+\t\t\t\t\t\t\t\t : \"mut\";\n+      std::string ptr_path = \"*\" + ptr_type_str + \" \" + path.get ();\n+      result = CanonicalPath::new_seg (type.get_node_id (), ptr_path);\n+    }\n+}\n+\n+void\n+ResolveTypeToCanonicalPath::visit (AST::SliceType &type)\n+{\n+  CanonicalPath path = CanonicalPath::create_empty ();\n+  bool ok = ResolveTypeToCanonicalPath::go (type.get_elem_type ().get (), path);\n+  if (ok)\n+    {\n+      std::string slice_path = \"[\" + path.get () + \"]\";\n+      result = CanonicalPath::new_seg (type.get_node_id (), slice_path);\n+    }\n+}\n+\n+void\n+ResolveTypeToCanonicalPath::visit (AST::TraitObjectTypeOneBound &type)\n+{\n+  CanonicalPath path = CanonicalPath::create_empty ();\n+  bool ok\n+    = ResolveTypeToCanonicalPath::go (&type.get_trait_bound ().get_type_path (),\n+\t\t\t\t      path);\n+  if (ok)\n+    {\n+      std::string slice_path = \"<dyn \" + path.get () + \">\";\n+      result = CanonicalPath::new_seg (type.get_node_id (), slice_path);\n+    }\n+}\n+\n+void\n+ResolveTypeToCanonicalPath::visit (AST::TraitObjectType &type)\n+{\n+  // FIXME is this actually allowed? dyn A+B\n+  gcc_unreachable ();\n+}\n+\n+ResolveTypeToCanonicalPath::ResolveTypeToCanonicalPath ()\n+  : ResolverBase (), result (CanonicalPath::create_empty ())\n+{}\n+\n+bool\n+ResolveGenericArgs::is_const_value_name (const CanonicalPath &path)\n+{\n+  NodeId resolved;\n+  auto found = resolver->get_name_scope ().lookup (path, &resolved);\n+\n+  return found;\n+}\n+\n+bool\n+ResolveGenericArgs::is_type_name (const CanonicalPath &path)\n+{\n+  NodeId resolved;\n+  auto found = resolver->get_type_scope ().lookup (path, &resolved);\n+\n+  return found;\n+}\n+\n+void\n+ResolveGenericArgs::disambiguate (AST::GenericArg &arg)\n+{\n+  auto path = canonical_prefix.append (\n+    CanonicalPath::new_seg (UNKNOWN_NODEID, arg.get_path ()));\n+\n+  auto is_type = is_type_name (path);\n+  auto is_value = is_const_value_name (path);\n+\n+  // In case we cannot find anything, we resolve the ambiguity to a type.\n+  // This causes the typechecker to error out properly and when necessary.\n+  // But types also take priority over const values in the case of\n+  // ambiguities, hence the weird control flow\n+  if (is_type || (!is_type && !is_value))\n+    arg = arg.disambiguate_to_type ();\n+  else if (is_value)\n+    arg = arg.disambiguate_to_const ();\n+}\n+\n+void\n+ResolveGenericArgs::resolve_disambiguated_generic (AST::GenericArg &arg)\n+{\n+  switch (arg.get_kind ())\n+    {\n+    case AST::GenericArg::Kind::Const:\n+      ResolveExpr::go (arg.get_expression ().get (), prefix, canonical_prefix);\n+      break;\n+    case AST::GenericArg::Kind::Type:\n+      ResolveType::go (arg.get_type ().get ());\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+void\n+ResolveGenericArgs::go (AST::GenericArgs &generic_args)\n+{\n+  auto empty = CanonicalPath::create_empty ();\n+\n+  go (generic_args, empty, empty);\n+}\n+\n+void\n+ResolveGenericArgs::go (AST::GenericArgs &generic_args,\n+\t\t\tconst CanonicalPath &prefix,\n+\t\t\tconst CanonicalPath &canonical_prefix)\n+{\n+  auto resolver = ResolveGenericArgs (prefix, canonical_prefix);\n+\n+  for (auto &arg : generic_args.get_generic_args ())\n+    {\n+      if (arg.get_kind () == AST::GenericArg::Kind::Either)\n+\tresolver.disambiguate (arg);\n+\n+      resolver.resolve_disambiguated_generic (arg);\n+    }\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "5a71268c0d446db816140fed76dc83840554eb99", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "added", "additions": 290, "deletions": 0, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=85a8fe00f805e7889b4e67a98ae1d435c042166b", "patch": "@@ -0,0 +1,290 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_TYPE_H\n+#define RUST_AST_RESOLVE_TYPE_H\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-resolve-expr.h\"\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolveRelativeTypePath\n+{\n+public:\n+  static bool go (AST::TypePath &path, NodeId &resolved_node_id);\n+};\n+\n+class ResolveRelativeQualTypePath : public ResolverBase\n+{\n+  using ResolverBase::visit;\n+\n+public:\n+  static bool go (AST::QualifiedPathInType &path);\n+\n+  void visit (AST::TypePathSegmentGeneric &seg) override;\n+\n+  void visit (AST::TypePathSegment &seg) override;\n+\n+protected:\n+  bool resolve_qual_seg (AST::QualifiedPathType &seg);\n+\n+private:\n+  ResolveRelativeQualTypePath ();\n+\n+  bool failure_flag;\n+};\n+\n+class ResolveType : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static NodeId go (AST::Type *type)\n+  {\n+    ResolveType resolver;\n+    type->accept_vis (resolver);\n+    return resolver.resolved_node;\n+  }\n+\n+  void visit (AST::BareFunctionType &fntype) override\n+  {\n+    for (auto &param : fntype.get_function_params ())\n+      ResolveType::go (param.get_type ().get ());\n+\n+    if (fntype.has_return_type ())\n+      ResolveType::go (fntype.get_return_type ().get ());\n+  }\n+\n+  void visit (AST::TupleType &tuple) override\n+  {\n+    if (tuple.is_unit_type ())\n+      {\n+\tresolved_node = resolver->get_unit_type_node_id ();\n+\treturn;\n+      }\n+\n+    for (auto &elem : tuple.get_elems ())\n+      ResolveType::go (elem.get ());\n+  }\n+\n+  void visit (AST::TypePath &path) override\n+  {\n+    ResolveRelativeTypePath::go (path, resolved_node);\n+  }\n+\n+  void visit (AST::QualifiedPathInType &path) override\n+  {\n+    ResolveRelativeQualTypePath::go (path);\n+  }\n+\n+  void visit (AST::ArrayType &type) override;\n+\n+  void visit (AST::ReferenceType &type) override;\n+\n+  void visit (AST::InferredType &type) override;\n+\n+  void visit (AST::NeverType &type) override;\n+\n+  void visit (AST::RawPointerType &type) override;\n+\n+  void visit (AST::TraitObjectTypeOneBound &type) override;\n+\n+  void visit (AST::TraitObjectType &type) override;\n+\n+  void visit (AST::SliceType &type) override;\n+\n+private:\n+  ResolveType () : ResolverBase () {}\n+};\n+\n+class ResolveTypeBound : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static NodeId go (AST::TypeParamBound *type)\n+  {\n+    ResolveTypeBound resolver;\n+    type->accept_vis (resolver);\n+    return resolver.resolved_node;\n+  };\n+\n+  void visit (AST::TraitBound &bound) override\n+  {\n+    resolved_node = ResolveType::go (&bound.get_type_path ());\n+  }\n+\n+private:\n+  ResolveTypeBound () : ResolverBase () {}\n+};\n+\n+class ResolveGenericParam : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static NodeId go (AST::GenericParam *param, const CanonicalPath &prefix,\n+\t\t    const CanonicalPath &canonical_prefix)\n+  {\n+    ResolveGenericParam resolver (prefix, canonical_prefix);\n+    param->accept_vis (resolver);\n+    return resolver.resolved_node;\n+  }\n+\n+  void visit (AST::ConstGenericParam &param) override\n+  {\n+    ResolveType::go (param.get_type ().get ());\n+\n+    if (param.has_default_value ())\n+      ResolveExpr::go (param.get_default_value ().get_expression ().get (),\n+\t\t       prefix, canonical_prefix);\n+\n+    ok = true;\n+  }\n+\n+  void visit (AST::TypeParam &param) override\n+  {\n+    // if it has a type lets resolve it\n+    if (param.has_type ())\n+      ResolveType::go (param.get_type ().get ());\n+\n+    if (param.has_type_param_bounds ())\n+      {\n+\tfor (auto &bound : param.get_type_param_bounds ())\n+\t  {\n+\t    ResolveTypeBound::go (bound.get ());\n+\t  }\n+      }\n+\n+    auto seg = CanonicalPath::new_seg (param.get_node_id (),\n+\t\t\t\t       param.get_type_representation ());\n+    resolver->get_type_scope ().insert (\n+      seg, param.get_node_id (), param.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\trust_error_at (param.get_locus (),\n+\t\t       \"generic param redefined multiple times\");\n+\trust_error_at (locus, \"was defined here\");\n+      });\n+\n+    mappings->insert_canonical_path (param.get_node_id (), seg);\n+  }\n+\n+private:\n+  ResolveGenericParam (const CanonicalPath &prefix,\n+\t\t       const CanonicalPath &canonical_prefix)\n+    : ResolverBase (), ok (false), prefix (prefix),\n+      canonical_prefix (canonical_prefix)\n+  {}\n+\n+  bool ok;\n+  const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n+};\n+\n+class ResolveWhereClause : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static void Resolve (AST::WhereClause &where_clause)\n+  {\n+    ResolveWhereClause r;\n+    for (auto &clause : where_clause.get_items ())\n+      clause->accept_vis (r);\n+  }\n+\n+  void visit (AST::TypeBoundWhereClauseItem &item) override\n+  {\n+    ResolveType::go (item.get_type ().get ());\n+    if (item.has_type_param_bounds ())\n+      {\n+\tfor (auto &bound : item.get_type_param_bounds ())\n+\t  {\n+\t    ResolveTypeBound::go (bound.get ());\n+\t  }\n+      }\n+  }\n+\n+private:\n+  ResolveWhereClause () : ResolverBase () {}\n+};\n+\n+class ResolveTypeToCanonicalPath : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static bool go (AST::Type *type, CanonicalPath &result);\n+\n+  void visit (AST::TypePath &path) override;\n+\n+  void visit (AST::ReferenceType &type) override;\n+\n+  void visit (AST::RawPointerType &type) override;\n+\n+  void visit (AST::SliceType &type) override;\n+\n+  void visit (AST::TraitObjectTypeOneBound &type) override;\n+\n+  void visit (AST::TraitObjectType &type) override;\n+\n+private:\n+  ResolveTypeToCanonicalPath ();\n+\n+  CanonicalPath result;\n+};\n+\n+class ResolveGenericArgs : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static void go (AST::GenericArgs &generic_args);\n+  static void go (AST::GenericArgs &generic_args, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix);\n+\n+private:\n+  ResolveGenericArgs (const CanonicalPath &prefix,\n+\t\t      const CanonicalPath &canonical_prefix)\n+    : ResolverBase (), prefix (prefix), canonical_prefix (canonical_prefix)\n+  {}\n+\n+  bool is_type_name (const CanonicalPath &path);\n+  bool is_const_value_name (const CanonicalPath &path);\n+\n+  /**\n+   * Resolve a disambiguated generic arg\n+   */\n+  void disambiguate (AST::GenericArg &arg);\n+\n+  /**\n+   * Resolve a disambiguated generic arg\n+   */\n+  void resolve_disambiguated_generic (AST::GenericArg &arg);\n+\n+  const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_TYPE_H"}, {"sha": "93fa7c8761c290acf51ed1de06f1c26abfb83a50", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=85a8fe00f805e7889b4e67a98ae1d435c042166b", "patch": "@@ -0,0 +1,115 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-resolve.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-tyty.h\"\n+#include \"rust-ast-resolve-toplevel.h\"\n+#include \"rust-ast-resolve-item.h\"\n+#include \"rust-ast-resolve-expr.h\"\n+#include \"rust-ast-resolve-struct-expr-field.h\"\n+\n+extern bool\n+saw_errors (void);\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+// NameResolution\n+\n+NameResolution *\n+NameResolution::get ()\n+{\n+  static NameResolution *instance;\n+  if (instance == nullptr)\n+    instance = new NameResolution ();\n+\n+  return instance;\n+}\n+\n+NameResolution::NameResolution ()\n+  : resolver (Resolver::get ()), mappings (Analysis::Mappings::get ())\n+{\n+  // these are global\n+  resolver->get_type_scope ().push (mappings->get_next_node_id ());\n+  resolver->insert_builtin_types (resolver->get_type_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+}\n+\n+void\n+NameResolution::Resolve (AST::Crate &crate)\n+{\n+  auto resolver = get ();\n+  resolver->go (crate);\n+}\n+\n+void\n+NameResolution::go (AST::Crate &crate)\n+{\n+  // lookup current crate name\n+  CrateNum cnum = mappings->get_current_crate ();\n+  std::string crate_name;\n+  bool ok = mappings->get_crate_name (cnum, crate_name);\n+  rust_assert (ok);\n+\n+  // setup the ribs\n+  NodeId scope_node_id = crate.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  // get the root segment\n+  CanonicalPath crate_prefix\n+    = CanonicalPath::new_seg (scope_node_id, crate_name);\n+  crate_prefix.set_crate_num (cnum);\n+\n+  // setup a dummy crate node\n+  resolver->get_name_scope ().insert (\n+    CanonicalPath::new_seg (crate.get_node_id (), \"__$$crate__\"),\n+    crate.get_node_id (), Location ());\n+\n+  // setup the root scope\n+  resolver->push_new_module_scope (scope_node_id);\n+\n+  // first gather the top-level namespace names then we drill down so this\n+  // allows for resolving forward declarations since an impl block might have\n+  // a Self type Foo which is defined after the impl block for example.\n+  for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n+    ResolveTopLevel::go (it->get (), CanonicalPath::create_empty (),\n+\t\t\t crate_prefix);\n+\n+  // FIXME remove this\n+  if (saw_errors ())\n+    {\n+      resolver->pop_module_scope ();\n+      return;\n+    }\n+\n+  // next we can drill down into the items and their scopes\n+  for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n+    ResolveItem::go (it->get (), CanonicalPath::create_empty (), crate_prefix);\n+\n+  // done\n+  resolver->pop_module_scope ();\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "a2e10d5c74247f65a5b7e2329796727b744174b9", "filename": "gcc/rust/resolve/rust-ast-resolve.h", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.h?ref=85a8fe00f805e7889b4e67a98ae1d435c042166b", "patch": "@@ -0,0 +1,50 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_H\n+#define RUST_AST_RESOLVE_H\n+\n+#include \"rust-name-resolver.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-hir-map.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class NameResolution\n+{\n+public:\n+  static void Resolve (AST::Crate &crate);\n+\n+  static NameResolution *get ();\n+\n+  ~NameResolution () {}\n+\n+private:\n+  void go (AST::Crate &crate);\n+\n+  NameResolution ();\n+\n+  Resolver *resolver;\n+  Analysis::Mappings *mappings;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_H"}, {"sha": "74551cb014dcedeba4d3d82da6a9c71f82f322f9", "filename": "gcc/rust/resolve/rust-ast-verify-assignee.h", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h?ref=85a8fe00f805e7889b4e67a98ae1d435c042166b", "patch": "@@ -0,0 +1,84 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_VERIFY_ASSIGNEE\n+#define RUST_AST_VERIFY_ASSIGNEE\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class VerifyAsignee : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static bool go (AST::Expr *assignee, NodeId parent)\n+  {\n+    VerifyAsignee checker (parent);\n+    assignee->accept_vis (checker);\n+    if (!checker.ok)\n+      rust_error_at (assignee->get_locus (),\n+\t\t     \"invalid left-hand side of assignment\");\n+    return checker.ok;\n+  }\n+\n+  void visit (AST::ArrayIndexExpr &expr) override\n+  {\n+    expr.get_array_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (AST::FieldAccessExpr &expr) override\n+  {\n+    expr.get_receiver_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (AST::TupleIndexExpr &expr) override\n+  {\n+    expr.get_tuple_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (AST::IdentifierExpr &expr) override\n+  {\n+    if (!resolver->get_name_scope ().lookup (\n+\t  CanonicalPath::new_seg (expr.get_node_id (), expr.as_string ()),\n+\t  &resolved_node))\n+      return;\n+\n+    ok = true;\n+  }\n+\n+  void visit (AST::DereferenceExpr &expr) override\n+  {\n+    expr.get_dereferenced_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (AST::PathInExpression &expr) override { ok = true; }\n+\n+private:\n+  VerifyAsignee (NodeId parent) : ResolverBase (), ok (false) {}\n+\n+  bool ok;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_VERIFY_ASSIGNEE"}, {"sha": "fb7087425c130cca84b13b4fdcc50057be2958ad", "filename": "gcc/rust/resolve/rust-name-resolver.cc", "status": "added", "additions": 503, "deletions": 0, "changes": 503, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-name-resolver.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-name-resolver.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.cc?ref=85a8fe00f805e7889b4e67a98ae1d435c042166b", "patch": "@@ -0,0 +1,503 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-name-resolver.h\"\n+#include \"rust-ast-full.h\"\n+\n+#define MKBUILTIN_TYPE(_X, _R, _TY)                                            \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      AST::PathIdentSegment seg (_X, Linemap::predeclared_location ());        \\\n+      auto typePath = ::std::unique_ptr<AST::TypePathSegment> (                \\\n+\tnew AST::TypePathSegment (::std::move (seg), false,                    \\\n+\t\t\t\t  Linemap::predeclared_location ()));          \\\n+      ::std::vector< ::std::unique_ptr<AST::TypePathSegment> > segs;           \\\n+      segs.push_back (::std::move (typePath));                                 \\\n+      auto builtin_type                                                        \\\n+\t= new AST::TypePath (::std::move (segs),                               \\\n+\t\t\t     Linemap::predeclared_location (), false);         \\\n+      _R.push_back (builtin_type);                                             \\\n+      tyctx->insert_builtin (_TY->get_ref (), builtin_type->get_node_id (),    \\\n+\t\t\t     _TY);                                             \\\n+      mappings->insert_node_to_hir (builtin_type->get_node_id (),              \\\n+\t\t\t\t    _TY->get_ref ());                          \\\n+      mappings->insert_canonical_path (                                        \\\n+\tbuiltin_type->get_node_id (),                                          \\\n+\tCanonicalPath::new_seg (builtin_type->get_node_id (), _X));            \\\n+    }                                                                          \\\n+  while (0)\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+Rib::Rib (CrateNum crateNum, NodeId node_id)\n+  : crate_num (crateNum), node_id (node_id),\n+    mappings (Analysis::Mappings::get ())\n+{}\n+\n+void\n+Rib::insert_name (\n+  const CanonicalPath &path, NodeId id, Location locus, bool shadow,\n+  std::function<void (const CanonicalPath &, NodeId, Location)> dup_cb)\n+{\n+  auto it = path_mappings.find (path);\n+  bool path_already_exists = it != path_mappings.end ();\n+  if (path_already_exists && !shadow)\n+    {\n+      const auto &decl = decls_within_rib.find (it->second);\n+      if (decl != decls_within_rib.end ())\n+\tdup_cb (path, it->second, decl->second);\n+      else\n+\tdup_cb (path, it->second, locus);\n+\n+      return;\n+    }\n+\n+  path_mappings[path] = id;\n+  reverse_path_mappings.insert (std::pair<NodeId, CanonicalPath> (id, path));\n+  decls_within_rib.insert (std::pair<NodeId, Location> (id, locus));\n+  references[id] = {};\n+}\n+\n+bool\n+Rib::lookup_name (const CanonicalPath &ident, NodeId *id)\n+{\n+  auto it = path_mappings.find (ident);\n+  if (it == path_mappings.end ())\n+    return false;\n+\n+  *id = it->second;\n+  return true;\n+}\n+\n+void\n+Rib::clear_name (const CanonicalPath &ident, NodeId id)\n+{\n+  auto ii = path_mappings.find (ident);\n+  if (ii != path_mappings.end ())\n+    path_mappings.erase (ii);\n+\n+  auto ij = reverse_path_mappings.find (id);\n+  if (ij != reverse_path_mappings.end ())\n+    reverse_path_mappings.erase (ij);\n+\n+  auto ik = decls_within_rib.find (id);\n+  if (ik != decls_within_rib.end ())\n+    decls_within_rib.erase (ik);\n+}\n+\n+void\n+Rib::append_reference_for_def (NodeId def, NodeId ref)\n+{\n+  references[def].insert (ref);\n+}\n+\n+bool\n+Rib::have_references_for_node (NodeId def) const\n+{\n+  auto it = references.find (def);\n+  if (it == references.end ())\n+    return false;\n+\n+  return !it->second.empty ();\n+}\n+\n+bool\n+Rib::decl_was_declared_here (NodeId def) const\n+{\n+  for (auto &it : decls_within_rib)\n+    {\n+      if (it.first == def)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+void\n+Rib::debug () const\n+{\n+  fprintf (stderr, \"%s\\n\", debug_str ().c_str ());\n+}\n+\n+std::string\n+Rib::debug_str () const\n+{\n+  std::string buffer;\n+  for (const auto &it : path_mappings)\n+    {\n+      buffer += it.first.get () + \"=\" + std::to_string (it.second);\n+      buffer += \",\";\n+    }\n+  return \"{\" + buffer + \"}\";\n+}\n+\n+Scope::Scope (CrateNum crate_num) : crate_num (crate_num) {}\n+\n+void\n+Scope::insert (\n+  const CanonicalPath &ident, NodeId id, Location locus, bool shadow,\n+  std::function<void (const CanonicalPath &, NodeId, Location)> dup_cb)\n+{\n+  peek ()->insert_name (ident, id, locus, shadow, dup_cb);\n+}\n+\n+void\n+Scope::insert (const CanonicalPath &ident, NodeId id, Location locus)\n+{\n+  peek ()->insert_name (ident, id, locus, true,\n+\t\t\t[] (const CanonicalPath &, NodeId, Location) -> void {\n+\t\t\t});\n+}\n+\n+bool\n+Scope::lookup (const CanonicalPath &ident, NodeId *id)\n+{\n+  NodeId lookup = UNKNOWN_NODEID;\n+  iterate ([&] (Rib *r) mutable -> bool {\n+    if (r->lookup_name (ident, &lookup))\n+      return false;\n+    return true;\n+  });\n+\n+  *id = lookup;\n+  return lookup != UNKNOWN_NODEID;\n+}\n+\n+void\n+Scope::iterate (std::function<bool (Rib *)> cb)\n+{\n+  for (auto it = stack.rbegin (); it != stack.rend (); ++it)\n+    {\n+      if (!cb (*it))\n+\treturn;\n+    }\n+}\n+\n+void\n+Scope::iterate (std::function<bool (const Rib *)> cb) const\n+{\n+  for (auto it = stack.rbegin (); it != stack.rend (); ++it)\n+    {\n+      if (!cb (*it))\n+\treturn;\n+    }\n+}\n+\n+Rib *\n+Scope::peek ()\n+{\n+  return stack.back ();\n+}\n+\n+void\n+Scope::push (NodeId id)\n+{\n+  stack.push_back (new Rib (get_crate_num (), id));\n+}\n+\n+Rib *\n+Scope::pop ()\n+{\n+  Rib *r = peek ();\n+  stack.pop_back ();\n+  return r;\n+}\n+\n+void\n+Scope::append_reference_for_def (NodeId refId, NodeId defId)\n+{\n+  bool ok = false;\n+  iterate ([&] (Rib *r) mutable -> bool {\n+    if (r->decl_was_declared_here (defId))\n+      {\n+\tok = true;\n+\tr->append_reference_for_def (defId, refId);\n+      }\n+    return true;\n+  });\n+  rust_assert (ok);\n+}\n+\n+bool\n+Scope::decl_was_declared_here (NodeId def) const\n+{\n+  bool found = false;\n+  iterate ([&] (const Rib *r) -> bool {\n+    if (r->decl_was_declared_here (def))\n+      {\n+\tfound = true;\n+\treturn false;\n+      }\n+    return true;\n+  });\n+  return found;\n+}\n+\n+Resolver::Resolver ()\n+  : mappings (Analysis::Mappings::get ()), tyctx (TypeCheckContext::get ()),\n+    name_scope (Scope (mappings->get_current_crate ())),\n+    type_scope (Scope (mappings->get_current_crate ())),\n+    label_scope (Scope (mappings->get_current_crate ())),\n+    macro_scope (Scope (mappings->get_current_crate ())),\n+    global_type_node_id (UNKNOWN_NODEID), unit_ty_node_id (UNKNOWN_NODEID)\n+{\n+  generate_builtins ();\n+}\n+\n+Resolver *\n+Resolver::get ()\n+{\n+  static Resolver *instance;\n+  if (instance == nullptr)\n+    instance = new Resolver ();\n+\n+  return instance;\n+}\n+\n+void\n+Resolver::push_new_name_rib (Rib *r)\n+{\n+  rust_assert (name_ribs.find (r->get_node_id ()) == name_ribs.end ());\n+  name_ribs[r->get_node_id ()] = r;\n+}\n+\n+void\n+Resolver::push_new_type_rib (Rib *r)\n+{\n+  if (type_ribs.size () == 0)\n+    global_type_node_id = r->get_node_id ();\n+\n+  rust_assert (type_ribs.find (r->get_node_id ()) == type_ribs.end ());\n+  type_ribs[r->get_node_id ()] = r;\n+}\n+\n+void\n+Resolver::push_new_label_rib (Rib *r)\n+{\n+  rust_assert (label_ribs.find (r->get_node_id ()) == label_ribs.end ());\n+  label_ribs[r->get_node_id ()] = r;\n+}\n+\n+void\n+Resolver::push_new_macro_rib (Rib *r)\n+{\n+  rust_assert (label_ribs.find (r->get_node_id ()) == label_ribs.end ());\n+  macro_ribs[r->get_node_id ()] = r;\n+}\n+\n+bool\n+Resolver::find_name_rib (NodeId id, Rib **rib)\n+{\n+  auto it = name_ribs.find (id);\n+  if (it == name_ribs.end ())\n+    return false;\n+\n+  *rib = it->second;\n+  return true;\n+}\n+\n+bool\n+Resolver::find_type_rib (NodeId id, Rib **rib)\n+{\n+  auto it = type_ribs.find (id);\n+  if (it == type_ribs.end ())\n+    return false;\n+\n+  *rib = it->second;\n+  return true;\n+}\n+\n+bool\n+Resolver::find_macro_rib (NodeId id, Rib **rib)\n+{\n+  auto it = macro_ribs.find (id);\n+  if (it == macro_ribs.end ())\n+    return false;\n+\n+  *rib = it->second;\n+  return true;\n+}\n+\n+void\n+Resolver::insert_builtin_types (Rib *r)\n+{\n+  auto builtins = get_builtin_types ();\n+  for (auto &builtin : builtins)\n+    {\n+      CanonicalPath builtin_path\n+\t= CanonicalPath::new_seg (builtin->get_node_id (),\n+\t\t\t\t  builtin->as_string ());\n+      r->insert_name (builtin_path, builtin->get_node_id (),\n+\t\t      Linemap::predeclared_location (), false,\n+\t\t      [] (const CanonicalPath &, NodeId, Location) -> void {});\n+    }\n+}\n+\n+std::vector<AST::Type *> &\n+Resolver::get_builtin_types ()\n+{\n+  return builtins;\n+}\n+\n+void\n+Resolver::generate_builtins ()\n+{\n+  auto u8\n+    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U8);\n+  auto u16\n+    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U16);\n+  auto u32\n+    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U32);\n+  auto u64\n+    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U64);\n+  auto u128\n+    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U128);\n+  auto i8 = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I8);\n+  auto i16\n+    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I16);\n+  auto i32\n+    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I32);\n+  auto i64\n+    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I64);\n+  auto i128\n+    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I128);\n+  auto rbool = new TyTy::BoolType (mappings->get_next_hir_id ());\n+  auto f32\n+    = new TyTy::FloatType (mappings->get_next_hir_id (), TyTy::FloatType::F32);\n+  auto f64\n+    = new TyTy::FloatType (mappings->get_next_hir_id (), TyTy::FloatType::F64);\n+  auto usize = new TyTy::USizeType (mappings->get_next_hir_id ());\n+  auto isize = new TyTy::ISizeType (mappings->get_next_hir_id ());\n+  auto char_tyty = new TyTy::CharType (mappings->get_next_hir_id ());\n+  auto str = new TyTy::StrType (mappings->get_next_hir_id ());\n+  auto never = new TyTy::NeverType (mappings->get_next_hir_id ());\n+\n+  MKBUILTIN_TYPE (\"u8\", builtins, u8);\n+  MKBUILTIN_TYPE (\"u16\", builtins, u16);\n+  MKBUILTIN_TYPE (\"u32\", builtins, u32);\n+  MKBUILTIN_TYPE (\"u64\", builtins, u64);\n+  MKBUILTIN_TYPE (\"u128\", builtins, u128);\n+  MKBUILTIN_TYPE (\"i8\", builtins, i8);\n+  MKBUILTIN_TYPE (\"i16\", builtins, i16);\n+  MKBUILTIN_TYPE (\"i32\", builtins, i32);\n+  MKBUILTIN_TYPE (\"i64\", builtins, i64);\n+  MKBUILTIN_TYPE (\"i128\", builtins, i128);\n+  MKBUILTIN_TYPE (\"bool\", builtins, rbool);\n+  MKBUILTIN_TYPE (\"f32\", builtins, f32);\n+  MKBUILTIN_TYPE (\"f64\", builtins, f64);\n+  MKBUILTIN_TYPE (\"usize\", builtins, usize);\n+  MKBUILTIN_TYPE (\"isize\", builtins, isize);\n+  MKBUILTIN_TYPE (\"char\", builtins, char_tyty);\n+  MKBUILTIN_TYPE (\"str\", builtins, str);\n+  MKBUILTIN_TYPE (\"!\", builtins, never);\n+\n+  // unit type ()\n+  TyTy::TupleType *unit_tyty\n+    = TyTy::TupleType::get_unit_type (mappings->get_next_hir_id ());\n+  std::vector<std::unique_ptr<AST::Type> > elems;\n+  AST::TupleType *unit_type\n+    = new AST::TupleType (std::move (elems), Linemap::predeclared_location ());\n+  builtins.push_back (unit_type);\n+  tyctx->insert_builtin (unit_tyty->get_ref (), unit_type->get_node_id (),\n+\t\t\t unit_tyty);\n+  set_unit_type_node_id (unit_type->get_node_id ());\n+}\n+\n+void\n+Resolver::insert_resolved_name (NodeId refId, NodeId defId)\n+{\n+  resolved_names[refId] = defId;\n+  get_name_scope ().append_reference_for_def (refId, defId);\n+}\n+\n+bool\n+Resolver::lookup_resolved_name (NodeId refId, NodeId *defId)\n+{\n+  auto it = resolved_names.find (refId);\n+  if (it == resolved_names.end ())\n+    return false;\n+\n+  *defId = it->second;\n+  return true;\n+}\n+\n+void\n+Resolver::insert_resolved_type (NodeId refId, NodeId defId)\n+{\n+  // auto it = resolved_types.find (refId);\n+  // rust_assert (it == resolved_types.end ());\n+\n+  resolved_types[refId] = defId;\n+  get_type_scope ().append_reference_for_def (refId, defId);\n+}\n+\n+bool\n+Resolver::lookup_resolved_type (NodeId refId, NodeId *defId)\n+{\n+  auto it = resolved_types.find (refId);\n+  if (it == resolved_types.end ())\n+    return false;\n+\n+  *defId = it->second;\n+  return true;\n+}\n+\n+void\n+Resolver::insert_resolved_label (NodeId refId, NodeId defId)\n+{\n+  auto it = resolved_labels.find (refId);\n+  rust_assert (it == resolved_labels.end ());\n+\n+  resolved_labels[refId] = defId;\n+  get_label_scope ().append_reference_for_def (refId, defId);\n+}\n+\n+bool\n+Resolver::lookup_resolved_label (NodeId refId, NodeId *defId)\n+{\n+  auto it = resolved_labels.find (refId);\n+  if (it == resolved_labels.end ())\n+    return false;\n+\n+  *defId = it->second;\n+  return true;\n+}\n+\n+void\n+Resolver::insert_resolved_macro (NodeId refId, NodeId defId)\n+{\n+  auto it = resolved_macros.find (refId);\n+  rust_assert (it == resolved_macros.end ());\n+\n+  resolved_labels[refId] = defId;\n+  get_label_scope ().append_reference_for_def (refId, defId);\n+}\n+\n+bool\n+Resolver::lookup_resolved_macro (NodeId refId, NodeId *defId)\n+{\n+  auto it = resolved_macros.find (refId);\n+  if (it == resolved_macros.end ())\n+    return false;\n+\n+  *defId = it->second;\n+  return true;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "014628a87c9a0fc44a7e0babd6291c274f1ab378", "filename": "gcc/rust/resolve/rust-name-resolver.h", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a8fe00f805e7889b4e67a98ae1d435c042166b/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.h?ref=85a8fe00f805e7889b4e67a98ae1d435c042166b", "patch": "@@ -0,0 +1,212 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_NAME_RESOLVER_H\n+#define RUST_NAME_RESOLVER_H\n+\n+#include \"rust-system.h\"\n+#include \"rust-canonical-path.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-hir-type-check.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class Rib\n+{\n+public:\n+  // Rust uses local_def_ids assigned by def_collector on the AST\n+  // lets use NodeId instead\n+  Rib (CrateNum crateNum, NodeId node_id);\n+\n+  // this takes the relative paths of items within a compilation unit for lookup\n+  void insert_name (\n+    const CanonicalPath &path, NodeId id, Location locus, bool shadow,\n+    std::function<void (const CanonicalPath &, NodeId, Location)> dup_cb);\n+\n+  bool lookup_canonical_path (const NodeId &id, CanonicalPath *ident);\n+  bool lookup_name (const CanonicalPath &ident, NodeId *id);\n+  void clear_name (const CanonicalPath &ident, NodeId id);\n+  void append_reference_for_def (NodeId def, NodeId ref);\n+  bool have_references_for_node (NodeId def) const;\n+  bool decl_was_declared_here (NodeId def) const;\n+  void debug () const;\n+  std::string debug_str () const;\n+\n+  CrateNum get_crate_num () const { return crate_num; }\n+  NodeId get_node_id () const { return node_id; }\n+  std::map<NodeId, Location> &get_declarations () { return decls_within_rib; }\n+\n+private:\n+  CrateNum crate_num;\n+  NodeId node_id;\n+  std::map<CanonicalPath, NodeId> path_mappings;\n+  std::map<NodeId, CanonicalPath> reverse_path_mappings;\n+  std::map<NodeId, Location> decls_within_rib;\n+  std::map<NodeId, std::set<NodeId>> references;\n+  Analysis::Mappings *mappings;\n+};\n+\n+class Scope\n+{\n+public:\n+  Scope (CrateNum crate_num);\n+\n+  void\n+  insert (const CanonicalPath &ident, NodeId id, Location locus, bool shadow,\n+\t  std::function<void (const CanonicalPath &, NodeId, Location)> dup_cb);\n+\n+  void insert (const CanonicalPath &ident, NodeId id, Location locus);\n+  bool lookup (const CanonicalPath &ident, NodeId *id);\n+\n+  void iterate (std::function<bool (Rib *)> cb);\n+  void iterate (std::function<bool (const Rib *)> cb) const;\n+\n+  Rib *peek ();\n+  void push (NodeId id);\n+  Rib *pop ();\n+\n+  bool decl_was_declared_here (NodeId def) const;\n+  void append_reference_for_def (NodeId refId, NodeId defId);\n+\n+  CrateNum get_crate_num () const { return crate_num; }\n+\n+private:\n+  CrateNum crate_num;\n+  std::vector<Rib *> stack;\n+};\n+\n+class Resolver\n+{\n+public:\n+  static Resolver *get ();\n+  ~Resolver () {}\n+\n+  // these builtin types\n+  void insert_builtin_types (Rib *r);\n+\n+  // these will be required for type resolution passes to\n+  // map back to tyty nodes\n+  std::vector<AST::Type *> &get_builtin_types ();\n+\n+  void push_new_name_rib (Rib *r);\n+  void push_new_type_rib (Rib *r);\n+  void push_new_label_rib (Rib *r);\n+  void push_new_macro_rib (Rib *r);\n+\n+  bool find_name_rib (NodeId id, Rib **rib);\n+  bool find_type_rib (NodeId id, Rib **rib);\n+  bool find_label_rib (NodeId id, Rib **rib);\n+  bool find_macro_rib (NodeId id, Rib **rib);\n+\n+  void insert_resolved_name (NodeId refId, NodeId defId);\n+  bool lookup_resolved_name (NodeId refId, NodeId *defId);\n+\n+  void insert_resolved_type (NodeId refId, NodeId defId);\n+  bool lookup_resolved_type (NodeId refId, NodeId *defId);\n+\n+  void insert_resolved_label (NodeId refId, NodeId defId);\n+  bool lookup_resolved_label (NodeId refId, NodeId *defId);\n+\n+  void insert_resolved_macro (NodeId refId, NodeId defId);\n+  bool lookup_resolved_macro (NodeId refId, NodeId *defId);\n+\n+  // proxy for scoping\n+  Scope &get_name_scope () { return name_scope; }\n+  Scope &get_type_scope () { return type_scope; }\n+  Scope &get_label_scope () { return label_scope; }\n+  Scope &get_macro_scope () { return macro_scope; }\n+\n+  NodeId get_global_type_node_id () { return global_type_node_id; }\n+  void set_unit_type_node_id (NodeId id) { unit_ty_node_id = id; }\n+  NodeId get_unit_type_node_id () { return unit_ty_node_id; }\n+\n+  void push_new_module_scope (NodeId module_id)\n+  {\n+    current_module_stack.push_back (module_id);\n+  }\n+\n+  void pop_module_scope ()\n+  {\n+    rust_assert (!current_module_stack.empty ());\n+    current_module_stack.pop_back ();\n+  }\n+\n+  NodeId peek_current_module_scope () const\n+  {\n+    rust_assert (!current_module_stack.empty ());\n+    return current_module_stack.back ();\n+  }\n+\n+  NodeId peek_crate_module_scope () const\n+  {\n+    rust_assert (!current_module_stack.empty ());\n+    return current_module_stack.front ();\n+  }\n+\n+  NodeId peek_parent_module_scope () const\n+  {\n+    rust_assert (current_module_stack.size () > 1);\n+    return current_module_stack.at (current_module_stack.size () - 2);\n+  }\n+\n+private:\n+  Resolver ();\n+\n+  void generate_builtins ();\n+\n+  Analysis::Mappings *mappings;\n+  TypeCheckContext *tyctx;\n+\n+  std::vector<AST::Type *> builtins;\n+\n+  Scope name_scope;\n+  Scope type_scope;\n+  Scope label_scope;\n+  Scope macro_scope;\n+\n+  NodeId global_type_node_id;\n+  NodeId unit_ty_node_id;\n+\n+  // map a AST Node to a Rib\n+  std::map<NodeId, Rib *> name_ribs;\n+  std::map<NodeId, Rib *> type_ribs;\n+  std::map<NodeId, Rib *> label_ribs;\n+  std::map<NodeId, Rib *> macro_ribs;\n+\n+  // Rust uses DefIds to namespace these under a crate_num\n+  // but then it uses the def_collector to assign local_defids\n+  // to each ast node as well. not sure if this is going to fit\n+  // with gcc very well to compile a full crate in one go but we will\n+  // see.\n+\n+  // these are of the form ref->Def-NodeId\n+  // we need two namespaces one for names and ones for types\n+  std::map<NodeId, NodeId> resolved_names;\n+  std::map<NodeId, NodeId> resolved_types;\n+  std::map<NodeId, NodeId> resolved_labels;\n+  std::map<NodeId, NodeId> resolved_macros;\n+\n+  // keep track of the current module scope ids\n+  std::vector<NodeId> current_module_stack;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_NAME_RESOLVER_H"}]}