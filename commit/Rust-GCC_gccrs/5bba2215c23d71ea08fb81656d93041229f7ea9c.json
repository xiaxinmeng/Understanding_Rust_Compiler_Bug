{"sha": "5bba2215c23d71ea08fb81656d93041229f7ea9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJiYTIyMTVjMjNkNzFlYTA4ZmI4MTY1NmQ5MzA0MTIyOWY3ZWE5Yw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-11-19T21:18:09Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-11-19T21:25:00Z"}, "message": "c++: Template hash access\n\nThis exposes the template specialization table, so the modules\nmachinery may access it.  The hashed entity (tmpl, args & spec) is\navailable, along with a hash table walker.  We also need a way of\nfinding or inserting entries, along with some bookkeeping fns to deal\nwith the instantiation and (partial) specialization lists.\n\n\tgcc/cp/\n\t* cp-tree.h (struct spec_entry): Moved from pt.c.\n\t(walk_specializations, match_mergeable_specialization)\n\t(get_mergeable_specialization_flags)\n\t(add_mergeable_specialization): Declare.\n\t* pt.c (struct spec_entry): Moved to cp-tree.h.\n\t(walk_specializations, match_mergeable_specialization)\n\t(get_mergeable_specialization_flags)\n\t(add_mergeable_specialization): New.", "tree": {"sha": "db66443f05f6268c3fda4f83c6d718b9bb87fb0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db66443f05f6268c3fda4f83c6d718b9bb87fb0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5bba2215c23d71ea08fb81656d93041229f7ea9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bba2215c23d71ea08fb81656d93041229f7ea9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bba2215c23d71ea08fb81656d93041229f7ea9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bba2215c23d71ea08fb81656d93041229f7ea9c/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08b4d325711d5c6f68ac29443aba3fd7aa173ac8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08b4d325711d5c6f68ac29443aba3fd7aa173ac8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08b4d325711d5c6f68ac29443aba3fd7aa173ac8"}], "stats": {"total": 119, "additions": 112, "deletions": 7}, "files": [{"sha": "021de76e14255eaae8990748270734053b255710", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bba2215c23d71ea08fb81656d93041229f7ea9c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bba2215c23d71ea08fb81656d93041229f7ea9c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5bba2215c23d71ea08fb81656d93041229f7ea9c", "patch": "@@ -5403,6 +5403,14 @@ class local_specialization_stack\n   hash_map<tree, tree> *saved;\n };\n \n+/* Entry in the specialization hash table.  */\n+struct GTY((for_user)) spec_entry\n+{\n+  tree tmpl;  /* The general template this is a specialization of.  */\n+  tree args;  /* The args for this (maybe-partial) specialization.  */\n+  tree spec;  /* The specialization itself.  */\n+};\n+\n /* in class.c */\n \n extern int current_class_depth;\n@@ -6994,6 +7002,15 @@ extern bool copy_guide_p\t\t\t(const_tree);\n extern bool template_guide_p\t\t\t(const_tree);\n extern bool builtin_guide_p\t\t\t(const_tree);\n extern void store_explicit_specifier\t\t(tree, tree);\n+extern void walk_specializations\t\t(bool,\n+\t\t\t\t\t\t void (*)(bool, spec_entry *,\n+\t\t\t\t\t\t\t  void *),\n+\t\t\t\t\t\t void *);\n+extern tree match_mergeable_specialization\t(bool is_decl, tree tmpl,\n+\t\t\t\t\t\t tree args, tree spec);\n+extern unsigned get_mergeable_specialization_flags (tree tmpl, tree spec);\n+extern void add_mergeable_specialization        (tree tmpl, tree args,\n+\t\t\t\t\t\t tree spec, unsigned);\n extern tree add_outermost_template_args\t\t(tree, tree);\n extern tree add_extra_args\t\t\t(tree, tree);\n extern tree build_extra_args\t\t\t(tree, tree, tsubst_flags_t);"}, {"sha": "463b1c3a57d6de4ab6e2c39792474e9c1a858241", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 95, "deletions": 7, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bba2215c23d71ea08fb81656d93041229f7ea9c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bba2215c23d71ea08fb81656d93041229f7ea9c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5bba2215c23d71ea08fb81656d93041229f7ea9c", "patch": "@@ -103,13 +103,6 @@ local_specialization_stack::~local_specialization_stack ()\n /* True if we've recursed into fn_type_unification too many times.  */\n static bool excessive_deduction_depth;\n \n-struct GTY((for_user)) spec_entry\n-{\n-  tree tmpl;\n-  tree args;\n-  tree spec;\n-};\n-\n struct spec_hasher : ggc_ptr_hash<spec_entry>\n {\n   static hashval_t hash (spec_entry *);\n@@ -29625,6 +29618,101 @@ declare_integer_pack (void)\n \t\t\t      CP_BUILT_IN_INTEGER_PACK);\n }\n \n+/* Walk the decl or type specialization table calling FN on each\n+   entry.  */\n+\n+void\n+walk_specializations (bool decls_p,\n+\t\t      void (*fn) (bool decls_p, spec_entry *entry, void *data),\n+\t\t      void *data)\n+{\n+  spec_hash_table *table = decls_p ? decl_specializations\n+    : type_specializations;\n+  spec_hash_table::iterator end (table->end ());\n+  for (spec_hash_table::iterator iter (table->begin ()); iter != end; ++iter)\n+    fn (decls_p, *iter, data);\n+}\n+\n+/* Lookup the specialization of TMPL, ARGS in the decl or type\n+   specialization table.  Return what's there, or if SPEC is non-null,\n+   add it and return NULL.  */\n+\n+tree\n+match_mergeable_specialization (bool decl_p, tree tmpl, tree args, tree spec)\n+{\n+  spec_entry elt = {tmpl, args, spec};\n+  hash_table<spec_hasher> *specializations\n+    = decl_p ? decl_specializations : type_specializations;\n+  hashval_t hash = spec_hasher::hash (&elt);\n+  spec_entry **slot\n+    = specializations->find_slot_with_hash (&elt, hash,\n+\t\t\t\t\t    spec ? INSERT : NO_INSERT);\n+  spec_entry *entry = slot ? *slot: NULL;\n+  \n+  if (entry)\n+    return entry->spec;\n+\n+  if (spec)\n+    {\n+      entry = ggc_alloc<spec_entry> ();\n+      *entry = elt;\n+      *slot = entry;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Return flags encoding whether SPEC is on the instantiation and/or\n+   specialization lists of TMPL.  */\n+\n+unsigned\n+get_mergeable_specialization_flags (tree tmpl, tree decl)\n+{\n+  unsigned flags = 0;\n+\n+  for (tree inst = DECL_TEMPLATE_INSTANTIATIONS (tmpl);\n+       inst; inst = TREE_CHAIN (inst))\n+    if (TREE_VALUE (inst) == decl)\n+      {\n+\tflags |= 1;\n+\tbreak;\n+      }\n+\n+  if (CLASS_TYPE_P (TREE_TYPE (decl))\n+      && CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (decl))\n+      && CLASSTYPE_USE_TEMPLATE (TREE_TYPE (decl)) == 2)\n+    /* Only need to search if DECL is a partial specialization.  */\n+    for (tree part = DECL_TEMPLATE_SPECIALIZATIONS (tmpl);\n+\t part; part = TREE_CHAIN (part))\n+      if (TREE_VALUE (part) == decl)\n+\t{\n+\t  flags |= 2;\n+\t  break;\n+\t}\n+\n+  return flags;\n+}\n+\n+/* Add a new specialization of TMPL.  FLAGS is as returned from\n+   get_mergeable_specialization_flags.  */\n+\n+void\n+add_mergeable_specialization (tree tmpl, tree args, tree decl, unsigned flags)\n+{\n+  if (flags & 1)\n+    DECL_TEMPLATE_INSTANTIATIONS (tmpl)\n+      = tree_cons (args, decl, DECL_TEMPLATE_INSTANTIATIONS (tmpl));\n+\n+  if (flags & 2)\n+    {\n+      /* A partial specialization.  */\n+      DECL_TEMPLATE_SPECIALIZATIONS (tmpl)\n+\t= tree_cons (args, decl, DECL_TEMPLATE_SPECIALIZATIONS (tmpl));\n+      TREE_TYPE (DECL_TEMPLATE_SPECIALIZATIONS (tmpl))\n+\t= TREE_TYPE (DECL_TEMPLATE_RESULT (decl));\n+    }\n+}\n+\n /* Set up the hash tables for template instantiations.  */\n \n void"}]}