{"sha": "1adae327479aaff6d8020d9df6e401b7075c5672", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFkYWUzMjc0NzlhYWZmNmQ4MDIwZDlkZjZlNDAxYjcwNzVjNTY3Mg==", "commit": {"author": {"name": "Bernd Edlinger", "email": "bernd.edlinger@hotmail.de", "date": "2016-10-03T14:05:46Z"}, "committer": {"name": "Bernd Edlinger", "email": "edlinger@gcc.gnu.org", "date": "2016-10-03T14:05:46Z"}, "message": "re PR preprocessor/77699 (suspicious code in get_next_line)\n\n2016-10-03  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n\n        PR preprocessor/77699\n        * input.c (maybe_grow): Don't allocate one byte extra headroom.\n        (get_next_line): Return false on error.\n        (read_next_line): Removed, use get_next_line instead.\n        (read_line_num): Don't copy the line.\n        (location_get_source_line): Don't use static data.\n        (selftest::test_reading_source_line): Add more test cases.\n\nFrom-SVN: r240713", "tree": {"sha": "bf3d97cb2d5979631ce86c0a5481f6a726caf672", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf3d97cb2d5979631ce86c0a5481f6a726caf672"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1adae327479aaff6d8020d9df6e401b7075c5672", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1adae327479aaff6d8020d9df6e401b7075c5672", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1adae327479aaff6d8020d9df6e401b7075c5672", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1adae327479aaff6d8020d9df6e401b7075c5672/comments", "author": {"login": "bernd-edlinger", "id": 17638929, "node_id": "MDQ6VXNlcjE3NjM4OTI5", "avatar_url": "https://avatars.githubusercontent.com/u/17638929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bernd-edlinger", "html_url": "https://github.com/bernd-edlinger", "followers_url": "https://api.github.com/users/bernd-edlinger/followers", "following_url": "https://api.github.com/users/bernd-edlinger/following{/other_user}", "gists_url": "https://api.github.com/users/bernd-edlinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/bernd-edlinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bernd-edlinger/subscriptions", "organizations_url": "https://api.github.com/users/bernd-edlinger/orgs", "repos_url": "https://api.github.com/users/bernd-edlinger/repos", "events_url": "https://api.github.com/users/bernd-edlinger/events{/privacy}", "received_events_url": "https://api.github.com/users/bernd-edlinger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d07b0a23a5b00c9f51ff052f60c911013f036a7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d07b0a23a5b00c9f51ff052f60c911013f036a7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d07b0a23a5b00c9f51ff052f60c911013f036a7c"}], "stats": {"total": 114, "additions": 47, "deletions": 67}, "files": [{"sha": "824d1a8602c83af4ecb572d2b167a30862e3ae47", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1adae327479aaff6d8020d9df6e401b7075c5672/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1adae327479aaff6d8020d9df6e401b7075c5672/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1adae327479aaff6d8020d9df6e401b7075c5672", "patch": "@@ -1,3 +1,13 @@\n+2016-10-03  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\tPR preprocessor/77699\n+\t* input.c (maybe_grow): Don't allocate one byte extra headroom.\n+\t(get_next_line): Return false on error.\n+\t(read_next_line): Removed, use get_next_line instead.\n+\t(read_line_num): Don't copy the line.\n+\t(location_get_source_line): Don't use static data.\n+\t(selftest::test_reading_source_line): Add more test cases.\n+\n 2016-10-03  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tRevert"}, {"sha": "67f727e5a2b7292b83a37cf957cc3f106c144238", "filename": "gcc/input.c", "status": "modified", "additions": 37, "deletions": 67, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1adae327479aaff6d8020d9df6e401b7075c5672/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1adae327479aaff6d8020d9df6e401b7075c5672/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=1adae327479aaff6d8020d9df6e401b7075c5672", "patch": "@@ -432,7 +432,7 @@ maybe_grow (fcache *c)\n     return;\n \n   size_t size = c->size == 0 ? fcache_buffer_size : c->size * 2;\n-  c->data = XRESIZEVEC (char, c->data, size + 1);\n+  c->data = XRESIZEVEC (char, c->data, size);\n   c->size = size;\n }\n \n@@ -472,14 +472,13 @@ maybe_read_data (fcache *c)\n \n /* Read a new line from file FP, using C as a cache for the data\n    coming from the file.  Upon successful completion, *LINE is set to\n-   the beginning of the line found.  Space for that line has been\n-   allocated in the cache thus *LINE has the same life time as C.\n+   the beginning of the line found.  *LINE points directly in the\n+   line cache and is only valid until the next call of get_next_line.\n    *LINE_LEN is set to the length of the line.  Note that the line\n    does not contain any terminal delimiter.  This function returns\n    true if some data was read or process from the cache, false\n-   otherwise.  Note that subsequent calls to get_next_line return the\n-   next lines of the file and might overwrite the content of\n-   *LINE.  */\n+   otherwise.  Note that subsequent calls to get_next_line might\n+   make the content of *LINE invalid.  */\n \n static bool\n get_next_line (fcache *c, char **line, ssize_t *line_len)\n@@ -534,7 +533,7 @@ get_next_line (fcache *c, char **line, ssize_t *line_len)\n     }\n \n   if (ferror (c->fp))\n-    return -1;\n+    return false;\n \n   /* At this point, we've found the end of the of line.  It either\n      points to the '\\n' or to one byte after the last byte of the\n@@ -597,36 +596,6 @@ get_next_line (fcache *c, char **line, ssize_t *line_len)\n   return true;\n }\n \n-/* Reads the next line from FILE into *LINE.  If *LINE is too small\n-   (or NULL) it is allocated (or extended) to have enough space to\n-   containe the line.  *LINE_LENGTH must contain the size of the\n-   initial*LINE buffer.  It's then updated by this function to the\n-   actual length of the returned line.  Note that the returned line\n-   can contain several zero bytes.  Also note that the returned string\n-   is allocated in static storage that is going to be re-used by\n-   subsequent invocations of read_line.  */\n-\n-static bool\n-read_next_line (fcache *cache, char ** line, ssize_t *line_len)\n-{\n-  char *l = NULL;\n-  ssize_t len = 0;\n-\n-  if (!get_next_line (cache, &l, &len))\n-    return false;\n-\n-  if (*line == NULL)\n-    *line = XNEWVEC (char, len);\n-  else\n-    if (*line_len < len)\n-\t*line = XRESIZEVEC (char, *line, len);\n-\n-  memcpy (*line, l, len);\n-  *line_len = len;\n-\n-  return true;\n-}\n-\n /* Consume the next bytes coming from the cache (or from its\n    underlying file if there are remaining unread bytes in the file)\n    until we reach the next end-of-line (or end-of-file).  There is no\n@@ -643,15 +612,15 @@ goto_next_line (fcache *cache)\n }\n \n /* Read an arbitrary line number LINE_NUM from the file cached in C.\n-   The line is copied into *LINE.  *LINE_LEN must have been set to the\n-   length of *LINE.  If *LINE is too small (or NULL) it's extended (or\n-   allocated) and *LINE_LEN is adjusted accordingly.  *LINE ends up\n-   with a terminal zero byte and can contain additional zero bytes.\n+   If the line was read successfully, *LINE points to the beginning\n+   of the line in the file cache and *LINE_LEN is the length of the\n+   line.  *LINE is not nul-terminated, but may contain zero bytes.\n+   *LINE is only valid until the next call of read_line_num.\n    This function returns bool if a line was read.  */\n \n static bool\n read_line_num (fcache *c, size_t line_num,\n-\t       char ** line, ssize_t *line_len)\n+\t       char **line, ssize_t *line_len)\n {\n   gcc_assert (line_num > 0);\n \n@@ -703,14 +672,9 @@ read_line_num (fcache *c, size_t line_num,\n \n \t  if (i && i->line_num == line_num)\n \t    {\n-\t      /* We have the start/end of the line.  Let's just copy\n-\t\t it again and we are done.  */\n-\t      ssize_t len = i->end_pos - i->start_pos + 1;\n-\t      if (*line_len < len)\n-\t\t*line = XRESIZEVEC (char, *line, len);\n-\t      memmove (*line, c->data + i->start_pos, len);\n-\t      (*line)[len - 1] = '\\0';\n-\t      *line_len = --len;\n+\t      /* We have the start/end of the line.  */\n+\t      *line = c->data + i->start_pos;\n+\t      *line_len = i->end_pos - i->start_pos;\n \t      return true;\n \t    }\n \n@@ -735,21 +699,22 @@ read_line_num (fcache *c, size_t line_num,\n \n   /* The line we want is the next one.  Let's read and copy it back to\n      the caller.  */\n-  return read_next_line (c, line, line_len);\n+  return get_next_line (c, line, line_len);\n }\n \n-/* Return the physical source line that corresponds to FILE_PATH/LINE in a\n-   buffer that is statically allocated.  The newline is replaced by\n-   the null character.  Note that the line can contain several null\n-   characters, so LINE_LEN, if non-null, points to the actual length\n-   of the line.  */\n+/* Return the physical source line that corresponds to FILE_PATH/LINE.\n+   The line is not nul-terminated.  The returned pointer is only\n+   valid until the next call of location_get_source_line.\n+   Note that the line can contain several null characters,\n+   so LINE_LEN, if non-null, points to the actual length of the line.\n+   If the function fails, NULL is returned.  */\n \n const char *\n location_get_source_line (const char *file_path, int line,\n \t\t\t  int *line_len)\n {\n-  static char *buffer;\n-  static ssize_t len;\n+  char *buffer;\n+  ssize_t len;\n \n   if (line == 0)\n     return NULL;\n@@ -1818,22 +1783,27 @@ test_reading_source_line ()\n   temp_source_file tmp (SELFTEST_LOCATION, \".txt\",\n \t\t\t\"01234567890123456789\\n\"\n \t\t\t\"This is the test text\\n\"\n-\t\t\t\"This is the 3rd line\\n\");\n+\t\t\t\"This is the 3rd line\");\n \n   /* Read back a specific line from the tempfile.  */\n   int line_size;\n   const char *source_line = location_get_source_line (tmp.get_filename (),\n-\t\t\t\t\t\t      2, &line_size);\n+\t\t\t\t\t\t      3, &line_size);\n+  ASSERT_TRUE (source_line != NULL);\n+  ASSERT_EQ (20, line_size);\n+  ASSERT_TRUE (!strncmp (\"This is the 3rd line\",\n+\t\t\t source_line, line_size));\n+\n+  source_line = location_get_source_line (tmp.get_filename (),\n+\t\t\t\t\t  2, &line_size);\n   ASSERT_TRUE (source_line != NULL);\n   ASSERT_EQ (21, line_size);\n-  if (!strncmp (\"This is the test text\",\n-\t\tsource_line, line_size))\n-    ::selftest::pass (SELFTEST_LOCATION,\n-\t\t      \"source_line matched expected value\");\n-  else\n-    ::selftest::fail (SELFTEST_LOCATION,\n-\t\t      \"source_line did not match expected value\");\n+  ASSERT_TRUE (!strncmp (\"This is the test text\",\n+\t\t\t source_line, line_size));\n \n+  source_line = location_get_source_line (tmp.get_filename (),\n+\t\t\t\t\t  4, &line_size);\n+  ASSERT_TRUE (source_line == NULL);\n }\n \n /* Tests of lexing.  */"}]}