{"sha": "36ba4aaedc8507aa7f66add20d92b65df3b8faff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZiYTRhYWVkYzg1MDdhYTdmNjZhZGQyMGQ5MmI2NWRmM2I4ZmFmZg==", "commit": {"author": {"name": "Ira Rosen", "email": "ira.rosen@linaro.org", "date": "2011-10-18T09:39:04Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2011-10-18T09:39:04Z"}, "message": "md.texi (vec_widen_ushiftl_hi, [...]): Document.\n\n\n\t* doc/md.texi (vec_widen_ushiftl_hi, vec_widen_ushiftl_lo,\n\tvec_widen_sshiftl_hi, vec_widen_sshiftl_lo): Document.\n\t* tree-pretty-print.c (dump_generic_node): Handle WIDEN_LSHIFT_EXPR,\n\tVEC_WIDEN_LSHIFT_HI_EXPR and VEC_WIDEN_LSHIFT_LO_EXPR.\n\t(op_code_prio): Likewise.\n\t(op_symbol_code): Handle WIDEN_LSHIFT_EXPR.\n\t* optabs.c (optab_for_tree_code): Handle\n\tVEC_WIDEN_LSHIFT_HI_EXPR and VEC_WIDEN_LSHIFT_LO_EXPR.\n\t(init-optabs): Initialize optab codes for vec_widen_u/sshiftl_hi/lo.\n\t* optabs.h (enum optab_index): Add OTI_vec_widen_u/sshiftl_hi/lo.\n\t* genopinit.c (optabs): Initialize the new optabs.\n\t* expr.c (expand_expr_real_2): Handle\n\tVEC_WIDEN_LSHIFT_HI_EXPR and VEC_WIDEN_LSHIFT_LO_EXPR.\n\t* gimple-pretty-print.c (dump_binary_rhs): Likewise.\n\t* tree-vectorizer.h (NUM_PATTERNS): Increase to 8.\n\t* tree.def (WIDEN_LSHIFT_EXPR, VEC_WIDEN_LSHIFT_HI_EXPR,\n\tVEC_WIDEN_LSHIFT_LO_EXPR): New.\n\t* cfgexpand.c (expand_debug_expr): Handle new tree codes.\n\t* tree-vect-patterns.c (vect_vect_recog_func_ptrs): Add\n\tvect_recog_widen_shift_pattern.\n\t(vect_handle_widen_mult_by_const): Rename...\n\t(vect_handle_widen_op_by_const): ...to this.  Handle shifts.\n\tAdd a new argument, update documentation.\n\t(vect_recog_widen_mult_pattern): Assume that only second\n\toperand can be constant.  Update call to\n\tvect_handle_widen_op_by_const.\n\t(vect_recog_over_widening_pattern): Fix typo.\n\t(vect_recog_widen_shift_pattern): New.\n\t* tree-vect-stmts.c (vectorizable_type_promotion): Handle\n\twidening shifts.\n\t(supportable_widening_operation): Likewise.\n\t* tree-inline.c (estimate_operator_cost): Handle new tree codes.\n\t* tree-vect-generic.c (expand_vector_operations_1): Likewise.\n\t* tree-cfg.c (verify_gimple_assign_binary): Likewise.\n\t* config/arm/neon.md (neon_vec_<US>shiftl_<mode>): New.\n\t(vec_widen_<US>shiftl_lo_<mode>, neon_vec_<US>shiftl_hi_<mode>,\n\tvec_widen_<US>shiftl_hi_<mode>, neon_vec_<US>shift_left_<mode>):\n\tLikewise.\n\t* config/arm/predicates.md (const_neon_scalar_shift_amount_operand):\n\tNew.\n\t* config/arm/iterators.md (V_innermode): New.\n\t* tree-vect-slp.c (vect_build_slp_tree): Require same shift operand\n\tfor widening shift.\n\nFrom-SVN: r180128", "tree": {"sha": "003e1d024145ae0b6a8fe049fd43e175358d9b1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/003e1d024145ae0b6a8fe049fd43e175358d9b1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36ba4aaedc8507aa7f66add20d92b65df3b8faff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36ba4aaedc8507aa7f66add20d92b65df3b8faff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36ba4aaedc8507aa7f66add20d92b65df3b8faff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36ba4aaedc8507aa7f66add20d92b65df3b8faff/comments", "author": null, "committer": null, "parents": [{"sha": "d355361573c6be211721cc5c945dd5cecdd33c6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d355361573c6be211721cc5c945dd5cecdd33c6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d355361573c6be211721cc5c945dd5cecdd33c6b"}], "stats": {"total": 944, "additions": 895, "deletions": 49}, "files": [{"sha": "8247454031a6bbed52e4f6b3c08dc4dedd26e41c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -1,3 +1,49 @@\n+2011-10-18  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* doc/md.texi (vec_widen_ushiftl_hi, vec_widen_ushiftl_lo,\n+\tvec_widen_sshiftl_hi, vec_widen_sshiftl_lo): Document.\n+\t* tree-pretty-print.c (dump_generic_node): Handle WIDEN_LSHIFT_EXPR,\n+\tVEC_WIDEN_LSHIFT_HI_EXPR and VEC_WIDEN_LSHIFT_LO_EXPR.\n+\t(op_code_prio): Likewise.\n+\t(op_symbol_code): Handle WIDEN_LSHIFT_EXPR.\n+\t* optabs.c (optab_for_tree_code): Handle\n+\tVEC_WIDEN_LSHIFT_HI_EXPR and VEC_WIDEN_LSHIFT_LO_EXPR.\n+\t(init-optabs): Initialize optab codes for vec_widen_u/sshiftl_hi/lo.\n+\t* optabs.h (enum optab_index): Add OTI_vec_widen_u/sshiftl_hi/lo.\n+\t* genopinit.c (optabs): Initialize the new optabs.\n+\t* expr.c (expand_expr_real_2): Handle\n+\tVEC_WIDEN_LSHIFT_HI_EXPR and VEC_WIDEN_LSHIFT_LO_EXPR.\n+\t* gimple-pretty-print.c (dump_binary_rhs): Likewise.\n+\t* tree-vectorizer.h (NUM_PATTERNS): Increase to 8.\n+\t* tree.def (WIDEN_LSHIFT_EXPR, VEC_WIDEN_LSHIFT_HI_EXPR,\n+\tVEC_WIDEN_LSHIFT_LO_EXPR): New.\n+\t* cfgexpand.c (expand_debug_expr): Handle new tree codes.\n+\t* tree-vect-patterns.c (vect_vect_recog_func_ptrs): Add\n+\tvect_recog_widen_shift_pattern.\n+\t(vect_handle_widen_mult_by_const): Rename...\n+\t(vect_handle_widen_op_by_const): ...to this.  Handle shifts.\n+\tAdd a new argument, update documentation.\n+\t(vect_recog_widen_mult_pattern): Assume that only second\n+\toperand can be constant.  Update call to\n+\tvect_handle_widen_op_by_const.\n+\t(vect_recog_over_widening_pattern): Fix typo.\n+\t(vect_recog_widen_shift_pattern): New.\n+\t* tree-vect-stmts.c (vectorizable_type_promotion): Handle\n+\twidening shifts.\n+\t(supportable_widening_operation): Likewise.\n+\t* tree-inline.c (estimate_operator_cost): Handle new tree codes.\n+\t* tree-vect-generic.c (expand_vector_operations_1): Likewise.\n+\t* tree-cfg.c (verify_gimple_assign_binary): Likewise.\n+\t* config/arm/neon.md (neon_vec_<US>shiftl_<mode>): New.\n+\t(vec_widen_<US>shiftl_lo_<mode>, neon_vec_<US>shiftl_hi_<mode>,\n+\tvec_widen_<US>shiftl_hi_<mode>, neon_vec_<US>shift_left_<mode>):\n+\tLikewise.\n+\t* config/arm/predicates.md (const_neon_scalar_shift_amount_operand):\n+\tNew.\n+\t* config/arm/iterators.md (V_innermode): New.\n+\t* tree-vect-slp.c (vect_build_slp_tree): Require same shift operand\n+\tfor widening shift.\n+\n 2011-10-18  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-alias.h (struct pt_solution): Remove"}, {"sha": "045c2e28813f035f88930d5e77277964eaee8710", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -3265,6 +3265,8 @@ expand_debug_expr (tree exp)\n     case VEC_UNPACK_LO_EXPR:\n     case VEC_WIDEN_MULT_HI_EXPR:\n     case VEC_WIDEN_MULT_LO_EXPR:\n+    case VEC_WIDEN_LSHIFT_HI_EXPR:\n+    case VEC_WIDEN_LSHIFT_LO_EXPR:\n       return NULL;\n \n    /* Misc codes.  */"}, {"sha": "08874ff0411be004af5858634f0917ca7c3eb097", "filename": "gcc/config/arm/iterators.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Fconfig%2Farm%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Fconfig%2Farm%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiterators.md?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -414,6 +414,9 @@\n \t\t\t       (V4QQ \"8\") (V2HQ \"16\") (QQ \"8\") (HQ \"16\")\n \t\t\t       (V2HA \"16\") (HA \"16\") (SQ \"\") (SA \"\")])\n \n+;; Mode attribute for vshll.\n+(define_mode_attr V_innermode [(V8QI \"QI\") (V4HI \"HI\") (V2SI \"SI\")])\n+\n ;;----------------------------------------------------------------------------\n ;; Code attributes\n ;;----------------------------------------------------------------------------"}, {"sha": "5cbe5bed2ccb8c2e5d1da9776ca17217724eba3d", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -5335,6 +5335,44 @@\n  }\n )\n \n+(define_insn \"neon_vec_<US>shiftl_<mode>\"\n+ [(set (match_operand:<V_widen> 0 \"register_operand\" \"=w\")\n+       (SE:<V_widen> (ashift:VW (match_operand:VW 1 \"register_operand\" \"w\")\n+       (match_operand:<V_innermode> 2 \"const_neon_scalar_shift_amount_operand\" \"\"))))]\n+  \"TARGET_NEON\"\n+{\n+  return \"vshll.<US><V_sz_elem> %q0, %P1, %2\";\n+}\n+  [(set_attr \"neon_type\" \"neon_shift_1\")]\n+)\n+\n+(define_expand \"vec_widen_<US>shiftl_lo_<mode>\"\n+  [(match_operand:<V_unpack> 0 \"register_operand\" \"\")\n+   (SE:<V_unpack> (match_operand:VU 1 \"register_operand\" \"\"))\n+   (match_operand:SI 2 \"immediate_operand\" \"i\")]\n+ \"TARGET_NEON && !BYTES_BIG_ENDIAN\"\n+ {\n+  emit_insn (gen_neon_vec_<US>shiftl_<V_half> (operands[0],\n+\t\tsimplify_gen_subreg (<V_HALF>mode, operands[1], <MODE>mode, 0),\n+\t\toperands[2]));\n+   DONE;\n+ }\n+)\n+\n+(define_expand \"vec_widen_<US>shiftl_hi_<mode>\"\n+  [(match_operand:<V_unpack> 0 \"register_operand\" \"\")\n+   (SE:<V_unpack> (match_operand:VU 1 \"register_operand\" \"\"))\n+   (match_operand:SI 2 \"immediate_operand\" \"i\")]\n+ \"TARGET_NEON && !BYTES_BIG_ENDIAN\"\n+ {\n+  emit_insn (gen_neon_vec_<US>shiftl_<V_half> (operands[0],\n+                simplify_gen_subreg (<V_HALF>mode, operands[1], <MODE>mode,\n+\t\t\t\t     GET_MODE_SIZE (<V_HALF>mode)),\n+                operands[2]));\n+   DONE;\n+ }\n+)\n+\n ;; Vectorize for non-neon-quad case\n (define_insn \"neon_unpack<US>_<mode>\"\n  [(set (match_operand:<V_widen> 0 \"register_operand\" \"=w\")\n@@ -5411,6 +5449,34 @@\n  }\n )\n \n+(define_expand \"vec_widen_<US>shiftl_hi_<mode>\"\n+ [(match_operand:<V_double_width> 0 \"register_operand\" \"\")\n+   (SE:<V_double_width> (match_operand:VDI 1 \"register_operand\" \"\"))\n+   (match_operand:SI 2 \"immediate_operand\" \"i\")]\n+ \"TARGET_NEON\"\n+ {\n+   rtx tmpreg = gen_reg_rtx (<V_widen>mode);\n+   emit_insn (gen_neon_vec_<US>shiftl_<mode> (tmpreg, operands[1], operands[2]));\n+   emit_insn (gen_neon_vget_high<V_widen_l> (operands[0], tmpreg));\n+\n+   DONE;\n+ }\n+)\n+\n+(define_expand \"vec_widen_<US>shiftl_lo_<mode>\"\n+  [(match_operand:<V_double_width> 0 \"register_operand\" \"\")\n+   (SE:<V_double_width> (match_operand:VDI 1 \"register_operand\" \"\"))\n+   (match_operand:SI 2 \"immediate_operand\" \"i\")]\n+ \"TARGET_NEON\"\n+ {\n+   rtx tmpreg = gen_reg_rtx (<V_widen>mode);\n+   emit_insn (gen_neon_vec_<US>shiftl_<mode> (tmpreg, operands[1], operands[2]));\n+   emit_insn (gen_neon_vget_low<V_widen_l> (operands[0], tmpreg));\n+\n+   DONE;\n+ }\n+)\n+\n ; FIXME: These instruction patterns can't be used safely in big-endian mode\n ; because the ordering of vector elements in Q registers is different from what\n ; the semantics of the instructions require."}, {"sha": "92eb004ae14cec5275c291112d9629158e3a798a", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -136,6 +136,11 @@\n \t    (match_operand 0 \"s_register_operand\"))\n        (match_operand 0 \"const_int_operand\")))\n \n+(define_predicate \"const_neon_scalar_shift_amount_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"((unsigned HOST_WIDE_INT) INTVAL (op)) <= GET_MODE_BITSIZE (mode)\n+\t&& ((unsigned HOST_WIDE_INT) INTVAL (op)) > 0\")))\n+\n (define_predicate \"arm_add_operand\"\n   (ior (match_operand 0 \"arm_rhs_operand\")\n        (match_operand 0 \"arm_neg_immediate_operand\")))"}, {"sha": "4a0bcfa1bf1d3d48e97764dc3bf2072bf5520248", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -4272,6 +4272,17 @@ are vectors with N signed/unsigned elements of size S@.  Multiply the high/low\n elements of the two vectors, and put the N/2 products of size 2*S in the\n output vector (operand 0).\n \n+@cindex @code{vec_widen_ushiftl_hi_@var{m}} instruction pattern\n+@cindex @code{vec_widen_ushiftl_lo_@var{m}} instruction pattern\n+@cindex @code{vec_widen_sshiftl_hi_@var{m}} instruction pattern\n+@cindex @code{vec_widen_sshiftl_lo_@var{m}} instruction pattern\n+@item @samp{vec_widen_ushiftl_hi_@var{m}}, @samp{vec_widen_ushiftl_lo_@var{m}}\n+@itemx @samp{vec_widen_sshiftl_hi_@var{m}}, @samp{vec_widen_sshiftl_lo_@var{m}}\n+Signed/Unsigned widening shift left.  The first input (operand 1) is a vector\n+with N signed/unsigned elements of size S@.  Operand 2 is a constant.  Shift\n+the high/low elements of operand 1, and put the N/2 results of size 2*S in the\n+output vector (operand 0).\n+\n @cindex @code{mulhisi3} instruction pattern\n @item @samp{mulhisi3}\n Multiply operands 1 and 2, which have mode @code{HImode}, and store"}, {"sha": "a4cfee005d04d8ae2ad2f2c79a3cd89dc5398be5", "filename": "gcc/expr.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -8732,6 +8732,19 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \treturn target;\n       }\n \n+    case VEC_WIDEN_LSHIFT_HI_EXPR:\n+    case VEC_WIDEN_LSHIFT_LO_EXPR:\n+      {\n+        tree oprnd0 = treeop0;\n+        tree oprnd1 = treeop1;\n+\n+        expand_operands (oprnd0, oprnd1, NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n+        target = expand_widen_pattern_expr (ops, op0, op1, NULL_RTX,\n+                                            target, unsignedp);\n+        gcc_assert (target);\n+        return target;\n+      }\n+\n     case VEC_PACK_TRUNC_EXPR:\n     case VEC_PACK_SAT_EXPR:\n     case VEC_PACK_FIX_TRUNC_EXPR:"}, {"sha": "4c64842ea2774a8cee14c3353eb8d20365ef699a", "filename": "gcc/genopinit.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -271,6 +271,10 @@ static const char * const optabs[] =\n   \"set_optab_handler (vec_widen_umult_lo_optab, $A, CODE_FOR_$(vec_widen_umult_lo_$a$))\",\n   \"set_optab_handler (vec_widen_smult_hi_optab, $A, CODE_FOR_$(vec_widen_smult_hi_$a$))\",\n   \"set_optab_handler (vec_widen_smult_lo_optab, $A, CODE_FOR_$(vec_widen_smult_lo_$a$))\",\n+  \"set_optab_handler (vec_widen_ushiftl_hi_optab, $A, CODE_FOR_$(vec_widen_ushiftl_hi_$a$))\",\n+  \"set_optab_handler (vec_widen_ushiftl_lo_optab, $A, CODE_FOR_$(vec_widen_ushiftl_lo_$a$))\",\n+  \"set_optab_handler (vec_widen_sshiftl_hi_optab, $A, CODE_FOR_$(vec_widen_sshiftl_hi_$a$))\",\n+  \"set_optab_handler (vec_widen_sshiftl_lo_optab, $A, CODE_FOR_$(vec_widen_sshiftl_lo_$a$))\",\n   \"set_optab_handler (vec_unpacks_hi_optab, $A, CODE_FOR_$(vec_unpacks_hi_$a$))\",\n   \"set_optab_handler (vec_unpacks_lo_optab, $A, CODE_FOR_$(vec_unpacks_lo_$a$))\",\n   \"set_optab_handler (vec_unpacku_hi_optab, $A, CODE_FOR_$(vec_unpacku_hi_$a$))\","}, {"sha": "981d5b094d9dbd714ad6cc8a545329570571c3c6", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -343,6 +343,8 @@ dump_binary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n     case VEC_EXTRACT_ODD_EXPR:\n     case VEC_INTERLEAVE_HIGH_EXPR:\n     case VEC_INTERLEAVE_LOW_EXPR:\n+    case VEC_WIDEN_LSHIFT_HI_EXPR:\n+    case VEC_WIDEN_LSHIFT_LO_EXPR:\n       for (p = tree_code_name [(int) code]; *p; p++)\n \tpp_character (buffer, TOUPPER (*p));\n       pp_string (buffer, \" <\");"}, {"sha": "558c0fa107f07bad5d79d247c83ce3a8d259d364", "filename": "gcc/optabs.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -479,6 +479,14 @@ optab_for_tree_code (enum tree_code code, const_tree type,\n       return TYPE_UNSIGNED (type) ?\n \tvec_widen_umult_lo_optab : vec_widen_smult_lo_optab;\n \n+    case VEC_WIDEN_LSHIFT_HI_EXPR:\n+      return TYPE_UNSIGNED (type) ?\n+        vec_widen_ushiftl_hi_optab : vec_widen_sshiftl_hi_optab;\n+\n+    case VEC_WIDEN_LSHIFT_LO_EXPR:\n+      return TYPE_UNSIGNED (type) ?\n+        vec_widen_ushiftl_lo_optab : vec_widen_sshiftl_lo_optab;\n+\n     case VEC_UNPACK_HI_EXPR:\n       return TYPE_UNSIGNED (type) ?\n \tvec_unpacku_hi_optab : vec_unpacks_hi_optab;\n@@ -6197,6 +6205,10 @@ init_optabs (void)\n   init_optab (vec_widen_umult_lo_optab, UNKNOWN);\n   init_optab (vec_widen_smult_hi_optab, UNKNOWN);\n   init_optab (vec_widen_smult_lo_optab, UNKNOWN);\n+  init_optab (vec_widen_ushiftl_hi_optab, UNKNOWN);\n+  init_optab (vec_widen_ushiftl_lo_optab, UNKNOWN);\n+  init_optab (vec_widen_sshiftl_hi_optab, UNKNOWN);\n+  init_optab (vec_widen_sshiftl_lo_optab, UNKNOWN);\n   init_optab (vec_unpacks_hi_optab, UNKNOWN);\n   init_optab (vec_unpacks_lo_optab, UNKNOWN);\n   init_optab (vec_unpacku_hi_optab, UNKNOWN);"}, {"sha": "86e0ec93bc17911cc879feb3d5610cf5dee7feb4", "filename": "gcc/optabs.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -351,6 +351,12 @@ enum optab_index\n   OTI_vec_widen_umult_lo,\n   OTI_vec_widen_smult_hi,\n   OTI_vec_widen_smult_lo,\n+  /* Widening shift left.\n+     The high/low part of the resulting vector is returned.  */\n+  OTI_vec_widen_ushiftl_hi,\n+  OTI_vec_widen_ushiftl_lo,\n+  OTI_vec_widen_sshiftl_hi,\n+  OTI_vec_widen_sshiftl_lo,\n   /* Extract and widen the high/low part of a vector of signed or\n      floating point elements.  */\n   OTI_vec_unpacks_hi,\n@@ -544,6 +550,10 @@ enum optab_index\n #define vec_widen_umult_lo_optab (&optab_table[OTI_vec_widen_umult_lo])\n #define vec_widen_smult_hi_optab (&optab_table[OTI_vec_widen_smult_hi])\n #define vec_widen_smult_lo_optab (&optab_table[OTI_vec_widen_smult_lo])\n+#define vec_widen_ushiftl_hi_optab (&optab_table[OTI_vec_widen_ushiftl_hi])\n+#define vec_widen_ushiftl_lo_optab (&optab_table[OTI_vec_widen_ushiftl_lo])\n+#define vec_widen_sshiftl_hi_optab (&optab_table[OTI_vec_widen_sshiftl_hi])\n+#define vec_widen_sshiftl_lo_optab (&optab_table[OTI_vec_widen_sshiftl_lo])\n #define vec_unpacks_hi_optab (&optab_table[OTI_vec_unpacks_hi])\n #define vec_unpacks_lo_optab (&optab_table[OTI_vec_unpacks_lo])\n #define vec_unpacku_hi_optab (&optab_table[OTI_vec_unpacku_hi])"}, {"sha": "cbebb55393c539f7715e36d4bd775cde25aee0bd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -1,3 +1,12 @@\n+2011-10-18  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* testsuite/lib/target-supports.exp\n+\t(check_effective_target_vect_widen_shift): New.\n+\t* gcc.dg/vect/vect-widen-shift-s16.c: New.\n+\t* gcc.dg/vect/vect-widen-shift-s8.c: New.\n+\t* gcc.dg/vect/vect-widen-shift-u16.c: New.\n+\t* gcc.dg/vect/vect-widen-shift-u8.c: New.\n+\n 2011-10-18  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.dg/torture/restrict-1.c: New testcase."}, {"sha": "efee60437077171f4c6a770eeac5475750189f5c", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-shift-s16.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-shift-s16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-shift-s16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-shift-s16.c?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -0,0 +1,107 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+#define C 16\n+\n+__attribute__ ((noinline)) void\n+foo (short *src, int *dst)\n+{\n+  int i;\n+  short b, b0, b1, b2, b3, *s = src;\n+  int *d = dst;\n+\n+  for (i = 0; i < N/4; i++)\n+    {\n+      b0 = *s++;\n+      b1 = *s++;\n+      b2 = *s++;\n+      b3 = *s++;\n+      *d = b0 << C;\n+      d++;\n+      *d = b1 << C;\n+      d++;\n+      *d = b2 << C;\n+      d++;\n+      *d = b3 << C;\n+      d++;\n+    }\n+\n+  s = src;\n+  d = dst;\n+  for (i = 0; i < N; i++)\n+    {\n+      b = *s++;\n+      if (*d != b << C)\n+        abort ();\n+      d++;\n+    }\n+\n+  s = src;\n+  d = dst;\n+  for (i = 0; i < N/4; i++)\n+    {\n+      b0 = *s++;\n+      b1 = *s++;\n+      b2 = *s++;\n+      b3 = *s++;\n+      *d = b0 << C;\n+      d++;\n+      *d = b1 << C;\n+      d++;\n+      *d = b2 << C;\n+      d++;\n+      *d = b3 << 6;\n+      d++;\n+    }\n+\n+  s = src;\n+  d = dst;\n+  for (i = 0; i < N/4; i++)\n+    {\n+      b = *s++;\n+      if (*d != b << C)\n+        abort ();\n+      d++;\n+      b = *s++;\n+      if (*d != b << C)\n+        abort ();\n+      d++;\n+      b = *s++;\n+      if (*d != b << C)\n+        abort ();\n+      d++;\n+      b = *s++;\n+      if (*d != b << 6)\n+        abort ();\n+      d++;\n+    }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  short in[N];\n+  int out[N];\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      in[i] = i;\n+      out[i] = 255;\n+      __asm__ volatile (\"\");\n+    }\n+\n+  foo (in, out);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_shift_pattern: detected\" 8 \"vect\" { target vect_widen_shift } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "e829a799568242a03d99be4b33efcefee342d3c5", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-shift-s8.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-shift-s8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-shift-s8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-shift-s8.c?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+#define C 12\n+\n+__attribute__ ((noinline)) void\n+foo (char *src, int *dst)\n+{\n+  int i;\n+  char b, *s = src;\n+  int *d = dst;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      b = *s++;\n+      *d = b << C;\n+      d++;\n+    }\n+\n+  s = src;\n+  d = dst;\n+  for (i = 0; i < N; i++)\n+    {\n+      b = *s++;\n+      if (*d != b << C)\n+        abort ();\n+      d++;\n+    }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  char in[N];\n+  int out[N];\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      in[i] = i;\n+      out[i] = 255;\n+      __asm__ volatile (\"\");\n+    }\n+\n+  foo (in, out);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_shift_pattern: detected\" 1 \"vect\" { target vect_widen_shift } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "75834d481cbff4da590865bf8697cd40151d8d39", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-shift-u16.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-shift-u16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-shift-u16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-shift-u16.c?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+#define C 7\n+\n+__attribute__ ((noinline)) void\n+foo (unsigned short *src, unsigned int *dst)\n+{\n+  int i;\n+  unsigned short b, *s = src;\n+  unsigned int *d = dst;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      b = *s++;\n+      *d = b << C;\n+      d++;\n+    }\n+\n+  s = src;\n+  d = dst;\n+  for (i = 0; i < N; i++)\n+    {\n+      b = *s++;\n+      if (*d != b << C)\n+        abort ();\n+      d++;\n+    }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  unsigned short in[N];\n+  unsigned int out[N];\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      in[i] = i;\n+      out[i] = 255;\n+      __asm__ volatile (\"\");\n+    }\n+\n+  foo (in, out);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_shift_pattern: detected\" 1 \"vect\" { target vect_widen_shift } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "b87a277c2f780a87e6c76973dbdb103fa418501d", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-shift-u8.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-shift-u8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-shift-u8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-shift-u8.c?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+#define C1 10\n+#define C2 5\n+\n+__attribute__ ((noinline)) void\n+foo (unsigned char *src, unsigned int *dst1, unsigned int *dst2)\n+{\n+  int i;\n+  unsigned char b, *s = src;\n+  unsigned int *d1 = dst1, *d2 = dst2;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      b = *s++;\n+      *d1 = b << C1;\n+      d1++;\n+      *d2 = b << C2;\n+      d2++;\n+    }\n+\n+  s = src;\n+  d1 = dst1;\n+  d2 = dst2;\n+  for (i = 0; i < N; i++)\n+    {\n+      b = *s++;\n+      if (*d1 != b << C1 || *d2 != b << C2)\n+        abort ();\n+      d1++;\n+      d2++;\n+    }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  unsigned char in[N];\n+  unsigned int out1[N];\n+  unsigned int out2[N];\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      in[i] = i;\n+      out1[i] = 255;\n+      out2[i] = 255;\n+      __asm__ volatile (\"\");\n+    }\n+\n+  foo (in, out1, out2);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_shift_pattern: detected\" 1 \"vect\" { target vect_widen_shift } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "c4077ffabb6c8a87f7589b5f61005471bd6d17e1", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -2906,6 +2906,26 @@ proc check_effective_target_vect_widen_mult_hi_to_si_pattern { } {\n     return $et_vect_widen_mult_hi_to_si_pattern_saved\n }\n \n+# Return 1 if the target plus current options supports a vector\n+# widening shift, 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+proc check_effective_target_vect_widen_shift { } {\n+    global et_vect_widen_shift_saved\n+\n+    if [info exists et_vect_shift_saved] {\n+        verbose \"check_effective_target_vect_widen_shift: using cached result\" 2\n+    } else {\n+        set et_vect_widen_shift_saved 0\n+        if { ([istarget arm*-*-*] && [check_effective_target_arm_neon_ok]) } {\n+            set et_vect_widen_shift_saved 1\n+        }\n+    }\n+    verbose \"check_effective_target_vect_widen_shift: returning $et_vect_widen_shift_saved\" 2\n+    return $et_vect_widen_shift_saved\n+}\n+\n # Return 1 if the target plus current options supports a vector\n # dot-product of signed chars, 0 otherwise.\n #"}, {"sha": "a8409db59822fafa29dc15cc8483a5acecfa0b34", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -3510,6 +3510,44 @@ verify_gimple_assign_binary (gimple stmt)\n \treturn false;\n       }\n \n+    case WIDEN_LSHIFT_EXPR:\n+      {\n+        if (!INTEGRAL_TYPE_P (lhs_type)\n+            || !INTEGRAL_TYPE_P (rhs1_type)\n+            || TREE_CODE (rhs2) != INTEGER_CST\n+            || (2 * TYPE_PRECISION (rhs1_type) > TYPE_PRECISION (lhs_type)))\n+          {\n+            error (\"type mismatch in widening vector shift expression\");\n+            debug_generic_expr (lhs_type);\n+            debug_generic_expr (rhs1_type);\n+            debug_generic_expr (rhs2_type);\n+            return true;\n+          }\n+\n+        return false;\n+      }\n+\n+    case VEC_WIDEN_LSHIFT_HI_EXPR:\n+    case VEC_WIDEN_LSHIFT_LO_EXPR:\n+      {\n+        if (TREE_CODE (rhs1_type) != VECTOR_TYPE\n+            || TREE_CODE (lhs_type) != VECTOR_TYPE\n+            || !INTEGRAL_TYPE_P (TREE_TYPE (rhs1_type))\n+            || !INTEGRAL_TYPE_P (TREE_TYPE (lhs_type))\n+            || TREE_CODE (rhs2) != INTEGER_CST\n+            || (2 * TYPE_PRECISION (TREE_TYPE (rhs1_type))\n+                > TYPE_PRECISION (TREE_TYPE (lhs_type))))\n+          {\n+            error (\"type mismatch in widening vector shift expression\");\n+            debug_generic_expr (lhs_type);\n+            debug_generic_expr (rhs1_type);\n+            debug_generic_expr (rhs2_type);\n+            return true;\n+          }\n+\n+        return false;\n+      }\n+\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n       {"}, {"sha": "11be8d0791f721fdfb7332bae44db440f2294bd2", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -3355,6 +3355,7 @@ estimate_operator_cost (enum tree_code code, eni_weights *weights,\n     case DOT_PROD_EXPR:\n     case WIDEN_MULT_PLUS_EXPR:\n     case WIDEN_MULT_MINUS_EXPR:\n+    case WIDEN_LSHIFT_EXPR:\n \n     case VEC_WIDEN_MULT_HI_EXPR:\n     case VEC_WIDEN_MULT_LO_EXPR:\n@@ -3369,6 +3370,8 @@ estimate_operator_cost (enum tree_code code, eni_weights *weights,\n     case VEC_EXTRACT_ODD_EXPR:\n     case VEC_INTERLEAVE_HIGH_EXPR:\n     case VEC_INTERLEAVE_LOW_EXPR:\n+    case VEC_WIDEN_LSHIFT_HI_EXPR:\n+    case VEC_WIDEN_LSHIFT_LO_EXPR:\n \n       return 1;\n "}, {"sha": "24d70c3ff38c0055ead9d5f4d6bdf2a76f020043", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -1599,6 +1599,7 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n     case RROTATE_EXPR:\n     case VEC_LSHIFT_EXPR:\n     case VEC_RSHIFT_EXPR:\n+    case WIDEN_LSHIFT_EXPR:\n     case BIT_IOR_EXPR:\n     case BIT_XOR_EXPR:\n     case BIT_AND_EXPR:\n@@ -2297,6 +2298,22 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       pp_string (buffer, \" > \");\n       break;\n \n+    case VEC_WIDEN_LSHIFT_HI_EXPR:\n+      pp_string (buffer, \" VEC_WIDEN_LSHIFT_HI_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n+\n+    case VEC_WIDEN_LSHIFT_LO_EXPR:\n+      pp_string (buffer, \" VEC_WIDEN_LSHIFT_HI_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n+\n     case VEC_UNPACK_HI_EXPR:\n       pp_string (buffer, \" VEC_UNPACK_HI_EXPR < \");\n       dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n@@ -2619,6 +2636,9 @@ op_code_prio (enum tree_code code)\n     case RSHIFT_EXPR:\n     case LROTATE_EXPR:\n     case RROTATE_EXPR:\n+    case VEC_WIDEN_LSHIFT_HI_EXPR:\n+    case VEC_WIDEN_LSHIFT_LO_EXPR:\n+    case WIDEN_LSHIFT_EXPR:\n       return 11;\n \n     case WIDEN_SUM_EXPR:\n@@ -2794,6 +2814,9 @@ op_symbol_code (enum tree_code code)\n     case VEC_RSHIFT_EXPR:\n       return \"v>>\";\n \n+    case WIDEN_LSHIFT_EXPR:\n+      return \"w<<\";\n+\n     case POINTER_PLUS_EXPR:\n       return \"+\";\n "}, {"sha": "37ff807b1b5125892f1ccf832a3de1c0b76d7c76", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -823,7 +823,9 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n       || code == VEC_UNPACK_LO_EXPR\n       || code == VEC_PACK_TRUNC_EXPR\n       || code == VEC_PACK_SAT_EXPR\n-      || code == VEC_PACK_FIX_TRUNC_EXPR)\n+      || code == VEC_PACK_FIX_TRUNC_EXPR\n+      || code == VEC_WIDEN_LSHIFT_HI_EXPR\n+      || code == VEC_WIDEN_LSHIFT_LO_EXPR)\n     type = TREE_TYPE (rhs1);\n \n   /* Optabs will try converting a negation into a subtraction, so"}, {"sha": "94ab9b79667abfe869049cf27e5e479c6b39fd1f", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 262, "deletions": 39, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -49,6 +49,8 @@ static gimple vect_recog_dot_prod_pattern (VEC (gimple, heap) **, tree *,\n static gimple vect_recog_pow_pattern (VEC (gimple, heap) **, tree *, tree *);\n static gimple vect_recog_over_widening_pattern (VEC (gimple, heap) **, tree *,\n                                                  tree *);\n+static gimple vect_recog_widen_shift_pattern (VEC (gimple, heap) **,\n+\t                                tree *, tree *);\n static gimple vect_recog_mixed_size_cond_pattern (VEC (gimple, heap) **,\n \t\t\t\t\t\t  tree *, tree *);\n static gimple vect_recog_bool_pattern (VEC (gimple, heap) **, tree *, tree *);\n@@ -58,10 +60,10 @@ static vect_recog_func_ptr vect_vect_recog_func_ptrs[NUM_PATTERNS] = {\n \tvect_recog_dot_prod_pattern,\n \tvect_recog_pow_pattern,\n \tvect_recog_over_widening_pattern,\n+\tvect_recog_widen_shift_pattern,\n \tvect_recog_mixed_size_cond_pattern,\n \tvect_recog_bool_pattern};\n \n-\n /* Function widened_name_p\n \n    Check whether NAME, an ssa-name used in USE_STMT,\n@@ -340,27 +342,37 @@ vect_recog_dot_prod_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n }\n \n \n-/* Handle two cases of multiplication by a constant.  The first one is when\n-   the constant, CONST_OPRND, fits the type (HALF_TYPE) of the second\n-   operand (OPRND).  In that case, we can peform widen-mult from HALF_TYPE to\n-   TYPE.\n+/* Handle widening operation by a constant.  At the moment we support MULT_EXPR\n+   and LSHIFT_EXPR.\n+\n+   For MULT_EXPR we check that CONST_OPRND fits HALF_TYPE, and for LSHIFT_EXPR\n+   we check that CONST_OPRND is less or equal to the size of HALF_TYPE.\n \n    Otherwise, if the type of the result (TYPE) is at least 4 times bigger than\n-   HALF_TYPE, and CONST_OPRND fits an intermediate type (2 times smaller than\n-   TYPE), we can perform widen-mult from the intermediate type to TYPE and\n-   replace a_T = (TYPE) a_t; with a_it - (interm_type) a_t;  */\n+   HALF_TYPE, and there is an intermediate type (2 times smaller than TYPE)\n+   that satisfies the above restrictions,  we can perform a widening opeartion\n+   from the intermediate type to TYPE and replace a_T = (TYPE) a_t;\n+   with a_it = (interm_type) a_t;  */\n \n static bool\n-vect_handle_widen_mult_by_const (gimple stmt, tree const_oprnd, tree *oprnd,\n-   \t\t\t         VEC (gimple, heap) **stmts, tree type,\n-\t\t\t         tree *half_type, gimple def_stmt)\n+vect_handle_widen_op_by_const (gimple stmt, enum tree_code code,\n+\t\t               tree const_oprnd, tree *oprnd,\n+   \t\t               VEC (gimple, heap) **stmts, tree type,\n+\t\t\t       tree *half_type, gimple def_stmt)\n {\n   tree new_type, new_oprnd, tmp;\n   gimple new_stmt;\n   loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (vinfo_for_stmt (stmt));\n   struct loop *loop = LOOP_VINFO_LOOP (loop_info);\n \n-  if (int_fits_type_p (const_oprnd, *half_type))\n+  if (code != MULT_EXPR && code != LSHIFT_EXPR)\n+    return false;\n+\n+  if (((code == MULT_EXPR && int_fits_type_p (const_oprnd, *half_type))\n+        || (code == LSHIFT_EXPR\n+            && compare_tree_int (const_oprnd, TYPE_PRECISION (*half_type))\n+\t    \t!= 1))\n+      && TYPE_PRECISION (type) == (TYPE_PRECISION (*half_type) * 2))\n     {\n       /* CONST_OPRND is a constant of HALF_TYPE.  */\n       *oprnd = gimple_assign_rhs1 (def_stmt);\n@@ -373,14 +385,16 @@ vect_handle_widen_mult_by_const (gimple stmt, tree const_oprnd, tree *oprnd,\n       || !vinfo_for_stmt (def_stmt))\n     return false;\n \n-  /* TYPE is 4 times bigger than HALF_TYPE, try widen-mult for\n+  /* TYPE is 4 times bigger than HALF_TYPE, try widening operation for\n      a type 2 times bigger than HALF_TYPE.  */\n   new_type = build_nonstandard_integer_type (TYPE_PRECISION (type) / 2,\n                                              TYPE_UNSIGNED (type));\n-  if (!int_fits_type_p (const_oprnd, new_type))\n+  if ((code == MULT_EXPR && !int_fits_type_p (const_oprnd, new_type))\n+      || (code == LSHIFT_EXPR\n+          && compare_tree_int (const_oprnd, TYPE_PRECISION (new_type)) == 1))\n     return false;\n \n-  /* Use NEW_TYPE for widen_mult.  */\n+  /* Use NEW_TYPE for widening operation.  */\n   if (STMT_VINFO_RELATED_STMT (vinfo_for_stmt (def_stmt)))\n     {\n       new_stmt = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (def_stmt));\n@@ -500,7 +514,7 @@ vect_recog_widen_mult_pattern (VEC (gimple, heap) **stmts,\n   enum tree_code dummy_code;\n   int dummy_int;\n   VEC (tree, heap) *dummy_vec;\n-  bool op0_ok, op1_ok;\n+  bool op1_ok;\n \n   if (!is_gimple_assign (last_stmt))\n     return NULL;\n@@ -520,38 +534,23 @@ vect_recog_widen_mult_pattern (VEC (gimple, heap) **stmts,\n     return NULL;\n \n   /* Check argument 0.  */\n-  op0_ok = widened_name_p (oprnd0, last_stmt, &half_type0, &def_stmt0, false);\n+  if (!widened_name_p (oprnd0, last_stmt, &half_type0, &def_stmt0, false))\n+    return NULL;\n   /* Check argument 1.  */\n   op1_ok = widened_name_p (oprnd1, last_stmt, &half_type1, &def_stmt1, false);\n \n-  /* In case of multiplication by a constant one of the operands may not match\n-     the pattern, but not both.  */\n-  if (!op0_ok && !op1_ok)\n-    return NULL;\n-\n-  if (op0_ok && op1_ok)\n+  if (op1_ok)\n     {\n       oprnd0 = gimple_assign_rhs1 (def_stmt0);\n       oprnd1 = gimple_assign_rhs1 (def_stmt1);\n     }\t       \n-  else if (!op0_ok)\n-    {\n-      if (TREE_CODE (oprnd0) == INTEGER_CST\n-\t  && TREE_CODE (half_type1) == INTEGER_TYPE\n-          && vect_handle_widen_mult_by_const (last_stmt, oprnd0, &oprnd1,\n-                                              stmts, type,\n-\t\t\t\t \t      &half_type1, def_stmt1))\n-        half_type0 = half_type1;\n-      else\n-\treturn NULL;\n-    }\n-  else if (!op1_ok)\n+  else\n     {\n       if (TREE_CODE (oprnd1) == INTEGER_CST\n           && TREE_CODE (half_type0) == INTEGER_TYPE\n-          && vect_handle_widen_mult_by_const (last_stmt, oprnd1, &oprnd0,\n-                                              stmts, type,\n-\t\t\t\t\t      &half_type0, def_stmt0))\n+          && vect_handle_widen_op_by_const (last_stmt, MULT_EXPR, oprnd1,\n+\t\t                            &oprnd0, stmts, type,\n+\t\t\t\t\t    &half_type0, def_stmt0))\n         half_type1 = half_type0;\n       else\n         return NULL;\n@@ -1130,7 +1129,7 @@ vect_recog_over_widening_pattern (VEC (gimple, heap) **stmts,\n          statetments, except for the case when the last statement in the\n          sequence doesn't have a corresponding pattern statement.  In such\n          case we associate the last pattern statement with the last statement\n-         in the sequence.  Therefore, we only add an original statetement to\n+         in the sequence.  Therefore, we only add the original statement to\n          the list if we know that it is not the last.  */\n       if (prev_stmt)\n         VEC_safe_push (gimple, heap, *stmts, prev_stmt);\n@@ -1215,6 +1214,230 @@ vect_recog_over_widening_pattern (VEC (gimple, heap) **stmts,\n   return pattern_stmt;\n }\n \n+/* Detect widening shift pattern:\n+\n+   type a_t;\n+   TYPE a_T, res_T;\n+\n+   S1 a_t = ;\n+   S2 a_T = (TYPE) a_t;\n+   S3 res_T = a_T << CONST;\n+\n+  where type 'TYPE' is at least double the size of type 'type'.\n+\n+  Also detect unsgigned cases:\n+\n+  unsigned type a_t;\n+  unsigned TYPE u_res_T;\n+  TYPE a_T, res_T;\n+\n+  S1 a_t = ;\n+  S2 a_T = (TYPE) a_t;\n+  S3 res_T = a_T << CONST;\n+  S4 u_res_T = (unsigned TYPE) res_T;\n+\n+  And a case when 'TYPE' is 4 times bigger than 'type'.  In that case we\n+  create an additional pattern stmt for S2 to create a variable of an\n+  intermediate type, and perform widen-shift on the intermediate type:\n+\n+  type a_t;\n+  interm_type a_it;\n+  TYPE a_T, res_T, res_T';\n+\n+  S1 a_t = ;\n+  S2 a_T = (TYPE) a_t;\n+      '--> a_it = (interm_type) a_t;\n+  S3 res_T = a_T << CONST;\n+      '--> res_T' = a_it <<* CONST;\n+\n+  Input/Output:\n+\n+  * STMTS: Contains a stmt from which the pattern search begins.\n+    In case of unsigned widen-shift, the original stmt (S3) is replaced with S4\n+    in STMTS.  When an intermediate type is used and a pattern statement is\n+    created for S2, we also put S2 here (before S3).\n+\n+  Output:\n+\n+  * TYPE_IN: The type of the input arguments to the pattern.\n+\n+  * TYPE_OUT: The type of the output of this pattern.\n+\n+  * Return value: A new stmt that will be used to replace the sequence of\n+    stmts that constitute the pattern.  In this case it will be:\n+    WIDEN_LSHIFT_EXPR <a_t, CONST>.  */\n+\n+static gimple\n+vect_recog_widen_shift_pattern (VEC (gimple, heap) **stmts,\n+\t\t\t\ttree *type_in, tree *type_out)\n+{\n+  gimple last_stmt = VEC_pop (gimple, *stmts);\n+  gimple def_stmt0;\n+  tree oprnd0, oprnd1;\n+  tree type, half_type0;\n+  gimple pattern_stmt, orig_stmt = NULL;\n+  tree vectype, vectype_out = NULL_TREE;\n+  tree dummy;\n+  tree var;\n+  enum tree_code dummy_code;\n+  int dummy_int;\n+  VEC (tree, heap) * dummy_vec;\n+  gimple use_stmt = NULL;\n+  bool over_widen = false;\n+\n+  if (!is_gimple_assign (last_stmt) || !vinfo_for_stmt (last_stmt))\n+    return NULL;\n+\n+  orig_stmt = last_stmt;\n+  if (STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (last_stmt)))\n+    {\n+      /* This statement was also detected as over-widening operation (it can't\n+         be any other pattern, because only over-widening detects shifts).\n+         LAST_STMT is the final type demotion statement, but its related\n+         statement is shift.  We analyze the related statement to catch cases:\n+\n+         orig code:\n+          type a_t;\n+          itype res;\n+          TYPE a_T, res_T;\n+\n+          S1 a_T = (TYPE) a_t;\n+          S2 res_T = a_T << CONST;\n+          S3 res = (itype)res_T;\n+\n+          (size of type * 2 <= size of itype\n+           and size of itype * 2 <= size of TYPE)\n+\n+         code after over-widening pattern detection:\n+\n+          S1 a_T = (TYPE) a_t;\n+               --> a_it = (itype) a_t;\n+          S2 res_T = a_T << CONST;\n+          S3 res = (itype)res_T;  <--- LAST_STMT\n+               --> res = a_it << CONST;\n+\n+         after widen_shift:\n+\n+          S1 a_T = (TYPE) a_t;\n+               --> a_it = (itype) a_t; - redundant\n+          S2 res_T = a_T << CONST;\n+          S3 res = (itype)res_T;\n+               --> res = a_t w<< CONST;\n+\n+      i.e., we replace the three statements with res = a_t w<< CONST.  */\n+      last_stmt = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (last_stmt));\n+      over_widen = true;\n+    }\n+\n+  if (gimple_assign_rhs_code (last_stmt) != LSHIFT_EXPR)\n+    return NULL;\n+\n+  oprnd0 = gimple_assign_rhs1 (last_stmt);\n+  oprnd1 = gimple_assign_rhs2 (last_stmt);\n+  if (TREE_CODE (oprnd0) != SSA_NAME || TREE_CODE (oprnd1) != INTEGER_CST)\n+    return NULL;\n+\n+  /* Check operand 0: it has to be defined by a type promotion.  */\n+  if (!widened_name_p (oprnd0, last_stmt, &half_type0, &def_stmt0, false))\n+    return NULL;\n+\n+  /* Check operand 1: has to be positive.  We check that it fits the type\n+     in vect_handle_widen_op_by_const ().  */\n+  if (tree_int_cst_compare (oprnd1, size_zero_node) <= 0)\n+    return NULL;\n+\n+  oprnd0 = gimple_assign_rhs1 (def_stmt0);\n+  type = gimple_expr_type (last_stmt);\n+\n+  /* Check if this a widening operation.  */\n+  if (!vect_handle_widen_op_by_const (last_stmt, LSHIFT_EXPR, oprnd1,\n+       \t\t\t\t      &oprnd0, stmts,\n+\t                              type, &half_type0, def_stmt0))\n+    return NULL;\n+\n+  /* Handle unsigned case.  Look for\n+     S4  u_res_T = (unsigned TYPE) res_T;\n+     Use unsigned TYPE as the type for WIDEN_LSHIFT_EXPR.  */\n+  if (TYPE_UNSIGNED (type) != TYPE_UNSIGNED (half_type0))\n+    {\n+      tree lhs = gimple_assign_lhs (last_stmt), use_lhs;\n+      imm_use_iterator imm_iter;\n+      use_operand_p use_p;\n+      int nuses = 0;\n+      tree use_type;\n+\n+      if (over_widen)\n+        {\n+          /* In case of over-widening pattern, S4 should be ORIG_STMT itself.\n+             We check here that TYPE is the correct type for the operation,\n+             i.e., it's the type of the original result.  */\n+          tree orig_type = gimple_expr_type (orig_stmt);\n+          if ((TYPE_UNSIGNED (type) != TYPE_UNSIGNED (orig_type))\n+              || (TYPE_PRECISION (type) != TYPE_PRECISION (orig_type)))\n+            return NULL;\n+        }\n+      else\n+        {\n+          FOR_EACH_IMM_USE_FAST (use_p, imm_iter, lhs)\n+            {\n+\t      if (is_gimple_debug (USE_STMT (use_p)))\n+\t        continue;\n+      \t      use_stmt = USE_STMT (use_p);\n+ \t      nuses++;\n+            }\n+\n+          if (nuses != 1 || !is_gimple_assign (use_stmt)\n+\t      || !CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (use_stmt)))\n+\t    return NULL;\n+\n+          use_lhs = gimple_assign_lhs (use_stmt);\n+          use_type = TREE_TYPE (use_lhs);\n+\n+          if (!INTEGRAL_TYPE_P (use_type)\n+              || (TYPE_UNSIGNED (type) == TYPE_UNSIGNED (use_type))\n+              || (TYPE_PRECISION (type) != TYPE_PRECISION (use_type)))\n+            return NULL;\n+\n+          type = use_type;\n+        }\n+    }\n+\n+  /* Pattern detected.  */\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"vect_recog_widen_shift_pattern: detected: \");\n+\n+  /* Check target support.  */\n+  vectype = get_vectype_for_scalar_type (half_type0);\n+  vectype_out = get_vectype_for_scalar_type (type);\n+\n+  if (!vectype\n+      || !vectype_out\n+      || !supportable_widening_operation (WIDEN_LSHIFT_EXPR, last_stmt,\n+\t\t\t\t\t  vectype_out, vectype,\n+\t\t\t\t\t  &dummy, &dummy, &dummy_code,\n+\t\t\t\t\t  &dummy_code, &dummy_int,\n+\t\t\t\t\t  &dummy_vec))\n+    return NULL;\n+\n+  *type_in = vectype;\n+  *type_out = vectype_out;\n+\n+  /* Pattern supported.  Create a stmt to be used to replace the pattern.  */\n+  var = vect_recog_temp_ssa_var (type, NULL);\n+  pattern_stmt =\n+    gimple_build_assign_with_ops (WIDEN_LSHIFT_EXPR, var, oprnd0, oprnd1);\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    print_gimple_stmt (vect_dump, pattern_stmt, 0, TDF_SLIM);\n+\n+  if (use_stmt)\n+    last_stmt = use_stmt;\n+  else\n+    last_stmt = orig_stmt;\n+\n+  VEC_safe_push (gimple, heap, *stmts, last_stmt);\n+  return pattern_stmt;\n+}\n \n /* Function vect_recog_mixed_size_cond_pattern\n "}, {"sha": "f131f1eec238109a4e272cf11c01c450a2f4901d", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -489,6 +489,11 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t    }\n \t\t}\n \t    }\n+\t  else if (rhs_code == WIDEN_LSHIFT_EXPR)\n+            {\n+              need_same_oprnds = true;\n+              first_op1 = gimple_assign_rhs2 (stmt);\n+            }\n \t}\n       else\n \t{"}, {"sha": "b8f6336d2b3d72873005b1718c7f96318aed627e", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 46, "deletions": 8, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -3333,6 +3333,7 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n   VEC (tree, heap) *vec_oprnds0 = NULL, *vec_oprnds1 = NULL;\n   VEC (tree, heap) *vec_dsts = NULL, *interm_types = NULL, *tmp_vec_dsts = NULL;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n+  unsigned int k;\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n     return false;\n@@ -3349,7 +3350,8 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n \n   code = gimple_assign_rhs_code (stmt);\n   if (!CONVERT_EXPR_CODE_P (code)\n-      && code != WIDEN_MULT_EXPR)\n+      && code != WIDEN_MULT_EXPR\n+      && code != WIDEN_LSHIFT_EXPR)\n     return false;\n \n   scalar_dest = gimple_assign_lhs (stmt);\n@@ -3377,7 +3379,7 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n       bool ok;\n \n       op1 = gimple_assign_rhs2 (stmt);\n-      if (code == WIDEN_MULT_EXPR)\n+      if (code == WIDEN_MULT_EXPR || code == WIDEN_LSHIFT_EXPR)\n         {\n \t  /* For WIDEN_MULT_EXPR, if OP0 is a constant, use the type of\n \t     OP1.  */\n@@ -3454,7 +3456,7 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n     fprintf (vect_dump, \"transform type promotion operation. ncopies = %d.\",\n                         ncopies);\n \n-  if (code == WIDEN_MULT_EXPR)\n+  if (code == WIDEN_MULT_EXPR || code == WIDEN_LSHIFT_EXPR)\n     {\n       if (CONSTANT_CLASS_P (op0))\n \top0 = fold_convert (TREE_TYPE (op1), op0);\n@@ -3495,6 +3497,8 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n       if (op_type == binary_op)\n         vec_oprnds1 = VEC_alloc (tree, heap, 1);\n     }\n+  else if (code == WIDEN_LSHIFT_EXPR)\n+    vec_oprnds1 = VEC_alloc (tree, heap, slp_node->vec_stmts_size);\n \n   /* In case the vectorization factor (VF) is bigger than the number\n      of elements that we can fit in a vectype (nunits), we have to generate\n@@ -3508,15 +3512,33 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n       if (j == 0)\n         {\n           if (slp_node)\n-              vect_get_slp_defs (op0, op1, slp_node, &vec_oprnds0,\n-                                 &vec_oprnds1, -1);\n-          else\n+\t    {\n+\t      if (code == WIDEN_LSHIFT_EXPR)\n+                {\n+                  vec_oprnd1 = op1;\n+\t\t  /* Store vec_oprnd1 for every vector stmt to be created\n+\t\t     for SLP_NODE.  We check during the analysis that all\n+\t\t     the shift arguments are the same.  */\n+                  for (k = 0; k < slp_node->vec_stmts_size - 1; k++)\n+                    VEC_quick_push (tree, vec_oprnds1, vec_oprnd1);\n+\n+    \t\t  vect_get_slp_defs (op0, NULL_TREE, slp_node, &vec_oprnds0, NULL,\n+ \t                             -1);\n+                }\n+              else\n+                vect_get_slp_defs (op0, op1, slp_node, &vec_oprnds0,\n+                                   &vec_oprnds1, -1);\n+\t    }\n+\t  else\n             {\n               vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n               VEC_quick_push (tree, vec_oprnds0, vec_oprnd0);\n               if (op_type == binary_op)\n                 {\n-                  vec_oprnd1 = vect_get_vec_def_for_operand (op1, stmt, NULL);\n+                  if (code == WIDEN_LSHIFT_EXPR)\n+                    vec_oprnd1 = op1;\n+                  else\n+                    vec_oprnd1 = vect_get_vec_def_for_operand (op1, stmt, NULL);\n                   VEC_quick_push (tree, vec_oprnds1, vec_oprnd1);\n                 }\n             }\n@@ -3527,7 +3549,10 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n           VEC_replace (tree, vec_oprnds0, 0, vec_oprnd0);\n           if (op_type == binary_op)\n             {\n-              vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt[1], vec_oprnd1);\n+              if (code == WIDEN_LSHIFT_EXPR)\n+                vec_oprnd1 = op1;\n+              else\n+                vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt[1], vec_oprnd1);\n               VEC_replace (tree, vec_oprnds1, 0, vec_oprnd1);\n             }\n         }\n@@ -5789,6 +5814,19 @@ supportable_widening_operation (enum tree_code code, gimple stmt,\n         }\n       break;\n \n+    case WIDEN_LSHIFT_EXPR:\n+      if (BYTES_BIG_ENDIAN)\n+        {\n+          c1 = VEC_WIDEN_LSHIFT_HI_EXPR;\n+          c2 = VEC_WIDEN_LSHIFT_LO_EXPR;\n+        }\n+      else\n+        {\n+          c2 = VEC_WIDEN_LSHIFT_HI_EXPR;\n+          c1 = VEC_WIDEN_LSHIFT_LO_EXPR;\n+        }\n+      break;\n+\n     CASE_CONVERT:\n       if (BYTES_BIG_ENDIAN)\n         {"}, {"sha": "c27e76ca7accd4ffadb7da4b82950041f5a62d1a", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -902,7 +902,7 @@ extern void vect_slp_transform_bb (basic_block);\n    Additional pattern recognition functions can (and will) be added\n    in the future.  */\n typedef gimple (* vect_recog_func_ptr) (VEC (gimple, heap) **, tree *, tree *);\n-#define NUM_PATTERNS 7\n+#define NUM_PATTERNS 8\n void vect_pattern_recog (loop_vec_info);\n \n /* In tree-vectorizer.c.  */"}, {"sha": "1472cb15fb89c33dae626fe3d3c3b4eb1d313b49", "filename": "gcc/tree.def", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ba4aaedc8507aa7f66add20d92b65df3b8faff/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=36ba4aaedc8507aa7f66add20d92b65df3b8faff", "patch": "@@ -1125,6 +1125,19 @@ DEFTREECODE (WIDEN_MULT_PLUS_EXPR, \"widen_mult_plus_expr\", tcc_expression, 3)\n    is subtracted from t3.  */\n DEFTREECODE (WIDEN_MULT_MINUS_EXPR, \"widen_mult_minus_expr\", tcc_expression, 3)\n \n+/* Widening shift left.\n+   The first operand is of type t1.\n+   The second operand is the number of bits to shift by; it need not be the\n+   same type as the first operand and result.\n+   Note that the result is undefined if the second operand is larger\n+   than or equal to the first operand's type size.\n+   The type of the entire expression is t2, such that t2 is at least twice\n+   the size of t1.\n+   WIDEN_LSHIFT_EXPR is equivalent to first widening (promoting)\n+   the first argument from type t1 to type t2, and then shifting it\n+   by the second argument.  */\n+DEFTREECODE (WIDEN_LSHIFT_EXPR, \"widen_lshift_expr\", tcc_binary, 2)\n+\n /* Fused multiply-add.\n    All operands and the result are of the same type.  No intermediate\n    rounding is performed after multiplying operand one with operand two\n@@ -1180,6 +1193,16 @@ DEFTREECODE (VEC_EXTRACT_ODD_EXPR, \"vec_extractodd_expr\", tcc_binary, 2)\n DEFTREECODE (VEC_INTERLEAVE_HIGH_EXPR, \"vec_interleavehigh_expr\", tcc_binary, 2)\n DEFTREECODE (VEC_INTERLEAVE_LOW_EXPR, \"vec_interleavelow_expr\", tcc_binary, 2)\n \n+/* Widening vector shift left in bits.\n+   Operand 0 is a vector to be shifted with N elements of size S.\n+   Operand 1 is an integer shift amount in bits.\n+   The result of the operation is N elements of size 2*S.\n+   VEC_WIDEN_LSHIFT_HI_EXPR computes the N/2 high results.\n+   VEC_WIDEN_LSHIFT_LO_EXPR computes the N/2 low results.\n+ */\n+DEFTREECODE (VEC_WIDEN_LSHIFT_HI_EXPR, \"widen_lshift_hi_expr\", tcc_binary, 2)\n+DEFTREECODE (VEC_WIDEN_LSHIFT_LO_EXPR, \"widen_lshift_lo_expr\", tcc_binary, 2)\n+\n /* PREDICT_EXPR.  Specify hint for branch prediction.  The\n    PREDICT_EXPR_PREDICTOR specify predictor and PREDICT_EXPR_OUTCOME the\n    outcome (0 for not taken and 1 for taken).  Once the profile is guessed"}]}