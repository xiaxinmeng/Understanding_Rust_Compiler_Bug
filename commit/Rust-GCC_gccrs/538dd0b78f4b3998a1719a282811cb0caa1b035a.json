{"sha": "538dd0b78f4b3998a1719a282811cb0caa1b035a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM4ZGQwYjc4ZjRiMzk5OGExNzE5YTI4MjgxMWNiMGNhYTFiMDM1YQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-11-19T17:00:54Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-11-19T17:00:54Z"}, "message": "Merger of git branch \"gimple-classes-v2-option-3\"\n\ngcc/ChangeLog:\n\tMerger of git branch \"gimple-classes-v2-option-3\".\n\n\t* ChangeLog.gimple-classes: New.\n\n\t* coretypes.h (struct gcond): Add forward decl.\n\t(struct gdebug): Likewise.\n\t(struct ggoto): Likewise.\n\t(struct glabel): Likewise.\n\t(struct gswitch): Likewise.\n\t(struct gassign): Likewise.\n\t(struct gasm): Likewise.\n\t(struct gcall): Likewise.\n\t(struct gtransaction): Likewise.\n\t(struct greturn): Likewise.\n\t(struct gbind): Likewise.\n\t(struct gcatch): Likewise.\n\t(struct geh_filter): Likewise.\n\t(struct geh_mnt): Likewise.\n\t(struct geh_else): Likewise.\n\t(struct gresx): Likewise.\n\t(struct geh_dispatch): Likewise.\n\t(struct gphi): Likewise.\n\t(struct gtry): Likewise.\n\t(struct gomp_atomic_load): Likewise.\n\t(struct gomp_atomic_store): Likewise.\n\t(struct gomp_continue): Likewise.\n\t(struct gomp_critical): Likewise.\n\t(struct gomp_for): Likewise.\n\t(struct gomp_parallel): Likewise.\n\t(struct gomp_task): Likewise.\n\t(struct gomp_sections): Likewise.\n\t(struct gomp_single): Likewise.\n\t(struct gomp_target): Likewise.\n\t(struct gomp_teams): Likewise.\n\n\t* doc/gimple.texi (Class hierarchy of GIMPLE statements): Update\n\tfor renaming of gimple subclasses.\n\n\t* gdbhooks.py: Update.\n\n\t* gimple-iterator.c (gsi_for_phi): New.\n\t(gsi_start_phis): Strengthen return type from gimple_stmt_iterator\n\tto gphi_iterator.\n\t* gimple-iterator.h (struct gphi_iterator): New subclass of\n\tgimple_stmt_iterator.\n\t(gsi_for_phi): New prototype.\n\t(gsi_start_phis): Strengthen return type from gimple_stmt_iterator\n\tto gphi_iterator.\n\t(gsi_next_nonvirtual_phi): Strengthen param from\n\tgimple_stmt_iterator * to gphi_iterator *, and local \"phi\" from\n\tgimple to gphi *.\n\n\t* gsstruct.def: Update for renamings of classes.\n\n\t* gimple.c (gimple_build_return): Strengthen return type from\n\tgimple to greturn *.\n\t(gimple_call_reset_alias_info): Strengthen param to gcall *.\n\t(gimple_build_call_1): Strengthen return type from gimple to\n\tgcall *.\n\t(gimple_build_call_vec): Likewise.\n\t(gimple_build_call): Likewise.\n\t(gimple_build_call_valist): Likewise.\n\t(gimple_build_call_internal_1): Likewise.\n\t(gimple_build_call_internal): Likewise.\n\t(gimple_build_call_internal_vec): Likewise.\n\t(gimple_build_call_from_tree): Likewise.\n\t(gimple_build_assign_stat): Strengthen return type from gimple to\n\tgassign *.\n\t(gimple_build_assign_with_ops): Likewise.\n\t(gimple_build_assign_with_ops): Likewise.\n\t(gimple_build_cond): Strengthen return type from gimple to\n\tgcond *.\n\t(gimple_build_cond_from_tree): Likewise.\n\t(gimple_cond_set_condition_from_tree): Require a gcond *.\n\t(gimple_build_label): Strengthen return type from gimple to\n\tglabel *.\n\t(gimple_build_goto): Strengthen return type from gimple to\n\tggoto *.\n\t(gimple_build_bind): Strengthen return type from gimple to\n\tgbind *.\n\t(gimple_build_asm_1): Strengthen return type from gimple to\n\tgasm *.\n\t(gimple_build_asm_vec): Likewise.\n\t(gimple_build_catch): Strengthen return type from gimple to\n\tgcatch *.\n\t(gimple_build_eh_filter): Strengthen return type from gimple to\n\tgeh_filter *.\n\t(gimple_build_eh_must_not_throw): Strengthen return type from\n\tgimple to geh_mnt *.\n\t(gimple_build_eh_else): Strengthen return type from gimple to\n\tgeh_else *.\n\t(gimple_build_try): Update for renaming of gimple_statement_try to\n\tgtry.\n\t(gimple_build_resx): Strengthen return type from gimple to\n\tgresx *.\n\t(gimple_build_switch_nlabels): Strengthen return type from gimple\n\tto gswitch *.\n\t(gimple_build_switch): Likewise.\n\t(gimple_build_eh_dispatch): Strengthen return type from gimple to\n\tgeh_dispatch *.\n\t(gimple_build_debug_bind_stat): Strengthen return type from gimple\n\tto gdebug *.\n\t(gimple_build_debug_source_bind_stat): Strengthen return type from\n\tgimple to gdebug *.\n\t(gimple_build_omp_critical): Strengthen return type from gimple to\n\tgomp_critical *.\n\t(gimple_build_omp_for): Strengthen return type from gimple to\n\tgomp_for *.\n\t(gimple_build_omp_parallel): Strengthen return type from gimple to\n\tgomp_parallel *.\n\t(gimple_build_omp_task): Strengthen return type from gimple to\n\tgomp_task *.\n\t(gimple_build_omp_continue): Strengthen return type from gimple to\n\tgomp_continue *.\n\t(gimple_build_omp_sections): Strengthen return type from gimple to\n\tgomp_sections *.\n\t(gimple_build_omp_single): Strengthen return type from gimple to\n\tgomp_single *.\n\t(gimple_build_omp_target): Strengthen return type from gimple to\n\tgomp_target *.\n\t(gimple_build_omp_teams): Strengthen return type from gimple to\n\tgomp_teams *.\n\t(gimple_build_omp_atomic_load): Strengthen return type from gimple\n\tto gomp_atomic_load *.\n\t(gimple_build_omp_atomic_store): Strengthen return type from gimple\n\tto gomp_atomic_store *.\n\t(gimple_build_transaction): Strengthen return type from gimple\n\tto gtransaction *.\n\t(empty_stmt_p): Replace check for GIMPLE_BIND with a dyn_cast.\n\t(gimple_call_fnspec): Require a const gcall *.\n\t(gimple_call_arg_flags): Likewise.\n\t(gimple_call_return_flags): Likewise.\n\t(gimple_set_bb): Add a checked cast.\n\t(gimple_copy): Within the cases, add locals of the appropriate\n\tsubclass and use in place of \"stmt\" and \"copy\" for typesafety.\n\t(gimple_has_side_effects): Add a checked cast.\n\t(gimple_could_trap_p_1): Likewise.\n\t(gimple_call_copy_skip_args): Require a gcall *, and return one.\n\t(gimple_asm_clobbers_memory_p): Require a const gasm *.\n\t(infer_nonnull_range): Replace a check for GIMPLE_RETURN with a\n\tdyn_cast, introducing local \"return_stmt\" and using ti in place\n\tof \"stmt\".\n\n\t* gimple.h (gimple_vec): Eliminate this typedef.\n\t(struct gimple_statement_call): Rename to...\n\t(struct gcall): ...this.\n\t(struct gimple_statement_bind): Rename to...\n\t(struct gbind): ...this.\n\t(struct gimple_statement_catch): Rename to...\n\t(struct gcatch): ...this.\n\t(struct gimple_statement_eh_filter): Rename to...\n\t(struct geh_filter): ...this.\n\t(struct gimple_statement_eh_else): Rename to...\n\t(struct geh_else): ...this.\n\t(struct gimple_statement_eh_mnt): Rename to...\n\t(struct geh_mnt): ...this.\n\t(struct gimple_statement_phi): Rename to...\n\t(struct gphi): ...this.\n\t(struct gimple_statement_resx): Rename to...\n\t(struct gresx): ...this.\n\t(struct gimple_statement_eh_dispatch): Rename to...\n\t(struct geh_dispatch): ...this.\n\t(struct gimple_statement_try): Rename to...\n\t(struct gtry): ...this.\n\t(struct gimple_statement_asm): Rename to...\n\t(struct gasm): ...this.\n\t(struct gimple_statement_omp_critical): Rename to...\n\t(struct gomp_critical): ...this.\n\t(struct gimple_statement_omp_for): Rename to...\n\t(struct gomp_for): ...this.\n\t(struct gimple_statement_omp_parallel): Rename to...\n\t(struct gomp_parallel): ...this.\n\t(struct gimple_statement_omp_target): Rename to...\n\t(struct gomp_target): ...this.\n\t(struct gimple_statement_omp_task): Rename to...\n\t(struct gomp_task): ...this.\n\t(struct gimple_statement_omp_sections): Rename to...\n\t(struct gomp_sections): ...this.\n\t(struct gimple_statement_omp_continue): Rename to...\n\t(struct gomp_continue): ...this.\n\t(struct gimple_statement_omp_single): Rename to...\n\t(struct gomp_single): ...this.\n\t(struct gimple_statement_omp_teams): Rename to...\n\t(struct gomp_teams): ...this.\n\t(struct gimple_statement_omp_atomic_load): Rename to...\n\t(struct gomp_atomic_load): ...this.\n\t(struct gimple_statement_omp_atomic_store :): Rename to...\n\t(struct gomp_atomic_store :): ...this.\n\t(struct gimple_statement_transaction): Rename to...\n\t(struct gtransaction): ...this.\n\t(struct gcond): New subclass.\n\t(struct gdebug): New subclass.\n\t(struct ggoto): New subclass.\n\t(struct glabel): New subclass.\n\t(struct gswitch): New subclass.\n\t(struct gassign): New subclass.\n\t(struct greturn): New subclass.\n\t(is_a_helper <gimple_statement_asm *>::test): Rename to...\n\t(is_a_helper <gasm *>::test): ...this.\n\t(is_a_helper <gimple_statement_bind *>::test): Rename to...\n\t(is_a_helper <gbind *>::test): ...this.\n\t(is_a_helper <gassign *>::test): New.\n\t(is_a_helper <gimple_statement_call *>::test): Rename to...\n\t(is_a_helper <gcall *>::test): ...this.\n\t(is_a_helper <gimple_statement_catch *>::test): Rename to...\n\t(is_a_helper <gcatch *>::test): ...this.\n\t(is_a_helper <gimple_statement_resx *>::test): Rename to...\n\t(is_a_helper <gresx *>::test): ...this.\n\t(is_a_helper <gcond *>::test): New.\n\t(is_a_helper <gdebug *>::test): New.\n\t(is_a_helper <ggoto *>::test): New.\n\t(is_a_helper <glabel *>::test): New.\n\t(is_a_helper <gimple_statement_eh_dispatch *>::test): Rename to...\n\t(is_a_helper <geh_dispatch *>::test): ...this.\n\t(is_a_helper <gimple_statement_eh_else *>::test): Rename to...\n\t(is_a_helper <geh_else *>::test): ...this.\n\t(is_a_helper <gimple_statement_eh_filter *>::test): Rename to...\n\t(is_a_helper <geh_filter *>::test): ...this.\n\t(is_a_helper <gimple_statement_eh_mnt *>::test): Rename to...\n\t(is_a_helper <geh_mnt *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_atomic_load *>::test): Rename to...\n\t(is_a_helper <gomp_atomic_load *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_atomic_store *>::test): Rename to...\n\t(is_a_helper <gomp_atomic_store *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_continue *>::test): Rename to...\n\t(is_a_helper <gomp_continue *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_critical *>::test): Rename to...\n\t(is_a_helper <gomp_critical *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_for *>::test): Rename to...\n\t(is_a_helper <gomp_for *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_parallel *>::test): Rename to...\n\t(is_a_helper <gomp_parallel *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_target *>::test): Rename to...\n\t(is_a_helper <gomp_target *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_sections *>::test): Rename to...\n\t(is_a_helper <gomp_sections *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_single *>::test): Rename to...\n\t(is_a_helper <gomp_single *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_teams *>::test): Rename to...\n\t(is_a_helper <gomp_teams *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_task *>::test): Rename to...\n\t(is_a_helper <gomp_task *>::test): ...this.\n\t(is_a_helper <gimple_statement_phi *>::test): Rename to...\n\t(is_a_helper <gphi *>::test): ...this.\n\t(is_a_helper <gimple_statement_transaction *>::test): Rename to...\n\t(is_a_helper <gtransaction *>::test): ...this.\n\t(is_a_helper <greturn *>::test): New.\n\t(is_a_helper <gswitch *>::test): New.\n\t(is_a_helper <gimple_statement_try *>::test): Rename to...\n\t(is_a_helper <gtry *>::test): ...this.\n\t(is_a_helper <const gimple_statement_asm *>::test): Rename to...\n\t(is_a_helper <const gasm *>::test): ...this.\n\t(is_a_helper <const gimple_statement_bind *>::test): Rename to...\n\t(is_a_helper <const gbind *>::test): ...this.\n\t(is_a_helper <const gimple_statement_call *>::test): Rename to...\n\t(is_a_helper <const gcall *>::test): ...this.\n\t(is_a_helper <const gimple_statement_catch *>::test): Rename to...\n\t(is_a_helper <const gcatch *>::test): ...this.\n\t(is_a_helper <const gimple_statement_resx *>::test): Rename to...\n\t(is_a_helper <const gresx *>::test): ...this.\n\t(is_a_helper <const gimple_statement_eh_dispatch *>::test): Rename to...\n\t(is_a_helper <const geh_dispatch *>::test): ...this.\n\t(is_a_helper <const gimple_statement_eh_filter *>::test): Rename to...\n\t(is_a_helper <const geh_filter *>::test): ...this.\n\t(is_a_helper <const gimple_statement_omp_atomic_load *>::test):\n\tRename to...\n\t(is_a_helper <const gomp_atomic_load *>::test): ...this.\n\t(is_a_helper <const gimple_statement_omp_atomic_store *>::test):\n\tRename to...\n\t(is_a_helper <const gomp_atomic_store *>::test): ...this.\n\t(is_a_helper <const gimple_statement_omp_continue *>::test):\n\tRename to...\n\t(is_a_helper <const gomp_continue *>::test): ...this.\n\t(is_a_helper <const gimple_statement_omp_critical *>::test):\n\tRename to...\n\t(is_a_helper <const gomp_critical *>::test): ...this.\n\t(is_a_helper <const gimple_statement_omp_for *>::test): Rename to...\n\t(is_a_helper <const gomp_for *>::test): ...this.\n\t(is_a_helper <const gimple_statement_omp_parallel *>::test):\n\tRename to...\n\t(is_a_helper <const gomp_parallel *>::test): ...this.\n\t(is_a_helper <const gimple_statement_omp_target *>::test): Rename to...\n\t(is_a_helper <const gomp_target *>::test): ...this.\n\t(is_a_helper <const gimple_statement_omp_sections *>::test):\n\tRename to...\n\t(is_a_helper <const gomp_sections *>::test): ...this.\n\t(is_a_helper <const gimple_statement_omp_single *>::test): Rename to...\n\t(is_a_helper <const gomp_single *>::test): ...this.\n\t(is_a_helper <const gimple_statement_omp_teams *>::test): Rename to...\n\t(is_a_helper <const gomp_teams *>::test): ...this.\n\t(is_a_helper <const gimple_statement_omp_task *>::test): Rename to...\n\t(is_a_helper <const gomp_task *>::test): ...this.\n\t(is_a_helper <const gimple_statement_phi *>::test): Rename to...\n\t(is_a_helper <const gphi *>::test): ...this.\n\t(is_a_helper <const gimple_statement_transaction *>::test): Rename to...\n\t(is_a_helper <const gtransaction *>::test): ...this.\n\t(gimple_build_return): Strengthen return type to greturn *.\n\t(gimple_call_reset_alias_info): Require a gcall *.\n\t(gimple_build_call_vec): Return a gcall *.\n\t(gimple_build_call): Likewise.\n\t(gimple_build_call_valist): Likewise.\n\t(gimple_build_call_internal): Likewise.\n\t(gimple_build_call_internal_vec): Likewise.\n\t(gimple_build_call_from_tree): Likewise.\n\t(gimple_build_assign_stat): Return a gassign *.\n\t(gimple_build_assign_with_ops): Likewise.\n\t(gimple_build_cond): Return a gcond *.\n\t(gimple_build_cond_from_tree): Likewise.\n\t(gimple_cond_set_condition_from_tree): Require a gcond *.\n\t(gimple_build_label): Return a glabel *.\n\t(gimple_build_goto): Return a ggoto *.\n\t(gimple_build_bind): Return a gbind *.\n\t(gimple_build_asm_vec): Return a gasm *.\n\t(gimple_build_catch): Return a gcatch *.\n\t(gimple_build_eh_filter): Return a geh_filter *.\n\t(gimple_build_eh_must_not_throw): Return a geh_mnt *.\n\t(gimple_build_eh_else): Return a geh_else *.\n\t(gimple_build_try): Return a gtry *.\n\t(gimple_build_resx): Return a gresx *.\n\t(gimple_build_switch_nlabels): Return a gswitch *.\n\t(gimple_build_switch): Return a gswitch *.\n\t(gimple_build_eh_dispatch): Return a geh_dispatch *.\n\t(gimple_build_debug_bind_stat): Return a gdebug *.\n\t(gimple_build_debug_source_bind_stat): Return a gdebug *.\n\t(gimple_build_omp_critical): Return a gomp_critical *.\n\t(gimple_build_omp_for): Return a gomp_for *.\n\t(gimple_build_omp_parallel): Return a gomp_parallel *.\n\t(gimple_build_omp_task): Return a gomp_task *.\n\t(gimple_build_omp_continue): Return a gomp_continue *.\n\t(gimple_build_omp_sections): Return a gomp_sections *.\n\t(gimple_build_omp_single): Return a gomp_single *.\n\t(gimple_build_omp_target): Return a gomp_target *.\n\t(gimple_build_omp_teams): Return a gomp_teams *.\n\t(gimple_build_omp_atomic_load): Return a gomp_atomic_load *.\n\t(gimple_build_omp_atomic_store): Return a gomp_atomic_store *.\n\t(gimple_build_transaction): Return a gtransaction *.\n\t(gimple_call_arg_flags): Require a const gcall *.\n\t(gimple_call_return_flags): Likewise.\n\t(gimple_call_copy_skip_args): Require and return a gcall *.\n\t(gimple_asm_clobbers_memory_p): Require a const gasm *.\n\t(gimple_seq_first_stmt_as_a_bind): New.\n\t(gimple_assign_nontemporal_move_p): Require a const gassign *\n\trather than a const_gimple.\n\t(gimple_call_internal_fn): Update for renaming to gcall.\n\t(gimple_call_fntype): Likewise.\n\t(gimple_call_set_fntype): Require a gcall * rather than a gimple.\n\t(gimple_call_set_fn): Likewise.\n\t(gimple_call_set_internal_fn): Likewise.\n\t(gimple_call_set_chain): Likewise.\n\t(gimple_call_set_tail): Likewise.\n\t(gimple_call_tail_p): Likewise.\n\t(gimple_call_set_return_slot_opt): Likewise.\n\t(gimple_call_return_slot_opt_p): Likewise.\n\t(gimple_call_set_from_thunk): Likewise.\n\t(gimple_call_from_thunk_p): Likewise.\n\t(gimple_call_set_va_arg_pack): Likewise.\n\t(gimple_call_va_arg_pack_p): Likewise.\n\t(gimple_call_set_nothrow): Likewise.\n\t(gimple_call_nothrow_p): Likewise.\n\t(gimple_call_set_alloca_for_var): Likewise.\n\t(gimple_call_alloca_for_var_p): Likewise.\n\t(gimple_call_use_set): Likewise.\n\t(gimple_call_clobber_set): Likewise.\n\t(gimple_call_return_type): Require a const gcall * rather than a\n\tconst_gimple.\n\t(gimple_call_chain_ptr): Likewise.\n\t(gimple_call_copy_flags): Require a pair of gcall *.\n\t(gimple_cond_set_code): Require a gcond * rather than a gimple\n\t(gimple_cond_set_lhs): Likewise.\n\t(gimple_cond_set_rhs): Likewise.\n\t(gimple_cond_set_true_label): Likewise.\n\t(gimple_cond_set_false_label): Likewise.\n\t(gimple_cond_make_false): Likewise.\n\t(gimple_cond_make_true): Likewise.\n\t(gimple_cond_lhs_ptr): Require a const gcond * rather than a\n\tconst_gimple.\n\t(gimple_cond_rhs_ptr): Likewise.\n\t(gimple_cond_true_label): Likewise.\n\t(gimple_cond_false_label): Likewise.\n\t(gimple_cond_true_p): Likewise.\n\t(gimple_cond_false_p): Likewise.\n\t(gimple_cond_set_condition): Likewise.\n\t(gimple_label_label): Require a const glabel *.\n\t(gimple_label_set_label): Require a glabel *.\n\t(gimple_goto_set_dest): Require a ggoto *.\n\t(gimple_bind_vars): Require a const gbind *.\n\t(gimple_bind_block): Likewise.\n\t(gimple_bind_set_vars): Require a gbind *.\n\t(gimple_bind_append_vars): Likewise.\n\t(gimple_bind_body_ptr): Likewise.\n\t(gimple_bind_body): Likewise.\n\t(gimple_bind_set_body): Likewise.\n\t(gimple_bind_add_stmt): Likewise.\n\t(gimple_bind_add_seq): Likewise.\n\t(gimple_bind_set_block): Likewise.\n\t(gimple_asm_ninputs): Require a const gasm *.\n\t(gimple_asm_noutputs): Likewise.\n\t(gimple_asm_nclobbers): Likewise.\n\t(gimple_asm_nlabels): Likewise.\n\t(gimple_asm_input_op): Likewise.\n\t(gimple_asm_input_op_ptr): Likewise.\n\t(gimple_asm_output_op): Likewise.\n\t(gimple_asm_output_op_ptr): Likewise.\n\t(gimple_asm_clobber_op): Likewise.\n\t(gimple_asm_label_op): Likewise.\n\t(gimple_asm_string): Likewise.\n\t(gimple_asm_volatile_p): Likewise.\n\t(gimple_asm_input_p): Likewise.\n\t(gimple_asm_set_input_op): Require a gasm *.\n\t(gimple_asm_set_output_op): Likewise.\n\t(gimple_asm_set_clobber_op): Likewise.\n\t(gimple_asm_set_label_op): Likewise.\n\t(gimple_asm_set_volatile): Likewise.\n\t(gimple_asm_set_input): Likewise.\n\t(gimple_catch_types): Require a const gcatch *.\n\t(gimple_catch_types_ptr): Require a gcatch *.\n\t(gimple_catch_handler_ptr): Likewise.\n\t(gimple_catch_handler): Likewise.\n\t(gimple_catch_set_types): Likewise.\n\t(gimple_catch_set_handler): Likewise.\n\t(gimple_eh_filter_types): Update for renaming of subclass to\n\tgeh_filter.\n\t(gimple_eh_filter_types_ptr): Likewise.\n\t(gimple_eh_filter_failure_ptr): Likewise.\n\t(gimple_eh_filter_set_types): Require a geh_filter *.\n\t(gimple_eh_filter_set_failure): Likewise.\n\t(gimple_eh_must_not_throw_fndecl): Require a geh_mnt *.\n\t(gimple_eh_must_not_throw_set_fndecl): Likewise.\n\t(gimple_eh_else_n_body_ptr): Require a geh_else *.\n\t(gimple_eh_else_n_body): Likewise.\n\t(gimple_eh_else_e_body_ptr): Likewise.\n\t(gimple_eh_else_e_body): Likewise.\n\t(gimple_eh_else_set_n_body): Likewise.\n\t(gimple_eh_else_set_e_body): Likewise.\n\t(gimple_try_set_kind): Require a gtry *.\n\t(gimple_try_set_catch_is_cleanup): Likewise.\n\t(gimple_try_set_eval): Likewise.\n\t(gimple_try_set_cleanup): Likewise.\n\t(gimple_try_eval_ptr): Update for renaming of subclass to gtry.\n\t(gimple_try_cleanup_ptr): Likewise.\n\t(gimple_phi_capacity): Update for renaming of subclass to gphi.\n\t(gimple_phi_num_args): Likewise.\n\t(gimple_phi_result): Likewise.\n\t(gimple_phi_result_ptr): Likewise.\n\t(gimple_phi_arg): Likewise.\n\t(gimple_phi_set_result): Require a gphi *.\n\t(gimple_phi_set_arg): Likewise.\n\t(gimple_phi_arg_def_ptr): Likewise.\n\t(gimple_phi_arg_edge): Likewise.\n\t(gimple_phi_arg_location): Likewise.\n\t(gimple_phi_arg_location_from_edge): Likewise.\n\t(gimple_phi_arg_set_location): Likewise.\n\t(gimple_phi_arg_has_location): Likewise.\n\t(gimple_resx_region): Require a const gresx *.\n\t(gimple_resx_set_region): Require a gresx *.\n\t(gimple_eh_dispatch_region): Require a const geh_dispatch *.\n\t(gimple_eh_dispatch_set_region): Require a geh_dispatch *.\n\t(gimple_switch_num_labels): Require a const gswitch *.\n\t(gimple_switch_set_num_labels): Likewise.\n\t(gimple_switch_index): Likewise.\n\t(gimple_switch_index_ptr): Likewise.\n\t(gimple_switch_label): Likewise.\n\t(gimple_switch_default_label): Likewise.\n\t(gimple_switch_set_index): Require a gswitch *.\n\t(gimple_switch_set_label): Likewise.\n\t(gimple_switch_set_default_label): Likewise.\n\t(gimple_omp_critical_name): Require a const gomp_critical *.\n\t(gimple_omp_critical_name_ptr): Require a gomp_critical *.\n\t(gimple_omp_critical_set_name): Likewise.\n\t(gimple_omp_for_set_kind): Require a gomp_for *.\n\t(gimple_omp_for_set_combined_p): Likewise.\n\t(gimple_omp_for_set_combined_into_p): Likewise.\n\t(gimple_omp_for_clauses): Update for renaming of subclass to\n\tgomp_for.\n\t(gimple_omp_for_clauses_ptr): Likewise.\n\t(gimple_omp_for_set_clauses): Likewise.\n\t(gimple_omp_for_collapse): Likewise.\n\t(gimple_omp_for_index): Likewise.\n\t(gimple_omp_for_index_ptr): Likewise.\n\t(gimple_omp_for_set_index): Likewise.\n\t(gimple_omp_for_initial): Likewise.\n\t(gimple_omp_for_initial_ptr): Likewise.\n\t(gimple_omp_for_set_initial): Likewise.\n\t(gimple_omp_for_final): Likewise.\n\t(gimple_omp_for_final_ptr): Likewise.\n\t(gimple_omp_for_set_final): Likewise.\n\t(gimple_omp_for_incr): Likewise.\n\t(gimple_omp_for_incr_ptr): Likewise.\n\t(gimple_omp_for_set_incr): Likewise.\n\t(gimple_omp_for_pre_body): Likewise.\n\t(gimple_omp_for_set_pre_body): Likewise.\n\t(gimple_omp_parallel_clauses): Update for renaming of subclass to\n\tgomp_parallel.\n\t(gimple_omp_parallel_clauses_ptr): Require a gomp_parallel *.\n\t(gimple_omp_parallel_set_clauses): Likewise.\n\t(gimple_omp_parallel_child_fn_ptr): Likewise.\n\t(gimple_omp_parallel_set_child_fn): Likewise.\n\t(gimple_omp_parallel_data_arg_ptr): Likewise.\n\t(gimple_omp_parallel_set_data_arg): Likewise.\n\t(gimple_omp_parallel_child_fn): Require a const gomp_parallel *.\n\t(gimple_omp_parallel_data_arg): Likewise.\n\t(gimple_omp_task_clauses): Update for renaming of subclass to\n\tgomp_task.\n\t(gimple_omp_task_clauses_ptr): Likewise.\n\t(gimple_omp_task_set_clauses): Likewise.\n\t(gimple_omp_task_child_fn): Likewise.\n\t(gimple_omp_task_child_fn_ptr): Likewise.\n\t(gimple_omp_task_set_child_fn): Likewise.\n\t(gimple_omp_task_data_arg): Likewise.\n\t(gimple_omp_task_data_arg_ptr): Likewise.\n\t(gimple_omp_task_set_data_arg): Likewise.\n\t(gimple_omp_taskreg_clauses): Whitespace fixes.\n\t(gimple_omp_taskreg_clauses_ptr): Likewise.\n\t(gimple_omp_taskreg_set_clauses): Likewise.\n\t(gimple_omp_taskreg_child_fn): Likewise.\n\t(gimple_omp_taskreg_child_fn_ptr): Likewise.\n\t(gimple_omp_taskreg_set_child_fn): Likewise.\n\t(gimple_omp_taskreg_data_arg): Likewise.\n\t(gimple_omp_taskreg_data_arg_ptr): Likewise.\n\t(gimple_omp_taskreg_set_data_arg): Likewise.\n\t(gimple_omp_task_copy_fn): Update for renaming of subclass to\n\tgomp_task.\n\t(gimple_omp_task_copy_fn_ptr): Likewise.\n\t(gimple_omp_task_set_copy_fn): Likewise.\n\t(gimple_omp_task_arg_size): Likewise.\n\t(gimple_omp_task_arg_size_ptr): Likewise.\n\t(gimple_omp_task_set_arg_size): Likewise.\n\t(gimple_omp_task_arg_align): Likewise.\n\t(gimple_omp_task_arg_align_ptr): Likewise.\n\t(gimple_omp_task_set_arg_align): Likewise.\n\t(gimple_omp_single_clauses): Update for renaming of subclass to\n\tgomp_single.\n\t(gimple_omp_single_clauses_ptr): Likewise.\n\t(gimple_omp_single_set_clauses): Likewise.\n\t(gimple_omp_target_clauses): Update for renaming of subclass to\n\tgomp_target.\n\t(gimple_omp_target_clauses_ptr): Likewise.\n\t(gimple_omp_target_set_clauses): Require a gomp_target *.\n\t(gimple_omp_target_set_kind): Likewise.\n\t(gimple_omp_target_child_fn_ptr): Likewise.\n\t(gimple_omp_target_set_child_fn): Likewise.\n\t(gimple_omp_target_data_arg_ptr): Likewise.\n\t(gimple_omp_target_set_data_arg): Likewise.\n\t(gimple_omp_target_child_fn): Require a const gomp_target *.\n\t(gimple_omp_target_data_arg): Likewise.\n\t(gimple_omp_teams_clauses): Update for renaming of subclass to\n\tgomp_teams.\n\t(gimple_omp_teams_clauses_ptr): Likewise.\n\t(gimple_omp_teams_set_clauses): Require a gomp_teams *.\n\t(gimple_omp_sections_clauses): Update for renaming of subclass to\n\tgomp_sections.\n\t(gimple_omp_sections_clauses_ptr): Likewise.\n\t(gimple_omp_sections_set_clauses): Likewise.\n\t(gimple_omp_sections_control): Likewise.\n\t(gimple_omp_sections_control_ptr): Likewise.\n\t(gimple_omp_sections_set_control): Likewise.\n\t(gimple_omp_for_set_cond): Likewise.\n\t(gimple_omp_for_cond): Likewise.\n\t(gimple_omp_atomic_store_set_val): Require a gomp_atomic_store *.\n\t(gimple_omp_atomic_store_val_ptr): Likewise.\n\t(gimple_omp_atomic_load_set_lhs): Likewise.\n\t(gimple_omp_atomic_store_val): Require a const gomp_atomic_store *.\n\t(gimple_omp_atomic_load_lhs): Likewise.\n\t(gimple_omp_atomic_load_rhs): Likewise.\n\t(gimple_omp_atomic_load_lhs_ptr): Require a gomp_atomic_load *.\n\t(gimple_omp_atomic_load_set_rhs): Likewise.\n\t(gimple_omp_atomic_load_rhs_ptr): Likewise.\n\t(gimple_omp_continue_control_def): Require a const gomp_continue *.\n\t(gimple_omp_continue_control_use): Likewise.\n\t(gimple_omp_continue_control_def_ptr): Require a gomp_continue *.\n\t(gimple_omp_continue_set_control_def): Likewise.\n\t(gimple_omp_continue_control_use_ptr): Likewise.\n\t(gimple_omp_continue_set_control_use): Likewise.\n\t(gimple_transaction_body_ptr): Require a gtransaction *.\n\t(gimple_transaction_body): Likewise.\n\t(gimple_transaction_label_ptr): Likewise.\n\t(gimple_transaction_label): Require a const gtransaction *.\n\t(gimple_transaction_subcode): Likewise.\n\t(gimple_transaction_set_body): Require a gtransaction *.\n\t(gimple_transaction_set_label): Likewise.\n\t(gimple_transaction_set_subcode): Likewise.\n\t(gimple_return_retval_ptr): Require a const greturn *.\n\t(gimple_return_retval): Likewise.\n\t(gimple_return_set_retval): Require a greturn *.\n\t(gimple_expr_type): Introduce local \"call_stmt\" and use in place of\n\t\"stmt\" for typesafety.\n\n\t* asan.c: Use gimple subclasses.\n\t* auto-profile.c: Likewise.\n\t* builtins.c: Likewise.\n\t* builtins.h: Likewise.\n\t* cfgexpand.c: Likewise.\n\t* cfgloop.c: Likewise.\n\t* cfgloopmanip.c: Likewise.\n\t* cgraph.c: Likewise.\n\t* cgraph.h: Likewise.\n\t* cgraphbuild.c: Likewise.\n\t* cgraphclones.c: Likewise.\n\t* cgraphunit.c: Likewise.\n\t* expr.h: Likewise.\n\t* gimple-builder.c: Likewise.\n\t* gimple-builder.h: Likewise.\n\t* gimple-fold.c: Likewise.\n\t* gimple-low.c: Likewise.\n\t* gimple-pretty-print.c: Likewise.\n\t* gimple-ssa-isolate-paths.c: Likewise.\n\t* gimple-ssa-strength-reduction.c: Likewise.\n\t* gimple-streamer-in.c: Likewise.\n\t* gimple-streamer-out.c: Likewise.\n\t* gimple-walk.c: Likewise.\n\t* gimplify-me.c: Likewise.\n\t* gimplify.c: Likewise.\n\t* gimplify.h: Likewise.\n\t* graphite-scop-detection.c: Likewise.\n\t* graphite-sese-to-poly.c: Likewise.\n\t* internal-fn.c: Likewise.\n\t* internal-fn.def:: Likewise.\n\t* internal-fn.h: Likewise.\n\t* ipa-icf-gimple.c: Likewise.\n\t* ipa-icf-gimple.h: Likewise.\n\t* ipa-icf.c: Likewise.\n\t* ipa-inline-analysis.c: Likewise.\n\t* ipa-prop.c: Likewise.\n\t* ipa-prop.h: Likewise.\n\t* ipa-pure-const.c: Likewise.\n\t* ipa-split.c: Likewise.\n\t* lto-streamer-in.c: Likewise.\n\t* lto-streamer-out.c: Likewise.\n\t* omp-low.c: Likewise.\n\t* predict.c: Likewise.\n\t* sanopt.c: Likewise.\n\t* sese.c: Likewise.\n\t* ssa-iterators.h: Likewise.\n\t* stmt.c: Likewise.\n\t* trans-mem.c: Likewise.\n\t* tree-call-cdce.c: Likewise.\n\t* tree-cfg.c: Likewise.\n\t* tree-cfg.h: Likewise.\n\t* tree-cfgcleanup.c: Likewise.\n\t* tree-chkp.c: Likewise.\n\t* tree-chkp.h: Likewise.\n\t* tree-complex.c: Likewise.\n\t* tree-data-ref.c: Likewise.\n\t* tree-dfa.c: Likewise.\n\t* tree-eh.c: Likewise.\n\t* tree-eh.h: Likewise.\n\t* tree-emutls.c: Likewise.\n\t* tree-if-conv.c: Likewise.\n\t* tree-inline.c: Likewise.\n\t* tree-inline.h: Likewise.\n\t* tree-into-ssa.c: Likewise.\n\t* tree-into-ssa.h: Likewise.\n\t* tree-loop-distribution.c: Likewise.\n\t* tree-nrv.c: Likewise.\n\t* tree-object-size.c: Likewise.\n\t* tree-outof-ssa.c: Likewise.\n\t* tree-parloops.c: Likewise.\n\t* tree-phinodes.c: Likewise.\n\t* tree-phinodes.h: Likewise.\n\t* tree-predcom.c: Likewise.\n\t* tree-profile.c: Likewise.\n\t* tree-scalar-evolution.c: Likewise.\n\t* tree-scalar-evolution.h\n\t* tree-sra.cn_function):\n\t* tree-ssa-alias.c: Likewise.\n\t* tree-ssa-alias.h: Likewise.\n\t* tree-ssa-ccp.c: Likewise.\n\t* tree-ssa-coalesce.c: Likewise.\n\t* tree-ssa-copy.c: Likewise.\n\t* tree-ssa-copyrename.c: Likewise.\n\t* tree-ssa-dce.c: Likewise.\n\t* tree-ssa-dom.c: Likewise.\n\t* tree-ssa-forwprop.c: Likewise.\n\t* tree-ssa-ifcombine.c: Likewise.\n\t* tree-ssa-live.c: Likewise.\n\t* tree-ssa-loop-im.c: Likewise.\n\t* tree-ssa-loop-ivcanon.c: Likewise.\n\t* tree-ssa-loop-ivopts.c: Likewise.\n\t* tree-ssa-loop-manip.c: Likewise.\n\t* tree-ssa-loop-niter.c: Likewise.\n\t* tree-ssa-loop-prefetch.c: Likewise.\n\t* tree-ssa-loop-unswitch.c: Likewise.\n\t* tree-ssa-math-opts.c: Likewise.\n\t* tree-ssa-operands.c: Likewise.\n\t* tree-ssa-phiopt.c: Likewise.\n\t* tree-ssa-phiprop.c: Likewise.\n\t* tree-ssa-pre.c: Likewise.\n\t* tree-ssa-propagate.c: Likewise.\n\t* tree-ssa-propagate.h: Likewise.\n\t* tree-ssa-reassoc.c: Likewise.\n\t* tree-ssa-sccvn.c: Likewise.\n\t* tree-ssa-sccvn.h: Likewise.\n\t* tree-ssa-sink.c: Likewise.\n\t* tree-ssa-strlen.c\n\t* tree-ssa-structalias.c\n\t* tree-ssa-tail-merge.c: Likewise.\n\t* tree-ssa-ter.c: Likewise.\n\t* tree-ssa-threadedge.c: Likewise.\n\t* tree-ssa-threadedge.h: Likewise.\n\t* tree-ssa-threadupdate.c: Likewise.\n\t* tree-ssa-uncprop.c: Likewise.\n\t* tree-ssa-uninit.c: Likewise.\n\t* tree-ssa.c: Likewise.\n\t* tree-stdarg.c: Likewise.\n\t* tree-switch-conversion.c: Likewise.\n\t* tree-tailcall.c: Likewise.\n\t* tree-vect-data-refs.c: Likewise.\n\t* tree-vect-generic.c: Likewise.\n\t* tree-vect-loop-manip.c: Likewise.\n\t* tree-vect-loop.c: Likewise.\n\t* tree-vect-patterns.c: Likewise.\n\t* tree-vect-slp.c: Likewise.\n\t* tree-vect-stmts.c: Likewise.\n\t* tree-vectorizer.h: Likewise.\n\t* tree-vrp.c: Likewise.\n\t* tree.c: Likewise.\n\t* ubsan.c: Likewise.\n\t* value-prof.c: Likewise.\n\t* value-prof.h: Likewise.\n\t* vtable-verify.c: Likewise.\n\ngcc/c-family/ChangeLog:\n\tMerger of git branch \"gimple-classes-v2-option-3\".\n\t* ChangeLog.gimple-classes: New.\n\t* c-gimplify.c (add_block_to_enclosing): Strengthen local \"stack\"\n\tfrom being just a vec<gimple> to a vec<gbind *>.\n\ngcc/java/ChangeLog:\n\tMerger of git branch \"gimple-classes-v2-option-3\".\n\t* ChangeLog.gimple-classes: New.\n\t* java-gimplify.c (java_gimplify_block): Strengthen local \"outer\"\n\tfrom gimple to gbind *.\n\nFrom-SVN: r217787", "tree": {"sha": "10282bd0fe08815f5683eb5ed7fbc1456ff26a4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10282bd0fe08815f5683eb5ed7fbc1456ff26a4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/538dd0b78f4b3998a1719a282811cb0caa1b035a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/538dd0b78f4b3998a1719a282811cb0caa1b035a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/538dd0b78f4b3998a1719a282811cb0caa1b035a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/538dd0b78f4b3998a1719a282811cb0caa1b035a/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "da9c88d86d71721af15f9342a31e385e897fb643", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da9c88d86d71721af15f9342a31e385e897fb643", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da9c88d86d71721af15f9342a31e385e897fb643"}], "stats": {"total": 13120, "additions": 9602, "deletions": 3518}, "files": [{"sha": "791599fca4fa6c88b67b9df18eb8191ab15b83c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 723, "deletions": 0, "changes": 723, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -1,3 +1,726 @@\n+2014-11-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tMerger of git branch \"gimple-classes-v2-option-3\".\n+\n+\t* ChangeLog.gimple-classes: New.\n+\n+\t* coretypes.h (struct gcond): Add forward decl.\n+\t(struct gdebug): Likewise.\n+\t(struct ggoto): Likewise.\n+\t(struct glabel): Likewise.\n+\t(struct gswitch): Likewise.\n+\t(struct gassign): Likewise.\n+\t(struct gasm): Likewise.\n+\t(struct gcall): Likewise.\n+\t(struct gtransaction): Likewise.\n+\t(struct greturn): Likewise.\n+\t(struct gbind): Likewise.\n+\t(struct gcatch): Likewise.\n+\t(struct geh_filter): Likewise.\n+\t(struct geh_mnt): Likewise.\n+\t(struct geh_else): Likewise.\n+\t(struct gresx): Likewise.\n+\t(struct geh_dispatch): Likewise.\n+\t(struct gphi): Likewise.\n+\t(struct gtry): Likewise.\n+\t(struct gomp_atomic_load): Likewise.\n+\t(struct gomp_atomic_store): Likewise.\n+\t(struct gomp_continue): Likewise.\n+\t(struct gomp_critical): Likewise.\n+\t(struct gomp_for): Likewise.\n+\t(struct gomp_parallel): Likewise.\n+\t(struct gomp_task): Likewise.\n+\t(struct gomp_sections): Likewise.\n+\t(struct gomp_single): Likewise.\n+\t(struct gomp_target): Likewise.\n+\t(struct gomp_teams): Likewise.\n+\n+\t* doc/gimple.texi (Class hierarchy of GIMPLE statements): Update\n+\tfor renaming of gimple subclasses.\n+\n+\t* gdbhooks.py: Update.\n+\n+\t* gimple-iterator.c (gsi_for_phi): New.\n+\t(gsi_start_phis): Strengthen return type from gimple_stmt_iterator\n+\tto gphi_iterator.\n+\t* gimple-iterator.h (struct gphi_iterator): New subclass of\n+\tgimple_stmt_iterator.\n+\t(gsi_for_phi): New prototype.\n+\t(gsi_start_phis): Strengthen return type from gimple_stmt_iterator\n+\tto gphi_iterator.\n+\t(gsi_next_nonvirtual_phi): Strengthen param from\n+\tgimple_stmt_iterator * to gphi_iterator *, and local \"phi\" from\n+\tgimple to gphi *.\n+\n+\t* gsstruct.def: Update for renamings of classes.\n+\n+\t* gimple.c (gimple_build_return): Strengthen return type from\n+\tgimple to greturn *.\n+\t(gimple_call_reset_alias_info): Strengthen param to gcall *.\n+\t(gimple_build_call_1): Strengthen return type from gimple to\n+\tgcall *.\n+\t(gimple_build_call_vec): Likewise.\n+\t(gimple_build_call): Likewise.\n+\t(gimple_build_call_valist): Likewise.\n+\t(gimple_build_call_internal_1): Likewise.\n+\t(gimple_build_call_internal): Likewise.\n+\t(gimple_build_call_internal_vec): Likewise.\n+\t(gimple_build_call_from_tree): Likewise.\n+\t(gimple_build_assign_stat): Strengthen return type from gimple to\n+\tgassign *.\n+\t(gimple_build_assign_with_ops): Likewise.\n+\t(gimple_build_assign_with_ops): Likewise.\n+\t(gimple_build_cond): Strengthen return type from gimple to\n+\tgcond *.\n+\t(gimple_build_cond_from_tree): Likewise.\n+\t(gimple_cond_set_condition_from_tree): Require a gcond *.\n+\t(gimple_build_label): Strengthen return type from gimple to\n+\tglabel *.\n+\t(gimple_build_goto): Strengthen return type from gimple to\n+\tggoto *.\n+\t(gimple_build_bind): Strengthen return type from gimple to\n+\tgbind *.\n+\t(gimple_build_asm_1): Strengthen return type from gimple to\n+\tgasm *.\n+\t(gimple_build_asm_vec): Likewise.\n+\t(gimple_build_catch): Strengthen return type from gimple to\n+\tgcatch *.\n+\t(gimple_build_eh_filter): Strengthen return type from gimple to\n+\tgeh_filter *.\n+\t(gimple_build_eh_must_not_throw): Strengthen return type from\n+\tgimple to geh_mnt *.\n+\t(gimple_build_eh_else): Strengthen return type from gimple to\n+\tgeh_else *.\n+\t(gimple_build_try): Update for renaming of gimple_statement_try to\n+\tgtry.\n+\t(gimple_build_resx): Strengthen return type from gimple to\n+\tgresx *.\n+\t(gimple_build_switch_nlabels): Strengthen return type from gimple\n+\tto gswitch *.\n+\t(gimple_build_switch): Likewise.\n+\t(gimple_build_eh_dispatch): Strengthen return type from gimple to\n+\tgeh_dispatch *.\n+\t(gimple_build_debug_bind_stat): Strengthen return type from gimple\n+\tto gdebug *.\n+\t(gimple_build_debug_source_bind_stat): Strengthen return type from\n+\tgimple to gdebug *.\n+\t(gimple_build_omp_critical): Strengthen return type from gimple to\n+\tgomp_critical *.\n+\t(gimple_build_omp_for): Strengthen return type from gimple to\n+\tgomp_for *.\n+\t(gimple_build_omp_parallel): Strengthen return type from gimple to\n+\tgomp_parallel *.\n+\t(gimple_build_omp_task): Strengthen return type from gimple to\n+\tgomp_task *.\n+\t(gimple_build_omp_continue): Strengthen return type from gimple to\n+\tgomp_continue *.\n+\t(gimple_build_omp_sections): Strengthen return type from gimple to\n+\tgomp_sections *.\n+\t(gimple_build_omp_single): Strengthen return type from gimple to\n+\tgomp_single *.\n+\t(gimple_build_omp_target): Strengthen return type from gimple to\n+\tgomp_target *.\n+\t(gimple_build_omp_teams): Strengthen return type from gimple to\n+\tgomp_teams *.\n+\t(gimple_build_omp_atomic_load): Strengthen return type from gimple\n+\tto gomp_atomic_load *.\n+\t(gimple_build_omp_atomic_store): Strengthen return type from gimple\n+\tto gomp_atomic_store *.\n+\t(gimple_build_transaction): Strengthen return type from gimple\n+\tto gtransaction *.\n+\t(empty_stmt_p): Replace check for GIMPLE_BIND with a dyn_cast.\n+\t(gimple_call_fnspec): Require a const gcall *.\n+\t(gimple_call_arg_flags): Likewise.\n+\t(gimple_call_return_flags): Likewise.\n+\t(gimple_set_bb): Add a checked cast.\n+\t(gimple_copy): Within the cases, add locals of the appropriate\n+\tsubclass and use in place of \"stmt\" and \"copy\" for typesafety.\n+\t(gimple_has_side_effects): Add a checked cast.\n+\t(gimple_could_trap_p_1): Likewise.\n+\t(gimple_call_copy_skip_args): Require a gcall *, and return one.\n+\t(gimple_asm_clobbers_memory_p): Require a const gasm *.\n+\t(infer_nonnull_range): Replace a check for GIMPLE_RETURN with a\n+\tdyn_cast, introducing local \"return_stmt\" and using ti in place\n+\tof \"stmt\".\n+\n+\t* gimple.h (gimple_vec): Eliminate this typedef.\n+\t(struct gimple_statement_call): Rename to...\n+\t(struct gcall): ...this.\n+\t(struct gimple_statement_bind): Rename to...\n+\t(struct gbind): ...this.\n+\t(struct gimple_statement_catch): Rename to...\n+\t(struct gcatch): ...this.\n+\t(struct gimple_statement_eh_filter): Rename to...\n+\t(struct geh_filter): ...this.\n+\t(struct gimple_statement_eh_else): Rename to...\n+\t(struct geh_else): ...this.\n+\t(struct gimple_statement_eh_mnt): Rename to...\n+\t(struct geh_mnt): ...this.\n+\t(struct gimple_statement_phi): Rename to...\n+\t(struct gphi): ...this.\n+\t(struct gimple_statement_resx): Rename to...\n+\t(struct gresx): ...this.\n+\t(struct gimple_statement_eh_dispatch): Rename to...\n+\t(struct geh_dispatch): ...this.\n+\t(struct gimple_statement_try): Rename to...\n+\t(struct gtry): ...this.\n+\t(struct gimple_statement_asm): Rename to...\n+\t(struct gasm): ...this.\n+\t(struct gimple_statement_omp_critical): Rename to...\n+\t(struct gomp_critical): ...this.\n+\t(struct gimple_statement_omp_for): Rename to...\n+\t(struct gomp_for): ...this.\n+\t(struct gimple_statement_omp_parallel): Rename to...\n+\t(struct gomp_parallel): ...this.\n+\t(struct gimple_statement_omp_target): Rename to...\n+\t(struct gomp_target): ...this.\n+\t(struct gimple_statement_omp_task): Rename to...\n+\t(struct gomp_task): ...this.\n+\t(struct gimple_statement_omp_sections): Rename to...\n+\t(struct gomp_sections): ...this.\n+\t(struct gimple_statement_omp_continue): Rename to...\n+\t(struct gomp_continue): ...this.\n+\t(struct gimple_statement_omp_single): Rename to...\n+\t(struct gomp_single): ...this.\n+\t(struct gimple_statement_omp_teams): Rename to...\n+\t(struct gomp_teams): ...this.\n+\t(struct gimple_statement_omp_atomic_load): Rename to...\n+\t(struct gomp_atomic_load): ...this.\n+\t(struct gimple_statement_omp_atomic_store :): Rename to...\n+\t(struct gomp_atomic_store :): ...this.\n+\t(struct gimple_statement_transaction): Rename to...\n+\t(struct gtransaction): ...this.\n+\t(struct gcond): New subclass.\n+\t(struct gdebug): New subclass.\n+\t(struct ggoto): New subclass.\n+\t(struct glabel): New subclass.\n+\t(struct gswitch): New subclass.\n+\t(struct gassign): New subclass.\n+\t(struct greturn): New subclass.\n+\t(is_a_helper <gimple_statement_asm *>::test): Rename to...\n+\t(is_a_helper <gasm *>::test): ...this.\n+\t(is_a_helper <gimple_statement_bind *>::test): Rename to...\n+\t(is_a_helper <gbind *>::test): ...this.\n+\t(is_a_helper <gassign *>::test): New.\n+\t(is_a_helper <gimple_statement_call *>::test): Rename to...\n+\t(is_a_helper <gcall *>::test): ...this.\n+\t(is_a_helper <gimple_statement_catch *>::test): Rename to...\n+\t(is_a_helper <gcatch *>::test): ...this.\n+\t(is_a_helper <gimple_statement_resx *>::test): Rename to...\n+\t(is_a_helper <gresx *>::test): ...this.\n+\t(is_a_helper <gcond *>::test): New.\n+\t(is_a_helper <gdebug *>::test): New.\n+\t(is_a_helper <ggoto *>::test): New.\n+\t(is_a_helper <glabel *>::test): New.\n+\t(is_a_helper <gimple_statement_eh_dispatch *>::test): Rename to...\n+\t(is_a_helper <geh_dispatch *>::test): ...this.\n+\t(is_a_helper <gimple_statement_eh_else *>::test): Rename to...\n+\t(is_a_helper <geh_else *>::test): ...this.\n+\t(is_a_helper <gimple_statement_eh_filter *>::test): Rename to...\n+\t(is_a_helper <geh_filter *>::test): ...this.\n+\t(is_a_helper <gimple_statement_eh_mnt *>::test): Rename to...\n+\t(is_a_helper <geh_mnt *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_atomic_load *>::test): Rename to...\n+\t(is_a_helper <gomp_atomic_load *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_atomic_store *>::test): Rename to...\n+\t(is_a_helper <gomp_atomic_store *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_continue *>::test): Rename to...\n+\t(is_a_helper <gomp_continue *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_critical *>::test): Rename to...\n+\t(is_a_helper <gomp_critical *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_for *>::test): Rename to...\n+\t(is_a_helper <gomp_for *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_parallel *>::test): Rename to...\n+\t(is_a_helper <gomp_parallel *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_target *>::test): Rename to...\n+\t(is_a_helper <gomp_target *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_sections *>::test): Rename to...\n+\t(is_a_helper <gomp_sections *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_single *>::test): Rename to...\n+\t(is_a_helper <gomp_single *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_teams *>::test): Rename to...\n+\t(is_a_helper <gomp_teams *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_task *>::test): Rename to...\n+\t(is_a_helper <gomp_task *>::test): ...this.\n+\t(is_a_helper <gimple_statement_phi *>::test): Rename to...\n+\t(is_a_helper <gphi *>::test): ...this.\n+\t(is_a_helper <gimple_statement_transaction *>::test): Rename to...\n+\t(is_a_helper <gtransaction *>::test): ...this.\n+\t(is_a_helper <greturn *>::test): New.\n+\t(is_a_helper <gswitch *>::test): New.\n+\t(is_a_helper <gimple_statement_try *>::test): Rename to...\n+\t(is_a_helper <gtry *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_asm *>::test): Rename to...\n+\t(is_a_helper <const gasm *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_bind *>::test): Rename to...\n+\t(is_a_helper <const gbind *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_call *>::test): Rename to...\n+\t(is_a_helper <const gcall *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_catch *>::test): Rename to...\n+\t(is_a_helper <const gcatch *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_resx *>::test): Rename to...\n+\t(is_a_helper <const gresx *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_eh_dispatch *>::test): Rename to...\n+\t(is_a_helper <const geh_dispatch *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_eh_filter *>::test): Rename to...\n+\t(is_a_helper <const geh_filter *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_omp_atomic_load *>::test):\n+\tRename to...\n+\t(is_a_helper <const gomp_atomic_load *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_omp_atomic_store *>::test):\n+\tRename to...\n+\t(is_a_helper <const gomp_atomic_store *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_omp_continue *>::test):\n+\tRename to...\n+\t(is_a_helper <const gomp_continue *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_omp_critical *>::test):\n+\tRename to...\n+\t(is_a_helper <const gomp_critical *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_omp_for *>::test): Rename to...\n+\t(is_a_helper <const gomp_for *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_omp_parallel *>::test):\n+\tRename to...\n+\t(is_a_helper <const gomp_parallel *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_omp_target *>::test): Rename to...\n+\t(is_a_helper <const gomp_target *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_omp_sections *>::test):\n+\tRename to...\n+\t(is_a_helper <const gomp_sections *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_omp_single *>::test): Rename to...\n+\t(is_a_helper <const gomp_single *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_omp_teams *>::test): Rename to...\n+\t(is_a_helper <const gomp_teams *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_omp_task *>::test): Rename to...\n+\t(is_a_helper <const gomp_task *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_phi *>::test): Rename to...\n+\t(is_a_helper <const gphi *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_transaction *>::test): Rename to...\n+\t(is_a_helper <const gtransaction *>::test): ...this.\n+\t(gimple_build_return): Strengthen return type to greturn *.\n+\t(gimple_call_reset_alias_info): Require a gcall *.\n+\t(gimple_build_call_vec): Return a gcall *.\n+\t(gimple_build_call): Likewise.\n+\t(gimple_build_call_valist): Likewise.\n+\t(gimple_build_call_internal): Likewise.\n+\t(gimple_build_call_internal_vec): Likewise.\n+\t(gimple_build_call_from_tree): Likewise.\n+\t(gimple_build_assign_stat): Return a gassign *.\n+\t(gimple_build_assign_with_ops): Likewise.\n+\t(gimple_build_cond): Return a gcond *.\n+\t(gimple_build_cond_from_tree): Likewise.\n+\t(gimple_cond_set_condition_from_tree): Require a gcond *.\n+\t(gimple_build_label): Return a glabel *.\n+\t(gimple_build_goto): Return a ggoto *.\n+\t(gimple_build_bind): Return a gbind *.\n+\t(gimple_build_asm_vec): Return a gasm *.\n+\t(gimple_build_catch): Return a gcatch *.\n+\t(gimple_build_eh_filter): Return a geh_filter *.\n+\t(gimple_build_eh_must_not_throw): Return a geh_mnt *.\n+\t(gimple_build_eh_else): Return a geh_else *.\n+\t(gimple_build_try): Return a gtry *.\n+\t(gimple_build_resx): Return a gresx *.\n+\t(gimple_build_switch_nlabels): Return a gswitch *.\n+\t(gimple_build_switch): Return a gswitch *.\n+\t(gimple_build_eh_dispatch): Return a geh_dispatch *.\n+\t(gimple_build_debug_bind_stat): Return a gdebug *.\n+\t(gimple_build_debug_source_bind_stat): Return a gdebug *.\n+\t(gimple_build_omp_critical): Return a gomp_critical *.\n+\t(gimple_build_omp_for): Return a gomp_for *.\n+\t(gimple_build_omp_parallel): Return a gomp_parallel *.\n+\t(gimple_build_omp_task): Return a gomp_task *.\n+\t(gimple_build_omp_continue): Return a gomp_continue *.\n+\t(gimple_build_omp_sections): Return a gomp_sections *.\n+\t(gimple_build_omp_single): Return a gomp_single *.\n+\t(gimple_build_omp_target): Return a gomp_target *.\n+\t(gimple_build_omp_teams): Return a gomp_teams *.\n+\t(gimple_build_omp_atomic_load): Return a gomp_atomic_load *.\n+\t(gimple_build_omp_atomic_store): Return a gomp_atomic_store *.\n+\t(gimple_build_transaction): Return a gtransaction *.\n+\t(gimple_call_arg_flags): Require a const gcall *.\n+\t(gimple_call_return_flags): Likewise.\n+\t(gimple_call_copy_skip_args): Require and return a gcall *.\n+\t(gimple_asm_clobbers_memory_p): Require a const gasm *.\n+\t(gimple_seq_first_stmt_as_a_bind): New.\n+\t(gimple_assign_nontemporal_move_p): Require a const gassign *\n+\trather than a const_gimple.\n+\t(gimple_call_internal_fn): Update for renaming to gcall.\n+\t(gimple_call_fntype): Likewise.\n+\t(gimple_call_set_fntype): Require a gcall * rather than a gimple.\n+\t(gimple_call_set_fn): Likewise.\n+\t(gimple_call_set_internal_fn): Likewise.\n+\t(gimple_call_set_chain): Likewise.\n+\t(gimple_call_set_tail): Likewise.\n+\t(gimple_call_tail_p): Likewise.\n+\t(gimple_call_set_return_slot_opt): Likewise.\n+\t(gimple_call_return_slot_opt_p): Likewise.\n+\t(gimple_call_set_from_thunk): Likewise.\n+\t(gimple_call_from_thunk_p): Likewise.\n+\t(gimple_call_set_va_arg_pack): Likewise.\n+\t(gimple_call_va_arg_pack_p): Likewise.\n+\t(gimple_call_set_nothrow): Likewise.\n+\t(gimple_call_nothrow_p): Likewise.\n+\t(gimple_call_set_alloca_for_var): Likewise.\n+\t(gimple_call_alloca_for_var_p): Likewise.\n+\t(gimple_call_use_set): Likewise.\n+\t(gimple_call_clobber_set): Likewise.\n+\t(gimple_call_return_type): Require a const gcall * rather than a\n+\tconst_gimple.\n+\t(gimple_call_chain_ptr): Likewise.\n+\t(gimple_call_copy_flags): Require a pair of gcall *.\n+\t(gimple_cond_set_code): Require a gcond * rather than a gimple\n+\t(gimple_cond_set_lhs): Likewise.\n+\t(gimple_cond_set_rhs): Likewise.\n+\t(gimple_cond_set_true_label): Likewise.\n+\t(gimple_cond_set_false_label): Likewise.\n+\t(gimple_cond_make_false): Likewise.\n+\t(gimple_cond_make_true): Likewise.\n+\t(gimple_cond_lhs_ptr): Require a const gcond * rather than a\n+\tconst_gimple.\n+\t(gimple_cond_rhs_ptr): Likewise.\n+\t(gimple_cond_true_label): Likewise.\n+\t(gimple_cond_false_label): Likewise.\n+\t(gimple_cond_true_p): Likewise.\n+\t(gimple_cond_false_p): Likewise.\n+\t(gimple_cond_set_condition): Likewise.\n+\t(gimple_label_label): Require a const glabel *.\n+\t(gimple_label_set_label): Require a glabel *.\n+\t(gimple_goto_set_dest): Require a ggoto *.\n+\t(gimple_bind_vars): Require a const gbind *.\n+\t(gimple_bind_block): Likewise.\n+\t(gimple_bind_set_vars): Require a gbind *.\n+\t(gimple_bind_append_vars): Likewise.\n+\t(gimple_bind_body_ptr): Likewise.\n+\t(gimple_bind_body): Likewise.\n+\t(gimple_bind_set_body): Likewise.\n+\t(gimple_bind_add_stmt): Likewise.\n+\t(gimple_bind_add_seq): Likewise.\n+\t(gimple_bind_set_block): Likewise.\n+\t(gimple_asm_ninputs): Require a const gasm *.\n+\t(gimple_asm_noutputs): Likewise.\n+\t(gimple_asm_nclobbers): Likewise.\n+\t(gimple_asm_nlabels): Likewise.\n+\t(gimple_asm_input_op): Likewise.\n+\t(gimple_asm_input_op_ptr): Likewise.\n+\t(gimple_asm_output_op): Likewise.\n+\t(gimple_asm_output_op_ptr): Likewise.\n+\t(gimple_asm_clobber_op): Likewise.\n+\t(gimple_asm_label_op): Likewise.\n+\t(gimple_asm_string): Likewise.\n+\t(gimple_asm_volatile_p): Likewise.\n+\t(gimple_asm_input_p): Likewise.\n+\t(gimple_asm_set_input_op): Require a gasm *.\n+\t(gimple_asm_set_output_op): Likewise.\n+\t(gimple_asm_set_clobber_op): Likewise.\n+\t(gimple_asm_set_label_op): Likewise.\n+\t(gimple_asm_set_volatile): Likewise.\n+\t(gimple_asm_set_input): Likewise.\n+\t(gimple_catch_types): Require a const gcatch *.\n+\t(gimple_catch_types_ptr): Require a gcatch *.\n+\t(gimple_catch_handler_ptr): Likewise.\n+\t(gimple_catch_handler): Likewise.\n+\t(gimple_catch_set_types): Likewise.\n+\t(gimple_catch_set_handler): Likewise.\n+\t(gimple_eh_filter_types): Update for renaming of subclass to\n+\tgeh_filter.\n+\t(gimple_eh_filter_types_ptr): Likewise.\n+\t(gimple_eh_filter_failure_ptr): Likewise.\n+\t(gimple_eh_filter_set_types): Require a geh_filter *.\n+\t(gimple_eh_filter_set_failure): Likewise.\n+\t(gimple_eh_must_not_throw_fndecl): Require a geh_mnt *.\n+\t(gimple_eh_must_not_throw_set_fndecl): Likewise.\n+\t(gimple_eh_else_n_body_ptr): Require a geh_else *.\n+\t(gimple_eh_else_n_body): Likewise.\n+\t(gimple_eh_else_e_body_ptr): Likewise.\n+\t(gimple_eh_else_e_body): Likewise.\n+\t(gimple_eh_else_set_n_body): Likewise.\n+\t(gimple_eh_else_set_e_body): Likewise.\n+\t(gimple_try_set_kind): Require a gtry *.\n+\t(gimple_try_set_catch_is_cleanup): Likewise.\n+\t(gimple_try_set_eval): Likewise.\n+\t(gimple_try_set_cleanup): Likewise.\n+\t(gimple_try_eval_ptr): Update for renaming of subclass to gtry.\n+\t(gimple_try_cleanup_ptr): Likewise.\n+\t(gimple_phi_capacity): Update for renaming of subclass to gphi.\n+\t(gimple_phi_num_args): Likewise.\n+\t(gimple_phi_result): Likewise.\n+\t(gimple_phi_result_ptr): Likewise.\n+\t(gimple_phi_arg): Likewise.\n+\t(gimple_phi_set_result): Require a gphi *.\n+\t(gimple_phi_set_arg): Likewise.\n+\t(gimple_phi_arg_def_ptr): Likewise.\n+\t(gimple_phi_arg_edge): Likewise.\n+\t(gimple_phi_arg_location): Likewise.\n+\t(gimple_phi_arg_location_from_edge): Likewise.\n+\t(gimple_phi_arg_set_location): Likewise.\n+\t(gimple_phi_arg_has_location): Likewise.\n+\t(gimple_resx_region): Require a const gresx *.\n+\t(gimple_resx_set_region): Require a gresx *.\n+\t(gimple_eh_dispatch_region): Require a const geh_dispatch *.\n+\t(gimple_eh_dispatch_set_region): Require a geh_dispatch *.\n+\t(gimple_switch_num_labels): Require a const gswitch *.\n+\t(gimple_switch_set_num_labels): Likewise.\n+\t(gimple_switch_index): Likewise.\n+\t(gimple_switch_index_ptr): Likewise.\n+\t(gimple_switch_label): Likewise.\n+\t(gimple_switch_default_label): Likewise.\n+\t(gimple_switch_set_index): Require a gswitch *.\n+\t(gimple_switch_set_label): Likewise.\n+\t(gimple_switch_set_default_label): Likewise.\n+\t(gimple_omp_critical_name): Require a const gomp_critical *.\n+\t(gimple_omp_critical_name_ptr): Require a gomp_critical *.\n+\t(gimple_omp_critical_set_name): Likewise.\n+\t(gimple_omp_for_set_kind): Require a gomp_for *.\n+\t(gimple_omp_for_set_combined_p): Likewise.\n+\t(gimple_omp_for_set_combined_into_p): Likewise.\n+\t(gimple_omp_for_clauses): Update for renaming of subclass to\n+\tgomp_for.\n+\t(gimple_omp_for_clauses_ptr): Likewise.\n+\t(gimple_omp_for_set_clauses): Likewise.\n+\t(gimple_omp_for_collapse): Likewise.\n+\t(gimple_omp_for_index): Likewise.\n+\t(gimple_omp_for_index_ptr): Likewise.\n+\t(gimple_omp_for_set_index): Likewise.\n+\t(gimple_omp_for_initial): Likewise.\n+\t(gimple_omp_for_initial_ptr): Likewise.\n+\t(gimple_omp_for_set_initial): Likewise.\n+\t(gimple_omp_for_final): Likewise.\n+\t(gimple_omp_for_final_ptr): Likewise.\n+\t(gimple_omp_for_set_final): Likewise.\n+\t(gimple_omp_for_incr): Likewise.\n+\t(gimple_omp_for_incr_ptr): Likewise.\n+\t(gimple_omp_for_set_incr): Likewise.\n+\t(gimple_omp_for_pre_body): Likewise.\n+\t(gimple_omp_for_set_pre_body): Likewise.\n+\t(gimple_omp_parallel_clauses): Update for renaming of subclass to\n+\tgomp_parallel.\n+\t(gimple_omp_parallel_clauses_ptr): Require a gomp_parallel *.\n+\t(gimple_omp_parallel_set_clauses): Likewise.\n+\t(gimple_omp_parallel_child_fn_ptr): Likewise.\n+\t(gimple_omp_parallel_set_child_fn): Likewise.\n+\t(gimple_omp_parallel_data_arg_ptr): Likewise.\n+\t(gimple_omp_parallel_set_data_arg): Likewise.\n+\t(gimple_omp_parallel_child_fn): Require a const gomp_parallel *.\n+\t(gimple_omp_parallel_data_arg): Likewise.\n+\t(gimple_omp_task_clauses): Update for renaming of subclass to\n+\tgomp_task.\n+\t(gimple_omp_task_clauses_ptr): Likewise.\n+\t(gimple_omp_task_set_clauses): Likewise.\n+\t(gimple_omp_task_child_fn): Likewise.\n+\t(gimple_omp_task_child_fn_ptr): Likewise.\n+\t(gimple_omp_task_set_child_fn): Likewise.\n+\t(gimple_omp_task_data_arg): Likewise.\n+\t(gimple_omp_task_data_arg_ptr): Likewise.\n+\t(gimple_omp_task_set_data_arg): Likewise.\n+\t(gimple_omp_taskreg_clauses): Whitespace fixes.\n+\t(gimple_omp_taskreg_clauses_ptr): Likewise.\n+\t(gimple_omp_taskreg_set_clauses): Likewise.\n+\t(gimple_omp_taskreg_child_fn): Likewise.\n+\t(gimple_omp_taskreg_child_fn_ptr): Likewise.\n+\t(gimple_omp_taskreg_set_child_fn): Likewise.\n+\t(gimple_omp_taskreg_data_arg): Likewise.\n+\t(gimple_omp_taskreg_data_arg_ptr): Likewise.\n+\t(gimple_omp_taskreg_set_data_arg): Likewise.\n+\t(gimple_omp_task_copy_fn): Update for renaming of subclass to\n+\tgomp_task.\n+\t(gimple_omp_task_copy_fn_ptr): Likewise.\n+\t(gimple_omp_task_set_copy_fn): Likewise.\n+\t(gimple_omp_task_arg_size): Likewise.\n+\t(gimple_omp_task_arg_size_ptr): Likewise.\n+\t(gimple_omp_task_set_arg_size): Likewise.\n+\t(gimple_omp_task_arg_align): Likewise.\n+\t(gimple_omp_task_arg_align_ptr): Likewise.\n+\t(gimple_omp_task_set_arg_align): Likewise.\n+\t(gimple_omp_single_clauses): Update for renaming of subclass to\n+\tgomp_single.\n+\t(gimple_omp_single_clauses_ptr): Likewise.\n+\t(gimple_omp_single_set_clauses): Likewise.\n+\t(gimple_omp_target_clauses): Update for renaming of subclass to\n+\tgomp_target.\n+\t(gimple_omp_target_clauses_ptr): Likewise.\n+\t(gimple_omp_target_set_clauses): Require a gomp_target *.\n+\t(gimple_omp_target_set_kind): Likewise.\n+\t(gimple_omp_target_child_fn_ptr): Likewise.\n+\t(gimple_omp_target_set_child_fn): Likewise.\n+\t(gimple_omp_target_data_arg_ptr): Likewise.\n+\t(gimple_omp_target_set_data_arg): Likewise.\n+\t(gimple_omp_target_child_fn): Require a const gomp_target *.\n+\t(gimple_omp_target_data_arg): Likewise.\n+\t(gimple_omp_teams_clauses): Update for renaming of subclass to\n+\tgomp_teams.\n+\t(gimple_omp_teams_clauses_ptr): Likewise.\n+\t(gimple_omp_teams_set_clauses): Require a gomp_teams *.\n+\t(gimple_omp_sections_clauses): Update for renaming of subclass to\n+\tgomp_sections.\n+\t(gimple_omp_sections_clauses_ptr): Likewise.\n+\t(gimple_omp_sections_set_clauses): Likewise.\n+\t(gimple_omp_sections_control): Likewise.\n+\t(gimple_omp_sections_control_ptr): Likewise.\n+\t(gimple_omp_sections_set_control): Likewise.\n+\t(gimple_omp_for_set_cond): Likewise.\n+\t(gimple_omp_for_cond): Likewise.\n+\t(gimple_omp_atomic_store_set_val): Require a gomp_atomic_store *.\n+\t(gimple_omp_atomic_store_val_ptr): Likewise.\n+\t(gimple_omp_atomic_load_set_lhs): Likewise.\n+\t(gimple_omp_atomic_store_val): Require a const gomp_atomic_store *.\n+\t(gimple_omp_atomic_load_lhs): Likewise.\n+\t(gimple_omp_atomic_load_rhs): Likewise.\n+\t(gimple_omp_atomic_load_lhs_ptr): Require a gomp_atomic_load *.\n+\t(gimple_omp_atomic_load_set_rhs): Likewise.\n+\t(gimple_omp_atomic_load_rhs_ptr): Likewise.\n+\t(gimple_omp_continue_control_def): Require a const gomp_continue *.\n+\t(gimple_omp_continue_control_use): Likewise.\n+\t(gimple_omp_continue_control_def_ptr): Require a gomp_continue *.\n+\t(gimple_omp_continue_set_control_def): Likewise.\n+\t(gimple_omp_continue_control_use_ptr): Likewise.\n+\t(gimple_omp_continue_set_control_use): Likewise.\n+\t(gimple_transaction_body_ptr): Require a gtransaction *.\n+\t(gimple_transaction_body): Likewise.\n+\t(gimple_transaction_label_ptr): Likewise.\n+\t(gimple_transaction_label): Require a const gtransaction *.\n+\t(gimple_transaction_subcode): Likewise.\n+\t(gimple_transaction_set_body): Require a gtransaction *.\n+\t(gimple_transaction_set_label): Likewise.\n+\t(gimple_transaction_set_subcode): Likewise.\n+\t(gimple_return_retval_ptr): Require a const greturn *.\n+\t(gimple_return_retval): Likewise.\n+\t(gimple_return_set_retval): Require a greturn *.\n+\t(gimple_expr_type): Introduce local \"call_stmt\" and use in place of\n+\t\"stmt\" for typesafety.\n+\n+\t* asan.c: Use gimple subclasses.\n+\t* auto-profile.c: Likewise.\n+\t* builtins.c: Likewise.\n+\t* builtins.h: Likewise.\n+\t* cfgexpand.c: Likewise.\n+\t* cfgloop.c: Likewise.\n+\t* cfgloopmanip.c: Likewise.\n+\t* cgraph.c: Likewise.\n+\t* cgraph.h: Likewise.\n+\t* cgraphbuild.c: Likewise.\n+\t* cgraphclones.c: Likewise.\n+\t* cgraphunit.c: Likewise.\n+\t* expr.h: Likewise.\n+\t* gimple-builder.c: Likewise.\n+\t* gimple-builder.h: Likewise.\n+\t* gimple-fold.c: Likewise.\n+\t* gimple-low.c: Likewise.\n+\t* gimple-pretty-print.c: Likewise.\n+\t* gimple-ssa-isolate-paths.c: Likewise.\n+\t* gimple-ssa-strength-reduction.c: Likewise.\n+\t* gimple-streamer-in.c: Likewise.\n+\t* gimple-streamer-out.c: Likewise.\n+\t* gimple-walk.c: Likewise.\n+\t* gimplify-me.c: Likewise.\n+\t* gimplify.c: Likewise.\n+\t* gimplify.h: Likewise.\n+\t* graphite-scop-detection.c: Likewise.\n+\t* graphite-sese-to-poly.c: Likewise.\n+\t* internal-fn.c: Likewise.\n+\t* internal-fn.def:: Likewise.\n+\t* internal-fn.h: Likewise.\n+\t* ipa-icf-gimple.c: Likewise.\n+\t* ipa-icf-gimple.h: Likewise.\n+\t* ipa-icf.c: Likewise.\n+\t* ipa-inline-analysis.c: Likewise.\n+\t* ipa-prop.c: Likewise.\n+\t* ipa-prop.h: Likewise.\n+\t* ipa-pure-const.c: Likewise.\n+\t* ipa-split.c: Likewise.\n+\t* lto-streamer-in.c: Likewise.\n+\t* lto-streamer-out.c: Likewise.\n+\t* omp-low.c: Likewise.\n+\t* predict.c: Likewise.\n+\t* sanopt.c: Likewise.\n+\t* sese.c: Likewise.\n+\t* ssa-iterators.h: Likewise.\n+\t* stmt.c: Likewise.\n+\t* trans-mem.c: Likewise.\n+\t* tree-call-cdce.c: Likewise.\n+\t* tree-cfg.c: Likewise.\n+\t* tree-cfg.h: Likewise.\n+\t* tree-cfgcleanup.c: Likewise.\n+\t* tree-chkp.c: Likewise.\n+\t* tree-chkp.h: Likewise.\n+\t* tree-complex.c: Likewise.\n+\t* tree-data-ref.c: Likewise.\n+\t* tree-dfa.c: Likewise.\n+\t* tree-eh.c: Likewise.\n+\t* tree-eh.h: Likewise.\n+\t* tree-emutls.c: Likewise.\n+\t* tree-if-conv.c: Likewise.\n+\t* tree-inline.c: Likewise.\n+\t* tree-inline.h: Likewise.\n+\t* tree-into-ssa.c: Likewise.\n+\t* tree-into-ssa.h: Likewise.\n+\t* tree-loop-distribution.c: Likewise.\n+\t* tree-nrv.c: Likewise.\n+\t* tree-object-size.c: Likewise.\n+\t* tree-outof-ssa.c: Likewise.\n+\t* tree-parloops.c: Likewise.\n+\t* tree-phinodes.c: Likewise.\n+\t* tree-phinodes.h: Likewise.\n+\t* tree-predcom.c: Likewise.\n+\t* tree-profile.c: Likewise.\n+\t* tree-scalar-evolution.c: Likewise.\n+\t* tree-scalar-evolution.h\n+\t* tree-sra.cn_function):\n+\t* tree-ssa-alias.c: Likewise.\n+\t* tree-ssa-alias.h: Likewise.\n+\t* tree-ssa-ccp.c: Likewise.\n+\t* tree-ssa-coalesce.c: Likewise.\n+\t* tree-ssa-copy.c: Likewise.\n+\t* tree-ssa-copyrename.c: Likewise.\n+\t* tree-ssa-dce.c: Likewise.\n+\t* tree-ssa-dom.c: Likewise.\n+\t* tree-ssa-forwprop.c: Likewise.\n+\t* tree-ssa-ifcombine.c: Likewise.\n+\t* tree-ssa-live.c: Likewise.\n+\t* tree-ssa-loop-im.c: Likewise.\n+\t* tree-ssa-loop-ivcanon.c: Likewise.\n+\t* tree-ssa-loop-ivopts.c: Likewise.\n+\t* tree-ssa-loop-manip.c: Likewise.\n+\t* tree-ssa-loop-niter.c: Likewise.\n+\t* tree-ssa-loop-prefetch.c: Likewise.\n+\t* tree-ssa-loop-unswitch.c: Likewise.\n+\t* tree-ssa-math-opts.c: Likewise.\n+\t* tree-ssa-operands.c: Likewise.\n+\t* tree-ssa-phiopt.c: Likewise.\n+\t* tree-ssa-phiprop.c: Likewise.\n+\t* tree-ssa-pre.c: Likewise.\n+\t* tree-ssa-propagate.c: Likewise.\n+\t* tree-ssa-propagate.h: Likewise.\n+\t* tree-ssa-reassoc.c: Likewise.\n+\t* tree-ssa-sccvn.c: Likewise.\n+\t* tree-ssa-sccvn.h: Likewise.\n+\t* tree-ssa-sink.c: Likewise.\n+\t* tree-ssa-strlen.c\n+\t* tree-ssa-structalias.c\n+\t* tree-ssa-tail-merge.c: Likewise.\n+\t* tree-ssa-ter.c: Likewise.\n+\t* tree-ssa-threadedge.c: Likewise.\n+\t* tree-ssa-threadedge.h: Likewise.\n+\t* tree-ssa-threadupdate.c: Likewise.\n+\t* tree-ssa-uncprop.c: Likewise.\n+\t* tree-ssa-uninit.c: Likewise.\n+\t* tree-ssa.c: Likewise.\n+\t* tree-stdarg.c: Likewise.\n+\t* tree-switch-conversion.c: Likewise.\n+\t* tree-tailcall.c: Likewise.\n+\t* tree-vect-data-refs.c: Likewise.\n+\t* tree-vect-generic.c: Likewise.\n+\t* tree-vect-loop-manip.c: Likewise.\n+\t* tree-vect-loop.c: Likewise.\n+\t* tree-vect-patterns.c: Likewise.\n+\t* tree-vect-slp.c: Likewise.\n+\t* tree-vect-stmts.c: Likewise.\n+\t* tree-vectorizer.h: Likewise.\n+\t* tree-vrp.c: Likewise.\n+\t* tree.c: Likewise.\n+\t* ubsan.c: Likewise.\n+\t* value-prof.c: Likewise.\n+\t* value-prof.h: Likewise.\n+\t* vtable-verify.c: Likewise.\n+\n 2014-11-19  Markus Trippelsdorf  <markus@trippelsdorf.de>\n \n \t* config/rs6000/constraints.md: Avoid signed integer overflows."}, {"sha": "fbbe3ae6aa588dfbe22fa3ce11ce3cb49f5314e9", "filename": "gcc/ChangeLog.gimple-classes", "status": "added", "additions": 4735, "deletions": 0, "changes": 4735, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2FChangeLog.gimple-classes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2FChangeLog.gimple-classes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.gimple-classes?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a"}, {"sha": "be28ede0fb8f129f0d896f3d3cf7ae5307871a66", "filename": "gcc/asan.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -493,7 +493,7 @@ has_mem_ref_been_instrumented (const asan_mem_ref *ref, tree len)\n    otherwise.  */\n \n static bool\n-get_mem_ref_of_assignment (const gimple assignment,\n+get_mem_ref_of_assignment (const gassign *assignment,\n \t\t\t   asan_mem_ref *ref,\n \t\t\t   bool *ref_is_store)\n {\n@@ -521,7 +521,7 @@ get_mem_ref_of_assignment (const gimple assignment,\n    representing a builtin call that has to do with memory access.  */\n \n static bool\n-get_mem_refs_of_builtin_call (const gimple call,\n+get_mem_refs_of_builtin_call (const gcall *call,\n \t\t\t      asan_mem_ref *src0,\n \t\t\t      tree *src0_len,\n \t\t\t      bool *src0_is_store,\n@@ -864,7 +864,8 @@ has_stmt_been_instrumented_p (gimple stmt)\n       asan_mem_ref r;\n       asan_mem_ref_init (&r, NULL, 1);\n \n-      if (get_mem_ref_of_assignment (stmt, &r, &r_is_store))\n+      if (get_mem_ref_of_assignment (as_a <gassign *> (stmt), &r,\n+\t\t\t\t     &r_is_store))\n \treturn has_mem_ref_been_instrumented (&r);\n     }\n   else if (gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))\n@@ -877,7 +878,7 @@ has_stmt_been_instrumented_p (gimple stmt)\n       tree src0_len = NULL_TREE, src1_len = NULL_TREE, dest_len = NULL_TREE;\n       bool src0_is_store = false, src1_is_store = false,\n \tdest_is_store = false, dest_is_deref = false, intercepted_p = true;\n-      if (get_mem_refs_of_builtin_call (stmt,\n+      if (get_mem_refs_of_builtin_call (as_a <gcall *> (stmt),\n \t\t\t\t\t&src0, &src0_len, &src0_is_store,\n \t\t\t\t\t&src1, &src1_len, &src1_is_store,\n \t\t\t\t\t&dest, &dest_len, &dest_is_store,\n@@ -1556,7 +1557,7 @@ create_cond_insert_point (gimple_stmt_iterator *iter,\n    pointing to initially.  */\n \n static void\n-insert_if_then_before_iter (gimple cond,\n+insert_if_then_before_iter (gcond *cond,\n \t\t\t    gimple_stmt_iterator *iter,\n \t\t\t    bool then_more_likely_p,\n \t\t\t    basic_block *then_bb,\n@@ -1901,7 +1902,7 @@ instrument_builtin_call (gimple_stmt_iterator *iter)\n     return false;\n \n   bool iter_advanced_p = false;\n-  gimple call = gsi_stmt (*iter);\n+  gcall *call = as_a <gcall *> (gsi_stmt (*iter));\n \n   gcc_checking_assert (gimple_call_builtin_p (call, BUILT_IN_NORMAL));\n \n@@ -2586,8 +2587,9 @@ asan_expand_check_ifn (gimple_stmt_iterator *iter, bool use_calls)\n       gimple_set_location (g, loc);\n \n       basic_block then_bb, fallthrough_bb;\n-      insert_if_then_before_iter (g, iter, /*then_more_likely_p=*/true,\n-\t\t\t\t &then_bb, &fallthrough_bb);\n+      insert_if_then_before_iter (as_a <gcond *> (g), iter,\n+\t\t\t\t  /*then_more_likely_p=*/true,\n+\t\t\t\t  &then_bb, &fallthrough_bb);\n       /* Note that fallthrough_bb starts with the statement that was\n \tpointed to by ITER.  */\n "}, {"sha": "7055c4ac819ee5816ada3d73dd9a59a54ad06f30", "filename": "gcc/auto-profile.c", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fauto-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fauto-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-profile.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -243,7 +243,7 @@ class function_instance\n \n   /* Read the inlined indirect call target profile for STMT and store it in\n      MAP, return the total count for all inlined indirect calls.  */\n-  gcov_type find_icall_target_map (gimple stmt, icall_target_map *map) const;\n+  gcov_type find_icall_target_map (gcall *stmt, icall_target_map *map) const;\n \n   /* Sum of counts that is used during annotation.  */\n   gcov_type total_annotated_count () const;\n@@ -311,7 +311,7 @@ class autofdo_source_profile\n \n   /* Update value profile INFO for STMT from the inlined indirect callsite.\n      Return true if INFO is updated.  */\n-  bool update_inlined_ind_target (gimple stmt, count_info *info);\n+  bool update_inlined_ind_target (gcall *stmt, count_info *info);\n \n   /* Mark LOC as annotated.  */\n   void mark_annotated (location_t loc);\n@@ -600,7 +600,7 @@ function_instance::mark_annotated (location_t loc)\n    MAP, return the total count for all inlined indirect calls.  */\n \n gcov_type\n-function_instance::find_icall_target_map (gimple stmt,\n+function_instance::find_icall_target_map (gcall *stmt,\n                                           icall_target_map *map) const\n {\n   gcov_type ret = 0;\n@@ -769,7 +769,7 @@ autofdo_source_profile::mark_annotated (location_t loc)\n    Return true if INFO is updated.  */\n \n bool\n-autofdo_source_profile::update_inlined_ind_target (gimple stmt,\n+autofdo_source_profile::update_inlined_ind_target (gcall *stmt,\n                                                    count_info *info)\n {\n   if (LOCATION_LOCUS (gimple_location (stmt)) == cfun->function_end_locus)\n@@ -963,11 +963,13 @@ static void\n afdo_indirect_call (gimple_stmt_iterator *gsi, const icall_target_map &map,\n                     bool transform)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple gs = gsi_stmt (*gsi);\n   tree callee;\n \n-  if (map.size () == 0 || gimple_code (stmt) != GIMPLE_CALL\n-      || gimple_call_fndecl (stmt) != NULL_TREE)\n+  if (map.size () == 0)\n+    return;\n+  gcall *stmt = dyn_cast <gcall *> (gs);\n+  if ((!stmt) || gimple_call_fndecl (stmt) != NULL_TREE)\n     return;\n \n   callee = gimple_call_fn (stmt);\n@@ -1085,9 +1087,11 @@ afdo_set_bb_count (basic_block bb, const stmt_set &promoted)\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     afdo_source_profile->mark_annotated (gimple_location (gsi_stmt (gsi)));\n-  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gphi_iterator gpi = gsi_start_phis (bb);\n+       !gsi_end_p (gpi);\n+       gsi_next (&gpi))\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gpi.phi ();\n       size_t i;\n       for (i = 0; i < gimple_phi_num_args (phi); i++)\n         afdo_source_profile->mark_annotated (gimple_phi_arg_location (phi, i));\n@@ -1245,7 +1249,7 @@ afdo_propagate_circuit (const bb_set &annotated_bb, edge_set *annotated_edge)\n   basic_block bb;\n   FOR_ALL_BB_FN (bb, cfun)\n   {\n-    gimple phi_stmt;\n+    gimple def_stmt;\n     tree cmp_rhs, cmp_lhs;\n     gimple cmp_stmt = last_stmt (bb);\n     edge e;\n@@ -1262,12 +1266,15 @@ afdo_propagate_circuit (const bb_set &annotated_bb, edge_set *annotated_edge)\n       continue;\n     if (!is_bb_annotated (bb, annotated_bb))\n       continue;\n-    phi_stmt = SSA_NAME_DEF_STMT (cmp_lhs);\n-    while (phi_stmt && gimple_code (phi_stmt) == GIMPLE_ASSIGN\n-           && gimple_assign_single_p (phi_stmt)\n-           && TREE_CODE (gimple_assign_rhs1 (phi_stmt)) == SSA_NAME)\n-      phi_stmt = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (phi_stmt));\n-    if (!phi_stmt || gimple_code (phi_stmt) != GIMPLE_PHI)\n+    def_stmt = SSA_NAME_DEF_STMT (cmp_lhs);\n+    while (def_stmt && gimple_code (def_stmt) == GIMPLE_ASSIGN\n+           && gimple_assign_single_p (def_stmt)\n+           && TREE_CODE (gimple_assign_rhs1 (def_stmt)) == SSA_NAME)\n+      def_stmt = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (def_stmt));\n+    if (!def_stmt)\n+      continue;\n+    gphi *phi_stmt = dyn_cast <gphi *> (def_stmt);\n+    if (!phi_stmt)\n       continue;\n     FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n@@ -1426,11 +1433,11 @@ afdo_vpt_for_early_inline (stmt_set *promoted_stmts)\n \n     for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n-        gimple stmt = gsi_stmt (gsi);\n+        gcall *stmt = dyn_cast <gcall *> (gsi_stmt (gsi));\n         /* IC_promotion and early_inline_2 is done in multiple iterations.\n            No need to promoted the stmt if its in promoted_stmts (means\n            it is already been promoted in the previous iterations).  */\n-        if (gimple_code (stmt) != GIMPLE_CALL || gimple_call_fn (stmt) == NULL\n+        if ((!stmt) || gimple_call_fn (stmt) == NULL\n             || TREE_CODE (gimple_call_fn (stmt)) == FUNCTION_DECL\n             || promoted_stmts->find (stmt) != promoted_stmts->end ())\n           continue;"}, {"sha": "7766da7c448dbb60ac6bf895e0e208af8df9cb7d", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -10953,7 +10953,7 @@ validate_arg (const_tree arg, enum tree_code code)\n    validate_arglist will then be removed.  */\n \n bool\n-validate_gimple_arglist (const_gimple call, ...)\n+validate_gimple_arglist (const gcall *call, ...)\n {\n   enum tree_code code;\n   bool res = 0;\n@@ -12811,7 +12811,7 @@ do_mpc_arg2 (tree arg0, tree arg1, tree type, int do_nonfinite,\n    call node earlier than the warning is generated.  */\n \n tree\n-fold_call_stmt (gimple stmt, bool ignore)\n+fold_call_stmt (gcall *stmt, bool ignore)\n {\n   tree ret = NULL_TREE;\n   tree fndecl = gimple_call_fndecl (stmt);"}, {"sha": "93d45cb69831b53d7157d2f029385c20911628e4", "filename": "gcc/builtins.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -77,11 +77,11 @@ extern bool avoid_folding_inline_builtin (tree);\n extern tree fold_call_expr (location_t, tree, bool);\n extern tree fold_builtin_call_array (location_t, tree, tree, int, tree *);\n extern tree fold_builtin_n (location_t, tree, tree *, int, bool);\n-extern bool validate_gimple_arglist (const_gimple, ...);\n+extern bool validate_gimple_arglist (const gcall *, ...);\n extern rtx default_expand_builtin (tree, rtx, rtx, machine_mode, int);\n extern bool fold_builtin_next_arg (tree, bool);\n extern tree do_mpc_arg2 (tree, tree, tree, int, int (*)(mpc_ptr, mpc_srcptr, mpc_srcptr, mpc_rnd_t));\n-extern tree fold_call_stmt (gimple, bool);\n+extern tree fold_call_stmt (gcall *, bool);\n extern void set_builtin_user_assembler_name (tree decl, const char *asmspec);\n extern bool is_simple_builtin (tree);\n extern bool is_inexpensive_builtin (tree);"}, {"sha": "cf919132e4d12ec889924a04b5c0cd160989c4a7", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -1,3 +1,10 @@\n+2014-11-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tMerger of git branch \"gimple-classes-v2-option-3\".\n+\t* ChangeLog.gimple-classes: New.\n+\t* c-gimplify.c (add_block_to_enclosing): Strengthen local \"stack\"\n+\tfrom being just a vec<gimple> to a vec<gbind *>.\n+\n 2014-11-18  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR sanitizer/63813"}, {"sha": "6dc9addc8bb69e1c33f859082b441ead5f8ba653", "filename": "gcc/c-family/ChangeLog.gimple-classes", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fc-family%2FChangeLog.gimple-classes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fc-family%2FChangeLog.gimple-classes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog.gimple-classes?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -0,0 +1,20 @@\n+2014-10-27  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPatch autogenerated by rename_gimple_subclasses.py from\n+\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n+\trevision 7d754b63ff2bf47226a67b2c0af5d74b54d4709f\n+\n+\t* c-gimplify.c (add_block_to_enclosing): Rename gimple subclass types.\n+\n+2014-10-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tIntroduce gimple_bind and use it for accessors.\n+\n+\t* c-gimplify.c (add_block_to_enclosing): Strengthen local \"stack\"\n+\tfrom being just a vec<gimple> to a vec<gimple_bind>.\n+\n+Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+Copying and distribution of this file, with or without modification,\n+are permitted in any medium without royalty provided the copyright\n+notice and this notice are preserved."}, {"sha": "85b42237538b665e3ab7f7cd3648511cf99bfd32", "filename": "gcc/c-family/c-gimplify.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fc-family%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fc-family%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-gimplify.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -175,8 +175,8 @@ add_block_to_enclosing (tree block)\n {\n   unsigned i;\n   tree enclosing;\n-  gimple bind;\n-  vec<gimple> stack = gimple_bind_expr_stack ();\n+  gbind *bind;\n+  vec<gbind *> stack = gimple_bind_expr_stack ();\n \n   FOR_EACH_VEC_ELT (stack, i, bind)\n     if (gimple_bind_block (bind))"}, {"sha": "45c13b48ae3caa51c1e3af73dd7d551da6c2b5fb", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 31, "deletions": 27, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -2001,7 +2001,6 @@ label_rtx_for_bb (basic_block bb ATTRIBUTE_UNUSED)\n {\n   gimple_stmt_iterator gsi;\n   tree lab;\n-  gimple lab_stmt;\n \n   if (bb->flags & BB_RTL)\n     return block_label (bb);\n@@ -2014,8 +2013,10 @@ label_rtx_for_bb (basic_block bb ATTRIBUTE_UNUSED)\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      lab_stmt = gsi_stmt (gsi);\n-      if (gimple_code (lab_stmt) != GIMPLE_LABEL)\n+      glabel *lab_stmt;\n+\n+      lab_stmt = dyn_cast <glabel *> (gsi_stmt (gsi));\n+      if (!lab_stmt)\n \tbreak;\n \n       lab = gimple_label_label (lab_stmt);\n@@ -2088,7 +2089,7 @@ maybe_cleanup_end_of_block (edge e, rtx_insn *last)\n    block and created a new one.  */\n \n static basic_block\n-expand_gimple_cond (basic_block bb, gimple stmt)\n+expand_gimple_cond (basic_block bb, gcond *stmt)\n {\n   basic_block new_bb, dest;\n   edge new_edge;\n@@ -2260,7 +2261,7 @@ mark_transaction_restart_calls (gimple stmt)\n    statement STMT.  */\n \n static void\n-expand_call_stmt (gimple stmt)\n+expand_call_stmt (gcall *stmt)\n {\n   tree exp, decl, lhs;\n   bool builtin_p;\n@@ -2947,7 +2948,7 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n \n \n static void\n-expand_asm_stmt (gimple stmt)\n+expand_asm_stmt (gasm *stmt)\n {\n   int noutputs;\n   tree outputs, tail, t;\n@@ -3274,23 +3275,23 @@ expand_gimple_stmt_1 (gimple stmt)\n \texpand_computed_goto (op0);\n       break;\n     case GIMPLE_LABEL:\n-      expand_label (gimple_label_label (stmt));\n+      expand_label (gimple_label_label (as_a <glabel *> (stmt)));\n       break;\n     case GIMPLE_NOP:\n     case GIMPLE_PREDICT:\n       break;\n     case GIMPLE_SWITCH:\n-      expand_case (stmt);\n+      expand_case (as_a <gswitch *> (stmt));\n       break;\n     case GIMPLE_ASM:\n-      expand_asm_stmt (stmt);\n+      expand_asm_stmt (as_a <gasm *> (stmt));\n       break;\n     case GIMPLE_CALL:\n-      expand_call_stmt (stmt);\n+      expand_call_stmt (as_a <gcall *> (stmt));\n       break;\n \n     case GIMPLE_RETURN:\n-      op0 = gimple_return_retval (stmt);\n+      op0 = gimple_return_retval (as_a <greturn *> (stmt));\n \n       if (op0 && op0 != error_mark_node)\n \t{\n@@ -3321,7 +3322,8 @@ expand_gimple_stmt_1 (gimple stmt)\n \n     case GIMPLE_ASSIGN:\n       {\n-\ttree lhs = gimple_assign_lhs (stmt);\n+\tgassign *assign_stmt = as_a <gassign *> (stmt);\n+\ttree lhs = gimple_assign_lhs (assign_stmt);\n \n \t/* Tree expand used to fiddle with |= and &= of two bitfield\n \t   COMPONENT_REFs here.  This can't happen with gimple, the LHS\n@@ -3331,7 +3333,7 @@ expand_gimple_stmt_1 (gimple stmt)\n \t    || get_gimple_rhs_class (gimple_expr_code (stmt))\n \t       == GIMPLE_SINGLE_RHS)\n \t  {\n-\t    tree rhs = gimple_assign_rhs1 (stmt);\n+\t    tree rhs = gimple_assign_rhs1 (assign_stmt);\n \t    gcc_assert (get_gimple_rhs_class (gimple_expr_code (stmt))\n \t\t\t== GIMPLE_SINGLE_RHS);\n \t    if (gimple_has_location (stmt) && CAN_HAVE_LOCATION_P (rhs))\n@@ -3342,31 +3344,32 @@ expand_gimple_stmt_1 (gimple stmt)\n \t      ;\n \t    else\n \t      expand_assignment (lhs, rhs,\n-\t\t\t\t gimple_assign_nontemporal_move_p (stmt));\n+\t\t\t\t gimple_assign_nontemporal_move_p (\n+\t\t\t\t   assign_stmt));\n \t  }\n \telse\n \t  {\n \t    rtx target, temp;\n-\t    bool nontemporal = gimple_assign_nontemporal_move_p (stmt);\n+\t    bool nontemporal = gimple_assign_nontemporal_move_p (assign_stmt);\n \t    struct separate_ops ops;\n \t    bool promoted = false;\n \n \t    target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n \t    if (GET_CODE (target) == SUBREG && SUBREG_PROMOTED_VAR_P (target))\n \t      promoted = true;\n \n-\t    ops.code = gimple_assign_rhs_code (stmt);\n+\t    ops.code = gimple_assign_rhs_code (assign_stmt);\n \t    ops.type = TREE_TYPE (lhs);\n \t    switch (get_gimple_rhs_class (gimple_expr_code (stmt)))\n \t      {\n \t\tcase GIMPLE_TERNARY_RHS:\n-\t\t  ops.op2 = gimple_assign_rhs3 (stmt);\n+\t\t  ops.op2 = gimple_assign_rhs3 (assign_stmt);\n \t\t  /* Fallthru */\n \t\tcase GIMPLE_BINARY_RHS:\n-\t\t  ops.op1 = gimple_assign_rhs2 (stmt);\n+\t\t  ops.op1 = gimple_assign_rhs2 (assign_stmt);\n \t\t  /* Fallthru */\n \t\tcase GIMPLE_UNARY_RHS:\n-\t\t  ops.op0 = gimple_assign_rhs1 (stmt);\n+\t\t  ops.op0 = gimple_assign_rhs1 (assign_stmt);\n \t\t  break;\n \t\tdefault:\n \t\t  gcc_unreachable ();\n@@ -3477,7 +3480,7 @@ expand_gimple_stmt (gimple stmt)\n    tailcall) and the normal result happens via a sqrt instruction.  */\n \n static basic_block\n-expand_gimple_tailcall (basic_block bb, gimple stmt, bool *can_fallthru)\n+expand_gimple_tailcall (basic_block bb, gcall *stmt, bool *can_fallthru)\n {\n   rtx_insn *last2, *last;\n   edge e;\n@@ -4982,7 +4985,7 @@ expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n   if (!gsi_end_p (gsi)\n       && gimple_code (gsi_stmt (gsi)) == GIMPLE_RETURN)\n     {\n-      gimple ret_stmt = gsi_stmt (gsi);\n+      greturn *ret_stmt = as_a <greturn *> (gsi_stmt (gsi));\n \n       gcc_assert (single_succ_p (bb));\n       gcc_assert (single_succ (bb) == EXIT_BLOCK_PTR_FOR_FN (cfun));\n@@ -5139,7 +5142,7 @@ expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n \t fixup the CFG accordingly.  */\n       if (gimple_code (stmt) == GIMPLE_COND)\n \t{\n-\t  new_bb = expand_gimple_cond (bb, stmt);\n+\t  new_bb = expand_gimple_cond (bb, as_a <gcond *> (stmt));\n \t  if (new_bb)\n \t    return new_bb;\n \t}\n@@ -5239,15 +5242,16 @@ expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n \t}\n       else\n \t{\n-\t  if (is_gimple_call (stmt)\n-\t      && gimple_call_tail_p (stmt)\n+\t  gcall *call_stmt = dyn_cast <gcall *> (stmt);\n+\t  if (call_stmt\n+\t      && gimple_call_tail_p (call_stmt)\n \t      && disable_tail_calls)\n-\t    gimple_call_set_tail (stmt, false);\n+\t    gimple_call_set_tail (call_stmt, false);\n \n-\t  if (is_gimple_call (stmt) && gimple_call_tail_p (stmt))\n+\t  if (call_stmt && gimple_call_tail_p (call_stmt))\n \t    {\n \t      bool can_fallthru;\n-\t      new_bb = expand_gimple_tailcall (bb, stmt, &can_fallthru);\n+\t      new_bb = expand_gimple_tailcall (bb, call_stmt, &can_fallthru);\n \t      if (new_bb)\n \t\t{\n \t\t  if (can_fallthru)"}, {"sha": "5c5cedc5a8cbe1465cdf07d2a07e177babdce9fd", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -587,8 +587,8 @@ find_subloop_latch_edge_by_ivs (struct loop *loop ATTRIBUTE_UNUSED, vec<edge> la\n {\n   edge e, latch = latches[0];\n   unsigned i;\n-  gimple phi;\n-  gimple_stmt_iterator psi;\n+  gphi *phi;\n+  gphi_iterator psi;\n   tree lop;\n   basic_block bb;\n \n@@ -606,7 +606,7 @@ find_subloop_latch_edge_by_ivs (struct loop *loop ATTRIBUTE_UNUSED, vec<edge> la\n      a subloop.  */\n   for (psi = gsi_start_phis (loop->header); !gsi_end_p (psi); gsi_next (&psi))\n     {\n-      phi = gsi_stmt (psi);\n+      phi = psi.phi ();\n       lop = PHI_ARG_DEF_FROM_EDGE (phi, latch);\n \n       /* Ignore the values that are not changed inside the subloop.  */"}, {"sha": "83a5dc55b149d3c3266de3dffea994c6b84b5dfd", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -701,7 +701,7 @@ create_empty_if_region_on_edge (edge entry_edge, tree condition)\n \n   basic_block cond_bb, true_bb, false_bb, join_bb;\n   edge e_true, e_false, exit_edge;\n-  gimple cond_stmt;\n+  gcond *cond_stmt;\n   tree simple_cond;\n   gimple_stmt_iterator gsi;\n \n@@ -787,7 +787,7 @@ create_empty_loop_on_edge (edge entry_edge,\n   struct loop *loop;\n   gimple_stmt_iterator gsi;\n   gimple_seq stmts;\n-  gimple cond_expr;\n+  gcond *cond_expr;\n   tree exit_test;\n   edge exit_e;\n   int prob;"}, {"sha": "5323468b8f52fb352a0d12ae0e1c67648f9f9b2d", "filename": "gcc/cgraph.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -743,7 +743,7 @@ cgraph_node::get_edge (gimple call_stmt)\n    edge, then update all components.  */\n \n void\n-cgraph_edge::set_call_stmt (gimple new_stmt, bool update_speculative)\n+cgraph_edge::set_call_stmt (gcall *new_stmt, bool update_speculative)\n {\n   tree decl;\n \n@@ -796,8 +796,8 @@ cgraph_edge::set_call_stmt (gimple new_stmt, bool update_speculative)\n \n cgraph_edge *\n symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n-\t\t     gimple call_stmt, gcov_type count, int freq,\n-\t\t     bool indir_unknown_callee)\n+\t\t\t   gcall *call_stmt, gcov_type count, int freq,\n+\t\t\t   bool indir_unknown_callee)\n {\n   cgraph_edge *edge;\n \n@@ -878,7 +878,7 @@ symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n \n cgraph_edge *\n cgraph_node::create_edge (cgraph_node *callee,\n-\t\t\t  gimple call_stmt, gcov_type count, int freq)\n+\t\t\t  gcall *call_stmt, gcov_type count, int freq)\n {\n   cgraph_edge *edge = symtab->create_edge (this, callee, call_stmt, count,\n \t\t\t\t\t   freq, false);\n@@ -914,7 +914,7 @@ cgraph_allocate_init_indirect_info (void)\n    PARAM_INDEX. */\n \n cgraph_edge *\n-cgraph_node::create_indirect_edge (gimple call_stmt, int ecf_flags,\n+cgraph_node::create_indirect_edge (gcall *call_stmt, int ecf_flags,\n \t\t\t\t   gcov_type count, int freq,\n \t\t\t\t   bool compute_indirect_info)\n {\n@@ -1291,7 +1291,7 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n \n   tree decl = gimple_call_fndecl (e->call_stmt);\n   tree lhs = gimple_call_lhs (e->call_stmt);\n-  gimple new_stmt;\n+  gcall *new_stmt;\n   gimple_stmt_iterator gsi;\n #ifdef ENABLE_CHECKING\n   cgraph_node *node;\n@@ -1300,7 +1300,7 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n   if (e->speculative)\n     {\n       cgraph_edge *e2;\n-      gimple new_stmt;\n+      gcall *new_stmt;\n       ipa_ref *ref;\n \n       e->speculative_call_info (e, e2, ref);\n@@ -1366,8 +1366,8 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n \t    {\n \t      tree dresult = gimple_call_lhs (new_stmt);\n \t      tree iresult = gimple_call_lhs (e2->call_stmt);\n-\t      gimple dbndret = chkp_retbnd_call_by_val (dresult);\n-\t      gimple ibndret = chkp_retbnd_call_by_val (iresult);\n+\t      gcall *dbndret = chkp_retbnd_call_by_val (dresult);\n+\t      gcall *ibndret = chkp_retbnd_call_by_val (iresult);\n \t      struct cgraph_edge *iedge\n \t\t= e2->caller->cgraph_node::get_edge (ibndret);\n \t      struct cgraph_edge *dedge;\n@@ -1534,7 +1534,7 @@ cgraph_update_edges_for_call_stmt_node (cgraph_node *node,\n \t\t  if (callee->decl == new_call\n \t\t      || callee->former_clone_of == new_call)\n \t\t    {\n-\t\t      e->set_call_stmt (new_stmt);\n+\t\t      e->set_call_stmt (as_a <gcall *> (new_stmt));\n \t\t      return;\n \t\t    }\n \t\t  callee = callee->clone_of;\n@@ -1563,13 +1563,14 @@ cgraph_update_edges_for_call_stmt_node (cgraph_node *node,\n       if (new_call)\n \t{\n \t  ne = node->create_edge (cgraph_node::get_create (new_call),\n-\t\t\t\t  new_stmt, count, frequency);\n+\t\t\t\t  as_a <gcall *> (new_stmt), count,\n+\t\t\t\t  frequency);\n \t  gcc_assert (ne->inline_failed);\n \t}\n     }\n   /* We only updated the call stmt; update pointer in cgraph edge..  */\n   else if (old_stmt != new_stmt)\n-    node->get_edge (old_stmt)->set_call_stmt (new_stmt);\n+    node->get_edge (old_stmt)->set_call_stmt (as_a <gcall *> (new_stmt));\n }\n \n /* Update or remove the corresponding cgraph edge if a GIMPLE_CALL"}, {"sha": "a5c5f569d678441e3bfda0a249d85c7494cf9552", "filename": "gcc/cgraph.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -785,7 +785,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n      When WHOLE_SPECULATIVE_EDGES is true, all three components of\n      speculative edge gets updated.  Otherwise we update only direct\n      call.  */\n-  void set_call_stmt_including_clones (gimple old_stmt, gimple new_stmt,\n+  void set_call_stmt_including_clones (gimple old_stmt, gcall *new_stmt,\n \t\t\t\t       bool update_speculative = true);\n \n   /* Walk the alias chain to return the function cgraph_node is alias of.\n@@ -966,21 +966,21 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n \n   /* Create edge from a given function to CALLEE in the cgraph.  */\n   cgraph_edge *create_edge (cgraph_node *callee,\n-\t\t\t    gimple call_stmt, gcov_type count,\n+\t\t\t    gcall *call_stmt, gcov_type count,\n \t\t\t    int freq);\n \n   /* Create an indirect edge with a yet-undetermined callee where the call\n      statement destination is a formal parameter of the caller with index\n      PARAM_INDEX. */\n-  cgraph_edge *create_indirect_edge (gimple call_stmt, int ecf_flags,\n+  cgraph_edge *create_indirect_edge (gcall *call_stmt, int ecf_flags,\n \t\t\t\t     gcov_type count, int freq,\n \t\t\t\t     bool compute_indirect_info = true);\n \n   /* Like cgraph_create_edge walk the clone tree and update all clones sharing\n    same function body.  If clones already have edge for OLD_STMT; only\n    update the edge same way as cgraph_set_call_stmt_including_clones does.  */\n   void create_edge_including_clones (cgraph_node *callee,\n-\t\t\t\t     gimple old_stmt, gimple stmt,\n+\t\t\t\t     gimple old_stmt, gcall *stmt,\n \t\t\t\t     gcov_type count,\n \t\t\t\t     int freq,\n \t\t\t\t     cgraph_inline_failed_t reason);\n@@ -1462,7 +1462,7 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n   /* Change field call_stmt of edge to NEW_STMT.\n      If UPDATE_SPECULATIVE and E is any component of speculative\n      edge, then update all components.  */\n-  void set_call_stmt (gimple new_stmt, bool update_speculative = true);\n+  void set_call_stmt (gcall *new_stmt, bool update_speculative = true);\n \n   /* Redirect callee of the edge to N.  The function does not update underlying\n      call expression.  */\n@@ -1495,7 +1495,7 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n \n   /* Create clone of edge in the node N represented\n      by CALL_EXPR the callgraph.  */\n-  cgraph_edge * clone (cgraph_node *n, gimple call_stmt, unsigned stmt_uid,\n+  cgraph_edge * clone (cgraph_node *n, gcall *call_stmt, unsigned stmt_uid,\n \t\t       gcov_type count_scale, int freq_scale, bool update_original);\n \n   /* Return true when call of edge can not lead to return from caller\n@@ -1525,7 +1525,7 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n   cgraph_edge *next_caller;\n   cgraph_edge *prev_callee;\n   cgraph_edge *next_callee;\n-  gimple call_stmt;\n+  gcall *call_stmt;\n   /* Additional information about an indirect call.  Not cleared when an edge\n      becomes direct.  */\n   cgraph_indirect_call_info *indirect_info;\n@@ -2052,7 +2052,7 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n      parameters of which only CALLEE can be NULL (when creating an indirect call\n      edge).  */\n   cgraph_edge *create_edge (cgraph_node *caller, cgraph_node *callee,\n-\t\t\t    gimple call_stmt, gcov_type count, int freq,\n+\t\t\t    gcall *call_stmt, gcov_type count, int freq,\n \t\t\t    bool indir_unknown_callee);\n \n   /* Put the edge onto the free list.  */"}, {"sha": "53acb43dc5632840ae0a02edb20fe829526dfc2a", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -353,25 +353,24 @@ pass_build_cgraph_edges::execute (function *fun)\n \t  if (is_gimple_debug (stmt))\n \t    continue;\n \n-\t  if (is_gimple_call (stmt))\n+\t  if (gcall *call_stmt = dyn_cast <gcall *> (stmt))\n \t    {\n \t      int freq = compute_call_stmt_bb_frequency (current_function_decl,\n \t\t\t\t\t\t\t bb);\n-\t      decl = gimple_call_fndecl (stmt);\n+\t      decl = gimple_call_fndecl (call_stmt);\n \t      if (decl)\n-\t\tnode->create_edge (cgraph_node::get_create (decl), stmt, bb->count, freq);\n-\t      else if (gimple_call_internal_p (stmt))\n+\t\tnode->create_edge (cgraph_node::get_create (decl), call_stmt, bb->count, freq);\n+\t      else if (gimple_call_internal_p (call_stmt))\n \t\t;\n \t      else\n-\t\tnode->create_indirect_edge (stmt,\n-\t\t\t\t\t    gimple_call_flags (stmt),\n+\t\tnode->create_indirect_edge (call_stmt,\n+\t\t\t\t\t    gimple_call_flags (call_stmt),\n \t\t\t\t\t    bb->count, freq);\n \t    }\n \t  node->record_stmt_references (stmt);\n-\t  if (gimple_code (stmt) == GIMPLE_OMP_PARALLEL\n-\t      && gimple_omp_parallel_child_fn (stmt))\n+\t  if (gomp_parallel *omp_par_stmt = dyn_cast <gomp_parallel *> (stmt))\n \t    {\n-\t      tree fn = gimple_omp_parallel_child_fn (stmt);\n+\t      tree fn = gimple_omp_parallel_child_fn (omp_par_stmt);\n \t      node->create_reference (cgraph_node::get_create (fn),\n \t\t\t\t      IPA_REF_ADDR, stmt);\n \t    }\n@@ -449,19 +448,19 @@ cgraph_edge::rebuild_edges (void)\n \t  gimple stmt = gsi_stmt (gsi);\n \t  tree decl;\n \n-\t  if (is_gimple_call (stmt))\n+\t  if (gcall *call_stmt = dyn_cast <gcall *> (stmt))\n \t    {\n \t      int freq = compute_call_stmt_bb_frequency (current_function_decl,\n \t\t\t\t\t\t\t bb);\n-\t      decl = gimple_call_fndecl (stmt);\n+\t      decl = gimple_call_fndecl (call_stmt);\n \t      if (decl)\n-\t\tnode->create_edge (cgraph_node::get_create (decl), stmt,\n+\t\tnode->create_edge (cgraph_node::get_create (decl), call_stmt,\n \t\t\t\t   bb->count, freq);\n-\t      else if (gimple_call_internal_p (stmt))\n+\t      else if (gimple_call_internal_p (call_stmt))\n \t\t;\n \t      else\n-\t\tnode->create_indirect_edge (stmt,\n-\t\t\t\t\t    gimple_call_flags (stmt),\n+\t\tnode->create_indirect_edge (call_stmt,\n+\t\t\t\t\t    gimple_call_flags (call_stmt),\n \t\t\t\t\t    bb->count, freq);\n \t    }\n \t  node->record_stmt_references (stmt);"}, {"sha": "086dd92ebde2d22dd23749fbca2e594e34e0a980", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -117,7 +117,7 @@ along with GCC; see the file COPYING3.  If not see\n    the callgraph.  */\n \n cgraph_edge *\n-cgraph_edge::clone (cgraph_node *n, gimple call_stmt, unsigned stmt_uid,\n+cgraph_edge::clone (cgraph_node *n, gcall *call_stmt, unsigned stmt_uid,\n \t\t    gcov_type count_scale, int freq_scale, bool update_original)\n {\n   cgraph_edge *new_edge;\n@@ -702,7 +702,8 @@ cgraph_node::find_replacement (void)\n    call.  */\n \n void\n-cgraph_node::set_call_stmt_including_clones (gimple old_stmt, gimple new_stmt,\n+cgraph_node::set_call_stmt_including_clones (gimple old_stmt,\n+\t\t\t\t\t     gcall *new_stmt,\n \t\t\t\t\t     bool update_speculative)\n {\n   cgraph_node *node;\n@@ -757,7 +758,7 @@ cgraph_node::set_call_stmt_including_clones (gimple old_stmt, gimple new_stmt,\n \n void\n cgraph_node::create_edge_including_clones (cgraph_node *callee,\n-\t\t\t\t\t   gimple old_stmt, gimple stmt,\n+\t\t\t\t\t   gimple old_stmt, gcall *stmt,\n \t\t\t\t\t   gcov_type count,\n \t\t\t\t\t   int freq,\n \t\t\t\t\t   cgraph_inline_failed_t reason)"}, {"sha": "2fd99a7c09840d5238b68ae91c05eaba7db5674f", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -1340,7 +1340,7 @@ thunk_adjust (gimple_stmt_iterator * bsi,\n \t      tree ptr, bool this_adjusting,\n \t      HOST_WIDE_INT fixed_offset, tree virtual_offset)\n {\n-  gimple stmt;\n+  gassign *stmt;\n   tree ret;\n \n   if (this_adjusting\n@@ -1516,8 +1516,8 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n       tree resdecl;\n       tree restmp = NULL;\n \n-      gimple call;\n-      gimple ret;\n+      gcall *call;\n+      greturn *ret;\n \n       if (in_lto_p)\n \tget_untransformed_body ();"}, {"sha": "0d9eb2349ccb9d074bf5a1a480bb912612b46a03", "filename": "gcc/coretypes.h", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -86,6 +86,41 @@ typedef struct gimple_statement_base *gimple;\n typedef const struct gimple_statement_base *const_gimple;\n typedef gimple gimple_seq;\n struct gimple_stmt_iterator;\n+\n+/* Forward decls for leaf gimple subclasses (for individual gimple codes).\n+   Keep this in the same order as the corresponding codes in gimple.def.  */\n+\n+struct gcond;\n+struct gdebug;\n+struct ggoto;\n+struct glabel;\n+struct gswitch;\n+struct gassign;\n+struct gasm;\n+struct gcall;\n+struct gtransaction;\n+struct greturn;\n+struct gbind;\n+struct gcatch;\n+struct geh_filter;\n+struct geh_mnt;\n+struct geh_else;\n+struct gresx;\n+struct geh_dispatch;\n+struct gphi;\n+struct gtry;\n+struct gomp_atomic_load;\n+struct gomp_atomic_store;\n+struct gomp_continue;\n+struct gomp_critical;\n+struct gomp_for;\n+struct gomp_parallel;\n+struct gomp_task;\n+struct gomp_sections;\n+struct gomp_single;\n+struct gomp_target;\n+struct gomp_teams;\n+\n union section;\n typedef union section section;\n struct gcc_options;"}, {"sha": "621c8600f9c0ae0bd97ca8c6a9008023dcf56b17", "filename": "gcc/doc/gimple.texi", "status": "modified", "additions": 47, "deletions": 32, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fdoc%2Fgimple.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fdoc%2Fgimple.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgimple.texi?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -311,111 +311,126 @@ kinds, along with their relationships to @code{GSS_} values (layouts) and\n      |   |    (no GSS layout)\n      |   |\n      |   + gimple_statement_with_ops\n-     |   |        layout: GSS_WITH_OPS\n-     |   |        Used for 5 codes: GIMPLE_COND\n-     |   |                          GIMPLE_DEBUG\n-     |   |                          GIMPLE_GOTO\n-     |   |                          GIMPLE_LABEL\n-     |   |                          GIMPLE_SWITCH\n+     |   |   |    layout: GSS_WITH_OPS\n+     |   |   |\n+     |   |   + gcond\n+     |   |   |     code: GIMPLE_COND\n+     |   |   |\n+     |   |   + gdebug\n+     |   |   |     code: GIMPLE_DEBUG\n+     |   |   |\n+     |   |   + ggoto\n+     |   |   |     code: GIMPLE_GOTO\n+     |   |   |\n+     |   |   + glabel\n+     |   |   |     code: GIMPLE_LABEL\n+     |   |   |\n+     |   |   + gswitch\n+     |   |         code: GIMPLE_SWITCH\n      |   |\n      |   + gimple_statement_with_memory_ops_base\n      |       |    layout: GSS_WITH_MEM_OPS_BASE\n      |       |\n      |       + gimple_statement_with_memory_ops\n-     |       |        layout: GSS_WITH_MEM_OPS.\n-     |       |        used for codes GIMPLE_ASSIGN and GIMPLE_RETURN.\n+     |       |   |    layout: GSS_WITH_MEM_OPS\n+     |       |   |\n+     |       |   + gassign\n+     |       |   |    code GIMPLE_ASSIGN\n+     |       |   |\n+     |       |   + greturn\n+     |       |        code GIMPLE_RETURN\n      |       |\n-     |       + gimple_statement_call\n+     |       + gcall\n      |       |        layout: GSS_CALL, code: GIMPLE_CALL\n      |       |\n-     |       + gimple_statement_asm\n+     |       + gasm\n      |       |        layout: GSS_ASM, code: GIMPLE_ASM\n      |       |\n-     |       + gimple_statement_transaction\n+     |       + gtransaction\n      |                layout: GSS_TRANSACTION, code: GIMPLE_TRANSACTION\n      |\n      + gimple_statement_omp\n      |   |    layout: GSS_OMP.  Used for code GIMPLE_OMP_SECTION\n      |   |\n-     |   + gimple_statement_omp_critical\n+     |   + gomp_critical\n      |   |        layout: GSS_OMP_CRITICAL, code: GIMPLE_OMP_CRITICAL\n      |   |\n-     |   + gimple_statement_omp_for\n+     |   + gomp_for\n      |   |        layout: GSS_OMP_FOR, code: GIMPLE_OMP_FOR\n      |   |\n-     |   + gimple_statement_omp_parallel_layout\n+     |   + gomp_parallel_layout\n      |   |   |    layout: GSS_OMP_PARALLEL_LAYOUT\n      |   |   |\n      |   |   + gimple_statement_omp_taskreg\n      |   |   |   |\n-     |   |   |   + gimple_statement_omp_parallel\n+     |   |   |   + gomp_parallel\n      |   |   |   |        code: GIMPLE_OMP_PARALLEL\n      |   |   |   |\n-     |   |   |   + gimple_statement_omp_task\n+     |   |   |   + gomp_task\n      |   |   |            code: GIMPLE_OMP_TASK\n      |   |   |\n      |   |   + gimple_statement_omp_target\n      |   |            code: GIMPLE_OMP_TARGET\n      |   |\n-     |   + gimple_statement_omp_sections\n+     |   + gomp_sections\n      |   |        layout: GSS_OMP_SECTIONS, code: GIMPLE_OMP_SECTIONS\n      |   |\n      |   + gimple_statement_omp_single_layout\n      |       |    layout: GSS_OMP_SINGLE_LAYOUT\n      |       |\n-     |       + gimple_statement_omp_single\n+     |       + gomp_single\n      |       |        code: GIMPLE_OMP_SINGLE\n      |       |\n-     |       + gimple_statement_omp_teams\n+     |       + gomp_teams\n      |                code: GIMPLE_OMP_TEAMS\n      |\n-     + gimple_statement_bind\n+     + gbind\n      |        layout: GSS_BIND, code: GIMPLE_BIND\n      |\n-     + gimple_statement_catch\n+     + gcatch\n      |        layout: GSS_CATCH, code: GIMPLE_CATCH\n      |\n-     + gimple_statement_eh_filter\n+     + geh_filter\n      |        layout: GSS_EH_FILTER, code: GIMPLE_EH_FILTER\n      |\n-     + gimple_statement_eh_else\n+     + geh_else\n      |        layout: GSS_EH_ELSE, code: GIMPLE_EH_ELSE\n      |\n-     + gimple_statement_eh_mnt\n+     + geh_mnt\n      |        layout: GSS_EH_MNT, code: GIMPLE_EH_MUST_NOT_THROW\n      |\n-     + gimple_statement_phi\n+     + gphi\n      |        layout: GSS_PHI, code: GIMPLE_PHI\n      |\n      + gimple_statement_eh_ctrl\n      |   |    layout: GSS_EH_CTRL\n      |   |\n-     |   + gimple_statement_resx\n+     |   + gresx\n      |   |        code: GIMPLE_RESX\n      |   |\n-     |   + gimple_statement_eh_dispatch\n+     |   + geh_dispatch\n      |            code: GIMPLE_EH_DISPATCH\n      |\n-     + gimple_statement_try\n+     + gtry\n      |        layout: GSS_TRY, code: GIMPLE_TRY\n      |\n      + gimple_statement_wce\n      |        layout: GSS_WCE, code: GIMPLE_WITH_CLEANUP_EXPR\n      |\n-     + gimple_statement_omp_continue\n+     + gomp_continue\n      |        layout: GSS_OMP_CONTINUE, code: GIMPLE_OMP_CONTINUE\n      |\n-     + gimple_statement_omp_atomic_load\n+     + gomp_atomic_load\n      |        layout: GSS_OMP_ATOMIC_LOAD, code: GIMPLE_OMP_ATOMIC_LOAD\n      |\n      + gimple_statement_omp_atomic_store_layout\n          |    layout: GSS_OMP_ATOMIC_STORE_LAYOUT,\n          |    code: GIMPLE_OMP_ATOMIC_STORE\n          |\n-         + gimple_statement_omp_atomic_store\n+         + gomp_atomic_store\n          |        code: GIMPLE_OMP_ATOMIC_STORE\n          |\n-         + gimple_statement_omp_return\n+         + gomp_return\n                   code: GIMPLE_OMP_RETURN\n @end smallexample\n "}, {"sha": "1b865ac39c5c42d177829be1527c66c7e1295014", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -595,7 +595,7 @@ rtx get_personality_function (tree);\n /* In stmt.c */\n \n /* Expand a GIMPLE_SWITCH statement.  */\n-extern void expand_case (gimple);\n+extern void expand_case (gswitch *);\n \n /* Like expand_case but special-case for SJLJ exception dispatching.  */\n extern void expand_sjlj_dispatch_table (rtx, vec<tree> );"}, {"sha": "a74e712c1e124b44b7c250303eca654bcdbb4383", "filename": "gcc/gdbhooks.py", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgdbhooks.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgdbhooks.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgdbhooks.py?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -455,7 +455,24 @@ def build_pretty_printer():\n                              'tree', TreePrinter)\n     pp.add_printer_for_types(['cgraph_node *'],\n                              'cgraph_node', CGraphNodePrinter)\n-    pp.add_printer_for_types(['gimple', 'gimple_statement_base *'],\n+    pp.add_printer_for_types(['gimple', 'gimple_statement_base *',\n+\n+                              # Keep this in the same order as gimple.def:\n+                              'gimple_cond', 'const_gimple_cond',\n+                              'gimple_statement_cond *',\n+                              'gimple_debug', 'const_gimple_debug',\n+                              'gimple_statement_debug *',\n+                              'gimple_label', 'const_gimple_label',\n+                              'gimple_statement_label *',\n+                              'gimple_switch', 'const_gimple_switch',\n+                              'gimple_statement_switch *',\n+                              'gimple_assign', 'const_gimple_assign',\n+                              'gimple_statement_assign *',\n+                              'gimple_bind', 'const_gimple_bind',\n+                              'gimple_statement_bind *',\n+                              'gimple_phi', 'const_gimple_phi',\n+                              'gimple_statement_phi *'],\n+\n                              'gimple',\n                              GimplePrinter)\n     pp.add_printer_for_types(['basic_block', 'basic_block_def *'],"}, {"sha": "c5c9938b81a11ee0764d1dcd5d4d964b5a5e24d9", "filename": "gcc/gimple-builder.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-builder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-builder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-builder.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -60,7 +60,7 @@ get_expr_type (enum tree_code code, tree op)\n    the expression code for the RHS.  OP1 is the first operand and VAL\n    is an integer value to be used as the second operand.  */\n \n-gimple\n+gassign *\n build_assign (enum tree_code code, tree op1, int val, tree lhs)\n {\n   tree op2 = build_int_cst (TREE_TYPE (op1), val);\n@@ -69,7 +69,7 @@ build_assign (enum tree_code code, tree op1, int val, tree lhs)\n   return gimple_build_assign_with_ops (code, lhs, op1, op2);\n }\n \n-gimple\n+gassign *\n build_assign (enum tree_code code, gimple g, int val, tree lhs )\n {\n   return build_assign (code, gimple_assign_lhs (g), val, lhs);\n@@ -84,27 +84,27 @@ build_assign (enum tree_code code, gimple g, int val, tree lhs )\n    in normal form depending on the type of builder invoking this\n    function.  */\n \n-gimple\n+gassign *\n build_assign (enum tree_code code, tree op1, tree op2, tree lhs)\n {\n   if (lhs == NULL_TREE)\n     lhs = make_ssa_name (get_expr_type (code, op1), NULL);\n   return gimple_build_assign_with_ops (code, lhs, op1, op2);\n }\n \n-gimple\n+gassign *\n build_assign (enum tree_code code, gimple op1, tree op2, tree lhs)\n {\n   return build_assign (code, gimple_assign_lhs (op1), op2, lhs);\n }\n \n-gimple\n+gassign *\n build_assign (enum tree_code code, tree op1, gimple op2, tree lhs)\n {\n   return build_assign (code, op1, gimple_assign_lhs (op2), lhs);\n }\n \n-gimple\n+gassign *\n build_assign (enum tree_code code, gimple op1, gimple op2, tree lhs)\n {\n   return build_assign (code, gimple_assign_lhs (op1), gimple_assign_lhs (op2),\n@@ -115,15 +115,15 @@ build_assign (enum tree_code code, gimple op1, gimple op2, tree lhs)\n /* Create and return a type cast assignment. This creates a NOP_EXPR\n    that converts OP to TO_TYPE.  */\n \n-gimple\n+gassign *\n build_type_cast (tree to_type, tree op, tree lhs)\n {\n   if (lhs == NULL_TREE)\n     lhs = make_ssa_name (to_type, NULL);\n   return gimple_build_assign_with_ops (NOP_EXPR, lhs, op);\n }\n \n-gimple\n+gassign *\n build_type_cast (tree to_type, gimple op, tree lhs)\n {\n   return build_type_cast (to_type, gimple_assign_lhs (op), lhs);"}, {"sha": "f8ec23a684915dffca79545e5ac4b78d0b67f521", "filename": "gcc/gimple-builder.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-builder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-builder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-builder.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -21,13 +21,13 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_GIMPLE_BUILDER_H\n #define GCC_GIMPLE_BUILDER_H\n \n-gimple build_assign (enum tree_code, tree, int, tree lhs = NULL_TREE);\n-gimple build_assign (enum tree_code, gimple, int, tree lhs = NULL_TREE);\n-gimple build_assign (enum tree_code, tree, tree, tree lhs = NULL_TREE);\n-gimple build_assign (enum tree_code, gimple, tree, tree lhs = NULL_TREE);\n-gimple build_assign (enum tree_code, tree, gimple, tree lhs = NULL_TREE);\n-gimple build_assign (enum tree_code, gimple, gimple, tree lhs = NULL_TREE);\n-gimple build_type_cast (tree, tree, tree lhs = NULL_TREE);\n-gimple build_type_cast (tree, gimple, tree lhs = NULL_TREE);\n+gassign *build_assign (enum tree_code, tree, int, tree lhs = NULL_TREE);\n+gassign *build_assign (enum tree_code, gimple, int, tree lhs = NULL_TREE);\n+gassign *build_assign (enum tree_code, tree, tree, tree lhs = NULL_TREE);\n+gassign *build_assign (enum tree_code, gimple, tree, tree lhs = NULL_TREE);\n+gassign *build_assign (enum tree_code, tree, gimple, tree lhs = NULL_TREE);\n+gassign *build_assign (enum tree_code, gimple, gimple, tree lhs = NULL_TREE);\n+gassign *build_type_cast (tree, tree, tree lhs = NULL_TREE);\n+gassign *build_type_cast (tree, gimple, tree lhs = NULL_TREE);\n \n #endif /* GCC_GIMPLE_BUILDER_H */"}, {"sha": "8e0c9e055ef82e82cd2a1397586a455fa923a3e2", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -545,7 +545,7 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n    assumed that the operands have been previously folded.  */\n \n static bool\n-fold_gimple_cond (gimple stmt)\n+fold_gimple_cond (gcond *stmt)\n {\n   tree result = fold_binary_loc (gimple_location (stmt),\n \t\t\t     gimple_cond_code (stmt),\n@@ -2024,7 +2024,7 @@ static bool\n gimple_fold_builtin_snprintf_chk (gimple_stmt_iterator *gsi,\n \t\t\t\t  enum built_in_function fcode)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gcall *stmt = as_a <gcall *> (gsi_stmt (*gsi));\n   tree dest, size, len, fn, fmt, flag;\n   const char *fmt_str;\n \n@@ -2104,7 +2104,7 @@ static bool\n gimple_fold_builtin_sprintf_chk (gimple_stmt_iterator *gsi,\n \t\t\t\t enum built_in_function fcode)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gcall *stmt = as_a <gcall *> (gsi_stmt (*gsi));\n   tree dest, size, len, fn, fmt, flag;\n   const char *fmt_str;\n   unsigned nargs = gimple_call_num_args (stmt);\n@@ -2327,7 +2327,7 @@ gimple_fold_builtin_sprintf (gimple_stmt_iterator *gsi)\n static bool\n gimple_fold_builtin_snprintf (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gcall *stmt = as_a <gcall *> (gsi_stmt (*gsi));\n   tree dest = gimple_call_arg (stmt, 0);\n   tree destsize = gimple_call_arg (stmt, 1);\n   tree fmt = gimple_call_arg (stmt, 2);\n@@ -2477,7 +2477,7 @@ gimple_fold_builtin_strlen (gimple_stmt_iterator *gsi)\n static bool\n gimple_fold_builtin (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gcall *stmt = as_a <gcall *>(gsi_stmt (*gsi));\n   tree callee = gimple_call_fndecl (stmt);\n \n   /* Give up for always_inline inline builtins until they are\n@@ -2621,7 +2621,7 @@ arith_overflowed_p (enum tree_code code, const_tree type,\n static bool\n gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gcall *stmt = as_a <gcall *> (gsi_stmt (*gsi));\n   tree callee;\n   bool changed = false;\n   unsigned i;\n@@ -2931,7 +2931,7 @@ replace_stmt_with_simplification (gimple_stmt_iterator *gsi,\n \t  && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[2])))\n     return false;\n \n-  if (gimple_code (stmt) == GIMPLE_COND)\n+  if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n     {\n       gcc_assert (rcode.is_tree_code ());\n       if (TREE_CODE_CLASS ((enum tree_code)rcode) == tcc_comparison\n@@ -2941,24 +2941,24 @@ replace_stmt_with_simplification (gimple_stmt_iterator *gsi,\n \t      || !operation_could_trap_p (rcode,\n \t\t\t\t\t  FLOAT_TYPE_P (TREE_TYPE (ops[0])),\n \t\t\t\t\t  false, NULL_TREE)))\n-\tgimple_cond_set_condition (stmt, rcode, ops[0], ops[1]);\n+\tgimple_cond_set_condition (cond_stmt, rcode, ops[0], ops[1]);\n       else if (rcode == SSA_NAME)\n-\tgimple_cond_set_condition (stmt, NE_EXPR, ops[0],\n+\tgimple_cond_set_condition (cond_stmt, NE_EXPR, ops[0],\n \t\t\t\t   build_zero_cst (TREE_TYPE (ops[0])));\n       else if (rcode == INTEGER_CST)\n \t{\n \t  if (integer_zerop (ops[0]))\n-\t    gimple_cond_make_false (stmt);\n+\t    gimple_cond_make_false (cond_stmt);\n \t  else\n-\t    gimple_cond_make_true (stmt);\n+\t    gimple_cond_make_true (cond_stmt);\n \t}\n       else if (!inplace)\n \t{\n \t  tree res = maybe_push_res_to_seq (rcode, boolean_type_node,\n \t\t\t\t\t    ops, seq);\n \t  if (!res)\n \t    return false;\n-\t  gimple_cond_set_condition (stmt, NE_EXPR, res,\n+\t  gimple_cond_set_condition (cond_stmt, NE_EXPR, res,\n \t\t\t\t     build_zero_cst (TREE_TYPE (res)));\n \t}\n       else\n@@ -3149,17 +3149,18 @@ fold_stmt_1 (gimple_stmt_iterator *gsi, bool inplace, tree (*valueize) (tree))\n       }\n     case GIMPLE_ASM:\n       {\n-\tfor (i = 0; i < gimple_asm_noutputs (stmt); ++i)\n+\tgasm *asm_stmt = as_a <gasm *> (stmt);\n+\tfor (i = 0; i < gimple_asm_noutputs (asm_stmt); ++i)\n \t  {\n-\t    tree link = gimple_asm_output_op (stmt, i);\n+\t    tree link = gimple_asm_output_op (asm_stmt, i);\n \t    tree op = TREE_VALUE (link);\n \t    if (REFERENCE_CLASS_P (op)\n \t\t&& maybe_canonicalize_mem_ref_addr (&TREE_VALUE (link)))\n \t      changed = true;\n \t  }\n-\tfor (i = 0; i < gimple_asm_ninputs (stmt); ++i)\n+\tfor (i = 0; i < gimple_asm_ninputs (asm_stmt); ++i)\n \t  {\n-\t    tree link = gimple_asm_input_op (stmt, i);\n+\t    tree link = gimple_asm_input_op (asm_stmt, i);\n \t    tree op = TREE_VALUE (link);\n \t    if ((REFERENCE_CLASS_P (op)\n \t\t || TREE_CODE (op) == ADDR_EXPR)\n@@ -3238,7 +3239,7 @@ fold_stmt_1 (gimple_stmt_iterator *gsi, bool inplace, tree (*valueize) (tree))\n       }\n \n     case GIMPLE_COND:\n-      changed |= fold_gimple_cond (stmt);\n+      changed |= fold_gimple_cond (as_a <gcond *> (stmt));\n       break;\n \n     case GIMPLE_CALL:\n@@ -3248,17 +3249,18 @@ fold_stmt_1 (gimple_stmt_iterator *gsi, bool inplace, tree (*valueize) (tree))\n     case GIMPLE_ASM:\n       /* Fold *& in asm operands.  */\n       {\n+\tgasm *asm_stmt = as_a <gasm *> (stmt);\n \tsize_t noutputs;\n \tconst char **oconstraints;\n \tconst char *constraint;\n \tbool allows_mem, allows_reg;\n \n-\tnoutputs = gimple_asm_noutputs (stmt);\n+\tnoutputs = gimple_asm_noutputs (asm_stmt);\n \toconstraints = XALLOCAVEC (const char *, noutputs);\n \n-\tfor (i = 0; i < gimple_asm_noutputs (stmt); ++i)\n+\tfor (i = 0; i < gimple_asm_noutputs (asm_stmt); ++i)\n \t  {\n-\t    tree link = gimple_asm_output_op (stmt, i);\n+\t    tree link = gimple_asm_output_op (asm_stmt, i);\n \t    tree op = TREE_VALUE (link);\n \t    oconstraints[i]\n \t      = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (link)));\n@@ -3269,9 +3271,9 @@ fold_stmt_1 (gimple_stmt_iterator *gsi, bool inplace, tree (*valueize) (tree))\n \t\tchanged = true;\n \t      }\n \t  }\n-\tfor (i = 0; i < gimple_asm_ninputs (stmt); ++i)\n+\tfor (i = 0; i < gimple_asm_ninputs (asm_stmt); ++i)\n \t  {\n-\t    tree link = gimple_asm_input_op (stmt, i);\n+\t    tree link = gimple_asm_input_op (asm_stmt, i);\n \t    tree op = TREE_VALUE (link);\n \t    constraint\n \t      = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (link)));\n@@ -4683,6 +4685,7 @@ gimple_fold_stmt_to_constant_1 (gimple stmt, tree (*valueize) (tree),\n     case GIMPLE_CALL:\n       {\n \ttree fn;\n+\tgcall *call_stmt = as_a <gcall *> (stmt);\n \n \tif (gimple_call_internal_p (stmt))\n \t  {\n@@ -4747,14 +4750,15 @@ gimple_fold_stmt_to_constant_1 (gimple stmt, tree (*valueize) (tree),\n \t    for (i = 0; i < gimple_call_num_args (stmt); ++i)\n \t      args[i] = (*valueize) (gimple_call_arg (stmt, i));\n \t    call = build_call_array_loc (loc,\n-\t\t\t\t\t gimple_call_return_type (stmt),\n+\t\t\t\t\t gimple_call_return_type (call_stmt),\n \t\t\t\t\t fn, gimple_call_num_args (stmt), args);\n \t    retval = fold_call_expr (EXPR_LOCATION (call), call, false);\n \t    if (retval)\n \t      {\n \t\t/* fold_call_expr wraps the result inside a NOP_EXPR.  */\n \t\tSTRIP_NOPS (retval);\n-\t\tretval = fold_convert (gimple_call_return_type (stmt), retval);\n+\t\tretval = fold_convert (gimple_call_return_type (call_stmt),\n+\t\t\t\t       retval);\n \t      }\n \t    return retval;\n \t  }"}, {"sha": "e7a4658dbd4f151492455dbe497e4e53fe5f532d", "filename": "gcc/gimple-iterator.c", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -639,6 +639,19 @@ gsi_for_stmt (gimple stmt)\n   return i;\n }\n \n+/* Finds iterator for PHI.  */\n+\n+gphi_iterator\n+gsi_for_phi (gphi *phi)\n+{\n+  gphi_iterator i;\n+  basic_block bb = gimple_bb (phi);\n+\n+  i = gsi_start_phis (bb);\n+  i.ptr = phi;\n+\n+  return i;\n+}\n \n /* Move the statement at FROM so it comes right after the statement at TO.  */\n \n@@ -899,9 +912,17 @@ gsi_commit_one_edge_insert (edge e, basic_block *new_bb)\n \n /* Returns iterator at the start of the list of phi nodes of BB.  */\n \n-gimple_stmt_iterator\n+gphi_iterator\n gsi_start_phis (basic_block bb)\n {\n   gimple_seq *pseq = phi_nodes_ptr (bb);\n-  return gsi_start_1 (pseq);\n+\n+  /* Adapted from gsi_start_1. */\n+  gphi_iterator i;\n+\n+  i.ptr = gimple_seq_first (*pseq);\n+  i.seq = pseq;\n+  i.bb = i.ptr ? gimple_bb (i.ptr) : NULL;\n+\n+  return i;\n }"}, {"sha": "fb6cc0718fbc8092aa9eeec909c23d22cf3f3b9c", "filename": "gcc/gimple-iterator.h", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -34,6 +34,15 @@ struct gimple_stmt_iterator\n   gimple_seq *seq;\n   basic_block bb;\n };\n+\n+/* Iterator over GIMPLE_PHI statements.  */\n+struct gphi_iterator : public gimple_stmt_iterator\n+{\n+  gphi *phi () const\n+  {\n+    return as_a <gphi *> (ptr);\n+  }\n+};\n  \n enum gsi_iterator_update\n {\n@@ -70,6 +79,7 @@ extern void gsi_insert_after (gimple_stmt_iterator *, gimple,\n \t\t\t      enum gsi_iterator_update);\n extern bool gsi_remove (gimple_stmt_iterator *, bool);\n extern gimple_stmt_iterator gsi_for_stmt (gimple);\n+extern gphi_iterator gsi_for_phi (gphi *);\n extern void gsi_move_after (gimple_stmt_iterator *, gimple_stmt_iterator *);\n extern void gsi_move_before (gimple_stmt_iterator *, gimple_stmt_iterator *);\n extern void gsi_move_to_bb_end (gimple_stmt_iterator *, basic_block);\n@@ -79,7 +89,7 @@ extern basic_block gsi_insert_on_edge_immediate (edge, gimple);\n extern basic_block gsi_insert_seq_on_edge_immediate (edge, gimple_seq);\n extern void gsi_commit_edge_inserts (void);\n extern void gsi_commit_one_edge_insert (edge, basic_block *);\n-extern gimple_stmt_iterator gsi_start_phis (basic_block);\n+extern gphi_iterator gsi_start_phis (basic_block);\n \n /* Return a new iterator pointing to GIMPLE_SEQ's first statement.  */\n \n@@ -284,14 +294,14 @@ gsi_last_nondebug_bb (basic_block bb)\n /* Iterates I statement iterator to the next non-virtual statement.  */\n \n static inline void\n-gsi_next_nonvirtual_phi (gimple_stmt_iterator *i)\n+gsi_next_nonvirtual_phi (gphi_iterator *i)\n {\n-  gimple phi;\n+  gphi *phi;\n \n   if (gsi_end_p (*i))\n     return;\n \n-  phi = gsi_stmt (*i);\n+  phi = i->phi ();\n   gcc_assert (phi != NULL);\n \n   while (virtual_operand_p (gimple_phi_result (phi)))\n@@ -301,7 +311,7 @@ gsi_next_nonvirtual_phi (gimple_stmt_iterator *i)\n       if (gsi_end_p (*i))\n \treturn;\n \n-      phi = gsi_stmt (*i);\n+      phi = i->phi ();\n     }\n }\n "}, {"sha": "402a921ed0bbe441bc5839d4fb858942b7fdbe15", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -67,7 +67,7 @@ along with GCC; see the file COPYING3.  If not see\n struct return_statements_t\n {\n   tree label;\n-  gimple stmt;\n+  greturn *stmt;\n };\n typedef struct return_statements_t return_statements_t;\n \n@@ -305,8 +305,11 @@ lower_stmt (gimple_stmt_iterator *gsi, struct lower_data *data)\n       return;\n \n     case GIMPLE_EH_ELSE:\n-      lower_sequence (gimple_eh_else_n_body_ptr (stmt), data);\n-      lower_sequence (gimple_eh_else_e_body_ptr (stmt), data);\n+      {\n+\tgeh_else *eh_else_stmt = as_a <geh_else *> (stmt);\n+\tlower_sequence (gimple_eh_else_n_body_ptr (eh_else_stmt), data);\n+\tlower_sequence (gimple_eh_else_e_body_ptr (eh_else_stmt), data);\n+      }\n       break;\n \n     case GIMPLE_NOP:\n@@ -378,7 +381,9 @@ lower_stmt (gimple_stmt_iterator *gsi, struct lower_data *data)\n       return;\n \n     case GIMPLE_TRANSACTION:\n-      lower_sequence (gimple_transaction_body_ptr (stmt), data);\n+      lower_sequence (gimple_transaction_body_ptr (\n+\t\t\tas_a <gtransaction *> (stmt)),\n+\t\t      data);\n       break;\n \n     default:\n@@ -395,7 +400,7 @@ static void\n lower_gimple_bind (gimple_stmt_iterator *gsi, struct lower_data *data)\n {\n   tree old_block = data->block;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gbind *stmt = as_a <gbind *> (gsi_stmt (*gsi));\n   tree new_block = gimple_bind_block (stmt);\n \n   if (new_block)\n@@ -468,7 +473,9 @@ lower_try_catch (gimple_stmt_iterator *gsi, struct lower_data *data)\n       for (; !gsi_end_p (i); gsi_next (&i))\n \t{\n \t  data->cannot_fallthru = false;\n-\t  lower_sequence (gimple_catch_handler_ptr (gsi_stmt (i)), data);\n+\t  lower_sequence (gimple_catch_handler_ptr (\n+                            as_a <gcatch *> (gsi_stmt (i))),\n+\t\t\t  data);\n \t  if (!data->cannot_fallthru)\n \t    cannot_fallthru = false;\n \t}\n@@ -509,7 +516,7 @@ lower_try_catch (gimple_stmt_iterator *gsi, struct lower_data *data)\n    This is a subroutine of gimple_stmt_may_fallthru.  */\n \n static bool\n-gimple_try_catch_may_fallthru (gimple stmt)\n+gimple_try_catch_may_fallthru (gtry *stmt)\n {\n   gimple_stmt_iterator i;\n \n@@ -530,7 +537,8 @@ gimple_try_catch_may_fallthru (gimple stmt)\n \t through iff any of the catch bodies falls through.  */\n       for (; !gsi_end_p (i); gsi_next (&i))\n \t{\n-\t  if (gimple_seq_may_fallthru (gimple_catch_handler (gsi_stmt (i))))\n+\t  if (gimple_seq_may_fallthru (gimple_catch_handler (\n+\t\t\t\t\t as_a <gcatch *> (gsi_stmt (i)))))\n \t    return true;\n \t}\n       return false;\n@@ -589,11 +597,12 @@ gimple_stmt_may_fallthru (gimple stmt)\n       return false;\n \n     case GIMPLE_BIND:\n-      return gimple_seq_may_fallthru (gimple_bind_body (stmt));\n+      return gimple_seq_may_fallthru (\n+\t       gimple_bind_body (as_a <gbind *> (stmt)));\n \n     case GIMPLE_TRY:\n       if (gimple_try_kind (stmt) == GIMPLE_TRY_CATCH)\n-        return gimple_try_catch_may_fallthru (stmt);\n+        return gimple_try_catch_may_fallthru (as_a <gtry *> (stmt));\n \n       /* It must be a GIMPLE_TRY_FINALLY.  */\n \n@@ -608,8 +617,12 @@ gimple_stmt_may_fallthru (gimple stmt)\n \t      && gimple_seq_may_fallthru (gimple_try_cleanup (stmt)));\n \n     case GIMPLE_EH_ELSE:\n-      return (gimple_seq_may_fallthru (gimple_eh_else_n_body (stmt))\n-\t      || gimple_seq_may_fallthru (gimple_eh_else_e_body (stmt)));\n+      {\n+\tgeh_else *eh_else_stmt = as_a <geh_else *> (stmt);\n+\treturn (gimple_seq_may_fallthru (gimple_eh_else_n_body (eh_else_stmt))\n+\t\t|| gimple_seq_may_fallthru (gimple_eh_else_e_body (\n+\t\t\t\t\t      eh_else_stmt)));\n+      }\n \n     case GIMPLE_CALL:\n       /* Functions that do not return do not fall through.  */\n@@ -635,7 +648,7 @@ gimple_seq_may_fallthru (gimple_seq seq)\n static void\n lower_gimple_return (gimple_stmt_iterator *gsi, struct lower_data *data)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  greturn *stmt = as_a <greturn *> (gsi_stmt (*gsi));\n   gimple t;\n   int i;\n   return_statements_t tmp_rs;"}, {"sha": "39e25721c21733e2802b4f7f527e024b7e3b0d60", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 102, "deletions": 79, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -271,7 +271,7 @@ dump_gimple_fmt (pretty_printer *buffer, int spc, int flags,\n    assignment GS.  BUFFER, SPC and FLAGS are as in pp_gimple_stmt_1.  */\n \n static void\n-dump_unary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_unary_rhs (pretty_printer *buffer, gassign *gs, int spc, int flags)\n {\n   enum tree_code rhs_code = gimple_assign_rhs_code (gs);\n   tree lhs = gimple_assign_lhs (gs);\n@@ -355,7 +355,7 @@ dump_unary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n    assignment GS.  BUFFER, SPC and FLAGS are as in pp_gimple_stmt_1.  */\n \n static void\n-dump_binary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_binary_rhs (pretty_printer *buffer, gassign *gs, int spc, int flags)\n {\n   const char *p;\n   enum tree_code code = gimple_assign_rhs_code (gs);\n@@ -411,7 +411,7 @@ dump_binary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n    assignment GS.  BUFFER, SPC and FLAGS are as in pp_gimple_stmt_1.  */\n \n static void\n-dump_ternary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_ternary_rhs (pretty_printer *buffer, gassign *gs, int spc, int flags)\n {\n   const char *p;\n   enum tree_code code = gimple_assign_rhs_code (gs);\n@@ -506,7 +506,7 @@ dump_ternary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n    pp_gimple_stmt_1.  */\n \n static void\n-dump_gimple_assign (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_assign (pretty_printer *buffer, gassign *gs, int spc, int flags)\n {\n   if (flags & TDF_RAW)\n     {\n@@ -565,7 +565,7 @@ dump_gimple_assign (pretty_printer *buffer, gimple gs, int spc, int flags)\n    pp_gimple_stmt_1.  */\n \n static void\n-dump_gimple_return (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_return (pretty_printer *buffer, greturn *gs, int spc, int flags)\n {\n   tree t, t2;\n \n@@ -595,7 +595,7 @@ dump_gimple_return (pretty_printer *buffer, gimple gs, int spc, int flags)\n    dump_gimple_call.  */\n \n static void\n-dump_gimple_call_args (pretty_printer *buffer, gimple gs, int flags)\n+dump_gimple_call_args (pretty_printer *buffer, gcall *gs, int flags)\n {\n   size_t i;\n \n@@ -668,7 +668,7 @@ pp_points_to_solution (pretty_printer *buffer, struct pt_solution *pt)\n    pp_gimple_stmt_1.  */\n \n static void\n-dump_gimple_call (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_call (pretty_printer *buffer, gcall *gs, int spc, int flags)\n {\n   tree lhs = gimple_call_lhs (gs);\n   tree fn = gimple_call_fn (gs);\n@@ -801,7 +801,8 @@ dump_gimple_call (pretty_printer *buffer, gimple gs, int spc, int flags)\n    pp_gimple_stmt_1.  */\n \n static void\n-dump_gimple_switch (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_switch (pretty_printer *buffer, gswitch *gs, int spc,\n+\t\t    int flags)\n {\n   unsigned int i;\n \n@@ -834,7 +835,7 @@ dump_gimple_switch (pretty_printer *buffer, gimple gs, int spc, int flags)\n    pp_gimple_stmt_1.  */\n \n static void\n-dump_gimple_cond (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_cond (pretty_printer *buffer, gcond *gs, int spc, int flags)\n {\n   if (flags & TDF_RAW)\n     dump_gimple_fmt (buffer, spc, flags, \"%G <%s, %T, %T, %T, %T>\", gs,\n@@ -878,7 +879,7 @@ dump_gimple_cond (pretty_printer *buffer, gimple gs, int spc, int flags)\n    TDF_* in dumpfils.h).  */\n \n static void\n-dump_gimple_label (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_label (pretty_printer *buffer, glabel *gs, int spc, int flags)\n {\n   tree label = gimple_label_label (gs);\n   if (flags & TDF_RAW)\n@@ -899,7 +900,7 @@ dump_gimple_label (pretty_printer *buffer, gimple gs, int spc, int flags)\n    TDF_* in dumpfile.h).  */\n \n static void\n-dump_gimple_goto (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_goto (pretty_printer *buffer, ggoto *gs, int spc, int flags)\n {\n   tree label = gimple_goto_dest (gs);\n   if (flags & TDF_RAW)\n@@ -914,7 +915,7 @@ dump_gimple_goto (pretty_printer *buffer, gimple gs, int spc, int flags)\n    TDF_* in dumpfile.h).  */\n \n static void\n-dump_gimple_bind (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_bind (pretty_printer *buffer, gbind *gs, int spc, int flags)\n {\n   if (flags & TDF_RAW)\n     dump_gimple_fmt (buffer, spc, flags, \"%G <\", gs);\n@@ -947,7 +948,7 @@ dump_gimple_bind (pretty_printer *buffer, gimple gs, int spc, int flags)\n    dumpfile.h).  */\n \n static void\n-dump_gimple_try (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_try (pretty_printer *buffer, gtry *gs, int spc, int flags)\n {\n   if (flags & TDF_RAW)\n     {\n@@ -1003,7 +1004,7 @@ dump_gimple_try (pretty_printer *buffer, gimple gs, int spc, int flags)\n    dumpfile.h).  */\n \n static void\n-dump_gimple_catch (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_catch (pretty_printer *buffer, gcatch *gs, int spc, int flags)\n {\n   if (flags & TDF_RAW)\n       dump_gimple_fmt (buffer, spc, flags, \"%G <%T, %+CATCH <%S>%->\", gs,\n@@ -1019,7 +1020,8 @@ dump_gimple_catch (pretty_printer *buffer, gimple gs, int spc, int flags)\n    dumpfile.h).  */\n \n static void\n-dump_gimple_eh_filter (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_eh_filter (pretty_printer *buffer, geh_filter *gs, int spc,\n+\t\t       int flags)\n {\n   if (flags & TDF_RAW)\n     dump_gimple_fmt (buffer, spc, flags, \"%G <%T, %+FAILURE <%S>%->\", gs,\n@@ -1035,8 +1037,8 @@ dump_gimple_eh_filter (pretty_printer *buffer, gimple gs, int spc, int flags)\n /* Dump a GIMPLE_EH_MUST_NOT_THROW tuple.  */\n \n static void\n-dump_gimple_eh_must_not_throw (pretty_printer *buffer, gimple gs,\n-\t\t\t       int spc, int flags)\n+dump_gimple_eh_must_not_throw (pretty_printer *buffer,\n+\t\t\t       geh_mnt *gs, int spc, int flags)\n {\n   if (flags & TDF_RAW)\n     dump_gimple_fmt (buffer, spc, flags, \"%G <%T>\", gs,\n@@ -1052,7 +1054,8 @@ dump_gimple_eh_must_not_throw (pretty_printer *buffer, gimple gs,\n    dumpfile.h).  */\n \n static void\n-dump_gimple_eh_else (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_eh_else (pretty_printer *buffer, geh_else *gs, int spc,\n+\t\t     int flags)\n {\n   if (flags & TDF_RAW)\n     dump_gimple_fmt (buffer, spc, flags,\n@@ -1070,7 +1073,7 @@ dump_gimple_eh_else (pretty_printer *buffer, gimple gs, int spc, int flags)\n    dumpfile.h).  */\n \n static void\n-dump_gimple_resx (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_resx (pretty_printer *buffer, gresx *gs, int spc, int flags)\n {\n   if (flags & TDF_RAW)\n     dump_gimple_fmt (buffer, spc, flags, \"%G <%d>\", gs,\n@@ -1082,7 +1085,7 @@ dump_gimple_resx (pretty_printer *buffer, gimple gs, int spc, int flags)\n /* Dump a GIMPLE_EH_DISPATCH tuple on the pretty_printer BUFFER.  */\n \n static void\n-dump_gimple_eh_dispatch (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_eh_dispatch (pretty_printer *buffer, geh_dispatch *gs, int spc, int flags)\n {\n   if (flags & TDF_RAW)\n     dump_gimple_fmt (buffer, spc, flags, \"%G <%d>\", gs,\n@@ -1097,7 +1100,7 @@ dump_gimple_eh_dispatch (pretty_printer *buffer, gimple gs, int spc, int flags)\n    in dumpfile.h).  */\n \n static void\n-dump_gimple_debug (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_debug (pretty_printer *buffer, gdebug *gs, int spc, int flags)\n {\n   switch (gs->subcode)\n     {\n@@ -1130,7 +1133,7 @@ dump_gimple_debug (pretty_printer *buffer, gimple gs, int spc, int flags)\n \n /* Dump a GIMPLE_OMP_FOR tuple on the pretty_printer BUFFER.  */\n static void\n-dump_gimple_omp_for (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_omp_for (pretty_printer *buffer, gomp_for *gs, int spc, int flags)\n {\n   size_t i;\n \n@@ -1266,7 +1269,8 @@ dump_gimple_omp_for (pretty_printer *buffer, gimple gs, int spc, int flags)\n /* Dump a GIMPLE_OMP_CONTINUE tuple on the pretty_printer BUFFER.  */\n \n static void\n-dump_gimple_omp_continue (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_omp_continue (pretty_printer *buffer, gomp_continue *gs,\n+\t\t\t  int spc, int flags)\n {\n   if (flags & TDF_RAW)\n     {\n@@ -1290,7 +1294,8 @@ dump_gimple_omp_continue (pretty_printer *buffer, gimple gs, int spc, int flags)\n /* Dump a GIMPLE_OMP_SINGLE tuple on the pretty_printer BUFFER.  */\n \n static void\n-dump_gimple_omp_single (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_omp_single (pretty_printer *buffer, gomp_single *gs,\n+\t\t\tint spc, int flags)\n {\n   if (flags & TDF_RAW)\n     {\n@@ -1318,7 +1323,8 @@ dump_gimple_omp_single (pretty_printer *buffer, gimple gs, int spc, int flags)\n /* Dump a GIMPLE_OMP_TARGET tuple on the pretty_printer BUFFER.  */\n \n static void\n-dump_gimple_omp_target (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_omp_target (pretty_printer *buffer, gomp_target *gs,\n+\t\t\tint spc, int flags)\n {\n   const char *kind;\n   switch (gimple_omp_target_kind (gs))\n@@ -1369,7 +1375,8 @@ dump_gimple_omp_target (pretty_printer *buffer, gimple gs, int spc, int flags)\n /* Dump a GIMPLE_OMP_TEAMS tuple on the pretty_printer BUFFER.  */\n \n static void\n-dump_gimple_omp_teams (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_omp_teams (pretty_printer *buffer, gomp_teams *gs, int spc,\n+\t\t       int flags)\n {\n   if (flags & TDF_RAW)\n     {\n@@ -1397,8 +1404,8 @@ dump_gimple_omp_teams (pretty_printer *buffer, gimple gs, int spc, int flags)\n /* Dump a GIMPLE_OMP_SECTIONS tuple on the pretty_printer BUFFER.  */\n \n static void\n-dump_gimple_omp_sections (pretty_printer *buffer, gimple gs, int spc,\n-\t\t\t  int flags)\n+dump_gimple_omp_sections (pretty_printer *buffer, gomp_sections *gs,\n+\t\t\t  int spc, int flags)\n {\n   if (flags & TDF_RAW)\n     {\n@@ -1473,8 +1480,8 @@ dump_gimple_omp_block (pretty_printer *buffer, gimple gs, int spc, int flags)\n /* Dump a GIMPLE_OMP_CRITICAL tuple on the pretty_printer BUFFER.  */\n \n static void\n-dump_gimple_omp_critical (pretty_printer *buffer, gimple gs, int spc,\n-\t\t\t  int flags)\n+dump_gimple_omp_critical (pretty_printer *buffer, gomp_critical *gs,\n+\t\t\t  int spc, int flags)\n {\n   if (flags & TDF_RAW)\n     dump_gimple_fmt (buffer, spc, flags, \"%G <%+BODY <%S> >\", gs,\n@@ -1534,7 +1541,8 @@ dump_gimple_omp_return (pretty_printer *buffer, gimple gs, int spc, int flags)\n /* Dump a GIMPLE_TRANSACTION tuple on the pretty_printer BUFFER.  */\n \n static void\n-dump_gimple_transaction (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_transaction (pretty_printer *buffer, gtransaction *gs,\n+\t\t\t int spc, int flags)\n {\n   unsigned subcode = gimple_transaction_subcode (gs);\n \n@@ -1621,7 +1629,7 @@ dump_gimple_transaction (pretty_printer *buffer, gimple gs, int spc, int flags)\n    dumpfile.h).  */\n \n static void\n-dump_gimple_asm (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_asm (pretty_printer *buffer, gasm *gs, int spc, int flags)\n {\n   unsigned int i, n, f, fields;\n \n@@ -1827,7 +1835,7 @@ dump_ssaname_info (pretty_printer *buffer, tree node, int spc)\n    pretty printer.  If COMMENT is true, print this after #.  */\n \n static void\n-dump_gimple_phi (pretty_printer *buffer, gimple phi, int spc, bool comment,\n+dump_gimple_phi (pretty_printer *buffer, gphi *phi, int spc, bool comment,\n \t\t int flags)\n {\n   size_t i;\n@@ -1868,8 +1876,8 @@ dump_gimple_phi (pretty_printer *buffer, gimple phi, int spc, bool comment,\n    dumpfile.h).  */\n \n static void\n-dump_gimple_omp_parallel (pretty_printer *buffer, gimple gs, int spc,\n-                          int flags)\n+dump_gimple_omp_parallel (pretty_printer *buffer, gomp_parallel *gs,\n+\t\t\t  int spc, int flags)\n {\n   if (flags & TDF_RAW)\n     {\n@@ -1922,7 +1930,7 @@ dump_gimple_omp_parallel (pretty_printer *buffer, gimple gs, int spc,\n    dumpfile.h).  */\n \n static void\n-dump_gimple_omp_task (pretty_printer *buffer, gimple gs, int spc,\n+dump_gimple_omp_task (pretty_printer *buffer, gomp_task *gs, int spc,\n \t\t      int flags)\n {\n   if (flags & TDF_RAW)\n@@ -1979,8 +1987,8 @@ dump_gimple_omp_task (pretty_printer *buffer, gimple gs, int spc,\n    in dumpfile.h).  */\n \n static void\n-dump_gimple_omp_atomic_load (pretty_printer *buffer, gimple gs, int spc,\n-                             int flags)\n+dump_gimple_omp_atomic_load (pretty_printer *buffer, gomp_atomic_load *gs,\n+\t\t\t     int spc, int flags)\n {\n   if (flags & TDF_RAW)\n     {\n@@ -2012,8 +2020,8 @@ dump_gimple_omp_atomic_load (pretty_printer *buffer, gimple gs, int spc,\n    in dumpfile.h).  */\n \n static void\n-dump_gimple_omp_atomic_store (pretty_printer *buffer, gimple gs, int spc,\n-                             int flags)\n+dump_gimple_omp_atomic_store (pretty_printer *buffer,\n+\t\t\t      gomp_atomic_store *gs, int spc, int flags)\n {\n   if (flags & TDF_RAW)\n     {\n@@ -2100,96 +2108,104 @@ pp_gimple_stmt_1 (pretty_printer *buffer, gimple gs, int spc, int flags)\n   switch (gimple_code (gs))\n     {\n     case GIMPLE_ASM:\n-      dump_gimple_asm (buffer, gs, spc, flags);\n+      dump_gimple_asm (buffer, as_a <gasm *> (gs), spc, flags);\n       break;\n \n     case GIMPLE_ASSIGN:\n-      dump_gimple_assign (buffer, gs, spc, flags);\n+      dump_gimple_assign (buffer, as_a <gassign *> (gs), spc, flags);\n       break;\n \n     case GIMPLE_BIND:\n-      dump_gimple_bind (buffer, gs, spc, flags);\n+      dump_gimple_bind (buffer, as_a <gbind *> (gs), spc, flags);\n       break;\n \n     case GIMPLE_CALL:\n-      dump_gimple_call (buffer, gs, spc, flags);\n+      dump_gimple_call (buffer, as_a <gcall *> (gs), spc, flags);\n       break;\n \n     case GIMPLE_COND:\n-      dump_gimple_cond (buffer, gs, spc, flags);\n+      dump_gimple_cond (buffer, as_a <gcond *> (gs), spc, flags);\n       break;\n \n     case GIMPLE_LABEL:\n-      dump_gimple_label (buffer, gs, spc, flags);\n+      dump_gimple_label (buffer, as_a <glabel *> (gs), spc, flags);\n       break;\n \n     case GIMPLE_GOTO:\n-      dump_gimple_goto (buffer, gs, spc, flags);\n+      dump_gimple_goto (buffer, as_a <ggoto *> (gs), spc, flags);\n       break;\n \n     case GIMPLE_NOP:\n       pp_string (buffer, \"GIMPLE_NOP\");\n       break;\n \n     case GIMPLE_RETURN:\n-      dump_gimple_return (buffer, gs, spc, flags);\n+      dump_gimple_return (buffer, as_a <greturn *> (gs), spc, flags);\n       break;\n \n     case GIMPLE_SWITCH:\n-      dump_gimple_switch (buffer, gs, spc, flags);\n+      dump_gimple_switch (buffer, as_a <gswitch *> (gs), spc, flags);\n       break;\n \n     case GIMPLE_TRY:\n-      dump_gimple_try (buffer, gs, spc, flags);\n+      dump_gimple_try (buffer, as_a <gtry *> (gs), spc, flags);\n       break;\n \n     case GIMPLE_PHI:\n-      dump_gimple_phi (buffer, gs, spc, false, flags);\n+      dump_gimple_phi (buffer, as_a <gphi *> (gs), spc, false, flags);\n       break;\n \n     case GIMPLE_OMP_PARALLEL:\n-      dump_gimple_omp_parallel (buffer, gs, spc, flags);\n+      dump_gimple_omp_parallel (buffer, as_a <gomp_parallel *> (gs), spc,\n+\t\t\t\tflags);\n       break;\n \n     case GIMPLE_OMP_TASK:\n-      dump_gimple_omp_task (buffer, gs, spc, flags);\n+      dump_gimple_omp_task (buffer, as_a <gomp_task *> (gs), spc, flags);\n       break;\n \n     case GIMPLE_OMP_ATOMIC_LOAD:\n-      dump_gimple_omp_atomic_load (buffer, gs, spc, flags);\n-\n+      dump_gimple_omp_atomic_load (buffer, as_a <gomp_atomic_load *> (gs),\n+\t\t\t\t   spc, flags);\n       break;\n \n     case GIMPLE_OMP_ATOMIC_STORE:\n-      dump_gimple_omp_atomic_store (buffer, gs, spc, flags);\n+      dump_gimple_omp_atomic_store (buffer,\n+\t\t\t\t    as_a <gomp_atomic_store *> (gs),\n+\t\t\t\t    spc, flags);\n       break;\n \n     case GIMPLE_OMP_FOR:\n-      dump_gimple_omp_for (buffer, gs, spc, flags);\n+      dump_gimple_omp_for (buffer, as_a <gomp_for *> (gs), spc, flags);\n       break;\n \n     case GIMPLE_OMP_CONTINUE:\n-      dump_gimple_omp_continue (buffer, gs, spc, flags);\n+      dump_gimple_omp_continue (buffer, as_a <gomp_continue *> (gs), spc,\n+\t\t\t\tflags);\n       break;\n \n     case GIMPLE_OMP_SINGLE:\n-      dump_gimple_omp_single (buffer, gs, spc, flags);\n+      dump_gimple_omp_single (buffer, as_a <gomp_single *> (gs), spc,\n+\t\t\t      flags);\n       break;\n \n     case GIMPLE_OMP_TARGET:\n-      dump_gimple_omp_target (buffer, gs, spc, flags);\n+      dump_gimple_omp_target (buffer, as_a <gomp_target *> (gs), spc,\n+\t\t\t      flags);\n       break;\n \n     case GIMPLE_OMP_TEAMS:\n-      dump_gimple_omp_teams (buffer, gs, spc, flags);\n+      dump_gimple_omp_teams (buffer, as_a <gomp_teams *> (gs), spc,\n+\t\t\t     flags);\n       break;\n \n     case GIMPLE_OMP_RETURN:\n       dump_gimple_omp_return (buffer, gs, spc, flags);\n       break;\n \n     case GIMPLE_OMP_SECTIONS:\n-      dump_gimple_omp_sections (buffer, gs, spc, flags);\n+      dump_gimple_omp_sections (buffer, as_a <gomp_sections *> (gs),\n+\t\t\t\tspc, flags);\n       break;\n \n     case GIMPLE_OMP_SECTIONS_SWITCH:\n@@ -2204,35 +2220,39 @@ pp_gimple_stmt_1 (pretty_printer *buffer, gimple gs, int spc, int flags)\n       break;\n \n     case GIMPLE_OMP_CRITICAL:\n-      dump_gimple_omp_critical (buffer, gs, spc, flags);\n+      dump_gimple_omp_critical (buffer, as_a <gomp_critical *> (gs), spc,\n+\t\t\t\tflags);\n       break;\n \n     case GIMPLE_CATCH:\n-      dump_gimple_catch (buffer, gs, spc, flags);\n+      dump_gimple_catch (buffer, as_a <gcatch *> (gs), spc, flags);\n       break;\n \n     case GIMPLE_EH_FILTER:\n-      dump_gimple_eh_filter (buffer, gs, spc, flags);\n+      dump_gimple_eh_filter (buffer, as_a <geh_filter *> (gs), spc, flags);\n       break;\n \n     case GIMPLE_EH_MUST_NOT_THROW:\n-      dump_gimple_eh_must_not_throw (buffer, gs, spc, flags);\n+      dump_gimple_eh_must_not_throw (buffer,\n+\t\t\t\t     as_a <geh_mnt *> (gs),\n+\t\t\t\t     spc, flags);\n       break;\n \n     case GIMPLE_EH_ELSE:\n-      dump_gimple_eh_else (buffer, gs, spc, flags);\n+      dump_gimple_eh_else (buffer, as_a <geh_else *> (gs), spc, flags);\n       break;\n \n     case GIMPLE_RESX:\n-      dump_gimple_resx (buffer, gs, spc, flags);\n+      dump_gimple_resx (buffer, as_a <gresx *> (gs), spc, flags);\n       break;\n \n     case GIMPLE_EH_DISPATCH:\n-      dump_gimple_eh_dispatch (buffer, gs, spc, flags);\n+      dump_gimple_eh_dispatch (buffer, as_a <geh_dispatch *> (gs), spc,\n+\t\t\t       flags);\n       break;\n \n     case GIMPLE_DEBUG:\n-      dump_gimple_debug (buffer, gs, spc, flags);\n+      dump_gimple_debug (buffer, as_a <gdebug *> (gs), spc, flags);\n       break;\n \n     case GIMPLE_PREDICT:\n@@ -2246,7 +2266,8 @@ pp_gimple_stmt_1 (pretty_printer *buffer, gimple gs, int spc, int flags)\n       break;\n \n     case GIMPLE_TRANSACTION:\n-      dump_gimple_transaction (buffer, gs, spc, flags);\n+      dump_gimple_transaction (buffer, as_a <gtransaction *> (gs), spc,\n+\t\t\t       flags);\n       break;\n \n     default:\n@@ -2312,11 +2333,11 @@ dump_gimple_bb_footer (FILE *outf ATTRIBUTE_UNUSED,\n static void\n dump_phi_nodes (pretty_printer *buffer, basic_block bb, int indent, int flags)\n {\n-  gimple_stmt_iterator i;\n+  gphi_iterator i;\n \n   for (i = gsi_start_phis (bb); !gsi_end_p (i); gsi_next (&i))\n     {\n-      gimple phi = gsi_stmt (i);\n+      gphi *phi = i.phi ();\n       if (!virtual_operand_p (gimple_phi_result (phi)) || (flags & TDF_VOPS))\n         {\n           INDENT (indent);\n@@ -2343,7 +2364,9 @@ pp_cfg_jump (pretty_printer *buffer, basic_block bb)\n   if (stmt && gimple_code (stmt) == GIMPLE_LABEL)\n     {\n       pp_string (buffer, \" (\");\n-      dump_generic_node (buffer, gimple_label_label (stmt), 0, 0, false);\n+      dump_generic_node (buffer,\n+\t\t\t gimple_label_label (as_a <glabel *> (stmt)),\n+\t\t\t 0, 0, false);\n       pp_right_paren (buffer);\n       pp_semicolon (buffer);\n     }\n@@ -2465,14 +2488,13 @@ gimple_dump_bb (FILE *file, basic_block bb, int indent, int flags)\n void\n gimple_dump_bb_for_graph (pretty_printer *pp, basic_block bb)\n {\n-  gimple_stmt_iterator gsi;\n-\n   pp_printf (pp, \"<bb %d>:\\n\", bb->index);\n   pp_write_text_as_dot_label_to_stream (pp, /*for_record=*/true);\n \n-  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n       if (!virtual_operand_p (gimple_phi_result (phi))\n \t  || (dump_flags & TDF_VOPS))\n \t{\n@@ -2485,7 +2507,8 @@ gimple_dump_bb_for_graph (pretty_printer *pp, basic_block bb)\n \t}\n     }\n \n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n     {\n       gimple stmt = gsi_stmt (gsi);\n       pp_bar (pp);"}, {"sha": "6dc63fd31d64b0d35595bef1ace7b775156dc345", "filename": "gcc/gimple-ssa-isolate-paths.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-ssa-isolate-paths.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-ssa-isolate-paths.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-isolate-paths.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -107,7 +107,7 @@ insert_trap_and_remove_trailing_statements (gimple_stmt_iterator *si_p, tree op)\n       update_stmt (stmt);\n     }\n \n-  gimple new_stmt\n+  gcall *new_stmt\n     = gimple_build_call (builtin_decl_explicit (BUILT_IN_TRAP), 0);\n   gimple_seq seq = NULL;\n   gimple_seq_add_stmt (&seq, new_stmt);\n@@ -216,7 +216,7 @@ isolate_path (basic_block bb, basic_block duplicate,\n     {\n       if (ret_zero)\n \t{\n-\t  gimple ret = gsi_stmt (si2);\n+\t  greturn *ret = as_a <greturn *> (gsi_stmt (si2));\n \t  tree zero = build_zero_cst (TREE_TYPE (gimple_return_retval (ret)));\n \t  gimple_return_set_retval (ret, zero);\n \t  update_stmt (ret);\n@@ -243,7 +243,7 @@ find_implicit_erroneous_behaviour (void)\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      gimple_stmt_iterator si;\n+      gphi_iterator si;\n \n       /* Out of an abundance of caution, do not isolate paths to a\n \t block where the block has any abnormal outgoing edges.\n@@ -262,7 +262,7 @@ find_implicit_erroneous_behaviour (void)\n \t cases.   */\n       for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n \t{\n-\t  gimple phi = gsi_stmt (si);\n+\t  gphi *phi = si.phi ();\n \t  tree lhs = gimple_phi_result (phi);\n \n \t  /* If the result is not a pointer, then there is no need to\n@@ -296,8 +296,12 @@ find_implicit_erroneous_behaviour (void)\n \t\t    {\n \t\t      FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n \t\t\t{\n-\t\t\t  if (gimple_code (use_stmt) != GIMPLE_RETURN\n-\t\t\t      || gimple_return_retval (use_stmt) != lhs)\n+\t\t\t  greturn *return_stmt\n+\t\t\t    = dyn_cast <greturn *> (use_stmt);\n+\t\t\t  if (!return_stmt)\n+\t\t\t    continue;\n+\n+\t\t\t  if (gimple_return_retval (return_stmt) != lhs)\n \t\t\t    continue;\n \n \t\t\t  if (warning_at (gimple_location (use_stmt),\n@@ -410,9 +414,9 @@ find_explicit_erroneous_behaviour (void)\n \t  /* Detect returning the address of a local variable.  This only\n \t     becomes undefined behavior if the result is used, so we do not\n \t     insert a trap and only return NULL instead.  */\n-\t  if (gimple_code (stmt) == GIMPLE_RETURN)\n+\t  if (greturn *return_stmt = dyn_cast <greturn *> (stmt))\n \t    {\n-\t      tree val = gimple_return_retval (stmt);\n+\t      tree val = gimple_return_retval (return_stmt);\n \t      if (val && TREE_CODE (val) == ADDR_EXPR)\n \t\t{\n \t\t  tree valbase = get_base_address (TREE_OPERAND (val, 0));\n@@ -436,7 +440,7 @@ find_explicit_erroneous_behaviour (void)\n \t\t\t\t      OPT_Wreturn_local_addr, msg))\n \t\t\tinform (DECL_SOURCE_LOCATION(valbase), \"declared here\");\n \t\t      tree zero = build_zero_cst (TREE_TYPE (val));\n-\t\t      gimple_return_set_retval (stmt, zero);\n+\t\t      gimple_return_set_retval (return_stmt, zero);\n \t\t      update_stmt (stmt);\n \t\t    }\n \t\t}"}, {"sha": "e719129df24082a12168da201361641fc56edfdc", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -753,7 +753,7 @@ add_cand_for_stmt (gimple gs, slsr_cand_t c)\n    is used to help find a basis for subsequent candidates.  */\n \n static void\n-slsr_process_phi (gimple phi, bool speed)\n+slsr_process_phi (gphi *phi, bool speed)\n {\n   unsigned i;\n   tree arg0_base = NULL_TREE, base_type;\n@@ -1678,12 +1678,13 @@ void\n find_candidates_dom_walker::before_dom_children (basic_block bb)\n {\n   bool speed = optimize_bb_for_speed_p (bb);\n-  gimple_stmt_iterator gsi;\n \n-  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    slsr_process_phi (gsi_stmt (gsi), speed);\n+  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n+    slsr_process_phi (gsi.phi (), speed);\n \n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n     {\n       gimple gs = gsi_stmt (gsi);\n \n@@ -2063,7 +2064,7 @@ replace_mult_candidate (slsr_cand_t c, tree basis_name, widest_int bump)\n       if (bump == 0)\n \t{\n \t  tree lhs = gimple_assign_lhs (c->cand_stmt);\n-\t  gimple copy_stmt = gimple_build_assign (lhs, basis_name);\n+\t  gassign *copy_stmt = gimple_build_assign (lhs, basis_name);\n \t  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n \t  gimple_set_location (copy_stmt, gimple_location (c->cand_stmt));\n \t  gsi_replace (&gsi, copy_stmt, false);\n@@ -2162,7 +2163,7 @@ create_add_on_incoming_edge (slsr_cand_t c, tree basis_name,\n   basic_block insert_bb;\n   gimple_stmt_iterator gsi;\n   tree lhs, basis_type;\n-  gimple new_stmt;\n+  gassign *new_stmt;\n \n   /* If the add candidate along this incoming edge has the same\n      index as C's hidden basis, the hidden basis represents this\n@@ -2246,7 +2247,7 @@ create_phi_basis (slsr_cand_t c, gimple from_phi, tree basis_name,\n {\n   int i;\n   tree name, phi_arg;\n-  gimple phi;\n+  gphi *phi;\n   vec<tree> phi_args;\n   slsr_cand_t basis = lookup_cand (c->basis);\n   int nargs = gimple_phi_num_args (from_phi);\n@@ -2981,7 +2982,7 @@ ncd_for_two_cands (basic_block bb1, basic_block bb2,\n    candidates, return the earliest candidate in the block in *WHERE.  */\n \n static basic_block\n-ncd_with_phi (slsr_cand_t c, const widest_int &incr, gimple phi,\n+ncd_with_phi (slsr_cand_t c, const widest_int &incr, gphi *phi,\n \t      basic_block ncd, slsr_cand_t *where)\n {\n   unsigned i;\n@@ -2997,7 +2998,8 @@ ncd_with_phi (slsr_cand_t c, const widest_int &incr, gimple phi,\n \t  gimple arg_def = SSA_NAME_DEF_STMT (arg);\n \n \t  if (gimple_code (arg_def) == GIMPLE_PHI)\n-\t    ncd = ncd_with_phi (c, incr, arg_def, ncd, where);\n+\t    ncd = ncd_with_phi (c, incr, as_a <gphi *> (arg_def), ncd,\n+\t\t\t\twhere);\n \t  else \n \t    {\n \t      slsr_cand_t arg_cand = base_cand_from_table (arg);\n@@ -3031,7 +3033,8 @@ ncd_of_cand_and_phis (slsr_cand_t c, const widest_int &incr, slsr_cand_t *where)\n     }\n   \n   if (phi_dependent_cand_p (c))\n-    ncd = ncd_with_phi (c, incr, lookup_cand (c->def_phi)->cand_stmt,\n+    ncd = ncd_with_phi (c, incr,\n+\t\t\tas_a <gphi *> (lookup_cand (c->def_phi)->cand_stmt),\n \t\t\tncd, where);\n \n   return ncd;\n@@ -3119,7 +3122,7 @@ insert_initializers (slsr_cand_t c)\n     {\n       basic_block bb;\n       slsr_cand_t where = NULL;\n-      gimple init_stmt;\n+      gassign *init_stmt;\n       tree stride_type, new_name, incr_tree;\n       widest_int incr = incr_vec[i].incr;\n \n@@ -3257,7 +3260,7 @@ static tree\n introduce_cast_before_cand (slsr_cand_t c, tree to_type, tree from_expr)\n {\n   tree cast_lhs;\n-  gimple cast_stmt;\n+  gassign *cast_stmt;\n   gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n \n   cast_lhs = make_temp_ssa_name (to_type, NULL, \"slsr\");\n@@ -3418,7 +3421,7 @@ replace_one_candidate (slsr_cand_t c, unsigned i, tree basis_name)\n       \n       if (types_compatible_p (lhs_type, basis_type))\n \t{\n-\t  gimple copy_stmt = gimple_build_assign (lhs, basis_name);\n+\t  gassign *copy_stmt = gimple_build_assign (lhs, basis_name);\n \t  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n \t  gimple_set_location (copy_stmt, gimple_location (c->cand_stmt));\n \t  gsi_replace (&gsi, copy_stmt, false);\n@@ -3430,8 +3433,8 @@ replace_one_candidate (slsr_cand_t c, unsigned i, tree basis_name)\n       else\n \t{\n \t  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n-\t  gimple cast_stmt = gimple_build_assign_with_ops (NOP_EXPR, lhs,\n-\t\t\t\t\t\t\t   basis_name);\n+\t  gassign *cast_stmt = gimple_build_assign_with_ops (NOP_EXPR, lhs,\n+\t\t\t\t\t\t\t     basis_name);\n \t  gimple_set_location (cast_stmt, gimple_location (c->cand_stmt));\n \t  gsi_replace (&gsi, cast_stmt, false);\n \t  c->cand_stmt = cast_stmt;"}, {"sha": "21b9c0e07b278acb9f1e420695b960664717a728", "filename": "gcc/gimple-streamer-in.c", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-in.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -59,14 +59,14 @@ along with GCC; see the file COPYING3.  If not see\n /* Read a PHI function for basic block BB in function FN.  DATA_IN is\n    the file being read.  IB is the input block to use for reading.  */\n \n-static gimple\n+static gphi *\n input_phi (struct lto_input_block *ib, basic_block bb, struct data_in *data_in,\n \t   struct function *fn)\n {\n   unsigned HOST_WIDE_INT ix;\n   tree phi_result;\n   int i, len;\n-  gimple result;\n+  gphi *result;\n \n   ix = streamer_read_uhwi (ib);\n   phi_result = (*SSANAMES (fn))[ix];\n@@ -138,21 +138,25 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n   switch (code)\n     {\n     case GIMPLE_RESX:\n-      gimple_resx_set_region (stmt, streamer_read_hwi (ib));\n+      gimple_resx_set_region (as_a <gresx *> (stmt),\n+\t\t\t      streamer_read_hwi (ib));\n       break;\n \n     case GIMPLE_EH_MUST_NOT_THROW:\n-      gimple_eh_must_not_throw_set_fndecl (stmt, stream_read_tree (ib, data_in));\n+      gimple_eh_must_not_throw_set_fndecl (\n+\tas_a <geh_mnt *> (stmt),\n+\tstream_read_tree (ib, data_in));\n       break;\n \n     case GIMPLE_EH_DISPATCH:\n-      gimple_eh_dispatch_set_region (stmt, streamer_read_hwi (ib));\n+      gimple_eh_dispatch_set_region (as_a <geh_dispatch *> (stmt),\n+\t\t\t\t     streamer_read_hwi (ib));\n       break;\n \n     case GIMPLE_ASM:\n       {\n \t/* FIXME lto.  Move most of this into a new gimple_asm_set_string().  */\n-\tgimple_statement_asm *asm_stmt = as_a <gimple_statement_asm *> (stmt);\n+\tgasm *asm_stmt = as_a <gasm *> (stmt);\n \ttree str;\n \tasm_stmt->ni = streamer_read_uhwi (ib);\n \tasm_stmt->no = streamer_read_uhwi (ib);\n@@ -200,13 +204,13 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n \t\t  == TREE_TYPE (TREE_OPERAND (TREE_OPERAND (*opp, 0), 0))))\n \t    *opp = TREE_OPERAND (TREE_OPERAND (*opp, 0), 0);\n \t}\n-      if (is_gimple_call (stmt))\n+      if (gcall *call_stmt = dyn_cast <gcall *> (stmt))\n \t{\n-\t  if (gimple_call_internal_p (stmt))\n+\t  if (gimple_call_internal_p (call_stmt))\n \t    gimple_call_set_internal_fn\n-\t      (stmt, streamer_read_enum (ib, internal_fn, IFN_LAST));\n+\t      (call_stmt, streamer_read_enum (ib, internal_fn, IFN_LAST));\n \t  else\n-\t    gimple_call_set_fntype (stmt, stream_read_tree (ib, data_in));\n+\t    gimple_call_set_fntype (call_stmt, stream_read_tree (ib, data_in));\n \t}\n       break;\n \n@@ -215,7 +219,8 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n       break;\n \n     case GIMPLE_TRANSACTION:\n-      gimple_transaction_set_label (stmt, stream_read_tree (ib, data_in));\n+      gimple_transaction_set_label (as_a <gtransaction *> (stmt),\n+\t\t\t\t    stream_read_tree (ib, data_in));\n       break;\n \n     default:\n@@ -233,19 +238,20 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n     }\n   else if (code == GIMPLE_ASM)\n     {\n+      gasm *asm_stmt = as_a <gasm *> (stmt);\n       unsigned i;\n \n-      for (i = 0; i < gimple_asm_noutputs (stmt); i++)\n+      for (i = 0; i < gimple_asm_noutputs (asm_stmt); i++)\n \t{\n-\t  tree op = TREE_VALUE (gimple_asm_output_op (stmt, i));\n+\t  tree op = TREE_VALUE (gimple_asm_output_op (asm_stmt, i));\n \t  if (TREE_CODE (op) == SSA_NAME)\n \t    SSA_NAME_DEF_STMT (op) = stmt;\n \t}\n     }\n \n   /* Reset alias information.  */\n   if (code == GIMPLE_CALL)\n-    gimple_call_reset_alias_info (stmt);\n+    gimple_call_reset_alias_info (as_a <gcall *> (stmt));\n \n   /* Mark the statement modified so its operand vectors can be filled in.  */\n   gimple_set_modified (stmt, true);"}, {"sha": "64ba66951cd7e49e3c8945fe3217f0ec064a297b", "filename": "gcc/gimple-streamer-out.c", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-out.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -54,7 +54,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Output PHI function PHI to the main stream in OB.  */\n \n static void\n-output_phi (struct output_block *ob, gimple phi)\n+output_phi (struct output_block *ob, gphi *phi)\n {\n   unsigned i, len = gimple_phi_num_args (phi);\n \n@@ -93,7 +93,10 @@ output_gimple_stmt (struct output_block *ob, gimple stmt)\n   bp_pack_var_len_unsigned (&bp, gimple_num_ops (stmt));\n   bp_pack_value (&bp, gimple_no_warning_p (stmt), 1);\n   if (is_gimple_assign (stmt))\n-    bp_pack_value (&bp, gimple_assign_nontemporal_move_p (stmt), 1);\n+    bp_pack_value (&bp,\n+\t\t   gimple_assign_nontemporal_move_p (\n+\t\t     as_a <gassign *> (stmt)),\n+\t\t   1);\n   bp_pack_value (&bp, gimple_has_volatile_ops (stmt), 1);\n   hist = gimple_histogram_value (cfun, stmt);\n   bp_pack_value (&bp, hist != NULL, 1);\n@@ -110,24 +113,32 @@ output_gimple_stmt (struct output_block *ob, gimple stmt)\n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_RESX:\n-      streamer_write_hwi (ob, gimple_resx_region (stmt));\n+      streamer_write_hwi (ob, gimple_resx_region (as_a <gresx *> (stmt)));\n       break;\n \n     case GIMPLE_EH_MUST_NOT_THROW:\n-      stream_write_tree (ob, gimple_eh_must_not_throw_fndecl (stmt), true);\n+      stream_write_tree (ob,\n+\t\t\t gimple_eh_must_not_throw_fndecl (\n+\t\t\t   as_a <geh_mnt *> (stmt)),\n+\t\t\t true);\n       break;\n \n     case GIMPLE_EH_DISPATCH:\n-      streamer_write_hwi (ob, gimple_eh_dispatch_region (stmt));\n+      streamer_write_hwi (ob,\n+\t\t\t  gimple_eh_dispatch_region (\n+\t\t\t    as_a <geh_dispatch *> (stmt)));\n       break;\n \n     case GIMPLE_ASM:\n-      streamer_write_uhwi (ob, gimple_asm_ninputs (stmt));\n-      streamer_write_uhwi (ob, gimple_asm_noutputs (stmt));\n-      streamer_write_uhwi (ob, gimple_asm_nclobbers (stmt));\n-      streamer_write_uhwi (ob, gimple_asm_nlabels (stmt));\n-      streamer_write_string (ob, ob->main_stream, gimple_asm_string (stmt),\n-\t\t\t     true);\n+      {\n+\tgasm *asm_stmt = as_a <gasm *> (stmt);\n+\tstreamer_write_uhwi (ob, gimple_asm_ninputs (asm_stmt));\n+\tstreamer_write_uhwi (ob, gimple_asm_noutputs (asm_stmt));\n+\tstreamer_write_uhwi (ob, gimple_asm_nclobbers (asm_stmt));\n+\tstreamer_write_uhwi (ob, gimple_asm_nlabels (asm_stmt));\n+\tstreamer_write_string (ob, ob->main_stream,\n+\t\t\t       gimple_asm_string (asm_stmt), true);\n+      }\n       /* Fallthru  */\n \n     case GIMPLE_ASSIGN:\n@@ -187,8 +198,11 @@ output_gimple_stmt (struct output_block *ob, gimple stmt)\n       break;\n \n     case GIMPLE_TRANSACTION:\n-      gcc_assert (gimple_transaction_body (stmt) == NULL);\n-      stream_write_tree (ob, gimple_transaction_label (stmt), true);\n+      {\n+\tgtransaction *trans_stmt = as_a <gtransaction *> (stmt);\n+\tgcc_assert (gimple_transaction_body (trans_stmt) == NULL);\n+\tstream_write_tree (ob, gimple_transaction_label (trans_stmt), true);\n+      }\n       break;\n \n     default:\n@@ -240,9 +254,11 @@ output_bb (struct output_block *ob, basic_block bb, struct function *fn)\n \n       streamer_write_record_start (ob, LTO_null);\n \n-      for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+      for (gphi_iterator psi = gsi_start_phis (bb);\n+\t   !gsi_end_p (psi);\n+\t   gsi_next (&psi))\n \t{\n-\t  gimple phi = gsi_stmt (bsi);\n+\t  gphi *phi = psi.phi ();\n \n \t  /* Only emit PHIs for gimple registers.  PHI nodes for .MEM\n \t     will be filled in on reading when the SSA form is"}, {"sha": "48fa05d7789e832b890cde4d02acfb85dd79e15a", "filename": "gcc/gimple-walk.c", "status": "modified", "additions": 93, "deletions": 75, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-walk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple-walk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-walk.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -102,7 +102,7 @@ walk_gimple_seq (gimple_seq seq, walk_stmt_fn callback_stmt,\n /* Helper function for walk_gimple_stmt.  Walk operands of a GIMPLE_ASM.  */\n \n static tree\n-walk_gimple_asm (gimple stmt, walk_tree_fn callback_op,\n+walk_gimple_asm (gasm *stmt, walk_tree_fn callback_op,\n \t\t struct walk_stmt_info *wi)\n {\n   tree ret, op;\n@@ -244,7 +244,8 @@ walk_gimple_op (gimple stmt, walk_tree_fn callback_op,\n \t  wi->val_only = true;\n \t}\n \n-      ret = walk_tree (gimple_call_chain_ptr (stmt), callback_op, wi, pset);\n+      ret = walk_tree (gimple_call_chain_ptr (as_a <gcall *> (stmt)),\n+\t\t       callback_op, wi, pset);\n       if (ret)\n         return ret;\n \n@@ -285,8 +286,8 @@ walk_gimple_op (gimple stmt, walk_tree_fn callback_op,\n       break;\n \n     case GIMPLE_CATCH:\n-      ret = walk_tree (gimple_catch_types_ptr (stmt), callback_op, wi,\n-\t\t       pset);\n+      ret = walk_tree (gimple_catch_types_ptr (as_a <gcatch *> (stmt)),\n+\t\t       callback_op, wi, pset);\n       if (ret)\n \treturn ret;\n       break;\n@@ -299,26 +300,30 @@ walk_gimple_op (gimple stmt, walk_tree_fn callback_op,\n       break;\n \n     case GIMPLE_ASM:\n-      ret = walk_gimple_asm (stmt, callback_op, wi);\n+      ret = walk_gimple_asm (as_a <gasm *> (stmt), callback_op, wi);\n       if (ret)\n \treturn ret;\n       break;\n \n     case GIMPLE_OMP_CONTINUE:\n-      ret = walk_tree (gimple_omp_continue_control_def_ptr (stmt),\n-\t  \t       callback_op, wi, pset);\n-      if (ret)\n-\treturn ret;\n-\n-      ret = walk_tree (gimple_omp_continue_control_use_ptr (stmt),\n-\t  \t       callback_op, wi, pset);\n-      if (ret)\n-\treturn ret;\n+      {\n+\tgomp_continue *cont_stmt = as_a <gomp_continue *> (stmt);\n+\tret = walk_tree (gimple_omp_continue_control_def_ptr (cont_stmt),\n+\t\t\t callback_op, wi, pset);\n+\tif (ret)\n+\t  return ret;\n+\n+\tret = walk_tree (gimple_omp_continue_control_use_ptr (cont_stmt),\n+\t\t\t callback_op, wi, pset);\n+\tif (ret)\n+\t  return ret;\n+      }\n       break;\n \n     case GIMPLE_OMP_CRITICAL:\n-      ret = walk_tree (gimple_omp_critical_name_ptr (stmt), callback_op, wi,\n-\t\t       pset);\n+      ret = walk_tree (gimple_omp_critical_name_ptr (\n+\t\t\t as_a <gomp_critical *> (stmt)),\n+\t\t       callback_op, wi, pset);\n       if (ret)\n \treturn ret;\n       break;\n@@ -350,18 +355,21 @@ walk_gimple_op (gimple stmt, walk_tree_fn callback_op,\n       break;\n \n     case GIMPLE_OMP_PARALLEL:\n-      ret = walk_tree (gimple_omp_parallel_clauses_ptr (stmt), callback_op,\n-\t\t       wi, pset);\n-      if (ret)\n-\treturn ret;\n-      ret = walk_tree (gimple_omp_parallel_child_fn_ptr (stmt), callback_op,\n-\t\t       wi, pset);\n-      if (ret)\n-\treturn ret;\n-      ret = walk_tree (gimple_omp_parallel_data_arg_ptr (stmt), callback_op,\n-\t\t       wi, pset);\n-      if (ret)\n-\treturn ret;\n+      {\n+\tgomp_parallel *omp_par_stmt = as_a <gomp_parallel *> (stmt);\n+\tret = walk_tree (gimple_omp_parallel_clauses_ptr (omp_par_stmt),\n+\t\t\t callback_op, wi, pset);\n+\tif (ret)\n+\t  return ret;\n+\tret = walk_tree (gimple_omp_parallel_child_fn_ptr (omp_par_stmt),\n+\t\t\t callback_op, wi, pset);\n+\tif (ret)\n+\t  return ret;\n+\tret = walk_tree (gimple_omp_parallel_data_arg_ptr (omp_par_stmt),\n+\t\t\t callback_op, wi, pset);\n+\tif (ret)\n+\t  return ret;\n+      }\n       break;\n \n     case GIMPLE_OMP_TASK:\n@@ -426,27 +434,32 @@ walk_gimple_op (gimple stmt, walk_tree_fn callback_op,\n       break;\n \n     case GIMPLE_OMP_ATOMIC_LOAD:\n-      ret = walk_tree (gimple_omp_atomic_load_lhs_ptr (stmt), callback_op, wi,\n-\t\t       pset);\n-      if (ret)\n-\treturn ret;\n-\n-      ret = walk_tree (gimple_omp_atomic_load_rhs_ptr (stmt), callback_op, wi,\n-\t\t       pset);\n-      if (ret)\n-\treturn ret;\n+      {\n+\tgomp_atomic_load *omp_stmt = as_a <gomp_atomic_load *> (stmt);\n+\tret = walk_tree (gimple_omp_atomic_load_lhs_ptr (omp_stmt),\n+\t\t\t callback_op, wi, pset);\n+\tif (ret)\n+\t  return ret;\n+\n+\tret = walk_tree (gimple_omp_atomic_load_rhs_ptr (omp_stmt),\n+\t\t\t callback_op, wi, pset);\n+\tif (ret)\n+\t  return ret;\n+      }\n       break;\n \n     case GIMPLE_OMP_ATOMIC_STORE:\n-      ret = walk_tree (gimple_omp_atomic_store_val_ptr (stmt), callback_op,\n-\t\t       wi, pset);\n+      ret = walk_tree (gimple_omp_atomic_store_val_ptr (\n+\t\t         as_a <gomp_atomic_store *> (stmt)),\n+\t\t       callback_op, wi, pset);\n       if (ret)\n \treturn ret;\n       break;\n \n     case GIMPLE_TRANSACTION:\n-      ret = walk_tree (gimple_transaction_label_ptr (stmt), callback_op,\n-\t\t       wi, pset);\n+      ret = walk_tree (gimple_transaction_label_ptr (\n+\t\t\t as_a <gtransaction *> (stmt)),\n+\t\t       callback_op, wi, pset);\n       if (ret)\n \treturn ret;\n       break;\n@@ -549,15 +562,16 @@ walk_gimple_stmt (gimple_stmt_iterator *gsi, walk_stmt_fn callback_stmt,\n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_BIND:\n-      ret = walk_gimple_seq_mod (gimple_bind_body_ptr (stmt), callback_stmt,\n-\t\t\t\t callback_op, wi);\n+      ret = walk_gimple_seq_mod (gimple_bind_body_ptr (as_a <gbind *> (stmt)),\n+\t\t\t\t callback_stmt, callback_op, wi);\n       if (ret)\n \treturn wi->callback_result;\n       break;\n \n     case GIMPLE_CATCH:\n-      ret = walk_gimple_seq_mod (gimple_catch_handler_ptr (stmt), callback_stmt,\n-\t\t\t\t callback_op, wi);\n+      ret = walk_gimple_seq_mod (gimple_catch_handler_ptr (\n+\t\t\t\t   as_a <gcatch *> (stmt)),\n+\t\t\t\t callback_stmt, callback_op, wi);\n       if (ret)\n \treturn wi->callback_result;\n       break;\n@@ -570,14 +584,17 @@ walk_gimple_stmt (gimple_stmt_iterator *gsi, walk_stmt_fn callback_stmt,\n       break;\n \n     case GIMPLE_EH_ELSE:\n-      ret = walk_gimple_seq_mod (gimple_eh_else_n_body_ptr (stmt),\n-\t\t\t     callback_stmt, callback_op, wi);\n-      if (ret)\n-\treturn wi->callback_result;\n-      ret = walk_gimple_seq_mod (gimple_eh_else_e_body_ptr (stmt),\n-\t\t\t     callback_stmt, callback_op, wi);\n-      if (ret)\n-\treturn wi->callback_result;\n+      {\n+\tgeh_else *eh_else_stmt = as_a <geh_else *> (stmt);\n+\tret = walk_gimple_seq_mod (gimple_eh_else_n_body_ptr (eh_else_stmt),\n+\t\t\t\t   callback_stmt, callback_op, wi);\n+\tif (ret)\n+\t  return wi->callback_result;\n+\tret = walk_gimple_seq_mod (gimple_eh_else_e_body_ptr (eh_else_stmt),\n+\t\t\t\t   callback_stmt, callback_op, wi);\n+\tif (ret)\n+\t  return wi->callback_result;\n+      }\n       break;\n \n     case GIMPLE_TRY:\n@@ -624,7 +641,8 @@ walk_gimple_stmt (gimple_stmt_iterator *gsi, walk_stmt_fn callback_stmt,\n       break;\n \n     case GIMPLE_TRANSACTION:\n-      ret = walk_gimple_seq_mod (gimple_transaction_body_ptr (stmt),\n+      ret = walk_gimple_seq_mod (gimple_transaction_body_ptr (\n+\t\t\t\t   as_a <gtransaction *> (stmt)),\n \t\t\t     callback_stmt, callback_op, wi);\n       if (ret)\n \treturn wi->callback_result;\n@@ -747,11 +765,11 @@ walk_stmt_load_store_addr_ops (gimple stmt, void *data,\n \t    }\n \t}\n     }\n-  else if (is_gimple_call (stmt))\n+  else if (gcall *call_stmt = dyn_cast <gcall *> (stmt))\n     {\n       if (visit_store)\n \t{\n-\t  tree arg = gimple_call_lhs (stmt);\n+\t  tree arg = gimple_call_lhs (call_stmt);\n \t  if (arg)\n \t    {\n \t      tree lhs = get_base_loadstore (arg);\n@@ -760,9 +778,9 @@ walk_stmt_load_store_addr_ops (gimple stmt, void *data,\n \t    }\n \t}\n       if (visit_load || visit_addr)\n-\tfor (i = 0; i < gimple_call_num_args (stmt); ++i)\n+\tfor (i = 0; i < gimple_call_num_args (call_stmt); ++i)\n \t  {\n-\t    tree arg = gimple_call_arg (stmt, i);\n+\t    tree arg = gimple_call_arg (call_stmt, i);\n \t    if (visit_addr\n \t\t&& TREE_CODE (arg) == ADDR_EXPR)\n \t      ret |= visit_addr (stmt, TREE_OPERAND (arg, 0), arg, data);\n@@ -774,29 +792,29 @@ walk_stmt_load_store_addr_ops (gimple stmt, void *data,\n \t      }\n \t  }\n       if (visit_addr\n-\t  && gimple_call_chain (stmt)\n-\t  && TREE_CODE (gimple_call_chain (stmt)) == ADDR_EXPR)\n-\tret |= visit_addr (stmt, TREE_OPERAND (gimple_call_chain (stmt), 0),\n-\t\t\t   gimple_call_chain (stmt), data);\n+\t  && gimple_call_chain (call_stmt)\n+\t  && TREE_CODE (gimple_call_chain (call_stmt)) == ADDR_EXPR)\n+\tret |= visit_addr (stmt, TREE_OPERAND (gimple_call_chain (call_stmt), 0),\n+\t\t\t   gimple_call_chain (call_stmt), data);\n       if (visit_addr\n-\t  && gimple_call_return_slot_opt_p (stmt)\n-\t  && gimple_call_lhs (stmt) != NULL_TREE\n-\t  && TREE_ADDRESSABLE (TREE_TYPE (gimple_call_lhs (stmt))))\n-\tret |= visit_addr (stmt, gimple_call_lhs (stmt),\n-\t\t\t   gimple_call_lhs (stmt), data);\n+\t  && gimple_call_return_slot_opt_p (call_stmt)\n+\t  && gimple_call_lhs (call_stmt) != NULL_TREE\n+\t  && TREE_ADDRESSABLE (TREE_TYPE (gimple_call_lhs (call_stmt))))\n+\tret |= visit_addr (stmt, gimple_call_lhs (call_stmt),\n+\t\t\t   gimple_call_lhs (call_stmt), data);\n     }\n-  else if (gimple_code (stmt) == GIMPLE_ASM)\n+  else if (gasm *asm_stmt = dyn_cast <gasm *> (stmt))\n     {\n       unsigned noutputs;\n       const char *constraint;\n       const char **oconstraints;\n       bool allows_mem, allows_reg, is_inout;\n-      noutputs = gimple_asm_noutputs (stmt);\n+      noutputs = gimple_asm_noutputs (asm_stmt);\n       oconstraints = XALLOCAVEC (const char *, noutputs);\n       if (visit_store || visit_addr)\n-\tfor (i = 0; i < gimple_asm_noutputs (stmt); ++i)\n+\tfor (i = 0; i < gimple_asm_noutputs (asm_stmt); ++i)\n \t  {\n-\t    tree link = gimple_asm_output_op (stmt, i);\n+\t    tree link = gimple_asm_output_op (asm_stmt, i);\n \t    tree op = get_base_loadstore (TREE_VALUE (link));\n \t    if (op && visit_store)\n \t      ret |= visit_store (stmt, op, TREE_VALUE (link), data);\n@@ -812,9 +830,9 @@ walk_stmt_load_store_addr_ops (gimple stmt, void *data,\n \t      }\n \t  }\n       if (visit_load || visit_addr)\n-\tfor (i = 0; i < gimple_asm_ninputs (stmt); ++i)\n+\tfor (i = 0; i < gimple_asm_ninputs (asm_stmt); ++i)\n \t  {\n-\t    tree link = gimple_asm_input_op (stmt, i);\n+\t    tree link = gimple_asm_input_op (asm_stmt, i);\n \t    tree op = TREE_VALUE (link);\n \t    if (visit_addr\n \t\t&& TREE_CODE (op) == ADDR_EXPR)\n@@ -841,9 +859,9 @@ walk_stmt_load_store_addr_ops (gimple stmt, void *data,\n \t      }\n \t  }\n     }\n-  else if (gimple_code (stmt) == GIMPLE_RETURN)\n+  else if (greturn *return_stmt = dyn_cast <greturn *> (stmt))\n     {\n-      tree op = gimple_return_retval (stmt);\n+      tree op = gimple_return_retval (return_stmt);\n       if (op)\n \t{\n \t  if (visit_addr"}, {"sha": "69cac22a2b37ef1ad1c620f4315f261d122324bc", "filename": "gcc/gimple.c", "status": "modified", "additions": 198, "deletions": 151, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -191,10 +191,12 @@ gimple_build_with_ops_stat (enum gimple_code code, unsigned subcode,\n \n /* Build a GIMPLE_RETURN statement returning RETVAL.  */\n \n-gimple\n+greturn *\n gimple_build_return (tree retval)\n {\n-  gimple s = gimple_build_with_ops (GIMPLE_RETURN, ERROR_MARK, 2);\n+  greturn *s\n+    = as_a <greturn *> (gimple_build_with_ops (GIMPLE_RETURN, ERROR_MARK,\n+\t\t\t\t\t       2));\n   if (retval)\n     gimple_return_set_retval (s, retval);\n   return s;\n@@ -203,7 +205,7 @@ gimple_build_return (tree retval)\n /* Reset alias information on call S.  */\n \n void\n-gimple_call_reset_alias_info (gimple s)\n+gimple_call_reset_alias_info (gcall *s)\n {\n   if (gimple_call_flags (s) & ECF_CONST)\n     memset (gimple_call_use_set (s), 0, sizeof (struct pt_solution));\n@@ -220,10 +222,12 @@ gimple_call_reset_alias_info (gimple s)\n    components of a GIMPLE_CALL statement to function FN with NARGS\n    arguments.  */\n \n-static inline gimple\n+static inline gcall *\n gimple_build_call_1 (tree fn, unsigned nargs)\n {\n-  gimple s = gimple_build_with_ops (GIMPLE_CALL, ERROR_MARK, nargs + 3);\n+  gcall *s\n+    = as_a <gcall *> (gimple_build_with_ops (GIMPLE_CALL, ERROR_MARK,\n+\t\t\t\t\t     nargs + 3));\n   if (TREE_CODE (fn) == FUNCTION_DECL)\n     fn = build_fold_addr_expr (fn);\n   gimple_set_op (s, 1, fn);\n@@ -236,12 +240,12 @@ gimple_build_call_1 (tree fn, unsigned nargs)\n /* Build a GIMPLE_CALL statement to function FN with the arguments\n    specified in vector ARGS.  */\n \n-gimple\n+gcall *\n gimple_build_call_vec (tree fn, vec<tree> args)\n {\n   unsigned i;\n   unsigned nargs = args.length ();\n-  gimple call = gimple_build_call_1 (fn, nargs);\n+  gcall *call = gimple_build_call_1 (fn, nargs);\n \n   for (i = 0; i < nargs; i++)\n     gimple_call_set_arg (call, i, args[i]);\n@@ -253,11 +257,11 @@ gimple_build_call_vec (tree fn, vec<tree> args)\n /* Build a GIMPLE_CALL statement to function FN.  NARGS is the number of\n    arguments.  The ... are the arguments.  */\n \n-gimple\n+gcall *\n gimple_build_call (tree fn, unsigned nargs, ...)\n {\n   va_list ap;\n-  gimple call;\n+  gcall *call;\n   unsigned i;\n \n   gcc_assert (TREE_CODE (fn) == FUNCTION_DECL || is_gimple_call_addr (fn));\n@@ -276,10 +280,10 @@ gimple_build_call (tree fn, unsigned nargs, ...)\n /* Build a GIMPLE_CALL statement to function FN.  NARGS is the number of\n    arguments.  AP contains the arguments.  */\n \n-gimple\n+gcall *\n gimple_build_call_valist (tree fn, unsigned nargs, va_list ap)\n {\n-  gimple call;\n+  gcall *call;\n   unsigned i;\n \n   gcc_assert (TREE_CODE (fn) == FUNCTION_DECL || is_gimple_call_addr (fn));\n@@ -297,10 +301,12 @@ gimple_build_call_valist (tree fn, unsigned nargs, va_list ap)\n    Build the basic components of a GIMPLE_CALL statement to internal\n    function FN with NARGS arguments.  */\n \n-static inline gimple\n+static inline gcall *\n gimple_build_call_internal_1 (enum internal_fn fn, unsigned nargs)\n {\n-  gimple s = gimple_build_with_ops (GIMPLE_CALL, ERROR_MARK, nargs + 3);\n+  gcall *s\n+    = as_a <gcall *> (gimple_build_with_ops (GIMPLE_CALL, ERROR_MARK,\n+\t\t\t\t\t     nargs + 3));\n   s->subcode |= GF_CALL_INTERNAL;\n   gimple_call_set_internal_fn (s, fn);\n   gimple_call_reset_alias_info (s);\n@@ -311,11 +317,11 @@ gimple_build_call_internal_1 (enum internal_fn fn, unsigned nargs)\n /* Build a GIMPLE_CALL statement to internal function FN.  NARGS is\n    the number of arguments.  The ... are the arguments.  */\n \n-gimple\n+gcall *\n gimple_build_call_internal (enum internal_fn fn, unsigned nargs, ...)\n {\n   va_list ap;\n-  gimple call;\n+  gcall *call;\n   unsigned i;\n \n   call = gimple_build_call_internal_1 (fn, nargs);\n@@ -331,11 +337,11 @@ gimple_build_call_internal (enum internal_fn fn, unsigned nargs, ...)\n /* Build a GIMPLE_CALL statement to internal function FN with the arguments\n    specified in vector ARGS.  */\n \n-gimple\n+gcall *\n gimple_build_call_internal_vec (enum internal_fn fn, vec<tree> args)\n {\n   unsigned i, nargs;\n-  gimple call;\n+  gcall *call;\n \n   nargs = args.length ();\n   call = gimple_build_call_internal_1 (fn, nargs);\n@@ -350,11 +356,11 @@ gimple_build_call_internal_vec (enum internal_fn fn, vec<tree> args)\n    assumed to be in GIMPLE form already.  Minimal checking is done of\n    this fact.  */\n \n-gimple\n+gcall *\n gimple_build_call_from_tree (tree t)\n {\n   unsigned i, nargs;\n-  gimple call;\n+  gcall *call;\n   tree fndecl = get_callee_fndecl (t);\n \n   gcc_assert (TREE_CODE (t) == CALL_EXPR);\n@@ -392,7 +398,7 @@ gimple_build_call_from_tree (tree t)\n    LHS of the assignment.\n    RHS of the assignment which can be unary or binary.  */\n \n-gimple\n+gassign *\n gimple_build_assign_stat (tree lhs, tree rhs MEM_STAT_DECL)\n {\n   enum tree_code subcode;\n@@ -408,19 +414,20 @@ gimple_build_assign_stat (tree lhs, tree rhs MEM_STAT_DECL)\n    OP1 and OP2.  If OP2 is NULL then SUBCODE must be of class\n    GIMPLE_UNARY_RHS or GIMPLE_SINGLE_RHS.  */\n \n-gimple\n+gassign *\n gimple_build_assign_with_ops (enum tree_code subcode, tree lhs, tree op1,\n \t\t\t      tree op2, tree op3 MEM_STAT_DECL)\n {\n   unsigned num_ops;\n-  gimple p;\n+  gassign *p;\n \n   /* Need 1 operand for LHS and 1 or 2 for the RHS (depending on the\n      code).  */\n   num_ops = get_gimple_rhs_num_ops (subcode) + 1;\n \n-  p = gimple_build_with_ops_stat (GIMPLE_ASSIGN, (unsigned)subcode, num_ops\n-  \t\t\t          PASS_MEM_STAT);\n+  p = as_a <gassign *> (\n+        gimple_build_with_ops_stat (GIMPLE_ASSIGN, (unsigned)subcode, num_ops\n+\t\t\t\t    PASS_MEM_STAT));\n   gimple_assign_set_lhs (p, lhs);\n   gimple_assign_set_rhs1 (p, op1);\n   if (op2)\n@@ -438,15 +445,15 @@ gimple_build_assign_with_ops (enum tree_code subcode, tree lhs, tree op1,\n   return p;\n }\n \n-gimple\n+gassign *\n gimple_build_assign_with_ops (enum tree_code subcode, tree lhs, tree op1,\n \t\t\t      tree op2 MEM_STAT_DECL)\n {\n   return gimple_build_assign_with_ops (subcode, lhs, op1, op2, NULL_TREE\n \t\t\t\t       PASS_MEM_STAT);\n }\n \n-gimple\n+gassign *\n gimple_build_assign_with_ops (enum tree_code subcode, tree lhs, tree op1\n \t\t\t      MEM_STAT_DECL)\n {\n@@ -461,14 +468,14 @@ gimple_build_assign_with_ops (enum tree_code subcode, tree lhs, tree op1\n    T_LABEL is the label to jump to if the condition is true.\n    F_LABEL is the label to jump to otherwise.  */\n \n-gimple\n+gcond *\n gimple_build_cond (enum tree_code pred_code, tree lhs, tree rhs,\n \t\t   tree t_label, tree f_label)\n {\n-  gimple p;\n+  gcond *p;\n \n   gcc_assert (TREE_CODE_CLASS (pred_code) == tcc_comparison);\n-  p = gimple_build_with_ops (GIMPLE_COND, pred_code, 4);\n+  p = as_a <gcond *> (gimple_build_with_ops (GIMPLE_COND, pred_code, 4));\n   gimple_cond_set_lhs (p, lhs);\n   gimple_cond_set_rhs (p, rhs);\n   gimple_cond_set_true_label (p, t_label);\n@@ -479,7 +486,7 @@ gimple_build_cond (enum tree_code pred_code, tree lhs, tree rhs,\n /* Build a GIMPLE_COND statement from the conditional expression tree\n    COND.  T_LABEL and F_LABEL are as in gimple_build_cond.  */\n \n-gimple\n+gcond *\n gimple_build_cond_from_tree (tree cond, tree t_label, tree f_label)\n {\n   enum tree_code code;\n@@ -493,7 +500,7 @@ gimple_build_cond_from_tree (tree cond, tree t_label, tree f_label)\n    boolean expression tree COND.  */\n \n void\n-gimple_cond_set_condition_from_tree (gimple stmt, tree cond)\n+gimple_cond_set_condition_from_tree (gcond *stmt, tree cond)\n {\n   enum tree_code code;\n   tree lhs, rhs;\n@@ -504,20 +511,22 @@ gimple_cond_set_condition_from_tree (gimple stmt, tree cond)\n \n /* Build a GIMPLE_LABEL statement for LABEL.  */\n \n-gimple\n+glabel *\n gimple_build_label (tree label)\n {\n-  gimple p = gimple_build_with_ops (GIMPLE_LABEL, ERROR_MARK, 1);\n+  glabel *p\n+    = as_a <glabel *> (gimple_build_with_ops (GIMPLE_LABEL, ERROR_MARK, 1));\n   gimple_label_set_label (p, label);\n   return p;\n }\n \n /* Build a GIMPLE_GOTO statement to label DEST.  */\n \n-gimple\n+ggoto *\n gimple_build_goto (tree dest)\n {\n-  gimple p = gimple_build_with_ops (GIMPLE_GOTO, ERROR_MARK, 1);\n+  ggoto *p\n+    = as_a <ggoto *> (gimple_build_with_ops (GIMPLE_GOTO, ERROR_MARK, 1));\n   gimple_goto_set_dest (p, dest);\n   return p;\n }\n@@ -536,10 +545,10 @@ gimple_build_nop (void)\n    VARS are the variables in BODY.\n    BLOCK is the containing block.  */\n \n-gimple\n+gbind *\n gimple_build_bind (tree vars, gimple_seq body, tree block)\n {\n-  gimple p = gimple_alloc (GIMPLE_BIND, 0);\n+  gbind *p = as_a <gbind *> (gimple_alloc (GIMPLE_BIND, 0));\n   gimple_bind_set_vars (p, vars);\n   if (body)\n     gimple_bind_set_body (p, body);\n@@ -556,18 +565,18 @@ gimple_build_bind (tree vars, gimple_seq body, tree block)\n    NCLOBBERS is the number of clobbered registers.\n    */\n \n-static inline gimple\n+static inline gasm *\n gimple_build_asm_1 (const char *string, unsigned ninputs, unsigned noutputs,\n                     unsigned nclobbers, unsigned nlabels)\n {\n-  gimple_statement_asm *p;\n+  gasm *p;\n   int size = strlen (string);\n \n   /* ASMs with labels cannot have outputs.  This should have been\n      enforced by the front end.  */\n   gcc_assert (nlabels == 0 || noutputs == 0);\n \n-  p = as_a <gimple_statement_asm *> (\n+  p = as_a <gasm *> (\n         gimple_build_with_ops (GIMPLE_ASM, ERROR_MARK,\n \t\t\t       ninputs + noutputs + nclobbers + nlabels));\n \n@@ -594,12 +603,12 @@ gimple_build_asm_1 (const char *string, unsigned ninputs, unsigned noutputs,\n    CLOBBERS is a vector of the clobbered register parameters.\n    LABELS is a vector of destination labels.  */\n \n-gimple\n+gasm *\n gimple_build_asm_vec (const char *string, vec<tree, va_gc> *inputs,\n                       vec<tree, va_gc> *outputs, vec<tree, va_gc> *clobbers,\n \t\t      vec<tree, va_gc> *labels)\n {\n-  gimple p;\n+  gasm *p;\n   unsigned i;\n \n   p = gimple_build_asm_1 (string,\n@@ -628,10 +637,10 @@ gimple_build_asm_vec (const char *string, vec<tree, va_gc> *inputs,\n   TYPES are the catch types.\n   HANDLER is the exception handler.  */\n \n-gimple\n+gcatch *\n gimple_build_catch (tree types, gimple_seq handler)\n {\n-  gimple p = gimple_alloc (GIMPLE_CATCH, 0);\n+  gcatch *p = as_a <gcatch *> (gimple_alloc (GIMPLE_CATCH, 0));\n   gimple_catch_set_types (p, types);\n   if (handler)\n     gimple_catch_set_handler (p, handler);\n@@ -644,10 +653,10 @@ gimple_build_catch (tree types, gimple_seq handler)\n    TYPES are the filter's types.\n    FAILURE is the filter's failure action.  */\n \n-gimple\n+geh_filter *\n gimple_build_eh_filter (tree types, gimple_seq failure)\n {\n-  gimple p = gimple_alloc (GIMPLE_EH_FILTER, 0);\n+  geh_filter *p = as_a <geh_filter *> (gimple_alloc (GIMPLE_EH_FILTER, 0));\n   gimple_eh_filter_set_types (p, types);\n   if (failure)\n     gimple_eh_filter_set_failure (p, failure);\n@@ -657,10 +666,10 @@ gimple_build_eh_filter (tree types, gimple_seq failure)\n \n /* Build a GIMPLE_EH_MUST_NOT_THROW statement.  */\n \n-gimple\n+geh_mnt *\n gimple_build_eh_must_not_throw (tree decl)\n {\n-  gimple p = gimple_alloc (GIMPLE_EH_MUST_NOT_THROW, 0);\n+  geh_mnt *p = as_a <geh_mnt *> (gimple_alloc (GIMPLE_EH_MUST_NOT_THROW, 0));\n \n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n   gcc_assert (flags_from_decl_or_type (decl) & ECF_NORETURN);\n@@ -671,10 +680,10 @@ gimple_build_eh_must_not_throw (tree decl)\n \n /* Build a GIMPLE_EH_ELSE statement.  */\n \n-gimple\n+geh_else *\n gimple_build_eh_else (gimple_seq n_body, gimple_seq e_body)\n {\n-  gimple p = gimple_alloc (GIMPLE_EH_ELSE, 0);\n+  geh_else *p = as_a <geh_else *> (gimple_alloc (GIMPLE_EH_ELSE, 0));\n   gimple_eh_else_set_n_body (p, n_body);\n   gimple_eh_else_set_e_body (p, e_body);\n   return p;\n@@ -687,14 +696,14 @@ gimple_build_eh_else (gimple_seq n_body, gimple_seq e_body)\n    KIND is either GIMPLE_TRY_CATCH or GIMPLE_TRY_FINALLY depending on\n    whether this is a try/catch or a try/finally respectively.  */\n \n-gimple_statement_try *\n+gtry *\n gimple_build_try (gimple_seq eval, gimple_seq cleanup,\n     \t\t  enum gimple_try_flags kind)\n {\n-  gimple_statement_try *p;\n+  gtry *p;\n \n   gcc_assert (kind == GIMPLE_TRY_CATCH || kind == GIMPLE_TRY_FINALLY);\n-  p = as_a <gimple_statement_try *> (gimple_alloc (GIMPLE_TRY, 0));\n+  p = as_a <gtry *> (gimple_alloc (GIMPLE_TRY, 0));\n   gimple_set_subcode (p, kind);\n   if (eval)\n     gimple_try_set_eval (p, eval);\n@@ -721,12 +730,11 @@ gimple_build_wce (gimple_seq cleanup)\n \n /* Build a GIMPLE_RESX statement.  */\n \n-gimple\n+gresx *\n gimple_build_resx (int region)\n {\n-  gimple_statement_resx *p =\n-    as_a <gimple_statement_resx *> (\n-      gimple_build_with_ops (GIMPLE_RESX, ERROR_MARK, 0));\n+  gresx *p\n+    = as_a <gresx *> (gimple_build_with_ops (GIMPLE_RESX, ERROR_MARK, 0));\n   p->region = region;\n   return p;\n }\n@@ -737,13 +745,14 @@ gimple_build_resx (int region)\n    NLABELS is the number of labels in the switch excluding the default.\n    DEFAULT_LABEL is the default label for the switch statement.  */\n \n-gimple\n+gswitch *\n gimple_build_switch_nlabels (unsigned nlabels, tree index, tree default_label)\n {\n   /* nlabels + 1 default label + 1 index.  */\n   gcc_checking_assert (default_label);\n-  gimple p = gimple_build_with_ops (GIMPLE_SWITCH, ERROR_MARK,\n-\t\t\t\t    1 + 1 + nlabels);\n+  gswitch *p = as_a <gswitch *> (gimple_build_with_ops (GIMPLE_SWITCH,\n+\t\t\t\t\t\t\tERROR_MARK,\n+\t\t\t\t\t\t\t1 + 1 + nlabels));\n   gimple_switch_set_index (p, index);\n   gimple_switch_set_default_label (p, default_label);\n   return p;\n@@ -755,12 +764,12 @@ gimple_build_switch_nlabels (unsigned nlabels, tree index, tree default_label)\n    DEFAULT_LABEL is the default label\n    ARGS is a vector of labels excluding the default.  */\n \n-gimple\n+gswitch *\n gimple_build_switch (tree index, tree default_label, vec<tree> args)\n {\n   unsigned i, nlabels = args.length ();\n \n-  gimple p = gimple_build_switch_nlabels (nlabels, index, default_label);\n+  gswitch *p = gimple_build_switch_nlabels (nlabels, index, default_label);\n \n   /* Copy the labels from the vector to the switch statement.  */\n   for (i = 0; i < nlabels; i++)\n@@ -771,12 +780,12 @@ gimple_build_switch (tree index, tree default_label, vec<tree> args)\n \n /* Build a GIMPLE_EH_DISPATCH statement.  */\n \n-gimple\n+geh_dispatch *\n gimple_build_eh_dispatch (int region)\n {\n-  gimple_statement_eh_dispatch *p =\n-    as_a <gimple_statement_eh_dispatch *> (\n-      gimple_build_with_ops (GIMPLE_EH_DISPATCH, ERROR_MARK, 0));\n+  geh_dispatch *p\n+    = as_a <geh_dispatch *> (\n+\tgimple_build_with_ops (GIMPLE_EH_DISPATCH, ERROR_MARK, 0));\n   p->region = region;\n   return p;\n }\n@@ -785,13 +794,13 @@ gimple_build_eh_dispatch (int region)\n \n    VAR is bound to VALUE; block and location are taken from STMT.  */\n \n-gimple\n+gdebug *\n gimple_build_debug_bind_stat (tree var, tree value, gimple stmt MEM_STAT_DECL)\n {\n-  gimple p = gimple_build_with_ops_stat (GIMPLE_DEBUG,\n-\t\t\t\t\t (unsigned)GIMPLE_DEBUG_BIND, 2\n-\t\t\t\t\t PASS_MEM_STAT);\n-\n+  gdebug *p\n+    = as_a <gdebug *> (gimple_build_with_ops_stat (GIMPLE_DEBUG,\n+\t\t\t\t\t\t   (unsigned)GIMPLE_DEBUG_BIND, 2\n+\t\t\t\t\t\t   PASS_MEM_STAT));\n   gimple_debug_bind_set_var (p, var);\n   gimple_debug_bind_set_value (p, value);\n   if (stmt)\n@@ -805,13 +814,15 @@ gimple_build_debug_bind_stat (tree var, tree value, gimple stmt MEM_STAT_DECL)\n \n    VAR is bound to VALUE; block and location are taken from STMT.  */\n \n-gimple\n+gdebug *\n gimple_build_debug_source_bind_stat (tree var, tree value,\n \t\t\t\t     gimple stmt MEM_STAT_DECL)\n {\n-  gimple p = gimple_build_with_ops_stat (GIMPLE_DEBUG,\n-\t\t\t\t\t (unsigned)GIMPLE_DEBUG_SOURCE_BIND, 2\n-\t\t\t\t\t PASS_MEM_STAT);\n+  gdebug *p\n+    = as_a <gdebug *> (\n+        gimple_build_with_ops_stat (GIMPLE_DEBUG,\n+\t\t\t\t    (unsigned)GIMPLE_DEBUG_SOURCE_BIND, 2\n+\t\t\t\t    PASS_MEM_STAT));\n \n   gimple_debug_source_bind_set_var (p, var);\n   gimple_debug_source_bind_set_value (p, value);\n@@ -827,10 +838,11 @@ gimple_build_debug_source_bind_stat (tree var, tree value,\n    BODY is the sequence of statements for which only one thread can execute.\n    NAME is optional identifier for this critical block.  */\n \n-gimple\n+gomp_critical *\n gimple_build_omp_critical (gimple_seq body, tree name)\n {\n-  gimple p = gimple_alloc (GIMPLE_OMP_CRITICAL, 0);\n+  gomp_critical *p\n+    = as_a <gomp_critical *> (gimple_alloc (GIMPLE_OMP_CRITICAL, 0));\n   gimple_omp_critical_set_name (p, name);\n   if (body)\n     gimple_omp_set_body (p, body);\n@@ -847,12 +859,11 @@ gimple_build_omp_critical (gimple_seq body, tree name)\n    COLLAPSE is the collapse count.\n    PRE_BODY is the sequence of statements that are loop invariant.  */\n \n-gimple\n+gomp_for *\n gimple_build_omp_for (gimple_seq body, int kind, tree clauses, size_t collapse,\n \t\t      gimple_seq pre_body)\n {\n-  gimple_statement_omp_for *p =\n-    as_a <gimple_statement_omp_for *> (gimple_alloc (GIMPLE_OMP_FOR, 0));\n+  gomp_for *p = as_a <gomp_for *> (gimple_alloc (GIMPLE_OMP_FOR, 0));\n   if (body)\n     gimple_omp_set_body (p, body);\n   gimple_omp_for_set_clauses (p, clauses);\n@@ -874,11 +885,12 @@ gimple_build_omp_for (gimple_seq body, int kind, tree clauses, size_t collapse,\n    CHILD_FN is the function created for the parallel threads to execute.\n    DATA_ARG are the shared data argument(s).  */\n \n-gimple\n+gomp_parallel *\n gimple_build_omp_parallel (gimple_seq body, tree clauses, tree child_fn,\n \t\t\t   tree data_arg)\n {\n-  gimple p = gimple_alloc (GIMPLE_OMP_PARALLEL, 0);\n+  gomp_parallel *p\n+    = as_a <gomp_parallel *> (gimple_alloc (GIMPLE_OMP_PARALLEL, 0));\n   if (body)\n     gimple_omp_set_body (p, body);\n   gimple_omp_parallel_set_clauses (p, clauses);\n@@ -898,12 +910,12 @@ gimple_build_omp_parallel (gimple_seq body, tree clauses, tree child_fn,\n    COPY_FN is the optional function for firstprivate initialization.\n    ARG_SIZE and ARG_ALIGN are size and alignment of the data block.  */\n \n-gimple\n+gomp_task *\n gimple_build_omp_task (gimple_seq body, tree clauses, tree child_fn,\n \t\t       tree data_arg, tree copy_fn, tree arg_size,\n \t\t       tree arg_align)\n {\n-  gimple p = gimple_alloc (GIMPLE_OMP_TASK, 0);\n+  gomp_task *p = as_a <gomp_task *> (gimple_alloc (GIMPLE_OMP_TASK, 0));\n   if (body)\n     gimple_omp_set_body (p, body);\n   gimple_omp_task_set_clauses (p, clauses);\n@@ -968,10 +980,11 @@ gimple_build_omp_taskgroup (gimple_seq body)\n    CONTROL_DEF is the definition of the control variable.\n    CONTROL_USE is the use of the control variable.  */\n \n-gimple\n+gomp_continue *\n gimple_build_omp_continue (tree control_def, tree control_use)\n {\n-  gimple p = gimple_alloc (GIMPLE_OMP_CONTINUE, 0);\n+  gomp_continue *p\n+    = as_a <gomp_continue *> (gimple_alloc (GIMPLE_OMP_CONTINUE, 0));\n   gimple_omp_continue_set_control_def (p, control_def);\n   gimple_omp_continue_set_control_use (p, control_use);\n   return p;\n@@ -1013,10 +1026,11 @@ gimple_build_omp_return (bool wait_p)\n    CLAUSES are any of the OMP sections contsruct's clauses: private,\n    firstprivate, lastprivate, reduction, and nowait.  */\n \n-gimple\n+gomp_sections *\n gimple_build_omp_sections (gimple_seq body, tree clauses)\n {\n-  gimple p = gimple_alloc (GIMPLE_OMP_SECTIONS, 0);\n+  gomp_sections *p\n+    = as_a <gomp_sections *> (gimple_alloc (GIMPLE_OMP_SECTIONS, 0));\n   if (body)\n     gimple_omp_set_body (p, body);\n   gimple_omp_sections_set_clauses (p, clauses);\n@@ -1040,10 +1054,11 @@ gimple_build_omp_sections_switch (void)\n    CLAUSES are any of the OMP single construct's clauses: private, firstprivate,\n    copyprivate, nowait.  */\n \n-gimple\n+gomp_single *\n gimple_build_omp_single (gimple_seq body, tree clauses)\n {\n-  gimple p = gimple_alloc (GIMPLE_OMP_SINGLE, 0);\n+  gomp_single *p\n+    = as_a <gomp_single *> (gimple_alloc (GIMPLE_OMP_SINGLE, 0));\n   if (body)\n     gimple_omp_set_body (p, body);\n   gimple_omp_single_set_clauses (p, clauses);\n@@ -1057,10 +1072,11 @@ gimple_build_omp_single (gimple_seq body, tree clauses)\n    BODY is the sequence of statements that will be executed.\n    CLAUSES are any of the OMP target construct's clauses.  */\n \n-gimple\n+gomp_target *\n gimple_build_omp_target (gimple_seq body, int kind, tree clauses)\n {\n-  gimple p = gimple_alloc (GIMPLE_OMP_TARGET, 0);\n+  gomp_target *p\n+    = as_a <gomp_target *> (gimple_alloc (GIMPLE_OMP_TARGET, 0));\n   if (body)\n     gimple_omp_set_body (p, body);\n   gimple_omp_target_set_clauses (p, clauses);\n@@ -1075,10 +1091,10 @@ gimple_build_omp_target (gimple_seq body, int kind, tree clauses)\n    BODY is the sequence of statements that will be executed.\n    CLAUSES are any of the OMP teams construct's clauses.  */\n \n-gimple\n+gomp_teams *\n gimple_build_omp_teams (gimple_seq body, tree clauses)\n {\n-  gimple p = gimple_alloc (GIMPLE_OMP_TEAMS, 0);\n+  gomp_teams *p = as_a <gomp_teams *> (gimple_alloc (GIMPLE_OMP_TEAMS, 0));\n   if (body)\n     gimple_omp_set_body (p, body);\n   gimple_omp_teams_set_clauses (p, clauses);\n@@ -1089,10 +1105,11 @@ gimple_build_omp_teams (gimple_seq body, tree clauses)\n \n /* Build a GIMPLE_OMP_ATOMIC_LOAD statement.  */\n \n-gimple\n+gomp_atomic_load *\n gimple_build_omp_atomic_load (tree lhs, tree rhs)\n {\n-  gimple p = gimple_alloc (GIMPLE_OMP_ATOMIC_LOAD, 0);\n+  gomp_atomic_load *p\n+    = as_a <gomp_atomic_load *> (gimple_alloc (GIMPLE_OMP_ATOMIC_LOAD, 0));\n   gimple_omp_atomic_load_set_lhs (p, lhs);\n   gimple_omp_atomic_load_set_rhs (p, rhs);\n   return p;\n@@ -1102,20 +1119,22 @@ gimple_build_omp_atomic_load (tree lhs, tree rhs)\n \n    VAL is the value we are storing.  */\n \n-gimple\n+gomp_atomic_store *\n gimple_build_omp_atomic_store (tree val)\n {\n-  gimple p = gimple_alloc (GIMPLE_OMP_ATOMIC_STORE, 0);\n+  gomp_atomic_store *p\n+    = as_a <gomp_atomic_store *> (gimple_alloc (GIMPLE_OMP_ATOMIC_STORE, 0));\n   gimple_omp_atomic_store_set_val (p, val);\n   return p;\n }\n \n /* Build a GIMPLE_TRANSACTION statement.  */\n \n-gimple\n+gtransaction *\n gimple_build_transaction (gimple_seq body, tree label)\n {\n-  gimple p = gimple_alloc (GIMPLE_TRANSACTION, 0);\n+  gtransaction *p\n+    = as_a <gtransaction *> (gimple_alloc (GIMPLE_TRANSACTION, 0));\n   gimple_transaction_set_body (p, body);\n   gimple_transaction_set_label (p, label);\n   return p;\n@@ -1283,8 +1302,8 @@ empty_stmt_p (gimple stmt)\n {\n   if (gimple_code (stmt) == GIMPLE_NOP)\n     return true;\n-  if (gimple_code (stmt) == GIMPLE_BIND)\n-    return empty_body_p (gimple_bind_body (stmt));\n+  if (gbind *bind_stmt = dyn_cast <gbind *> (stmt))\n+    return empty_body_p (gimple_bind_body (bind_stmt));\n   return false;\n }\n \n@@ -1366,7 +1385,7 @@ gimple_call_flags (const_gimple stmt)\n /* Return the \"fn spec\" string for call STMT.  */\n \n static const_tree\n-gimple_call_fnspec (const_gimple stmt)\n+gimple_call_fnspec (const gcall *stmt)\n {\n   tree type, attr;\n \n@@ -1387,7 +1406,7 @@ gimple_call_fnspec (const_gimple stmt)\n /* Detects argument flags for argument number ARG on call STMT.  */\n \n int\n-gimple_call_arg_flags (const_gimple stmt, unsigned arg)\n+gimple_call_arg_flags (const gcall *stmt, unsigned arg)\n {\n   const_tree attr = gimple_call_fnspec (stmt);\n \n@@ -1421,7 +1440,7 @@ gimple_call_arg_flags (const_gimple stmt, unsigned arg)\n /* Detects return flags for the call STMT.  */\n \n int\n-gimple_call_return_flags (const_gimple stmt)\n+gimple_call_return_flags (const gcall *stmt)\n {\n   const_tree attr;\n \n@@ -1513,7 +1532,7 @@ gimple_set_bb (gimple stmt, basic_block bb)\n       tree t;\n       int uid;\n \n-      t = gimple_label_label (stmt);\n+      t = gimple_label_label (as_a <glabel *> (stmt));\n       uid = LABEL_DECL_UID (t);\n       if (uid == -1)\n \t{\n@@ -1662,38 +1681,60 @@ gimple_copy (gimple stmt)\n       switch (gimple_code (stmt))\n \t{\n \tcase GIMPLE_BIND:\n-\t  new_seq = gimple_seq_copy (gimple_bind_body (stmt));\n-\t  gimple_bind_set_body (copy, new_seq);\n-\t  gimple_bind_set_vars (copy, unshare_expr (gimple_bind_vars (stmt)));\n-\t  gimple_bind_set_block (copy, gimple_bind_block (stmt));\n+\t  {\n+\t    gbind *bind_stmt = as_a <gbind *> (stmt);\n+\t    gbind *bind_copy = as_a <gbind *> (copy);\n+\t    new_seq = gimple_seq_copy (gimple_bind_body (bind_stmt));\n+\t    gimple_bind_set_body (bind_copy, new_seq);\n+\t    gimple_bind_set_vars (bind_copy,\n+\t\t\t\t  unshare_expr (gimple_bind_vars (bind_stmt)));\n+\t    gimple_bind_set_block (bind_copy, gimple_bind_block (bind_stmt));\n+\t  }\n \t  break;\n \n \tcase GIMPLE_CATCH:\n-\t  new_seq = gimple_seq_copy (gimple_catch_handler (stmt));\n-\t  gimple_catch_set_handler (copy, new_seq);\n-\t  t = unshare_expr (gimple_catch_types (stmt));\n-\t  gimple_catch_set_types (copy, t);\n+\t  {\n+\t    gcatch *catch_stmt = as_a <gcatch *> (stmt);\n+\t    gcatch *catch_copy = as_a <gcatch *> (copy);\n+\t    new_seq = gimple_seq_copy (gimple_catch_handler (catch_stmt));\n+\t    gimple_catch_set_handler (catch_copy, new_seq);\n+\t    t = unshare_expr (gimple_catch_types (catch_stmt));\n+\t    gimple_catch_set_types (catch_copy, t);\n+\t  }\n \t  break;\n \n \tcase GIMPLE_EH_FILTER:\n-\t  new_seq = gimple_seq_copy (gimple_eh_filter_failure (stmt));\n-\t  gimple_eh_filter_set_failure (copy, new_seq);\n-\t  t = unshare_expr (gimple_eh_filter_types (stmt));\n-\t  gimple_eh_filter_set_types (copy, t);\n+\t  {\n+\t    geh_filter *eh_filter_stmt = as_a <geh_filter *> (stmt);\n+\t    geh_filter *eh_filter_copy = as_a <geh_filter *> (copy);\n+\t    new_seq\n+\t      = gimple_seq_copy (gimple_eh_filter_failure (eh_filter_stmt));\n+\t    gimple_eh_filter_set_failure (eh_filter_copy, new_seq);\n+\t    t = unshare_expr (gimple_eh_filter_types (eh_filter_stmt));\n+\t    gimple_eh_filter_set_types (eh_filter_copy, t);\n+\t  }\n \t  break;\n \n \tcase GIMPLE_EH_ELSE:\n-\t  new_seq = gimple_seq_copy (gimple_eh_else_n_body (stmt));\n-\t  gimple_eh_else_set_n_body (copy, new_seq);\n-\t  new_seq = gimple_seq_copy (gimple_eh_else_e_body (stmt));\n-\t  gimple_eh_else_set_e_body (copy, new_seq);\n+\t  {\n+\t    geh_else *eh_else_stmt = as_a <geh_else *> (stmt);\n+\t    geh_else *eh_else_copy = as_a <geh_else *> (copy);\n+\t    new_seq = gimple_seq_copy (gimple_eh_else_n_body (eh_else_stmt));\n+\t    gimple_eh_else_set_n_body (eh_else_copy, new_seq);\n+\t    new_seq = gimple_seq_copy (gimple_eh_else_e_body (eh_else_stmt));\n+\t    gimple_eh_else_set_e_body (eh_else_copy, new_seq);\n+\t  }\n \t  break;\n \n \tcase GIMPLE_TRY:\n-\t  new_seq = gimple_seq_copy (gimple_try_eval (stmt));\n-\t  gimple_try_set_eval (copy, new_seq);\n-\t  new_seq = gimple_seq_copy (gimple_try_cleanup (stmt));\n-\t  gimple_try_set_cleanup (copy, new_seq);\n+\t  {\n+\t    gtry *try_stmt = as_a <gtry *> (stmt);\n+\t    gtry *try_copy = as_a <gtry *> (copy);\n+\t    new_seq = gimple_seq_copy (gimple_try_eval (try_stmt));\n+\t    gimple_try_set_eval (try_copy, new_seq);\n+\t    new_seq = gimple_seq_copy (gimple_try_cleanup (try_stmt));\n+\t    gimple_try_set_cleanup (try_copy, new_seq);\n+\t  }\n \t  break;\n \n \tcase GIMPLE_OMP_FOR:\n@@ -1702,8 +1743,7 @@ gimple_copy (gimple stmt)\n \t  t = unshare_expr (gimple_omp_for_clauses (stmt));\n \t  gimple_omp_for_set_clauses (copy, t);\n \t  {\n-\t    gimple_statement_omp_for *omp_for_copy =\n-\t      as_a <gimple_statement_omp_for *> (copy);\n+\t    gomp_for *omp_for_copy = as_a <gomp_for *> (copy);\n \t    omp_for_copy->iter = ggc_vec_alloc<gimple_omp_for_iter>\n \t      ( gimple_omp_for_collapse (stmt));\n           }\n@@ -1723,12 +1763,16 @@ gimple_copy (gimple stmt)\n \t  goto copy_omp_body;\n \n \tcase GIMPLE_OMP_PARALLEL:\n-\t  t = unshare_expr (gimple_omp_parallel_clauses (stmt));\n-\t  gimple_omp_parallel_set_clauses (copy, t);\n-\t  t = unshare_expr (gimple_omp_parallel_child_fn (stmt));\n-\t  gimple_omp_parallel_set_child_fn (copy, t);\n-\t  t = unshare_expr (gimple_omp_parallel_data_arg (stmt));\n-\t  gimple_omp_parallel_set_data_arg (copy, t);\n+\t  {\n+\t    gomp_parallel *omp_par_stmt = as_a <gomp_parallel *> (stmt);\n+\t    gomp_parallel *omp_par_copy = as_a <gomp_parallel *> (copy);\n+\t    t = unshare_expr (gimple_omp_parallel_clauses (omp_par_stmt));\n+\t    gimple_omp_parallel_set_clauses (omp_par_copy, t);\n+\t    t = unshare_expr (gimple_omp_parallel_child_fn (omp_par_stmt));\n+\t    gimple_omp_parallel_set_child_fn (omp_par_copy, t);\n+\t    t = unshare_expr (gimple_omp_parallel_data_arg (omp_par_stmt));\n+\t    gimple_omp_parallel_set_data_arg (omp_par_copy, t);\n+\t  }\n \t  goto copy_omp_body;\n \n \tcase GIMPLE_OMP_TASK:\n@@ -1747,8 +1791,9 @@ gimple_copy (gimple stmt)\n \t  goto copy_omp_body;\n \n \tcase GIMPLE_OMP_CRITICAL:\n-\t  t = unshare_expr (gimple_omp_critical_name (stmt));\n-\t  gimple_omp_critical_set_name (copy, t);\n+\t  t = unshare_expr (gimple_omp_critical_name (\n+\t\t\t      as_a <gomp_critical *> (stmt)));\n+\t  gimple_omp_critical_set_name (as_a <gomp_critical *> (copy), t);\n \t  goto copy_omp_body;\n \n \tcase GIMPLE_OMP_SECTIONS:\n@@ -1771,8 +1816,10 @@ gimple_copy (gimple stmt)\n \t  break;\n \n \tcase GIMPLE_TRANSACTION:\n-\t  new_seq = gimple_seq_copy (gimple_transaction_body (stmt));\n-\t  gimple_transaction_set_body (copy, new_seq);\n+\t  new_seq = gimple_seq_copy (gimple_transaction_body (\n+\t\t\t\t       as_a <gtransaction *> (stmt)));\n+\t  gimple_transaction_set_body (as_a <gtransaction *> (copy),\n+\t\t\t\t       new_seq);\n \t  break;\n \n \tcase GIMPLE_WITH_CLEANUP_EXPR:\n@@ -1827,7 +1874,7 @@ gimple_has_side_effects (const_gimple s)\n     return true;\n \n   if (gimple_code (s) == GIMPLE_ASM\n-      && gimple_asm_volatile_p (s))\n+      && gimple_asm_volatile_p (as_a <const gasm *> (s)))\n     return true;\n \n   if (is_gimple_call (s))\n@@ -1868,7 +1915,7 @@ gimple_could_trap_p_1 (gimple s, bool include_mem, bool include_stores)\n   switch (gimple_code (s))\n     {\n     case GIMPLE_ASM:\n-      return gimple_asm_volatile_p (s);\n+      return gimple_asm_volatile_p (as_a <gasm *> (s));\n \n     case GIMPLE_CALL:\n       t = gimple_call_fndecl (s);\n@@ -2041,13 +2088,13 @@ canonicalize_cond_expr_cond (tree t)\n /* Build a GIMPLE_CALL identical to STMT but skipping the arguments in\n    the positions marked by the set ARGS_TO_SKIP.  */\n \n-gimple\n-gimple_call_copy_skip_args (gimple stmt, bitmap args_to_skip)\n+gcall *\n+gimple_call_copy_skip_args (gcall *stmt, bitmap args_to_skip)\n {\n   int i;\n   int nargs = gimple_call_num_args (stmt);\n   auto_vec<tree> vargs (nargs);\n-  gimple new_stmt;\n+  gcall *new_stmt;\n \n   for (i = 0; i < nargs; i++)\n     if (!bitmap_bit_p (args_to_skip, i))\n@@ -2493,7 +2540,7 @@ gimple_call_builtin_p (const_gimple stmt, enum built_in_function code)\n    GIMPLE_ASM.  */\n \n bool\n-gimple_asm_clobbers_memory_p (const_gimple stmt)\n+gimple_asm_clobbers_memory_p (const gasm *stmt)\n {\n   unsigned i;\n \n@@ -2652,13 +2699,13 @@ infer_nonnull_range (gimple stmt, tree op, bool dereference, bool attribute)\n \n   /* If this function is marked as returning non-null, then we can\n      infer OP is non-null if it is used in the return statement.  */\n-  if (attribute\n-      && gimple_code (stmt) == GIMPLE_RETURN\n-      && gimple_return_retval (stmt)\n-      && operand_equal_p (gimple_return_retval (stmt), op, 0)\n-      && lookup_attribute (\"returns_nonnull\",\n-\t\t\t   TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl))))\n-    return true;\n+  if (attribute)\n+    if (greturn *return_stmt = dyn_cast <greturn *> (stmt))\n+      if (gimple_return_retval (return_stmt)\n+\t  && operand_equal_p (gimple_return_retval (return_stmt), op, 0)\n+\t  && lookup_attribute (\"returns_nonnull\",\n+\t\t\t       TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl))))\n+\treturn true;\n \n   return false;\n }"}, {"sha": "9380211bdd94479ba85601611cfa460bb0d1a522", "filename": "gcc/gimple.h", "status": "modified", "additions": 636, "deletions": 744, "changes": 1380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a"}, {"sha": "9d969de7fc98a30730d57db872b3b0748a3327aa", "filename": "gcc/gimplify-me.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimplify-me.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimplify-me.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify-me.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -177,30 +177,35 @@ gimple_regimplify_operands (gimple stmt, gimple_stmt_iterator *gsi_p)\n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_COND:\n-      gimplify_expr (gimple_cond_lhs_ptr (stmt), &pre, NULL,\n-\t\t     is_gimple_val, fb_rvalue);\n-      gimplify_expr (gimple_cond_rhs_ptr (stmt), &pre, NULL,\n-\t\t     is_gimple_val, fb_rvalue);\n+      {\n+\tgcond *cond_stmt = as_a <gcond *> (stmt);\n+\tgimplify_expr (gimple_cond_lhs_ptr (cond_stmt), &pre, NULL,\n+\t\t       is_gimple_val, fb_rvalue);\n+\tgimplify_expr (gimple_cond_rhs_ptr (cond_stmt), &pre, NULL,\n+\t\t       is_gimple_val, fb_rvalue);\n+      }\n       break;\n     case GIMPLE_SWITCH:\n-      gimplify_expr (gimple_switch_index_ptr (stmt), &pre, NULL,\n-\t\t     is_gimple_val, fb_rvalue);\n+      gimplify_expr (gimple_switch_index_ptr (as_a <gswitch *> (stmt)),\n+\t\t     &pre, NULL, is_gimple_val, fb_rvalue);\n       break;\n     case GIMPLE_OMP_ATOMIC_LOAD:\n-      gimplify_expr (gimple_omp_atomic_load_rhs_ptr (stmt), &pre, NULL,\n-\t\t     is_gimple_val, fb_rvalue);\n+      gimplify_expr (gimple_omp_atomic_load_rhs_ptr (\n+\t\t       as_a <gomp_atomic_load *> (stmt)),\n+\t\t     &pre, NULL, is_gimple_val, fb_rvalue);\n       break;\n     case GIMPLE_ASM:\n       {\n-\tsize_t i, noutputs = gimple_asm_noutputs (stmt);\n+\tgasm *asm_stmt = as_a <gasm *> (stmt);\n+\tsize_t i, noutputs = gimple_asm_noutputs (asm_stmt);\n \tconst char *constraint, **oconstraints;\n \tbool allows_mem, allows_reg, is_inout;\n \n \toconstraints\n \t  = (const char **) alloca ((noutputs) * sizeof (const char *));\n \tfor (i = 0; i < noutputs; i++)\n \t  {\n-\t    tree op = gimple_asm_output_op (stmt, i);\n+\t    tree op = gimple_asm_output_op (asm_stmt, i);\n \t    constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (op)));\n \t    oconstraints[i] = constraint;\n \t    parse_output_constraint (&constraint, i, 0, 0, &allows_mem,\n@@ -209,9 +214,9 @@ gimple_regimplify_operands (gimple stmt, gimple_stmt_iterator *gsi_p)\n \t\t\t   is_inout ? is_gimple_min_lval : is_gimple_lvalue,\n \t\t\t   fb_lvalue | fb_mayfail);\n \t  }\n-\tfor (i = 0; i < gimple_asm_ninputs (stmt); i++)\n+\tfor (i = 0; i < gimple_asm_ninputs (asm_stmt); i++)\n \t  {\n-\t    tree op = gimple_asm_input_op (stmt, i);\n+\t    tree op = gimple_asm_input_op (asm_stmt, i);\n \t    constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (op)));\n \t    parse_input_constraint (&constraint, 0, 0, noutputs, 0,\n \t\t\t\t    oconstraints, &allows_mem, &allows_reg);"}, {"sha": "8e3dd834a01fb053d6e4bef876536ab9becae74e", "filename": "gcc/gimplify.c", "status": "modified", "additions": 76, "deletions": 71, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -124,7 +124,7 @@ struct gimplify_ctx\n {\n   struct gimplify_ctx *prev_context;\n \n-  vec<gimple> bind_expr_stack;\n+  vec<gbind *> bind_expr_stack;\n   tree temps;\n   gimple_seq conditional_cleanups;\n   tree exit_label;\n@@ -275,10 +275,10 @@ pop_gimplify_context (gimple body)\n /* Push a GIMPLE_BIND tuple onto the stack of bindings.  */\n \n static void\n-gimple_push_bind_expr (gimple gimple_bind)\n+gimple_push_bind_expr (gbind *bind_stmt)\n {\n   gimplify_ctxp->bind_expr_stack.reserve (8);\n-  gimplify_ctxp->bind_expr_stack.safe_push (gimple_bind);\n+  gimplify_ctxp->bind_expr_stack.safe_push (bind_stmt);\n }\n \n /* Pop the first element off the stack of bindings.  */\n@@ -291,15 +291,15 @@ gimple_pop_bind_expr (void)\n \n /* Return the first element of the stack of bindings.  */\n \n-gimple\n+gbind *\n gimple_current_bind_expr (void)\n {\n   return gimplify_ctxp->bind_expr_stack.last ();\n }\n \n /* Return the stack of bindings created during gimplification.  */\n \n-vec<gimple> \n+vec<gbind *>\n gimple_bind_expr_stack (void)\n {\n   return gimplify_ctxp->bind_expr_stack;\n@@ -576,14 +576,14 @@ get_initialized_tmp_var (tree val, gimple_seq *pre_p, gimple_seq *post_p)\n    generate debug info for them; otherwise don't.  */\n \n void\n-declare_vars (tree vars, gimple scope, bool debug_info)\n+declare_vars (tree vars, gimple gs, bool debug_info)\n {\n   tree last = vars;\n   if (last)\n     {\n       tree temps, block;\n \n-      gcc_assert (gimple_code (scope) == GIMPLE_BIND);\n+      gbind *scope = as_a <gbind *> (gs);\n \n       temps = nreverse (last);\n \n@@ -1033,7 +1033,7 @@ voidify_wrapper_expr (tree wrapper, tree temp)\n    a temporary through which they communicate.  */\n \n static void\n-build_stack_save_restore (gimple *save, gimple *restore)\n+build_stack_save_restore (gcall **save, gcall **restore)\n {\n   tree tmp_var;\n \n@@ -1054,9 +1054,9 @@ gimplify_bind_expr (tree *expr_p, gimple_seq *pre_p)\n   tree bind_expr = *expr_p;\n   bool old_save_stack = gimplify_ctxp->save_stack;\n   tree t;\n-  gimple gimple_bind;\n+  gbind *bind_stmt;\n   gimple_seq body, cleanup;\n-  gimple stack_save;\n+  gcall *stack_save;\n   location_t start_locus = 0, end_locus = 0;\n \n   tree temp = voidify_wrapper_expr (bind_expr, NULL);\n@@ -1099,16 +1099,16 @@ gimplify_bind_expr (tree *expr_p, gimple_seq *pre_p)\n \tDECL_GIMPLE_REG_P (t) = 1;\n     }\n \n-  gimple_bind = gimple_build_bind (BIND_EXPR_VARS (bind_expr), NULL,\n+  bind_stmt = gimple_build_bind (BIND_EXPR_VARS (bind_expr), NULL,\n                                    BIND_EXPR_BLOCK (bind_expr));\n-  gimple_push_bind_expr (gimple_bind);\n+  gimple_push_bind_expr (bind_stmt);\n \n   gimplify_ctxp->save_stack = false;\n \n   /* Gimplify the body into the GIMPLE_BIND tuple's body.  */\n   body = NULL;\n   gimplify_stmt (&BIND_EXPR_BODY (bind_expr), &body);\n-  gimple_bind_set_body (gimple_bind, body);\n+  gimple_bind_set_body (bind_stmt, body);\n \n   /* Source location wise, the cleanup code (stack_restore and clobbers)\n      belongs to the end of the block, so propagate what we have.  The\n@@ -1127,7 +1127,7 @@ gimplify_bind_expr (tree *expr_p, gimple_seq *pre_p)\n   stack_save = NULL;\n   if (gimplify_ctxp->save_stack)\n     {\n-      gimple stack_restore;\n+      gcall *stack_restore;\n \n       /* Save stack on entry and restore it on exit.  Add a try_finally\n \t block to achieve this.  */\n@@ -1164,23 +1164,23 @@ gimplify_bind_expr (tree *expr_p, gimple_seq *pre_p)\n \n   if (cleanup)\n     {\n-      gimple gs;\n+      gtry *gs;\n       gimple_seq new_body;\n \n       new_body = NULL;\n-      gs = gimple_build_try (gimple_bind_body (gimple_bind), cleanup,\n+      gs = gimple_build_try (gimple_bind_body (bind_stmt), cleanup,\n \t  \t\t     GIMPLE_TRY_FINALLY);\n \n       if (stack_save)\n \tgimplify_seq_add_stmt (&new_body, stack_save);\n       gimplify_seq_add_stmt (&new_body, gs);\n-      gimple_bind_set_body (gimple_bind, new_body);\n+      gimple_bind_set_body (bind_stmt, new_body);\n     }\n \n   gimplify_ctxp->save_stack = old_save_stack;\n   gimple_pop_bind_expr ();\n \n-  gimplify_seq_add_stmt (pre_p, gimple_bind);\n+  gimplify_seq_add_stmt (pre_p, bind_stmt);\n \n   if (temp)\n     {\n@@ -1202,7 +1202,7 @@ gimplify_bind_expr (tree *expr_p, gimple_seq *pre_p)\n static enum gimplify_status\n gimplify_return_expr (tree stmt, gimple_seq *pre_p)\n {\n-  gimple ret;\n+  greturn *ret;\n   tree ret_expr = TREE_OPERAND (stmt, 0);\n   tree result_decl, result;\n \n@@ -1222,7 +1222,7 @@ gimplify_return_expr (tree stmt, gimple_seq *pre_p)\n       || TREE_CODE (ret_expr) == RESULT_DECL\n       || ret_expr == error_mark_node)\n     {\n-      gimple ret = gimple_build_return (ret_expr);\n+      greturn *ret = gimple_build_return (ret_expr);\n       gimple_set_no_warning (ret, TREE_NO_WARNING (stmt));\n       gimplify_seq_add_stmt (pre_p, ret);\n       return GS_ALL_DONE;\n@@ -1495,7 +1495,7 @@ gimplify_switch_expr (tree *expr_p, gimple_seq *pre_p)\n       vec<tree> labels;\n       vec<tree> saved_labels;\n       tree default_case = NULL_TREE;\n-      gimple gimple_switch;\n+      gswitch *switch_stmt;\n \n       /* If someone can be bothered to fill in the labels, they can\n \t be bothered to null out the body too.  */\n@@ -1515,7 +1515,7 @@ gimplify_switch_expr (tree *expr_p, gimple_seq *pre_p)\n \n       if (!default_case)\n \t{\n-\t  gimple new_default;\n+\t  glabel *new_default;\n \n \t  default_case\n \t    = build_case_label (NULL_TREE, NULL_TREE,\n@@ -1524,9 +1524,9 @@ gimplify_switch_expr (tree *expr_p, gimple_seq *pre_p)\n \t  gimplify_seq_add_stmt (&switch_body_seq, new_default);\n \t}\n \n-      gimple_switch = gimple_build_switch (SWITCH_COND (switch_expr),\n+      switch_stmt = gimple_build_switch (SWITCH_COND (switch_expr),\n \t\t\t\t\t   default_case, labels);\n-      gimplify_seq_add_stmt (pre_p, gimple_switch);\n+      gimplify_seq_add_stmt (pre_p, switch_stmt);\n       gimplify_seq_add_seq (pre_p, switch_body_seq);\n       labels.release ();\n     }\n@@ -1542,7 +1542,7 @@ static enum gimplify_status\n gimplify_case_label_expr (tree *expr_p, gimple_seq *pre_p)\n {\n   struct gimplify_ctx *ctxp;\n-  gimple gimple_label;\n+  glabel *label_stmt;\n \n   /* Invalid OpenMP programs can play Duff's Device type games with\n      #pragma omp parallel.  At least in the C front end, we don't\n@@ -1551,9 +1551,9 @@ gimplify_case_label_expr (tree *expr_p, gimple_seq *pre_p)\n     if (ctxp->case_labels.exists ())\n       break;\n \n-  gimple_label = gimple_build_label (CASE_LABEL (*expr_p));\n+  label_stmt = gimple_build_label (CASE_LABEL (*expr_p));\n   ctxp->case_labels.safe_push (*expr_p);\n-  gimplify_seq_add_stmt (pre_p, gimple_label);\n+  gimplify_seq_add_stmt (pre_p, label_stmt);\n \n   return GS_ALL_DONE;\n }\n@@ -2267,7 +2267,7 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n   tree fndecl, parms, p, fnptrtype;\n   enum gimplify_status ret;\n   int i, nargs;\n-  gimple call;\n+  gcall *call;\n   bool builtin_va_start_p = false;\n   location_t loc = EXPR_LOCATION (*expr_p);\n \n@@ -2990,7 +2990,7 @@ gimplify_cond_expr (tree *expr_p, gimple_seq *pre_p, fallback_t fallback)\n   enum gimplify_status ret;\n   tree label_true, label_false, label_cont;\n   bool have_then_clause_p, have_else_clause_p;\n-  gimple gimple_cond;\n+  gcond *cond_stmt;\n   enum tree_code pred_code;\n   gimple_seq seq = NULL;\n \n@@ -3139,10 +3139,10 @@ gimplify_cond_expr (tree *expr_p, gimple_seq *pre_p, fallback_t fallback)\n   gimple_cond_get_ops_from_tree (COND_EXPR_COND (expr), &pred_code, &arm1,\n \t\t\t\t &arm2);\n \n-  gimple_cond = gimple_build_cond (pred_code, arm1, arm2, label_true,\n+  cond_stmt = gimple_build_cond (pred_code, arm1, arm2, label_true,\n                                    label_false);\n \n-  gimplify_seq_add_stmt (&seq, gimple_cond);\n+  gimplify_seq_add_stmt (&seq, cond_stmt);\n   label_cont = NULL_TREE;\n   if (!have_then_clause_p)\n     {\n@@ -3238,7 +3238,7 @@ gimplify_modify_expr_to_memcpy (tree *expr_p, tree size, bool want_value,\n     \t\t\t\tgimple_seq *seq_p)\n {\n   tree t, to, to_ptr, from, from_ptr;\n-  gimple gs;\n+  gcall *gs;\n   location_t loc = EXPR_LOCATION (*expr_p);\n \n   to = TREE_OPERAND (*expr_p, 0);\n@@ -3285,7 +3285,7 @@ gimplify_modify_expr_to_memset (tree *expr_p, tree size, bool want_value,\n     \t\t\t\tgimple_seq *seq_p)\n {\n   tree t, from, to, to_ptr;\n-  gimple gs;\n+  gcall *gs;\n   location_t loc = EXPR_LOCATION (*expr_p);\n \n   /* Assert our assumptions, to abort instead of producing wrong code\n@@ -4101,7 +4101,7 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t{\n \t  tree lhs = TREE_OPERAND (*expr_p, 0);\n \t  tree rhs = TREE_OPERAND (*expr_p, 1);\n-\t  gimple init = gimple_build_assign (lhs, rhs);\n+\t  gassign *init = gimple_build_assign (lhs, rhs);\n \t  gimplify_seq_add_stmt (pre_p, init);\n \t  *expr_p = NULL;\n \t}\n@@ -4662,6 +4662,7 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n     {\n       /* Since the RHS is a CALL_EXPR, we need to create a GIMPLE_CALL\n \t instead of a GIMPLE_ASSIGN.  */\n+      gcall *call_stmt;\n       if (CALL_EXPR_FN (*from_p) == NULL_TREE)\n \t{\n \t  /* Gimplify internal functions created in the FEs.  */\n@@ -4675,8 +4676,8 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t\t\t    EXPR_LOCATION (*from_p));\n \t      vargs.quick_push (CALL_EXPR_ARG (*from_p, i));\n \t    }\n-\t  assign = gimple_build_call_internal_vec (ifn, vargs);\n-\t  gimple_set_location (assign, EXPR_LOCATION (*expr_p));\n+\t  call_stmt = gimple_build_call_internal_vec (ifn, vargs);\n+\t  gimple_set_location (call_stmt, EXPR_LOCATION (*expr_p));\n \t}\n       else\n \t{\n@@ -4688,19 +4689,20 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n \t      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_EXPECT\n \t      && call_expr_nargs (*from_p) == 3)\n-\t    assign = gimple_build_call_internal (IFN_BUILTIN_EXPECT, 3,\n-\t\t\t\t\t\t CALL_EXPR_ARG (*from_p, 0),\n-\t\t\t\t\t\t CALL_EXPR_ARG (*from_p, 1),\n-\t\t\t\t\t\t CALL_EXPR_ARG (*from_p, 2));\n+\t    call_stmt = gimple_build_call_internal (IFN_BUILTIN_EXPECT, 3,\n+\t\t\t\t\t\t    CALL_EXPR_ARG (*from_p, 0),\n+\t\t\t\t\t\t    CALL_EXPR_ARG (*from_p, 1),\n+\t\t\t\t\t\t    CALL_EXPR_ARG (*from_p, 2));\n \t  else\n \t    {\n-\t      assign = gimple_build_call_from_tree (*from_p);\n-\t      gimple_call_set_fntype (assign, TREE_TYPE (fnptrtype));\n+\t      call_stmt = gimple_build_call_from_tree (*from_p);\n+\t      gimple_call_set_fntype (call_stmt, TREE_TYPE (fnptrtype));\n \t    }\n \t}\n-      notice_special_calls (assign);\n-      if (!gimple_call_noreturn_p (assign))\n-\tgimple_call_set_lhs (assign, *to_p);\n+      notice_special_calls (call_stmt);\n+      if (!gimple_call_noreturn_p (call_stmt))\n+\tgimple_call_set_lhs (call_stmt, *to_p);\n+      assign = call_stmt;\n     }\n   else\n     {\n@@ -4979,7 +4981,7 @@ gimplify_asm_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n   const char *constraint;\n   bool allows_mem, allows_reg, is_inout;\n   enum gimplify_status ret, tret;\n-  gimple stmt;\n+  gasm *stmt;\n   vec<tree, va_gc> *inputs;\n   vec<tree, va_gc> *outputs;\n   vec<tree, va_gc> *clobbers;\n@@ -5269,7 +5271,7 @@ gimplify_cleanup_point_expr (tree *expr_p, gimple_seq *pre_p)\n \t    }\n \t  else\n \t    {\n-\t      gimple_statement_try *gtry;\n+\t      gtry *gtry;\n \t      gimple_seq seq;\n \t      enum gimple_try_flags kind;\n \n@@ -5341,8 +5343,8 @@ gimple_push_cleanup (tree var, tree cleanup, bool eh_only, gimple_seq *pre_p)\n \t   val\n       */\n       tree flag = create_tmp_var (boolean_type_node, \"cleanup\");\n-      gimple ffalse = gimple_build_assign (flag, boolean_false_node);\n-      gimple ftrue = gimple_build_assign (flag, boolean_true_node);\n+      gassign *ffalse = gimple_build_assign (flag, boolean_false_node);\n+      gassign *ftrue = gimple_build_assign (flag, boolean_true_node);\n \n       cleanup = build3 (COND_EXPR, void_type_node, flag, cleanup, NULL);\n       gimplify_stmt (&cleanup, &cleanup_stmts);\n@@ -6769,7 +6771,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n   tree for_stmt, orig_for_stmt, decl, var, t;\n   enum gimplify_status ret = GS_ALL_DONE;\n   enum gimplify_status tret;\n-  gimple gfor;\n+  gomp_for *gfor;\n   gimple_seq for_body, for_pre_body;\n   int i;\n   bool simd;\n@@ -7241,7 +7243,7 @@ static void\n gimplify_omp_target_update (tree *expr_p, gimple_seq *pre_p)\n {\n   tree expr = *expr_p;\n-  gimple stmt;\n+  gomp_target *stmt;\n \n   gimplify_scan_omp_clauses (&OMP_TARGET_UPDATE_CLAUSES (expr), pre_p,\n \t\t\t     ORT_WORKSHARE);\n@@ -7369,7 +7371,8 @@ gimplify_omp_atomic (tree *expr_p, gimple_seq *pre_p)\n \t     ? NULL : TREE_OPERAND (*expr_p, 1);\n   tree type = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (addr)));\n   tree tmp_load;\n-  gimple loadstmt, storestmt;\n+  gomp_atomic_load *loadstmt;\n+  gomp_atomic_store *storestmt;\n \n   tmp_load = create_tmp_reg (type, NULL);\n   if (rhs && goa_stabilize_expr (&rhs, pre_p, addr, tmp_load) < 0)\n@@ -7420,7 +7423,8 @@ static enum gimplify_status\n gimplify_transaction (tree *expr_p, gimple_seq *pre_p)\n {\n   tree expr = *expr_p, temp, tbody = TRANSACTION_EXPR_BODY (expr);\n-  gimple g;\n+  gimple body_stmt;\n+  gtransaction *trans_stmt;\n   gimple_seq body = NULL;\n   int subcode = 0;\n \n@@ -7437,17 +7441,17 @@ gimplify_transaction (tree *expr_p, gimple_seq *pre_p)\n   push_gimplify_context ();\n   temp = voidify_wrapper_expr (*expr_p, NULL);\n \n-  g = gimplify_and_return_first (TRANSACTION_EXPR_BODY (expr), &body);\n-  pop_gimplify_context (g);\n+  body_stmt = gimplify_and_return_first (TRANSACTION_EXPR_BODY (expr), &body);\n+  pop_gimplify_context (body_stmt);\n \n-  g = gimple_build_transaction (body, NULL);\n+  trans_stmt = gimple_build_transaction (body, NULL);\n   if (TRANSACTION_EXPR_OUTER (expr))\n     subcode = GTMA_IS_OUTER;\n   else if (TRANSACTION_EXPR_RELAXED (expr))\n     subcode = GTMA_IS_RELAXED;\n-  gimple_transaction_set_subcode (g, subcode);\n+  gimple_transaction_set_subcode (trans_stmt, subcode);\n \n-  gimplify_seq_add_stmt (pre_p, g);\n+  gimplify_seq_add_stmt (pre_p, trans_stmt);\n \n   if (temp)\n     {\n@@ -7789,7 +7793,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t      }\n \t    tree tmp = create_tmp_var (type, NULL);\n \t    gimplify_arg (&cond, pre_p, EXPR_LOCATION (*expr_p));\n-\t    gimple call\n+\t    gcall *call\n \t      = gimple_build_call_internal (IFN_ANNOTATE, 2, cond, kind);\n \t    gimple_call_set_lhs (call, tmp);\n \t    gimplify_seq_add_stmt (pre_p, call);\n@@ -8052,7 +8056,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \tcase TRY_CATCH_EXPR:\n \t  {\n \t    gimple_seq eval, cleanup;\n-\t    gimple try_;\n+\t    gtry *try_;\n \n \t    /* Calls to destructors are generated automatically in FINALLY/CATCH\n \t       block. They should have location as UNKNOWN_LOCATION. However,\n@@ -8791,12 +8795,13 @@ gimplify_one_sizepos (tree *expr_p, gimple_seq *stmt_p)\n    containing the sequence of corresponding GIMPLE statements.  If DO_PARMS\n    is true, also gimplify the parameters.  */\n \n-gimple\n+gbind *\n gimplify_body (tree fndecl, bool do_parms)\n {\n   location_t saved_location = input_location;\n   gimple_seq parm_stmts, seq;\n-  gimple outer_bind;\n+  gimple outer_stmt;\n+  gbind *outer_bind;\n   struct cgraph_node *cgn;\n \n   timevar_push (TV_TREE_GIMPLIFY);\n@@ -8836,18 +8841,18 @@ gimplify_body (tree fndecl, bool do_parms)\n   /* Gimplify the function's body.  */\n   seq = NULL;\n   gimplify_stmt (&DECL_SAVED_TREE (fndecl), &seq);\n-  outer_bind = gimple_seq_first_stmt (seq);\n-  if (!outer_bind)\n+  outer_stmt = gimple_seq_first_stmt (seq);\n+  if (!outer_stmt)\n     {\n-      outer_bind = gimple_build_nop ();\n-      gimplify_seq_add_stmt (&seq, outer_bind);\n+      outer_stmt = gimple_build_nop ();\n+      gimplify_seq_add_stmt (&seq, outer_stmt);\n     }\n \n   /* The body must contain exactly one statement, a GIMPLE_BIND.  If this is\n      not the case, wrap everything in a GIMPLE_BIND to make it so.  */\n-  if (gimple_code (outer_bind) == GIMPLE_BIND\n+  if (gimple_code (outer_stmt) == GIMPLE_BIND\n       && gimple_seq_first (seq) == gimple_seq_last (seq))\n-    ;\n+    outer_bind = as_a <gbind *> (outer_stmt);\n   else\n     outer_bind = gimple_build_bind (NULL_TREE, seq, NULL);\n \n@@ -8961,7 +8966,7 @@ gimplify_function_tree (tree fndecl)\n {\n   tree parm, ret;\n   gimple_seq seq;\n-  gimple bind;\n+  gbind *bind;\n \n   gcc_assert (!gimple_body (fndecl));\n \n@@ -9005,11 +9010,11 @@ gimplify_function_tree (tree fndecl)\n       && !flag_instrument_functions_exclude_p (fndecl))\n     {\n       tree x;\n-      gimple new_bind;\n+      gbind *new_bind;\n       gimple tf;\n       gimple_seq cleanup = NULL, body = NULL;\n       tree tmp_var;\n-      gimple call;\n+      gcall *call;\n \n       x = builtin_decl_implicit (BUILT_IN_RETURN_ADDRESS);\n       call = gimple_build_call (x, 1, integer_zero_node);"}, {"sha": "16cd725e6b78450c290307074eeae968d5c4beb8", "filename": "gcc/gimplify.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimplify.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgimplify.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -53,8 +53,8 @@ extern void free_gimplify_stack (void);\n extern void push_gimplify_context (bool in_ssa = false,\n \t\t\t\t   bool rhs_cond_ok = false);\n extern void pop_gimplify_context (gimple);\n-extern gimple gimple_current_bind_expr (void);\n-extern vec<gimple> gimple_bind_expr_stack (void);\n+extern gbind *gimple_current_bind_expr (void);\n+extern vec<gbind *> gimple_bind_expr_stack (void);\n extern void gimplify_and_add (tree, gimple_seq *);\n extern tree get_formal_tmp_var (tree, gimple_seq *);\n extern tree get_initialized_tmp_var (tree, gimple_seq *, gimple_seq *);\n@@ -76,7 +76,7 @@ extern enum gimplify_status gimplify_expr (tree *, gimple_seq *, gimple_seq *,\n \n extern void gimplify_type_sizes (tree, gimple_seq *);\n extern void gimplify_one_sizepos (tree *, gimple_seq *);\n-extern gimple gimplify_body (tree, bool);\n+extern gbind *gimplify_body (tree, bool);\n extern enum gimplify_status gimplify_arg (tree *, gimple_seq *, location_t);\n extern void gimplify_function_tree (tree);\n extern enum gimplify_status gimplify_va_arg_expr (tree *, gimple_seq *,"}, {"sha": "d49f57a811e6bbe479abbc4a8ab7603cb7e045ad", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -1262,7 +1262,7 @@ limit_scops (vec<scop_p> *scops)\n    argument.  */\n \n static inline bool\n-same_close_phi_node (gimple p1, gimple p2)\n+same_close_phi_node (gphi *p1, gphi *p2)\n {\n   return operand_equal_p (gimple_phi_arg_def (p1, 0),\n \t\t\t  gimple_phi_arg_def (p2, 0), 0);\n@@ -1272,15 +1272,15 @@ same_close_phi_node (gimple p1, gimple p2)\n    of PHI.  */\n \n static void\n-remove_duplicate_close_phi (gimple phi, gimple_stmt_iterator *gsi)\n+remove_duplicate_close_phi (gphi *phi, gphi_iterator *gsi)\n {\n   gimple use_stmt;\n   use_operand_p use_p;\n   imm_use_iterator imm_iter;\n   tree res = gimple_phi_result (phi);\n-  tree def = gimple_phi_result (gsi_stmt (*gsi));\n+  tree def = gimple_phi_result (gsi->phi ());\n \n-  gcc_assert (same_close_phi_node (phi, gsi_stmt (*gsi)));\n+  gcc_assert (same_close_phi_node (phi, gsi->phi ()));\n \n   FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, def)\n     {\n@@ -1305,20 +1305,20 @@ remove_duplicate_close_phi (gimple phi, gimple_stmt_iterator *gsi)\n static void\n make_close_phi_nodes_unique (basic_block bb)\n {\n-  gimple_stmt_iterator psi;\n+  gphi_iterator psi;\n \n   for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n     {\n-      gimple_stmt_iterator gsi = psi;\n-      gimple phi = gsi_stmt (psi);\n+      gphi_iterator gsi = psi;\n+      gphi *phi = psi.phi ();\n \n       /* At this point, PHI should be a close phi in normal form.  */\n       gcc_assert (gimple_phi_num_args (phi) == 1);\n \n       /* Iterate over the next phis and remove duplicates.  */\n       gsi_next (&gsi);\n       while (!gsi_end_p (gsi))\n-\tif (same_close_phi_node (phi, gsi_stmt (gsi)))\n+\tif (same_close_phi_node (phi, gsi.phi ()))\n \t  remove_duplicate_close_phi (phi, &gsi);\n \telse\n \t  gsi_next (&gsi);\n@@ -1345,22 +1345,22 @@ canonicalize_loop_closed_ssa (loop_p loop)\n     }\n   else\n     {\n-      gimple_stmt_iterator psi;\n+      gphi_iterator psi;\n       basic_block close = split_edge (e);\n \n       e = single_succ_edge (close);\n \n       for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n \t{\n-\t  gimple phi = gsi_stmt (psi);\n+\t  gphi *phi = psi.phi ();\n \t  unsigned i;\n \n \t  for (i = 0; i < gimple_phi_num_args (phi); i++)\n \t    if (gimple_phi_arg_edge (phi, i) == e)\n \t      {\n \t\ttree res, arg = gimple_phi_arg_def (phi, i);\n \t\tuse_operand_p use_p;\n-\t\tgimple close_phi;\n+\t\tgphi *close_phi;\n \n \t\tif (TREE_CODE (arg) != SSA_NAME)\n \t\t  continue;"}, {"sha": "bdeba166633582daff4d59b93ae8b6f63429ae4f", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 73, "deletions": 67, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -100,7 +100,7 @@ tree_int_to_gmp (tree t, mpz_t res)\n    loop.  */\n \n static size_t\n-phi_arg_in_outermost_loop (gimple phi)\n+phi_arg_in_outermost_loop (gphi *phi)\n {\n   loop_p loop = gimple_bb (phi)->loop_father;\n   size_t i, res = 0;\n@@ -119,13 +119,13 @@ phi_arg_in_outermost_loop (gimple phi)\n    PSI by inserting on the loop ENTRY edge assignment \"RES = INIT\".  */\n \n static void\n-remove_simple_copy_phi (gimple_stmt_iterator *psi)\n+remove_simple_copy_phi (gphi_iterator *psi)\n {\n-  gimple phi = gsi_stmt (*psi);\n+  gphi *phi = psi->phi ();\n   tree res = gimple_phi_result (phi);\n   size_t entry = phi_arg_in_outermost_loop (phi);\n   tree init = gimple_phi_arg_def (phi, entry);\n-  gimple stmt = gimple_build_assign (res, init);\n+  gassign *stmt = gimple_build_assign (res, init);\n   edge e = gimple_phi_arg_edge (phi, entry);\n \n   remove_phi_node (psi, false);\n@@ -136,16 +136,16 @@ remove_simple_copy_phi (gimple_stmt_iterator *psi)\n    loop ENTRY edge the assignment RES = INIT.  */\n \n static void\n-remove_invariant_phi (sese region, gimple_stmt_iterator *psi)\n+remove_invariant_phi (sese region, gphi_iterator *psi)\n {\n-  gimple phi = gsi_stmt (*psi);\n+  gphi *phi = psi->phi ();\n   loop_p loop = loop_containing_stmt (phi);\n   tree res = gimple_phi_result (phi);\n   tree scev = scalar_evolution_in_region (region, loop, res);\n   size_t entry = phi_arg_in_outermost_loop (phi);\n   edge e = gimple_phi_arg_edge (phi, entry);\n   tree var;\n-  gimple stmt;\n+  gassign *stmt;\n   gimple_seq stmts = NULL;\n \n   if (tree_contains_chrecs (scev, NULL))\n@@ -164,7 +164,7 @@ remove_invariant_phi (sese region, gimple_stmt_iterator *psi)\n /* Returns true when the phi node at PSI is of the form \"a = phi (a, x)\".  */\n \n static inline bool\n-simple_copy_phi_p (gimple phi)\n+simple_copy_phi_p (gphi *phi)\n {\n   tree res;\n \n@@ -181,10 +181,10 @@ simple_copy_phi_p (gimple phi)\n    be considered.  */\n \n static bool\n-reduction_phi_p (sese region, gimple_stmt_iterator *psi)\n+reduction_phi_p (sese region, gphi_iterator *psi)\n {\n   loop_p loop;\n-  gimple phi = gsi_stmt (*psi);\n+  gphi *phi = psi->phi ();\n   tree res = gimple_phi_result (phi);\n \n   loop = loop_containing_stmt (phi);\n@@ -1128,7 +1128,7 @@ create_pw_aff_from_tree (poly_bb_p pbb, tree t)\n    inequalities.  */\n \n static void\n-add_condition_to_pbb (poly_bb_p pbb, gimple stmt, enum tree_code code)\n+add_condition_to_pbb (poly_bb_p pbb, gcond *stmt, enum tree_code code)\n {\n   isl_pw_aff *lhs = create_pw_aff_from_tree (pbb, gimple_cond_lhs (stmt));\n   isl_pw_aff *rhs = create_pw_aff_from_tree (pbb, gimple_cond_rhs (stmt));\n@@ -1188,13 +1188,14 @@ add_conditions_to_domain (poly_bb_p pbb)\n       {\n       case GIMPLE_COND:\n \t  {\n-\t    enum tree_code code = gimple_cond_code (stmt);\n+\t    gcond *cond_stmt = as_a <gcond *> (stmt);\n+\t    enum tree_code code = gimple_cond_code (cond_stmt);\n \n \t    /* The conditions for ELSE-branches are inverted.  */\n \t    if (!GBB_CONDITION_CASES (gbb)[i])\n \t      code = invert_tree_comparison (code, false);\n \n-\t    add_condition_to_pbb (pbb, stmt, code);\n+\t    add_condition_to_pbb (pbb, cond_stmt, code);\n \t    break;\n \t  }\n \n@@ -1224,7 +1225,7 @@ add_conditions_to_constraints (scop_p scop)\n    edge between BB and its predecessor is not a loop exit edge, and\n    the last statement of the single predecessor is a COND_EXPR.  */\n \n-static gimple\n+static gcond *\n single_pred_cond_non_loop_exit (basic_block bb)\n {\n   if (single_pred_p (bb))\n@@ -1239,7 +1240,7 @@ single_pred_cond_non_loop_exit (basic_block bb)\n       stmt = last_stmt (pred);\n \n       if (stmt && gimple_code (stmt) == GIMPLE_COND)\n-\treturn stmt;\n+\treturn as_a <gcond *> (stmt);\n     }\n \n   return NULL;\n@@ -1270,7 +1271,7 @@ void\n sese_dom_walker::before_dom_children (basic_block bb)\n {\n   gimple_bb_p gbb;\n-  gimple stmt;\n+  gcond *stmt;\n \n   if (!bb_in_sese_p (bb, m_region))\n     return;\n@@ -1936,14 +1937,14 @@ build_scop_drs (scop_p scop)\n \n /* Return a gsi at the position of the phi node STMT.  */\n \n-static gimple_stmt_iterator\n-gsi_for_phi_node (gimple stmt)\n+static gphi_iterator\n+gsi_for_phi_node (gphi *stmt)\n {\n-  gimple_stmt_iterator psi;\n+  gphi_iterator psi;\n   basic_block bb = gimple_bb (stmt);\n \n   for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n-    if (stmt == gsi_stmt (psi))\n+    if (stmt == psi.phi ())\n       return psi;\n \n   gcc_unreachable ();\n@@ -2011,7 +2012,7 @@ insert_out_of_ssa_copy (scop_p scop, tree res, tree expr, gimple after_stmt)\n   gimple_seq stmts;\n   gimple_stmt_iterator gsi;\n   tree var = force_gimple_operand (expr, &stmts, true, NULL_TREE);\n-  gimple stmt = gimple_build_assign (unshare_expr (res), var);\n+  gassign *stmt = gimple_build_assign (unshare_expr (res), var);\n   auto_vec<gimple, 3> x;\n \n   gimple_seq_add_stmt (&stmts, stmt);\n@@ -2240,10 +2241,10 @@ rewrite_close_phi_out_of_ssa (scop_p scop, gimple_stmt_iterator *psi)\n    dimension array for it.  */\n \n static void\n-rewrite_phi_out_of_ssa (scop_p scop, gimple_stmt_iterator *psi)\n+rewrite_phi_out_of_ssa (scop_p scop, gphi_iterator *psi)\n {\n   size_t i;\n-  gimple phi = gsi_stmt (*psi);\n+  gphi *phi = psi->phi ();\n   basic_block bb = gimple_bb (phi);\n   tree res = gimple_phi_result (phi);\n   tree zero_dim_array = create_zero_dim_array (res, \"phi_out_of_ssa\");\n@@ -2274,12 +2275,12 @@ rewrite_phi_out_of_ssa (scop_p scop, gimple_stmt_iterator *psi)\n    form \"x = phi (y, y, ..., y)\" to \"x = y\".  */\n \n static void\n-rewrite_degenerate_phi (gimple_stmt_iterator *psi)\n+rewrite_degenerate_phi (gphi_iterator *psi)\n {\n   tree rhs;\n   gimple stmt;\n   gimple_stmt_iterator gsi;\n-  gimple phi = gsi_stmt (*psi);\n+  gphi *phi = psi->phi ();\n   tree res = gimple_phi_result (phi);\n   basic_block bb;\n \n@@ -2300,14 +2301,14 @@ static void\n rewrite_reductions_out_of_ssa (scop_p scop)\n {\n   basic_block bb;\n-  gimple_stmt_iterator psi;\n+  gphi_iterator psi;\n   sese region = SCOP_REGION (scop);\n \n   FOR_EACH_BB_FN (bb, cfun)\n     if (bb_in_sese_p (bb, region))\n       for (psi = gsi_start_phis (bb); !gsi_end_p (psi);)\n \t{\n-\t  gimple phi = gsi_stmt (psi);\n+\t  gphi *phi = psi.phi ();\n \n \t  if (virtual_operand_p (gimple_phi_result (phi)))\n \t    {\n@@ -2454,7 +2455,7 @@ rewrite_cross_bb_scalar_deps (scop_p scop, gimple_stmt_iterator *gsi)\n     if (gimple_code (use_stmt) == GIMPLE_PHI\n \t&& (res = true))\n       {\n-\tgimple_stmt_iterator psi = gsi_for_stmt (use_stmt);\n+\tgphi_iterator psi = gsi_start_phis (gimple_bb (use_stmt));\n \n \tif (scalar_close_phi_node_p (gsi_stmt (psi)))\n \t  rewrite_close_phi_out_of_ssa (scop, &psi);\n@@ -2623,7 +2624,7 @@ is_reduction_operation_p (gimple stmt)\n /* Returns true when PHI contains an argument ARG.  */\n \n static bool\n-phi_contains_arg (gimple phi, tree arg)\n+phi_contains_arg (gphi *phi, tree arg)\n {\n   size_t i;\n \n@@ -2636,7 +2637,7 @@ phi_contains_arg (gimple phi, tree arg)\n \n /* Return a loop phi node that corresponds to a reduction containing LHS.  */\n \n-static gimple\n+static gphi *\n follow_ssa_with_commutative_ops (tree arg, tree lhs)\n {\n   gimple stmt;\n@@ -2650,10 +2651,10 @@ follow_ssa_with_commutative_ops (tree arg, tree lhs)\n       || gimple_code (stmt) == GIMPLE_CALL)\n     return NULL;\n \n-  if (gimple_code (stmt) == GIMPLE_PHI)\n+  if (gphi *phi = dyn_cast <gphi *> (stmt))\n     {\n-      if (phi_contains_arg (stmt, lhs))\n-\treturn stmt;\n+      if (phi_contains_arg (phi, lhs))\n+\treturn phi;\n       return NULL;\n     }\n \n@@ -2665,7 +2666,8 @@ follow_ssa_with_commutative_ops (tree arg, tree lhs)\n \n   if (is_reduction_operation_p (stmt))\n     {\n-      gimple res = follow_ssa_with_commutative_ops (gimple_assign_rhs1 (stmt), lhs);\n+      gphi *res\n+\t= follow_ssa_with_commutative_ops (gimple_assign_rhs1 (stmt), lhs);\n \n       return res ? res :\n \tfollow_ssa_with_commutative_ops (gimple_assign_rhs2 (stmt), lhs);\n@@ -2677,12 +2679,12 @@ follow_ssa_with_commutative_ops (tree arg, tree lhs)\n /* Detect commutative and associative scalar reductions starting at\n    the STMT.  Return the phi node of the reduction cycle, or NULL.  */\n \n-static gimple\n+static gphi *\n detect_commutative_reduction_arg (tree lhs, gimple stmt, tree arg,\n \t\t\t\t  vec<gimple> *in,\n \t\t\t\t  vec<gimple> *out)\n {\n-  gimple phi = follow_ssa_with_commutative_ops (arg, lhs);\n+  gphi *phi = follow_ssa_with_commutative_ops (arg, lhs);\n \n   if (!phi)\n     return NULL;\n@@ -2695,7 +2697,7 @@ detect_commutative_reduction_arg (tree lhs, gimple stmt, tree arg,\n /* Detect commutative and associative scalar reductions starting at\n    STMT.  Return the phi node of the reduction cycle, or NULL.  */\n \n-static gimple\n+static gphi *\n detect_commutative_reduction_assign (gimple stmt, vec<gimple> *in,\n \t\t\t\t     vec<gimple> *out)\n {\n@@ -2708,9 +2710,9 @@ detect_commutative_reduction_assign (gimple stmt, vec<gimple> *in,\n \n   if (is_reduction_operation_p (stmt))\n     {\n-      gimple res = detect_commutative_reduction_arg (lhs, stmt,\n-\t\t\t\t\t\t     gimple_assign_rhs1 (stmt),\n-\t\t\t\t\t\t     in, out);\n+      gphi *res = detect_commutative_reduction_arg (lhs, stmt,\n+\t\t\t\t\t\t    gimple_assign_rhs1 (stmt),\n+\t\t\t\t\t\t    in, out);\n       return res ? res\n \t: detect_commutative_reduction_arg (lhs, stmt,\n \t\t\t\t\t    gimple_assign_rhs2 (stmt),\n@@ -2722,7 +2724,7 @@ detect_commutative_reduction_assign (gimple stmt, vec<gimple> *in,\n \n /* Return a loop phi node that corresponds to a reduction containing LHS.  */\n \n-static gimple\n+static gphi *\n follow_inital_value_to_phi (tree arg, tree lhs)\n {\n   gimple stmt;\n@@ -2732,9 +2734,9 @@ follow_inital_value_to_phi (tree arg, tree lhs)\n \n   stmt = SSA_NAME_DEF_STMT (arg);\n \n-  if (gimple_code (stmt) == GIMPLE_PHI\n-      && phi_contains_arg (stmt, lhs))\n-    return stmt;\n+  if (gphi *phi = dyn_cast <gphi *> (stmt))\n+    if (phi_contains_arg (phi, lhs))\n+      return phi;\n \n   return NULL;\n }\n@@ -2744,7 +2746,7 @@ follow_inital_value_to_phi (tree arg, tree lhs)\n    from outside the loop.  */\n \n static edge\n-edge_initial_value_for_loop_phi (gimple phi)\n+edge_initial_value_for_loop_phi (gphi *phi)\n {\n   size_t i;\n \n@@ -2764,7 +2766,7 @@ edge_initial_value_for_loop_phi (gimple phi)\n    from outside the loop.  */\n \n static tree\n-initial_value_for_loop_phi (gimple phi)\n+initial_value_for_loop_phi (gphi *phi)\n {\n   size_t i;\n \n@@ -2808,13 +2810,14 @@ used_outside_reduction (tree def, gimple loop_phi)\n    the SCOP starting at the loop closed phi node STMT.  Return the phi\n    node of the reduction cycle, or NULL.  */\n \n-static gimple\n+static gphi *\n detect_commutative_reduction (scop_p scop, gimple stmt, vec<gimple> *in,\n \t\t\t      vec<gimple> *out)\n {\n   if (scalar_close_phi_node_p (stmt))\n     {\n-      gimple def, loop_phi, phi, close_phi = stmt;\n+      gimple def;\n+      gphi *loop_phi, *phi, *close_phi = as_a <gphi *> (stmt);\n       tree init, lhs, arg = gimple_phi_arg_def (close_phi, 0);\n \n       if (TREE_CODE (arg) != SSA_NAME)\n@@ -2854,10 +2857,10 @@ detect_commutative_reduction (scop_p scop, gimple stmt, vec<gimple> *in,\n \n static void\n translate_scalar_reduction_to_array_for_stmt (scop_p scop, tree red,\n-\t\t\t\t\t      gimple stmt, gimple loop_phi)\n+\t\t\t\t\t      gimple stmt, gphi *loop_phi)\n {\n   tree res = gimple_phi_result (loop_phi);\n-  gimple assign = gimple_build_assign (res, unshare_expr (red));\n+  gassign *assign = gimple_build_assign (res, unshare_expr (red));\n   gimple_stmt_iterator gsi;\n \n   insert_stmts (scop, assign, NULL, gsi_after_labels (gimple_bb (loop_phi)));\n@@ -2872,7 +2875,7 @@ translate_scalar_reduction_to_array_for_stmt (scop_p scop, tree red,\n    the PHI_RESULT.  */\n \n static void\n-remove_phi (gimple phi)\n+remove_phi (gphi *phi)\n {\n   imm_use_iterator imm_iter;\n   tree def;\n@@ -2935,7 +2938,7 @@ dr_indices_valid_in_loop (tree ref ATTRIBUTE_UNUSED, tree *index, void *data)\n    NULL_TREE.  */\n \n static tree\n-close_phi_written_to_memory (gimple close_phi)\n+close_phi_written_to_memory (gphi *close_phi)\n {\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n@@ -2990,30 +2993,33 @@ translate_scalar_reduction_to_array (scop_p scop,\n \t\t\t\t     vec<gimple> in,\n \t\t\t\t     vec<gimple> out)\n {\n-  gimple loop_phi;\n+  gimple loop_stmt;\n   unsigned int i = out.length () - 1;\n-  tree red = close_phi_written_to_memory (out[i]);\n+  tree red = close_phi_written_to_memory (as_a <gphi *> (out[i]));\n \n-  FOR_EACH_VEC_ELT (in, i, loop_phi)\n+  FOR_EACH_VEC_ELT (in, i, loop_stmt)\n     {\n-      gimple close_phi = out[i];\n+      gimple close_stmt = out[i];\n \n       if (i == 0)\n \t{\n-\t  gimple stmt = loop_phi;\n-\t  basic_block bb = split_reduction_stmt (scop, stmt);\n+\t  basic_block bb = split_reduction_stmt (scop, loop_stmt);\n \t  poly_bb_p pbb = pbb_from_bb (bb);\n \t  PBB_IS_REDUCTION (pbb) = true;\n-\t  gcc_assert (close_phi == loop_phi);\n+\t  gcc_assert (close_stmt == loop_stmt);\n \n \t  if (!red)\n \t    red = create_zero_dim_array\n-\t      (gimple_assign_lhs (stmt), \"Commutative_Associative_Reduction\");\n+\t      (gimple_assign_lhs (loop_stmt), \"Commutative_Associative_Reduction\");\n \n-\t  translate_scalar_reduction_to_array_for_stmt (scop, red, stmt, in[1]);\n+\t  translate_scalar_reduction_to_array_for_stmt (scop, red, loop_stmt,\n+\t\t\t\t\t\t\tas_a <gphi *> (in[1]));\n \t  continue;\n \t}\n \n+      gphi *loop_phi = as_a <gphi *> (loop_stmt);\n+      gphi *close_phi = as_a <gphi *> (close_stmt);\n+\n       if (i == in.length () - 1)\n \t{\n \t  insert_out_of_ssa_copy (scop, gimple_phi_result (close_phi),\n@@ -3033,7 +3039,7 @@ translate_scalar_reduction_to_array (scop_p scop,\n \n static bool\n rewrite_commutative_reductions_out_of_ssa_close_phi (scop_p scop,\n-\t\t\t\t\t\t     gimple close_phi)\n+\t\t\t\t\t\t     gphi *close_phi)\n {\n   bool res;\n   auto_vec<gimple, 10> in;\n@@ -3054,7 +3060,7 @@ static bool\n rewrite_commutative_reductions_out_of_ssa_loop (scop_p scop,\n \t\t\t\t\t\tloop_p loop)\n {\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n   edge exit = single_exit (loop);\n   tree res;\n   bool changed = false;\n@@ -3063,11 +3069,11 @@ rewrite_commutative_reductions_out_of_ssa_loop (scop_p scop,\n     return false;\n \n   for (gsi = gsi_start_phis (exit->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n-    if ((res = gimple_phi_result (gsi_stmt (gsi)))\n+    if ((res = gimple_phi_result (gsi.phi ()))\n \t&& !virtual_operand_p (res)\n \t&& !scev_analyzable_p (res, SCOP_REGION (scop)))\n       changed |= rewrite_commutative_reductions_out_of_ssa_close_phi\n-\t(scop, gsi_stmt (gsi));\n+\t(scop, gsi.phi ());\n \n   return changed;\n }\n@@ -3104,7 +3110,7 @@ static bool\n scop_ivs_can_be_represented (scop_p scop)\n {\n   loop_p loop;\n-  gimple_stmt_iterator psi;\n+  gphi_iterator psi;\n   bool result = true;\n \n   FOR_EACH_LOOP (loop, 0)\n@@ -3115,7 +3121,7 @@ scop_ivs_can_be_represented (scop_p scop)\n       for (psi = gsi_start_phis (loop->header);\n \t   !gsi_end_p (psi); gsi_next (&psi))\n \t{\n-\t  gimple phi = gsi_stmt (psi);\n+\t  gphi *phi = psi.phi ();\n \t  tree res = PHI_RESULT (phi);\n \t  tree type = TREE_TYPE (res);\n "}, {"sha": "ed4caa1e0a25afff3d20bde75caecabd4c16a011", "filename": "gcc/gsstruct.def", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgsstruct.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fgsstruct.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgsstruct.def?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -29,25 +29,25 @@ DEFGSSTRUCT(GSS_BASE, gimple_statement_base, false)\n DEFGSSTRUCT(GSS_WITH_OPS, gimple_statement_with_ops, true)\n DEFGSSTRUCT(GSS_WITH_MEM_OPS_BASE, gimple_statement_with_memory_ops_base, false)\n DEFGSSTRUCT(GSS_WITH_MEM_OPS, gimple_statement_with_memory_ops, true)\n-DEFGSSTRUCT(GSS_CALL, gimple_statement_call, true)\n-DEFGSSTRUCT(GSS_ASM, gimple_statement_asm, true)\n-DEFGSSTRUCT(GSS_BIND, gimple_statement_bind, false)\n-DEFGSSTRUCT(GSS_PHI, gimple_statement_phi, false)\n-DEFGSSTRUCT(GSS_TRY, gimple_statement_try, false)\n-DEFGSSTRUCT(GSS_CATCH, gimple_statement_catch, false)\n-DEFGSSTRUCT(GSS_EH_FILTER, gimple_statement_eh_filter, false)\n-DEFGSSTRUCT(GSS_EH_MNT, gimple_statement_eh_mnt, false)\n+DEFGSSTRUCT(GSS_CALL, gcall, true)\n+DEFGSSTRUCT(GSS_ASM, gasm, true)\n+DEFGSSTRUCT(GSS_BIND, gbind, false)\n+DEFGSSTRUCT(GSS_PHI, gphi, false)\n+DEFGSSTRUCT(GSS_TRY, gtry, false)\n+DEFGSSTRUCT(GSS_CATCH, gcatch, false)\n+DEFGSSTRUCT(GSS_EH_FILTER, geh_filter, false)\n+DEFGSSTRUCT(GSS_EH_MNT, geh_mnt, false)\n DEFGSSTRUCT(GSS_EH_CTRL, gimple_statement_eh_ctrl, false)\n-DEFGSSTRUCT(GSS_EH_ELSE, gimple_statement_eh_else, false)\n+DEFGSSTRUCT(GSS_EH_ELSE, geh_else, false)\n DEFGSSTRUCT(GSS_WCE, gimple_statement_wce, false)\n DEFGSSTRUCT(GSS_OMP, gimple_statement_omp, false)\n-DEFGSSTRUCT(GSS_OMP_CRITICAL, gimple_statement_omp_critical, false)\n-DEFGSSTRUCT(GSS_OMP_FOR, gimple_statement_omp_for, false)\n+DEFGSSTRUCT(GSS_OMP_CRITICAL, gomp_critical, false)\n+DEFGSSTRUCT(GSS_OMP_FOR, gomp_for, false)\n DEFGSSTRUCT(GSS_OMP_PARALLEL_LAYOUT, gimple_statement_omp_parallel_layout, false)\n-DEFGSSTRUCT(GSS_OMP_TASK, gimple_statement_omp_task, false)\n-DEFGSSTRUCT(GSS_OMP_SECTIONS, gimple_statement_omp_sections, false)\n+DEFGSSTRUCT(GSS_OMP_TASK, gomp_task, false)\n+DEFGSSTRUCT(GSS_OMP_SECTIONS, gomp_sections, false)\n DEFGSSTRUCT(GSS_OMP_SINGLE_LAYOUT, gimple_statement_omp_single_layout, false)\n-DEFGSSTRUCT(GSS_OMP_CONTINUE, gimple_statement_omp_continue, false)\n-DEFGSSTRUCT(GSS_OMP_ATOMIC_LOAD, gimple_statement_omp_atomic_load, false)\n-DEFGSSTRUCT(GSS_OMP_ATOMIC_STORE_LAYOUT, gimple_statement_omp_atomic_store, false)\n-DEFGSSTRUCT(GSS_TRANSACTION, gimple_statement_transaction, false)\n+DEFGSSTRUCT(GSS_OMP_CONTINUE, gomp_continue, false)\n+DEFGSSTRUCT(GSS_OMP_ATOMIC_LOAD, gomp_atomic_load, false)\n+DEFGSSTRUCT(GSS_OMP_ATOMIC_STORE_LAYOUT, gomp_atomic_store, false)\n+DEFGSSTRUCT(GSS_TRANSACTION, gtransaction, false)"}, {"sha": "0ba20245d679aa432858004361d5371968741f1c", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -101,7 +101,7 @@ get_multi_vector_move (tree array_type, convert_optab optab)\n /* Expand LOAD_LANES call STMT.  */\n \n static void\n-expand_LOAD_LANES (gimple stmt)\n+expand_LOAD_LANES (gcall *stmt)\n {\n   struct expand_operand ops[2];\n   tree type, lhs, rhs;\n@@ -125,7 +125,7 @@ expand_LOAD_LANES (gimple stmt)\n /* Expand STORE_LANES call STMT.  */\n \n static void\n-expand_STORE_LANES (gimple stmt)\n+expand_STORE_LANES (gcall *stmt)\n {\n   struct expand_operand ops[2];\n   tree type, lhs, rhs;\n@@ -147,63 +147,63 @@ expand_STORE_LANES (gimple stmt)\n }\n \n static void\n-expand_ANNOTATE (gimple stmt ATTRIBUTE_UNUSED)\n+expand_ANNOTATE (gcall *stmt ATTRIBUTE_UNUSED)\n {\n   gcc_unreachable ();\n }\n \n /* This should get expanded in adjust_simduid_builtins.  */\n \n static void\n-expand_GOMP_SIMD_LANE (gimple stmt ATTRIBUTE_UNUSED)\n+expand_GOMP_SIMD_LANE (gcall *stmt ATTRIBUTE_UNUSED)\n {\n   gcc_unreachable ();\n }\n \n /* This should get expanded in adjust_simduid_builtins.  */\n \n static void\n-expand_GOMP_SIMD_VF (gimple stmt ATTRIBUTE_UNUSED)\n+expand_GOMP_SIMD_VF (gcall *stmt ATTRIBUTE_UNUSED)\n {\n   gcc_unreachable ();\n }\n \n /* This should get expanded in adjust_simduid_builtins.  */\n \n static void\n-expand_GOMP_SIMD_LAST_LANE (gimple stmt ATTRIBUTE_UNUSED)\n+expand_GOMP_SIMD_LAST_LANE (gcall *stmt ATTRIBUTE_UNUSED)\n {\n   gcc_unreachable ();\n }\n \n /* This should get expanded in the sanopt pass.  */\n \n static void\n-expand_UBSAN_NULL (gimple stmt ATTRIBUTE_UNUSED)\n+expand_UBSAN_NULL (gcall *stmt ATTRIBUTE_UNUSED)\n {\n   gcc_unreachable ();\n }\n \n /* This should get expanded in the sanopt pass.  */\n \n static void\n-expand_UBSAN_BOUNDS (gimple stmt ATTRIBUTE_UNUSED)\n+expand_UBSAN_BOUNDS (gcall *stmt ATTRIBUTE_UNUSED)\n {\n   gcc_unreachable ();\n }\n \n /* This should get expanded in the sanopt pass.  */\n \n static void\n-expand_UBSAN_OBJECT_SIZE (gimple stmt ATTRIBUTE_UNUSED)\n+expand_UBSAN_OBJECT_SIZE (gcall *stmt ATTRIBUTE_UNUSED)\n {\n   gcc_unreachable ();\n }\n \n /* This should get expanded in the sanopt pass.  */\n \n static void\n-expand_ASAN_CHECK (gimple stmt ATTRIBUTE_UNUSED)\n+expand_ASAN_CHECK (gcall *stmt ATTRIBUTE_UNUSED)\n {\n   gcc_unreachable ();\n }\n@@ -1614,7 +1614,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n /* Expand UBSAN_CHECK_ADD call STMT.  */\n \n static void\n-expand_UBSAN_CHECK_ADD (gimple stmt)\n+expand_UBSAN_CHECK_ADD (gcall *stmt)\n {\n   location_t loc = gimple_location (stmt);\n   tree lhs = gimple_call_lhs (stmt);\n@@ -1627,7 +1627,7 @@ expand_UBSAN_CHECK_ADD (gimple stmt)\n /* Expand UBSAN_CHECK_SUB call STMT.  */\n \n static void\n-expand_UBSAN_CHECK_SUB (gimple stmt)\n+expand_UBSAN_CHECK_SUB (gcall *stmt)\n {\n   location_t loc = gimple_location (stmt);\n   tree lhs = gimple_call_lhs (stmt);\n@@ -1643,7 +1643,7 @@ expand_UBSAN_CHECK_SUB (gimple stmt)\n /* Expand UBSAN_CHECK_MUL call STMT.  */\n \n static void\n-expand_UBSAN_CHECK_MUL (gimple stmt)\n+expand_UBSAN_CHECK_MUL (gcall *stmt)\n {\n   location_t loc = gimple_location (stmt);\n   tree lhs = gimple_call_lhs (stmt);\n@@ -1828,37 +1828,37 @@ expand_arith_overflow (enum tree_code code, gimple stmt)\n /* Expand ADD_OVERFLOW STMT.  */\n \n static void\n-expand_ADD_OVERFLOW (gimple stmt)\n+expand_ADD_OVERFLOW (gcall *stmt)\n {\n   expand_arith_overflow (PLUS_EXPR, stmt);\n }\n \n /* Expand SUB_OVERFLOW STMT.  */\n \n static void\n-expand_SUB_OVERFLOW (gimple stmt)\n+expand_SUB_OVERFLOW (gcall *stmt)\n {\n   expand_arith_overflow (MINUS_EXPR, stmt);\n }\n \n /* Expand MUL_OVERFLOW STMT.  */\n \n static void\n-expand_MUL_OVERFLOW (gimple stmt)\n+expand_MUL_OVERFLOW (gcall *stmt)\n {\n   expand_arith_overflow (MULT_EXPR, stmt);\n }\n \n /* This should get folded in tree-vectorizer.c.  */\n \n static void\n-expand_LOOP_VECTORIZED (gimple stmt ATTRIBUTE_UNUSED)\n+expand_LOOP_VECTORIZED (gcall *stmt ATTRIBUTE_UNUSED)\n {\n   gcc_unreachable ();\n }\n \n static void\n-expand_MASK_LOAD (gimple stmt)\n+expand_MASK_LOAD (gcall *stmt)\n {\n   struct expand_operand ops[3];\n   tree type, lhs, rhs, maskt;\n@@ -1883,7 +1883,7 @@ expand_MASK_LOAD (gimple stmt)\n }\n \n static void\n-expand_MASK_STORE (gimple stmt)\n+expand_MASK_STORE (gcall *stmt)\n {\n   struct expand_operand ops[3];\n   tree type, lhs, rhs, maskt;\n@@ -1906,12 +1906,12 @@ expand_MASK_STORE (gimple stmt)\n }\n \n static void\n-expand_ABNORMAL_DISPATCHER (gimple)\n+expand_ABNORMAL_DISPATCHER (gcall *)\n {\n }\n \n static void\n-expand_BUILTIN_EXPECT (gimple stmt)\n+expand_BUILTIN_EXPECT (gcall *stmt)\n {\n   /* When guessing was done, the hints should be already stripped away.  */\n   gcc_assert (!flag_guess_branch_prob || optimize == 0 || seen_error ());\n@@ -1930,10 +1930,10 @@ expand_BUILTIN_EXPECT (gimple stmt)\n /* Routines to expand each internal function, indexed by function number.\n    Each routine has the prototype:\n \n-       expand_<NAME> (gimple stmt)\n+       expand_<NAME> (gcall *stmt)\n \n    where STMT is the statement that performs the call. */\n-static void (*const internal_fn_expanders[]) (gimple) = {\n+static void (*const internal_fn_expanders[]) (gcall *) = {\n #define DEF_INTERNAL_FN(CODE, FLAGS, FNSPEC) expand_##CODE,\n #include \"internal-fn.def\"\n #undef DEF_INTERNAL_FN\n@@ -1943,7 +1943,7 @@ static void (*const internal_fn_expanders[]) (gimple) = {\n /* Expand STMT, which is a call to internal function FN.  */\n \n void\n-expand_internal_call (gimple stmt)\n+expand_internal_call (gcall *stmt)\n {\n   internal_fn_expanders[(int) gimple_call_internal_fn (stmt)] (stmt);\n }"}, {"sha": "bfc3c9abf60f5eb4b55003a87bcf901a38a31d0c", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -35,7 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n    \n    Each entry must have a corresponding expander of the form:\n \n-     void expand_NAME (gimple stmt)\n+     void expand_NAME (gimple_call stmt)\n \n    where STMT is the statement that performs the call.  */\n "}, {"sha": "94444889c02d8b3beace8b02b957e010d957c776", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -57,6 +57,6 @@ internal_fn_fnspec (enum internal_fn fn)\n   return internal_fn_fnspec_array[(int) fn];\n }\n \n-extern void expand_internal_call (gimple);\n+extern void expand_internal_call (gcall *);\n \n #endif"}, {"sha": "8f2a438abc9198d0be37c2bd66086b600e790537", "filename": "gcc/ipa-icf-gimple.c", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fipa-icf-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fipa-icf-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -539,9 +539,9 @@ func_checker::parse_labels (sem_bb *bb)\n     {\n       gimple stmt = gsi_stmt (gsi);\n \n-      if (gimple_code (stmt) == GIMPLE_LABEL)\n+      if (glabel *label_stmt = dyn_cast <glabel *> (stmt))\n \t{\n-\t  tree t = gimple_label_label (stmt);\n+\t  tree t = gimple_label_label (label_stmt);\n \t  gcc_assert (TREE_CODE (t) == LABEL_DECL);\n \n \t  m_label_bb_map.put (t, bb->bb->index);\n@@ -595,7 +595,8 @@ func_checker::compare_bb (sem_bb *bb1, sem_bb *bb2)\n       switch (gimple_code (s1))\n \t{\n \tcase GIMPLE_CALL:\n-\t  if (!compare_gimple_call (s1, s2))\n+\t  if (!compare_gimple_call (as_a <gcall *> (s1),\n+\t\t\t\t    as_a <gcall *> (s2)))\n \t    return return_different_stmts (s1, s2, \"GIMPLE_CALL\");\n \t  break;\n \tcase GIMPLE_ASSIGN:\n@@ -607,30 +608,35 @@ func_checker::compare_bb (sem_bb *bb1, sem_bb *bb2)\n \t    return return_different_stmts (s1, s2, \"GIMPLE_COND\");\n \t  break;\n \tcase GIMPLE_SWITCH:\n-\t  if (!compare_gimple_switch (s1, s2))\n+\t  if (!compare_gimple_switch (as_a <gswitch *> (s1),\n+\t\t\t\t      as_a <gswitch *> (s2)))\n \t    return return_different_stmts (s1, s2, \"GIMPLE_SWITCH\");\n \t  break;\n \tcase GIMPLE_DEBUG:\n \tcase GIMPLE_EH_DISPATCH:\n \t  break;\n \tcase GIMPLE_RESX:\n-\t  if (!compare_gimple_resx (s1, s2))\n+\t  if (!compare_gimple_resx (as_a <gresx *> (s1),\n+\t\t\t\t    as_a <gresx *> (s2)))\n \t    return return_different_stmts (s1, s2, \"GIMPLE_RESX\");\n \t  break;\n \tcase GIMPLE_LABEL:\n-\t  if (!compare_gimple_label (s1, s2))\n+\t  if (!compare_gimple_label (as_a <glabel *> (s1),\n+\t\t\t\t     as_a <glabel *> (s2)))\n \t    return return_different_stmts (s1, s2, \"GIMPLE_LABEL\");\n \t  break;\n \tcase GIMPLE_RETURN:\n-\t  if (!compare_gimple_return (s1, s2))\n+\t  if (!compare_gimple_return (as_a <greturn *> (s1),\n+\t\t\t\t      as_a <greturn *> (s2)))\n \t    return return_different_stmts (s1, s2, \"GIMPLE_RETURN\");\n \t  break;\n \tcase GIMPLE_GOTO:\n \t  if (!compare_gimple_goto (s1, s2))\n \t    return return_different_stmts (s1, s2, \"GIMPLE_GOTO\");\n \t  break;\n \tcase GIMPLE_ASM:\n-\t  if (!compare_gimple_asm (s1, s2))\n+\t  if (!compare_gimple_asm (as_a <gasm *> (s1),\n+\t\t\t\t   as_a <gasm *> (s2)))\n \t    return return_different_stmts (s1, s2, \"GIMPLE_ASM\");\n \t  break;\n \tcase GIMPLE_PREDICT:\n@@ -651,7 +657,7 @@ func_checker::compare_bb (sem_bb *bb1, sem_bb *bb2)\n    call statements are semantically equivalent.  */\n \n bool\n-func_checker::compare_gimple_call (gimple s1, gimple s2)\n+func_checker::compare_gimple_call (gcall *s1, gcall *s2)\n {\n   unsigned i;\n   tree t1, t2;\n@@ -781,11 +787,11 @@ func_checker::compare_tree_ssa_label (tree t1, tree t2)\n   return compare_operand (t1, t2);\n }\n \n-/* Verifies for given GIMPLEs S1 and S2 that\n+/* Verifies for given GIMPLE_LABEL stmts S1 and S2 that\n    label statements are semantically equivalent.  */\n \n bool\n-func_checker::compare_gimple_label (gimple g1, gimple g2)\n+func_checker::compare_gimple_label (const glabel *g1, const glabel *g2)\n {\n   if (m_ignore_labels)\n     return true;\n@@ -800,11 +806,11 @@ func_checker::compare_gimple_label (gimple g1, gimple g2)\n   return true;\n }\n \n-/* Verifies for given GIMPLEs S1 and S2 that\n+/* Verifies for given GIMPLE_SWITCH stmts S1 and S2 that\n    switch statements are semantically equivalent.  */\n \n bool\n-func_checker::compare_gimple_switch (gimple g1, gimple g2)\n+func_checker::compare_gimple_switch (const gswitch *g1, const gswitch *g2)\n {\n   unsigned lsize1, lsize2, i;\n \n@@ -854,11 +860,11 @@ func_checker::compare_gimple_switch (gimple g1, gimple g2)\n   return true;\n }\n \n-/* Verifies for given GIMPLEs S1 and S2 that\n+/* Verifies for given GIMPLE_RETURN stmts S1 and S2 that\n    return statements are semantically equivalent.  */\n \n bool\n-func_checker::compare_gimple_return (gimple g1, gimple g2)\n+func_checker::compare_gimple_return (const greturn *g1, const greturn *g2)\n {\n   tree t1, t2;\n \n@@ -889,11 +895,11 @@ func_checker::compare_gimple_goto (gimple g1, gimple g2)\n   return compare_operand (dest1, dest2);\n }\n \n-/* Verifies for given GIMPLEs S1 and S2 that\n+/* Verifies for given GIMPLE_RESX stmts S1 and S2 that\n    resx statements are semantically equivalent.  */\n \n bool\n-func_checker::compare_gimple_resx (gimple g1, gimple g2)\n+func_checker::compare_gimple_resx (const gresx *g1, const gresx *g2)\n {\n   return gimple_resx_region (g1) == gimple_resx_region (g2);\n }\n@@ -903,7 +909,7 @@ func_checker::compare_gimple_resx (gimple g1, gimple g2)\n    '__asm__ __volatile__ (\"\", \"\", \"\", \"memory\")'.  */\n \n bool\n-func_checker::compare_gimple_asm (gimple g1, gimple g2)\n+func_checker::compare_gimple_asm (const gasm *g1, const gasm *g2)\n {\n   if (gimple_asm_volatile_p (g1) != gimple_asm_volatile_p (g2))\n     return false;"}, {"sha": "cb9b1fc1d83a1e6c315dede685154377d52ffbcd", "filename": "gcc/ipa-icf-gimple.h", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fipa-icf-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fipa-icf-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -161,7 +161,7 @@ class func_checker\n \n   /* Verifies for given GIMPLEs S1 and S2 that\n      call statements are semantically equivalent.  */\n-  bool compare_gimple_call (gimple s1, gimple s2);\n+  bool compare_gimple_call (gcall *s1, gcall *s2);\n \n   /* Verifies for given GIMPLEs S1 and S2 that\n      assignment statements are semantically equivalent.  */\n@@ -171,30 +171,31 @@ class func_checker\n      condition statements are semantically equivalent.  */\n   bool compare_gimple_cond (gimple s1, gimple s2);\n \n-  /* Verifies for given GIMPLEs S1 and S2 that\n+  /* Verifies for given GIMPLE_LABEL stmts S1 and S2 that\n      label statements are semantically equivalent.  */\n-  bool compare_gimple_label (gimple s1, gimple s2);\n+  bool compare_gimple_label (const glabel *s1, const glabel *s2);\n \n-  /* Verifies for given GIMPLEs S1 and S2 that\n+  /* Verifies for given GIMPLE_SWITCH stmts S1 and S2 that\n      switch statements are semantically equivalent.  */\n-  bool compare_gimple_switch (gimple s1, gimple s2);\n+  bool compare_gimple_switch (const gswitch *s1, const gswitch *s2);\n \n-  /* Verifies for given GIMPLEs S1 and S2 that\n+  /* Verifies for given GIMPLE_RETURN stmts S1 and S2 that\n      return statements are semantically equivalent.  */\n-  bool compare_gimple_return (gimple s1, gimple s2);\n+  bool compare_gimple_return (const greturn *s1, const greturn *s2);\n \n   /* Verifies for given GIMPLEs S1 and S2 that\n      goto statements are semantically equivalent.  */\n   bool compare_gimple_goto (gimple s1, gimple s2);\n \n-  /* Verifies for given GIMPLEs S1 and S2 that\n+  /* Verifies for given GIMPLE_RESX stmts S1 and S2 that\n      resx statements are semantically equivalent.  */\n-  bool compare_gimple_resx (gimple s1, gimple s2);\n+  bool compare_gimple_resx (const gresx *s1, const gresx *s2);\n \n-  /* Verifies for given GIMPLEs S1 and S2 that ASM statements are equivalent.\n+  /* Verifies for given GIMPLE_ASM stmts S1 and S2 that ASM statements\n+     are equivalent.\n      For the beginning, the pass only supports equality for\n      '__asm__ __volatile__ (\"\", \"\", \"\", \"memory\")'.  */\n-  bool compare_gimple_asm (gimple s1, gimple s2);\n+  bool compare_gimple_asm (const gasm *s1, const gasm *s2);\n \n   /* Verification function for declaration trees T1 and T2.  */\n   bool compare_decl (tree t1, tree t2);"}, {"sha": "af8360138ef769a6bb9dc638afb8dd4cd5576f93", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -883,8 +883,8 @@ sem_function::parse_tree_args (void)\n bool\n sem_function::compare_phi_node (basic_block bb1, basic_block bb2)\n {\n-  gimple_stmt_iterator si1, si2;\n-  gimple phi1, phi2;\n+  gphi_iterator si1, si2;\n+  gphi *phi1, *phi2;\n   unsigned size1, size2, i;\n   tree t1, t2;\n   edge e1, e2;\n@@ -905,8 +905,8 @@ sem_function::compare_phi_node (basic_block bb1, basic_block bb2)\n       if (gsi_end_p (si1) || gsi_end_p (si2))\n \treturn return_false();\n \n-      phi1 = gsi_stmt (si1);\n-      phi2 = gsi_stmt (si2);\n+      phi1 = si1.phi ();\n+      phi2 = si2.phi ();\n \n       tree phi_result1 = gimple_phi_result (phi1);\n       tree phi_result2 = gimple_phi_result (phi2);"}, {"sha": "2f2993ce2995117e524c2a35d36fcfd38e9b00c0", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -1815,7 +1815,7 @@ set_switch_stmt_execution_predicate (struct ipa_node_params *info,\n \t\t\t\t     struct inline_summary *summary,\n \t\t\t\t     basic_block bb)\n {\n-  gimple last;\n+  gimple lastg;\n   tree op;\n   int index;\n   struct agg_position_info aggpos;\n@@ -1824,9 +1824,10 @@ set_switch_stmt_execution_predicate (struct ipa_node_params *info,\n   size_t n;\n   size_t case_idx;\n \n-  last = last_stmt (bb);\n-  if (!last || gimple_code (last) != GIMPLE_SWITCH)\n+  lastg = last_stmt (bb);\n+  if (!lastg || gimple_code (lastg) != GIMPLE_SWITCH)\n     return;\n+  gswitch *last = as_a <gswitch *> (lastg);\n   op = gimple_switch_index (last);\n   if (!unmodified_parm_or_parm_agg_item (info, last, op, &index, &aggpos))\n     return;\n@@ -2276,7 +2277,7 @@ phi_result_unknown_predicate (struct ipa_node_params *info,\n    NONCONSTANT_NAMES, if possible.  */\n \n static void\n-predicate_for_phi_result (struct inline_summary *summary, gimple phi,\n+predicate_for_phi_result (struct inline_summary *summary, gphi *phi,\n \t\t\t  struct predicate *p,\n \t\t\t  vec<predicate_t> nonconstant_names)\n {\n@@ -2459,7 +2460,6 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   /* Benefits are scaled by probability of elimination that is in range\n      <0,2>.  */\n   basic_block bb;\n-  gimple_stmt_iterator bsi;\n   struct function *my_function = DECL_STRUCT_FUNCTION (node->decl);\n   int freq;\n   struct inline_summary *info = inline_summary (node);\n@@ -2540,7 +2540,8 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t  struct predicate phi_predicate;\n \t  bool first_phi = true;\n \n-\t  for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+\t  for (gphi_iterator bsi = gsi_start_phis (bb); !gsi_end_p (bsi);\n+\t       gsi_next (&bsi))\n \t    {\n \t      if (first_phi\n \t\t  && !phi_result_unknown_predicate (parms_info, info, bb,\n@@ -2553,14 +2554,15 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\t  fprintf (dump_file, \"  \");\n \t\t  print_gimple_stmt (dump_file, gsi_stmt (bsi), 0, 0);\n \t\t}\n-\t      predicate_for_phi_result (info, gsi_stmt (bsi), &phi_predicate,\n+\t      predicate_for_phi_result (info, bsi.phi (), &phi_predicate,\n \t\t\t\t\tnonconstant_names);\n \t    }\n \t}\n \n       fix_builtin_expect_stmt = find_foldable_builtin_expect (bb);\n \n-      for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+      for (gimple_stmt_iterator bsi = gsi_start_bb (bb); !gsi_end_p (bsi);\n+\t   gsi_next (&bsi))\n \t{\n \t  gimple stmt = gsi_stmt (bsi);\n \t  int this_size = estimate_num_insns (stmt, &eni_size_weights);"}, {"sha": "2e0016bfbe666544974ab7095e96ac75f8574982", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -710,7 +710,7 @@ param_type_may_change_p (tree function, tree arg, gimple call)\n \n static bool\n detect_type_change_from_memory_writes (tree arg, tree base, tree comp_type,\n-\t\t\t\t       gimple call, struct ipa_jump_func *jfunc,\n+\t\t\t\t       gcall *call, struct ipa_jump_func *jfunc,\n \t\t\t\t       HOST_WIDE_INT offset)\n {\n   struct prop_type_change_info tci;\n@@ -759,7 +759,7 @@ detect_type_change_from_memory_writes (tree arg, tree base, tree comp_type,\n    returned by get_ref_base_and_extent, as is the offset.  */\n \n static bool\n-detect_type_change (tree arg, tree base, tree comp_type, gimple call,\n+detect_type_change (tree arg, tree base, tree comp_type, gcall *call,\n \t\t    struct ipa_jump_func *jfunc, HOST_WIDE_INT offset)\n {\n   if (!flag_devirtualize)\n@@ -780,7 +780,7 @@ detect_type_change (tree arg, tree base, tree comp_type, gimple call,\n \n static bool\n detect_type_change_ssa (tree arg, tree comp_type,\n-\t\t\tgimple call, struct ipa_jump_func *jfunc)\n+\t\t\tgcall *call, struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (TREE_CODE (arg) == SSA_NAME);\n   if (!flag_devirtualize\n@@ -1157,7 +1157,7 @@ static void\n compute_complex_assign_jump_func (struct func_body_info *fbi,\n \t\t\t\t  struct ipa_node_params *info,\n \t\t\t\t  struct ipa_jump_func *jfunc,\n-\t\t\t\t  gimple call, gimple stmt, tree name,\n+\t\t\t\t  gcall *call, gimple stmt, tree name,\n \t\t\t\t  tree param_type)\n {\n   HOST_WIDE_INT offset, size, max_size;\n@@ -1299,7 +1299,7 @@ static void\n compute_complex_ancestor_jump_func (struct func_body_info *fbi,\n \t\t\t\t    struct ipa_node_params *info,\n \t\t\t\t    struct ipa_jump_func *jfunc,\n-\t\t\t\t    gimple call, gimple phi)\n+\t\t\t\t    gcall *call, gphi *phi)\n {\n   HOST_WIDE_INT offset;\n   gimple assign, cond;\n@@ -1486,7 +1486,8 @@ build_agg_jump_func_from_list (struct ipa_known_agg_contents_list *list,\n    subsequently stored.  */\n \n static void\n-determine_locally_known_aggregate_parts (gimple call, tree arg, tree arg_type,\n+determine_locally_known_aggregate_parts (gcall *call, tree arg,\n+\t\t\t\t\t tree arg_type,\n \t\t\t\t\t struct ipa_jump_func *jfunc)\n {\n   struct ipa_known_agg_contents_list *list = NULL;\n@@ -1682,7 +1683,7 @@ ipa_compute_jump_functions_for_edge (struct func_body_info *fbi,\n {\n   struct ipa_node_params *info = IPA_NODE_REF (cs->caller);\n   struct ipa_edge_args *args = IPA_EDGE_REF (cs);\n-  gimple call = cs->call_stmt;\n+  gcall *call = cs->call_stmt;\n   int n, arg_num = gimple_call_num_args (call);\n   bool useful_context = false;\n \n@@ -1751,7 +1752,8 @@ ipa_compute_jump_functions_for_edge (struct func_body_info *fbi,\n \t\t\t\t\t\t  call, stmt, arg, param_type);\n \t      else if (gimple_code (stmt) == GIMPLE_PHI)\n \t\tcompute_complex_ancestor_jump_func (fbi, info, jfunc,\n-\t\t\t\t\t\t    call, stmt);\n+\t\t\t\t\t\t    call,\n+\t\t\t\t\t\t    as_a <gphi *> (stmt));\n \t    }\n \t}\n \n@@ -1871,7 +1873,8 @@ ipa_is_ssa_with_stmt_def (tree t)\n    indirect call graph edge.  */\n \n static struct cgraph_edge *\n-ipa_note_param_call (struct cgraph_node *node, int param_index, gimple stmt)\n+ipa_note_param_call (struct cgraph_node *node, int param_index,\n+\t\t     gcall *stmt)\n {\n   struct cgraph_edge *cs;\n \n@@ -1942,7 +1945,7 @@ ipa_note_param_call (struct cgraph_node *node, int param_index, gimple stmt)\n    passed by value or reference.  */\n \n static void\n-ipa_analyze_indirect_call_uses (struct func_body_info *fbi, gimple call,\n+ipa_analyze_indirect_call_uses (struct func_body_info *fbi, gcall *call,\n \t\t\t\ttree target)\n {\n   struct ipa_node_params *info = fbi->info;\n@@ -2081,7 +2084,7 @@ ipa_analyze_indirect_call_uses (struct func_body_info *fbi, gimple call,\n \n static void\n ipa_analyze_virtual_call_uses (struct func_body_info *fbi,\n-\t\t\t       gimple call, tree target)\n+\t\t\t       gcall *call, tree target)\n {\n   tree obj = OBJ_TYPE_REF_OBJECT (target);\n   int index;\n@@ -2137,7 +2140,7 @@ ipa_analyze_virtual_call_uses (struct func_body_info *fbi,\n    containing intermediate information about each formal parameter.  */\n \n static void\n-ipa_analyze_call_uses (struct func_body_info *fbi, gimple call)\n+ipa_analyze_call_uses (struct func_body_info *fbi, gcall *call)\n {\n   tree target = gimple_call_fn (call);\n \n@@ -2186,7 +2189,7 @@ static void\n ipa_analyze_stmt_uses (struct func_body_info *fbi, gimple stmt)\n {\n   if (is_gimple_call (stmt))\n-    ipa_analyze_call_uses (fbi, stmt);\n+    ipa_analyze_call_uses (fbi, as_a <gcall *> (stmt));\n }\n \n /* Callback of walk_stmt_load_store_addr_ops for the visit_load.\n@@ -3852,13 +3855,13 @@ ipa_modify_formal_parameters (tree fndecl, ipa_parm_adjustment_vec adjustments)\n    contain the corresponding call graph edge.  */\n \n void\n-ipa_modify_call_arguments (struct cgraph_edge *cs, gimple stmt,\n+ipa_modify_call_arguments (struct cgraph_edge *cs, gcall *stmt,\n \t\t\t   ipa_parm_adjustment_vec adjustments)\n {\n   struct cgraph_node *current_node = cgraph_node::get (current_function_decl);\n   vec<tree> vargs;\n   vec<tree, va_gc> **debug_args = NULL;\n-  gimple new_stmt;\n+  gcall *new_stmt;\n   gimple_stmt_iterator gsi, prev_gsi;\n   tree callee_decl;\n   int i, len;"}, {"sha": "9190aad032507051a58b9b197d0b608e3ce1fcd2", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -637,7 +637,7 @@ typedef vec<ipa_parm_adjustment> ipa_parm_adjustment_vec;\n vec<tree> ipa_get_vector_of_formal_parms (tree fndecl);\n vec<tree> ipa_get_vector_of_formal_parm_types (tree fntype);\n void ipa_modify_formal_parameters (tree fndecl, ipa_parm_adjustment_vec);\n-void ipa_modify_call_arguments (struct cgraph_edge *, gimple,\n+void ipa_modify_call_arguments (struct cgraph_edge *, gcall *,\n \t\t\t\tipa_parm_adjustment_vec);\n ipa_parm_adjustment_vec ipa_combine_adjustments (ipa_parm_adjustment_vec,\n \t\t\t\t\t\t ipa_parm_adjustment_vec);"}, {"sha": "9c016c1d5862e8474aec300573dc20f15210dca5", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -518,7 +518,7 @@ special_builtin_state (enum pure_const_state_e *state, bool *looping,\n    the entire call expression.  */\n \n static void\n-check_call (funct_state local, gimple call, bool ipa)\n+check_call (funct_state local, gcall *call, bool ipa)\n {\n   int flags = gimple_call_flags (call);\n   tree callee_t = gimple_call_fndecl (call);\n@@ -745,10 +745,10 @@ check_stmt (gimple_stmt_iterator *gsip, funct_state local, bool ipa)\n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_CALL:\n-      check_call (local, stmt, ipa);\n+      check_call (local, as_a <gcall *> (stmt), ipa);\n       break;\n     case GIMPLE_LABEL:\n-      if (DECL_NONLOCAL (gimple_label_label (stmt)))\n+      if (DECL_NONLOCAL (gimple_label_label (as_a <glabel *> (stmt))))\n \t/* Target of long jump. */\n \t{\n           if (dump_file)\n@@ -757,15 +757,15 @@ check_stmt (gimple_stmt_iterator *gsip, funct_state local, bool ipa)\n \t}\n       break;\n     case GIMPLE_ASM:\n-      if (gimple_asm_clobbers_memory_p (stmt))\n+      if (gimple_asm_clobbers_memory_p (as_a <gasm *> (stmt)))\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"    memory asm clobber is not const/pure\\n\");\n \t  /* Abandon all hope, ye who enter here. */\n \t  local->pure_const_state = IPA_NEITHER;\n \t  local->can_free = true;\n \t}\n-      if (gimple_asm_volatile_p (stmt))\n+      if (gimple_asm_volatile_p (as_a <gasm *> (stmt)))\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"    volatile is not const/pure\\n\");"}, {"sha": "134b33ff64fdc8515b5d1c297eb9f82f76f1f910", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 60, "deletions": 50, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -248,8 +248,6 @@ verify_non_ssa_vars (struct split_point *current, bitmap non_ssa_vars,\n \n   while (!worklist.is_empty ())\n     {\n-      gimple_stmt_iterator bsi;\n-\n       bb = worklist.pop ();\n       FOR_EACH_EDGE (e, ei, bb->preds)\n \tif (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n@@ -259,7 +257,8 @@ verify_non_ssa_vars (struct split_point *current, bitmap non_ssa_vars,\n \t\t\t\t\t        e->src->index));\n \t    worklist.safe_push (e->src);\n \t  }\n-      for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+      for (gimple_stmt_iterator bsi = gsi_start_bb (bb); !gsi_end_p (bsi);\n+\t   gsi_next (&bsi))\n \t{\n \t  gimple stmt = gsi_stmt (bsi);\n \t  if (is_gimple_debug (stmt))\n@@ -271,15 +270,16 @@ verify_non_ssa_vars (struct split_point *current, bitmap non_ssa_vars,\n \t      ok = false;\n \t      goto done;\n \t    }\n-\t  if (gimple_code (stmt) == GIMPLE_LABEL\n-\t      && test_nonssa_use (stmt, gimple_label_label (stmt),\n-\t\t\t\t  NULL_TREE, non_ssa_vars))\n-\t    {\n-\t      ok = false;\n-\t      goto done;\n-\t    }\n+\t  if (glabel *label_stmt = dyn_cast <glabel *> (stmt))\n+\t    if (test_nonssa_use (stmt, gimple_label_label (label_stmt),\n+\t\t\t\t NULL_TREE, non_ssa_vars))\n+\t      {\n+\t\tok = false;\n+\t\tgoto done;\n+\t      }\n \t}\n-      for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+      for (gphi_iterator bsi = gsi_start_phis (bb); !gsi_end_p (bsi);\n+\t   gsi_next (&bsi))\n \t{\n \t  if (walk_stmt_load_store_addr_ops\n \t      (gsi_stmt (bsi), non_ssa_vars, test_nonssa_use, test_nonssa_use,\n@@ -293,10 +293,11 @@ verify_non_ssa_vars (struct split_point *current, bitmap non_ssa_vars,\n \t{\n \t  if (e->dest != return_bb)\n \t    continue;\n-\t  for (bsi = gsi_start_phis (return_bb); !gsi_end_p (bsi);\n+\t  for (gphi_iterator bsi = gsi_start_phis (return_bb);\n+\t       !gsi_end_p (bsi);\n \t       gsi_next (&bsi))\n \t    {\n-\t      gimple stmt = gsi_stmt (bsi);\n+\t      gphi *stmt = bsi.phi ();\n \t      tree op = gimple_phi_arg_def (stmt, e->dest_idx);\n \n \t      if (virtual_operand_p (gimple_phi_result (stmt)))\n@@ -319,15 +320,17 @@ verify_non_ssa_vars (struct split_point *current, bitmap non_ssa_vars,\n       {\n         gimple_stmt_iterator bsi;\n         for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-\t  if (gimple_code (gsi_stmt (bsi)) == GIMPLE_LABEL\n-\t      && test_nonssa_use (gsi_stmt (bsi),\n-\t\t\t\t  gimple_label_label (gsi_stmt (bsi)),\n-\t\t\t\t  NULL_TREE, non_ssa_vars))\n+\t  if (glabel *label_stmt = dyn_cast <glabel *> (gsi_stmt (bsi)))\n \t    {\n-\t      ok = false;\n-\t      goto done;\n+\t      if (test_nonssa_use (label_stmt,\n+\t\t\t\t   gimple_label_label (label_stmt),\n+\t\t\t\t   NULL_TREE, non_ssa_vars))\n+\t\t{\n+\t\t  ok = false;\n+\t\t  goto done;\n+\t\t}\n \t    }\n-\t  else if (gimple_code (gsi_stmt (bsi)) != GIMPLE_LABEL)\n+\t  else\n \t    break;\n       }\n     \n@@ -369,9 +372,10 @@ check_forbidden_calls (gimple stmt)\n       basic_block use_bb, forbidden_bb;\n       enum tree_code code;\n       edge true_edge, false_edge;\n-      gimple use_stmt = USE_STMT (use_p);\n+      gcond *use_stmt;\n \n-      if (gimple_code (use_stmt) != GIMPLE_COND)\n+      use_stmt = dyn_cast <gcond *> (USE_STMT (use_p));\n+      if (!use_stmt)\n \tcontinue;\n \n       /* Assuming canonical form for GIMPLE_COND here, with constant\n@@ -443,7 +447,7 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n   unsigned int call_overhead;\n   edge e;\n   edge_iterator ei;\n-  gimple_stmt_iterator bsi;\n+  gphi_iterator bsi;\n   unsigned int i;\n   int incoming_freq = 0;\n   tree retval;\n@@ -501,7 +505,7 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n      incoming from header are the same.  */\n   for (bsi = gsi_start_phis (current->entry_bb); !gsi_end_p (bsi); gsi_next (&bsi))\n     {\n-      gimple stmt = gsi_stmt (bsi);\n+      gphi *stmt = bsi.phi ();\n       tree val = NULL;\n \n       if (virtual_operand_p (gimple_phi_result (stmt)))\n@@ -673,15 +677,15 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n      for the return value.  If there are other PHIs, give up.  */\n   if (return_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n-      gimple_stmt_iterator psi;\n+      gphi_iterator psi;\n \n       for (psi = gsi_start_phis (return_bb); !gsi_end_p (psi); gsi_next (&psi))\n-\tif (!virtual_operand_p (gimple_phi_result (gsi_stmt (psi)))\n+\tif (!virtual_operand_p (gimple_phi_result (psi.phi ()))\n \t    && !(retval\n \t\t && current->split_part_set_retval\n \t\t && TREE_CODE (retval) == SSA_NAME\n \t\t && !DECL_BY_REFERENCE (DECL_RESULT (current_function_decl))\n-\t\t && SSA_NAME_DEF_STMT (retval) == gsi_stmt (psi)))\n+\t\t && SSA_NAME_DEF_STMT (retval) == psi.phi ()))\n \t  {\n \t    if (dump_file && (dump_flags & TDF_DETAILS))\n \t      fprintf (dump_file,\n@@ -762,10 +766,10 @@ find_return_bb (void)\n \t\t   || is_gimple_min_invariant (gimple_assign_rhs1 (stmt)))\n \t       && retval == gimple_assign_lhs (stmt))\n \t;\n-      else if (gimple_code (stmt) == GIMPLE_RETURN)\n+      else if (greturn *return_stmt = dyn_cast <greturn *> (stmt))\n \t{\n \t  found_return = true;\n-\t  retval = gimple_return_retval (stmt);\n+\t  retval = gimple_return_retval (return_stmt);\n \t}\n       else\n \tbreak;\n@@ -783,8 +787,8 @@ find_retval (basic_block return_bb)\n {\n   gimple_stmt_iterator bsi;\n   for (bsi = gsi_start_bb (return_bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-    if (gimple_code (gsi_stmt (bsi)) == GIMPLE_RETURN)\n-      return gimple_return_retval (gsi_stmt (bsi));\n+    if (greturn *return_stmt = dyn_cast <greturn *> (gsi_stmt (bsi)))\n+      return gimple_return_retval (return_stmt);\n     else if (gimple_code (gsi_stmt (bsi)) == GIMPLE_ASSIGN\n \t     && !gimple_clobber_p (gsi_stmt (bsi)))\n       return gimple_assign_rhs1 (gsi_stmt (bsi));\n@@ -861,12 +865,12 @@ visit_bb (basic_block bb, basic_block return_bb,\n \t  bitmap set_ssa_names, bitmap used_ssa_names,\n \t  bitmap non_ssa_vars)\n {\n-  gimple_stmt_iterator bsi;\n   edge e;\n   edge_iterator ei;\n   bool can_split = true;\n \n-  for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+  for (gimple_stmt_iterator bsi = gsi_start_bb (bb); !gsi_end_p (bsi);\n+       gsi_next (&bsi))\n     {\n       gimple stmt = gsi_stmt (bsi);\n       tree op;\n@@ -935,9 +939,10 @@ visit_bb (basic_block bb, basic_block return_bb,\n \t\t\t\t\t\t   mark_nonssa_use,\n \t\t\t\t\t\t   mark_nonssa_use);\n     }\n-  for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+  for (gphi_iterator bsi = gsi_start_phis (bb); !gsi_end_p (bsi);\n+       gsi_next (&bsi))\n     {\n-      gimple stmt = gsi_stmt (bsi);\n+      gphi *stmt = bsi.phi ();\n       unsigned int i;\n \n       if (virtual_operand_p (gimple_phi_result (stmt)))\n@@ -959,9 +964,11 @@ visit_bb (basic_block bb, basic_block return_bb,\n   FOR_EACH_EDGE (e, ei, bb->succs)\n     if (e->dest == return_bb)\n       {\n-\tfor (bsi = gsi_start_phis (return_bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+\tfor (gphi_iterator bsi = gsi_start_phis (return_bb);\n+\t     !gsi_end_p (bsi);\n+\t     gsi_next (&bsi))\n \t  {\n-\t    gimple stmt = gsi_stmt (bsi);\n+\t    gphi *stmt = bsi.phi ();\n \t    tree op = gimple_phi_arg_def (stmt, e->dest_idx);\n \n \t    if (virtual_operand_p (gimple_phi_result (stmt)))\n@@ -1198,8 +1205,7 @@ split_function (struct split_point *split_point)\n   cgraph_node *node, *cur_node = cgraph_node::get (current_function_decl);\n   basic_block return_bb = find_return_bb ();\n   basic_block call_bb;\n-  gimple_stmt_iterator gsi;\n-  gimple call;\n+  gcall *call;\n   edge e;\n   edge_iterator ei;\n   tree retval = NULL, real_retval = NULL, retbnd = NULL;\n@@ -1302,9 +1308,10 @@ split_function (struct split_point *split_point)\n   if (return_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n       bool phi_p = false;\n-      for (gsi = gsi_start_phis (return_bb); !gsi_end_p (gsi);)\n+      for (gphi_iterator gsi = gsi_start_phis (return_bb);\n+\t   !gsi_end_p (gsi);)\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gphi *stmt = gsi.phi ();\n \t  if (!virtual_operand_p (gimple_phi_result (stmt)))\n \t    {\n \t      gsi_next (&gsi);\n@@ -1323,7 +1330,9 @@ split_function (struct split_point *split_point)\n          entry of the SESE region as the vuse of the call and the reaching\n \t vdef of the exit of the SESE region as the vdef of the call.  */\n       if (!phi_p)\n-\tfor (gsi = gsi_start_bb (return_bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\tfor (gimple_stmt_iterator gsi = gsi_start_bb (return_bb);\n+\t     !gsi_end_p (gsi);\n+\t     gsi_next (&gsi))\n \t  {\n \t    gimple stmt = gsi_stmt (gsi);\n \t    if (gimple_vuse (stmt))\n@@ -1372,7 +1381,7 @@ split_function (struct split_point *split_point)\n   /* Create the basic block we place call into.  It is the entry basic block\n      split after last label.  */\n   call_bb = split_point->entry_bb;\n-  for (gsi = gsi_start_bb (call_bb); !gsi_end_p (gsi);)\n+  for (gimple_stmt_iterator gsi = gsi_start_bb (call_bb); !gsi_end_p (gsi);)\n     if (gimple_code (gsi_stmt (gsi)) == GIMPLE_LABEL)\n       {\n \tlast_stmt = gsi_stmt (gsi);\n@@ -1384,7 +1393,7 @@ split_function (struct split_point *split_point)\n   remove_edge (e);\n \n   /* Produce the call statement.  */\n-  gsi = gsi_last_bb (call_bb);\n+  gimple_stmt_iterator gsi = gsi_last_bb (call_bb);\n   FOR_EACH_VEC_ELT (args_to_pass, i, arg)\n     if (!is_gimple_val (arg))\n       {\n@@ -1504,7 +1513,7 @@ split_function (struct split_point *split_point)\n \n \t  if (real_retval && split_point->split_part_set_retval)\n \t    {\n-\t      gimple_stmt_iterator psi;\n+\t      gphi_iterator psi;\n \n \t      /* See if we need new SSA_NAME for the result.\n \t\t When DECL_BY_REFERENCE is true, retval is actually pointer to\n@@ -1517,13 +1526,13 @@ split_function (struct split_point *split_point)\n \t\t  /* See if there is PHI defining return value.  */\n \t\t  for (psi = gsi_start_phis (return_bb);\n \t\t       !gsi_end_p (psi); gsi_next (&psi))\n-\t\t    if (!virtual_operand_p (gimple_phi_result (gsi_stmt (psi))))\n+\t\t    if (!virtual_operand_p (gimple_phi_result (psi.phi ())))\n \t\t      break;\n \n \t\t  /* When there is PHI, just update its value.  */\n \t\t  if (TREE_CODE (retval) == SSA_NAME\n \t\t      && !gsi_end_p (psi))\n-\t\t    add_phi_arg (gsi_stmt (psi), retval, e, UNKNOWN_LOCATION);\n+\t\t    add_phi_arg (psi.phi (), retval, e, UNKNOWN_LOCATION);\n \t\t  /* Otherwise update the return BB itself.\n \t\t     find_return_bb allows at most one assignment to return value,\n \t\t     so update first statement.  */\n@@ -1532,9 +1541,10 @@ split_function (struct split_point *split_point)\n \t\t      gimple_stmt_iterator bsi;\n \t\t      for (bsi = gsi_start_bb (return_bb); !gsi_end_p (bsi);\n \t\t\t   gsi_next (&bsi))\n-\t\t\tif (gimple_code (gsi_stmt (bsi)) == GIMPLE_RETURN)\n+\t\t\tif (greturn *return_stmt\n+\t\t\t      = dyn_cast <greturn *> (gsi_stmt (bsi)))\n \t\t\t  {\n-\t\t\t    gimple_return_set_retval (gsi_stmt (bsi), retval);\n+\t\t\t    gimple_return_set_retval (return_stmt, retval);\n \t\t\t    break;\n \t\t\t  }\n \t\t\telse if (gimple_code (gsi_stmt (bsi)) == GIMPLE_ASSIGN\n@@ -1596,7 +1606,7 @@ split_function (struct split_point *split_point)\n \t */\n       else\n \t{\n-\t  gimple ret;\n+\t  greturn *ret;\n \t  if (split_point->split_part_set_retval\n \t      && !VOID_TYPE_P (TREE_TYPE (TREE_TYPE (current_function_decl))))\n \t    {"}, {"sha": "961fc3abc519ad69aa926098333f861c4c0bba6a", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -1,3 +1,10 @@\n+2014-11-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tMerger of git branch \"gimple-classes-v2-option-3\".\n+\t* ChangeLog.gimple-classes: New.\n+\t* java-gimplify.c (java_gimplify_block): Strengthen local \"outer\"\n+\tfrom gimple to gbind *.\n+\n 2014-11-11  David Malcolm  <dmalcolm@redhat.com>\n \n \t* gcc/ChangeLog.jit: New."}, {"sha": "1f7488e11a62a8de3bf601dc090976963aa9c1e5", "filename": "gcc/java/ChangeLog.gimple-classes", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fjava%2FChangeLog.gimple-classes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fjava%2FChangeLog.gimple-classes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog.gimple-classes?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -0,0 +1,20 @@\n+2014-10-27  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPatch autogenerated by rename_gimple_subclasses.py from\n+\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n+\trevision 7d754b63ff2bf47226a67b2c0af5d74b54d4709f\n+\n+\t* java-gimplify.c (java_gimplify_block): Rename gimple subclass types.\n+\n+2014-10-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tIntroduce gimple_bind and use it for accessors.\n+\n+\t* java-gimplify.c (java_gimplify_block): Update local to be a\n+\tgimple_bind rather than just a gimple.\n+\n+Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+Copying and distribution of this file, with or without modification,\n+are permitted in any medium without royalty provided the copyright\n+notice and this notice are preserved."}, {"sha": "fe7a6e3288b0ef62f453ba7f8ccfd0a34b6ab6e8", "filename": "gcc/java/java-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fjava%2Fjava-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fjava%2Fjava-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-gimplify.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -137,7 +137,7 @@ java_gimplify_block (tree java_block)\n {\n   tree decls = BLOCK_VARS (java_block);\n   tree body = BLOCK_EXPR_BODY (java_block);\n-  gimple outer = gimple_current_bind_expr ();\n+  gbind *outer = gimple_current_bind_expr ();\n   tree block;\n \n   /* Don't bother with empty blocks.  */"}, {"sha": "588fd6ee0cd32f68304a7838c8c30edab4a4ef6f", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -799,15 +799,15 @@ fixup_call_stmt_edges_1 (struct cgraph_node *node, gimple *stmts,\n     {\n       if (gimple_stmt_max_uid (fn) < cedge->lto_stmt_uid)\n         fatal_error (\"Cgraph edge statement index out of range\");\n-      cedge->call_stmt = stmts[cedge->lto_stmt_uid - 1];\n+      cedge->call_stmt = as_a <gcall *> (stmts[cedge->lto_stmt_uid - 1]);\n       if (!cedge->call_stmt)\n         fatal_error (\"Cgraph edge statement index not found\");\n     }\n   for (cedge = node->indirect_calls; cedge; cedge = cedge->next_callee)\n     {\n       if (gimple_stmt_max_uid (fn) < cedge->lto_stmt_uid)\n         fatal_error (\"Cgraph edge statement index out of range\");\n-      cedge->call_stmt = stmts[cedge->lto_stmt_uid - 1];\n+      cedge->call_stmt = as_a <gcall *> (stmts[cedge->lto_stmt_uid - 1]);\n       if (!cedge->call_stmt)\n         fatal_error (\"Cgraph edge statement index not found\");\n     }"}, {"sha": "be041e9c8115c1b06e76228bcd903b36f69ed83b", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -2023,16 +2023,17 @@ output_function (struct cgraph_node *node)\n       set_gimple_stmt_max_uid (cfun, 0);\n       FOR_ALL_BB_FN (bb, cfun)\n \t{\n-\t  gimple_stmt_iterator gsi;\n-\t  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+\t       gsi_next (&gsi))\n \t    {\n-\t      gimple stmt = gsi_stmt (gsi);\n+\t      gphi *stmt = gsi.phi ();\n \n \t      /* Virtual PHIs are not going to be streamed.  */\n \t      if (!virtual_operand_p (gimple_phi_result (stmt)))\n \t        gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));\n \t    }\n-\t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+\t       gsi_next (&gsi))\n \t    {\n \t      gimple stmt = gsi_stmt (gsi);\n \t      gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));\n@@ -2042,10 +2043,10 @@ output_function (struct cgraph_node *node)\n \t virtual phis now.  */\n       FOR_ALL_BB_FN (bb, cfun)\n \t{\n-\t  gimple_stmt_iterator gsi;\n-\t  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+\t       gsi_next (&gsi))\n \t    {\n-\t      gimple stmt = gsi_stmt (gsi);\n+\t      gphi *stmt = gsi.phi ();\n \t      if (virtual_operand_p (gimple_phi_result (stmt)))\n \t        gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));\n \t    }"}, {"sha": "15aa140770cf02da74551d95a105029439a5aa8f", "filename": "gcc/omp-low.c", "status": "modified", "additions": 253, "deletions": 209, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -208,7 +208,7 @@ struct omp_for_data\n {\n   struct omp_for_data_loop loop;\n   tree chunk_size;\n-  gimple for_stmt;\n+  gomp_for *for_stmt;\n   tree pre, iter_type;\n   int collapse;\n   bool have_nowait, have_ordered;\n@@ -321,7 +321,7 @@ is_combined_parallel (struct omp_region *region)\n    them into *FD.  */\n \n static void\n-extract_omp_for_data (gimple for_stmt, struct omp_for_data *fd,\n+extract_omp_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \t\t      struct omp_for_data_loop *loops)\n {\n   tree t, var, *collapse_iter, *collapse_count;\n@@ -669,7 +669,7 @@ workshare_safe_to_combine_p (basic_block ws_entry_bb)\n \n   gcc_assert (gimple_code (ws_stmt) == GIMPLE_OMP_FOR);\n \n-  extract_omp_for_data (ws_stmt, &fd, NULL);\n+  extract_omp_for_data (as_a <gomp_for *> (ws_stmt), &fd, NULL);\n \n   if (fd.collapse > 1 && TREE_CODE (fd.loop.n2) != INTEGER_CST)\n     return false;\n@@ -702,16 +702,16 @@ get_ws_args_for (gimple par_stmt, gimple ws_stmt)\n   location_t loc = gimple_location (ws_stmt);\n   vec<tree, va_gc> *ws_args;\n \n-  if (gimple_code (ws_stmt) == GIMPLE_OMP_FOR)\n+  if (gomp_for *for_stmt = dyn_cast <gomp_for *> (ws_stmt))\n     {\n       struct omp_for_data fd;\n       tree n1, n2;\n \n-      extract_omp_for_data (ws_stmt, &fd, NULL);\n+      extract_omp_for_data (for_stmt, &fd, NULL);\n       n1 = fd.loop.n1;\n       n2 = fd.loop.n2;\n \n-      if (gimple_omp_for_combined_into_p (ws_stmt))\n+      if (gimple_omp_for_combined_into_p (for_stmt))\n \t{\n \t  tree innerc\n \t    = find_omp_clause (gimple_omp_parallel_clauses (par_stmt),\n@@ -1403,12 +1403,12 @@ static gimple_seq maybe_catch_exception (gimple_seq);\n /* Finalize task copyfn.  */\n \n static void\n-finalize_task_copyfn (gimple task_stmt)\n+finalize_task_copyfn (gomp_task *task_stmt)\n {\n   struct function *child_cfun;\n   tree child_fn;\n   gimple_seq seq = NULL, new_seq;\n-  gimple bind;\n+  gbind *bind;\n \n   child_fn = gimple_omp_task_copy_fn (task_stmt);\n   if (child_fn == NULL_TREE)\n@@ -1465,7 +1465,7 @@ delete_omp_context (splay_tree_value value)\n     }\n \n   if (is_task_ctx (ctx))\n-    finalize_task_copyfn (ctx->stmt);\n+    finalize_task_copyfn (as_a <gomp_task *> (ctx->stmt));\n \n   XDELETE (ctx);\n }\n@@ -2074,7 +2074,7 @@ scan_omp_parallel (gimple_stmt_iterator *gsi, omp_context *outer_ctx)\n {\n   omp_context *ctx;\n   tree name;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gomp_parallel *stmt = as_a <gomp_parallel *> (gsi_stmt (*gsi));\n \n   /* Ignore parallel directives with empty bodies, unless there\n      are copyin clauses.  */\n@@ -2089,16 +2089,15 @@ scan_omp_parallel (gimple_stmt_iterator *gsi, omp_context *outer_ctx)\n \n   if (gimple_omp_parallel_combined_p (stmt))\n     {\n-      gimple for_stmt;\n       struct walk_stmt_info wi;\n \n       memset (&wi, 0, sizeof (wi));\n       wi.val_only = true;\n       walk_gimple_seq (gimple_omp_body (stmt),\n \t\t       find_combined_for, NULL, &wi);\n-      for_stmt = (gimple) wi.info;\n-      if (for_stmt)\n+      if (wi.info)\n \t{\n+\t  gomp_for *for_stmt = as_a <gomp_for *> ((gimple) wi.info);\n \t  struct omp_for_data fd;\n \t  extract_omp_for_data (for_stmt, &fd, NULL);\n \t  /* We need two temporaries with fd.loop.v type (istart/iend)\n@@ -2152,7 +2151,7 @@ scan_omp_task (gimple_stmt_iterator *gsi, omp_context *outer_ctx)\n {\n   omp_context *ctx;\n   tree name, t;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gomp_task *stmt = as_a <gomp_task *> (gsi_stmt (*gsi));\n \n   /* Ignore task directives with empty bodies.  */\n   if (optimize > 0\n@@ -2298,7 +2297,7 @@ finish_taskreg_scan (omp_context *ctx)\n /* Scan an OpenMP loop directive.  */\n \n static void\n-scan_omp_for (gimple stmt, omp_context *outer_ctx)\n+scan_omp_for (gomp_for *stmt, omp_context *outer_ctx)\n {\n   omp_context *ctx;\n   size_t i;\n@@ -2321,7 +2320,7 @@ scan_omp_for (gimple stmt, omp_context *outer_ctx)\n /* Scan an OpenMP sections directive.  */\n \n static void\n-scan_omp_sections (gimple stmt, omp_context *outer_ctx)\n+scan_omp_sections (gomp_sections *stmt, omp_context *outer_ctx)\n {\n   omp_context *ctx;\n \n@@ -2333,7 +2332,7 @@ scan_omp_sections (gimple stmt, omp_context *outer_ctx)\n /* Scan an OpenMP single directive.  */\n \n static void\n-scan_omp_single (gimple stmt, omp_context *outer_ctx)\n+scan_omp_single (gomp_single *stmt, omp_context *outer_ctx)\n {\n   omp_context *ctx;\n   tree name;\n@@ -2358,7 +2357,7 @@ scan_omp_single (gimple stmt, omp_context *outer_ctx)\n /* Scan an OpenMP target{, data, update} directive.  */\n \n static void\n-scan_omp_target (gimple stmt, omp_context *outer_ctx)\n+scan_omp_target (gomp_target *stmt, omp_context *outer_ctx)\n {\n   omp_context *ctx;\n   tree name;\n@@ -2406,7 +2405,7 @@ scan_omp_target (gimple stmt, omp_context *outer_ctx)\n /* Scan an OpenMP teams directive.  */\n \n static void\n-scan_omp_teams (gimple stmt, omp_context *outer_ctx)\n+scan_omp_teams (gomp_teams *stmt, omp_context *outer_ctx)\n {\n   omp_context *ctx = new_omp_context (stmt, outer_ctx);\n   scan_sharing_clauses (gimple_omp_teams_clauses (stmt), ctx);\n@@ -2649,16 +2648,20 @@ check_omp_nesting_restrictions (gimple stmt, omp_context *ctx)\n \t  }\n       break;\n     case GIMPLE_OMP_CRITICAL:\n-      for (; ctx != NULL; ctx = ctx->outer)\n-\tif (gimple_code (ctx->stmt) == GIMPLE_OMP_CRITICAL\n-\t    && (gimple_omp_critical_name (stmt)\n-\t\t== gimple_omp_critical_name (ctx->stmt)))\n-\t  {\n-\t    error_at (gimple_location (stmt),\n-\t\t      \"critical region may not be nested inside a critical \"\n-\t\t      \"region with the same name\");\n-\t    return false;\n-\t  }\n+      {\n+\ttree this_stmt_name\n+\t  = gimple_omp_critical_name (as_a <gomp_critical *> (stmt));\n+\tfor (; ctx != NULL; ctx = ctx->outer)\n+\t  if (gomp_critical *other_crit\n+\t        = dyn_cast <gomp_critical *> (ctx->stmt))\n+\t    if (this_stmt_name == gimple_omp_critical_name (other_crit))\n+\t      {\n+\t\terror_at (gimple_location (stmt),\n+\t\t\t  \"critical region may not be nested inside a critical \"\n+\t\t\t  \"region with the same name\");\n+\t\treturn false;\n+\t      }\n+      }\n       break;\n     case GIMPLE_OMP_TEAMS:\n       if (ctx == NULL\n@@ -2831,15 +2834,15 @@ scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       break;\n \n     case GIMPLE_OMP_FOR:\n-      scan_omp_for (stmt, ctx);\n+      scan_omp_for (as_a <gomp_for *> (stmt), ctx);\n       break;\n \n     case GIMPLE_OMP_SECTIONS:\n-      scan_omp_sections (stmt, ctx);\n+      scan_omp_sections (as_a <gomp_sections *> (stmt), ctx);\n       break;\n \n     case GIMPLE_OMP_SINGLE:\n-      scan_omp_single (stmt, ctx);\n+      scan_omp_single (as_a <gomp_single *> (stmt), ctx);\n       break;\n \n     case GIMPLE_OMP_SECTION:\n@@ -2852,11 +2855,11 @@ scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       break;\n \n     case GIMPLE_OMP_TARGET:\n-      scan_omp_target (stmt, ctx);\n+      scan_omp_target (as_a <gomp_target *> (stmt), ctx);\n       break;\n \n     case GIMPLE_OMP_TEAMS:\n-      scan_omp_teams (stmt, ctx);\n+      scan_omp_teams (as_a <gomp_teams *> (stmt), ctx);\n       break;\n \n     case GIMPLE_BIND:\n@@ -2865,7 +2868,9 @@ scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \n \t*handled_ops_p = false;\n \tif (ctx)\n-\t  for (var = gimple_bind_vars (stmt); var ; var = DECL_CHAIN (var))\n+\t  for (var = gimple_bind_vars (as_a <gbind *> (stmt));\n+\t       var ;\n+\t       var = DECL_CHAIN (var))\n \t    insert_decl_map (&ctx->cb, var, var);\n       }\n       break;\n@@ -2906,7 +2911,7 @@ build_omp_barrier (tree lhs)\n {\n   tree fndecl = builtin_decl_explicit (lhs ? BUILT_IN_GOMP_BARRIER_CANCEL\n \t\t\t\t\t   : BUILT_IN_GOMP_BARRIER);\n-  gimple g = gimple_build_call (fndecl, 0);\n+  gcall *g = gimple_build_call (fndecl, 0);\n   if (lhs)\n     gimple_call_set_lhs (g, lhs);\n   return g;\n@@ -3369,7 +3374,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \n \t      if (c_kind != OMP_CLAUSE_FIRSTPRIVATE || !is_task_ctx (ctx))\n \t\t{\n-\t\t  gimple stmt;\n+\t\t  gcall *stmt;\n \t\t  tree tmp, atmp;\n \n \t\t  ptr = DECL_VALUE_EXPR (new_var);\n@@ -3622,7 +3627,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t  gimplify_and_add (x, ilist);\n \t\t\t  gimple_stmt_iterator gsi\n \t\t\t    = gsi_start_1 (gimple_omp_body_ptr (ctx->stmt));\n-\t\t\t  gimple g\n+\t\t\t  gassign *g\n \t\t\t    = gimple_build_assign (unshare_expr (lvar), iv);\n \t\t\t  gsi_insert_before_without_update (&gsi, g,\n \t\t\t\t\t\t\t    GSI_SAME_STMT);\n@@ -3958,7 +3963,7 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n \n   if (predicate)\n     {\n-      gimple stmt;\n+      gcond *stmt;\n       tree label_true, arm1, arm2;\n \n       label = create_artificial_label (UNKNOWN_LOCATION);\n@@ -4005,7 +4010,7 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n \t\t  if (lastlane == NULL)\n \t\t    {\n \t\t      lastlane = create_tmp_var (unsigned_type_node, NULL);\n-\t\t      gimple g\n+\t\t      gcall *g\n \t\t\t= gimple_build_call_internal (IFN_GOMP_SIMD_LAST_LANE,\n \t\t\t\t\t\t      2, simduid,\n \t\t\t\t\t\t      TREE_OPERAND (val, 1));\n@@ -4361,7 +4366,7 @@ lower_send_shared_vars (gimple_seq *ilist, gimple_seq *olist, omp_context *ctx)\n /* A convenience function to build an empty GIMPLE_COND with just the\n    condition.  */\n \n-static gimple\n+static gcond *\n gimple_build_cond_empty (tree cond)\n {\n   enum tree_code pred_code;\n@@ -4381,7 +4386,8 @@ gimple_build_cond_empty (tree cond)\n \n static void\n expand_parallel_call (struct omp_region *region, basic_block bb,\n-\t\t      gimple entry_stmt, vec<tree, va_gc> *ws_args)\n+\t\t      gomp_parallel *entry_stmt,\n+\t\t      vec<tree, va_gc> *ws_args)\n {\n   tree t, t1, t2, val, cond, c, clauses, flags;\n   gimple_stmt_iterator gsi;\n@@ -4504,7 +4510,7 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n \n \t  if (gimple_in_ssa_p (cfun))\n \t    {\n-\t      gimple phi = create_phi_node (tmp_join, bb);\n+\t      gphi *phi = create_phi_node (tmp_join, bb);\n \t      add_phi_arg (phi, tmp_then, e_then, UNKNOWN_LOCATION);\n \t      add_phi_arg (phi, tmp_else, e_else, UNKNOWN_LOCATION);\n \t    }\n@@ -4544,7 +4550,7 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n    ENTRY_STMT into the basic_block BB.  */\n \n static void\n-expand_cilk_for_call (basic_block bb, gimple entry_stmt,\n+expand_cilk_for_call (basic_block bb, gomp_parallel *entry_stmt,\n \t\t      vec <tree, va_gc> *ws_args)\n {\n   tree t, t1, t2;\n@@ -4583,7 +4589,7 @@ expand_cilk_for_call (basic_block bb, gimple entry_stmt,\n    generate the task operation.  BB is the block where to insert the code.  */\n \n static void\n-expand_task_call (basic_block bb, gimple entry_stmt)\n+expand_task_call (basic_block bb, gomp_task *entry_stmt)\n {\n   tree t, t1, t2, t3, flags, cond, c, c2, clauses, depend;\n   gimple_stmt_iterator gsi;\n@@ -4737,7 +4743,8 @@ remove_exit_barrier (struct omp_region *region)\n \t     of such a variable.  */\n \t  if (any_addressable_vars < 0)\n \t    {\n-\t      gimple parallel_stmt = last_stmt (region->entry);\n+\t      gomp_parallel *parallel_stmt\n+\t\t= as_a <gomp_parallel *> (last_stmt (region->entry));\n \t      tree child_fun = gimple_omp_parallel_child_fn (parallel_stmt);\n \t      tree local_decls, block, decl;\n \t      unsigned ix;\n@@ -5137,11 +5144,13 @@ expand_omp_taskreg (struct omp_region *region)\n \n   /* Emit a library call to launch the children threads.  */\n   if (is_cilk_for)\n-    expand_cilk_for_call (new_bb, entry_stmt, ws_args);\n+    expand_cilk_for_call (new_bb,\n+\t\t\t  as_a <gomp_parallel *> (entry_stmt), ws_args);\n   else if (gimple_code (entry_stmt) == GIMPLE_OMP_PARALLEL)\n-    expand_parallel_call (region, new_bb, entry_stmt, ws_args);\n+    expand_parallel_call (region, new_bb,\n+\t\t\t  as_a <gomp_parallel *> (entry_stmt), ws_args);\n   else\n-    expand_task_call (new_bb, entry_stmt);\n+    expand_task_call (new_bb, as_a <gomp_task *> (entry_stmt));\n   if (gimple_in_ssa_p (cfun))\n     update_ssa (TODO_update_ssa_only_virtuals);\n }\n@@ -5207,7 +5216,6 @@ expand_omp_for_init_counts (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t\t\t    basic_block &l2_dom_bb)\n {\n   tree t, type = TREE_TYPE (fd->loop.v);\n-  gimple stmt;\n   edge e, ne;\n   int i;\n \n@@ -5246,34 +5254,36 @@ expand_omp_for_init_counts (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t\t\t\tfold_convert (itype, fd->loops[i].n2)))\n \t      == NULL_TREE || !integer_onep (t)))\n \t{\n+\t  gcond *cond_stmt;\n \t  tree n1, n2;\n \t  n1 = fold_convert (itype, unshare_expr (fd->loops[i].n1));\n \t  n1 = force_gimple_operand_gsi (gsi, n1, true, NULL_TREE,\n \t\t\t\t\t true, GSI_SAME_STMT);\n \t  n2 = fold_convert (itype, unshare_expr (fd->loops[i].n2));\n \t  n2 = force_gimple_operand_gsi (gsi, n2, true, NULL_TREE,\n \t\t\t\t\t true, GSI_SAME_STMT);\n-\t  stmt = gimple_build_cond (fd->loops[i].cond_code, n1, n2,\n-\t\t\t\t    NULL_TREE, NULL_TREE);\n-\t  gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n-\t  if (walk_tree (gimple_cond_lhs_ptr (stmt),\n+\t  cond_stmt = gimple_build_cond (fd->loops[i].cond_code, n1, n2,\n+\t\t\t\t\t NULL_TREE, NULL_TREE);\n+\t  gsi_insert_before (gsi, cond_stmt, GSI_SAME_STMT);\n+\t  if (walk_tree (gimple_cond_lhs_ptr (cond_stmt),\n \t\t\t expand_omp_regimplify_p, NULL, NULL)\n-\t      || walk_tree (gimple_cond_rhs_ptr (stmt),\n+\t      || walk_tree (gimple_cond_rhs_ptr (cond_stmt),\n \t\t\t    expand_omp_regimplify_p, NULL, NULL))\n \t    {\n-\t      *gsi = gsi_for_stmt (stmt);\n-\t      gimple_regimplify_operands (stmt, gsi);\n+\t      *gsi = gsi_for_stmt (cond_stmt);\n+\t      gimple_regimplify_operands (cond_stmt, gsi);\n \t    }\n-\t  e = split_block (entry_bb, stmt);\n+\t  e = split_block (entry_bb, cond_stmt);\n \t  if (zero_iter_bb == NULL)\n \t    {\n+\t      gassign *assign_stmt;\n \t      first_zero_iter = i;\n \t      zero_iter_bb = create_empty_bb (entry_bb);\n \t      add_bb_to_loop (zero_iter_bb, entry_bb->loop_father);\n \t      *gsi = gsi_after_labels (zero_iter_bb);\n-\t      stmt = gimple_build_assign (fd->loop.n2,\n-\t\t\t\t\t  build_zero_cst (type));\n-\t      gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n+\t      assign_stmt = gimple_build_assign (fd->loop.n2,\n+\t\t\t\t\t\t build_zero_cst (type));\n+\t      gsi_insert_before (gsi, assign_stmt, GSI_SAME_STMT);\n \t      set_immediate_dominator (CDI_DOMINATORS, zero_iter_bb,\n \t\t\t\t       entry_bb);\n \t    }\n@@ -5374,7 +5384,7 @@ expand_omp_for_init_vars (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t      tree t = fold_convert (TREE_TYPE (tem), counts[i]);\n \t      t = force_gimple_operand_gsi (gsi, t, false, NULL_TREE,\n \t\t\t\t\t    false, GSI_CONTINUE_LINKING);\n-\t      gimple stmt = gimple_build_assign (tem, t);\n+\t      gassign *stmt = gimple_build_assign (tem, t);\n \t      gsi_insert_after (gsi, stmt, GSI_CONTINUE_LINKING);\n \t    }\n \t}\n@@ -5383,7 +5393,7 @@ expand_omp_for_init_vars (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \n   tree type = TREE_TYPE (fd->loop.v);\n   tree tem = create_tmp_reg (type, \".tem\");\n-  gimple stmt = gimple_build_assign (tem, startvar);\n+  gassign *stmt = gimple_build_assign (tem, startvar);\n   gsi_insert_after (gsi, stmt, GSI_CONTINUE_LINKING);\n \n   for (i = fd->collapse - 1; i >= 0; i--)\n@@ -5613,7 +5623,7 @@ expand_omp_for_generic (struct omp_region *region,\n   basic_block entry_bb, cont_bb, exit_bb, l0_bb, l1_bb, collapse_bb;\n   basic_block l2_bb = NULL, l3_bb = NULL;\n   gimple_stmt_iterator gsi;\n-  gimple stmt;\n+  gassign *assign_stmt;\n   bool in_combined_parallel = is_combined_parallel (region);\n   bool broken_loop = region->cont == NULL;\n   edge e, ne;\n@@ -5828,8 +5838,8 @@ expand_omp_for_generic (struct omp_region *region,\n \t\t\t\tDECL_P (startvar)\n \t\t\t\t&& TREE_ADDRESSABLE (startvar),\n \t\t\t\tNULL_TREE, false, GSI_CONTINUE_LINKING);\n-  stmt = gimple_build_assign (startvar, t);\n-  gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+  assign_stmt = gimple_build_assign (startvar, t);\n+  gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n \n   t = iend0;\n   if (bias)\n@@ -5841,13 +5851,13 @@ expand_omp_for_generic (struct omp_region *region,\n \t\t\t\t   false, GSI_CONTINUE_LINKING);\n   if (endvar)\n     {\n-      stmt = gimple_build_assign (endvar, iend);\n-      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+      assign_stmt = gimple_build_assign (endvar, iend);\n+      gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n       if (useless_type_conversion_p (TREE_TYPE (fd->loop.v), TREE_TYPE (iend)))\n-\tstmt = gimple_build_assign (fd->loop.v, iend);\n+\tassign_stmt = gimple_build_assign (fd->loop.v, iend);\n       else\n-\tstmt = gimple_build_assign_with_ops (NOP_EXPR, fd->loop.v, iend);\n-      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+\tassign_stmt = gimple_build_assign_with_ops (NOP_EXPR, fd->loop.v, iend);\n+      gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n     }\n   if (fd->collapse > 1)\n     expand_omp_for_init_vars (fd, &gsi, counts, inner_stmt, startvar);\n@@ -5857,10 +5867,10 @@ expand_omp_for_generic (struct omp_region *region,\n       /* Code to control the increment and predicate for the sequential\n \t loop goes in the CONT_BB.  */\n       gsi = gsi_last_bb (cont_bb);\n-      stmt = gsi_stmt (gsi);\n-      gcc_assert (gimple_code (stmt) == GIMPLE_OMP_CONTINUE);\n-      vmain = gimple_omp_continue_control_use (stmt);\n-      vback = gimple_omp_continue_control_def (stmt);\n+      gomp_continue *cont_stmt = as_a <gomp_continue *> (gsi_stmt (gsi));\n+      gcc_assert (gimple_code (cont_stmt) == GIMPLE_OMP_CONTINUE);\n+      vmain = gimple_omp_continue_control_use (cont_stmt);\n+      vback = gimple_omp_continue_control_def (cont_stmt);\n \n       if (!gimple_omp_for_combined_p (fd->for_stmt))\n \t{\n@@ -5872,14 +5882,14 @@ expand_omp_for_generic (struct omp_region *region,\n \t\t\t\t\tDECL_P (vback)\n \t\t\t\t\t&& TREE_ADDRESSABLE (vback),\n \t\t\t\t\tNULL_TREE, true, GSI_SAME_STMT);\n-\t  stmt = gimple_build_assign (vback, t);\n-\t  gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+\t  assign_stmt = gimple_build_assign (vback, t);\n+\t  gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n \n \t  t = build2 (fd->loop.cond_code, boolean_type_node,\n \t\t      DECL_P (vback) && TREE_ADDRESSABLE (vback) ? t : vback,\n \t\t      iend);\n-\t  stmt = gimple_build_cond_empty (t);\n-\t  gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+\t  gcond *cond_stmt = gimple_build_cond_empty (t);\n+\t  gsi_insert_before (&gsi, cond_stmt, GSI_SAME_STMT);\n \t}\n \n       /* Remove GIMPLE_OMP_CONTINUE.  */\n@@ -5899,8 +5909,8 @@ expand_omp_for_generic (struct omp_region *region,\n       if (TREE_TYPE (t) != boolean_type_node)\n \tt = fold_build2 (NE_EXPR, boolean_type_node,\n \t\t\t t, build_int_cst (TREE_TYPE (t), 0));\n-      stmt = gimple_build_cond_empty (t);\n-      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+      gcond *cond_stmt = gimple_build_cond_empty (t);\n+      gsi_insert_after (&gsi, cond_stmt, GSI_CONTINUE_LINKING);\n     }\n \n   /* Add the loop cleanup function.  */\n@@ -5911,10 +5921,10 @@ expand_omp_for_generic (struct omp_region *region,\n     t = builtin_decl_explicit (BUILT_IN_GOMP_LOOP_END_CANCEL);\n   else\n     t = builtin_decl_explicit (BUILT_IN_GOMP_LOOP_END);\n-  stmt = gimple_build_call (t, 0);\n+  gcall *call_stmt = gimple_build_call (t, 0);\n   if (gimple_omp_return_lhs (gsi_stmt (gsi)))\n-    gimple_call_set_lhs (stmt, gimple_omp_return_lhs (gsi_stmt (gsi)));\n-  gsi_insert_after (&gsi, stmt, GSI_SAME_STMT);\n+    gimple_call_set_lhs (call_stmt, gimple_omp_return_lhs (gsi_stmt (gsi)));\n+  gsi_insert_after (&gsi, call_stmt, GSI_SAME_STMT);\n   gsi_remove (&gsi, true);\n \n   /* Connect the new blocks.  */\n@@ -6037,7 +6047,6 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   basic_block body_bb, cont_bb, collapse_bb = NULL;\n   basic_block fin_bb;\n   gimple_stmt_iterator gsi;\n-  gimple stmt;\n   edge ep;\n   enum built_in_function get_num_threads = BUILT_IN_OMP_GET_NUM_THREADS;\n   enum built_in_function get_thread_num = BUILT_IN_OMP_GET_THREAD_NUM;\n@@ -6101,18 +6110,18 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n       n2 = fold_convert (type, unshare_expr (fd->loop.n2));\n       n2 = force_gimple_operand_gsi (&gsi, n2, true, NULL_TREE,\n \t\t\t\t     true, GSI_SAME_STMT);\n-      stmt = gimple_build_cond (fd->loop.cond_code, n1, n2,\n-\t\t\t\tNULL_TREE, NULL_TREE);\n-      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n-      if (walk_tree (gimple_cond_lhs_ptr (stmt),\n+      gcond *cond_stmt = gimple_build_cond (fd->loop.cond_code, n1, n2,\n+\t\t\t\t\t\t NULL_TREE, NULL_TREE);\n+      gsi_insert_before (&gsi, cond_stmt, GSI_SAME_STMT);\n+      if (walk_tree (gimple_cond_lhs_ptr (cond_stmt),\n \t\t     expand_omp_regimplify_p, NULL, NULL)\n-\t  || walk_tree (gimple_cond_rhs_ptr (stmt),\n+\t  || walk_tree (gimple_cond_rhs_ptr (cond_stmt),\n \t\t\texpand_omp_regimplify_p, NULL, NULL))\n \t{\n-\t  gsi = gsi_for_stmt (stmt);\n-\t  gimple_regimplify_operands (stmt, &gsi);\n+\t  gsi = gsi_for_stmt (cond_stmt);\n+\t  gimple_regimplify_operands (cond_stmt, &gsi);\n \t}\n-      ep = split_block (entry_bb, stmt);\n+      ep = split_block (entry_bb, cond_stmt);\n       ep->flags = EDGE_TRUE_VALUE;\n       entry_bb = ep->dest;\n       ep->probability = REG_BR_PROB_BASE - (REG_BR_PROB_BASE / 2000 - 1);\n@@ -6121,10 +6130,10 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n       if (gimple_in_ssa_p (cfun))\n \t{\n \t  int dest_idx = find_edge (entry_bb, fin_bb)->dest_idx;\n-\t  for (gsi = gsi_start_phis (fin_bb);\n-\t       !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  for (gphi_iterator gpi = gsi_start_phis (fin_bb);\n+\t       !gsi_end_p (gpi); gsi_next (&gpi))\n \t    {\n-\t      gimple phi = gsi_stmt (gsi);\n+\t      gphi *phi = gpi.phi ();\n \t      add_phi_arg (phi, gimple_phi_arg_def (phi, dest_idx),\n \t\t\t   ep, UNKNOWN_LOCATION);\n \t    }\n@@ -6187,20 +6196,21 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   gsi_insert_before (&gsi, gimple_build_assign (tt, t), GSI_SAME_STMT);\n \n   t = build2 (LT_EXPR, boolean_type_node, threadid, tt);\n-  stmt = gimple_build_cond_empty (t);\n-  gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+  gcond *cond_stmt = gimple_build_cond_empty (t);\n+  gsi_insert_before (&gsi, cond_stmt, GSI_SAME_STMT);\n \n-  second_bb = split_block (entry_bb, stmt)->dest;\n+  second_bb = split_block (entry_bb, cond_stmt)->dest;\n   gsi = gsi_last_bb (second_bb);\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n \n   gsi_insert_before (&gsi, gimple_build_assign (tt, build_int_cst (itype, 0)),\n \t\t     GSI_SAME_STMT);\n-  stmt = gimple_build_assign_with_ops (PLUS_EXPR, q, q,\n-\t\t\t\t       build_int_cst (itype, 1));\n-  gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+  gassign *assign_stmt\n+    = gimple_build_assign_with_ops (PLUS_EXPR, q, q,\n+\t\t\t\t    build_int_cst (itype, 1));\n+  gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n \n-  third_bb = split_block (second_bb, stmt)->dest;\n+  third_bb = split_block (second_bb, assign_stmt)->dest;\n   gsi = gsi_last_bb (third_bb);\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n \n@@ -6247,8 +6257,8 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n \t\t\t\tDECL_P (startvar)\n \t\t\t\t&& TREE_ADDRESSABLE (startvar),\n \t\t\t\tNULL_TREE, false, GSI_CONTINUE_LINKING);\n-  stmt = gimple_build_assign (startvar, t);\n-  gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+  assign_stmt = gimple_build_assign (startvar, t);\n+  gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n \n   t = fold_convert (itype, e0);\n   t = fold_build2 (MULT_EXPR, itype, t, step);\n@@ -6261,13 +6271,13 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n \t\t\t\tfalse, GSI_CONTINUE_LINKING);\n   if (endvar)\n     {\n-      stmt = gimple_build_assign (endvar, e);\n-      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+      assign_stmt = gimple_build_assign (endvar, e);\n+      gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n       if (useless_type_conversion_p (TREE_TYPE (fd->loop.v), TREE_TYPE (e)))\n-\tstmt = gimple_build_assign (fd->loop.v, e);\n+\tassign_stmt = gimple_build_assign (fd->loop.v, e);\n       else\n-\tstmt = gimple_build_assign_with_ops (NOP_EXPR, fd->loop.v, e);\n-      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+\tassign_stmt = gimple_build_assign_with_ops (NOP_EXPR, fd->loop.v, e);\n+      gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n     }\n   if (fd->collapse > 1)\n     expand_omp_for_init_vars (fd, &gsi, counts, inner_stmt, startvar);\n@@ -6277,10 +6287,10 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n       /* The code controlling the sequential loop replaces the\n \t GIMPLE_OMP_CONTINUE.  */\n       gsi = gsi_last_bb (cont_bb);\n-      stmt = gsi_stmt (gsi);\n-      gcc_assert (gimple_code (stmt) == GIMPLE_OMP_CONTINUE);\n-      vmain = gimple_omp_continue_control_use (stmt);\n-      vback = gimple_omp_continue_control_def (stmt);\n+      gomp_continue *cont_stmt = as_a <gomp_continue *> (gsi_stmt (gsi));\n+      gcc_assert (gimple_code (cont_stmt) == GIMPLE_OMP_CONTINUE);\n+      vmain = gimple_omp_continue_control_use (cont_stmt);\n+      vback = gimple_omp_continue_control_def (cont_stmt);\n \n       if (!gimple_omp_for_combined_p (fd->for_stmt))\n \t{\n@@ -6292,8 +6302,8 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n \t\t\t\t\tDECL_P (vback)\n \t\t\t\t\t&& TREE_ADDRESSABLE (vback),\n \t\t\t\t\tNULL_TREE, true, GSI_SAME_STMT);\n-\t  stmt = gimple_build_assign (vback, t);\n-\t  gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+\t  assign_stmt = gimple_build_assign (vback, t);\n+\t  gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n \n \t  t = build2 (fd->loop.cond_code, boolean_type_node,\n \t\t      DECL_P (vback) && TREE_ADDRESSABLE (vback)\n@@ -6413,7 +6423,6 @@ expand_omp_for_static_chunk (struct omp_region *region,\n   basic_block entry_bb, exit_bb, body_bb, seq_start_bb, iter_part_bb;\n   basic_block trip_update_bb = NULL, cont_bb, collapse_bb = NULL, fin_bb;\n   gimple_stmt_iterator gsi;\n-  gimple stmt;\n   edge se;\n   enum built_in_function get_num_threads = BUILT_IN_OMP_GET_NUM_THREADS;\n   enum built_in_function get_thread_num = BUILT_IN_OMP_GET_THREAD_NUM;\n@@ -6481,18 +6490,18 @@ expand_omp_for_static_chunk (struct omp_region *region,\n       n2 = fold_convert (type, unshare_expr (fd->loop.n2));\n       n2 = force_gimple_operand_gsi (&gsi, n2, true, NULL_TREE,\n \t\t\t\t     true, GSI_SAME_STMT);\n-      stmt = gimple_build_cond (fd->loop.cond_code, n1, n2,\n-\t\t\t\tNULL_TREE, NULL_TREE);\n-      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n-      if (walk_tree (gimple_cond_lhs_ptr (stmt),\n+      gcond *cond_stmt = gimple_build_cond (fd->loop.cond_code, n1, n2,\n+\t\t\t\t\t\t NULL_TREE, NULL_TREE);\n+      gsi_insert_before (&gsi, cond_stmt, GSI_SAME_STMT);\n+      if (walk_tree (gimple_cond_lhs_ptr (cond_stmt),\n \t\t     expand_omp_regimplify_p, NULL, NULL)\n-\t  || walk_tree (gimple_cond_rhs_ptr (stmt),\n+\t  || walk_tree (gimple_cond_rhs_ptr (cond_stmt),\n \t\t\texpand_omp_regimplify_p, NULL, NULL))\n \t{\n-\t  gsi = gsi_for_stmt (stmt);\n-\t  gimple_regimplify_operands (stmt, &gsi);\n+\t  gsi = gsi_for_stmt (cond_stmt);\n+\t  gimple_regimplify_operands (cond_stmt, &gsi);\n \t}\n-      se = split_block (entry_bb, stmt);\n+      se = split_block (entry_bb, cond_stmt);\n       se->flags = EDGE_TRUE_VALUE;\n       entry_bb = se->dest;\n       se->probability = REG_BR_PROB_BASE - (REG_BR_PROB_BASE / 2000 - 1);\n@@ -6501,10 +6510,10 @@ expand_omp_for_static_chunk (struct omp_region *region,\n       if (gimple_in_ssa_p (cfun))\n \t{\n \t  int dest_idx = find_edge (entry_bb, fin_bb)->dest_idx;\n-\t  for (gsi = gsi_start_phis (fin_bb);\n-\t       !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  for (gphi_iterator gpi = gsi_start_phis (fin_bb);\n+\t       !gsi_end_p (gpi); gsi_next (&gpi))\n \t    {\n-\t      gimple phi = gsi_stmt (gsi);\n+\t      gphi *phi = gpi.phi ();\n \t      add_phi_arg (phi, gimple_phi_arg_def (phi, dest_idx),\n \t\t\t   se, UNKNOWN_LOCATION);\n \t    }\n@@ -6574,8 +6583,9 @@ expand_omp_for_static_chunk (struct omp_region *region,\n       trip_back = trip_var;\n     }\n \n-  stmt = gimple_build_assign (trip_init, build_int_cst (itype, 0));\n-  gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+  gassign *assign_stmt\n+    = gimple_build_assign (trip_init, build_int_cst (itype, 0));\n+  gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n \n   t = fold_build2 (MULT_EXPR, itype, threadid, fd->chunk_size);\n   t = fold_build2 (MULT_EXPR, itype, t, step);\n@@ -6637,8 +6647,8 @@ expand_omp_for_static_chunk (struct omp_region *region,\n \t\t\t\tDECL_P (startvar)\n \t\t\t\t&& TREE_ADDRESSABLE (startvar),\n \t\t\t\tNULL_TREE, false, GSI_CONTINUE_LINKING);\n-  stmt = gimple_build_assign (startvar, t);\n-  gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+  assign_stmt = gimple_build_assign (startvar, t);\n+  gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n \n   t = fold_convert (itype, e0);\n   t = fold_build2 (MULT_EXPR, itype, t, step);\n@@ -6651,13 +6661,13 @@ expand_omp_for_static_chunk (struct omp_region *region,\n \t\t\t\tfalse, GSI_CONTINUE_LINKING);\n   if (endvar)\n     {\n-      stmt = gimple_build_assign (endvar, e);\n-      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+      assign_stmt = gimple_build_assign (endvar, e);\n+      gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n       if (useless_type_conversion_p (TREE_TYPE (fd->loop.v), TREE_TYPE (e)))\n-\tstmt = gimple_build_assign (fd->loop.v, e);\n+\tassign_stmt = gimple_build_assign (fd->loop.v, e);\n       else\n-\tstmt = gimple_build_assign_with_ops (NOP_EXPR, fd->loop.v, e);\n-      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+\tassign_stmt = gimple_build_assign_with_ops (NOP_EXPR, fd->loop.v, e);\n+      gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n     }\n   if (fd->collapse > 1)\n     expand_omp_for_init_vars (fd, &gsi, counts, inner_stmt, startvar);\n@@ -6667,10 +6677,9 @@ expand_omp_for_static_chunk (struct omp_region *region,\n       /* The code controlling the sequential loop goes in CONT_BB,\n \t replacing the GIMPLE_OMP_CONTINUE.  */\n       gsi = gsi_last_bb (cont_bb);\n-      stmt = gsi_stmt (gsi);\n-      gcc_assert (gimple_code (stmt) == GIMPLE_OMP_CONTINUE);\n-      vmain = gimple_omp_continue_control_use (stmt);\n-      vback = gimple_omp_continue_control_def (stmt);\n+      gomp_continue *cont_stmt = as_a <gomp_continue *> (gsi_stmt (gsi));\n+      vmain = gimple_omp_continue_control_use (cont_stmt);\n+      vback = gimple_omp_continue_control_def (cont_stmt);\n \n       if (!gimple_omp_for_combined_p (fd->for_stmt))\n \t{\n@@ -6681,8 +6690,8 @@ expand_omp_for_static_chunk (struct omp_region *region,\n \t  if (DECL_P (vback) && TREE_ADDRESSABLE (vback))\n \t    t = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t\t\t  true, GSI_SAME_STMT);\n-\t  stmt = gimple_build_assign (vback, t);\n-\t  gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+\t  assign_stmt = gimple_build_assign (vback, t);\n+\t  gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n \n \t  t = build2 (fd->loop.cond_code, boolean_type_node,\n \t\t      DECL_P (vback) && TREE_ADDRESSABLE (vback)\n@@ -6701,8 +6710,8 @@ expand_omp_for_static_chunk (struct omp_region *region,\n \n       t = build_int_cst (itype, 1);\n       t = build2 (PLUS_EXPR, itype, trip_main, t);\n-      stmt = gimple_build_assign (trip_back, t);\n-      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+      assign_stmt = gimple_build_assign (trip_back, t);\n+      gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n     }\n \n   /* Replace the GIMPLE_OMP_RETURN with a barrier, or nothing.  */\n@@ -6741,8 +6750,8 @@ expand_omp_for_static_chunk (struct omp_region *region,\n \n   if (gimple_in_ssa_p (cfun))\n     {\n-      gimple_stmt_iterator psi;\n-      gimple phi;\n+      gphi_iterator psi;\n+      gphi *phi;\n       edge re, ene;\n       edge_var_map *vm;\n       size_t i;\n@@ -6761,10 +6770,10 @@ expand_omp_for_static_chunk (struct omp_region *region,\n       for (i = 0; !gsi_end_p (psi) && head->iterate (i, &vm);\n \t   gsi_next (&psi), ++i)\n \t{\n-\t  gimple nphi;\n+\t  gphi *nphi;\n \t  source_location locus;\n \n-\t  phi = gsi_stmt (psi);\n+\t  phi = psi.phi ();\n \t  t = gimple_phi_result (phi);\n \t  gcc_assert (t == redirect_edge_var_map_result (vm));\n \t  nphi = create_phi_node (t, iter_part_bb);\n@@ -6890,7 +6899,8 @@ expand_cilk_for (struct omp_region *region, struct omp_for_data *fd)\n      comment).  */\n \n   tree child_fndecl\n-    = gimple_omp_parallel_child_fn (last_stmt (region->outer->entry));\n+    = gimple_omp_parallel_child_fn (\n+        as_a <gomp_parallel *> (last_stmt (region->outer->entry)));\n   tree t, low_val = NULL_TREE, high_val = NULL_TREE;\n   for (t = DECL_ARGUMENTS (child_fndecl); t; t = TREE_CHAIN (t))\n     {\n@@ -7080,6 +7090,7 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n   basic_block entry_bb, cont_bb, exit_bb, l0_bb, l1_bb, l2_bb, l2_dom_bb;\n   gimple_stmt_iterator gsi;\n   gimple stmt;\n+  gcond *cond_stmt;\n   bool broken_loop = region->cont == NULL;\n   edge e, ne;\n   tree *counts = NULL;\n@@ -7239,15 +7250,15 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n   t = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t\tfalse, GSI_CONTINUE_LINKING);\n   t = build2 (fd->loop.cond_code, boolean_type_node, fd->loop.v, t);\n-  stmt = gimple_build_cond_empty (t);\n-  gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n-  if (walk_tree (gimple_cond_lhs_ptr (stmt), expand_omp_regimplify_p,\n+  cond_stmt = gimple_build_cond_empty (t);\n+  gsi_insert_after (&gsi, cond_stmt, GSI_CONTINUE_LINKING);\n+  if (walk_tree (gimple_cond_lhs_ptr (cond_stmt), expand_omp_regimplify_p,\n \t\t NULL, NULL)\n-      || walk_tree (gimple_cond_rhs_ptr (stmt), expand_omp_regimplify_p,\n+      || walk_tree (gimple_cond_rhs_ptr (cond_stmt), expand_omp_regimplify_p,\n \t\t    NULL, NULL))\n     {\n-      gsi = gsi_for_stmt (stmt);\n-      gimple_regimplify_operands (stmt, &gsi);\n+      gsi = gsi_for_stmt (cond_stmt);\n+      gimple_regimplify_operands (cond_stmt, &gsi);\n     }\n \n   /* Remove GIMPLE_OMP_RETURN.  */\n@@ -7335,7 +7346,8 @@ expand_omp_for (struct omp_region *region, gimple inner_stmt)\n     = (struct omp_for_data_loop *)\n       alloca (gimple_omp_for_collapse (last_stmt (region->entry))\n \t      * sizeof (struct omp_for_data_loop));\n-  extract_omp_for_data (last_stmt (region->entry), &fd, loops);\n+  extract_omp_for_data (as_a <gomp_for *> (last_stmt (region->entry)),\n+\t\t\t&fd, loops);\n   region->sched_kind = fd.sched_kind;\n \n   gcc_assert (EDGE_COUNT (region->entry->succs) == 2);\n@@ -7430,7 +7442,9 @@ expand_omp_sections (struct omp_region *region)\n   unsigned len;\n   basic_block entry_bb, l0_bb, l1_bb, l2_bb, default_bb;\n   gimple_stmt_iterator si, switch_si;\n-  gimple sections_stmt, stmt, cont;\n+  gomp_sections *sections_stmt;\n+  gimple stmt;\n+  gomp_continue *cont;\n   edge_iterator ei;\n   edge e;\n   struct omp_region *inner;\n@@ -7484,7 +7498,7 @@ expand_omp_sections (struct omp_region *region)\n   /* The call to GOMP_sections_start goes in ENTRY_BB, replacing the\n      GIMPLE_OMP_SECTIONS statement.  */\n   si = gsi_last_bb (entry_bb);\n-  sections_stmt = gsi_stmt (si);\n+  sections_stmt = as_a <gomp_sections *> (gsi_stmt (si));\n   gcc_assert (gimple_code (sections_stmt) == GIMPLE_OMP_SECTIONS);\n   vin = gimple_omp_sections_control (sections_stmt);\n   if (!is_combined_parallel (region))\n@@ -7511,7 +7525,7 @@ expand_omp_sections (struct omp_region *region)\n   gcc_assert (gimple_code (gsi_stmt (switch_si)) == GIMPLE_OMP_SECTIONS_SWITCH);\n   if (exit_reachable)\n     {\n-      cont = last_stmt (l1_bb);\n+      cont = as_a <gomp_continue *> (last_stmt (l1_bb));\n       gcc_assert (gimple_code (cont) == GIMPLE_OMP_CONTINUE);\n       vmain = gimple_omp_continue_control_use (cont);\n       vnext = gimple_omp_continue_control_def (cont);\n@@ -8049,7 +8063,7 @@ expand_omp_atomic_pipeline (basic_block load_bb, basic_block store_bb,\n       gsi2 = gsi_start_bb (loop_header);\n       if (gimple_in_ssa_p (cfun))\n \t{\n-\t  gimple stmt;\n+\t  gassign *stmt;\n \t  x = force_gimple_operand_gsi (&gsi2, x, true, NULL_TREE,\n \t\t\t\t\ttrue, GSI_SAME_STMT);\n \t  stmt = gimple_build_assign (loaded_val, x);\n@@ -8162,7 +8176,7 @@ expand_omp_atomic_mutex (basic_block load_bb, basic_block store_bb,\n \t\t\t tree addr, tree loaded_val, tree stored_val)\n {\n   gimple_stmt_iterator si;\n-  gimple stmt;\n+  gassign *stmt;\n   tree t;\n \n   si = gsi_last_bb (load_bb);\n@@ -8204,7 +8218,8 @@ static void\n expand_omp_atomic (struct omp_region *region)\n {\n   basic_block load_bb = region->entry, store_bb = region->exit;\n-  gimple load = last_stmt (load_bb), store = last_stmt (store_bb);\n+  gomp_atomic_load *load = as_a <gomp_atomic_load *> (last_stmt (load_bb));\n+  gomp_atomic_store *store = as_a <gomp_atomic_store *> (last_stmt (store_bb));\n   tree loaded_val = gimple_omp_atomic_load_lhs (load);\n   tree addr = gimple_omp_atomic_load_rhs (load);\n   tree stored_val = gimple_omp_atomic_store_val (store);\n@@ -8268,10 +8283,11 @@ expand_omp_target (struct omp_region *region)\n   struct function *child_cfun = NULL;\n   tree child_fn = NULL_TREE, block, t;\n   gimple_stmt_iterator gsi;\n-  gimple entry_stmt, stmt;\n+  gomp_target *entry_stmt;\n+  gimple stmt;\n   edge e;\n \n-  entry_stmt = last_stmt (region->entry);\n+  entry_stmt = as_a <gomp_target *> (last_stmt (region->entry));\n   new_bb = region->entry;\n   int kind = gimple_omp_target_kind (entry_stmt);\n   if (kind == GF_OMP_TARGET_KIND_REGION)\n@@ -8934,10 +8950,12 @@ lower_omp_sections (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n {\n   tree block, control;\n   gimple_stmt_iterator tgsi;\n-  gimple stmt, new_stmt, bind, t;\n+  gomp_sections *stmt;\n+  gimple t;\n+  gbind *new_stmt, *bind;\n   gimple_seq ilist, dlist, olist, new_body;\n \n-  stmt = gsi_stmt (*gsi_p);\n+  stmt = as_a <gomp_sections *> (gsi_stmt (*gsi_p));\n \n   push_gimplify_context ();\n \n@@ -9032,7 +9050,7 @@ lower_omp_sections (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   to a synchronization analysis pass.  */\n \n static void\n-lower_omp_single_simple (gimple single_stmt, gimple_seq *pre_p)\n+lower_omp_single_simple (gomp_single *single_stmt, gimple_seq *pre_p)\n {\n   location_t loc = gimple_location (single_stmt);\n   tree tlabel = create_artificial_label (loc);\n@@ -9087,7 +9105,8 @@ lower_omp_single_simple (gimple single_stmt, gimple_seq *pre_p)\n   to a synchronization analysis pass.  */\n \n static void\n-lower_omp_single_copy (gimple single_stmt, gimple_seq *pre_p, omp_context *ctx)\n+lower_omp_single_copy (gomp_single *single_stmt, gimple_seq *pre_p,\n+\t\t       omp_context *ctx)\n {\n   tree ptr_type, t, l0, l1, l2, bfn_decl;\n   gimple_seq copyin_seq;\n@@ -9143,7 +9162,9 @@ static void\n lower_omp_single (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n {\n   tree block;\n-  gimple t, bind, single_stmt = gsi_stmt (*gsi_p);\n+  gimple t;\n+  gomp_single *single_stmt = as_a <gomp_single *> (gsi_stmt (*gsi_p));\n+  gbind *bind;\n   gimple_seq bind_body, bind_body_tail = NULL, dlist;\n \n   push_gimplify_context ();\n@@ -9201,7 +9222,8 @@ static void\n lower_omp_master (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n {\n   tree block, lab = NULL, x, bfn_decl;\n-  gimple stmt = gsi_stmt (*gsi_p), bind;\n+  gimple stmt = gsi_stmt (*gsi_p);\n+  gbind *bind;\n   location_t loc = gimple_location (stmt);\n   gimple_seq tseq;\n \n@@ -9241,7 +9263,9 @@ lower_omp_master (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n static void\n lower_omp_taskgroup (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n {\n-  gimple stmt = gsi_stmt (*gsi_p), bind, x;\n+  gimple stmt = gsi_stmt (*gsi_p);\n+  gcall *x;\n+  gbind *bind;\n   tree block = make_node (BLOCK);\n \n   bind = gimple_build_bind (NULL, NULL, block);\n@@ -9269,7 +9293,9 @@ static void\n lower_omp_ordered (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n {\n   tree block;\n-  gimple stmt = gsi_stmt (*gsi_p), bind, x;\n+  gimple stmt = gsi_stmt (*gsi_p);\n+  gcall *x;\n+  gbind *bind;\n \n   push_gimplify_context ();\n \n@@ -9312,7 +9338,8 @@ lower_omp_critical (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n {\n   tree block;\n   tree name, lock, unlock;\n-  gimple stmt = gsi_stmt (*gsi_p), bind;\n+  gomp_critical *stmt = as_a <gomp_critical *> (gsi_stmt (*gsi_p));\n+  gbind *bind;\n   location_t loc = gimple_location (stmt);\n   gimple_seq tbody;\n \n@@ -9465,7 +9492,8 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n {\n   tree *rhs_p, block;\n   struct omp_for_data fd, *fdp = NULL;\n-  gimple stmt = gsi_stmt (*gsi_p), new_stmt;\n+  gomp_for *stmt = as_a <gomp_for *> (gsi_stmt (*gsi_p));\n+  gbind *new_stmt;\n   gimple_seq omp_for_body, body, dlist;\n   size_t i;\n \n@@ -9486,7 +9514,8 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   if (!gimple_seq_empty_p (omp_for_body)\n       && gimple_code (gimple_seq_first_stmt (omp_for_body)) == GIMPLE_BIND)\n     {\n-      gimple inner_bind = gimple_seq_first_stmt (omp_for_body);\n+      gbind *inner_bind\n+\t= as_a <gbind *> (gimple_seq_first_stmt (omp_for_body));\n       tree vars = gimple_bind_vars (inner_bind);\n       gimple_bind_append_vars (new_stmt, vars);\n       /* bind_vars/BLOCK_VARS are being moved to new_stmt/block, don't\n@@ -9685,7 +9714,7 @@ task_copyfn_remap_type (struct omp_taskcopy_context *tcctx, tree orig_type)\n /* Create task copyfn.  */\n \n static void\n-create_task_copyfn (gimple task_stmt, omp_context *ctx)\n+create_task_copyfn (gomp_task *task_stmt, omp_context *ctx)\n {\n   struct function *child_cfun;\n   tree child_fn, t, c, src, dst, f, sf, arg, sarg, decl;\n@@ -9983,12 +10012,13 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   tree clauses;\n   tree child_fn, t;\n   gimple stmt = gsi_stmt (*gsi_p);\n-  gimple par_bind, bind, dep_bind = NULL;\n+  gbind *par_bind, *bind, *dep_bind = NULL;\n   gimple_seq par_body, olist, ilist, par_olist, par_rlist, par_ilist, new_body;\n   location_t loc = gimple_location (stmt);\n \n   clauses = gimple_omp_taskreg_clauses (stmt);\n-  par_bind = gimple_seq_first_stmt (gimple_omp_body (stmt));\n+  par_bind\n+    = as_a <gbind *> (gimple_seq_first_stmt (gimple_omp_body (stmt)));\n   par_body = gimple_bind_body (par_bind);\n   child_fn = ctx->cb.dst_fn;\n   if (gimple_code (stmt) == GIMPLE_OMP_PARALLEL\n@@ -10015,7 +10045,7 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n     }\n \n   if (ctx->srecord_type)\n-    create_task_copyfn (stmt, ctx);\n+    create_task_copyfn (as_a <gomp_task *> (stmt), ctx);\n \n   push_gimplify_context ();\n \n@@ -10104,8 +10134,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n {\n   tree clauses;\n   tree child_fn, t, c;\n-  gimple stmt = gsi_stmt (*gsi_p);\n-  gimple tgt_bind = NULL, bind;\n+  gomp_target *stmt = as_a <gomp_target *> (gsi_stmt (*gsi_p));\n+  gbind *tgt_bind = NULL, *bind;\n   gimple_seq tgt_body = NULL, olist, ilist, new_body;\n   location_t loc = gimple_location (stmt);\n   int kind = gimple_omp_target_kind (stmt);\n@@ -10114,7 +10144,7 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   clauses = gimple_omp_target_clauses (stmt);\n   if (kind == GF_OMP_TARGET_KIND_REGION)\n     {\n-      tgt_bind = gimple_seq_first_stmt (gimple_omp_body (stmt));\n+      tgt_bind = gimple_seq_first_stmt_as_a_bind (gimple_omp_body (stmt));\n       tgt_body = gimple_bind_body (tgt_bind);\n     }\n   else if (kind == GF_OMP_TARGET_KIND_DATA)\n@@ -10414,11 +10444,11 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n static void\n lower_omp_teams (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n {\n-  gimple teams_stmt = gsi_stmt (*gsi_p);\n+  gomp_teams *teams_stmt = as_a <gomp_teams *> (gsi_stmt (*gsi_p));\n   push_gimplify_context ();\n \n   tree block = make_node (BLOCK);\n-  gimple bind = gimple_build_bind (NULL, NULL, block);\n+  gbind *bind = gimple_build_bind (NULL, NULL, block);\n   gsi_replace (gsi_p, bind, true);\n   gimple_seq bind_body = NULL;\n   gimple_seq dlist = NULL;\n@@ -10507,6 +10537,7 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n {\n   gimple stmt = gsi_stmt (*gsi_p);\n   struct walk_stmt_info wi;\n+  gcall *call_stmt;\n \n   if (gimple_has_location (stmt))\n     input_location = gimple_location (stmt);\n@@ -10526,15 +10557,20 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_COND:\n-      if ((ctx || task_shared_vars)\n-\t  && (walk_tree (gimple_cond_lhs_ptr (stmt), lower_omp_regimplify_p,\n-\t      \t\t ctx ? NULL : &wi, NULL)\n-\t      || walk_tree (gimple_cond_rhs_ptr (stmt), lower_omp_regimplify_p,\n-\t\t\t    ctx ? NULL : &wi, NULL)))\n-\tgimple_regimplify_operands (stmt, gsi_p);\n+      {\n+\tgcond *cond_stmt = as_a <gcond *> (stmt);\n+\tif ((ctx || task_shared_vars)\n+\t    && (walk_tree (gimple_cond_lhs_ptr (cond_stmt),\n+\t\t\t   lower_omp_regimplify_p,\n+\t\t\t   ctx ? NULL : &wi, NULL)\n+\t\t|| walk_tree (gimple_cond_rhs_ptr (cond_stmt),\n+\t\t\t      lower_omp_regimplify_p,\n+\t\t\t      ctx ? NULL : &wi, NULL)))\n+\t  gimple_regimplify_operands (cond_stmt, gsi_p);\n+      }\n       break;\n     case GIMPLE_CATCH:\n-      lower_omp (gimple_catch_handler_ptr (stmt), ctx);\n+      lower_omp (gimple_catch_handler_ptr (as_a <gcatch *> (stmt)), ctx);\n       break;\n     case GIMPLE_EH_FILTER:\n       lower_omp (gimple_eh_filter_failure_ptr (stmt), ctx);\n@@ -10544,10 +10580,12 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n       lower_omp (gimple_try_cleanup_ptr (stmt), ctx);\n       break;\n     case GIMPLE_TRANSACTION:\n-      lower_omp (gimple_transaction_body_ptr (stmt), ctx);\n+      lower_omp (gimple_transaction_body_ptr (\n+                   as_a <gtransaction *> (stmt)),\n+\t\t ctx);\n       break;\n     case GIMPLE_BIND:\n-      lower_omp (gimple_bind_body_ptr (stmt), ctx);\n+      lower_omp (gimple_bind_body_ptr (as_a <gbind *> (stmt)), ctx);\n       break;\n     case GIMPLE_OMP_PARALLEL:\n     case GIMPLE_OMP_TASK:\n@@ -10598,7 +10636,8 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n       break;\n     case GIMPLE_OMP_ATOMIC_LOAD:\n       if ((ctx || task_shared_vars)\n-\t  && walk_tree (gimple_omp_atomic_load_rhs_ptr (stmt),\n+\t  && walk_tree (gimple_omp_atomic_load_rhs_ptr (\n+\t\t\t  as_a <gomp_atomic_load *> (stmt)),\n \t\t\tlower_omp_regimplify_p, ctx ? NULL : &wi, NULL))\n \tgimple_regimplify_operands (stmt, gsi_p);\n       break;\n@@ -10614,7 +10653,8 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n       break;\n     case GIMPLE_CALL:\n       tree fndecl;\n-      fndecl = gimple_call_fndecl (stmt);\n+      call_stmt = as_a <gcall *> (stmt);\n+      fndecl = gimple_call_fndecl (call_stmt);\n       if (fndecl\n \t  && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n \tswitch (DECL_FUNCTION_CODE (fndecl))\n@@ -10629,7 +10669,7 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    cctx = ctx;\n \t    if (gimple_code (cctx->stmt) == GIMPLE_OMP_SECTION)\n \t      cctx = cctx->outer;\n-\t    gcc_assert (gimple_call_lhs (stmt) == NULL_TREE);\n+\t    gcc_assert (gimple_call_lhs (call_stmt) == NULL_TREE);\n \t    if (!cctx->cancellable)\n \t      {\n \t\tif (DECL_FUNCTION_CODE (fndecl)\n@@ -10643,12 +10683,12 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_GOMP_BARRIER)\n \t      {\n \t\tfndecl = builtin_decl_explicit (BUILT_IN_GOMP_BARRIER_CANCEL);\n-\t\tgimple_call_set_fndecl (stmt, fndecl);\n-\t\tgimple_call_set_fntype (stmt, TREE_TYPE (fndecl));\n+\t\tgimple_call_set_fndecl (call_stmt, fndecl);\n+\t\tgimple_call_set_fntype (call_stmt, TREE_TYPE (fndecl));\n \t      }\n \t    tree lhs;\n \t    lhs = create_tmp_var (TREE_TYPE (TREE_TYPE (fndecl)), NULL);\n-\t    gimple_call_set_lhs (stmt, lhs);\n+\t    gimple_call_set_lhs (call_stmt, lhs);\n \t    tree fallthru_label;\n \t    fallthru_label = create_artificial_label (UNKNOWN_LOCATION);\n \t    gimple g;\n@@ -10911,7 +10951,9 @@ diagnose_sb_1 (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n       break;\n \n     case GIMPLE_LABEL:\n-      splay_tree_insert (all_labels, (splay_tree_key) gimple_label_label (stmt),\n+      splay_tree_insert (all_labels,\n+\t\t\t (splay_tree_key) gimple_label_label (\n+\t\t\t\t\t    as_a <glabel *> (stmt)),\n \t\t\t (splay_tree_value) context);\n       break;\n \n@@ -10967,15 +11009,16 @@ diagnose_sb_2 (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n \n     case GIMPLE_COND:\n \t{\n-\t  tree lab = gimple_cond_true_label (stmt);\n+\t  gcond *cond_stmt = as_a <gcond *> (stmt);\n+\t  tree lab = gimple_cond_true_label (cond_stmt);\n \t  if (lab)\n \t    {\n \t      n = splay_tree_lookup (all_labels,\n \t\t\t\t     (splay_tree_key) lab);\n \t      diagnose_sb_0 (gsi_p, context,\n \t\t\t     n ? (gimple) n->value : NULL);\n \t    }\n-\t  lab = gimple_cond_false_label (stmt);\n+\t  lab = gimple_cond_false_label (cond_stmt);\n \t  if (lab)\n \t    {\n \t      n = splay_tree_lookup (all_labels,\n@@ -10999,10 +11042,11 @@ diagnose_sb_2 (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n \n     case GIMPLE_SWITCH:\n       {\n+\tgswitch *switch_stmt = as_a <gswitch *> (stmt);\n \tunsigned int i;\n-\tfor (i = 0; i < gimple_switch_num_labels (stmt); ++i)\n+\tfor (i = 0; i < gimple_switch_num_labels (switch_stmt); ++i)\n \t  {\n-\t    tree lab = CASE_LABEL (gimple_switch_label (stmt, i));\n+\t    tree lab = CASE_LABEL (gimple_switch_label (switch_stmt, i));\n \t    n = splay_tree_lookup (all_labels, (splay_tree_key) lab);\n \t    if (n && diagnose_sb_0 (gsi_p, context, (gimple) n->value))\n \t      break;\n@@ -11999,9 +12043,9 @@ ipa_simd_modify_function_body (struct cgraph_node *node,\n \t  wi.info = &info;\n \t  walk_gimple_op (stmt, ipa_simd_modify_stmt_ops, &wi);\n \n-\t  if (gimple_code (stmt) == GIMPLE_RETURN)\n+\t  if (greturn *return_stmt = dyn_cast <greturn *> (stmt))\n \t    {\n-\t      tree retval = gimple_return_retval (stmt);\n+\t      tree retval = gimple_return_retval (return_stmt);\n \t      if (!retval)\n \t\t{\n \t\t  gsi_remove (&gsi, true);\n@@ -12143,7 +12187,7 @@ simd_clone_adjust (struct cgraph_node *node)\n      make_edge (incr_bb, latch_bb, EDGE_TRUE_VALUE);  */\n   FALLTHRU_EDGE (incr_bb)->flags = EDGE_TRUE_VALUE;\n \n-  gimple phi = create_phi_node (iter1, body_bb);\n+  gphi *phi = create_phi_node (iter1, body_bb);\n   edge preheader_edge = find_edge (entry_bb, body_bb);\n   edge latch_edge = single_succ_edge (latch_bb);\n   add_phi_arg (phi, build_zero_cst (unsigned_type_node), preheader_edge,\n@@ -12186,7 +12230,7 @@ simd_clone_adjust (struct cgraph_node *node)\n \t    tree fn = builtin_decl_explicit (BUILT_IN_ASSUME_ALIGNED);\n \t    gimple_seq seq = NULL;\n \t    bool need_cvt = false;\n-\t    gimple call\n+\t    gcall *call\n \t      = gimple_build_call (fn, 2, def, size_int (alignment));\n \t    g = call;\n \t    if (!useless_type_conversion_p (TREE_TYPE (orig_arg),"}, {"sha": "779af115b2ab1553dcf87bd1cb7647b05431a293", "filename": "gcc/predict.c", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -1065,7 +1065,7 @@ get_base_value (tree t)\n    Otherwise return false and set LOOP_INVAIANT to NULL.  */\n \n static bool\n-is_comparison_with_loop_invariant_p (gimple stmt, struct loop *loop,\n+is_comparison_with_loop_invariant_p (gcond *stmt, struct loop *loop,\n \t\t\t\t     tree *loop_invariant,\n \t\t\t\t     enum tree_code *compare_code,\n \t\t\t\t     tree *loop_step,\n@@ -1230,7 +1230,8 @@ predict_iv_comparison (struct loop *loop, basic_block bb,\n   stmt = last_stmt (bb);\n   if (!stmt || gimple_code (stmt) != GIMPLE_COND)\n     return;\n-  if (!is_comparison_with_loop_invariant_p (stmt, loop, &compare_var,\n+  if (!is_comparison_with_loop_invariant_p (as_a <gcond *> (stmt),\n+\t\t\t\t\t    loop, &compare_var,\n \t\t\t\t\t    &compare_code,\n \t\t\t\t\t    &compare_step_var,\n \t\t\t\t\t    &compare_base))\n@@ -1403,12 +1404,19 @@ predict_extra_loop_exits (edge exit_edge)\n {\n   unsigned i;\n   bool check_value_one;\n-  gimple phi_stmt;\n+  gimple lhs_def_stmt;\n+  gphi *phi_stmt;\n   tree cmp_rhs, cmp_lhs;\n-  gimple cmp_stmt = last_stmt (exit_edge->src);\n+  gimple last;\n+  gcond *cmp_stmt;\n \n-  if (!cmp_stmt || gimple_code (cmp_stmt) != GIMPLE_COND)\n+  last = last_stmt (exit_edge->src);\n+  if (!last)\n+    return;\n+  cmp_stmt = dyn_cast <gcond *> (last);\n+  if (!cmp_stmt)\n     return;\n+\n   cmp_rhs = gimple_cond_rhs (cmp_stmt);\n   cmp_lhs = gimple_cond_lhs (cmp_stmt);\n   if (!TREE_CONSTANT (cmp_rhs)\n@@ -1424,8 +1432,12 @@ predict_extra_loop_exits (edge exit_edge)\n \t\t    ^ (gimple_cond_code (cmp_stmt) == EQ_EXPR))\n \t\t    ^ ((exit_edge->flags & EDGE_TRUE_VALUE) != 0));\n \n-  phi_stmt = SSA_NAME_DEF_STMT (cmp_lhs);\n-  if (!phi_stmt || gimple_code (phi_stmt) != GIMPLE_PHI)\n+  lhs_def_stmt = SSA_NAME_DEF_STMT (cmp_lhs);\n+  if (!lhs_def_stmt)\n+    return;\n+\n+  phi_stmt = dyn_cast <gphi *> (lhs_def_stmt);\n+  if (!phi_stmt)\n     return;\n \n   for (i = 0; i < gimple_phi_num_args (phi_stmt); i++)\n@@ -1471,7 +1483,7 @@ predict_loops (void)\n       tree loop_bound_step = NULL;\n       tree loop_bound_var = NULL;\n       tree loop_iv_base = NULL;\n-      gimple stmt = NULL;\n+      gcond *stmt = NULL;\n \n       exits = get_loop_exit_edges (loop);\n       n_exits = exits.length ();\n@@ -1538,12 +1550,12 @@ predict_loops (void)\n \tif (nb_iter->stmt\n \t    && gimple_code (nb_iter->stmt) == GIMPLE_COND)\n \t  {\n-\t    stmt = nb_iter->stmt;\n+\t    stmt = as_a <gcond *> (nb_iter->stmt);\n \t    break;\n \t  }\n       if (!stmt && last_stmt (loop->header)\n \t  && gimple_code (last_stmt (loop->header)) == GIMPLE_COND)\n-\tstmt = last_stmt (loop->header);\n+\tstmt = as_a <gcond *> (last_stmt (loop->header));\n       if (stmt)\n \tis_comparison_with_loop_invariant_p (stmt, loop,\n \t\t\t\t\t     &loop_bound_var,\n@@ -2101,21 +2113,24 @@ return_prediction (tree val, enum prediction *prediction)\n static void\n apply_return_prediction (void)\n {\n-  gimple return_stmt = NULL;\n+  greturn *return_stmt = NULL;\n   tree return_val;\n   edge e;\n-  gimple phi;\n+  gphi *phi;\n   int phi_num_args, i;\n   enum br_predictor pred;\n   enum prediction direction;\n   edge_iterator ei;\n \n   FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n     {\n-      return_stmt = last_stmt (e->src);\n-      if (return_stmt\n-\t  && gimple_code (return_stmt) == GIMPLE_RETURN)\n-\tbreak;\n+      gimple last = last_stmt (e->src);\n+      if (last\n+\t  && gimple_code (last) == GIMPLE_RETURN)\n+\t{\n+\t  return_stmt = as_a <greturn *> (last);\n+\t  break;\n+\t}\n     }\n   if (!e)\n     return;\n@@ -2126,7 +2141,7 @@ apply_return_prediction (void)\n       || !SSA_NAME_DEF_STMT (return_val)\n       || gimple_code (SSA_NAME_DEF_STMT (return_val)) != GIMPLE_PHI)\n     return;\n-  phi = SSA_NAME_DEF_STMT (return_val);\n+  phi = as_a <gphi *> (SSA_NAME_DEF_STMT (return_val));\n   phi_num_args = gimple_phi_num_args (phi);\n   pred = return_prediction (PHI_ARG_DEF (phi, 0), &direction);\n \n@@ -2231,12 +2246,12 @@ tree_estimate_probability_bb (basic_block bb)\n \t  gimple_stmt_iterator gi;\n \t  for (gi = gsi_start_bb (e->dest); !gsi_end_p (gi); gsi_next (&gi))\n \t    {\n-\t      gimple stmt = gsi_stmt (gi);\n+\t      glabel *label_stmt = dyn_cast <glabel *> (gsi_stmt (gi));\n \t      tree decl;\n \n-\t      if (gimple_code (stmt) != GIMPLE_LABEL)\n+\t      if (!label_stmt)\n \t\tbreak;\n-\t      decl = gimple_label_label (stmt);\n+\t      decl = gimple_label_label (label_stmt);\n \t      if (DECL_ARTIFICIAL (decl))\n \t\tcontinue;\n "}, {"sha": "e1d11e0d5e60f31e104f88700d7d458b77bfc2f3", "filename": "gcc/sanopt.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fsanopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fsanopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanopt.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -418,10 +418,11 @@ sanopt_optimize_walker (basic_block bb, struct sanopt_ctx *ctx)\n \t{\n \t  /* Handle asm volatile or asm with \"memory\" clobber\n \t     the same as potentionally freeing call.  */\n-\t  if (gimple_code (stmt) == GIMPLE_ASM\n+\t  gasm *asm_stmt = dyn_cast <gasm *> (stmt);\n+\t  if (asm_stmt\n \t      && asan_check_optimize\n-\t      && (gimple_asm_clobbers_memory_p (stmt)\n-\t\t  || gimple_asm_volatile_p (stmt)))\n+\t      && (gimple_asm_clobbers_memory_p (asm_stmt)\n+\t\t  || gimple_asm_volatile_p (asm_stmt)))\n \t    info->freeing_call_events++;\n \t  gsi_next (&gsi);\n \t  continue;"}, {"sha": "e0869e08f5b1f88a1459e13dc0e8d260ea837225", "filename": "gcc/sese.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -186,18 +186,19 @@ sese_build_liveouts_use (sese region, bitmap liveouts, basic_block bb,\n static void\n sese_build_liveouts_bb (sese region, bitmap liveouts, basic_block bb)\n {\n-  gimple_stmt_iterator bsi;\n   edge e;\n   edge_iterator ei;\n   ssa_op_iter iter;\n   use_operand_p use_p;\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n-    for (bsi = gsi_start_phis (e->dest); !gsi_end_p (bsi); gsi_next (&bsi))\n+    for (gphi_iterator bsi = gsi_start_phis (e->dest); !gsi_end_p (bsi);\n+\t gsi_next (&bsi))\n       sese_build_liveouts_use (region, liveouts, bb,\n-\t\t\t       PHI_ARG_DEF_FROM_EDGE (gsi_stmt (bsi), e));\n+\t\t\t       PHI_ARG_DEF_FROM_EDGE (bsi.phi (), e));\n \n-  for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+  for (gimple_stmt_iterator bsi = gsi_start_bb (bb); !gsi_end_p (bsi);\n+       gsi_next (&bsi))\n     {\n       gimple stmt = gsi_stmt (bsi);\n \n@@ -318,7 +319,7 @@ free_sese (sese region)\n static void\n sese_add_exit_phis_edge (basic_block exit, tree use, edge false_e, edge true_e)\n {\n-  gimple phi = create_phi_node (NULL_TREE, exit);\n+  gphi *phi = create_phi_node (NULL_TREE, exit);\n   create_new_def_for (use, phi, gimple_phi_result_ptr (phi));\n   add_phi_arg (phi, use, false_e, UNKNOWN_LOCATION);\n   add_phi_arg (phi, use, true_e, UNKNOWN_LOCATION);\n@@ -737,7 +738,7 @@ set_ifsese_condition (ifsese if_region, tree condition)\n   basic_block bb = entry->dest;\n   gimple last = last_stmt (bb);\n   gimple_stmt_iterator gsi = gsi_last_bb (bb);\n-  gimple cond_stmt;\n+  gcond *cond_stmt;\n \n   gcc_assert (gimple_code (last) == GIMPLE_COND);\n "}, {"sha": "f178e77c9f6985d89b99d8a1165005f873748b64", "filename": "gcc/ssa-iterators.h", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fssa-iterators.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fssa-iterators.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-iterators.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -194,7 +194,9 @@ struct ssa_op_iter\n    a real stmt or a PHI node, looking at the USE nodes matching FLAGS.  */\n #define FOR_EACH_PHI_OR_STMT_USE(USEVAR, STMT, ITER, FLAGS)\t\\\n   for ((USEVAR) = (gimple_code (STMT) == GIMPLE_PHI \t\t\\\n-\t\t   ? op_iter_init_phiuse (&(ITER), STMT, FLAGS)\t\\\n+\t\t   ? op_iter_init_phiuse (&(ITER),              \\\n+\t\t\t\t\t  as_a <gphi *> (STMT), \\\n+\t\t\t\t\t  FLAGS)\t\t\\\n \t\t   : op_iter_init_use (&(ITER), STMT, FLAGS));\t\\\n        !op_iter_done (&(ITER));\t\t\t\t\t\\\n        (USEVAR) = op_iter_next_use (&(ITER)))\n@@ -203,7 +205,9 @@ struct ssa_op_iter\n    a real stmt or a PHI node, looking at the DEF nodes matching FLAGS.  */\n #define FOR_EACH_PHI_OR_STMT_DEF(DEFVAR, STMT, ITER, FLAGS)\t\\\n   for ((DEFVAR) = (gimple_code (STMT) == GIMPLE_PHI \t\t\\\n-\t\t   ? op_iter_init_phidef (&(ITER), STMT, FLAGS)\t\\\n+\t\t   ? op_iter_init_phidef (&(ITER),\t\t\\\n+\t\t\t\t\t  as_a <gphi *> (STMT), \\\n+\t\t\t\t\t  FLAGS)\t\t\\\n \t\t   : op_iter_init_def (&(ITER), STMT, FLAGS));\t\\\n        !op_iter_done (&(ITER));\t\t\t\t\t\\\n        (DEFVAR) = op_iter_next_def (&(ITER)))\n@@ -610,7 +614,7 @@ op_iter_init (ssa_op_iter *ptr, gimple stmt, int flags)\n \t    ptr->numops = 1;\n \t    break;\n \t  case GIMPLE_ASM:\n-\t    ptr->numops = gimple_asm_noutputs (stmt);\n+\t    ptr->numops = gimple_asm_noutputs (as_a <gasm *> (stmt));\n \t    break;\n \t  default:\n \t    ptr->numops = 0;\n@@ -749,7 +753,7 @@ num_ssa_operands (gimple stmt, int flags)\n /* If there is a single DEF in the PHI node which matches FLAG, return it.\n    Otherwise return NULL_DEF_OPERAND_P.  */\n static inline tree\n-single_phi_def (gimple stmt, int flags)\n+single_phi_def (gphi *stmt, int flags)\n {\n   tree def = PHI_RESULT (stmt);\n   if ((flags & SSA_OP_DEF) && is_gimple_reg (def))\n@@ -762,7 +766,7 @@ single_phi_def (gimple stmt, int flags)\n /* Initialize the iterator PTR for uses matching FLAGS in PHI.  FLAGS should\n    be either SSA_OP_USES or SSA_OP_VIRTUAL_USES.  */\n static inline use_operand_p\n-op_iter_init_phiuse (ssa_op_iter *ptr, gimple phi, int flags)\n+op_iter_init_phiuse (ssa_op_iter *ptr, gphi *phi, int flags)\n {\n   tree phi_def = gimple_phi_result (phi);\n   int comp;\n@@ -792,7 +796,7 @@ op_iter_init_phiuse (ssa_op_iter *ptr, gimple phi, int flags)\n /* Start an iterator for a PHI definition.  */\n \n static inline def_operand_p\n-op_iter_init_phidef (ssa_op_iter *ptr, gimple phi, int flags)\n+op_iter_init_phidef (ssa_op_iter *ptr, gphi *phi, int flags)\n {\n   tree phi_def = PHI_RESULT (phi);\n   int comp;\n@@ -881,9 +885,9 @@ link_use_stmts_after (use_operand_p head, imm_use_iterator *imm)\n   /* Only look at virtual or real uses, depending on the type of HEAD.  */\n   flag = (is_gimple_reg (use) ? SSA_OP_USE : SSA_OP_VIRTUAL_USES);\n \n-  if (gimple_code (head_stmt) == GIMPLE_PHI)\n+  if (gphi *phi = dyn_cast <gphi *> (head_stmt))\n     {\n-      FOR_EACH_PHI_ARG (use_p, head_stmt, op_iter, flag)\n+      FOR_EACH_PHI_ARG (use_p, phi, op_iter, flag)\n \tif (USE_FROM_PTR (use_p) == use)\n \t  last_p = move_use_after_head (use_p, head, last_p);\n     }"}, {"sha": "8ab7ba5ee904645dc1f17f1ea4ace76bf6b3e5b3", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -1111,7 +1111,7 @@ reset_out_edges_aux (basic_block bb)\n    STMT. Record this information in the aux field of the edge.  */\n \n static inline void\n-compute_cases_per_edge (gimple stmt)\n+compute_cases_per_edge (gswitch *stmt)\n {\n   basic_block bb = gimple_bb (stmt);\n   reset_out_edges_aux (bb);\n@@ -1133,7 +1133,7 @@ compute_cases_per_edge (gimple stmt)\n    Generate the code to test it and jump to the right place.  */\n \n void\n-expand_case (gimple stmt)\n+expand_case (gswitch *stmt)\n {\n   tree minval = NULL_TREE, maxval = NULL_TREE, range = NULL_TREE;\n   rtx default_label = NULL_RTX;"}, {"sha": "d3a6f10fbcc42b8fecf45c60e8429aff7a97f49b", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 83, "deletions": 49, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -767,9 +767,10 @@ diagnose_tm_1 (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \n     case GIMPLE_TRANSACTION:\n       {\n+\tgtransaction *trans_stmt = as_a <gtransaction *> (stmt);\n \tunsigned char inner_flags = DIAG_TM_SAFE;\n \n-\tif (gimple_transaction_subcode (stmt) & GTMA_IS_RELAXED)\n+\tif (gimple_transaction_subcode (trans_stmt) & GTMA_IS_RELAXED)\n \t  {\n \t    if (d->block_flags & DIAG_TM_SAFE)\n \t      error_at (gimple_location (stmt),\n@@ -779,7 +780,7 @@ diagnose_tm_1 (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t\t\t\"relaxed transaction in %<transaction_safe%> function\");\n \t    inner_flags = DIAG_TM_RELAXED;\n \t  }\n-\telse if (gimple_transaction_subcode (stmt) & GTMA_IS_OUTER)\n+\telse if (gimple_transaction_subcode (trans_stmt) & GTMA_IS_OUTER)\n \t  {\n \t    if (d->block_flags)\n \t      error_at (gimple_location (stmt),\n@@ -795,7 +796,7 @@ diagnose_tm_1 (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t  }\n \n \t*handled_ops_p = true;\n-\tif (gimple_transaction_body (stmt))\n+\tif (gimple_transaction_body (trans_stmt))\n \t  {\n \t    struct walk_stmt_info wi_inner;\n \t    struct diagnose_tm d_inner;\n@@ -808,7 +809,7 @@ diagnose_tm_1 (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t    memset (&wi_inner, 0, sizeof (wi_inner));\n \t    wi_inner.info = &d_inner;\n \n-\t    walk_gimple_seq (gimple_transaction_body (stmt),\n+\t    walk_gimple_seq (gimple_transaction_body (trans_stmt),\n \t\t\t     diagnose_tm_1, diagnose_tm_1_op, &wi_inner);\n \t  }\n       }\n@@ -930,7 +931,7 @@ typedef struct tm_log_entry\n   /* Entry block for the transaction this address occurs in.  */\n   basic_block entry_block;\n   /* Dominating statements the store occurs in.  */\n-  gimple_vec stmts;\n+  vec<gimple> stmts;\n   /* Initially, while we are building the log, we place a nonzero\n      value here to mean that this address *will* be saved with a\n      save/restore sequence.  Later, when generating the save sequence\n@@ -1610,7 +1611,8 @@ examine_call_tm (unsigned *state, gimple_stmt_iterator *gsi)\n static void\n lower_transaction (gimple_stmt_iterator *gsi, struct walk_stmt_info *wi)\n {\n-  gimple g, stmt = gsi_stmt (*gsi);\n+  gimple g;\n+  gtransaction *stmt = as_a <gtransaction *> (gsi_stmt (*gsi));\n   unsigned int *outer_state = (unsigned int *) wi->info;\n   unsigned int this_state = 0;\n   struct walk_stmt_info this_wi;\n@@ -1806,6 +1808,22 @@ make_pass_lower_tm (gcc::context *ctxt)\n \n struct tm_region\n {\n+public:\n+\n+  /* The field \"transaction_stmt\" is initially a gtransaction *,\n+     but eventually gets lowered to a gcall *(to BUILT_IN_TM_START).\n+\n+     Helper method to get it as a gtransaction *, with code-checking\n+     in a checked-build.  */\n+\n+  gtransaction *\n+  get_transaction_stmt () const\n+  {\n+    return as_a <gtransaction *> (transaction_stmt);\n+  }\n+\n+public:\n+\n   /* Link to the next unnested transaction.  */\n   struct tm_region *next;\n \n@@ -1817,7 +1835,8 @@ struct tm_region\n \n   /* The GIMPLE_TRANSACTION statement beginning this transaction.\n      After TM_MARK, this gets replaced by a call to\n-     BUILT_IN_TM_START.  */\n+     BUILT_IN_TM_START.\n+     Hence this will be either a gtransaction *or a gcall *.  */\n   gimple transaction_stmt;\n \n   /* After TM_MARK expands the GIMPLE_TRANSACTION into a call to\n@@ -1860,7 +1879,8 @@ static bitmap_obstack tm_obstack;\n    GIMPLE_TRANSACTION statement in a tree of tm_region elements.  */\n \n static struct tm_region *\n-tm_region_init_0 (struct tm_region *outer, basic_block bb, gimple stmt)\n+tm_region_init_0 (struct tm_region *outer, basic_block bb,\n+\t\t  gtransaction *stmt)\n {\n   struct tm_region *region;\n \n@@ -1975,8 +1995,9 @@ tm_region_init (struct tm_region *region)\n       /* Check for the last statement in the block beginning a new region.  */\n       g = last_stmt (bb);\n       old_region = region;\n-      if (g && gimple_code (g) == GIMPLE_TRANSACTION)\n-\tregion = tm_region_init_0 (region, bb, g);\n+      if (g)\n+\tif (gtransaction *trans_stmt = dyn_cast <gtransaction *> (g))\n+\t  region = tm_region_init_0 (region, bb, trans_stmt);\n \n       /* Process subsequent blocks.  */\n       FOR_EACH_EDGE (e, ei, bb->succs)\n@@ -2085,8 +2106,9 @@ transaction_subcode_ior (struct tm_region *region, unsigned flags)\n {\n   if (region && region->transaction_stmt)\n     {\n-      flags |= gimple_transaction_subcode (region->transaction_stmt);\n-      gimple_transaction_set_subcode (region->transaction_stmt, flags);\n+      gtransaction *transaction_stmt = region->get_transaction_stmt ();\n+      flags |= gimple_transaction_subcode (transaction_stmt);\n+      gimple_transaction_set_subcode (transaction_stmt, flags);\n     }\n }\n \n@@ -2096,12 +2118,12 @@ transaction_subcode_ior (struct tm_region *region, unsigned flags)\n \n    LOC is the location to use for the new statement(s).  */\n \n-static gimple\n+static gcall *\n build_tm_load (location_t loc, tree lhs, tree rhs, gimple_stmt_iterator *gsi)\n {\n   enum built_in_function code = END_BUILTINS;\n   tree t, type = TREE_TYPE (rhs), decl;\n-  gimple gcall;\n+  gcall *gcall;\n \n   if (type == float_type_node)\n     code = BUILT_IN_TM_LOAD_FLOAT;\n@@ -2168,12 +2190,12 @@ build_tm_load (location_t loc, tree lhs, tree rhs, gimple_stmt_iterator *gsi)\n \n /* Similarly for storing TYPE in a transactional context.  */\n \n-static gimple\n+static gcall *\n build_tm_store (location_t loc, tree lhs, tree rhs, gimple_stmt_iterator *gsi)\n {\n   enum built_in_function code = END_BUILTINS;\n   tree t, fn, type = TREE_TYPE (rhs), simple_type;\n-  gimple gcall;\n+  gcall *gcall;\n \n   if (type == float_type_node)\n     code = BUILT_IN_TM_STORE_FLOAT;\n@@ -2340,7 +2362,7 @@ static bool\n expand_call_tm (struct tm_region *region,\n \t\tgimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gcall *stmt = as_a <gcall *> (gsi_stmt (*gsi));\n   tree lhs = gimple_call_lhs (stmt);\n   tree fn_decl;\n   struct cgraph_node *node;\n@@ -2427,6 +2449,7 @@ expand_call_tm (struct tm_region *region,\n       tree tmp = create_tmp_reg (TREE_TYPE (lhs), NULL);\n       location_t loc = gimple_location (stmt);\n       edge fallthru_edge = NULL;\n+      gassign *assign_stmt;\n \n       /* Remember if the call was going to throw.  */\n       if (stmt_can_throw_internal (stmt))\n@@ -2445,23 +2468,23 @@ expand_call_tm (struct tm_region *region,\n \n       gimple_call_set_lhs (stmt, tmp);\n       update_stmt (stmt);\n-      stmt = gimple_build_assign (lhs, tmp);\n-      gimple_set_location (stmt, loc);\n+      assign_stmt = gimple_build_assign (lhs, tmp);\n+      gimple_set_location (assign_stmt, loc);\n \n       /* We cannot throw in the middle of a BB.  If the call was going\n \t to throw, place the instrumentation on the fallthru edge, so\n \t the call remains the last statement in the block.  */\n       if (fallthru_edge)\n \t{\n-\t  gimple_seq fallthru_seq = gimple_seq_alloc_with_stmt (stmt);\n+\t  gimple_seq fallthru_seq = gimple_seq_alloc_with_stmt (assign_stmt);\n \t  gimple_stmt_iterator fallthru_gsi = gsi_start (fallthru_seq);\n \t  expand_assign_tm (region, &fallthru_gsi);\n \t  gsi_insert_seq_on_edge (fallthru_edge, fallthru_seq);\n \t  pending_edge_inserts_p = true;\n \t}\n       else\n \t{\n-\t  gsi_insert_after (gsi, stmt, GSI_CONTINUE_LINKING);\n+\t  gsi_insert_after (gsi, assign_stmt, GSI_CONTINUE_LINKING);\n \t  expand_assign_tm (region, gsi);\n \t}\n \n@@ -2710,7 +2733,7 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n \n   /* ??? There are plenty of bits here we're not computing.  */\n   {\n-    int subcode = gimple_transaction_subcode (region->transaction_stmt);\n+    int subcode = gimple_transaction_subcode (region->get_transaction_stmt ());\n     int flags = 0;\n     if (subcode & GTMA_DOES_GO_IRREVOCABLE)\n       flags |= PR_DOESGOIRREVOCABLE;\n@@ -2729,7 +2752,7 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n     if (subcode & GTMA_IS_OUTER)\n       region->original_transaction_was_outer = true;\n     tree t = build_int_cst (tm_state_type, flags);\n-    gimple call = gimple_build_call (tm_start, 1, t);\n+    gcall *call = gimple_build_call (tm_start, 1, t);\n     gimple_call_set_lhs (call, tm_state);\n     gimple_set_location (call, gimple_location (region->transaction_stmt));\n \n@@ -2915,16 +2938,16 @@ generate_tm_state (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n   // again as we process blocks.\n   if (region->exit_blocks)\n     {\n-      unsigned int subcode\n-\t= gimple_transaction_subcode (region->transaction_stmt);\n+      gtransaction *transaction_stmt = region->get_transaction_stmt ();\n+      unsigned int subcode = gimple_transaction_subcode (transaction_stmt);\n \n       if (subcode & GTMA_DOES_GO_IRREVOCABLE)\n \tsubcode &= (GTMA_DECLARATION_MASK | GTMA_DOES_GO_IRREVOCABLE\n \t\t    | GTMA_MAY_ENTER_IRREVOCABLE\n \t\t    | GTMA_HAS_NO_INSTRUMENTATION);\n       else\n \tsubcode &= GTMA_DECLARATION_MASK;\n-      gimple_transaction_set_subcode (region->transaction_stmt, subcode);\n+      gimple_transaction_set_subcode (transaction_stmt, subcode);\n     }\n \n   return NULL;\n@@ -2940,11 +2963,13 @@ propagate_tm_flags_out (struct tm_region *region)\n \n   if (region->outer && region->outer->transaction_stmt)\n     {\n-      unsigned s = gimple_transaction_subcode (region->transaction_stmt);\n+      unsigned s\n+\t= gimple_transaction_subcode (region->get_transaction_stmt ());\n       s &= (GTMA_HAVE_ABORT | GTMA_HAVE_LOAD | GTMA_HAVE_STORE\n             | GTMA_MAY_ENTER_IRREVOCABLE);\n-      s |= gimple_transaction_subcode (region->outer->transaction_stmt);\n-      gimple_transaction_set_subcode (region->outer->transaction_stmt, s);\n+      s |= gimple_transaction_subcode (region->outer->get_transaction_stmt ());\n+      gimple_transaction_set_subcode (region->outer->get_transaction_stmt (),\n+\t\t\t\t      s);\n     }\n \n   propagate_tm_flags_out (region->next);\n@@ -2979,7 +3004,8 @@ execute_tm_mark (void)\n \t{\n \t  if (r->transaction_stmt)\n \t    {\n-\t      unsigned sub = gimple_transaction_subcode (r->transaction_stmt);\n+\t      unsigned sub\n+\t\t= gimple_transaction_subcode (r->get_transaction_stmt ());\n \n \t      /* If we're sure to go irrevocable, there won't be\n \t\t anything to expand, since the run-time will go\n@@ -3097,23 +3123,26 @@ expand_block_edges (struct tm_region *const region, basic_block bb)\n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi = next_gsi)\n     {\n       gimple stmt = gsi_stmt (gsi);\n+      gcall *call_stmt;\n \n       next_gsi = gsi;\n       gsi_next (&next_gsi);\n \n       // ??? Shouldn't we split for any non-pure, non-irrevocable function?\n-      if (gimple_code (stmt) != GIMPLE_CALL\n-\t  || (gimple_call_flags (stmt) & ECF_TM_BUILTIN) == 0)\n+      call_stmt = dyn_cast <gcall *> (stmt);\n+      if ((!call_stmt)\n+\t  || (gimple_call_flags (call_stmt) & ECF_TM_BUILTIN) == 0)\n \tcontinue;\n \n-      if (DECL_FUNCTION_CODE (gimple_call_fndecl (stmt)) == BUILT_IN_TM_ABORT)\n+      if (DECL_FUNCTION_CODE (gimple_call_fndecl (call_stmt))\n+\t  == BUILT_IN_TM_ABORT)\n \t{\n \t  // If we have a ``_transaction_cancel [[outer]]'', there is only\n \t  // one abnormal edge: to the transaction marked OUTER.\n \t  // All compiler-generated instances of BUILT_IN_TM_ABORT have a\n \t  // constant argument, which we can examine here.  Users invoking\n \t  // TM_ABORT directly get what they deserve.\n-\t  tree arg = gimple_call_arg (stmt, 0);\n+\t  tree arg = gimple_call_arg (call_stmt, 0);\n \t  if (TREE_CODE (arg) == INTEGER_CST\n \t      && (TREE_INT_CST_LOW (arg) & AR_OUTERABORT) != 0\n \t      && !decl_is_tm_clone (current_function_decl))\n@@ -3122,7 +3151,7 @@ expand_block_edges (struct tm_region *const region, basic_block bb)\n \t      for (struct tm_region *o = region; o; o = o->outer)\n \t\tif (o->original_transaction_was_outer)\n \t\t  {\n-\t\t    split_bb_make_tm_edge (stmt, o->restart_block,\n+\t\t    split_bb_make_tm_edge (call_stmt, o->restart_block,\n \t\t\t\t\t   gsi, &next_gsi);\n \t\t    break;\n \t\t  }\n@@ -3135,7 +3164,8 @@ expand_block_edges (struct tm_region *const region, basic_block bb)\n \n \t  // Non-outer, TM aborts have an abnormal edge to the inner-most\n \t  // transaction, the one being aborted;\n-\t  split_bb_make_tm_edge (stmt, region->restart_block, gsi, &next_gsi);\n+\t  split_bb_make_tm_edge (call_stmt, region->restart_block, gsi,\n+\t\t\t\t &next_gsi);\n \t}\n \n       // All TM builtins have an abnormal edge to the outer-most transaction.\n@@ -3153,14 +3183,14 @@ expand_block_edges (struct tm_region *const region, basic_block bb)\n       for (struct tm_region *o = region; o; o = o->outer)\n \tif (!o->outer)\n \t  {\n-            split_bb_make_tm_edge (stmt, o->restart_block, gsi, &next_gsi);\n+            split_bb_make_tm_edge (call_stmt, o->restart_block, gsi, &next_gsi);\n \t    break;\n \t  }\n \n       // Delete any tail-call annotation that may have been added.\n       // The tail-call pass may have mis-identified the commit as being\n       // a candidate because we had not yet added this restart edge.\n-      gimple_call_set_tail (stmt, false);\n+      gimple_call_set_tail (call_stmt, false);\n     }\n }\n \n@@ -3764,7 +3794,7 @@ dump_tm_memopt_transform (gimple stmt)\n \n static void\n tm_memopt_transform_stmt (unsigned int offset,\n-\t\t\t  gimple stmt,\n+\t\t\t  gcall *stmt,\n \t\t\t  gimple_stmt_iterator *gsi)\n {\n   tree fn = gimple_call_fn (stmt);\n@@ -3800,28 +3830,30 @@ tm_memopt_transform_blocks (vec<basic_block> blocks)\n \n \t  if (is_tm_simple_load (stmt))\n \t    {\n+\t      gcall *call_stmt = as_a <gcall *> (stmt);\n \t      loc = tm_memopt_value_number (stmt, NO_INSERT);\n \t      if (store_avail && bitmap_bit_p (store_avail, loc))\n-\t\ttm_memopt_transform_stmt (TRANSFORM_RAW, stmt, &gsi);\n+\t\ttm_memopt_transform_stmt (TRANSFORM_RAW, call_stmt, &gsi);\n \t      else if (store_antic && bitmap_bit_p (store_antic, loc))\n \t\t{\n-\t\t  tm_memopt_transform_stmt (TRANSFORM_RFW, stmt, &gsi);\n+\t\t  tm_memopt_transform_stmt (TRANSFORM_RFW, call_stmt, &gsi);\n \t\t  bitmap_set_bit (store_avail, loc);\n \t\t}\n \t      else if (read_avail && bitmap_bit_p (read_avail, loc))\n-\t\ttm_memopt_transform_stmt (TRANSFORM_RAR, stmt, &gsi);\n+\t\ttm_memopt_transform_stmt (TRANSFORM_RAR, call_stmt, &gsi);\n \t      else\n \t\tbitmap_set_bit (read_avail, loc);\n \t    }\n \t  else if (is_tm_simple_store (stmt))\n \t    {\n+\t      gcall *call_stmt = as_a <gcall *> (stmt);\n \t      loc = tm_memopt_value_number (stmt, NO_INSERT);\n \t      if (store_avail && bitmap_bit_p (store_avail, loc))\n-\t\ttm_memopt_transform_stmt (TRANSFORM_WAW, stmt, &gsi);\n+\t\ttm_memopt_transform_stmt (TRANSFORM_WAW, call_stmt, &gsi);\n \t      else\n \t\t{\n \t\t  if (read_avail && bitmap_bit_p (read_avail, loc))\n-\t\t    tm_memopt_transform_stmt (TRANSFORM_WAR, stmt, &gsi);\n+\t\t    tm_memopt_transform_stmt (TRANSFORM_WAR, call_stmt, &gsi);\n \t\t  bitmap_set_bit (store_avail, loc);\n \t\t}\n \t    }\n@@ -4676,7 +4708,8 @@ ipa_tm_diagnose_transaction (struct cgraph_node *node,\n   struct tm_region *r;\n \n   for (r = all_tm_regions; r ; r = r->next)\n-    if (gimple_transaction_subcode (r->transaction_stmt) & GTMA_IS_RELAXED)\n+    if (gimple_transaction_subcode (r->get_transaction_stmt ())\n+\t& GTMA_IS_RELAXED)\n       {\n \t/* Atomic transactions can be nested inside relaxed.  */\n \tif (r->inner)\n@@ -4950,7 +4983,7 @@ ipa_tm_insert_irr_call (struct cgraph_node *node, struct tm_region *region,\n \t\t\tbasic_block bb)\n {\n   gimple_stmt_iterator gsi;\n-  gimple g;\n+  gcall *g;\n \n   transaction_subcode_ior (region, GTMA_MAY_ENTER_IRREVOCABLE);\n \n@@ -4973,10 +5006,11 @@ ipa_tm_insert_irr_call (struct cgraph_node *node, struct tm_region *region,\n static bool\n ipa_tm_insert_gettmclone_call (struct cgraph_node *node,\n \t\t\t       struct tm_region *region,\n-\t\t\t       gimple_stmt_iterator *gsi, gimple stmt)\n+\t\t\t       gimple_stmt_iterator *gsi, gcall *stmt)\n {\n   tree gettm_fn, ret, old_fn, callfn;\n-  gimple g, g2;\n+  gcall *g;\n+  gassign *g2;\n   bool safe;\n \n   old_fn = gimple_call_fn (stmt);\n@@ -5072,7 +5106,7 @@ ipa_tm_transform_calls_redirect (struct cgraph_node *node,\n \t\t\t\t gimple_stmt_iterator *gsi,\n \t\t\t\t bool *need_ssa_rename_p)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gcall *stmt = as_a <gcall *> (gsi_stmt (*gsi));\n   struct cgraph_node *new_node;\n   struct cgraph_edge *e = node->get_edge (stmt);\n   tree fndecl = gimple_call_fndecl (stmt);"}, {"sha": "188a29553fa56fa7e0d4c5b6e6838f8e418631df", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -184,7 +184,7 @@ check_target_format (tree arg)\n #define MAX_BASE_INT_BIT_SIZE 32\n \n static bool\n-check_pow (gimple pow_call)\n+check_pow (gcall *pow_call)\n {\n   tree base, expn;\n   enum tree_code bc, ec;\n@@ -258,7 +258,7 @@ check_pow (gimple pow_call)\n    Returns true if the function call is a candidate.  */\n \n static bool\n-check_builtin_call (gimple bcall)\n+check_builtin_call (gcall *bcall)\n {\n   tree arg;\n \n@@ -271,7 +271,7 @@ check_builtin_call (gimple bcall)\n    is a candidate.  */\n \n static bool\n-is_call_dce_candidate (gimple call)\n+is_call_dce_candidate (gcall *call)\n {\n   tree fn;\n   enum built_in_function fnc;\n@@ -342,7 +342,9 @@ gen_one_condition (tree arg, int lbub,\n {\n   tree lbub_real_cst, lbub_cst, float_type;\n   tree temp, tempn, tempc, tempcn;\n-  gimple stmt1, stmt2, stmt3;\n+  gassign *stmt1;\n+  gassign *stmt2;\n+  gcond *stmt3;\n \n   float_type = TREE_TYPE (arg);\n   lbub_cst = build_int_cst (integer_type_node, lbub);\n@@ -547,7 +549,7 @@ gen_conditions_for_pow_int_base (tree base, tree expn,\n    and *NCONDS is the number of logical conditions.  */\n \n static void\n-gen_conditions_for_pow (gimple pow_call, vec<gimple> conds,\n+gen_conditions_for_pow (gcall *pow_call, vec<gimple> conds,\n                         unsigned *nconds)\n {\n   tree base, expn;\n@@ -683,10 +685,10 @@ get_no_error_domain (enum built_in_function fnc)\n    condition are separated by NULL tree in the vector.  */\n \n static void\n-gen_shrink_wrap_conditions (gimple bi_call, vec<gimple> conds,\n+gen_shrink_wrap_conditions (gcall *bi_call, vec<gimple> conds,\n                             unsigned int *nconds)\n {\n-  gimple call;\n+  gcall *call;\n   tree fn;\n   enum built_in_function fnc;\n \n@@ -724,7 +726,7 @@ gen_shrink_wrap_conditions (gimple bi_call, vec<gimple> conds,\n    transformation actually happens.  */\n \n static bool\n-shrink_wrap_one_built_in_call (gimple bi_call)\n+shrink_wrap_one_built_in_call (gcall *bi_call)\n {\n   gimple_stmt_iterator bi_call_bsi;\n   basic_block bi_call_bb, join_tgt_bb, guard_bb, guard_bb0;\n@@ -859,7 +861,7 @@ shrink_wrap_one_built_in_call (gimple bi_call)\n    wrapping transformation.  */\n \n static bool\n-shrink_wrap_conditional_dead_built_in_calls (vec<gimple> calls)\n+shrink_wrap_conditional_dead_built_in_calls (vec<gcall *> calls)\n {\n   bool changed = false;\n   unsigned i = 0;\n@@ -870,7 +872,7 @@ shrink_wrap_conditional_dead_built_in_calls (vec<gimple> calls)\n \n   for (; i < n ; i++)\n     {\n-      gimple bi_call = calls[i];\n+      gcall *bi_call = calls[i];\n       changed |= shrink_wrap_one_built_in_call (bi_call);\n     }\n \n@@ -919,15 +921,14 @@ pass_call_cdce::execute (function *fun)\n   basic_block bb;\n   gimple_stmt_iterator i;\n   bool something_changed = false;\n-  auto_vec<gimple> cond_dead_built_in_calls;\n+  auto_vec<gcall *> cond_dead_built_in_calls;\n   FOR_EACH_BB_FN (bb, fun)\n     {\n       /* Collect dead call candidates.  */\n       for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n         {\n-\t  gimple stmt = gsi_stmt (i);\n-          if (is_gimple_call (stmt)\n-              && is_call_dce_candidate (stmt))\n+\t  gcall *stmt = dyn_cast <gcall *> (gsi_stmt (i));\n+          if (stmt && is_call_dce_candidate (stmt))\n             {\n               if (dump_file && (dump_flags & TDF_DETAILS))\n                 {"}, {"sha": "e78554f5721d6648bf387910a225bc25a28cec40", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 225, "deletions": 182, "changes": 407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -164,7 +164,7 @@ static void make_blocks (gimple_seq);\n static void make_edges (void);\n static void assign_discriminators (void);\n static void make_cond_expr_edges (basic_block);\n-static void make_gimple_switch_edges (basic_block);\n+static void make_gimple_switch_edges (gswitch *, basic_block);\n static bool make_goto_expr_edges (basic_block);\n static void make_gimple_asm_edges (basic_block);\n static edge gimple_redirect_edge_and_branch (edge, basic_block);\n@@ -175,7 +175,7 @@ static inline bool stmt_starts_bb_p (gimple, gimple);\n static int gimple_verify_flow_info (void);\n static void gimple_make_forwarder_block (edge);\n static gimple first_non_label_stmt (basic_block);\n-static bool verify_gimple_transaction (gimple);\n+static bool verify_gimple_transaction (gtransaction *);\n static bool call_can_make_abnormal_goto (gimple);\n \n /* Flowgraph optimization and cleanup.  */\n@@ -184,8 +184,8 @@ static bool gimple_can_merge_blocks_p (basic_block, basic_block);\n static void remove_bb (basic_block);\n static edge find_taken_edge_computed_goto (basic_block, tree);\n static edge find_taken_edge_cond_expr (basic_block, tree);\n-static edge find_taken_edge_switch_expr (basic_block, tree);\n-static tree find_case_label_for_value (gimple, tree);\n+static edge find_taken_edge_switch_expr (gswitch *, basic_block, tree);\n+static tree find_case_label_for_value (gswitch *, tree);\n \n void\n init_empty_tree_cfg_for_function (struct function *fn)\n@@ -623,13 +623,16 @@ fold_cond_expr_cond (void)\n \n       if (stmt && gimple_code (stmt) == GIMPLE_COND)\n \t{\n+\t  gcond *cond_stmt = as_a <gcond *> (stmt);\n \t  location_t loc = gimple_location (stmt);\n \t  tree cond;\n \t  bool zerop, onep;\n \n \t  fold_defer_overflow_warnings ();\n-\t  cond = fold_binary_loc (loc, gimple_cond_code (stmt), boolean_type_node,\n-\t\t\t      gimple_cond_lhs (stmt), gimple_cond_rhs (stmt));\n+\t  cond = fold_binary_loc (loc, gimple_cond_code (cond_stmt),\n+\t\t\t\t  boolean_type_node,\n+\t\t\t\t  gimple_cond_lhs (cond_stmt),\n+\t\t\t\t  gimple_cond_rhs (cond_stmt));\n \t  if (cond)\n \t    {\n \t      zerop = integer_zerop (cond);\n@@ -642,9 +645,9 @@ fold_cond_expr_cond (void)\n \t\t\t\t\t  stmt,\n \t\t\t\t\t  WARN_STRICT_OVERFLOW_CONDITIONAL);\n \t  if (zerop)\n-\t    gimple_cond_make_false (stmt);\n+\t    gimple_cond_make_false (cond_stmt);\n \t  else if (onep)\n-\t    gimple_cond_make_true (stmt);\n+\t    gimple_cond_make_true (cond_stmt);\n \t}\n     }\n }\n@@ -836,15 +839,15 @@ make_edges (void)\n \t      fallthru = false;\n \t      break;\n \t    case GIMPLE_SWITCH:\n-\t      make_gimple_switch_edges (bb);\n+\t      make_gimple_switch_edges (as_a <gswitch *> (last), bb);\n \t      fallthru = false;\n \t      break;\n \t    case GIMPLE_RESX:\n \t      make_eh_edges (last);\n \t      fallthru = false;\n \t      break;\n \t    case GIMPLE_EH_DISPATCH:\n-\t      fallthru = make_eh_dispatch_edges (last);\n+\t      fallthru = make_eh_dispatch_edges (as_a <geh_dispatch *> (last));\n \t      break;\n \n \t    case GIMPLE_CALL:\n@@ -891,7 +894,8 @@ make_edges (void)\n \n \t    case GIMPLE_TRANSACTION:\n \t      {\n-\t\ttree abort_label = gimple_transaction_label (last);\n+\t\ttree abort_label\n+\t\t  = gimple_transaction_label (as_a <gtransaction *> (last));\n \t\tif (abort_label)\n \t\t  make_edge (bb, label_to_block (abort_label), EDGE_TM_ABORT);\n \t\tfallthru = true;\n@@ -939,10 +943,10 @@ make_edges (void)\n \t{\n \t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t    {\n-\t      gimple label_stmt = gsi_stmt (gsi);\n+\t      glabel *label_stmt = dyn_cast <glabel *> (gsi_stmt (gsi));\n \t      tree target;\n \n-\t      if (gimple_code (label_stmt) != GIMPLE_LABEL)\n+\t      if (!label_stmt)\n \t\tbreak;\n \n \t      target = gimple_label_label (label_stmt);\n@@ -1074,7 +1078,7 @@ assign_discriminators (void)\n static void\n make_cond_expr_edges (basic_block bb)\n {\n-  gimple entry = last_stmt (bb);\n+  gcond *entry = as_a <gcond *> (last_stmt (bb));\n   gimple then_stmt, else_stmt;\n   basic_block then_bb, else_bb;\n   tree then_label, else_label;\n@@ -1159,7 +1163,7 @@ end_recording_case_labels (void)\n \t{\n \t  gimple stmt = last_stmt (bb);\n \t  if (stmt && gimple_code (stmt) == GIMPLE_SWITCH)\n-\t    group_case_labels_stmt (stmt);\n+\t    group_case_labels_stmt (as_a <gswitch *> (stmt));\n \t}\n     }\n   BITMAP_FREE (touched_switch_bbs);\n@@ -1171,7 +1175,7 @@ end_recording_case_labels (void)\n    Otherwise return NULL.  */\n \n static tree\n-get_cases_for_edge (edge e, gimple t)\n+get_cases_for_edge (edge e, gswitch *t)\n {\n   tree *slot;\n   size_t i, n;\n@@ -1210,9 +1214,8 @@ get_cases_for_edge (edge e, gimple t)\n /* Create the edges for a GIMPLE_SWITCH starting at block BB.  */\n \n static void\n-make_gimple_switch_edges (basic_block bb)\n+make_gimple_switch_edges (gswitch *entry, basic_block bb)\n {\n-  gimple entry = last_stmt (bb);\n   size_t i, n;\n \n   n = gimple_switch_num_labels (entry);\n@@ -1280,7 +1283,7 @@ make_goto_expr_edges (basic_block bb)\n static void\n make_gimple_asm_edges (basic_block bb)\n {\n-  gimple stmt = last_stmt (bb);\n+  gasm *stmt = as_a <gasm *> (last_stmt (bb));\n   int i, n = gimple_asm_nlabels (stmt);\n \n   for (i = 0; i < n; ++i)\n@@ -1404,12 +1407,12 @@ cleanup_dead_labels (void)\n       for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n \t{\n \t  tree label;\n-\t  gimple stmt = gsi_stmt (i);\n+\t  glabel *label_stmt = dyn_cast <glabel *> (gsi_stmt (i));\n \n-\t  if (gimple_code (stmt) != GIMPLE_LABEL)\n+\t  if (!label_stmt)\n \t    break;\n \n-\t  label = gimple_label_label (stmt);\n+\t  label = gimple_label_label (label_stmt);\n \n \t  /* If we have not yet seen a label for the current block,\n \t     remember this one and see if there are more labels.  */\n@@ -1444,31 +1447,35 @@ cleanup_dead_labels (void)\n       switch (gimple_code (stmt))\n \t{\n \tcase GIMPLE_COND:\n-\t  label = gimple_cond_true_label (stmt);\n-\t  if (label)\n-\t    {\n-\t      new_label = main_block_label (label);\n-\t      if (new_label != label)\n-\t\tgimple_cond_set_true_label (stmt, new_label);\n-\t    }\n+\t  {\n+\t    gcond *cond_stmt = as_a <gcond *> (stmt);\n+\t    label = gimple_cond_true_label (cond_stmt);\n+\t    if (label)\n+\t      {\n+\t\tnew_label = main_block_label (label);\n+\t\tif (new_label != label)\n+\t\t  gimple_cond_set_true_label (cond_stmt, new_label);\n+\t      }\n \n-\t  label = gimple_cond_false_label (stmt);\n-\t  if (label)\n-\t    {\n-\t      new_label = main_block_label (label);\n-\t      if (new_label != label)\n-\t\tgimple_cond_set_false_label (stmt, new_label);\n-\t    }\n+\t    label = gimple_cond_false_label (cond_stmt);\n+\t    if (label)\n+\t      {\n+\t\tnew_label = main_block_label (label);\n+\t\tif (new_label != label)\n+\t\t  gimple_cond_set_false_label (cond_stmt, new_label);\n+\t      }\n+\t  }\n \t  break;\n \n \tcase GIMPLE_SWITCH:\n \t  {\n-\t    size_t i, n = gimple_switch_num_labels (stmt);\n+\t    gswitch *switch_stmt = as_a <gswitch *> (stmt);\n+\t    size_t i, n = gimple_switch_num_labels (switch_stmt);\n \n \t    /* Replace all destination labels.  */\n \t    for (i = 0; i < n; ++i)\n \t      {\n-\t\ttree case_label = gimple_switch_label (stmt, i);\n+\t\ttree case_label = gimple_switch_label (switch_stmt, i);\n \t\tlabel = CASE_LABEL (case_label);\n \t\tnew_label = main_block_label (label);\n \t\tif (new_label != label)\n@@ -1479,11 +1486,12 @@ cleanup_dead_labels (void)\n \n \tcase GIMPLE_ASM:\n \t  {\n-\t    int i, n = gimple_asm_nlabels (stmt);\n+\t    gasm *asm_stmt = as_a <gasm *> (stmt);\n+\t    int i, n = gimple_asm_nlabels (asm_stmt);\n \n \t    for (i = 0; i < n; ++i)\n \t      {\n-\t\ttree cons = gimple_asm_label_op (stmt, i);\n+\t\ttree cons = gimple_asm_label_op (asm_stmt, i);\n \t\ttree label = main_block_label (TREE_VALUE (cons));\n \t\tTREE_VALUE (cons) = label;\n \t      }\n@@ -1495,21 +1503,23 @@ cleanup_dead_labels (void)\n \tcase GIMPLE_GOTO:\n \t  if (!computed_goto_p (stmt))\n \t    {\n-\t      label = gimple_goto_dest (stmt);\n+\t      ggoto *goto_stmt = as_a <ggoto *> (stmt);\n+\t      label = gimple_goto_dest (goto_stmt);\n \t      new_label = main_block_label (label);\n \t      if (new_label != label)\n-\t\tgimple_goto_set_dest (stmt, new_label);\n+\t\tgimple_goto_set_dest (goto_stmt, new_label);\n \t    }\n \t  break;\n \n \tcase GIMPLE_TRANSACTION:\n \t  {\n-\t    tree label = gimple_transaction_label (stmt);\n+\t    gtransaction *trans_stmt = as_a <gtransaction *> (stmt);\n+\t    tree label = gimple_transaction_label (trans_stmt);\n \t    if (label)\n \t      {\n \t\ttree new_label = main_block_label (label);\n \t\tif (new_label != label)\n-\t\t  gimple_transaction_set_label (stmt, new_label);\n+\t\t  gimple_transaction_set_label (trans_stmt, new_label);\n \t      }\n \t  }\n \t  break;\n@@ -1540,12 +1550,12 @@ cleanup_dead_labels (void)\n       for (i = gsi_start_bb (bb); !gsi_end_p (i); )\n \t{\n \t  tree label;\n-\t  gimple stmt = gsi_stmt (i);\n+\t  glabel *label_stmt = dyn_cast <glabel *> (gsi_stmt (i));\n \n-\t  if (gimple_code (stmt) != GIMPLE_LABEL)\n+\t  if (!label_stmt)\n \t    break;\n \n-\t  label = gimple_label_label (stmt);\n+\t  label = gimple_label_label (label_stmt);\n \n \t  if (label == label_for_this_bb\n \t      || !DECL_ARTIFICIAL (label)\n@@ -1565,7 +1575,7 @@ cleanup_dead_labels (void)\n    Eg. three separate entries 1: 2: 3: become one entry 1..3:  */\n \n void\n-group_case_labels_stmt (gimple stmt)\n+group_case_labels_stmt (gswitch *stmt)\n {\n   int old_size = gimple_switch_num_labels (stmt);\n   int i, j, new_size = old_size;\n@@ -1653,7 +1663,7 @@ group_case_labels (void)\n     {\n       gimple stmt = last_stmt (bb);\n       if (stmt && gimple_code (stmt) == GIMPLE_SWITCH)\n-\tgroup_case_labels_stmt (stmt);\n+\tgroup_case_labels_stmt (as_a <gswitch *> (stmt));\n     }\n }\n \n@@ -1663,7 +1673,6 @@ static bool\n gimple_can_merge_blocks_p (basic_block a, basic_block b)\n {\n   gimple stmt;\n-  gimple_stmt_iterator gsi;\n \n   if (!single_succ_p (a))\n     return false;\n@@ -1687,19 +1696,20 @@ gimple_can_merge_blocks_p (basic_block a, basic_block b)\n     return false;\n \n   /* Do not allow a block with only a non-local label to be merged.  */\n-  if (stmt\n-      && gimple_code (stmt) == GIMPLE_LABEL\n-      && DECL_NONLOCAL (gimple_label_label (stmt)))\n-    return false;\n+  if (stmt)\n+    if (glabel *label_stmt = dyn_cast <glabel *> (stmt))\n+      if (DECL_NONLOCAL (gimple_label_label (label_stmt)))\n+\treturn false;\n \n   /* Examine the labels at the beginning of B.  */\n-  for (gsi = gsi_start_bb (b); !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gimple_stmt_iterator gsi = gsi_start_bb (b); !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n     {\n       tree lab;\n-      stmt = gsi_stmt (gsi);\n-      if (gimple_code (stmt) != GIMPLE_LABEL)\n+      glabel *label_stmt = dyn_cast <glabel *> (gsi_stmt (gsi));\n+      if (!label_stmt)\n \tbreak;\n-      lab = gimple_label_label (stmt);\n+      lab = gimple_label_label (label_stmt);\n \n       /* Do not remove user forced labels or for -O0 any user labels.  */\n       if (!DECL_ARTIFICIAL (lab) && (!optimize || FORCED_LABEL (lab)))\n@@ -1717,9 +1727,10 @@ gimple_can_merge_blocks_p (basic_block a, basic_block b)\n   /* It must be possible to eliminate all phi nodes in B.  If ssa form\n      is not up-to-date and a name-mapping is registered, we cannot eliminate\n      any phis.  Symbols marked for renaming are never a problem though.  */\n-  for (gsi = gsi_start_phis (b); !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gphi_iterator gsi = gsi_start_phis (b); !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n       /* Technically only new names matter.  */\n       if (name_registered_for_update_p (PHI_RESULT (phi)))\n \treturn false;\n@@ -1768,7 +1779,8 @@ replace_uses_by (tree name, tree val)\n \n \t  if (gimple_code (stmt) == GIMPLE_PHI)\n \t    {\n-\t      e = gimple_phi_arg_edge (stmt, PHI_ARG_INDEX_FROM_USE (use));\n+\t      e = gimple_phi_arg_edge (as_a <gphi *> (stmt),\n+\t\t\t\t       PHI_ARG_INDEX_FROM_USE (use));\n \t      if (e->flags & EDGE_ABNORMAL)\n \t\t{\n \t\t  /* This can only occur for virtual operands, since\n@@ -1830,7 +1842,8 @@ replace_uses_by (tree name, tree val)\n static void\n gimple_merge_blocks (basic_block a, basic_block b)\n {\n-  gimple_stmt_iterator last, gsi, psi;\n+  gimple_stmt_iterator last, gsi;\n+  gphi_iterator psi;\n \n   if (dump_file)\n     fprintf (dump_file, \"Merging blocks %d and %d\\n\", a->index, b->index);\n@@ -1902,9 +1915,9 @@ gimple_merge_blocks (basic_block a, basic_block b)\n   for (gsi = gsi_start_bb (b); !gsi_end_p (gsi);)\n     {\n       gimple stmt = gsi_stmt (gsi);\n-      if (gimple_code (stmt) == GIMPLE_LABEL)\n+      if (glabel *label_stmt = dyn_cast <glabel *> (stmt))\n \t{\n-\t  tree label = gimple_label_label (stmt);\n+\t  tree label = gimple_label_label (label_stmt);\n \t  int lp_nr;\n \n \t  gsi_remove (&gsi, false);\n@@ -1988,7 +2001,7 @@ single_noncomplex_succ (basic_block bb)\n /* T is CALL_EXPR.  Set current_function_calls_* flags.  */\n \n void\n-notice_special_calls (gimple call)\n+notice_special_calls (gcall *call)\n {\n   int flags = gimple_call_flags (call);\n \n@@ -2062,20 +2075,21 @@ remove_bb (basic_block bb)\n       for (i = gsi_last_bb (bb); !gsi_end_p (i);)\n \t{\n \t  gimple stmt = gsi_stmt (i);\n-\t  if (gimple_code (stmt) == GIMPLE_LABEL\n-\t      && (FORCED_LABEL (gimple_label_label (stmt))\n-\t\t  || DECL_NONLOCAL (gimple_label_label (stmt))))\n+\t  glabel *label_stmt = dyn_cast <glabel *> (stmt);\n+\t  if (label_stmt\n+\t      && (FORCED_LABEL (gimple_label_label (label_stmt))\n+\t\t  || DECL_NONLOCAL (gimple_label_label (label_stmt))))\n \t    {\n \t      basic_block new_bb;\n \t      gimple_stmt_iterator new_gsi;\n \n \t      /* A non-reachable non-local label may still be referenced.\n \t\t But it no longer needs to carry the extra semantics of\n \t\t non-locality.  */\n-\t      if (DECL_NONLOCAL (gimple_label_label (stmt)))\n+\t      if (DECL_NONLOCAL (gimple_label_label (label_stmt)))\n \t\t{\n-\t\t  DECL_NONLOCAL (gimple_label_label (stmt)) = 0;\n-\t\t  FORCED_LABEL (gimple_label_label (stmt)) = 1;\n+\t\t  DECL_NONLOCAL (gimple_label_label (label_stmt)) = 0;\n+\t\t  FORCED_LABEL (gimple_label_label (label_stmt)) = 1;\n \t\t}\n \n \t      new_bb = bb->prev_bb;\n@@ -2132,7 +2146,7 @@ find_taken_edge (basic_block bb, tree val)\n     return find_taken_edge_cond_expr (bb, val);\n \n   if (gimple_code (stmt) == GIMPLE_SWITCH)\n-    return find_taken_edge_switch_expr (bb, val);\n+    return find_taken_edge_switch_expr (as_a <gswitch *> (stmt), bb, val);\n \n   if (computed_goto_p (stmt))\n     {\n@@ -2191,14 +2205,13 @@ find_taken_edge_cond_expr (basic_block bb, tree val)\n    NULL if any edge may be taken.  */\n \n static edge\n-find_taken_edge_switch_expr (basic_block bb, tree val)\n+find_taken_edge_switch_expr (gswitch *switch_stmt, basic_block bb,\n+\t\t\t     tree val)\n {\n   basic_block dest_bb;\n   edge e;\n-  gimple switch_stmt;\n   tree taken_case;\n \n-  switch_stmt = last_stmt (bb);\n   taken_case = find_case_label_for_value (switch_stmt, val);\n   dest_bb = label_to_block (CASE_LABEL (taken_case));\n \n@@ -2213,7 +2226,7 @@ find_taken_edge_switch_expr (basic_block bb, tree val)\n    sorted: We can do a binary search for a case matching VAL.  */\n \n static tree\n-find_case_label_for_value (gimple switch_stmt, tree val)\n+find_case_label_for_value (gswitch *switch_stmt, tree val)\n {\n   size_t low, high, n = gimple_switch_num_labels (switch_stmt);\n   tree default_case = gimple_switch_default_label (switch_stmt);\n@@ -2451,7 +2464,7 @@ is_ctrl_altering_stmt (gimple t)\n       return true;\n \n     case GIMPLE_ASM:\n-      if (gimple_asm_nlabels (t) > 0)\n+      if (gimple_asm_nlabels (as_a <gasm *> (t)) > 0)\n \treturn true;\n       break;\n \n@@ -2498,16 +2511,17 @@ stmt_starts_bb_p (gimple stmt, gimple prev_stmt)\n   /* Labels start a new basic block only if the preceding statement\n      wasn't a label of the same type.  This prevents the creation of\n      consecutive blocks that have nothing but a single label.  */\n-  if (gimple_code (stmt) == GIMPLE_LABEL)\n+  if (glabel *label_stmt = dyn_cast <glabel *> (stmt))\n     {\n       /* Nonlocal and computed GOTO targets always start a new block.  */\n-      if (DECL_NONLOCAL (gimple_label_label (stmt))\n-\t  || FORCED_LABEL (gimple_label_label (stmt)))\n+      if (DECL_NONLOCAL (gimple_label_label (label_stmt))\n+\t  || FORCED_LABEL (gimple_label_label (label_stmt)))\n \treturn true;\n \n       if (prev_stmt && gimple_code (prev_stmt) == GIMPLE_LABEL)\n \t{\n-\t  if (DECL_NONLOCAL (gimple_label_label (prev_stmt)))\n+\t  if (DECL_NONLOCAL (gimple_label_label (\n+\t\t\t       as_a <glabel *> (prev_stmt))))\n \t    return true;\n \n \t  cfg_stats.num_merged_labels++;\n@@ -2625,7 +2639,7 @@ reinstall_phi_args (edge new_edge, edge old_edge)\n {\n   edge_var_map *vm;\n   int i;\n-  gimple_stmt_iterator phis;\n+  gphi_iterator phis;\n \n   vec<edge_var_map> *v = redirect_edge_var_map_vector (old_edge);\n   if (!v)\n@@ -2635,7 +2649,7 @@ reinstall_phi_args (edge new_edge, edge old_edge)\n        v->iterate (i, &vm) && !gsi_end_p (phis);\n        i++, gsi_next (&phis))\n     {\n-      gimple phi = gsi_stmt (phis);\n+      gphi *phi = phis.phi ();\n       tree result = redirect_edge_var_map_result (vm);\n       tree arg = redirect_edge_var_map_def (vm);\n \n@@ -3241,7 +3255,7 @@ valid_fixed_convert_types_p (tree type1, tree type2)\n    is a problem, otherwise false.  */\n \n static bool\n-verify_gimple_call (gimple stmt)\n+verify_gimple_call (gcall *stmt)\n {\n   tree fn = gimple_call_fn (stmt);\n   tree fntype, fndecl;\n@@ -3452,7 +3466,7 @@ verify_gimple_comparison (tree type, tree op0, tree op1)\n    Returns true if anything is wrong.  */\n \n static bool\n-verify_gimple_assign_unary (gimple stmt)\n+verify_gimple_assign_unary (gassign *stmt)\n {\n   enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n   tree lhs = gimple_assign_lhs (stmt);\n@@ -3614,7 +3628,7 @@ verify_gimple_assign_unary (gimple stmt)\n    Returns true if anything is wrong.  */\n \n static bool\n-verify_gimple_assign_binary (gimple stmt)\n+verify_gimple_assign_binary (gassign *stmt)\n {\n   enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n   tree lhs = gimple_assign_lhs (stmt);\n@@ -3855,7 +3869,7 @@ verify_gimple_assign_binary (gimple stmt)\n    Returns true if anything is wrong.  */\n \n static bool\n-verify_gimple_assign_ternary (gimple stmt)\n+verify_gimple_assign_ternary (gassign *stmt)\n {\n   enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n   tree lhs = gimple_assign_lhs (stmt);\n@@ -4028,7 +4042,7 @@ verify_gimple_assign_ternary (gimple stmt)\n    Returns true if anything is wrong.  */\n \n static bool\n-verify_gimple_assign_single (gimple stmt)\n+verify_gimple_assign_single (gassign *stmt)\n {\n   enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n   tree lhs = gimple_assign_lhs (stmt);\n@@ -4242,7 +4256,7 @@ verify_gimple_assign_single (gimple stmt)\n    is a problem, otherwise false.  */\n \n static bool\n-verify_gimple_assign (gimple stmt)\n+verify_gimple_assign (gassign *stmt)\n {\n   switch (gimple_assign_rhs_class (stmt))\n     {\n@@ -4267,7 +4281,7 @@ verify_gimple_assign (gimple stmt)\n    is a problem, otherwise false.  */\n \n static bool\n-verify_gimple_return (gimple stmt)\n+verify_gimple_return (greturn *stmt)\n {\n   tree op = gimple_return_retval (stmt);\n   tree restype = TREE_TYPE (TREE_TYPE (cfun->decl));\n@@ -4309,7 +4323,7 @@ verify_gimple_return (gimple stmt)\n    is a problem, otherwise false.  */\n \n static bool\n-verify_gimple_goto (gimple stmt)\n+verify_gimple_goto (ggoto *stmt)\n {\n   tree dest = gimple_goto_dest (stmt);\n \n@@ -4330,7 +4344,7 @@ verify_gimple_goto (gimple stmt)\n    is a problem, otherwise false.  */\n \n static bool\n-verify_gimple_switch (gimple stmt)\n+verify_gimple_switch (gswitch *stmt)\n {\n   unsigned int i, n;\n   tree elt, prev_upper_bound = NULL_TREE;\n@@ -4434,7 +4448,7 @@ verify_gimple_debug (gimple stmt ATTRIBUTE_UNUSED)\n    Returns true if anything is wrong.  */\n \n static bool\n-verify_gimple_label (gimple stmt)\n+verify_gimple_label (glabel *stmt)\n {\n   tree decl = gimple_label_label (stmt);\n   int uid;\n@@ -4472,6 +4486,31 @@ verify_gimple_label (gimple stmt)\n   return err;\n }\n \n+/* Verify a gimple cond statement STMT.\n+   Returns true if anything is wrong.  */\n+\n+static bool\n+verify_gimple_cond (gcond *stmt)\n+{\n+  if (TREE_CODE_CLASS (gimple_cond_code (stmt)) != tcc_comparison)\n+    {\n+      error (\"invalid comparison code in gimple cond\");\n+      return true;\n+    }\n+  if (!(!gimple_cond_true_label (stmt)\n+\t|| TREE_CODE (gimple_cond_true_label (stmt)) == LABEL_DECL)\n+      || !(!gimple_cond_false_label (stmt)\n+\t   || TREE_CODE (gimple_cond_false_label (stmt)) == LABEL_DECL))\n+    {\n+      error (\"invalid labels in gimple cond\");\n+      return true;\n+    }\n+\n+  return verify_gimple_comparison (boolean_type_node,\n+\t\t\t\t   gimple_cond_lhs (stmt),\n+\t\t\t\t   gimple_cond_rhs (stmt));\n+}\n+\n /* Verify the GIMPLE statement STMT.  Returns true if there is an\n    error, otherwise false.  */\n \n@@ -4481,47 +4520,31 @@ verify_gimple_stmt (gimple stmt)\n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_ASSIGN:\n-      return verify_gimple_assign (stmt);\n+      return verify_gimple_assign (as_a <gassign *> (stmt));\n \n     case GIMPLE_LABEL:\n-      return verify_gimple_label (stmt);\n+      return verify_gimple_label (as_a <glabel *> (stmt));\n \n     case GIMPLE_CALL:\n-      return verify_gimple_call (stmt);\n+      return verify_gimple_call (as_a <gcall *> (stmt));\n \n     case GIMPLE_COND:\n-      if (TREE_CODE_CLASS (gimple_cond_code (stmt)) != tcc_comparison)\n-\t{\n-\t  error (\"invalid comparison code in gimple cond\");\n-\t  return true;\n-\t}\n-      if (!(!gimple_cond_true_label (stmt)\n-\t    || TREE_CODE (gimple_cond_true_label (stmt)) == LABEL_DECL)\n-\t  || !(!gimple_cond_false_label (stmt)\n-\t       || TREE_CODE (gimple_cond_false_label (stmt)) == LABEL_DECL))\n-\t{\n-\t  error (\"invalid labels in gimple cond\");\n-\t  return true;\n-\t}\n-\t  \n-      return verify_gimple_comparison (boolean_type_node,\n-\t\t\t\t       gimple_cond_lhs (stmt),\n-\t\t\t\t       gimple_cond_rhs (stmt));\n+      return verify_gimple_cond (as_a <gcond *> (stmt));\n \n     case GIMPLE_GOTO:\n-      return verify_gimple_goto (stmt);\n+      return verify_gimple_goto (as_a <ggoto *> (stmt));\n \n     case GIMPLE_SWITCH:\n-      return verify_gimple_switch (stmt);\n+      return verify_gimple_switch (as_a <gswitch *> (stmt));\n \n     case GIMPLE_RETURN:\n-      return verify_gimple_return (stmt);\n+      return verify_gimple_return (as_a <greturn *> (stmt));\n \n     case GIMPLE_ASM:\n       return false;\n \n     case GIMPLE_TRANSACTION:\n-      return verify_gimple_transaction (stmt);\n+      return verify_gimple_transaction (as_a <gtransaction *> (stmt));\n \n     /* Tuples that do not have tree operands.  */\n     case GIMPLE_NOP:\n@@ -4627,7 +4650,8 @@ verify_gimple_in_seq_2 (gimple_seq stmts)\n       switch (gimple_code (stmt))\n         {\n \tcase GIMPLE_BIND:\n-\t  err |= verify_gimple_in_seq_2 (gimple_bind_body (stmt));\n+\t  err |= verify_gimple_in_seq_2 (\n+                   gimple_bind_body (as_a <gbind *> (stmt)));\n \t  break;\n \n \tcase GIMPLE_TRY:\n@@ -4640,16 +4664,20 @@ verify_gimple_in_seq_2 (gimple_seq stmts)\n \t  break;\n \n \tcase GIMPLE_EH_ELSE:\n-\t  err |= verify_gimple_in_seq_2 (gimple_eh_else_n_body (stmt));\n-\t  err |= verify_gimple_in_seq_2 (gimple_eh_else_e_body (stmt));\n+\t  {\n+\t    geh_else *eh_else = as_a <geh_else *> (stmt);\n+\t    err |= verify_gimple_in_seq_2 (gimple_eh_else_n_body (eh_else));\n+\t    err |= verify_gimple_in_seq_2 (gimple_eh_else_e_body (eh_else));\n+\t  }\n \t  break;\n \n \tcase GIMPLE_CATCH:\n-\t  err |= verify_gimple_in_seq_2 (gimple_catch_handler (stmt));\n+\t  err |= verify_gimple_in_seq_2 (gimple_catch_handler (\n+\t\t\t\t\t   as_a <gcatch *> (stmt)));\n \t  break;\n \n \tcase GIMPLE_TRANSACTION:\n-\t  err |= verify_gimple_transaction (stmt);\n+\t  err |= verify_gimple_transaction (as_a <gtransaction *> (stmt));\n \t  break;\n \n \tdefault:\n@@ -4669,7 +4697,7 @@ verify_gimple_in_seq_2 (gimple_seq stmts)\n    is a problem, otherwise false.  */\n \n static bool\n-verify_gimple_transaction (gimple stmt)\n+verify_gimple_transaction (gtransaction *stmt)\n {\n   tree lab = gimple_transaction_label (stmt);\n   if (lab != NULL && TREE_CODE (lab) != LABEL_DECL)\n@@ -4872,9 +4900,11 @@ verify_gimple_in_cfg (struct function *fn, bool verify_nothrow)\n     {\n       gimple_stmt_iterator gsi;\n \n-      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gphi_iterator gpi = gsi_start_phis (bb);\n+\t   !gsi_end_p (gpi);\n+\t   gsi_next (&gpi))\n \t{\n-\t  gimple phi = gsi_stmt (gsi);\n+\t  gphi *phi = gpi.phi ();\n \t  bool err2 = false;\n \t  unsigned i;\n \n@@ -5073,7 +5103,7 @@ gimple_verify_flow_info (void)\n \t  if (gimple_code (stmt) != GIMPLE_LABEL)\n \t    break;\n \n-\t  label = gimple_label_label (stmt);\n+\t  label = gimple_label_label (as_a <glabel *> (stmt));\n \t  if (prev_stmt && DECL_NONLOCAL (label))\n \t    {\n \t      error (\"nonlocal label \");\n@@ -5126,10 +5156,10 @@ gimple_verify_flow_info (void)\n \t  if (stmt_ends_bb_p (stmt))\n \t    found_ctrl_stmt = true;\n \n-\t  if (gimple_code (stmt) == GIMPLE_LABEL)\n+\t  if (glabel *label_stmt = dyn_cast <glabel *> (stmt))\n \t    {\n \t      error (\"label \");\n-\t      print_generic_expr (stderr, gimple_label_label (stmt), 0);\n+\t      print_generic_expr (stderr, gimple_label_label (label_stmt), 0);\n \t      fprintf (stderr, \" in the middle of basic block %d\", bb->index);\n \t      err = 1;\n \t    }\n@@ -5239,26 +5269,27 @@ gimple_verify_flow_info (void)\n \n \tcase GIMPLE_SWITCH:\n \t  {\n+\t    gswitch *switch_stmt = as_a <gswitch *> (stmt);\n \t    tree prev;\n \t    edge e;\n \t    size_t i, n;\n \n-\t    n = gimple_switch_num_labels (stmt);\n+\t    n = gimple_switch_num_labels (switch_stmt);\n \n \t    /* Mark all the destination basic blocks.  */\n \t    for (i = 0; i < n; ++i)\n \t      {\n-\t\ttree lab = CASE_LABEL (gimple_switch_label (stmt, i));\n+\t\ttree lab = CASE_LABEL (gimple_switch_label (switch_stmt, i));\n \t\tbasic_block label_bb = label_to_block (lab);\n \t\tgcc_assert (!label_bb->aux || label_bb->aux == (void *)1);\n \t\tlabel_bb->aux = (void *)1;\n \t      }\n \n \t    /* Verify that the case labels are sorted.  */\n-\t    prev = gimple_switch_label (stmt, 0);\n+\t    prev = gimple_switch_label (switch_stmt, 0);\n \t    for (i = 1; i < n; ++i)\n \t      {\n-\t\ttree c = gimple_switch_label (stmt, i);\n+\t\ttree c = gimple_switch_label (switch_stmt, i);\n \t\tif (!CASE_LOW (c))\n \t\t  {\n \t\t    error (\"found default case not at the start of \"\n@@ -5304,7 +5335,7 @@ gimple_verify_flow_info (void)\n \t    /* Check that we have all of them.  */\n \t    for (i = 0; i < n; ++i)\n \t      {\n-\t\ttree lab = CASE_LABEL (gimple_switch_label (stmt, i));\n+\t\ttree lab = CASE_LABEL (gimple_switch_label (switch_stmt, i));\n \t\tbasic_block label_bb = label_to_block (lab);\n \n \t\tif (label_bb->aux != (void *)2)\n@@ -5320,7 +5351,7 @@ gimple_verify_flow_info (void)\n \t  break;\n \n \tcase GIMPLE_EH_DISPATCH:\n-\t  err |= verify_eh_dispatch_edge (stmt);\n+\t  err |= verify_eh_dispatch_edge (as_a <geh_dispatch *> (stmt));\n \t  break;\n \n \tdefault:\n@@ -5345,7 +5376,7 @@ gimple_make_forwarder_block (edge fallthru)\n   edge_iterator ei;\n   basic_block dummy, bb;\n   tree var;\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n \n   dummy = fallthru->src;\n   bb = fallthru->dest;\n@@ -5357,9 +5388,9 @@ gimple_make_forwarder_block (edge fallthru)\n      start of BB.  */\n   for (gsi = gsi_start_phis (dummy); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple phi, new_phi;\n+      gphi *phi, *new_phi;\n \n-      phi = gsi_stmt (gsi);\n+      phi = gsi.phi ();\n       var = gimple_phi_result (phi);\n       new_phi = create_phi_node (var, bb);\n       gimple_phi_set_result (phi, copy_ssa_name (var, phi));\n@@ -5387,12 +5418,12 @@ gimple_block_label (basic_block bb)\n   gimple_stmt_iterator i, s = gsi_start_bb (bb);\n   bool first = true;\n   tree label;\n-  gimple stmt;\n+  glabel *stmt;\n \n   for (i = s; !gsi_end_p (i); first = false, gsi_next (&i))\n     {\n-      stmt = gsi_stmt (i);\n-      if (gimple_code (stmt) != GIMPLE_LABEL)\n+      stmt = dyn_cast <glabel *> (gsi_stmt (i));\n+      if (!stmt)\n \tbreak;\n       label = gimple_label_label (stmt);\n       if (!DECL_NONLOCAL (label))\n@@ -5492,8 +5523,9 @@ gimple_redirect_edge_and_branch (edge e, basic_block dest)\n \n     case GIMPLE_SWITCH:\n       {\n+\tgswitch *switch_stmt = as_a <gswitch *> (stmt);\n \ttree label = gimple_block_label (dest);\n-        tree cases = get_cases_for_edge (e, stmt);\n+        tree cases = get_cases_for_edge (e, switch_stmt);\n \n \t/* If we have a list of cases associated with E, then use it\n \t   as it's a lot faster than walking the entire case vector.  */\n@@ -5514,7 +5546,7 @@ gimple_redirect_edge_and_branch (edge e, basic_block dest)\n \t       to move all the cases associated with E to E2.  */\n \t    if (e2)\n \t      {\n-\t\ttree cases2 = get_cases_for_edge (e2, stmt);\n+\t\ttree cases2 = get_cases_for_edge (e2, switch_stmt);\n \n \t\tCASE_CHAIN (last) = CASE_CHAIN (cases2);\n \t\tCASE_CHAIN (cases2) = first;\n@@ -5523,11 +5555,11 @@ gimple_redirect_edge_and_branch (edge e, basic_block dest)\n \t  }\n \telse\n \t  {\n-\t    size_t i, n = gimple_switch_num_labels (stmt);\n+\t    size_t i, n = gimple_switch_num_labels (switch_stmt);\n \n \t    for (i = 0; i < n; i++)\n \t      {\n-\t\ttree elt = gimple_switch_label (stmt, i);\n+\t\ttree elt = gimple_switch_label (switch_stmt, i);\n \t\tif (label_to_block (CASE_LABEL (elt)) == e->dest)\n \t\t  CASE_LABEL (elt) = label;\n \t      }\n@@ -5537,12 +5569,13 @@ gimple_redirect_edge_and_branch (edge e, basic_block dest)\n \n     case GIMPLE_ASM:\n       {\n-\tint i, n = gimple_asm_nlabels (stmt);\n+\tgasm *asm_stmt = as_a <gasm *> (stmt);\n+\tint i, n = gimple_asm_nlabels (asm_stmt);\n \ttree label = NULL;\n \n \tfor (i = 0; i < n; ++i)\n \t  {\n-\t    tree cons = gimple_asm_label_op (stmt, i);\n+\t    tree cons = gimple_asm_label_op (asm_stmt, i);\n \t    if (label_to_block (TREE_VALUE (cons)) == e->dest)\n \t      {\n \t\tif (!label)\n@@ -5572,14 +5605,15 @@ gimple_redirect_edge_and_branch (edge e, basic_block dest)\n \n     case GIMPLE_EH_DISPATCH:\n       if (!(e->flags & EDGE_FALLTHRU))\n-\tredirect_eh_dispatch_edge (stmt, e, dest);\n+\tredirect_eh_dispatch_edge (as_a <geh_dispatch *> (stmt), e, dest);\n       break;\n \n     case GIMPLE_TRANSACTION:\n       /* The ABORT edge has a stored label associated with it, otherwise\n \t the edges are simply redirectable.  */\n       if (e->flags == 0)\n-\tgimple_transaction_set_label (stmt, gimple_block_label (dest));\n+\tgimple_transaction_set_label (as_a <gtransaction *> (stmt),\n+\t\t\t\t      gimple_block_label (dest));\n       break;\n \n     default:\n@@ -5748,29 +5782,33 @@ static basic_block\n gimple_duplicate_bb (basic_block bb)\n {\n   basic_block new_bb;\n-  gimple_stmt_iterator gsi, gsi_tgt;\n-  gimple_seq phis = phi_nodes (bb);\n-  gimple phi, stmt, copy;\n+  gimple_stmt_iterator gsi_tgt;\n \n   new_bb = create_empty_bb (EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb);\n \n   /* Copy the PHI nodes.  We ignore PHI node arguments here because\n      the incoming edges have not been setup yet.  */\n-  for (gsi = gsi_start (phis); !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gphi_iterator gpi = gsi_start_phis (bb);\n+       !gsi_end_p (gpi);\n+       gsi_next (&gpi))\n     {\n-      phi = gsi_stmt (gsi);\n+      gphi *phi, *copy;\n+      phi = gpi.phi ();\n       copy = create_phi_node (NULL_TREE, new_bb);\n       create_new_def_for (gimple_phi_result (phi), copy,\n \t\t\t  gimple_phi_result_ptr (copy));\n       gimple_set_uid (copy, gimple_uid (phi));\n     }\n \n   gsi_tgt = gsi_start_bb (new_bb);\n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gimple_stmt_iterator gsi = gsi_start_bb (bb);\n+       !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n     {\n       def_operand_p def_p;\n       ssa_op_iter op_iter;\n       tree lhs;\n+      gimple stmt, copy;\n \n       stmt = gsi_stmt (gsi);\n       if (gimple_code (stmt) == GIMPLE_LABEL)\n@@ -5825,9 +5863,9 @@ add_phi_args_after_copy_edge (edge e_copy)\n   basic_block bb, bb_copy = e_copy->src, dest;\n   edge e;\n   edge_iterator ei;\n-  gimple phi, phi_copy;\n+  gphi *phi, *phi_copy;\n   tree def;\n-  gimple_stmt_iterator psi, psi_copy;\n+  gphi_iterator psi, psi_copy;\n \n   if (gimple_seq_empty_p (phi_nodes (e_copy->dest)))\n     return;\n@@ -5860,8 +5898,8 @@ add_phi_args_after_copy_edge (edge e_copy)\n        !gsi_end_p (psi);\n        gsi_next (&psi), gsi_next (&psi_copy))\n     {\n-      phi = gsi_stmt (psi);\n-      phi_copy = gsi_stmt (psi_copy);\n+      phi = psi.phi ();\n+      phi_copy = psi_copy.phi ();\n       def = PHI_ARG_DEF_FROM_EDGE (phi, e);\n       add_phi_arg (phi_copy, def, e_copy,\n \t\t   gimple_phi_arg_location_from_edge (phi, e));\n@@ -6123,8 +6161,8 @@ gimple_duplicate_sese_tail (edge entry ATTRIBUTE_UNUSED, edge exit ATTRIBUTE_UNU\n   gimple cond_stmt;\n   edge sorig, snew;\n   basic_block exit_bb;\n-  gimple_stmt_iterator psi;\n-  gimple phi;\n+  gphi_iterator psi;\n+  gphi *phi;\n   tree def;\n   struct loop *target, *aloop, *cloop;\n \n@@ -6244,7 +6282,7 @@ gimple_duplicate_sese_tail (edge entry ATTRIBUTE_UNUSED, edge exit ATTRIBUTE_UNU\n \t     !gsi_end_p (psi);\n \t     gsi_next (&psi))\n \t  {\n-\t    phi = gsi_stmt (psi);\n+\t    phi = psi.phi ();\n \t    def = PHI_ARG_DEF (phi, nexits[0]->dest_idx);\n \t    add_phi_arg (phi, def, e, gimple_phi_arg_location_from_edge (phi, e));\n \t  }\n@@ -6517,17 +6555,19 @@ move_stmt_r (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n \n     case GIMPLE_RESX:\n       {\n-\tint r = gimple_resx_region (stmt);\n+\tgresx *resx_stmt = as_a <gresx *> (stmt);\n+\tint r = gimple_resx_region (resx_stmt);\n \tr = move_stmt_eh_region_nr (r, p);\n-\tgimple_resx_set_region (stmt, r);\n+\tgimple_resx_set_region (resx_stmt, r);\n       }\n       break;\n \n     case GIMPLE_EH_DISPATCH:\n       {\n-\tint r = gimple_eh_dispatch_region (stmt);\n+\tgeh_dispatch *eh_dispatch_stmt = as_a <geh_dispatch *> (stmt);\n+\tint r = gimple_eh_dispatch_region (eh_dispatch_stmt);\n \tr = move_stmt_eh_region_nr (r, p);\n-\tgimple_eh_dispatch_set_region (stmt, r);\n+\tgimple_eh_dispatch_set_region (eh_dispatch_stmt, r);\n       }\n       break;\n \n@@ -6619,9 +6659,10 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n   (*cfg->x_basic_block_info)[bb->index] = bb;\n \n   /* Remap the variables in phi nodes.  */\n-  for (si = gsi_start_phis (bb); !gsi_end_p (si); )\n+  for (gphi_iterator psi = gsi_start_phis (bb);\n+       !gsi_end_p (psi); )\n     {\n-      gimple phi = gsi_stmt (si);\n+      gphi *phi = psi.phi ();\n       use_operand_p use;\n       tree op = PHI_RESULT (phi);\n       ssa_op_iter oi;\n@@ -6631,7 +6672,7 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n \t{\n \t  /* Remove the phi nodes for virtual operands (alias analysis will be\n \t     run for the new function, anyway).  */\n-          remove_phi_node (&si, true);\n+          remove_phi_node (&psi, true);\n \t  continue;\n \t}\n \n@@ -6661,7 +6702,7 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n \t    }\n \t}\n \n-      gsi_next (&si);\n+      gsi_next (&psi);\n     }\n \n   for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n@@ -6673,9 +6714,9 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n       wi.info = d;\n       walk_gimple_stmt (&si, move_stmt_r, move_stmt_op, &wi);\n \n-      if (gimple_code (stmt) == GIMPLE_LABEL)\n+      if (glabel *label_stmt = dyn_cast <glabel *> (stmt))\n \t{\n-\t  tree label = gimple_label_label (stmt);\n+\t  tree label = gimple_label_label (label_stmt);\n \t  int uid = LABEL_DECL_UID (label);\n \n \t  gcc_assert (uid > -1);\n@@ -7569,9 +7610,9 @@ need_fake_edge_p (gimple t)\n \t  return true;\n     }\n \n-  if (gimple_code (t) == GIMPLE_ASM\n-       && (gimple_asm_volatile_p (t) || gimple_asm_input_p (t)))\n-    return true;\n+  if (gasm *asm_stmt = dyn_cast <gasm *> (t))\n+    if (gimple_asm_volatile_p (asm_stmt) || gimple_asm_input_p (asm_stmt))\n+      return true;\n \n   return false;\n }\n@@ -7969,8 +8010,8 @@ static void\n gimple_lv_adjust_loop_header_phi (basic_block first, basic_block second,\n \t\t\t\t  basic_block new_head, edge e)\n {\n-  gimple phi1, phi2;\n-  gimple_stmt_iterator psi1, psi2;\n+  gphi *phi1, *phi2;\n+  gphi_iterator psi1, psi2;\n   tree def;\n   edge e2 = find_edge (new_head, second);\n \n@@ -7986,8 +8027,8 @@ gimple_lv_adjust_loop_header_phi (basic_block first, basic_block second,\n        !gsi_end_p (psi2) && !gsi_end_p (psi1);\n        gsi_next (&psi2),  gsi_next (&psi1))\n     {\n-      phi1 = gsi_stmt (psi1);\n-      phi2 = gsi_stmt (psi2);\n+      phi1 = psi1.phi ();\n+      phi2 = psi2.phi ();\n       def = PHI_ARG_DEF (phi2, e2->dest_idx);\n       add_phi_arg (phi1, def, e, gimple_phi_arg_location_from_edge (phi2, e2));\n     }\n@@ -8353,8 +8394,9 @@ pass_warn_function_return::execute (function *fun)\n       FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (fun)->preds)\n \t{\n \t  gimple last = last_stmt (e->src);\n-\t  if (gimple_code (last) == GIMPLE_RETURN\n-\t      && gimple_return_retval (last) == NULL\n+\t  greturn *return_stmt = dyn_cast <greturn *> (last);\n+\t  if (return_stmt\n+\t      && gimple_return_retval (return_stmt) == NULL\n \t      && !gimple_no_warning_p (last))\n \t    {\n \t      location = gimple_location (last);\n@@ -8394,14 +8436,15 @@ do_warn_unused_result (gimple_seq seq)\n       switch (gimple_code (g))\n \t{\n \tcase GIMPLE_BIND:\n-\t  do_warn_unused_result (gimple_bind_body (g));\n+\t  do_warn_unused_result (gimple_bind_body (as_a <gbind *>(g)));\n \t  break;\n \tcase GIMPLE_TRY:\n \t  do_warn_unused_result (gimple_try_eval (g));\n \t  do_warn_unused_result (gimple_try_cleanup (g));\n \t  break;\n \tcase GIMPLE_CATCH:\n-\t  do_warn_unused_result (gimple_catch_handler (g));\n+\t  do_warn_unused_result (gimple_catch_handler (\n+\t\t\t\t   as_a <gcatch *> (g)));\n \t  break;\n \tcase GIMPLE_EH_FILTER:\n \t  do_warn_unused_result (gimple_eh_filter_failure (g));"}, {"sha": "626e97380d8adb293e974000400803945080fbca", "filename": "gcc/tree-cfg.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-cfg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-cfg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -37,11 +37,11 @@ extern void end_recording_case_labels (void);\n extern basic_block label_to_block_fn (struct function *, tree);\n #define label_to_block(t) (label_to_block_fn (cfun, t))\n extern void cleanup_dead_labels (void);\n-extern void group_case_labels_stmt (gimple);\n+extern void group_case_labels_stmt (gswitch *);\n extern void group_case_labels (void);\n extern void replace_uses_by (tree, tree);\n extern basic_block single_noncomplex_succ (basic_block bb);\n-extern void notice_special_calls (gimple);\n+extern void notice_special_calls (gcall *);\n extern void clear_special_calls (void);\n extern edge find_taken_edge (basic_block, tree);\n extern void gimple_debug_bb (basic_block);"}, {"sha": "438b55442bfca57e794d06c0c68f65d7da335a57", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -123,7 +123,7 @@ cleanup_control_expr_graph (basic_block bb, gimple_stmt_iterator gsi)\n \t  break;\n \n \tcase GIMPLE_SWITCH:\n-\t  val = gimple_switch_index (stmt);\n+\t  val = gimple_switch_index (as_a <gswitch *> (stmt));\n \t  break;\n \n \tdefault:\n@@ -319,7 +319,7 @@ tree_forwarder_block_p (basic_block bb, bool phi_wanted)\n       switch (gimple_code (stmt))\n \t{\n \tcase GIMPLE_LABEL:\n-\t  if (DECL_NONLOCAL (gimple_label_label (stmt)))\n+\t  if (DECL_NONLOCAL (gimple_label_label (as_a <glabel *> (stmt))))\n \t    return false;\n \t  if (optimize == 0 && gimple_location (stmt) != locus)\n \t    return false;\n@@ -377,11 +377,11 @@ phi_alternatives_equal (basic_block dest, edge e1, edge e2)\n {\n   int n1 = e1->dest_idx;\n   int n2 = e2->dest_idx;\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n \n   for (gsi = gsi_start_phis (dest); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n       tree val1 = gimple_phi_arg_def (phi, n1);\n       tree val2 = gimple_phi_arg_def (phi, n2);\n \n@@ -416,11 +416,11 @@ remove_forwarder_block (basic_block bb)\n   /* If the destination block consists of a nonlocal label or is a\n      EH landing pad, do not merge it.  */\n   label = first_stmt (dest);\n-  if (label\n-      && gimple_code (label) == GIMPLE_LABEL\n-      && (DECL_NONLOCAL (gimple_label_label (label))\n-\t  || EH_LANDING_PAD_NR (gimple_label_label (label)) != 0))\n-    return false;\n+  if (label)\n+    if (glabel *label_stmt = dyn_cast <glabel *> (label))\n+      if (DECL_NONLOCAL (gimple_label_label (label_stmt))\n+\t  || EH_LANDING_PAD_NR (gimple_label_label (label_stmt)) != 0)\n+\treturn false;\n \n   /* If there is an abnormal edge to basic block BB, but not into\n      dest, problems might occur during removal of the phi node at out\n@@ -478,11 +478,11 @@ remove_forwarder_block (basic_block bb)\n \t{\n \t  /* Create arguments for the phi nodes, since the edge was not\n \t     here before.  */\n-\t  for (gsi = gsi_start_phis (dest);\n-\t       !gsi_end_p (gsi);\n-\t       gsi_next (&gsi))\n+\t  for (gphi_iterator psi = gsi_start_phis (dest);\n+\t       !gsi_end_p (psi);\n+\t       gsi_next (&psi))\n \t    {\n-\t      gimple phi = gsi_stmt (gsi);\n+\t      gphi *phi = psi.phi ();\n \t      source_location l = gimple_phi_arg_location_from_edge (phi, succ);\n \t      tree def = gimple_phi_arg_def (phi, succ->dest_idx);\n \t      add_phi_arg (phi, unshare_expr (def), s, l);\n@@ -502,7 +502,7 @@ remove_forwarder_block (basic_block bb)\n       label = gsi_stmt (gsi);\n       if (is_gimple_debug (label))\n \tbreak;\n-      decl = gimple_label_label (label);\n+      decl = gimple_label_label (as_a <glabel *> (label));\n       if (EH_LANDING_PAD_NR (decl) != 0\n \t  || DECL_NONLOCAL (decl)\n \t  || FORCED_LABEL (decl)\n@@ -828,10 +828,10 @@ remove_forwarder_block_with_phi (basic_block bb)\n   /* If the destination block consists of a nonlocal label, do not\n      merge it.  */\n   label = first_stmt (dest);\n-  if (label\n-      && gimple_code (label) == GIMPLE_LABEL\n-      && DECL_NONLOCAL (gimple_label_label (label)))\n-    return false;\n+  if (label)\n+    if (glabel *label_stmt = dyn_cast <glabel *> (label))\n+      if (DECL_NONLOCAL (gimple_label_label (label_stmt)))\n+\treturn false;\n \n   /* Record BB's single pred in case we need to update the father\n      loop's latch information later.  */\n@@ -843,7 +843,7 @@ remove_forwarder_block_with_phi (basic_block bb)\n   while (EDGE_COUNT (bb->preds) > 0)\n     {\n       edge e = EDGE_PRED (bb, 0), s;\n-      gimple_stmt_iterator gsi;\n+      gphi_iterator gsi;\n \n       s = find_edge (e->src, dest);\n       if (s)\n@@ -875,7 +875,7 @@ remove_forwarder_block_with_phi (basic_block bb)\n \t   !gsi_end_p (gsi);\n \t   gsi_next (&gsi))\n \t{\n-\t  gimple phi = gsi_stmt (gsi);\n+\t  gphi *phi = gsi.phi ();\n \t  tree def = gimple_phi_arg_def (phi, succ->dest_idx);\n \t  source_location locus = gimple_phi_arg_location_from_edge (phi, succ);\n \n@@ -1023,7 +1023,7 @@ pass_merge_phi::execute (function *fun)\n \t}\n       else\n \t{\n-\t  gimple_stmt_iterator gsi;\n+\t  gphi_iterator gsi;\n \t  unsigned int dest_idx = single_succ_edge (bb)->dest_idx;\n \n \t  /* BB dominates DEST.  There may be many users of the PHI\n@@ -1034,7 +1034,7 @@ pass_merge_phi::execute (function *fun)\n \t  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n \t       gsi_next (&gsi))\n \t    {\n-\t      gimple phi = gsi_stmt (gsi);\n+\t      gphi *phi = gsi.phi ();\n \t      tree result = gimple_phi_result (phi);\n \t      use_operand_p imm_use;\n \t      gimple use_stmt;"}, {"sha": "3e386918e014bd420e8cd0b5fe95231be91d6b33", "filename": "gcc/tree-chkp.c", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-chkp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-chkp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chkp.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -691,18 +691,15 @@ chkp_recompute_phi_bounds (tree const &bounds, tree *slot,\n \t\t\t   void *res ATTRIBUTE_UNUSED)\n {\n   tree ptr = *slot;\n-  gimple bounds_phi;\n-  gimple ptr_phi;\n+  gphi *bounds_phi;\n+  gphi *ptr_phi;\n   unsigned i;\n \n   gcc_assert (TREE_CODE (bounds) == SSA_NAME);\n   gcc_assert (TREE_CODE (ptr) == SSA_NAME);\n \n-  bounds_phi = SSA_NAME_DEF_STMT (bounds);\n-  ptr_phi = SSA_NAME_DEF_STMT (ptr);\n-\n-  gcc_assert (bounds_phi && gimple_code (bounds_phi) == GIMPLE_PHI);\n-  gcc_assert (ptr_phi && gimple_code (ptr_phi) == GIMPLE_PHI);\n+  bounds_phi = as_a <gphi *> (SSA_NAME_DEF_STMT (bounds));\n+  ptr_phi = as_a <gphi *> (SSA_NAME_DEF_STMT (ptr));\n \n   for (i = 0; i < gimple_phi_num_args (bounds_phi); i++)\n     {\n@@ -1198,7 +1195,7 @@ chkp_get_registered_bounds (tree ptr)\n static void\n chkp_add_bounds_to_ret_stmt (gimple_stmt_iterator *gsi)\n {\n-  gimple ret = gsi_stmt (*gsi);\n+  greturn *ret = as_a <greturn *> (gsi_stmt (*gsi));\n   tree retval = gimple_return_retval (ret);\n   tree ret_decl = DECL_RESULT (cfun->decl);\n   tree bounds;\n@@ -1637,7 +1634,7 @@ chkp_instrument_normal_builtin (tree fndecl)\n static void\n chkp_add_bounds_to_call_stmt (gimple_stmt_iterator *gsi)\n {\n-  gimple call = gsi_stmt (*gsi);\n+  gcall *call = as_a <gcall *> (gsi_stmt (*gsi));\n   unsigned arg_no = 0;\n   tree fndecl = gimple_call_fndecl (call);\n   tree fntype;\n@@ -1646,7 +1643,7 @@ chkp_add_bounds_to_call_stmt (gimple_stmt_iterator *gsi)\n   bool use_fntype = false;\n   tree op;\n   ssa_op_iter iter;\n-  gimple new_call;\n+  gcall *new_call;\n \n   /* Do nothing for internal functions.  */\n   if (gimple_call_internal_p (call))\n@@ -2085,7 +2082,7 @@ chkp_get_nonpointer_load_bounds (void)\n \n /* Build bounds returned by CALL.  */\n static tree\n-chkp_build_returned_bound (gimple call)\n+chkp_build_returned_bound (gcall *call)\n {\n   gimple_stmt_iterator gsi;\n   tree bounds;\n@@ -2191,7 +2188,7 @@ chkp_build_returned_bound (gimple call)\n \n /* Return bounds used as returned by call\n    which produced SSA name VAL.  */\n-gimple\n+gcall *\n chkp_retbnd_call_by_val (tree val)\n {\n   if (TREE_CODE (val) != SSA_NAME)\n@@ -2204,7 +2201,7 @@ chkp_retbnd_call_by_val (tree val)\n   FOR_EACH_IMM_USE_FAST (use_p, use_iter, val)\n     if (gimple_code (USE_STMT (use_p)) == GIMPLE_CALL\n \t&& gimple_call_fndecl (USE_STMT (use_p)) == chkp_ret_bnd_fndecl)\n-      return USE_STMT (use_p);\n+      return as_a <gcall *> (USE_STMT (use_p));\n \n   return NULL;\n }\n@@ -2599,11 +2596,11 @@ chkp_compute_bounds_for_assignment (tree node, gimple assign)\n    Return computed bounds.  */\n static tree\n chkp_get_bounds_by_definition (tree node, gimple def_stmt,\n-\t\t\t       gimple_stmt_iterator *iter)\n+\t\t\t       gphi_iterator *iter)\n {\n   tree var, bounds;\n   enum gimple_code code = gimple_code (def_stmt);\n-  gimple stmt;\n+  gphi *stmt;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -2664,7 +2661,7 @@ chkp_get_bounds_by_definition (tree node, gimple def_stmt,\n       break;\n \n     case GIMPLE_CALL:\n-      bounds = chkp_build_returned_bound (def_stmt);\n+      bounds = chkp_build_returned_bound (as_a <gcall *> (def_stmt));\n       break;\n \n     case GIMPLE_PHI:\n@@ -2679,7 +2676,7 @@ chkp_get_bounds_by_definition (tree node, gimple def_stmt,\n \tvar = chkp_get_tmp_var ();\n       stmt = create_phi_node (var, gimple_bb (def_stmt));\n       bounds = gimple_phi_result (stmt);\n-      *iter = gsi_for_stmt (stmt);\n+      *iter = gsi_for_phi (stmt);\n \n       bounds = chkp_maybe_copy_and_register_bounds (node, bounds);\n \n@@ -3389,21 +3386,21 @@ chkp_find_bounds_1 (tree ptr, tree ptr_src, gimple_stmt_iterator *iter)\n       if (!bounds)\n \t{\n \t  gimple def_stmt = SSA_NAME_DEF_STMT (ptr_src);\n-\t  gimple_stmt_iterator phi_iter;\n+\t  gphi_iterator phi_iter;\n \n \t  bounds = chkp_get_bounds_by_definition (ptr_src, def_stmt, &phi_iter);\n \n \t  gcc_assert (bounds);\n \n-\t  if (gimple_code (def_stmt) == GIMPLE_PHI)\n+\t  if (gphi *def_phi = dyn_cast <gphi *> (def_stmt))\n \t    {\n \t      unsigned i;\n \n-\t      for (i = 0; i < gimple_phi_num_args (def_stmt); i++)\n+\t      for (i = 0; i < gimple_phi_num_args (def_phi); i++)\n \t\t{\n-\t\t  tree arg = gimple_phi_arg_def (def_stmt, i);\n+\t\t  tree arg = gimple_phi_arg_def (def_phi, i);\n \t\t  tree arg_bnd;\n-\t\t  gimple phi_bnd;\n+\t\t  gphi *phi_bnd;\n \n \t\t  arg_bnd = chkp_find_bounds (arg, NULL);\n \n@@ -3413,10 +3410,10 @@ chkp_find_bounds_1 (tree ptr, tree ptr_src, gimple_stmt_iterator *iter)\n \t\t     Previous call to chkp_find_bounds could create\n \t\t     new basic block and therefore change phi statement\n \t\t     phi_iter points to.  */\n-\t\t  phi_bnd = gsi_stmt (phi_iter);\n+\t\t  phi_bnd = phi_iter.phi ();\n \n \t\t  add_phi_arg (phi_bnd, arg_bnd,\n-\t\t\t       gimple_phi_arg_edge (def_stmt, i),\n+\t\t\t       gimple_phi_arg_edge (def_phi, i),\n \t\t\t       UNKNOWN_LOCATION);\n \t\t}\n \n@@ -3874,7 +3871,9 @@ chkp_copy_bounds_for_assign (gimple assign, struct cgraph_edge *edge)\n \t\t      || fndecl == chkp_bndldx_fndecl\n \t\t      || fndecl == chkp_ret_bnd_fndecl);\n \n-\t  new_edge = edge->caller->create_edge (callee, stmt, edge->count,\n+\t  new_edge = edge->caller->create_edge (callee,\n+\t\t\t\t\t\tas_a <gcall *> (stmt),\n+\t\t\t\t\t\tedge->count,\n \t\t\t\t\t\tedge->frequency);\n \t  new_edge->frequency = compute_call_stmt_bb_frequency\n \t    (edge->caller->decl, gimple_bb (stmt));\n@@ -4036,18 +4035,21 @@ chkp_instrument_function (void)\n               break;\n \n             case GIMPLE_RETURN:\n-              if (gimple_return_retval (s) != NULL_TREE)\n-\t\t{\n-\t\t  chkp_process_stmt (&i, gimple_return_retval (s),\n-\t\t\t\t     gimple_location (s),\n-\t\t\t\t     integer_zero_node,\n-\t\t\t\t     NULL_TREE, NULL_TREE, safe);\n-\n-\t\t  /* Additionally we need to add bounds\n-\t\t     to return statement.  */\n-\t\t  chkp_add_bounds_to_ret_stmt (&i);\n-                }\n-              break;\n+\t      {\n+\t\tgreturn *r = as_a <greturn *> (s);\n+\t\tif (gimple_return_retval (r) != NULL_TREE)\n+\t\t  {\n+\t\t    chkp_process_stmt (&i, gimple_return_retval (r),\n+\t\t\t\t       gimple_location (r),\n+\t\t\t\t       integer_zero_node,\n+\t\t\t\t       NULL_TREE, NULL_TREE, safe);\n+\n+\t\t    /* Additionally we need to add bounds\n+\t\t       to return statement.  */\n+\t\t    chkp_add_bounds_to_ret_stmt (&i);\n+\t\t  }\n+\t      }\n+\t      break;\n \n \t    case GIMPLE_CALL:\n \t      chkp_add_bounds_to_call_stmt (&i);"}, {"sha": "71a29c0bfa5aca7f8d1247e4cf214a02cffa22f4", "filename": "gcc/tree-chkp.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-chkp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-chkp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chkp.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -46,7 +46,7 @@ extern tree chkp_build_bndstx_call (tree addr, tree ptr, tree bounds);\n extern void chkp_find_bound_slots (const_tree type, bitmap res);\n extern void chkp_build_bndstx (tree addr, tree ptr, tree bounds,\n \t\t\t       gimple_stmt_iterator *gsi);\n-extern gimple chkp_retbnd_call_by_val (tree val);\n+extern gcall *chkp_retbnd_call_by_val (tree val);\n extern bool chkp_function_instrumented_p (tree fndecl);\n extern void chkp_function_mark_instrumented (tree fndecl);\n extern void chkp_copy_bounds_for_assign (gimple assign,"}, {"sha": "a2d3639e964bb19a678798eec247a8245d710f46", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -211,20 +211,20 @@ static bool\n init_dont_simulate_again (void)\n {\n   basic_block bb;\n-  gimple_stmt_iterator gsi;\n-  gimple phi;\n   bool saw_a_complex_op = false;\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n \t{\n-\t  phi = gsi_stmt (gsi);\n+\t  gphi *phi = gsi.phi ();\n \t  prop_set_simulate_again (phi,\n \t\t\t\t   is_complex_reg (gimple_phi_result (phi)));\n \t}\n \n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n \t{\n \t  gimple stmt;\n \t  tree op0, op1;\n@@ -409,7 +409,7 @@ complex_visit_stmt (gimple stmt, edge *taken_edge_p ATTRIBUTE_UNUSED,\n /* Evaluate a PHI node against the complex lattice defined above.  */\n \n static enum ssa_prop_result\n-complex_visit_phi (gimple phi)\n+complex_visit_phi (gphi *phi)\n {\n   complex_lattice_t new_l, old_l;\n   unsigned int ver;\n@@ -732,11 +732,11 @@ update_parameter_components (void)\n static void\n update_phi_components (basic_block bb)\n {\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n \n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n \n       if (is_complex_reg (gimple_phi_result (phi)))\n \t{\n@@ -865,7 +865,7 @@ expand_complex_move (gimple_stmt_iterator *gsi, tree type)\n \n \t  stmt = gsi_stmt (*gsi);\n \t  gcc_assert (gimple_code (stmt) == GIMPLE_RETURN);\n-\t  gimple_return_set_retval (stmt, lhs);\n+\t  gimple_return_set_retval (as_a <greturn *> (stmt), lhs);\n \t}\n \n       update_stmt (stmt);\n@@ -960,7 +960,8 @@ expand_complex_libcall (gimple_stmt_iterator *gsi, tree ar, tree ai,\n   machine_mode mode;\n   enum built_in_function bcode;\n   tree fn, type, lhs;\n-  gimple old_stmt, stmt;\n+  gimple old_stmt;\n+  gcall *stmt;\n \n   old_stmt = gsi_stmt (*gsi);\n   lhs = gimple_assign_lhs (old_stmt);\n@@ -1400,8 +1401,11 @@ expand_complex_comparison (gimple_stmt_iterator *gsi, tree ar, tree ai,\n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_RETURN:\n-      type = TREE_TYPE (gimple_return_retval (stmt));\n-      gimple_return_set_retval (stmt, fold_convert (type, cc));\n+      {\n+\tgreturn *return_stmt = as_a <greturn *> (stmt);\n+\ttype = TREE_TYPE (gimple_return_retval (return_stmt));\n+\tgimple_return_set_retval (return_stmt, fold_convert (type, cc));\n+      }\n       break;\n \n     case GIMPLE_ASSIGN:\n@@ -1411,9 +1415,12 @@ expand_complex_comparison (gimple_stmt_iterator *gsi, tree ar, tree ai,\n       break;\n \n     case GIMPLE_COND:\n-      gimple_cond_set_code (stmt, EQ_EXPR);\n-      gimple_cond_set_lhs (stmt, cc);\n-      gimple_cond_set_rhs (stmt, boolean_true_node);\n+      {\n+\tgcond *cond_stmt = as_a <gcond *> (stmt);\n+\tgimple_cond_set_code (cond_stmt, EQ_EXPR);\n+\tgimple_cond_set_lhs (cond_stmt, cc);\n+\tgimple_cond_set_rhs (cond_stmt, boolean_true_node);\n+      }\n       break;\n \n     default:\n@@ -1428,7 +1435,7 @@ expand_complex_comparison (gimple_stmt_iterator *gsi, tree ar, tree ai,\n static void\n expand_complex_asm (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gasm *stmt = as_a <gasm *> (gsi_stmt (*gsi));\n   unsigned int i;\n \n   for (i = 0; i < gimple_asm_noutputs (stmt); ++i)"}, {"sha": "cca569ac216ee06850e8504ccc4d56dece8f2b66", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -4399,7 +4399,8 @@ get_references_in_stmt (gimple stmt, vec<data_ref_loc, va_heap> *references)\n \tclobbers_memory = true;\n     }\n   else if (stmt_code == GIMPLE_ASM\n-\t   && (gimple_asm_volatile_p (stmt) || gimple_vuse (stmt)))\n+\t   && (gimple_asm_volatile_p (as_a <gasm *> (stmt))\n+\t       || gimple_vuse (stmt)))\n     clobbers_memory = true;\n \n   if (!gimple_vuse (stmt))"}, {"sha": "681bf18ffac994186353cad1a37e45fe56983d6a", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -241,7 +241,7 @@ dump_dfa_stats (FILE *file)\n   fprintf (file, fmt_str_1, \"VDEF operands\", dfa_stats.num_vdefs,\n \t   SCALE (size), LABEL (size));\n \n-  size = dfa_stats.num_phis * sizeof (struct gimple_statement_phi);\n+  size = dfa_stats.num_phis * sizeof (struct gphi);\n   total += size;\n   fprintf (file, fmt_str_1, \"PHI nodes\", dfa_stats.num_phis,\n \t   SCALE (size), LABEL (size));\n@@ -290,18 +290,18 @@ collect_dfa_stats (struct dfa_stats_d *dfa_stats_p ATTRIBUTE_UNUSED)\n   /* Walk all the statements in the function counting references.  */\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      gimple_stmt_iterator si;\n-\n-      for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n+      for (gphi_iterator si = gsi_start_phis (bb); !gsi_end_p (si);\n+\t   gsi_next (&si))\n \t{\n-\t  gimple phi = gsi_stmt (si);\n+\t  gphi *phi = si.phi ();\n \t  dfa_stats_p->num_phis++;\n \t  dfa_stats_p->num_phi_args += gimple_phi_num_args (phi);\n \t  if (gimple_phi_num_args (phi) > dfa_stats_p->max_num_phi_args)\n \t    dfa_stats_p->max_num_phi_args = gimple_phi_num_args (phi);\n \t}\n \n-      for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+      for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n+\t   gsi_next (&si))\n \t{\n \t  gimple stmt = gsi_stmt (si);\n \t  dfa_stats_p->num_defs += NUM_SSA_OPERANDS (stmt, SSA_OP_DEF);"}, {"sha": "8180ff7e6e06a16752d1b40f1dee1e739a610f37", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 160, "deletions": 119, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -190,7 +190,7 @@ struct finally_tree_node\n      tree) leaves the TRY block, its necessary to record a tree in\n      this field.  Thus a treemple is used. */\n   treemple child;\n-  gimple parent;\n+  gtry *parent;\n };\n \n /* Hashtable helpers.  */\n@@ -219,7 +219,7 @@ finally_tree_hasher::equal (const value_type *v, const compare_type *c)\n static hash_table<finally_tree_hasher> *finally_tree;\n \n static void\n-record_in_finally_tree (treemple child, gimple parent)\n+record_in_finally_tree (treemple child, gtry *parent)\n {\n   struct finally_tree_node *n;\n   finally_tree_node **slot;\n@@ -234,13 +234,13 @@ record_in_finally_tree (treemple child, gimple parent)\n }\n \n static void\n-collect_finally_tree (gimple stmt, gimple region);\n+collect_finally_tree (gimple stmt, gtry *region);\n \n /* Go through the gimple sequence.  Works with collect_finally_tree to\n    record all GIMPLE_LABEL and GIMPLE_TRY statements. */\n \n static void\n-collect_finally_tree_1 (gimple_seq seq, gimple region)\n+collect_finally_tree_1 (gimple_seq seq, gtry *region)\n {\n   gimple_stmt_iterator gsi;\n \n@@ -249,14 +249,14 @@ collect_finally_tree_1 (gimple_seq seq, gimple region)\n }\n \n static void\n-collect_finally_tree (gimple stmt, gimple region)\n+collect_finally_tree (gimple stmt, gtry *region)\n {\n   treemple temp;\n \n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_LABEL:\n-      temp.t = gimple_label_label (stmt);\n+      temp.t = gimple_label_label (as_a <glabel *> (stmt));\n       record_in_finally_tree (temp, region);\n       break;\n \n@@ -265,7 +265,8 @@ collect_finally_tree (gimple stmt, gimple region)\n         {\n           temp.g = stmt;\n           record_in_finally_tree (temp, region);\n-          collect_finally_tree_1 (gimple_try_eval (stmt), stmt);\n+          collect_finally_tree_1 (gimple_try_eval (stmt),\n+\t\t\t\t  as_a <gtry *> (stmt));\n \t  collect_finally_tree_1 (gimple_try_cleanup (stmt), region);\n         }\n       else if (gimple_try_kind (stmt) == GIMPLE_TRY_CATCH)\n@@ -276,16 +277,21 @@ collect_finally_tree (gimple stmt, gimple region)\n       break;\n \n     case GIMPLE_CATCH:\n-      collect_finally_tree_1 (gimple_catch_handler (stmt), region);\n+      collect_finally_tree_1 (gimple_catch_handler (\n+\t\t\t\t as_a <gcatch *> (stmt)),\n+\t\t\t      region);\n       break;\n \n     case GIMPLE_EH_FILTER:\n       collect_finally_tree_1 (gimple_eh_filter_failure (stmt), region);\n       break;\n \n     case GIMPLE_EH_ELSE:\n-      collect_finally_tree_1 (gimple_eh_else_n_body (stmt), region);\n-      collect_finally_tree_1 (gimple_eh_else_e_body (stmt), region);\n+      {\n+\tgeh_else *eh_else_stmt = as_a <geh_else *> (stmt);\n+\tcollect_finally_tree_1 (gimple_eh_else_n_body (eh_else_stmt), region);\n+\tcollect_finally_tree_1 (gimple_eh_else_e_body (eh_else_stmt), region);\n+      }\n       break;\n \n     default:\n@@ -377,8 +383,8 @@ struct leh_tf_state\n      try_finally_expr is the original GIMPLE_TRY_FINALLY.  We need to retain\n      this so that outside_finally_tree can reliably reference the tree used\n      in the collect_finally_tree data structures.  */\n-  gimple try_finally_expr;\n-  gimple top_p;\n+  gtry *try_finally_expr;\n+  gtry *top_p;\n \n   /* While lowering a top_p usually it is expanded into multiple statements,\n      thus we need the following field to store them. */\n@@ -418,7 +424,7 @@ struct leh_tf_state\n   bool may_throw;\n };\n \n-static gimple_seq lower_eh_must_not_throw (struct leh_state *, gimple);\n+static gimple_seq lower_eh_must_not_throw (struct leh_state *, gtry *);\n \n /* Search for STMT in the goto queue.  Return the replacement,\n    or null if the statement isn't in the queue.  */\n@@ -532,14 +538,21 @@ replace_goto_queue_1 (gimple stmt, struct leh_tf_state *tf,\n       replace_goto_queue_stmt_list (gimple_try_cleanup_ptr (stmt), tf);\n       break;\n     case GIMPLE_CATCH:\n-      replace_goto_queue_stmt_list (gimple_catch_handler_ptr (stmt), tf);\n+      replace_goto_queue_stmt_list (gimple_catch_handler_ptr (\n+\t\t\t\t      as_a <gcatch *> (stmt)),\n+\t\t\t\t    tf);\n       break;\n     case GIMPLE_EH_FILTER:\n       replace_goto_queue_stmt_list (gimple_eh_filter_failure_ptr (stmt), tf);\n       break;\n     case GIMPLE_EH_ELSE:\n-      replace_goto_queue_stmt_list (gimple_eh_else_n_body_ptr (stmt), tf);\n-      replace_goto_queue_stmt_list (gimple_eh_else_e_body_ptr (stmt), tf);\n+      {\n+\tgeh_else *eh_else_stmt = as_a <geh_else *> (stmt);\n+\treplace_goto_queue_stmt_list (gimple_eh_else_n_body_ptr (eh_else_stmt),\n+\t\t\t\t      tf);\n+\treplace_goto_queue_stmt_list (gimple_eh_else_e_body_ptr (eh_else_stmt),\n+\t\t\t\t      tf);\n+      }\n       break;\n \n     default:\n@@ -671,12 +684,17 @@ maybe_record_in_goto_queue (struct leh_state *state, gimple stmt)\n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_COND:\n-      new_stmt.tp = gimple_op_ptr (stmt, 2);\n-      record_in_goto_queue_label (tf, new_stmt, gimple_cond_true_label (stmt),\n-\t\t\t\t  EXPR_LOCATION (*new_stmt.tp));\n-      new_stmt.tp = gimple_op_ptr (stmt, 3);\n-      record_in_goto_queue_label (tf, new_stmt, gimple_cond_false_label (stmt),\n-\t\t\t\t  EXPR_LOCATION (*new_stmt.tp));\n+      {\n+\tgcond *cond_stmt = as_a <gcond *> (stmt);\n+\tnew_stmt.tp = gimple_op_ptr (cond_stmt, 2);\n+\trecord_in_goto_queue_label (tf, new_stmt,\n+\t\t\t\t    gimple_cond_true_label (cond_stmt),\n+\t\t\t\t    EXPR_LOCATION (*new_stmt.tp));\n+\tnew_stmt.tp = gimple_op_ptr (cond_stmt, 3);\n+\trecord_in_goto_queue_label (tf, new_stmt,\n+\t\t\t\t    gimple_cond_false_label (cond_stmt),\n+\t\t\t\t    EXPR_LOCATION (*new_stmt.tp));\n+      }\n       break;\n     case GIMPLE_GOTO:\n       new_stmt.g = stmt;\n@@ -702,7 +720,8 @@ maybe_record_in_goto_queue (struct leh_state *state, gimple stmt)\n    of the labels will leave outer GIMPLE_TRY_FINALLY nodes. Verify this.  */\n \n static void\n-verify_norecord_switch_expr (struct leh_state *state, gimple switch_expr)\n+verify_norecord_switch_expr (struct leh_state *state,\n+\t\t\t     gswitch *switch_expr)\n {\n   struct leh_tf_state *tf = state->tf;\n   size_t i, n;\n@@ -768,7 +787,7 @@ static void\n do_goto_redirection (struct goto_queue_node *q, tree finlab, gimple_seq mod,\n \t\t     struct leh_tf_state *tf)\n {\n-  gimple x;\n+  ggoto *x;\n \n   gcc_assert (q->is_label);\n \n@@ -788,7 +807,7 @@ static void\n emit_post_landing_pad (gimple_seq *seq, eh_region region)\n {\n   eh_landing_pad lp = region->landing_pads;\n-  gimple x;\n+  glabel *x;\n \n   if (lp == NULL)\n     lp = gen_eh_landing_pad (region);\n@@ -805,7 +824,7 @@ emit_post_landing_pad (gimple_seq *seq, eh_region region)\n static void\n emit_resx (gimple_seq *seq, eh_region region)\n {\n-  gimple x = gimple_build_resx (region->index);\n+  gresx *x = gimple_build_resx (region->index);\n   gimple_seq_add_stmt (seq, x);\n   if (region->outer)\n     record_stmt_eh_region (region->outer, x);\n@@ -816,7 +835,7 @@ emit_resx (gimple_seq *seq, eh_region region)\n static void\n emit_eh_dispatch (gimple_seq *seq, eh_region region)\n {\n-  gimple x = gimple_build_eh_dispatch (region->index);\n+  geh_dispatch *x = gimple_build_eh_dispatch (region->index);\n   gimple_seq_add_stmt (seq, x);\n }\n \n@@ -861,7 +880,7 @@ eh_region_may_contain_throw (eh_region r)\n    an existing label that should be put at the exit, or NULL.  */\n \n static gimple_seq\n-frob_into_branch_around (gimple tp, eh_region region, tree over)\n+frob_into_branch_around (gtry *tp, eh_region region, tree over)\n {\n   gimple x;\n   gimple_seq cleanup, result;\n@@ -898,7 +917,7 @@ static gimple_seq\n lower_try_finally_dup_block (gimple_seq seq, struct leh_state *outer_state,\n \t\t\t     location_t loc)\n {\n-  gimple region = NULL;\n+  gtry *region = NULL;\n   gimple_seq new_seq;\n   gimple_stmt_iterator gsi;\n \n@@ -948,14 +967,14 @@ lower_try_finally_fallthru_label (struct leh_tf_state *tf)\n /* A subroutine of lower_try_finally.  If FINALLY consits of a\n    GIMPLE_EH_ELSE node, return it.  */\n \n-static inline gimple\n+static inline geh_else *\n get_eh_else (gimple_seq finally)\n {\n   gimple x = gimple_seq_first_stmt (finally);\n   if (gimple_code (x) == GIMPLE_EH_ELSE)\n     {\n       gcc_assert (gimple_seq_singleton_p (finally));\n-      return x;\n+      return as_a <geh_else *> (x);\n     }\n   return NULL;\n }\n@@ -989,7 +1008,10 @@ honor_protect_cleanup_actions (struct leh_state *outer_state,\n   gimple_stmt_iterator gsi;\n   bool finally_may_fallthru;\n   gimple_seq finally;\n-  gimple x, eh_else;\n+  gimple x;\n+  geh_mnt *eh_mnt;\n+  gtry *try_stmt;\n+  geh_else *eh_else;\n \n   /* First check for nothing to do.  */\n   if (lang_hooks.eh_protect_cleanup_actions == NULL)\n@@ -1031,10 +1053,10 @@ honor_protect_cleanup_actions (struct leh_state *outer_state,\n     }\n \n   /* Wrap the block with protect_cleanup_actions as the action.  */\n-  x = gimple_build_eh_must_not_throw (protect_cleanup_actions);\n-  x = gimple_build_try (finally, gimple_seq_alloc_with_stmt (x),\n-\t\t\tGIMPLE_TRY_CATCH);\n-  finally = lower_eh_must_not_throw (outer_state, x);\n+  eh_mnt = gimple_build_eh_must_not_throw (protect_cleanup_actions);\n+  try_stmt = gimple_build_try (finally, gimple_seq_alloc_with_stmt (eh_mnt),\n+\t\t\t       GIMPLE_TRY_CATCH);\n+  finally = lower_eh_must_not_throw (outer_state, try_stmt);\n \n   /* Drop all of this into the exception sequence.  */\n   emit_post_landing_pad (&eh_seq, tf->region);\n@@ -1057,7 +1079,8 @@ lower_try_finally_nofallthru (struct leh_state *state,\n \t\t\t      struct leh_tf_state *tf)\n {\n   tree lab;\n-  gimple x, eh_else;\n+  gimple x;\n+  geh_else *eh_else;\n   gimple_seq finally;\n   struct goto_queue_node *q, *qe;\n \n@@ -1121,6 +1144,8 @@ static void\n lower_try_finally_onedest (struct leh_state *state, struct leh_tf_state *tf)\n {\n   struct goto_queue_node *q, *qe;\n+  geh_else *eh_else;\n+  glabel *label_stmt;\n   gimple x;\n   gimple_seq finally;\n   gimple_stmt_iterator gsi;\n@@ -1133,13 +1158,13 @@ lower_try_finally_onedest (struct leh_state *state, struct leh_tf_state *tf)\n   /* Since there's only one destination, and the destination edge can only\n      either be EH or non-EH, that implies that all of our incoming edges\n      are of the same type.  Therefore we can lower EH_ELSE immediately.  */\n-  x = get_eh_else (finally);\n-  if (x)\n+  eh_else = get_eh_else (finally);\n+  if (eh_else)\n     {\n       if (tf->may_throw)\n-\tfinally = gimple_eh_else_e_body (x);\n+\tfinally = gimple_eh_else_e_body (eh_else);\n       else\n-\tfinally = gimple_eh_else_n_body (x);\n+\tfinally = gimple_eh_else_n_body (eh_else);\n     }\n \n   lower_eh_constructs_1 (state, &finally);\n@@ -1174,8 +1199,8 @@ lower_try_finally_onedest (struct leh_state *state, struct leh_tf_state *tf)\n     }\n \n   finally_label = create_artificial_label (loc);\n-  x = gimple_build_label (finally_label);\n-  gimple_seq_add_stmt (&tf->top_p_seq, x);\n+  label_stmt = gimple_build_label (finally_label);\n+  gimple_seq_add_stmt (&tf->top_p_seq, label_stmt);\n \n   gimple_seq_add_seq (&tf->top_p_seq, finally);\n \n@@ -1223,7 +1248,8 @@ lower_try_finally_copy (struct leh_state *state, struct leh_tf_state *tf)\n   gimple_seq finally;\n   gimple_seq new_stmt;\n   gimple_seq seq;\n-  gimple x, eh_else;\n+  gimple x;\n+  geh_else *eh_else;\n   tree tmp;\n   location_t tf_loc = gimple_location (tf->try_finally_expr);\n \n@@ -1356,7 +1382,8 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n   tree last_case;\n   vec<tree> case_label_vec;\n   gimple_seq switch_body = NULL;\n-  gimple x, eh_else;\n+  gimple x;\n+  geh_else *eh_else;\n   tree tmp;\n   gimple switch_stmt;\n   gimple_seq finally;\n@@ -1568,7 +1595,7 @@ static bool\n decide_copy_try_finally (int ndests, bool may_throw, gimple_seq finally)\n {\n   int f_estimate, sw_estimate;\n-  gimple eh_else;\n+  geh_else *eh_else;\n \n   /* If there's an EH_ELSE involved, the exception path is separate\n      and really doesn't come into play for this computation.  */\n@@ -1634,7 +1661,7 @@ cleanup_is_dead_in (eh_region reg)\n    arrange for the FINALLY block to be executed on all exits.  */\n \n static gimple_seq\n-lower_try_finally (struct leh_state *state, gimple tp)\n+lower_try_finally (struct leh_state *state, gtry *tp)\n {\n   struct leh_tf_state this_tf;\n   struct leh_state this_state;\n@@ -1741,7 +1768,7 @@ lower_try_finally (struct leh_state *state, gimple tp)\n    exception region trees that records all the magic.  */\n \n static gimple_seq\n-lower_catch (struct leh_state *state, gimple tp)\n+lower_catch (struct leh_state *state, gtry *tp)\n {\n   eh_region try_region = NULL;\n   struct leh_state this_state = *state;\n@@ -1776,13 +1803,13 @@ lower_catch (struct leh_state *state, gimple tp)\n        gsi_next (&gsi))\n     {\n       eh_catch c;\n-      gimple gcatch;\n+      gcatch *catch_stmt;\n       gimple_seq handler;\n \n-      gcatch = gsi_stmt (gsi);\n-      c = gen_eh_region_catch (try_region, gimple_catch_types (gcatch));\n+      catch_stmt = as_a <gcatch *> (gsi_stmt (gsi));\n+      c = gen_eh_region_catch (try_region, gimple_catch_types (catch_stmt));\n \n-      handler = gimple_catch_handler (gcatch);\n+      handler = gimple_catch_handler (catch_stmt);\n       lower_eh_constructs_1 (&this_state, &handler);\n \n       c->label = create_artificial_label (UNKNOWN_LOCATION);\n@@ -1813,7 +1840,7 @@ lower_catch (struct leh_state *state, gimple tp)\n    region trees that record all the magic.  */\n \n static gimple_seq\n-lower_eh_filter (struct leh_state *state, gimple tp)\n+lower_eh_filter (struct leh_state *state, gtry *tp)\n {\n   struct leh_state this_state = *state;\n   eh_region this_region = NULL;\n@@ -1858,7 +1885,7 @@ lower_eh_filter (struct leh_state *state, gimple tp)\n    plus the exception region trees that record all the magic.  */\n \n static gimple_seq\n-lower_eh_must_not_throw (struct leh_state *state, gimple tp)\n+lower_eh_must_not_throw (struct leh_state *state, gtry *tp)\n {\n   struct leh_state this_state = *state;\n \n@@ -1869,7 +1896,8 @@ lower_eh_must_not_throw (struct leh_state *state, gimple tp)\n \n       this_region = gen_eh_region_must_not_throw (state->cur_region);\n       this_region->u.must_not_throw.failure_decl\n-\t= gimple_eh_must_not_throw_fndecl (inner);\n+\t= gimple_eh_must_not_throw_fndecl (\n+\t    as_a <geh_mnt *> (inner));\n       this_region->u.must_not_throw.failure_loc\n \t= LOCATION_LOCUS (gimple_location (tp));\n \n@@ -1890,7 +1918,7 @@ lower_eh_must_not_throw (struct leh_state *state, gimple tp)\n    except that we only execute the cleanup block for exception edges.  */\n \n static gimple_seq\n-lower_cleanup (struct leh_state *state, gimple tp)\n+lower_cleanup (struct leh_state *state, gtry *tp)\n {\n   struct leh_state this_state = *state;\n   eh_region this_region = NULL;\n@@ -2041,40 +2069,43 @@ lower_eh_constructs_2 (struct leh_state *state, gimple_stmt_iterator *gsi)\n       break;\n \n     case GIMPLE_SWITCH:\n-      verify_norecord_switch_expr (state, stmt);\n+      verify_norecord_switch_expr (state, as_a <gswitch *> (stmt));\n       break;\n \n     case GIMPLE_TRY:\n-      if (gimple_try_kind (stmt) == GIMPLE_TRY_FINALLY)\n-\treplace = lower_try_finally (state, stmt);\n-      else\n-\t{\n-\t  x = gimple_seq_first_stmt (gimple_try_cleanup (stmt));\n-\t  if (!x)\n-\t    {\n-\t      replace = gimple_try_eval (stmt);\n-\t      lower_eh_constructs_1 (state, &replace);\n-\t    }\n-\t  else\n-\t    switch (gimple_code (x))\n+      {\n+\tgtry *try_stmt = as_a <gtry *> (stmt);\n+\tif (gimple_try_kind (try_stmt) == GIMPLE_TRY_FINALLY)\n+\t  replace = lower_try_finally (state, try_stmt);\n+\telse\n+\t  {\n+\t    x = gimple_seq_first_stmt (gimple_try_cleanup (try_stmt));\n+\t    if (!x)\n \t      {\n+\t\treplace = gimple_try_eval (try_stmt);\n+\t\tlower_eh_constructs_1 (state, &replace);\n+\t      }\n+\t    else\n+\t      switch (gimple_code (x))\n+\t\t{\n \t\tcase GIMPLE_CATCH:\n-\t\t    replace = lower_catch (state, stmt);\n-\t\t    break;\n+\t\t  replace = lower_catch (state, try_stmt);\n+\t\t  break;\n \t\tcase GIMPLE_EH_FILTER:\n-\t\t    replace = lower_eh_filter (state, stmt);\n-\t\t    break;\n+\t\t  replace = lower_eh_filter (state, try_stmt);\n+\t\t  break;\n \t\tcase GIMPLE_EH_MUST_NOT_THROW:\n-\t\t    replace = lower_eh_must_not_throw (state, stmt);\n-\t\t    break;\n+\t\t  replace = lower_eh_must_not_throw (state, try_stmt);\n+\t\t  break;\n \t\tcase GIMPLE_EH_ELSE:\n-\t\t    /* This code is only valid with GIMPLE_TRY_FINALLY.  */\n-\t\t    gcc_unreachable ();\n+\t\t  /* This code is only valid with GIMPLE_TRY_FINALLY.  */\n+\t\t  gcc_unreachable ();\n \t\tdefault:\n-\t\t    replace = lower_cleanup (state, stmt);\n-\t\t    break;\n-\t      }\n-\t}\n+\t\t  replace = lower_cleanup (state, try_stmt);\n+\t\t  break;\n+\t\t}\n+\t  }\n+      }\n \n       /* Remove the old stmt and insert the transformed sequence\n \t instead. */\n@@ -2190,7 +2221,7 @@ make_pass_lower_eh (gcc::context *ctxt)\n    no fallthru edge; false if there is.  */\n \n bool\n-make_eh_dispatch_edges (gimple stmt)\n+make_eh_dispatch_edges (geh_dispatch *stmt)\n {\n   eh_region r;\n   eh_catch c;\n@@ -2348,7 +2379,7 @@ redirect_eh_edge (edge edge_in, basic_block new_bb)\n    The actual edge update will happen in the caller.  */\n \n void\n-redirect_eh_dispatch_edge (gimple stmt, edge e, basic_block new_bb)\n+redirect_eh_dispatch_edge (geh_dispatch *stmt, edge e, basic_block new_bb)\n {\n   tree new_lab = gimple_block_label (new_bb);\n   bool any_changed = false;\n@@ -2763,7 +2794,7 @@ stmt_could_throw_p (gimple stmt)\n       return true;\n \n     case GIMPLE_CALL:\n-      return !gimple_call_nothrow_p (stmt);\n+      return !gimple_call_nothrow_p (as_a <gcall *> (stmt));\n \n     case GIMPLE_ASSIGN:\n     case GIMPLE_COND:\n@@ -2774,7 +2805,7 @@ stmt_could_throw_p (gimple stmt)\n     case GIMPLE_ASM:\n       if (!cfun->can_throw_non_call_exceptions)\n         return false;\n-      return gimple_asm_volatile_p (stmt);\n+      return gimple_asm_volatile_p (as_a <gasm *> (stmt));\n \n     default:\n       return false;\n@@ -3000,7 +3031,7 @@ same_handler_p (gimple_seq oneh, gimple_seq twoh)\n    temporary used in the initializer for A.  */\n \n static void\n-optimize_double_finally (gimple one, gimple two)\n+optimize_double_finally (gtry *one, gtry *two)\n {\n   gimple oneh;\n   gimple_stmt_iterator gsi;\n@@ -3047,13 +3078,12 @@ refactor_eh_r (gimple_seq seq)\n \ttwo = NULL;\n       else\n \ttwo = gsi_stmt (gsi);\n-      if (one\n-\t  && two\n-\t  && gimple_code (one) == GIMPLE_TRY\n-\t  && gimple_code (two) == GIMPLE_TRY\n-\t  && gimple_try_kind (one) == GIMPLE_TRY_FINALLY\n-\t  && gimple_try_kind (two) == GIMPLE_TRY_FINALLY)\n-\toptimize_double_finally (one, two);\n+      if (one && two)\n+\tif (gtry *try_one = dyn_cast <gtry *> (one))\n+\t  if (gtry *try_two = dyn_cast <gtry *> (two))\n+\t    if (gimple_try_kind (try_one) == GIMPLE_TRY_FINALLY\n+\t\t&& gimple_try_kind (try_two) == GIMPLE_TRY_FINALLY)\n+\t      optimize_double_finally (try_one, try_two);\n       if (one)\n \tswitch (gimple_code (one))\n \t  {\n@@ -3062,14 +3092,17 @@ refactor_eh_r (gimple_seq seq)\n \t    refactor_eh_r (gimple_try_cleanup (one));\n \t    break;\n \t  case GIMPLE_CATCH:\n-\t    refactor_eh_r (gimple_catch_handler (one));\n+\t    refactor_eh_r (gimple_catch_handler (as_a <gcatch *> (one)));\n \t    break;\n \t  case GIMPLE_EH_FILTER:\n \t    refactor_eh_r (gimple_eh_filter_failure (one));\n \t    break;\n \t  case GIMPLE_EH_ELSE:\n-\t    refactor_eh_r (gimple_eh_else_n_body (one));\n-\t    refactor_eh_r (gimple_eh_else_e_body (one));\n+\t    {\n+\t      geh_else *eh_else_stmt = as_a <geh_else *> (one);\n+\t      refactor_eh_r (gimple_eh_else_n_body (eh_else_stmt));\n+\t      refactor_eh_r (gimple_eh_else_e_body (eh_else_stmt));\n+\t    }\n \t    break;\n \t  default:\n \t    break;\n@@ -3124,7 +3157,8 @@ make_pass_refactor_eh (gcc::context *ctxt)\n /* At the end of gimple optimization, we can lower RESX.  */\n \n static bool\n-lower_resx (basic_block bb, gimple stmt, hash_map<eh_region, tree> *mnt_map)\n+lower_resx (basic_block bb, gresx *stmt,\n+\t    hash_map<eh_region, tree> *mnt_map)\n {\n   int lp_nr;\n   eh_region src_r, dst_r;\n@@ -3312,7 +3346,8 @@ pass_lower_resx::execute (function *fun)\n       gimple last = last_stmt (bb);\n       if (last && is_gimple_resx (last))\n \t{\n-\t  dominance_invalidated |= lower_resx (bb, last, &mnt_map);\n+\t  dominance_invalidated |=\n+\t    lower_resx (bb, as_a <gresx *> (last), &mnt_map);\n \t  any_rewritten = true;\n \t}\n     }\n@@ -3436,14 +3471,15 @@ sink_clobbers (basic_block bb)\n \n   /* See if there is a virtual PHI node to take an updated virtual\n      operand from.  */\n-  gimple vphi = NULL;\n+  gphi *vphi = NULL;\n   tree vuse = NULL_TREE;\n-  for (gsi = gsi_start_phis (succbb); !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gphi_iterator gpi = gsi_start_phis (succbb);\n+       !gsi_end_p (gpi); gsi_next (&gpi))\n     {\n-      tree res = gimple_phi_result (gsi_stmt (gsi));\n+      tree res = gimple_phi_result (gpi.phi ());\n       if (virtual_operand_p (res))\n \t{\n-\t  vphi = gsi_stmt (gsi);\n+\t  vphi = gpi.phi ();\n \t  vuse = res;\n \t  break;\n \t}\n@@ -3521,7 +3557,7 @@ sink_clobbers (basic_block bb)\n    we have found some duplicate labels and removed some edges.  */\n \n static bool\n-lower_eh_dispatch (basic_block src, gimple stmt)\n+lower_eh_dispatch (basic_block src, geh_dispatch *stmt)\n {\n   gimple_stmt_iterator gsi;\n   int region_nr;\n@@ -3709,7 +3745,8 @@ pass_lower_eh_dispatch::execute (function *fun)\n \tcontinue;\n       if (gimple_code (last) == GIMPLE_EH_DISPATCH)\n \t{\n-\t  redirected |= lower_eh_dispatch (bb, last);\n+\t  redirected |= lower_eh_dispatch (bb,\n+\t\t\t\t\t   as_a <geh_dispatch *> (last));\n \t  flags |= TODO_update_ssa_only_virtuals;\n \t}\n       else if (gimple_code (last) == GIMPLE_RESX)\n@@ -3797,10 +3834,13 @@ mark_reachable_handlers (sbitmap *r_reachablep, sbitmap *lp_reachablep)\n \t  switch (gimple_code (stmt))\n \t    {\n \t    case GIMPLE_RESX:\n-\t      bitmap_set_bit (r_reachable, gimple_resx_region (stmt));\n+\t      bitmap_set_bit (r_reachable,\n+\t\t\t      gimple_resx_region (as_a <gresx *> (stmt)));\n \t      break;\n \t    case GIMPLE_EH_DISPATCH:\n-\t      bitmap_set_bit (r_reachable, gimple_eh_dispatch_region (stmt));\n+\t      bitmap_set_bit (r_reachable,\n+\t\t\t      gimple_eh_dispatch_region (\n+                                as_a <geh_dispatch *> (stmt)));\n \t      break;\n \t    default:\n \t      break;\n@@ -3971,13 +4011,13 @@ unsplit_eh (eh_landing_pad lp)\n      for a different region.  */\n   for (gsi = gsi_start_bb (e_out->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      glabel *label_stmt = dyn_cast <glabel *> (gsi_stmt (gsi));\n       tree lab;\n       int lp_nr;\n \n-      if (gimple_code (stmt) != GIMPLE_LABEL)\n+      if (!label_stmt)\n \tbreak;\n-      lab = gimple_label_label (stmt);\n+      lab = gimple_label_label (label_stmt);\n       lp_nr = EH_LANDING_PAD_NR (lab);\n       if (lp_nr && get_eh_region_from_lp_number (lp_nr) != lp->region)\n \treturn false;\n@@ -3994,9 +4034,10 @@ unsplit_eh (eh_landing_pad lp)\n      that doesn't appear to handle virtuals.  Propagate by hand.  */\n   if (!gimple_seq_empty_p (phi_nodes (bb)))\n     {\n-      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); )\n+      for (gphi_iterator gpi = gsi_start_phis (bb); !gsi_end_p (gpi); )\n \t{\n-\t  gimple use_stmt, phi = gsi_stmt (gsi);\n+\t  gimple use_stmt;\n+\t  gphi *phi = gpi.phi ();\n \t  tree lhs = gimple_phi_result (phi);\n \t  tree rhs = gimple_phi_arg_def (phi, 0);\n \t  use_operand_p use_p;\n@@ -4011,7 +4052,7 @@ unsplit_eh (eh_landing_pad lp)\n \t  if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))\n \t    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs) = 1;\n \n-\t  remove_phi_node (&gsi, true);\n+\t  remove_phi_node (&gpi, true);\n \t}\n     }\n \n@@ -4060,7 +4101,7 @@ static bool\n cleanup_empty_eh_merge_phis (basic_block new_bb, basic_block old_bb,\n \t\t\t     edge old_bb_out, bool change_region)\n {\n-  gimple_stmt_iterator ngsi, ogsi;\n+  gphi_iterator ngsi, ogsi;\n   edge_iterator ei;\n   edge e;\n   bitmap ophi_handled;\n@@ -4090,7 +4131,7 @@ cleanup_empty_eh_merge_phis (basic_block new_bb, basic_block old_bb,\n      for the edges we're going to move.  */\n   for (ngsi = gsi_start_phis (new_bb); !gsi_end_p (ngsi); gsi_next (&ngsi))\n     {\n-      gimple ophi, nphi = gsi_stmt (ngsi);\n+      gphi *ophi, *nphi = ngsi.phi ();\n       tree nresult, nop;\n \n       nresult = gimple_phi_result (nphi);\n@@ -4101,7 +4142,7 @@ cleanup_empty_eh_merge_phis (basic_block new_bb, basic_block old_bb,\n       ophi = NULL;\n       for (ogsi = gsi_start_phis (old_bb); !gsi_end_p (ogsi); gsi_next (&ogsi))\n \t{\n-\t  ophi = gsi_stmt (ogsi);\n+\t  ophi = ogsi.phi ();\n \t  if (gimple_phi_result (ophi) == nop)\n \t    break;\n \t  ophi = NULL;\n@@ -4154,7 +4195,7 @@ cleanup_empty_eh_merge_phis (basic_block new_bb, basic_block old_bb,\n      we don't know what values from the other edges into NEW_BB to use.  */\n   for (ogsi = gsi_start_phis (old_bb); !gsi_end_p (ogsi); gsi_next (&ogsi))\n     {\n-      gimple ophi = gsi_stmt (ogsi);\n+      gphi *ophi = ogsi.phi ();\n       tree oresult = gimple_phi_result (ophi);\n       if (!bitmap_bit_p (ophi_handled, SSA_NAME_VERSION (oresult)))\n \tgoto fail;\n@@ -4242,10 +4283,10 @@ cleanup_empty_eh_unsplit (basic_block bb, edge e_out, eh_landing_pad lp)\n   lab = NULL;\n   for (gsi = gsi_start_bb (e_out->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      glabel *stmt = dyn_cast <glabel *> (gsi_stmt (gsi));\n       int lp_nr;\n \n-      if (gimple_code (stmt) != GIMPLE_LABEL)\n+      if (!stmt)\n \tbreak;\n       lab = gimple_label_label (stmt);\n       lp_nr = EH_LANDING_PAD_NR (lab);\n@@ -4642,7 +4683,7 @@ verify_eh_edges (gimple stmt)\n /* Similarly, but handle GIMPLE_EH_DISPATCH specifically.  */\n \n DEBUG_FUNCTION bool\n-verify_eh_dispatch_edge (gimple stmt)\n+verify_eh_dispatch_edge (geh_dispatch *stmt)\n {\n   eh_region r;\n   eh_catch c;"}, {"sha": "0923c57f736c2419b4ee1669d58ed9f77899efa1", "filename": "gcc/tree-eh.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-eh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-eh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -30,10 +30,10 @@ extern bool remove_stmt_from_eh_lp_fn (struct function *, gimple);\n extern bool remove_stmt_from_eh_lp (gimple);\n extern int lookup_stmt_eh_lp_fn (struct function *, gimple);\n extern int lookup_stmt_eh_lp (gimple);\n-extern bool make_eh_dispatch_edges (gimple);\n+extern bool make_eh_dispatch_edges (geh_dispatch *);\n extern void make_eh_edges (gimple);\n extern edge redirect_eh_edge (edge, basic_block);\n-extern void redirect_eh_dispatch_edge (gimple, edge, basic_block);\n+extern void redirect_eh_dispatch_edge (geh_dispatch *, edge, basic_block);\n extern bool operation_could_trap_helper_p (enum tree_code, bool, bool, bool,\n \t\t\t\t\t   bool, tree, bool *);\n extern bool operation_could_trap_p (enum tree_code, bool, bool, tree);\n@@ -51,6 +51,6 @@ extern bool maybe_duplicate_eh_stmt_fn (struct function *, gimple,\n extern bool maybe_duplicate_eh_stmt (gimple, gimple);\n extern void maybe_remove_unreachable_handlers (void);\n extern bool verify_eh_edges (gimple);\n-extern bool verify_eh_dispatch_edge (gimple);\n+extern bool verify_eh_dispatch_edge (geh_dispatch *);\n \n #endif /* GCC_TREE_EH_H */"}, {"sha": "3f71d7d1707952deaf96c13c613011252171f47b", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -419,7 +419,7 @@ gen_emutls_addr (tree decl, struct lower_emutls_data *d)\n     {\n       varpool_node *cvar;\n       tree cdecl;\n-      gimple x;\n+      gcall *x;\n \n       cvar = data->control_var;\n       cdecl = cvar->decl;\n@@ -569,7 +569,8 @@ lower_emutls_stmt (gimple stmt, struct lower_emutls_data *d)\n /* Lower the I'th operand of PHI.  */\n \n static void\n-lower_emutls_phi_arg (gimple phi, unsigned int i, struct lower_emutls_data *d)\n+lower_emutls_phi_arg (gphi *phi, unsigned int i,\n+\t\t      struct lower_emutls_data *d)\n {\n   struct walk_stmt_info wi;\n   struct phi_arg_d *pd = gimple_phi_arg (phi, i);\n@@ -630,7 +631,6 @@ lower_emutls_function_body (struct cgraph_node *node)\n \n   FOR_EACH_BB_FN (d.bb, cfun)\n     {\n-      gimple_stmt_iterator gsi;\n       unsigned int i, nedge;\n \n       /* Lower each of the PHI nodes of the block, as we may have \n@@ -652,10 +652,10 @@ lower_emutls_function_body (struct cgraph_node *node)\n \t      clear_access_vars ();\n \t      d.seq = NULL;\n \n-\t      for (gsi = gsi_start_phis (d.bb);\n+\t      for (gphi_iterator gsi = gsi_start_phis (d.bb);\n \t\t   !gsi_end_p (gsi);\n \t\t   gsi_next (&gsi))\n-\t\tlower_emutls_phi_arg (gsi_stmt (gsi), i, &d);\n+\t\tlower_emutls_phi_arg (gsi.phi (), i, &d);\n \n \t      /* Insert all statements generated by all phi nodes for this\n \t\t particular edge all at once.  */\n@@ -673,7 +673,8 @@ lower_emutls_function_body (struct cgraph_node *node)\n       clear_access_vars ();\n \n       /* Lower each of the statements of the block.  */\n-      for (gsi = gsi_start_bb (d.bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (d.bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n \t{\n           d.seq = NULL;\n \t  lower_emutls_stmt (gsi_stmt (gsi), &d);"}, {"sha": "7c3954771e1b9bde48240088a1478eff7a97ab29", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -515,7 +515,7 @@ bb_with_exit_edge_p (struct loop *loop, basic_block bb)\n    - there is a virtual PHI in a BB other than the loop->header.  */\n \n static bool\n-if_convertible_phi_p (struct loop *loop, basic_block bb, gimple phi,\n+if_convertible_phi_p (struct loop *loop, basic_block bb, gphi *phi,\n \t\t      bool any_mask_load_store)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1282,10 +1282,10 @@ if_convertible_loop_p_1 (struct loop *loop,\n   for (i = 0; i < loop->num_nodes; i++)\n     {\n       basic_block bb = ifc_bbs[i];\n-      gimple_stmt_iterator itr;\n+      gphi_iterator itr;\n \n       for (itr = gsi_start_phis (bb); !gsi_end_p (itr); gsi_next (&itr))\n-\tif (!if_convertible_phi_p (loop, bb, gsi_stmt (itr),\n+\tif (!if_convertible_phi_p (loop, bb, itr.phi (),\n \t\t\t\t   *any_mask_load_store))\n \t  return false;\n     }\n@@ -1592,7 +1592,7 @@ convert_scalar_cond_reduction (gimple reduc, gimple_stmt_iterator *gsi,\n    TRUE_BB is selected.  */\n \n static void\n-predicate_scalar_phi (gimple phi, tree cond,\n+predicate_scalar_phi (gphi *phi, tree cond,\n \t\t      basic_block true_bb,\n \t\t      gimple_stmt_iterator *gsi)\n {\n@@ -1667,9 +1667,10 @@ predicate_all_scalar_phis (struct loop *loop)\n \n   for (i = 1; i < orig_loop_num_nodes; i++)\n     {\n-      gimple phi;\n+      gphi *phi;\n       tree cond = NULL_TREE;\n-      gimple_stmt_iterator gsi, phi_gsi;\n+      gimple_stmt_iterator gsi;\n+      gphi_iterator phi_gsi;\n       basic_block true_bb = NULL;\n       bb = ifc_bbs[i];\n \n@@ -1687,7 +1688,7 @@ predicate_all_scalar_phis (struct loop *loop)\n \n       while (!gsi_end_p (phi_gsi))\n \t{\n-\t  phi = gsi_stmt (phi_gsi);\n+\t  phi = phi_gsi.phi ();\n \t  predicate_scalar_phi (phi, cond, true_bb, &gsi);\n \t  release_phi_node (phi);\n \t  gsi_next (&phi_gsi);"}, {"sha": "835edd12cf3f099dcf51eff5bbf3d2189f501651", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 139, "deletions": 105, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -808,7 +808,7 @@ remap_gimple_seq (gimple_seq body, copy_body_data *id)\n    block using the mapping information in ID.  */\n \n static gimple\n-copy_gimple_bind (gimple stmt, copy_body_data *id)\n+copy_gimple_bind (gbind *stmt, copy_body_data *id)\n {\n   gimple new_bind;\n   tree new_block, new_vars;\n@@ -1319,7 +1319,7 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n      statement.  */\n   if (gimple_code (stmt) == GIMPLE_RETURN && id->transform_return_to_modify)\n     {\n-      tree retval = gimple_return_retval (stmt);\n+      tree retval = gimple_return_retval (as_a <greturn *> (stmt));\n       tree retbnd = gimple_return_retbnd (stmt);\n       tree bndslot = id->retbnd;\n \n@@ -1371,12 +1371,15 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n       switch (gimple_code (stmt))\n \t{\n \tcase GIMPLE_BIND:\n-\t  copy = copy_gimple_bind (stmt, id);\n+\t  copy = copy_gimple_bind (as_a <gbind *> (stmt), id);\n \t  break;\n \n \tcase GIMPLE_CATCH:\n-\t  s1 = remap_gimple_seq (gimple_catch_handler (stmt), id);\n-\t  copy = gimple_build_catch (gimple_catch_types (stmt), s1);\n+\t  {\n+\t    gcatch *catch_stmt = as_a <gcatch *> (stmt);\n+\t    s1 = remap_gimple_seq (gimple_catch_handler (catch_stmt), id);\n+\t    copy = gimple_build_catch (gimple_catch_types (catch_stmt), s1);\n+\t  }\n \t  break;\n \n \tcase GIMPLE_EH_FILTER:\n@@ -1396,12 +1399,15 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n \t  break;\n \n \tcase GIMPLE_OMP_PARALLEL:\n-\t  s1 = remap_gimple_seq (gimple_omp_body (stmt), id);\n-\t  copy = gimple_build_omp_parallel\n-\t           (s1,\n-\t\t    gimple_omp_parallel_clauses (stmt),\n-\t\t    gimple_omp_parallel_child_fn (stmt),\n-\t\t    gimple_omp_parallel_data_arg (stmt));\n+\t  {\n+\t    gomp_parallel *omp_par_stmt = as_a <gomp_parallel *> (stmt);\n+\t    s1 = remap_gimple_seq (gimple_omp_body (omp_par_stmt), id);\n+\t    copy = gimple_build_omp_parallel\n+\t             (s1,\n+\t\t      gimple_omp_parallel_clauses (omp_par_stmt),\n+\t\t      gimple_omp_parallel_child_fn (omp_par_stmt),\n+\t\t      gimple_omp_parallel_data_arg (omp_par_stmt));\n+\t  }\n \t  break;\n \n \tcase GIMPLE_OMP_TASK:\n@@ -1487,14 +1493,25 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n \n \tcase GIMPLE_OMP_CRITICAL:\n \t  s1 = remap_gimple_seq (gimple_omp_body (stmt), id);\n-\t  copy\n-\t    = gimple_build_omp_critical (s1, gimple_omp_critical_name (stmt));\n+\t  copy = gimple_build_omp_critical (s1,\n+\t\t\t\t\t    gimple_omp_critical_name (\n+\t\t\t\t\t      as_a <gomp_critical *> (stmt)));\n \t  break;\n \n \tcase GIMPLE_TRANSACTION:\n-\t  s1 = remap_gimple_seq (gimple_transaction_body (stmt), id);\n-\t  copy = gimple_build_transaction (s1, gimple_transaction_label (stmt));\n-\t  gimple_transaction_set_subcode (copy, gimple_transaction_subcode (stmt));\n+\t  {\n+\t    gtransaction *old_trans_stmt = as_a <gtransaction *> (stmt);\n+\t    gtransaction *new_trans_stmt;\n+\t    s1 = remap_gimple_seq (gimple_transaction_body (old_trans_stmt),\n+\t\t\t\t   id);\n+\t    copy = new_trans_stmt\n+\t      = gimple_build_transaction (\n+\t\t  s1,\n+\t\t  gimple_transaction_label (old_trans_stmt));\n+\t    gimple_transaction_set_subcode (\n+              new_trans_stmt,\n+\t      gimple_transaction_subcode (old_trans_stmt));\n+\t  }\n \t  break;\n \n \tdefault:\n@@ -1546,18 +1563,20 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n \n       if (gimple_debug_bind_p (stmt))\n \t{\n-\t  copy = gimple_build_debug_bind (gimple_debug_bind_get_var (stmt),\n-\t\t\t\t\t  gimple_debug_bind_get_value (stmt),\n-\t\t\t\t\t  stmt);\n+\t  gdebug *copy\n+\t    = gimple_build_debug_bind (gimple_debug_bind_get_var (stmt),\n+\t\t\t\t       gimple_debug_bind_get_value (stmt),\n+\t\t\t\t       stmt);\n \t  id->debug_stmts.safe_push (copy);\n \t  gimple_seq_add_stmt (&stmts, copy);\n \t  return stmts;\n \t}\n       if (gimple_debug_source_bind_p (stmt))\n \t{\n-\t  copy = gimple_build_debug_source_bind\n-\t\t   (gimple_debug_source_bind_get_var (stmt),\n-\t\t    gimple_debug_source_bind_get_value (stmt), stmt);\n+\t  gdebug *copy = gimple_build_debug_source_bind\n+\t                   (gimple_debug_source_bind_get_var (stmt),\n+\t\t\t    gimple_debug_source_bind_get_value (stmt),\n+\t\t\t    stmt);\n \t  id->debug_stmts.safe_push (copy);\n \t  gimple_seq_add_stmt (&stmts, copy);\n \t  return stmts;\n@@ -1567,9 +1586,9 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n       copy = gimple_copy (stmt);\n \n       /* Clear flags that need revisiting.  */\n-      if (is_gimple_call (copy)\n-\t  && gimple_call_tail_p (copy))\n-\tgimple_call_set_tail (copy, false);\n+      if (gcall *call_stmt = dyn_cast <gcall *> (copy))\n+\tif (gimple_call_tail_p (call_stmt))\n+\t  gimple_call_set_tail (call_stmt, false);\n \n       /* Remap the region numbers for __builtin_eh_{pointer,filter},\n \t RESX and EH_DISPATCH.  */\n@@ -1603,23 +1622,25 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n \t\t keep it valid over inlining by setting DECL_PT_UID.  */\n \t      if (!id->src_cfun->gimple_df\n \t\t  || !id->src_cfun->gimple_df->ipa_pta)\n-\t\tgimple_call_reset_alias_info (copy);\n+\t\tgimple_call_reset_alias_info (as_a <gcall *> (copy));\n \t    }\n \t    break;\n \n \t  case GIMPLE_RESX:\n \t    {\n-\t      int r = gimple_resx_region (copy);\n+\t      gresx *resx_stmt = as_a <gresx *> (copy);\n+\t      int r = gimple_resx_region (resx_stmt);\n \t      r = remap_eh_region_nr (r, id);\n-\t      gimple_resx_set_region (copy, r);\n+\t      gimple_resx_set_region (resx_stmt, r);\n \t    }\n \t    break;\n \n \t  case GIMPLE_EH_DISPATCH:\n \t    {\n-\t      int r = gimple_eh_dispatch_region (copy);\n+\t      geh_dispatch *eh_dispatch = as_a <geh_dispatch *> (copy);\n+\t      int r = gimple_eh_dispatch_region (eh_dispatch);\n \t      r = remap_eh_region_nr (r, id);\n-\t      gimple_eh_dispatch_set_region (copy, r);\n+\t      gimple_eh_dispatch_set_region (eh_dispatch, r);\n \t    }\n \t    break;\n \n@@ -1769,18 +1790,20 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n       do\n \t{\n \t  tree fn;\n+\t  gcall *call_stmt;\n \n \t  stmt = gsi_stmt (copy_gsi);\n-\t  if (is_gimple_call (stmt)\n-\t      && gimple_call_va_arg_pack_p (stmt)\n-\t      && id->gimple_call)\n+\t  call_stmt = dyn_cast <gcall *> (stmt);\n+\t  if (call_stmt\n+\t      && gimple_call_va_arg_pack_p (call_stmt)\n+\t      && id->call_stmt)\n \t    {\n \t      /* __builtin_va_arg_pack () should be replaced by\n \t\t all arguments corresponding to ... in the caller.  */\n \t      tree p;\n-\t      gimple new_call;\n+\t      gcall *new_call;\n \t      vec<tree> argarray;\n-\t      size_t nargs = gimple_call_num_args (id->gimple_call);\n+\t      size_t nargs = gimple_call_num_args (id->call_stmt);\n \t      size_t n, i, nargs_to_copy;\n \t      bool remove_bounds = false;\n \n@@ -1791,84 +1814,84 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t we handle not instrumented call in instrumented\n \t\t function.  */\n \t      nargs_to_copy = nargs;\n-\t      if (gimple_call_with_bounds_p (id->gimple_call)\n+\t      if (gimple_call_with_bounds_p (id->call_stmt)\n \t\t  && !gimple_call_with_bounds_p (stmt))\n \t\t{\n-\t\t  for (i = gimple_call_num_args (id->gimple_call) - nargs;\n-\t\t       i < gimple_call_num_args (id->gimple_call);\n+\t\t  for (i = gimple_call_num_args (id->call_stmt) - nargs;\n+\t\t       i < gimple_call_num_args (id->call_stmt);\n \t\t       i++)\n-\t\t    if (POINTER_BOUNDS_P (gimple_call_arg (id->gimple_call, i)))\n+\t\t    if (POINTER_BOUNDS_P (gimple_call_arg (id->call_stmt, i)))\n \t\t      nargs_to_copy--;\n \t\t  remove_bounds = true;\n \t\t}\n \n \t      /* Create the new array of arguments.  */\n-\t      n = nargs_to_copy + gimple_call_num_args (stmt);\n+\t      n = nargs_to_copy + gimple_call_num_args (call_stmt);\n \t      argarray.create (n);\n \t      argarray.safe_grow_cleared (n);\n \n \t      /* Copy all the arguments before '...'  */\n \t      memcpy (argarray.address (),\n-\t\t      gimple_call_arg_ptr (stmt, 0),\n-\t\t      gimple_call_num_args (stmt) * sizeof (tree));\n+\t\t      gimple_call_arg_ptr (call_stmt, 0),\n+\t\t      gimple_call_num_args (call_stmt) * sizeof (tree));\n \n \t      if (remove_bounds)\n \t\t{\n \t\t  /* Append the rest of arguments removing bounds.  */\n-\t\t  unsigned cur = gimple_call_num_args (stmt);\n-\t\t  i = gimple_call_num_args (id->gimple_call) - nargs;\n-\t\t  for (i = gimple_call_num_args (id->gimple_call) - nargs;\n-\t\t       i < gimple_call_num_args (id->gimple_call);\n+\t\t  unsigned cur = gimple_call_num_args (call_stmt);\n+\t\t  i = gimple_call_num_args (id->call_stmt) - nargs;\n+\t\t  for (i = gimple_call_num_args (id->call_stmt) - nargs;\n+\t\t       i < gimple_call_num_args (id->call_stmt);\n \t\t       i++)\n-\t\t    if (!POINTER_BOUNDS_P (gimple_call_arg (id->gimple_call, i)))\n-\t\t      argarray[cur++] = gimple_call_arg (id->gimple_call, i);\n+\t\t    if (!POINTER_BOUNDS_P (gimple_call_arg (id->call_stmt, i)))\n+\t\t      argarray[cur++] = gimple_call_arg (id->call_stmt, i);\n \t\t  gcc_assert (cur == n);\n \t\t}\n \t      else\n \t\t{\n \t\t  /* Append the arguments passed in '...'  */\n-\t\t  memcpy (argarray.address () + gimple_call_num_args (stmt),\n-\t\t\t  gimple_call_arg_ptr (id->gimple_call, 0)\n-\t\t\t  + (gimple_call_num_args (id->gimple_call) - nargs),\n+\t\t  memcpy (argarray.address () + gimple_call_num_args (call_stmt),\n+\t\t\t  gimple_call_arg_ptr (id->call_stmt, 0)\n+\t\t\t  + (gimple_call_num_args (id->call_stmt) - nargs),\n \t\t\t  nargs * sizeof (tree));\n \t\t}\n \n-\t      new_call = gimple_build_call_vec (gimple_call_fn (stmt),\n+\t      new_call = gimple_build_call_vec (gimple_call_fn (call_stmt),\n \t\t\t\t\t\targarray);\n \n \t      argarray.release ();\n \n \t      /* Copy all GIMPLE_CALL flags, location and block, except\n \t\t GF_CALL_VA_ARG_PACK.  */\n-\t      gimple_call_copy_flags (new_call, stmt);\n+\t      gimple_call_copy_flags (new_call, call_stmt);\n \t      gimple_call_set_va_arg_pack (new_call, false);\n \t      gimple_set_location (new_call, gimple_location (stmt));\n \t      gimple_set_block (new_call, gimple_block (stmt));\n-\t      gimple_call_set_lhs (new_call, gimple_call_lhs (stmt));\n+\t      gimple_call_set_lhs (new_call, gimple_call_lhs (call_stmt));\n \n \t      gsi_replace (&copy_gsi, new_call, false);\n \t      stmt = new_call;\n \t    }\n \t  else if (is_gimple_call (stmt)\n-\t\t   && id->gimple_call\n+\t\t   && id->call_stmt\n \t\t   && (decl = gimple_call_fndecl (stmt))\n \t\t   && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL\n \t\t   && DECL_FUNCTION_CODE (decl) == BUILT_IN_VA_ARG_PACK_LEN)\n \t    {\n \t      /* __builtin_va_arg_pack_len () should be replaced by\n \t\t the number of anonymous arguments.  */\n-\t      size_t nargs = gimple_call_num_args (id->gimple_call), i;\n+\t      size_t nargs = gimple_call_num_args (id->call_stmt), i;\n \t      tree count, p;\n \t      gimple new_stmt;\n \n \t      for (p = DECL_ARGUMENTS (id->src_fn); p; p = DECL_CHAIN (p))\n \t\tnargs--;\n \n \t      /* For instrumented calls we should ignore bounds.  */\n-\t      for (i = gimple_call_num_args (id->gimple_call) - nargs;\n-\t\t   i < gimple_call_num_args (id->gimple_call);\n+\t      for (i = gimple_call_num_args (id->call_stmt) - nargs;\n+\t\t   i < gimple_call_num_args (id->call_stmt);\n \t\t   i++)\n-\t\tif (POINTER_BOUNDS_P (gimple_call_arg (id->gimple_call, i)))\n+\t\tif (POINTER_BOUNDS_P (gimple_call_arg (id->call_stmt, i)))\n \t\t  nargs--;\n \n \t      count = build_int_cst (integer_type_node, nargs);\n@@ -1893,7 +1916,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \n \t  /* We're duplicating a CALL_EXPR.  Find any corresponding\n \t     callgraph edges and update or duplicate them.  */\n-\t  if (is_gimple_call (stmt))\n+\t  if (gcall *call_stmt = dyn_cast <gcall *> (stmt))\n \t    {\n \t      struct cgraph_edge *edge;\n \n@@ -1906,7 +1929,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t      int edge_freq = edge->frequency;\n \t\t      int new_freq;\n \t\t      struct cgraph_edge *old_edge = edge;\n-\t\t      edge = edge->clone (id->dst_node, stmt,\n+\t\t      edge = edge->clone (id->dst_node, call_stmt,\n \t\t\t\t\t  gimple_uid (stmt),\n \t\t\t\t\t  REG_BR_PROB_BASE, CGRAPH_FREQ_BASE,\n \t\t\t\t\t  true);\n@@ -1925,7 +1948,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \n \t\t\t  gcc_assert (!edge->indirect_unknown_callee);\n \t\t\t  old_edge->speculative_call_info (direct, indirect, ref);\n-\t\t\t  indirect = indirect->clone (id->dst_node, stmt,\n+\t\t\t  indirect = indirect->clone (id->dst_node, call_stmt,\n \t\t\t\t\t\t      gimple_uid (stmt),\n \t\t\t\t\t\t      REG_BR_PROB_BASE, CGRAPH_FREQ_BASE,\n \t\t\t\t\t\t      true);\n@@ -1964,14 +1987,14 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \n \t\tcase CB_CGE_MOVE_CLONES:\n \t\t  id->dst_node->set_call_stmt_including_clones (orig_stmt,\n-\t\t\t\t\t\t\t\tstmt);\n+\t\t\t\t\t\t\t\tcall_stmt);\n \t\t  edge = id->dst_node->get_edge (stmt);\n \t\t  break;\n \n \t\tcase CB_CGE_MOVE:\n \t\t  edge = id->dst_node->get_edge (orig_stmt);\n \t\t  if (edge)\n-\t\t    edge->set_call_stmt (stmt);\n+\t\t    edge->set_call_stmt (call_stmt);\n \t\t  break;\n \n \t\tdefault:\n@@ -2000,12 +2023,12 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t\t      || !id->dst_node->definition);\n \t\t  if (id->transform_call_graph_edges == CB_CGE_MOVE_CLONES)\n \t\t    id->dst_node->create_edge_including_clones\n-\t\t      (dest, orig_stmt, stmt, bb->count,\n+\t\t      (dest, orig_stmt, call_stmt, bb->count,\n \t\t       compute_call_stmt_bb_frequency (id->dst_node->decl,\n \t\t       \t\t\t\t       copy_basic_block),\n \t\t       CIF_ORIGINALLY_INDIRECT_CALL);\n \t\t  else\n-\t\t    id->dst_node->create_edge (dest, stmt,\n+\t\t    id->dst_node->create_edge (dest, call_stmt,\n \t\t\t\t\tbb->count,\n \t\t\t\t\tcompute_call_stmt_bb_frequency\n \t\t\t\t\t  (id->dst_node->decl,\n@@ -2018,7 +2041,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t    }\n \t\t}\n \n-\t      notice_special_calls (stmt);\n+\t      notice_special_calls (as_a <gcall *> (stmt));\n \t    }\n \n \t  maybe_duplicate_eh_stmt_fn (cfun, stmt, id->src_cfun, orig_stmt,\n@@ -2073,8 +2096,8 @@ update_ssa_across_abnormal_edges (basic_block bb, basic_block ret_bb,\n     if (!e->dest->aux\n \t|| ((basic_block)e->dest->aux)->index == ENTRY_BLOCK)\n       {\n-\tgimple phi;\n-\tgimple_stmt_iterator si;\n+\tgphi *phi;\n+\tgphi_iterator si;\n \n \tif (!nonlocal_goto)\n \t  gcc_assert (e->flags & EDGE_EH);\n@@ -2086,7 +2109,7 @@ update_ssa_across_abnormal_edges (basic_block bb, basic_block ret_bb,\n \t  {\n \t    edge re;\n \n-\t    phi = gsi_stmt (si);\n+\t    phi = si.phi ();\n \n \t    /* For abnormal goto/call edges the receiver can be the\n \t       ENTRY_BLOCK.  Do not assert this cannot happen.  */\n@@ -2194,7 +2217,7 @@ copy_edges_for_bb (basic_block bb, gcov_type count_scale, basic_block ret_bb,\n \t}\n \n       if (gimple_code (copy_stmt) == GIMPLE_EH_DISPATCH)\n-\tmake_eh_dispatch_edges (copy_stmt);\n+\tmake_eh_dispatch_edges (as_a <geh_dispatch *> (copy_stmt));\n       else if (can_throw)\n \tmake_eh_edges (copy_stmt);\n \n@@ -2240,17 +2263,17 @@ copy_phis_for_bb (basic_block bb, copy_body_data *id)\n {\n   basic_block const new_bb = (basic_block) bb->aux;\n   edge_iterator ei;\n-  gimple phi;\n-  gimple_stmt_iterator si;\n+  gphi *phi;\n+  gphi_iterator si;\n   edge new_edge;\n   bool inserted = false;\n \n   for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n     {\n       tree res, new_res;\n-      gimple new_phi;\n+      gphi *new_phi;\n \n-      phi = gsi_stmt (si);\n+      phi = si.phi ();\n       res = PHI_RESULT (phi);\n       new_res = res;\n       if (!virtual_operand_p (res))\n@@ -2421,7 +2444,8 @@ maybe_move_debug_stmts_to_successors (copy_body_data *id, basic_block new_bb)\n       gimple_stmt_iterator dsi = gsi_after_labels (e->dest);\n       while (is_gimple_debug (gsi_stmt (ssi)))\n \t{\n-\t  gimple stmt = gsi_stmt (ssi), new_stmt;\n+\t  gimple stmt = gsi_stmt (ssi);\n+\t  gdebug *new_stmt;\n \t  tree var;\n \t  tree value;\n \n@@ -2658,12 +2682,12 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n \n   /* Now that we've duplicated the blocks, duplicate their edges.  */\n   basic_block abnormal_goto_dest = NULL;\n-  if (id->gimple_call\n-      && stmt_can_make_abnormal_goto (id->gimple_call))\n+  if (id->call_stmt\n+      && stmt_can_make_abnormal_goto (id->call_stmt))\n     {\n-      gimple_stmt_iterator gsi = gsi_for_stmt (id->gimple_call);\n+      gimple_stmt_iterator gsi = gsi_for_stmt (id->call_stmt);\n \n-      bb = gimple_bb (id->gimple_call);\n+      bb = gimple_bb (id->call_stmt);\n       gsi_next (&gsi);\n       if (gsi_end_p (gsi))\n \tabnormal_goto_dest = get_abnormal_succ_dispatcher (bb);\n@@ -2749,7 +2773,7 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n    this arises, we drop the VALUE expression altogether.  */\n \n static void\n-copy_debug_stmt (gimple stmt, copy_body_data *id)\n+copy_debug_stmt (gdebug *stmt, copy_body_data *id)\n {\n   tree t, *n;\n   struct walk_stmt_info wi;\n@@ -2808,7 +2832,7 @@ copy_debug_stmt (gimple stmt, copy_body_data *id)\n       t = gimple_debug_source_bind_get_value (stmt);\n       if (t != NULL_TREE\n \t  && TREE_CODE (t) == PARM_DECL\n-\t  && id->gimple_call)\n+\t  && id->call_stmt)\n \t{\n \t  vec<tree, va_gc> **debug_args = decl_debug_args_lookup (id->src_fn);\n \t  unsigned int i;\n@@ -2841,7 +2865,7 @@ static void\n copy_debug_stmts (copy_body_data *id)\n {\n   size_t i;\n-  gimple stmt;\n+  gdebug *stmt;\n \n   if (!id->debug_stmts.exists ())\n     return;\n@@ -3512,7 +3536,7 @@ inline_forbidden_p_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t VLA objects as those can't cause unbounded growth (they're always\n \t wrapped inside stack_save/stack_restore regions.  */\n       if (gimple_alloca_call_p (stmt)\n-\t  && !gimple_call_alloca_for_var_p (stmt)\n+\t  && !gimple_call_alloca_for_var_p (as_a <gcall *> (stmt))\n \t  && !lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)))\n \t{\n \t  inline_forbidden_reason\n@@ -3974,15 +3998,18 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n       break;\n \n     case GIMPLE_SWITCH:\n-      /* Take into account cost of the switch + guess 2 conditional jumps for\n-         each case label.\n-\n-\t TODO: once the switch expansion logic is sufficiently separated, we can\n-\t do better job on estimating cost of the switch.  */\n-      if (weights->time_based)\n-        cost = floor_log2 (gimple_switch_num_labels (stmt)) * 2;\n-      else\n-        cost = gimple_switch_num_labels (stmt) * 2;\n+      {\n+\tgswitch *switch_stmt = as_a <gswitch *> (stmt);\n+\t/* Take into account cost of the switch + guess 2 conditional jumps for\n+\t   each case label.\n+\n+\t   TODO: once the switch expansion logic is sufficiently separated, we can\n+\t   do better job on estimating cost of the switch.  */\n+\tif (weights->time_based)\n+\t  cost = floor_log2 (gimple_switch_num_labels (switch_stmt)) * 2;\n+\telse\n+\t  cost = gimple_switch_num_labels (switch_stmt) * 2;\n+      }\n       break;\n \n     case GIMPLE_CALL:\n@@ -4056,7 +4083,7 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n \n     case GIMPLE_ASM:\n       {\n-\tint count = asm_str_count (gimple_asm_string (stmt));\n+\tint count = asm_str_count (gimple_asm_string (as_a <gasm *> (stmt)));\n \t/* 1000 means infinity. This avoids overflows later\n \t   with very long asm statements.  */\n \tif (count > 1000)\n@@ -4076,13 +4103,17 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n       return 10;\n \n     case GIMPLE_BIND:\n-      return estimate_num_insns_seq (gimple_bind_body (stmt), weights);\n+      return estimate_num_insns_seq (\n+\t       gimple_bind_body (as_a <gbind *> (stmt)),\n+\t       weights);\n \n     case GIMPLE_EH_FILTER:\n       return estimate_num_insns_seq (gimple_eh_filter_failure (stmt), weights);\n \n     case GIMPLE_CATCH:\n-      return estimate_num_insns_seq (gimple_catch_handler (stmt), weights);\n+      return estimate_num_insns_seq (gimple_catch_handler (\n+\t\t\t\t       as_a <gcatch *> (stmt)),\n+\t\t\t\t     weights);\n \n     case GIMPLE_TRY:\n       return (estimate_num_insns_seq (gimple_try_eval (stmt), weights)\n@@ -4121,7 +4152,8 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n \n     case GIMPLE_TRANSACTION:\n       return (weights->tm_cost\n-\t      + estimate_num_insns_seq (gimple_transaction_body (stmt),\n+\t      + estimate_num_insns_seq (gimple_transaction_body (\n+\t\t\t\t\t  as_a <gtransaction *> (stmt)),\n \t\t\t\t\tweights));\n \n     default:\n@@ -4258,6 +4290,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n   gimple_stmt_iterator gsi, stmt_gsi;\n   bool successfully_inlined = FALSE;\n   bool purge_dead_abnormal_edges;\n+  gcall *call_stmt;\n   unsigned int i;\n \n   /* Set input_location here so we get the right instantiation context\n@@ -4267,7 +4300,8 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n   input_location = gimple_location (stmt);\n \n   /* From here on, we're only interested in CALL_EXPRs.  */\n-  if (gimple_code (stmt) != GIMPLE_CALL)\n+  call_stmt = dyn_cast <gcall *> (stmt);\n+  if (!call_stmt)\n     goto egress;\n \n   cg_edge = id->dst_node->get_edge (stmt);\n@@ -4413,7 +4447,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n   id->src_fn = fn;\n   id->src_node = cg_edge->callee;\n   id->src_cfun = DECL_STRUCT_FUNCTION (fn);\n-  id->gimple_call = stmt;\n+  id->call_stmt = stmt;\n \n   gcc_assert (!id->src_cfun->after_inlining);\n \n@@ -4473,7 +4507,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n       if (gimple_call_with_bounds_p (stmt)\n \t  && TREE_CODE (modify_dest) == SSA_NAME)\n \t{\n-\t  gimple retbnd = chkp_retbnd_call_by_val (modify_dest);\n+\t  gcall *retbnd = chkp_retbnd_call_by_val (modify_dest);\n \t  if (retbnd)\n \t    {\n \t      return_bounds = gimple_call_lhs (retbnd);\n@@ -4496,7 +4530,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n       if (DECL_P (modify_dest))\n \tTREE_NO_WARNING (modify_dest) = 1;\n \n-      if (gimple_call_return_slot_opt_p (stmt))\n+      if (gimple_call_return_slot_opt_p (call_stmt))\n \t{\n \t  return_slot = modify_dest;\n \t  modify_dest = NULL;\n@@ -4969,9 +5003,9 @@ mark_local_labels_stmt (gimple_stmt_iterator *gsip,\n \t\t        struct walk_stmt_info *wi)\n {\n   copy_body_data *id = (copy_body_data *) wi->info;\n-  gimple stmt = gsi_stmt (*gsip);\n+  glabel *stmt = dyn_cast <glabel *> (gsi_stmt (*gsip));\n \n-  if (gimple_code (stmt) == GIMPLE_LABEL)\n+  if (stmt)\n     {\n       tree decl = gimple_label_label (stmt);\n \n@@ -5043,9 +5077,9 @@ replace_locals_stmt (gimple_stmt_iterator *gsip,\n \t\t     struct walk_stmt_info *wi)\n {\n   copy_body_data *id = (copy_body_data *) wi->info;\n-  gimple stmt = gsi_stmt (*gsip);\n+  gimple gs = gsi_stmt (*gsip);\n \n-  if (gimple_code (stmt) == GIMPLE_BIND)\n+  if (gbind *stmt = dyn_cast <gbind *> (gs))\n     {\n       tree block = gimple_bind_block (stmt);\n "}, {"sha": "453b9cde0b7ff26d4d2ac48dddc7dedbaf8de453", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -81,7 +81,7 @@ struct copy_body_data\n \n   /* GIMPLE_CALL if va arg parameter packs should be expanded or NULL\n      is not.  */\n-  gimple gimple_call;\n+  gimple call_stmt;\n \n   /* Exception landing pad the inlined call lies in.  */\n   int eh_lp_nr;\n@@ -133,7 +133,7 @@ struct copy_body_data\n   bitmap blocks_to_copy;\n \n   /* Debug statements that need processing.  */\n-  vec<gimple> debug_stmts;\n+  vec<gdebug *> debug_stmts;\n \n   /* A map from local declarations in the inlined function to\n      equivalents in the function into which it is being inlined, where"}, {"sha": "b5a854f7d0eb79bf45ecac1e9d61aa48f70bd2c4", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -128,7 +128,7 @@ static bitmap names_to_release;\n /* vec of vec of PHIs to rewrite in a basic block.  Element I corresponds\n    the to basic block with index I.  Allocated once per compilation, *not*\n    released between different functions.  */\n-static vec<gimple_vec> phis_to_rewrite;\n+static vec< vec<gphi *> > phis_to_rewrite;\n \n /* The bitmap of non-NULL elements of PHIS_TO_REWRITE.  */\n static bitmap blocks_with_phis_to_rewrite;\n@@ -960,9 +960,9 @@ find_def_blocks_for (tree var)\n /* Marks phi node PHI in basic block BB for rewrite.  */\n \n static void\n-mark_phi_for_rewrite (basic_block bb, gimple phi)\n+mark_phi_for_rewrite (basic_block bb, gphi *phi)\n {\n-  gimple_vec phis;\n+  vec<gphi *> phis;\n   unsigned n, idx = bb->index;\n \n   if (rewrite_uses_p (phi))\n@@ -1001,7 +1001,7 @@ insert_phi_nodes_for (tree var, bitmap phi_insertion_points, bool update_p)\n {\n   unsigned bb_index;\n   edge e;\n-  gimple phi;\n+  gphi *phi;\n   basic_block bb;\n   bitmap_iterator bi;\n   struct def_blocks_d *def_map = find_def_blocks_for (var);\n@@ -1405,16 +1405,16 @@ rewrite_add_phi_arguments (basic_block bb)\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n-      gimple phi;\n-      gimple_stmt_iterator gsi;\n+      gphi *phi;\n+      gphi_iterator gsi;\n \n       for (gsi = gsi_start_phis (e->dest); !gsi_end_p (gsi);\n \t   gsi_next (&gsi))\n \t{\n \t  tree currdef, res;\n \t  location_t loc;\n \n-\t  phi = gsi_stmt (gsi);\n+\t  phi = gsi.phi ();\n \t  res = gimple_phi_result (phi);\n \t  currdef = get_reaching_def (SSA_NAME_VAR (res));\n \t  /* Virtual operand PHI args do not need a location.  */\n@@ -1444,8 +1444,6 @@ class rewrite_dom_walker : public dom_walker\n void\n rewrite_dom_walker::before_dom_children (basic_block bb)\n {\n-  gimple_stmt_iterator gsi;\n-\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\n\\nRenaming block #%d\\n\\n\", bb->index);\n \n@@ -1455,7 +1453,8 @@ rewrite_dom_walker::before_dom_children (basic_block bb)\n   /* Step 1.  Register new definitions for every PHI node in the block.\n      Conceptually, all the PHI nodes are executed in parallel and each PHI\n      node introduces a new version for the associated variable.  */\n-  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n     {\n       tree result = gimple_phi_result (gsi_stmt (gsi));\n       register_new_def (result, SSA_NAME_VAR (result));\n@@ -1465,7 +1464,8 @@ rewrite_dom_walker::before_dom_children (basic_block bb)\n      with its immediate reaching definitions.  Update the current definition\n      of a variable when a new real or virtual definition is found.  */\n   if (bitmap_bit_p (interesting_blocks, bb->index))\n-    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+\t gsi_next (&gsi))\n       rewrite_stmt (&gsi);\n \n   /* Step 3.  Visit all the successor blocks of BB looking for PHI nodes.\n@@ -2016,8 +2016,8 @@ rewrite_update_phi_arguments (basic_block bb)\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n-      gimple phi;\n-      gimple_vec phis;\n+      gphi *phi;\n+      vec<gphi *> phis;\n \n       if (!bitmap_bit_p (blocks_with_phis_to_rewrite, e->dest->index))\n \tcontinue;\n@@ -2070,12 +2070,13 @@ rewrite_update_phi_arguments (basic_block bb)\n \t      else\n \t\t{\n \t\t  gimple stmt = SSA_NAME_DEF_STMT (reaching_def);\n+\t\t  gphi *other_phi = dyn_cast <gphi *> (stmt);\n \n \t\t  /* Single element PHI nodes  behave like copies, so get the\n \t\t     location from the phi argument.  */\n-\t\t  if (gimple_code (stmt) == GIMPLE_PHI\n-\t\t      && gimple_phi_num_args (stmt) == 1)\n-\t\t    locus = gimple_phi_arg_location (stmt, 0);\n+\t\t  if (other_phi\n+\t\t      && gimple_phi_num_args (other_phi) == 1)\n+\t\t    locus = gimple_phi_arg_location (other_phi, 0);\n \t\t  else\n \t\t    locus = gimple_location (stmt);\n \t\t}\n@@ -2108,7 +2109,6 @@ void\n rewrite_update_dom_walker::before_dom_children (basic_block bb)\n {\n   bool is_abnormal_phi;\n-  gimple_stmt_iterator gsi;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Registering new PHI nodes in block #%d\\n\",\n@@ -2129,10 +2129,11 @@ rewrite_update_dom_walker::before_dom_children (basic_block bb)\n      register it as a new definition for its corresponding name.  Also\n      register definitions for names whose underlying symbols are\n      marked for renaming.  */\n-  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n     {\n       tree lhs, lhs_sym;\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n \n       if (!register_defs_p (phi))\n \tcontinue;\n@@ -2164,7 +2165,7 @@ rewrite_update_dom_walker::before_dom_children (basic_block bb)\n   if (bitmap_bit_p (interesting_blocks, bb->index))\n     {\n       gcc_checking_assert (bitmap_bit_p (blocks_to_update, bb->index));\n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n \tif (rewrite_update_stmt (gsi_stmt (gsi), gsi))\n \t  gsi_remove (&gsi, true);\n \telse\n@@ -2480,7 +2481,7 @@ mark_use_interesting (tree var, gimple stmt, basic_block bb, bool insert_phi_p)\n   mark_block_for_update (bb);\n \n   if (gimple_code (stmt) == GIMPLE_PHI)\n-    mark_phi_for_rewrite (def_bb, stmt);\n+    mark_phi_for_rewrite (def_bb, as_a <gphi *> (stmt));\n   else\n     {\n       set_rewrite_uses (stmt, true);\n@@ -2522,17 +2523,17 @@ static void\n prepare_block_for_update (basic_block bb, bool insert_phi_p)\n {\n   basic_block son;\n-  gimple_stmt_iterator si;\n   edge e;\n   edge_iterator ei;\n \n   mark_block_for_update (bb);\n \n   /* Process PHI nodes marking interesting those that define or use\n      the symbols that we are interested in.  */\n-  for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n+  for (gphi_iterator si = gsi_start_phis (bb); !gsi_end_p (si);\n+       gsi_next (&si))\n     {\n-      gimple phi = gsi_stmt (si);\n+      gphi *phi = si.phi ();\n       tree lhs_sym, lhs = gimple_phi_result (phi);\n \n       if (TREE_CODE (lhs) == SSA_NAME\n@@ -2556,7 +2557,8 @@ prepare_block_for_update (basic_block bb, bool insert_phi_p)\n     }\n \n   /* Process the statements.  */\n-  for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+  for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n+       gsi_next (&si))\n     {\n       gimple stmt;\n       ssa_op_iter i;\n@@ -2628,7 +2630,7 @@ prepare_use_sites_for (tree name, bool insert_phi_p)\n       if (gimple_code (stmt) == GIMPLE_PHI)\n \t{\n \t  int ix = PHI_ARG_INDEX_FROM_USE (use_p);\n-\t  edge e = gimple_phi_arg_edge (stmt, ix);\n+\t  edge e = gimple_phi_arg_edge (as_a <gphi *> (stmt), ix);\n \t  mark_use_interesting (name, stmt, e->src, insert_phi_p);\n \t}\n       else\n@@ -2840,7 +2842,7 @@ delete_update_ssa (void)\n   if (blocks_with_phis_to_rewrite)\n     EXECUTE_IF_SET_IN_BITMAP (blocks_with_phis_to_rewrite, 0, i, bi)\n       {\n-\tgimple_vec phis = phis_to_rewrite[i];\n+\tvec<gphi *> phis = phis_to_rewrite[i];\n \tphis.release ();\n \tphis_to_rewrite[i].create (0);\n       }\n@@ -2935,7 +2937,7 @@ mark_virtual_operand_for_renaming (tree name)\n    removed.  */\n \n void\n-mark_virtual_phi_result_for_renaming (gimple phi)\n+mark_virtual_phi_result_for_renaming (gphi *phi)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {"}, {"sha": "c627f45d4cbdd06f4454f38dd09b7d5b0204ff3a", "filename": "gcc/tree-into-ssa.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-into-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-into-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -26,7 +26,7 @@ void delete_update_ssa (void);\n tree create_new_def_for (tree, gimple, def_operand_p);\n void mark_virtual_operands_for_renaming (struct function *);\n void mark_virtual_operand_for_renaming (tree);\n-void mark_virtual_phi_result_for_renaming (gimple);\n+void mark_virtual_phi_result_for_renaming (gphi *);\n bool need_ssa_update_p (struct function *);\n bool name_registered_for_update_p (tree);\n void release_ssa_name_after_update_ssa (tree);"}, {"sha": "7aa7e31755bf0667535f69b60f099cecd7b637e7", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -405,16 +405,16 @@ stmts_from_loop (struct loop *loop, vec<gimple> *stmts)\n   for (i = 0; i < loop->num_nodes; i++)\n     {\n       basic_block bb = bbs[i];\n-      gimple_stmt_iterator bsi;\n-      gimple stmt;\n \n-      for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-\tif (!virtual_operand_p (gimple_phi_result (gsi_stmt (bsi))))\n-\t  stmts->safe_push (gsi_stmt (bsi));\n+      for (gphi_iterator bsi = gsi_start_phis (bb); !gsi_end_p (bsi);\n+\t   gsi_next (&bsi))\n+\tif (!virtual_operand_p (gimple_phi_result (bsi.phi ())))\n+\t  stmts->safe_push (bsi.phi ());\n \n-      for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+      for (gimple_stmt_iterator bsi = gsi_start_bb (bb); !gsi_end_p (bsi);\n+\t   gsi_next (&bsi))\n \t{\n-\t  stmt = gsi_stmt (bsi);\n+\t  gimple stmt = gsi_stmt (bsi);\n \t  if (gimple_code (stmt) != GIMPLE_LABEL && !is_gimple_debug (stmt))\n \t    stmts->safe_push (stmt);\n \t}\n@@ -632,7 +632,6 @@ generate_loops_for_partition (struct loop *loop, partition_t partition,\n \t\t\t      bool copy_p)\n {\n   unsigned i;\n-  gimple_stmt_iterator bsi;\n   basic_block *bbs;\n \n   if (copy_p)\n@@ -651,15 +650,16 @@ generate_loops_for_partition (struct loop *loop, partition_t partition,\n       {\n \tbasic_block bb = bbs[i];\n \n-\tfor (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+\tfor (gphi_iterator bsi = gsi_start_phis (bb); !gsi_end_p (bsi);\n+\t     gsi_next (&bsi))\n \t  {\n-\t    gimple phi = gsi_stmt (bsi);\n+\t    gphi *phi = bsi.phi ();\n \t    if (!virtual_operand_p (gimple_phi_result (phi))\n \t\t&& !bitmap_bit_p (partition->stmts, gimple_uid (phi)))\n \t      reset_debug_uses (phi);\n \t  }\n \n-\tfor (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+\tfor (gimple_stmt_iterator bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n \t  {\n \t    gimple stmt = gsi_stmt (bsi);\n \t    if (gimple_code (stmt) != GIMPLE_LABEL\n@@ -673,17 +673,17 @@ generate_loops_for_partition (struct loop *loop, partition_t partition,\n     {\n       basic_block bb = bbs[i];\n \n-      for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi);)\n+      for (gphi_iterator bsi = gsi_start_phis (bb); !gsi_end_p (bsi);)\n \t{\n-\t  gimple phi = gsi_stmt (bsi);\n+\t  gphi *phi = bsi.phi ();\n \t  if (!virtual_operand_p (gimple_phi_result (phi))\n \t      && !bitmap_bit_p (partition->stmts, gimple_uid (phi)))\n \t    remove_phi_node (&bsi, true);\n \t  else\n \t    gsi_next (&bsi);\n \t}\n \n-      for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi);)\n+      for (gimple_stmt_iterator bsi = gsi_start_bb (bb); !gsi_end_p (bsi);)\n \t{\n \t  gimple stmt = gsi_stmt (bsi);\n \t  if (gimple_code (stmt) != GIMPLE_LABEL\n@@ -692,15 +692,16 @@ generate_loops_for_partition (struct loop *loop, partition_t partition,\n \t    {\n \t      /* Choose an arbitrary path through the empty CFG part\n \t\t that this unnecessary control stmt controls.  */\n-\t      if (gimple_code (stmt) == GIMPLE_COND)\n+\t      if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n \t\t{\n-\t\t  gimple_cond_make_false (stmt);\n+\t\t  gimple_cond_make_false (cond_stmt);\n \t\t  update_stmt (stmt);\n \t\t}\n \t      else if (gimple_code (stmt) == GIMPLE_SWITCH)\n \t\t{\n+\t\t  gswitch *switch_stmt = as_a <gswitch *> (stmt);\n \t\t  gimple_switch_set_index\n-\t\t      (stmt, CASE_LOW (gimple_switch_label (stmt, 1)));\n+\t\t      (switch_stmt, CASE_LOW (gimple_switch_label (switch_stmt, 1)));\n \t\t  update_stmt (stmt);\n \t\t}\n \t      else\n@@ -912,14 +913,15 @@ destroy_loop (struct loop *loop)\n \t Make sure we replace all uses of virtual defs that will remain\n \t outside of the loop with the bare symbol as delete_basic_block\n \t will release them.  */\n-      gimple_stmt_iterator gsi;\n-      for (gsi = gsi_start_phis (bbs[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gphi_iterator gsi = gsi_start_phis (bbs[i]); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n \t{\n-\t  gimple phi = gsi_stmt (gsi);\n+\t  gphi *phi = gsi.phi ();\n \t  if (virtual_operand_p (gimple_phi_result (phi)))\n \t    mark_virtual_phi_result_for_renaming (phi);\n \t}\n-      for (gsi = gsi_start_bb (bbs[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (bbs[i]); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n \t{\n \t  gimple stmt = gsi_stmt (gsi);\n \t  tree vdef = gimple_vdef (stmt);\n@@ -1752,10 +1754,11 @@ pass_loop_distribution::execute (function *fun)\n       bbs = get_loop_body_in_dom_order (loop);\n       for (i = 0; i < loop->num_nodes; ++i)\n \t{\n-\t  gimple_stmt_iterator gsi;\n-\t  for (gsi = gsi_start_phis (bbs[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  for (gphi_iterator gsi = gsi_start_phis (bbs[i]);\n+\t       !gsi_end_p (gsi);\n+\t       gsi_next (&gsi))\n \t    {\n-\t      gimple phi = gsi_stmt (gsi);\n+\t      gphi *phi = gsi.phi ();\n \t      if (virtual_operand_p (gimple_phi_result (phi)))\n \t\tcontinue;\n \t      /* Distribute stmts which have defs that are used outside of\n@@ -1764,7 +1767,9 @@ pass_loop_distribution::execute (function *fun)\n \t\tcontinue;\n \t      work_list.safe_push (phi);\n \t    }\n-\t  for (gsi = gsi_start_bb (bbs[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  for (gimple_stmt_iterator gsi = gsi_start_bb (bbs[i]);\n+\t       !gsi_end_p (gsi);\n+\t       gsi_next (&gsi))\n \t    {\n \t      gimple stmt = gsi_stmt (gsi);\n "}, {"sha": "4d318376e58408a7e94571016521f9e8c3b393e7", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -418,7 +418,7 @@ get_chain_field (struct nesting_info *info)\n \n static tree\n init_tmp_var_with_call (struct nesting_info *info, gimple_stmt_iterator *gsi,\n-\t\t        gimple call)\n+\t\t        gcall *call)\n {\n   tree t;\n \n@@ -623,7 +623,7 @@ walk_function (walk_stmt_fn callback_stmt, walk_tree_fn callback_op,\n /* Invoke CALLBACK on a GIMPLE_OMP_FOR's init, cond, incr and pre-body.  */\n \n static void\n-walk_gimple_omp_for (gimple for_stmt,\n+walk_gimple_omp_for (gomp_for *for_stmt,\n     \t\t     walk_stmt_fn callback_stmt, walk_tree_fn callback_op,\n     \t\t     struct nesting_info *info)\n {\n@@ -1355,7 +1355,8 @@ convert_nonlocal_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n     case GIMPLE_OMP_FOR:\n       save_suppress = info->suppress_expansion;\n       convert_nonlocal_omp_clauses (gimple_omp_for_clauses_ptr (stmt), wi);\n-      walk_gimple_omp_for (stmt, convert_nonlocal_reference_stmt,\n+      walk_gimple_omp_for (as_a <gomp_for *> (stmt),\n+\t\t\t   convert_nonlocal_reference_stmt,\n \t  \t\t   convert_nonlocal_reference_op, info);\n       walk_body (convert_nonlocal_reference_stmt,\n \t  \t convert_nonlocal_reference_op, info, gimple_omp_body_ptr (stmt));\n@@ -1401,7 +1402,7 @@ convert_nonlocal_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t  OMP_CLAUSE_MAP_KIND (c) = OMP_CLAUSE_MAP_TO;\n \t  OMP_CLAUSE_SIZE (c) = DECL_SIZE_UNIT (decl);\n \t  OMP_CLAUSE_CHAIN (c) = gimple_omp_target_clauses (stmt);\n-\t  gimple_omp_target_set_clauses (stmt, c);\n+\t  gimple_omp_target_set_clauses (as_a <gomp_target *> (stmt), c);\n \t}\n \n       save_local_var_chain = info->new_local_var_chain;\n@@ -1435,10 +1436,12 @@ convert_nonlocal_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       break;\n \n     case GIMPLE_BIND:\n-      if (!optimize && gimple_bind_block (stmt))\n-\tnote_nonlocal_block_vlas (info, gimple_bind_block (stmt));\n+      {\n+      gbind *bind_stmt = as_a <gbind *> (stmt);\n+      if (!optimize && gimple_bind_block (bind_stmt))\n+\tnote_nonlocal_block_vlas (info, gimple_bind_block (bind_stmt));\n \n-      for (tree var = gimple_bind_vars (stmt); var; var = DECL_CHAIN (var))\n+      for (tree var = gimple_bind_vars (bind_stmt); var; var = DECL_CHAIN (var))\n \tif (TREE_CODE (var) == NAMELIST_DECL)\n \t  {\n \t    /* Adjust decls mentioned in NAMELIST_DECL.  */\n@@ -1459,7 +1462,7 @@ convert_nonlocal_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \n       *handled_ops_p = false;\n       return NULL_TREE;\n-\n+      }\n     case GIMPLE_COND:\n       wi->val_only = true;\n       wi->is_lhs = false;\n@@ -1921,7 +1924,8 @@ convert_local_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n     case GIMPLE_OMP_FOR:\n       save_suppress = info->suppress_expansion;\n       convert_local_omp_clauses (gimple_omp_for_clauses_ptr (stmt), wi);\n-      walk_gimple_omp_for (stmt, convert_local_reference_stmt,\n+      walk_gimple_omp_for (as_a <gomp_for *> (stmt),\n+\t\t\t   convert_local_reference_stmt,\n \t\t\t   convert_local_reference_op, info);\n       walk_body (convert_local_reference_stmt, convert_local_reference_op,\n \t\t info, gimple_omp_body_ptr (stmt));\n@@ -1964,7 +1968,7 @@ convert_local_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t  OMP_CLAUSE_MAP_KIND (c) = OMP_CLAUSE_MAP_TOFROM;\n \t  OMP_CLAUSE_SIZE (c) = DECL_SIZE_UNIT (info->frame_decl);\n \t  OMP_CLAUSE_CHAIN (c) = gimple_omp_target_clauses (stmt);\n-\t  gimple_omp_target_set_clauses (stmt, c);\n+\t  gimple_omp_target_set_clauses (as_a <gomp_target *> (stmt), c);\n \t}\n \n       save_local_var_chain = info->new_local_var_chain;\n@@ -2017,7 +2021,9 @@ convert_local_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       return NULL_TREE;\n \n     case GIMPLE_BIND:\n-      for (tree var = gimple_bind_vars (stmt); var; var = DECL_CHAIN (var))\n+      for (tree var = gimple_bind_vars (as_a <gbind *> (stmt));\n+\t   var;\n+\t   var = DECL_CHAIN (var))\n \tif (TREE_CODE (var) == NAMELIST_DECL)\n \t  {\n \t    /* Adjust decls mentioned in NAMELIST_DECL.  */\n@@ -2069,7 +2075,7 @@ convert_nl_goto_reference (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n {\n   struct nesting_info *const info = (struct nesting_info *) wi->info, *i;\n   tree label, new_label, target_context, x, field;\n-  gimple call;\n+  gcall *call;\n   gimple stmt = gsi_stmt (*gsi);\n \n   if (gimple_code (stmt) != GIMPLE_GOTO)\n@@ -2140,9 +2146,9 @@ convert_nl_goto_receiver (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n   struct nesting_info *const info = (struct nesting_info *) wi->info;\n   tree label, new_label;\n   gimple_stmt_iterator tmp_gsi;\n-  gimple stmt = gsi_stmt (*gsi);\n+  glabel *stmt = dyn_cast <glabel *> (gsi_stmt (*gsi));\n \n-  if (gimple_code (stmt) != GIMPLE_LABEL)\n+  if (!stmt)\n     {\n       *handled_ops_p = false;\n       return NULL_TREE;\n@@ -2186,7 +2192,7 @@ convert_tramp_reference_op (tree *tp, int *walk_subtrees, void *data)\n   struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n   struct nesting_info *const info = (struct nesting_info *) wi->info, *i;\n   tree t = *tp, decl, target_context, x, builtin;\n-  gimple call;\n+  gcall *call;\n \n   *walk_subtrees = 0;\n   switch (TREE_CODE (t))\n@@ -2335,8 +2341,9 @@ convert_gimple_call (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       target_context = decl_function_context (decl);\n       if (target_context && DECL_STATIC_CHAIN (decl))\n \t{\n-\t  gimple_call_set_chain (stmt, get_static_chain (info, target_context,\n-\t\t\t\t\t\t\t &wi->gsi));\n+\t  gimple_call_set_chain (as_a <gcall *> (stmt),\n+\t\t\t\t get_static_chain (info, target_context,\n+\t\t\t\t\t\t   &wi->gsi));\n \t  info->static_chain_added |= (1 << (info->context != target_context));\n \t}\n       break;\n@@ -2403,7 +2410,8 @@ convert_gimple_call (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t\t= i ? OMP_CLAUSE_MAP_TO : OMP_CLAUSE_MAP_TOFROM;\n \t      OMP_CLAUSE_SIZE (c) = DECL_SIZE_UNIT (decl);\n \t      OMP_CLAUSE_CHAIN (c) = gimple_omp_target_clauses (stmt);\n-\t      gimple_omp_target_set_clauses (stmt, c);\n+\t      gimple_omp_target_set_clauses (as_a <gomp_target *> (stmt),\n+\t\t\t\t\t     c);\n \t    }\n \t}\n       info->static_chain_added |= save_static_chain_added;\n@@ -2783,9 +2791,9 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n   /* If we created initialization statements, insert them.  */\n   if (stmt_list)\n     {\n-      gimple bind;\n+      gbind *bind;\n       annotate_all_with_location (stmt_list, DECL_SOURCE_LOCATION (context));\n-      bind = gimple_seq_first_stmt (gimple_body (context));\n+      bind = gimple_seq_first_stmt_as_a_bind (gimple_body (context));\n       gimple_seq_add_seq (&stmt_list, gimple_bind_body (bind));\n       gimple_bind_set_body (bind, stmt_list);\n     }\n@@ -2814,7 +2822,7 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n   if (root->debug_var_chain)\n     {\n       tree debug_var;\n-      gimple scope;\n+      gbind *scope;\n \n       remap_vla_decls (DECL_INITIAL (root->context), root);\n \n@@ -2869,7 +2877,7 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n \t  delete id.cb.decl_map;\n \t}\n \n-      scope = gimple_seq_first_stmt (gimple_body (root->context));\n+      scope = gimple_seq_first_stmt_as_a_bind (gimple_body (root->context));\n       if (gimple_bind_block (scope))\n \tdeclare_vars (root->debug_var_chain, scope, true);\n       else"}, {"sha": "182039edc0d7a5c47edca4492b1da202068b5a07", "filename": "gcc/tree-nrv.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-nrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-nrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nrv.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -189,12 +189,12 @@ pass_nrv::execute (function *fun)\n \t  gimple stmt = gsi_stmt (gsi);\n \t  tree ret_val;\n \n-\t  if (gimple_code (stmt) == GIMPLE_RETURN)\n+\t  if (greturn *return_stmt = dyn_cast <greturn *> (stmt))\n \t    {\n \t      /* In a function with an aggregate return value, the\n \t\t gimplifier has changed all non-empty RETURN_EXPRs to\n \t\t return the RESULT_DECL.  */\n-\t      ret_val = gimple_return_retval (stmt);\n+\t      ret_val = gimple_return_retval (return_stmt);\n \t      if (ret_val)\n \t\tgcc_assert (ret_val == result);\n \t    }\n@@ -324,7 +324,7 @@ make_pass_nrv (gcc::context *ctxt)\n    DEST is available if it is not clobbered or used by the call.  */\n \n static bool\n-dest_safe_for_nrv_p (gimple call)\n+dest_safe_for_nrv_p (gcall *call)\n {\n   tree dest = gimple_call_lhs (call);\n \n@@ -391,10 +391,11 @@ pass_return_slot::execute (function *fun)\n       gimple_stmt_iterator gsi;\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gcall *stmt;\n \t  bool slot_opt_p;\n \n-\t  if (is_gimple_call (stmt)\n+\t  stmt = dyn_cast <gcall *> (gsi_stmt (gsi));\n+\t  if (stmt\n \t      && gimple_call_lhs (stmt)\n \t      && !gimple_call_return_slot_opt_p (stmt)\n \t      && aggregate_value_p (TREE_TYPE (gimple_call_lhs (stmt)),"}, {"sha": "20b99567eef7100ca6d879507405a14435a171f3", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -69,8 +69,8 @@ static const unsigned HOST_WIDE_INT unknown[4] = { -1, -1, 0, 0 };\n static tree compute_object_offset (const_tree, const_tree);\n static unsigned HOST_WIDE_INT addr_object_size (struct object_size_info *,\n \t\t\t\t\t\tconst_tree, int);\n-static unsigned HOST_WIDE_INT alloc_object_size (const_gimple, int);\n-static tree pass_through_call (const_gimple);\n+static unsigned HOST_WIDE_INT alloc_object_size (const gcall *, int);\n+static tree pass_through_call (const gcall *);\n static void collect_object_sizes_for (struct object_size_info *, tree);\n static void expr_object_size (struct object_size_info *, tree, tree);\n static bool merge_object_sizes (struct object_size_info *, tree, tree,\n@@ -402,7 +402,7 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n    unknown[object_size_type].  */\n \n static unsigned HOST_WIDE_INT\n-alloc_object_size (const_gimple call, int object_size_type)\n+alloc_object_size (const gcall *call, int object_size_type)\n {\n   tree callee, bytes = NULL_TREE;\n   tree alloc_size;\n@@ -465,7 +465,7 @@ alloc_object_size (const_gimple call, int object_size_type)\n    Otherwise return NULL.  */\n \n static tree\n-pass_through_call (const_gimple call)\n+pass_through_call (const gcall *call)\n {\n   tree callee = gimple_call_fndecl (call);\n \n@@ -679,7 +679,7 @@ expr_object_size (struct object_size_info *osi, tree ptr, tree value)\n /* Compute object_sizes for PTR, defined to the result of a call.  */\n \n static void\n-call_object_size (struct object_size_info *osi, tree ptr, gimple call)\n+call_object_size (struct object_size_info *osi, tree ptr, gcall *call)\n {\n   int object_size_type = osi->object_size_type;\n   unsigned int varno = SSA_NAME_VERSION (ptr);\n@@ -976,7 +976,8 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n \n     case GIMPLE_CALL:\n       {\n-        tree arg = pass_through_call (stmt);\n+\tgcall *call_stmt = as_a <gcall *> (stmt);\n+        tree arg = pass_through_call (call_stmt);\n         if (arg)\n           {\n             if (TREE_CODE (arg) == SSA_NAME\n@@ -986,7 +987,7 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n               expr_object_size (osi, var, arg);\n           }\n         else\n-          call_object_size (osi, var, stmt);\n+          call_object_size (osi, var, call_stmt);\n \tbreak;\n       }\n \n@@ -1112,7 +1113,8 @@ check_for_plus_in_loops_1 (struct object_size_info *osi, tree var,\n \n     case GIMPLE_CALL:\n       {\n-        tree arg = pass_through_call (stmt);\n+\tgcall *call_stmt = as_a <gcall *> (stmt);\n+        tree arg = pass_through_call (call_stmt);\n         if (arg)\n           {\n             if (TREE_CODE (arg) == SSA_NAME)\n@@ -1260,7 +1262,7 @@ pass_object_sizes::execute (function *fun)\n \t    continue;\n \n \t  init_object_sizes ();\n-\t  result = fold_call_stmt (call, false);\n+\t  result = fold_call_stmt (as_a <gcall *> (call), false);\n \t  if (!result)\n \t    {\n \t      if (gimple_call_num_args (call) == 2"}, {"sha": "085c8f4cc341d4187bd512f81f0701c09dc5d46a", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -593,13 +593,13 @@ eliminate_build (elim_graph g)\n {\n   tree Ti;\n   int p0, pi;\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n \n   clear_elim_graph (g);\n \n   for (gsi = gsi_start_phis (g->e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n       source_location locus;\n \n       p0 = var_to_partition (g->map, gimple_phi_result (phi));\n@@ -800,7 +800,7 @@ eliminate_phi (edge e, elim_graph g)\n    check to see if this allows another PHI node to be removed.  */\n \n static void\n-remove_gimple_phi_args (gimple phi)\n+remove_gimple_phi_args (gphi *phi)\n {\n   use_operand_p arg_p;\n   ssa_op_iter iter;\n@@ -828,7 +828,7 @@ remove_gimple_phi_args (gimple phi)\n \t      /* Also remove the def if it is a PHI node.  */\n \t      if (gimple_code (stmt) == GIMPLE_PHI)\n \t\t{\n-\t\t  remove_gimple_phi_args (stmt);\n+\t\t  remove_gimple_phi_args (as_a <gphi *> (stmt));\n \t\t  gsi = gsi_for_stmt (stmt);\n \t\t  remove_phi_node (&gsi, true);\n \t\t}\n@@ -844,14 +844,14 @@ static void\n eliminate_useless_phis (void)\n {\n   basic_block bb;\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n   tree result;\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); )\n         {\n-\t  gimple phi = gsi_stmt (gsi);\n+\t  gphi *phi = gsi.phi ();\n \t  result = gimple_phi_result (phi);\n \t  if (virtual_operand_p (result))\n \t    {\n@@ -907,10 +907,10 @@ rewrite_trees (var_map map ATTRIBUTE_UNUSED)\n      create incorrect code.  */\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      gimple_stmt_iterator gsi;\n+      gphi_iterator gsi;\n       for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple phi = gsi_stmt (gsi);\n+\t  gphi *phi = gsi.phi ();\n \t  tree T0 = var_to_partition_to_var (map, gimple_phi_result (phi));\n \t  if (T0 == NULL_TREE)\n \t    {\n@@ -1109,7 +1109,7 @@ static void\n insert_backedge_copies (void)\n {\n   basic_block bb;\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n \n   mark_dfs_back_edges ();\n \n@@ -1120,7 +1120,7 @@ insert_backedge_copies (void)\n \n       for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple phi = gsi_stmt (gsi);\n+\t  gphi *phi = gsi.phi ();\n \t  tree result = gimple_phi_result (phi);\n \t  size_t i;\n \n@@ -1142,7 +1142,8 @@ insert_backedge_copies (void)\n \t\t      || trivially_conflicts_p (bb, result, arg)))\n \t\t{\n \t\t  tree name;\n-\t\t  gimple stmt, last = NULL;\n+\t\t  gassign *stmt;\n+\t\t  gimple last = NULL;\n \t\t  gimple_stmt_iterator gsi2;\n \n \t\t  gsi2 = gsi_last_bb (gimple_phi_arg_edge (phi, i)->src);"}, {"sha": "885dc314994f65dd921a4001dd7bba471e8984fc", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 58, "deletions": 43, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -203,12 +203,12 @@ struct reduction_info\n   enum tree_code reduction_code;/* code for the reduction operation.  */\n   unsigned reduc_version;\t/* SSA_NAME_VERSION of original reduc_phi\n \t\t\t\t   result.  */\n-  gimple keep_res;\t\t/* The PHI_RESULT of this phi is the resulting value\n+  gphi *keep_res;\t\t/* The PHI_RESULT of this phi is the resulting value\n \t\t\t\t   of the reduction variable when existing the loop. */\n   tree initial_value;\t\t/* The initial value of the reduction var before entering the loop.  */\n   tree field;\t\t\t/*  the name of the field in the parloop data structure intended for reduction.  */\n   tree init;\t\t\t/* reduction initialization value.  */\n-  gimple new_phi;\t\t/* (helper field) Newly created phi node whose result\n+  gphi *new_phi;\t\t/* (helper field) Newly created phi node whose result\n \t\t\t\t   will be passed to the atomic operation.  Represents\n \t\t\t\t   the local result each thread computed for the reduction\n \t\t\t\t   operation.  */\n@@ -501,7 +501,7 @@ take_address_of (tree obj, tree type, edge entry,\n {\n   int uid;\n   tree *var_p, name, addr;\n-  gimple stmt;\n+  gassign *stmt;\n   gimple_seq stmts;\n \n   /* Since the address of OBJ is invariant, the trees may be shared.\n@@ -1038,7 +1038,7 @@ create_phi_for_local_result (reduction_info **slot, struct loop *loop)\n {\n   struct reduction_info *const reduc = *slot;\n   edge e;\n-  gimple new_phi;\n+  gphi *new_phi;\n   basic_block store_bb;\n   tree local_res;\n   source_location locus;\n@@ -1509,23 +1509,26 @@ transform_to_exit_first_loop (struct loop *loop,\n   bool ok;\n   edge exit = single_dom_exit (loop), hpred;\n   tree control, control_name, res, t;\n-  gimple phi, nphi, cond_stmt, stmt, cond_nit;\n-  gimple_stmt_iterator gsi;\n+  gphi *phi, *nphi;\n+  gassign *stmt;\n+  gcond *cond_stmt, *cond_nit;\n   tree nit_1;\n \n   split_block_after_labels (loop->header);\n   orig_header = single_succ (loop->header);\n   hpred = single_succ_edge (loop->header);\n \n-  cond_stmt = last_stmt (exit->src);\n+  cond_stmt = as_a <gcond *> (last_stmt (exit->src));\n   control = gimple_cond_lhs (cond_stmt);\n   gcc_assert (gimple_cond_rhs (cond_stmt) == nit);\n \n   /* Make sure that we have phi nodes on exit for all loop header phis\n      (create_parallel_loop requires that).  */\n-  for (gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gphi_iterator gsi = gsi_start_phis (loop->header);\n+       !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n     {\n-      phi = gsi_stmt (gsi);\n+      phi = gsi.phi ();\n       res = PHI_RESULT (phi);\n       t = copy_ssa_name (res, phi);\n       SET_PHI_RESULT (phi, t);\n@@ -1556,9 +1559,10 @@ transform_to_exit_first_loop (struct loop *loop,\n      out of the loop is the control variable.  */\n   exit = single_dom_exit (loop);\n   control_name = NULL_TREE;\n-  for (gsi = gsi_start_phis (ex_bb); !gsi_end_p (gsi); )\n+  for (gphi_iterator gsi = gsi_start_phis (ex_bb);\n+       !gsi_end_p (gsi); )\n     {\n-      phi = gsi_stmt (gsi);\n+      phi = gsi.phi ();\n       res = PHI_RESULT (phi);\n       if (virtual_operand_p (res))\n \t{\n@@ -1593,8 +1597,8 @@ transform_to_exit_first_loop (struct loop *loop,\n \n   /* Initialize the control variable to number of iterations\n      according to the rhs of the exit condition.  */\n-  gsi = gsi_after_labels (ex_bb);\n-  cond_nit = last_stmt (exit->src);\n+  gimple_stmt_iterator gsi = gsi_after_labels (ex_bb);\n+  cond_nit = as_a <gcond *> (last_stmt (exit->src));\n   nit_1 =  gimple_cond_rhs (cond_nit);\n   nit_1 = force_gimple_operand_gsi (&gsi,\n \t\t\t\t  fold_convert (TREE_TYPE (control_name), nit_1),\n@@ -1616,7 +1620,12 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n   gimple_stmt_iterator gsi;\n   basic_block bb, paral_bb, for_bb, ex_bb;\n   tree t, param;\n-  gimple stmt, for_stmt, phi, cond_stmt;\n+  gomp_parallel *omp_par_stmt;\n+  gimple omp_return_stmt1, omp_return_stmt2;\n+  gimple phi;\n+  gcond *cond_stmt;\n+  gomp_for *for_stmt;\n+  gomp_continue *omp_cont_stmt;\n   tree cvar, cvar_init, initvar, cvar_next, cvar_base, type;\n   edge exit, nexit, guard, end, e;\n \n@@ -1628,35 +1637,37 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n   t = build_omp_clause (loc, OMP_CLAUSE_NUM_THREADS);\n   OMP_CLAUSE_NUM_THREADS_EXPR (t)\n     = build_int_cst (integer_type_node, n_threads);\n-  stmt = gimple_build_omp_parallel (NULL, t, loop_fn, data);\n-  gimple_set_location (stmt, loc);\n+  omp_par_stmt = gimple_build_omp_parallel (NULL, t, loop_fn, data);\n+  gimple_set_location (omp_par_stmt, loc);\n \n-  gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n+  gsi_insert_after (&gsi, omp_par_stmt, GSI_NEW_STMT);\n \n   /* Initialize NEW_DATA.  */\n   if (data)\n     {\n+      gassign *assign_stmt;\n+\n       gsi = gsi_after_labels (bb);\n \n       param = make_ssa_name (DECL_ARGUMENTS (loop_fn), NULL);\n-      stmt = gimple_build_assign (param, build_fold_addr_expr (data));\n-      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+      assign_stmt = gimple_build_assign (param, build_fold_addr_expr (data));\n+      gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n \n-      stmt = gimple_build_assign (new_data,\n+      assign_stmt = gimple_build_assign (new_data,\n \t\t\t\t  fold_convert (TREE_TYPE (new_data), param));\n-      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+      gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n     }\n \n   /* Emit GIMPLE_OMP_RETURN for GIMPLE_OMP_PARALLEL.  */\n   bb = split_loop_exit_edge (single_dom_exit (loop));\n   gsi = gsi_last_bb (bb);\n-  stmt = gimple_build_omp_return (false);\n-  gimple_set_location (stmt, loc);\n-  gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n+  omp_return_stmt1 = gimple_build_omp_return (false);\n+  gimple_set_location (omp_return_stmt1, loc);\n+  gsi_insert_after (&gsi, omp_return_stmt1, GSI_NEW_STMT);\n \n   /* Extract data for GIMPLE_OMP_FOR.  */\n   gcc_assert (loop->header == single_dom_exit (loop)->src);\n-  cond_stmt = last_stmt (loop->header);\n+  cond_stmt = as_a <gcond *> (last_stmt (loop->header));\n \n   cvar = gimple_cond_lhs (cond_stmt);\n   cvar_base = SSA_NAME_VAR (cvar);\n@@ -1680,12 +1691,16 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n   guard = make_edge (for_bb, ex_bb, 0);\n   single_succ_edge (loop->latch)->flags = 0;\n   end = make_edge (loop->latch, ex_bb, EDGE_FALLTHRU);\n-  for (gsi = gsi_start_phis (ex_bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gphi_iterator gpi = gsi_start_phis (ex_bb);\n+       !gsi_end_p (gpi); gsi_next (&gpi))\n     {\n       source_location locus;\n       tree def;\n-      phi = gsi_stmt (gsi);\n-      stmt = SSA_NAME_DEF_STMT (PHI_ARG_DEF_FROM_EDGE (phi, exit));\n+      gphi *phi = gpi.phi ();\n+      gphi *stmt;\n+\n+      stmt = as_a <gphi *> (\n+\t       SSA_NAME_DEF_STMT (PHI_ARG_DEF_FROM_EDGE (phi, exit)));\n \n       def = PHI_ARG_DEF_FROM_EDGE (stmt, loop_preheader_edge (loop));\n       locus = gimple_phi_arg_location_from_edge (stmt,\n@@ -1721,16 +1736,16 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n \n   /* Emit GIMPLE_OMP_CONTINUE.  */\n   gsi = gsi_last_bb (loop->latch);\n-  stmt = gimple_build_omp_continue (cvar_next, cvar);\n-  gimple_set_location (stmt, loc);\n-  gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n-  SSA_NAME_DEF_STMT (cvar_next) = stmt;\n+  omp_cont_stmt = gimple_build_omp_continue (cvar_next, cvar);\n+  gimple_set_location (omp_cont_stmt, loc);\n+  gsi_insert_after (&gsi, omp_cont_stmt, GSI_NEW_STMT);\n+  SSA_NAME_DEF_STMT (cvar_next) = omp_cont_stmt;\n \n   /* Emit GIMPLE_OMP_RETURN for GIMPLE_OMP_FOR.  */\n   gsi = gsi_last_bb (ex_bb);\n-  stmt = gimple_build_omp_return (true);\n-  gimple_set_location (stmt, loc);\n-  gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n+  omp_return_stmt2 = gimple_build_omp_return (true);\n+  gimple_set_location (omp_return_stmt2, loc);\n+  gsi_insert_after (&gsi, omp_return_stmt2, GSI_NEW_STMT);\n \n   /* After the above dom info is hosed.  Re-compute it.  */\n   free_dominance_info (CDI_DOMINATORS);\n@@ -1914,12 +1929,12 @@ loop_has_vector_phi_nodes (struct loop *loop ATTRIBUTE_UNUSED)\n {\n   unsigned i;\n   basic_block *bbs = get_loop_body_in_dom_order (loop);\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n   bool res = true;\n \n   for (i = 0; i < loop->num_nodes; i++)\n     for (gsi = gsi_start_phis (bbs[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n-      if (TREE_CODE (TREE_TYPE (PHI_RESULT (gsi_stmt (gsi)))) == VECTOR_TYPE)\n+      if (TREE_CODE (TREE_TYPE (PHI_RESULT (gsi.phi ()))) == VECTOR_TYPE)\n \tgoto end;\n \n   res = false;\n@@ -1933,7 +1948,7 @@ loop_has_vector_phi_nodes (struct loop *loop ATTRIBUTE_UNUSED)\n \n static void\n build_new_reduction (reduction_info_table_type *reduction_list,\n-\t\t     gimple reduc_stmt, gimple phi)\n+\t\t     gimple reduc_stmt, gphi *phi)\n {\n   reduction_info **slot;\n   struct reduction_info *new_reduction;\n@@ -1973,14 +1988,14 @@ set_reduc_phi_uids (reduction_info **slot, void *data ATTRIBUTE_UNUSED)\n static void\n gather_scalar_reductions (loop_p loop, reduction_info_table_type *reduction_list)\n {\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n   loop_vec_info simple_loop_info;\n \n   simple_loop_info = vect_analyze_loop_form (loop);\n \n   for (gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n       affine_iv iv;\n       tree res = PHI_RESULT (phi);\n       bool double_reduc;\n@@ -2036,7 +2051,7 @@ try_create_reduction_list (loop_p loop,\n \t\t\t   reduction_info_table_type *reduction_list)\n {\n   edge exit = single_dom_exit (loop);\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n \n   gcc_assert (exit);\n \n@@ -2045,7 +2060,7 @@ try_create_reduction_list (loop_p loop,\n \n   for (gsi = gsi_start_phis (exit->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n       struct reduction_info *red;\n       imm_use_iterator imm_iter;\n       use_operand_p use_p;\n@@ -2103,7 +2118,7 @@ try_create_reduction_list (loop_p loop,\n      iteration space can be distributed efficiently.  */\n   for (gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n       tree def = PHI_RESULT (phi);\n       affine_iv iv;\n "}, {"sha": "90d60efc6b7f2339a04e7d5919fee5aa29691ad3", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -105,12 +105,12 @@ phinodes_print_statistics (void)\n    happens to contain a PHI node with LEN arguments or more, return\n    that one.  */\n \n-static inline gimple_statement_phi *\n+static inline gphi *\n allocate_phi_node (size_t len)\n {\n-  gimple_statement_phi *phi;\n+  gphi *phi;\n   size_t bucket = NUM_BUCKETS - 2;\n-  size_t size = sizeof (struct gimple_statement_phi)\n+  size_t size = sizeof (struct gphi)\n \t        + (len - 1) * sizeof (struct phi_arg_d);\n \n   if (free_phinode_count)\n@@ -123,16 +123,15 @@ allocate_phi_node (size_t len)\n       && gimple_phi_capacity ((*free_phinodes[bucket])[0]) >= len)\n     {\n       free_phinode_count--;\n-      phi = as_a <gimple_statement_phi *> (free_phinodes[bucket]->pop ());\n+      phi = as_a <gphi *> (free_phinodes[bucket]->pop ());\n       if (free_phinodes[bucket]->is_empty ())\n \tvec_free (free_phinodes[bucket]);\n       if (GATHER_STATISTICS)\n \tphi_nodes_reused++;\n     }\n   else\n     {\n-      phi = static_cast <gimple_statement_phi *> (\n-\tggc_internal_alloc (size));\n+      phi = static_cast <gphi *> (ggc_internal_alloc (size));\n       if (GATHER_STATISTICS)\n \t{\n \t  enum gimple_alloc_kind kind = gimple_alloc_kind (GIMPLE_PHI);\n@@ -166,7 +165,7 @@ ideal_phi_node_len (int len)\n     len = 2;\n \n   /* Compute the number of bytes of the original request.  */\n-  size = sizeof (struct gimple_statement_phi)\n+  size = sizeof (struct gphi)\n \t + (len - 1) * sizeof (struct phi_arg_d);\n \n   /* Round it up to the next power of two.  */\n@@ -181,10 +180,10 @@ ideal_phi_node_len (int len)\n \n /* Return a PHI node with LEN argument slots for variable VAR.  */\n \n-static gimple\n+static gphi *\n make_phi_node (tree var, int len)\n {\n-  gimple_statement_phi *phi;\n+  gphi *phi;\n   int capacity, i;\n \n   capacity = ideal_phi_node_len (len);\n@@ -194,7 +193,7 @@ make_phi_node (tree var, int len)\n   /* We need to clear the entire PHI node, including the argument\n      portion, because we represent a \"missing PHI argument\" by placing\n      NULL_TREE in PHI_ARG_DEF.  */\n-  memset (phi, 0, (sizeof (struct gimple_statement_phi)\n+  memset (phi, 0, (sizeof (struct gphi)\n \t\t   - sizeof (struct phi_arg_d)\n \t\t   + sizeof (struct phi_arg_d) * len));\n   phi->code = GIMPLE_PHI;\n@@ -249,18 +248,18 @@ release_phi_node (gimple phi)\n /* Resize an existing PHI node.  The only way is up.  Return the\n    possibly relocated phi.  */\n \n-static gimple_statement_phi *\n-resize_phi_node (gimple_statement_phi *phi, size_t len)\n+static gphi *\n+resize_phi_node (gphi *phi, size_t len)\n {\n   size_t old_size, i;\n-  gimple_statement_phi *new_phi;\n+  gphi *new_phi;\n \n   gcc_assert (len > gimple_phi_capacity (phi));\n \n   /* The garbage collector will not look at the PHI node beyond the\n      first PHI_NUM_ARGS elements.  Therefore, all we have to copy is a\n      portion of the PHI node currently in use.  */\n-  old_size = sizeof (struct gimple_statement_phi)\n+  old_size = sizeof (struct gphi)\n \t     + (gimple_phi_num_args (phi) - 1) * sizeof (struct phi_arg_d);\n \n   new_phi = allocate_phi_node (len);\n@@ -300,16 +299,15 @@ reserve_phi_args_for_new_edge (basic_block bb)\n {\n   size_t len = EDGE_COUNT (bb->preds);\n   size_t cap = ideal_phi_node_len (len + 4);\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n \n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple_statement_phi *stmt =\n-\tas_a <gimple_statement_phi *> (gsi_stmt (gsi));\n+      gphi *stmt = gsi.phi ();\n \n       if (len > gimple_phi_capacity (stmt))\n \t{\n-\t  gimple_statement_phi *new_phi = resize_phi_node (stmt, cap);\n+\t  gphi *new_phi = resize_phi_node (stmt, cap);\n \n \t  /* The result of the PHI is defined by this PHI node.  */\n \t  SSA_NAME_DEF_STMT (gimple_phi_result (new_phi)) = new_phi;\n@@ -336,7 +334,7 @@ reserve_phi_args_for_new_edge (basic_block bb)\n /* Adds PHI to BB.  */\n \n void\n-add_phi_node_to_bb (gimple phi, basic_block bb)\n+add_phi_node_to_bb (gphi *phi, basic_block bb)\n {\n   gimple_seq seq = phi_nodes (bb);\n   /* Add the new PHI node to the list of PHI nodes for block BB.  */\n@@ -355,10 +353,10 @@ add_phi_node_to_bb (gimple phi, basic_block bb)\n \n /* Create a new PHI node for variable VAR at basic block BB.  */\n \n-gimple\n+gphi *\n create_phi_node (tree var, basic_block bb)\n {\n-  gimple phi = make_phi_node (var, EDGE_COUNT (bb->preds));\n+  gphi *phi = make_phi_node (var, EDGE_COUNT (bb->preds));\n \n   add_phi_node_to_bb (phi, bb);\n   return phi;\n@@ -372,7 +370,7 @@ create_phi_node (tree var, basic_block bb)\n    PHI points to the reallocated phi node when we return.  */\n \n void\n-add_phi_arg (gimple phi, tree def, edge e, source_location locus)\n+add_phi_arg (gphi *phi, tree def, edge e, source_location locus)\n {\n   basic_block bb = e->dest;\n \n@@ -405,7 +403,7 @@ add_phi_arg (gimple phi, tree def, edge e, source_location locus)\n    is consistent with how we remove an edge from the edge vector.  */\n \n static void\n-remove_phi_arg_num (gimple_statement_phi *phi, int i)\n+remove_phi_arg_num (gphi *phi, int i)\n {\n   int num_elem = gimple_phi_num_args (phi);\n \n@@ -441,10 +439,10 @@ remove_phi_arg_num (gimple_statement_phi *phi, int i)\n void\n remove_phi_args (edge e)\n {\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n \n   for (gsi = gsi_start_phis (e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n-    remove_phi_arg_num (as_a <gimple_statement_phi *> (gsi_stmt (gsi)),\n+    remove_phi_arg_num (gsi.phi (),\n \t\t\te->dest_idx);\n }\n \n@@ -476,7 +474,7 @@ remove_phi_node (gimple_stmt_iterator *gsi, bool release_lhs_p)\n void\n remove_phi_nodes (basic_block bb)\n {\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n \n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); )\n     remove_phi_node (&gsi, true);\n@@ -488,7 +486,7 @@ remove_phi_nodes (basic_block bb)\n    NULL.  */\n \n tree\n-degenerate_phi_result (gimple phi)\n+degenerate_phi_result (gphi *phi)\n {\n   tree lhs = gimple_phi_result (phi);\n   tree val = NULL;"}, {"sha": "c35acc149bcfc7e7261a19d4860f60a4ec172e4b", "filename": "gcc/tree-phinodes.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-phinodes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-phinodes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -23,13 +23,13 @@ along with GCC; see the file COPYING3.  If not see\n extern void phinodes_print_statistics (void);\n extern void release_phi_node (gimple);\n extern void reserve_phi_args_for_new_edge (basic_block);\n-extern void add_phi_node_to_bb (gimple phi, basic_block bb);\n-extern gimple create_phi_node (tree, basic_block);\n-extern void add_phi_arg (gimple, tree, edge, source_location);\n+extern void add_phi_node_to_bb (gphi *phi, basic_block bb);\n+extern gphi *create_phi_node (tree, basic_block);\n+extern void add_phi_arg (gphi *, tree, edge, source_location);\n extern void remove_phi_args (edge);\n extern void remove_phi_node (gimple_stmt_iterator *, bool);\n extern void remove_phi_nodes (basic_block);\n-extern tree degenerate_phi_result (gimple);\n+extern tree degenerate_phi_result (gphi *);\n extern void set_phi_nodes (basic_block, gimple_seq);\n \n static inline use_operand_p"}, {"sha": "93a523ca2ca430ebf94d05f56a3a3cccd834e89c", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -1122,14 +1122,15 @@ valid_initializer_p (struct data_reference *ref,\n    iteration), returns the phi node.  Otherwise, NULL_TREE is returned.  ROOT\n    is the root of the current chain.  */\n \n-static gimple\n+static gphi *\n find_looparound_phi (struct loop *loop, dref ref, dref root)\n {\n   tree name, init, init_ref;\n-  gimple phi = NULL, init_stmt;\n+  gphi *phi = NULL;\n+  gimple init_stmt;\n   edge latch = loop_latch_edge (loop);\n   struct data_reference init_dr;\n-  gimple_stmt_iterator psi;\n+  gphi_iterator psi;\n \n   if (is_gimple_assign (ref->stmt))\n     {\n@@ -1145,7 +1146,7 @@ find_looparound_phi (struct loop *loop, dref ref, dref root)\n \n   for (psi = gsi_start_phis (loop->header); !gsi_end_p (psi); gsi_next (&psi))\n     {\n-      phi = gsi_stmt (psi);\n+      phi = psi.phi ();\n       if (PHI_ARG_DEF_FROM_EDGE (phi, latch) == name)\n \tbreak;\n     }\n@@ -1183,7 +1184,7 @@ find_looparound_phi (struct loop *loop, dref ref, dref root)\n /* Adds a reference for the looparound copy of REF in PHI to CHAIN.  */\n \n static void\n-insert_looparound_copy (chain_p chain, dref ref, gimple phi)\n+insert_looparound_copy (chain_p chain, dref ref, gphi *phi)\n {\n   dref nw = XCNEW (struct dref_d), aref;\n   unsigned i;\n@@ -1214,7 +1215,7 @@ add_looparound_copies (struct loop *loop, chain_p chain)\n {\n   unsigned i;\n   dref ref, root = get_chain_root (chain);\n-  gimple phi;\n+  gphi *phi;\n \n   FOR_EACH_VEC_ELT (chain->refs, i, ref)\n     {\n@@ -1302,7 +1303,7 @@ static void\n replace_ref_with (gimple stmt, tree new_tree, bool set, bool in_lhs)\n {\n   tree val;\n-  gimple new_stmt;\n+  gassign *new_stmt;\n   gimple_stmt_iterator bsi, psi;\n \n   if (gimple_code (stmt) == GIMPLE_PHI)\n@@ -1466,7 +1467,7 @@ initialize_root_vars (struct loop *loop, chain_p chain, bitmap tmp_vars)\n   dref root = get_chain_root (chain);\n   bool reuse_first = !chain->has_max_use_after;\n   tree ref, init, var, next;\n-  gimple phi;\n+  gphi *phi;\n   gimple_seq stmts;\n   edge entry = loop_preheader_edge (loop), latch = loop_latch_edge (loop);\n \n@@ -1540,7 +1541,7 @@ initialize_root_vars_lm (struct loop *loop, dref root, bool written,\n   unsigned i;\n   tree ref = DR_REF (root->ref), init, var, next;\n   gimple_seq stmts;\n-  gimple phi;\n+  gphi *phi;\n   edge entry = loop_preheader_edge (loop), latch = loop_latch_edge (loop);\n \n   /* Find the initializer for the variable, and check that it cannot\n@@ -1571,7 +1572,7 @@ initialize_root_vars_lm (struct loop *loop, dref root, bool written,\n     }\n   else\n     {\n-      gimple init_stmt = gimple_build_assign (var, init);\n+      gassign *init_stmt = gimple_build_assign (var, init);\n       gsi_insert_on_edge_immediate (entry, init_stmt);\n     }\n }\n@@ -1897,14 +1898,15 @@ static void\n eliminate_temp_copies (struct loop *loop, bitmap tmp_vars)\n {\n   edge e;\n-  gimple phi, stmt;\n+  gphi *phi;\n+  gimple stmt;\n   tree name, use, var;\n-  gimple_stmt_iterator psi;\n+  gphi_iterator psi;\n \n   e = loop_latch_edge (loop);\n   for (psi = gsi_start_phis (loop->header); !gsi_end_p (psi); gsi_next (&psi))\n     {\n-      phi = gsi_stmt (psi);\n+      phi = psi.phi ();\n       name = PHI_RESULT (phi);\n       var = SSA_NAME_VAR (name);\n       if (!var || !bitmap_bit_p (tmp_vars, DECL_UID (var)))\n@@ -2137,7 +2139,7 @@ static gimple\n reassociate_to_the_same_stmt (tree name1, tree name2)\n {\n   gimple stmt1, stmt2, root1, root2, s1, s2;\n-  gimple new_stmt, tmp_stmt;\n+  gassign *new_stmt, *tmp_stmt;\n   tree new_name, tmp_name, var, r1, r2;\n   unsigned dist1, dist2;\n   enum tree_code code;"}, {"sha": "73844e81d16c8f99be9f58eb225f5d0bc6684b54", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -306,7 +306,7 @@ void\n gimple_gen_edge_profiler (int edgeno, edge e)\n {\n   tree ref, one, gcov_type_tmp_var;\n-  gimple stmt1, stmt2, stmt3;\n+  gassign *stmt1, *stmt2, *stmt3;\n \n   ref = tree_coverage_counter_ref (GCOV_COUNTER_ARCS, edgeno);\n   one = build_int_cst (gcov_type_node, 1);\n@@ -347,7 +347,7 @@ gimple_gen_interval_profiler (histogram_value value, unsigned tag, unsigned base\n   gimple stmt = value->hvalue.stmt;\n   gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n   tree ref = tree_coverage_counter_ref (tag, base), ref_ptr;\n-  gimple call;\n+  gcall *call;\n   tree val;\n   tree start = build_int_cst_type (integer_type_node,\n \t\t\t\t   value->hdata.intvl.int_start);\n@@ -373,7 +373,7 @@ gimple_gen_pow2_profiler (histogram_value value, unsigned tag, unsigned base)\n   gimple stmt = value->hvalue.stmt;\n   gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n   tree ref_ptr = tree_coverage_counter_addr (tag, base);\n-  gimple call;\n+  gcall *call;\n   tree val;\n \n   ref_ptr = force_gimple_operand_gsi (&gsi, ref_ptr,\n@@ -393,7 +393,7 @@ gimple_gen_one_value_profiler (histogram_value value, unsigned tag, unsigned bas\n   gimple stmt = value->hvalue.stmt;\n   gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n   tree ref_ptr = tree_coverage_counter_addr (tag, base);\n-  gimple call;\n+  gcall *call;\n   tree val;\n \n   ref_ptr = force_gimple_operand_gsi (&gsi, ref_ptr,\n@@ -414,7 +414,7 @@ void\n gimple_gen_ic_profiler (histogram_value value, unsigned tag, unsigned base)\n {\n   tree tmp1;\n-  gimple stmt1, stmt2, stmt3;\n+  gassign *stmt1, *stmt2, *stmt3;\n   gimple stmt = value->hvalue.stmt;\n   gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n   tree ref_ptr = tree_coverage_counter_addr (tag, base);\n@@ -456,7 +456,8 @@ gimple_gen_ic_func_profiler (void)\n {\n   struct cgraph_node * c_node = cgraph_node::get (current_function_decl);\n   gimple_stmt_iterator gsi;\n-  gimple stmt1, stmt2;\n+  gcall *stmt1;\n+  gassign *stmt2;\n   tree tree_uid, cur_func, void0;\n \n   if (c_node->only_called_directly_p ())\n@@ -516,7 +517,7 @@ gimple_gen_time_profiler (unsigned tag, unsigned base,\n                           gimple_stmt_iterator &gsi)\n {\n   tree ref_ptr = tree_coverage_counter_addr (tag, base);\n-  gimple call;\n+  gcall *call;\n \n   ref_ptr = force_gimple_operand_gsi (&gsi, ref_ptr,\n \t\t\t\t      true, NULL_TREE, true, GSI_SAME_STMT);\n@@ -551,7 +552,7 @@ gimple_gen_average_profiler (histogram_value value, unsigned tag, unsigned base)\n   gimple stmt = value->hvalue.stmt;\n   gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n   tree ref_ptr = tree_coverage_counter_addr (tag, base);\n-  gimple call;\n+  gcall *call;\n   tree val;\n \n   ref_ptr = force_gimple_operand_gsi (&gsi, ref_ptr,\n@@ -572,7 +573,7 @@ gimple_gen_ior_profiler (histogram_value value, unsigned tag, unsigned base)\n   gimple stmt = value->hvalue.stmt;\n   gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n   tree ref_ptr = tree_coverage_counter_addr (tag, base);\n-  gimple call;\n+  gcall *call;\n   tree val;\n \n   ref_ptr = force_gimple_operand_gsi (&gsi, ref_ptr,"}, {"sha": "46463152ed5bc606667636d20f01d0172da2108d", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 48, "deletions": 39, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -878,10 +878,10 @@ add_to_evolution (unsigned loop_nb, tree chrec_before, enum tree_code code,\n    guards the exit edge.  If the expression is too difficult to\n    analyze, then give up.  */\n \n-gimple\n+gcond *\n get_loop_exit_condition (const struct loop *loop)\n {\n-  gimple res = NULL;\n+  gcond *res = NULL;\n   edge exit_edge = single_exit (loop);\n \n   if (dump_file && (dump_flags & TDF_SCEV))\n@@ -892,8 +892,8 @@ get_loop_exit_condition (const struct loop *loop)\n       gimple stmt;\n \n       stmt = last_stmt (exit_edge->src);\n-      if (gimple_code (stmt) == GIMPLE_COND)\n-\tres = stmt;\n+      if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n+\tres = cond_stmt;\n     }\n \n   if (dump_file && (dump_flags & TDF_SCEV))\n@@ -915,15 +915,17 @@ typedef enum t_bool {\n } t_bool;\n \n \n-static t_bool follow_ssa_edge (struct loop *loop, gimple, gimple, tree *, int);\n+static t_bool follow_ssa_edge (struct loop *loop, gimple, gphi *,\n+\t\t\t       tree *, int);\n \n /* Follow the ssa edge into the binary expression RHS0 CODE RHS1.\n    Return true if the strongly connected component has been found.  */\n \n static t_bool\n follow_ssa_edge_binary (struct loop *loop, gimple at_stmt,\n \t\t\ttree type, tree rhs0, enum tree_code code, tree rhs1,\n-\t\t\tgimple halting_phi, tree *evolution_of_loop, int limit)\n+\t\t\tgphi *halting_phi, tree *evolution_of_loop,\n+\t\t\tint limit)\n {\n   t_bool res = t_false;\n   tree evol;\n@@ -1058,7 +1060,8 @@ follow_ssa_edge_binary (struct loop *loop, gimple at_stmt,\n \n static t_bool\n follow_ssa_edge_expr (struct loop *loop, gimple at_stmt, tree expr,\n-\t\t      gimple halting_phi, tree *evolution_of_loop, int limit)\n+\t\t      gphi *halting_phi, tree *evolution_of_loop,\n+\t\t      int limit)\n {\n   enum tree_code code = TREE_CODE (expr);\n   tree type = TREE_TYPE (expr), rhs0, rhs1;\n@@ -1148,7 +1151,8 @@ follow_ssa_edge_expr (struct loop *loop, gimple at_stmt, tree expr,\n \n static t_bool\n follow_ssa_edge_in_rhs (struct loop *loop, gimple stmt,\n-\t\t\tgimple halting_phi, tree *evolution_of_loop, int limit)\n+\t\t\tgphi *halting_phi, tree *evolution_of_loop,\n+\t\t\tint limit)\n {\n   enum tree_code code = gimple_assign_rhs_code (stmt);\n   tree type = gimple_expr_type (stmt), rhs1, rhs2;\n@@ -1188,7 +1192,7 @@ follow_ssa_edge_in_rhs (struct loop *loop, gimple stmt,\n /* Checks whether the I-th argument of a PHI comes from a backedge.  */\n \n static bool\n-backedge_phi_arg_p (gimple phi, int i)\n+backedge_phi_arg_p (gphi *phi, int i)\n {\n   const_edge e = gimple_phi_arg_edge (phi, i);\n \n@@ -1208,8 +1212,8 @@ backedge_phi_arg_p (gimple phi, int i)\n static inline t_bool\n follow_ssa_edge_in_condition_phi_branch (int i,\n \t\t\t\t\t struct loop *loop,\n-\t\t\t\t\t gimple condition_phi,\n-\t\t\t\t\t gimple halting_phi,\n+\t\t\t\t\t gphi *condition_phi,\n+\t\t\t\t\t gphi *halting_phi,\n \t\t\t\t\t tree *evolution_of_branch,\n \t\t\t\t\t tree init_cond, int limit)\n {\n@@ -1243,8 +1247,8 @@ follow_ssa_edge_in_condition_phi_branch (int i,\n \n static t_bool\n follow_ssa_edge_in_condition_phi (struct loop *loop,\n-\t\t\t\t  gimple condition_phi,\n-\t\t\t\t  gimple halting_phi,\n+\t\t\t\t  gphi *condition_phi,\n+\t\t\t\t  gphi *halting_phi,\n \t\t\t\t  tree *evolution_of_loop, int limit)\n {\n   int i, n;\n@@ -1290,8 +1294,8 @@ follow_ssa_edge_in_condition_phi (struct loop *loop,\n \n static t_bool\n follow_ssa_edge_inner_loop_phi (struct loop *outer_loop,\n-\t\t\t\tgimple loop_phi_node,\n-\t\t\t\tgimple halting_phi,\n+\t\t\t\tgphi *loop_phi_node,\n+\t\t\t\tgphi *halting_phi,\n \t\t\t\ttree *evolution_of_loop, int limit)\n {\n   struct loop *loop = loop_containing_stmt (loop_phi_node);\n@@ -1336,7 +1340,7 @@ follow_ssa_edge_inner_loop_phi (struct loop *outer_loop,\n    path that is analyzed on the return walk.  */\n \n static t_bool\n-follow_ssa_edge (struct loop *loop, gimple def, gimple halting_phi,\n+follow_ssa_edge (struct loop *loop, gimple def, gphi *halting_phi,\n \t\t tree *evolution_of_loop, int limit)\n {\n   struct loop *def_loop;\n@@ -1359,7 +1363,8 @@ follow_ssa_edge (struct loop *loop, gimple def, gimple halting_phi,\n \t   information and set the approximation to the main\n \t   variable.  */\n \treturn follow_ssa_edge_in_condition_phi\n-\t  (loop, def, halting_phi, evolution_of_loop, limit);\n+\t  (loop, as_a <gphi *> (def), halting_phi, evolution_of_loop,\n+\t   limit);\n \n       /* When the analyzed phi is the halting_phi, the\n \t depth-first search is over: we have found a path from\n@@ -1376,7 +1381,8 @@ follow_ssa_edge (struct loop *loop, gimple def, gimple halting_phi,\n       /* Inner loop.  */\n       if (flow_loop_nested_p (loop, def_loop))\n \treturn follow_ssa_edge_inner_loop_phi\n-\t  (loop, def, halting_phi, evolution_of_loop, limit + 1);\n+\t  (loop, as_a <gphi *> (def), halting_phi, evolution_of_loop,\n+\t   limit + 1);\n \n       /* Outer loop.  */\n       return t_false;\n@@ -1457,7 +1463,7 @@ simplify_peeled_chrec (struct loop *loop, tree arg, tree init_cond)\n    function from LOOP_PHI_NODE to LOOP_PHI_NODE in the loop.  */\n \n static tree\n-analyze_evolution_in_loop (gimple loop_phi_node,\n+analyze_evolution_in_loop (gphi *loop_phi_node,\n \t\t\t   tree init_cond)\n {\n   int i, n = gimple_phi_num_args (loop_phi_node);\n@@ -1552,7 +1558,7 @@ analyze_evolution_in_loop (gimple loop_phi_node,\n    loop, and leaves this task to the on-demand tree reconstructor.  */\n \n static tree\n-analyze_initial_condition (gimple loop_phi_node)\n+analyze_initial_condition (gphi *loop_phi_node)\n {\n   int i, n;\n   tree init_cond = chrec_not_analyzed_yet;\n@@ -1601,13 +1607,15 @@ analyze_initial_condition (gimple loop_phi_node)\n   if (TREE_CODE (init_cond) == SSA_NAME)\n     {\n       gimple def = SSA_NAME_DEF_STMT (init_cond);\n-      tree res;\n-      if (gimple_code (def) == GIMPLE_PHI\n-\t  && (res = degenerate_phi_result (def)) != NULL_TREE\n-\t  /* Only allow invariants here, otherwise we may break\n-\t     loop-closed SSA form.  */\n-\t  && is_gimple_min_invariant (res))\n-\tinit_cond = res;\n+      if (gphi *phi = dyn_cast <gphi *> (def))\n+\t{\n+\t  tree res = degenerate_phi_result (phi);\n+\t  if (res != NULL_TREE\n+\t      /* Only allow invariants here, otherwise we may break\n+\t\t loop-closed SSA form.  */\n+\t      && is_gimple_min_invariant (res))\n+\t    init_cond = res;\n+\t}\n     }\n \n   if (dump_file && (dump_flags & TDF_SCEV))\n@@ -1623,7 +1631,7 @@ analyze_initial_condition (gimple loop_phi_node)\n /* Analyze the scalar evolution for LOOP_PHI_NODE.  */\n \n static tree\n-interpret_loop_phi (struct loop *loop, gimple loop_phi_node)\n+interpret_loop_phi (struct loop *loop, gphi *loop_phi_node)\n {\n   tree res;\n   struct loop *phi_loop = loop_containing_stmt (loop_phi_node);\n@@ -1672,7 +1680,7 @@ interpret_loop_phi (struct loop *loop, gimple loop_phi_node)\n    analyzed.  */\n \n static tree\n-interpret_condition_phi (struct loop *loop, gimple condition_phi)\n+interpret_condition_phi (struct loop *loop, gphi *condition_phi)\n {\n   int i, n = gimple_phi_num_args (condition_phi);\n   tree res = chrec_not_analyzed_yet;\n@@ -2000,9 +2008,9 @@ analyze_scalar_evolution_1 (struct loop *loop, tree var, tree res)\n \n     case GIMPLE_PHI:\n       if (loop_phi_node_p (def))\n-\tres = interpret_loop_phi (loop, def);\n+\tres = interpret_loop_phi (loop, as_a <gphi *> (def));\n       else\n-\tres = interpret_condition_phi (loop, def);\n+\tres = interpret_condition_phi (loop, as_a <gphi *> (def));\n       break;\n \n     default:\n@@ -2249,8 +2257,8 @@ loop_closed_phi_def (tree var)\n {\n   struct loop *loop;\n   edge exit;\n-  gimple phi;\n-  gimple_stmt_iterator psi;\n+  gphi *phi;\n+  gphi_iterator psi;\n \n   if (var == NULL_TREE\n       || TREE_CODE (var) != SSA_NAME)\n@@ -2263,7 +2271,7 @@ loop_closed_phi_def (tree var)\n \n   for (psi = gsi_start_phis (exit->dest); !gsi_end_p (psi); gsi_next (&psi))\n     {\n-      phi = gsi_stmt (psi);\n+      phi = psi.phi ();\n       if (PHI_ARG_DEF_FROM_EDGE (phi, exit) == var)\n \treturn PHI_RESULT (phi);\n     }\n@@ -3349,11 +3357,12 @@ scev_const_prop (void)\n {\n   basic_block bb;\n   tree name, type, ev;\n-  gimple phi, ass;\n+  gphi *phi;\n+  gassign *ass;\n   struct loop *loop, *ex_loop;\n   bitmap ssa_names_to_remove = NULL;\n   unsigned i;\n-  gimple_stmt_iterator psi;\n+  gphi_iterator psi;\n \n   if (number_of_loops (cfun) <= 1)\n     return 0;\n@@ -3364,7 +3373,7 @@ scev_const_prop (void)\n \n       for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n \t{\n-\t  phi = gsi_stmt (psi);\n+\t  phi = psi.phi ();\n \t  name = PHI_RESULT (phi);\n \n \t  if (virtual_operand_p (name))\n@@ -3402,7 +3411,7 @@ scev_const_prop (void)\n \t{\n \t  gimple_stmt_iterator psi;\n \t  name = ssa_name (i);\n-\t  phi = SSA_NAME_DEF_STMT (name);\n+\t  phi = as_a <gphi *> (SSA_NAME_DEF_STMT (name));\n \n \t  gcc_assert (gimple_code (phi) == GIMPLE_PHI);\n \t  psi = gsi_for_stmt (phi);\n@@ -3440,7 +3449,7 @@ scev_const_prop (void)\n \n       for (psi = gsi_start_phis (exit->dest); !gsi_end_p (psi); )\n \t{\n-\t  phi = gsi_stmt (psi);\n+\t  phi = psi.phi ();\n \t  rslt = PHI_RESULT (phi);\n \t  def = PHI_ARG_DEF_FROM_EDGE (phi, exit);\n \t  if (virtual_operand_p (def))"}, {"sha": "f96da994ee45dfa0feb6b5699c46173550000caf", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -22,7 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_TREE_SCALAR_EVOLUTION_H\n \n extern tree number_of_latch_executions (struct loop *);\n-extern gimple get_loop_exit_condition (const struct loop *);\n+extern gcond *get_loop_exit_condition (const struct loop *);\n \n extern void scev_initialize (void);\n extern bool scev_initialized_p (void);"}, {"sha": "8e4b94c1e9562fd1525eac8f8634b794ad10d397", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 68, "deletions": 56, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -1293,7 +1293,7 @@ scan_function (void)\n \t  switch (gimple_code (stmt))\n \t    {\n \t    case GIMPLE_RETURN:\n-\t      t = gimple_return_retval (stmt);\n+\t      t = gimple_return_retval (as_a <greturn *> (stmt));\n \t      if (t != NULL_TREE)\n \t\tret |= build_access_from_expr (t, stmt, false);\n \t      if (final_bbs)\n@@ -1338,21 +1338,24 @@ scan_function (void)\n \t      break;\n \n \t    case GIMPLE_ASM:\n-\t      walk_stmt_load_store_addr_ops (stmt, NULL, NULL, NULL,\n-\t\t\t\t\t     asm_visit_addr);\n-\t      if (final_bbs)\n-\t\tbitmap_set_bit (final_bbs, bb->index);\n+\t      {\n+\t\tgasm *asm_stmt = as_a <gasm *> (stmt);\n+\t\twalk_stmt_load_store_addr_ops (asm_stmt, NULL, NULL, NULL,\n+\t\t\t\t\t       asm_visit_addr);\n+\t\tif (final_bbs)\n+\t\t  bitmap_set_bit (final_bbs, bb->index);\n \n-\t      for (i = 0; i < gimple_asm_ninputs (stmt); i++)\n-\t\t{\n-\t\t  t = TREE_VALUE (gimple_asm_input_op (stmt, i));\n-\t\t  ret |= build_access_from_expr (t, stmt, false);\n-\t\t}\n-\t      for (i = 0; i < gimple_asm_noutputs (stmt); i++)\n-\t\t{\n-\t\t  t = TREE_VALUE (gimple_asm_output_op (stmt, i));\n-\t\t  ret |= build_access_from_expr (t, stmt, true);\n-\t\t}\n+\t\tfor (i = 0; i < gimple_asm_ninputs (asm_stmt); i++)\n+\t\t  {\n+\t\t    t = TREE_VALUE (gimple_asm_input_op (asm_stmt, i));\n+\t\t    ret |= build_access_from_expr (t, asm_stmt, false);\n+\t\t  }\n+\t\tfor (i = 0; i < gimple_asm_noutputs (asm_stmt); i++)\n+\t\t  {\n+\t\t    t = TREE_VALUE (gimple_asm_output_op (asm_stmt, i));\n+\t\t    ret |= build_access_from_expr (t, asm_stmt, true);\n+\t\t  }\n+\t      }\n \t      break;\n \n \t    default:\n@@ -1541,7 +1544,7 @@ build_ref_for_offset (location_t loc, tree base, HOST_WIDE_INT offset,\n      offset such as array[var_index].  */\n   if (!base)\n     {\n-      gimple stmt;\n+      gassign *stmt;\n       tree tmp, addr;\n \n       gcc_checking_assert (gsi);\n@@ -2625,7 +2628,7 @@ generate_subtree_copies (struct access *access, tree agg,\n \t      || access->offset + access->size > start_offset))\n \t{\n \t  tree expr, repl = get_access_replacement (access);\n-\t  gimple stmt;\n+\t  gassign *stmt;\n \n \t  expr = build_ref_for_model (loc, agg, access->offset - top_offset,\n \t\t\t\t      access, gsi, insert_after);\n@@ -2663,7 +2666,7 @@ generate_subtree_copies (struct access *access, tree agg,\n \t       && (chunk_size == 0\n \t\t   || access->offset + access->size > start_offset))\n \t{\n-\t  gimple ds;\n+\t  gdebug *ds;\n \t  tree drhs = build_debug_ref_for_model (loc, agg,\n \t\t\t\t\t\t access->offset - top_offset,\n \t\t\t\t\t\t access);\n@@ -2699,7 +2702,7 @@ init_subtree_with_zero (struct access *access, gimple_stmt_iterator *gsi,\n \n   if (access->grp_to_be_replaced)\n     {\n-      gimple stmt;\n+      gassign *stmt;\n \n       stmt = gimple_build_assign (get_access_replacement (access),\n \t\t\t\t  build_zero_cst (access->type));\n@@ -2712,9 +2715,10 @@ init_subtree_with_zero (struct access *access, gimple_stmt_iterator *gsi,\n     }\n   else if (access->grp_to_be_debug_replaced)\n     {\n-      gimple ds = gimple_build_debug_bind (get_access_replacement (access),\n-\t\t\t\t\t   build_zero_cst (access->type),\n-\t\t\t\t\t   gsi_stmt (*gsi));\n+      gdebug *ds\n+\t= gimple_build_debug_bind (get_access_replacement (access),\n+\t\t\t\t   build_zero_cst (access->type),\n+\t\t\t\t   gsi_stmt (*gsi));\n       if (insert_after)\n \tgsi_insert_after (gsi, ds, GSI_NEW_STMT);\n       else\n@@ -2808,7 +2812,7 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)\n \n \t  if (write)\n \t    {\n-\t      gimple stmt;\n+\t      gassign *stmt;\n \n \t      if (access->grp_partial_lhs)\n \t\tref = force_gimple_operand_gsi (gsi, ref, true, NULL_TREE,\n@@ -2819,7 +2823,7 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)\n \t    }\n \t  else\n \t    {\n-\t      gimple stmt;\n+\t      gassign *stmt;\n \n \t      if (access->grp_partial_lhs)\n \t\trepl = force_gimple_operand_gsi (gsi, repl, true, NULL_TREE,\n@@ -2835,9 +2839,9 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)\n     }\n   else if (write && access->grp_to_be_debug_replaced)\n     {\n-      gimple ds = gimple_build_debug_bind (get_access_replacement (access),\n-\t\t\t\t\t   NULL_TREE,\n-\t\t\t\t\t   gsi_stmt (*gsi));\n+      gdebug *ds = gimple_build_debug_bind (get_access_replacement (access),\n+\t\t\t\t\t    NULL_TREE,\n+\t\t\t\t\t    gsi_stmt (*gsi));\n       gsi_insert_after (gsi, ds, GSI_NEW_STMT);\n     }\n \n@@ -2937,7 +2941,7 @@ load_assign_lhs_subreplacements (struct access *lacc,\n       if (lacc->grp_to_be_replaced)\n \t{\n \t  struct access *racc;\n-\t  gimple stmt;\n+\t  gassign *stmt;\n \t  tree rhs;\n \n \t  racc = find_access_in_subtree (sad->top_racc, offset, lacc->size);\n@@ -2987,7 +2991,7 @@ load_assign_lhs_subreplacements (struct access *lacc,\n \n \t  if (lacc && lacc->grp_to_be_debug_replaced)\n \t    {\n-\t      gimple ds;\n+\t      gdebug *ds;\n \t      tree drhs;\n \t      struct access *racc = find_access_in_subtree (sad->top_racc,\n \t\t\t\t\t\t\t    offset,\n@@ -3229,7 +3233,7 @@ sra_modify_assign (gimple stmt, gimple_stmt_iterator *gsi)\n \t    drhs = fold_build1_loc (loc, VIEW_CONVERT_EXPR,\n \t\t\t\t    TREE_TYPE (dlhs), drhs);\n \t}\n-      gimple ds = gimple_build_debug_bind (dlhs, drhs, stmt);\n+      gdebug *ds = gimple_build_debug_bind (dlhs, drhs, stmt);\n       gsi_insert_before (gsi, ds, GSI_SAME_STMT);\n     }\n \n@@ -3399,7 +3403,7 @@ sra_modify_function_body (void)\n \t  switch (gimple_code (stmt))\n \t    {\n \t    case GIMPLE_RETURN:\n-\t      t = gimple_return_retval_ptr (stmt);\n+\t      t = gimple_return_retval_ptr (as_a <greturn *> (stmt));\n \t      if (*t != NULL_TREE)\n \t\tmodified |= sra_modify_expr (t, &gsi, false);\n \t      break;\n@@ -3426,16 +3430,19 @@ sra_modify_function_body (void)\n \t      break;\n \n \t    case GIMPLE_ASM:\n-\t      for (i = 0; i < gimple_asm_ninputs (stmt); i++)\n-\t\t{\n-\t\t  t = &TREE_VALUE (gimple_asm_input_op (stmt, i));\n-\t\t  modified |= sra_modify_expr (t, &gsi, false);\n-\t\t}\n-\t      for (i = 0; i < gimple_asm_noutputs (stmt); i++)\n-\t\t{\n-\t\t  t = &TREE_VALUE (gimple_asm_output_op (stmt, i));\n-\t\t  modified |= sra_modify_expr (t, &gsi, true);\n-\t\t}\n+\t      {\n+\t\tgasm *asm_stmt = as_a <gasm *> (stmt);\n+\t\tfor (i = 0; i < gimple_asm_ninputs (asm_stmt); i++)\n+\t\t  {\n+\t\t    t = &TREE_VALUE (gimple_asm_input_op (asm_stmt, i));\n+\t\t    modified |= sra_modify_expr (t, &gsi, false);\n+\t\t  }\n+\t\tfor (i = 0; i < gimple_asm_noutputs (asm_stmt); i++)\n+\t\t  {\n+\t\t    t = &TREE_VALUE (gimple_asm_output_op (asm_stmt, i));\n+\t\t    modified |= sra_modify_expr (t, &gsi, true);\n+\t\t  }\n+\t      }\n \t      break;\n \n \t    default:\n@@ -4563,7 +4570,7 @@ replace_removed_params_ssa_names (gimple stmt,\n   else if (is_gimple_call (stmt))\n     gimple_call_set_lhs (stmt, name);\n   else\n-    gimple_phi_set_result (stmt, name);\n+    gimple_phi_set_result (as_a <gphi *> (stmt), name);\n \n   replace_uses_by (lhs, name);\n   release_ssa_name (lhs);\n@@ -4659,7 +4666,7 @@ ipa_sra_modify_function_body (ipa_parm_adjustment_vec adjustments)\n \t  switch (gimple_code (stmt))\n \t    {\n \t    case GIMPLE_RETURN:\n-\t      t = gimple_return_retval_ptr (stmt);\n+\t      t = gimple_return_retval_ptr (as_a <greturn *> (stmt));\n \t      if (*t != NULL_TREE)\n \t\tmodified |= ipa_modify_expr (t, true, adjustments);\n \t      break;\n@@ -4687,16 +4694,19 @@ ipa_sra_modify_function_body (ipa_parm_adjustment_vec adjustments)\n \t      break;\n \n \t    case GIMPLE_ASM:\n-\t      for (i = 0; i < gimple_asm_ninputs (stmt); i++)\n-\t\t{\n-\t\t  t = &TREE_VALUE (gimple_asm_input_op (stmt, i));\n-\t\t  modified |= ipa_modify_expr (t, true, adjustments);\n-\t\t}\n-\t      for (i = 0; i < gimple_asm_noutputs (stmt); i++)\n-\t\t{\n-\t\t  t = &TREE_VALUE (gimple_asm_output_op (stmt, i));\n-\t\t  modified |= ipa_modify_expr (t, false, adjustments);\n-\t\t}\n+\t      {\n+\t\tgasm *asm_stmt = as_a <gasm *> (stmt);\n+\t\tfor (i = 0; i < gimple_asm_ninputs (asm_stmt); i++)\n+\t\t  {\n+\t\t    t = &TREE_VALUE (gimple_asm_input_op (asm_stmt, i));\n+\t\t    modified |= ipa_modify_expr (t, true, adjustments);\n+\t\t  }\n+\t\tfor (i = 0; i < gimple_asm_noutputs (asm_stmt); i++)\n+\t\t  {\n+\t\t    t = &TREE_VALUE (gimple_asm_output_op (asm_stmt, i));\n+\t\t    modified |= ipa_modify_expr (t, false, adjustments);\n+\t\t  }\n+\t      }\n \t      break;\n \n \t    default:\n@@ -4736,7 +4746,8 @@ sra_ipa_reset_debug_stmts (ipa_parm_adjustment_vec adjustments)\n     {\n       struct ipa_parm_adjustment *adj;\n       imm_use_iterator ui;\n-      gimple stmt, def_temp;\n+      gimple stmt;\n+      gdebug *def_temp;\n       tree name, vexpr, copy = NULL_TREE;\n       use_operand_p use_p;\n \n@@ -4887,9 +4898,10 @@ convert_callers (struct cgraph_node *node, tree old_decl,\n \n       for (gsi = gsi_start_bb (this_block); !gsi_end_p (gsi); gsi_next (&gsi))\n         {\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gcall *stmt;\n \t  tree call_fndecl;\n-\t  if (gimple_code (stmt) != GIMPLE_CALL)\n+\t  stmt = dyn_cast <gcall *> (gsi_stmt (gsi));\n+\t  if (!stmt)\n \t    continue;\n \t  call_fndecl = gimple_call_fndecl (stmt);\n \t  if (call_fndecl == old_decl)"}, {"sha": "a122898c2bb159c95408d34fc40e2ecec75a3c7e", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -1490,7 +1490,7 @@ refs_output_dependent_p (tree store1, tree store2)\n    otherwise return false.  */\n \n static bool\n-ref_maybe_used_by_call_p_1 (gimple call, ao_ref *ref)\n+ref_maybe_used_by_call_p_1 (gcall *call, ao_ref *ref)\n {\n   tree base, callee;\n   unsigned i;\n@@ -1803,7 +1803,7 @@ ref_maybe_used_by_call_p_1 (gimple call, ao_ref *ref)\n }\n \n static bool\n-ref_maybe_used_by_call_p (gimple call, ao_ref *ref)\n+ref_maybe_used_by_call_p (gcall *call, ao_ref *ref)\n {\n   bool res;\n   res = ref_maybe_used_by_call_p_1 (call, ref);\n@@ -1838,10 +1838,10 @@ ref_maybe_used_by_stmt_p (gimple stmt, ao_ref *ref)\n       return refs_may_alias_p (rhs, ref);\n     }\n   else if (is_gimple_call (stmt))\n-    return ref_maybe_used_by_call_p (stmt, ref);\n-  else if (gimple_code (stmt) == GIMPLE_RETURN)\n+    return ref_maybe_used_by_call_p (as_a <gcall *> (stmt), ref);\n+  else if (greturn *return_stmt = dyn_cast <greturn *> (stmt))\n     {\n-      tree retval = gimple_return_retval (stmt);\n+      tree retval = gimple_return_retval (return_stmt);\n       if (retval\n \t  && TREE_CODE (retval) != SSA_NAME\n \t  && !is_gimple_min_invariant (retval)\n@@ -1874,7 +1874,7 @@ ref_maybe_used_by_stmt_p (gimple stmt, tree ref)\n    return true, otherwise return false.  */\n \n bool\n-call_may_clobber_ref_p_1 (gimple call, ao_ref *ref)\n+call_may_clobber_ref_p_1 (gcall *call, ao_ref *ref)\n {\n   tree base;\n   tree callee;\n@@ -2147,7 +2147,7 @@ call_may_clobber_ref_p_1 (gimple call, ao_ref *ref)\n    return true, otherwise return false.  */\n \n bool\n-call_may_clobber_ref_p (gimple call, tree ref)\n+call_may_clobber_ref_p (gcall *call, tree ref)\n {\n   bool res;\n   ao_ref r;\n@@ -2179,7 +2179,7 @@ stmt_may_clobber_ref_p_1 (gimple stmt, ao_ref *ref)\n \t    return true;\n \t}\n \n-      return call_may_clobber_ref_p_1 (stmt, ref);\n+      return call_may_clobber_ref_p_1 (as_a <gcall *> (stmt), ref);\n     }\n   else if (gimple_assign_single_p (stmt))\n     {"}, {"sha": "3193c64a38a260a719ed37fcbcdfd400ce85734d", "filename": "gcc/tree-ssa-alias.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-alias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-alias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -112,8 +112,8 @@ extern bool ref_maybe_used_by_stmt_p (gimple, ao_ref *);\n extern bool stmt_may_clobber_global_p (gimple);\n extern bool stmt_may_clobber_ref_p (gimple, tree);\n extern bool stmt_may_clobber_ref_p_1 (gimple, ao_ref *);\n-extern bool call_may_clobber_ref_p (gimple, tree);\n-extern bool call_may_clobber_ref_p_1 (gimple, ao_ref *);\n+extern bool call_may_clobber_ref_p (gcall *, tree);\n+extern bool call_may_clobber_ref_p_1 (gcall *, ao_ref *);\n extern bool stmt_kills_ref_p (gimple, tree);\n extern bool stmt_kills_ref_p (gimple, ao_ref *);\n extern tree get_continuation_for_phi (gimple, ao_ref *,"}, {"sha": "fced23af2bfe3a5048eea9f2a93f35260cb7ea6a", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -839,11 +839,11 @@ ccp_initialize (void)\n      except for phi nodes for virtual operands when we do not do store ccp.  */\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      gimple_stmt_iterator i;\n+      gphi_iterator i;\n \n       for (i = gsi_start_phis (bb); !gsi_end_p (i); gsi_next (&i))\n         {\n-          gimple phi = gsi_stmt (i);\n+          gphi *phi = i.phi ();\n \n \t  if (virtual_operand_p (gimple_phi_result (phi)))\n             prop_set_simulate_again (phi, false);\n@@ -1028,7 +1028,7 @@ ccp_lattice_meet (ccp_prop_value_t *val1, ccp_prop_value_t *val2)\n    of the PHI node that are incoming via executable edges.  */\n \n static enum ssa_prop_result\n-ccp_visit_phi_node (gimple phi)\n+ccp_visit_phi_node (gphi *phi)\n {\n   unsigned i;\n   ccp_prop_value_t *old_val, new_val;\n@@ -1174,7 +1174,7 @@ ccp_fold (gimple stmt)\n     case GIMPLE_SWITCH:\n       {\n \t/* Return the constant switch index.  */\n-        return valueize_op (gimple_switch_index (stmt));\n+        return valueize_op (gimple_switch_index (as_a <gswitch *> (stmt)));\n       }\n \n     case GIMPLE_ASSIGN:\n@@ -1724,7 +1724,7 @@ evaluate_stmt (gimple stmt)\n             simplified = gimple_assign_rhs1 (stmt);\n         }\n       else if (code == GIMPLE_SWITCH)\n-        simplified = gimple_switch_index (stmt);\n+        simplified = gimple_switch_index (as_a <gswitch *> (stmt));\n       else\n \t/* These cannot satisfy is_gimple_min_invariant without folding.  */\n \tgcc_assert (code == GIMPLE_CALL || code == GIMPLE_COND);\n@@ -1935,7 +1935,8 @@ static void\n insert_clobber_before_stack_restore (tree saved_val, tree var,\n \t\t\t\t     gimple_htab **visited)\n {\n-  gimple stmt, clobber_stmt;\n+  gimple stmt;\n+  gassign *clobber_stmt;\n   tree clobber;\n   imm_use_iterator iter;\n   gimple_stmt_iterator i;\n@@ -2094,6 +2095,7 @@ ccp_fold_stmt (gimple_stmt_iterator *gsi)\n     {\n     case GIMPLE_COND:\n       {\n+\tgcond *cond_stmt = as_a <gcond *> (stmt);\n \tccp_prop_value_t val;\n \t/* Statement evaluation will handle type mismatches in constants\n \t   more gracefully than the final propagation.  This allows us to\n@@ -2113,9 +2115,9 @@ ccp_fold_stmt (gimple_stmt_iterator *gsi)\n \t  }\n \n \tif (integer_zerop (val.value))\n-\t  gimple_cond_make_false (stmt);\n+\t  gimple_cond_make_false (cond_stmt);\n \telse\n-\t  gimple_cond_make_true (stmt);\n+\t  gimple_cond_make_true (cond_stmt);\n \n \treturn true;\n       }\n@@ -2600,10 +2602,10 @@ optimize_unreachable (gimple_stmt_iterator i)\n       if (is_gimple_debug (stmt))\n        continue;\n \n-      if (gimple_code (stmt) == GIMPLE_LABEL)\n+      if (glabel *label_stmt = dyn_cast <glabel *> (stmt))\n \t{\n \t  /* Verify we do not need to preserve the label.  */\n-\t  if (FORCED_LABEL (gimple_label_label (stmt)))\n+\t  if (FORCED_LABEL (gimple_label_label (label_stmt)))\n \t    return false;\n \n \t  continue;\n@@ -2624,15 +2626,15 @@ optimize_unreachable (gimple_stmt_iterator i)\n \tcontinue;\n \n       stmt = gsi_stmt (gsi);\n-      if (gimple_code (stmt) == GIMPLE_COND)\n+      if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n \t{\n \t  if (e->flags & EDGE_TRUE_VALUE)\n-\t    gimple_cond_make_false (stmt);\n+\t    gimple_cond_make_false (cond_stmt);\n \t  else if (e->flags & EDGE_FALSE_VALUE)\n-\t    gimple_cond_make_true (stmt);\n+\t    gimple_cond_make_true (cond_stmt);\n \t  else\n \t    gcc_unreachable ();\n-\t  update_stmt (stmt);\n+\t  update_stmt (cond_stmt);\n \t}\n       else\n \t{"}, {"sha": "7d1825d59987c5583138f3021881b0ebdd47f2c6", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -834,12 +834,11 @@ build_ssa_conflict_graph (tree_live_info_p liveinfo)\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      gimple_stmt_iterator gsi;\n-\n       /* Start with live on exit temporaries.  */\n       live_track_init (live, live_on_exit (liveinfo, bb));\n \n-      for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi); gsi_prev (&gsi))\n+      for (gimple_stmt_iterator gsi = gsi_last_bb (bb); !gsi_end_p (gsi);\n+\t   gsi_prev (&gsi))\n         {\n \t  tree var;\n \t  gimple stmt = gsi_stmt (gsi);\n@@ -876,9 +875,10 @@ build_ssa_conflict_graph (tree_live_info_p liveinfo)\n \t There must be a conflict recorded between the result of the PHI and\n \t any variables that are live.  Otherwise the out-of-ssa translation\n \t may create incorrect code.  */\n-      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n \t{\n-\t  gimple phi = gsi_stmt (gsi);\n+\t  gphi *phi = gsi.phi ();\n \t  tree result = PHI_RESULT (phi);\n \t  if (live_track_live_p (live, result))\n \t    live_track_process_def (live, result, graph);\n@@ -944,9 +944,11 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n     {\n       tree arg;\n \n-      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gphi_iterator gpi = gsi_start_phis (bb);\n+\t   !gsi_end_p (gpi);\n+\t   gsi_next (&gpi))\n \t{\n-\t  gimple phi = gsi_stmt (gsi);\n+\t  gphi *phi = gpi.phi ();\n \t  size_t i;\n \t  int ver;\n \t  tree res;\n@@ -1018,15 +1020,16 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n \n \t    case GIMPLE_ASM:\n \t      {\n+\t\tgasm *asm_stmt = as_a <gasm *> (stmt);\n \t\tunsigned long noutputs, i;\n \t\tunsigned long ninputs;\n \t\ttree *outputs, link;\n-\t\tnoutputs = gimple_asm_noutputs (stmt);\n-\t\tninputs = gimple_asm_ninputs (stmt);\n+\t\tnoutputs = gimple_asm_noutputs (asm_stmt);\n+\t\tninputs = gimple_asm_ninputs (asm_stmt);\n \t\toutputs = (tree *) alloca (noutputs * sizeof (tree));\n \t\tfor (i = 0; i < noutputs; ++i)\n \t\t  {\n-\t\t    link = gimple_asm_output_op (stmt, i);\n+\t\t    link = gimple_asm_output_op (asm_stmt, i);\n \t\t    outputs[i] = TREE_VALUE (link);\n \t\t  }\n \n@@ -1037,7 +1040,7 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n \t\t    char *end;\n \t\t    unsigned long match;\n \n-\t\t    link = gimple_asm_input_op (stmt, i);\n+\t\t    link = gimple_asm_input_op (asm_stmt, i);\n \t\t    constraint\n \t\t      = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (link)));\n \t\t    input = TREE_VALUE (link);\n@@ -1199,11 +1202,11 @@ coalesce_partitions (var_map map, ssa_conflicts_p graph, coalesce_list_p cl,\n       FOR_EACH_EDGE (e, ei, bb->preds)\n \tif (e->flags & EDGE_ABNORMAL)\n \t  {\n-\t    gimple_stmt_iterator gsi;\n+\t    gphi_iterator gsi;\n \t    for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n \t\t gsi_next (&gsi))\n \t      {\n-\t\tgimple phi = gsi_stmt (gsi);\n+\t\tgphi *phi = gsi.phi ();\n \t\ttree res = PHI_RESULT (phi);\n \t        tree arg = PHI_ARG_DEF (phi, e->dest_idx);\n \t\tint v1 = SSA_NAME_VERSION (res);"}, {"sha": "3833dff03e0a88e4b23bd1c0e47528be13ce4eb1", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -340,7 +340,7 @@ copy_prop_visit_stmt (gimple stmt, edge *taken_edge_p, tree *result_p)\n    set it to be the value of the LHS of PHI.  */\n \n static enum ssa_prop_result\n-copy_prop_visit_phi_node (gimple phi)\n+copy_prop_visit_phi_node (gphi *phi)\n {\n   enum ssa_prop_result retval;\n   unsigned i;\n@@ -461,9 +461,8 @@ init_copy_prop (void)\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      gimple_stmt_iterator si;\n-\n-      for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+      for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n+\t   gsi_next (&si))\n \t{\n \t  gimple stmt = gsi_stmt (si);\n \t  ssa_op_iter iter;\n@@ -487,9 +486,10 @@ init_copy_prop (void)\n \t      set_copy_of_val (def, def);\n \t}\n \n-      for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n+      for (gphi_iterator si = gsi_start_phis (bb); !gsi_end_p (si);\n+\t   gsi_next (&si))\n \t{\n-          gimple phi = gsi_stmt (si);\n+          gphi *phi = si.phi ();\n           tree def;\n \n \t  def = gimple_phi_result (phi);"}, {"sha": "cd7bac54e755477ebcb9422416f9551d7acddca0", "filename": "gcc/tree-ssa-copyrename.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-copyrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-copyrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copyrename.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -347,9 +347,8 @@ pass_rename_ssa_copies::execute (function *fun)\n {\n   var_map map;\n   basic_block bb;\n-  gimple_stmt_iterator gsi;\n   tree var, part_var;\n-  gimple stmt, phi;\n+  gimple stmt;\n   unsigned x;\n   FILE *debug;\n \n@@ -365,7 +364,8 @@ pass_rename_ssa_copies::execute (function *fun)\n   FOR_EACH_BB_FN (bb, fun)\n     {\n       /* Scan for real copies.  */\n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n \t{\n \t  stmt = gsi_stmt (gsi);\n \t  if (gimple_assign_ssa_name_copy_p (stmt))\n@@ -381,12 +381,12 @@ pass_rename_ssa_copies::execute (function *fun)\n   FOR_EACH_BB_FN (bb, fun)\n     {\n       /* Treat PHI nodes as copies between the result and each argument.  */\n-      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n         {\n           size_t i;\n \t  tree res;\n-\n-\t  phi = gsi_stmt (gsi);\n+\t  gphi *phi = gsi.phi ();\n \t  res = gimple_phi_result (phi);\n \n \t  /* Do not process virtual SSA_NAMES.  */"}, {"sha": "1d887c28f866bf67b20926e49af7b18c58661b48", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -673,6 +673,7 @@ propagate_necessity (bool aggressive)\n \t     we also consider the control dependent edges leading to the\n \t     predecessor block associated with each PHI alternative as\n \t     necessary.  */\n+\t  gphi *phi = as_a <gphi *> (stmt);\n \t  size_t k;\n \n \t  for (k = 0; k < gimple_phi_num_args (stmt); k++)\n@@ -755,7 +756,7 @@ propagate_necessity (bool aggressive)\n \t    {\n \t      for (k = 0; k < gimple_phi_num_args (stmt); k++)\n \t\t{\n-\t\t  basic_block arg_bb = gimple_phi_arg_edge (stmt, k)->src;\n+\t\t  basic_block arg_bb = gimple_phi_arg_edge (phi, k)->src;\n \n \t\t  if (gimple_bb (stmt)\n \t\t      != get_immediate_dominator (CDI_POST_DOMINATORS, arg_bb))\n@@ -895,9 +896,9 @@ propagate_necessity (bool aggressive)\n \t\t    mark_all_reaching_defs_necessary (stmt);\n \t\t}\n \t    }\n-\t  else if (gimple_code (stmt) == GIMPLE_RETURN)\n+\t  else if (greturn *return_stmt = dyn_cast <greturn *> (stmt))\n \t    {\n-\t      tree rhs = gimple_return_retval (stmt);\n+\t      tree rhs = gimple_return_retval (return_stmt);\n \t      /* A return statement may perform a load.  */\n \t      if (rhs\n \t\t  && TREE_CODE (rhs) != SSA_NAME\n@@ -910,14 +911,14 @@ propagate_necessity (bool aggressive)\n \t\t    mark_all_reaching_defs_necessary (stmt);\n \t\t}\n \t    }\n-\t  else if (gimple_code (stmt) == GIMPLE_ASM)\n+\t  else if (gasm *asm_stmt = dyn_cast <gasm *> (stmt))\n \t    {\n \t      unsigned i;\n \t      mark_all_reaching_defs_necessary (stmt);\n \t      /* Inputs may perform loads.  */\n-\t      for (i = 0; i < gimple_asm_ninputs (stmt); ++i)\n+\t      for (i = 0; i < gimple_asm_ninputs (asm_stmt); ++i)\n \t\t{\n-\t\t  tree op = TREE_VALUE (gimple_asm_input_op (stmt, i));\n+\t\t  tree op = TREE_VALUE (gimple_asm_input_op (asm_stmt, i));\n \t\t  if (TREE_CODE (op) != SSA_NAME\n \t\t      && !is_gimple_min_invariant (op)\n \t\t      && TREE_CODE (op) != CONSTRUCTOR\n@@ -961,13 +962,13 @@ static bool\n remove_dead_phis (basic_block bb)\n {\n   bool something_changed = false;\n-  gimple phi;\n-  gimple_stmt_iterator gsi;\n+  gphi *phi;\n+  gphi_iterator gsi;\n \n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi);)\n     {\n       stats.total_phis++;\n-      phi = gsi_stmt (gsi);\n+      phi = gsi.phi ();\n \n       /* We do not track necessity of virtual PHI nodes.  Instead do\n          very simple dead PHI removal here.  */\n@@ -1019,7 +1020,7 @@ remove_dead_phis (basic_block bb)\n static edge\n forward_edge_to_pdom (edge e, basic_block post_dom_bb)\n {\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n   edge e2 = NULL;\n   edge_iterator ei;\n \n@@ -1043,7 +1044,7 @@ forward_edge_to_pdom (edge e, basic_block post_dom_bb)\n \t  break;\n       for (gsi = gsi_start_phis (post_dom_bb); !gsi_end_p (gsi);)\n \t{\n-\t  gimple phi = gsi_stmt (gsi);\n+\t  gphi *phi = gsi.phi ();\n \t  tree op;\n \t  source_location locus;\n \n@@ -1153,7 +1154,7 @@ remove_dead_stmt (gimple_stmt_iterator *i, basic_block bb)\n \t  && !DECL_HAS_VALUE_EXPR_P (lhs))\n \t{\n \t  tree rhs = gimple_assign_rhs1 (stmt);\n-\t  gimple note\n+\t  gdebug *note\n \t    = gimple_build_debug_bind (lhs, unshare_expr (rhs), stmt);\n \t  gsi_insert_after (i, note, GSI_SAME_STMT);\n \t}\n@@ -1369,7 +1370,7 @@ eliminate_unnecessary_stmts (void)\n \t    {\n \t      tree name = gimple_call_lhs (stmt);\n \n-\t      notice_special_calls (stmt);\n+\t      notice_special_calls (as_a <gcall *> (stmt));\n \n \t      /* When LHS of var = call (); is dead, simplify it into\n \t\t call (); saving one operand.  */\n@@ -1447,13 +1448,15 @@ eliminate_unnecessary_stmts (void)\n \t  if (!bitmap_bit_p (bb_contains_live_stmts, bb->index)\n \t      || !(bb->flags & BB_REACHABLE))\n \t    {\n-\t      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t\tif (virtual_operand_p (gimple_phi_result (gsi_stmt (gsi))))\n+\t      for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+\t\t   gsi_next (&gsi))\n+\t\tif (virtual_operand_p (gimple_phi_result (gsi.phi ())))\n \t\t  {\n \t\t    bool found = false;\n \t\t    imm_use_iterator iter;\n \n-\t\t    FOR_EACH_IMM_USE_STMT (stmt, iter, gimple_phi_result (gsi_stmt (gsi)))\n+\t\t    FOR_EACH_IMM_USE_STMT (stmt, iter,\n+\t\t\t\t\t   gimple_phi_result (gsi.phi ()))\n \t\t      {\n \t\t\tif (!(gimple_bb (stmt)->flags & BB_REACHABLE))\n \t\t\t  continue;\n@@ -1465,7 +1468,7 @@ eliminate_unnecessary_stmts (void)\n \t\t\t  }\n \t\t      }\n \t\t    if (found)\n-\t\t      mark_virtual_phi_result_for_renaming (gsi_stmt (gsi));\n+\t\t      mark_virtual_phi_result_for_renaming (gsi.phi ());\n \t\t  }\n \n \t      if (!(bb->flags & BB_REACHABLE))"}, {"sha": "8af5d2e4e74c35a69e91b1ea42cdc18cf055cbeb", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -91,7 +91,7 @@ struct hashable_expr\n     struct { enum tree_code op;  tree opnd; } unary;\n     struct { enum tree_code op;  tree opnd0, opnd1; } binary;\n     struct { enum tree_code op;  tree opnd0, opnd1, opnd2; } ternary;\n-    struct { gimple fn_from; bool pure; size_t nargs; tree *args; } call;\n+    struct { gcall *fn_from; bool pure; size_t nargs; tree *args; } call;\n     struct { size_t nargs; tree *args; } phi;\n   } ops;\n };\n@@ -337,32 +337,32 @@ initialize_hash_element (gimple stmt, tree lhs,\n       expr->ops.binary.opnd0 = gimple_cond_lhs (stmt);\n       expr->ops.binary.opnd1 = gimple_cond_rhs (stmt);\n     }\n-  else if (code == GIMPLE_CALL)\n+  else if (gcall *call_stmt = dyn_cast <gcall *> (stmt))\n     {\n-      size_t nargs = gimple_call_num_args (stmt);\n+      size_t nargs = gimple_call_num_args (call_stmt);\n       size_t i;\n \n-      gcc_assert (gimple_call_lhs (stmt));\n+      gcc_assert (gimple_call_lhs (call_stmt));\n \n-      expr->type = TREE_TYPE (gimple_call_lhs (stmt));\n+      expr->type = TREE_TYPE (gimple_call_lhs (call_stmt));\n       expr->kind = EXPR_CALL;\n-      expr->ops.call.fn_from = stmt;\n+      expr->ops.call.fn_from = call_stmt;\n \n-      if (gimple_call_flags (stmt) & (ECF_CONST | ECF_PURE))\n+      if (gimple_call_flags (call_stmt) & (ECF_CONST | ECF_PURE))\n         expr->ops.call.pure = true;\n       else\n         expr->ops.call.pure = false;\n \n       expr->ops.call.nargs = nargs;\n       expr->ops.call.args = XCNEWVEC (tree, nargs);\n       for (i = 0; i < nargs; i++)\n-        expr->ops.call.args[i] = gimple_call_arg (stmt, i);\n+        expr->ops.call.args[i] = gimple_call_arg (call_stmt, i);\n     }\n-  else if (code == GIMPLE_SWITCH)\n+  else if (gswitch *swtch_stmt = dyn_cast <gswitch *> (stmt))\n     {\n-      expr->type = TREE_TYPE (gimple_switch_index (stmt));\n+      expr->type = TREE_TYPE (gimple_switch_index (swtch_stmt));\n       expr->kind = EXPR_SINGLE;\n-      expr->ops.single.rhs = gimple_switch_index (stmt);\n+      expr->ops.single.rhs = gimple_switch_index (swtch_stmt);\n     }\n   else if (code == GIMPLE_GOTO)\n     {\n@@ -647,7 +647,7 @@ add_hashable_expr (const struct hashable_expr *expr, hash &hstate)\n       {\n         size_t i;\n         enum tree_code code = CALL_EXPR;\n-        gimple fn_from;\n+        gcall *fn_from;\n \n         hstate.add_object (code);\n         fn_from = expr->ops.call.fn_from;\n@@ -723,7 +723,7 @@ print_expr_hash_elt (FILE * stream, const struct expr_hash_elt *element)\n         {\n           size_t i;\n           size_t nargs = element->expr.ops.call.nargs;\n-          gimple fn_from;\n+          gcall *fn_from;\n \n           fn_from = element->expr.ops.call.fn_from;\n           if (gimple_call_internal_p (fn_from))\n@@ -843,7 +843,7 @@ class dom_opt_dom_walker : public dom_walker\n private:\n   void thread_across_edge (edge);\n \n-  gimple m_dummy_cond;\n+  gcond *m_dummy_cond;\n };\n \n /* Jump threading, redundancy elimination and const/copy propagation.\n@@ -1015,7 +1015,7 @@ make_pass_dominator (gcc::context *ctxt)\n    condition to a canonical form.  */\n \n static void\n-canonicalize_comparison (gimple condstmt)\n+canonicalize_comparison (gcond *condstmt)\n {\n   tree op0;\n   tree op1;\n@@ -1201,11 +1201,11 @@ dom_opt_dom_walker::thread_across_edge (edge e)\n static void\n record_equivalences_from_phis (basic_block bb)\n {\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n \n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n \n       tree lhs = gimple_phi_result (phi);\n       tree rhs = NULL;\n@@ -1728,7 +1728,7 @@ cprop_into_successor_phis (basic_block bb)\n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n       int indx;\n-      gimple_stmt_iterator gsi;\n+      gphi_iterator gsi;\n \n       /* If this is an abnormal edge, then we do not want to copy propagate\n \t into the PHI alternative associated with this edge.  */\n@@ -1767,7 +1767,7 @@ cprop_into_successor_phis (basic_block bb)\n \t  tree new_val;\n \t  use_operand_p orig_p;\n \t  tree orig_val;\n-          gimple phi = gsi_stmt (gsi);\n+          gphi *phi = gsi.phi ();\n \n \t  /* The alternative may be associated with a constant, so verify\n \t     it is an SSA_NAME before doing anything with it.  */\n@@ -1807,19 +1807,20 @@ record_edge_info (basic_block bb)\n \n       if (gimple_code (stmt) == GIMPLE_SWITCH)\n \t{\n-\t  tree index = gimple_switch_index (stmt);\n+\t  gswitch *switch_stmt = as_a <gswitch *> (stmt);\n+\t  tree index = gimple_switch_index (switch_stmt);\n \n \t  if (TREE_CODE (index) == SSA_NAME)\n \t    {\n \t      int i;\n-              int n_labels = gimple_switch_num_labels (stmt);\n+              int n_labels = gimple_switch_num_labels (switch_stmt);\n \t      tree *info = XCNEWVEC (tree, last_basic_block_for_fn (cfun));\n \t      edge e;\n \t      edge_iterator ei;\n \n \t      for (i = 0; i < n_labels; i++)\n \t\t{\n-\t\t  tree label = gimple_switch_label (stmt, i);\n+\t\t  tree label = gimple_switch_label (switch_stmt, i);\n \t\t  basic_block target_bb = label_to_block (CASE_LABEL (label));\n \t\t  if (CASE_HIGH (label)\n \t\t      || !CASE_LOW (label)\n@@ -2092,8 +2093,8 @@ eliminate_redundant_computations (gimple_stmt_iterator* gsi)\n       expr_type = TREE_TYPE (gimple_call_lhs (stmt));\n       assigns_var_p = true;\n     }\n-  else if (gimple_code (stmt) == GIMPLE_SWITCH)\n-    expr_type = TREE_TYPE (gimple_switch_index (stmt));\n+  else if (gswitch *swtch_stmt = dyn_cast <gswitch *> (stmt))\n+    expr_type = TREE_TYPE (gimple_switch_index (swtch_stmt));\n   else if (gimple_code (stmt) == GIMPLE_PHI)\n     /* We can't propagate into a phi, so the logic below doesn't apply.\n        Instead record an equivalence between the cached LHS and the\n@@ -2204,7 +2205,7 @@ record_equivalences_from_stmt (gimple stmt, int may_optimize_p)\n       && !is_gimple_reg (lhs))\n     {\n       tree rhs = gimple_assign_rhs1 (stmt);\n-      gimple new_stmt;\n+      gassign *new_stmt;\n \n       /* Build a new statement with the RHS and LHS exchanged.  */\n       if (TREE_CODE (rhs) == SSA_NAME)\n@@ -2337,7 +2338,7 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si)\n     }\n \n   if (gimple_code (stmt) == GIMPLE_COND)\n-    canonicalize_comparison (stmt);\n+    canonicalize_comparison (as_a <gcond *> (stmt));\n \n   update_stmt_if_modified (stmt);\n   opt_stats.num_stmts++;\n@@ -2370,9 +2371,9 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si)\n         rhs = gimple_assign_rhs1 (stmt);\n       else if (gimple_code (stmt) == GIMPLE_GOTO)\n         rhs = gimple_goto_dest (stmt);\n-      else if (gimple_code (stmt) == GIMPLE_SWITCH)\n+      else if (gswitch *swtch_stmt = dyn_cast <gswitch *> (stmt))\n         /* This should never be an ADDR_EXPR.  */\n-        rhs = gimple_switch_index (stmt);\n+        rhs = gimple_switch_index (swtch_stmt);\n \n       if (rhs && TREE_CODE (rhs) == ADDR_EXPR)\n         recompute_tree_invariant_for_addr_expr (rhs);\n@@ -2420,7 +2421,7 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si)\n \t  tree lhs = gimple_assign_lhs (stmt);\n \t  tree rhs = gimple_assign_rhs1 (stmt);\n \t  tree cached_lhs;\n-\t  gimple new_stmt;\n+\t  gassign *new_stmt;\n \t  if (TREE_CODE (rhs) == SSA_NAME)\n \t    {\n \t      tree tem = SSA_NAME_VALUE (rhs);\n@@ -2494,8 +2495,8 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si)\n         val = fold_binary_loc (gimple_location (stmt),\n \t\t\t   gimple_cond_code (stmt), boolean_type_node,\n                            gimple_cond_lhs (stmt),  gimple_cond_rhs (stmt));\n-      else if (gimple_code (stmt) == GIMPLE_SWITCH)\n-\tval = gimple_switch_index (stmt);\n+      else if (gswitch *swtch_stmt = dyn_cast <gswitch *> (stmt))\n+\tval = gimple_switch_index (swtch_stmt);\n \n       if (val && TREE_CODE (val) == INTEGER_CST && find_taken_edge (bb, val))\n \tcfg_altered = true;\n@@ -2656,7 +2657,7 @@ static tree\n get_rhs_or_phi_arg (gimple stmt)\n {\n   if (gimple_code (stmt) == GIMPLE_PHI)\n-    return degenerate_phi_result (stmt);\n+    return degenerate_phi_result (as_a <gphi *> (stmt));\n   else if (gimple_assign_single_p (stmt))\n     return gimple_assign_rhs1 (stmt);\n   else\n@@ -2847,7 +2848,7 @@ propagate_rhs_into_lhs (gimple stmt, tree lhs, tree rhs, bitmap interesting_name\n                                    gimple_cond_lhs (use_stmt),\n                                    gimple_cond_rhs (use_stmt));\n               else if (gimple_code (use_stmt) == GIMPLE_SWITCH)\n-\t\tval = gimple_switch_index (use_stmt);\n+\t\tval = gimple_switch_index (as_a <gswitch *> (use_stmt));\n \t      else\n \t\tval = gimple_goto_dest  (use_stmt);\n \n@@ -2857,7 +2858,8 @@ propagate_rhs_into_lhs (gimple stmt, tree lhs, tree rhs, bitmap interesting_name\n \t\t  edge te = find_taken_edge (bb, val);\n \t\t  edge_iterator ei;\n \t\t  edge e;\n-\t\t  gimple_stmt_iterator gsi, psi;\n+\t\t  gimple_stmt_iterator gsi;\n+\t\t  gphi_iterator psi;\n \n \t\t  /* Remove all outgoing edges except TE.  */\n \t\t  for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei));)\n@@ -2870,7 +2872,7 @@ propagate_rhs_into_lhs (gimple stmt, tree lhs, tree rhs, bitmap interesting_name\n                                !gsi_end_p (psi);\n                                gsi_next (&psi))\n                             {\n-                              gimple phi = gsi_stmt (psi);\n+                              gphi *phi = psi.phi ();\n \n \t\t\t      tree result = gimple_phi_result (phi);\n \t\t\t      int version = SSA_NAME_VERSION (result);\n@@ -2980,12 +2982,12 @@ eliminate_const_or_copy (gimple stmt, bitmap interesting_names)\n static void\n eliminate_degenerate_phis_1 (basic_block bb, bitmap interesting_names)\n {\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n   basic_block son;\n \n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n \n       eliminate_const_or_copy (phi, interesting_names);\n     }"}, {"sha": "43f4f2a05e0633ce5613db86b3a67777faf5f31b", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -355,7 +355,7 @@ remove_prop_source_from_use (tree name)\n   return cfg_changed;\n }\n \n-/* Return the rhs of a gimple_assign STMT in a form of a single tree,\n+/* Return the rhs of a gassign *STMT in a form of a single tree,\n    converted to type TYPE.\n \n    This should disappear, but is needed so we can combine expressions and use\n@@ -529,7 +529,7 @@ forward_propagate_into_comparison (gimple_stmt_iterator *gsi)\n    This must be kept in sync with forward_propagate_into_cond.  */\n \n static int\n-forward_propagate_into_gimple_cond (gimple stmt)\n+forward_propagate_into_gimple_cond (gcond *stmt)\n {\n   tree tmp;\n   enum tree_code code = gimple_cond_code (stmt);\n@@ -1043,7 +1043,7 @@ forward_propagate_addr_expr (tree name, tree rhs, bool parent_single_use_p)\n    have values outside the range of the new type.  */\n \n static void\n-simplify_gimple_switch_label_vec (gimple stmt, tree index_type)\n+simplify_gimple_switch_label_vec (gswitch *stmt, tree index_type)\n {\n   unsigned int branch_num = gimple_switch_num_labels (stmt);\n   auto_vec<tree> labels (branch_num);\n@@ -1113,7 +1113,7 @@ simplify_gimple_switch_label_vec (gimple stmt, tree index_type)\n    the condition which we may be able to optimize better.  */\n \n static bool\n-simplify_gimple_switch (gimple stmt)\n+simplify_gimple_switch (gswitch *stmt)\n {\n   /* The optimization that we really care about is removing unnecessary\n      casts.  That will let us do much better in propagating the inferred\n@@ -2233,10 +2233,10 @@ pass_forwprop::execute (function *fun)\n \t\tbitmap_set_bit (to_purge, bb->index);\n \t      /* Cleanup the CFG if we simplified a condition to\n \t         true or false.  */\n-\t      if (gimple_code (stmt) == GIMPLE_COND\n-\t\t  && (gimple_cond_true_p (stmt)\n-\t\t      || gimple_cond_false_p (stmt)))\n-\t\tcfg_changed = true;\n+\t      if (gcond *cond = dyn_cast <gcond *> (stmt))\n+\t\tif (gimple_cond_true_p (cond)\n+\t\t    || gimple_cond_false_p (cond))\n+\t\t  cfg_changed = true;\n \t      update_stmt (stmt);\n \t    }\n \n@@ -2286,13 +2286,13 @@ pass_forwprop::execute (function *fun)\n \t      }\n \n \t    case GIMPLE_SWITCH:\n-\t      changed = simplify_gimple_switch (stmt);\n+\t      changed = simplify_gimple_switch (as_a <gswitch *> (stmt));\n \t      break;\n \n \t    case GIMPLE_COND:\n \t      {\n-\t\tint did_something;\n-\t\tdid_something = forward_propagate_into_gimple_cond (stmt);\n+\t\tint did_something\n+\t\t  = forward_propagate_into_gimple_cond (as_a <gcond *> (stmt));\n \t\tif (did_something == 2)\n \t\t  cfg_changed = true;\n \t\tchanged = did_something != 0;"}, {"sha": "9fd71130db165eaa9f5e54ddf0283d7c24ade682", "filename": "gcc/tree-ssa-ifcombine.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-ifcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-ifcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ifcombine.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -169,12 +169,12 @@ same_phi_args_p (basic_block bb1, basic_block bb2, basic_block dest)\n {\n   edge e1 = find_edge (bb1, dest);\n   edge e2 = find_edge (bb2, dest);\n-  gimple_stmt_iterator gsi;\n-  gimple phi;\n+  gphi_iterator gsi;\n+  gphi *phi;\n \n   for (gsi = gsi_start_phis (dest); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      phi = gsi_stmt (gsi);\n+      phi = gsi.phi ();\n       if (!operand_equal_p (PHI_ARG_DEF_FROM_EDGE (phi, e1),\n \t\t\t    PHI_ARG_DEF_FROM_EDGE (phi, e2), 0))\n         return false;\n@@ -213,7 +213,7 @@ get_name_for_bit_test (tree candidate)\n    Returns true if the pattern matched, false otherwise.  */\n \n static bool\n-recognize_single_bit_test (gimple cond, tree *name, tree *bit, bool inv)\n+recognize_single_bit_test (gcond *cond, tree *name, tree *bit, bool inv)\n {\n   gimple stmt;\n \n@@ -322,7 +322,7 @@ recognize_single_bit_test (gimple cond, tree *name, tree *bit, bool inv)\n    Returns true if the pattern matched, false otherwise.  */\n \n static bool\n-recognize_bits_test (gimple cond, tree *name, tree *bits, bool inv)\n+recognize_bits_test (gcond *cond, tree *name, tree *bits, bool inv)\n {\n   gimple stmt;\n \n@@ -353,18 +353,21 @@ ifcombine_ifandif (basic_block inner_cond_bb, bool inner_inv,\n \t\t   basic_block outer_cond_bb, bool outer_inv, bool result_inv)\n {\n   gimple_stmt_iterator gsi;\n-  gimple inner_cond, outer_cond;\n+  gimple inner_stmt, outer_stmt;\n+  gcond *inner_cond, *outer_cond;\n   tree name1, name2, bit1, bit2, bits1, bits2;\n \n-  inner_cond = last_stmt (inner_cond_bb);\n-  if (!inner_cond\n-      || gimple_code (inner_cond) != GIMPLE_COND)\n+  inner_stmt = last_stmt (inner_cond_bb);\n+  if (!inner_stmt\n+      || gimple_code (inner_stmt) != GIMPLE_COND)\n     return false;\n+  inner_cond = as_a <gcond *> (inner_stmt);\n \n-  outer_cond = last_stmt (outer_cond_bb);\n-  if (!outer_cond\n-      || gimple_code (outer_cond) != GIMPLE_COND)\n+  outer_stmt = last_stmt (outer_cond_bb);\n+  if (!outer_stmt\n+      || gimple_code (outer_stmt) != GIMPLE_COND)\n     return false;\n+  outer_cond = as_a <gcond *> (outer_stmt);\n \n   /* See if we test a single bit of the same name in both tests.  In\n      that case remove the outer test, merging both else edges,"}, {"sha": "0a4565a8c15ca718110e523515d28e87e97c92c9", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -830,12 +830,14 @@ remove_unused_locals (void)\n \t    mark_all_vars_used (gimple_op_ptr (gsi_stmt (gsi), i));\n \t}\n \n-      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gphi_iterator gpi = gsi_start_phis (bb);\n+\t   !gsi_end_p (gpi);\n+\t   gsi_next (&gpi))\n         {\n           use_operand_p arg_p;\n           ssa_op_iter i;\n \t  tree def;\n-\t  gimple phi = gsi_stmt (gsi);\n+\t  gphi *phi = gpi.phi ();\n \n \t  if (virtual_operand_p (gimple_phi_result (phi)))\n \t    continue;\n@@ -1121,7 +1123,7 @@ set_var_live_on_entry (tree ssa_name, tree_live_info_p live)\n \t     as this is where a copy would be inserted.  Check to see if it is\n \t     defined in that block, or whether its live on entry.  */\n \t  int index = PHI_ARG_INDEX_FROM_USE (use);\n-\t  edge e = gimple_phi_arg_edge (use_stmt, index);\n+\t  edge e = gimple_phi_arg_edge (as_a <gphi *> (use_stmt), index);\n \t  if (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t    {\n \t      if (e->src != def_bb)\n@@ -1169,13 +1171,13 @@ calculate_live_on_exit (tree_live_info_p liveinfo)\n   /* Set all the live-on-exit bits for uses in PHIs.  */\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      gimple_stmt_iterator gsi;\n+      gphi_iterator gsi;\n       size_t i;\n \n       /* Mark the PHI arguments which are live on exit to the pred block.  */\n       for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple phi = gsi_stmt (gsi);\n+\t  gphi *phi = gsi.phi ();\n \t  for (i = 0; i < gimple_phi_num_args (phi); i++)\n \t    {\n \t      tree t = PHI_ARG_DEF (phi, i);\n@@ -1453,12 +1455,12 @@ verify_live_on_entry (tree_live_info_p live)\n \t\t   if it occurs in a PHI argument of the block.  */\n \t\tsize_t z;\n \t\tbool ok = false;\n-\t\tgimple_stmt_iterator gsi;\n+\t\tgphi_iterator gsi;\n \t\tfor (gsi = gsi_start_phis (e->dest);\n \t\t     !gsi_end_p (gsi) && !ok;\n \t\t     gsi_next (&gsi))\n \t\t  {\n-\t\t    gimple phi = gsi_stmt (gsi);\n+\t\t    gphi *phi = gsi.phi ();\n \t\t    for (z = 0; z < gimple_phi_num_args (phi); z++)\n \t\t      if (var == gimple_phi_arg_def (phi, z))\n \t\t\t{"}, {"sha": "0e806f4b68222b388f46e47bc2afe95362a1a69b", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 36, "deletions": 29, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -633,7 +633,7 @@ mem_ref_in_stmt (gimple stmt)\n    else return false.  */\n \n static bool\n-extract_true_false_args_from_phi (basic_block dom, gimple phi,\n+extract_true_false_args_from_phi (basic_block dom, gphi *phi,\n \t\t\t\t  tree *true_arg_p, tree *false_arg_p)\n {\n   basic_block bb = gimple_bb (phi);\n@@ -716,7 +716,7 @@ determine_max_movement (gimple stmt, bool must_preserve_exec)\n     level = superloop_at_depth (loop, 1);\n   lim_data->max_loop = level;\n \n-  if (gimple_code (stmt) == GIMPLE_PHI)\n+  if (gphi *phi = dyn_cast <gphi *> (stmt))\n     {\n       use_operand_p use_p;\n       unsigned min_cost = UINT_MAX;\n@@ -727,7 +727,7 @@ determine_max_movement (gimple stmt, bool must_preserve_exec)\n \t evaluated.  For this reason the PHI cost (and thus the\n \t cost we remove from the loop by doing the invariant motion)\n \t is that of the cheapest PHI argument dependency chain.  */\n-      FOR_EACH_PHI_ARG (use_p, stmt, iter, SSA_OP_USE)\n+      FOR_EACH_PHI_ARG (use_p, phi, iter, SSA_OP_USE)\n \t{\n \t  val = USE_FROM_PTR (use_p);\n \n@@ -757,7 +757,7 @@ determine_max_movement (gimple stmt, bool must_preserve_exec)\n       min_cost = MIN (min_cost, total_cost);\n       lim_data->cost += min_cost;\n \n-      if (gimple_phi_num_args (stmt) > 1)\n+      if (gimple_phi_num_args (phi) > 1)\n \t{\n \t  basic_block dom = get_immediate_dominator (CDI_DOMINATORS, bb);\n \t  gimple cond;\n@@ -769,7 +769,7 @@ determine_max_movement (gimple stmt, bool must_preserve_exec)\n \t  /* Verify that this is an extended form of a diamond and\n \t     the PHI arguments are completely controlled by the\n \t     predicate in DOM.  */\n-\t  if (!extract_true_false_args_from_phi (dom, stmt, NULL, NULL))\n+\t  if (!extract_true_false_args_from_phi (dom, phi, NULL, NULL))\n \t    return false;\n \n \t  /* Fold in dependencies and cost of the condition.  */\n@@ -886,12 +886,12 @@ nonpure_call_p (gimple stmt)\n static gimple\n rewrite_reciprocal (gimple_stmt_iterator *bsi)\n {\n-  gimple stmt, stmt1, stmt2;\n+  gassign *stmt, *stmt1, *stmt2;\n   tree name, lhs, type;\n   tree real_one;\n   gimple_stmt_iterator gsi;\n \n-  stmt = gsi_stmt (*bsi);\n+  stmt = as_a <gassign *> (gsi_stmt (*bsi));\n   lhs = gimple_assign_lhs (stmt);\n   type = TREE_TYPE (lhs);\n \n@@ -921,22 +921,28 @@ rewrite_reciprocal (gimple_stmt_iterator *bsi)\n static gimple\n rewrite_bittest (gimple_stmt_iterator *bsi)\n {\n-  gimple stmt, use_stmt, stmt1, stmt2;\n+  gassign *stmt;\n+  gimple stmt1;\n+  gassign *stmt2;\n+  gimple use_stmt;\n+  gcond *cond_stmt;\n   tree lhs, name, t, a, b;\n   use_operand_p use;\n \n-  stmt = gsi_stmt (*bsi);\n+  stmt = as_a <gassign *> (gsi_stmt (*bsi));\n   lhs = gimple_assign_lhs (stmt);\n \n   /* Verify that the single use of lhs is a comparison against zero.  */\n   if (TREE_CODE (lhs) != SSA_NAME\n-      || !single_imm_use (lhs, &use, &use_stmt)\n-      || gimple_code (use_stmt) != GIMPLE_COND)\n+      || !single_imm_use (lhs, &use, &use_stmt))\n     return stmt;\n-  if (gimple_cond_lhs (use_stmt) != lhs\n-      || (gimple_cond_code (use_stmt) != NE_EXPR\n-\t  && gimple_cond_code (use_stmt) != EQ_EXPR)\n-      || !integer_zerop (gimple_cond_rhs (use_stmt)))\n+  cond_stmt = dyn_cast <gcond *> (use_stmt);\n+  if (!cond_stmt)\n+    return stmt;\n+  if (gimple_cond_lhs (cond_stmt) != lhs\n+      || (gimple_cond_code (cond_stmt) != NE_EXPR\n+\t  && gimple_cond_code (cond_stmt) != EQ_EXPR)\n+      || !integer_zerop (gimple_cond_rhs (cond_stmt)))\n     return stmt;\n \n   /* Get at the operands of the shift.  The rhs is TMP1 & 1.  */\n@@ -984,7 +990,9 @@ rewrite_bittest (gimple_stmt_iterator *bsi)\n       /* Replace the SSA_NAME we compare against zero.  Adjust\n \t the type of zero accordingly.  */\n       SET_USE (use, name);\n-      gimple_cond_set_rhs (use_stmt, build_int_cst_type (TREE_TYPE (name), 0));\n+      gimple_cond_set_rhs (cond_stmt,\n+\t\t\t   build_int_cst_type (TREE_TYPE (name),\n+\t\t\t\t\t       0));\n \n       /* Don't use gsi_replace here, none of the new assignments sets\n \t the variable originally set in stmt.  Move bsi to stmt1, and\n@@ -1168,18 +1176,16 @@ void\n move_computations_dom_walker::before_dom_children (basic_block bb)\n {\n   struct loop *level;\n-  gimple_stmt_iterator bsi;\n-  gimple stmt;\n   unsigned cost = 0;\n   struct lim_aux_data *lim_data;\n \n   if (!loop_outer (bb->loop_father))\n     return;\n \n-  for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); )\n+  for (gphi_iterator bsi = gsi_start_phis (bb); !gsi_end_p (bsi); )\n     {\n-      gimple new_stmt;\n-      stmt = gsi_stmt (bsi);\n+      gassign *new_stmt;\n+      gphi *stmt = bsi.phi ();\n \n       lim_data = get_lim_data (stmt);\n       if (lim_data == NULL)\n@@ -1233,11 +1239,11 @@ move_computations_dom_walker::before_dom_children (basic_block bb)\n       remove_phi_node (&bsi, false);\n     }\n \n-  for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); )\n+  for (gimple_stmt_iterator bsi = gsi_start_bb (bb); !gsi_end_p (bsi); )\n     {\n       edge e;\n \n-      stmt = gsi_stmt (bsi);\n+      gimple stmt = gsi_stmt (bsi);\n \n       lim_data = get_lim_data (stmt);\n       if (lim_data == NULL)\n@@ -1275,11 +1281,11 @@ move_computations_dom_walker::before_dom_children (basic_block bb)\n \t{\n \t  /* The new VUSE is the one from the virtual PHI in the loop\n \t     header or the one already present.  */\n-\t  gimple_stmt_iterator gsi2;\n+\t  gphi_iterator gsi2;\n \t  for (gsi2 = gsi_start_phis (e->dest);\n \t       !gsi_end_p (gsi2); gsi_next (&gsi2))\n \t    {\n-\t      gimple phi = gsi_stmt (gsi2);\n+\t      gphi *phi = gsi2.phi ();\n \t      if (virtual_operand_p (gimple_phi_result (phi)))\n \t\t{\n \t\t  gimple_set_vuse (stmt, PHI_ARG_DEF_FROM_EDGE (phi, e));\n@@ -1886,9 +1892,10 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag)\n   }\n \n   if (!loop_has_only_one_exit)\n-    for (gsi = gsi_start_phis (old_dest); !gsi_end_p (gsi); gsi_next (&gsi))\n+    for (gphi_iterator gpi = gsi_start_phis (old_dest);\n+\t !gsi_end_p (gpi); gsi_next (&gpi))\n       {\n-\tgimple phi = gsi_stmt (gsi);\n+\tgphi *phi = gpi.phi ();\n \tunsigned i;\n \n \tfor (i = 0; i < gimple_phi_num_args (phi); i++)\n@@ -1950,7 +1957,7 @@ execute_sm (struct loop *loop, vec<edge> exits, mem_ref_p ref)\n {\n   tree tmp_var, store_flag = NULL_TREE;\n   unsigned i;\n-  gimple load;\n+  gassign *load;\n   struct fmt_data fmt_data;\n   edge ex;\n   struct lim_aux_data *lim_data;\n@@ -2007,7 +2014,7 @@ execute_sm (struct loop *loop, vec<edge> exits, mem_ref_p ref)\n   FOR_EACH_VEC_ELT (exits, i, ex)\n     if (!multi_threaded_model_p)\n       {\n-\tgimple store;\n+\tgassign *store;\n \tstore = gimple_build_assign (unshare_expr (ref->mem.ref), tmp_var);\n \tgsi_insert_on_edge (ex, store);\n       }"}, {"sha": "7dc5adcab9345ec1acfa9022be52e5217398cd23", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -106,7 +106,7 @@ create_canonical_iv (struct loop *loop, edge exit, tree niter)\n {\n   edge in;\n   tree type, var;\n-  gimple cond;\n+  gcond *cond;\n   gimple_stmt_iterator incr_at;\n   enum tree_code cmp;\n \n@@ -117,7 +117,7 @@ create_canonical_iv (struct loop *loop, edge exit, tree niter)\n       fprintf (dump_file, \" iterations.\\n\");\n     }\n \n-  cond = last_stmt (exit->src);\n+  cond = as_a <gcond *> (last_stmt (exit->src));\n   in = EDGE_SUCC (exit->src, 0);\n   if (in == exit)\n     in = EDGE_SUCC (exit->src, 1);\n@@ -323,7 +323,9 @@ tree_estimate_loop_size (struct loop *loop, edge exit, edge edge_to_cancel, stru\n \t\t    && constant_after_peeling (gimple_cond_lhs (stmt), stmt, loop)\n \t\t    && constant_after_peeling (gimple_cond_rhs (stmt), stmt, loop))\n \t\t   || (gimple_code (stmt) == GIMPLE_SWITCH\n-\t\t       && constant_after_peeling (gimple_switch_index (stmt), stmt, loop)))\n+\t\t       && constant_after_peeling (gimple_switch_index (\n+\t\t\t\t\t\t    as_a <gswitch *> (stmt)),\n+\t\t\t\t\t\t  stmt, loop)))\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t        fprintf (dump_file, \"   Constant conditional.\\n\");\n@@ -375,7 +377,9 @@ tree_estimate_loop_size (struct loop *loop, edge exit, edge edge_to_cancel, stru\n \t        && (!constant_after_peeling (gimple_cond_lhs (stmt), stmt, loop)\n \t\t    || constant_after_peeling (gimple_cond_rhs (stmt), stmt, loop)))\n \t       || (gimple_code (stmt) == GIMPLE_SWITCH\n-\t\t   && !constant_after_peeling (gimple_switch_index (stmt), stmt, loop)))\n+\t\t   && !constant_after_peeling (gimple_switch_index (\n+\t\t\t\t\t\t as_a <gswitch *> (stmt)),\n+\t\t\t\t\t       stmt, loop)))\n \t      && (!exit || bb != exit->src))\n \t    size->num_branches_on_hot_path++;\n \t}\n@@ -511,7 +515,7 @@ remove_exits_and_undefined_stmts (struct loop *loop, unsigned int npeeled)\n \t  && wi::ltu_p (elt->bound, npeeled))\n \t{\n \t  gimple_stmt_iterator gsi = gsi_for_stmt (elt->stmt);\n-\t  gimple stmt = gimple_build_call\n+\t  gcall *stmt = gimple_build_call\n \t      (builtin_decl_implicit (BUILT_IN_UNREACHABLE), 0);\n \n \t  gimple_set_location (stmt, gimple_location (elt->stmt));\n@@ -538,11 +542,12 @@ remove_exits_and_undefined_stmts (struct loop *loop, unsigned int npeeled)\n \t  if (!loop_exit_edge_p (loop, exit_edge))\n \t    exit_edge = EDGE_SUCC (bb, 1);\n \t  gcc_checking_assert (loop_exit_edge_p (loop, exit_edge));\n+\t  gcond *cond_stmt = as_a <gcond *> (elt->stmt);\n \t  if (exit_edge->flags & EDGE_TRUE_VALUE)\n-\t    gimple_cond_make_true (elt->stmt);\n+\t    gimple_cond_make_true (cond_stmt);\n \t  else\n-\t    gimple_cond_make_false (elt->stmt);\n-\t  update_stmt (elt->stmt);\n+\t    gimple_cond_make_false (cond_stmt);\n+\t  update_stmt (cond_stmt);\n \t  changed = true;\n \t}\n     }\n@@ -591,11 +596,12 @@ remove_redundant_iv_tests (struct loop *loop)\n \t      fprintf (dump_file, \"Removed pointless exit: \");\n \t      print_gimple_stmt (dump_file, elt->stmt, 0, 0);\n \t    }\n+\t  gcond *cond_stmt = as_a <gcond *> (elt->stmt);\n \t  if (exit_edge->flags & EDGE_TRUE_VALUE)\n-\t    gimple_cond_make_false (elt->stmt);\n+\t    gimple_cond_make_false (cond_stmt);\n \t  else\n-\t    gimple_cond_make_true (elt->stmt);\n-\t  update_stmt (elt->stmt);\n+\t    gimple_cond_make_true (cond_stmt);\n+\t  update_stmt (cond_stmt);\n \t  changed = true;\n \t}\n     }\n@@ -630,7 +636,7 @@ unloop_loops (bitmap loop_closed_ssa_invalidated,\n       edge latch_edge = loop_latch_edge (loop);\n       int flags = latch_edge->flags;\n       location_t locus = latch_edge->goto_locus;\n-      gimple stmt;\n+      gcall *stmt;\n       gimple_stmt_iterator gsi;\n \n       remove_exits_and_undefined_stmts (loop, n_unroll);\n@@ -675,7 +681,6 @@ try_unroll_loop_completely (struct loop *loop,\n \t\t\t    location_t locus)\n {\n   unsigned HOST_WIDE_INT n_unroll = 0, ninsns, unr_insns;\n-  gimple cond;\n   struct loop_size size;\n   bool n_unroll_found = false;\n   edge edge_to_cancel = NULL;\n@@ -880,7 +885,7 @@ try_unroll_loop_completely (struct loop *loop,\n   /* Remove the conditional from the last copy of the loop.  */\n   if (edge_to_cancel)\n     {\n-      cond = last_stmt (edge_to_cancel->src);\n+      gcond *cond = as_a <gcond *> (last_stmt (edge_to_cancel->src));\n       if (edge_to_cancel->flags & EDGE_TRUE_VALUE)\n \tgimple_cond_make_false (cond);\n       else\n@@ -1219,12 +1224,10 @@ propagate_into_all_uses (tree ssa_name, tree val)\n static void\n propagate_constants_for_unrolling (basic_block bb)\n {\n-  gimple_stmt_iterator gsi;\n-\n   /* Look for degenerate PHI nodes with constant argument.  */\n-  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); )\n+  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi); )\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n       tree result = gimple_phi_result (phi);\n       tree arg = gimple_phi_arg_def (phi, 0);\n \n@@ -1239,7 +1242,7 @@ propagate_constants_for_unrolling (basic_block bb)\n     }\n \n   /* Look for assignments to SSA names with constant RHS.  */\n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n+  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n     {\n       gimple stmt = gsi_stmt (gsi);\n       tree lhs;"}, {"sha": "4007e5483b27725efdeaa3cc6f52d26f5eb16db8", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -1049,7 +1049,7 @@ get_iv (struct ivopts_data *data, tree var)\n    not define a simple affine biv with nonzero step.  */\n \n static tree\n-determine_biv_step (gimple phi)\n+determine_biv_step (gphi *phi)\n {\n   struct loop *loop = gimple_bb (phi)->loop_father;\n   tree name = PHI_RESULT (phi);\n@@ -1069,15 +1069,15 @@ determine_biv_step (gimple phi)\n static bool\n find_bivs (struct ivopts_data *data)\n {\n-  gimple phi;\n+  gphi *phi;\n   tree step, type, base;\n   bool found = false;\n   struct loop *loop = data->current_loop;\n-  gimple_stmt_iterator psi;\n+  gphi_iterator psi;\n \n   for (psi = gsi_start_phis (loop->header); !gsi_end_p (psi); gsi_next (&psi))\n     {\n-      phi = gsi_stmt (psi);\n+      phi = psi.phi ();\n \n       if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (PHI_RESULT (phi)))\n \tcontinue;\n@@ -1114,16 +1114,17 @@ find_bivs (struct ivopts_data *data)\n static void\n mark_bivs (struct ivopts_data *data)\n {\n-  gimple phi, def;\n+  gphi *phi;\n+  gimple def;\n   tree var;\n   struct iv *iv, *incr_iv;\n   struct loop *loop = data->current_loop;\n   basic_block incr_bb;\n-  gimple_stmt_iterator psi;\n+  gphi_iterator psi;\n \n   for (psi = gsi_start_phis (loop->header); !gsi_end_p (psi); gsi_next (&psi))\n     {\n-      phi = gsi_stmt (psi);\n+      phi = psi.phi ();\n \n       iv = get_iv (data, PHI_RESULT (phi));\n       if (!iv)\n@@ -1390,8 +1391,9 @@ extract_cond_operands (struct ivopts_data *data, gimple stmt,\n \n   if (gimple_code (stmt) == GIMPLE_COND)\n     {\n-      op0 = gimple_cond_lhs_ptr (stmt);\n-      op1 = gimple_cond_rhs_ptr (stmt);\n+      gcond *cond_stmt = as_a <gcond *> (stmt);\n+      op0 = gimple_cond_lhs_ptr (cond_stmt);\n+      op1 = gimple_cond_rhs_ptr (cond_stmt);\n     }\n   else\n     {\n@@ -2006,13 +2008,13 @@ find_interesting_uses_stmt (struct ivopts_data *data, gimple stmt)\n static void\n find_interesting_uses_outside (struct ivopts_data *data, edge exit)\n {\n-  gimple phi;\n-  gimple_stmt_iterator psi;\n+  gphi *phi;\n+  gphi_iterator psi;\n   tree def;\n \n   for (psi = gsi_start_phis (exit->dest); !gsi_end_p (psi); gsi_next (&psi))\n     {\n-      phi = gsi_stmt (psi);\n+      phi = psi.phi ();\n       def = PHI_ARG_DEF_FROM_EDGE (phi, exit);\n       if (!virtual_operand_p (def))\n         find_interesting_uses_op (data, def);\n@@ -5177,8 +5179,8 @@ static void\n determine_set_costs (struct ivopts_data *data)\n {\n   unsigned j, n;\n-  gimple phi;\n-  gimple_stmt_iterator psi;\n+  gphi *phi;\n+  gphi_iterator psi;\n   tree op;\n   struct loop *loop = data->current_loop;\n   bitmap_iterator bi;\n@@ -5195,7 +5197,7 @@ determine_set_costs (struct ivopts_data *data)\n   n = 0;\n   for (psi = gsi_start_phis (loop->header); !gsi_end_p (psi); gsi_next (&psi))\n     {\n-      phi = gsi_stmt (psi);\n+      phi = psi.phi ();\n       op = PHI_RESULT (phi);\n \n       if (virtual_operand_p (op))\n@@ -6219,7 +6221,7 @@ rewrite_use_nonlinear_expr (struct ivopts_data *data,\n {\n   tree comp;\n   tree op, tgt;\n-  gimple ass;\n+  gassign *ass;\n   gimple_stmt_iterator bsi;\n \n   /* An important special case -- if we are asked to express value of\n@@ -6471,9 +6473,10 @@ rewrite_use_compare (struct ivopts_data *data,\n \t\tloop_preheader_edge (data->current_loop),\n \t\tstmts);\n \n-      gimple_cond_set_lhs (use->stmt, var);\n-      gimple_cond_set_code (use->stmt, compare);\n-      gimple_cond_set_rhs (use->stmt, op);\n+      gcond *cond_stmt = as_a <gcond *> (use->stmt);\n+      gimple_cond_set_lhs (cond_stmt, var);\n+      gimple_cond_set_code (cond_stmt, compare);\n+      gimple_cond_set_rhs (cond_stmt, op);\n       return;\n     }\n \n@@ -6636,7 +6639,8 @@ remove_unused_ivs (struct ivopts_data *data)\n \t\t    DECL_MODE (vexpr) = DECL_MODE (SSA_NAME_VAR (def));\n \t\t  else\n \t\t    DECL_MODE (vexpr) = TYPE_MODE (TREE_TYPE (vexpr));\n-\t\t  gimple def_temp = gimple_build_debug_bind (vexpr, comp, NULL);\n+\t\t  gdebug *def_temp\n+\t\t    = gimple_build_debug_bind (vexpr, comp, NULL);\n \t\t  gimple_stmt_iterator gsi;\n \n \t\t  if (gimple_code (SSA_NAME_DEF_STMT (def)) == GIMPLE_PHI)"}, {"sha": "db6f25f39e52b75ad458fe936dc8e9a2c58da1ca", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -82,7 +82,8 @@ create_iv (tree base, tree step, tree var, struct loop *loop,\n \t   gimple_stmt_iterator *incr_pos, bool after,\n \t   tree *var_before, tree *var_after)\n {\n-  gimple stmt;\n+  gassign *stmt;\n+  gphi *phi;\n   tree initial, step1;\n   gimple_seq stmts;\n   tree vb, va;\n@@ -154,9 +155,9 @@ create_iv (tree base, tree step, tree var, struct loop *loop,\n   if (stmts)\n     gsi_insert_seq_on_edge_immediate (pe, stmts);\n \n-  stmt = create_phi_node (vb, loop->header);\n-  add_phi_arg (stmt, initial, loop_preheader_edge (loop), UNKNOWN_LOCATION);\n-  add_phi_arg (stmt, va, loop_latch_edge (loop), UNKNOWN_LOCATION);\n+  phi = create_phi_node (vb, loop->header);\n+  add_phi_arg (phi, initial, loop_preheader_edge (loop), UNKNOWN_LOCATION);\n+  add_phi_arg (phi, va, loop_latch_edge (loop), UNKNOWN_LOCATION);\n }\n \n /* Return the innermost superloop LOOP of USE_LOOP that is a superloop of\n@@ -287,7 +288,7 @@ compute_live_loop_exits (bitmap live_exits, bitmap use_blocks,\n static void\n add_exit_phi (basic_block exit, tree var)\n {\n-  gimple phi;\n+  gphi *phi;\n   edge e;\n   edge_iterator ei;\n \n@@ -441,20 +442,21 @@ find_uses_to_rename_stmt (gimple stmt, bitmap *use_blocks, bitmap need_phis)\n static void\n find_uses_to_rename_bb (basic_block bb, bitmap *use_blocks, bitmap need_phis)\n {\n-  gimple_stmt_iterator bsi;\n   edge e;\n   edge_iterator ei;\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n-    for (bsi = gsi_start_phis (e->dest); !gsi_end_p (bsi); gsi_next (&bsi))\n+    for (gphi_iterator bsi = gsi_start_phis (e->dest); !gsi_end_p (bsi);\n+\t gsi_next (&bsi))\n       {\n-        gimple phi = gsi_stmt (bsi);\n+        gphi *phi = bsi.phi ();\n \tif (! virtual_operand_p (gimple_phi_result (phi)))\n \t  find_uses_to_rename_use (bb, PHI_ARG_DEF_FROM_EDGE (phi, e),\n \t\t\t\t   use_blocks, need_phis);\n       }\n \n-  for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+  for (gimple_stmt_iterator bsi = gsi_start_bb (bb); !gsi_end_p (bsi);\n+       gsi_next (&bsi))\n     find_uses_to_rename_stmt (gsi_stmt (bsi), use_blocks, need_phis);\n }\n \n@@ -600,8 +602,6 @@ DEBUG_FUNCTION void\n verify_loop_closed_ssa (bool verify_ssa_p)\n {\n   basic_block bb;\n-  gimple_stmt_iterator bsi;\n-  gimple phi;\n   edge e;\n   edge_iterator ei;\n \n@@ -615,15 +615,17 @@ verify_loop_closed_ssa (bool verify_ssa_p)\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+      for (gphi_iterator bsi = gsi_start_phis (bb); !gsi_end_p (bsi);\n+\t   gsi_next (&bsi))\n \t{\n-\t  phi = gsi_stmt (bsi);\n+\t  gphi *phi = bsi.phi ();\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    check_loop_closed_ssa_use (e->src,\n \t\t\t\t       PHI_ARG_DEF_FROM_EDGE (phi, e));\n \t}\n \n-      for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+      for (gimple_stmt_iterator bsi = gsi_start_bb (bb); !gsi_end_p (bsi);\n+\t   gsi_next (&bsi))\n \tcheck_loop_closed_ssa_stmt (bb, gsi_stmt (bsi));\n     }\n \n@@ -638,15 +640,15 @@ split_loop_exit_edge (edge exit)\n {\n   basic_block dest = exit->dest;\n   basic_block bb = split_edge (exit);\n-  gimple phi, new_phi;\n+  gphi *phi, *new_phi;\n   tree new_name, name;\n   use_operand_p op_p;\n-  gimple_stmt_iterator psi;\n+  gphi_iterator psi;\n   source_location locus;\n \n   for (psi = gsi_start_phis (dest); !gsi_end_p (psi); gsi_next (&psi))\n     {\n-      phi = gsi_stmt (psi);\n+      phi = psi.phi ();\n       op_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, single_succ_edge (bb));\n       locus = gimple_phi_arg_location_from_edge (phi, single_succ_edge (bb));\n \n@@ -1030,12 +1032,12 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n \t\t\t\ttransform_callback transform,\n \t\t\t\tvoid *data)\n {\n-  gimple exit_if;\n+  gcond *exit_if;\n   tree ctr_before, ctr_after;\n   tree enter_main_cond, exit_base, exit_step, exit_bound;\n   enum tree_code exit_cmp;\n-  gimple phi_old_loop, phi_new_loop, phi_rest;\n-  gimple_stmt_iterator psi_old_loop, psi_new_loop;\n+  gphi *phi_old_loop, *phi_new_loop, *phi_rest;\n+  gphi_iterator psi_old_loop, psi_new_loop;\n   tree init, next, new_init;\n   struct loop *new_loop;\n   basic_block rest, exit_bb;\n@@ -1142,8 +1144,8 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n        !gsi_end_p (psi_old_loop);\n        gsi_next (&psi_old_loop), gsi_next (&psi_new_loop))\n     {\n-      phi_old_loop = gsi_stmt (psi_old_loop);\n-      phi_new_loop = gsi_stmt (psi_new_loop);\n+      phi_old_loop = psi_old_loop.phi ();\n+      phi_new_loop = psi_new_loop.phi ();\n \n       init = PHI_ARG_DEF_FROM_EDGE (phi_old_loop, old_entry);\n       op = PHI_ARG_DEF_PTR_FROM_EDGE (phi_new_loop, new_entry);\n@@ -1227,7 +1229,7 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n   /* Finally create the new counter for number of iterations and add the new\n      exit instruction.  */\n   bsi = gsi_last_nondebug_bb (exit_bb);\n-  exit_if = gsi_stmt (bsi);\n+  exit_if = as_a <gcond *> (gsi_stmt (bsi));\n   create_iv (exit_base, exit_step, NULL_TREE, loop,\n \t     &bsi, false, &ctr_before, &ctr_after);\n   gimple_cond_set_code (exit_if, exit_cmp);\n@@ -1259,12 +1261,13 @@ tree_unroll_loop (struct loop *loop, unsigned factor,\n \n static void\n rewrite_phi_with_iv (loop_p loop,\n-\t\t     gimple_stmt_iterator *psi,\n+\t\t     gphi_iterator *psi,\n \t\t     gimple_stmt_iterator *gsi,\n \t\t     tree main_iv)\n {\n   affine_iv iv;\n-  gimple stmt, phi = gsi_stmt (*psi);\n+  gassign *stmt;\n+  gphi *phi = psi->phi ();\n   tree atype, mtype, val, res = PHI_RESULT (phi);\n \n   if (virtual_operand_p (res) || res == main_iv)\n@@ -1302,7 +1305,7 @@ rewrite_all_phi_nodes_with_iv (loop_p loop, tree main_iv)\n {\n   unsigned i;\n   basic_block *bbs = get_loop_body_in_dom_order (loop);\n-  gimple_stmt_iterator psi;\n+  gphi_iterator psi;\n \n   for (i = 0; i < loop->num_nodes; i++)\n     {\n@@ -1335,8 +1338,9 @@ canonicalize_loop_ivs (struct loop *loop, tree *nit, bool bump_in_latch)\n   unsigned precision = TYPE_PRECISION (TREE_TYPE (*nit));\n   unsigned original_precision = precision;\n   tree type, var_before;\n-  gimple_stmt_iterator gsi, psi;\n-  gimple stmt;\n+  gimple_stmt_iterator gsi;\n+  gphi_iterator psi;\n+  gcond *stmt;\n   edge exit = single_dom_exit (loop);\n   gimple_seq stmts;\n   machine_mode mode;\n@@ -1345,7 +1349,7 @@ canonicalize_loop_ivs (struct loop *loop, tree *nit, bool bump_in_latch)\n   for (psi = gsi_start_phis (loop->header);\n        !gsi_end_p (psi); gsi_next (&psi))\n     {\n-      gimple phi = gsi_stmt (psi);\n+      gphi *phi = psi.phi ();\n       tree res = PHI_RESULT (phi);\n       bool uns;\n \n@@ -1387,7 +1391,7 @@ canonicalize_loop_ivs (struct loop *loop, tree *nit, bool bump_in_latch)\n \n   rewrite_all_phi_nodes_with_iv (loop, var_before);\n \n-  stmt = last_stmt (exit->src);\n+  stmt = as_a <gcond *> (last_stmt (exit->src));\n   /* Make the loop exit if the control condition is not satisfied.  */\n   if (exit->flags & EDGE_TRUE_VALUE)\n     {"}, {"sha": "fd4d5bf7b5ee93597b38f2739f86727dc3f11a4b", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -156,15 +156,15 @@ determine_value_range (struct loop *loop, tree type, tree var, mpz_t off,\n     {\n       edge e = loop_preheader_edge (loop);\n       signop sgn = TYPE_SIGN (type);\n-      gimple_stmt_iterator gsi;\n+      gphi_iterator gsi;\n \n       /* Either for VAR itself...  */\n       rtype = get_range_info (var, &minv, &maxv);\n       /* Or for PHI results in loop->header where VAR is used as\n \t PHI argument from the loop preheader edge.  */\n       for (gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple phi = gsi_stmt (gsi);\n+\t  gphi *phi = gsi.phi ();\n \t  wide_int minc, maxc;\n \t  if (PHI_ARG_DEF_FROM_EDGE (phi, e) == var\n \t      && (get_range_info (gimple_phi_result (phi), &minc, &maxc)\n@@ -1931,7 +1931,8 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n \t\t\t   struct tree_niter_desc *niter,\n \t\t\t   bool warn, bool every_iteration)\n {\n-  gimple stmt;\n+  gimple last;\n+  gcond *stmt;\n   tree type;\n   tree op0, op1;\n   enum tree_code code;\n@@ -1944,8 +1945,11 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n     return false;\n \n   niter->assumptions = boolean_false_node;\n-  stmt = last_stmt (exit->src);\n-  if (!stmt || gimple_code (stmt) != GIMPLE_COND)\n+  last = last_stmt (exit->src);\n+  if (!last)\n+    return false;\n+  stmt = dyn_cast <gcond *> (last);\n+  if (!stmt)\n     return false;\n \n   /* We want the condition for staying inside loop.  */\n@@ -2164,7 +2168,7 @@ finite_loop_p (struct loop *loop)\n    result by a chain of operations such that all but exactly one of their\n    operands are constants.  */\n \n-static gimple\n+static gphi *\n chain_of_csts_start (struct loop *loop, tree x)\n {\n   gimple stmt = SSA_NAME_DEF_STMT (x);\n@@ -2179,7 +2183,7 @@ chain_of_csts_start (struct loop *loop, tree x)\n   if (gimple_code (stmt) == GIMPLE_PHI)\n     {\n       if (bb == loop->header)\n-\treturn stmt;\n+\treturn as_a <gphi *> (stmt);\n \n       return NULL;\n     }\n@@ -2212,10 +2216,10 @@ chain_of_csts_start (struct loop *loop, tree x)\n \n    If such phi node exists, it is returned, otherwise NULL is returned.  */\n \n-static gimple\n+static gphi *\n get_base_for (struct loop *loop, tree x)\n {\n-  gimple phi;\n+  gphi *phi;\n   tree init, next;\n \n   if (is_gimple_min_invariant (x))\n@@ -2306,7 +2310,8 @@ loop_niter_by_eval (struct loop *loop, edge exit)\n {\n   tree acnd;\n   tree op[2], val[2], next[2], aval[2];\n-  gimple phi, cond;\n+  gphi *phi;\n+  gimple cond;\n   unsigned i, j;\n   enum tree_code cmp;\n "}, {"sha": "28ebb3705959470fdd850f31486d28e9422fbf7d", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -1137,7 +1137,7 @@ issue_prefetch_ref (struct mem_ref *ref, unsigned unroll_factor, unsigned ahead)\n {\n   HOST_WIDE_INT delta;\n   tree addr, addr_base, write_p, local, forward;\n-  gimple prefetch;\n+  gcall *prefetch;\n   gimple_stmt_iterator bsi;\n   unsigned n_prefetches, ap;\n   bool nontemporal = ref->reuse_distance >= L2_CACHE_SIZE_BYTES;\n@@ -1254,7 +1254,7 @@ emit_mfence_after_loop (struct loop *loop)\n {\n   vec<edge> exits = get_loop_exit_edges (loop);\n   edge exit;\n-  gimple call;\n+  gcall *call;\n   gimple_stmt_iterator bsi;\n   unsigned i;\n "}, {"sha": "bad33ae435cc52ef013147749fa5132e7c91e6a5", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -148,15 +148,17 @@ tree_ssa_unswitch_loops (void)\n static tree\n tree_may_unswitch_on (basic_block bb, struct loop *loop)\n {\n-  gimple stmt, def;\n+  gimple last, def;\n+  gcond *stmt;\n   tree cond, use;\n   basic_block def_bb;\n   ssa_op_iter iter;\n \n   /* BB must end in a simple conditional jump.  */\n-  stmt = last_stmt (bb);\n-  if (!stmt || gimple_code (stmt) != GIMPLE_COND)\n+  last = last_stmt (bb);\n+  if (!last || gimple_code (last) != GIMPLE_COND)\n     return NULL_TREE;\n+  stmt = as_a <gcond *> (last);\n \n   /* To keep the things simple, we do not directly remove the conditions,\n      but just replace tests with 0 != 0 resp. 1 != 0.  Prevent the infinite\n@@ -258,13 +260,15 @@ tree_unswitch_single_loop (struct loop *loop, int num)\n       if (integer_nonzerop (cond))\n \t{\n \t  /* Remove false path.  */\n-\t  gimple_cond_set_condition_from_tree (stmt, boolean_true_node);\n+\t  gimple_cond_set_condition_from_tree (as_a <gcond *> (stmt),\n+\t\t\t\t\t       boolean_true_node);\n \t  changed = true;\n \t}\n       else if (integer_zerop (cond))\n \t{\n \t  /* Remove true path.  */\n-\t  gimple_cond_set_condition_from_tree (stmt, boolean_false_node);\n+\t  gimple_cond_set_condition_from_tree (as_a <gcond *> (stmt),\n+\t\t\t\t\t       boolean_false_node);\n \t  changed = true;\n \t}\n       /* Do not unswitch too much.  */\n@@ -326,9 +330,10 @@ tree_unswitch_single_loop (struct loop *loop, int num)\n \t      if (stmt\n \t\t  && gimple_code (stmt) == GIMPLE_COND)\n \t\t{\n-\t\t  if (gimple_cond_true_p (stmt))\n+\t\t  gcond *cond_stmt = as_a <gcond *> (stmt);\n+\t\t  if (gimple_cond_true_p (cond_stmt))\n \t\t    flags = EDGE_FALSE_VALUE;\n-\t\t  else if (gimple_cond_false_p (stmt))\n+\t\t  else if (gimple_cond_false_p (cond_stmt))\n \t\t    flags = EDGE_TRUE_VALUE;\n \t\t}\n \t    }"}, {"sha": "f9c30bf72b6e06e6ce5a0f4a144b1f1bd5579afc", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -367,7 +367,7 @@ insert_reciprocals (gimple_stmt_iterator *def_gsi, struct occurrence *occ,\n \t\t    tree def, tree recip_def, int threshold)\n {\n   tree type;\n-  gimple new_stmt;\n+  gassign *new_stmt;\n   gimple_stmt_iterator gsi;\n   struct occurrence *occ_child;\n \n@@ -577,20 +577,20 @@ pass_cse_reciprocals::execute (function *fun)\n \n   FOR_EACH_BB_FN (bb, fun)\n     {\n-      gimple_stmt_iterator gsi;\n-      gimple phi;\n       tree def;\n \n-      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n \t{\n-\t  phi = gsi_stmt (gsi);\n+\t  gphi *phi = gsi.phi ();\n \t  def = PHI_RESULT (phi);\n \t  if (! virtual_operand_p (def)\n \t      && FLOAT_TYPE_P (TREE_TYPE (def)))\n \t    execute_cse_reciprocals_1 (NULL, def);\n \t}\n \n-      for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gimple_stmt_iterator gsi = gsi_after_labels (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n         {\n \t  gimple stmt = gsi_stmt (gsi);\n \n@@ -605,7 +605,8 @@ pass_cse_reciprocals::execute (function *fun)\n         continue;\n \n       /* Scan for a/func(b) and convert it to reciprocal a*rfunc(b).  */\n-      for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gimple_stmt_iterator gsi = gsi_after_labels (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n         {\n \t  gimple stmt = gsi_stmt (gsi);\n \t  tree fndecl;\n@@ -983,7 +984,7 @@ powi_as_mults_1 (gimple_stmt_iterator *gsi, location_t loc, tree type,\n {\n   tree op0, op1, ssa_target;\n   unsigned HOST_WIDE_INT digit;\n-  gimple mult_stmt;\n+  gassign *mult_stmt;\n \n   if (n < POWI_TABLE_SIZE && cache[n])\n     return cache[n];\n@@ -1023,7 +1024,7 @@ powi_as_mults (gimple_stmt_iterator *gsi, location_t loc,\n \t       tree arg0, HOST_WIDE_INT n)\n {\n   tree cache[POWI_TABLE_SIZE], result, type = TREE_TYPE (arg0);\n-  gimple div_stmt;\n+  gassign *div_stmt;\n   tree target;\n \n   if (n == 0)\n@@ -1076,7 +1077,7 @@ static tree\n build_and_insert_call (gimple_stmt_iterator *gsi, location_t loc,\n \t\t       tree fn, tree arg)\n {\n-  gimple call_stmt;\n+  gcall *call_stmt;\n   tree ssa_target;\n \n   call_stmt = gimple_build_call (fn, 1, arg);\n@@ -1099,7 +1100,7 @@ build_and_insert_binop (gimple_stmt_iterator *gsi, location_t loc,\n \t\t\ttree arg0, tree arg1)\n {\n   tree result = make_temp_ssa_name (TREE_TYPE (arg0), NULL, name);\n-  gimple stmt = gimple_build_assign_with_ops (code, result, arg0, arg1);\n+  gassign *stmt = gimple_build_assign_with_ops (code, result, arg0, arg1);\n   gimple_set_location (stmt, loc);\n   gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n   return result;\n@@ -1129,7 +1130,7 @@ build_and_insert_cast (gimple_stmt_iterator *gsi, location_t loc,\n \t\t       tree type, tree val)\n {\n   tree result = make_ssa_name (type, NULL);\n-  gimple stmt = gimple_build_assign_with_ops (NOP_EXPR, result, val);\n+  gassign *stmt = gimple_build_assign_with_ops (NOP_EXPR, result, val);\n   gimple_set_location (stmt, loc);\n   gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n   return result;\n@@ -1506,7 +1507,7 @@ pass_cse_sincos::execute (function *fun)\n \t\t  if (result)\n \t\t    {\n \t\t      tree lhs = gimple_get_lhs (stmt);\n-\t\t      gimple new_stmt = gimple_build_assign (lhs, result);\n+\t\t      gassign *new_stmt = gimple_build_assign (lhs, result);\n \t\t      gimple_set_location (new_stmt, loc);\n \t\t      unlink_stmt_vdef (stmt);\n \t\t      gsi_replace (&gsi, new_stmt, true);\n@@ -1524,7 +1525,7 @@ pass_cse_sincos::execute (function *fun)\n \t\t  if (real_minus_onep (arg0))\n \t\t    {\n                       tree t0, t1, cond, one, minus_one;\n-\t\t      gimple stmt;\n+\t\t      gassign *stmt;\n \n \t\t      t0 = TREE_TYPE (arg0);\n \t\t      t1 = TREE_TYPE (arg1);\n@@ -1558,7 +1559,7 @@ pass_cse_sincos::execute (function *fun)\n \t\t  if (result)\n \t\t    {\n \t\t      tree lhs = gimple_get_lhs (stmt);\n-\t\t      gimple new_stmt = gimple_build_assign (lhs, result);\n+\t\t      gassign *new_stmt = gimple_build_assign (lhs, result);\n \t\t      gimple_set_location (new_stmt, loc);\n \t\t      unlink_stmt_vdef (stmt);\n \t\t      gsi_replace (&gsi, new_stmt, true);\n@@ -1576,7 +1577,7 @@ pass_cse_sincos::execute (function *fun)\n \t\t  if (result)\n \t\t    {\n \t\t      tree lhs = gimple_get_lhs (stmt);\n-\t\t      gimple new_stmt = gimple_build_assign (lhs, result);\n+\t\t      gassign *new_stmt = gimple_build_assign (lhs, result);\n \t\t      gimple_set_location (new_stmt, loc);\n \t\t      unlink_stmt_vdef (stmt);\n \t\t      gsi_replace (&gsi, new_stmt, true);\n@@ -2986,7 +2987,8 @@ convert_mult_to_fma (gimple mul_stmt, tree op1, tree op2)\n {\n   tree mul_result = gimple_get_lhs (mul_stmt);\n   tree type = TREE_TYPE (mul_result);\n-  gimple use_stmt, neguse_stmt, fma_stmt;\n+  gimple use_stmt, neguse_stmt;\n+  gassign *fma_stmt;\n   use_operand_p use_p;\n   imm_use_iterator imm_iter;\n "}, {"sha": "7d509b170bec9a41ac80722f5329f20f11a5ebba", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -642,7 +642,7 @@ get_tmr_operands (struct function *fn, gimple stmt, tree expr, int flags)\n    escape, add them to the VDEF/VUSE lists for it.  */\n \n static void\n-maybe_add_call_vops (struct function *fn, gimple stmt)\n+maybe_add_call_vops (struct function *fn, gcall *stmt)\n {\n   int call_flags = gimple_call_flags (stmt);\n \n@@ -663,7 +663,7 @@ maybe_add_call_vops (struct function *fn, gimple stmt)\n /* Scan operands in the ASM_EXPR stmt referred to in INFO.  */\n \n static void\n-get_asm_stmt_operands (struct function *fn, gimple stmt)\n+get_asm_stmt_operands (struct function *fn, gasm *stmt)\n {\n   size_t i, noutputs;\n   const char **oconstraints;\n@@ -917,7 +917,7 @@ parse_ssa_operands (struct function *fn, gimple stmt)\n   switch (code)\n     {\n     case GIMPLE_ASM:\n-      get_asm_stmt_operands (fn, stmt);\n+      get_asm_stmt_operands (fn, as_a <gasm *> (stmt));\n       break;\n \n     case GIMPLE_TRANSACTION:\n@@ -938,7 +938,7 @@ parse_ssa_operands (struct function *fn, gimple stmt)\n \n     case GIMPLE_CALL:\n       /* Add call-clobbered operands, if needed.  */\n-      maybe_add_call_vops (fn, stmt);\n+      maybe_add_call_vops (fn, as_a <gcall *> (stmt));\n       /* FALLTHRU */\n \n     case GIMPLE_ASSIGN:"}, {"sha": "6ee2c39e618d21792ea8698c9012e5d93de77276", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -73,7 +73,7 @@ along with GCC; see the file COPYING3.  If not see\n \n static unsigned int tree_ssa_phiopt_worker (bool, bool);\n static bool conditional_replacement (basic_block, basic_block,\n-\t\t\t\t     edge, edge, gimple, tree, tree);\n+\t\t\t\t     edge, edge, gphi *, tree, tree);\n static int value_replacement (basic_block, basic_block,\n \t\t\t      edge, edge, gimple, tree, tree);\n static bool minmax_replacement (basic_block, basic_block,\n@@ -149,16 +149,16 @@ tree_ssa_cs_elim (void)\n \n /* Return the singleton PHI in the SEQ of PHIs for edges E0 and E1. */\n \n-static gimple\n+static gphi *\n single_non_singleton_phi_for_edges (gimple_seq seq, edge e0, edge e1)\n {\n   gimple_stmt_iterator i;\n-  gimple phi = NULL;\n+  gphi *phi = NULL;\n   if (gimple_seq_singleton_p (seq))\n-    return gsi_stmt (gsi_start (seq));\n+    return as_a <gphi *> (gsi_stmt (gsi_start (seq)));\n   for (i = gsi_start (seq); !gsi_end_p (i); gsi_next (&i))\n     {\n-      gimple p = gsi_stmt (i);\n+      gphi *p = as_a <gphi *> (gsi_stmt (i));\n       /* If the PHI arguments are equal then we can skip this PHI. */\n       if (operand_equal_for_phi_arg_p (gimple_phi_arg_def (p, e0->dest_idx),\n \t\t\t\t       gimple_phi_arg_def (p, e1->dest_idx)))\n@@ -222,7 +222,8 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads)\n \n   for (i = 0; i < n; i++)\n     {\n-      gimple cond_stmt, phi;\n+      gimple cond_stmt;\n+      gphi *phi;\n       basic_block bb1, bb2;\n       edge e1, e2;\n       tree arg0, arg1;\n@@ -333,7 +334,7 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads)\n \t     so try that first. */\n \t  for (gsi = gsi_start (phis); !gsi_end_p (gsi); gsi_next (&gsi))\n \t    {\n-\t      phi = gsi_stmt (gsi);\n+\t      phi = as_a <gphi *> (gsi_stmt (gsi));\n \t      arg0 = gimple_phi_arg_def (phi, e1->dest_idx);\n \t      arg1 = gimple_phi_arg_def (phi, e2->dest_idx);\n \t      if (value_replacement (bb, bb1, e1, e2, phi, arg0, arg1) == 2)\n@@ -444,11 +445,12 @@ replace_phi_edge_with_variable (basic_block cond_block,\n \n static bool\n conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n-\t\t\t edge e0, edge e1, gimple phi,\n+\t\t\t edge e0, edge e1, gphi *phi,\n \t\t\t tree arg0, tree arg1)\n {\n   tree result;\n-  gimple stmt, new_stmt;\n+  gimple stmt;\n+  gassign *new_stmt;\n   tree cond;\n   gimple_stmt_iterator gsi;\n   edge true_edge, false_edge;\n@@ -921,7 +923,8 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n \t\t    tree arg0, tree arg1)\n {\n   tree result, type;\n-  gimple cond, new_stmt;\n+  gcond *cond;\n+  gassign *new_stmt;\n   edge true_edge, false_edge;\n   enum tree_code cmp, minmax, ass_code;\n   tree smaller, larger, arg_true, arg_false;\n@@ -933,7 +936,7 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n   if (HONOR_NANS (TYPE_MODE (type)))\n     return false;\n \n-  cond = last_stmt (cond_bb);\n+  cond = as_a <gcond *> (last_stmt (cond_bb));\n   cmp = gimple_cond_code (cond);\n \n   /* This transformation is only valid for order comparisons.  Record which\n@@ -1168,7 +1171,8 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n \t\t gimple phi, tree arg0, tree arg1)\n {\n   tree result;\n-  gimple new_stmt, cond;\n+  gassign *new_stmt;\n+  gimple cond;\n   gimple_stmt_iterator gsi;\n   edge true_edge, false_edge;\n   gimple assign;\n@@ -1649,7 +1653,8 @@ cond_store_replacement (basic_block middle_bb, basic_block join_bb,\n {\n   gimple assign = last_and_only_stmt (middle_bb);\n   tree lhs, rhs, name, name2;\n-  gimple newphi, new_stmt;\n+  gphi *newphi;\n+  gassign *new_stmt;\n   gimple_stmt_iterator gsi;\n   source_location locus;\n \n@@ -1722,7 +1727,8 @@ cond_if_else_store_replacement_1 (basic_block then_bb, basic_block else_bb,\n   tree lhs_base, lhs, then_rhs, else_rhs, name;\n   source_location then_locus, else_locus;\n   gimple_stmt_iterator gsi;\n-  gimple newphi, new_stmt;\n+  gphi *newphi;\n+  gassign *new_stmt;\n \n   if (then_assign == NULL\n       || !gimple_assign_single_p (then_assign)\n@@ -2016,14 +2022,14 @@ hoist_adjacent_loads (basic_block bb0, basic_block bb1,\n {\n   int param_align = PARAM_VALUE (PARAM_L1_CACHE_LINE_SIZE);\n   unsigned param_align_bits = (unsigned) (param_align * BITS_PER_UNIT);\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n \n   /* Walk the phis in bb3 looking for an opportunity.  We are looking\n      for phis of two SSA names, one each of which is defined in bb1 and\n      bb2.  */\n   for (gsi = gsi_start_phis (bb3); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple phi_stmt = gsi_stmt (gsi);\n+      gphi *phi_stmt = gsi.phi ();\n       gimple def1, def2, defswap;\n       tree arg1, arg2, ref1, ref2, field1, field2, fieldswap;\n       tree tree_offset1, tree_offset2, tree_size2, next;"}, {"sha": "8caab38b985716d099cb9948dbfff74f8c338989", "filename": "gcc/tree-ssa-phiprop.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-phiprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-phiprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiprop.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -149,11 +149,11 @@ phivn_valid_p (struct phiprop_d *phivn, tree name, basic_block bb)\n    BB with the virtual operands from USE_STMT.  */\n \n static tree\n-phiprop_insert_phi (basic_block bb, gimple phi, gimple use_stmt,\n+phiprop_insert_phi (basic_block bb, gphi *phi, gimple use_stmt,\n \t\t    struct phiprop_d *phivn, size_t n)\n {\n   tree res;\n-  gimple new_phi;\n+  gphi *new_phi;\n   edge_iterator ei;\n   edge e;\n \n@@ -176,7 +176,7 @@ phiprop_insert_phi (basic_block bb, gimple phi, gimple use_stmt,\n   FOR_EACH_EDGE (e, ei, bb->preds)\n     {\n       tree old_arg, new_var;\n-      gimple tmp;\n+      gassign *tmp;\n       source_location locus;\n \n       old_arg = PHI_ARG_DEF_FROM_EDGE (phi, e);\n@@ -257,7 +257,7 @@ phiprop_insert_phi (basic_block bb, gimple phi, gimple use_stmt,\n    with aliasing issues as we are moving memory reads.  */\n \n static bool\n-propagate_with_phi (basic_block bb, gimple phi, struct phiprop_d *phivn,\n+propagate_with_phi (basic_block bb, gphi *phi, struct phiprop_d *phivn,\n \t\t    size_t n)\n {\n   tree ptr = PHI_RESULT (phi);\n@@ -419,7 +419,7 @@ pass_phiprop::execute (function *fun)\n   struct phiprop_d *phivn;\n   bool did_something = false;\n   basic_block bb;\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n   unsigned i;\n   size_t n;\n \n@@ -434,7 +434,7 @@ pass_phiprop::execute (function *fun)\n \t\t\t\t  single_succ (ENTRY_BLOCK_PTR_FOR_FN (fun)));\n   FOR_EACH_VEC_ELT (bbs, i, bb)\n     for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-      did_something |= propagate_with_phi (bb, gsi_stmt (gsi), phivn, n);\n+      did_something |= propagate_with_phi (bb, gsi.phi (), phivn, n);\n \n   if (did_something)\n     gsi_commit_edge_inserts ();"}, {"sha": "c42b2a4dc1b4eb7759002ff6dcc9c596d0b9f015", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 34, "deletions": 27, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -2801,7 +2801,7 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n   gimple_stmt_iterator gsi;\n   tree exprtype = type ? type : get_expr_type (expr);\n   pre_expr nameexpr;\n-  gimple newstmt;\n+  gassign *newstmt;\n \n   switch (expr->kind)\n     {\n@@ -2983,7 +2983,7 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n   edge_iterator ei;\n   tree type = get_expr_type (expr);\n   tree temp;\n-  gimple phi;\n+  gphi *phi;\n \n   /* Make sure we aren't creating an induction variable.  */\n   if (bb_loop_depth (block) > 0 && EDGE_COUNT (block->preds) == 2)\n@@ -3332,8 +3332,11 @@ do_regular_insertion (basic_block block, basic_block dom)\n \n \t      tree temp = make_temp_ssa_name (get_expr_type (expr),\n \t\t\t\t\t      NULL, \"pretmp\");\n-\t      gimple assign = gimple_build_assign (temp,\n-\t\t\t\t\t\t   edoubleprime->kind == CONSTANT ? PRE_EXPR_CONSTANT (edoubleprime) : PRE_EXPR_NAME (edoubleprime));\n+\t      gassign *assign\n+\t\t= gimple_build_assign (temp,\n+\t\t\t\t       edoubleprime->kind == CONSTANT ?\n+\t\t\t\t       PRE_EXPR_CONSTANT (edoubleprime) :\n+\t\t\t\t       PRE_EXPR_NAME (edoubleprime));\n \t      gimple_stmt_iterator gsi = gsi_after_labels (block);\n \t      gsi_insert_before (&gsi, assign, GSI_NEW_STMT);\n \n@@ -3630,7 +3633,6 @@ compute_avail (void)\n   /* Loop until the worklist is empty.  */\n   while (sp)\n     {\n-      gimple_stmt_iterator gsi;\n       gimple stmt;\n       basic_block dom;\n \n@@ -3647,9 +3649,10 @@ compute_avail (void)\n \t}\n \n       /* Generate values for PHI nodes.  */\n-      for (gsi = gsi_start_phis (block); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gphi_iterator gsi = gsi_start_phis (block); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n \t{\n-\t  tree result = gimple_phi_result (gsi_stmt (gsi));\n+\t  tree result = gimple_phi_result (gsi.phi ());\n \n \t  /* We have no need for virtual phis, as they don't represent\n \t     actual computations.  */\n@@ -3669,7 +3672,8 @@ compute_avail (void)\n \n       /* Now compute value numbers and populate value sets with all\n \t the expressions computed in BLOCK.  */\n-      for (gsi = gsi_start_bb (block); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (block); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n \t{\n \t  ssa_op_iter iter;\n \t  tree op;\n@@ -3732,7 +3736,7 @@ compute_avail (void)\n \t\tif (gimple_call_internal_p (stmt))\n \t\t  continue;\n \n-\t\tvn_reference_lookup_call (stmt, &ref, &ref1);\n+\t\tvn_reference_lookup_call (as_a <gcall *> (stmt), &ref, &ref1);\n \t\tif (!ref)\n \t\t  continue;\n \n@@ -3931,9 +3935,9 @@ eliminate_insert (gimple_stmt_iterator *gsi, tree val)\n     return NULL_TREE;\n \n   tree res = make_temp_ssa_name (TREE_TYPE (val), NULL, \"pretmp\");\n-  gimple tem = gimple_build_assign (res,\n-\t\t\t\t    fold_build1 (TREE_CODE (expr),\n-\t\t\t\t\t\t TREE_TYPE (expr), leader));\n+  gassign *tem = gimple_build_assign (res,\n+\t\t\t\t      fold_build1 (TREE_CODE (expr),\n+\t\t\t\t\t\t   TREE_TYPE (expr), leader));\n   gsi_insert_before (gsi, tem, GSI_SAME_STMT);\n   VN_INFO_GET (res)->valnum = val;\n \n@@ -3967,19 +3971,16 @@ class eliminate_dom_walker : public dom_walker\n void\n eliminate_dom_walker::before_dom_children (basic_block b)\n {\n-  gimple_stmt_iterator gsi;\n-  gimple stmt;\n-\n   /* Mark new bb.  */\n   el_avail_stack.safe_push (NULL_TREE);\n \n   /* ???  If we do nothing for unreachable blocks then this will confuse\n      tailmerging.  Eventually we can reduce its reliance on SCCVN now\n      that we fully copy/constant-propagate (most) things.  */\n \n-  for (gsi = gsi_start_phis (b); !gsi_end_p (gsi);)\n+  for (gphi_iterator gsi = gsi_start_phis (b); !gsi_end_p (gsi);)\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n       tree res = PHI_RESULT (phi);\n \n       if (virtual_operand_p (res))\n@@ -4040,10 +4041,12 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n       gsi_next (&gsi);\n     }\n \n-  for (gsi = gsi_start_bb (b); !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gimple_stmt_iterator gsi = gsi_start_bb (b);\n+       !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n     {\n       tree sprime = NULL_TREE;\n-      stmt = gsi_stmt (gsi);\n+      gimple stmt = gsi_stmt (gsi);\n       tree lhs = gimple_get_lhs (stmt);\n       if (lhs && TREE_CODE (lhs) == SSA_NAME\n \t  && !gimple_has_volatile_ops (stmt)\n@@ -4316,9 +4319,9 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \n       /* Visit indirect calls and turn them into direct calls if\n \t possible using the devirtualization machinery.  */\n-      if (is_gimple_call (stmt))\n+      if (gcall *call_stmt = dyn_cast <gcall *> (stmt))\n \t{\n-\t  tree fn = gimple_call_fn (stmt);\n+\t  tree fn = gimple_call_fn (call_stmt);\n \t  if (fn\n \t      && flag_devirtualize\n \t      && virtual_method_call_p (fn))\n@@ -4357,7 +4360,7 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t\t\t\t       \"function %s\\n\",\n \t\t\t\t       cgraph_node::get (fn)->name ());\n \t\t    }\n-\t\t  gimple_call_set_fndecl (stmt, fn);\n+\t\t  gimple_call_set_fndecl (call_stmt, fn);\n \t\t  gimple_set_modified (stmt, true);\n \t\t}\n \t    }\n@@ -4387,10 +4390,12 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t      fold_stmt (&gsi);\n \t      stmt = gsi_stmt (gsi);\n \t      if ((gimple_code (stmt) == GIMPLE_COND\n-\t\t   && (gimple_cond_true_p (stmt)\n-\t\t       || gimple_cond_false_p (stmt)))\n+\t\t   && (gimple_cond_true_p (as_a <gcond *> (stmt))\n+\t\t       || gimple_cond_false_p (as_a <gcond *> (stmt))))\n \t\t  || (gimple_code (stmt) == GIMPLE_SWITCH\n-\t\t      && TREE_CODE (gimple_switch_index (stmt)) == INTEGER_CST))\n+\t\t      && TREE_CODE (gimple_switch_index (\n+\t\t\t\t      as_a <gswitch *> (stmt)))\n+\t\t         == INTEGER_CST))\n \t\tel_todo |= TODO_cleanup_cfg;\n \t    }\n \t  /* If we removed EH side-effects from the statement, clean\n@@ -4428,9 +4433,11 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n   edge e;\n   FOR_EACH_EDGE (e, ei, b->succs)\n     {\n-      for (gsi = gsi_start_phis (e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gphi_iterator gsi = gsi_start_phis (e->dest);\n+\t   !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n \t{\n-\t  gimple phi = gsi_stmt (gsi);\n+\t  gphi *phi = gsi.phi ();\n \t  use_operand_p use_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, e);\n \t  tree arg = USE_FROM_PTR (use_p);\n \t  if (TREE_CODE (arg) != SSA_NAME"}, {"sha": "94a34ee2d2bf7c941bf3416fb3e2801a2e19438c", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -333,7 +333,7 @@ simulate_stmt (gimple stmt)\n \n   if (gimple_code (stmt) == GIMPLE_PHI)\n     {\n-      val = ssa_prop_visit_phi (stmt);\n+      val = ssa_prop_visit_phi (as_a <gphi *> (stmt));\n       output_name = gimple_phi_result (stmt);\n     }\n   else\n@@ -748,7 +748,7 @@ bool\n update_gimple_call (gimple_stmt_iterator *si_p, tree fn, int nargs, ...)\n {\n   va_list ap;\n-  gimple new_stmt, stmt = gsi_stmt (*si_p);\n+  gcall *new_stmt, *stmt = as_a <gcall *> (gsi_stmt (*si_p));\n \n   gcc_assert (is_gimple_call (stmt));\n   va_start (ap, nargs);\n@@ -782,7 +782,7 @@ update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n       unsigned i;\n       unsigned nargs = call_expr_nargs (expr);\n       vec<tree> args = vNULL;\n-      gimple new_stmt;\n+      gcall *new_stmt;\n \n       if (nargs > 0)\n         {\n@@ -975,7 +975,7 @@ replace_uses_in (gimple stmt, ssa_prop_get_value_fn get_value)\n    values from PROP_VALUE.  */\n \n static bool\n-replace_phi_args_in (gimple phi, ssa_prop_get_value_fn get_value)\n+replace_phi_args_in (gphi *phi, ssa_prop_get_value_fn get_value)\n {\n   size_t i;\n   bool replaced = false;\n@@ -1063,12 +1063,12 @@ class substitute_and_fold_dom_walker : public dom_walker\n void\n substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n {\n-  gimple_stmt_iterator i;\n-\n   /* Propagate known values into PHI nodes.  */\n-  for (i = gsi_start_phis (bb); !gsi_end_p (i); gsi_next (&i))\n+  for (gphi_iterator i = gsi_start_phis (bb);\n+       !gsi_end_p (i);\n+       gsi_next (&i))\n     {\n-      gimple phi = gsi_stmt (i);\n+      gphi *phi = i.phi ();\n       tree res = gimple_phi_result (phi);\n       if (virtual_operand_p (res))\n \tcontinue;\n@@ -1089,7 +1089,9 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n \n   /* Propagate known values into stmts.  In some case it exposes\n      more trivially deletable stmts to walk backward.  */\n-  for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n+  for (gimple_stmt_iterator i = gsi_start_bb (bb);\n+       !gsi_end_p (i);\n+       gsi_next (&i))\n     {\n       bool did_replace;\n       gimple stmt = gsi_stmt (i);\n@@ -1326,8 +1328,8 @@ may_propagate_copy_into_stmt (gimple dest, tree orig)\n \n   if (gimple_assign_single_p (dest))\n     return may_propagate_copy (gimple_assign_rhs1 (dest), orig);\n-  else if (gimple_code (dest) == GIMPLE_SWITCH)\n-    return may_propagate_copy (gimple_switch_index (dest), orig);\n+  else if (gswitch *dest_swtch = dyn_cast <gswitch *> (dest))\n+    return may_propagate_copy (gimple_switch_index (dest_swtch), orig);\n \n   /* In other cases, the expression is not materialized, so there\n      is no destination to pass to may_propagate_copy.  On the other\n@@ -1455,14 +1457,14 @@ propagate_tree_value_into_stmt (gimple_stmt_iterator *gsi, tree val)\n       propagate_tree_value (&expr, val);\n       gimple_assign_set_rhs_from_tree (gsi, expr);\n     }\n-  else if (gimple_code (stmt) == GIMPLE_COND)\n+  else if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n     {\n       tree lhs = NULL_TREE;\n       tree rhs = build_zero_cst (TREE_TYPE (val));\n       propagate_tree_value (&lhs, val);\n-      gimple_cond_set_code (stmt, NE_EXPR);\n-      gimple_cond_set_lhs (stmt, lhs);\n-      gimple_cond_set_rhs (stmt, rhs);\n+      gimple_cond_set_code (cond_stmt, NE_EXPR);\n+      gimple_cond_set_lhs (cond_stmt, lhs);\n+      gimple_cond_set_rhs (cond_stmt, rhs);\n     }\n   else if (is_gimple_call (stmt)\n            && gimple_call_lhs (stmt) != NULL_TREE)\n@@ -1473,8 +1475,8 @@ propagate_tree_value_into_stmt (gimple_stmt_iterator *gsi, tree val)\n       res = update_call_from_tree (gsi, expr);\n       gcc_assert (res);\n     }\n-  else if (gimple_code (stmt) == GIMPLE_SWITCH)\n-    propagate_tree_value (gimple_switch_index_ptr (stmt), val);\n+  else if (gswitch *swtch_stmt = dyn_cast <gswitch *> (stmt))\n+    propagate_tree_value (gimple_switch_index_ptr (swtch_stmt), val);\n   else\n     gcc_unreachable ();\n }"}, {"sha": "0f8b42ee139d739cb73d7ec8d6fc01822f9d39ff", "filename": "gcc/tree-ssa-propagate.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-propagate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-propagate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -63,7 +63,7 @@ enum ssa_prop_result {\n \n /* Call-back functions used by the value propagation engine.  */\n typedef enum ssa_prop_result (*ssa_prop_visit_stmt_fn) (gimple, edge *, tree *);\n-typedef enum ssa_prop_result (*ssa_prop_visit_phi_fn) (gimple);\n+typedef enum ssa_prop_result (*ssa_prop_visit_phi_fn) (gphi *);\n typedef bool (*ssa_prop_fold_stmt_fn) (gimple_stmt_iterator *gsi);\n typedef tree (*ssa_prop_get_value_fn) (tree);\n "}, {"sha": "df99f0dea676bda6c54d351df2807f42de681472", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -1338,7 +1338,7 @@ build_and_add_sum (tree type, tree op1, tree op2, enum tree_code opcode)\n   gimple op1def = NULL, op2def = NULL;\n   gimple_stmt_iterator gsi;\n   tree op;\n-  gimple sum;\n+  gassign *sum;\n \n   /* Create the addition statement.  */\n   op = make_ssa_name (type, NULL);\n@@ -2787,7 +2787,7 @@ suitable_cond_bb (basic_block bb, basic_block test_bb, basic_block *other_bb,\n   edge_iterator ei, ei2;\n   edge e, e2;\n   gimple stmt;\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n   bool other_edge_seen = false;\n   bool is_cond;\n \n@@ -2849,7 +2849,7 @@ suitable_cond_bb (basic_block bb, basic_block test_bb, basic_block *other_bb,\n   e2 = find_edge (test_bb, *other_bb);\n   for (gsi = gsi_start_phis (e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n       /* If both BB and TEST_BB end with GIMPLE_COND, all PHI arguments\n \t corresponding to BB and TEST_BB predecessor must be the same.  */\n       if (!operand_equal_p (gimple_phi_arg_def (phi, e->dest_idx),\n@@ -3000,8 +3000,8 @@ update_ops (tree var, enum tree_code code, vec<operand_entry_t> ops,\n     {\n       gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n       var = make_ssa_name (TREE_TYPE (var), NULL);\n-      gimple g = gimple_build_assign_with_ops (gimple_assign_rhs_code (stmt),\n-\t\t\t\t\t       var, rhs[2], rhs[3]);\n+      gassign *g = gimple_build_assign_with_ops (gimple_assign_rhs_code (stmt),\n+\t\t\t\t\t\t var, rhs[2], rhs[3]);\n       gimple_set_uid (g, gimple_uid (stmt));\n       gimple_set_visited (g, true);\n       gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n@@ -3299,7 +3299,7 @@ maybe_optimize_range_tests (gimple stmt)\n \t\t      tree new_lhs = make_ssa_name (TREE_TYPE (lhs), NULL);\n \t\t      enum tree_code rhs_code\n \t\t\t= gimple_assign_rhs_code (cast_stmt);\n-\t\t      gimple g;\n+\t\t      gassign *g;\n \t\t      if (is_gimple_min_invariant (new_op))\n \t\t\t{\n \t\t\t  new_op = fold_convert (TREE_TYPE (lhs), new_op);\n@@ -3333,18 +3333,19 @@ maybe_optimize_range_tests (gimple stmt)\n \t      && bbinfo[idx].op == NULL_TREE\n \t      && ops[bbinfo[idx].first_idx]->op != NULL_TREE)\n \t    {\n-\t      stmt = last_stmt (bb);\n+\t      gcond *cond_stmt = as_a <gcond *> (last_stmt (bb));\n \t      if (integer_zerop (ops[bbinfo[idx].first_idx]->op))\n-\t\tgimple_cond_make_false (stmt);\n+\t\tgimple_cond_make_false (cond_stmt);\n \t      else if (integer_onep (ops[bbinfo[idx].first_idx]->op))\n-\t\tgimple_cond_make_true (stmt);\n+\t\tgimple_cond_make_true (cond_stmt);\n \t      else\n \t\t{\n-\t\t  gimple_cond_set_code (stmt, NE_EXPR);\n-\t\t  gimple_cond_set_lhs (stmt, ops[bbinfo[idx].first_idx]->op);\n-\t\t  gimple_cond_set_rhs (stmt, boolean_false_node);\n+\t\t  gimple_cond_set_code (cond_stmt, NE_EXPR);\n+\t\t  gimple_cond_set_lhs (cond_stmt,\n+\t\t\t\t       ops[bbinfo[idx].first_idx]->op);\n+\t\t  gimple_cond_set_rhs (cond_stmt, boolean_false_node);\n \t\t}\n-\t      update_stmt (stmt);\n+\t      update_stmt (cond_stmt);\n \t    }\n \t  if (bb == first_bb)\n \t    break;\n@@ -3360,6 +3361,7 @@ static bool\n is_phi_for_stmt (gimple stmt, tree operand)\n {\n   gimple def_stmt;\n+  gphi *def_phi;\n   tree lhs;\n   use_operand_p arg_p;\n   ssa_op_iter i;\n@@ -3370,10 +3372,11 @@ is_phi_for_stmt (gimple stmt, tree operand)\n   lhs = gimple_assign_lhs (stmt);\n \n   def_stmt = SSA_NAME_DEF_STMT (operand);\n-  if (gimple_code (def_stmt) != GIMPLE_PHI)\n+  def_phi = dyn_cast <gphi *> (def_stmt);\n+  if (!def_phi)\n     return false;\n \n-  FOR_EACH_PHI_ARG (arg_p, def_stmt, i, SSA_OP_USE)\n+  FOR_EACH_PHI_ARG (arg_p, def_phi, i, SSA_OP_USE)\n     if (lhs == USE_FROM_PTR (arg_p))\n       return true;\n   return false;\n@@ -3686,7 +3689,7 @@ get_reassociation_width (int ops_num, enum tree_code opc,\n    parallel.  */\n \n static void\n-rewrite_expr_tree_parallel (gimple stmt, int width,\n+rewrite_expr_tree_parallel (gassign *stmt, int width,\n \t\t\t    vec<operand_entry_t> ops)\n {\n   enum tree_code opcode = gimple_assign_rhs_code (stmt);\n@@ -4828,7 +4831,8 @@ reassociate_bb (basic_block bb)\n \n \t\t  if (width > 1\n \t\t      && ops.length () > 3)\n-\t\t    rewrite_expr_tree_parallel (stmt, width, ops);\n+\t\t    rewrite_expr_tree_parallel (as_a <gassign *> (stmt),\n+\t\t\t\t\t\twidth, ops);\n \t\t  else\n                     {\n                       /* When there are three operands left, we want\n@@ -4935,7 +4939,7 @@ branch_fixup (void)\n       else\n \tgcc_unreachable ();\n       tree lhs = gimple_assign_lhs (use_stmt);\n-      gimple phi = create_phi_node (lhs, merge_bb);\n+      gphi *phi = create_phi_node (lhs, merge_bb);\n       add_phi_arg (phi, build_one_cst (TREE_TYPE (lhs)), etrue, loc);\n       add_phi_arg (phi, othervar, single_succ_edge (then_bb), loc);\n       gsi = gsi_for_stmt (use_stmt);"}, {"sha": "aa155a8e1461572fe6138b2d0345a037902ea75b", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -1130,7 +1130,7 @@ ao_ref_init_from_vn_reference (ao_ref *ref,\n    vn_reference_op_s's.  */\n \n static void\n-copy_reference_ops_from_call (gimple call,\n+copy_reference_ops_from_call (gcall *call,\n \t\t\t      vec<vn_reference_op_s> *result)\n {\n   vn_reference_op_s temp;\n@@ -1456,7 +1456,7 @@ valueize_shared_reference_ops_from_ref (tree ref, bool *valueized_anything)\n    this function.  */\n \n static vec<vn_reference_op_s> \n-valueize_shared_reference_ops_from_call (gimple call)\n+valueize_shared_reference_ops_from_call (gcall *call)\n {\n   if (!call)\n     return vNULL;\n@@ -1630,7 +1630,8 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \t}\n       if (valueized_anything)\n \t{\n-\t  bool res = call_may_clobber_ref_p_1 (def_stmt, ref);\n+\t  bool res = call_may_clobber_ref_p_1 (as_a <gcall *> (def_stmt),\n+\t\t\t\t\t       ref);\n \t  for (unsigned i = 0; i < gimple_call_num_args (def_stmt); ++i)\n \t    gimple_call_set_arg (def_stmt, i, oldargs[i]);\n \t  if (!res)\n@@ -2156,7 +2157,7 @@ vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,\n    *VNRESULT if found.  Populates *VR for the hashtable lookup.  */\n \n void\n-vn_reference_lookup_call (gimple call, vn_reference_t *vnresult,\n+vn_reference_lookup_call (gcall *call, vn_reference_t *vnresult,\n \t\t\t  vn_reference_t vr)\n {\n   if (vnresult)\n@@ -2859,7 +2860,7 @@ visit_nary_op (tree lhs, gimple stmt)\n    of the LHS has changed as a result.  */\n \n static bool\n-visit_reference_op_call (tree lhs, gimple stmt)\n+visit_reference_op_call (tree lhs, gcall *stmt)\n {\n   bool changed = false;\n   struct vn_reference_s vr1;\n@@ -3311,7 +3312,7 @@ simplify_binary_expression (gimple stmt)\n    simplified. */\n \n static tree\n-simplify_unary_expression (gimple stmt)\n+simplify_unary_expression (gassign *stmt)\n {\n   tree result = NULL_TREE;\n   tree orig_op0, op0 = gimple_assign_rhs1 (stmt);\n@@ -3375,7 +3376,7 @@ simplify_unary_expression (gimple stmt)\n /* Try to simplify RHS using equivalences and constant folding.  */\n \n static tree\n-try_to_simplify (gimple stmt)\n+try_to_simplify (gassign *stmt)\n {\n   enum tree_code code = gimple_assign_rhs_code (stmt);\n   tree tem;\n@@ -3463,7 +3464,7 @@ visit_use (tree use)\n \t      changed = visit_copy (lhs, rhs1);\n \t      goto done;\n \t    }\n-\t  simplified = try_to_simplify (stmt);\n+\t  simplified = try_to_simplify (as_a <gassign *> (stmt));\n \t  if (simplified)\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3593,7 +3594,7 @@ visit_use (tree use)\n \t  else\n \t    changed = defs_to_varying (stmt);\n \t}\n-      else if (is_gimple_call (stmt))\n+      else if (gcall *call_stmt = dyn_cast <gcall *> (stmt))\n \t{\n \t  tree lhs = gimple_call_lhs (stmt);\n \t  if (lhs && TREE_CODE (lhs) == SSA_NAME)\n@@ -3679,11 +3680,11 @@ visit_use (tree use)\n \t\t         not alias with anything else.  In which case the\n \t\t\t information that the values are distinct are encoded\n \t\t\t in the IL.  */\n-\t\t      && !(gimple_call_return_flags (stmt) & ERF_NOALIAS)\n+\t\t      && !(gimple_call_return_flags (call_stmt) & ERF_NOALIAS)\n \t\t      /* Only perform the following when being called from PRE\n \t\t\t which embeds tail merging.  */\n \t\t      && default_vn_walk_kind == VN_WALK)))\n-\t    changed = visit_reference_op_call (lhs, stmt);\n+\t    changed = visit_reference_op_call (lhs, call_stmt);\n \t  else\n \t    changed = defs_to_varying (stmt);\n \t}\n@@ -3946,8 +3947,8 @@ DFS (tree name)\n   if (!gimple_nop_p (defstmt))\n     {\n       /* Push a new iterator.  */\n-      if (gimple_code (defstmt) == GIMPLE_PHI)\n-\tusep = op_iter_init_phiuse (&iter, defstmt, SSA_OP_ALL_USES);\n+      if (gphi *phi = dyn_cast <gphi *> (defstmt))\n+\tusep = op_iter_init_phiuse (&iter, phi, SSA_OP_ALL_USES);\n       else\n \tusep = op_iter_init_use (&iter, defstmt, SSA_OP_ALL_USES);\n     }\n@@ -4269,7 +4270,7 @@ cond_dom_walker::before_dom_children (basic_block bb)\n \tbreak;\n       }\n     case GIMPLE_SWITCH:\n-      val = gimple_switch_index (stmt);\n+      val = gimple_switch_index (as_a <gswitch *> (stmt));\n       break;\n     case GIMPLE_GOTO:\n       val = gimple_goto_dest (stmt);"}, {"sha": "285338b2da34d82d0190aae1204c403520cc33df", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -212,7 +212,7 @@ tree vn_reference_lookup_pieces (tree, alias_set_type, tree,\n \t\t\t\t vec<vn_reference_op_s> ,\n \t\t\t\t vn_reference_t *, vn_lookup_kind);\n tree vn_reference_lookup (tree, tree, vn_lookup_kind, vn_reference_t *);\n-void vn_reference_lookup_call (gimple, vn_reference_t *, vn_reference_t);\n+void vn_reference_lookup_call (gcall *, vn_reference_t *, vn_reference_t);\n vn_reference_t vn_reference_insert_pieces (tree, alias_set_type, tree,\n \t\t\t\t\t   vec<vn_reference_op_s> ,\n \t\t\t\t\t   tree, unsigned int);"}, {"sha": "c6d871209bea4b3ae13cec202eff4ed93b2a3345", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -95,7 +95,7 @@ static struct\n    we return NULL.  */\n \n static basic_block\n-find_bb_for_arg (gimple phi, tree def)\n+find_bb_for_arg (gphi *phi, tree def)\n {\n   size_t i;\n   bool foundone = false;\n@@ -159,11 +159,11 @@ nearest_common_dominator_of_uses (def_operand_p def_p, bool *debug_stmts)\n       gimple usestmt = USE_STMT (use_p);\n       basic_block useblock;\n \n-      if (gimple_code (usestmt) == GIMPLE_PHI)\n+      if (gphi *phi = dyn_cast <gphi *> (usestmt))\n \t{\n \t  int idx = PHI_ARG_INDEX_FROM_USE (use_p);\n \n-\t  useblock = gimple_phi_arg_edge (usestmt, idx)->src;\n+\t  useblock = gimple_phi_arg_edge (phi, idx)->src;\n \t}\n       else if (is_gimple_debug (usestmt))\n \t{\n@@ -456,7 +456,7 @@ statement_sink_location (gimple stmt, basic_block frombb,\n \t}\n     }\n \n-  sinkbb = find_bb_for_arg (use, DEF_FROM_PTR (def_p));\n+  sinkbb = find_bb_for_arg (as_a <gphi *> (use), DEF_FROM_PTR (def_p));\n \n   /* This can happen if there are multiple uses in a PHI.  */\n   if (!sinkbb)"}, {"sha": "c02e6128aa7ced94775c4f71a0a35177d42e1fc9", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -2130,7 +2130,6 @@ class strlen_dom_walker : public dom_walker\n void\n strlen_dom_walker::before_dom_children (basic_block bb)\n {\n-  gimple_stmt_iterator gsi;\n   basic_block dombb = get_immediate_dominator (CDI_DOMINATORS, bb);\n \n   if (dombb == NULL)\n@@ -2140,9 +2139,10 @@ strlen_dom_walker::before_dom_children (basic_block bb)\n       stridx_to_strinfo = ((vec<strinfo, va_heap, vl_embed> *) dombb->aux);\n       if (stridx_to_strinfo)\n \t{\n-\t  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+\t       gsi_next (&gsi))\n \t    {\n-\t      gimple phi = gsi_stmt (gsi);\n+\t      gphi *phi = gsi.phi ();\n \t      if (virtual_operand_p (gimple_phi_result (phi)))\n \t\t{\n \t\t  bitmap visited = BITMAP_ALLOC (NULL);\n@@ -2179,9 +2179,10 @@ strlen_dom_walker::before_dom_children (basic_block bb)\n \n   /* If all PHI arguments have the same string index, the PHI result\n      has it as well.  */\n-  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n       tree result = gimple_phi_result (phi);\n       if (!virtual_operand_p (result) && POINTER_TYPE_P (TREE_TYPE (result)))\n \t{\n@@ -2199,7 +2200,7 @@ strlen_dom_walker::before_dom_children (basic_block bb)\n     }\n \n   /* Attempt to optimize individual statements.  */\n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n+  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n     if (strlen_optimize_stmt (&gsi))\n       gsi_next (&gsi);\n "}, {"sha": "e065f1a1b4c81d421cc9b356eccb7b7bc7f7c2c8", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 45, "deletions": 41, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -409,7 +409,7 @@ static hash_map<gimple, varinfo_t> *call_stmt_vars;\n /* Lookup or create the variable for the call statement CALL.  */\n \n static varinfo_t\n-get_call_vi (gimple call)\n+get_call_vi (gcall *call)\n {\n   varinfo_t vi, vi2;\n \n@@ -440,7 +440,7 @@ get_call_vi (gimple call)\n    the uses.  Returns NULL if there is nothing special about this call.  */\n \n static varinfo_t\n-lookup_call_use_vi (gimple call)\n+lookup_call_use_vi (gcall *call)\n {\n   varinfo_t *slot_p = call_stmt_vars->get (call);\n   if (slot_p)\n@@ -453,7 +453,7 @@ lookup_call_use_vi (gimple call)\n    the clobbers.  Returns NULL if there is nothing special about this call.  */\n \n static varinfo_t\n-lookup_call_clobber_vi (gimple call)\n+lookup_call_clobber_vi (gcall *call)\n {\n   varinfo_t uses = lookup_call_use_vi (call);\n   if (!uses)\n@@ -466,7 +466,7 @@ lookup_call_clobber_vi (gimple call)\n    the uses.  */\n \n static varinfo_t\n-get_call_use_vi (gimple call)\n+get_call_use_vi (gcall *call)\n {\n   return get_call_vi (call);\n }\n@@ -475,7 +475,7 @@ get_call_use_vi (gimple call)\n    the clobbers.  */\n \n static varinfo_t ATTRIBUTE_UNUSED\n-get_call_clobber_vi (gimple call)\n+get_call_clobber_vi (gcall *call)\n {\n   return vi_next (get_call_vi (call));\n }\n@@ -3854,7 +3854,7 @@ get_function_part_constraint (varinfo_t fi, unsigned part)\n    RHS.  */\n \n static void\n-handle_rhs_call (gimple stmt, vec<ce_s> *results)\n+handle_rhs_call (gcall *stmt, vec<ce_s> *results)\n {\n   struct constraint_expr rhsc;\n   unsigned i;\n@@ -3956,7 +3956,7 @@ handle_rhs_call (gimple stmt, vec<ce_s> *results)\n    the LHS point to global and escaped variables.  */\n \n static void\n-handle_lhs_call (gimple stmt, tree lhs, int flags, vec<ce_s> rhsc,\n+handle_lhs_call (gcall *stmt, tree lhs, int flags, vec<ce_s> rhsc,\n \t\t tree fndecl)\n {\n   auto_vec<ce_s> lhsc;\n@@ -4019,7 +4019,7 @@ handle_lhs_call (gimple stmt, tree lhs, int flags, vec<ce_s> rhsc,\n    const function that returns a pointer in the statement STMT.  */\n \n static void\n-handle_const_call (gimple stmt, vec<ce_s> *results)\n+handle_const_call (gcall *stmt, vec<ce_s> *results)\n {\n   struct constraint_expr rhsc;\n   unsigned int k;\n@@ -4060,7 +4060,7 @@ handle_const_call (gimple stmt, vec<ce_s> *results)\n    pure function in statement STMT.  */\n \n static void\n-handle_pure_call (gimple stmt, vec<ce_s> *results)\n+handle_pure_call (gcall *stmt, vec<ce_s> *results)\n {\n   struct constraint_expr rhsc;\n   unsigned i;\n@@ -4107,7 +4107,7 @@ handle_pure_call (gimple stmt, vec<ce_s> *results)\n /* Return the varinfo for the callee of CALL.  */\n \n static varinfo_t\n-get_fi_for_callee (gimple call)\n+get_fi_for_callee (gcall *call)\n {\n   tree decl, fn = gimple_call_fn (call);\n \n@@ -4138,7 +4138,7 @@ get_fi_for_callee (gimple call)\n    was handled, otherwise false.  */\n \n static bool\n-find_func_aliases_for_builtin_call (struct function *fn, gimple t)\n+find_func_aliases_for_builtin_call (struct function *fn, gcall *t)\n {\n   tree fndecl = gimple_call_fndecl (t);\n   auto_vec<ce_s, 2> lhsc;\n@@ -4496,7 +4496,7 @@ find_func_aliases_for_builtin_call (struct function *fn, gimple t)\n /* Create constraints for the call T.  */\n \n static void\n-find_func_aliases_for_call (struct function *fn, gimple t)\n+find_func_aliases_for_call (struct function *fn, gcall *t)\n {\n   tree fndecl = gimple_call_fndecl (t);\n   varinfo_t fi;\n@@ -4659,7 +4659,7 @@ find_func_aliases (struct function *fn, gimple origt)\n      In non-ipa mode, we need to generate constraints for each\n      pointer passed by address.  */\n   else if (is_gimple_call (t))\n-    find_func_aliases_for_call (fn, t);\n+    find_func_aliases_for_call (fn, as_a <gcall *> (t));\n     \n   /* Otherwise, just a regular assignment statement.  Only care about\n      operations with pointer result, others are dealt with as escape\n@@ -4744,12 +4744,13 @@ find_func_aliases (struct function *fn, gimple origt)\n     }\n   /* Handle escapes through return.  */\n   else if (gimple_code (t) == GIMPLE_RETURN\n-\t   && gimple_return_retval (t) != NULL_TREE)\n+\t   && gimple_return_retval (as_a <greturn *> (t)) != NULL_TREE)\n     {\n+      greturn *return_stmt = as_a <greturn *> (t);\n       fi = NULL;\n       if (!in_ipa_mode\n \t  || !(fi = get_vi_for_tree (fn->decl)))\n-\tmake_escape_constraint (gimple_return_retval (t));\n+\tmake_escape_constraint (gimple_return_retval (return_stmt));\n       else if (in_ipa_mode\n \t       && fi != NULL)\n \t{\n@@ -4758,25 +4759,25 @@ find_func_aliases (struct function *fn, gimple origt)\n \t  unsigned i;\n \n \t  lhs = get_function_part_constraint (fi, fi_result);\n-\t  get_constraint_for_rhs (gimple_return_retval (t), &rhsc);\n+\t  get_constraint_for_rhs (gimple_return_retval (return_stmt), &rhsc);\n \t  FOR_EACH_VEC_ELT (rhsc, i, rhsp)\n \t    process_constraint (new_constraint (lhs, *rhsp));\n \t}\n     }\n   /* Handle asms conservatively by adding escape constraints to everything.  */\n-  else if (gimple_code (t) == GIMPLE_ASM)\n+  else if (gasm *asm_stmt = dyn_cast <gasm *> (t))\n     {\n       unsigned i, noutputs;\n       const char **oconstraints;\n       const char *constraint;\n       bool allows_mem, allows_reg, is_inout;\n \n-      noutputs = gimple_asm_noutputs (t);\n+      noutputs = gimple_asm_noutputs (asm_stmt);\n       oconstraints = XALLOCAVEC (const char *, noutputs);\n \n       for (i = 0; i < noutputs; ++i)\n \t{\n-\t  tree link = gimple_asm_output_op (t, i);\n+\t  tree link = gimple_asm_output_op (asm_stmt, i);\n \t  tree op = TREE_VALUE (link);\n \n \t  constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (link)));\n@@ -4803,9 +4804,9 @@ find_func_aliases (struct function *fn, gimple origt)\n \t\tprocess_constraint (new_constraint (*lhsp, rhsc));\n \t    }\n \t}\n-      for (i = 0; i < gimple_asm_ninputs (t); ++i)\n+      for (i = 0; i < gimple_asm_ninputs (asm_stmt); ++i)\n \t{\n-\t  tree link = gimple_asm_input_op (t, i);\n+\t  tree link = gimple_asm_input_op (asm_stmt, i);\n \t  tree op = TREE_VALUE (link);\n \n \t  constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (link)));\n@@ -4897,10 +4898,11 @@ find_func_clobbers (struct function *fn, gimple origt)\n   /* Account for uses in assigments and returns.  */\n   if (gimple_assign_single_p (t)\n       || (gimple_code (t) == GIMPLE_RETURN\n-\t  && gimple_return_retval (t) != NULL_TREE))\n+\t  && gimple_return_retval (as_a <greturn *> (t)) != NULL_TREE))\n     {\n       tree rhs = (gimple_assign_single_p (t)\n-\t\t  ? gimple_assign_rhs1 (t) : gimple_return_retval (t));\n+\t\t  ? gimple_assign_rhs1 (t)\n+\t\t  : gimple_return_retval (as_a <greturn *> (t)));\n       tree tem = rhs;\n       while (handled_component_p (tem))\n \ttem = TREE_OPERAND (tem, 0);\n@@ -4922,7 +4924,7 @@ find_func_clobbers (struct function *fn, gimple origt)\n \t}\n     }\n \n-  if (is_gimple_call (t))\n+  if (gcall *call_stmt = dyn_cast <gcall *> (t))\n     {\n       varinfo_t cfi = NULL;\n       tree decl = gimple_call_fndecl (t);\n@@ -5059,7 +5061,7 @@ find_func_clobbers (struct function *fn, gimple origt)\n \n       /* Build constraints for propagating clobbers/uses along the\n \t callgraph edges.  */\n-      cfi = get_fi_for_callee (t);\n+      cfi = get_fi_for_callee (call_stmt);\n       if (cfi->id == anything_id)\n \t{\n \t  if (gimple_vdef (t))\n@@ -5083,10 +5085,10 @@ find_func_clobbers (struct function *fn, gimple origt)\n \t  make_copy_constraint (first_vi_for_offset (fi, fi_uses), escaped_id);\n \n \t  /* Also honor the call statement use/clobber info.  */\n-\t  if ((vi = lookup_call_clobber_vi (t)) != NULL)\n+\t  if ((vi = lookup_call_clobber_vi (call_stmt)) != NULL)\n \t    make_copy_constraint (first_vi_for_offset (fi, fi_clobbers),\n \t\t\t\t  vi->id);\n-\t  if ((vi = lookup_call_use_vi (t)) != NULL)\n+\t  if ((vi = lookup_call_use_vi (call_stmt)) != NULL)\n \t    make_copy_constraint (first_vi_for_offset (fi, fi_uses),\n \t\t\t\t  vi->id);\n \t  return;\n@@ -6786,17 +6788,17 @@ compute_points_to_sets (void)\n   /* Now walk all statements and build the constraint set.  */\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      gimple_stmt_iterator gsi;\n-\n-      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n \t{\n-\t  gimple phi = gsi_stmt (gsi);\n+\t  gphi *phi = gsi.phi ();\n \n \t  if (! virtual_operand_p (gimple_phi_result (phi)))\n \t    find_func_aliases (cfun, phi);\n \t}\n \n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n \t{\n \t  gimple stmt = gsi_stmt (gsi);\n \n@@ -6837,9 +6839,11 @@ compute_points_to_sets (void)\n \n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gcall *stmt;\n \t  struct pt_solution *pt;\n-\t  if (!is_gimple_call (stmt))\n+\n+\t  stmt = dyn_cast <gcall *> (gsi_stmt (gsi));\n+\t  if (!stmt)\n \t    continue;\n \n \t  pt = gimple_call_use_set (stmt);\n@@ -7174,18 +7178,17 @@ ipa_pta_execute (void)\n       /* Build constriants for the function body.  */\n       FOR_EACH_BB_FN (bb, func)\n \t{\n-\t  gimple_stmt_iterator gsi;\n-\n-\t  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+\t  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n \t       gsi_next (&gsi))\n \t    {\n-\t      gimple phi = gsi_stmt (gsi);\n+\t      gphi *phi = gsi.phi ();\n \n \t      if (! virtual_operand_p (gimple_phi_result (phi)))\n \t\tfind_func_aliases (func, phi);\n \t    }\n \n-\t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+\t       gsi_next (&gsi))\n \t    {\n \t      gimple stmt = gsi_stmt (gsi);\n \n@@ -7247,12 +7250,13 @@ ipa_pta_execute (void)\n \n \t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t    {\n-\t      gimple stmt = gsi_stmt (gsi);\n+\t      gcall *stmt;\n \t      struct pt_solution *pt;\n \t      varinfo_t vi, fi;\n \t      tree decl;\n \n-\t      if (!is_gimple_call (stmt))\n+\t      stmt = dyn_cast <gcall *> (gsi_stmt (gsi));\n+\t      if (!stmt)\n \t\tcontinue;\n \n \t      /* Handle direct calls to functions with body.  */"}, {"sha": "230a4223dbd7bb0886ca6773e5a2d3889d66a9cc", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -469,13 +469,12 @@ same_succ_hash (const_same_succ e)\n   unsigned int first = bitmap_first_set_bit (e->bbs);\n   basic_block bb = BASIC_BLOCK_FOR_FN (cfun, first);\n   int size = 0;\n-  gimple_stmt_iterator gsi;\n   gimple stmt;\n   tree arg;\n   unsigned int s;\n   bitmap_iterator bs;\n \n-  for (gsi = gsi_start_nondebug_bb (bb);\n+  for (gimple_stmt_iterator gsi = gsi_start_nondebug_bb (bb);\n        !gsi_end_p (gsi); gsi_next_nondebug (&gsi))\n     {\n       stmt = gsi_stmt (gsi);\n@@ -518,10 +517,11 @@ same_succ_hash (const_same_succ e)\n   EXECUTE_IF_SET_IN_BITMAP (e->succs, 0, s, bs)\n     {\n       int n = find_edge (bb, BASIC_BLOCK_FOR_FN (cfun, s))->dest_idx;\n-      for (gsi = gsi_start_phis (BASIC_BLOCK_FOR_FN (cfun, s)); !gsi_end_p (gsi);\n+      for (gphi_iterator gsi = gsi_start_phis (BASIC_BLOCK_FOR_FN (cfun, s));\n+\t   !gsi_end_p (gsi);\n \t   gsi_next (&gsi))\n \t{\n-\t  gimple phi = gsi_stmt (gsi);\n+\t  gphi *phi = gsi.phi ();\n \t  tree lhs = gimple_phi_result (phi);\n \t  tree val = gimple_phi_arg_def (phi, n);\n \n@@ -858,9 +858,8 @@ same_succ_flush_bbs (bitmap bbs)\n static void\n release_last_vdef (basic_block bb)\n {\n-  gimple_stmt_iterator i;\n-\n-  for (i = gsi_last_bb (bb); !gsi_end_p (i); gsi_prev_nondebug (&i))\n+  for (gimple_stmt_iterator i = gsi_last_bb (bb); !gsi_end_p (i);\n+       gsi_prev_nondebug (&i))\n     {\n       gimple stmt = gsi_stmt (i);\n       if (gimple_vdef (stmt) == NULL_TREE)\n@@ -870,9 +869,10 @@ release_last_vdef (basic_block bb)\n       return;\n     }\n \n-  for (i = gsi_start_phis (bb); !gsi_end_p (i); gsi_next (&i))\n+  for (gphi_iterator i = gsi_start_phis (bb); !gsi_end_p (i);\n+       gsi_next (&i))\n     {\n-      gimple phi = gsi_stmt (i);\n+      gphi *phi = i.phi ();\n       tree res = gimple_phi_result (phi);\n \n       if (!virtual_operand_p (res))\n@@ -1298,11 +1298,11 @@ static bool\n same_phi_alternatives_1 (basic_block dest, edge e1, edge e2)\n {\n   int n1 = e1->dest_idx, n2 = e2->dest_idx;\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n \n   for (gsi = gsi_start_phis (dest); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n       tree lhs = gimple_phi_result (phi);\n       tree val1 = gimple_phi_arg_def (phi, n1);\n       tree val2 = gimple_phi_arg_def (phi, n2);\n@@ -1479,14 +1479,14 @@ find_clusters (void)\n \n /* Returns the vop phi of BB, if any.  */\n \n-static gimple\n+static gphi *\n vop_phi (basic_block bb)\n {\n-  gimple stmt;\n-  gimple_stmt_iterator gsi;\n+  gphi *stmt;\n+  gphi_iterator gsi;\n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      stmt = gsi_stmt (gsi);\n+      stmt = gsi.phi ();\n       if (! virtual_operand_p (gimple_phi_result (stmt)))\n \tcontinue;\n       return stmt;\n@@ -1503,7 +1503,7 @@ replace_block_by (basic_block bb1, basic_block bb2)\n   edge e1, e2;\n   edge_iterator ei;\n   unsigned int i;\n-  gimple bb2_phi;\n+  gphi *bb2_phi;\n \n   bb2_phi = vop_phi (bb2);\n "}, {"sha": "96b3959e9a82f09b532411e6404bef6b0677726c", "filename": "gcc/tree-ssa-ter.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-ter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-ter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ter.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -438,8 +438,8 @@ ter_is_replaceable_p (gimple stmt)\n       block1 = LOCATION_BLOCK (locus1);\n       locus1 = LOCATION_LOCUS (locus1);\n \n-      if (gimple_code (use_stmt) == GIMPLE_PHI)\n-\tlocus2 = gimple_phi_arg_location (use_stmt, \n+      if (gphi *phi = dyn_cast <gphi *> (use_stmt))\n+\tlocus2 = gimple_phi_arg_location (phi,\n \t\t\t\t\t  PHI_ARG_INDEX_FROM_USE (use_p));\n       else\n \tlocus2 = gimple_location (use_stmt);"}, {"sha": "486940a30949b5ce838f3947afb0dbaf63f19b9e", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -209,14 +209,14 @@ record_temporary_equivalence (tree x, tree y, vec<tree> *stack)\n static bool\n record_temporary_equivalences_from_phis (edge e, vec<tree> *stack)\n {\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n \n   /* Each PHI creates a temporary equivalence, record them.\n      These are context sensitive equivalences and will be removed\n      later.  */\n   for (gsi = gsi_start_phis (e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n       tree src = PHI_ARG_DEF_FROM_EDGE (phi, e);\n       tree dst = gimple_phi_result (phi);\n \n@@ -377,7 +377,8 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n       /* If the statement has volatile operands, then we assume we\n \t can not thread through this block.  This is overly\n \t conservative in some ways.  */\n-      if (gimple_code (stmt) == GIMPLE_ASM && gimple_asm_volatile_p (stmt))\n+      if (gimple_code (stmt) == GIMPLE_ASM\n+\t  && gimple_asm_volatile_p (as_a <gasm *> (stmt)))\n \treturn NULL;\n \n       /* If duplicating this block is going to cause too much code\n@@ -495,7 +496,7 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n \t  /* Try to fold/lookup the new expression.  Inserting the\n \t     expression into the hash table is unlikely to help.  */\n           if (is_gimple_call (stmt))\n-            cached_lhs = fold_call_stmt (stmt, false);\n+            cached_lhs = fold_call_stmt (as_a <gcall *> (stmt), false);\n \t  else\n             cached_lhs = fold_assignment_stmt (stmt);\n \n@@ -553,7 +554,7 @@ dummy_simplify (gimple stmt1 ATTRIBUTE_UNUSED, gimple stmt2 ATTRIBUTE_UNUSED)\n static tree\n simplify_control_stmt_condition (edge e,\n \t\t\t\t gimple stmt,\n-\t\t\t\t gimple dummy_cond,\n+\t\t\t\t gcond *dummy_cond,\n \t\t\t\t tree (*simplify) (gimple, gimple),\n \t\t\t\t bool handle_dominating_asserts)\n {\n@@ -650,7 +651,7 @@ simplify_control_stmt_condition (edge e,\n     }\n \n   if (code == GIMPLE_SWITCH)\n-    cond = gimple_switch_index (stmt);\n+    cond = gimple_switch_index (as_a <gswitch *> (stmt));\n   else if (code == GIMPLE_GOTO)\n     cond = gimple_goto_dest (stmt);\n   else\n@@ -834,7 +835,7 @@ propagate_threaded_block_debug_into (basic_block dest, basic_block src)\n    try and simplify the condition at the end of TAKEN_EDGE->dest.  */\n static bool\n thread_around_empty_blocks (edge taken_edge,\n-\t\t\t    gimple dummy_cond,\n+\t\t\t    gcond *dummy_cond,\n \t\t\t    bool handle_dominating_asserts,\n \t\t\t    tree (*simplify) (gimple, gimple),\n \t\t\t    bitmap visited,\n@@ -982,7 +983,7 @@ thread_around_empty_blocks (edge taken_edge,\n \n static int\n thread_through_normal_block (edge e,\n-\t\t\t     gimple dummy_cond,\n+\t\t\t     gcond *dummy_cond,\n \t\t\t     bool handle_dominating_asserts,\n \t\t\t     vec<tree> *stack,\n \t\t\t     tree (*simplify) (gimple, gimple),\n@@ -1110,7 +1111,7 @@ thread_through_normal_block (edge e,\n    SIMPLIFY is a pass-specific function used to simplify statements.  */\n \n void\n-thread_across_edge (gimple dummy_cond,\n+thread_across_edge (gcond *dummy_cond,\n \t\t    edge e,\n \t\t    bool handle_dominating_asserts,\n \t\t    vec<tree> *stack,"}, {"sha": "01c2b1b7baea724642ff00fcd10568349f9b1930", "filename": "gcc/tree-ssa-threadedge.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-threadedge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-threadedge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -30,7 +30,7 @@ extern void threadedge_initialize_values (void);\n extern void threadedge_finalize_values (void);\n extern bool potentially_threadable_block (basic_block);\n extern void propagate_threaded_block_debug_into (basic_block, basic_block);\n-extern void thread_across_edge (gimple, edge, bool,\n+extern void thread_across_edge (gcond *, edge, bool,\n \t\t\t\tvec<tree> *, tree (*) (gimple, gimple));\n \n #endif /* GCC_TREE_SSA_THREADEDGE_H */"}, {"sha": "97748cb66a397d06e63efb16551c0cf1fd4cf566", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -405,13 +405,13 @@ copy_phi_arg_into_existing_phi (edge src_e, edge tgt_e)\n   int tgt_idx = tgt_e->dest_idx;\n \n   /* Iterate over each PHI in e->dest.  */\n-  for (gimple_stmt_iterator gsi = gsi_start_phis (src_e->dest),\n-\t\t\t    gsi2 = gsi_start_phis (tgt_e->dest);\n+  for (gphi_iterator gsi = gsi_start_phis (src_e->dest),\n+\t\t\t   gsi2 = gsi_start_phis (tgt_e->dest);\n        !gsi_end_p (gsi);\n        gsi_next (&gsi), gsi_next (&gsi2))\n     {\n-      gimple src_phi = gsi_stmt (gsi);\n-      gimple dest_phi = gsi_stmt (gsi2);\n+      gphi *src_phi = gsi.phi ();\n+      gphi *dest_phi = gsi2.phi ();\n       tree val = gimple_phi_arg_def (src_phi, src_idx);\n       source_location locus = gimple_phi_arg_location (src_phi, src_idx);\n \n@@ -430,14 +430,14 @@ get_value_locus_in_path (tree def, vec<jump_thread_edge *> *path,\n \t\t\t basic_block bb, int idx, source_location *locus)\n {\n   tree arg;\n-  gimple def_phi;\n+  gphi *def_phi;\n   basic_block def_bb;\n \n   if (path == NULL || idx == 0)\n     return def;\n \n-  def_phi = SSA_NAME_DEF_STMT (def);\n-  if (gimple_code (def_phi) != GIMPLE_PHI)\n+  def_phi = dyn_cast <gphi *> (SSA_NAME_DEF_STMT (def));\n+  if (!def_phi)\n     return def;\n \n   def_bb = gimple_bb (def_phi);\n@@ -474,12 +474,12 @@ static void\n copy_phi_args (basic_block bb, edge src_e, edge tgt_e,\n \t       vec<jump_thread_edge *> *path, int idx)\n {\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n   int src_indx = src_e->dest_idx;\n \n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n       tree def = gimple_phi_arg_def (phi, src_indx);\n       source_location locus = gimple_phi_arg_location (phi, src_indx);\n \n@@ -2068,13 +2068,13 @@ thread_through_loop_header (struct loop *loop, bool may_peel_loop_headers)\n static bool\n phi_args_equal_on_edges (edge e1, edge e2)\n {\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n   int indx1 = e1->dest_idx;\n   int indx2 = e2->dest_idx;\n \n   for (gsi = gsi_start_phis (e1->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n \n       if (!operand_equal_p (gimple_phi_arg_def (phi, indx1),\n \t\t\t    gimple_phi_arg_def (phi, indx2), 0))"}, {"sha": "ecddef4925011a83f3a6e5cd6afa956c100987ee", "filename": "gcc/tree-ssa-uncprop.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -184,20 +184,21 @@ associate_equivalences_with_edges (void)\n \t target block creates an equivalence.  */\n       else if (gimple_code (stmt) == GIMPLE_SWITCH)\n \t{\n-\t  tree cond = gimple_switch_index (stmt);\n+\t  gswitch *switch_stmt = as_a <gswitch *> (stmt);\n+\t  tree cond = gimple_switch_index (switch_stmt);\n \n \t  if (TREE_CODE (cond) == SSA_NAME\n \t      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (cond))\n \t    {\n-\t      int i, n_labels = gimple_switch_num_labels (stmt);\n+\t      int i, n_labels = gimple_switch_num_labels (switch_stmt);\n \t      tree *info = XCNEWVEC (tree, last_basic_block_for_fn (cfun));\n \n \t      /* Walk over the case label vector.  Record blocks\n \t\t which are reached by a single case label which represents\n \t\t a single value.  */\n \t      for (i = 0; i < n_labels; i++)\n \t\t{\n-\t\t  tree label = gimple_switch_label (stmt, i);\n+\t\t  tree label = gimple_switch_label (switch_stmt, i);\n \t\t  basic_block bb = label_to_block (CASE_LABEL (label));\n \n \t\t  if (CASE_HIGH (label)"}, {"sha": "9fa3acf2ea3c7f0668c076869cd36e7696442dd1", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -301,7 +301,7 @@ can_skip_redundant_opnd (tree opnd, gimple phi)\n    that have empty (or possibly empty) definitions.  */\n \n static unsigned\n-compute_uninit_opnds_pos (gimple phi)\n+compute_uninit_opnds_pos (gphi *phi)\n {\n   size_t i, n;\n   unsigned uninit_opnds = 0;\n@@ -653,7 +653,7 @@ find_predicates (pred_chain_union *preds,\n    VISITED_PHIS is a pointer set for detecting cycles.  */\n \n static void\n-collect_phi_def_edges (gimple phi, basic_block cd_root,\n+collect_phi_def_edges (gphi *phi, basic_block cd_root,\n                        vec<edge> *edges,\n                        hash_set<gimple> *visited_phis)\n {\n@@ -686,7 +686,7 @@ collect_phi_def_edges (gimple phi, basic_block cd_root,\n           if (gimple_code (def) == GIMPLE_PHI\n               && dominated_by_p (CDI_DOMINATORS,\n                                  gimple_bb (def), cd_root))\n-            collect_phi_def_edges (def, cd_root, edges,\n+            collect_phi_def_edges (as_a <gphi *> (def), cd_root, edges,\n                                    visited_phis);\n           else if (!uninit_undefined_value_p (opnd))\n             {\n@@ -706,7 +706,7 @@ collect_phi_def_edges (gimple phi, basic_block cd_root,\n    composite predicates pointed to by PREDS.  */\n \n static bool\n-find_def_preds (pred_chain_union *preds, gimple phi)\n+find_def_preds (pred_chain_union *preds, gphi *phi)\n {\n   size_t num_chains = 0, i, n;\n   vec<edge> dep_chains[MAX_NUM_CHAINS];\n@@ -944,9 +944,9 @@ find_matching_predicate_in_rest_chains (pred_info pred,\n static bool\n is_use_properly_guarded (gimple use_stmt,\n                          basic_block use_bb,\n-                         gimple phi,\n+                         gphi *phi,\n                          unsigned uninit_opnds,\n-                         hash_set<gimple> *visited_phis);\n+                         hash_set<gphi *> *visited_phis);\n \n /* Returns true if all uninitialized opnds are pruned. Returns false\n    otherwise. PHI is the phi node with uninitialized operands,\n@@ -983,12 +983,12 @@ is_use_properly_guarded (gimple use_stmt,\n */\n \n static bool\n-prune_uninit_phi_opnds_in_unrealizable_paths (gimple phi,\n+prune_uninit_phi_opnds_in_unrealizable_paths (gphi *phi,\n \t\t\t\t\t      unsigned uninit_opnds,\n-\t\t\t\t\t      gimple flag_def,\n+\t\t\t\t\t      gphi *flag_def,\n \t\t\t\t\t      tree boundary_cst,\n \t\t\t\t\t      enum tree_code cmp_code,\n-\t\t\t\t\t      hash_set<gimple> *visited_phis,\n+\t\t\t\t\t      hash_set<gphi *> *visited_phis,\n \t\t\t\t\t      bitmap *visited_flag_phis)\n {\n   unsigned i;\n@@ -1003,22 +1003,22 @@ prune_uninit_phi_opnds_in_unrealizable_paths (gimple phi,\n       flag_arg = gimple_phi_arg_def (flag_def, i);\n       if (!is_gimple_constant (flag_arg))\n         {\n-          gimple flag_arg_def, phi_arg_def;\n+          gphi *flag_arg_def, *phi_arg_def;\n           tree phi_arg;\n           unsigned uninit_opnds_arg_phi;\n \n           if (TREE_CODE (flag_arg) != SSA_NAME)\n             return false;\n-          flag_arg_def = SSA_NAME_DEF_STMT (flag_arg);\n-          if (gimple_code (flag_arg_def) != GIMPLE_PHI)\n+          flag_arg_def = dyn_cast <gphi *> (SSA_NAME_DEF_STMT (flag_arg));\n+\t  if (!flag_arg_def)\n             return false;\n \n           phi_arg = gimple_phi_arg_def (phi, i);\n           if (TREE_CODE (phi_arg) != SSA_NAME)\n             return false;\n \n-          phi_arg_def = SSA_NAME_DEF_STMT (phi_arg);\n-          if (gimple_code (phi_arg_def) != GIMPLE_PHI)\n+          phi_arg_def = dyn_cast <gphi *> (SSA_NAME_DEF_STMT (phi_arg));\n+\t  if (!phi_arg_def)\n             return false;\n \n           if (gimple_bb (phi_arg_def) != gimple_bb (flag_arg_def))\n@@ -1059,16 +1059,16 @@ prune_uninit_phi_opnds_in_unrealizable_paths (gimple phi,\n \n           opnd = gimple_phi_arg_def (phi, i);\n           opnd_def = SSA_NAME_DEF_STMT (opnd);\n-          if (gimple_code (opnd_def) == GIMPLE_PHI)\n+          if (gphi *opnd_def_phi = dyn_cast <gphi *> (opnd_def))\n             {\n               edge opnd_edge;\n               unsigned uninit_opnds2\n-                  = compute_uninit_opnds_pos (opnd_def);\n+                  = compute_uninit_opnds_pos (opnd_def_phi);\n               gcc_assert (!MASK_EMPTY (uninit_opnds2));\n               opnd_edge = gimple_phi_arg_edge (phi, i);\n               if (!is_use_properly_guarded (phi,\n                                             opnd_edge->src,\n-                                            opnd_def,\n+                                            opnd_def_phi,\n                                             uninit_opnds2,\n                                             visited_phis))\n                   return false;\n@@ -1157,8 +1157,8 @@ prune_uninit_phi_opnds_in_unrealizable_paths (gimple phi,\n \n static bool\n use_pred_not_overlap_with_undef_path_pred (pred_chain_union preds,\n-\t\t\t\t           gimple phi, unsigned uninit_opnds,\n-\t\t\t\t\t   hash_set<gimple> *visited_phis)\n+\t\t\t\t           gphi *phi, unsigned uninit_opnds,\n+\t\t\t\t\t   hash_set<gphi *> *visited_phis)\n {\n   unsigned int i, n;\n   gimple flag_def = 0;\n@@ -1231,7 +1231,7 @@ use_pred_not_overlap_with_undef_path_pred (pred_chain_union preds,\n \n   all_pruned = prune_uninit_phi_opnds_in_unrealizable_paths (phi,\n                                                              uninit_opnds,\n-                                                             flag_def,\n+                                                             as_a <gphi *> (flag_def),\n                                                              boundary_cst,\n                                                              cmp_code,\n                                                              visited_phis,\n@@ -2112,9 +2112,9 @@ normalize_preds (pred_chain_union preds, gimple use_or_def, bool is_use)\n static bool\n is_use_properly_guarded (gimple use_stmt,\n                          basic_block use_bb,\n-                         gimple phi,\n+                         gphi *phi,\n                          unsigned uninit_opnds,\n-                         hash_set<gimple> *visited_phis)\n+                         hash_set<gphi *> *visited_phis)\n {\n   basic_block phi_bb;\n   pred_chain_union preds = vNULL;\n@@ -2181,9 +2181,9 @@ is_use_properly_guarded (gimple use_stmt,\n    if the new phi is already in the worklist.  */\n \n static gimple\n-find_uninit_use (gimple phi, unsigned uninit_opnds,\n-                 vec<gimple> *worklist,\n-\t\t hash_set<gimple> *added_to_worklist)\n+find_uninit_use (gphi *phi, unsigned uninit_opnds,\n+                 vec<gphi *> *worklist,\n+\t\t hash_set<gphi *> *added_to_worklist)\n {\n   tree phi_result;\n   use_operand_p use_p;\n@@ -2200,13 +2200,13 @@ find_uninit_use (gimple phi, unsigned uninit_opnds,\n       if (is_gimple_debug (use_stmt))\n \tcontinue;\n \n-      if (gimple_code (use_stmt) == GIMPLE_PHI)\n-\tuse_bb = gimple_phi_arg_edge (use_stmt,\n+      if (gphi *use_phi = dyn_cast <gphi *> (use_stmt))\n+\tuse_bb = gimple_phi_arg_edge (use_phi,\n \t\t\t\t      PHI_ARG_INDEX_FROM_USE (use_p))->src;\n       else\n \tuse_bb = gimple_bb (use_stmt);\n \n-      hash_set<gimple> visited_phis;\n+      hash_set<gphi *> visited_phis;\n       if (is_use_properly_guarded (use_stmt, use_bb, phi, uninit_opnds,\n                                    &visited_phis))\n \tcontinue;\n@@ -2222,15 +2222,15 @@ find_uninit_use (gimple phi, unsigned uninit_opnds,\n \n       /* Found a phi use that is not guarded,\n          add the phi to the worklist.  */\n-      if (!added_to_worklist->add (use_stmt))\n+      if (!added_to_worklist->add (as_a <gphi *> (use_stmt)))\n         {\n           if (dump_file && (dump_flags & TDF_DETAILS))\n             {\n               fprintf (dump_file, \"[WORKLIST]: Update worklist with phi: \");\n               print_gimple_stmt (dump_file, use_stmt, 0, 0);\n             }\n \n-          worklist->safe_push (use_stmt);\n+          worklist->safe_push (as_a <gphi *> (use_stmt));\n           possibly_undefined_names->add (phi_result);\n         }\n     }\n@@ -2247,8 +2247,8 @@ find_uninit_use (gimple phi, unsigned uninit_opnds,\n    a pointer set tracking if the new phi is added to the worklist or not.  */\n \n static void\n-warn_uninitialized_phi (gimple phi, vec<gimple> *worklist,\n-                        hash_set<gimple> *added_to_worklist)\n+warn_uninitialized_phi (gphi *phi, vec<gphi *> *worklist,\n+                        hash_set<gphi *> *added_to_worklist)\n {\n   unsigned uninit_opnds;\n   gimple uninit_use_stmt = 0;\n@@ -2333,8 +2333,8 @@ unsigned int\n pass_late_warn_uninitialized::execute (function *fun)\n {\n   basic_block bb;\n-  gimple_stmt_iterator gsi;\n-  vec<gimple> worklist = vNULL;\n+  gphi_iterator gsi;\n+  vec<gphi *> worklist = vNULL;\n \n   calculate_dominance_info (CDI_DOMINATORS);\n   calculate_dominance_info (CDI_POST_DOMINATORS);\n@@ -2346,13 +2346,13 @@ pass_late_warn_uninitialized::execute (function *fun)\n   timevar_push (TV_TREE_UNINIT);\n \n   possibly_undefined_names = new hash_set<tree>;\n-  hash_set<gimple> added_to_worklist;\n+  hash_set<gphi *> added_to_worklist;\n \n   /* Initialize worklist  */\n   FOR_EACH_BB_FN (bb, fun)\n     for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n-\tgimple phi = gsi_stmt (gsi);\n+\tgphi *phi = gsi.phi ();\n \tsize_t n, i;\n \n \tn = gimple_phi_num_args (phi);\n@@ -2381,7 +2381,7 @@ pass_late_warn_uninitialized::execute (function *fun)\n \n   while (worklist.length () != 0)\n     {\n-      gimple cur_phi = 0;\n+      gphi *cur_phi = 0;\n       cur_phi = worklist.pop ();\n       warn_uninitialized_phi (cur_phi, &worklist, &added_to_worklist);\n     }"}, {"sha": "835e3c12458ee335e1b19e3a581242f504624994", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -157,8 +157,8 @@ redirect_edge_var_map_destroy (void)\n edge\n ssa_redirect_edge (edge e, basic_block dest)\n {\n-  gimple_stmt_iterator gsi;\n-  gimple phi;\n+  gphi_iterator gsi;\n+  gphi *phi;\n \n   redirect_edge_var_map_clear (e);\n \n@@ -168,7 +168,7 @@ ssa_redirect_edge (edge e, basic_block dest)\n       tree def;\n       source_location locus ;\n \n-      phi = gsi_stmt (gsi);\n+      phi = gsi.phi ();\n       def = gimple_phi_arg_def (phi, e->dest_idx);\n       locus = gimple_phi_arg_location (phi, e->dest_idx);\n \n@@ -190,10 +190,10 @@ ssa_redirect_edge (edge e, basic_block dest)\n void\n flush_pending_stmts (edge e)\n {\n-  gimple phi;\n+  gphi *phi;\n   edge_var_map *vm;\n   int i;\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n \n   vec<edge_var_map> *v = redirect_edge_var_map_vector (e);\n   if (!v)\n@@ -205,7 +205,7 @@ flush_pending_stmts (edge e)\n     {\n       tree def;\n \n-      phi = gsi_stmt (gsi);\n+      phi = gsi.phi ();\n       def = redirect_edge_var_map_def (vm);\n       add_phi_arg (phi, def, e, redirect_edge_var_map_location (vm));\n     }\n@@ -366,7 +366,7 @@ insert_debug_temp_for_var_def (gimple_stmt_iterator *gsi, tree var)\n      we'll have to drop debug information.  */\n   if (gimple_code (def_stmt) == GIMPLE_PHI)\n     {\n-      value = degenerate_phi_result (def_stmt);\n+      value = degenerate_phi_result (as_a <gphi *> (def_stmt));\n       if (value && walk_tree (&value, find_released_ssa_name, NULL, NULL))\n \tvalue = NULL;\n       /* error_mark_node is what fixup_noreturn_call changes PHI arguments\n@@ -444,7 +444,7 @@ insert_debug_temp_for_var_def (gimple_stmt_iterator *gsi, tree var)\n \t;\n       else\n \t{\n-\t  gimple def_temp;\n+\t  gdebug *def_temp;\n \t  tree vexpr = make_node (DEBUG_EXPR_DECL);\n \n \t  def_temp = gimple_build_debug_bind (vexpr,\n@@ -838,7 +838,7 @@ verify_use (basic_block bb, basic_block def_bb, use_operand_p use_p,\n       definition of SSA_NAME.  */\n \n static bool\n-verify_phi_args (gimple phi, basic_block bb, basic_block *definition_block)\n+verify_phi_args (gphi *phi, basic_block bb, basic_block *definition_block)\n {\n   edge e;\n   bool err = false;\n@@ -969,9 +969,7 @@ verify_ssa (bool check_modified_stmt, bool check_ssa_operands)\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       edge e;\n-      gimple phi;\n       edge_iterator ei;\n-      gimple_stmt_iterator gsi;\n \n       /* Make sure that all edges have a clear 'aux' field.  */\n       FOR_EACH_EDGE (e, ei, bb->preds)\n@@ -985,9 +983,9 @@ verify_ssa (bool check_modified_stmt, bool check_ssa_operands)\n \t}\n \n       /* Verify the arguments for every PHI node in the block.  */\n-      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  phi = gsi_stmt (gsi);\n+\t  gphi *phi = gsi.phi ();\n \t  if (verify_phi_args (phi, bb, definition_block))\n \t    goto err;\n \n@@ -996,7 +994,8 @@ verify_ssa (bool check_modified_stmt, bool check_ssa_operands)\n \t}\n \n       /* Now verify all the uses and vuses in every statement of the block.  */\n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n \t{\n \t  gimple stmt = gsi_stmt (gsi);\n \t  use_operand_p use_p;\n@@ -1406,7 +1405,6 @@ maybe_optimize_var (tree var, bitmap addresses_taken, bitmap not_reg_needs,\n void\n execute_update_addresses_taken (void)\n {\n-  gimple_stmt_iterator gsi;\n   basic_block bb;\n   bitmap addresses_taken = BITMAP_ALLOC (NULL);\n   bitmap not_reg_needs = BITMAP_ALLOC (NULL);\n@@ -1420,7 +1418,8 @@ execute_update_addresses_taken (void)\n      the function body.  */\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n \t{\n \t  gimple stmt = gsi_stmt (gsi);\n \t  enum gimple_code code = gimple_code (stmt);\n@@ -1463,9 +1462,10 @@ execute_update_addresses_taken (void)\n \n \t  else if (code == GIMPLE_ASM)\n \t    {\n-\t      for (i = 0; i < gimple_asm_noutputs (stmt); ++i)\n+\t      gasm *asm_stmt = as_a <gasm *> (stmt);\n+\t      for (i = 0; i < gimple_asm_noutputs (asm_stmt); ++i)\n \t\t{\n-\t\t  tree link = gimple_asm_output_op (stmt, i);\n+\t\t  tree link = gimple_asm_output_op (asm_stmt, i);\n \t\t  tree lhs = TREE_VALUE (link);\n \t\t  if (TREE_CODE (lhs) != SSA_NAME)\n \t\t    {\n@@ -1480,19 +1480,20 @@ execute_update_addresses_taken (void)\n \t\t\tbitmap_set_bit (not_reg_needs, DECL_UID (decl));\n \t\t    }\n \t\t}\n-\t      for (i = 0; i < gimple_asm_ninputs (stmt); ++i)\n+\t      for (i = 0; i < gimple_asm_ninputs (asm_stmt); ++i)\n \t\t{\n-\t\t  tree link = gimple_asm_input_op (stmt, i);\n+\t\t  tree link = gimple_asm_input_op (asm_stmt, i);\n \t\t  if ((decl = non_rewritable_mem_ref_base (TREE_VALUE (link))))\n \t\t    bitmap_set_bit (not_reg_needs, DECL_UID (decl));\n \t\t}\n \t    }\n \t}\n \n-      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n \t{\n \t  size_t i;\n-\t  gimple phi = gsi_stmt (gsi);\n+\t  gphi *phi = gsi.phi ();\n \n \t  for (i = 0; i < gimple_phi_num_args (phi); i++)\n \t    {\n@@ -1521,7 +1522,7 @@ execute_update_addresses_taken (void)\n   if (!bitmap_empty_p (suitable_for_renaming))\n     {\n       FOR_EACH_BB_FN (bb, cfun)\n-\tfor (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n+\tfor (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n \t  {\n \t    gimple stmt = gsi_stmt (gsi);\n \n@@ -1581,16 +1582,17 @@ execute_update_addresses_taken (void)\n \n \t    else if (gimple_code (stmt) == GIMPLE_ASM)\n \t      {\n+\t\tgasm *asm_stmt = as_a <gasm *> (stmt);\n \t\tunsigned i;\n-\t\tfor (i = 0; i < gimple_asm_noutputs (stmt); ++i)\n+\t\tfor (i = 0; i < gimple_asm_noutputs (asm_stmt); ++i)\n \t\t  {\n-\t\t    tree link = gimple_asm_output_op (stmt, i);\n+\t\t    tree link = gimple_asm_output_op (asm_stmt, i);\n \t\t    maybe_rewrite_mem_ref_base (&TREE_VALUE (link),\n \t\t\t\t\t\tsuitable_for_renaming);\n \t\t  }\n-\t\tfor (i = 0; i < gimple_asm_ninputs (stmt); ++i)\n+\t\tfor (i = 0; i < gimple_asm_ninputs (asm_stmt); ++i)\n \t\t  {\n-\t\t    tree link = gimple_asm_input_op (stmt, i);\n+\t\t    tree link = gimple_asm_input_op (asm_stmt, i);\n \t\t    maybe_rewrite_mem_ref_base (&TREE_VALUE (link),\n \t\t\t\t\t\tsuitable_for_renaming);\n \t\t  }"}, {"sha": "7bf3335c48ad4755b4c74ad956cd0aa4c0c4147f", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -547,14 +547,13 @@ check_all_va_list_escapes (struct stdarg_info *si)\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      gimple_stmt_iterator i;\n-\n-      for (i = gsi_start_phis (bb); !gsi_end_p (i); gsi_next (&i))\n+      for (gphi_iterator i = gsi_start_phis (bb); !gsi_end_p (i);\n+\t   gsi_next (&i))\n \t{\n \t  tree lhs;\n \t  use_operand_p uop;\n \t  ssa_op_iter soi;\n-\t  gimple phi = gsi_stmt (i);\n+\t  gphi *phi = i.phi ();\n \n \t  lhs = PHI_RESULT (phi);\n \t  if (virtual_operand_p (lhs)\n@@ -580,7 +579,8 @@ check_all_va_list_escapes (struct stdarg_info *si)\n \t    }\n \t}\n \n-      for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n+      for (gimple_stmt_iterator i = gsi_start_bb (bb); !gsi_end_p (i);\n+\t   gsi_next (&i))\n \t{\n \t  gimple stmt = gsi_stmt (i);\n \t  tree use;\n@@ -844,8 +844,6 @@ pass_stdarg::execute (function *fun)\n \n   FOR_EACH_BB_FN (bb, fun)\n     {\n-      gimple_stmt_iterator i;\n-\n       si.compute_sizes = -1;\n       si.bb = bb;\n \n@@ -859,9 +857,10 @@ pass_stdarg::execute (function *fun)\n \t  use_operand_p uop;\n \t  ssa_op_iter soi;\n \n-\t  for (i = gsi_start_phis (bb); !gsi_end_p (i); gsi_next (&i))\n+\t  for (gphi_iterator i = gsi_start_phis (bb); !gsi_end_p (i);\n+\t       gsi_next (&i))\n \t    {\n-\t      gimple phi = gsi_stmt (i);\n+\t      gphi *phi = i.phi ();\n \t      lhs = PHI_RESULT (phi);\n \n \t      if (virtual_operand_p (lhs))\n@@ -891,7 +890,7 @@ pass_stdarg::execute (function *fun)\n \t    }\n \t}\n \n-      for (i = gsi_start_bb (bb);\n+      for (gimple_stmt_iterator i = gsi_start_bb (bb);\n \t   !gsi_end_p (i) && !va_list_escapes;\n \t   gsi_next (&i))\n \t{"}, {"sha": "9728273beb4016547ad57e24095ca509bbc0a0f6", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -100,7 +100,7 @@ hoist_edge_and_branch_if_true (gimple_stmt_iterator *gsip,\n \t\t\t       bool update_dominators)\n {\n   tree tmp;\n-  gimple cond_stmt;\n+  gcond *cond_stmt;\n   edge e_false;\n   basic_block new_bb, split_bb = gsi_bb (*gsip);\n   bool dominated_e_true = false;\n@@ -285,7 +285,7 @@ case_bit_test_cmp (const void *p1, const void *p2)\n     node targets.  */\n \n static void\n-emit_case_bit_tests (gimple swtch, tree index_expr,\n+emit_case_bit_tests (gswitch *swtch, tree index_expr,\n \t\t     tree minval, tree range, tree maxval)\n {\n   struct case_bit_test test[MAX_CASE_BIT_TESTS];\n@@ -304,7 +304,7 @@ emit_case_bit_tests (gimple swtch, tree index_expr,\n   unsigned int branch_num = gimple_switch_num_labels (swtch);\n \n   gimple_stmt_iterator gsi;\n-  gimple shift_stmt;\n+  gassign *shift_stmt;\n \n   tree idx, tmp, csui;\n   tree word_type_node = lang_hooks.types.type_for_mode (word_mode, 1);\n@@ -621,7 +621,7 @@ struct switch_conv_info\n /* Collect information about GIMPLE_SWITCH statement SWTCH into INFO.  */\n \n static void\n-collect_switch_conv_info (gimple swtch, struct switch_conv_info *info)\n+collect_switch_conv_info (gswitch *swtch, struct switch_conv_info *info)\n {\n   unsigned int branch_num = gimple_switch_num_labels (swtch);\n   tree min_case, max_case;\n@@ -759,12 +759,12 @@ check_all_empty_except_final (struct switch_conv_info *info)\n static bool\n check_final_bb (struct switch_conv_info *info)\n {\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n \n   info->phi_count = 0;\n   for (gsi = gsi_start_phis (info->final_bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n       unsigned int i;\n \n       info->phi_count++;\n@@ -840,7 +840,7 @@ free_temp_arrays (struct switch_conv_info *info)\n static void\n gather_default_values (tree default_case, struct switch_conv_info *info)\n {\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n   basic_block bb = label_to_block (CASE_LABEL (default_case));\n   edge e;\n   int i = 0;\n@@ -854,7 +854,7 @@ gather_default_values (tree default_case, struct switch_conv_info *info)\n \n   for (gsi = gsi_start_phis (info->final_bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n       tree val = PHI_ARG_DEF_FROM_EDGE (phi, e);\n       gcc_assert (val);\n       info->default_values[i++] = val;\n@@ -866,7 +866,7 @@ gather_default_values (tree default_case, struct switch_conv_info *info)\n    order of phi nodes.  SWTCH is the switch statement being converted.  */\n \n static void\n-build_constructors (gimple swtch, struct switch_conv_info *info)\n+build_constructors (gswitch *swtch, struct switch_conv_info *info)\n {\n   unsigned i, branch_num = gimple_switch_num_labels (swtch);\n   tree pos = info->range_min;\n@@ -877,7 +877,7 @@ build_constructors (gimple swtch, struct switch_conv_info *info)\n       basic_block bb = label_to_block (CASE_LABEL (cs));\n       edge e;\n       tree high;\n-      gimple_stmt_iterator gsi;\n+      gphi_iterator gsi;\n       int j;\n \n       if (bb == info->final_bb)\n@@ -912,7 +912,7 @@ build_constructors (gimple swtch, struct switch_conv_info *info)\n       for (gsi = gsi_start_phis (info->final_bb);\n \t   !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple phi = gsi_stmt (gsi);\n+\t  gphi *phi = gsi.phi ();\n \t  tree val = PHI_ARG_DEF_FROM_EDGE (phi, e);\n \t  tree low = CASE_LOW (cs);\n \t  pos = CASE_LOW (cs);\n@@ -960,7 +960,7 @@ constructor_contains_same_values_p (vec<constructor_elt, va_gc> *vec)\n    all the constants.  */\n \n static tree\n-array_value_type (gimple swtch, tree type, int num,\n+array_value_type (gswitch *swtch, tree type, int num,\n \t\t  struct switch_conv_info *info)\n {\n   unsigned int i, len = vec_safe_length (info->constructors[num]);\n@@ -1037,8 +1037,8 @@ array_value_type (gimple swtch, tree type, int num,\n    new array.  */\n \n static void\n-build_one_array (gimple swtch, int num, tree arr_index_type, gimple phi,\n-\t\t tree tidx, struct switch_conv_info *info)\n+build_one_array (gswitch *swtch, int num, tree arr_index_type,\n+\t\t gphi *phi, tree tidx, struct switch_conv_info *info)\n {\n   tree name, cst;\n   gimple load;\n@@ -1103,12 +1103,13 @@ build_one_array (gimple swtch, int num, tree arr_index_type, gimple phi,\n    them.  */\n \n static void\n-build_arrays (gimple swtch, struct switch_conv_info *info)\n+build_arrays (gswitch *swtch, struct switch_conv_info *info)\n {\n   tree arr_index_type;\n   tree tidx, sub, utype;\n   gimple stmt;\n   gimple_stmt_iterator gsi;\n+  gphi_iterator gpi;\n   int i;\n   location_t loc = gimple_location (swtch);\n \n@@ -1134,19 +1135,19 @@ build_arrays (gimple swtch, struct switch_conv_info *info)\n   update_stmt (stmt);\n   info->arr_ref_first = stmt;\n \n-  for (gsi = gsi_start_phis (info->final_bb), i = 0;\n-       !gsi_end_p (gsi); gsi_next (&gsi), i++)\n-    build_one_array (swtch, i, arr_index_type, gsi_stmt (gsi), tidx, info);\n+  for (gpi = gsi_start_phis (info->final_bb), i = 0;\n+       !gsi_end_p (gpi); gsi_next (&gpi), i++)\n+    build_one_array (swtch, i, arr_index_type, gpi.phi (), tidx, info);\n }\n \n /* Generates and appropriately inserts loads of default values at the position\n    given by BSI.  Returns the last inserted statement.  */\n \n-static gimple\n+static gassign *\n gen_def_assigns (gimple_stmt_iterator *gsi, struct switch_conv_info *info)\n {\n   int i;\n-  gimple assign = NULL;\n+  gassign *assign = NULL;\n \n   for (i = 0; i < info->phi_count; i++)\n     {\n@@ -1190,13 +1191,13 @@ static void\n fix_phi_nodes (edge e1f, edge e2f, basic_block bbf,\n \t       struct switch_conv_info *info)\n {\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n   int i;\n \n   for (gsi = gsi_start_phis (bbf), i = 0;\n        !gsi_end_p (gsi); gsi_next (&gsi), i++)\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n       add_phi_arg (phi, info->target_inbound_names[i], e1f, UNKNOWN_LOCATION);\n       add_phi_arg (phi, info->target_outbound_names[i], e2f, UNKNOWN_LOCATION);\n     }\n@@ -1224,18 +1225,18 @@ fix_phi_nodes (edge e1f, edge e2f, basic_block bbf,\n */\n \n static void\n-gen_inbound_check (gimple swtch, struct switch_conv_info *info)\n+gen_inbound_check (gswitch *swtch, struct switch_conv_info *info)\n {\n   tree label_decl1 = create_artificial_label (UNKNOWN_LOCATION);\n   tree label_decl2 = create_artificial_label (UNKNOWN_LOCATION);\n   tree label_decl3 = create_artificial_label (UNKNOWN_LOCATION);\n-  gimple label1, label2, label3;\n+  glabel *label1, *label2, *label3;\n   tree utype, tidx;\n   tree bound;\n \n-  gimple cond_stmt;\n+  gcond *cond_stmt;\n \n-  gimple last_assign;\n+  gassign *last_assign;\n   gimple_stmt_iterator gsi;\n   basic_block bb0, bb1, bb2, bbf, bbd;\n   edge e01, e02, e21, e1d, e1f, e2f;\n@@ -1344,7 +1345,7 @@ gen_inbound_check (gimple swtch, struct switch_conv_info *info)\n    conversion failed.  */\n \n static const char *\n-process_switch (gimple swtch)\n+process_switch (gswitch *swtch)\n {\n   struct switch_conv_info info;\n \n@@ -1478,7 +1479,7 @@ pass_convert_switch::execute (function *fun)\n \t    putc ('\\n', dump_file);\n \t  }\n \n-\tfailure_reason = process_switch (stmt);\n+\tfailure_reason = process_switch (as_a <gswitch *> (stmt));\n \tif (! failure_reason)\n \t  {\n \t    if (dump_file)"}, {"sha": "037dfbce207672162e4b139410e0209fc9f1574a", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -280,7 +280,7 @@ independent_of_stmt_p (tree expr, gimple at, gimple_stmt_iterator gsi)\n    additive factor for the real return value.  */\n \n static bool\n-process_assignment (gimple stmt, gimple_stmt_iterator call, tree *m,\n+process_assignment (gassign *stmt, gimple_stmt_iterator call, tree *m,\n \t\t    tree *a, tree *ass_var)\n {\n   tree op0, op1 = NULL_TREE, non_ass_var = NULL_TREE;\n@@ -401,11 +401,11 @@ static tree\n propagate_through_phis (tree var, edge e)\n {\n   basic_block dest = e->dest;\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n \n   for (gsi = gsi_start_phis (dest); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n       if (PHI_ARG_DEF_FROM_EDGE (phi, e) == var)\n         return PHI_RESULT (phi);\n     }\n@@ -419,7 +419,8 @@ static void\n find_tail_calls (basic_block bb, struct tailcall **ret)\n {\n   tree ass_var = NULL_TREE, ret_var, func, param;\n-  gimple stmt, call = NULL;\n+  gimple stmt;\n+  gcall *call = NULL;\n   gimple_stmt_iterator gsi, agsi;\n   bool tail_recursion;\n   struct tailcall *nw;\n@@ -446,8 +447,8 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n       /* Check for a call.  */\n       if (is_gimple_call (stmt))\n \t{\n-\t  call = stmt;\n-\t  ass_var = gimple_call_lhs (stmt);\n+\t  call = as_a <gcall *> (stmt);\n+\t  ass_var = gimple_call_lhs (call);\n \t  break;\n \t}\n \n@@ -572,7 +573,8 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n \treturn;\n \n       /* This is a gimple assign. */\n-      if (! process_assignment (stmt, gsi, &tmp_m, &tmp_a, &ass_var))\n+      if (! process_assignment (as_a <gassign *> (stmt), gsi, &tmp_m,\n+\t\t\t\t&tmp_a, &ass_var))\n \treturn;\n \n       if (tmp_a)\n@@ -597,7 +599,7 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n     }\n \n   /* See if this is a tail call we can handle.  */\n-  ret_var = gimple_return_retval (stmt);\n+  ret_var = gimple_return_retval (as_a <greturn *> (stmt));\n \n   /* We may proceed if there either is no return value, or the return value\n      is identical to the call's return.  */\n@@ -632,14 +634,14 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n static void\n add_successor_phi_arg (edge e, tree var, tree phi_arg)\n {\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n \n   for (gsi = gsi_start_phis (e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n-    if (PHI_RESULT (gsi_stmt (gsi)) == var)\n+    if (PHI_RESULT (gsi.phi ()) == var)\n       break;\n \n   gcc_assert (!gsi_end_p (gsi));\n-  add_phi_arg (gsi_stmt (gsi), phi_arg, e, UNKNOWN_LOCATION);\n+  add_phi_arg (gsi.phi (), phi_arg, e, UNKNOWN_LOCATION);\n }\n \n /* Creates a GIMPLE statement which computes the operation specified by\n@@ -654,7 +656,7 @@ adjust_return_value_with_ops (enum tree_code code, const char *label,\n \n   tree ret_type = TREE_TYPE (DECL_RESULT (current_function_decl));\n   tree result = make_temp_ssa_name (ret_type, NULL, label);\n-  gimple stmt;\n+  gassign *stmt;\n \n   if (POINTER_TYPE_P (ret_type))\n     {\n@@ -691,7 +693,7 @@ static tree\n update_accumulator_with_ops (enum tree_code code, tree acc, tree op1,\n \t\t\t     gimple_stmt_iterator gsi)\n {\n-  gimple stmt;\n+  gassign *stmt;\n   tree var = copy_ssa_name (acc, NULL);\n   if (types_compatible_p (TREE_TYPE (acc), TREE_TYPE (op1)))\n     stmt = gimple_build_assign_with_ops (code, var, acc, op1);\n@@ -758,7 +760,7 @@ static void\n adjust_return_value (basic_block bb, tree m, tree a)\n {\n   tree retval;\n-  gimple ret_stmt = gimple_seq_last_stmt (bb_seq (bb));\n+  greturn *ret_stmt = as_a <greturn *> (gimple_seq_last_stmt (bb_seq (bb)));\n   gimple_stmt_iterator gsi = gsi_last_bb (bb);\n \n   gcc_assert (gimple_code (ret_stmt) == GIMPLE_RETURN);\n@@ -831,7 +833,8 @@ eliminate_tail_call (struct tailcall *t)\n   size_t idx;\n   basic_block bb, first;\n   edge e;\n-  gimple phi;\n+  gphi *phi;\n+  gphi_iterator gpi;\n   gimple_stmt_iterator gsi;\n   gimple orig_stmt;\n \n@@ -884,19 +887,19 @@ eliminate_tail_call (struct tailcall *t)\n   /* Add phi node entries for arguments.  The ordering of the phi nodes should\n      be the same as the ordering of the arguments.  */\n   for (param = DECL_ARGUMENTS (current_function_decl),\n-\t idx = 0, gsi = gsi_start_phis (first);\n+\t idx = 0, gpi = gsi_start_phis (first);\n        param;\n        param = DECL_CHAIN (param), idx++)\n     {\n       if (!arg_needs_copy_p (param))\n \tcontinue;\n \n       arg = gimple_call_arg (stmt, idx);\n-      phi = gsi_stmt (gsi);\n+      phi = gpi.phi ();\n       gcc_assert (param == SSA_NAME_VAR (PHI_RESULT (phi)));\n \n       add_phi_arg (phi, arg, e, gimple_location (stmt));\n-      gsi_next (&gsi);\n+      gsi_next (&gpi);\n     }\n \n   /* Update the values of accumulators.  */\n@@ -929,7 +932,7 @@ optimize_tail_call (struct tailcall *t, bool opt_tailcalls)\n \n   if (opt_tailcalls)\n     {\n-      gimple stmt = gsi_stmt (t->call_gsi);\n+      gcall *stmt = as_a <gcall *> (gsi_stmt (t->call_gsi));\n \n       gimple_call_set_tail (stmt, true);\n       cfun->tail_call_marked = true;\n@@ -958,7 +961,7 @@ create_tailcall_accumulator (const char *label, basic_block bb, tree init)\n     ret_type = sizetype;\n \n   tree tmp = make_temp_ssa_name (ret_type, NULL, label);\n-  gimple phi;\n+  gphi *phi;\n \n   phi = create_phi_node (tmp, bb);\n   /* RET_TYPE can be a float when -ffast-maths is enabled.  */\n@@ -1022,7 +1025,7 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n \t      {\n \t\ttree name = ssa_default_def (cfun, param);\n \t\ttree new_name = make_ssa_name (param, SSA_NAME_DEF_STMT (name));\n-\t\tgimple phi;\n+\t\tgphi *phi;\n \n \t\tset_ssa_default_def (cfun, param, new_name);\n \t\tphi = create_phi_node (name, first);"}, {"sha": "35d0e0fa80311f1f1fb9117b75933a5d4ebaa804", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -4339,7 +4339,7 @@ bump_vector_ptr (tree dataref_ptr, gimple ptr_incr, gimple_stmt_iterator *gsi,\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   tree update = TYPE_SIZE_UNIT (vectype);\n-  gimple incr_stmt;\n+  gassign *incr_stmt;\n   ssa_op_iter iter;\n   use_operand_p use_p;\n   tree new_dataref_ptr;\n@@ -4778,11 +4778,10 @@ vect_setup_realignment (gimple stmt, gimple_stmt_iterator *gsi,\n   gimple inc;\n   tree ptr;\n   tree data_ref;\n-  gimple new_stmt;\n   basic_block new_bb;\n   tree msq_init = NULL_TREE;\n   tree new_temp;\n-  gimple phi_stmt;\n+  gphi *phi_stmt;\n   tree msq = NULL_TREE;\n   gimple_seq stmts = NULL;\n   bool inv_p;\n@@ -4873,6 +4872,7 @@ vect_setup_realignment (gimple stmt, gimple_stmt_iterator *gsi,\n   if (alignment_support_scheme == dr_explicit_realign_optimized)\n     {\n       /* Create msq_init = *(floor(p1)) in the loop preheader  */\n+      gassign *new_stmt;\n \n       gcc_assert (!compute_in_loop);\n       vec_dest = vect_create_destination_var (scalar_dest, vectype);\n@@ -4909,6 +4909,7 @@ vect_setup_realignment (gimple stmt, gimple_stmt_iterator *gsi,\n \n   if (targetm.vectorize.builtin_mask_for_load)\n     {\n+      gcall *new_stmt;\n       tree builtin_decl;\n \n       /* Compute INIT_ADDR - the initial addressed accessed by this memref.  */"}, {"sha": "246ca623b5186bc15e43c7f66a6fc044e83e3098", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -846,7 +846,7 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n static void\n expand_vector_condition (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gassign *stmt = as_a <gassign *> (gsi_stmt (*gsi));\n   tree type = gimple_expr_type (stmt);\n   tree a = gimple_assign_rhs1 (stmt);\n   tree a1 = a;\n@@ -909,7 +909,7 @@ expand_vector_condition (gimple_stmt_iterator *gsi)\n \n static tree\n expand_vector_operation (gimple_stmt_iterator *gsi, tree type, tree compute_type,\n-\t\t\t gimple assign, enum tree_code code)\n+\t\t\t gassign *assign, enum tree_code code)\n {\n   machine_mode compute_mode = TYPE_MODE (compute_type);\n \n@@ -1015,7 +1015,7 @@ expand_vector_operation (gimple_stmt_iterator *gsi, tree type, tree compute_type\n static void\n optimize_vector_constructor (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gassign *stmt = as_a <gassign *> (gsi_stmt (*gsi));\n   tree lhs = gimple_assign_lhs (stmt);\n   tree rhs = gimple_assign_rhs1 (stmt);\n   tree type = TREE_TYPE (rhs);\n@@ -1230,7 +1230,7 @@ vector_element (gimple_stmt_iterator *gsi, tree vect, tree idx, tree *ptmpvec)\n static void\n lower_vec_perm (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gassign *stmt = as_a <gassign *> (gsi_stmt (*gsi));\n   tree mask = gimple_assign_rhs3 (stmt);\n   tree vec0 = gimple_assign_rhs1 (stmt);\n   tree vec1 = gimple_assign_rhs2 (stmt);\n@@ -1403,14 +1403,15 @@ count_type_subparts (tree type)\n static void\n expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n   tree lhs, rhs1, rhs2 = NULL, type, compute_type = NULL_TREE;\n   enum tree_code code;\n   optab op = unknown_optab;\n   enum gimple_rhs_class rhs_class;\n   tree new_rhs;\n \n-  if (gimple_code (stmt) != GIMPLE_ASSIGN)\n+  /* Only consider code == GIMPLE_ASSIGN. */\n+  gassign *stmt = dyn_cast <gassign *> (gsi_stmt (*gsi));\n+  if (!stmt)\n     return;\n \n   code = gimple_assign_rhs_code (stmt);"}, {"sha": "64ccaa3becfeb671b96f70a4b456228152f36334", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -96,15 +96,15 @@ rename_use_op (use_operand_p op_p)\n static void\n rename_variables_in_bb (basic_block bb)\n {\n-  gimple_stmt_iterator gsi;\n   gimple stmt;\n   use_operand_p use_p;\n   ssa_op_iter iter;\n   edge e;\n   edge_iterator ei;\n   struct loop *loop = bb->loop_father;\n \n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n     {\n       stmt = gsi_stmt (gsi);\n       FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n@@ -115,8 +115,9 @@ rename_variables_in_bb (basic_block bb)\n     {\n       if (!flow_bb_inside_loop_p (loop, e->src))\n \tcontinue;\n-      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-        rename_use_op (PHI_ARG_DEF_PTR_FROM_EDGE (gsi_stmt (gsi), e));\n+      for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+        rename_use_op (PHI_ARG_DEF_PTR_FROM_EDGE (gsi.phi (), e));\n     }\n }\n \n@@ -402,16 +403,16 @@ static void\n slpeel_update_phi_nodes_for_guard1 (edge guard_edge, struct loop *loop,\n                                     bool is_new_loop, basic_block *new_exit_bb)\n {\n-  gimple orig_phi, new_phi;\n-  gimple update_phi, update_phi2;\n+  gphi *orig_phi, *new_phi;\n+  gphi *update_phi, *update_phi2;\n   tree guard_arg, loop_arg;\n   basic_block new_merge_bb = guard_edge->dest;\n   edge e = EDGE_SUCC (new_merge_bb, 0);\n   basic_block update_bb = e->dest;\n   basic_block orig_bb = loop->header;\n   edge new_exit_e;\n   tree current_new_name;\n-  gimple_stmt_iterator gsi_orig, gsi_update;\n+  gphi_iterator gsi_orig, gsi_update;\n \n   /* Create new bb between loop and new_merge_bb.  */\n   *new_exit_bb = split_edge (single_exit (loop));\n@@ -425,8 +426,8 @@ slpeel_update_phi_nodes_for_guard1 (edge guard_edge, struct loop *loop,\n     {\n       source_location loop_locus, guard_locus;\n       tree new_res;\n-      orig_phi = gsi_stmt (gsi_orig);\n-      update_phi = gsi_stmt (gsi_update);\n+      orig_phi = gsi_orig.phi ();\n+      update_phi = gsi_update.phi ();\n \n       /** 1. Handle new-merge-point phis  **/\n \n@@ -542,8 +543,8 @@ static void\n slpeel_update_phi_nodes_for_guard2 (edge guard_edge, struct loop *loop,\n                                     bool is_new_loop, basic_block *new_exit_bb)\n {\n-  gimple orig_phi, new_phi;\n-  gimple update_phi, update_phi2;\n+  gphi *orig_phi, *new_phi;\n+  gphi *update_phi, *update_phi2;\n   tree guard_arg, loop_arg;\n   basic_block new_merge_bb = guard_edge->dest;\n   edge e = EDGE_SUCC (new_merge_bb, 0);\n@@ -552,7 +553,7 @@ slpeel_update_phi_nodes_for_guard2 (edge guard_edge, struct loop *loop,\n   tree orig_def, orig_def_new_name;\n   tree new_name, new_name2;\n   tree arg;\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n \n   /* Create new bb between loop and new_merge_bb.  */\n   *new_exit_bb = split_edge (single_exit (loop));\n@@ -562,7 +563,7 @@ slpeel_update_phi_nodes_for_guard2 (edge guard_edge, struct loop *loop,\n   for (gsi = gsi_start_phis (update_bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       tree new_res;\n-      update_phi = gsi_stmt (gsi);\n+      update_phi = gsi.phi ();\n       orig_phi = update_phi;\n       orig_def = PHI_ARG_DEF_FROM_EDGE (orig_phi, e);\n       /* This loop-closed-phi actually doesn't represent a use\n@@ -678,8 +679,8 @@ void\n slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters)\n {\n   tree indx_before_incr, indx_after_incr;\n-  gimple cond_stmt;\n-  gimple orig_cond;\n+  gcond *cond_stmt;\n+  gcond *orig_cond;\n   edge exit_edge = single_exit (loop);\n   gimple_stmt_iterator loop_cond_gsi;\n   gimple_stmt_iterator incr_gsi;\n@@ -831,13 +832,13 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop,\n     {\n       if (scalar_loop != loop)\n \t{\n-\t  gimple_stmt_iterator gsi;\n+\t  gphi_iterator gsi;\n \t  new_exit = redirect_edge_and_branch (new_exit, exit_dest);\n \n \t  for (gsi = gsi_start_phis (exit_dest); !gsi_end_p (gsi);\n \t       gsi_next (&gsi))\n \t    {\n-\t      gimple phi = gsi_stmt (gsi);\n+\t      gphi *phi = gsi.phi ();\n \t      tree orig_arg = PHI_ARG_DEF_FROM_EDGE (phi, e);\n \t      location_t orig_locus\n \t\t= gimple_phi_arg_location_from_edge (phi, e);\n@@ -897,7 +898,7 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop,\n     {\n       /* Update new_loop->header PHIs, so that on the preheader\n \t edge they are the ones from loop rather than scalar_loop.  */\n-      gimple_stmt_iterator gsi_orig, gsi_new;\n+      gphi_iterator gsi_orig, gsi_new;\n       edge orig_e = loop_preheader_edge (loop);\n       edge new_e = loop_preheader_edge (new_loop);\n \n@@ -906,8 +907,8 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop,\n \t   !gsi_end_p (gsi_orig) && !gsi_end_p (gsi_new);\n \t   gsi_next (&gsi_orig), gsi_next (&gsi_new))\n \t{\n-\t  gimple orig_phi = gsi_stmt (gsi_orig);\n-\t  gimple new_phi = gsi_stmt (gsi_new);\n+\t  gphi *orig_phi = gsi_orig.phi ();\n+\t  gphi *new_phi = gsi_new.phi ();\n \t  tree orig_arg = PHI_ARG_DEF_FROM_EDGE (orig_phi, orig_e);\n \t  location_t orig_locus\n \t    = gimple_phi_arg_location_from_edge (orig_phi, orig_e);\n@@ -940,7 +941,7 @@ slpeel_add_loop_guard (basic_block guard_bb, tree cond,\n {\n   gimple_stmt_iterator gsi;\n   edge new_e, enter_e;\n-  gimple cond_stmt;\n+  gcond *cond_stmt;\n   gimple_seq gimplify_stmt_list = NULL;\n \n   enter_e = EDGE_SUCC (guard_bb, 0);\n@@ -985,7 +986,7 @@ slpeel_can_duplicate_loop_p (const struct loop *loop, const_edge e)\n {\n   edge exit_e = single_exit (loop);\n   edge entry_e = loop_preheader_edge (loop);\n-  gimple orig_cond = get_loop_exit_condition (loop);\n+  gcond *orig_cond = get_loop_exit_condition (loop);\n   gimple_stmt_iterator loop_exit_gsi = gsi_last_bb (exit_e->src);\n \n   if (loop->inner\n@@ -1053,9 +1054,9 @@ set_prologue_iterations (basic_block bb_before_first_loop,\n   basic_block cond_bb, then_bb;\n   tree var, prologue_after_cost_adjust_name;\n   gimple_stmt_iterator gsi;\n-  gimple newphi;\n+  gphi *newphi;\n   edge e_true, e_false, e_fallthru;\n-  gimple cond_stmt;\n+  gcond *cond_stmt;\n   gimple_seq stmts = NULL;\n   tree cost_pre_condition = NULL_TREE;\n   tree scalar_loop_iters =\n@@ -1184,7 +1185,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loop *scalar_loop,\n   basic_block bb_before_first_loop;\n   basic_block bb_between_loops;\n   basic_block new_exit_bb;\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n   edge exit_e = single_exit (loop);\n   source_location loop_loc;\n   /* There are many aspects to how likely the first loop is going to be executed.\n@@ -1216,15 +1217,15 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loop *scalar_loop,\n   for (gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))\n     if (virtual_operand_p (gimple_phi_result (gsi_stmt (gsi))))\n       {\n-\tgimple phi = gsi_stmt (gsi);\n+\tgphi *phi = gsi.phi ();\n \tfor (gsi = gsi_start_phis (exit_e->dest);\n \t     !gsi_end_p (gsi); gsi_next (&gsi))\n \t  if (virtual_operand_p (gimple_phi_result (gsi_stmt (gsi))))\n \t    break;\n \tif (gsi_end_p (gsi))\n \t  {\n \t    tree new_vop = copy_ssa_name (PHI_RESULT (phi), NULL);\n-\t    gimple new_phi = create_phi_node (new_vop, exit_e->dest);\n+\t    gphi *new_phi = create_phi_node (new_vop, exit_e->dest);\n \t    tree vop = PHI_ARG_DEF_FROM_EDGE (phi, EDGE_SUCC (loop->latch, 0));\n \t    imm_use_iterator imm_iter;\n \t    gimple stmt;\n@@ -1540,7 +1541,7 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block bb = loop->header;\n   gimple phi;\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n \n   /* Analyze phi functions of the loop header.  */\n \n@@ -1550,7 +1551,7 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n     {\n       tree evolution_part;\n \n-      phi = gsi_stmt (gsi);\n+      phi = gsi.phi ();\n       if (dump_enabled_p ())\n \t{\n           dump_printf_loc (MSG_NOTE, vect_location, \"Analyze phi: \");\n@@ -1649,8 +1650,8 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block exit_bb = single_exit (loop)->dest;\n-  gimple phi, phi1;\n-  gimple_stmt_iterator gsi, gsi1;\n+  gphi *phi, *phi1;\n+  gphi_iterator gsi, gsi1;\n   basic_block update_bb = update_e->dest;\n \n   gcc_checking_assert (vect_can_advance_ivs_p (loop_vinfo));\n@@ -1669,8 +1670,8 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n       gimple_stmt_iterator last_gsi;\n       stmt_vec_info stmt_info;\n \n-      phi = gsi_stmt (gsi);\n-      phi1 = gsi_stmt (gsi1);\n+      phi = gsi.phi ();\n+      phi1 = gsi1.phi ();\n       if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_NOTE, vect_location,\n@@ -2328,11 +2329,12 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   struct loop *scalar_loop = LOOP_VINFO_SCALAR_LOOP (loop_vinfo);\n   basic_block condition_bb;\n-  gimple_stmt_iterator gsi, cond_exp_gsi;\n+  gphi_iterator gsi;\n+  gimple_stmt_iterator cond_exp_gsi;\n   basic_block merge_bb;\n   basic_block new_exit_bb;\n   edge new_exit_e, e;\n-  gimple orig_phi, new_phi;\n+  gphi *orig_phi, *new_phi;\n   tree cond_expr = NULL_TREE;\n   gimple_seq cond_expr_stmt_list = NULL;\n   tree arg;\n@@ -2436,7 +2438,7 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n       for (gsi = gsi_start_phis (merge_bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  tree new_res;\n-\t  orig_phi = gsi_stmt (gsi);\n+\t  orig_phi = gsi.phi ();\n \t  new_res = copy_ssa_name (PHI_RESULT (orig_phi), NULL);\n \t  new_phi = create_phi_node (new_res, new_exit_bb);\n \t  arg = PHI_ARG_DEF_FROM_EDGE (orig_phi, e);"}, {"sha": "a4f9501b29e079124d6ada5cd7ba8084f89422d8", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -199,10 +199,9 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n   int nbbs = loop->num_nodes;\n-  gimple_stmt_iterator si;\n   unsigned int vectorization_factor = 0;\n   tree scalar_type;\n-  gimple phi;\n+  gphi *phi;\n   tree vectype;\n   unsigned int nunits;\n   stmt_vec_info stmt_info;\n@@ -221,9 +220,10 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n     {\n       basic_block bb = bbs[i];\n \n-      for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n+      for (gphi_iterator si = gsi_start_phis (bb); !gsi_end_p (si);\n+\t   gsi_next (&si))\n \t{\n-\t  phi = gsi_stmt (si);\n+\t  phi = si.phi ();\n \t  stmt_info = vinfo_for_stmt (phi);\n \t  if (dump_enabled_p ())\n \t    {\n@@ -281,7 +281,8 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t    }\n \t}\n \n-      for (si = gsi_start_bb (bb); !gsi_end_p (si) || analyze_pattern_stmt;)\n+      for (gimple_stmt_iterator si = gsi_start_bb (bb);\n+\t   !gsi_end_p (si) || analyze_pattern_stmt;)\n         {\n           tree vf_vectype;\n \n@@ -634,7 +635,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n   basic_block bb = loop->header;\n   tree init, step;\n   auto_vec<gimple, 64> worklist;\n-  gimple_stmt_iterator gsi;\n+  gphi_iterator gsi;\n   bool double_reduc;\n \n   if (dump_enabled_p ())\n@@ -646,7 +647,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n      changed.  */\n   for (gsi = gsi_start_phis  (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gphi *phi = gsi.phi ();\n       tree access_fn = NULL;\n       tree def = PHI_RESULT (phi);\n       stmt_vec_info stmt_vinfo = vinfo_for_stmt (phi);\n@@ -817,7 +818,8 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n \n    Return the loop exit condition.  */\n \n-static gimple\n+\n+static gcond *\n vect_get_loop_niters (struct loop *loop, tree *number_of_iterations,\n \t\t      tree *number_of_iterationsm1)\n {\n@@ -1097,7 +1099,7 @@ loop_vec_info\n vect_analyze_loop_form (struct loop *loop)\n {\n   loop_vec_info loop_vinfo;\n-  gimple loop_cond;\n+  gcond *loop_cond;\n   tree number_of_iterations = NULL, number_of_iterationsm1 = NULL;\n   loop_vec_info inner_loop_vinfo = NULL;\n \n@@ -1345,10 +1347,8 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n   int nbbs = loop->num_nodes;\n-  gimple_stmt_iterator si;\n   unsigned int vectorization_factor = 0;\n   int i;\n-  gimple phi;\n   stmt_vec_info stmt_info;\n   bool need_to_vectorize = false;\n   int min_profitable_iters;\n@@ -1375,7 +1375,8 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n       for (i = 0; i < nbbs; i++)\n \t{\n \t  basic_block bb = bbs[i];\n-\t  for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+\t  for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n+\t       gsi_next (&si))\n \t    {\n \t      gimple stmt = gsi_stmt (si);\n \t      stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n@@ -1405,9 +1406,10 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n     {\n       basic_block bb = bbs[i];\n \n-      for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n+      for (gphi_iterator si = gsi_start_phis (bb); !gsi_end_p (si);\n+\t   gsi_next (&si))\n         {\n-          phi = gsi_stmt (si);\n+          gphi *phi = si.phi ();\n           ok = true;\n \n           stmt_info = vinfo_for_stmt (phi);\n@@ -1510,7 +1512,8 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n             }\n         }\n \n-      for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+      for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n+\t   gsi_next (&si))\n         {\n           gimple stmt = gsi_stmt (si);\n \t  if (!gimple_clobber_p (stmt)\n@@ -3304,7 +3307,8 @@ get_initial_def_for_induction (gimple iv_phi)\n   tree new_vec, vec_init, vec_step, t;\n   tree new_var;\n   tree new_name;\n-  gimple init_stmt, induction_phi, new_stmt;\n+  gimple init_stmt, new_stmt;\n+  gphi *induction_phi;\n   tree induc_def, vec_def, vec_dest;\n   tree init_expr, step_expr;\n   int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n@@ -4008,14 +4012,15 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n       for (j = 0; j < ncopies; j++)\n         {\n           /* Set the loop-entry arg of the reduction-phi.  */\n-          add_phi_arg (phi, vec_init_def, loop_preheader_edge (loop),\n-                       UNKNOWN_LOCATION);\n+          add_phi_arg (as_a <gphi *> (phi), vec_init_def,\n+\t\t       loop_preheader_edge (loop), UNKNOWN_LOCATION);\n \n           /* Set the loop-latch arg for the reduction-phi.  */\n           if (j > 0)\n             def = vect_get_vec_def_for_stmt_copy (vect_unknown_def_type, def);\n \n-          add_phi_arg (phi, def, loop_latch_edge (loop), UNKNOWN_LOCATION);\n+          add_phi_arg (as_a <gphi *> (phi), def, loop_latch_edge (loop),\n+\t\t       UNKNOWN_LOCATION);\n \n           if (dump_enabled_p ())\n             {\n@@ -4095,7 +4100,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n       FOR_EACH_VEC_ELT (new_phis, i, phi)\n \t{\n \t  tree new_result = copy_ssa_name (PHI_RESULT (phi), NULL);\n-\t  gimple outer_phi = create_phi_node (new_result, exit_bb);\n+\t  gphi *outer_phi = create_phi_node (new_result, exit_bb);\n \t  SET_PHI_ARG_DEF (outer_phi, single_exit (loop)->dest_idx,\n \t\t\t   PHI_RESULT (phi));\n \t  set_vinfo_for_stmt (outer_phi, new_stmt_vec_info (outer_phi,\n@@ -4182,7 +4187,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n     {\n       tree first_vect = PHI_RESULT (new_phis[0]);\n       tree tmp;\n-      gimple new_vec_stmt = NULL;\n+      gassign *new_vec_stmt = NULL;\n \n       vec_dest = vect_create_destination_var (scalar_dest, vectype);\n       for (k = 1; k < new_phis.length (); k++)\n@@ -4557,7 +4562,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n           if (outer_loop)\n             {\n               stmt_vec_info exit_phi_vinfo = vinfo_for_stmt (exit_phi);\n-              gimple vect_phi;\n+              gphi *vect_phi;\n \n               /* FORNOW. Currently not supporting the case that an inner-loop\n                  reduction is not used in the outer-loop (but only outside the\n@@ -4772,7 +4777,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n   tree def;\n   gimple def_stmt;\n   enum vect_def_type dt;\n-  gimple new_phi = NULL;\n+  gphi *new_phi = NULL;\n   tree scalar_type;\n   bool is_simple_use;\n   gimple orig_stmt;\n@@ -5816,7 +5821,6 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n   int nbbs = loop->num_nodes;\n-  gimple_stmt_iterator si;\n   int i;\n   tree ratio = NULL;\n   int vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n@@ -5925,11 +5929,11 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n     {\n       basic_block bb = bbs[i];\n       stmt_vec_info stmt_info;\n-      gimple phi;\n \n-      for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n+      for (gphi_iterator si = gsi_start_phis (bb); !gsi_end_p (si);\n+\t   gsi_next (&si))\n         {\n-\t  phi = gsi_stmt (si);\n+\t  gphi *phi = si.phi ();\n \t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n@@ -5963,7 +5967,8 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t}\n \n       pattern_stmt = NULL;\n-      for (si = gsi_start_bb (bb); !gsi_end_p (si) || transform_pattern_stmt;)\n+      for (gimple_stmt_iterator si = gsi_start_bb (bb);\n+\t   !gsi_end_p (si) || transform_pattern_stmt;)\n \t{\n \t  bool is_store;\n "}, {"sha": "f2bce3cbaa5abb6b00a827be0da3778af39c150c", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -1127,7 +1127,7 @@ vect_recog_pow_pattern (vec<gimple> *stmts, tree *type_in,\n       *type_in = get_vectype_for_scalar_type (TREE_TYPE (base));\n       if (*type_in)\n \t{\n-\t  gimple stmt = gimple_build_call (newfn, 1, base);\n+\t  gcall *stmt = gimple_build_call (newfn, 1, base);\n \t  if (vectorizable_function (stmt, *type_in, *type_in)\n \t      != NULL_TREE)\n \t    {"}, {"sha": "829f74aaea80a0f024ab0afda1f2b094280fe90a", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -555,20 +555,21 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n             vectorization_factor = *max_nunits;\n         }\n \n-      if (is_gimple_call (stmt))\n+      if (gcall *call_stmt = dyn_cast <gcall *> (stmt))\n \t{\n \t  rhs_code = CALL_EXPR;\n-\t  if (gimple_call_internal_p (stmt)\n-\t      || gimple_call_tail_p (stmt)\n-\t      || gimple_call_noreturn_p (stmt)\n-\t      || !gimple_call_nothrow_p (stmt)\n-\t      || gimple_call_chain (stmt))\n+\t  if (gimple_call_internal_p (call_stmt)\n+\t      || gimple_call_tail_p (call_stmt)\n+\t      || gimple_call_noreturn_p (call_stmt)\n+\t      || !gimple_call_nothrow_p (call_stmt)\n+\t      || gimple_call_chain (call_stmt))\n \t    {\n \t      if (dump_enabled_p ())\n \t\t{\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t\t   \"Build SLP failed: unsupported call type \");\n-\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t\t    call_stmt, 0);\n                   dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t\t}\n \t      /* Fatal mismatch.  */"}, {"sha": "e80ac95a7feb36d816c7f63f59df7fa313cfd302", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -1720,7 +1720,7 @@ vect_finish_stmt_generation (gimple stmt, gimple vec_stmt,\n    of the function, or NULL_TREE if the function cannot be vectorized.  */\n \n tree\n-vectorizable_function (gimple call, tree vectype_out, tree vectype_in)\n+vectorizable_function (gcall *call, tree vectype_out, tree vectype_in)\n {\n   tree fndecl = gimple_call_fndecl (call);\n \n@@ -2186,20 +2186,21 @@ vectorizable_mask_load_store (gimple stmt, gimple_stmt_iterator *gsi,\n \n /* Function vectorizable_call.\n \n-   Check if STMT performs a function call that can be vectorized.\n+   Check if GS performs a function call that can be vectorized.\n    If VEC_STMT is also passed, vectorize the STMT: create a vectorized\n    stmt to replace it, put it in VEC_STMT, and insert it at BSI.\n    Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n \n static bool\n-vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n+vectorizable_call (gimple gs, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t   slp_tree slp_node)\n {\n+  gcall *stmt;\n   tree vec_dest;\n   tree scalar_dest;\n   tree op, type;\n   tree vec_oprnd0 = NULL_TREE, vec_oprnd1 = NULL_TREE;\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt), prev_stmt_info;\n+  stmt_vec_info stmt_info = vinfo_for_stmt (gs), prev_stmt_info;\n   tree vectype_out, vectype_in;\n   int nunits_in;\n   int nunits_out;\n@@ -2222,8 +2223,9 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n     return false;\n \n-  /* Is STMT a vectorizable call?   */\n-  if (!is_gimple_call (stmt))\n+  /* Is GS a vectorizable call?   */\n+  stmt = dyn_cast <gcall *> (gs);\n+  if (!stmt)\n     return false;\n \n   if (gimple_call_internal_p (stmt)\n@@ -2991,7 +2993,7 @@ vectorizable_simd_clone_call (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t      gcc_assert (!new_bb);\n \t\t    }\n \t\t  tree phi_res = copy_ssa_name (op, NULL);\n-\t\t  gimple new_phi = create_phi_node (phi_res, loop->header);\n+\t\t  gphi *new_phi = create_phi_node (phi_res, loop->header);\n \t\t  set_vinfo_for_stmt (new_phi,\n \t\t\t\t      new_stmt_vec_info (new_phi, loop_vinfo,\n \t\t\t\t\t\t\t NULL));\n@@ -5619,7 +5621,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   tree offset = NULL_TREE;\n   tree byte_offset = NULL_TREE;\n   tree realignment_token = NULL_TREE;\n-  gimple phi = NULL;\n+  gphi *phi = NULL;\n   vec<tree> dr_chain = vNULL;\n   bool grouped_load = false;\n   bool load_lanes_p = false;\n@@ -6274,7 +6276,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t\t\t    &at_loop);\n       if (alignment_support_scheme == dr_explicit_realign_optimized)\n \t{\n-\t  phi = SSA_NAME_DEF_STMT (msq);\n+\t  phi = as_a <gphi *> (SSA_NAME_DEF_STMT (msq));\n \t  byte_offset = size_binop (MINUS_EXPR, TYPE_SIZE_UNIT (vectype),\n \t\t\t\t    size_one_node);\n \t}\n@@ -6805,7 +6807,7 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n   /* Handle cond expr.  */\n   for (j = 0; j < ncopies; j++)\n     {\n-      gimple new_stmt = NULL;\n+      gassign *new_stmt = NULL;\n       if (j == 0)\n \t{\n           if (slp_node)"}, {"sha": "3f9b78c9cf9263041eaff542cdac7161dd9a36b4", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -1004,7 +1004,7 @@ extern bool supportable_narrowing_operation (enum tree_code, tree, tree,\n extern stmt_vec_info new_stmt_vec_info (gimple stmt, loop_vec_info,\n                                         bb_vec_info);\n extern void free_stmt_vec_info (gimple stmt);\n-extern tree vectorizable_function (gimple, tree, tree);\n+extern tree vectorizable_function (gcall *, tree, tree);\n extern void vect_model_simple_cost (stmt_vec_info, int, enum vect_def_type *,\n                                     stmt_vector_for_cost *,\n \t\t\t\t    stmt_vector_for_cost *);"}, {"sha": "bcf4c2ba60c64bfc5f020b5eb44b88dd3cad1474", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 52, "deletions": 48, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -181,7 +181,7 @@ static bool values_propagated;\n static int *vr_phi_edge_counts;\n \n typedef struct {\n-  gimple stmt;\n+  gswitch *stmt;\n   tree vec;\n } switch_update;\n \n@@ -3690,7 +3690,7 @@ extract_range_from_unary_expr (value_range_t *vr, enum tree_code code,\n    the ranges of each of its operands and the expression code.  */\n \n static void\n-extract_range_from_cond_expr (value_range_t *vr, gimple stmt)\n+extract_range_from_cond_expr (value_range_t *vr, gassign *stmt)\n {\n   tree op0, op1;\n   value_range_t vr0 = VR_INITIALIZER;\n@@ -4184,7 +4184,7 @@ extract_range_basic (value_range_t *vr, gimple stmt)\n    in *VR.  */\n \n static void\n-extract_range_from_assignment (value_range_t *vr, gimple stmt)\n+extract_range_from_assignment (value_range_t *vr, gassign *stmt)\n {\n   enum tree_code code = gimple_assign_rhs_code (stmt);\n \n@@ -4802,7 +4802,7 @@ static gimple\n build_assert_expr_for (tree cond, tree v)\n {\n   tree a;\n-  gimple assertion;\n+  gassign *assertion;\n \n   gcc_assert (TREE_CODE (v) == SSA_NAME\n \t      && COMPARISON_CLASS_P (cond));\n@@ -5869,7 +5869,7 @@ register_edge_assert_for (tree name, edge e, gimple_stmt_iterator si,\n    list of assertions for the corresponding operands.  */\n \n static void\n-find_conditional_asserts (basic_block bb, gimple last)\n+find_conditional_asserts (basic_block bb, gcond *last)\n {\n   gimple_stmt_iterator bsi;\n   tree op;\n@@ -5941,7 +5941,7 @@ compare_case_labels (const void *p1, const void *p2)\n    list of assertions for the corresponding operands.  */\n \n static void\n-find_switch_asserts (basic_block bb, gimple last)\n+find_switch_asserts (basic_block bb, gswitch *last)\n {\n   gimple_stmt_iterator bsi;\n   tree op;\n@@ -6079,7 +6079,6 @@ find_switch_asserts (basic_block bb, gimple last)\n static void\n find_assert_locations_1 (basic_block bb, sbitmap live)\n {\n-  gimple_stmt_iterator si;\n   gimple last;\n \n   last = last_stmt (bb);\n@@ -6090,18 +6089,19 @@ find_assert_locations_1 (basic_block bb, sbitmap live)\n       && gimple_code (last) == GIMPLE_COND\n       && !fp_predicate (last)\n       && !ZERO_SSA_OPERANDS (last, SSA_OP_USE))\n-    find_conditional_asserts (bb, last);\n+    find_conditional_asserts (bb, as_a <gcond *> (last));\n \n   /* If BB's last statement is a switch statement involving integer\n      operands, determine if we need to add ASSERT_EXPRs.  */\n   if (last\n       && gimple_code (last) == GIMPLE_SWITCH\n       && !ZERO_SSA_OPERANDS (last, SSA_OP_USE))\n-    find_switch_asserts (bb, last);\n+    find_switch_asserts (bb, as_a <gswitch *> (last));\n \n   /* Traverse all the statements in BB marking used names and looking\n      for statements that may infer assertions for their used operands.  */\n-  for (si = gsi_last_bb (bb); !gsi_end_p (si); gsi_prev (&si))\n+  for (gimple_stmt_iterator si = gsi_last_bb (bb); !gsi_end_p (si);\n+       gsi_prev (&si))\n     {\n       gimple stmt;\n       tree op;\n@@ -6171,11 +6171,12 @@ find_assert_locations_1 (basic_block bb, sbitmap live)\n     }\n \n   /* Traverse all PHI nodes in BB, updating live.  */\n-  for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n+  for (gphi_iterator si = gsi_start_phis (bb); !gsi_end_p (si);\n+       gsi_next (&si))\n     {\n       use_operand_p arg_p;\n       ssa_op_iter i;\n-      gimple phi = gsi_stmt (si);\n+      gphi *phi = si.phi ();\n       tree res = gimple_phi_result (phi);\n \n       if (virtual_operand_p (res))\n@@ -6216,10 +6217,10 @@ find_assert_locations (void)\n     {\n       i = loop->latch->index;\n       unsigned int j = single_succ_edge (loop->latch)->dest_idx;\n-      for (gimple_stmt_iterator gsi = gsi_start_phis (loop->header);\n+      for (gphi_iterator gsi = gsi_start_phis (loop->header);\n \t   !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple phi = gsi_stmt (gsi);\n+\t  gphi *phi = gsi.phi ();\n \t  if (virtual_operand_p (gimple_phi_result (phi)))\n \t    continue;\n \t  tree arg = gimple_phi_arg_def (phi, j);\n@@ -6971,11 +6972,10 @@ vrp_initialize (void)\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      gimple_stmt_iterator si;\n-\n-      for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n+      for (gphi_iterator si = gsi_start_phis (bb); !gsi_end_p (si);\n+\t   gsi_next (&si))\n \t{\n-\t  gimple phi = gsi_stmt (si);\n+\t  gphi *phi = si.phi ();\n \t  if (!stmt_interesting_for_vrp (phi))\n \t    {\n \t      tree lhs = PHI_RESULT (phi);\n@@ -6986,7 +6986,8 @@ vrp_initialize (void)\n \t    prop_set_simulate_again (phi, true);\n \t}\n \n-      for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+      for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n+\t   gsi_next (&si))\n         {\n \t  gimple stmt = gsi_stmt (si);\n \n@@ -7077,7 +7078,7 @@ vrp_visit_assignment_or_call (gimple stmt, tree *output_p)\n       else if (code == GIMPLE_CALL)\n \textract_range_basic (&new_vr, stmt);\n       else\n-\textract_range_from_assignment (&new_vr, stmt);\n+\textract_range_from_assignment (&new_vr, as_a <gassign *> (stmt));\n \n       if (update_value_range (lhs, &new_vr))\n \t{\n@@ -7478,7 +7479,7 @@ vrp_evaluate_conditional (enum tree_code code, tree op0, tree op1, gimple stmt)\n    SSA_PROP_VARYING.  */\n \n static enum ssa_prop_result\n-vrp_visit_cond_stmt (gimple stmt, edge *taken_edge_p)\n+vrp_visit_cond_stmt (gcond *stmt, edge *taken_edge_p)\n {\n   tree val;\n   bool sop;\n@@ -7593,7 +7594,7 @@ vrp_visit_cond_stmt (gimple stmt, edge *taken_edge_p)\n    returned. */\n \n static bool\n-find_case_label_index (gimple stmt, size_t start_idx, tree val, size_t *idx)\n+find_case_label_index (gswitch *stmt, size_t start_idx, tree val, size_t *idx)\n {\n   size_t n = gimple_switch_num_labels (stmt);\n   size_t low, high;\n@@ -7643,7 +7644,7 @@ find_case_label_index (gimple stmt, size_t start_idx, tree val, size_t *idx)\n    Returns true if the default label is not needed. */\n \n static bool\n-find_case_label_range (gimple stmt, tree min, tree max, size_t *min_idx,\n+find_case_label_range (gswitch *stmt, tree min, tree max, size_t *min_idx,\n \t\t       size_t *max_idx)\n {\n   size_t i, j;\n@@ -7699,7 +7700,7 @@ find_case_label_range (gimple stmt, tree min, tree max, size_t *min_idx,\n    Returns true if the default label is not needed.  */\n \n static bool\n-find_case_label_ranges (gimple stmt, value_range_t *vr, size_t *min_idx1,\n+find_case_label_ranges (gswitch *stmt, value_range_t *vr, size_t *min_idx1,\n \t\t\tsize_t *max_idx1, size_t *min_idx2,\n \t\t\tsize_t *max_idx2)\n {\n@@ -7777,7 +7778,7 @@ find_case_label_ranges (gimple stmt, value_range_t *vr, size_t *min_idx1,\n    SSA_PROP_VARYING.  */\n \n static enum ssa_prop_result\n-vrp_visit_switch_stmt (gimple stmt, edge *taken_edge_p)\n+vrp_visit_switch_stmt (gswitch *stmt, edge *taken_edge_p)\n {\n   tree op, val;\n   value_range_t *vr;\n@@ -7890,9 +7891,9 @@ vrp_visit_stmt (gimple stmt, edge *taken_edge_p, tree *output_p)\n   else if (is_gimple_assign (stmt) || is_gimple_call (stmt))\n     return vrp_visit_assignment_or_call (stmt, output_p);\n   else if (gimple_code (stmt) == GIMPLE_COND)\n-    return vrp_visit_cond_stmt (stmt, taken_edge_p);\n+    return vrp_visit_cond_stmt (as_a <gcond *> (stmt), taken_edge_p);\n   else if (gimple_code (stmt) == GIMPLE_SWITCH)\n-    return vrp_visit_switch_stmt (stmt, taken_edge_p);\n+    return vrp_visit_switch_stmt (as_a <gswitch *> (stmt), taken_edge_p);\n \n   /* All other statements produce nothing of interest for VRP, so mark\n      their outputs varying and prevent further simulation.  */\n@@ -8627,7 +8628,7 @@ vrp_meet (value_range_t *vr0, value_range_t *vr1)\n    value ranges, set a new range for the LHS of PHI.  */\n \n static enum ssa_prop_result\n-vrp_visit_phi_node (gimple phi)\n+vrp_visit_phi_node (gphi *phi)\n {\n   size_t i;\n   tree lhs = PHI_RESULT (phi);\n@@ -8884,7 +8885,8 @@ simplify_truth_ops_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n   else if (need_conversion)\n     {\n       tree tem = make_ssa_name (TREE_TYPE (op0), NULL);\n-      gimple newop = gimple_build_assign_with_ops (BIT_XOR_EXPR, tem, op0, op1);\n+      gassign *newop\n+\t= gimple_build_assign_with_ops (BIT_XOR_EXPR, tem, op0, op1);\n       gsi_insert_before (gsi, newop, GSI_SAME_STMT);\n       gimple_assign_set_rhs_with_ops (gsi, NOP_EXPR, tem);\n     }\n@@ -9232,7 +9234,7 @@ range_fits_type_p (value_range_t *vr, unsigned dest_precision, signop dest_sgn)\n    the original conditional.  */\n \n static bool\n-simplify_cond_using_ranges (gimple stmt)\n+simplify_cond_using_ranges (gcond *stmt)\n {\n   tree op0 = gimple_cond_lhs (stmt);\n   tree op1 = gimple_cond_rhs (stmt);\n@@ -9379,7 +9381,7 @@ simplify_cond_using_ranges (gimple stmt)\n    argument.  */\n \n static bool\n-simplify_switch_using_ranges (gimple stmt)\n+simplify_switch_using_ranges (gswitch *stmt)\n {\n   tree op = gimple_switch_index (stmt);\n   value_range_t *vr;\n@@ -9563,7 +9565,7 @@ simplify_float_conversion_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n   machine_mode fltmode = TYPE_MODE (TREE_TYPE (gimple_assign_lhs (stmt)));\n   machine_mode mode;\n   tree tem;\n-  gimple conv;\n+  gassign *conv;\n \n   /* We can only handle constant ranges.  */\n   if (vr->type != VR_RANGE\n@@ -9785,9 +9787,9 @@ simplify_stmt_using_ranges (gimple_stmt_iterator *gsi)\n \t}\n     }\n   else if (gimple_code (stmt) == GIMPLE_COND)\n-    return simplify_cond_using_ranges (stmt);\n+    return simplify_cond_using_ranges (as_a <gcond *> (stmt));\n   else if (gimple_code (stmt) == GIMPLE_SWITCH)\n-    return simplify_switch_using_ranges (stmt);\n+    return simplify_switch_using_ranges (as_a <gswitch *> (stmt));\n   else if (is_gimple_call (stmt)\n \t   && gimple_call_internal_p (stmt))\n     return simplify_internal_call_using_ranges (gsi, stmt);\n@@ -9815,10 +9817,10 @@ fold_predicate_in (gimple_stmt_iterator *si)\n \t\t\t\t      gimple_assign_rhs2 (stmt),\n \t\t\t\t      stmt);\n     }\n-  else if (gimple_code (stmt) == GIMPLE_COND)\n-    val = vrp_evaluate_conditional (gimple_cond_code (stmt),\n-\t\t\t\t    gimple_cond_lhs (stmt),\n-\t\t\t\t    gimple_cond_rhs (stmt),\n+  else if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n+    val = vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n+\t\t\t\t    gimple_cond_lhs (cond_stmt),\n+\t\t\t\t    gimple_cond_rhs (cond_stmt),\n \t\t\t\t    stmt);\n   else\n     return false;\n@@ -9842,10 +9844,11 @@ fold_predicate_in (gimple_stmt_iterator *si)\n       else\n \t{\n \t  gcc_assert (gimple_code (stmt) == GIMPLE_COND);\n+\t  gcond *cond_stmt = as_a <gcond *> (stmt);\n \t  if (integer_zerop (val))\n-\t    gimple_cond_make_false (stmt);\n+\t    gimple_cond_make_false (cond_stmt);\n \t  else if (integer_onep (val))\n-\t    gimple_cond_make_true (stmt);\n+\t    gimple_cond_make_true (cond_stmt);\n \t  else\n \t    gcc_unreachable ();\n \t}\n@@ -9882,21 +9885,22 @@ static vec<tree> equiv_stack;\n static tree\n simplify_stmt_for_jump_threading (gimple stmt, gimple within_stmt)\n {\n-  if (gimple_code (stmt) == GIMPLE_COND)\n-    return vrp_evaluate_conditional (gimple_cond_code (stmt),\n-\t\t\t\t     gimple_cond_lhs (stmt),\n-\t\t\t\t     gimple_cond_rhs (stmt), within_stmt);\n+  if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n+    return vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n+\t\t\t\t     gimple_cond_lhs (cond_stmt),\n+\t\t\t\t     gimple_cond_rhs (cond_stmt),\n+\t\t\t\t     within_stmt);\n \n-  if (gimple_code (stmt) == GIMPLE_ASSIGN)\n+  if (gassign *assign_stmt = dyn_cast <gassign *> (stmt))\n     {\n       value_range_t new_vr = VR_INITIALIZER;\n-      tree lhs = gimple_assign_lhs (stmt);\n+      tree lhs = gimple_assign_lhs (assign_stmt);\n \n       if (TREE_CODE (lhs) == SSA_NAME\n \t  && (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n \t      || POINTER_TYPE_P (TREE_TYPE (lhs))))\n \t{\n-\t  extract_range_from_assignment (&new_vr, stmt);\n+\t  extract_range_from_assignment (&new_vr, assign_stmt);\n \t  if (range_int_cst_singleton_p (&new_vr))\n \t    return new_vr.min;\n \t}\n@@ -9929,7 +9933,7 @@ static void\n identify_jump_threads (void)\n {\n   basic_block bb;\n-  gimple dummy;\n+  gcond *dummy;\n   int i;\n   edge e;\n "}, {"sha": "272b2a3c100936336ed6094eb094f94e60e00394", "filename": "gcc/tree.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -5538,12 +5538,13 @@ find_decls_types_in_node (struct cgraph_node *n, struct free_lang_data_d *fld)\n   /* Traverse every statement in FN.  */\n   FOR_EACH_BB_FN (bb, fn)\n     {\n+      gphi_iterator psi;\n       gimple_stmt_iterator si;\n       unsigned i;\n \n-      for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n+      for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n \t{\n-\t  gimple phi = gsi_stmt (si);\n+\t  gphi *phi = psi.phi ();\n \n \t  for (i = 0; i < gimple_phi_num_args (phi); i++)\n \t    {"}, {"sha": "5da0b180928864a594a2c4f45a3759a507638532", "filename": "gcc/ubsan.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -975,7 +975,7 @@ instrument_mem_ref (tree mem, tree base, gimple_stmt_iterator *iter,\n     ikind = UBSAN_MEMBER_ACCESS;\n   tree kind = build_int_cst (TREE_TYPE (t), ikind);\n   tree alignt = build_int_cst (pointer_sized_int_node, align);\n-  gimple g = gimple_build_call_internal (IFN_UBSAN_NULL, 3, t, kind, alignt);\n+  gcall *g = gimple_build_call_internal (IFN_UBSAN_NULL, 3, t, kind, alignt);\n   gimple_set_location (g, gimple_location (gsi_stmt (*iter)));\n   gsi_insert_before (iter, g, GSI_SAME_STMT);\n }\n@@ -1435,7 +1435,7 @@ instrument_nonnull_arg (gimple_stmt_iterator *gsi)\n static void\n instrument_nonnull_return (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  greturn *stmt = as_a <greturn *> (gsi_stmt (*gsi));\n   location_t loc[2];\n   tree arg = gimple_return_retval (stmt);\n   /* infer_nonnull_range needs flag_delete_null_pointer_checks set,"}, {"sha": "7aac67d35ab0453e30f2a88e20a290a68a112838", "filename": "gcc/value-prof.c", "status": "modified", "additions": 53, "deletions": 39, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -141,10 +141,11 @@ along with GCC; see the file COPYING3.  If not see\n      and gimple_value_profile_transformations table-driven, perhaps...\n */\n \n-static tree gimple_divmod_fixed_value (gimple, tree, int, gcov_type, gcov_type);\n-static tree gimple_mod_pow2 (gimple, int, gcov_type, gcov_type);\n-static tree gimple_mod_subtract (gimple, int, int, int, gcov_type, gcov_type,\n-\t\t\t\t gcov_type);\n+static tree gimple_divmod_fixed_value (gassign *, tree, int, gcov_type,\n+\t\t\t\t       gcov_type);\n+static tree gimple_mod_pow2 (gassign *, int, gcov_type, gcov_type);\n+static tree gimple_mod_subtract (gassign *, int, int, int, gcov_type,\n+\t\t\t\t gcov_type, gcov_type);\n static bool gimple_divmod_fixed_value_transform (gimple_stmt_iterator *);\n static bool gimple_mod_pow2_value_transform (gimple_stmt_iterator *);\n static bool gimple_mod_subtract_transform (gimple_stmt_iterator *);\n@@ -740,10 +741,11 @@ gimple_value_profile_transformations (void)\n    alter the original STMT.  */\n \n static tree\n-gimple_divmod_fixed_value (gimple stmt, tree value, int prob, gcov_type count,\n-\t\t\t   gcov_type all)\n+gimple_divmod_fixed_value (gassign *stmt, tree value, int prob,\n+\t\t\t   gcov_type count, gcov_type all)\n {\n-  gimple stmt1, stmt2, stmt3;\n+  gassign *stmt1, *stmt2;\n+  gcond *stmt3;\n   tree tmp0, tmp1, tmp2;\n   gimple bb1end, bb2end, bb3end;\n   basic_block bb, bb2, bb3, bb4;\n@@ -827,10 +829,10 @@ gimple_divmod_fixed_value_transform (gimple_stmt_iterator *si)\n   gcov_type val, count, all;\n   tree result, value, tree_val;\n   gcov_type prob;\n-  gimple stmt;\n+  gassign *stmt;\n \n-  stmt = gsi_stmt (*si);\n-  if (gimple_code (stmt) != GIMPLE_ASSIGN)\n+  stmt = dyn_cast <gassign *> (gsi_stmt (*si));\n+  if (!stmt)\n     return false;\n \n   if (!INTEGRAL_TYPE_P (TREE_TYPE (gimple_assign_lhs (stmt))))\n@@ -903,9 +905,10 @@ gimple_divmod_fixed_value_transform (gimple_stmt_iterator *si)\n    within roundoff error).  This generates the result into a temp and returns\n    the temp; it does not replace or alter the original STMT.  */\n static tree\n-gimple_mod_pow2 (gimple stmt, int prob, gcov_type count, gcov_type all)\n+gimple_mod_pow2 (gassign *stmt, int prob, gcov_type count, gcov_type all)\n {\n-  gimple stmt1, stmt2, stmt3, stmt4;\n+  gassign *stmt1, *stmt2, *stmt3;\n+  gcond *stmt4;\n   tree tmp2, tmp3;\n   gimple bb1end, bb2end, bb3end;\n   basic_block bb, bb2, bb3, bb4;\n@@ -989,10 +992,10 @@ gimple_mod_pow2_value_transform (gimple_stmt_iterator *si)\n   gcov_type count, wrong_values, all;\n   tree lhs_type, result, value;\n   gcov_type prob;\n-  gimple stmt;\n+  gassign *stmt;\n \n-  stmt = gsi_stmt (*si);\n-  if (gimple_code (stmt) != GIMPLE_ASSIGN)\n+  stmt = dyn_cast <gassign *> (gsi_stmt (*si));\n+  if (!stmt)\n     return false;\n \n   lhs_type = TREE_TYPE (gimple_assign_lhs (stmt));\n@@ -1055,10 +1058,12 @@ gimple_mod_pow2_value_transform (gimple_stmt_iterator *si)\n /* FIXME: Generalize the interface to handle NCOUNTS > 1.  */\n \n static tree\n-gimple_mod_subtract (gimple stmt, int prob1, int prob2, int ncounts,\n+gimple_mod_subtract (gassign *stmt, int prob1, int prob2, int ncounts,\n \t\t     gcov_type count1, gcov_type count2, gcov_type all)\n {\n-  gimple stmt1, stmt2, stmt3;\n+  gassign *stmt1;\n+  gimple stmt2;\n+  gcond *stmt3;\n   tree tmp1;\n   gimple bb1end, bb2end = NULL, bb3end;\n   basic_block bb, bb2, bb3, bb4;\n@@ -1161,10 +1166,10 @@ gimple_mod_subtract_transform (gimple_stmt_iterator *si)\n   gcov_type prob1, prob2;\n   unsigned int i, steps;\n   gcov_type count1, count2;\n-  gimple stmt;\n+  gassign *stmt;\n \n-  stmt = gsi_stmt (*si);\n-  if (gimple_code (stmt) != GIMPLE_ASSIGN)\n+  stmt = dyn_cast <gassign *> (gsi_stmt (*si));\n+  if (!stmt)\n     return false;\n \n   lhs_type = TREE_TYPE (gimple_assign_lhs (stmt));\n@@ -1357,7 +1362,7 @@ find_func_by_profile_id (int profile_id)\n    Returns true if TARGET is considered ok for call CALL_STMT.  */\n \n bool\n-check_ic_target (gimple call_stmt, struct cgraph_node *target)\n+check_ic_target (gcall *call_stmt, struct cgraph_node *target)\n {\n    location_t locus;\n    if (gimple_check_call_matching_types (call_stmt, target->decl, true))\n@@ -1379,11 +1384,14 @@ check_ic_target (gimple call_stmt, struct cgraph_node *target)\n     old call\n  */\n \n-gimple\n-gimple_ic (gimple icall_stmt, struct cgraph_node *direct_call,\n+gcall *\n+gimple_ic (gcall *icall_stmt, struct cgraph_node *direct_call,\n \t   int prob, gcov_type count, gcov_type all)\n {\n-  gimple dcall_stmt, load_stmt, cond_stmt, iretbnd_stmt = NULL;\n+  gcall *dcall_stmt;\n+  gassign *load_stmt;\n+  gcond *cond_stmt;\n+  gcall *iretbnd_stmt = NULL;\n   tree tmp0, tmp1, tmp;\n   basic_block cond_bb, dcall_bb, icall_bb, join_bb = NULL;\n   tree optype = build_pointer_type (void_type_node);\n@@ -1417,7 +1425,7 @@ gimple_ic (gimple icall_stmt, struct cgraph_node *direct_call,\n   gimple_set_vdef (icall_stmt, NULL_TREE);\n   gimple_set_vuse (icall_stmt, NULL_TREE);\n   update_stmt (icall_stmt);\n-  dcall_stmt = gimple_copy (icall_stmt);\n+  dcall_stmt = as_a <gcall *> (gimple_copy (icall_stmt));\n   gimple_call_set_fndecl (dcall_stmt, direct_call->decl);\n   dflags = flags_from_decl_or_type (direct_call->decl);\n   if ((dflags & ECF_NORETURN) != 0)\n@@ -1485,7 +1493,7 @@ gimple_ic (gimple icall_stmt, struct cgraph_node *direct_call,\n       && (dflags & ECF_NORETURN) == 0)\n     {\n       tree result = gimple_call_lhs (icall_stmt);\n-      gimple phi = create_phi_node (result, join_bb);\n+      gphi *phi = create_phi_node (result, join_bb);\n       gimple_call_set_lhs (icall_stmt,\n \t\t\t   duplicate_ssa_name (result, icall_stmt));\n       add_phi_arg (phi, gimple_call_lhs (icall_stmt), e_ij, UNKNOWN_LOCATION);\n@@ -1549,10 +1557,10 @@ gimple_ic (gimple icall_stmt, struct cgraph_node *direct_call,\n     if (e_eh->flags & (EDGE_EH | EDGE_ABNORMAL))\n       {\n \te = make_edge (dcall_bb, e_eh->dest, e_eh->flags);\n-\tfor (psi = gsi_start_phis (e_eh->dest);\n+\tfor (gphi_iterator psi = gsi_start_phis (e_eh->dest);\n \t     !gsi_end_p (psi); gsi_next (&psi))\n \t  {\n-\t    gimple phi = gsi_stmt (psi);\n+\t    gphi *phi = psi.phi ();\n \t    SET_USE (PHI_ARG_DEF_PTR_FROM_EDGE (phi, e),\n \t\t     PHI_ARG_DEF_FROM_EDGE (phi, e_eh));\n \t  }\n@@ -1569,12 +1577,13 @@ gimple_ic (gimple icall_stmt, struct cgraph_node *direct_call,\n static bool\n gimple_ic_transform (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gcall *stmt;\n   histogram_value histogram;\n   gcov_type val, count, all, bb_all;\n   struct cgraph_node *direct_call;\n \n-  if (gimple_code (stmt) != GIMPLE_CALL)\n+  stmt = dyn_cast <gcall *> (gsi_stmt (*gsi));\n+  if (!stmt)\n     return false;\n \n   if (gimple_call_fndecl (stmt) != NULL_TREE)\n@@ -1656,7 +1665,7 @@ gimple_ic_transform (gimple_stmt_iterator *gsi)\n    operation.\n */\n static bool\n-interesting_stringop_to_profile_p (tree fndecl, gimple call, int *size_arg)\n+interesting_stringop_to_profile_p (tree fndecl, gcall *call, int *size_arg)\n {\n   enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n \n@@ -1693,10 +1702,12 @@ interesting_stringop_to_profile_p (tree fndecl, gimple call, int *size_arg)\n    assuming we'll propagate a true constant into ICALL_SIZE later.  */\n \n static void\n-gimple_stringop_fixed_value (gimple vcall_stmt, tree icall_size, int prob,\n+gimple_stringop_fixed_value (gcall *vcall_stmt, tree icall_size, int prob,\n \t\t\t     gcov_type count, gcov_type all)\n {\n-  gimple tmp_stmt, cond_stmt, icall_stmt;\n+  gassign *tmp_stmt;\n+  gcond *cond_stmt;\n+  gcall *icall_stmt;\n   tree tmp0, tmp1, vcall_size, optype;\n   basic_block cond_bb, icall_bb, vcall_bb, join_bb;\n   edge e_ci, e_cv, e_iv, e_ij, e_vj;\n@@ -1728,7 +1739,7 @@ gimple_stringop_fixed_value (gimple vcall_stmt, tree icall_size, int prob,\n   gimple_set_vdef (vcall_stmt, NULL);\n   gimple_set_vuse (vcall_stmt, NULL);\n   update_stmt (vcall_stmt);\n-  icall_stmt = gimple_copy (vcall_stmt);\n+  icall_stmt = as_a <gcall *> (gimple_copy (vcall_stmt));\n   gimple_call_set_arg (icall_stmt, size_arg, icall_size);\n   gsi_insert_before (&gsi, icall_stmt, GSI_SAME_STMT);\n \n@@ -1768,7 +1779,7 @@ gimple_stringop_fixed_value (gimple vcall_stmt, tree icall_size, int prob,\n       && TREE_CODE (gimple_call_lhs (vcall_stmt)) == SSA_NAME)\n     {\n       tree result = gimple_call_lhs (vcall_stmt);\n-      gimple phi = create_phi_node (result, join_bb);\n+      gphi *phi = create_phi_node (result, join_bb);\n       gimple_call_set_lhs (vcall_stmt,\n \t\t\t   duplicate_ssa_name (result, vcall_stmt));\n       add_phi_arg (phi, gimple_call_lhs (vcall_stmt), e_vj, UNKNOWN_LOCATION);\n@@ -1787,7 +1798,7 @@ gimple_stringop_fixed_value (gimple vcall_stmt, tree icall_size, int prob,\n static bool\n gimple_stringops_transform (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gcall *stmt;\n   tree fndecl;\n   tree blck_size;\n   enum built_in_function fcode;\n@@ -1799,7 +1810,8 @@ gimple_stringops_transform (gimple_stmt_iterator *gsi)\n   tree tree_val;\n   int size_arg;\n \n-  if (gimple_code (stmt) != GIMPLE_CALL)\n+  stmt = dyn_cast <gcall *> (gsi_stmt (*gsi));\n+  if (!stmt)\n     return false;\n   fndecl = gimple_call_fndecl (stmt);\n   if (!fndecl)\n@@ -2016,14 +2028,16 @@ gimple_indirect_call_to_profile (gimple stmt, histogram_values *values)\n /* Find values inside STMT for that we want to measure histograms for\n    string operations.  */\n static void\n-gimple_stringops_values_to_profile (gimple stmt, histogram_values *values)\n+gimple_stringops_values_to_profile (gimple gs, histogram_values *values)\n {\n+  gcall *stmt;\n   tree fndecl;\n   tree blck_size;\n   tree dest;\n   int size_arg;\n \n-  if (gimple_code (stmt) != GIMPLE_CALL)\n+  stmt = dyn_cast <gcall *> (gs);\n+  if (!stmt)\n     return;\n   fndecl = gimple_call_fndecl (stmt);\n   if (!fndecl)"}, {"sha": "561e9bfbbb46ddad5e98b9338f18a753f4a7ab1b", "filename": "gcc/value-prof.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -92,8 +92,9 @@ void gimple_move_stmt_histograms (struct function *, gimple, gimple);\n void verify_histograms (void);\n void free_histograms (void);\n void stringop_block_profile (gimple, unsigned int *, HOST_WIDE_INT *);\n-gimple gimple_ic (gimple, struct cgraph_node *, int, gcov_type, gcov_type);\n-bool check_ic_target (gimple, struct cgraph_node *);\n+gcall *gimple_ic (gcall *, struct cgraph_node *, int, gcov_type,\n+\t\t  gcov_type);\n+bool check_ic_target (gcall *, struct cgraph_node *);\n \n \n /* In tree-profile.c.  */"}, {"sha": "c7105d5a89a2cd30b2a210d6694cfd4d64b6dd7c", "filename": "gcc/vtable-verify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fvtable-verify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538dd0b78f4b3998a1719a282811cb0caa1b035a/gcc%2Fvtable-verify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvtable-verify.c?ref=538dd0b78f4b3998a1719a282811cb0caa1b035a", "patch": "@@ -605,7 +605,7 @@ verify_bb_vtables (basic_block bb)\n           tree vtbl_var_decl = NULL_TREE;\n           struct vtbl_map_node *vtable_map_node;\n           tree vtbl_decl = NULL_TREE;\n-          gimple call_stmt;\n+          gcall *call_stmt;\n           const char *vtable_name = \"<unknown>\";\n           tree tmp0;\n           bool found;"}]}