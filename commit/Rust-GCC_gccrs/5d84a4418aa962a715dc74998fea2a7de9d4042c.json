{"sha": "5d84a4418aa962a715dc74998fea2a7de9d4042c", "node_id": "C_kwDOANBUbNoAKDVkODRhNDQxOGFhOTYyYTcxNWRjNzQ5OThmZWEyYTdkZTlkNDA0MmM", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-09-13T15:18:14Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-09-13T15:18:14Z"}, "message": "libstdc++: Implement ranges::chunk_view from P2442R1\n\nThis also implements the LWG 3707, 3710 and 3712 changes to chunk_view.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/ranges (__detail::__div_ceil): Define.\n\t(chunk_view): Define.\n\t(chunk_view::_OuterIter): Define.\n\t(chunk_view::_OuterIter::value_type): Define.\n\t(chunk_view::_InnerIter): Define.\n\t(chunk_view<_Vp>): Define partial specialization for forward\n\tranges.\n\t(enable_borrowed_range<chunk_view>): Define.\n\t(chunk_view<_Vp>::_Iterator): Define.\n\t(views::__detail::__can_chunk_view): Define.\n\t(views::_Chunk, views::chunk): Define.\n\t* testsuite/std/ranges/adaptors/chunk/1.cc: New test.", "tree": {"sha": "21f4236ced19c73ea6b92bc3600647ece899b334", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21f4236ced19c73ea6b92bc3600647ece899b334"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d84a4418aa962a715dc74998fea2a7de9d4042c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d84a4418aa962a715dc74998fea2a7de9d4042c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d84a4418aa962a715dc74998fea2a7de9d4042c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d84a4418aa962a715dc74998fea2a7de9d4042c/comments", "author": null, "committer": null, "parents": [{"sha": "7aa80c82ecf3a320faca276b22b4a4286bbebacf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7aa80c82ecf3a320faca276b22b4a4286bbebacf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7aa80c82ecf3a320faca276b22b4a4286bbebacf"}], "stats": {"total": 617, "additions": 617, "deletions": 0}, "files": [{"sha": "da235685ab43d0b5d0fea4a071e5957471e2dca3", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 537, "deletions": 0, "changes": 537, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d84a4418aa962a715dc74998fea2a7de9d4042c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d84a4418aa962a715dc74998fea2a7de9d4042c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=5d84a4418aa962a715dc74998fea2a7de9d4042c", "patch": "@@ -5776,6 +5776,543 @@ namespace views::__adaptor\n \n     inline constexpr auto pairwise_transform = adjacent_transform<2>;\n   }\n+\n+  namespace __detail\n+  {\n+    template<typename _Tp>\n+    constexpr _Tp __div_ceil(_Tp __num, _Tp __denom)\n+    {\n+      _Tp __r = __num / __denom;\n+      if (__num % __denom)\n+\t++__r;\n+      return __r;\n+    }\n+  }\n+\n+  template<view _Vp>\n+    requires input_range<_Vp>\n+  class chunk_view : public view_interface<chunk_view<_Vp>>\n+  {\n+    _Vp _M_base;\n+    range_difference_t<_Vp> _M_n;\n+    range_difference_t<_Vp> _M_remainder = 0;\n+    __detail::__non_propagating_cache<iterator_t<_Vp>> _M_current;\n+\n+    class _OuterIter;\n+    class _InnerIter;\n+\n+  public:\n+    constexpr explicit\n+    chunk_view(_Vp __base, range_difference_t<_Vp> __n)\n+      : _M_base(std::move(__base)), _M_n(__n)\n+    { __glibcxx_assert(__n >= 0); }\n+\n+    constexpr _Vp\n+    base() const & requires copy_constructible<_Vp>\n+    { return _M_base; }\n+\n+    constexpr _Vp\n+    base() &&\n+    { return std::move(_M_base); }\n+\n+    constexpr _OuterIter\n+    begin()\n+    {\n+      _M_current = ranges::begin(_M_base);\n+      _M_remainder = _M_n;\n+      return _OuterIter(*this);\n+    }\n+\n+    constexpr default_sentinel_t\n+    end() const noexcept\n+    { return default_sentinel; }\n+\n+    constexpr auto\n+    size() requires sized_range<_Vp>\n+    {\n+      return __detail::__to_unsigned_like(__detail::__div_ceil\n+\t\t\t\t\t  (ranges::distance(_M_base), _M_n));\n+    }\n+\n+    constexpr auto\n+    size() const requires sized_range<const _Vp>\n+    {\n+      return __detail::__to_unsigned_like(__detail::__div_ceil\n+\t\t\t\t\t  (ranges::distance(_M_base), _M_n));\n+    }\n+  };\n+\n+  template<typename _Range>\n+    chunk_view(_Range&&, range_difference_t<_Range>) -> chunk_view<views::all_t<_Range>>;\n+\n+  template<view _Vp>\n+    requires input_range<_Vp>\n+  class chunk_view<_Vp>::_OuterIter\n+  {\n+    chunk_view* _M_parent;\n+\n+    constexpr explicit\n+    _OuterIter(chunk_view& __parent) noexcept\n+      : _M_parent(std::__addressof(__parent))\n+    { }\n+\n+    friend chunk_view;\n+\n+  public:\n+    using iterator_concept = input_iterator_tag;\n+    using difference_type = range_difference_t<_Vp>;\n+\n+    struct value_type;\n+\n+    _OuterIter(_OuterIter&&) = default;\n+    _OuterIter& operator=(_OuterIter&&) = default;\n+\n+    constexpr value_type\n+    operator*() const\n+    {\n+      __glibcxx_assert(*this != default_sentinel);\n+      return value_type(*_M_parent);\n+    }\n+\n+    constexpr _OuterIter&\n+    operator++()\n+    {\n+      __glibcxx_assert(*this != default_sentinel);\n+      ranges::advance(*_M_parent->_M_current, _M_parent->_M_remainder,\n+\t\t      ranges::end(_M_parent->_M_base));\n+      _M_parent->_M_remainder = _M_parent->_M_n;\n+      return *this;\n+    }\n+\n+    constexpr void\n+    operator++(int)\n+    { ++*this; }\n+\n+    friend constexpr bool\n+    operator==(const _OuterIter& __x, default_sentinel_t)\n+    {\n+      return *__x._M_parent->_M_current == ranges::end(__x._M_parent->_M_base)\n+\t&& __x._M_parent->_M_remainder != 0;\n+    }\n+\n+    friend constexpr difference_type\n+    operator-(default_sentinel_t, const _OuterIter& __x)\n+    requires sized_sentinel_for<sentinel_t<_Vp>, iterator_t<_Vp>>\n+    {\n+      const auto __dist = ranges::end(__x._M_parent->_M_base) - *__x._M_parent->_M_current;\n+\n+      if (__dist < __x._M_parent->_M_remainder)\n+\treturn __dist == 0 ? 0 : 1;\n+\n+      return 1 + __detail::__div_ceil(__dist - __x._M_parent->_M_remainder,\n+\t\t\t\t      __x._M_parent->_M_n);\n+    }\n+\n+    friend constexpr difference_type\n+    operator-(const _OuterIter& __x, default_sentinel_t __y)\n+    requires sized_sentinel_for<sentinel_t<_Vp>, iterator_t<_Vp>>\n+    { return -(__y - __x); }\n+  };\n+\n+  template<view _Vp>\n+    requires input_range<_Vp>\n+  struct chunk_view<_Vp>::_OuterIter::value_type : view_interface<value_type>\n+  {\n+  private:\n+    chunk_view* _M_parent;\n+\n+    constexpr explicit\n+    value_type(chunk_view& __parent) noexcept\n+    : _M_parent(std::__addressof(__parent))\n+    { }\n+\n+    friend _OuterIter;\n+\n+  public:\n+    constexpr _InnerIter\n+    begin() const noexcept\n+    { return _InnerIter(*_M_parent); }\n+\n+    constexpr default_sentinel_t\n+    end() const noexcept\n+    { return default_sentinel; }\n+\n+    constexpr auto\n+    size() const\n+    requires sized_sentinel_for<sentinel_t<_Vp>, iterator_t<_Vp>>\n+    {\n+      return __detail::__to_unsigned_like\n+\t(ranges::min(_M_parent->_M_remainder,\n+\t\t     ranges::end(_M_parent->_M_base) - *_M_parent->_M_current));\n+    }\n+  };\n+\n+  template<view _Vp>\n+    requires input_range<_Vp>\n+  class chunk_view<_Vp>::_InnerIter\n+  {\n+    chunk_view* _M_parent;\n+\n+    constexpr explicit\n+    _InnerIter(chunk_view& __parent) noexcept\n+    : _M_parent(std::__addressof(__parent))\n+    { }\n+\n+    friend _OuterIter::value_type;\n+\n+  public:\n+    using iterator_concept = input_iterator_tag;\n+    using difference_type = range_difference_t<_Vp>;\n+    using value_type = range_value_t<_Vp>;\n+\n+    _InnerIter(_InnerIter&&) = default;\n+    _InnerIter& operator=(_InnerIter&&) = default;\n+\n+    constexpr const iterator_t<_Vp>&\n+    base() const &\n+    { return *_M_parent->_M_current; }\n+\n+    constexpr range_reference_t<_Vp>\n+    operator*() const\n+    {\n+      __glibcxx_assert(*this != default_sentinel);\n+      return **_M_parent->_M_current;\n+    }\n+\n+    constexpr _InnerIter&\n+    operator++()\n+    {\n+      __glibcxx_assert(*this != default_sentinel);\n+      ++*_M_parent->_M_current;\n+      if (*_M_parent->_M_current == ranges::end(_M_parent->_M_base))\n+\t_M_parent->_M_remainder = 0;\n+      else\n+\t--_M_parent->_M_remainder;\n+      return *this;\n+    }\n+\n+    constexpr void\n+    operator++(int)\n+    { ++*this; }\n+\n+    friend constexpr bool\n+    operator==(const _InnerIter& __x, default_sentinel_t) noexcept\n+    { return __x._M_parent->_M_remainder == 0; }\n+\n+    friend constexpr difference_type\n+    operator-(default_sentinel_t, const _InnerIter& __x)\n+      requires sized_sentinel_for<sentinel_t<_Vp>, iterator_t<_Vp>>\n+    {\n+      return ranges::min(__x._M_parent->_M_remainder,\n+\t\t\t ranges::end(__x._M_parent->_M_base) - *__x._M_parent->_M_current);\n+    }\n+\n+    friend constexpr difference_type\n+    operator-(const _InnerIter& __x, default_sentinel_t __y)\n+      requires sized_sentinel_for<sentinel_t<_Vp>, iterator_t<_Vp>>\n+    { return -(__y - __x); }\n+  };\n+\n+  template<view _Vp>\n+    requires forward_range<_Vp>\n+  class chunk_view<_Vp> : public view_interface<chunk_view<_Vp>>\n+  {\n+    _Vp _M_base;\n+    range_difference_t<_Vp> _M_n;\n+    template<bool> class _Iterator;\n+\n+  public:\n+    constexpr explicit\n+    chunk_view(_Vp __base, range_difference_t<_Vp> __n)\n+    : _M_base(std::move(__base)), _M_n(__n)\n+    { __glibcxx_assert(__n > 0); }\n+\n+    constexpr _Vp\n+    base() const & requires copy_constructible<_Vp>\n+    { return _M_base; }\n+\n+    constexpr _Vp\n+    base() &&\n+    { return std::move(_M_base); }\n+\n+    constexpr auto\n+    begin() requires (!__detail::__simple_view<_Vp>)\n+    { return _Iterator<false>(this, ranges::begin(_M_base)); }\n+\n+    constexpr auto\n+    begin() const requires forward_range<const _Vp>\n+    { return _Iterator<true>(this, ranges::begin(_M_base)); }\n+\n+    constexpr auto\n+    end() requires (!__detail::__simple_view<_Vp>)\n+    {\n+      if constexpr (common_range<_Vp> && sized_range<_Vp>)\n+\t{\n+\t  auto __missing = (_M_n - ranges::distance(_M_base) % _M_n) % _M_n;\n+\t  return _Iterator<false>(this, ranges::end(_M_base), __missing);\n+\t}\n+      else if constexpr (common_range<_Vp> && !bidirectional_range<_Vp>)\n+\treturn _Iterator<false>(this, ranges::end(_M_base));\n+      else\n+\treturn default_sentinel;\n+    }\n+\n+    constexpr auto\n+    end() const requires forward_range<const _Vp>\n+    {\n+      if constexpr (common_range<const _Vp> && sized_range<const _Vp>)\n+\t{\n+\t  auto __missing = (_M_n - ranges::distance(_M_base) % _M_n) % _M_n;\n+\t  return _Iterator<true>(this, ranges::end(_M_base), __missing);\n+\t}\n+      else if constexpr (common_range<const _Vp> && !bidirectional_range<const _Vp>)\n+\treturn _Iterator<true>(this, ranges::end(_M_base));\n+      else\n+\treturn default_sentinel;\n+    }\n+\n+    constexpr auto\n+    size() requires sized_range<_Vp>\n+    {\n+      return __detail::__to_unsigned_like(__detail::__div_ceil\n+\t\t\t\t\t  (ranges::distance(_M_base), _M_n));\n+    }\n+\n+    constexpr auto\n+    size() const requires sized_range<const _Vp>\n+    {\n+      return __detail::__to_unsigned_like(__detail::__div_ceil\n+\t\t\t\t\t  (ranges::distance(_M_base), _M_n));\n+    }\n+  };\n+\n+  template<typename _Vp>\n+    inline constexpr bool enable_borrowed_range<chunk_view<_Vp>>\n+      = forward_range<_Vp> && enable_borrowed_range<_Vp>;\n+\n+  template<view _Vp>\n+    requires forward_range<_Vp>\n+  template<bool _Const>\n+  class chunk_view<_Vp>::_Iterator\n+  {\n+    using _Parent = __detail::__maybe_const_t<_Const, chunk_view>;\n+    using _Base = __detail::__maybe_const_t<_Const, _Vp>;\n+\n+    iterator_t<_Base> _M_current = iterator_t<_Base>();\n+    sentinel_t<_Base> _M_end = sentinel_t<_Base>();\n+    range_difference_t<_Base> _M_n = 0;\n+    range_difference_t<_Base> _M_missing = 0;\n+\n+    constexpr\n+    _Iterator(_Parent* __parent, iterator_t<_Base> __current,\n+\t      range_difference_t<_Base> __missing = 0)\n+    : _M_current(__current), _M_end(ranges::end(__parent->_M_base)),\n+      _M_n(__parent->_M_n), _M_missing(__missing)\n+    { }\n+\n+    static auto\n+    _S_iter_cat()\n+    {\n+      if constexpr (random_access_range<_Base>)\n+\treturn random_access_iterator_tag{};\n+      else if constexpr (bidirectional_range<_Base>)\n+\treturn bidirectional_iterator_tag{};\n+      else\n+\treturn forward_iterator_tag{};\n+    }\n+\n+    friend chunk_view;\n+\n+  public:\n+    using iterator_category = input_iterator_tag;\n+    using iterator_concept = decltype(_S_iter_cat());\n+    using value_type = decltype(views::take(subrange(_M_current, _M_end), _M_n));\n+    using difference_type = range_difference_t<_Base>;\n+\n+    _Iterator() = default;\n+\n+    constexpr _Iterator(_Iterator<!_Const> __i)\n+      requires _Const\n+\t&& convertible_to<iterator_t<_Vp>, iterator_t<_Base>>\n+\t&& convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>\n+    : _M_current(std::move(__i._M_current)), _M_end(std::move(__i._M_end)),\n+      _M_n(__i._M_n), _M_missing(__i._M_missing)\n+    { }\n+\n+    constexpr iterator_t<_Base>\n+    base() const\n+    { return _M_current; }\n+\n+    constexpr value_type\n+    operator*() const\n+    {\n+      __glibcxx_assert(_M_current != _M_end);\n+      return views::take(subrange(_M_current, _M_end), _M_n);\n+    }\n+\n+    constexpr _Iterator&\n+    operator++()\n+    {\n+      __glibcxx_assert(_M_current != _M_end);\n+      _M_missing = ranges::advance(_M_current, _M_n, _M_end);\n+      return *this;\n+    }\n+\n+    constexpr _Iterator\n+    operator++(int)\n+    {\n+      auto __tmp = *this;\n+      ++*this;\n+      return __tmp;\n+    }\n+\n+    constexpr _Iterator&\n+    operator--() requires bidirectional_range<_Base>\n+    {\n+      ranges::advance(_M_current, _M_missing - _M_n);\n+      _M_missing = 0;\n+      return *this;\n+    }\n+\n+    constexpr _Iterator\n+    operator--(int) requires bidirectional_range<_Base>\n+    {\n+      auto __tmp = *this;\n+      --*this;\n+      return __tmp;\n+    }\n+\n+    constexpr _Iterator&\n+    operator+=(difference_type __x)\n+      requires random_access_range<_Base>\n+    {\n+      if (__x > 0)\n+\t{\n+\t  __glibcxx_assert(ranges::distance(_M_current, _M_end) > _M_n * (__x - 1));\n+\t  _M_missing = ranges::advance(_M_current, _M_n * __x, _M_end);\n+\t}\n+      else if (__x < 0)\n+\t{\n+\t  ranges::advance(_M_current, _M_n * __x + _M_missing);\n+\t  _M_missing = 0;\n+\t}\n+      return *this;\n+    }\n+\n+    constexpr _Iterator&\n+    operator-=(difference_type __x)\n+      requires random_access_range<_Base>\n+    { return *this += -__x; }\n+\n+    constexpr value_type\n+    operator[](difference_type __n) const\n+      requires random_access_range<_Base>\n+    { return *(*this + __n); }\n+\n+    friend constexpr bool\n+    operator==(const _Iterator& __x, const _Iterator& __y)\n+    { return __x._M_current == __y._M_current; }\n+\n+    friend constexpr bool\n+    operator==(const _Iterator& __x, default_sentinel_t)\n+    { return __x._M_current == __x._M_end; }\n+\n+    friend constexpr bool\n+    operator<(const _Iterator& __x, const _Iterator& __y)\n+      requires random_access_range<_Base>\n+    { return __x._M_current > __y._M_current; }\n+\n+    friend constexpr bool\n+    operator>(const _Iterator& __x, const _Iterator& __y)\n+      requires random_access_range<_Base>\n+    { return __y < __x; }\n+\n+    friend constexpr bool\n+    operator<=(const _Iterator& __x, const _Iterator& __y)\n+      requires random_access_range<_Base>\n+    { return !(__y < __x); }\n+\n+    friend constexpr bool\n+    operator>=(const _Iterator& __x, const _Iterator& __y)\n+      requires random_access_range<_Base>\n+    { return !(__x < __y); }\n+\n+    friend constexpr auto\n+    operator<=>(const _Iterator& __x, const _Iterator& __y)\n+      requires random_access_range<_Base>\n+\t&& three_way_comparable<iterator_t<_Base>>\n+    { return __x._M_current <=> __y._M_current; }\n+\n+    friend constexpr _Iterator\n+    operator+(const _Iterator& __i, difference_type __n)\n+      requires random_access_range<_Base>\n+    {\n+      auto __r  = __i;\n+      __r += __n;\n+      return __r;\n+    }\n+\n+    friend constexpr _Iterator\n+    operator+(difference_type __n, const _Iterator& __i)\n+      requires random_access_range<_Base>\n+    {\n+      auto __r  = __i;\n+      __r += __n;\n+      return __r;\n+    }\n+\n+    friend constexpr _Iterator\n+    operator-(const _Iterator& __i, difference_type __n)\n+      requires random_access_range<_Base>\n+    {\n+      auto __r  = __i;\n+      __r -= __n;\n+      return __r;\n+    }\n+\n+    friend constexpr difference_type\n+    operator-(const _Iterator& __x, const _Iterator& __y)\n+      requires sized_sentinel_for<iterator_t<_Base>, iterator_t<_Base>>\n+    {\n+      return (__x._M_current - __y._M_current\n+\t      + __x._M_missing - __y._M_missing) / __x._M_n;\n+    }\n+\n+    friend constexpr difference_type\n+    operator-(default_sentinel_t __y, const _Iterator& __x)\n+      requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base>>\n+    { return __detail::__div_ceil(__x._M_end - __x._M_current, __x._M_n); }\n+\n+    friend constexpr difference_type\n+    operator-(const _Iterator& __x, default_sentinel_t __y)\n+      requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base>>\n+    { return -(__y - __x); }\n+  };\n+\n+  namespace views\n+  {\n+    namespace __detail\n+    {\n+      template<typename _Range, typename _Dp>\n+\tconcept __can_chunk_view\n+\t  = requires { chunk_view(std::declval<_Range>(), std::declval<_Dp>()); };\n+    }\n+\n+    struct _Chunk : __adaptor::_RangeAdaptor<_Chunk>\n+    {\n+      template<viewable_range _Range, typename _Dp = range_difference_t<_Range>>\n+\trequires __detail::__can_chunk_view<_Range, _Dp>\n+\tconstexpr auto\n+\toperator() [[nodiscard]] (_Range&& __r, type_identity_t<_Dp> __n) const\n+\t{ return chunk_view(std::forward<_Range>(__r), __n); }\n+\n+      using __adaptor::_RangeAdaptor<_Chunk>::operator();\n+      static constexpr int _S_arity = 2;\n+      static constexpr bool _S_has_simple_extra_args = true;\n+    };\n+\n+    inline constexpr _Chunk chunk;\n+  }\n #endif // C++23\n } // namespace ranges\n "}, {"sha": "125c88ef853d284694e44baf939981f5cfe98f58", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/chunk/1.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d84a4418aa962a715dc74998fea2a7de9d4042c/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fchunk%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d84a4418aa962a715dc74998fea2a7de9d4042c/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fchunk%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fchunk%2F1.cc?ref=5d84a4418aa962a715dc74998fea2a7de9d4042c", "patch": "@@ -0,0 +1,80 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <ranges>\n+#include <algorithm>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+namespace ranges = std::ranges;\n+namespace views = std::views;\n+\n+constexpr bool\n+test01()\n+{\n+  int x[] = {1, 2, 3, 4, 5};\n+\n+  auto v2 = x | views::chunk(2);\n+  const auto i0 = v2.begin(), i1 = v2.begin() + 1;\n+  VERIFY( i0 + 1 - 1 == i0 );\n+  VERIFY( i0 < i1 );\n+  VERIFY( i1 < v2.end() );\n+  VERIFY( i1 - i0 == 1 );\n+  VERIFY( i0 - i1 == -1 );\n+  VERIFY( v2.end() - i1 == 2 );\n+  VERIFY( i1 - v2.end() == -2 );\n+  auto i2 = v2.begin();\n+  i2 += 2;\n+  i2 -= -1;\n+  VERIFY( i2 == v2.end() );\n+  VERIFY( ranges::size(v2) == 3 );\n+  VERIFY( ranges::equal(v2, (std::initializer_list<int>[]){{1, 2}, {3, 4}, {5}},\n+\t\t\tranges::equal) );\n+\n+  auto v1 = x | views::chunk(1);\n+  VERIFY( ranges::size(v1) == ranges::size(x) );\n+  for (auto [r, n] : views::zip(v1, x))\n+    {\n+      VERIFY( ranges::size(r) == 1 );\n+      VERIFY( *r.begin() == n );\n+    }\n+\n+  auto v5 = x | views::chunk(5);\n+  VERIFY( ranges::size(v5) == 1 );\n+  VERIFY( ranges::equal(v5[0], (int[]){1, 2, 3, 4, 5}) );\n+\n+  auto v10 = x | views::chunk(10);\n+  VERIFY( ranges::size(v10) == 1 );\n+  VERIFY( ranges::equal(v10[0], (int[]){1, 2, 3, 4, 5}) );\n+\n+  return true;\n+}\n+\n+template<class wrapper>\n+void\n+test02()\n+{\n+  int x[] = {1, 2, 3, 4, 5, 6, 7, 8};\n+  wrapper rx(x);\n+  auto v = rx | views::chunk(3);\n+  auto i = ranges::begin(v);\n+  VERIFY( ranges::equal(*i, (int[]){1, 2, 3}) );\n+  ++i;\n+  VERIFY( ranges::equal(*i, (int[]){4, 5, 6}) );\n+  ++i;\n+  VERIFY( ranges::equal(*i, (int[]){7, 8}) );\n+  i++;\n+  VERIFY( i == ranges::end(v) );\n+\n+  for (int i = 1; i <= 10; ++i)\n+    VERIFY( ranges::equal(wrapper(x) | views::chunk(i) | views::join, x) );\n+}\n+\n+int\n+main()\n+{\n+  static_assert(test01());\n+  test02<__gnu_test::test_input_range<int>>();\n+  test02<__gnu_test::test_forward_range<int>>();\n+}"}]}