{"sha": "df3e34938d9b38a0906a8ebf491f8b73bda5346d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGYzZTM0OTM4ZDliMzhhMDkwNmE4ZWJmNDkxZjhiNzNiZGE1MzQ2ZA==", "commit": {"author": {"name": "Kito Cheng", "email": "kito@0xlab.org", "date": "2014-10-14T19:13:33Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2014-10-14T19:13:33Z"}, "message": "ira.c: Fix typo in comment.\n\n2014-10-14  Kito Cheng  <kito@0xlab.org>\n\n\t* ira.c: Fix typo in comment.\n\t* ira.h: Ditto.\n\t* ira-build.c: Ditto.\n\t* ira-color.c: Ditto.\n\t* ira-emit.c: Ditto.\n\t* ira-int.h: Ditto.\n\t* ira-lives.c: Ditto.\n\nFrom-SVN: r216218", "tree": {"sha": "10902165f66caa8f4abfc0ec1654c35a18946479", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10902165f66caa8f4abfc0ec1654c35a18946479"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df3e34938d9b38a0906a8ebf491f8b73bda5346d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df3e34938d9b38a0906a8ebf491f8b73bda5346d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df3e34938d9b38a0906a8ebf491f8b73bda5346d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df3e34938d9b38a0906a8ebf491f8b73bda5346d/comments", "author": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0777fc02105dd9067329ed9ccfe341a9fb90fdc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0777fc02105dd9067329ed9ccfe341a9fb90fdc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0777fc02105dd9067329ed9ccfe341a9fb90fdc2"}], "stats": {"total": 66, "additions": 38, "deletions": 28}, "files": [{"sha": "dc93b4c4af3c0c9153ac3a1108a49a10873234e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e34938d9b38a0906a8ebf491f8b73bda5346d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e34938d9b38a0906a8ebf491f8b73bda5346d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df3e34938d9b38a0906a8ebf491f8b73bda5346d", "patch": "@@ -1,3 +1,13 @@\n+2014-10-14  Kito Cheng  <kito@0xlab.org>\n+\n+\t* ira.c: Fix typo in comment.\n+\t* ira.h: Ditto.\n+\t* ira-build.c: Ditto.\n+\t* ira-color.c: Ditto.\n+\t* ira-emit.c: Ditto.\n+\t* ira-int.h: Ditto.\n+\t* ira-lives.c: Ditto.\n+\n 2014-10-14  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR rtl-optimization/63475"}, {"sha": "98df8cd35a8d4c93f50f12862617d7c31e981147", "filename": "gcc/ira-build.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e34938d9b38a0906a8ebf491f8b73bda5346d/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e34938d9b38a0906a8ebf491f8b73bda5346d/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=df3e34938d9b38a0906a8ebf491f8b73bda5346d", "patch": "@@ -1224,7 +1224,7 @@ ira_create_pref (ira_allocno_t a, int hard_regno, int freq)\n   return pref;\n }\n \n-/* Attach a pref PREF to the cooresponding allocno.  */\n+/* Attach a pref PREF to the corresponding allocno.  */\n static void\n add_allocno_pref_to_list (ira_pref_t pref)\n {"}, {"sha": "c8e8f9a9d135a84ebbbb146f02fa94a06c555f94", "filename": "gcc/ira-color.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e34938d9b38a0906a8ebf491f8b73bda5346d/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e34938d9b38a0906a8ebf491f8b73bda5346d/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=df3e34938d9b38a0906a8ebf491f8b73bda5346d", "patch": "@@ -104,7 +104,7 @@ struct update_cost_record\n struct allocno_color_data\n {\n   /* TRUE value means that the allocno was not removed yet from the\n-     conflicting graph during colouring.  */\n+     conflicting graph during coloring.  */\n   unsigned int in_graph_p : 1;\n   /* TRUE if it is put on the stack to make other allocnos\n      colorable.  */\n@@ -1203,7 +1203,7 @@ struct update_cost_queue_elem\n      connecting this allocno to the one being allocated.  */\n   int divisor;\n \n-  /* Allocno from which we are chaning costs of connected allocnos.\n+  /* Allocno from which we are chaining costs of connected allocnos.\n      It is used not go back in graph of allocnos connected by\n      copies.  */\n   ira_allocno_t from;\n@@ -1928,7 +1928,7 @@ copy_freq_compare_func (const void *v1p, const void *v2p)\n   if (pri2 - pri1)\n     return pri2 - pri1;\n \n-  /* If freqencies are equal, sort by copies, so that the results of\n+  /* If frequencies are equal, sort by copies, so that the results of\n      qsort leave nothing to chance.  */\n   return cp1->num - cp2->num;\n }\n@@ -1983,7 +1983,7 @@ merge_threads (ira_allocno_t t1, ira_allocno_t t2)\n   ALLOCNO_COLOR_DATA (t1)->thread_freq += ALLOCNO_COLOR_DATA (t2)->thread_freq;\n }\n \n-/* Create threads by processing CP_NUM copies from sorted)ciopeis.  We\n+/* Create threads by processing CP_NUM copies from sorted copies.  We\n    process the most expensive copies first.  */\n static void\n form_threads_from_copies (int cp_num)\n@@ -3608,7 +3608,7 @@ conflict_by_live_ranges_p (int regno1, int regno2)\n \n   ira_assert (regno1 >= FIRST_PSEUDO_REGISTER\n \t      && regno2 >= FIRST_PSEUDO_REGISTER);\n-  /* Reg info caclulated by dataflow infrastructure can be different\n+  /* Reg info calculated by dataflow infrastructure can be different\n      from one calculated by regclass.  */\n   if ((a1 = ira_loop_tree_root->regno_allocno_map[regno1]) == NULL\n       || (a2 = ira_loop_tree_root->regno_allocno_map[regno2]) == NULL)"}, {"sha": "0a930deec95f7d74eb968c44cf37d6776f83218b", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e34938d9b38a0906a8ebf491f8b73bda5346d/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e34938d9b38a0906a8ebf491f8b73bda5346d/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=df3e34938d9b38a0906a8ebf491f8b73bda5346d", "patch": "@@ -118,7 +118,7 @@ struct cost_classes\n   /* Container of the cost classes.  */\n   enum reg_class classes[N_REG_CLASSES];\n   /* Map reg class -> index of the reg class in the previous array.\n-     -1 if it is not a cost classe.  */\n+     -1 if it is not a cost class.  */\n   int index[N_REG_CLASSES];\n   /* Map hard regno index of first class in array CLASSES containing\n      the hard regno, -1 otherwise.  */\n@@ -277,7 +277,7 @@ setup_regno_cost_classes_by_aclass (int regno, enum reg_class aclass)\n    decrease number of cost classes for the pseudo, if hard registers\n    of some important classes can not hold a value of MODE.  So the\n    pseudo can not get hard register of some important classes and cost\n-   calculation for such important classes is only waisting CPU\n+   calculation for such important classes is only wasting CPU\n    time.  */\n static void\n setup_regno_cost_classes_by_mode (int regno, enum machine_mode mode)\n@@ -314,7 +314,7 @@ setup_regno_cost_classes_by_mode (int regno, enum machine_mode mode)\n   regno_cost_classes[regno] = classes_ptr;\n }\n \n-/* Finilize info about the cost classes for each pseudo.  */\n+/* Finalize info about the cost classes for each pseudo.  */\n static void\n finish_regno_cost_classes (void)\n {\n@@ -1238,7 +1238,7 @@ record_operand_costs (rtx_insn *insn, enum reg_class *pref)\n      then we may want to adjust the cost of that register class to -1.\n \n      Avoid the adjustment if the source does not die to avoid\n-     stressing of register allocator by preferrencing two colliding\n+     stressing of register allocator by preferencing two colliding\n      registers into single class.\n \n      Also avoid the adjustment if a copy between hard registers of the"}, {"sha": "53612348e300f2b98fb701ca4bd506f1ed16abb9", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e34938d9b38a0906a8ebf491f8b73bda5346d/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e34938d9b38a0906a8ebf491f8b73bda5346d/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=df3e34938d9b38a0906a8ebf491f8b73bda5346d", "patch": "@@ -777,7 +777,7 @@ modify_move_list (move_t list)\n \n   if (list == NULL)\n     return NULL;\n-  /* Creat move deps.  */\n+  /* Create move deps.  */\n   curr_tick++;\n   for (move = list; move != NULL; move = move->next)\n     {\n@@ -812,7 +812,7 @@ modify_move_list (move_t list)\n \t  move->deps_num = n;\n \t}\n     }\n-  /* Toplogical sorting:  */\n+  /* Topological sorting:  */\n   move_vec.truncate (0);\n   for (move = list; move != NULL; move = move->next)\n     traverse_moves (move);"}, {"sha": "ec42638abd1eaaa087771de794e3f25fd681319a", "filename": "gcc/ira-int.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e34938d9b38a0906a8ebf491f8b73bda5346d/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e34938d9b38a0906a8ebf491f8b73bda5346d/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=df3e34938d9b38a0906a8ebf491f8b73bda5346d", "patch": "@@ -531,7 +531,7 @@ extern ira_object_t *ira_object_id_map;\n /* The size of the previous array.  */\n extern int ira_objects_num;\n \n-/* The following structure represents a hard register prefererence of\n+/* The following structure represents a hard register preference of\n    allocno.  The preference represent move insns or potential move\n    insns usually because of two operand insn constraints.  One move\n    operand is a hard register.  */\n@@ -546,7 +546,7 @@ struct ira_allocno_pref\n   int freq;\n   /* Given allocno.  */\n   ira_allocno_t allocno;\n-  /* All prefernces with the same allocno are linked by the following\n+  /* All preferences with the same allocno are linked by the following\n      member.  */\n   ira_pref_t next_pref;\n };"}, {"sha": "1d410538d16388c40a91d5f2b8952375ba18e511", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e34938d9b38a0906a8ebf491f8b73bda5346d/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e34938d9b38a0906a8ebf491f8b73bda5346d/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=df3e34938d9b38a0906a8ebf491f8b73bda5346d", "patch": "@@ -1227,7 +1227,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t\t  sparseset_set_bit (allocnos_processed, num);\n \n \t\t  if (allocno_saved_at_call[num] != last_call_num)\n-\t\t    /* Here we are mimicking caller-save.c behaviour\n+\t\t    /* Here we are mimicking caller-save.c behavior\n \t\t       which does not save hard register at a call if\n \t\t       it was saved on previous call in the same basic\n \t\t       block and the hard register was not mentioned"}, {"sha": "aac1fad74f8c25eaa79655f8eeed7da68506bb87", "filename": "gcc/ira.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e34938d9b38a0906a8ebf491f8b73bda5346d/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e34938d9b38a0906a8ebf491f8b73bda5346d/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=df3e34938d9b38a0906a8ebf491f8b73bda5346d", "patch": "@@ -153,7 +153,7 @@ along with GCC; see the file COPYING3.  If not see\n          calculates its initial (non-accumulated) cost of memory and\n          each hard-register of its allocno class (file ira-cost.c).\n \n-       * IRA creates live ranges of each allocno, calulates register\n+       * IRA creates live ranges of each allocno, calculates register\n          pressure for each pressure class in each region, sets up\n          conflict hard registers for each allocno and info about calls\n          the allocno lives through (file ira-lives.c).\n@@ -245,7 +245,7 @@ along with GCC; see the file COPYING3.  If not see\n          hard-register for allocnos conflicting with given allocno.\n \n        * Chaitin-Briggs coloring assigns as many pseudos as possible\n-         to hard registers.  After coloringh we try to improve\n+         to hard registers.  After coloring we try to improve\n          allocation with cost point of view.  We improve the\n          allocation by spilling some allocnos and assigning the freed\n          hard registers to other allocnos if it decreases the overall\n@@ -307,7 +307,7 @@ along with GCC; see the file COPYING3.  If not see\n        rebuilding would be, but is much faster.\n \n      o After IR flattening, IRA tries to assign hard registers to all\n-       spilled allocnos.  This is impelemented by a simple and fast\n+       spilled allocnos.  This is implemented by a simple and fast\n        priority coloring algorithm (see function\n        ira_reassign_conflict_allocnos::ira-color.c).  Here new allocnos\n        created during the code change pass can be assigned to hard\n@@ -328,7 +328,7 @@ along with GCC; see the file COPYING3.  If not see\n          in places where the pseudo-register lives.\n \n    IRA uses a lot of data representing the target processors.  These\n-   data are initilized in file ira.c.\n+   data are initialized in file ira.c.\n \n    If function has no loops (or the loops are ignored when\n    -fira-algorithm=CB is used), we have classic Chaitin-Briggs\n@@ -898,7 +898,7 @@ setup_pressure_classes (void)\n \t  IOR_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n       }\n     for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-      /* Some targets (like SPARC with ICC reg) have alocatable regs\n+      /* Some targets (like SPARC with ICC reg) have allocatable regs\n \t for which no reg class is defined.  */\n       if (REGNO_REG_CLASS (i) == NO_REGS)\n \tSET_HARD_REG_BIT (ignore_hard_regs, i);\n@@ -959,7 +959,7 @@ setup_uniform_class_p (void)\n /* Set up IRA_ALLOCNO_CLASSES, IRA_ALLOCNO_CLASSES_NUM,\n    IRA_IMPORTANT_CLASSES, and IRA_IMPORTANT_CLASSES_NUM.\n \n-   Target may have many subtargets and not all target hard regiters can\n+   Target may have many subtargets and not all target hard registers can\n    be used for allocation, e.g. x86 port in 32-bit mode can not use\n    hard registers introduced in x86-64 like r8-r15).  Some classes\n    might have the same allocatable hard registers, e.g.  INDEX_REGS\n@@ -1019,7 +1019,7 @@ setup_allocno_and_important_classes (void)\n   classes[n] = LIM_REG_CLASSES;\n \n   /* Set up classes which can be used for allocnos as classes\n-     conatining non-empty unique sets of allocatable hard\n+     containing non-empty unique sets of allocatable hard\n      registers.  */\n   ira_allocno_classes_num = 0;\n   for (i = 0; (cl = classes[i]) != LIM_REG_CLASSES; i++)\n@@ -1313,7 +1313,7 @@ setup_reg_class_relations (void)\n \t      if (important_class_p[cl3]\n \t\t  && hard_reg_set_subset_p (temp_hard_regset, union_set))\n \t\t{\n-\t\t  /* CL3 allocatbale hard register set is inside of\n+\t\t  /* CL3 allocatable hard register set is inside of\n \t\t     union of allocatable hard register sets of CL1\n \t\t     and CL2.  */\n \t\t  COPY_HARD_REG_SET\n@@ -1366,7 +1366,7 @@ setup_reg_class_relations (void)\n     }\n }\n \n-/* Output all unifrom and important classes into file F.  */\n+/* Output all uniform and important classes into file F.  */\n static void\n print_unform_and_important_classes (FILE *f)\n {\n@@ -2774,7 +2774,7 @@ setup_preferred_alternate_classes_for_new_pseudos (int start)\n }\n \n \f\n-/* The number of entries allocated in teg_info.  */\n+/* The number of entries allocated in reg_info.  */\n static int allocated_reg_info_size;\n \n /* Regional allocation can create new pseudo-registers.  This function\n@@ -3349,7 +3349,7 @@ update_equiv_regs (void)\n   init_alias_analysis ();\n \n   /* Scan insns and set pdx_subregs[regno] if the reg is used in a\n-     paradoxical subreg. Don't set such reg sequivalent to a mem,\n+     paradoxical subreg. Don't set such reg equivalent to a mem,\n      because lra will not substitute such equiv memory in order to\n      prevent access beyond allocated memory for paradoxical memory subreg.  */\n   FOR_EACH_BB_FN (bb, cfun)\n@@ -4776,7 +4776,7 @@ interesting_dest_for_shprep_1 (rtx set, basic_block call_dom)\n   return dest;\n }\n \n-/* If insn is interesting for parameter range-splitting shring-wrapping\n+/* If insn is interesting for parameter range-splitting shrink-wrapping\n    preparation, i.e. it is a single set from a hard register to a pseudo, which\n    is live at CALL_DOM (if non-NULL, otherwise this check is omitted), or a\n    parallel statement with only one such statement, return the destination."}, {"sha": "a6c067dae5485ed6a6e20f7c777c8c277a7c1de2", "filename": "gcc/ira.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e34938d9b38a0906a8ebf491f8b73bda5346d/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e34938d9b38a0906a8ebf491f8b73bda5346d/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=df3e34938d9b38a0906a8ebf491f8b73bda5346d", "patch": "@@ -64,7 +64,7 @@ struct target_ira\n      class.  */\n   enum reg_class x_ira_pressure_class_translate[N_REG_CLASSES];\n \n-  /* Bigest pressure register class containing stack registers.\n+  /* Biggest pressure register class containing stack registers.\n      NO_REGS if there are no stack registers.  */\n   enum reg_class x_ira_stack_reg_pressure_class;\n "}]}