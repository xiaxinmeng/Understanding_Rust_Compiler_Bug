{"sha": "03c00798828246afcfd998988c9fee8321b9313c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNjMDA3OTg4MjgyNDZhZmNmZDk5ODk4OGM5ZmVlODMyMWI5MzEzYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-12-04T11:57:15Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-12-04T11:57:15Z"}, "message": "re PR middle-end/65958 (-fstack-check breaks alloca on architectures using generic stack checking)\n\n\tPR middle-end/65958\n\t* gimplify.c (struct gimplify_ctx): Turn boolean fields into 1-bit\n\tfields, add keep_stack and reorder them.\n\t(gimplify_bind_expr): Save gimplify_ctxp->keep_stack on entry then\n\tset it to false.  Do not insert a stack save/restore pair if it has\n\tbeen set to true by the gimplification of the statements.\n\tRestore it to the saved value on exit if it is still false.\n\t(gimplify_vla_decl): Do not set gimplify_ctxp->save_stack here.\n\t(gimplify_call_expr) <BUILT_IN_ALLOCA[_WITH_ALIGN]>: New case.  Set\n\teither save_stack or keep_stack depending on CALL_ALLOCA_FOR_VAR_P.\n\t* doc/extend.texi (Variable Length): Document new behavior.\n\t* doc/generic.texi (Blocks): Document new handling of VLAs.\n\nFrom-SVN: r231260", "tree": {"sha": "d944ebe798474d59975ae0092d6818956e8aeba8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d944ebe798474d59975ae0092d6818956e8aeba8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03c00798828246afcfd998988c9fee8321b9313c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03c00798828246afcfd998988c9fee8321b9313c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03c00798828246afcfd998988c9fee8321b9313c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03c00798828246afcfd998988c9fee8321b9313c/comments", "author": null, "committer": null, "parents": [{"sha": "a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3"}], "stats": {"total": 106, "additions": 88, "deletions": 18}, "files": [{"sha": "cfc56586f2c800dd84924e35517cf4d910c4d0c3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c00798828246afcfd998988c9fee8321b9313c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c00798828246afcfd998988c9fee8321b9313c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03c00798828246afcfd998988c9fee8321b9313c", "patch": "@@ -1,3 +1,18 @@\n+2015-12-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR middle-end/65958\n+\t* gimplify.c (struct gimplify_ctx): Turn boolean fields into 1-bit\n+\tfields, add keep_stack and reorder them.\n+\t(gimplify_bind_expr): Save gimplify_ctxp->keep_stack on entry then\n+\tset it to false.  Do not insert a stack save/restore pair if it has\n+\tbeen set to true by the gimplification of the statements.\n+\tRestore it to the saved value on exit if it is still false.\n+\t(gimplify_vla_decl): Do not set gimplify_ctxp->save_stack here.\n+\t(gimplify_call_expr) <BUILT_IN_ALLOCA[_WITH_ALIGN]>: New case.  Set\n+\teither save_stack or keep_stack depending on CALL_ALLOCA_FOR_VAR_P.\n+\t* doc/extend.texi (Variable Length): Document new behavior.\n+\t* doc/generic.texi (Blocks): Document new handling of VLAs.\n+\n 2015-12-04  Eric Botcazou  <ebotcazou@adacore.com>\n             Tristan Gingold  <gingold@adacore.com>\n "}, {"sha": "6a5e2b86f780e3d9de8dc64cffae13c41a792125", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c00798828246afcfd998988c9fee8321b9313c/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c00798828246afcfd998988c9fee8321b9313c/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=03c00798828246afcfd998988c9fee8321b9313c", "patch": "@@ -1658,9 +1658,7 @@ variable-length arrays are more elegant.\n There are other differences between these two methods.  Space allocated\n with @code{alloca} exists until the containing @emph{function} returns.\n The space for a variable-length array is deallocated as soon as the array\n-name's scope ends.  (If you use both variable-length arrays and\n-@code{alloca} in the same function, deallocation of a variable-length array\n-also deallocates anything more recently allocated with @code{alloca}.)\n+name's scope ends, unless you also use @code{alloca} in this scope.\n \n You can also use variable-length arrays as arguments to functions:\n "}, {"sha": "f6b43977c368256929f61e74859acd562fd6c571", "filename": "gcc/doc/generic.texi", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c00798828246afcfd998988c9fee8321b9313c/gcc%2Fdoc%2Fgeneric.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c00798828246afcfd998988c9fee8321b9313c/gcc%2Fdoc%2Fgeneric.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgeneric.texi?ref=03c00798828246afcfd998988c9fee8321b9313c", "patch": "@@ -1950,11 +1950,15 @@ this initialization replaces the @code{DECL_STMT}.  These variables\n will never require cleanups.  The scope of these variables is just the\n body\n \n-Variable-length arrays (VLAs) complicate this process, as their\n-size often refers to variables initialized earlier in the block.\n-To handle this, we currently split the block at that point, and\n-move the VLA into a new, inner @code{BIND_EXPR}.  This strategy\n-may change in the future.\n+Variable-length arrays (VLAs) complicate this process, as their size\n+often refers to variables initialized earlier in the block and their\n+initialization involves an explicit stack allocation.  To handle this,\n+we add an indirection and replace them with a pointer to stack space\n+allocated by means of @code{alloca}.  In most cases, we also arrange\n+for this space to be reclaimed when the enclosing @code{BIND_EXPR} is\n+exited, the exception to this being when there is an explicit call to\n+@code{alloca} in the source code, in which case the stack is left\n+depressed on exit of the @code{BIND_EXPR}.\n \n A C++ program will usually contain more @code{BIND_EXPR}s than\n there are syntactic blocks in the source code, since several C++"}, {"sha": "80c6bf2b90f5668f3f9bfe5547819f67886d79e8", "filename": "gcc/gimplify.c", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c00798828246afcfd998988c9fee8321b9313c/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c00798828246afcfd998988c9fee8321b9313c/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=03c00798828246afcfd998988c9fee8321b9313c", "patch": "@@ -155,10 +155,11 @@ struct gimplify_ctx\n   hash_table<gimplify_hasher> *temp_htab;\n \n   int conditions;\n-  bool save_stack;\n-  bool into_ssa;\n-  bool allow_rhs_cond_expr;\n-  bool in_cleanup_point_expr;\n+  unsigned into_ssa : 1;\n+  unsigned allow_rhs_cond_expr : 1;\n+  unsigned in_cleanup_point_expr : 1;\n+  unsigned keep_stack : 1;\n+  unsigned save_stack : 1;\n };\n \n struct gimplify_omp_ctx\n@@ -1080,6 +1081,7 @@ static enum gimplify_status\n gimplify_bind_expr (tree *expr_p, gimple_seq *pre_p)\n {\n   tree bind_expr = *expr_p;\n+  bool old_keep_stack = gimplify_ctxp->keep_stack;\n   bool old_save_stack = gimplify_ctxp->save_stack;\n   tree t;\n   gbind *bind_stmt;\n@@ -1129,9 +1131,10 @@ gimplify_bind_expr (tree *expr_p, gimple_seq *pre_p)\n     }\n \n   bind_stmt = gimple_build_bind (BIND_EXPR_VARS (bind_expr), NULL,\n-                                   BIND_EXPR_BLOCK (bind_expr));\n+\t\t\t\t BIND_EXPR_BLOCK (bind_expr));\n   gimple_push_bind_expr (bind_stmt);\n \n+  gimplify_ctxp->keep_stack = false;\n   gimplify_ctxp->save_stack = false;\n \n   /* Gimplify the body into the GIMPLE_BIND tuple's body.  */\n@@ -1154,7 +1157,10 @@ gimplify_bind_expr (tree *expr_p, gimple_seq *pre_p)\n \n   cleanup = NULL;\n   stack_save = NULL;\n-  if (gimplify_ctxp->save_stack)\n+\n+  /* If the code both contains VLAs and calls alloca, then we cannot reclaim\n+     the stack space allocated to the VLAs.  */\n+  if (gimplify_ctxp->save_stack && !gimplify_ctxp->keep_stack)\n     {\n       gcall *stack_restore;\n \n@@ -1236,7 +1242,11 @@ gimplify_bind_expr (tree *expr_p, gimple_seq *pre_p)\n       gimple_bind_set_body (bind_stmt, new_body);\n     }\n \n+  /* keep_stack propagates all the way up to the outermost BIND_EXPR.  */\n+  if (!gimplify_ctxp->keep_stack)\n+    gimplify_ctxp->keep_stack = old_keep_stack;\n   gimplify_ctxp->save_stack = old_save_stack;\n+\n   gimple_pop_bind_expr ();\n \n   gimplify_seq_add_stmt (pre_p, bind_stmt);\n@@ -1393,10 +1403,6 @@ gimplify_vla_decl (tree decl, gimple_seq *seq_p)\n   t = build2 (MODIFY_EXPR, TREE_TYPE (addr), addr, t);\n \n   gimplify_and_add (t, seq_p);\n-\n-  /* Indicate that we need to restore the stack level when the\n-     enclosing BIND_EXPR is exited.  */\n-  gimplify_ctxp->save_stack = true;\n }\n \n /* A helper function to be called via walk_tree.  Mark all labels under *TP\n@@ -2377,6 +2383,18 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n       && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n     switch (DECL_FUNCTION_CODE (fndecl))\n       {\n+      case BUILT_IN_ALLOCA:\n+      case BUILT_IN_ALLOCA_WITH_ALIGN:\n+\t/* If the call has been built for a variable-sized object, then we\n+\t   want to restore the stack level when the enclosing BIND_EXPR is\n+\t   exited to reclaim the allocated space; otherwise, we precisely\n+\t   need to do the opposite and preserve the latest stack level.  */\n+\tif (CALL_ALLOCA_FOR_VAR_P (*expr_p))\n+\t  gimplify_ctxp->save_stack = true;\n+\telse\n+\t  gimplify_ctxp->keep_stack = true;\n+\tbreak;\n+\n       case BUILT_IN_VA_START:\n         {\n \t  builtin_va_start_p = TRUE;"}, {"sha": "2944394d67a80cc5911ad813e3d454cc943c81b1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c00798828246afcfd998988c9fee8321b9313c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c00798828246afcfd998988c9fee8321b9313c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=03c00798828246afcfd998988c9fee8321b9313c", "patch": "@@ -1,3 +1,7 @@\n+2015-12-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.dg/vla-24.c: New test.\n+\n 2015-12-04  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc.target/aarch64/stack-checking.c: New test."}, {"sha": "5bd5fed262e38b3687411909aee7af5408d5ccdf", "filename": "gcc/testsuite/gcc.dg/vla-24.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c00798828246afcfd998988c9fee8321b9313c/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c00798828246afcfd998988c9fee8321b9313c/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-24.c?ref=03c00798828246afcfd998988c9fee8321b9313c", "patch": "@@ -0,0 +1,31 @@\n+/* PR middle-end/65958 */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+extern void abort (void);\n+\n+int foo (int n)\n+{\n+  char *p, *q;\n+\n+  if (1)\n+    {\n+      char i[n];\n+      p = __builtin_alloca (8);\n+      p[0] = 1;\n+    }\n+\n+  q = __builtin_alloca (64);\n+  __builtin_memset (q, 0, 64);\n+\n+  return !p[0];\n+}\n+\n+int main (void)\n+{\n+  if (foo (48) != 0)\n+    abort ();\n+\n+  return 0;\n+}"}]}