{"sha": "55e78c8cf92151e9395ff9cfe91277b58f7fc1d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVlNzhjOGNmOTIxNTFlOTM5NWZmOWNmZTkxMjc3YjU4ZjdmYzFkMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2010-07-12T18:53:33Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2010-07-12T18:53:33Z"}, "message": "regs.h (target_regs): Add x_hard_regs_of_mode...\n\ngcc/\n\t* regs.h (target_regs): Add x_hard_regs_of_mode, x_contains_reg_of_mode,\n\tx_move_cost, x_may_move_in_cost, x_may_move_out_cost and\n\tx_last_mode_for_init_move_cost.\n\t(have_regs_of_mode, contains_reg_of_mode, move_cost)\n\t(may_move_in_cost, may_move_out_cost): Redefine as macros.\n\t* reginfo.c (have_regs_of_mode, contains_reg_of_mode, move_cost)\n\t(may_move_in_cost, may_move_out_cost): Delete.\n\t(last_mode_for_init_move_cost): Redefine as a macro.\n\nFrom-SVN: r162090", "tree": {"sha": "191314ba26394a131d04588253375bac451eef17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/191314ba26394a131d04588253375bac451eef17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55e78c8cf92151e9395ff9cfe91277b58f7fc1d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55e78c8cf92151e9395ff9cfe91277b58f7fc1d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55e78c8cf92151e9395ff9cfe91277b58f7fc1d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55e78c8cf92151e9395ff9cfe91277b58f7fc1d0/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6642445b2caf5917b0aa341ab998b01796310751", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6642445b2caf5917b0aa341ab998b01796310751", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6642445b2caf5917b0aa341ab998b01796310751"}], "stats": {"total": 85, "additions": 45, "deletions": 40}, "files": [{"sha": "36f4ea62ea247f14fa1481bb1beede4e93e7d9e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e78c8cf92151e9395ff9cfe91277b58f7fc1d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e78c8cf92151e9395ff9cfe91277b58f7fc1d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=55e78c8cf92151e9395ff9cfe91277b58f7fc1d0", "patch": "@@ -1,3 +1,14 @@\n+2010-07-12  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* regs.h (target_regs): Add x_hard_regs_of_mode, x_contains_reg_of_mode,\n+\tx_move_cost, x_may_move_in_cost, x_may_move_out_cost and\n+\tx_last_mode_for_init_move_cost.\n+\t(have_regs_of_mode, contains_reg_of_mode, move_cost)\n+\t(may_move_in_cost, may_move_out_cost): Redefine as macros.\n+\t* reginfo.c (have_regs_of_mode, contains_reg_of_mode, move_cost)\n+\t(may_move_in_cost, may_move_out_cost): Delete.\n+\t(last_mode_for_init_move_cost): Redefine as a macro.\n+\n 2010-07-12  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* hard-reg-set.h (target_hard_regs): New structure."}, {"sha": "f17084c46ef58d97daf2a7ce69e37496958a3742", "filename": "gcc/reginfo.c", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e78c8cf92151e9395ff9cfe91277b58f7fc1d0/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e78c8cf92151e9395ff9cfe91277b58f7fc1d0/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=55e78c8cf92151e9395ff9cfe91277b58f7fc1d0", "patch": "@@ -118,26 +118,8 @@ static const char *const initial_reg_names[] = REGISTER_NAMES;\n /* Array containing all of the register class names.  */\n const char * reg_class_names[] = REG_CLASS_NAMES;\n \n-/* 1 if there is a register of given mode.  */\n-bool have_regs_of_mode [MAX_MACHINE_MODE];\n-\n-/* 1 if class does contain register of given mode.  */\n-char contains_reg_of_mode [N_REG_CLASSES] [MAX_MACHINE_MODE];\n-\n-/* Maximum cost of moving from a register in one class to a register in\n-   another class.  Based on TARGET_REGISTER_MOVE_COST.  */\n-move_table *move_cost[MAX_MACHINE_MODE];\n-\n-/* Similar, but here we don't have to move if the first index is a subset\n-   of the second so in that case the cost is zero.  */\n-move_table *may_move_in_cost[MAX_MACHINE_MODE];\n-\n-/* Similar, but here we don't have to move if the first index is a superset\n-   of the second so in that case the cost is zero.  */\n-move_table *may_move_out_cost[MAX_MACHINE_MODE];\n-\n-/* Keep track of the last mode we initialized move costs for.  */\n-static int last_mode_for_init_move_cost;\n+#define last_mode_for_init_move_cost \\\n+  (this_target_regs->x_last_mode_for_init_move_cost)\n \n /* Sample MEM values for use by memory_move_secondary_cost.  */\n static GTY(()) rtx top_of_stack[MAX_MACHINE_MODE];"}, {"sha": "ac23ae62fc95c2c2f47cb0d3525295d8a430f415", "filename": "gcc/regs.h", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e78c8cf92151e9395ff9cfe91277b58f7fc1d0/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e78c8cf92151e9395ff9cfe91277b58f7fc1d0/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=55e78c8cf92151e9395ff9cfe91277b58f7fc1d0", "patch": "@@ -214,10 +214,6 @@ extern size_t reg_info_p_size;\n \n extern short *reg_renumber;\n \n-/* Vector indexed by machine mode saying whether there are regs of that mode.  */\n-\n-extern bool have_regs_of_mode [MAX_MACHINE_MODE];\n-\n /* Flag set by local-alloc or global-alloc if they decide to allocate\n    something in a call-clobbered register.  */\n \n@@ -249,24 +245,8 @@ extern int caller_save_needed;\n #define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE) 0\n #endif\n \n-/* 1 if the corresponding class does contain register of given\n-   mode.  */\n-extern char contains_reg_of_mode [N_REG_CLASSES] [MAX_MACHINE_MODE];\n-\n typedef unsigned short move_table[N_REG_CLASSES];\n \n-/* Maximum cost of moving from a register in one class to a register\n-   in another class.  */\n-extern move_table *move_cost[MAX_MACHINE_MODE];\n-\n-/* Similar, but here we don't have to move if the first index is a\n-   subset of the second so in that case the cost is zero.  */\n-extern move_table *may_move_in_cost[MAX_MACHINE_MODE];\n-\n-/* Similar, but here we don't have to move if the first index is a\n-   superset of the second so in that case the cost is zero.  */\n-extern move_table *may_move_out_cost[MAX_MACHINE_MODE];\n-\n /* Target-dependent globals.  */\n struct target_regs {\n   /* For each starting hard register, the number of consecutive hard\n@@ -278,6 +258,28 @@ struct target_regs {\n      it will be a MODE_FLOAT or a MODE_CC mode, whichever is valid for the\n      register.  */\n   enum machine_mode x_reg_raw_mode[FIRST_PSEUDO_REGISTER];\n+\n+  /* Vector indexed by machine mode saying whether there are regs of\n+     that mode.  */\n+  bool x_have_regs_of_mode[MAX_MACHINE_MODE];\n+\n+  /* 1 if the corresponding class contains a register of the given mode.  */\n+  char x_contains_reg_of_mode[N_REG_CLASSES][MAX_MACHINE_MODE];\n+\n+  /* Maximum cost of moving from a register in one class to a register\n+     in another class.  Based on TARGET_REGISTER_MOVE_COST.  */\n+  move_table *x_move_cost[MAX_MACHINE_MODE];\n+\n+  /* Similar, but here we don't have to move if the first index is a\n+     subset of the second so in that case the cost is zero.  */\n+  move_table *x_may_move_in_cost[MAX_MACHINE_MODE];\n+\n+  /* Similar, but here we don't have to move if the first index is a\n+     superset of the second so in that case the cost is zero.  */\n+  move_table *x_may_move_out_cost[MAX_MACHINE_MODE];\n+\n+  /* Keep track of the last mode we initialized move costs for.  */\n+  int x_last_mode_for_init_move_cost;\n };\n \n extern struct target_regs default_target_regs;\n@@ -291,6 +293,16 @@ extern struct target_regs *this_target_regs;\n   (this_target_regs->x_hard_regno_nregs)\n #define reg_raw_mode \\\n   (this_target_regs->x_reg_raw_mode)\n+#define have_regs_of_mode \\\n+  (this_target_regs->x_have_regs_of_mode)\n+#define contains_reg_of_mode \\\n+  (this_target_regs->x_contains_reg_of_mode)\n+#define move_cost \\\n+  (this_target_regs->x_move_cost)\n+#define may_move_in_cost \\\n+  (this_target_regs->x_may_move_in_cost)\n+#define may_move_out_cost \\\n+  (this_target_regs->x_may_move_out_cost)\n \n /* Return an exclusive upper bound on the registers occupied by hard\n    register (reg:MODE REGNO).  */"}]}