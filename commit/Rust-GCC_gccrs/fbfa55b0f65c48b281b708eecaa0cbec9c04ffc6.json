{"sha": "fbfa55b0f65c48b281b708eecaa0cbec9c04ffc6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJmYTU1YjBmNjVjNDhiMjgxYjcwOGVlY2FhMGNiZWM5YzA0ZmZjNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-03-18T05:09:55Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-03-18T05:09:55Z"}, "message": "dwarf2out.c (queue_reg_save): New.\n\n        * dwarf2out.c (queue_reg_save): New.\n        (flush_queued_reg_saves, clobbers_queued_reg_save): New.\n        (dwarf2out_frame_debug_expr): Call queue_reg_save instead of\n        dwarf2out_reg_save.\n        (dwarf2out_frame_debug): Call flush_queued_reg_saves when needed.\n        (cfa, cfa_store, cfa_temp): Make static.\n        * final.c (final_scan_insn): Always call dwarf2out_frame_debug.\n\nFrom-SVN: r40594", "tree": {"sha": "fa5628ade1ad651230550f737966340e18c83f7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa5628ade1ad651230550f737966340e18c83f7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbfa55b0f65c48b281b708eecaa0cbec9c04ffc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbfa55b0f65c48b281b708eecaa0cbec9c04ffc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbfa55b0f65c48b281b708eecaa0cbec9c04ffc6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbfa55b0f65c48b281b708eecaa0cbec9c04ffc6/comments", "author": null, "committer": null, "parents": [{"sha": "9de8be0b19b5e0f3ad37e6f56ee241293889f41a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9de8be0b19b5e0f3ad37e6f56ee241293889f41a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9de8be0b19b5e0f3ad37e6f56ee241293889f41a"}], "stats": {"total": 121, "additions": 95, "deletions": 26}, "files": [{"sha": "a6b8f5868701adc005bf15b6bccbeadcb60dbcbb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbfa55b0f65c48b281b708eecaa0cbec9c04ffc6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbfa55b0f65c48b281b708eecaa0cbec9c04ffc6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fbfa55b0f65c48b281b708eecaa0cbec9c04ffc6", "patch": "@@ -1,3 +1,13 @@\n+2001-03-17  Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2out.c (queue_reg_save): New.\n+\t(flush_queued_reg_saves, clobbers_queued_reg_save): New.\n+\t(dwarf2out_frame_debug_expr): Call queue_reg_save instead of\n+\tdwarf2out_reg_save.\n+\t(dwarf2out_frame_debug): Call flush_queued_reg_saves when needed.\n+\t(cfa, cfa_store, cfa_temp): Make static.\n+\t* final.c (final_scan_insn): Always call dwarf2out_frame_debug.\n+\n 2001-03-17  Richard Henderson  <rth@redhat.com>\n \n \t* integrate.h (struct inline_remap): Add local_return_label."}, {"sha": "f791538aa5f72a2c2f4e885aabf9a184a2530d6e", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 76, "deletions": 6, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbfa55b0f65c48b281b708eecaa0cbec9c04ffc6/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbfa55b0f65c48b281b708eecaa0cbec9c04ffc6/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=fbfa55b0f65c48b281b708eecaa0cbec9c04ffc6", "patch": "@@ -241,6 +241,9 @@ static long stack_adjust_offset\t\tPARAMS ((rtx));\n static void output_cfi\t\t\tPARAMS ((dw_cfi_ref, dw_fde_ref));\n static void output_call_frame_info\tPARAMS ((int));\n static void dwarf2out_stack_adjust\tPARAMS ((rtx));\n+static void queue_reg_save\t\tPARAMS ((const char *, rtx, long));\n+static void flush_queued_reg_saves\tPARAMS ((void));\n+static bool clobbers_queued_reg_save\tPARAMS ((rtx));\n static void dwarf2out_frame_debug_expr\tPARAMS ((rtx, const char *));\n \n /* Support for complex CFA locations.  */\n@@ -594,11 +597,11 @@ lookup_cfa (loc)\n }\n \n /* The current rule for calculating the DWARF2 canonical frame address.  */\n-dw_cfa_location cfa;\n+static dw_cfa_location cfa;\n \n /* The register used for saving registers to the stack, and its offset\n    from the CFA.  */\n-dw_cfa_location cfa_store;\n+static dw_cfa_location cfa_store;\n \n /* The running total of the size of arguments pushed onto the stack.  */\n static long args_size;\n@@ -1020,10 +1023,70 @@ dwarf2out_stack_adjust (insn)\n   dwarf2out_args_size (label, args_size);\n }\n \n+/* We delay emitting a register save until either (a) we reach the end\n+   of the prologue or (b) the register is clobbered.  This clusters\n+   register saves so that there are fewer pc advances.  */\n+\n+struct queued_reg_save\n+{\n+  struct queued_reg_save *next;\n+  rtx reg;\n+  long cfa_offset;\n+};\n+\n+static struct queued_reg_save *queued_reg_saves;\n+static const char *last_reg_save_label;\n+\n+static void\n+queue_reg_save (label, reg, offset)\n+     const char *label;\n+     rtx reg;\n+     long offset;\n+{\n+  struct queued_reg_save *q = (struct queued_reg_save *) xmalloc (sizeof (*q));\n+\n+  q->next = queued_reg_saves;\n+  q->reg = reg;\n+  q->cfa_offset = offset;\n+  queued_reg_saves = q;\n+\n+  last_reg_save_label = label;\n+}\n+\n+static void\n+flush_queued_reg_saves ()\n+{\n+  struct queued_reg_save *q, *next;\n+\n+  for (q = queued_reg_saves; q ; q = next)\n+    {\n+      dwarf2out_reg_save (last_reg_save_label, REGNO (q->reg), q->cfa_offset);\n+      next = q->next;\n+      free (q);\n+    }\n+\n+  queued_reg_saves = NULL;\n+  last_reg_save_label = NULL;\n+}\n+\n+static bool\n+clobbers_queued_reg_save (insn)\n+     rtx insn;\n+{\n+  struct queued_reg_save *q;\n+\n+  for (q = queued_reg_saves; q ; q = q->next)\n+    if (modified_in_p (q->reg, insn))\n+      return true;\n+\n+  return false;\n+}\n+  \n+\n /* A temporary register holding an integral value used in adjusting SP\n    or setting up the store_reg.  The \"offset\" field holds the integer\n    value, not an offset.  */\n-dw_cfa_location cfa_temp;\n+static dw_cfa_location cfa_temp;\n \n /* Record call frame debugging information for an expression EXPR,\n    which either sets SP or FP (adjusting how we calculate the frame\n@@ -1440,7 +1503,7 @@ dwarf2out_frame_debug_expr (expr, label)\n \t\t on the ARM.  */\n \n \t      def_cfa_1 (label, &cfa);\n-\t      dwarf2out_reg_save (label, STACK_POINTER_REGNUM, offset);\n+\t      queue_reg_save (label, stack_pointer_rtx, offset);\n \t      break;\n \t    }\n \t  else\n@@ -1462,7 +1525,7 @@ dwarf2out_frame_debug_expr (expr, label)\n \t}\n \n       def_cfa_1 (label, &cfa);\n-      dwarf2out_reg_save (label, REGNO (src), offset);\n+      queue_reg_save (label, src, offset);\n       break;\n \n     default:\n@@ -1483,6 +1546,9 @@ dwarf2out_frame_debug (insn)\n \n   if (insn == NULL_RTX)\n     {\n+      /* Flush any queued register saves.  */\n+      flush_queued_reg_saves ();\n+\n       /* Set up state for generating call frame debug info.  */\n       lookup_cfa (&cfa);\n       if (cfa.reg != (unsigned long) DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM))\n@@ -1494,9 +1560,13 @@ dwarf2out_frame_debug (insn)\n       return;\n     }\n \n+  if (GET_CODE (insn) != INSN || clobbers_queued_reg_save (insn))\n+    flush_queued_reg_saves ();\n+\n   if (! RTX_FRAME_RELATED_P (insn))\n     {\n-      dwarf2out_stack_adjust (insn);\n+      if (!ACCUMULATE_OUTGOING_ARGS)\n+        dwarf2out_stack_adjust (insn);\n       return;\n     }\n "}, {"sha": "2e3b40d78789ba007582f78df5b2214abd0ed805", "filename": "gcc/final.c", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbfa55b0f65c48b281b708eecaa0cbec9c04ffc6/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbfa55b0f65c48b281b708eecaa0cbec9c04ffc6/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=fbfa55b0f65c48b281b708eecaa0cbec9c04ffc6", "patch": "@@ -2324,9 +2324,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \n     case BARRIER:\n #if defined (DWARF2_UNWIND_INFO)\n-      /* If we push arguments, we need to check all insns for stack\n-\t adjustments.  */\n-      if (!ACCUMULATE_OUTGOING_ARGS && dwarf2out_do_frame ())\n+      if (dwarf2out_do_frame ())\n \tdwarf2out_frame_debug (insn);\n #endif\n       break;\n@@ -2936,9 +2934,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \tcurrent_output_insn = debug_insn = insn;\n \n #if defined (DWARF2_UNWIND_INFO)\n-\t/* If we push arguments, we want to know where the calls are.  */\n-\tif (!ACCUMULATE_OUTGOING_ARGS && GET_CODE (insn) == CALL_INSN\n-\t    && dwarf2out_do_frame ())\n+\tif (GET_CODE (insn) == CALL_INSN && dwarf2out_do_frame ())\n \t  dwarf2out_frame_debug (insn);\n #endif\n \n@@ -3006,22 +3002,15 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \toutput_asm_insn (template, recog_data.operand);\n \n #if defined (DWARF2_UNWIND_INFO)\n-\t/* If we push arguments, we need to check all insns for stack\n-\t   adjustments.  */\n-\tif (!ACCUMULATE_OUTGOING_ARGS)\n-\t  {\n-\t    if (GET_CODE (insn) == INSN && dwarf2out_do_frame ())\n-\t      dwarf2out_frame_debug (insn);\n-\t  }\n-\telse\n-\t  {\n #if defined (HAVE_prologue)\n-\t    /* If this insn is part of the prologue, emit DWARF v2\n-\t       call frame info.  */\n-\t    if (RTX_FRAME_RELATED_P (insn) && dwarf2out_do_frame ())\n-\t      dwarf2out_frame_debug (insn);\n+\tif (GET_CODE (insn) == INSN && dwarf2out_do_frame ())\n+\t  dwarf2out_frame_debug (insn);\n+#else\n+\tif (!ACCUMULATE_OUTGOING_ARGS\n+\t    && GET_CODE (insn) == INSN\n+\t    && dwarf2out_do_frame ())\n+\t  dwarf2out_frame_debug (insn);\n #endif\n-\t  }\n #endif\n \n #if 0"}]}