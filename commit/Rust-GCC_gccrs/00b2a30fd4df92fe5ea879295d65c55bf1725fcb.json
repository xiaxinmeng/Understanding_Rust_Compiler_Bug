{"sha": "00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBiMmEzMGZkNGRmOTJmZTVlYTg3OTI5NWQ2NWM1NWJmMTcyNWZjYg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-02-17T15:43:39Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-02-17T15:43:39Z"}, "message": "libgo: update to final Go 1.8 release\n    \n    Along with the update this fixes a problem that was always present but\n    only showed up with the new reflect test.  When a program used a\n    **unsafe.Pointer and stored the value in an interface type, the\n    generated type descriptor pointed to the GC data for *unsafe.Pointer.\n    It did that by name, but we were not generating a variable with the\n    right name.\n    \n    Reviewed-on: https://go-review.googlesource.com/37144\n\nFrom-SVN: r245535", "tree": {"sha": "01db6511f47b5c9c301fa6f57b0df9376c364fd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01db6511f47b5c9c301fa6f57b0df9376c364fd5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/comments", "author": null, "committer": null, "parents": [{"sha": "4bcd6597a33c86615059873504b3140f49c3b96c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bcd6597a33c86615059873504b3140f49c3b96c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bcd6597a33c86615059873504b3140f49c3b96c"}], "stats": {"total": 1159, "additions": 894, "deletions": 265}, "files": [{"sha": "9cf7ec34f4ab8399f4436db0c4856106d0291803", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "patch": "@@ -1,4 +1,4 @@\n-c3935e1f20ad5b1d4c41150f11fb266913c04df7\n+893f0e4a707c6f10eb14842b18954486042f0fb3\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "16f346a2b8e6832e3f4eb9b29ad7203bc055e5ed", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "patch": "@@ -1,4 +1,4 @@\n-2a5f65a98ca483aad2dd74dc2636a7baecc59cf2\n+cd6b6202dd1559b3ac63179b45f1833fcfbe7eca\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "436edd93930654ba96603e796227c537f3534a52", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "patch": "@@ -1 +1 @@\n-go1.8rc3\n+go1.8"}, {"sha": "3d5dd2b39725883fd01bb5541d8604c268ddd4fc", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "patch": "@@ -17,7 +17,7 @@\n // \tclean       remove object files\n // \tdoc         show documentation for package or symbol\n // \tenv         print Go environment information\n-// \tbug         print information for bug reports\n+// \tbug         start a bug report\n // \tfix         run go tool fix on packages\n // \tfmt         run gofmt on package sources\n // \tgenerate    generate Go files by processing source\n@@ -324,15 +324,14 @@\n // each named variable on its own line.\n //\n //\n-// Print information for bug reports\n+// Start a bug report\n //\n // Usage:\n //\n // \tgo bug\n //\n-// Bug prints information that helps file effective bug reports.\n-//\n-// Bugs may be reported at https://golang.org/issue/new.\n+// Bug opens the default browser and starts a new bug report.\n+// The report includes useful system information.\n //\n //\n // Run go tool fix on packages"}, {"sha": "6fb4235068ec944a94b49c8fe07a972e9824b004", "filename": "libgo/go/cmd/go/get.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fcmd%2Fgo%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fcmd%2Fgo%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fget.go?ref=00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "patch": "@@ -428,7 +428,7 @@ func downloadPackage(p *Package) error {\n \t\t\treturn fmt.Errorf(\"cannot download, $GOPATH not set. For more details see: 'go help gopath'\")\n \t\t}\n \t\t// Guard against people setting GOPATH=$GOROOT.\n-\t\tif list[0] == goroot {\n+\t\tif filepath.Clean(list[0]) == filepath.Clean(goroot) {\n \t\t\treturn fmt.Errorf(\"cannot download, $GOPATH must not be set to $GOROOT. For more details see: 'go help gopath'\")\n \t\t}\n \t\tif _, err := os.Stat(filepath.Join(list[0], \"src/cmd/go/alldocs.go\")); err == nil {"}, {"sha": "56de65ce55ae3d65e6bf0db6d7538a2d022572fa", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 75, "deletions": 130, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "patch": "@@ -1683,173 +1683,111 @@ func homeEnvName() string {\n \t}\n }\n \n-// Test go env missing GOPATH shows default.\n-func TestMissingGOPATHEnvShowsDefault(t *testing.T) {\n+func TestDefaultGOPATH(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n-\ttg.setenv(\"GOPATH\", \"\")\n-\ttg.run(\"env\", \"GOPATH\")\n+\ttg.tempDir(\"home/go\")\n+\ttg.setenv(homeEnvName(), tg.path(\"home\"))\n \n-\twant := filepath.Join(os.Getenv(homeEnvName()), \"go\")\n-\tgot := strings.TrimSpace(tg.getStdout())\n-\tif got != want {\n-\t\tt.Errorf(\"got %q; want %q\", got, want)\n-\t}\n-}\n-\n-// Test go get missing GOPATH causes go get to warn if directory doesn't exist.\n-func TestMissingGOPATHGetWarnsIfNotExists(t *testing.T) {\n-\ttestenv.MustHaveExternalNetwork(t)\n-\n-\tif _, err := exec.LookPath(\"git\"); err != nil {\n-\t\tt.Skip(\"skipping because git binary not found\")\n-\t}\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\n-\t// setenv variables for test and defer deleting temporary home directory.\n-\ttg.setenv(\"GOPATH\", \"\")\n-\ttmp, err := ioutil.TempDir(\"\", \"\")\n-\tif err != nil {\n-\t\tt.Fatalf(\"could not create tmp home: %v\", err)\n-\t}\n-\tdefer os.RemoveAll(tmp)\n-\ttg.setenv(homeEnvName(), tmp)\n+\ttg.run(\"env\", \"GOPATH\")\n+\ttg.grepStdout(regexp.QuoteMeta(tg.path(\"home/go\")), \"want GOPATH=$HOME/go\")\n \n-\ttg.run(\"get\", \"-v\", \"github.com/golang/example/hello\")\n+\ttg.setenv(\"GOROOT\", tg.path(\"home/go\"))\n+\ttg.run(\"env\", \"GOPATH\")\n+\ttg.grepStdoutNot(\".\", \"want unset GOPATH because GOROOT=$HOME/go\")\n \n-\twant := fmt.Sprintf(\"created GOPATH=%s; see 'go help gopath'\", filepath.Join(tmp, \"go\"))\n-\tgot := strings.TrimSpace(tg.getStderr())\n-\tif !strings.Contains(got, want) {\n-\t\tt.Errorf(\"got %q; want %q\", got, want)\n-\t}\n+\ttg.setenv(\"GOROOT\", tg.path(\"home/go\")+\"/\")\n+\ttg.run(\"env\", \"GOPATH\")\n+\ttg.grepStdoutNot(\".\", \"want unset GOPATH because GOROOT=$HOME/go/\")\n }\n \n-// Test go get missing GOPATH causes no warning if directory exists.\n-func TestMissingGOPATHGetDoesntWarnIfExists(t *testing.T) {\n+func TestDefaultGOPATHGet(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \n-\tif _, err := exec.LookPath(\"git\"); err != nil {\n-\t\tt.Skip(\"skipping because git binary not found\")\n-\t}\n-\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n-\n-\t// setenv variables for test and defer resetting them.\n \ttg.setenv(\"GOPATH\", \"\")\n-\ttmp, err := ioutil.TempDir(\"\", \"\")\n-\tif err != nil {\n-\t\tt.Fatalf(\"could not create tmp home: %v\", err)\n-\t}\n-\tdefer os.RemoveAll(tmp)\n-\tif err := os.Mkdir(filepath.Join(tmp, \"go\"), 0777); err != nil {\n-\t\tt.Fatalf(\"could not create $HOME/go: %v\", err)\n-\t}\n+\ttg.tempDir(\"home\")\n+\ttg.setenv(homeEnvName(), tg.path(\"home\"))\n \n-\ttg.setenv(homeEnvName(), tmp)\n+\t// warn for creating directory\n+\ttg.run(\"get\", \"-v\", \"github.com/golang/example/hello\")\n+\ttg.grepStderr(\"created GOPATH=\"+regexp.QuoteMeta(tg.path(\"home/go\"))+\"; see 'go help gopath'\", \"did not create GOPATH\")\n \n+\t// no warning if directory already exists\n+\ttg.must(os.RemoveAll(tg.path(\"home/go\")))\n+\ttg.tempDir(\"home/go\")\n \ttg.run(\"get\", \"github.com/golang/example/hello\")\n+\ttg.grepStderrNot(\".\", \"expected no output on standard error\")\n \n-\tgot := strings.TrimSpace(tg.getStderr())\n-\tif got != \"\" {\n-\t\tt.Errorf(\"got %q; wants empty\", got)\n-\t}\n-}\n-\n-// Test go get missing GOPATH fails if pointed file is not a directory.\n-func TestMissingGOPATHGetFailsIfItsNotDirectory(t *testing.T) {\n-\ttestenv.MustHaveExternalNetwork(t)\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\n-\t// setenv variables for test and defer resetting them.\n-\ttg.setenv(\"GOPATH\", \"\")\n-\ttmp, err := ioutil.TempDir(\"\", \"\")\n-\tif err != nil {\n-\t\tt.Fatalf(\"could not create tmp home: %v\", err)\n-\t}\n-\tdefer os.RemoveAll(tmp)\n-\n-\tpath := filepath.Join(tmp, \"go\")\n-\tif err := ioutil.WriteFile(path, nil, 0777); err != nil {\n-\t\tt.Fatalf(\"could not create GOPATH at %s: %v\", path, err)\n-\t}\n-\ttg.setenv(homeEnvName(), tmp)\n-\n-\tconst pkg = \"github.com/golang/example/hello\"\n-\ttg.runFail(\"get\", pkg)\n-\n-\tmsg := \"not a directory\"\n-\tif runtime.GOOS == \"windows\" {\n-\t\tmsg = \"The system cannot find the path specified.\"\n-\t}\n-\twant := fmt.Sprintf(\"package %s: mkdir %s: %s\", pkg, filepath.Join(tmp, \"go\"), msg)\n-\tgot := strings.TrimSpace(tg.getStderr())\n-\tif got != want {\n-\t\tt.Errorf(\"got %q; wants %q\", got, want)\n-\t}\n+\t// error if $HOME/go is a file\n+\ttg.must(os.RemoveAll(tg.path(\"home/go\")))\n+\ttg.tempFile(\"home/go\", \"\")\n+\ttg.runFail(\"get\", \"github.com/golang/example/hello\")\n+\ttg.grepStderr(`mkdir .*[/\\\\]go: .*(not a directory|cannot find the path)`, \"expected error because $HOME/go is a file\")\n }\n \n-// Test go install of missing package when missing GOPATH fails and shows default GOPATH.\n-func TestMissingGOPATHInstallMissingPackageFailsAndShowsDefault(t *testing.T) {\n+func TestDefaultGOPATHPrintedSearchList(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n-\n-\t// setenv variables for test and defer resetting them.\n \ttg.setenv(\"GOPATH\", \"\")\n-\ttmp, err := ioutil.TempDir(\"\", \"\")\n-\tif err != nil {\n-\t\tt.Fatalf(\"could not create tmp home: %v\", err)\n-\t}\n-\tdefer os.RemoveAll(tmp)\n-\tif err := os.Mkdir(filepath.Join(tmp, \"go\"), 0777); err != nil {\n-\t\tt.Fatalf(\"could not create $HOME/go: %v\", err)\n-\t}\n-\ttg.setenv(homeEnvName(), tmp)\n-\n-\tconst pkg = \"github.com/golang/example/hello\"\n-\ttg.runFail(\"install\", pkg)\n-\n-\tpkgPath := filepath.Join(strings.Split(pkg, \"/\")...)\n-\twant := fmt.Sprintf(\"can't load package: package %s: cannot find package \\\"%s\\\" in any of:\", pkg, pkg) +\n-\t\tfmt.Sprintf(\"\\n\\t%s (from $GOROOT)\", filepath.Join(runtime.GOROOT(), \"src\", pkgPath)) +\n-\t\tfmt.Sprintf(\"\\n\\t%s (from $GOPATH)\", filepath.Join(tmp, \"go\", \"src\", pkgPath))\n+\ttg.tempDir(\"home\")\n+\ttg.setenv(homeEnvName(), tg.path(\"home\"))\n \n-\tgot := strings.TrimSpace(tg.getStderr())\n-\tif got != want {\n-\t\tt.Errorf(\"got %q; wants %q\", got, want)\n-\t}\n+\ttg.runFail(\"install\", \"github.com/golang/example/hello\")\n+\ttg.grepStderr(regexp.QuoteMeta(tg.path(\"home/go/src/github.com/golang/example/hello\"))+`.*from \\$GOPATH`, \"expected default GOPATH\")\n }\n \n // Issue 4186.  go get cannot be used to download packages to $GOROOT.\n // Test that without GOPATH set, go get should fail.\n-func TestWithoutGOPATHGoGetFails(t *testing.T) {\n+func TestGoGetIntoGOROOT(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n \ttg.tempDir(\"src\")\n-\ttg.setenv(\"GOPATH\", \"\")\n+\n+\t// Fails because GOROOT=GOPATH\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n \ttg.setenv(\"GOROOT\", tg.path(\".\"))\n-\ttg.runFail(\"get\", \"-d\", \"golang.org/x/codereview/cmd/hgpatch\")\n-}\n+\ttg.runFail(\"get\", \"-d\", \"github.com/golang/example/hello\")\n+\ttg.grepStderr(\"warning: GOPATH set to GOROOT\", \"go should detect GOPATH=GOROOT\")\n+\ttg.grepStderr(`\\$GOPATH must not be set to \\$GOROOT`, \"go should detect GOPATH=GOROOT\")\n \n-// Test that with GOPATH=$GOROOT, go get should fail.\n-func TestWithGOPATHEqualsGOROOTGoGetFails(t *testing.T) {\n-\ttestenv.MustHaveExternalNetwork(t)\n+\t// Fails because GOROOT=GOPATH after cleaning.\n+\ttg.setenv(\"GOPATH\", tg.path(\".\")+\"/\")\n+\ttg.setenv(\"GOROOT\", tg.path(\".\"))\n+\ttg.runFail(\"get\", \"-d\", \"github.com/golang/example/hello\")\n+\ttg.grepStderr(\"warning: GOPATH set to GOROOT\", \"go should detect GOPATH=GOROOT\")\n+\ttg.grepStderr(`\\$GOPATH must not be set to \\$GOROOT`, \"go should detect GOPATH=GOROOT\")\n \n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.tempDir(\"src\")\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.setenv(\"GOROOT\", tg.path(\".\"))\n-\ttg.runFail(\"get\", \"-d\", \"golang.org/x/codereview/cmd/hgpatch\")\n+\ttg.setenv(\"GOROOT\", tg.path(\".\")+\"/\")\n+\ttg.runFail(\"get\", \"-d\", \"github.com/golang/example/hello\")\n+\ttg.grepStderr(\"warning: GOPATH set to GOROOT\", \"go should detect GOPATH=GOROOT\")\n+\ttg.grepStderr(`\\$GOPATH must not be set to \\$GOROOT`, \"go should detect GOPATH=GOROOT\")\n+\n+\t// Fails because GOROOT=$HOME/go so default GOPATH unset.\n+\ttg.tempDir(\"home/go\")\n+\ttg.setenv(homeEnvName(), tg.path(\"home\"))\n+\ttg.setenv(\"GOPATH\", \"\")\n+\ttg.setenv(\"GOROOT\", tg.path(\"home/go\"))\n+\ttg.runFail(\"get\", \"-d\", \"github.com/golang/example/hello\")\n+\ttg.grepStderr(`\\$GOPATH not set`, \"expected GOPATH not set\")\n+\n+\ttg.setenv(homeEnvName(), tg.path(\"home\")+\"/\")\n+\ttg.setenv(\"GOPATH\", \"\")\n+\ttg.setenv(\"GOROOT\", tg.path(\"home/go\"))\n+\ttg.runFail(\"get\", \"-d\", \"github.com/golang/example/hello\")\n+\ttg.grepStderr(`\\$GOPATH not set`, \"expected GOPATH not set\")\n+\n+\ttg.setenv(homeEnvName(), tg.path(\"home\"))\n+\ttg.setenv(\"GOPATH\", \"\")\n+\ttg.setenv(\"GOROOT\", tg.path(\"home/go\")+\"/\")\n+\ttg.runFail(\"get\", \"-d\", \"github.com/golang/example/hello\")\n+\ttg.grepStderr(`\\$GOPATH not set`, \"expected GOPATH not set\")\n }\n \n func TestLdflagsArgumentsWithSpacesIssue3941(t *testing.T) {\n@@ -3744,6 +3682,13 @@ func TestMatchesOnlySubtestParallelIsOK(t *testing.T) {\n \ttg.grepBoth(okPattern, \"go test did not say ok\")\n }\n \n+// Issue 18845\n+func TestBenchTimeout(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"test\", \"-bench\", \".\", \"-timeout\", \"750ms\", \"testdata/timeoutbench_test.go\")\n+}\n+\n func TestLinkXImportPathEscape(t *testing.T) {\n \t// golang.org/issue/16710\n \ttg := testgo(t)"}, {"sha": "d80ff2da5fe67d28a711d3ff72436db032d3c965", "filename": "libgo/go/cmd/go/main.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go?ref=00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "patch": "@@ -136,7 +136,7 @@ func main() {\n \t// Diagnose common mistake: GOPATH==GOROOT.\n \t// This setting is equivalent to not setting GOPATH at all,\n \t// which is not what most people want when they do it.\n-\tif gopath := buildContext.GOPATH; gopath == runtime.GOROOT() {\n+\tif gopath := buildContext.GOPATH; filepath.Clean(gopath) == filepath.Clean(runtime.GOROOT()) {\n \t\tfmt.Fprintf(os.Stderr, \"warning: GOPATH set to GOROOT (%s) has no effect\\n\", gopath)\n \t} else {\n \t\tfor _, p := range filepath.SplitList(gopath) {"}, {"sha": "aa1785e4c637508f2d01d0679f271f7ea3d3bc51", "filename": "libgo/go/crypto/x509/root_linux.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_linux.go?ref=00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "patch": "@@ -7,8 +7,8 @@ package x509\n // Possible certificate files; stop after finding one.\n var certFiles = []string{\n \t\"/etc/ssl/certs/ca-certificates.crt\",                // Debian/Ubuntu/Gentoo etc.\n-\t\"/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem\", // CentOS/RHEL 7\n \t\"/etc/pki/tls/certs/ca-bundle.crt\",                  // Fedora/RHEL 6\n \t\"/etc/ssl/ca-bundle.pem\",                            // OpenSUSE\n \t\"/etc/pki/tls/cacert.pem\",                           // OpenELEC\n+\t\"/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem\", // CentOS/RHEL 7\n }"}, {"sha": "bd652b54625337b211fe1b9466239acfa104b190", "filename": "libgo/go/database/sql/ctxutil.go", "status": "modified", "additions": 20, "deletions": 34, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fdatabase%2Fsql%2Fctxutil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fdatabase%2Fsql%2Fctxutil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fctxutil.go?ref=00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "patch": "@@ -35,15 +35,12 @@ func ctxDriverExec(ctx context.Context, execer driver.Execer, query string, nvda\n \t\treturn nil, err\n \t}\n \n-\tresi, err := execer.Exec(query, dargs)\n-\tif err == nil {\n-\t\tselect {\n-\t\tdefault:\n-\t\tcase <-ctx.Done():\n-\t\t\treturn resi, ctx.Err()\n-\t\t}\n+\tselect {\n+\tdefault:\n+\tcase <-ctx.Done():\n+\t\treturn nil, ctx.Err()\n \t}\n-\treturn resi, err\n+\treturn execer.Exec(query, dargs)\n }\n \n func ctxDriverQuery(ctx context.Context, queryer driver.Queryer, query string, nvdargs []driver.NamedValue) (driver.Rows, error) {\n@@ -56,16 +53,12 @@ func ctxDriverQuery(ctx context.Context, queryer driver.Queryer, query string, n\n \t\treturn nil, err\n \t}\n \n-\trowsi, err := queryer.Query(query, dargs)\n-\tif err == nil {\n-\t\tselect {\n-\t\tdefault:\n-\t\tcase <-ctx.Done():\n-\t\t\trowsi.Close()\n-\t\t\treturn nil, ctx.Err()\n-\t\t}\n+\tselect {\n+\tdefault:\n+\tcase <-ctx.Done():\n+\t\treturn nil, ctx.Err()\n \t}\n-\treturn rowsi, err\n+\treturn queryer.Query(query, dargs)\n }\n \n func ctxDriverStmtExec(ctx context.Context, si driver.Stmt, nvdargs []driver.NamedValue) (driver.Result, error) {\n@@ -77,15 +70,12 @@ func ctxDriverStmtExec(ctx context.Context, si driver.Stmt, nvdargs []driver.Nam\n \t\treturn nil, err\n \t}\n \n-\tresi, err := si.Exec(dargs)\n-\tif err == nil {\n-\t\tselect {\n-\t\tdefault:\n-\t\tcase <-ctx.Done():\n-\t\t\treturn resi, ctx.Err()\n-\t\t}\n+\tselect {\n+\tdefault:\n+\tcase <-ctx.Done():\n+\t\treturn nil, ctx.Err()\n \t}\n-\treturn resi, err\n+\treturn si.Exec(dargs)\n }\n \n func ctxDriverStmtQuery(ctx context.Context, si driver.Stmt, nvdargs []driver.NamedValue) (driver.Rows, error) {\n@@ -97,16 +87,12 @@ func ctxDriverStmtQuery(ctx context.Context, si driver.Stmt, nvdargs []driver.Na\n \t\treturn nil, err\n \t}\n \n-\trowsi, err := si.Query(dargs)\n-\tif err == nil {\n-\t\tselect {\n-\t\tdefault:\n-\t\tcase <-ctx.Done():\n-\t\t\trowsi.Close()\n-\t\t\treturn nil, ctx.Err()\n-\t\t}\n+\tselect {\n+\tdefault:\n+\tcase <-ctx.Done():\n+\t\treturn nil, ctx.Err()\n \t}\n-\treturn rowsi, err\n+\treturn si.Query(dargs)\n }\n \n var errLevelNotSupported = errors.New(\"sql: selected isolation level is not supported\")"}, {"sha": "c016681fca13c305aaea2cbfd6fc0707135c5827", "filename": "libgo/go/database/sql/sql.go", "status": "modified", "additions": 109, "deletions": 42, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go?ref=00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "patch": "@@ -305,8 +305,9 @@ type DB struct {\n \n \tmu           sync.Mutex // protects following fields\n \tfreeConn     []*driverConn\n-\tconnRequests []chan connRequest\n-\tnumOpen      int // number of opened and pending open connections\n+\tconnRequests map[uint64]chan connRequest\n+\tnextRequest  uint64 // Next key to use in connRequests.\n+\tnumOpen      int    // number of opened and pending open connections\n \t// Used to signal the need for new connections\n \t// a goroutine running connectionOpener() reads on this chan and\n \t// maybeOpenNewConnections sends on the chan (one send per needed connection)\n@@ -572,10 +573,11 @@ func Open(driverName, dataSourceName string) (*DB, error) {\n \t\treturn nil, fmt.Errorf(\"sql: unknown driver %q (forgotten import?)\", driverName)\n \t}\n \tdb := &DB{\n-\t\tdriver:   driveri,\n-\t\tdsn:      dataSourceName,\n-\t\topenerCh: make(chan struct{}, connectionRequestQueueSize),\n-\t\tlastPut:  make(map[*driverConn]string),\n+\t\tdriver:       driveri,\n+\t\tdsn:          dataSourceName,\n+\t\topenerCh:     make(chan struct{}, connectionRequestQueueSize),\n+\t\tlastPut:      make(map[*driverConn]string),\n+\t\tconnRequests: make(map[uint64]chan connRequest),\n \t}\n \tgo db.connectionOpener()\n \treturn db, nil\n@@ -881,6 +883,14 @@ type connRequest struct {\n \n var errDBClosed = errors.New(\"sql: database is closed\")\n \n+// nextRequestKeyLocked returns the next connection request key.\n+// It is assumed that nextRequest will not overflow.\n+func (db *DB) nextRequestKeyLocked() uint64 {\n+\tnext := db.nextRequest\n+\tdb.nextRequest++\n+\treturn next\n+}\n+\n // conn returns a newly-opened or cached *driverConn.\n func (db *DB) conn(ctx context.Context, strategy connReuseStrategy) (*driverConn, error) {\n \tdb.mu.Lock()\n@@ -918,12 +928,25 @@ func (db *DB) conn(ctx context.Context, strategy connReuseStrategy) (*driverConn\n \t\t// Make the connRequest channel. It's buffered so that the\n \t\t// connectionOpener doesn't block while waiting for the req to be read.\n \t\treq := make(chan connRequest, 1)\n-\t\tdb.connRequests = append(db.connRequests, req)\n+\t\treqKey := db.nextRequestKeyLocked()\n+\t\tdb.connRequests[reqKey] = req\n \t\tdb.mu.Unlock()\n \n \t\t// Timeout the connection request with the context.\n \t\tselect {\n \t\tcase <-ctx.Done():\n+\t\t\t// Remove the connection request and ensure no value has been sent\n+\t\t\t// on it after removing.\n+\t\t\tdb.mu.Lock()\n+\t\t\tdelete(db.connRequests, reqKey)\n+\t\t\tdb.mu.Unlock()\n+\t\t\tselect {\n+\t\t\tdefault:\n+\t\t\tcase ret, ok := <-req:\n+\t\t\t\tif ok {\n+\t\t\t\t\tdb.putConn(ret.conn, ret.err)\n+\t\t\t\t}\n+\t\t\t}\n \t\t\treturn nil, ctx.Err()\n \t\tcase ret, ok := <-req:\n \t\t\tif !ok {\n@@ -1044,12 +1067,12 @@ func (db *DB) putConnDBLocked(dc *driverConn, err error) bool {\n \t\treturn false\n \t}\n \tif c := len(db.connRequests); c > 0 {\n-\t\treq := db.connRequests[0]\n-\t\t// This copy is O(n) but in practice faster than a linked list.\n-\t\t// TODO: consider compacting it down less often and\n-\t\t// moving the base instead?\n-\t\tcopy(db.connRequests, db.connRequests[1:])\n-\t\tdb.connRequests = db.connRequests[:c-1]\n+\t\tvar req chan connRequest\n+\t\tvar reqKey uint64\n+\t\tfor reqKey, req = range db.connRequests {\n+\t\t\tbreak\n+\t\t}\n+\t\tdelete(db.connRequests, reqKey) // Remove from pending requests.\n \t\tif err == nil {\n \t\t\tdc.inUse = true\n \t\t}\n@@ -2071,14 +2094,21 @@ type Rows struct {\n \tdc          *driverConn // owned; must call releaseConn when closed to release\n \treleaseConn func(error)\n \trowsi       driver.Rows\n+\tcancel      func()      // called when Rows is closed, may be nil.\n+\tcloseStmt   *driverStmt // if non-nil, statement to Close on close\n \n-\t// closed value is 1 when the Rows is closed.\n-\t// Use atomic operations on value when checking value.\n-\tclosed    int32\n-\tcancel    func() // called when Rows is closed, may be nil.\n-\tlastcols  []driver.Value\n-\tlasterr   error       // non-nil only if closed is true\n-\tcloseStmt *driverStmt // if non-nil, statement to Close on close\n+\t// closemu prevents Rows from closing while there\n+\t// is an active streaming result. It is held for read during non-close operations\n+\t// and exclusively during close.\n+\t//\n+\t// closemu guards lasterr and closed.\n+\tclosemu sync.RWMutex\n+\tclosed  bool\n+\tlasterr error // non-nil only if closed is true\n+\n+\t// lastcols is only used in Scan, Next, and NextResultSet which are expected\n+\t// not not be called concurrently.\n+\tlastcols []driver.Value\n }\n \n func (rs *Rows) initContextClose(ctx context.Context) {\n@@ -2089,7 +2119,7 @@ func (rs *Rows) initContextClose(ctx context.Context) {\n // awaitDone blocks until the rows are closed or the context canceled.\n func (rs *Rows) awaitDone(ctx context.Context) {\n \t<-ctx.Done()\n-\trs.Close()\n+\trs.close(ctx.Err())\n }\n \n // Next prepares the next result row for reading with the Scan method. It\n@@ -2099,8 +2129,19 @@ func (rs *Rows) awaitDone(ctx context.Context) {\n //\n // Every call to Scan, even the first one, must be preceded by a call to Next.\n func (rs *Rows) Next() bool {\n-\tif rs.isClosed() {\n-\t\treturn false\n+\tvar doClose, ok bool\n+\twithLock(rs.closemu.RLocker(), func() {\n+\t\tdoClose, ok = rs.nextLocked()\n+\t})\n+\tif doClose {\n+\t\trs.Close()\n+\t}\n+\treturn ok\n+}\n+\n+func (rs *Rows) nextLocked() (doClose, ok bool) {\n+\tif rs.closed {\n+\t\treturn false, false\n \t}\n \tif rs.lastcols == nil {\n \t\trs.lastcols = make([]driver.Value, len(rs.rowsi.Columns()))\n@@ -2109,23 +2150,21 @@ func (rs *Rows) Next() bool {\n \tif rs.lasterr != nil {\n \t\t// Close the connection if there is a driver error.\n \t\tif rs.lasterr != io.EOF {\n-\t\t\trs.Close()\n-\t\t\treturn false\n+\t\t\treturn true, false\n \t\t}\n \t\tnextResultSet, ok := rs.rowsi.(driver.RowsNextResultSet)\n \t\tif !ok {\n-\t\t\trs.Close()\n-\t\t\treturn false\n+\t\t\treturn true, false\n \t\t}\n \t\t// The driver is at the end of the current result set.\n \t\t// Test to see if there is another result set after the current one.\n \t\t// Only close Rows if there is no further result sets to read.\n \t\tif !nextResultSet.HasNextResultSet() {\n-\t\t\trs.Close()\n+\t\t\tdoClose = true\n \t\t}\n-\t\treturn false\n+\t\treturn doClose, false\n \t}\n-\treturn true\n+\treturn false, true\n }\n \n // NextResultSet prepares the next result set for reading. It returns true if\n@@ -2137,18 +2176,28 @@ func (rs *Rows) Next() bool {\n // scanning. If there are further result sets they may not have rows in the result\n // set.\n func (rs *Rows) NextResultSet() bool {\n-\tif rs.isClosed() {\n+\tvar doClose bool\n+\tdefer func() {\n+\t\tif doClose {\n+\t\t\trs.Close()\n+\t\t}\n+\t}()\n+\trs.closemu.RLock()\n+\tdefer rs.closemu.RUnlock()\n+\n+\tif rs.closed {\n \t\treturn false\n \t}\n+\n \trs.lastcols = nil\n \tnextResultSet, ok := rs.rowsi.(driver.RowsNextResultSet)\n \tif !ok {\n-\t\trs.Close()\n+\t\tdoClose = true\n \t\treturn false\n \t}\n \trs.lasterr = nextResultSet.NextResultSet()\n \tif rs.lasterr != nil {\n-\t\trs.Close()\n+\t\tdoClose = true\n \t\treturn false\n \t}\n \treturn true\n@@ -2157,6 +2206,8 @@ func (rs *Rows) NextResultSet() bool {\n // Err returns the error, if any, that was encountered during iteration.\n // Err may be called after an explicit or implicit Close.\n func (rs *Rows) Err() error {\n+\trs.closemu.RLock()\n+\tdefer rs.closemu.RUnlock()\n \tif rs.lasterr == io.EOF {\n \t\treturn nil\n \t}\n@@ -2167,7 +2218,9 @@ func (rs *Rows) Err() error {\n // Columns returns an error if the rows are closed, or if the rows\n // are from QueryRow and there was a deferred error.\n func (rs *Rows) Columns() ([]string, error) {\n-\tif rs.isClosed() {\n+\trs.closemu.RLock()\n+\tdefer rs.closemu.RUnlock()\n+\tif rs.closed {\n \t\treturn nil, errors.New(\"sql: Rows are closed\")\n \t}\n \tif rs.rowsi == nil {\n@@ -2179,7 +2232,9 @@ func (rs *Rows) Columns() ([]string, error) {\n // ColumnTypes returns column information such as column type, length,\n // and nullable. Some information may not be available from some drivers.\n func (rs *Rows) ColumnTypes() ([]*ColumnType, error) {\n-\tif rs.isClosed() {\n+\trs.closemu.RLock()\n+\tdefer rs.closemu.RUnlock()\n+\tif rs.closed {\n \t\treturn nil, errors.New(\"sql: Rows are closed\")\n \t}\n \tif rs.rowsi == nil {\n@@ -2329,9 +2384,13 @@ func rowsColumnInfoSetup(rowsi driver.Rows) []*ColumnType {\n // For scanning into *bool, the source may be true, false, 1, 0, or\n // string inputs parseable by strconv.ParseBool.\n func (rs *Rows) Scan(dest ...interface{}) error {\n-\tif rs.isClosed() {\n+\trs.closemu.RLock()\n+\tif rs.closed {\n+\t\trs.closemu.RUnlock()\n \t\treturn errors.New(\"sql: Rows are closed\")\n \t}\n+\trs.closemu.RUnlock()\n+\n \tif rs.lastcols == nil {\n \t\treturn errors.New(\"sql: Scan called without calling Next\")\n \t}\n@@ -2351,20 +2410,28 @@ func (rs *Rows) Scan(dest ...interface{}) error {\n // hook throug a test only mutex.\n var rowsCloseHook = func() func(*Rows, *error) { return nil }\n \n-func (rs *Rows) isClosed() bool {\n-\treturn atomic.LoadInt32(&rs.closed) != 0\n-}\n-\n // Close closes the Rows, preventing further enumeration. If Next is called\n // and returns false and there are no further result sets,\n // the Rows are closed automatically and it will suffice to check the\n // result of Err. Close is idempotent and does not affect the result of Err.\n func (rs *Rows) Close() error {\n-\tif !atomic.CompareAndSwapInt32(&rs.closed, 0, 1) {\n+\treturn rs.close(nil)\n+}\n+\n+func (rs *Rows) close(err error) error {\n+\trs.closemu.Lock()\n+\tdefer rs.closemu.Unlock()\n+\n+\tif rs.closed {\n \t\treturn nil\n \t}\n+\trs.closed = true\n+\n+\tif rs.lasterr == nil {\n+\t\trs.lasterr = err\n+\t}\n \n-\terr := rs.rowsi.Close()\n+\terr = rs.rowsi.Close()\n \tif fn := rowsCloseHook(); fn != nil {\n \t\tfn(rs, &err)\n \t}"}, {"sha": "450e5f1f8c961d1c0885a4bc97f3de8bcf26bd44", "filename": "libgo/go/database/sql/sql_test.go", "status": "modified", "additions": 102, "deletions": 23, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go?ref=00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "patch": "@@ -153,8 +153,13 @@ func closeDB(t testing.TB, db *DB) {\n \tif err != nil {\n \t\tt.Fatalf(\"error closing DB: %v\", err)\n \t}\n-\tif count := db.numOpenConns(); count != 0 {\n-\t\tt.Fatalf(\"%d connections still open after closing DB\", count)\n+\n+\tvar numOpen int\n+\tif !waitCondition(5*time.Second, 5*time.Millisecond, func() bool {\n+\t\tnumOpen = db.numOpenConns()\n+\t\treturn numOpen == 0\n+\t}) {\n+\t\tt.Fatalf(\"%d connections still open after closing DB\", numOpen)\n \t}\n }\n \n@@ -276,6 +281,7 @@ func TestQuery(t *testing.T) {\n \t}\n }\n \n+// TestQueryContext tests canceling the context while scanning the rows.\n func TestQueryContext(t *testing.T) {\n \tdb := newTestDB(t, \"people\")\n \tdefer closeDB(t, db)\n@@ -297,7 +303,7 @@ func TestQueryContext(t *testing.T) {\n \tfor rows.Next() {\n \t\tif index == 2 {\n \t\t\tcancel()\n-\t\t\ttime.Sleep(10 * time.Millisecond)\n+\t\t\twaitForRowsClose(t, rows, 5*time.Second)\n \t\t}\n \t\tvar r row\n \t\terr = rows.Scan(&r.age, &r.name)\n@@ -313,9 +319,13 @@ func TestQueryContext(t *testing.T) {\n \t\tgot = append(got, r)\n \t\tindex++\n \t}\n-\terr = rows.Err()\n-\tif err != nil {\n-\t\tt.Fatalf(\"Err: %v\", err)\n+\tselect {\n+\tcase <-ctx.Done():\n+\t\tif err := ctx.Err(); err != context.Canceled {\n+\t\t\tt.Fatalf(\"context err = %v; want context.Canceled\")\n+\t\t}\n+\tdefault:\n+\t\tt.Fatalf(\"context err = nil; want context.Canceled\")\n \t}\n \twant := []row{\n \t\t{age: 1, name: \"Alice\"},\n@@ -327,6 +337,7 @@ func TestQueryContext(t *testing.T) {\n \n \t// And verify that the final rows.Next() call, which hit EOF,\n \t// also closed the rows connection.\n+\twaitForRowsClose(t, rows, 5*time.Second)\n \twaitForFree(t, db, 5*time.Second, 1)\n \tif prepares := numPrepares(t, db) - prepares0; prepares != 1 {\n \t\tt.Errorf(\"executed %d Prepare statements; want 1\", prepares)\n@@ -356,12 +367,27 @@ func waitForFree(t *testing.T, db *DB, maxWait time.Duration, want int) {\n \t}\n }\n \n+func waitForRowsClose(t *testing.T, rows *Rows, maxWait time.Duration) {\n+\tif !waitCondition(maxWait, 5*time.Millisecond, func() bool {\n+\t\trows.closemu.RLock()\n+\t\tdefer rows.closemu.RUnlock()\n+\t\treturn rows.closed\n+\t}) {\n+\t\tt.Fatal(\"failed to close rows\")\n+\t}\n+}\n+\n+// TestQueryContextWait ensures that rows and all internal statements are closed when\n+// a query context is closed during execution.\n func TestQueryContextWait(t *testing.T) {\n \tdb := newTestDB(t, \"people\")\n \tdefer closeDB(t, db)\n \tprepares0 := numPrepares(t, db)\n \n-\tctx, _ := context.WithTimeout(context.Background(), time.Millisecond*15)\n+\t// TODO(kardianos): convert this from using a timeout to using an explicit\n+\t// cancel when the query signals that is is \"executing\" the query.\n+\tctx, cancel := context.WithTimeout(context.Background(), 300*time.Millisecond)\n+\tdefer cancel()\n \n \t// This will trigger the *fakeConn.Prepare method which will take time\n \t// performing the query. The ctxDriverPrepare func will check the context\n@@ -374,10 +400,15 @@ func TestQueryContextWait(t *testing.T) {\n \t// Verify closed rows connection after error condition.\n \twaitForFree(t, db, 5*time.Second, 1)\n \tif prepares := numPrepares(t, db) - prepares0; prepares != 1 {\n-\t\tt.Errorf(\"executed %d Prepare statements; want 1\", prepares)\n+\t\t// TODO(kardianos): if the context timeouts before the db.QueryContext\n+\t\t// executes this check may fail. After adjusting how the context\n+\t\t// is canceled above revert this back to a Fatal error.\n+\t\tt.Logf(\"executed %d Prepare statements; want 1\", prepares)\n \t}\n }\n \n+// TestTxContextWait tests the transaction behavior when the tx context is canceled\n+// during execution of the query.\n func TestTxContextWait(t *testing.T) {\n \tdb := newTestDB(t, \"people\")\n \tdefer closeDB(t, db)\n@@ -386,6 +417,10 @@ func TestTxContextWait(t *testing.T) {\n \n \ttx, err := db.BeginTx(ctx, nil)\n \tif err != nil {\n+\t\t// Guard against the context being canceled before BeginTx completes.\n+\t\tif err == context.DeadlineExceeded {\n+\t\t\tt.Skip(\"tx context canceled prior to first use\")\n+\t\t}\n \t\tt.Fatal(err)\n \t}\n \n@@ -398,12 +433,6 @@ func TestTxContextWait(t *testing.T) {\n \t}\n \n \twaitForFree(t, db, 5*time.Second, 0)\n-\n-\t// Ensure the dropped connection allows more connections to be made.\n-\t// Checked on DB Close.\n-\twaitCondition(5*time.Second, 5*time.Millisecond, func() bool {\n-\t\treturn db.numOpenConns() == 0\n-\t})\n }\n \n func TestMultiResultSetQuery(t *testing.T) {\n@@ -527,6 +556,63 @@ func TestQueryNamedArg(t *testing.T) {\n \t}\n }\n \n+func TestPoolExhaustOnCancel(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"long test\")\n+\t}\n+\tdb := newTestDB(t, \"people\")\n+\tdefer closeDB(t, db)\n+\n+\tmax := 3\n+\n+\tdb.SetMaxOpenConns(max)\n+\n+\t// First saturate the connection pool.\n+\t// Then start new requests for a connection that is cancelled after it is requested.\n+\n+\tvar saturate, saturateDone sync.WaitGroup\n+\tsaturate.Add(max)\n+\tsaturateDone.Add(max)\n+\n+\tfor i := 0; i < max; i++ {\n+\t\tgo func() {\n+\t\t\tsaturate.Done()\n+\t\t\trows, err := db.Query(\"WAIT|500ms|SELECT|people|name,photo|\")\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"Query: %v\", err)\n+\t\t\t}\n+\t\t\trows.Close()\n+\t\t\tsaturateDone.Done()\n+\t\t}()\n+\t}\n+\n+\tsaturate.Wait()\n+\n+\t// Now cancel the request while it is waiting.\n+\tctx, cancel := context.WithTimeout(context.Background(), time.Second*2)\n+\tdefer cancel()\n+\n+\tfor i := 0; i < max; i++ {\n+\t\tctxReq, cancelReq := context.WithCancel(ctx)\n+\t\tgo func() {\n+\t\t\ttime.Sleep(time.Millisecond * 100)\n+\t\t\tcancelReq()\n+\t\t}()\n+\t\terr := db.PingContext(ctxReq)\n+\t\tif err != context.Canceled {\n+\t\t\tt.Fatalf(\"PingContext (Exhaust): %v\", err)\n+\t\t}\n+\t}\n+\n+\tsaturateDone.Wait()\n+\n+\t// Now try to open a normal connection.\n+\terr := db.PingContext(ctx)\n+\tif err != nil {\n+\t\tt.Fatalf(\"PingContext (Normal): %v\", err)\n+\t}\n+}\n+\n func TestByteOwnership(t *testing.T) {\n \tdb := newTestDB(t, \"people\")\n \tdefer closeDB(t, db)\n@@ -2677,7 +2763,6 @@ func TestIssue18429(t *testing.T) {\n \t\t}()\n \t}\n \twg.Wait()\n-\ttime.Sleep(milliWait * 3 * time.Millisecond)\n }\n \n // TestIssue18719 closes the context right before use. The sql.driverConn\n@@ -2720,14 +2805,8 @@ func TestIssue18719(t *testing.T) {\n \t// Do not explicitly rollback. The rollback will happen from the\n \t// canceled context.\n \n-\t// Wait for connections to return to pool.\n-\tvar numOpen int\n-\tif !waitCondition(5*time.Second, 5*time.Millisecond, func() bool {\n-\t\tnumOpen = db.numOpenConns()\n-\t\treturn numOpen == 0\n-\t}) {\n-\t\tt.Fatalf(\"open conns after hitting EOF = %d; want 0\", numOpen)\n-\t}\n+\tcancel()\n+\twaitForRowsClose(t, rows, 5*time.Second)\n }\n \n func TestConcurrency(t *testing.T) {"}, {"sha": "4c6ba8c1a5abee01f1be377661fbb588ef5438a1", "filename": "libgo/go/encoding/xml/marshal.go", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go?ref=00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "patch": "@@ -775,6 +775,20 @@ func (p *printer) marshalSimple(typ reflect.Type, val reflect.Value) (string, []\n \n var ddBytes = []byte(\"--\")\n \n+// indirect drills into interfaces and pointers, returning the pointed-at value.\n+// If it encounters a nil interface or pointer, indirect returns that nil value.\n+// This can turn into an infinite loop given a cyclic chain,\n+// but it matches the Go 1 behavior.\n+func indirect(vf reflect.Value) reflect.Value {\n+\tfor vf.Kind() == reflect.Interface || vf.Kind() == reflect.Ptr {\n+\t\tif vf.IsNil() {\n+\t\t\treturn vf\n+\t\t}\n+\t\tvf = vf.Elem()\n+\t}\n+\treturn vf\n+}\n+\n func (p *printer) marshalStruct(tinfo *typeInfo, val reflect.Value) error {\n \ts := parentStack{p: p}\n \tfor i := range tinfo.fields {\n@@ -816,17 +830,9 @@ func (p *printer) marshalStruct(tinfo *typeInfo, val reflect.Value) error {\n \t\t\t\t\tcontinue\n \t\t\t\t}\n \t\t\t}\n-\t\t\t// Drill into interfaces and pointers.\n-\t\t\t// This can turn into an infinite loop given a cyclic chain,\n-\t\t\t// but it matches the Go 1 behavior.\n-\t\t\tfor vf.Kind() == reflect.Interface || vf.Kind() == reflect.Ptr {\n-\t\t\t\tif vf.IsNil() {\n-\t\t\t\t\treturn nil\n-\t\t\t\t}\n-\t\t\t\tvf = vf.Elem()\n-\t\t\t}\n \n \t\t\tvar scratch [64]byte\n+\t\t\tvf = indirect(vf)\n \t\t\tswitch vf.Kind() {\n \t\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n \t\t\t\tif err := emit(p, strconv.AppendInt(scratch[:0], vf.Int(), 10)); err != nil {\n@@ -861,6 +867,7 @@ func (p *printer) marshalStruct(tinfo *typeInfo, val reflect.Value) error {\n \t\t\tif err := s.trim(finfo.parents); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n+\t\t\tvf = indirect(vf)\n \t\t\tk := vf.Kind()\n \t\t\tif !(k == reflect.String || k == reflect.Slice && vf.Type().Elem().Kind() == reflect.Uint8) {\n \t\t\t\treturn fmt.Errorf(\"xml: bad type for comment field of %s\", val.Type())\n@@ -901,6 +908,7 @@ func (p *printer) marshalStruct(tinfo *typeInfo, val reflect.Value) error {\n \t\t\tcontinue\n \n \t\tcase fInnerXml:\n+\t\t\tvf = indirect(vf)\n \t\t\tiface := vf.Interface()\n \t\t\tswitch raw := iface.(type) {\n \t\t\tcase []byte:"}, {"sha": "5ec7ececa4d039331bfec347269bccf2e2b71e31", "filename": "libgo/go/encoding/xml/marshal_test.go", "status": "modified", "additions": 537, "deletions": 7, "changes": 544, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go?ref=00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "patch": "@@ -386,6 +386,140 @@ func ifaceptr(x interface{}) interface{} {\n \treturn &x\n }\n \n+func stringptr(x string) *string {\n+\treturn &x\n+}\n+\n+type T1 struct{}\n+type T2 struct{}\n+type T3 struct{}\n+\n+type IndirComment struct {\n+\tT1      T1\n+\tComment *string `xml:\",comment\"`\n+\tT2      T2\n+}\n+\n+type DirectComment struct {\n+\tT1      T1\n+\tComment string `xml:\",comment\"`\n+\tT2      T2\n+}\n+\n+type IfaceComment struct {\n+\tT1      T1\n+\tComment interface{} `xml:\",comment\"`\n+\tT2      T2\n+}\n+\n+type IndirChardata struct {\n+\tT1       T1\n+\tChardata *string `xml:\",chardata\"`\n+\tT2       T2\n+}\n+\n+type DirectChardata struct {\n+\tT1       T1\n+\tChardata string `xml:\",chardata\"`\n+\tT2       T2\n+}\n+\n+type IfaceChardata struct {\n+\tT1       T1\n+\tChardata interface{} `xml:\",chardata\"`\n+\tT2       T2\n+}\n+\n+type IndirCDATA struct {\n+\tT1    T1\n+\tCDATA *string `xml:\",cdata\"`\n+\tT2    T2\n+}\n+\n+type DirectCDATA struct {\n+\tT1    T1\n+\tCDATA string `xml:\",cdata\"`\n+\tT2    T2\n+}\n+\n+type IfaceCDATA struct {\n+\tT1    T1\n+\tCDATA interface{} `xml:\",cdata\"`\n+\tT2    T2\n+}\n+\n+type IndirInnerXML struct {\n+\tT1       T1\n+\tInnerXML *string `xml:\",innerxml\"`\n+\tT2       T2\n+}\n+\n+type DirectInnerXML struct {\n+\tT1       T1\n+\tInnerXML string `xml:\",innerxml\"`\n+\tT2       T2\n+}\n+\n+type IfaceInnerXML struct {\n+\tT1       T1\n+\tInnerXML interface{} `xml:\",innerxml\"`\n+\tT2       T2\n+}\n+\n+type IndirElement struct {\n+\tT1      T1\n+\tElement *string\n+\tT2      T2\n+}\n+\n+type DirectElement struct {\n+\tT1      T1\n+\tElement string\n+\tT2      T2\n+}\n+\n+type IfaceElement struct {\n+\tT1      T1\n+\tElement interface{}\n+\tT2      T2\n+}\n+\n+type IndirOmitEmpty struct {\n+\tT1        T1\n+\tOmitEmpty *string `xml:\",omitempty\"`\n+\tT2        T2\n+}\n+\n+type DirectOmitEmpty struct {\n+\tT1        T1\n+\tOmitEmpty string `xml:\",omitempty\"`\n+\tT2        T2\n+}\n+\n+type IfaceOmitEmpty struct {\n+\tT1        T1\n+\tOmitEmpty interface{} `xml:\",omitempty\"`\n+\tT2        T2\n+}\n+\n+type IndirAny struct {\n+\tT1  T1\n+\tAny *string `xml:\",any\"`\n+\tT2  T2\n+}\n+\n+type DirectAny struct {\n+\tT1  T1\n+\tAny string `xml:\",any\"`\n+\tT2  T2\n+}\n+\n+type IfaceAny struct {\n+\tT1  T1\n+\tAny interface{} `xml:\",any\"`\n+\tT2  T2\n+}\n+\n var (\n \tnameAttr     = \"Sarah\"\n \tageAttr      = uint(12)\n@@ -398,10 +532,12 @@ var (\n // please try to make them two-way as well to ensure that\n // marshaling and unmarshaling are as symmetrical as feasible.\n var marshalTests = []struct {\n-\tValue         interface{}\n-\tExpectXML     string\n-\tMarshalOnly   bool\n-\tUnmarshalOnly bool\n+\tValue          interface{}\n+\tExpectXML      string\n+\tMarshalOnly    bool\n+\tMarshalError   string\n+\tUnmarshalOnly  bool\n+\tUnmarshalError string\n }{\n \t// Test nil marshals to nothing\n \t{Value: nil, ExpectXML: ``, MarshalOnly: true},\n@@ -1133,6 +1269,382 @@ var marshalTests = []struct {\n \t\tExpectXML: `<NestedAndCData><A><B></B><B></B></A><![CDATA[test]]></NestedAndCData>`,\n \t\tValue:     &NestedAndCData{AB: make([]string, 2), CDATA: \"test\"},\n \t},\n+\t// Test pointer indirection in various kinds of fields.\n+\t// https://golang.org/issue/19063\n+\t{\n+\t\tExpectXML:   `<IndirComment><T1></T1><!--hi--><T2></T2></IndirComment>`,\n+\t\tValue:       &IndirComment{Comment: stringptr(\"hi\")},\n+\t\tMarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:   `<IndirComment><T1></T1><T2></T2></IndirComment>`,\n+\t\tValue:       &IndirComment{Comment: stringptr(\"\")},\n+\t\tMarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:    `<IndirComment><T1></T1><T2></T2></IndirComment>`,\n+\t\tValue:        &IndirComment{Comment: nil},\n+\t\tMarshalError: \"xml: bad type for comment field of xml.IndirComment\",\n+\t},\n+\t{\n+\t\tExpectXML:     `<IndirComment><T1></T1><!--hi--><T2></T2></IndirComment>`,\n+\t\tValue:         &IndirComment{Comment: nil},\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:   `<IfaceComment><T1></T1><!--hi--><T2></T2></IfaceComment>`,\n+\t\tValue:       &IfaceComment{Comment: \"hi\"},\n+\t\tMarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:     `<IfaceComment><T1></T1><!--hi--><T2></T2></IfaceComment>`,\n+\t\tValue:         &IfaceComment{Comment: nil},\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:    `<IfaceComment><T1></T1><T2></T2></IfaceComment>`,\n+\t\tValue:        &IfaceComment{Comment: nil},\n+\t\tMarshalError: \"xml: bad type for comment field of xml.IfaceComment\",\n+\t},\n+\t{\n+\t\tExpectXML:     `<IfaceComment><T1></T1><T2></T2></IfaceComment>`,\n+\t\tValue:         &IfaceComment{Comment: nil},\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML: `<DirectComment><T1></T1><!--hi--><T2></T2></DirectComment>`,\n+\t\tValue:     &DirectComment{Comment: string(\"hi\")},\n+\t},\n+\t{\n+\t\tExpectXML: `<DirectComment><T1></T1><T2></T2></DirectComment>`,\n+\t\tValue:     &DirectComment{Comment: string(\"\")},\n+\t},\n+\t{\n+\t\tExpectXML: `<IndirChardata><T1></T1>hi<T2></T2></IndirChardata>`,\n+\t\tValue:     &IndirChardata{Chardata: stringptr(\"hi\")},\n+\t},\n+\t{\n+\t\tExpectXML:     `<IndirChardata><T1></T1><![CDATA[hi]]><T2></T2></IndirChardata>`,\n+\t\tValue:         &IndirChardata{Chardata: stringptr(\"hi\")},\n+\t\tUnmarshalOnly: true, // marshals without CDATA\n+\t},\n+\t{\n+\t\tExpectXML: `<IndirChardata><T1></T1><T2></T2></IndirChardata>`,\n+\t\tValue:     &IndirChardata{Chardata: stringptr(\"\")},\n+\t},\n+\t{\n+\t\tExpectXML:   `<IndirChardata><T1></T1><T2></T2></IndirChardata>`,\n+\t\tValue:       &IndirChardata{Chardata: nil},\n+\t\tMarshalOnly: true, // unmarshal leaves Chardata=stringptr(\"\")\n+\t},\n+\t{\n+\t\tExpectXML:      `<IfaceChardata><T1></T1>hi<T2></T2></IfaceChardata>`,\n+\t\tValue:          &IfaceChardata{Chardata: string(\"hi\")},\n+\t\tUnmarshalError: \"cannot unmarshal into interface {}\",\n+\t},\n+\t{\n+\t\tExpectXML:      `<IfaceChardata><T1></T1><![CDATA[hi]]><T2></T2></IfaceChardata>`,\n+\t\tValue:          &IfaceChardata{Chardata: string(\"hi\")},\n+\t\tUnmarshalOnly:  true, // marshals without CDATA\n+\t\tUnmarshalError: \"cannot unmarshal into interface {}\",\n+\t},\n+\t{\n+\t\tExpectXML:      `<IfaceChardata><T1></T1><T2></T2></IfaceChardata>`,\n+\t\tValue:          &IfaceChardata{Chardata: string(\"\")},\n+\t\tUnmarshalError: \"cannot unmarshal into interface {}\",\n+\t},\n+\t{\n+\t\tExpectXML:      `<IfaceChardata><T1></T1><T2></T2></IfaceChardata>`,\n+\t\tValue:          &IfaceChardata{Chardata: nil},\n+\t\tUnmarshalError: \"cannot unmarshal into interface {}\",\n+\t},\n+\t{\n+\t\tExpectXML: `<DirectChardata><T1></T1>hi<T2></T2></DirectChardata>`,\n+\t\tValue:     &DirectChardata{Chardata: string(\"hi\")},\n+\t},\n+\t{\n+\t\tExpectXML:     `<DirectChardata><T1></T1><![CDATA[hi]]><T2></T2></DirectChardata>`,\n+\t\tValue:         &DirectChardata{Chardata: string(\"hi\")},\n+\t\tUnmarshalOnly: true, // marshals without CDATA\n+\t},\n+\t{\n+\t\tExpectXML: `<DirectChardata><T1></T1><T2></T2></DirectChardata>`,\n+\t\tValue:     &DirectChardata{Chardata: string(\"\")},\n+\t},\n+\t{\n+\t\tExpectXML: `<IndirCDATA><T1></T1><![CDATA[hi]]><T2></T2></IndirCDATA>`,\n+\t\tValue:     &IndirCDATA{CDATA: stringptr(\"hi\")},\n+\t},\n+\t{\n+\t\tExpectXML:     `<IndirCDATA><T1></T1>hi<T2></T2></IndirCDATA>`,\n+\t\tValue:         &IndirCDATA{CDATA: stringptr(\"hi\")},\n+\t\tUnmarshalOnly: true, // marshals with CDATA\n+\t},\n+\t{\n+\t\tExpectXML: `<IndirCDATA><T1></T1><T2></T2></IndirCDATA>`,\n+\t\tValue:     &IndirCDATA{CDATA: stringptr(\"\")},\n+\t},\n+\t{\n+\t\tExpectXML:   `<IndirCDATA><T1></T1><T2></T2></IndirCDATA>`,\n+\t\tValue:       &IndirCDATA{CDATA: nil},\n+\t\tMarshalOnly: true, // unmarshal leaves CDATA=stringptr(\"\")\n+\t},\n+\t{\n+\t\tExpectXML:      `<IfaceCDATA><T1></T1><![CDATA[hi]]><T2></T2></IfaceCDATA>`,\n+\t\tValue:          &IfaceCDATA{CDATA: string(\"hi\")},\n+\t\tUnmarshalError: \"cannot unmarshal into interface {}\",\n+\t},\n+\t{\n+\t\tExpectXML:      `<IfaceCDATA><T1></T1>hi<T2></T2></IfaceCDATA>`,\n+\t\tValue:          &IfaceCDATA{CDATA: string(\"hi\")},\n+\t\tUnmarshalOnly:  true, // marshals with CDATA\n+\t\tUnmarshalError: \"cannot unmarshal into interface {}\",\n+\t},\n+\t{\n+\t\tExpectXML:      `<IfaceCDATA><T1></T1><T2></T2></IfaceCDATA>`,\n+\t\tValue:          &IfaceCDATA{CDATA: string(\"\")},\n+\t\tUnmarshalError: \"cannot unmarshal into interface {}\",\n+\t},\n+\t{\n+\t\tExpectXML:      `<IfaceCDATA><T1></T1><T2></T2></IfaceCDATA>`,\n+\t\tValue:          &IfaceCDATA{CDATA: nil},\n+\t\tUnmarshalError: \"cannot unmarshal into interface {}\",\n+\t},\n+\t{\n+\t\tExpectXML: `<DirectCDATA><T1></T1><![CDATA[hi]]><T2></T2></DirectCDATA>`,\n+\t\tValue:     &DirectCDATA{CDATA: string(\"hi\")},\n+\t},\n+\t{\n+\t\tExpectXML:     `<DirectCDATA><T1></T1>hi<T2></T2></DirectCDATA>`,\n+\t\tValue:         &DirectCDATA{CDATA: string(\"hi\")},\n+\t\tUnmarshalOnly: true, // marshals with CDATA\n+\t},\n+\t{\n+\t\tExpectXML: `<DirectCDATA><T1></T1><T2></T2></DirectCDATA>`,\n+\t\tValue:     &DirectCDATA{CDATA: string(\"\")},\n+\t},\n+\t{\n+\t\tExpectXML:   `<IndirInnerXML><T1></T1><hi/><T2></T2></IndirInnerXML>`,\n+\t\tValue:       &IndirInnerXML{InnerXML: stringptr(\"<hi/>\")},\n+\t\tMarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:   `<IndirInnerXML><T1></T1><T2></T2></IndirInnerXML>`,\n+\t\tValue:       &IndirInnerXML{InnerXML: stringptr(\"\")},\n+\t\tMarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML: `<IndirInnerXML><T1></T1><T2></T2></IndirInnerXML>`,\n+\t\tValue:     &IndirInnerXML{InnerXML: nil},\n+\t},\n+\t{\n+\t\tExpectXML:     `<IndirInnerXML><T1></T1><hi/><T2></T2></IndirInnerXML>`,\n+\t\tValue:         &IndirInnerXML{InnerXML: nil},\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:   `<IfaceInnerXML><T1></T1><hi/><T2></T2></IfaceInnerXML>`,\n+\t\tValue:       &IfaceInnerXML{InnerXML: \"<hi/>\"},\n+\t\tMarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:     `<IfaceInnerXML><T1></T1><hi/><T2></T2></IfaceInnerXML>`,\n+\t\tValue:         &IfaceInnerXML{InnerXML: nil},\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML: `<IfaceInnerXML><T1></T1><T2></T2></IfaceInnerXML>`,\n+\t\tValue:     &IfaceInnerXML{InnerXML: nil},\n+\t},\n+\t{\n+\t\tExpectXML:     `<IfaceInnerXML><T1></T1><T2></T2></IfaceInnerXML>`,\n+\t\tValue:         &IfaceInnerXML{InnerXML: nil},\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:   `<DirectInnerXML><T1></T1><hi/><T2></T2></DirectInnerXML>`,\n+\t\tValue:       &DirectInnerXML{InnerXML: string(\"<hi/>\")},\n+\t\tMarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:     `<DirectInnerXML><T1></T1><hi/><T2></T2></DirectInnerXML>`,\n+\t\tValue:         &DirectInnerXML{InnerXML: string(\"<T1></T1><hi/><T2></T2>\")},\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:   `<DirectInnerXML><T1></T1><T2></T2></DirectInnerXML>`,\n+\t\tValue:       &DirectInnerXML{InnerXML: string(\"\")},\n+\t\tMarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:     `<DirectInnerXML><T1></T1><T2></T2></DirectInnerXML>`,\n+\t\tValue:         &DirectInnerXML{InnerXML: string(\"<T1></T1><T2></T2>\")},\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML: `<IndirElement><T1></T1><Element>hi</Element><T2></T2></IndirElement>`,\n+\t\tValue:     &IndirElement{Element: stringptr(\"hi\")},\n+\t},\n+\t{\n+\t\tExpectXML: `<IndirElement><T1></T1><Element></Element><T2></T2></IndirElement>`,\n+\t\tValue:     &IndirElement{Element: stringptr(\"\")},\n+\t},\n+\t{\n+\t\tExpectXML: `<IndirElement><T1></T1><T2></T2></IndirElement>`,\n+\t\tValue:     &IndirElement{Element: nil},\n+\t},\n+\t{\n+\t\tExpectXML:   `<IfaceElement><T1></T1><Element>hi</Element><T2></T2></IfaceElement>`,\n+\t\tValue:       &IfaceElement{Element: \"hi\"},\n+\t\tMarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:     `<IfaceElement><T1></T1><Element>hi</Element><T2></T2></IfaceElement>`,\n+\t\tValue:         &IfaceElement{Element: nil},\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML: `<IfaceElement><T1></T1><T2></T2></IfaceElement>`,\n+\t\tValue:     &IfaceElement{Element: nil},\n+\t},\n+\t{\n+\t\tExpectXML:     `<IfaceElement><T1></T1><T2></T2></IfaceElement>`,\n+\t\tValue:         &IfaceElement{Element: nil},\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML: `<DirectElement><T1></T1><Element>hi</Element><T2></T2></DirectElement>`,\n+\t\tValue:     &DirectElement{Element: string(\"hi\")},\n+\t},\n+\t{\n+\t\tExpectXML: `<DirectElement><T1></T1><Element></Element><T2></T2></DirectElement>`,\n+\t\tValue:     &DirectElement{Element: string(\"\")},\n+\t},\n+\t{\n+\t\tExpectXML: `<IndirOmitEmpty><T1></T1><OmitEmpty>hi</OmitEmpty><T2></T2></IndirOmitEmpty>`,\n+\t\tValue:     &IndirOmitEmpty{OmitEmpty: stringptr(\"hi\")},\n+\t},\n+\t{\n+\t\t// Note: Changed in Go 1.8 to include <OmitEmpty> element (because x.OmitEmpty != nil).\n+\t\tExpectXML:   `<IndirOmitEmpty><T1></T1><OmitEmpty></OmitEmpty><T2></T2></IndirOmitEmpty>`,\n+\t\tValue:       &IndirOmitEmpty{OmitEmpty: stringptr(\"\")},\n+\t\tMarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:     `<IndirOmitEmpty><T1></T1><OmitEmpty></OmitEmpty><T2></T2></IndirOmitEmpty>`,\n+\t\tValue:         &IndirOmitEmpty{OmitEmpty: stringptr(\"\")},\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML: `<IndirOmitEmpty><T1></T1><T2></T2></IndirOmitEmpty>`,\n+\t\tValue:     &IndirOmitEmpty{OmitEmpty: nil},\n+\t},\n+\t{\n+\t\tExpectXML:   `<IfaceOmitEmpty><T1></T1><OmitEmpty>hi</OmitEmpty><T2></T2></IfaceOmitEmpty>`,\n+\t\tValue:       &IfaceOmitEmpty{OmitEmpty: \"hi\"},\n+\t\tMarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:     `<IfaceOmitEmpty><T1></T1><OmitEmpty>hi</OmitEmpty><T2></T2></IfaceOmitEmpty>`,\n+\t\tValue:         &IfaceOmitEmpty{OmitEmpty: nil},\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML: `<IfaceOmitEmpty><T1></T1><T2></T2></IfaceOmitEmpty>`,\n+\t\tValue:     &IfaceOmitEmpty{OmitEmpty: nil},\n+\t},\n+\t{\n+\t\tExpectXML:     `<IfaceOmitEmpty><T1></T1><T2></T2></IfaceOmitEmpty>`,\n+\t\tValue:         &IfaceOmitEmpty{OmitEmpty: nil},\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML: `<DirectOmitEmpty><T1></T1><OmitEmpty>hi</OmitEmpty><T2></T2></DirectOmitEmpty>`,\n+\t\tValue:     &DirectOmitEmpty{OmitEmpty: string(\"hi\")},\n+\t},\n+\t{\n+\t\tExpectXML: `<DirectOmitEmpty><T1></T1><T2></T2></DirectOmitEmpty>`,\n+\t\tValue:     &DirectOmitEmpty{OmitEmpty: string(\"\")},\n+\t},\n+\t{\n+\t\tExpectXML: `<IndirAny><T1></T1><Any>hi</Any><T2></T2></IndirAny>`,\n+\t\tValue:     &IndirAny{Any: stringptr(\"hi\")},\n+\t},\n+\t{\n+\t\tExpectXML: `<IndirAny><T1></T1><Any></Any><T2></T2></IndirAny>`,\n+\t\tValue:     &IndirAny{Any: stringptr(\"\")},\n+\t},\n+\t{\n+\t\tExpectXML: `<IndirAny><T1></T1><T2></T2></IndirAny>`,\n+\t\tValue:     &IndirAny{Any: nil},\n+\t},\n+\t{\n+\t\tExpectXML:   `<IfaceAny><T1></T1><Any>hi</Any><T2></T2></IfaceAny>`,\n+\t\tValue:       &IfaceAny{Any: \"hi\"},\n+\t\tMarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:     `<IfaceAny><T1></T1><Any>hi</Any><T2></T2></IfaceAny>`,\n+\t\tValue:         &IfaceAny{Any: nil},\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML: `<IfaceAny><T1></T1><T2></T2></IfaceAny>`,\n+\t\tValue:     &IfaceAny{Any: nil},\n+\t},\n+\t{\n+\t\tExpectXML:     `<IfaceAny><T1></T1><T2></T2></IfaceAny>`,\n+\t\tValue:         &IfaceAny{Any: nil},\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML: `<DirectAny><T1></T1><Any>hi</Any><T2></T2></DirectAny>`,\n+\t\tValue:     &DirectAny{Any: string(\"hi\")},\n+\t},\n+\t{\n+\t\tExpectXML: `<DirectAny><T1></T1><Any></Any><T2></T2></DirectAny>`,\n+\t\tValue:     &DirectAny{Any: string(\"\")},\n+\t},\n+\t{\n+\t\tExpectXML:     `<IndirFoo><T1></T1><Foo>hi</Foo><T2></T2></IndirFoo>`,\n+\t\tValue:         &IndirAny{Any: stringptr(\"hi\")},\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:     `<IndirFoo><T1></T1><Foo></Foo><T2></T2></IndirFoo>`,\n+\t\tValue:         &IndirAny{Any: stringptr(\"\")},\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:     `<IndirFoo><T1></T1><T2></T2></IndirFoo>`,\n+\t\tValue:         &IndirAny{Any: nil},\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:     `<IfaceFoo><T1></T1><Foo>hi</Foo><T2></T2></IfaceFoo>`,\n+\t\tValue:         &IfaceAny{Any: nil},\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:     `<IfaceFoo><T1></T1><T2></T2></IfaceFoo>`,\n+\t\tValue:         &IfaceAny{Any: nil},\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:     `<IfaceFoo><T1></T1><T2></T2></IfaceFoo>`,\n+\t\tValue:         &IfaceAny{Any: nil},\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:     `<DirectFoo><T1></T1><Foo>hi</Foo><T2></T2></DirectFoo>`,\n+\t\tValue:         &DirectAny{Any: string(\"hi\")},\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:     `<DirectFoo><T1></T1><Foo></Foo><T2></T2></DirectFoo>`,\n+\t\tValue:         &DirectAny{Any: string(\"\")},\n+\t\tUnmarshalOnly: true,\n+\t},\n }\n \n func TestMarshal(t *testing.T) {\n@@ -1142,7 +1654,17 @@ func TestMarshal(t *testing.T) {\n \t\t}\n \t\tdata, err := Marshal(test.Value)\n \t\tif err != nil {\n-\t\t\tt.Errorf(\"#%d: marshal(%#v): %s\", idx, test.Value, err)\n+\t\t\tif test.MarshalError == \"\" {\n+\t\t\t\tt.Errorf(\"#%d: marshal(%#v): %s\", idx, test.Value, err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif !strings.Contains(err.Error(), test.MarshalError) {\n+\t\t\t\tt.Errorf(\"#%d: marshal(%#v): %s, want %q\", idx, test.Value, err, test.MarshalError)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif test.MarshalError != \"\" {\n+\t\t\tt.Errorf(\"#%d: Marshal succeeded, want error %q\", idx, test.MarshalError)\n \t\t\tcontinue\n \t\t}\n \t\tif got, want := string(data), test.ExpectXML; got != want {\n@@ -1268,8 +1790,16 @@ func TestUnmarshal(t *testing.T) {\n \t\t}\n \n \t\tif err != nil {\n-\t\t\tt.Errorf(\"#%d: unexpected error: %#v\", i, err)\n-\t\t} else if got, want := dest, test.Value; !reflect.DeepEqual(got, want) {\n+\t\t\tif test.UnmarshalError == \"\" {\n+\t\t\t\tt.Errorf(\"#%d: unmarshal(%#v): %s\", i, test.ExpectXML, err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif !strings.Contains(err.Error(), test.UnmarshalError) {\n+\t\t\t\tt.Errorf(\"#%d: unmarshal(%#v): %s, want %q\", i, test.ExpectXML, err, test.UnmarshalError)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif got, want := dest, test.Value; !reflect.DeepEqual(got, want) {\n \t\t\tt.Errorf(\"#%d: unmarshal(%q):\\nhave %#v\\nwant %#v\", i, test.ExpectXML, got, want)\n \t\t}\n \t}"}, {"sha": "4e1b29fecd997b518cee8a57905e2d7a31f2bd07", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "patch": "@@ -266,7 +266,7 @@ func defaultGOPATH() string {\n \t}\n \tif home := os.Getenv(env); home != \"\" {\n \t\tdef := filepath.Join(home, \"go\")\n-\t\tif def == runtime.GOROOT() {\n+\t\tif filepath.Clean(def) == filepath.Clean(runtime.GOROOT()) {\n \t\t\t// Don't set the default GOPATH to GOROOT,\n \t\t\t// as that will trigger warnings from the go tool.\n \t\t\treturn \"\""}, {"sha": "859de7c86706c0bae9ad5e27adc10df1394f7fe3", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "patch": "@@ -2481,17 +2481,24 @@ func TestNumMethodOnDDD(t *testing.T) {\n }\n \n func TestPtrTo(t *testing.T) {\n+\t// This block of code means that the ptrToThis field of the\n+\t// reflect data for *unsafe.Pointer is non zero, see\n+\t// https://golang.org/issue/19003\n+\tvar x unsafe.Pointer\n+\tvar y = &x\n+\tvar z = &y\n+\n \tvar i int\n \n-\ttyp := TypeOf(i)\n+\ttyp := TypeOf(z)\n \tfor i = 0; i < 100; i++ {\n \t\ttyp = PtrTo(typ)\n \t}\n \tfor i = 0; i < 100; i++ {\n \t\ttyp = typ.Elem()\n \t}\n-\tif typ != TypeOf(i) {\n-\t\tt.Errorf(\"after 100 PtrTo and Elem, have %s, want %s\", typ, TypeOf(i))\n+\tif typ != TypeOf(z) {\n+\t\tt.Errorf(\"after 100 PtrTo and Elem, have %s, want %s\", typ, TypeOf(z))\n \t}\n }\n "}, {"sha": "0325260455682a88ee2c1ea8d54fcb41e516babc", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "patch": "@@ -1174,6 +1174,7 @@ func (t *rtype) ptrTo() *rtype {\n \tpp := *prototype\n \n \tpp.string = &s\n+\tpp.ptrToThis = nil\n \n \t// For the type structures linked into the binary, the\n \t// compiler provides a good hash of the string."}, {"sha": "3da82961b9b74a21d5fe6da480e55d38a91180bf", "filename": "libgo/go/runtime/testdata/testprogcgo/threadpprof.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Fthreadpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Fthreadpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Fthreadpprof.go?ref=00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "patch": "@@ -61,7 +61,7 @@ static void* cpuHogDriver(void* arg __attribute__ ((unused))) {\n \treturn 0;\n }\n \n-void runCPUHogThread() {\n+void runCPUHogThread(void) {\n \tpthread_t tid;\n \tpthread_create(&tid, 0, cpuHogDriver, 0);\n }"}, {"sha": "2a023f66caeb74f49933e2f9111b20beac3faa69", "filename": "libgo/go/runtime/testdata/testprogcgo/traceback.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Ftraceback.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Ftraceback.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Ftraceback.go?ref=00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "patch": "@@ -15,16 +15,16 @@ package main\n \n char *p;\n \n-static int f3() {\n+static int f3(void) {\n \t*p = 0;\n \treturn 0;\n }\n \n-static int f2() {\n+static int f2(void) {\n \treturn f3();\n }\n \n-static int f1() {\n+static int f1(void) {\n \treturn f2();\n }\n "}, {"sha": "b002aa0bf10a850ce702413b4a49db145c9939c3", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "patch": "@@ -821,6 +821,7 @@ func (m *M) Run() int {\n \thaveExamples = len(m.examples) > 0\n \ttestRan, testOk := runTests(m.deps.MatchString, m.tests)\n \texampleRan, exampleOk := runExamples(m.deps.MatchString, m.examples)\n+\tstopAlarm()\n \tif !testRan && !exampleRan && *matchBenchmarks == \"\" {\n \t\tfmt.Fprintln(os.Stderr, \"testing: warning: no tests to run\")\n \t}"}, {"sha": "3a97ee1d4adc5b65195ce9d2e191e003e07ee475", "filename": "libgo/runtime/go-unsafe-pointer.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fruntime%2Fgo-unsafe-pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b2a30fd4df92fe5ea879295d65c55bf1725fcb/libgo%2Fruntime%2Fgo-unsafe-pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-unsafe-pointer.c?ref=00b2a30fd4df92fe5ea879295d65c55bf1725fcb", "patch": "@@ -85,6 +85,12 @@ static const String preflection_string =\n   sizeof PREFLECTION - 1,\n };\n \n+extern const uintptr pointer_unsafe_Pointer_gc[]\n+  __asm__ (GOSYM_PREFIX \"__go_td_pN14_unsafe.Pointer$gc\");\n+\n+const uintptr pointer_unsafe_Pointer_gc[] __attribute__((aligned(4))) =\n+  {sizeof(void*), GC_APTR, 0, GC_END};\n+\n const struct __go_ptr_type pointer_unsafe_Pointer =\n {\n   /* __common */\n@@ -104,7 +110,7 @@ const struct __go_ptr_type pointer_unsafe_Pointer =\n     /* __equalfn */\n     &runtime_pointerequal_descriptor,\n     /* __gc */\n-    unsafe_Pointer_gc,\n+    pointer_unsafe_Pointer_gc,\n     /* __reflection */\n     &preflection_string,\n     /* __uncommon */"}]}