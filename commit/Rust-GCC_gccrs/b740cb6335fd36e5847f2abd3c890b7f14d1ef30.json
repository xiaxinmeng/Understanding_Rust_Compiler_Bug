{"sha": "b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc0MGNiNjMzNWZkMzZlNTg0N2YyYWJkM2M4OTBiN2YxNGQxZWYzMA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-11-29T23:02:54Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-11-29T23:02:54Z"}, "message": "libgo: update to weekly.2011-10-25\n\nChanges were mainly straightforward to merge.\n\nFrom-SVN: r181824", "tree": {"sha": "3cbc69464b9e65b6abf2f6adbda2845f1577b756", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3cbc69464b9e65b6abf2f6adbda2845f1577b756"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/comments", "author": null, "committer": null, "parents": [{"sha": "cebc182b78fd3be5396fb772f3b12a9096fc73ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cebc182b78fd3be5396fb772f3b12a9096fc73ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cebc182b78fd3be5396fb772f3b12a9096fc73ab"}], "stats": {"total": 9113, "additions": 5187, "deletions": 3926}, "files": [{"sha": "2a86f2f86edc1cc3f401ed3d4deec693d3422003", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -1,4 +1,4 @@\n-6d7136d74b65\n+941b8015061a\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "5ab10a61f3db3e4f45fbab8ffac31410dc0093b4", "filename": "libgo/Makefile.am", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -236,11 +236,19 @@ toolexeclibgoencoding_DATA = \\\n \tencoding/hex.gox \\\n \tencoding/pem.gox\n \n+if LIBGO_IS_LINUX\n+# exp_inotify_gox = exp/inotify.gox\n+exp_inotify_gox =\n+else\n+exp_inotify_gox =\n+endif\n+\n toolexeclibgoexpdir = $(toolexeclibgodir)/exp\n \n toolexeclibgoexp_DATA = \\\n \texp/ebnf.gox \\\n \texp/gui.gox \\\n+\t$(exp_inotify_gox) \\\n \texp/norm.gox \\\n \texp/spdy.gox \\\n \texp/sql.gox \\\n@@ -332,15 +340,7 @@ toolexeclibgoold_DATA = \\\n \n toolexeclibgoosdir = $(toolexeclibgodir)/os\n \n-if LIBGO_IS_LINUX\n-# os_inotify_gox = os/inotify.gox\n-os_inotify_gox =\n-else\n-os_inotify_gox =\n-endif\n-\n toolexeclibgoos_DATA = \\\n-\t$(os_inotify_gox) \\\n \tos/user.gox \\\n \tos/signal.gox\n \n@@ -1212,6 +1212,8 @@ go_exp_ebnf_files = \\\n \tgo/exp/ebnf/parser.go\n go_exp_gui_files = \\\n \tgo/exp/gui/gui.go\n+go_exp_inotify_files = \\\n+\tgo/exp/inotify/inotify_linux.go\n go_exp_norm_files = \\\n \tgo/exp/norm/composition.go \\\n \tgo/exp/norm/forminfo.go \\\n@@ -1229,11 +1231,13 @@ go_exp_sql_files = \\\n \tgo/exp/sql/sql.go\n go_exp_ssh_files = \\\n \tgo/exp/ssh/channel.go \\\n+\tgo/exp/ssh/client.go \\\n \tgo/exp/ssh/common.go \\\n \tgo/exp/ssh/doc.go \\\n \tgo/exp/ssh/messages.go \\\n \tgo/exp/ssh/server.go \\\n \tgo/exp/ssh/server_shell.go \\\n+\tgo/exp/ssh/session.go \\\n \tgo/exp/ssh/transport.go\n go_exp_terminal_files = \\\n \tgo/exp/terminal/shell.go \\\n@@ -1387,9 +1391,6 @@ go_old_template_files = \\\n \tgo/old/template/format.go \\\n \tgo/old/template/parse.go\n \n-go_os_inotify_files = \\\n-\tgo/os/inotify/inotify_linux.go\n-\n go_os_user_files = \\\n \tgo/os/user/user.go \\\n \tgo/os/user/lookup_unix.go\n@@ -2723,6 +2724,13 @@ exp/gui/x11/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/gui/x11/check\n \n+exp/inotify.lo: $(go_exp_inotify_files) fmt.gox os.gox strings.gox syscall.gox\n+\t$(BUILDPACKAGE)\n+exp/inotify/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/inotify\n+\t@$(CHECK)\n+.PHONY: exp/inotify/check\n+\n exp/sql/driver.lo: $(go_exp_sql_driver_files) fmt.gox os.gox reflect.gox \\\n \t\tstrconv.gox\n \t$(BUILDPACKAGE)\n@@ -2998,13 +3006,6 @@ old/template/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: old/template/check\n \n-os/inotify.lo: $(go_os_inotify_files) fmt.gox os.gox strings.gox syscall.gox\n-\t$(BUILDPACKAGE)\n-os/inotify/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) os/inotify\n-\t@$(CHECK)\n-.PHONY: os/inotify/check\n-\n os/user.lo: $(go_os_user_files) fmt.gox os.gox runtime.gox strconv.gox \\\n \t\tstrings.gox syscall.gox\n \t$(BUILDPACKAGE)\n@@ -3331,6 +3332,8 @@ exp/ebnf.gox: exp/ebnf.lo\n \t$(BUILDGOX)\n exp/gui.gox: exp/gui.lo\n \t$(BUILDGOX)\n+exp/inotify.gox: exp/inotify.lo\n+\t$(BUILDGOX)\n exp/norm.gox: exp/norm.lo\n \t$(BUILDGOX)\n exp/spdy.gox: exp/spdy.lo\n@@ -3424,8 +3427,6 @@ old/regexp.gox: old/regexp.lo\n old/template.gox: old/template.lo\n \t$(BUILDGOX)\n \n-os/inotify.gox: os/inotify.lo\n-\t$(BUILDGOX)\n os/user.gox: os/user.lo\n \t$(BUILDGOX)\n os/signal.gox: os/signal.lo\n@@ -3459,10 +3460,10 @@ testing/script.gox: testing/script.lo\n \t$(BUILDGOX)\n \n if LIBGO_IS_LINUX\n-# os_inotify_check = os/inotify/check\n-os_inotify_check =\n+# exp_inotify_check = exp/inotify/check\n+exp_inotify_check =\n else\n-os_inotify_check =\n+exp_inotify_check =\n endif\n \n TEST_PACKAGES = \\\n@@ -3563,6 +3564,7 @@ TEST_PACKAGES = \\\n \tencoding/hex/check \\\n \tencoding/pem/check \\\n \texp/ebnf/check \\\n+\t$(exp_inotify_check) \\\n \texp/norm/check \\\n \texp/spdy/check \\\n \texp/sql/check \\\n@@ -3594,7 +3596,6 @@ TEST_PACKAGES = \\\n \told/netchan/check \\\n \told/regexp/check \\\n \told/template/check \\\n-\t$(os_inotify_check) \\\n \tos/user/check \\\n \tos/signal/check \\\n \tpath/filepath/check \\"}, {"sha": "f7c293a66ccc4c9d1e8c7d6912d4f7f349add3fb", "filename": "libgo/Makefile.in", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -699,10 +699,15 @@ toolexeclibgoencoding_DATA = \\\n \tencoding/hex.gox \\\n \tencoding/pem.gox\n \n+@LIBGO_IS_LINUX_FALSE@exp_inotify_gox = \n+\n+# exp_inotify_gox = exp/inotify.gox\n+@LIBGO_IS_LINUX_TRUE@exp_inotify_gox = \n toolexeclibgoexpdir = $(toolexeclibgodir)/exp\n toolexeclibgoexp_DATA = \\\n \texp/ebnf.gox \\\n \texp/gui.gox \\\n+\t$(exp_inotify_gox) \\\n \texp/norm.gox \\\n \texp/spdy.gox \\\n \texp/sql.gox \\\n@@ -781,12 +786,7 @@ toolexeclibgoold_DATA = \\\n \told/template.gox\n \n toolexeclibgoosdir = $(toolexeclibgodir)/os\n-@LIBGO_IS_LINUX_FALSE@os_inotify_gox = \n-\n-# os_inotify_gox = os/inotify.gox\n-@LIBGO_IS_LINUX_TRUE@os_inotify_gox = \n toolexeclibgoos_DATA = \\\n-\t$(os_inotify_gox) \\\n \tos/user.gox \\\n \tos/signal.gox\n \n@@ -1579,6 +1579,9 @@ go_exp_ebnf_files = \\\n go_exp_gui_files = \\\n \tgo/exp/gui/gui.go\n \n+go_exp_inotify_files = \\\n+\tgo/exp/inotify/inotify_linux.go\n+\n go_exp_norm_files = \\\n \tgo/exp/norm/composition.go \\\n \tgo/exp/norm/forminfo.go \\\n@@ -1599,11 +1602,13 @@ go_exp_sql_files = \\\n \n go_exp_ssh_files = \\\n \tgo/exp/ssh/channel.go \\\n+\tgo/exp/ssh/client.go \\\n \tgo/exp/ssh/common.go \\\n \tgo/exp/ssh/doc.go \\\n \tgo/exp/ssh/messages.go \\\n \tgo/exp/ssh/server.go \\\n \tgo/exp/ssh/server_shell.go \\\n+\tgo/exp/ssh/session.go \\\n \tgo/exp/ssh/transport.go\n \n go_exp_terminal_files = \\\n@@ -1773,9 +1778,6 @@ go_old_template_files = \\\n \tgo/old/template/format.go \\\n \tgo/old/template/parse.go\n \n-go_os_inotify_files = \\\n-\tgo/os/inotify/inotify_linux.go\n-\n go_os_user_files = \\\n \tgo/os/user/user.go \\\n \tgo/os/user/lookup_unix.go\n@@ -2171,10 +2173,10 @@ BUILDGOX = \\\n \tf=`echo $< | sed -e 's/.lo$$/.o/'`; \\\n \t$(OBJCOPY) -j .go_export $$f $@.tmp && mv -f $@.tmp $@\n \n-@LIBGO_IS_LINUX_FALSE@os_inotify_check = \n+@LIBGO_IS_LINUX_FALSE@exp_inotify_check = \n \n-# os_inotify_check = os/inotify/check\n-@LIBGO_IS_LINUX_TRUE@os_inotify_check = \n+# exp_inotify_check = exp/inotify/check\n+@LIBGO_IS_LINUX_TRUE@exp_inotify_check = \n TEST_PACKAGES = \\\n \tasn1/check \\\n \tbig/check \\\n@@ -2273,6 +2275,7 @@ TEST_PACKAGES = \\\n \tencoding/hex/check \\\n \tencoding/pem/check \\\n \texp/ebnf/check \\\n+\t$(exp_inotify_check) \\\n \texp/norm/check \\\n \texp/spdy/check \\\n \texp/sql/check \\\n@@ -2304,7 +2307,6 @@ TEST_PACKAGES = \\\n \told/netchan/check \\\n \told/regexp/check \\\n \told/template/check \\\n-\t$(os_inotify_check) \\\n \tos/user/check \\\n \tos/signal/check \\\n \tpath/filepath/check \\\n@@ -5326,6 +5328,13 @@ exp/gui/x11/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/gui/x11/check\n \n+exp/inotify.lo: $(go_exp_inotify_files) fmt.gox os.gox strings.gox syscall.gox\n+\t$(BUILDPACKAGE)\n+exp/inotify/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/inotify\n+\t@$(CHECK)\n+.PHONY: exp/inotify/check\n+\n exp/sql/driver.lo: $(go_exp_sql_driver_files) fmt.gox os.gox reflect.gox \\\n \t\tstrconv.gox\n \t$(BUILDPACKAGE)\n@@ -5601,13 +5610,6 @@ old/template/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: old/template/check\n \n-os/inotify.lo: $(go_os_inotify_files) fmt.gox os.gox strings.gox syscall.gox\n-\t$(BUILDPACKAGE)\n-os/inotify/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) os/inotify\n-\t@$(CHECK)\n-.PHONY: os/inotify/check\n-\n os/user.lo: $(go_os_user_files) fmt.gox os.gox runtime.gox strconv.gox \\\n \t\tstrings.gox syscall.gox\n \t$(BUILDPACKAGE)\n@@ -5929,6 +5931,8 @@ exp/ebnf.gox: exp/ebnf.lo\n \t$(BUILDGOX)\n exp/gui.gox: exp/gui.lo\n \t$(BUILDGOX)\n+exp/inotify.gox: exp/inotify.lo\n+\t$(BUILDGOX)\n exp/norm.gox: exp/norm.lo\n \t$(BUILDGOX)\n exp/spdy.gox: exp/spdy.lo\n@@ -6022,8 +6026,6 @@ old/regexp.gox: old/regexp.lo\n old/template.gox: old/template.lo\n \t$(BUILDGOX)\n \n-os/inotify.gox: os/inotify.lo\n-\t$(BUILDGOX)\n os/user.gox: os/user.lo\n \t$(BUILDGOX)\n os/signal.gox: os/signal.lo"}, {"sha": "b0dde1e6e372505b99c804adc800fea9e8d2a002", "filename": "libgo/go/big/int.go", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fbig%2Fint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fbig%2Fint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fint.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -58,22 +58,24 @@ func NewInt(x int64) *Int {\n \n // Set sets z to x and returns z.\n func (z *Int) Set(x *Int) *Int {\n-\tz.abs = z.abs.set(x.abs)\n-\tz.neg = x.neg\n+\tif z != x {\n+\t\tz.abs = z.abs.set(x.abs)\n+\t\tz.neg = x.neg\n+\t}\n \treturn z\n }\n \n // Abs sets z to |x| (the absolute value of x) and returns z.\n func (z *Int) Abs(x *Int) *Int {\n-\tz.abs = z.abs.set(x.abs)\n+\tz.Set(x)\n \tz.neg = false\n \treturn z\n }\n \n // Neg sets z to -x and returns z.\n func (z *Int) Neg(x *Int) *Int {\n-\tz.abs = z.abs.set(x.abs)\n-\tz.neg = len(z.abs) > 0 && !x.neg // 0 has no sign\n+\tz.Set(x)\n+\tz.neg = len(z.abs) > 0 && !z.neg // 0 has no sign\n \treturn z\n }\n \n@@ -174,7 +176,7 @@ func (z *Int) Quo(x, y *Int) *Int {\n // If y == 0, a division-by-zero run-time panic occurs.\n // Rem implements truncated modulus (like Go); see QuoRem for more details.\n func (z *Int) Rem(x, y *Int) *Int {\n-\t_, z.abs = nat(nil).div(z.abs, x.abs, y.abs)\n+\t_, z.abs = nat{}.div(z.abs, x.abs, y.abs)\n \tz.neg = len(z.abs) > 0 && x.neg // 0 has no sign\n \treturn z\n }\n@@ -422,8 +424,8 @@ func (x *Int) Format(s fmt.State, ch int) {\n // scan sets z to the integer value corresponding to the longest possible prefix\n // read from r representing a signed integer number in a given conversion base.\n // It returns z, the actual conversion base used, and an error, if any. In the\n-// error case, the value of z is undefined. The syntax follows the syntax of\n-// integer literals in Go.\n+// error case, the value of z is undefined but the returned value is nil. The\n+// syntax follows the syntax of integer literals in Go.\n //\n // The base argument must be 0 or a value from 2 through MaxBase. If the base\n // is 0, the string prefix determines the actual conversion base. A prefix of\n@@ -434,7 +436,7 @@ func (z *Int) scan(r io.RuneScanner, base int) (*Int, int, os.Error) {\n \t// determine sign\n \tch, _, err := r.ReadRune()\n \tif err != nil {\n-\t\treturn z, 0, err\n+\t\treturn nil, 0, err\n \t}\n \tneg := false\n \tswitch ch {\n@@ -448,7 +450,7 @@ func (z *Int) scan(r io.RuneScanner, base int) (*Int, int, os.Error) {\n \t// determine mantissa\n \tz.abs, base, err = z.abs.scan(r, base)\n \tif err != nil {\n-\t\treturn z, base, err\n+\t\treturn nil, base, err\n \t}\n \tz.neg = len(z.abs) > 0 && neg // 0 has no sign\n \n@@ -497,7 +499,7 @@ func (x *Int) Int64() int64 {\n \n // SetString sets z to the value of s, interpreted in the given base,\n // and returns z and a boolean indicating success. If SetString fails,\n-// the value of z is undefined.\n+// the value of z is undefined but the returned value is nil.\n //\n // The base argument must be 0 or a value from 2 through MaxBase. If the base\n // is 0, the string prefix determines the actual conversion base. A prefix of\n@@ -508,10 +510,13 @@ func (z *Int) SetString(s string, base int) (*Int, bool) {\n \tr := strings.NewReader(s)\n \t_, _, err := z.scan(r, base)\n \tif err != nil {\n-\t\treturn z, false\n+\t\treturn nil, false\n \t}\n \t_, _, err = r.ReadRune()\n-\treturn z, err == os.EOF // err == os.EOF => scan consumed all of s\n+\tif err != os.EOF {\n+\t\treturn nil, false\n+\t}\n+\treturn z, true // err == os.EOF => scan consumed all of s\n }\n \n // SetBytes interprets buf as the bytes of a big-endian unsigned"}, {"sha": "fde19c23b720ef08915401fdda59fb0587e6e3a6", "filename": "libgo/go/big/int_test.go", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fbig%2Fint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fbig%2Fint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fint_test.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -311,7 +311,16 @@ func TestSetString(t *testing.T) {\n \t\t\tt.Errorf(\"#%d (input '%s') ok incorrect (should be %t)\", i, test.in, test.ok)\n \t\t\tcontinue\n \t\t}\n-\t\tif !ok1 || !ok2 {\n+\t\tif !ok1 {\n+\t\t\tif n1 != nil {\n+\t\t\t\tt.Errorf(\"#%d (input '%s') n1 != nil\", i, test.in)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !ok2 {\n+\t\t\tif n2 != nil {\n+\t\t\t\tt.Errorf(\"#%d (input '%s') n2 != nil\", i, test.in)\n+\t\t\t}\n \t\t\tcontinue\n \t\t}\n "}, {"sha": "c0769d88a91ae40f53e472154bda8a9f3104a8df", "filename": "libgo/go/big/nat.go", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fbig%2Fnat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fbig%2Fnat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fnat.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -35,7 +35,7 @@ import (\n // During arithmetic operations, denormalized values may occur but are\n // always normalized before returning the final result. The normalized\n // representation of 0 is the empty or nil slice (length = 0).\n-\n+//\n type nat []Word\n \n var (\n@@ -447,10 +447,10 @@ func (z nat) mulRange(a, b uint64) nat {\n \tcase a == b:\n \t\treturn z.setUint64(a)\n \tcase a+1 == b:\n-\t\treturn z.mul(nat(nil).setUint64(a), nat(nil).setUint64(b))\n+\t\treturn z.mul(nat{}.setUint64(a), nat{}.setUint64(b))\n \t}\n \tm := (a + b) / 2\n-\treturn z.mul(nat(nil).mulRange(a, m), nat(nil).mulRange(m+1, b))\n+\treturn z.mul(nat{}.mulRange(a, m), nat{}.mulRange(m+1, b))\n }\n \n // q = (x-r)/y, with 0 <= r < y\n@@ -589,7 +589,6 @@ func (x nat) bitLen() int {\n // MaxBase is the largest number base accepted for string conversions.\n const MaxBase = 'z' - 'a' + 10 + 1 // = hexValue('z') + 1\n \n-\n func hexValue(ch int) Word {\n \td := MaxBase + 1 // illegal base\n \tswitch {\n@@ -786,7 +785,7 @@ func (x nat) string(charset string) string {\n \t}\n \n \t// preserve x, create local copy for use in repeated divisions\n-\tq := nat(nil).set(x)\n+\tq := nat{}.set(x)\n \tvar r Word\n \n \t// convert\n@@ -1192,11 +1191,11 @@ func (n nat) probablyPrime(reps int) bool {\n \t\treturn false\n \t}\n \n-\tnm1 := nat(nil).sub(n, natOne)\n+\tnm1 := nat{}.sub(n, natOne)\n \t// 1<<k * q = nm1;\n \tq, k := nm1.powersOfTwoDecompose()\n \n-\tnm3 := nat(nil).sub(nm1, natTwo)\n+\tnm3 := nat{}.sub(nm1, natTwo)\n \trand := rand.New(rand.NewSource(int64(n[0])))\n \n \tvar x, y, quotient nat"}, {"sha": "4f5732824c5b4fe8ec4606a424c3944c114ae659", "filename": "libgo/go/big/nat_test.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fbig%2Fnat_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fbig%2Fnat_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fnat_test.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -67,7 +67,7 @@ var prodNN = []argNN{\n \n func TestSet(t *testing.T) {\n \tfor _, a := range sumNN {\n-\t\tz := nat(nil).set(a.z)\n+\t\tz := nat{}.set(a.z)\n \t\tif z.cmp(a.z) != 0 {\n \t\t\tt.Errorf(\"got z = %v; want %v\", z, a.z)\n \t\t}\n@@ -129,7 +129,7 @@ var mulRangesN = []struct {\n \n func TestMulRangeN(t *testing.T) {\n \tfor i, r := range mulRangesN {\n-\t\tprod := nat(nil).mulRange(r.a, r.b).decimalString()\n+\t\tprod := nat{}.mulRange(r.a, r.b).decimalString()\n \t\tif prod != r.prod {\n \t\t\tt.Errorf(\"#%d: got %s; want %s\", i, prod, r.prod)\n \t\t}\n@@ -175,7 +175,7 @@ func toString(x nat, charset string) string {\n \ts := make([]byte, i)\n \n \t// don't destroy x\n-\tq := nat(nil).set(x)\n+\tq := nat{}.set(x)\n \n \t// convert\n \tfor len(q) > 0 {\n@@ -212,7 +212,7 @@ func TestString(t *testing.T) {\n \t\t\tt.Errorf(\"string%+v\\n\\tgot s = %s; want %s\", a, s, a.s)\n \t\t}\n \n-\t\tx, b, err := nat(nil).scan(strings.NewReader(a.s), len(a.c))\n+\t\tx, b, err := nat{}.scan(strings.NewReader(a.s), len(a.c))\n \t\tif x.cmp(a.x) != 0 {\n \t\t\tt.Errorf(\"scan%+v\\n\\tgot z = %v; want %v\", a, x, a.x)\n \t\t}\n@@ -271,7 +271,7 @@ var natScanTests = []struct {\n func TestScanBase(t *testing.T) {\n \tfor _, a := range natScanTests {\n \t\tr := strings.NewReader(a.s)\n-\t\tx, b, err := nat(nil).scan(r, a.base)\n+\t\tx, b, err := nat{}.scan(r, a.base)\n \t\tif err == nil && !a.ok {\n \t\t\tt.Errorf(\"scan%+v\\n\\texpected error\", a)\n \t\t}\n@@ -651,17 +651,17 @@ var expNNTests = []struct {\n \n func TestExpNN(t *testing.T) {\n \tfor i, test := range expNNTests {\n-\t\tx, _, _ := nat(nil).scan(strings.NewReader(test.x), 0)\n-\t\ty, _, _ := nat(nil).scan(strings.NewReader(test.y), 0)\n-\t\tout, _, _ := nat(nil).scan(strings.NewReader(test.out), 0)\n+\t\tx, _, _ := nat{}.scan(strings.NewReader(test.x), 0)\n+\t\ty, _, _ := nat{}.scan(strings.NewReader(test.y), 0)\n+\t\tout, _, _ := nat{}.scan(strings.NewReader(test.out), 0)\n \n \t\tvar m nat\n \n \t\tif len(test.m) > 0 {\n-\t\t\tm, _, _ = nat(nil).scan(strings.NewReader(test.m), 0)\n+\t\t\tm, _, _ = nat{}.scan(strings.NewReader(test.m), 0)\n \t\t}\n \n-\t\tz := nat(nil).expNN(x, y, m)\n+\t\tz := nat{}.expNN(x, y, m)\n \t\tif z.cmp(out) != 0 {\n \t\t\tt.Errorf(\"#%d got %v want %v\", i, z, out)\n \t\t}"}, {"sha": "6b8606272065d243cc086b46197638071ad548b8", "filename": "libgo/go/big/rat.go", "status": "modified", "additions": 129, "deletions": 72, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fbig%2Frat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fbig%2Frat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Frat.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -13,11 +13,11 @@ import (\n \t\"strings\"\n )\n \n-// A Rat represents a quotient a/b of arbitrary precision. The zero value for\n-// a Rat, 0/0, is not a legal Rat.\n+// A Rat represents a quotient a/b of arbitrary precision.\n+// The zero value for a Rat represents the value 0.\n type Rat struct {\n \ta Int\n-\tb nat\n+\tb nat // len(b) == 0 acts like b == 1\n }\n \n // NewRat creates a new Rat with numerator a and denominator b.\n@@ -29,8 +29,11 @@ func NewRat(a, b int64) *Rat {\n func (z *Rat) SetFrac(a, b *Int) *Rat {\n \tz.a.neg = a.neg != b.neg\n \tbabs := b.abs\n+\tif len(babs) == 0 {\n+\t\tpanic(\"division by zero\")\n+\t}\n \tif &z.a == b || alias(z.a.abs, babs) {\n-\t\tbabs = nat(nil).set(babs) // make a copy\n+\t\tbabs = nat{}.set(babs) // make a copy\n \t}\n \tz.a.abs = z.a.abs.set(a.abs)\n \tz.b = z.b.set(babs)\n@@ -40,6 +43,9 @@ func (z *Rat) SetFrac(a, b *Int) *Rat {\n // SetFrac64 sets z to a/b and returns z.\n func (z *Rat) SetFrac64(a, b int64) *Rat {\n \tz.a.SetInt64(a)\n+\tif b == 0 {\n+\t\tpanic(\"division by zero\")\n+\t}\n \tif b < 0 {\n \t\tb = -b\n \t\tz.a.neg = !z.a.neg\n@@ -51,14 +57,55 @@ func (z *Rat) SetFrac64(a, b int64) *Rat {\n // SetInt sets z to x (by making a copy of x) and returns z.\n func (z *Rat) SetInt(x *Int) *Rat {\n \tz.a.Set(x)\n-\tz.b = z.b.setWord(1)\n+\tz.b = z.b.make(0)\n \treturn z\n }\n \n // SetInt64 sets z to x and returns z.\n func (z *Rat) SetInt64(x int64) *Rat {\n \tz.a.SetInt64(x)\n-\tz.b = z.b.setWord(1)\n+\tz.b = z.b.make(0)\n+\treturn z\n+}\n+\n+// Set sets z to x (by making a copy of x) and returns z.\n+func (z *Rat) Set(x *Rat) *Rat {\n+\tif z != x {\n+\t\tz.a.Set(&x.a)\n+\t\tz.b = z.b.set(x.b)\n+\t}\n+\treturn z\n+}\n+\n+// Abs sets z to |x| (the absolute value of x) and returns z.\n+func (z *Rat) Abs(x *Rat) *Rat {\n+\tz.Set(x)\n+\tz.a.neg = false\n+\treturn z\n+}\n+\n+// Neg sets z to -x and returns z.\n+func (z *Rat) Neg(x *Rat) *Rat {\n+\tz.Set(x)\n+\tz.a.neg = len(z.a.abs) > 0 && !z.a.neg // 0 has no sign\n+\treturn z\n+}\n+\n+// Inv sets z to 1/x and returns z.\n+func (z *Rat) Inv(x *Rat) *Rat {\n+\tif len(x.a.abs) == 0 {\n+\t\tpanic(\"division by zero\")\n+\t}\n+\tz.Set(x)\n+\ta := z.b\n+\tif len(a) == 0 {\n+\t\ta = a.setWord(1) // materialize numerator\n+\t}\n+\tb := z.a.abs\n+\tif b.cmp(natOne) == 0 {\n+\t\tb = b.make(0) // normalize denominator\n+\t}\n+\tz.a.abs, z.b = a, b // sign doesn't change\n \treturn z\n }\n \n@@ -74,21 +121,24 @@ func (x *Rat) Sign() int {\n \n // IsInt returns true if the denominator of x is 1.\n func (x *Rat) IsInt() bool {\n-\treturn len(x.b) == 1 && x.b[0] == 1\n+\treturn len(x.b) == 0 || x.b.cmp(natOne) == 0\n }\n \n-// Num returns the numerator of z; it may be <= 0.\n-// The result is a reference to z's numerator; it\n-// may change if a new value is assigned to z.\n-func (z *Rat) Num() *Int {\n-\treturn &z.a\n+// Num returns the numerator of x; it may be <= 0.\n+// The result is a reference to x's numerator; it\n+// may change if a new value is assigned to x.\n+func (x *Rat) Num() *Int {\n+\treturn &x.a\n }\n \n-// Denom returns the denominator of z; it is always > 0.\n-// The result is a reference to z's denominator; it\n-// may change if a new value is assigned to z.\n-func (z *Rat) Denom() *Int {\n-\treturn &Int{false, z.b}\n+// Denom returns the denominator of x; it is always > 0.\n+// The result is a reference to x's denominator; it\n+// may change if a new value is assigned to x.\n+func (x *Rat) Denom() *Int {\n+\tif len(x.b) == 0 {\n+\t\treturn &Int{abs: nat{1}}\n+\t}\n+\treturn &Int{abs: x.b}\n }\n \n func gcd(x, y nat) nat {\n@@ -106,24 +156,47 @@ func gcd(x, y nat) nat {\n }\n \n func (z *Rat) norm() *Rat {\n-\tf := gcd(z.a.abs, z.b)\n-\tif len(z.a.abs) == 0 {\n-\t\t// z == 0\n-\t\tz.a.neg = false // normalize sign\n-\t\tz.b = z.b.setWord(1)\n-\t\treturn z\n-\t}\n-\tif f.cmp(natOne) != 0 {\n-\t\tz.a.abs, _ = z.a.abs.div(nil, z.a.abs, f)\n-\t\tz.b, _ = z.b.div(nil, z.b, f)\n+\tswitch {\n+\tcase len(z.a.abs) == 0:\n+\t\t// z == 0 - normalize sign and denominator\n+\t\tz.a.neg = false\n+\t\tz.b = z.b.make(0)\n+\tcase len(z.b) == 0:\n+\t\t// z is normalized int - nothing to do\n+\tcase z.b.cmp(natOne) == 0:\n+\t\t// z is int - normalize denominator\n+\t\tz.b = z.b.make(0)\n+\tdefault:\n+\t\tif f := gcd(z.a.abs, z.b); f.cmp(natOne) != 0 {\n+\t\t\tz.a.abs, _ = z.a.abs.div(nil, z.a.abs, f)\n+\t\t\tz.b, _ = z.b.div(nil, z.b, f)\n+\t\t}\n \t}\n \treturn z\n }\n \n-func mulNat(x *Int, y nat) *Int {\n+// mulDenom sets z to the denominator product x*y (by taking into\n+// account that 0 values for x or y must be interpreted as 1) and\n+// returns z.\n+func mulDenom(z, x, y nat) nat {\n+\tswitch {\n+\tcase len(x) == 0:\n+\t\treturn z.set(y)\n+\tcase len(y) == 0:\n+\t\treturn z.set(x)\n+\t}\n+\treturn z.mul(x, y)\n+}\n+\n+// scaleDenom computes x*f.\n+// If f == 0 (zero value of denominator), the result is (a copy of) x.\n+func scaleDenom(x *Int, f nat) *Int {\n \tvar z Int\n-\tz.abs = z.abs.mul(x.abs, y)\n-\tz.neg = len(z.abs) > 0 && x.neg\n+\tif len(f) == 0 {\n+\t\treturn z.Set(x)\n+\t}\n+\tz.abs = z.abs.mul(x.abs, f)\n+\tz.neg = x.neg\n \treturn &z\n }\n \n@@ -133,39 +206,32 @@ func mulNat(x *Int, y nat) *Int {\n //    0 if x == y\n //   +1 if x >  y\n //\n-func (x *Rat) Cmp(y *Rat) (r int) {\n-\treturn mulNat(&x.a, y.b).Cmp(mulNat(&y.a, x.b))\n-}\n-\n-// Abs sets z to |x| (the absolute value of x) and returns z.\n-func (z *Rat) Abs(x *Rat) *Rat {\n-\tz.a.Abs(&x.a)\n-\tz.b = z.b.set(x.b)\n-\treturn z\n+func (x *Rat) Cmp(y *Rat) int {\n+\treturn scaleDenom(&x.a, y.b).Cmp(scaleDenom(&y.a, x.b))\n }\n \n // Add sets z to the sum x+y and returns z.\n func (z *Rat) Add(x, y *Rat) *Rat {\n-\ta1 := mulNat(&x.a, y.b)\n-\ta2 := mulNat(&y.a, x.b)\n+\ta1 := scaleDenom(&x.a, y.b)\n+\ta2 := scaleDenom(&y.a, x.b)\n \tz.a.Add(a1, a2)\n-\tz.b = z.b.mul(x.b, y.b)\n+\tz.b = mulDenom(z.b, x.b, y.b)\n \treturn z.norm()\n }\n \n // Sub sets z to the difference x-y and returns z.\n func (z *Rat) Sub(x, y *Rat) *Rat {\n-\ta1 := mulNat(&x.a, y.b)\n-\ta2 := mulNat(&y.a, x.b)\n+\ta1 := scaleDenom(&x.a, y.b)\n+\ta2 := scaleDenom(&y.a, x.b)\n \tz.a.Sub(a1, a2)\n-\tz.b = z.b.mul(x.b, y.b)\n+\tz.b = mulDenom(z.b, x.b, y.b)\n \treturn z.norm()\n }\n \n // Mul sets z to the product x*y and returns z.\n func (z *Rat) Mul(x, y *Rat) *Rat {\n \tz.a.Mul(&x.a, &y.a)\n-\tz.b = z.b.mul(x.b, y.b)\n+\tz.b = mulDenom(z.b, x.b, y.b)\n \treturn z.norm()\n }\n \n@@ -175,28 +241,14 @@ func (z *Rat) Quo(x, y *Rat) *Rat {\n \tif len(y.a.abs) == 0 {\n \t\tpanic(\"division by zero\")\n \t}\n-\ta := mulNat(&x.a, y.b)\n-\tb := mulNat(&y.a, x.b)\n+\ta := scaleDenom(&x.a, y.b)\n+\tb := scaleDenom(&y.a, x.b)\n \tz.a.abs = a.abs\n \tz.b = b.abs\n \tz.a.neg = a.neg != b.neg\n \treturn z.norm()\n }\n \n-// Neg sets z to -x (by making a copy of x if necessary) and returns z.\n-func (z *Rat) Neg(x *Rat) *Rat {\n-\tz.a.Neg(&x.a)\n-\tz.b = z.b.set(x.b)\n-\treturn z\n-}\n-\n-// Set sets z to x (by making a copy of x if necessary) and returns z.\n-func (z *Rat) Set(x *Rat) *Rat {\n-\tz.a.Set(&x.a)\n-\tz.b = z.b.set(x.b)\n-\treturn z\n-}\n-\n func ratTok(ch int) bool {\n \treturn strings.IndexRune(\"+-/0123456789.eE\", ch) >= 0\n }\n@@ -219,23 +271,23 @@ func (z *Rat) Scan(s fmt.ScanState, ch int) os.Error {\n \n // SetString sets z to the value of s and returns z and a boolean indicating\n // success. s can be given as a fraction \"a/b\" or as a floating-point number\n-// optionally followed by an exponent. If the operation failed, the value of z\n-// is undefined.\n+// optionally followed by an exponent. If the operation failed, the value of\n+// z is undefined but the returned value is nil.\n func (z *Rat) SetString(s string) (*Rat, bool) {\n \tif len(s) == 0 {\n-\t\treturn z, false\n+\t\treturn nil, false\n \t}\n \n \t// check for a quotient\n \tsep := strings.Index(s, \"/\")\n \tif sep >= 0 {\n \t\tif _, ok := z.a.SetString(s[0:sep], 10); !ok {\n-\t\t\treturn z, false\n+\t\t\treturn nil, false\n \t\t}\n \t\ts = s[sep+1:]\n \t\tvar err os.Error\n \t\tif z.b, _, err = z.b.scan(strings.NewReader(s), 10); err != nil {\n-\t\t\treturn z, false\n+\t\t\treturn nil, false\n \t\t}\n \t\treturn z.norm(), true\n \t}\n@@ -248,10 +300,10 @@ func (z *Rat) SetString(s string) (*Rat, bool) {\n \tif e >= 0 {\n \t\tif e < sep {\n \t\t\t// The E must come after the decimal point.\n-\t\t\treturn z, false\n+\t\t\treturn nil, false\n \t\t}\n \t\tif _, ok := exp.SetString(s[e+1:], 10); !ok {\n-\t\t\treturn z, false\n+\t\t\treturn nil, false\n \t\t}\n \t\ts = s[0:e]\n \t}\n@@ -261,23 +313,27 @@ func (z *Rat) SetString(s string) (*Rat, bool) {\n \t}\n \n \tif _, ok := z.a.SetString(s, 10); !ok {\n-\t\treturn z, false\n+\t\treturn nil, false\n \t}\n \tpowTen := nat{}.expNN(natTen, exp.abs, nil)\n \tif exp.neg {\n \t\tz.b = powTen\n \t\tz.norm()\n \t} else {\n \t\tz.a.abs = z.a.abs.mul(z.a.abs, powTen)\n-\t\tz.b = z.b.setWord(1)\n+\t\tz.b = z.b.make(0)\n \t}\n \n \treturn z, true\n }\n \n // String returns a string representation of z in the form \"a/b\" (even if b == 1).\n func (z *Rat) String() string {\n-\treturn z.a.String() + \"/\" + z.b.decimalString()\n+\ts := \"/1\"\n+\tif len(z.b) != 0 {\n+\t\ts = \"/\" + z.b.decimalString()\n+\t}\n+\treturn z.a.String() + s\n }\n \n // RatString returns a string representation of z in the form \"a/b\" if b != 1,\n@@ -299,6 +355,7 @@ func (z *Rat) FloatString(prec int) string {\n \t\t}\n \t\treturn s\n \t}\n+\t// z.b != 0\n \n \tq, r := nat{}.div(nat{}, z.a.abs, z.b)\n "}, {"sha": "a95e5fea3a52097628e52358b3c52001615968ad", "filename": "libgo/go/big/rat_test.go", "status": "modified", "additions": 104, "deletions": 20, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fbig%2Frat_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fbig%2Frat_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Frat_test.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -11,6 +11,46 @@ import (\n \t\"testing\"\n )\n \n+func TestZeroRat(t *testing.T) {\n+\tvar x, y, z Rat\n+\ty.SetFrac64(0, 42)\n+\n+\tif x.Cmp(&y) != 0 {\n+\t\tt.Errorf(\"x and y should be both equal and zero\")\n+\t}\n+\n+\tif s := x.String(); s != \"0/1\" {\n+\t\tt.Errorf(\"got x = %s, want 0/1\", s)\n+\t}\n+\n+\tif s := x.RatString(); s != \"0\" {\n+\t\tt.Errorf(\"got x = %s, want 0\", s)\n+\t}\n+\n+\tz.Add(&x, &y)\n+\tif s := z.RatString(); s != \"0\" {\n+\t\tt.Errorf(\"got x+y = %s, want 0\", s)\n+\t}\n+\n+\tz.Sub(&x, &y)\n+\tif s := z.RatString(); s != \"0\" {\n+\t\tt.Errorf(\"got x-y = %s, want 0\", s)\n+\t}\n+\n+\tz.Mul(&x, &y)\n+\tif s := z.RatString(); s != \"0\" {\n+\t\tt.Errorf(\"got x*y = %s, want 0\", s)\n+\t}\n+\n+\t// check for division by zero\n+\tdefer func() {\n+\t\tif s := recover(); s == nil || s.(string) != \"division by zero\" {\n+\t\t\tpanic(s)\n+\t\t}\n+\t}()\n+\tz.Quo(&x, &y)\n+}\n+\n var setStringTests = []struct {\n \tin, out string\n \tok      bool\n@@ -50,8 +90,14 @@ func TestRatSetString(t *testing.T) {\n \tfor i, test := range setStringTests {\n \t\tx, ok := new(Rat).SetString(test.in)\n \n-\t\tif ok != test.ok || ok && x.RatString() != test.out {\n-\t\t\tt.Errorf(\"#%d got %s want %s\", i, x.RatString(), test.out)\n+\t\tif ok {\n+\t\t\tif !test.ok {\n+\t\t\t\tt.Errorf(\"#%d SetString(%q) expected failure\", i, test.in)\n+\t\t\t} else if x.RatString() != test.out {\n+\t\t\t\tt.Errorf(\"#%d SetString(%q) got %s want %s\", i, test.in, x.RatString(), test.out)\n+\t\t\t}\n+\t\t} else if x != nil {\n+\t\t\tt.Errorf(\"#%d SetString(%q) got %p want nil\", i, test.in, x)\n \t\t}\n \t}\n }\n@@ -113,8 +159,10 @@ func TestFloatString(t *testing.T) {\n func TestRatSign(t *testing.T) {\n \tzero := NewRat(0, 1)\n \tfor _, a := range setStringTests {\n-\t\tvar x Rat\n-\t\tx.SetString(a.in)\n+\t\tx, ok := new(Rat).SetString(a.in)\n+\t\tif !ok {\n+\t\t\tcontinue\n+\t\t}\n \t\ts := x.Sign()\n \t\te := x.Cmp(zero)\n \t\tif s != e {\n@@ -153,29 +201,65 @@ func TestRatCmp(t *testing.T) {\n func TestIsInt(t *testing.T) {\n \tone := NewInt(1)\n \tfor _, a := range setStringTests {\n-\t\tvar x Rat\n-\t\tx.SetString(a.in)\n+\t\tx, ok := new(Rat).SetString(a.in)\n+\t\tif !ok {\n+\t\t\tcontinue\n+\t\t}\n \t\ti := x.IsInt()\n \t\te := x.Denom().Cmp(one) == 0\n \t\tif i != e {\n-\t\t\tt.Errorf(\"got %v; want %v for z = %v\", i, e, &x)\n+\t\t\tt.Errorf(\"got IsInt(%v) == %v; want %v\", x, i, e)\n \t\t}\n \t}\n }\n \n func TestRatAbs(t *testing.T) {\n-\tzero := NewRat(0, 1)\n+\tzero := new(Rat)\n \tfor _, a := range setStringTests {\n-\t\tvar z Rat\n-\t\tz.SetString(a.in)\n-\t\tvar e Rat\n-\t\te.Set(&z)\n+\t\tx, ok := new(Rat).SetString(a.in)\n+\t\tif !ok {\n+\t\t\tcontinue\n+\t\t}\n+\t\te := new(Rat).Set(x)\n \t\tif e.Cmp(zero) < 0 {\n-\t\t\te.Sub(zero, &e)\n+\t\t\te.Sub(zero, e)\n+\t\t}\n+\t\tz := new(Rat).Abs(x)\n+\t\tif z.Cmp(e) != 0 {\n+\t\t\tt.Errorf(\"got Abs(%v) = %v; want %v\", x, z, e)\n+\t\t}\n+\t}\n+}\n+\n+func TestRatNeg(t *testing.T) {\n+\tzero := new(Rat)\n+\tfor _, a := range setStringTests {\n+\t\tx, ok := new(Rat).SetString(a.in)\n+\t\tif !ok {\n+\t\t\tcontinue\n+\t\t}\n+\t\te := new(Rat).Sub(zero, x)\n+\t\tz := new(Rat).Neg(x)\n+\t\tif z.Cmp(e) != 0 {\n+\t\t\tt.Errorf(\"got Neg(%v) = %v; want %v\", x, z, e)\n+\t\t}\n+\t}\n+}\n+\n+func TestRatInv(t *testing.T) {\n+\tzero := new(Rat)\n+\tfor _, a := range setStringTests {\n+\t\tx, ok := new(Rat).SetString(a.in)\n+\t\tif !ok {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif x.Cmp(zero) == 0 {\n+\t\t\tcontinue // avoid division by zero\n \t\t}\n-\t\tz.Abs(&z)\n-\t\tif z.Cmp(&e) != 0 {\n-\t\t\tt.Errorf(\"got z = %v; want %v\", &z, &e)\n+\t\te := new(Rat).SetFrac(x.Denom(), x.Num())\n+\t\tz := new(Rat).Inv(x)\n+\t\tif z.Cmp(e) != 0 {\n+\t\t\tt.Errorf(\"got Inv(%v) = %v; want %v\", x, z, e)\n \t\t}\n \t}\n }\n@@ -186,10 +270,10 @@ type ratBinArg struct {\n }\n \n func testRatBin(t *testing.T, i int, name string, f ratBinFun, a ratBinArg) {\n-\tx, _ := NewRat(0, 1).SetString(a.x)\n-\ty, _ := NewRat(0, 1).SetString(a.y)\n-\tz, _ := NewRat(0, 1).SetString(a.z)\n-\tout := f(NewRat(0, 1), x, y)\n+\tx, _ := new(Rat).SetString(a.x)\n+\ty, _ := new(Rat).SetString(a.y)\n+\tz, _ := new(Rat).SetString(a.z)\n+\tout := f(new(Rat), x, y)\n \n \tif out.Cmp(z) != 0 {\n \t\tt.Errorf(\"%s #%d got %s want %s\", name, i, out, z)"}, {"sha": "73b32e7d586e38fc602bd33ce2411c23e9b14300", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -928,11 +928,11 @@ func CreateCertificate(rand io.Reader, template, parent *Certificate, pub *rsa.P\n \t\treturn\n \t}\n \n-\tasn1Issuer, err := asn1.Marshal(parent.Issuer.ToRDNSequence())\n+\tasn1Issuer, err := asn1.Marshal(parent.Subject.ToRDNSequence())\n \tif err != nil {\n \t\treturn\n \t}\n-\tasn1Subject, err := asn1.Marshal(parent.Subject.ToRDNSequence())\n+\tasn1Subject, err := asn1.Marshal(template.Subject.ToRDNSequence())\n \tif err != nil {\n \t\treturn\n \t}"}, {"sha": "d113f850eb067f8575bdae88bdd7c11def9f13cc", "filename": "libgo/go/crypto/x509/x509_test.go", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -6,8 +6,8 @@ package x509\n \n import (\n \t\"asn1\"\n-\t\"bytes\"\n \t\"big\"\n+\t\"bytes\"\n \t\"crypto/dsa\"\n \t\"crypto/rand\"\n \t\"crypto/rsa\"\n@@ -243,10 +243,11 @@ func TestCreateSelfSignedCertificate(t *testing.T) {\n \t\treturn\n \t}\n \n+\tcommonName := \"test.example.com\"\n \ttemplate := Certificate{\n \t\tSerialNumber: big.NewInt(1),\n \t\tSubject: pkix.Name{\n-\t\t\tCommonName:   \"test.example.com\",\n+\t\t\tCommonName:   commonName,\n \t\t\tOrganization: []string{\"Acme Co\"},\n \t\t},\n \t\tNotBefore: time.SecondsToUTC(1000),\n@@ -283,6 +284,14 @@ func TestCreateSelfSignedCertificate(t *testing.T) {\n \t\tt.Errorf(\"Failed to parse name constraints: %#v\", cert.PermittedDNSDomains)\n \t}\n \n+\tif cert.Subject.CommonName != commonName {\n+\t\tt.Errorf(\"Subject wasn't correctly copied from the template. Got %s, want %s\", cert.Subject.CommonName, commonName)\n+\t}\n+\n+\tif cert.Issuer.CommonName != commonName {\n+\t\tt.Errorf(\"Issuer wasn't correctly copied from the template. Got %s, want %s\", cert.Issuer.CommonName, commonName)\n+\t}\n+\n \terr = cert.CheckSignatureFrom(cert)\n \tif err != nil {\n \t\tt.Errorf(\"Signature verification failed: %s\", err)"}, {"sha": "ee3c75f63b131a98a7ef1e06c43b93ff682eb5e8", "filename": "libgo/go/exp/inotify/inotify_linux.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "previous_filename": "libgo/go/os/inotify/inotify_linux.go"}, {"sha": "a6bb46fe77d0d82eeebfb599a8b8a49065b6ba72", "filename": "libgo/go/exp/inotify/inotify_linux_test.go", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux_test.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -6,8 +6,8 @@ package inotify\n \n import (\n \t\"os\"\n-\t\"time\"\n \t\"testing\"\n+\t\"time\"\n )\n \n func TestInotifyEvents(t *testing.T) {", "previous_filename": "libgo/go/os/inotify/inotify_linux_test.go"}, {"sha": "f69b735fd47f1f53b9941378ddf9cc316f52c2b5", "filename": "libgo/go/exp/ssh/channel.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Fssh%2Fchannel.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Fssh%2Fchannel.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fchannel.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -68,7 +68,7 @@ type channel struct {\n \tweClosed    bool\n \tdead        bool\n \n-\tserverConn            *ServerConnection\n+\tserverConn            *ServerConn\n \tmyId, theirId         uint32\n \tmyWindow, theirWindow uint32\n \tmaxPacketSize         uint32"}, {"sha": "331138581fef4ddf19ea6210d37c2f0063970234", "filename": "libgo/go/exp/ssh/client.go", "status": "added", "additions": 490, "deletions": 0, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -0,0 +1,490 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ssh\n+\n+import (\n+\t\"big\"\n+\t\"crypto\"\n+\t\"crypto/rand\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net\"\n+\t\"os\"\n+\t\"sync\"\n+)\n+\n+// clientVersion is the fixed identification string that the client will use.\n+var clientVersion = []byte(\"SSH-2.0-Go\\r\\n\")\n+\n+// ClientConn represents the client side of an SSH connection.\n+type ClientConn struct {\n+\t*transport\n+\tconfig *ClientConfig\n+\tchanlist\n+}\n+\n+// Client returns a new SSH client connection using c as the underlying transport.\n+func Client(c net.Conn, config *ClientConfig) (*ClientConn, os.Error) {\n+\tconn := &ClientConn{\n+\t\ttransport: newTransport(c, config.rand()),\n+\t\tconfig:    config,\n+\t}\n+\tif err := conn.handshake(); err != nil {\n+\t\tconn.Close()\n+\t\treturn nil, err\n+\t}\n+\tif err := conn.authenticate(); err != nil {\n+\t\tconn.Close()\n+\t\treturn nil, err\n+\t}\n+\tgo conn.mainLoop()\n+\treturn conn, nil\n+}\n+\n+// handshake performs the client side key exchange. See RFC 4253 Section 7.\n+func (c *ClientConn) handshake() os.Error {\n+\tvar magics handshakeMagics\n+\n+\tif _, err := c.Write(clientVersion); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := c.Flush(); err != nil {\n+\t\treturn err\n+\t}\n+\tmagics.clientVersion = clientVersion[:len(clientVersion)-2]\n+\n+\t// read remote server version\n+\tversion, err := readVersion(c)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tmagics.serverVersion = version\n+\tclientKexInit := kexInitMsg{\n+\t\tKexAlgos:                supportedKexAlgos,\n+\t\tServerHostKeyAlgos:      supportedHostKeyAlgos,\n+\t\tCiphersClientServer:     supportedCiphers,\n+\t\tCiphersServerClient:     supportedCiphers,\n+\t\tMACsClientServer:        supportedMACs,\n+\t\tMACsServerClient:        supportedMACs,\n+\t\tCompressionClientServer: supportedCompressions,\n+\t\tCompressionServerClient: supportedCompressions,\n+\t}\n+\tkexInitPacket := marshal(msgKexInit, clientKexInit)\n+\tmagics.clientKexInit = kexInitPacket\n+\n+\tif err := c.writePacket(kexInitPacket); err != nil {\n+\t\treturn err\n+\t}\n+\tpacket, err := c.readPacket()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tmagics.serverKexInit = packet\n+\n+\tvar serverKexInit kexInitMsg\n+\tif err = unmarshal(&serverKexInit, packet, msgKexInit); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tkexAlgo, hostKeyAlgo, ok := findAgreedAlgorithms(c.transport, &clientKexInit, &serverKexInit)\n+\tif !ok {\n+\t\treturn os.NewError(\"ssh: no common algorithms\")\n+\t}\n+\n+\tif serverKexInit.FirstKexFollows && kexAlgo != serverKexInit.KexAlgos[0] {\n+\t\t// The server sent a Kex message for the wrong algorithm,\n+\t\t// which we have to ignore.\n+\t\tif _, err := c.readPacket(); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\tvar H, K []byte\n+\tvar hashFunc crypto.Hash\n+\tswitch kexAlgo {\n+\tcase kexAlgoDH14SHA1:\n+\t\thashFunc = crypto.SHA1\n+\t\tdhGroup14Once.Do(initDHGroup14)\n+\t\tH, K, err = c.kexDH(dhGroup14, hashFunc, &magics, hostKeyAlgo)\n+\tdefault:\n+\t\terr = fmt.Errorf(\"ssh: unexpected key exchange algorithm %v\", kexAlgo)\n+\t}\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif err = c.writePacket([]byte{msgNewKeys}); err != nil {\n+\t\treturn err\n+\t}\n+\tif err = c.transport.writer.setupKeys(clientKeys, K, H, H, hashFunc); err != nil {\n+\t\treturn err\n+\t}\n+\tif packet, err = c.readPacket(); err != nil {\n+\t\treturn err\n+\t}\n+\tif packet[0] != msgNewKeys {\n+\t\treturn UnexpectedMessageError{msgNewKeys, packet[0]}\n+\t}\n+\treturn c.transport.reader.setupKeys(serverKeys, K, H, H, hashFunc)\n+}\n+\n+// authenticate authenticates with the remote server. See RFC 4252. \n+// Only \"password\" authentication is supported.\n+func (c *ClientConn) authenticate() os.Error {\n+\tif err := c.writePacket(marshal(msgServiceRequest, serviceRequestMsg{serviceUserAuth})); err != nil {\n+\t\treturn err\n+\t}\n+\tpacket, err := c.readPacket()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tvar serviceAccept serviceAcceptMsg\n+\tif err = unmarshal(&serviceAccept, packet, msgServiceAccept); err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// TODO(dfc) support proper authentication method negotation\n+\tmethod := \"none\"\n+\tif c.config.Password != \"\" {\n+\t\tmethod = \"password\"\n+\t}\n+\tif err := c.sendUserAuthReq(method); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif packet, err = c.readPacket(); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif packet[0] != msgUserAuthSuccess {\n+\t\treturn UnexpectedMessageError{msgUserAuthSuccess, packet[0]}\n+\t}\n+\treturn nil\n+}\n+\n+func (c *ClientConn) sendUserAuthReq(method string) os.Error {\n+\tlength := stringLength([]byte(c.config.Password)) + 1\n+\tpayload := make([]byte, length)\n+\t// always false for password auth, see RFC 4252 Section 8.\n+\tpayload[0] = 0\n+\tmarshalString(payload[1:], []byte(c.config.Password))\n+\n+\treturn c.writePacket(marshal(msgUserAuthRequest, userAuthRequestMsg{\n+\t\tUser:    c.config.User,\n+\t\tService: serviceSSH,\n+\t\tMethod:  method,\n+\t\tPayload: payload,\n+\t}))\n+}\n+\n+// kexDH performs Diffie-Hellman key agreement on a ClientConn. The\n+// returned values are given the same names as in RFC 4253, section 8.\n+func (c *ClientConn) kexDH(group *dhGroup, hashFunc crypto.Hash, magics *handshakeMagics, hostKeyAlgo string) ([]byte, []byte, os.Error) {\n+\tx, err := rand.Int(c.config.rand(), group.p)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\tX := new(big.Int).Exp(group.g, x, group.p)\n+\tkexDHInit := kexDHInitMsg{\n+\t\tX: X,\n+\t}\n+\tif err := c.writePacket(marshal(msgKexDHInit, kexDHInit)); err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tpacket, err := c.readPacket()\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tvar kexDHReply = new(kexDHReplyMsg)\n+\tif err = unmarshal(kexDHReply, packet, msgKexDHReply); err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tif kexDHReply.Y.Sign() == 0 || kexDHReply.Y.Cmp(group.p) >= 0 {\n+\t\treturn nil, nil, os.NewError(\"server DH parameter out of bounds\")\n+\t}\n+\n+\tkInt := new(big.Int).Exp(kexDHReply.Y, x, group.p)\n+\th := hashFunc.New()\n+\twriteString(h, magics.clientVersion)\n+\twriteString(h, magics.serverVersion)\n+\twriteString(h, magics.clientKexInit)\n+\twriteString(h, magics.serverKexInit)\n+\twriteString(h, kexDHReply.HostKey)\n+\twriteInt(h, X)\n+\twriteInt(h, kexDHReply.Y)\n+\tK := make([]byte, intLength(kInt))\n+\tmarshalInt(K, kInt)\n+\th.Write(K)\n+\n+\tH := h.Sum()\n+\n+\treturn H, K, nil\n+}\n+\n+// openChan opens a new client channel. The most common session type is \"session\". \n+// The full set of valid session types are listed in RFC 4250 4.9.1.\n+func (c *ClientConn) openChan(typ string) (*clientChan, os.Error) {\n+\tch := c.newChan(c.transport)\n+\tif err := c.writePacket(marshal(msgChannelOpen, channelOpenMsg{\n+\t\tChanType:      typ,\n+\t\tPeersId:       ch.id,\n+\t\tPeersWindow:   1 << 14,\n+\t\tMaxPacketSize: 1 << 15, // RFC 4253 6.1\n+\t})); err != nil {\n+\t\tc.chanlist.remove(ch.id)\n+\t\treturn nil, err\n+\t}\n+\t// wait for response\n+\tswitch msg := (<-ch.msg).(type) {\n+\tcase *channelOpenConfirmMsg:\n+\t\tch.peersId = msg.MyId\n+\tcase *channelOpenFailureMsg:\n+\t\tc.chanlist.remove(ch.id)\n+\t\treturn nil, os.NewError(msg.Message)\n+\tdefault:\n+\t\tc.chanlist.remove(ch.id)\n+\t\treturn nil, os.NewError(\"Unexpected packet\")\n+\t}\n+\treturn ch, nil\n+}\n+\n+// mainloop reads incoming messages and routes channel messages\n+// to their respective ClientChans.\n+func (c *ClientConn) mainLoop() {\n+\tfor {\n+\t\tpacket, err := c.readPacket()\n+\t\tif err != nil {\n+\t\t\t// TODO(dfc) signal the underlying close to all channels\n+\t\t\tc.Close()\n+\t\t\treturn\n+\t\t}\n+\t\t// TODO(dfc) A note on blocking channel use. \n+\t\t// The msg, win, data and dataExt channels of a clientChan can \n+\t\t// cause this loop to block indefinately if the consumer does \n+\t\t// not service them. \n+\t\tswitch msg := decode(packet).(type) {\n+\t\tcase *channelOpenMsg:\n+\t\t\tc.getChan(msg.PeersId).msg <- msg\n+\t\tcase *channelOpenConfirmMsg:\n+\t\t\tc.getChan(msg.PeersId).msg <- msg\n+\t\tcase *channelOpenFailureMsg:\n+\t\t\tc.getChan(msg.PeersId).msg <- msg\n+\t\tcase *channelCloseMsg:\n+\t\t\tch := c.getChan(msg.PeersId)\n+\t\t\tclose(ch.win)\n+\t\t\tclose(ch.data)\n+\t\t\tclose(ch.dataExt)\n+\t\t\tc.chanlist.remove(msg.PeersId)\n+\t\tcase *channelEOFMsg:\n+\t\t\tc.getChan(msg.PeersId).msg <- msg\n+\t\tcase *channelRequestSuccessMsg:\n+\t\t\tc.getChan(msg.PeersId).msg <- msg\n+\t\tcase *channelRequestFailureMsg:\n+\t\t\tc.getChan(msg.PeersId).msg <- msg\n+\t\tcase *channelRequestMsg:\n+\t\t\tc.getChan(msg.PeersId).msg <- msg\n+\t\tcase *windowAdjustMsg:\n+\t\t\tc.getChan(msg.PeersId).win <- int(msg.AdditionalBytes)\n+\t\tcase *channelData:\n+\t\t\tc.getChan(msg.PeersId).data <- msg.Payload\n+\t\tcase *channelExtendedData:\n+\t\t\t// RFC 4254 5.2 defines data_type_code 1 to be data destined \n+\t\t\t// for stderr on interactive sessions. Other data types are\n+\t\t\t// silently discarded.\n+\t\t\tif msg.Datatype == 1 {\n+\t\t\t\tc.getChan(msg.PeersId).dataExt <- msg.Payload\n+\t\t\t}\n+\t\tdefault:\n+\t\t\tfmt.Printf(\"mainLoop: unhandled %#v\\n\", msg)\n+\t\t}\n+\t}\n+}\n+\n+// Dial connects to the given network address using net.Dial and \n+// then initiates a SSH handshake, returning the resulting client connection.\n+func Dial(network, addr string, config *ClientConfig) (*ClientConn, os.Error) {\n+\tconn, err := net.Dial(network, addr)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn Client(conn, config)\n+}\n+\n+// A ClientConfig structure is used to configure a ClientConn. After one has \n+// been passed to an SSH function it must not be modified.\n+type ClientConfig struct {\n+\t// Rand provides the source of entropy for key exchange. If Rand is \n+\t// nil, the cryptographic random reader in package crypto/rand will \n+\t// be used.\n+\tRand io.Reader\n+\n+\t// The username to authenticate.\n+\tUser string\n+\n+\t// Used for \"password\" method authentication.\n+\tPassword string\n+}\n+\n+func (c *ClientConfig) rand() io.Reader {\n+\tif c.Rand == nil {\n+\t\treturn rand.Reader\n+\t}\n+\treturn c.Rand\n+}\n+\n+// A clientChan represents a single RFC 4254 channel that is multiplexed \n+// over a single SSH connection.\n+type clientChan struct {\n+\tpacketWriter\n+\tid, peersId uint32\n+\tdata        chan []byte      // receives the payload of channelData messages\n+\tdataExt     chan []byte      // receives the payload of channelExtendedData messages\n+\twin         chan int         // receives window adjustments\n+\tmsg         chan interface{} // incoming messages\n+}\n+\n+func newClientChan(t *transport, id uint32) *clientChan {\n+\treturn &clientChan{\n+\t\tpacketWriter: t,\n+\t\tid:           id,\n+\t\tdata:         make(chan []byte, 16),\n+\t\tdataExt:      make(chan []byte, 16),\n+\t\twin:          make(chan int, 16),\n+\t\tmsg:          make(chan interface{}, 16),\n+\t}\n+}\n+\n+// Close closes the channel. This does not close the underlying connection.\n+func (c *clientChan) Close() os.Error {\n+\treturn c.writePacket(marshal(msgChannelClose, channelCloseMsg{\n+\t\tPeersId: c.id,\n+\t}))\n+}\n+\n+func (c *clientChan) sendChanReq(req channelRequestMsg) os.Error {\n+\tif err := c.writePacket(marshal(msgChannelRequest, req)); err != nil {\n+\t\treturn err\n+\t}\n+\tmsg := <-c.msg\n+\tif _, ok := msg.(*channelRequestSuccessMsg); ok {\n+\t\treturn nil\n+\t}\n+\treturn fmt.Errorf(\"failed to complete request: %s, %#v\", req.Request, msg)\n+}\n+\n+// Thread safe channel list.\n+type chanlist struct {\n+\t// protects concurrent access to chans\n+\tsync.Mutex\n+\t// chans are indexed by the local id of the channel, clientChan.id.\n+\t// The PeersId value of messages received by ClientConn.mainloop is\n+\t// used to locate the right local clientChan in this slice.\n+\tchans []*clientChan\n+}\n+\n+// Allocate a new ClientChan with the next avail local id.\n+func (c *chanlist) newChan(t *transport) *clientChan {\n+\tc.Lock()\n+\tdefer c.Unlock()\n+\tfor i := range c.chans {\n+\t\tif c.chans[i] == nil {\n+\t\t\tch := newClientChan(t, uint32(i))\n+\t\t\tc.chans[i] = ch\n+\t\t\treturn ch\n+\t\t}\n+\t}\n+\ti := len(c.chans)\n+\tch := newClientChan(t, uint32(i))\n+\tc.chans = append(c.chans, ch)\n+\treturn ch\n+}\n+\n+func (c *chanlist) getChan(id uint32) *clientChan {\n+\tc.Lock()\n+\tdefer c.Unlock()\n+\treturn c.chans[int(id)]\n+}\n+\n+func (c *chanlist) remove(id uint32) {\n+\tc.Lock()\n+\tdefer c.Unlock()\n+\tc.chans[int(id)] = nil\n+}\n+\n+// A chanWriter represents the stdin of a remote process.\n+type chanWriter struct {\n+\twin          chan int // receives window adjustments\n+\tid           uint32   // this channel's id\n+\trwin         int      // current rwin size\n+\tpacketWriter          // for sending channelDataMsg\n+}\n+\n+// Write writes data to the remote process's standard input.\n+func (w *chanWriter) Write(data []byte) (n int, err os.Error) {\n+\tfor {\n+\t\tif w.rwin == 0 {\n+\t\t\twin, ok := <-w.win\n+\t\t\tif !ok {\n+\t\t\t\treturn 0, os.EOF\n+\t\t\t}\n+\t\t\tw.rwin += win\n+\t\t\tcontinue\n+\t\t}\n+\t\tn = len(data)\n+\t\tpacket := make([]byte, 0, 9+n)\n+\t\tpacket = append(packet, msgChannelData,\n+\t\t\tbyte(w.id)>>24, byte(w.id)>>16, byte(w.id)>>8, byte(w.id),\n+\t\t\tbyte(n)>>24, byte(n)>>16, byte(n)>>8, byte(n))\n+\t\terr = w.writePacket(append(packet, data...))\n+\t\tw.rwin -= n\n+\t\treturn\n+\t}\n+\tpanic(\"unreachable\")\n+}\n+\n+func (w *chanWriter) Close() os.Error {\n+\treturn w.writePacket(marshal(msgChannelEOF, channelEOFMsg{w.id}))\n+}\n+\n+// A chanReader represents stdout or stderr of a remote process.\n+type chanReader struct {\n+\t// TODO(dfc) a fixed size channel may not be the right data structure.\n+\t// If writes to this channel block, they will block mainLoop, making\n+\t// it unable to receive new messages from the remote side.\n+\tdata         chan []byte // receives data from remote\n+\tid           uint32\n+\tpacketWriter // for sending windowAdjustMsg\n+\tbuf          []byte\n+}\n+\n+// Read reads data from the remote process's stdout or stderr.\n+func (r *chanReader) Read(data []byte) (int, os.Error) {\n+\tvar ok bool\n+\tfor {\n+\t\tif len(r.buf) > 0 {\n+\t\t\tn := copy(data, r.buf)\n+\t\t\tr.buf = r.buf[n:]\n+\t\t\tmsg := windowAdjustMsg{\n+\t\t\t\tPeersId:         r.id,\n+\t\t\t\tAdditionalBytes: uint32(n),\n+\t\t\t}\n+\t\t\treturn n, r.writePacket(marshal(msgChannelWindowAdjust, msg))\n+\t\t}\n+\t\tr.buf, ok = <-r.data\n+\t\tif !ok {\n+\t\t\treturn 0, os.EOF\n+\t\t}\n+\t}\n+\tpanic(\"unreachable\")\n+}\n+\n+func (r *chanReader) Close() os.Error {\n+\treturn r.writePacket(marshal(msgChannelEOF, channelEOFMsg{r.id}))\n+}"}, {"sha": "fc842b0c1d247420892415067a6b5bc790140e10", "filename": "libgo/go/exp/ssh/doc.go", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Fssh%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Fssh%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fdoc.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -3,42 +3,44 @@\n // license that can be found in the LICENSE file.\n \n /*\n-Package ssh implements an SSH server.\n+Package ssh implements an SSH client and server.\n \n SSH is a transport security protocol, an authentication protocol and a\n family of application protocols. The most typical application level\n protocol is a remote shell and this is specifically implemented.  However,\n the multiplexed nature of SSH is exposed to users that wish to support\n others.\n \n-An SSH server is represented by a Server, which manages a number of\n-ServerConnections and handles authentication.\n+An SSH server is represented by a ServerConfig, which holds certificate\n+details and handles authentication of ServerConns.\n \n-\tvar s Server\n-\ts.PubKeyCallback = pubKeyAuth\n-\ts.PasswordCallback = passwordAuth\n+\tconfig := new(ServerConfig)\n+\tconfig.PubKeyCallback = pubKeyAuth\n+\tconfig.PasswordCallback = passwordAuth\n \n \tpemBytes, err := ioutil.ReadFile(\"id_rsa\")\n \tif err != nil {\n \t\tpanic(\"Failed to load private key\")\n \t}\n-\terr = s.SetRSAPrivateKey(pemBytes)\n+\terr = config.SetRSAPrivateKey(pemBytes)\n \tif err != nil {\n \t\tpanic(\"Failed to parse private key\")\n \t}\n \n-Once a Server has been set up, connections can be attached.\n+Once a ServerConfig has been configured, connections can be accepted.\n \n-\tvar sConn ServerConnection\n-\tsConn.Server = &s\n+\tlistener := Listen(\"tcp\", \"0.0.0.0:2022\", config)\n+\tsConn, err := listener.Accept()\n+\tif err != nil {\n+\t\tpanic(\"failed to accept incoming connection\")\n+\t}\n \terr = sConn.Handshake(conn)\n \tif err != nil {\n \t\tpanic(\"failed to handshake\")\n \t}\n \n An SSH connection multiplexes several channels, which must be accepted themselves:\n \n-\n \tfor {\n \t\tchannel, err := sConn.Accept()\n \t\tif err != nil {\n@@ -75,5 +77,29 @@ present a simple terminal interface.\n \t\t}\n \t\treturn\n \t}()\n+\n+An SSH client is represented with a ClientConn. Currently only the \"password\"\n+authentication method is supported. \n+\n+\tconfig := &ClientConfig{\n+\t\tUser: \"username\",\n+\t\tPassword: \"123456\",\n+\t}\n+\tclient, err := Dial(\"yourserver.com:22\", config)\n+\n+Each ClientConn can support multiple interactive sessions, represented by a Session. \n+\n+\tsession, err := client.NewSession()\n+\n+Once a Session is created, you can execute a single command on the remote side \n+using the Exec method.\n+\n+\tif err := session.Exec(\"/usr/bin/whoami\"); err != nil {\n+\t\tpanic(\"Failed to exec: \" + err.String())\n+\t}\n+\treader := bufio.NewReader(session.Stdin)\n+\tline, _, _ := reader.ReadLine()\n+\tfmt.Println(line)\n+\tsession.Close()\n */\n package ssh"}, {"sha": "7771f2b242e662287c3d64d0b6a9826e916dbca5", "filename": "libgo/go/exp/ssh/messages.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Fssh%2Fmessages.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Fssh%2Fmessages.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fmessages.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -154,7 +154,7 @@ type channelData struct {\n type channelExtendedData struct {\n \tPeersId  uint32\n \tDatatype uint32\n-\tData     string\n+\tPayload  []byte `ssh:\"rest\"`\n }\n \n type channelRequestMsg struct {"}, {"sha": "3a640fc081ec432f633cb874f9cf49f4e139384b", "filename": "libgo/go/exp/ssh/server.go", "status": "modified", "additions": 102, "deletions": 49, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -10,19 +10,23 @@ import (\n \t\"crypto\"\n \t\"crypto/rand\"\n \t\"crypto/rsa\"\n-\t_ \"crypto/sha1\"\n \t\"crypto/x509\"\n \t\"encoding/pem\"\n+\t\"io\"\n \t\"net\"\n \t\"os\"\n \t\"sync\"\n )\n \n-// Server represents an SSH server. A Server may have several ServerConnections.\n-type Server struct {\n+type ServerConfig struct {\n \trsa           *rsa.PrivateKey\n \trsaSerialized []byte\n \n+\t// Rand provides the source of entropy for key exchange. If Rand is \n+\t// nil, the cryptographic random reader in package crypto/rand will \n+\t// be used.\n+\tRand io.Reader\n+\n \t// NoClientAuth is true if clients are allowed to connect without\n \t// authenticating.\n \tNoClientAuth bool\n@@ -38,11 +42,18 @@ type Server struct {\n \tPubKeyCallback func(user, algo string, pubkey []byte) bool\n }\n \n+func (c *ServerConfig) rand() io.Reader {\n+\tif c.Rand == nil {\n+\t\treturn rand.Reader\n+\t}\n+\treturn c.Rand\n+}\n+\n // SetRSAPrivateKey sets the private key for a Server. A Server must have a\n // private key configured in order to accept connections. The private key must\n // be in the form of a PEM encoded, PKCS#1, RSA private key. The file \"id_rsa\"\n // typically contains such a key.\n-func (s *Server) SetRSAPrivateKey(pemBytes []byte) os.Error {\n+func (s *ServerConfig) SetRSAPrivateKey(pemBytes []byte) os.Error {\n \tblock, _ := pem.Decode(pemBytes)\n \tif block == nil {\n \t\treturn os.NewError(\"ssh: no key found\")\n@@ -109,7 +120,7 @@ func parseRSASig(in []byte) (sig []byte, ok bool) {\n }\n \n // cachedPubKey contains the results of querying whether a public key is\n-// acceptable for a user. The cache only applies to a single ServerConnection.\n+// acceptable for a user. The cache only applies to a single ServerConn.\n type cachedPubKey struct {\n \tuser, algo string\n \tpubKey     []byte\n@@ -118,11 +129,10 @@ type cachedPubKey struct {\n \n const maxCachedPubKeys = 16\n \n-// ServerConnection represents an incomming connection to a Server.\n-type ServerConnection struct {\n-\tServer *Server\n-\n+// A ServerConn represents an incomming connection.\n+type ServerConn struct {\n \t*transport\n+\tconfig *ServerConfig\n \n \tchannels   map[uint32]*channel\n \tnextChanId uint32\n@@ -139,9 +149,20 @@ type ServerConnection struct {\n \tcachedPubKeys []cachedPubKey\n }\n \n+// Server returns a new SSH server connection\n+// using c as the underlying transport.\n+func Server(c net.Conn, config *ServerConfig) *ServerConn {\n+\tconn := &ServerConn{\n+\t\ttransport: newTransport(c, config.rand()),\n+\t\tchannels:  make(map[uint32]*channel),\n+\t\tconfig:    config,\n+\t}\n+\treturn conn\n+}\n+\n // kexDH performs Diffie-Hellman key agreement on a ServerConnection. The\n // returned values are given the same names as in RFC 4253, section 8.\n-func (s *ServerConnection) kexDH(group *dhGroup, hashFunc crypto.Hash, magics *handshakeMagics, hostKeyAlgo string) (H, K []byte, err os.Error) {\n+func (s *ServerConn) kexDH(group *dhGroup, hashFunc crypto.Hash, magics *handshakeMagics, hostKeyAlgo string) (H, K []byte, err os.Error) {\n \tpacket, err := s.readPacket()\n \tif err != nil {\n \t\treturn\n@@ -155,7 +176,7 @@ func (s *ServerConnection) kexDH(group *dhGroup, hashFunc crypto.Hash, magics *h\n \t\treturn nil, nil, os.NewError(\"client DH parameter out of bounds\")\n \t}\n \n-\ty, err := rand.Int(rand.Reader, group.p)\n+\ty, err := rand.Int(s.config.rand(), group.p)\n \tif err != nil {\n \t\treturn\n \t}\n@@ -166,7 +187,7 @@ func (s *ServerConnection) kexDH(group *dhGroup, hashFunc crypto.Hash, magics *h\n \tvar serializedHostKey []byte\n \tswitch hostKeyAlgo {\n \tcase hostAlgoRSA:\n-\t\tserializedHostKey = s.Server.rsaSerialized\n+\t\tserializedHostKey = s.config.rsaSerialized\n \tdefault:\n \t\treturn nil, nil, os.NewError(\"internal error\")\n \t}\n@@ -192,7 +213,7 @@ func (s *ServerConnection) kexDH(group *dhGroup, hashFunc crypto.Hash, magics *h\n \tvar sig []byte\n \tswitch hostKeyAlgo {\n \tcase hostAlgoRSA:\n-\t\tsig, err = rsa.SignPKCS1v15(rand.Reader, s.Server.rsa, hashFunc, hh)\n+\t\tsig, err = rsa.SignPKCS1v15(s.config.rand(), s.config.rsa, hashFunc, hh)\n \t\tif err != nil {\n \t\t\treturn\n \t\t}\n@@ -257,19 +278,20 @@ func buildDataSignedForAuth(sessionId []byte, req userAuthRequestMsg, algo, pubK\n \treturn ret\n }\n \n-// Handshake performs an SSH transport and client authentication on the given ServerConnection.\n-func (s *ServerConnection) Handshake(conn net.Conn) os.Error {\n+// Handshake performs an SSH transport and client authentication on the given ServerConn.\n+func (s *ServerConn) Handshake() os.Error {\n \tvar magics handshakeMagics\n-\ts.transport = newTransport(conn, rand.Reader)\n-\n-\tif _, err := conn.Write(serverVersion); err != nil {\n+\tif _, err := s.Write(serverVersion); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := s.Flush(); err != nil {\n \t\treturn err\n \t}\n \tmagics.serverVersion = serverVersion[:len(serverVersion)-2]\n \n-\tversion, ok := readVersion(s.transport)\n-\tif !ok {\n-\t\treturn os.NewError(\"failed to read version string from client\")\n+\tversion, err := readVersion(s)\n+\tif err != nil {\n+\t\treturn err\n \t}\n \tmagics.clientVersion = version\n \n@@ -310,8 +332,7 @@ func (s *ServerConnection) Handshake(conn net.Conn) os.Error {\n \tif clientKexInit.FirstKexFollows && kexAlgo != clientKexInit.KexAlgos[0] {\n \t\t// The client sent a Kex message for the wrong algorithm,\n \t\t// which we have to ignore.\n-\t\t_, err := s.readPacket()\n-\t\tif err != nil {\n+\t\tif _, err := s.readPacket(); err != nil {\n \t\t\treturn err\n \t\t}\n \t}\n@@ -324,32 +345,27 @@ func (s *ServerConnection) Handshake(conn net.Conn) os.Error {\n \t\tdhGroup14Once.Do(initDHGroup14)\n \t\tH, K, err = s.kexDH(dhGroup14, hashFunc, &magics, hostKeyAlgo)\n \tdefault:\n-\t\terr = os.NewError(\"ssh: internal error\")\n+\t\terr = os.NewError(\"ssh: unexpected key exchange algorithm \" + kexAlgo)\n \t}\n-\n \tif err != nil {\n \t\treturn err\n \t}\n \n-\tpacket = []byte{msgNewKeys}\n-\tif err = s.writePacket(packet); err != nil {\n+\tif err = s.writePacket([]byte{msgNewKeys}); err != nil {\n \t\treturn err\n \t}\n \tif err = s.transport.writer.setupKeys(serverKeys, K, H, H, hashFunc); err != nil {\n \t\treturn err\n \t}\n-\n \tif packet, err = s.readPacket(); err != nil {\n \t\treturn err\n \t}\n+\n \tif packet[0] != msgNewKeys {\n \t\treturn UnexpectedMessageError{msgNewKeys, packet[0]}\n \t}\n-\n \ts.transport.reader.setupKeys(clientKeys, K, H, H, hashFunc)\n-\n-\tpacket, err = s.readPacket()\n-\tif err != nil {\n+\tif packet, err = s.readPacket(); err != nil {\n \t\treturn err\n \t}\n \n@@ -360,20 +376,16 @@ func (s *ServerConnection) Handshake(conn net.Conn) os.Error {\n \tif serviceRequest.Service != serviceUserAuth {\n \t\treturn os.NewError(\"ssh: requested service '\" + serviceRequest.Service + \"' before authenticating\")\n \t}\n-\n \tserviceAccept := serviceAcceptMsg{\n \t\tService: serviceUserAuth,\n \t}\n-\tpacket = marshal(msgServiceAccept, serviceAccept)\n-\tif err = s.writePacket(packet); err != nil {\n+\tif err = s.writePacket(marshal(msgServiceAccept, serviceAccept)); err != nil {\n \t\treturn err\n \t}\n \n \tif err = s.authenticate(H); err != nil {\n \t\treturn err\n \t}\n-\n-\ts.channels = make(map[uint32]*channel)\n \treturn nil\n }\n \n@@ -382,8 +394,8 @@ func isAcceptableAlgo(algo string) bool {\n }\n \n // testPubKey returns true if the given public key is acceptable for the user.\n-func (s *ServerConnection) testPubKey(user, algo string, pubKey []byte) bool {\n-\tif s.Server.PubKeyCallback == nil || !isAcceptableAlgo(algo) {\n+func (s *ServerConn) testPubKey(user, algo string, pubKey []byte) bool {\n+\tif s.config.PubKeyCallback == nil || !isAcceptableAlgo(algo) {\n \t\treturn false\n \t}\n \n@@ -393,7 +405,7 @@ func (s *ServerConnection) testPubKey(user, algo string, pubKey []byte) bool {\n \t\t}\n \t}\n \n-\tresult := s.Server.PubKeyCallback(user, algo, pubKey)\n+\tresult := s.config.PubKeyCallback(user, algo, pubKey)\n \tif len(s.cachedPubKeys) < maxCachedPubKeys {\n \t\tc := cachedPubKey{\n \t\t\tuser:   user,\n@@ -408,7 +420,7 @@ func (s *ServerConnection) testPubKey(user, algo string, pubKey []byte) bool {\n \treturn result\n }\n \n-func (s *ServerConnection) authenticate(H []byte) os.Error {\n+func (s *ServerConn) authenticate(H []byte) os.Error {\n \tvar userAuthReq userAuthRequestMsg\n \tvar err os.Error\n \tvar packet []byte\n@@ -428,11 +440,11 @@ userAuthLoop:\n \n \t\tswitch userAuthReq.Method {\n \t\tcase \"none\":\n-\t\t\tif s.Server.NoClientAuth {\n+\t\t\tif s.config.NoClientAuth {\n \t\t\t\tbreak userAuthLoop\n \t\t\t}\n \t\tcase \"password\":\n-\t\t\tif s.Server.PasswordCallback == nil {\n+\t\t\tif s.config.PasswordCallback == nil {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tpayload := userAuthReq.Payload\n@@ -445,11 +457,11 @@ userAuthLoop:\n \t\t\t\treturn ParseError{msgUserAuthRequest}\n \t\t\t}\n \n-\t\t\tif s.Server.PasswordCallback(userAuthReq.User, string(password)) {\n+\t\t\tif s.config.PasswordCallback(userAuthReq.User, string(password)) {\n \t\t\t\tbreak userAuthLoop\n \t\t\t}\n \t\tcase \"publickey\":\n-\t\t\tif s.Server.PubKeyCallback == nil {\n+\t\t\tif s.config.PubKeyCallback == nil {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tpayload := userAuthReq.Payload\n@@ -520,10 +532,10 @@ userAuthLoop:\n \t\t}\n \n \t\tvar failureMsg userAuthFailureMsg\n-\t\tif s.Server.PasswordCallback != nil {\n+\t\tif s.config.PasswordCallback != nil {\n \t\t\tfailureMsg.Methods = append(failureMsg.Methods, \"password\")\n \t\t}\n-\t\tif s.Server.PubKeyCallback != nil {\n+\t\tif s.config.PubKeyCallback != nil {\n \t\t\tfailureMsg.Methods = append(failureMsg.Methods, \"publickey\")\n \t\t}\n \n@@ -546,9 +558,9 @@ userAuthLoop:\n \n const defaultWindowSize = 32768\n \n-// Accept reads and processes messages on a ServerConnection. It must be called\n+// Accept reads and processes messages on a ServerConn. It must be called\n // in order to demultiplex messages to any resulting Channels.\n-func (s *ServerConnection) Accept() (Channel, os.Error) {\n+func (s *ServerConn) Accept() (Channel, os.Error) {\n \tif s.err != nil {\n \t\treturn nil, s.err\n \t}\n@@ -643,3 +655,44 @@ func (s *ServerConnection) Accept() (Channel, os.Error) {\n \n \tpanic(\"unreachable\")\n }\n+\n+// A Listener implements a network listener (net.Listener) for SSH connections.\n+type Listener struct {\n+\tlistener net.Listener\n+\tconfig   *ServerConfig\n+}\n+\n+// Accept waits for and returns the next incoming SSH connection.\n+// The receiver should call Handshake() in another goroutine \n+// to avoid blocking the accepter.\n+func (l *Listener) Accept() (*ServerConn, os.Error) {\n+\tc, err := l.listener.Accept()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tconn := Server(c, l.config)\n+\treturn conn, nil\n+}\n+\n+// Addr returns the listener's network address.\n+func (l *Listener) Addr() net.Addr {\n+\treturn l.listener.Addr()\n+}\n+\n+// Close closes the listener.\n+func (l *Listener) Close() os.Error {\n+\treturn l.listener.Close()\n+}\n+\n+// Listen creates an SSH listener accepting connections on\n+// the given network address using net.Listen.\n+func Listen(network, addr string, config *ServerConfig) (*Listener, os.Error) {\n+\tl, err := net.Listen(network, addr)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &Listener{\n+\t\tl,\n+\t\tconfig,\n+\t}, nil\n+}"}, {"sha": "13df2f0dda40f06c2efe189b8936a9b317d86ad0", "filename": "libgo/go/exp/ssh/session.go", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Fssh%2Fsession.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Fssh%2Fsession.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fsession.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -0,0 +1,132 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ssh\n+\n+// Session implements an interactive session described in\n+// \"RFC 4254, section 6\".\n+\n+import (\n+\t\"encoding/binary\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// A Session represents a connection to a remote command or shell.\n+type Session struct {\n+\t// Writes to Stdin are made available to the remote command's standard input.\n+\t// Closing Stdin causes the command to observe an EOF on its standard input.\n+\tStdin io.WriteCloser\n+\n+\t// Reads from Stdout and Stderr consume from the remote command's standard\n+\t// output and error streams, respectively.\n+\t// There is a fixed amount of buffering that is shared for the two streams.\n+\t// Failing to read from either may eventually cause the command to block.\n+\t// Closing Stdout unblocks such writes and causes them to return errors.\n+\tStdout io.ReadCloser\n+\tStderr io.Reader\n+\n+\t*clientChan // the channel backing this session\n+\n+\tstarted bool // started is set to true once a Shell or Exec is invoked.\n+}\n+\n+// Setenv sets an environment variable that will be applied to any\n+// command executed by Shell or Exec.\n+func (s *Session) Setenv(name, value string) os.Error {\n+\tn, v := []byte(name), []byte(value)\n+\tnlen, vlen := stringLength(n), stringLength(v)\n+\tpayload := make([]byte, nlen+vlen)\n+\tmarshalString(payload[:nlen], n)\n+\tmarshalString(payload[nlen:], v)\n+\n+\treturn s.sendChanReq(channelRequestMsg{\n+\t\tPeersId:             s.id,\n+\t\tRequest:             \"env\",\n+\t\tWantReply:           true,\n+\t\tRequestSpecificData: payload,\n+\t})\n+}\n+\n+// An empty mode list (a string of 1 character, opcode 0), see RFC 4254 Section 8.\n+var emptyModeList = []byte{0, 0, 0, 1, 0}\n+\n+// RequestPty requests the association of a pty with the session on the remote host.\n+func (s *Session) RequestPty(term string, h, w int) os.Error {\n+\tbuf := make([]byte, 4+len(term)+16+len(emptyModeList))\n+\tb := marshalString(buf, []byte(term))\n+\tbinary.BigEndian.PutUint32(b, uint32(h))\n+\tbinary.BigEndian.PutUint32(b[4:], uint32(w))\n+\tbinary.BigEndian.PutUint32(b[8:], uint32(h*8))\n+\tbinary.BigEndian.PutUint32(b[12:], uint32(w*8))\n+\tcopy(b[16:], emptyModeList)\n+\n+\treturn s.sendChanReq(channelRequestMsg{\n+\t\tPeersId:             s.id,\n+\t\tRequest:             \"pty-req\",\n+\t\tWantReply:           true,\n+\t\tRequestSpecificData: buf,\n+\t})\n+}\n+\n+// Exec runs cmd on the remote host. Typically, the remote \n+// server passes cmd to the shell for interpretation. \n+// A Session only accepts one call to Exec or Shell.\n+func (s *Session) Exec(cmd string) os.Error {\n+\tif s.started {\n+\t\treturn os.NewError(\"session already started\")\n+\t}\n+\tcmdLen := stringLength([]byte(cmd))\n+\tpayload := make([]byte, cmdLen)\n+\tmarshalString(payload, []byte(cmd))\n+\ts.started = true\n+\n+\treturn s.sendChanReq(channelRequestMsg{\n+\t\tPeersId:             s.id,\n+\t\tRequest:             \"exec\",\n+\t\tWantReply:           true,\n+\t\tRequestSpecificData: payload,\n+\t})\n+}\n+\n+// Shell starts a login shell on the remote host. A Session only \n+// accepts one call to Exec or Shell.\n+func (s *Session) Shell() os.Error {\n+\tif s.started {\n+\t\treturn os.NewError(\"session already started\")\n+\t}\n+\ts.started = true\n+\n+\treturn s.sendChanReq(channelRequestMsg{\n+\t\tPeersId:   s.id,\n+\t\tRequest:   \"shell\",\n+\t\tWantReply: true,\n+\t})\n+}\n+\n+// NewSession returns a new interactive session on the remote host.\n+func (c *ClientConn) NewSession() (*Session, os.Error) {\n+\tch, err := c.openChan(\"session\")\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &Session{\n+\t\tStdin: &chanWriter{\n+\t\t\tpacketWriter: ch,\n+\t\t\tid:           ch.id,\n+\t\t\twin:          ch.win,\n+\t\t},\n+\t\tStdout: &chanReader{\n+\t\t\tpacketWriter: ch,\n+\t\t\tid:           ch.id,\n+\t\t\tdata:         ch.data,\n+\t\t},\n+\t\tStderr: &chanReader{\n+\t\t\tpacketWriter: ch,\n+\t\t\tid:           ch.id,\n+\t\t\tdata:         ch.dataExt,\n+\t\t},\n+\t\tclientChan: ch,\n+\t}, nil\n+}"}, {"sha": "97eaf975d10f306bd6ca26f2eade366edcd1ea3a", "filename": "libgo/go/exp/ssh/transport.go", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -332,16 +332,15 @@ func (t truncatingMAC) Size() int {\n const maxVersionStringBytes = 1024\n \n // Read version string as specified by RFC 4253, section 4.2.\n-func readVersion(r io.Reader) (versionString []byte, ok bool) {\n-\tversionString = make([]byte, 0, 64)\n-\tseenCR := false\n-\n+func readVersion(r io.Reader) ([]byte, os.Error) {\n+\tversionString := make([]byte, 0, 64)\n+\tvar ok, seenCR bool\n \tvar buf [1]byte\n forEachByte:\n \tfor len(versionString) < maxVersionStringBytes {\n \t\t_, err := io.ReadFull(r, buf[:])\n \t\tif err != nil {\n-\t\t\treturn\n+\t\t\treturn nil, err\n \t\t}\n \t\tb := buf[0]\n \n@@ -360,10 +359,10 @@ forEachByte:\n \t\tversionString = append(versionString, b)\n \t}\n \n-\tif ok {\n-\t\t// We need to remove the CR from versionString\n-\t\tversionString = versionString[:len(versionString)-1]\n+\tif !ok {\n+\t\treturn nil, os.NewError(\"failed to read version string\")\n \t}\n \n-\treturn\n+\t// We need to remove the CR from versionString\n+\treturn versionString[:len(versionString)-1], nil\n }"}, {"sha": "b2e2a7fc92aa6587a978fe637c1566492cbb788b", "filename": "libgo/go/exp/ssh/transport_test.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Fssh%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Fssh%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Ftransport_test.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -12,9 +12,9 @@ import (\n \n func TestReadVersion(t *testing.T) {\n \tbuf := []byte(serverVersion)\n-\tresult, ok := readVersion(bufio.NewReader(bytes.NewBuffer(buf)))\n-\tif !ok {\n-\t\tt.Error(\"readVersion didn't read version correctly\")\n+\tresult, err := readVersion(bufio.NewReader(bytes.NewBuffer(buf)))\n+\tif err != nil {\n+\t\tt.Errorf(\"readVersion didn't read version correctly: %s\", err)\n \t}\n \tif !bytes.Equal(buf[:len(buf)-2], result) {\n \t\tt.Error(\"version read did not match expected\")\n@@ -23,15 +23,15 @@ func TestReadVersion(t *testing.T) {\n \n func TestReadVersionTooLong(t *testing.T) {\n \tbuf := make([]byte, maxVersionStringBytes+1)\n-\tif _, ok := readVersion(bufio.NewReader(bytes.NewBuffer(buf))); ok {\n+\tif _, err := readVersion(bufio.NewReader(bytes.NewBuffer(buf))); err == nil {\n \t\tt.Errorf(\"readVersion consumed %d bytes without error\", len(buf))\n \t}\n }\n \n func TestReadVersionWithoutCRLF(t *testing.T) {\n \tbuf := []byte(serverVersion)\n \tbuf = buf[:len(buf)-1]\n-\tif _, ok := readVersion(bufio.NewReader(bytes.NewBuffer(buf))); ok {\n+\tif _, err := readVersion(bufio.NewReader(bytes.NewBuffer(buf))); err == nil {\n \t\tt.Error(\"readVersion did not notice \\\\n was missing\")\n \t}\n }"}, {"sha": "e744a63a96ec965bcd7294a3b1ac5c50e0b1cda4", "filename": "libgo/go/exp/types/gcimporter.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -289,9 +289,10 @@ func (p *gcParser) parseExportedName() (*ast.Object, string) {\n // BasicType = identifier .\n //\n func (p *gcParser) parseBasicType() Type {\n-\tobj := Universe.Lookup(p.expect(scanner.Ident))\n+\tid := p.expect(scanner.Ident)\n+\tobj := Universe.Lookup(id)\n \tif obj == nil || obj.Kind != ast.Typ {\n-\t\tp.errorf(\"not a basic type: %s\", obj.Name)\n+\t\tp.errorf(\"not a basic type: %s\", id)\n \t}\n \treturn obj.Type.(Type)\n }"}, {"sha": "6e264d04f90b931ba536cdd6cd6777e3b987b1a8", "filename": "libgo/go/exp/winfsnotify/winfsnotify_test.go", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify_test.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -6,8 +6,8 @@ package winfsnotify\n \n import (\n \t\"os\"\n-\t\"time\"\n \t\"testing\"\n+\t\"time\"\n )\n \n func expect(t *testing.T, eventstream <-chan *Event, name string, mask uint32) {\n@@ -70,15 +70,11 @@ func TestNotifyEvents(t *testing.T) {\n \tif _, err = file.WriteString(\"hello, world\"); err != nil {\n \t\tt.Fatalf(\"failed to write to test file: %s\", err)\n \t}\n-\tif err = file.Sync(); err != nil {\n-\t\tt.Fatalf(\"failed to sync test file: %s\", err)\n-\t}\n-\texpect(t, watcher.Event, testFile, FS_MODIFY)\n-\texpect(t, watcher.Event, testFile, FS_MODIFY)\n-\n \tif err = file.Close(); err != nil {\n \t\tt.Fatalf(\"failed to close test file: %s\", err)\n \t}\n+\texpect(t, watcher.Event, testFile, FS_MODIFY)\n+\texpect(t, watcher.Event, testFile, FS_MODIFY)\n \n \tif err = os.Rename(testFile, testFile2); err != nil {\n \t\tt.Fatalf(\"failed to rename test file: %s\", err)"}, {"sha": "38280d61f6be3e39951f287dc32101950c1abcda", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -88,6 +88,10 @@ type S struct {\n \tG G // a struct field that GoStrings\n }\n \n+type SI struct {\n+\tI interface{}\n+}\n+\n // A type with a String method with pointer receiver for testing %p\n type P int\n \n@@ -352,6 +356,7 @@ var fmttests = []struct {\n \t{\"%#v\", map[string]int{\"a\": 1}, `map[string] int{\"a\":1}`},\n \t{\"%#v\", map[string]B{\"a\": {1, 2}}, `map[string] fmt_test.B{\"a\":fmt_test.B{I:1, j:2}}`},\n \t{\"%#v\", []string{\"a\", \"b\"}, `[]string{\"a\", \"b\"}`},\n+\t{\"%#v\", SI{}, `fmt_test.SI{I:interface { }(nil)}`},\n \n \t// slices with other formats\n \t{\"%#x\", []int{1, 2, 15}, `[0x1 0x2 0xf]`},"}, {"sha": "710baeec1d2cffffe6f6b7329ae06e5d19bba8f7", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 85, "deletions": 94, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -74,6 +74,8 @@ type pp struct {\n \tn         int\n \tpanicking bool\n \tbuf       bytes.Buffer\n+\t// field holds the current item, as an interface{}.\n+\tfield interface{}\n \t// value holds the current item, as a reflect.Value, and will be\n \t// the zero Value if the item has not been reflected.\n \tvalue   reflect.Value\n@@ -132,6 +134,7 @@ func (p *pp) free() {\n \t\treturn\n \t}\n \tp.buf.Reset()\n+\tp.field = nil\n \tp.value = reflect.Value{}\n \tppFree.put(p)\n }\n@@ -294,16 +297,16 @@ func (p *pp) unknownType(v interface{}) {\n \tp.buf.WriteByte('?')\n }\n \n-func (p *pp) badVerb(verb int, val interface{}) {\n+func (p *pp) badVerb(verb int) {\n \tp.add('%')\n \tp.add('!')\n \tp.add(verb)\n \tp.add('(')\n \tswitch {\n-\tcase val != nil:\n-\t\tp.buf.WriteString(reflect.TypeOf(val).String())\n+\tcase p.field != nil:\n+\t\tp.buf.WriteString(reflect.TypeOf(p.field).String())\n \t\tp.add('=')\n-\t\tp.printField(val, 'v', false, false, 0)\n+\t\tp.printField(p.field, 'v', false, false, 0)\n \tcase p.value.IsValid():\n \t\tp.buf.WriteString(p.value.Type().String())\n \t\tp.add('=')\n@@ -314,12 +317,12 @@ func (p *pp) badVerb(verb int, val interface{}) {\n \tp.add(')')\n }\n \n-func (p *pp) fmtBool(v bool, verb int, value interface{}) {\n+func (p *pp) fmtBool(v bool, verb int) {\n \tswitch verb {\n \tcase 't', 'v':\n \t\tp.fmt.fmt_boolean(v)\n \tdefault:\n-\t\tp.badVerb(verb, value)\n+\t\tp.badVerb(verb)\n \t}\n }\n \n@@ -333,7 +336,7 @@ func (p *pp) fmtC(c int64) {\n \tp.fmt.pad(p.runeBuf[0:w])\n }\n \n-func (p *pp) fmtInt64(v int64, verb int, value interface{}) {\n+func (p *pp) fmtInt64(v int64, verb int) {\n \tswitch verb {\n \tcase 'b':\n \t\tp.fmt.integer(v, 2, signed, ldigits)\n@@ -347,7 +350,7 @@ func (p *pp) fmtInt64(v int64, verb int, value interface{}) {\n \t\tif 0 <= v && v <= unicode.MaxRune {\n \t\t\tp.fmt.fmt_qc(v)\n \t\t} else {\n-\t\t\tp.badVerb(verb, value)\n+\t\t\tp.badVerb(verb)\n \t\t}\n \tcase 'x':\n \t\tp.fmt.integer(v, 16, signed, ldigits)\n@@ -356,7 +359,7 @@ func (p *pp) fmtInt64(v int64, verb int, value interface{}) {\n \tcase 'X':\n \t\tp.fmt.integer(v, 16, signed, udigits)\n \tdefault:\n-\t\tp.badVerb(verb, value)\n+\t\tp.badVerb(verb)\n \t}\n }\n \n@@ -391,7 +394,7 @@ func (p *pp) fmtUnicode(v int64) {\n \tp.fmt.sharp = sharp\n }\n \n-func (p *pp) fmtUint64(v uint64, verb int, goSyntax bool, value interface{}) {\n+func (p *pp) fmtUint64(v uint64, verb int, goSyntax bool) {\n \tswitch verb {\n \tcase 'b':\n \t\tp.fmt.integer(int64(v), 2, unsigned, ldigits)\n@@ -411,7 +414,7 @@ func (p *pp) fmtUint64(v uint64, verb int, goSyntax bool, value interface{}) {\n \t\tif 0 <= v && v <= unicode.MaxRune {\n \t\t\tp.fmt.fmt_qc(int64(v))\n \t\t} else {\n-\t\t\tp.badVerb(verb, value)\n+\t\t\tp.badVerb(verb)\n \t\t}\n \tcase 'x':\n \t\tp.fmt.integer(int64(v), 16, unsigned, ldigits)\n@@ -420,11 +423,11 @@ func (p *pp) fmtUint64(v uint64, verb int, goSyntax bool, value interface{}) {\n \tcase 'U':\n \t\tp.fmtUnicode(int64(v))\n \tdefault:\n-\t\tp.badVerb(verb, value)\n+\t\tp.badVerb(verb)\n \t}\n }\n \n-func (p *pp) fmtFloat32(v float32, verb int, value interface{}) {\n+func (p *pp) fmtFloat32(v float32, verb int) {\n \tswitch verb {\n \tcase 'b':\n \t\tp.fmt.fmt_fb32(v)\n@@ -439,11 +442,11 @@ func (p *pp) fmtFloat32(v float32, verb int, value interface{}) {\n \tcase 'G':\n \t\tp.fmt.fmt_G32(v)\n \tdefault:\n-\t\tp.badVerb(verb, value)\n+\t\tp.badVerb(verb)\n \t}\n }\n \n-func (p *pp) fmtFloat64(v float64, verb int, value interface{}) {\n+func (p *pp) fmtFloat64(v float64, verb int) {\n \tswitch verb {\n \tcase 'b':\n \t\tp.fmt.fmt_fb64(v)\n@@ -458,33 +461,33 @@ func (p *pp) fmtFloat64(v float64, verb int, value interface{}) {\n \tcase 'G':\n \t\tp.fmt.fmt_G64(v)\n \tdefault:\n-\t\tp.badVerb(verb, value)\n+\t\tp.badVerb(verb)\n \t}\n }\n \n-func (p *pp) fmtComplex64(v complex64, verb int, value interface{}) {\n+func (p *pp) fmtComplex64(v complex64, verb int) {\n \tswitch verb {\n \tcase 'e', 'E', 'f', 'F', 'g', 'G':\n \t\tp.fmt.fmt_c64(v, verb)\n \tcase 'v':\n \t\tp.fmt.fmt_c64(v, 'g')\n \tdefault:\n-\t\tp.badVerb(verb, value)\n+\t\tp.badVerb(verb)\n \t}\n }\n \n-func (p *pp) fmtComplex128(v complex128, verb int, value interface{}) {\n+func (p *pp) fmtComplex128(v complex128, verb int) {\n \tswitch verb {\n \tcase 'e', 'E', 'f', 'F', 'g', 'G':\n \t\tp.fmt.fmt_c128(v, verb)\n \tcase 'v':\n \t\tp.fmt.fmt_c128(v, 'g')\n \tdefault:\n-\t\tp.badVerb(verb, value)\n+\t\tp.badVerb(verb)\n \t}\n }\n \n-func (p *pp) fmtString(v string, verb int, goSyntax bool, value interface{}) {\n+func (p *pp) fmtString(v string, verb int, goSyntax bool) {\n \tswitch verb {\n \tcase 'v':\n \t\tif goSyntax {\n@@ -501,11 +504,11 @@ func (p *pp) fmtString(v string, verb int, goSyntax bool, value interface{}) {\n \tcase 'q':\n \t\tp.fmt.fmt_q(v)\n \tdefault:\n-\t\tp.badVerb(verb, value)\n+\t\tp.badVerb(verb)\n \t}\n }\n \n-func (p *pp) fmtBytes(v []byte, verb int, goSyntax bool, depth int, value interface{}) {\n+func (p *pp) fmtBytes(v []byte, verb int, goSyntax bool, depth int) {\n \tif verb == 'v' || verb == 'd' {\n \t\tif goSyntax {\n \t\t\tp.buf.Write(bytesBytes)\n@@ -540,17 +543,17 @@ func (p *pp) fmtBytes(v []byte, verb int, goSyntax bool, depth int, value interf\n \tcase 'q':\n \t\tp.fmt.fmt_q(s)\n \tdefault:\n-\t\tp.badVerb(verb, value)\n+\t\tp.badVerb(verb)\n \t}\n }\n \n-func (p *pp) fmtPointer(field interface{}, value reflect.Value, verb int, goSyntax bool) {\n+func (p *pp) fmtPointer(value reflect.Value, verb int, goSyntax bool) {\n \tvar u uintptr\n \tswitch value.Kind() {\n \tcase reflect.Chan, reflect.Func, reflect.Map, reflect.Ptr, reflect.Slice, reflect.UnsafePointer:\n \t\tu = value.Pointer()\n \tdefault:\n-\t\tp.badVerb(verb, field)\n+\t\tp.badVerb(verb)\n \t\treturn\n \t}\n \tif goSyntax {\n@@ -576,12 +579,12 @@ var (\n \tuintptrBits = reflect.TypeOf(uintptr(0)).Bits()\n )\n \n-func (p *pp) catchPanic(val interface{}, verb int) {\n+func (p *pp) catchPanic(field interface{}, verb int) {\n \tif err := recover(); err != nil {\n \t\t// If it's a nil pointer, just say \"<nil>\". The likeliest causes are a\n \t\t// Stringer that fails to guard against nil or a nil pointer for a\n \t\t// value receiver, and in either case, \"<nil>\" is a nice result.\n-\t\tif v := reflect.ValueOf(val); v.Kind() == reflect.Ptr && v.IsNil() {\n+\t\tif v := reflect.ValueOf(field); v.Kind() == reflect.Ptr && v.IsNil() {\n \t\t\tp.buf.Write(nilAngleBytes)\n \t\t\treturn\n \t\t}\n@@ -601,12 +604,12 @@ func (p *pp) catchPanic(val interface{}, verb int) {\n \t}\n }\n \n-func (p *pp) handleMethods(field interface{}, verb int, plus, goSyntax bool, depth int) (wasString, handled bool) {\n+func (p *pp) handleMethods(verb int, plus, goSyntax bool, depth int) (wasString, handled bool) {\n \t// Is it a Formatter?\n-\tif formatter, ok := field.(Formatter); ok {\n+\tif formatter, ok := p.field.(Formatter); ok {\n \t\thandled = true\n \t\twasString = false\n-\t\tdefer p.catchPanic(field, verb)\n+\t\tdefer p.catchPanic(p.field, verb)\n \t\tformatter.Format(p, verb)\n \t\treturn\n \t}\n@@ -618,20 +621,20 @@ func (p *pp) handleMethods(field interface{}, verb int, plus, goSyntax bool, dep\n \t// If we're doing Go syntax and the field knows how to supply it, take care of it now.\n \tif goSyntax {\n \t\tp.fmt.sharp = false\n-\t\tif stringer, ok := field.(GoStringer); ok {\n+\t\tif stringer, ok := p.field.(GoStringer); ok {\n \t\t\twasString = false\n \t\t\thandled = true\n-\t\t\tdefer p.catchPanic(field, verb)\n+\t\t\tdefer p.catchPanic(p.field, verb)\n \t\t\t// Print the result of GoString unadorned.\n-\t\t\tp.fmtString(stringer.GoString(), 's', false, field)\n+\t\t\tp.fmtString(stringer.GoString(), 's', false)\n \t\t\treturn\n \t\t}\n \t} else {\n \t\t// Is it a Stringer?\n-\t\tif stringer, ok := field.(Stringer); ok {\n+\t\tif stringer, ok := p.field.(Stringer); ok {\n \t\t\twasString = false\n \t\t\thandled = true\n-\t\t\tdefer p.catchPanic(field, verb)\n+\t\t\tdefer p.catchPanic(p.field, verb)\n \t\t\tp.printField(stringer.String(), verb, plus, false, depth)\n \t\t\treturn\n \t\t}\n@@ -645,86 +648,74 @@ func (p *pp) printField(field interface{}, verb int, plus, goSyntax bool, depth\n \t\tif verb == 'T' || verb == 'v' {\n \t\t\tp.buf.Write(nilAngleBytes)\n \t\t} else {\n-\t\t\tp.badVerb(verb, field)\n+\t\t\tp.badVerb(verb)\n \t\t}\n \t\treturn false\n \t}\n \n+\tp.field = field\n+\tp.value = reflect.Value{}\n \t// Special processing considerations.\n \t// %T (the value's type) and %p (its address) are special; we always do them first.\n \tswitch verb {\n \tcase 'T':\n \t\tp.printField(reflect.TypeOf(field).String(), 's', false, false, 0)\n \t\treturn false\n \tcase 'p':\n-\t\tp.fmtPointer(field, reflect.ValueOf(field), verb, goSyntax)\n+\t\tp.fmtPointer(reflect.ValueOf(field), verb, goSyntax)\n \t\treturn false\n \t}\n \n-\tif wasString, handled := p.handleMethods(field, verb, plus, goSyntax, depth); handled {\n+\tif wasString, handled := p.handleMethods(verb, plus, goSyntax, depth); handled {\n \t\treturn wasString\n \t}\n \n \t// Some types can be done without reflection.\n \tswitch f := field.(type) {\n \tcase bool:\n-\t\tp.fmtBool(f, verb, field)\n-\t\treturn false\n+\t\tp.fmtBool(f, verb)\n \tcase float32:\n-\t\tp.fmtFloat32(f, verb, field)\n-\t\treturn false\n+\t\tp.fmtFloat32(f, verb)\n \tcase float64:\n-\t\tp.fmtFloat64(f, verb, field)\n-\t\treturn false\n+\t\tp.fmtFloat64(f, verb)\n \tcase complex64:\n-\t\tp.fmtComplex64(complex64(f), verb, field)\n-\t\treturn false\n+\t\tp.fmtComplex64(complex64(f), verb)\n \tcase complex128:\n-\t\tp.fmtComplex128(f, verb, field)\n-\t\treturn false\n+\t\tp.fmtComplex128(f, verb)\n \tcase int:\n-\t\tp.fmtInt64(int64(f), verb, field)\n-\t\treturn false\n+\t\tp.fmtInt64(int64(f), verb)\n \tcase int8:\n-\t\tp.fmtInt64(int64(f), verb, field)\n-\t\treturn false\n+\t\tp.fmtInt64(int64(f), verb)\n \tcase int16:\n-\t\tp.fmtInt64(int64(f), verb, field)\n-\t\treturn false\n+\t\tp.fmtInt64(int64(f), verb)\n \tcase int32:\n-\t\tp.fmtInt64(int64(f), verb, field)\n-\t\treturn false\n+\t\tp.fmtInt64(int64(f), verb)\n \tcase int64:\n-\t\tp.fmtInt64(f, verb, field)\n-\t\treturn false\n+\t\tp.fmtInt64(f, verb)\n \tcase uint:\n-\t\tp.fmtUint64(uint64(f), verb, goSyntax, field)\n-\t\treturn false\n+\t\tp.fmtUint64(uint64(f), verb, goSyntax)\n \tcase uint8:\n-\t\tp.fmtUint64(uint64(f), verb, goSyntax, field)\n-\t\treturn false\n+\t\tp.fmtUint64(uint64(f), verb, goSyntax)\n \tcase uint16:\n-\t\tp.fmtUint64(uint64(f), verb, goSyntax, field)\n-\t\treturn false\n+\t\tp.fmtUint64(uint64(f), verb, goSyntax)\n \tcase uint32:\n-\t\tp.fmtUint64(uint64(f), verb, goSyntax, field)\n-\t\treturn false\n+\t\tp.fmtUint64(uint64(f), verb, goSyntax)\n \tcase uint64:\n-\t\tp.fmtUint64(f, verb, goSyntax, field)\n-\t\treturn false\n+\t\tp.fmtUint64(f, verb, goSyntax)\n \tcase uintptr:\n-\t\tp.fmtUint64(uint64(f), verb, goSyntax, field)\n-\t\treturn false\n+\t\tp.fmtUint64(uint64(f), verb, goSyntax)\n \tcase string:\n-\t\tp.fmtString(f, verb, goSyntax, field)\n-\t\treturn verb == 's' || verb == 'v'\n+\t\tp.fmtString(f, verb, goSyntax)\n+\t\twasString = verb == 's' || verb == 'v'\n \tcase []byte:\n-\t\tp.fmtBytes(f, verb, goSyntax, depth, field)\n-\t\treturn verb == 's'\n+\t\tp.fmtBytes(f, verb, goSyntax, depth)\n+\t\twasString = verb == 's'\n+\tdefault:\n+\t\t// Need to use reflection\n+\t\treturn p.printReflectValue(reflect.ValueOf(field), verb, plus, goSyntax, depth)\n \t}\n-\n-\t// Need to use reflection\n-\treturn p.printReflectValue(reflect.ValueOf(field), verb, plus, goSyntax, depth)\n+\tp.field = nil\n+\treturn\n }\n \n // printValue is like printField but starts with a reflect value, not an interface{} value.\n@@ -733,7 +724,7 @@ func (p *pp) printValue(value reflect.Value, verb int, plus, goSyntax bool, dept\n \t\tif verb == 'T' || verb == 'v' {\n \t\t\tp.buf.Write(nilAngleBytes)\n \t\t} else {\n-\t\t\tp.badVerb(verb, nil)\n+\t\t\tp.badVerb(verb)\n \t\t}\n \t\treturn false\n \t}\n@@ -745,17 +736,17 @@ func (p *pp) printValue(value reflect.Value, verb int, plus, goSyntax bool, dept\n \t\tp.printField(value.Type().String(), 's', false, false, 0)\n \t\treturn false\n \tcase 'p':\n-\t\tp.fmtPointer(nil, value, verb, goSyntax)\n+\t\tp.fmtPointer(value, verb, goSyntax)\n \t\treturn false\n \t}\n \n \t// Handle values with special methods.\n \t// Call always, even when field == nil, because handleMethods clears p.fmt.plus for us.\n-\tvar field interface{}\n+\tp.field = nil // Make sure it's cleared, for safety.\n \tif value.CanInterface() {\n-\t\tfield = value.Interface()\n+\t\tp.field = value.Interface()\n \t}\n-\tif wasString, handled := p.handleMethods(field, verb, plus, goSyntax, depth); handled {\n+\tif wasString, handled := p.handleMethods(verb, plus, goSyntax, depth); handled {\n \t\treturn wasString\n \t}\n \n@@ -770,25 +761,25 @@ func (p *pp) printReflectValue(value reflect.Value, verb int, plus, goSyntax boo\n BigSwitch:\n \tswitch f := value; f.Kind() {\n \tcase reflect.Bool:\n-\t\tp.fmtBool(f.Bool(), verb, nil)\n+\t\tp.fmtBool(f.Bool(), verb)\n \tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n-\t\tp.fmtInt64(f.Int(), verb, nil)\n+\t\tp.fmtInt64(f.Int(), verb)\n \tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n-\t\tp.fmtUint64(uint64(f.Uint()), verb, goSyntax, nil)\n+\t\tp.fmtUint64(uint64(f.Uint()), verb, goSyntax)\n \tcase reflect.Float32, reflect.Float64:\n \t\tif f.Type().Size() == 4 {\n-\t\t\tp.fmtFloat32(float32(f.Float()), verb, nil)\n+\t\t\tp.fmtFloat32(float32(f.Float()), verb)\n \t\t} else {\n-\t\t\tp.fmtFloat64(float64(f.Float()), verb, nil)\n+\t\t\tp.fmtFloat64(float64(f.Float()), verb)\n \t\t}\n \tcase reflect.Complex64, reflect.Complex128:\n \t\tif f.Type().Size() == 8 {\n-\t\t\tp.fmtComplex64(complex64(f.Complex()), verb, nil)\n+\t\t\tp.fmtComplex64(complex64(f.Complex()), verb)\n \t\t} else {\n-\t\t\tp.fmtComplex128(complex128(f.Complex()), verb, nil)\n+\t\t\tp.fmtComplex128(complex128(f.Complex()), verb)\n \t\t}\n \tcase reflect.String:\n-\t\tp.fmtString(f.String(), verb, goSyntax, nil)\n+\t\tp.fmtString(f.String(), verb, goSyntax)\n \tcase reflect.Map:\n \t\tif goSyntax {\n \t\t\tp.buf.WriteString(f.Type().String())\n@@ -842,7 +833,7 @@ BigSwitch:\n \t\tvalue := f.Elem()\n \t\tif !value.IsValid() {\n \t\t\tif goSyntax {\n-\t\t\t\tp.buf.WriteString(value.Type().String())\n+\t\t\t\tp.buf.WriteString(f.Type().String())\n \t\t\t\tp.buf.Write(nilParenBytes)\n \t\t\t} else {\n \t\t\t\tp.buf.Write(nilAngleBytes)\n@@ -864,7 +855,7 @@ BigSwitch:\n \t\t\tfor i := range bytes {\n \t\t\t\tbytes[i] = byte(f.Index(i).Uint())\n \t\t\t}\n-\t\t\tp.fmtBytes(bytes, verb, goSyntax, depth, nil)\n+\t\t\tp.fmtBytes(bytes, verb, goSyntax, depth)\n \t\t\twasString = verb == 's'\n \t\t\tbreak\n \t\t}\n@@ -924,7 +915,7 @@ BigSwitch:\n \t\t}\n \t\tp.fmt0x64(uint64(v), true)\n \tcase reflect.Chan, reflect.Func, reflect.UnsafePointer:\n-\t\tp.fmtPointer(nil, value, verb, goSyntax)\n+\t\tp.fmtPointer(value, verb, goSyntax)\n \tdefault:\n \t\tp.unknownType(f)\n \t}"}, {"sha": "c3153ed6f725abfc96c19b806962e43b0eb1ccf4", "filename": "libgo/go/go/ast/print_test.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fgo%2Fast%2Fprint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fgo%2Fast%2Fprint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fprint_test.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -23,11 +23,10 @@ var tests = []struct {\n \t{\"foobar\", \"0  \\\"foobar\\\"\"},\n \n \t// maps\n-\t{map[string]int{\"a\": 1, \"b\": 2},\n-\t\t`0  map[string] int (len = 2) {\n+\t{map[string]int{\"a\": 1},\n+\t\t`0  map[string] int (len = 1) {\n \t\t1  .  \"a\": 1\n-\t\t2  .  \"b\": 2\n-\t\t3  }`},\n+\t\t2  }`},\n \n \t// pointers\n \t{new(int), \"0  *0\"},"}, {"sha": "ba9d188486f3ecce1f1508f4cfa355a21a7a2107", "filename": "libgo/go/html/doc.go", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fhtml%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fhtml%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fdoc.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -70,9 +70,6 @@ call to Next. For example, to extract an HTML page's anchor text:\n \t\t}\n \t}\n \n-A Tokenizer typically skips over HTML comments. To return comment tokens, set\n-Tokenizer.ReturnComments to true before looping over calls to Next.\n-\n Parsing is done by calling Parse with an io.Reader, which returns the root of\n the parse tree (the document element) as a *Node. It is the caller's\n responsibility to ensure that the Reader provides UTF-8 encoded HTML. For"}, {"sha": "530942aa8f0904b8445c19917ef428f7925905ce", "filename": "libgo/go/html/parse.go", "status": "modified", "additions": 319, "deletions": 34, "changes": 353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fhtml%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fhtml%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -32,6 +32,9 @@ type parser struct {\n \t// originalIM is the insertion mode to go back to after completing a text\n \t// or inTableText insertion mode.\n \toriginalIM insertionMode\n+\t// fosterParenting is whether new elements should be inserted according to\n+\t// the foster parenting rules (section 11.2.5.3).\n+\tfosterParenting bool\n }\n \n func (p *parser) top() *Node {\n@@ -49,6 +52,11 @@ var (\n \ttableScopeStopTags    = []string{\"html\", \"table\"}\n )\n \n+// stopTags for use in clearStackToContext.\n+var (\n+\ttableRowContextStopTags = []string{\"tr\", \"html\"}\n+)\n+\n // popUntil pops the stack of open elements at the highest element whose tag\n // is in matchTags, provided there is no higher element in stopTags. It returns\n // whether or not there was such an element. If there was not, popUntil leaves\n@@ -103,12 +111,61 @@ func (p *parser) elementInScope(stopTags []string, matchTags ...string) bool {\n // addChild adds a child node n to the top element, and pushes n onto the stack\n // of open elements if it is an element node.\n func (p *parser) addChild(n *Node) {\n-\tp.top().Add(n)\n+\tif p.fosterParenting {\n+\t\tp.fosterParent(n)\n+\t} else {\n+\t\tp.top().Add(n)\n+\t}\n+\n \tif n.Type == ElementNode {\n \t\tp.oe = append(p.oe, n)\n \t}\n }\n \n+// fosterParent adds a child node according to the foster parenting rules.\n+// Section 11.2.5.3, \"foster parenting\".\n+func (p *parser) fosterParent(n *Node) {\n+\tvar table, parent *Node\n+\tvar i int\n+\tfor i = len(p.oe) - 1; i >= 0; i-- {\n+\t\tif p.oe[i].Data == \"table\" {\n+\t\t\ttable = p.oe[i]\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\tif table == nil {\n+\t\t// The foster parent is the html element.\n+\t\tparent = p.oe[0]\n+\t} else {\n+\t\tparent = table.Parent\n+\t}\n+\tif parent == nil {\n+\t\tparent = p.oe[i-1]\n+\t}\n+\n+\tvar child *Node\n+\tfor i, child = range parent.Child {\n+\t\tif child == table {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\tif i > 0 && parent.Child[i-1].Type == TextNode && n.Type == TextNode {\n+\t\tparent.Child[i-1].Data += n.Data\n+\t\treturn\n+\t}\n+\n+\tif i == len(parent.Child) {\n+\t\tparent.Add(n)\n+\t} else {\n+\t\t// Insert n into parent.Child at index i.\n+\t\tparent.Child = append(parent.Child[:i+1], parent.Child[i:]...)\n+\t\tparent.Child[i] = n\n+\t\tn.Parent = parent\n+\t}\n+}\n+\n // addText adds text to the preceding node if it is a text node, or else it\n // calls addChild with a new text node.\n func (p *parser) addText(text string) {\n@@ -170,9 +227,9 @@ func (p *parser) reconstructActiveFormattingElements() {\n \t}\n \tfor {\n \t\ti++\n-\t\tn = p.afe[i]\n-\t\tp.addChild(n.clone())\n-\t\tp.afe[i] = n\n+\t\tclone := p.afe[i].clone()\n+\t\tp.addChild(clone)\n+\t\tp.afe[i] = clone\n \t\tif i == len(p.afe)-1 {\n \t\t\tbreak\n \t\t}\n@@ -234,10 +291,52 @@ func (p *parser) setOriginalIM(im insertionMode) {\n \tp.originalIM = im\n }\n \n+// Section 11.2.3.1, \"reset the insertion mode\".\n+func (p *parser) resetInsertionMode() insertionMode {\n+\tfor i := len(p.oe) - 1; i >= 0; i-- {\n+\t\tn := p.oe[i]\n+\t\tif i == 0 {\n+\t\t\t// TODO: set n to the context element, for HTML fragment parsing.\n+\t\t}\n+\t\tswitch n.Data {\n+\t\tcase \"select\":\n+\t\t\treturn inSelectIM\n+\t\tcase \"td\", \"th\":\n+\t\t\treturn inCellIM\n+\t\tcase \"tr\":\n+\t\t\treturn inRowIM\n+\t\tcase \"tbody\", \"thead\", \"tfoot\":\n+\t\t\treturn inTableBodyIM\n+\t\tcase \"caption\":\n+\t\t\t// TODO: return inCaptionIM\n+\t\tcase \"colgroup\":\n+\t\t\t// TODO: return inColumnGroupIM\n+\t\tcase \"table\":\n+\t\t\treturn inTableIM\n+\t\tcase \"head\":\n+\t\t\treturn inBodyIM\n+\t\tcase \"body\":\n+\t\t\treturn inBodyIM\n+\t\tcase \"frameset\":\n+\t\t\t// TODO: return inFramesetIM\n+\t\tcase \"html\":\n+\t\t\treturn beforeHeadIM\n+\t\t}\n+\t}\n+\treturn inBodyIM\n+}\n+\n // Section 11.2.5.4.1.\n func initialIM(p *parser) (insertionMode, bool) {\n-\tif p.tok.Type == DoctypeToken {\n-\t\tp.addChild(&Node{\n+\tswitch p.tok.Type {\n+\tcase CommentToken:\n+\t\tp.doc.Add(&Node{\n+\t\t\tType: CommentNode,\n+\t\t\tData: p.tok.Data,\n+\t\t})\n+\t\treturn initialIM, true\n+\tcase DoctypeToken:\n+\t\tp.doc.Add(&Node{\n \t\t\tType: DoctypeNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n@@ -275,6 +374,12 @@ func beforeHTMLIM(p *parser) (insertionMode, bool) {\n \t\tdefault:\n \t\t\t// Ignore the token.\n \t\t}\n+\tcase CommentToken:\n+\t\tp.doc.Add(&Node{\n+\t\t\tType: CommentNode,\n+\t\t\tData: p.tok.Data,\n+\t\t})\n+\t\treturn beforeHTMLIM, true\n \t}\n \tif add || implied {\n \t\tp.addElement(\"html\", attr)\n@@ -312,6 +417,12 @@ func beforeHeadIM(p *parser) (insertionMode, bool) {\n \t\tdefault:\n \t\t\t// Ignore the token.\n \t\t}\n+\tcase CommentToken:\n+\t\tp.addChild(&Node{\n+\t\t\tType: CommentNode,\n+\t\t\tData: p.tok.Data,\n+\t\t})\n+\t\treturn beforeHeadIM, true\n \t}\n \tif add || implied {\n \t\tp.addElement(\"head\", attr)\n@@ -344,11 +455,17 @@ func inHeadIM(p *parser) (insertionMode, bool) {\n \t\t\tpop = true\n \t\t}\n \t\t// TODO.\n+\tcase CommentToken:\n+\t\tp.addChild(&Node{\n+\t\t\tType: CommentNode,\n+\t\t\tData: p.tok.Data,\n+\t\t})\n+\t\treturn inHeadIM, true\n \t}\n \tif pop || implied {\n \t\tn := p.oe.pop()\n \t\tif n.Data != \"head\" {\n-\t\t\tpanic(\"html: bad parser state\")\n+\t\t\tpanic(\"html: bad parser state: <head> element not found, in the in-head insertion mode\")\n \t\t}\n \t\treturn afterHeadIM, !implied\n \t}\n@@ -387,6 +504,12 @@ func afterHeadIM(p *parser) (insertionMode, bool) {\n \t\t}\n \tcase EndTagToken:\n \t\t// TODO.\n+\tcase CommentToken:\n+\t\tp.addChild(&Node{\n+\t\t\tType: CommentNode,\n+\t\t\tData: p.tok.Data,\n+\t\t})\n+\t\treturn afterHeadIM, true\n \t}\n \tif add || implied {\n \t\tp.addElement(\"body\", attr)\n@@ -447,6 +570,30 @@ func inBodyIM(p *parser) (insertionMode, bool) {\n \t\t\tp.oe.pop()\n \t\t\tp.acknowledgeSelfClosingTag()\n \t\t\tp.framesetOK = false\n+\t\tcase \"select\":\n+\t\t\tp.reconstructActiveFormattingElements()\n+\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\t\tp.framesetOK = false\n+\t\t\t// TODO: detect <select> inside a table.\n+\t\t\treturn inSelectIM, true\n+\t\tcase \"li\":\n+\t\t\tp.framesetOK = false\n+\t\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n+\t\t\t\tnode := p.oe[i]\n+\t\t\t\tswitch node.Data {\n+\t\t\t\tcase \"li\":\n+\t\t\t\t\tp.popUntil(listItemScopeStopTags, \"li\")\n+\t\t\t\tcase \"address\", \"div\", \"p\":\n+\t\t\t\t\tcontinue\n+\t\t\t\tdefault:\n+\t\t\t\t\tif !isSpecialElement[node.Data] {\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tp.popUntil(buttonScopeStopTags, \"p\")\n+\t\t\tp.addElement(\"li\", p.tok.Attr)\n \t\tdefault:\n \t\t\t// TODO.\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n@@ -463,12 +610,16 @@ func inBodyIM(p *parser) (insertionMode, bool) {\n \t\t\tp.popUntil(buttonScopeStopTags, \"p\")\n \t\tcase \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\":\n \t\t\tp.inBodyEndTagFormatting(p.tok.Data)\n+\t\tcase \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\", \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\", \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\":\n+\t\t\tp.popUntil(defaultScopeStopTags, p.tok.Data)\n \t\tdefault:\n-\t\t\t// TODO: any other end tag\n-\t\t\tif p.tok.Data == p.top().Data {\n-\t\t\t\tp.oe.pop()\n-\t\t\t}\n+\t\t\tp.inBodyEndTagOther(p.tok.Data)\n \t\t}\n+\tcase CommentToken:\n+\t\tp.addChild(&Node{\n+\t\t\tType: CommentNode,\n+\t\t\tData: p.tok.Data,\n+\t\t})\n \t}\n \n \treturn inBodyIM, true\n@@ -496,6 +647,7 @@ func (p *parser) inBodyEndTagFormatting(tag string) {\n \t\t\t}\n \t\t}\n \t\tif formattingElement == nil {\n+\t\t\tp.inBodyEndTagOther(tag)\n \t\t\treturn\n \t\t}\n \t\tfeIndex := p.oe.index(formattingElement)\n@@ -568,8 +720,7 @@ func (p *parser) inBodyEndTagFormatting(tag string) {\n \t\t}\n \t\tswitch commonAncestor.Data {\n \t\tcase \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\":\n-\t\t\t// TODO: fix up misnested table nodes; find the foster parent.\n-\t\t\tfallthrough\n+\t\t\tp.fosterParent(lastNode)\n \t\tdefault:\n \t\t\tcommonAncestor.Add(lastNode)\n \t\t}\n@@ -590,6 +741,19 @@ func (p *parser) inBodyEndTagFormatting(tag string) {\n \t}\n }\n \n+// inBodyEndTagOther performs the \"any other end tag\" algorithm for inBodyIM.\n+func (p *parser) inBodyEndTagOther(tag string) {\n+\tfor i := len(p.oe) - 1; i >= 0; i-- {\n+\t\tif p.oe[i].Data == tag {\n+\t\t\tp.oe = p.oe[:i]\n+\t\t\tbreak\n+\t\t}\n+\t\tif isSpecialElement[p.oe[i].Data] {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+}\n+\n // Section 11.2.5.4.8.\n func textIM(p *parser) (insertionMode, bool) {\n \tswitch p.tok.Type {\n@@ -606,12 +770,6 @@ func textIM(p *parser) (insertionMode, bool) {\n \n // Section 11.2.5.4.9.\n func inTableIM(p *parser) (insertionMode, bool) {\n-\tvar (\n-\t\tadd      bool\n-\t\tdata     string\n-\t\tattr     []Attribute\n-\t\tconsumed bool\n-\t)\n \tswitch p.tok.Type {\n \tcase ErrorToken:\n \t\t// Stop parsing.\n@@ -621,37 +779,62 @@ func inTableIM(p *parser) (insertionMode, bool) {\n \tcase StartTagToken:\n \t\tswitch p.tok.Data {\n \t\tcase \"tbody\", \"tfoot\", \"thead\":\n-\t\t\tadd = true\n-\t\t\tdata = p.tok.Data\n-\t\t\tattr = p.tok.Attr\n-\t\t\tconsumed = true\n+\t\t\tp.clearStackToContext(tableScopeStopTags)\n+\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\t\treturn inTableBodyIM, true\n \t\tcase \"td\", \"th\", \"tr\":\n-\t\t\tadd = true\n-\t\t\tdata = \"tbody\"\n+\t\t\tp.clearStackToContext(tableScopeStopTags)\n+\t\t\tp.addElement(\"tbody\", nil)\n+\t\t\treturn inTableBodyIM, false\n+\t\tcase \"table\":\n+\t\t\tif p.popUntil(tableScopeStopTags, \"table\") {\n+\t\t\t\treturn p.resetInsertionMode(), false\n+\t\t\t}\n+\t\t\t// Ignore the token.\n+\t\t\treturn inTableIM, true\n \t\tdefault:\n \t\t\t// TODO.\n \t\t}\n \tcase EndTagToken:\n \t\tswitch p.tok.Data {\n \t\tcase \"table\":\n \t\t\tif p.popUntil(tableScopeStopTags, \"table\") {\n-\t\t\t\t// TODO: \"reset the insertion mode appropriately\" as per 11.2.3.1.\n-\t\t\t\treturn inBodyIM, false\n+\t\t\t\treturn p.resetInsertionMode(), true\n \t\t\t}\n \t\t\t// Ignore the token.\n \t\t\treturn inTableIM, true\n \t\tcase \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\":\n \t\t\t// Ignore the token.\n \t\t\treturn inTableIM, true\n \t\t}\n+\tcase CommentToken:\n+\t\tp.addChild(&Node{\n+\t\t\tType: CommentNode,\n+\t\t\tData: p.tok.Data,\n+\t\t})\n+\t\treturn inTableIM, true\n \t}\n-\tif add {\n-\t\t// TODO: clear the stack back to a table context.\n-\t\tp.addElement(data, attr)\n-\t\treturn inTableBodyIM, consumed\n+\n+\tswitch p.top().Data {\n+\tcase \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\":\n+\t\tp.fosterParenting = true\n+\t\tdefer func() { p.fosterParenting = false }()\n+\t}\n+\n+\treturn useTheRulesFor(p, inTableIM, inBodyIM)\n+}\n+\n+// clearStackToContext pops elements off the stack of open elements\n+// until an element listed in stopTags is found.\n+func (p *parser) clearStackToContext(stopTags []string) {\n+\tfor i := len(p.oe) - 1; i >= 0; i-- {\n+\t\tfor _, tag := range stopTags {\n+\t\t\tif p.oe[i].Data == tag {\n+\t\t\t\tp.oe = p.oe[:i+1]\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n \t}\n-\t// TODO: return useTheRulesFor(inTableIM, inBodyIM, p) unless etc. etc. foster parenting.\n-\treturn inTableIM, true\n }\n \n // Section 11.2.5.4.13.\n@@ -693,6 +876,12 @@ func inTableBodyIM(p *parser) (insertionMode, bool) {\n \t\t\t// Ignore the token.\n \t\t\treturn inTableBodyIM, true\n \t\t}\n+\tcase CommentToken:\n+\t\tp.addChild(&Node{\n+\t\t\tType: CommentNode,\n+\t\t\tData: p.tok.Data,\n+\t\t})\n+\t\treturn inTableBodyIM, true\n \t}\n \tif add {\n \t\t// TODO: clear the stack back to a table body context.\n@@ -722,7 +911,12 @@ func inRowIM(p *parser) (insertionMode, bool) {\n \tcase EndTagToken:\n \t\tswitch p.tok.Data {\n \t\tcase \"tr\":\n-\t\t\t// TODO.\n+\t\t\tif !p.elementInScope(tableScopeStopTags, \"tr\") {\n+\t\t\t\treturn inRowIM, true\n+\t\t\t}\n+\t\t\tp.clearStackToContext(tableRowContextStopTags)\n+\t\t\tp.oe.pop()\n+\t\t\treturn inTableBodyIM, true\n \t\tcase \"table\":\n \t\t\tif p.popUntil(tableScopeStopTags, \"tr\") {\n \t\t\t\treturn inTableBodyIM, false\n@@ -737,6 +931,12 @@ func inRowIM(p *parser) (insertionMode, bool) {\n \t\tdefault:\n \t\t\t// TODO.\n \t\t}\n+\tcase CommentToken:\n+\t\tp.addChild(&Node{\n+\t\t\tType: CommentNode,\n+\t\t\tData: p.tok.Data,\n+\t\t})\n+\t\treturn inRowIM, true\n \t}\n \treturn useTheRulesFor(p, inRowIM, inTableIM)\n }\n@@ -763,6 +963,12 @@ func inCellIM(p *parser) (insertionMode, bool) {\n \t\t\t// TODO: check for matching element in table scope.\n \t\t\tcloseTheCellAndReprocess = true\n \t\t}\n+\tcase CommentToken:\n+\t\tp.addChild(&Node{\n+\t\t\tType: CommentNode,\n+\t\t\tData: p.tok.Data,\n+\t\t})\n+\t\treturn inCellIM, true\n \t}\n \tif closeTheCellAndReprocess {\n \t\tif p.popUntil(tableScopeStopTags, \"td\") || p.popUntil(tableScopeStopTags, \"th\") {\n@@ -773,6 +979,68 @@ func inCellIM(p *parser) (insertionMode, bool) {\n \treturn useTheRulesFor(p, inCellIM, inBodyIM)\n }\n \n+// Section 11.2.5.4.16.\n+func inSelectIM(p *parser) (insertionMode, bool) {\n+\tendSelect := false\n+\tswitch p.tok.Type {\n+\tcase ErrorToken:\n+\t\t// TODO.\n+\tcase TextToken:\n+\t\tp.addText(p.tok.Data)\n+\tcase StartTagToken:\n+\t\tswitch p.tok.Data {\n+\t\tcase \"html\":\n+\t\t\t// TODO.\n+\t\tcase \"option\":\n+\t\t\tif p.top().Data == \"option\" {\n+\t\t\t\tp.oe.pop()\n+\t\t\t}\n+\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\tcase \"optgroup\":\n+\t\t\t// TODO.\n+\t\tcase \"select\":\n+\t\t\tendSelect = true\n+\t\tcase \"input\", \"keygen\", \"textarea\":\n+\t\t\t// TODO.\n+\t\tcase \"script\":\n+\t\t\t// TODO.\n+\t\tdefault:\n+\t\t\t// Ignore the token.\n+\t\t}\n+\tcase EndTagToken:\n+\t\tswitch p.tok.Data {\n+\t\tcase \"option\":\n+\t\t\t// TODO.\n+\t\tcase \"optgroup\":\n+\t\t\t// TODO.\n+\t\tcase \"select\":\n+\t\t\tendSelect = true\n+\t\tdefault:\n+\t\t\t// Ignore the token.\n+\t\t}\n+\tcase CommentToken:\n+\t\tp.doc.Add(&Node{\n+\t\t\tType: CommentNode,\n+\t\t\tData: p.tok.Data,\n+\t\t})\n+\t}\n+\tif endSelect {\n+\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n+\t\t\tswitch p.oe[i].Data {\n+\t\t\tcase \"select\":\n+\t\t\t\tp.oe = p.oe[:i]\n+\t\t\t\treturn p.resetInsertionMode(), true\n+\t\t\tcase \"option\", \"optgroup\":\n+\t\t\t\tcontinue\n+\t\t\tdefault:\n+\t\t\t\t// Ignore the token.\n+\t\t\t\treturn inSelectIM, true\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn inSelectIM, true\n+}\n+\n // Section 11.2.5.4.18.\n func afterBodyIM(p *parser) (insertionMode, bool) {\n \tswitch p.tok.Type {\n@@ -790,7 +1058,18 @@ func afterBodyIM(p *parser) (insertionMode, bool) {\n \t\tdefault:\n \t\t\t// TODO.\n \t\t}\n+\tcase CommentToken:\n+\t\t// The comment is attached to the <html> element.\n+\t\tif len(p.oe) < 1 || p.oe[0].Data != \"html\" {\n+\t\t\tpanic(\"html: bad parser state: <html> element not found, in the after-body insertion mode\")\n+\t\t}\n+\t\tp.oe[0].Add(&Node{\n+\t\t\tType: CommentNode,\n+\t\t\tData: p.tok.Data,\n+\t\t})\n+\t\treturn afterBodyIM, true\n \t}\n+\t// TODO: should this be \"return inBodyIM, true\"?\n \treturn afterBodyIM, true\n }\n \n@@ -806,6 +1085,12 @@ func afterAfterBodyIM(p *parser) (insertionMode, bool) {\n \t\tif p.tok.Data == \"html\" {\n \t\t\treturn useTheRulesFor(p, afterAfterBodyIM, inBodyIM)\n \t\t}\n+\tcase CommentToken:\n+\t\tp.doc.Add(&Node{\n+\t\t\tType: CommentNode,\n+\t\t\tData: p.tok.Data,\n+\t\t})\n+\t\treturn afterAfterBodyIM, true\n \t}\n \treturn inBodyIM, false\n }"}, {"sha": "b0ddd9247629b7510290554d7b457056d98f49e2", "filename": "libgo/go/html/parse_test.go", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fhtml%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fhtml%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse_test.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -69,22 +69,31 @@ func readDat(filename string, c chan io.Reader) {\n \t}\n }\n \n-func dumpLevel(w io.Writer, n *Node, level int) os.Error {\n+func dumpIndent(w io.Writer, level int) {\n \tio.WriteString(w, \"| \")\n \tfor i := 0; i < level; i++ {\n \t\tio.WriteString(w, \"  \")\n \t}\n+}\n+\n+func dumpLevel(w io.Writer, n *Node, level int) os.Error {\n+\tdumpIndent(w, level)\n \tswitch n.Type {\n \tcase ErrorNode:\n \t\treturn os.NewError(\"unexpected ErrorNode\")\n \tcase DocumentNode:\n \t\treturn os.NewError(\"unexpected DocumentNode\")\n \tcase ElementNode:\n \t\tfmt.Fprintf(w, \"<%s>\", n.Data)\n+\t\tfor _, a := range n.Attr {\n+\t\t\tio.WriteString(w, \"\\n\")\n+\t\t\tdumpIndent(w, level+1)\n+\t\t\tfmt.Fprintf(w, `%s=\"%s\"`, a.Key, a.Val)\n+\t\t}\n \tcase TextNode:\n \t\tfmt.Fprintf(w, \"%q\", n.Data)\n \tcase CommentNode:\n-\t\treturn os.NewError(\"COMMENT\")\n+\t\tfmt.Fprintf(w, \"<!-- %s -->\", n.Data)\n \tcase DoctypeNode:\n \t\tfmt.Fprintf(w, \"<!DOCTYPE %s>\", n.Data)\n \tcase scopeMarkerNode:\n@@ -123,7 +132,7 @@ func TestParser(t *testing.T) {\n \t\trc := make(chan io.Reader)\n \t\tgo readDat(filename, rc)\n \t\t// TODO(nigeltao): Process all test cases, not just a subset.\n-\t\tfor i := 0; i < 27; i++ {\n+\t\tfor i := 0; i < 34; i++ {\n \t\t\t// Parse the #data section.\n \t\t\tb, err := ioutil.ReadAll(<-rc)\n \t\t\tif err != nil {\n@@ -152,6 +161,13 @@ func TestParser(t *testing.T) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\t// Check that rendering and re-parsing results in an identical tree.\n+\t\t\tif filename == \"tests1.dat\" && i == 30 {\n+\t\t\t\t// Test 30 in tests1.dat is such messed-up markup that a correct parse\n+\t\t\t\t// results in a non-conforming tree (one <a> element nested inside another).\n+\t\t\t\t// Therefore when it is rendered and re-parsed, it isn't the same.\n+\t\t\t\t// So we skip rendering on that test.\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\tpr, pw := io.Pipe()\n \t\t\tgo func() {\n \t\t\t\tpw.CloseWithError(Render(pw, doc))"}, {"sha": "d5dc44843330c760f006d57c943bf4bfe00eec83", "filename": "libgo/go/html/render.go", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fhtml%2Frender.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fhtml%2Frender.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Frender.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -30,9 +30,6 @@ type writer interface {\n // would become a tree containing <html>, <head> and <body> elements. Another\n // example is that the programmatic equivalent of \"a<head>b</head>c\" becomes\n // \"<html><head><head/><body>abc</body></html>\".\n-//\n-// Comment nodes are elided from the output, analogous to Parse skipping over\n-// any <!--comment--> input.\n func Render(w io.Writer, n *Node) os.Error {\n \tif x, ok := w.(writer); ok {\n \t\treturn render(x, n)\n@@ -61,6 +58,15 @@ func render(w writer, n *Node) os.Error {\n \tcase ElementNode:\n \t\t// No-op.\n \tcase CommentNode:\n+\t\tif _, err := w.WriteString(\"<!--\"); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif _, err := w.WriteString(n.Data); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif _, err := w.WriteString(\"-->\"); err != nil {\n+\t\t\treturn err\n+\t\t}\n \t\treturn nil\n \tcase DoctypeNode:\n \t\tif _, err := w.WriteString(\"<!DOCTYPE \"); err != nil {"}, {"sha": "952d17468bd97b9a3584c5a9af950ccef80ecc99", "filename": "libgo/go/html/token.go", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fhtml%2Ftoken.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fhtml%2Ftoken.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftoken.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -116,10 +116,6 @@ type span struct {\n \n // A Tokenizer returns a stream of HTML Tokens.\n type Tokenizer struct {\n-\t// If ReturnComments is set, Next returns comment tokens;\n-\t// otherwise it skips over comments (default).\n-\tReturnComments bool\n-\n \t// r is the source of the HTML text.\n \tr io.Reader\n \t// tt is the TokenType of the current token.\n@@ -546,17 +542,19 @@ func (z *Tokenizer) readTagAttrVal() {\n \t}\n }\n \n-// next scans the next token and returns its type.\n-func (z *Tokenizer) next() TokenType {\n+// Next scans the next token and returns its type.\n+func (z *Tokenizer) Next() TokenType {\n \tif z.err != nil {\n-\t\treturn ErrorToken\n+\t\tz.tt = ErrorToken\n+\t\treturn z.tt\n \t}\n \tz.raw.start = z.raw.end\n \tz.data.start = z.raw.end\n \tz.data.end = z.raw.end\n \tif z.rawTag != \"\" {\n \t\tz.readRawOrRCDATA()\n-\t\treturn TextToken\n+\t\tz.tt = TextToken\n+\t\treturn z.tt\n \t}\n \tz.textIsRaw = false\n \n@@ -596,11 +594,13 @@ loop:\n \t\tif x := z.raw.end - len(\"<a\"); z.raw.start < x {\n \t\t\tz.raw.end = x\n \t\t\tz.data.end = x\n-\t\t\treturn TextToken\n+\t\t\tz.tt = TextToken\n+\t\t\treturn z.tt\n \t\t}\n \t\tswitch tokenType {\n \t\tcase StartTagToken:\n-\t\t\treturn z.readStartTag()\n+\t\t\tz.tt = z.readStartTag()\n+\t\t\treturn z.tt\n \t\tcase EndTagToken:\n \t\t\tc = z.readByte()\n \t\t\tif z.err != nil {\n@@ -616,39 +616,31 @@ loop:\n \t\t\t}\n \t\t\tif 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z' {\n \t\t\t\tz.readEndTag()\n-\t\t\t\treturn EndTagToken\n+\t\t\t\tz.tt = EndTagToken\n+\t\t\t\treturn z.tt\n \t\t\t}\n \t\t\tz.raw.end--\n \t\t\tz.readUntilCloseAngle()\n-\t\t\treturn CommentToken\n+\t\t\tz.tt = CommentToken\n+\t\t\treturn z.tt\n \t\tcase CommentToken:\n \t\t\tif c == '!' {\n-\t\t\t\treturn z.readMarkupDeclaration()\n+\t\t\t\tz.tt = z.readMarkupDeclaration()\n+\t\t\t\treturn z.tt\n \t\t\t}\n \t\t\tz.raw.end--\n \t\t\tz.readUntilCloseAngle()\n-\t\t\treturn CommentToken\n+\t\t\tz.tt = CommentToken\n+\t\t\treturn z.tt\n \t\t}\n \t}\n \tif z.raw.start < z.raw.end {\n \t\tz.data.end = z.raw.end\n-\t\treturn TextToken\n-\t}\n-\treturn ErrorToken\n-}\n-\n-// Next scans the next token and returns its type.\n-func (z *Tokenizer) Next() TokenType {\n-\tfor {\n-\t\tz.tt = z.next()\n-\t\t// TODO: remove the ReturnComments option. A tokenizer should\n-\t\t// always return comment tags.\n-\t\tif z.tt == CommentToken && !z.ReturnComments {\n-\t\t\tcontinue\n-\t\t}\n+\t\tz.tt = TextToken\n \t\treturn z.tt\n \t}\n-\tpanic(\"unreachable\")\n+\tz.tt = ErrorToken\n+\treturn z.tt\n }\n \n // Raw returns the unmodified text of the current token. Calling Next, Token,"}, {"sha": "45ce85e911573c8eab4f75da44c884484f1f1187", "filename": "libgo/go/html/token_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fhtml%2Ftoken_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fhtml%2Ftoken_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftoken_test.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -424,7 +424,6 @@ func TestTokenizer(t *testing.T) {\n loop:\n \tfor _, tt := range tokenTests {\n \t\tz := NewTokenizer(strings.NewReader(tt.html))\n-\t\tz.ReturnComments = true\n \t\tif tt.golden != \"\" {\n \t\t\tfor i, s := range strings.Split(tt.golden, \"$\") {\n \t\t\t\tif z.Next() == ErrorToken {"}, {"sha": "e939b96a311a5b69eb2f78e291260457588e093a", "filename": "libgo/go/http/client.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fhttp%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fhttp%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fclient.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -2,7 +2,10 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Primitive HTTP client. See RFC 2616.\n+// HTTP client. See RFC 2616.\n+// \n+// This is the high-level Client interface.\n+// The low-level implementation is in transport.go.\n \n package http\n "}, {"sha": "8f61286c46abc3c222e225d9562a52d23bb010b5", "filename": "libgo/go/http/client_test.go", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fhttp%2Fclient_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fhttp%2Fclient_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fclient_test.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -7,6 +7,7 @@\n package http_test\n \n import (\n+\t\"crypto/tls\"\n \t\"fmt\"\n \t. \"http\"\n \t\"http/httptest\"\n@@ -292,3 +293,26 @@ func TestClientWrites(t *testing.T) {\n \t\tt.Errorf(\"Post request did %d Write calls, want 1\", writes)\n \t}\n }\n+\n+func TestClientInsecureTransport(t *testing.T) {\n+\tts := httptest.NewTLSServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tw.Write([]byte(\"Hello\"))\n+\t}))\n+\tdefer ts.Close()\n+\n+\t// TODO(bradfitz): add tests for skipping hostname checks too?\n+\t// would require a new cert for testing, and probably\n+\t// redundant with these tests.\n+\tfor _, insecure := range []bool{true, false} {\n+\t\ttr := &Transport{\n+\t\t\tTLSClientConfig: &tls.Config{\n+\t\t\t\tInsecureSkipVerify: insecure,\n+\t\t\t},\n+\t\t}\n+\t\tc := &Client{Transport: tr}\n+\t\t_, err := c.Get(ts.URL)\n+\t\tif (err == nil) != insecure {\n+\t\t\tt.Errorf(\"insecure=%v: got unexpected err=%v\", insecure, err)\n+\t\t}\n+\t}\n+}"}, {"sha": "9c47ac7823fde5085337d172b9ee2502e96f7712", "filename": "libgo/go/http/doc.go", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fhttp%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fhttp%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fdoc.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+/*\n+Package http provides HTTP client and server implementations.\n+\n+Get, Head, Post, and PostForm make HTTP requests:\n+\n+\tresp, err := http.Get(\"http://example.com/\")\n+\t...\n+\tresp, err := http.Post(\"http://example.com/upload\", \"image/jpeg\", &buf)\n+\t...\n+\tresp, err := http.PostForm(\"http://example.com/form\",\n+ \t\turl.Values{\"key\": {\"Value\"}, \"id\": {\"123\"}})\n+\n+The client must close the response body when finished with it:\n+\n+\tresp, err := http.Get(\"http://example.com/\")\n+\tif err != nil {\n+\t\t// handle error\n+\t}\n+\tdefer resp.Body.Close()\n+\tbody, err := ioutil.ReadAll(resp.Body)\n+\t// ...\n+\n+For control over HTTP client headers, redirect policy, and other\n+settings, create a Client:\n+\n+\tclient := &http.Client{\n+\t\tCheckRedirect: redirectPolicyFunc,\n+\t}\n+\n+\tresp, err := client.Get(\"http://example.com\")\n+\t// ...\n+\n+\treq := http.NewRequest(\"GET\", \"http://example.com\", nil)\n+\treq.Header.Add(\"If-None-Match\", `W/\"wyzzy\"`)\n+\tresp, err := client.Do(req)\n+\t// ...\n+\n+For control over proxies, TLS configuration, keep-alives,\n+compression, and other settings, create a Transport:\n+\n+\ttr := &http.Transport{\n+\t\tTLSClientConfig:    &tls.Config{RootCAs: pool},\n+\t\tDisableCompression: true,\n+\t}\n+\tclient := &http.Client{Transport: tr}\n+\tresp, err := client.Get(\"https://example.com\")\n+\n+Clients and Transports are safe for concurrent use by multiple\n+goroutines and for efficiency should only be created once and re-used.\n+\n+ListenAndServe starts an HTTP server with a given address and handler.\n+The handler is usually nil, which means to use DefaultServeMux.\n+Handle and HandleFunc add handlers to DefaultServeMux:\n+\n+\thttp.Handle(\"/foo\", fooHandler)\n+\n+\thttp.HandleFunc(\"/bar\", func(w http.ResponseWriter, r *http.Request) {\n+\t\tfmt.Fprintf(w, \"Hello, %q\", html.EscapeString(r.URL.RawPath))\n+\t})\n+\n+\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n+\n+More control over the server's behavior is available by creating a\n+custom Server:\n+\n+\ts := &http.Server{\n+\t\tAddr:           \":8080\",\n+\t\tHandler:        myHandler,\n+\t\tReadTimeout:    10e9,\n+\t\tWriteTimeout:   10e9,\n+\t\tMaxHeaderBytes: 1 << 20,\n+\t}\n+\tlog.Fatal(s.ListenAndServe())\n+*/\n+package http"}, {"sha": "78e07ecbc97eae38b25d8d5629377385ef775d75", "filename": "libgo/go/http/request.go", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fhttp%2Frequest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fhttp%2Frequest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Frequest.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -4,8 +4,6 @@\n \n // HTTP Request reading and parsing.\n \n-// Package http implements parsing of HTTP requests, replies, and URLs and\n-// provides an extensible HTTP server and a basic HTTP client.\n package http\n \n import ("}, {"sha": "1d4433d14f6e66cd945f522023fd8112dc5b9d69", "filename": "libgo/go/http/transport.go", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ftransport.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -2,6 +2,11 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// HTTP client implementation. See RFC 2616.\n+// \n+// This is the low-level Transport implementation of RoundTripper.\n+// The high-level interface is in client.go.\n+\n package http\n \n import (\n@@ -357,8 +362,10 @@ func (t *Transport) getConn(cm *connectMethod) (*persistConn, os.Error) {\n \t\tif err = conn.(*tls.Conn).Handshake(); err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\tif err = conn.(*tls.Conn).VerifyHostname(cm.tlsHost()); err != nil {\n-\t\t\treturn nil, err\n+\t\tif t.TLSClientConfig == nil || !t.TLSClientConfig.InsecureSkipVerify {\n+\t\t\tif err = conn.(*tls.Conn).VerifyHostname(cm.tlsHost()); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n \t\t}\n \t\tpconn.conn = conn\n \t}"}, {"sha": "5169d1e6a29ea58ccaa365aa403a2b31da9ec6a3", "filename": "libgo/go/net/sock_windows.go", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fnet%2Fsock_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Fnet%2Fsock_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock_windows.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30", "patch": "@@ -11,9 +11,6 @@ import (\n )\n \n func setKernelSpecificSockopt(s syscall.Handle, f int) {\n-\t// Allow reuse of recently-used addresses and ports.\n-\tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n-\n \t// Allow broadcast.\n \tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_BROADCAST, 1)\n "}, {"sha": "a3b882625ef5affae0f3de4dccf9a32904261f15", "filename": "libgo/go/unicode/tables.go", "status": "modified", "additions": 3488, "deletions": 3488, "changes": 6976, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Funicode%2Ftables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b740cb6335fd36e5847f2abd3c890b7f14d1ef30/libgo%2Fgo%2Funicode%2Ftables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Ftables.go?ref=b740cb6335fd36e5847f2abd3c890b7f14d1ef30"}]}