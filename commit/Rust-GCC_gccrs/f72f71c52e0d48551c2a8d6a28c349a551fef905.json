{"sha": "f72f71c52e0d48551c2a8d6a28c349a551fef905", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjcyZjcxYzUyZTBkNDg1NTFjMmE4ZDZhMjhjMzQ5YTU1MWZlZjkwNQ==", "commit": {"author": {"name": "Dimitar Dimitrov", "email": "dimitar@dinux.eu", "date": "2021-06-20T15:39:41Z"}, "committer": {"name": "Dimitar Dimitrov", "email": "dimitar@dinux.eu", "date": "2021-06-23T20:13:43Z"}, "message": "doc/lto.texi: List slim object format as the default\n\nSlim LTO object files have been the default for quite a while, since:\n  commit e9f67e625c2a4225a7169d7220dcb85b6fdd7ca9\n  Author:     Jan Hubicka <hubicka@gcc.gnu.org>\n  common.opt (ffat-lto-objects): Disable by default.\n\nThat commit did not update lto.texi, so do it now.\n\ngcc/ChangeLog:\n\n\t* doc/lto.texi (Design Overview): Update that slim objects are\n\tthe default.\n\nSigned-off-by: Dimitar Dimitrov <dimitar@dinux.eu>", "tree": {"sha": "fc9f0b9a0255b9803486f6bb6cf2c31f6ecf5aba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc9f0b9a0255b9803486f6bb6cf2c31f6ecf5aba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f72f71c52e0d48551c2a8d6a28c349a551fef905", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f72f71c52e0d48551c2a8d6a28c349a551fef905", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f72f71c52e0d48551c2a8d6a28c349a551fef905", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f72f71c52e0d48551c2a8d6a28c349a551fef905/comments", "author": null, "committer": null, "parents": [{"sha": "cac3527793b38164e2a83c7ccbfe0cfcf5ac95b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cac3527793b38164e2a83c7ccbfe0cfcf5ac95b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cac3527793b38164e2a83c7ccbfe0cfcf5ac95b8"}], "stats": {"total": 25, "additions": 12, "deletions": 13}, "files": [{"sha": "3c5de2144d0e1e8eeca841e5981d3eb1a5419860", "filename": "gcc/doc/lto.texi", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f71c52e0d48551c2a8d6a28c349a551fef905/gcc%2Fdoc%2Flto.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f71c52e0d48551c2a8d6a28c349a551fef905/gcc%2Fdoc%2Flto.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Flto.texi?ref=f72f71c52e0d48551c2a8d6a28c349a551fef905", "patch": "@@ -36,11 +36,18 @@ bytecode representation of GIMPLE that is emitted in special sections\n of @code{.o} files.  Currently, LTO support is enabled in most\n ELF-based systems, as well as darwin, cygwin and mingw systems.\n \n-Since GIMPLE bytecode is saved alongside final object code, object\n-files generated with LTO support are larger than regular object files.\n-This ``fat'' object format makes it easy to integrate LTO into\n-existing build systems, as one can, for instance, produce archives of\n-the files.  Additionally, one might be able to ship one set of fat\n+By default, object files generated with LTO support contain only GIMPLE\n+bytecode.  Such objects are called ``slim'', and they require that\n+tools like @code{ar} and @code{nm} understand symbol tables of LTO\n+sections.  For most targets these tools have been extended to use the\n+plugin infrastructure, so GCC can support ``slim'' objects consisting\n+of the intermediate code alone.\n+\n+GIMPLE bytecode could also be saved alongside final object code if\n+the @option{-ffat-lto-objects} option is passed, or if no plugin support\n+is detected for @code{ar} and @code{nm} when GCC is configured.  It makes\n+the object files generated with LTO support larger than regular object\n+files.  This ``fat'' object format allows to ship one set of fat\n objects which could be used both for development and the production of\n optimized builds.  A, perhaps surprising, side effect of this feature\n is that any mistake in the toolchain leads to LTO information not\n@@ -49,14 +56,6 @@ This is both an advantage, as the system is more robust, and a\n disadvantage, as the user is not informed that the optimization has\n been disabled.\n \n-The current implementation only produces ``fat'' objects, effectively\n-doubling compilation time and increasing file sizes up to 5x the\n-original size.  This hides the problem that some tools, such as\n-@code{ar} and @code{nm}, need to understand symbol tables of LTO\n-sections.  These tools were extended to use the plugin infrastructure,\n-and with these problems solved, GCC will also support ``slim'' objects\n-consisting of the intermediate code alone.\n-\n At the highest level, LTO splits the compiler in two.  The first half\n (the ``writer'') produces a streaming representation of all the\n internal data structures needed to optimize and generate code.  This"}]}