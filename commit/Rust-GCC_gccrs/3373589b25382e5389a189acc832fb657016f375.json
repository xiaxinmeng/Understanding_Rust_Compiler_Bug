{"sha": "3373589b25382e5389a189acc832fb657016f375", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM3MzU4OWIyNTM4MmU1Mzg5YTE4OWFjYzgzMmZiNjU3MDE2ZjM3NQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T13:37:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T13:37:54Z"}, "message": "[multiple changes]\n\n2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_res.adb (Resolve_Generalized_Indexing): In ASIS mode, when\n\trestoring original node, remove Generalized_Indexing operation\n\tso that it is recreated during re- analysis.\n\n2015-10-26  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_unst.adb: (Unnest_Subprogram):\n\tReplace absolute references to 1 and 0 by their counterpart\n\trelative references through Subps_First.\n\n2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* par-ch3.adb (P_Declarative_Items): In case of misplaced\n\taspect specifications, ensure that flag Done is properly set to\n\tcontinue parse.\n\t* sem_prag.adb, sem_prag.ads: Remove Build_Generic_Class_Condition,\n\tunused.\n\nFrom-SVN: r229362", "tree": {"sha": "9344bb0ac2f1f166554bbb48748b433385974349", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9344bb0ac2f1f166554bbb48748b433385974349"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3373589b25382e5389a189acc832fb657016f375", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3373589b25382e5389a189acc832fb657016f375", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3373589b25382e5389a189acc832fb657016f375", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3373589b25382e5389a189acc832fb657016f375/comments", "author": null, "committer": null, "parents": [{"sha": "64dfccae7b6b30498e1ce660941051bb4d3108bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64dfccae7b6b30498e1ce660941051bb4d3108bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64dfccae7b6b30498e1ce660941051bb4d3108bd"}], "stats": {"total": 299, "additions": 33, "deletions": 266}, "files": [{"sha": "4806519dd2b221402d78ec602383062ec37abc75", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3373589b25382e5389a189acc832fb657016f375/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3373589b25382e5389a189acc832fb657016f375/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3373589b25382e5389a189acc832fb657016f375", "patch": "@@ -1,3 +1,23 @@\n+2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Generalized_Indexing): In ASIS mode, when\n+\trestoring original node, remove Generalized_Indexing operation\n+\tso that it is recreated during re- analysis.\n+\n+2015-10-26  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_unst.adb: (Unnest_Subprogram):\n+\tReplace absolute references to 1 and 0 by their counterpart\n+\trelative references through Subps_First.\n+\n+2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* par-ch3.adb (P_Declarative_Items): In case of misplaced\n+\taspect specifications, ensure that flag Done is properly set to\n+\tcontinue parse.\n+\t* sem_prag.adb, sem_prag.ads: Remove Build_Generic_Class_Condition,\n+\tunused.\n+\n 2015-10-26  Emmanuel Briot  <briot@adacore.com>\n \n \t* s-os_lib.adb (Argument_String_To_List): Remove backslashes in"}, {"sha": "93fbf6cf5622948dbac1247589387b5750d40a61", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3373589b25382e5389a189acc832fb657016f375/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3373589b25382e5389a189acc832fb657016f375/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=3373589b25382e5389a189acc832fb657016f375", "patch": "@@ -275,9 +275,9 @@ package body Exp_Unst is\n \n       --  First step, we must mark all nested subprograms that require a static\n       --  link (activation record) because either they contain explicit uplevel\n-      --  references (as indicated by ??? being set at this\n-      --  point), or they make calls to other subprograms in the same nest that\n-      --  require a static link (in which case we set this flag).\n+      --  references (as indicated by Is_Uplevel_Referenced_Entity being set at\n+      --  this point), or they make calls to other subprograms in the same nest\n+      --  that require a static link (in which case we set this flag).\n \n       --  This is a recursive definition, and to implement this, we have to\n       --  build a call graph for the set of nested subprograms, and then go\n@@ -684,7 +684,7 @@ package body Exp_Unst is\n          Modified : Boolean;\n \n       begin\n-         Subps.Table (1).Reachable := True;\n+         Subps.Table (Subps_First).Reachable := True;\n \n          --  We use a simple minded algorithm as follows (obviously this can\n          --  be done more efficiently, using one of the standard algorithms\n@@ -822,13 +822,13 @@ package body Exp_Unst is\n \n       --  Remove unreachable subprograms from Subps table. Note that we do\n       --  this after eliminating entries from the other two tables, since\n-      --  thos elimination steps depend on referencing the Subps table.\n+      --  those elimination steps depend on referencing the Subps table.\n \n       declare\n          New_SI : SI_Type;\n \n       begin\n-         New_SI := 0;\n+         New_SI := Subps_First - 1;\n          for J in Subps_First .. Subps.Last loop\n             declare\n                STJ  : Subp_Entry renames Subps.Table (J);"}, {"sha": "5859bcea05b8ffae1d9a17f2bbf171a4dfb66d3b", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3373589b25382e5389a189acc832fb657016f375/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3373589b25382e5389a189acc832fb657016f375/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=3373589b25382e5389a189acc832fb657016f375", "patch": "@@ -4560,6 +4560,11 @@ package body Ch3 is\n                Scan; -- past RECORD\n                TF_Semicolon;\n \n+               --  This might happen because of misplaced aspect specification.\n+               --  After discarding the misplaced aspects we can continue the\n+               --  scan.\n+\n+               Done := False;\n             else\n                Restore_Scan_State (Scan_State); -- to END\n                Done := True;"}, {"sha": "912d75ecaf7a021449d3c47ad85b6159f6b79f32", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 0, "deletions": 249, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3373589b25382e5389a189acc832fb657016f375/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3373589b25382e5389a189acc832fb657016f375/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=3373589b25382e5389a189acc832fb657016f375", "patch": "@@ -22932,10 +22932,6 @@ package body Sem_Prag is\n          end if;\n       end if;\n \n-      if Class_Present (N) then\n-         Build_Generic_Class_Condition (Spec_Id, N);\n-      end if;\n-\n       Preanalyze_Assert_Expression (Expr, Standard_Boolean);\n \n       --  For a class-wide condition, a reference to a controlling formal must\n@@ -25727,251 +25723,6 @@ package body Sem_Prag is\n       return False;\n    end Appears_In;\n \n-   -----------------------------------\n-   -- Build_Generic_Class_Condition --\n-   -----------------------------------\n-\n-   procedure Build_Generic_Class_Condition\n-     (Subp : Entity_Id;\n-      Prag : Node_Id)\n-   is\n-      Expr     : constant Node_Id :=\n-                   Get_Pragma_Arg\n-                     (First (Pragma_Argument_Associations (Prag)));\n-      Loc      : constant Source_Ptr := Sloc (Prag);\n-      Map      : constant Elist_Id   := New_Elmt_List;\n-      New_Expr : constant Node_Id    := New_Copy_Tree (Expr);\n-      New_Pred : constant Entity_Id  :=\n-                   Make_Defining_Identifier (Loc,\n-                     New_External_Name (Chars (Subp), \"Pre\", -1));\n-      Typ      : constant Entity_Id  := Find_Dispatching_Type (Subp);\n-\n-      function Replace_Formal (N : Node_Id) return Traverse_Result;\n-      --  Replace occurrence of a formal parameter of the original expression\n-      --  in the precondition, with the formal of the generic function created\n-      --  for it.\n-\n-      --------------------\n-      -- Replace_Formal --\n-      --------------------\n-\n-      function Replace_Formal (N : Node_Id) return Traverse_Result is\n-         Loc   : constant Source_Ptr := Sloc (N);\n-         El    : Elmt_Id;\n-         F     : Entity_Id;\n-         New_F : Entity_Id;\n-\n-      begin\n-         if Nkind (N) = N_Identifier\n-           and then (Nkind (Parent (N)) /= N_Parameter_Association\n-             or else N /= Selector_Name (Parent (N)))\n-           and then Present (Entity (N))\n-           and then Is_Formal (Entity (N))\n-         then\n-            El := First_Elmt (Map);\n-            while Present (El) loop\n-               F := Node (El);\n-               if Chars (F) = Chars (N) then\n-                  New_F := Node (Next_Elmt (El));\n-\n-                  --  If this is a controlling formal, in the generic it\n-                  --  becomes a conversion to the controlling formal of the\n-                  --  operation with the class-wide precondition. If the formal\n-                  --  is an access parameter, a reference to F becomes\n-                  --  Root (New_F.all)'access.\n-\n-                  if Is_Controlling_Formal (F) then\n-                     if Is_Access_Type (Etype (F)) then\n-                        Rewrite (N,\n-                          Make_Attribute_Reference (Loc,\n-                            Prefix         =>\n-                              Unchecked_Convert_To (\n-                                Designated_Type (Etype (F)),\n-                                  Make_Explicit_Dereference (Loc,\n-                                    Prefix => New_Occurrence_Of (New_F, Loc))),\n-                            Attribute_Name => Name_Access));\n-\n-                     else\n-                        Rewrite (N,\n-                          Unchecked_Convert_To\n-                            (Etype (F), New_Occurrence_Of (New_F, Sloc (N))));\n-                     end if;\n-\n-                  --  Noncontrolling formals retain their original type\n-\n-                  else\n-                     Rewrite (N, New_Occurrence_Of (New_F, Sloc (N)));\n-                  end if;\n-\n-                  return OK;\n-               end if;\n-\n-               Next_Elmt (El);\n-               Next_Elmt (El);\n-            end loop;\n-\n-         elsif Nkind (N) = N_Parameter_Association then\n-            Set_Next_Named_Actual (N, Empty);\n-\n-         elsif Nkind (N) = N_Function_Call then\n-            Set_First_Named_Actual (N, Empty);\n-         end if;\n-\n-         return OK;\n-      end Replace_Formal;\n-\n-      procedure Map_Formals is new Traverse_Proc (Replace_Formal);\n-\n-      --  Local variables\n-\n-      Bod      : Node_Id;\n-      Decl     : Node_Id;\n-      F        : Entity_Id;\n-      New_F    : Entity_Id;\n-      New_Form : List_Id;\n-      New_Typ  : Entity_Id;\n-      Par_Typ  : Entity_Id;\n-      Root_Typ : Entity_Id;\n-      Spec     : Node_Id;\n-\n-   --  Start of processing for Build_Generic_Class_Pre\n-\n-   begin\n-      --  Nothing to do if previous error or expansion disabled.\n-\n-      if not Expander_Active then\n-         return;\n-      end if;\n-\n-      if Chars (Pragma_Identifier (Prag)) = Name_Postcondition then\n-         return;\n-      end if;\n-\n-      --  Build list of controlling formals and their renamings in the new\n-      --  generic operation.\n-\n-      New_Form := New_List;\n-      New_Typ  := Empty;\n-\n-      F := First_Formal (Subp);\n-      while Present (F) loop\n-         New_F :=\n-           Make_Defining_Identifier (Loc, New_External_Name (Chars (F), \"GF\"));\n-         Set_Ekind (New_F, Ekind (F));\n-         Append_Elmt (F, Map);\n-         Append_Elmt (New_F, Map);\n-\n-         if Is_Controlling_Formal (F) then\n-            Root_Typ := Etype (F);\n-\n-            if Is_Access_Type (Etype (F)) then\n-               Root_Typ := Designated_Type (Root_Typ);\n-               New_Typ :=\n-                 Make_Defining_Identifier (Loc,\n-                   Chars =>\n-                     New_External_Name\n-                       (Chars (Designated_Type (Etype (F))), \"GT\"));\n-               Par_Typ :=\n-                 Make_Access_Definition (Loc,\n-                   Subtype_Mark => New_Occurrence_Of (New_Typ, Loc));\n-            else\n-               New_Typ :=\n-                 Make_Defining_Identifier (Loc,\n-                   Chars => New_External_Name (Chars (Etype (F)), \"GT\"));\n-               Par_Typ := New_Occurrence_Of (New_Typ, Loc);\n-            end if;\n-\n-            Append_To (New_Form,\n-              Make_Parameter_Specification (Loc,\n-                Defining_Identifier => New_F,\n-                Parameter_Type      => Par_Typ));\n-         else\n-            --  If formal has a class-wide type, build same attribute for new\n-            --  formal.\n-\n-            if Is_Class_Wide_Type (Etype (F)) then\n-               Append_To (New_Form,\n-                 Make_Parameter_Specification (Loc,\n-                   Defining_Identifier => New_F,\n-                   Parameter_Type      =>\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix         =>\n-                         New_Occurrence_Of (Etype (Etype (F)), Loc),\n-                       Attribute_Name => Name_Class)));\n-            else\n-               --  If it is an anonymous access type, create a similar type\n-               --  definition.\n-\n-               if Ekind (Etype (F)) = E_Anonymous_Access_Type then\n-                  Par_Typ := New_Copy_Tree (Parameter_Type (Parent (F)));\n-               else\n-                  Par_Typ := New_Occurrence_Of (Etype (F), Loc);\n-               end if;\n-\n-               Append_To (New_Form,\n-                 Make_Parameter_Specification (Loc,\n-                   Defining_Identifier => New_F,\n-                   Parameter_Type      => Par_Typ));\n-            end if;\n-         end if;\n-\n-         Next_Formal (F);\n-      end loop;\n-\n-      --  If no controlling formal found, pre/postcondition is incorrect.\n-\n-      if No (New_Typ) then\n-         return;\n-      end if;\n-\n-      Spec :=\n-        Make_Function_Specification (Loc,\n-          Defining_Unit_Name       => New_Pred,\n-          Parameter_Specifications => New_Form,\n-          Result_Definition        =>\n-            New_Occurrence_Of (Standard_Boolean, Loc));\n-\n-      Decl :=\n-        Make_Generic_Subprogram_Declaration (Loc,\n-          Specification               => Spec,\n-          Generic_Formal_Declarations => New_List (\n-            Make_Formal_Type_Declaration (Loc,\n-              Defining_Identifier    => New_Typ,\n-              Formal_Type_Definition =>\n-                Make_Formal_Derived_Type_Definition (Loc,\n-                  Subtype_Mark    => New_Occurrence_Of (Root_Typ, Loc),\n-                  Private_Present => True))));\n-\n-      Preanalyze (New_Expr);\n-      Map_Formals (New_Expr);\n-\n-      Bod :=\n-        Make_Subprogram_Body (Loc,\n-          Specification              => New_Copy_Tree (Spec),\n-          Declarations               => New_List,\n-          Handled_Statement_Sequence =>\n-            Make_Handled_Sequence_Of_Statements (Loc,\n-              Statements => New_List (\n-                Make_Simple_Return_Statement (Loc,\n-                  Expression => New_Expr))));\n-\n-      --  Generic function must be analyzed after type is frozen, and will be\n-      --  instantiated when subprogram contract for operation or any of its\n-      --  overridings is expanded.\n-\n-      Append_Freeze_Actions (Typ, New_List (Decl, Bod));\n-\n-      --  We need to convey the existence of the generic to the point at which\n-      --  we expand the contract. We replace the expression in the pragma with\n-      --  name of the generic function, to be instantiated when expanding the\n-      --  contract for the subprogram or some overriding of it. See\n-      --  Exp_ch6.Expand_Subprogram_Contract.Build_Pragma_Check_Equivalent.\n-      --  (TBD)\n-\n-      Set_Ekind (New_Pred, E_Generic_Function);\n-      Set_Scope (New_Pred, Current_Scope);\n-   end Build_Generic_Class_Condition;\n-\n    -----------------------------\n    -- Check_Applicable_Policy --\n    -----------------------------"}, {"sha": "784578a4da0e642ac27a84d062bc35fb8853e8cc", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3373589b25382e5389a189acc832fb657016f375/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3373589b25382e5389a189acc832fb657016f375/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=3373589b25382e5389a189acc832fb657016f375", "patch": "@@ -231,17 +231,6 @@ package Sem_Prag is\n    procedure Analyze_Test_Case_In_Decl_Part (N : Node_Id);\n    --  Perform preanalysis of pragma Test_Case\n \n-   procedure Build_Generic_Class_Condition\n-     (Subp : Entity_Id;\n-      Prag : Node_Id);\n-   --  AI12-113 modifies the semantics of classwide pre- and postconditions,\n-   --  as well as type invariants, so that the expression used in an inherited\n-   --  operation uses the actual type and is statically bound, rather than\n-   --  using T'Class and dispatching. This new semantics is implemented by\n-   --  building a generic function for the corresponding condition and\n-   --  instantiating it for each descendant type. Checking the condition is\n-   --  implemented as a call to that instantiation.\n-\n    procedure Check_Applicable_Policy (N : Node_Id);\n    --  N is either an N_Aspect or an N_Pragma node. There are two cases. If\n    --  the name of the aspect or pragma is not one of those recognized as"}, {"sha": "d2963f73e7cf6edc223b1dc25e2f9ebffc8cee8e", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3373589b25382e5389a189acc832fb657016f375/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3373589b25382e5389a189acc832fb657016f375/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=3373589b25382e5389a189acc832fb657016f375", "patch": "@@ -8110,6 +8110,7 @@ package body Sem_Res is\n       end if;\n \n       Analyze_Dimension (N);\n+\n       --  Note: No Eval processing is required for an explicit dereference,\n       --  because such a name can never be static.\n \n@@ -8166,6 +8167,7 @@ package body Sem_Res is\n             Indexes := Parameter_Associations (Call);\n             Pref := Remove_Head (Indexes);\n             Set_Expressions (N, Indexes);\n+            Set_Generalized_Indexing (N, Empty);\n             Set_Prefix (N, Pref);\n          end if;\n "}]}