{"sha": "a81072c78284d233c2ca7582235d0e01eda83082", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTgxMDcyYzc4Mjg0ZDIzM2MyY2E3NTgyMjM1ZDBlMDFlZGE4MzA4Mg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2015-10-21T02:24:08Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2015-10-21T02:24:08Z"}, "message": "re PR c++/66583 (incorrect implicitly-defined move constructor for class with anonymous union and NSDMI)\n\n\tPR c++/66583\n\n\t* init.c (innermost_aggr_scope): New.\n\t(build_field_list): Change uses_unions_p to uses_unions_or_anon_p.\n\t(sort_mem_initializers): Handle initializers for entire anonymous\n\taggregates.\n\nFrom-SVN: r229108", "tree": {"sha": "e72867ff2c9fdb8412f2bb8ee008bc3e5e120fc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e72867ff2c9fdb8412f2bb8ee008bc3e5e120fc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a81072c78284d233c2ca7582235d0e01eda83082", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a81072c78284d233c2ca7582235d0e01eda83082", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a81072c78284d233c2ca7582235d0e01eda83082", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a81072c78284d233c2ca7582235d0e01eda83082/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0a8f32b8fc399b3fc2da1449d92de22da83d3853", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a8f32b8fc399b3fc2da1449d92de22da83d3853", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a8f32b8fc399b3fc2da1449d92de22da83d3853"}], "stats": {"total": 118, "additions": 95, "deletions": 23}, "files": [{"sha": "9f282d8352ecd85ea91f944b229031877117eb71", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a81072c78284d233c2ca7582235d0e01eda83082/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a81072c78284d233c2ca7582235d0e01eda83082/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a81072c78284d233c2ca7582235d0e01eda83082", "patch": "@@ -1,3 +1,11 @@\n+2015-10-20  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/66583\n+\t* init.c (innermost_aggr_scope): New.\n+\t(build_field_list): Change uses_unions_p to uses_unions_or_anon_p.\n+\t(sort_mem_initializers): Handle initializers for entire anonymous\n+\taggregates.\n+\n 2015-10-20  Marek Polacek  <polacek@redhat.com>\n \n \t* parser.c (is_cilkplus_vector_p): Don't define here."}, {"sha": "d89e1ac0b5a58c1a4e2713ddaa2a24fb7938ab55", "filename": "gcc/cp/init.c", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a81072c78284d233c2ca7582235d0e01eda83082/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a81072c78284d233c2ca7582235d0e01eda83082/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a81072c78284d233c2ca7582235d0e01eda83082", "patch": "@@ -823,13 +823,13 @@ perform_member_init (tree member, tree init)\n    the FIELD_DECLs on the TYPE_FIELDS list for T, in reverse order.  */\n \n static tree\n-build_field_list (tree t, tree list, int *uses_unions_p)\n+build_field_list (tree t, tree list, int *uses_unions_or_anon_p)\n {\n   tree fields;\n \n   /* Note whether or not T is a union.  */\n   if (TREE_CODE (t) == UNION_TYPE)\n-    *uses_unions_p = 1;\n+    *uses_unions_or_anon_p = 1;\n \n   for (fields = TYPE_FIELDS (t); fields; fields = DECL_CHAIN (fields))\n     {\n@@ -840,9 +840,6 @@ build_field_list (tree t, tree list, int *uses_unions_p)\n \tcontinue;\n \n       fieldtype = TREE_TYPE (fields);\n-      /* Keep track of whether or not any fields are unions.  */\n-      if (TREE_CODE (fieldtype) == UNION_TYPE)\n-\t*uses_unions_p = 1;\n \n       /* For an anonymous struct or union, we must recursively\n \t consider the fields of the anonymous type.  They can be\n@@ -853,7 +850,8 @@ build_field_list (tree t, tree list, int *uses_unions_p)\n \t     initialize the entire aggregate.  */\n \t  list = tree_cons (fields, NULL_TREE, list);\n \t  /* And now add the fields in the anonymous aggregate.  */\n-\t  list = build_field_list (fieldtype, list, uses_unions_p);\n+\t  list = build_field_list (fieldtype, list, uses_unions_or_anon_p);\n+\t  *uses_unions_or_anon_p = 1;\n \t}\n       /* Add this field.  */\n       else if (DECL_NAME (fields))\n@@ -863,6 +861,18 @@ build_field_list (tree t, tree list, int *uses_unions_p)\n   return list;\n }\n \n+/* Return the innermost aggregate scope for FIELD, whether that is\n+   the enclosing class or an anonymous aggregate within it.  */\n+\n+static tree\n+innermost_aggr_scope (tree field)\n+{\n+  if (ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n+    return TREE_TYPE (field);\n+  else\n+    return DECL_CONTEXT (field);\n+}\n+\n /* The MEM_INITS are a TREE_LIST.  The TREE_PURPOSE of each list gives\n    a FIELD_DECL or BINFO in T that needs initialization.  The\n    TREE_VALUE gives the initializer, or list of initializer arguments.\n@@ -880,7 +890,7 @@ sort_mem_initializers (tree t, tree mem_inits)\n   tree next_subobject;\n   vec<tree, va_gc> *vbases;\n   int i;\n-  int uses_unions_p = 0;\n+  int uses_unions_or_anon_p = 0;\n \n   /* Build up a list of initializations.  The TREE_PURPOSE of entry\n      will be the subobject (a FIELD_DECL or BINFO) to initialize.  The\n@@ -900,7 +910,7 @@ sort_mem_initializers (tree t, tree mem_inits)\n       sorted_inits = tree_cons (base_binfo, NULL_TREE, sorted_inits);\n \n   /* Process the non-static data members.  */\n-  sorted_inits = build_field_list (t, sorted_inits, &uses_unions_p);\n+  sorted_inits = build_field_list (t, sorted_inits, &uses_unions_or_anon_p);\n   /* Reverse the entire list of initializations, so that they are in\n      the order that they will actually be performed.  */\n   sorted_inits = nreverse (sorted_inits);\n@@ -984,7 +994,7 @@ sort_mem_initializers (tree t, tree mem_inits)\n      anonymous unions), the ctor-initializer is ill-formed.\n \n      Here we also splice out uninitialized union members.  */\n-  if (uses_unions_p)\n+  if (uses_unions_or_anon_p)\n     {\n       tree *last_p = NULL;\n       tree *p;\n@@ -1001,21 +1011,18 @@ sort_mem_initializers (tree t, tree mem_inits)\n \t  if (TREE_CODE (field) != FIELD_DECL)\n \t    goto next;\n \n-\t  /* If this is an anonymous union with no explicit initializer,\n+\t  /* If this is an anonymous aggregate with no explicit initializer,\n \t     splice it out.  */\n-\t  if (!TREE_VALUE (init) && ANON_UNION_TYPE_P (TREE_TYPE (field)))\n+\t  if (!TREE_VALUE (init) && ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n \t    goto splice;\n \n \t  /* See if this field is a member of a union, or a member of a\n \t     structure contained in a union, etc.  */\n-\t  for (ctx = DECL_CONTEXT (field);\n-\t       !same_type_p (ctx, t);\n-\t       ctx = TYPE_CONTEXT (ctx))\n-\t    if (TREE_CODE (ctx) == UNION_TYPE\n-\t\t|| !ANON_AGGR_TYPE_P (ctx))\n-\t      break;\n+\t  ctx = innermost_aggr_scope (field);\n+\n \t  /* If this field is not a member of a union, skip it.  */\n-\t  if (TREE_CODE (ctx) != UNION_TYPE)\n+\t  if (TREE_CODE (ctx) != UNION_TYPE\n+\t      && !ANON_AGGR_TYPE_P (ctx))\n \t    goto next;\n \n \t  /* If this union member has no explicit initializer and no NSDMI,\n@@ -1034,17 +1041,19 @@ sort_mem_initializers (tree t, tree mem_inits)\n \t    }\n \n \t  /* See if LAST_FIELD and the field initialized by INIT are\n-\t     members of the same union.  If so, there's a problem,\n-\t     unless they're actually members of the same structure\n+\t     members of the same union (or the union itself). If so, there's\n+\t     a problem, unless they're actually members of the same structure\n \t     which is itself a member of a union.  For example, given:\n \n \t       union { struct { int i; int j; }; };\n \n \t     initializing both `i' and `j' makes sense.  */\n-\t  ctx = common_enclosing_class (DECL_CONTEXT (field),\n-\t\t\t\t\tDECL_CONTEXT (TREE_PURPOSE (*last_p)));\n+\t  ctx = common_enclosing_class\n+\t    (innermost_aggr_scope (field),\n+\t     innermost_aggr_scope (TREE_PURPOSE (*last_p)));\n \n-\t  if (ctx && TREE_CODE (ctx) == UNION_TYPE)\n+\t  if (ctx && (TREE_CODE (ctx) == UNION_TYPE\n+\t\t      || ctx == TREE_TYPE (TREE_PURPOSE (*last_p))))\n \t    {\n \t      /* A mem-initializer hides an NSDMI.  */\n \t      if (TREE_VALUE (init) && !TREE_VALUE (*last_p))"}, {"sha": "19f6291211c48cc6faa96dfa96c584d22004b540", "filename": "gcc/testsuite/g++.dg/cpp0x/anon-union1.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a81072c78284d233c2ca7582235d0e01eda83082/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fanon-union1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a81072c78284d233c2ca7582235d0e01eda83082/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fanon-union1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fanon-union1.C?ref=a81072c78284d233c2ca7582235d0e01eda83082", "patch": "@@ -0,0 +1,27 @@\n+// PR c++/66583\n+// { dg-do run { target c++11 } }\n+\n+template <class T>\n+T&& move(T& t) { return static_cast<T&&>(t); }\n+\n+struct A {\n+  A() { };\n+  A(const A&) { }\n+};\n+\n+struct B {\n+  union {\n+    int m_1 = 0;\n+    int m_2;\n+  };\n+  A dummy;\n+};\n+\n+int main()\n+{\n+  B b;\n+  b.m_1 = 1;\n+  B c = move(b);\n+  if (c.m_1 != 1)\n+    __builtin_abort();\n+}"}, {"sha": "6e47e34c7d4ee3b8ba6bb93870bb486e9d524585", "filename": "gcc/testsuite/g++.dg/ext/anon-struct7.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a81072c78284d233c2ca7582235d0e01eda83082/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fanon-struct7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a81072c78284d233c2ca7582235d0e01eda83082/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fanon-struct7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fanon-struct7.C?ref=a81072c78284d233c2ca7582235d0e01eda83082", "patch": "@@ -0,0 +1,28 @@\n+// PR c++/66583\n+// { dg-do run { target c++11 } }\n+// { dg-options \"\" }\n+\n+template <class T>\n+T&& move(T& t) { return static_cast<T&&>(t); }\n+\n+struct A {\n+  A() { };\n+  A(const A&) { }\n+};\n+\n+struct B {\n+  struct {\n+    int m_1 = 0;\n+    int m_2;\n+  };\n+  A dummy;\n+};\n+\n+int main()\n+{\n+  B b;\n+  b.m_1 = 1;\n+  B c = move(b);\n+  if (c.m_1 != 1)\n+    __builtin_abort();\n+}"}]}