{"sha": "ae180d84fc7bb97b09fb67a1e478288d748e41fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWUxODBkODRmYzdiYjk3YjA5ZmI2N2ExZTQ3ODI4OGQ3NDhlNDFmYg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-09-05T17:41:24Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-09-05T17:41:24Z"}, "message": "v850: New directory for v850 port.\n\nFri Sep  5 10:08:44 1997  Jeffrey A Law  (law@cygnus.com)\n\n        * v850: New directory for v850 port.\n        * v850/lib1funcs.asm: New file.\n        * t-v850, v850.c, v850.h, v850.md, xm-v850.h: New files.\n        * ginclude/va-v850.h: New file.\n        * varargs.h, stdarg.h: Include va-mn10200.h.\n        * configure.in (mn10200-*-*): New target.\n        * Makefile.in (USER_H): Add va-mn10200.h.\n\nFrom-SVN: r15103", "tree": {"sha": "a46d3dd141bcd31d33f4ff1c5bbe8c1713f4ac8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a46d3dd141bcd31d33f4ff1c5bbe8c1713f4ac8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae180d84fc7bb97b09fb67a1e478288d748e41fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae180d84fc7bb97b09fb67a1e478288d748e41fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae180d84fc7bb97b09fb67a1e478288d748e41fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae180d84fc7bb97b09fb67a1e478288d748e41fb/comments", "author": null, "committer": null, "parents": [{"sha": "89cc6098e680140f7b56f639d20be360c23d23ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89cc6098e680140f7b56f639d20be360c23d23ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89cc6098e680140f7b56f639d20be360c23d23ba"}], "stats": {"total": 6576, "additions": 6576, "deletions": 0}, "files": [{"sha": "d441590678fbe84951f5f9e12eeda9c8a0628e57", "filename": "gcc/config/v850/lib1funcs.asm", "status": "added", "additions": 1271, "deletions": 0, "changes": 1271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae180d84fc7bb97b09fb67a1e478288d748e41fb/gcc%2Fconfig%2Fv850%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae180d84fc7bb97b09fb67a1e478288d748e41fb/gcc%2Fconfig%2Fv850%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Flib1funcs.asm?ref=ae180d84fc7bb97b09fb67a1e478288d748e41fb", "patch": "@@ -0,0 +1,1271 @@\n+/* CYGNUS LOCAL entire file v850/law */\n+/* libgcc1 routines for NEC V850.\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file with other programs, and to distribute\n+those programs without any restriction coming from the use of this\n+file.  (The General Public License restrictions do apply in other\n+respects; for example, they cover modification of the file, and\n+distribution when not linked into another program.)\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#ifdef L_mulsi3\n+\t.text\n+\t.globl ___mulsi3\n+\t.type  ___mulsi3,@function\n+\n+/*\n+ * In order to not deal with negative numbers (mulh is a signed multiply\n+ * and we want an unsigned multiply, code the multiplication as a series\n+ * of 7 bit multiplies).\n+ *\n+ * int __mulsi3 (unsigned a, unsigned b)\n+ * {\n+ *   int i, j;\n+ *   int ret = 0;\n+ *\n+ *   for (i = 0; i < 32; i += 7)\n+ *     {\n+ *       short a_part = a & 0x7f;\n+ *       unsigned b_tmp = b;\n+ *       a >>= 7;\n+ * \n+ *       for (j = 0; (i+j) < 32; j += 7)\n+ * \t{\n+ * \t  short b_part = b_tmp & 0x7f;\n+ * \t  ret += (((int)a_part) * ((int)b_part)) << (i+j);\n+ * \t  b_tmp >>= 7;\n+ * \t}\n+ *    }\n+ *\n+ *   return ret;\n+ * }\n+ */\n+\n+___mulsi3:\n+\tmov 0,r10\t\t\t/* total */\n+\tmov 0,r14\t\t\t/* i = 0, index for multiply a's part */\n+\tmovea lo(31),r0,r16\t\t/* upper bounds for loop */\n+.L5:\n+\tmov r7,r13\t\t\t/* b_tmp = b */\n+\tandi 0x7f,r6,r15\t\t/* a_part = (a & 127) */\n+\tshr 7,r6\t\t\t/* a >>= 7 */\n+\tmov r14,r12\t\t\t/* i+j = i */\n+.L9:\n+\tandi 0x7f,r13,r11\t\t/* b_part = (b_tmp & 127) */\n+\tmulh r15,r11\t\t\t/* ((int)a_part) * ((int)b_part) */\n+\tshr 7,r13\t\t\t/* b_tmp >>= 7 */\n+\tshl r12,r11\t\t\t/* (((int)a_part) * ((int)b_part)) << (i+j) */\n+\tadd r11,r10\t\t\t/* ret += (((int)a_part) * ((int)b_part)) << (i+j) */\n+\tadd 7,r12\t\t\t/* i+j += 7 */\n+\tcmp r16,r12\t\t\t/* i+j < 32 */\n+\tble .L9\n+\n+\tadd 7,r14\t\t\t/* i += 7 */\n+\tcmp r16,r14\t\t\t/* i < 32 */\n+\tble .L5\n+\n+\tjmp [r31]\t\t\t/* return */\n+\t.size __mulsi3,.-__mulsi3\n+#endif\n+\n+#ifdef L_udivsi3\n+\t.global ___udivsi3\n+___udivsi3:\n+\tmov 1,r12\n+\tmov 0,r10\n+\tcmp r6,r7\n+\tbnl .L12\n+\tmovhi hi(-2147483648),r0,r13\n+\tcmp r0,r7\n+\tblt .L12\n+.L4:\n+\tshl 1,r7\n+\tshl 1,r12\n+\tcmp r6,r7\n+\tbnl .L12\n+\tcmp r0,r12\n+\tbe .L8\n+\tmov r7,r5\n+\tand r13,r5\n+\tbe .L4\n+\tbr .L12\n+.L9:\n+\tcmp r7,r6\n+\tbl .L10\n+\tsub r7,r6\n+\tor r12,r10\n+.L10:\n+\tshr 1,r12\n+\tshr 1,r7\n+.L12:\n+\tcmp r0,r12\n+\tbne .L9\n+.L8:\n+\tjmp [r31]\n+\t.size __udivsi3,.-__udivsi3\n+#endif\n+\n+#ifdef L_divsi3\n+\t.text\n+\t.globl ___divsi3\n+\t.type  ___divsi3,@function\n+___divsi3:\n+\tadd -8,sp\n+\tst.w r31,4[sp]\n+\tst.w r22,0[sp]\n+\tmov 1,r22\n+\ttst r7,r7\n+\tbp .L3\n+\tsubr r0,r7\n+\tsubr r0,r22\n+.L3:\n+\ttst r6,r6\n+\tbp .L4\n+\tsubr r0,r6\n+\tsubr r0,r22\n+.L4:\n+\tjarl ___udivsi3,r31\n+\tcmp r0,r22\n+\tbp .L7\n+\tsubr r0,r10\n+.L7:\n+\tld.w 0[sp],r22\n+\tld.w 4[sp],r31\n+\tadd 8,sp\n+\tjmp [r31]\n+\t.size __divsi3,.-__divsi3\n+#endif\n+\n+#ifdef  L_umodsi3\n+\t.text\n+\t.globl ___umodsi3\n+\t.type  ___umodsi3,@function\n+___umodsi3:\n+\tadd -12,sp\n+\tst.w r31,8[sp]\n+\tst.w r7,4[sp]\n+\tst.w r6,0[sp]\n+\tjarl ___udivsi3,r31\n+\tld.w 4[sp],r7\n+\tmov r10,r6\n+\tjarl ___mulsi3,r31\n+\tld.w 0[sp],r6\n+\tsubr r6,r10\n+\tld.w 8[sp],r31\n+\tadd 12,sp\n+\tjmp [r31]\n+\t.size __umodsi3,.-__umodsi3\n+#endif /* L_umodsi3 */\n+\n+#ifdef  L_modsi3\n+\t.text\n+\t.globl ___modsi3\n+\t.type  ___modsi3,@function\n+___modsi3:\n+\tadd -12,sp\n+\tst.w r31,8[sp]\n+\tst.w r7,4[sp]\n+\tst.w r6,0[sp]\n+\tjarl ___divsi3,r31\n+\tld.w 4[sp],r7\n+\tmov r10,r6\n+\tjarl ___mulsi3,r31\n+\tld.w 0[sp],r6\n+\tsubr r6,r10\n+\tld.w 8[sp],r31\n+\tadd 12,sp\n+\tjmp [r31]\n+\t.size __modsi3,.-__modsi3\n+#endif /* L_modsi3 */\n+\n+#ifdef\tL_save_2\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r2_r29\n+\t.type\t__save_r2_r29,@function\n+\t/* Allocate space and save registers 2, 20 .. 29 on the stack */\n+\t/* Called via:\tjalr __save_r2_r29,r10 */\n+__save_r2_r29:\n+\tmov\tep,r1\n+\taddi\t-44,sp,sp\n+\tmov\tsp,ep\n+\tsst.w\tr29,0[ep]\n+\tsst.w\tr28,4[ep]\n+\tsst.w\tr27,8[ep]\n+\tsst.w\tr26,12[ep]\n+\tsst.w\tr25,16[ep]\n+\tsst.w\tr24,20[ep]\n+\tsst.w\tr23,24[ep]\n+\tsst.w\tr22,28[ep]\n+\tsst.w\tr21,32[ep]\n+\tsst.w\tr20,36[ep]\n+\tsst.w\tr2,40[ep]\n+\tmov\tr1,ep\n+\tjmp\t[r10]\n+\t.size\t__save_r2_r29,.-__save_r2_r29\n+\n+\t/* Restore saved registers, deallocate stack and return to the user */\n+\t/* Called via:\tjr __return_r2_r29 */\n+\t.align\t2\n+\t.globl\t__return_r2_r29\n+\t.type\t__return_r2_r29,@function\n+__return_r2_r29:\n+\tmov\tep,r1\n+\tmov\tsp,ep\n+\tsld.w\t0[ep],r29\n+\tsld.w\t4[ep],r28\n+\tsld.w\t8[ep],r27\n+\tsld.w\t12[ep],r26\n+\tsld.w\t16[ep],r25\n+\tsld.w\t20[ep],r24\n+\tsld.w\t24[ep],r23\n+\tsld.w\t28[ep],r22\n+\tsld.w\t32[ep],r21\n+\tsld.w\t36[ep],r20\n+\tsld.w\t40[ep],r2\n+\taddi\t44,sp,sp\n+\tmov\tr1,ep\n+\tjmp\t[r31]\n+\t.size\t__return_r2_r29,.-__return_r2_r29\n+#endif /* L_save_2 */\n+\n+#ifdef\tL_save_20\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r20_r29\n+\t.type\t__save_r20_r29,@function\n+\t/* Allocate space and save registers 20 .. 29 on the stack */\n+\t/* Called via:\tjalr __save_r20_r29,r10 */\n+__save_r20_r29:\n+\tmov\tep,r1\n+\taddi\t-40,sp,sp\n+\tmov\tsp,ep\n+\tsst.w\tr29,0[ep]\n+\tsst.w\tr28,4[ep]\n+\tsst.w\tr27,8[ep]\n+\tsst.w\tr26,12[ep]\n+\tsst.w\tr25,16[ep]\n+\tsst.w\tr24,20[ep]\n+\tsst.w\tr23,24[ep]\n+\tsst.w\tr22,28[ep]\n+\tsst.w\tr21,32[ep]\n+\tsst.w\tr20,36[ep]\n+\tmov\tr1,ep\n+\tjmp\t[r10]\n+\t.size\t__save_r20_r29,.-__save_r20_r29\n+\n+\t/* Restore saved registers, deallocate stack and return to the user */\n+\t/* Called via:\tjr __return_r20_r29 */\n+\t.align\t2\n+\t.globl\t__return_r20_r29\n+\t.type\t__return_r20_r29,@function\n+__return_r20_r29:\n+\tmov\tep,r1\n+\tmov\tsp,ep\n+\tsld.w\t0[ep],r29\n+\tsld.w\t4[ep],r28\n+\tsld.w\t8[ep],r27\n+\tsld.w\t12[ep],r26\n+\tsld.w\t16[ep],r25\n+\tsld.w\t20[ep],r24\n+\tsld.w\t24[ep],r23\n+\tsld.w\t28[ep],r22\n+\tsld.w\t32[ep],r21\n+\tsld.w\t36[ep],r20\n+\taddi\t40,sp,sp\n+\tmov\tr1,ep\n+\tjmp\t[r31]\n+\t.size\t__return_r20_r29,.-__return_r20_r29\n+#endif /* L_save_20 */\n+\n+#ifdef\tL_save_21\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r21_r29\n+\t.type\t__save_r21_r29,@function\n+\t/* Allocate space and save registers 21 .. 29 on the stack */\n+\t/* Called via:\tjalr __save_r21_r29,r10 */\n+__save_r21_r29:\n+\tmov\tep,r1\n+\taddi\t-36,sp,sp\n+\tmov\tsp,ep\n+\tsst.w\tr29,0[ep]\n+\tsst.w\tr28,4[ep]\n+\tsst.w\tr27,8[ep]\n+\tsst.w\tr26,12[ep]\n+\tsst.w\tr25,16[ep]\n+\tsst.w\tr24,20[ep]\n+\tsst.w\tr23,24[ep]\n+\tsst.w\tr22,28[ep]\n+\tsst.w\tr21,32[ep]\n+\tmov\tr1,ep\n+\tjmp\t[r10]\n+\t.size\t__save_r21_r29,.-__save_r21_r29\n+\n+\t/* Restore saved registers, deallocate stack and return to the user */\n+\t/* Called via:\tjr __return_r21_r29 */\n+\t.align\t2\n+\t.globl\t__return_r21_r29\n+\t.type\t__return_r21_r29,@function\n+__return_r21_r29:\n+\tmov\tep,r1\n+\tmov\tsp,ep\n+\tsld.w\t0[ep],r29\n+\tsld.w\t4[ep],r28\n+\tsld.w\t8[ep],r27\n+\tsld.w\t12[ep],r26\n+\tsld.w\t16[ep],r25\n+\tsld.w\t20[ep],r24\n+\tsld.w\t24[ep],r23\n+\tsld.w\t28[ep],r22\n+\tsld.w\t32[ep],r21\n+\taddi\t36,sp,sp\n+\tmov\tr1,ep\n+\tjmp\t[r31]\n+\t.size\t__return_r21_r29,.-__return_r21_r29\n+#endif /* L_save_21 */\n+\n+#ifdef\tL_save_22\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r22_r29\n+\t.type\t__save_r22_r29,@function\n+\t/* Allocate space and save registers 22 .. 29 on the stack */\n+\t/* Called via:\tjalr __save_r22_r29,r10 */\n+__save_r22_r29:\n+\tmov\tep,r1\n+\taddi\t-32,sp,sp\n+\tmov\tsp,ep\n+\tsst.w\tr29,0[ep]\n+\tsst.w\tr28,4[ep]\n+\tsst.w\tr27,8[ep]\n+\tsst.w\tr26,12[ep]\n+\tsst.w\tr25,16[ep]\n+\tsst.w\tr24,20[ep]\n+\tsst.w\tr23,24[ep]\n+\tsst.w\tr22,28[ep]\n+\tmov\tr1,ep\n+\tjmp\t[r10]\n+\t.size\t__save_r22_r29,.-__save_r22_r29\n+\n+\t/* Restore saved registers, deallocate stack and return to the user */\n+\t/* Called via:\tjr __return_r22_r29 */\n+\t.align\t2\n+\t.globl\t__return_r22_r29\n+\t.type\t__return_r22_r29,@function\n+__return_r22_r29:\n+\tmov\tep,r1\n+\tmov\tsp,ep\n+\tsld.w\t0[ep],r29\n+\tsld.w\t4[ep],r28\n+\tsld.w\t8[ep],r27\n+\tsld.w\t12[ep],r26\n+\tsld.w\t16[ep],r25\n+\tsld.w\t20[ep],r24\n+\tsld.w\t24[ep],r23\n+\tsld.w\t28[ep],r22\n+\taddi\t32,sp,sp\n+\tmov\tr1,ep\n+\tjmp\t[r31]\n+\t.size\t__return_r22_r29,.-__return_r22_r29\n+#endif /* L_save_22 */\n+\n+#ifdef\tL_save_23\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r23_r29\n+\t.type\t__save_r23_r29,@function\n+\t/* Allocate space and save registers 23 .. 29 on the stack */\n+\t/* Called via:\tjalr __save_r23_r29,r10 */\n+__save_r23_r29:\n+\tmov\tep,r1\n+\taddi\t-28,sp,sp\n+\tmov\tsp,ep\n+\tsst.w\tr29,0[ep]\n+\tsst.w\tr28,4[ep]\n+\tsst.w\tr27,8[ep]\n+\tsst.w\tr26,12[ep]\n+\tsst.w\tr25,16[ep]\n+\tsst.w\tr24,20[ep]\n+\tsst.w\tr23,24[ep]\n+\tmov\tr1,ep\n+\tjmp\t[r10]\n+\t.size\t__save_r23_r29,.-__save_r23_r29\n+\n+\t/* Restore saved registers, deallocate stack and return to the user */\n+\t/* Called via:\tjr __return_r23_r29 */\n+\t.align\t2\n+\t.globl\t__return_r23_r29\n+\t.type\t__return_r23_r29,@function\n+__return_r23_r29:\n+\tmov\tep,r1\n+\tmov\tsp,ep\n+\tsld.w\t0[ep],r29\n+\tsld.w\t4[ep],r28\n+\tsld.w\t8[ep],r27\n+\tsld.w\t12[ep],r26\n+\tsld.w\t16[ep],r25\n+\tsld.w\t20[ep],r24\n+\tsld.w\t24[ep],r23\n+\taddi\t28,sp,sp\n+\tmov\tr1,ep\n+\tjmp\t[r31]\n+\t.size\t__return_r23_r29,.-__return_r23_r29\n+#endif /* L_save_23 */\n+\n+#ifdef\tL_save_24\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r24_r29\n+\t.type\t__save_r24_r29,@function\n+\t/* Allocate space and save registers 24 .. 29 on the stack */\n+\t/* Called via:\tjalr __save_r24_r29,r10 */\n+__save_r24_r29:\n+\tmov\tep,r1\n+\taddi\t-24,sp,sp\n+\tmov\tsp,ep\n+\tsst.w\tr29,0[ep]\n+\tsst.w\tr28,4[ep]\n+\tsst.w\tr27,8[ep]\n+\tsst.w\tr26,12[ep]\n+\tsst.w\tr25,16[ep]\n+\tsst.w\tr24,20[ep]\n+\tmov\tr1,ep\n+\tjmp\t[r10]\n+\t.size\t__save_r24_r29,.-__save_r24_r29\n+\n+\t/* Restore saved registers, deallocate stack and return to the user */\n+\t/* Called via:\tjr __return_r24_r29 */\n+\t.align\t2\n+\t.globl\t__return_r24_r29\n+\t.type\t__return_r24_r29,@function\n+__return_r24_r29:\n+\tmov\tep,r1\n+\tmov\tsp,ep\n+\tsld.w\t0[ep],r29\n+\tsld.w\t4[ep],r28\n+\tsld.w\t8[ep],r27\n+\tsld.w\t12[ep],r26\n+\tsld.w\t16[ep],r25\n+\tsld.w\t20[ep],r24\n+\taddi\t24,sp,sp\n+\tmov\tr1,ep\n+\tjmp\t[r31]\n+\t.size\t__return_r24_r29,.-__return_r24_r29\n+#endif /* L_save_24 */\n+\n+#ifdef\tL_save_25\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r25_r29\n+\t.type\t__save_r25_r29,@function\n+\t/* Allocate space and save registers 25 .. 29 on the stack */\n+\t/* Called via:\tjalr __save_r25_r29,r10 */\n+__save_r25_r29:\n+\tmov\tep,r1\n+\taddi\t-20,sp,sp\n+\tmov\tsp,ep\n+\tsst.w\tr29,0[ep]\n+\tsst.w\tr28,4[ep]\n+\tsst.w\tr27,8[ep]\n+\tsst.w\tr26,12[ep]\n+\tsst.w\tr25,16[ep]\n+\tmov\tr1,ep\n+\tjmp\t[r10]\n+\t.size\t__save_r25_r29,.-__save_r25_r29\n+\n+\t/* Restore saved registers, deallocate stack and return to the user */\n+\t/* Called via:\tjr __return_r25_r29 */\n+\t.align\t2\n+\t.globl\t__return_r25_r29\n+\t.type\t__return_r25_r29,@function\n+__return_r25_r29:\n+\tmov\tep,r1\n+\tmov\tsp,ep\n+\tsld.w\t0[ep],r29\n+\tsld.w\t4[ep],r28\n+\tsld.w\t8[ep],r27\n+\tsld.w\t12[ep],r26\n+\tsld.w\t16[ep],r25\n+\taddi\t20,sp,sp\n+\tmov\tr1,ep\n+\tjmp\t[r31]\n+\t.size\t__return_r25_r29,.-__return_r25_r29\n+#endif /* L_save_25 */\n+\n+#ifdef\tL_save_26\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r26_r29\n+\t.type\t__save_r26_r29,@function\n+\t/* Allocate space and save registers 26 .. 29 on the stack */\n+\t/* Called via:\tjalr __save_r26_r29,r10 */\n+__save_r26_r29:\n+\tmov\tep,r1\n+\tadd\t-16,sp\n+\tmov\tsp,ep\n+\tsst.w\tr29,0[ep]\n+\tsst.w\tr28,4[ep]\n+\tsst.w\tr27,8[ep]\n+\tsst.w\tr26,12[ep]\n+\tmov\tr1,ep\n+\tjmp\t[r10]\n+\t.size\t__save_r26_r29,.-__save_r26_r29\n+\n+\t/* Restore saved registers, deallocate stack and return to the user */\n+\t/* Called via:\tjr __return_r26_r29 */\n+\t.align\t2\n+\t.globl\t__return_r26_r29\n+\t.type\t__return_r26_r29,@function\n+__return_r26_r29:\n+\tmov\tep,r1\n+\tmov\tsp,ep\n+\tsld.w\t0[ep],r29\n+\tsld.w\t4[ep],r28\n+\tsld.w\t8[ep],r27\n+\tsld.w\t12[ep],r26\n+\taddi\t16,sp,sp\n+\tmov\tr1,ep\n+\tjmp\t[r31]\n+\t.size\t__return_r26_r29,.-__return_r26_r29\n+#endif /* L_save_26 */\n+\n+#ifdef\tL_save_27\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r27_r29\n+\t.type\t__save_r27_r29,@function\n+\t/* Allocate space and save registers 27 .. 29 on the stack */\n+\t/* Called via:\tjalr __save_r27_r29,r10 */\n+__save_r27_r29:\n+\tadd\t-12,sp\n+\tst.w\tr29,0[sp]\n+\tst.w\tr28,4[sp]\n+\tst.w\tr27,8[sp]\n+\tjmp\t[r10]\n+\t.size\t__save_r27_r29,.-__save_r27_r29\n+\n+\t/* Restore saved registers, deallocate stack and return to the user */\n+\t/* Called via:\tjr __return_r27_r29 */\n+\t.align\t2\n+\t.globl\t__return_r27_r29\n+\t.type\t__return_r27_r29,@function\n+__return_r27_r29:\n+\tld.w\t0[sp],r29\n+\tld.w\t4[sp],r28\n+\tld.w\t8[sp],r27\n+\tadd\t12,sp\n+\tjmp\t[r31]\n+\t.size\t__return_r27_r29,.-__return_r27_r29\n+#endif /* L_save_27 */\n+\n+#ifdef\tL_save_28\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r28_r29\n+\t.type\t__save_r28_r29,@function\n+\t/* Allocate space and save registers 28,29 on the stack */\n+\t/* Called via:\tjalr __save_r28_r29,r10 */\n+__save_r28_r29:\n+\tadd\t-8,sp\n+\tst.w\tr29,0[sp]\n+\tst.w\tr28,4[sp]\n+\tjmp\t[r10]\n+\t.size\t__save_r28_r29,.-__save_r28_r29\n+\n+\t/* Restore saved registers, deallocate stack and return to the user */\n+\t/* Called via:\tjr __return_r28_r29 */\n+\t.align\t2\n+\t.globl\t__return_r28_r29\n+\t.type\t__return_r28_r29,@function\n+__return_r28_r29:\n+\tld.w\t0[sp],r29\n+\tld.w\t4[sp],r28\n+\tadd\t8,sp\n+\tjmp\t[r31]\n+\t.size\t__return_r28_r29,.-__return_r28_r29\n+#endif /* L_save_28 */\n+\n+#ifdef\tL_save_29\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r29\n+\t.type\t__save_r29,@function\n+\t/* Allocate space and save register 29 on the stack */\n+\t/* Called via:\tjalr __save_r29,r10 */\n+__save_r29:\n+\tadd\t-4,sp\n+\tst.w\tr29,0[sp]\n+\tjmp\t[r10]\n+\t.size\t__save_r29,.-__save_r29\n+\n+\t/* Restore saved register 29, deallocate stack and return to the user */\n+\t/* Called via:\tjr __return_r29 */\n+\t.align\t2\n+\t.globl\t__return_r29\n+\t.type\t__return_r29,@function\n+__return_r29:\n+\tld.w\t0[sp],r29\n+\tadd\t4,sp\n+\tjmp\t[r31]\n+\t.size\t__return_r29,.-__return_r29\n+#endif /* L_save_28 */\n+\n+#ifdef\tL_save_2c\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r2_r31\n+\t.type\t__save_r2_r31,@function\n+\t/* Allocate space and save registers 20 .. 29, 31 on the stack */\n+\t/* Also allocate space for the argument save area */\n+\t/* Called via:\tjalr __save_r2_r31,r10 */\n+__save_r2_r31:\n+\tmov\tep,r1\n+\taddi\t-64,sp,sp\n+\tmov\tsp,ep\n+\tsst.w\tr29,16[ep]\n+\tsst.w\tr28,20[ep]\n+\tsst.w\tr27,24[ep]\n+\tsst.w\tr26,28[ep]\n+\tsst.w\tr25,32[ep]\n+\tsst.w\tr24,36[ep]\n+\tsst.w\tr23,40[ep]\n+\tsst.w\tr22,44[ep]\n+\tsst.w\tr21,48[ep]\n+\tsst.w\tr20,52[ep]\n+\tsst.w\tr2,56[ep]\n+\tsst.w\tr31,60[ep]\n+\tmov\tr1,ep\n+\tjmp\t[r10]\n+\t.size\t__save_r2_r31,.-__save_r2_r31\n+\n+\t/* Restore saved registers, deallocate stack and return to the user */\n+\t/* Called via:\tjr __return_r20_r31 */\n+\t.align\t2\n+\t.globl\t__return_r2_r31\n+\t.type\t__return_r2_r31,@function\n+__return_r2_r31:\n+\tmov\tep,r1\n+\tmov\tsp,ep\n+\tsld.w\t16[ep],r29\n+\tsld.w\t20[ep],r28\n+\tsld.w\t24[ep],r27\n+\tsld.w\t28[ep],r26\n+\tsld.w\t32[ep],r25\n+\tsld.w\t36[ep],r24\n+\tsld.w\t40[ep],r23\n+\tsld.w\t44[ep],r22\n+\tsld.w\t48[ep],r21\n+\tsld.w\t52[ep],r20\n+\tsld.w\t56[ep],r2\n+\tsld.w\t60[ep],r31\n+\taddi\t64,sp,sp\n+\tmov\tr1,ep\n+\tjmp\t[r31]\n+\t.size\t__return_r2_r31,.-__return_r2_r31\n+#endif /* L_save_2c */\n+\n+#ifdef\tL_save_20c\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r20_r31\n+\t.type\t__save_r20_r31,@function\n+\t/* Allocate space and save registers 20 .. 29, 31 on the stack */\n+\t/* Also allocate space for the argument save area */\n+\t/* Called via:\tjalr __save_r20_r31,r10 */\n+__save_r20_r31:\n+\tmov\tep,r1\n+\taddi\t-60,sp,sp\n+\tmov\tsp,ep\n+\tsst.w\tr29,16[ep]\n+\tsst.w\tr28,20[ep]\n+\tsst.w\tr27,24[ep]\n+\tsst.w\tr26,28[ep]\n+\tsst.w\tr25,32[ep]\n+\tsst.w\tr24,36[ep]\n+\tsst.w\tr23,40[ep]\n+\tsst.w\tr22,44[ep]\n+\tsst.w\tr21,48[ep]\n+\tsst.w\tr20,52[ep]\n+\tsst.w\tr31,56[ep]\n+\tmov\tr1,ep\n+\tjmp\t[r10]\n+\t.size\t__save_r20_r31,.-__save_r20_r31\n+\n+\t/* Restore saved registers, deallocate stack and return to the user */\n+\t/* Called via:\tjr __return_r20_r31 */\n+\t.align\t2\n+\t.globl\t__return_r20_r31\n+\t.type\t__return_r20_r31,@function\n+__return_r20_r31:\n+\tmov\tep,r1\n+\tmov\tsp,ep\n+\tsld.w\t16[ep],r29\n+\tsld.w\t20[ep],r28\n+\tsld.w\t24[ep],r27\n+\tsld.w\t28[ep],r26\n+\tsld.w\t32[ep],r25\n+\tsld.w\t36[ep],r24\n+\tsld.w\t40[ep],r23\n+\tsld.w\t44[ep],r22\n+\tsld.w\t48[ep],r21\n+\tsld.w\t52[ep],r20\n+\tsld.w\t56[ep],r31\n+\taddi\t60,sp,sp\n+\tmov\tr1,ep\n+\tjmp\t[r31]\n+\t.size\t__return_r20_r31,.-__return_r20_r31\n+#endif /* L_save_20c */\n+\n+#ifdef\tL_save_21c\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r21_r31\n+\t.type\t__save_r21_r31,@function\n+\t/* Allocate space and save registers 21 .. 29, 31 on the stack */\n+\t/* Also allocate space for the argument save area */\n+\t/* Called via:\tjalr __save_r21_r31,r10 */\n+__save_r21_r31:\n+\tmov\tep,r1\n+\taddi\t-56,sp,sp\n+\tmov\tsp,ep\n+\tsst.w\tr29,16[ep]\n+\tsst.w\tr28,20[ep]\n+\tsst.w\tr27,24[ep]\n+\tsst.w\tr26,28[ep]\n+\tsst.w\tr25,32[ep]\n+\tsst.w\tr24,36[ep]\n+\tsst.w\tr23,40[ep]\n+\tsst.w\tr22,44[ep]\n+\tsst.w\tr21,48[ep]\n+\tsst.w\tr31,52[ep]\n+\tmov\tr1,ep\n+\tjmp\t[r10]\n+\t.size\t__save_r21_r31,.-__save_r21_r31\n+\n+\t/* Restore saved registers, deallocate stack and return to the user */\n+\t/* Called via:\tjr __return_r21_r31 */\n+\t.align\t2\n+\t.globl\t__return_r21_r31\n+\t.type\t__return_r21_r31,@function\n+__return_r21_r31:\n+\tmov\tep,r1\n+\tmov\tsp,ep\n+\tsld.w\t16[ep],r29\n+\tsld.w\t20[ep],r28\n+\tsld.w\t24[ep],r27\n+\tsld.w\t28[ep],r26\n+\tsld.w\t32[ep],r25\n+\tsld.w\t36[ep],r24\n+\tsld.w\t40[ep],r23\n+\tsld.w\t44[ep],r22\n+\tsld.w\t48[ep],r21\n+\tsld.w\t52[ep],r31\n+\taddi\t56,sp,sp\n+\tmov\tr1,ep\n+\tjmp\t[r31]\n+\t.size\t__return_r21_r31,.-__return_r21_r31\n+#endif /* L_save_21c */\n+\n+#ifdef\tL_save_22c\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r22_r31\n+\t.type\t__save_r22_r31,@function\n+\t/* Allocate space and save registers 22 .. 29, 31 on the stack */\n+\t/* Also allocate space for the argument save area */\n+\t/* Called via:\tjalr __save_r22_r31,r10 */\n+__save_r22_r31:\n+\tmov\tep,r1\n+\taddi\t-52,sp,sp\n+\tmov\tsp,ep\n+\tsst.w\tr29,16[ep]\n+\tsst.w\tr28,20[ep]\n+\tsst.w\tr27,24[ep]\n+\tsst.w\tr26,28[ep]\n+\tsst.w\tr25,32[ep]\n+\tsst.w\tr24,36[ep]\n+\tsst.w\tr23,40[ep]\n+\tsst.w\tr22,44[ep]\n+\tsst.w\tr31,48[ep]\n+\tmov\tr1,ep\n+\tjmp\t[r10]\n+\t.size\t__save_r22_r31,.-__save_r22_r31\n+\n+\t/* Restore saved registers, deallocate stack and return to the user */\n+\t/* Called via:\tjr __return_r22_r31 */\n+\t.align\t2\n+\t.globl\t__return_r22_r31\n+\t.type\t__return_r22_r31,@function\n+__return_r22_r31:\n+\tmov\tep,r1\n+\tmov\tsp,ep\n+\tsld.w\t16[ep],r29\n+\tsld.w\t20[ep],r28\n+\tsld.w\t24[ep],r27\n+\tsld.w\t28[ep],r26\n+\tsld.w\t32[ep],r25\n+\tsld.w\t36[ep],r24\n+\tsld.w\t40[ep],r23\n+\tsld.w\t44[ep],r22\n+\tsld.w\t48[ep],r31\n+\taddi\t52,sp,sp\n+\tmov\tr1,ep\n+\tjmp\t[r31]\n+\t.size\t__return_r22_r31,.-__return_r22_r31\n+#endif /* L_save_22c */\n+\n+#ifdef\tL_save_23c\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r23_r31\n+\t.type\t__save_r23_r31,@function\n+\t/* Allocate space and save registers 23 .. 29, 31 on the stack */\n+\t/* Also allocate space for the argument save area */\n+\t/* Called via:\tjalr __save_r23_r31,r10 */\n+__save_r23_r31:\n+\tmov\tep,r1\n+\taddi\t-48,sp,sp\n+\tmov\tsp,ep\n+\tsst.w\tr29,16[ep]\n+\tsst.w\tr28,20[ep]\n+\tsst.w\tr27,24[ep]\n+\tsst.w\tr26,28[ep]\n+\tsst.w\tr25,32[ep]\n+\tsst.w\tr24,36[ep]\n+\tsst.w\tr23,40[ep]\n+\tsst.w\tr31,44[ep]\n+\tmov\tr1,ep\n+\tjmp\t[r10]\n+\t.size\t__save_r23_r31,.-__save_r23_r31\n+\n+\t/* Restore saved registers, deallocate stack and return to the user */\n+\t/* Called via:\tjr __return_r23_r31 */\n+\t.align\t2\n+\t.globl\t__return_r23_r31\n+\t.type\t__return_r23_r31,@function\n+__return_r23_r31:\n+\tmov\tep,r1\n+\tmov\tsp,ep\n+\tsld.w\t16[ep],r29\n+\tsld.w\t20[ep],r28\n+\tsld.w\t24[ep],r27\n+\tsld.w\t28[ep],r26\n+\tsld.w\t32[ep],r25\n+\tsld.w\t36[ep],r24\n+\tsld.w\t40[ep],r23\n+\tsld.w\t44[ep],r31\n+\taddi\t48,sp,sp\n+\tmov\tr1,ep\n+\tjmp\t[r31]\n+\t.size\t__return_r23_r31,.-__return_r23_r31\n+#endif /* L_save_23c */\n+\n+#ifdef\tL_save_24c\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r24_r31\n+\t.type\t__save_r24_r31,@function\n+\t/* Allocate space and save registers 24 .. 29, 31 on the stack */\n+\t/* Also allocate space for the argument save area */\n+\t/* Called via:\tjalr __save_r24_r31,r10 */\n+__save_r24_r31:\n+\tmov\tep,r1\n+\taddi\t-44,sp,sp\n+\tmov\tsp,ep\n+\tsst.w\tr29,16[ep]\n+\tsst.w\tr28,20[ep]\n+\tsst.w\tr27,24[ep]\n+\tsst.w\tr26,28[ep]\n+\tsst.w\tr25,32[ep]\n+\tsst.w\tr24,36[ep]\n+\tsst.w\tr31,40[ep]\n+\tmov\tr1,ep\n+\tjmp\t[r10]\n+\t.size\t__save_r24_r31,.-__save_r24_r31\n+\n+\t/* Restore saved registers, deallocate stack and return to the user */\n+\t/* Called via:\tjr __return_r24_r31 */\n+\t.align\t2\n+\t.globl\t__return_r24_r31\n+\t.type\t__return_r24_r31,@function\n+__return_r24_r31:\n+\tmov\tep,r1\n+\tmov\tsp,ep\n+\tsld.w\t16[ep],r29\n+\tsld.w\t20[ep],r28\n+\tsld.w\t24[ep],r27\n+\tsld.w\t28[ep],r26\n+\tsld.w\t32[ep],r25\n+\tsld.w\t36[ep],r24\n+\tsld.w\t40[ep],r31\n+\taddi\t44,sp,sp\n+\tmov\tr1,ep\n+\tjmp\t[r31]\n+\t.size\t__return_r24_r31,.-__return_r24_r31\n+#endif /* L_save_24c */\n+\n+#ifdef\tL_save_25c\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r25_r31\n+\t.type\t__save_r25_r31,@function\n+\t/* Allocate space and save registers 25 .. 29, 31 on the stack */\n+\t/* Also allocate space for the argument save area */\n+\t/* Called via:\tjalr __save_r25_r31,r10 */\n+__save_r25_r31:\n+\tmov\tep,r1\n+\taddi\t-40,sp,sp\n+\tmov\tsp,ep\n+\tsst.w\tr29,16[ep]\n+\tsst.w\tr28,20[ep]\n+\tsst.w\tr27,24[ep]\n+\tsst.w\tr26,28[ep]\n+\tsst.w\tr25,32[ep]\n+\tsst.w\tr31,36[ep]\n+\tmov\tr1,ep\n+\tjmp\t[r10]\n+\t.size\t__save_r25_r31,.-__save_r25_r31\n+\n+\t/* Restore saved registers, deallocate stack and return to the user */\n+\t/* Called via:\tjr __return_r25_r31 */\n+\t.align\t2\n+\t.globl\t__return_r25_r31\n+\t.type\t__return_r25_r31,@function\n+__return_r25_r31:\n+\tmov\tep,r1\n+\tmov\tsp,ep\n+\tsld.w\t16[ep],r29\n+\tsld.w\t20[ep],r28\n+\tsld.w\t24[ep],r27\n+\tsld.w\t28[ep],r26\n+\tsld.w\t32[ep],r25\n+\tsld.w\t36[ep],r31\n+\taddi\t40,sp,sp\n+\tmov\tr1,ep\n+\tjmp\t[r31]\n+\t.size\t__return_r25_r31,.-__return_r25_r31\n+#endif /* L_save_25c */\n+\n+#ifdef\tL_save_26c\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r26_r31\n+\t.type\t__save_r26_r31,@function\n+\t/* Allocate space and save registers 26 .. 29, 31 on the stack */\n+\t/* Also allocate space for the argument save area */\n+\t/* Called via:\tjalr __save_r26_r31,r10 */\n+__save_r26_r31:\n+\tmov\tep,r1\n+\taddi\t-36,sp,sp\n+\tmov\tsp,ep\n+\tsst.w\tr29,16[ep]\n+\tsst.w\tr28,20[ep]\n+\tsst.w\tr27,24[ep]\n+\tsst.w\tr26,28[ep]\n+\tsst.w\tr31,32[ep]\n+\tmov\tr1,ep\n+\tjmp\t[r10]\n+\t.size\t__save_r26_r31,.-__save_r26_r31\n+\n+\t/* Restore saved registers, deallocate stack and return to the user */\n+\t/* Called via:\tjr __return_r26_r31 */\n+\t.align\t2\n+\t.globl\t__return_r26_r31\n+\t.type\t__return_r26_r31,@function\n+__return_r26_r31:\n+\tmov\tep,r1\n+\tmov\tsp,ep\n+\tsld.w\t16[ep],r29\n+\tsld.w\t20[ep],r28\n+\tsld.w\t24[ep],r27\n+\tsld.w\t28[ep],r26\n+\tsld.w\t32[ep],r31\n+\taddi\t36,sp,sp\n+\tmov\tr1,ep\n+\tjmp\t[r31]\n+\t.size\t__return_r26_r31,.-__return_r26_r31\n+#endif /* L_save_26c */\n+\n+#ifdef\tL_save_27c\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r27_r31\n+\t.type\t__save_r27_r31,@function\n+\t/* Allocate space and save registers 27 .. 29, 31 on the stack */\n+\t/* Also allocate space for the argument save area */\n+\t/* Called via:\tjalr __save_r27_r31,r10 */\n+__save_r27_r31:\n+\tmov\tep,r1\n+\taddi\t-32,sp,sp\n+\tmov\tsp,ep\n+\tsst.w\tr29,16[ep]\n+\tsst.w\tr28,20[ep]\n+\tsst.w\tr27,24[ep]\n+\tsst.w\tr31,28[ep]\n+\tmov\tr1,ep\n+\tjmp\t[r10]\n+\t.size\t__save_r27_r31,.-__save_r27_r31\n+\n+\t/* Restore saved registers, deallocate stack and return to the user */\n+\t/* Called via:\tjr __return_r27_r31 */\n+\t.align\t2\n+\t.globl\t__return_r27_r31\n+\t.type\t__return_r27_r31,@function\n+__return_r27_r31:\n+\tmov\tep,r1\n+\tmov\tsp,ep\n+\tsld.w\t16[ep],r29\n+\tsld.w\t20[ep],r28\n+\tsld.w\t24[ep],r27\n+\tsld.w\t28[ep],r31\n+\taddi\t32,sp,sp\n+\tmov\tr1,ep\n+\tjmp\t[r31]\n+\t.size\t__return_r27_r31,.-__return_r27_r31\n+#endif /* L_save_27c */\n+\n+#ifdef\tL_save_28c\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r28_r31\n+\t.type\t__save_r28_r31,@function\n+\t/* Allocate space and save registers 28 .. 29, 31 on the stack */\n+\t/* Also allocate space for the argument save area */\n+\t/* Called via:\tjalr __save_r28_r31,r10 */\n+__save_r28_r31:\n+\taddi\t-28,sp,sp\n+\tst.w\tr29,16[sp]\n+\tst.w\tr28,20[sp]\n+\tst.w\tr31,24[sp]\n+\tjmp\t[r10]\n+\t.size\t__save_r28_r31,.-__save_r28_r31\n+\n+\t/* Restore saved registers, deallocate stack and return to the user */\n+\t/* Called via:\tjr __return_r28_r31 */\n+\t.align\t2\n+\t.globl\t__return_r28_r31\n+\t.type\t__return_r28_r31,@function\n+__return_r28_r31:\n+\tld.w\t16[sp],r29\n+\tld.w\t20[sp],r28\n+\tld.w\t24[sp],r31\n+\taddi\t28,sp,sp\n+\tjmp\t[r31]\n+\t.size\t__return_r28_r31,.-__return_r28_r31\n+#endif /* L_save_28c */\n+\n+#ifdef\tL_save_29c\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r29_r31\n+\t.type\t__save_r29_r31,@function\n+\t/* Allocate space and save registers 29 & 31 on the stack */\n+\t/* Also allocate space for the argument save area */\n+\t/* Called via:\tjalr __save_r29_r31,r10 */\n+__save_r29_r31:\n+\taddi\t-24,sp,sp\n+\tst.w\tr29,16[sp]\n+\tst.w\tr31,20[sp]\n+\tjmp\t[r10]\n+\t.size\t__save_r29_r31,.-__save_r29_r31\n+\n+\t/* Restore saved registers, deallocate stack and return to the user */\n+\t/* Called via:\tjr __return_r29_r31 */\n+\t.align\t2\n+\t.globl\t__return_r29_r31\n+\t.type\t__return_r29_r31,@function\n+__return_r29_r31:\n+\tld.w\t16[sp],r29\n+\tld.w\t20[sp],r31\n+\taddi\t24,sp,sp\n+\tjmp\t[r31]\n+\t.size\t__return_r29_r31,.-__return_r29_r31\n+#endif /* L_save_29c */\n+\n+#ifdef\tL_save_31c\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r31\n+\t.type\t__save_r31,@function\n+\t/* Allocate space and save register 31 on the stack */\n+\t/* Also allocate space for the argument save area */\n+\t/* Called via:\tjalr __save_r29_r31,r10 */\n+__save_r31:\n+\taddi\t-20,sp,sp\n+\tst.w\tr31,16[sp]\n+\tjmp\t[r10]\n+\t.size\t__save_r31,.-__save_r31\n+\n+\t/* Restore saved registers, deallocate stack and return to the user */\n+\t/* Called via:\tjr __return_r31 */\n+\t.align\t2\n+\t.globl\t__return_r31\n+\t.type\t__return_r31,@function\n+__return_r31:\n+\tld.w\t16[sp],r31\n+\taddi\t20,sp,sp\n+\tjmp\t[r31]\n+\t.size\t__return_r29_r31,.-__return_r29_r31\n+#endif /* L_save_31c */\n+\n+#ifdef L_save_varargs\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_r6_r9\n+\t.type\t__save_r6_r9,@function\n+\t/* Save registers 6 .. 9 on the stack for variable argument functions */\n+\t/* Called via:\tjalr __save_r6_r9,r10 */\n+__save_r6_r9:\n+\tmov\tep,r1\n+\tmov\tsp,ep\n+\tsst.w\tr6,0[ep]\n+\tsst.w\tr7,4[ep]\n+\tsst.w\tr8,8[ep]\n+\tsst.w\tr9,12[ep]\n+\tmov\tr1,ep\n+\tjmp\t[r10]\n+\t.size\t__save_r6_r9,.-__save_r6_r9\n+#endif /* L_save_varargs */\n+\n+#ifdef\tL_save_interrupt\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_interrupt\n+\t.type\t__save_interrupt,@function\n+\t/* Save registers r1, r5 on stack and load up with expected values */\n+\t/* Note, 12 bytes of stack have already been allocated. */\n+\t/* Called via:\tjalr __save_interrupt,r10 */\n+__save_interrupt:\n+\tst.w\tep,0[sp]\n+\tst.w\tgp,4[sp]\n+\tst.w\tr1,8[sp]\n+\tmovhi\thi(__ep),r0,ep\n+\tmovea\tlo(__ep),ep,ep\n+\tmovhi\thi(__gp),r0,gp\n+\tmovea\tlo(__gp),gp,gp\n+\tjmp\t[r10]\n+\t.size\t__save_interrupt,.-__save_interrupt\n+\n+\t/* Restore saved registers, deallocate stack and return from the interrupt */\n+\t/* Called via:\tjr __return_interupt */\n+\t.align\t2\n+\t.globl\t__return_interrupt\n+\t.type\t__return_interrupt,@function\n+__return_interrupt:\n+\tld.w\t0[sp],ep\n+\tld.w\t4[sp],gp\n+\tld.w\t8[ep],r1\n+\tld.w\t12[ep],r10\n+\tadd\t12,sp\n+\treti\n+\t.size\t__return_interrupt,.-__return_interrupt\n+#endif /* L_save_interrupt */\n+\n+#ifdef L_save_all_interrupt\n+\t.text\n+\t.align\t2\n+\t.globl\t__save_all_interrupt\n+\t.type\t__save_all_interrupt,@function\n+\t/* Save all registers except for those saved in __save_interrupt */\n+\t/* allocate enough stack for all of the registers & 16 bytes of space */\n+\t/* Called via:\tjalr __save_all_interrupt,r10 */\n+__save_all_interrupt:\n+\taddi\t-120,sp,sp\n+\tmov\tep,r1\n+\tmov\tsp,ep\n+\tsst.w\tr31,116[ep]\n+\tsst.w\tr2,112[ep]\n+\tsst.w\tgp,108[ep]\n+\tsst.w\tr6,104[ep]\n+\tsst.w\tr7,100[ep]\n+\tsst.w\tr8,96[ep]\n+\tsst.w\tr9,92[ep]\n+\tsst.w\tr11,88[ep]\n+\tsst.w\tr12,84[ep]\n+\tsst.w\tr13,80[ep]\n+\tsst.w\tr14,76[ep]\n+\tsst.w\tr15,72[ep]\n+\tsst.w\tr16,68[ep]\n+\tsst.w\tr17,64[ep]\n+\tsst.w\tr18,60[ep]\n+\tsst.w\tr19,56[ep]\n+\tsst.w\tr20,52[ep]\n+\tsst.w\tr21,48[ep]\n+\tsst.w\tr22,44[ep]\n+\tsst.w\tr23,40[ep]\n+\tsst.w\tr24,36[ep]\n+\tsst.w\tr25,32[ep]\n+\tsst.w\tr26,28[ep]\n+\tsst.w\tr27,24[ep]\n+\tsst.w\tr28,20[ep]\n+\tsst.w\tr29,16[ep]\n+\tmov\tr1,ep\n+\tjmp\t[r10]\n+\t.size\t__save_all_interrupt,.-__save_all_interrupt\n+\n+\t.globl\t__restore_all_interrupt\n+\t.type\t__restore_all_interrupt,@function\n+\t/* Restore all registers saved in __save_all_interrupt */\n+\t/* & deallocate the stack space */\n+\t/* Called via:\tjalr __restore_all_interrupt,r10 */\n+__restore_all_interrupt:\n+\tmov\tep,r1\n+\tmov\tsp,ep\n+\tsld.w\t116[ep],r31\n+\tsld.w\t112[ep],r2\n+\tsld.w\t108[ep],gp\n+\tsld.w\t104[ep],r6\n+\tsld.w\t100[ep],r7\n+\tsld.w\t96[ep],r8\n+\tsld.w\t92[ep],r9\n+\tsld.w\t88[ep],r11\n+\tsld.w\t84[ep],r12\n+\tsld.w\t80[ep],r13\n+\tsld.w\t76[ep],r14\n+\tsld.w\t72[ep],r15\n+\tsld.w\t68[ep],r16\n+\tsld.w\t64[ep],r17\n+\tsld.w\t60[ep],r18\n+\tsld.w\t56[ep],r19\n+\tsld.w\t52[ep],r20\n+\tsld.w\t48[ep],r21\n+\tsld.w\t44[ep],r22\n+\tsld.w\t40[ep],r23\n+\tsld.w\t36[ep],r24\n+\tsld.w\t32[ep],r25\n+\tsld.w\t28[ep],r26\n+\tsld.w\t24[ep],r27\n+\tsld.w\t20[ep],r28\n+\tsld.w\t16[ep],r29\n+\tmov\tr1,ep\n+\taddi\t120,sp,sp\n+\tjmp\t[r10]\n+\t.size\t__restore_all_interrupt,.-__restore_all_interrupt\n+#endif /* L_save_all_interrupt */\n+/* END CYGNUS LOCAL */"}, {"sha": "52034414b70739418d4cce73a62cb713604ea98a", "filename": "gcc/config/v850/t-v850", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae180d84fc7bb97b09fb67a1e478288d748e41fb/gcc%2Fconfig%2Fv850%2Ft-v850", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae180d84fc7bb97b09fb67a1e478288d748e41fb/gcc%2Fconfig%2Fv850%2Ft-v850", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Ft-v850?ref=ae180d84fc7bb97b09fb67a1e478288d748e41fb", "patch": "@@ -0,0 +1,54 @@\n+# CYGNUS LOCAL entire file v850/law\n+CROSS_LIBGCC1 = libgcc1-asm.a\n+LIB1ASMSRC = v850/lib1funcs.asm\n+LIB1ASMFUNCS\t= _mulsi3 \\\n+\t\t  _divsi3 \\\n+\t\t  _udivsi3 \\\n+\t\t  _modsi3 \\\n+\t\t  _umodsi3 \\\n+\t\t  _save_2 \\\n+\t\t  _save_20 \\\n+\t\t  _save_21 \\\n+\t\t  _save_22 \\\n+\t\t  _save_23 \\\n+\t\t  _save_24 \\\n+\t\t  _save_25 \\\n+\t\t  _save_26 \\\n+\t\t  _save_27 \\\n+\t\t  _save_28 \\\n+\t\t  _save_29 \\\n+\t\t  _save_2c \\\n+\t\t  _save_20c \\\n+\t\t  _save_21c \\\n+\t\t  _save_22c \\\n+\t\t  _save_23c \\\n+\t\t  _save_24c \\\n+\t\t  _save_25c \\\n+\t\t  _save_26c \\\n+\t\t  _save_27c \\\n+\t\t  _save_28c \\\n+\t\t  _save_29c \\\n+\t\t  _save_31c \\\n+\t\t  _save_varargs \\\n+\t\t  _save_interrupt \\\n+\t\t  _save_all_interrupt\n+\t\n+\n+# These are really part of libgcc1, but this will cause them to be\n+# built correctly, so...\n+\n+LIB2FUNCS_EXTRA = fp-bit.c dp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#ifdef __LITTLE_ENDIAN__' > dp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >>dp-bit.c\n+\techo '#endif' \t\t>> dp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\techo '#ifdef __LITTLE_ENDIAN__' >> fp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >>fp-bit.c\n+\techo '#endif' \t\t>> fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+#END CYGNUS LOCAL"}, {"sha": "6435d4093363075c059cd371fdc7b6e0f0adb5a0", "filename": "gcc/config/v850/v850.c", "status": "added", "additions": 1942, "deletions": 0, "changes": 1942, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae180d84fc7bb97b09fb67a1e478288d748e41fb/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae180d84fc7bb97b09fb67a1e478288d748e41fb/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=ae180d84fc7bb97b09fb67a1e478288d748e41fb", "patch": "@@ -0,0 +1,1942 @@\n+/* Subroutines for insn-output.c for NEC V850 series\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Jeff Law (law@cygnus.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include <stdio.h>\n+#include <ctype.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"recog.h\"\n+#include \"expr.h\"\n+#include \"tree.h\"\n+#include \"obstack.h\"\n+\n+/* True if the current function has anonymous arguments.  */\n+int current_function_anonymous_args;\n+\n+/* Information about the various small memory areas.  */\n+struct small_memory_info small_memory[ (int)SMALL_MEMORY_max ] =\n+{\n+  /* name\tvalue\t\tmax\t\tphysical max */\n+  { \"tda\",\t(char *)0,\t0,\t\t256 },\n+  { \"sda\",\t(char *)0,\t0,\t\t65536 },\n+  { \"zda\",\t(char *)0,\t0,\t\t32768 },\n+};\n+\n+/* True if we don't need to check any more if the current\n+   function is an interrupt handler */\n+static int v850_interrupt_cache_p = FALSE;\n+\n+/* Whether current function is an interrupt handler.  */\n+static int v850_interrupt_p = FALSE;\n+\n+\f\n+/* Sometimes certain combinations of command options do not make\n+   sense on a particular target machine.  You can define a macro\n+   `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n+   defined, is executed once just after all the command options have\n+   been parsed.\n+\n+   Don't use this macro to turn on various extra optimizations for\n+   `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */\n+\n+void\n+override_options ()\n+{\n+  int i;\n+  extern int atoi ();\n+\n+  /* Parse -m{s,t,z}da=nnn switches */\n+  for (i = 0; i < (int)SMALL_MEMORY_max; i++)\n+    {\n+      if (small_memory[i].value)\n+\t{\n+\t  if (!isdigit (*small_memory[i].value))\n+\t    error (\"%s=%s is not numeric.\",\n+\t\t   small_memory[i].name,\n+\t\t   small_memory[i].value);\n+\t  else\n+\t    {\n+\t      small_memory[i].max = atoi (small_memory[i].value);\n+\t      if (small_memory[i].max > small_memory[i].physical_max)\n+\t\terror (\"%s=%s is too large.\",\n+\t\t   small_memory[i].name,\n+\t\t   small_memory[i].value);\n+\t    }\n+\t}\n+    }\n+}\n+\n+\f\n+/* Output assembly code for the start of the file.  */\n+\n+void\n+asm_file_start (file)\n+     FILE *file;\n+{\n+  output_file_directive (file, main_input_filename);\n+}\n+\f\n+\n+/* Return an RTX to represent where a value with mode MODE will be returned\n+   from a function.  If the result is 0, the argument is pushed.  */\n+\n+rtx\n+function_arg (cum, mode, type, named)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+{\n+  rtx result = 0;\n+  int size, align;\n+\n+  if (TARGET_GHS && !named)\n+    return NULL_RTX;\n+\n+  if (mode == BLKmode)\n+    size = int_size_in_bytes (type);\n+  else\n+    size = GET_MODE_SIZE (mode);\n+\n+  if (type)\n+    align = TYPE_ALIGN (type) / BITS_PER_UNIT;\n+  else\n+    align = size;\n+\n+  cum->nbytes = (cum->nbytes + align - 1) &~(align - 1);\n+\n+  if (cum->nbytes > 4 * UNITS_PER_WORD)\n+    return 0;\n+\n+  if (type == NULL_TREE\n+      && cum->nbytes + size > 4 * UNITS_PER_WORD)\n+    return 0;\n+\n+  switch (cum->nbytes / UNITS_PER_WORD)\n+    {\n+    case 0:\n+      result = gen_rtx (REG, mode, 6);\n+      break;\n+    case 1:\n+      result = gen_rtx (REG, mode, 7);\n+      break;\n+    case 2:\n+      result = gen_rtx (REG, mode, 8);\n+      break;\n+    case 3:\n+      result = gen_rtx (REG, mode, 9);\n+      break;\n+    default:\n+      result = 0;\n+    }\n+\n+  return result;\n+}\n+\n+\f\n+/* Return the number of words which must be put into registers\n+   for values which are part in registers and part in memory.  */\n+\n+int\n+function_arg_partial_nregs (cum, mode, type, named)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+{\n+  int size, align;\n+\n+  if (TARGET_GHS && !named)\n+    return 0;\n+\n+  if (mode == BLKmode)\n+    size = int_size_in_bytes (type);\n+  else\n+    size = GET_MODE_SIZE (mode);\n+\n+  if (type)\n+    align = TYPE_ALIGN (type) / BITS_PER_UNIT;\n+  else\n+    align = size;\n+\n+  cum->nbytes = (cum->nbytes + align - 1) &~(align - 1);\n+\n+  if (cum->nbytes > 4 * UNITS_PER_WORD)\n+    return 0;\n+\n+  if (cum->nbytes + size <= 4 * UNITS_PER_WORD)\n+    return 0;\n+\n+  if (type == NULL_TREE\n+      && cum->nbytes + size > 4 * UNITS_PER_WORD)\n+    return 0;\n+\n+  return (4 * UNITS_PER_WORD - cum->nbytes) / UNITS_PER_WORD;\n+}\n+\n+\f\n+/* Return the high and low words of a CONST_DOUBLE */\n+\n+static void\n+const_double_split (x, p_high, p_low)\n+     rtx x;\n+     HOST_WIDE_INT *p_high;\n+     HOST_WIDE_INT *p_low;\n+{\n+  if (GET_CODE (x) == CONST_DOUBLE)\n+    {\n+      long t[2];\n+      REAL_VALUE_TYPE rv;\n+\n+      switch (GET_MODE (x))\n+\t{\n+\tcase DFmode:\n+\t  REAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n+\t  REAL_VALUE_TO_TARGET_DOUBLE (rv, t);\n+\t  *p_high = t[1];\t/* since v850 is little endian */\n+\t  *p_low = t[0];\t/* high is second word */\n+\t  return;\n+\n+\tcase SFmode:\n+\t  REAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n+\t  REAL_VALUE_TO_TARGET_SINGLE (rv, *p_high);\n+\t  *p_low = 0;\n+\t  return;\n+\n+\tcase VOIDmode:\n+\tcase DImode:\n+\t  *p_high = CONST_DOUBLE_HIGH (x);\n+\t  *p_low  = CONST_DOUBLE_LOW (x);\n+\t  return;\n+\t}\n+    }\n+\n+  fatal_insn (\"const_double_split got a bad insn:\", x);\n+}\n+\n+\f\n+/* Return the cost of the rtx R with code CODE.  */\n+\n+static int\n+const_costs_int (value, zero_cost)\n+     HOST_WIDE_INT value;\n+     int zero_cost;\n+{\n+  if (CONST_OK_FOR_I (value))\n+      return zero_cost;\n+  else if (CONST_OK_FOR_J (value))\n+    return 1;\n+  else if (CONST_OK_FOR_K (value))\n+    return 2;\n+  else\n+    return 4;\n+}\n+\n+int\n+const_costs (r, c)\n+     rtx r;\n+     enum rtx_code c;\n+{\n+  HOST_WIDE_INT high, low;\n+\n+  switch (c)\n+    {\n+    case CONST_INT:\n+      return const_costs_int (INTVAL (r), 0);\n+\n+    case CONST_DOUBLE:\n+      const_double_split (r, &high, &low);\n+      if (GET_MODE (r) == SFmode)\n+\treturn const_costs_int (high, 1);\n+      else\n+\treturn const_costs_int (high, 1) + const_costs_int (low, 1);\n+\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+    case CONST:\n+      return 2;\n+\n+    case HIGH:\n+      return 1;\n+\n+    default:\n+      return 4;\n+    }\n+}\n+\n+\f\n+/* Print operand X using operand code CODE to assembly language output file\n+   FILE.  */\n+\n+void\n+print_operand (file, x, code)\n+     FILE *file;\n+     rtx x;\n+     int code;\n+{\n+  HOST_WIDE_INT high, low;\n+\n+  switch (code)\n+    {\n+    case 'b':\n+    case 'B':\n+      switch (code == 'b' ? GET_CODE (x) : reverse_condition (GET_CODE (x)))\n+\t{\n+\t  case NE:\n+\t    fprintf (file, \"bne\");\n+\t    break;\n+\t  case EQ:\n+\t    fprintf (file, \"be\");\n+\t    break;\n+\t  case GE:\n+\t    fprintf (file, \"bge\");\n+\t    break;\n+\t  case GT:\n+\t    fprintf (file, \"bgt\");\n+\t    break;\n+\t  case LE:\n+\t    fprintf (file, \"ble\");\n+\t    break;\n+\t  case LT:\n+\t    fprintf (file, \"blt\");\n+\t    break;\n+\t  case GEU:\n+\t    fprintf (file, \"bnl\");\n+\t    break;\n+\t  case GTU:\n+\t    fprintf (file, \"bh\");\n+\t    break;\n+\t  case LEU:\n+\t    fprintf (file, \"bnh\");\n+\t    break;\n+\t  case LTU:\n+\t    fprintf (file, \"bl\");\n+\t    break;\n+\t  default:\n+\t    abort ();\n+\t}\n+      break;\n+      switch (GET_CODE (x))\n+\t{\n+\t  case NE:\n+\t    fprintf (file, \"be\");\n+\t    break;\n+\t  case EQ:\n+\t    fprintf (file, \"bne\");\n+\t    break;\n+\t  case GE:\n+\t    fprintf (file, \"blt\");\n+\t    break;\n+\t  case GT:\n+\t    fprintf (file, \"bgt\");\n+\t    break;\n+\t  case LE:\n+\t    fprintf (file, \"ble\");\n+\t    break;\n+\t  case LT:\n+\t    fprintf (file, \"blt\");\n+\t    break;\n+\t  case GEU:\n+\t    fprintf (file, \"bnl\");\n+\t    break;\n+\t  case GTU:\n+\t    fprintf (file, \"bh\");\n+\t    break;\n+\t  case LEU:\n+\t    fprintf (file, \"bnh\");\n+\t    break;\n+\t  case LTU:\n+\t    fprintf (file, \"bl\");\n+\t    break;\n+\t  default:\n+\t    abort ();\n+\t}\n+      break;\n+    case 'F':\t\t\t/* high word of CONST_DOUBLE */\n+      if (GET_CODE (x) == CONST_INT)\n+\tfprintf (file, \"%d\", (INTVAL (x) >= 0) ? 0 : -1);\n+      else if (GET_CODE (x) == CONST_DOUBLE)\n+\t{\n+\t  const_double_split (x, &high, &low);\n+\t  fprintf (file, \"%ld\", (long) high);\n+\t}\n+      else\n+\tabort ();\n+      break;\n+    case 'G':\t\t\t/* low word of CONST_DOUBLE */\n+      if (GET_CODE (x) == CONST_INT)\n+\tfprintf (file, \"%ld\", (long) INTVAL (x));\n+      else if (GET_CODE (x) == CONST_DOUBLE)\n+\t{\n+\t  const_double_split (x, &high, &low);\n+\t  fprintf (file, \"%ld\", (long) low);\n+\t}\n+      else\n+\tabort ();\n+      break;\n+    case 'L':\n+      fprintf (file, \"%d\\n\", INTVAL (x) & 0xffff);\n+      break;\n+    case 'M':\n+      fprintf (file, \"%d\", exact_log2 (INTVAL (x)));\n+      break;\n+    case 'O':\n+      if (special_symbolref_operand (x, VOIDmode))\n+        {\n+          char* name;\n+\n+\t  if (GET_CODE (x) == SYMBOL_REF)\n+\t    name = XSTR (x, 0);\n+\t  else if (GET_CODE (x) == CONST)\n+\t    name = XSTR (XEXP (XEXP (x, 0), 0), 0);\n+\t  else\n+\t    abort ();\n+\n+          if (ZDA_NAME_P (name))\n+            fprintf (file, \"zdaoff\");\n+          else if (SDA_NAME_P (name))\n+            fprintf (file, \"sdaoff\");\n+          else if (TDA_NAME_P (name))\n+            fprintf (file, \"tdaoff\");\n+          else\n+            abort();\n+        }\n+      else\n+        abort();\n+      break;\n+    case 'P':\n+      if (special_symbolref_operand (x, VOIDmode))\n+        output_addr_const (file, x);\n+      else\n+        abort();\n+      break;\n+    case 'Q':\n+      if (special_symbolref_operand (x, VOIDmode))\n+        {\n+          char* name;\n+\n+\t  if (GET_CODE (x) == SYMBOL_REF)\n+\t    name = XSTR (x, 0);\n+\t  else if (GET_CODE (x) == CONST)\n+\t    name = XSTR (XEXP (XEXP (x, 0), 0), 0);\n+\t  else\n+\t    abort ();\n+\n+          if (ZDA_NAME_P (name))\n+            fprintf (file, \"r0\");\n+          else if (SDA_NAME_P (name))\n+            fprintf (file, \"gp\");\n+          else if (TDA_NAME_P (name))\n+            fprintf (file, \"ep\");\n+          else\n+            abort();\n+        }\n+      else\n+        abort();\n+      break;\n+    case 'R':\t\t/* 2nd word of a double.  */\n+      switch (GET_CODE (x))\n+\t{\n+\t  case REG:\n+\t    fprintf (file, reg_names[REGNO (x) + 1]);\n+\t    break;\n+\t  case MEM:\n+\t    print_operand_address (file,\n+\t\t\t\t   XEXP (adj_offsettable_operand (x, 4), 0));\n+\t    break;\n+\t}\n+      break;\n+    case 'S':\n+      {\n+        /* if it's a referance to a TDA variable, use sst/sld vs. st/ld */\n+        if (GET_CODE (x) == MEM && ep_memory_operand (x, GET_MODE (x)))\n+          fputs (\"s\", file);\n+\n+        break;\n+      }\n+    case 'W':\t\t\t/* print the instruction suffix */\n+      switch (GET_MODE (x))\n+\t{\n+\tdefault:\n+\t  abort ();\n+\n+\tcase QImode: fputs (\".b\", file); break;\n+\tcase HImode: fputs (\".h\", file); break;\n+\tcase SImode: fputs (\".w\", file); break;\n+\tcase SFmode: fputs (\".w\", file); break;\n+\t}\n+      break;\n+    case '.':\t\t\t/* register r0 */\n+      fputs (reg_names[0], file);\n+      break;\n+    default:\n+      switch (GET_CODE (x))\n+\t{\n+\tcase MEM:\n+\t  if (GET_CODE (XEXP (x, 0)) == CONST_INT)\n+\t    output_address (gen_rtx (PLUS, SImode,\n+\t\t\t\t     gen_rtx (REG, SImode, 0),\n+\t\t\t\t     XEXP (x, 0)));\n+\t  else\n+\t    output_address (XEXP (x, 0));\n+\t  break;\n+\n+\tcase REG:\n+\t  fputs (reg_names[REGNO (x)], file);\n+\t  break;\n+\tcase SUBREG:\n+\t  fputs (reg_names[REGNO (SUBREG_REG (x)) + SUBREG_WORD (x)], file);\n+\t  break;\n+\tcase CONST_INT:\n+\tcase SYMBOL_REF:\n+\tcase CONST:\n+\tcase LABEL_REF:\n+\tcase CODE_LABEL:\n+\t  print_operand_address (file, x);\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+\n+    }\n+}\n+\n+\f\n+/* Output assembly language output for the address ADDR to FILE.  */\n+\n+void\n+print_operand_address (file, addr)\n+     FILE *file;\n+     rtx addr;\n+{\n+  switch (GET_CODE (addr))\n+    {\n+    case REG:\n+      fprintf (file, \"0[\");\n+      print_operand (file, addr, 0);\n+      fprintf (file, \"]\");\n+      break;\n+    case LO_SUM:\n+      if (GET_CODE (XEXP (addr, 0)) == REG)\n+\t{\n+\t  /* reg,foo */\n+\t  fprintf (file, \"lo(\");\n+\t  print_operand (file, XEXP (addr, 1), 0);\n+\t  fprintf (file, \")[\");\n+\t  print_operand (file, XEXP (addr, 0), 0);\n+\t  fprintf (file, \"]\");\n+\t}\n+      break;\n+    case PLUS:\n+      if (GET_CODE (XEXP (addr, 0)) == REG\n+\t  || GET_CODE (XEXP (addr, 0)) == SUBREG)\n+\t{\n+\t  /* reg,foo */\n+\t  print_operand (file, XEXP (addr, 1), 0);\n+\t  fprintf (file, \"[\");\n+\t  print_operand (file, XEXP (addr, 0), 0);\n+\t  fprintf (file, \"]\");\n+\t}\n+      else\n+\t{\n+\t  print_operand (file, XEXP (addr, 0), 0);\n+\t  fprintf (file, \"+\");\n+\t  print_operand (file, XEXP (addr, 1), 0);\n+\t}\n+      break;\n+    case SYMBOL_REF:\n+      if (ENCODED_NAME_P (XSTR (addr, 0)))\n+        {\n+          char* name = XSTR (addr, 0);\n+          char* off_name;\n+          char* reg_name;\n+\n+          if (ZDA_NAME_P (name))\n+            {\n+              off_name = \"zdaoff\";\n+              reg_name = \"r0\";\n+            }\n+          else if (SDA_NAME_P (name))\n+            {\n+              off_name = \"sdaoff\";\n+              reg_name = \"gp\";\n+            }\n+          else if (TDA_NAME_P (name))\n+            {\n+              off_name = \"tdaoff\";\n+              reg_name = \"ep\";\n+            }\n+          else\n+            abort();\n+\n+          fprintf (file, \"%s(\", off_name);\n+          output_addr_const (file, addr);\n+          fprintf (file, \")[%s]\", reg_name);\n+        }\n+      else\n+        output_addr_const (file, addr);\n+      break;\n+    case CONST:\n+      if (special_symbolref_operand (addr, VOIDmode))\n+        {\n+          char* name = XSTR (XEXP (XEXP (addr, 0), 0), 0);\n+          char* off_name;\n+          char* reg_name;\n+\n+          if (ZDA_NAME_P (name))\n+            {\n+              off_name = \"zdaoff\";\n+              reg_name = \"r0\";\n+            }\n+          else if (SDA_NAME_P (name))\n+            {\n+              off_name = \"sdaoff\";\n+              reg_name = \"gp\";\n+            }\n+          else if (TDA_NAME_P (name))\n+            {\n+              off_name = \"tdaoff\";\n+              reg_name = \"ep\";\n+            }\n+          else\n+            abort();\n+\n+          fprintf (file, \"%s(\", off_name);\n+          output_addr_const (file, addr);\n+          fprintf (file, \")[%s]\", reg_name);\n+        }\n+      else\n+        output_addr_const (file, addr);\n+      break;\n+    default:\n+      output_addr_const (file, addr);\n+      break;\n+    }\n+}\n+\n+\f\n+/* Return appropriate code to load up a 1, 2, or 4 integer/floating\n+   point value.  */\n+\n+char *\n+output_move_single (operands)\n+     rtx *operands;\n+{\n+  rtx dst = operands[0];\n+  rtx src = operands[1];\n+\n+  if (REG_P (dst))\n+    {\n+      if (REG_P (src))\n+\treturn \"mov %1,%0\";\n+\n+      else if (GET_CODE (src) == CONST_INT)\n+\t{\n+\t  HOST_WIDE_INT value = INTVAL (src);\n+\n+\t  if (CONST_OK_FOR_J (value))\t\t/* signed 5 bit immediate */\n+\t    return \"mov %1,%0\";\n+\n+\t  else if (CONST_OK_FOR_K (value))\t/* signed 16 bit immediate */\n+\t    return \"movea lo(%1),%.,%0\";\n+\n+\t  else if (CONST_OK_FOR_L (value))\t/* upper 16 bits were set */\n+\t    return \"movhi hi(%1),%.,%0\";\n+\n+\t  else\t\t\t\t\t/* random constant */\n+\t    return \"movhi hi(%1),%.,%0\\n\\tmovea lo(%1),%0,%0\";\n+\t}\n+\n+      else if (GET_CODE (src) == CONST_DOUBLE && GET_MODE (src) == SFmode)\n+\t{\n+\t  HOST_WIDE_INT high, low;\n+\n+\t  const_double_split (src, &high, &low);\n+\t  if (CONST_OK_FOR_J (high))\t\t/* signed 5 bit immediate */\n+\t    return \"mov %F1,%0\";\n+\n+\t  else if (CONST_OK_FOR_K (high))\t/* signed 16 bit immediate */\n+\t    return \"movea lo(%F1),%.,%0\";\n+\n+\t  else if (CONST_OK_FOR_L (high))\t/* upper 16 bits were set */\n+\t    return \"movhi hi(%F1),%.,%0\";\n+\n+\t  else\t\t\t\t\t/* random constant */\n+\t    return \"movhi hi(%F1),%.,%0\\n\\tmovea lo(%F1),%0,%0\";\n+\t}\n+\n+      else if (GET_CODE (src) == MEM)\n+\treturn \"%S1ld%W1 %1,%0\";\n+\n+      else if (special_symbolref_operand (src, VOIDmode))\n+\treturn \"movea %O1(%P1),%Q1,%0\";\n+\n+      else if (GET_CODE (src) == LABEL_REF\n+\t       || GET_CODE (src) == SYMBOL_REF\n+\t       || GET_CODE (src) == CONST)\n+\treturn \"movhi hi(%1),%.,%0\\n\\tmovea lo(%1),%0,%0\";\n+\n+      else if (GET_CODE (src) == HIGH)\n+\treturn \"movhi hi(%1),%.,%0\";\n+\n+      else if (GET_CODE (src) == LO_SUM)\n+\t{\n+\t  operands[2] = XEXP (src, 0);\n+\t  operands[3] = XEXP (src, 1);\n+\t  return \"movea lo(%3),%2,%0\";\n+\t}\n+    }\n+\n+  else if (GET_CODE (dst) == MEM)\n+    {\n+      if (REG_P (src))\n+\treturn \"%S0st%W0 %1,%0\";\n+\n+      else if (GET_CODE (src) == CONST_INT && INTVAL (src) == 0)\n+\treturn \"%S0st%W0 %.,%0\";\n+\n+      else if (GET_CODE (src) == CONST_DOUBLE\n+\t       && CONST0_RTX (GET_MODE (dst)) == src)\n+\treturn \"%S0st%W0 %.,%0\";\n+    }\n+\n+  fatal_insn (\"output_move_single:\", gen_rtx (SET, VOIDmode, dst, src));\n+  return \"\";\n+}\n+\n+\f\n+/* Return appropriate code to load up an 8 byte integer or floating point value */\n+\n+char *\n+output_move_double (operands)\n+    rtx *operands;\n+{\n+  enum machine_mode mode = GET_MODE (operands[0]);\n+  rtx dst = operands[0];\n+  rtx src = operands[1];\n+\n+  if (register_operand (dst, mode)\n+      && register_operand (src, mode))\n+    {\n+      if (REGNO (src) + 1 == REGNO (dst))\n+\treturn \"mov %R1,%R0\\n\\tmov %1,%0\";\n+      else\n+\treturn \"mov %1,%0\\n\\tmov %R1,%R0\";\n+    }\n+\n+  /* Storing 0 */\n+  if (GET_CODE (dst) == MEM\n+      && ((GET_CODE (src) == CONST_INT && INTVAL (src) == 0)\n+\t  || (GET_CODE (src) == CONST_DOUBLE && CONST_DOUBLE_OK_FOR_G (src))))\n+    return \"st.w %.,%0\\n\\tst.w %.,%R0\";\n+\n+  if (GET_CODE (src) == CONST_INT || GET_CODE (src) == CONST_DOUBLE)\n+    {\n+      HOST_WIDE_INT high_low[2];\n+      int i;\n+      rtx xop[10];\n+\n+      if (GET_CODE (src) == CONST_DOUBLE)\n+\tconst_double_split (src, &high_low[1], &high_low[0]);\n+      else\n+\t{\n+\t  high_low[0] = INTVAL (src);\n+\t  high_low[1] = (INTVAL (src) >= 0) ? 0 : -1;\n+\t}\n+\n+      for (i = 0; i < 2; i++)\n+\t{\n+\t  xop[0] = gen_rtx (REG, SImode, REGNO (dst)+i);\n+\t  xop[1] = GEN_INT (high_low[i]);\n+\t  output_asm_insn (output_move_single (xop), xop);\n+\t}\n+\n+      return \"\";\n+    }\n+\n+  if (GET_CODE (src) == MEM)\n+    {\n+      int ptrreg = -1;\n+      int dreg = REGNO (dst);\n+      rtx inside = XEXP (src, 0);\n+\n+      if (GET_CODE (inside) == REG)\n+ \tptrreg = REGNO (inside);\n+      else if (GET_CODE (inside) == SUBREG)\n+\tptrreg = REGNO (SUBREG_REG (inside)) + SUBREG_WORD (inside);\n+      else if (GET_CODE (inside) == PLUS)\n+\tptrreg = REGNO (XEXP (inside, 0));\n+      else if (GET_CODE (inside) == LO_SUM)\n+\tptrreg = REGNO (XEXP (inside, 0));\n+\n+      if (dreg == ptrreg)\n+\treturn \"ld.w %R1,%R0\\n\\tld.w %1,%0\";\n+    }\n+\n+  if (GET_CODE (src) == MEM)\n+    return \"ld.w %1,%0\\n\\tld.w %R1,%R0\";\n+  \n+  if (GET_CODE (dst) == MEM)\n+    return \"st.w %1,%0\\n\\tst.w %R1,%R0\";\n+\n+  return \"mov %1,%0\\n\\tmov %R1,%R0\";\n+}\n+\n+\f\n+/* Return true if OP is a valid short EP memory reference */\n+\n+int\n+ep_memory_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  rtx addr, op0, op1;\n+  int max_offset;\n+  int mask;\n+\n+  if (GET_CODE (op) != MEM)\n+    return FALSE;\n+\n+  switch (GET_MODE (op))\n+    {\n+    default:\n+      return FALSE;\n+\n+    case QImode:\n+      max_offset = 128;\n+      mask = 0;\n+      break;\n+\n+    case HImode:\n+      max_offset = 256;\n+      mask = 1;\n+      break;\n+\n+    case SImode:\n+    case SFmode:\n+      max_offset = 256;\n+      mask = 3;\n+      break;\n+    }\n+\n+  addr = XEXP (op, 0);\n+  if (GET_CODE (addr) == CONST)\n+    addr = XEXP (addr, 0);\n+\n+  switch (GET_CODE (addr))\n+    {\n+    default:\n+      break;\n+\n+    case SYMBOL_REF:\n+      return TDA_NAME_P (XSTR (addr, 0));\n+\n+    case REG:\n+      return REGNO (addr) == EP_REGNUM;\n+\n+    case PLUS:\n+      op0 = XEXP (addr, 0);\n+      op1 = XEXP (addr, 1);\n+      if (GET_CODE (op1) == CONST_INT\n+\t  && INTVAL (op1) < max_offset\n+\t  && (INTVAL (op1) & mask) == 0)\n+\t{\n+\t  if (GET_CODE (op0) == REG && REGNO (op0) == EP_REGNUM)\n+\t    return TRUE;\n+\n+\t  if (GET_CODE (op0) == SYMBOL_REF && TDA_NAME_P (XSTR (op0, 0)))\n+\t    return TRUE;\n+\t}\n+      break;\n+    }\n+\n+  return FALSE;\n+}\n+\n+/* Return true if OP is either a register or 0 */\n+\n+int\n+reg_or_0_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return INTVAL (op) == 0;\n+\n+  else if (GET_CODE (op) == CONST_DOUBLE)\n+    return CONST_DOUBLE_OK_FOR_G (op);\n+\n+  else if (GET_CODE (op) == REG)\n+    return TRUE;\n+\n+  else if (GET_CODE (op) == SUBREG)\n+    {\n+      do {\n+\top = SUBREG_REG (op);\n+      } while (GET_CODE (op) == SUBREG);\n+\n+      if (GET_CODE (op) == MEM && !reload_completed)\n+\treturn TRUE;\n+\n+      else if (GET_CODE (op) == REG)\n+\treturn TRUE;\n+    }\n+\n+  return FALSE;\n+}\n+\n+/* Return true if OP is either a register or a signed five bit integer */\n+\n+int\n+reg_or_int5_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return CONST_OK_FOR_J (INTVAL (op));\n+\n+  else if (GET_CODE (op) == REG)\n+    return TRUE;\n+\n+  else if (GET_CODE (op) == SUBREG)\n+    {\n+      do {\n+\top = SUBREG_REG (op);\n+      } while (GET_CODE (op) == SUBREG);\n+\n+      if (GET_CODE (op) == MEM && !reload_completed)\n+\treturn TRUE;\n+\n+      else if (GET_CODE (op) == REG)\n+\treturn TRUE;\n+    }\n+\n+  return FALSE;\n+}\n+\n+/* Return true if OP is a valid call operand.  */\n+\n+int\n+call_address_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  /* Only registers are valid call operands if TARGET_LONG_CALLS.  */\n+  if (TARGET_LONG_CALLS)\n+    return GET_CODE (op) == REG;\n+  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == REG);\n+}\n+\n+int\n+special_symbolref_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    return ENCODED_NAME_P (XSTR (op, 0));\n+\n+  else if (GET_CODE (op) == CONST)\n+    return (GET_CODE (XEXP (op, 0)) == PLUS\n+\t    && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n+\t    && ENCODED_NAME_P (XSTR (XEXP (XEXP (op, 0), 0), 0))\n+\t    && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n+\t    && CONST_OK_FOR_K (INTVAL (XEXP (XEXP (op, 0), 1))));\n+\n+  return FALSE;\n+}\n+\n+int\n+movsi_source_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  /* Some constants, as well as symbolic operands\n+     must be done with HIGH & LO_SUM patterns.  */\n+  if (CONSTANT_P (op)\n+      && GET_CODE (op) != HIGH\n+      && !(GET_CODE (op) == CONST_INT\n+           && (CONST_OK_FOR_J (INTVAL (op))\n+               || CONST_OK_FOR_K (INTVAL (op))\n+               || CONST_OK_FOR_L (INTVAL (op)))))\n+    return special_symbolref_operand (op, mode);\n+  else\n+    return general_operand (op, mode);\n+}\n+\n+int\n+power_of_two_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+\n+  if (exact_log2 (INTVAL (op)) == -1)\n+    return 0;\n+  return 1;\n+}\n+\n+int\n+not_power_of_two_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  unsigned int mask;\n+\n+  if (mode == QImode)\n+    mask = 0xff;\n+  else if (mode == HImode)\n+    mask = 0xffff;\n+  else if (mode == SImode)\n+    mask = 0xffffffff; \n+  else\n+    return 0;\n+\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+\n+  if (exact_log2 (~INTVAL (op) & mask) == -1)\n+    return 0;\n+  return 1;\n+}\n+\n+\f\n+/* Substitute memory references involving a pointer, to use the ep pointer,\n+   taking care to save and preserve the ep.  */\n+\n+static void\n+substitute_ep_register (first_insn, last_insn, uses, regno, p_r1, p_ep)\n+     rtx first_insn;\n+     rtx last_insn;\n+     int uses;\n+     int regno;\n+     rtx *p_r1;\n+     rtx *p_ep;\n+{\n+  rtx reg = gen_rtx (REG, Pmode, regno);\n+  rtx insn;\n+  int i;\n+\n+  if (!*p_r1)\n+    {\n+      regs_ever_live[1] = 1;\n+      *p_r1 = gen_rtx (REG, Pmode, 1);\n+      *p_ep = gen_rtx (REG, Pmode, 30);\n+    }\n+\n+  if (TARGET_DEBUG)\n+    fprintf (stderr, \"Saved %d bytes (%d uses of register %s) in function %s, starting as insn %d, ending at %d\\n\",\n+\t     2 * (uses - 3), uses, reg_names[regno],\n+\t     IDENTIFIER_POINTER (DECL_NAME (current_function_decl)),\n+\t     INSN_UID (first_insn), INSN_UID (last_insn));\n+\n+  if (GET_CODE (first_insn) == NOTE)\n+    first_insn = next_nonnote_insn (first_insn);\n+\n+  last_insn = next_nonnote_insn (last_insn);\n+  for (insn = first_insn; insn && insn != last_insn; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == INSN)\n+\t{\n+\t  rtx pattern = single_set (insn);\n+\n+\t  /* Replace the memory references.  */\n+\t  if (pattern)\n+\t    {\n+\t      rtx *p_mem;\n+\n+\t      if (GET_CODE (SET_DEST (pattern)) == MEM\n+\t\t  && GET_CODE (SET_SRC (pattern)) == MEM)\n+\t\tp_mem = (rtx *)0;\n+\n+\t      else if (GET_CODE (SET_DEST (pattern)) == MEM)\n+\t\tp_mem = &SET_DEST (pattern);\n+\n+\t      else if (GET_CODE (SET_SRC (pattern)) == MEM)\n+\t\tp_mem = &SET_SRC (pattern);\n+\n+\t      else\n+\t\tp_mem = (rtx *)0;\n+\n+\t      if (p_mem)\n+\t\t{\n+\t\t  rtx addr = XEXP (*p_mem, 0);\n+\n+\t\t  if (GET_CODE (addr) == REG && REGNO (addr) == regno)\n+\t\t    *p_mem = change_address (*p_mem, VOIDmode, *p_ep);\n+\n+\t\t  else if (GET_CODE (addr) == PLUS\n+\t\t\t   && GET_CODE (XEXP (addr, 0)) == REG\n+\t\t\t   && REGNO (XEXP (addr, 0)) == regno\n+\t\t\t   && GET_CODE (XEXP (addr, 1)) == CONST_INT\n+\t\t\t   && ((unsigned)INTVAL (XEXP (addr, 1))) < 256\n+\t\t\t   && (GET_MODE (*p_mem) != QImode\n+\t\t\t       || ((unsigned)INTVAL (XEXP (addr, 1))) < 128))\n+\t\t    *p_mem = change_address (*p_mem, VOIDmode,\n+\t\t\t\t\t     gen_rtx (PLUS, Pmode,\n+\t\t\t\t\t\t      *p_ep, XEXP (addr, 1)));\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  /* Optimize back to back cases of ep <- r1 & r1 <- ep.  */\n+  insn = prev_nonnote_insn (first_insn);\n+  if (insn && GET_CODE (insn) == INSN\n+      && GET_CODE (PATTERN (insn)) == SET\n+      && SET_DEST (PATTERN (insn)) == *p_ep\n+      && SET_SRC (PATTERN (insn)) == *p_r1)\n+    delete_insn (insn);\n+  else\n+    emit_insn_before (gen_rtx (SET, Pmode, *p_r1, *p_ep), first_insn);\n+\n+  emit_insn_before (gen_rtx (SET, Pmode, *p_ep, reg), first_insn);\n+  emit_insn_before (gen_rtx (SET, Pmode, *p_ep, *p_r1), last_insn);\n+}\n+\n+\f\n+/* In rare cases, correct code generation requires extra machine\n+   dependent processing between the second jump optimization pass and\n+   delayed branch scheduling.  On those machines, define this macro\n+   as a C statement to act on the code starting at INSN.\n+\n+   On the 850, we use it to implement the -mep mode to copy heavily used\n+   pointers to ep to use the implicit addressing */\n+\n+void v850_reorg (start_insn)\n+     rtx start_insn;\n+{\n+  struct {\n+    int uses;\n+    rtx first_insn;\n+    rtx last_insn;\n+  } regs[FIRST_PSEUDO_REGISTER];\n+\n+  int i;\n+  int use_ep = FALSE;\n+  rtx r1 = NULL_RTX;\n+  rtx ep = NULL_RTX;\n+  rtx insn;\n+  rtx pattern;\n+\n+  /* If not ep mode, just return now */\n+  if (!TARGET_EP)\n+    return;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      regs[i].uses = 0;\n+      regs[i].first_insn = NULL_RTX;\n+      regs[i].last_insn = NULL_RTX;\n+    }\n+\n+  for (insn = start_insn; insn != NULL_RTX; insn = NEXT_INSN (insn))\n+    {\n+      switch (GET_CODE (insn))\n+\t{\n+\t  /* End of basic block */\n+\tdefault:\n+\t  if (!use_ep)\n+\t    {\n+\t      int max_uses = -1;\n+\t      int max_regno = -1;\n+\n+\t      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t\t{\n+\t\t  if (max_uses < regs[i].uses)\n+\t\t    {\n+\t\t      max_uses = regs[i].uses;\n+\t\t      max_regno = i;\n+\t\t    }\n+\t\t}\n+\n+\t      if (max_uses > 3)\n+\t\tsubstitute_ep_register (regs[max_regno].first_insn,\n+\t\t\t\t\tregs[max_regno].last_insn,\n+\t\t\t\t\tmax_uses, max_regno, &r1, &ep);\n+\t    }\n+\n+\t  use_ep = FALSE;\n+\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t    {\n+\t      regs[i].uses = 0;\n+\t      regs[i].first_insn = NULL_RTX;\n+\t      regs[i].last_insn = NULL_RTX;\n+\t    }\n+\t  break;\n+\n+\tcase NOTE:\n+\t  break;\n+\n+\tcase INSN:\n+\t  pattern = single_set (insn);\n+\n+\t  /* See if there are any memory references we can shorten */\n+\t  if (pattern)\n+\t    {\n+\t      rtx src = SET_SRC (pattern);\n+\t      rtx dest = SET_DEST (pattern);\n+\t      rtx mem;\n+\n+\t      if (GET_CODE (dest) == MEM && GET_CODE (src) == MEM)\n+\t\tmem = NULL_RTX;\n+\n+\t      else if (GET_CODE (dest) == MEM)\n+\t\tmem = dest;\n+\n+\t      else if (GET_CODE (src) == MEM)\n+\t\tmem = src;\n+\n+\t      else\n+\t\tmem = NULL_RTX;\n+\n+\t      if (mem && ep_memory_operand (mem, GET_MODE (mem)))\n+\t\tuse_ep = TRUE;\n+\n+\t      else if (!use_ep && mem\n+\t\t       && GET_MODE_SIZE (GET_MODE (mem)) <= UNITS_PER_WORD)\n+\t\t{\n+\t\t  rtx addr = XEXP (mem, 0);\n+\t\t  int regno = -1;\n+\t\t  int short_p;\n+\n+\t\t  if (GET_CODE (addr) == REG)\n+\t\t    {\n+\t\t      short_p = TRUE;\n+\t\t      regno = REGNO (addr);\n+\t\t    }\n+\n+\t\t  else if (GET_CODE (addr) == PLUS\n+\t\t\t   && GET_CODE (XEXP (addr, 0)) == REG\n+\t\t\t   && GET_CODE (XEXP (addr, 1)) == CONST_INT\n+\t\t\t   && ((unsigned)INTVAL (XEXP (addr, 1))) < 256\n+\t\t\t   && (GET_MODE (mem) != QImode\n+\t\t\t       || ((unsigned)INTVAL (XEXP (addr, 1))) < 128))\n+\t\t    {\n+\t\t      short_p = TRUE;\n+\t\t      regno = REGNO (XEXP (addr, 0));\n+\t\t    }\n+\n+\t\t  else\n+\t\t    short_p = FALSE;\n+\n+\t\t  if (short_p)\n+\t\t    {\n+\t\t      regs[regno].uses++;\n+\t\t      regs[regno].last_insn = insn;\n+\t\t      if (!regs[regno].first_insn)\n+\t\t\tregs[regno].first_insn = insn;\n+\t\t    }\n+\t\t}\n+\n+\t      /* Loading up a register in the basic block zaps any savings\n+\t\t for the register */\n+\t      if (GET_CODE (dest) == REG || GET_CODE (dest) == SUBREG)\n+\t\t{\n+\t\t  enum machine_mode mode = GET_MODE (dest);\n+\t\t  int word = 0;\n+\t\t  int regno;\n+\t\t  int endregno;\n+\n+\t\t  while (GET_CODE (dest) == SUBREG)\n+\t\t    {\n+\t\t      word = SUBREG_WORD (dest);\n+\t\t      dest = SUBREG_REG (dest);\n+\t\t    }\n+\n+\t\t  regno = REGNO (dest) + word;\n+\t\t  endregno = regno + HARD_REGNO_NREGS (regno, mode);\n+\n+\t\t  if (!use_ep)\n+\t\t    {\n+\t\t      /* See if we can use the pointer before this\n+\t\t\t modification.  */\n+\t\t      int max_uses = -1;\n+\t\t      int max_regno = -1;\n+\n+\t\t      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t\t\t{\n+\t\t\t  if (max_uses < regs[i].uses)\n+\t\t\t    {\n+\t\t\t      max_uses = regs[i].uses;\n+\t\t\t      max_regno = i;\n+\t\t\t    }\n+\t\t\t}\n+\n+\t\t      if (max_uses > 3\n+\t\t\t  && max_regno >= regno\n+\t\t\t  && max_regno < endregno)\n+\t\t\t{\n+\t\t\t  substitute_ep_register (regs[max_regno].first_insn,\n+\t\t\t\t\t\t  regs[max_regno].last_insn,\n+\t\t\t\t\t\t  max_uses, max_regno, &r1, &ep);\n+\n+\t\t\t  /* Since we made a substitution, zap all remembered\n+\t\t\t     registers.  */\n+\t\t\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t\t\t    {\n+\t\t\t      regs[i].uses = 0;\n+\t\t\t      regs[i].first_insn = NULL_RTX;\n+\t\t\t      regs[i].last_insn = NULL_RTX;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  for (i = regno; i < endregno; i++)\n+\t\t    {\n+\t\t      regs[i].uses = 0;\n+\t\t      regs[i].first_insn = NULL_RTX;\n+\t\t      regs[i].last_insn = NULL_RTX;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+\f\n+/* # of registers saved by the interrupt handler.  */\n+#define INTERRUPT_FIXED_NUM 4\n+\n+/* # of bytes for registers saved by the interrupt handler.  */\n+#define INTERRUPT_FIXED_SAVE_SIZE (4 * INTERRUPT_FIXED_NUM)\n+\n+/* # of registers saved in register parameter area.  */\n+#define INTERRUPT_REGPARM_NUM 4\n+/* # of words saved for other registers.  */\n+#define INTERRUPT_ALL_SAVE_NUM \\\n+  (30 - INTERRUPT_FIXED_NUM + INTERRUPT_REGPARM_NUM)\n+\n+#define INTERRUPT_ALL_SAVE_SIZE (4 * INTERRUPT_ALL_SAVE_NUM)\n+\n+int\n+compute_register_save_size (p_reg_saved)\n+     long *p_reg_saved;\n+{\n+  int size = 0;\n+  int i;\n+  int interrupt_handler = v850_interrupt_function_p (current_function_decl);\n+  int call_p = regs_ever_live[31];\n+  long reg_saved = 0;\n+\n+  /* Count the return pointer if we need to save it.  */\n+  if (profile_flag && !call_p)\n+    regs_ever_live[31] = call_p = 1;\n+ \n+  /* Count space for the register saves.  */\n+  if (interrupt_handler)\n+    {\n+      for (i = 0; i <= 31; i++)\n+\tswitch (i)\n+\t  {\n+\t  default:\n+\t    if (regs_ever_live[i] || call_p)\n+\t      {\n+\t\tsize += 4;\n+\t\treg_saved |= 1L << i;\n+\t      }\n+\t    break;\n+\n+\t    /* We don't save/restore r0 or the stack pointer */\n+\t  case 0:\n+\t  case STACK_POINTER_REGNUM:\n+\t    break;\n+\n+\t    /* For registers with fixed use, we save them, set them to the\n+\t       appropriate value, and then restore them.\n+\t       These registers are handled specially, so don't list them\n+\t       on the list of registers to save in the prologue.  */\n+\t  case 1:\t\t/* temp used to hold ep */\n+\t  case 5:\t\t/* gp */\n+\t  case 10:\t\t/* temp used to call interrupt save/restore */\n+\t  case EP_REGNUM:\t/* ep */\n+\t    size += 4;\n+\t    break;\n+\t  }\n+    }\n+\n+  else\n+    for (i = 0; i <= 31; i++)\n+      if (regs_ever_live[i] && ((! call_used_regs[i]) || i == 31))\n+\t{\n+\t  size += 4;\n+\t  reg_saved |= 1L << i;\n+\t}\n+\n+  if (p_reg_saved)\n+    *p_reg_saved = reg_saved;\n+\n+  return size;\n+}\n+\n+int\n+compute_frame_size (size, p_reg_saved)\n+     int size;\n+     long *p_reg_saved;\n+{\n+  extern int current_function_outgoing_args_size;\n+\n+  return (size\n+\t  + compute_register_save_size (p_reg_saved)\n+\t  + current_function_outgoing_args_size);\n+}\n+\n+\f\n+void\n+expand_prologue ()\n+{\n+  unsigned int i;\n+  int offset;\n+  unsigned int size = get_frame_size ();\n+  unsigned int actual_fsize;\n+  unsigned int init_stack_alloc = 0;\n+  rtx save_regs[32];\n+  rtx save_all;\n+  int num_save;\n+  int default_stack;\n+  int code;\n+  int interrupt_handler = v850_interrupt_function_p (current_function_decl);\n+  long reg_saved = 0;\n+\n+  actual_fsize = compute_frame_size (size, &reg_saved);\n+\n+  /* Save/setup global registers for interrupt functions right now */\n+  if (interrupt_handler)\n+    {\n+      emit_insn (gen_save_interrupt ());\n+      actual_fsize -= INTERRUPT_FIXED_SAVE_SIZE;\n+      if (((1L << 31) & reg_saved) != 0)\n+\tactual_fsize -= INTERRUPT_ALL_SAVE_SIZE;\n+    }\n+\n+  /* Save arg registers to the stack if necessary.  */\n+  else if (current_function_anonymous_args)\n+    {\n+      if (TARGET_PROLOG_FUNCTION)\n+\temit_insn (gen_save_r6_r9 ());\n+      else\n+\t{\n+\t  offset = 0;\n+\t  for (i = 6; i < 10; i++)\n+\t    {\n+\t      emit_move_insn (gen_rtx (MEM, SImode,\n+\t\t\t\t       plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t      offset)),\n+\t\t\t      gen_rtx (REG, SImode, i));\n+\t      offset += 4;\n+\t    }\n+\t}\n+    }\n+\n+  /* Identify all of the saved registers */\n+  num_save = 0;\n+  default_stack = 0;\n+  for (i = 1; i < 31; i++)\n+    {\n+      if (((1L << i) & reg_saved) != 0)\n+\tsave_regs[num_save++] = gen_rtx (REG, Pmode, i);\n+    }\n+\n+  /* If the return pointer is saved, the helper functions also allocate\n+     16 bytes of stack for arguments to be saved in.  */\n+  if (((1L << 31) & reg_saved) != 0)\n+    {\n+      save_regs[num_save++] = gen_rtx (REG, Pmode, 31);\n+      default_stack = 16;\n+    }\n+\n+  /* See if we have an insn that allocates stack space and saves the particular\n+     registers we want to.  */\n+  save_all = NULL_RTX;\n+  if (TARGET_PROLOG_FUNCTION && num_save > 0 && actual_fsize >= default_stack)\n+    {\n+      int alloc_stack = (4 * num_save) + default_stack;\n+      int unalloc_stack = actual_fsize - alloc_stack;\n+      int save_func_len = 4;\n+      int save_normal_len;\n+\n+      if (unalloc_stack)\n+\tsave_func_len += CONST_OK_FOR_J (unalloc_stack) ? 2 : 4;\n+\n+      /* see if we would have used ep to save the stack */\n+      if (TARGET_EP && num_save > 3 && (unsigned)actual_fsize < 255)\n+\tsave_normal_len = (3 * 2) + (2 * num_save);\n+      else\n+\tsave_normal_len = 4 * num_save;\n+\n+      save_normal_len += CONST_OK_FOR_J (actual_fsize) ? 2 : 4;\n+\n+      /* Don't bother checking if we don't actually save any space.\n+\t This happens for instance if one register is saved and additional\n+\t stack space is allocated.  */\n+      if (save_func_len < save_normal_len)\n+\t{\n+\t  save_all = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (num_save + 2));\n+\t  XVECEXP (save_all, 0, 0) = gen_rtx (SET, VOIDmode,\n+\t\t\t\t\t      stack_pointer_rtx,\n+\t\t\t\t\t      gen_rtx (PLUS, Pmode,\n+\t\t\t\t\t\t       stack_pointer_rtx,\n+\t\t\t\t\t\t       GEN_INT (-alloc_stack)));\n+\n+\t  XVECEXP (save_all, 0, num_save+1)\n+\t    = gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, Pmode, 10));\n+\n+\t  offset = - default_stack;\n+\t  for (i = 0; i < num_save; i++)\n+\t    {\n+\t      XVECEXP (save_all, 0, i+1)\n+\t\t= gen_rtx (SET, VOIDmode,\n+\t\t\t   gen_rtx (MEM, Pmode,\n+\t\t\t\t    plus_constant (stack_pointer_rtx, offset)),\n+\t\t\t\t    save_regs[i]);\n+\t      offset -= 4;\n+\t    }\n+\n+\t  code = recog (save_all, NULL_RTX, NULL_PTR);\n+\t  if (code >= 0)\n+\t    {\n+\t      rtx insn = emit_insn (save_all);\n+\t      INSN_CODE (insn) = code;\n+\t      actual_fsize -= alloc_stack;\n+\n+\t      if (TARGET_DEBUG)\n+\t\tfprintf (stderr, \"Saved %d bytes via prologue function (%d vs. %d) for function %s\\n\",\n+\t\t\t save_normal_len - save_func_len,\n+\t\t\t save_normal_len, save_func_len,\n+\t\t\t IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));\n+\t    }\n+\t  else\n+\t    save_all = NULL_RTX;\n+\t}\n+    }\n+\n+  /* If no prolog save function is available, store the registers the old fashioned\n+     way (one by one). */\n+  if (!save_all)\n+    {\n+      /* Special case interrupt functions that save all registers for a call.  */\n+      if (interrupt_handler && ((1L << 31) & reg_saved) != 0)\n+\temit_insn (gen_save_all_interrupt ());\n+\n+      else\n+\t{\n+\t  /* If the stack is too big, allocate it in chunks so we can do the\n+\t     register saves.  We use the register save size so we use the ep\n+\t     register.  */\n+\t  if (actual_fsize && !CONST_OK_FOR_K (-actual_fsize))\n+\t    init_stack_alloc = compute_register_save_size (NULL);\n+\t  else\n+\t    init_stack_alloc = actual_fsize;\n+\n+\t  /* Save registers at the beginning of the stack frame */\n+\t  offset = init_stack_alloc - 4;\n+\n+\t  if (init_stack_alloc)\n+\t    emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t   GEN_INT (-init_stack_alloc)));\n+\n+\t  /* Save the return pointer first.  */\n+\t  if (num_save > 0 && REGNO (save_regs[num_save-1]) == 31)\n+\t    {\n+\t      emit_move_insn (gen_rtx (MEM, SImode,\n+\t\t\t\t       plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t      offset)),\n+\t\t\t      save_regs[--num_save]);\n+\t      offset -= 4;\n+\t    }\n+\n+\t  for (i = 0; i < num_save; i++)\n+\t    {\n+\t      emit_move_insn (gen_rtx (MEM, SImode,\n+\t\t\t\t       plus_constant (stack_pointer_rtx,\n+\t\t\t\t       offset)),\n+\t\t\t      save_regs[i]);\n+\t      offset -= 4;\n+\t    }\n+\t}\n+    }\n+\n+  /* Allocate the rest of the stack that was not allocated above (either it is\n+     > 32K or we just called a function to save the registers and needed more\n+     stack.  */\n+  if (actual_fsize > init_stack_alloc)\n+    {\n+      int diff = actual_fsize - init_stack_alloc;\n+      if (CONST_OK_FOR_K (diff))\n+\temit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t       stack_pointer_rtx,\n+\t\t\t       GEN_INT (-diff)));\n+      else\n+\t{\n+\t  rtx reg = gen_rtx (REG, Pmode, 12);\n+\t  emit_move_insn (reg, GEN_INT (-diff));\n+\t  emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, reg));\n+\t}\n+    }\n+\n+  /* If we need a frame pointer, set it up now.  */\n+  if (frame_pointer_needed)\n+    emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n+}\n+\f\n+\n+void\n+expand_epilogue ()\n+{\n+  unsigned int i;\n+  int offset;\n+  unsigned int size = get_frame_size ();\n+  long reg_saved = 0;\n+  unsigned int actual_fsize = compute_frame_size (size, &reg_saved);\n+  unsigned int init_stack_free = 0;\n+  rtx restore_regs[32];\n+  rtx restore_all;\n+  int num_restore;\n+  int default_stack;\n+  int code;\n+  int interrupt_handler = v850_interrupt_function_p (current_function_decl);\n+\n+  /* Eliminate the initial stack stored by interrupt functions.  */\n+  if (interrupt_handler)\n+    {\n+      actual_fsize -= INTERRUPT_FIXED_SAVE_SIZE;\n+      if (((1L << 31) & reg_saved) != 0)\n+\tactual_fsize -= INTERRUPT_ALL_SAVE_SIZE;\n+    }\n+\n+  /* Cut off any dynamic stack created.  */\n+  if (frame_pointer_needed)\n+    emit_move_insn (stack_pointer_rtx, hard_frame_pointer_rtx);\n+\n+  /* Identify all of the saved registers */\n+  num_restore = 0;\n+  default_stack = 0;\n+  for (i = 1; i < 31; i++)\n+    {\n+      if (((1L << i) & reg_saved) != 0)\n+\trestore_regs[num_restore++] = gen_rtx (REG, Pmode, i);\n+    }\n+\n+  /* If the return pointer is saved, the helper functions also allocate\n+     16 bytes of stack for arguments to be saved in.  */\n+  if (((1L << 31) & reg_saved) != 0)\n+    {\n+      restore_regs[num_restore++] = gen_rtx (REG, Pmode, 31);\n+      default_stack = 16;\n+    }\n+\n+  /* See if we have an insn that restores the particular registers we\n+     want to.  */\n+  restore_all = NULL_RTX;\n+  if (TARGET_PROLOG_FUNCTION && num_restore > 0 && actual_fsize >= default_stack\n+      && !interrupt_handler)\n+    {\n+      int alloc_stack = (4 * num_restore) + default_stack;\n+      int unalloc_stack = actual_fsize - alloc_stack;\n+      int restore_func_len = 4;\n+      int restore_normal_len;\n+\n+      if (unalloc_stack)\n+\trestore_func_len += CONST_OK_FOR_J (unalloc_stack) ? 2 : 4;\n+\n+      /* see if we would have used ep to restore the registers */\n+      if (TARGET_EP && num_restore > 3 && (unsigned)actual_fsize < 255)\n+\trestore_normal_len = (3 * 2) + (2 * num_restore);\n+      else\n+\trestore_normal_len = 4 * num_restore;\n+\n+      restore_normal_len += (CONST_OK_FOR_J (actual_fsize) ? 2 : 4) + 2;\n+\n+      /* Don't bother checking if we don't actually save any space.  */\n+      if (restore_func_len < restore_normal_len)\n+\t{\n+\t  restore_all = gen_rtx (PARALLEL, VOIDmode,\n+\t\t\t\t rtvec_alloc (num_restore + 2));\n+\t  XVECEXP (restore_all, 0, 0) = gen_rtx (RETURN, VOIDmode);\n+\t  XVECEXP (restore_all, 0, 1)\n+\t    = gen_rtx (SET, VOIDmode, stack_pointer_rtx,\n+\t\t       gen_rtx (PLUS, Pmode,\n+\t\t\t\tstack_pointer_rtx,\n+\t\t\t\tGEN_INT (alloc_stack)));\n+\n+\t  offset = alloc_stack - 4;\n+\t  for (i = 0; i < num_restore; i++)\n+\t    {\n+\t      XVECEXP (restore_all, 0, i+2)\n+\t\t= gen_rtx (SET, VOIDmode,\n+\t\t\t   restore_regs[i],\n+\t\t\t   gen_rtx (MEM, Pmode,\n+\t\t\t\t    plus_constant (stack_pointer_rtx, offset)));\n+\t      offset -= 4;\n+\t    }\n+\n+\t  code = recog (restore_all, NULL_RTX, NULL_PTR);\n+\t  if (code >= 0)\n+\t    {\n+\t      rtx insn;\n+\n+\t      actual_fsize -= alloc_stack;\n+\t      if (actual_fsize)\n+\t\t{\n+\t\t  if (CONST_OK_FOR_K (actual_fsize))\n+\t\t    emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t\t   GEN_INT (actual_fsize)));\n+\t\t  else\n+\t\t    {\n+\t\t      rtx reg = gen_rtx (REG, Pmode, 12);\n+\t\t      emit_move_insn (reg, GEN_INT (actual_fsize));\n+\t\t      emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t\t     stack_pointer_rtx,\n+\t\t\t\t\t     reg));\n+\t\t    }\n+\t\t}\n+\n+\t      insn = emit_jump_insn (restore_all);\n+\t      INSN_CODE (insn) = code;\n+\n+\t      if (TARGET_DEBUG)\n+\t\tfprintf (stderr, \"Saved %d bytes via epilogue function (%d vs. %d) in function %s\\n\",\n+\t\t\t restore_normal_len - restore_func_len,\n+\t\t\t restore_normal_len, restore_func_len,\n+\t\t\t IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));\n+\t    }\n+\t  else\n+\t    restore_all = NULL_RTX;\n+\t}\n+    }\n+\n+  /* If no epilog save function is available, restore the registers the\n+     old fashioned way (one by one). */\n+  if (!restore_all)\n+    {\n+      /* If the stack is large, we need to cut it down in 2 pieces.  */\n+      if (actual_fsize && !CONST_OK_FOR_K (-actual_fsize))\n+\tinit_stack_free = 4 * num_restore;\n+      else\n+\tinit_stack_free = actual_fsize;\n+\n+      /* Deallocate the rest of the stack if it is > 32K or if extra stack\n+\t was allocated for an interrupt handler that makes a call.  */\n+      if (actual_fsize > init_stack_free || (interrupt_handler && actual_fsize))\n+\t{\n+\t  int diff = actual_fsize - ((interrupt_handler) ? 0 : init_stack_free);\n+\t  if (CONST_OK_FOR_K (diff))\n+\t    emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t   GEN_INT (diff)));\n+\t  else\n+\t    {\n+\t      rtx reg = gen_rtx (REG, Pmode, 12);\n+\t      emit_move_insn (reg, GEN_INT (diff));\n+\t      emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t     stack_pointer_rtx,\n+\t\t\t\t     reg));\n+\t    }\n+\t}\n+\n+      /* Special case interrupt functions that save all registers\n+\t for a call.  */\n+      if (interrupt_handler && ((1L << 31) & reg_saved) != 0)\n+\temit_insn (gen_restore_all_interrupt ());\n+      else\n+\t{\n+\t  /* Restore registers from the beginning of the stack frame */\n+\t  offset = init_stack_free - 4;\n+\n+\t  /* Restore the return pointer first.  */\n+\t  if (num_restore > 0 && REGNO (restore_regs[num_restore-1]) == 31)\n+\t    {\n+\t      emit_move_insn (restore_regs[--num_restore],\n+\t\t\t      gen_rtx (MEM, SImode,\n+\t\t\t\t       plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t      offset)));\n+\t      offset -= 4;\n+\t    }\n+\n+\t  for (i = 0; i < num_restore; i++)\n+\t    {\n+\t      emit_move_insn (restore_regs[i],\n+\t\t\t      gen_rtx (MEM, SImode,\n+\t\t\t\t       plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t      offset)));\n+\n+\t      offset -= 4;\n+\t    }\n+\n+\t  /* Cut back the remainder of the stack.  */\n+\t  if (init_stack_free)\n+\t    emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t   GEN_INT (init_stack_free)));\n+\t}\n+\n+      /* And return or use reti for interrupt handlers.  */\n+      if (interrupt_handler)\n+\temit_jump_insn (gen_restore_interrupt ());\n+      else if (actual_fsize)\n+\temit_jump_insn (gen_return_internal ());\n+      else\n+\temit_jump_insn (gen_return ());\n+    }\n+\n+  current_function_anonymous_args = 0;\n+  v850_interrupt_cache_p = FALSE;\n+  v850_interrupt_p = FALSE;\n+}\n+\n+\f\n+/* Update the condition code from the insn.  */\n+\n+void\n+notice_update_cc (body, insn)\n+     rtx body;\n+     rtx insn;\n+{\n+  switch (get_attr_cc (insn))\n+    {\n+    case CC_NONE:\n+      /* Insn does not affect CC at all.  */\n+      break;\n+\n+    case CC_NONE_0HIT:\n+      /* Insn does not change CC, but the 0'th operand has been changed.  */\n+      if (cc_status.value1 != 0\n+\t  && reg_overlap_mentioned_p (recog_operand[0], cc_status.value1))\n+\tcc_status.value1 = 0;\n+      break;\n+\n+    case CC_SET_ZN:\n+      /* Insn sets the Z,N flags of CC to recog_operand[0].\n+\t V,C is in an unusable state.  */\n+      CC_STATUS_INIT;\n+      cc_status.flags |= CC_OVERFLOW_UNUSABLE | CC_NO_CARRY;\n+      cc_status.value1 = recog_operand[0];\n+      break;\n+\n+    case CC_SET_ZNV:\n+      /* Insn sets the Z,N,V flags of CC to recog_operand[0].\n+\t C is in an unusable state.  */\n+      CC_STATUS_INIT;\n+      cc_status.flags |= CC_NO_CARRY;\n+      cc_status.value1 = recog_operand[0];\n+      break;\n+\n+    case CC_COMPARE:\n+      /* The insn is a compare instruction.  */\n+      CC_STATUS_INIT;\n+      cc_status.value1 = SET_SRC (body);\n+      break;\n+\n+    case CC_CLOBBER:\n+      /* Insn doesn't leave CC in a usable state.  */\n+      CC_STATUS_INIT;\n+      break;\n+    }\n+}\n+\n+\f\n+/* Return nonzero if ATTR is a valid attribute for DECL.\n+   ATTRIBUTES are any existing attributes and ARGS are the arguments\n+   supplied with ATTR.\n+\n+   Supported attributes:\n+\n+   interrupt_handler or interrupt: output a prologue and epilogue suitable\n+   for an interrupt handler.  */\n+\n+int\n+v850_valid_machine_decl_attribute (decl, attributes, attr, args)\n+     tree decl;\n+     tree attributes;\n+     tree attr;\n+     tree args;\n+{\n+  if (args != NULL_TREE)\n+    return 0;\n+\n+  if (is_attribute_p (\"interrupt_handler\", attr)\n+      || is_attribute_p (\"interrupt\", attr))\n+    return TREE_CODE (decl) == FUNCTION_DECL;\n+\n+  return 0;\n+}\n+\n+\f\n+/* Return nonzero if FUNC is an interrupt function as specified\n+   by the \"interrupt\" attribute.  */\n+\n+int\n+v850_interrupt_function_p (func)\n+     tree func;\n+{\n+  tree a;\n+  int ret = 0;\n+\n+  if (v850_interrupt_cache_p)\n+    return v850_interrupt_p;\n+\n+  if (TREE_CODE (func) != FUNCTION_DECL)\n+    return 0;\n+\n+  a = lookup_attribute (\"interrupt_handler\", DECL_MACHINE_ATTRIBUTES (func));\n+  if (a != NULL_TREE)\n+    ret = 1;\n+\n+  else\n+    {\n+      a = lookup_attribute (\"interrupt\", DECL_MACHINE_ATTRIBUTES (func));\n+      ret = a != NULL_TREE;\n+    }\n+\n+  /* Its not safe to trust global variables until after function inlining has\n+     been done.  */\n+  if (reload_completed | reload_in_progress)\n+    v850_interrupt_p = ret;\n+\n+  return ret;\n+}\n+\n+\f\n+extern struct obstack *saveable_obstack;\n+\n+v850_encode_data_area (decl)\n+     tree decl;\n+{\n+  char *str = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n+  int len = strlen (str);\n+  char *newstr;\n+\n+  /* In the Cygnus sources we actually do something; this is just\n+     here to make merges easier.  */\n+  return;\n+}"}, {"sha": "2a05aef749b5540f40467870ed6db23cffecd0b5", "filename": "gcc/config/v850/v850.h", "status": "added", "additions": 1406, "deletions": 0, "changes": 1406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae180d84fc7bb97b09fb67a1e478288d748e41fb/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae180d84fc7bb97b09fb67a1e478288d748e41fb/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=ae180d84fc7bb97b09fb67a1e478288d748e41fb", "patch": "@@ -0,0 +1,1406 @@\n+/* CYGNUS LOCAL entire file/law */\n+/* Definitions of target machine for GNU compiler. \n+   NEC V850 series\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Jeff Law (law@cygnus.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"svr4.h\"\n+\n+#undef ASM_SPEC\n+#undef ASM_FINAL_SPEC\n+#undef LIB_SPEC\n+#undef ENDFILE_SPEC\n+#undef LINK_SPEC\n+#undef STARTFILE_SPEC\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-D__v850__ -D__v851__ -D__v850\"\n+\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+extern int target_flags;\n+\n+/* Target flags bits, see below for an explanation of the bits.  */\n+#define MASK_GHS\t\t0x00000001\n+#define MASK_LONG_CALLS\t\t0x00000002\n+#define MASK_EP\t\t\t0x00000004\n+#define MASK_PROLOG_FUNCTION\t0x00000008\n+#define MASK_DEBUG\t\t0x40000000\n+\n+/* Macros used in the machine description to test the flags.  */\n+\n+/* The GHS calling convention support doesn't really work,\n+   mostly due to a lack of documentation.  Outstanding issues:\n+\n+     * How do varargs & stdarg really work.  How to they handle\n+     passing structures (if at all).\n+\n+     * Doubles are normally 4 byte aligned, except in argument\n+     lists where they are 8 byte aligned.  Is the alignment\n+     in the argument list based on the first parameter,\n+     first stack parameter, etc etc.\n+\n+     * Passing/returning of large structures probably isn't the same\n+     as GHS.  We don't have enough documentation on their conventions\n+     to be compatable.\n+\n+     * Tests of SETUP_INCOMING_VARARGS need to be made runtime checks\n+     since it depends on TARGET_GHS.  */\n+#define TARGET_GHS (target_flags & MASK_GHS)\n+ \n+/* Don't do PC-relative calls, instead load the address of the target\n+   function into a register and perform a register indirect call.  */\n+#define TARGET_LONG_CALLS (target_flags & MASK_LONG_CALLS)\n+\n+/* Whether to optimize space by using ep (r30) for pointers with small offsets\n+   in basic blocks.  */\n+#define TARGET_EP (target_flags & MASK_EP)\n+\n+/* Whether to call out-of-line functions to save registers or not.  */\n+#define TARGET_PROLOG_FUNCTION (target_flags & MASK_PROLOG_FUNCTION)\n+\n+/* General debug flag */\n+#define TARGET_DEBUG (target_flags & MASK_DEBUG)\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES\t\t\t\t\t\t\t\\\n+  {{ \"ghs\",\t\t\t MASK_GHS },\t\t\t\t\\\n+   { \"no-ghs\",\t\t\t-MASK_GHS },\t\t\t\t\\\n+   { \"long-calls\",\t\t MASK_LONG_CALLS },\t\t\t\\\n+   { \"no-long-calls\",\t\t-MASK_LONG_CALLS },\t\t\t\\\n+   { \"ep\",\t\t\t MASK_EP },\t\t\t\t\\\n+   { \"no-ep\",\t\t\t-MASK_EP },\t\t\t\t\\\n+   { \"prolog-function\",\t\t MASK_PROLOG_FUNCTION },\t\t\\\n+   { \"no-prolog-function\",\t-MASK_PROLOG_FUNCTION },\t\t\\\n+   { \"space\",\t\t\t MASK_EP | MASK_PROLOG_FUNCTION },\t\\\n+   { \"debug\",\t\t\t MASK_DEBUG },\t\t\t\t\\\n+   { \"\",\t\t\t TARGET_DEFAULT}}\n+\n+#ifndef TARGET_DEFAULT\n+#define TARGET_DEFAULT 0\n+#endif\n+\n+/* Information about the various small memory areas.  */\n+struct small_memory_info {\n+  char *name;\n+  char *value;\n+  long max;\n+  long physical_max;\n+};\n+\n+enum small_memory_type {\n+  /* tiny data area, using EP as base register */\n+  SMALL_MEMORY_TDA = 0,\n+  /* small data area using dp as base register */\n+  SMALL_MEMORY_SDA,\n+  /* zero data area using r0 as base register */\n+  SMALL_MEMORY_ZDA,\n+  SMALL_MEMORY_max\n+};\n+\n+extern struct small_memory_info small_memory[(int)SMALL_MEMORY_max];\n+\n+/* This macro is similar to `TARGET_SWITCHES' but defines names of\n+   command options that have values.  Its definition is an\n+   initializer with a subgrouping for each command option.\n+\n+   Each subgrouping contains a string constant, that defines the\n+   fixed part of the option name, and the address of a variable.  The\n+   variable, type `char *', is set to the variable part of the given\n+   option if the fixed part matches.  The actual option name is made\n+   by appending `-m' to the specified name.\n+\n+   Here is an example which defines `-mshort-data-NUMBER'.  If the\n+   given option is `-mshort-data-512', the variable `m88k_short_data'\n+   will be set to the string `\"512\"'.\n+\n+          extern char *m88k_short_data;\n+          #define TARGET_OPTIONS \\\n+           { { \"short-data-\", &m88k_short_data } } */\n+\n+#define TARGET_OPTIONS\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  { \"tda=\",\t&small_memory[ (int)SMALL_MEMORY_TDA ].value },\t\t\\\n+  { \"tda-\",\t&small_memory[ (int)SMALL_MEMORY_TDA ].value },\t\t\\\n+  { \"sda=\",\t&small_memory[ (int)SMALL_MEMORY_SDA ].value },\t\t\\\n+  { \"sda-\",\t&small_memory[ (int)SMALL_MEMORY_SDA ].value },\t\t\\\n+  { \"zda=\",\t&small_memory[ (int)SMALL_MEMORY_ZDA ].value },\t\t\\\n+  { \"zda-\",\t&small_memory[ (int)SMALL_MEMORY_ZDA ].value },\t\t\\\n+}\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+\n+#define TARGET_VERSION fprintf (stderr, \" (NEC V850)\");\n+\n+/* Sometimes certain combinations of command options do not make\n+   sense on a particular target machine.  You can define a macro\n+   `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n+   defined, is executed once just after all the command options have\n+   been parsed.\n+\n+   Don't use this macro to turn on various extra optimizations for\n+   `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */\n+#define OVERRIDE_OPTIONS override_options ()\n+\n+\n+/* Show we can debug even without a frame pointer.  */\n+#define CAN_DEBUG_WITHOUT_FP\n+\n+/* Some machines may desire to change what optimizations are\n+   performed for various optimization levels.   This macro, if\n+   defined, is executed once just after the optimization level is\n+   determined and before the remainder of the command options have\n+   been parsed.  Values set in this macro are used as the default\n+   values for the other command line options.\n+\n+   LEVEL is the optimization level specified; 2 if `-O2' is\n+   specified, 1 if `-O' is specified, and 0 if neither is specified.\n+\n+   You should not use this macro to change options that are not\n+   machine-specific.  These should uniformly selected by the same\n+   optimization level on all supported machines.  Use this macro to\n+   enable machine-specific optimizations.\n+\n+   *Do not examine `write_symbols' in this macro!* The debugging\n+   options are not supposed to alter the generated code. */\n+\n+#define OPTIMIZATION_OPTIONS(LEVEL)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (LEVEL)\t\t\t\t\t\t\t\t\\\n+    target_flags |= (MASK_EP | MASK_PROLOG_FUNCTION);\t\t\t\\\n+}\n+\n+\f\n+/* Target machine storage layout */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.\n+   This is not true on the NEC V850.  */\n+#define BITS_BIG_ENDIAN 0\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+/* This is not true on the NEC V850.  */\n+#define BYTES_BIG_ENDIAN 0\n+\n+/* Define this if most significant word of a multiword number is lowest\n+   numbered.\n+   This is not true on the NEC V850.  */\n+#define WORDS_BIG_ENDIAN 0\n+\n+/* Number of bits in an addressable storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD\t\t32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD\t\t4\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE \t\t32\n+\n+/* Define this macro if it is advisable to hold scalars in registers\n+   in a wider mode than that declared by the program.  In such cases,\n+   the value is constrained to be within the bounds of the declared\n+   type, but kept valid in the wider mode.  The signedness of the\n+   extension may differ from that of the type.\n+\n+   Some simple experiments have shown that leaving UNSIGNEDP alone\n+   generates the best overall code.  */\n+\n+#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)  \\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT \\\n+      && GET_MODE_SIZE (MODE) < 4)      \\\n+    { (MODE) = SImode; }\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY\t\t32\n+\n+/* The stack goes in 32 bit lumps.  */\n+#define STACK_BOUNDARY \t\t32\n+\n+/* Allocation boundary (in *bits*) for the code of a function.\n+   16 is the minimum boundary; 32 would give better performance.  */\n+#define FUNCTION_BOUNDARY 16\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT\t32\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* No structure field wants to be aligned rounder than this.  */\n+#define BIGGEST_FIELD_ALIGNMENT 32\n+\n+/* Define this if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT 1\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.\n+\n+   On the NEC V850, loads do sign extension, so make this default. */\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.  */\n+\n+#define FIRST_PSEUDO_REGISTER 34\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.  */\n+\n+#define FIXED_REGISTERS \\\n+  { 1, 1, 0, 1, 1, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 1, 0, \\\n+    1, 1}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you\n+   like.  */\n+\n+#define CALL_USED_REGISTERS \\\n+  { 1, 1, 0, 1, 1, 1, 1, 1, \\\n+    1, 1, 1, 1, 1, 1, 1, 1, \\\n+    1, 1, 1, 1, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 1, 1, \\\n+    1, 1}\n+\n+/* List the order in which to allocate registers.  Each register must be\n+   listed once, even those in FIXED_REGISTERS.\n+\n+   On the 850, we make the return registers first, then all of the volatile\n+   registers, then the saved registers in reverse order to better save the\n+   registers with an out of line function , and finnally the fixed\n+   registers.  */\n+\n+#define REG_ALLOC_ORDER\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  10, 11,\t\t\t\t/* return registers */\t\t\\\n+  12, 13, 14, 15, 16, 17, 18, 19,\t/* scratch registers */\t\t\\\n+   6,  7,  8,  9, 31,\t\t\t/* argument registers */\t\\\n+  29, 28, 27, 26, 25, 24, 23, 22,\t/* saved registers */\t\t\\\n+  21, 20,  2,\t\t\t\t\t\t\t\t\\\n+   0,  1,  3,  4,  5, 30, 32, 33\t/* fixed registers */\t\t\\\n+}\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.  */\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode\n+   MODE.  */\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+ ((((REGNO) & 1) == 0) || (GET_MODE_SIZE (MODE) <= 4))\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2) \\\n+  (MODE1 == MODE2 || GET_MODE_SIZE (MODE1) <= 4 && GET_MODE_SIZE (MODE2) <= 4)\n+\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+   \n+enum reg_class {\n+  NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES \\\n+{ \"NO_REGS\", \"GENERAL_REGS\", \"ALL_REGS\", \"LIM_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS  \t\t\t\\\n+{  0x00000000,\t\t/* No regs      */\t\\\n+   0xffffffff,\t\t/* GENERAL_REGS */    \t\\\n+   0xffffffff,\t\t/* ALL_REGS \t*/\t\\\n+}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO)  GENERAL_REGS\n+\n+/* The class value for index registers, and the one for base regs.  */\n+\n+#define INDEX_REG_CLASS NO_REGS\n+#define BASE_REG_CLASS  GENERAL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+\n+#define REG_CLASS_FROM_LETTER(C) (NO_REGS)\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+ \n+#define REGNO_OK_FOR_BASE_P(regno) \\\n+  ((regno) < FIRST_PSEUDO_REGISTER || reg_renumber[regno] >= 0)\n+\n+#define REGNO_OK_FOR_INDEX_P(regno) 0\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  */\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)  (CLASS)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* The letters I, J, K, L, M, N, O, P in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.  */\n+\n+#define INT_7_BITS(VALUE) ((unsigned) (VALUE) + 0x40 < 0x80)\n+#define INT_8_BITS(VALUE) ((unsigned) (VALUE) + 0x80 < 0x100)\n+#define CONST_OK_FOR_I(VALUE) ((VALUE) == 0)\n+#define CONST_OK_FOR_J(VALUE) ((unsigned) (VALUE) + 0x10 < 0x20)\n+#define CONST_OK_FOR_K(VALUE) ((unsigned) (VALUE) + 0x8000 < 0x10000)\n+#define CONST_OK_FOR_L(VALUE) \\\n+  (((unsigned) ((int) (VALUE) >> 16) + 0x8000 < 0x10000) \\\n+   && CONST_OK_FOR_I ((VALUE & 0xffff)))\n+#define CONST_OK_FOR_M(VALUE) ((unsigned)(VALUE) < 0x10000)\n+\n+#define CONST_OK_FOR_N(VALUE) ((unsigned) VALUE >= 0 && (unsigned) VALUE <= 31) /* 5 bit signed immediate in shift instructions */\n+#define CONST_OK_FOR_O(VALUE) 0\n+#define CONST_OK_FOR_P(VALUE) 0\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n+  ((C) == 'I' ? CONST_OK_FOR_I (VALUE) : \\\n+   (C) == 'J' ? CONST_OK_FOR_J (VALUE) : \\\n+   (C) == 'K' ? CONST_OK_FOR_K (VALUE) : \\\n+   (C) == 'L' ? CONST_OK_FOR_L (VALUE) : \\\n+   (C) == 'M' ? CONST_OK_FOR_M (VALUE) : \\\n+   (C) == 'N' ? CONST_OK_FOR_N (VALUE) : \\\n+   (C) == 'O' ? CONST_OK_FOR_O (VALUE) : \\\n+   (C) == 'P' ? CONST_OK_FOR_P (VALUE) : \\\n+   0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself. \n+     \n+  `G' is a zero of some form.  */\n+\n+#define CONST_DOUBLE_OK_FOR_G(VALUE)\t\t\t\t\t\\\n+  ((GET_MODE_CLASS (GET_MODE (VALUE)) == MODE_FLOAT\t\t\t\\\n+    && (VALUE) == CONST0_RTX (GET_MODE (VALUE)))\t\t\t\\\n+   || (GET_MODE_CLASS (GET_MODE (VALUE)) == MODE_INT\t\t\t\\\n+       && CONST_DOUBLE_LOW (VALUE) == 0\t\t\t\t\t\\\n+       && CONST_DOUBLE_HIGH (VALUE) == 0))\n+\n+#define CONST_DOUBLE_OK_FOR_H(VALUE) 0\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n+  ((C) == 'G'   ? CONST_DOUBLE_OK_FOR_G (VALUE)\t\t\t\t\\\n+   : (C) == 'H' ? CONST_DOUBLE_OK_FOR_H (VALUE)\t\t\t\t\\\n+   : 0)\n+\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+\n+#define STARTING_FRAME_OFFSET 0\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+/* Is equal to the size of the saved fp + pc, even if an fp isn't\n+   saved since the value is used before we know.  */\n+\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 3\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 32\n+\n+/* On some machines the offset between the frame pointer and starting\n+   offset of the automatic variables is not known until after register\n+   allocation has been done (for example, because the saved registers\n+   are between these two locations).  On those machines, define\n+   `FRAME_POINTER_REGNUM' the number of a special, fixed register to\n+   be used internally until the offset is known, and define\n+   `HARD_FRAME_POINTER_REGNUM' to be actual the hard register number\n+   used for the frame pointer.\n+\n+   You should define this macro only in the very rare circumstances\n+   when it is not possible to calculate the offset between the frame\n+   pointer and the automatic variables until after register\n+   allocation has been completed.  When this macro is defined, you\n+   must also indicate in your definition of `ELIMINABLE_REGS' how to\n+   eliminate `FRAME_POINTER_REGNUM' into either\n+   `HARD_FRAME_POINTER_REGNUM' or `STACK_POINTER_REGNUM'.\n+\n+   Do not define this macro if it would be the same as\n+   `FRAME_POINTER_REGNUM'. */\n+#define HARD_FRAME_POINTER_REGNUM 29\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 33\n+\n+/* Register in which static-chain is passed to a function.  */\n+#define STATIC_CHAIN_REGNUM 5\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  */\n+#define FRAME_POINTER_REQUIRED 0\n+\n+/* If defined, this macro specifies a table of register pairs used to\n+   eliminate unneeded registers that point into the stack frame.  If\n+   it is not defined, the only elimination attempted by the compiler\n+   is to replace references to the frame pointer with references to\n+   the stack pointer.\n+\n+   The definition of this macro is a list of structure\n+   initializations, each of which specifies an original and\n+   replacement register.\n+\n+   On some machines, the position of the argument pointer is not\n+   known until the compilation is completed.  In such a case, a\n+   separate hard register must be used for the argument pointer.\n+   This register can be eliminated by replacing it with either the\n+   frame pointer or the argument pointer, depending on whether or not\n+   the frame pointer has been eliminated.\n+\n+   In this case, you might specify:\n+        #define ELIMINABLE_REGS  \\\n+        {{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM}, \\\n+         {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM}, \\\n+         {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n+\n+   Note that the elimination of the argument pointer with the stack\n+   pointer is specified first since that is the preferred elimination. */\n+\n+#define ELIMINABLE_REGS\t\t\t\t\t\t\t\\\n+{{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM },\t\t\t\\\n+ { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM },\t\t\t\\\n+ { ARG_POINTER_REGNUM,\t STACK_POINTER_REGNUM },\t\t\t\\\n+ { ARG_POINTER_REGNUM,   HARD_FRAME_POINTER_REGNUM }}\t\t\t\\\n+\n+/* A C expression that returns non-zero if the compiler is allowed to\n+   try to replace register number FROM-REG with register number\n+   TO-REG.  This macro need only be defined if `ELIMINABLE_REGS' is\n+   defined, and will usually be the constant 1, since most of the\n+   cases preventing register elimination are things that the compiler\n+   already knows about. */\n+\n+#define CAN_ELIMINATE(FROM, TO) \\\n+ ((TO) == STACK_POINTER_REGNUM ? ! frame_pointer_needed : 1)\n+\n+/* This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It\n+   specifies the initial difference between the specified pair of\n+   registers.  This macro must be defined if `ELIMINABLE_REGS' is\n+   defined. */\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if ((FROM) == FRAME_POINTER_REGNUM)\t\t\t\t\t\\\n+    (OFFSET) = get_frame_size () + current_function_outgoing_args_size;\t\\\n+  else if ((FROM) == ARG_POINTER_REGNUM)\t\t\t\t\\\n+   (OFFSET) = compute_frame_size (get_frame_size (), (long *)0);\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    abort ();\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* A guess for the V850.  */\n+#define PROMOTE_PROTOTYPES 1\n+\n+/* Keep the stack pointer constant throughout the function.  */\n+#define ACCUMULATE_OUTGOING_ARGS\n+\n+/* Value is the number of bytes of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNDECL is the declaration node of the function (as a tree),\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.  */\n+\n+#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n+\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.  */\n+\n+#define CUMULATIVE_ARGS struct cum_arg\n+struct cum_arg { int nbytes; };\n+\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+struct rtx_def *function_arg();\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+  function_arg (&CUM, MODE, TYPE, NAMED)\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n+  function_arg_partial_nregs (&CUM, MODE, TYPE, NAMED)\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)\t\\\n+ ((CUM).nbytes = 0)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+ ((CUM).nbytes += ((MODE) != BLKmode\t\t\t\\\n+  ? (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) & -UNITS_PER_WORD\t\\\n+  : (int_size_in_bytes (TYPE) + UNITS_PER_WORD - 1) & -UNITS_PER_WORD))\n+\n+/* When a parameter is passed in a register, stack space is still\n+   allocated for it.  */\n+#define REG_PARM_STACK_SPACE(DECL) (!TARGET_GHS ? 16 : 0)\n+\n+/* Define this if the above stack space is to be considered part of the\n+   space allocated by the caller.  */\n+#define OUTGOING_REG_PARM_STACK_SPACE\n+\n+extern int current_function_anonymous_args;\n+/* Do any setup necessary for varargs/stdargs functions.  */\n+#define SETUP_INCOMING_VARARGS(CUM, MODE, TYPE, PAS, SECOND) \\\n+  current_function_anonymous_args = (!TARGET_GHS ? 1 : 0);\n+\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n+  ((TYPE) && int_size_in_bytes (TYPE) > 8)\n+ \n+#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) \\\n+  ((TYPE) && int_size_in_bytes (TYPE) > 8)\n+\n+/* 1 if N is a possible register number for function argument passing.  */\n+\n+#define FUNCTION_ARG_REGNO_P(N) (N >= 6 && N <= 9)\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.   */\n+   \n+#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE), 10)\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+#define LIBCALL_VALUE(MODE) \\\n+  gen_rtx (REG, MODE, 10)\n+\n+/* 1 if N is a possible register number for a function value.  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 10)\n+\n+/* Return values > 8 bytes in length in memory.  */\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+#define RETURN_IN_MEMORY(TYPE)  \\\n+  (int_size_in_bytes (TYPE) > 8 || TYPE_MODE (TYPE) == BLKmode)\n+\n+/* Register in which address to store a structure value\n+   is passed to a function.  On the V850 it's passed as\n+   the first parameter.  */\n+\n+#define STRUCT_VALUE 0\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define EXIT_IGNORE_STACK 1\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO) ;\n+\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tjarl .+4,r12\\n\");\t\t\t\\\n+    fprintf (FILE, \"\\tld.w 12[r12],r5\\n\");\t\t\\\n+    fprintf (FILE, \"\\tld.w 16[r12],r12\\n\");\t\t\\\n+    fprintf (FILE, \"\\tjmp [r12]\\n\");\t\t\t\\\n+    fprintf (FILE, \"\\tnop\\n\");\t\t\t\t\\\n+    fprintf (FILE, \"\\t.long 0\\n\");\t\t\t\\\n+    fprintf (FILE, \"\\t.long 0\\n\");\t\t\t\\\n+  } while (0)\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE 24\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 16)),\t\\\n+ \t\t (CXT));\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 20)),\t\\\n+\t\t (FNADDR));\t\t\t\t\t\t\\\n+}\n+\n+/* Addressing modes, and classification of registers for them.  */\n+\n+\f\n+/* 1 if X is an rtx for a constant that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X)   \\\n+  (GET_CODE (X) == CONST_INT\t\t\t\t\\\n+   && CONST_OK_FOR_K (INTVAL (X)))\n+\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X) 0\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) 1\n+#define REG_OK_FOR_INDEX_P_STRICT(X) 0\n+#define REG_OK_FOR_BASE_P_STRICT(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+#define STRICT 0\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) 0\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+#define STRICT 1\n+\n+#endif\n+\n+/* A C expression that defines the optional machine-dependent\n+   constraint letters that can be used to segregate specific types of\n+   operands, usually memory references, for the target machine.\n+   Normally this macro will not be defined.  If it is required for a\n+   particular target machine, it should return 1 if VALUE corresponds\n+   to the operand type represented by the constraint letter C.  If C\n+   is not defined as an extra constraint, the value returned should\n+   be 0 regardless of VALUE.\n+\n+   For example, on the ROMP, load instructions cannot have their\n+   output in r0 if the memory reference contains a symbolic address.\n+   Constraint letter `Q' is defined as representing a memory address\n+   that does *not* contain a symbolic address.  An alternative is\n+   specified with a `Q' constraint on the input and `r' on the\n+   output.  The next alternative specifies `m' on the input and a\n+   register class that does not include r0 on the output.  */\n+\n+#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\t\t\\\n+ ((C) == 'Q'   ? ep_memory_operand (OP, GET_MODE (OP))\t\t\t\\\n+  : (C) == 'R' ? special_symbolref_operand (OP, VOIDmode)\t\t\\\n+  : (C) == 'S' ? (GET_CODE (OP) == SYMBOL_REF && ! ZDA_NAME_P (XSTR (OP, 0))) \\\n+  : (C) == 'T' ? 0\t\t\t\t\t\t\t\\\n+  : (C) == 'U' ? 0                                                      \\\n+  : 0)\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n+   except for CONSTANT_ADDRESS_P which is actually\n+   machine-independent.  */\n+\n+/* Accept either REG or SUBREG where a register is valid.  */\n+  \n+#define RTX_OK_FOR_BASE_P(X)\t\t\t\t\t\t\\\n+  ((REG_P (X) && REG_OK_FOR_BASE_P (X))\t\t\t\t\t\\\n+   || (GET_CODE (X) == SUBREG && REG_P (SUBREG_REG (X))\t\t\t\\\n+       && REG_OK_FOR_BASE_P (SUBREG_REG (X))))\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (RTX_OK_FOR_BASE_P (X)) goto ADDR;\t\t\t\t\t\\\n+  if (CONSTANT_ADDRESS_P (X)\t\t\t\t\t\t\\\n+      && (MODE == QImode || INTVAL (X) % 2 == 0))\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == LO_SUM\t\t\t\t\t\t\\\n+      && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n+      && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n+      && CONSTANT_P (XEXP (X, 1))\t\t\t\t\t\\\n+      && (GET_CODE (XEXP (X, 1)) != CONST_INT\t\t\t\t\\\n+\t  || ((MODE == QImode || INTVAL (XEXP (X, 1)) % 2 == 0)\t\t\\\n+\t      && CONST_OK_FOR_K (INTVAL (XEXP (X, 1)))))\t\t\\\n+      && GET_MODE_SIZE (MODE) <= GET_MODE_SIZE (word_mode))\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n+  if (special_symbolref_operand (X, MODE)\t\t\t\t\\\n+      && (GET_MODE_SIZE (MODE) <= GET_MODE_SIZE (word_mode)))\t\t\\\n+     goto ADDR;\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n+      && CONSTANT_ADDRESS_P (XEXP (X, 1))\t\t\t\t\\\n+      && (MODE == QImode || INTVAL (XEXP (X, 1)) % 2 == 0)\t\t\\\n+      && RTX_OK_FOR_BASE_P (XEXP (X, 0))) goto ADDR;\t\t\t\\\n+} while (0)\n+\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.   */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)  {}\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.  */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)  {}\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X)\t\t\t\t\t\\\n+  (GET_CODE (X) == CONST_DOUBLE\t\t\t\t\t\t\\\n+   || !(GET_CODE (X) == CONST\t\t\t\t\t\t\\\n+\t&& GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\t\\\n+\t&& GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF\t\t\\\n+\t&& GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT\t\t\\\n+\t&& ! CONST_OK_FOR_K (INTVAL (XEXP (XEXP (X, 0), 1)))))\n+\n+/* In rare cases, correct code generation requires extra machine\n+   dependent processing between the second jump optimization pass and\n+   delayed branch scheduling.  On those machines, define this macro\n+   as a C statement to act on the code starting at INSN.  */\n+\n+#define MACHINE_DEPENDENT_REORG(INSN) v850_reorg (INSN)\n+\n+\f\n+/* Tell final.c how to eliminate redundant test instructions.  */\n+\n+/* Here we define machine-dependent flags and fields in cc_status\n+   (see `conditions.h').  No extra ones are needed for the vax.  */\n+\n+/* Store in cc_status the expressions\n+   that the condition codes will describe\n+   after execution of an instruction whose pattern is EXP.\n+   Do not alter them if the instruction would not alter the cc's.  */\n+\n+#define CC_OVERFLOW_UNUSABLE 0x200\n+#define CC_NO_CARRY CC_NO_OVERFLOW\n+#define NOTICE_UPDATE_CC(EXP, INSN) notice_update_cc(EXP, INSN)\n+\n+/* A part of a C `switch' statement that describes the relative costs\n+   of constant RTL expressions.  It must contain `case' labels for\n+   expression codes `const_int', `const', `symbol_ref', `label_ref'\n+   and `const_double'.  Each case must ultimately reach a `return'\n+   statement to return the relative cost of the use of that kind of\n+   constant value in an expression.  The cost may depend on the\n+   precise value of the constant, which is available for examination\n+   in X, and the rtx code of the expression in which it is contained,\n+   found in OUTER_CODE.\n+\n+   CODE is the expression code--redundant, since it can be obtained\n+   with `GET_CODE (X)'. */\n+\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE)\t\t\t\t\\\n+  case CONST_INT:\t\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n+  case CONST:\t\t\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      int _zxy = const_costs(RTX, CODE);\t\t\t\t\\\n+      return (_zxy) ? COSTS_N_INSNS (_zxy) : 0;\t\t\t\t\\\n+    }\n+\n+/* A crude cut at RTX_COSTS for the V850.  */\n+\n+/* Provide the costs of a rtl expression.  This is in the body of a\n+   switch on CODE. \n+\n+   There aren't DImode MOD, DIV or MULT operations, so call them\n+   very expensive.  Everything else is pretty much a costant cost.  */\n+\n+#define RTX_COSTS(RTX,CODE,OUTER_CODE)\t\t\t\t\t\\\n+  case MOD:\t\t\t\t\t\t\t\t\\\n+  case DIV:\t\t\t\t\t\t\t\t\\\n+    return 60;\t\t\t\t\t\t\t\t\\\n+  case MULT:\t\t\t\t\t\t\t\t\\\n+    return 20;\n+\n+/* All addressing modes have the same cost on the V850 series.  */\n+#define ADDRESS_COST(ADDR) 1\n+\n+/* Nonzero if access to memory by bytes or half words is no faster\n+   than accessing full words.  */\n+#define SLOW_BYTE_ACCESS 1\n+\n+/* Define this if zero-extension is slow (more than one real instruction).  */\n+#define SLOW_ZERO_EXTEND \n+\n+/* According expr.c, a value of around 6 should minimize code size, and\n+   for the V850 series, that's our primary concern.  */\n+#define MOVE_RATIO 6\n+\n+/* Indirect calls are expensive, never turn a direct call\n+   into an indirect call.  */\n+#define NO_FUNCTION_CSE\n+\n+/* A list of names for sections other than the standard two, which are\n+   `in_text' and `in_data'.  You need not define this macro on a\n+   system with no other sections (that GCC needs to use).  */\n+#undef\tEXTRA_SECTIONS\n+#define EXTRA_SECTIONS in_tdata, in_sdata, in_zdata, in_const, in_ctors, in_dtors\n+\n+/* One or more functions to be defined in `varasm.c'.  These\n+   functions should do jobs analogous to those of `text_section' and\n+   `data_section', for your additional sections.  Do not define this\n+   macro if you do not define `EXTRA_SECTIONS'. */\n+#undef\tEXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n+CONST_SECTION_FUNCTION\t\t\t\t\t\t\t\\\n+CTORS_SECTION_FUNCTION\t\t\t\t\t\t\t\\\n+DTORS_SECTION_FUNCTION\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+sdata_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_sdata)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", SDATA_SECTION_ASM_OP);\t\t\\\n+      in_section = in_sdata;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+tdata_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_tdata)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", TDATA_SECTION_ASM_OP);\t\t\\\n+      in_section = in_tdata;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+zdata_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_zdata)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", ZDATA_SECTION_ASM_OP);\t\t\\\n+      in_section = in_zdata;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define TEXT_SECTION_ASM_OP \"\\t.section .text\"\n+#define DATA_SECTION_ASM_OP \"\\t.section .data\"\n+#define BSS_SECTION_ASM_OP \"\\t.section .bss\"\n+#define SDATA_SECTION_ASM_OP \"\\t.section .sdata,\\\"aw\\\"\"\n+#define SBSS_SECTION_ASM_OP \"\\t.section .sbss,\\\"aw\\\"\"\n+#define ZDATA_SECTION_ASM_OP \"\\t.section .zdata,\\\"aw\\\"\"\n+#define ZBSS_SECTION_ASM_OP \"\\t.section .zbss,\\\"aw\\\"\"\n+#define TDATA_SECTION_ASM_OP \"\\t.section .tdata,\\\"aw\\\"\"\n+\n+/* A C statement or statements to switch to the appropriate section\n+   for output of EXP.  You can assume that EXP is either a `VAR_DECL'\n+   node or a constant of some sort.  RELOC indicates whether the\n+   initial value of EXP requires link-time relocations.  Select the\n+   section by calling `text_section' or one of the alternatives for\n+   other sections.\n+\n+   Do not define this macro if you put all read-only variables and\n+   constants in the read-only data section (usually the text section).  */\n+#undef\tSELECT_SECTION\n+#define SELECT_SECTION(EXP, RELOC)\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (TREE_CODE (EXP) == VAR_DECL)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (!TREE_READONLY (EXP) || TREE_SIDE_EFFECTS (EXP)\t\t\\\n+\t  || !DECL_INITIAL (EXP)\t\t\t\t\t\\\n+\t  || (DECL_INITIAL (EXP) != error_mark_node\t\t\t\\\n+\t      && !TREE_CONSTANT (DECL_INITIAL (EXP))))\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tconst_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (TREE_CODE (EXP) == STRING_CST)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (! flag_writable_strings)\t\t\t\t\t\\\n+\tconst_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    const_section ();\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* A C statement or statements to switch to the appropriate section\n+   for output of RTX in mode MODE.  You can assume that RTX is some\n+   kind of constant in RTL.  The argument MODE is redundant except in\n+   the case of a `const_int' rtx.  Select the section by calling\n+   `text_section' or one of the alternatives for other sections.\n+\n+   Do not define this macro if you put all constants in the read-only\n+   data section.  */\n+/* #define SELECT_RTX_SECTION(MODE, RTX) */\n+\n+/* Output at beginning/end of assembler file.  */\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE) asm_file_start(FILE)\n+\n+#define ASM_COMMENT_START \"#\"\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON \"#APP\\n\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF \"#NO_APP\\n\"\n+\n+/* This is how to output an assembler line defining a `double' constant.\n+   It is .double or .float, depending.  */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE, VALUE)\t\t\t\\\n+do { char dstr[30];\t\t\t\t\t\\\n+     REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", dstr);\t\\\n+     fprintf (FILE, \"\\t.double %s\\n\", dstr);\t\t\\\n+   } while (0)\n+\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+#define ASM_OUTPUT_FLOAT(FILE, VALUE)\t\t\t\\\n+do { char dstr[30];\t\t\t\t\t\\\n+     REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", dstr);\t\\\n+     fprintf (FILE, \"\\t.float %s\\n\", dstr);\t\t\\\n+   } while (0)\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE, VALUE)\t\t\\\n+( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `char' and `short' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE, VALUE)\t\t\\\n+( fprintf (FILE, \"\\t.hword \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE, VALUE)\t\t\\\n+( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+#define ASM_OUTPUT_BYTE(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* This says how to output the assembler to define a global\n+   uninitialized but not common symbol.\n+   Try to use asm_output_bss to implement this macro.  */\n+\n+#define ASM_OUTPUT_BSS(FILE, DECL, NAME, SIZE, ROUNDED) \\\n+  asm_output_bss ((FILE), (DECL), (NAME), (SIZE), (ROUNDED))\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE, NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE, NAME)\t\\\n+  do { fputs (\"\\t.global \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n+\n+#undef ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(FILE, NAME)\t          \\\n+  do {                                            \\\n+  char* real_name;                                \\\n+  STRIP_NAME_ENCODING (real_name, (NAME));        \\\n+  fprintf (FILE, \"_%s\", real_name);               \\\n+  } while (0)           \n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s___%d\", (NAME), (LABELNO)))\n+\n+/* This is how we tell the assembler that two symbols have the same value.  */\n+\n+#define ASM_OUTPUT_DEF(FILE,NAME1,NAME2) \\\n+  do { assemble_name(FILE, NAME1); \t \\\n+       fputs(\" = \", FILE);\t\t \\\n+       assemble_name(FILE, NAME2);\t \\\n+       fputc('\\n', FILE); } while (0)\n+\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n+{  \"r0\",  \"r1\",  \"r2\",  \"sp\",  \"gp\",  \"r5\",  \"r6\" , \"r7\",\t\t\\\n+   \"r8\",  \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\t\\\n+  \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",\t\t\\\n+  \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\",  \"ep\", \"r31\",\t\t\\\n+  \".fp\", \".ap\"}\n+\n+#define ADDITIONAL_REGISTER_NAMES\t\t\t\t\t\\\n+{ { \"zero\",\t0 },\t\t\t\t\t\t\t\\\n+  { \"hp\",\t2 },\t\t\t\t\t\t\t\\\n+  { \"r3\",\t3 },\t\t\t\t\t\t\t\\\n+  { \"r4\",\t4 },\t\t\t\t\t\t\t\\\n+  { \"tp\",\t5 },\t\t\t\t\t\t\t\\\n+  { \"fp\",\t29 },\t\t\t\t\t\t\t\\\n+  { \"r30\",\t30 },\t\t\t\t\t\t\t\\\n+  { \"lp\",\t31} }\n+\n+/* Print an instruction operand X on file FILE.\n+   look in v850.c for details */\n+\n+#define PRINT_OPERAND(FILE, X, CODE)  print_operand(FILE,X,CODE)\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) \\\n+  ((CODE) == '.')\n+\n+/* Print a memory operand whose address is X, on file FILE.\n+   This uses a function in output-vax.c.  */\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \\\n+  asm_fprintf (FILE, \"\\t%s .L%d\\n\", \".long\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+  fprintf (FILE, \"\\t%s .L%d-.L%d\\n\", \".long\", VALUE, REL)\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) != 0)\t\t\t\\\n+    fprintf (FILE, \"\\t.align %d\\n\", (LOG))\n+\n+/* We don't have to worry about dbx compatability for the v850.  */\n+#define DEFAULT_GDB_EXTENSIONS 1\n+\n+/* Use stabs debugging info by default.  */\n+#undef PREFERRED_DEBUGGING_TYPE\n+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n+\n+#define DBX_REGISTER_NUMBER(REGNO) REGNO\n+\n+/* Define to use software floating point emulator for REAL_ARITHMETIC and\n+   decimal <-> binary conversion. */\n+#define REAL_ARITHMETIC\n+\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE Pmode\n+\n+/* Define this if the case instruction drops through after the table\n+   when the index is out of range.  Don't define it if the case insn\n+   jumps to the default label instead.  */\n+#define CASE_DROPS_THROUGH\n+\n+#define WORD_REGISTER_OPERATIONS\n+\n+/* Byte and short loads sign extend the value to a word.  */\n+#define LOAD_EXTEND_OP(MODE) SIGN_EXTEND\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This flag, if defined, says the same insns that convert to a signed fixnum\n+   also convert validly to an unsigned one.  */\n+#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX\t4\n+\n+/* Define if shifts truncate the shift count\n+   which implies one can omit a sign-extension or zero-extension\n+   of a shift count.  */\n+#define SHIFT_COUNT_TRUNCATED 1\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+#define STORE_FLAG_VALUE 1\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode SImode\n+\n+/* A function address in a call instruction\n+   is a byte address (for indexing purposes)\n+   so give the MEM rtx a byte's mode.  */\n+#define FUNCTION_MODE QImode\n+\n+/* A C expression whose value is nonzero if IDENTIFIER with arguments ARGS\n+   is a valid machine specific attribute for DECL.\n+   The attributes in ATTRIBUTES have previously been assigned to DECL.  */\n+#define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \\\n+v850_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n+\n+/* Tell compiler we have {ZDA,TDA,SDA} small data regions */\n+#define HAVE_ZDA 1\n+#define HAVE_SDA 1\n+#define HAVE_TDA 1\n+\n+/* Tell compiler we want to support GHS pragmas */\n+#define HANDLE_GHS_PRAGMA\n+\n+/* The assembler op to to start the file.  */\n+\n+#define FILE_ASM_OP \"\\t.file\\n\"\n+\n+/* Enable the register move pass to improve code.  */\n+#define ENABLE_REGMOVE_PASS\n+\n+\n+/* Implement ZDA, TDA, and SDA */\n+\n+#define EP_REGNUM 30\t/* ep register number */\n+\n+#define ENCODE_SECTION_INFO(DECL)\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if ((TREE_STATIC (DECL) || DECL_EXTERNAL (DECL))\t\t\t\\\n+      && TREE_CODE (DECL) == VAR_DECL)\t\t\t\t\t\\\n+    v850_encode_data_area (DECL);\t\t\t\t\t\\\n+} while (0)\n+\n+#define ZDA_NAME_FLAG_CHAR '@'\n+#define TDA_NAME_FLAG_CHAR '%'\n+#define SDA_NAME_FLAG_CHAR '&'\n+\n+#define ZDA_NAME_P(NAME) (*(NAME) == ZDA_NAME_FLAG_CHAR)\n+#define TDA_NAME_P(NAME) (*(NAME) == TDA_NAME_FLAG_CHAR)\n+#define SDA_NAME_P(NAME) (*(NAME) == SDA_NAME_FLAG_CHAR)\n+\n+#define ENCODED_NAME_P(SYMBOL_NAME)    \\\n+  (ZDA_NAME_P (SYMBOL_NAME)            \\\n+   || TDA_NAME_P (SYMBOL_NAME)         \\\n+   || SDA_NAME_P (SYMBOL_NAME))\n+\n+#define STRIP_NAME_ENCODING(VAR,SYMBOL_NAME) \\\n+     (VAR) = (SYMBOL_NAME) + (ENCODED_NAME_P (SYMBOL_NAME) || *(SYMBOL_NAME) == '*')\n+\n+/* Define this if you have defined special-purpose predicates in the\n+   file `MACHINE.c'.  This macro is called within an initializer of an\n+   array of structures.  The first field in the structure is the name\n+   of a predicate and the second field is an array of rtl codes.  For\n+   each predicate, list all rtl codes that can be in expressions\n+   matched by the predicate.  The list should have a trailing comma.  */\n+\n+#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n+{ \"ep_memory_operand\",\t\t{ MEM }},\t\t\t\t\\\n+{ \"reg_or_0_operand\",\t\t{ REG, SUBREG, CONST_INT, CONST_DOUBLE }}, \\\n+{ \"reg_or_int5_operand\",\t{ REG, SUBREG, CONST_INT }},\t\t\\\n+{ \"call_address_operand\",\t{ REG, SYMBOL_REF }},\t\t\t\\\n+{ \"movsi_source_operand\",\t{ LABEL_REF, SYMBOL_REF, CONST_INT,\t\\\n+\t\t\t\t  CONST_DOUBLE, CONST, HIGH, MEM,\t\\\n+\t\t\t\t  REG, SUBREG }},\t\t\t\\\n+{ \"special_symbolref_operand\",\t{ SYMBOL_REF }},\t\t\t\\\n+{ \"power_of_two_operand\",\t{ CONST_INT }},\t\t\t\t\\\n+{ \"not_power_of_two_operand\",\t{ CONST_INT }},\n+\n+extern void override_options ();\n+extern void asm_file_start ();\n+extern int function_arg_partial_nregs ();\n+extern int const_costs ();\n+extern void print_operand ();\n+extern void print_operand_address ();\n+extern char *output_move_double ();\n+extern char *output_move_single ();\n+extern int ep_operand ();\n+extern int reg_or_0_operand ();\n+extern int reg_or_int5_operand ();\n+extern int call_address_operand ();\n+extern int movsi_source_operand ();\n+extern int power_of_two_operand ();\n+extern int not_power_of_two_operand ();\n+extern void v850_reorg ();\n+extern int compute_register_save_size ();\n+extern int compute_frame_size ();\n+extern void expand_prologue ();\n+extern void expand_epilogue ();\n+extern void notice_update_cc ();\n+extern int v850_valid_machine_decl_attribute ();\n+extern int v850_interrupt_function_p ();\n+/* END CYGNUS LOCAL */"}, {"sha": "30ebf8709c092d67a9b1a1c51589f9ac0c740d1b", "filename": "gcc/config/v850/v850.md", "status": "added", "additions": 1852, "deletions": 0, "changes": 1852, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae180d84fc7bb97b09fb67a1e478288d748e41fb/gcc%2Fconfig%2Fv850%2Fv850.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae180d84fc7bb97b09fb67a1e478288d748e41fb/gcc%2Fconfig%2Fv850%2Fv850.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.md?ref=ae180d84fc7bb97b09fb67a1e478288d748e41fb", "patch": "@@ -0,0 +1,1852 @@\n+;; CYGNUS LOCAL entire file/law\n+;; GCC machine description for NEC V850\n+;; Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+\n+;;   Contributed by Jeff Law (law@cygnus.com).\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; The original PO technology requires these to be ordered by speed,\n+;; so that assigner will pick the fastest.\n+\n+;; See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+;; The V851 manual states that the instruction address space is 16M;\n+;; the various branch/call instructions only have a 22bit offset (4M range).\n+;;\n+;; One day we'll probably need to handle calls to targets more than 4M\n+;; away.\n+\n+;; The size of instructions in bytes.\n+\n+(define_attr \"length\" \"\"\n+  (const_int 200))\n+\n+;; Types of instructions (for scheduling purposes).\n+\n+(define_attr \"type\" \"load,mult,other\"\n+  (const_string \"other\"))\n+\n+;; Condition code settings.\n+;; none - insn does not affect cc\n+;; none_0hit - insn does not affect cc but it does modify operand 0\n+;;\tThis attribute is used to keep track of when operand 0 changes.\n+;; \tSee the description of NOTICE_UPDATE_CC for more info.\n+;; set_znv - sets z,n,v to useable values; c is unknown.\n+;; set_zn  - sets z,n to usable values; v,c is unknown.\n+;; compare - compare instruction\n+;; clobber - value of cc is unknown\n+(define_attr \"cc\" \"none,none_0hit,set_zn,set_znv,compare,clobber\"\n+  (const_string \"clobber\"))\n+\f\n+;; Function units for the V850.  As best as I can tell, there's\n+;; a traditional memory load/use stall as well as a stall if\n+;; the result of a multiply is used too early.\n+;;\n+(define_function_unit \"memory\" 1 0 (eq_attr \"type\" \"load\") 2 0)\n+(define_function_unit \"mult\"   1 0 (eq_attr \"type\" \"mult\") 2 0)\n+\n+\f\n+;; ----------------------------------------------------------------------\n+;; MOVE INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+;; movqi\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register or 0 */\n+  if (!register_operand (operand0, QImode)\n+      && !reg_or_0_operand (operand1, QImode))\n+    operands[1] = copy_to_mode_reg (QImode, operand1);\n+}\")\n+\n+(define_insn \"*movqi_internal\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r,Q,r,m,m\")\n+\t(match_operand:QI 1 \"general_operand\" \"Jr,n,Q,Ir,m,r,I\"))]\n+  \"register_operand (operands[0], QImode)\n+   || reg_or_0_operand (operands[1], QImode)\"\n+  \"* return output_move_single (operands);\"\n+  [(set_attr \"length\" \"2,4,2,2,4,4,4\")\n+   (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")\n+   (set_attr \"type\" \"other,other,load,other,load,other,other\")])\n+\n+;; movhi\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register or 0 */\n+  if (!register_operand (operand0, HImode)\n+      && !reg_or_0_operand (operand1, HImode))\n+    operands[1] = copy_to_mode_reg (HImode, operand1);\n+}\")\n+\n+(define_insn \"*movhi_internal\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r,r,r,Q,r,m,m\")\n+\t(match_operand:HI 1 \"general_operand\" \"Jr,n,Q,Ir,m,r,I\"))]\n+  \"register_operand (operands[0], HImode)\n+   || reg_or_0_operand (operands[1], HImode)\"\n+  \"* return output_move_single (operands);\"\n+  [(set_attr \"length\" \"2,4,2,2,4,4,4\")\n+   (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")\n+   (set_attr \"type\" \"other,other,load,other,load,other,other\")])\n+\n+;; movsi and helpers\n+\n+(define_insn \"*movsi_high\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(high:SI (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"movhi hi(%1),%.,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"other\")])\n+\n+(define_insn \"*movsi_lo\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"movea lo(%2),%1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"other\")])\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register or 0 */\n+  if (!register_operand (operand0, SImode)\n+      && !reg_or_0_operand (operand1, SImode))\n+    operands[1] = copy_to_mode_reg (SImode, operand1);\n+\n+  /* Some constants, as well as symbolic operands\n+     must be done with HIGH & LO_SUM patterns.  */\n+  if (CONSTANT_P (operands[1])\n+      && GET_CODE (operands[1]) != HIGH\n+      && !special_symbolref_operand (operands[1], VOIDmode)\n+      && !(GET_CODE (operands[1]) == CONST_INT\n+\t   && (CONST_OK_FOR_J (INTVAL (operands[1]))\n+\t       || CONST_OK_FOR_K (INTVAL (operands[1]))\n+\t       || CONST_OK_FOR_L (INTVAL (operands[1])))))\n+    {\n+      rtx high;\n+      rtx temp;\n+\n+      if (reload_in_progress || reload_completed)\n+        temp = operands[0];\n+      else\n+\ttemp = gen_reg_rtx (SImode);\n+\n+      emit_insn (gen_rtx (SET, SImode, temp,\n+                          gen_rtx (HIGH, SImode, operand1)));\n+      emit_insn (gen_rtx (SET, SImode, operand0,\n+                          gen_rtx (LO_SUM, SImode, temp, operand1)));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*movsi_internal\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r,r,r,r,Q,r,r,m,m\")\n+\t(match_operand:SI 1 \"movsi_source_operand\" \"Jr,K,L,Q,Ir,m,R,r,I\"))]\n+  \"register_operand (operands[0], SImode)\n+   || reg_or_0_operand (operands[1], SImode)\"\n+  \"* return output_move_single (operands);\"\n+  [(set_attr \"length\" \"2,4,4,2,2,4,4,4,4\")\n+   (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")\n+   (set_attr \"type\" \"other,other,other,load,other,load,other,other,other\")])\n+\n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register or 0 */\n+  if (!register_operand (operand0, DImode)\n+      && !reg_or_0_operand (operand1, DImode))\n+    operands[1] = copy_to_mode_reg (DImode, operand1);\n+}\")\n+\n+(define_insn \"*movdi_internal\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=r,r,r,r,r,m,m,r\")\n+\t(match_operand:DI 1 \"general_operand\" \"Jr,K,L,i,m,r,IG,iF\"))]\n+  \"register_operand (operands[0], DImode)\n+   || reg_or_0_operand (operands[1], DImode)\"\n+  \"* return output_move_double (operands);\"\n+  [(set_attr \"length\" \"4,8,8,16,8,8,8,16\")\n+   (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")\n+   (set_attr \"type\" \"other,other,other,other,load,other,other,other\")])\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register or 0 */\n+  if (!register_operand (operand0, SFmode)\n+      && !reg_or_0_operand (operand1, SFmode))\n+    operands[1] = copy_to_mode_reg (SFmode, operand1);\n+}\")\n+\n+(define_insn \"*movsf_internal\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=r,r,r,r,r,Q,r,m,m,r\")\n+\t(match_operand:SF 1 \"general_operand\" \"Jr,K,L,n,Q,Ir,m,r,IG,iF\"))]\n+  \"register_operand (operands[0], SFmode)\n+   || reg_or_0_operand (operands[1], SFmode)\"\n+  \"* return output_move_single (operands);\"\n+  [(set_attr \"length\" \"2,4,4,8,2,2,4,4,4,8\")\n+   (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")\n+   (set_attr \"type\" \"other,other,other,other,load,other,load,other,other,other\")])\n+\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t(match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register or 0 */\n+  if (!register_operand (operand0, DFmode)\n+      && !reg_or_0_operand (operand1, DFmode))\n+    operands[1] = copy_to_mode_reg (DFmode, operand1);\n+}\")\n+\n+(define_insn \"*movdf_internal\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=r,r,r,r,r,m,m,r\")\n+\t(match_operand:DF 1 \"general_operand\" \"Jr,K,L,i,m,r,IG,iF\"))]\n+  \"register_operand (operands[0], DFmode)\n+   || reg_or_0_operand (operands[1], DFmode)\"\n+  \"* return output_move_double (operands);\"\n+  [(set_attr \"length\" \"4,8,8,16,8,8,8,16\")\n+   (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")\n+   (set_attr \"type\" \"other,other,other,other,load,other,other,other\")])\n+\n+\f\n+;; ----------------------------------------------------------------------\n+;; TEST INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"*v850_tst1\"\n+  [(set (cc0) (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"m\")\n+                               (const_int 1)\n+                               (match_operand:QI 1 \"const_int_operand\" \"n\")))]\n+  \"\"\n+  \"tst1 %1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"tstsi\"\n+  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"cmp %.,%0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+(define_insn \"cmpsi\"\n+  [(set (cc0)\n+\t(compare:SI (match_operand:SI 0 \"register_operand\" \"r,r\")\n+\t\t    (match_operand:SI 1 \"reg_or_int5_operand\" \"r,J\")))]\n+  \"\"\n+  \"@\n+  cmp %1,%0\n+  cmp %1,%0\"\n+  [(set_attr \"length\" \"2,2\")\n+   (set_attr \"cc\" \"compare\")])\n+\f\n+;; ----------------------------------------------------------------------\n+;; ADD INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,&r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,r,r\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"rJ,K,r\")))]\n+  \"\"\n+  \"@\n+   add %2,%0\n+   addi %2,%1,%0\n+   mov %1,%0\\;add %2,%0\"\n+  [(set_attr \"length\" \"2,4,6\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+;; ----------------------------------------------------------------------\n+;; SUBTRACT INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"0,r\")\n+\t\t  (match_operand:SI 2 \"register_operand\" \"r,0\")))]\n+  \"\"\n+  \"@\n+  sub %2,%0\n+  subr %1,%0\"\n+  [(set_attr \"length\" \"2,2\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (neg:SI (match_operand:SI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"subr %.,%0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+;; ----------------------------------------------------------------------\n+;; MULTIPLY INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_expand \"mulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(mult:SI\n+\t  (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"\"))\n+\t  (sign_extend:SI (match_operand:HI 2 \"nonmemory_operand\" \"\"))))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*mulhisi3_internal1\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mult:SI\n+\t  (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n+\t  (sign_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"mulh %2,%0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"mult\")])\n+\n+(define_insn \"*mulhisi3_internal2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(mult:SI\n+\t  (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"%0,r\"))\n+\t  (sign_extend:SI (match_operand 2 \"const_int_operand\" \"J,K\"))))]\n+  \"\"\n+  \"@\n+   mulh %2,%0\n+   mulhi %2,%1,%0\"\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"cc\" \"none_0hit,none_0hit\")\n+   (set_attr \"type\" \"mult\")])\n+\n+\f\n+;; ----------------------------------------------------------------------\n+;; AND INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"*v850_clr1_1\"\n+  [(set (match_operand:QI 0 \"memory_operand\" \"=m\")\n+\t(subreg:QI\n+\t  (and:SI (subreg:SI (match_dup 0) 0)\n+\t\t  (match_operand:QI 1 \"not_power_of_two_operand\" \"\")) 0))]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[2];\n+  xoperands[0] = operands[0];\n+  xoperands[1] = GEN_INT (~INTVAL (operands[1]) & 0xff);\n+  output_asm_insn (\\\"clr1 %M1,%0\\\", xoperands);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"*v850_clr1_2\"\n+  [(set (match_operand:HI 0 \"memory_operand\" \"=m\")\n+\t(subreg:HI\n+\t  (and:SI (subreg:SI (match_dup 0) 0)\n+\t\t  (match_operand:HI 1 \"not_power_of_two_operand\" \"\")) 0))]\n+  \"\"\n+  \"*\n+{\n+  int log2 = exact_log2 (~INTVAL (operands[1]) & 0xffff);\n+\n+  rtx xoperands[2];\n+  xoperands[0] = gen_rtx (MEM, QImode,\n+\t\t\t  plus_constant (XEXP (operands[0], 0), log2 / 8));\n+  xoperands[1] = GEN_INT (log2 % 8);\n+  output_asm_insn (\\\"clr1 %1,%0\\\", xoperands);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"*v850_clr1_3\"\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+\t(and:SI (match_dup 0)\n+\t\t(match_operand:SI 1 \"not_power_of_two_operand\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  int log2 = exact_log2 (~INTVAL (operands[1]) & 0xffffffff);\n+\n+  rtx xoperands[2];\n+  xoperands[0] = gen_rtx (MEM, QImode,\n+\t\t\t  plus_constant (XEXP (operands[0], 0), log2 / 8));\n+  xoperands[1] = GEN_INT (log2 % 8);\n+  output_asm_insn (\\\"clr1 %1,%0\\\", xoperands);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0,r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,I,M\")))]\n+  \"\"\n+  \"@\n+  and %2,%0\n+  and %.,%0\n+  andi %2,%1,%0\"\n+  [(set_attr \"length\" \"2,2,4\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+;; ----------------------------------------------------------------------\n+;; OR INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"*v850_set1_1\"\n+  [(set (match_operand:QI 0 \"memory_operand\" \"=m\")\n+\t(subreg:QI (ior:SI (subreg:SI (match_dup 0) 0)\n+\t\t\t   (match_operand 1 \"power_of_two_operand\" \"\")) 0))]\n+  \"\"\n+  \"set1 %M1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"*v850_set1_2\"\n+  [(set (match_operand:HI 0 \"memory_operand\" \"=m\")\n+\t(subreg:HI (ior:SI (subreg:SI (match_dup 0) 0)\n+\t\t\t   (match_operand 1 \"power_of_two_operand\" \"\")) 0))]\n+  \"\"\n+  \"*\n+{\n+  int log2 = exact_log2 (INTVAL (operands[1]));\n+\n+  if (log2 < 8)\n+    return \\\"set1 %M1,%0\\\";\n+  else\n+    {\n+      rtx xoperands[2];\n+      xoperands[0] = gen_rtx (MEM, QImode,\n+\t\t\t      plus_constant (XEXP (operands[0], 0), log2 / 8));\n+      xoperands[1] = GEN_INT (log2 % 8);\n+      output_asm_insn (\\\"set1 %1,%0\\\", xoperands);\n+    }\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"*v850_set1_3\"\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+\t(ior:SI (match_dup 0)\n+\t\t(match_operand 1 \"power_of_two_operand\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  int log2 = exact_log2 (INTVAL (operands[1]));\n+\n+  if (log2 < 8)\n+    return \\\"set1 %M1,%0\\\";\n+  else\n+    {\n+      rtx xoperands[2];\n+      xoperands[0] = gen_rtx (MEM, QImode,\n+\t\t\t      plus_constant (XEXP (operands[0], 0), log2 / 8));\n+      xoperands[1] = GEN_INT (log2 % 8);\n+      output_asm_insn (\\\"set1 %1,%0\\\", xoperands);\n+    }\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0,r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,I,M\")))]\n+  \"\"\n+  \"@\n+  or %2,%0\n+  or %.,%0\n+  ori %2,%1,%0\"\n+  [(set_attr \"length\" \"2,2,4\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+;; ----------------------------------------------------------------------\n+;; XOR INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"*v850_not1_1\"\n+  [(set (match_operand:QI 0 \"memory_operand\" \"=m\")\n+\t(subreg:QI (xor:SI (subreg:SI (match_dup 0) 0)\n+\t\t\t   (match_operand 1 \"power_of_two_operand\" \"\")) 0))]\n+  \"\"\n+  \"not1 %M1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"*v850_not1_2\"\n+  [(set (match_operand:HI 0 \"memory_operand\" \"=m\")\n+\t(subreg:HI (xor:SI (subreg:SI (match_dup 0) 0)\n+\t\t\t   (match_operand 1 \"power_of_two_operand\" \"\")) 0))]\n+  \"\"\n+  \"*\n+{\n+  int log2 = exact_log2 (INTVAL (operands[1]));\n+\n+  if (log2 < 8)\n+    return \\\"not1 %M1,%0\\\";\n+  else\n+    {\n+      rtx xoperands[2];\n+      xoperands[0] = gen_rtx (MEM, QImode,\n+\t\t\t      plus_constant (XEXP (operands[0], 0), log2 / 8));\n+      xoperands[1] = GEN_INT (log2 % 8);\n+      output_asm_insn (\\\"not1 %1,%0\\\", xoperands);\n+    }\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"*v850_not1_3\"\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+\t(xor:SI (match_dup 0)\n+\t\t(match_operand 1 \"power_of_two_operand\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  int log2 = exact_log2 (INTVAL (operands[1]));\n+\n+  if (log2 < 8)\n+    return \\\"not1 %M1,%0\\\";\n+  else\n+    {\n+      rtx xoperands[2];\n+      xoperands[0] = gen_rtx (MEM, QImode,\n+\t\t\t      plus_constant (XEXP (operands[0], 0), log2 / 8));\n+      xoperands[1] = GEN_INT (log2 % 8);\n+      output_asm_insn (\\\"not1 %1,%0\\\", xoperands);\n+    }\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,0,r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,I,M\")))]\n+  \"\"\n+  \"@\n+  xor %2,%0\n+  xor %.,%0\n+  xori %2,%1,%0\"\n+  [(set_attr \"length\" \"2,2,4\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\f\n+;; ----------------------------------------------------------------------\n+;; NOT INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"not %1,%0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\f\n+;; -----------------------------------------------------------------\n+;; BIT FIELDS\n+;; -----------------------------------------------------------------\n+;; Is it worth defining insv and extv for the V850 series?!?\n+\n+;; -----------------------------------------------------------------\n+;; Scc INSTRUCTIONS\n+;; -----------------------------------------------------------------\n+\n+(define_insn \"sle\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (le:SI (cc0) (const_int 0)))]\n+  \"\"\n+  \"*\n+{\n+  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0)\n+    return 0;\n+\n+  return \\\"setf le,%0\\\";\n+}\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"sleu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (leu:SI (cc0) (const_int 0)))]\n+  \"\"\n+  \"setf nh,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"sge\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (ge:SI (cc0) (const_int 0)))]\n+  \"\"\n+  \"*\n+{\n+  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0)\n+    return 0;\n+\n+  return \\\"setf ge,%0\\\";\n+}\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"sgeu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (geu:SI (cc0) (const_int 0)))]\n+  \"\"\n+  \"setf nl,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"slt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (lt:SI (cc0) (const_int 0)))]\n+  \"\"\n+  \"*\n+{\n+  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0)\n+    return 0;\n+\n+  return \\\"setf lt,%0\\\";\n+}\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"sltu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (ltu:SI (cc0) (const_int 0)))]\n+  \"\"\n+  \"setf l,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"sgt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (gt:SI (cc0) (const_int 0)))]\n+  \"\"\n+  \"*\n+{\n+  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0)\n+    return 0;\n+\n+  return \\\"setf gt,%0\\\";\n+}\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"sgtu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (gtu:SI (cc0) (const_int 0)))]\n+  \"\"\n+  \"setf h,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"seq\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (eq:SI (cc0) (const_int 0)))]\n+  \"\"\n+  \"setf z,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"sne\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (ne:SI (cc0) (const_int 0)))]\n+  \"\"\n+  \"setf nz,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n+\f\n+;; ----------------------------------------------------------------------\n+;; JUMP INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+;; Conditional jump instructions\n+\n+(define_expand \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*branch_normal\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"comparison_operator\"\n+\t\t\t\t      [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+{\n+  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0\n+      && (GET_CODE (operands[1]) == GT\n+\t  || GET_CODE (operands[1]) == GE\n+\t  || GET_CODE (operands[1]) == LE\n+\t  || GET_CODE (operands[1]) == LT))\n+    return 0;\n+\n+  if (get_attr_length (insn) == 2)\n+    return \\\"%b1 %l0\\\";\n+  else\n+    return \\\"%B1 .+6\\;jr %l0\\\";\n+}\"\n+ [(set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 0) (pc)))\n+\t\t      (const_int 256))\n+\t\t  (const_int 2)\n+\t\t  (const_int 6)))\n+  (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"*branch_invert\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"comparison_operator\"\n+\t\t\t\t      [(cc0) (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0\n+      && (GET_CODE (operands[1]) == GT\n+\t  || GET_CODE (operands[1]) == GE\n+\t  || GET_CODE (operands[1]) == LE\n+\t  || GET_CODE (operands[1]) == LT))\n+    return 0;\n+  if (get_attr_length (insn) == 2)\n+    return \\\"%B1 %l0\\\";\n+  else\n+    return \\\"%b1 .+6\\;jr %l0\\\";\n+}\"\n+ [(set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 0) (pc)))\n+\t\t      (const_int 256))\n+\t\t  (const_int 2)\n+\t\t  (const_int 6)))\n+  (set_attr \"cc\" \"none\")])\n+\n+;; Unconditional and other jump instructions.\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  if (get_attr_length (insn) == 2)\n+    return \\\"br %0\\\";\n+  else\n+    return \\\"jr %0\\\";\n+}\"\n+ [(set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 0) (pc)))\n+\t\t      (const_int 256))\n+\t\t  (const_int 2)\n+\t\t  (const_int 4)))\n+  (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"jmp %0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"tablejump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"jmp  %0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"none\")])\n+\n+;; Call subroutine with no return value.\n+\n+(define_expand \"call\"\n+  [(call (match_operand:QI 0 \"general_operand\" \"\")\n+\t (match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (! call_address_operand (XEXP (operands[0], 0))\n+      || TARGET_LONG_CALLS)\n+    XEXP (operands[0], 0) = force_reg (SImode, XEXP (operands[0], 0));\n+  emit_call_insn (gen_call_internal (XEXP (operands[0], 0), operands[1]));\n+  DONE;\n+}\")\n+\n+(define_insn \"call_internal\"\n+  [(call (mem:QI (match_operand:SI 0 \"call_address_operand\" \"S,r\"))\n+\t (match_operand:SI 1 \"general_operand\" \"g,g\"))\n+   (clobber (reg:SI 31))]\n+  \"\"\n+  \"@\n+  jarl %0,r31\n+  jarl .+4,r31\\\\n\\\\tadd 4,r31\\\\n\\\\tjmp %0\"\n+  [(set_attr \"length\" \"4,8\")])\n+\n+;; Call subroutine, returning value in operand 0\n+;; (which must be a hard register).\n+\n+(define_expand \"call_value\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (match_operand:QI 1 \"general_operand\" \"\")\n+\t      (match_operand:SI 2 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (! call_address_operand (XEXP (operands[1], 0))\n+      || TARGET_LONG_CALLS)\n+    XEXP (operands[1], 0) = force_reg (SImode, XEXP (operands[1], 0));\n+  emit_call_insn (gen_call_value_internal (operands[0],\n+\t\t\t\t\t   XEXP (operands[1], 0),\n+\t\t\t\t\t   operands[2]));\n+  DONE;\n+}\")\n+\n+(define_insn \"call_value_internal\"\n+  [(set (match_operand 0 \"\" \"=r,r\")\n+\t(call (mem:QI (match_operand:SI 1 \"call_address_operand\" \"S,r\"))\n+\t      (match_operand:SI 2 \"general_operand\" \"g,g\")))\n+   (clobber (reg:SI 31))]\n+  \"\"\n+  \"@\n+  jarl %1,r31\n+  jarl .+4,r31\\\\n\\\\tadd 4,r31\\\\n\\\\tjmp %1\"\n+  [(set_attr \"length\" \"4,8\")])\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"none\")])\n+\f\n+;; ----------------------------------------------------------------------\n+;; EXTEND INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI\n+\t (match_operand:HI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"andi 65535,%1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI\n+\t (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"andi 255,%1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+;;- sign extension instructions\n+\n+(define_expand \"extendhisi2\"\n+  [(set (match_dup 2)\n+        (ashift:SI (match_operand:HI 1 \"register_operand\" \"\")\n+                   (const_int 16)))\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+        (ashiftrt:SI (match_dup 2)\n+                     (const_int 16)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_lowpart (SImode, operands[1]);\n+  operands[2] = gen_reg_rtx (SImode);\n+}\")\n+\n+(define_expand \"extendqisi2\"\n+  [(set (match_dup 2)\n+        (ashift:SI (match_operand:QI 1 \"register_operand\" \"\")\n+                   (const_int 24)))\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+        (ashiftrt:SI (match_dup 2)\n+                     (const_int 24)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_lowpart (SImode, operands[1]);\n+  operands[2] = gen_reg_rtx (SImode);\n+}\")\n+\f\n+;; ----------------------------------------------------------------------\n+;; SHIFTS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ashift:SI\n+\t (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t (match_operand:QI 2 \"nonmemory_operand\" \"r,N\")))]\n+  \"\"\n+  \"@\n+  shl %2,%0\n+  shl %2,%0\"\n+  [(set_attr \"length\" \"4,2\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(lshiftrt:SI\n+\t (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t (match_operand:QI 2 \"nonmemory_operand\" \"r,J\")))]\n+  \"\"\n+  \"@\n+  shr %2,%0\n+  shr %2,%0\"\n+  [(set_attr \"length\" \"4,2\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ashiftrt:SI\n+\t (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t (match_operand:SI 2 \"nonmemory_operand\" \"r,N\")))]\n+  \"\"\n+  \"@\n+  sar %2,%0\n+  sar %2,%0\"\n+  [(set_attr \"length\" \"4,2\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+;; ----------------------------------------------------------------------\n+;; PROLOGUE/EPILOGUE\n+;; ----------------------------------------------------------------------\n+(define_expand \"prologue\"\n+  [(const_int 0)]\n+  \"\"\n+  \"expand_prologue (); DONE;\")\n+\n+(define_expand \"epilogue\"\n+  [(return)]\n+  \"\"\n+  \"\n+{\n+  /* Try to use the trivial return first.  Else use the\n+     full epilogue.  */\n+  if (0)\n+    emit_jump_insn (gen_return ());\n+  else\n+    expand_epilogue ();\n+  DONE;\n+}\")\n+\n+(define_insn \"return\"\n+  [(return)]\n+  \"reload_completed && compute_frame_size (get_frame_size (), (long *)0) == 0\"\n+  \"jmp [r31]\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"return_internal\"\n+  [(return)\n+   (use (reg:SI 31))]\n+  \"\"\n+  \"jmp [r31]\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"none\")])\n+\n+\n+\f\n+;; ----------------------------------------------------------------------\n+;; HELPER INSTRUCTIONS for saving the prologue and epilog registers\n+;; ----------------------------------------------------------------------\n+\n+;; Save r2, r20-r29, r31, and create 16 byte register call area\n+(define_insn \"save_r2_r31\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -64)))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -16))) (reg:SI 2))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -20))) (reg:SI 20))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -24))) (reg:SI 21))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -28))) (reg:SI 22))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -32))) (reg:SI 23))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -36))) (reg:SI 24))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -40))) (reg:SI 25))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -44))) (reg:SI 26))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -48))) (reg:SI 27))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -52))) (reg:SI 28))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -56))) (reg:SI 29))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -60))) (reg:SI 31))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r2_r31,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save r20-r29, r31, and create 16 byte register call area\n+(define_insn \"save_r20_r31\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -60)))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -16))) (reg:SI 20))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -20))) (reg:SI 21))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -24))) (reg:SI 22))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -28))) (reg:SI 23))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -32))) (reg:SI 24))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -36))) (reg:SI 25))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -40))) (reg:SI 26))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -44))) (reg:SI 27))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -48))) (reg:SI 28))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -52))) (reg:SI 29))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -56))) (reg:SI 31))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r20_r31,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save r21-r29, r31, and create 16 byte register call area\n+(define_insn \"save_r21_r31\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -56)))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -16))) (reg:SI 21))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -20))) (reg:SI 22))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -24))) (reg:SI 23))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -28))) (reg:SI 24))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -32))) (reg:SI 25))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -36))) (reg:SI 26))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -40))) (reg:SI 27))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -44))) (reg:SI 28))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -48))) (reg:SI 29))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -52))) (reg:SI 31))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r21_r31,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save r22-r29, r31, and create 16 byte register call area\n+(define_insn \"save_r22_r31\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -52)))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -16))) (reg:SI 22))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -20))) (reg:SI 23))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -24))) (reg:SI 24))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -28))) (reg:SI 25))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -32))) (reg:SI 26))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -36))) (reg:SI 27))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -40))) (reg:SI 28))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -44))) (reg:SI 29))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -48))) (reg:SI 31))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r22_r31,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save r23-r29, r31, and create 16 byte register call area\n+(define_insn \"save_r23_r31\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -48)))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -16))) (reg:SI 23))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -20))) (reg:SI 24))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -24))) (reg:SI 25))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -28))) (reg:SI 26))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -32))) (reg:SI 27))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -36))) (reg:SI 28))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -40))) (reg:SI 29))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -44))) (reg:SI 31))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r23_r31,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save r24-r29, r31, and create 16 byte register call area\n+(define_insn \"save_r24_r31\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -44)))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -16))) (reg:SI 24))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -20))) (reg:SI 25))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -24))) (reg:SI 26))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -28))) (reg:SI 27))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -32))) (reg:SI 28))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -36))) (reg:SI 29))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -40))) (reg:SI 31))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r24_r31,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save r25-r29, r31, and create 16 byte register call area\n+(define_insn \"save_r25_r31\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -40)))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -16))) (reg:SI 25))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -20))) (reg:SI 26))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -24))) (reg:SI 27))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -28))) (reg:SI 28))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -32))) (reg:SI 29))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -36))) (reg:SI 31))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r25_r31,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save r26-r29, r31, and create 16 byte register call area\n+(define_insn \"save_r26_r31\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -36)))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -16))) (reg:SI 26))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -20))) (reg:SI 27))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -24))) (reg:SI 28))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -28))) (reg:SI 29))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -32))) (reg:SI 31))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r26_r31,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save r27-r29, r31, and create 16 byte register call area\n+(define_insn \"save_r27_r31\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -32)))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -16))) (reg:SI 27))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -20))) (reg:SI 28))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -24))) (reg:SI 29))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -28))) (reg:SI 31))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r27_r31,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save r28-r29, r31, and create 16 byte register call area\n+(define_insn \"save_r28_r31\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -28)))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -16))) (reg:SI 28))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -20))) (reg:SI 29))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -24))) (reg:SI 31))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r28_r31,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save r29, r31, and create 16 byte register call area\n+(define_insn \"save_r29_r31\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -24)))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -16))) (reg:SI 29))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -20))) (reg:SI 31))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r29_r31,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save r31, and create 16 byte register call area\n+(define_insn \"save_r31\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -20)))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -16))) (reg:SI 31))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r31,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save r2, r20-r29\n+(define_insn \"save_r2_r29\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -44)))\n+   (set (mem:SI (reg:SI 3)) (reg:SI 2))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -4))) (reg:SI 20))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -8))) (reg:SI 21))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -12))) (reg:SI 22))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -16))) (reg:SI 23))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -20))) (reg:SI 24))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -24))) (reg:SI 25))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -28))) (reg:SI 26))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -32))) (reg:SI 27))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -36))) (reg:SI 28))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -40))) (reg:SI 29))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r2_r29,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save r20-r29\n+(define_insn \"save_r20_r29\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -40)))\n+   (set (mem:SI (reg:SI 3)) (reg:SI 20))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -4))) (reg:SI 21))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -8))) (reg:SI 22))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -12))) (reg:SI 23))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -16))) (reg:SI 24))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -20))) (reg:SI 25))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -24))) (reg:SI 26))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -28))) (reg:SI 27))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -32))) (reg:SI 28))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -36))) (reg:SI 29))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r20_r29,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save r21-r29\n+(define_insn \"save_r21_r29\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -36)))\n+   (set (mem:SI (reg:SI 3)) (reg:SI 21))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -4))) (reg:SI 22))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -8))) (reg:SI 23))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -12))) (reg:SI 24))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -16))) (reg:SI 25))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -20))) (reg:SI 26))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -24))) (reg:SI 27))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -28))) (reg:SI 28))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -32))) (reg:SI 29))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r21_r29,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save r22-r29\n+(define_insn \"save_r22_r29\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -32)))\n+   (set (mem:SI (reg:SI 3)) (reg:SI 22))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -4))) (reg:SI 23))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -8))) (reg:SI 24))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -12))) (reg:SI 25))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -16))) (reg:SI 26))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -20))) (reg:SI 27))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -24))) (reg:SI 28))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -28))) (reg:SI 29))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r22_r29,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save r23-r29\n+(define_insn \"save_r23_r29\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -28)))\n+   (set (mem:SI (reg:SI 3)) (reg:SI 23))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -4))) (reg:SI 24))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -8))) (reg:SI 25))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -12))) (reg:SI 26))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -16))) (reg:SI 27))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -20))) (reg:SI 28))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -24))) (reg:SI 29))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r23_r29,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save r24-r29\n+(define_insn \"save_r24_r29\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -24)))\n+   (set (mem:SI (reg:SI 3)) (reg:SI 24))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -4))) (reg:SI 25))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -8))) (reg:SI 26))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -12))) (reg:SI 27))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -16))) (reg:SI 28))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -20))) (reg:SI 29))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r24_r29,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save r25-r29\n+(define_insn \"save_r25_r29\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -20)))\n+   (set (mem:SI (reg:SI 3)) (reg:SI 25))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -4))) (reg:SI 26))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -8))) (reg:SI 27))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -12))) (reg:SI 28))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -16))) (reg:SI 29))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r25_r29,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save r26-r29\n+(define_insn \"save_r26_r29\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -16)))\n+   (set (mem:SI (reg:SI 3)) (reg:SI 26))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -4))) (reg:SI 27))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -8))) (reg:SI 28))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -12))) (reg:SI 29))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r26_r29,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save r27-r29\n+(define_insn \"save_r27_r29\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -12)))\n+   (set (mem:SI (reg:SI 3)) (reg:SI 27))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -4))) (reg:SI 28))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -8))) (reg:SI 29))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r27_r29,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save r28-r29\n+(define_insn \"save_r28_r29\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -8)))\n+   (set (mem:SI (reg:SI 3)) (reg:SI 28))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -4))) (reg:SI 29))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r28_r29,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save r29\n+(define_insn \"save_r29\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -4)))\n+   (set (mem:SI (reg:SI 3)) (reg:SI 29))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r29,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Initialize an interrupt function.  Do not depend on TARGET_PROLOG_FUNCTION.\n+(define_insn \"save_interrupt\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -16)))\n+   (set (mem:SI (reg:SI 3)) (reg:SI 30))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -4))) (reg:SI 10))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -8))) (reg:SI 5))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -12))) (reg:SI 1))]\n+  \"\"\n+  \"add -16,sp\\;st.w r10,12[sp]\\;jarl __save_interrupt,r10\"\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save all registers except for the registers saved in save_interrupt when\n+;; an interrupt function makes a call.\n+;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n+;; all of memory.  This blocks insns from being moved across this point.\n+;; This is needed because the rest of the compiler is not reading to handle\n+;; insns this compilcated\n+\n+(define_insn \"save_all_interrupt\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"\"\n+  \"jarl __save_all_interrupt,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r2, r20-r29, r31, eliminate 16 byte register call area, and return to user\n+(define_insn \"restore_r2_r31\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 64)))\n+   (set (reg:SI 2) (mem:SI (plus:SI (reg:SI 3) (const_int 60))))\n+   (set (reg:SI 20) (mem:SI (plus:SI (reg:SI 3) (const_int 56))))\n+   (set (reg:SI 21) (mem:SI (plus:SI (reg:SI 3) (const_int 52))))\n+   (set (reg:SI 22) (mem:SI (plus:SI (reg:SI 3) (const_int 48))))\n+   (set (reg:SI 23) (mem:SI (plus:SI (reg:SI 3) (const_int 44))))\n+   (set (reg:SI 24) (mem:SI (plus:SI (reg:SI 3) (const_int 40))))\n+   (set (reg:SI 25) (mem:SI (plus:SI (reg:SI 3) (const_int 36))))\n+   (set (reg:SI 26) (mem:SI (plus:SI (reg:SI 3) (const_int 32))))\n+   (set (reg:SI 27) (mem:SI (plus:SI (reg:SI 3) (const_int 28))))\n+   (set (reg:SI 28) (mem:SI (plus:SI (reg:SI 3) (const_int 24))))\n+   (set (reg:SI 29) (mem:SI (plus:SI (reg:SI 3) (const_int 20))))\n+   (set (reg:SI 31) (mem:SI (plus:SI (reg:SI 3) (const_int 16))))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jr __return_r2_r31\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r20-r29, r31, eliminate 16 byte register call area, and return to user\n+(define_insn \"restore_r20_r31\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 60)))\n+   (set (reg:SI 20) (mem:SI (plus:SI (reg:SI 3) (const_int 56))))\n+   (set (reg:SI 21) (mem:SI (plus:SI (reg:SI 3) (const_int 52))))\n+   (set (reg:SI 22) (mem:SI (plus:SI (reg:SI 3) (const_int 48))))\n+   (set (reg:SI 23) (mem:SI (plus:SI (reg:SI 3) (const_int 44))))\n+   (set (reg:SI 24) (mem:SI (plus:SI (reg:SI 3) (const_int 40))))\n+   (set (reg:SI 25) (mem:SI (plus:SI (reg:SI 3) (const_int 36))))\n+   (set (reg:SI 26) (mem:SI (plus:SI (reg:SI 3) (const_int 32))))\n+   (set (reg:SI 27) (mem:SI (plus:SI (reg:SI 3) (const_int 28))))\n+   (set (reg:SI 28) (mem:SI (plus:SI (reg:SI 3) (const_int 24))))\n+   (set (reg:SI 29) (mem:SI (plus:SI (reg:SI 3) (const_int 20))))\n+   (set (reg:SI 31) (mem:SI (plus:SI (reg:SI 3) (const_int 16))))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jr __return_r20_r31\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r21-r29, r31, eliminate 16 byte register call area, and return to user\n+(define_insn \"restore_r21_r31\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 56)))\n+   (set (reg:SI 21) (mem:SI (plus:SI (reg:SI 3) (const_int 52))))\n+   (set (reg:SI 22) (mem:SI (plus:SI (reg:SI 3) (const_int 48))))\n+   (set (reg:SI 23) (mem:SI (plus:SI (reg:SI 3) (const_int 44))))\n+   (set (reg:SI 24) (mem:SI (plus:SI (reg:SI 3) (const_int 40))))\n+   (set (reg:SI 25) (mem:SI (plus:SI (reg:SI 3) (const_int 36))))\n+   (set (reg:SI 26) (mem:SI (plus:SI (reg:SI 3) (const_int 32))))\n+   (set (reg:SI 27) (mem:SI (plus:SI (reg:SI 3) (const_int 28))))\n+   (set (reg:SI 28) (mem:SI (plus:SI (reg:SI 3) (const_int 24))))\n+   (set (reg:SI 29) (mem:SI (plus:SI (reg:SI 3) (const_int 20))))\n+   (set (reg:SI 31) (mem:SI (plus:SI (reg:SI 3) (const_int 16))))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jr __return_r21_r31\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r22-r29, r31, eliminate 16 byte register call area, and return to user\n+(define_insn \"restore_r22_r31\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 52)))\n+   (set (reg:SI 22) (mem:SI (plus:SI (reg:SI 3) (const_int 48))))\n+   (set (reg:SI 23) (mem:SI (plus:SI (reg:SI 3) (const_int 44))))\n+   (set (reg:SI 24) (mem:SI (plus:SI (reg:SI 3) (const_int 40))))\n+   (set (reg:SI 25) (mem:SI (plus:SI (reg:SI 3) (const_int 36))))\n+   (set (reg:SI 26) (mem:SI (plus:SI (reg:SI 3) (const_int 32))))\n+   (set (reg:SI 27) (mem:SI (plus:SI (reg:SI 3) (const_int 28))))\n+   (set (reg:SI 28) (mem:SI (plus:SI (reg:SI 3) (const_int 24))))\n+   (set (reg:SI 29) (mem:SI (plus:SI (reg:SI 3) (const_int 20))))\n+   (set (reg:SI 31) (mem:SI (plus:SI (reg:SI 3) (const_int 16))))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jr __return_r22_r31\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r23-r29, r31, eliminate 16 byte register call area, and return to user\n+(define_insn \"restore_r23_r31\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 48)))\n+   (set (reg:SI 23) (mem:SI (plus:SI (reg:SI 3) (const_int 44))))\n+   (set (reg:SI 24) (mem:SI (plus:SI (reg:SI 3) (const_int 40))))\n+   (set (reg:SI 25) (mem:SI (plus:SI (reg:SI 3) (const_int 36))))\n+   (set (reg:SI 26) (mem:SI (plus:SI (reg:SI 3) (const_int 32))))\n+   (set (reg:SI 27) (mem:SI (plus:SI (reg:SI 3) (const_int 28))))\n+   (set (reg:SI 28) (mem:SI (plus:SI (reg:SI 3) (const_int 24))))\n+   (set (reg:SI 29) (mem:SI (plus:SI (reg:SI 3) (const_int 20))))\n+   (set (reg:SI 31) (mem:SI (plus:SI (reg:SI 3) (const_int 16))))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jr __return_r23_r31\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r24-r29, r31, eliminate 16 byte register call area, and return to user\n+(define_insn \"restore_r24_r31\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 44)))\n+   (set (reg:SI 24) (mem:SI (plus:SI (reg:SI 3) (const_int 40))))\n+   (set (reg:SI 25) (mem:SI (plus:SI (reg:SI 3) (const_int 36))))\n+   (set (reg:SI 26) (mem:SI (plus:SI (reg:SI 3) (const_int 32))))\n+   (set (reg:SI 27) (mem:SI (plus:SI (reg:SI 3) (const_int 28))))\n+   (set (reg:SI 28) (mem:SI (plus:SI (reg:SI 3) (const_int 24))))\n+   (set (reg:SI 29) (mem:SI (plus:SI (reg:SI 3) (const_int 20))))\n+   (set (reg:SI 31) (mem:SI (plus:SI (reg:SI 3) (const_int 16))))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jr __return_r24_r31\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r25-r29, r31, eliminate 16 byte register call area, and return to user\n+(define_insn \"restore_r25_r31\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 40)))\n+   (set (reg:SI 25) (mem:SI (plus:SI (reg:SI 3) (const_int 36))))\n+   (set (reg:SI 26) (mem:SI (plus:SI (reg:SI 3) (const_int 32))))\n+   (set (reg:SI 27) (mem:SI (plus:SI (reg:SI 3) (const_int 28))))\n+   (set (reg:SI 28) (mem:SI (plus:SI (reg:SI 3) (const_int 24))))\n+   (set (reg:SI 29) (mem:SI (plus:SI (reg:SI 3) (const_int 20))))\n+   (set (reg:SI 31) (mem:SI (plus:SI (reg:SI 3) (const_int 16))))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jr __return_r25_r31\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r26-r29, r31, eliminate 16 byte register call area, and return to user\n+(define_insn \"restore_r26_r31\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 36)))\n+   (set (reg:SI 26) (mem:SI (plus:SI (reg:SI 3) (const_int 32))))\n+   (set (reg:SI 27) (mem:SI (plus:SI (reg:SI 3) (const_int 28))))\n+   (set (reg:SI 28) (mem:SI (plus:SI (reg:SI 3) (const_int 24))))\n+   (set (reg:SI 29) (mem:SI (plus:SI (reg:SI 3) (const_int 20))))\n+   (set (reg:SI 31) (mem:SI (plus:SI (reg:SI 3) (const_int 16))))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jr __return_r26_r31\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r27-r29, r31, eliminate 16 byte register call area, and return to user\n+(define_insn \"restore_r27_r31\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 32)))\n+   (set (reg:SI 27) (mem:SI (plus:SI (reg:SI 3) (const_int 28))))\n+   (set (reg:SI 28) (mem:SI (plus:SI (reg:SI 3) (const_int 24))))\n+   (set (reg:SI 29) (mem:SI (plus:SI (reg:SI 3) (const_int 20))))\n+   (set (reg:SI 31) (mem:SI (plus:SI (reg:SI 3) (const_int 16))))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jr __return_r27_r31\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r28-r29, r31, eliminate 16 byte register call area, and return to user\n+(define_insn \"restore_r28_r31\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 28)))\n+   (set (reg:SI 28) (mem:SI (plus:SI (reg:SI 3) (const_int 24))))\n+   (set (reg:SI 29) (mem:SI (plus:SI (reg:SI 3) (const_int 20))))\n+   (set (reg:SI 31) (mem:SI (plus:SI (reg:SI 3) (const_int 16))))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jr __return_r28_r31\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r29, r31, eliminate 16 byte register call area, and return to user\n+(define_insn \"restore_r29_r31\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 24)))\n+   (set (reg:SI 29) (mem:SI (plus:SI (reg:SI 3) (const_int 20))))\n+   (set (reg:SI 31) (mem:SI (plus:SI (reg:SI 3) (const_int 16))))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jr __return_r29_r31\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r31, eliminate 16 byte register call area, and return to user\n+(define_insn \"restore_r31\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 20)))\n+   (set (reg:SI 31) (mem:SI (plus:SI (reg:SI 3) (const_int 16))))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jr __return_r31\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r2, r20-r29, and return to user\n+(define_insn \"restore_r2_r29\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 48)))\n+   (set (reg:SI 2) (mem:SI (plus:SI (reg:SI 3) (const_int 44))))\n+   (set (reg:SI 20) (mem:SI (plus:SI (reg:SI 3) (const_int 40))))\n+   (set (reg:SI 21) (mem:SI (plus:SI (reg:SI 3) (const_int 36))))\n+   (set (reg:SI 22) (mem:SI (plus:SI (reg:SI 3) (const_int 32))))\n+   (set (reg:SI 23) (mem:SI (plus:SI (reg:SI 3) (const_int 28))))\n+   (set (reg:SI 24) (mem:SI (plus:SI (reg:SI 3) (const_int 24))))\n+   (set (reg:SI 25) (mem:SI (plus:SI (reg:SI 3) (const_int 20))))\n+   (set (reg:SI 26) (mem:SI (plus:SI (reg:SI 3) (const_int 16))))\n+   (set (reg:SI 27) (mem:SI (plus:SI (reg:SI 3) (const_int 12))))\n+   (set (reg:SI 28) (mem:SI (plus:SI (reg:SI 3) (const_int 8))))\n+   (set (reg:SI 29) (mem:SI (plus:SI (reg:SI 3) (const_int 4))))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jr __return_r2_r29\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r20-r29, and return to user\n+(define_insn \"restore_r20_r29\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 44)))\n+   (set (reg:SI 20) (mem:SI (plus:SI (reg:SI 3) (const_int 40))))\n+   (set (reg:SI 21) (mem:SI (plus:SI (reg:SI 3) (const_int 36))))\n+   (set (reg:SI 22) (mem:SI (plus:SI (reg:SI 3) (const_int 32))))\n+   (set (reg:SI 23) (mem:SI (plus:SI (reg:SI 3) (const_int 28))))\n+   (set (reg:SI 24) (mem:SI (plus:SI (reg:SI 3) (const_int 24))))\n+   (set (reg:SI 25) (mem:SI (plus:SI (reg:SI 3) (const_int 20))))\n+   (set (reg:SI 26) (mem:SI (plus:SI (reg:SI 3) (const_int 16))))\n+   (set (reg:SI 27) (mem:SI (plus:SI (reg:SI 3) (const_int 12))))\n+   (set (reg:SI 28) (mem:SI (plus:SI (reg:SI 3) (const_int 8))))\n+   (set (reg:SI 29) (mem:SI (plus:SI (reg:SI 3) (const_int 4))))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jr __return_r20_r29\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r21-r29, and return to user\n+(define_insn \"restore_r21_r29\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 40)))\n+   (set (reg:SI 21) (mem:SI (plus:SI (reg:SI 3) (const_int 36))))\n+   (set (reg:SI 22) (mem:SI (plus:SI (reg:SI 3) (const_int 32))))\n+   (set (reg:SI 23) (mem:SI (plus:SI (reg:SI 3) (const_int 28))))\n+   (set (reg:SI 24) (mem:SI (plus:SI (reg:SI 3) (const_int 24))))\n+   (set (reg:SI 25) (mem:SI (plus:SI (reg:SI 3) (const_int 20))))\n+   (set (reg:SI 26) (mem:SI (plus:SI (reg:SI 3) (const_int 16))))\n+   (set (reg:SI 27) (mem:SI (plus:SI (reg:SI 3) (const_int 12))))\n+   (set (reg:SI 28) (mem:SI (plus:SI (reg:SI 3) (const_int 8))))\n+   (set (reg:SI 29) (mem:SI (plus:SI (reg:SI 3) (const_int 4))))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jr __return_r21_r29\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r22-r29, and return to user\n+(define_insn \"restore_r22_r29\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 36)))\n+   (set (reg:SI 22) (mem:SI (plus:SI (reg:SI 3) (const_int 32))))\n+   (set (reg:SI 23) (mem:SI (plus:SI (reg:SI 3) (const_int 28))))\n+   (set (reg:SI 24) (mem:SI (plus:SI (reg:SI 3) (const_int 24))))\n+   (set (reg:SI 25) (mem:SI (plus:SI (reg:SI 3) (const_int 20))))\n+   (set (reg:SI 26) (mem:SI (plus:SI (reg:SI 3) (const_int 16))))\n+   (set (reg:SI 27) (mem:SI (plus:SI (reg:SI 3) (const_int 12))))\n+   (set (reg:SI 28) (mem:SI (plus:SI (reg:SI 3) (const_int 8))))\n+   (set (reg:SI 29) (mem:SI (plus:SI (reg:SI 3) (const_int 4))))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jr __return_r22_r29\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r23-r29, and return to user\n+(define_insn \"restore_r23_r29\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 32)))\n+   (set (reg:SI 23) (mem:SI (plus:SI (reg:SI 3) (const_int 28))))\n+   (set (reg:SI 24) (mem:SI (plus:SI (reg:SI 3) (const_int 24))))\n+   (set (reg:SI 25) (mem:SI (plus:SI (reg:SI 3) (const_int 20))))\n+   (set (reg:SI 26) (mem:SI (plus:SI (reg:SI 3) (const_int 16))))\n+   (set (reg:SI 27) (mem:SI (plus:SI (reg:SI 3) (const_int 12))))\n+   (set (reg:SI 28) (mem:SI (plus:SI (reg:SI 3) (const_int 8))))\n+   (set (reg:SI 29) (mem:SI (plus:SI (reg:SI 3) (const_int 4))))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jr __return_r23_r29\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r24-r29, and return to user\n+(define_insn \"restore_r24_r29\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 28)))\n+   (set (reg:SI 24) (mem:SI (plus:SI (reg:SI 3) (const_int 24))))\n+   (set (reg:SI 25) (mem:SI (plus:SI (reg:SI 3) (const_int 20))))\n+   (set (reg:SI 26) (mem:SI (plus:SI (reg:SI 3) (const_int 16))))\n+   (set (reg:SI 27) (mem:SI (plus:SI (reg:SI 3) (const_int 12))))\n+   (set (reg:SI 28) (mem:SI (plus:SI (reg:SI 3) (const_int 8))))\n+   (set (reg:SI 29) (mem:SI (plus:SI (reg:SI 3) (const_int 4))))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jr __return_r24_r29\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r25-r29, and return to user\n+(define_insn \"restore_r25_r29\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 24)))\n+   (set (reg:SI 25) (mem:SI (plus:SI (reg:SI 3) (const_int 20))))\n+   (set (reg:SI 26) (mem:SI (plus:SI (reg:SI 3) (const_int 16))))\n+   (set (reg:SI 27) (mem:SI (plus:SI (reg:SI 3) (const_int 12))))\n+   (set (reg:SI 28) (mem:SI (plus:SI (reg:SI 3) (const_int 8))))\n+   (set (reg:SI 29) (mem:SI (plus:SI (reg:SI 3) (const_int 4))))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jr __return_r25_r29\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r26-r29, and return to user\n+(define_insn \"restore_r26_r29\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 20)))\n+   (set (reg:SI 26) (mem:SI (plus:SI (reg:SI 3) (const_int 16))))\n+   (set (reg:SI 27) (mem:SI (plus:SI (reg:SI 3) (const_int 12))))\n+   (set (reg:SI 28) (mem:SI (plus:SI (reg:SI 3) (const_int 8))))\n+   (set (reg:SI 29) (mem:SI (plus:SI (reg:SI 3) (const_int 4))))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jr __return_r26_r29\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r27-r29, and return to user\n+(define_insn \"restore_r27_r29\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 16)))\n+   (set (reg:SI 27) (mem:SI (plus:SI (reg:SI 3) (const_int 12))))\n+   (set (reg:SI 28) (mem:SI (plus:SI (reg:SI 3) (const_int 8))))\n+   (set (reg:SI 29) (mem:SI (plus:SI (reg:SI 3) (const_int 4))))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jr __return_r27_r29\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r28-r29, and return to user\n+(define_insn \"restore_r28_r29\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 12)))\n+   (set (reg:SI 28) (mem:SI (plus:SI (reg:SI 3) (const_int 8))))\n+   (set (reg:SI 29) (mem:SI (plus:SI (reg:SI 3) (const_int 4))))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jr __return_r28_r29\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r29, and return to user\n+(define_insn \"restore_r29\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 8)))\n+   (set (reg:SI 29) (mem:SI (plus:SI (reg:SI 3) (const_int 4))))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jr __return_r29\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore r1, r5, r10, and return from the interrupt\n+(define_insn \"restore_interrupt\"\n+  [(return)\n+   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 16)))\n+   (set (reg:SI 30) (mem:SI (plus:SI (reg:SI 3) (const_int 12))))\n+   (set (reg:SI 10) (mem:SI (plus:SI (reg:SI 3) (const_int 8))))\n+   (set (reg:SI 5)  (mem:SI (plus:SI (reg:SI 3) (const_int 4))))\n+   (set (reg:SI 1)  (mem:SI (reg:SI 3)))]\n+  \"\"\n+  \"jr __return_interrupt\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Restore all registers saved when an interrupt function makes a call.\n+;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n+;; all of memory.  This blocks insns from being moved across this point.\n+;; This is needed because the rest of the compiler is not reading to handle\n+;; insns this compilcated\n+\n+(define_insn \"restore_all_interrupt\"\n+  [(unspec_volatile [(const_int 0)] 1)]\n+  \"\"\n+  \"jarl __restore_all_interrupt,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Save r6-r9 for a variable argument function\n+(define_insn \"save_r6_r9\"\n+  [(set (mem:SI (reg:SI 3)) (reg:SI 6))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int 4))) (reg:SI 7))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int 8))) (reg:SI 8))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int 12))) (reg:SI 9))\n+   (clobber (reg:SI 10))]\n+  \"TARGET_PROLOG_FUNCTION\"\n+  \"jarl __save_r6_r9,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+;; END CYGNUS LOCAL"}, {"sha": "2d67cf81788210c1fbe25ef48e186b17b52c24a9", "filename": "gcc/config/v850/xm-v850.h", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae180d84fc7bb97b09fb67a1e478288d748e41fb/gcc%2Fconfig%2Fv850%2Fxm-v850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae180d84fc7bb97b09fb67a1e478288d748e41fb/gcc%2Fconfig%2Fv850%2Fxm-v850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fxm-v850.h?ref=ae180d84fc7bb97b09fb67a1e478288d748e41fb", "patch": "@@ -0,0 +1,51 @@\n+/* CYGNUS LOCAL entire file v850/law */\n+/* Configuration for NEC V850. \n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Contributed by Cygnus Support.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* #defines that need visibility everywhere.  */\n+#define FALSE 0\n+#define TRUE 1\n+\n+/* This describes the machine the compiler is hosted on.  */\n+#define HOST_BITS_PER_CHAR 8\n+#define HOST_BITS_PER_SHORT 16\n+#define HOST_BITS_PER_INT 32\n+#define HOST_BITS_PER_LONG 32\n+#define HOST_BITS_PER_LONGLONG 64\n+\n+/* Arguments to use with `exit'.  */\n+#define SUCCESS_EXIT_CODE 0\n+#define FATAL_EXIT_CODE 33\n+\n+#ifdef __v850__\n+#ifndef __STDC__\n+extern char *malloc (), *realloc (), *calloc ();\n+#else\n+extern void *malloc (), *realloc (), *calloc ();\n+#endif\n+extern void free ();\n+#endif\n+\n+/* target machine dependencies.\n+   tm.h is a symbolic link to the actual target specific file.   */\n+\n+#include \"tm.h\"\n+/* END CYGNUS LOCAL */"}]}