{"sha": "47aeffac9c6f9ec347293d4bcf8c0556c6db7f5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdhZWZmYWM5YzZmOWVjMzQ3MjkzZDRiY2Y4YzA1NTZjNmRiN2Y1Yw==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2003-12-01T22:59:30Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2003-12-01T22:59:30Z"}, "message": "ggc.h (struct alloc_zone): Move forward declaration up.\n\n\t* ggc.h (struct alloc_zone): Move forward declaration up.\n\t(new_ggc_zone): New function prototype.\n\t(destroy_ggc_zone): Ditto.\n\t* ggc-simple.c (new_ggc_zone): New function, does nothing.\n\t(destroy_ggc_zone): Ditto.\n\t* ggc-page.c (new_ggc_zone): New function, does nothing.\n\t(destroy_ggc_zone): Ditto.\n\t* ggc-zone.c (struct page_entry): Fix comment.\n\t(ggc_alloc_typed): Use a switch statement instead of ifs.\n\t(new_ggc_zone): New function to set up a new GC zone.\n\t(destroy_ggc_zone): New function to remove a GC zone.\n\tinit_ggc): Use new_ggc_zone to set up the default zones.\n\t(ggc_collect): Walk a list of zones, instead of just the\n\tdefault zones.  Report statistics using the zone name.\n\nFrom-SVN: r74132", "tree": {"sha": "828e8c449db658913176f3c52668d0d0325b655d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/828e8c449db658913176f3c52668d0d0325b655d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47aeffac9c6f9ec347293d4bcf8c0556c6db7f5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47aeffac9c6f9ec347293d4bcf8c0556c6db7f5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47aeffac9c6f9ec347293d4bcf8c0556c6db7f5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47aeffac9c6f9ec347293d4bcf8c0556c6db7f5c/comments", "author": null, "committer": null, "parents": [{"sha": "f26deb3d4478566f86a9aa21f54b08b457abe79c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f26deb3d4478566f86a9aa21f54b08b457abe79c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f26deb3d4478566f86a9aa21f54b08b457abe79c"}], "stats": {"total": 179, "additions": 128, "deletions": 51}, "files": [{"sha": "0507e0d679197b15969203c7d793cbc2833dcc8e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47aeffac9c6f9ec347293d4bcf8c0556c6db7f5c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47aeffac9c6f9ec347293d4bcf8c0556c6db7f5c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47aeffac9c6f9ec347293d4bcf8c0556c6db7f5c", "patch": "@@ -1,3 +1,20 @@\n+2003-12-01  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* ggc.h (struct alloc_zone): Move forward declaration up.\n+\t(new_ggc_zone): New function prototype.\n+\t(destroy_ggc_zone): Ditto.\n+\t* ggc-simple.c (new_ggc_zone): New function, does nothing.\n+\t(destroy_ggc_zone): Ditto.\n+\t* ggc-page.c (new_ggc_zone): New function, does nothing.\n+\t(destroy_ggc_zone): Ditto.\n+\t* ggc-zone.c (struct page_entry): Fix comment.\n+\t(ggc_alloc_typed): Use a switch statement instead of ifs.\n+\t(new_ggc_zone): New function to set up a new GC zone.\n+\t(destroy_ggc_zone): New function to remove a GC zone.\n+\tinit_ggc): Use new_ggc_zone to set up the default zones.\n+\t(ggc_collect): Walk a list of zones, instead of just the\n+\tdefault zones.  Report statistics using the zone name.\n+\n 2003-12-01  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* unroll.c (find_splittable_givs): Add missing extend_value_for_giv."}, {"sha": "7e40d0445350f3a206f90c699b707fcf92390315", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47aeffac9c6f9ec347293d4bcf8c0556c6db7f5c/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47aeffac9c6f9ec347293d4bcf8c0556c6db7f5c/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=47aeffac9c6f9ec347293d4bcf8c0556c6db7f5c", "patch": "@@ -1401,6 +1401,20 @@ init_ggc (void)\n   G.save_in_use = xmalloc (G.by_depth_max * sizeof (unsigned long *));\n }\n \n+/* Start a new GGC zone.  */\n+\n+struct alloc_zone *\n+new_ggc_zone (const char *name ATTRIBUTE_UNUSED)\n+{\n+  return NULL;\n+}\n+\n+/* Destroy a GGC zone.  */\n+void\n+destroy_ggc_zone (struct alloc_zone *zone ATTRIBUTE_UNUSED)\n+{\n+}\n+\n /* Increment the `GC context'.  Objects allocated in an outer context\n    are never freed, eliminating the need to register their roots.  */\n "}, {"sha": "2f75021f42dd14d8a476a020a71d35c591051039", "filename": "gcc/ggc-simple.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47aeffac9c6f9ec347293d4bcf8c0556c6db7f5c/gcc%2Fggc-simple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47aeffac9c6f9ec347293d4bcf8c0556c6db7f5c/gcc%2Fggc-simple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-simple.c?ref=47aeffac9c6f9ec347293d4bcf8c0556c6db7f5c", "patch": "@@ -344,6 +344,20 @@ init_ggc (void)\n {\n }\n \n+/* Start a new GGC zone.  */\n+\n+struct alloc_zone *\n+new_ggc_zone (const char *name ATTRIBUTE_UNUSED)\n+{\n+  return NULL;\n+}\n+\n+/* Destroy a GGC zone.  */\n+void\n+destroy_ggc_zone (struct alloc_zone *zone ATTRIBUTE_UNUSED)\n+{\n+}\n+\n /* Start a new GGC context.  Memory allocated in previous contexts\n    will not be collected while the new context is active.  */\n "}, {"sha": "4aee63852b2b4bbcb9bf88fefb23aa42b28afa3a", "filename": "gcc/ggc-zone.c", "status": "modified", "additions": 74, "deletions": 49, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47aeffac9c6f9ec347293d4bcf8c0556c6db7f5c/gcc%2Fggc-zone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47aeffac9c6f9ec347293d4bcf8c0556c6db7f5c/gcc%2Fggc-zone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-zone.c?ref=47aeffac9c6f9ec347293d4bcf8c0556c6db7f5c", "patch": "@@ -277,6 +277,7 @@ typedef struct page_entry\n   /* Does this page contain small objects, or one large object?  */\n   bool large_p;\n \n+  /* The zone that this page entry belongs to.  */\n   struct alloc_zone *zone;\n } page_entry;\n \n@@ -1007,14 +1008,20 @@ ggc_alloc_zone_1 (size_t size, struct alloc_zone *zone, short type)\n void *\n ggc_alloc_typed (enum gt_types_enum gte, size_t size)\n {\n-  if (gte == gt_ggc_e_14lang_tree_node)\n-    return ggc_alloc_zone_1 (size, tree_zone, gte);\n-  else if (gte == gt_ggc_e_7rtx_def)\n-    return ggc_alloc_zone_1 (size, rtl_zone, gte);\n-  else if (gte == gt_ggc_e_9rtvec_def)\n-    return ggc_alloc_zone_1 (size, rtl_zone, gte);\n-  else\n-    return ggc_alloc_zone_1 (size, &main_zone, gte);\n+  switch (gte)\n+    {\n+    case gt_ggc_e_14lang_tree_node:\n+      return ggc_alloc_zone_1 (size, tree_zone, gte);\n+\n+    case gt_ggc_e_7rtx_def:\n+      return ggc_alloc_zone_1 (size, rtl_zone, gte);\n+\n+    case gt_ggc_e_9rtvec_def:\n+      return ggc_alloc_zone_1 (size, rtl_zone, gte);\n+\n+    default:\n+      return ggc_alloc_zone_1 (size, &main_zone, gte);\n+    }\n }\n \n /* Normal ggc_alloc simply allocates into the main zone.  */\n@@ -1135,24 +1142,14 @@ ggc_get_size (const void *p)\n void\n init_ggc (void)\n {\n-  /* Create the zones.  */\n+  /* Set up the main zone by hand.  */\n   main_zone.name = \"Main zone\";\n   G.zones = &main_zone;\n \n-  rtl_zone = xcalloc (1, sizeof (struct alloc_zone));\n-  rtl_zone->name = \"RTL zone\";\n-  /* The main zone's connected to the ... rtl_zone */\n-  G.zones->next_zone = rtl_zone;\n-\n-  garbage_zone = xcalloc (1, sizeof (struct alloc_zone));\n-  garbage_zone->name = \"Garbage zone\";\n-  /* The rtl zone's connected to the ... garbage zone */\n-  rtl_zone->next_zone = garbage_zone;\n-\n-  tree_zone = xcalloc (1, sizeof (struct alloc_zone));\n-  tree_zone->name = \"Tree zone\";\n-  /* The garbage zone's connected to ... the tree zone */\n-  garbage_zone->next_zone = tree_zone;\n+  /* Allocate the default zones.  */\n+  rtl_zone = new_ggc_zone (\"RTL zone\");\n+  tree_zone = new_ggc_zone (\"Tree zone\");\n+  garbage_zone = new_ggc_zone (\"Garbage zone\");\n \n   G.pagesize = getpagesize();\n   G.lg_pagesize = exact_log2 (G.pagesize);\n@@ -1197,6 +1194,40 @@ init_ggc (void)\n #endif\n }\n \n+/* Start a new GGC zone.  */\n+\n+struct alloc_zone *\n+new_ggc_zone (const char * name)\n+{\n+  struct alloc_zone *new_zone = xcalloc (1, sizeof (struct alloc_zone));\n+  new_zone->name = name;\n+  new_zone->next_zone = G.zones->next_zone;\n+  G.zones->next_zone = new_zone;\n+  return new_zone;\n+}\n+\n+/* Destroy a GGC zone.  */\n+void\n+destroy_ggc_zone (struct alloc_zone * dead_zone)\n+{\n+  struct alloc_zone *z;\n+\n+  for (z = G.zones; z && z->next_zone != dead_zone; z = z->next_zone)\n+    /* Just find that zone.  */ ;\n+\n+  /* We should have found the zone in the list.  Anything else is\n+     fatal.\n+     If we did find the zone, we expect this zone to be empty.\n+     A ggc_collect should have emptied it before we can destroy it.  */\n+  if (!z || dead_zone->allocated != 0)\n+    abort ();\n+\n+  /* Unchain the dead zone, release all its pages and free it.  */\n+  z->next_zone = z->next_zone->next_zone;\n+  release_pages (dead_zone);\n+  free (dead_zone);\n+}\n+\n /* Increment the `GC context'.  Objects allocated in an outer context\n    are never freed, eliminating the need to register their roots.  */\n \n@@ -1234,9 +1265,9 @@ ggc_pop_context_1 (struct alloc_zone *zone)\n   /* Any remaining pages in the popped context are lowered to the new\n      current context; i.e. objects allocated in the popped context and\n      left over are imported into the previous context.  */\n-    for (p = zone->pages; p != NULL; p = p->next)\n-      if (p->context_depth > depth)\n-\tp->context_depth = depth;\n+  for (p = zone->pages; p != NULL; p = p->next)\n+    if (p->context_depth > depth)\n+      p->context_depth = depth;\n }\n \n /* Pop all the zone contexts.  */\n@@ -1478,6 +1509,7 @@ ggc_collect (void)\n   /* Start by possibly collecting the main zone.  */\n   main_zone.was_collected = false;\n   marked |= ggc_collect_1 (&main_zone, true);\n+\n   /* In order to keep the number of collections down, we don't\n      collect other zones unless we are collecting the main zone.  This\n      gives us roughly the same number of collections as we used to\n@@ -1489,36 +1521,30 @@ ggc_collect (void)\n \n   if (main_zone.was_collected)\n     {\n-      check_cookies ();\n-      rtl_zone->was_collected = false;\n-      marked |= ggc_collect_1 (rtl_zone, !marked);\n-      check_cookies ();\n-      tree_zone->was_collected = false;\n-      marked |= ggc_collect_1 (tree_zone, !marked);\n-      check_cookies ();\n-      garbage_zone->was_collected = false;\n-      marked |= ggc_collect_1 (garbage_zone, !marked);\n+      struct alloc_zone *zone;\n+\n+      for (zone = main_zone.next_zone; zone; zone = zone->next_zone)\n+\t{\n+\t  check_cookies ();\n+\t  zone->was_collected = false;\n+\t  marked |= ggc_collect_1 (zone, !marked);\n+\t}\n     }\n \n   /* Print page survival stats, if someone wants them.  */\n   if (GGC_DEBUG_LEVEL >= 2)\n     {\n-      if (rtl_zone->was_collected)\n-\t{\n-\t  f = calculate_average_page_survival (rtl_zone);\n-\t  printf (\"Average RTL page survival is %f\\n\", f);\n-\t}\n-      if (main_zone.was_collected)\n-\t{\n-\t  f = calculate_average_page_survival (&main_zone);\n-\t  printf (\"Average main page survival is %f\\n\", f);\n-\t}\n-      if (tree_zone->was_collected)\n+      for (zone = G.zones; zone; zone = zone->next_zone)\n \t{\n-\t  f = calculate_average_page_survival (tree_zone);\n-\t  printf (\"Average tree page survival is %f\\n\", f);\n+\t  if (zone->was_collected)\n+\t    {\n+\t      f = calculate_average_page_survival (zone);\n+\t      printf (\"Average page survival in zone `%s' is %f\\n\",\n+\t\t      zone->name, f);\n+\t    }\n \t}\n     }\n+\n   /* Since we don't mark zone at a time right now, marking in any\n      zone means marking in every zone. So we have to clear all the\n      marks in all the zones that weren't collected already.  */\n@@ -1578,7 +1604,6 @@ struct ggc_pch_data\n   } d;\n   size_t base;\n   size_t written;\n-\n };\n \n /* Initialize the PCH datastructure.  */"}, {"sha": "3a8b57e4aba9b915b4d6a2efd85f8ee7def97198", "filename": "gcc/ggc.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47aeffac9c6f9ec347293d4bcf8c0556c6db7f5c/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47aeffac9c6f9ec347293d4bcf8c0556c6db7f5c/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=47aeffac9c6f9ec347293d4bcf8c0556c6db7f5c", "patch": "@@ -141,9 +141,18 @@ extern void init_stringpool (void);\n /* A GC implementation must provide these functions.  They are internal\n    to the GC system.  */\n \n+/* Forward declare the zone structure.  Only ggc_zone implements this.  */\n+struct alloc_zone;\n+\n /* Initialize the garbage collector.  */\n extern void init_ggc (void);\n \n+/* Start a new GGC zone.  */\n+extern struct alloc_zone *new_ggc_zone (const char *);\n+\n+/* Free a complete GGC zone, destroying everything in it.  */\n+extern void destroy_ggc_zone (struct alloc_zone *);\n+\n /* Start a new GGC context.  Memory allocated in previous contexts\n    will not be collected while the new context is active.  */\n extern void ggc_push_context (void);\n@@ -193,8 +202,6 @@ extern void ggc_pch_read (FILE *, void *);\n \f\n /* Allocation.  */\n \n-/* Zone structure.  */\n-struct alloc_zone;\n /* For single pass garbage.  */\n extern struct alloc_zone *garbage_zone;\n /* For regular rtl allocations.  */"}]}