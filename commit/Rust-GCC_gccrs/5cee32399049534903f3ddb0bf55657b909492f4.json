{"sha": "5cee32399049534903f3ddb0bf55657b909492f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNlZTMyMzk5MDQ5NTM0OTAzZjNkZGIwYmY1NTY1N2I5MDk0OTJmNA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-07-04T13:55:15Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-07-04T13:55:15Z"}, "message": "re PR tree-optimization/90911 (456.hmmer regression with r272239)\n\n2019-07-04  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/90911\n\t* tree-vectorizer.h (_loop_vec_info::scalar_loop_scaling): New field.\n\t(LOOP_VINFO_SCALAR_LOOP_SCALING): new.\n\t* tree-vect-loop.c (_loop_vec_info::_loop_vec_info): Initialize\n\tscalar_loop_scaling.\n\t(vect_transform_loop): Scale scalar loop profile if needed.\n\t* tree-vect-loop-manip.c (vect_loop_versioning): When re-using\n\tthe loop copy from if-conversion adjust edge probabilities\n\tand scale the vectorized loop body profile, queue the scalar\n\tprofile for updating after peeling.\n\nFrom-SVN: r273082", "tree": {"sha": "17ab89e8de21203b0ece5a305b55f5e21cee285b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17ab89e8de21203b0ece5a305b55f5e21cee285b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cee32399049534903f3ddb0bf55657b909492f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cee32399049534903f3ddb0bf55657b909492f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cee32399049534903f3ddb0bf55657b909492f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cee32399049534903f3ddb0bf55657b909492f4/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5bb8f28194ee8271357051441db27decbd74d5c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bb8f28194ee8271357051441db27decbd74d5c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bb8f28194ee8271357051441db27decbd74d5c5"}], "stats": {"total": 35, "additions": 33, "deletions": 2}, "files": [{"sha": "591e2972a16984a8e49b2fbe8ed089fda8a2cb3c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cee32399049534903f3ddb0bf55657b909492f4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cee32399049534903f3ddb0bf55657b909492f4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5cee32399049534903f3ddb0bf55657b909492f4", "patch": "@@ -1,3 +1,16 @@\n+2019-07-04  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/90911\n+\t* tree-vectorizer.h (_loop_vec_info::scalar_loop_scaling): New field.\n+\t(LOOP_VINFO_SCALAR_LOOP_SCALING): new.\n+\t* tree-vect-loop.c (_loop_vec_info::_loop_vec_info): Initialize\n+\tscalar_loop_scaling.\n+\t(vect_transform_loop): Scale scalar loop profile if needed.\n+\t* tree-vect-loop-manip.c (vect_loop_versioning): When re-using\n+\tthe loop copy from if-conversion adjust edge probabilities\n+\tand scale the vectorized loop body profile, queue the scalar\n+\tprofile for updating after peeling.\n+\n 2019-07-04  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-ssa-alias.c (decl_refs_may_alias_p): Add size1 and size2"}, {"sha": "bd8fffb1704787d0a611fc02ee29054422596cbb", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cee32399049534903f3ddb0bf55657b909492f4/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cee32399049534903f3ddb0bf55657b909492f4/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=5cee32399049534903f3ddb0bf55657b909492f4", "patch": "@@ -3114,8 +3114,17 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n \t\t\t\t GSI_SAME_STMT);\n \t}\n \n-      /* ???  if-conversion uses profile_probability::always () but\n-         prob below is profile_probability::likely ().  */\n+      /* if-conversion uses profile_probability::always () for both paths,\n+\t reset the paths probabilities appropriately.  */\n+      edge te, fe;\n+      extract_true_false_edges_from_block (condition_bb, &te, &fe);\n+      te->probability = prob;\n+      fe->probability = prob.invert ();\n+      /* We can scale loops counts immediately but have to postpone\n+         scaling the scalar loop because we re-use it during peeling.  */\n+      scale_loop_frequencies (loop_to_version, te->probability);\n+      LOOP_VINFO_SCALAR_LOOP_SCALING (loop_vinfo) = fe->probability;\n+\n       nloop = scalar_loop;\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,"}, {"sha": "b49ab152012a5c7fe9cc0564e58d296447f9ffb1", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cee32399049534903f3ddb0bf55657b909492f4/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cee32399049534903f3ddb0bf55657b909492f4/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=5cee32399049534903f3ddb0bf55657b909492f4", "patch": "@@ -833,6 +833,7 @@ _loop_vec_info::_loop_vec_info (struct loop *loop_in, vec_info_shared *shared)\n     operands_swapped (false),\n     no_data_dependencies (false),\n     has_mask_store (false),\n+    scalar_loop_scaling (profile_probability::uninitialized ()),\n     scalar_loop (NULL),\n     orig_loop_info (NULL)\n {\n@@ -8557,6 +8558,10 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   epilogue = vect_do_peeling (loop_vinfo, niters, nitersm1, &niters_vector,\n \t\t\t      &step_vector, &niters_vector_mult_vf, th,\n \t\t\t      check_profitability, niters_no_overflow);\n+  if (LOOP_VINFO_SCALAR_LOOP (loop_vinfo)\n+      && LOOP_VINFO_SCALAR_LOOP_SCALING (loop_vinfo).initialized_p ())\n+    scale_loop_frequencies (LOOP_VINFO_SCALAR_LOOP (loop_vinfo),\n+\t\t\t    LOOP_VINFO_SCALAR_LOOP_SCALING (loop_vinfo));\n \n   if (niters_vector == NULL_TREE)\n     {"}, {"sha": "f7432f0584762fd28d54f2978dc59f2df443e991", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cee32399049534903f3ddb0bf55657b909492f4/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cee32399049534903f3ddb0bf55657b909492f4/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=5cee32399049534903f3ddb0bf55657b909492f4", "patch": "@@ -548,6 +548,9 @@ typedef struct _loop_vec_info : public vec_info {\n   /* Mark loops having masked stores.  */\n   bool has_mask_store;\n \n+  /* Queued scaling factor for the scalar loop.  */\n+  profile_probability scalar_loop_scaling;\n+\n   /* If if-conversion versioned this loop before conversion, this is the\n      loop version without if-conversion.  */\n   struct loop *scalar_loop;\n@@ -603,6 +606,7 @@ typedef struct _loop_vec_info : public vec_info {\n #define LOOP_VINFO_PEELING_FOR_NITER(L)    (L)->peeling_for_niter\n #define LOOP_VINFO_NO_DATA_DEPENDENCIES(L) (L)->no_data_dependencies\n #define LOOP_VINFO_SCALAR_LOOP(L)\t   (L)->scalar_loop\n+#define LOOP_VINFO_SCALAR_LOOP_SCALING(L)  (L)->scalar_loop_scaling\n #define LOOP_VINFO_HAS_MASK_STORE(L)       (L)->has_mask_store\n #define LOOP_VINFO_SCALAR_ITERATION_COST(L) (L)->scalar_cost_vec\n #define LOOP_VINFO_SINGLE_SCALAR_ITERATION_COST(L) (L)->single_scalar_iteration_cost"}]}