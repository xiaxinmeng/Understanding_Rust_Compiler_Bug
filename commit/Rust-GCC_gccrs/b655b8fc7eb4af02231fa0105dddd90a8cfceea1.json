{"sha": "b655b8fc7eb4af02231fa0105dddd90a8cfceea1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY1NWI4ZmM3ZWI0YWYwMjIzMWZhMDEwNWRkZGQ5MGE4Y2ZjZWVhMQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-08-20T12:13:25Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-08-20T12:13:25Z"}, "message": "Refactor std::optional SFINAE constraints\n\n\t* include/std/optional (_Optional_payload): Use variable templates\n\tfor conditions in default template arguments and exception\n\tspecifications.\n\t(optional): Likewise. Adjust indentation.\n\t(optional::__not_self, optional::__not_tag, optional::_Requires): New\n\tSFINAE helpers.\n\t(optional::optional): Use new helpers in constructor constraints.\n\t* include/std/type_traits (__or_v, __and_v): New variable templates.\n\t* testsuite/20_util/optional/cons/value_neg.cc: Change dg-error to\n\tdg-prune-output. Remove unused header.\n\nFrom-SVN: r263657", "tree": {"sha": "61b04ddfbf6feee972e4760ea6d713ca97f7e9aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61b04ddfbf6feee972e4760ea6d713ca97f7e9aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b655b8fc7eb4af02231fa0105dddd90a8cfceea1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b655b8fc7eb4af02231fa0105dddd90a8cfceea1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b655b8fc7eb4af02231fa0105dddd90a8cfceea1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b655b8fc7eb4af02231fa0105dddd90a8cfceea1/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "285ee4d029d29c3baebfc6715249c9724e5f83d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/285ee4d029d29c3baebfc6715249c9724e5f83d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/285ee4d029d29c3baebfc6715249c9724e5f83d1"}], "stats": {"total": 364, "additions": 187, "deletions": 177}, "files": [{"sha": "39855d9b6918f1c02f33115e357d7beeed1aaab8", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b655b8fc7eb4af02231fa0105dddd90a8cfceea1/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b655b8fc7eb4af02231fa0105dddd90a8cfceea1/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b655b8fc7eb4af02231fa0105dddd90a8cfceea1", "patch": "@@ -1,3 +1,16 @@\n+2018-08-20  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/std/optional (_Optional_payload): Use variable templates\n+\tfor conditions in default template arguments and exception\n+\tspecifications.\n+\t(optional): Likewise. Adjust indentation.\n+\t(optional::__not_self, optional::__not_tag, optional::_Requires): New\n+\tSFINAE helpers.\n+\t(optional::optional): Use new helpers in constructor constraints.\n+\t* include/std/type_traits (__or_v, __and_v): New variable templates.\n+\t* testsuite/20_util/optional/cons/value_neg.cc: Change dg-error to\n+\tdg-prune-output. Remove unused header.\n+\n 2018-08-18  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n \n \t* testsuite/25_algorithms/copy/86658.cc: Use dg-options to define"}, {"sha": "d0257c07e1fe92da339512d2457ac2ad43b12686", "filename": "libstdc++-v3/include/std/optional", "status": "modified", "additions": 168, "deletions": 172, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b655b8fc7eb4af02231fa0105dddd90a8cfceea1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b655b8fc7eb4af02231fa0105dddd90a8cfceea1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional?ref=b655b8fc7eb4af02231fa0105dddd90a8cfceea1", "patch": "@@ -102,11 +102,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // Payload for optionals with non-trivial destructor.\n   template <typename _Tp,\n \t    bool /*_HasTrivialDestructor*/ =\n-\t      is_trivially_destructible<_Tp>::value,\n+\t      is_trivially_destructible_v<_Tp>,\n \t    bool /*_HasTrivialCopyAssignment*/ =\n-\t      is_trivially_copy_assignable<_Tp>::value,\n+\t      is_trivially_copy_assignable_v<_Tp>,\n \t    bool /*_HasTrivialMoveAssignment*/ =\n-\t      is_trivially_move_assignable<_Tp>::value>\n+\t      is_trivially_move_assignable_v<_Tp>>\n     struct _Optional_payload\n     {\n       constexpr _Optional_payload() noexcept : _M_empty() { }\n@@ -165,8 +165,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       _Optional_payload&\n       operator=(_Optional_payload&& __other)\n-      noexcept(__and_<is_nothrow_move_constructible<_Tp>,\n-\t\t      is_nothrow_move_assignable<_Tp>>())\n+      noexcept(__and_v<is_nothrow_move_constructible<_Tp>,\n+\t\t       is_nothrow_move_assignable<_Tp>>)\n       {\n \tif (this->_M_engaged && __other._M_engaged)\n \t  this->_M_get() = std::move(__other._M_get());\n@@ -199,7 +199,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename... _Args>\n         void\n         _M_construct(_Args&&... __args)\n-        noexcept(is_nothrow_constructible<_Stored_type, _Args...>())\n+        noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)\n         {\n           ::new ((void *) std::__addressof(this->_M_payload))\n             _Stored_type(std::forward<_Args>(__args)...);\n@@ -377,7 +377,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename... _Args>\n         void\n         _M_construct(_Args&&... __args)\n-        noexcept(is_nothrow_constructible<_Stored_type, _Args...>())\n+        noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)\n         {\n           ::new ((void *) std::__addressof(this->_M_payload))\n             _Stored_type(std::forward<_Args>(__args)...);\n@@ -468,8 +468,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       _Optional_payload&\n       operator=(_Optional_payload&& __other)\n-      noexcept(__and_<is_nothrow_move_constructible<_Tp>,\n-\t\t      is_nothrow_move_assignable<_Tp>>())\n+      noexcept(__and_v<is_nothrow_move_constructible<_Tp>,\n+\t\t       is_nothrow_move_assignable<_Tp>>)\n       {\n \tif (this->_M_engaged && __other._M_engaged)\n \t  this->_M_get() = std::move(__other._M_get());\n@@ -496,7 +496,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename... _Args>\n         void\n         _M_construct(_Args&&... __args)\n-        noexcept(is_nothrow_constructible<_Stored_type, _Args...>())\n+        noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)\n         {\n           ::new ((void *) std::__addressof(this->_M_payload))\n             _Stored_type(std::forward<_Args>(__args)...);\n@@ -598,8 +598,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       _Optional_payload&\n       operator=(_Optional_payload&& __other)\n-      noexcept(__and_<is_nothrow_move_constructible<_Tp>,\n-\t\t      is_nothrow_move_assignable<_Tp>>())\n+      noexcept(__and_v<is_nothrow_move_constructible<_Tp>,\n+\t\t       is_nothrow_move_assignable<_Tp>>)\n       {\n \tif (this->_M_engaged && __other._M_engaged)\n \t  this->_M_get() = std::move(__other._M_get());\n@@ -626,7 +626,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename... _Args>\n         void\n         _M_construct(_Args&&... __args)\n-        noexcept(is_nothrow_constructible<_Stored_type, _Args...>())\n+        noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)\n         {\n           ::new ((void *) std::__addressof(this->_M_payload))\n             _Stored_type(std::forward<_Args>(__args)...);\n@@ -665,7 +665,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename... _Args>\n \tvoid\n \t_M_construct(_Args&&... __args)\n-\tnoexcept(is_nothrow_constructible<_Stored_type, _Args...>())\n+\tnoexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)\n \t{\n \t  ::new\n \t    (std::__addressof(static_cast<_Dp*>(this)->_M_payload._M_payload))\n@@ -735,7 +735,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { }\n \n       constexpr _Optional_base(_Optional_base&& __other)\n-      noexcept(is_nothrow_move_constructible<_Tp>())\n+      noexcept(is_nothrow_move_constructible_v<_Tp>)\n \t: _M_payload(__other._M_payload._M_engaged,\n \t\t     std::move(__other._M_payload))\n       { }\n@@ -864,7 +864,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       constexpr _Optional_base(const _Optional_base& __other) = default;\n \n       constexpr _Optional_base(_Optional_base&& __other)\n-      noexcept(is_nothrow_move_constructible<_Tp>())\n+      noexcept(is_nothrow_move_constructible_v<_Tp>)\n \t: _M_payload(__other._M_payload._M_engaged,\n \t\t     std::move(__other._M_payload))\n       { }\n@@ -985,16 +985,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     class optional\n     : private _Optional_base<_Tp>,\n       private _Enable_copy_move<\n-        // Copy constructor.\n-        is_copy_constructible<_Tp>::value,\n-        // Copy assignment.\n-        __and_<is_copy_constructible<_Tp>, is_copy_assignable<_Tp>>::value,\n-        // Move constructor.\n-        is_move_constructible<_Tp>::value,\n-        // Move assignment.\n-        __and_<is_move_constructible<_Tp>, is_move_assignable<_Tp>>::value,\n-        // Unique tag type.\n-        optional<_Tp>>\n+\t// Copy constructor.\n+\tis_copy_constructible_v<_Tp>,\n+\t// Copy assignment.\n+\t__and_v<is_copy_constructible<_Tp>, is_copy_assignable<_Tp>>,\n+\t// Move constructor.\n+\tis_move_constructible_v<_Tp>,\n+\t// Move assignment.\n+\t__and_v<is_move_constructible<_Tp>, is_move_assignable<_Tp>>,\n+\t// Unique tag type.\n+\toptional<_Tp>>\n     {\n       static_assert(!is_same_v<remove_cv_t<_Tp>, nullopt_t>);\n       static_assert(!is_same_v<remove_cv_t<_Tp>, in_place_t>);\n@@ -1003,6 +1003,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     private:\n       using _Base = _Optional_base<_Tp>;\n \n+      // SFINAE helpers\n+      template<typename _Up>\n+\tusing __not_self = __not_<is_same<optional, __remove_cvref_t<_Up>>>;\n+      template<typename _Up>\n+\tusing __not_tag = __not_<is_same<in_place_t, __remove_cvref_t<_Up>>>;\n+      template<typename... _Cond>\n+\tusing _Requires = enable_if_t<__and_v<_Cond...>, bool>;\n+\n     public:\n       using value_type = _Tp;\n \n@@ -1011,171 +1019,158 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       constexpr optional(nullopt_t) noexcept { }\n \n       // Converting constructors for engaged optionals.\n-      template <typename _Up = _Tp,\n-                enable_if_t<__and_<\n-\t\t\t      __not_<is_same<optional<_Tp>, decay_t<_Up>>>,\n-\t\t\t      __not_<is_same<in_place_t, decay_t<_Up>>>,\n-\t\t\t      is_constructible<_Tp, _Up&&>,\n-\t\t\t      is_convertible<_Up&&, _Tp>\n-\t\t\t      >::value, bool> = true>\n-      constexpr optional(_Up&& __t)\n-        : _Base(std::in_place, std::forward<_Up>(__t)) { }\n-\n-      template <typename _Up = _Tp,\n-                enable_if_t<__and_<\n-\t\t\t      __not_<is_same<optional<_Tp>, decay_t<_Up>>>,\n-\t\t\t      __not_<is_same<in_place_t, decay_t<_Up>>>,\n-\t\t\t      is_constructible<_Tp, _Up&&>,\n-\t\t\t      __not_<is_convertible<_Up&&, _Tp>>\n-\t\t\t      >::value, bool> = false>\n-      explicit constexpr optional(_Up&& __t)\n+      template<typename _Up = _Tp,\n+\t       _Requires<__not_self<_Up>, __not_tag<_Up>,\n+\t\t\t is_constructible<_Tp, _Up&&>,\n+\t\t\t is_convertible<_Up&&, _Tp>> = true>\n+\tconstexpr\n+\toptional(_Up&& __t)\n+\t: _Base(std::in_place, std::forward<_Up>(__t)) { }\n+\n+      template<typename _Up = _Tp,\n+\t       _Requires<__not_self<_Up>, __not_tag<_Up>,\n+\t\t\t is_constructible<_Tp, _Up&&>,\n+\t\t\t __not_<is_convertible<_Up&&, _Tp>>> = false>\n+\texplicit constexpr\n+\toptional(_Up&& __t)\n         : _Base(std::in_place, std::forward<_Up>(__t)) { }\n \n-      template <typename _Up,\n-                enable_if_t<__and_<\n-\t\t\t    __not_<is_same<_Tp, _Up>>,\n-\t\t\t    is_constructible<_Tp, const _Up&>,\n-\t\t\t    is_convertible<const _Up&, _Tp>,\n-\t\t\t    __not_<__converts_from_optional<_Tp, _Up>>\n-\t\t\t    >::value, bool> = true>\n-      constexpr optional(const optional<_Up>& __t)\n-      {\n-\tif (__t)\n-\t  emplace(*__t);\n-      }\n+      template<typename _Up,\n+\t       _Requires<__not_<is_same<_Tp, _Up>>,\n+\t\t\t is_constructible<_Tp, const _Up&>,\n+\t\t\t is_convertible<const _Up&, _Tp>,\n+\t\t\t __not_<__converts_from_optional<_Tp, _Up>>> = true>\n+\tconstexpr\n+\toptional(const optional<_Up>& __t)\n+\t{\n+\t  if (__t)\n+\t    emplace(*__t);\n+\t}\n \n-      template <typename _Up,\n-                 enable_if_t<__and_<\n-\t\t\t       __not_<is_same<_Tp, _Up>>,\n-\t\t\t       is_constructible<_Tp, const _Up&>,\n-\t\t\t       __not_<is_convertible<const _Up&, _Tp>>,\n-\t\t\t       __not_<__converts_from_optional<_Tp, _Up>>\n-\t\t\t       >::value, bool> = false>\n-      explicit constexpr optional(const optional<_Up>& __t)\n-      {\n-\tif (__t)\n-\t  emplace(*__t);\n-      }\n+      template<typename _Up,\n+\t       _Requires<__not_<is_same<_Tp, _Up>>,\n+\t\t\t is_constructible<_Tp, const _Up&>,\n+\t\t\t __not_<is_convertible<const _Up&, _Tp>>,\n+\t\t\t __not_<__converts_from_optional<_Tp, _Up>>> = false>\n+\texplicit constexpr\n+\toptional(const optional<_Up>& __t)\n+\t{\n+\t  if (__t)\n+\t    emplace(*__t);\n+\t}\n \n       template <typename _Up,\n-                enable_if_t<__and_<\n-\t\t\t      __not_<is_same<_Tp, _Up>>,\n-\t\t\t      is_constructible<_Tp, _Up&&>,\n-\t\t\t      is_convertible<_Up&&, _Tp>,\n-\t\t\t      __not_<__converts_from_optional<_Tp, _Up>>\n-\t\t\t      >::value, bool> = true>\n-      constexpr optional(optional<_Up>&& __t)\n-      {\n-\tif (__t)\n-\t  emplace(std::move(*__t));\n-      }\n+\t\t_Requires<__not_<is_same<_Tp, _Up>>,\n+\t\t\t  is_constructible<_Tp, _Up&&>,\n+\t\t\t  is_convertible<_Up&&, _Tp>,\n+\t\t\t  __not_<__converts_from_optional<_Tp, _Up>>> = true>\n+\tconstexpr\n+\toptional(optional<_Up>&& __t)\n+\t{\n+\t  if (__t)\n+\t    emplace(std::move(*__t));\n+\t}\n \n       template <typename _Up,\n-                enable_if_t<__and_<\n-\t\t\t    __not_<is_same<_Tp, _Up>>,\n-\t\t\t    is_constructible<_Tp, _Up&&>,\n-\t\t\t    __not_<is_convertible<_Up&&, _Tp>>,\n-\t\t\t    __not_<__converts_from_optional<_Tp, _Up>>\n-\t\t\t    >::value, bool> = false>\n-      explicit constexpr optional(optional<_Up>&& __t)\n-      {\n-\tif (__t)\n-\t  emplace(std::move(*__t));\n-      }\n+\t\t_Requires<__not_<is_same<_Tp, _Up>>,\n+\t\t\t  is_constructible<_Tp, _Up&&>,\n+\t\t\t  __not_<is_convertible<_Up&&, _Tp>>,\n+\t\t\t  __not_<__converts_from_optional<_Tp, _Up>>> = false>\n+\texplicit constexpr\n+\toptional(optional<_Up>&& __t)\n+\t{\n+\t  if (__t)\n+\t    emplace(std::move(*__t));\n+\t}\n \n       template<typename... _Args,\n-\t       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>\n-      explicit constexpr optional(in_place_t, _Args&&... __args)\n-        : _Base(std::in_place, std::forward<_Args>(__args)...) { }\n+\t       _Requires<is_constructible<_Tp, _Args&&...>> = false>\n+\texplicit constexpr\n+\toptional(in_place_t, _Args&&... __args)\n+\t: _Base(std::in_place, std::forward<_Args>(__args)...) { }\n \n       template<typename _Up, typename... _Args,\n-               enable_if_t<is_constructible_v<_Tp,\n-\t\t\t\t\t      initializer_list<_Up>&,\n-\t\t\t\t\t      _Args&&...>, bool> = false>\n-      explicit constexpr optional(in_place_t,\n-\t\t\t\t  initializer_list<_Up> __il,\n-\t\t\t\t  _Args&&... __args)\n-        : _Base(std::in_place, __il, std::forward<_Args>(__args)...) { }\n+\t       _Requires<is_constructible<_Tp,\n+\t\t\t\t\t  initializer_list<_Up>&,\n+\t\t\t\t\t  _Args&&...>> = false>\n+\texplicit constexpr\n+\toptional(in_place_t, initializer_list<_Up> __il, _Args&&... __args)\n+\t: _Base(std::in_place, __il, std::forward<_Args>(__args)...) { }\n \n       // Assignment operators.\n       optional&\n       operator=(nullopt_t) noexcept\n       {\n-        this->_M_reset();\n-        return *this;\n+\tthis->_M_reset();\n+\treturn *this;\n       }\n \n       template<typename _Up = _Tp>\n-        enable_if_t<__and_<\n-\t\t      __not_<is_same<optional<_Tp>, decay_t<_Up>>>,\n-\t\t      is_constructible<_Tp, _Up>,\n-\t\t      __not_<__and_<is_scalar<_Tp>,\n-\t\t\t\t    is_same<_Tp, decay_t<_Up>>>>,\n-\t\t      is_assignable<_Tp&, _Up>>::value,\n+\tenable_if_t<__and_v<__not_self<_Up>,\n+\t\t\t    __not_<__and_<is_scalar<_Tp>,\n+\t\t\t\t\t  is_same<_Tp, decay_t<_Up>>>>,\n+\t\t\t    is_constructible<_Tp, _Up>,\n+\t\t\t    is_assignable<_Tp&, _Up>>,\n \t\t    optional&>\n-        operator=(_Up&& __u)\n-        {\n-          if (this->_M_is_engaged())\n-            this->_M_get() = std::forward<_Up>(__u);\n-          else\n-            this->_M_construct(std::forward<_Up>(__u));\n+\toperator=(_Up&& __u)\n+\t{\n+\t  if (this->_M_is_engaged())\n+\t    this->_M_get() = std::forward<_Up>(__u);\n+\t  else\n+\t    this->_M_construct(std::forward<_Up>(__u));\n \n-          return *this;\n-        }\n+\t  return *this;\n+\t}\n \n       template<typename _Up>\n-\tenable_if_t<__and_<\n-\t\t      __not_<is_same<_Tp, _Up>>,\n-\t\t      is_constructible<_Tp, const _Up&>,\n-\t\t      is_assignable<_Tp&, _Up>,\n-\t\t      __not_<__converts_from_optional<_Tp, _Up>>,\n-\t\t      __not_<__assigns_from_optional<_Tp, _Up>>\n-\t\t      >::value,\n+\tenable_if_t<__and_v<__not_<is_same<_Tp, _Up>>,\n+\t\t\t    is_constructible<_Tp, const _Up&>,\n+\t\t\t    is_assignable<_Tp&, _Up>,\n+\t\t\t    __not_<__converts_from_optional<_Tp, _Up>>,\n+\t\t\t    __not_<__assigns_from_optional<_Tp, _Up>>>,\n \t\t    optional&>\n-        operator=(const optional<_Up>& __u)\n-        {\n-          if (__u)\n-            {\n-              if (this->_M_is_engaged())\n-                this->_M_get() = *__u;\n-              else\n-                this->_M_construct(*__u);\n-            }\n-          else\n-            {\n-              this->_M_reset();\n-            }\n-          return *this;\n-        }\n+\toperator=(const optional<_Up>& __u)\n+\t{\n+\t  if (__u)\n+\t    {\n+\t      if (this->_M_is_engaged())\n+\t\tthis->_M_get() = *__u;\n+\t      else\n+\t\tthis->_M_construct(*__u);\n+\t    }\n+\t  else\n+\t    {\n+\t      this->_M_reset();\n+\t    }\n+\t  return *this;\n+\t}\n \n       template<typename _Up>\n-\tenable_if_t<__and_<\n-\t\t      __not_<is_same<_Tp, _Up>>,\n-\t\t      is_constructible<_Tp, _Up>,\n-\t\t      is_assignable<_Tp&, _Up>,\n-\t\t      __not_<__converts_from_optional<_Tp, _Up>>,\n-\t\t      __not_<__assigns_from_optional<_Tp, _Up>>\n-\t\t      >::value,\n+        enable_if_t<__and_v<__not_<is_same<_Tp, _Up>>,\n+\t\t\t    is_constructible<_Tp, _Up>,\n+\t\t\t    is_assignable<_Tp&, _Up>,\n+\t\t\t    __not_<__converts_from_optional<_Tp, _Up>>,\n+\t\t\t    __not_<__assigns_from_optional<_Tp, _Up>>>,\n \t\t    optional&>\n-        operator=(optional<_Up>&& __u)\n-        {\n-          if (__u)\n-            {\n-              if (this->_M_is_engaged())\n-                this->_M_get() = std::move(*__u);\n-              else\n-                this->_M_construct(std::move(*__u));\n-            }\n-          else\n-            {\n-              this->_M_reset();\n-            }\n-\n-          return *this;\n-        }\n+\toperator=(optional<_Up>&& __u)\n+\t{\n+\t  if (__u)\n+\t    {\n+\t      if (this->_M_is_engaged())\n+\t\tthis->_M_get() = std::move(*__u);\n+\t      else\n+\t\tthis->_M_construct(std::move(*__u));\n+\t    }\n+\t  else\n+\t    {\n+\t      this->_M_reset();\n+\t    }\n+\n+\t  return *this;\n+\t}\n \n       template<typename... _Args>\n-\tenable_if_t<is_constructible<_Tp, _Args&&...>::value, _Tp&>\n+\tenable_if_t<is_constructible_v<_Tp, _Args&&...>, _Tp&>\n \templace(_Args&&... __args)\n \t{\n \t  this->_M_reset();\n@@ -1184,8 +1179,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n \n       template<typename _Up, typename... _Args>\n-\tenable_if_t<is_constructible<_Tp, initializer_list<_Up>&,\n-\t\t\t\t     _Args&&...>::value, _Tp&>\n+\tenable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&,\n+\t\t\t\t       _Args&&...>, _Tp&>\n \templace(initializer_list<_Up> __il, _Args&&... __args)\n \t{\n \t  this->_M_reset();\n@@ -1198,19 +1193,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // Swap.\n       void\n       swap(optional& __other)\n-      noexcept(is_nothrow_move_constructible<_Tp>()\n-               && is_nothrow_swappable_v<_Tp>)\n+      noexcept(is_nothrow_move_constructible_v<_Tp>\n+\t       && is_nothrow_swappable_v<_Tp>)\n       {\n-        using std::swap;\n+\tusing std::swap;\n \n-        if (this->_M_is_engaged() && __other._M_is_engaged())\n-          swap(this->_M_get(), __other._M_get());\n-        else if (this->_M_is_engaged())\n+\tif (this->_M_is_engaged() && __other._M_is_engaged())\n+\t  swap(this->_M_get(), __other._M_get());\n+\telse if (this->_M_is_engaged())\n \t  {\n \t    __other._M_construct(std::move(this->_M_get()));\n \t    this->_M_destruct();\n \t  }\n-        else if (__other._M_is_engaged())\n+\telse if (__other._M_is_engaged())\n \t  {\n \t    this->_M_construct(std::move(__other._M_get()));\n \t    __other._M_destruct();\n@@ -1307,12 +1302,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    ? std::move(this->_M_get())\n \t    : static_cast<_Tp>(std::forward<_Up>(__u));\n \t}\n+\n       void reset() noexcept { this->_M_reset(); }\n     };\n \n   template<typename _Tp>\n     using __optional_relop_t =\n-    enable_if_t<is_convertible<_Tp, bool>::value, bool>;\n+      enable_if_t<is_convertible<_Tp, bool>::value, bool>;\n \n   // Comparisons between optional values.\n   template<typename _Tp, typename _Up>"}, {"sha": "86b58ccf225597a64995878edc68c8666fa2c675", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b655b8fc7eb4af02231fa0105dddd90a8cfceea1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b655b8fc7eb4af02231fa0105dddd90a8cfceea1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=b655b8fc7eb4af02231fa0105dddd90a8cfceea1", "patch": "@@ -144,6 +144,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n #if __cplusplus >= 201703L\n \n+  template<typename... _Bn>\n+    inline constexpr bool __or_v = __or_<_Bn...>::value;\n+  template<typename... _Bn>\n+    inline constexpr bool __and_v = __and_<_Bn...>::value;\n+\n #define __cpp_lib_logical_traits 201510\n \n   template<typename... _Bn>"}, {"sha": "020cb26453f465ac49afb87f77e4833d0fb3aa16", "filename": "libstdc++-v3/testsuite/20_util/optional/cons/value_neg.cc", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b655b8fc7eb4af02231fa0105dddd90a8cfceea1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fvalue_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b655b8fc7eb4af02231fa0105dddd90a8cfceea1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fvalue_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fvalue_neg.cc?ref=b655b8fc7eb4af02231fa0105dddd90a8cfceea1", "patch": "@@ -19,8 +19,6 @@\n // <http://www.gnu.org/licenses/>.\n \n #include <optional>\n-#include <testsuite_hooks.h>\n-\n #include <string>\n #include <memory>\n \n@@ -37,8 +35,6 @@ int main()\n     std::optional<std::unique_ptr<int>> oup2 = new int;  // { dg-error \"conversion\" }\n     struct U { explicit U(std::in_place_t); };\n     std::optional<U> ou(std::in_place); // { dg-error \"no matching\" }\n-    // { dg-error \"no type\" \"\" { target { *-*-* } } 1020 }\n-    // { dg-error \"no type\" \"\" { target { *-*-* } } 1030 }\n-    // { dg-error \"no type\" \"\" { target { *-*-* } } 1087 }\n   }\n }\n+// { dg-prune-output \"no type .*enable_if\" }"}]}