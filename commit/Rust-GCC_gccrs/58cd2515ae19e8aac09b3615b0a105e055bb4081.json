{"sha": "58cd2515ae19e8aac09b3615b0a105e055bb4081", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThjZDI1MTVhZTE5ZThhYWMwOWIzNjE1YjBhMTA1ZTA1NWJiNDA4MQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-12-15T14:29:10Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-12-15T14:29:10Z"}, "message": "re PR c++/11773 (GCOV misreports coverage for in-class C++ member functions)\n\n\tPR c++/11773\n\t* doc/gcov.texi (Gcov and Optimization): Document inline function\n\tbehaviour.  Fix some file suffixes.\n\nFrom-SVN: r74630", "tree": {"sha": "24cfe454bee9d8ed3743e7eb06a57d379fd66037", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24cfe454bee9d8ed3743e7eb06a57d379fd66037"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58cd2515ae19e8aac09b3615b0a105e055bb4081", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58cd2515ae19e8aac09b3615b0a105e055bb4081", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58cd2515ae19e8aac09b3615b0a105e055bb4081", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58cd2515ae19e8aac09b3615b0a105e055bb4081/comments", "author": null, "committer": null, "parents": [{"sha": "f5c28a158bb972bef91b18028e1965722b5cff69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5c28a158bb972bef91b18028e1965722b5cff69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5c28a158bb972bef91b18028e1965722b5cff69"}], "stats": {"total": 38, "additions": 33, "deletions": 5}, "files": [{"sha": "bde0cc07af8f29c5ee62bdb4c7c75ec19fb3455d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58cd2515ae19e8aac09b3615b0a105e055bb4081/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58cd2515ae19e8aac09b3615b0a105e055bb4081/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=58cd2515ae19e8aac09b3615b0a105e055bb4081", "patch": "@@ -1,3 +1,9 @@\n+2003-12-15  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/11773\n+\t* doc/gcov.texi (Gcov and Optimization): Document inline function\n+\tbehaviour. Fix some file suffixes.\n+\n 2003-12-14  David O'Brien  <obrien@FreeBSD.org>\n \n \t* config/i386/i386.h (__amd64, __amd64__): Remove duplicates."}, {"sha": "8f0a23cae5d17df0e370ae07a130a1e33c3c4dae", "filename": "gcc/doc/gcov.texi", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58cd2515ae19e8aac09b3615b0a105e055bb4081/gcc%2Fdoc%2Fgcov.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58cd2515ae19e8aac09b3615b0a105e055bb4081/gcc%2Fdoc%2Fgcov.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcov.texi?ref=58cd2515ae19e8aac09b3615b0a105e055bb4081", "patch": "@@ -249,8 +249,8 @@ information needed by gcov.  These additional files are placed in the\n directory where the object file is located.\n \n Running the program will cause profile output to be generated.  For each\n-source file compiled with @option{-fprofile-arcs}, an accompanying @file{.da}\n-file will be placed in the object file directory.\n+source file compiled with @option{-fprofile-arcs}, an accompanying\n+@file{.gcda} file will be placed in the object file directory.\n \n Running @command{gcov} with your program's source file names as arguments\n will now produce a listing of the code along with frequency of execution\n@@ -410,17 +410,17 @@ of times the call was executed will be printed.  This will usually be\n and thus may not return every time they are called.\n \n The execution counts are cumulative.  If the example program were\n-executed again without removing the @file{.da} file, the count for the\n+executed again without removing the @file{.gcda} file, the count for the\n number of times each line in the source was executed would be added to\n the results of the previous run(s).  This is potentially useful in\n several ways.  For example, it could be used to accumulate data over a\n number of program runs as part of a test verification suite, or to\n provide more accurate long-term information over a large number of\n program runs.\n \n-The data in the @file{.da} files is saved immediately before the program\n+The data in the @file{.gcda} files is saved immediately before the program\n exits.  For each source file compiled with @option{-fprofile-arcs}, the\n-profiling code first attempts to read in an existing @file{.da} file; if\n+profiling code first attempts to read in an existing @file{.gcda} file; if\n the file doesn't match the executable (differing number of basic block\n counts) it will ignore the contents of the file.  It then adds in the\n new execution counts and finally writes the data to the file.\n@@ -463,6 +463,28 @@ executed 100 times.  In one sense this result is correct, because there\n was only one instruction representing all four of these lines.  However,\n the output does not indicate how many times the result was 0 and how\n many times the result was 1.\n+\n+Inlineable functions can create unexpected line counts.  Line counts are\n+shown for the source code of the inlineable function, but what is shown\n+depends on where the function is inlined, or if it is not inlined at all.\n+\n+If the function is not inlined, the compiler must emit an out of line\n+copy of the function, in any object file that needs it.  If\n+@file{fileA.o} and @file{fileB.o} both contain out of line bodies of a\n+particular inlineable function, they will also both contain coverage\n+counts for that function.  When @file{fileA.o} and @file{fileB.o} are\n+linked together, the linker will, on many systems, select one of those\n+out of line bodies for all calls to that function, and remove or ignore\n+the other.  Unfortunately, it will not remove the coverage counters for\n+the unused function body.  Hence when instrumented, all but one use of\n+that function will show zero counts.\n+\n+If the function is inlined in several places, the block structure in\n+each location might not be the same.  For instance, a condition might\n+now be calculable at compile time in some instances.  Because the\n+coverage of all the uses of the inline function will be shown for the\n+same source lines, the line counts themselves might seem inconsistent.\n+\n @c man end\n \n @node Gcov Data Files"}]}