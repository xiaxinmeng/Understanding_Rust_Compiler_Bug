{"sha": "328f4006b21e918649efe753493f853d49876d87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI4ZjQwMDZiMjFlOTE4NjQ5ZWZlNzUzNDkzZjg1M2Q0OTg3NmQ4Nw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-11-22T16:40:32Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-11-22T16:40:32Z"}, "message": "Reformat load_mems slightly.\n\nFrom-SVN: r30618", "tree": {"sha": "f8b5c78d62b62ec5f8822e81ea715bf8f7e8ef88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8b5c78d62b62ec5f8822e81ea715bf8f7e8ef88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/328f4006b21e918649efe753493f853d49876d87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/328f4006b21e918649efe753493f853d49876d87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/328f4006b21e918649efe753493f853d49876d87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/328f4006b21e918649efe753493f853d49876d87/comments", "author": null, "committer": null, "parents": [{"sha": "19a027a0824ae73ad022f87e65cb92560a18ae50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19a027a0824ae73ad022f87e65cb92560a18ae50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19a027a0824ae73ad022f87e65cb92560a18ae50"}], "stats": {"total": 277, "additions": 140, "deletions": 137}, "files": [{"sha": "5e0d6411cc475904ba31c7f111332a5f0eb4fc42", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/328f4006b21e918649efe753493f853d49876d87/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/328f4006b21e918649efe753493f853d49876d87/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=328f4006b21e918649efe753493f853d49876d87", "patch": "@@ -1,3 +1,7 @@\n+1999-11-22  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* loop.c (load_mems): Reformat slightly.\n+\n 1999-11-22  Bruce Korb  <autogen@linuxbox.com\n \n \t* fixinc/mkfisinc.sh(i?86-*-linux): disable script, run fixincl exe"}, {"sha": "63f3ae4bc0343d00303535df092da3c6c5b342ee", "filename": "gcc/loop.c", "status": "modified", "additions": 136, "deletions": 137, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/328f4006b21e918649efe753493f853d49876d87/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/328f4006b21e918649efe753493f853d49876d87/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=328f4006b21e918649efe753493f853d49876d87", "patch": "@@ -9715,165 +9715,164 @@ load_mems (scan_start, end, loop_top, start)\n   rtx p;\n   rtx label = NULL_RTX;\n   rtx end_label = NULL_RTX;\n+  /* Nonzero if the next instruction may never be executed.  */\n+  int next_maybe_never = 0;\n \n-  if (loop_mems_idx > 0) \n-    {\n-      /* Nonzero if the next instruction may never be executed.  */\n-      int next_maybe_never = 0;\n+  if (loop_mems_idx == 0)\n+    return;\n \n-      /* Check to see if it's possible that some instructions in the\n-\t loop are never executed.  */\n-      for (p = next_insn_in_loop (scan_start, scan_start, end, loop_top); \n-\t   p != NULL_RTX && !maybe_never; \n-\t   p = next_insn_in_loop (p, scan_start, end, loop_top))\n+  /* Check to see if it's possible that some instructions in the\n+     loop are never executed.  */\n+  for (p = next_insn_in_loop (scan_start, scan_start, end, loop_top); \n+       p != NULL_RTX && !maybe_never; \n+       p = next_insn_in_loop (p, scan_start, end, loop_top))\n+    {\n+      if (GET_CODE (p) == CODE_LABEL)\n+\tmaybe_never = 1;\n+      else if (GET_CODE (p) == JUMP_INSN\n+\t       /* If we enter the loop in the middle, and scan\n+\t\t  around to the beginning, don't set maybe_never\n+\t\t  for that.  This must be an unconditional jump,\n+\t\t  otherwise the code at the top of the loop might\n+\t\t  never be executed.  Unconditional jumps are\n+\t\t  followed a by barrier then loop end.  */\n+\t       && ! (GET_CODE (p) == JUMP_INSN \n+\t\t     && JUMP_LABEL (p) == loop_top\n+\t\t     && NEXT_INSN (NEXT_INSN (p)) == end\n+\t\t     && simplejump_p (p)))\n \t{\n-\t  if (GET_CODE (p) == CODE_LABEL)\n-\t    maybe_never = 1;\n-\t  else if (GET_CODE (p) == JUMP_INSN\n-\t\t   /* If we enter the loop in the middle, and scan\n-\t\t      around to the beginning, don't set maybe_never\n-\t\t      for that.  This must be an unconditional jump,\n-\t\t      otherwise the code at the top of the loop might\n-\t\t      never be executed.  Unconditional jumps are\n-\t\t      followed a by barrier then loop end.  */\n-\t\t   && ! (GET_CODE (p) == JUMP_INSN \n-\t\t\t && JUMP_LABEL (p) == loop_top\n-\t\t\t && NEXT_INSN (NEXT_INSN (p)) == end\n-\t\t\t && simplejump_p (p)))\n-\t    {\n-\t      if (!condjump_p (p))\n-\t\t/* Something complicated.  */\n-\t\tmaybe_never = 1;\n-\t      else\n-\t\t/* If there are any more instructions in the loop, they\n-\t\t   might not be reached.  */\n-\t\tnext_maybe_never = 1; \n-\t    } \n-\t  else if (next_maybe_never)\n+\t  if (!condjump_p (p))\n+\t    /* Something complicated.  */\n \t    maybe_never = 1;\n-\t}\n+\t  else\n+\t    /* If there are any more instructions in the loop, they\n+\t       might not be reached.  */\n+\t    next_maybe_never = 1; \n+\t} \n+      else if (next_maybe_never)\n+\tmaybe_never = 1;\n+    }\n+\n+  /* Actually move the MEMs.  */\n+  for (i = 0; i < loop_mems_idx; ++i) \n+    {\n+      int written = 0;\n+      rtx reg;\n+      rtx mem = loop_mems[i].mem;\n+      rtx mem_list_entry;\n \n-      /* Actually move the MEMs.  */\n-      for (i = 0; i < loop_mems_idx; ++i) \n+      if (MEM_VOLATILE_P (mem) \n+\t  || invariant_p (XEXP (mem, 0)) != 1)\n+\t/* There's no telling whether or not MEM is modified.  */\n+\tloop_mems[i].optimize = 0;\n+\n+      /* Go through the MEMs written to in the loop to see if this\n+\t one is aliased by one of them.  */\n+      mem_list_entry = loop_store_mems;\n+      while (mem_list_entry)\n \t{\n-\t  int written = 0;\n-\t  rtx reg;\n-\t  rtx mem = loop_mems[i].mem;\n-\t  rtx mem_list_entry;\n-\n-\t  if (MEM_VOLATILE_P (mem) \n-\t      || invariant_p (XEXP (mem, 0)) != 1)\n-\t    /* There's no telling whether or not MEM is modified.  */\n-\t    loop_mems[i].optimize = 0;\n-\n-\t  /* Go through the MEMs written to in the loop to see if this\n-\t     one is aliased by one of them.  */\n-\t  mem_list_entry = loop_store_mems;\n-\t  while (mem_list_entry)\n+\t  if (rtx_equal_p (mem, XEXP (mem_list_entry, 0)))\n+\t    written = 1;\n+\t  else if (true_dependence (XEXP (mem_list_entry, 0), VOIDmode,\n+\t\t\t\t    mem, rtx_varies_p))\n \t    {\n-\t      if (rtx_equal_p (mem, XEXP (mem_list_entry, 0)))\n-\t\twritten = 1;\n-\t      else if (true_dependence (XEXP (mem_list_entry, 0), VOIDmode,\n-\t\t\t\t\tmem, rtx_varies_p))\n-\t\t{\n-\t\t  /* MEM is indeed aliased by this store.  */\n-\t\t  loop_mems[i].optimize = 0;\n-\t\t  break;\n-\t\t}\n-\t      mem_list_entry = XEXP (mem_list_entry, 1);\n+\t      /* MEM is indeed aliased by this store.  */\n+\t      loop_mems[i].optimize = 0;\n+\t      break;\n \t    }\n+\t  mem_list_entry = XEXP (mem_list_entry, 1);\n+\t}\n \t  \n-\t  /* If this MEM is written to, we must be sure that there\n-\t     are no reads from another MEM that aliases this one.  */ \n-\t  if (loop_mems[i].optimize && written)\n-\t    {\n-\t      int j;\n+      /* If this MEM is written to, we must be sure that there\n+\t are no reads from another MEM that aliases this one.  */ \n+      if (loop_mems[i].optimize && written)\n+\t{\n+\t  int j;\n \n-\t      for (j = 0; j < loop_mems_idx; ++j)\n+\t  for (j = 0; j < loop_mems_idx; ++j)\n+\t    {\n+\t      if (j == i)\n+\t\tcontinue;\n+\t      else if (true_dependence (mem,\n+\t\t\t\t\tVOIDmode,\n+\t\t\t\t\tloop_mems[j].mem,\n+\t\t\t\t\trtx_varies_p))\n \t\t{\n-\t\t  if (j == i)\n-\t\t    continue;\n-\t\t  else if (true_dependence (mem,\n-\t\t\t\t\t    VOIDmode,\n-\t\t\t\t\t    loop_mems[j].mem,\n-\t\t\t\t\t    rtx_varies_p))\n-\t\t    {\n-\t\t      /* It's not safe to hoist loop_mems[i] out of\n-\t\t\t the loop because writes to it might not be\n-\t\t\t seen by reads from loop_mems[j].  */\n-\t\t      loop_mems[i].optimize = 0;\n-\t\t      break;\n-\t\t    }\n+\t\t  /* It's not safe to hoist loop_mems[i] out of\n+\t\t     the loop because writes to it might not be\n+\t\t     seen by reads from loop_mems[j].  */\n+\t\t  loop_mems[i].optimize = 0;\n+\t\t  break;\n \t\t}\n \t    }\n+\t}\n \n-\t  if (maybe_never && may_trap_p (mem))\n-\t    /* We can't access the MEM outside the loop; it might\n-\t       cause a trap that wouldn't have happened otherwise.  */\n-\t    loop_mems[i].optimize = 0;\n+      if (maybe_never && may_trap_p (mem))\n+\t/* We can't access the MEM outside the loop; it might\n+\t   cause a trap that wouldn't have happened otherwise.  */\n+\tloop_mems[i].optimize = 0;\n \t  \n-\t  if (!loop_mems[i].optimize)\n-\t    /* We thought we were going to lift this MEM out of the\n-\t       loop, but later discovered that we could not.  */\n-\t    continue;\n+      if (!loop_mems[i].optimize)\n+\t/* We thought we were going to lift this MEM out of the\n+\t   loop, but later discovered that we could not.  */\n+\tcontinue;\n \n-\t  /* Allocate a pseudo for this MEM.  We set REG_USERVAR_P in\n-\t     order to keep scan_loop from moving stores to this MEM\n-\t     out of the loop just because this REG is neither a\n-\t     user-variable nor used in the loop test.  */\n-\t  reg = gen_reg_rtx (GET_MODE (mem));\n-\t  REG_USERVAR_P (reg) = 1;\n-\t  loop_mems[i].reg = reg;\n-\n-\t  /* Now, replace all references to the MEM with the\n-\t     corresponding pesudos.  */\n-\t  for (p = next_insn_in_loop (scan_start, scan_start, end, loop_top);\n-\t       p != NULL_RTX;\n-\t       p = next_insn_in_loop (p, scan_start, end, loop_top))\n-\t    {\n-\t      rtx_and_int ri;\n-\t      ri.r = p;\n-\t      ri.i = i;\n-\t      for_each_rtx (&p, replace_loop_mem, &ri);\n-\t    }\n+      /* Allocate a pseudo for this MEM.  We set REG_USERVAR_P in\n+\t order to keep scan_loop from moving stores to this MEM\n+\t out of the loop just because this REG is neither a\n+\t user-variable nor used in the loop test.  */\n+      reg = gen_reg_rtx (GET_MODE (mem));\n+      REG_USERVAR_P (reg) = 1;\n+      loop_mems[i].reg = reg;\n+\n+      /* Now, replace all references to the MEM with the\n+\t corresponding pesudos.  */\n+      for (p = next_insn_in_loop (scan_start, scan_start, end, loop_top);\n+\t   p != NULL_RTX;\n+\t   p = next_insn_in_loop (p, scan_start, end, loop_top))\n+\t{\n+\t  rtx_and_int ri;\n+\t  ri.r = p;\n+\t  ri.i = i;\n+\t  for_each_rtx (&p, replace_loop_mem, &ri);\n+\t}\n \n-\t  if (!apply_change_group ())\n-\t    /* We couldn't replace all occurrences of the MEM.  */\n-\t    loop_mems[i].optimize = 0;\n-\t  else\n-\t    {\n-\t      rtx set;\n+      if (! apply_change_group ())\n+\t/* We couldn't replace all occurrences of the MEM.  */\n+\tloop_mems[i].optimize = 0;\n+      else\n+\t{\n+\t  rtx set;\n \n-\t      /* Load the memory immediately before START, which is\n-\t\t the NOTE_LOOP_BEG.  */\n-\t      set = gen_move_insn (reg, mem);\n-\t      emit_insn_before (set, start);\n+\t  /* Load the memory immediately before START, which is\n+\t     the NOTE_LOOP_BEG.  */\n+\t  set = gen_move_insn (reg, mem);\n+\t  emit_insn_before (set, start);\n \n-\t      if (written)\n+\t  if (written)\n+\t    {\n+\t      if (label == NULL_RTX)\n \t\t{\n-\t\t  if (label == NULL_RTX)\n-\t\t    {\n-\t\t      /* We must compute the former\n-\t\t\t right-after-the-end label before we insert\n-\t\t\t the new one.  */\n-\t\t      end_label = next_label (end);\n-\t\t      label = gen_label_rtx ();\n-\t\t      emit_label_after (label, end);\n-\t\t    }\n-\n-\t\t  /* Store the memory immediately after END, which is\n-\t\t   the NOTE_LOOP_END.  */\n-\t\t  set = gen_move_insn (copy_rtx (mem), reg); \n-\t\t  emit_insn_after (set, label);\n+\t\t  /* We must compute the former\n+\t\t     right-after-the-end label before we insert\n+\t\t     the new one.  */\n+\t\t  end_label = next_label (end);\n+\t\t  label = gen_label_rtx ();\n+\t\t  emit_label_after (label, end);\n \t\t}\n \n-\t      if (loop_dump_stream)\n-\t\t{\n-\t\t  fprintf (loop_dump_stream, \"Hoisted regno %d %s from \",\n-\t\t\t   REGNO (reg), (written ? \"r/w\" : \"r/o\"));\n-\t\t  print_rtl (loop_dump_stream, mem);\n-\t\t  fputc ('\\n', loop_dump_stream);\n-\t\t}\n+\t      /* Store the memory immediately after END, which is\n+\t\t the NOTE_LOOP_END.  */\n+\t      set = gen_move_insn (copy_rtx (mem), reg); \n+\t      emit_insn_after (set, label);\n+\t    }\n+\n+\t  if (loop_dump_stream)\n+\t    {\n+\t      fprintf (loop_dump_stream, \"Hoisted regno %d %s from \",\n+\t\t       REGNO (reg), (written ? \"r/w\" : \"r/o\"));\n+\t      print_rtl (loop_dump_stream, mem);\n+\t      fputc ('\\n', loop_dump_stream);\n \t    }\n \t}\n     }"}]}