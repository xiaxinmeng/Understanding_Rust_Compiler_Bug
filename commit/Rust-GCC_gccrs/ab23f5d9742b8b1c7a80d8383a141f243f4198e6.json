{"sha": "ab23f5d9742b8b1c7a80d8383a141f243f4198e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWIyM2Y1ZDk3NDJiOGIxYzdhODBkODM4M2ExNDFmMjQzZjQxOThlNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-11-17T18:37:45Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-11-17T18:37:45Z"}, "message": "Add basic support for direct_optab internal functions\n\nThis patch adds a concept of internal functions that map directly to an\noptab (here called \"direct internal functions\").  The function can only\nbe used if the associated optab can be used.\n\nWe currently have four functions like that:\n\n- LOAD_LANES\n- STORE_LANES\n- MASK_LOAD\n- MASK_STORE\n\nso the patch converts them to the new infrastructure.  These four\nall need different types of optabs, but future patches will add\nregular unary and binary ones.\n\nIn general we need one or two modes to decide whether an optab is\nsupported, depending on whether it's a convert_optab or not.\nThis in turn means that we need up to two types to decide whether\nan internal function is supported.  The patch records which types\nare needed for each internal function, using -1 if the return type\nshould be used and N>=0 if the type of argument N should be used.\n\n(LOAD_LANES and STORE_LANES are unusual in that both optab modes\ncome from the same array type.)\n\nTested on x86_64-linux-gnu, aarch64-linux-gnu and arm-linux-gnueabi.\n\ngcc/\n\t* coretypes.h (tree_pair): New type.\n\t* internal-fn.def (DEF_INTERNAL_OPTAB_FN): New macro.  Use it\n\tfor MASK_LOAD, LOAD_LANES, MASK_STORE and STORE_LANES.\n\t* internal-fn.h (direct_internal_fn_info): New structure.\n\t(direct_internal_fn_array): Declare.\n\t(direct_internal_fn_p, direct_internal_fn): New functions.\n\t(direct_internal_fn_types, direct_internal_fn_supported_p): Declare.\n\t* internal-fn.c (not_direct, mask_load_direct, load_lanes_direct)\n\t(mask_store_direct, store_lanes_direct): New macros.\n\t(direct_internal_fn_array) New array.\n\t(get_multi_vector_move): Return the optab handler without asserting\n\tthat it is available.\n\t(expand_LOAD_LANES): Rename to...\n\t(expand_load_lanes_optab_fn): ...this and add an optab argument.\n\t(expand_STORE_LANES): Rename to...\n\t(expand_store_lanes_optab_fn): ...this and add an optab argument.\n\t(expand_MASK_LOAD): Rename to...\n\t(expand_mask_load_optab_fn): ...this and add an optab argument.\n\t(expand_MASK_STORE): Rename to...\n\t(expand_mask_store_optab_fn): ...this and add an optab argument.\n\t(direct_internal_fn_types, direct_optab_supported_p)\n\t(multi_vector_optab_supported_p, direct_internal_fn_supported_p)\n\t(direct_internal_fn_supported_p): New functions.\n\t(direct_mask_load_optab_supported_p): New macro.\n\t(direct_load_lanes_optab_supported_p): Likewise.\n\t(direct_mask_store_optab_supported_p): Likewise.\n\t(direct_store_lanes_optab_supported_p): Likewise.\n\nFrom-SVN: r230473", "tree": {"sha": "7992187ca8d4f9960f0586f1f0304b08fcb6e935", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7992187ca8d4f9960f0586f1f0304b08fcb6e935"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab23f5d9742b8b1c7a80d8383a141f243f4198e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab23f5d9742b8b1c7a80d8383a141f243f4198e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab23f5d9742b8b1c7a80d8383a141f243f4198e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab23f5d9742b8b1c7a80d8383a141f243f4198e6/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "00175cb22a6ec9029f64044a9665c7390d53e5f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00175cb22a6ec9029f64044a9665c7390d53e5f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00175cb22a6ec9029f64044a9665c7390d53e5f6"}], "stats": {"total": 254, "additions": 233, "deletions": 21}, "files": [{"sha": "bdb295c6f2463b01a4c1002eac451ca1473b9e68", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab23f5d9742b8b1c7a80d8383a141f243f4198e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab23f5d9742b8b1c7a80d8383a141f243f4198e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab23f5d9742b8b1c7a80d8383a141f243f4198e6", "patch": "@@ -1,3 +1,33 @@\n+2015-11-17  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* coretypes.h (tree_pair): New type.\n+\t* internal-fn.def (DEF_INTERNAL_OPTAB_FN): New macro.  Use it\n+\tfor MASK_LOAD, LOAD_LANES, MASK_STORE and STORE_LANES.\n+\t* internal-fn.h (direct_internal_fn_info): New structure.\n+\t(direct_internal_fn_array): Declare.\n+\t(direct_internal_fn_p, direct_internal_fn): New functions.\n+\t(direct_internal_fn_types, direct_internal_fn_supported_p): Declare.\n+\t* internal-fn.c (not_direct, mask_load_direct, load_lanes_direct)\n+\t(mask_store_direct, store_lanes_direct): New macros.\n+\t(direct_internal_fn_array) New array.\n+\t(get_multi_vector_move): Return the optab handler without asserting\n+\tthat it is available.\n+\t(expand_LOAD_LANES): Rename to...\n+\t(expand_load_lanes_optab_fn): ...this and add an optab argument.\n+\t(expand_STORE_LANES): Rename to...\n+\t(expand_store_lanes_optab_fn): ...this and add an optab argument.\n+\t(expand_MASK_LOAD): Rename to...\n+\t(expand_mask_load_optab_fn): ...this and add an optab argument.\n+\t(expand_MASK_STORE): Rename to...\n+\t(expand_mask_store_optab_fn): ...this and add an optab argument.\n+\t(direct_internal_fn_types, direct_optab_supported_p)\n+\t(multi_vector_optab_supported_p, direct_internal_fn_supported_p)\n+\t(direct_internal_fn_supported_p): New functions.\n+\t(direct_mask_load_optab_supported_p): New macro.\n+\t(direct_load_lanes_optab_supported_p): Likewise.\n+\t(direct_mask_store_optab_supported_p): Likewise.\n+\t(direct_store_lanes_optab_supported_p): Likewise.\n+\n 2015-11-17  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-core.h (internal_fn): Move immediately after the definition"}, {"sha": "d4a75db3b283c761741fd5e2585dc3afbdee2259", "filename": "gcc/coretypes.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab23f5d9742b8b1c7a80d8383a141f243f4198e6/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab23f5d9742b8b1c7a80d8383a141f243f4198e6/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=ab23f5d9742b8b1c7a80d8383a141f243f4198e6", "patch": "@@ -251,6 +251,8 @@ namespace gcc {\n   class context;\n }\n \n+typedef std::pair <tree, tree> tree_pair;\n+\n #else\n \n struct _dont_use_rtx_here_;"}, {"sha": "e77006d4dd317eede139fac7349b952b80ed43b2", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 129, "deletions": 15, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab23f5d9742b8b1c7a80d8383a141f243f4198e6/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab23f5d9742b8b1c7a80d8383a141f243f4198e6/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=ab23f5d9742b8b1c7a80d8383a141f243f4198e6", "patch": "@@ -66,29 +66,41 @@ init_internal_fns ()\n   internal_fn_fnspec_array[IFN_LAST] = 0;\n }\n \n+/* Create static initializers for the information returned by\n+   direct_internal_fn.  */\n+#define not_direct { -2, -2 }\n+#define mask_load_direct { -1, 2 }\n+#define load_lanes_direct { -1, -1 }\n+#define mask_store_direct { 3, 2 }\n+#define store_lanes_direct { 0, 0 }\n+\n+const direct_internal_fn_info direct_internal_fn_array[IFN_LAST + 1] = {\n+#define DEF_INTERNAL_FN(CODE, FLAGS, FNSPEC) not_direct,\n+#define DEF_INTERNAL_OPTAB_FN(CODE, FLAGS, OPTAB, TYPE) TYPE##_direct,\n+#include \"internal-fn.def\"\n+  not_direct\n+};\n+\n /* ARRAY_TYPE is an array of vector modes.  Return the associated insn\n-   for load-lanes-style optab OPTAB.  The insn must exist.  */\n+   for load-lanes-style optab OPTAB, or CODE_FOR_nothing if none.  */\n \n static enum insn_code\n get_multi_vector_move (tree array_type, convert_optab optab)\n {\n-  enum insn_code icode;\n   machine_mode imode;\n   machine_mode vmode;\n \n   gcc_assert (TREE_CODE (array_type) == ARRAY_TYPE);\n   imode = TYPE_MODE (array_type);\n   vmode = TYPE_MODE (TREE_TYPE (array_type));\n \n-  icode = convert_optab_handler (optab, imode, vmode);\n-  gcc_assert (icode != CODE_FOR_nothing);\n-  return icode;\n+  return convert_optab_handler (optab, imode, vmode);\n }\n \n-/* Expand LOAD_LANES call STMT.  */\n+/* Expand LOAD_LANES call STMT using optab OPTAB.  */\n \n static void\n-expand_LOAD_LANES (gcall *stmt)\n+expand_load_lanes_optab_fn (gcall *stmt, convert_optab optab)\n {\n   struct expand_operand ops[2];\n   tree type, lhs, rhs;\n@@ -106,13 +118,13 @@ expand_LOAD_LANES (gcall *stmt)\n \n   create_output_operand (&ops[0], target, TYPE_MODE (type));\n   create_fixed_operand (&ops[1], mem);\n-  expand_insn (get_multi_vector_move (type, vec_load_lanes_optab), 2, ops);\n+  expand_insn (get_multi_vector_move (type, optab), 2, ops);\n }\n \n-/* Expand STORE_LANES call STMT.  */\n+/* Expand STORE_LANES call STMT using optab OPTAB.  */\n \n static void\n-expand_STORE_LANES (gcall *stmt)\n+expand_store_lanes_optab_fn (gcall *stmt, convert_optab optab)\n {\n   struct expand_operand ops[2];\n   tree type, lhs, rhs;\n@@ -130,7 +142,7 @@ expand_STORE_LANES (gcall *stmt)\n \n   create_fixed_operand (&ops[0], target);\n   create_input_operand (&ops[1], reg, TYPE_MODE (type));\n-  expand_insn (get_multi_vector_move (type, vec_store_lanes_optab), 2, ops);\n+  expand_insn (get_multi_vector_move (type, optab), 2, ops);\n }\n \n static void\n@@ -1867,8 +1879,10 @@ expand_LOOP_VECTORIZED (gcall *)\n   gcc_unreachable ();\n }\n \n+/* Expand MASK_LOAD call STMT using optab OPTAB.  */\n+\n static void\n-expand_MASK_LOAD (gcall *stmt)\n+expand_mask_load_optab_fn (gcall *stmt, convert_optab optab)\n {\n   struct expand_operand ops[3];\n   tree type, lhs, rhs, maskt;\n@@ -1889,13 +1903,15 @@ expand_MASK_LOAD (gcall *stmt)\n   create_output_operand (&ops[0], target, TYPE_MODE (type));\n   create_fixed_operand (&ops[1], mem);\n   create_input_operand (&ops[2], mask, TYPE_MODE (TREE_TYPE (maskt)));\n-  expand_insn (convert_optab_handler (maskload_optab, TYPE_MODE (type),\n+  expand_insn (convert_optab_handler (optab, TYPE_MODE (type),\n \t\t\t\t      TYPE_MODE (TREE_TYPE (maskt))),\n \t       3, ops);\n }\n \n+/* Expand MASK_STORE call STMT using optab OPTAB.  */\n+\n static void\n-expand_MASK_STORE (gcall *stmt)\n+expand_mask_store_optab_fn (gcall *stmt, convert_optab optab)\n {\n   struct expand_operand ops[3];\n   tree type, lhs, rhs, maskt;\n@@ -1914,7 +1930,7 @@ expand_MASK_STORE (gcall *stmt)\n   create_fixed_operand (&ops[0], mem);\n   create_input_operand (&ops[1], reg, TYPE_MODE (type));\n   create_input_operand (&ops[2], mask, TYPE_MODE (TREE_TYPE (maskt)));\n-  expand_insn (convert_optab_handler (maskstore_optab, TYPE_MODE (type),\n+  expand_insn (convert_optab_handler (optab, TYPE_MODE (type),\n \t\t\t\t      TYPE_MODE (TREE_TYPE (maskt))),\n \t       3, ops);\n }\n@@ -2054,6 +2070,104 @@ expand_GOACC_REDUCTION (gcall *stmt ATTRIBUTE_UNUSED)\n   gcc_unreachable ();\n }\n \n+/* RETURN_TYPE and ARGS are a return type and argument list that are\n+   in principle compatible with FN (which satisfies direct_internal_fn_p).\n+   Return the types that should be used to determine whether the\n+   target supports FN.  */\n+\n+tree_pair\n+direct_internal_fn_types (internal_fn fn, tree return_type, tree *args)\n+{\n+  const direct_internal_fn_info &info = direct_internal_fn (fn);\n+  tree type0 = (info.type0 < 0 ? return_type : TREE_TYPE (args[info.type0]));\n+  tree type1 = (info.type1 < 0 ? return_type : TREE_TYPE (args[info.type1]));\n+  return tree_pair (type0, type1);\n+}\n+\n+/* CALL is a call whose return type and arguments are in principle\n+   compatible with FN (which satisfies direct_internal_fn_p).  Return the\n+   types that should be used to determine whether the target supports FN.  */\n+\n+tree_pair\n+direct_internal_fn_types (internal_fn fn, gcall *call)\n+{\n+  const direct_internal_fn_info &info = direct_internal_fn (fn);\n+  tree op0 = (info.type0 < 0\n+\t      ? gimple_call_lhs (call)\n+\t      : gimple_call_arg (call, info.type0));\n+  tree op1 = (info.type1 < 0\n+\t      ? gimple_call_lhs (call)\n+\t      : gimple_call_arg (call, info.type1));\n+  return tree_pair (TREE_TYPE (op0), TREE_TYPE (op1));\n+}\n+\n+/* Return true if OPTAB is supported for TYPES (whose modes should be\n+   the same).  Used for simple direct optabs.  */\n+\n+static bool\n+direct_optab_supported_p (direct_optab optab, tree_pair types)\n+{\n+  machine_mode mode = TYPE_MODE (types.first);\n+  gcc_checking_assert (mode == TYPE_MODE (types.second));\n+  return direct_optab_handler (optab, mode) != CODE_FOR_nothing;\n+}\n+\n+/* Return true if load/store lanes optab OPTAB is supported for\n+   array type TYPES.first.  */\n+\n+static bool\n+multi_vector_optab_supported_p (convert_optab optab, tree_pair types)\n+{\n+  return get_multi_vector_move (types.first, optab) != CODE_FOR_nothing;\n+}\n+\n+#define direct_mask_load_optab_supported_p direct_optab_supported_p\n+#define direct_load_lanes_optab_supported_p multi_vector_optab_supported_p\n+#define direct_mask_store_optab_supported_p direct_optab_supported_p\n+#define direct_store_lanes_optab_supported_p multi_vector_optab_supported_p\n+\n+/* Return true if FN is supported for the types in TYPES.  The types\n+   are those associated with the \"type0\" and \"type1\" fields of FN's\n+   direct_internal_fn_info structure.  */\n+\n+bool\n+direct_internal_fn_supported_p (internal_fn fn, tree_pair types)\n+{\n+  switch (fn)\n+    {\n+#define DEF_INTERNAL_FN(CODE, FLAGS, FNSPEC) \\\n+    case IFN_##CODE: break;\n+#define DEF_INTERNAL_OPTAB_FN(CODE, FLAGS, OPTAB, TYPE) \\\n+    case IFN_##CODE: \\\n+      return direct_##TYPE##_optab_supported_p (OPTAB##_optab, types);\n+#include \"internal-fn.def\"\n+\n+    case IFN_LAST:\n+      break;\n+    }\n+  gcc_unreachable ();\n+}\n+\n+/* Return true if FN is supported for type TYPE.  The caller knows that\n+   the \"type0\" and \"type1\" fields of FN's direct_internal_fn_info\n+   structure are the same.  */\n+\n+bool\n+direct_internal_fn_supported_p (internal_fn fn, tree type)\n+{\n+  const direct_internal_fn_info &info = direct_internal_fn (fn);\n+  gcc_checking_assert (info.type0 == info.type1);\n+  return direct_internal_fn_supported_p (fn, tree_pair (type, type));\n+}\n+\n+#define DEF_INTERNAL_OPTAB_FN(CODE, FLAGS, OPTAB, TYPE) \\\n+  static void\t\t\t\t\t\t\\\n+  expand_##CODE (gcall *stmt)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    expand_##TYPE##_optab_fn (stmt, OPTAB##_optab);\t\\\n+  }\n+#include \"internal-fn.def\"\n+\n /* Routines to expand each internal function, indexed by function number.\n    Each routine has the prototype:\n "}, {"sha": "a5f6df26a91f57f71b922ff6e19edb567437c22d", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab23f5d9742b8b1c7a80d8383a141f243f4198e6/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab23f5d9742b8b1c7a80d8383a141f243f4198e6/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=ab23f5d9742b8b1c7a80d8383a141f243f4198e6", "patch": "@@ -26,29 +26,56 @@ along with GCC; see the file COPYING3.  If not see\n    and its operands are more naturally represented as a GIMPLE_CALL\n    than a GIMPLE_ASSIGN.\n \n-   Each entry in this file has the form:\n+   Each entry in this file has one of the forms:\n \n      DEF_INTERNAL_FN (NAME, FLAGS, FNSPEC)\n+     DEF_INTERNAL_OPTAB_FN (NAME, FLAGS, OPTAB, TYPE)\n \n    where NAME is the name of the function, FLAGS is a set of\n    ECF_* flags and FNSPEC is a string describing functions fnspec.\n    \n+   DEF_INTERNAL_OPTAB_FN defines an internal function that maps to a\n+   direct optab.  The function should only be called with a given\n+   set of types if the associated optab is available for the modes\n+   of those types.  OPTAB says what optab to use (without the trailing\n+   \"_optab\") and TYPE categorizes the optab based on its inputs and\n+   outputs.  The possible types of optab are:\n+\n+   - mask_load: currently just maskload\n+   - load_lanes: currently just vec_load_lanes\n+\n+   - mask_store: currently just maskstore\n+   - store_lanes: currently just vec_store_lanes\n+\n    Each entry must have a corresponding expander of the form:\n \n      void expand_NAME (gimple_call stmt)\n \n-   where STMT is the statement that performs the call.  */\n+   where STMT is the statement that performs the call.  These are generated\n+   automatically for optab functions and call out to a function or macro\n+   called expand_<TYPE>_optab_fn.  */\n+\n+#ifndef DEF_INTERNAL_FN\n+#define DEF_INTERNAL_FN(CODE, FLAGS, FNSPEC)\n+#endif\n+\n+#ifndef DEF_INTERNAL_OPTAB_FN\n+#define DEF_INTERNAL_OPTAB_FN(NAME, FLAGS, OPTAB, TYPE) \\\n+  DEF_INTERNAL_FN (NAME, FLAGS | ECF_LEAF, NULL)\n+#endif\n+\n+DEF_INTERNAL_OPTAB_FN (MASK_LOAD, ECF_PURE, maskload, mask_load)\n+DEF_INTERNAL_OPTAB_FN (LOAD_LANES, ECF_CONST, vec_load_lanes, load_lanes)\n+\n+DEF_INTERNAL_OPTAB_FN (MASK_STORE, 0, maskstore, mask_store)\n+DEF_INTERNAL_OPTAB_FN (STORE_LANES, ECF_CONST, vec_store_lanes, store_lanes)\n \n-DEF_INTERNAL_FN (LOAD_LANES, ECF_CONST | ECF_LEAF, NULL)\n-DEF_INTERNAL_FN (STORE_LANES, ECF_CONST | ECF_LEAF, NULL)\n DEF_INTERNAL_FN (GOMP_SIMD_LANE, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMD_VF, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMD_LAST_LANE, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMD_ORDERED_START, ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMD_ORDERED_END, ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (LOOP_VECTORIZED, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n-DEF_INTERNAL_FN (MASK_LOAD, ECF_PURE | ECF_LEAF, NULL)\n-DEF_INTERNAL_FN (MASK_STORE, ECF_LEAF, NULL)\n DEF_INTERNAL_FN (ANNOTATE,  ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (UBSAN_NULL, ECF_LEAF | ECF_NOTHROW, \".R.\")\n DEF_INTERNAL_FN (UBSAN_BOUNDS, ECF_LEAF | ECF_NOTHROW, NULL)\n@@ -87,4 +114,5 @@ DEF_INTERNAL_FN (GOACC_LOOP, ECF_PURE | ECF_NOTHROW, NULL)\n /* OpenACC reduction abstraction.  See internal-fn.h  for usage.  */\n DEF_INTERNAL_FN (GOACC_REDUCTION, ECF_NOTHROW | ECF_LEAF, NULL)\n \n+#undef DEF_INTERNAL_OPTAB_FN\n #undef DEF_INTERNAL_FN"}, {"sha": "31e895ecd34a12182592debcce5e04a06b1e75d5", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab23f5d9742b8b1c7a80d8383a141f243f4198e6/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab23f5d9742b8b1c7a80d8383a141f243f4198e6/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=ab23f5d9742b8b1c7a80d8383a141f243f4198e6", "patch": "@@ -123,6 +123,44 @@ internal_fn_fnspec (enum internal_fn fn)\n   return internal_fn_fnspec_array[(int) fn];\n }\n \n+/* Describes an internal function that maps directly to an optab.  */\n+struct direct_internal_fn_info\n+{\n+  /* optabs can be parameterized by one or two modes.  These fields describe\n+     how to select those modes from the types of the return value and\n+     arguments.  A value of -1 says that the mode is determined by the\n+     return type while a value N >= 0 says that the mode is determined by\n+     the type of argument N.  A value of -2 says that this internal\n+     function isn't directly mapped to an optab.  */\n+  signed int type0 : 8;\n+  signed int type1 : 8;\n+};\n+\n+extern const direct_internal_fn_info direct_internal_fn_array[IFN_LAST + 1];\n+\n+/* Return true if FN is mapped directly to an optab.  */\n+\n+inline bool\n+direct_internal_fn_p (internal_fn fn)\n+{\n+  return direct_internal_fn_array[fn].type0 >= -1;\n+}\n+\n+/* Return optab information about internal function FN.  Only meaningful\n+   if direct_internal_fn_p (FN).  */\n+\n+inline const direct_internal_fn_info &\n+direct_internal_fn (internal_fn fn)\n+{\n+  gcc_checking_assert (direct_internal_fn_p (fn));\n+  return direct_internal_fn_array[fn];\n+}\n+\n+extern tree_pair direct_internal_fn_types (internal_fn, tree, tree *);\n+extern tree_pair direct_internal_fn_types (internal_fn, gcall *);\n+extern bool direct_internal_fn_supported_p (internal_fn, tree_pair);\n+extern bool direct_internal_fn_supported_p (internal_fn, tree);\n+\n extern void expand_internal_call (gcall *);\n \n #endif"}]}