{"sha": "9a7a4398d3b33eb4ea3be8094e7a381921f6a4f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE3YTQzOThkM2IzM2ViNGVhM2JlODA5NGU3YTM4MTkyMWY2YTRmNg==", "commit": {"author": {"name": "Ulrich Weigand", "email": "ulrich.weigand@linaro.org", "date": "2012-05-04T12:27:04Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2012-05-04T12:27:04Z"}, "message": "tree-vect-patterns.c (vect_single_imm_use): New function.\n\n\t* tree-vect-patterns.c (vect_single_imm_use): New function.\n\t(vect_recog_widen_mult_pattern): Use it instead of open-coding loop.\n\t(vect_recog_over_widening_pattern): Likewise.\n\t(vect_recog_widen_shift_pattern): Likewise.\n\nFrom-SVN: r187157", "tree": {"sha": "b9fce3229d85a7e3f5e61e604faa5b5f56f40b66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9fce3229d85a7e3f5e61e604faa5b5f56f40b66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a7a4398d3b33eb4ea3be8094e7a381921f6a4f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a7a4398d3b33eb4ea3be8094e7a381921f6a4f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a7a4398d3b33eb4ea3be8094e7a381921f6a4f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a7a4398d3b33eb4ea3be8094e7a381921f6a4f6/comments", "author": null, "committer": null, "parents": [{"sha": "f71cf56a386f60e5baf5e0a2a88913ab36637ec8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f71cf56a386f60e5baf5e0a2a88913ab36637ec8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f71cf56a386f60e5baf5e0a2a88913ab36637ec8"}], "stats": {"total": 89, "additions": 38, "deletions": 51}, "files": [{"sha": "41dba2e7b0f9c40cf106c2954d44a2309dd0b322", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a7a4398d3b33eb4ea3be8094e7a381921f6a4f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a7a4398d3b33eb4ea3be8094e7a381921f6a4f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a7a4398d3b33eb4ea3be8094e7a381921f6a4f6", "patch": "@@ -1,3 +1,10 @@\n+2012-05-04  Ulrich Weigand  <ulrich.weigand@linaro.org>\n+\n+\t* tree-vect-patterns.c (vect_single_imm_use): New function.\n+\t(vect_recog_widen_mult_pattern): Use it instead of open-coding loop.\n+\t(vect_recog_over_widening_pattern): Likewise.\n+\t(vect_recog_widen_shift_pattern): Likewise.\n+\n 2012-05-04  Ulrich Weigand  <ulrich.weigand@linaro.org>\n \n \t* tree-vect-patterns.c (vect_same_loop_or_bb_p): New function."}, {"sha": "99346546dba295be11255376bc2778e8b94105f9", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 31, "deletions": 51, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a7a4398d3b33eb4ea3be8094e7a381921f6a4f6/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a7a4398d3b33eb4ea3be8094e7a381921f6a4f6/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=9a7a4398d3b33eb4ea3be8094e7a381921f6a4f6", "patch": "@@ -119,6 +119,25 @@ vect_same_loop_or_bb_p (gimple stmt1, gimple stmt2)\n   return true;\n }\n \n+/* If the LHS of DEF_STMT has a single use, and that statement is\n+   in the same loop or basic block, return it.  */\n+\n+static gimple\n+vect_single_imm_use (gimple def_stmt)\n+{\n+  tree lhs = gimple_assign_lhs (def_stmt);\n+  use_operand_p use_p;\n+  gimple use_stmt;\n+\n+  if (!single_imm_use (lhs, &use_p, &use_stmt))\n+    return NULL;\n+\n+  if (!vect_same_loop_or_bb_p (def_stmt, use_stmt))\n+    return NULL;\n+\n+  return use_stmt;\n+}\n+\n /* Check whether NAME, an ssa-name used in USE_STMT,\n    is a result of a type promotion or demotion, such that:\n      DEF_STMT: NAME = NOP (name0)\n@@ -636,31 +655,18 @@ vect_recog_widen_mult_pattern (VEC (gimple, heap) **stmts,\n      Use unsigned TYPE as the type for WIDEN_MULT_EXPR.  */\n   if (TYPE_UNSIGNED (type) != TYPE_UNSIGNED (half_type0))\n     {\n-      tree lhs = gimple_assign_lhs (last_stmt), use_lhs;\n-      imm_use_iterator imm_iter;\n-      use_operand_p use_p;\n-      int nuses = 0;\n-      gimple use_stmt = NULL;\n+      gimple use_stmt;\n+      tree use_lhs;\n       tree use_type;\n \n       if (TYPE_UNSIGNED (type) == TYPE_UNSIGNED (half_type1))\n         return NULL;\n \n-      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, lhs)\n-        {\n-\t  if (is_gimple_debug (USE_STMT (use_p)))\n-\t    continue;\n-          use_stmt = USE_STMT (use_p);\n-          nuses++;\n-        }\n-\n-      if (nuses != 1 || !is_gimple_assign (use_stmt)\n-          || gimple_assign_rhs_code (use_stmt) != NOP_EXPR)\n+      use_stmt = vect_single_imm_use (last_stmt);\n+      if (!use_stmt || !is_gimple_assign (use_stmt)\n+\t  || gimple_assign_rhs_code (use_stmt) != NOP_EXPR)\n         return NULL;\n \n-      if (!vect_same_loop_or_bb_p (last_stmt, use_stmt))\n-\treturn NULL;\n-\n       use_lhs = gimple_assign_lhs (use_stmt);\n       use_type = TREE_TYPE (use_lhs);\n       if (!INTEGRAL_TYPE_P (use_type)\n@@ -1165,10 +1171,7 @@ vect_recog_over_widening_pattern (VEC (gimple, heap) **stmts,\n {\n   gimple stmt = VEC_pop (gimple, *stmts);\n   gimple pattern_stmt = NULL, new_def_stmt, prev_stmt = NULL, use_stmt = NULL;\n-  tree op0, op1, vectype = NULL_TREE, lhs, use_lhs, use_type;\n-  imm_use_iterator imm_iter;\n-  use_operand_p use_p;\n-  int nuses = 0;\n+  tree op0, op1, vectype = NULL_TREE, use_lhs, use_type;\n   tree var = NULL_TREE, new_type = NULL_TREE, tmp, new_oprnd;\n   bool first;\n   tree type = NULL;\n@@ -1192,18 +1195,8 @@ vect_recog_over_widening_pattern (VEC (gimple, heap) **stmts,\n         }\n \n       /* STMT can be performed on a smaller type.  Check its uses.  */\n-      lhs = gimple_assign_lhs (stmt);\n-      nuses = 0;\n-      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, lhs)\n-        {\n-          if (is_gimple_debug (USE_STMT (use_p)))\n-            continue;\n-          use_stmt = USE_STMT (use_p);\n-          nuses++;\n-        }\n-\n-      if (nuses != 1 || !is_gimple_assign (use_stmt)\n-\t  || !vect_same_loop_or_bb_p (stmt, use_stmt))\n+      use_stmt = vect_single_imm_use (stmt);\n+      if (!use_stmt || !is_gimple_assign (use_stmt))\n         return NULL;\n \n       /* Create pattern statement for STMT.  */\n@@ -1454,12 +1447,6 @@ vect_recog_widen_shift_pattern (VEC (gimple, heap) **stmts,\n      Use unsigned TYPE as the type for WIDEN_LSHIFT_EXPR.  */\n   if (TYPE_UNSIGNED (type) != TYPE_UNSIGNED (half_type0))\n     {\n-      tree lhs = gimple_assign_lhs (last_stmt), use_lhs;\n-      imm_use_iterator imm_iter;\n-      use_operand_p use_p;\n-      int nuses = 0;\n-      tree use_type;\n-\n       if (over_widen)\n         {\n           /* In case of over-widening pattern, S4 should be ORIG_STMT itself.\n@@ -1472,21 +1459,14 @@ vect_recog_widen_shift_pattern (VEC (gimple, heap) **stmts,\n         }\n       else\n         {\n-          FOR_EACH_IMM_USE_FAST (use_p, imm_iter, lhs)\n-            {\n-\t      if (is_gimple_debug (USE_STMT (use_p)))\n-\t        continue;\n-      \t      use_stmt = USE_STMT (use_p);\n- \t      nuses++;\n-            }\n+\t  tree use_type;\n+\t  tree use_lhs;\n \n-          if (nuses != 1 || !is_gimple_assign (use_stmt)\n+\t  use_stmt = vect_single_imm_use (last_stmt);\n+\t  if (!use_stmt || !is_gimple_assign (use_stmt)\n \t      || !CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (use_stmt)))\n \t    return NULL;\n \n-\t  if (!vect_same_loop_or_bb_p (last_stmt, use_stmt))\n-\t    return NULL;\n-\n           use_lhs = gimple_assign_lhs (use_stmt);\n           use_type = TREE_TYPE (use_lhs);\n "}]}