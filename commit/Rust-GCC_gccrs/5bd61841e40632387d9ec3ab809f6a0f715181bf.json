{"sha": "5bd61841e40632387d9ec3ab809f6a0f715181bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJkNjE4NDFlNDA2MzIzODdkOWVjM2FiODA5ZjZhMGY3MTUxODFiZg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-02-13T07:19:25Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-02-13T07:19:25Z"}, "message": "call.c (conversion_kind): New type.\n\n\t* call.c (conversion_kind): New type.\n\t(conversion_rank): Likewise.\n\t(conversion): Likewise.\n\t(CONVERSION_RANK): New macro.\n\t(conversion_obstack): New variable.\n\t(obstack_initialized): Likewise.\n\t(z_candidate): Change type of convs and second_conv.\n\t(candidate_warning): New type.\n\t(IDENTITY_RANK): Remove.\n\t(EXACT_RANK): Likewise.\n\t(PROMO_RANK): Likewise.\n\t(STD_RANK): Likewise.\n\t(PBOOL_RANK): Likewise.\n\t(USER_RANK): Likewise.\n\t(ELLIPSIS_RANK): Likewise.\n\t(BAD_RANK): Likewise.\n\t(ICS_RANK): Likewise.\n\t(ICS_STD_RANK): Likewise.\n\t(ICS_USER_FLAG): Likewise.\n\t(ICS_ELLIPSIS_FLAG): Likewise.\n\t(ICS_THIS_FLAG): Likewise.\n\t(ICS_BAD_FLAG): Likewise.\n\t(NEED_TEMPORARY_P): Likewise.\n\t(CHECK_COPY_CONSTRUCTOR_P): Likewise.\n\t(USER_CONV_CAND): Likewise.\n\t(USER_CONV_FN): Likewise.\n\t(conversion_obstack_alloc): New function.\n\t(alloc_conversion): Likewise.\n\t(validate_conversion_obstack): Likewise.\n\t(alloc_conversions): Likewise.\n\t(build_conv): Adjust to deal with new conversion data structures.\n\t(build_identity_conv): New function.\n\t(build_ambiguous_conv): Likewise.\n\t(standard_conversion): Adjust to deal with new conversion data\n\tstructures.\n\t(convert_class_to_reference): Likewise.\n\t(direct_reference_binding): Likewise.\n\t(reference_binding): Likewise.\n\t(implicit_conversion): Likewise.\n\t(add_candidate): Likewise.\n\t(add_function_candidate): Likewise.\n\t(add_conv_candidate): Likewise.\n\t(build_builtin_candidate): Likewise.\n\t(print_z_candidate): Likewise.\n\t(merge_conversion_sequences): Likewise.\n\t(build_user_type_conversion_1): Likewise.\n\t(build_user_type_conversion): Likewise.\n\t(build_new_function_call): Likewise.\n\t(build_object_call): Likewise.\n\t(conditional_conversion): Likewise.\n\t(build_conditional_expr): Likewise.\n\t(build_new_op): Likewise.\n\t(build_op_delete_call): Likewise.\n\t(convert_like_real): Likewise.\n\t(build_over_call): Likewise.\n\t(build_new_method_call): Likewise.\n\t(is_subseq): Likewise.\n\t(maybe_handle_implicit_object): Likewise.\n\t(maybe_handle_ref_bind): Likewise.\n\t(compare_ics): Likewise.\n\t(source_type): Likewise.\n\t(add_warning): Likewise.\n\t(joust): Likewise.\n\t(can_convert_arg): Likewise.\n\t(can_convert_arg_bad): Likewise.\n\t(perform_implicit_conversion): Likewise.\n\t(perform_direct_initialization_if_possible): Likewise.\n\t(initialize_reference): Likewise.\n\t* cp-lang.c (cp_tree_size): Do not handle WRAPPER.\n\t* cp-tree.def (WRAPPER): Likewise.\n\t(IDENTITY_CONV): Remove.\n\t(LVALUE_CONV): Likewise.\n\t(QUAL_CONV): Likewise.\n\t(STD_CONV): Likewise.\n\t(PTR_CONV): Likewise.\n\t(PMEM_CONV): Likewise.\n\t(BASE_CONV): Likewise.\n\t(REF_BIND): Likewise.\n\t(USER_CONV): Likewise.\n\t(AMBIG_CONV): Likewise.\n\t(RVALUE_CONV): Likewise.\n\t* cp-tree.h (tree_wrapper): Remove.\n\t(WRAPPER_ZC): Remove.\n\t(lang_tree_node): Remove wrapper.\n\t(LOOKUP_SPECULATIVELY): Remove.\n\t(build_op_delete_call): Adjust prototype.\n\t(validate_conversion_obstack): Declare.\n\t(build_zc_wrapper): Remove.\n\t* cvt.c (convert_to_reference): Remove dead code.\n\t(ocp_convert): Likewise.\n\t* decl.c (redeclaration_error_message): Correct handling of\n\ttemplates.\n\t(finish_destructor_body): Do not use LOOKUP_SPECULATIVELY.\n\t(cp_tree_node_structure): Remove WRAPPER case.\n\t* decl2.c (finish_file): Call validate_conversion_obstack.\n\t* init.c (build_new_1): Remove use of LOOKUP_SPECULATIVELY.\n\t(build_op_delete_call): Likewise.\n\t(build_x_delete): Likewise.\n\t(build_delete): Adjust call to build_op_delete_call.\n\t* pt.c (tsubst_friend_declaration): Adjust code to determine\n\twhether or not a friend template is a definition.\n\t(tsubst_decl): Clear DECL_INITIAL for new FUNCTION_DECLs.\n\t* tree.c (build_zc_wrapper): Remove.\n\nFrom-SVN: r77752", "tree": {"sha": "e382a6ccb6d3a95fc45701be992f111188d0bde8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e382a6ccb6d3a95fc45701be992f111188d0bde8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5bd61841e40632387d9ec3ab809f6a0f715181bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bd61841e40632387d9ec3ab809f6a0f715181bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bd61841e40632387d9ec3ab809f6a0f715181bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bd61841e40632387d9ec3ab809f6a0f715181bf/comments", "author": null, "committer": null, "parents": [{"sha": "d349192c3892455e0d54147055f8e03fa120c7a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d349192c3892455e0d54147055f8e03fa120c7a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d349192c3892455e0d54147055f8e03fa120c7a0"}], "stats": {"total": 1640, "additions": 995, "deletions": 645}, "files": [{"sha": "809dcfe876073c3fbd58ba19ec8b4780108e062d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bd61841e40632387d9ec3ab809f6a0f715181bf/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bd61841e40632387d9ec3ab809f6a0f715181bf/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5bd61841e40632387d9ec3ab809f6a0f715181bf", "patch": "@@ -1,3 +1,109 @@\n+2004-02-12  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* call.c (conversion_kind): New type.\n+\t(conversion_rank): Likewise.\n+\t(conversion): Likewise.\n+\t(CONVERSION_RANK): New macro.\n+\t(conversion_obstack): New variable.\n+\t(obstack_initialized): Likewise.\n+\t(z_candidate): Change type of convs and second_conv.\n+\t(candidate_warning): New type.\n+\t(IDENTITY_RANK): Remove.\n+\t(EXACT_RANK): Likewise.\n+\t(PROMO_RANK): Likewise.\n+\t(STD_RANK): Likewise.\n+\t(PBOOL_RANK): Likewise.\n+\t(USER_RANK): Likewise.\n+\t(ELLIPSIS_RANK): Likewise.\n+\t(BAD_RANK): Likewise.\n+\t(ICS_RANK): Likewise.\n+\t(ICS_STD_RANK): Likewise.\n+\t(ICS_USER_FLAG): Likewise.\n+\t(ICS_ELLIPSIS_FLAG): Likewise.\n+\t(ICS_THIS_FLAG): Likewise.\n+\t(ICS_BAD_FLAG): Likewise.\n+\t(NEED_TEMPORARY_P): Likewise.\n+\t(CHECK_COPY_CONSTRUCTOR_P): Likewise.\n+\t(USER_CONV_CAND): Likewise.\n+\t(USER_CONV_FN): Likewise.\n+\t(conversion_obstack_alloc): New function.\n+\t(alloc_conversion): Likewise.\n+\t(validate_conversion_obstack): Likewise.\n+\t(alloc_conversions): Likewise.\n+\t(build_conv): Adjust to deal with new conversion data structures.\n+\t(build_identity_conv): New function.\n+\t(build_ambiguous_conv): Likewise.\n+\t(standard_conversion): Adjust to deal with new conversion data\n+\tstructures.\n+\t(convert_class_to_reference): Likewise.\n+\t(direct_reference_binding): Likewise.\n+\t(reference_binding): Likewise.\n+\t(implicit_conversion): Likewise.\n+\t(add_candidate): Likewise.\n+\t(add_function_candidate): Likewise.\n+\t(add_conv_candidate): Likewise.\n+\t(build_builtin_candidate): Likewise.\n+\t(print_z_candidate): Likewise.\n+\t(merge_conversion_sequences): Likewise.\n+\t(build_user_type_conversion_1): Likewise.\n+\t(build_user_type_conversion): Likewise.\n+\t(build_new_function_call): Likewise.\n+\t(build_object_call): Likewise.\n+\t(conditional_conversion): Likewise.\n+\t(build_conditional_expr): Likewise.\n+\t(build_new_op): Likewise.\n+\t(build_op_delete_call): Likewise.\n+\t(convert_like_real): Likewise.\n+\t(build_over_call): Likewise.\n+\t(build_new_method_call): Likewise.\n+\t(is_subseq): Likewise.\n+\t(maybe_handle_implicit_object): Likewise.\n+\t(maybe_handle_ref_bind): Likewise.\n+\t(compare_ics): Likewise.\n+\t(source_type): Likewise.\n+\t(add_warning): Likewise.\n+\t(joust): Likewise.\n+\t(can_convert_arg): Likewise.\n+\t(can_convert_arg_bad): Likewise.\n+\t(perform_implicit_conversion): Likewise.\n+\t(perform_direct_initialization_if_possible): Likewise.\n+\t(initialize_reference): Likewise.\n+\t* cp-lang.c (cp_tree_size): Do not handle WRAPPER.\n+\t* cp-tree.def (WRAPPER): Likewise.\n+\t(IDENTITY_CONV): Remove.\n+\t(LVALUE_CONV): Likewise.\n+\t(QUAL_CONV): Likewise.\n+\t(STD_CONV): Likewise.\n+\t(PTR_CONV): Likewise.\n+\t(PMEM_CONV): Likewise.\n+\t(BASE_CONV): Likewise.\n+\t(REF_BIND): Likewise.\n+\t(USER_CONV): Likewise.\n+\t(AMBIG_CONV): Likewise.\n+\t(RVALUE_CONV): Likewise.\n+\t* cp-tree.h (tree_wrapper): Remove.\n+\t(WRAPPER_ZC): Remove.\n+\t(lang_tree_node): Remove wrapper.\n+\t(LOOKUP_SPECULATIVELY): Remove.\n+\t(build_op_delete_call): Adjust prototype.\n+\t(validate_conversion_obstack): Declare.\n+\t(build_zc_wrapper): Remove.\n+\t* cvt.c (convert_to_reference): Remove dead code.\n+\t(ocp_convert): Likewise.\n+\t* decl.c (redeclaration_error_message): Correct handling of\n+\ttemplates.\n+\t(finish_destructor_body): Do not use LOOKUP_SPECULATIVELY.\n+\t(cp_tree_node_structure): Remove WRAPPER case.\n+\t* decl2.c (finish_file): Call validate_conversion_obstack.\n+\t* init.c (build_new_1): Remove use of LOOKUP_SPECULATIVELY.\n+\t(build_op_delete_call): Likewise.\n+\t(build_x_delete): Likewise.\n+\t(build_delete): Adjust call to build_op_delete_call.\n+\t* pt.c (tsubst_friend_declaration): Adjust code to determine\n+\twhether or not a friend template is a definition.\n+\t(tsubst_decl): Clear DECL_INITIAL for new FUNCTION_DECLs.\n+\t* tree.c (build_zc_wrapper): Remove.\n+\t\n 2004-02-12  Zack Weinberg  <zack@codesourcery.com>\n \n \t* cp-lang.c: Don't define LANG_HOOKS_BUILTIN_TYPE_DECLS."}, {"sha": "0f7c9e56dc081a295e6b7820a34d93a0554da75c", "filename": "gcc/cp/call.c", "status": "modified", "additions": 842, "deletions": 556, "changes": 1398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bd61841e40632387d9ec3ab809f6a0f715181bf/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bd61841e40632387d9ec3ab809f6a0f715181bf/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=5bd61841e40632387d9ec3ab809f6a0f715181bf", "patch": "@@ -40,10 +40,88 @@ Boston, MA 02111-1307, USA.  */\n #include \"target.h\"\n #include \"convert.h\"\n \n+/* The various kinds of conversion.  */\n+\n+typedef enum conversion_kind { \n+  ck_identity,\n+  ck_lvalue,\n+  ck_qual,\n+  ck_std,\n+  ck_ptr,\n+  ck_pmem,\n+  ck_base,\n+  ck_ref_bind,\n+  ck_user,\n+  ck_ambig,\n+  ck_rvalue\n+} conversion_kind;\n+\n+/* The rank of the conversion.  Order of the enumerals matters; better\n+   conversions should come earlier in the list.  */\n+\n+typedef enum conversion_rank {\n+  cr_identity,\n+  cr_exact,\n+  cr_promotion,\n+  cr_std,\n+  cr_pbool,\n+  cr_user,\n+  cr_ellipsis,\n+  cr_bad\n+} conversion_rank;\n+\n+/* An implicit conversion sequence, in the sense of [over.best.ics].\n+   The first conversion to be performed is at the end of the chain.\n+   That conversion is always an cr_identity conversion.  */\n+\n+typedef struct conversion conversion;\n+struct conversion {\n+  /* The kind of conversion represented by this step.  */\n+  conversion_kind kind;\n+  /* The rank of this conversion.  */\n+  conversion_rank rank;\n+  BOOL_BITFIELD user_conv_p : 1;\n+  BOOL_BITFIELD ellipsis_p : 1;\n+  BOOL_BITFIELD this_p : 1;\n+  BOOL_BITFIELD bad_p : 1;\n+  /* If KIND is ck_ref_bind ck_base_conv, true to indicate that a\n+     temporary should be created to hold the result of the\n+     conversion.  */\n+  BOOL_BITFIELD need_temporary_p : 1;\n+  /* If KIND is ck_identity or ck_base_conv, true to indicate that the\n+     copy constructor must be accessible, even though it is not being\n+     used.  */\n+  BOOL_BITFIELD check_copy_constructor_p : 1;\n+  /* The type of the expression resulting from the conversion.  */\n+  tree type;\n+  union {\n+    /* The next conversion in the chain.  Since the conversions are\n+       arranged from outermost to innermost, the NEXT conversion will\n+       actually be performed before this conversion.  This variant is\n+       used only when KIND is neither ck_identity nor ck_ambig.  */\n+    conversion *next;\n+    /* The expression at the beginning of the conversion chain.  This\n+       variant is used only if KIND is ck_identity or ck_ambig.  */\n+    tree expr;\n+  } u;\n+  /* The function candidate corresponding to this conversion\n+     sequence.  This field is only used if KIND is ck_user.  */\n+  struct z_candidate *cand;\n+};\n+\n+#define CONVERSION_RANK(NODE)\t\t\t\\\n+  ((NODE)->bad_p ? cr_bad\t\t\t\\\n+   : (NODE)->ellipsis_p ? cr_ellipsis\t\t\\\n+   : (NODE)->user_conv_p ? cr_user\t\t\\\n+   : (NODE)->rank)\n+\n+static struct obstack conversion_obstack;\n+static bool conversion_obstack_initialized;\n+\n static struct z_candidate * tourney (struct z_candidate *);\n static int equal_functions (tree, tree);\n static int joust (struct z_candidate *, struct z_candidate *, bool);\n-static int compare_ics (tree, tree);\n+static int compare_ics (conversion *, conversion *);\n static tree build_over_call (struct z_candidate *, int);\n static tree build_java_interface_fn_ref (tree, tree);\n #define convert_like(CONV, EXPR)\t\t\t\t\\\n@@ -52,7 +130,7 @@ static tree build_java_interface_fn_ref (tree, tree);\n #define convert_like_with_context(CONV, EXPR, FN, ARGNO)\t\\\n   convert_like_real ((CONV), (EXPR), (FN), (ARGNO), 0, \t\t\\\n \t\t     /*issue_conversion_warnings=*/true)\n-static tree convert_like_real (tree, tree, tree, int, int, bool);\n+static tree convert_like_real (conversion *, tree, tree, int, int, bool);\n static void op_error (enum tree_code, enum tree_code, tree, tree,\n \t\t\t    tree, const char *);\n static tree build_object_call (tree, tree);\n@@ -85,29 +163,30 @@ static struct z_candidate *add_conv_candidate\n \t(struct z_candidate **, tree, tree, tree, tree, tree);\n static struct z_candidate *add_function_candidate \n \t(struct z_candidate **, tree, tree, tree, tree, tree, int);\n-static tree implicit_conversion (tree, tree, tree, int);\n-static tree standard_conversion (tree, tree, tree);\n-static tree reference_binding (tree, tree, tree, int);\n-static tree build_conv (enum tree_code, tree, tree);\n-static bool is_subseq (tree, tree);\n-static tree maybe_handle_ref_bind (tree *);\n-static void maybe_handle_implicit_object (tree *);\n+static conversion *implicit_conversion (tree, tree, tree, int);\n+static conversion *standard_conversion (tree, tree, tree);\n+static conversion *reference_binding (tree, tree, tree, int);\n+static conversion *build_conv (conversion_kind, tree, conversion *);\n+static bool is_subseq (conversion *, conversion *);\n+static tree maybe_handle_ref_bind (conversion **);\n+static void maybe_handle_implicit_object (conversion **);\n static struct z_candidate *add_candidate \n-        (struct z_candidate **, tree, tree, tree, tree, tree, int);\n-static tree source_type (tree);\n+        (struct z_candidate **, tree, tree, size_t, \n+\t conversion **, tree, tree, int);\n+static tree source_type (conversion *);\n static void add_warning (struct z_candidate *, struct z_candidate *);\n static bool reference_related_p (tree, tree);\n static bool reference_compatible_p (tree, tree);\n-static tree convert_class_to_reference (tree, tree, tree);\n-static tree direct_reference_binding (tree, tree);\n+static conversion *convert_class_to_reference (tree, tree, tree);\n+static conversion *direct_reference_binding (tree, conversion *);\n static bool promoted_arithmetic_type_p (tree);\n-static tree conditional_conversion (tree, tree);\n+static conversion *conditional_conversion (tree, tree);\n static char *name_as_c_string (tree, tree, bool *);\n static tree call_builtin_trap (tree);\n static tree prep_operand (tree);\n static void add_candidates (tree, tree, tree, bool, tree, tree,\n \t\t\t    int, struct z_candidate **);\n-static tree merge_conversion_sequences (tree, tree);\n+static conversion *merge_conversion_sequences (conversion *, conversion *);\n static bool magic_varargs_p (tree);\n \n tree\n@@ -307,19 +386,29 @@ build_call (tree function, tree parms)\n \n /* New overloading code.  */\n \n-struct z_candidate GTY(()) {\n+typedef struct z_candidate z_candidate;\n+\n+typedef struct candidate_warning candidate_warning;\n+struct candidate_warning {\n+  z_candidate *loser;\n+  candidate_warning *next;\n+};\n+\n+struct z_candidate {\n   /* The FUNCTION_DECL that will be called if this candidate is\n      selected by overload resolution.  */\n   tree fn;\n   /* The arguments to use when calling this function.  */\n   tree args;\n   /* The implicit conversion sequences for each of the arguments to\n      FN.  */\n-  tree convs;\n+  conversion **convs;\n+  /* The number of implicit conversion sequences.  */\n+  size_t num_convs;\n   /* If FN is a user-defined conversion, the standard conversion\n      sequence from the type returned by FN to the desired destination\n      type.  */\n-  tree second_conv;\n+  conversion *second_conv;\n   int viable;\n   /* If FN is a member function, the binfo indicating the path used to\n      qualify the name of FN at the call site.  This path is used to\n@@ -334,43 +423,10 @@ struct z_candidate GTY(()) {\n      indicated by the CONVERSION_PATH.  */\n   tree conversion_path;\n   tree template;\n-  tree warnings;\n-  struct z_candidate *next;\n+  candidate_warning *warnings;\n+  z_candidate *next;\n };\n \n-#define IDENTITY_RANK 0\n-#define EXACT_RANK 1\n-#define PROMO_RANK 2\n-#define STD_RANK 3\n-#define PBOOL_RANK 4\n-#define USER_RANK 5\n-#define ELLIPSIS_RANK 6\n-#define BAD_RANK 7\n-\n-#define ICS_RANK(NODE)\t\t\t\t\\\n-  (ICS_BAD_FLAG (NODE) ? BAD_RANK   \t\t\\\n-   : ICS_ELLIPSIS_FLAG (NODE) ? ELLIPSIS_RANK\t\\\n-   : ICS_USER_FLAG (NODE) ? USER_RANK\t\t\\\n-   : ICS_STD_RANK (NODE))\n-\n-#define ICS_STD_RANK(NODE) TREE_COMPLEXITY (NODE)\n-\n-#define ICS_USER_FLAG(NODE) TREE_LANG_FLAG_0 (NODE)\n-#define ICS_ELLIPSIS_FLAG(NODE) TREE_LANG_FLAG_1 (NODE)\n-#define ICS_THIS_FLAG(NODE) TREE_LANG_FLAG_2 (NODE)\n-#define ICS_BAD_FLAG(NODE) TREE_LANG_FLAG_3 (NODE)\n-\n-/* In a REF_BIND or a BASE_CONV, this indicates that a temporary\n-   should be created to hold the result of the conversion.  */\n-#define NEED_TEMPORARY_P(NODE) TREE_LANG_FLAG_4 (NODE)\n-\n-/* TRUE in an IDENTITY_CONV or BASE_CONV if the copy constructor must\n-   be accessible, even though it is not being used.  */\n-#define CHECK_COPY_CONSTRUCTOR_P(NODE) TREE_LANG_FLAG_5 (NODE)\n-\n-#define USER_CONV_CAND(NODE) WRAPPER_ZC (TREE_OPERAND (NODE, 1))\n-#define USER_CONV_FN(NODE) (USER_CONV_CAND (NODE)->fn)\n-\n bool\n null_ptr_cst_p (tree t)\n {\n@@ -398,42 +454,127 @@ sufficient_parms_p (tree parmlist)\n   return true;\n }\n \n-static tree\n-build_conv (enum tree_code code, tree type, tree from)\n+/* Allocate N bytes of memory from the conversion obstack.  The memory\n+   is zeroed before being returned.  */\n+\n+static void *\n+conversion_obstack_alloc (size_t n)\n {\n-  tree t;\n-  int rank = ICS_STD_RANK (from);\n+  void *p;\n+  if (!conversion_obstack_initialized)\n+    {\n+      gcc_obstack_init (&conversion_obstack);\n+      conversion_obstack_initialized = true;\n+    }\n+  p = obstack_alloc (&conversion_obstack, n);\n+  memset (p, 0, n);\n+  return p;\n+}\n+\n+/* Dynamically allocate a conversion.  */\n+\n+static conversion *\n+alloc_conversion (conversion_kind kind)\n+{\n+  conversion *c;\n+  c = conversion_obstack_alloc (sizeof (conversion));\n+  c->kind = kind;\n+  return c;\n+}\n+\n+#ifdef ENABLE_CHECKING\n+\n+/* Make sure that all memory on the conversion obstack has been\n+   freed.  */\n+\n+void\n+validate_conversion_obstack (void)\n+{\n+  if (conversion_obstack_initialized)\n+    my_friendly_assert ((obstack_next_free (&conversion_obstack) \n+\t\t\t == obstack_base (&conversion_obstack)),\n+\t\t\t20040208);\n+}\n+\n+#endif /* ENABLE_CHECKING */\n+\n+/* Dynamically allocate an array of N conversions.  */\n+\n+static conversion **\n+alloc_conversions (size_t n)\n+{\n+  return conversion_obstack_alloc (n * sizeof (conversion *));\n+}\n+\n+static conversion *\n+build_conv (conversion_kind code, tree type, conversion *from)\n+{\n+  conversion *t;\n+  conversion_rank rank = CONVERSION_RANK (from);\n \n   /* We can't use buildl1 here because CODE could be USER_CONV, which\n      takes two arguments.  In that case, the caller is responsible for\n      filling in the second argument.  */\n-  t = make_node (code);\n-  TREE_TYPE (t) = type;\n-  TREE_OPERAND (t, 0) = from;\n+  t = alloc_conversion (code);\n+  t->type = type;\n+  t->u.next = from;\n \n   switch (code)\n     {\n-    case PTR_CONV:\n-    case PMEM_CONV:\n-    case BASE_CONV:\n-    case STD_CONV:\n-      if (rank < STD_RANK)\n-\trank = STD_RANK;\n+    case ck_ptr:\n+    case ck_pmem:\n+    case ck_base:\n+    case ck_std:\n+      if (rank < cr_std)\n+\trank = cr_std;\n       break;\n \n-    case QUAL_CONV:\n-      if (rank < EXACT_RANK)\n-\trank = EXACT_RANK;\n+    case ck_qual:\n+      if (rank < cr_exact)\n+\trank = cr_exact;\n+      break;\n \n     default:\n       break;\n     }\n-  ICS_STD_RANK (t) = rank;\n-  ICS_USER_FLAG (t) = (code == USER_CONV || ICS_USER_FLAG (from));\n-  ICS_BAD_FLAG (t) = ICS_BAD_FLAG (from);\n+  t->rank = rank;\n+  t->user_conv_p = (code == ck_user || from->user_conv_p);\n+  t->bad_p = from->bad_p;\n   return t;\n }\n \n+/* Build a representation of the identity conversion from EXPR to\n+   itself.  The TYPE should match the the type of EXPR, if EXPR is\n+   non-NULL.  */\n+\n+static conversion *\n+build_identity_conv (tree type, tree expr)\n+{\n+  conversion *c;\n+  \n+  c = alloc_conversion (ck_identity);\n+  c->type = type;\n+  c->u.expr = expr;\n+\n+  return c;\n+}\n+\n+/* Converting from EXPR to TYPE was ambiguous in the sense that there\n+   were multiple user-defined conversions to accomplish the job.\n+   Build a conversion that indicates that ambiguity.  */\n+\n+static conversion *\n+build_ambiguous_conv (tree type, tree expr)\n+{\n+  conversion *c;\n+\n+  c = alloc_conversion (ck_ambig);\n+  c->type = type;\n+  c->u.expr = expr;\n+\n+  return c;\n+}\n+\n tree\n strip_top_quals (tree t)\n {\n@@ -446,11 +587,11 @@ strip_top_quals (tree t)\n    TO, if any.  For proper handling of null pointer constants, you must\n    also pass the expression EXPR to convert from.  */\n \n-static tree\n+static conversion *\n standard_conversion (tree to, tree from, tree expr)\n {\n   enum tree_code fcode, tcode;\n-  tree conv;\n+  conversion *conv;\n   bool fromref = false;\n \n   to = non_reference (to);\n@@ -467,46 +608,45 @@ standard_conversion (tree to, tree from, tree expr)\n     {\n       expr = instantiate_type (to, expr, tf_conv);\n       if (expr == error_mark_node)\n-\treturn NULL_TREE;\n+\treturn NULL;\n       from = TREE_TYPE (expr);\n     }\n \n   fcode = TREE_CODE (from);\n   tcode = TREE_CODE (to);\n \n-  conv = build1 (IDENTITY_CONV, from, expr);\n-\n+  conv = build_identity_conv (from, expr);\n   if (fcode == FUNCTION_TYPE)\n     {\n       from = build_pointer_type (from);\n       fcode = TREE_CODE (from);\n-      conv = build_conv (LVALUE_CONV, from, conv);\n+      conv = build_conv (ck_lvalue, from, conv);\n     }\n   else if (fcode == ARRAY_TYPE)\n     {\n       from = build_pointer_type (TREE_TYPE (from));\n       fcode = TREE_CODE (from);\n-      conv = build_conv (LVALUE_CONV, from, conv);\n+      conv = build_conv (ck_lvalue, from, conv);\n     }\n   else if (fromref || (expr && lvalue_p (expr)))\n-    conv = build_conv (RVALUE_CONV, from, conv);\n+    conv = build_conv (ck_rvalue, from, conv);\n \n    /* Allow conversion between `__complex__' data types.  */\n   if (tcode == COMPLEX_TYPE && fcode == COMPLEX_TYPE)\n     {\n       /* The standard conversion sequence to convert FROM to TO is\n          the standard conversion sequence to perform componentwise\n          conversion.  */\n-      tree part_conv = standard_conversion\n+      conversion *part_conv = standard_conversion\n         (TREE_TYPE (to), TREE_TYPE (from), NULL_TREE);\n       \n       if (part_conv)\n         {\n-          conv = build_conv (TREE_CODE (part_conv), to, conv);\n-          ICS_STD_RANK (conv) = ICS_STD_RANK (part_conv);\n+\t  conv = build_conv (part_conv->kind, to, conv);\n+\t  conv->rank = part_conv->rank;\n         }\n       else\n-        conv = NULL_TREE;\n+        conv = NULL;\n \n       return conv;\n     }\n@@ -516,27 +656,27 @@ standard_conversion (tree to, tree from, tree expr)\n \n   if ((tcode == POINTER_TYPE || TYPE_PTR_TO_MEMBER_P (to))\n       && expr && null_ptr_cst_p (expr))\n-    conv = build_conv (STD_CONV, to, conv);\n+    conv = build_conv (ck_std, to, conv);\n   else if (tcode == POINTER_TYPE && fcode == POINTER_TYPE\n \t   && TREE_CODE (TREE_TYPE (to)) == VECTOR_TYPE\n \t   && TREE_CODE (TREE_TYPE (from)) == VECTOR_TYPE\n \t   && ((*targetm.vector_opaque_p) (TREE_TYPE (to))\n \t       || (*targetm.vector_opaque_p) (TREE_TYPE (from))))\n-    conv = build_conv (STD_CONV, to, conv);\n+    conv = build_conv (ck_std, to, conv);\n   else if ((tcode == INTEGER_TYPE && fcode == POINTER_TYPE)\n \t   || (tcode == POINTER_TYPE && fcode == INTEGER_TYPE))\n     {\n       /* For backwards brain damage compatibility, allow interconversion of\n \t pointers and integers with a pedwarn.  */\n-      conv = build_conv (STD_CONV, to, conv);\n-      ICS_BAD_FLAG (conv) = 1;\n+      conv = build_conv (ck_std, to, conv);\n+      conv->bad_p = true;\n     }\n   else if (tcode == ENUMERAL_TYPE && fcode == INTEGER_TYPE)\n     {\n       /* For backwards brain damage compatibility, allow interconversion of\n \t enums and integers with a pedwarn.  */\n-      conv = build_conv (STD_CONV, to, conv);\n-      ICS_BAD_FLAG (conv) = 1;\n+      conv = build_conv (ck_std, to, conv);\n+      conv->bad_p = true;\n     }\n   else if ((tcode == POINTER_TYPE && fcode == POINTER_TYPE)\n \t   || (TYPE_PTRMEM_P (to) && TYPE_PTRMEM_P (from)))\n@@ -555,7 +695,7 @@ standard_conversion (tree to, tree from, tree expr)\n \t  from = build_pointer_type\n \t    (cp_build_qualified_type (void_type_node, \n \t\t\t\t      cp_type_quals (TREE_TYPE (from))));\n-\t  conv = build_conv (PTR_CONV, from, conv);\n+\t  conv = build_conv (ck_ptr, from, conv);\n \t}\n       else if (TYPE_PTRMEM_P (from))\n \t{\n@@ -569,7 +709,7 @@ standard_conversion (tree to, tree from, tree expr)\n \t    {\n \t      from = build_ptrmem_type (tbase, \n \t\t\t\t\tTYPE_PTRMEM_POINTED_TO_TYPE (from));\n-\t      conv = build_conv (PMEM_CONV, from, conv);\n+\t      conv = build_conv (ck_pmem, from, conv);\n \t    }\n \t}\n       else if (IS_AGGR_TYPE (TREE_TYPE (from))\n@@ -591,7 +731,7 @@ standard_conversion (tree to, tree from, tree expr)\n \t    cp_build_qualified_type (TREE_TYPE (to),\n \t\t\t\t     cp_type_quals (TREE_TYPE (from)));\n \t  from = build_pointer_type (from);\n-\t  conv = build_conv (PTR_CONV, from, conv);\n+\t  conv = build_conv (ck_ptr, from, conv);\n \t}\n \n       if (tcode == POINTER_TYPE)\n@@ -608,17 +748,17 @@ standard_conversion (tree to, tree from, tree expr)\n       if (same_type_p (from, to))\n \t/* OK */;\n       else if (comp_ptr_ttypes (to_pointee, from_pointee))\n-\tconv = build_conv (QUAL_CONV, to, conv);\n+\tconv = build_conv (ck_qual, to, conv);\n       else if (expr && string_conv_p (to, expr, 0))\n \t/* converting from string constant to char *.  */\n-\tconv = build_conv (QUAL_CONV, to, conv);\n+\tconv = build_conv (ck_qual, to, conv);\n       else if (ptr_reasonably_similar (to_pointee, from_pointee))\n \t{\n-\t  conv = build_conv (PTR_CONV, to, conv);\n-\t  ICS_BAD_FLAG (conv) = 1;\n+\t  conv = build_conv (ck_ptr, to, conv);\n+\t  conv->bad_p = true;\n \t}\n       else\n-\treturn 0;\n+\treturn NULL;\n \n       from = to;\n     }\n@@ -641,7 +781,7 @@ standard_conversion (tree to, tree from, tree expr)\n \t\t\t\t\t TREE_TYPE (fromfn),\n \t\t\t\t\t TREE_CHAIN (TYPE_ARG_TYPES (fromfn)));\n       from = build_ptrmemfunc_type (build_pointer_type (from));\n-      conv = build_conv (PMEM_CONV, from, conv);\n+      conv = build_conv (ck_pmem, from, conv);\n     }\n   else if (tcode == BOOLEAN_TYPE)\n     {\n@@ -654,16 +794,16 @@ standard_conversion (tree to, tree from, tree expr)\n \t  || fcode == POINTER_TYPE\n \t  || TYPE_PTR_TO_MEMBER_P (from))\n \t{\n-\t  conv = build_conv (STD_CONV, to, conv);\n+\t  conv = build_conv (ck_std, to, conv);\n \t  if (fcode == POINTER_TYPE\n \t      || TYPE_PTRMEM_P (from)\n \t      || (TYPE_PTRMEMFUNC_P (from) \n-\t\t  && ICS_STD_RANK (conv) < PBOOL_RANK))\n-\t    ICS_STD_RANK (conv) = PBOOL_RANK;\n+\t\t  && conv->rank < cr_pbool))\n+\t    conv->rank = cr_pbool;\n \t  return conv;\n \t}\n       \n-      return NULL_TREE;\n+      return NULL;\n     }\n   /* We don't check for ENUMERAL_TYPE here because there are no standard\n      conversions to enum type.  */\n@@ -672,31 +812,31 @@ standard_conversion (tree to, tree from, tree expr)\n     {\n       if (! (INTEGRAL_CODE_P (fcode) || fcode == REAL_TYPE))\n \treturn 0;\n-      conv = build_conv (STD_CONV, to, conv);\n+      conv = build_conv (ck_std, to, conv);\n \n       /* Give this a better rank if it's a promotion.  */\n       if (same_type_p (to, type_promotes_to (from))\n-\t  && ICS_STD_RANK (TREE_OPERAND (conv, 0)) <= PROMO_RANK)\n-\tICS_STD_RANK (conv) = PROMO_RANK;\n+\t  && conv->u.next->rank <= cr_promotion)\n+\tconv->rank = cr_promotion;\n     }\n   else if (fcode == VECTOR_TYPE && tcode == VECTOR_TYPE\n       && ((*targetm.vector_opaque_p) (from)\n \t  || (*targetm.vector_opaque_p) (to)))\n-    return build_conv (STD_CONV, to, conv);\n+    return build_conv (ck_std, to, conv);\n   else if (IS_AGGR_TYPE (to) && IS_AGGR_TYPE (from)\n \t   && is_properly_derived_from (from, to))\n     {\n-      if (TREE_CODE (conv) == RVALUE_CONV)\n-\tconv = TREE_OPERAND (conv, 0);\n-      conv = build_conv (BASE_CONV, to, conv);\n+      if (conv->kind == ck_rvalue)\n+\tconv = conv->u.next;\n+      conv = build_conv (ck_base, to, conv);\n       /* The derived-to-base conversion indicates the initialization\n \t of a parameter with base type from an object of a derived\n \t type.  A temporary object is created to hold the result of\n \t the conversion.  */\n-      NEED_TEMPORARY_P (conv) = 1;\n+      conv->need_temporary_p = true;\n     }\n   else\n-    return 0;\n+    return NULL;\n \n   return conv;\n }\n@@ -736,20 +876,20 @@ reference_compatible_p (tree t1, tree t2)\n /* Determine whether or not the EXPR (of class type S) can be\n    converted to T as in [over.match.ref].  */\n \n-static tree\n+static conversion *\n convert_class_to_reference (tree t, tree s, tree expr)\n {\n   tree conversions;\n   tree arglist;\n-  tree conv;\n+  conversion *conv;\n   tree reference_type;\n   struct z_candidate *candidates;\n   struct z_candidate *cand;\n   bool any_viable_p;\n \n   conversions = lookup_conversions (s);\n   if (!conversions)\n-    return NULL_TREE;\n+    return NULL;\n \n   /* [over.match.ref]\n \n@@ -829,17 +969,18 @@ convert_class_to_reference (tree t, tree s, tree expr)\n \t  \n \t  if (cand)\n \t    {\n+\t      conversion *identity_conv;\n \t      /* Build a standard conversion sequence indicating the\n \t\t binding from the reference type returned by the\n \t\t function to the desired REFERENCE_TYPE.  */\n+\t      identity_conv \n+\t\t= build_identity_conv (TREE_TYPE (TREE_TYPE \n+\t\t\t\t\t\t  (TREE_TYPE (cand->fn))),\n+\t\t\t\t       NULL_TREE);\n \t      cand->second_conv\n \t\t= (direct_reference_binding \n-\t\t   (reference_type, \n-\t\t    build1 (IDENTITY_CONV, \n-\t\t\t    TREE_TYPE (TREE_TYPE (TREE_TYPE (cand->fn))),\n-\t\t\t    NULL_TREE)));\n-\t      ICS_BAD_FLAG (cand->second_conv) \n-\t\t|= ICS_BAD_FLAG (TREE_VEC_ELT (cand->convs, 0));\n+\t\t   (reference_type, identity_conv));\n+\t      cand->second_conv->bad_p |= cand->convs[0]->bad_p;\n \t    }\n \t}\n       conversions = TREE_CHAIN (conversions);\n@@ -849,11 +990,11 @@ convert_class_to_reference (tree t, tree s, tree expr)\n   /* If none of the conversion functions worked out, let our caller\n      know.  */\n   if (!any_viable_p)\n-    return NULL_TREE;\n+    return NULL;\n \n   cand = tourney (candidates);\n   if (!cand)\n-    return NULL_TREE;\n+    return NULL;\n \n   /* Now that we know that this is the function we're going to use fix\n      the dummy first argument.  */\n@@ -863,17 +1004,17 @@ convert_class_to_reference (tree t, tree s, tree expr)\n \n   /* Build a user-defined conversion sequence representing the\n      conversion.  */\n-  conv = build_conv (USER_CONV,\n+  conv = build_conv (ck_user,\n \t\t     TREE_TYPE (TREE_TYPE (cand->fn)),\n-\t\t     build1 (IDENTITY_CONV, TREE_TYPE (expr), expr));\n-  TREE_OPERAND (conv, 1) = build_zc_wrapper (cand);\n+\t\t     build_identity_conv (TREE_TYPE (expr), expr));\n+  conv->cand = cand;\n \n   /* Merge it with the standard conversion sequence from the\n      conversion function's return type to the desired type.  */\n   cand->second_conv = merge_conversion_sequences (conv, cand->second_conv);\n \n   if (cand->viable == -1)\n-    ICS_BAD_FLAG (conv) = 1;\n+    conv->bad_p = true;\n   \n   return cand->second_conv;\n }\n@@ -882,14 +1023,13 @@ convert_class_to_reference (tree t, tree s, tree expr)\n    expression represented by the implicit conversion sequence CONV.\n    Return a conversion sequence for this binding.  */\n \n-static tree\n-direct_reference_binding (tree type, tree conv)\n+static conversion *\n+direct_reference_binding (tree type, conversion *conv)\n {\n   tree t;\n \n   my_friendly_assert (TREE_CODE (type) == REFERENCE_TYPE, 20030306);\n-  my_friendly_assert (TREE_CODE (TREE_TYPE (conv)) != REFERENCE_TYPE,\n-\t\t      20030306);\n+  my_friendly_assert (TREE_CODE (conv->type) != REFERENCE_TYPE, 20030306);\n \n   t = TREE_TYPE (type);\n \n@@ -909,16 +1049,16 @@ direct_reference_binding (tree type, tree conv)\n      either an identity conversion or, if the conversion function\n      returns an entity of a type that is a derived class of the\n      parameter type, a derived-to-base conversion.  */\n-  if (!same_type_ignoring_top_level_qualifiers_p (t, TREE_TYPE (conv)))\n+  if (!same_type_ignoring_top_level_qualifiers_p (t, conv->type))\n     {\n       /* Represent the derived-to-base conversion.  */\n-      conv = build_conv (BASE_CONV, t, conv);\n+      conv = build_conv (ck_base, t, conv);\n       /* We will actually be binding to the base-class subobject in\n \t the derived class, so we mark this conversion appropriately.\n \t That way, convert_like knows not to generate a temporary.  */\n-      NEED_TEMPORARY_P (conv) = 0;\n+      conv->need_temporary_p = false;\n     }\n-  return build_conv (REF_BIND, type, conv);\n+  return build_conv (ck_ref_bind, type, conv);\n }\n \n /* Returns the conversion path from type FROM to reference type TO for\n@@ -927,10 +1067,10 @@ direct_reference_binding (tree type, tree conv)\n    reference will be bound to a temporary, NEED_TEMPORARY_P is set for\n    the conversion returned.  */\n \n-static tree\n+static conversion *\n reference_binding (tree rto, tree rfrom, tree expr, int flags)\n {\n-  tree conv = NULL_TREE;\n+  conversion *conv = NULL;\n   tree to = TREE_TYPE (rto);\n   tree from = rfrom;\n   bool related_p;\n@@ -941,7 +1081,7 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)\n     {\n       expr = instantiate_type (to, expr, tf_none);\n       if (expr == error_mark_node)\n-\treturn NULL_TREE;\n+\treturn NULL;\n       from = TREE_TYPE (expr);\n     }\n \n@@ -971,7 +1111,7 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)\n \t \n \t the reference is bound directly to the initializer expression\n \t lvalue.  */\n-      conv = build1 (IDENTITY_CONV, from, expr);\n+      conv = build_identity_conv (from, expr);\n       conv = direct_reference_binding (rto, conv);\n       if ((lvalue_p & clk_bitfield) != 0\n \t  || ((lvalue_p & clk_packed) != 0 && !TYPE_PACKED (to)))\n@@ -986,7 +1126,7 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)\n \t   reference is volatile, or isn't const, then we cannot make\n \t   a temporary, so we just issue an error when the conversion\n \t   actually occurs.  */\n-\tNEED_TEMPORARY_P (conv) = 1;\n+\tconv->need_temporary_p = true;\n \t\t\t\t\t\n       return conv;\n     }\n@@ -1013,7 +1153,7 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)\n   /* From this point on, we conceptually need temporaries, even if we\n      elide them.  Only the cases above are \"direct bindings\".  */\n   if (flags & LOOKUP_NO_TEMP_BIND)\n-    return NULL_TREE;\n+    return NULL;\n \n   /* [over.ics.rank]\n      \n@@ -1030,7 +1170,7 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)\n \n      Otherwise, the reference shall be to a non-volatile const type.  */\n   if (!CP_TYPE_CONST_NON_VOLATILE_P (to))\n-    return NULL_TREE;\n+    return NULL;\n \n   /* [dcl.init.ref]\n      \n@@ -1050,9 +1190,9 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)\n      conversion, just as for direct binding.  */\n   if (CLASS_TYPE_P (from) && compatible_p)\n     {\n-      conv = build1 (IDENTITY_CONV, from, expr);\n+      conv = build_identity_conv (from, expr);\n       conv = direct_reference_binding (rto, conv);\n-      CHECK_COPY_CONSTRUCTOR_P (TREE_OPERAND (conv, 0)) = 1;\n+      conv->u.next->check_copy_constructor_p = true;\n       return conv;\n     }\n \n@@ -1064,16 +1204,16 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)\n      T2, cv1 must be the same cv-qualification as, or greater\n      cv-qualification than, cv2; otherwise, the program is ill-formed.  */\n   if (related_p && !at_least_as_qualified_p (to, from))\n-    return NULL_TREE;\n+    return NULL;\n \n   conv = implicit_conversion (to, from, expr, flags);\n   if (!conv)\n-    return NULL_TREE;\n+    return NULL;\n \n-  conv = build_conv (REF_BIND, rto, conv);\n+  conv = build_conv (ck_ref_bind, rto, conv);\n   /* This reference binding, unlike those above, requires the\n      creation of a temporary.  */\n-  NEED_TEMPORARY_P (conv) = 1;\n+  conv->need_temporary_p = true;\n \n   return conv;\n }\n@@ -1083,14 +1223,14 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)\n    FLAGS are the usual overloading flags.  Only LOOKUP_NO_CONVERSION is\n    significant.  */\n \n-static tree\n+static conversion *\n implicit_conversion (tree to, tree from, tree expr, int flags)\n {\n-  tree conv;\n+  conversion *conv;\n \n   if (from == error_mark_node || to == error_mark_node\n       || expr == error_mark_node)\n-    return NULL_TREE;\n+    return NULL;\n \n   if (TREE_CODE (to) == REFERENCE_TYPE)\n     conv = reference_binding (to, from, expr, flags);\n@@ -1118,22 +1258,26 @@ implicit_conversion (tree to, tree from, tree expr, int flags)\n       return conv;\n     }\n \n-  return NULL_TREE;\n+  return NULL;\n }\n \n /* Add a new entry to the list of candidates.  Used by the add_*_candidate\n    functions.  */\n \n static struct z_candidate *\n add_candidate (struct z_candidate **candidates, \n-\t       tree fn, tree args, tree convs, tree access_path, \n-\t       tree conversion_path, int viable)\n+\t       tree fn, tree args, \n+\t       size_t num_convs, conversion **convs, \n+\t       tree access_path, tree conversion_path, \n+\t       int viable)\n {\n-  struct z_candidate *cand = ggc_alloc_cleared (sizeof (struct z_candidate));\n+  struct z_candidate *cand \n+    = conversion_obstack_alloc (sizeof (struct z_candidate));\n \n   cand->fn = fn;\n   cand->args = args;\n   cand->convs = convs;\n+  cand->num_convs = num_convs;\n   cand->access_path = access_path;\n   cand->conversion_path = conversion_path;\n   cand->viable = viable;\n@@ -1158,7 +1302,7 @@ add_function_candidate (struct z_candidate **candidates,\n {\n   tree parmlist = TYPE_ARG_TYPES (TREE_TYPE (fn));\n   int i, len;\n-  tree convs;\n+  conversion **convs;\n   tree parmnode, argnode;\n   tree orig_arglist;\n   int viable = 1;\n@@ -1180,7 +1324,7 @@ add_function_candidate (struct z_candidate **candidates,\n     orig_arglist = arglist;\n \n   len = list_length (arglist);\n-  convs = make_tree_vec (len);\n+  convs = alloc_conversions (len);\n \n   /* 13.3.2 - Viable functions [over.match.viable]\n      First, to be a viable function, a candidate function shall have enough\n@@ -1218,7 +1362,7 @@ add_function_candidate (struct z_candidate **candidates,\n     {\n       tree arg = TREE_VALUE (argnode);\n       tree argtype = lvalue_type (arg);\n-      tree t;\n+      conversion *t;\n       int is_this;\n \n       if (parmnode == void_list_node)\n@@ -1252,21 +1396,21 @@ add_function_candidate (struct z_candidate **candidates,\n \t}\n       else\n \t{\n-\t  t = build1 (IDENTITY_CONV, argtype, arg);\n-\t  ICS_ELLIPSIS_FLAG (t) = 1;\n+\t  t = build_identity_conv (argtype, arg);\n+\t  t->ellipsis_p = true;\n \t}\n \n       if (t && is_this)\n-\tICS_THIS_FLAG (t) = 1;\n+\tt->this_p = true;\n \n-      TREE_VEC_ELT (convs, i) = t;\n+      convs[i] = t;\n       if (! t)\n \t{\n \t  viable = 0;\n \t  break;\n \t}\n \n-      if (ICS_BAD_FLAG (t))\n+      if (t->bad_p)\n \tviable = -1;\n \n       if (parmnode)\n@@ -1275,8 +1419,8 @@ add_function_candidate (struct z_candidate **candidates,\n     }\n \n  out:\n-  return add_candidate (candidates, fn, orig_arglist, convs, access_path,\n-\t\t\tconversion_path, viable);\n+  return add_candidate (candidates, fn, orig_arglist, len, convs, \n+\t\t\taccess_path, conversion_path, viable);\n }\n \n /* Create an overload candidate for the conversion function FN which will\n@@ -1296,14 +1440,15 @@ add_conv_candidate (struct z_candidate **candidates, tree fn, tree obj,\n {\n   tree totype = TREE_TYPE (TREE_TYPE (fn));\n   int i, len, viable, flags;\n-  tree parmlist, convs, parmnode, argnode;\n+  tree parmlist, parmnode, argnode;\n+  conversion **convs;\n \n   for (parmlist = totype; TREE_CODE (parmlist) != FUNCTION_TYPE; )\n     parmlist = TREE_TYPE (parmlist);\n   parmlist = TYPE_ARG_TYPES (parmlist);\n \n   len = list_length (arglist) + 1;\n-  convs = make_tree_vec (len);\n+  convs = alloc_conversions (len);\n   parmnode = parmlist;\n   argnode = arglist;\n   viable = 1;\n@@ -1317,7 +1462,7 @@ add_conv_candidate (struct z_candidate **candidates, tree fn, tree obj,\n     {\n       tree arg = i == 0 ? obj : TREE_VALUE (argnode);\n       tree argtype = lvalue_type (arg);\n-      tree t;\n+      conversion *t;\n \n       if (i == 0)\n \tt = implicit_conversion (totype, argtype, arg, flags);\n@@ -1327,15 +1472,15 @@ add_conv_candidate (struct z_candidate **candidates, tree fn, tree obj,\n \tt = implicit_conversion (TREE_VALUE (parmnode), argtype, arg, flags);\n       else\n \t{\n-\t  t = build1 (IDENTITY_CONV, argtype, arg);\n-\t  ICS_ELLIPSIS_FLAG (t) = 1;\n+\t  t = build_identity_conv (argtype, arg);\n+\t  t->ellipsis_p = true;\n \t}\n \n-      TREE_VEC_ELT (convs, i) = t;\n+      convs[i] = t;\n       if (! t)\n \tbreak;\n \n-      if (ICS_BAD_FLAG (t))\n+      if (t->bad_p)\n \tviable = -1;\n \n       if (i == 0)\n@@ -1352,23 +1497,26 @@ add_conv_candidate (struct z_candidate **candidates, tree fn, tree obj,\n   if (!sufficient_parms_p (parmnode))\n     viable = 0;\n \n-  return add_candidate (candidates, totype, arglist, convs, access_path,\n-\t\t\tconversion_path, viable);\n+  return add_candidate (candidates, totype, arglist, len, convs, \n+\t\t\taccess_path, conversion_path, viable);\n }\n \n static void\n build_builtin_candidate (struct z_candidate **candidates, tree fnname,\n                          tree type1, tree type2, tree *args, tree *argtypes,\n                          int flags)\n {\n-  tree t, convs;\n+  conversion *t;\n+  conversion **convs;\n+  size_t num_convs;\n   int viable = 1, i;\n   tree types[2];\n \n   types[0] = type1;\n   types[1] = type2;\n \n-  convs = make_tree_vec (args[2] ? 3 : (args[1] ? 2 : 1));\n+  num_convs =  args[2] ? 3 : (args[1] ? 2 : 1);\n+  convs = alloc_conversions (num_convs);\n \n   for (i = 0; i < 2; ++i)\n     {\n@@ -1380,26 +1528,27 @@ build_builtin_candidate (struct z_candidate **candidates, tree fnname,\n \t{\n \t  viable = 0;\n \t  /* We need something for printing the candidate.  */\n-\t  t = build1 (IDENTITY_CONV, types[i], NULL_TREE);\n+\t  t = build_identity_conv (types[i], NULL_TREE);\n \t}\n-      else if (ICS_BAD_FLAG (t))\n+      else if (t->bad_p)\n \tviable = 0;\n-      TREE_VEC_ELT (convs, i) = t;\n+      convs[i] = t;\n     }\n \n   /* For COND_EXPR we rearranged the arguments; undo that now.  */\n   if (args[2])\n     {\n-      TREE_VEC_ELT (convs, 2) = TREE_VEC_ELT (convs, 1);\n-      TREE_VEC_ELT (convs, 1) = TREE_VEC_ELT (convs, 0);\n+      convs[2] = convs[1];\n+      convs[1] = convs[0];\n       t = implicit_conversion (boolean_type_node, argtypes[2], args[2], flags);\n       if (t)\n-\tTREE_VEC_ELT (convs, 0) = t;\n+\tconvs[0] = t;\n       else\n \tviable = 0;\n     }      \n \n-  add_candidate (candidates, fnname, /*args=*/NULL_TREE, convs, \n+  add_candidate (candidates, fnname, /*args=*/NULL_TREE, \n+\t\t num_convs, convs, \n \t\t /*access_path=*/NULL_TREE,\n \t\t /*conversion_path=*/NULL_TREE,\n \t\t viable);\n@@ -2224,18 +2373,18 @@ print_z_candidate (const char *msgstr, struct z_candidate *candidate)\n {\n   if (TREE_CODE (candidate->fn) == IDENTIFIER_NODE)\n     {\n-      if (TREE_VEC_LENGTH (candidate->convs) == 3)\n+      if (candidate->num_convs == 3)\n \tinform (\"%s %D(%T, %T, %T) <built-in>\", msgstr, candidate->fn,\n-\t\tTREE_TYPE (TREE_VEC_ELT (candidate->convs, 0)),\n-\t\tTREE_TYPE (TREE_VEC_ELT (candidate->convs, 1)),\n-\t\tTREE_TYPE (TREE_VEC_ELT (candidate->convs, 2)));\n-      else if (TREE_VEC_LENGTH (candidate->convs) == 2)\n+\t\tcandidate->convs[0]->type,\n+\t\tcandidate->convs[1]->type,\n+\t\tcandidate->convs[2]->type);\n+      else if (candidate->num_convs == 2)\n \tinform (\"%s %D(%T, %T) <built-in>\", msgstr, candidate->fn,\n-\t\tTREE_TYPE (TREE_VEC_ELT (candidate->convs, 0)),\n-\t\tTREE_TYPE (TREE_VEC_ELT (candidate->convs, 1)));\n+\t\tcandidate->convs[0]->type,\n+\t\tcandidate->convs[1]->type);\n       else\n \tinform (\"%s %D(%T) <built-in>\", msgstr, candidate->fn,\n-\t\tTREE_TYPE (TREE_VEC_ELT (candidate->convs, 0)));\n+\t\tcandidate->convs[0]->type);\n     }\n   else if (TYPE_P (candidate->fn))\n     inform (\"%s %T <conversion>\", msgstr, candidate->fn);\n@@ -2304,25 +2453,24 @@ print_z_candidates (struct z_candidate *candidates)\n    desired type.  Merge the the two sequences into a single sequence,\n    and return the merged sequence.  */\n \n-static tree\n-merge_conversion_sequences (tree user_seq, tree std_seq)\n+static conversion *\n+merge_conversion_sequences (conversion *user_seq, conversion *std_seq)\n {\n-  tree *t;\n+  conversion **t;\n \n-  my_friendly_assert (TREE_CODE (user_seq) == USER_CONV,\n-\t\t      20030306);\n+  my_friendly_assert (user_seq->kind == ck_user, 20030306);\n \n   /* Find the end of the second conversion sequence.  */\n   t = &(std_seq); \n-  while (TREE_CODE (*t) != IDENTITY_CONV)\n-    t = &TREE_OPERAND (*t, 0);\n+  while ((*t)->kind != ck_identity)\n+    t = &((*t)->u.next);\n \n   /* Replace the identity conversion with the user conversion\n      sequence.  */\n   *t = user_seq;\n \n   /* The entire sequence is a user-conversion sequence.  */\n-  ICS_USER_FLAG (std_seq) = 1;\n+  std_seq->user_conv_p = true;\n \n   return std_seq;\n }\n@@ -2338,7 +2486,9 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n {\n   struct z_candidate *candidates, *cand;\n   tree fromtype = TREE_TYPE (expr);\n-  tree ctors = NULL_TREE, convs = NULL_TREE;\n+  tree ctors = NULL_TREE;\n+  tree conv_fns = NULL_TREE;\n+  conversion *conv = NULL;\n   tree args = NULL_TREE;\n   bool any_viable_p;\n \n@@ -2354,7 +2504,7 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \t\t\t     0);\n \n   if (IS_AGGR_TYPE (fromtype))\n-    convs = lookup_conversions (fromtype);\n+    conv_fns = lookup_conversions (fromtype);\n \n   candidates = 0;\n   flags |= LOOKUP_NO_CONVERSION;\n@@ -2395,16 +2545,16 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \t\t\t\t       flags); \n \n       if (cand)\n-\tcand->second_conv = build1 (IDENTITY_CONV, totype, NULL_TREE);\n+\tcand->second_conv = build_identity_conv (totype, NULL_TREE);\n     }\n \n-  if (convs)\n+  if (conv_fns)\n     args = build_tree_list (NULL_TREE, build_this (expr));\n \n-  for (; convs; convs = TREE_CHAIN (convs))\n+  for (; conv_fns; conv_fns = TREE_CHAIN (conv_fns))\n     {\n       tree fns;\n-      tree conversion_path = TREE_PURPOSE (convs);\n+      tree conversion_path = TREE_PURPOSE (conv_fns);\n       int convflags = LOOKUP_NO_CONVERSION;\n \n       /* If we are called to convert to a reference type, we are trying to\n@@ -2414,7 +2564,7 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n       if (TREE_CODE (totype) == REFERENCE_TYPE)\n \tconvflags |= LOOKUP_NO_TEMP_BIND;\n       \n-      for (fns = TREE_VALUE (convs); fns; fns = OVL_NEXT (fns))\n+      for (fns = TREE_VALUE (conv_fns); fns; fns = OVL_NEXT (fns))\n \t{\n \t  tree fn = OVL_CURRENT (fns);\n \t  \n@@ -2442,15 +2592,16 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \n \t  if (cand)\n \t    {\n-\t      tree ics = implicit_conversion (totype, \n-\t\t\t\t\t      TREE_TYPE (TREE_TYPE (cand->fn)),\n-\t\t\t\t\t      0, convflags);\n+\t      conversion *ics\n+\t\t= implicit_conversion (totype, \n+\t\t\t\t       TREE_TYPE (TREE_TYPE (cand->fn)),\n+\t\t\t\t       0, convflags);\n \n \t      cand->second_conv = ics;\n \t      \n-\t      if (ics == NULL_TREE)\n+\t      if (!ics)\n \t\tcand->viable = 0;\n-\t      else if (candidates->viable == 1 && ICS_BAD_FLAG (ics))\n+\t      else if (candidates->viable == 1 && ics->bad_p)\n \t\tcand->viable = -1;\n \t    }\n \t}\n@@ -2471,10 +2622,10 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \t}\n \n       cand = candidates;\t/* any one will do */\n-      cand->second_conv = build1 (AMBIG_CONV, totype, expr);\n-      ICS_USER_FLAG (cand->second_conv) = 1;\n+      cand->second_conv = build_ambiguous_conv (totype, expr);\n+      cand->second_conv->user_conv_p = true;\n       if (!any_strictly_viable (candidates))\n-\tICS_BAD_FLAG (cand->second_conv) = 1;\n+\tcand->second_conv->bad_p = true;\n       /* If there are viable candidates, don't set ICS_BAD_FLAG; an\n \t ambiguous conversion is no worse than another user-defined\n \t conversion.  */\n@@ -2483,19 +2634,19 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n     }\n \n   /* Build the user conversion sequence.  */\n-  convs = build_conv\n-    (USER_CONV,\n+  conv = build_conv\n+    (ck_user,\n      (DECL_CONSTRUCTOR_P (cand->fn)\n       ? totype : non_reference (TREE_TYPE (TREE_TYPE (cand->fn)))),\n-     build1 (IDENTITY_CONV, TREE_TYPE (expr), expr));\n-  TREE_OPERAND (convs, 1) = build_zc_wrapper (cand);\n+     build_identity_conv (TREE_TYPE (expr), expr));\n+  conv->cand = cand;\n \n   /* Combine it with the second conversion sequence.  */\n-  cand->second_conv = merge_conversion_sequences (convs,\n+  cand->second_conv = merge_conversion_sequences (conv,\n \t\t\t\t\t\t  cand->second_conv);\n \n   if (cand->viable == -1)\n-    ICS_BAD_FLAG (cand->second_conv) = 1;\n+    cand->second_conv->bad_p = true;\n \n   return cand;\n }\n@@ -2508,7 +2659,7 @@ build_user_type_conversion (tree totype, tree expr, int flags)\n \n   if (cand)\n     {\n-      if (TREE_CODE (cand->second_conv) == AMBIG_CONV)\n+      if (cand->second_conv->kind == ck_ambig)\n \treturn error_mark_node;\n       return convert_from_reference (convert_like (cand->second_conv, expr));\n     }\n@@ -2602,11 +2753,16 @@ build_new_function_call (tree fn, tree args)\n {\n   struct z_candidate *candidates, *cand;\n   bool any_viable_p;\n+  void *p;\n+  tree result;\n \n   args = resolve_args (args);\n   if (args == error_mark_node)\n     return error_mark_node;\n \n+  /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n+  p = conversion_obstack_alloc (0);\n+\n   cand = perform_overload_resolution (fn, args, &candidates, &any_viable_p);\n \n   if (!cand)\n@@ -2623,10 +2779,15 @@ build_new_function_call (tree fn, tree args)\n \t       DECL_NAME (OVL_CURRENT (fn)), args);\n       if (candidates)\n \tprint_z_candidates (candidates);\n-      return error_mark_node;\n+      result = error_mark_node;\n     }\n+  else\n+    result = build_over_call (cand, LOOKUP_NORMAL);\n \n-  return build_over_call (cand, LOOKUP_NORMAL);\n+  /* Free all the conversions we allocated.  */\n+  obstack_free (&conversion_obstack, p);\n+\n+  return result;\n }\n \n /* Build a call to a global operator new.  FNNAME is the name of the\n@@ -2724,6 +2885,8 @@ build_object_call (tree obj, tree args)\n   tree fns, convs, mem_args = NULL_TREE;\n   tree type = TREE_TYPE (obj);\n   bool any_viable_p;\n+  tree result = NULL_TREE;\n+  void *p;\n \n   if (TYPE_PTRMEMFUNC_P (type))\n     {\n@@ -2742,6 +2905,9 @@ build_object_call (tree obj, tree args)\n   if (args == error_mark_node)\n     return error_mark_node;\n \n+  /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n+  p = conversion_obstack_alloc (0);\n+\n   if (fns)\n     {\n       tree base = BINFO_TYPE (BASELINK_BINFO (fns));\n@@ -2797,29 +2963,34 @@ build_object_call (tree obj, tree args)\n     {\n       error (\"no match for call to `(%T) (%A)'\", TREE_TYPE (obj), args);\n       print_z_candidates (candidates);\n-      return error_mark_node;\n+      result = error_mark_node;\n     }\n-\n-  cand = tourney (candidates);\n-  if (cand == 0)\n+  else\n     {\n-      error (\"call of `(%T) (%A)' is ambiguous\", TREE_TYPE (obj), args);\n-      print_z_candidates (candidates);\n-      return error_mark_node;\n+      cand = tourney (candidates);\n+      if (cand == 0)\n+\t{\n+\t  error (\"call of `(%T) (%A)' is ambiguous\", TREE_TYPE (obj), args);\n+\t  print_z_candidates (candidates);\n+\t  result = error_mark_node;\n+\t}\n+      /* Since cand->fn will be a type, not a function, for a conversion\n+\t function, we must be careful not to unconditionally look at\n+\t DECL_NAME here.  */\n+      else if (TREE_CODE (cand->fn) == FUNCTION_DECL\n+\t       && DECL_OVERLOADED_OPERATOR_P (cand->fn) == CALL_EXPR)\n+\tresult = build_over_call (cand, LOOKUP_NORMAL);\n+      else\n+\t{\n+\t  obj = convert_like_with_context (cand->convs[0], obj, cand->fn, -1);\n+\t  result = build_function_call (obj, args);\n+\t}\n     }\n \n-  /* Since cand->fn will be a type, not a function, for a conversion\n-     function, we must be careful not to unconditionally look at\n-     DECL_NAME here.  */\n-  if (TREE_CODE (cand->fn) == FUNCTION_DECL\n-      && DECL_OVERLOADED_OPERATOR_P (cand->fn) == CALL_EXPR)\n-    return build_over_call (cand, LOOKUP_NORMAL);\n+  /* Free all the conversions we allocated.  */\n+  obstack_free (&conversion_obstack, p);\n \n-  obj = convert_like_with_context\n-          (TREE_VEC_ELT (cand->convs, 0), obj, cand->fn, -1);\n-\n-  /* FIXME */\n-  return build_function_call (obj, args);\n+  return result;\n }\n \n static void\n@@ -2868,12 +3039,12 @@ op_error (enum tree_code code, enum tree_code code2,\n /* Return the implicit conversion sequence that could be used to\n    convert E1 to E2 in [expr.cond].  */\n \n-static tree\n+static conversion *\n conditional_conversion (tree e1, tree e2)\n {\n   tree t1 = non_reference (TREE_TYPE (e1));\n   tree t2 = non_reference (TREE_TYPE (e2));\n-  tree conv;\n+  conversion *conv;\n   bool good_base;\n \n   /* [expr.cond]\n@@ -2910,19 +3081,19 @@ conditional_conversion (tree e1, tree e2)\n     {\n       if (good_base && at_least_as_qualified_p (t2, t1))\n \t{\n-\t  conv = build1 (IDENTITY_CONV, t1, e1);\n+\t  conv = build_identity_conv (t1, e1);\n \t  if (!same_type_p (TYPE_MAIN_VARIANT (t1), \n \t\t\t    TYPE_MAIN_VARIANT (t2)))\n \t    {\n-\t      conv = build_conv (BASE_CONV, t2, conv);\n-\t      NEED_TEMPORARY_P (conv) = 1;\n+\t      conv = build_conv (ck_base, t2, conv);\n+\t      conv->need_temporary_p = true;\n \t    }\n \t  else\n-\t    conv = build_conv (RVALUE_CONV, t2, conv);\n+\t    conv = build_conv (ck_rvalue, t2, conv);\n \t  return conv;\n \t}\n       else\n-\treturn NULL_TREE;\n+\treturn NULL;\n     }\n   else\n     /* [expr.cond]\n@@ -2941,11 +3112,12 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n {\n   tree arg2_type;\n   tree arg3_type;\n-  tree result;\n+  tree result = NULL_TREE;\n   tree result_type = NULL_TREE;\n   bool lvalue_p = true;\n   struct z_candidate *candidates = 0;\n   struct z_candidate *cand;\n+  void *p;\n \n   /* As a G++ extension, the second argument to the conditional can be\n      omitted.  (So that `a ? : c' is roughly equivalent to `a ? a :\n@@ -3031,9 +3203,15 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n   else if (!same_type_p (arg2_type, arg3_type)\n \t   && (CLASS_TYPE_P (arg2_type) || CLASS_TYPE_P (arg3_type)))\n     {\n-      tree conv2 = conditional_conversion (arg2, arg3);\n-      tree conv3 = conditional_conversion (arg3, arg2);\n+      conversion *conv2;\n+      conversion *conv3;\n       \n+      /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n+      p = conversion_obstack_alloc (0);\n+\n+      conv2 = conditional_conversion (arg2, arg3);\n+      conv3 = conditional_conversion (arg3, arg2);\n+\n       /* [expr.cond]\n \n \t If both can be converted, or one can be converted but the\n@@ -3043,15 +3221,15 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \t one conversion is possible, that conversion is applied to the\n \t chosen operand and the converted operand is used in place of\n \t the original operand for the remainder of this section.  */\n-      if ((conv2 && !ICS_BAD_FLAG (conv2) \n-\t   && conv3 && !ICS_BAD_FLAG (conv3))\n-\t  || (conv2 && TREE_CODE (conv2) == AMBIG_CONV)\n-\t  || (conv3 && TREE_CODE (conv3) == AMBIG_CONV))\n+      if ((conv2 && !conv2->bad_p\n+\t   && conv3 && !conv3->bad_p)\n+\t  || (conv2 && conv2->kind == ck_ambig)\n+\t  || (conv3 && conv3->kind == ck_ambig))\n \t{\n \t  error (\"operands to ?: have different types\");\n-\t  return error_mark_node;\n+\t  result = error_mark_node;\n \t}\n-      else if (conv2 && !ICS_BAD_FLAG (conv2))\n+      else if (conv2 && !conv2->bad_p)\n \t{\n \t  arg2 = convert_like (conv2, arg2);\n \t  arg2 = convert_from_reference (arg2);\n@@ -3063,7 +3241,7 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \t    abort ();\n \t  arg2_type = TREE_TYPE (arg2);\n \t}\n-      else if (conv3 && !ICS_BAD_FLAG (conv3))\n+      else if (conv3 && !conv3->bad_p)\n \t{\n \t  arg3 = convert_like (conv3, arg3);\n \t  arg3 = convert_from_reference (arg3);\n@@ -3072,6 +3250,12 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \t    abort ();\n \t  arg3_type = TREE_TYPE (arg3);\n \t}\n+\n+      /* Free all the conversions we allocated.  */\n+      obstack_free (&conversion_obstack, p);\n+\n+      if (result)\n+\treturn result;\n     }\n \n   /* [expr.cond]\n@@ -3098,7 +3282,7 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n       && (CLASS_TYPE_P (arg2_type) || CLASS_TYPE_P (arg3_type)))\n     {\n       tree args[3];\n-      tree conv;\n+      conversion *conv;\n       bool any_viable_p;\n \n       /* Rearrange the arguments so that add_builtin_candidate only has\n@@ -3138,11 +3322,11 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \t Otherwise, the conversions thus determined are applied, and\n \t the converted operands are used in place of the original\n \t operands for the remainder of this section.  */\n-      conv = TREE_VEC_ELT (cand->convs, 0);\n+      conv = cand->convs[0];\n       arg1 = convert_like (conv, arg1);\n-      conv = TREE_VEC_ELT (cand->convs, 1);\n+      conv = cand->convs[1];\n       arg2 = convert_like (conv, arg2);\n-      conv = TREE_VEC_ELT (cand->convs, 2);\n+      conv = cand->convs[2];\n       arg3 = convert_like (conv, arg3);\n     }\n \n@@ -3353,8 +3537,11 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n   struct z_candidate *candidates = 0, *cand;\n   tree arglist, fnname;\n   tree args[3];\n+  tree result = NULL_TREE;\n+  bool result_valid_p = false;\n   enum tree_code code2 = NOP_EXPR;\n-  tree conv;\n+  conversion *conv;\n+  void *p;\n   bool strict_p;\n   bool any_viable_p;\n \n@@ -3416,6 +3603,9 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n     arglist = tree_cons (NULL_TREE, arg2, arglist);\n   arglist = tree_cons (NULL_TREE, arg1, arglist);\n \n+  /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n+  p = conversion_obstack_alloc (0);\n+\n   /* Add namespace-scope operators to the list of functions to\n      consider.  */\n   add_candidates (lookup_function_nonclass (fnname, arglist),\n@@ -3428,7 +3618,10 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n \n       fns = lookup_fnfields (TYPE_BINFO (TREE_TYPE (arg1)), fnname, 1);\n       if (fns == error_mark_node)\n-\treturn fns;\n+\t{\n+\t  result = error_mark_node;\n+\t  goto user_defined_result_ready;\n+\t}\n       if (fns)\n \tadd_candidates (BASELINK_FUNCTIONS (fns), arglist, \n \t\t\tNULL_TREE, false,\n@@ -3491,98 +3684,113 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n \t    code = PREINCREMENT_EXPR;\n \t  else\n \t    code = PREDECREMENT_EXPR;\t\n-\t  return build_new_op (code, flags, arg1, NULL_TREE, NULL_TREE);\n-\t  \n+\t  result = build_new_op (code, flags, arg1, NULL_TREE, NULL_TREE);\n+\t  break;\n+\n \t  /* The caller will deal with these.  */\n \tcase ADDR_EXPR:\n \tcase COMPOUND_EXPR:\n \tcase COMPONENT_REF:\n-\t  return NULL_TREE;\n+\t  result = NULL_TREE;\n+\t  result_valid_p = true;\n+\t  break;\n \n \tdefault:\n+\t  if (flags & LOOKUP_COMPLAIN)\n+\t    {\n+\t      op_error (code, code2, arg1, arg2, arg3, \"no match\");\n+\t      print_z_candidates (candidates);\n+\t    }\n+\t  result = error_mark_node;\n \t  break;\n \t}\n-      if (flags & LOOKUP_COMPLAIN)\n-\t{\n-\t  op_error (code, code2, arg1, arg2, arg3, \"no match\");\n-\t  print_z_candidates (candidates);\n-\t}\n-      return error_mark_node;\n     }\n-\n-  cand = tourney (candidates);\n-  if (cand == 0)\n+  else\n     {\n-      if (flags & LOOKUP_COMPLAIN)\n+      cand = tourney (candidates);\n+      if (cand == 0)\n \t{\n-\t  op_error (code, code2, arg1, arg2, arg3, \"ambiguous overload\");\n-\t  print_z_candidates (candidates);\n+\t  if (flags & LOOKUP_COMPLAIN)\n+\t    {\n+\t      op_error (code, code2, arg1, arg2, arg3, \"ambiguous overload\");\n+\t      print_z_candidates (candidates);\n+\t    }\n+\t  result = error_mark_node;\n \t}\n-      return error_mark_node;\n-    }\n-\n-  if (TREE_CODE (cand->fn) == FUNCTION_DECL)\n-    {\n-      if (warn_synth\n-\t  && fnname == ansi_assopname (NOP_EXPR)\n-\t  && DECL_ARTIFICIAL (cand->fn)\n-\t  && candidates->next\n-\t  && ! candidates->next->next)\n+      else if (TREE_CODE (cand->fn) == FUNCTION_DECL)\n \t{\n-\t  warning (\"using synthesized `%#D' for copy assignment\",\n-\t\t      cand->fn);\n-\t  cp_warning_at (\"  where cfront would use `%#D'\",\n-\t\t\t cand == candidates\n-\t\t\t ? candidates->next->fn\n-\t\t\t : candidates->fn);\n-\t}\n-\n-      return build_over_call (cand, LOOKUP_NORMAL);\n-    }\n+\t  if (warn_synth\n+\t      && fnname == ansi_assopname (NOP_EXPR)\n+\t      && DECL_ARTIFICIAL (cand->fn)\n+\t      && candidates->next\n+\t      && ! candidates->next->next)\n+\t    {\n+\t      warning (\"using synthesized `%#D' for copy assignment\",\n+\t\t\t  cand->fn);\n+\t      cp_warning_at (\"  where cfront would use `%#D'\",\n+\t\t\t     cand == candidates\n+\t\t\t     ? candidates->next->fn\n+\t\t\t     : candidates->fn);\n+\t    }\n \n-  /* Check for comparison of different enum types.  */\n-  switch (code)\n-    {\n-    case GT_EXPR:\n-    case LT_EXPR:\n-    case GE_EXPR:\n-    case LE_EXPR:\n-    case EQ_EXPR:\n-    case NE_EXPR:\n-      if (TREE_CODE (TREE_TYPE (arg1)) == ENUMERAL_TYPE \n-\t  && TREE_CODE (TREE_TYPE (arg2)) == ENUMERAL_TYPE \n-\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (arg1))\n-\t      != TYPE_MAIN_VARIANT (TREE_TYPE (arg2))))\n+\t  result = build_over_call (cand, LOOKUP_NORMAL);\n+\t}\n+      else\n \t{\n-\t  warning (\"comparison between `%#T' and `%#T'\", \n-\t\t      TREE_TYPE (arg1), TREE_TYPE (arg2));\n+\t  /* Check for comparison of different enum types.  */\n+\t  switch (code)\n+\t    {\n+\t    case GT_EXPR:\n+\t    case LT_EXPR:\n+\t    case GE_EXPR:\n+\t    case LE_EXPR:\n+\t    case EQ_EXPR:\n+\t    case NE_EXPR:\n+\t      if (TREE_CODE (TREE_TYPE (arg1)) == ENUMERAL_TYPE \n+\t\t  && TREE_CODE (TREE_TYPE (arg2)) == ENUMERAL_TYPE \n+\t\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (arg1))\n+\t\t      != TYPE_MAIN_VARIANT (TREE_TYPE (arg2))))\n+\t\t{\n+\t\t  warning (\"comparison between `%#T' and `%#T'\", \n+\t\t\t      TREE_TYPE (arg1), TREE_TYPE (arg2));\n+\t\t}\n+\t      break;\n+\t    default:\n+\t      break;\n+\t    }\n+\n+\t  /* We need to strip any leading REF_BIND so that bitfields\n+\t     don't cause errors.  This should not remove any important\n+\t     conversions, because builtins don't apply to class\n+\t     objects directly.  */\n+\t  conv = cand->convs[0];\n+\t  if (conv->kind == ck_ref_bind)\n+\t    conv = conv->u.next;\n+\t  arg1 = convert_like (conv, arg1);\n+\t  if (arg2)\n+\t    {\n+\t      conv = cand->convs[1];\n+\t      if (conv->kind == ck_ref_bind)\n+\t\tconv = conv->u.next;\n+\t      arg2 = convert_like (conv, arg2);\n+\t    }\n+\t  if (arg3)\n+\t    {\n+\t      conv = cand->convs[2];\n+\t      if (conv->kind == ck_ref_bind)\n+\t\tconv = conv->u.next;\n+\t      arg3 = convert_like (conv, arg3);\n+\t    }\n \t}\n-      break;\n-    default:\n-      break;\n     }\n \n-  /* We need to strip any leading REF_BIND so that bitfields don't cause\n-     errors.  This should not remove any important conversions, because\n-     builtins don't apply to class objects directly.  */\n-  conv = TREE_VEC_ELT (cand->convs, 0);\n-  if (TREE_CODE (conv) == REF_BIND)\n-    conv = TREE_OPERAND (conv, 0);\n-  arg1 = convert_like (conv, arg1);\n-  if (arg2)\n-    {\n-      conv = TREE_VEC_ELT (cand->convs, 1);\n-      if (TREE_CODE (conv) == REF_BIND)\n-        conv = TREE_OPERAND (conv, 0);\n-      arg2 = convert_like (conv, arg2);\n-    }\n-  if (arg3)\n-    {\n-      conv = TREE_VEC_ELT (cand->convs, 2);\n-      if (TREE_CODE (conv) == REF_BIND)\n-        conv = TREE_OPERAND (conv, 0);\n-      arg3 = convert_like (conv, arg3);\n-    }\n+ user_defined_result_ready:\n+\n+  /* Free all the conversions we allocated.  */\n+  obstack_free (&conversion_obstack, p);\n+\n+  if (result || result_valid_p)\n+    return result;\n \n builtin:\n   switch (code)\n@@ -3658,12 +3866,13 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n    CODE is either DELETE_EXPR or VEC_DELETE_EXPR.\n    ADDR is the pointer to be deleted.\n    SIZE is the size of the memory block to be deleted.\n-   FLAGS are the usual overloading flags.\n+   GLOBAL_P is true if the delete-expression should not consider\n+   class-specific delete operators.\n    PLACEMENT is the corresponding placement new call, or NULL_TREE.  */\n \n tree\n build_op_delete_call (enum tree_code code, tree addr, tree size,\n-                      int flags, tree placement)\n+\t\t      bool global_p, tree placement)\n {\n   tree fn = NULL_TREE;\n   tree fns, fnname, argtypes, args, type;\n@@ -3676,7 +3885,7 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \n   fnname = ansi_opname (code);\n \n-  if (IS_AGGR_TYPE (type) && ! (flags & LOOKUP_GLOBAL))\n+  if (IS_AGGR_TYPE (type) && !global_p)\n     /* In [class.free]\n \n        If the result of the lookup is ambiguous or inaccessible, or if\n@@ -3866,30 +4075,30 @@ build_temp (tree expr, tree type, int flags,\n    conversions will be emitted if appropriate.  */\n \n static tree\n-convert_like_real (tree convs, tree expr, tree fn, int argnum, int inner,\n-\t\t   bool issue_conversion_warnings)\n+convert_like_real (conversion *convs, tree expr, tree fn, int argnum, \n+\t\t   int inner, bool issue_conversion_warnings)\n {\n-  tree totype = TREE_TYPE (convs);\n+  tree totype = convs->type;\n   void (*diagnostic_fn)(const char *, ...);\n \n-  if (ICS_BAD_FLAG (convs)\n-      && TREE_CODE (convs) != USER_CONV\n-      && TREE_CODE (convs) != AMBIG_CONV\n-      && TREE_CODE (convs) != REF_BIND)\n+  if (convs->bad_p\n+      && convs->kind != ck_user\n+      && convs->kind != ck_ambig\n+      && convs->kind != ck_ref_bind)\n     {\n-      tree t = convs; \n-      for (; t; t = TREE_OPERAND (t, 0))\n+      conversion *t = convs;\n+      for (; t; t = convs->u.next)\n \t{\n-\t  if (TREE_CODE (t) == USER_CONV || !ICS_BAD_FLAG (t))\n+\t  if (t->kind == ck_user || !t->bad_p)\n \t    {\n \t      expr = convert_like_real (t, expr, fn, argnum, 1,\n \t\t\t\t\t/*issue_conversion_warnings=*/false);\n \t      break;\n \t    }\n-\t  else if (TREE_CODE (t) == AMBIG_CONV)\n+\t  else if (t->kind == ck_ambig)\n \t    return convert_like_real (t, expr, fn, argnum, 1,\n \t\t\t\t      /*issue_conversion_warnings=*/false);\n-\t  else if (TREE_CODE (t) == IDENTITY_CONV)\n+\t  else if (t->kind == ck_identity)\n \t    break;\n \t}\n       pedwarn (\"invalid conversion from `%T' to `%T'\", TREE_TYPE (expr), totype);\n@@ -3901,11 +4110,11 @@ convert_like_real (tree convs, tree expr, tree fn, int argnum, int inner,\n   if (issue_conversion_warnings)\n     expr = dubious_conversion_warnings\n              (totype, expr, \"converting\", fn, argnum);\n-  switch (TREE_CODE (convs))\n+  switch (convs->kind)\n     {\n-    case USER_CONV:\n+    case ck_user:\n       {\n-\tstruct z_candidate *cand = USER_CONV_CAND (convs);\n+\tstruct z_candidate *cand = convs->cand;\n \ttree convfn = cand->fn;\n \ttree args;\n \n@@ -3965,7 +4174,7 @@ convert_like_real (tree convs, tree expr, tree fn, int argnum, int inner,\n \t  }\n \treturn expr;\n       }\n-    case IDENTITY_CONV:\n+    case ck_identity:\n       if (type_unknown_p (expr))\n \texpr = instantiate_type (totype, expr, tf_error | tf_warning);\n       /* Convert a non-array constant variable to its underlying value, unless we\n@@ -3974,40 +4183,40 @@ convert_like_real (tree convs, tree expr, tree fn, int argnum, int inner,\n       if (inner >= 0\n \t  && TREE_CODE (TREE_TYPE (expr)) != ARRAY_TYPE)\n \texpr = decl_constant_value (expr);\n-      if (CHECK_COPY_CONSTRUCTOR_P (convs))\n+      if (convs->check_copy_constructor_p)\n \t/* Generate a temporary copy purely to generate the required\n \t   diagnostics.  */\n \tbuild_temp (build_dummy_object (totype), totype, \n \t\t    LOOKUP_NORMAL|LOOKUP_ONLYCONVERTING,\n \t\t    &diagnostic_fn);\n \treturn expr;\n-    case AMBIG_CONV:\n+    case ck_ambig:\n       /* Call build_user_type_conversion again for the error.  */\n       return build_user_type_conversion\n-\t(totype, TREE_OPERAND (convs, 0), LOOKUP_NORMAL);\n+\t(totype, convs->u.expr, LOOKUP_NORMAL);\n \n     default:\n       break;\n     };\n \n-  expr = convert_like_real (TREE_OPERAND (convs, 0), expr, fn, argnum,\n-                            TREE_CODE (convs) == REF_BIND ? -1 : 1,\n+  expr = convert_like_real (convs->u.next, expr, fn, argnum,\n+\t\t\t    convs->kind == ck_ref_bind ? -1 : 1,\n \t\t\t    /*issue_conversion_warnings=*/false);\n   if (expr == error_mark_node)\n     return error_mark_node;\n \n-  switch (TREE_CODE (convs))\n+  switch (convs->kind)\n     {\n-    case RVALUE_CONV:\n+    case ck_rvalue:\n       if (! IS_AGGR_TYPE (totype))\n \treturn expr;\n       /* Else fall through.  */\n-    case BASE_CONV:\n-      if (TREE_CODE (convs) == BASE_CONV && !NEED_TEMPORARY_P (convs))\n+    case ck_base:\n+      if (convs->kind == ck_base && !convs->need_temporary_p)\n \t{\n \t  /* We are going to bind a reference directly to a base-class\n \t     subobject of EXPR.  */\n-\t  if (CHECK_COPY_CONSTRUCTOR_P (convs))\n+\t  if (convs->check_copy_constructor_p)\n \t    /* Generate a temporary copy purely to generate the required\n \t       diagnostics.  */\n \t    build_temp (build_dummy_object (TREE_TYPE (expr)),\n@@ -4031,14 +4240,14 @@ convert_like_real (tree convs, tree expr, tree fn, int argnum, int inner,\n \tdiagnostic_fn (\"  initializing argument %P of `%D'\", argnum, fn);\n       return build_cplus_new (totype, expr);\n \n-    case REF_BIND:\n+    case ck_ref_bind:\n       {\n \ttree ref_type = totype;\n \n \t/* If necessary, create a temporary.  */\n-\tif (NEED_TEMPORARY_P (convs) || !lvalue_p (expr))\n+\tif (convs->need_temporary_p || !lvalue_p (expr))\n \t  {\n-\t    tree type = TREE_TYPE (TREE_OPERAND (convs, 0));\n+\t    tree type = convs->u.next->type;\n \n \t    if (!CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (ref_type)))\n \t      {\n@@ -4074,10 +4283,10 @@ convert_like_real (tree convs, tree expr, tree fn, int argnum, int inner,\n \treturn build_nop (ref_type, expr);\n       }\n \n-    case LVALUE_CONV:\n+    case ck_lvalue:\n       return decay_conversion (expr);\n \n-    case QUAL_CONV:\n+    case ck_qual:\n       /* Warn about deprecated conversion if appropriate.  */\n       string_conv_p (totype, expr, 1);\n       break;\n@@ -4307,10 +4516,11 @@ build_over_call (struct z_candidate *cand, int flags)\n {\n   tree fn = cand->fn;\n   tree args = cand->args;\n-  tree convs = cand->convs;\n+  conversion **convs = cand->convs;\n+  conversion *conv;\n   tree converted_args = NULL_TREE;\n   tree parm = TYPE_ARG_TYPES (TREE_TYPE (fn));\n-  tree conv, arg, val;\n+  tree arg, val;\n   int i = 0;\n   int is_method = 0;\n \n@@ -4331,8 +4541,11 @@ build_over_call (struct z_candidate *cand, int flags)\n \n   /* Give any warnings we noticed during overload resolution.  */\n   if (cand->warnings)\n-    for (val = cand->warnings; val; val = TREE_CHAIN (val))\n-      joust (cand, WRAPPER_ZC (TREE_VALUE (val)), 1);\n+    {\n+      struct candidate_warning *w;\n+      for (w = cand->warnings; w; w = w->next)\n+\tjoust (cand, w->loser, 1);\n+    }\n \n   if (DECL_FUNCTION_MEMBER_P (fn))\n     {\n@@ -4399,7 +4612,7 @@ build_over_call (struct z_candidate *cand, int flags)\n       tree converted_arg;\n       tree base_binfo;\n       \n-      if (ICS_BAD_FLAG (TREE_VEC_ELT (convs, i)))\n+      if (convs[i]->bad_p)\n \tpedwarn (\"passing `%T' as `this' argument of `%#D' discards qualifiers\",\n \t\t    TREE_TYPE (argtype), fn);\n \n@@ -4442,7 +4655,7 @@ build_over_call (struct z_candidate *cand, int flags)\n     {\n       tree type = TREE_VALUE (parm);\n \n-      conv = TREE_VEC_ELT (convs, i);\n+      conv = convs[i];\n       val = convert_like_with_context\n \t(conv, TREE_VALUE (arg), fn, i - is_method);\n \n@@ -4481,8 +4694,7 @@ build_over_call (struct z_candidate *cand, int flags)\n \n   if (! flag_elide_constructors)\n     /* Do things the hard way.  */;\n-  else if (TREE_VEC_LENGTH (convs) == 1\n-\t   && DECL_COPY_CONSTRUCTOR_P (fn))\n+  else if (cand->num_convs == 1 && DECL_COPY_CONSTRUCTOR_P (fn))\n     {\n       tree targ;\n       arg = skip_artificial_parms_for (fn, converted_args);\n@@ -4913,6 +5125,7 @@ build_new_method_call (tree instance, tree fns, tree args,\n   tree orig_instance;\n   tree orig_fns;\n   tree orig_args;\n+  void *p;\n \n   my_friendly_assert (instance != NULL_TREE, 20020729);\n \n@@ -5004,6 +5217,9 @@ build_new_method_call (tree instance, tree fns, tree args,\n   class_type = (conversion_path ? BINFO_TYPE (conversion_path) : NULL_TREE);\n   mem_args = tree_cons (NULL_TREE, instance_ptr, args);\n \n+  /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n+  p = conversion_obstack_alloc (0);\n+\n   for (fn = fns; fn; fn = OVL_NEXT (fn))\n     {\n       tree t = OVL_CURRENT (fn);\n@@ -5041,9 +5257,6 @@ build_new_method_call (tree instance, tree fns, tree args,\n   candidates = splice_viable (candidates, pedantic, &any_viable_p);\n   if (!any_viable_p)\n     {\n-      /* XXX will LOOKUP_SPECULATIVELY be needed when this is done?  */\n-      if (flags & LOOKUP_SPECULATIVELY)\n-\treturn NULL_TREE;\n       if (!COMPLETE_TYPE_P (basetype))\n \tcxx_incomplete_type_error (instance_ptr, basetype);\n       else\n@@ -5059,99 +5272,110 @@ build_new_method_call (tree instance, tree fns, tree args,\n \t    free (pretty_name);\n \t}\n       print_z_candidates (candidates);\n-      return error_mark_node;\n+      call = error_mark_node;\n     }\n-\n-  cand = tourney (candidates);\n-  if (cand == 0)\n+  else\n     {\n-      char *pretty_name;\n-      bool free_p;\n+      cand = tourney (candidates);\n+      if (cand == 0)\n+\t{\n+\t  char *pretty_name;\n+\t  bool free_p;\n \n-      pretty_name = name_as_c_string (name, basetype, &free_p);\n-      error (\"call of overloaded `%s(%A)' is ambiguous\", pretty_name,\n-\t     user_args);\n-      print_z_candidates (candidates);\n-      if (free_p)\n-\tfree (pretty_name);\n-      return error_mark_node;\n+\t  pretty_name = name_as_c_string (name, basetype, &free_p);\n+\t  error (\"call of overloaded `%s(%A)' is ambiguous\", pretty_name,\n+\t\t user_args);\n+\t  print_z_candidates (candidates);\n+\t  if (free_p)\n+\t    free (pretty_name);\n+\t  call = error_mark_node;\n+\t}\n+      else\n+\t{\n+\t  if (DECL_PURE_VIRTUAL_P (cand->fn)\n+\t      && instance == current_class_ref\n+\t      && (DECL_CONSTRUCTOR_P (current_function_decl)\n+\t\t  || DECL_DESTRUCTOR_P (current_function_decl))\n+\t      && ! (flags & LOOKUP_NONVIRTUAL)\n+\t      && value_member (cand->fn, CLASSTYPE_PURE_VIRTUALS (basetype)))\n+\t    error ((DECL_CONSTRUCTOR_P (current_function_decl) ? \n+\t\t    \"abstract virtual `%#D' called from constructor\"\n+\t\t    : \"abstract virtual `%#D' called from destructor\"),\n+\t\t   cand->fn);\n+\t  if (TREE_CODE (TREE_TYPE (cand->fn)) == METHOD_TYPE\n+\t      && is_dummy_object (instance_ptr))\n+\t    {\n+\t      error (\"cannot call member function `%D' without object\", \n+\t\t     cand->fn);\n+\t      call = error_mark_node;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (DECL_VINDEX (cand->fn) && ! (flags & LOOKUP_NONVIRTUAL)\n+\t\t  && resolves_to_fixed_type_p (instance, 0))\n+\t\tflags |= LOOKUP_NONVIRTUAL;\n+\n+\t      call = build_over_call (cand, flags);\n+\n+\t      /* In an expression of the form `a->f()' where `f' turns\n+\t\t out to be a static member function, `a' is\n+\t\t none-the-less evaluated.  */\n+\t      if (TREE_CODE (TREE_TYPE (cand->fn)) != METHOD_TYPE\n+\t\t  && !is_dummy_object (instance_ptr) \n+\t\t  && TREE_SIDE_EFFECTS (instance))\n+\t\tcall = build (COMPOUND_EXPR, TREE_TYPE (call), \n+\t\t\t      instance, call);\n+\t    }\n+\t}\n     }\n \n-  if (DECL_PURE_VIRTUAL_P (cand->fn)\n-      && instance == current_class_ref\n-      && (DECL_CONSTRUCTOR_P (current_function_decl)\n-\t  || DECL_DESTRUCTOR_P (current_function_decl))\n-      && ! (flags & LOOKUP_NONVIRTUAL)\n-      && value_member (cand->fn, CLASSTYPE_PURE_VIRTUALS (basetype)))\n-    error ((DECL_CONSTRUCTOR_P (current_function_decl) ? \n-\t       \"abstract virtual `%#D' called from constructor\"\n-\t       : \"abstract virtual `%#D' called from destructor\"),\n-\t      cand->fn);\n-  if (TREE_CODE (TREE_TYPE (cand->fn)) == METHOD_TYPE\n-      && is_dummy_object (instance_ptr))\n-    {\n-      error (\"cannot call member function `%D' without object\", cand->fn);\n-      return error_mark_node;\n-    }\n+  if (processing_template_decl && call != error_mark_node)\n+    call = (build_min_non_dep\n+\t    (CALL_EXPR, call,\n+\t     build_min_nt (COMPONENT_REF, orig_instance, orig_fns),\n+\t     orig_args));\n \n-  if (DECL_VINDEX (cand->fn) && ! (flags & LOOKUP_NONVIRTUAL)\n-      && resolves_to_fixed_type_p (instance, 0))\n-    flags |= LOOKUP_NONVIRTUAL;\n+ /* Free all the conversions we allocated.  */\n+  obstack_free (&conversion_obstack, p);\n \n-  if (TREE_CODE (TREE_TYPE (cand->fn)) == METHOD_TYPE)\n-    call = build_over_call (cand, flags);\n-  else\n-    {\n-      call = build_over_call (cand, flags);\n-      /* In an expression of the form `a->f()' where `f' turns out to\n-\t be a static member function, `a' is none-the-less evaluated.  */\n-      if (!is_dummy_object (instance_ptr) && TREE_SIDE_EFFECTS (instance))\n-\tcall = build (COMPOUND_EXPR, TREE_TYPE (call), instance, call);\n-    }\n-  \n-  if (processing_template_decl && call != error_mark_node)\n-    return build_min_non_dep\n-      (CALL_EXPR, call,\n-       build_min_nt (COMPONENT_REF, orig_instance, orig_fns),\n-       orig_args);\n   return call;\n }\n \n /* Returns true iff standard conversion sequence ICS1 is a proper\n    subsequence of ICS2.  */\n \n static bool\n-is_subseq (tree ics1, tree ics2)\n+is_subseq (conversion *ics1, conversion *ics2)\n {\n   /* We can assume that a conversion of the same code\n      between the same types indicates a subsequence since we only get\n      here if the types we are converting from are the same.  */\n \n-  while (TREE_CODE (ics1) == RVALUE_CONV\n-\t || TREE_CODE (ics1) == LVALUE_CONV)\n-    ics1 = TREE_OPERAND (ics1, 0);\n+  while (ics1->kind == ck_rvalue\n+\t || ics1->kind == ck_lvalue)\n+    ics1 = ics1->u.next;\n \n   while (1)\n     {\n-      while (TREE_CODE (ics2) == RVALUE_CONV\n-\t  || TREE_CODE (ics2) == LVALUE_CONV)\n-\tics2 = TREE_OPERAND (ics2, 0);\n+      while (ics2->kind == ck_rvalue\n+\t     || ics2->kind == ck_lvalue)\n+\tics2 = ics2->u.next;\n \n-      if (TREE_CODE (ics2) == USER_CONV\n-\t  || TREE_CODE (ics2) == AMBIG_CONV\n-\t  || TREE_CODE (ics2) == IDENTITY_CONV)\n+      if (ics2->kind == ck_user\n+\t  || ics2->kind == ck_ambig\n+\t  || ics2->kind == ck_identity)\n \t/* At this point, ICS1 cannot be a proper subsequence of\n \t   ICS2.  We can get a USER_CONV when we are comparing the\n \t   second standard conversion sequence of two user conversion\n \t   sequences.  */\n \treturn false;\n \n-      ics2 = TREE_OPERAND (ics2, 0);\n+      ics2 = ics2->u.next;\n \n-      if (TREE_CODE (ics2) == TREE_CODE (ics1)\n-\t  && same_type_p (TREE_TYPE (ics2), TREE_TYPE (ics1))\n-\t  && same_type_p (TREE_TYPE (TREE_OPERAND (ics2, 0)),\n-\t\t\t     TREE_TYPE (TREE_OPERAND (ics1, 0))))\n+      if (ics2->kind == ics1->kind\n+\t  && same_type_p (ics2->type, ics1->type)\n+\t  && same_type_p (ics2->u.next->type, \n+\t\t\t  ics1->u.next->type))\n \treturn true;\n     }\n }\n@@ -5179,9 +5403,9 @@ is_properly_derived_from (tree derived, tree base)\n    modify it accordingly.  */\n \n static void\n-maybe_handle_implicit_object (tree *ics)\n+maybe_handle_implicit_object (conversion **ics)\n {\n-  if (ICS_THIS_FLAG (*ics))\n+  if ((*ics)->this_p)\n     {\n       /* [over.match.funcs]\n \t \n@@ -5190,20 +5414,20 @@ maybe_handle_implicit_object (tree *ics)\n \t where X is the class of which the function is a\n \t member and cv is the cv-qualification on the member\n \t function declaration.  */\n-      tree t = *ics;\n+      conversion *t = *ics;\n       tree reference_type;\n \n       /* The `this' parameter is a pointer to a class type.  Make the\n \t implicit conversion talk about a reference to that same class\n \t type.  */\n-      reference_type = TREE_TYPE (TREE_TYPE (*ics));\n+      reference_type = TREE_TYPE (t->type);\n       reference_type = build_reference_type (reference_type);\n \n-      if (TREE_CODE (t) == QUAL_CONV)\n-\tt = TREE_OPERAND (t, 0);\n-      if (TREE_CODE (t) == PTR_CONV)\n-\tt = TREE_OPERAND (t, 0);\n-      t = build1 (IDENTITY_CONV, TREE_TYPE (TREE_TYPE (t)), NULL_TREE);\n+      if (t->kind == ck_qual)\n+\tt = t->u.next;\n+      if (t->kind == ck_ptr)\n+\tt = t->u.next;\n+      t = build_identity_conv (TREE_TYPE (t->type), NULL_TREE);\n       t = direct_reference_binding (reference_type, t); \n       *ics = t;\n     }\n@@ -5214,15 +5438,15 @@ maybe_handle_implicit_object (tree *ics)\n    leave *ICS unchanged and return NULL_TREE.  */\n \n static tree\n-maybe_handle_ref_bind (tree *ics)\n+maybe_handle_ref_bind (conversion **ics)\n {\n-  if (TREE_CODE (*ics) == REF_BIND)\n+  if ((*ics)->kind == ck_ref_bind)\n     {\n-      tree old_ics = *ics;\n-      tree type = TREE_TYPE (TREE_TYPE (old_ics));\n-      *ics = TREE_OPERAND (old_ics, 0);\n-      ICS_USER_FLAG (*ics) = ICS_USER_FLAG (old_ics);\n-      ICS_BAD_FLAG (*ics) = ICS_BAD_FLAG (old_ics);\n+      conversion *old_ics = *ics;\n+      tree type = TREE_TYPE (old_ics->type);\n+      *ics = old_ics->u.next;\n+      (*ics)->user_conv_p = old_ics->user_conv_p;\n+      (*ics)->bad_p = old_ics->bad_p;\n       return type;\n     }\n \n@@ -5237,7 +5461,7 @@ maybe_handle_ref_bind (tree *ics)\n       0: ics1 and ics2 are indistinguishable */\n \n static int\n-compare_ics (tree ics1, tree ics2)\n+compare_ics (conversion *ics1, conversion *ics2)\n {\n   tree from_type1;\n   tree from_type2;\n@@ -5247,7 +5471,7 @@ compare_ics (tree ics1, tree ics2)\n   tree deref_from_type2 = NULL_TREE;\n   tree deref_to_type1 = NULL_TREE;\n   tree deref_to_type2 = NULL_TREE;\n-  int rank1, rank2;\n+  conversion_rank rank1, rank2;\n \n   /* REF_BINDING is nonzero if the result of the conversion sequence\n      is a reference type.   In that case TARGET_TYPE is the\n@@ -5275,30 +5499,30 @@ compare_ics (tree ics1, tree ics2)\n      --a user-defined conversion sequence (_over.ics.user_) is a\n        better conversion sequence than an ellipsis conversion sequence\n        (_over.ics.ellipsis_).  */\n-  rank1 = ICS_RANK (ics1);\n-  rank2 = ICS_RANK (ics2);\n+  rank1 = CONVERSION_RANK (ics1);\n+  rank2 = CONVERSION_RANK (ics2);\n   \n   if (rank1 > rank2)\n     return -1;\n   else if (rank1 < rank2)\n     return 1;\n \n-  if (rank1 == BAD_RANK)\n+  if (rank1 == cr_bad)\n     {\n       /* XXX Isn't this an extension? */\n       /* Both ICS are bad.  We try to make a decision based on what\n \t would have happened if they'd been good.  */\n-      if (ICS_USER_FLAG (ics1) > ICS_USER_FLAG (ics2)\n-\t  || ICS_STD_RANK (ics1) > ICS_STD_RANK (ics2))\n+      if (ics1->user_conv_p > ics2->user_conv_p\n+\t  || ics1->rank  > ics2->rank)\n \treturn -1;\n-      else if (ICS_USER_FLAG (ics1) < ICS_USER_FLAG (ics2)\n-\t       || ICS_STD_RANK (ics1) < ICS_STD_RANK (ics2))\n+      else if (ics1->user_conv_p < ics2->user_conv_p\n+\t       || ics1->rank < ics2->rank)\n \treturn 1;\n \n       /* We couldn't make up our minds; try to figure it out below.  */\n     }\n \n-  if (ICS_ELLIPSIS_FLAG (ics1))\n+  if (ics1->ellipsis_p)\n     /* Both conversions are ellipsis conversions.  */\n     return 0;\n \n@@ -5308,27 +5532,31 @@ compare_ics (tree ics1, tree ics2)\n      ond standard conversion sequence of U1 is  better  than  the  second\n      standard conversion sequence of U2.  */\n \n-  if (ICS_USER_FLAG (ics1))\n+  if (ics1->user_conv_p)\n     {\n-      tree t1, t2;\n+      conversion *t1;\n+      conversion *t2;\n \n-      for (t1 = ics1; TREE_CODE (t1) != USER_CONV; t1 = TREE_OPERAND (t1, 0))\n-\tif (TREE_CODE (t1) == AMBIG_CONV)\n+      for (t1 = ics1; t1->kind != ck_user; t1 = t1->u.next)\n+\tif (t1->kind == ck_ambig)\n \t  return 0;\n-      for (t2 = ics2; TREE_CODE (t2) != USER_CONV; t2 = TREE_OPERAND (t2, 0))\n-\tif (TREE_CODE (t2) == AMBIG_CONV)\n+      for (t2 = ics2; t2->kind != ck_user; t2 = t2->u.next)\n+\tif (t2->kind == ck_ambig)\n \t  return 0;\n \n-      if (USER_CONV_FN (t1) != USER_CONV_FN (t2))\n+      if (t1->cand->fn != t2->cand->fn)\n \treturn 0;\n \n       /* We can just fall through here, after setting up\n \t FROM_TYPE1 and FROM_TYPE2.  */\n-      from_type1 = TREE_TYPE (t1);\n-      from_type2 = TREE_TYPE (t2);\n+      from_type1 = t1->type;\n+      from_type2 = t2->type;\n     }\n   else\n     {\n+      conversion *t1;\n+      conversion *t2;\n+\n       /* We're dealing with two standard conversion sequences. \n \n \t [over.ics.rank]\n@@ -5342,15 +5570,15 @@ compare_ics (tree ics1, tree ics2)\n \t   conversion sequence is considered to be a subsequence of\n \t   any non-identity conversion sequence */\n       \n-      from_type1 = ics1;\n-      while (TREE_CODE (from_type1) != IDENTITY_CONV)\n-\tfrom_type1 = TREE_OPERAND (from_type1, 0);\n-      from_type1 = TREE_TYPE (from_type1);\n+      t1 = ics1;\n+      while (t1->kind != ck_identity)\n+\tt1 = t1->u.next;\n+      from_type1 = t1->type;\n       \n-      from_type2 = ics2;\n-      while (TREE_CODE (from_type2) != IDENTITY_CONV)\n-\tfrom_type2 = TREE_OPERAND (from_type2, 0);\n-      from_type2 = TREE_TYPE (from_type2);\n+      t2 = ics2;\n+      while (t2->kind != ck_identity)\n+\tt2 = t2->u.next;\n+      from_type2 = t2->type;\n     }\n \n   if (same_type_p (from_type1, from_type2))\n@@ -5385,13 +5613,13 @@ compare_ics (tree ics1, tree ics2)\n \n     The ICS_STD_RANK automatically handles the pointer-to-bool rule,\n     so that we do not have to check it explicitly.  */\n-  if (ICS_STD_RANK (ics1) < ICS_STD_RANK (ics2))\n+  if (ics1->rank < ics2->rank)\n     return 1;\n-  else if (ICS_STD_RANK (ics2) < ICS_STD_RANK (ics1))\n+  else if (ics2->rank < ics1->rank)\n     return -1;\n \n-  to_type1 = TREE_TYPE (ics1);\n-  to_type2 = TREE_TYPE (ics2);\n+  to_type1 = ics1->type;\n+  to_type2 = ics2->type;\n \n   if (TYPE_PTR_P (from_type1)\n       && TYPE_PTR_P (from_type2)\n@@ -5541,8 +5769,8 @@ compare_ics (tree ics1, tree ics2)\n        similar  types  T1 and T2 (_conv.qual_), respectively, and the cv-\n        qualification signature of type T1 is a proper subset of  the  cv-\n        qualification signature of type T2  */\n-  if (TREE_CODE (ics1) == QUAL_CONV \n-      && TREE_CODE (ics2) == QUAL_CONV\n+  if (ics1->kind == ck_qual\n+      && ics2->kind == ck_qual\n       && same_type_p (from_type1, from_type2))\n     return comp_cv_qual_signature (to_type1, to_type2);\n \n@@ -5565,14 +5793,14 @@ compare_ics (tree ics1, tree ics2)\n /* The source type for this standard conversion sequence.  */\n \n static tree\n-source_type (tree t)\n+source_type (conversion *t)\n {\n-  for (;; t = TREE_OPERAND (t, 0))\n+  for (;; t = t->u.next)\n     {\n-      if (TREE_CODE (t) == USER_CONV\n-\t  || TREE_CODE (t) == AMBIG_CONV\n-\t  || TREE_CODE (t) == IDENTITY_CONV)\n-\treturn TREE_TYPE (t);\n+      if (t->kind == ck_user\n+\t  || t->kind == ck_ambig\n+\t  || t->kind == ck_identity)\n+\treturn t->type;\n     }\n   abort ();\n }\n@@ -5584,9 +5812,12 @@ source_type (tree t)\n static void\n add_warning (struct z_candidate *winner, struct z_candidate *loser)\n {\n-  winner->warnings = tree_cons (NULL_TREE,\n-\t\t\t\tbuild_zc_wrapper (loser),\n-\t\t\t\twinner->warnings);\n+  candidate_warning *cw;\n+\n+  cw = conversion_obstack_alloc (sizeof (candidate_warning));\n+  cw->loser = loser;\n+  cw->next = winner->warnings;\n+  winner->warnings = cw;\n }\n \n /* Compare two candidates for overloading as described in\n@@ -5600,7 +5831,9 @@ static int\n joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n {\n   int winner = 0;\n-  int i, off1 = 0, off2 = 0, len;\n+  int off1 = 0, off2 = 0;\n+  size_t i;\n+  size_t len;\n \n   /* Candidates that involve bad conversions are always worse than those\n      that don't.  */\n@@ -5627,8 +5860,8 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n      the implicit object parameter of the non-static function.  The\n      standard says to pretend that the static function has an object\n      parm, but that won't work with operator overloading.  */\n-  len = TREE_VEC_LENGTH (cand1->convs);\n-  if (len != TREE_VEC_LENGTH (cand2->convs))\n+  len = cand1->num_convs;\n+  if (len != cand2->num_convs)\n     {\n       if (DECL_STATIC_FUNCTION_P (cand1->fn)\n \t  && ! DECL_STATIC_FUNCTION_P (cand2->fn))\n@@ -5645,32 +5878,33 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n \n   for (i = 0; i < len; ++i)\n     {\n-      tree t1 = TREE_VEC_ELT (cand1->convs, i+off1);\n-      tree t2 = TREE_VEC_ELT (cand2->convs, i+off2);\n+      conversion *t1 = cand1->convs[i + off1];\n+      conversion *t2 = cand2->convs[i + off2];\n       int comp = compare_ics (t1, t2);\n \n       if (comp != 0)\n \t{\n \t  if (warn_sign_promo\n-\t      && ICS_RANK (t1) + ICS_RANK (t2) == STD_RANK + PROMO_RANK\n-\t      && TREE_CODE (t1) == STD_CONV\n-\t      && TREE_CODE (t2) == STD_CONV\n-\t      && TREE_CODE (TREE_TYPE (t1)) == INTEGER_TYPE\n-\t      && TREE_CODE (TREE_TYPE (t2)) == INTEGER_TYPE\n-\t      && (TYPE_PRECISION (TREE_TYPE (t1))\n-\t\t  == TYPE_PRECISION (TREE_TYPE (t2)))\n-\t      && (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (t1, 0)))\n-\t\t  || (TREE_CODE (TREE_TYPE (TREE_OPERAND (t1, 0)))\n+\t      && (CONVERSION_RANK (t1) + CONVERSION_RANK (t2)\n+\t\t  == cr_std + cr_promotion)\n+\t      && t1->kind == ck_std\n+\t      && t2->kind == ck_std\n+\t      && TREE_CODE (t1->type) == INTEGER_TYPE\n+\t      && TREE_CODE (t2->type) == INTEGER_TYPE\n+\t      && (TYPE_PRECISION (t1->type)\n+\t\t  == TYPE_PRECISION (t2->type))\n+\t      && (TREE_UNSIGNED (t1->u.next->type)\n+\t\t  || (TREE_CODE (t1->u.next->type)\n \t\t      == ENUMERAL_TYPE)))\n \t    {\n-\t      tree type = TREE_TYPE (TREE_OPERAND (t1, 0));\n+\t      tree type = t1->u.next->type;\n \t      tree type1, type2;\n \t      struct z_candidate *w, *l;\n \t      if (comp > 0)\n-\t\ttype1 = TREE_TYPE (t1), type2 = TREE_TYPE (t2),\n+\t\ttype1 = t1->type, type2 = t2->type,\n \t\t  w = cand1, l = cand2;\n \t      else\n-\t\ttype1 = TREE_TYPE (t2), type2 = TREE_TYPE (t1),\n+\t\ttype1 = t2->type, type2 = t1->type,\n \t\t  w = cand2, l = cand1;\n \n \t      if (warn)\n@@ -5731,12 +5965,12 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n \t/*NOP*/;\n       else if (warn)\n \t{\n-\t  tree source = source_type (TREE_VEC_ELT (w->convs, 0));\n+\t  tree source = source_type (w->convs[0]);\n \t  if (! DECL_CONSTRUCTOR_P (w->fn))\n \t    source = TREE_TYPE (source);\n \t  warning (\"choosing `%D' over `%D'\", w->fn, l->fn);\n \t  warning (\"  for conversion from `%T' to `%T'\",\n-\t\t   source, TREE_TYPE (w->second_conv));\n+\t\t   source, w->second_conv->type);\n \t  warning (\"  because conversion sequence for the argument is better\");\n \t}\n       else\n@@ -5773,7 +6007,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n \t    [temp.func.order]: The presence of unused ellipsis and default\n \t    arguments has no effect on the partial ordering of function\n \t    templates.  */\n-         TREE_VEC_LENGTH (cand1->convs)\n+\t cand1->num_convs\n \t - (DECL_NONSTATIC_MEMBER_FUNCTION_P (cand1->fn)\n \t    - DECL_CONSTRUCTOR_P (cand1->fn)));\n       if (winner)\n@@ -5810,10 +6044,10 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n       || TREE_CODE (cand2->fn) == IDENTIFIER_NODE)\n     {\n       for (i = 0; i < len; ++i)\n-\tif (!same_type_p (TREE_TYPE (TREE_VEC_ELT (cand1->convs, i)),\n-\t\t\t  TREE_TYPE (TREE_VEC_ELT (cand2->convs, i))))\n+\tif (!same_type_p (cand1->convs[i]->type,\n+\t\t\t  cand2->convs[i]->type))\n \t  break;\n-      if (i == TREE_VEC_LENGTH (cand1->convs))\n+      if (i == cand1->num_convs)\n \t{\n \t  if (cand1->fn == cand2->fn)\n \t    /* Two built-in candidates; arbitrarily pick one.  */\n@@ -5839,15 +6073,15 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n      worst conversion for the other, take the first.  */\n   if (!pedantic)\n     {\n-      int rank1 = IDENTITY_RANK, rank2 = IDENTITY_RANK;\n+      conversion_rank rank1 = cr_identity, rank2 = cr_identity;\n       struct z_candidate *w = 0, *l = 0;\n \n       for (i = 0; i < len; ++i)\n \t{\n-\t  if (ICS_RANK (TREE_VEC_ELT (cand1->convs, i+off1)) > rank1)\n-\t    rank1 = ICS_RANK (TREE_VEC_ELT (cand1->convs, i+off1));\n-\t  if (ICS_RANK (TREE_VEC_ELT (cand2->convs, i+off2)) > rank2)\n-\t    rank2 = ICS_RANK (TREE_VEC_ELT (cand2->convs, i+off2));\n+\t  if (CONVERSION_RANK (cand1->convs[i+off1]) > rank1)\n+\t    rank1 = CONVERSION_RANK (cand1->convs[i+off1]);\n+\t  if (CONVERSION_RANK (cand2->convs[i + off2]) > rank2)\n+\t    rank2 = CONVERSION_RANK (cand2->convs[i + off2]);\n \t}\n       if (rank1 < rank2)\n \twinner = 1, w = cand1, l = cand2;\n@@ -5942,16 +6176,38 @@ can_convert (tree to, tree from)\n bool\n can_convert_arg (tree to, tree from, tree arg)\n {\n-  tree t = implicit_conversion (to, from, arg, LOOKUP_NORMAL);\n-  return (t && ! ICS_BAD_FLAG (t));\n+  conversion *t;\n+  void *p;\n+  bool ok_p;\n+\n+  /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n+  p = conversion_obstack_alloc (0);\n+\n+  t  = implicit_conversion (to, from, arg, LOOKUP_NORMAL);\n+  ok_p = (t && !t->bad_p);\n+\n+  /* Free all the conversions we allocated.  */\n+  obstack_free (&conversion_obstack, p);\n+\n+  return ok_p;\n }\n \n /* Like can_convert_arg, but allows dubious conversions as well.  */\n \n bool\n can_convert_arg_bad (tree to, tree from, tree arg)\n {\n-  return implicit_conversion (to, from, arg, LOOKUP_NORMAL) != 0;\n+  conversion *t;\n+  void *p;\n+\n+  /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n+  p = conversion_obstack_alloc (0);\n+  /* Try to perform the conversion.  */\n+  t  = implicit_conversion (to, from, arg, LOOKUP_NORMAL);\n+  /* Free all the conversions we allocated.  */\n+  obstack_free (&conversion_obstack, p);\n+\n+  return t != NULL;\n }\n \n /* Convert EXPR to TYPE.  Return the converted expression.\n@@ -5963,19 +6219,29 @@ can_convert_arg_bad (tree to, tree from, tree arg)\n tree\n perform_implicit_conversion (tree type, tree expr)\n {\n-  tree conv;\n-  \n+  conversion *conv;\n+  void *p;\n+\n   if (error_operand_p (expr))\n     return error_mark_node;\n+\n+  /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n+  p = conversion_obstack_alloc (0);\n+\n   conv = implicit_conversion (type, TREE_TYPE (expr), expr,\n \t\t\t      LOOKUP_NORMAL);\n   if (!conv)\n     {\n       error (\"could not convert `%E' to `%T'\", expr, type);\n-      return error_mark_node;\n+      expr = error_mark_node;\n     }\n+  else\n+    expr = convert_like (conv, expr);\n+\n+  /* Free all the conversions we allocated.  */\n+  obstack_free (&conversion_obstack, p);\n \n-  return convert_like (conv, expr);\n+  return expr;\n }\n \n /* Convert EXPR to TYPE (as a direct-initialization) if that is\n@@ -5986,8 +6252,9 @@ perform_implicit_conversion (tree type, tree expr)\n tree\n perform_direct_initialization_if_possible (tree type, tree expr)\n {\n-  tree conv;\n-  \n+  conversion *conv;\n+  void *p;\n+\n   if (type == error_mark_node || error_operand_p (expr))\n     return error_mark_node;\n   /* [dcl.init]\n@@ -6006,12 +6273,22 @@ perform_direct_initialization_if_possible (tree type, tree expr)\n \t\t\t\t\tLOOKUP_NORMAL);\n       return build_cplus_new (type, expr);\n     }\n+\n+  /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n+  p = conversion_obstack_alloc (0);\n+\n   conv = implicit_conversion (type, TREE_TYPE (expr), expr,\n \t\t\t      LOOKUP_NORMAL);\n-  if (!conv || ICS_BAD_FLAG (conv))\n-    return NULL_TREE;\n-  return convert_like_real (conv, expr, NULL_TREE, 0, 0, \n-\t\t\t    /*issue_conversion_warnings=*/false);\n+  if (!conv || conv->bad_p)\n+    expr = NULL_TREE;\n+  else\n+    expr = convert_like_real (conv, expr, NULL_TREE, 0, 0, \n+\t\t\t      /*issue_conversion_warnings=*/false);\n+\n+  /* Free all the conversions we allocated.  */\n+  obstack_free (&conversion_obstack, p);\n+\n+  return expr;\n }\n \n /* DECL is a VAR_DECL whose type is a REFERENCE_TYPE.  The reference\n@@ -6066,13 +6343,17 @@ make_temporary_var_for_ref_to_temp (tree decl, tree type)\n tree\n initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n {\n-  tree conv;\n+  conversion *conv;\n+  void *p;\n \n   if (type == error_mark_node || error_operand_p (expr))\n     return error_mark_node;\n \n+  /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n+  p = conversion_obstack_alloc (0);\n+\n   conv = reference_binding (type, TREE_TYPE (expr), expr, LOOKUP_NORMAL);\n-  if (!conv || ICS_BAD_FLAG (conv))\n+  if (!conv || conv->bad_p)\n     {\n       if (!(TYPE_QUALS (TREE_TYPE (type)) & TYPE_QUAL_CONST)\n           && !real_lvalue_p (expr))\n@@ -6120,28 +6401,28 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n \n     we can extend the lifetime of the return value of the conversion\n     operator.  */\n-  my_friendly_assert (TREE_CODE (conv) == REF_BIND, 20030302);\n+  my_friendly_assert (conv->kind == ck_ref_bind, 20030302);\n   if (decl)\n     {\n       tree var;\n       tree base_conv_type;\n \n       /* Skip over the REF_BIND.  */\n-      conv = TREE_OPERAND (conv, 0);\n+      conv = conv->u.next;\n       /* If the next conversion is a BASE_CONV, skip that too -- but\n \t remember that the conversion was required.  */\n-      if (TREE_CODE (conv) == BASE_CONV && !NEED_TEMPORARY_P (conv))\n+      if (conv->kind == ck_base && conv->need_temporary_p)\n \t{\n \t  void (*diagnostic_fn) (const char *, ...);\n-\t  if (CHECK_COPY_CONSTRUCTOR_P (conv))\n+\t  if (conv->check_copy_constructor_p)\n \t    /* Generate a temporary copy purely to generate the required\n \t       diagnostics.  */\n \t    build_temp (build_dummy_object (TREE_TYPE (expr)),\n \t\t\tTREE_TYPE (expr),\n \t\t\tLOOKUP_NORMAL|LOOKUP_ONLYCONVERTING,\n \t\t\t&diagnostic_fn);\n-\t  base_conv_type = TREE_TYPE (conv);\n-\t  conv = TREE_OPERAND (conv, 0);\n+\t  base_conv_type = conv->type;\n+\t  conv = conv->u.next;\n \t}\n       else\n \tbase_conv_type = NULL_TREE;\n@@ -6205,11 +6486,16 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n       if (base_conv_type)\n \texpr = (perform_implicit_conversion \n \t\t(build_pointer_type (base_conv_type), expr));\n-      return build_nop (type, expr);\n+      expr = build_nop (type, expr);\n     }\n+  else\n+    /* Perform the conversion.  */\n+    expr = convert_like (conv, expr);\n+  \n+  /* Free all the conversions we allocated.  */\n+  obstack_free (&conversion_obstack, p);\n \n-  /* Perform the conversion.  */\n-  return convert_like (conv, expr);\n+  return expr;\n }\n \n #include \"gt-cp-call.h\""}, {"sha": "f30f0ffc03af4ee7c91dc5d2fdc2ce147b26310d", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bd61841e40632387d9ec3ab809f6a0f715181bf/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bd61841e40632387d9ec3ab809f6a0f715181bf/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=5bd61841e40632387d9ec3ab809f6a0f715181bf", "patch": "@@ -365,7 +365,6 @@ cp_tree_size (enum tree_code code)\n     case TEMPLATE_PARM_INDEX: \treturn sizeof (template_parm_index);\n     case DEFAULT_ARG:\t\treturn sizeof (struct tree_default_arg);\n     case OVERLOAD:\t\treturn sizeof (struct tree_overload);\n-    case WRAPPER:\t\treturn sizeof (struct tree_wrapper);\n     default:\n       abort ();\n     }"}, {"sha": "ebe64f2bd201eae54c8d92b4b0f27fe448fd55f8", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bd61841e40632387d9ec3ab809f6a0f715181bf/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bd61841e40632387d9ec3ab809f6a0f715181bf/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=5bd61841e40632387d9ec3ab809f6a0f715181bf", "patch": "@@ -217,10 +217,6 @@ DEFTREECODE (TEMPLATE_ID_EXPR, \"template_id_expr\", 'e', 2)\n    the original name, and the parameter is the FUNCTION_DECL.  */\n DEFTREECODE (OVERLOAD, \"overload\", 'x', 0)\n \n-/* A generic wrapper for something not tree that we want to include in\n-   tree structure.  */\n-DEFTREECODE (WRAPPER, \"wrapper\", 'x', 0)\n-\n /* A whole bunch of tree codes for the initial, superficial parsing of\n    templates.  */\n DEFTREECODE (MODOP_EXPR, \"modop_expr\", 'e', 3)\n@@ -261,26 +257,6 @@ DEFTREECODE (MUST_NOT_THROW_EXPR, \"must_not_throw_expr\", 'e', 1)\n \n DEFTREECODE (TAG_DEFN, \"tag_defn\", 'e', 0)\n \n-/* The following codes are used to represent implicit conversion\n-   sequences, in the sense of [over.best.ics].  The conversion\n-   sequences are connected through their first operands, with the\n-   first conversion to be performed at the end of the chain.\n-\n-   The innermost conversion (i.e, the one at the end of the chain) is\n-   always an IDENTITY_CONV, corresponding to the identity conversion.  */\n-\n-DEFTREECODE (IDENTITY_CONV, \"identity_conv\", 'e', 1)\n-DEFTREECODE (LVALUE_CONV, \"lvalue_conv\", 'e', 1)\n-DEFTREECODE (QUAL_CONV, \"qual_conv\", 'e', 1)\n-DEFTREECODE (STD_CONV, \"std_conv\", 'e', 1)\n-DEFTREECODE (PTR_CONV, \"ptr_conv\", 'e', 1)\n-DEFTREECODE (PMEM_CONV, \"pmem_conv\", 'e', 1)\n-DEFTREECODE (BASE_CONV, \"base_conv\", 'e', 1)\n-DEFTREECODE (REF_BIND, \"ref_bind\", 'e', 1)\n-DEFTREECODE (USER_CONV, \"user_conv\", 'e', 2)\n-DEFTREECODE (AMBIG_CONV, \"ambig_conv\", 'e', 1)\n-DEFTREECODE (RVALUE_CONV, \"rvalue_conv\", 'e', 1)\n-\n /*\n Local variables:\n mode:c"}, {"sha": "ce826afad903192c980553c312ccfdd95a05019c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bd61841e40632387d9ec3ab809f6a0f715181bf/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bd61841e40632387d9ec3ab809f6a0f715181bf/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5bd61841e40632387d9ec3ab809f6a0f715181bf", "patch": "@@ -73,7 +73,6 @@ struct diagnostic_context;\n    4: BINFO_NEW_VTABLE_MARKED.\n       TREE_HAS_CONSTRUCTOR (in INDIRECT_REF, SAVE_EXPR, CONSTRUCTOR,\n           or FIELD_DECL).\n-      NEED_TEMPORARY_P (in REF_BIND, BASE_CONV)\n       IDENTIFIER_TYPENAME_P (in IDENTIFIER_NODE)\n    5: C_IS_RESERVED_WORD (in IDENTIFIER_NODE)\n       DECL_VTABLE_OR_VTT_P (in VAR_DECL)\n@@ -346,14 +345,6 @@ struct tree_baselink GTY(())\n   tree access_binfo;\n };\n \n-#define WRAPPER_ZC(NODE) (((struct tree_wrapper*)WRAPPER_CHECK (NODE))->z_c)\n-\n-struct tree_wrapper GTY(())\n-{\n-  struct tree_common common;\n-  struct z_candidate *z_c;\n-};\n-\n /* The different kinds of ids that we ecounter.  */\n \n typedef enum cp_id_kind\n@@ -484,7 +475,6 @@ union lang_tree_node GTY((desc (\"cp_tree_node_structure (&%h)\"),\n   struct ptrmem_cst GTY ((tag (\"TS_CP_PTRMEM\"))) ptrmem;\n   struct tree_overload GTY ((tag (\"TS_CP_OVERLOAD\"))) overload;\n   struct tree_baselink GTY ((tag (\"TS_CP_BASELINK\"))) baselink;\n-  struct tree_wrapper GTY ((tag (\"TS_CP_WRAPPER\"))) wrapper;\n   struct tree_default_arg GTY ((tag (\"TS_CP_DEFAULT_ARG\"))) default_arg;\n   struct lang_identifier GTY ((tag (\"TS_CP_IDENTIFIER\"))) identifier;\n };\n@@ -3316,9 +3306,6 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n      direct-initialization in cases where other parts of the compiler have\n      already generated a temporary, such as reference initialization and the\n      catch parameter.\n-   LOOKUP_SPECULATIVELY means return NULL_TREE if we cannot find what we are\n-     after.  Note, LOOKUP_COMPLAIN is checked and error messages printed\n-     before LOOKUP_SPECULATIVELY is checked.\n    LOOKUP_NO_CONVERSION means that user-defined conversions are not\n      permitted.  Built-in conversions are permitted.\n    LOOKUP_DESTRUCTOR means explicit call to destructor.\n@@ -3336,7 +3323,6 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n #define LOOKUP_NORMAL (3)\n #define LOOKUP_NONVIRTUAL (8)\n #define LOOKUP_GLOBAL (16)\n-#define LOOKUP_SPECULATIVELY (64)\n #define LOOKUP_ONLYCONVERTING (128)\n #define DIRECT_BIND (256)\n #define LOOKUP_NO_CONVERSION (512)\n@@ -3521,7 +3507,7 @@ extern tree build_operator_new_call (tree, tree, tree *, tree *);\n extern tree build_new_method_call (tree, tree, tree, tree, int);\n extern tree build_special_member_call (tree, tree, tree, tree, int);\n extern tree build_new_op (enum tree_code, int, tree, tree, tree);\n-extern tree build_op_delete_call (enum tree_code, tree, tree, int, tree);\n+extern tree build_op_delete_call (enum tree_code, tree, tree, bool, tree);\n extern bool can_convert (tree, tree);\n extern bool can_convert_arg (tree, tree, tree);\n extern bool can_convert_arg_bad (tree, tree, tree);\n@@ -3541,6 +3527,9 @@ extern tree perform_implicit_conversion (tree, tree);\n extern tree perform_direct_initialization_if_possible (tree, tree);\n extern tree in_charge_arg_for_name (tree);\n extern tree build_cxx_call (tree, tree, tree);\n+#ifdef ENABLE_CHECKING\n+extern void validate_conversion_obstack (void);\n+#endif /* ENABLE_CHECKING */\n \n /* in class.c */\n extern tree build_base_path\t\t\t(enum tree_code, tree, tree, int);\n@@ -4143,7 +4132,6 @@ extern tree vec_binfo_member\t\t\t(tree, tree);\n extern tree decl_namespace_context\t\t(tree);\n extern tree lvalue_type\t\t\t\t(tree);\n extern tree error_type\t\t\t\t(tree);\n-extern tree build_zc_wrapper\t\t\t(struct z_candidate *);\n extern int varargs_function_p\t\t\t(tree);\n extern int really_overloaded_fn\t\t\t(tree);\n extern bool cp_tree_equal\t\t\t(tree, tree);"}, {"sha": "37839d712f8e7b892b21b0eb4a2d741228b1cb8e", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bd61841e40632387d9ec3ab809f6a0f715181bf/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bd61841e40632387d9ec3ab809f6a0f715181bf/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=5bd61841e40632387d9ec3ab809f6a0f715181bf", "patch": "@@ -552,9 +552,6 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n   if (flags & LOOKUP_COMPLAIN)\n     error (\"cannot convert type `%T' to type `%T'\", intype, reftype);\n \n-  if (flags & LOOKUP_SPECULATIVELY)\n-    return NULL_TREE;\n-\n   return error_mark_node;\n }\n \n@@ -689,8 +686,6 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t    return rval;\n \t  if (flags & LOOKUP_COMPLAIN)\n \t    error (\"`%#T' used where a `%T' was expected\", intype, type);\n-\t  if (flags & LOOKUP_SPECULATIVELY)\n-\t    return NULL_TREE;\n \t  return error_mark_node;\n \t}\n       if (code == BOOLEAN_TYPE)\n@@ -761,8 +756,6 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n   if (flags & LOOKUP_COMPLAIN)\n     error (\"conversion from `%T' to non-scalar type `%T' requested\",\n \t      TREE_TYPE (expr), type);\n-  if (flags & LOOKUP_SPECULATIVELY)\n-    return NULL_TREE;\n   return error_mark_node;\n }\n "}, {"sha": "bb6ef73c8978c881afccbec7fcc13fb91f857af4", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bd61841e40632387d9ec3ab809f6a0f715181bf/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bd61841e40632387d9ec3ab809f6a0f715181bf/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5bd61841e40632387d9ec3ab809f6a0f715181bf", "patch": "@@ -2028,16 +2028,31 @@ redeclaration_error_message (tree newdecl, tree olddecl)\n     }\n   else if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n     {\n-      if ((TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == FUNCTION_DECL\n-\t   && (DECL_TEMPLATE_RESULT (newdecl)\n-\t       != DECL_TEMPLATE_RESULT (olddecl))\n-\t   && DECL_INITIAL (DECL_TEMPLATE_RESULT (newdecl))\n-\t   && DECL_INITIAL (DECL_TEMPLATE_RESULT (olddecl)))\n-\t  || (TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL\n-\t      && COMPLETE_TYPE_P (TREE_TYPE (newdecl))\n-\t      && COMPLETE_TYPE_P (TREE_TYPE (olddecl))))\n+      tree nt, ot;\n+\n+      if (TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL)\n+\t{\n+\t  if (COMPLETE_TYPE_P (TREE_TYPE (newdecl))\n+\t      && COMPLETE_TYPE_P (TREE_TYPE (olddecl)))\n+\t    return \"redefinition of `%#D'\";\n+\t  return NULL;\n+\t}\n+\n+      if (TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) != FUNCTION_DECL\n+\t  || (DECL_TEMPLATE_RESULT (newdecl) \n+\t      == DECL_TEMPLATE_RESULT (olddecl)))\n+\treturn NULL;\n+\n+      nt = DECL_TEMPLATE_RESULT (newdecl);\n+      if (DECL_TEMPLATE_INFO (nt))\n+\tnt = DECL_TEMPLATE_RESULT (template_for_substitution (nt));\n+      ot = DECL_TEMPLATE_RESULT (olddecl);\n+      if (DECL_TEMPLATE_INFO (ot))\n+\tot = DECL_TEMPLATE_RESULT (template_for_substitution (ot));\n+      if (DECL_INITIAL (nt) && DECL_INITIAL (ot))\n \treturn \"redefinition of `%#D'\";\n-      return 0;\n+\n+      return NULL;\n     }\n   else if (toplevel_bindings_p () || DECL_NAMESPACE_SCOPE_P (newdecl))\n     {\n@@ -10606,8 +10621,8 @@ finish_destructor_body (void)\n       be looked up in the scope of the destructor's class and if\n       found shall be accessible and unambiguous.  */\n       exprstmt = build_op_delete_call\n-\t(DELETE_EXPR, current_class_ptr, virtual_size,\n-\t LOOKUP_NORMAL | LOOKUP_SPECULATIVELY, NULL_TREE);\n+\t(DELETE_EXPR, current_class_ptr, virtual_size, \n+\t /*global_p=*/false, NULL_TREE);\n \n       if_stmt = begin_if_stmt ();\n       finish_if_stmt_cond (build (BIT_AND_EXPR, integer_type_node,\n@@ -11218,7 +11233,6 @@ cp_tree_node_structure (union lang_tree_node * t)\n     case TEMPLATE_PARM_INDEX:\treturn TS_CP_TPI;\n     case PTRMEM_CST:\t\treturn TS_CP_PTRMEM;\n     case BASELINK:              return TS_CP_BASELINK;\n-    case WRAPPER:\t\treturn TS_CP_WRAPPER;\n     default:\t\t\treturn TS_CP_GENERIC;\n     }\n }"}, {"sha": "07acd139f327453b69ac574522e37566abafd6d6", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bd61841e40632387d9ec3ab809f6a0f715181bf/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bd61841e40632387d9ec3ab809f6a0f715181bf/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=5bd61841e40632387d9ec3ab809f6a0f715181bf", "patch": "@@ -2884,6 +2884,10 @@ finish_file (void)\n       dump_time_statistics ();\n     }\n   input_location = locus;\n+\n+#ifdef ENABLE_CHECKING\n+  validate_conversion_obstack ();\n+#endif /* ENABLE_CHECKING */\n }\n \n /* FN is an OFFSET_REF, DOTSTAR_EXPR or MEMBER_REF indicating the"}, {"sha": "0065244d89ed786b0a8843b71746322ee3d5b4ab", "filename": "gcc/cp/init.c", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bd61841e40632387d9ec3ab809f6a0f715181bf/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bd61841e40632387d9ec3ab809f6a0f715181bf/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=5bd61841e40632387d9ec3ab809f6a0f715181bf", "patch": "@@ -2232,15 +2232,12 @@ build_new_1 (tree exp)\n \t{\n \t  enum tree_code dcode = has_array ? VEC_DELETE_EXPR : DELETE_EXPR;\n \t  tree cleanup;\n-\t  int flags = (LOOKUP_NORMAL \n-\t\t       | (globally_qualified_p * LOOKUP_GLOBAL));\n \n \t  /* The Standard is unclear here, but the right thing to do\n \t     is to use the same method for finding deallocation\n \t     functions that we use for finding allocation functions.  */\n-\t  flags |= LOOKUP_SPECULATIVELY;\n-\n-\t  cleanup = build_op_delete_call (dcode, alloc_node, size, flags,\n+\t  cleanup = build_op_delete_call (dcode, alloc_node, size, \n+\t\t\t\t\t  globally_qualified_p,\n \t\t\t\t\t  (placement_allocation_fn_p \n \t\t\t\t\t   ? alloc_call : NULL_TREE));\n \n@@ -2790,9 +2787,9 @@ build_x_delete (tree addr, int which_delete, tree virtual_size)\n   int use_global_delete = which_delete & 1;\n   int use_vec_delete = !!(which_delete & 2);\n   enum tree_code code = use_vec_delete ? VEC_DELETE_EXPR : DELETE_EXPR;\n-  int flags = LOOKUP_NORMAL | (use_global_delete * LOOKUP_GLOBAL);\n \n-  return build_op_delete_call (code, addr, virtual_size, flags, NULL_TREE);\n+  return build_op_delete_call (code, addr, virtual_size, use_global_delete, \n+\t\t\t       NULL_TREE);\n }\n \n /* Call the DTOR_KIND destructor for EXP.  FLAGS are as for\n@@ -2923,8 +2920,7 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n \treturn void_zero_node;\n \n       return build_op_delete_call\n-\t(DELETE_EXPR, addr, cxx_sizeof_nowarn (type),\n-\t LOOKUP_NORMAL | (use_global_delete * LOOKUP_GLOBAL),\n+\t(DELETE_EXPR, addr, cxx_sizeof_nowarn (type), use_global_delete,\n \t NULL_TREE);\n     }\n   else\n@@ -2959,7 +2955,7 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n \t  do_delete = build_op_delete_call (DELETE_EXPR,\n \t\t\t\t\t    addr,\n \t\t\t\t\t    cxx_sizeof_nowarn (type),\n-\t\t\t\t\t    LOOKUP_NORMAL,\n+\t\t\t\t\t    /*global_p=*/false,\n \t\t\t\t\t    NULL_TREE);\n \t  /* Call the complete object destructor.  */\n \t  auto_delete = sfk_complete_destructor;\n@@ -2970,7 +2966,7 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n \t  /* Make sure we have access to the member op delete, even though\n \t     we'll actually be calling it from the destructor.  */\n \t  build_op_delete_call (DELETE_EXPR, addr, cxx_sizeof_nowarn (type),\n-\t\t\t\tLOOKUP_NORMAL, NULL_TREE);\n+\t\t\t\t/*global_p=*/false, NULL_TREE);\n \t}\n \n       expr = build_dtor_call (build_indirect_ref (addr, NULL),"}, {"sha": "085fdbd81608cb0f31df1ac425405768e58f2659", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bd61841e40632387d9ec3ab809f6a0f715181bf/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bd61841e40632387d9ec3ab809f6a0f715181bf/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5bd61841e40632387d9ec3ab809f6a0f715181bf", "patch": "@@ -5009,21 +5009,20 @@ tsubst_friend_function (tree decl, tree args)\n \t duplicate decls since that function will free NEW_FRIEND if\n \t possible.  */\n       new_friend_template_info = DECL_TEMPLATE_INFO (new_friend);\n+      new_friend_is_defn =\n+\t    (DECL_INITIAL (DECL_TEMPLATE_RESULT \n+\t\t\t   (template_for_substitution (new_friend)))\n+\t     != NULL_TREE);\n       if (TREE_CODE (new_friend) == TEMPLATE_DECL)\n \t{\n \t  /* This declaration is a `primary' template.  */\n \t  DECL_PRIMARY_TEMPLATE (new_friend) = new_friend;\n \t  \n-\t  new_friend_is_defn \n-\t    = DECL_INITIAL (DECL_TEMPLATE_RESULT (new_friend)) != NULL_TREE;\n \t  new_friend_result_template_info\n \t    = DECL_TEMPLATE_INFO (DECL_TEMPLATE_RESULT (new_friend));\n \t}\n       else\n-\t{\n-\t  new_friend_is_defn = DECL_INITIAL (new_friend) != NULL_TREE;\n-\t  new_friend_result_template_info = NULL_TREE;\n-\t}\n+\tnew_friend_result_template_info = NULL_TREE;\n \n       /* Inside pushdecl_namespace_level, we will push into the\n \t current namespace. However, the friend function should go\n@@ -6163,7 +6162,7 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n \t/* Clear out the mangled name and RTL for the instantiation.  */\n \tSET_DECL_ASSEMBLER_NAME (r, NULL_TREE);\n \tSET_DECL_RTL (r, NULL_RTX);\n-\n+\tDECL_INITIAL (r) = NULL_TREE;\n \tDECL_CONTEXT (r) = ctx;\n \n \tif (member && DECL_CONV_FN_P (r)) "}, {"sha": "8cba3d633a2fd16fe655d58c31e9787cba8d1fd4", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bd61841e40632387d9ec3ab809f6a0f715181bf/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bd61841e40632387d9ec3ab809f6a0f715181bf/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=5bd61841e40632387d9ec3ab809f6a0f715181bf", "patch": "@@ -1641,17 +1641,6 @@ cp_tree_equal (tree t1, tree t2)\n   return false;\n }\n \n-/* Build a wrapper around a 'struct z_candidate' so we can use it as a\n-   tree.  */\n-\n-tree\n-build_zc_wrapper (struct z_candidate* ptr)\n-{\n-  tree t = make_node (WRAPPER);\n-  WRAPPER_ZC (t) = ptr;\n-  return t;\n-}\n-\n /* The type of ARG when used as an lvalue.  */\n \n tree"}]}