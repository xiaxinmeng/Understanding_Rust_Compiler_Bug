{"sha": "7d1d3a546409ce9e4aedb3b8d537cc770beabd62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2QxZDNhNTQ2NDA5Y2U5ZTRhZWRiM2I4ZDUzN2NjNzcwYmVhYmQ2Mg==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2018-06-11T09:19:30Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-06-11T09:19:30Z"}, "message": "[Ada] Double finalization of limited controlled result\n\nThis patch disables a build-in-place optimization when a function returns a\nlimited controlled result because the optimization may violate the semantics of\nfinalizable types by performing illegal calls to Finalize.\n\nIn general, the optimization causes the result object of a build-in-place\nfunction to be allocated at the caller site, with a pointer to the object\npassed to the function. The function then simply initializes the caller-\nallocated object.\n\nThis mode of operation however violates semantics of finalizable types when\nthe context of the call is allocation. The act of allocating the controlled\nobject at the caller site will place it on the associated access type's\nfinalization master. If the function fails the initialization of the object,\nthe malformed object will still be finalized when the finalization master\ngoes out of scope. This is dangerous, and must not happen.\n\n------------\n-- Source --\n------------\n\n--  pack.ads\n\nwith Ada.Finalization; use Ada.Finalization;\n\npackage Pack is\n   type Lim_Ctrl is new Limited_Controlled with null record;\n   procedure Finalize (Obj : in out Lim_Ctrl);\n\n   type Lim_Ctrl_Ptr is access all Lim_Ctrl;\n\n   function Make_Lim_Ctrl_Bad_Init return Lim_Ctrl;\n   function Make_Lim_Ctrl_OK_Init return Lim_Ctrl;\nend Pack;\n\n--  pack.adb\n\nwith Ada.Text_IO; use Ada.Text_IO;\n\npackage body Pack is\n   procedure Finalize (Obj : in out Lim_Ctrl) is\n   begin\n      Put_Line (\"     Finalize\");\n   end Finalize;\n\n   function Make_Lim_Ctrl_Bad_Init return Lim_Ctrl is\n   begin\n      return Result : Lim_Ctrl := raise Program_Error do\n         null;\n      end return;\n   end Make_Lim_Ctrl_Bad_Init;\n\n   function Make_Lim_Ctrl_OK_Init return Lim_Ctrl is\n   begin\n      return Result : Lim_Ctrl do\n         raise Program_Error;\n      end return;\n   end Make_Lim_Ctrl_OK_Init;\nend Pack;\n\n--  main.adb\n\nwith Ada.Text_IO; use Ada.Text_IO;\nwith Pack;        use Pack;\n\nprocedure Main is\nbegin\n   begin\n      Put_Line (\"1) Heap-allocated bad init\");\n\n      declare\n         Obj : Lim_Ctrl_Ptr := new Lim_Ctrl'(Make_Lim_Ctrl_Bad_Init);\n      begin\n         Put_Line (\"1) ERROR: Heap-allocated bad init: exception not raised\");\n      end;\n\n   exception\n      when Program_Error =>\n         Put_Line (\"1) Heap-allocated bad init: Program_Error raised\");\n      when others =>\n         Put_Line (\"1) ERROR: Heap-allocatd bad init: unexpected exception\");\n   end;\n\n   begin\n      Put_Line (\"2) Stack-allocated bad init\");\n\n      declare\n         Obj : Lim_Ctrl := Make_Lim_Ctrl_Bad_Init;\n      begin\n         Put_Line (\"2) ERROR: Stack-allocated bad init: exception not raised\");\n      end;\n\n   exception\n      when Program_Error =>\n         Put_Line (\"2) Stack-allocated bad init: Program_Error raised\");\n      when others =>\n         Put_Line (\"2) ERROR: Stack-allocated bad init: unexpected exception\");\n   end;\n\n   begin\n      Put_Line (\"3) Heap-allocated OK init\");\n\n      declare\n         Obj : Lim_Ctrl_Ptr := new Lim_Ctrl'(Make_Lim_Ctrl_OK_Init);\n      begin\n         Put_Line (\"3) ERROR: Heap-allocated OK init: exception not raised\");\n      end;\n\n   exception\n      when Program_Error =>\n         Put_Line (\"3) Heap-allocated OK init: Program_Error raised\");\n      when others =>\n         Put_Line (\"3) ERROR: Heap-allocatd OK init: unexpected exception\");\n   end;\n\n   begin\n      Put_Line (\"4) Stack-allocated OK init\");\n\n      declare\n         Obj : Lim_Ctrl := Make_Lim_Ctrl_OK_Init;\n      begin\n         Put_Line (\"4) ERROR: Stack-allocated OK init: exception not raised\");\n      end;\n\n   exception\n      when Program_Error =>\n         Put_Line (\"4) Stack-allocated OK init: Program_Error raised\");\n      when others =>\n         Put_Line (\"4) ERROR: Stack-allocated OK init: unexpected exception\");\n   end;\nend Main;\n\n----------------------------\n-- Compilation and output --\n----------------------------\n\n$ gnatmake -q main.adb\n$ ./main\n1) Heap-allocated bad init\n1) Heap-allocated bad init: Program_Error raised\n2) Stack-allocated bad init\n2) Stack-allocated bad init: Program_Error raised\n3) Heap-allocated OK init\n     Finalize\n3) Heap-allocated OK init: Program_Error raised\n4) Stack-allocated OK init\n     Finalize\n4) Stack-allocated OK init: Program_Error raised\n\n2018-06-11  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch6.adb (Add_Unconstrained_Actuals_To_Build_In_Place_Call): Do\n\tnot add any actuals when the size of the object is known, and the\n\tcaller will allocate it.\n\t(Build_Heap_Allocator): Rename to Build_Heap_Or_Pool_Allocator to\n\tbetter illustrate its functionality. Update the comment on the\n\tgenerated code.  Generate a branch for the heap and pool cases where\n\tthe object is not necessarity controlled.\n\t(Expand_N_Extended_Return_Statement): Expand the extended return\n\tstatement into four branches depending the requested mode if the caller\n\twill not allocate the object on its side.\n\t(Make_Build_In_Place_Call_In_Allocator): Do not allocate a controlled\n\tobject on the caller side because this will violate the semantics of\n\tfinalizable types. Instead notify the function to allocate the object\n\ton the heap or a user-defined storage pool.\n\t(Needs_BIP_Alloc_Form): A build-in-place function needs to be notified\n\twhich of the four modes to employ when returning a limited controlled\n\tresult.\n\t* exp_util.adb (Build_Allocate_Deallocate_Proc): Remove a redundant\n\tguard which is already covered in Needs_Finalization.\n\nFrom-SVN: r261427", "tree": {"sha": "1d865570cb207f112015c1a363d5a1cc63701c4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d865570cb207f112015c1a363d5a1cc63701c4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d1d3a546409ce9e4aedb3b8d537cc770beabd62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d1d3a546409ce9e4aedb3b8d537cc770beabd62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d1d3a546409ce9e4aedb3b8d537cc770beabd62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d1d3a546409ce9e4aedb3b8d537cc770beabd62/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "557b744a6e41a13dd44770dc64e19a34a32092c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/557b744a6e41a13dd44770dc64e19a34a32092c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/557b744a6e41a13dd44770dc64e19a34a32092c5"}], "stats": {"total": 608, "additions": 337, "deletions": 271}, "files": [{"sha": "517494098985296d6fd13d645fc52f87704ae447", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1d3a546409ce9e4aedb3b8d537cc770beabd62/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1d3a546409ce9e4aedb3b8d537cc770beabd62/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7d1d3a546409ce9e4aedb3b8d537cc770beabd62", "patch": "@@ -1,3 +1,25 @@\n+2018-06-11  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch6.adb (Add_Unconstrained_Actuals_To_Build_In_Place_Call): Do\n+\tnot add any actuals when the size of the object is known, and the\n+\tcaller will allocate it.\n+\t(Build_Heap_Allocator): Rename to Build_Heap_Or_Pool_Allocator to\n+\tbetter illustrate its functionality. Update the comment on the\n+\tgenerated code.  Generate a branch for the heap and pool cases where\n+\tthe object is not necessarity controlled.\n+\t(Expand_N_Extended_Return_Statement): Expand the extended return\n+\tstatement into four branches depending the requested mode if the caller\n+\twill not allocate the object on its side.\n+\t(Make_Build_In_Place_Call_In_Allocator): Do not allocate a controlled\n+\tobject on the caller side because this will violate the semantics of\n+\tfinalizable types. Instead notify the function to allocate the object\n+\ton the heap or a user-defined storage pool.\n+\t(Needs_BIP_Alloc_Form): A build-in-place function needs to be notified\n+\twhich of the four modes to employ when returning a limited controlled\n+\tresult.\n+\t* exp_util.adb (Build_Allocate_Deallocate_Proc): Remove a redundant\n+\tguard which is already covered in Needs_Finalization.\n+\n 2018-06-11  Olivier Hainque  <hainque@adacore.com>\n \n \t* libgnat/s-excmac*.ads: Factorize Unwind_Action definitions ..."}, {"sha": "9ddf0fa038199cb39fdba3ed4d9a12afc70498f4", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 314, "deletions": 264, "changes": 578, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1d3a546409ce9e4aedb3b8d537cc770beabd62/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1d3a546409ce9e4aedb3b8d537cc770beabd62/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=7d1d3a546409ce9e4aedb3b8d537cc770beabd62", "patch": "@@ -336,22 +336,18 @@ package body Exp_Ch6 is\n       Alloc_Form_Exp : Node_Id             := Empty;\n       Pool_Actual    : Node_Id             := Make_Null (No_Location))\n    is\n-      Loc               : constant Source_Ptr := Sloc (Function_Call);\n+      Loc : constant Source_Ptr := Sloc (Function_Call);\n+\n       Alloc_Form_Actual : Node_Id;\n       Alloc_Form_Formal : Node_Id;\n       Pool_Formal       : Node_Id;\n \n    begin\n-      --  The allocation form generally doesn't need to be passed in the case\n-      --  of a constrained result subtype, since normally the caller performs\n-      --  the allocation in that case. However this formal is still needed in\n-      --  the case where the function has a tagged result, because generally\n-      --  such functions can be called in a dispatching context and such calls\n-      --  must be handled like calls to class-wide functions.\n-\n-      if Is_Constrained (Underlying_Type (Etype (Function_Id)))\n-        and then not Is_Tagged_Type (Underlying_Type (Etype (Function_Id)))\n-      then\n+      --  Nothing to do when the size of the object is known, and the caller is\n+      --  in charge of allocating it, and the callee doesn't unconditionally\n+      --  require an allocation form (such as due to having a tagged result).\n+\n+      if not Needs_BIP_Alloc_Form (Function_Id) then\n          return;\n       end if;\n \n@@ -382,8 +378,8 @@ package body Exp_Ch6 is\n       Add_Extra_Actual_To_Call\n         (Function_Call, Alloc_Form_Formal, Alloc_Form_Actual);\n \n-      --  Pass the Storage_Pool parameter. This parameter is omitted on\n-      --  ZFP as those targets do not support pools.\n+      --  Pass the Storage_Pool parameter. This parameter is omitted on ZFP as\n+      --  those targets do not support pools.\n \n       if RTE_Available (RE_Root_Storage_Pool_Ptr) then\n          Pool_Formal := Build_In_Place_Formal (Function_Id, BIP_Storage_Pool);\n@@ -4488,38 +4484,46 @@ package body Exp_Ch6 is\n    --  That is, we need to have a reified return object if there are statements\n    --  (which might refer to it) or if we're doing build-in-place (so we can\n    --  set its address to the final resting place or if there is no expression\n-   --  (in which case default initial values might need to be set).\n+   --  (in which case default initial values might need to be set)).\n \n    procedure Expand_N_Extended_Return_Statement (N : Node_Id) is\n       Loc : constant Source_Ptr := Sloc (N);\n \n-      function Build_Heap_Allocator\n+      function Build_Heap_Or_Pool_Allocator\n         (Temp_Id    : Entity_Id;\n          Temp_Typ   : Entity_Id;\n          Func_Id    : Entity_Id;\n          Ret_Typ    : Entity_Id;\n          Alloc_Expr : Node_Id) return Node_Id;\n       --  Create the statements necessary to allocate a return object on the\n-      --  caller's master. The master is available through implicit parameter\n-      --  BIPfinalizationmaster.\n+      --  heap or user-defined storage pool. The object may need finalization\n+      --  actions depending on the return type.\n       --\n-      --    if BIPfinalizationmaster /= null then\n-      --       declare\n-      --          type Ptr_Typ is access Ret_Typ;\n-      --          for Ptr_Typ'Storage_Pool use\n-      --                Base_Pool (BIPfinalizationmaster.all).all;\n-      --          Local : Ptr_Typ;\n+      --    * Controlled case\n+      --\n+      --       if BIPfinalizationmaster = null then\n+      --          Temp_Id := <Alloc_Expr>;\n+      --       else\n+      --          declare\n+      --             type Ptr_Typ is access Ret_Typ;\n+      --             for Ptr_Typ'Storage_Pool use\n+      --                   Base_Pool (BIPfinalizationmaster.all).all;\n+      --             Local : Ptr_Typ;\n       --\n-      --       begin\n-      --          procedure Allocate (...) is\n       --          begin\n-      --             System.Storage_Pools.Subpools.Allocate_Any (...);\n-      --          end Allocate;\n+      --             procedure Allocate (...) is\n+      --             begin\n+      --                System.Storage_Pools.Subpools.Allocate_Any (...);\n+      --             end Allocate;\n       --\n-      --          Local := <Alloc_Expr>;\n-      --          Temp_Id := Temp_Typ (Local);\n-      --       end;\n-      --    end if;\n+      --             Local := <Alloc_Expr>;\n+      --             Temp_Id := Temp_Typ (Local);\n+      --          end;\n+      --       end if;\n+      --\n+      --    * Non-controlled case\n+      --\n+      --       Temp_Id := <Alloc_Expr>;\n       --\n       --  Temp_Id is the temporary which is used to reference the internally\n       --  created object in all allocation forms. Temp_Typ is the type of the\n@@ -4536,11 +4540,11 @@ package body Exp_Ch6 is\n       --  Func_Id is the entity of the function where the extended return\n       --  statement appears.\n \n-      --------------------------\n-      -- Build_Heap_Allocator --\n-      --------------------------\n+      ----------------------------------\n+      -- Build_Heap_Or_Pool_Allocator --\n+      ----------------------------------\n \n-      function Build_Heap_Allocator\n+      function Build_Heap_Or_Pool_Allocator\n         (Temp_Id    : Entity_Id;\n          Temp_Typ   : Entity_Id;\n          Func_Id    : Entity_Id;\n@@ -4550,14 +4554,15 @@ package body Exp_Ch6 is\n       begin\n          pragma Assert (Is_Build_In_Place_Function (Func_Id));\n \n-         --  Processing for build-in-place object allocation.\n+         --  Processing for objects that require finalization actions\n \n          if Needs_Finalization (Ret_Typ) then\n             declare\n                Decls      : constant List_Id := New_List;\n                Fin_Mas_Id : constant Entity_Id :=\n                               Build_In_Place_Formal\n                                 (Func_Id, BIP_Finalization_Master);\n+               Orig_Expr  : constant Node_Id := New_Copy_Tree (Alloc_Expr);\n                Stmts      : constant List_Id := New_List;\n                Desig_Typ  : Entity_Id;\n                Local_Id   : Entity_Id;\n@@ -4619,7 +4624,7 @@ package body Exp_Ch6 is\n                --  Perform minor decoration in order to set the master and the\n                --  storage pool attributes.\n \n-               Set_Ekind (Ptr_Typ, E_Access_Type);\n+               Set_Ekind                   (Ptr_Typ, E_Access_Type);\n                Set_Finalization_Master     (Ptr_Typ, Fin_Mas_Id);\n                Set_Associated_Storage_Pool (Ptr_Typ, Pool_Id);\n \n@@ -4658,7 +4663,9 @@ package body Exp_Ch6 is\n                --  to a Finalize_Storage_Only allocation.\n \n                --  Generate:\n-               --    if BIPfinalizationmaster /= null then\n+               --    if BIPfinalizationmaster = null then\n+               --       Temp_Id := <Orig_Expr>;\n+               --    else\n                --       declare\n                --          <Decls>\n                --       begin\n@@ -4669,11 +4676,16 @@ package body Exp_Ch6 is\n                return\n                  Make_If_Statement (Loc,\n                    Condition       =>\n-                     Make_Op_Ne (Loc,\n+                     Make_Op_Eq (Loc,\n                        Left_Opnd  => New_Occurrence_Of (Fin_Mas_Id, Loc),\n                        Right_Opnd => Make_Null (Loc)),\n \n                    Then_Statements => New_List (\n+                     Make_Assignment_Statement (Loc,\n+                       Name       => New_Occurrence_Of (Temp_Id, Loc),\n+                       Expression => Orig_Expr)),\n+\n+                   Else_Statements => New_List (\n                      Make_Block_Statement (Loc,\n                        Declarations               => Decls,\n                        Handled_Statement_Sequence =>\n@@ -4690,7 +4702,7 @@ package body Exp_Ch6 is\n                 Name       => New_Occurrence_Of (Temp_Id, Loc),\n                 Expression => Alloc_Expr);\n          end if;\n-      end Build_Heap_Allocator;\n+      end Build_Heap_Or_Pool_Allocator;\n \n       ---------------------------\n       -- Move_Activation_Chain --\n@@ -5037,11 +5049,9 @@ package body Exp_Ch6 is\n                   --  determine the form of allocation needed, initialization\n                   --  is done with each part of the if statement that handles\n                   --  the different forms of allocation (this is true for\n-                  --  unconstrained and tagged result subtypes).\n+                  --  unconstrained, tagged, and controlled result subtypes).\n \n-                  if Is_Constrained (Ret_Typ)\n-                    and then not Is_Tagged_Type (Underlying_Type (Ret_Typ))\n-                  then\n+                  if not Needs_BIP_Alloc_Form (Func_Id) then\n                      Insert_After (Ret_Obj_Decl, Init_Assignment);\n                   end if;\n                end if;\n@@ -5057,16 +5067,14 @@ package body Exp_Ch6 is\n                --  a storage pool. We generate an if statement to test the\n                --  implicit allocation formal and initialize a local access\n                --  value appropriately, creating allocators in the secondary\n-               --  stack and global heap cases.  The special formal also exists\n+               --  stack and global heap cases. The special formal also exists\n                --  and must be tested when the function has a tagged result,\n                --  even when the result subtype is constrained, because in\n                --  general such functions can be called in dispatching contexts\n                --  and must be handled similarly to functions with a class-wide\n                --  result.\n \n-               if not Is_Constrained (Ret_Typ)\n-                 or else Is_Tagged_Type (Underlying_Type (Ret_Typ))\n-               then\n+               if Needs_BIP_Alloc_Form (Func_Id) then\n                   Obj_Alloc_Formal :=\n                     Build_In_Place_Formal (Func_Id, BIP_Alloc_Form);\n \n@@ -5331,7 +5339,7 @@ package body Exp_Ch6 is\n                                                     (Global_Heap)))),\n \n                              Then_Statements => New_List (\n-                               Build_Heap_Allocator\n+                               Build_Heap_Or_Pool_Allocator\n                                  (Temp_Id    => Alloc_Obj_Id,\n                                   Temp_Typ   => Ref_Type,\n                                   Func_Id    => Func_Id,\n@@ -5355,7 +5363,7 @@ package body Exp_Ch6 is\n \n                              Then_Statements => New_List (\n                                Pool_Decl,\n-                               Build_Heap_Allocator\n+                               Build_Heap_Or_Pool_Allocator\n                                  (Temp_Id    => Alloc_Obj_Id,\n                                   Temp_Typ   => Ref_Type,\n                                   Func_Id    => Func_Id,\n@@ -7256,204 +7264,6 @@ package body Exp_Ch6 is\n       end if;\n    end Expand_Simple_Function_Return;\n \n-   --------------------------------------------\n-   -- Has_Unconstrained_Access_Discriminants --\n-   --------------------------------------------\n-\n-   function Has_Unconstrained_Access_Discriminants\n-     (Subtyp : Entity_Id) return Boolean\n-   is\n-      Discr : Entity_Id;\n-\n-   begin\n-      if Has_Discriminants (Subtyp)\n-        and then not Is_Constrained (Subtyp)\n-      then\n-         Discr := First_Discriminant (Subtyp);\n-         while Present (Discr) loop\n-            if Ekind (Etype (Discr)) = E_Anonymous_Access_Type then\n-               return True;\n-            end if;\n-\n-            Next_Discriminant (Discr);\n-         end loop;\n-      end if;\n-\n-      return False;\n-   end Has_Unconstrained_Access_Discriminants;\n-\n-   -----------------------------------\n-   -- Is_Build_In_Place_Result_Type --\n-   -----------------------------------\n-\n-   function Is_Build_In_Place_Result_Type (Typ : Entity_Id) return Boolean is\n-   begin\n-      if not Expander_Active then\n-         return False;\n-      end if;\n-\n-      --  In Ada 2005 all functions with an inherently limited return type\n-      --  must be handled using a build-in-place profile, including the case\n-      --  of a function with a limited interface result, where the function\n-      --  may return objects of nonlimited descendants.\n-\n-      if Is_Limited_View (Typ) then\n-         return Ada_Version >= Ada_2005 and then not Debug_Flag_Dot_L;\n-\n-      else\n-         if Debug_Flag_Dot_9 then\n-            return False;\n-         end if;\n-\n-         if Has_Interfaces (Typ) then\n-            return False;\n-         end if;\n-\n-         declare\n-            T : Entity_Id := Typ;\n-         begin\n-            --  For T'Class, return True if it's True for T. This is necessary\n-            --  because a class-wide function might say \"return F (...)\", where\n-            --  F returns the corresponding specific type. We need a loop in\n-            --  case T is a subtype of a class-wide type.\n-\n-            while Is_Class_Wide_Type (T) loop\n-               T := Etype (T);\n-            end loop;\n-\n-            --  If this is a generic formal type in an instance, return True if\n-            --  it's True for the generic actual type.\n-\n-            if Nkind (Parent (T)) = N_Subtype_Declaration\n-              and then Present (Generic_Parent_Type (Parent (T)))\n-            then\n-               T := Entity (Subtype_Indication (Parent (T)));\n-\n-               if Present (Full_View (T)) then\n-                  T := Full_View (T);\n-               end if;\n-            end if;\n-\n-            if Present (Underlying_Type (T)) then\n-               T := Underlying_Type (T);\n-            end if;\n-\n-            declare\n-               Result : Boolean;\n-               --  So we can stop here in the debugger\n-            begin\n-               --  ???For now, enable build-in-place for a very narrow set of\n-               --  controlled types. Change \"if True\" to \"if False\" to\n-               --  experiment with more controlled types. Eventually, we might\n-               --  like to enable build-in-place for all tagged types, all\n-               --  types that need finalization, and all caller-unknown-size\n-               --  types.\n-\n-               if True then\n-                  Result := Is_Controlled (T)\n-                    and then Present (Enclosing_Subprogram (T))\n-                    and then not Is_Compilation_Unit (Enclosing_Subprogram (T))\n-                    and then Ekind (Enclosing_Subprogram (T)) = E_Procedure;\n-               else\n-                  Result := Is_Controlled (T);\n-               end if;\n-\n-               return Result;\n-            end;\n-         end;\n-      end if;\n-   end Is_Build_In_Place_Result_Type;\n-\n-   --------------------------------\n-   -- Is_Build_In_Place_Function --\n-   --------------------------------\n-\n-   function Is_Build_In_Place_Function (E : Entity_Id) return Boolean is\n-   begin\n-      --  This function is called from Expand_Subtype_From_Expr during\n-      --  semantic analysis, even when expansion is off. In those cases\n-      --  the build_in_place expansion will not take place.\n-\n-      if not Expander_Active then\n-         return False;\n-      end if;\n-\n-      --  For now we test whether E denotes a function or access-to-function\n-      --  type whose result subtype is inherently limited. Later this test\n-      --  may be revised to allow composite nonlimited types. Functions with\n-      --  a foreign convention or whose result type has a foreign convention\n-      --  never qualify.\n-\n-      if Ekind_In (E, E_Function, E_Generic_Function)\n-        or else (Ekind (E) = E_Subprogram_Type\n-                  and then Etype (E) /= Standard_Void_Type)\n-      then\n-         --  Note: If the function has a foreign convention, it cannot build\n-         --  its result in place, so you're on your own. On the other hand,\n-         --  if only the return type has a foreign convention, its layout is\n-         --  intended to be compatible with the other language, but the build-\n-         --  in place machinery can ensure that the object is not copied.\n-\n-         return Is_Build_In_Place_Result_Type (Etype (E))\n-           and then not Has_Foreign_Convention (E)\n-           and then not Debug_Flag_Dot_L;\n-\n-      else\n-         return False;\n-      end if;\n-   end Is_Build_In_Place_Function;\n-\n-   -------------------------------------\n-   -- Is_Build_In_Place_Function_Call --\n-   -------------------------------------\n-\n-   function Is_Build_In_Place_Function_Call (N : Node_Id) return Boolean is\n-      Exp_Node    : constant Node_Id := Unqual_Conv (N);\n-      Function_Id : Entity_Id;\n-\n-   begin\n-      --  Return False if the expander is currently inactive, since awareness\n-      --  of build-in-place treatment is only relevant during expansion. Note\n-      --  that Is_Build_In_Place_Function, which is called as part of this\n-      --  function, is also conditioned this way, but we need to check here as\n-      --  well to avoid blowing up on processing protected calls when expansion\n-      --  is disabled (such as with -gnatc) since those would trip over the\n-      --  raise of Program_Error below.\n-\n-      --  In SPARK mode, build-in-place calls are not expanded, so that we\n-      --  may end up with a call that is neither resolved to an entity, nor\n-      --  an indirect call.\n-\n-      if not Expander_Active or else Nkind (Exp_Node) /= N_Function_Call then\n-         return False;\n-      end if;\n-\n-      if Is_Entity_Name (Name (Exp_Node)) then\n-         Function_Id := Entity (Name (Exp_Node));\n-\n-      --  In the case of an explicitly dereferenced call, use the subprogram\n-      --  type generated for the dereference.\n-\n-      elsif Nkind (Name (Exp_Node)) = N_Explicit_Dereference then\n-         Function_Id := Etype (Name (Exp_Node));\n-\n-      --  This may be a call to a protected function.\n-\n-      elsif Nkind (Name (Exp_Node)) = N_Selected_Component then\n-         Function_Id := Etype (Entity (Selector_Name (Name (Exp_Node))));\n-\n-      else\n-         raise Program_Error;\n-      end if;\n-\n-      declare\n-         Result : constant Boolean := Is_Build_In_Place_Function (Function_Id);\n-         --  So we can stop here in the debugger\n-      begin\n-         return Result;\n-      end;\n-   end Is_Build_In_Place_Function_Call;\n-\n    -----------------------\n    -- Freeze_Subprogram --\n    -----------------------\n@@ -7646,6 +7456,32 @@ package body Exp_Ch6 is\n       end if;\n    end Freeze_Subprogram;\n \n+   --------------------------------------------\n+   -- Has_Unconstrained_Access_Discriminants --\n+   --------------------------------------------\n+\n+   function Has_Unconstrained_Access_Discriminants\n+     (Subtyp : Entity_Id) return Boolean\n+   is\n+      Discr : Entity_Id;\n+\n+   begin\n+      if Has_Discriminants (Subtyp)\n+        and then not Is_Constrained (Subtyp)\n+      then\n+         Discr := First_Discriminant (Subtyp);\n+         while Present (Discr) loop\n+            if Ekind (Etype (Discr)) = E_Anonymous_Access_Type then\n+               return True;\n+            end if;\n+\n+            Next_Discriminant (Discr);\n+         end loop;\n+      end if;\n+\n+      return False;\n+   end Has_Unconstrained_Access_Discriminants;\n+\n    ------------------------------\n    -- Insert_Post_Call_Actions --\n    ------------------------------\n@@ -7768,6 +7604,177 @@ package body Exp_Ch6 is\n       end if;\n    end Insert_Post_Call_Actions;\n \n+   -----------------------------------\n+   -- Is_Build_In_Place_Result_Type --\n+   -----------------------------------\n+\n+   function Is_Build_In_Place_Result_Type (Typ : Entity_Id) return Boolean is\n+   begin\n+      if not Expander_Active then\n+         return False;\n+      end if;\n+\n+      --  In Ada 2005 all functions with an inherently limited return type\n+      --  must be handled using a build-in-place profile, including the case\n+      --  of a function with a limited interface result, where the function\n+      --  may return objects of nonlimited descendants.\n+\n+      if Is_Limited_View (Typ) then\n+         return Ada_Version >= Ada_2005 and then not Debug_Flag_Dot_L;\n+\n+      else\n+         if Debug_Flag_Dot_9 then\n+            return False;\n+         end if;\n+\n+         if Has_Interfaces (Typ) then\n+            return False;\n+         end if;\n+\n+         declare\n+            T : Entity_Id := Typ;\n+         begin\n+            --  For T'Class, return True if it's True for T. This is necessary\n+            --  because a class-wide function might say \"return F (...)\", where\n+            --  F returns the corresponding specific type. We need a loop in\n+            --  case T is a subtype of a class-wide type.\n+\n+            while Is_Class_Wide_Type (T) loop\n+               T := Etype (T);\n+            end loop;\n+\n+            --  If this is a generic formal type in an instance, return True if\n+            --  it's True for the generic actual type.\n+\n+            if Nkind (Parent (T)) = N_Subtype_Declaration\n+              and then Present (Generic_Parent_Type (Parent (T)))\n+            then\n+               T := Entity (Subtype_Indication (Parent (T)));\n+\n+               if Present (Full_View (T)) then\n+                  T := Full_View (T);\n+               end if;\n+            end if;\n+\n+            if Present (Underlying_Type (T)) then\n+               T := Underlying_Type (T);\n+            end if;\n+\n+            declare\n+               Result : Boolean;\n+               --  So we can stop here in the debugger\n+            begin\n+               --  ???For now, enable build-in-place for a very narrow set of\n+               --  controlled types. Change \"if True\" to \"if False\" to\n+               --  experiment with more controlled types. Eventually, we might\n+               --  like to enable build-in-place for all tagged types, all\n+               --  types that need finalization, and all caller-unknown-size\n+               --  types.\n+\n+               if True then\n+                  Result := Is_Controlled (T)\n+                    and then Present (Enclosing_Subprogram (T))\n+                    and then not Is_Compilation_Unit (Enclosing_Subprogram (T))\n+                    and then Ekind (Enclosing_Subprogram (T)) = E_Procedure;\n+               else\n+                  Result := Is_Controlled (T);\n+               end if;\n+\n+               return Result;\n+            end;\n+         end;\n+      end if;\n+   end Is_Build_In_Place_Result_Type;\n+\n+   --------------------------------\n+   -- Is_Build_In_Place_Function --\n+   --------------------------------\n+\n+   function Is_Build_In_Place_Function (E : Entity_Id) return Boolean is\n+   begin\n+      --  This function is called from Expand_Subtype_From_Expr during\n+      --  semantic analysis, even when expansion is off. In those cases\n+      --  the build_in_place expansion will not take place.\n+\n+      if not Expander_Active then\n+         return False;\n+      end if;\n+\n+      --  For now we test whether E denotes a function or access-to-function\n+      --  type whose result subtype is inherently limited. Later this test\n+      --  may be revised to allow composite nonlimited types. Functions with\n+      --  a foreign convention or whose result type has a foreign convention\n+      --  never qualify.\n+\n+      if Ekind_In (E, E_Function, E_Generic_Function)\n+        or else (Ekind (E) = E_Subprogram_Type\n+                  and then Etype (E) /= Standard_Void_Type)\n+      then\n+         --  Note: If the function has a foreign convention, it cannot build\n+         --  its result in place, so you're on your own. On the other hand,\n+         --  if only the return type has a foreign convention, its layout is\n+         --  intended to be compatible with the other language, but the build-\n+         --  in place machinery can ensure that the object is not copied.\n+\n+         return Is_Build_In_Place_Result_Type (Etype (E))\n+           and then not Has_Foreign_Convention (E)\n+           and then not Debug_Flag_Dot_L;\n+      else\n+         return False;\n+      end if;\n+   end Is_Build_In_Place_Function;\n+\n+   -------------------------------------\n+   -- Is_Build_In_Place_Function_Call --\n+   -------------------------------------\n+\n+   function Is_Build_In_Place_Function_Call (N : Node_Id) return Boolean is\n+      Exp_Node    : constant Node_Id := Unqual_Conv (N);\n+      Function_Id : Entity_Id;\n+\n+   begin\n+      --  Return False if the expander is currently inactive, since awareness\n+      --  of build-in-place treatment is only relevant during expansion. Note\n+      --  that Is_Build_In_Place_Function, which is called as part of this\n+      --  function, is also conditioned this way, but we need to check here as\n+      --  well to avoid blowing up on processing protected calls when expansion\n+      --  is disabled (such as with -gnatc) since those would trip over the\n+      --  raise of Program_Error below.\n+\n+      --  In SPARK mode, build-in-place calls are not expanded, so that we\n+      --  may end up with a call that is neither resolved to an entity, nor\n+      --  an indirect call.\n+\n+      if not Expander_Active or else Nkind (Exp_Node) /= N_Function_Call then\n+         return False;\n+      end if;\n+\n+      if Is_Entity_Name (Name (Exp_Node)) then\n+         Function_Id := Entity (Name (Exp_Node));\n+\n+      --  In the case of an explicitly dereferenced call, use the subprogram\n+      --  type generated for the dereference.\n+\n+      elsif Nkind (Name (Exp_Node)) = N_Explicit_Dereference then\n+         Function_Id := Etype (Name (Exp_Node));\n+\n+      --  This may be a call to a protected function.\n+\n+      elsif Nkind (Name (Exp_Node)) = N_Selected_Component then\n+         Function_Id := Etype (Entity (Selector_Name (Name (Exp_Node))));\n+\n+      else\n+         raise Program_Error;\n+      end if;\n+\n+      declare\n+         Result : constant Boolean := Is_Build_In_Place_Function (Function_Id);\n+         --  So we can stop here in the debugger\n+      begin\n+         return Result;\n+      end;\n+   end Is_Build_In_Place_Function_Call;\n+\n    -----------------------\n    -- Is_Null_Procedure --\n    -----------------------\n@@ -7853,10 +7860,9 @@ package body Exp_Ch6 is\n       --  Step past qualification or unchecked conversion (the latter can occur\n       --  in cases of calls to 'Input).\n \n-      if Nkind_In (Func_Call,\n-                   N_Qualified_Expression,\n-                   N_Type_Conversion,\n-                   N_Unchecked_Type_Conversion)\n+      if Nkind_In (Func_Call, N_Qualified_Expression,\n+                              N_Type_Conversion,\n+                              N_Unchecked_Type_Conversion)\n       then\n          Func_Call := Expression (Func_Call);\n       end if;\n@@ -7889,16 +7895,37 @@ package body Exp_Ch6 is\n       Set_Can_Never_Be_Null (Acc_Type, False);\n       --  It gets initialized to null, so we can't have that\n \n-      --  When the result subtype is constrained, the return object is\n-      --  allocated on the caller side, and access to it is passed to the\n-      --  function.\n+      --  When the result subtype is constrained, the return object is created\n+      --  on the caller side, and access to it is passed to the function. This\n+      --  optimization is disabled when the result subtype needs finalization\n+      --  actions because the caller side allocation may result in undesirable\n+      --  finalization. Consider the following example:\n+      --\n+      --    function Make_Lim_Ctrl return Lim_Ctrl is\n+      --    begin\n+      --       return Result : Lim_Ctrl := raise Program_Error do\n+      --          null;\n+      --       end return;\n+      --    end Make_Lim_Ctrl;\n+      --\n+      --    Obj : Lim_Ctrl_Ptr := new Lim_Ctrl'(Make_Lim_Ctrl);\n+      --\n+      --  Even though the size of limited controlled type Lim_Ctrl is known,\n+      --  allocating Obj at the caller side will chain Obj on Lim_Ctrl_Ptr's\n+      --  finalization master. The subsequent call to Make_Lim_Ctrl will fail\n+      --  during the initialization actions for Result, which implies that\n+      --  Result (and Obj by extension) should not be finalized. However Obj\n+      --  will be finalized when access type Lim_Ctrl_Ptr goes out of scope\n+      --  since it is already attached on the related finalization master.\n \n       --  Here and in related routines, we must examine the full view of the\n       --  type, because the view at the point of call may differ from that\n       --  that in the function body, and the expansion mechanism depends on\n       --  the characteristics of the full view.\n \n-      if Is_Constrained (Underlying_Type (Result_Subt)) then\n+      if Is_Constrained (Underlying_Type (Result_Subt))\n+        and then not Needs_Finalization (Underlying_Type (Result_Subt))\n+      then\n          --  Replace the initialized allocator of form \"new T'(Func (...))\"\n          --  with an uninitialized allocator of form \"new T\", where T is the\n          --  result subtype of the called function. The call to the function\n@@ -7926,8 +7953,8 @@ package body Exp_Ch6 is\n \n          Temp_Init := Relocate_Node (Allocator);\n \n-         if Nkind_In\n-           (Function_Call, N_Type_Conversion, N_Unchecked_Type_Conversion)\n+         if Nkind_In (Function_Call, N_Type_Conversion,\n+                                     N_Unchecked_Type_Conversion)\n          then\n             Temp_Init := Unchecked_Convert_To (Acc_Type, Temp_Init);\n          end if;\n@@ -8001,17 +8028,17 @@ package body Exp_Ch6 is\n       --  that the full types will be compatible, but the types not visibly\n       --  compatible.\n \n-      elsif Nkind_In\n-        (Function_Call, N_Type_Conversion, N_Unchecked_Type_Conversion)\n+      elsif Nkind_In (Function_Call, N_Type_Conversion,\n+                                     N_Unchecked_Type_Conversion)\n       then\n          Ref_Func_Call := Unchecked_Convert_To (Acc_Type, Ref_Func_Call);\n       end if;\n \n       declare\n          Assign : constant Node_Id :=\n-           Make_Assignment_Statement (Loc,\n-             Name       => New_Occurrence_Of (Return_Obj_Access, Loc),\n-             Expression => Ref_Func_Call);\n+                    Make_Assignment_Statement (Loc,\n+                      Name       => New_Occurrence_Of (Return_Obj_Access, Loc),\n+                      Expression => Ref_Func_Call);\n          --  Assign the result of the function call into the temp. In the\n          --  caller-allocates case, this is overwriting the temp with its\n          --  initial value, which has no effect. In the callee-allocates case,\n@@ -8025,6 +8052,7 @@ package body Exp_Ch6 is\n          --  to wrap the assignment in a block that activates them. The\n          --  activation chain of that block must be passed to the function,\n          --  rather than some outer chain.\n+\n       begin\n          if Has_Task (Result_Subt) then\n             Actions := New_List;\n@@ -9062,8 +9090,30 @@ package body Exp_Ch6 is\n    function Needs_BIP_Alloc_Form (Func_Id : Entity_Id) return Boolean is\n       pragma Assert (Is_Build_In_Place_Function (Func_Id));\n       Func_Typ : constant Entity_Id := Underlying_Type (Etype (Func_Id));\n+\n    begin\n-      return not Is_Constrained (Func_Typ) or else Is_Tagged_Type (Func_Typ);\n+      --  A build-in-place function needs to know which allocation form to\n+      --  use when:\n+      --\n+      --  1) The result subtype is unconstrained. In this case, depending on\n+      --     the context of the call, the object may need to be created in the\n+      --     secondary stack, the heap, or a user-defined storage pool.\n+      --\n+      --  2) The result subtype is tagged. In this case the function call may\n+      --     dispatch on result and thus needs to be treated in the same way as\n+      --     calls to functions with class-wide results, because a callee that\n+      --     can be dispatched to may have any of various result subtypes, so\n+      --     if any of the possible callees would require an allocation form to\n+      --     be passed then they all do.\n+      --\n+      --  3) The result subtype needs finalization actions. In this case, based\n+      --     on the context of the call, the object may need to be created at\n+      --     the caller site, in the heap, or in a user-defined storage pool.\n+\n+      return\n+        not Is_Constrained (Func_Typ)\n+          or else Is_Tagged_Type (Func_Typ)\n+          or else Needs_Finalization (Func_Typ);\n    end Needs_BIP_Alloc_Form;\n \n    --------------------------------------"}, {"sha": "7b49a7a29bad25aa47459040b9afbe498da10e52", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1d3a546409ce9e4aedb3b8d537cc770beabd62/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1d3a546409ce9e4aedb3b8d537cc770beabd62/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=7d1d3a546409ce9e4aedb3b8d537cc770beabd62", "patch": "@@ -682,16 +682,10 @@ package body Exp_Util is\n \n       if Needs_Fin then\n \n-         --  Certain run-time configurations and targets do not provide support\n-         --  for controlled types.\n-\n-         if Restriction_Active (No_Finalization) then\n-            return;\n-\n          --  Do nothing if the access type may never allocate / deallocate\n          --  objects.\n \n-         elsif No_Pool_Assigned (Ptr_Typ) then\n+         if No_Pool_Assigned (Ptr_Typ) then\n             return;\n          end if;\n "}]}