{"sha": "28ae04d46ea61a77b5a41267fc09b9478d4fb3cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhhZTA0ZDQ2ZWE2MWE3N2I1YTQxMjY3ZmMwOWI5NDc4ZDRmYjNjYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-06-16T16:08:36Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-06-16T16:08:36Z"}, "message": "profile.c (compare_freqs): New function.\n\n\t* profile.c (compare_freqs): New function.\n\t(branch_prob): Sort edge list.\n\t(find_spanning_tree): Assume that the list is priority sorted.\n\nFrom-SVN: r249270", "tree": {"sha": "787209534abc294f53a6a154901f69e468e45fb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/787209534abc294f53a6a154901f69e468e45fb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28ae04d46ea61a77b5a41267fc09b9478d4fb3cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28ae04d46ea61a77b5a41267fc09b9478d4fb3cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28ae04d46ea61a77b5a41267fc09b9478d4fb3cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28ae04d46ea61a77b5a41267fc09b9478d4fb3cc/comments", "author": null, "committer": null, "parents": [{"sha": "e249fcad3aea469b27d92ba9ef435ee79fd932d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e249fcad3aea469b27d92ba9ef435ee79fd932d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e249fcad3aea469b27d92ba9ef435ee79fd932d4"}], "stats": {"total": 46, "additions": 30, "deletions": 16}, "files": [{"sha": "169f0141277f8434f895bdee22852493d810ca7e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28ae04d46ea61a77b5a41267fc09b9478d4fb3cc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28ae04d46ea61a77b5a41267fc09b9478d4fb3cc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=28ae04d46ea61a77b5a41267fc09b9478d4fb3cc", "patch": "@@ -1,3 +1,9 @@\n+2017-06-16  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* profile.c (compare_freqs): New function.\n+\t(branch_prob): Sort edge list.\n+\t(find_spanning_tree): Assume that the list is priority sorted.\n+\n 2017-06-16  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/81090"}, {"sha": "51ca248f5adcb7aa4601ade7d80fa4ee957230c0", "filename": "gcc/profile.c", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28ae04d46ea61a77b5a41267fc09b9478d4fb3cc/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28ae04d46ea61a77b5a41267fc09b9478d4fb3cc/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=28ae04d46ea61a77b5a41267fc09b9478d4fb3cc", "patch": "@@ -987,6 +987,27 @@ output_location (char const *file_name, int line,\n     }\n }\n \n+/* Helper for qsort so edges get sorted from highest frequency to smallest.\n+   This controls the weight for minimal spanning tree algorithm  */\n+static int\n+compare_freqs (const void *p1, const void *p2)\n+{\n+  const_edge e1 = *(const const_edge *)p1;\n+  const_edge e2 = *(const const_edge *)p2;\n+\n+  /* Critical edges needs to be split which introduce extra control flow.\n+     Make them more heavy.  */\n+  int m1 = EDGE_CRITICAL_P (e1) ? 2 : 1;\n+  int m2 = EDGE_CRITICAL_P (e2) ? 2 : 1;\n+\n+  if (EDGE_FREQUENCY (e1) * m1 + m1 != EDGE_FREQUENCY (e2) * m2 + m2)\n+    return EDGE_FREQUENCY (e2) * m2 + m2 - EDGE_FREQUENCY (e1) * m1 - m1;\n+  /* Stabilize sort.  */\n+  if (e1->src->index != e2->src->index)\n+    return e2->src->index - e1->src->index;\n+  return e2->dest->index - e1->dest->index;\n+}\n+\n /* Instrument and/or analyze program behavior based on program the CFG.\n \n    This function creates a representation of the control flow graph (of\n@@ -1140,6 +1161,7 @@ branch_prob (void)\n \n   el = create_edge_list ();\n   num_edges = NUM_EDGES (el);\n+  qsort (el->index_to_edge, num_edges, sizeof (edge), compare_freqs);\n   alloc_aux_for_edges (sizeof (struct edge_profile_info));\n \n   /* The basic blocks are expected to be numbered sequentially.  */\n@@ -1431,22 +1453,8 @@ find_spanning_tree (struct edge_list *el)\n \t}\n     }\n \n-  /* Now insert all critical edges to the tree unless they form a cycle.  */\n-  for (i = 0; i < num_edges; i++)\n-    {\n-      edge e = INDEX_EDGE (el, i);\n-      if (EDGE_CRITICAL_P (e) && !EDGE_INFO (e)->ignore\n-\t  && find_group (e->src) != find_group (e->dest))\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Critical edge %d to %d put to tree\\n\",\n-\t\t     e->src->index, e->dest->index);\n-\t  EDGE_INFO (e)->on_tree = 1;\n-\t  union_groups (e->src, e->dest);\n-\t}\n-    }\n-\n-  /* And now the rest.  */\n+  /* And now the rest.  Edge list is sorted according to frequencies and\n+     thus we will produce minimal spanning tree.  */\n   for (i = 0; i < num_edges; i++)\n     {\n       edge e = INDEX_EDGE (el, i);"}]}