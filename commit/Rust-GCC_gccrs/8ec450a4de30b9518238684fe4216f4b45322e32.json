{"sha": "8ec450a4de30b9518238684fe4216f4b45322e32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGVjNDUwYTRkZTMwYjk1MTgyMzg2ODRmZTQyMTZmNGI0NTMyMmUzMg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-10-17T06:47:27Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-10-17T06:47:27Z"}, "message": "reload.h (struct reload): Add new fields \"mode\" and \"nregs\".\n\n        * reload.h (struct reload): Add new fields \"mode\" and \"nregs\".\n        * reload1.c: Change all occurrences of reload_mode and reload_nregs\n        to reference the \"mode\" and \"nregs\" field within struct reload.\n\nFrom-SVN: r30051", "tree": {"sha": "b6e06d2e64bd73926b7e2b0f2b093c565527426d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6e06d2e64bd73926b7e2b0f2b093c565527426d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ec450a4de30b9518238684fe4216f4b45322e32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ec450a4de30b9518238684fe4216f4b45322e32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ec450a4de30b9518238684fe4216f4b45322e32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ec450a4de30b9518238684fe4216f4b45322e32/comments", "author": null, "committer": null, "parents": [{"sha": "356edbd763bb467a126d12fcd42d0e00a6cd6b9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/356edbd763bb467a126d12fcd42d0e00a6cd6b9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/356edbd763bb467a126d12fcd42d0e00a6cd6b9a"}], "stats": {"total": 90, "additions": 48, "deletions": 42}, "files": [{"sha": "032482bf2fb7c19371946db761503439cb0b4c0a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ec450a4de30b9518238684fe4216f4b45322e32/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ec450a4de30b9518238684fe4216f4b45322e32/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8ec450a4de30b9518238684fe4216f4b45322e32", "patch": "@@ -1,3 +1,9 @@\n+Sun Oct 17 00:44:17 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* reload.h (struct reload): Add new fields \"mode\" and \"nregs\".\n+\t* reload1.c: Change all occurrences of reload_mode and reload_nregs\n+\tto reference the \"mode\" and \"nregs\" field within struct reload.\n+\n Sat Oct 16 21:50:28 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* haifa-sched.c (true_dependency_cache): New."}, {"sha": "5159c4763a6404705c4e14070d9d57b159928847", "filename": "gcc/reload.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ec450a4de30b9518238684fe4216f4b45322e32/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ec450a4de30b9518238684fe4216f4b45322e32/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=8ec450a4de30b9518238684fe4216f4b45322e32", "patch": "@@ -99,6 +99,12 @@ struct reload\n   /* The mode this operand should have when reloaded, on output.  */\n   enum machine_mode outmode;\n \n+  /* The mode of the reload register.  */\n+  enum mode;\n+\n+  /* the largest number of registers this reload will require.  */\n+  int nregs;\n+\n   /* Positive amount to increment or decrement by if\n      reload_in is a PRE_DEC, PRE_INC, POST_DEC, POST_INC.\n      Ignored otherwise (don't assume it is zero).  */"}, {"sha": "f4036d091617a11248c0964152cd8c59a437ec06", "filename": "gcc/reload1.c", "status": "modified", "additions": 36, "deletions": 42, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ec450a4de30b9518238684fe4216f4b45322e32/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ec450a4de30b9518238684fe4216f4b45322e32/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=8ec450a4de30b9518238684fe4216f4b45322e32", "patch": "@@ -4508,12 +4508,6 @@ forget_old_reloads_1 (x, ignored)\n       reg_last_reload_reg[regno + nr] = 0;\n }\n \f\n-/* For each reload, the mode of the reload register.  */\n-static enum machine_mode reload_mode[MAX_RELOADS];\n-\n-/* For each reload, the largest number of registers it will require.  */\n-static int reload_nregs[MAX_RELOADS];\n-\n /* Comparison function for qsort to decide which of two reloads\n    should be handled first.  *P1 and *P2 are the reload numbers.  */\n \n@@ -4537,7 +4531,7 @@ reload_reg_class_lower (r1p, r2p)\n     return t;\n \n   /* Aside from solitaires, consider all multi-reg groups first.  */\n-  t = reload_nregs[r2] - reload_nregs[r1];\n+  t = rld[r2].nregs - rld[r1].nregs;\n   if (t != 0)\n     return t;\n \n@@ -4748,7 +4742,7 @@ clear_reload_reg_in_use (regno, opnum, type, mode)\n \t      int conflict_start = true_regnum (rld[i].reg_rtx);\n \t      int conflict_end\n \t\t= (conflict_start\n-\t\t   + HARD_REGNO_NREGS (conflict_start, reload_mode[i]));\n+\t\t   + HARD_REGNO_NREGS (conflict_start, rld[i].mode));\n \n \t      /* If there is an overlap with the first to-be-freed register,\n \t\t adjust the interval start.  */\n@@ -5400,7 +5394,7 @@ allocate_reload_reg (chain, r, last_reload, noerror)\n      Perhaps those classes should be avoided for reloading\n      by use of more alternatives.  */\n \n-  int force_group = reload_nregs[r] > 1 && ! last_reload;\n+  int force_group = rld[r].nregs > 1 && ! last_reload;\n \n   /* If we want a single register and haven't yet found one,\n      take any reg in the right class and not in use.\n@@ -5453,7 +5447,7 @@ allocate_reload_reg (chain, r, last_reload, noerror)\n \t\t\t\t\t\t   rld[r].in,\n \t\t\t\t\t\t   rld[r].out, r, 1)))\n \t      && TEST_HARD_REG_BIT (reg_class_contents[class], regnum)\n-\t      && HARD_REGNO_MODE_OK (regnum, reload_mode[r])\n+\t      && HARD_REGNO_MODE_OK (regnum, rld[r].mode)\n \t      /* Look first for regs to share, then for unshared.  But\n \t\t don't share regs used for inherited reloads; they are\n \t\t the ones we want to preserve.  */\n@@ -5463,12 +5457,12 @@ allocate_reload_reg (chain, r, last_reload, noerror)\n \t\t      && ! TEST_HARD_REG_BIT (reload_reg_used_for_inherit,\n \t\t\t\t\t      regnum))))\n \t    {\n-\t      int nr = HARD_REGNO_NREGS (regnum, reload_mode[r]);\n+\t      int nr = HARD_REGNO_NREGS (regnum, rld[r].mode);\n \t      /* Avoid the problem where spilling a GENERAL_OR_FP_REG\n \t\t (on 68000) got us two FP regs.  If NR is 1,\n \t\t we would reject both of them.  */\n \t      if (force_group)\n-\t\tnr = CLASS_MAX_NREGS (rld[r].class, reload_mode[r]);\n+\t\tnr = CLASS_MAX_NREGS (rld[r].class, rld[r].mode);\n \t      /* If we need only one reg, we have already won.  */\n \t      if (nr == 1)\n \t\t{\n@@ -5517,21 +5511,21 @@ allocate_reload_reg (chain, r, last_reload, noerror)\n \n   new = spill_reg_rtx[i];\n \n-  if (new == 0 || GET_MODE (new) != reload_mode[r])\n+  if (new == 0 || GET_MODE (new) != rld[r].mode)\n     spill_reg_rtx[i] = new\n-      = gen_rtx_REG (reload_mode[r], spill_regs[i]);\n+      = gen_rtx_REG (rld[r].mode, spill_regs[i]);\n \n   regno = true_regnum (new);\n \n   /* Detect when the reload reg can't hold the reload mode.\n      This used to be one `if', but Sequent compiler can't handle that.  */\n-  if (HARD_REGNO_MODE_OK (regno, reload_mode[r]))\n+  if (HARD_REGNO_MODE_OK (regno, rld[r].mode))\n     {\n       enum machine_mode test_mode = VOIDmode;\n       if (rld[r].in)\n \ttest_mode = GET_MODE (rld[r].in);\n       /* If rld[r].in has VOIDmode, it means we will load it\n-\t in whatever mode the reload reg has: to wit, reload_mode[r].\n+\t in whatever mode the reload reg has: to wit, rld[r].mode.\n \t We have already tested that for validity.  */\n       /* Aside from that, we need to test that the expressions\n \t to reload from or into have modes which are valid for this\n@@ -5547,7 +5541,7 @@ allocate_reload_reg (chain, r, last_reload, noerror)\n \t    /* Mark as in use for this insn the reload regs we use\n \t       for this.  */\n \t    mark_reload_reg_in_use (spill_regs[i], rld[r].opnum,\n-\t\t\t\t    rld[r].when_needed, reload_mode[r]);\n+\t\t\t\t    rld[r].when_needed, rld[r].mode);\n \n \t    rld[r].reg_rtx = new;\n \t    reload_spill_index[r] = spill_regs[i];\n@@ -5682,16 +5676,16 @@ choose_reload_regs (chain)\n       reload_order[j] = j;\n       reload_spill_index[j] = -1;\n \n-      reload_mode[j] = ((rld[j].inmode == VOIDmode\n-\t\t\t || (GET_MODE_SIZE (rld[j].outmode)\n-\t\t\t     > GET_MODE_SIZE (rld[j].inmode)))\n-\t\t\t? rld[j].outmode : rld[j].inmode);\n+      rld[j].mode = ((rld[j].inmode == VOIDmode\n+\t\t      || (GET_MODE_SIZE (rld[j].outmode)\n+\t\t\t  > GET_MODE_SIZE (rld[j].inmode)))\n+\t\t     ? rld[j].outmode : rld[j].inmode);\n \n-      reload_nregs[j] = CLASS_MAX_NREGS (rld[j].class, reload_mode[j]);\n+      rld[j].nregs = CLASS_MAX_NREGS (rld[j].class, rld[j].mode);\n \n-      if (reload_nregs[j] > 1)\n+      if (rld[j].nregs > 1)\n \t{\n-\t  max_group_size = MAX (reload_nregs[j], max_group_size);\n+\t  max_group_size = MAX (rld[j].nregs, max_group_size);\n \t  group_class = reg_class_superunion[(int)rld[j].class][(int)group_class];\n \t}\n \n@@ -5700,7 +5694,7 @@ choose_reload_regs (chain)\n \t don't use it in another way.  */\n       if (rld[j].reg_rtx)\n \tmark_reload_reg_in_use (REGNO (rld[j].reg_rtx), rld[j].opnum,\n-\t\t\t\trld[j].when_needed, reload_mode[j]);\n+\t\t\t\trld[j].when_needed, rld[j].mode);\n     }\n \n   if (n_reloads > 1)\n@@ -5882,7 +5876,7 @@ choose_reload_regs (chain)\n \t\t       >= GET_MODE_SIZE (mode) + word * UNITS_PER_WORD)\n \t\t      && reg_reloaded_contents[i] == regno\n \t\t      && TEST_HARD_REG_BIT (reg_reloaded_valid, i)\n-\t\t      && HARD_REGNO_MODE_OK (i, reload_mode[r])\n+\t\t      && HARD_REGNO_MODE_OK (i, rld[r].mode)\n \t\t      && (TEST_HARD_REG_BIT (reg_class_contents[(int) class], i)\n \t\t\t  /* Even if we can't use this register as a reload\n \t\t\t     register, we might use it for reload_override_in,\n@@ -5901,7 +5895,7 @@ choose_reload_regs (chain)\n #endif\n \t\t\t      ))\n \n-\t\t      && (reload_nregs[r] == max_group_size\n+\t\t      && (rld[r].nregs == max_group_size\n \t\t\t  || ! TEST_HARD_REG_BIT (reg_class_contents[(int) group_class],\n \t\t\t\t\t\t  i))\n \t\t      && reload_reg_free_for_value_p (i, rld[r].opnum,\n@@ -5912,7 +5906,7 @@ choose_reload_regs (chain)\n \t\t      /* If a group is needed, verify that all the subsequent\n \t\t\t registers still have their values intact.  */\n \t\t      int nr\n-\t\t\t= HARD_REGNO_NREGS (i, reload_mode[r]);\n+\t\t\t= HARD_REGNO_NREGS (i, rld[r].mode);\n \t\t      int k;\n \n \t\t      for (k = 1; k < nr; k++)\n@@ -5953,7 +5947,7 @@ choose_reload_regs (chain)\n \t\t\t\t  && rld[r].out)\n \t\t\t      /* Don't really use the inherited spill reg\n \t\t\t\t if we need it wider than we've got it.  */\n-\t\t\t      || (GET_MODE_SIZE (reload_mode[r])\n+\t\t\t      || (GET_MODE_SIZE (rld[r].mode)\n \t\t\t\t  > GET_MODE_SIZE (mode))\n \t\t\t      || ! TEST_HARD_REG_BIT (reg_class_contents[(int) rld[r].class],\n \t\t\t\t\t\t      i)\n@@ -5978,7 +5972,7 @@ choose_reload_regs (chain)\n \t\t\t      mark_reload_reg_in_use (i,\n \t\t\t\t\t\t      rld[r].opnum,\n \t\t\t\t\t\t      rld[r].when_needed,\n-\t\t\t\t\t\t      reload_mode[r]);\n+\t\t\t\t\t\t      rld[r].mode);\n \t\t\t      rld[r].reg_rtx = last_reg;\n \t\t\t      reload_inherited[r] = 1;\n \t\t\t      reload_inheritance_insn[r]\n@@ -6002,7 +5996,7 @@ choose_reload_regs (chain)\n \t\t  || GET_CODE (rld[r].in) == PLUS\n \t\t  || GET_CODE (rld[r].in) == REG\n \t\t  || GET_CODE (rld[r].in) == MEM)\n-\t      && (reload_nregs[r] == max_group_size\n+\t      && (rld[r].nregs == max_group_size\n \t\t  || ! reg_classes_intersect_p (rld[r].class, group_class)))\n \t    search_equiv = rld[r].in;\n \t  /* If this is an output reload from a simple move insn, look\n@@ -6021,7 +6015,7 @@ choose_reload_regs (chain)\n \t    {\n \t      register rtx equiv\n \t\t= find_equiv_reg (search_equiv, insn, rld[r].class,\n-\t\t\t\t  -1, NULL_PTR, 0, reload_mode[r]);\n+\t\t\t\t  -1, NULL_PTR, 0, rld[r].mode);\n \t      int regno = 0;\n \n \t      if (equiv != 0)\n@@ -6035,7 +6029,7 @@ choose_reload_regs (chain)\n \t\t\t address and not all machines support SUBREGs\n \t\t\t there.  */\n \t\t      regno = REGNO (SUBREG_REG (equiv)) + SUBREG_WORD (equiv);\n-\t\t      equiv = gen_rtx_REG (reload_mode[r], regno);\n+\t\t      equiv = gen_rtx_REG (rld[r].mode, regno);\n \t\t    }\n \t\t  else\n \t\t    abort ();\n@@ -6053,7 +6047,7 @@ choose_reload_regs (chain)\n \t\t\t\t\t      regno)))\n \t\tequiv = 0;\n \n-\t      if (equiv != 0 && ! HARD_REGNO_MODE_OK (regno, reload_mode[r]))\n+\t      if (equiv != 0 && ! HARD_REGNO_MODE_OK (regno, rld[r].mode))\n \t\tequiv = 0;\n \n \t      /* We found a register that contains the value we need.\n@@ -6101,7 +6095,7 @@ choose_reload_regs (chain)\n \t\t to load it, and use it as our reload reg.  */\n \t      if (equiv != 0 && regno != HARD_FRAME_POINTER_REGNUM)\n \t\t{\n-\t\t  int nr = HARD_REGNO_NREGS (regno, reload_mode[r]);\n+\t\t  int nr = HARD_REGNO_NREGS (regno, rld[r].mode);\n \t\t  int k;\n \t\t  rld[r].reg_rtx = equiv;\n \t\t  reload_inherited[r] = 1;\n@@ -6121,7 +6115,7 @@ choose_reload_regs (chain)\n \t\t\t{\n \t\t\t  mark_reload_reg_in_use (regno, rld[r].opnum,\n \t\t\t\t\t\t  rld[r].when_needed,\n-\t\t\t\t\t\t  reload_mode[r]);\n+\t\t\t\t\t\t  rld[r].mode);\n \t\t\t  SET_HARD_REG_BIT (reload_reg_used_for_inherit,\n \t\t\t\t\t    regno + k);\n \t\t\t}\n@@ -6158,7 +6152,7 @@ choose_reload_regs (chain)\n \t      if ((rld[s].class != rld[r].class\n \t\t   && reg_classes_intersect_p (rld[r].class,\n \t\t\t\t\t       rld[s].class))\n-\t\t  || reload_nregs[s] < reload_nregs[r])\n+\t\t  || rld[s].nregs < rld[r].nregs)\n \t\tbreak;\n \t    }\n \n@@ -6307,7 +6301,7 @@ choose_reload_regs (chain)\n \n \tif (spill_reg_order[regno] >= 0)\n \t  clear_reload_reg_in_use (regno, rld[j].opnum,\n-\t\t\t\t   rld[j].when_needed, reload_mode[j]);\n+\t\t\t\t   rld[j].when_needed, rld[j].mode);\n \trld[j].reg_rtx = 0;\n       }\n \n@@ -6328,14 +6322,14 @@ choose_reload_regs (chain)\n \t  int nr = 1;\n \n \t  if (nregno < FIRST_PSEUDO_REGISTER)\n-\t    nr = HARD_REGNO_NREGS (nregno, reload_mode[r]);\n+\t    nr = HARD_REGNO_NREGS (nregno, rld[r].mode);\n \n \t  while (--nr >= 0)\n \t    reg_has_output_reload[nregno + nr] = 1;\n \n \t  if (i >= 0)\n \t    {\n-\t      nr = HARD_REGNO_NREGS (i, reload_mode[r]);\n+\t      nr = HARD_REGNO_NREGS (i, rld[r].mode);\n \t      while (--nr >= 0)\n \t\tSET_HARD_REG_BIT (reg_is_output_reload, i + nr);\n \t    }\n@@ -6362,7 +6356,7 @@ deallocate_reload_reg (r)\n   rld[r].reg_rtx = 0;\n   if (spill_reg_order[regno] >= 0)\n     clear_reload_reg_in_use (regno, rld[r].opnum, rld[r].when_needed,\n-\t\t\t     reload_mode[r]);\n+\t\t\t     rld[r].mode);\n   reload_spill_index[r] = -1;\n }\n \f\n@@ -7640,7 +7634,7 @@ emit_reload_insns (chain)\n \t\t  && REGNO (src_reg) < FIRST_PSEUDO_REGISTER)\n \t\t{\n \t\t  int src_regno = REGNO (src_reg);\n-\t\t  int nr = HARD_REGNO_NREGS (src_regno, reload_mode[r]);\n+\t\t  int nr = HARD_REGNO_NREGS (src_regno, rld[r].mode);\n \t\t  /* The place where to find a death note varies with\n \t\t     PRESERVE_DEATH_INFO_REGNO_P .  The condition is not\n \t\t     necessarily checked exactly in the code that moves"}]}