{"sha": "2edb37a65e4b043f00de9c28d6076058b236cbaa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVkYjM3YTY1ZTRiMDQzZjAwZGU5YzI4ZDYwNzYwNThiMjM2Y2JhYQ==", "commit": {"author": {"name": "Xinliang David Li", "email": "davidxl@google.com", "date": "2010-10-15T23:16:59Z"}, "committer": {"name": "Xinliang David Li", "email": "davidxl@gcc.gnu.org", "date": "2010-10-15T23:16:59Z"}, "message": "uninit var analysis enhancement\n\nFrom-SVN: r165530", "tree": {"sha": "410cb95a75eba97ac187d4846c518ab3ab669b4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/410cb95a75eba97ac187d4846c518ab3ab669b4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2edb37a65e4b043f00de9c28d6076058b236cbaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2edb37a65e4b043f00de9c28d6076058b236cbaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2edb37a65e4b043f00de9c28d6076058b236cbaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2edb37a65e4b043f00de9c28d6076058b236cbaa/comments", "author": {"login": "vns-mn", "id": 57157229, "node_id": "MDQ6VXNlcjU3MTU3MjI5", "avatar_url": "https://avatars.githubusercontent.com/u/57157229?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vns-mn", "html_url": "https://github.com/vns-mn", "followers_url": "https://api.github.com/users/vns-mn/followers", "following_url": "https://api.github.com/users/vns-mn/following{/other_user}", "gists_url": "https://api.github.com/users/vns-mn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vns-mn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vns-mn/subscriptions", "organizations_url": "https://api.github.com/users/vns-mn/orgs", "repos_url": "https://api.github.com/users/vns-mn/repos", "events_url": "https://api.github.com/users/vns-mn/events{/privacy}", "received_events_url": "https://api.github.com/users/vns-mn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d527c90aa56dfdcf6798f58ca0199e1a56043981", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d527c90aa56dfdcf6798f58ca0199e1a56043981", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d527c90aa56dfdcf6798f58ca0199e1a56043981"}], "stats": {"total": 363, "additions": 321, "deletions": 42}, "files": [{"sha": "d7ffbbb412fa553c1067beed93b509fe66f69ad1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2edb37a65e4b043f00de9c28d6076058b236cbaa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2edb37a65e4b043f00de9c28d6076058b236cbaa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2edb37a65e4b043f00de9c28d6076058b236cbaa", "patch": "@@ -1,3 +1,10 @@\n+2010-10-15  Xinliang David Li  <davidxl@google.com>\n+\n+\t* tree-ssa-uninit.c (prune_uninit_phi_opnds_in_unrealizable_paths): New\n+\tfunction.\n+\t(use_pred_not_overlap_with_undef_path_pred): Outline phi arg pruning\n+\tinto a recursive function.\n+\n 2010-10-15  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (*movdfcc_1_rex64): Correct mode attribute."}, {"sha": "bc57cde893879b1b10fb296e02c5b98614d7be55", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2edb37a65e4b043f00de9c28d6076058b236cbaa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2edb37a65e4b043f00de9c28d6076058b236cbaa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2edb37a65e4b043f00de9c28d6076058b236cbaa", "patch": "@@ -1,3 +1,8 @@\n+2010-10-15  Xinliang David Li  <davidxl@google.com>\n+\n+\t* g++.dg/uninit-pred-3_a.C: New test.\n+\t* g++.dg/uninit-pred-3_b.C: New test.\n+\n 2010-10-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc.dg/gnu-api-2-object.m: New."}, {"sha": "91014079004e7f246bccfc3bf871eb71d84fc3ee", "filename": "gcc/testsuite/g++.dg/uninit-pred-3_a.C", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2edb37a65e4b043f00de9c28d6076058b236cbaa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-3_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2edb37a65e4b043f00de9c28d6076058b236cbaa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-3_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-3_a.C?ref=2edb37a65e4b043f00de9c28d6076058b236cbaa", "patch": "@@ -0,0 +1,77 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+/* Multiple initialization paths.  */\n+\n+typedef long long int64;\n+void incr ();\n+bool is_valid (int);\n+int  get_time ();\n+\n+class A\n+{\n+public:\n+  A ();\n+  ~A () {\n+    if (I) delete I;\n+  }\n+\n+private:\n+  int* I;\n+};\n+\n+bool get_url (A *);\n+bool get_url2 (A *);\n+\n+class M {\n+\n+ public:\n+ __attribute__ ((always_inline))\n+ bool GetC (int *c)  {\n+\n+    A details_str;\n+    /* Intialization path 1  */\n+    if (get_url (&details_str))\n+      {\n+        *c = get_time ();\n+        return true;\n+      }\n+\n+    /* insert dtor calls (inlined) into following return paths  */\n+    A tmp_str;\n+\n+    /* Intializtion path 2  */\n+    if (get_url2 (&details_str))\n+      {\n+        *c = get_time ();\n+        return true;\n+      }\n+\n+    return false;\n+  }\n+\n+  void do_sth();\n+  void do_sth2();\n+\n+  void P (int64 t)\n+    {\n+      int cc;\n+      if (!GetC (&cc)) /* return flag checked properly */\n+        return;\n+\n+      if (cc <= 0)   /* { dg-bogus \"uninitialized\" \"uninitialized variable warning\" } */\n+        {\n+          this->do_sth();\n+          return;\n+        }\n+\n+    do_sth2();\n+  }\n+};\n+\n+M* m;\n+void test(int x)\n+{\n+  m = new M;\n+  m->P(x);\n+}"}, {"sha": "cfe2113bb6e34de5ca1443aa5667f240fd061b7f", "filename": "gcc/testsuite/g++.dg/uninit-pred-3_b.C", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2edb37a65e4b043f00de9c28d6076058b236cbaa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-3_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2edb37a65e4b043f00de9c28d6076058b236cbaa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-3_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-3_b.C?ref=2edb37a65e4b043f00de9c28d6076058b236cbaa", "patch": "@@ -0,0 +1,87 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+/* Multiple initialization paths.  */\n+\n+typedef long long int64;\n+void incr ();\n+bool is_valid (int);\n+int  get_time ();\n+\n+class A\n+{\n+public:\n+  A ();\n+  ~A () {\n+    if (I) delete I;\n+  }\n+\n+private:\n+  int* I;\n+};\n+\n+bool get_url (A *);\n+bool get_url2 (A *);\n+bool get_url3 (A *);\n+\n+class M {\n+\n+ public:\n+ __attribute__ ((always_inline))\n+ bool GetC (int *c)  {\n+\n+    A details_str;\n+\n+    /* Initialization path 1  */\n+    if (get_url (&details_str))\n+      {\n+        *c = get_time ();\n+        return true;\n+      }\n+\n+    /* Destructor call before return*/\n+    A tmp_str;\n+\n+    /* Initialization path 2  */\n+    if (get_url2 (&details_str))\n+      {\n+        *c = get_time ();\n+        return true;\n+      }\n+\n+    /* Fail to initialize in this path but\n+       still returns true  */\n+    if (get_url2 (&details_str))\n+      {\n+        /* Fail to initialize *c  */\n+        return true;\n+      }\n+\n+    return false;\n+  }\n+\n+  void do_sth();\n+  void do_sth2();\n+\n+  void P (int64 t)\n+    {\n+      int cc; /* { dg-excess-errors \"note: 'cc' was declared here\" } */\n+      if (!GetC (&cc))\n+        return;\n+\n+      if (cc <= 0)   /* { dg-warning \"uninitialized\" \"uninitialized variable warning\" } */\n+        {\n+          this->do_sth();\n+          return;\n+        }\n+\n+    do_sth2();\n+  }\n+};\n+\n+M* m;\n+void test(int x)\n+{\n+  m = new M;\n+  m->P(x);\n+}"}, {"sha": "01ff43165d3ea9cb34529ce2b2b3e09c4196abc3", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 145, "deletions": 42, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2edb37a65e4b043f00de9c28d6076058b236cbaa/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2edb37a65e4b043f00de9c28d6076058b236cbaa/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=2edb37a65e4b043f00de9c28d6076058b236cbaa", "patch": "@@ -785,6 +785,139 @@ is_use_properly_guarded (gimple use_stmt,\n                          unsigned uninit_opnds,\n                          struct pointer_set_t *visited_phis);\n \n+/* Returns true if all uninitialized opnds are pruned. Returns false\n+   otherwise. PHI is the phi node with uninitialized operands,\n+   UNINIT_OPNDS is the bitmap of the uninitialize operand positions,\n+   FLAG_DEF is the statement defining the flag guarding the use of the\n+   PHI output, BOUNDARY_CST is the const value used in the predicate\n+   associated with the flag, CMP_CODE is the comparison code used in\n+   the predicate, VISITED_PHIS is the pointer set of phis visited, and\n+   VISITED_FLAG_PHIS is the pointer to the pointer set of flag definitions\n+   that are also phis.\n+\n+   Example scenario:\n+\n+   BB1:\n+   flag_1 = phi <0, 1>                  // (1)\n+   var_1  = phi <undef, some_val>\n+\n+\n+   BB2:\n+   flag_2 = phi <0,   flag_1, flag_1>   // (2)\n+   var_2  = phi <undef, var_1, var_1>\n+   if (flag_2 == 1)\n+      goto BB3;\n+\n+   BB3:\n+   use of var_2                         // (3)\n+\n+   Because some flag arg in (1) is not constant, if we do not look into the\n+   flag phis recursively, it is conservatively treated as unknown and var_1\n+   is thought to be flowed into use at (3). Since var_1 is potentially uninitialized\n+   a false warning will be emitted. Checking recursively into (1), the compiler can\n+   find out that only some_val (which is defined) can flow into (3) which is OK.\n+\n+*/\n+\n+static bool\n+prune_uninit_phi_opnds_in_unrealizable_paths (\n+    gimple phi, unsigned uninit_opnds,\n+    gimple flag_def, tree boundary_cst,\n+    enum tree_code cmp_code,\n+    struct pointer_set_t *visited_phis,\n+    bitmap *visited_flag_phis)\n+{\n+  unsigned i;\n+\n+  for (i = 0; i < MIN (32, gimple_phi_num_args (flag_def)); i++)\n+    {\n+      tree flag_arg;\n+\n+      if (!MASK_TEST_BIT (uninit_opnds, i))\n+        continue;\n+\n+      flag_arg = gimple_phi_arg_def (flag_def, i);\n+      if (!is_gimple_constant (flag_arg))\n+        {\n+          gimple flag_arg_def, phi_arg_def;\n+          tree phi_arg;\n+          unsigned uninit_opnds_arg_phi;\n+\n+          if (TREE_CODE (flag_arg) != SSA_NAME)\n+            return false;\n+          flag_arg_def = SSA_NAME_DEF_STMT (flag_arg);\n+          if (gimple_code (flag_arg_def) != GIMPLE_PHI)\n+            return false;\n+\n+          phi_arg = gimple_phi_arg_def (phi, i);\n+          if (TREE_CODE (phi_arg) != SSA_NAME)\n+            return false;\n+\n+          phi_arg_def = SSA_NAME_DEF_STMT (phi_arg);\n+          if (gimple_code (phi_arg_def) != GIMPLE_PHI)\n+            return false;\n+\n+          if (gimple_bb (phi_arg_def) != gimple_bb (flag_arg_def))\n+            return false;\n+\n+          if (!*visited_flag_phis)\n+            *visited_flag_phis = BITMAP_ALLOC (NULL);\n+\n+          if (bitmap_bit_p (*visited_flag_phis,\n+                            SSA_NAME_VERSION (gimple_phi_result (flag_arg_def))))\n+            return false;\n+\n+          bitmap_set_bit (*visited_flag_phis,\n+                          SSA_NAME_VERSION (gimple_phi_result (flag_arg_def)));\n+\n+          /* Now recursively prune the uninitialized phi args.  */\n+          uninit_opnds_arg_phi = compute_uninit_opnds_pos (phi_arg_def);\n+          if (!prune_uninit_phi_opnds_in_unrealizable_paths (\n+                  phi_arg_def, uninit_opnds_arg_phi,\n+                  flag_arg_def, boundary_cst, cmp_code,\n+                  visited_phis, visited_flag_phis))\n+            return false;\n+\n+          bitmap_clear_bit (*visited_flag_phis,\n+                            SSA_NAME_VERSION (gimple_phi_result (flag_arg_def)));\n+          continue;\n+        }\n+\n+      /* Now check if the constant is in the guarded range.  */\n+      if (is_value_included_in (flag_arg, boundary_cst, cmp_code))\n+        {\n+          tree opnd;\n+          gimple opnd_def;\n+\n+          /* Now that we know that this undefined edge is not\n+             pruned. If the operand is defined by another phi,\n+             we can further prune the incoming edges of that\n+             phi by checking the predicates of this operands.  */\n+\n+          opnd = gimple_phi_arg_def (phi, i);\n+          opnd_def = SSA_NAME_DEF_STMT (opnd);\n+          if (gimple_code (opnd_def) == GIMPLE_PHI)\n+            {\n+              edge opnd_edge;\n+              unsigned uninit_opnds2\n+                  = compute_uninit_opnds_pos (opnd_def);\n+              gcc_assert (!MASK_EMPTY (uninit_opnds2));\n+              opnd_edge = gimple_phi_arg_edge (phi, i);\n+              if (!is_use_properly_guarded (phi,\n+                                            opnd_edge->src,\n+                                            opnd_def,\n+                                            uninit_opnds2,\n+                                            visited_phis))\n+                  return false;\n+            }\n+          else\n+            return false;\n+        }\n+    }\n+\n+  return true;\n+}\n+\n /* A helper function that determines if the predicate set\n    of the use is not overlapping with that of the uninit paths.\n    The most common senario of guarded use is in Example 1:\n@@ -873,6 +1006,8 @@ use_pred_not_overlap_with_undef_path_pred (\n   bool swap_cond = false;\n   bool invert = false;\n   VEC(use_pred_info_t, heap) *the_pred_chain;\n+  bitmap visited_flag_phis = NULL;\n+  bool all_pruned = false;\n \n   gcc_assert (num_preds > 0);\n   /* Find within the common prefix of multiple predicate chains\n@@ -935,50 +1070,18 @@ use_pred_not_overlap_with_undef_path_pred (\n   if (cmp_code == ERROR_MARK)\n     return false;\n \n-  for (i = 0; i < sizeof (unsigned); i++)\n-    {\n-      tree flag_arg;\n-\n-      if (!MASK_TEST_BIT (uninit_opnds, i))\n-        continue;\n-\n-      flag_arg = gimple_phi_arg_def (flag_def, i);\n-      if (!is_gimple_constant (flag_arg))\n-        return false;\n-\n-      /* Now check if the constant is in the guarded range.  */\n-      if (is_value_included_in (flag_arg, boundary_cst, cmp_code))\n-        {\n-          tree opnd;\n-          gimple opnd_def;\n-\n-          /* Now that we know that this undefined edge is not\n-             pruned. If the operand is defined by another phi,\n-             we can further prune the incoming edges of that\n-             phi by checking the predicates of this operands.  */\n+  all_pruned = prune_uninit_phi_opnds_in_unrealizable_paths (phi,\n+                                                             uninit_opnds,\n+                                                             flag_def,\n+                                                             boundary_cst,\n+                                                             cmp_code,\n+                                                             visited_phis,\n+                                                             &visited_flag_phis);\n \n-          opnd = gimple_phi_arg_def (phi, i);\n-          opnd_def = SSA_NAME_DEF_STMT (opnd);\n-          if (gimple_code (opnd_def) == GIMPLE_PHI)\n-            {\n-              edge opnd_edge;\n-              unsigned uninit_opnds2\n-                  = compute_uninit_opnds_pos (opnd_def);\n-              gcc_assert (!MASK_EMPTY (uninit_opnds2));\n-              opnd_edge = gimple_phi_arg_edge (phi, i);\n-              if (!is_use_properly_guarded (phi,\n-                                            opnd_edge->src,\n-                                            opnd_def,\n-                                            uninit_opnds2,\n-                                            visited_phis))\n-                  return false;\n-            }\n-          else\n-            return false;\n-        }\n-    }\n+  if (visited_flag_phis)\n+    BITMAP_FREE (visited_flag_phis);\n \n-  return true;\n+  return all_pruned;\n }\n \n /* Returns true if TC is AND or OR */"}]}