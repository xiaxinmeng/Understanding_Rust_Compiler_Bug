{"sha": "a82e1b5569dab500cc4d77635549f59f057aac49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTgyZTFiNTU2OWRhYjUwMGNjNGQ3NzYzNTU0OWY1OWYwNTdhYWM0OQ==", "commit": {"author": {"name": "Brendan Kehoe", "email": "brendan@lisa.cygnus.com", "date": "1996-04-17T19:18:01Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-04-17T19:18:01Z"}, "message": "(handle_cp_pragma): New function, with decl, doing the cc1plus pragmas.\n\n(handle_cp_pragma): New function, with decl, doing the cc1plus\npragmas.\n(check_newline): Put the vtable/unit/implementation/interface pragma\ncode into handle_cp_pragma, replacing it with a call.\n(handle_sysv_pragma): Give int return type, and take FINPUT and TOKEN\nargs.  Get the next token after handling the pragma token.\n\nFrom-SVN: r11842", "tree": {"sha": "e9e8189ee982690ee4703dad35c1285935cb4c04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9e8189ee982690ee4703dad35c1285935cb4c04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a82e1b5569dab500cc4d77635549f59f057aac49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a82e1b5569dab500cc4d77635549f59f057aac49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a82e1b5569dab500cc4d77635549f59f057aac49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a82e1b5569dab500cc4d77635549f59f057aac49/comments", "author": null, "committer": null, "parents": [{"sha": "78f308f51e2138b775182d2d4b09f53f96ec6175", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78f308f51e2138b775182d2d4b09f53f96ec6175", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78f308f51e2138b775182d2d4b09f53f96ec6175"}], "stats": {"total": 479, "additions": 239, "deletions": 240}, "files": [{"sha": "d59932dd8f9759c482c1901e72dd689601176b10", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 239, "deletions": 240, "changes": 479, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82e1b5569dab500cc4d77635549f59f057aac49/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82e1b5569dab500cc4d77635549f59f057aac49/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=a82e1b5569dab500cc4d77635549f59f057aac49", "patch": "@@ -1865,6 +1865,8 @@ get_last_nonwhite_on_line ()\n \n int linemode;\n \n+int handle_cp_pragma ();\n+\n int\n check_newline ()\n {\n@@ -1909,251 +1911,36 @@ check_newline ()\n \t      && getch () == 'm'\n \t      && getch () == 'a')\n \t    {\n-\t      /* Read first nonwhite char after the `#pragma'.  */\n-\n-\t      do\n+\t      c = getch ();\n+\t      while (c == ' ' || c == '\\t')\n \t\tc = getch ();\n-\t      while (c == ' ' || c == '\\t');\n-\n-\t      if (c == 'v'\n-\t\t  && getch () == 't'\n-\t\t  && getch () == 'a'\n-\t\t  && getch () == 'b'\n-\t\t  && getch () == 'l'\n-\t\t  && getch () == 'e'\n-\t\t  && ((c = getch ()) == ' ' || c == '\\t'))\n-\t\t{\n-\t\t  extern tree pending_vtables;\n-\n-\t\t  /* More follows: it must be a string constant (class name).  */\n-\t\t  token = real_yylex ();\n-\t\t  if (token != STRING || TREE_CODE (yylval.ttype) != STRING_CST)\n-\t\t    {\n-\t\t      error (\"invalid #pragma vtable\");\n-\t\t      goto skipline;\n-\t\t    }\n-\t\t  if (write_virtuals != 2)\n-\t\t    {\n-\t\t      warning (\"use `+e2' option to enable #pragma vtable\");\n-\t\t      goto skipline;\n-\t\t    }\n-\t\t  pending_vtables = perm_tree_cons (NULL_TREE, get_identifier (TREE_STRING_POINTER (yylval.ttype)), pending_vtables);\n-\t\t  if (nextchar < 0)\n-\t\t    nextchar = getch ();\n-\t\t  c = nextchar;\n-\t\t  if (c != EOF)\n-\t\t    warning (\"trailing characters ignored\");\n-\t\t}\n-\t      else if (c == 'u'\n-\t\t       && getch () == 'n'\n-\t\t       && getch () == 'i'\n-\t\t       && getch () == 't'\n-\t\t       && ((c = getch ()) == ' ' || c == '\\t'))\n+\t      put_back (c);\n+\t      if (c == '\\n' || c == EOF)\n+\t\tgoto skipline;\n+\t      token = real_yylex ();\n+\t      if (token == IDENTIFIER\n+\t\t  && TREE_CODE (yylval.ttype) == IDENTIFIER_NODE)\n \t\t{\n-\t\t  /* More follows: it must be a string constant (unit name).  */\n-\t\t  token = real_yylex ();\n-\t\t  if (token != STRING || TREE_CODE (yylval.ttype) != STRING_CST)\n-\t\t    {\n-\t\t      error (\"invalid #pragma unit\");\n-\t\t      goto skipline;\n-\t\t    }\n-\t\t  if (nextchar < 0)\n-\t\t    nextchar = getch ();\n-\t\t  c = nextchar;\n-\t\t  if (c != EOF)\n-\t\t    warning (\"trailing characters ignored\");\n+\t\t  /* If this is 1, we handled it; if it's -1, it was one we\n+\t\t     wanted but had something wrong with it.  Only if it's\n+\t\t     0 was it not handled.  */\n+\t\t  if (handle_cp_pragma (IDENTIFIER_POINTER (yylval.ttype)))\n+\t\t    goto skipline;\n \t\t}\n-\t      else if (c == 'i')\n-\t\t{\n-\t\t  tree fileinfo = IDENTIFIER_CLASS_VALUE (get_time_identifier (input_filename));\n-\t\t  c = getch ();\n-\n-\t\t  if (c == 'n'\n-\t\t      && getch () == 't'\n-\t\t      && getch () == 'e'\n-\t\t      && getch () == 'r'\n-\t\t      && getch () == 'f'\n-\t\t      && getch () == 'a'\n-\t\t      && getch () == 'c'\n-\t\t      && getch () == 'e'\n-\t\t      && ((c = getch ()) == ' ' || c == '\\t' || c == EOF))\n-\t\t    {\n-\t\t      int warned_already = 0;\n-\t\t      char *main_filename = input_filename;\n-\n-\t\t      main_filename = FILE_NAME_NONDIRECTORY (main_filename);\n-\t\t      while (c == ' ' || c == '\\t')\n-\t\t\tc = getch ();\n-\t\t      if (c != EOF)\n-\t\t\t{\n-\t\t\t  put_back (c);\n-\t\t\t  token = real_yylex ();\n-\t\t\t  if (token != STRING\n-\t\t\t      || TREE_CODE (yylval.ttype) != STRING_CST)\n-\t\t\t    {\n-\t\t\t      error (\"invalid `#pragma interface'\");\n-\t\t\t      goto skipline;\n-\t\t\t    }\n-\t\t\t  main_filename = TREE_STRING_POINTER (yylval.ttype);\n-\t\t\t  c = getch ();\n-\t\t\t  put_back (c);\n-\t\t\t}\n-\n-\t\t      while (c == ' ' || c == '\\t')\n-\t\t\tc = getch ();\n-\n-\t\t      while (c != EOF)\n-\t\t\t{\n-\t\t\t  if (!warned_already && extra_warnings\n-\t\t\t      && c != ' ' && c != '\\t')\n-\t\t\t    {\n-\t\t\t      warning (\"garbage after `#pragma interface' ignored\");\n-\t\t\t      warned_already = 1;\n-\t\t\t    }\n-\t\t\t  c = getch ();\n-\t\t\t}\n-\n-\t\t      write_virtuals = 3;\n-\n-\t\t      if (impl_file_chain == 0)\n-\t\t\t{\n-\t\t\t  /* If this is zero at this point, then we are\n-\t\t\t     auto-implementing.  */\n-\t\t\t  if (main_input_filename == 0)\n-\t\t\t    main_input_filename = input_filename;\n-\n-#ifdef AUTO_IMPLEMENT\n-\t\t\t  filename = FILE_NAME_NONDIRECTORY (main_input_filename);\n-\t\t\t  fi = get_time_identifier (filename);\n-\t\t\t  fi = IDENTIFIER_CLASS_VALUE (fi);\n-\t\t\t  TREE_INT_CST_LOW (fi) = 0;\n-\t\t\t  TREE_INT_CST_HIGH (fi) = 1;\n-\t\t\t  /* Get default.  */\n-\t\t\t  impl_file_chain = (struct impl_files *)permalloc (sizeof (struct impl_files));\n-\t\t\t  impl_file_chain->filename = filename;\n-\t\t\t  impl_file_chain->next = 0;\n-#endif\n-\t\t\t}\n-\n-\t\t      interface_only = interface_strcmp (main_filename);\n-\t\t      interface_unknown = 0;\n-\t\t      TREE_INT_CST_LOW (fileinfo) = interface_only;\n-\t\t      TREE_INT_CST_HIGH (fileinfo) = interface_unknown;\n-\t\t    }\n-\t\t  else if (c == 'm'\n-\t\t\t   && getch () == 'p'\n-\t\t\t   && getch () == 'l'\n-\t\t\t   && getch () == 'e'\n-\t\t\t   && getch () == 'm'\n-\t\t\t   && getch () == 'e'\n-\t\t\t   && getch () == 'n'\n-\t\t\t   && getch () == 't'\n-\t\t\t   && getch () == 'a'\n-\t\t\t   && getch () == 't'\n-\t\t\t   && getch () == 'i'\n-\t\t\t   && getch () == 'o'\n-\t\t\t   && getch () == 'n'\n-\t\t\t   && ((c = getch ()) == ' ' || c == '\\t' || c == EOF))\n-\t\t    {\n-\t\t      int warned_already = 0;\n-\t\t      char *main_filename = main_input_filename ? main_input_filename : input_filename;\n-\n-\t\t      main_filename = FILE_NAME_NONDIRECTORY (main_filename);\n-\t\t      while (c == ' ' || c == '\\t')\n-\t\t\tc = getch ();\n-\t\t      if (c != EOF)\n-\t\t\t{\n-\t\t\t  put_back (c);\n-\t\t\t  token = real_yylex ();\n-\t\t\t  if (token != STRING\n-\t\t\t      || TREE_CODE (yylval.ttype) != STRING_CST)\n-\t\t\t    {\n-\t\t\t      error (\"invalid `#pragma implementation'\");\n-\t\t\t      goto skipline;\n-\t\t\t    }\n-\t\t\t  main_filename = TREE_STRING_POINTER (yylval.ttype);\n-\t\t\t  c = getch ();\n-\t\t\t  put_back (c);\n-\t\t\t}\n-\n-\t\t      while (c == ' ' || c == '\\t')\n-\t\t\tc = getch ();\n-\n-\t\t      while (c != EOF)\n-\t\t\t{\n-\t\t\t  if (!warned_already && extra_warnings\n-\t\t\t      && c != ' ' && c != '\\t')\n-\t\t\t    {\n-\t\t\t      warning (\"garbage after `#pragma implementation' ignored\");\n-\t\t\t      warned_already = 1;\n-\t\t\t    }\n-\t\t\t  c = getch ();\n-\t\t\t}\n+\t      else if (token == END_OF_LINE)\n+\t\tgoto skipline;\n \n-\t\t      if (write_virtuals == 3)\n-\t\t\t{\n-\t\t\t  struct impl_files *ifiles = impl_file_chain;\n-\t\t\t  while (ifiles)\n-\t\t\t    {\n-\t\t\t      if (! strcmp (ifiles->filename, main_filename))\n-\t\t\t\tbreak;\n-\t\t\t      ifiles = ifiles->next;\n-\t\t\t    }\n-\t\t\t  if (ifiles == 0)\n-\t\t\t    {\n-\t\t\t      ifiles = (struct impl_files*) permalloc (sizeof (struct impl_files));\n-\t\t\t      ifiles->filename = main_filename;\n-\t\t\t      ifiles->next = impl_file_chain;\n-\t\t\t      impl_file_chain = ifiles;\n-\t\t\t    }\n-\t\t\t}\n-\t\t      else if ((main_input_filename != 0\n-\t\t\t\t&& ! strcmp (main_input_filename, input_filename))\n-\t\t\t       || ! strcmp (input_filename, main_filename))\n-\t\t\t{\n-\t\t\t  write_virtuals = 3;\n-\t\t\t  if (impl_file_chain == 0)\n-\t\t\t    {\n-\t\t\t      impl_file_chain = (struct impl_files*) permalloc (sizeof (struct impl_files));\n-\t\t\t      impl_file_chain->filename = main_filename;\n-\t\t\t      impl_file_chain->next = 0;\n-\t\t\t    }\n-\t\t\t}\n-\t\t      else\n-\t\t\terror (\"`#pragma implementation' can only appear at top-level\");\n-\t\t      interface_only = 0;\n-#if 1\n-\t\t      /* We make this non-zero so that we infer decl linkage\n-\t\t\t in the impl file only for variables first declared\n-\t\t\t in the interface file.  */\n-\t\t      interface_unknown = 1;\n-#else\n-\t\t      /* We make this zero so that templates in the impl\n-                         file will be emitted properly. */\n-\t\t      interface_unknown = 0;\n-#endif\n-\t\t      TREE_INT_CST_LOW (fileinfo) = interface_only;\n-\t\t      TREE_INT_CST_HIGH (fileinfo) = interface_unknown;\n-\t\t    }\n-\t\t}\n #ifdef HANDLE_SYSV_PRAGMA\n-\t      else\n-\t\t{\n-\t\t  put_back (c);\n-\t\t  handle_sysv_pragma ();\n-\t\t}\n+\t      if (handle_sysv_pragma (finput, token))\n+\t\tgoto skipline;\n #else\n #ifdef HANDLE_PRAGMA\n-\t      /* FIXME: This will break if we're doing any of the C++ input\n-                 tricks.  */\n-\t      else\n-\t\t{\n-\t\t  c = HANDLE_PRAGMA (finput, c);\n-\t\t}\n+\t      if (HANDLE_PRAGMA (finput, yylval.ttype))\n+\t\tgoto skipline;\n #endif\n #endif\n-\t      goto skipline;\n \t    }\n+\t  goto skipline;\n \t}\n       else if (c == 'd')\n \t{\n@@ -4597,6 +4384,210 @@ yyerror (string)\n   error (buf, token_buffer);\n }\n \f\n+int\n+handle_cp_pragma (pname)\n+     char *pname;\n+{\n+  register int token;\n+  register int c;\n+\n+  if (! strcmp (pname, \"vtable\"))\n+    {\n+      extern tree pending_vtables;\n+\n+      /* More follows: it must be a string constant (class name).  */\n+      token = real_yylex ();\n+      if (token != STRING || TREE_CODE (yylval.ttype) != STRING_CST)\n+\t{\n+\t  error (\"invalid #pragma vtable\");\n+\t  return -1;\n+\t}\n+\n+      if (write_virtuals != 2)\n+\t{\n+\t  warning (\"use `+e2' option to enable #pragma vtable\");\n+\t  return -1;\n+\t}\n+      pending_vtables\n+\t= perm_tree_cons (NULL_TREE,\n+\t\t\t  get_identifier (TREE_STRING_POINTER (yylval.ttype)),\n+\t\t\t  pending_vtables);\n+      if (nextchar < 0)\n+\tnextchar = getch ();\n+      c = nextchar;\n+      if (c != EOF)\n+\twarning (\"trailing characters ignored\");\n+      return 1;\n+    }\n+  else if (! strcmp (pname, \"unit\"))\n+    {\n+      /* More follows: it must be a string constant (unit name).  */\n+      token = real_yylex ();\n+      if (token != STRING || TREE_CODE (yylval.ttype) != STRING_CST)\n+\t{\n+\t  error (\"invalid #pragma unit\");\n+\t  return -1;\n+\t}\n+      if (nextchar < 0)\n+\tnextchar = getch ();\n+      c = nextchar;\n+      if (c != EOF)\n+\twarning (\"trailing characters ignored\");\n+      return 1;\n+    }\n+  else if (! strcmp (pname, \"interface\"))\n+    {\n+      tree fileinfo = IDENTIFIER_CLASS_VALUE (get_time_identifier (input_filename));\n+      int warned_already = 0;\n+      char *main_filename = input_filename;\n+\n+      main_filename = FILE_NAME_NONDIRECTORY (main_filename);\n+\n+      do\n+\t{\n+\t  c = getch ();\n+\t} while (c == ' ' || c == '\\t');\n+\n+      if (c != EOF)\n+\t{\n+\t  put_back (c);\n+\t  token = real_yylex ();\n+\t  if (token != STRING\n+\t      || TREE_CODE (yylval.ttype) != STRING_CST)\n+\t    {\n+\t      error (\"invalid `#pragma interface'\");\n+\t      return -1;\n+\t    }\n+\t  main_filename = TREE_STRING_POINTER (yylval.ttype);\n+\t  c = getch();\n+\t  put_back (c);\n+\n+\t  while (c == ' ' || c == '\\t')\n+\t    c = getch ();\n+\n+\t  while (c != EOF)\n+\t    {\n+\t      if (!warned_already && extra_warnings\n+\t\t  && c != ' ' && c != '\\t')\n+\t\t{\n+\t\t  warning (\"garbage after `#pragma interface' ignored\");\n+\t\t  warned_already = 1;\n+\t\t}\n+\t      c = getch ();\n+\t    }\n+\n+\t  write_virtuals = 3;\n+\n+\t  if (impl_file_chain == 0)\n+\t    {\n+\t      /* If this is zero at this point, then we are\n+\t\t auto-implementing.  */\n+\t      if (main_input_filename == 0)\n+\t\tmain_input_filename = input_filename;\n+\n+#ifdef AUTO_IMPLEMENT\n+\t      filename = FILE_NAME_NONDIRECTORY (main_input_filename);\n+\t      fi = get_time_identifier (filename);\n+\t      fi = IDENTIFIER_CLASS_VALUE (fi);\n+\t      TREE_INT_CST_LOW (fi) = 0;\n+\t      TREE_INT_CST_HIGH (fi) = 1;\n+\t      /* Get default.  */\n+\t      impl_file_chain = (struct impl_files *)permalloc (sizeof (struct impl_files));\n+\t      impl_file_chain->filename = filename;\n+\t      impl_file_chain->next = 0;\n+#endif\n+\t    }\n+\t}\n+\n+      interface_only = interface_strcmp (main_filename);\n+      interface_unknown = 0;\n+      TREE_INT_CST_LOW (fileinfo) = interface_only;\n+      TREE_INT_CST_HIGH (fileinfo) = interface_unknown;\n+\n+      return 1;\n+    }\n+  else if (! strcmp (pname, \"implementation\"))\n+    {\n+      tree fileinfo = IDENTIFIER_CLASS_VALUE (get_time_identifier (input_filename));\n+      int warned_already = 0;\n+      char *main_filename = main_input_filename ? main_input_filename : input_filename;\n+\n+      main_filename = FILE_NAME_NONDIRECTORY (main_filename);\n+      token = real_yylex ();\n+      if (token != STRING\n+\t  || TREE_CODE (yylval.ttype) != STRING_CST)\n+\t{\n+\t  error (\"invalid `#pragma implementation'\");\n+\t  return -1;\n+\t}\n+      main_filename = TREE_STRING_POINTER (yylval.ttype);\n+      c = getch();\n+      put_back (c);\n+\n+      while (c == ' ' || c == '\\t')\n+\tc = getch ();\n+\n+      while (c != EOF)\n+\t{\n+\t  if (!warned_already && extra_warnings\n+\t      && c != ' ' && c != '\\t')\n+\t    {\n+\t      warning (\"garbage after `#pragma implementation' ignored\");\n+\t      warned_already = 1;\n+\t    }\n+\t  c = getch ();\n+\t}\n+\n+      if (write_virtuals == 3)\n+\t{\n+\t  struct impl_files *ifiles = impl_file_chain;\n+\t  while (ifiles)\n+\t    {\n+\t      if (! strcmp (ifiles->filename, main_filename))\n+\t\tbreak;\n+\t      ifiles = ifiles->next;\n+\t    }\n+\t  if (ifiles == 0)\n+\t    {\n+\t      ifiles = (struct impl_files*) permalloc (sizeof (struct impl_files));\n+\t      ifiles->filename = main_filename;\n+\t      ifiles->next = impl_file_chain;\n+\t      impl_file_chain = ifiles;\n+\t    }\n+\t}\n+      else if ((main_input_filename != 0\n+\t\t&& ! strcmp (main_input_filename, input_filename))\n+\t       || ! strcmp (input_filename, main_filename))\n+\t{\n+\t  write_virtuals = 3;\n+\t  if (impl_file_chain == 0)\n+\t    {\n+\t      impl_file_chain = (struct impl_files*) permalloc (sizeof (struct impl_files));\n+\t      impl_file_chain->filename = main_filename;\n+\t      impl_file_chain->next = 0;\n+\t    }\n+\t}\n+      else\n+\terror (\"`#pragma implementation' can only appear at top-level\");\n+      interface_only = 0;\n+#if 1\n+      /* We make this non-zero so that we infer decl linkage\n+\t in the impl file only for variables first declared\n+\t in the interface file.  */\n+      interface_unknown = 1;\n+#else\n+      /* We make this zero so that templates in the impl\n+\t file will be emitted properly. */\n+      interface_unknown = 0;\n+#endif\n+      TREE_INT_CST_LOW (fileinfo) = interface_only;\n+      TREE_INT_CST_HIGH (fileinfo) = interface_unknown;\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\f\n #ifdef HANDLE_SYSV_PRAGMA\n \n /* Handle a #pragma directive.  INPUT is the current input stream,\n@@ -4605,43 +4596,51 @@ yyerror (string)\n \n /* This function has to be in this file, in order to get at\n    the token types.  */\n-\n-handle_sysv_pragma ()\n+int\n+handle_sysv_pragma (finput, token)\n+     FILE *finput;\n+     register int token;\n {\n   for (;;)\n     {\n-      switch (yylex ())\n+      switch (token)\n \t{\n \tcase IDENTIFIER:\n \tcase TYPENAME:\n \tcase STRING:\n \tcase CONSTANT:\n \t  handle_pragma_token (\"ignored\", yylval.ttype);\n+\t  token = yylex ();\n \t  break;\n \tcase '(':\n \t  handle_pragma_token (\"(\", NULL_TREE);\n+\t  token = yylex ();\n \t  break;\n \tcase ')':\n \t  handle_pragma_token (\")\", NULL_TREE);\n+\t  token = yylex ();\n \t  break;\n \tcase ',':\n \t  handle_pragma_token (\",\", NULL_TREE);\n+\t  token = yylex ();\n \t  break;\n \tcase '=':\n \t  handle_pragma_token (\"=\", NULL_TREE);\n+\t  token = yylex ();\n \t  break;\n \tcase LEFT_RIGHT:\n \t  handle_pragma_token (\"(\", NULL_TREE);\n \t  handle_pragma_token (\")\", NULL_TREE);\n+\t  token = yylex ();\n \t  break;\n \tcase END_OF_LINE:\n \t  handle_pragma_token (NULL_PTR, NULL_TREE);\n-\t  return;\n+\t  return 1;\n \tdefault:\n \t  handle_pragma_token (NULL_PTR, NULL_TREE);\n \t  while (yylex () != END_OF_LINE)\n \t    /* continue */;\n-\t  return;\n+\t  return 1;\n \t}\n     }\n }"}]}