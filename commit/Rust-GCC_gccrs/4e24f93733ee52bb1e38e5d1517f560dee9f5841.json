{"sha": "4e24f93733ee52bb1e38e5d1517f560dee9f5841", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGUyNGY5MzczM2VlNTJiYjFlMzhlNWQxNTE3ZjU2MGRlZTlmNTg0MQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-12-20T22:54:26Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-12-20T22:54:26Z"}, "message": "2003-12-20  Michael Koch  <konqueror@gmx.de>\n\n\t* gnu/java/net/protocol/jar/Connection.java\n\t(connectionCache): New field.\n\t(connect): New method.\n\t(getInputStream): New method.\n\t(hdrHash): New field.\n\t(hdrVec): New field.\n\t(gotHeaders): New field.\n\t(getHeaderField): New method.\n\t(getHeaderFields): New method.\n\t(getHeaderFieldKey): New method.\n\t(getKey): New method.\n\t(getField): New method.\n\t(getHeaders): New method.\n\t* java/net/JarURLConnection.java\n\t(connectionCache): Removed.\n\t(connect): Removed.\n\t(getInputStream): Removed.\n\t(hdrHash): Removed.\n\t(hdrVec): Removed.\n\t(gotHeaders): Removed.\n\t(getHeaderField): Removed.\n\t(getHeaderFields): Removed.\n\t(getHeaderFieldKey): Removed.\n\t(getKey): Removed.\n\t(getField): Removed.\n\t(getHeaders): Removed.\n\nFrom-SVN: r74895", "tree": {"sha": "baad7842970f8dc0bdc488f3c0165a56f4edf055", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/baad7842970f8dc0bdc488f3c0165a56f4edf055"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e24f93733ee52bb1e38e5d1517f560dee9f5841", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e24f93733ee52bb1e38e5d1517f560dee9f5841", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e24f93733ee52bb1e38e5d1517f560dee9f5841", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e24f93733ee52bb1e38e5d1517f560dee9f5841/comments", "author": null, "committer": null, "parents": [{"sha": "70d26e8152ceae744a8add22da6dd6326286f739", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70d26e8152ceae744a8add22da6dd6326286f739", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70d26e8152ceae744a8add22da6dd6326286f739"}], "stats": {"total": 486, "additions": 258, "deletions": 228}, "files": [{"sha": "25a1f80ab45e6c2f1376907adf08a3f5903f2483", "filename": "libjava/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e24f93733ee52bb1e38e5d1517f560dee9f5841/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e24f93733ee52bb1e38e5d1517f560dee9f5841/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=4e24f93733ee52bb1e38e5d1517f560dee9f5841", "patch": "@@ -1,3 +1,32 @@\n+2003-12-20  Michael Koch  <konqueror@gmx.de>\n+\n+\t* gnu/java/net/protocol/jar/Connection.java\n+\t(connectionCache): New field.\n+\t(connect): New method.\n+\t(getInputStream): New method.\n+\t(hdrHash): New field.\n+\t(hdrVec): New field.\n+\t(gotHeaders): New field.\n+\t(getHeaderField): New method.\n+\t(getHeaderFields): New method.\n+\t(getHeaderFieldKey): New method.\n+\t(getKey): New method.\n+\t(getField): New method.\n+\t(getHeaders): New method.\n+\t* java/net/JarURLConnection.java\n+\t(connectionCache): Removed.\n+\t(connect): Removed.\n+\t(getInputStream): Removed.\n+\t(hdrHash): Removed.\n+\t(hdrVec): Removed.\n+\t(gotHeaders): Removed.\n+\t(getHeaderField): Removed.\n+\t(getHeaderFields): Removed.\n+\t(getHeaderFieldKey): Removed.\n+\t(getKey): Removed.\n+\t(getField): Removed.\n+\t(getHeaders): Removed.\n+\n 2003-12-20  Michael Koch  <konqueror@gmx.de>\n \n \t* java/io/ObjectStreamField.java (isUnshared): Added documentation."}, {"sha": "af4903d78ab6f709164e1afe9739b7d2fdb34585", "filename": "libjava/gnu/java/net/protocol/jar/Connection.java", "status": "modified", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e24f93733ee52bb1e38e5d1517f560dee9f5841/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fjar%2FConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e24f93733ee52bb1e38e5d1517f560dee9f5841/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fjar%2FConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fjar%2FConnection.java?ref=4e24f93733ee52bb1e38e5d1517f560dee9f5841", "patch": "@@ -38,6 +38,8 @@\n \n package gnu.java.net.protocol.jar;\n \n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayInputStream;\n import java.io.File;\n import java.io.FileOutputStream;\n import java.io.InputStream;\n@@ -47,9 +49,15 @@\n import java.net.ProtocolException;\n import java.net.URL;\n import java.net.URLConnection;\n+import java.util.Map;\n+import java.util.Vector;\n+import java.util.HashMap;\n import java.util.Hashtable;\n import java.util.jar.JarFile;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarInputStream;\n import java.util.zip.ZipFile;\n+import java.util.zip.ZipEntry;\n \n /**\n  * This subclass of java.net.JarURLConnection models a URLConnection via\n@@ -62,12 +70,109 @@ public final class Connection extends JarURLConnection\n   private static Hashtable file_cache = new Hashtable();\n   private JarFile jar_file;\n \n+  /**\n+   * Cached JarURLConnection objects .\n+   */\n+  static HashMap connectionCache = new HashMap();\n+\n   protected Connection(URL url)\n     throws MalformedURLException\n   {\n     super(url);\n   }\n \n+  public synchronized void connect() throws IOException\n+  {\n+    // Call is ignored if already connected.\n+    if (connected)\n+      return;\n+\n+    if (getUseCaches())\n+      {\n+\tjarFileURLConnection =\n+          (URLConnection) connectionCache.get(getJarFileURL());\n+\n+\tif (jarFileURLConnection == null)\n+\t  {\n+\t    jarFileURLConnection = getJarFileURL().openConnection();\n+\t    jarFileURLConnection.setUseCaches(true);\n+\t    jarFileURLConnection.connect();\n+\t    connectionCache.put(getJarFileURL(), jarFileURLConnection);\n+\t  }\n+      }\n+    else\n+      {\n+\tjarFileURLConnection = getJarFileURL().openConnection();\n+\tjarFileURLConnection.connect();\n+      }\n+\n+    connected = true;\n+  }\n+\n+  public InputStream getInputStream() throws IOException\n+  {\n+    if (!connected)\n+      connect();\n+\n+    if (! doInput)\n+      throw new ProtocolException(\"Can't open InputStream if doInput is false\");\n+\n+    if (getEntryName() == null)\n+      {\n+\t// This is a JarURLConnection for the entire jar file.  \n+\n+\tInputStream in = new BufferedInputStream\n+\t  (jarFileURLConnection.getInputStream());\n+\treturn new JarInputStream(in);\n+      }\n+\n+    // Reaching this point, we're looking for an entry of a jar file.\n+\n+    JarFile jarfile = null;\n+\n+    try\n+      {\n+\tjarfile = getJarFile ();\n+      }\n+    catch (IOException x)\n+      {\n+\t/* ignore */\n+      }\n+    \n+    if (jarfile != null)\n+      {\n+\t// this is the easy way...\n+\tZipEntry entry = jarfile.getEntry(getEntryName());\n+        \n+\tif (entry != null)\n+\t  return jarfile.getInputStream (entry);\n+\telse\n+\t  return null;\n+      }\n+    else\n+      {\n+\t// If the jar file is not local, ...\n+\tJarInputStream zis = new JarInputStream(\n+\t\t\tjarFileURLConnection.getInputStream ());\n+\n+\t// This is hideous, we're doing a linear search...\n+\tfor (ZipEntry entry = zis.getNextEntry(); \n+\t     entry != null; \n+\t     entry = zis.getNextEntry())\n+\t  {\n+\t    if (getEntryName().equals(entry.getName()))\n+\t      {\n+\t\tint size = (int) entry.getSize();\n+\t\tbyte[] data = new byte[size];\n+\t\tzis.read (data, 0, size);\n+\t\treturn new ByteArrayInputStream (data);\n+\t      }\n+\t  }\n+      }\n+\n+    return null;\n+  }\n+\n   public synchronized JarFile getJarFile() throws IOException\n   {\n     if (!connected)\n@@ -116,4 +221,128 @@ public synchronized JarFile getJarFile() throws IOException\n     return jar_file;\n   }\n \n+  // Steal and borrow from protocol/file/Connection.java\n+\n+  private Hashtable hdrHash = new Hashtable();\n+  private Vector hdrVec = new Vector();\n+  private boolean gotHeaders = false;\n+\n+  // Override default method in URLConnection.\n+  public String getHeaderField(String name)\n+  {\n+    try\n+      {\n+\tgetHeaders();\n+      }\n+    catch (IOException x)\n+      {\n+\treturn null;\n+      }\n+    return (String) hdrHash.get(name.toLowerCase());\n+  }\n+\n+  // Override default method in URLConnection.\n+  public Map getHeaderFields()\n+  {\n+    try\n+      {\n+        getHeaders();\n+      }\n+    catch (IOException x)\n+      {\n+        return null;\n+      }\n+    return hdrHash;\n+  }\n+\n+  // Override default method in URLConnection.\n+  public String getHeaderField(int n)\n+  {\n+    try\n+      {\n+\tgetHeaders();\n+      }\n+    catch (IOException x)\n+      {\n+\treturn null;\n+      }\n+    if (n < hdrVec.size())\n+      return getField((String) hdrVec.elementAt(n));\n+\n+    return null;\n+  }\n+\n+  // Override default method in URLConnection.\n+  public String getHeaderFieldKey(int n)\n+  {\n+    try\n+      {\n+\tgetHeaders();\n+      }\n+    catch (IOException x)\n+      {\n+\treturn null;\n+      }\n+    if (n < hdrVec.size())\n+      return getKey((String) hdrVec.elementAt(n));\n+\n+    return null;\n+  }\n+\n+  private String getKey(String str)\n+  {\n+    if (str == null)\n+      return null;\n+    int index = str.indexOf(':');\n+    if (index >= 0)\n+      return str.substring(0, index);\n+    else\n+      return null;\n+  }\n+\n+  private String getField(String str)\n+  {\n+    if (str == null)\n+      return null;\n+    int index = str.indexOf(':');\n+    if (index >= 0)\n+      return str.substring(index + 1).trim();\n+    else\n+      return str;\n+  }\n+\n+  private void getHeaders() throws IOException\n+  {\n+    if (gotHeaders)\n+      return;\n+    gotHeaders = true;\n+\n+    connect();\n+\n+    // Yes, it is overkill to use the hash table and vector here since\n+    // we're only putting one header in the file, but in case we need\n+    // to add others later and for consistency, we'll implement it this way.\n+\n+    // Add the only header we know about right now:  Content-length.\n+    long len = -1;\n+\n+    if (getEntryName() == null)\n+      if (jarFileURLConnection != null)\n+\tlen = jarFileURLConnection.getContentLength ();\n+    else\n+      {\n+\tJarEntry entry = getJarEntry();\n+\tif (entry != null)\n+\t  len = entry.getSize ();\n+      }\n+\n+    String line = \"Content-length: \" + len;\n+    hdrVec.addElement(line);\n+\n+    // The key will never be null in this scenario since we build up the\n+    // headers ourselves.  If we ever rely on getting a header from somewhere\n+    // else, then we may have to check if the result of getKey() is null.\n+    String key = getKey(line);\n+    hdrHash.put(key.toLowerCase(), Long.toString(len));\n+  }\n }"}, {"sha": "87d9db36f1c494a21aa1fa674ab7c280bb05e55e", "filename": "libjava/java/net/JarURLConnection.java", "status": "modified", "additions": 0, "deletions": 228, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e24f93733ee52bb1e38e5d1517f560dee9f5841/libjava%2Fjava%2Fnet%2FJarURLConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e24f93733ee52bb1e38e5d1517f560dee9f5841/libjava%2Fjava%2Fnet%2FJarURLConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FJarURLConnection.java?ref=4e24f93733ee52bb1e38e5d1517f560dee9f5841", "patch": "@@ -38,20 +38,13 @@\n \n package java.net;\n \n-import java.io.BufferedInputStream;\n-import java.io.ByteArrayInputStream;\n-import java.io.InputStream;\n import java.io.IOException;\n import java.util.jar.Attributes;\n import java.util.jar.JarEntry;\n import java.util.jar.JarFile;\n import java.util.jar.JarInputStream;\n import java.util.jar.Manifest;\n import java.util.zip.ZipEntry;\n-import java.util.Map;\n-import java.util.Vector;\n-import java.util.HashMap;\n-import java.util.Hashtable;\n import java.security.cert.Certificate;\n \n /**\n@@ -100,11 +93,6 @@ public abstract class JarURLConnection extends URLConnection\n    */\n   private final String entryName;\n \n-  /**\n-   * Cached JarURLConnection objects .\n-   */\n-  static HashMap connectionCache = new HashMap();\n-\n   /**\n    * Creates a JarURLConnection from an URL object\n    *\n@@ -157,97 +145,6 @@ public String getEntryName ()\n     return entryName;\n   }\n \n-  public synchronized void connect() throws IOException\n-  {\n-    // Call is ignored if already connected.\n-    if (connected)\n-      return;\n-\n-    if (getUseCaches())\n-      {\n-\tjarFileURLConnection = (URLConnection) connectionCache.get (jarFileURL);\n-\n-\tif (jarFileURLConnection == null)\n-\t  {\n-\t    jarFileURLConnection = jarFileURL.openConnection ();\n-\t    jarFileURLConnection.setUseCaches (true);\n-\t    jarFileURLConnection.connect ();\n-\t    connectionCache.put (jarFileURL, jarFileURLConnection);\n-\t  }\n-      }\n-    else\n-      {\n-\tjarFileURLConnection = jarFileURL.openConnection ();\n-\tjarFileURLConnection.connect ();\n-      }\n-\n-    connected = true;\n-  }\n-\n-  public InputStream getInputStream() throws IOException\n-  {\n-    if (!connected)\n-      connect();\n-\n-    if (! doInput)\n-      throw new ProtocolException(\"Can't open InputStream if doInput is false\");\n-\n-    if (entryName == null)\n-      {\n-\t// This is a JarURLConnection for the entire jar file.  \n-\n-\tInputStream jar_is = new BufferedInputStream(\n-\t\t\tjarFileURLConnection.getInputStream ());\n-\treturn new JarInputStream(jar_is);\n-      }\n-\n-    // Reaching this point, we're looking for an entry of a jar file.\n-\n-    JarFile jarfile = null;\n-\n-    try\n-      {\n-\tjarfile = getJarFile ();\n-      }\n-    catch (IOException x)\n-      {\n-\t/* ignore */\n-      }\n-    \n-    if (jarfile != null)\n-      {\n-\t// this is the easy way...\n-\tZipEntry entry = jarfile.getEntry (entryName);\n-        \n-\tif (entry != null)\n-\t  return jarfile.getInputStream (entry);\n-\telse\n-\t  return null;\n-      }\n-    else\n-      {\n-\t// If the jar file is not local, ...\n-\tJarInputStream zis = new JarInputStream(\n-\t\t\tjarFileURLConnection.getInputStream ());\n-\n-\t// This is hideous, we're doing a linear search...\n-\tfor (ZipEntry ent = zis.getNextEntry (); \n-\t     ent != null; \n-\t     ent = zis.getNextEntry ())\n-\t  {\n-\t    if (entryName.equals (ent.getName()))\n-\t      {\n-\t\tint size = (int)ent.getSize();\n-\t\tbyte[] data = new byte[size];\n-\t\tzis.read (data, 0, size);\n-\t\treturn new ByteArrayInputStream (data);\n-\t      }\n-\t  }\n-      }\n-\n-    return null;\n-  }\n-\n   /**\n    * Returns the entry in this jar file specified by the URL.  \n    * \n@@ -308,131 +205,6 @@ public JarEntry getJarEntry () throws IOException\n    */\n   public abstract JarFile getJarFile () throws IOException;\n \n-  // Steal and borrow from protocol/file/Connection.java\n-\n-  private Hashtable hdrHash = new Hashtable();\n-  private Vector hdrVec = new Vector();\n-  private boolean gotHeaders = false;\n-\n-  // Override default method in URLConnection.\n-  public String getHeaderField(String name)\n-  {\n-    try\n-      {\n-\tgetHeaders();\n-      }\n-    catch (IOException x)\n-      {\n-\treturn null;\n-      }\n-    return (String) hdrHash.get(name.toLowerCase());\n-  }\n-\n-  // Override default method in URLConnection.\n-  public Map getHeaderFields()\n-  {\n-    try\n-      {\n-        getHeaders();\n-      }\n-    catch (IOException x)\n-      {\n-        return null;\n-      }\n-    return hdrHash;\n-  }\n-\n-  // Override default method in URLConnection.\n-  public String getHeaderField(int n)\n-  {\n-    try\n-      {\n-\tgetHeaders();\n-      }\n-    catch (IOException x)\n-      {\n-\treturn null;\n-      }\n-    if (n < hdrVec.size())\n-      return getField((String) hdrVec.elementAt(n));\n-\n-    return null;\n-  }\n-\n-  // Override default method in URLConnection.\n-  public String getHeaderFieldKey(int n)\n-  {\n-    try\n-      {\n-\tgetHeaders();\n-      }\n-    catch (IOException x)\n-      {\n-\treturn null;\n-      }\n-    if (n < hdrVec.size())\n-      return getKey((String) hdrVec.elementAt(n));\n-\n-    return null;\n-  }\n-\n-  private String getKey(String str)\n-  {\n-    if (str == null)\n-      return null;\n-    int index = str.indexOf(':');\n-    if (index >= 0)\n-      return str.substring(0, index);\n-    else\n-      return null;\n-  }\n-\n-  private String getField(String str)\n-  {\n-    if (str == null)\n-      return null;\n-    int index = str.indexOf(':');\n-    if (index >= 0)\n-      return str.substring(index + 1).trim();\n-    else\n-      return str;\n-  }\n-\n-  private void getHeaders() throws IOException\n-  {\n-    if (gotHeaders)\n-      return;\n-    gotHeaders = true;\n-\n-    connect();\n-\n-    // Yes, it is overkill to use the hash table and vector here since\n-    // we're only putting one header in the file, but in case we need\n-    // to add others later and for consistency, we'll implement it this way.\n-\n-    // Add the only header we know about right now:  Content-length.\n-    long len = -1;\n-\n-    if (entryName == null)\n-      if (jarFileURLConnection != null)\n-\tlen = jarFileURLConnection.getContentLength ();\n-    else\n-      {\n-\tJarEntry entry = getJarEntry();\n-\tif (entry != null)\n-\t  len = entry.getSize ();\n-      }\n-\n-    String line = \"Content-length: \" + len;\n-    hdrVec.addElement(line);\n-\n-    // The key will never be null in this scenario since we build up the\n-    // headers ourselves.  If we ever rely on getting a header from somewhere\n-    // else, then we may have to check if the result of getKey() is null.\n-    String key = getKey(line);\n-    hdrHash.put(key.toLowerCase(), Long.toString(len));\n-  }\n-\n   /**\n    * Returns an array of Certificate objects for the jar file entry specified\n    * by this URL or null if there are none"}]}