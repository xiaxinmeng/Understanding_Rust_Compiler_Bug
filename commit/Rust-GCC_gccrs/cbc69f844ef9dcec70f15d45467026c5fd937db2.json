{"sha": "cbc69f844ef9dcec70f15d45467026c5fd937db2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JjNjlmODQ0ZWY5ZGNlYzcwZjE1ZDQ1NDY3MDI2YzVmZDkzN2RiMg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-06-05T20:27:12Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-06-05T20:27:12Z"}, "message": "cpphash.h (_cpp_create_definition): Update prototype.\n\n\t* cpphash.h (_cpp_create_definition): Update prototype.\n\t(_cpp_push_text_context, _cpp_create_trad_definition): New.\n\t( cpp_lex_identifier_trad): New.\n\t(_cpp_set_trad_context): New.\n\t* cppinit.c (cpp_finish_options): Don't conditionalize builtins.\n\t* cpplib.c (SEEN_EOL): Update.\n\t(lex_macro_node): Update for -traditional.\n\t(cpp_push_buffer, _cpp_pop_buffer): Similarly.\n\t* cppmacro.c (_cpp_create_definition): Split into\n\tcreate_iso_definition() and _cpp_create_trad_definition().\n\t(warn_of_redefinition): Update prototype; handle traditional\n\tmacros.\n\t(_cpp_push_text_context): New.\n\t* cpptrad.c (skip_whitespace, push_replacement_text): New.\n\t(lex_identifier): Call ht_lookup with correct start.\n\t(_cpp_lex_identifier_tradm _cpp_create_trad_definition,\n\t_cpp_set_trad_context): New.\n\t(scan_out_logical_line): Update to handle changing contexts.\n\nFrom-SVN: r54293", "tree": {"sha": "b098c6dcb911ae0a74ccb0f807fc5136f1aaecd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b098c6dcb911ae0a74ccb0f807fc5136f1aaecd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbc69f844ef9dcec70f15d45467026c5fd937db2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbc69f844ef9dcec70f15d45467026c5fd937db2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbc69f844ef9dcec70f15d45467026c5fd937db2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbc69f844ef9dcec70f15d45467026c5fd937db2/comments", "author": null, "committer": null, "parents": [{"sha": "dbf87f32ae756cd4efd33b05003929206169bda3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbf87f32ae756cd4efd33b05003929206169bda3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbf87f32ae756cd4efd33b05003929206169bda3"}], "stats": {"total": 418, "additions": 317, "deletions": 101}, "files": [{"sha": "a51e8cfcced3696886edb8a008da415b6c8da044", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbc69f844ef9dcec70f15d45467026c5fd937db2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbc69f844ef9dcec70f15d45467026c5fd937db2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cbc69f844ef9dcec70f15d45467026c5fd937db2", "patch": "@@ -1,3 +1,24 @@\n+2002-06-05  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpphash.h (_cpp_create_definition): Update prototype.\n+\t(_cpp_push_text_context, _cpp_create_trad_definition): New.\n+\t( cpp_lex_identifier_trad): New.\n+\t(_cpp_set_trad_context): New.\n+\t* cppinit.c (cpp_finish_options): Don't conditionalize builtins.\n+\t* cpplib.c (SEEN_EOL): Update.\n+\t(lex_macro_node): Update for -traditional.\n+\t(cpp_push_buffer, _cpp_pop_buffer): Similarly.\n+\t* cppmacro.c (_cpp_create_definition): Split into\n+\tcreate_iso_definition() and _cpp_create_trad_definition().\n+\t(warn_of_redefinition): Update prototype; handle traditional\n+\tmacros.\n+\t(_cpp_push_text_context): New.\n+\t* cpptrad.c (skip_whitespace, push_replacement_text): New.\n+\t(lex_identifier): Call ht_lookup with correct start.\n+\t(_cpp_lex_identifier_tradm _cpp_create_trad_definition,\n+\t_cpp_set_trad_context): New.\n+\t(scan_out_logical_line): Update to handle changing contexts.\n+\n Wed Jun  5 20:42:31 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n \n \t* config.gcc (sh-*-elf*,  sh64*-*-elf*): Unify."}, {"sha": "e508b80ddcf279ba437cc96333f1ef785c4c8096", "filename": "gcc/cpphash.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbc69f844ef9dcec70f15d45467026c5fd937db2/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbc69f844ef9dcec70f15d45467026c5fd937db2/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=cbc69f844ef9dcec70f15d45467026c5fd937db2", "patch": "@@ -424,8 +424,11 @@ extern int _cpp_begin_message PARAMS ((cpp_reader *, int,\n \n /* In cppmacro.c */\n extern void _cpp_free_definition\tPARAMS ((cpp_hashnode *));\n-extern int _cpp_create_definition\tPARAMS ((cpp_reader *, cpp_hashnode *));\n+extern bool _cpp_create_definition\tPARAMS ((cpp_reader *, cpp_hashnode *));\n extern void _cpp_pop_context\t\tPARAMS ((cpp_reader *));\n+extern void _cpp_push_text_context\tPARAMS ((cpp_reader *, cpp_hashnode *,\n+\t\t\t\t\t\t const uchar *, const uchar*));\n+extern bool _cpp_create_trad_definition PARAMS ((cpp_reader *, cpp_macro *));\n \n /* In cpphash.c */\n extern void _cpp_init_hashtable\t\tPARAMS ((cpp_reader *, hash_table *));\n@@ -478,6 +481,8 @@ extern void _cpp_pop_buffer PARAMS ((cpp_reader *));\n extern bool _cpp_read_logical_line_trad PARAMS ((cpp_reader *));\n extern void _cpp_overlay_buffer PARAMS ((cpp_reader *pfile, const uchar *,\n \t\t\t\t\t size_t));\n+extern cpp_hashnode *_cpp_lex_identifier_trad PARAMS ((cpp_reader *));\n+extern void _cpp_set_trad_context PARAMS ((cpp_reader *));\n \n /* Utility routines and macros.  */\n #define DSC(str) (const uchar *)str, sizeof str - 1"}, {"sha": "9d6a105852a7f4c6e3bbb76767f91b589409b25b", "filename": "gcc/cppinit.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbc69f844ef9dcec70f15d45467026c5fd937db2/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbc69f844ef9dcec70f15d45467026c5fd937db2/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=cbc69f844ef9dcec70f15d45467026c5fd937db2", "patch": "@@ -995,12 +995,10 @@ cpp_finish_options (pfile)\n       struct pending_option *p;\n \n       _cpp_do_file_change (pfile, LC_RENAME, _(\"<built-in>\"), 1, 0);\n-      if (!CPP_OPTION (pfile, traditional) /* REMOVEME */)\n-\tinit_builtins (pfile);\n+      init_builtins (pfile);\n       _cpp_do_file_change (pfile, LC_RENAME, _(\"<command line>\"), 1, 0);\n-      if (!CPP_OPTION (pfile, traditional) /* REMOVEME */)\n-\tfor (p = CPP_OPTION (pfile, pending)->directive_head; p; p = p->next)\n-\t  (*p->handler) (pfile, p->arg);\n+      for (p = CPP_OPTION (pfile, pending)->directive_head; p; p = p->next)\n+\t(*p->handler) (pfile, p->arg);\n \n       /* Scan -imacros files after -D, -U, but before -include.\n \t pfile->next_include_file is NULL, so _cpp_pop_buffer does not"}, {"sha": "acc6f111f4730d23f1125d4f261c6ba5ea8f2547", "filename": "gcc/cpplib.c", "status": "modified", "additions": 38, "deletions": 28, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbc69f844ef9dcec70f15d45467026c5fd937db2/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbc69f844ef9dcec70f15d45467026c5fd937db2/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=cbc69f844ef9dcec70f15d45467026c5fd937db2", "patch": "@@ -202,7 +202,8 @@ static const directive linemarker_dir =\n   do_linemarker, U\"#\", 1, KANDR, IN_I\n };\n \n-#define SEEN_EOL() (pfile->cur_token[-1].type == CPP_EOF)\n+#define SEEN_EOL() (CPP_OPTION (pfile, traditional) \\\n+\t\t    || pfile->cur_token[-1].type == CPP_EOF)\n \n /* Skip any remaining tokens in a directive.  */\n static void\n@@ -447,7 +448,6 @@ lex_macro_node (pfile)\n      cpp_reader *pfile;\n {\n   cpp_hashnode *node;\n-  const cpp_token *token = _cpp_lex_token (pfile);\n \n   /* The token immediately after #define must be an identifier.  That\n      identifier may not be \"defined\", per C99 6.10.8p4.\n@@ -459,39 +459,43 @@ lex_macro_node (pfile)\n      Note that if we're copying comments into macro expansions, we\n      could encounter comment tokens here, so eat them all up first.  */\n \n-  if (! CPP_OPTION (pfile, discard_comments_in_macro_exp))\n+  if (CPP_OPTION (pfile, traditional))\n+    node = _cpp_lex_identifier_trad (pfile);\n+  else\n     {\n-      while (token->type == CPP_COMMENT)\n-\ttoken = _cpp_lex_token (pfile);\n-    }\n+      const cpp_token *token = _cpp_lex_token (pfile);\n+\n+      if (! CPP_OPTION (pfile, discard_comments_in_macro_exp))\n+\t{\n+\t  while (token->type == CPP_COMMENT)\n+\t    token = _cpp_lex_token (pfile);\n+\t}\n \n-  if (token->type != CPP_NAME)\n-    {\n       if (token->type == CPP_EOF)\n-\tcpp_error (pfile, DL_ERROR, \"no macro name given in #%s directive\",\n-\t\t   pfile->directive->name);\n-      else if (token->flags & NAMED_OP)\n-\tcpp_error (pfile, DL_ERROR,\n-\t   \"\\\"%s\\\" cannot be used as a macro name as it is an operator in C++\",\n-\t\t   NODE_NAME (token->val.node));\n+\t{\n+\t  cpp_error (pfile, DL_ERROR, \"no macro name given in #%s directive\",\n+\t\t     pfile->directive->name);\n+\t  return NULL;\n+\t}\n+\t\n+      if (token->type == CPP_NAME || (token->flags & NAMED_OP))\n+\tnode = token->val.node;\n       else\n-\tcpp_error (pfile, DL_ERROR, \"macro names must be identifiers\");\n-\n-      return 0;\n+\tnode = NULL;\n     }\n \n-  node = token->val.node;\n-  if (node->flags & NODE_POISONED)\n-    return 0;\n-\n-  if (node == pfile->spec_nodes.n_defined)\n-    {\n-      cpp_error (pfile, DL_ERROR, \"\\\"%s\\\" cannot be used as a macro name\",\n-\t\t NODE_NAME (node));\n-      return 0;\n-    }\n+  if (!node)\n+    cpp_error (pfile, DL_ERROR, \"macro names must be identifiers\");\n+  else if (node->flags & NODE_OPERATOR)\n+    cpp_error (pfile, DL_ERROR,\n+       \"\\\"%s\\\" cannot be used as a macro name as it is an operator in C++\",\n+\t       NODE_NAME (node));\n+  else if (node == pfile->spec_nodes.n_defined)\n+    cpp_error (pfile, DL_ERROR, \"\\\"defined\\\" cannot be used as a macro name\");\n+  else if (! (node->flags & NODE_POISONED))\n+    return node;\n \n-  return node;\n+  return NULL;\n }\n \n /* Process a #define directive.  Most work is done in cppmacro.c.  */\n@@ -1890,6 +1894,9 @@ cpp_push_buffer (pfile, buffer, len, from_stage3, return_at_eof)\n \n   pfile->buffer = new;\n \n+  if (CPP_OPTION (pfile, traditional))\n+    _cpp_set_trad_context (pfile);\n+\n   return new;\n }\n \n@@ -1934,6 +1941,9 @@ _cpp_pop_buffer (pfile)\n \t    _cpp_maybe_push_include_file (pfile);\n \t}\n     }\n+\n+  if (pfile->buffer && CPP_OPTION (pfile, traditional))\n+    _cpp_set_trad_context (pfile);\n }\n \n /* Enter all recognised directives in the hash table.  */"}, {"sha": "0b1f0ffc9fea351d5e6bd79c92cfe37549a17e2d", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 93, "deletions": 59, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbc69f844ef9dcec70f15d45467026c5fd937db2/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbc69f844ef9dcec70f15d45467026c5fd937db2/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=cbc69f844ef9dcec70f15d45467026c5fd937db2", "patch": "@@ -62,13 +62,14 @@ static bool paste_tokens PARAMS ((cpp_reader *, const cpp_token **,\n static void replace_args PARAMS ((cpp_reader *, cpp_hashnode *, cpp_macro *,\n \t\t\t\t  macro_arg *));\n static _cpp_buff *funlike_invocation_p PARAMS ((cpp_reader *, cpp_hashnode *));\n+static bool create_iso_definition PARAMS ((cpp_reader *, cpp_macro *));\n \n /* #define directive parsing and handling.  */\n \n static cpp_token *alloc_expansion_token PARAMS ((cpp_reader *, cpp_macro *));\n static cpp_token *lex_expansion_token PARAMS ((cpp_reader *, cpp_macro *));\n-static int warn_of_redefinition PARAMS ((const cpp_hashnode *,\n-\t\t\t\t\t const cpp_macro *));\n+static bool warn_of_redefinition PARAMS ((cpp_reader *, const cpp_hashnode *,\n+\t\t\t\t\t  const cpp_macro *));\n static int save_parameter PARAMS ((cpp_reader *, cpp_macro *, cpp_hashnode *));\n static int parse_params PARAMS ((cpp_reader *, cpp_macro *));\n static void check_trad_stringification PARAMS ((cpp_reader *,\n@@ -917,6 +918,22 @@ push_token_context (pfile, macro, first, count)\n   LAST (context).token = first + count;\n }\n \n+/* Push a traditional macro's replacement text.  */\n+void\n+_cpp_push_text_context (pfile, macro, start, end)\n+     cpp_reader *pfile;\n+     cpp_hashnode *macro;\n+     const uchar *start, *end;\n+{\n+  cpp_context *context = next_context (pfile);\n+\n+  context->direct_p = true;\n+  context->macro = macro;\n+  context->buff = NULL;\n+  CUR (context) = start;\n+  RLIMIT (context) = end;\n+}\n+\n /* Expand an argument ARG before replacing parameters in a\n    function-like macro.  This works by pushing a context with the\n    argument's tokens, and then expanding that into a temporary buffer\n@@ -1127,8 +1144,9 @@ _cpp_backup_tokens (pfile, count)\n /* #define directive parsing and handling.  */\n \n /* Returns non-zero if a macro redefinition warning is required.  */\n-static int\n-warn_of_redefinition (node, macro2)\n+static bool\n+warn_of_redefinition (pfile, node, macro2)\n+     cpp_reader *pfile;\n      const cpp_hashnode *node;\n      const cpp_macro *macro2;\n {\n@@ -1137,7 +1155,7 @@ warn_of_redefinition (node, macro2)\n \n   /* Some redefinitions need to be warned about regardless.  */\n   if (node->flags & NODE_WARN)\n-    return 1;\n+    return true;\n \n   /* Redefinition of a macro is allowed if and only if the old and new\n      definitions are the same.  (6.10.3 paragraph 2).  */\n@@ -1148,19 +1166,22 @@ warn_of_redefinition (node, macro2)\n       || macro1->paramc != macro2->paramc\n       || macro1->fun_like != macro2->fun_like\n       || macro1->variadic != macro2->variadic)\n-    return 1;\n-\n-  /* Check each token.  */\n-  for (i = 0; i < macro1->count; i++)\n-    if (! _cpp_equiv_tokens (&macro1->exp.tokens[i], &macro2->exp.tokens[i]))\n-      return 1;\n+    return true;\n \n   /* Check parameter spellings.  */\n   for (i = 0; i < macro1->paramc; i++)\n     if (macro1->params[i] != macro2->params[i])\n-      return 1;\n+      return true;\n \n-  return 0;\n+  /* Check the replacement text or tokens.  */\n+  if (CPP_OPTION (pfile, traditional))\n+    return memcmp (macro1->exp.text, macro2->exp.text, macro1->count);\n+\n+  for (i = 0; i < macro1->count; i++)\n+    if (!_cpp_equiv_tokens (&macro1->exp.tokens[i], &macro2->exp.tokens[i]))\n+      return true;\n+\n+  return false;\n }\n \n /* Free the definition of hashnode H.  */\n@@ -1316,35 +1337,24 @@ lex_expansion_token (pfile, macro)\n   return token;\n }\n \n-/* Parse a macro and save its expansion.  Returns non-zero on success.  */\n-int\n-_cpp_create_definition (pfile, node)\n+static bool\n+create_iso_definition (pfile, macro)\n      cpp_reader *pfile;\n-     cpp_hashnode *node;\n+     cpp_macro *macro;\n {\n-  cpp_macro *macro;\n-  cpp_token *token, *saved_cur_token;\n+  cpp_token *token;\n   const cpp_token *ctoken;\n-  unsigned int i, ok = 1;\n-\n-  macro = (cpp_macro *) _cpp_aligned_alloc (pfile, sizeof (cpp_macro));\n-  macro->line = pfile->directive_line;\n-  macro->params = 0;\n-  macro->paramc = 0;\n-  macro->variadic = 0;\n-  macro->count = 0;\n-  macro->fun_like = 0;\n \n   /* Get the first token of the expansion (or the '(' of a\n      function-like macro).  */\n   ctoken = _cpp_lex_token (pfile);\n \n   if (ctoken->type == CPP_OPEN_PAREN && !(ctoken->flags & PREV_WHITE))\n     {\n-      ok = parse_params (pfile, macro);\n+      bool ok = parse_params (pfile, macro);\n       macro->params = (cpp_hashnode **) BUFF_FRONT (pfile->a_buff);\n       if (!ok)\n-\tgoto cleanup2;\n+\treturn false;\n \n       /* Success.  Commit the parameter array.  */\n       BUFF_FRONT (pfile->a_buff) = (uchar *) &macro->params[macro->paramc];\n@@ -1354,8 +1364,6 @@ _cpp_create_definition (pfile, node)\n     cpp_error (pfile, DL_PEDWARN,\n \t       \"ISO C requires whitespace after the macro name\");\n \n-  saved_cur_token = pfile->cur_token;\n-\n   if (macro->fun_like)\n     token = lex_expansion_token (pfile, macro);\n   else\n@@ -1381,10 +1389,9 @@ _cpp_create_definition (pfile, node)\n \t  /* Let assembler get away with murder.  */\n \t  else if (CPP_OPTION (pfile, lang) != CLK_ASM)\n \t    {\n-\t      ok = 0;\n \t      cpp_error (pfile, DL_ERROR,\n \t\t\t \"'#' is not followed by a macro parameter\");\n-\t      goto cleanup1;\n+\t      return false;\n \t    }\n \t}\n \n@@ -1401,10 +1408,9 @@ _cpp_create_definition (pfile, node)\n \n \t  if (macro->count == 0 || token->type == CPP_EOF)\n \t    {\n-\t      ok = 0;\n \t      cpp_error (pfile, DL_ERROR,\n \t\t\t \"'##' cannot appear at either end of a macro expansion\");\n-\t      goto cleanup1;\n+\t      return false;\n \t    }\n \n \t  token[-1].flags |= PASTE_LEFT;\n@@ -1425,25 +1431,68 @@ _cpp_create_definition (pfile, node)\n   /* Commit the memory.  */\n   BUFF_FRONT (pfile->a_buff) = (uchar *) &macro->exp.tokens[macro->count];\n \n-  /* Implement the macro-defined-to-itself optimisation.  */\n-  if (macro->count == 1 && !macro->fun_like\n-      && macro->exp.tokens[0].type == CPP_NAME\n-      && macro->exp.tokens[0].val.node == node)\n-    node->flags |= NODE_DISABLED;\n+  return true;\n+}\n+\n+/* Parse a macro and save its expansion.  Returns non-zero on success.  */\n+bool\n+_cpp_create_definition (pfile, node)\n+     cpp_reader *pfile;\n+     cpp_hashnode *node;\n+{\n+  cpp_macro *macro;\n+  unsigned int i;\n+  bool ok;\n \n+  macro = (cpp_macro *) _cpp_aligned_alloc (pfile, sizeof (cpp_macro));\n+  macro->line = pfile->directive_line;\n+  macro->params = 0;\n+  macro->paramc = 0;\n+  macro->variadic = 0;\n+  macro->count = 0;\n+  macro->fun_like = 0;\n   /* To suppress some diagnostics.  */\n   macro->syshdr = pfile->map->sysp != 0;\n \n+  if (CPP_OPTION (pfile, traditional))\n+    ok = _cpp_create_trad_definition (pfile, macro);\n+  else\n+    {\n+      cpp_token *saved_cur_token = pfile->cur_token;\n+\n+      ok = create_iso_definition (pfile, macro);\n+\n+      /* Restore lexer position because of games lex_expansion_token()\n+\t plays lexing the macro.  We set the type for SEEN_EOL() in\n+\t cpplib.c.\n+\n+\t Longer term we should lex the whole line before coming here,\n+\t and just copy the expansion.  */\n+      saved_cur_token[-1].type = pfile->cur_token[-1].type;\n+      pfile->cur_token = saved_cur_token;\n+\n+      /* Stop the lexer accepting __VA_ARGS__.  */\n+      pfile->state.va_args_ok = 0;\n+    }\n+\n+  /* Clear the fast argument lookup indices.  */\n+  for (i = macro->paramc; i-- > 0; )\n+    macro->params[i]->arg_index = 0;\n+\n+  if (!ok)\n+    return ok;\n+\n   if (node->type != NT_VOID)\n     {\n-      if (warn_of_redefinition (node, macro))\n+      if (warn_of_redefinition (pfile, node, macro))\n \t{\n \t  cpp_error_with_line (pfile, DL_PEDWARN, pfile->directive_line, 0,\n \t\t\t       \"\\\"%s\\\" redefined\", NODE_NAME (node));\n \n \t  if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN))\n-\t    cpp_error_with_line (pfile, DL_PEDWARN, node->value.macro->line, 0,\n-\t\t\t    \"this is the location of the previous definition\");\n+\t    cpp_error_with_line (pfile, DL_PEDWARN,\n+\t\t\t\t node->value.macro->line, 0,\n+\t\t\t \"this is the location of the previous definition\");\n \t}\n       _cpp_free_definition (node);\n     }\n@@ -1454,21 +1503,6 @@ _cpp_create_definition (pfile, node)\n   if (! ustrncmp (NODE_NAME (node), DSC (\"__STDC_\")))\n     node->flags |= NODE_WARN;\n \n- cleanup1:\n-\n-  /* Set type for SEEN_EOL() in cpplib.c, restore the lexer position.  */\n-  saved_cur_token[-1].type = pfile->cur_token[-1].type;\n-  pfile->cur_token = saved_cur_token;\n-\n- cleanup2:\n-\n-  /* Stop the lexer accepting __VA_ARGS__.  */\n-  pfile->state.va_args_ok = 0;\n-\n-  /* Clear the fast argument lookup indices.  */\n-  for (i = macro->paramc; i-- > 0; )\n-    macro->params[i]->arg_index = 0;\n-\n   return ok;\n }\n "}, {"sha": "6397248733323a3e845161c51920b1ae6dc60166", "filename": "gcc/cpptrad.c", "status": "modified", "additions": 156, "deletions": 8, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbc69f844ef9dcec70f15d45467026c5fd937db2/gcc%2Fcpptrad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbc69f844ef9dcec70f15d45467026c5fd937db2/gcc%2Fcpptrad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpptrad.c?ref=cbc69f844ef9dcec70f15d45467026c5fd937db2", "patch": "@@ -23,16 +23,19 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n /* Lexing TODO: Handle -C, maybe -CC, and space in escaped newlines.\n    Stop cpplex.c from recognizing comments and directives during its\n-   lexing pass.  Get rid of line_base usage - seems pointless?  */\n+   lexing pass.  Get rid of line_base usage - seems pointless?  Do we\n+   get escaped newline at EOF correct?  */\n \n static const uchar *handle_newline PARAMS ((cpp_reader *, const uchar *));\n static const uchar *skip_escaped_newlines PARAMS ((cpp_reader *,\n \t\t\t\t\t\t   const uchar *));\n+static const uchar *skip_whitespace PARAMS ((cpp_reader *, const uchar *));\n static cpp_hashnode *lex_identifier PARAMS ((cpp_reader *, const uchar *));\n static const uchar *skip_comment PARAMS ((cpp_reader *, const uchar *));\n static void scan_out_logical_line PARAMS ((cpp_reader *pfile));\n static void check_output_buffer PARAMS ((cpp_reader *, size_t));\n static void restore_buff PARAMS ((cpp_reader *));\n+static void push_replacement_text PARAMS ((cpp_reader *, cpp_hashnode *));\n \n /* Ensures we have N bytes' space in the output buffer, and\n    reallocates it if not.  */\n@@ -118,6 +121,47 @@ skip_comment (pfile, cur)\n   return cur;\n }\n \n+/* Skip any horizontal whitespace and comments beginning at CUR,\n+   returning the following character.  */\n+static const uchar *\n+skip_whitespace (pfile, cur)\n+     cpp_reader *pfile;\n+     const uchar *cur;\n+{\n+  const uchar *tmp;\n+\n+  for (;;)\n+    {\n+      while (is_nvspace (*cur) && *cur != 0)\n+\tcur++;\n+\n+      if (*cur == '\\0' && cur != RLIMIT (pfile->context))\n+\tcontinue;\n+\n+      if (*cur == '\\\\')\n+\t{\n+\t  tmp = cur;\n+\t  cur = skip_escaped_newlines (pfile, cur);\n+\t  if (tmp != cur)\n+\t    continue;\n+\t}\n+\n+      if (*cur == '/')\n+\t{\n+\t  tmp = skip_escaped_newlines (pfile, cur + 1);\n+\t  if (*tmp == '*')\n+\t    {\n+\t      cur = skip_comment (pfile, tmp + 1);\n+\t      continue;\n+\t    }\n+\t}\n+\n+      break;\n+    }\n+\n+  return cur;\n+}\n+\n /* Lexes and outputs an identifier starting at CUR, which is assumed\n    to point to a valid first character of an identifier.  Returns\n    the hashnode, and updates trad_out_cur.  */\n@@ -128,6 +172,7 @@ lex_identifier (pfile, cur)\n {\n   size_t len;\n   uchar *out = pfile->trad_out_cur;\n+  cpp_hashnode *result;\n \n   do\n     {\n@@ -140,9 +185,27 @@ lex_identifier (pfile, cur)\n \n   CUR (pfile->context) = cur;\n   len = out - pfile->trad_out_cur;\n+  result = (cpp_hashnode *) ht_lookup (pfile->hash_table, pfile->trad_out_cur,\n+\t\t\t\t       len, HT_ALLOC);\n   pfile->trad_out_cur = out;\n-  return (cpp_hashnode *) ht_lookup (pfile->hash_table, pfile->trad_out_cur,\n-\t\t\t\t     len, HT_ALLOC);\n+  return result;\n+}\n+\n+/* Reads an identifier, returning its hashnode.  If the next token is\n+   not an identifier, returns NULL.  */\n+cpp_hashnode *\n+_cpp_lex_identifier_trad (pfile)\n+     cpp_reader *pfile;\n+{\n+  const uchar *cur = skip_whitespace (pfile, CUR (pfile->context));\n+\n+  if (!ISIDST (*cur))\n+    {\n+      CUR (pfile->context) = cur;\n+      return NULL;\n+    }\n+\n+  return lex_identifier (pfile, cur);\n }\n \n /* Overlays the true file buffer temporarily with text of length LEN\n@@ -226,11 +289,14 @@ static void\n scan_out_logical_line (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_context *context = pfile->context;\n-  const uchar *cur = CUR (context);\n+  cpp_context *context;\n+  const uchar *cur;\n   unsigned int c, quote = 0;\n   uchar *out;\n \n+ new_context:\n+  context = pfile->context;\n+  cur = CUR (context);\n   check_output_buffer (pfile, RLIMIT (context) - cur);\n   out = pfile->trad_out_cur;\n \n@@ -246,6 +312,16 @@ scan_out_logical_line (pfile)\n \tcase '\\0':\n \t  if (cur - 1 != RLIMIT (context))\n \t    break;\n+\n+\t  /* If this is a macro's expansion, pop it.  */\n+\t  if (context->prev)\n+\t    {\n+\t      pfile->trad_out_cur = out - 1;\n+\t      _cpp_pop_context (pfile);\n+\t      goto new_context;\n+\t    }\n+\n+\t  /* Premature end of file.  Fake a new line.  */\n \t  cur--;\n \t  if (!pfile->buffer->from_stage3)\n \t    cpp_error (pfile, DL_PEDWARN, \"no newline at end of file\");\n@@ -254,11 +330,10 @@ scan_out_logical_line (pfile)\n \n \tcase '\\r': case '\\n':\n \t  cur = handle_newline (pfile, cur - 1);\n+\t  out[-1] = '\\0';\n \tfinish_output:\n-\t  out[-1] = '\\n';\n-\t  out[0] = '\\0';\n \t  CUR (context) = cur;\n-\t  pfile->trad_out_cur = out;\n+\t  pfile->trad_out_cur = out - 1;\n \t  return;\n \n \tcase '\"':\n@@ -309,6 +384,13 @@ scan_out_logical_line (pfile)\n \n \t    pfile->trad_out_cur = --out;\n \t    node = lex_identifier (pfile, cur - 1);\n+\t    if (node->type == NT_MACRO)\n+\t      {\n+\t\t/* Remove the macro name from the output.  */\n+\t\tpfile->trad_out_cur = out;\n+\t\tpush_replacement_text (pfile, node);\n+\t\tgoto new_context;\n+\t      }\n \t    out = pfile->trad_out_cur;\n \t    cur = CUR (context);\n \t  }\n@@ -319,3 +401,69 @@ scan_out_logical_line (pfile)\n \t}\n     }\n }\n+\n+/* Push a context holding the replacement text of the macro NODE on\n+   the context stack.  Doesn't yet handle special built-ins or\n+   function-like macros.  */\n+static void\n+push_replacement_text (pfile, node)\n+     cpp_reader *pfile;\n+     cpp_hashnode *node;\n+{\n+  cpp_macro *macro = node->value.macro;\n+\n+  _cpp_push_text_context (pfile, node,\n+\t\t\t  macro->exp.text,\n+\t\t\t  macro->exp.text + macro->count);\n+}\n+\n+/* Analyze and save the replacement text of a macro.  */\n+bool\n+_cpp_create_trad_definition (pfile, macro)\n+     cpp_reader *pfile;\n+     cpp_macro *macro;\n+{\n+  const uchar *cur, *limit;\n+  uchar *exp;\n+  size_t len;\n+\n+  /* Skip leading whitespace now.  */\n+  CUR (pfile->context) = skip_whitespace (pfile, CUR (pfile->context));\n+\n+  pfile->trad_out_cur = pfile->trad_out_base;\n+  scan_out_logical_line (pfile);\n+\n+  /* Skip trailing white space.  */\n+  cur = pfile->trad_out_base;\n+  limit = pfile->trad_out_cur;\n+  while (limit > cur && is_space (limit[-1]))\n+    limit--;\n+\n+  len = (size_t) (limit - cur);\n+  exp = _cpp_unaligned_alloc (pfile, len + 1);\n+  memcpy (exp, cur, len);\n+  exp[len] = '\\0';\n+\n+  macro->exp.text = exp;\n+  /* Include NUL.  */\n+  macro->count = len;\n+\n+  return true;\n+}\n+\n+/* Prepare to be able to scan the current buffer.  */\n+void\n+_cpp_set_trad_context (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_buffer *buffer = pfile->buffer;\n+  cpp_context *context = pfile->context;\n+\n+  if (pfile->context->prev)\n+    abort ();\n+\n+  pfile->trad_out_cur = pfile->trad_out_base;\n+  CUR (context) = buffer->cur;\n+  RLIMIT (context) = buffer->rlimit;\n+  check_output_buffer (pfile, RLIMIT (context) - CUR (context));\n+}"}]}