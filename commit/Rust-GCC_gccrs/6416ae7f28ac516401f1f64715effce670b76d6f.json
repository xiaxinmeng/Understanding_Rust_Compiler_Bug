{"sha": "6416ae7f28ac516401f1f64715effce670b76d6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQxNmFlN2YyOGFjNTE2NDAxZjFmNjQ3MTVlZmZjZTY3MGI3NmQ2Zg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2005-12-16T06:09:31Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-12-16T06:09:31Z"}, "message": "basic-block.h, [...]: Fix comment typos.\n\n\t* basic-block.h, config/i386/winnt.c, config/pa/pa.c,\n\tconfig/s390/s390.c, dfp.c, expr.c, fold-const.c, params.def,\n\treload.c, struct-equiv.c, tree-ssa-ccp.c, tree-ssa-pre.c,\n\ttree-ssa-reassoc.c, tree-ssa-structalias.c: Fix comment typos.\n\t* doc/invoke.texi, doc/tm.texi: Fix typos.\n\nFrom-SVN: r108626", "tree": {"sha": "bf3e819caad98dac5bc95062e67178180a96af0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf3e819caad98dac5bc95062e67178180a96af0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6416ae7f28ac516401f1f64715effce670b76d6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6416ae7f28ac516401f1f64715effce670b76d6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6416ae7f28ac516401f1f64715effce670b76d6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6416ae7f28ac516401f1f64715effce670b76d6f/comments", "author": null, "committer": null, "parents": [{"sha": "bcf51da29c8c946e51084946a2307a36a1198529", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcf51da29c8c946e51084946a2307a36a1198529", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcf51da29c8c946e51084946a2307a36a1198529"}], "stats": {"total": 52, "additions": 30, "deletions": 22}, "files": [{"sha": "5af6d55cfc995b07fba6f65e2ab4153075960828", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6416ae7f28ac516401f1f64715effce670b76d6f", "patch": "@@ -1,3 +1,11 @@\n+2005-12-16  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* basic-block.h, config/i386/winnt.c, config/pa/pa.c,\n+\tconfig/s390/s390.c, dfp.c, expr.c, fold-const.c, params.def,\n+\treload.c, struct-equiv.c, tree-ssa-ccp.c, tree-ssa-pre.c,\n+\ttree-ssa-reassoc.c, tree-ssa-structalias.c: Fix comment typos.\n+\t* doc/invoke.texi, doc/tm.texi: Fix typos.\n+\n 2005-12-16  Ben Elliston  <bje@au.ibm.com>\n \n \t* real.c (decimal_quad_format): Correct values for emin, emax."}, {"sha": "c2e4a16dd797f553c62bdea9879b5635d398aa6e", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=6416ae7f28ac516401f1f64715effce670b76d6f", "patch": "@@ -1115,7 +1115,7 @@ struct equiv_info\n      NEED_RERUN is set.  This has to be tested by the caller to re-run\n      the comparison if the match appears otherwise sound.  The state kept in\n      x_start, y_start, equiv_used and check_input_conflict ensures that\n-     we won't loop indefinetly.  */\n+     we won't loop indefinitely.  */\n   bool need_rerun;\n   /* If there is indication of an input conflict at the end,\n      CHECK_INPUT_CONFLICT is set so that we'll check for input conflicts\n@@ -1156,7 +1156,7 @@ struct equiv_info\n      that are being compared.  A final jump insn will not be included.  */\n   rtx x_end, y_end;\n \n-  /* If we are matching tablejumps, X_LABEL in X_BLOCK coresponds to\n+  /* If we are matching tablejumps, X_LABEL in X_BLOCK corresponds to\n      Y_LABEL in Y_BLOCK.  */\n   rtx x_label, y_label;\n "}, {"sha": "d80db9ec6162bedeb7cf80fc1132b0dc0810522f", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=6416ae7f28ac516401f1f64715effce670b76d6f", "patch": "@@ -155,7 +155,7 @@ i386_pe_dllimport_p (tree decl)\n \n   /* The DECL_DLLIMPORT_P flag was set for decls in the class definition\n      by  targetm.cxx.adjust_class_at_definition.  Check again to emit\n-     warnings if the class attribute has been overriden by an\n+     warnings if the class attribute has been overridden by an\n      out-of-class definition.  */\n   if (associated_type (decl)\n       && lookup_attribute (\"dllimport\","}, {"sha": "bb6ac07dd30f629c98faa318c2c24046651874c3", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=6416ae7f28ac516401f1f64715effce670b76d6f", "patch": "@@ -5304,7 +5304,7 @@ output_deferred_plabels (void)\n \n   /* If we have some deferred plabels, then we need to switch into the\n      data or readonly data section, and align it to a 4 byte boundary\n-     before outputing the deferred plabels.  */\n+     before outputting the deferred plabels.  */\n   if (n_deferred_plabels)\n     {\n       switch_to_section (flag_pic ? data_section : readonly_data_section);"}, {"sha": "883e1213cd7bf310c33ac16554c536f86f468861", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=6416ae7f28ac516401f1f64715effce670b76d6f", "patch": "@@ -3998,7 +3998,7 @@ struct alignment_context\n   rtx shift;\t  /* Bit offset with regard to lsb.  */\n   rtx modemask;\t  /* Mask of the HQImode shifted by SHIFT bits.  */\n   rtx modemaski;  /* ~modemask */\n-  bool aligned;\t  /* True if memory is aliged, false else.  */\n+  bool aligned;\t  /* True if memory is aligned, false else.  */\n };\n \n /* A subroutine of s390_expand_cs_hqi and s390_expand_atomic to initialize"}, {"sha": "55c6f2de4f59e7e9675dab4d054ce9e13b6bf2a6", "filename": "gcc/dfp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Fdfp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Fdfp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdfp.c?ref=6416ae7f28ac516401f1f64715effce670b76d6f", "patch": "@@ -333,7 +333,7 @@ decimal_from_binary (REAL_VALUE_TYPE *to, const REAL_VALUE_TYPE *from)\n }\n \n /* Helper function to real.c:do_compare() to handle decimal internal\n-   represenation including when one of the operands is still in the\n+   representation including when one of the operands is still in the\n    binary internal representation.  */\n \n int"}, {"sha": "3dbefc03fe8a1ff10c15e49c0b78d2b8cf38f649", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=6416ae7f28ac516401f1f64715effce670b76d6f", "patch": "@@ -5853,7 +5853,7 @@ A, the growth of unit is 300\\% and yet such inlining is very sane.  For very\n large units consisting of small inlininable functions however the overall unit\n growth limit is needed to avoid exponential explosion of code size.  Thus for\n smaller units, the size is increased to @option{--param large-unit-insns}\n-before aplying @option{--param inline-unit-growth}.  The default is 10000\n+before applying @option{--param inline-unit-growth}.  The default is 10000\n \n @item inline-unit-growth\n Specifies maximal overall growth of the compilation unit caused by inlining."}, {"sha": "ea57dbebaaf9f17e04df4a4928a89c75948a8a1b", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=6416ae7f28ac516401f1f64715effce670b76d6f", "patch": "@@ -3032,7 +3032,7 @@ The final value should conincide with that calculated by\n Normally the CFA is calculated as an offset from the argument pointer,\n via @code{ARG_POINTER_CFA_OFFSET}, but if the argument pointer is \n variable due to the ABI, this may not be possible.  If this macro is\n-defined, it imples that the virtual register instantiation should be\n+defined, it implies that the virtual register instantiation should be\n based on the frame pointer instead of the argument pointer.  Only one\n of @code{FRAME_POINTER_CFA_OFFSET} and @code{ARG_POINTER_CFA_OFFSET}\n should be defined."}, {"sha": "df86a57ee1813780c655a4115706d133e665423b", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6416ae7f28ac516401f1f64715effce670b76d6f", "patch": "@@ -8090,7 +8090,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \telse\n \t  comparison_code = unsignedp ? LEU : LE;\n \n-\t/* Canonicalize to comparsions against 0.  */\n+\t/* Canonicalize to comparisons against 0.  */\n \tif (op1 == const1_rtx)\n \t  {\n \t    /* Converting (a >= 1 ? a : 1) into (a > 0 ? a : 1)"}, {"sha": "33e27af59f0b07840ee14210e830a609650b1ebe", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=6416ae7f28ac516401f1f64715effce670b76d6f", "patch": "@@ -6809,7 +6809,7 @@ fold_unary (enum tree_code code, tree type, tree op0)\n       if (TREE_TYPE (op0) == type)\n \treturn op0;\n       \n-      /* If we have (type) (a CMP b) and type is an integal type, return\n+      /* If we have (type) (a CMP b) and type is an integral type, return\n          new expression involving the new type.  */\n       if (COMPARISON_CLASS_P (op0) && INTEGRAL_TYPE_P (type))\n \treturn fold_build2 (TREE_CODE (op0), type, TREE_OPERAND (op0, 0),\n@@ -8408,7 +8408,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t    }\n \n  \t  /* Optimize tan(x)/sin(x) as 1.0/cos(x) if we don't care about\n-\t     NaNs or Infintes.  */\n+\t     NaNs or Infinities.  */\n  \t  if (((fcode0 == BUILT_IN_TAN && fcode1 == BUILT_IN_SIN)\n  \t       || (fcode0 == BUILT_IN_TANF && fcode1 == BUILT_IN_SINF)\n  \t       || (fcode0 == BUILT_IN_TANL && fcode1 == BUILT_IN_SINL)))"}, {"sha": "7690383e12b96a405dcd4852087dce40ce8711ae", "filename": "gcc/params.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=6416ae7f28ac516401f1f64715effce670b76d6f", "patch": "@@ -321,7 +321,7 @@ DEFPARAM(HOT_BB_FREQUENCY_FRACTION,\n    the other loops cold that is not usually the case.  So we need to artificially\n    flatten the profile.  \n \n-   We need to cut the maximal predicted iterations to large enought iterations\n+   We need to cut the maximal predicted iterations to large enough iterations\n    so the loop appears important, but safely within HOT_BB_COUNT_FRACTION\n    range.  */\n "}, {"sha": "97b2c3be525bce9957a6c5fc001b148da32eb2f5", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=6416ae7f28ac516401f1f64715effce670b76d6f", "patch": "@@ -366,7 +366,7 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n       gcc_assert (insn_data[(int) icode].n_operands == 3);\n \n       /* ??? We currently have no way to represent a reload that needs\n-\t an icode to reload from an intermediate tertiaty reload register.\n+\t an icode to reload from an intermediate tertiary reload register.\n \t We should probably have a new field in struct reload to tag a\n \t chain of scratch operand reloads onto.   */\n       gcc_assert (class == NO_REGS);"}, {"sha": "73ac34c83b78624f54a8613ebd3b15a0b8c0750f", "filename": "gcc/struct-equiv.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Fstruct-equiv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Fstruct-equiv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstruct-equiv.c?ref=6416ae7f28ac516401f1f64715effce670b76d6f", "patch": "@@ -54,7 +54,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    the number of inputs an miss an input conflict.  Sufficient information\n    is gathered so that when we make another pass, we won't have to backtrack\n    at the same point.\n-   Another issue is that information in memory atttributes and/or REG_NOTES\n+   Another issue is that information in memory attributes and/or REG_NOTES\n    might have to be merged or discarded to make a valid match.  We don't want\n    to discard such information when we are not certain that we want to merge\n    the two (partial) blocks.\n@@ -99,7 +99,7 @@ static bool resolve_input_conflict (struct equiv_info *info);\n    SECONDARY_MEMORY_NEEDED, cannot be done directly.  For our purposes, we\n    consider them impossible to generate after reload (even though some\n    might be synthesized when you throw enough code at them).\n-   Since we don't know while procesing a cross-jump if a local register\n+   Since we don't know while processing a cross-jump if a local register\n    that is currently live will eventually be live and thus be an input,\n    we keep track of potential inputs that would require an impossible move\n    by using a prohibitively high cost for them.\n@@ -201,7 +201,7 @@ merge_memattrs (rtx x, rtx y)\n }\n \n /* In SET, assign the bit for the register number of REG the value VALUE.\n-   If REG is a hard register, do so for all its consituent registers.\n+   If REG is a hard register, do so for all its constituent registers.\n    Return the number of registers that have become included (as a positive\n    number) or excluded (as a negative number).  */\n static int\n@@ -1128,7 +1128,7 @@ struct_equiv_block_eq (int mode, struct equiv_info *info)\n \n   if (mode & STRUCT_EQUIV_MATCH_JUMPS)\n     {\n-      /* The caller is expected to have comapred the jumps already, but we\n+      /* The caller is expected to have compared the jumps already, but we\n \t need to match them again to get any local registers and inputs.  */\n       gcc_assert (!info->cur.x_start == !info->cur.y_start);\n       if (info->cur.x_start)"}, {"sha": "b0db349d7ae6d5ebb8ee6a4f5ff8ef7ba743545d", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=6416ae7f28ac516401f1f64715effce670b76d6f", "patch": "@@ -276,7 +276,7 @@ debug_lattice_value (prop_value_t val)\n /* The regular is_gimple_min_invariant does a shallow test of the object.\n    It assumes that full gimplification has happened, or will happen on the\n    object.  For a value coming from DECL_INITIAL, this is not true, so we\n-   have to be more strict outselves.  */\n+   have to be more strict ourselves.  */\n \n static bool\n ccp_decl_initial_min_invariant (tree t)"}, {"sha": "eb6e28a1e155bc2347d225a41431530ec49689c5", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=6416ae7f28ac516401f1f64715effce670b76d6f", "patch": "@@ -555,7 +555,7 @@ bitmap_set_copy (bitmap_set_t dest, bitmap_set_t orig)\n   bitmap_copy (dest->values, orig->values);\n }\n \n-/* Perform bitmapped set rperation DEST &= ORIG.  */\n+/* Perform bitmapped set operation DEST &= ORIG.  */\n \n static void\n bitmap_set_and (bitmap_set_t dest, bitmap_set_t orig)"}, {"sha": "edca241ef4033ddd3d8355e88ffa07ac86821f14", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=6416ae7f28ac516401f1f64715effce670b76d6f", "patch": "@@ -69,7 +69,7 @@ Boston, MA 02110-1301, USA.  */\n \n     In order to promote the most redundancy elimination, you want\n     binary expressions whose operands are the same rank (or\n-    preferrably, the same value) exposed to the redundancy eliminator,\n+    preferably, the same value) exposed to the redundancy eliminator,\n     for possible elimination.\n \n     So the way to do this if we really cared, is to build the new op"}, {"sha": "cf307593b3cea70191db2070985d8b5b0483ceb1", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6416ae7f28ac516401f1f64715effce670b76d6f/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=6416ae7f28ac516401f1f64715effce670b76d6f", "patch": "@@ -3294,7 +3294,7 @@ find_func_aliases (tree origt)\n \t  gcc_assert (found);\n \t}\n \n-      /* Assign all the passed arguments to the approriate incoming\n+      /* Assign all the passed arguments to the appropriate incoming\n \t parameters of the function.  */\n       fi = get_varinfo (varid);\n       arglist = TREE_OPERAND (rhsop, 1);\n@@ -3683,7 +3683,7 @@ create_function_info_for (tree decl, const char *name)\n   \n   arg = DECL_ARGUMENTS (decl);\n \n-  /* Set up varirables for each argument.  */\n+  /* Set up variables for each argument.  */\n   for (i = 1; i < vi->fullsize; i++)\n     {      \n       varinfo_t argvi;"}]}