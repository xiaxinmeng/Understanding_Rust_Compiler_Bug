{"sha": "79ae63b183c55dc44a5071ed804c4955adeb99af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzlhZTYzYjE4M2M1NWRjNDRhNTA3MWVkODA0YzQ5NTVhZGViOTlhZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-02-18T20:55:29Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-02-18T20:55:29Z"}, "message": "simplify-rtx.c (simplify_unary_operation): Deal with logicals on floats.\n\n\n\t* simplify-rtx.c (simplify_unary_operation): Deal with logicals on\n\tfloats.\n\t(simplify_binary_operation): Deal with logicals on floats.\n\n\t* i386.md (SSE fabs splitters): Emit new patterns.\n\t(SSE cmov splitters): Likewise.\n\t(sse_andv4sf3, sse_nandv4sf3, sse_iorv4sf3, sse_xorv4sf3\n\t(sse_andv2df3, sse_nandv2df3, sse_iorv2df3, sse_xorv2df3): Do not use\n\tsubregs.\n\t(sse_andsf3, sse_nandsf3, sse_xorsf3): Kill.\n\t(sse_anddf3, sse_nanddf3, sse_xordf3): Kill.\n\nFrom-SVN: r78045", "tree": {"sha": "87138275b980d3c2dbe72a00980ccd6f080eee2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87138275b980d3c2dbe72a00980ccd6f080eee2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79ae63b183c55dc44a5071ed804c4955adeb99af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79ae63b183c55dc44a5071ed804c4955adeb99af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79ae63b183c55dc44a5071ed804c4955adeb99af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79ae63b183c55dc44a5071ed804c4955adeb99af/comments", "author": null, "committer": null, "parents": [{"sha": "01ab55749f71283cfd8416d68c7e34f036b2d51d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01ab55749f71283cfd8416d68c7e34f036b2d51d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01ab55749f71283cfd8416d68c7e34f036b2d51d"}], "stats": {"total": 430, "additions": 241, "deletions": 189}, "files": [{"sha": "313f0cae750c405187426e62fb23c345b268cff8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79ae63b183c55dc44a5071ed804c4955adeb99af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79ae63b183c55dc44a5071ed804c4955adeb99af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79ae63b183c55dc44a5071ed804c4955adeb99af", "patch": "@@ -1,3 +1,17 @@\n+2004-02-18  Jan Hubicka  <jh@suse.cz>\n+\n+\t* simplify-rtx.c (simplify_unary_operation): Deal with logicals on\n+\tfloats.\n+\t(simplify_binary_operation): Deal with logicals on floats.\n+\n+\t* i386.md (SSE fabs splitters): Emit new patterns.\n+\t(SSE cmov splitters): Likewise.\n+\t(sse_andv4sf3, sse_nandv4sf3, sse_iorv4sf3, sse_xorv4sf3\n+\t(sse_andv2df3, sse_nandv2df3, sse_iorv2df3, sse_xorv2df3): Do not use\n+\tsubregs.\n+\t(sse_andsf3, sse_nandsf3, sse_xorsf3): Kill.\n+\t(sse_anddf3, sse_nanddf3, sse_xordf3): Kill.\n+\n 2004-02-18  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.c (expand_a_rotate): Don't generate insns"}, {"sha": "77336814934b74d9010872e7528f2ac71168769b", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 173, "deletions": 174, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79ae63b183c55dc44a5071ed804c4955adeb99af/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79ae63b183c55dc44a5071ed804c4955adeb99af/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=79ae63b183c55dc44a5071ed804c4955adeb99af", "patch": "@@ -9657,12 +9657,12 @@\n    (use (match_operand:V4SF 2 \"nonimmediate_operand\" \"\"))\n    (clobber (reg:CC 17))]\n   \"reload_completed && SSE_REG_P (operands[0])\"\n-  [(set (subreg:TI (match_dup 0) 0)\n-\t(xor:TI (match_dup 1)\n-\t\t(match_dup 2)))]\n+  [(set (match_dup 0)\n+\t(xor:V4SF (match_dup 1)\n+\t\t  (match_dup 2)))]\n {\n-  operands[1] = simplify_gen_subreg (TImode, operands[1], SFmode, 0);\n-  operands[2] = simplify_gen_subreg (TImode, operands[2], V4SFmode, 0);\n+  operands[0] = simplify_gen_subreg (V4SFmode, operands[0], SFmode, 0);\n+  operands[1] = simplify_gen_subreg (V4SFmode, operands[1], SFmode, 0);\n   if (operands_match_p (operands[0], operands[2]))\n     {\n       rtx tmp;\n@@ -9825,13 +9825,12 @@\n    (use (match_operand:V2DF 2 \"nonimmediate_operand\" \"\"))\n    (clobber (reg:CC 17))]\n   \"reload_completed && SSE_REG_P (operands[0])\"\n-  [(set (subreg:TI (match_dup 0) 0)\n-\t(xor:TI (match_dup 1)\n-\t\t(match_dup 2)))]\n+  [(set (match_dup 0)\n+\t(xor:V2DF (match_dup 1)\n+\t\t  (match_dup 2)))]\n {\n   operands[0] = simplify_gen_subreg (V2DFmode, operands[0], DFmode, 0);\n-  operands[1] = simplify_gen_subreg (TImode, operands[1], DFmode, 0);\n-  operands[2] = simplify_gen_subreg (TImode, operands[2], V2DFmode, 0);\n+  operands[1] = simplify_gen_subreg (V2DFmode, operands[1], DFmode, 0);\n   /* Avoid possible reformatting on the operands.  */\n   if (TARGET_SSE_PARTIAL_REGS && !optimize_size)\n     emit_insn (gen_sse2_unpcklpd (operands[0], operands[0], operands[0]));\n@@ -10065,12 +10064,12 @@\n    (use (match_operand:V4SF 2 \"nonimmediate_operand\" \"\"))\n    (clobber (reg:CC 17))]\n   \"reload_completed && SSE_REG_P (operands[0])\"\n-  [(set (subreg:TI (match_dup 0) 0)\n-\t(and:TI (match_dup 1)\n-\t\t(match_dup 2)))]\n+  [(set (match_dup 0)\n+\t(and:V4SF (match_dup 1)\n+\t\t  (match_dup 2)))]\n {\n-  operands[1] = simplify_gen_subreg (TImode, operands[1], SFmode, 0);\n-  operands[2] = simplify_gen_subreg (TImode, operands[2], V4SFmode, 0);\n+  operands[0] = simplify_gen_subreg (V4SFmode, operands[0], SFmode, 0);\n+  operands[1] = simplify_gen_subreg (V4SFmode, operands[1], SFmode, 0);\n   if (operands_match_p (operands[0], operands[2]))\n     {\n       rtx tmp;\n@@ -10219,13 +10218,12 @@\n    (use (match_operand:V2DF 2 \"nonimmediate_operand\" \"\"))\n    (clobber (reg:CC 17))]\n   \"reload_completed && SSE_REG_P (operands[0])\"\n-  [(set (subreg:TI (match_dup 0) 0)\n-\t(and:TI (match_dup 1)\n-\t\t(match_dup 2)))]\n+  [(set (match_dup 0)\n+\t(and:V2DF (match_dup 1)\n+\t\t  (match_dup 2)))]\n {\n   operands[0] = simplify_gen_subreg (V2DFmode, operands[0], DFmode, 0);\n-  operands[1] = simplify_gen_subreg (TImode, operands[1], DFmode, 0);\n-  operands[2] = simplify_gen_subreg (TImode, operands[2], V2DFmode, 0);\n+  operands[1] = simplify_gen_subreg (V2DFmode, operands[1], DFmode, 0);\n   /* Avoid possible reformatting on the operands.  */\n   if (TARGET_SSE_PARTIAL_REGS && !optimize_size)\n     emit_insn (gen_sse2_unpcklpd (operands[0], operands[0], operands[0]));\n@@ -17099,22 +17097,60 @@\n ;; nand  op0, op3   -  load op3 to op0 if comparison was false\n ;; or\t op2, op0   -  get the nonzero one into the result.\n (define_split\n-  [(set (match_operand 0 \"register_operand\" \"\")\n-\t(if_then_else (match_operator 1 \"sse_comparison_operator\"\n-\t\t\t[(match_operand 4 \"register_operand\" \"\")\n-\t\t\t (match_operand 5 \"nonimmediate_operand\" \"\")])\n-\t\t      (match_operand 2 \"register_operand\" \"\")\n-\t\t      (match_operand 3 \"register_operand\" \"\")))\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(if_then_else (match_operator:SF 1 \"sse_comparison_operator\"\n+\t\t\t[(match_operand:SF 4 \"register_operand\" \"\")\n+\t\t\t (match_operand:SF 5 \"nonimmediate_operand\" \"\")])\n+\t\t      (match_operand:SF 2 \"register_operand\" \"\")\n+\t\t      (match_operand:SF 3 \"register_operand\" \"\")))\n    (clobber (match_operand 6 \"\" \"\"))\n    (clobber (reg:CC 17))]\n   \"SSE_REG_P (operands[0]) && reload_completed\"\n   [(set (match_dup 4) (match_op_dup 1 [(match_dup 4) (match_dup 5)]))\n-   (set (subreg:TI (match_dup 2) 0) (and:TI (subreg:TI (match_dup 2) 0)\n-\t\t\t\t\t    (subreg:TI (match_dup 4) 0)))\n-   (set (subreg:TI (match_dup 4) 0) (and:TI (not:TI (subreg:TI (match_dup 4) 0))\n-\t\t\t\t\t    (subreg:TI (match_dup 3) 0)))\n-   (set (subreg:TI (match_dup 0) 0) (ior:TI (subreg:TI (match_dup 6) 0)\n-\t\t\t\t\t    (subreg:TI (match_dup 7) 0)))]\n+   (set (match_dup 2) (and:V4SF (match_dup 2)\n+\t\t\t        (match_dup 8)))\n+   (set (match_dup 8) (and:V4SF (not:V4SF (match_dup 8))\n+\t\t\t\t          (match_dup 3)))\n+   (set (match_dup 0) (ior:V4SF (match_dup 6)\n+\t\t\t        (match_dup 7)))]\n+{\n+  /* If op2 == op3, op3 would be clobbered before it is used.  */\n+  if (operands_match_p (operands[2], operands[3]))\n+    {\n+      emit_move_insn (operands[0], operands[2]);\n+      DONE;\n+    }\n+\n+  PUT_MODE (operands[1], GET_MODE (operands[0]));\n+  if (operands_match_p (operands[0], operands[4]))\n+    operands[6] = operands[4], operands[7] = operands[2];\n+  else\n+    operands[6] = operands[2], operands[7] = operands[4];\n+  operands[0] = simplify_gen_subreg (V4SFmode, operands[0], SFmode, 0);\n+  operands[2] = simplify_gen_subreg (V4SFmode, operands[2], SFmode, 0);\n+  operands[3] = simplify_gen_subreg (V4SFmode, operands[3], SFmode, 0);\n+  operands[8] = simplify_gen_subreg (V4SFmode, operands[4], SFmode, 0);\n+  operands[6] = simplify_gen_subreg (V4SFmode, operands[6], SFmode, 0);\n+  operands[7] = simplify_gen_subreg (V4SFmode, operands[7], SFmode, 0);\n+})\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(if_then_else (match_operator:DF 1 \"sse_comparison_operator\"\n+\t\t\t[(match_operand:DF 4 \"register_operand\" \"\")\n+\t\t\t (match_operand:DF 5 \"nonimmediate_operand\" \"\")])\n+\t\t      (match_operand:DF 2 \"register_operand\" \"\")\n+\t\t      (match_operand:DF 3 \"register_operand\" \"\")))\n+   (clobber (match_operand 6 \"\" \"\"))\n+   (clobber (reg:CC 17))]\n+  \"SSE_REG_P (operands[0]) && reload_completed\"\n+  [(set (match_dup 4) (match_op_dup 1 [(match_dup 4) (match_dup 5)]))\n+   (set (match_dup 2) (and:V2DF (match_dup 2)\n+\t\t\t        (match_dup 8)))\n+   (set (match_dup 8) (and:V2DF (not:V2DF (match_dup 8))\n+\t\t\t\t          (match_dup 3)))\n+   (set (match_dup 0) (ior:V2DF (match_dup 6)\n+\t\t\t        (match_dup 7)))]\n {\n   if (GET_MODE (operands[2]) == DFmode\n       && TARGET_SSE_PARTIAL_REGS && !optimize_size)\n@@ -17137,6 +17173,12 @@\n     operands[6] = operands[4], operands[7] = operands[2];\n   else\n     operands[6] = operands[2], operands[7] = operands[4];\n+  operands[0] = simplify_gen_subreg (V2DFmode, operands[0], DFmode, 0);\n+  operands[2] = simplify_gen_subreg (V2DFmode, operands[2], DFmode, 0);\n+  operands[3] = simplify_gen_subreg (V2DFmode, operands[3], DFmode, 0);\n+  operands[8] = simplify_gen_subreg (V2DFmode, operands[4], DFmode, 0);\n+  operands[6] = simplify_gen_subreg (V2DFmode, operands[6], DFmode, 0);\n+  operands[7] = simplify_gen_subreg (V2DFmode, operands[7], DFmode, 0);\n })\n \n ;; Special case of conditional move we can handle effectively.\n@@ -17223,18 +17265,55 @@\n   \"#\")\n \n (define_split\n-  [(set (match_operand 0 \"register_operand\" \"\")\n-\t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t[(match_operand 4 \"nonimmediate_operand\" \"\")\n-\t\t\t (match_operand 5 \"nonimmediate_operand\" \"\")])\n-\t\t      (match_operand 2 \"nonmemory_operand\" \"\")\n-\t\t      (match_operand 3 \"nonmemory_operand\" \"\")))]\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(if_then_else (match_operator:SF 1 \"comparison_operator\"\n+\t\t\t[(match_operand:SF 4 \"nonimmediate_operand\" \"\")\n+\t\t\t (match_operand:SF 5 \"nonimmediate_operand\" \"\")])\n+\t\t      (match_operand:SF 2 \"nonmemory_operand\" \"\")\n+\t\t      (match_operand:SF 3 \"nonmemory_operand\" \"\")))]\n+  \"SSE_REG_P (operands[0]) && reload_completed\n+   && (const0_operand (operands[2], GET_MODE (operands[0]))\n+       || const0_operand (operands[3], GET_MODE (operands[0])))\"\n+  [(set (match_dup 0) (match_op_dup 1 [(match_dup 0) (match_dup 5)]))\n+   (set (match_dup 8) (and:V4SF (match_dup 6) (match_dup 7)))]\n+{\n+  PUT_MODE (operands[1], GET_MODE (operands[0]));\n+  if (!sse_comparison_operator (operands[1], VOIDmode)\n+      || !rtx_equal_p (operands[0], operands[4]))\n+    {\n+      rtx tmp = operands[5];\n+      operands[5] = operands[4];\n+      operands[4] = tmp;\n+      PUT_CODE (operands[1], swap_condition (GET_CODE (operands[1])));\n+    }\n+  if (!rtx_equal_p (operands[0], operands[4]))\n+    abort ();\n+  operands[8] = simplify_gen_subreg (V4SFmode, operands[0], SFmode, 0);\n+  if (const0_operand (operands[2], GET_MODE (operands[2])))\n+    {\n+      operands[7] = operands[3];\n+      operands[6] = gen_rtx_NOT (V4SFmode, operands[5]);\n+    }\n+  else\n+    {\n+      operands[7] = operands[2];\n+      operands[6] = operands[0];\n+    }\n+  operands[7] = simplify_gen_subreg (V4SFmode, operands[7], SFmode, 0);\n+})\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(if_then_else (match_operator:DF 1 \"comparison_operator\"\n+\t\t\t[(match_operand:DF 4 \"nonimmediate_operand\" \"\")\n+\t\t\t (match_operand:DF 5 \"nonimmediate_operand\" \"\")])\n+\t\t      (match_operand:DF 2 \"nonmemory_operand\" \"\")\n+\t\t      (match_operand:DF 3 \"nonmemory_operand\" \"\")))]\n   \"SSE_REG_P (operands[0]) && reload_completed\n    && (const0_operand (operands[2], GET_MODE (operands[0]))\n        || const0_operand (operands[3], GET_MODE (operands[0])))\"\n   [(set (match_dup 0) (match_op_dup 1 [(match_dup 0) (match_dup 5)]))\n-   (set (subreg:TI (match_dup 0) 0) (and:TI (match_dup 6)\n-\t\t\t\t\t    (match_dup 7)))]\n+   (set (match_dup 8) (and:V2DF (match_dup 6) (match_dup 7)))]\n {\n   if (TARGET_SSE_PARTIAL_REGS && !optimize_size\n       && GET_MODE (operands[2]) == DFmode)\n@@ -17261,19 +17340,18 @@\n     }\n   if (!rtx_equal_p (operands[0], operands[4]))\n     abort ();\n-  if (const0_operand (operands[2], GET_MODE (operands[0])))\n+  operands[8] = simplify_gen_subreg (V2DFmode, operands[0], DFmode, 0);\n+  if (const0_operand (operands[2], GET_MODE (operands[2])))\n     {\n       operands[7] = operands[3];\n-      operands[6] = gen_rtx_NOT (TImode, gen_rtx_SUBREG (TImode, operands[0],\n-\t\t\t\t\t\t\t 0));\n+      operands[6] = gen_rtx_NOT (V2DFmode, operands[8]);\n     }\n   else\n     {\n       operands[7] = operands[2];\n-      operands[6] = gen_rtx_SUBREG (TImode, operands[0], 0);\n+      operands[6] = operands[8];\n     }\n-  operands[7] = simplify_gen_subreg (TImode, operands[7],\n-  \t\t\t\t     GET_MODE (operands[7]), 0);\n+  operands[7] = simplify_gen_subreg (V2DFmode, operands[7], DFmode, 0);\n })\n \n (define_expand \"allocate_stack_worker\"\n@@ -19539,106 +19617,66 @@\n ;; of DImode subregs again!\n ;; SSE1 single precision floating point logical operation\n (define_expand \"sse_andv4sf3\"\n-  [(set (subreg:TI (match_operand:V4SF 0 \"register_operand\" \"\") 0)\n-        (and:TI (subreg:TI (match_operand:V4SF 1 \"register_operand\" \"\") 0)\n-\t\t(subreg:TI (match_operand:V4SF 2 \"nonimmediate_operand\" \"\") 0)))]\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"\")\n+        (and:V4SF (match_operand:V4SF 1 \"register_operand\" \"\")\n+\t\t  (match_operand:V4SF 2 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_SSE\"\n   \"\")\n \n (define_insn \"*sse_andv4sf3\"\n-  [(set (subreg:TI (match_operand:V4SF 0 \"register_operand\" \"=x\") 0)\n-        (and:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE\n-   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n-  \"andps\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"V4SF\")])\n-\n-(define_insn \"*sse_andsf3\"\n-  [(set (subreg:TI (match_operand:SF 0 \"register_operand\" \"=x\") 0)\n-        (and:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+        (and:V4SF (match_operand:V4SF 1 \"nonimmediate_operand\" \"%0\")\n+\t\t  (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm\")))]\n   \"TARGET_SSE\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"andps\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"mode\" \"V4SF\")])\n \n (define_expand \"sse_nandv4sf3\"\n-  [(set (subreg:TI (match_operand:V4SF 0 \"register_operand\" \"\") 0)\n-        (and:TI (not:TI (subreg:TI (match_operand:V4SF 1 \"register_operand\" \"\") 0))\n-\t        (subreg:TI (match_operand:V4SF 2 \"nonimmediate_operand\" \"\") 0)))]\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"\")\n+        (and:V4SF (not:V4SF (match_operand:V4SF 1 \"register_operand\" \"\"))\n+\t          (match_operand:V4SF 2 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_SSE\"\n   \"\")\n \n (define_insn \"*sse_nandv4sf3\"\n-  [(set (subreg:TI (match_operand:V4SF 0 \"register_operand\" \"=x\") 0)\n-        (and:TI (not:TI (match_operand:TI 1 \"register_operand\" \"0\"))\n-\t        (match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE\"\n-  \"andnps\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"V4SF\")])\n-\n-(define_insn \"*sse_nandsf3\"\n-  [(set (subreg:TI (match_operand:SF 0 \"register_operand\" \"=x\") 0)\n-        (and:TI (not:TI (match_operand:TI 1 \"register_operand\" \"0\"))\n-\t        (match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+        (and:V4SF (not:V4SF (match_operand:V4SF 1 \"register_operand\" \"0\"))\n+\t          (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm\")))]\n   \"TARGET_SSE\"\n   \"andnps\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"mode\" \"V4SF\")])\n \n (define_expand \"sse_iorv4sf3\"\n-  [(set (subreg:TI (match_operand:V4SF 0 \"register_operand\" \"\") 0)\n-        (ior:TI (subreg:TI (match_operand:V4SF 1 \"register_operand\" \"\") 0)\n-\t\t(subreg:TI (match_operand:V4SF 2 \"nonimmediate_operand\" \"\") 0)))]\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"\")\n+        (ior:V4SF (match_operand:V4SF 1 \"register_operand\" \"\")\n+\t\t  (match_operand:V4SF 2 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_SSE\"\n   \"\")\n \n (define_insn \"*sse_iorv4sf3\"\n-  [(set (subreg:TI (match_operand:V4SF 0 \"register_operand\" \"=x\") 0)\n-        (ior:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE\n-   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n-  \"orps\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"V4SF\")])\n-\n-(define_insn \"*sse_iorsf3\"\n-  [(set (subreg:TI (match_operand:SF 0 \"register_operand\" \"=x\") 0)\n-        (ior:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+        (ior:V4SF (match_operand:V4SF 1 \"nonimmediate_operand\" \"%0\")\n+\t\t  (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm\")))]\n   \"TARGET_SSE\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"orps\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"mode\" \"V4SF\")])\n \n (define_expand \"sse_xorv4sf3\"\n-  [(set (subreg:TI (match_operand:V4SF 0 \"register_operand\" \"\") 0)\n-        (xor:TI (subreg:TI (match_operand:V4SF 1 \"register_operand\" \"\") 0)\n-\t\t(subreg:TI (match_operand:V4SF 2 \"nonimmediate_operand\" \"\") 0)))]\n-  \"TARGET_SSE\n-   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"\")\n+        (xor:V4SF (match_operand:V4SF 1 \"register_operand\" \"\")\n+\t\t  (match_operand:V4SF 2 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_SSE\"\n   \"\")\n \n (define_insn \"*sse_xorv4sf3\"\n-  [(set (subreg:TI (match_operand:V4SF 0 \"register_operand\" \"=x\") 0)\n-        (xor:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE\n-   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n-  \"xorps\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"V4SF\")])\n-\n-(define_insn \"*sse_xorsf3\"\n-  [(set (subreg:TI (match_operand:SF 0 \"register_operand\" \"=x\") 0)\n-        (xor:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+        (xor:V4SF (match_operand:V4SF 1 \"nonimmediate_operand\" \"%0\")\n+\t\t  (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm\")))]\n   \"TARGET_SSE\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"xorps\\t{%2, %0|%0, %2}\"\n@@ -19648,105 +19686,66 @@\n ;; SSE2 double precision floating point logical operation\n \n (define_expand \"sse2_andv2df3\"\n-  [(set (subreg:TI (match_operand:V2DF 0 \"register_operand\" \"\") 0)\n-        (and:TI (subreg:TI (match_operand:V2DF 1 \"register_operand\" \"\") 0)\n-\t        (subreg:TI (match_operand:V2DF 2 \"nonimmediate_operand\" \"\") 0)))]\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"\")\n+        (and:V2DF (match_operand:V2DF 1 \"register_operand\" \"\")\n+\t          (match_operand:V2DF 2 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_SSE2\"\n   \"\")\n \n (define_insn \"*sse2_andv2df3\"\n-  [(set (subreg:TI (match_operand:V2DF 0 \"register_operand\" \"=x\") 0)\n-        (and:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE2\n-   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n-  \"andpd\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"V2DF\")])\n-\n-(define_insn \"*sse2_andv2df3\"\n-  [(set (subreg:TI (match_operand:DF 0 \"register_operand\" \"=x\") 0)\n-        (and:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n+        (and:V2DF (match_operand:V2DF 1 \"nonimmediate_operand\" \"%0\")\n+\t\t  (match_operand:V2DF 2 \"nonimmediate_operand\" \"xm\")))]\n   \"TARGET_SSE2\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"andpd\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"mode\" \"V2DF\")])\n \n (define_expand \"sse2_nandv2df3\"\n-  [(set (subreg:TI (match_operand:V2DF 0 \"register_operand\" \"\") 0)\n-        (and:TI (not:TI (subreg:TI (match_operand:V2DF 1 \"register_operand\" \"\") 0))\n-\t        (subreg:TI (match_operand:V2DF 2 \"nonimmediate_operand\" \"\") 0)))]\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"\")\n+        (and:V2DF (not:V2DF (match_operand:V2DF 1 \"register_operand\" \"\"))\n+\t          (match_operand:V2DF 2 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_SSE2\"\n   \"\")\n \n (define_insn \"*sse2_nandv2df3\"\n-  [(set (subreg:TI (match_operand:V2DF 0 \"register_operand\" \"=x\") 0)\n-        (and:TI (not:TI (match_operand:TI 1 \"register_operand\" \"0\"))\n-\t        (match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE2\"\n-  \"andnpd\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"V2DF\")])\n-\n-(define_insn \"*sse_nandti3_df\"\n-  [(set (subreg:TI (match_operand:DF 0 \"register_operand\" \"=Y\") 0)\n-        (and:TI (not:TI (match_operand:TI 1 \"register_operand\" \"0\"))\n-\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"Ym\")))]\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n+        (and:V2DF (not:V2DF (match_operand:V2DF 1 \"register_operand\" \"0\"))\n+\t          (match_operand:V2DF 2 \"nonimmediate_operand\" \"xm\")))]\n   \"TARGET_SSE2\"\n   \"andnpd\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"mode\" \"V2DF\")])\n \n (define_expand \"sse2_iorv2df3\"\n-  [(set (subreg:TI (match_operand:V2DF 0 \"register_operand\" \"\") 0)\n-        (ior:TI (subreg:TI (match_operand:V2DF 1 \"register_operand\" \"\") 0)\n-\t\t(subreg:TI (match_operand:V2DF 2 \"nonimmediate_operand\" \"\") 0)))]\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"\")\n+        (ior:V2DF (match_operand:V2DF 1 \"register_operand\" \"\")\n+\t\t  (match_operand:V2DF 2 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_SSE2\"\n   \"\")\n \n (define_insn \"*sse2_iorv2df3\"\n-  [(set (subreg:TI (match_operand:V2DF 0 \"register_operand\" \"=x\") 0)\n-        (ior:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE2\n-   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n-  \"orpd\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"V2DF\")])\n-\n-(define_insn \"*sse2_iordf3\"\n-  [(set (subreg:TI (match_operand:DF 0 \"register_operand\" \"=x\") 0)\n-        (ior:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n+        (ior:V2DF (match_operand:V2DF 1 \"nonimmediate_operand\" \"%0\")\n+\t\t  (match_operand:V2DF 2 \"nonimmediate_operand\" \"xm\")))]\n   \"TARGET_SSE2\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"orpd\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"mode\" \"V2DF\")])\n \n (define_expand \"sse2_xorv2df3\"\n-  [(set (subreg:TI (match_operand:V2DF 0 \"register_operand\" \"\") 0)\n-        (xor:TI (subreg:TI (match_operand:V2DF 1 \"nonimmediate_operand\" \"\") 0)\n-\t\t(subreg:TI (match_operand:V2DF 2 \"nonimmediate_operand\" \"\") 0)))]\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"\")\n+        (xor:V2DF (match_operand:V2DF 1 \"nonimmediate_operand\" \"\")\n+\t\t  (match_operand:V2DF 2 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_SSE2\"\n   \"\")\n \n (define_insn \"*sse2_xorv2df3\"\n-  [(set (subreg:TI (match_operand:V2DF 0 \"register_operand\" \"=x\") 0)\n-        (xor:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE2\n-   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n-  \"xorpd\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"V2DF\")])\n-\n-(define_insn \"*sse2_xordf3\"\n-  [(set (subreg:TI (match_operand:DF 0 \"register_operand\" \"=x\") 0)\n-        (xor:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n+        (xor:V2DF (match_operand:V2DF 1 \"nonimmediate_operand\" \"%0\")\n+\t\t  (match_operand:V2DF 2 \"nonimmediate_operand\" \"xm\")))]\n   \"TARGET_SSE2\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"xorpd\\t{%2, %0|%0, %2}\""}, {"sha": "dda7dd47365e07d46d10b12a83c620ab181a514c", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 54, "deletions": 15, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79ae63b183c55dc44a5071ed804c4955adeb99af/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79ae63b183c55dc44a5071ed804c4955adeb99af/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=79ae63b183c55dc44a5071ed804c4955adeb99af", "patch": "@@ -771,7 +771,16 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n \tcase FIX:\n \t  real_arithmetic (&d, FIX_TRUNC_EXPR, &d, NULL);\n \t  break;\n+\tcase NOT:\n+\t  {\n+\t    long tmp[4];\n+\t    int i;\n \n+\t    real_to_target (tmp, &d, GET_MODE (trueop));\n+\t    for (i = 0; i < 4; i++)\n+\t      tmp[i] = ~tmp[i];\n+\t    real_from_target (&d, tmp, mode);\n+\t  }\n \tdefault:\n \t  abort ();\n \t}\n@@ -1210,26 +1219,56 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n       && GET_CODE (trueop1) == CONST_DOUBLE\n       && mode == GET_MODE (op0) && mode == GET_MODE (op1))\n     {\n-      REAL_VALUE_TYPE f0, f1, value;\n+      if (code == AND\n+\t  || code == IOR\n+\t  || code == XOR)\n+\t{\n+\t  long tmp0[4];\n+\t  long tmp1[4];\n+\t  REAL_VALUE_TYPE r;\n+\t  int i;\n+\n+\t  real_to_target (tmp0, CONST_DOUBLE_REAL_VALUE (op0),\n+\t\t\t  GET_MODE (op0));\n+\t  real_to_target (tmp1, CONST_DOUBLE_REAL_VALUE (op1),\n+\t\t\t  GET_MODE (op1));\n+\t  for (i = 0; i < 4; i++)\n+\t    {\n+\t      if (code == AND)\n+\t\ttmp0[i] &= tmp1[i];\n+\t      else if (code == IOR)\n+\t\ttmp0[i] |= tmp1[i];\n+\t      else if (code == XOR)\n+\t\ttmp0[i] ^= tmp1[i];\n+\t      else\n+\t\tabort ();\n+\t    }\n+\t   real_from_target (&r, tmp0, mode);\n+\t   return CONST_DOUBLE_FROM_REAL_VALUE (r, mode);\n+\t}\n+      else\n+\t{\n+\t  REAL_VALUE_TYPE f0, f1, value;\n \n-      REAL_VALUE_FROM_CONST_DOUBLE (f0, trueop0);\n-      REAL_VALUE_FROM_CONST_DOUBLE (f1, trueop1);\n-      f0 = real_value_truncate (mode, f0);\n-      f1 = real_value_truncate (mode, f1);\n+\t  REAL_VALUE_FROM_CONST_DOUBLE (f0, trueop0);\n+\t  REAL_VALUE_FROM_CONST_DOUBLE (f1, trueop1);\n+\t  f0 = real_value_truncate (mode, f0);\n+\t  f1 = real_value_truncate (mode, f1);\n \n-      if (HONOR_SNANS (mode)\n-\t  && (REAL_VALUE_ISNAN (f0) || REAL_VALUE_ISNAN (f1)))\n-\treturn 0;\n+\t  if (HONOR_SNANS (mode)\n+\t      && (REAL_VALUE_ISNAN (f0) || REAL_VALUE_ISNAN (f1)))\n+\t    return 0;\n \n-      if (code == DIV\n-\t  && REAL_VALUES_EQUAL (f1, dconst0)\n-\t  && (flag_trapping_math || ! MODE_HAS_INFINITIES (mode)))\n-\treturn 0;\n+\t  if (code == DIV\n+\t      && REAL_VALUES_EQUAL (f1, dconst0)\n+\t      && (flag_trapping_math || ! MODE_HAS_INFINITIES (mode)))\n+\t    return 0;\n \n-      REAL_ARITHMETIC (value, rtx_to_tree_code (code), f0, f1);\n+\t  REAL_ARITHMETIC (value, rtx_to_tree_code (code), f0, f1);\n \n-      value = real_value_truncate (mode, value);\n-      return CONST_DOUBLE_FROM_REAL_VALUE (value, mode);\n+\t  value = real_value_truncate (mode, value);\n+\t  return CONST_DOUBLE_FROM_REAL_VALUE (value, mode);\n+\t}\n     }\n \n   /* We can fold some multi-word operations.  */"}]}