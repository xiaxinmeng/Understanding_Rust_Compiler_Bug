{"sha": "7b27cb4b510c4c0ae8446140929380aba4a9f79a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2IyN2NiNGI1MTBjNGMwYWU4NDQ2MTQwOTI5MzgwYWJhNGE5Zjc5YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-10-09T10:51:45Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-10-09T10:51:45Z"}, "message": "Allow non-wi <op> wi\n\nThis patch uses global rather than member operators for wide-int.h,\nso that the first operand can be a non-wide-int type.\n\nThe patch also removes the and_not and or_not member functions.\nIt was already inconsistent to have member functions for these\ntwo operations (one of which was never used) and not other wi::\nones like udiv.  After the operator change, we'd have the additional\ninconsistency that \"non-wi & wi\" would work but \"non-wi.and_not (wi)\"\nwouldn't.\n\n2017-10-09  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* wide-int.h (WI_BINARY_OPERATOR_RESULT): New macro.\n\t(WI_BINARY_PREDICATE_RESULT): Likewise.\n\t(wi::binary_traits::operator_result): New type.\n\t(wi::binary_traits::predicate_result): Likewise.\n\t(generic_wide_int::operator~, unary generic_wide_int::operator-)\n\t(generic_wide_int::operator==, generic_wide_int::operator!=)\n\t(generic_wide_int::operator&, generic_wide_int::and_not)\n\t(generic_wide_int::operator|, generic_wide_int::or_not)\n\t(generic_wide_int::operator^, generic_wide_int::operator+\n\t(binary generic_wide_int::operator-, generic_wide_int::operator*):\n\tDelete.\n\t(operator~, unary operator-, operator==, operator!=, operator&)\n\t(operator|, operator^, operator+, binary operator-, operator*): New\n\tfunctions.\n\t* expr.c (get_inner_reference): Use wi::bit_and_not.\n\t* fold-const.c (fold_binary_loc): Likewise.\n\t* ipa-prop.c (ipa_compute_jump_functions_for_edge): Likewise.\n\t* tree-ssa-ccp.c (get_value_from_alignment): Likewise.\n\t(bit_value_binop): Likewise.\n\t* tree-ssa-math-opts.c (find_bswap_or_nop_load): Likewise.\n\t* tree-vrp.c (zero_nonzero_bits_from_vr): Likewise.\n\t(extract_range_from_binary_expr_1): Likewise.\n\t(masked_increment): Likewise.\n\t(simplify_bit_ops_using_ranges): Likewise.\n\nFrom-SVN: r253539", "tree": {"sha": "f4ff87714e14c46a92572a3688e8ec637e80ea78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4ff87714e14c46a92572a3688e8ec637e80ea78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b27cb4b510c4c0ae8446140929380aba4a9f79a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b27cb4b510c4c0ae8446140929380aba4a9f79a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b27cb4b510c4c0ae8446140929380aba4a9f79a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b27cb4b510c4c0ae8446140929380aba4a9f79a/comments", "author": null, "committer": null, "parents": [{"sha": "191411e43abdefb0c999215bf081d4a5776f281a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/191411e43abdefb0c999215bf081d4a5776f281a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/191411e43abdefb0c999215bf081d4a5776f281a"}], "stats": {"total": 176, "additions": 123, "deletions": 53}, "files": [{"sha": "0cf8731d2fb1d7e531df27a246083d7cd0da204a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b27cb4b510c4c0ae8446140929380aba4a9f79a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b27cb4b510c4c0ae8446140929380aba4a9f79a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b27cb4b510c4c0ae8446140929380aba4a9f79a", "patch": "@@ -1,3 +1,30 @@\n+2017-10-09  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* wide-int.h (WI_BINARY_OPERATOR_RESULT): New macro.\n+\t(WI_BINARY_PREDICATE_RESULT): Likewise.\n+\t(wi::binary_traits::operator_result): New type.\n+\t(wi::binary_traits::predicate_result): Likewise.\n+\t(generic_wide_int::operator~, unary generic_wide_int::operator-)\n+\t(generic_wide_int::operator==, generic_wide_int::operator!=)\n+\t(generic_wide_int::operator&, generic_wide_int::and_not)\n+\t(generic_wide_int::operator|, generic_wide_int::or_not)\n+\t(generic_wide_int::operator^, generic_wide_int::operator+\n+\t(binary generic_wide_int::operator-, generic_wide_int::operator*):\n+\tDelete.\n+\t(operator~, unary operator-, operator==, operator!=, operator&)\n+\t(operator|, operator^, operator+, binary operator-, operator*): New\n+\tfunctions.\n+\t* expr.c (get_inner_reference): Use wi::bit_and_not.\n+\t* fold-const.c (fold_binary_loc): Likewise.\n+\t* ipa-prop.c (ipa_compute_jump_functions_for_edge): Likewise.\n+\t* tree-ssa-ccp.c (get_value_from_alignment): Likewise.\n+\t(bit_value_binop): Likewise.\n+\t* tree-ssa-math-opts.c (find_bswap_or_nop_load): Likewise.\n+\t* tree-vrp.c (zero_nonzero_bits_from_vr): Likewise.\n+\t(extract_range_from_binary_expr_1): Likewise.\n+\t(masked_increment): Likewise.\n+\t(simplify_bit_ops_using_ranges): Likewise.\n+\n 2017-10-09  Martin Jambor  <mjambor@suse.cz>\n \n \tPR hsa/82416"}, {"sha": "baaef260320663126ae6b57164ab5e9496747a18", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b27cb4b510c4c0ae8446140929380aba4a9f79a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b27cb4b510c4c0ae8446140929380aba4a9f79a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=7b27cb4b510c4c0ae8446140929380aba4a9f79a", "patch": "@@ -7153,7 +7153,7 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n       if (wi::neg_p (bit_offset) || !wi::fits_shwi_p (bit_offset))\n         {\n \t  offset_int mask = wi::mask <offset_int> (LOG2_BITS_PER_UNIT, false);\n-\t  offset_int tem = bit_offset.and_not (mask);\n+\t  offset_int tem = wi::bit_and_not (bit_offset, mask);\n \t  /* TEM is the bitpos rounded to BITS_PER_UNIT towards -Inf.\n \t     Subtract it to BIT_OFFSET and add it (scaled) to OFFSET.  */\n \t  bit_offset -= tem;"}, {"sha": "aac62f83321ea9fe1fe37e0981b3e12a1ee579f1", "filename": "gcc/fold-const.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b27cb4b510c4c0ae8446140929380aba4a9f79a/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b27cb4b510c4c0ae8446140929380aba4a9f79a/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=7b27cb4b510c4c0ae8446140929380aba4a9f79a", "patch": "@@ -9888,7 +9888,7 @@ fold_binary_loc (location_t loc,\n \t\t\t\t   TYPE_PRECISION (TREE_TYPE (arg1)));\n \n \t  /* If (C1|C2) == ~0 then (X&C1)|C2 becomes X|C2.  */\n-\t  if (msk.and_not (c1 | c2) == 0)\n+\t  if (wi::bit_and_not (msk, c1 | c2) == 0)\n \t    {\n \t      tem = fold_convert_loc (loc, type, TREE_OPERAND (arg0, 0));\n \t      return fold_build2_loc (loc, BIT_IOR_EXPR, type, tem, arg1);\n@@ -9899,12 +9899,13 @@ fold_binary_loc (location_t loc,\n \t     mode which allows further optimizations.  */\n \t  c1 &= msk;\n \t  c2 &= msk;\n-\t  wide_int c3 = c1.and_not (c2);\n+\t  wide_int c3 = wi::bit_and_not (c1, c2);\n \t  for (w = BITS_PER_UNIT; w <= width; w <<= 1)\n \t    {\n \t      wide_int mask = wi::mask (w, false,\n \t\t\t\t\tTYPE_PRECISION (type));\n-\t      if (((c1 | c2) & mask) == mask && c1.and_not (mask) == 0)\n+\t      if (((c1 | c2) & mask) == mask\n+\t\t  && wi::bit_and_not (c1, mask) == 0)\n \t\t{\n \t\t  c3 = mask;\n \t\t  break;"}, {"sha": "8fbb6435427c6b11fe2e0e7c33563ff59ab5d335", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b27cb4b510c4c0ae8446140929380aba4a9f79a/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b27cb4b510c4c0ae8446140929380aba4a9f79a/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=7b27cb4b510c4c0ae8446140929380aba4a9f79a", "patch": "@@ -1931,9 +1931,9 @@ ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n \t  unsigned align;\n \n \t  get_pointer_alignment_1 (arg, &align, &bitpos);\n-\t  widest_int mask\n-\t    = wi::mask<widest_int>(TYPE_PRECISION (TREE_TYPE (arg)), false)\n-\t    .and_not (align / BITS_PER_UNIT - 1);\n+\t  widest_int mask = wi::bit_and_not\n+\t    (wi::mask<widest_int> (TYPE_PRECISION (TREE_TYPE (arg)), false),\n+\t     align / BITS_PER_UNIT - 1);\n \t  widest_int value = bitpos / BITS_PER_UNIT;\n \t  ipa_set_jfunc_bits (jfunc, value, mask);\n \t}"}, {"sha": "df409af2d835bc558a172397bfbe008f68d08935", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b27cb4b510c4c0ae8446140929380aba4a9f79a/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b27cb4b510c4c0ae8446140929380aba4a9f79a/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=7b27cb4b510c4c0ae8446140929380aba4a9f79a", "patch": "@@ -569,9 +569,11 @@ get_value_from_alignment (tree expr)\n   gcc_assert (TREE_CODE (expr) == ADDR_EXPR);\n \n   get_pointer_alignment_1 (expr, &align, &bitpos);\n-  val.mask = (POINTER_TYPE_P (type) || TYPE_UNSIGNED (type)\n-\t      ? wi::mask <widest_int> (TYPE_PRECISION (type), false)\n-\t      : -1).and_not (align / BITS_PER_UNIT - 1);\n+  val.mask = wi::bit_and_not\n+    (POINTER_TYPE_P (type) || TYPE_UNSIGNED (type)\n+     ? wi::mask <widest_int> (TYPE_PRECISION (type), false)\n+     : -1,\n+     align / BITS_PER_UNIT - 1);\n   val.lattice_val\n     = wi::sext (val.mask, TYPE_PRECISION (type)) == -1 ? VARYING : CONSTANT;\n   if (val.lattice_val == CONSTANT)\n@@ -1308,8 +1310,9 @@ bit_value_binop (enum tree_code code, signop sgn, int width,\n     case BIT_IOR_EXPR:\n       /* The mask is constant where there is a known\n \t set bit, (m1 | m2) & ~((v1 & ~m1) | (v2 & ~m2)).  */\n-      *mask = (r1mask | r2mask)\n-\t      .and_not (r1val.and_not (r1mask) | r2val.and_not (r2mask));\n+      *mask = wi::bit_and_not (r1mask | r2mask,\n+\t\t\t       wi::bit_and_not (r1val, r1mask)\n+\t\t\t       | wi::bit_and_not (r2val, r2mask));\n       *val = r1val | r2val;\n       break;\n \n@@ -1395,7 +1398,8 @@ bit_value_binop (enum tree_code code, signop sgn, int width,\n       {\n \t/* Do the addition with unknown bits set to zero, to give carry-ins of\n \t   zero wherever possible.  */\n-\twidest_int lo = r1val.and_not (r1mask) + r2val.and_not (r2mask);\n+\twidest_int lo = (wi::bit_and_not (r1val, r1mask)\n+\t\t\t + wi::bit_and_not (r2val, r2mask));\n \tlo = wi::ext (lo, width, sgn);\n \t/* Do the addition with unknown bits set to one, to give carry-ins of\n \t   one wherever possible.  */\n@@ -1447,7 +1451,7 @@ bit_value_binop (enum tree_code code, signop sgn, int width,\n     case NE_EXPR:\n       {\n \twidest_int m = r1mask | r2mask;\n-\tif (r1val.and_not (m) != r2val.and_not (m))\n+\tif (wi::bit_and_not (r1val, m) != wi::bit_and_not (r2val, m))\n \t  {\n \t    *mask = 0;\n \t    *val = ((code == EQ_EXPR) ? 0 : 1);\n@@ -1486,8 +1490,10 @@ bit_value_binop (enum tree_code code, signop sgn, int width,\n \t/* If we know the most significant bits we know the values\n \t   value ranges by means of treating varying bits as zero\n \t   or one.  Do a cross comparison of the max/min pairs.  */\n-\tmaxmin = wi::cmp (o1val | o1mask, o2val.and_not (o2mask), sgn);\n-\tminmax = wi::cmp (o1val.and_not (o1mask), o2val | o2mask, sgn);\n+\tmaxmin = wi::cmp (o1val | o1mask,\n+\t\t\t  wi::bit_and_not (o2val, o2mask), sgn);\n+\tminmax = wi::cmp (wi::bit_and_not (o1val, o1mask),\n+\t\t\t  o2val | o2mask, sgn);\n \tif (maxmin < 0)  /* o1 is less than o2.  */\n \t  {\n \t    *mask = 0;"}, {"sha": "17d62a82e8bfdf32b9755cf5d8397335fb09ded6", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b27cb4b510c4c0ae8446140929380aba4a9f79a/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b27cb4b510c4c0ae8446140929380aba4a9f79a/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=7b27cb4b510c4c0ae8446140929380aba4a9f79a", "patch": "@@ -2138,7 +2138,7 @@ find_bswap_or_nop_load (gimple *stmt, tree ref, struct symbolic_number *n)\n       if (wi::neg_p (bit_offset))\n \t{\n \t  offset_int mask = wi::mask <offset_int> (LOG2_BITS_PER_UNIT, false);\n-\t  offset_int tem = bit_offset.and_not (mask);\n+\t  offset_int tem = wi::bit_and_not (bit_offset, mask);\n \t  /* TEM is the bitpos rounded to BITS_PER_UNIT towards -Inf.\n \t     Subtract it to BIT_OFFSET and add it (scaled) to OFFSET.  */\n \t  bit_offset -= tem;"}, {"sha": "3e8be2688fb827777b4fd011628fc6b497cb7181", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b27cb4b510c4c0ae8446140929380aba4a9f79a/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b27cb4b510c4c0ae8446140929380aba4a9f79a/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=7b27cb4b510c4c0ae8446140929380aba4a9f79a", "patch": "@@ -1769,7 +1769,7 @@ zero_nonzero_bits_from_vr (const tree expr_type,\n \t  wide_int mask = wi::mask (wi::floor_log2 (xor_mask), false,\n \t\t\t\t    may_be_nonzero->get_precision ());\n \t  *may_be_nonzero = *may_be_nonzero | mask;\n-\t  *must_be_nonzero = must_be_nonzero->and_not (mask);\n+\t  *must_be_nonzero = wi::bit_and_not (*must_be_nonzero, mask);\n \t}\n     }\n \n@@ -2975,8 +2975,8 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t  wide_int result_zero_bits = ((must_be_nonzero0 & must_be_nonzero1)\n \t\t\t\t       | ~(may_be_nonzero0 | may_be_nonzero1));\n \t  wide_int result_one_bits\n-\t    = (must_be_nonzero0.and_not (may_be_nonzero1)\n-\t       | must_be_nonzero1.and_not (may_be_nonzero0));\n+\t    = (wi::bit_and_not (must_be_nonzero0, may_be_nonzero1)\n+\t       | wi::bit_and_not (must_be_nonzero1, may_be_nonzero0));\n \t  max = wide_int_to_tree (expr_type, ~result_zero_bits);\n \t  min = wide_int_to_tree (expr_type, result_one_bits);\n \t  /* If the range has all positive or all negative values the\n@@ -4877,7 +4877,7 @@ masked_increment (const wide_int &val_in, const wide_int &mask,\n       if ((res & bit) == 0)\n \tcontinue;\n       res = bit - 1;\n-      res = (val + bit).and_not (res);\n+      res = wi::bit_and_not (val + bit, res);\n       res &= mask;\n       if (wi::gtu_p (res, val))\n \treturn res ^ sgnbit;\n@@ -9538,27 +9538,27 @@ simplify_bit_ops_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n   switch (gimple_assign_rhs_code (stmt))\n     {\n     case BIT_AND_EXPR:\n-      mask = may_be_nonzero0.and_not (must_be_nonzero1);\n+      mask = wi::bit_and_not (may_be_nonzero0, must_be_nonzero1);\n       if (mask == 0)\n \t{\n \t  op = op0;\n \t  break;\n \t}\n-      mask = may_be_nonzero1.and_not (must_be_nonzero0);\n+      mask = wi::bit_and_not (may_be_nonzero1, must_be_nonzero0);\n       if (mask == 0)\n \t{\n \t  op = op1;\n \t  break;\n \t}\n       break;\n     case BIT_IOR_EXPR:\n-      mask = may_be_nonzero0.and_not (must_be_nonzero1);\n+      mask = wi::bit_and_not (may_be_nonzero0, must_be_nonzero1);\n       if (mask == 0)\n \t{\n \t  op = op1;\n \t  break;\n \t}\n-      mask = may_be_nonzero1.and_not (must_be_nonzero0);\n+      mask = wi::bit_and_not (may_be_nonzero1, must_be_nonzero0);\n       if (mask == 0)\n \t{\n \t  op = op0;"}, {"sha": "56bc5345ba43b268aa926a4d62fae9adb2e62912", "filename": "gcc/wide-int.h", "status": "modified", "additions": 64, "deletions": 28, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b27cb4b510c4c0ae8446140929380aba4a9f79a/gcc%2Fwide-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b27cb4b510c4c0ae8446140929380aba4a9f79a/gcc%2Fwide-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.h?ref=7b27cb4b510c4c0ae8446140929380aba4a9f79a", "patch": "@@ -262,11 +262,22 @@ along with GCC; see the file COPYING3.  If not see\n #define WI_BINARY_RESULT(T1, T2) \\\n   typename wi::binary_traits <T1, T2>::result_type\n \n+/* Likewise for binary operators, which excludes the case in which neither\n+   T1 nor T2 is a wide-int-based type.  */\n+#define WI_BINARY_OPERATOR_RESULT(T1, T2) \\\n+  typename wi::binary_traits <T1, T2>::operator_result\n+\n /* The type of result produced by T1 << T2.  Leads to substitution failure\n    if the operation isn't supported.  Defined purely for brevity.  */\n #define WI_SIGNED_SHIFT_RESULT(T1, T2) \\\n   typename wi::binary_traits <T1, T2>::signed_shift_result_type\n \n+/* The type of result produced by a sign-agnostic binary predicate on\n+   types T1 and T2.  This is bool if wide-int operations make sense for\n+   T1 and T2 and leads to substitution failure otherwise.  */\n+#define WI_BINARY_PREDICATE_RESULT(T1, T2) \\\n+  typename wi::binary_traits <T1, T2>::predicate_result\n+\n /* The type of result produced by a signed binary predicate on types T1 and T2.\n    This is bool if signed comparisons make sense for T1 and T2 and leads to\n    substitution failure otherwise.  */\n@@ -382,12 +393,15 @@ namespace wi\n   struct binary_traits <T1, T2, FLEXIBLE_PRECISION, FLEXIBLE_PRECISION>\n   {\n     typedef widest_int result_type;\n+    /* Don't define operators for this combination.  */\n   };\n \n   template <typename T1, typename T2>\n   struct binary_traits <T1, T2, FLEXIBLE_PRECISION, VAR_PRECISION>\n   {\n     typedef wide_int result_type;\n+    typedef result_type operator_result;\n+    typedef bool predicate_result;\n   };\n \n   template <typename T1, typename T2>\n@@ -397,13 +411,17 @@ namespace wi\n        so as not to confuse gengtype.  */\n     typedef generic_wide_int < fixed_wide_int_storage\n \t\t\t       <int_traits <T2>::precision> > result_type;\n+    typedef result_type operator_result;\n+    typedef bool predicate_result;\n     typedef bool signed_predicate_result;\n   };\n \n   template <typename T1, typename T2>\n   struct binary_traits <T1, T2, VAR_PRECISION, FLEXIBLE_PRECISION>\n   {\n     typedef wide_int result_type;\n+    typedef result_type operator_result;\n+    typedef bool predicate_result;\n   };\n \n   template <typename T1, typename T2>\n@@ -413,18 +431,22 @@ namespace wi\n        so as not to confuse gengtype.  */\n     typedef generic_wide_int < fixed_wide_int_storage\n \t\t\t       <int_traits <T1>::precision> > result_type;\n+    typedef result_type operator_result;\n+    typedef bool predicate_result;\n     typedef result_type signed_shift_result_type;\n     typedef bool signed_predicate_result;\n   };\n \n   template <typename T1, typename T2>\n   struct binary_traits <T1, T2, CONST_PRECISION, CONST_PRECISION>\n   {\n+    STATIC_ASSERT (int_traits <T1>::precision == int_traits <T2>::precision);\n     /* Spelled out explicitly (rather than through FIXED_WIDE_INT)\n        so as not to confuse gengtype.  */\n-    STATIC_ASSERT (int_traits <T1>::precision == int_traits <T2>::precision);\n     typedef generic_wide_int < fixed_wide_int_storage\n \t\t\t       <int_traits <T1>::precision> > result_type;\n+    typedef result_type operator_result;\n+    typedef bool predicate_result;\n     typedef result_type signed_shift_result_type;\n     typedef bool signed_predicate_result;\n   };\n@@ -433,6 +455,8 @@ namespace wi\n   struct binary_traits <T1, T2, VAR_PRECISION, VAR_PRECISION>\n   {\n     typedef wide_int result_type;\n+    typedef result_type operator_result;\n+    typedef bool predicate_result;\n   };\n }\n \n@@ -675,18 +699,6 @@ class GTY(()) generic_wide_int : public storage\n   template <typename T>\n   generic_wide_int &operator = (const T &);\n \n-#define BINARY_PREDICATE(OP, F) \\\n-  template <typename T> \\\n-  bool OP (const T &c) const { return wi::F (*this, c); }\n-\n-#define UNARY_OPERATOR(OP, F) \\\n-  WI_UNARY_RESULT (generic_wide_int) OP () const { return wi::F (*this); }\n-\n-#define BINARY_OPERATOR(OP, F) \\\n-  template <typename T> \\\n-    WI_BINARY_RESULT (generic_wide_int, T) \\\n-    OP (const T &c) const { return wi::F (*this, c); }\n-\n #define ASSIGNMENT_OPERATOR(OP, F) \\\n   template <typename T> \\\n     generic_wide_int &OP (const T &c) { return (*this = wi::F (*this, c)); }\n@@ -699,18 +711,6 @@ class GTY(()) generic_wide_int : public storage\n #define INCDEC_OPERATOR(OP, DELTA) \\\n   generic_wide_int &OP () { *this += DELTA; return *this; }\n \n-  UNARY_OPERATOR (operator ~, bit_not)\n-  UNARY_OPERATOR (operator -, neg)\n-  BINARY_PREDICATE (operator ==, eq_p)\n-  BINARY_PREDICATE (operator !=, ne_p)\n-  BINARY_OPERATOR (operator &, bit_and)\n-  BINARY_OPERATOR (and_not, bit_and_not)\n-  BINARY_OPERATOR (operator |, bit_or)\n-  BINARY_OPERATOR (or_not, bit_or_not)\n-  BINARY_OPERATOR (operator ^, bit_xor)\n-  BINARY_OPERATOR (operator +, add)\n-  BINARY_OPERATOR (operator -, sub)\n-  BINARY_OPERATOR (operator *, mul)\n   ASSIGNMENT_OPERATOR (operator &=, bit_and)\n   ASSIGNMENT_OPERATOR (operator |=, bit_or)\n   ASSIGNMENT_OPERATOR (operator ^=, bit_xor)\n@@ -722,9 +722,6 @@ class GTY(()) generic_wide_int : public storage\n   INCDEC_OPERATOR (operator ++, 1)\n   INCDEC_OPERATOR (operator --, -1)\n \n-#undef BINARY_PREDICATE\n-#undef UNARY_OPERATOR\n-#undef BINARY_OPERATOR\n #undef SHIFT_ASSIGNMENT_OPERATOR\n #undef ASSIGNMENT_OPERATOR\n #undef INCDEC_OPERATOR\n@@ -3123,6 +3120,45 @@ SIGNED_BINARY_PREDICATE (operator >=, ges_p)\n \n #undef SIGNED_BINARY_PREDICATE\n \n+#define UNARY_OPERATOR(OP, F) \\\n+  template<typename T> \\\n+  WI_UNARY_RESULT (generic_wide_int<T>) \\\n+  OP (const generic_wide_int<T> &x) \\\n+  { \\\n+    return wi::F (x); \\\n+  }\n+\n+#define BINARY_PREDICATE(OP, F) \\\n+  template<typename T1, typename T2> \\\n+  WI_BINARY_PREDICATE_RESULT (T1, T2) \\\n+  OP (const T1 &x, const T2 &y) \\\n+  { \\\n+    return wi::F (x, y); \\\n+  }\n+\n+#define BINARY_OPERATOR(OP, F) \\\n+  template<typename T1, typename T2> \\\n+  WI_BINARY_OPERATOR_RESULT (T1, T2) \\\n+  OP (const T1 &x, const T2 &y) \\\n+  { \\\n+    return wi::F (x, y); \\\n+  }\n+\n+UNARY_OPERATOR (operator ~, bit_not)\n+UNARY_OPERATOR (operator -, neg)\n+BINARY_PREDICATE (operator ==, eq_p)\n+BINARY_PREDICATE (operator !=, ne_p)\n+BINARY_OPERATOR (operator &, bit_and)\n+BINARY_OPERATOR (operator |, bit_or)\n+BINARY_OPERATOR (operator ^, bit_xor)\n+BINARY_OPERATOR (operator +, add)\n+BINARY_OPERATOR (operator -, sub)\n+BINARY_OPERATOR (operator *, mul)\n+\n+#undef UNARY_OPERATOR\n+#undef BINARY_PREDICATE\n+#undef BINARY_OPERATOR\n+\n template <typename T1, typename T2>\n inline WI_SIGNED_SHIFT_RESULT (T1, T2)\n operator << (const T1 &x, const T2 &y)"}]}