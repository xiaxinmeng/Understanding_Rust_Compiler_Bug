{"sha": "521b92248e4ce84a4106887ac8104d820037717f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTIxYjkyMjQ4ZTRjZTg0YTQxMDY4ODdhYzgxMDRkODIwMDM3NzE3Zg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-01-14T20:35:06Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-01-14T20:35:06Z"}, "message": "genrecog.c (DT_veclen_ge): New.\n\n        * genrecog.c (DT_veclen_ge): New.\n        (add_to_sequence) [MATCH_PARALLEL]: Generate one.\n        (maybe_both_true_2): Simplify DT_veclen vs DT_veclen_ge.\n        (nodes_identical_1): Handle DT_veclen_ge.\n        (write_cond, debug_decision_2): Likewise.\n\nFrom-SVN: r39016", "tree": {"sha": "0ae5b9e038cb8db433e6b4a957bbe6bce29b9d84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ae5b9e038cb8db433e6b4a957bbe6bce29b9d84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/521b92248e4ce84a4106887ac8104d820037717f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/521b92248e4ce84a4106887ac8104d820037717f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/521b92248e4ce84a4106887ac8104d820037717f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/521b92248e4ce84a4106887ac8104d820037717f/comments", "author": null, "committer": null, "parents": [{"sha": "d6c5a763516081cca8b9ed4f10a17a90f7176b69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6c5a763516081cca8b9ed4f10a17a90f7176b69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6c5a763516081cca8b9ed4f10a17a90f7176b69"}], "stats": {"total": 35, "additions": 33, "deletions": 2}, "files": [{"sha": "5769bb8aa5df83d187afa6ec9739cf16a65e0480", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/521b92248e4ce84a4106887ac8104d820037717f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/521b92248e4ce84a4106887ac8104d820037717f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=521b92248e4ce84a4106887ac8104d820037717f", "patch": "@@ -1,3 +1,11 @@\n+2001-01-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* genrecog.c (DT_veclen_ge): New.\n+\t(add_to_sequence) [MATCH_PARALLEL]: Generate one.\n+\t(maybe_both_true_2): Simplify DT_veclen vs DT_veclen_ge.\n+\t(nodes_identical_1): Handle DT_veclen_ge.\n+\t(write_cond, debug_decision_2): Likewise.\n+\n 2001-01-14  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.md (ldmsi_postinc, ldmsi, stmsi_postinc, smsi): Delete.  Replace"}, {"sha": "cbca47b8e2de9f5612ca11db06826c2dc4172145", "filename": "gcc/genrecog.c", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/521b92248e4ce84a4106887ac8104d820037717f/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/521b92248e4ce84a4106887ac8104d820037717f/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=521b92248e4ce84a4106887ac8104d820037717f", "patch": "@@ -87,7 +87,7 @@ struct decision_test\n   enum decision_type {\n     DT_mode, DT_code, DT_veclen,\n     DT_elt_zero_int, DT_elt_one_int, DT_elt_zero_wide,\n-    DT_dup, DT_pred, DT_c_test, \n+    DT_veclen_ge, DT_dup, DT_pred, DT_c_test, \n     DT_accept_op, DT_accept_insn\n   } type;\n \n@@ -802,10 +802,19 @@ add_to_sequence (pattern, last, position, insn_type, top)\n       /* Else nothing special.  */\n       break;\n \n+    case MATCH_PARALLEL:\n+      /* The explicit patterns within a match_parallel enforce a minimum\n+\t length on the vector.  The match_parallel predicate may allow\n+\t for more elements.  We do need to check for this minimum here\n+\t or the code generated to match the internals may reference data\n+\t beyond the end of the vector.  */\n+      test = new_decision_test (DT_veclen_ge, &place);\n+      test->u.veclen = XVECLEN (pattern, 2);\n+      /* FALLTHRU */\n+\n     case MATCH_OPERAND:\n     case MATCH_SCRATCH:\n     case MATCH_OPERATOR:\n-    case MATCH_PARALLEL:\n     case MATCH_INSN:\n       {\n \tconst char *pred_name;\n@@ -1122,6 +1131,12 @@ maybe_both_true_2 (d1, d2)\n \t}\n     }\n \n+  /* Tests vs veclen may be known when strict equality is involved.  */\n+  if (d1->type == DT_veclen && d2->type == DT_veclen_ge)\n+    return d1->u.veclen >= d2->u.veclen;\n+  if (d1->type == DT_veclen_ge && d2->type == DT_veclen)\n+    return d2->u.veclen >= d1->u.veclen;\n+\n   return -1;\n }\n \n@@ -1252,6 +1267,7 @@ nodes_identical_1 (d1, d2)\n       return strcmp (d1->u.c_test, d2->u.c_test) == 0;\n \n     case DT_veclen:\n+    case DT_veclen_ge:\n       return d1->u.veclen == d2->u.veclen;\n \n     case DT_dup:\n@@ -1952,6 +1968,10 @@ write_cond (p, depth, subroutine_type)\n       printf (HOST_WIDE_INT_PRINT_DEC, p->u.intval);\n       break;\n \n+    case DT_veclen_ge:\n+      printf (\"XVECLEN (x%d, 0) >= %d\", depth, p->u.veclen);\n+      break;\n+\n     case DT_dup:\n       printf (\"rtx_equal_p (x%d, operands[%d])\", depth, p->u.dup);\n       break;\n@@ -2715,6 +2735,9 @@ debug_decision_2 (test)\n       fprintf (stderr, \"elt0_w=\");\n       fprintf (stderr, HOST_WIDE_INT_PRINT_DEC, test->u.intval);\n       break;\n+    case DT_veclen_ge:\n+      fprintf (stderr, \"veclen>=%d\", test->u.veclen);\n+      break;\n     case DT_dup:\n       fprintf (stderr, \"dup=%d\", test->u.dup);\n       break;"}]}