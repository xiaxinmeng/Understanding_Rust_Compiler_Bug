{"sha": "e404a39a9c7a3867132194bc09c37fa94cf80f86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQwNGEzOWE5YzdhMzg2NzEzMjE5NGJjMDljMzdmYTk0Y2Y4MGY4Ng==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-09-21T12:26:33Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-09-21T12:26:33Z"}, "message": "(reload): Print the needs to the dump file.\n\n(reload): If we can't get a register that we know won't interfere with groups,\nget one that might instead of giving up.\n\nFrom-SVN: r2201", "tree": {"sha": "b2bb9060dd729df1c7e6b9d7d630054fd428f551", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2bb9060dd729df1c7e6b9d7d630054fd428f551"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e404a39a9c7a3867132194bc09c37fa94cf80f86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e404a39a9c7a3867132194bc09c37fa94cf80f86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e404a39a9c7a3867132194bc09c37fa94cf80f86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e404a39a9c7a3867132194bc09c37fa94cf80f86/comments", "author": null, "committer": null, "parents": [{"sha": "8ed694b11a09a4e757c660ca7c53612380e8fc0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ed694b11a09a4e757c660ca7c53612380e8fc0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ed694b11a09a4e757c660ca7c53612380e8fc0d"}], "stats": {"total": 39, "additions": 39, "deletions": 0}, "files": [{"sha": "1b322bbee0d65dd8006208acb8d1e96a71bf8b13", "filename": "gcc/reload1.c", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e404a39a9c7a3867132194bc09c37fa94cf80f86/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e404a39a9c7a3867132194bc09c37fa94cf80f86/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=e404a39a9c7a3867132194bc09c37fa94cf80f86", "patch": "@@ -802,6 +802,7 @@ reload (first, global, dumpfile)\n       rtx max_nongroups_insn[N_REG_CLASSES];\n       rtx x;\n       int starting_frame_size = get_frame_size ();\n+      static char *reg_class_names[] = REG_CLASS_NAMES;\n \n       something_changed = 0;\n       bzero (max_needs, sizeof max_needs);\n@@ -1323,6 +1324,27 @@ reload (first, global, dumpfile)\n       if (starting_frame_size != get_frame_size ())\n \tsomething_changed = 1;\n \n+      if (dumpfile)\n+\tfor (i = 0; i < N_REG_CLASSES; i++)\n+\t  {\n+\t    if (max_needs[i] > 0)\n+\t      fprintf (dumpfile,\n+\t\t\t \";; Need %d reg%s of class %s (for insn %d).\\n\",\n+\t\t       max_needs[i], max_needs[i] == 1 ? \"\" : \"s\",\n+\t\t       reg_class_names[i], INSN_UID (max_needs_insn[i]));\n+\t    if (max_nongroups[i] > 0)\n+\t      fprintf (dumpfile,\n+\t\t       \";; Need %d nongroup reg%s of class %s (for insn %d).\\n\",\n+\t\t       max_nongroups[i], max_nongroups[i] == 1 ? \"\" : \"s\",\n+\t\t       reg_class_names[i], INSN_UID (max_nongroups_insn[i]));\n+\t    if (max_groups[i] > 0)\n+\t      fprintf (dumpfile,\n+\t\t       \";; Need %d group%s (%smode) of class %s (for insn %d).\\n\",\n+\t\t       max_groups[i], max_groups[i] == 1 ? \"\" : \"s\",\n+\t\t       mode_name[(int) group_mode[i]],\n+\t\t       reg_class_names[i], INSN_UID (max_groups_insn[i]));\n+\t  }\n+\t\t\t \n       /* If we have caller-saves, set up the save areas and see if caller-save\n \t will need a spill register.  */\n \n@@ -1703,6 +1725,23 @@ reload (first, global, dumpfile)\n \t\t\t|| possible_group_p (potential_reload_regs[i], max_groups)))\n \t\t  break;\n \n+\t      /* If we couldn't get a register, try to get one even if we\n+\t\t might foreclose possible groups.  This may cause problems\n+\t\t later, but that's better than aborting now, since it is\n+\t\t possible that we will, in fact, be able to form the needed\n+\t\t group even with this allocation.  */\n+\n+\t      if (i >= FIRST_PSEUDO_REGISTER\n+\t\t  && (asm_noperands (max_needs[class] > 0\n+\t\t\t\t     ? max_needs_insn[class]\n+\t\t\t\t     : max_nongroups_insn[class])\n+\t\t      < 0))\n+\t\tfor (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t\t  if (potential_reload_regs[i] >= 0\n+\t\t      && TEST_HARD_REG_BIT (reg_class_contents[class],\n+\t\t\t\t\t    potential_reload_regs[i]))\n+\t\t    break;\n+\n \t      /* I should be the index in potential_reload_regs\n \t\t of the new reload reg we have found.  */\n "}]}