{"sha": "c1a19acbfd17a67e79e71cc0d617ba804f0d15d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFhMTlhY2JmZDE3YTY3ZTc5ZTcxY2MwZDYxN2JhODA0ZjBkMTVkMQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-04-23T02:46:03Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-04-23T02:46:03Z"}, "message": "real.c (do_add): Change to return a bool indicating that the result of the operation may be...\n\n\n\t* real.c (do_add): Change to return a bool indicating that the\n\tresult of the operation may be inexact due to loss of precision.\n\t(do_multiply): Likewise.\n\t(do_divide): Likewise.\n\nFrom-SVN: r65980", "tree": {"sha": "a4f65e0c74166fc582d3742c93aa64dd4ebcc3a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4f65e0c74166fc582d3742c93aa64dd4ebcc3a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1a19acbfd17a67e79e71cc0d617ba804f0d15d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1a19acbfd17a67e79e71cc0d617ba804f0d15d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1a19acbfd17a67e79e71cc0d617ba804f0d15d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1a19acbfd17a67e79e71cc0d617ba804f0d15d1/comments", "author": null, "committer": null, "parents": [{"sha": "438f50c386103c9bf04de9f5c37bf9076ac1c112", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/438f50c386103c9bf04de9f5c37bf9076ac1c112", "html_url": "https://github.com/Rust-GCC/gccrs/commit/438f50c386103c9bf04de9f5c37bf9076ac1c112"}], "stats": {"total": 94, "additions": 59, "deletions": 35}, "files": [{"sha": "ab6dd74e1defd617c4afb0c776517bc4eaf333c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a19acbfd17a67e79e71cc0d617ba804f0d15d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a19acbfd17a67e79e71cc0d617ba804f0d15d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c1a19acbfd17a67e79e71cc0d617ba804f0d15d1", "patch": "@@ -1,3 +1,10 @@\n+2003-04-22  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* real.c (do_add): Change to return a bool indicating that the\n+\tresult of the operation may be inexact due to loss of precision.\n+\t(do_multiply): Likewise.\n+\t(do_divide): Likewise.\n+\n 2003-04-22  Geoffrey Keating  <geoffk@apple.com>\n \t    Loren James Rittle  <ljrittle@acm.org>\n "}, {"sha": "db658fdcb95c6929fd85fbadc974edc0f1dd7f79", "filename": "gcc/real.c", "status": "modified", "additions": 52, "deletions": 35, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a19acbfd17a67e79e71cc0d617ba804f0d15d1/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a19acbfd17a67e79e71cc0d617ba804f0d15d1/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=c1a19acbfd17a67e79e71cc0d617ba804f0d15d1", "patch": "@@ -115,12 +115,12 @@ static bool div_significands PARAMS ((REAL_VALUE_TYPE *,\n \t\t\t\t      const REAL_VALUE_TYPE *));\n static void normalize PARAMS ((REAL_VALUE_TYPE *));\n \n-static void do_add PARAMS ((REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *,\n+static bool do_add PARAMS ((REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *,\n \t\t\t    const REAL_VALUE_TYPE *, int));\n-static void do_multiply PARAMS ((REAL_VALUE_TYPE *,\n+static bool do_multiply PARAMS ((REAL_VALUE_TYPE *,\n \t\t\t\t const REAL_VALUE_TYPE *,\n \t\t\t\t const REAL_VALUE_TYPE *));\n-static void do_divide PARAMS ((REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *,\n+static bool do_divide PARAMS ((REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *,\n \t\t\t       const REAL_VALUE_TYPE *));\n static int do_compare PARAMS ((const REAL_VALUE_TYPE *,\n \t\t\t       const REAL_VALUE_TYPE *, int));\n@@ -563,9 +563,10 @@ normalize (r)\n     }\n }\n \f\n-/* Return R = A + (SUBTRACT_P ? -B : B).  */\n+/* Calculate R = A + (SUBTRACT_P ? -B : B).  Return true if the\n+   result may be inexact due to a loss of precision.  */\n \n-static void\n+static bool\n do_add (r, a, b, subtract_p)\n      REAL_VALUE_TYPE *r;\n      const REAL_VALUE_TYPE *a, *b;\n@@ -584,7 +585,7 @@ do_add (r, a, b, subtract_p)\n     case CLASS2 (rvc_zero, rvc_zero):\n       /* -0 + -0 = -0, -0 - +0 = -0; all other cases yield +0.  */\n       get_zero (r, sign & !subtract_p);\n-      return;\n+      return false;\n \n     case CLASS2 (rvc_zero, rvc_normal):\n     case CLASS2 (rvc_zero, rvc_inf):\n@@ -598,7 +599,7 @@ do_add (r, a, b, subtract_p)\n       /* R + Inf = Inf.  */\n       *r = *b;\n       r->sign = sign ^ subtract_p;\n-      return;\n+      return false;\n \n     case CLASS2 (rvc_normal, rvc_zero):\n     case CLASS2 (rvc_inf, rvc_zero):\n@@ -610,7 +611,7 @@ do_add (r, a, b, subtract_p)\n     case CLASS2 (rvc_inf, rvc_normal):\n       /* Inf + R = Inf.  */\n       *r = *a;\n-      return;\n+      return false;\n \n     case CLASS2 (rvc_inf, rvc_inf):\n       if (subtract_p)\n@@ -619,7 +620,7 @@ do_add (r, a, b, subtract_p)\n       else\n \t/* Inf + Inf = Inf.  */\n \t*r = *a;\n-      return;\n+      return false;\n \n     case CLASS2 (rvc_normal, rvc_normal):\n       break;\n@@ -649,7 +650,7 @@ do_add (r, a, b, subtract_p)\n \t{\n \t  *r = *a;\n \t  r->sign = sign;\n-\t  return;\n+\t  return true;\n \t}\n \n       inexact |= sticky_rshift_significand (&t, b, dexp);\n@@ -680,7 +681,7 @@ do_add (r, a, b, subtract_p)\n \t  if (++exp > MAX_EXP)\n \t    {\n \t      get_inf (r, sign);\n-\t      return;\n+\t      return true;\n \t    }\n \t}\n     }\n@@ -698,18 +699,21 @@ do_add (r, a, b, subtract_p)\n     r->sign = 0;\n   else\n     r->sig[0] |= inexact;\n+\n+  return inexact;\n }\n \n-/* Return R = A * B.  */\n+/* Calculate R = A * B.  Return true if the result may be inexact.  */\n \n-static void\n+static bool\n do_multiply (r, a, b)\n      REAL_VALUE_TYPE *r;\n      const REAL_VALUE_TYPE *a, *b;\n {\n   REAL_VALUE_TYPE u, t, *rr;\n   unsigned int i, j, k;\n   int sign = a->sign ^ b->sign;\n+  bool inexact = false;\n \n   switch (CLASS2 (a->class, b->class))\n     {\n@@ -718,7 +722,7 @@ do_multiply (r, a, b)\n     case CLASS2 (rvc_normal, rvc_zero):\n       /* +-0 * ANY = 0 with appropriate sign.  */\n       get_zero (r, sign);\n-      return;\n+      return false;\n \n     case CLASS2 (rvc_zero, rvc_nan):\n     case CLASS2 (rvc_normal, rvc_nan):\n@@ -727,29 +731,28 @@ do_multiply (r, a, b)\n       /* ANY * NaN = NaN.  */\n       *r = *b;\n       r->sign = sign;\n-      return;\n+      return false;\n \n     case CLASS2 (rvc_nan, rvc_zero):\n     case CLASS2 (rvc_nan, rvc_normal):\n     case CLASS2 (rvc_nan, rvc_inf):\n       /* NaN * ANY = NaN.  */\n       *r = *a;\n       r->sign = sign;\n-      return;\n+      return false;\n \n     case CLASS2 (rvc_zero, rvc_inf):\n     case CLASS2 (rvc_inf, rvc_zero):\n       /* 0 * Inf = NaN */\n       get_canonical_qnan (r, sign);\n-      return;\n+      return false;\n \n     case CLASS2 (rvc_inf, rvc_inf):\n     case CLASS2 (rvc_normal, rvc_inf):\n     case CLASS2 (rvc_inf, rvc_normal):\n       /* Inf * Inf = Inf, R * Inf = Inf */\n-    overflow:\n       get_inf (r, sign);\n-      return;\n+      return false;\n \n     case CLASS2 (rvc_normal, rvc_normal):\n       break;\n@@ -799,10 +802,16 @@ do_multiply (r, a, b)\n \t\t     + (b->exp - (1-j)*(HOST_BITS_PER_LONG/2)));\n \n \t  if (exp > MAX_EXP)\n-\t    goto overflow;\n+\t    {\n+\t      get_inf (r, sign);\n+\t      return true;\n+\t    }\n \t  if (exp < -MAX_EXP)\n-\t    /* Would underflow to zero, which we shouldn't bother adding.  */\n-\t    continue;\n+\t    {\n+\t      /* Would underflow to zero, which we shouldn't bother adding.  */\n+\t      inexact = true;\n+\t      continue;\n+\t    }\n \n \t  u.class = rvc_normal;\n \t  u.sign = 0;\n@@ -820,18 +829,20 @@ do_multiply (r, a, b)\n \t    }\n \n \t  normalize (&u);\n-\t  do_add (rr, rr, &u, 0);\n+\t  inexact |= do_add (rr, rr, &u, 0);\n \t}\n     }\n \n   rr->sign = sign;\n   if (rr != r)\n     *r = t;\n+\n+  return inexact;\n }\n \n-/* Return R = A / B.  */\n+/* Calculate R = A / B.  Return true if the result may be inexact.  */\n \n-static void\n+static bool\n do_divide (r, a, b)\n      REAL_VALUE_TYPE *r;\n      const REAL_VALUE_TYPE *a, *b;\n@@ -847,23 +858,22 @@ do_divide (r, a, b)\n     case CLASS2 (rvc_inf, rvc_inf):\n       /* Inf / Inf = NaN.  */\n       get_canonical_qnan (r, sign);\n-      return;\n+      return false;\n \n     case CLASS2 (rvc_zero, rvc_normal):\n     case CLASS2 (rvc_zero, rvc_inf):\n       /* 0 / ANY = 0.  */\n     case CLASS2 (rvc_normal, rvc_inf):\n       /* R / Inf = 0.  */\n-    underflow:\n       get_zero (r, sign);\n-      return;\n+      return false;\n \n     case CLASS2 (rvc_normal, rvc_zero):\n       /* R / 0 = Inf.  */\n     case CLASS2 (rvc_inf, rvc_zero):\n       /* Inf / 0 = Inf.  */\n       get_inf (r, sign);\n-      return;\n+      return false;\n \n     case CLASS2 (rvc_zero, rvc_nan):\n     case CLASS2 (rvc_normal, rvc_nan):\n@@ -872,21 +882,20 @@ do_divide (r, a, b)\n       /* ANY / NaN = NaN.  */\n       *r = *b;\n       r->sign = sign;\n-      return;\n+      return false;\n \n     case CLASS2 (rvc_nan, rvc_zero):\n     case CLASS2 (rvc_nan, rvc_normal):\n     case CLASS2 (rvc_nan, rvc_inf):\n       /* NaN / ANY = NaN.  */\n       *r = *a;\n       r->sign = sign;\n-      return;\n+      return false;\n \n     case CLASS2 (rvc_inf, rvc_normal):\n       /* Inf / R = Inf.  */\n-    overflow:\n       get_inf (r, sign);\n-      return;\n+      return false;\n \n     case CLASS2 (rvc_normal, rvc_normal):\n       break;\n@@ -905,9 +914,15 @@ do_divide (r, a, b)\n \n   exp = a->exp - b->exp + 1;\n   if (exp > MAX_EXP)\n-    goto overflow;\n+    {\n+      get_inf (r, sign);\n+      return true;\n+    }\n   if (exp < -MAX_EXP)\n-    goto underflow;\n+    {\n+      get_zero (r, sign);\n+      return true;\n+    }\n   rr->exp = exp;\n \n   inexact = div_significands (rr, a, b);\n@@ -918,6 +933,8 @@ do_divide (r, a, b)\n \n   if (rr != r)\n     *r = t;\n+\n+  return inexact;\n }\n \n /* Return a tri-state comparison of A vs B.  Return NAN_RESULT if"}]}