{"sha": "05b9868b182bb9ed2013b39a0bc6297354a0db49", "node_id": "C_kwDOANBUbNoAKDA1Yjk4NjhiMTgyYmI5ZWQyMDEzYjM5YTBiYzYyOTczNTRhMGRiNDk", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-01-19T09:00:51Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-01-19T09:00:51Z"}, "message": "forwprop: Further fixes for simplify_rotate [PR108440]\n\nAs mentioned in the simplify_rotate comment, for e.g.\n   ((T) ((T2) X << (Y & (B - 1)))) | ((T) ((T2) X >> ((-Y) & (B - 1))))\nwe already emit\n   X r<< (Y & (B - 1))\nas replacement.  This PR is about the\n   ((T) ((T2) X << Y)) OP ((T) ((T2) X >> (B - Y)))\n   ((T) ((T2) X << (int) Y)) OP ((T) ((T2) X >> (int) (B - Y)))\nforms if T2 is wider than T.  Unlike e.g.\n   (X << Y) OP (X >> (B - Y))\nwhich is valid just for Y in [1, B - 1], the above 2 forms are actually\nvalid and do the rotates for Y in [0, B] - for Y 0 the X value is preserved\nby the left shift and right logical shift by B adds just zeros (but because\nthe shift is in wider precision B is still valid shift count), while for\nY equal to B X is preserved through the latter shift and the former adds\njust zeros.\nNow, it is unclear if we in the middle-end treat rotates with rotate count\nequal or larger than precision as UB or not, unlike shifts there are less\nreasons to do so, but e.g. expansion of X r<< Y if there is no rotate optab\nfor the mode is emitted as (X << Y) | (((unsigned) X) >> ((-Y) & (B - 1)))\nand so with UB on Y == B.\n\nThe following patch does multiple things:\n1) for the above 2, asks the ranger if Y could be equal to B and if so,\n   instead of using X r<< Y uses X r<< (Y & (B - 1))\n2) for the\n   ((T) ((T2) X << Y)) | ((T) ((T2) X >> ((-Y) & (B - 1))))\n   ((T) ((T2) X << (int) Y)) | ((T) ((T2) X >> (int) ((-Y) & (B - 1))))\n   forms that were fixed 2 days ago it only punts if Y might be in the\n   [B,B2-1] range but isn't known to be in the\n   [0,B][2*B,2*B][3*B,3*B]... range.  Because for Y which is a multiple\n   of B but smaller than B2 it acts as a rotate too, left shift provides\n   0 and (-Y) & (B - 1) is 0 and so preserves X.  Though, for the cases\n   where Y is not known to be in [0,B-1] the patch also uses\n   X r<< (Y & (B - 1)) rather than X r<< Y\n3) as discussed with Aldy, instead of using global ranger it uses a pass\n   specific copy but lazily created on first simplify_rotate that needs it;\n   this e.g. handles rotate inside of if body where the guarding condition\n   limits the shift count to some range which will not work with the\n   global ranger (unless there is some SSA_NAME to attach the range to).\n\nNote, e.g. on x86 X r<< (Y & (B - 1)) and X r<< Y actually emit the\nsame assembly because rotates work the same even for larger rotate counts,\nbut that is handled only during combine.\n\n2023-01-19  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/108440\n\t* tree-ssa-forwprop.cc: Include gimple-range.h.\n\t(simplify_rotate): For the forms with T2 wider than T and shift counts of\n\tY and B - Y add & (B - 1) masking for the rotate count if Y could be equal\n\tto B.  For the forms with T2 wider than T and shift counts of\n\tY and (-Y) & (B - 1), don't punt if range could be [B, B2], but only if\n\trange doesn't guarantee Y < B or Y = N * B.  If range doesn't guarantee\n\tY < B, also add & (B - 1) masking for the rotate count.  Use lazily created\n\tpass specific ranger instead of get_global_range_query.\n\t(pass_forwprop::execute): Disable that ranger at the end of pass if it has\n\tbeen created.\n\n\t* c-c++-common/rotate-10.c: New test.\n\t* c-c++-common/rotate-11.c: New test.", "tree": {"sha": "98f2063ab18781a7c211122be338aaf9b9cf4379", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98f2063ab18781a7c211122be338aaf9b9cf4379"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05b9868b182bb9ed2013b39a0bc6297354a0db49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05b9868b182bb9ed2013b39a0bc6297354a0db49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05b9868b182bb9ed2013b39a0bc6297354a0db49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05b9868b182bb9ed2013b39a0bc6297354a0db49/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22c75b4ed94bd731cb6e37c507de1d91954a17cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22c75b4ed94bd731cb6e37c507de1d91954a17cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22c75b4ed94bd731cb6e37c507de1d91954a17cf"}], "stats": {"total": 179, "additions": 170, "deletions": 9}, "files": [{"sha": "683d2cbc96bf2b585746bfb6f472880151583383", "filename": "gcc/testsuite/c-c++-common/rotate-10.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05b9868b182bb9ed2013b39a0bc6297354a0db49/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Frotate-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05b9868b182bb9ed2013b39a0bc6297354a0db49/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Frotate-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Frotate-10.c?ref=05b9868b182bb9ed2013b39a0bc6297354a0db49", "patch": "@@ -0,0 +1,53 @@\n+/* PR tree-optimization/108440 */\n+/* { dg-do compile { target { { ilp32 || lp64 } || llp64 } } } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-times \" r<< \" 5 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\\\& 7;\" 4 \"optimized\" } } */\n+\n+unsigned char\n+foo (unsigned char x, unsigned int y)\n+{\n+  if (y > __CHAR_BIT__)\n+    __builtin_unreachable ();\n+  return (x << y) | (x >> ((-y) & (__CHAR_BIT__ - 1)));\n+}\n+\n+unsigned char\n+bar (unsigned char x, unsigned int y)\n+{\n+  if (y >= __CHAR_BIT__)\n+    __builtin_unreachable ();\n+  return (x << y) | (x >> ((-y) & (__CHAR_BIT__ - 1)));\n+}\n+\n+unsigned char\n+baz (unsigned char x, unsigned int y)\n+{\n+  if (y > __CHAR_BIT__ && y != 2 * __CHAR_BIT__)\n+    __builtin_unreachable ();\n+  return (x << y) | (x >> ((-y) & (__CHAR_BIT__ - 1)));\n+}\n+\n+unsigned char\n+qux (unsigned char x, unsigned int y)\n+{\n+  if (y > __CHAR_BIT__ && y != 2 * __CHAR_BIT__ && y != __CHAR_BIT__ + 2)\n+    __builtin_unreachable ();\n+  return (x << y) | (x >> ((-y) & (__CHAR_BIT__ - 1)));\n+}\n+\n+unsigned char\n+quux (unsigned char x, unsigned int y)\n+{\n+  if (y > __CHAR_BIT__)\n+    __builtin_unreachable ();\n+  return (x << y) | (x >> (__CHAR_BIT__ - y));\n+}\n+\n+unsigned char\n+corge (unsigned char x, unsigned int y)\n+{\n+  if (y >= __CHAR_BIT__)\n+    __builtin_unreachable ();\n+  return (x << y) | (x >> (__CHAR_BIT__ - y));\n+}"}, {"sha": "e57db19d949ed9c3cc8e2eecbaa20102b0ef4fca", "filename": "gcc/testsuite/c-c++-common/rotate-11.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05b9868b182bb9ed2013b39a0bc6297354a0db49/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Frotate-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05b9868b182bb9ed2013b39a0bc6297354a0db49/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Frotate-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Frotate-11.c?ref=05b9868b182bb9ed2013b39a0bc6297354a0db49", "patch": "@@ -0,0 +1,53 @@\n+/* PR tree-optimization/108440 */\n+/* { dg-do compile { target { { ilp32 || lp64 } || llp64 } } } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-times \" r<< \" 5 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\\\& 7;\" 4 \"optimized\" } } */\n+\n+unsigned char\n+foo (unsigned char x, unsigned int y)\n+{\n+  if (y > __CHAR_BIT__)\n+    return 42;\n+  return (x << y) | (x >> ((-y) & (__CHAR_BIT__ - 1)));\n+}\n+\n+unsigned char\n+bar (unsigned char x, unsigned int y)\n+{\n+  if (y >= __CHAR_BIT__)\n+    return 42;\n+  return (x << y) | (x >> ((-y) & (__CHAR_BIT__ - 1)));\n+}\n+\n+unsigned char\n+baz (unsigned char x, unsigned int y)\n+{\n+  if (y > __CHAR_BIT__ && y != 2 * __CHAR_BIT__)\n+    return 42;\n+  return (x << y) | (x >> ((-y) & (__CHAR_BIT__ - 1)));\n+}\n+\n+unsigned char\n+qux (unsigned char x, unsigned int y)\n+{\n+  if (y > __CHAR_BIT__ && y != 2 * __CHAR_BIT__ && y != __CHAR_BIT__ + 2)\n+    return 42;\n+  return (x << y) | (x >> ((-y) & (__CHAR_BIT__ - 1)));\n+}\n+\n+unsigned char\n+quux (unsigned char x, unsigned int y)\n+{\n+  if (y > __CHAR_BIT__)\n+    return 42;\n+  return (x << y) | (x >> (__CHAR_BIT__ - y));\n+}\n+\n+unsigned char\n+corge (unsigned char x, unsigned int y)\n+{\n+  if (y >= __CHAR_BIT__)\n+    return 42;\n+  return (x << y) | (x >> (__CHAR_BIT__ - y));\n+}"}, {"sha": "0841a739fe14305c54d8e9366ba8319babdd8196", "filename": "gcc/tree-ssa-forwprop.cc", "status": "modified", "additions": 64, "deletions": 9, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05b9868b182bb9ed2013b39a0bc6297354a0db49/gcc%2Ftree-ssa-forwprop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05b9868b182bb9ed2013b39a0bc6297354a0db49/gcc%2Ftree-ssa-forwprop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.cc?ref=05b9868b182bb9ed2013b39a0bc6297354a0db49", "patch": "@@ -52,6 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"internal-fn.h\"\n #include \"cgraph.h\"\n #include \"tree-ssa.h\"\n+#include \"gimple-range.h\"\n \n /* This pass propagates the RHS of assignment statements into use\n    sites of the LHS of the assignment.  It's basically a specialized\n@@ -1837,8 +1838,12 @@ defcodefor_name (tree name, enum tree_code *code, tree *arg1, tree *arg2)\n    ((T) ((T2) X << Y)) | ((T) ((T2) X >> ((-Y) & (B - 1))))\n    ((T) ((T2) X << (int) Y)) | ((T) ((T2) X >> (int) ((-Y) & (B - 1))))\n \n-   transform these into (last 2 only if ranger can prove Y < B):\n+   transform these into (last 2 only if ranger can prove Y < B\n+   or Y = N * B):\n    X r<< Y\n+   or\n+   X r<< (& & (B - 1))\n+   The latter for the forms with T2 wider than T if ranger can't prove Y < B.\n \n    Or for:\n    (X << (Y & (B - 1))) | (X >> ((-Y) & (B - 1)))\n@@ -1868,6 +1873,7 @@ simplify_rotate (gimple_stmt_iterator *gsi)\n   gimple *g;\n   gimple *def_arg_stmt[2] = { NULL, NULL };\n   int wider_prec = 0;\n+  bool add_masking = false;\n \n   arg[0] = gimple_assign_rhs1 (stmt);\n   arg[1] = gimple_assign_rhs2 (stmt);\n@@ -1995,7 +2001,7 @@ simplify_rotate (gimple_stmt_iterator *gsi)\n       tree cdef_arg1[2], cdef_arg2[2], def_arg2_alt[2];\n       enum tree_code cdef_code[2];\n       gimple *def_arg_alt_stmt[2] = { NULL, NULL };\n-      bool check_range = false;\n+      int check_range = 0;\n       gimple *check_range_stmt = NULL;\n       /* Look through conversion of the shift count argument.\n \t The C/C++ FE cast any shift count argument to integer_type_node.\n@@ -2036,6 +2042,11 @@ simplify_rotate (gimple_stmt_iterator *gsi)\n \t\t|| cdef_arg2[i] == def_arg2_alt[1 - i])\n \t      {\n \t\trotcnt = cdef_arg2[i];\n+\t\tcheck_range = -1;\n+\t\tif (cdef_arg2[i] == def_arg2[1 - i])\n+\t\t  check_range_stmt = def_arg_stmt[1 - i];\n+\t\telse\n+\t\t  check_range_stmt = def_arg_alt_stmt[1 - i];\n \t\tbreak;\n \t      }\n \t    defcodefor_name (cdef_arg2[i], &code, &tem, NULL);\n@@ -2048,6 +2059,11 @@ simplify_rotate (gimple_stmt_iterator *gsi)\n \t\t    || tem == def_arg2_alt[1 - i]))\n \t      {\n \t\trotcnt = tem;\n+\t\tcheck_range = -1;\n+\t\tif (tem == def_arg2[1 - i])\n+\t\t  check_range_stmt = def_arg_stmt[1 - i];\n+\t\telse\n+\t\t  check_range_stmt = def_arg_alt_stmt[1 - i];\n \t\tbreak;\n \t      }\n \t  }\n@@ -2080,7 +2096,7 @@ simplify_rotate (gimple_stmt_iterator *gsi)\n \t\tif (tem == def_arg2[1 - i] || tem == def_arg2_alt[1 - i])\n \t\t  {\n \t\t    rotcnt = tem;\n-\t\t    check_range = true;\n+\t\t    check_range = 1;\n \t\t    if (tem == def_arg2[1 - i])\n \t\t      check_range_stmt = def_arg_stmt[1 - i];\n \t\t    else\n@@ -2099,7 +2115,7 @@ simplify_rotate (gimple_stmt_iterator *gsi)\n \t\t\t|| tem2 == def_arg2_alt[1 - i])\n \t\t      {\n \t\t\trotcnt = tem2;\n-\t\t\tcheck_range = true;\n+\t\t\tcheck_range = 1;\n \t\t\tif (tem2 == def_arg2[1 - i])\n \t\t\t  check_range_stmt = def_arg_stmt[1 - i];\n \t\t\telse\n@@ -2144,17 +2160,44 @@ simplify_rotate (gimple_stmt_iterator *gsi)\n \t  if (TREE_CODE (rotcnt) != SSA_NAME)\n \t    return false;\n \t  int_range_max r;\n-\t  if (!get_global_range_query ()->range_of_expr (r, rotcnt,\n-\t\t\t\t\t\t\t check_range_stmt))\n-\t    return false;\n+\t  range_query *q = get_range_query (cfun);\n+\t  if (q == get_global_range_query ())\n+\t    q = enable_ranger (cfun);\n+\t  if (!q->range_of_expr (r, rotcnt, check_range_stmt))\n+\t    {\n+\t      if (check_range > 0)\n+\t\treturn false;\n+\t      r.set_varying (TREE_TYPE (rotcnt));\n+\t    }\n \t  int prec = TYPE_PRECISION (TREE_TYPE (rotcnt));\n \t  signop sign = TYPE_SIGN (TREE_TYPE (rotcnt));\n \t  wide_int min = wide_int::from (TYPE_PRECISION (rtype), prec, sign);\n \t  wide_int max = wide_int::from (wider_prec - 1, prec, sign);\n-\t  int_range<2> r2 (TREE_TYPE (rotcnt), min, max);\n+\t  if (check_range < 0)\n+\t    max = min;\n+\t  int_range<1> r2 (TREE_TYPE (rotcnt), min, max);\n \t  r.intersect (r2);\n \t  if (!r.undefined_p ())\n-\t    return false;\n+\t    {\n+\t      if (check_range > 0)\n+\t\t{\n+\t\t  int_range_max r3;\n+\t\t  for (int i = TYPE_PRECISION (rtype) + 1; i < wider_prec;\n+\t\t       i += TYPE_PRECISION (rtype))\n+\t\t    {\n+\t\t      int j = i + TYPE_PRECISION (rtype) - 2;\n+\t\t      min = wide_int::from (i, prec, sign);\n+\t\t      max = wide_int::from (MIN (j, wider_prec - 1),\n+\t\t\t\t\t    prec, sign);\n+\t\t      int_range<1> r4 (TREE_TYPE (rotcnt), min, max);\n+\t\t      r3.union_ (r4);\n+\t\t    }\n+\t\t  r.intersect (r3);\n+\t\t  if (!r.undefined_p ())\n+\t\t    return false;\n+\t\t}\n+\t      add_masking = true;\n+\t    }\n \t}\n       if (rotcnt == NULL_TREE)\n \treturn false;\n@@ -2169,6 +2212,15 @@ simplify_rotate (gimple_stmt_iterator *gsi)\n       gsi_insert_before (gsi, g, GSI_SAME_STMT);\n       rotcnt = gimple_assign_lhs (g);\n     }\n+  if (add_masking)\n+    {\n+      g = gimple_build_assign (make_ssa_name (TREE_TYPE (rotcnt)),\n+\t\t\t       BIT_AND_EXPR, rotcnt,\n+\t\t\t       build_int_cst (TREE_TYPE (rotcnt),\n+\t\t\t\t\t      TYPE_PRECISION (rtype) - 1));\n+      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+      rotcnt = gimple_assign_lhs (g);\n+    }\n   lhs = gimple_assign_lhs (stmt);\n   if (!useless_type_conversion_p (rtype, TREE_TYPE (def_arg1[0])))\n     lhs = make_ssa_name (TREE_TYPE (def_arg1[0]));\n@@ -3958,6 +4010,9 @@ pass_forwprop::execute (function *fun)\n   BITMAP_FREE (to_purge);\n   BITMAP_FREE (need_ab_cleanup);\n \n+  if (get_range_query (cfun) != get_global_range_query ())\n+    disable_ranger (cfun);\n+\n   if (cfg_changed)\n     todoflags |= TODO_cleanup_cfg;\n "}]}