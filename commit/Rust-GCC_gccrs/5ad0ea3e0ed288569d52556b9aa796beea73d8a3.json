{"sha": "5ad0ea3e0ed288569d52556b9aa796beea73d8a3", "node_id": "C_kwDOANBUbNoAKDVhZDBlYTNlMGVkMjg4NTY5ZDUyNTU2YjlhYTc5NmJlZWE3M2Q4YTM", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-05-20T11:35:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-20T11:35:25Z"}, "message": "Merge #1258\n\n1258: Report privacy errors on explicit types r=CohenArthur a=CohenArthur\n\n~~Needs #1255, so skip reviewing the first commit or wait for it to be merged~~ Done and rebased :)\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "ae7bea4a2b13b1052e7a998104bb6aaff7e1c429", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae7bea4a2b13b1052e7a998104bb6aaff7e1c429"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ad0ea3e0ed288569d52556b9aa796beea73d8a3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJih3z9CRBK7hj4Ov3rIwAAhP8IADHdsyG/SJAd4MRVqBtakCcu\niUrytwnuAAonxh0IvkpW06trTtFxHw/NplYu9xMDLIBhqrRs+6YFetyvqqbJ07Vr\njDmAl4pQFKPXxgAPftw/QNr0sd7/fIJ1lb0zdkZDXuczTGlypog5r019lkQUmrWQ\n2EfqBC3wHjuMceXfGMnD88/m18deD9XRGKNV1eam0jDr8g4x0SimJdyvoH+q1ocO\nkLMeBbMx5wNecrzQN7sx9qA8wnEm3ZGSBqkfISTNa3ffWa7LsDzNG1RvBAr4CuqG\nqwm2PK78yr/CxJusJubxYzDXDNRzrC7yPBH+ynkPLwA1kx01+8sncPw47P1km20=\n=PwJm\n-----END PGP SIGNATURE-----\n", "payload": "tree ae7bea4a2b13b1052e7a998104bb6aaff7e1c429\nparent e9d41c4ef9da8ba71570ecf83691c813c12d9149\nparent b0527990a14efd5abb857ea7edfd96c7ad78792e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1653046525 +0000\ncommitter GitHub <noreply@github.com> 1653046525 +0000\n\nMerge #1258\n\n1258: Report privacy errors on explicit types r=CohenArthur a=CohenArthur\n\n~~Needs #1255, so skip reviewing the first commit or wait for it to be merged~~ Done and rebased :)\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ad0ea3e0ed288569d52556b9aa796beea73d8a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ad0ea3e0ed288569d52556b9aa796beea73d8a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ad0ea3e0ed288569d52556b9aa796beea73d8a3/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9d41c4ef9da8ba71570ecf83691c813c12d9149", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9d41c4ef9da8ba71570ecf83691c813c12d9149", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9d41c4ef9da8ba71570ecf83691c813c12d9149"}, {"sha": "b0527990a14efd5abb857ea7edfd96c7ad78792e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0527990a14efd5abb857ea7edfd96c7ad78792e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0527990a14efd5abb857ea7edfd96c7ad78792e"}], "stats": {"total": 268, "additions": 240, "deletions": 28}, "files": [{"sha": "cab46b27b5d9be6929c05dcf9e21f7129f6ea682", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad0ea3e0ed288569d52556b9aa796beea73d8a3/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad0ea3e0ed288569d52556b9aa796beea73d8a3/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=5ad0ea3e0ed288569d52556b9aa796beea73d8a3", "patch": "@@ -486,6 +486,8 @@ class Type : public Node\n   virtual Type *clone_type_impl () const = 0;\n \n   Analysis::NodeMapping mappings;\n+\n+  // FIXME: How do we get the location here for each type?\n };\n \n // A type without parentheses? - abstract"}, {"sha": "9664d62f65c4fa2ebc8f5a38d832f431e203a13c", "filename": "gcc/rust/privacy/rust-privacy-check.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad0ea3e0ed288569d52556b9aa796beea73d8a3/gcc%2Frust%2Fprivacy%2Frust-privacy-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad0ea3e0ed288569d52556b9aa796beea73d8a3/gcc%2Frust%2Fprivacy%2Frust-privacy-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-privacy-check.cc?ref=5ad0ea3e0ed288569d52556b9aa796beea73d8a3", "patch": "@@ -41,7 +41,7 @@ Resolver::resolve (HIR::Crate &crate)\n \n   VisibilityResolver (*mappings, *resolver).go (crate);\n   PubRestrictedVisitor (*mappings).go (crate);\n-  PrivacyReporter (*mappings, *resolver).go (crate);\n+  PrivacyReporter (*mappings, *resolver, *ty_ctx).go (crate);\n \n   auto visitor = ReachabilityVisitor (ctx, *ty_ctx);\n "}, {"sha": "4b010a05b02699a78f882a92f2a73199aafa75e0", "filename": "gcc/rust/privacy/rust-privacy-reporter.cc", "status": "modified", "additions": 119, "deletions": 5, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad0ea3e0ed288569d52556b9aa796beea73d8a3/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad0ea3e0ed288569d52556b9aa796beea73d8a3/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.cc?ref=5ad0ea3e0ed288569d52556b9aa796beea73d8a3", "patch": "@@ -6,9 +6,10 @@\n namespace Rust {\n namespace Privacy {\n \n-PrivacyReporter::PrivacyReporter (Analysis::Mappings &mappings,\n-\t\t\t\t  Resolver::Resolver &resolver)\n-  : mappings (mappings), resolver (resolver),\n+PrivacyReporter::PrivacyReporter (\n+  Analysis::Mappings &mappings, Resolver::Resolver &resolver,\n+  const Rust::Resolver::TypeCheckContext &ty_ctx)\n+  : mappings (mappings), resolver (resolver), ty_ctx (ty_ctx),\n     current_module (Optional<NodeId>::none ())\n {}\n \n@@ -52,7 +53,11 @@ PrivacyReporter::check_for_privacy_violation (const NodeId &use_id,\n   if (!resolver.lookup_resolved_name (use_id, &ref_node_id))\n     resolver.lookup_resolved_type (use_id, &ref_node_id);\n \n-  rust_assert (ref_node_id != UNKNOWN_NODEID);\n+  // FIXME: Assert here. For now, we return since this causes issues when\n+  // checking inferred types (#1260)\n+  // rust_assert (ref_node_id != UNKNOWN_NODEID);\n+  if (ref_node_id == UNKNOWN_NODEID)\n+    return;\n \n   ModuleVisibility vis;\n \n@@ -97,6 +102,106 @@ PrivacyReporter::check_for_privacy_violation (const NodeId &use_id,\n     rust_error_at (locus, \"definition is private in this context\");\n }\n \n+void\n+PrivacyReporter::check_base_type_privacy (Analysis::NodeMapping &node_mappings,\n+\t\t\t\t\t  const TyTy::BaseType *ty,\n+\t\t\t\t\t  const Location &locus)\n+{\n+  // Avoids repeating commong argument such as `use_id` or `locus` since we're\n+  // doing a lot of recursive calls here\n+  auto recursive_check\n+    = [this, &node_mappings, &locus] (const TyTy::BaseType *ty) {\n+\treturn check_base_type_privacy (node_mappings, ty, locus);\n+      };\n+\n+  switch (ty->get_kind ())\n+    {\n+      // These \"simple\" types are our stop condition\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::ADT:\n+      case TyTy::STR: {\n+\tauto ref_id = ty->get_ref ();\n+\tNodeId lookup_id;\n+\n+\tmappings.lookup_hir_to_node (node_mappings.get_crate_num (), ref_id,\n+\t\t\t\t     &lookup_id);\n+\n+\treturn check_for_privacy_violation (lookup_id, locus);\n+      }\n+    case TyTy::REF:\n+      return recursive_check (\n+\tstatic_cast<const TyTy::ReferenceType *> (ty)->get_base ());\n+    case TyTy::POINTER:\n+      return recursive_check (\n+\tstatic_cast<const TyTy::PointerType *> (ty)->get_base ());\n+    case TyTy::ARRAY:\n+      return recursive_check (\n+\tstatic_cast<const TyTy::ArrayType *> (ty)->get_element_type ());\n+    case TyTy::SLICE:\n+      return recursive_check (\n+\tstatic_cast<const TyTy::SliceType *> (ty)->get_element_type ());\n+    case TyTy::FNPTR:\n+      for (auto &param : static_cast<const TyTy::FnPtr *> (ty)->get_params ())\n+\trecursive_check (param.get_tyty ());\n+      return recursive_check (\n+\tstatic_cast<const TyTy::FnPtr *> (ty)->get_return_type ());\n+    case TyTy::TUPLE:\n+      for (auto &param :\n+\t   static_cast<const TyTy::TupleType *> (ty)->get_fields ())\n+\trecursive_check (param.get_tyty ());\n+      return;\n+    case TyTy::PLACEHOLDER:\n+      return recursive_check (\n+\t// FIXME: Can we use `resolve` here? Is that what we should do?\n+\tstatic_cast<const TyTy::PlaceholderType *> (ty)->resolve ());\n+    case TyTy::PROJECTION:\n+      return recursive_check (\n+\tstatic_cast<const TyTy::ProjectionType *> (ty)->get ());\n+    case TyTy::CLOSURE:\n+      sorry_at (locus.gcc_location (),\n+\t\t\"privacy pass for closures is not handled yet\");\n+      break;\n+\n+      // If we're dealing with a generic param, there's nothing we should be\n+      // doing here\n+    case TyTy::PARAM:\n+      // We are dealing with a function definition that has been assigned\n+      // somewhere else. Nothing to resolve privacy-wise other than the actual\n+      // function, which is resolved as an expression\n+    case TyTy::FNDEF:\n+      // FIXME: Can we really not resolve Dynamic types here? Shouldn't we have\n+      // a look at the path and perform proper privacy analysis?\n+    case TyTy::DYNAMIC:\n+      // The never type is builtin and always available\n+    case TyTy::NEVER:\n+      // We shouldn't have inference types here, ever\n+    case TyTy::INFER:\n+      return;\n+    case TyTy::ERROR:\n+      rust_unreachable ();\n+    }\n+}\n+\n+void\n+PrivacyReporter::check_type_privacy (const HIR::Type *type,\n+\t\t\t\t     const Location &locus)\n+{\n+  rust_assert (type);\n+\n+  TyTy::BaseType *lookup = nullptr;\n+  rust_assert (\n+    ty_ctx.lookup_type (type->get_mappings ().get_hirid (), &lookup));\n+\n+  auto node_mappings = type->get_mappings ();\n+  return check_base_type_privacy (node_mappings, lookup, locus);\n+}\n+\n void\n PrivacyReporter::visit (HIR::IdentifierExpr &ident_expr)\n {}\n@@ -529,6 +634,11 @@ PrivacyReporter::visit (HIR::UseDeclaration &use_decl)\n void\n PrivacyReporter::visit (HIR::Function &function)\n {\n+  for (auto &param : function.get_function_params ())\n+    check_type_privacy (param.get_type (), param.get_locus ());\n+\n+  // FIXME: It would be better if it was specifically the type's locus (#1256)\n+\n   function.get_definition ()->accept_vis (*this);\n }\n \n@@ -626,7 +736,11 @@ PrivacyReporter::visit (HIR::EmptyStmt &stmt)\n void\n PrivacyReporter::visit (HIR::LetStmt &stmt)\n {\n-  // FIXME: We probably have to check the type as well\n+  auto type = stmt.get_type ();\n+  if (type)\n+    check_type_privacy (type, stmt.get_locus ());\n+  // FIXME: #1256\n+\n   auto init_expr = stmt.get_init_expr ();\n   if (init_expr)\n     init_expr->accept_vis (*this);"}, {"sha": "234bea718dca3b9b43d7f96eca5ae8ab162c7530", "filename": "gcc/rust/privacy/rust-privacy-reporter.h", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad0ea3e0ed288569d52556b9aa796beea73d8a3/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad0ea3e0ed288569d52556b9aa796beea73d8a3/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.h?ref=5ad0ea3e0ed288569d52556b9aa796beea73d8a3", "patch": "@@ -37,7 +37,8 @@ class PrivacyReporter : public HIR::HIRExpressionVisitor,\n {\n public:\n   PrivacyReporter (Analysis::Mappings &mappings,\n-\t\t   Rust::Resolver::Resolver &resolver);\n+\t\t   Rust::Resolver::Resolver &resolver,\n+\t\t   const Rust::Resolver::TypeCheckContext &ty_ctx);\n \n   /**\n    * Perform privacy error reporting on an entire crate\n@@ -57,6 +58,26 @@ class PrivacyReporter : public HIR::HIRExpressionVisitor,\n   void check_for_privacy_violation (const NodeId &use_id,\n \t\t\t\t    const Location &locus);\n \n+  /**\n+   * Internal function used by `check_type_privacy` when dealing with complex\n+types\n+   * such as references or arrays\n+   */\n+  void check_base_type_privacy (Analysis::NodeMapping &node_mappings,\n+\t\t\t\tconst TyTy::BaseType *ty,\n+\t\t\t\tconst Location &locus);\n+\n+  /**\n+   * Check the privacy of an explicit type.\n+   *\n+   * This function reports the errors it finds.\n+   *\n+   * @param type Reference to an explicit type used in a statement, expression\n+   * \t\tor parameter\n+   * @param locus Location of said type\n+   */\n+  void check_type_privacy (const HIR::Type *type, const Location &locus);\n+\n   virtual void visit (HIR::StructExprFieldIdentifier &field);\n   virtual void visit (HIR::StructExprFieldIdentifierValue &field);\n   virtual void visit (HIR::StructExprFieldIndexValue &field);\n@@ -142,6 +163,7 @@ class PrivacyReporter : public HIR::HIRExpressionVisitor,\n \n   Analysis::Mappings &mappings;\n   Rust::Resolver::Resolver &resolver;\n+  const Rust::Resolver::TypeCheckContext &ty_ctx;\n \n   // `None` means we're in the root module - the crate\n   Optional<NodeId> current_module;"}, {"sha": "8672c8acb12018f3270209320e1202edc2ba5191", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad0ea3e0ed288569d52556b9aa796beea73d8a3/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad0ea3e0ed288569d52556b9aa796beea73d8a3/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=5ad0ea3e0ed288569d52556b9aa796beea73d8a3", "patch": "@@ -239,7 +239,7 @@ Mappings::insert_hir_item (CrateNum crateNum, HirId id, HIR::Item *item)\n   rust_assert (lookup_hir_item (crateNum, id) == nullptr);\n \n   hirItemMappings[crateNum][id] = item;\n-  nodeIdToHirMappings[crateNum][item->get_mappings ().get_nodeid ()] = id;\n+  insert_node_to_hir (crateNum, item->get_mappings ().get_nodeid (), id);\n }\n \n HIR::Item *\n@@ -263,7 +263,7 @@ Mappings::insert_hir_trait_item (CrateNum crateNum, HirId id,\n   rust_assert (lookup_hir_trait_item (crateNum, id) == nullptr);\n \n   hirTraitItemMappings[crateNum][id] = item;\n-  nodeIdToHirMappings[crateNum][item->get_mappings ().get_nodeid ()] = id;\n+  insert_node_to_hir (crateNum, item->get_mappings ().get_nodeid (), id);\n }\n \n HIR::TraitItem *\n@@ -287,7 +287,7 @@ Mappings::insert_hir_extern_item (CrateNum crateNum, HirId id,\n   rust_assert (lookup_hir_extern_item (crateNum, id) == nullptr);\n \n   hirExternItemMappings[crateNum][id] = item;\n-  nodeIdToHirMappings[crateNum][item->get_mappings ().get_nodeid ()] = id;\n+  insert_node_to_hir (crateNum, item->get_mappings ().get_nodeid (), id);\n }\n \n HIR::ExternalItem *\n@@ -311,7 +311,7 @@ Mappings::insert_hir_impl_block (CrateNum crateNum, HirId id,\n   rust_assert (lookup_hir_impl_block (crateNum, id) == nullptr);\n \n   hirImplBlockMappings[crateNum][id] = item;\n-  nodeIdToHirMappings[crateNum][item->get_mappings ().get_nodeid ()] = id;\n+  insert_node_to_hir (crateNum, item->get_mappings ().get_nodeid (), id);\n }\n \n HIR::ImplBlock *\n@@ -357,7 +357,7 @@ Mappings::insert_hir_implitem (CrateNum crateNum, HirId id,\n   rust_assert (lookup_hir_implitem (crateNum, id, nullptr) == nullptr);\n   hirImplItemMappings[crateNum][id]\n     = std::pair<HirId, HIR::ImplItem *> (parent_impl_id, item);\n-  nodeIdToHirMappings[crateNum][item->get_impl_mappings ().get_nodeid ()] = id;\n+  insert_node_to_hir (crateNum, item->get_impl_mappings ().get_nodeid (), id);\n }\n \n HIR::ImplItem *\n@@ -383,7 +383,7 @@ void\n Mappings::insert_hir_expr (CrateNum crateNum, HirId id, HIR::Expr *expr)\n {\n   hirExprMappings[crateNum][id] = expr;\n-  nodeIdToHirMappings[crateNum][expr->get_mappings ().get_nodeid ()] = id;\n+  insert_node_to_hir (crateNum, expr->get_mappings ().get_nodeid (), id);\n   insert_location (crateNum, id, expr->get_locus ());\n }\n \n@@ -408,7 +408,7 @@ Mappings::insert_hir_path_expr_seg (CrateNum crateNum, HirId id,\n   rust_assert (lookup_hir_path_expr_seg (crateNum, id) == nullptr);\n \n   hirPathSegMappings[crateNum][id] = expr;\n-  nodeIdToHirMappings[crateNum][expr->get_mappings ().get_nodeid ()] = id;\n+  insert_node_to_hir (crateNum, expr->get_mappings ().get_nodeid (), id);\n   insert_location (crateNum, id, expr->get_locus ());\n }\n \n@@ -433,7 +433,7 @@ Mappings::insert_simple_path_segment (CrateNum crateNum, HirId id,\n   rust_assert (lookup_simple_path_segment (crateNum, id) == nullptr);\n \n   astSimplePathSegmentMappings[crateNum][id] = path;\n-  nodeIdToHirMappings[crateNum][path->get_node_id ()] = id;\n+  insert_node_to_hir (crateNum, path->get_node_id (), id);\n   insert_location (crateNum, id, path->get_locus ());\n }\n \n@@ -458,7 +458,7 @@ Mappings::insert_simple_path (CrateNum crateNum, HirId id,\n   rust_assert (lookup_simple_path (crateNum, id) == nullptr);\n \n   astSimplePathMappings[crateNum][id] = path;\n-  nodeIdToHirMappings[crateNum][path->get_node_id ()] = id;\n+  insert_node_to_hir (crateNum, path->get_node_id (), id);\n   insert_location (crateNum, id, path->get_locus ());\n }\n \n@@ -483,7 +483,7 @@ Mappings::insert_hir_generic_param (CrateNum crateNum, HirId id,\n   rust_assert (lookup_hir_generic_param (crateNum, id) == nullptr);\n \n   hirGenericParamMappings[crateNum][id] = param;\n-  nodeIdToHirMappings[crateNum][param->get_mappings ().get_nodeid ()] = id;\n+  insert_node_to_hir (crateNum, param->get_mappings ().get_nodeid (), id);\n   insert_location (crateNum, id, param->get_locus ());\n }\n \n@@ -507,7 +507,7 @@ Mappings::insert_hir_type (CrateNum crateNum, HirId id, HIR::Type *type)\n   rust_assert (lookup_hir_type (crateNum, id) == nullptr);\n \n   hirTypeMappings[crateNum][id] = type;\n-  nodeIdToHirMappings[crateNum][type->get_mappings ().get_nodeid ()] = id;\n+  insert_node_to_hir (crateNum, type->get_mappings ().get_nodeid (), id);\n }\n \n HIR::Type *\n@@ -525,12 +525,12 @@ Mappings::lookup_hir_type (CrateNum crateNum, HirId id)\n }\n \n void\n-Mappings::insert_hir_stmt (CrateNum crateNum, HirId id, HIR::Stmt *type)\n+Mappings::insert_hir_stmt (CrateNum crateNum, HirId id, HIR::Stmt *stmt)\n {\n   rust_assert (lookup_hir_stmt (crateNum, id) == nullptr);\n \n-  hirStmtMappings[crateNum][id] = type;\n-  nodeIdToHirMappings[crateNum][type->get_mappings ().get_nodeid ()] = id;\n+  hirStmtMappings[crateNum][id] = stmt;\n+  insert_node_to_hir (crateNum, stmt->get_mappings ().get_nodeid (), id);\n }\n \n HIR::Stmt *\n@@ -554,7 +554,7 @@ Mappings::insert_hir_param (CrateNum crateNum, HirId id,\n   rust_assert (lookup_hir_stmt (crateNum, id) == nullptr);\n \n   hirParamMappings[crateNum][id] = param;\n-  nodeIdToHirMappings[crateNum][param->get_mappings ().get_nodeid ()] = id;\n+  insert_node_to_hir (crateNum, param->get_mappings ().get_nodeid (), id);\n }\n \n HIR::FunctionParam *\n@@ -578,7 +578,7 @@ Mappings::insert_hir_self_param (CrateNum crateNum, HirId id,\n   rust_assert (lookup_hir_stmt (crateNum, id) == nullptr);\n \n   hirSelfParamMappings[crateNum][id] = param;\n-  nodeIdToHirMappings[crateNum][param->get_mappings ().get_nodeid ()] = id;\n+  insert_node_to_hir (crateNum, param->get_mappings ().get_nodeid (), id);\n }\n \n HIR::SelfParam *\n@@ -602,7 +602,7 @@ Mappings::insert_hir_struct_field (CrateNum crateNum, HirId id,\n   rust_assert (lookup_hir_stmt (crateNum, id) == nullptr);\n \n   hirStructFieldMappings[crateNum][id] = field;\n-  nodeIdToHirMappings[crateNum][field->get_mappings ().get_nodeid ()] = id;\n+  insert_node_to_hir (crateNum, field->get_mappings ().get_nodeid (), id);\n }\n \n HIR::StructExprField *\n@@ -624,8 +624,8 @@ Mappings::insert_hir_pattern (CrateNum crateNum, HirId id,\n \t\t\t      HIR::Pattern *pattern)\n {\n   hirPatternMappings[crateNum][id] = pattern;\n-  nodeIdToHirMappings[crateNum][pattern->get_pattern_mappings ().get_nodeid ()]\n-    = id;\n+  insert_node_to_hir (crateNum, pattern->get_pattern_mappings ().get_nodeid (),\n+\t\t      id);\n }\n \n HIR::Pattern *\n@@ -684,6 +684,7 @@ void\n Mappings::insert_node_to_hir (CrateNum crate, NodeId id, HirId ref)\n {\n   nodeIdToHirMappings[crate][id] = ref;\n+  hirIdToNodeMappings[crate][ref] = id;\n }\n \n bool\n@@ -701,6 +702,21 @@ Mappings::lookup_node_to_hir (CrateNum crate, NodeId id, HirId *ref)\n   return true;\n }\n \n+bool\n+Mappings::lookup_hir_to_node (CrateNum crate, HirId id, NodeId *ref)\n+{\n+  auto it = hirIdToNodeMappings.find (crate);\n+  if (it == hirIdToNodeMappings.end ())\n+    return false;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return false;\n+\n+  *ref = iy->second;\n+  return true;\n+}\n+\n void\n Mappings::insert_location (CrateNum crate, HirId id, Location locus)\n {"}, {"sha": "65f86616d56ac466f7af1c1ec82a80deb648e40b", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad0ea3e0ed288569d52556b9aa796beea73d8a3/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad0ea3e0ed288569d52556b9aa796beea73d8a3/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=5ad0ea3e0ed288569d52556b9aa796beea73d8a3", "patch": "@@ -177,7 +177,7 @@ class Mappings\n   void insert_hir_type (CrateNum crateNum, HirId id, HIR::Type *type);\n   HIR::Type *lookup_hir_type (CrateNum crateNum, HirId id);\n \n-  void insert_hir_stmt (CrateNum crateNum, HirId id, HIR::Stmt *type);\n+  void insert_hir_stmt (CrateNum crateNum, HirId id, HIR::Stmt *stmt);\n   HIR::Stmt *lookup_hir_stmt (CrateNum crateNum, HirId id);\n \n   void insert_hir_param (CrateNum crateNum, HirId id, HIR::FunctionParam *type);\n@@ -199,6 +199,7 @@ class Mappings\n \n   void insert_node_to_hir (CrateNum crate, NodeId id, HirId ref);\n   bool lookup_node_to_hir (CrateNum crate, NodeId id, HirId *ref);\n+  bool lookup_hir_to_node (CrateNum crate, HirId id, NodeId *ref);\n \n   void insert_location (CrateNum crate, HirId id, Location locus);\n   Location lookup_location (CrateNum crate, HirId id);\n@@ -376,8 +377,8 @@ class Mappings\n   // location info\n   std::map<CrateNum, std::map<NodeId, Location>> locations;\n \n-  // reverse mappings\n   std::map<CrateNum, std::map<NodeId, HirId>> nodeIdToHirMappings;\n+  std::map<CrateNum, std::map<HirId, NodeId>> hirIdToNodeMappings;\n \n   // all hirid nodes\n   std::map<CrateNum, std::set<HirId>> hirNodesWithinCrate;"}, {"sha": "ad552c73abec2a3dd87f38440418db9c7d51cc9b", "filename": "gcc/testsuite/rust/compile/privacy5.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad0ea3e0ed288569d52556b9aa796beea73d8a3/gcc%2Ftestsuite%2Frust%2Fcompile%2Fprivacy5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad0ea3e0ed288569d52556b9aa796beea73d8a3/gcc%2Ftestsuite%2Frust%2Fcompile%2Fprivacy5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fprivacy5.rs?ref=5ad0ea3e0ed288569d52556b9aa796beea73d8a3", "patch": "@@ -0,0 +1,18 @@\n+mod orange {\n+    mod green {\n+        struct Foo;\n+        pub(in orange) struct Bar;\n+        pub struct Baz;\n+    }\n+\n+    fn brown() {\n+        let _ = green::Foo; // { dg-error \"definition is private in this context\" }\n+        let _ = green::Bar;\n+        let _ = green::Baz;\n+\n+        let _: green::Foo; // { dg-error \"definition is private in this context\" }\n+\n+        fn any(a0: green::Foo, a1: green::Bar) {}\n+        // { dg-error \"definition is private in this context\" \"\" { target *-*-* } .-1 }\n+    }\n+}"}, {"sha": "487ed02420902028a10f66eb06323386f5d192fc", "filename": "gcc/testsuite/rust/compile/privacy6.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad0ea3e0ed288569d52556b9aa796beea73d8a3/gcc%2Ftestsuite%2Frust%2Fcompile%2Fprivacy6.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad0ea3e0ed288569d52556b9aa796beea73d8a3/gcc%2Ftestsuite%2Frust%2Fcompile%2Fprivacy6.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fprivacy6.rs?ref=5ad0ea3e0ed288569d52556b9aa796beea73d8a3", "patch": "@@ -0,0 +1,39 @@\n+// { dg-additional-options \"-w\" }\n+\n+struct Adt;\n+enum EAdt {\n+    V0,\n+    V1,\n+}\n+struct Registers {\n+    r0: i64,\n+    r1: i64,\n+    r2: i64,\n+    r3: i64,\n+}\n+trait Foo {}\n+\n+fn foo1(value: bool) {}\n+fn foo2(value: char) {}\n+fn foo3(value: i32) {}\n+fn foo4(value: u16) {}\n+fn foo5(value: f64) {}\n+fn foo6(value: usize) {}\n+fn foo7(value: isize) {}\n+fn foo8(value: Adt) {}\n+fn foo9(value: EAdt) {}\n+fn foo10(value: &str) {}\n+fn foo11(value: *const i8) {}\n+fn foo12<T>(value: T) {}\n+fn foo13(value: [i32; 5]) {}\n+fn foo14(value: [Adt]) {}\n+fn foo15(value: fn(i32) -> i32) {}\n+fn foo16(value: (i32, Adt)) {}\n+fn foo17(value: (i32, [f64; 5])) {}\n+fn foo18(value: Registers) {}\n+fn foo19(value: &dyn Foo) {}\n+fn foo20(value: &[Adt]) {}\n+// FIXME: Uncomment once #1257 is fixed\n+// fn foo21(value: fn(i32)) {}\n+// fn foo22(value: fn()) {}\n+fn foo23(value: fn() -> i32) {}"}]}