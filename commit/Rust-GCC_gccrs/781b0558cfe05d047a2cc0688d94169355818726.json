{"sha": "781b0558cfe05d047a2cc0688d94169355818726", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzgxYjA1NThjZmUwNWQwNDdhMmNjMDY4OGQ5NDE2OTM1NTgxODcyNg==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "1999-12-31T02:41:24Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "1999-12-31T02:41:24Z"}, "message": "parse.h (ABSTRACT_CHECK, [...]): Avoid the use of ANSI string concatenation.\n\n\t* parse.h (ABSTRACT_CHECK, JCONSTRUCTOR_CHECK,\n\tERROR_CANT_CONVERT_TO_BOOLEAN, ERROR_CANT_CONVERT_TO_NUMERIC,\n\tERROR_CAST_NEEDED_TO_INTEGRAL): Avoid the use of ANSI string\n\tconcatenation.\n\n\t* parse.y (synchronized, variable_redefinition_error,\n\tcheck_class_interface_creation, create_interface, create_class,\n\tmethod_header, finish_method_declaration,\n\tcheck_modifiers_consistency, method_declarator,\n\tcomplete_class_report_errors, check_abstract_method_definitions,\n\tjava_check_regular_methods, check_throws_clauses,\n\tjava_check_abstract_methods, read_import_dir,\n\tcheck_pkg_class_access, declare_local_variables, fix_constructors,\n\tcut_identifier_in_qualified, resolve_expression_name,\n\tresolve_qualified_expression_name, patch_method_invocation,\n\tjava_complete_lhs, patch_assignment, try_builtin_assignconv,\n\tpatch_binop, patch_array_ref, patch_newarray, build_labeled_block,\n\tpatch_exit_expr, patch_exit_expr, patch_switch_statement,\n\tpatch_try_statement, patch_synchronized_statement,\n\tpatch_throw_statement, check_thrown_exceptions,\n\tpatch_conditional_expr): Likewise.\n\nFrom-SVN: r31146", "tree": {"sha": "90c80da7f30dcc0da5fced26748d4dfe2b4d09b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90c80da7f30dcc0da5fced26748d4dfe2b4d09b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/781b0558cfe05d047a2cc0688d94169355818726", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/781b0558cfe05d047a2cc0688d94169355818726", "html_url": "https://github.com/Rust-GCC/gccrs/commit/781b0558cfe05d047a2cc0688d94169355818726", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/781b0558cfe05d047a2cc0688d94169355818726/comments", "author": null, "committer": null, "parents": [{"sha": "e920ebc9311d99636a40f1ff229ecd4167f46166", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e920ebc9311d99636a40f1ff229ecd4167f46166", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e920ebc9311d99636a40f1ff229ecd4167f46166"}], "stats": {"total": 1529, "additions": 756, "deletions": 773}, "files": [{"sha": "de49f427036a2e887c08589a66861f278f0fa6c5", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781b0558cfe05d047a2cc0688d94169355818726/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781b0558cfe05d047a2cc0688d94169355818726/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=781b0558cfe05d047a2cc0688d94169355818726", "patch": "@@ -1,3 +1,27 @@\n+1999-12-30  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* parse.h (ABSTRACT_CHECK, JCONSTRUCTOR_CHECK,\n+\tERROR_CANT_CONVERT_TO_BOOLEAN, ERROR_CANT_CONVERT_TO_NUMERIC,\n+\tERROR_CAST_NEEDED_TO_INTEGRAL): Avoid the use of ANSI string\n+\tconcatenation.\n+\n+\t* parse.y (synchronized, variable_redefinition_error,\n+\tcheck_class_interface_creation, create_interface, create_class,\n+\tmethod_header, finish_method_declaration,\n+\tcheck_modifiers_consistency, method_declarator,\n+\tcomplete_class_report_errors, check_abstract_method_definitions,\n+\tjava_check_regular_methods, check_throws_clauses,\n+\tjava_check_abstract_methods, read_import_dir,\n+\tcheck_pkg_class_access, declare_local_variables, fix_constructors,\n+\tcut_identifier_in_qualified, resolve_expression_name,\n+\tresolve_qualified_expression_name, patch_method_invocation,\n+\tjava_complete_lhs, patch_assignment, try_builtin_assignconv,\n+\tpatch_binop, patch_array_ref, patch_newarray, build_labeled_block,\n+\tpatch_exit_expr, patch_exit_expr, patch_switch_statement,\n+\tpatch_try_statement, patch_synchronized_statement,\n+\tpatch_throw_statement, check_thrown_exceptions,\n+\tpatch_conditional_expr): Likewise.\n+\n 1999-12-14  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* class.c (class_depth): Return -1 if the class doesn't load"}, {"sha": "b2b8235db58f496361cb998357a1b5d200c82e85", "filename": "gcc/java/parse.c", "status": "modified", "additions": 624, "deletions": 626, "changes": 1250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781b0558cfe05d047a2cc0688d94169355818726/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781b0558cfe05d047a2cc0688d94169355818726/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=781b0558cfe05d047a2cc0688d94169355818726"}, {"sha": "0221598baa124e7064898c1313851a9d2b869425", "filename": "gcc/java/parse.h", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781b0558cfe05d047a2cc0688d94169355818726/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781b0558cfe05d047a2cc0688d94169355818726/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=781b0558cfe05d047a2cc0688d94169355818726", "patch": "@@ -101,7 +101,7 @@ extern tree stabilize_reference PROTO ((tree));\n \n #define ABSTRACT_CHECK(FLAG, V, CL, S)\t\t\t\t\\\n   if ((FLAG) & (V))\t\t\t\t\t\t\\\n-    parse_error_context ((CL), S \" method can't be abstract\");\n+    parse_error_context ((CL), \"%s method can't be abstract\", (S));\n \n #define JCONSTRUCTOR_CHECK(FLAG, V, CL, S)\t\t\t\\\n   if ((FLAG) & (V))\t\t\t\t\t\t\\\n@@ -142,8 +142,7 @@ extern tree stabilize_reference PROTO ((tree));\n   {                                                                          \\\n     if (flag_redundant && (cl) && ((flags) & (modifier)))\t\t     \\\n       parse_warning_context (cl,                                             \\\n-\t\t\t     \"Discouraged redundant use of `%s' modifier \"   \\\n-\t\t\t     \"in declaration of \" format,                    \\\n+     \"Discouraged redundant use of `%s' modifier in declaration of \" format, \\\n \t\t\t     java_accstring_lookup (modifier), arg);         \\\n   }\n \n@@ -212,26 +211,26 @@ extern tree stabilize_reference PROTO ((tree));\n \n /* Standard error messages */\n #define ERROR_CANT_CONVERT_TO_BOOLEAN(OPERATOR, NODE, TYPE)\t\t\\\n-  parse_error_context\t\t\t\t\t\t\t\\\n-    ((OPERATOR), \"Incompatible type for `%s'. Can't convert `%s' to \"\t\\\n-     \"boolean\", operator_string ((NODE)), lang_printable_name ((TYPE),0))\n+  parse_error_context ((OPERATOR),\t\t\t\t\t\\\n+    \"Incompatible type for `%s'. Can't convert `%s' to boolean\",\t\\\n+    operator_string ((NODE)), lang_printable_name ((TYPE),0))\n \n #define ERROR_CANT_CONVERT_TO_NUMERIC(OPERATOR, NODE, TYPE)\t\t\\\n-  parse_error_context\t\t\t\t\t\t\t\\\n-    ((OPERATOR), \"Incompatible type for `%s'. Can't convert `%s' to \"\t\\\n-     \"numeric type\", operator_string ((NODE)), lang_printable_name ((TYPE), 0))\n+  parse_error_context ((OPERATOR),\t\t\t\t\t\\\n+      \"Incompatible type for `%s'. Can't convert `%s' to numeric type\",\t\\\n+      operator_string ((NODE)), lang_printable_name ((TYPE), 0))\n \n #define ERROR_CAST_NEEDED_TO_INTEGRAL(OPERATOR, NODE, TYPE)\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   tree _operator = (OPERATOR), _node = (NODE), _type = (TYPE);\t\t\\\n   if (JPRIMITIVE_TYPE_P (_type))\t\t\t\t\t\\\n-    parse_error_context (_operator, \"Incompatible type for `%s'. Explicit\" \\\n-                         \" cast needed to convert `%s' to integral\",\t\\\n+    parse_error_context (_operator,\t\t\t\t\t\\\n+\"Incompatible type for `%s'. Explicit cast needed to convert `%s' to integral\",\\\n \t\t\t operator_string(_node),\t\t\t\\\n \t\t\t lang_printable_name (_type, 0));\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n-    parse_error_context (_operator, \"Incompatible type for `%s'. Can't\" \\\n-                         \" convert `%s' to integral\",\t\t\t\\\n+    parse_error_context (_operator,\t\t\t\t\t\\\n+      \"Incompatible type for `%s'. Can't convert `%s' to integral\",\t\\\n \t\t\t operator_string(_node),\t\t\t\\\n \t\t\t lang_printable_name (_type, 0));\t\t\\\n } while (0)"}, {"sha": "9e4b4c0a8af0bcd46930227a51a63ced5f439437", "filename": "gcc/java/parse.y", "status": "modified", "additions": 96, "deletions": 134, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781b0558cfe05d047a2cc0688d94169355818726/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781b0558cfe05d047a2cc0688d94169355818726/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=781b0558cfe05d047a2cc0688d94169355818726", "patch": "@@ -1675,8 +1675,8 @@ synchronized_statement:\n synchronized:\n \tmodifiers\n \t\t{\n-\t\t  check_modifiers (\"Illegal modifier `%s'. Only \"\n-\t\t\t\t   \"`synchronized' was expected here\",\n+\t\t  check_modifiers (\n+             \"Illegal modifier `%s'. Only `synchronized' was expected here\",\n \t\t\t\t   $1, ACC_SYNCHRONIZED);\n \t\t  if ($1 != ACC_SYNCHRONIZED)\n \t\t    MODIFIER_WFL (SYNCHRONIZED_TK) = \n@@ -2746,8 +2746,7 @@ variable_redefinition_error (context, name, type, line)\n     type_name = lang_printable_name (type, 0);\n \n   parse_error_context (context,\n-\t\t       \"Variable `%s' is already defined in this method and \"\n-\t\t       \"was declared `%s %s' at line %d\", \n+\t\t       \"Variable `%s' is already defined in this method and was declared `%s %s' at line %d\", \n \t\t       IDENTIFIER_POINTER (name),\n \t\t       type_name, IDENTIFIER_POINTER (name), line);\n }\n@@ -2908,8 +2907,8 @@ check_class_interface_creation (is_interface, flags, raw_name, qualified_name, d\n       if (strncmp (IDENTIFIER_POINTER (raw_name), \n \t\t   f , IDENTIFIER_LENGTH (raw_name)) ||\n \t  f [IDENTIFIER_LENGTH (raw_name)] != '.')\n-\tparse_error_context (cl, \"Public %s `%s' must be defined in a file \"\n-\t\t\t     \"called `%s.java'\", \n+\tparse_error_context\n+\t  (cl, \"Public %s `%s' must be defined in a file called `%s.java'\", \n \t\t\t     (is_interface ? \"interface\" : \"class\"),\n \t\t\t     IDENTIFIER_POINTER (qualified_name),\n \t\t\t     IDENTIFIER_POINTER (raw_name));\n@@ -3013,8 +3012,7 @@ create_interface (flags, id, super)\n   if ((flags & ACC_ABSTRACT) && flag_redundant)\n     parse_warning_context \n       (MODIFIER_WFL (ABSTRACT_TK),\n-       \"Redundant use of `abstract' modifier. Interface `%s' is implicitely \"\n-       \"abstract\", IDENTIFIER_POINTER (raw_name));\n+       \"Redundant use of `abstract' modifier. Interface `%s' is implicitely abstract\", IDENTIFIER_POINTER (raw_name));\n \n   /* Create a new decl if DECL is NULL, otherwise fix it */\n   decl = maybe_create_class_interface_decl (decl, q_name, id);\n@@ -3055,8 +3053,9 @@ create_class (flags, id, super, interfaces)\n        - abstract AND final forbidden \n        - Public classes defined in the correct file */\n   if ((flags & ACC_ABSTRACT) && (flags & ACC_FINAL))\n-    parse_error_context (id, \"Class `%s' can't be declared both abstract \"\n-\t\t\t \"and final\", IDENTIFIER_POINTER (raw_name));\n+    parse_error_context\n+      (id, \"Class `%s' can't be declared both abstract and final\",\n+       IDENTIFIER_POINTER (raw_name));\n \n   /* Create a new decl if DECL is NULL, otherwise fix it */\n   decl = maybe_create_class_interface_decl (decl, class_id, id);\n@@ -3388,8 +3387,7 @@ method_header (flags, type, mdecl, throws)\n       if (!CLASS_ABSTRACT (TYPE_NAME (this_class))\n \t  && !CLASS_INTERFACE (TYPE_NAME (this_class)))\n \tparse_error_context \n-\t  (id, \"Class `%s' must be declared abstract to define abstract \"\n-\t   \"method `%s'\", \n+\t  (id, \"Class `%s' must be declared abstract to define abstract method `%s'\", \n \t   IDENTIFIER_POINTER (DECL_NAME (ctxp->current_parsed_class)),\n \t   IDENTIFIER_POINTER (EXPR_WFL_NODE (id)));\n     }\n@@ -3591,10 +3589,10 @@ finish_method_declaration (method_body)\n   else if (!(flags & ACC_ABSTRACT) && !(flags & ACC_NATIVE) && !method_body)\n     {\n       tree wfl = DECL_NAME (current_function_decl);\n-      parse_error_context (wfl, \n-\t\t\t   \"Non native and non abstract method `%s' must \"\n-\t\t\t   \"have a body defined\",\n-\t\t\t   IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl)));\n+      parse_error_context\n+\t(wfl, \n+\t \"Non native and non abstract method `%s' must have a body defined\",\n+\t IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl)));\n       method_body = NULL_TREE;\n     }\n \n@@ -3690,8 +3688,7 @@ check_modifiers_consistency (flags)\n   THIS_MODIFIER_ONLY (flags, ACC_PROTECTED, 2, acc_count, cl);\n   if (acc_count > 1)\n     parse_error_context\n-      (cl, \"Inconsistent member declaration. At most one of `public', \"\n-       \"`private', or `protected' may be specified\");\n+      (cl, \"Inconsistent member declaration. At most one of `public', `private', or `protected' may be specified\");\n }\n \n /* Check the methode header METH for abstract specifics features */\n@@ -3759,9 +3756,9 @@ method_declarator (id, list)\n       for (already = arg_types; already; already = TREE_CHAIN (already))\n \tif (TREE_PURPOSE (already) == name)\n \t  {\n-\t    parse_error_context \n-\t      (wfl_name, \"Variable `%s' is used more than once in the \"\n-\t       \"argument list of method `%s'\", IDENTIFIER_POINTER (name),\n+\t    parse_error_context\n+\t      (wfl_name, \"Variable `%s' is used more than once in the argument list of method `%s'\",\n+\t       IDENTIFIER_POINTER (name),\n \t       IDENTIFIER_POINTER (EXPR_WFL_NODE (id)));\n \t    break;\n \t  }\n@@ -4494,16 +4491,14 @@ complete_class_report_errors (dep)\n       break;\n     case JDEP_METHOD:\t\t/* Covers arguments */\n       parse_error_context\n-\t(JDEP_WFL (dep), \"Type `%s' not found in the declaration of the \"\n-\t \"argument `%s' of method `%s'\",\n+\t(JDEP_WFL (dep), \"Type `%s' not found in the declaration of the argument `%s' of method `%s'\",\n \t purify_type_name (name),\n \t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_DECL_WFL (dep))),\n \t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_MISC (dep))));\n       break;\n     case JDEP_METHOD_RETURN:\t/* Covers return type */\n       parse_error_context\n-\t(JDEP_WFL (dep), \"Type `%s' not found in the declaration of the \"\n-\t \"return type of method `%s'\", \n+\t(JDEP_WFL (dep), \"Type `%s' not found in the declaration of the return type of method `%s'\", \n \t purify_type_name (name),\n \t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_DECL_WFL (dep))));\n       break;\n@@ -4516,8 +4511,7 @@ complete_class_report_errors (dep)\n       break;\n     case JDEP_VARIABLE:\n       parse_error_context\n-\t(JDEP_WFL (dep), \"Type `%s' not found in the declaration of the \"\n-\t \"local variable `%s'\", \n+\t(JDEP_WFL (dep), \"Type `%s' not found in the declaration of the local variable `%s'\", \n \t purify_type_name (IDENTIFIER_POINTER \n \t\t\t   (EXPR_WFL_NODE (JDEP_WFL (dep)))),\n \t IDENTIFIER_POINTER (DECL_NAME (JDEP_DECL (dep))));\n@@ -4711,9 +4705,7 @@ check_abstract_method_definitions (do_interface, class_decl, type)\n \t  \n \t  parse_error_context \n \t    (lookup_cl (class_decl),\n-\t     \"Class `%s' doesn't define the abstract method `%s %s' from \"\n-\t     \"%s `%s'. This method must be defined or %s `%s' must be \"\n-\t     \"declared abstract\",\n+\t     \"Class `%s' doesn't define the abstract method `%s %s' from %s `%s'. This method must be defined or %s `%s' must be declared abstract\",\n \t     IDENTIFIER_POINTER (DECL_NAME (class_decl)),\n \t     t, lang_printable_name (method, 0), \n \t     (CLASS_INTERFACE (TYPE_NAME (DECL_CONTEXT (method))) ? \n@@ -4821,8 +4813,7 @@ java_check_regular_methods (class_decl)\n \t{\n \t  if (!inherits_from_p (TREE_VALUE (mthrows), throwable_type_node))\n \t    parse_error_context \n-\t      (TREE_PURPOSE (mthrows), \"Class `%s' in `throws' clause must be \"\n-\t       \"a subclass of class `java.lang.Throwable'\",\n+\t      (TREE_PURPOSE (mthrows), \"Class `%s' in `throws' clause must be a subclass of class `java.lang.Throwable'\",\n \t       IDENTIFIER_POINTER \n \t         (DECL_NAME (TYPE_NAME (TREE_VALUE (mthrows)))));\n \t}\n@@ -4871,9 +4862,7 @@ java_check_regular_methods (class_decl)\n \t  && flag_not_overriding)\n         {\n \t  parse_warning_context \n-\t    (method_wfl, \"Method `%s' in class `%s' does not \"\n-\t     \"override the corresponding method in class `%s', which is \"\n-\t     \"private to a different package\",\n+\t    (method_wfl, \"Method `%s' in class `%s' does not override the corresponding method in class `%s', which is private to a different package\",\n \t     lang_printable_name (found, 0),\n \t     IDENTIFIER_POINTER (DECL_NAME (class_decl)),\n \t     IDENTIFIER_POINTER (DECL_NAME \n@@ -4903,8 +4892,7 @@ java_check_regular_methods (class_decl)\n \t{\n \t  parse_error_context \n \t    (method_wfl,\n-\t     \"Instance methods can't be overriden by a static method. Method \"\n-\t     \"`%s' is an instance method in class `%s'\",\n+\t     \"Instance methods can't be overriden by a static method. Method `%s' is an instance method in class `%s'\",\n \t     lang_printable_name (found, 0),\n \t     IDENTIFIER_POINTER\n \t       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n@@ -4924,8 +4912,7 @@ java_check_regular_methods (class_decl)\n \t{\n \t  parse_error_context \n \t    (method_wfl,\n-\t     \"Methods can't be overridden to be more private. Method `%s' is \"\n-\t     \"not %s in class `%s'\", lang_printable_name (method, 0),\n+\t     \"Methods can't be overridden to be more private. Method `%s' is not %s in class `%s'\", lang_printable_name (method, 0),\n \t     (METHOD_PUBLIC (method) ? \"public\" : \n \t      (METHOD_PRIVATE (method) ? \"private\" : \"protected\")),\n \t     IDENTIFIER_POINTER (DECL_NAME \n@@ -4985,9 +4972,7 @@ check_throws_clauses (method, method_wfl, found)\n       if (!fthrows)\n \t{\n \t  parse_error_context \n-\t    (method_wfl, \"Invalid checked exception class `%s' in \"\n-\t     \"`throws' clause. The exception must be a subclass of an \"\n-\t     \"exception thrown by `%s' from class `%s'\",\n+\t    (method_wfl, \"Invalid checked exception class `%s' in `throws' clause. The exception must be a subclass of an exception thrown by `%s' from class `%s'\",\n \t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (TREE_VALUE (mthrows)))),\n \t     lang_printable_name (found, 0),\n \t     IDENTIFIER_POINTER \n@@ -5059,9 +5044,7 @@ java_check_abstract_methods (interface_decl)\n \t      reset_method_name (found);\n \t      parse_error_context \n \t\t(lookup_cl (sub_interface_method),\n-\t\t \"Interface `%s' inherits method `%s' from interface `%s'. \"\n-\t\t \"This method is redefined with a different return type in \"\n-\t\t \"interface `%s'\",\n+\t\t \"Interface `%s' inherits method `%s' from interface `%s'. This method is redefined with a different return type in interface `%s'\",\n \t\t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (interface))),\n \t\t lang_printable_name (found, 0),\n \t\t IDENTIFIER_POINTER \n@@ -5365,9 +5348,7 @@ read_import_dir (wfl)\n       static int first = 1;\n       if (first)\n \t{\n-\t  error (\"Can't find default package `%s'. Check \"\n-\t\t \"the CLASSPATH environment variable and the access to the \"\n-\t\t \"archives.\", package_name);\n+\t  error (\"Can't find default package `%s'. Check the CLASSPATH environment variable and the access to the archives.\", package_name);\n \t  java_error_count++;\n \t  first = 0;\n \t}\n@@ -5570,8 +5551,7 @@ check_pkg_class_access (class_name, cl)\n \treturn 0;\n \n       parse_error_context \n-\t(cl, \"Can't access %s `%s'. Only public classes and interfaces in \"\n-\t \"other packages can be accessed\",\n+\t(cl, \"Can't access %s `%s'. Only public classes and interfaces in other packages can be accessed\",\n \t (CLASS_INTERFACE (TYPE_NAME (type)) ? \"interface\" : \"class\"),\n \t IDENTIFIER_POINTER (class_name));\n       return 1;\n@@ -5608,8 +5588,7 @@ declare_local_variables (modifier, type, vlist)\n \t{\n \t  if (flag_static_local_jdk1_1)\n \t    parse_warning_context (ctxp->modifier_ctx [i], \n-\t\t\t\t   \"Unsupported JDK1.1 `final' local variable \"\n-\t\t\t\t   \"(treated as non final)\");\n+\t      \"Unsupported JDK1.1 `final' local variable (treated as non final)\");\n \t}\n       else \n \t{\n@@ -6222,9 +6201,9 @@ fix_constructors (mdecl)\n \t{\n \t  tree sclass_decl = TYPE_NAME (CLASSTYPE_SUPER (current_class));\n \t  const char *n = IDENTIFIER_POINTER (DECL_NAME (sclass_decl));\n-\t  parse_error_context (lookup_cl (TYPE_NAME (current_class)), \n-\t\t\t       \"No constructor matching `%s()' found in \"\n-\t\t\t       \"class `%s'\", n, n);\n+\t  parse_error_context\n+\t    (lookup_cl (TYPE_NAME (current_class)), \n+\t     \"No constructor matching `%s()' found in class `%s'\", n, n);\n \t}\n       \n       start_artificial_method_body (mdecl);\n@@ -6445,8 +6424,7 @@ cut_identifier_in_qualified (wfl)\n     if (!TREE_CHAIN (q))\n       {\n \tif (!previous)\n-\t  fatal (\"Operating on a non qualified qualified WFL - \"\n-\t\t \"cut_identifier_in_qualified\");\n+\t  fatal (\"Operating on a non qualified qualified WFL - cut_identifier_in_qualified\");\n \tTREE_CHAIN (previous) = NULL_TREE;\n \treturn TREE_PURPOSE (q);\n       }\n@@ -6490,8 +6468,7 @@ resolve_expression_name (id, orig)\n \t      if (!fs && ctxp->explicit_constructor_p)\n \t\t{\n \t\t  parse_error_context\n-\t\t    (id, \"Can't reference `%s' before the superclass \"\n-\t\t     \"constructor has been called\", IDENTIFIER_POINTER (name));\n+\t\t    (id, \"Can't reference `%s' before the superclass constructor has been called\", IDENTIFIER_POINTER (name));\n \t\t  return error_mark_node;\n \t\t}\n \n@@ -6781,8 +6758,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t    }\n \t  if (ctxp->explicit_constructor_p)\n \t    {\n-\t      parse_error_context (wfl, \"Can't reference `this' before the \"\n-\t\t\t\t   \"superclass constructor has been called\");\n+\t      parse_error_context (wfl, \"Can't reference `this' before the superclass constructor has been called\");\n \t      return 1;\n \t    }\n \t  /* We have to generate code for intermediate acess */\n@@ -7198,9 +7174,10 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n \t    {\n \t      tree remainder;\n \t      breakdown_qualified (&remainder, NULL, EXPR_WFL_NODE (wfl));\n-\t      parse_error_context (wfl, \"Can't search method `%s' in package \"\n-\t\t\t\t   \"`%s'\",IDENTIFIER_POINTER (identifier),\n-\t\t\t\t   IDENTIFIER_POINTER (remainder));\n+\t      parse_error_context\n+\t\t(wfl, \"Can't search method `%s' in package `%s'\",\n+\t\t IDENTIFIER_POINTER (identifier),\n+\t\t IDENTIFIER_POINTER (remainder));\n \t      PATCH_METHOD_RETURN_ERROR ();\n \t    }\n \t  RESOLVE_PACKAGE_NAME_P (wfl) = 0;\n@@ -7228,8 +7205,9 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n \t  if (CLASS_INTERFACE (decl))\n \t    {\n \t      parse_error_context\n-\t\t(identifier_wfl, \"Can't make static reference to method \"\n-\t\t \"`%s' in interface `%s'\", IDENTIFIER_POINTER (identifier), \n+\t\t(identifier_wfl,\n+\t\t\"Can't make static reference to method `%s' in interface `%s'\",\n+\t\t IDENTIFIER_POINTER (identifier), \n \t\t IDENTIFIER_POINTER (name));\n \t      PATCH_METHOD_RETURN_ERROR ();\n \t    }\n@@ -7307,8 +7285,7 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n \t\t  DECL_NAME (TYPE_NAME (CLASSTYPE_SUPER (current_class)));\n \t      else\n \t\t{\n-\t\t  parse_error_context (wfl, \"Can't invoke super constructor \"\n-\t\t\t\t       \"on java.lang.Object\");\n+\t\t  parse_error_context (wfl, \"Can't invoke super constructor on java.lang.Object\");\n \t\t  PATCH_METHOD_RETURN_ERROR ();\n \t\t}\n \t    }\n@@ -7333,8 +7310,8 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n \t\t  && TREE_CODE (patch) == NEW_CLASS_EXPR)\n \t\t{\n \t\t  parse_error_context \n-\t\t    (wfl, \"Class `%s' is an abstract class. It can't be \"\n-\t\t     \"instantiated\", IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl)));\n+\t\t    (wfl, \"Class `%s' is an abstract class. It can't be instantiated\",\n+\t\t     IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl)));\n \t\t  PATCH_METHOD_RETURN_ERROR ();\n \t\t}\n \t      class_to_search = TREE_TYPE (class_to_search);\n@@ -7410,9 +7387,7 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n       && (!primary || primary == current_this)\n       && (TREE_CODE (patch) != NEW_CLASS_EXPR))\n     {\n-      parse_error_context \n-\t(wfl, \"Can't reference `this' before the superclass constructor has \"\n-\t \"been called\");\n+      parse_error_context (wfl, \"Can't reference `this' before the superclass constructor has been called\");\n       PATCH_METHOD_RETURN_ERROR ();\n     }\n   java_parser_context_restore_global ();\n@@ -8755,17 +8730,16 @@ java_complete_lhs (node)\n       if (!current_this)\n \t{\n \t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n-\t  parse_error_context (wfl_operator, \"Keyword `this' used outside \"\n-\t\t\t       \"allowed context\");\n+\t  parse_error_context (wfl_operator,\n+\t\t\t       \"Keyword `this' used outside allowed context\");\n \t  TREE_TYPE (node) = error_mark_node;\n \t  return error_mark_node;\n \t}\n       if (ctxp->explicit_constructor_p)\n \t{\n \t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n \t  parse_error_context \n-\t    (wfl_operator, \"Can't reference `this' or `super' before the \"\n-\t     \"superclass constructor has been called\");\n+\t    (wfl_operator, \"Can't reference `this' or `super' before the superclass constructor has been called\");\n \t  TREE_TYPE (node) = error_mark_node;\n \t  return error_mark_node;\n \t}\n@@ -9208,12 +9182,11 @@ patch_assignment (node, wfl_op1, wfl_op2)\n \t}\n \n       if (!valid_cast_to_p (rhs_type, lhs_type))\n-\tparse_error_context (wfl, \"Incompatible type for %s. \"\n-\t\t\t     \"Can't convert `%s' to `%s'\",\n-\t\t\t     operation, t1, t2);\n+\tparse_error_context\n+\t  (wfl, \"Incompatible type for %s. Can't convert `%s' to `%s'\",\n+\t   operation, t1, t2);\n       else\n-\tparse_error_context (wfl, \"Incompatible type for %s. \"\n-\t\t\t     \"Explicit cast needed to convert `%s' to `%s'\",\n+\tparse_error_context (wfl, \"Incompatible type for %s. Explicit cast needed to convert `%s' to `%s'\",\n \t\t\t     operation, t1, t2);\n       free (t1); free (t2);\n       error_found = 1;\n@@ -9350,8 +9323,7 @@ try_builtin_assignconv (wfl_op1, lhs_type, rhs)\n         new_rhs = convert (lhs_type, rhs);\n       else if (wfl_op1)\t\t/* Might be called with a NULL */\n \tparse_warning_context \n-\t  (wfl_op1, \"Constant expression `%s' to wide for narrowing \"\n-\t   \"primitive conversion to `%s'\", \n+\t  (wfl_op1, \"Constant expression `%s' to wide for narrowing primitive conversion to `%s'\", \n \t   print_int_node (rhs), lang_printable_name (lhs_type, 0));\n       /* Reported a warning that will turn into an error further\n \t down, so we don't return */\n@@ -9820,15 +9792,12 @@ patch_binop (node, wfl_op1, wfl_op2)\n \t    {\n \t      if (JPRIMITIVE_TYPE_P (op2_type))\n \t\tparse_error_context (wfl_operator,\n-\t\t\t\t     \"Incompatible type for `%s'. \"\n-\t\t\t\t     \"Explicit cast needed to convert \"\n-\t\t\t\t     \"shift distance from `%s' to integral\",\n+\t\t\t\t     \"Incompatible type for `%s'. Explicit cast needed to convert shift distance from `%s' to integral\",\n \t\t\t\t     operator_string (node),\n \t\t\t\t     lang_printable_name (op2_type, 0));\n \t      else\n-\t\tparse_error_context (wfl_operator, \"Incompatible type for `%s'.\"\n-\t\t\t\t     \" Can't convert shift distance from \"\n-\t\t\t\t     \"`%s' to integral\", \n+\t\tparse_error_context (wfl_operator,\n+\t\t\t\t     \"Incompatible type for `%s'. Can't convert shift distance from `%s' to integral\", \n \t\t\t\t     operator_string (node),\n \t\t\t\t     lang_printable_name (op2_type, 0));\n \t    }\n@@ -10036,8 +10005,9 @@ patch_binop (node, wfl_op1, wfl_op2)\n \t  char *t1;\n \t  t1 = xstrdup (lang_printable_name (op1_type, 0));\n \t  parse_error_context \n-\t    (wfl_operator, \"Incompatible type for `%s'. Can't convert `%s' \"\n-\t     \"to `%s'\", operator_string (node), t1, \n+\t    (wfl_operator,\n+\t     \"Incompatible type for `%s'. Can't convert `%s' to `%s'\",\n+\t     operator_string (node), t1, \n \t     lang_printable_name (op2_type, 0));\n \t  free (t1);\n \t  TREE_TYPE (node) = boolean_type_node;\n@@ -10681,8 +10651,9 @@ patch_array_ref (node)\n   if (!TYPE_ARRAY_P (array_type))\n     {\n       parse_error_context \n-\t(wfl_operator, \"`[]' can only be applied to arrays. It can't be \"\n-\t \"applied to `%s'\", lang_printable_name (array_type, 0));\n+\t(wfl_operator,\n+\t \"`[]' can only be applied to arrays. It can't be applied to `%s'\",\n+\t lang_printable_name (array_type, 0));\n       TREE_TYPE (node) = error_mark_node;\n       error_found = 1;\n     }\n@@ -10693,12 +10664,12 @@ patch_array_ref (node)\n   if (TREE_TYPE (index) != int_type_node)\n     {\n       if (valid_cast_to_p (index_type, int_type_node))\n-\tparse_error_context (wfl_operator, \"Incompatible type for `[]'. \"\n-\t\t\t     \"Explicit cast needed to convert `%s' to `int'\",\n+\tparse_error_context (wfl_operator,\n+   \"Incompatible type for `[]'. Explicit cast needed to convert `%s' to `int'\",\n \t\t\t     lang_printable_name (index_type, 0));\n       else\n-\tparse_error_context (wfl_operator, \"Incompatible type for `[]'. \"\n-\t\t\t     \"Can't convert `%s' to `int'\",\n+\tparse_error_context (wfl_operator,\n+          \"Incompatible type for `[]'. Can't convert `%s' to `int'\",\n \t\t\t     lang_printable_name (index_type, 0));\n       TREE_TYPE (node) = error_mark_node;\n       error_found = 1;\n@@ -10782,8 +10753,7 @@ patch_newarray (node)\n \t{\n \t  parse_error_context \n \t    (TREE_PURPOSE (cdim), \n-\t     \"Incompatible type for dimension in array creation expression. \"\n-\t     \"%s convert `%s' to `int'\", \n+\t     \"Incompatible type for dimension in array creation expression. %s convert `%s' to `int'\", \n \t     (valid_cast_to_p (TREE_TYPE (dim), int_type_node) ?\n \t      \"Explicit cast needed to\" : \"Can't\"),\n \t     lang_printable_name (TREE_TYPE (dim), 0));\n@@ -11174,13 +11144,13 @@ build_labeled_block (location, label)\n       if (IDENTIFIER_LOCAL_VALUE (label_name))\n \t{\n \t  EXPR_WFL_LINECOL (wfl_operator) = location;\n-\t  parse_error_context (wfl_operator, \"Declaration of `%s' shadows \"\n-\t\t\t       \"a previous label declaration\",\n+\t  parse_error_context (wfl_operator,\n+            \"Declaration of `%s' shadows a previous label declaration\",\n \t\t\t       IDENTIFIER_POINTER (label));\n \t  EXPR_WFL_LINECOL (wfl_operator) = \n \t    EXPR_WFL_LINECOL (IDENTIFIER_LOCAL_VALUE (label_name));\n-\t  parse_error_context (wfl_operator, \"This is the location of the \"\n-\t\t\t       \"previous declaration of label `%s'\",\n+\t  parse_error_context (wfl_operator,\n+            \"This is the location of the previous declaration of label `%s'\",\n \t\t\t       IDENTIFIER_POINTER (label));\n \t  java_error_count--;\n \t}\n@@ -11501,8 +11471,7 @@ patch_exit_expr (node)\n     {\n       parse_error_context \n \t(wfl_operator, \n-\t \"Incompatible type for loop conditional. Can't convert `%s' to \"\n-\t \"`boolean'\", \n+    \"Incompatible type for loop conditional. Can't convert `%s' to `boolean'\", \n \t lang_printable_name (TREE_TYPE (expression), 0));\n       return error_mark_node;\n     }\n@@ -11539,8 +11508,8 @@ patch_switch_statement (node)\n   if (!JINTEGRAL_TYPE_P (se_type))\n     {\n       EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n-      parse_error_context (wfl_operator, \"Incompatible type for `switch'. \"\n-\t\t\t   \"Can't convert `%s' to `int'\",\n+      parse_error_context (wfl_operator,\n+\t  \"Incompatible type for `switch'. Can't convert `%s' to `int'\",\n \t\t\t   lang_printable_name (se_type, 0));\n       /* This is what java_complete_tree will check */\n       TREE_OPERAND (node, 0) = error_mark_node;\n@@ -11628,9 +11597,7 @@ patch_try_statement (node)\n \t{\n \t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (current);\n \t  parse_error_context (wfl_operator,\n-\t\t\t       \"Can't catch class `%s'. Catch clause \"\n-\t\t\t       \"parameter type must be a subclass of \"\n-\t\t\t       \"class `java.lang.Throwable'\",\n+\t\t\t       \"Can't catch class `%s'. Catch clause parameter type must be a subclass of class `java.lang.Throwable'\",\n \t\t\t       lang_printable_name (carg_type, 0));\n \t  error_found = 1;\n \t  continue;\n@@ -11653,8 +11620,9 @@ patch_try_statement (node)\n \t    {\n \t      EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (current);\n \t      parse_error_context \n-\t\t(wfl_operator, \"`catch' not reached because of the catch \"\n-\t\t \"clause at line %d\", EXPR_WFL_LINENO (sub_current));\n+\t\t(wfl_operator,\n+\t\t \"`catch' not reached because of the catch clause at line %d\",\n+\t\t EXPR_WFL_LINENO (sub_current));\n \t      unreachable = error_found = 1;\n \t      break;\n \t    }\n@@ -11717,8 +11685,7 @@ patch_synchronized_statement (node, wfl_op1)\n   if (!JREFERENCE_TYPE_P (TREE_TYPE (expr)))\n     {\n       SET_WFL_OPERATOR (wfl_operator, node, wfl_op1);\n-      parse_error_context (wfl_operator, \"Incompatible type for `synchronized'\"\n-\t\t\t   \". Can't convert `%s' to `java.lang.Object'\",\n+      parse_error_context (wfl_operator, \"Incompatible type for `synchronized'. Can't convert `%s' to `java.lang.Object'\",\n \t\t\t   lang_printable_name (TREE_TYPE (expr), 0));\n       return error_mark_node;\n     }\n@@ -11781,8 +11748,8 @@ patch_throw_statement (node, wfl_op1)\n   if (!try_reference_assignconv (throwable_type_node, expr))\n     {\n       SET_WFL_OPERATOR (wfl_operator, node, wfl_op1);\n-      parse_error_context (wfl_operator, \"Can't throw `%s'; it must be a \"\n-\t\t\t   \"subclass of class `java.lang.Throwable'\",\n+      parse_error_context (wfl_operator,\n+    \"Can't throw `%s'; it must be a subclass of class `java.lang.Throwable'\",\n \t\t\t   lang_printable_name (type, 0));\n       /* If the thrown expression was a reference, we further the\n          compile-time check. */\n@@ -11812,9 +11779,7 @@ patch_throw_statement (node, wfl_op1)\n \t only if there is something after the list of checked\n \t exception thrown by the current function (if any). */\n       if (IN_TRY_BLOCK_P ())\n-\tparse_error_context (wfl_operator, \"Checked exception `%s' can't be \"\n-\t\t\t     \"caught by any of the catch clause(s) \"\n-\t\t\t     \"of the surrounding `try' block\",\n+\tparse_error_context (wfl_operator, \"Checked exception `%s' can't be caught by any of the catch clause(s) of the surrounding `try' block\",\n \t\t\t     lang_printable_name (type, 0));\n       /* If we have no surrounding try statement and the method doesn't have\n \t any throws, report it now. FIXME */\n@@ -11826,20 +11791,18 @@ patch_throw_statement (node, wfl_op1)\n \t       && !tryblock_throws_ok)\n \t{\n \t  if (IS_CLINIT (current_function_decl))\n-\t    parse_error_context (wfl_operator, \"Checked exception `%s' can't \"\n-\t\t\t\t \"be thrown in initializer\",\n+\t    parse_error_context (wfl_operator,\n+                   \"Checked exception `%s' can't be thrown in initializer\",\n \t\t\t\t lang_printable_name (type, 0));\n \t  else\n-\t    parse_error_context (wfl_operator, \"Checked exception `%s' isn't \"\n-\t\t\t\t \"thrown from a `try' block\", \n+\t    parse_error_context (wfl_operator,\n+                   \"Checked exception `%s' isn't thrown from a `try' block\", \n \t\t\t\t lang_printable_name (type, 0));\n \t}\n       /* Otherwise, the current method doesn't have the appropriate\n          throws declaration */\n       else\n-\tparse_error_context (wfl_operator, \"Checked exception `%s' doesn't \"\n-\t\t\t     \"match any of current method's `throws' \"\n-\t\t\t     \"declaration(s)\", \n+\tparse_error_context (wfl_operator, \"Checked exception `%s' doesn't match any of current method's `throws' declaration(s)\", \n \t\t\t     lang_printable_name (type, 0));\n       return error_mark_node;\n     }\n@@ -11880,8 +11843,7 @@ check_thrown_exceptions (location, decl)\n \telse \n \t  {\n \t    parse_error_context \n-\t      (wfl_operator, \"Exception `%s' must be caught, or it must be \"\n-\t       \"declared in the `throws' clause of `%s'\", \n+\t      (wfl_operator, \"Exception `%s' must be caught, or it must be declared in the `throws' clause of `%s'\", \n \t       lang_printable_name (TREE_VALUE (throws), 0),\n \t       (DECL_NAME (current_function_decl) == init_identifier_node ?\n \t\tIDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))) :\n@@ -11963,8 +11925,8 @@ patch_conditional_expr (node, wfl_cond, wfl_op1)\n   if (TREE_TYPE (cond) != boolean_type_node)\n     {\n       SET_WFL_OPERATOR (wfl_operator, node, wfl_cond);\n-      parse_error_context (wfl_operator, \"Incompatible type for `?:'. Can't \"\n-\t\t\t   \"convert `%s' to `boolean'\",\n+      parse_error_context (wfl_operator,\n+               \"Incompatible type for `?:'. Can't convert `%s' to `boolean'\",\n \t\t\t   lang_printable_name (TREE_TYPE (cond), 0));\n       error_found = 1;\n     }\n@@ -12031,9 +11993,9 @@ patch_conditional_expr (node, wfl_cond, wfl_op1)\n     {\n       char *t = xstrdup (lang_printable_name (t1, 0));\n       SET_WFL_OPERATOR (wfl_operator, node, wfl_op1);\n-      parse_error_context (wfl_operator, \"Incompatible type for `?:'. Can't \"\n-\t\t\t   \"convert `%s' to `%s'\", t,\n-\t\t\t   lang_printable_name (t2, 0));\n+      parse_error_context (wfl_operator,\n+\t\t \"Incompatible type for `?:'. Can't convert `%s' to `%s'\",\n+\t\t\t   t, lang_printable_name (t2, 0));\n       free (t);\n       error_found = 1;\n     }"}]}