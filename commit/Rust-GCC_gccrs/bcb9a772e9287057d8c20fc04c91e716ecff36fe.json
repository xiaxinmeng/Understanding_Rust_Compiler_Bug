{"sha": "bcb9a772e9287057d8c20fc04c91e716ecff36fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNiOWE3NzJlOTI4NzA1N2Q4YzIwZmMwNGM5MWU3MTZlY2ZmMzZmZQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2016-11-14T19:55:42Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-11-14T19:55:42Z"}, "message": "rs6000.c (rs6000_expand_vector_set): Add support for using xxinsertw and vinsert{b,h} on ISA 3.0.\n\n[gcc]\n2016-11-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_expand_vector_set): Add support\n\tfor using xxinsertw and vinsert{b,h} on ISA 3.0.\n\n\t* config/rs6000/vsx.md (vsx_extract_<mode>): Update comment.\n\t(vsx_set_<mode>_p9): New insn to generate xxinsertw and\n\tvinsert{b,h} on ISA 3.0.\n\n[gcc/testsuite]\n2016-11-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/vec-set-int.c: New test.\n\t* gcc.target/powerpc/vec-set-short.c: Likesie.\n\t* gcc.target/powerpc/vec-set-char.c: Likewise.\n\nFrom-SVN: r242397", "tree": {"sha": "acecd1905711db7abe57f78abe3b79cba4dc6c60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acecd1905711db7abe57f78abe3b79cba4dc6c60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcb9a772e9287057d8c20fc04c91e716ecff36fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcb9a772e9287057d8c20fc04c91e716ecff36fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcb9a772e9287057d8c20fc04c91e716ecff36fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcb9a772e9287057d8c20fc04c91e716ecff36fe/comments", "author": null, "committer": null, "parents": [{"sha": "3eb89071d6ffc652b0bde7aa0a5ea61da6ac96f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eb89071d6ffc652b0bde7aa0a5ea61da6ac96f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3eb89071d6ffc652b0bde7aa0a5ea61da6ac96f6"}], "stats": {"total": 199, "additions": 190, "deletions": 9}, "files": [{"sha": "0044469e970d14714e5d290210ebcac99abf194b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb9a772e9287057d8c20fc04c91e716ecff36fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb9a772e9287057d8c20fc04c91e716ecff36fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bcb9a772e9287057d8c20fc04c91e716ecff36fe", "patch": "@@ -1,3 +1,12 @@\n+2016-11-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_expand_vector_set): Add support\n+\tfor using xxinsertw and vinsert{b,h} on ISA 3.0.\n+\n+\t* config/rs6000/vsx.md (vsx_extract_<mode>): Update comment.\n+\t(vsx_set_<mode>_p9): New insn to generate xxinsertw and\n+\tvinsert{b,h} on ISA 3.0.\n+\n 2016-11-14  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \t* tree-ssa-math-opts.c (find_bswap_or_nop): Zero out bytes in cmpxchg\n@@ -18,7 +27,7 @@\n \n 2016-11-14  Prasad Ghangal  <prasad.ghangal@gmail.com>\n \t    Richard Biener  <rguenther@suse.de>\n-    \n+\n \t* doc/invoke.texi (fgimple): Document.\n \t* dumpfile.h (TDF_GIMPLE): Add.\n \t* dumpfile.c (dump_options): Add gimple."}, {"sha": "c2234345f32bd062dd41b77d9678a5f0e0878088", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb9a772e9287057d8c20fc04c91e716ecff36fe/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb9a772e9287057d8c20fc04c91e716ecff36fe/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=bcb9a772e9287057d8c20fc04c91e716ecff36fe", "patch": "@@ -7095,12 +7095,33 @@ rs6000_expand_vector_set (rtx target, rtx val, int elt)\n   int width = GET_MODE_SIZE (inner_mode);\n   int i;\n \n-  if (VECTOR_MEM_VSX_P (mode) && (mode == V2DFmode || mode == V2DImode))\n+  if (VECTOR_MEM_VSX_P (mode))\n     {\n-      rtx (*set_func) (rtx, rtx, rtx, rtx)\n-\t= ((mode == V2DFmode) ? gen_vsx_set_v2df : gen_vsx_set_v2di);\n-      emit_insn (set_func (target, target, val, GEN_INT (elt)));\n-      return;\n+      rtx insn = NULL_RTX;\n+      rtx elt_rtx = GEN_INT (elt);\n+\n+      if (mode == V2DFmode)\n+\tinsn = gen_vsx_set_v2df (target, target, val, elt_rtx);\n+\n+      else if (mode == V2DImode)\n+\tinsn = gen_vsx_set_v2di (target, target, val, elt_rtx);\n+\n+      else if (TARGET_P9_VECTOR && TARGET_VSX_SMALL_INTEGER\n+\t       && TARGET_UPPER_REGS_DI && TARGET_POWERPC64)\n+\t{\n+\t  if (mode == V4SImode)\n+\t    insn = gen_vsx_set_v4si_p9 (target, target, val, elt_rtx);\n+\t  else if (mode == V8HImode)\n+\t    insn = gen_vsx_set_v8hi_p9 (target, target, val, elt_rtx);\n+\t  else if (mode == V16QImode)\n+\t    insn = gen_vsx_set_v16qi_p9 (target, target, val, elt_rtx);\n+\t}\n+\n+      if (insn)\n+\t{\n+\t  emit_insn (insn);\n+\t  return;\n+\t}\n     }\n \n   /* Simplify setting single element vectors like V1TImode.  */"}, {"sha": "75c16252f8ca66c48e1b04f9d7716b5746f74a45", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb9a772e9287057d8c20fc04c91e716ecff36fe/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb9a772e9287057d8c20fc04c91e716ecff36fe/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=bcb9a772e9287057d8c20fc04c91e716ecff36fe", "patch": "@@ -2514,9 +2514,9 @@\n     FAIL;\n })\n \n-;; Extraction of a single element in a small integer vector.  None of the small\n-;; types are currently allowed in a vector register, so we extract to a DImode\n-;; and either do a direct move or store.\n+;; Extraction of a single element in a small integer vector.  Until ISA 3.0,\n+;; none of the small types were allowed in a vector register, so we had to\n+;; extract to a DImode and either do a direct move or store.\n (define_expand  \"vsx_extract_<mode>\"\n   [(parallel [(set (match_operand:<VS_scalar> 0 \"gpc_reg_operand\")\n \t\t   (vec_select:<VS_scalar>\n@@ -2839,6 +2839,31 @@\n   DONE;\n })\n \n+;; V4SI/V8HI/V16QI set operation on ISA 3.0\n+(define_insn \"vsx_set_<mode>_p9\"\n+  [(set (match_operand:VSX_EXTRACT_I 0 \"gpc_reg_operand\" \"=<VSX_EX>\")\n+\t(unspec:VSX_EXTRACT_I\n+\t [(match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"0\")\n+\t  (match_operand:<VS_scalar> 2 \"gpc_reg_operand\" \"<VSX_EX>\")\n+\t  (match_operand:QI 3 \"<VSX_EXTRACT_PREDICATE>\" \"n\")]\n+\t UNSPEC_VSX_SET))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_P9_VECTOR && TARGET_VSX_SMALL_INTEGER\n+   && TARGET_UPPER_REGS_DI && TARGET_POWERPC64\"\n+{\n+  int ele = INTVAL (operands[3]);\n+  int nunits = GET_MODE_NUNITS (<MODE>mode);\n+\n+  if (!VECTOR_ELT_ORDER_BIG)\n+    ele = nunits - 1 - ele;\n+\n+  operands[3] = GEN_INT (nunits * ele);\n+  if (<MODE>mode == V4SImode)\n+    return \"xxinsertw %x0,%x2,%3\";\n+  else\n+    return \"vinsert<wd> %0,%2,%3\";\n+}\n+  [(set_attr \"type\" \"vecperm\")])\n+\n ;; Expanders for builtins\n (define_expand \"vsx_mergel_<mode>\"\n   [(use (match_operand:VSX_D 0 \"vsx_register_operand\" \"\"))"}, {"sha": "8c2c1a692396b01549db0fb8eb50caef1950bd7a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb9a772e9287057d8c20fc04c91e716ecff36fe/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb9a772e9287057d8c20fc04c91e716ecff36fe/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bcb9a772e9287057d8c20fc04c91e716ecff36fe", "patch": "@@ -1,3 +1,9 @@\n+2016-11-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/vec-set-int.c: New test.\n+\t* gcc.target/powerpc/vec-set-short.c: Likesie.\n+\t* gcc.target/powerpc/vec-set-char.c: Likewise.\n+\n 2016-11-14  Jakub Jelinek  <jakub@redhat.com>\n \n \t* g++.dg/cpp1z/feat-cxx1z.C: Test __cpp_structured_bindings macro."}, {"sha": "2da79ef9e9d235edee417e2df84e79111a97dcd4", "filename": "gcc/testsuite/gcc.target/powerpc/vec-set-char.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb9a772e9287057d8c20fc04c91e716ecff36fe/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-set-char.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb9a772e9287057d8c20fc04c91e716ecff36fe/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-set-char.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-set-char.c?ref=bcb9a772e9287057d8c20fc04c91e716ecff36fe", "patch": "@@ -0,0 +1,40 @@\n+#include <altivec.h>\n+\n+/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9 -O2 -mupper-regs-di -mvsx-small-integer\" } */\n+\n+vector char\n+insert_0_0 (vector char v)\n+{\n+  return vec_insert (0, v, 0);\n+}\n+\n+vector char\n+insert_m1_1 (vector char v)\n+{\n+  return vec_insert (-1, v, 1);\n+}\n+\n+vector char\n+insert_5_2 (vector char v)\n+{\n+  return vec_insert (5, v, 2);\n+}\n+\n+vector char\n+insert_mem_15 (vector char v, char *p)\n+{\n+  return vec_insert (*p, v, 15);\n+}\n+\n+/* { dg-final { scan-assembler     \"vinsertb\" } } */\n+/* { dg-final { scan-assembler     \"xxspltib\" } } */\n+/* { dg-final { scan-assembler     \"vspltisb\" } } */\n+/* { dg-final { scan-assembler-not \"mtvsrd\"   } } */\n+/* { dg-final { scan-assembler-not \"mtvsrdd\"  } } */\n+/* { dg-final { scan-assembler-not \"mtvsrwa\"  } } */\n+/* { dg-final { scan-assembler-not \"mtvsrwz\"  } } */\n+/* { dg-final { scan-assembler-not \"mfvsrd\"   } } */\n+/* { dg-final { scan-assembler-not \"mfvsrwz\"  } } */"}, {"sha": "dc97ac9d4d3ec3f016d2cdf8289a112553081a04", "filename": "gcc/testsuite/gcc.target/powerpc/vec-set-int.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb9a772e9287057d8c20fc04c91e716ecff36fe/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-set-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb9a772e9287057d8c20fc04c91e716ecff36fe/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-set-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-set-int.c?ref=bcb9a772e9287057d8c20fc04c91e716ecff36fe", "patch": "@@ -0,0 +1,40 @@\n+#include <altivec.h>\n+\n+/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9 -O2 -mupper-regs-di -mvsx-small-integer\" } */\n+\n+vector int\n+insert_0_0 (vector int v)\n+{\n+  return vec_insert (0, v, 0);\n+}\n+\n+vector int\n+insert_m1_1 (vector int v)\n+{\n+  return vec_insert (-1, v, 1);\n+}\n+\n+vector int\n+insert_5_2 (vector int v)\n+{\n+  return vec_insert (5, v, 2);\n+}\n+\n+vector int\n+insert_mem_3 (vector int v, int *p)\n+{\n+  return vec_insert (*p, v, 3);\n+}\n+\n+/* { dg-final { scan-assembler     \"xxinsertw\" } } */\n+/* { dg-final { scan-assembler     \"xxspltib\"  } } */\n+/* { dg-final { scan-assembler     \"vspltisw\"  } } */\n+/* { dg-final { scan-assembler-not \"mtvsrd\"    } } */\n+/* { dg-final { scan-assembler-not \"mtvsrdd\"   } } */\n+/* { dg-final { scan-assembler-not \"mtvsrwa\"   } } */\n+/* { dg-final { scan-assembler-not \"mtvsrwz\"   } } */\n+/* { dg-final { scan-assembler-not \"mfvsrd\"    } } */\n+/* { dg-final { scan-assembler-not \"mfvsrwz\"   } } */"}, {"sha": "d82760955fdfcbc8e67c6d5508f847a320b0f36e", "filename": "gcc/testsuite/gcc.target/powerpc/vec-set-short.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb9a772e9287057d8c20fc04c91e716ecff36fe/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-set-short.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb9a772e9287057d8c20fc04c91e716ecff36fe/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-set-short.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-set-short.c?ref=bcb9a772e9287057d8c20fc04c91e716ecff36fe", "patch": "@@ -0,0 +1,40 @@\n+#include <altivec.h>\n+\n+/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9 -O2 -mupper-regs-di -mvsx-small-integer\" } */\n+\n+vector short\n+insert_0_0 (vector short v)\n+{\n+  return vec_insert (0, v, 0);\n+}\n+\n+vector short\n+insert_m1_1 (vector short v)\n+{\n+  return vec_insert (-1, v, 1);\n+}\n+\n+vector short\n+insert_5_2 (vector short v)\n+{\n+  return vec_insert (5, v, 2);\n+}\n+\n+vector short\n+insert_mem_7 (vector short v, short *p)\n+{\n+  return vec_insert (*p, v, 7);\n+}\n+\n+/* { dg-final { scan-assembler     \"vinserth\" } } */\n+/* { dg-final { scan-assembler     \"xxspltib\" } } */\n+/* { dg-final { scan-assembler     \"vspltish\" } } */\n+/* { dg-final { scan-assembler-not \"mtvsrd\"   } } */\n+/* { dg-final { scan-assembler-not \"mtvsrdd\"  } } */\n+/* { dg-final { scan-assembler-not \"mtvsrwa\"  } } */\n+/* { dg-final { scan-assembler-not \"mtvsrwz\"  } } */\n+/* { dg-final { scan-assembler-not \"mfvsrd\"   } } */\n+/* { dg-final { scan-assembler-not \"mfvsrwz\"  } } */"}]}