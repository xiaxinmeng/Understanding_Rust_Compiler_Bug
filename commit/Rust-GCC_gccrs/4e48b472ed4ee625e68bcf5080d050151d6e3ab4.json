{"sha": "4e48b472ed4ee625e68bcf5080d050151d6e3ab4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU0OGI0NzJlZDRlZTYyNWU2OGJjZjUwODBkMDUwMTUxZDZlM2FiNA==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2017-12-28T20:19:01Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2017-12-28T20:19:01Z"}, "message": "re PR fortran/83548 (Compilation Error using logical function in parameter)\n\n2017-12-28  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\tPR Fortran/83548\n\t* match.c (gfc_match_type_spec): Check for LOGICAL conflict in\n\ttype-spec versus LOGICAL intrinsic subprogram.\n\n2017-12-28  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\tPR Fortran/83548\n\t* gfortran.dg/array_constructor_type_22.f03: New test.\n\nFrom-SVN: r256022", "tree": {"sha": "6fb75aacacf917291267381d138b2f350fa8683c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fb75aacacf917291267381d138b2f350fa8683c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e48b472ed4ee625e68bcf5080d050151d6e3ab4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e48b472ed4ee625e68bcf5080d050151d6e3ab4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e48b472ed4ee625e68bcf5080d050151d6e3ab4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e48b472ed4ee625e68bcf5080d050151d6e3ab4/comments", "author": null, "committer": null, "parents": [{"sha": "208413c7b4d3a2360ba4864f00ceaf720b4f67c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/208413c7b4d3a2360ba4864f00ceaf720b4f67c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/208413c7b4d3a2360ba4864f00ceaf720b4f67c7"}], "stats": {"total": 70, "additions": 57, "deletions": 13}, "files": [{"sha": "678ffc684694560ce485e43f9954ea5b3a6a120a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e48b472ed4ee625e68bcf5080d050151d6e3ab4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e48b472ed4ee625e68bcf5080d050151d6e3ab4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4e48b472ed4ee625e68bcf5080d050151d6e3ab4", "patch": "@@ -1,3 +1,9 @@\n+2017-12-28  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR Fortran/83548\n+\t* match.c (gfc_match_type_spec): Check for LOGICAL conflict in\n+\ttype-spec versus LOGICAL intrinsic subprogram.\n+\n 2017-12-28  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR fortran/83344"}, {"sha": "d251a4d8cd8a41810d8cec468fd96240d9278b3d", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e48b472ed4ee625e68bcf5080d050151d6e3ab4/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e48b472ed4ee625e68bcf5080d050151d6e3ab4/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=4e48b472ed4ee625e68bcf5080d050151d6e3ab4", "patch": "@@ -2102,27 +2102,31 @@ gfc_match_type_spec (gfc_typespec *ts)\n       return m;\n     }\n \n-  if (gfc_match (\"logical\") == MATCH_YES)\n-    {\n-      ts->type = BT_LOGICAL;\n-      ts->kind = gfc_default_logical_kind;\n-      goto kind_selector;\n-    }\n-\n   /* REAL is a real pain because it can be a type, intrinsic subprogram,\n      or list item in a type-list of an OpenMP reduction clause.  Need to\n      differentiate REAL([KIND]=scalar-int-initialization-expr) from\n-     REAL(A,[KIND]) and REAL(KIND,A).  */\n+     REAL(A,[KIND]) and REAL(KIND,A).  Logically, when this code was\n+     written the use of LOGICAL as a type-spec or intrinsic subprogram \n+     was overlooked.  */\n \n   m = gfc_match (\" %n\", name);\n-  if (m == MATCH_YES && strcmp (name, \"real\") == 0)\n+  if (m == MATCH_YES\n+      && (strcmp (name, \"real\") == 0 || strcmp (name, \"logical\") == 0))\n     {\n       char c;\n       gfc_expr *e;\n       locus where;\n \n-      ts->type = BT_REAL;\n-      ts->kind = gfc_default_real_kind;\n+      if (*name == 'r')\n+\t{\n+\t  ts->type = BT_REAL;\n+\t  ts->kind = gfc_default_real_kind;\n+\t}\n+      else\n+\t{\n+\t  ts->type = BT_LOGICAL;\n+\t  ts->kind = gfc_default_logical_kind;\n+\t}\n \n       gfc_gobble_whitespace ();\n \n@@ -2154,7 +2158,7 @@ gfc_match_type_spec (gfc_typespec *ts)\n \t  c = gfc_next_char ();\n \t  if (c == '=')\n \t    {\n-\t      if (strcmp(name, \"a\") == 0)\n+\t      if (strcmp(name, \"a\") == 0 || strcmp(name, \"l\") == 0)\n \t\treturn MATCH_NO;\n \t      else if (strcmp(name, \"kind\") == 0)\n \t\tgoto found;\n@@ -2194,7 +2198,7 @@ gfc_match_type_spec (gfc_typespec *ts)\n \n \t  gfc_next_char (); /* Burn the ')'. */\n \t  ts->kind = (int) mpz_get_si (e->value.integer);\n-\t  if (gfc_validate_kind (BT_REAL, ts->kind , true) == -1)\n+\t  if (gfc_validate_kind (ts->type, ts->kind , true) == -1)\n \t    {\n \t      gfc_error (\"Invalid type-spec at %C\");\n \t      return MATCH_ERROR;"}, {"sha": "4be6423aaa2622172b904411163a8d494ea71b5e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e48b472ed4ee625e68bcf5080d050151d6e3ab4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e48b472ed4ee625e68bcf5080d050151d6e3ab4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4e48b472ed4ee625e68bcf5080d050151d6e3ab4", "patch": "@@ -1,3 +1,8 @@\n+2017-12-28  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR Fortran/83548\n+\t* gfortran.dg/array_constructor_type_22.f03: New test.\n+\n 2017-12-28  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR fortran/83344"}, {"sha": "9122eb51e86d7b4ee1711f4165353ef86473aeb2", "filename": "gcc/testsuite/gfortran.dg/array_constructor_type_22.f03", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e48b472ed4ee625e68bcf5080d050151d6e3ab4/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_type_22.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e48b472ed4ee625e68bcf5080d050151d6e3ab4/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_type_22.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_type_22.f03?ref=4e48b472ed4ee625e68bcf5080d050151d6e3ab4", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do compile }\n+! PR Fortran/83548\n+program foo\n+\n+   implicit none\n+\n+   logical, parameter :: t = .true., f = .false.\n+   logical, parameter :: a1(2) = [t, f]\n+   logical(kind=1), parameter :: a2(2) = [logical(kind=1) :: t,  f]\n+   logical(kind=4), parameter :: a3(2) = [logical(kind=4) :: t,  f]\n+   logical(kind=1), parameter :: a4(2) = [logical(t, 1), logical(f, 1)]\n+   logical(kind=4), parameter :: a5(2) = [logical(t, 4), logical(f, 4)]\n+   logical(kind=1) b(2)\n+   logical(kind=4) c(2)\n+\n+   real, parameter :: x = 1, y = 2\n+   real, parameter :: r1(2) = [x, y]\n+   real(kind=4), parameter :: r2(2) = [real(kind=4) :: x,  y]\n+   real(kind=8), parameter :: r3(2) = [real(kind=8) :: x,  y]\n+   real(kind=4), parameter :: r4(2) = [real(x, 4), real(y, 4)]\n+   real(kind=8), parameter :: r5(2) = [real(x, 8), real(y, 8)]\n+   real(kind=4) p(2)\n+   real(kind=8) q(2)\n+\n+   p = [real(kind=4) :: x,  y]\n+   q = [real(kind=8) :: x,  y]\n+   if (any(p .ne. r2)) call abort\n+   if (any(q .ne. r3)) call abort\n+end program foo"}]}