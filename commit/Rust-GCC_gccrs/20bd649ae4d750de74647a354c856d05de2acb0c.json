{"sha": "20bd649ae4d750de74647a354c856d05de2acb0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBiZDY0OWFlNGQ3NTBkZTc0NjQ3YTM1NGM4NTZkMDVkZTJhY2IwYw==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2014-12-11T11:07:58Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2014-12-11T11:07:58Z"}, "message": "fold-const.c (fold_negate_expr): Add ANY_INTEGRAL_TYPE_P check.\n\n\t* fold-const.c (fold_negate_expr): Add ANY_INTEGRAL_TYPE_P check.\n\t(extract_muldiv_1): Likewise.\n\t(maybe_canonicalize_comparison_1): Likewise.\n\t(fold_comparison): Likewise.\n\t(tree_binary_nonnegative_warnv_p): Likewise.\n\t(tree_binary_nonzero_warnv_p): Likewise.\n\t* gimple-ssa-strength-reduction.c (legal_cast_p_1): Likewise.\n\t* tree-scalar-evolution.c (simple_iv): Likewise.\n\t(scev_const_prop): Likewise.\n\t* tree-ssa-loop-niter.c (expand_simple_operations): Likewise.\n\t* tree-vect-generic.c (expand_vector_operation): Likewise.\n\t* tree.h (ANY_INTEGRAL_TYPE_CHECK): Define.\n\t(ANY_INTEGRAL_TYPE_P): Define.\n\t(TYPE_OVERFLOW_WRAPS, TYPE_OVERFLOW_UNDEFINED, TYPE_OVERFLOW_TRAPS):\n\tAdd ANY_INTEGRAL_TYPE_CHECK.\n\t(any_integral_type_check): New function.\n\nFrom-SVN: r218621", "tree": {"sha": "22c03e8da3a902dc6f9f55eeee02c2dfeda09227", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22c03e8da3a902dc6f9f55eeee02c2dfeda09227"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20bd649ae4d750de74647a354c856d05de2acb0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20bd649ae4d750de74647a354c856d05de2acb0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20bd649ae4d750de74647a354c856d05de2acb0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20bd649ae4d750de74647a354c856d05de2acb0c/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f63950e56178b03d3adffc818b247eb6e1c6d340", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f63950e56178b03d3adffc818b247eb6e1c6d340", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f63950e56178b03d3adffc818b247eb6e1c6d340"}], "stats": {"total": 107, "additions": 87, "deletions": 20}, "files": [{"sha": "24bd895d002d64c403784e347d57c0d3824fdb82", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bd649ae4d750de74647a354c856d05de2acb0c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bd649ae4d750de74647a354c856d05de2acb0c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=20bd649ae4d750de74647a354c856d05de2acb0c", "patch": "@@ -1,3 +1,22 @@\n+2014-12-11  Marek Polacek  <polacek@redhat.com>\n+\n+\t* fold-const.c (fold_negate_expr): Add ANY_INTEGRAL_TYPE_P check.\n+\t(extract_muldiv_1): Likewise.\n+\t(maybe_canonicalize_comparison_1): Likewise.\n+\t(fold_comparison): Likewise.\n+\t(tree_binary_nonnegative_warnv_p): Likewise.\n+\t(tree_binary_nonzero_warnv_p): Likewise.\n+\t* gimple-ssa-strength-reduction.c (legal_cast_p_1): Likewise.\n+\t* tree-scalar-evolution.c (simple_iv): Likewise.\n+\t(scev_const_prop): Likewise.\n+\t* tree-ssa-loop-niter.c (expand_simple_operations): Likewise.\n+\t* tree-vect-generic.c (expand_vector_operation): Likewise.\n+\t* tree.h (ANY_INTEGRAL_TYPE_CHECK): Define.\n+\t(ANY_INTEGRAL_TYPE_P): Define.\n+\t(TYPE_OVERFLOW_WRAPS, TYPE_OVERFLOW_UNDEFINED, TYPE_OVERFLOW_TRAPS):\n+\tAdd ANY_INTEGRAL_TYPE_CHECK.\n+\t(any_integral_type_check): New function.\n+\n 2014-12-11  Tobias Burnus  <burnus@net-b.de>\n \t    Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n "}, {"sha": "7b68bea18ab805fa7661300cc3967a2a3eb30c5b", "filename": "gcc/fold-const.c", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bd649ae4d750de74647a354c856d05de2acb0c/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bd649ae4d750de74647a354c856d05de2acb0c/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=20bd649ae4d750de74647a354c856d05de2acb0c", "patch": "@@ -558,7 +558,8 @@ fold_negate_expr (location_t loc, tree t)\n     case INTEGER_CST:\n       tem = fold_negate_const (t, type);\n       if (TREE_OVERFLOW (tem) == TREE_OVERFLOW (t)\n-\t  || (!TYPE_OVERFLOW_TRAPS (type)\n+\t  || (ANY_INTEGRAL_TYPE_P (type)\n+\t      && !TYPE_OVERFLOW_TRAPS (type)\n \t      && TYPE_OVERFLOW_WRAPS (type))\n \t  || (flag_sanitize & SANITIZE_SI_OVERFLOW) == 0)\n \treturn tem;\n@@ -5951,7 +5952,8 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n \t   || EXPRESSION_CLASS_P (op0))\n \t  /* ... and has wrapping overflow, and its type is smaller\n \t     than ctype, then we cannot pass through as widening.  */\n-\t  && ((TYPE_OVERFLOW_WRAPS (TREE_TYPE (op0))\n+\t  && (((ANY_INTEGRAL_TYPE_P (TREE_TYPE (op0))\n+\t\t&& TYPE_OVERFLOW_WRAPS (TREE_TYPE (op0)))\n \t       && (TYPE_PRECISION (ctype)\n \t           > TYPE_PRECISION (TREE_TYPE (op0))))\n \t      /* ... or this is a truncation (t is narrower than op0),\n@@ -5966,7 +5968,8 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n \t      /* ... or has undefined overflow while the converted to\n \t\t type has not, we cannot do the operation in the inner type\n \t\t as that would introduce undefined overflow.  */\n-\t      || (TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (op0))\n+\t      || ((ANY_INTEGRAL_TYPE_P (TREE_TYPE (op0))\n+\t\t   && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (op0)))\n \t\t  && !TYPE_OVERFLOW_UNDEFINED (type))))\n \tbreak;\n \n@@ -8497,7 +8500,8 @@ maybe_canonicalize_comparison_1 (location_t loc, enum tree_code code, tree type,\n \n   /* Match A +- CST code arg1 and CST code arg1.  We can change the\n      first form only if overflow is undefined.  */\n-  if (!((TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg0))\n+  if (!(((ANY_INTEGRAL_TYPE_P (TREE_TYPE (arg0))\n+\t  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg0)))\n \t /* In principle pointers also have undefined overflow behavior,\n \t    but that causes problems elsewhere.  */\n \t && !POINTER_TYPE_P (TREE_TYPE (arg0))\n@@ -8712,7 +8716,9 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \n   /* Transform comparisons of the form X +- C1 CMP C2 to X CMP C2 -+ C1.  */\n   if ((TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n-      && (equality_code || TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg0)))\n+      && (equality_code\n+\t  || (ANY_INTEGRAL_TYPE_P (TREE_TYPE (arg0))\n+\t      && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg0))))\n       && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n       && !TREE_OVERFLOW (TREE_OPERAND (arg0, 1))\n       && TREE_CODE (arg1) == INTEGER_CST\n@@ -9031,7 +9037,8 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n      X CMP Y +- C2 +- C1 for signed X, Y.  This is valid if\n      the resulting offset is smaller in absolute value than the\n      original one and has the same sign.  */\n-  if (TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg0))\n+  if (ANY_INTEGRAL_TYPE_P (TREE_TYPE (arg0))\n+      && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg0))\n       && (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n       && (TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n \t  && !TREE_OVERFLOW (TREE_OPERAND (arg0, 1)))\n@@ -9085,7 +9092,8 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n      signed arithmetic case.  That form is created by the compiler\n      often enough for folding it to be of value.  One example is in\n      computing loop trip counts after Operator Strength Reduction.  */\n-  if (TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg0))\n+  if (ANY_INTEGRAL_TYPE_P (TREE_TYPE (arg0))\n+      && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg0))\n       && TREE_CODE (arg0) == MULT_EXPR\n       && (TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n           && !TREE_OVERFLOW (TREE_OPERAND (arg0, 1)))\n@@ -14733,7 +14741,8 @@ tree_binary_nonnegative_warnv_p (enum tree_code code, tree type, tree op0,\n \t      || (tree_expr_nonnegative_warnv_p (op0, strict_overflow_p)\n \t\t  && tree_expr_nonnegative_warnv_p (op1, strict_overflow_p)))\n \t    {\n-\t      if (TYPE_OVERFLOW_UNDEFINED (type))\n+\t      if (ANY_INTEGRAL_TYPE_P (type)\n+\t\t  && TYPE_OVERFLOW_UNDEFINED (type))\n \t\t*strict_overflow_p = true;\n \t      return true;\n \t    }\n@@ -15205,7 +15214,7 @@ tree_binary_nonzero_warnv_p (enum tree_code code,\n     {\n     case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n-      if (TYPE_OVERFLOW_UNDEFINED (type))\n+      if (ANY_INTEGRAL_TYPE_P (type) && TYPE_OVERFLOW_UNDEFINED (type))\n \t{\n \t  /* With the presence of negative values it is hard\n \t     to say something.  */"}, {"sha": "945075c2517633217a41715789f30d57c3f34de6", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bd649ae4d750de74647a354c856d05de2acb0c/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bd649ae4d750de74647a354c856d05de2acb0c/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=20bd649ae4d750de74647a354c856d05de2acb0c", "patch": "@@ -1487,8 +1487,8 @@ legal_cast_p_1 (tree lhs, tree rhs)\n   rhs_type = TREE_TYPE (rhs);\n   lhs_size = TYPE_PRECISION (lhs_type);\n   rhs_size = TYPE_PRECISION (rhs_type);\n-  lhs_wraps = TYPE_OVERFLOW_WRAPS (lhs_type);\n-  rhs_wraps = TYPE_OVERFLOW_WRAPS (rhs_type);\n+  lhs_wraps = ANY_INTEGRAL_TYPE_P (lhs_type) && TYPE_OVERFLOW_WRAPS (lhs_type);\n+  rhs_wraps = ANY_INTEGRAL_TYPE_P (rhs_type) && TYPE_OVERFLOW_WRAPS (rhs_type);\n \n   if (lhs_size < rhs_size\n       || (rhs_wraps && !lhs_wraps)"}, {"sha": "7c698149d90245ba6857e9750800bb2a05ff963a", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bd649ae4d750de74647a354c856d05de2acb0c/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bd649ae4d750de74647a354c856d05de2acb0c/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=20bd649ae4d750de74647a354c856d05de2acb0c", "patch": "@@ -3267,7 +3267,8 @@ simple_iv (struct loop *wrto_loop, struct loop *use_loop, tree op,\n   if (tree_contains_chrecs (iv->base, NULL))\n     return false;\n \n-  iv->no_overflow = !folded_casts && TYPE_OVERFLOW_UNDEFINED (type);\n+  iv->no_overflow = (!folded_casts && ANY_INTEGRAL_TYPE_P (type)\n+\t\t     && TYPE_OVERFLOW_UNDEFINED (type));\n \n   return true;\n }\n@@ -3490,7 +3491,8 @@ scev_const_prop (void)\n \t  /* If def's type has undefined overflow and there were folded\n \t     casts, rewrite all stmts added for def into arithmetics\n \t     with defined overflow behavior.  */\n-\t  if (folded_casts && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (def)))\n+\t  if (folded_casts && ANY_INTEGRAL_TYPE_P (TREE_TYPE (def))\n+\t      && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (def)))\n \t    {\n \t      gimple_seq stmts;\n \t      gimple_stmt_iterator gsi2;"}, {"sha": "359d03d027cfb0671139de0e9fff2e0c30602786", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bd649ae4d750de74647a354c856d05de2acb0c/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bd649ae4d750de74647a354c856d05de2acb0c/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=20bd649ae4d750de74647a354c856d05de2acb0c", "patch": "@@ -1642,7 +1642,8 @@ expand_simple_operations (tree expr)\n \n     case PLUS_EXPR:\n     case MINUS_EXPR:\n-      if (TYPE_OVERFLOW_TRAPS (TREE_TYPE (expr)))\n+      if (ANY_INTEGRAL_TYPE_P (TREE_TYPE (expr))\n+\t  && TYPE_OVERFLOW_TRAPS (TREE_TYPE (expr)))\n \treturn expr;\n       /* Fallthru.  */\n     case POINTER_PLUS_EXPR:"}, {"sha": "de09ff0b1e79bcd283105d9265ffe33c8599da99", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bd649ae4d750de74647a354c856d05de2acb0c/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bd649ae4d750de74647a354c856d05de2acb0c/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=20bd649ae4d750de74647a354c856d05de2acb0c", "patch": "@@ -926,14 +926,14 @@ expand_vector_operation (gimple_stmt_iterator *gsi, tree type, tree compute_type\n       {\n       case PLUS_EXPR:\n       case MINUS_EXPR:\n-        if (!TYPE_OVERFLOW_TRAPS (type))\n+        if (ANY_INTEGRAL_TYPE_P (type) && !TYPE_OVERFLOW_TRAPS (type))\n \t  return expand_vector_addition (gsi, do_binop, do_plus_minus, type,\n \t\t\t\t\t gimple_assign_rhs1 (assign),\n \t\t\t\t\t gimple_assign_rhs2 (assign), code);\n \tbreak;\n \n       case NEGATE_EXPR:\n-        if (!TYPE_OVERFLOW_TRAPS (type))\n+        if (ANY_INTEGRAL_TYPE_P (type) && !TYPE_OVERFLOW_TRAPS (type))\n           return expand_vector_addition (gsi, do_unop, do_negate, type,\n \t\t      \t\t         gimple_assign_rhs1 (assign),\n \t\t\t\t\t NULL_TREE, code);"}, {"sha": "c8a91ddf8b5ee9a4fc65e42e374b955e700c73aa", "filename": "gcc/tree.h", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bd649ae4d750de74647a354c856d05de2acb0c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bd649ae4d750de74647a354c856d05de2acb0c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=20bd649ae4d750de74647a354c856d05de2acb0c", "patch": "@@ -283,6 +283,10 @@ along with GCC; see the file COPYING3.  If not see\n #define NON_TYPE_CHECK(T) \\\n (non_type_check ((T), __FILE__, __LINE__, __FUNCTION__))\n \n+/* These checks have to be special cased.  */\n+#define ANY_INTEGRAL_TYPE_CHECK(T) \\\n+(any_integral_type_check ((T), __FILE__, __LINE__, __FUNCTION__))\n+\n #define TREE_INT_CST_ELT_CHECK(T, I) \\\n (*tree_int_cst_elt_check ((T), (I), __FILE__, __LINE__, __FUNCTION__))\n \n@@ -388,6 +392,7 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n #define OMP_CLAUSE_ELT_CHECK(T, i)\t        ((T)->omp_clause.ops[i])\n #define OMP_CLAUSE_RANGE_CHECK(T, CODE1, CODE2)\t(T)\n #define OMP_CLAUSE_SUBCODE_CHECK(T, CODE)\t(T)\n+#define ANY_INTEGRAL_TYPE_CHECK(T)\t\t(T)\n \n #define TREE_CHAIN(NODE) ((NODE)->common.chain)\n #define TREE_TYPE(NODE) ((NODE)->typed.type)\n@@ -482,6 +487,15 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n    || TREE_CODE (TYPE) == BOOLEAN_TYPE \\\n    || TREE_CODE (TYPE) == INTEGER_TYPE)\n \n+/* Nonzero if TYPE represents an integral type, including complex\n+   and vector integer types.  */\n+\n+#define ANY_INTEGRAL_TYPE_P(TYPE)\t\t\\\n+  (INTEGRAL_TYPE_P (TYPE)\t\t\t\\\n+   || ((TREE_CODE (TYPE) == COMPLEX_TYPE \t\\\n+        || VECTOR_TYPE_P (TYPE))\t\t\\\n+       && INTEGRAL_TYPE_P (TREE_TYPE (TYPE))))\n+\n /* Nonzero if TYPE represents a non-saturating fixed-point type.  */\n \n #define NON_SAT_FIXED_POINT_TYPE_P(TYPE) \\\n@@ -771,7 +785,7 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n /* True if overflow wraps around for the given integral type.  That\n    is, TYPE_MAX + 1 == TYPE_MIN.  */\n #define TYPE_OVERFLOW_WRAPS(TYPE) \\\n-  (TYPE_UNSIGNED (TYPE) || flag_wrapv)\n+  (ANY_INTEGRAL_TYPE_CHECK(TYPE)->base.u.bits.unsigned_flag || flag_wrapv)\n \n /* True if overflow is undefined for the given integral type.  We may\n    optimize on the assumption that values in the type never overflow.\n@@ -781,13 +795,14 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n    it will be appropriate to issue the warning immediately, and in\n    other cases it will be appropriate to simply set a flag and let the\n    caller decide whether a warning is appropriate or not.  */\n-#define TYPE_OVERFLOW_UNDEFINED(TYPE) \\\n-  (!TYPE_UNSIGNED (TYPE) && !flag_wrapv && !flag_trapv && flag_strict_overflow)\n+#define TYPE_OVERFLOW_UNDEFINED(TYPE)\t\t\t\t\\\n+  (!ANY_INTEGRAL_TYPE_CHECK(TYPE)->base.u.bits.unsigned_flag\t\\\n+   && !flag_wrapv && !flag_trapv && flag_strict_overflow)\n \n /* True if overflow for the given integral type should issue a\n    trap.  */\n #define TYPE_OVERFLOW_TRAPS(TYPE) \\\n-  (!TYPE_UNSIGNED (TYPE) && flag_trapv)\n+  (!ANY_INTEGRAL_TYPE_CHECK(TYPE)->base.u.bits.unsigned_flag && flag_trapv)\n \n /* True if an overflow is to be preserved for sanitization.  */\n #define TYPE_OVERFLOW_SANITIZED(TYPE)\t\t\t\\\n@@ -2990,6 +3005,17 @@ omp_clause_elt_check (tree __t, int __i,\n   return &__t->omp_clause.ops[__i];\n }\n \n+/* These checks have to be special cased.  */\n+\n+inline tree\n+any_integral_type_check (tree __t, const char *__f, int __l, const char *__g)\n+{\n+  if (!ANY_INTEGRAL_TYPE_P (__t))\n+    tree_check_failed (__t, __f, __l, __g, BOOLEAN_TYPE, ENUMERAL_TYPE,\n+\t\t       INTEGER_TYPE, 0);\n+  return __t;\n+}\n+\n inline const_tree\n tree_check (const_tree __t, const char *__f, int __l, const char *__g,\n \t    tree_code __c)\n@@ -3197,6 +3223,16 @@ omp_clause_elt_check (const_tree __t, int __i,\n   return CONST_CAST (const_tree *, &__t->omp_clause.ops[__i]);\n }\n \n+inline const_tree\n+any_integral_type_check (const_tree __t, const char *__f, int __l,\n+\t\t\t const char *__g)\n+{\n+  if (!ANY_INTEGRAL_TYPE_P (__t))\n+    tree_check_failed (__t, __f, __l, __g, BOOLEAN_TYPE, ENUMERAL_TYPE,\n+\t\t       INTEGER_TYPE, 0);\n+  return __t;\n+}\n+\n #endif\n \n /* Compute the number of operands in an expression node NODE.  For"}]}