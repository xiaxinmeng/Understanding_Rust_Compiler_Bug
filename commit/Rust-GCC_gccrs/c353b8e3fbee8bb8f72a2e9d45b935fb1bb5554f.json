{"sha": "c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM1M2I4ZTNmYmVlOGJiOGY3MmEyZTlkNDViOTM1ZmIxYmI1NTU0Zg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-01-26T17:41:50Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-01-26T17:41:50Z"}, "message": "class.c (add_method): Just check processing_template_decl to determine whether or not we are within a...\n\n\t* class.c (add_method): Just check processing_template_decl to\n\tdetermine whether or not we are within a template.\n\t* decl2.c (maybe_retrofit_in_chrg): Likewise.\n\t* init.c (decl_constant_value): Check the type of the declaration,\n\tnot TREE_READONLY.\n\t* name-lookup.c (maybe_push_to_top_level): Rename to ...\n\t(push_to_top_level): ... this.\n\t* name-lookup.h (maybe_push_to_top_level): Do not declare it.\n\t* pt.c (push_template_decl_real): Reorder condition for speed.\n\t(convert_template_argument): Use dependency-checking functions in\n\tplace of uses_template_parms.\n\t(lookup_template_class): Avoid calling uses_template_parms more\n\tthan once.\n\t(uses_template_parms): Reimplement, using dependency-checking\n\tfunctions.\n\t(instantiate_class_template): Use push_to_top_level, not\n\tmaybe_push_to_top_level.\n\t(type_unification_real): Simplify.\n\t(type_dependent_expression_p): Handle OFFSET_REFs and\n\tTEMPLATE_DECLs.\n\t(any_dependent_template_arguments_p): Handle multiple levels of\n\ttemplate argument.\n\t* semantics.c (expand_or_defer_fn): Do not check\n\tuses_template_parms for template instantiations.\n\t* typeck.c (comptypes): Avoid calling cp_type_quals.\n\nFrom-SVN: r76647", "tree": {"sha": "f1fbe8b9a2f8a334b51dc3db7b4365cfa40b5582", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1fbe8b9a2f8a334b51dc3db7b4365cfa40b5582"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f/comments", "author": null, "committer": null, "parents": [{"sha": "d9b7db1265b9f8285eabd73d6d9725db75ae309d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9b7db1265b9f8285eabd73d6d9725db75ae309d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9b7db1265b9f8285eabd73d6d9725db75ae309d"}], "stats": {"total": 148, "additions": 104, "deletions": 44}, "files": [{"sha": "917457b18046da9297af2789592b6575e6ddb4f5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f", "patch": "@@ -1,3 +1,31 @@\n+2004-01-26  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c (add_method): Just check processing_template_decl to\n+\tdetermine whether or not we are within a template.\n+\t* decl2.c (maybe_retrofit_in_chrg): Likewise.\n+\t* init.c (decl_constant_value): Check the type of the declaration,\n+\tnot TREE_READONLY.\n+\t* name-lookup.c (maybe_push_to_top_level): Rename to ...\n+\t(push_to_top_level): ... this.\n+\t* name-lookup.h (maybe_push_to_top_level): Do not declare it.\n+\t* pt.c (push_template_decl_real): Reorder condition for speed.\n+\t(convert_template_argument): Use dependency-checking functions in\n+\tplace of uses_template_parms.\n+\t(lookup_template_class): Avoid calling uses_template_parms more\n+\tthan once.\n+\t(uses_template_parms): Reimplement, using dependency-checking\n+\tfunctions.\n+\t(instantiate_class_template): Use push_to_top_level, not\n+\tmaybe_push_to_top_level.\n+\t(type_unification_real): Simplify.\n+\t(type_dependent_expression_p): Handle OFFSET_REFs and\n+\tTEMPLATE_DECLs.\n+\t(any_dependent_template_arguments_p): Handle multiple levels of\n+\ttemplate argument.\n+\t* semantics.c (expand_or_defer_fn): Do not check\n+\tuses_template_parms for template instantiations.\n+\t* typeck.c (comptypes): Avoid calling cp_type_quals.\n+\n 2004-01-25  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/13833"}, {"sha": "d97f85046e57ef4b1a39c4a7741bac32a98a6711", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f", "patch": "@@ -866,7 +866,7 @@ add_method (tree type, tree method, int error_p)\n \t}\n     }\n       \n-  if (template_class_depth (type))\n+  if (processing_template_decl)\n     /* TYPE is a template class.  Don't issue any errors now; wait\n        until instantiation time to complain.  */\n     ;"}, {"sha": "7bcbc605ea1b8f79085e5d6f46999adfd863e238", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f", "patch": "@@ -229,7 +229,7 @@ maybe_retrofit_in_chrg (tree fn)\n \n   /* When processing templates we can't know, in general, whether or\n      not we're going to have virtual baseclasses.  */\n-  if (uses_template_parms (fn))\n+  if (processing_template_decl)\n     return;\n \n   /* We don't need an in-charge parameter for constructors that don't"}, {"sha": "6f361b082b3f2960883d4addcd4f5ecf704a517d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f", "patch": "@@ -1610,8 +1610,12 @@ decl_constant_value (tree decl)\n \t\t      TREE_OPERAND (decl, 0), d1, d2);\n     }\n \n-  if (TREE_READONLY_DECL_P (decl)\n-      && ! TREE_THIS_VOLATILE (decl)\n+  if (DECL_P (decl)\n+      && (/* Enumeration constants are constant.  */\n+\t  TREE_CODE (decl) == CONST_DECL\n+\t  /* And so are variables with a 'const' type -- unless they\n+\t     are also 'volatile'.  */\n+\t  || CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (decl)))\n       && DECL_INITIAL (decl)\n       && DECL_INITIAL (decl) != error_mark_node\n       /* This is invalid if initial value is not constant."}, {"sha": "14f7b76bdcdcbc161ac05f272c58a9e878323bd9", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f", "patch": "@@ -4688,7 +4688,7 @@ store_bindings (tree names, cxx_saved_binding *old_bindings)\n }\n \n void\n-maybe_push_to_top_level (int pseudo)\n+push_to_top_level (void)\n {\n   struct saved_scope *s;\n   struct cp_binding_level *b;\n@@ -4723,7 +4723,7 @@ maybe_push_to_top_level (int pseudo)\n \t inserted into namespace level, finish_file wouldn't find them\n \t when doing pending instantiations. Therefore, don't stop at\n \t namespace level, but continue until :: .  */\n-      if (global_scope_p (b) || (pseudo && b->kind == sk_template_parms))\n+      if (global_scope_p (b))\n \tbreak;\n \n       old_bindings = store_bindings (b->names, old_bindings);\n@@ -4751,12 +4751,6 @@ maybe_push_to_top_level (int pseudo)\n   timevar_pop (TV_NAME_LOOKUP);\n }\n \n-void\n-push_to_top_level (void)\n-{\n-  maybe_push_to_top_level (0);\n-}\n-\n void\n pop_from_top_level (void)\n {"}, {"sha": "c986fbc9707138c7f9ebe67e2839dc9b45e414c0", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f", "patch": "@@ -264,7 +264,6 @@ extern void print_binding_stack\t(void);\n extern void print_binding_level\t(cxx_scope *);\n extern void push_to_top_level (void);\n extern void pop_from_top_level (void);\n-extern void maybe_push_to_top_level (int);\n extern void pop_everything (void);\n extern void keep_next_level (bool);\n extern bool is_ancestor (tree, tree);"}, {"sha": "ba296c700e95381adcd7b8bace3599bd1dc83015", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 58, "deletions": 20, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f", "patch": "@@ -2909,10 +2909,10 @@ push_template_decl_real (tree decl, int is_friend)\n       else\n \ttmpl = DECL_TI_TEMPLATE (decl);\n       \n-      if (is_member_template (tmpl)\n-\t  && DECL_FUNCTION_TEMPLATE_P (tmpl)\n+      if (DECL_FUNCTION_TEMPLATE_P (tmpl)\n \t  && DECL_TEMPLATE_INFO (decl) && DECL_TI_ARGS (decl) \n-\t  && DECL_TEMPLATE_SPECIALIZATION (decl))\n+\t  && DECL_TEMPLATE_SPECIALIZATION (decl)\n+\t  && is_member_template (tmpl))\n \t{\n \t  tree new_tmpl;\n \n@@ -4275,11 +4275,7 @@ lookup_template_class (tree d1,\n \t\t\t\t   template,\n \t                           complain, /*require_all_args=*/1);\n \n-      if (arglist == error_mark_node\n-\t  || (!uses_template_parms (INNERMOST_TEMPLATE_ARGS (arglist))\n-\t      && check_instantiated_args (template,\n-\t\t\t\t\t  INNERMOST_TEMPLATE_ARGS (arglist),\n-\t\t\t\t\t  complain)))\n+      if (arglist == error_mark_node)\n \t/* We were unable to bind the arguments.  */\n \tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \n@@ -4340,6 +4336,14 @@ lookup_template_class (tree d1,\n \t well.  */\n       is_partial_instantiation = uses_template_parms (arglist);\n \n+      /* If the deduced arguments are invalid, then the binding\n+\t failed.  */\n+      if (!is_partial_instantiation\n+\t  && check_instantiated_args (template,\n+\t\t\t\t      INNERMOST_TEMPLATE_ARGS (arglist),\n+\t\t\t\t      complain))\n+\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+\t\n       if (!is_partial_instantiation \n \t  && !PRIMARY_TEMPLATE_P (template)\n \t  && TREE_CODE (CP_DECL_CONTEXT (template)) == NAMESPACE_DECL)\n@@ -4717,7 +4721,34 @@ for_each_template_parm (tree t, tree_fn_t fn, void* data, htab_t visited)\n int\n uses_template_parms (tree t)\n {\n-  return for_each_template_parm (t, 0, 0, NULL);\n+  bool dependent_p;\n+  int saved_processing_template_decl;\n+\n+  saved_processing_template_decl = processing_template_decl;\n+  if (!saved_processing_template_decl)\n+    processing_template_decl = 1;\n+  if (TYPE_P (t))\n+    dependent_p = dependent_type_p (t);\n+  else if (TREE_CODE (t) == TREE_VEC)\n+    dependent_p = any_dependent_template_arguments_p (t);\n+  else if (TREE_CODE (t) == TREE_LIST)\n+    dependent_p = (uses_template_parms (TREE_VALUE (t))\n+\t\t   || uses_template_parms (TREE_CHAIN (t)));\n+  else if (DECL_P (t) \n+\t   || EXPR_P (t) \n+\t   || TREE_CODE (t) == TEMPLATE_PARM_INDEX\n+\t   || TREE_CODE (t) == OVERLOAD\n+\t   || TREE_CODE (t) == BASELINK\n+\t   || TREE_CODE_CLASS (TREE_CODE (t)) == 'c')\n+    dependent_p = (type_dependent_expression_p (t)\n+\t\t   || value_dependent_expression_p (t));\n+  else if (t == error_mark_node)\n+    dependent_p = false;\n+  else \n+    abort ();\n+  processing_template_decl = saved_processing_template_decl;\n+\n+  return dependent_p;\n }\n \n /* Returns true if T depends on any template parameter with level LEVEL.  */\n@@ -5229,7 +5260,7 @@ instantiate_class_template (tree type)\n      it now.  */\n   push_deferring_access_checks (dk_no_deferred);\n \n-  maybe_push_to_top_level (uses_template_parms (type));\n+  push_to_top_level ();\n \n   if (t)\n     {\n@@ -8952,17 +8983,14 @@ type_unification_real (tree tparms,\n \t corresponds with a function parameter that contains only\n \t non-deducible template parameters and explicitly specified\n \t template parameters.  */\n-      if (! uses_template_parms (parm))\n+      if (!uses_template_parms (parm))\n \t{\n \t  tree type;\n \n \t  if (!TYPE_P (arg))\n \t    type = TREE_TYPE (arg);\n \t  else\n-\t    {\n-\t      type = arg;\n-\t      arg = NULL_TREE;\n-\t    }\n+\t    type = arg;\n \n \t  if (strict == DEDUCE_EXACT || strict == DEDUCE_ORDER)\n \t    {\n@@ -11767,11 +11795,16 @@ type_dependent_expression_p (tree expression)\n \t  (INNERMOST_TEMPLATE_ARGS (DECL_TI_ARGS (expression)))))\n     return true;\n \n+  if (TREE_CODE (expression) == TEMPLATE_DECL\n+      && !DECL_TEMPLATE_TEMPLATE_PARM_P (expression))\n+    return false;\n+\n   if (TREE_TYPE (expression) == unknown_type_node)\n     {\n       if (TREE_CODE (expression) == ADDR_EXPR)\n \treturn type_dependent_expression_p (TREE_OPERAND (expression, 0));\n-      if (TREE_CODE (expression) == COMPONENT_REF)\n+      if (TREE_CODE (expression) == COMPONENT_REF\n+\t  || TREE_CODE (expression) == OFFSET_REF)\n \t{\n \t  if (type_dependent_expression_p (TREE_OPERAND (expression, 0)))\n \t    return true;\n@@ -11847,13 +11880,18 @@ bool\n any_dependent_template_arguments_p (tree args)\n {\n   int i;\n-  \n+  int j;\n+\n   if (!args)\n     return false;\n \n-  for (i = 0; i < TREE_VEC_LENGTH (args); ++i)\n-    if (dependent_template_arg_p (TREE_VEC_ELT (args, i)))\n-      return true;\n+  for (i = 0; i < TMPL_ARGS_DEPTH (args); ++i)\n+    {\n+      tree level = TMPL_ARGS_LEVEL (args, i + 1);\n+      for (j = 0; j < TREE_VEC_LENGTH (level); ++j)\n+\tif (dependent_template_arg_p (TREE_VEC_ELT (level, j)))\n+\t  return true;\n+    }\n \n   return false;\n }"}, {"sha": "69364d8f673825e4a0d968fbb27db7fdd3f93301", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f", "patch": "@@ -2930,14 +2930,8 @@ void\n expand_or_defer_fn (tree fn)\n {\n   /* When the parser calls us after finishing the body of a template\n-     function, we don't really want to expand the body.  When we're\n-     processing an in-class definition of an inline function,\n-     PROCESSING_TEMPLATE_DECL will no longer be set here, so we have\n-     to look at the function itself.  */\n-  if (processing_template_decl\n-      || (DECL_LANG_SPECIFIC (fn) \n-\t  && DECL_TEMPLATE_INFO (fn)\n-\t  && uses_template_parms (DECL_TI_ARGS (fn))))\n+     function, we don't really want to expand the body.  */\n+  if (processing_template_decl)\n     {\n       /* Normally, collection only occurs in rest_of_compilation.  So,\n \t if we don't collect here, we never collect junk generated"}, {"sha": "b2dfe647a6bd99c8026314034661f13eb74cc2bc", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=c353b8e3fbee8bb8f72a2e9d45b935fb1bb5554f", "patch": "@@ -963,8 +963,10 @@ comptypes (tree t1, tree t2, int strict)\n   if (TREE_CODE (t1) != TREE_CODE (t2))\n     return false;\n \n-  /* Qualifiers must match.  */\n-  if (cp_type_quals (t1) != cp_type_quals (t2))\n+  /* Qualifiers must match.  For array types, we will check when we\n+     recur on the array element types.  */\n+  if (TREE_CODE (t1) != ARRAY_TYPE\n+      && TYPE_QUALS (t1) != TYPE_QUALS (t2))\n     return false;\n   if (TYPE_FOR_JAVA (t1) != TYPE_FOR_JAVA (t2))\n     return false;\n@@ -973,7 +975,8 @@ comptypes (tree t1, tree t2, int strict)\n      definition.  Note that we already checked for equality of the type\n      qualifiers (just above).  */\n \n-  if (TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n+  if (TREE_CODE (t1) != ARRAY_TYPE\n+      && TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n     return true;\n \n   if (!(*targetm.comp_type_attributes) (t1, t2))"}]}