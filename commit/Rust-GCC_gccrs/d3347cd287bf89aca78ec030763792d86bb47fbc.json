{"sha": "d3347cd287bf89aca78ec030763792d86bb47fbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDMzNDdjZDI4N2JmODlhY2E3OGVjMDMwNzYzNzkyZDg2YmI0N2ZiYw==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.vnet.ibm.com", "date": "2017-09-21T04:30:16Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-09-21T04:30:16Z"}, "message": "s390.c (MIN_UNROLL_PROBES): Define.\n\n\t* config/s390/s390.c (MIN_UNROLL_PROBES): Define.\n\t(allocate_stack_space): New function, partially extracted from\n\ts390_emit_prologue.\n\t(s390_emit_prologue): Track offset to most recent stack probe.\n\tCode to allocate space moved into allocate_stack_space.\n\tDump actions when no stack is allocated.\n\t(s390_prologue_plus_offset): New function.\n\t(s390_emit_stack_probe): Likewise.\n\n\t* gcc.dg/stack-check-5.c:  Add argument for s390.\n\t* lib/target-supports.exp:\n\t(check_effective_target_supports_stack_clash_protection): Enable for\n\ts390/s390x targets.\n\nCo-Authored-By: Jeff Law <law@redhat.com>\n\nFrom-SVN: r253049", "tree": {"sha": "a79b3cf39f96e4094384599615d4ad35580b356f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a79b3cf39f96e4094384599615d4ad35580b356f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3347cd287bf89aca78ec030763792d86bb47fbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3347cd287bf89aca78ec030763792d86bb47fbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3347cd287bf89aca78ec030763792d86bb47fbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3347cd287bf89aca78ec030763792d86bb47fbc/comments", "author": null, "committer": null, "parents": [{"sha": "12f713131ef7ffc26cbff4c380e43109fe7afcef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12f713131ef7ffc26cbff4c380e43109fe7afcef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12f713131ef7ffc26cbff4c380e43109fe7afcef"}], "stats": {"total": 288, "additions": 260, "deletions": 28}, "files": [{"sha": "bd8bb61f71ba805fe85b9cae0ee68ef77986d77c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3347cd287bf89aca78ec030763792d86bb47fbc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3347cd287bf89aca78ec030763792d86bb47fbc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d3347cd287bf89aca78ec030763792d86bb47fbc", "patch": "@@ -1,3 +1,15 @@\n+2017-09-20  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\t    Jeff Law  <law@redhat.com>\n+\n+\t* config/s390/s390.c (MIN_UNROLL_PROBES): Define.\n+\t(allocate_stack_space): New function, partially extracted from\n+\ts390_emit_prologue.\n+\t(s390_emit_prologue): Track offset to most recent stack probe.\n+\tCode to allocate space moved into allocate_stack_space.\n+\tDump actions when no stack is allocated.\n+\t(s390_prologue_plus_offset): New function.\n+\t(s390_emit_stack_probe): Likewise.\n+\n 2017-09-20  Alexandre Oliva <aoliva@redhat.com>\n \n \t* common.opt (Wa, Wl, Wp, g, gz=): Add"}, {"sha": "037e22e737ec5e6255b8b7de98605b8460f73e72", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 234, "deletions": 26, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3347cd287bf89aca78ec030763792d86bb47fbc/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3347cd287bf89aca78ec030763792d86bb47fbc/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=d3347cd287bf89aca78ec030763792d86bb47fbc", "patch": "@@ -11155,6 +11155,183 @@ pass_s390_early_mach::execute (function *fun)\n \n } // anon namespace\n \n+/* Calculate TARGET = REG + OFFSET as s390_emit_prologue would do it.\n+   - push too big immediates to the literal pool and annotate the refs\n+   - emit frame related notes for stack pointer changes.  */\n+\n+static rtx\n+s390_prologue_plus_offset (rtx target, rtx reg, rtx offset, bool frame_related_p)\n+{\n+  rtx insn;\n+  rtx orig_offset = offset;\n+\n+  gcc_assert (REG_P (target));\n+  gcc_assert (REG_P (reg));\n+  gcc_assert (CONST_INT_P (offset));\n+\n+  if (offset == const0_rtx)                               /* lr/lgr */\n+    {\n+      insn = emit_move_insn (target, reg);\n+    }\n+  else if (DISP_IN_RANGE (INTVAL (offset)))               /* la */\n+    {\n+      insn = emit_move_insn (target, gen_rtx_PLUS (Pmode, reg,\n+\t\t\t\t\t\t   offset));\n+    }\n+  else\n+    {\n+      if (!satisfies_constraint_K (offset)                /* ahi/aghi */\n+\t  && (!TARGET_EXTIMM\n+\t      || (!satisfies_constraint_Op (offset)       /* alfi/algfi */\n+\t\t  && !satisfies_constraint_On (offset)))) /* slfi/slgfi */\n+\toffset = force_const_mem (Pmode, offset);\n+\n+      if (target != reg)\n+\t{\n+\t  insn = emit_move_insn (target, reg);\n+\t  RTX_FRAME_RELATED_P (insn) = frame_related_p ? 1 : 0;\n+\t}\n+\n+      insn = emit_insn (gen_add2_insn (target, offset));\n+\n+      if (!CONST_INT_P (offset))\n+\t{\n+\t  annotate_constant_pool_refs (&PATTERN (insn));\n+\n+\t  if (frame_related_p)\n+\t    add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t\t  gen_rtx_SET (target,\n+\t\t\t\t       gen_rtx_PLUS (Pmode, target,\n+\t\t\t\t\t\t     orig_offset)));\n+\t}\n+    }\n+\n+  RTX_FRAME_RELATED_P (insn) = frame_related_p ? 1 : 0;\n+\n+  /* If this is a stack adjustment and we are generating a stack clash\n+     prologue, then add a REG_STACK_CHECK note to signal that this insn\n+     should be left alone.  */\n+  if (flag_stack_clash_protection && target == stack_pointer_rtx)\n+    add_reg_note (insn, REG_STACK_CHECK, const0_rtx);\n+\n+  return insn;\n+}\n+\n+/* Emit a compare instruction with a volatile memory access as stack\n+   probe.  It does not waste store tags and does not clobber any\n+   registers apart from the condition code.  */\n+static void\n+s390_emit_stack_probe (rtx addr)\n+{\n+  rtx tmp = gen_rtx_MEM (Pmode, addr);\n+  MEM_VOLATILE_P (tmp) = 1;\n+  s390_emit_compare (EQ, gen_rtx_REG (Pmode, 0), tmp);\n+  emit_insn (gen_blockage ());\n+}\n+\n+/* Use a runtime loop if we have to emit more probes than this.  */\n+#define MIN_UNROLL_PROBES 3\n+\n+/* Allocate SIZE bytes of stack space, using TEMP_REG as a temporary\n+   if necessary.  LAST_PROBE_OFFSET contains the offset of the closest\n+   probe relative to the stack pointer.\n+\n+   Note that SIZE is negative.\n+\n+   The return value is true if TEMP_REG has been clobbered.  */\n+static bool\n+allocate_stack_space (rtx size, HOST_WIDE_INT last_probe_offset,\n+\t\t      rtx temp_reg)\n+{\n+  bool temp_reg_clobbered_p = false;\n+  HOST_WIDE_INT probe_interval\n+    = 1 << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_PROBE_INTERVAL);\n+  HOST_WIDE_INT guard_size\n+    = 1 << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE);\n+\n+  if (flag_stack_clash_protection)\n+    {\n+      if (last_probe_offset + -INTVAL (size) < guard_size)\n+\tdump_stack_clash_frame_info (NO_PROBE_SMALL_FRAME, true);\n+      else\n+\t{\n+\t  rtx offset = GEN_INT (probe_interval - UNITS_PER_LONG);\n+\t  HOST_WIDE_INT rounded_size = -INTVAL (size) & -probe_interval;\n+\t  HOST_WIDE_INT num_probes = rounded_size / probe_interval;\n+\t  HOST_WIDE_INT residual = -INTVAL (size) - rounded_size;\n+\n+\t  if (num_probes < MIN_UNROLL_PROBES)\n+\t    {\n+\t      /* Emit unrolled probe statements.  */\n+\n+\t      for (unsigned int i = 0; i < num_probes; i++)\n+\t\t{\n+\t\t  s390_prologue_plus_offset (stack_pointer_rtx,\n+\t\t\t\t\t     stack_pointer_rtx,\n+\t\t\t\t\t     GEN_INT (-probe_interval), true);\n+\t\t  s390_emit_stack_probe (gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t       stack_pointer_rtx,\n+\t\t\t\t\t\t       offset));\n+\t\t}\n+\t      dump_stack_clash_frame_info (PROBE_INLINE, residual != 0);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Emit a loop probing the pages.  */\n+\n+\t      rtx_code_label *loop_start_label = gen_label_rtx ();\n+\n+\t      /* From now on temp_reg will be the CFA register.  */\n+\t      s390_prologue_plus_offset (temp_reg, stack_pointer_rtx,\n+\t\t\t\t\t GEN_INT (-rounded_size), true);\n+\t      emit_label (loop_start_label);\n+\n+\t      s390_prologue_plus_offset (stack_pointer_rtx,\n+\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t GEN_INT (-probe_interval), false);\n+\t      s390_emit_stack_probe (gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t\t\t   offset));\n+\t      emit_cmp_and_jump_insns (stack_pointer_rtx, temp_reg,\n+\t\t\t\t       GT, NULL_RTX,\n+\t\t\t\t       Pmode, 1, loop_start_label);\n+\n+\t      /* Without this make_edges ICEes.  */\n+\t      JUMP_LABEL (get_last_insn ()) = loop_start_label;\n+\t      LABEL_NUSES (loop_start_label) = 1;\n+\n+\t      /* That's going to be a NOP since stack pointer and\n+\t\t temp_reg are supposed to be the same here.  We just\n+\t\t emit it to set the CFA reg back to r15.  */\n+\t      s390_prologue_plus_offset (stack_pointer_rtx, temp_reg,\n+\t\t\t\t\t const0_rtx, true);\n+\t      temp_reg_clobbered_p = true;\n+\t      dump_stack_clash_frame_info (PROBE_LOOP, residual != 0);\n+\t    }\n+\n+\t  /* Handle any residual allocation request.  */\n+\t  s390_prologue_plus_offset (stack_pointer_rtx,\n+\t\t\t\t     stack_pointer_rtx,\n+\t\t\t\t     GEN_INT (-residual), true);\n+\t  last_probe_offset += residual;\n+\t  if (last_probe_offset >= probe_interval)\n+\t    s390_emit_stack_probe (gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t\t GEN_INT (residual\n+\t\t\t\t\t\t\t  - UNITS_PER_LONG)));\n+\n+\t  return temp_reg_clobbered_p;\n+\t}\n+    }\n+\n+  /* Subtract frame size from stack pointer.  */\n+  s390_prologue_plus_offset (stack_pointer_rtx,\n+\t\t\t     stack_pointer_rtx,\n+\t\t\t     size, true);\n+\n+  return temp_reg_clobbered_p;\n+}\n+\n /* Expand the prologue into a bunch of separate insns.  */\n \n void\n@@ -11179,6 +11356,19 @@ s390_emit_prologue (void)\n   else\n     temp_reg = gen_rtx_REG (Pmode, 1);\n \n+  /* When probing for stack-clash mitigation, we have to track the distance\n+     between the stack pointer and closest known reference.\n+\n+     Most of the time we have to make a worst cast assumption.  The\n+     only exception is when TARGET_BACKCHAIN is active, in which case\n+     we know *sp (offset 0) was written.  */\n+  HOST_WIDE_INT probe_interval\n+    = 1 << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_PROBE_INTERVAL);\n+  HOST_WIDE_INT last_probe_offset\n+    = (TARGET_BACKCHAIN\n+       ? (TARGET_PACKED_STACK ? STACK_POINTER_OFFSET - UNITS_PER_LONG : 0)\n+       : probe_interval - (STACK_BOUNDARY / UNITS_PER_WORD));\n+\n   s390_save_gprs_to_fprs ();\n \n   /* Save call saved gprs.  */\n@@ -11190,6 +11380,14 @@ s390_emit_prologue (void)\n \t\t\t\t\t  - cfun_frame_layout.first_save_gpr_slot),\n \t\t\tcfun_frame_layout.first_save_gpr,\n \t\t\tcfun_frame_layout.last_save_gpr);\n+\n+      /* This is not 100% correct.  If we have more than one register saved,\n+\t then LAST_PROBE_OFFSET can move even closer to sp.  */\n+      last_probe_offset\n+\t= (cfun_frame_layout.gprs_offset +\n+\t   UNITS_PER_LONG * (cfun_frame_layout.first_save_gpr\n+\t\t\t     - cfun_frame_layout.first_save_gpr_slot));\n+\n       emit_insn (insn);\n     }\n \n@@ -11206,6 +11404,8 @@ s390_emit_prologue (void)\n       if (cfun_fpr_save_p (i))\n \t{\n \t  save_fpr (stack_pointer_rtx, offset, i);\n+\t  if (offset < last_probe_offset)\n+\t    last_probe_offset = offset;\n \t  offset += 8;\n \t}\n       else if (!TARGET_PACKED_STACK || cfun->stdarg)\n@@ -11219,6 +11419,8 @@ s390_emit_prologue (void)\n       if (cfun_fpr_save_p (i))\n \t{\n \t  insn = save_fpr (stack_pointer_rtx, offset, i);\n+\t  if (offset < last_probe_offset)\n+\t    last_probe_offset = offset;\n \t  offset += 8;\n \n \t  /* If f4 and f6 are call clobbered they are saved due to\n@@ -11241,6 +11443,8 @@ s390_emit_prologue (void)\n \tif (cfun_fpr_save_p (i))\n \t  {\n \t    insn = save_fpr (stack_pointer_rtx, offset, i);\n+\t    if (offset < last_probe_offset)\n+\t      last_probe_offset = offset;\n \n \t    RTX_FRAME_RELATED_P (insn) = 1;\n \t    offset -= 8;\n@@ -11260,10 +11464,11 @@ s390_emit_prologue (void)\n   if (cfun_frame_layout.frame_size > 0)\n     {\n       rtx frame_off = GEN_INT (-cfun_frame_layout.frame_size);\n-      rtx real_frame_off;\n+      rtx_insn *stack_pointer_backup_loc;\n+      bool temp_reg_clobbered_p;\n \n       if (s390_stack_size)\n-  \t{\n+\t{\n \t  HOST_WIDE_INT stack_guard;\n \n \t  if (s390_stack_guard)\n@@ -11329,35 +11534,36 @@ s390_emit_prologue (void)\n       if (s390_warn_dynamicstack_p && cfun->calls_alloca)\n \twarning (0, \"%qs uses dynamic stack allocation\", current_function_name ());\n \n-      /* Save incoming stack pointer into temp reg.  */\n-      if (TARGET_BACKCHAIN || next_fpr)\n-\tinsn = emit_insn (gen_move_insn (temp_reg, stack_pointer_rtx));\n+      /* Save the location where we could backup the incoming stack\n+\t pointer.  */\n+      stack_pointer_backup_loc = get_last_insn ();\n \n-      /* Subtract frame size from stack pointer.  */\n+      temp_reg_clobbered_p = allocate_stack_space (frame_off, last_probe_offset,\n+\t\t\t\t\t\t   temp_reg);\n \n-      if (DISP_IN_RANGE (INTVAL (frame_off)))\n-\t{\n-\t  insn = gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t      gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t    frame_off));\n-\t  insn = emit_insn (insn);\n-\t}\n-      else\n+      if (TARGET_BACKCHAIN || next_fpr)\n \t{\n-\t  if (!CONST_OK_FOR_K (INTVAL (frame_off)))\n-\t    frame_off = force_const_mem (Pmode, frame_off);\n-\n-          insn = emit_insn (gen_add2_insn (stack_pointer_rtx, frame_off));\n-\t  annotate_constant_pool_refs (&PATTERN (insn));\n+\t  if (temp_reg_clobbered_p)\n+\t    {\n+\t      /* allocate_stack_space had to make use of temp_reg and\n+\t\t we need it to hold a backup of the incoming stack\n+\t\t pointer.  Calculate back that value from the current\n+\t\t stack pointer.  */\n+\t      s390_prologue_plus_offset (temp_reg, stack_pointer_rtx,\n+\t\t\t\t\t GEN_INT (cfun_frame_layout.frame_size),\n+\t\t\t\t\t false);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* allocate_stack_space didn't actually required\n+\t\t temp_reg.  Insert the stack pointer backup insn\n+\t\t before the stack pointer decrement code - knowing now\n+\t\t that the value will survive.  */\n+\t      emit_insn_after (gen_move_insn (temp_reg, stack_pointer_rtx),\n+\t\t\t       stack_pointer_backup_loc);\n+\t    }\n \t}\n \n-      RTX_FRAME_RELATED_P (insn) = 1;\n-      real_frame_off = GEN_INT (-cfun_frame_layout.frame_size);\n-      add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n-\t\t    gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t\t gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t       real_frame_off)));\n-\n       /* Set backchain.  */\n \n       if (TARGET_BACKCHAIN)\n@@ -11381,6 +11587,8 @@ s390_emit_prologue (void)\n \t  emit_clobber (addr);\n \t}\n     }\n+  else if (flag_stack_clash_protection)\n+    dump_stack_clash_frame_info (NO_PROBE_NO_FRAME, false);\n \n   /* Save fprs 8 - 15 (64 bit ABI).  */\n "}, {"sha": "75c14d5b04543111496e7939c7d5114282457b6c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3347cd287bf89aca78ec030763792d86bb47fbc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3347cd287bf89aca78ec030763792d86bb47fbc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d3347cd287bf89aca78ec030763792d86bb47fbc", "patch": "@@ -1,3 +1,11 @@\n+2017-09-20  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\t    Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/stack-check-5.c:  Add argument for s390.\n+\t* lib/target-supports.exp: \n+\t(check_effective_target_supports_stack_clash_protection): Enable for\n+\ts390/s390x targets.\n+\n 2017-09-20  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/81854"}, {"sha": "3178f5d8ce54ca1d1069d72500401b905e0adc8b", "filename": "gcc/testsuite/gcc.dg/stack-check-5.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3347cd287bf89aca78ec030763792d86bb47fbc/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-check-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3347cd287bf89aca78ec030763792d86bb47fbc/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-check-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-check-5.c?ref=d3347cd287bf89aca78ec030763792d86bb47fbc", "patch": "@@ -3,6 +3,10 @@\n /* { dg-require-effective-target supports_stack_clash_protection } */\n \n \n+/* Otherwise the S/390 back-end might save the stack pointer in f2 ()\n+   into an FPR.  */\n+/* { dg-additional-options \"-msoft-float\" { target { s390x-*-* } } } */\n+\n extern void foo (char *);\n extern void bar (void);\n "}, {"sha": "2e0e4d43bfad5b41693539f10425c53e7c418a8f", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3347cd287bf89aca78ec030763792d86bb47fbc/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3347cd287bf89aca78ec030763792d86bb47fbc/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=d3347cd287bf89aca78ec030763792d86bb47fbc", "patch": "@@ -8640,12 +8640,12 @@ proc check_effective_target_supports_stack_clash_protection { } {\n \n    # Temporary until the target bits are fully ACK'd.\n #  if { [istarget aarch*-*-*]\n-#       || [istarget s390*-*-*]\n #       || [istarget powerpc*-*-*] || [istarget rs6000*-*-*] } {\n #\treturn 1\n #  }\n \n-    if { [istarget x86_64-*-*] || [istarget i?86-*-*] } {\n+    if { [istarget x86_64-*-*] || [istarget i?86-*-*] \n+\t  || [istarget s390*-*-*] } {\n \treturn 1\n     }\n   return 0"}]}