{"sha": "3c1ab1ab837e235a763d858cbd18e7fac16f3bc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2MxYWIxYWI4MzdlMjM1YTc2M2Q4NThjYmQxOGU3ZmFjMTZmM2JjNw==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2013-08-17T20:31:02Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2013-08-17T20:31:02Z"}, "message": "error.c (dump_scope): Add a cxx_pretty_printer parameter.\n\n\t* error.c (dump_scope): Add a cxx_pretty_printer parameter.\n\tAdjust callers.\n\t(dump_template_argument): Likewise.\n\t(dump_template_argument_list): Likewise.\n\t(dump_template_parameter): Likewise.\n\t(dump_template_bindings): Likewise.\n\t(dump_alias_template_specialization): Likewise.\n\t(dump_type): Likewise.\n\t(dump_typename): Likewise.\n\t(dump_aggr_type): Likewise.\n\t(dump_type_prefix): Likewise.\n\t(dump_type_suffix): Likewise.\n\t(dump_global_iord): Likewise.\n\t(dump_simple_decl): Likewise.\n\t(dump_decl): Likewise.\n\t(dump_template_decl): Likewise.\n\t(dump_function_decl): Likewise.\n\t(dump_parameters): Likewise.\n\t(dump_ref_qualifier): Likewise.\n\t(dump_exception_spec): Likewise.\n\t(dump_function_name): Likewise.\n\t(dump_template_parms): Likewise.\n\t(dump_call_expr_args): Likewise.\n\t(dump_aggr_init_expr_args): Likewise.\n\t(dump_expr_list): Likewise.\n\t(dump_expr_init_vec): Likewise.\n\t(dump_expr): Likewise.\n\t(dump_binary_op): Likewise.\n\t(dump_unary_op): Likewise.\n\nFrom-SVN: r201818", "tree": {"sha": "3063c92c7230f167d748c91f25f3bb6215d84960", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3063c92c7230f167d748c91f25f3bb6215d84960"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c1ab1ab837e235a763d858cbd18e7fac16f3bc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c1ab1ab837e235a763d858cbd18e7fac16f3bc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c1ab1ab837e235a763d858cbd18e7fac16f3bc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c1ab1ab837e235a763d858cbd18e7fac16f3bc7/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5945bebf44217c25eb47124b66823df7f1ddcb3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5945bebf44217c25eb47124b66823df7f1ddcb3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5945bebf44217c25eb47124b66823df7f1ddcb3d"}], "stats": {"total": 1302, "additions": 673, "deletions": 629}, "files": [{"sha": "7ada1ae4f64244123723e66d568aaabb3ad67711", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c1ab1ab837e235a763d858cbd18e7fac16f3bc7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c1ab1ab837e235a763d858cbd18e7fac16f3bc7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3c1ab1ab837e235a763d858cbd18e7fac16f3bc7", "patch": "@@ -1,3 +1,35 @@\n+2013-08-17  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* error.c (dump_scope): Add a cxx_pretty_printer parameter.\n+\tAdjust callers.\n+\t(dump_template_argument): Likewise.\n+\t(dump_template_argument_list): Likewise.\n+\t(dump_template_parameter): Likewise.\n+\t(dump_template_bindings): Likewise.\n+\t(dump_alias_template_specialization): Likewise.\n+\t(dump_type): Likewise.\n+\t(dump_typename): Likewise.\n+\t(dump_aggr_type): Likewise.\n+\t(dump_type_prefix): Likewise.\n+\t(dump_type_suffix): Likewise.\n+\t(dump_global_iord): Likewise.\n+\t(dump_simple_decl): Likewise.\n+\t(dump_decl): Likewise.\n+\t(dump_template_decl): Likewise.\n+\t(dump_function_decl): Likewise.\n+\t(dump_parameters): Likewise.\n+\t(dump_ref_qualifier): Likewise.\n+\t(dump_exception_spec): Likewise.\n+\t(dump_function_name): Likewise.\n+\t(dump_template_parms): Likewise.\n+\t(dump_call_expr_args): Likewise.\n+\t(dump_aggr_init_expr_args): Likewise.\n+\t(dump_expr_list): Likewise.\n+\t(dump_expr_init_vec): Likewise.\n+\t(dump_expr): Likewise.\n+\t(dump_binary_op): Likewise.\n+\t(dump_unary_op): Likewise.\n+\n 2013-08-14  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/51912"}, {"sha": "5741b1755da99176cfccbfff6779fe56efcacff5", "filename": "gcc/cp/error.c", "status": "modified", "additions": 641, "deletions": 629, "changes": 1270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c1ab1ab837e235a763d858cbd18e7fac16f3bc7/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c1ab1ab837e235a763d858cbd18e7fac16f3bc7/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=3c1ab1ab837e235a763d858cbd18e7fac16f3bc7", "patch": "@@ -59,33 +59,34 @@ static const char *op_to_string\t(enum tree_code);\n static const char *parm_to_string (int);\n static const char *type_to_string (tree, int);\n \n-static void dump_alias_template_specialization (tree, int);\n-static void dump_type (tree, int);\n-static void dump_typename (tree, int);\n-static void dump_simple_decl (tree, tree, int);\n-static void dump_decl (tree, int);\n-static void dump_template_decl (tree, int);\n-static void dump_function_decl (tree, int);\n-static void dump_expr (tree, int);\n-static void dump_unary_op (const char *, tree, int);\n-static void dump_binary_op (const char *, tree, int);\n-static void dump_aggr_type (tree, int);\n-static void dump_type_prefix (tree, int);\n-static void dump_type_suffix (tree, int);\n-static void dump_function_name (tree, int);\n-static void dump_call_expr_args (tree, int, bool);\n-static void dump_aggr_init_expr_args (tree, int, bool);\n-static void dump_expr_list (tree, int);\n-static void dump_global_iord (tree);\n-static void dump_parameters (tree, int);\n-static void dump_ref_qualifier (tree, int);\n-static void dump_exception_spec (tree, int);\n-static void dump_template_argument (tree, int);\n-static void dump_template_argument_list (tree, int);\n-static void dump_template_parameter (tree, int);\n-static void dump_template_bindings (tree, tree, vec<tree, va_gc> *);\n-static void dump_scope (tree, int);\n-static void dump_template_parms (tree, int, int);\n+static void dump_alias_template_specialization (cxx_pretty_printer *, tree, int);\n+static void dump_type (cxx_pretty_printer *, tree, int);\n+static void dump_typename (cxx_pretty_printer *, tree, int);\n+static void dump_simple_decl (cxx_pretty_printer *, tree, tree, int);\n+static void dump_decl (cxx_pretty_printer *, tree, int);\n+static void dump_template_decl (cxx_pretty_printer *, tree, int);\n+static void dump_function_decl (cxx_pretty_printer *, tree, int);\n+static void dump_expr (cxx_pretty_printer *, tree, int);\n+static void dump_unary_op (cxx_pretty_printer *, const char *, tree, int);\n+static void dump_binary_op (cxx_pretty_printer *, const char *, tree, int);\n+static void dump_aggr_type (cxx_pretty_printer *, tree, int);\n+static void dump_type_prefix (cxx_pretty_printer *, tree, int);\n+static void dump_type_suffix (cxx_pretty_printer *, tree, int);\n+static void dump_function_name (cxx_pretty_printer *, tree, int);\n+static void dump_call_expr_args (cxx_pretty_printer *, tree, int, bool);\n+static void dump_aggr_init_expr_args (cxx_pretty_printer *, tree, int, bool);\n+static void dump_expr_list (cxx_pretty_printer *, tree, int);\n+static void dump_global_iord (cxx_pretty_printer *, tree);\n+static void dump_parameters (cxx_pretty_printer *, tree, int);\n+static void dump_ref_qualifier (cxx_pretty_printer *, tree, int);\n+static void dump_exception_spec (cxx_pretty_printer *, tree, int);\n+static void dump_template_argument (cxx_pretty_printer *, tree, int);\n+static void dump_template_argument_list (cxx_pretty_printer *, tree, int);\n+static void dump_template_parameter (cxx_pretty_printer *, tree, int);\n+static void dump_template_bindings (cxx_pretty_printer *, tree, tree,\n+                                    vec<tree, va_gc> *);\n+static void dump_scope (cxx_pretty_printer *, tree, int);\n+static void dump_template_parms (cxx_pretty_printer *, tree, int, int);\n static int get_non_default_template_args_count (tree, int);\n static const char *function_category (tree);\n static void maybe_print_constexpr_context (diagnostic_context *);\n@@ -115,7 +116,7 @@ init_error (void)\n /* Dump a scope, if deemed necessary.  */\n \n static void\n-dump_scope (tree scope, int flags)\n+dump_scope (cxx_pretty_printer *pp, tree scope, int flags)\n {\n   int f = flags & (TFF_SCOPE | TFF_CHASE_TYPEDEF);\n \n@@ -126,39 +127,39 @@ dump_scope (tree scope, int flags)\n     {\n       if (scope != global_namespace)\n \t{\n-\t  dump_decl (scope, f);\n-\t  pp_cxx_colon_colon (cxx_pp);\n+          dump_decl (pp, scope, f);\n+\t  pp_cxx_colon_colon (pp);\n \t}\n     }\n   else if (AGGREGATE_TYPE_P (scope))\n     {\n-      dump_type (scope, f);\n-      pp_cxx_colon_colon (cxx_pp);\n+      dump_type (pp, scope, f);\n+      pp_cxx_colon_colon (pp);\n     }\n   else if ((flags & TFF_SCOPE) && TREE_CODE (scope) == FUNCTION_DECL)\n     {\n-      dump_function_decl (scope, f);\n-      pp_cxx_colon_colon (cxx_pp);\n+      dump_function_decl (pp, scope, f);\n+      pp_cxx_colon_colon (pp);\n     }\n }\n \n /* Dump the template ARGument under control of FLAGS.  */\n \n static void\n-dump_template_argument (tree arg, int flags)\n+dump_template_argument (cxx_pretty_printer *pp, tree arg, int flags)\n {\n   if (ARGUMENT_PACK_P (arg))\n-    dump_template_argument_list (ARGUMENT_PACK_ARGS (arg),\n+    dump_template_argument_list (pp, ARGUMENT_PACK_ARGS (arg),\n \t\t\t\t /* No default args in argument packs.  */\n \t\t\t\t flags|TFF_NO_OMIT_DEFAULT_TEMPLATE_ARGUMENTS);\n   else if (TYPE_P (arg) || TREE_CODE (arg) == TEMPLATE_DECL)\n-    dump_type (arg, flags & ~TFF_CLASS_KEY_OR_ENUM);\n+    dump_type (pp, arg, flags & ~TFF_CLASS_KEY_OR_ENUM);\n   else\n     {\n       if (TREE_CODE (arg) == TREE_LIST)\n \targ = TREE_VALUE (arg);\n \n-      dump_expr (arg, (flags | TFF_EXPR_IN_PARENS) & ~TFF_CLASS_KEY_OR_ENUM);\n+      dump_expr (pp, arg, (flags | TFF_EXPR_IN_PARENS) & ~TFF_CLASS_KEY_OR_ENUM);\n     }\n }\n \n@@ -186,7 +187,7 @@ get_non_default_template_args_count (tree args, int flags)\n    of FLAGS.  */\n \n static void\n-dump_template_argument_list (tree args, int flags)\n+dump_template_argument_list (cxx_pretty_printer *pp, tree args, int flags)\n {\n   int n = get_non_default_template_args_count (args, flags);\n   int need_comma = 0;\n@@ -202,17 +203,17 @@ dump_template_argument_list (tree args, int flags)\n       if (need_comma\n           && (!ARGUMENT_PACK_P (arg)\n               || TREE_VEC_LENGTH (ARGUMENT_PACK_ARGS (arg)) > 0))\n-\tpp_separate_with_comma (cxx_pp);\n+\tpp_separate_with_comma (pp);\n \n-      dump_template_argument (arg, flags);\n+      dump_template_argument (pp, arg, flags);\n       need_comma = 1;\n     }\n }\n \n /* Dump a template parameter PARM (a TREE_LIST) under control of FLAGS.  */\n \n static void\n-dump_template_parameter (tree parm, int flags)\n+dump_template_parameter (cxx_pretty_printer *pp, tree parm, int flags)\n {\n   tree p;\n   tree a;\n@@ -227,29 +228,29 @@ dump_template_parameter (tree parm, int flags)\n     {\n       if (flags & TFF_DECL_SPECIFIERS)\n \t{\n-\t  pp_cxx_ws_string (cxx_pp, \"class\");\n+\t  pp_cxx_ws_string (pp, \"class\");\n           if (TEMPLATE_TYPE_PARAMETER_PACK (TREE_TYPE (p)))\n-            pp_cxx_ws_string (cxx_pp, \"...\");\n+            pp_cxx_ws_string (pp, \"...\");\n \t  if (DECL_NAME (p))\n-\t    pp_cxx_tree_identifier (cxx_pp, DECL_NAME (p));\n+\t    pp_cxx_tree_identifier (pp, DECL_NAME (p));\n \t}\n       else if (DECL_NAME (p))\n-\tpp_cxx_tree_identifier (cxx_pp, DECL_NAME (p));\n+\tpp_cxx_tree_identifier (pp, DECL_NAME (p));\n       else\n-\tpp_cxx_canonical_template_parameter (cxx_pp, TREE_TYPE (p));\n+\tpp_cxx_canonical_template_parameter (pp, TREE_TYPE (p));\n     }\n   else\n-    dump_decl (p, flags | TFF_DECL_SPECIFIERS);\n+    dump_decl (pp, p, flags | TFF_DECL_SPECIFIERS);\n \n   if ((flags & TFF_FUNCTION_DEFAULT_ARGUMENTS) && a != NULL_TREE)\n     {\n-      pp_cxx_whitespace (cxx_pp);\n-      pp_equal (cxx_pp);\n-      pp_cxx_whitespace (cxx_pp);\n+      pp_cxx_whitespace (pp);\n+      pp_equal (pp);\n+      pp_cxx_whitespace (pp);\n       if (TREE_CODE (p) == TYPE_DECL || TREE_CODE (p) == TEMPLATE_DECL)\n-\tdump_type (a, flags & ~TFF_CHASE_TYPEDEF);\n+\tdump_type (pp, a, flags & ~TFF_CHASE_TYPEDEF);\n       else\n-\tdump_expr (a, flags | TFF_EXPR_IN_PARENS);\n+\tdump_expr (pp, a, flags | TFF_EXPR_IN_PARENS);\n     }\n }\n \n@@ -258,7 +259,8 @@ dump_template_parameter (tree parm, int flags)\n    TREE_VEC.  */\n \n static void\n-dump_template_bindings (tree parms, tree args, vec<tree, va_gc> *typenames)\n+dump_template_bindings (cxx_pretty_printer *pp, tree parms, tree args,\n+                        vec<tree, va_gc> *typenames)\n {\n   bool need_semicolon = false;\n   int i;\n@@ -285,21 +287,22 @@ dump_template_bindings (tree parms, tree args, vec<tree, va_gc> *typenames)\n \t    arg = TREE_VEC_ELT (lvl_args, arg_idx);\n \n \t  if (need_semicolon)\n-\t    pp_separate_with_semicolon (cxx_pp);\n-\t  dump_template_parameter (TREE_VEC_ELT (p, i), TFF_PLAIN_IDENTIFIER);\n-\t  pp_cxx_whitespace (cxx_pp);\n-\t  pp_equal (cxx_pp);\n-\t  pp_cxx_whitespace (cxx_pp);\n+\t    pp_separate_with_semicolon (pp);\n+\t  dump_template_parameter (pp, TREE_VEC_ELT (p, i),\n+                                   TFF_PLAIN_IDENTIFIER);\n+\t  pp_cxx_whitespace (pp);\n+\t  pp_equal (pp);\n+\t  pp_cxx_whitespace (pp);\n \t  if (arg)\n \t    {\n \t      if (ARGUMENT_PACK_P (arg))\n-\t\tpp_cxx_left_brace (cxx_pp);\n-\t      dump_template_argument (arg, TFF_PLAIN_IDENTIFIER);\n+\t\tpp_cxx_left_brace (pp);\n+\t      dump_template_argument (pp, arg, TFF_PLAIN_IDENTIFIER);\n \t      if (ARGUMENT_PACK_P (arg))\n-\t\tpp_cxx_right_brace (cxx_pp);\n+\t\tpp_cxx_right_brace (pp);\n \t    }\n \t  else\n-\t    pp_string (cxx_pp, M_(\"<missing>\"));\n+\t    pp_string (pp, M_(\"<missing>\"));\n \n \t  ++arg_idx;\n \t  need_semicolon = true;\n@@ -315,36 +318,36 @@ dump_template_bindings (tree parms, tree args, vec<tree, va_gc> *typenames)\n   FOR_EACH_VEC_SAFE_ELT (typenames, i, t)\n     {\n       if (need_semicolon)\n-\tpp_separate_with_semicolon (cxx_pp);\n-      dump_type (t, TFF_PLAIN_IDENTIFIER);\n-      pp_cxx_whitespace (cxx_pp);\n-      pp_equal (cxx_pp);\n-      pp_cxx_whitespace (cxx_pp);\n+\tpp_separate_with_semicolon (pp);\n+      dump_type (pp, t, TFF_PLAIN_IDENTIFIER);\n+      pp_cxx_whitespace (pp);\n+      pp_equal (pp);\n+      pp_cxx_whitespace (pp);\n       push_deferring_access_checks (dk_no_check);\n       t = tsubst (t, args, tf_none, NULL_TREE);\n       pop_deferring_access_checks ();\n       /* Strip typedefs.  We can't just use TFF_CHASE_TYPEDEF because\n \t pp_simple_type_specifier doesn't know about it.  */\n       t = strip_typedefs (t);\n-      dump_type (t, TFF_PLAIN_IDENTIFIER);\n+      dump_type (pp, t, TFF_PLAIN_IDENTIFIER);\n     }\n }\n \n /* Dump a human-readable equivalent of the alias template\n    specialization of T.  */\n \n static void\n-dump_alias_template_specialization (tree t, int flags)\n+dump_alias_template_specialization (cxx_pretty_printer *pp, tree t, int flags)\n {\n   tree name;\n \n   gcc_assert (alias_template_specialization_p (t));\n \n   if (!(flags & TFF_UNQUALIFIED_NAME))\n-    dump_scope (CP_DECL_CONTEXT (TYPE_NAME (t)), flags);\n+    dump_scope (pp, CP_DECL_CONTEXT (TYPE_NAME (t)), flags);\n   name = TYPE_IDENTIFIER (t);\n-  pp_cxx_tree_identifier (cxx_pp, name);\n-  dump_template_parms (TYPE_TEMPLATE_INFO (t),\n+  pp_cxx_tree_identifier (pp, name);\n+  dump_template_parms (pp, TYPE_TEMPLATE_INFO (t),\n \t\t       /*primary=*/false,\n \t\t       flags & ~TFF_TEMPLATE_HEADER);\n }\n@@ -353,7 +356,7 @@ dump_alias_template_specialization (tree t, int flags)\n    format.  */\n \n static void\n-dump_type (tree t, int flags)\n+dump_type (cxx_pretty_printer *pp, tree t, int flags)\n {\n   if (t == NULL_TREE)\n     return;\n@@ -369,15 +372,15 @@ dump_type (tree t, int flags)\n \tt = strip_typedefs (t);\n       else if (alias_template_specialization_p (t))\n \t{\n-\t  dump_alias_template_specialization (t, flags);\n+\t  dump_alias_template_specialization (pp, t, flags);\n \t  return;\n \t}\n       else if (same_type_p (t, TREE_TYPE (decl)))\n \tt = decl;\n       else\n \t{\n-\t  pp_cxx_cv_qualifier_seq (cxx_pp, t);\n-\t  pp_cxx_tree_identifier (cxx_pp, TYPE_IDENTIFIER (t));\n+\t  pp_cxx_cv_qualifier_seq (pp, t);\n+\t  pp_cxx_tree_identifier (pp, TYPE_IDENTIFIER (t));\n \t  return;\n \t}\n     }\n@@ -389,47 +392,47 @@ dump_type (tree t, int flags)\n     {\n     case LANG_TYPE:\n       if (t == init_list_type_node)\n-\tpp_string (cxx_pp, M_(\"<brace-enclosed initializer list>\"));\n+\tpp_string (pp, M_(\"<brace-enclosed initializer list>\"));\n       else if (t == unknown_type_node)\n-\tpp_string (cxx_pp, M_(\"<unresolved overloaded function type>\"));\n+\tpp_string (pp, M_(\"<unresolved overloaded function type>\"));\n       else\n \t{\n-\t  pp_cxx_cv_qualifier_seq (cxx_pp, t);\n-\t  pp_cxx_tree_identifier (cxx_pp, TYPE_IDENTIFIER (t));\n+\t  pp_cxx_cv_qualifier_seq (pp, t);\n+\t  pp_cxx_tree_identifier (pp, TYPE_IDENTIFIER (t));\n \t}\n       break;\n \n     case TREE_LIST:\n       /* A list of function parms.  */\n-      dump_parameters (t, flags);\n+      dump_parameters (pp, t, flags);\n       break;\n \n     case IDENTIFIER_NODE:\n-      pp_cxx_tree_identifier (cxx_pp, t);\n+      pp_cxx_tree_identifier (pp, t);\n       break;\n \n     case TREE_BINFO:\n-      dump_type (BINFO_TYPE (t), flags);\n+      dump_type (pp, BINFO_TYPE (t), flags);\n       break;\n \n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case ENUMERAL_TYPE:\n-      dump_aggr_type (t, flags);\n+      dump_aggr_type (pp, t, flags);\n       break;\n \n     case TYPE_DECL:\n       if (flags & TFF_CHASE_TYPEDEF)\n \t{\n-\t  dump_type (DECL_ORIGINAL_TYPE (t)\n+\t  dump_type (pp, DECL_ORIGINAL_TYPE (t)\n \t\t     ? DECL_ORIGINAL_TYPE (t) : TREE_TYPE (t), flags);\n \t  break;\n \t}\n       /* Else fall through.  */\n \n     case TEMPLATE_DECL:\n     case NAMESPACE_DECL:\n-      dump_decl (t, flags & ~TFF_DECL_SPECIFIERS);\n+      dump_decl (pp, t, flags & ~TFF_DECL_SPECIFIERS);\n       break;\n \n     case INTEGER_TYPE:\n@@ -439,35 +442,35 @@ dump_type (tree t, int flags)\n     case COMPLEX_TYPE:\n     case VECTOR_TYPE:\n     case FIXED_POINT_TYPE:\n-      pp_type_specifier_seq (cxx_pp, t);\n+      pp_type_specifier_seq (pp, t);\n       break;\n \n     case TEMPLATE_TEMPLATE_PARM:\n       /* For parameters inside template signature.  */\n       if (TYPE_IDENTIFIER (t))\n-\tpp_cxx_tree_identifier (cxx_pp, TYPE_IDENTIFIER (t));\n+\tpp_cxx_tree_identifier (pp, TYPE_IDENTIFIER (t));\n       else\n-\tpp_cxx_canonical_template_parameter (cxx_pp, t);\n+\tpp_cxx_canonical_template_parameter (pp, t);\n       break;\n \n     case BOUND_TEMPLATE_TEMPLATE_PARM:\n       {\n \ttree args = TYPE_TI_ARGS (t);\n-\tpp_cxx_cv_qualifier_seq (cxx_pp, t);\n-\tpp_cxx_tree_identifier (cxx_pp, TYPE_IDENTIFIER (t));\n-\tpp_cxx_begin_template_argument_list (cxx_pp);\n-\tdump_template_argument_list (args, flags);\n-\tpp_cxx_end_template_argument_list (cxx_pp);\n+\tpp_cxx_cv_qualifier_seq (pp, t);\n+\tpp_cxx_tree_identifier (pp, TYPE_IDENTIFIER (t));\n+\tpp_cxx_begin_template_argument_list (pp);\n+\tdump_template_argument_list (pp, args, flags);\n+\tpp_cxx_end_template_argument_list (pp);\n       }\n       break;\n \n     case TEMPLATE_TYPE_PARM:\n-      pp_cxx_cv_qualifier_seq (cxx_pp, t);\n+      pp_cxx_cv_qualifier_seq (pp, t);\n       if (TYPE_IDENTIFIER (t))\n-\tpp_cxx_tree_identifier (cxx_pp, TYPE_IDENTIFIER (t));\n+\tpp_cxx_tree_identifier (pp, TYPE_IDENTIFIER (t));\n       else\n \tpp_cxx_canonical_template_parameter\n-\t  (cxx_pp, TEMPLATE_TYPE_PARM_INDEX (t));\n+\t  (pp, TEMPLATE_TYPE_PARM_INDEX (t));\n       break;\n \n       /* This is not always necessary for pointers and such, but doing this\n@@ -480,78 +483,78 @@ dump_type (tree t, int flags)\n     case FUNCTION_TYPE:\n     case METHOD_TYPE:\n     {\n-      dump_type_prefix (t, flags);\n-      dump_type_suffix (t, flags);\n+      dump_type_prefix (pp, t, flags);\n+      dump_type_suffix (pp, t, flags);\n       break;\n     }\n     case TYPENAME_TYPE:\n       if (! (flags & TFF_CHASE_TYPEDEF)\n \t  && DECL_ORIGINAL_TYPE (TYPE_NAME (t)))\n \t{\n-\t  dump_decl (TYPE_NAME (t), TFF_PLAIN_IDENTIFIER);\n+\t  dump_decl (pp, TYPE_NAME (t), TFF_PLAIN_IDENTIFIER);\n \t  break;\n \t}\n-      pp_cxx_cv_qualifier_seq (cxx_pp, t);\n-      pp_cxx_ws_string (cxx_pp,\n+      pp_cxx_cv_qualifier_seq (pp, t);\n+      pp_cxx_ws_string (pp,\n \t\t\t TYPENAME_IS_ENUM_P (t) ? \"enum\"\n \t\t\t : TYPENAME_IS_CLASS_P (t) ? \"class\"\n \t\t\t : \"typename\");\n-      dump_typename (t, flags);\n+      dump_typename (pp, t, flags);\n       break;\n \n     case UNBOUND_CLASS_TEMPLATE:\n       if (! (flags & TFF_UNQUALIFIED_NAME))\n \t{\n-\t  dump_type (TYPE_CONTEXT (t), flags);\n-\t  pp_cxx_colon_colon (cxx_pp);\n+\t  dump_type (pp, TYPE_CONTEXT (t), flags);\n+\t  pp_cxx_colon_colon (pp);\n \t}\n-      pp_cxx_ws_string (cxx_pp, \"template\");\n-      dump_type (DECL_NAME (TYPE_NAME (t)), flags);\n+      pp_cxx_ws_string (pp, \"template\");\n+      dump_type (pp, DECL_NAME (TYPE_NAME (t)), flags);\n       break;\n \n     case TYPEOF_TYPE:\n-      pp_cxx_ws_string (cxx_pp, \"__typeof__\");\n-      pp_cxx_whitespace (cxx_pp);\n-      pp_cxx_left_paren (cxx_pp);\n-      dump_expr (TYPEOF_TYPE_EXPR (t), flags & ~TFF_EXPR_IN_PARENS);\n-      pp_cxx_right_paren (cxx_pp);\n+      pp_cxx_ws_string (pp, \"__typeof__\");\n+      pp_cxx_whitespace (pp);\n+      pp_cxx_left_paren (pp);\n+      dump_expr (pp, TYPEOF_TYPE_EXPR (t), flags & ~TFF_EXPR_IN_PARENS);\n+      pp_cxx_right_paren (pp);\n       break;\n \n     case UNDERLYING_TYPE:\n-      pp_cxx_ws_string (cxx_pp, \"__underlying_type\");\n-      pp_cxx_whitespace (cxx_pp);\n-      pp_cxx_left_paren (cxx_pp);\n-      dump_expr (UNDERLYING_TYPE_TYPE (t), flags & ~TFF_EXPR_IN_PARENS);\n-      pp_cxx_right_paren (cxx_pp);\n+      pp_cxx_ws_string (pp, \"__underlying_type\");\n+      pp_cxx_whitespace (pp);\n+      pp_cxx_left_paren (pp);\n+      dump_expr (pp, UNDERLYING_TYPE_TYPE (t), flags & ~TFF_EXPR_IN_PARENS);\n+      pp_cxx_right_paren (pp);\n       break;\n \n     case TYPE_PACK_EXPANSION:\n-      dump_type (PACK_EXPANSION_PATTERN (t), flags);\n-      pp_cxx_ws_string (cxx_pp, \"...\");\n+      dump_type (pp, PACK_EXPANSION_PATTERN (t), flags);\n+      pp_cxx_ws_string (pp, \"...\");\n       break;\n \n     case TYPE_ARGUMENT_PACK:\n-      dump_template_argument (t, flags);\n+      dump_template_argument (pp, t, flags);\n       break;\n \n     case DECLTYPE_TYPE:\n-      pp_cxx_ws_string (cxx_pp, \"decltype\");\n-      pp_cxx_whitespace (cxx_pp);\n-      pp_cxx_left_paren (cxx_pp);\n-      dump_expr (DECLTYPE_TYPE_EXPR (t), flags & ~TFF_EXPR_IN_PARENS);\n-      pp_cxx_right_paren (cxx_pp);\n+      pp_cxx_ws_string (pp, \"decltype\");\n+      pp_cxx_whitespace (pp);\n+      pp_cxx_left_paren (pp);\n+      dump_expr (pp, DECLTYPE_TYPE_EXPR (t), flags & ~TFF_EXPR_IN_PARENS);\n+      pp_cxx_right_paren (pp);\n       break;\n \n     case NULLPTR_TYPE:\n-      pp_string (cxx_pp, \"std::nullptr_t\");\n+      pp_string (pp, \"std::nullptr_t\");\n       break;\n \n     default:\n-      pp_unsupported_tree (cxx_pp, t);\n+      pp_unsupported_tree (pp, t);\n       /* Fall through to error.  */\n \n     case ERROR_MARK:\n-      pp_string (cxx_pp, M_(\"<type error>\"));\n+      pp_string (pp, M_(\"<type error>\"));\n       break;\n     }\n }\n@@ -560,16 +563,16 @@ dump_type (tree t, int flags)\n    a TYPENAME_TYPE.  */\n \n static void\n-dump_typename (tree t, int flags)\n+dump_typename (cxx_pretty_printer *pp, tree t, int flags)\n {\n   tree ctx = TYPE_CONTEXT (t);\n \n   if (TREE_CODE (ctx) == TYPENAME_TYPE)\n-    dump_typename (ctx, flags);\n+    dump_typename (pp, ctx, flags);\n   else\n-    dump_type (ctx, flags & ~TFF_CLASS_KEY_OR_ENUM);\n-  pp_cxx_colon_colon (cxx_pp);\n-  dump_decl (TYPENAME_TYPE_FULLNAME (t), flags);\n+    dump_type (pp, ctx, flags & ~TFF_CLASS_KEY_OR_ENUM);\n+  pp_cxx_colon_colon (pp);\n+  dump_decl (pp, TYPENAME_TYPE_FULLNAME (t), flags);\n }\n \n /* Return the name of the supplied aggregate, or enumeral type.  */\n@@ -596,17 +599,17 @@ class_key_or_enum_as_string (tree t)\n    in the form `class foo'.  */\n \n static void\n-dump_aggr_type (tree t, int flags)\n+dump_aggr_type (cxx_pretty_printer *pp, tree t, int flags)\n {\n   tree name;\n   const char *variety = class_key_or_enum_as_string (t);\n   int typdef = 0;\n   int tmplate = 0;\n \n-  pp_cxx_cv_qualifier_seq (cxx_pp, t);\n+  pp_cxx_cv_qualifier_seq (pp, t);\n \n   if (flags & TFF_CLASS_KEY_OR_ENUM)\n-    pp_cxx_ws_string (cxx_pp, variety);\n+    pp_cxx_ws_string (pp, variety);\n \n   name = TYPE_NAME (t);\n \n@@ -634,7 +637,7 @@ dump_aggr_type (tree t, int flags)\n \t\t    || PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (t)));\n       \n       if (! (flags & TFF_UNQUALIFIED_NAME))\n-\tdump_scope (CP_DECL_CONTEXT (name), flags | TFF_SCOPE);\n+\tdump_scope (pp, CP_DECL_CONTEXT (name), flags | TFF_SCOPE);\n       flags &= ~TFF_UNQUALIFIED_NAME;\n       if (tmplate)\n \t{\n@@ -652,23 +655,24 @@ dump_aggr_type (tree t, int flags)\n   if (name == 0 || ANON_AGGRNAME_P (name))\n     {\n       if (flags & TFF_CLASS_KEY_OR_ENUM)\n-\tpp_string (cxx_pp, M_(\"<anonymous>\"));\n+\tpp_string (pp, M_(\"<anonymous>\"));\n       else\n-\tpp_printf (cxx_pp, M_(\"<anonymous %s>\"), variety);\n+\tpp_printf (pp, M_(\"<anonymous %s>\"), variety);\n     }\n   else if (LAMBDA_TYPE_P (t))\n     {\n       /* A lambda's \"type\" is essentially its signature.  */\n-      pp_string (cxx_pp, M_(\"<lambda\"));\n+      pp_string (pp, M_(\"<lambda\"));\n       if (lambda_function (t))\n-\tdump_parameters (FUNCTION_FIRST_USER_PARMTYPE (lambda_function (t)),\n+\tdump_parameters (pp,\n+                         FUNCTION_FIRST_USER_PARMTYPE (lambda_function (t)),\n \t\t\t flags);\n-      pp_greater (cxx_pp);\n+      pp_greater (pp);\n     }\n   else\n-    pp_cxx_tree_identifier (cxx_pp, name);\n+    pp_cxx_tree_identifier (pp, name);\n   if (tmplate)\n-    dump_template_parms (TYPE_TEMPLATE_INFO (t),\n+    dump_template_parms (pp, TYPE_TEMPLATE_INFO (t),\n \t\t\t !CLASSTYPE_USE_TEMPLATE (t),\n \t\t\t flags & ~TFF_TEMPLATE_HEADER);\n }\n@@ -685,7 +689,7 @@ dump_aggr_type (tree t, int flags)\n    int *[]&.  */\n \n static void\n-dump_type_prefix (tree t, int flags)\n+dump_type_prefix (cxx_pretty_printer *pp, tree t, int flags)\n {\n   if (TYPE_PTRMEMFUNC_P (t))\n     {\n@@ -700,60 +704,60 @@ dump_type_prefix (tree t, int flags)\n       {\n \ttree sub = TREE_TYPE (t);\n \n-\tdump_type_prefix (sub, flags);\n+\tdump_type_prefix (pp, sub, flags);\n \tif (TREE_CODE (sub) == ARRAY_TYPE\n \t    || TREE_CODE (sub) == FUNCTION_TYPE)\n \t  {\n-\t    pp_cxx_whitespace (cxx_pp);\n-\t    pp_cxx_left_paren (cxx_pp);\n-\t    pp_c_attributes_display (cxx_pp, TYPE_ATTRIBUTES (sub));\n+\t    pp_cxx_whitespace (pp);\n+\t    pp_cxx_left_paren (pp);\n+\t    pp_c_attributes_display (pp, TYPE_ATTRIBUTES (sub));\n \t  }\n \tif (TYPE_PTR_P (t))\n-\t  pp_star (cxx_pp);\n+\t  pp_star (pp);\n \telse if (TREE_CODE (t) == REFERENCE_TYPE)\n \t{\n \t  if (TYPE_REF_IS_RVALUE (t))\n-\t    pp_ampersand_ampersand (cxx_pp);\n+\t    pp_ampersand_ampersand (pp);\n \t  else\n-\t    pp_ampersand (cxx_pp);\n+\t    pp_ampersand (pp);\n \t}\n-\tcxx_pp->padding = pp_before;\n-\tpp_cxx_cv_qualifier_seq (cxx_pp, t);\n+\tpp->padding = pp_before;\n+\tpp_cxx_cv_qualifier_seq (pp, t);\n       }\n       break;\n \n     case OFFSET_TYPE:\n     offset_type:\n-      dump_type_prefix (TREE_TYPE (t), flags);\n+      dump_type_prefix (pp, TREE_TYPE (t), flags);\n       if (TREE_CODE (t) == OFFSET_TYPE)\t/* pmfs deal with this in d_t_p */\n \t{\n-\t  pp_maybe_space (cxx_pp);\n+\t  pp_maybe_space (pp);\n \t  if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n-\t     pp_cxx_left_paren (cxx_pp);\n-\t  dump_type (TYPE_OFFSET_BASETYPE (t), flags);\n-\t  pp_cxx_colon_colon (cxx_pp);\n+\t     pp_cxx_left_paren (pp);\n+\t  dump_type (pp, TYPE_OFFSET_BASETYPE (t), flags);\n+\t  pp_cxx_colon_colon (pp);\n \t}\n-      pp_cxx_star (cxx_pp);\n-      pp_cxx_cv_qualifier_seq (cxx_pp, t);\n-      cxx_pp->padding = pp_before;\n+      pp_cxx_star (pp);\n+      pp_cxx_cv_qualifier_seq (pp, t);\n+      pp->padding = pp_before;\n       break;\n \n       /* This can be reached without a pointer when dealing with\n \t templates, e.g. std::is_function.  */\n     case FUNCTION_TYPE:\n-      dump_type_prefix (TREE_TYPE (t), flags);\n+      dump_type_prefix (pp, TREE_TYPE (t), flags);\n       break;\n \n     case METHOD_TYPE:\n-      dump_type_prefix (TREE_TYPE (t), flags);\n-      pp_maybe_space (cxx_pp);\n-      pp_cxx_left_paren (cxx_pp);\n-      dump_aggr_type (TYPE_METHOD_BASETYPE (t), flags);\n-      pp_cxx_colon_colon (cxx_pp);\n+      dump_type_prefix (pp, TREE_TYPE (t), flags);\n+      pp_maybe_space (pp);\n+      pp_cxx_left_paren (pp);\n+      dump_aggr_type (pp, TYPE_METHOD_BASETYPE (t), flags);\n+      pp_cxx_colon_colon (pp);\n       break;\n \n     case ARRAY_TYPE:\n-      dump_type_prefix (TREE_TYPE (t), flags);\n+      dump_type_prefix (pp, TREE_TYPE (t), flags);\n       break;\n \n     case ENUMERAL_TYPE:\n@@ -780,15 +784,15 @@ dump_type_prefix (tree t, int flags)\n     case TYPE_PACK_EXPANSION:\n     case FIXED_POINT_TYPE:\n     case NULLPTR_TYPE:\n-      dump_type (t, flags);\n-      cxx_pp->padding = pp_before;\n+      dump_type (pp, t, flags);\n+      pp->padding = pp_before;\n       break;\n \n     default:\n-      pp_unsupported_tree (cxx_pp, t);\n+      pp_unsupported_tree (pp, t);\n       /* fall through.  */\n     case ERROR_MARK:\n-      pp_string (cxx_pp, M_(\"<typeprefixerror>\"));\n+      pp_string (pp, M_(\"<typeprefixerror>\"));\n       break;\n     }\n }\n@@ -797,7 +801,7 @@ dump_type_prefix (tree t, int flags)\n    which appears after the identifier (or function parms).  */\n \n static void\n-dump_type_suffix (tree t, int flags)\n+dump_type_suffix (cxx_pretty_printer *pp, tree t, int flags)\n {\n   if (TYPE_PTRMEMFUNC_P (t))\n     t = TYPE_PTRMEMFUNC_FN_TYPE (t);\n@@ -809,8 +813,8 @@ dump_type_suffix (tree t, int flags)\n     case OFFSET_TYPE:\n       if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE\n \t  || TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE)\n-\tpp_cxx_right_paren (cxx_pp);\n-      dump_type_suffix (TREE_TYPE (t), flags);\n+\tpp_cxx_right_paren (pp);\n+      dump_type_suffix (pp, TREE_TYPE (t), flags);\n       break;\n \n     case FUNCTION_TYPE:\n@@ -819,34 +823,34 @@ dump_type_suffix (tree t, int flags)\n \ttree arg;\n \tif (TREE_CODE (t) == METHOD_TYPE)\n \t  /* Can only be reached through a pointer.  */\n-\t  pp_cxx_right_paren (cxx_pp);\n+\t  pp_cxx_right_paren (pp);\n \targ = TYPE_ARG_TYPES (t);\n \tif (TREE_CODE (t) == METHOD_TYPE)\n \t  arg = TREE_CHAIN (arg);\n \n \t/* Function pointers don't have default args.  Not in standard C++,\n \t   anyway; they may in g++, but we'll just pretend otherwise.  */\n-\tdump_parameters (arg, flags & ~TFF_FUNCTION_DEFAULT_ARGUMENTS);\n+\tdump_parameters (pp, arg, flags & ~TFF_FUNCTION_DEFAULT_ARGUMENTS);\n \n-\tcxx_pp->padding = pp_before;\n-\tpp_cxx_cv_qualifiers (cxx_pp, type_memfn_quals (t));\n-\tdump_ref_qualifier (t, flags);\n-\tdump_exception_spec (TYPE_RAISES_EXCEPTIONS (t), flags);\n-\tdump_type_suffix (TREE_TYPE (t), flags);\n+\tpp->padding = pp_before;\n+\tpp_cxx_cv_qualifiers (pp, type_memfn_quals (t));\n+\tdump_ref_qualifier (pp, t, flags);\n+\tdump_exception_spec (pp, TYPE_RAISES_EXCEPTIONS (t), flags);\n+\tdump_type_suffix (pp, TREE_TYPE (t), flags);\n \tbreak;\n       }\n \n     case ARRAY_TYPE:\n-      pp_maybe_space (cxx_pp);\n-      pp_cxx_left_bracket (cxx_pp);\n+      pp_maybe_space (pp);\n+      pp_cxx_left_bracket (pp);\n       if (TYPE_DOMAIN (t))\n \t{\n \t  tree dtype = TYPE_DOMAIN (t);\n \t  tree max = TYPE_MAX_VALUE (dtype);\n \t  if (integer_all_onesp (max))\n-\t    pp_character (cxx_pp, '0');\n+\t    pp_character (pp, '0');\n \t  else if (host_integerp (max, 0))\n-\t    pp_wide_integer (cxx_pp, tree_low_cst (max, 0) + 1);\n+\t    pp_wide_integer (pp, tree_low_cst (max, 0) + 1);\n \t  else\n \t    {\n \t      STRIP_NOPS (max);\n@@ -863,11 +867,11 @@ dump_type_suffix (tree t, int flags)\n \t\tmax = fold_build2_loc (input_location,\n \t\t\t\t       PLUS_EXPR, dtype, max,\n \t\t\t\t       build_int_cst (dtype, 1));\n-\t      dump_expr (max, flags & ~TFF_EXPR_IN_PARENS);\n+\t      dump_expr (pp, max, flags & ~TFF_EXPR_IN_PARENS);\n \t    }\n \t}\n-      pp_cxx_right_bracket (cxx_pp);\n-      dump_type_suffix (TREE_TYPE (t), flags);\n+      pp_cxx_right_bracket (pp);\n+      dump_type_suffix (pp, TREE_TYPE (t), flags);\n       break;\n \n     case ENUMERAL_TYPE:\n@@ -897,7 +901,7 @@ dump_type_suffix (tree t, int flags)\n       break;\n \n     default:\n-      pp_unsupported_tree (cxx_pp, t);\n+      pp_unsupported_tree (pp, t);\n     case ERROR_MARK:\n       /* Don't mark it here, we should have already done in\n \t dump_type_prefix.  */\n@@ -906,7 +910,7 @@ dump_type_suffix (tree t, int flags)\n }\n \n static void\n-dump_global_iord (tree t)\n+dump_global_iord (cxx_pretty_printer *pp, tree t)\n {\n   const char *p = NULL;\n \n@@ -917,51 +921,51 @@ dump_global_iord (tree t)\n   else\n     gcc_unreachable ();\n \n-  pp_printf (cxx_pp, p, input_filename);\n+  pp_printf (pp, p, input_filename);\n }\n \n static void\n-dump_simple_decl (tree t, tree type, int flags)\n+dump_simple_decl (cxx_pretty_printer *pp, tree t, tree type, int flags)\n {\n   if (flags & TFF_DECL_SPECIFIERS)\n     {\n       if (VAR_P (t)\n \t  && DECL_DECLARED_CONSTEXPR_P (t))\n-\tpp_cxx_ws_string (cxx_pp, \"constexpr\");\n-      dump_type_prefix (type, flags & ~TFF_UNQUALIFIED_NAME);\n-      pp_maybe_space (cxx_pp);\n+\tpp_cxx_ws_string (pp, \"constexpr\");\n+      dump_type_prefix (pp, type, flags & ~TFF_UNQUALIFIED_NAME);\n+      pp_maybe_space (pp);\n     }\n   if (! (flags & TFF_UNQUALIFIED_NAME)\n       && TREE_CODE (t) != PARM_DECL\n       && (!DECL_INITIAL (t)\n \t  || TREE_CODE (DECL_INITIAL (t)) != TEMPLATE_PARM_INDEX))\n-    dump_scope (CP_DECL_CONTEXT (t), flags);\n+    dump_scope (pp, CP_DECL_CONTEXT (t), flags);\n   flags &= ~TFF_UNQUALIFIED_NAME;\n   if ((flags & TFF_DECL_SPECIFIERS)\n       && DECL_TEMPLATE_PARM_P (t) \n       && TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (t)))\n-    pp_string (cxx_pp, \"...\");\n+    pp_string (pp, \"...\");\n   if (DECL_NAME (t))\n     {\n       if (TREE_CODE (t) == FIELD_DECL && DECL_NORMAL_CAPTURE_P (t))\n \t{\n-\t  pp_less (cxx_pp);\n-\t  pp_string (cxx_pp, IDENTIFIER_POINTER (DECL_NAME (t)) + 2);\n-\t  pp_string (cxx_pp, \" capture>\");\n+\t  pp_less (pp);\n+\t  pp_string (pp, IDENTIFIER_POINTER (DECL_NAME (t)) + 2);\n+\t  pp_string (pp, \" capture>\");\n \t}\n       else\n-\tdump_decl (DECL_NAME (t), flags);\n+\tdump_decl (pp, DECL_NAME (t), flags);\n     }\n   else\n-    pp_string (cxx_pp, M_(\"<anonymous>\"));\n+    pp_string (pp, M_(\"<anonymous>\"));\n   if (flags & TFF_DECL_SPECIFIERS)\n-    dump_type_suffix (type, flags);\n+    dump_type_suffix (pp, type, flags);\n }\n \n /* Dump a human readable string for the decl T under control of FLAGS.  */\n \n static void\n-dump_decl (tree t, int flags)\n+dump_decl (cxx_pretty_printer *pp, tree t, int flags)\n {\n   if (t == NULL_TREE)\n     return;\n@@ -973,7 +977,7 @@ dump_decl (tree t, int flags)\n       const char *demangled = objc_maybe_printable_name (t, flags);\n       if (demangled)\n \t{\n-\t  pp_string (cxx_pp, demangled);\n+\t  pp_string (pp, demangled);\n \t  return;\n \t}\n     }\n@@ -988,111 +992,111 @@ dump_decl (tree t, int flags)\n \t      && TREE_CODE (TREE_TYPE (t)) == TEMPLATE_TYPE_PARM)\n \t    {\n \t      /* Say `class T' not just `T'.  */\n-\t      pp_cxx_ws_string (cxx_pp, \"class\");\n+\t      pp_cxx_ws_string (pp, \"class\");\n \n \t      /* Emit the `...' for a parameter pack.  */\n \t      if (TEMPLATE_TYPE_PARAMETER_PACK (TREE_TYPE (t)))\n-\t\tpp_cxx_ws_string (cxx_pp, \"...\");\n+\t\tpp_cxx_ws_string (pp, \"...\");\n \t    }\n \n-\t  dump_type (TREE_TYPE (t), flags);\n+\t  dump_type (pp, TREE_TYPE (t), flags);\n \t  break;\n \t}\n       if (TYPE_DECL_ALIAS_P (t)\n \t  && (flags & TFF_DECL_SPECIFIERS\n \t      || flags & TFF_CLASS_KEY_OR_ENUM))\n \t{\n-\t  pp_cxx_ws_string (cxx_pp, \"using\");\n-\t  dump_decl (DECL_NAME (t), flags);\n-\t  pp_cxx_whitespace (cxx_pp);\n-\t  pp_cxx_ws_string (cxx_pp, \"=\");\n-\t  pp_cxx_whitespace (cxx_pp);\n-\t  dump_type (DECL_ORIGINAL_TYPE (t), flags);\n+\t  pp_cxx_ws_string (pp, \"using\");\n+\t  dump_decl (pp, DECL_NAME (t), flags);\n+\t  pp_cxx_whitespace (pp);\n+\t  pp_cxx_ws_string (pp, \"=\");\n+\t  pp_cxx_whitespace (pp);\n+\t  dump_type (pp, DECL_ORIGINAL_TYPE (t), flags);\n \t  break;\n \t}\n       if ((flags & TFF_DECL_SPECIFIERS)\n \t  && !DECL_SELF_REFERENCE_P (t))\n-\tpp_cxx_ws_string (cxx_pp, \"typedef\");\n-      dump_simple_decl (t, DECL_ORIGINAL_TYPE (t)\n+\tpp_cxx_ws_string (pp, \"typedef\");\n+      dump_simple_decl (pp, t, DECL_ORIGINAL_TYPE (t)\n \t\t\t? DECL_ORIGINAL_TYPE (t) : TREE_TYPE (t),\n \t\t\tflags);\n       break;\n \n     case VAR_DECL:\n       if (DECL_NAME (t) && VTABLE_NAME_P (DECL_NAME (t)))\n \t{\n-\t  pp_string (cxx_pp, M_(\"vtable for \"));\n+\t  pp_string (pp, M_(\"vtable for \"));\n \t  gcc_assert (TYPE_P (DECL_CONTEXT (t)));\n-\t  dump_type (DECL_CONTEXT (t), flags);\n+\t  dump_type (pp, DECL_CONTEXT (t), flags);\n \t  break;\n \t}\n       /* Else fall through.  */\n     case FIELD_DECL:\n     case PARM_DECL:\n-      dump_simple_decl (t, TREE_TYPE (t), flags);\n+      dump_simple_decl (pp, t, TREE_TYPE (t), flags);\n       break;\n \n     case RESULT_DECL:\n-      pp_string (cxx_pp, M_(\"<return value> \"));\n-      dump_simple_decl (t, TREE_TYPE (t), flags);\n+      pp_string (pp, M_(\"<return value> \"));\n+      dump_simple_decl (pp, t, TREE_TYPE (t), flags);\n       break;\n \n     case NAMESPACE_DECL:\n       if (flags & TFF_DECL_SPECIFIERS)\n-\tpp_cxx_declaration (cxx_pp, t);\n+\tpp_cxx_declaration (pp, t);\n       else\n \t{\n \t  if (! (flags & TFF_UNQUALIFIED_NAME))\n-\t    dump_scope (CP_DECL_CONTEXT (t), flags);\n+\t    dump_scope (pp, CP_DECL_CONTEXT (t), flags);\n \t  flags &= ~TFF_UNQUALIFIED_NAME;\n \t  if (DECL_NAME (t) == NULL_TREE)\n             {\n-              if (!(cxx_pp->flags & pp_c_flag_gnu_v3))\n-                pp_cxx_ws_string (cxx_pp, M_(\"{anonymous}\"));\n+              if (!(pp->flags & pp_c_flag_gnu_v3))\n+                pp_cxx_ws_string (pp, M_(\"{anonymous}\"));\n               else\n-                pp_cxx_ws_string (cxx_pp, M_(\"(anonymous namespace)\"));\n+                pp_cxx_ws_string (pp, M_(\"(anonymous namespace)\"));\n             }\n \t  else\n-\t    pp_cxx_tree_identifier (cxx_pp, DECL_NAME (t));\n+\t    pp_cxx_tree_identifier (pp, DECL_NAME (t));\n \t}\n       break;\n \n     case SCOPE_REF:\n-      dump_type (TREE_OPERAND (t, 0), flags);\n-      pp_colon_colon (cxx_pp);\n-      dump_decl (TREE_OPERAND (t, 1), TFF_UNQUALIFIED_NAME);\n+      dump_type (pp, TREE_OPERAND (t, 0), flags);\n+      pp_colon_colon (pp);\n+      dump_decl (pp, TREE_OPERAND (t, 1), TFF_UNQUALIFIED_NAME);\n       break;\n \n     case ARRAY_REF:\n-      dump_decl (TREE_OPERAND (t, 0), flags);\n-      pp_cxx_left_bracket (cxx_pp);\n-      dump_decl (TREE_OPERAND (t, 1), flags);\n-      pp_cxx_right_bracket (cxx_pp);\n+      dump_decl (pp, TREE_OPERAND (t, 0), flags);\n+      pp_cxx_left_bracket (pp);\n+      dump_decl (pp, TREE_OPERAND (t, 1), flags);\n+      pp_cxx_right_bracket (pp);\n       break;\n \n     case ARRAY_NOTATION_REF:\n-      dump_decl (ARRAY_NOTATION_ARRAY (t), flags | TFF_EXPR_IN_PARENS);\n-      pp_cxx_left_bracket (cxx_pp);\n-      dump_decl (ARRAY_NOTATION_START (t), flags | TFF_EXPR_IN_PARENS);\n-      pp_colon (cxx_pp);\n-      dump_decl (ARRAY_NOTATION_LENGTH (t), flags | TFF_EXPR_IN_PARENS);\n-      pp_colon (cxx_pp);\n-      dump_decl (ARRAY_NOTATION_STRIDE (t), flags | TFF_EXPR_IN_PARENS);\n-      pp_cxx_right_bracket (cxx_pp);\n+      dump_decl (pp, ARRAY_NOTATION_ARRAY (t), flags | TFF_EXPR_IN_PARENS);\n+      pp_cxx_left_bracket (pp);\n+      dump_decl (pp, ARRAY_NOTATION_START (t), flags | TFF_EXPR_IN_PARENS);\n+      pp_colon (pp);\n+      dump_decl (pp, ARRAY_NOTATION_LENGTH (t), flags | TFF_EXPR_IN_PARENS);\n+      pp_colon (pp);\n+      dump_decl (pp, ARRAY_NOTATION_STRIDE (t), flags | TFF_EXPR_IN_PARENS);\n+      pp_cxx_right_bracket (pp);\n       break;\n \n       /* So that we can do dump_decl on an aggr type.  */\n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case ENUMERAL_TYPE:\n-      dump_type (t, flags);\n+      dump_type (pp, t, flags);\n       break;\n \n     case BIT_NOT_EXPR:\n       /* This is a pseudo destructor call which has not been folded into\n \t a PSEUDO_DTOR_EXPR yet.  */\n-      pp_cxx_complement (cxx_pp);\n-      dump_type (TREE_OPERAND (t, 0), flags);\n+      pp_cxx_complement (pp);\n+      dump_type (pp, TREE_OPERAND (t, 0), flags);\n       break;\n \n     case TYPE_EXPR:\n@@ -1104,13 +1108,13 @@ dump_decl (tree t, int flags)\n     case IDENTIFIER_NODE:\n       if (IDENTIFIER_TYPENAME_P (t))\n \t{\n-\t  pp_cxx_ws_string (cxx_pp, \"operator\");\n+\t  pp_cxx_ws_string (pp, \"operator\");\n \t  /* Not exactly IDENTIFIER_TYPE_VALUE.  */\n-\t  dump_type (TREE_TYPE (t), flags);\n+\t  dump_type (pp, TREE_TYPE (t), flags);\n \t  break;\n \t}\n       else\n-\tpp_cxx_tree_identifier (cxx_pp, t);\n+\tpp_cxx_tree_identifier (pp, t);\n       break;\n \n     case OVERLOAD:\n@@ -1119,15 +1123,15 @@ dump_decl (tree t, int flags)\n \t  t = OVL_CURRENT (t);\n \t  if (DECL_CLASS_SCOPE_P (t))\n \t    {\n-\t      dump_type (DECL_CONTEXT (t), flags);\n-\t      pp_cxx_colon_colon (cxx_pp);\n+\t      dump_type (pp, DECL_CONTEXT (t), flags);\n+\t      pp_cxx_colon_colon (pp);\n \t    }\n \t  else if (!DECL_FILE_SCOPE_P (t))\n \t    {\n-\t      dump_decl (DECL_CONTEXT (t), flags);\n-\t      pp_cxx_colon_colon (cxx_pp);\n+\t      dump_decl (pp, DECL_CONTEXT (t), flags);\n+\t      pp_cxx_colon_colon (pp);\n \t    }\n-\t  dump_decl (DECL_NAME (t), flags);\n+\t  dump_decl (pp, DECL_NAME (t), flags);\n \t  break;\n \t}\n \n@@ -1138,15 +1142,15 @@ dump_decl (tree t, int flags)\n \n     case FUNCTION_DECL:\n       if (! DECL_LANG_SPECIFIC (t))\n-\tpp_string (cxx_pp, M_(\"<built-in>\"));\n+\tpp_string (pp, M_(\"<built-in>\"));\n       else if (DECL_GLOBAL_CTOR_P (t) || DECL_GLOBAL_DTOR_P (t))\n-\tdump_global_iord (t);\n+\tdump_global_iord (pp, t);\n       else\n-\tdump_function_decl (t, flags);\n+\tdump_function_decl (pp, t, flags);\n       break;\n \n     case TEMPLATE_DECL:\n-      dump_template_decl (t, flags);\n+      dump_template_decl (pp, t, flags);\n       break;\n \n     case TEMPLATE_ID_EXPR:\n@@ -1156,71 +1160,71 @@ dump_decl (tree t, int flags)\n \n \tif (is_overloaded_fn (name))\n \t  name = DECL_NAME (get_first_fn (name));\n-\tdump_decl (name, flags);\n-\tpp_cxx_begin_template_argument_list (cxx_pp);\n+\tdump_decl (pp, name, flags);\n+\tpp_cxx_begin_template_argument_list (pp);\n \tif (args == error_mark_node)\n-\t  pp_string (cxx_pp, M_(\"<template arguments error>\"));\n+\t  pp_string (pp, M_(\"<template arguments error>\"));\n \telse if (args)\n-\t  dump_template_argument_list (args, flags);\n-      \tpp_cxx_end_template_argument_list (cxx_pp);\n+\t  dump_template_argument_list (pp, args, flags);\n+      \tpp_cxx_end_template_argument_list (pp);\n       }\n       break;\n \n     case LABEL_DECL:\n-      pp_cxx_tree_identifier (cxx_pp, DECL_NAME (t));\n+      pp_cxx_tree_identifier (pp, DECL_NAME (t));\n       break;\n \n     case CONST_DECL:\n       if ((TREE_TYPE (t) != NULL_TREE && NEXT_CODE (t) == ENUMERAL_TYPE)\n \t  || (DECL_INITIAL (t) &&\n \t      TREE_CODE (DECL_INITIAL (t)) == TEMPLATE_PARM_INDEX))\n-\tdump_simple_decl (t, TREE_TYPE (t), flags);\n+\tdump_simple_decl (pp, t, TREE_TYPE (t), flags);\n       else if (DECL_NAME (t))\n-\tdump_decl (DECL_NAME (t), flags);\n+\tdump_decl (pp, DECL_NAME (t), flags);\n       else if (DECL_INITIAL (t))\n-\tdump_expr (DECL_INITIAL (t), flags | TFF_EXPR_IN_PARENS);\n+\tdump_expr (pp, DECL_INITIAL (t), flags | TFF_EXPR_IN_PARENS);\n       else\n-\tpp_string (cxx_pp, M_(\"<enumerator>\"));\n+\tpp_string (pp, M_(\"<enumerator>\"));\n       break;\n \n     case USING_DECL:\n-      pp_cxx_ws_string (cxx_pp, \"using\");\n-      dump_type (USING_DECL_SCOPE (t), flags);\n-      pp_cxx_colon_colon (cxx_pp);\n-      dump_decl (DECL_NAME (t), flags);\n+      pp_cxx_ws_string (pp, \"using\");\n+      dump_type (pp, USING_DECL_SCOPE (t), flags);\n+      pp_cxx_colon_colon (pp);\n+      dump_decl (pp, DECL_NAME (t), flags);\n       break;\n \n     case STATIC_ASSERT:\n-      pp_cxx_declaration (cxx_pp, t);\n+      pp_cxx_declaration (pp, t);\n       break;\n \n     case BASELINK:\n-      dump_decl (BASELINK_FUNCTIONS (t), flags);\n+      dump_decl (pp, BASELINK_FUNCTIONS (t), flags);\n       break;\n \n     case NON_DEPENDENT_EXPR:\n-      dump_expr (t, flags);\n+      dump_expr (pp, t, flags);\n       break;\n \n     case TEMPLATE_TYPE_PARM:\n       if (flags & TFF_DECL_SPECIFIERS)\n-\tpp_cxx_declaration (cxx_pp, t);\n+\tpp_cxx_declaration (pp, t);\n       else\n-\tpp_type_id (cxx_pp, t);\n+\tpp_type_id (pp, t);\n       break;\n \n     case UNBOUND_CLASS_TEMPLATE:\n     case TYPE_PACK_EXPANSION:\n     case TREE_BINFO:\n-      dump_type (t, flags);\n+      dump_type (pp, t, flags);\n       break;\n \n     default:\n-      pp_unsupported_tree (cxx_pp, t);\n+      pp_unsupported_tree (pp, t);\n       /* Fall through to error.  */\n \n     case ERROR_MARK:\n-      pp_string (cxx_pp, M_(\"<declaration error>\"));\n+      pp_string (pp, M_(\"<declaration error>\"));\n       break;\n     }\n }\n@@ -1229,7 +1233,7 @@ dump_decl (tree t, int flags)\n    'template <...> leaders plus the 'class X' or 'void fn(...)' part.  */\n \n static void\n-dump_template_decl (tree t, int flags)\n+dump_template_decl (cxx_pretty_printer *pp, tree t, int flags)\n {\n   tree orig_parms = DECL_TEMPLATE_PARMS (t);\n   tree parms;\n@@ -1244,8 +1248,8 @@ dump_template_decl (tree t, int flags)\n \t  tree inner_parms = INNERMOST_TEMPLATE_PARMS (parms);\n \t  int len = TREE_VEC_LENGTH (inner_parms);\n \n-\t  pp_cxx_ws_string (cxx_pp, \"template\");\n-\t  pp_cxx_begin_template_argument_list (cxx_pp);\n+\t  pp_cxx_ws_string (pp, \"template\");\n+\t  pp_cxx_begin_template_argument_list (pp);\n \n \t  /* If we've shown the template prefix, we'd better show the\n \t     parameters' and decl's type too.  */\n@@ -1254,46 +1258,47 @@ dump_template_decl (tree t, int flags)\n \t  for (i = 0; i < len; i++)\n \t    {\n \t      if (i)\n-\t\tpp_separate_with_comma (cxx_pp);\n-\t      dump_template_parameter (TREE_VEC_ELT (inner_parms, i), flags);\n+\t\tpp_separate_with_comma (pp);\n+\t      dump_template_parameter (pp, TREE_VEC_ELT (inner_parms, i),\n+                                       flags);\n \t    }\n-\t  pp_cxx_end_template_argument_list (cxx_pp);\n-\t  pp_cxx_whitespace (cxx_pp);\n+\t  pp_cxx_end_template_argument_list (pp);\n+\t  pp_cxx_whitespace (pp);\n \t}\n       nreverse(orig_parms);\n \n       if (DECL_TEMPLATE_TEMPLATE_PARM_P (t))\n \t{\n \t  /* Say `template<arg> class TT' not just `template<arg> TT'.  */\n-\t  pp_cxx_ws_string (cxx_pp, \"class\");\n+\t  pp_cxx_ws_string (pp, \"class\");\n \n \t  /* If this is a parameter pack, print the ellipsis.  */\n \t  if (TEMPLATE_TYPE_PARAMETER_PACK (TREE_TYPE (t)))\n-\t    pp_cxx_ws_string (cxx_pp, \"...\");\n+\t    pp_cxx_ws_string (pp, \"...\");\n \t}\n     }\n \n   if (DECL_CLASS_TEMPLATE_P (t))\n-    dump_type (TREE_TYPE (t),\n+    dump_type (pp, TREE_TYPE (t),\n \t       ((flags & ~TFF_CLASS_KEY_OR_ENUM) | TFF_TEMPLATE_NAME\n \t\t| (flags & TFF_DECL_SPECIFIERS ? TFF_CLASS_KEY_OR_ENUM : 0)));\n   else if (DECL_TEMPLATE_RESULT (t)\n            && (VAR_P (DECL_TEMPLATE_RESULT (t))\n \t       /* Alias template.  */\n \t       || DECL_TYPE_TEMPLATE_P (t)))\n-    dump_decl (DECL_TEMPLATE_RESULT (t), flags | TFF_TEMPLATE_NAME);\n+    dump_decl (pp, DECL_TEMPLATE_RESULT (t), flags | TFF_TEMPLATE_NAME);\n   else\n     {\n       gcc_assert (TREE_TYPE (t));\n       switch (NEXT_CODE (t))\n \t{\n \tcase METHOD_TYPE:\n \tcase FUNCTION_TYPE:\n-\t  dump_function_decl (t, flags | TFF_TEMPLATE_NAME);\n+\t  dump_function_decl (pp, t, flags | TFF_TEMPLATE_NAME);\n \t  break;\n \tdefault:\n \t  /* This case can occur with some invalid code.  */\n-\t  dump_type (TREE_TYPE (t),\n+\t  dump_type (pp, TREE_TYPE (t),\n \t\t     (flags & ~TFF_CLASS_KEY_OR_ENUM) | TFF_TEMPLATE_NAME\n \t\t     | (flags & TFF_DECL_SPECIFIERS\n \t\t\t? TFF_CLASS_KEY_OR_ENUM : 0));\n@@ -1363,7 +1368,7 @@ find_typenames (tree t)\n    is %D which doesn't print the throw specs, and %F which does.  */\n \n static void\n-dump_function_decl (tree t, int flags)\n+dump_function_decl (cxx_pretty_printer *pp, tree t, int flags)\n {\n   tree fntype;\n   tree parmtypes;\n@@ -1379,7 +1384,7 @@ dump_function_decl (tree t, int flags)\n     {\n       /* A lambda's signature is essentially its \"type\", so defer.  */\n       gcc_assert (LAMBDA_TYPE_P (DECL_CONTEXT (t)));\n-      dump_type (DECL_CONTEXT (t), flags);\n+      dump_type (pp, DECL_CONTEXT (t), flags);\n       return;\n     }\n \n@@ -1419,12 +1424,12 @@ dump_function_decl (tree t, int flags)\n   if (flags & TFF_DECL_SPECIFIERS)\n     {\n       if (DECL_STATIC_FUNCTION_P (t))\n-\tpp_cxx_ws_string (cxx_pp, \"static\");\n+\tpp_cxx_ws_string (pp, \"static\");\n       else if (DECL_VIRTUAL_P (t))\n-\tpp_cxx_ws_string (cxx_pp, \"virtual\");\n+\tpp_cxx_ws_string (pp, \"virtual\");\n \n       if (DECL_DECLARED_CONSTEXPR_P (STRIP_TEMPLATE (t)))\n-\tpp_cxx_ws_string (cxx_pp, \"constexpr\");\n+\tpp_cxx_ws_string (pp, \"constexpr\");\n     }\n \n   /* Print the return type?  */\n@@ -1434,73 +1439,73 @@ dump_function_decl (tree t, int flags)\n   if (show_return)\n     {\n       tree ret = fndecl_declared_return_type (t);\n-      dump_type_prefix (ret, flags);\n+      dump_type_prefix (pp, ret, flags);\n     }\n \n   /* Print the function name.  */\n   if (!do_outer_scope)\n     /* Nothing.  */;\n   else if (cname)\n     {\n-      dump_type (cname, flags);\n-      pp_cxx_colon_colon (cxx_pp);\n+      dump_type (pp, cname, flags);\n+      pp_cxx_colon_colon (pp);\n     }\n   else\n-    dump_scope (CP_DECL_CONTEXT (t), flags);\n+    dump_scope (pp, CP_DECL_CONTEXT (t), flags);\n \n-  dump_function_name (t, flags);\n+  dump_function_name (pp, t, flags);\n \n   if (!(flags & TFF_NO_FUNCTION_ARGUMENTS))\n     {\n-      dump_parameters (parmtypes, flags);\n+      dump_parameters (pp, parmtypes, flags);\n \n       if (TREE_CODE (fntype) == METHOD_TYPE)\n \t{\n-\t  cxx_pp->padding = pp_before;\n-\t  pp_cxx_cv_qualifier_seq (cxx_pp, class_of_this_parm (fntype));\n-\t  dump_ref_qualifier (fntype, flags);\n+\t  pp->padding = pp_before;\n+\t  pp_cxx_cv_qualifier_seq (pp, class_of_this_parm (fntype));\n+\t  dump_ref_qualifier (pp, fntype, flags);\n \t}\n \n       if (flags & TFF_EXCEPTION_SPECIFICATION)\n \t{\n-\t  cxx_pp->padding = pp_before;\n-\t  dump_exception_spec (exceptions, flags);\n+\t  pp->padding = pp_before;\n+\t  dump_exception_spec (pp, exceptions, flags);\n \t}\n \n       if (show_return)\n-\tdump_type_suffix (TREE_TYPE (fntype), flags);\n+\tdump_type_suffix (pp, TREE_TYPE (fntype), flags);\n \n       /* If T is a template instantiation, dump the parameter binding.  */\n       if (template_parms != NULL_TREE && template_args != NULL_TREE\n \t  && !(flags & TFF_NO_TEMPLATE_BINDINGS))\n \t{\n-\t  pp_cxx_whitespace (cxx_pp);\n-\t  pp_cxx_left_bracket (cxx_pp);\n-\t  pp_cxx_ws_string (cxx_pp, M_(\"with\"));\n-\t  pp_cxx_whitespace (cxx_pp);\n-\t  dump_template_bindings (template_parms, template_args, typenames);\n-\t  pp_cxx_right_bracket (cxx_pp);\n+\t  pp_cxx_whitespace (pp);\n+\t  pp_cxx_left_bracket (pp);\n+\t  pp_cxx_ws_string (pp, M_(\"with\"));\n+\t  pp_cxx_whitespace (pp);\n+\t  dump_template_bindings (pp, template_parms, template_args, typenames);\n+\t  pp_cxx_right_bracket (pp);\n \t}\n     }\n   else if (template_args)\n     {\n       bool need_comma = false;\n       int i;\n-      pp_cxx_begin_template_argument_list (cxx_pp);\n+      pp_cxx_begin_template_argument_list (pp);\n       template_args = INNERMOST_TEMPLATE_ARGS (template_args);\n       for (i = 0; i < TREE_VEC_LENGTH (template_args); ++i)\n \t{\n \t  tree arg = TREE_VEC_ELT (template_args, i);\n \t  if (need_comma)\n-\t    pp_separate_with_comma (cxx_pp);\n+\t    pp_separate_with_comma (pp);\n \t  if (ARGUMENT_PACK_P (arg))\n-\t    pp_cxx_left_brace (cxx_pp);\n-\t  dump_template_argument (arg, TFF_PLAIN_IDENTIFIER);\n+\t    pp_cxx_left_brace (pp);\n+\t  dump_template_argument (pp, arg, TFF_PLAIN_IDENTIFIER);\n \t  if (ARGUMENT_PACK_P (arg))\n-\t    pp_cxx_right_brace (cxx_pp);\n+\t    pp_cxx_right_brace (pp);\n \t  need_comma = true;\n \t}\n-      pp_cxx_end_template_argument_list (cxx_pp);\n+      pp_cxx_end_template_argument_list (pp);\n     }\n }\n \n@@ -1509,92 +1514,92 @@ dump_function_decl (tree t, int flags)\n    already been removed.  */\n \n static void\n-dump_parameters (tree parmtypes, int flags)\n+dump_parameters (cxx_pretty_printer *pp, tree parmtypes, int flags)\n {\n   int first = 1;\n   flags &= ~TFF_SCOPE;\n-  pp_cxx_left_paren (cxx_pp);\n+  pp_cxx_left_paren (pp);\n \n   for (first = 1; parmtypes != void_list_node;\n        parmtypes = TREE_CHAIN (parmtypes))\n     {\n       if (!first)\n-\tpp_separate_with_comma (cxx_pp);\n+\tpp_separate_with_comma (pp);\n       first = 0;\n       if (!parmtypes)\n \t{\n-\t  pp_cxx_ws_string (cxx_pp, \"...\");\n+\t  pp_cxx_ws_string (pp, \"...\");\n \t  break;\n \t}\n \n-      dump_type (TREE_VALUE (parmtypes), flags);\n+      dump_type (pp, TREE_VALUE (parmtypes), flags);\n \n       if ((flags & TFF_FUNCTION_DEFAULT_ARGUMENTS) && TREE_PURPOSE (parmtypes))\n \t{\n-\t  pp_cxx_whitespace (cxx_pp);\n-\t  pp_equal (cxx_pp);\n-\t  pp_cxx_whitespace (cxx_pp);\n-\t  dump_expr (TREE_PURPOSE (parmtypes), flags | TFF_EXPR_IN_PARENS);\n+\t  pp_cxx_whitespace (pp);\n+\t  pp_equal (pp);\n+\t  pp_cxx_whitespace (pp);\n+\t  dump_expr (pp, TREE_PURPOSE (parmtypes), flags | TFF_EXPR_IN_PARENS);\n \t}\n     }\n \n-  pp_cxx_right_paren (cxx_pp);\n+  pp_cxx_right_paren (pp);\n }\n \n /* Print ref-qualifier of a FUNCTION_TYPE or METHOD_TYPE. FLAGS are ignored. */\n \n static void\n-dump_ref_qualifier (tree t, int flags ATTRIBUTE_UNUSED)\n+dump_ref_qualifier (cxx_pretty_printer *pp, tree t, int flags ATTRIBUTE_UNUSED)\n {\n   if (FUNCTION_REF_QUALIFIED (t))\n     {\n-      cxx_pp->padding = pp_before;\n+      pp->padding = pp_before;\n       if (FUNCTION_RVALUE_QUALIFIED (t))\n-        pp_cxx_ws_string (cxx_pp, \"&&\");\n+        pp_cxx_ws_string (pp, \"&&\");\n       else\n-        pp_cxx_ws_string (cxx_pp, \"&\");\n+        pp_cxx_ws_string (pp, \"&\");\n     }\n }\n \n /* Print an exception specification. T is the exception specification.  */\n \n static void\n-dump_exception_spec (tree t, int flags)\n+dump_exception_spec (cxx_pretty_printer *pp, tree t, int flags)\n {\n   if (t && TREE_PURPOSE (t))\n     {\n-      pp_cxx_ws_string (cxx_pp, \"noexcept\");\n-      pp_cxx_whitespace (cxx_pp);\n-      pp_cxx_left_paren (cxx_pp);\n+      pp_cxx_ws_string (pp, \"noexcept\");\n+      pp_cxx_whitespace (pp);\n+      pp_cxx_left_paren (pp);\n       if (DEFERRED_NOEXCEPT_SPEC_P (t))\n-\tpp_cxx_ws_string (cxx_pp, \"<uninstantiated>\");\n+\tpp_cxx_ws_string (pp, \"<uninstantiated>\");\n       else\n-\tdump_expr (TREE_PURPOSE (t), flags);\n-      pp_cxx_right_paren (cxx_pp);\n+\tdump_expr (pp, TREE_PURPOSE (t), flags);\n+      pp_cxx_right_paren (pp);\n     }\n   else if (t)\n     {\n-      pp_cxx_ws_string (cxx_pp, \"throw\");\n-      pp_cxx_whitespace (cxx_pp);\n-      pp_cxx_left_paren (cxx_pp);\n+      pp_cxx_ws_string (pp, \"throw\");\n+      pp_cxx_whitespace (pp);\n+      pp_cxx_left_paren (pp);\n       if (TREE_VALUE (t) != NULL_TREE)\n \twhile (1)\n \t  {\n-\t    dump_type (TREE_VALUE (t), flags);\n+\t    dump_type (pp, TREE_VALUE (t), flags);\n \t    t = TREE_CHAIN (t);\n \t    if (!t)\n \t      break;\n-\t    pp_separate_with_comma (cxx_pp);\n+\t    pp_separate_with_comma (pp);\n \t  }\n-      pp_cxx_right_paren (cxx_pp);\n+      pp_cxx_right_paren (pp);\n     }\n }\n \n /* Handle the function name for a FUNCTION_DECL node, grokking operators\n    and destructors properly.  */\n \n static void\n-dump_function_name (tree t, int flags)\n+dump_function_name (cxx_pretty_printer *pp, tree t, int flags)\n {\n   tree name = DECL_NAME (t);\n \n@@ -1605,7 +1610,7 @@ dump_function_name (tree t, int flags)\n      literal name.  */\n   if (!DECL_LANG_SPECIFIC (t))\n     {\n-      pp_cxx_tree_identifier (cxx_pp, name);\n+      pp_cxx_tree_identifier (pp, name);\n       return;\n     }\n \n@@ -1626,8 +1631,8 @@ dump_function_name (tree t, int flags)\n \n   if (DECL_DESTRUCTOR_P (t))\n     {\n-      pp_cxx_complement (cxx_pp);\n-      dump_decl (name, TFF_PLAIN_IDENTIFIER);\n+      pp_cxx_complement (pp);\n+      dump_decl (pp, name, TFF_PLAIN_IDENTIFIER);\n     }\n   else if (DECL_CONV_FN_P (t))\n     {\n@@ -1637,21 +1642,22 @@ dump_function_name (tree t, int flags)\n \t declarations, both will have the same name, yet\n \t the types will be different, hence the TREE_TYPE field\n \t of the first name will be clobbered by the second.  */\n-      pp_cxx_ws_string (cxx_pp, \"operator\");\n-      dump_type (TREE_TYPE (TREE_TYPE (t)), flags);\n+      pp_cxx_ws_string (pp, \"operator\");\n+      dump_type (pp, TREE_TYPE (TREE_TYPE (t)), flags);\n     }\n   else if (name && IDENTIFIER_OPNAME_P (name))\n-    pp_cxx_tree_identifier (cxx_pp, name);\n+    pp_cxx_tree_identifier (pp, name);\n   else if (name && UDLIT_OPER_P (name))\n-    pp_cxx_tree_identifier (cxx_pp, name);\n+    pp_cxx_tree_identifier (pp, name);\n   else\n-    dump_decl (name, flags);\n+    dump_decl (pp, name, flags);\n \n   if (DECL_TEMPLATE_INFO (t)\n       && !DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION (t)\n       && (TREE_CODE (DECL_TI_TEMPLATE (t)) != TEMPLATE_DECL\n \t  || PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (t))))\n-    dump_template_parms (DECL_TEMPLATE_INFO (t), !DECL_USE_TEMPLATE (t), flags);\n+    dump_template_parms (pp, DECL_TEMPLATE_INFO (t), !DECL_USE_TEMPLATE (t),\n+                         flags);\n }\n \n /* Dump the template parameters from the template info INFO under control of\n@@ -1661,14 +1667,15 @@ dump_function_name (tree t, int flags)\n    decoration.  */\n \n static void\n-dump_template_parms (tree info, int primary, int flags)\n+dump_template_parms (cxx_pretty_printer *pp, tree info,\n+                     int primary, int flags)\n {\n   tree args = info ? TI_ARGS (info) : NULL_TREE;\n \n   if (primary && flags & TFF_TEMPLATE_NAME)\n     return;\n   flags &= ~(TFF_CLASS_KEY_OR_ENUM | TFF_TEMPLATE_NAME);\n-  pp_cxx_begin_template_argument_list (cxx_pp);\n+  pp_cxx_begin_template_argument_list (pp);\n \n   /* Be careful only to print things when we have them, so as not\n      to crash producing error messages.  */\n@@ -1688,12 +1695,12 @@ dump_template_parms (tree info, int primary, int flags)\n           if (ix\n               && (!ARGUMENT_PACK_P (arg)\n                   || TREE_VEC_LENGTH (ARGUMENT_PACK_ARGS (arg)) > 0))\n-            pp_separate_with_comma (cxx_pp);\n+            pp_separate_with_comma (pp);\n           \n           if (!arg)\n-            pp_string (cxx_pp, M_(\"<template parameter error>\"));\n+            pp_string (pp, M_(\"<template parameter error>\"));\n           else\n-            dump_template_argument (arg, flags);\n+            dump_template_argument (pp, arg, flags);\n         }\n     }\n   else if (primary)\n@@ -1711,97 +1718,99 @@ dump_template_parms (tree info, int primary, int flags)\n \n           if (TREE_VEC_ELT (parms, ix) == error_mark_node)\n             {\n-              pp_string (cxx_pp, M_(\"<template parameter error>\"));\n+              pp_string (pp, M_(\"<template parameter error>\"));\n               continue;\n             }\n \n           parm = TREE_VALUE (TREE_VEC_ELT (parms, ix));\n \n \t  if (ix)\n-\t    pp_separate_with_comma (cxx_pp);\n+\t    pp_separate_with_comma (pp);\n \n-\t  dump_decl (parm, flags & ~TFF_DECL_SPECIFIERS);\n+\t  dump_decl (pp, parm, flags & ~TFF_DECL_SPECIFIERS);\n \t}\n     }\n-  pp_cxx_end_template_argument_list (cxx_pp);\n+  pp_cxx_end_template_argument_list (pp);\n }\n \n /* Print out the arguments of CALL_EXPR T as a parenthesized list using\n    flags FLAGS.  Skip over the first argument if SKIPFIRST is true.  */\n \n static void\n-dump_call_expr_args (tree t, int flags, bool skipfirst)\n+dump_call_expr_args (cxx_pretty_printer *pp, tree t, int flags, bool skipfirst)\n {\n   tree arg;\n   call_expr_arg_iterator iter;\n   \n-  pp_cxx_left_paren (cxx_pp);\n+  pp_cxx_left_paren (pp);\n   FOR_EACH_CALL_EXPR_ARG (arg, iter, t)\n     {\n       if (skipfirst)\n \tskipfirst = false;\n       else\n \t{\n-\t  dump_expr (arg, flags | TFF_EXPR_IN_PARENS);\n+\t  dump_expr (pp, arg, flags | TFF_EXPR_IN_PARENS);\n \t  if (more_call_expr_args_p (&iter))\n-\t    pp_separate_with_comma (cxx_pp);\n+\t    pp_separate_with_comma (pp);\n \t}\n     }\n-  pp_cxx_right_paren (cxx_pp);\n+  pp_cxx_right_paren (pp);\n }\n \n /* Print out the arguments of AGGR_INIT_EXPR T as a parenthesized list\n    using flags FLAGS.  Skip over the first argument if SKIPFIRST is\n    true.  */\n \n static void\n-dump_aggr_init_expr_args (tree t, int flags, bool skipfirst)\n+dump_aggr_init_expr_args (cxx_pretty_printer *pp, tree t, int flags,\n+                          bool skipfirst)\n {\n   tree arg;\n   aggr_init_expr_arg_iterator iter;\n   \n-  pp_cxx_left_paren (cxx_pp);\n+  pp_cxx_left_paren (pp);\n   FOR_EACH_AGGR_INIT_EXPR_ARG (arg, iter, t)\n     {\n       if (skipfirst)\n \tskipfirst = false;\n       else\n \t{\n-\t  dump_expr (arg, flags | TFF_EXPR_IN_PARENS);\n+\t  dump_expr (pp, arg, flags | TFF_EXPR_IN_PARENS);\n \t  if (more_aggr_init_expr_args_p (&iter))\n-\t    pp_separate_with_comma (cxx_pp);\n+\t    pp_separate_with_comma (pp);\n \t}\n     }\n-  pp_cxx_right_paren (cxx_pp);\n+  pp_cxx_right_paren (pp);\n }\n \n /* Print out a list of initializers (subr of dump_expr).  */\n \n static void\n-dump_expr_list (tree l, int flags)\n+dump_expr_list (cxx_pretty_printer *pp, tree l, int flags)\n {\n   while (l)\n     {\n-      dump_expr (TREE_VALUE (l), flags | TFF_EXPR_IN_PARENS);\n+      dump_expr (pp, TREE_VALUE (l), flags | TFF_EXPR_IN_PARENS);\n       l = TREE_CHAIN (l);\n       if (l)\n-\tpp_separate_with_comma (cxx_pp);\n+\tpp_separate_with_comma (pp);\n     }\n }\n \n /* Print out a vector of initializers (subr of dump_expr).  */\n \n static void\n-dump_expr_init_vec (vec<constructor_elt, va_gc> *v, int flags)\n+dump_expr_init_vec (cxx_pretty_printer *pp, vec<constructor_elt, va_gc> *v,\n+                    int flags)\n {\n   unsigned HOST_WIDE_INT idx;\n   tree value;\n \n   FOR_EACH_CONSTRUCTOR_VALUE (v, idx, value)\n     {\n-      dump_expr (value, flags | TFF_EXPR_IN_PARENS);\n+      dump_expr (pp, value, flags | TFF_EXPR_IN_PARENS);\n       if (idx != v->length () - 1)\n-\tpp_separate_with_comma (cxx_pp);\n+\tpp_separate_with_comma (pp);\n     }\n }\n \n@@ -1830,7 +1839,7 @@ resolve_virtual_fun_from_obj_type_ref (tree ref)\n /* Print out an expression E under control of FLAGS.  */\n \n static void\n-dump_expr (tree t, int flags)\n+dump_expr (cxx_pretty_printer *pp, tree t, int flags)\n {\n   tree op;\n \n@@ -1839,7 +1848,7 @@ dump_expr (tree t, int flags)\n \n   if (STATEMENT_CLASS_P (t))\n     {\n-      pp_cxx_ws_string (cxx_pp, M_(\"<statement>\"));\n+      pp_cxx_ws_string (pp, M_(\"<statement>\"));\n       return;\n     }\n \n@@ -1856,70 +1865,70 @@ dump_expr (tree t, int flags)\n     case OVERLOAD:\n     case TYPE_DECL:\n     case IDENTIFIER_NODE:\n-      dump_decl (t, ((flags & ~(TFF_DECL_SPECIFIERS|TFF_RETURN_TYPE\n-\t\t\t\t|TFF_TEMPLATE_HEADER))\n-\t\t     | TFF_NO_FUNCTION_ARGUMENTS));\n+      dump_decl (pp, t, ((flags & ~(TFF_DECL_SPECIFIERS|TFF_RETURN_TYPE\n+                                    |TFF_TEMPLATE_HEADER))\n+                         | TFF_NO_FUNCTION_ARGUMENTS));\n       break;\n \n     case SSA_NAME:\n       if (SSA_NAME_VAR (t)\n \t  && !DECL_ARTIFICIAL (SSA_NAME_VAR (t)))\n-\tdump_expr (SSA_NAME_VAR (t), flags);\n+\tdump_expr (pp, SSA_NAME_VAR (t), flags);\n       else\n-\tpp_cxx_ws_string (cxx_pp, M_(\"<unknown>\"));\n+\tpp_cxx_ws_string (pp, M_(\"<unknown>\"));\n       break;\n \n     case INTEGER_CST:\n     case REAL_CST:\n     case STRING_CST:\n     case COMPLEX_CST:\n-      pp_constant (cxx_pp, t);\n+      pp_constant (pp, t);\n       break;\n \n     case USERDEF_LITERAL:\n-      pp_cxx_userdef_literal (cxx_pp, t);\n+      pp_cxx_userdef_literal (pp, t);\n       break;\n \n     case THROW_EXPR:\n       /* While waiting for caret diagnostics, avoid printing\n \t __cxa_allocate_exception, __cxa_throw, and the like.  */\n-      pp_cxx_ws_string (cxx_pp, M_(\"<throw-expression>\"));\n+      pp_cxx_ws_string (pp, M_(\"<throw-expression>\"));\n       break;\n \n     case PTRMEM_CST:\n-      pp_ampersand (cxx_pp);\n-      dump_type (PTRMEM_CST_CLASS (t), flags);\n-      pp_cxx_colon_colon (cxx_pp);\n-      pp_cxx_tree_identifier (cxx_pp, DECL_NAME (PTRMEM_CST_MEMBER (t)));\n+      pp_ampersand (pp);\n+      dump_type (pp, PTRMEM_CST_CLASS (t), flags);\n+      pp_cxx_colon_colon (pp);\n+      pp_cxx_tree_identifier (pp, DECL_NAME (PTRMEM_CST_MEMBER (t)));\n       break;\n \n     case COMPOUND_EXPR:\n-      pp_cxx_left_paren (cxx_pp);\n-      dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n-      pp_separate_with_comma (cxx_pp);\n-      dump_expr (TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n-      pp_cxx_right_paren (cxx_pp);\n+      pp_cxx_left_paren (pp);\n+      dump_expr (pp, TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n+      pp_separate_with_comma (pp);\n+      dump_expr (pp, TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n+      pp_cxx_right_paren (pp);\n       break;\n \n     case COND_EXPR:\n-      pp_cxx_left_paren (cxx_pp);\n-      dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n-      pp_string (cxx_pp, \" ? \");\n-      dump_expr (TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n-      pp_string (cxx_pp, \" : \");\n-      dump_expr (TREE_OPERAND (t, 2), flags | TFF_EXPR_IN_PARENS);\n-      pp_cxx_right_paren (cxx_pp);\n+      pp_cxx_left_paren (pp);\n+      dump_expr (pp, TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n+      pp_string (pp, \" ? \");\n+      dump_expr (pp, TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n+      pp_string (pp, \" : \");\n+      dump_expr (pp, TREE_OPERAND (t, 2), flags | TFF_EXPR_IN_PARENS);\n+      pp_cxx_right_paren (pp);\n       break;\n \n     case SAVE_EXPR:\n       if (TREE_HAS_CONSTRUCTOR (t))\n \t{\n-\t  pp_cxx_ws_string (cxx_pp, \"new\");\n-\t  pp_cxx_whitespace (cxx_pp);\n-\t  dump_type (TREE_TYPE (TREE_TYPE (t)), flags);\n+\t  pp_cxx_ws_string (pp, \"new\");\n+\t  pp_cxx_whitespace (pp);\n+\t  dump_type (pp, TREE_TYPE (TREE_TYPE (t)), flags);\n \t}\n       else\n-\tdump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n+\tdump_expr (pp, TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n       break;\n \n     case AGGR_INIT_EXPR:\n@@ -1932,14 +1941,14 @@ dump_expr (tree t, int flags)\n \tif (fn && TREE_CODE (fn) == FUNCTION_DECL)\n \t  {\n \t    if (DECL_CONSTRUCTOR_P (fn))\n-\t      dump_type (DECL_CONTEXT (fn), flags);\n+\t      dump_type (pp, DECL_CONTEXT (fn), flags);\n \t    else\n-\t      dump_decl (fn, 0);\n+\t      dump_decl (pp, fn, 0);\n \t  }\n \telse\n-\t  dump_expr (AGGR_INIT_EXPR_FN (t), 0);\n+\t  dump_expr (pp, AGGR_INIT_EXPR_FN (t), 0);\n       }\n-      dump_aggr_init_expr_args (t, flags, true);\n+      dump_aggr_init_expr_args (pp, t, flags, true);\n       break;\n \n     case CALL_EXPR:\n@@ -1961,19 +1970,20 @@ dump_expr (tree t, int flags)\n \t    tree ob = CALL_EXPR_ARG (t, 0);\n \t    if (TREE_CODE (ob) == ADDR_EXPR)\n \t      {\n-\t\tdump_expr (TREE_OPERAND (ob, 0), flags | TFF_EXPR_IN_PARENS);\n-\t\tpp_cxx_dot (cxx_pp);\n+\t\tdump_expr (pp, TREE_OPERAND (ob, 0),\n+                           flags | TFF_EXPR_IN_PARENS);\n+\t\tpp_cxx_dot (pp);\n \t      }\n \t    else if (TREE_CODE (ob) != PARM_DECL\n \t\t     || strcmp (IDENTIFIER_POINTER (DECL_NAME (ob)), \"this\"))\n \t      {\n-\t\tdump_expr (ob, flags | TFF_EXPR_IN_PARENS);\n-\t\tpp_cxx_arrow (cxx_pp);\n+\t\tdump_expr (pp, ob, flags | TFF_EXPR_IN_PARENS);\n+\t\tpp_cxx_arrow (pp);\n \t      }\n \t    skipfirst = true;\n \t  }\n-\tdump_expr (fn, flags | TFF_EXPR_IN_PARENS);\n-\tdump_call_expr_args (t, flags, skipfirst);\n+\tdump_expr (pp, fn, flags | TFF_EXPR_IN_PARENS);\n+\tdump_call_expr_args (pp, t, flags, skipfirst);\n       }\n       break;\n \n@@ -1984,16 +1994,16 @@ dump_expr (tree t, int flags)\n \t default argument.  Note we may have cleared out the first\n \t operand in expand_expr, so don't go killing ourselves.  */\n       if (TREE_OPERAND (t, 1))\n-\tdump_expr (TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n+\tdump_expr (pp, TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n       break;\n \n     case POINTER_PLUS_EXPR:\n-      dump_binary_op (\"+\", t, flags);\n+      dump_binary_op (pp, \"+\", t, flags);\n       break;\n \n     case INIT_EXPR:\n     case MODIFY_EXPR:\n-      dump_binary_op (assignment_operator_name_info[(int)NOP_EXPR].name,\n+      dump_binary_op (pp, assignment_operator_name_info[NOP_EXPR].name,\n \t\t      t, flags);\n       break;\n \n@@ -2018,20 +2028,20 @@ dump_expr (tree t, int flags)\n     case EQ_EXPR:\n     case NE_EXPR:\n     case EXACT_DIV_EXPR:\n-      dump_binary_op (operator_name_info[(int) TREE_CODE (t)].name, t, flags);\n+      dump_binary_op (pp, operator_name_info[TREE_CODE (t)].name, t, flags);\n       break;\n \n     case CEIL_DIV_EXPR:\n     case FLOOR_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n     case RDIV_EXPR:\n-      dump_binary_op (\"/\", t, flags);\n+      dump_binary_op (pp, \"/\", t, flags);\n       break;\n \n     case CEIL_MOD_EXPR:\n     case FLOOR_MOD_EXPR:\n     case ROUND_MOD_EXPR:\n-      dump_binary_op (\"%\", t, flags);\n+      dump_binary_op (pp, \"%\", t, flags);\n       break;\n \n     case COMPONENT_REF:\n@@ -2044,42 +2054,42 @@ dump_expr (tree t, int flags)\n \t\t|| (DECL_NAME (ob)\n \t\t    && strcmp (IDENTIFIER_POINTER (DECL_NAME (ob)), \"this\")))\n \t      {\n-\t\tdump_expr (ob, flags | TFF_EXPR_IN_PARENS);\n+\t\tdump_expr (pp, ob, flags | TFF_EXPR_IN_PARENS);\n \t\tif (TREE_CODE (TREE_TYPE (ob)) == REFERENCE_TYPE)\n-\t\t  pp_cxx_dot (cxx_pp);\n+\t\t  pp_cxx_dot (pp);\n \t\telse\n-\t\t  pp_cxx_arrow (cxx_pp);\n+\t\t  pp_cxx_arrow (pp);\n \t      }\n \t  }\n \telse\n \t  {\n-\t    dump_expr (ob, flags | TFF_EXPR_IN_PARENS);\n-\t    pp_cxx_dot (cxx_pp);\n+\t    dump_expr (pp, ob, flags | TFF_EXPR_IN_PARENS);\n+\t    pp_cxx_dot (pp);\n \t  }\n-\tdump_expr (TREE_OPERAND (t, 1), flags & ~TFF_EXPR_IN_PARENS);\n+\tdump_expr (pp, TREE_OPERAND (t, 1), flags & ~TFF_EXPR_IN_PARENS);\n       }\n       break;\n \n     case ARRAY_REF:\n-      dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n-      pp_cxx_left_bracket (cxx_pp);\n-      dump_expr (TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n-      pp_cxx_right_bracket (cxx_pp);\n+      dump_expr (pp, TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n+      pp_cxx_left_bracket (pp);\n+      dump_expr (pp, TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n+      pp_cxx_right_bracket (pp);\n       break;\n \n     case ARRAY_NOTATION_REF:\n-      dump_expr (ARRAY_NOTATION_ARRAY (t), flags | TFF_EXPR_IN_PARENS);\n-      pp_cxx_left_bracket (cxx_pp);\n-      dump_expr (ARRAY_NOTATION_START (t), flags | TFF_EXPR_IN_PARENS);\n-      pp_colon (cxx_pp);\n-      dump_expr (ARRAY_NOTATION_LENGTH (t), flags | TFF_EXPR_IN_PARENS);\n-      pp_colon (cxx_pp);\n-      dump_expr (ARRAY_NOTATION_STRIDE (t), flags | TFF_EXPR_IN_PARENS);\n-      pp_cxx_right_bracket (cxx_pp);\n+      dump_expr (pp, ARRAY_NOTATION_ARRAY (t), flags | TFF_EXPR_IN_PARENS);\n+      pp_cxx_left_bracket (pp);\n+      dump_expr (pp, ARRAY_NOTATION_START (t), flags | TFF_EXPR_IN_PARENS);\n+      pp_colon (pp);\n+      dump_expr (pp, ARRAY_NOTATION_LENGTH (t), flags | TFF_EXPR_IN_PARENS);\n+      pp_colon (pp);\n+      dump_expr (pp, ARRAY_NOTATION_STRIDE (t), flags | TFF_EXPR_IN_PARENS);\n+      pp_cxx_right_bracket (pp);\n       break;\n \n     case UNARY_PLUS_EXPR:\n-      dump_unary_op (\"+\", t, flags);\n+      dump_unary_op (pp, \"+\", t, flags);\n       break;\n \n     case ADDR_EXPR:\n@@ -2090,56 +2100,57 @@ dump_expr (tree t, int flags)\n \t     that the expression has pointer type.  */\n \t  || (TREE_TYPE (t)\n \t      && TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE))\n-\tdump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n+\tdump_expr (pp, TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n       else if (TREE_CODE (TREE_OPERAND (t, 0)) == LABEL_DECL)\n-\tdump_unary_op (\"&&\", t, flags);\n+\tdump_unary_op (pp, \"&&\", t, flags);\n       else\n-\tdump_unary_op (\"&\", t, flags);\n+\tdump_unary_op (pp, \"&\", t, flags);\n       break;\n \n     case INDIRECT_REF:\n       if (TREE_HAS_CONSTRUCTOR (t))\n \t{\n \t  t = TREE_OPERAND (t, 0);\n \t  gcc_assert (TREE_CODE (t) == CALL_EXPR);\n-\t  dump_expr (CALL_EXPR_FN (t), flags | TFF_EXPR_IN_PARENS);\n-\t  dump_call_expr_args (t, flags, true);\n+\t  dump_expr (pp, CALL_EXPR_FN (t), flags | TFF_EXPR_IN_PARENS);\n+\t  dump_call_expr_args (pp, t, flags, true);\n \t}\n       else\n \t{\n \t  if (TREE_OPERAND (t,0) != NULL_TREE\n \t      && TREE_TYPE (TREE_OPERAND (t, 0))\n \t      && NEXT_CODE (TREE_OPERAND (t, 0)) == REFERENCE_TYPE)\n-\t    dump_expr (TREE_OPERAND (t, 0), flags);\n+\t    dump_expr (pp, TREE_OPERAND (t, 0), flags);\n \t  else\n-\t    dump_unary_op (\"*\", t, flags);\n+\t    dump_unary_op (pp, \"*\", t, flags);\n \t}\n       break;\n \n     case MEM_REF:\n       if (TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR\n \t  && integer_zerop (TREE_OPERAND (t, 1)))\n-\tdump_expr (TREE_OPERAND (TREE_OPERAND (t, 0), 0), flags);\n+\tdump_expr (pp, TREE_OPERAND (TREE_OPERAND (t, 0), 0), flags);\n       else\n \t{\n-\t  pp_cxx_star (cxx_pp);\n+\t  pp_cxx_star (pp);\n \t  if (!integer_zerop (TREE_OPERAND (t, 1)))\n \t    {\n-\t      pp_cxx_left_paren (cxx_pp);\n+\t      pp_cxx_left_paren (pp);\n \t      if (!integer_onep (TYPE_SIZE_UNIT\n \t\t\t\t (TREE_TYPE (TREE_TYPE (TREE_OPERAND (t, 0))))))\n \t\t{\n-\t\t  pp_cxx_left_paren (cxx_pp);\n-\t\t  dump_type (ptr_type_node, flags);\n-\t\t  pp_cxx_right_paren (cxx_pp);\n+\t\t  pp_cxx_left_paren (pp);\n+\t\t  dump_type (pp, ptr_type_node, flags);\n+\t\t  pp_cxx_right_paren (pp);\n \t\t}\n \t    }\n-\t  dump_expr (TREE_OPERAND (t, 0), flags);\n+\t  dump_expr (pp, TREE_OPERAND (t, 0), flags);\n \t  if (!integer_zerop (TREE_OPERAND (t, 1)))\n \t    {\n-\t      pp_cxx_ws_string (cxx_pp, \"+\");\n-\t      dump_expr (fold_convert (ssizetype, TREE_OPERAND (t, 1)), flags);\n-\t      pp_cxx_right_paren (cxx_pp);\n+\t      pp_cxx_ws_string (pp, \"+\");\n+\t      dump_expr (pp, fold_convert (ssizetype, TREE_OPERAND (t, 1)),\n+                         flags);\n+\t      pp_cxx_right_paren (pp);\n \t    }\n \t}\n       break;\n@@ -2149,15 +2160,15 @@ dump_expr (tree t, int flags)\n     case TRUTH_NOT_EXPR:\n     case PREDECREMENT_EXPR:\n     case PREINCREMENT_EXPR:\n-      dump_unary_op (operator_name_info [(int)TREE_CODE (t)].name, t, flags);\n+      dump_unary_op (pp, operator_name_info [TREE_CODE (t)].name, t, flags);\n       break;\n \n     case POSTDECREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n-      pp_cxx_left_paren (cxx_pp);\n-      dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n-      pp_cxx_ws_string (cxx_pp, operator_name_info[(int)TREE_CODE (t)].name);\n-      pp_cxx_right_paren (cxx_pp);\n+      pp_cxx_left_paren (pp);\n+      dump_expr (pp, TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n+      pp_cxx_ws_string (pp, operator_name_info[TREE_CODE (t)].name);\n+      pp_cxx_right_paren (pp);\n       break;\n \n     case NON_LVALUE_EXPR:\n@@ -2174,16 +2185,16 @@ dump_expr (tree t, int flags)\n \t  if (TREE_CODE (next) == FUNCTION_TYPE)\n \t    {\n \t      if (flags & TFF_EXPR_IN_PARENS)\n-\t\tpp_cxx_left_paren (cxx_pp);\n-\t      pp_cxx_star (cxx_pp);\n-\t      dump_expr (TREE_OPERAND (t, 0), flags & ~TFF_EXPR_IN_PARENS);\n+\t\tpp_cxx_left_paren (pp);\n+\t      pp_cxx_star (pp);\n+\t      dump_expr (pp, TREE_OPERAND (t, 0), flags & ~TFF_EXPR_IN_PARENS);\n \t      if (flags & TFF_EXPR_IN_PARENS)\n-\t\tpp_cxx_right_paren (cxx_pp);\n+\t\tpp_cxx_right_paren (pp);\n \t      break;\n \t    }\n \t  /* Else fall through.  */\n \t}\n-      dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n+      dump_expr (pp, TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n       break;\n \n     CASE_CONVERT:\n@@ -2201,25 +2212,25 @@ dump_expr (tree t, int flags)\n \t\t\t    TREE_TYPE (ttype)))\n \t  {\n \t    if (TREE_CODE (ttype) == REFERENCE_TYPE)\n-\t      dump_unary_op (\"*\", t, flags);\n+\t      dump_unary_op (pp, \"*\", t, flags);\n \t    else\n-\t      dump_unary_op (\"&\", t, flags);\n+\t      dump_unary_op (pp, \"&\", t, flags);\n \t  }\n \telse if (!same_type_p (TREE_TYPE (op), TREE_TYPE (t)))\n \t  {\n \t    /* It is a cast, but we cannot tell whether it is a\n \t       reinterpret or static cast. Use the C style notation.  */\n \t    if (flags & TFF_EXPR_IN_PARENS)\n-\t      pp_cxx_left_paren (cxx_pp);\n-\t    pp_cxx_left_paren (cxx_pp);\n-\t    dump_type (TREE_TYPE (t), flags);\n-\t    pp_cxx_right_paren (cxx_pp);\n-\t    dump_expr (op, flags | TFF_EXPR_IN_PARENS);\n+\t      pp_cxx_left_paren (pp);\n+\t    pp_cxx_left_paren (pp);\n+\t    dump_type (pp, TREE_TYPE (t), flags);\n+\t    pp_cxx_right_paren (pp);\n+\t    dump_expr (pp, op, flags | TFF_EXPR_IN_PARENS);\n \t    if (flags & TFF_EXPR_IN_PARENS)\n-\t      pp_cxx_right_paren (cxx_pp);\n+\t      pp_cxx_right_paren (pp);\n \t  }\n \telse\n-\t  dump_expr (op, flags);\n+\t  dump_expr (pp, op, flags);\n \tbreak;\n       }\n \n@@ -2231,12 +2242,12 @@ dump_expr (tree t, int flags)\n \t  if (integer_zerop (idx))\n \t    {\n \t      /* A NULL pointer-to-member constant.  */\n-\t      pp_cxx_left_paren (cxx_pp);\n-\t      pp_cxx_left_paren (cxx_pp);\n-\t      dump_type (TREE_TYPE (t), flags);\n-\t      pp_cxx_right_paren (cxx_pp);\n-\t      pp_character (cxx_pp, '0');\n-\t      pp_cxx_right_paren (cxx_pp);\n+\t      pp_cxx_left_paren (pp);\n+\t      pp_cxx_left_paren (pp);\n+\t      dump_type (pp, TREE_TYPE (t), flags);\n+\t      pp_cxx_right_paren (pp);\n+\t      pp_character (pp, '0');\n+\t      pp_cxx_right_paren (pp);\n \t      break;\n \t    }\n \t  else if (host_integerp (idx, 0))\n@@ -2261,27 +2272,27 @@ dump_expr (tree t, int flags)\n \t\t}\n \t      if (virtuals)\n \t\t{\n-\t\t  dump_expr (BV_FN (virtuals),\n+\t\t  dump_expr (pp, BV_FN (virtuals),\n \t\t\t     flags | TFF_EXPR_IN_PARENS);\n \t\t  break;\n \t\t}\n \t    }\n \t}\n       if (TREE_TYPE (t) && LAMBDA_TYPE_P (TREE_TYPE (t)))\n-\tpp_string (cxx_pp, \"<lambda closure object>\");\n+\tpp_string (pp, \"<lambda closure object>\");\n       if (TREE_TYPE (t) && EMPTY_CONSTRUCTOR_P (t))\n \t{\n-\t  dump_type (TREE_TYPE (t), 0);\n-\t  pp_cxx_left_paren (cxx_pp);\n-\t  pp_cxx_right_paren (cxx_pp);\n+\t  dump_type (pp, TREE_TYPE (t), 0);\n+\t  pp_cxx_left_paren (pp);\n+\t  pp_cxx_right_paren (pp);\n \t}\n       else\n \t{\n \t  if (!BRACE_ENCLOSED_INITIALIZER_P (t))\n-\t    dump_type (TREE_TYPE (t), 0);\n-\t  pp_cxx_left_brace (cxx_pp);\n-\t  dump_expr_init_vec (CONSTRUCTOR_ELTS (t), flags);\n-\t  pp_cxx_right_brace (cxx_pp);\n+\t    dump_type (pp, TREE_TYPE (t), 0);\n+\t  pp_cxx_left_brace (pp);\n+\t  dump_expr_init_vec (pp, CONSTRUCTOR_ELTS (t), flags);\n+\t  pp_cxx_right_brace (pp);\n \t}\n \n       break;\n@@ -2294,151 +2305,151 @@ dump_expr (tree t, int flags)\n \t    t = TREE_OPERAND (t, 1);\n \t    if (TREE_CODE (t) == FUNCTION_DECL)\n \t      /* A::f */\n-\t      dump_expr (t, flags | TFF_EXPR_IN_PARENS);\n+\t      dump_expr (pp, t, flags | TFF_EXPR_IN_PARENS);\n \t    else if (BASELINK_P (t))\n-\t      dump_expr (OVL_CURRENT (BASELINK_FUNCTIONS (t)),\n+\t      dump_expr (pp, OVL_CURRENT (BASELINK_FUNCTIONS (t)),\n \t\t\t flags | TFF_EXPR_IN_PARENS);\n \t    else\n-\t      dump_decl (t, flags);\n+\t      dump_decl (pp, t, flags);\n \t  }\n \telse\n \t  {\n \t    if (INDIRECT_REF_P (ob))\n \t      {\n-\t\tdump_expr (TREE_OPERAND (ob, 0), flags | TFF_EXPR_IN_PARENS);\n-\t\tpp_cxx_arrow (cxx_pp);\n-\t\tpp_cxx_star (cxx_pp);\n+\t\tdump_expr (pp, TREE_OPERAND (ob, 0), flags | TFF_EXPR_IN_PARENS);\n+\t\tpp_cxx_arrow (pp);\n+\t\tpp_cxx_star (pp);\n \t      }\n \t    else\n \t      {\n-\t\tdump_expr (ob, flags | TFF_EXPR_IN_PARENS);\n-\t\tpp_cxx_dot (cxx_pp);\n-\t\tpp_cxx_star (cxx_pp);\n+\t\tdump_expr (pp, ob, flags | TFF_EXPR_IN_PARENS);\n+\t\tpp_cxx_dot (pp);\n+\t\tpp_cxx_star (pp);\n \t      }\n-\t    dump_expr (TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n+\t    dump_expr (pp, TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n \t  }\n \tbreak;\n       }\n \n     case TEMPLATE_PARM_INDEX:\n-      dump_decl (TEMPLATE_PARM_DECL (t), flags & ~TFF_DECL_SPECIFIERS);\n+      dump_decl (pp, TEMPLATE_PARM_DECL (t), flags & ~TFF_DECL_SPECIFIERS);\n       break;\n \n     case CAST_EXPR:\n       if (TREE_OPERAND (t, 0) == NULL_TREE\n \t  || TREE_CHAIN (TREE_OPERAND (t, 0)))\n \t{\n-\t  dump_type (TREE_TYPE (t), flags);\n-\t  pp_cxx_left_paren (cxx_pp);\n-\t  dump_expr_list (TREE_OPERAND (t, 0), flags);\n-\t  pp_cxx_right_paren (cxx_pp);\n+\t  dump_type (pp, TREE_TYPE (t), flags);\n+\t  pp_cxx_left_paren (pp);\n+\t  dump_expr_list (pp, TREE_OPERAND (t, 0), flags);\n+\t  pp_cxx_right_paren (pp);\n \t}\n       else\n \t{\n-\t  pp_cxx_left_paren (cxx_pp);\n-\t  dump_type (TREE_TYPE (t), flags);\n-\t  pp_cxx_right_paren (cxx_pp);\n-\t  pp_cxx_left_paren (cxx_pp);\n-\t  dump_expr_list (TREE_OPERAND (t, 0), flags);\n-\t  pp_cxx_right_paren (cxx_pp);\n+\t  pp_cxx_left_paren (pp);\n+\t  dump_type (pp, TREE_TYPE (t), flags);\n+\t  pp_cxx_right_paren (pp);\n+\t  pp_cxx_left_paren (pp);\n+\t  dump_expr_list (pp, TREE_OPERAND (t, 0), flags);\n+\t  pp_cxx_right_paren (pp);\n \t}\n       break;\n \n     case STATIC_CAST_EXPR:\n-      pp_cxx_ws_string (cxx_pp, \"static_cast\");\n+      pp_cxx_ws_string (pp, \"static_cast\");\n       goto cast;\n     case REINTERPRET_CAST_EXPR:\n-      pp_cxx_ws_string (cxx_pp, \"reinterpret_cast\");\n+      pp_cxx_ws_string (pp, \"reinterpret_cast\");\n       goto cast;\n     case CONST_CAST_EXPR:\n-      pp_cxx_ws_string (cxx_pp, \"const_cast\");\n+      pp_cxx_ws_string (pp, \"const_cast\");\n       goto cast;\n     case DYNAMIC_CAST_EXPR:\n-      pp_cxx_ws_string (cxx_pp, \"dynamic_cast\");\n+      pp_cxx_ws_string (pp, \"dynamic_cast\");\n     cast:\n-      pp_cxx_begin_template_argument_list (cxx_pp);\n-      dump_type (TREE_TYPE (t), flags);\n-      pp_cxx_end_template_argument_list (cxx_pp);\n-      pp_cxx_left_paren (cxx_pp);\n-      dump_expr (TREE_OPERAND (t, 0), flags);\n-      pp_cxx_right_paren (cxx_pp);\n+      pp_cxx_begin_template_argument_list (pp);\n+      dump_type (pp, TREE_TYPE (t), flags);\n+      pp_cxx_end_template_argument_list (pp);\n+      pp_cxx_left_paren (pp);\n+      dump_expr (pp, TREE_OPERAND (t, 0), flags);\n+      pp_cxx_right_paren (pp);\n       break;\n \n     case ARROW_EXPR:\n-      dump_expr (TREE_OPERAND (t, 0), flags);\n-      pp_cxx_arrow (cxx_pp);\n+      dump_expr (pp, TREE_OPERAND (t, 0), flags);\n+      pp_cxx_arrow (pp);\n       break;\n \n     case SIZEOF_EXPR:\n     case ALIGNOF_EXPR:\n       if (TREE_CODE (t) == SIZEOF_EXPR)\n-\tpp_cxx_ws_string (cxx_pp, \"sizeof\");\n+\tpp_cxx_ws_string (pp, \"sizeof\");\n       else\n \t{\n \t  gcc_assert (TREE_CODE (t) == ALIGNOF_EXPR);\n-\t  pp_cxx_ws_string (cxx_pp, \"__alignof__\");\n+\t  pp_cxx_ws_string (pp, \"__alignof__\");\n \t}\n       op = TREE_OPERAND (t, 0);\n       if (PACK_EXPANSION_P (op))\n \t{\n-\t  pp_string (cxx_pp, \"...\");\n+\t  pp_string (pp, \"...\");\n \t  op = PACK_EXPANSION_PATTERN (op);\n \t}\n-      pp_cxx_whitespace (cxx_pp);\n-      pp_cxx_left_paren (cxx_pp);\n+      pp_cxx_whitespace (pp);\n+      pp_cxx_left_paren (pp);\n       if (TREE_CODE (t) == SIZEOF_EXPR && SIZEOF_EXPR_TYPE_P (t))\n-\tdump_type (TREE_TYPE (op), flags);\n+\tdump_type (pp, TREE_TYPE (op), flags);\n       else if (TYPE_P (TREE_OPERAND (t, 0)))\n-\tdump_type (op, flags);\n+\tdump_type (pp, op, flags);\n       else\n-\tdump_expr (op, flags);\n-      pp_cxx_right_paren (cxx_pp);\n+\tdump_expr (pp, op, flags);\n+      pp_cxx_right_paren (pp);\n       break;\n \n     case AT_ENCODE_EXPR:\n-      pp_cxx_ws_string (cxx_pp, \"@encode\");\n-      pp_cxx_whitespace (cxx_pp);\n-      pp_cxx_left_paren (cxx_pp);\n-      dump_type (TREE_OPERAND (t, 0), flags);\n-      pp_cxx_right_paren (cxx_pp);\n+      pp_cxx_ws_string (pp, \"@encode\");\n+      pp_cxx_whitespace (pp);\n+      pp_cxx_left_paren (pp);\n+      dump_type (pp, TREE_OPERAND (t, 0), flags);\n+      pp_cxx_right_paren (pp);\n       break;\n \n     case NOEXCEPT_EXPR:\n-      pp_cxx_ws_string (cxx_pp, \"noexcept\");\n-      pp_cxx_whitespace (cxx_pp);\n-      pp_cxx_left_paren (cxx_pp);\n-      dump_expr (TREE_OPERAND (t, 0), flags);\n-      pp_cxx_right_paren (cxx_pp);\n+      pp_cxx_ws_string (pp, \"noexcept\");\n+      pp_cxx_whitespace (pp);\n+      pp_cxx_left_paren (pp);\n+      dump_expr (pp, TREE_OPERAND (t, 0), flags);\n+      pp_cxx_right_paren (pp);\n       break;\n \n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-      pp_cxx_ws_string (cxx_pp, operator_name_info[TREE_CODE (t)].name);\n-      pp_cxx_whitespace (cxx_pp);\n-      dump_expr (TREE_OPERAND (t, 0), flags);\n+      pp_cxx_ws_string (pp, operator_name_info[TREE_CODE (t)].name);\n+      pp_cxx_whitespace (pp);\n+      dump_expr (pp, TREE_OPERAND (t, 0), flags);\n       break;\n \n     case DEFAULT_ARG:\n-      pp_string (cxx_pp, M_(\"<unparsed>\"));\n+      pp_string (pp, M_(\"<unparsed>\"));\n       break;\n \n     case TRY_CATCH_EXPR:\n     case WITH_CLEANUP_EXPR:\n     case CLEANUP_POINT_EXPR:\n-      dump_expr (TREE_OPERAND (t, 0), flags);\n+      dump_expr (pp, TREE_OPERAND (t, 0), flags);\n       break;\n \n     case PSEUDO_DTOR_EXPR:\n-      dump_expr (TREE_OPERAND (t, 2), flags);\n-      pp_cxx_dot (cxx_pp);\n-      dump_type (TREE_OPERAND (t, 0), flags);\n-      pp_cxx_colon_colon (cxx_pp);\n-      pp_cxx_complement (cxx_pp);\n-      dump_type (TREE_OPERAND (t, 1), flags);\n+      dump_expr (pp, TREE_OPERAND (t, 2), flags);\n+      pp_cxx_dot (pp);\n+      dump_type (pp, TREE_OPERAND (t, 0), flags);\n+      pp_cxx_colon_colon (pp);\n+      pp_cxx_complement (pp);\n+      dump_type (pp, TREE_OPERAND (t, 1), flags);\n       break;\n \n     case TEMPLATE_ID_EXPR:\n-      dump_decl (t, flags);\n+      dump_decl (pp, t, flags);\n       break;\n \n     case BIND_EXPR:\n@@ -2447,37 +2458,37 @@ dump_expr (tree t, int flags)\n     case STATEMENT_LIST:\n       /* We don't yet have a way of dumping statements in a\n \t human-readable format.  */\n-      pp_string (cxx_pp, \"({...})\");\n+      pp_string (pp, \"({...})\");\n       break;\n \n     case LOOP_EXPR:\n-      pp_string (cxx_pp, \"while (1) { \");\n-      dump_expr (TREE_OPERAND (t, 0), flags & ~TFF_EXPR_IN_PARENS);\n-      pp_cxx_right_brace (cxx_pp);\n+      pp_string (pp, \"while (1) { \");\n+      dump_expr (pp, TREE_OPERAND (t, 0), flags & ~TFF_EXPR_IN_PARENS);\n+      pp_cxx_right_brace (pp);\n       break;\n \n     case EXIT_EXPR:\n-      pp_string (cxx_pp, \"if (\");\n-      dump_expr (TREE_OPERAND (t, 0), flags & ~TFF_EXPR_IN_PARENS);\n-      pp_string (cxx_pp, \") break; \");\n+      pp_string (pp, \"if (\");\n+      dump_expr (pp, TREE_OPERAND (t, 0), flags & ~TFF_EXPR_IN_PARENS);\n+      pp_string (pp, \") break; \");\n       break;\n \n     case BASELINK:\n-      dump_expr (BASELINK_FUNCTIONS (t), flags & ~TFF_EXPR_IN_PARENS);\n+      dump_expr (pp, BASELINK_FUNCTIONS (t), flags & ~TFF_EXPR_IN_PARENS);\n       break;\n \n     case EMPTY_CLASS_EXPR:\n-      dump_type (TREE_TYPE (t), flags);\n-      pp_cxx_left_paren (cxx_pp);\n-      pp_cxx_right_paren (cxx_pp);\n+      dump_type (pp, TREE_TYPE (t), flags);\n+      pp_cxx_left_paren (pp);\n+      pp_cxx_right_paren (pp);\n       break;\n \n     case NON_DEPENDENT_EXPR:\n-      dump_expr (TREE_OPERAND (t, 0), flags);\n+      dump_expr (pp, TREE_OPERAND (t, 0), flags);\n       break;\n \n     case ARGUMENT_PACK_SELECT:\n-      dump_template_argument (ARGUMENT_PACK_SELECT_FROM_PACK (t), flags);\n+      dump_template_argument (pp, ARGUMENT_PACK_SELECT_FROM_PACK (t), flags);\n       break;\n \n     case RECORD_TYPE:\n@@ -2489,35 +2500,35 @@ dump_expr (tree t, int flags)\n     case INTEGER_TYPE:\n     case COMPLEX_TYPE:\n     case VECTOR_TYPE:\n-      pp_type_specifier_seq (cxx_pp, t);\n+      pp_type_specifier_seq (pp, t);\n       break;\n \n     case TYPENAME_TYPE:\n       /* We get here when we want to print a dependent type as an\n          id-expression, without any disambiguator decoration.  */\n-      pp_id_expression (cxx_pp, t);\n+      pp_id_expression (pp, t);\n       break;\n \n     case TEMPLATE_TYPE_PARM:\n     case TEMPLATE_TEMPLATE_PARM:\n     case BOUND_TEMPLATE_TEMPLATE_PARM:\n-      dump_type (t, flags);\n+      dump_type (pp, t, flags);\n       break;\n \n     case TRAIT_EXPR:\n-      pp_cxx_trait_expression (cxx_pp, t);\n+      pp_cxx_trait_expression (pp, t);\n       break;\n \n     case VA_ARG_EXPR:\n-      pp_cxx_va_arg_expression (cxx_pp, t);\n+      pp_cxx_va_arg_expression (pp, t);\n       break;\n \n     case OFFSETOF_EXPR:\n-      pp_cxx_offsetof_expression (cxx_pp, t);\n+      pp_cxx_offsetof_expression (pp, t);\n       break;\n \n     case SCOPE_REF:\n-      dump_decl (t, flags);\n+      dump_decl (pp, t, flags);\n       break;\n \n     case EXPR_PACK_EXPANSION:\n@@ -2545,69 +2556,70 @@ dump_expr (tree t, int flags)\n     case BIT_FIELD_REF:\n     case FIX_TRUNC_EXPR:\n     case FLOAT_EXPR:\n-      pp_expression (cxx_pp, t);\n+      pp_expression (pp, t);\n       break;\n \n     case TRUTH_AND_EXPR:\n     case TRUTH_OR_EXPR:\n     case TRUTH_XOR_EXPR:\n       if (flags & TFF_EXPR_IN_PARENS)\n-\tpp_cxx_left_paren (cxx_pp);\n-      pp_expression (cxx_pp, t);\n+\tpp_cxx_left_paren (pp);\n+      pp_expression (pp, t);\n       if (flags & TFF_EXPR_IN_PARENS)\n-\tpp_cxx_right_paren (cxx_pp);\n+\tpp_cxx_right_paren (pp);\n       break;\n \n     case OBJ_TYPE_REF:\n-      dump_expr (resolve_virtual_fun_from_obj_type_ref (t), flags);\n+      dump_expr (pp, resolve_virtual_fun_from_obj_type_ref (t), flags);\n       break;\n \n     case LAMBDA_EXPR:\n-      pp_string (cxx_pp, M_(\"<lambda>\"));\n+      pp_string (pp, M_(\"<lambda>\"));\n       break;\n \n     case PAREN_EXPR:\n-      pp_cxx_left_paren (cxx_pp);\n-      dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n-      pp_cxx_right_paren (cxx_pp);\n+      pp_cxx_left_paren (pp);\n+      dump_expr (pp, TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n+      pp_cxx_right_paren (pp);\n       break;\n \n       /*  This list is incomplete, but should suffice for now.\n \t  It is very important that `sorry' does not call\n \t  `report_error_function'.  That could cause an infinite loop.  */\n     default:\n-      pp_unsupported_tree (cxx_pp, t);\n+      pp_unsupported_tree (pp, t);\n       /* fall through to ERROR_MARK...  */\n     case ERROR_MARK:\n-      pp_string (cxx_pp, M_(\"<expression error>\"));\n+      pp_string (pp, M_(\"<expression error>\"));\n       break;\n     }\n }\n \n static void\n-dump_binary_op (const char *opstring, tree t, int flags)\n+dump_binary_op (cxx_pretty_printer *pp, const char *opstring, tree t,\n+                int flags)\n {\n-  pp_cxx_left_paren (cxx_pp);\n-  dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n-  pp_cxx_whitespace (cxx_pp);\n+  pp_cxx_left_paren (pp);\n+  dump_expr (pp, TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n+  pp_cxx_whitespace (pp);\n   if (opstring)\n-    pp_cxx_ws_string (cxx_pp, opstring);\n+    pp_cxx_ws_string (pp, opstring);\n   else\n-    pp_string (cxx_pp, M_(\"<unknown operator>\"));\n-  pp_cxx_whitespace (cxx_pp);\n-  dump_expr (TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n-  pp_cxx_right_paren (cxx_pp);\n+    pp_string (pp, M_(\"<unknown operator>\"));\n+  pp_cxx_whitespace (pp);\n+  dump_expr (pp, TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n+  pp_cxx_right_paren (pp);\n }\n \n static void\n-dump_unary_op (const char *opstring, tree t, int flags)\n+dump_unary_op (cxx_pretty_printer *pp, const char *opstring, tree t, int flags)\n {\n   if (flags & TFF_EXPR_IN_PARENS)\n-    pp_cxx_left_paren (cxx_pp);\n-  pp_cxx_ws_string (cxx_pp, opstring);\n-  dump_expr (TREE_OPERAND (t, 0), flags & ~TFF_EXPR_IN_PARENS);\n+    pp_cxx_left_paren (pp);\n+  pp_cxx_ws_string (pp, opstring);\n+  dump_expr (pp, TREE_OPERAND (t, 0), flags & ~TFF_EXPR_IN_PARENS);\n   if (flags & TFF_EXPR_IN_PARENS)\n-    pp_cxx_right_paren (cxx_pp);\n+    pp_cxx_right_paren (pp);\n }\n \n static void\n@@ -2629,15 +2641,15 @@ type_as_string (tree typ, int flags)\n {\n   reinit_cxx_pp ();\n   pp_translate_identifiers (cxx_pp) = false;\n-  dump_type (typ, flags);\n+  dump_type (cxx_pp, typ, flags);\n   return pp_formatted_text (cxx_pp);\n }\n \n const char *\n type_as_string_translate (tree typ, int flags)\n {\n   reinit_cxx_pp ();\n-  dump_type (typ, flags);\n+  dump_type (cxx_pp, typ, flags);\n   return pp_formatted_text (cxx_pp);\n }\n \n@@ -2646,7 +2658,7 @@ expr_as_string (tree decl, int flags)\n {\n   reinit_cxx_pp ();\n   pp_translate_identifiers (cxx_pp) = false;\n-  dump_expr (decl, flags);\n+  dump_expr (cxx_pp, decl, flags);\n   return pp_formatted_text (cxx_pp);\n }\n \n@@ -2670,15 +2682,15 @@ decl_as_string (tree decl, int flags)\n {\n   reinit_cxx_pp ();\n   pp_translate_identifiers (cxx_pp) = false;\n-  dump_decl (decl, flags);\n+  dump_decl (cxx_pp, decl, flags);\n   return pp_formatted_text (cxx_pp);\n }\n \n const char *\n decl_as_string_translate (tree decl, int flags)\n {\n   reinit_cxx_pp ();\n-  dump_decl (decl, flags);\n+  dump_decl (cxx_pp, decl, flags);\n   return pp_formatted_text (cxx_pp);\n }\n \n@@ -2714,17 +2726,17 @@ lang_decl_name (tree decl, int v, bool translate)\n \t  || (DECL_NAMESPACE_SCOPE_P (decl)\n \t      && CP_DECL_CONTEXT (decl) != global_namespace)))\n     {\n-      dump_type (CP_DECL_CONTEXT (decl), TFF_PLAIN_IDENTIFIER);\n+      dump_type (cxx_pp, CP_DECL_CONTEXT (decl), TFF_PLAIN_IDENTIFIER);\n       pp_cxx_colon_colon (cxx_pp);\n     }\n \n   if (TREE_CODE (decl) == FUNCTION_DECL)\n-    dump_function_name (decl, TFF_PLAIN_IDENTIFIER);\n+    dump_function_name (cxx_pp, decl, TFF_PLAIN_IDENTIFIER);\n   else if ((DECL_NAME (decl) == NULL_TREE)\n            && TREE_CODE (decl) == NAMESPACE_DECL)\n-    dump_decl (decl, TFF_PLAIN_IDENTIFIER | TFF_UNQUALIFIED_NAME);\n+    dump_decl (cxx_pp, decl, TFF_PLAIN_IDENTIFIER | TFF_UNQUALIFIED_NAME);\n   else\n-    dump_decl (DECL_NAME (decl), TFF_PLAIN_IDENTIFIER);\n+    dump_decl (cxx_pp, DECL_NAME (decl), TFF_PLAIN_IDENTIFIER);\n \n   return pp_formatted_text (cxx_pp);\n }\n@@ -2769,15 +2781,15 @@ decl_to_string (tree decl, int verbose)\n   flags |= TFF_TEMPLATE_HEADER;\n \n   reinit_cxx_pp ();\n-  dump_decl (decl, flags);\n+  dump_decl (cxx_pp, decl, flags);\n   return pp_formatted_text (cxx_pp);\n }\n \n static const char *\n expr_to_string (tree decl)\n {\n   reinit_cxx_pp ();\n-  dump_expr (decl, 0);\n+  dump_expr (cxx_pp, decl, 0);\n   return pp_formatted_text (cxx_pp);\n }\n \n@@ -2791,7 +2803,7 @@ fndecl_to_string (tree fndecl, int verbose)\n   if (verbose)\n     flags |= TFF_FUNCTION_DEFAULT_ARGUMENTS;\n   reinit_cxx_pp ();\n-  dump_decl (fndecl, flags);\n+  dump_decl (cxx_pp, fndecl, flags);\n   return pp_formatted_text (cxx_pp);\n }\n \n@@ -2838,7 +2850,7 @@ parm_to_string (int p)\n static const char *\n op_to_string (enum tree_code p)\n {\n-  tree id = operator_name_info[(int) p].identifier;\n+  tree id = operator_name_info[p].identifier;\n   return id ? IDENTIFIER_POINTER (id) : M_(\"<unknown>\");\n }\n \n@@ -2851,7 +2863,7 @@ type_to_string (tree typ, int verbose)\n   flags |= TFF_TEMPLATE_HEADER;\n \n   reinit_cxx_pp ();\n-  dump_type (typ, flags);\n+  dump_type (cxx_pp, typ, flags);\n   /* If we're printing a type that involves typedefs, also print the\n      stripped version.  But sometimes the stripped version looks\n      exactly the same, so we don't want it after all.  To avoid printing\n@@ -2868,7 +2880,7 @@ type_to_string (tree typ, int verbose)\n       pp_cxx_whitespace (cxx_pp);\n       /* And remember the start of the aka dump.  */\n       aka_start = obstack_object_size (ob);\n-      dump_type (aka, flags);\n+      dump_type (cxx_pp, aka, flags);\n       pp_right_brace (cxx_pp);\n       p = (char*)obstack_base (ob);\n       /* If they are identical, cut off the aka with a NUL.  */\n@@ -2904,7 +2916,7 @@ args_to_string (tree p, int verbose)\n       if (TREE_VALUE (p) == null_node)\n \tpp_cxx_ws_string (cxx_pp, \"NULL\");\n       else\n-\tdump_type (error_type (TREE_VALUE (p)), flags);\n+\tdump_type (cxx_pp, error_type (TREE_VALUE (p)), flags);\n       if (TREE_CHAIN (p))\n \tpp_separate_with_comma (cxx_pp);\n     }\n@@ -2928,12 +2940,12 @@ subst_to_string (tree p)\n     return \"\";\n \n   reinit_cxx_pp ();\n-  dump_template_decl (TREE_PURPOSE (p), flags);\n+  dump_template_decl (cxx_pp, TREE_PURPOSE (p), flags);\n   pp_cxx_whitespace (cxx_pp);\n   pp_cxx_left_bracket (cxx_pp);\n   pp_cxx_ws_string (cxx_pp, M_(\"with\"));\n   pp_cxx_whitespace (cxx_pp);\n-  dump_template_bindings (tparms, targs, NULL);\n+  dump_template_bindings (cxx_pp, tparms, targs, NULL);\n   pp_cxx_right_bracket (cxx_pp);\n   return pp_formatted_text (cxx_pp);\n }"}]}