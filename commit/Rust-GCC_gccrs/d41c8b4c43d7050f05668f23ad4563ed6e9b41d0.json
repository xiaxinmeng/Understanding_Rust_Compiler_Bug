{"sha": "d41c8b4c43d7050f05668f23ad4563ed6e9b41d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQxYzhiNGM0M2Q3MDUwZjA1NjY4ZjIzYWQ0NTYzZWQ2ZTliNDFkMA==", "commit": {"author": {"name": "Steve Ellcey", "email": "sellcey@imgtec.com", "date": "2015-10-09T17:10:42Z"}, "committer": {"name": "Steve Ellcey", "email": "sje@gcc.gnu.org", "date": "2015-10-09T17:10:42Z"}, "message": "config.gcc (mips*-*-*): Add frame-header-opt.o to extra_objs.\n\n2015-10-05  Steve Ellcey  <sellcey@imgtec.com>\n\n\t* config.gcc (mips*-*-*): Add frame-header-opt.o to extra_objs.\n\t* frame-header-opt.c: New file.\n\t* config/mips/mips-proto.h (mips_register_frame_header_opt):\n\tAdd prototype.\n\t* config/mips/mips.c (mips_compute_frame_info): Check\n\toptimize_call_stack flag.\n\t(mips_option_override): Register new frame_header_opt pass.\n \t(mips_frame_info, mips_int_mask, mips_shadow_set,\n\tmachine_function): Move these types to...\n\t* config/mips/mips.h: here.\n\t(machine_function): Add does_not_use_frame_header and\n\toptimize_call_stack fields.\n\t* config/mips/t-mips (frame-header-opt.o): Add new make rule.\n\t* doc/invoke.texi (-mframe-header-opt, -mno-frame-header-opt):\n\tDocument new flags.\n\t* config/mips/mips.opt (mframe-header-opt): Add new option.\n\nFrom-SVN: r228666", "tree": {"sha": "ec2b873ea269f855d61f77eb73a55bc41a5d0dc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec2b873ea269f855d61f77eb73a55bc41a5d0dc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d41c8b4c43d7050f05668f23ad4563ed6e9b41d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d41c8b4c43d7050f05668f23ad4563ed6e9b41d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d41c8b4c43d7050f05668f23ad4563ed6e9b41d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d41c8b4c43d7050f05668f23ad4563ed6e9b41d0/comments", "author": null, "committer": null, "parents": [{"sha": "b867c7ca88776d062e3e62c212fb0a59b6d688c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b867c7ca88776d062e3e62c212fb0a59b6d688c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b867c7ca88776d062e3e62c212fb0a59b6d688c9"}], "stats": {"total": 577, "additions": 425, "deletions": 152}, "files": [{"sha": "69743c318fb8b1c43f8ed17eb2dcf91c7b130f38", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d41c8b4c43d7050f05668f23ad4563ed6e9b41d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d41c8b4c43d7050f05668f23ad4563ed6e9b41d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d41c8b4c43d7050f05668f23ad4563ed6e9b41d0", "patch": "@@ -1,3 +1,22 @@\n+2015-10-09  Steve Ellcey  <sellcey@imgtec.com>\n+\n+\t* config.gcc (mips*-*-*): Add frame-header-opt.o to extra_objs.\n+\t* frame-header-opt.c: New file.\n+\t* config/mips/mips-proto.h (mips_register_frame_header_opt):\n+\tAdd prototype.\n+\t* config/mips/mips.c (mips_compute_frame_info): Check\n+\toptimize_call_stack flag.\n+\t(mips_option_override): Register new frame_header_opt pass.\n+ \t(mips_frame_info, mips_int_mask, mips_shadow_set,\n+\tmachine_function): Move these types to...\n+\t* config/mips/mips.h: here.\n+\t(machine_function): Add does_not_use_frame_header and\n+\toptimize_call_stack fields.\n+\t* config/mips/t-mips (frame-header-opt.o): Add new make rule.\n+\t* doc/invoke.texi (-mframe-header-opt, -mno-frame-header-opt):\n+\tDocument new flags.\n+\t* config/mips/mips.opt (mframe-header-opt): Add new option.\n+\n 2015-10-09  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c"}, {"sha": "1962b0fa923816715ab6688a5b03294fcbf668b1", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d41c8b4c43d7050f05668f23ad4563ed6e9b41d0/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d41c8b4c43d7050f05668f23ad4563ed6e9b41d0/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=d41c8b4c43d7050f05668f23ad4563ed6e9b41d0", "patch": "@@ -420,6 +420,7 @@ microblaze*-*-*)\n mips*-*-*)\n \tcpu_type=mips\n \textra_headers=\"loongson.h\"\n+\textra_objs=\"frame-header-opt.o\"\n \textra_options=\"${extra_options} g.opt fused-madd.opt mips/mips-tables.opt\"\n \t;;\n nds32*)"}, {"sha": "7c7b1f2209eba1da6695ba96e787f9b2a62ee2f1", "filename": "gcc/config/mips/frame-header-opt.c", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d41c8b4c43d7050f05668f23ad4563ed6e9b41d0/gcc%2Fconfig%2Fmips%2Fframe-header-opt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d41c8b4c43d7050f05668f23ad4563ed6e9b41d0/gcc%2Fconfig%2Fmips%2Fframe-header-opt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fframe-header-opt.c?ref=d41c8b4c43d7050f05668f23ad4563ed6e9b41d0", "patch": "@@ -0,0 +1,216 @@\n+/* Analyze functions to determine if callers need to allocate a frame header\n+   on the stack.  The frame header is used by callees to save their arguments.\n+   This optimization is specific to TARGET_OLDABI targets.  For TARGET_NEWABI\n+   targets, if a frame header is required, it is allocated by the callee.\n+\n+\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"context.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"tree-core.h\"\n+#include \"tree-pass.h\"\n+#include \"target.h\"\n+#include \"target-globals.h\"\n+#include \"cfg.h\"\n+#include \"cgraph.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimple-walk.h\"\n+\n+static unsigned int frame_header_opt (void);\n+\n+namespace {\n+\n+const pass_data pass_data_ipa_frame_header_opt =\n+{\n+  IPA_PASS, /* type */\n+  \"frame-header-opt\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_CGRAPHOPT, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_ipa_frame_header_opt : public ipa_opt_pass_d\n+{\n+public:\n+  pass_ipa_frame_header_opt (gcc::context *ctxt)\n+    : ipa_opt_pass_d (pass_data_ipa_frame_header_opt, ctxt,\n+                      NULL, /* generate_summary */\n+                      NULL, /* write_summary */\n+                      NULL, /* read_summary */\n+                      NULL, /* write_optimization_summary */\n+                      NULL, /* read_optimization_summary */\n+                      NULL, /* stmt_fixup */\n+                      0, /* function_transform_todo_flags_start */\n+                      NULL, /* function_transform */\n+                      NULL) /* variable_transform */\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+    {\n+      /* This optimization has no affect if TARGET_NEWABI.   If optimize\n+         is not at least 1 then the data needed for the optimization is\n+         not available and nothing will be done anyway.  */\n+      return TARGET_OLDABI && flag_frame_header_optimization;\n+    }\n+\n+  virtual unsigned int execute (function *) { return frame_header_opt (); }\n+\n+}; // class pass_ipa_frame_header_opt\n+\n+} // anon namespace\n+\n+static ipa_opt_pass_d *\n+make_pass_ipa_frame_header_opt (gcc::context *ctxt)\n+{\n+  return new pass_ipa_frame_header_opt (ctxt);\n+}\n+\n+void\n+mips_register_frame_header_opt (void)\n+{\n+  opt_pass *p = make_pass_ipa_frame_header_opt (g);\n+  static struct register_pass_info f =\n+    {p, \"comdats\", 1, PASS_POS_INSERT_AFTER };\n+  register_pass (&f);\n+}\n+\n+\n+/* Return true if it is certain that this is a leaf function.  False if it is\n+   not a leaf function or if it is impossible to tell.  */\n+\n+static bool\n+is_leaf_function (function *fn)\n+{\n+  basic_block bb;\n+  gimple_stmt_iterator gsi;\n+\n+  /* If we do not have a cfg for this function be conservative and assume\n+     it is not a leaf function.  */\n+  if (fn->cfg == NULL)\n+    return false;\n+\n+  FOR_EACH_BB_FN (bb, fn)\n+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      if (is_gimple_call (gsi_stmt (gsi)))\n+\treturn false;\n+  return true;\n+}\n+\n+/* Return true if this function will use the stack space allocated by its\n+   caller or if we cannot determine for certain that it does not.  */\n+\n+static bool\n+needs_frame_header_p (function *fn)\n+{\n+  tree t;\n+\n+  if (fn->decl == NULL)\n+    return true;\n+\n+  if (fn->stdarg || !is_leaf_function (fn))\n+    return true;\n+\n+  for (t = DECL_ARGUMENTS (fn->decl); t; t = TREE_CHAIN (t))\n+    {\n+      if (!use_register_for_decl (t))\n+\t  return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Returns TRUE if the argument stack space allocated by function FN is used.\n+   Returns FALSE if the space is needed or if the need for the space cannot\n+   be determined.  */\n+\n+static bool\n+callees_functions_use_frame_header (function *fn)\n+{\n+  basic_block bb;\n+  gimple_stmt_iterator gsi;\n+  gimple *stmt;\n+  tree called_fn_tree;\n+  function *called_fn;\n+\n+  if (fn->cfg == NULL)\n+    return true;\n+\n+  FOR_EACH_BB_FN (bb, fn)\n+    {\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  stmt = gsi_stmt (gsi);\n+\t  if (is_gimple_call (stmt))\n+\t    {\n+\t      called_fn_tree = gimple_call_fndecl (stmt);\n+\t      if (called_fn_tree != NULL)\n+\t        {\n+\t          called_fn = DECL_STRUCT_FUNCTION (called_fn_tree);\n+\t\t  if (called_fn == NULL\n+\t\t      || DECL_WEAK (called_fn_tree) \n+\t\t      || !called_fn->machine->does_not_use_frame_header)\n+\t\t    return true;\n+\t        }\n+\t      else\n+\t\treturn true;\n+            }\n+        }\n+    }\n+  return false;\n+}\n+\n+/* Scan each function to determine those that need its frame headers.  Perform\n+   a second scan to determine if the allocation can be skipped because none of\n+   their callees require the frame header.  */\n+\n+static unsigned int\n+frame_header_opt ()\n+{\n+  struct cgraph_node *node;\n+  function *fn;\n+\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    {\n+      fn = node->get_fun ();\n+      if (fn != NULL)\n+\tfn->machine->does_not_use_frame_header = !needs_frame_header_p (fn);\n+    }\n+\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    {\n+      fn = node->get_fun ();\n+      if (fn != NULL)\n+        fn->machine->optimize_call_stack\n+\t  = !callees_functions_use_frame_header (fn);\n+    }\n+  return 0;\n+}"}, {"sha": "43774facdbe92b226bc6f5b590ac420327880694", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d41c8b4c43d7050f05668f23ad4563ed6e9b41d0/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d41c8b4c43d7050f05668f23ad4563ed6e9b41d0/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=d41c8b4c43d7050f05668f23ad4563ed6e9b41d0", "patch": "@@ -371,4 +371,6 @@ typedef rtx (*mulsidi3_gen_fn) (rtx, rtx, rtx);\n extern mulsidi3_gen_fn mips_mulsidi3_gen_fn (enum rtx_code);\n #endif\n \n+extern void mips_register_frame_header_opt (void);\n+\n #endif /* ! GCC_MIPS_PROTOS_H */"}, {"sha": "a4bb454bee9ff57959a824774b6b1d666a99733e", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 11, "deletions": 151, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d41c8b4c43d7050f05668f23ad4563ed6e9b41d0/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d41c8b4c43d7050f05668f23ad4563ed6e9b41d0/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=d41c8b4c43d7050f05668f23ad4563ed6e9b41d0", "patch": "@@ -328,153 +328,6 @@ static struct {\n   bool fast_mult_zero_zero_p;\n } mips_tuning_info;\n \n-/* Information about a function's frame layout.  */\n-struct GTY(())  mips_frame_info {\n-  /* The size of the frame in bytes.  */\n-  HOST_WIDE_INT total_size;\n-\n-  /* The number of bytes allocated to variables.  */\n-  HOST_WIDE_INT var_size;\n-\n-  /* The number of bytes allocated to outgoing function arguments.  */\n-  HOST_WIDE_INT args_size;\n-\n-  /* The number of bytes allocated to the .cprestore slot, or 0 if there\n-     is no such slot.  */\n-  HOST_WIDE_INT cprestore_size;\n-\n-  /* Bit X is set if the function saves or restores GPR X.  */\n-  unsigned int mask;\n-\n-  /* Likewise FPR X.  */\n-  unsigned int fmask;\n-\n-  /* Likewise doubleword accumulator X ($acX).  */\n-  unsigned int acc_mask;\n-\n-  /* The number of GPRs, FPRs, doubleword accumulators and COP0\n-     registers saved.  */\n-  unsigned int num_gp;\n-  unsigned int num_fp;\n-  unsigned int num_acc;\n-  unsigned int num_cop0_regs;\n-\n-  /* The offset of the topmost GPR, FPR, accumulator and COP0-register\n-     save slots from the top of the frame, or zero if no such slots are\n-     needed.  */\n-  HOST_WIDE_INT gp_save_offset;\n-  HOST_WIDE_INT fp_save_offset;\n-  HOST_WIDE_INT acc_save_offset;\n-  HOST_WIDE_INT cop0_save_offset;\n-\n-  /* Likewise, but giving offsets from the bottom of the frame.  */\n-  HOST_WIDE_INT gp_sp_offset;\n-  HOST_WIDE_INT fp_sp_offset;\n-  HOST_WIDE_INT acc_sp_offset;\n-  HOST_WIDE_INT cop0_sp_offset;\n-\n-  /* Similar, but the value passed to _mcount.  */\n-  HOST_WIDE_INT ra_fp_offset;\n-\n-  /* The offset of arg_pointer_rtx from the bottom of the frame.  */\n-  HOST_WIDE_INT arg_pointer_offset;\n-\n-  /* The offset of hard_frame_pointer_rtx from the bottom of the frame.  */\n-  HOST_WIDE_INT hard_frame_pointer_offset;\n-};\n-\n-/* Enumeration for masked vectored (VI) and non-masked (EIC) interrupts.  */\n-enum mips_int_mask\n-{\n-  INT_MASK_EIC = -1,\n-  INT_MASK_SW0 = 0,\n-  INT_MASK_SW1 = 1,\n-  INT_MASK_HW0 = 2,\n-  INT_MASK_HW1 = 3,\n-  INT_MASK_HW2 = 4,\n-  INT_MASK_HW3 = 5,\n-  INT_MASK_HW4 = 6,\n-  INT_MASK_HW5 = 7\n-};\n-\n-/* Enumeration to mark the existence of the shadow register set.\n-   SHADOW_SET_INTSTACK indicates a shadow register set with a valid stack\n-   pointer.  */\n-enum mips_shadow_set\n-{\n-  SHADOW_SET_NO,\n-  SHADOW_SET_YES,\n-  SHADOW_SET_INTSTACK\n-};\n-\n-struct GTY(())  machine_function {\n-  /* The next floating-point condition-code register to allocate\n-     for ISA_HAS_8CC targets, relative to ST_REG_FIRST.  */\n-  unsigned int next_fcc;\n-\n-  /* The register returned by mips16_gp_pseudo_reg; see there for details.  */\n-  rtx mips16_gp_pseudo_rtx;\n-\n-  /* The number of extra stack bytes taken up by register varargs.\n-     This area is allocated by the callee at the very top of the frame.  */\n-  int varargs_size;\n-\n-  /* The current frame information, calculated by mips_compute_frame_info.  */\n-  struct mips_frame_info frame;\n-\n-  /* The register to use as the function's global pointer, or INVALID_REGNUM\n-     if the function doesn't need one.  */\n-  unsigned int global_pointer;\n-\n-  /* How many instructions it takes to load a label into $AT, or 0 if\n-     this property hasn't yet been calculated.  */\n-  unsigned int load_label_num_insns;\n-\n-  /* True if mips_adjust_insn_length should ignore an instruction's\n-     hazard attribute.  */\n-  bool ignore_hazard_length_p;\n-\n-  /* True if the whole function is suitable for .set noreorder and\n-     .set nomacro.  */\n-  bool all_noreorder_p;\n-\n-  /* True if the function has \"inflexible\" and \"flexible\" references\n-     to the global pointer.  See mips_cfun_has_inflexible_gp_ref_p\n-     and mips_cfun_has_flexible_gp_ref_p for details.  */\n-  bool has_inflexible_gp_insn_p;\n-  bool has_flexible_gp_insn_p;\n-\n-  /* True if the function's prologue must load the global pointer\n-     value into pic_offset_table_rtx and store the same value in\n-     the function's cprestore slot (if any).  Even if this value\n-     is currently false, we may decide to set it to true later;\n-     see mips_must_initialize_gp_p () for details.  */\n-  bool must_initialize_gp_p;\n-\n-  /* True if the current function must restore $gp after any potential\n-     clobber.  This value is only meaningful during the first post-epilogue\n-     split_insns pass; see mips_must_initialize_gp_p () for details.  */\n-  bool must_restore_gp_when_clobbered_p;\n-\n-  /* True if this is an interrupt handler.  */\n-  bool interrupt_handler_p;\n-\n-  /* Records the way in which interrupts should be masked.  Only used if\n-     interrupts are not kept masked.  */\n-  enum mips_int_mask int_mask;\n-\n-  /* Records if this is an interrupt handler that uses shadow registers.  */\n-  enum mips_shadow_set use_shadow_register_set;\n-\n-  /* True if this is an interrupt handler that should keep interrupts\n-     masked.  */\n-  bool keep_interrupts_masked_p;\n-\n-  /* True if this is an interrupt handler that should use DERET\n-     instead of ERET.  */\n-  bool use_debug_exception_return_p;\n-};\n-\n /* Information about a single argument.  */\n struct mips_arg_info {\n   /* True if the argument is passed in a floating-point register, or\n@@ -10504,10 +10357,15 @@ mips_compute_frame_info (void)\n   cfun->machine->global_pointer = mips_global_pointer ();\n \n   /* The first two blocks contain the outgoing argument area and the $gp save\n-     slot.  This area isn't needed in leaf functions, but if the\n-     target-independent frame size is nonzero, we have already committed to\n-     allocating these in STARTING_FRAME_OFFSET for !FRAME_GROWS_DOWNWARD.  */\n-  if ((size == 0 || FRAME_GROWS_DOWNWARD) && crtl->is_leaf)\n+     slot.  This area isn't needed in leaf functions.  We can also skip it\n+     if we know that none of the called functions will use this space.\n+\n+     But if the target-independent frame size is nonzero, we have already\n+     committed to allocating these in STARTING_FRAME_OFFSET for\n+     !FRAME_GROWS_DOWNWARD.  */\n+\n+  if ((size == 0 || FRAME_GROWS_DOWNWARD)\n+      && (crtl->is_leaf || (cfun->machine->optimize_call_stack && !flag_pic)))\n     {\n       /* The MIPS 3.0 linker does not like functions that dynamically\n \t allocate the stack and have 0 for STACK_DYNAMIC_OFFSET, since it\n@@ -18269,6 +18127,8 @@ mips_option_override (void)\n \n   if (TARGET_HARD_FLOAT_ABI && TARGET_MIPS5900)\n     REAL_MODE_FORMAT (SFmode) = &spu_single_format;\n+\n+  mips_register_frame_header_opt ();\n }\n \n /* Swap the register information for registers I and I + 1, which"}, {"sha": "be86c109b6c3c99b2eb46fdef2df504c94f2a881", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d41c8b4c43d7050f05668f23ad4563ed6e9b41d0/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d41c8b4c43d7050f05668f23ad4563ed6e9b41d0/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=d41c8b4c43d7050f05668f23ad4563ed6e9b41d0", "patch": "@@ -3119,6 +3119,161 @@ extern const struct mips_cpu_info *mips_tune_info;\n extern unsigned int mips_base_compression_flags;\n extern GTY(()) struct target_globals *mips16_globals;\n extern GTY(()) struct target_globals *micromips_globals;\n+\n+/* Information about a function's frame layout.  */\n+struct GTY(())  mips_frame_info {\n+  /* The size of the frame in bytes.  */\n+  HOST_WIDE_INT total_size;\n+\n+  /* The number of bytes allocated to variables.  */\n+  HOST_WIDE_INT var_size;\n+\n+  /* The number of bytes allocated to outgoing function arguments.  */\n+  HOST_WIDE_INT args_size;\n+\n+  /* The number of bytes allocated to the .cprestore slot, or 0 if there\n+     is no such slot.  */\n+  HOST_WIDE_INT cprestore_size;\n+\n+  /* Bit X is set if the function saves or restores GPR X.  */\n+  unsigned int mask;\n+\n+  /* Likewise FPR X.  */\n+  unsigned int fmask;\n+\n+  /* Likewise doubleword accumulator X ($acX).  */\n+  unsigned int acc_mask;\n+\n+  /* The number of GPRs, FPRs, doubleword accumulators and COP0\n+     registers saved.  */\n+  unsigned int num_gp;\n+  unsigned int num_fp;\n+  unsigned int num_acc;\n+  unsigned int num_cop0_regs;\n+\n+  /* The offset of the topmost GPR, FPR, accumulator and COP0-register\n+     save slots from the top of the frame, or zero if no such slots are\n+     needed.  */\n+  HOST_WIDE_INT gp_save_offset;\n+  HOST_WIDE_INT fp_save_offset;\n+  HOST_WIDE_INT acc_save_offset;\n+  HOST_WIDE_INT cop0_save_offset;\n+\n+  /* Likewise, but giving offsets from the bottom of the frame.  */\n+  HOST_WIDE_INT gp_sp_offset;\n+  HOST_WIDE_INT fp_sp_offset;\n+  HOST_WIDE_INT acc_sp_offset;\n+  HOST_WIDE_INT cop0_sp_offset;\n+\n+  /* Similar, but the value passed to _mcount.  */\n+  HOST_WIDE_INT ra_fp_offset;\n+\n+  /* The offset of arg_pointer_rtx from the bottom of the frame.  */\n+  HOST_WIDE_INT arg_pointer_offset;\n+\n+  /* The offset of hard_frame_pointer_rtx from the bottom of the frame.  */\n+  HOST_WIDE_INT hard_frame_pointer_offset;\n+};\n+\n+/* Enumeration for masked vectored (VI) and non-masked (EIC) interrupts.  */\n+enum mips_int_mask\n+{\n+  INT_MASK_EIC = -1,\n+  INT_MASK_SW0 = 0,\n+  INT_MASK_SW1 = 1,\n+  INT_MASK_HW0 = 2,\n+  INT_MASK_HW1 = 3,\n+  INT_MASK_HW2 = 4,\n+  INT_MASK_HW3 = 5,\n+  INT_MASK_HW4 = 6,\n+  INT_MASK_HW5 = 7\n+};\n+\n+/* Enumeration to mark the existence of the shadow register set.\n+   SHADOW_SET_INTSTACK indicates a shadow register set with a valid stack\n+   pointer.  */\n+enum mips_shadow_set\n+{\n+  SHADOW_SET_NO,\n+  SHADOW_SET_YES,\n+  SHADOW_SET_INTSTACK\n+};\n+\n+struct GTY(())  machine_function {\n+  /* The next floating-point condition-code register to allocate\n+     for ISA_HAS_8CC targets, relative to ST_REG_FIRST.  */\n+  unsigned int next_fcc;\n+\n+  /* The register returned by mips16_gp_pseudo_reg; see there for details.  */\n+  rtx mips16_gp_pseudo_rtx;\n+\n+  /* The number of extra stack bytes taken up by register varargs.\n+     This area is allocated by the callee at the very top of the frame.  */\n+  int varargs_size;\n+\n+  /* The current frame information, calculated by mips_compute_frame_info.  */\n+  struct mips_frame_info frame;\n+\n+  /* The register to use as the function's global pointer, or INVALID_REGNUM\n+     if the function doesn't need one.  */\n+  unsigned int global_pointer;\n+\n+  /* How many instructions it takes to load a label into $AT, or 0 if\n+     this property hasn't yet been calculated.  */\n+  unsigned int load_label_num_insns;\n+\n+  /* True if mips_adjust_insn_length should ignore an instruction's\n+     hazard attribute.  */\n+  bool ignore_hazard_length_p;\n+\n+  /* True if the whole function is suitable for .set noreorder and\n+     .set nomacro.  */\n+  bool all_noreorder_p;\n+\n+  /* True if the function has \"inflexible\" and \"flexible\" references\n+     to the global pointer.  See mips_cfun_has_inflexible_gp_ref_p\n+     and mips_cfun_has_flexible_gp_ref_p for details.  */\n+  bool has_inflexible_gp_insn_p;\n+  bool has_flexible_gp_insn_p;\n+\n+  /* True if the function's prologue must load the global pointer\n+     value into pic_offset_table_rtx and store the same value in\n+     the function's cprestore slot (if any).  Even if this value\n+     is currently false, we may decide to set it to true later;\n+     see mips_must_initialize_gp_p () for details.  */\n+  bool must_initialize_gp_p;\n+\n+  /* True if the current function must restore $gp after any potential\n+     clobber.  This value is only meaningful during the first post-epilogue\n+     split_insns pass; see mips_must_initialize_gp_p () for details.  */\n+  bool must_restore_gp_when_clobbered_p;\n+\n+  /* True if this is an interrupt handler.  */\n+  bool interrupt_handler_p;\n+\n+  /* Records the way in which interrupts should be masked.  Only used if\n+     interrupts are not kept masked.  */\n+  enum mips_int_mask int_mask;\n+\n+  /* Records if this is an interrupt handler that uses shadow registers.  */\n+  enum mips_shadow_set use_shadow_register_set;\n+\n+  /* True if this is an interrupt handler that should keep interrupts\n+     masked.  */\n+  bool keep_interrupts_masked_p;\n+\n+  /* True if this is an interrupt handler that should use DERET\n+     instead of ERET.  */\n+  bool use_debug_exception_return_p;\n+\n+  /* True if at least one of the formal parameters to a function must be\n+     written to the frame header (probably so its address can be taken).  */\n+  bool does_not_use_frame_header;\n+\n+  /* True if none of the functions that are called by this function need\n+     stack space allocated for their arguments.  */\n+  bool optimize_call_stack;\n+};\n #endif\n \n /* Enable querying of DFA units.  */"}, {"sha": "b979eb51c593806284de69eda5c922be5bf370c0", "filename": "gcc/config/mips/mips.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d41c8b4c43d7050f05668f23ad4563ed6e9b41d0/gcc%2Fconfig%2Fmips%2Fmips.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d41c8b4c43d7050f05668f23ad4563ed6e9b41d0/gcc%2Fconfig%2Fmips%2Fmips.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.opt?ref=d41c8b4c43d7050f05668f23ad4563ed6e9b41d0", "patch": "@@ -412,6 +412,10 @@ modd-spreg\n Target Report Mask(ODD_SPREG)\n Enable use of odd-numbered single-precision registers\n \n+mframe-header-opt\n+Target Report Var(flag_frame_header_optimization) Optimization\n+Optimize frame header\n+\n noasmopt\n Driver\n "}, {"sha": "a8938411420c69408d5c3ba27f507f38b9dc1716", "filename": "gcc/config/mips/t-mips", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d41c8b4c43d7050f05668f23ad4563ed6e9b41d0/gcc%2Fconfig%2Fmips%2Ft-mips", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d41c8b4c43d7050f05668f23ad4563ed6e9b41d0/gcc%2Fconfig%2Fmips%2Ft-mips", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-mips?ref=d41c8b4c43d7050f05668f23ad4563ed6e9b41d0", "patch": "@@ -20,3 +20,7 @@ $(srcdir)/config/mips/mips-tables.opt: $(srcdir)/config/mips/genopt.sh \\\n   $(srcdir)/config/mips/mips-cpus.def\n \t$(SHELL) $(srcdir)/config/mips/genopt.sh $(srcdir)/config/mips > \\\n \t\t$(srcdir)/config/mips/mips-tables.opt\n+\n+frame-header-opt.o: $(srcdir)/config/mips/frame-header-opt.c\n+\t$(COMPILE) $<\n+\t$(POSTCOMPILE)"}, {"sha": "f10d7496c7968216a093d55778cbe19e69df0367", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d41c8b4c43d7050f05668f23ad4563ed6e9b41d0/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d41c8b4c43d7050f05668f23ad4563ed6e9b41d0/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d41c8b4c43d7050f05668f23ad4563ed6e9b41d0", "patch": "@@ -818,7 +818,8 @@ Objective-C and Objective-C++ Dialects}.\n -mbranch-cost=@var{num}  -mbranch-likely  -mno-branch-likely @gol\n -mfp-exceptions -mno-fp-exceptions @gol\n -mvr4130-align -mno-vr4130-align -msynci -mno-synci @gol\n--mrelax-pic-calls -mno-relax-pic-calls -mmcount-ra-address}\n+-mrelax-pic-calls -mno-relax-pic-calls -mmcount-ra-address @gol\n+-mframe-header-opt -mno-frame-header-opt}\n \n @emph{MMIX Options}\n @gccoptlist{-mlibfuncs  -mno-libfuncs  -mepsilon  -mno-epsilon  -mabi=gnu @gol\n@@ -18108,6 +18109,17 @@ if @var{ra-address} is nonnull.\n \n The default is @option{-mno-mcount-ra-address}.\n \n+@item -mframe-header-opt\n+@itemx -mno-frame-header-opt\n+@opindex mframe-header-opt\n+Enable (disable) frame header optimization in the o32 ABI.  When using the\n+o32 ABI, calling functions will allocate 16 bytes on the stack for the called\n+function to write out register arguments.  When enabled, this optimization\n+will suppress the allocation of the frame header if it can be determined that\n+it is unused.\n+\n+This optimization is off by default at all optimization levels.\n+\n @end table\n \n @node MMIX Options"}]}