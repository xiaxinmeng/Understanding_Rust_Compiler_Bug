{"sha": "fbbc17c78ce9bc18bf4f458ca2f7aa9e604d71b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJiYzE3Yzc4Y2U5YmMxOGJmNGY0NThjYTJmN2FhOWU2MDRkNzFiMw==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2006-05-26T23:09:14Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2006-05-26T23:09:14Z"}, "message": "Fix whitespacing\n\nFrom-SVN: r114143", "tree": {"sha": "34d7340f0eb378a21fa4486a026704ede315d3ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34d7340f0eb378a21fa4486a026704ede315d3ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbbc17c78ce9bc18bf4f458ca2f7aa9e604d71b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbbc17c78ce9bc18bf4f458ca2f7aa9e604d71b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbbc17c78ce9bc18bf4f458ca2f7aa9e604d71b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbbc17c78ce9bc18bf4f458ca2f7aa9e604d71b3/comments", "author": null, "committer": null, "parents": [{"sha": "e8300d6eaf5937e3cd56b41f620f4380a21dab97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8300d6eaf5937e3cd56b41f620f4380a21dab97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8300d6eaf5937e3cd56b41f620f4380a21dab97"}], "stats": {"total": 282, "additions": 141, "deletions": 141}, "files": [{"sha": "ddf068a74f30c46ce340f31ad4c4f4f49927bf4c", "filename": "gcc/c-decl.c", "status": "modified", "additions": 141, "deletions": 141, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbc17c78ce9bc18bf4f458ca2f7aa9e604d71b3/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbc17c78ce9bc18bf4f458ca2f7aa9e604d71b3/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=fbbc17c78ce9bc18bf4f458ca2f7aa9e604d71b3", "patch": "@@ -1690,155 +1690,155 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n       C_DECL_THREADPRIVATE_P (newdecl) = 1;\n     }\n \n-   if (CODE_CONTAINS_STRUCT (TREE_CODE (olddecl), TS_DECL_WITH_VIS))\n-     {\n-       /* Merge the unused-warning information.  */\n-       if (DECL_IN_SYSTEM_HEADER (olddecl))\n-\t DECL_IN_SYSTEM_HEADER (newdecl) = 1;\n-       else if (DECL_IN_SYSTEM_HEADER (newdecl))\n-\t DECL_IN_SYSTEM_HEADER (olddecl) = 1;\n-\n-       /* Merge the section attribute.\n-\t  We want to issue an error if the sections conflict but that must be\n-\t  done later in decl_attributes since we are called before attributes\n-\t  are assigned.  */\n-       if (DECL_SECTION_NAME (newdecl) == NULL_TREE)\n-\t DECL_SECTION_NAME (newdecl) = DECL_SECTION_NAME (olddecl);\n-\n-       /* Copy the assembler name.\n-\t  Currently, it can only be defined in the prototype.  */\n-       COPY_DECL_ASSEMBLER_NAME (olddecl, newdecl);\n-\n-       /* Use visibility of whichever declaration had it specified */\n-       if (DECL_VISIBILITY_SPECIFIED (olddecl))\n-\t {\n-\t   DECL_VISIBILITY (newdecl) = DECL_VISIBILITY (olddecl);\n-\t   DECL_VISIBILITY_SPECIFIED (newdecl) = 1;\n-\t }\n+  if (CODE_CONTAINS_STRUCT (TREE_CODE (olddecl), TS_DECL_WITH_VIS))\n+    {\n+      /* Merge the unused-warning information.  */\n+      if (DECL_IN_SYSTEM_HEADER (olddecl))\n+\tDECL_IN_SYSTEM_HEADER (newdecl) = 1;\n+      else if (DECL_IN_SYSTEM_HEADER (newdecl))\n+\tDECL_IN_SYSTEM_HEADER (olddecl) = 1;\n+\n+      /* Merge the section attribute.\n+\t We want to issue an error if the sections conflict but that\n+\t must be done later in decl_attributes since we are called\n+\t before attributes are assigned.  */\n+      if (DECL_SECTION_NAME (newdecl) == NULL_TREE)\n+\tDECL_SECTION_NAME (newdecl) = DECL_SECTION_NAME (olddecl);\n+\n+      /* Copy the assembler name.\n+\t Currently, it can only be defined in the prototype.  */\n+      COPY_DECL_ASSEMBLER_NAME (olddecl, newdecl);\n+\n+      /* Use visibility of whichever declaration had it specified */\n+      if (DECL_VISIBILITY_SPECIFIED (olddecl))\n+\t{\n+\t  DECL_VISIBILITY (newdecl) = DECL_VISIBILITY (olddecl);\n+\t  DECL_VISIBILITY_SPECIFIED (newdecl) = 1;\n+\t}\n \n-       if (TREE_CODE (newdecl) == FUNCTION_DECL)\n-\t {\n-\t   DECL_STATIC_CONSTRUCTOR(newdecl) |= DECL_STATIC_CONSTRUCTOR(olddecl);\n-\t   DECL_STATIC_DESTRUCTOR (newdecl) |= DECL_STATIC_DESTRUCTOR (olddecl);\n-\t   DECL_NO_LIMIT_STACK (newdecl) |= DECL_NO_LIMIT_STACK (olddecl);\n-\t   DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (newdecl)\n-\t     |= DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (olddecl);\n-\t   TREE_THIS_VOLATILE (newdecl) |= TREE_THIS_VOLATILE (olddecl);\n-\t   TREE_READONLY (newdecl) |= TREE_READONLY (olddecl);\n-\t   DECL_IS_MALLOC (newdecl) |= DECL_IS_MALLOC (olddecl);\n-\t   DECL_IS_PURE (newdecl) |= DECL_IS_PURE (olddecl);\n-\t   DECL_IS_NOVOPS (newdecl) |= DECL_IS_NOVOPS (olddecl);\n-\t }\n+      if (TREE_CODE (newdecl) == FUNCTION_DECL)\n+\t{\n+\t  DECL_STATIC_CONSTRUCTOR(newdecl) |= DECL_STATIC_CONSTRUCTOR(olddecl);\n+\t  DECL_STATIC_DESTRUCTOR (newdecl) |= DECL_STATIC_DESTRUCTOR (olddecl);\n+\t  DECL_NO_LIMIT_STACK (newdecl) |= DECL_NO_LIMIT_STACK (olddecl);\n+\t  DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (newdecl)\n+\t    |= DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (olddecl);\n+\t  TREE_THIS_VOLATILE (newdecl) |= TREE_THIS_VOLATILE (olddecl);\n+\t  TREE_READONLY (newdecl) |= TREE_READONLY (olddecl);\n+\t  DECL_IS_MALLOC (newdecl) |= DECL_IS_MALLOC (olddecl);\n+\t  DECL_IS_PURE (newdecl) |= DECL_IS_PURE (olddecl);\n+\t  DECL_IS_NOVOPS (newdecl) |= DECL_IS_NOVOPS (olddecl);\n+\t}\n \n-       /* Merge the storage class information.  */\n-       merge_weak (newdecl, olddecl);\n+      /* Merge the storage class information.  */\n+      merge_weak (newdecl, olddecl);\n \n-       /* For functions, static overrides non-static.  */\n-       if (TREE_CODE (newdecl) == FUNCTION_DECL)\n-\t {\n-\t   TREE_PUBLIC (newdecl) &= TREE_PUBLIC (olddecl);\n-\t   /* This is since we don't automatically\n-\t      copy the attributes of NEWDECL into OLDDECL.  */\n-\t   TREE_PUBLIC (olddecl) = TREE_PUBLIC (newdecl);\n-\t   /* If this clears `static', clear it in the identifier too.  */\n-\t   if (!TREE_PUBLIC (olddecl))\n-\t     TREE_PUBLIC (DECL_NAME (olddecl)) = 0;\n-\t }\n-     }\n+      /* For functions, static overrides non-static.  */\n+      if (TREE_CODE (newdecl) == FUNCTION_DECL)\n+\t{\n+\t  TREE_PUBLIC (newdecl) &= TREE_PUBLIC (olddecl);\n+\t  /* This is since we don't automatically\n+\t     copy the attributes of NEWDECL into OLDDECL.  */\n+\t  TREE_PUBLIC (olddecl) = TREE_PUBLIC (newdecl);\n+\t  /* If this clears `static', clear it in the identifier too.  */\n+\t  if (!TREE_PUBLIC (olddecl))\n+\t    TREE_PUBLIC (DECL_NAME (olddecl)) = 0;\n+\t}\n+    }\n \n-   if (DECL_EXTERNAL (newdecl))\n-     {\n-       TREE_STATIC (newdecl) = TREE_STATIC (olddecl);\n-       DECL_EXTERNAL (newdecl) = DECL_EXTERNAL (olddecl);\n+  if (DECL_EXTERNAL (newdecl))\n+    {\n+      TREE_STATIC (newdecl) = TREE_STATIC (olddecl);\n+      DECL_EXTERNAL (newdecl) = DECL_EXTERNAL (olddecl);\n \n-       /* An extern decl does not override previous storage class.  */\n-       TREE_PUBLIC (newdecl) = TREE_PUBLIC (olddecl);\n-       if (!DECL_EXTERNAL (newdecl))\n-\t {\n-\t   DECL_CONTEXT (newdecl) = DECL_CONTEXT (olddecl);\n-\t   DECL_COMMON (newdecl) = DECL_COMMON (olddecl);\n-\t }\n-     }\n-   else\n-     {\n-       TREE_STATIC (olddecl) = TREE_STATIC (newdecl);\n-       TREE_PUBLIC (olddecl) = TREE_PUBLIC (newdecl);\n-     }\n-\n-   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n-     {\n-       /* If we're redefining a function previously defined as extern\n-\t  inline, make sure we emit debug info for the inline before we\n-\t  throw it away, in case it was inlined into a function that hasn't\n-\t  been written out yet.  */\n-       if (new_is_definition && DECL_INITIAL (olddecl))\n-\t {\n-\t   if (TREE_USED (olddecl)\n-\t       /* In unit-at-a-time mode we never inline re-defined extern\n-\t\t  inline functions.  */\n-\t       && !flag_unit_at_a_time\n-\t       && cgraph_function_possibly_inlined_p (olddecl))\n-\t     (*debug_hooks->outlining_inline_function) (olddecl);\n-\n-\t   /* The new defn must not be inline.  */\n-\t   DECL_INLINE (newdecl) = 0;\n-\t   DECL_UNINLINABLE (newdecl) = 1;\n-\t }\n-       else\n-\t {\n-\t   /* If either decl says `inline', this fn is inline,\n-\t      unless its definition was passed already.  */\n-\t   if (DECL_DECLARED_INLINE_P (newdecl)\n-\t       || DECL_DECLARED_INLINE_P (olddecl))\n-\t     DECL_DECLARED_INLINE_P (newdecl) = 1;\n-\n-\t   DECL_UNINLINABLE (newdecl) = DECL_UNINLINABLE (olddecl)\n-\t     = (DECL_UNINLINABLE (newdecl) || DECL_UNINLINABLE (olddecl));\n-\t }\n+      /* An extern decl does not override previous storage class.  */\n+      TREE_PUBLIC (newdecl) = TREE_PUBLIC (olddecl);\n+      if (!DECL_EXTERNAL (newdecl))\n+\t{\n+\t  DECL_CONTEXT (newdecl) = DECL_CONTEXT (olddecl);\n+\t  DECL_COMMON (newdecl) = DECL_COMMON (olddecl);\n+\t}\n+    }\n+  else\n+    {\n+      TREE_STATIC (olddecl) = TREE_STATIC (newdecl);\n+      TREE_PUBLIC (olddecl) = TREE_PUBLIC (newdecl);\n+    }\n \n-       if (DECL_BUILT_IN (olddecl))\n-\t {\n-\t   /* If redeclaring a builtin function, it stays built in.\n-\t      But it gets tagged as having been declared.  */\n-\t   DECL_BUILT_IN_CLASS (newdecl) = DECL_BUILT_IN_CLASS (olddecl);\n-\t   DECL_FUNCTION_CODE (newdecl) = DECL_FUNCTION_CODE (olddecl);\n-\t   C_DECL_DECLARED_BUILTIN (newdecl) = 1;\n-\t   if (new_is_prototype)\n-\t     C_DECL_BUILTIN_PROTOTYPE (newdecl) = 0;\n-\t   else\n-\t     C_DECL_BUILTIN_PROTOTYPE (newdecl)\n-\t       = C_DECL_BUILTIN_PROTOTYPE (olddecl);\n-\t }\n+  if (TREE_CODE (newdecl) == FUNCTION_DECL)\n+    {\n+      /* If we're redefining a function previously defined as extern\n+\t inline, make sure we emit debug info for the inline before we\n+\t throw it away, in case it was inlined into a function that\n+\t hasn't been written out yet.  */\n+      if (new_is_definition && DECL_INITIAL (olddecl))\n+\t{\n+\t  if (TREE_USED (olddecl)\n+\t      /* In unit-at-a-time mode we never inline re-defined extern\n+\t\t inline functions.  */\n+\t      && !flag_unit_at_a_time\n+\t      && cgraph_function_possibly_inlined_p (olddecl))\n+\t    (*debug_hooks->outlining_inline_function) (olddecl);\n+\n+\t  /* The new defn must not be inline.  */\n+\t  DECL_INLINE (newdecl) = 0;\n+\t  DECL_UNINLINABLE (newdecl) = 1;\n+\t}\n+      else\n+\t{\n+\t  /* If either decl says `inline', this fn is inline, unless\n+\t     its definition was passed already.  */\n+\t  if (DECL_DECLARED_INLINE_P (newdecl)\n+\t      || DECL_DECLARED_INLINE_P (olddecl))\n+\t    DECL_DECLARED_INLINE_P (newdecl) = 1;\n+\n+\t  DECL_UNINLINABLE (newdecl) = DECL_UNINLINABLE (olddecl)\n+\t    = (DECL_UNINLINABLE (newdecl) || DECL_UNINLINABLE (olddecl));\n+\t}\n \n-       /* Also preserve various other info from the definition.  */\n-       if (!new_is_definition)\n-\t {\n-\t   DECL_RESULT (newdecl) = DECL_RESULT (olddecl);\n-\t   DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n-\t   DECL_STRUCT_FUNCTION (newdecl) = DECL_STRUCT_FUNCTION (olddecl);\n-\t   DECL_SAVED_TREE (newdecl) = DECL_SAVED_TREE (olddecl);\n-\t   DECL_ARGUMENTS (newdecl) = DECL_ARGUMENTS (olddecl);\n-\n-\t   /* Set DECL_INLINE on the declaration if we've got a body\n-\t      from which to instantiate.  */\n-\t   if (DECL_INLINE (olddecl) && !DECL_UNINLINABLE (newdecl))\n-\t     {\n-\t       DECL_INLINE (newdecl) = 1;\n-\t       DECL_ABSTRACT_ORIGIN (newdecl)\n-\t\t = DECL_ABSTRACT_ORIGIN (olddecl);\n-\t     }\n-\t }\n-       else\n-\t {\n-\t   /* If a previous declaration said inline, mark the\n-\t      definition as inlinable.  */\n-\t   if (DECL_DECLARED_INLINE_P (newdecl)\n-\t       && !DECL_UNINLINABLE (newdecl))\n-\t     DECL_INLINE (newdecl) = 1;\n-\t }\n-     }\n+      if (DECL_BUILT_IN (olddecl))\n+\t{\n+\t  /* If redeclaring a builtin function, it stays built in.\n+\t     But it gets tagged as having been declared.  */\n+\t  DECL_BUILT_IN_CLASS (newdecl) = DECL_BUILT_IN_CLASS (olddecl);\n+\t  DECL_FUNCTION_CODE (newdecl) = DECL_FUNCTION_CODE (olddecl);\n+\t  C_DECL_DECLARED_BUILTIN (newdecl) = 1;\n+\t  if (new_is_prototype)\n+\t    C_DECL_BUILTIN_PROTOTYPE (newdecl) = 0;\n+\t  else\n+\t    C_DECL_BUILTIN_PROTOTYPE (newdecl)\n+\t      = C_DECL_BUILTIN_PROTOTYPE (olddecl);\n+\t}\n+\n+      /* Also preserve various other info from the definition.  */\n+      if (!new_is_definition)\n+\t{\n+\t  DECL_RESULT (newdecl) = DECL_RESULT (olddecl);\n+\t  DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n+\t  DECL_STRUCT_FUNCTION (newdecl) = DECL_STRUCT_FUNCTION (olddecl);\n+\t  DECL_SAVED_TREE (newdecl) = DECL_SAVED_TREE (olddecl);\n+\t  DECL_ARGUMENTS (newdecl) = DECL_ARGUMENTS (olddecl);\n+\n+\t  /* Set DECL_INLINE on the declaration if we've got a body\n+\t     from which to instantiate.  */\n+\t  if (DECL_INLINE (olddecl) && !DECL_UNINLINABLE (newdecl))\n+\t    {\n+\t      DECL_INLINE (newdecl) = 1;\n+\t      DECL_ABSTRACT_ORIGIN (newdecl)\n+\t\t= DECL_ABSTRACT_ORIGIN (olddecl);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* If a previous declaration said inline, mark the\n+\t     definition as inlinable.  */\n+\t  if (DECL_DECLARED_INLINE_P (newdecl)\n+\t      && !DECL_UNINLINABLE (newdecl))\n+\t    DECL_INLINE (newdecl) = 1;\n+\t}\n+    }\n \n-   /* Copy most of the decl-specific fields of NEWDECL into OLDDECL.\n+  /* Copy most of the decl-specific fields of NEWDECL into OLDDECL.\n      But preserve OLDDECL's DECL_UID and DECL_CONTEXT.  */\n   {\n     unsigned olddecl_uid = DECL_UID (olddecl);"}]}