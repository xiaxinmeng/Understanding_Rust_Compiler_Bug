{"sha": "564d80f490595b536426ffbb5b15a787f4561e8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY0ZDgwZjQ5MDU5NWI1MzY0MjZmZmJiNWIxNWE3ODdmNDU2MWU4ZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-01-24T16:39:07Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-01-24T16:39:07Z"}, "message": "i386.h (FIRST_PSEUDO_REGISTER): Set to 21.\n\n\t* i386.h (FIRST_PSEUDO_REGISTER): Set to 21.\n\t(FIXED_REGISTERS, CALL_USED_REGISTERS,\n\t REG_ALLOC_ORDER): Add frame pointer\n\t(FRAME_POINTER_REGNUM): Set to 20\n\t(HARD_FRAME_POINTER_REGNUM): New macro.\n\t(ELIMINABLE_REGS): Eliminate ARG_POINTER and FRAME_POINTER\n\tto HARD_FRAME_POINTER.\n\t(REGNO_OK_FOR_BASE_P): Accept FRAME_POINTER_REGNUM\n\t(REG_OK_FOR_INDEX_NONSTRICT_P): Likewise.\n\t(REG_OK_FOR_BASE_NONSTRICT_P): Likewise.\n\t(HI_REGISTER_NAMES): Add \"frame\".\n\t(CAN_ELIMINATE): Handle FRAME_POINTER_REGNUM elimination.\n\t(debug_reg): Handle FRAME_POINTER_REGNUM.\n\t(reg_class): Add arg pointer and frame pointer to NON_Q_REGS,\n\tGENERAL_REGS and INDEX_REGS.\n\t* i386.c (SAVED_REGS_FIRST): new macro.\n\t(AT_BP): Use hard_frame_pointer_rtx instead of frame_pointer_rtx\n\t(ix86_decompose_address, memory_address_length): Likewise.\n\t(regclass_map): Add frame pointer.\n\t(call_insn_operand): Handle frame_pointer_rtx.\n\t(reg_no_sp_operand): Likewise.\n\t(ix86_decompose_address): Handle frame_pointer_rtx as stack_pointer_rtx.\n\t(print_operand, legitimize_pic_address): Fix formating.\n\t(ix86_compute_frame_size): Make static, update prototype, new\n\tparameters padding1, padding2, use ix86_nsaved_regs, use\n\tstack_alignment_needed.\n\t(ix86_initial_elimination_offset): Handle FRAME_POINTER_REGNUM\n\tto HARD_FRAME_POINTER_REGNUM conversions.\n\t(ix86_expand_prologue): Handle SAVED_REGS_FIRST prologues.\n\t(ix86_expand_epilogue): Handle SAVED_REGS_FIRST epilogues.\n\t(print_reg): Abort on FRAME_POINTER_REGNUM\n\nFrom-SVN: r31587", "tree": {"sha": "cb77ac55bb967659389f2832e7fcb4b3a87f8983", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb77ac55bb967659389f2832e7fcb4b3a87f8983"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/564d80f490595b536426ffbb5b15a787f4561e8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/564d80f490595b536426ffbb5b15a787f4561e8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/564d80f490595b536426ffbb5b15a787f4561e8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/564d80f490595b536426ffbb5b15a787f4561e8e/comments", "author": null, "committer": null, "parents": [{"sha": "2247f6ed8d652b78666a4ccf19bb0ba691dfe7e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2247f6ed8d652b78666a4ccf19bb0ba691dfe7e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2247f6ed8d652b78666a4ccf19bb0ba691dfe7e1"}], "stats": {"total": 337, "additions": 235, "deletions": 102}, "files": [{"sha": "5b4d3ea42d9c7c3647dd921cbdda96006cb746a2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/564d80f490595b536426ffbb5b15a787f4561e8e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/564d80f490595b536426ffbb5b15a787f4561e8e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=564d80f490595b536426ffbb5b15a787f4561e8e", "patch": "@@ -1,3 +1,37 @@\n+Mon Jan 24 17:37:31 MET 2000  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.h (FIRST_PSEUDO_REGISTER): Set to 21.\n+\t(FIXED_REGISTERS, CALL_USED_REGISTERS,\n+\t REG_ALLOC_ORDER): Add frame pointer\n+\t(FRAME_POINTER_REGNUM): Set to 20\n+\t(HARD_FRAME_POINTER_REGNUM): New macro.\n+\t(ELIMINABLE_REGS): Eliminate ARG_POINTER and FRAME_POINTER\n+\tto HARD_FRAME_POINTER.\n+\t(REGNO_OK_FOR_BASE_P): Accept FRAME_POINTER_REGNUM\n+\t(REG_OK_FOR_INDEX_NONSTRICT_P): Likewise.\n+\t(REG_OK_FOR_BASE_NONSTRICT_P): Likewise.\n+\t(HI_REGISTER_NAMES): Add \"frame\".\n+\t(CAN_ELIMINATE): Handle FRAME_POINTER_REGNUM elimination.\n+\t(debug_reg): Handle FRAME_POINTER_REGNUM.\n+\t(reg_class): Add arg pointer and frame pointer to NON_Q_REGS,\n+\tGENERAL_REGS and INDEX_REGS.\n+\t* i386.c (SAVED_REGS_FIRST): new macro.\n+\t(AT_BP): Use hard_frame_pointer_rtx instead of frame_pointer_rtx\n+\t(ix86_decompose_address, memory_address_length): Likewise.\n+\t(regclass_map): Add frame pointer.\n+\t(call_insn_operand): Handle frame_pointer_rtx.\n+\t(reg_no_sp_operand): Likewise.\n+\t(ix86_decompose_address): Handle frame_pointer_rtx as stack_pointer_rtx.\n+\t(print_operand, legitimize_pic_address): Fix formating.\n+\t(ix86_compute_frame_size): Make static, update prototype, new\n+\tparameters padding1, padding2, use ix86_nsaved_regs, use\n+\tstack_alignment_needed.\n+\t(ix86_initial_elimination_offset): Handle FRAME_POINTER_REGNUM\n+\tto HARD_FRAME_POINTER_REGNUM conversions.\n+\t(ix86_expand_prologue): Handle SAVED_REGS_FIRST prologues.\n+\t(ix86_expand_epilogue): Handle SAVED_REGS_FIRST epilogues.\n+\t(print_reg): Abort on FRAME_POINTER_REGNUM\n+\n Mon Jan 24 16:50:08 MET 2000  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.h (PREDICATE_CODES): Add aligned_operand."}, {"sha": "2ea0fb7e99e0d90e43136e9b48ec3c35a432e1a1", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 164, "deletions": 80, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/564d80f490595b536426ffbb5b15a787f4561e8e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/564d80f490595b536426ffbb5b15a787f4561e8e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=564d80f490595b536426ffbb5b15a787f4561e8e", "patch": "@@ -41,6 +41,16 @@ Boston, MA 02111-1307, USA. */\n #include \"basic-block.h\"\n #include \"ggc.h\"\n \n+/* True when we want to do pushes before allocating stack to get better\n+   scheduling.\n+\n+   Saving registers first is win in the most cases except for LEAVE\n+   instruction.  Macro is 0 iff we will use LEAVE.  */\n+\n+#define SAVED_REGS_FIRST \\\n+  (!frame_pointer_needed || (!TARGET_USE_LEAVE && !optimize_size))\n+\n+\n #ifdef EXTRA_CONSTRAINT\n /* If EXTRA_CONSTRAINT is defined, then the 'S'\n    constraint in REG_CLASS_FROM_LETTER will no longer work, and various\n@@ -214,7 +224,7 @@ const int x86_split_long_moves = m_PPRO;\n const int x86_promote_QImode = m_K6 | m_PENT | m_386 | m_486;\n const int x86_single_stringop = m_386;\n \n-#define AT_BP(mode) (gen_rtx_MEM ((mode), frame_pointer_rtx))\n+#define AT_BP(mode) (gen_rtx_MEM ((mode), hard_frame_pointer_rtx))\n \n const char * const hi_reg_name[] = HI_REGISTER_NAMES;\n const char * const qi_reg_name[] = QI_REGISTER_NAMES;\n@@ -234,8 +244,8 @@ enum reg_class const regclass_map[FIRST_PSEUDO_REGISTER] =\n   FLOAT_REGS, FLOAT_REGS, FLOAT_REGS, FLOAT_REGS,\n   /* arg pointer */\n   NON_Q_REGS,\n-  /* flags, fpsr, dirflag */\n-  NO_REGS, NO_REGS, NO_REGS\n+  /* flags, fpsr, dirflag, frame */\n+  NO_REGS, NO_REGS, NO_REGS, NON_Q_REGS\n };\n \n /* The \"default\" register map.  */\n@@ -397,7 +407,8 @@ static void ix86_init_machine_status PARAMS ((struct function *));\n static void ix86_mark_machine_status PARAMS ((struct function *));\n static void ix86_split_to_parts PARAMS ((rtx, rtx *, enum machine_mode));\n static int ix86_safe_length_prefix PARAMS ((rtx));\n-static HOST_WIDE_INT ix86_compute_frame_size PARAMS((HOST_WIDE_INT, int *));\n+static HOST_WIDE_INT ix86_compute_frame_size PARAMS((HOST_WIDE_INT,\n+\t\t\t\t\t\t     int *, int *, int *));\n static int ix86_nsaved_regs PARAMS((void));\n static void ix86_emit_save_regs PARAMS((void));\n static void ix86_emit_restore_regs PARAMS((void));\n@@ -1051,6 +1062,7 @@ call_insn_operand (op, mode)\n      compiler aborts when trying to eliminate them.  */\n   if (GET_CODE (op) == REG\n       && (op == arg_pointer_rtx\n+\t  || op == frame_pointer_rtx\n \t  || (REGNO (op) >= FIRST_PSEUDO_REGISTER\n \t      && REGNO (op) <= LAST_VIRTUAL_REGISTER)))\n     return 0;\n@@ -1150,7 +1162,7 @@ reg_no_sp_operand (op, mode)\n   rtx t = op;\n   if (GET_CODE (t) == SUBREG)\n     t = SUBREG_REG (t);\n-  if (t == stack_pointer_rtx || t == arg_pointer_rtx)\n+  if (t == stack_pointer_rtx || t == arg_pointer_rtx || t == frame_pointer_rtx)\n     return 0;\n \n   return register_operand (op, mode);\n@@ -1644,91 +1656,133 @@ ix86_initial_elimination_offset (from, to)\n      int from;\n      int to;\n {\n-  if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n-    return 8;\t\t\t/* Skip saved PC and previous frame pointer */\n+  int padding1;\n+  int nregs;\n+\n+  /* Stack grows downward:\n+    \n+     [arguments]\n+\t\t\t\t\t\t<- ARG_POINTER\n+     saved pc\n+\n+     saved frame pointer if frame_pointer_needed\n+\t\t\t\t\t\t<- HARD_FRAME_POINTER\n+     [saved regs if SAVED_REGS_FIRST]\n+\n+     [padding1]   \\\n+\t\t   |\t\t\t\t<- FRAME_POINTER\n+     [frame]\t   > tsize\n+\t\t   |\n+     [padding2]   /\n+\n+     [saved regs if !SAVED_REGS_FIRST]\n+     \t\t\t\t\t\t<- STACK_POINTER\n+    */\n+\n+  if (from == ARG_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n+    /* Skip saved PC and previous frame pointer.\n+       Executed only when frame_pointer_needed.  */\n+    return 8;\n+  else if (from == FRAME_POINTER_REGNUM\n+\t   && to == HARD_FRAME_POINTER_REGNUM)\n+    {\n+      ix86_compute_frame_size (get_frame_size (), &nregs, &padding1, (int *)0);\n+      if (SAVED_REGS_FIRST)\n+\tpadding1 += nregs * UNITS_PER_WORD;\n+      return -padding1;\n+    }\n   else\n     {\n-      int nregs;\n-      int poffset;\n-      int offset;\n-      int preferred_alignment = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n+      /* ARG_POINTER or FRAME_POINTER to STACK_POINTER elimination.  */\n+      int frame_size = frame_pointer_needed ? 8 : 4;\n       HOST_WIDE_INT tsize = ix86_compute_frame_size (get_frame_size (),\n-\t\t\t\t\t\t     &nregs);\n-\n-      offset = (tsize + nregs * UNITS_PER_WORD);\n+\t\t\t\t\t\t     &nregs, &padding1, (int *)0);\n \n-      poffset = 4;\n-      if (frame_pointer_needed)\n-\tpoffset += UNITS_PER_WORD;\n \n-      if (from == ARG_POINTER_REGNUM)\n-\toffset += poffset;\n+      if (to != STACK_POINTER_REGNUM)\n+\tabort ();\n+      else if (from == ARG_POINTER_REGNUM)\n+\treturn tsize + nregs * UNITS_PER_WORD + frame_size;\n+      else if (from != FRAME_POINTER_REGNUM)\n+\tabort ();\n+      else if (SAVED_REGS_FIRST)\n+\treturn tsize - padding1;\n       else\n-\toffset -= ((poffset + preferred_alignment - 1)\n-\t\t   & -preferred_alignment) - poffset;\n-      return offset;\n+\treturn tsize + nregs * UNITS_PER_WORD - padding1;\n     }\n }\n \n /* Compute the size of local storage taking into consideration the\n    desired stack alignment which is to be maintained.  Also determine\n-   the number of registers saved below the local storage.  */\n-\n-HOST_WIDE_INT\n-ix86_compute_frame_size (size, nregs_on_stack)\n+   the number of registers saved below the local storage.  \n+ \n+   PADDING1 returns padding before stack frame and PADDING2 returns\n+   padding after stack frame;\n+ */\n+\n+static HOST_WIDE_INT\n+ix86_compute_frame_size (size, nregs_on_stack, rpadding1, rpadding2)\n      HOST_WIDE_INT size;\n      int *nregs_on_stack;\n+     int *rpadding1;\n+     int *rpadding2;\n {\n-  int limit;\n   int nregs;\n-  int regno;\n-  int padding;\n-  int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n-\t\t\t\t  || current_function_uses_const_pool);\n+  int padding1 = 0;\n+  int padding2 = 0;\n   HOST_WIDE_INT total_size;\n+  int stack_alignment_needed = cfun->stack_alignment_needed / BITS_PER_UNIT;\n \n-  limit = frame_pointer_needed\n-\t  ? FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM;\n+  nregs = ix86_nsaved_regs ();\n \n-  nregs = 0;\n-\n-  for (regno = limit - 1; regno >= 0; regno--)\n-    if ((regs_ever_live[regno] && ! call_used_regs[regno])\n-\t|| (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n-      nregs++;\n-\n-  padding = 0;\n-  total_size = size + (nregs * UNITS_PER_WORD);\n+  total_size = size;\n \n #ifdef PREFERRED_STACK_BOUNDARY\n   {\n     int offset;\n     int preferred_alignment = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n \n-    offset = 4;\n-    if (frame_pointer_needed)\n-      offset += UNITS_PER_WORD;\n+    offset = frame_pointer_needed ? 8 : 4;\n+\n+    /* When frame is not empty we ought to have recorded the alignment.  */\n+    if (size && !stack_alignment_needed)\n+      abort ();\n+\n+    if (stack_alignment_needed < 4)\n+      stack_alignment_needed = 4;\n+\n+    if (stack_alignment_needed > preferred_alignment)\n+      abort ();\n+\n+    if (SAVED_REGS_FIRST)\n+      offset += nregs * UNITS_PER_WORD;\n+    else\n+      total_size += nregs * UNITS_PER_WORD;\n \n     total_size += offset;\n-    \n-    padding = ((total_size + preferred_alignment - 1)\n-\t       & -preferred_alignment) - total_size;\n \n-    if (padding < (((offset + preferred_alignment - 1)\n-\t\t    & -preferred_alignment) - offset))\n-      padding += preferred_alignment;\n+    /* Align start of frame for local function.  */\n+    padding1 = ((offset + stack_alignment_needed - 1)\n+\t\t& -stack_alignment_needed) - offset;\n+    total_size += padding1;\n \n-    /* Don't bother aligning the stack of a leaf function\n-       which doesn't allocate any stack slots.  */\n-    if (size == 0 && current_function_is_leaf)\n-      padding = 0;\n+    /* Align stack boundary. */\n+    if (!current_function_is_leaf)\n+      padding2 = ((total_size + preferred_alignment - 1)\n+\t\t  & -preferred_alignment) - total_size;\n   }\n #endif\n \n   if (nregs_on_stack)\n     *nregs_on_stack = nregs;\n \n-  return size + padding;\n+  if (rpadding1)\n+    *rpadding1 = padding1;\n+\n+  if (rpadding2)\n+    *rpadding2 = padding2;\n+\n+  return size + padding1 + padding2;\n }\n \n /* Emit code to save registers in the prologue.  */\n@@ -1742,7 +1796,7 @@ ix86_emit_save_regs ()\n   int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n \t\t\t\t  || current_function_uses_const_pool);\n   limit = (frame_pointer_needed\n-\t   ? FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n+\t   ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n \n   for (regno = limit - 1; regno >= 0; regno--)\n     if ((regs_ever_live[regno] && !call_used_regs[regno])\n@@ -1758,23 +1812,27 @@ ix86_emit_save_regs ()\n void\n ix86_expand_prologue ()\n {\n+  HOST_WIDE_INT tsize = ix86_compute_frame_size (get_frame_size (), (int *)0, (int *)0,\n+\t\t\t\t\t\t (int *)0);\n+  rtx insn;\n   int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n \t\t\t\t  || current_function_uses_const_pool);\n-  HOST_WIDE_INT tsize = ix86_compute_frame_size (get_frame_size (), (int *)0);\n-  rtx insn;\n \n   /* Note: AT&T enter does NOT have reversed args.  Enter is probably\n      slower on all targets.  Also sdb doesn't like it.  */\n \n   if (frame_pointer_needed)\n     {\n-      insn = emit_insn (gen_push (frame_pointer_rtx));\n+      insn = emit_insn (gen_push (hard_frame_pointer_rtx));\n       RTX_FRAME_RELATED_P (insn) = 1;\n \n-      insn = emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n+      insn = emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n+  if (SAVED_REGS_FIRST)\n+    ix86_emit_save_regs ();\n+\n   if (tsize == 0)\n     ;\n   else if (! TARGET_STACK_PROBE || tsize < CHECK_STACK_LIMIT)\n@@ -1783,7 +1841,7 @@ ix86_expand_prologue ()\n \tinsn = emit_insn (gen_prologue_allocate_stack (stack_pointer_rtx,\n \t\t\t\t\t\t       stack_pointer_rtx,\n \t\t\t\t\t\t       GEN_INT (-tsize),\n-\t\t\t\t\t\t       frame_pointer_rtx));\n+\t\t\t\t\t\t       hard_frame_pointer_rtx));\n       else\n         insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t\t      GEN_INT (-tsize)));\n@@ -1807,7 +1865,9 @@ ix86_expand_prologue ()\n \t\t\t     CALL_INSN_FUNCTION_USAGE (insn));\n     }\n \n-  ix86_emit_save_regs ();\n+  if (!SAVED_REGS_FIRST)\n+    ix86_emit_save_regs ();\n+\n #ifdef SUBTARGET_PROLOGUE\n   SUBTARGET_PROLOGUE;\n #endif  \n@@ -1830,7 +1890,7 @@ ix86_emit_restore_regs ()\n   int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n \t\t\t\t  || current_function_uses_const_pool);\n   int limit = (frame_pointer_needed\n-\t       ? FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n+\t       ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n   int regno;\n \n   for (regno = 0; regno < limit; regno++)\n@@ -1900,20 +1960,38 @@ ix86_expand_epilogue ()\n \t\t\t\t  || current_function_uses_const_pool);\n   int sp_valid = !frame_pointer_needed || current_function_sp_is_unchanging;\n   HOST_WIDE_INT offset;\n-  HOST_WIDE_INT tsize = ix86_compute_frame_size (get_frame_size (), &nregs);\n+  HOST_WIDE_INT tsize = ix86_compute_frame_size (get_frame_size (), &nregs, (int *)0,\n+\t\t\t\t\t\t (int *)0);\n \n   /* SP is often unreliable so we may have to go off the frame pointer. */\n \n   offset = -(tsize + nregs * UNITS_PER_WORD);\n \n+  if (SAVED_REGS_FIRST)\n+    {\n+      if (!sp_valid)\n+        {\n+\t  if (nregs)\n+\t    emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t\t    gen_rtx_PLUS (SImode, hard_frame_pointer_rtx,\n+\t\t\t\t\t\t  GEN_INT (- nregs * UNITS_PER_WORD))));\n+\t  else\n+\t    emit_insn (gen_epilogue_deallocate_stack (stack_pointer_rtx,\n+\t\t\t\t\t\t   hard_frame_pointer_rtx));\n+\t}\n+      else if (tsize)\n+\tix86_emit_epilogue_esp_adjustment (tsize);\n+      ix86_emit_restore_regs ();\n+    }\n+\n   /* If we're only restoring one register and sp is not valid then\n      using a move instruction to restore the register since it's\n      less work than reloading sp and popping the register.  Otherwise,\n      restore sp (if necessary) and pop the registers. */\n \n-  if (nregs > 1 || sp_valid)\n+  else if (nregs > 1 || sp_valid)\n     {\n-      if ( !sp_valid )\n+      if (!sp_valid)\n \t{\n \t  rtx addr_offset;\n \t  addr_offset = adj_offsettable_operand (AT_BP (QImode), offset);\n@@ -1927,7 +2005,7 @@ ix86_expand_epilogue ()\n   else\n     {\n       limit = (frame_pointer_needed\n-\t       ? FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n+\t       ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n       for (regno = 0; regno < limit; regno++)\n \tif ((regs_ever_live[regno] && ! call_used_regs[regno])\n \t    || (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n@@ -1941,16 +2019,17 @@ ix86_expand_epilogue ()\n   if (frame_pointer_needed)\n     {\n       /* If not an i386, mov & pop is faster than \"leave\". */\n-      if (TARGET_USE_LEAVE)\n-\temit_insn (gen_leave());\n+      if (TARGET_USE_LEAVE || optimize_size)\n+\temit_insn (gen_leave ());\n       else\n \t{\n-\t  emit_insn (gen_epilogue_deallocate_stack (stack_pointer_rtx,\n-\t\t\t\t\t\t    frame_pointer_rtx));\n-\t  emit_insn (gen_popsi1 (frame_pointer_rtx));\n+\t  if (!SAVED_REGS_FIRST)\n+\t    emit_insn (gen_epilogue_deallocate_stack (stack_pointer_rtx,\n+\t\t\t\t\t\t   hard_frame_pointer_rtx));\n+\t  emit_insn (gen_popsi1 (hard_frame_pointer_rtx));\n \t}\n     }\n-  else if (tsize)\n+  else if (!SAVED_REGS_FIRST && tsize)\n     ix86_emit_epilogue_esp_adjustment (tsize);\n \n #ifdef FUNCTION_BLOCK_PROFILER_EXIT\n@@ -2071,15 +2150,18 @@ ix86_decompose_address (addr, out)\n \n   /* Allow arg pointer and stack pointer as index if there is not scaling */\n   if (base && index && scale == 1\n-      && (index == arg_pointer_rtx || index == stack_pointer_rtx))\n+      && (index == arg_pointer_rtx || index == frame_pointer_rtx\n+          || index == stack_pointer_rtx))\n     {\n       rtx tmp = base;\n       base = index;\n       index = tmp;\n     }\n \n   /* Special case: %ebp cannot be encoded as a base without a displacement.  */\n-  if (base == frame_pointer_rtx && !disp)\n+  if ((base == hard_frame_pointer_rtx\n+       || base == frame_pointer_rtx\n+       || base == arg_pointer_rtx) && !disp)\n     disp = const0_rtx;\n \n   /* Special case: on K6, [%esi] makes the instruction vector decoded.\n@@ -2388,7 +2470,7 @@ legitimize_pic_address (orig, reg)\n \t      /* Check that the unspec is one of the ones we generate?  */\n \t    }\n \t  else if (GET_CODE (addr) != PLUS)\n-\t    abort();\n+\t    abort ();\n \t}\n       if (GET_CODE (addr) == PLUS)\n \t{\n@@ -2807,6 +2889,7 @@ print_reg (x, code, file)\n      FILE *file;\n {\n   if (REGNO (x) == ARG_POINTER_REGNUM\n+      || REGNO (x) == FRAME_POINTER_REGNUM\n       || REGNO (x) == FLAGS_REG\n       || REGNO (x) == FPSR_REG)\n     abort ();\n@@ -3029,7 +3112,7 @@ print_operand (file, x, code)\n \t    case 8: size = \"QWORD\"; break;\n \t    case 12: size = \"XWORD\"; break;\n \t    default:\n-\t      abort();\n+\t      abort ();\n \t    }\n \t  fputs (size, file);\n \t  fputs (\" PTR \", file);\n@@ -3251,7 +3334,7 @@ split_di (operands, num, lo_half, hi_half)\n \t  hi_half[num] = change_address (op, SImode, hi_addr);\n \t}\n       else\n-\tabort();\n+\tabort ();\n     }\n }\n \f\n@@ -5580,7 +5663,8 @@ memory_address_length (addr)\n       /* Special cases: ebp and esp need the two-byte modrm form.  */\n       if (addr == stack_pointer_rtx\n \t  || addr == arg_pointer_rtx\n-\t  || addr == frame_pointer_rtx)\n+\t  || addr == frame_pointer_rtx\n+\t  || addr == hard_frame_pointer_rtx)\n \tlen = 1;\n     }\n "}, {"sha": "0dddfafe2223fdeeb166c2b49dce3208673424bc", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 37, "deletions": 22, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/564d80f490595b536426ffbb5b15a787f4561e8e/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/564d80f490595b536426ffbb5b15a787f4561e8e/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=564d80f490595b536426ffbb5b15a787f4561e8e", "patch": "@@ -619,7 +619,7 @@ extern int ix86_arch;\n    eliminated during reloading in favor of either the stack or frame\n    pointer. */\n \n-#define FIRST_PSEUDO_REGISTER 20\n+#define FIRST_PSEUDO_REGISTER 21\n \n /* Number of hardware registers that go into the DWARF-2 unwind info.\n    If not defined, equals FIRST_PSEUDO_REGISTER.  */\n@@ -631,7 +631,9 @@ extern int ix86_arch;\n    On the 80386, the stack pointer is such, as is the arg pointer. */\n #define FIXED_REGISTERS \\\n /*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg,flags,fpsr, dir*/ \\\n-{  0, 0, 0, 0, 0, 0, 0, 1, 0,  0,  0,  0,  0,  0,  0,  0,  1,    0,   0,   0 }\n+{  0, 0, 0, 0, 0, 0, 0, 1, 0,  0,  0,  0,  0,  0,  0,  0,  1,    0,   0,   0,  \\\n+/*frame\t\t\t\t\t\t\t\t\t    */ \\\n+   1}\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -642,7 +644,9 @@ extern int ix86_arch;\n \n #define CALL_USED_REGISTERS \\\n /*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg,flags,fpsr, dir*/ \\\n-{  1, 1, 1, 0, 0, 0, 0, 1, 1,  1,  1,  1,  1,  1,  1,  1,  1,    1,   1,   1 }\n+{  1, 1, 1, 0, 0, 0, 0, 1, 1,  1,  1,  1,  1,  1,  1,  1,  1,    1,   1,   1,  \\\n+/*frame\t\t\t\t\t\t\t\t\t    */ \\\n+   1}\n \n /* Order in which to allocate registers.  Each register must be\n    listed once, even those in FIXED_REGISTERS.  List frame pointer\n@@ -665,7 +669,9 @@ extern int ix86_arch;\n \n #define REG_ALLOC_ORDER \\\n /*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg,cc,fpsr, dir*/ \\\n-{  0, 1, 2, 3, 4, 5, 6, 7, 8,  9, 10, 11, 12, 13, 14, 15, 16,17,  18,  19 }\n+{  0, 1, 2, 3, 4, 5, 6, 7, 8,  9, 10, 11, 12, 13, 14, 15, 16,17,  18,  19,  \\\n+/*frame\t\t\t\t\t\t\t\t\t */ \\\n+  20}\n \n /* A C statement (sans semicolon) to choose the order in which to\n    allocate hard registers for pseudo-registers local to a basic\n@@ -762,7 +768,10 @@ extern int ix86_arch;\n #define STACK_POINTER_REGNUM 7\n \n /* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM 6\n+#define HARD_FRAME_POINTER_REGNUM 6\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 20\n \n /* First floating point reg */\n #define FIRST_FLOAT_REG 8\n@@ -853,7 +862,7 @@ enum reg_class\n   AREG, DREG, CREG, BREG, SIREG, DIREG,\n   AD_REGS,\t\t\t/* %eax/%edx for DImode */\n   Q_REGS,\t\t\t/* %eax %ebx %ecx %edx */\n-  NON_Q_REGS,\t\t\t/* %esi %edi %ebp %esi */\n+  NON_Q_REGS,\t\t\t/* %esi %edi %ebp %esp */\n   INDEX_REGS,\t\t\t/* %eax %ebx %ecx %edx %esi %edi %ebp */\n   GENERAL_REGS,\t\t\t/* %eax %ebx %ecx %edx %esi %edi %ebp %esp */\n   FP_TOP_REG, FP_SECOND_REG,\t/* %st(0) %st(1) */\n@@ -893,13 +902,13 @@ enum reg_class\n     {0x10},   {0x20},\t\t/* SIREG, DIREG */\t\t\\\n      {0x3},\t\t\t/* AD_REGS */\t\t\t\\\n      {0xf},\t\t\t/* Q_REGS */\t\t\t\\\n-    {0xf0},\t\t\t/* NON_Q_REGS */\t\t\\\n+{0x1100f0},\t\t\t/* NON_Q_REGS */\t\t\\\n     {0x7f},\t\t\t/* INDEX_REGS */\t\t\\\n- {0x100ff},\t\t\t/* GENERAL_REGS */\t\t\\\n+{0x1100ff},\t\t\t/* GENERAL_REGS */\t\t\\\n   {0x0100}, {0x0200},\t\t/* FP_TOP_REG, FP_SECOND_REG */\t\\\n   {0xff00},\t\t\t/* FLOAT_REGS */\t\t\\\n-  {0x1ffff},\t\t\t/* FLOAT_INT_REGS */\t\t\\\n- {0x7ffff}\t\t\t\t\t\t\t\\\n+{0x11ffff},\t\t\t/* FLOAT_INT_REGS */\t\t\\\n+{0x17ffff}\t\t\t\t\t\t\t\\\n }\n \n /* The same information, inverted:\n@@ -1392,15 +1401,16 @@ do {\t\t\t\t\t\t\t\t\\\n    followed by \"to\".  Eliminations of the same \"from\" register are listed\n    in order of preference.\n \n-   We have two registers that can be eliminated on the i386.  First, the\n-   frame pointer register can often be eliminated in favor of the stack\n-   pointer register.  Secondly, the argument pointer register can always be\n-   eliminated; it is replaced with either the stack or frame pointer. */\n+   We have three registers that can be eliminated on the i386.  First, the\n+   hard frame pointer register can often be eliminated in favor of the stack\n+   pointer register.  Secondly, the argument and frame pointer register can\n+   always be eliminated; They are replaced with either the stack or frame pointer. */\n \n-#define ELIMINABLE_REGS\t\t\t\t\\\n-{{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n- { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},   \\\n- { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n+#define ELIMINABLE_REGS\t\t\t\t\t\\\n+{{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n+ { ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},\t\\\n+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n+ { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\t\\\n \n /* Given FROM and TO register numbers, say whether this elimination is allowed.\n    Frame pointer elimination is automatically handled.\n@@ -1410,9 +1420,10 @@ do {\t\t\t\t\t\t\t\t\\\n \n    All other eliminations are valid.  */\n \n-#define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\\\n- ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM\t\\\n-  ? ! frame_pointer_needed\t\t\t\t\t\\\n+#define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\t\\\n+ ((((FROM) == ARG_POINTER_REGNUM || (FROM) == FRAME_POINTER_REGNUM)\t\\\n+   && (TO) == STACK_POINTER_REGNUM)\t\t\t\t\t\\\n+  ? ! frame_pointer_needed\t\t\t\t\t\t\\\n   : 1)\n \n /* Define the offset between two registers, one to be eliminated, and the other\n@@ -1444,6 +1455,7 @@ do {\t\t\t\t\t\t\t\t\\\n #define REGNO_OK_FOR_BASE_P(REGNO) \\\n   ((REGNO) <= STACK_POINTER_REGNUM \\\n    || (REGNO) == ARG_POINTER_REGNUM \\\n+   || (REGNO) == FRAME_POINTER_REGNUM \\\n    || (unsigned) reg_renumber[REGNO] <= STACK_POINTER_REGNUM)\n \n #define REGNO_OK_FOR_SIREG_P(REGNO) ((REGNO) == 4 || reg_renumber[REGNO] == 4)\n@@ -1471,6 +1483,7 @@ do {\t\t\t\t\t\t\t\t\\\n #define REG_OK_FOR_BASE_NONSTRICT_P(X)\t\t\t\t\t\\\n   (REGNO (X) <= STACK_POINTER_REGNUM\t\t\t\t\t\\\n    || REGNO (X) == ARG_POINTER_REGNUM\t\t\t\t\t\\\n+   || REGNO (X) == FRAME_POINTER_REGNUM \\\n    || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n \n #define REG_OK_FOR_STRREG_NONSTRICT_P(X)\t\t\t\t\\\n@@ -2153,7 +2166,7 @@ while (0)\n #define HI_REGISTER_NAMES\t\t\t\t\t\t\\\n {\"ax\",\"dx\",\"cx\",\"bx\",\"si\",\"di\",\"bp\",\"sp\",\t\t\t\t\\\n  \"st\",\"st(1)\",\"st(2)\",\"st(3)\",\"st(4)\",\"st(5)\",\"st(6)\",\"st(7)\",\"\",\t\\\n- \"flags\",\"fpsr\", \"dirflag\" }\n+ \"flags\",\"fpsr\", \"dirflag\", \"frame\" }\n \n #define REGISTER_NAMES HI_REGISTER_NAMES\n \n@@ -2365,6 +2378,8 @@ do { long l;\t\t\t\t\t\t\\\n \t { fputs (\"fpsr\", FILE); break; }\t\t\\\n        if (REGNO (X) == ARG_POINTER_REGNUM)\t\t\\\n \t { fputs (\"argp\", FILE); break; }\t\t\\\n+       if (REGNO (X) == FRAME_POINTER_REGNUM)\t\t\\\n+\t { fputs (\"frame\", FILE); break; }\t\t\\\n        if (STACK_TOP_P (X))\t\t\t\t\\\n \t { fputs (\"st(0)\", FILE); break; }\t\t\\\n        if (FP_REG_P (X))\t\t\t\t\\"}]}