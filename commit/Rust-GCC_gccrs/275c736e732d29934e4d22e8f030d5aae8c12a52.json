{"sha": "275c736e732d29934e4d22e8f030d5aae8c12a52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc1YzczNmU3MzJkMjk5MzRlNGQyMmU4ZjAzMGQ1YWFlOGMxMmE1Mg==", "commit": {"author": {"name": "Chung-Lin Tang", "email": "cltang@codesourcery.com", "date": "2021-06-17T13:33:32Z"}, "committer": {"name": "Chung-Lin Tang", "email": "cltang@codesourcery.com", "date": "2021-06-17T13:34:59Z"}, "message": "libgomp: Structure element mapping for OpenMP 5.0\n\nThis patch implement OpenMP 5.0 requirements of incrementing/decrementing\nthe reference count of a mapped structure at most once (across all elements)\non a construct.\n\nThis is implemented by pulling in libgomp/hashtab.h and using htab_t as a\npointer set. Structure element list siblings also have pointers-to-refcounts\nlinked together, to naturally achieve uniform increment/decrement without\nrepeating.\n\nThere are still some questions on whether using such a htab_t based set is\nfaster/slower than using a sorted pointer array based implementation. This\nis to be researched on later.\n\nlibgomp/ChangeLog:\n\n\t* hashtab.h (htab_clear): New function with initialization code\n\tfactored out from...\n\t(htab_create): ...here, adjust to use htab_clear function.\n\n\t* libgomp.h (REFCOUNT_SPECIAL): New symbol to denote range of\n\tspecial refcount values, add comments.\n\t(REFCOUNT_INFINITY): Adjust definition to use REFCOUNT_SPECIAL.\n\t(REFCOUNT_LINK): Likewise.\n\t(REFCOUNT_STRUCTELEM): New special refcount range for structure\n\telement siblings.\n\t(REFCOUNT_STRUCTELEM_P): Macro for testing for structure element\n\tsibling maps.\n\t(REFCOUNT_STRUCTELEM_FLAG_FIRST): Flag to indicate first sibling.\n\t(REFCOUNT_STRUCTELEM_FLAG_LAST):  Flag to indicate last sibling.\n\t(REFCOUNT_STRUCTELEM_FIRST_P): Macro to test _FIRST flag.\n\t(REFCOUNT_STRUCTELEM_LAST_P): Macro to test _LAST flag.\n\t(struct splay_tree_key_s): Add structelem_refcount and\n\tstructelem_refcount_ptr fields into a union with dynamic_refcount.\n\tAdd comments.\n\t(gomp_map_vars): Delete declaration.\n\t(gomp_map_vars_async): Likewise.\n\t(gomp_unmap_vars): Likewise.\n\t(gomp_unmap_vars_async): Likewise.\n\t(goacc_map_vars): New declaration.\n\t(goacc_unmap_vars): Likewise.\n\n\t* oacc-mem.c (acc_map_data): Adjust to use goacc_map_vars.\n\t(goacc_enter_datum): Likewise.\n\t(goacc_enter_data_internal): Likewise.\n\t* oacc-parallel.c (GOACC_parallel_keyed): Adjust to use goacc_map_vars\n\tand goacc_unmap_vars.\n\t(GOACC_data_start): Adjust to use goacc_map_vars.\n\t(GOACC_data_end): Adjust to use goacc_unmap_vars.\n\n\t* target.c (hash_entry_type): New typedef.\n\t(htab_alloc): New function hook for hashtab.h.\n\t(htab_free): Likewise.\n\t(htab_hash): Likewise.\n\t(htab_eq): Likewise.\n\t(hashtab.h): Add file include.\n\t(gomp_increment_refcount): New function.\n\t(gomp_decrement_refcount): Likewise.\n\t(gomp_map_vars_existing): Add refcount_set parameter, adjust to use\n\tgomp_increment_refcount.\n\t(gomp_map_fields_existing): Add refcount_set parameter, adjust calls\n\tto gomp_map_vars_existing.\n\n\t(gomp_map_vars_internal): Add refcount_set parameter, add local openmp_p\n\tvariable to guard OpenMP specific paths, adjust calls to\n\tgomp_map_vars_existing, add structure element sibling splay_tree_key\n\tsequence creation code, adjust Fortran map case to avoid increment\n\tunder OpenMP.\n\t(gomp_map_vars): Adjust to static, add refcount_set parameter, manage\n\tlocal refcount_set if caller passed in NULL, adjust call to\n\tgomp_map_vars_internal.\n\t(gomp_map_vars_async): Adjust and rename into...\n\t(goacc_map_vars): ...this new function, adjust call to\n\tgomp_map_vars_internal.\n\n\t(gomp_remove_splay_tree_key): New function with code factored out from\n\tgomp_remove_var_internal.\n\t(gomp_remove_var_internal): Add code to handle removing multiple\n\tsplay_tree_key sequence for structure elements, adjust code to use\n\tgomp_remove_splay_tree_key for splay-tree key removal.\n\t(gomp_unmap_vars_internal): Add refcount_set parameter, adjust to use\n\tgomp_decrement_refcount.\n\t(gomp_unmap_vars): Adjust to static, add refcount_set parameter, manage\n\tlocal refcount_set if caller passed in NULL, adjust call to\n\tgomp_unmap_vars_internal.\n\t(gomp_unmap_vars_async): Adjust and rename into...\n\t(goacc_unmap_vars): ...this new function, adjust call to\n\tgomp_unmap_vars_internal.\n\t(GOMP_target): Manage refcount_set and adjust calls to gomp_map_vars and\n\tgomp_unmap_vars.\n\t(GOMP_target_ext): Likewise.\n\t(gomp_target_data_fallback): Adjust call to gomp_map_vars.\n\t(GOMP_target_data): Likewise.\n\t(GOMP_target_data_ext): Likewise.\n\t(GOMP_target_end_data): Adjust call to gomp_unmap_vars.\n\t(gomp_exit_data): Add refcount_set parameter, adjust to use\n\tgomp_decrement_refcount, adjust to queue splay-tree keys for removal\n\tafter main loop.\n\t(GOMP_target_enter_exit_data): Manage refcount_set and adjust calls to\n\tgomp_map_vars and gomp_exit_data.\n\t(gomp_target_task_fn): Likewise.\n\n\t* testsuite/libgomp.c-c++-common/refcount-1.c: New testcase.\n\t* testsuite/libgomp.c-c++-common/struct-elem-1.c: New testcase.\n\t* testsuite/libgomp.c-c++-common/struct-elem-2.c: New testcase.\n\t* testsuite/libgomp.c-c++-common/struct-elem-3.c: New testcase.\n\t* testsuite/libgomp.c-c++-common/struct-elem-4.c: New testcase.\n\t* testsuite/libgomp.c-c++-common/struct-elem-5.c: New testcase.", "tree": {"sha": "bebf3236996c5f633d6c8982de058666cbcb6f36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bebf3236996c5f633d6c8982de058666cbcb6f36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/275c736e732d29934e4d22e8f030d5aae8c12a52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/275c736e732d29934e4d22e8f030d5aae8c12a52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/275c736e732d29934e4d22e8f030d5aae8c12a52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/275c736e732d29934e4d22e8f030d5aae8c12a52/comments", "author": {"login": "cltang", "id": 4055966, "node_id": "MDQ6VXNlcjQwNTU5NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/4055966?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cltang", "html_url": "https://github.com/cltang", "followers_url": "https://api.github.com/users/cltang/followers", "following_url": "https://api.github.com/users/cltang/following{/other_user}", "gists_url": "https://api.github.com/users/cltang/gists{/gist_id}", "starred_url": "https://api.github.com/users/cltang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cltang/subscriptions", "organizations_url": "https://api.github.com/users/cltang/orgs", "repos_url": "https://api.github.com/users/cltang/repos", "events_url": "https://api.github.com/users/cltang/events{/privacy}", "received_events_url": "https://api.github.com/users/cltang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cltang", "id": 4055966, "node_id": "MDQ6VXNlcjQwNTU5NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/4055966?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cltang", "html_url": "https://github.com/cltang", "followers_url": "https://api.github.com/users/cltang/followers", "following_url": "https://api.github.com/users/cltang/following{/other_user}", "gists_url": "https://api.github.com/users/cltang/gists{/gist_id}", "starred_url": "https://api.github.com/users/cltang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cltang/subscriptions", "organizations_url": "https://api.github.com/users/cltang/orgs", "repos_url": "https://api.github.com/users/cltang/repos", "events_url": "https://api.github.com/users/cltang/events{/privacy}", "received_events_url": "https://api.github.com/users/cltang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "967b46530234b4e6ad3983057705aea6c20a03c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/967b46530234b4e6ad3983057705aea6c20a03c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/967b46530234b4e6ad3983057705aea6c20a03c4"}], "stats": {"total": 845, "additions": 709, "deletions": 136}, "files": [{"sha": "26d80813436ad8c1fc8fb6fdfb6c466f528ec850", "filename": "libgomp/hashtab.h", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/275c736e732d29934e4d22e8f030d5aae8c12a52/libgomp%2Fhashtab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/275c736e732d29934e4d22e8f030d5aae8c12a52/libgomp%2Fhashtab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fhashtab.h?ref=275c736e732d29934e4d22e8f030d5aae8c12a52", "patch": "@@ -224,6 +224,15 @@ htab_mod_m2 (hashval_t hash, htab_t htab)\n   return 1 + htab_mod_1 (hash, p->prime - 2, p->inv_m2, p->shift);\n }\n \n+static inline htab_t\n+htab_clear (htab_t htab)\n+{\n+  htab->n_elements = 0;\n+  htab->n_deleted = 0;\n+  memset (htab->entries, 0, htab->size * sizeof (hash_entry_type));\n+  return htab;\n+}\n+\n /* Create hash table of size SIZE.  */\n \n static htab_t\n@@ -238,11 +247,8 @@ htab_create (size_t size)\n   result = (htab_t) htab_alloc (sizeof (struct htab)\n \t\t\t\t+ size * sizeof (hash_entry_type));\n   result->size = size;\n-  result->n_elements = 0;\n-  result->n_deleted = 0;\n   result->size_prime_index = size_prime_index;\n-  memset (result->entries, 0, size * sizeof (hash_entry_type));\n-  return result;\n+  return htab_clear (result);\n }\n \n /* Similar to htab_find_slot, but without several unwanted side effects:"}, {"sha": "8d25dc8e2a8518421bacb091690e28ac0c8fc8a5", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 49, "deletions": 17, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/275c736e732d29934e4d22e8f030d5aae8c12a52/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/275c736e732d29934e4d22e8f030d5aae8c12a52/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=275c736e732d29934e4d22e8f030d5aae8c12a52", "patch": "@@ -1012,11 +1012,35 @@ struct target_mem_desc {\n   struct target_var_desc list[];\n };\n \n+/* Special value for refcount - mask to indicate existence of special\n+   values. Right now we allocate 3 bits.  */\n+#define REFCOUNT_SPECIAL (~(uintptr_t) 0x7)\n+\n /* Special value for refcount - infinity.  */\n-#define REFCOUNT_INFINITY (~(uintptr_t) 0)\n+#define REFCOUNT_INFINITY (REFCOUNT_SPECIAL | 0)\n /* Special value for refcount - tgt_offset contains target address of the\n    artificial pointer to \"omp declare target link\" object.  */\n-#define REFCOUNT_LINK (~(uintptr_t) 1)\n+#define REFCOUNT_LINK     (REFCOUNT_SPECIAL | 1)\n+\n+/* Special value for refcount - structure element sibling list items.\n+   All such key refounts have REFCOUNT_STRUCTELEM bits set, with _FLAG_FIRST\n+   and _FLAG_LAST indicating first and last in the created sibling sequence.  */\n+#define REFCOUNT_STRUCTELEM (REFCOUNT_SPECIAL | 4)\n+#define REFCOUNT_STRUCTELEM_P(V)\t\t\t\\\n+  (((V) & REFCOUNT_STRUCTELEM) == REFCOUNT_STRUCTELEM)\n+/* The first leading key with _FLAG_FIRST set houses the actual reference count\n+   in the structelem_refcount field. Other siblings point to this counter value\n+   through its structelem_refcount_ptr field.  */\n+#define REFCOUNT_STRUCTELEM_FLAG_FIRST (1)\n+/* The last key in the sibling sequence has this set. This is required to\n+   indicate the sequence boundary, when we remove the structure sibling list\n+   from the map.  */\n+#define REFCOUNT_STRUCTELEM_FLAG_LAST  (2)\n+\n+#define REFCOUNT_STRUCTELEM_FIRST_P(V)\t\t\t\t\t\\\n+  (REFCOUNT_STRUCTELEM_P (V) && ((V) & REFCOUNT_STRUCTELEM_FLAG_FIRST))\n+#define REFCOUNT_STRUCTELEM_LAST_P(V)\t\t\t\t\t\\\n+  (REFCOUNT_STRUCTELEM_P (V) && ((V) & REFCOUNT_STRUCTELEM_FLAG_LAST))\n \n /* Special offset values.  */\n #define OFFSET_INLINED (~(uintptr_t) 0)\n@@ -1044,8 +1068,22 @@ struct splay_tree_key_s {\n   uintptr_t tgt_offset;\n   /* Reference count.  */\n   uintptr_t refcount;\n-  /* Dynamic reference count.  */\n-  uintptr_t dynamic_refcount;\n+  union {\n+    /* Dynamic reference count.  */\n+    uintptr_t dynamic_refcount;\n+\n+    /* Unified reference count for structure element siblings, this is used\n+       when REFCOUNT_STRUCTELEM_FIRST_P(k->refcount) == true, the first sibling\n+       in a structure element sibling list item sequence.  */\n+    uintptr_t structelem_refcount;\n+\n+    /* When REFCOUNT_STRUCTELEM_P (k->refcount) == true, this field points\n+       into the (above) structelem_refcount field of the _FIRST splay_tree_key,\n+       the first key in the created sequence. All structure element siblings\n+       share a single refcount in this manner. Since these two fields won't be\n+       used at the same time, they are stashed in a union.  */\n+    uintptr_t *structelem_refcount_ptr;\n+  };\n   struct splay_tree_aux *aux;\n };\n \n@@ -1200,19 +1238,13 @@ extern void gomp_attach_pointer (struct gomp_device_descr *,\n extern void gomp_detach_pointer (struct gomp_device_descr *,\n \t\t\t\t struct goacc_asyncqueue *, splay_tree_key,\n \t\t\t\t uintptr_t, bool, struct gomp_coalesce_buf *);\n-\n-extern struct target_mem_desc *gomp_map_vars (struct gomp_device_descr *,\n-\t\t\t\t\t      size_t, void **, void **,\n-\t\t\t\t\t      size_t *, void *, bool,\n-\t\t\t\t\t      enum gomp_map_vars_kind);\n-extern struct target_mem_desc *gomp_map_vars_async (struct gomp_device_descr *,\n-\t\t\t\t\t\t    struct goacc_asyncqueue *,\n-\t\t\t\t\t\t    size_t, void **, void **,\n-\t\t\t\t\t\t    size_t *, void *, bool,\n-\t\t\t\t\t\t    enum gomp_map_vars_kind);\n-extern void gomp_unmap_vars (struct target_mem_desc *, bool);\n-extern void gomp_unmap_vars_async (struct target_mem_desc *, bool,\n-\t\t\t\t   struct goacc_asyncqueue *);\n+extern struct target_mem_desc *goacc_map_vars (struct gomp_device_descr *,\n+\t\t\t\t\t       struct goacc_asyncqueue *,\n+\t\t\t\t\t       size_t, void **, void **,\n+\t\t\t\t\t       size_t *, void *, bool,\n+\t\t\t\t\t       enum gomp_map_vars_kind);\n+extern void goacc_unmap_vars (struct target_mem_desc *, bool,\n+\t\t\t      struct goacc_asyncqueue *);\n extern void gomp_init_device (struct gomp_device_descr *);\n extern bool gomp_fini_device (struct gomp_device_descr *);\n extern void gomp_unload_device (struct gomp_device_descr *);"}, {"sha": "c21508f3739986631946c4952502e359ccc51421", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/275c736e732d29934e4d22e8f030d5aae8c12a52/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/275c736e732d29934e4d22e8f030d5aae8c12a52/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=275c736e732d29934e4d22e8f030d5aae8c12a52", "patch": "@@ -402,9 +402,8 @@ acc_map_data (void *h, void *d, size_t s)\n       gomp_mutex_unlock (&acc_dev->lock);\n \n       struct target_mem_desc *tgt\n-\t= gomp_map_vars (acc_dev, mapnum, &hostaddrs, &devaddrs, &sizes,\n-\t\t\t &kinds, true,\n-\t\t\t GOMP_MAP_VARS_OPENACC | GOMP_MAP_VARS_ENTER_DATA);\n+\t= goacc_map_vars (acc_dev, NULL, mapnum, &hostaddrs, &devaddrs, &sizes,\n+\t\t\t  &kinds, true, GOMP_MAP_VARS_ENTER_DATA);\n       assert (tgt);\n       assert (tgt->list_count == 1);\n       splay_tree_key n = tgt->list[0].key;\n@@ -572,9 +571,8 @@ goacc_enter_datum (void **hostaddrs, size_t *sizes, void *kinds, int async)\n       goacc_aq aq = get_goacc_asyncqueue (async);\n \n       struct target_mem_desc *tgt\n-\t= gomp_map_vars_async (acc_dev, aq, mapnum, hostaddrs, NULL, sizes,\n-\t\t\t       kinds, true, (GOMP_MAP_VARS_OPENACC\n-\t\t\t\t\t     | GOMP_MAP_VARS_ENTER_DATA));\n+\t= goacc_map_vars (acc_dev, aq, mapnum, hostaddrs, NULL, sizes,\n+\t\t\t  kinds, true, GOMP_MAP_VARS_ENTER_DATA);\n       assert (tgt);\n       assert (tgt->list_count == 1);\n       n = tgt->list[0].key;\n@@ -1070,7 +1068,7 @@ find_group_last (int pos, size_t mapnum, size_t *sizes, unsigned short *kinds)\n }\n \n /* Map variables for OpenACC \"enter data\".  We can't just call\n-   gomp_map_vars_async once, because individual mapped variables might have\n+   goacc_map_vars once, because individual mapped variables might have\n    \"exit data\" called for them at different times.  */\n \n static void\n@@ -1202,10 +1200,9 @@ goacc_enter_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n \t  gomp_mutex_unlock (&acc_dev->lock);\n \n \t  struct target_mem_desc *tgt\n-\t    = gomp_map_vars_async (acc_dev, aq, groupnum, &hostaddrs[i], NULL,\n-\t\t\t\t   &sizes[i], &kinds[i], true,\n-\t\t\t\t   (GOMP_MAP_VARS_OPENACC\n-\t\t\t\t    | GOMP_MAP_VARS_ENTER_DATA));\n+\t    = goacc_map_vars (acc_dev, aq, groupnum, &hostaddrs[i], NULL,\n+\t\t\t      &sizes[i], &kinds[i], true,\n+\t\t\t      GOMP_MAP_VARS_ENTER_DATA);\n \t  assert (tgt);\n \n \t  gomp_mutex_lock (&acc_dev->lock);"}, {"sha": "83625ba8a8e33c083d41b84687fb37cce3a1190c", "filename": "libgomp/oacc-parallel.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/275c736e732d29934e4d22e8f030d5aae8c12a52/libgomp%2Foacc-parallel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/275c736e732d29934e4d22e8f030d5aae8c12a52/libgomp%2Foacc-parallel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-parallel.c?ref=275c736e732d29934e4d22e8f030d5aae8c12a52", "patch": "@@ -290,8 +290,8 @@ GOACC_parallel_keyed (int flags_m, void (*fn) (void *),\n \n   goacc_aq aq = get_goacc_asyncqueue (async);\n \n-  tgt = gomp_map_vars_async (acc_dev, aq, mapnum, hostaddrs, NULL, sizes, kinds,\n-\t\t\t     true, GOMP_MAP_VARS_OPENACC);\n+  tgt = goacc_map_vars (acc_dev, aq, mapnum, hostaddrs, NULL, sizes, kinds,\n+\t\t\ttrue, 0);\n   if (profiling_p)\n     {\n       prof_info.event_type = acc_ev_enter_data_end;\n@@ -300,7 +300,7 @@ GOACC_parallel_keyed (int flags_m, void (*fn) (void *),\n       goacc_profiling_dispatch (&prof_info, &enter_exit_data_event_info,\n \t\t\t\t&api_info);\n     }\n-  \n+\n   devaddrs = gomp_alloca (sizeof (void *) * mapnum);\n   for (i = 0; i < mapnum; i++)\n     devaddrs[i] = (void *) gomp_map_val (tgt, hostaddrs, i);\n@@ -321,11 +321,8 @@ GOACC_parallel_keyed (int flags_m, void (*fn) (void *),\n \t\t\t\t&api_info);\n     }\n \n-  /* If running synchronously, unmap immediately.  */\n-  if (aq == NULL)\n-    gomp_unmap_vars (tgt, true);\n-  else\n-    gomp_unmap_vars_async (tgt, true, aq);\n+  /* If running synchronously (aq == NULL), this will unmap immediately.  */\n+  goacc_unmap_vars (tgt, true, aq);\n \n   if (profiling_p)\n     {\n@@ -456,17 +453,16 @@ GOACC_data_start (int flags_m, size_t mapnum,\n     {\n       prof_info.device_type = acc_device_host;\n       api_info.device_type = prof_info.device_type;\n-      tgt = gomp_map_vars (NULL, 0, NULL, NULL, NULL, NULL, true,\n-\t\t\t   GOMP_MAP_VARS_OPENACC);\n+      tgt = goacc_map_vars (NULL, NULL, 0, NULL, NULL, NULL, NULL, true, 0);\n       tgt->prev = thr->mapped_data;\n       thr->mapped_data = tgt;\n \n       goto out_prof;\n     }\n \n   gomp_debug (0, \"  %s: prepare mappings\\n\", __FUNCTION__);\n-  tgt = gomp_map_vars (acc_dev, mapnum, hostaddrs, NULL, sizes, kinds, true,\n-\t\t       GOMP_MAP_VARS_OPENACC);\n+  tgt = goacc_map_vars (acc_dev, NULL, mapnum, hostaddrs, NULL, sizes, kinds,\n+\t\t\ttrue, 0);\n   gomp_debug (0, \"  %s: mappings prepared\\n\", __FUNCTION__);\n   tgt->prev = thr->mapped_data;\n   thr->mapped_data = tgt;\n@@ -542,7 +538,7 @@ GOACC_data_end (void)\n \n   gomp_debug (0, \"  %s: restore mappings\\n\", __FUNCTION__);\n   thr->mapped_data = tgt->prev;\n-  gomp_unmap_vars (tgt, true);\n+  goacc_unmap_vars (tgt, true, NULL);\n   gomp_debug (0, \"  %s: mappings restored\\n\", __FUNCTION__);\n \n   if (profiling_p)"}, {"sha": "bb09d501dd69a128ffff97ed636a4f56de194035", "filename": "libgomp/target.c", "status": "modified", "additions": 351, "deletions": 91, "changes": 442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/275c736e732d29934e4d22e8f030d5aae8c12a52/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/275c736e732d29934e4d22e8f030d5aae8c12a52/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=275c736e732d29934e4d22e8f030d5aae8c12a52", "patch": "@@ -44,6 +44,23 @@\n #include \"plugin-suffix.h\"\n #endif\n \n+typedef uintptr_t *hash_entry_type;\n+static inline void * htab_alloc (size_t size) { return gomp_malloc (size); }\n+static inline void htab_free (void *ptr) { free (ptr); }\n+#include \"hashtab.h\"\n+\n+static inline hashval_t\n+htab_hash (hash_entry_type element)\n+{\n+  return hash_pointer ((void *) element);\n+}\n+\n+static inline bool\n+htab_eq (hash_entry_type x, hash_entry_type y)\n+{\n+  return x == y;\n+}\n+\n #define FIELD_TGT_EMPTY (~(size_t) 0)\n \n static void gomp_target_init (void);\n@@ -360,6 +377,113 @@ gomp_free_device_memory (struct gomp_device_descr *devicep, void *devptr)\n     }\n }\n \n+/* Increment reference count of a splay_tree_key region K by 1.\n+   If REFCOUNT_SET != NULL, use it to track already seen refcounts, and only\n+   increment the value if refcount is not yet contained in the set (used for\n+   OpenMP 5.0, which specifies that a region's refcount is adjusted at most\n+   once for each construct).  */\n+\n+static inline void\n+gomp_increment_refcount (splay_tree_key k, htab_t *refcount_set)\n+{\n+  if (k == NULL || k->refcount == REFCOUNT_INFINITY)\n+    return;\n+\n+  uintptr_t *refcount_ptr = &k->refcount;\n+\n+  if (REFCOUNT_STRUCTELEM_FIRST_P (k->refcount))\n+    refcount_ptr = &k->structelem_refcount;\n+  else if (REFCOUNT_STRUCTELEM_P (k->refcount))\n+    refcount_ptr = k->structelem_refcount_ptr;\n+\n+  if (refcount_set)\n+    {\n+      if (htab_find (*refcount_set, refcount_ptr))\n+\treturn;\n+      uintptr_t **slot = htab_find_slot (refcount_set, refcount_ptr, INSERT);\n+      *slot = refcount_ptr;\n+    }\n+\n+  *refcount_ptr += 1;\n+  return;\n+}\n+\n+/* Decrement reference count of a splay_tree_key region K by 1, or if DELETE_P\n+   is true, set reference count to zero. If REFCOUNT_SET != NULL, use it to\n+   track already seen refcounts, and only adjust the value if refcount is not\n+   yet contained in the set (like gomp_increment_refcount).\n+\n+   Return out-values: set *DO_COPY to true if we set the refcount to zero, or\n+   it is already zero and we know we decremented it earlier. This signals that\n+   associated maps should be copied back to host.\n+\n+   *DO_REMOVE is set to true when we this is the first handling of this refcount\n+   and we are setting it to zero. This signals a removal of this key from the\n+   splay-tree map.\n+\n+   Copy and removal are separated due to cases like handling of structure\n+   elements, e.g. each map of a structure element representing a possible copy\n+   out of a structure field has to be handled individually, but we only signal\n+   removal for one (the first encountered) sibing map.  */\n+\n+static inline void\n+gomp_decrement_refcount (splay_tree_key k, htab_t *refcount_set, bool delete_p,\n+\t\t\t bool *do_copy, bool *do_remove)\n+{\n+  if (k == NULL || k->refcount == REFCOUNT_INFINITY)\n+    {\n+      *do_copy = *do_remove = false;\n+      return;\n+    }\n+\n+  uintptr_t *refcount_ptr = &k->refcount;\n+\n+  if (REFCOUNT_STRUCTELEM_FIRST_P (k->refcount))\n+    refcount_ptr = &k->structelem_refcount;\n+  else if (REFCOUNT_STRUCTELEM_P (k->refcount))\n+    refcount_ptr = k->structelem_refcount_ptr;\n+\n+  bool new_encountered_refcount;\n+  bool set_to_zero = false;\n+  bool is_zero = false;\n+\n+  uintptr_t orig_refcount = *refcount_ptr;\n+\n+  if (refcount_set)\n+    {\n+      if (htab_find (*refcount_set, refcount_ptr))\n+\t{\n+\t  new_encountered_refcount = false;\n+\t  goto end;\n+\t}\n+\n+      uintptr_t **slot = htab_find_slot (refcount_set, refcount_ptr, INSERT);\n+      *slot = refcount_ptr;\n+      new_encountered_refcount = true;\n+    }\n+  else\n+    /* If no refcount_set being used, assume all keys are being decremented\n+       for the first time.  */\n+    new_encountered_refcount = true;\n+\n+  if (delete_p)\n+    *refcount_ptr = 0;\n+  else if (*refcount_ptr > 0)\n+    *refcount_ptr -= 1;\n+\n+ end:\n+  if (*refcount_ptr == 0)\n+    {\n+      if (orig_refcount > 0)\n+\tset_to_zero = true;\n+\n+      is_zero = true;\n+    }\n+\n+  *do_copy = (set_to_zero || (!new_encountered_refcount && is_zero));\n+  *do_remove = (new_encountered_refcount && set_to_zero);\n+}\n+\n /* Handle the case where gomp_map_lookup, splay_tree_lookup or\n    gomp_map_0len_lookup found oldn for newn.\n    Helper function of gomp_map_vars.  */\n@@ -369,7 +493,8 @@ gomp_map_vars_existing (struct gomp_device_descr *devicep,\n \t\t\tstruct goacc_asyncqueue *aq, splay_tree_key oldn,\n \t\t\tsplay_tree_key newn, struct target_var_desc *tgt_var,\n \t\t\tunsigned char kind, bool always_to_flag,\n-\t\t\tstruct gomp_coalesce_buf *cbuf)\n+\t\t\tstruct gomp_coalesce_buf *cbuf,\n+\t\t\thtab_t *refcount_set)\n {\n   assert (kind != GOMP_MAP_ATTACH);\n \n@@ -398,8 +523,7 @@ gomp_map_vars_existing (struct gomp_device_descr *devicep,\n \t\t\t(void *) newn->host_start,\n \t\t\tnewn->host_end - newn->host_start, cbuf);\n \n-  if (oldn->refcount != REFCOUNT_INFINITY)\n-    oldn->refcount++;\n+  gomp_increment_refcount (oldn, refcount_set);\n }\n \n static int\n@@ -453,7 +577,7 @@ gomp_map_fields_existing (struct target_mem_desc *tgt,\n \t\t\t  struct goacc_asyncqueue *aq, splay_tree_key n,\n \t\t\t  size_t first, size_t i, void **hostaddrs,\n \t\t\t  size_t *sizes, void *kinds,\n-\t\t\t  struct gomp_coalesce_buf *cbuf)\n+\t\t\t  struct gomp_coalesce_buf *cbuf, htab_t *refcount_set)\n {\n   struct gomp_device_descr *devicep = tgt->device_descr;\n   struct splay_tree_s *mem_map = &devicep->mem_map;\n@@ -471,7 +595,7 @@ gomp_map_fields_existing (struct target_mem_desc *tgt,\n       && n2->host_start - n->host_start == n2->tgt_offset - n->tgt_offset)\n     {\n       gomp_map_vars_existing (devicep, aq, n2, &cur_node, &tgt->list[i],\n-\t\t\t      kind & typemask, false, cbuf);\n+\t\t\t      kind & typemask, false, cbuf, refcount_set);\n       return;\n     }\n   if (sizes[i] == 0)\n@@ -487,7 +611,7 @@ gomp_map_fields_existing (struct target_mem_desc *tgt,\n \t\t == n2->tgt_offset - n->tgt_offset)\n \t    {\n \t      gomp_map_vars_existing (devicep, aq, n2, &cur_node, &tgt->list[i],\n-\t\t\t\t      kind & typemask, false, cbuf);\n+\t\t\t\t      kind & typemask, false, cbuf, refcount_set);\n \t      return;\n \t    }\n \t}\n@@ -499,7 +623,7 @@ gomp_map_fields_existing (struct target_mem_desc *tgt,\n \t  && n2->host_start - n->host_start == n2->tgt_offset - n->tgt_offset)\n \t{\n \t  gomp_map_vars_existing (devicep, aq, n2, &cur_node, &tgt->list[i],\n-\t\t\t\t  kind & typemask, false, cbuf);\n+\t\t\t\t  kind & typemask, false, cbuf, refcount_set);\n \t  return;\n \t}\n     }\n@@ -671,11 +795,13 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t\tstruct goacc_asyncqueue *aq, size_t mapnum,\n \t\t\tvoid **hostaddrs, void **devaddrs, size_t *sizes,\n \t\t\tvoid *kinds, bool short_mapkind,\n+\t\t\thtab_t *refcount_set,\n \t\t\tenum gomp_map_vars_kind pragma_kind)\n {\n   size_t i, tgt_align, tgt_size, not_found_cnt = 0;\n   bool has_firstprivate = false;\n   bool has_always_ptrset = false;\n+  bool openmp_p = (pragma_kind & GOMP_MAP_VARS_OPENACC) == 0;\n   const int rshift = short_mapkind ? 8 : 3;\n   const int typemask = short_mapkind ? 0xff : 0x7;\n   struct splay_tree_s *mem_map = &devicep->mem_map;\n@@ -813,7 +939,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t    }\n \t  for (i = first; i <= last; i++)\n \t    gomp_map_fields_existing (tgt, aq, n, first, i, hostaddrs,\n-\t\t\t\t      sizes, kinds, NULL);\n+\t\t\t\t      sizes, kinds, NULL, refcount_set);\n \t  i--;\n \t  continue;\n \t}\n@@ -909,7 +1035,8 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t}\n \t    }\n \t  gomp_map_vars_existing (devicep, aq, n, &cur_node, &tgt->list[i],\n-\t\t\t\t  kind & typemask, always_to_cnt > 0, NULL);\n+\t\t\t\t  kind & typemask, always_to_cnt > 0, NULL,\n+\t\t\t\t  refcount_set);\n \t  i += always_to_cnt;\n \t}\n       else\n@@ -1022,6 +1149,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n       splay_tree_node array = tgt->array;\n       size_t j, field_tgt_offset = 0, field_tgt_clear = FIELD_TGT_EMPTY;\n       uintptr_t field_tgt_base = 0;\n+      splay_tree_key field_tgt_structelem_first = NULL;\n \n       for (i = 0; i < mapnum; i++)\n \tif (has_always_ptrset\n@@ -1064,8 +1192,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t    tgt->list[j].copy_from = false;\n \t\t    tgt->list[j].always_copy_from = false;\n \t\t    tgt->list[j].is_attach = false;\n-\t\t    if (k->refcount != REFCOUNT_INFINITY)\n-\t\t      k->refcount++;\n+\t\t    gomp_increment_refcount (k, refcount_set);\n \t\t    gomp_map_pointer (k->tgt, aq,\n \t\t\t\t      (uintptr_t) *(void **) hostaddrs[j],\n \t\t\t\t      k->tgt_offset + ((uintptr_t) hostaddrs[j]\n@@ -1153,13 +1280,14 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t    field_tgt_base = (uintptr_t) hostaddrs[first];\n \t\t    field_tgt_offset = tgt_size;\n \t\t    field_tgt_clear = last;\n+\t\t    field_tgt_structelem_first = NULL;\n \t\t    tgt_size += cur_node.host_end\n \t\t\t\t- (uintptr_t) hostaddrs[first];\n \t\t    continue;\n \t\t  }\n \t\tfor (i = first; i <= last; i++)\n \t\t  gomp_map_fields_existing (tgt, aq, n, first, i, hostaddrs,\n-\t\t\t\t\t    sizes, kinds, cbufp);\n+\t\t\t\t\t    sizes, kinds, cbufp, refcount_set);\n \t\ti--;\n \t\tcontinue;\n \t      case GOMP_MAP_ALWAYS_POINTER:\n@@ -1236,7 +1364,8 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t    splay_tree_key n = splay_tree_lookup (mem_map, k);\n \t    if (n && n->refcount != REFCOUNT_LINK)\n \t      gomp_map_vars_existing (devicep, aq, n, k, &tgt->list[i],\n-\t\t\t\t      kind & typemask, false, cbufp);\n+\t\t\t\t      kind & typemask, false, cbufp,\n+\t\t\t\t      refcount_set);\n \t    else\n \t      {\n \t\tk->aux = NULL;\n@@ -1252,10 +1381,33 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\tsize_t align = (size_t) 1 << (kind >> rshift);\n \t\ttgt->list[i].key = k;\n \t\tk->tgt = tgt;\n+\t\tk->refcount = 0;\n+\t\tk->dynamic_refcount = 0;\n \t\tif (field_tgt_clear != FIELD_TGT_EMPTY)\n \t\t  {\n \t\t    k->tgt_offset = k->host_start - field_tgt_base\n \t\t\t\t    + field_tgt_offset;\n+\t\t    if (openmp_p)\n+\t\t      {\n+\t\t\tk->refcount = REFCOUNT_STRUCTELEM;\n+\t\t\tif (field_tgt_structelem_first == NULL)\n+\t\t\t  {\n+\t\t\t    /* Set to first structure element of sequence.  */\n+\t\t\t    k->refcount |= REFCOUNT_STRUCTELEM_FLAG_FIRST;\n+\t\t\t    field_tgt_structelem_first = k;\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  /* Point to refcount of leading element, but do not\n+\t\t\t     increment again.  */\n+\t\t\t  k->structelem_refcount_ptr\n+\t\t\t    = &field_tgt_structelem_first->structelem_refcount;\n+\n+\t\t\tif (i == field_tgt_clear)\n+\t\t\t  {\n+\t\t\t    k->refcount |= REFCOUNT_STRUCTELEM_FLAG_LAST;\n+\t\t\t    field_tgt_structelem_first = NULL;\n+\t\t\t  }\n+\t\t      }\n \t\t    if (i == field_tgt_clear)\n \t\t      field_tgt_clear = FIELD_TGT_EMPTY;\n \t\t  }\n@@ -1265,14 +1417,17 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t    k->tgt_offset = tgt_size;\n \t\t    tgt_size += k->host_end - k->host_start;\n \t\t  }\n+\t\t/* First increment, from 0 to 1. gomp_increment_refcount\n+\t\t   encapsulates the different increment cases, so use this\n+\t\t   instead of directly setting 1 during initialization.  */\n+\t\tgomp_increment_refcount (k, refcount_set);\n+\n \t\ttgt->list[i].copy_from = GOMP_MAP_COPY_FROM_P (kind & typemask);\n \t\ttgt->list[i].always_copy_from\n \t\t  = GOMP_MAP_ALWAYS_FROM_P (kind & typemask);\n \t\ttgt->list[i].is_attach = false;\n \t\ttgt->list[i].offset = 0;\n \t\ttgt->list[i].length = k->host_end - k->host_start;\n-\t\tk->refcount = 1;\n-\t\tk->dynamic_refcount = 0;\n \t\ttgt->refcount++;\n \t\tarray->left = NULL;\n \t\tarray->right = NULL;\n@@ -1328,8 +1483,14 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t\t    tgt->list[j].always_copy_from = false;\n \t\t\t    tgt->list[j].is_attach = false;\n \t\t\t    tgt->list[i].has_null_ptr_assoc |= !(*(void **) hostaddrs[j]);\n-\t\t\t    if (k->refcount != REFCOUNT_INFINITY)\n-\t\t\t      k->refcount++;\n+\t\t\t    /* For OpenMP, the use of refcount_sets causes\n+\t\t\t       errors if we set k->refcount = 1 above but also\n+\t\t\t       increment it again here, for decrementing will\n+\t\t\t       not properly match, since we decrement only once\n+\t\t\t       for each key's refcount. Therefore avoid this\n+\t\t\t       increment for OpenMP constructs.  */\n+\t\t\t    if (!openmp_p)\n+\t\t\t      gomp_increment_refcount (k, refcount_set);\n \t\t\t    gomp_map_pointer (tgt, aq,\n \t\t\t\t\t      (uintptr_t) *(void **) hostaddrs[j],\n \t\t\t\t\t      k->tgt_offset\n@@ -1426,24 +1587,41 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n   return tgt;\n }\n \n-attribute_hidden struct target_mem_desc *\n+static struct target_mem_desc *\n gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t       void **hostaddrs, void **devaddrs, size_t *sizes, void *kinds,\n-\t       bool short_mapkind, enum gomp_map_vars_kind pragma_kind)\n+\t       bool short_mapkind, htab_t *refcount_set,\n+\t       enum gomp_map_vars_kind pragma_kind)\n {\n-  return gomp_map_vars_internal (devicep, NULL, mapnum, hostaddrs, devaddrs,\n-\t\t\t\t sizes, kinds, short_mapkind, pragma_kind);\n+  /* This management of a local refcount_set is for convenience of callers\n+     who do not share a refcount_set over multiple map/unmap uses.  */\n+  htab_t local_refcount_set = NULL;\n+  if (refcount_set == NULL)\n+    {\n+      local_refcount_set = htab_create (mapnum);\n+      refcount_set = &local_refcount_set;\n+    }\n+\n+  struct target_mem_desc *tgt;\n+  tgt = gomp_map_vars_internal (devicep, NULL, mapnum, hostaddrs, devaddrs,\n+\t\t\t\tsizes, kinds, short_mapkind, refcount_set,\n+\t\t\t\tpragma_kind);\n+  if (local_refcount_set)\n+    htab_free (local_refcount_set);\n+\n+  return tgt;\n }\n \n attribute_hidden struct target_mem_desc *\n-gomp_map_vars_async (struct gomp_device_descr *devicep,\n-\t\t     struct goacc_asyncqueue *aq, size_t mapnum,\n-\t\t     void **hostaddrs, void **devaddrs, size_t *sizes,\n-\t\t     void *kinds, bool short_mapkind,\n-\t\t     enum gomp_map_vars_kind pragma_kind)\n+goacc_map_vars (struct gomp_device_descr *devicep,\n+\t\tstruct goacc_asyncqueue *aq, size_t mapnum,\n+\t\tvoid **hostaddrs, void **devaddrs, size_t *sizes,\n+\t\tvoid *kinds, bool short_mapkind,\n+\t\tenum gomp_map_vars_kind pragma_kind)\n {\n   return gomp_map_vars_internal (devicep, aq, mapnum, hostaddrs, devaddrs,\n-\t\t\t\t sizes, kinds, short_mapkind, pragma_kind);\n+\t\t\t\t sizes, kinds, short_mapkind, NULL,\n+\t\t\t\t GOMP_MAP_VARS_OPENACC | pragma_kind);\n }\n \n static void\n@@ -1481,22 +1659,56 @@ gomp_unref_tgt_void (void *ptr)\n   (void) gomp_unref_tgt (ptr);\n }\n \n-static inline __attribute__((always_inline)) bool\n-gomp_remove_var_internal (struct gomp_device_descr *devicep, splay_tree_key k,\n-\t\t\t  struct goacc_asyncqueue *aq)\n+static void\n+gomp_remove_splay_tree_key (splay_tree sp, splay_tree_key k)\n {\n-  bool is_tgt_unmapped = false;\n-  splay_tree_remove (&devicep->mem_map, k);\n+  splay_tree_remove (sp, k);\n   if (k->aux)\n     {\n       if (k->aux->link_key)\n-\tsplay_tree_insert (&devicep->mem_map,\n-\t\t\t   (splay_tree_node) k->aux->link_key);\n+\tsplay_tree_insert (sp, (splay_tree_node) k->aux->link_key);\n       if (k->aux->attach_count)\n \tfree (k->aux->attach_count);\n       free (k->aux);\n       k->aux = NULL;\n     }\n+}\n+\n+static inline __attribute__((always_inline)) bool\n+gomp_remove_var_internal (struct gomp_device_descr *devicep, splay_tree_key k,\n+\t\t\t  struct goacc_asyncqueue *aq)\n+{\n+  bool is_tgt_unmapped = false;\n+\n+  if (REFCOUNT_STRUCTELEM_P (k->refcount))\n+    {\n+      if (REFCOUNT_STRUCTELEM_FIRST_P (k->refcount) == false)\n+\t/* Infer the splay_tree_key of the first structelem key using the\n+\t   pointer to the first structleme_refcount.  */\n+\tk = (splay_tree_key) ((char *) k->structelem_refcount_ptr\n+\t\t\t      - offsetof (struct splay_tree_key_s,\n+\t\t\t\t\t  structelem_refcount));\n+      assert (REFCOUNT_STRUCTELEM_FIRST_P (k->refcount));\n+\n+      /* The array created by gomp_map_vars is an array of splay_tree_nodes,\n+\t with the splay_tree_keys embedded inside.  */\n+      splay_tree_node node =\n+\t(splay_tree_node) ((char *) k\n+\t\t\t   - offsetof (struct splay_tree_node_s, key));\n+      while (true)\n+\t{\n+\t  /* Starting from the _FIRST key, and continue for all following\n+\t     sibling keys.  */\n+\t  gomp_remove_splay_tree_key (&devicep->mem_map, k);\n+\t  if (REFCOUNT_STRUCTELEM_LAST_P (k->refcount))\n+\t    break;\n+\t  else\n+\t    k = &(++node)->key;\n+\t}\n+    }\n+  else\n+    gomp_remove_splay_tree_key (&devicep->mem_map, k);\n+\n   if (aq)\n     devicep->openacc.async.queue_callback_func (aq, gomp_unref_tgt_void,\n \t\t\t\t\t\t(void *) k->tgt);\n@@ -1530,7 +1742,7 @@ gomp_remove_var_async (struct gomp_device_descr *devicep, splay_tree_key k,\n \n static inline __attribute__((always_inline)) void\n gomp_unmap_vars_internal (struct target_mem_desc *tgt, bool do_copyfrom,\n-\t\t\t  struct goacc_asyncqueue *aq)\n+\t\t\t  htab_t *refcount_set, struct goacc_asyncqueue *aq)\n {\n   struct gomp_device_descr *devicep = tgt->device_descr;\n \n@@ -1573,23 +1785,17 @@ gomp_unmap_vars_internal (struct target_mem_desc *tgt, bool do_copyfrom,\n       if (tgt->list[i].is_attach)\n \tcontinue;\n \n-      bool do_unmap = false;\n-      if (k->refcount > 1 && k->refcount != REFCOUNT_INFINITY)\n-\tk->refcount--;\n-      else if (k->refcount == 1)\n-\t{\n-\t  k->refcount--;\n-\t  do_unmap = true;\n-\t}\n+      bool do_copy, do_remove;\n+      gomp_decrement_refcount (k, refcount_set, false, &do_copy, &do_remove);\n \n-      if ((do_unmap && do_copyfrom && tgt->list[i].copy_from)\n+      if ((do_copy && do_copyfrom && tgt->list[i].copy_from)\n \t  || tgt->list[i].always_copy_from)\n \tgomp_copy_dev2host (devicep, aq,\n \t\t\t    (void *) (k->host_start + tgt->list[i].offset),\n \t\t\t    (void *) (k->tgt->tgt_start + k->tgt_offset\n \t\t\t\t      + tgt->list[i].offset),\n \t\t\t    tgt->list[i].length);\n-      if (do_unmap)\n+      if (do_remove)\n \t{\n \t  struct target_mem_desc *k_tgt = k->tgt;\n \t  bool is_tgt_unmapped = gomp_remove_var (devicep, k);\n@@ -1610,17 +1816,30 @@ gomp_unmap_vars_internal (struct target_mem_desc *tgt, bool do_copyfrom,\n   gomp_mutex_unlock (&devicep->lock);\n }\n \n-attribute_hidden void\n-gomp_unmap_vars (struct target_mem_desc *tgt, bool do_copyfrom)\n+static void\n+gomp_unmap_vars (struct target_mem_desc *tgt, bool do_copyfrom,\n+\t\t htab_t *refcount_set)\n {\n-  gomp_unmap_vars_internal (tgt, do_copyfrom, NULL);\n+  /* This management of a local refcount_set is for convenience of callers\n+     who do not share a refcount_set over multiple map/unmap uses.  */\n+  htab_t local_refcount_set = NULL;\n+  if (refcount_set == NULL)\n+    {\n+      local_refcount_set = htab_create (tgt->list_count);\n+      refcount_set = &local_refcount_set;\n+    }\n+\n+  gomp_unmap_vars_internal (tgt, do_copyfrom, refcount_set, NULL);\n+\n+  if (local_refcount_set)\n+    htab_free (local_refcount_set);\n }\n \n attribute_hidden void\n-gomp_unmap_vars_async (struct target_mem_desc *tgt, bool do_copyfrom,\n-\t\t       struct goacc_asyncqueue *aq)\n+goacc_unmap_vars (struct target_mem_desc *tgt, bool do_copyfrom,\n+\t\t  struct goacc_asyncqueue *aq)\n {\n-  gomp_unmap_vars_internal (tgt, do_copyfrom, aq);\n+  gomp_unmap_vars_internal (tgt, do_copyfrom, NULL, aq);\n }\n \n static void\n@@ -2130,12 +2349,15 @@ GOMP_target (int device, void (*fn) (void *), const void *unused,\n       || !(fn_addr = gomp_get_target_fn_addr (devicep, fn)))\n     return gomp_target_fallback (fn, hostaddrs, devicep);\n \n+  htab_t refcount_set = htab_create (mapnum);\n   struct target_mem_desc *tgt_vars\n     = gomp_map_vars (devicep, mapnum, hostaddrs, NULL, sizes, kinds, false,\n-\t\t     GOMP_MAP_VARS_TARGET);\n+\t\t     &refcount_set, GOMP_MAP_VARS_TARGET);\n   devicep->run_func (devicep->target_id, fn_addr, (void *) tgt_vars->tgt_start,\n \t\t     NULL);\n-  gomp_unmap_vars (tgt_vars, true);\n+  htab_clear (refcount_set);\n+  gomp_unmap_vars (tgt_vars, true, &refcount_set);\n+  htab_free (refcount_set);\n }\n \n static inline unsigned int\n@@ -2269,6 +2491,8 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,\n     }\n \n   struct target_mem_desc *tgt_vars;\n+  htab_t refcount_set = NULL;\n+\n   if (devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n     {\n       if (!fpc_done)\n@@ -2285,13 +2509,21 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,\n       tgt_vars = NULL;\n     }\n   else\n-    tgt_vars = gomp_map_vars (devicep, mapnum, hostaddrs, NULL, sizes, kinds,\n-\t\t\t      true, GOMP_MAP_VARS_TARGET);\n+    {\n+      refcount_set = htab_create (mapnum);\n+      tgt_vars = gomp_map_vars (devicep, mapnum, hostaddrs, NULL, sizes, kinds,\n+\t\t\t\ttrue, &refcount_set, GOMP_MAP_VARS_TARGET);\n+    }\n   devicep->run_func (devicep->target_id, fn_addr,\n \t\t     tgt_vars ? (void *) tgt_vars->tgt_start : hostaddrs,\n \t\t     args);\n   if (tgt_vars)\n-    gomp_unmap_vars (tgt_vars, true);\n+    {\n+      htab_clear (refcount_set);\n+      gomp_unmap_vars (tgt_vars, true, &refcount_set);\n+    }\n+  if (refcount_set)\n+    htab_free (refcount_set);\n }\n \n /* Host fallback for GOMP_target_data{,_ext} routines.  */\n@@ -2314,7 +2546,7 @@ gomp_target_data_fallback (struct gomp_device_descr *devicep)\n          would get out of sync.  */\n       struct target_mem_desc *tgt\n \t= gomp_map_vars (NULL, 0, NULL, NULL, NULL, NULL, false,\n-\t\t\t GOMP_MAP_VARS_DATA);\n+\t\t\t NULL, GOMP_MAP_VARS_DATA);\n       tgt->prev = icv->target_data;\n       icv->target_data = tgt;\n     }\n@@ -2333,7 +2565,7 @@ GOMP_target_data (int device, const void *unused, size_t mapnum,\n \n   struct target_mem_desc *tgt\n     = gomp_map_vars (devicep, mapnum, hostaddrs, NULL, sizes, kinds, false,\n-\t\t     GOMP_MAP_VARS_DATA);\n+\t\t     NULL, GOMP_MAP_VARS_DATA);\n   struct gomp_task_icv *icv = gomp_icv (true);\n   tgt->prev = icv->target_data;\n   icv->target_data = tgt;\n@@ -2352,7 +2584,7 @@ GOMP_target_data_ext (int device, size_t mapnum, void **hostaddrs,\n \n   struct target_mem_desc *tgt\n     = gomp_map_vars (devicep, mapnum, hostaddrs, NULL, sizes, kinds, true,\n-\t\t     GOMP_MAP_VARS_DATA);\n+\t\t     NULL, GOMP_MAP_VARS_DATA);\n   struct gomp_task_icv *icv = gomp_icv (true);\n   tgt->prev = icv->target_data;\n   icv->target_data = tgt;\n@@ -2366,7 +2598,7 @@ GOMP_target_end_data (void)\n     {\n       struct target_mem_desc *tgt = icv->target_data;\n       icv->target_data = tgt->prev;\n-      gomp_unmap_vars (tgt, true);\n+      gomp_unmap_vars (tgt, true, NULL);\n     }\n }\n \n@@ -2465,7 +2697,8 @@ GOMP_target_update_ext (int device, size_t mapnum, void **hostaddrs,\n \n static void\n gomp_exit_data (struct gomp_device_descr *devicep, size_t mapnum,\n-\t\tvoid **hostaddrs, size_t *sizes, unsigned short *kinds)\n+\t\tvoid **hostaddrs, size_t *sizes, unsigned short *kinds,\n+\t\thtab_t *refcount_set)\n {\n   const int typemask = 0xff;\n   size_t i;\n@@ -2489,6 +2722,9 @@ gomp_exit_data (struct gomp_device_descr *devicep, size_t mapnum,\n \t\t\t       false, NULL);\n       }\n \n+  int nrmvars = 0;\n+  splay_tree_key remove_vars[mapnum];\n+\n   for (i = 0; i < mapnum; i++)\n     {\n       struct splay_tree_key_s cur_node;\n@@ -2510,22 +2746,32 @@ gomp_exit_data (struct gomp_device_descr *devicep, size_t mapnum,\n \t  if (!k)\n \t    continue;\n \n-\t  if (k->refcount > 0 && k->refcount != REFCOUNT_INFINITY)\n-\t    k->refcount--;\n-\t  if ((kind == GOMP_MAP_DELETE\n-\t       || kind == GOMP_MAP_DELETE_ZERO_LEN_ARRAY_SECTION)\n-\t      && k->refcount != REFCOUNT_INFINITY)\n-\t    k->refcount = 0;\n+\t  bool delete_p = (kind == GOMP_MAP_DELETE\n+\t\t\t   || kind == GOMP_MAP_DELETE_ZERO_LEN_ARRAY_SECTION);\n+\t  bool do_copy, do_remove;\n+\t  gomp_decrement_refcount (k, refcount_set, delete_p, &do_copy,\n+\t\t\t\t   &do_remove);\n \n-\t  if ((kind == GOMP_MAP_FROM && k->refcount == 0)\n+\t  if ((kind == GOMP_MAP_FROM && do_copy)\n \t      || kind == GOMP_MAP_ALWAYS_FROM)\n \t    gomp_copy_dev2host (devicep, NULL, (void *) cur_node.host_start,\n \t\t\t\t(void *) (k->tgt->tgt_start + k->tgt_offset\n \t\t\t\t\t  + cur_node.host_start\n \t\t\t\t\t  - k->host_start),\n \t\t\t\tcur_node.host_end - cur_node.host_start);\n-\t  if (k->refcount == 0)\n-\t    gomp_remove_var (devicep, k);\n+\n+\t  /* Structure elements lists are removed altogether at once, which\n+\t     may cause immediate deallocation of the target_mem_desc, causing\n+\t     errors if we still have following element siblings to copy back.\n+\t     While we're at it, it also seems more disciplined to simply\n+\t     queue all removals together for processing below.\n+\n+\t     Structured block unmapping (i.e. gomp_unmap_vars_internal) should\n+\t     not have this problem, since they maintain an additional\n+\t     tgt->refcount = 1 reference to the target_mem_desc to start with.\n+\t  */\n+\t  if (do_remove)\n+\t    remove_vars[nrmvars++] = k;\n \t  break;\n \n \tcase GOMP_MAP_DETACH:\n@@ -2537,6 +2783,9 @@ gomp_exit_data (struct gomp_device_descr *devicep, size_t mapnum,\n \t}\n     }\n \n+  for (int i = 0; i < nrmvars; i++)\n+    gomp_remove_var (devicep, remove_vars[i]);\n+\n   gomp_mutex_unlock (&devicep->lock);\n }\n \n@@ -2616,6 +2865,8 @@ GOMP_target_enter_exit_data (int device, size_t mapnum, void **hostaddrs,\n \t}\n     }\n \n+  htab_t refcount_set = htab_create (mapnum);\n+\n   /* The variables are mapped separately such that they can be released\n      independently.  */\n   size_t i, j;\n@@ -2624,7 +2875,8 @@ GOMP_target_enter_exit_data (int device, size_t mapnum, void **hostaddrs,\n       if ((kinds[i] & 0xff) == GOMP_MAP_STRUCT)\n \t{\n \t  gomp_map_vars (devicep, sizes[i] + 1, &hostaddrs[i], NULL, &sizes[i],\n-\t\t\t &kinds[i], true, GOMP_MAP_VARS_ENTER_DATA);\n+\t\t\t &kinds[i], true, &refcount_set,\n+\t\t\t GOMP_MAP_VARS_ENTER_DATA);\n \t  i += sizes[i];\n \t}\n       else if ((kinds[i] & 0xff) == GOMP_MAP_TO_PSET)\n@@ -2634,22 +2886,24 @@ GOMP_target_enter_exit_data (int device, size_t mapnum, void **hostaddrs,\n \t\t&& !GOMP_MAP_ALWAYS_POINTER_P (get_kind (true, kinds, j) & 0xff))\n \t      break;\n \t  gomp_map_vars (devicep, j-i, &hostaddrs[i], NULL, &sizes[i],\n-\t\t\t &kinds[i], true, GOMP_MAP_VARS_ENTER_DATA);\n+\t\t\t &kinds[i], true, &refcount_set,\n+\t\t\t GOMP_MAP_VARS_ENTER_DATA);\n \t  i += j - i - 1;\n \t}\n       else if (i + 1 < mapnum && (kinds[i + 1] & 0xff) == GOMP_MAP_ATTACH)\n \t{\n \t  /* An attach operation must be processed together with the mapped\n \t     base-pointer list item.  */\n \t  gomp_map_vars (devicep, 2, &hostaddrs[i], NULL, &sizes[i], &kinds[i],\n-\t\t\t true, GOMP_MAP_VARS_ENTER_DATA);\n+\t\t\t true, &refcount_set, GOMP_MAP_VARS_ENTER_DATA);\n \t  i += 1;\n \t}\n       else\n \tgomp_map_vars (devicep, 1, &hostaddrs[i], NULL, &sizes[i], &kinds[i],\n-\t\t       true, GOMP_MAP_VARS_ENTER_DATA);\n+\t\t       true, &refcount_set, GOMP_MAP_VARS_ENTER_DATA);\n   else\n-    gomp_exit_data (devicep, mapnum, hostaddrs, sizes, kinds);\n+    gomp_exit_data (devicep, mapnum, hostaddrs, sizes, kinds, &refcount_set);\n+  htab_free (refcount_set);\n }\n \n bool\n@@ -2674,7 +2928,7 @@ gomp_target_task_fn (void *data)\n       if (ttask->state == GOMP_TARGET_TASK_FINISHED)\n \t{\n \t  if (ttask->tgt)\n-\t    gomp_unmap_vars (ttask->tgt, true);\n+\t    gomp_unmap_vars (ttask->tgt, true, NULL);\n \t  return false;\n \t}\n \n@@ -2688,7 +2942,7 @@ gomp_target_task_fn (void *data)\n \t{\n \t  ttask->tgt = gomp_map_vars (devicep, ttask->mapnum, ttask->hostaddrs,\n \t\t\t\t      NULL, ttask->sizes, ttask->kinds, true,\n-\t\t\t\t      GOMP_MAP_VARS_TARGET);\n+\t\t\t\t      NULL, GOMP_MAP_VARS_TARGET);\n \t  actual_arguments = (void *) ttask->tgt->tgt_start;\n \t}\n       ttask->state = GOMP_TARGET_TASK_READY_TO_RUN;\n@@ -2707,21 +2961,27 @@ gomp_target_task_fn (void *data)\n   if (ttask->flags & GOMP_TARGET_FLAG_UPDATE)\n     gomp_update (devicep, ttask->mapnum, ttask->hostaddrs, ttask->sizes,\n \t\t ttask->kinds, true);\n-  else if ((ttask->flags & GOMP_TARGET_FLAG_EXIT_DATA) == 0)\n-    for (i = 0; i < ttask->mapnum; i++)\n-      if ((ttask->kinds[i] & 0xff) == GOMP_MAP_STRUCT)\n-\t{\n-\t  gomp_map_vars (devicep, ttask->sizes[i] + 1, &ttask->hostaddrs[i],\n-\t\t\t NULL, &ttask->sizes[i], &ttask->kinds[i], true,\n-\t\t\t GOMP_MAP_VARS_ENTER_DATA);\n-\t  i += ttask->sizes[i];\n-\t}\n-      else\n-\tgomp_map_vars (devicep, 1, &ttask->hostaddrs[i], NULL, &ttask->sizes[i],\n-\t\t       &ttask->kinds[i], true, GOMP_MAP_VARS_ENTER_DATA);\n   else\n-    gomp_exit_data (devicep, ttask->mapnum, ttask->hostaddrs, ttask->sizes,\n-\t\t    ttask->kinds);\n+    {\n+      htab_t refcount_set = htab_create (ttask->mapnum);\n+      if ((ttask->flags & GOMP_TARGET_FLAG_EXIT_DATA) == 0)\n+\tfor (i = 0; i < ttask->mapnum; i++)\n+\t  if ((ttask->kinds[i] & 0xff) == GOMP_MAP_STRUCT)\n+\t    {\n+\t      gomp_map_vars (devicep, ttask->sizes[i] + 1, &ttask->hostaddrs[i],\n+\t\t\t     NULL, &ttask->sizes[i], &ttask->kinds[i], true,\n+\t\t\t     &refcount_set, GOMP_MAP_VARS_ENTER_DATA);\n+\t      i += ttask->sizes[i];\n+\t    }\n+\t  else\n+\t    gomp_map_vars (devicep, 1, &ttask->hostaddrs[i], NULL, &ttask->sizes[i],\n+\t\t\t   &ttask->kinds[i], true, &refcount_set,\n+\t\t\t   GOMP_MAP_VARS_ENTER_DATA);\n+      else\n+\tgomp_exit_data (devicep, ttask->mapnum, ttask->hostaddrs, ttask->sizes,\n+\t\t\tttask->kinds, &refcount_set);\n+      htab_free (refcount_set);\n+    }\n   return false;\n }\n "}, {"sha": "5ccd908aa85e333ebfc0641018ffc0efa4bd1753", "filename": "libgomp/testsuite/libgomp.c-c++-common/refcount-1.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/275c736e732d29934e4d22e8f030d5aae8c12a52/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frefcount-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/275c736e732d29934e4d22e8f030d5aae8c12a52/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frefcount-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frefcount-1.c?ref=275c736e732d29934e4d22e8f030d5aae8c12a52", "patch": "@@ -0,0 +1,61 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int main (void)\n+{\n+  int d = omp_get_default_device ();\n+  int id = omp_get_initial_device ();\n+\n+  if (d < 0 || d >= omp_get_num_devices ())\n+    d = id;\n+\n+  unsigned int a = 0xcdcdcdcd;\n+  #pragma omp target enter data map (to:a)\n+\n+  a = 0xabababab;\n+  unsigned char *p = (unsigned char *) &a;\n+  unsigned char *q = p + 2;\n+\n+  #pragma omp target enter data map (alloc:p[:1], q[:1])\n+\n+  if (d != id)\n+    {\n+      if (!omp_target_is_present (&a, d))\n+\tabort ();\n+      if (!omp_target_is_present (&p[0], d))\n+\tabort ();\n+      if (!omp_target_is_present (&q[0], d))\n+\tabort ();\n+    }\n+\n+  #pragma omp target exit data map (release:a)\n+\n+  if (d != id)\n+    {\n+      if (!omp_target_is_present (&a, d))\n+\tabort ();\n+      if (!omp_target_is_present (&p[0], d))\n+\tabort ();\n+      if (!omp_target_is_present (&q[0], d))\n+\tabort ();\n+    }\n+\n+  #pragma omp target exit data map (from:q[:1])\n+\n+  if (d != id)\n+    {\n+      if (omp_target_is_present (&a, d))\n+\tabort ();\n+      if (omp_target_is_present (&p[0], d))\n+\tabort ();\n+      if (omp_target_is_present (&q[0], d))\n+\tabort ();\n+\n+      if (q[0] != 0xcd)\n+\tabort ();\n+      if (p[0] != 0xab)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}"}, {"sha": "5f40fd7830c59f837e22aa4b9a8772415eba227d", "filename": "libgomp/testsuite/libgomp.c-c++-common/struct-elem-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/275c736e732d29934e4d22e8f030d5aae8c12a52/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fstruct-elem-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/275c736e732d29934e4d22e8f030d5aae8c12a52/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fstruct-elem-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fstruct-elem-1.c?ref=275c736e732d29934e4d22e8f030d5aae8c12a52", "patch": "@@ -0,0 +1,29 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+struct S\n+{\n+  int a, b;\n+};\n+typedef struct S S;\n+\n+int main (void)\n+{\n+  int d = omp_get_default_device ();\n+  int id = omp_get_initial_device ();\n+\n+  if (d < 0 || d >= omp_get_num_devices ())\n+    d = id;\n+\n+  S s;\n+  #pragma omp target enter data map (alloc: s.a, s.b)\n+  #pragma omp target exit data map (release: s.b)\n+\n+  /* OpenMP 5.0 structure element mapping rules describe that elements of same\n+     structure variable should allocate/deallocate in a uniform fashion, so\n+     \"s.a\" should be removed together by above 'exit data'.  */\n+  if (d != id && omp_target_is_present (&s.a, d))\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "c50b299c60748e072b312a6c756306d0fea5ba96", "filename": "libgomp/testsuite/libgomp.c-c++-common/struct-elem-2.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/275c736e732d29934e4d22e8f030d5aae8c12a52/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fstruct-elem-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/275c736e732d29934e4d22e8f030d5aae8c12a52/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fstruct-elem-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fstruct-elem-2.c?ref=275c736e732d29934e4d22e8f030d5aae8c12a52", "patch": "@@ -0,0 +1,47 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+struct S\n+{\n+  int a, b, c, d;\n+};\n+typedef struct S S;\n+\n+int main (void)\n+{\n+  int d = omp_get_default_device ();\n+  int id = omp_get_initial_device ();\n+\n+  if (d < 0 || d >= omp_get_num_devices ())\n+    d = id;\n+\n+  S s;\n+  #pragma omp target enter data map (alloc: s.a, s.b, s.c, s.d)\n+  #pragma omp target enter data map (alloc: s.c)\n+  #pragma omp target enter data map (alloc: s.b, s.d)\n+  #pragma omp target enter data map (alloc: s.a, s.c, s.b)\n+\n+  #pragma omp target exit data map (release: s.a)\n+  #pragma omp target exit data map (release: s.d)\n+  #pragma omp target exit data map (release: s.c)\n+  #pragma omp target exit data map (release: s.b)\n+\n+  /* OpenMP 5.0 structure element mapping rules describe that elements of same\n+     structure variable should allocate/deallocate in a uniform fashion, so\n+     all elements of 's' should be removed together by above 'exit data's.  */\n+  if (d != id)\n+    {\n+      if (omp_target_is_present (&s, d))\n+\tabort ();\n+      if (omp_target_is_present (&s.a, d))\n+\tabort ();\n+      if (omp_target_is_present (&s.b, d))\n+\tabort ();\n+      if (omp_target_is_present (&s.c, d))\n+\tabort ();\n+      if (omp_target_is_present (&s.d, d))\n+\tabort ();\n+    }\n+\n+  return 0;\n+}"}, {"sha": "e2b6a6a2b28473c6a6e436837114b7a02def9baf", "filename": "libgomp/testsuite/libgomp.c-c++-common/struct-elem-3.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/275c736e732d29934e4d22e8f030d5aae8c12a52/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fstruct-elem-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/275c736e732d29934e4d22e8f030d5aae8c12a52/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fstruct-elem-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fstruct-elem-3.c?ref=275c736e732d29934e4d22e8f030d5aae8c12a52", "patch": "@@ -0,0 +1,69 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+struct S\n+{\n+  int a, b, c, d;\n+};\n+typedef struct S S;\n+\n+int main (void)\n+{\n+  int d = omp_get_default_device ();\n+  int id = omp_get_initial_device ();\n+\n+  if (d < 0 || d >= omp_get_num_devices ())\n+    d = id;\n+\n+  S s;\n+\n+  #pragma omp target enter data map (alloc: s)\n+  #pragma omp target enter data map (alloc: s)\n+\n+  #pragma omp target exit data map (release: s.a)\n+  #pragma omp target exit data map (release: s.b)\n+\n+  /* OpenMP 5.0 structure element mapping rules describe that elements of same\n+     structure variable should allocate/deallocate in a uniform fashion, so\n+     all elements of 's' should be removed together by above 'exit data's.  */\n+  if (d != id)\n+    {\n+      if (omp_target_is_present (&s, d))\n+\tabort ();\n+      if (omp_target_is_present (&s.a, d))\n+\tabort ();\n+      if (omp_target_is_present (&s.b, d))\n+\tabort ();\n+      if (omp_target_is_present (&s.c, d))\n+\tabort ();\n+      if (omp_target_is_present (&s.d, d))\n+\tabort ();\n+    }\n+\n+  #pragma omp target enter data map (alloc: s.a, s.b)\n+  #pragma omp target enter data map (alloc: s.a)\n+  #pragma omp target enter data map (alloc: s.b)\n+\n+  #pragma omp target exit data map (release: s)\n+  #pragma omp target exit data map (release: s)\n+  #pragma omp target exit data map (release: s)\n+\n+  /* OpenMP 5.0 structure element mapping rules describe that elements of same\n+     structure variable should allocate/deallocate in a uniform fashion, so\n+     all elements of 's' should be removed together by above 'exit data's.  */\n+  if (d != id)\n+    {\n+      if (omp_target_is_present (&s, d))\n+\tabort ();\n+      if (omp_target_is_present (&s.a, d))\n+\tabort ();\n+      if (omp_target_is_present (&s.b, d))\n+\tabort ();\n+      if (omp_target_is_present (&s.c, d))\n+\tabort ();\n+      if (omp_target_is_present (&s.d, d))\n+\tabort ();\n+    }\n+\n+  return 0;\n+}"}, {"sha": "9a23b4fbb811c986fcab1c7aa401c124110637fc", "filename": "libgomp/testsuite/libgomp.c-c++-common/struct-elem-4.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/275c736e732d29934e4d22e8f030d5aae8c12a52/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fstruct-elem-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/275c736e732d29934e4d22e8f030d5aae8c12a52/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fstruct-elem-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fstruct-elem-4.c?ref=275c736e732d29934e4d22e8f030d5aae8c12a52", "patch": "@@ -0,0 +1,56 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+struct S\n+{\n+  int a, b, c, d, e;\n+};\n+typedef struct S S;\n+\n+int main (void)\n+{\n+  int d = omp_get_default_device ();\n+  int id = omp_get_initial_device ();\n+\n+  if (d < 0 || d >= omp_get_num_devices ())\n+    d = id;\n+\n+  S s = { 1, 2, 3, 4, 5 };\n+  #pragma omp target enter data map (to:s)\n+\n+  int *p = &s.b;\n+  int *q = &s.d;\n+  #pragma omp target enter data map (alloc: p[:1], q[:1])\n+\n+  s.b = 88;\n+  s.d = 99;\n+\n+  #pragma omp target exit data map (release: s)\n+  if (d != id)\n+    {\n+      if (!omp_target_is_present (&s, d))\n+\tabort ();\n+      if (!omp_target_is_present (&p[0], d))\n+\tabort ();\n+      if (!omp_target_is_present (&q[0], d))\n+\tabort ();\n+    }\n+\n+  #pragma omp target exit data map (from: q[:1])\n+  if (d != id)\n+    {\n+      if (omp_target_is_present (&s, d))\n+\tabort ();\n+      if (omp_target_is_present (&p[0], d))\n+\tabort ();\n+      if (omp_target_is_present (&q[0], d))\n+\tabort ();\n+\n+      if (q[0] != 4)\n+\tabort ();\n+      if (p[0] != 88)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}"}, {"sha": "814c30120e5bc60322cb6af5b91dc3115e6b3c99", "filename": "libgomp/testsuite/libgomp.c-c++-common/struct-elem-5.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/275c736e732d29934e4d22e8f030d5aae8c12a52/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fstruct-elem-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/275c736e732d29934e4d22e8f030d5aae8c12a52/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fstruct-elem-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fstruct-elem-5.c?ref=275c736e732d29934e4d22e8f030d5aae8c12a52", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do run } */\n+\n+struct S\n+{\n+  int a, b, c;\n+};\n+typedef struct S S;\n+\n+int main (void)\n+{\n+  S s;\n+  #pragma omp target data map (alloc: s.a, s.c)\n+  {\n+    #pragma omp target enter data map (alloc: s.b)\n+  }\n+\n+  return 0;\n+}\n+/* { dg-output \"Trying to map into device \\\\\\[\\[0-9a-fA-FxX\\]+..\\[0-9a-fA-FxX\\]+\\\\\\) structure element when other mapped elements from the same structure weren't mapped together with it\" } */\n+/* { dg-shouldfail \"\" } */"}]}