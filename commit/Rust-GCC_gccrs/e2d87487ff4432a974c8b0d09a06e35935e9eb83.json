{"sha": "e2d87487ff4432a974c8b0d09a06e35935e9eb83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJkODc0ODdmZjQ0MzJhOTc0YzhiMGQwOWEwNmUzNTkzNWU5ZWI4Mw==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2014-05-07T10:31:26Z"}, "committer": {"name": "Thomas Schwinge", "email": "tschwinge@gcc.gnu.org", "date": "2014-05-07T10:31:26Z"}, "message": "Really delete gcc/loop-unswitch.c.\n\n\tgcc/\n\t* loop-unswitch.c: Delete.\n\nFrom-SVN: r210150", "tree": {"sha": "994ededd7a201b7099768697d98cd6e6f4211afd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/994ededd7a201b7099768697d98cd6e6f4211afd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2d87487ff4432a974c8b0d09a06e35935e9eb83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2d87487ff4432a974c8b0d09a06e35935e9eb83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2d87487ff4432a974c8b0d09a06e35935e9eb83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2d87487ff4432a974c8b0d09a06e35935e9eb83/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f543058db940ba94e86118d5ee395bd870c54ff2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f543058db940ba94e86118d5ee395bd870c54ff2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f543058db940ba94e86118d5ee395bd870c54ff2"}], "stats": {"total": 482, "additions": 4, "deletions": 478}, "files": [{"sha": "e5033a04f268f5867774a4c76c4514f7634b44f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2d87487ff4432a974c8b0d09a06e35935e9eb83/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2d87487ff4432a974c8b0d09a06e35935e9eb83/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e2d87487ff4432a974c8b0d09a06e35935e9eb83", "patch": "@@ -1,3 +1,7 @@\n+2014-05-07  Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\t* loop-unswitch.c: Delete.\n+\n 2014-05-07  Richard Biener  <rguenther@suse.de>\n \n \t* config.gcc: Always set need_64bit_hwint to yes.\n@@ -2294,7 +2298,6 @@\n 2014-04-23  Richard Biener  <rguenther@suse.de>\n \n \t* Makefile.in (OBJS): Remove loop-unswitch.o.\n-\t* loop-unswitch.c: Delete.\n \t* tree-pass.h (make_pass_rtl_unswitch): Remove.\n \t* passes.def (pass_rtl_unswitch): Likewise.\n \t* loop-init.c (gate_rtl_unswitch): Likewise."}, {"sha": "fff0fd16e5272fe5bdd845fee33ef2ecf82c1f08", "filename": "gcc/loop-unswitch.c", "status": "removed", "additions": 0, "deletions": 477, "changes": 477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f543058db940ba94e86118d5ee395bd870c54ff2/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f543058db940ba94e86118d5ee395bd870c54ff2/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=f543058db940ba94e86118d5ee395bd870c54ff2", "patch": "@@ -1,477 +0,0 @@\n-/* Loop unswitching for GNU compiler.\n-   Copyright (C) 2002-2014 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"hard-reg-set.h\"\n-#include \"obstack.h\"\n-#include \"basic-block.h\"\n-#include \"cfgloop.h\"\n-#include \"params.h\"\n-#include \"expr.h\"\n-#include \"dumpfile.h\"\n-\n-/* This pass moves constant conditions out of loops, duplicating the loop\n-   in progress, i.e. this code:\n-\n-   while (loop_cond)\n-     {\n-       A;\n-       if (cond)\n-         branch1;\n-       else\n-\t branch2;\n-       B;\n-       if (cond)\n-         branch3;\n-       C;\n-     }\n-   where nothing inside the loop alters cond is transformed\n-   into\n-\n-   if (cond)\n-     {\n-       while (loop_cond)\n-\t {\n-\t   A;\n-\t   branch1;\n-\t   B;\n-\t   branch3;\n-\t   C;\n-\t }\n-     }\n-   else\n-     {\n-       while (loop_cond)\n-\t {\n-\t   A;\n-\t   branch2;\n-\t   B;\n-\t   C;\n-\t }\n-     }\n-\n-  Duplicating the loop might lead to code growth exponential in number of\n-  branches inside loop, so we limit the number of unswitchings performed\n-  in a single loop to PARAM_MAX_UNSWITCH_LEVEL.  We only perform the\n-  transformation on innermost loops, as the benefit of doing it on loops\n-  containing subloops would not be very large compared to complications\n-  with handling this case.  */\n-\n-static struct loop *unswitch_loop (struct loop *, basic_block, rtx, rtx);\n-static bool unswitch_single_loop (struct loop *, rtx, int);\n-static rtx may_unswitch_on (basic_block, struct loop *, rtx *);\n-\n-/* Prepare a sequence comparing OP0 with OP1 using COMP and jumping to LABEL if\n-   true, with probability PROB.  If CINSN is not NULL, it is the insn to copy\n-   in order to create a jump.  */\n-\n-rtx\n-compare_and_jump_seq (rtx op0, rtx op1, enum rtx_code comp, rtx label, int prob,\n-\t\t      rtx cinsn)\n-{\n-  rtx seq, jump, cond;\n-  enum machine_mode mode;\n-\n-  mode = GET_MODE (op0);\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (op1);\n-\n-  start_sequence ();\n-  if (GET_MODE_CLASS (mode) == MODE_CC)\n-    {\n-      /* A hack -- there seems to be no easy generic way how to make a\n-\t conditional jump from a ccmode comparison.  */\n-      gcc_assert (cinsn);\n-      cond = XEXP (SET_SRC (pc_set (cinsn)), 0);\n-      gcc_assert (GET_CODE (cond) == comp);\n-      gcc_assert (rtx_equal_p (op0, XEXP (cond, 0)));\n-      gcc_assert (rtx_equal_p (op1, XEXP (cond, 1)));\n-      emit_jump_insn (copy_insn (PATTERN (cinsn)));\n-      jump = get_last_insn ();\n-      gcc_assert (JUMP_P (jump));\n-      JUMP_LABEL (jump) = JUMP_LABEL (cinsn);\n-      LABEL_NUSES (JUMP_LABEL (jump))++;\n-      redirect_jump (jump, label, 0);\n-    }\n-  else\n-    {\n-      gcc_assert (!cinsn);\n-\n-      op0 = force_operand (op0, NULL_RTX);\n-      op1 = force_operand (op1, NULL_RTX);\n-      do_compare_rtx_and_jump (op0, op1, comp, 0,\n-\t\t\t       mode, NULL_RTX, NULL_RTX, label, -1);\n-      jump = get_last_insn ();\n-      gcc_assert (JUMP_P (jump));\n-      JUMP_LABEL (jump) = label;\n-      LABEL_NUSES (label)++;\n-    }\n-  add_int_reg_note (jump, REG_BR_PROB, prob);\n-\n-  seq = get_insns ();\n-  end_sequence ();\n-\n-  return seq;\n-}\n-\n-/* Main entry point.  Perform loop unswitching on all suitable loops.  */\n-void\n-unswitch_loops (void)\n-{\n-  struct loop *loop;\n-  bool changed = false;\n-\n-  /* Go through inner loops (only original ones).  */\n-\n-  FOR_EACH_LOOP (loop, LI_ONLY_INNERMOST)\n-    changed |= unswitch_single_loop (loop, NULL_RTX, 0);\n-\n-  iv_analysis_done ();\n-\n-  /* If we unswitched any loop discover new loops that are eventually\n-     exposed by making irreducible regions reducible.  */\n-  if (changed)\n-    {\n-      calculate_dominance_info (CDI_DOMINATORS);\n-      fix_loop_structure (NULL);\n-    }\n-}\n-\n-/* Checks whether we can unswitch LOOP on condition at end of BB -- one of its\n-   basic blocks (for what it means see comments below).  In case condition\n-   compares loop invariant cc mode register, return the jump in CINSN.  */\n-\n-static rtx\n-may_unswitch_on (basic_block bb, struct loop *loop, rtx *cinsn)\n-{\n-  rtx test, at, op[2], stest;\n-  struct rtx_iv iv;\n-  unsigned i;\n-  enum machine_mode mode;\n-\n-  /* BB must end in a simple conditional jump.  */\n-  if (EDGE_COUNT (bb->succs) != 2)\n-    return NULL_RTX;\n-  if (!any_condjump_p (BB_END (bb)))\n-    return NULL_RTX;\n-\n-  /* With branches inside loop.  */\n-  if (!flow_bb_inside_loop_p (loop, EDGE_SUCC (bb, 0)->dest)\n-      || !flow_bb_inside_loop_p (loop, EDGE_SUCC (bb, 1)->dest))\n-    return NULL_RTX;\n-\n-  /* It must be executed just once each iteration (because otherwise we\n-     are unable to update dominator/irreducible loop information correctly).  */\n-  if (!just_once_each_iteration_p (loop, bb))\n-    return NULL_RTX;\n-\n-  /* Condition must be invariant.  */\n-  test = get_condition (BB_END (bb), &at, true, false);\n-  if (!test)\n-    return NULL_RTX;\n-\n-  mode = VOIDmode;\n-  for (i = 0; i < 2; i++)\n-    {\n-      op[i] = XEXP (test, i);\n-\n-      if (CONSTANT_P (op[i]))\n-\tcontinue;\n-\n-      if (!iv_analyze (at, op[i], &iv))\n-\treturn NULL_RTX;\n-      if (iv.step != const0_rtx\n-\t  || iv.first_special)\n-\treturn NULL_RTX;\n-\n-      op[i] = get_iv_value (&iv, const0_rtx);\n-      if (iv.extend != IV_UNKNOWN_EXTEND\n-\t  && iv.mode != iv.extend_mode)\n-\top[i] = lowpart_subreg (iv.mode, op[i], iv.extend_mode);\n-      if (mode == VOIDmode)\n-\tmode = iv.mode;\n-      else\n-\tgcc_assert (mode == iv.mode);\n-    }\n-\n-  if (GET_MODE_CLASS (mode) == MODE_CC)\n-    {\n-      if (at != BB_END (bb))\n-\treturn NULL_RTX;\n-\n-      if (!rtx_equal_p (op[0], XEXP (test, 0))\n-\t  || !rtx_equal_p (op[1], XEXP (test, 1)))\n-\treturn NULL_RTX;\n-\n-      *cinsn = BB_END (bb);\n-      return test;\n-    }\n-\n-  stest = simplify_gen_relational (GET_CODE (test), SImode,\n-\t\t\t\t   mode, op[0], op[1]);\n-  if (stest == const0_rtx\n-      || stest == const_true_rtx)\n-    return stest;\n-\n-  return canon_condition (gen_rtx_fmt_ee (GET_CODE (test), SImode,\n-\t\t\t\t\t  op[0], op[1]));\n-}\n-\n-/* Reverses CONDition; returns NULL if we cannot.  */\n-rtx\n-reversed_condition (rtx cond)\n-{\n-  enum rtx_code reversed;\n-  reversed = reversed_comparison_code (cond, NULL);\n-  if (reversed == UNKNOWN)\n-    return NULL_RTX;\n-  else\n-    return gen_rtx_fmt_ee (reversed,\n-\t\t\t   GET_MODE (cond), XEXP (cond, 0),\n-\t\t\t   XEXP (cond, 1));\n-}\n-\n-/* Unswitch single LOOP.  COND_CHECKED holds list of conditions we already\n-   unswitched on and are therefore known to be true in this LOOP.  NUM is\n-   number of unswitchings done; do not allow it to grow too much, it is too\n-   easy to create example on that the code would grow exponentially.\n-   Returns true LOOP was unswitched.  */\n-static bool \n-unswitch_single_loop (struct loop *loop, rtx cond_checked, int num)\n-{\n-  basic_block *bbs;\n-  struct loop *nloop;\n-  unsigned i;\n-  rtx cond, rcond = NULL_RTX, conds, rconds, acond, cinsn;\n-  int repeat;\n-  edge e;\n-  HOST_WIDE_INT iterations;\n-\n-  /* Do not unswitch too much.  */\n-  if (num > PARAM_VALUE (PARAM_MAX_UNSWITCH_LEVEL))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \";; Not unswitching anymore, hit max level\\n\");\n-      return false;\n-    }\n-\n-  /* Only unswitch innermost loops.  */\n-  if (loop->inner)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \";; Not unswitching, not innermost loop\\n\");\n-      return false;\n-    }\n-\n-  /* We must be able to duplicate loop body.  */\n-  if (!can_duplicate_loop_p (loop))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \";; Not unswitching, can't duplicate loop\\n\");\n-      return false;\n-    }\n-\n-  /* The loop should not be too large, to limit code growth.  */\n-  if (num_loop_insns (loop) > PARAM_VALUE (PARAM_MAX_UNSWITCH_INSNS))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \";; Not unswitching, loop too big\\n\");\n-      return false;\n-    }\n-\n-  /* Do not unswitch in cold areas.  */\n-  if (optimize_loop_for_size_p (loop))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \";; Not unswitching, not hot area\\n\");\n-      return false;\n-    }\n-\n-  /* Nor if the loop usually does not roll.  */\n-  iterations = get_estimated_loop_iterations_int (loop);\n-  if (iterations >= 0 && iterations <= 1)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \";; Not unswitching, loop iterations < 1\\n\");\n-      return false;\n-    }\n-\n-  do\n-    {\n-      repeat = 0;\n-      cinsn = NULL_RTX;\n-\n-      /* Find a bb to unswitch on.  */\n-      bbs = get_loop_body (loop);\n-      iv_analysis_loop_init (loop);\n-      for (i = 0; i < loop->num_nodes; i++)\n-\tif ((cond = may_unswitch_on (bbs[i], loop, &cinsn)))\n-\t  break;\n-\n-      if (i == loop->num_nodes)\n-\t{\n-\t  free (bbs);\n-\t  return false;\n-\t}\n-\n-      if (cond != const0_rtx\n-\t  && cond != const_true_rtx)\n-\t{\n-\t  rcond = reversed_condition (cond);\n-\t  if (rcond)\n-\t    rcond = canon_condition (rcond);\n-\n-\t  /* Check whether the result can be predicted.  */\n-\t  for (acond = cond_checked; acond; acond = XEXP (acond, 1))\n-\t    simplify_using_condition (XEXP (acond, 0), &cond, NULL);\n-\t}\n-\n-      if (cond == const_true_rtx)\n-\t{\n-\t  /* Remove false path.  */\n-\t  e = FALLTHRU_EDGE (bbs[i]);\n-\t  remove_path (e);\n-\t  free (bbs);\n-\t  repeat = 1;\n-\t}\n-      else if (cond == const0_rtx)\n-\t{\n-\t  /* Remove true path.  */\n-\t  e = BRANCH_EDGE (bbs[i]);\n-\t  remove_path (e);\n-\t  free (bbs);\n-\t  repeat = 1;\n-\t}\n-    } while (repeat);\n-\n-  /* We found the condition we can unswitch on.  */\n-  conds = alloc_EXPR_LIST (0, cond, cond_checked);\n-  if (rcond)\n-    rconds = alloc_EXPR_LIST (0, rcond, cond_checked);\n-  else\n-    rconds = cond_checked;\n-\n-  if (dump_file)\n-    fprintf (dump_file, \";; Unswitching loop\\n\");\n-\n-  /* Unswitch the loop on this condition.  */\n-  nloop = unswitch_loop (loop, bbs[i], copy_rtx_if_shared (cond), cinsn);\n-  gcc_assert (nloop);\n-\n-  /* Invoke itself on modified loops.  */\n-  unswitch_single_loop (nloop, rconds, num + 1);\n-  unswitch_single_loop (loop, conds, num + 1);\n-\n-  free_EXPR_LIST_node (conds);\n-  if (rcond)\n-    free_EXPR_LIST_node (rconds);\n-\n-  free (bbs);\n-\n-  return true;\n-}\n-\n-/* Unswitch a LOOP w.r. to given basic block UNSWITCH_ON.  We only support\n-   unswitching of innermost loops.  UNSWITCH_ON must be executed in every\n-   iteration, i.e. it must dominate LOOP latch.  COND is the condition\n-   determining which loop is entered.  Returns NULL if impossible, new loop\n-   otherwise.  The new loop is entered if COND is true.  If CINSN is not\n-   NULL, it is the insn in that COND is compared.  */\n-\n-static struct loop *\n-unswitch_loop (struct loop *loop, basic_block unswitch_on, rtx cond, rtx cinsn)\n-{\n-  edge entry, latch_edge, true_edge, false_edge, e;\n-  basic_block switch_bb, unswitch_on_alt;\n-  struct loop *nloop;\n-  int irred_flag, prob;\n-  rtx seq;\n-\n-  /* Some sanity checking.  */\n-  gcc_assert (flow_bb_inside_loop_p (loop, unswitch_on));\n-  gcc_assert (EDGE_COUNT (unswitch_on->succs) == 2);\n-  gcc_assert (just_once_each_iteration_p (loop, unswitch_on));\n-  gcc_assert (!loop->inner);\n-  gcc_assert (flow_bb_inside_loop_p (loop, EDGE_SUCC (unswitch_on, 0)->dest));\n-  gcc_assert (flow_bb_inside_loop_p (loop, EDGE_SUCC (unswitch_on, 1)->dest));\n-\n-  entry = loop_preheader_edge (loop);\n-\n-  /* Make a copy.  */\n-  irred_flag = entry->flags & EDGE_IRREDUCIBLE_LOOP;\n-  entry->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n-  if (!duplicate_loop_to_header_edge (loop, entry, 1,\n-\t\t\t      \t      NULL, NULL, NULL, 0))\n-    return NULL;\n-  entry->flags |= irred_flag;\n-\n-  /* Record the block with condition we unswitch on.  */\n-  unswitch_on_alt = get_bb_copy (unswitch_on);\n-  true_edge = BRANCH_EDGE (unswitch_on_alt);\n-  false_edge = FALLTHRU_EDGE (unswitch_on);\n-  latch_edge = single_succ_edge (get_bb_copy (loop->latch));\n-\n-  /* Create a block with the condition.  */\n-  prob = true_edge->probability;\n-  switch_bb = create_empty_bb (EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb);\n-  seq = compare_and_jump_seq (XEXP (cond, 0), XEXP (cond, 1), GET_CODE (cond),\n-\t\t\t      block_label (true_edge->dest),\n-\t\t\t      prob, cinsn);\n-  emit_insn_after (seq, BB_END (switch_bb));\n-  e = make_edge (switch_bb, true_edge->dest, 0);\n-  e->probability = prob;\n-  e->count = apply_probability (latch_edge->count, prob);\n-  e = make_edge (switch_bb, FALLTHRU_EDGE (unswitch_on)->dest, EDGE_FALLTHRU);\n-  e->probability = false_edge->probability;\n-  e->count = apply_probability (latch_edge->count, false_edge->probability);\n-\n-  if (irred_flag)\n-    {\n-      switch_bb->flags |= BB_IRREDUCIBLE_LOOP;\n-      EDGE_SUCC (switch_bb, 0)->flags |= EDGE_IRREDUCIBLE_LOOP;\n-      EDGE_SUCC (switch_bb, 1)->flags |= EDGE_IRREDUCIBLE_LOOP;\n-    }\n-  else\n-    {\n-      switch_bb->flags &= ~BB_IRREDUCIBLE_LOOP;\n-      EDGE_SUCC (switch_bb, 0)->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n-      EDGE_SUCC (switch_bb, 1)->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n-    }\n-\n-  /* Loopify from the copy of LOOP body, constructing the new loop.  */\n-  nloop = loopify (latch_edge,\n-\t\t   single_pred_edge (get_bb_copy (loop->header)), switch_bb,\n-\t\t   BRANCH_EDGE (switch_bb), FALLTHRU_EDGE (switch_bb), true,\n-\t\t   prob, REG_BR_PROB_BASE - prob);\n-\n-  copy_loop_info (loop, nloop);\n-  /* Remove branches that are now unreachable in new loops.  */\n-  remove_path (true_edge);\n-  remove_path (false_edge);\n-\n-  /* Preserve the simple loop preheaders.  */\n-  split_edge (loop_preheader_edge (loop));\n-  split_edge (loop_preheader_edge (nloop));\n-\n-  return nloop;\n-}"}]}