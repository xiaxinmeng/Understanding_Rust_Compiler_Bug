{"sha": "956d93056d6c4a121da5e5caf5e15e8f619845f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU2ZDkzMDU2ZDZjNGExMjFkYTVlNWNhZjVlMTVlOGY2MTk4NDVmMQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-09-25T19:07:35Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-09-25T19:07:35Z"}, "message": "class.c (contains_empty_class_p): New method.\n\n\t* cp/class.c (contains_empty_class_p): New method.\n\t(walk_subobject_offsets): Correct computation of field offset.\n\t(layout_empty_base): Correct placement of emtpy base classes.\n\t(layout_class_type): Warn about ABI changes.\n\n\t* doc/invoke.texi: Add more -Wabi examples.\n\n\t* gcc/testsuite/g++.dg/abi/empty5.C: New test.\n\t* gcc/testsuite/g++.dg/abi/empty6.C: New test.\n\t* gcc/testsuite/g++.dg/abi/vbase12.C: New test.\n\nFrom-SVN: r57508", "tree": {"sha": "b79b951416ea5c7c8a8f8c353bf2390e1d2645da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b79b951416ea5c7c8a8f8c353bf2390e1d2645da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/956d93056d6c4a121da5e5caf5e15e8f619845f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/956d93056d6c4a121da5e5caf5e15e8f619845f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/956d93056d6c4a121da5e5caf5e15e8f619845f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/956d93056d6c4a121da5e5caf5e15e8f619845f1/comments", "author": null, "committer": null, "parents": [{"sha": "0b4c7d8042c4045b76681b4993752f79d11a31fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b4c7d8042c4045b76681b4993752f79d11a31fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b4c7d8042c4045b76681b4993752f79d11a31fd"}], "stats": {"total": 130, "additions": 128, "deletions": 2}, "files": [{"sha": "4d85a2f9c50cb6e5dce6405ab7a208b6fdd11665", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d93056d6c4a121da5e5caf5e15e8f619845f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d93056d6c4a121da5e5caf5e15e8f619845f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=956d93056d6c4a121da5e5caf5e15e8f619845f1", "patch": "@@ -1,3 +1,7 @@\n+2002-09-25  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* doc/invoke.texi: Add more -Wabi examples.\n+\n 2002-09-25  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.h (TARGET_MIPS4100): Add missing bracket."}, {"sha": "c9f7523d1c799e225f4a08f752baa09d9687d1d1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d93056d6c4a121da5e5caf5e15e8f619845f1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d93056d6c4a121da5e5caf5e15e8f619845f1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=956d93056d6c4a121da5e5caf5e15e8f619845f1", "patch": "@@ -1,3 +1,10 @@\n+2002-09-25  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp/class.c (contains_empty_class_p): New method.\n+\t(walk_subobject_offsets): Correct computation of field offset.\n+\t(layout_empty_base): Correct placement of emtpy base classes.\n+\t(layout_class_type): Warn about ABI changes.\n+\n 2002-09-23  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp/class.c (layout_virtual_bases): Do not round the size of the"}, {"sha": "7532c5d8e21df5617f2ff4a6b1021573c3003de9", "filename": "gcc/cp/class.c", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d93056d6c4a121da5e5caf5e15e8f619845f1/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d93056d6c4a121da5e5caf5e15e8f619845f1/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=956d93056d6c4a121da5e5caf5e15e8f619845f1", "patch": "@@ -210,6 +210,7 @@ static int splay_tree_compare_integer_csts PARAMS ((splay_tree_key k1,\n \t\t\t\t\t\t    splay_tree_key k2));\n static void warn_about_ambiguous_direct_bases PARAMS ((tree));\n static bool type_requires_array_cookie PARAMS ((tree));\n+static bool contains_empty_class_p (tree);\n \n /* Macros for dfs walking during vtt construction. See\n    dfs_ctor_vtable_bases_queue_p, dfs_build_secondary_vptr_vtt_inits\n@@ -3544,11 +3545,19 @@ walk_subobject_offsets (type, f, offset, offsets, max_offset, vbases_p)\n       for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n \tif (TREE_CODE (field) == FIELD_DECL)\n \t  {\n+\t    tree field_offset;\n+\n+\t    if (abi_version_at_least (2))\n+\t      field_offset = byte_position (field);\n+\t    else\n+\t      /* In G++ 3.2, DECL_FIELD_OFFSET was used.  */\n+\t      field_offset = DECL_FIELD_OFFSET (field);\n+\n \t    r = walk_subobject_offsets (TREE_TYPE (field),\n \t\t\t\t\tf,\n \t\t\t\t\tsize_binop (PLUS_EXPR,\n \t\t\t\t\t\t    offset,\n-\t\t\t\t\t\t    DECL_FIELD_OFFSET (field)),\n+\t\t\t\t\t\t    field_offset),\n \t\t\t\t\toffsets,\n \t\t\t\t\tmax_offset,\n \t\t\t\t\t/*vbases_p=*/1);\n@@ -3720,10 +3729,17 @@ layout_empty_base (binfo, eoc, offsets, t)\n   tree alignment;\n   tree basetype = BINFO_TYPE (binfo);\n   bool atend = false;\n-  \n+\n   /* This routine should only be used for empty classes.  */\n   my_friendly_assert (is_empty_class (basetype), 20000321);\n   alignment = ssize_int (CLASSTYPE_ALIGN_UNIT (basetype));\n+  \n+  if (abi_version_at_least (2))\n+    BINFO_OFFSET (binfo) = size_zero_node;\n+  if (warn_abi && !integer_zerop (BINFO_OFFSET (binfo)))\n+    warning (\"offset of empty base `%T' may not be ABI-compliant and may\"\n+\t     \"change in a future version of GCC\",\n+\t     BINFO_TYPE (binfo));\n \n   /* This is an empty base class.  We first try to put it at offset\n      zero.  */\n@@ -4915,6 +4931,17 @@ layout_class_type (t, empty_p, vfuns_p, virtuals_p)\n \tcp_warning_at (\"offset of `%D' is not ABI-compliant and may change in a future version of GCC\", \n \t\t       field);\n \n+      /* G++ used to use DECL_FIELD_OFFSET as if it were the byte\n+\t offset of the field.  */\n+      if (warn_abi \n+\t  && !tree_int_cst_equal (DECL_FIELD_OFFSET (field),\n+\t\t\t\t  byte_position (field))\n+\t  && contains_empty_class_p (TREE_TYPE (field)))\n+\tcp_warning_at (\"`%D' contains empty classes which may cause base \"\n+\t\t       \"classes to be placed at different locations in a \"\n+\t\t       \"future version of GCC\",\n+\t\t       field);\n+\n       /* If we needed additional padding after this field, add it\n \t now.  */\n       if (padding)\n@@ -6371,6 +6398,30 @@ is_empty_class (type)\n   return integer_zerop (CLASSTYPE_SIZE (type));\n }\n \n+/* Returns true if TYPE contains an empty class.  */\n+\n+static bool\n+contains_empty_class_p (tree type)\n+{\n+  if (is_empty_class (type))\n+    return true;\n+  if (CLASS_TYPE_P (type))\n+    {\n+      tree field;\n+      int i;\n+\n+      for (i = 0; i < CLASSTYPE_N_BASECLASSES (type); ++i)\n+\tif (contains_empty_class_p (TYPE_BINFO_BASETYPE (type, i)))\n+\t  return true;\n+      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\tif (contains_empty_class_p (TREE_TYPE (field)))\n+\t  return true;\n+    }\n+  else if (TREE_CODE (type) == ARRAY_TYPE)\n+    return contains_empty_class_p (TREE_TYPE (type));\n+  return false;\n+}\n+\n /* Find the enclosing class of the given NODE.  NODE can be a *_DECL or\n    a *_TYPE node.  NODE can also be a local class.  */\n "}, {"sha": "9a8fa2afa5129cd4edca293c55f1a194751c7f80", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d93056d6c4a121da5e5caf5e15e8f619845f1/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d93056d6c4a121da5e5caf5e15e8f619845f1/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=956d93056d6c4a121da5e5caf5e15e8f619845f1", "patch": "@@ -1546,6 +1546,25 @@ union U @{ int i : 4096; @};\n Assuming that an @code{int} does not have 4096 bits, G++ will make the\n union too small by the number of bits in an @code{int}.\n \n+@item\n+Empty classes can be placed at incorrect offsets.  For example:\n+ \n+@smallexample\n+struct A @{@};\n+\n+struct B @{\n+  A a;\n+  virtual void f ();\n+@};\n+\n+struct C : public B, public A @{@};\n+@end smallexample\n+\n+@noindent\n+G++ will place the @code{A} base class of @code{C} at a non-zero offset;\n+it should be placed at offset zero.  G++ mistakenly believes that the\n+@code{A} data member of @code{B} is already at offset zero.\n+\n @end itemize\n \n @item -Wctor-dtor-privacy @r{(C++ only)}"}, {"sha": "c7b67c682e3504c965d110475eacd8d64377b420", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d93056d6c4a121da5e5caf5e15e8f619845f1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d93056d6c4a121da5e5caf5e15e8f619845f1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=956d93056d6c4a121da5e5caf5e15e8f619845f1", "patch": "@@ -1,3 +1,9 @@\n+2002-09-25  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* gcc/testsuite/g++.dg/abi/empty5.C: New test.\n+\t* gcc/testsuite/g++.dg/abi/empty6.C: New test.\n+\t* gcc/testsuite/g++.dg/abi/vbase12.C: New test.\n+\n 2002-09-25  Richard Henderson  <rth@redhat.com>\n \n \t* gcc.c-torture/execute/ieee/20010226-1.c: Early exit for"}, {"sha": "c3717727e21469e72f51025c007b81cc94f1cb2a", "filename": "gcc/testsuite/g++.dg/abi/empty5.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d93056d6c4a121da5e5caf5e15e8f619845f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d93056d6c4a121da5e5caf5e15e8f619845f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty5.C?ref=956d93056d6c4a121da5e5caf5e15e8f619845f1", "patch": "@@ -0,0 +1,17 @@\n+// { dg-options \"-fabi-version=0\" }\n+\n+struct A {};\n+\n+struct B {\n+  A a;\n+  virtual void f () {}\n+};\n+\n+struct C : public B, public A {};\n+\n+C c;\n+\n+int main () {\n+  if ((void*) (A*) &c != &c)\n+    return 1;\n+}"}, {"sha": "aa272733987c8eba7c97a674cdeba52301fb5b43", "filename": "gcc/testsuite/g++.dg/abi/empty6.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d93056d6c4a121da5e5caf5e15e8f619845f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d93056d6c4a121da5e5caf5e15e8f619845f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty6.C?ref=956d93056d6c4a121da5e5caf5e15e8f619845f1", "patch": "@@ -0,0 +1,8 @@\n+// { dg-options \"-Wabi\" }\n+\n+struct A {};\n+\n+struct B {\n+  A a; // { dg-warning \"empty\" }\n+  virtual void f () {}\n+};"}, {"sha": "98b9054f05e00ad77e407097d8d2a774661219e6", "filename": "gcc/testsuite/g++.dg/abi/vbase12.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d93056d6c4a121da5e5caf5e15e8f619845f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvbase12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d93056d6c4a121da5e5caf5e15e8f619845f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvbase12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvbase12.C?ref=956d93056d6c4a121da5e5caf5e15e8f619845f1", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do run }\n+// { dg-options \"-fabi-version=0\" }\n+\n+struct A {};\n+struct B { A a; virtual void f () {} };\n+struct C : public B, virtual public A {};\n+struct D : public C, virtual public A {};\n+\n+D d;\n+\n+int main () {\n+  if (((char*)(A*)&d - (char*)&d) != 0)\n+    return 1;\n+}"}]}