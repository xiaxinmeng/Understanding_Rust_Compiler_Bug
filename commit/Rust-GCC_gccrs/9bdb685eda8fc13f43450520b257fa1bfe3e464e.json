{"sha": "9bdb685eda8fc13f43450520b257fa1bfe3e464e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJkYjY4NWVkYThmYzEzZjQzNDUwNTIwYjI1N2ZhMWJmZTNlNDY0ZQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-03-16T00:25:30Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-03-16T00:25:30Z"}, "message": "tree-ssa-loop-niter.c (record_estimate): Add \"upper\" argument.\n\n\t* tree-ssa-loop-niter.c (record_estimate): Add \"upper\" argument.\n\tUpdate constant estimates of number of iterations.\n\t(record_nonwrapping_iv): Add \"upper\" argument.  \"data_size_bounds_p\"\n\targument renamed to \"realistic\".\n\t(compute_estimated_nb_iterations): Removed.\n\t(record_niter_bound): New function.\n\t(idx_infer_loop_bounds): For possible but unlikely tail arrays,\n\tcall record_nonwrapping_iv with upper = false.\n\t(infer_loop_bounds_from_signedness): Pass upper argument to\n\trecord_nonwrapping_iv.\n\t(estimate_numbers_of_iterations_loop): Do not call\n\tcompute_estimated_nb_iterations.  Record estimate based on profile\n\tinformation.  Initialize the constant estimates of number of\n\titerations.\n\t* tree-data-ref.c (estimated_loop_iterations): Return the recorded\n\testimates.\n\t* tree-ssa-loop-prefetch.c (loop_prefetch_arrays): Add dump when\n\tnumber of iterations is too small.\n\t* cfgloop.h (struct nb_iter_bound): Remove \"realistic\" field.\n\t(EST_NOT_AVAILABLE): Removed.\n\t(struct loop): Replace estimated_nb_iterations by any_upper_bound,\n\tnb_iterations_upper_bound, any_estimate and nb_iterations_estimate\n\tfields.\n\n\t* gcc.dg/tree-ssa/prefetch-5.c: New test.\n\nFrom-SVN: r122969", "tree": {"sha": "5428421105c29c278a57087c665dc954fb95d826", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5428421105c29c278a57087c665dc954fb95d826"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bdb685eda8fc13f43450520b257fa1bfe3e464e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bdb685eda8fc13f43450520b257fa1bfe3e464e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bdb685eda8fc13f43450520b257fa1bfe3e464e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bdb685eda8fc13f43450520b257fa1bfe3e464e/comments", "author": null, "committer": null, "parents": [{"sha": "d4daf0d62328911ad4ba572a3e332a39abfb4096", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4daf0d62328911ad4ba572a3e332a39abfb4096", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4daf0d62328911ad4ba572a3e332a39abfb4096"}], "stats": {"total": 339, "additions": 235, "deletions": 104}, "files": [{"sha": "520f824c6f55ccbf5828391c633d7f4fd44f6709", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bdb685eda8fc13f43450520b257fa1bfe3e464e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bdb685eda8fc13f43450520b257fa1bfe3e464e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9bdb685eda8fc13f43450520b257fa1bfe3e464e", "patch": "@@ -1,3 +1,29 @@\n+2007-03-15  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-niter.c (record_estimate): Add \"upper\" argument.\n+\tUpdate constant estimates of number of iterations.\n+\t(record_nonwrapping_iv): Add \"upper\" argument.  \"data_size_bounds_p\"\n+\targument renamed to \"realistic\".\n+\t(compute_estimated_nb_iterations): Removed.\n+\t(record_niter_bound): New function.\n+\t(idx_infer_loop_bounds): For possible but unlikely tail arrays,\n+\tcall record_nonwrapping_iv with upper = false.\n+\t(infer_loop_bounds_from_signedness): Pass upper argument to\n+\trecord_nonwrapping_iv.\n+\t(estimate_numbers_of_iterations_loop): Do not call\n+\tcompute_estimated_nb_iterations.  Record estimate based on profile\n+\tinformation.  Initialize the constant estimates of number of\n+\titerations.\n+\t* tree-data-ref.c (estimated_loop_iterations): Return the recorded\n+\testimates.\n+\t* tree-ssa-loop-prefetch.c (loop_prefetch_arrays): Add dump when\n+\tnumber of iterations is too small.\n+\t* cfgloop.h (struct nb_iter_bound): Remove \"realistic\" field.\n+\t(EST_NOT_AVAILABLE): Removed.\n+\t(struct loop): Replace estimated_nb_iterations by any_upper_bound,\n+\tnb_iterations_upper_bound, any_estimate and nb_iterations_estimate\n+\tfields.\n+\n 2007-03-15  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* tree-ssa-loop-niter.c (refine_bounds_using_guard, bound_difference):"}, {"sha": "c5c1cf25b429d764adf0f6189b44f727a66d9664", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bdb685eda8fc13f43450520b257fa1bfe3e464e/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bdb685eda8fc13f43450520b257fa1bfe3e464e/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=9bdb685eda8fc13f43450520b257fa1bfe3e464e", "patch": "@@ -65,12 +65,6 @@ struct nb_iter_bound\n      are executed at most BOUND times.  */\n   bool is_exit;\n \n-  /* True if the bound is \"realistic\" -- i.e., most likely the loop really has\n-     number of iterations close to the bound.  Exact bounds (if the number of\n-     iterations of a loop is a constant) and bounds derived from the size of\n-     data accessed in the loop are considered realistic.  */\n-  bool realistic;\n-\n   /* The next bound in the list.  */\n   struct nb_iter_bound *next;\n };\n@@ -148,12 +142,18 @@ struct loop\n     {\n       /* Estimate was not computed yet.  */\n       EST_NOT_COMPUTED,\n-      /* Estimate was computed, but we could derive no useful bound.  */\n-      EST_NOT_AVAILABLE,\n       /* Estimate is ready.  */\n       EST_AVAILABLE\n     } estimate_state;\n-  double_int estimated_nb_iterations;\n+\n+  /* An integer guaranteed to bound the number of iterations of the loop\n+     from above.  */\n+  bool any_upper_bound;\n+  double_int nb_iterations_upper_bound;\n+\n+  /* An integer giving the expected number of iterations of the loop.  */\n+  bool any_estimate;\n+  double_int nb_iterations_estimate;\n \n   /* Upper bound on number of iterations of a loop.  */\n   struct nb_iter_bound *bounds;"}, {"sha": "8e8b8e70884c0623f281403c064d21af9729e5f7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bdb685eda8fc13f43450520b257fa1bfe3e464e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bdb685eda8fc13f43450520b257fa1bfe3e464e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9bdb685eda8fc13f43450520b257fa1bfe3e464e", "patch": "@@ -1,3 +1,7 @@\n+2007-03-15  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/prefetch-5.c: New test.\n+\n 2007-03-15  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR c++/30891"}, {"sha": "643ac8053e4cb036617957b4fcb55b35f6c2310c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/prefetch-5.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bdb685eda8fc13f43450520b257fa1bfe3e464e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fprefetch-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bdb685eda8fc13f43450520b257fa1bfe3e464e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fprefetch-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fprefetch-5.c?ref=9bdb685eda8fc13f43450520b257fa1bfe3e464e", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-options \"-O2 -fprefetch-loop-arrays -march=athlon -fdump-tree-aprefetch-details\" } */\n+\n+/* These are common idioms for writing variable-length arrays at the end\n+   of structures.  We should not deduce anything about the number of iterations\n+   of the loops from them.  */\n+\n+struct tail0\n+{\n+  int xxx;\n+  int yyy[0];\n+};\n+\n+int loop0 (int n, struct tail0 *x)\n+{\n+  int i, s = 0;\n+\n+  for (i = 0; i < n; i++)\n+    s += x->yyy[i];\n+\n+  return s;\n+}\n+\n+struct tail1\n+{\n+  int xxx;\n+  int yyy[1];\n+};\n+int loop1 (int n, struct tail1 *x)\n+{\n+  int i, s = 0;\n+\n+  for (i = 0; i < n; i++)\n+    s += x->yyy[i];\n+\n+  return s;\n+}\n+\n+/* It is unlikely that this should be a tail array.  We may deduce that most\n+   likely, the loop iterates about 5 times, and the array is not worth prefetching.  */\n+\n+struct tail5\n+{\n+  int xxx;\n+  int yyy[5];\n+};\n+int loop5 (int n, struct tail5 *x)\n+{\n+  int i, s = 0;\n+\n+  for (i = 0; i < n; i++)\n+    s += x->yyy[i];\n+\n+  return s;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Issued prefetch\" 2 \"aprefetch\" } } */\n+/* { dg-final { scan-tree-dump-times \"Not prefetching\" 1 \"aprefetch\" } } */\n+/* { dg-final { cleanup-tree-dump \"aprefetch\" } } */"}, {"sha": "01bb71b5907a4a2f8d08c7c392cbdcf269b95841", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bdb685eda8fc13f43450520b257fa1bfe3e464e/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bdb685eda8fc13f43450520b257fa1bfe3e464e/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=9bdb685eda8fc13f43450520b257fa1bfe3e464e", "patch": "@@ -2556,33 +2556,23 @@ static bool\n estimated_loop_iterations (struct loop *loop, bool conservative,\n \t\t\t   double_int *nit)\n {\n-  tree numiter = number_of_exit_cond_executions (loop);\n-\n-  /* If we have an exact value, use it.  */\n-  if (TREE_CODE (numiter) == INTEGER_CST)\n+  estimate_numbers_of_iterations_loop (loop);\n+  if (conservative)\n     {\n-      *nit = tree_to_double_int (numiter);\n-      return true;\n-    }\n+      if (!loop->any_upper_bound)\n+\treturn false;\n \n-  /* If we have a measured profile and we do not ask for a conservative bound,\n-     use it.  */\n-  if (!conservative && loop->header->count != 0)\n-    {\n-      *nit = uhwi_to_double_int (expected_loop_iterations (loop) + 1);\n-      return true;\n+      *nit = loop->nb_iterations_upper_bound;\n     }\n-\n-  /* Finally, try using a reliable estimate on number of iterations according\n-     to the size of the accessed data, if available.  */\n-  estimate_numbers_of_iterations_loop (loop);\n-  if (loop->estimate_state == EST_AVAILABLE)\n+  else\n     {\n-      *nit = loop->estimated_nb_iterations;\n-      return true;\n+      if (!loop->any_estimate)\n+\treturn false;\n+\n+      *nit = loop->nb_iterations_estimate;\n     }\n \n-  return false;\n+  return true;\n }\n \n /* Similar to estimated_loop_iterations, but returns the estimate only"}, {"sha": "909f5fcd30af05bff24c4510edb034aab5e5795a", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 118, "deletions": 73, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bdb685eda8fc13f43450520b257fa1bfe3e464e/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bdb685eda8fc13f43450520b257fa1bfe3e464e/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=9bdb685eda8fc13f43450520b257fa1bfe3e464e", "patch": "@@ -2386,46 +2386,110 @@ derive_constant_upper_bound (tree val)\n     }\n }\n \n+/* Records that every statement in LOOP is executed I_BOUND times.\n+   REALISTIC is true if I_BOUND is expected to be close the the real number\n+   of iterations.  UPPER is true if we are sure the loop iterates at most\n+   I_BOUND times.  */\n+\n+static void\n+record_niter_bound (struct loop *loop, double_int i_bound, bool realistic,\n+\t\t    bool upper)\n+{\n+  /* Update the bounds only when there is no previous estimation, or when the current\n+     estimation is smaller.  */\n+  if (upper\n+      && (!loop->any_upper_bound\n+\t  || double_int_ucmp (i_bound, loop->nb_iterations_upper_bound) < 0))\n+    {\n+      loop->any_upper_bound = true;\n+      loop->nb_iterations_upper_bound = i_bound;\n+    }\n+  if (realistic\n+      && (!loop->any_estimate\n+\t  || double_int_ucmp (i_bound, loop->nb_iterations_estimate) < 0))\n+    {\n+      loop->any_estimate = true;\n+      loop->nb_iterations_estimate = i_bound;\n+    }\n+}\n+\n /* Records that AT_STMT is executed at most BOUND + 1 times in LOOP.  IS_EXIT\n    is true if the loop is exited immediately after STMT, and this exit\n    is taken at last when the STMT is executed BOUND + 1 times.\n-   REALISTIC is true if the estimate comes from a reliable source\n-   (number of iterations analysis, or size of data accessed in the loop).\n-   I_BOUND is an unsigned double_int upper estimate on BOUND.  */\n+   REALISTIC is true if BOUND is expected to be close the the real number\n+   of iterations.  UPPER is true if we are sure the loop iterates at most\n+   BOUND times.  I_BOUND is an unsigned double_int upper estimate on BOUND.  */\n \n static void\n record_estimate (struct loop *loop, tree bound, double_int i_bound,\n-\t\t tree at_stmt, bool is_exit, bool realistic)\n+\t\t tree at_stmt, bool is_exit, bool realistic, bool upper)\n {\n-  struct nb_iter_bound *elt = xmalloc (sizeof (struct nb_iter_bound));\n+  double_int delta;\n+  edge exit;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Statement %s\", is_exit ? \"(exit)\" : \"\");\n       print_generic_expr (dump_file, at_stmt, TDF_SLIM);\n-      fprintf (dump_file, \" is executed at most \");\n+      fprintf (dump_file, \" is %sexecuted at most \",\n+\t       upper ? \"\" : \"probably \");\n       print_generic_expr (dump_file, bound, TDF_SLIM);\n       fprintf (dump_file, \" (bounded by \");\n       dump_double_int (dump_file, i_bound, true);\n       fprintf (dump_file, \") + 1 times in loop %d.\\n\", loop->num);\n     }\n \n-  elt->bound = i_bound;\n-  elt->stmt = at_stmt;\n-  elt->is_exit = is_exit;\n-  elt->realistic = realistic && TREE_CODE (bound) == INTEGER_CST;\n-  elt->next = loop->bounds;\n-  loop->bounds = elt;\n+  /* If the I_BOUND is just an estimate of BOUND, it rarely is close to the\n+     real number of iterations.  */\n+  if (TREE_CODE (bound) != INTEGER_CST)\n+    realistic = false;\n+  if (!upper && !realistic)\n+    return;\n+\n+  /* If we have a guaranteed upper bound, record it in the appropriate\n+     list.  */\n+  if (upper)\n+    {\n+      struct nb_iter_bound *elt = XNEW (struct nb_iter_bound);\n+\n+      elt->bound = i_bound;\n+      elt->stmt = at_stmt;\n+      elt->is_exit = is_exit;\n+      elt->next = loop->bounds;\n+      loop->bounds = elt;\n+    }\n+\n+  /* Update the number of iteration estimates according to the bound.\n+     If at_stmt is an exit, then every statement in the loop is\n+     executed at most BOUND + 1 times.  If it is not an exit, then\n+     some of the statements before it could be executed BOUND + 2\n+     times, if an exit of LOOP is before stmt.  */\n+  exit = single_exit (loop);\n+  if (is_exit\n+      || (exit != NULL\n+\t  && dominated_by_p (CDI_DOMINATORS,\n+\t\t\t     exit->src, bb_for_stmt (at_stmt))))\n+    delta = double_int_one;\n+  else\n+    delta = double_int_two;\n+  i_bound = double_int_add (i_bound, delta);\n+\n+  /* If an overflow occured, ignore the result.  */\n+  if (double_int_ucmp (i_bound, delta) < 0)\n+    return;\n+\n+  record_niter_bound (loop, i_bound, realistic, upper);\n }\n \n /* Record the estimate on number of iterations of LOOP based on the fact that\n    the induction variable BASE + STEP * i evaluated in STMT does not wrap and\n-   its values belong to the range <LOW, HIGH>.  DATA_SIZE_BOUNDS_P is true if\n-   LOW and HIGH are derived from the size of data.  */\n+   its values belong to the range <LOW, HIGH>.  REALISTIC is true if the\n+   estimated number of iterations is expected to be close to the real one.\n+   UPPER is true if we are sure the induction variable does not wrap.  */\n \n static void\n record_nonwrapping_iv (struct loop *loop, tree base, tree step, tree stmt,\n-\t\t       tree low, tree high, bool data_size_bounds_p)\n+\t\t       tree low, tree high, bool realistic, bool upper)\n {\n   tree niter_bound, extreme, delta;\n   tree type = TREE_TYPE (base), unsigned_type;\n@@ -2471,55 +2535,7 @@ record_nonwrapping_iv (struct loop *loop, tree base, tree step, tree stmt,\n      would get out of the range.  */\n   niter_bound = fold_build2 (FLOOR_DIV_EXPR, unsigned_type, delta, step);\n   max = derive_constant_upper_bound (niter_bound);\n-  record_estimate (loop, niter_bound, max, stmt, false, data_size_bounds_p);\n-}\n-\n-/* Initialize LOOP->ESTIMATED_NB_ITERATIONS with the lowest safe\n-   approximation of the number of iterations for LOOP.  */\n-\n-static void\n-compute_estimated_nb_iterations (struct loop *loop)\n-{\n-  struct nb_iter_bound *bound;\n-  double_int bnd_val, delta;\n-  edge exit;\n- \n-  gcc_assert (loop->estimate_state == EST_NOT_AVAILABLE);\n-\n-  for (bound = loop->bounds; bound; bound = bound->next)\n-    {\n-      if (!bound->realistic)\n-\tcontinue;\n-\n-      bnd_val = bound->bound;\n-      /* If bound->stmt is an exit, then every statement in the loop is\n-\t executed at most BND_VAL + 1 times.  If it is not an exit, then\n-\t some of the statements before it could be executed BND_VAL + 2\n-\t times, if an exit of LOOP is before stmt.  */\n-      exit = single_exit (loop);\n-\n-      if (bound->is_exit\n-\t  || (exit != NULL\n-\t      && dominated_by_p (CDI_DOMINATORS,\n-\t\t\t\t exit->src, bb_for_stmt (bound->stmt))))\n-\tdelta = double_int_one;\n-      else\n-\tdelta = double_int_two;\n-      bnd_val = double_int_add (bnd_val, delta);\n-\n-      /* If an overflow occured, ignore the result.  */\n-      if (double_int_ucmp (bnd_val, delta) < 0)\n-\tcontinue;\n-\n-      /* Update only when there is no previous estimation, or when the current\n-\t estimation is smaller.  */\n-      if (loop->estimate_state == EST_NOT_AVAILABLE\n-\t  || double_int_ucmp (bnd_val, loop->estimated_nb_iterations) < 0)\n-\t{\n-\t  loop->estimate_state = EST_AVAILABLE;\n-\t  loop->estimated_nb_iterations = bnd_val;\n-\t}\n-    }\n+  record_estimate (loop, niter_bound, max, stmt, false, realistic, upper);\n }\n \n /* Returns true if REF is a reference to an array at the end of a dynamically\n@@ -2579,13 +2595,18 @@ idx_infer_loop_bounds (tree base, tree *idx, void *dta)\n   struct ilb_data *data = dta;\n   tree ev, init, step;\n   tree low, high, type, next;\n-  bool sign;\n+  bool sign, upper = true;\n   struct loop *loop = data->loop;\n \n-  if (TREE_CODE (base) != ARRAY_REF\n-      || array_at_struct_end_p (base))\n+  if (TREE_CODE (base) != ARRAY_REF)\n     return true;\n \n+  /* For arrays at the end of the structure, we are not guaranteed that they\n+     do not really extend over their declared size.  However, for arrays of\n+     size greater than one, this is unlikely to be intended.  */\n+  if (array_at_struct_end_p (base))\n+    upper = false;\n+\n   ev = instantiate_parameters (loop, analyze_scalar_evolution (loop, *idx));\n   init = initial_condition (ev);\n   step = evolution_part_in_loop_num (ev, loop->num);\n@@ -2609,7 +2630,13 @@ idx_infer_loop_bounds (tree base, tree *idx, void *dta)\n     return true;\n   sign = tree_int_cst_sign_bit (step);\n   type = TREE_TYPE (step);\n-  \n+\n+  /* The array of length 1 at the end of a structure most likely extends\n+     beyond its bounds.  */\n+  if (!upper\n+      && operand_equal_p (low, high, 0))\n+    return true;\n+\n   /* In case the relevant bound of the array does not fit in type, or\n      it does, but bound + step (in type) still belongs into the range of the\n      array, the index may wrap and still stay within the range of the array\n@@ -2633,7 +2660,7 @@ idx_infer_loop_bounds (tree base, tree *idx, void *dta)\n       && tree_int_cst_compare (next, high) <= 0)\n     return true;\n \n-  record_nonwrapping_iv (loop, init, step, data->stmt, low, high, true);\n+  record_nonwrapping_iv (loop, init, step, data->stmt, low, high, true, upper);\n   return true;\n }\n \n@@ -2722,7 +2749,7 @@ infer_loop_bounds_from_signedness (struct loop *loop, tree stmt)\n   low = lower_bound_in_type (type, type);\n   high = upper_bound_in_type (type, type);\n \n-  record_nonwrapping_iv (loop, base, step, stmt, low, high, false);\n+  record_nonwrapping_iv (loop, base, step, stmt, low, high, false, true);\n }\n \n /* The following analyzers are extracting informations on the bounds\n@@ -2776,11 +2803,14 @@ estimate_numbers_of_iterations_loop (struct loop *loop)\n   unsigned i;\n   struct tree_niter_desc niter_desc;\n   edge ex;\n+  double_int bound;\n \n   /* Give up if we already have tried to compute an estimation.  */\n   if (loop->estimate_state != EST_NOT_COMPUTED)\n     return;\n-  loop->estimate_state = EST_NOT_AVAILABLE;\n+  loop->estimate_state = EST_AVAILABLE;\n+  loop->any_upper_bound = false;\n+  loop->any_estimate = false;\n \n   exits = get_loop_exit_edges (loop);\n   for (i = 0; VEC_iterate (edge, exits, i, ex); i++)\n@@ -2796,12 +2826,27 @@ estimate_numbers_of_iterations_loop (struct loop *loop)\n \t\t\tniter);\n       record_estimate (loop, niter, niter_desc.max,\n \t\t       last_stmt (ex->src),\n-\t\t       true, true);\n+\t\t       true, true, true);\n     }\n   VEC_free (edge, heap, exits);\n   \n   infer_loop_bounds_from_undefined (loop);\n-  compute_estimated_nb_iterations (loop);\n+\n+  /* If we have a measured profile, use it to estimate the number of\n+     iterations.  */\n+  if (loop->header->count != 0)\n+    {\n+      bound = uhwi_to_double_int (expected_loop_iterations (loop) + 1);\n+      record_niter_bound (loop, bound, true, false);\n+    }\n+\n+  /* If an upper bound is smaller than the realistic estimate of the\n+     number of iterations, use the upper bound instead.  */\n+  if (loop->any_upper_bound\n+      && loop->any_estimate\n+      && double_int_ucmp (loop->nb_iterations_upper_bound,\n+\t\t\t  loop->nb_iterations_estimate) < 0)\n+    loop->nb_iterations_estimate = loop->nb_iterations_upper_bound;\n }\n \n /* Records estimates on numbers of iterations of loops.  */"}, {"sha": "a0d70cc382f28d9ecc87adc53f8ce7e9281b9602", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bdb685eda8fc13f43450520b257fa1bfe3e464e/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bdb685eda8fc13f43450520b257fa1bfe3e464e/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=9bdb685eda8fc13f43450520b257fa1bfe3e464e", "patch": "@@ -968,7 +968,13 @@ loop_prefetch_arrays (struct loop *loop)\n      the loop rolls at least AHEAD times, prefetching the references does not\n      make sense.  */\n   if (est_niter >= 0 && est_niter <= (HOST_WIDE_INT) ahead)\n-    goto fail;\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Not prefetching -- loop estimated to roll only %d times\\n\",\n+\t\t (int) est_niter);\n+      goto fail;\n+    }\n \n   ninsns = tree_num_loop_insns (loop, &eni_size_weights);\n   unroll_factor = determine_unroll_factor (loop, refs, ninsns, &desc,"}]}