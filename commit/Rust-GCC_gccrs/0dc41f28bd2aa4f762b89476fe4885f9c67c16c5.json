{"sha": "0dc41f28bd2aa4f762b89476fe4885f9c67c16c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRjNDFmMjhiZDJhYTRmNzYyYjg5NDc2ZmU0ODg1ZjljNjdjMTZjNQ==", "commit": {"author": {"name": "Wei Mi", "email": "wmi@google.com", "date": "2013-11-04T21:41:48Z"}, "committer": {"name": "Wei Mi", "email": "wmi@gcc.gnu.org", "date": "2013-11-04T21:41:48Z"}, "message": "i386.c (memory_address_length): Extract a part of code to rip_relative_addr_p.\n\n2013-11-04  Wei Mi  <wmi@google.com>\n\n\t* gcc/config/i386/i386.c (memory_address_length): Extract a part\n\tof code to rip_relative_addr_p.\n\t(rip_relative_addr_p): New Function.\n\t(ix86_macro_fusion_p): Ditto.\n\t(ix86_macro_fusion_pair_p): Ditto.\n\t* gcc/config/i386/i386.h: Add new tune features about macro-fusion.\n\t* gcc/config/i386/x86-tune.def (DEF_TUNE): Ditto.\n\t* gcc/doc/tm.texi: Generated.\n\t* gcc/doc/tm.texi.in: Ditto.\n\t* gcc/haifa-sched.c (try_group_insn): New Function.\n\t(group_insns_for_macro_fusion): Ditto.\n\t(sched_init): Call group_insns_for_macro_fusion.\n\t* gcc/target.def: Add two hooks: macro_fusion_p and\n\tmacro_fusion_pair_p.\n\nFrom-SVN: r204369", "tree": {"sha": "ce5d3012d103754d13987152cc5ea59c12303593", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce5d3012d103754d13987152cc5ea59c12303593"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0dc41f28bd2aa4f762b89476fe4885f9c67c16c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dc41f28bd2aa4f762b89476fe4885f9c67c16c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dc41f28bd2aa4f762b89476fe4885f9c67c16c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dc41f28bd2aa4f762b89476fe4885f9c67c16c5/comments", "author": {"login": "wmi-11", "id": 59629650, "node_id": "MDQ6VXNlcjU5NjI5NjUw", "avatar_url": "https://avatars.githubusercontent.com/u/59629650?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wmi-11", "html_url": "https://github.com/wmi-11", "followers_url": "https://api.github.com/users/wmi-11/followers", "following_url": "https://api.github.com/users/wmi-11/following{/other_user}", "gists_url": "https://api.github.com/users/wmi-11/gists{/gist_id}", "starred_url": "https://api.github.com/users/wmi-11/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wmi-11/subscriptions", "organizations_url": "https://api.github.com/users/wmi-11/orgs", "repos_url": "https://api.github.com/users/wmi-11/repos", "events_url": "https://api.github.com/users/wmi-11/events{/privacy}", "received_events_url": "https://api.github.com/users/wmi-11/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}], "stats": {"total": 305, "additions": 281, "deletions": 24}, "files": [{"sha": "895da5a9bd96df5a6868a342424dc8df349020de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc41f28bd2aa4f762b89476fe4885f9c67c16c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc41f28bd2aa4f762b89476fe4885f9c67c16c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0dc41f28bd2aa4f762b89476fe4885f9c67c16c5", "patch": "@@ -1,3 +1,20 @@\n+2013-11-04  Wei Mi  <wmi@google.com>\n+\n+\t* gcc/config/i386/i386.c (memory_address_length): Extract a part\n+\tof code to rip_relative_addr_p.\n+\t(rip_relative_addr_p): New Function.\n+\t(ix86_macro_fusion_p): Ditto.\n+\t(ix86_macro_fusion_pair_p): Ditto.\n+\t* gcc/config/i386/i386.h: Add new tune features about macro-fusion.\n+\t* gcc/config/i386/x86-tune.def (DEF_TUNE): Ditto.\n+\t* gcc/doc/tm.texi: Generated.\n+\t* gcc/doc/tm.texi.in: Ditto.\n+\t* gcc/haifa-sched.c (try_group_insn): New Function.\n+\t(group_insns_for_macro_fusion): Ditto.\n+\t(sched_init): Call group_insns_for_macro_fusion.\n+\t* gcc/target.def: Add two hooks: macro_fusion_p and\n+\tmacro_fusion_pair_p.\n+\n 2013-11-04  Kostya Serebryany  <kcc@google.com>\n \n \tUpdate to match the changed asan API."}, {"sha": "11064d8e24065c3474e32654597fd59806dcb356", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 155, "deletions": 19, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc41f28bd2aa4f762b89476fe4885f9c67c16c5/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc41f28bd2aa4f762b89476fe4885f9c67c16c5/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0dc41f28bd2aa4f762b89476fe4885f9c67c16c5", "patch": "@@ -24523,6 +24523,42 @@ ix86_instantiate_decls (void)\n       instantiate_decl_rtl (s->rtl);\n }\n \f\n+/* Check whether x86 address PARTS is a pc-relative address.  */\n+\n+static bool\n+rip_relative_addr_p (struct ix86_address *parts)\n+{\n+  rtx base, index, disp;\n+\n+  base = parts->base;\n+  index = parts->index;\n+  disp = parts->disp;\n+\n+  if (disp && !base && !index)\n+    {\n+      if (TARGET_64BIT)\n+\t{\n+\t  rtx symbol = disp;\n+\n+\t  if (GET_CODE (disp) == CONST)\n+\t    symbol = XEXP (disp, 0);\n+\t  if (GET_CODE (symbol) == PLUS\n+\t      && CONST_INT_P (XEXP (symbol, 1)))\n+\t    symbol = XEXP (symbol, 0);\n+\n+\t  if (GET_CODE (symbol) == LABEL_REF\n+\t      || (GET_CODE (symbol) == SYMBOL_REF\n+\t\t  && SYMBOL_REF_TLS_MODEL (symbol) == 0)\n+\t      || (GET_CODE (symbol) == UNSPEC\n+\t\t  && (XINT (symbol, 1) == UNSPEC_GOTPCREL\n+\t\t      || XINT (symbol, 1) == UNSPEC_PCREL\n+\t\t      || XINT (symbol, 1) == UNSPEC_GOTNTPOFF)))\n+\t    return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n /* Calculate the length of the memory address in the instruction encoding.\n    Includes addr32 prefix, does not include the one-byte modrm, opcode,\n    or other prefixes.  We never generate addr32 prefix for LEA insn.  */\n@@ -24594,25 +24630,8 @@ memory_address_length (rtx addr, bool lea)\n   else if (disp && !base && !index)\n     {\n       len += 4;\n-      if (TARGET_64BIT)\n-\t{\n-\t  rtx symbol = disp;\n-\n-\t  if (GET_CODE (disp) == CONST)\n-\t    symbol = XEXP (disp, 0);\n-\t  if (GET_CODE (symbol) == PLUS\n-\t      && CONST_INT_P (XEXP (symbol, 1)))\n-\t    symbol = XEXP (symbol, 0);\n-\n-\t  if (GET_CODE (symbol) != LABEL_REF\n-\t      && (GET_CODE (symbol) != SYMBOL_REF\n-\t\t  || SYMBOL_REF_TLS_MODEL (symbol) != 0)\n-\t      && (GET_CODE (symbol) != UNSPEC\n-\t\t  || (XINT (symbol, 1) != UNSPEC_GOTPCREL\n-\t\t      && XINT (symbol, 1) != UNSPEC_PCREL\n-\t\t      && XINT (symbol, 1) != UNSPEC_GOTNTPOFF)))\n-\t    len++;\n-\t}\n+      if (rip_relative_addr_p (&parts))\n+\tlen++;\n     }\n   else\n     {\n@@ -25204,6 +25223,119 @@ ia32_multipass_dfa_lookahead (void)\n     }\n }\n \n+/* Return true if target platform supports macro-fusion.  */\n+\n+static bool\n+ix86_macro_fusion_p ()\n+{\n+  return TARGET_FUSE_CMP_AND_BRANCH;\n+}\n+\n+/* Check whether current microarchitecture support macro fusion\n+   for insn pair \"CONDGEN + CONDJMP\". Refer to\n+   \"Intel Architectures Optimization Reference Manual\". */\n+\n+static bool\n+ix86_macro_fusion_pair_p (rtx condgen, rtx condjmp)\n+{\n+  rtx src, dest;\n+  rtx single_set = single_set (condgen);\n+  enum rtx_code ccode;\n+  rtx compare_set = NULL_RTX, test_if, cond;\n+  rtx alu_set = NULL_RTX, addr = NULL_RTX;\n+\n+  if (get_attr_type (condgen) != TYPE_TEST\n+      && get_attr_type (condgen) != TYPE_ICMP\n+      && get_attr_type (condgen) != TYPE_INCDEC\n+      && get_attr_type (condgen) != TYPE_ALU)\n+    return false;\n+\n+  if (single_set == NULL_RTX\n+      && !TARGET_FUSE_ALU_AND_BRANCH)\n+    return false;\n+\n+  if (single_set != NULL_RTX)\n+    compare_set = single_set;\n+  else\n+    {\n+      int i;\n+      rtx pat = PATTERN (condgen);\n+      for (i = 0; i < XVECLEN (pat, 0); i++)\n+\tif (GET_CODE (XVECEXP (pat, 0, i)) == SET)\n+\t  {\n+\t    rtx set_src = SET_SRC (XVECEXP (pat, 0, i));\n+\t    if (GET_CODE (set_src) == COMPARE)\n+\t      compare_set = XVECEXP (pat, 0, i);\n+\t    else\n+\t      alu_set = XVECEXP (pat, 0, i);\n+\t  }\n+    }\n+  if (compare_set == NULL_RTX)\n+    return false;\n+  src = SET_SRC (compare_set);\n+  if (GET_CODE (src) != COMPARE)\n+    return false;\n+\n+  /* Macro-fusion for cmp/test MEM-IMM + conditional jmp is not\n+     supported.  */\n+  if ((MEM_P (XEXP (src, 0))\n+       && CONST_INT_P (XEXP (src, 1)))\n+      || (MEM_P (XEXP (src, 1))\n+\t  && CONST_INT_P (XEXP (src, 0))))\n+    return false;\n+\n+  /* No fusion for RIP-relative address.  */\n+  if (MEM_P (XEXP (src, 0)))\n+    addr = XEXP (XEXP (src, 0), 0);\n+  else if (MEM_P (XEXP (src, 1)))\n+    addr = XEXP (XEXP (src, 1), 0);\n+\n+  if (addr) {\n+    ix86_address parts;\n+    int ok = ix86_decompose_address (addr, &parts);\n+    gcc_assert (ok);\n+\n+    if (rip_relative_addr_p (&parts))\n+      return false;\n+  }\n+\n+  test_if = SET_SRC (pc_set (condjmp));\n+  cond = XEXP (test_if, 0);\n+  ccode = GET_CODE (cond);\n+  /* Check whether conditional jump use Sign or Overflow Flags.  */\n+  if (!TARGET_FUSE_CMP_AND_BRANCH_SOFLAGS\n+      && (ccode == GE\n+          || ccode == GT\n+\t  || ccode == LE\n+\t  || ccode == LT))\n+    return false;\n+\n+  /* Return true for TYPE_TEST and TYPE_ICMP.  */\n+  if (get_attr_type (condgen) == TYPE_TEST\n+      || get_attr_type (condgen) == TYPE_ICMP)\n+    return true;\n+\n+  /* The following is the case that macro-fusion for alu + jmp.  */\n+  if (!TARGET_FUSE_ALU_AND_BRANCH || !alu_set)\n+    return false;\n+\n+  /* No fusion for alu op with memory destination operand.  */\n+  dest = SET_DEST (alu_set);\n+  if (MEM_P (dest))\n+    return false;\n+\n+  /* Macro-fusion for inc/dec + unsigned conditional jump is not\n+     supported.  */\n+  if (get_attr_type (condgen) == TYPE_INCDEC\n+      && (ccode == GEU\n+\t  || ccode == GTU\n+\t  || ccode == LEU\n+\t  || ccode == LTU))\n+    return false;\n+\n+  return true;\n+}\n+\n /* Try to reorder ready list to take advantage of Atom pipelined IMUL\n    execution. It is applied if\n    (1) IMUL instruction is on the top of list;\n@@ -43487,6 +43619,10 @@ ix86_memmodel_check (unsigned HOST_WIDE_INT val)\n #undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD \\\n   ia32_multipass_dfa_lookahead\n+#undef TARGET_SCHED_MACRO_FUSION_P\n+#define TARGET_SCHED_MACRO_FUSION_P ix86_macro_fusion_p\n+#undef TARGET_SCHED_MACRO_FUSION_PAIR_P\n+#define TARGET_SCHED_MACRO_FUSION_PAIR_P ix86_macro_fusion_pair_p\n \n #undef TARGET_FUNCTION_OK_FOR_SIBCALL\n #define TARGET_FUNCTION_OK_FOR_SIBCALL ix86_function_ok_for_sibcall"}, {"sha": "9836a40b46c7429a3242740bc4e0f8b96679af5b", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc41f28bd2aa4f762b89476fe4885f9c67c16c5/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc41f28bd2aa4f762b89476fe4885f9c67c16c5/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=0dc41f28bd2aa4f762b89476fe4885f9c67c16c5", "patch": "@@ -416,8 +416,17 @@ extern unsigned char ix86_tune_features[X86_TUNE_LAST];\n \tix86_tune_features[X86_TUNE_USE_VECTOR_FP_CONVERTS]\n #define TARGET_USE_VECTOR_CONVERTS \\\n \tix86_tune_features[X86_TUNE_USE_VECTOR_CONVERTS]\n+#define TARGET_FUSE_CMP_AND_BRANCH_32 \\\n+\tix86_tune_features[X86_TUNE_FUSE_CMP_AND_BRANCH_32]\n+#define TARGET_FUSE_CMP_AND_BRANCH_64 \\\n+\tix86_tune_features[X86_TUNE_FUSE_CMP_AND_BRANCH_64]\n #define TARGET_FUSE_CMP_AND_BRANCH \\\n-\tix86_tune_features[X86_TUNE_FUSE_CMP_AND_BRANCH]\n+\t(TARGET_64BIT ? TARGET_FUSE_CMP_AND_BRANCH_64 \\\n+\t : TARGET_FUSE_CMP_AND_BRANCH_32)\n+#define TARGET_FUSE_CMP_AND_BRANCH_SOFLAGS \\\n+\tix86_tune_features[X86_TUNE_FUSE_CMP_AND_BRANCH_SOFLAGS]\n+#define TARGET_FUSE_ALU_AND_BRANCH \\\n+\tix86_tune_features[X86_TUNE_FUSE_ALU_AND_BRANCH]\n #define TARGET_OPT_AGU ix86_tune_features[X86_TUNE_OPT_AGU]\n #define TARGET_VECTORIZE_DOUBLE \\\n \tix86_tune_features[X86_TUNE_VECTORIZE_DOUBLE]"}, {"sha": "1a85ce266df6aecbf8f2fa55965695f882048d03", "filename": "gcc/config/i386/x86-tune.def", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc41f28bd2aa4f762b89476fe4885f9c67c16c5/gcc%2Fconfig%2Fi386%2Fx86-tune.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc41f28bd2aa4f762b89476fe4885f9c67c16c5/gcc%2Fconfig%2Fi386%2Fx86-tune.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-tune.def?ref=0dc41f28bd2aa4f762b89476fe4885f9c67c16c5", "patch": "@@ -92,11 +92,29 @@ DEF_TUNE (X86_TUNE_MOVX, \"movx\",\n DEF_TUNE (X86_TUNE_MEMORY_MISMATCH_STALL, \"memory_mismatch_stall\",\n           m_P4_NOCONA | m_CORE_ALL | m_ATOM | m_SLM | m_AMD_MULTIPLE | m_GENERIC)\n \n-/* X86_TUNE_FUSE_CMP_AND_BRANCH: Fuse a compare or test instruction\n-   with a subsequent conditional jump instruction into a single\n-   compare-and-branch uop.\n+/* X86_TUNE_FUSE_CMP_AND_BRANCH_32: Fuse compare with a subsequent\n+   conditional jump instruction for 32 bit TARGET.\n    FIXME: revisit for generic.  */\n-DEF_TUNE (X86_TUNE_FUSE_CMP_AND_BRANCH, \"fuse_cmp_and_branch\", m_BDVER | m_CORE_ALL)\n+DEF_TUNE (X86_TUNE_FUSE_CMP_AND_BRANCH_32, \"fuse_cmp_and_branch_32\",\n+          m_CORE_ALL | m_BDVER)\n+\n+/* X86_TUNE_FUSE_CMP_AND_BRANCH_64: Fuse compare with a subsequent\n+   conditional jump instruction for TARGET_64BIT.\n+   FIXME: revisit for generic.  */\n+DEF_TUNE (X86_TUNE_FUSE_CMP_AND_BRANCH_64, \"fuse_cmp_and_branch_64\",\n+          m_COREI7 | m_COREI7_AVX | m_HASWELL | m_BDVER)\n+\n+/* X86_TUNE_FUSE_CMP_AND_BRANCH_SOFLAGS: Fuse compare with a\n+   subsequent conditional jump instruction when the condition jump\n+   check sign flag (SF) or overflow flag (OF).  */\n+DEF_TUNE (X86_TUNE_FUSE_CMP_AND_BRANCH_SOFLAGS, \"fuse_cmp_and_branch_soflags\",\n+          m_COREI7 | m_COREI7_AVX | m_HASWELL | m_BDVER)\n+\n+/* X86_TUNE_FUSE_ALU_AND_BRANCH: Fuse alu with a subsequent conditional\n+   jump instruction when the alu instruction produces the CCFLAG consumed by\n+   the conditional jump instruction. */\n+DEF_TUNE (X86_TUNE_FUSE_ALU_AND_BRANCH, \"fuse_alu_and_branch\",\n+          m_COREI7_AVX | m_HASWELL)\n \n /* X86_TUNE_REASSOC_INT_TO_PARALLEL: Try to produce parallel computations\n    during reassociation of integer computation.  */"}, {"sha": "f5e8d2cdcec56a608d86f206386f9fa1db6627f5", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc41f28bd2aa4f762b89476fe4885f9c67c16c5/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc41f28bd2aa4f762b89476fe4885f9c67c16c5/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=0dc41f28bd2aa4f762b89476fe4885f9c67c16c5", "patch": "@@ -6574,6 +6574,17 @@ scheduling one insn causes other insns to become ready in the same\n cycle.  These other insns can then be taken into account properly.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_SCHED_MACRO_FUSION_P (void)\n+This hook is used to check whether target platform supports macro fusion.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} bool TARGET_SCHED_MACRO_FUSION_PAIR_P (rtx @var{condgen}, rtx @var{condjmp})\n+This hook is used to check whether two insns could be macro fused for\n+target microarchitecture. If this hook returns true for the given insn pair\n+(@var{condgen} and @var{condjmp}), scheduler will put them into a sched\n+group, and they will not be scheduled apart.\n+@end deftypefn\n+\n @deftypefn {Target Hook} void TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK (rtx @var{head}, rtx @var{tail})\n This hook is called after evaluation forward dependencies of insns in\n chain given by two parameter values (@var{head} and @var{tail}"}, {"sha": "1624f4f715e514235b155ad4845f250b6e96ddaa", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc41f28bd2aa4f762b89476fe4885f9c67c16c5/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc41f28bd2aa4f762b89476fe4885f9c67c16c5/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=0dc41f28bd2aa4f762b89476fe4885f9c67c16c5", "patch": "@@ -4938,6 +4938,10 @@ them: try the first ones in this list first.\n \n @hook TARGET_SCHED_REORDER2\n \n+@hook TARGET_SCHED_MACRO_FUSION_P\n+\n+@hook TARGET_SCHED_MACRO_FUSION_PAIR_P\n+\n @hook TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK\n \n @hook TARGET_SCHED_INIT"}, {"sha": "ab21d0d481b5fd9dc7d962fc08ef5611c20380b4", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc41f28bd2aa4f762b89476fe4885f9c67c16c5/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc41f28bd2aa4f762b89476fe4885f9c67c16c5/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=0dc41f28bd2aa4f762b89476fe4885f9c67c16c5", "patch": "@@ -6519,6 +6519,50 @@ setup_sched_dump (void)\n \t\t? stderr : dump_file);\n }\n \n+/* Try to group comparison and the following conditional jump INSN if\n+   they're already adjacent. This is to prevent scheduler from scheduling\n+   them apart.  */\n+\n+static void\n+try_group_insn (rtx insn)\n+{\n+  unsigned int condreg1, condreg2;\n+  rtx cc_reg_1;\n+  rtx prev;\n+\n+  if (!any_condjump_p (insn))\n+    return;\n+\n+  targetm.fixed_condition_code_regs (&condreg1, &condreg2);\n+  cc_reg_1 = gen_rtx_REG (CCmode, condreg1);\n+  prev = prev_nonnote_nondebug_insn (insn);\n+  if (!reg_referenced_p (cc_reg_1, PATTERN (insn))\n+      || !prev\n+      || !modified_in_p (cc_reg_1, prev))\n+    return;\n+\n+  /* Different microarchitectures support macro fusions for different\n+     combinations of insn pairs.  */\n+  if (!targetm.sched.macro_fusion_pair_p\n+      || !targetm.sched.macro_fusion_pair_p (prev, insn))\n+    return;\n+\n+  SCHED_GROUP_P (insn) = 1;\n+}\n+\n+/* If the last cond jump and the cond register defining insn are consecutive\n+   before scheduling, we want them to be in a schedule group. This is good\n+   for performance on microarchitectures supporting macro-fusion.  */\n+\n+static void\n+group_insns_for_macro_fusion ()\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    try_group_insn (BB_END (bb));\n+}\n+\n /* Initialize some global state for the scheduler.  This function works\n    with the common data shared between all the schedulers.  It is called\n    from the scheduler specific initialization routine.  */\n@@ -6645,6 +6689,11 @@ sched_init (void)\n     }\n \n   curr_state = xmalloc (dfa_state_size);\n+\n+  /* Group compare and branch insns for macro-fusion.  */\n+  if (targetm.sched.macro_fusion_p\n+      && targetm.sched.macro_fusion_p ())\n+    group_insns_for_macro_fusion ();\n }\n \n static void haifa_init_only_bb (basic_block, basic_block);"}, {"sha": "e665c1cb725234e456b7d0d12c17c3eb3e6fff8b", "filename": "gcc/target.def", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc41f28bd2aa4f762b89476fe4885f9c67c16c5/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc41f28bd2aa4f762b89476fe4885f9c67c16c5/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=0dc41f28bd2aa4f762b89476fe4885f9c67c16c5", "patch": "@@ -1041,6 +1041,19 @@ scheduling one insn causes other insns to become ready in the same\\n\\\n cycle.  These other insns can then be taken into account properly.\",\n  int, (FILE *file, int verbose, rtx *ready, int *n_readyp, int clock), NULL)\n \n+DEFHOOK\n+(macro_fusion_p,\n+ \"This hook is used to check whether target platform supports macro fusion.\",\n+ bool, (void), NULL)\n+\n+DEFHOOK\n+(macro_fusion_pair_p,\n+ \"This hook is used to check whether two insns could be macro fused for\\n\\\n+target microarchitecture. If this hook returns true for the given insn pair\\n\\\n+(@var{condgen} and @var{condjmp}), scheduler will put them into a sched\\n\\\n+group, and they will not be scheduled apart.\",\n+ bool, (rtx condgen, rtx condjmp), NULL)\n+\n /* The following member value is a pointer to a function called\n    after evaluation forward dependencies of insns in chain given\n    by two parameter values (head and tail correspondingly).  */"}]}