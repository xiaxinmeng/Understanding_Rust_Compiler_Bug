{"sha": "1e6869a54e6d237a870ba343044758fb98a11c33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU2ODY5YTU0ZTZkMjM3YTg3MGJhMzQzMDQ0NzU4ZmI5OGExMWMzMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-03-04T23:42:46Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-03-04T23:42:46Z"}, "message": "(FUNCTION_PROFILER): Emit label references corresponding to those generated by ASM_OUTPUT_INTERNAL_LABEL.\n\n(FUNCTION_PROFILER): Emit label references corresponding to those generated\nby ASM_OUTPUT_INTERNAL_LABEL.\n(MOTOROLA, MOTOROLA_BSR, ...): Define #ifndef USE_GAS.\n(ASM_SPEC): Define properly #ifdef USE_GAS.\n(LIB_SPEC): -L/usr/lib/libp deleted.\n(STARTFILE_SPEC): -L/usr/lib/libp added.\n(DEFAULT_A_OUT_NAME): Define.\n(LINK_SPEC): Pass -v if GNU ld is used.\n(LOCAL_LABEL_PREFIX): Local labels start with .L using GAS, else L%.\n(USER_LABEL_PREFIX): Undefine.\n(FUNCTION_PROFILER): Call asm_fprintf instead of normal fprintf.\n(ASM_APP_ON, ASM_FILE_START): GAS supports it.\n(CTORS_.../DTORS_...): Define if GNU ld is used.\n(ASM_FILE_START): Define properly for Motorola and GNU as syntax.\n(TARGET_VERSION): Re-define only #ifndef USE_GAS.\n(CALL_USED_REGISTERS): Deleted.\n(GLOBAL_ASM_OP): Re-define only #ifndef USE_GAS.\n(ASM_{LONG,SHORT,CHAR,BYTE,BYTE_OP}): New macros.\n(ASM_OUTPUT_{DOUBLE,LONG_DOUBLE,FLOAT,INT,SHORT}): Use them.\n(ASM_OUTPUT_{CHAR,BYTE,ASCII,FLOAT_OPERAND,DOUBLE_OPERAND}): Likewise.\n(ALIGN_ASM_OP, SKIP_ASM_OP): New macros.\n(ASM_OUTPUT_{ALIGN,SKIP}): Use them.\n(ASM_OUTPUT_SOURCE_FILENAME): Define only if not using GNU as.\n(ASM_{GENERATE,OUTPUT}_INTERAL_LABEL): Provide proper definitions for\nMotorola and GNU as syntax.\n(ASM_OUTPUT_ADDR_{VEC,DIFF}_ELT): Changed for portability between\nMotorola and GNU as syntax.\n(ASM_OUTPUT_{CASE_LABEL,OPCODE}): Define only if not using GNU as.\n(ASM_OUTPUT_CASE_FETCH, ASM_RETURN_CASE_JUMP): New macros.\n(ASM_OUTPUT_{COMMON,LOCAL}): Proper defns for Motorola and gas syntax.\n(SDB_...): Define only for Motorola as.\n(ALT_LIBM): New define to tell g++.c about an alternative name for `-lm'.\n(MATH_LIBRARY, NEED_ATEXIT, HAVE_ATEXIT, EXIT_BODY): New macros.\n\nFrom-SVN: r11428", "tree": {"sha": "488140d1342f07b3b3f926c00f3148d15850a354", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/488140d1342f07b3b3f926c00f3148d15850a354"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e6869a54e6d237a870ba343044758fb98a11c33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e6869a54e6d237a870ba343044758fb98a11c33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e6869a54e6d237a870ba343044758fb98a11c33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e6869a54e6d237a870ba343044758fb98a11c33/comments", "author": null, "committer": null, "parents": [{"sha": "3f889ae8a923505f2ae8da6a30ec153582ca6d5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f889ae8a923505f2ae8da6a30ec153582ca6d5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f889ae8a923505f2ae8da6a30ec153582ca6d5b"}], "stats": {"total": 272, "additions": 243, "deletions": 29}, "files": [{"sha": "8637c6d57628087bb82ff4b96b9665868c91270e", "filename": "gcc/config/m68k/mot3300.h", "status": "modified", "additions": 243, "deletions": 29, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6869a54e6d237a870ba343044758fb98a11c33/gcc%2Fconfig%2Fm68k%2Fmot3300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6869a54e6d237a870ba343044758fb98a11c33/gcc%2Fconfig%2Fm68k%2Fmot3300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fmot3300.h?ref=1e6869a54e6d237a870ba343044758fb98a11c33", "patch": "@@ -1,9 +1,11 @@\n /* Definitions of target machine for GNU compiler,\n    SysV68 Motorola 3300 Delta Series.\n-   Copyright (C) 1987, 1993, 1994, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.\n    Contributed by Abramo and Roberto Bagnara (bagnara@dipisa.di.unipi.it)\n    based on Alex Crain's 3B1 definitions.\n    Maintained by Philippe De Muyter (phdm@info.ucl.ac.be).\n+   Support for GAS added by merging mot3300g.h into this file by\n+   Manfred Hollstein (manfred@lts.sel.alcatel.de).\n \n This file is part of GNU CC.\n \n@@ -22,11 +24,13 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#ifndef USE_GAS\n #define MOTOROLA\t\t/* Use Motorola syntax rather than \"MIT\" */\n #define MOTOROLA_BSR\t\t/* Use Span-dependent optimized bsr */\n #define SGS\t\t\t/* Uses SGS assembler */\n #define SGS_CMP_ORDER\t\t/* Takes cmp operands in reverse order */\n #define SGS_SWAP_W\t\t/* Use swap.w rather than just plain swap */\n+#endif /* USE_GAS */\n \n #define NO_DOLLAR_IN_LABEL\n #define NO_DOT_IN_LABEL\n@@ -42,7 +46,12 @@ Boston, MA 02111-1307, USA.  */\n /* -m[c]6800 requires special flag to the assembler.  */\n \n #undef ASM_SPEC\n+#ifndef USE_GAS\n #define ASM_SPEC \"%{m68000:-p 000}%{mc68000:-p 000}\"\n+#else /* USE_GAS */\n+#define ASM_SPEC \\\n+  \"%{v:-v} %{m68000:-mc68000}%{mc68000:-mc68000}%{!mc68000:%{!m68000:-mc68020}}\"\n+#endif /* USE_GAS */\n \n /* NYI: FP= is equivalent to -msoft-float  */\n \n@@ -52,16 +61,32 @@ Boston, MA 02111-1307, USA.  */\n /* NYI: if FP= library is -lc.  */\n /* Default for us: FP=M68881 library is -lc881  */\n #undef LIB_SPEC\n-#define LIB_SPEC \"%{!shlib:%{p:-L/usr/lib/libp} %{pg:-L/usr/lib/libp} -lc881}\"\n+#define LIB_SPEC \"%{!shlib:%{!msoft-float:-lc881}%{msoft-float:-lc}}\"\n+#ifdef CROSS_COMPILE\n+#ifndef USE_GLD\n+#define DEFAULT_A_OUT_NAME \"m68ka.out\"\n+#endif\n+#endif\n+\n+#ifdef USE_GLD\n+#undef LINK_SPEC\n+#define LINK_SPEC \"%{v:-v}\"\n+#endif /* defined (USE_GLD) */\n \n #define CPP_SPEC \"%{!msoft-float:-D__HAVE_68881__}\"\n \n /* Shared libraries need to use crt0s.o  */\n \n #undef STARTFILE_SPEC\n+#ifdef CROSS_COMPILE\n #define STARTFILE_SPEC \\\n   \"%{!shlib:%{pg:mcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}}\\\n-   %{shlib:crt0s.o%s shlib.ifile%s} \"\n+   %{shlib:crt0s.o%s shlib.ifile%s} %{p:-L\"TOOLDIR_BASE_PREFIX DEFAULT_TARGET_MACHINE\"/lib/libp} %{pg:-L\"TOOLDIR_BASE_PREFIX DEFAULT_TARGET_MACHINE\"/lib/libp} \"\n+#else /* CROSS_COMPILE */\n+#define STARTFILE_SPEC \\\n+  \"%{!shlib:%{pg:mcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}}\\\n+   %{shlib:crt0s.o%s shlib.ifile%s} %{p:-L/usr/lib/libp} %{pg:-L/usr/lib/libp} \"\n+#endif /* CROSS_COMPILE */\n \n /* Generate calls to memcpy, memcmp and memset.  */\n \n@@ -95,11 +120,15 @@ Boston, MA 02111-1307, USA.  */\n #undef REGISTER_PREFIX\n #define REGISTER_PREFIX \"%\"\n \n-#if 0\n #undef LOCAL_LABEL_PREFIX\n-#define LOCAL_LABEL_PREFIX \"~\"\n+#ifdef USE_GAS\n+#define LOCAL_LABEL_PREFIX \".L\"\n+#else\n+#define LOCAL_LABEL_PREFIX \"L%\"\n #endif\n \n+#undef USER_LABEL_PREFIX\n+\n #undef IMMEDIATE_PREFIX\n #define IMMEDIATE_PREFIX \"&\"\n \n@@ -117,8 +146,13 @@ Boston, MA 02111-1307, USA.  */\n       asm_fprintf (FILE, \"\\tmov.l %Ra0,%Rd0\\n\"); } \n \n #undef FUNCTION_PROFILER\n+#ifndef USE_GAS\n+#define FUNCTION_PROFILER(FILE, LABEL_NO)\t\\\n+    asm_fprintf (FILE, \"\\tmov.l %ILP%%%d,%Ra0\\n\\tjsr mcount%%\\n\", (LABEL_NO))\n+#else /* USE_GAS */\n #define FUNCTION_PROFILER(FILE, LABEL_NO)\t\\\n-    fprintf (FILE, \"\\tmov.l &LP%%%d,%%a0\\n\\tjsr mcount%%\\n\", (LABEL_NO))\n+    asm_fprintf (FILE, \"\\tmov.l %I%.LP%d,%Ra0\\n\\tjsr mcount%%\\n\", (LABEL_NO))\n+#endif /* USE_GAS */\n \n /* This is how to output an insn to push a register on the stack.\n    It need not be very fast code.  */\n@@ -134,6 +168,8 @@ Boston, MA 02111-1307, USA.  */\n #define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n   fprintf (FILE, \"\\tmov.l (%%sp)+,%s\\n\", reg_names[REGNO])\n \n+#ifndef USE_GAS\n+\n #undef ASM_APP_ON\n #define ASM_APP_ON \"\"\n \n@@ -147,11 +183,83 @@ Boston, MA 02111-1307, USA.  */\n #undef ASCII_DATA_ASM_OP\n #define\tASCII_DATA_ASM_OP \"byte\"\n \n+#endif /* USE_GAS */\n+\n+#ifdef USE_GLD\n+/* Support the ctors and dtors sections for g++.  */\n+\n+#define CTORS_SECTION_ASM_OP\t\".section\\t.ctors,\\\"x\\\"\"\n+#define DTORS_SECTION_ASM_OP\t\".section\\t.dtors,\\\"x\\\"\"\n+\n+/* A list of other sections which the compiler might be \"in\" at any\n+   given time.  */\n+\n+#undef EXTRA_SECTIONS\n+#define EXTRA_SECTIONS in_ctors, in_dtors\n+\n+/* A list of extra section function definitions.  */\n+\n+#undef EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n+  CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  DTORS_SECTION_FUNCTION\n+\n+#define CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+ctors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_ctors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_ctors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define DTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+dtors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_dtors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_dtors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global constructors.  */\n+#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    ctors_section ();\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", ASM_LONG);\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global destructors.  */\n+#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)       \t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    dtors_section ();                   \t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", ASM_LONG);\t\t\t\t\\\n+    assemble_name (FILE, NAME);              \t\t\t\t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+  } while (0)\n+#endif /* defined (USE_GLD) */\n+\n /* The file command should always begin the output.  */\n \n #undef ASM_FILE_START\n+#ifndef USE_GAS\n #define ASM_FILE_START(FILE) \\\n-output_file_directive ((FILE), main_input_filename)\n+  output_file_directive ((FILE), main_input_filename)\n+#else /* USE_GAS */\n+#define ASM_FILE_START(FILE) \\\n+    { \\\n+       fprintf (FILE, \"%s\", ASM_APP_OFF); \\\n+       output_file_directive ((FILE), main_input_filename); \\\n+    }\n+#endif /* USE_GAS */\n \n /* The sysV68 assembler does not accept dots in labels.\n    Let's use percent instead  */\n@@ -166,15 +274,9 @@ output_file_directive ((FILE), main_input_filename)\n #define CPP_PREDEFINES \"-Dm68k -Dunix -DsysV68 -D__motorola__ -Asystem(unix) -Asystem(svr3) -Acpu(m68k) -Amachine(m68k)\"\n \n #undef TARGET_VERSION\n+#ifndef USE_GAS\n #define TARGET_VERSION fprintf (stderr, \" (68k, SGS/AT&T sysV68 syntax)\");\n-\n-/* Function calls save all but a0, a1, d0, d1, fp0, fp1.  */\n-\n-#undef CALL_USED_REGISTERS\n-#define CALL_USED_REGISTERS\t\t\t\t\t\t\\\n- {1, 1, 0, 0, 0, 0, 0, 0,\t\t\t\t\t\t\\\n-  1, 1, 0, 0, 0, 0, 0, 1,\t\t\t\t\t\t\\\n-  1, 1, 0, 0, 0, 0, 0, 0}\n+#endif /* USE_GAS */\n \n /* This will return small structs in d0.  */\n #define RETURN_IN_MEMORY(type) \\\n@@ -223,11 +325,13 @@ output_file_directive ((FILE), main_input_filename)\n #undef NEEDS_UNTYPED_CALL\n #define NEEDS_UNTYPED_CALL 1\n  \n+#ifndef USE_GAS\n /* This is the command to make the user-level label named NAME\n    defined for reference from other files.  */\n \n #undef GLOBAL_ASM_OP\n #define GLOBAL_ASM_OP \"global\"\n+#endif /* USE_GAS */\n \n /* Store in OUTPUT a string (made with alloca) containing\n    an assembler-name for a local static variable named NAME.\n@@ -238,21 +342,45 @@ output_file_directive ((FILE), main_input_filename)\n ( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 12),\t\\\n   sprintf ((OUTPUT), \"%s_%%%d\", (NAME), (LABELNO)))\n \n+#ifdef USE_GAS\n+#undef ASM_LONG\n+#define ASM_LONG\t\".long\"\n+#undef ASM_SHORT\n+#define ASM_SHORT\t\".short\"\n+#undef ASM_CHAR\n+#define ASM_CHAR\t\".byte\"\n+#undef ASM_BYTE\n+#define ASM_BYTE\t\".byte\"\n+#undef ASM_BYTE_OP\n+#define ASM_BYTE_OP\t\"\\t.byte\"\n+#else\n+#undef ASM_LONG\n+#define ASM_LONG\t\"long\"\n+#undef ASM_SHORT\n+#define ASM_SHORT\t\"short\"\n+#undef ASM_CHAR\n+#define ASM_CHAR\t\"byte\"\n+#undef ASM_BYTE\n+#define ASM_BYTE\t\"byte\"\n+#undef ASM_BYTE_OP\n+#define ASM_BYTE_OP\t\"\\tbyte\"\n+#endif /* USE_GAS */\n+\n /* The sysV68 as doesn't know about double's and float's.  */\n /* This is how to output an assembler line defining a `double' constant.  */\n \n #undef ASM_OUTPUT_DOUBLE\n #define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n do { long l[2];\t\t\t\t\t\t\\\n      REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\\\n-     fprintf (FILE, \"\\tlong 0x%x,0x%x\\n\", l[0], l[1]); \\\n+     fprintf (FILE, \"\\t%s 0x%x,0x%x\\n\", ASM_LONG, l[0], l[1]); \\\n    } while (0)\n \n #undef ASM_OUTPUT_LONG_DOUBLE\n #define ASM_OUTPUT_LONG_DOUBLE(FILE,VALUE)  \t\t\t\t\\\n do { long l[3];\t\t\t\t\t\t\t\t\\\n      REAL_VALUE_TO_TARGET_LONG_DOUBLE (VALUE, l);\t\t\t\\\n-     fprintf (FILE, \"\\tlong 0x%x,0x%x,0x%x\\n\", l[0], l[1], l[2]);\t\\\n+     fprintf (FILE, \"\\t%s 0x%x,0x%x,0x%x\\n\", ASM_LONG, l[0], l[1], l[2]);\t\\\n    } while (0)\n \n /* This is how to output an assembler line defining a `float' constant.  */\n@@ -261,59 +389,74 @@ do { long l[3];\t\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n do { long l;\t\t\t\t\t\\\n      REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\\\n-     fprintf ((FILE), \"\\tlong 0x%x\\n\", l);\t\\\n+     fprintf ((FILE), \"\\t%s 0x%x\\n\", ASM_LONG, l);\t\\\n    } while (0)\n \n /* This is how to output an assembler line defining an `int' constant.  */\n \n #undef ASM_OUTPUT_INT\n #define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\tlong \"),\t\t\t\\\n+( fprintf (FILE, \"\\t%s \", ASM_LONG),\t\t\\\n   output_addr_const (FILE, (VALUE)),\t\t\\\n   fprintf (FILE, \"\\n\"))\n \n /* Likewise for `char' and `short' constants.  */\n \n #undef ASM_OUTPUT_SHORT\n #define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\tshort \"),\t\t\t\\\n+( fprintf (FILE, \"\\t%s \", ASM_SHORT),\t\t\\\n   output_addr_const (FILE, (VALUE)),\t\t\\\n   fprintf (FILE, \"\\n\"))\n \n #undef ASM_OUTPUT_CHAR\n #define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\tbyte \"),\t\t\t\\\n+( fprintf (FILE, \"\\t%s \", ASM_CHAR),\t\t\\\n   output_addr_const (FILE, (VALUE)),\t\t\\\n   fprintf (FILE, \"\\n\"))\n \n /* This is how to output an assembler line for a numeric constant byte.  */\n \n #undef ASM_OUTPUT_BYTE\n #define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\tbyte 0x%x\\n\", (VALUE))\n+  fprintf (FILE, \"\\t%s 0x%x\\n\", ASM_BYTE, (VALUE))\n \n /* This is how to output an assembler line\n    that says to advance the location counter\n    to a multiple of 2**LOG bytes.  */\n \n+#ifndef USE_GAS\n+#define ALIGN_ASM_OP\t\"even\"\n+#else /* USE_GAS */\n+#define ALIGN_ASM_OP\t\".even\"\n+#endif /* USE_GAS */\n+\n #undef ASM_OUTPUT_ALIGN\n #define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n   if ((LOG) == 1)\t\t\t\\\n-    fprintf (FILE, \"\\teven\\n\");\t\t\\\n+    fprintf (FILE, \"\\t%s\\n\", ALIGN_ASM_OP);\t\\\n   else if ((LOG) != 0)\t\t\t\\\n     abort ();\n \n+#ifndef USE_GAS\n+#define SKIP_ASM_OP\t\"space\"\n+#else /* USE_GAS */\n+#define SKIP_ASM_OP\t\".skip\"\n+#endif /* USE_GAS */\n+\n #undef ASM_OUTPUT_SKIP\n #define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n-  fprintf (FILE, \"\\tspace %u\\n\", (SIZE))\n+  fprintf (FILE, \"\\t%s %u\\n\", SKIP_ASM_OP, (SIZE))\n \n /* Can't use ASM_OUTPUT_SKIP in text section.  */\n \n #define ASM_NO_SKIP_IN_TEXT 1\n \n /* The beginnings of sdb support...  */\n \n-#undef ASM_OUTPUT_SOURCE_FILENAME\n+/* Undefining these will allow `output_file_directive' (in toplev.c)\n+   to default to the right thing. */\n+#undef ASM_OUTPUT_MAIN_SOURCE_FILENAME\n+#ifndef USE_GAS\n #define ASM_OUTPUT_SOURCE_FILENAME(FILE, FILENAME) \\\n   do {\tfprintf (FILE, \"\\tfile\\t\");\t\t\\\n \toutput_quoted_string (FILE, FILENAME);\t\\\n@@ -331,7 +474,7 @@ do { long l;\t\t\t\t\t\\\n #undef ASM_OUTPUT_ASCII\n #define ASM_OUTPUT_ASCII(FILE,PTR,LEN) \\\n   do { register int sp = 0, lp = 0;\t\t\t\t\\\n-    fprintf ((FILE), \"\\tbyte\\t\");\t\t\t\t\\\n+    fprintf ((FILE), \"%s\\t\", ASM_BYTE_OP);\t\t\t\\\n   loop:\t\t\t\t\t\t\t\t\\\n     if ((PTR)[sp] > ' ' && ! ((PTR)[sp] & 0x80) && (PTR)[sp] != '\\\\')\t\\\n       { lp += 3;\t\t\t\t\t\t\\\n@@ -347,7 +490,9 @@ do { long l;\t\t\t\t\t\\\n \t  putc (',', (FILE));\t\t\t\t\t\\\n \tgoto loop; }\t\t\t\t\t\t\\\n     putc ('\\n', (FILE)); } while (0)\n+#endif /* USE_GAS */\n \n+#ifndef USE_GAS\n /* Output a float value (represented as a C double) as an immediate operand.\n    This macro is a 68k-specific macro.  */\n \n@@ -367,22 +512,33 @@ do { long l;\t\t\t\t\t\\\n       REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\t\t\\\n       fprintf ((FILE), \"&0x%lx%08lx\", l[0], l[1]);\t\t\t\\\n     } while (0)\n+#endif /* USE_GAS */\n \n /* This is how to store into the string LABEL\n    the symbol_ref name of an internal numbered label where\n    PREFIX is the class of label and NUM is the number within the class.\n    This is suitable for output with `assemble_name'.  */\n \n #undef ASM_GENERATE_INTERNAL_LABEL\n+#ifndef USE_GAS\n #define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\\\n   sprintf ((LABEL), \"%s%%%d\", (PREFIX), (NUM))\n+#else /* USE_GAS */\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\\\n+  sprintf ((LABEL), \".%s%d\", (PREFIX), (NUM))\n+#endif /* USE_GAS */\n \n /* This is how to output an internal numbered label where\n    PREFIX is the class of label and NUM is the number within the class.  */\n \n #undef ASM_OUTPUT_INTERNAL_LABEL\n+#ifndef USE_GAS\n #define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n     fprintf (FILE, \"%s%%%d:\\n\", PREFIX, NUM)\n+#else /* USE_GAS */\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+    fprintf (FILE, \".%s%d:\\n\", PREFIX, NUM)\n+#endif /* USE_GAS */\n \n /* This is how to output a reference to a user-level label named NAME.\n    `assemble_name' uses this.  */\n@@ -397,13 +553,15 @@ do { long l;\t\t\t\t\t\\\n \n #undef ASM_OUTPUT_ADDR_VEC_ELT\n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)\t\\\n-    fprintf (FILE, \"\\tlong L%%%d\\n\", (VALUE))\n+    asm_fprintf (FILE, \"\\t%s %L%d\\n\", ASM_LONG, (VALUE))\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n #undef ASM_OUTPUT_ADDR_DIFF_ELT\n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)\t\\\n-    fprintf (FILE, \"\\tshort L%%%d-L%%%d\\n\", (VALUE), (REL))\n+    asm_fprintf (FILE, \"\\t%s %L%d-%L%d\\n\", ASM_SHORT, (VALUE), (REL))\n+\n+#ifndef USE_GAS\n \n #define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,TABLE)\t\t\t\\\n     fprintf (FILE, \"\\tswbeg &%d\\n%s%%%d:\\n\",\t\t\t\t\\\n@@ -418,6 +576,18 @@ do { long l;\t\t\t\t\t\\\n \n #define ASM_RETURN_CASE_JUMP   return \"jmp 8(%%pc,%0.w)\"\n \t     \n+#else /* USE_GAS */\n+\n+/* labelno is not used here */\n+#define ASM_OUTPUT_CASE_FETCH(file, labelno, regname)\\\n+\tasm_fprintf (file, \"%Rpc@(6,%s:\", regname)\n+\n+#define ASM_RETURN_CASE_JUMP return \"jmp %%pc@(2,%0:w)\"\n+\n+#endif /* USE_GAS */\n+\n+#ifndef USE_GAS\n+\n /* Translate some opcodes to fit the sysV68 assembler syntax.  */\n /* The opcodes fdmov and fsmov are guesses.  */\n \n@@ -474,28 +644,43 @@ do { long l;\t\t\t\t\t\\\n        if ((PTR)[0] == 'a' || (PTR)[0] == 'i'\t \t\\\n \t   || (PTR)[0] == 'm') (PTR)++; }\t\t\\\n }\n+#endif /* USE_GAS */\n \n /* phdm@info.ucl.ac.be says to pass SIZE, not ROUNDED.  */\n \n /* This says how to output an assembler line\n    to define a global common symbol.  */\n \n #undef ASM_OUTPUT_COMMON\n+#ifndef USE_GAS\n #define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n ( fputs (\"\\tcomm \", (FILE)),\t\t\t\\\n   assemble_name ((FILE), (NAME)),\t\t\\\n   fprintf ((FILE), \",%u\\n\", (SIZE)))\n+#else /* USE_GAS */\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\"\\t.comm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (SIZE)))\n+#endif /* USE_GAS */\n \n /* This says how to output an assembler line\n    to define a local common symbol.  */\n \n #undef ASM_OUTPUT_LOCAL\n+#ifndef USE_GAS\n #define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n ( fputs (\"\\tlcomm \", (FILE)),\t\t\t\\\n   assemble_name ((FILE), (NAME)),\t\t\\\n   fprintf ((FILE), \",%u\\n\", (SIZE)))\n+#else /* USE_GAS */\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\"\\t.lcomm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (SIZE)))\n+#endif /* USE_GAS */\n \n-\f\n+#ifndef USE_GAS\n /* Override usual definitions of SDB output macros.\n    These definitions differ only in the absence of the period\n    at the beginning of the name of the directive\n@@ -554,6 +739,8 @@ do { fprintf (asm_out_file, \"\\ttag\\t\");\t\\\n #define SDB_GENERATE_FAKE(BUFFER, NUMBER) \\\n   sprintf ((BUFFER), \"~%dfake\", (NUMBER));\n \n+#endif /* USE_GAS */\n+\n /* Define subroutines to call to handle multiply, divide, and remainder.\n    Use the subroutines that the sysV68's library provides.\n    The `*' prevents an underscore from being prepended by the compiler.  */\n@@ -600,3 +787,30 @@ do {(CUM).offset = 0;\\\n \n #undef FUNCTION_ARG_REGNO_P\n #define FUNCTION_ARG_REGNO_P(N) (TARGET_68020 ? 0 : (N) == 0)\n+\n+/* manfred@lts.sel.alcatel.de: I believe that most delta machines are configured to have\n+   a 6888[12] FPU for which we need to link -lm881 instead of -lm; define ALT_LIBM to\n+   tell g++.c about that.  */\n+#define ALT_LIBM\t\"-lm881\"\n+\n+#if (TARGET_DEFAULT & 2)      /* The default configuration has a 6888[12] FPU. */\n+#define MATH_LIBRARY\t\"-lm881\"\n+#endif\n+\n+/* Currently we do not have the atexit() function;\n+ *  so take that from libgcc2.c\n+ */\n+\n+#define NEED_ATEXIT 1\n+#define HAVE_ATEXIT 1\n+\n+#define EXIT_BODY\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    { extern void monitor ();\t\t\t\t\t\\\n+      extern long mcount asm (\"mcount%\");\t\t\t\\\n+      extern long etext;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+      if (&mcount < &etext)\t\t\t\t\t\\\n+\tmonitor (0);\t\t\t\t\t\t\\\n+      _cleanup ();\t\t\t\t\t\t\\\n+    } while (0)"}]}