{"sha": "1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY4ZjRhMGIzMWM2ODdjZTljZmI3ZmI3NmMwZjFlMDI0NjBhOGRlZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-10-13T06:26:46Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-10-13T06:26:46Z"}, "message": "Remove obstacks.\n\n\t* Makefile.in (ggc-callbacks.o): Remove target.\n\t(flow.o): Depend on GGC_H.\n\t* alias.c (init_alias_analysis):\n\tRemove ggc_p conditionals.\n\t(end_alias_analysis): Likewise.\n\t* basic-block.h (init_flow): New function.\n\t(allocate_reg_life_data): Declare.\n\t* bb-reorder.c\t(function_obstack): Replace with ...\n\t(flow_obstack): ... new variable.\n\t(fixup_reorder_chain): Use it.\n\t* c-decl.c (ggc_p): Remove.\n\t(caller-save.c): Don't call oballoc/obfree.\n\t* combine.c (struct\n\tundobuf): Remove storage.\n\t(try_combine): Don't call oballoc.\n\t(undo_all): Don't call obfree.\n\t* cse.c (insert): Use xmalloc, not\n\toballoc.\n\t(cse_main): Adjust accordingly.\n\t* dwarf2out.c (save_rtx): Remove\n\tobstack code.\n\t(dwarf2out_init): Remove ggc_p conditionals.\n\t* emit-rtl.c (rtl_obstack): Remove.\n\t(gen_rtx_CONST_INT): Remove ggc_p conditionals.\n\t(make_insn_raw): Likewise.\n\t(emit_insn_before): Likewise.\n\t(emit_insn_after): Likewise.\n\t(emit_insn): Likewise.\n\t(gen_sequence): Likewise.\n\t(copy_insn_1): Remove handling of `b' RTL components.\n\t(init_emit_once): Remove ggc_p conditionals.\n\t* except.c (create_rethrow_ref): Don't fool with obstacks.\n\t(add_partial_entry): Likewise.\n\t(call_get_eh_context): Likewise.\n\t(begin_protect_partials): Likewise.\n\t(protect_with_terminate): Likewise.\n\t* explow.c\n\t(plus_constant_wide): Likewise.\n\t* expr.c (init_expr_once):\n\tLikewise.\n\t(emit_block_move): Likewise.\n\t(clear_storage): Likewise.\n\t(expand_expr): Likewise.\n\t* flow.c (function_obstack): Remove.\n\t(flow_obstack): New variable.\n\t(flow_firstobj): Likewise.\n\t(create_base_block): Use the flow_obstack.\n\t(split_block): Likewise.\n\t(split_edge): Likewise.\n\t(calculate_global_regs_live): Likewise.\n\t(allocate_bb_life_data): Make it static.  Likewiwse.\n\t(init_flow): New function.\n\t(size_int_type_wide): Remove ggc_p conditionals.\n\t* function.c\n\t(push_function_context_to): Don't call save_tree_status.\n\t(pop_function_context_from): Or restore_tree_status.\n\t(assign_stack_local_1): Don't call push_obstacks.\n\t(find_fixup_replacement): Use xmalloc.\n\t(fixup_var_refs_insns): Free the storage.\n\t(insns_for_mem_walk): Don't mess with obstacks.\n\t(instantiate_decls): Likewise.\n\t(trampoline_address): Likewise.\n\t(expand_function_end): Likewise.\n\t* function.h (sturct function):\n\tRemove obstack-related variables.\n\t(save_tree_status): Don't declare.\n\t(restore_tree_status): Likewise.\n\t* gcse.c (compute_can_copy):\n\tDon't call oballoc/obfree.\n\t* genattrtab.c (operate_exp): Remove\n\tggc_p conditionals.\n\t(simplify_cond): Likewise.\n\t(simplify_test_exp): Don't mess with obstacks.\n\t(optimize_attrs): Likewise.\n\t* gengenrtl.c (gendef): Don't include\n\tggc_p conditionals.\n\t* ggc-callbacks.c (ggc_p): Remove.\n\t* ggc-none.c (ggc_p): Remove.\n\t* ggc.h (ggc_p): Don't declare.\n\t* integrate.c (save_for_inline): Don't mess with obstacks.\n\t(integrate_decl_tree): Likewise.\n\t(output_inline_function): Likewise.\n\t* lists.c\n\t(init_EXPR_INSN_LIST_cache): Likewise.\n\t* loop.c (temp_obstack):\n\tRemove.\n\t(rtl_obstack): Likewise.\n\t(init_loop): Don't mess with obstacks.\n\t(reg_address_cost): Free BIVs and GIVs.\n\t(check_insns_for_bivs): Use xmalloc, not oballoc.\n\t(find_mem_givs): Likewise.\n\t(record_biv): Likewise.\n\t(general_induction_var): Likewise.\n\t(product_cheap_p): Likewse.\n\t* optabs.c (init_one_libfunc): Remove\n\tggc_p conditional.\n\t* print-tree.c (debug_tree): Don't use\n\toballoc/obfree.\n\t(print_node): Likewise.\n\t* profile.c (output_func_start_profiler):\n\tRemove call to temporary_allocation.\n\t* reload1.c\n\t(eliminate_regs_in_insn): Don't mess with obstacks.\n\t* resource.c\n\t(mark_target_live_regs): Use xmalloc.\n\t(free_resource_info): Free the memory.\n\t* rtl.c (rtl_obstack):\n\tRemove.\n\t(rtvec_alloc): Don't mess with obstacks.\n\t(rtx_alloc): Likewise.\n\t(rtx_free): Remove.\n\t(copy_rtx): Don't handle `b' cases.\n\t(read_rtx): Use a local rtl_obstack.\n\t* rtl.h (oballoc): Remove.\n\t(obfree): Likewise.\n\t(pop_obstacks): Likewise.\n\t(push_obstacks): Likewise.\n\t(allocate_bb_life_data): Likewise.\n\t(allocate_reg_life_data): Likewise.\n\t(rtx_free): Likewise.\n\t* sdbout.c (sdbout_queue_anonymous_type):\n\tUse tree_cons, not saveable_tree_cons.\n\t* simplify-rtx.c\n\t(cselib_init): Don't mess with obstacks.\n\t* stmt.c\n\t(mark_block_nesting): Mark the label_chain.\n\t(epxand_label): Use ggc_alloc, not oballoc.\n\t(clear_last_expr): Don't mess with obstacks.\n\t(expand_decl_cleanup): Likewise.\n\t(expand_dcc_cleanup): Likewise.\n\t(expand_dhc_cleanup): Likewise.\n\t(expand_anon_union_decl): Likewise.\n\t(add_case_node): Use xmalloc, not oballoc.\n\t(free_case_nodes): New function.\n\t(expand_end_case): Call it.\n\t* stor-layout.c (layout_type): Don't\n\tmess with obstacks.\n\t(layout_type): Likewise.\n\t* toplev.c (wrapup_global_declarations):\n\tLikewise.\n\t(compile_file): Remove ggc_p conditionals.\n\t(rest_of_compilation): Call init_flow.  Remove ggc_p conditionals.\n\t(decode_f_option): Remove ggc_p conditionals.\n\t* tree.c\n\t(function_maybepermanent_obstack): Remove.\n\t(maybepermanent_obstack): Likewise.\n\t(function_obstack): Likewise.\n\t(tmeporary_obstack): Likewise.\n\t(momentary_obstack): Likewise.\n\t(temp_decl_obstack): Likewise.\n\t(saveable_obstack): Likewise.\n\t(rtl_obstack): Likewise.\n\t(current_obstack): Likewise.\n\t(expression_obstack): Likewise.\n\t(struct obstack_stack): Likewise.\n\t(obstack_stack): Likewise.\n\t(obstack_stack_obstack): Likewise.\n\t(maybepermanent_firstobj): Likewise.\n\t(temporary_firstobj): Likewise.\n\t(momentary_firstobj): Likewise.\n\t(temp_decl_firstobj): Likewise.\n\t(momentary_function_firstobj): Likewise.\n\t(all_types_permanent): Likewise.\n\t(struct momentary_level): Likewise.\n\t(momentary_stack): Likewise.\n\t(init_obstacks): Remove initialization of removed obstacks.\n\t(save_tree_status): Remove.\n\t(restore_tree_status): Likewise.\n\t(temporary_allocation): Liekwise.\n\t(end_temporary_allocation): Liekwise.\n\t(resume_temporary_allocation): Likewise.\n\t(saveable_allocation): Likewise.\n\t(push_obstacks): Likewise.\n\t(push_obstacks_nochange): Likewise.\n\t(pop_obstacks): Likewise.\n\t(allocation_temporary_p): Likewise.\n\t(permanent_allocation): Likewise.\n\t(preserve_data): Likewise.\n\t(preserve_initializer): Likewise.\n\t(rtl_in_current_obstack): Likewise.\n\t(rtl_in_saveable_obstack): Likewise.\n\t(oballoc): Likewise.\n\t(obfree): Likewise.\n\t(savealloc): Likewise.\n\t(expralloc): Likewise.\n\t(print_obstack_name): Likewise.\n\t(debug_obstack): Likewise.\n\t(object_permanent_p): Likewise.\n\t(push_momentary): Likewise.\n\t(perserve_momentary): Likewise.\n\t(clear_momentary): Likewise.\n\t(pop_momentary): Likewise.\n\t(pop_momentary_nofree): Likewise.\n\t(suspend_momentary): Likewise.\n\t(resume_momentary): Likewise.\n\t(make_node): Don't set TREE_PERMANENT.\n\t(copy_node): Remove ggc_p conditionals.  Don't set TYPE_OBSTACK.\n\tDon't set TREE_PERMANENT.\n\t(get_identifier): Remove ggc_p conditionals.\n\t(build_string): Likewise.\n\t(make_tree_vec): Likewise.\n\t(build_decl_list): Remove.\n\t(build_expr_list): Likewise.\n\t(tree_cons): Remove ggc_p conditionals.\n\t(decl_tree_cons): Remove.\n\t(expr_tree_cons): Likewise.\n\t(perm_tree_cons): Likewise.\n\t(temp_tree_cons): Likewise.\n\t(saveable_tree_cons): Likewise.\n\t(build1): Remove ggc_p conditionals.\n\t(build_parse_node): Likewise.\n\t(build_type_attribute_variant): Don't mess with obstacks.\n\t(build_type_copy): Likewise.\n\t(type_hash_canon): Likewise.\n\t(build_pointer_type): Likewise.\n\t(build_reference_type): Likewise.\n\t(build_index_type): Likewise.\n\t(build_range_type): Likewise.\n\t(dump_tree_statistics): Don't print obstack information.\n\t* tree.h\n\t(struct tree_common): Remove permanent_flag.\n\t(TREE_PERMANENT): Remove.\n\t(TREE_SET_PERMANENT): Likewise.\n\t(TYPE_OBSTACK): Likewise.\n\t(struct tree_type): Remove obstack.\n\t(oballoc): Remove.\n\t(savealloc): Likewise.\n\t(build_decl_list): Likewise.\n\t(build_expr_list): Likewise.\n\t(perm_tree_cons): Likewise.\n\t(temp_tree_cons): Likewise.\n\t(saveable_tree_cons): Likewise.\n\t(decl_tree_cons): Likewise.\n\t(expr_tree_cons): Likewise.\n\t(suspend_momentary): Likewise.\n\t(allocation_temporary_p): Likewise.\n\t(resume_momentary): Likewise.\n\t(push_obstacks_nochange): Likewise.\n\t(permanent_allocation): Likewise.\n\t(push_momentary): Likewise.\n\t(clear_momentary): Likewise.\n\t(pop_momentary): Likewise.\n\t(end_temporary_allocation): Likewise.\n\t(pop_obstacks): Likewise.\n\t(push_obstacks): Likewise.\n\t(pop_momentary_nofree): LIkewise.\n\t(preserve_momentary): Likewise.\n\t(saveable_allocation): Likewise.\n\t(temporary_allocation): Likewise.\n\t(resume_temporary_allocation): Likewise.\n\t(perserve_initializer): Likewise.\n\t(debug_obstack): Likewise.\n\t(rtl_in_current_obstack): Likewise.\n\t(rtl_in_saveable_obstack): Likewise.\n\t(obfree): Likewise.\n\t* varasm.c (current_obstack): Remove.\n\t(saveable_obstack): Remove.\n\t(rtl_obstack): Remove.\n\t(immed_double_const): Don't mess with obstacks.\n\t(immed_real_cons): Likewise.\n\t(output_constant_def): Likewise.\n\t(init_varasm_status): Use xcalloc.\n\t(mark_pool_constant): Mark the pool constant itself.\n\t(free_varasm_status): Free memory.\n\t(decode_rtx_const): Call bzero directly, rather than expanding it\n\tinline.\n\t(record_rtx_const): Don't mess with obstacks.\n\t(force_const_mem): Likewise.\n\t* config/arm/arm.c (arm_encode_call_attribute): Remove ggc_p\n\tconditionals.\n\t(aof_pic_entry): Likewise.\n\t* config/ia64/ia64.c (ia64_encode_section_info): Likewise.\n\t* config/m32r/m32r.c (m32r_encode_section_info): Likewise.\n\t* config/pa/pa.c (saveable_obstack): Remove.\n\t(rtl_obstack): Likewise.\n\t(current_obstack): Likewise.\n\t(output_call): Don't mess with obstacks.\n\t(hppa_encode_label): Remove ggc_p conditionals.\n\t* config/romp/romp.c (get_symref): Don't mess with obstacks.\n\t* config/rs6000/rs6000.c (output_toc): Remove ggc_p conditional.\n\t(rs6000_encode_section_info): Likewise.\n\t* config/sh/sh.c (get_fpscr_rtx): Likewise.\n\nFrom-SVN: r36856", "tree": {"sha": "cd4e3b39aeeef559afdffecc5526c482b9b80b01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd4e3b39aeeef559afdffecc5526c482b9b80b01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/comments", "author": null, "committer": null, "parents": [{"sha": "c26f7a3165fa34de2f55291d33da8320ed3077e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c26f7a3165fa34de2f55291d33da8320ed3077e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c26f7a3165fa34de2f55291d33da8320ed3077e8"}], "stats": {"total": 2957, "additions": 836, "deletions": 2121}, "files": [{"sha": "c6779afb7b5b1c9e530aa60173e0a32f2e4f3f58", "filename": "gcc/ChangeLog", "status": "modified", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -1,3 +1,291 @@\n+2000-10-12  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tRemove obstacks.  \n+\t* Makefile.in (ggc-callbacks.o): Remove target.\n+\t(flow.o): Depend on GGC_H.  \n+\t* alias.c (init_alias_analysis):\n+\tRemove ggc_p conditionals.\n+\t(end_alias_analysis): Likewise.  \n+\t* basic-block.h (init_flow): New function.\n+\t(allocate_reg_life_data): Declare.  \n+\t* bb-reorder.c\t(function_obstack): Replace with ...\n+\t(flow_obstack): ... new variable.\n+\t(fixup_reorder_chain): Use it.  \n+\t* c-decl.c (ggc_p): Remove.\n+\t(caller-save.c): Don't call oballoc/obfree.  \n+\t* combine.c (struct\n+\tundobuf): Remove storage.\n+\t(try_combine): Don't call oballoc.\n+\t(undo_all): Don't call obfree.  \n+\t* cse.c (insert): Use xmalloc, not\n+\toballoc.\n+\t(cse_main): Adjust accordingly.  \n+\t* dwarf2out.c (save_rtx): Remove\n+\tobstack code.\n+\t(dwarf2out_init): Remove ggc_p conditionals.  \n+\t* emit-rtl.c (rtl_obstack): Remove.\n+\t(gen_rtx_CONST_INT): Remove ggc_p conditionals.\n+\t(make_insn_raw): Likewise.\n+\t(emit_insn_before): Likewise.\n+\t(emit_insn_after): Likewise.\n+\t(emit_insn): Likewise.\n+\t(gen_sequence): Likewise.\n+\t(copy_insn_1): Remove handling of `b' RTL components.\n+\t(init_emit_once): Remove ggc_p conditionals.  \n+\t* except.c (create_rethrow_ref): Don't fool with obstacks.\n+\t(add_partial_entry): Likewise.\n+\t(call_get_eh_context): Likewise.\n+\t(begin_protect_partials): Likewise.\n+\t(protect_with_terminate): Likewise.  \n+\t* explow.c\n+\t(plus_constant_wide): Likewise.  \n+\t* expr.c (init_expr_once):\n+\tLikewise.\n+\t(emit_block_move): Likewise.\n+\t(clear_storage): Likewise.\n+\t(expand_expr): Likewise.  \n+\t* flow.c (function_obstack): Remove.\n+\t(flow_obstack): New variable.\n+\t(flow_firstobj): Likewise.\n+\t(create_base_block): Use the flow_obstack.\n+\t(split_block): Likewise.\n+\t(split_edge): Likewise.\n+\t(calculate_global_regs_live): Likewise.\n+\t(allocate_bb_life_data): Make it static.  Likewiwse.\n+\t(init_flow): New function.\n+\t(size_int_type_wide): Remove ggc_p conditionals.  \n+\t* function.c\n+\t(push_function_context_to): Don't call save_tree_status.\n+\t(pop_function_context_from): Or restore_tree_status.\n+\t(assign_stack_local_1): Don't call push_obstacks.\n+\t(find_fixup_replacement): Use xmalloc.\n+\t(fixup_var_refs_insns): Free the storage.\n+\t(insns_for_mem_walk): Don't mess with obstacks.\n+\t(instantiate_decls): Likewise.\n+\t(trampoline_address): Likewise.\n+\t(expand_function_end): Likewise.  \n+\t* function.h (sturct function):\n+\tRemove obstack-related variables.\n+\t(save_tree_status): Don't declare.\n+\t(restore_tree_status): Likewise.  \n+\t* gcse.c (compute_can_copy):\n+\tDon't call oballoc/obfree.  \n+\t* genattrtab.c (operate_exp): Remove\n+\tggc_p conditionals.\n+\t(simplify_cond): Likewise.\n+\t(simplify_test_exp): Don't mess with obstacks.\n+\t(optimize_attrs): Likewise.  \n+\t* gengenrtl.c (gendef): Don't include\n+\tggc_p conditionals.  \n+\t* ggc-callbacks.c (ggc_p): Remove.  \n+\t*\n+\tggc-none.c (ggc_p): Remove.  \n+\t* ggc.h (ggc_p): Don't declare.  \n+\t*\n+\tintegrate.c (save_for_inline): Don't mess with obstacks.\n+\t(integrate_decl_tree): Likewise.\n+\t(output_inline_function): Likewise.  \n+\t* lists.c\n+\t(init_EXPR_INSN_LIST_cache): Likewise.  \n+\t* loop.c (temp_obstack):\n+\tRemove.\n+\t(rtl_obstack): Likewise.\n+\t(init_loop): Don't mess with obstacks.\n+\t(reg_address_cost): Free BIVs and GIVs.\n+\t(check_insns_for_bivs): Use xmalloc, not oballoc.\n+\t(find_mem_givs): Likewise.\n+\t(record_biv): Likewise.\n+\t(general_induction_var): Likewise.\n+\t(product_cheap_p): Likewse.  \n+\t* optabs.c (init_one_libfunc): Remove\n+\tggc_p conditional.  \n+\t* print-tree.c (debug_tree): Don't use\n+\toballoc/obfree.\n+\t(print_node): Likewise.  \n+\t* profile.c (output_func_start_profiler):\n+\tRemove call to temporary_allocation.  \n+\t* reload1.c\n+\t(eliminate_regs_in_insn): Don't mess with obstacks.  \n+\t* resource.c\n+\t(mark_target_live_regs): Use xmalloc.\n+\t(free_resource_info): Free the memory.  \n+\t* rtl.c (rtl_obstack):\n+\tRemove.\n+\t(rtvec_alloc): Don't mess with obstacks.\n+\t(rtx_alloc): Likewise.\n+\t(rtx_free): Remove.\n+\t(copy_rtx): Don't handle `b' cases.\n+\t(read_rtx): Use a local rtl_obstack.  \n+\t* rtl.h (oballoc): Remove.\n+\t(obfree): Likewise.\n+\t(pop_obstacks): Likewise.\n+\t(push_obstacks): Likewise.\n+\t(allocate_bb_life_data): Likewise.\n+\t(allocate_reg_life_data): Likewise.\n+\t(rtx_free): Likewise.  \n+\t* sdbout.c (sdbout_queue_anonymous_type):\n+\tUse tree_cons, not saveable_tree_cons.  \n+\t* simplify-rtx.c\n+\t(cselib_init): Don't mess with obstacks.  \n+\t* stmt.c\n+\t(mark_block_nesting): Mark the label_chain.\n+\t(epxand_label): Use ggc_alloc, not oballoc.\n+\t(clear_last_expr): Don't mess with obstacks.\n+\t(expand_decl_cleanup): Likewise.\n+\t(expand_dcc_cleanup): Likewise.\n+\t(expand_dhc_cleanup): Likewise.\n+\t(expand_anon_union_decl): Likewise.\n+\t(add_case_node): Use xmalloc, not oballoc.\n+\t(free_case_nodes): New function.\n+\t(expand_end_case): Call it.  \n+\t* stor-layout.c (layout_type): Don't\n+\tmess with obstacks.\n+\t(layout_type): Likewise.  \n+\t* toplev.c (wrapup_global_declarations):\n+\tLikewise.\n+\t(compile_file): Remove ggc_p conditionals.\n+\t(rest_of_compilation): Call init_flow.  Remove ggc_p conditionals.\n+\t(decode_f_option): Remove ggc_p conditionals.  \n+\t* tree.c\n+\t(function_maybepermanent_obstack): Remove.\n+\t(maybepermanent_obstack): Likewise.\n+\t(function_obstack): Likewise.\n+\t(tmeporary_obstack): Likewise.\n+\t(momentary_obstack): Likewise.\n+\t(temp_decl_obstack): Likewise.\n+\t(saveable_obstack): Likewise.\n+\t(rtl_obstack): Likewise.\n+\t(current_obstack): Likewise.\n+\t(expression_obstack): Likewise.\n+\t(struct obstack_stack): Likewise.\n+\t(obstack_stack): Likewise.\n+\t(obstack_stack_obstack): Likewise.\n+\t(maybepermanent_firstobj): Likewise.\n+\t(temporary_firstobj): Likewise.\n+\t(momentary_firstobj): Likewise.\n+\t(temp_decl_firstobj): Likewise.\n+\t(momentary_function_firstobj): Likewise.\n+\t(all_types_permanent): Likewise.\n+\t(struct momentary_level): Likewise.\n+\t(momentary_stack): Likewise.\n+\t(init_obstacks): Remove initialization of removed obstacks.\n+\t(save_tree_status): Remove.\n+\t(restore_tree_status): Likewise.\n+\t(temporary_allocation): Liekwise.\n+\t(end_temporary_allocation): Liekwise.\n+\t(resume_temporary_allocation): Likewise.\n+\t(saveable_allocation): Likewise.\n+\t(push_obstacks): Likewise.\n+\t(push_obstacks_nochange): Likewise.\n+\t(pop_obstacks): Likewise.\n+\t(allocation_temporary_p): Likewise.\n+\t(permanent_allocation): Likewise.\n+\t(preserve_data): Likewise.\n+\t(preserve_initializer): Likewise.\n+\t(rtl_in_current_obstack): Likewise.\n+\t(rtl_in_saveable_obstack): Likewise.\n+\t(oballoc): Likewise.\n+\t(obfree): Likewise.\n+\t(savealloc): Likewise.\n+\t(expralloc): Likewise.\n+\t(print_obstack_name): Likewise.\n+\t(debug_obstack): Likewise.\n+\t(object_permanent_p): Likewise.\n+\t(push_momentary): Likewise.\n+\t(perserve_momentary): Likewise.\n+\t(clear_momentary): Likewise.\n+\t(pop_momentary): Likewise.\n+\t(pop_momentary_nofree): Likewise.\n+\t(suspend_momentary): Likewise.\n+\t(resume_momentary): Likewise.\n+\t(make_node): Don't set TREE_PERMANENT.\n+\t(copy_node): Remove ggc_p conditionals.  Don't set TYPE_OBSTACK.\n+\tDon't set TREE_PERMANENT.\n+\t(get_identifier): Remove ggc_p conditionals.\n+\t(build_string): Likewise.\n+\t(make_tree_vec): Likewise.\n+\t(build_decl_list): Remove.\n+\t(build_expr_list): Likewise.\n+\t(tree_cons): Remove ggc_p conditionals.\n+\t(decl_tree_cons): Remove.\n+\t(expr_tree_cons): Likewise.\n+\t(perm_tree_cons): Likewise.\n+\t(temp_tree_cons): Likewise.\n+\t(saveable_tree_cons): Likewise.\n+\t(build1): Remove ggc_p conditionals.\n+\t(build_parse_node): Likewise.\n+\t(build_type_attribute_variant): Don't mess with obstacks.\n+\t(build_type_copy): Likewise.\n+\t(type_hash_canon): Likewise.\n+\t(build_pointer_type): Likewise.\n+\t(build_reference_type): Likewise.\n+\t(build_index_type): Likewise.\n+\t(build_range_type): Likewise.\n+\t(dump_tree_statistics): Don't print obstack information.  \n+\t* tree.h\n+\t(struct tree_common): Remove permanent_flag.\n+\t(TREE_PERMANENT): Remove.\n+\t(TREE_SET_PERMANENT): Likewise.\n+\t(TYPE_OBSTACK): Likewise.\n+\t(struct tree_type): Remove obstack.\n+\t(oballoc): Remove.\n+\t(savealloc): Likewise.\n+\t(build_decl_list): Likewise.\n+\t(build_expr_list): Likewise.\n+\t(perm_tree_cons): Likewise.\n+\t(temp_tree_cons): Likewise.\n+\t(saveable_tree_cons): Likewise.\n+\t(decl_tree_cons): Likewise.\n+\t(expr_tree_cons): Likewise.\n+\t(suspend_momentary): Likewise.\n+\t(allocation_temporary_p): Likewise.\n+\t(resume_momentary): Likewise.\n+\t(push_obstacks_nochange): Likewise.\n+\t(permanent_allocation): Likewise.\n+\t(push_momentary): Likewise.\n+\t(clear_momentary): Likewise.\n+\t(pop_momentary): Likewise.\n+\t(end_temporary_allocation): Likewise.\n+\t(pop_obstacks): Likewise.\n+\t(push_obstacks): Likewise.\n+\t(pop_momentary_nofree): LIkewise.\n+\t(preserve_momentary): Likewise.\n+\t(saveable_allocation): Likewise.\n+\t(temporary_allocation): Likewise.\n+\t(resume_temporary_allocation): Likewise.\n+\t(perserve_initializer): Likewise.\n+\t(debug_obstack): Likewise.\n+\t(rtl_in_current_obstack): Likewise.\n+\t(rtl_in_saveable_obstack): Likewise.\n+\t(obfree): Likewise.  \n+\t* varasm.c (current_obstack): Remove.\n+\t(saveable_obstack): Remove.\n+\t(rtl_obstack): Remove.\n+\t(immed_double_const): Don't mess with obstacks.\n+\t(immed_real_cons): Likewise.\n+\t(output_constant_def): Likewise.\n+\t(init_varasm_status): Use xcalloc.\n+\t(mark_pool_constant): Mark the pool constant itself.\n+\t(free_varasm_status): Free memory.\n+\t(decode_rtx_const): Call bzero directly, rather than expanding it\n+\tinline.\n+\t(record_rtx_const): Don't mess with obstacks.\n+\t(force_const_mem): Likewise.\n+\t* config/arm/arm.c (arm_encode_call_attribute): Remove ggc_p\n+\tconditionals.\n+\t(aof_pic_entry): Likewise.\n+\t* config/ia64/ia64.c (ia64_encode_section_info): Likewise.\n+\t* config/m32r/m32r.c (m32r_encode_section_info): Likewise.\n+\t* config/pa/pa.c (saveable_obstack): Remove.\n+\t(rtl_obstack): Likewise.\n+\t(current_obstack): Likewise.\n+\t(output_call): Don't mess with obstacks.\n+\t(hppa_encode_label): Remove ggc_p conditionals.\n+\t* config/romp/romp.c (get_symref): Don't mess with obstacks.\n+\t* config/rs6000/rs6000.c (output_toc): Remove ggc_p conditional.\n+\t(rs6000_encode_section_info): Likewise.\n+\t* config/sh/sh.c (get_fpscr_rtx): Likewise.\n+\t\n Thu Oct 12 16:02:31 MET DST 2000 Jan Hubicka  <jh@suse.cz>\n \n \t* i386.md (adddi3, subdi3 splitters): Update for new pattern."}, {"sha": "eeb1e191c0617c216d64df96b3838a8b33b47977", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -1232,8 +1232,6 @@ ggc-page.o: ggc-page.c $(CONFIG_H) $(RTL_H) $(TREE_H) flags.h toplev.h \\\n \n ggc-none.o: ggc-none.c $(CONFIG_H) $(RTL_H) $(GGC_H)\n \n-ggc-callbacks.o: ggc-callbacks.c $(CONFIG_H) $(RTL_H) $(TREE_H) $(GGC_H)\n-\n obstack.o: $(srcdir)/../libiberty/obstack.c $(CONFIG_H)\n \trm -f obstack.c\n \t$(LN_S) $(srcdir)/../libiberty/obstack.c obstack.c\n@@ -1365,7 +1363,7 @@ unroll.o : unroll.c $(CONFIG_H) system.h $(RTL_H) insn-config.h function.h \\\n    hard-reg-set.h varray.h $(BASIC_BLOCK_H)\n flow.o : flow.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h insn-config.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \\\n-   insn-flags.h function.h except.h $(EXPR_H) ssa.h\n+   insn-flags.h function.h except.h $(EXPR_H) ssa.h $(GGC_H)\n combine.o : combine.c $(CONFIG_H) system.h $(RTL_H) flags.h function.h \\\n    insn-config.h insn-flags.h insn-codes.h $(INSN_ATTR_H) $(REGS_H) $(EXPR_H) \\\n    $(BASIC_BLOCK_H) $(RECOG_H) real.h hard-reg-set.h toplev.h"}, {"sha": "c1158928eeddf21e3f3e6769d068d33e22410a7a", "filename": "gcc/alias.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -1935,8 +1935,7 @@ init_alias_analysis ()\n      registers.  */\n   reg_base_value_size = maxreg * 2;\n   reg_base_value = (rtx *) xcalloc (reg_base_value_size, sizeof (rtx));\n-  if (ggc_p)\n-    ggc_add_rtx_root (reg_base_value, reg_base_value_size);\n+  ggc_add_rtx_root (reg_base_value, reg_base_value_size);\n \n   new_reg_base_value = (rtx *) xmalloc (reg_base_value_size * sizeof (rtx));\n   reg_seen = (char *) xmalloc (reg_base_value_size);\n@@ -2129,8 +2128,7 @@ end_alias_analysis ()\n   reg_known_equiv_p = 0;\n   if (reg_base_value)\n     {\n-      if (ggc_p)\n-\tggc_del_root (reg_base_value);\n+      ggc_del_root (reg_base_value);\n       free (reg_base_value);\n       reg_base_value = 0;\n     }"}, {"sha": "2d6e2d4229423652a3caff977e98a9cc4f2aa361", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -521,12 +521,14 @@ extern void estimate_probability        PARAMS ((struct loops *));\n extern void expected_value_to_br_prob\tPARAMS ((void));\n \n /* In flow.c */\n+extern void init_flow                   PARAMS ((void));\n extern void reorder_basic_blocks\tPARAMS ((void));\n extern void dump_bb\t\t\tPARAMS ((basic_block, FILE *));\n extern void debug_bb\t\t\tPARAMS ((basic_block));\n extern void debug_bb_n\t\t\tPARAMS ((int));\n extern void dump_regset\t\t\tPARAMS ((regset, FILE *));\n extern void debug_regset\t\tPARAMS ((regset));\n+extern void allocate_reg_life_data      PARAMS ((void));\n \n /* This function is always defined so it can be called from the\n    debugger, and it is declared extern so we don't get warnings about"}, {"sha": "d2ea95d1f4e65096a9ed8b0db46d173cfa8a2fd4", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -110,7 +110,7 @@\n    For top-level functions, this is temporary_obstack.\n    Separate obstacks are made for nested functions.  */\n \n-extern struct obstack *function_obstack;\n+extern struct obstack flow_obstack;\n \n \n /* Structure to hold information about lexical scopes.  */\n@@ -676,8 +676,8 @@ fixup_reorder_chain ()\n       create_basic_block (n_basic_blocks - 1, jump_insn, jump_insn, NULL);\n \n       nb = BASIC_BLOCK (n_basic_blocks - 1);\n-      nb->global_live_at_start = OBSTACK_ALLOC_REG_SET (function_obstack);\n-      nb->global_live_at_end = OBSTACK_ALLOC_REG_SET (function_obstack);\n+      nb->global_live_at_start = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n+      nb->global_live_at_end = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n       nb->local_set = 0;\n \n       COPY_REG_SET (nb->global_live_at_start, bb->global_live_at_start);"}, {"sha": "419d85f3c59f08d4edf836630f2528aac00e6029", "filename": "gcc/c-decl.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -94,9 +94,6 @@ enum decl_context\n \t\t\t: \"long long unsigned int\"))\n #endif\n \f\n-/* Do GC.  */\n-int ggc_p = 1;\n-\n /* Nonzero if we have seen an invalid cross reference\n    to a struct, union, or enum, but not yet printed the message.  */\n "}, {"sha": "c8302ae6a7e4b2c59a1e85130ae9c4fddf9c851b", "filename": "gcc/caller-save.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -109,7 +109,6 @@ static void add_stored_regs\t\tPARAMS ((rtx, rtx, void *));\n void\n init_caller_save ()\n {\n-  char *first_obj = (char *) oballoc (0);\n   rtx addr_reg;\n   int offset;\n   rtx address;\n@@ -218,8 +217,6 @@ init_caller_save ()\n       }\n \n   end_sequence ();\n-\n-  obfree (first_obj);\n }\n \f\n /* Initialize save areas by showing that we haven't allocated any yet.  */"}, {"sha": "03780ba976f1ebc75ee17dacbad1bf5325d22ee3", "filename": "gcc/combine.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -337,9 +337,6 @@ struct undo\n /* Record a bunch of changes to be undone, up to MAX_UNDO of them.\n    num_undo says how many are currently recorded.\n \n-   storage is nonzero if we must undo the allocation of new storage.\n-   The value of storage is what to pass to obfree.\n-\n    other_insn is nonzero if we have modified some other insn in the process\n    of working on subst_insn.  It must be verified too.\n \n@@ -350,7 +347,6 @@ struct undo\n \n struct undobuf\n {\n-  char *storage;\n   struct undo *undos;\n   struct undo *frees;\n   struct undo *previous_undos;\n@@ -1530,10 +1526,6 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n   combine_attempts++;\n   undobuf.other_insn = 0;\n \n-  /* Save the current high-water-mark so we can free storage if we didn't\n-     accept this combination.  */\n-  undobuf.storage = (char *) oballoc (0);\n-\n   /* Reset the hard register usage information.  */\n   CLEAR_HARD_REG_SET (newpat_used_regs);\n \n@@ -2784,7 +2776,6 @@ undo_all ()\n       undobuf.frees = undo;\n     }\n \n-  obfree (undobuf.storage);\n   undobuf.undos = undobuf.previous_undos = 0;\n \n   /* Clear this here, so that subsequent get_last_value calls are not"}, {"sha": "777c6a5b29ff2736f20a457bbecf8706238314cd", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -1717,10 +1717,7 @@ arm_encode_call_attribute (decl, flag)\n   if (DECL_WEAK (decl) && flag == SHORT_CALL_FLAG_CHAR)\n     return;\n   \n-  if (ggc_p)\n-    newstr = ggc_alloc_string (NULL, len + 2);\n-  else\n-    newstr = permalloc (len + 2);\n+  newstr = ggc_alloc_string (NULL, len + 2);\n \n   sprintf (newstr, \"%c%s\", flag, str);\n \n@@ -9743,10 +9740,7 @@ aof_pic_entry (x)\n \t polluting even more code with ifdefs, and because it never\n \t contains anything useful until we assign to it here.  */\n       ggc_add_rtx_root (&aof_pic_label, 1);\n-      /* This needs to persist throughout the compilation.  */\n-      end_temporary_allocation ();\n       aof_pic_label = gen_rtx_SYMBOL_REF (Pmode, \"x$adcons\");\n-      resume_temporary_allocation ();\n     }\n \n   for (offset = 0, chainp = &aof_pic_chain; *chainp;"}, {"sha": "2026e9999b64446dbc89563fac83ae40e933da92", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -4642,11 +4642,7 @@ ia64_encode_section_info (decl)\n \t  size_t len = strlen (symbol_str);\n \t  char *newstr;\n \n-\t  if (ggc_p)\n-\t    newstr = ggc_alloc_string (NULL, len + 1);\n-\t  else\n-\t    newstr = obstack_alloc (saveable_obstack, len + 2);\n-\n+\t  newstr = ggc_alloc_string (NULL, len + 1);\n \t  *newstr = SDATA_NAME_FLAG_CHAR;\n \t  memcpy (newstr + 1, symbol_str, len + 1);\n \n@@ -4659,11 +4655,8 @@ ia64_encode_section_info (decl)\n      ENCODE_SECTION_INFO was first called.  Remove the '@'.*/\n   else if (symbol_str[0] == SDATA_NAME_FLAG_CHAR)\n     {\n-      if (ggc_p)\n-\tXSTR (XEXP (DECL_RTL (decl), 0), 0)\n-\t  = ggc_alloc_string (symbol_str + 1, -1);\n-      else\n-        XSTR (XEXP (DECL_RTL (decl), 0), 0) = symbol_str + 1;\n+      XSTR (XEXP (DECL_RTL (decl), 0), 0)\n+\t= ggc_alloc_string (symbol_str + 1, -1);\n     }\n }\n \f"}, {"sha": "09b7e43e6c5f2e070ff93b2f055afc2e5b1842f6", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -436,7 +436,7 @@ m32r_encode_section_info (decl)\n                  ? TREE_CST_RTL (decl) : DECL_RTL (decl));\n       const char *str = XSTR (XEXP (rtl, 0), 0);\n       int len = strlen (str);\n-      char *newstr = savealloc (len + 2);\n+      char *newstr = ggc_alloc (len + 2);\n       strcpy (newstr + 1, str);\n       *newstr = prefix;\n       XSTR (XEXP (rtl, 0), 0) = newstr;"}, {"sha": "c74fb62af050f315a1c4ce1a72e972de81838e1b", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -5674,9 +5674,6 @@ output_millicode_call (insn, call_dest)\n }\n \n extern struct obstack permanent_obstack;\n-extern struct obstack *saveable_obstack;\n-extern struct obstack *rtl_obstack;\n-extern struct obstack *current_obstack;\n \n /* INSN is either a function call.  It may have an unconditional jump\n    in its delay slot.\n@@ -5792,16 +5789,8 @@ output_call (insn, call_dest, sibcall)\n \t     not found on the list, create a new entry on the list.  */\n \t  if (deferred_plabels == NULL || i == n_deferred_plabels)\n \t    {\n-\t      struct obstack *ambient_obstack = current_obstack;\n-\t      struct obstack *ambient_rtl_obstack = rtl_obstack;\n \t      const char *real_name;\n \n-\t      /* Any RTL we create here needs to live until the end of\n-\t\t the compilation unit and therefore must live on the\n-\t\t permanent obstack.  */\n-\t      current_obstack = &permanent_obstack;\n-\t      rtl_obstack = &permanent_obstack;\n-\n \t      if (deferred_plabels == 0)\n \t\tdeferred_plabels = (struct deferred_plabel *)\n \t\t  xmalloc (1 * sizeof (struct deferred_plabel));\n@@ -5817,10 +5806,6 @@ output_call (insn, call_dest, sibcall)\n \t\t\t\t\t\t\tstrlen (name) + 1);\n \t      strcpy (deferred_plabels[i].name, name);\n \n-\t      /* Switch back to normal obstack allocation.  */\n-\t      current_obstack = ambient_obstack;\n-\t      rtl_obstack = ambient_rtl_obstack;\n-\n \t      /* Gross.  We have just implicitly taken the address of this\n \t\t function, mark it as such.  */\n \t      STRIP_NAME_ENCODING (real_name, name);\n@@ -5965,11 +5950,7 @@ hppa_encode_label (sym, permanent)\n   int len = strlen (str);\n   char *newstr;\n \n-  if (ggc_p)\n-    newstr = ggc_alloc_string (NULL, len + 1);\n-  else\n-    newstr = obstack_alloc ((permanent ? &permanent_obstack : saveable_obstack),\n-\t\t\t  len + 2);\n+  newstr = ggc_alloc_string (NULL, len + 1);\n \n   if (str[0] == '*')\n     *newstr++ = *str++;"}, {"sha": "33e8e90bb7ece4a02125ff1b257dc7559d2c12e4", "filename": "gcc/config/romp/romp.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fconfig%2Fromp%2Fromp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fconfig%2Fromp%2Fromp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -1352,14 +1352,12 @@ get_symref (name)\n   if (p == 0)\n     {\n       /* Ensure SYMBOL_REF will stay around.  */\n-      end_temporary_allocation ();\n       p = *last_p = (struct symref_hashent *)\n \t\t\tpermalloc (sizeof (struct symref_hashent));\n       p->symref = gen_rtx_SYMBOL_REF (Pmode,\n \t\t\t\t      obstack_copy0 (&permanent_obstack,\n \t\t\t\t\t\t     name, strlen (name)));\n       p->next = 0;\n-      resume_temporary_allocation ();\n     }\n \n   return p->symref;"}, {"sha": "9250bc1695e2febd96c1779d4f1b3f7ee73aae87", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -6705,10 +6705,8 @@ output_toc (file, x, labelno, mode)\n \n   /* When the linker won't eliminate them, don't output duplicate\n      TOC entries (this happens on AIX if there is any kind of TOC,\n-     and on SVR4 under -fPIC or -mrelocatable).\n-     This won't work if we are not garbage collecting, so \n-     we don't do it, sorry.  */\n-  if (TARGET_TOC && ggc_p)\n+     and on SVR4 under -fPIC or -mrelocatable).  */\n+  if (TARGET_TOC)\n     {\n       struct toc_hash_struct *h;\n       void * * found;\n@@ -7583,11 +7581,7 @@ rs6000_encode_section_info (decl)\n \t  size_t len2 = strlen (XSTR (sym_ref, 0));\n \t  char *str;\n \n-\t  if (ggc_p)\n-\t    str = ggc_alloc_string (NULL, len1 + len2);\n-\t  else\n-\t    str = permalloc (len1 + len2 + 1);\n-\n+\t  str = ggc_alloc_string (NULL, len1 + len2);\n \t  str[0] = '.';\n \t  str[1] = '.';\n \t  memcpy (str + len1, XSTR (sym_ref, 0), len2 + 1);\n@@ -7634,10 +7628,7 @@ rs6000_encode_section_info (decl)\n \t  size_t len = strlen (XSTR (sym_ref, 0));\n \t  char *str;\n \n-\t  if (ggc_p)\n-\t    str = ggc_alloc_string (NULL, len + 1);\n-\t  else\n-\t    str = permalloc (len + 2);\n+\t  str = ggc_alloc_string (NULL, len + 1);\n \t  str[0] = '@';\n \t  memcpy (str + 1, XSTR (sym_ref, 0), len + 1);\n "}, {"sha": "5c7c81c646a58d6c862c4913e9b1d928ba6ae638", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -5032,10 +5032,8 @@ get_fpscr_rtx ()\n \n   if (! fpscr_rtx)\n     {\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n       fpscr_rtx = gen_rtx (REG, PSImode, 48);\n       REG_USERVAR_P (fpscr_rtx) = 1;\n-      pop_obstacks ();\n       ggc_add_rtx_root (&fpscr_rtx, 1);\n       mark_user_reg (fpscr_rtx);\n     }"}, {"sha": "d068eeba16a1799b9495b83a7086281a0b40b2bd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -1,3 +1,36 @@\n+2000-10-12  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c (current_obstack): Remove.\n+\t* decl.c (ggc_p): Remove.\n+\t(start_decl): Don't use decl_tree_cons.\n+\t(grokdeclarator): Don't use build_decl_list.\n+\t(start_function): Don't use decl_tree_cons.\n+\t(finish_function): Don't mess with obstacks.\n+\t* decl2.c (grok_x_components): Don't use build_decl_list.\n+\t* lex.c (make_call_declarator): Don't call decl_tree_cons.\n+\t(implicitly_declare_fn): Don't call build_decl_list.\n+\t* parse.y (frob_specs): Don't call build_decl_list or\n+\tdecl_tree_cons.\n+\t(expr_or_declarator_intern): Don't call decl_tree_cons.\n+\t(primary): Don't call build_decl_list.\n+\t(fcast_or_absdcl): Likewise.\n+\t(typed_declspecs): Don't call decl_tree_cons.\n+\t(reserved_declspecs): Don't call build_decl_list.\n+\t(declmods): Likewise.\n+\t(reserved_typespecquals): Likewise.\n+\t(aggr): Likewise.\n+\t(new_type_id): Likewise.\n+\t(cv_qualifiers): Likewise.\n+\t(after_type_declarator_intern): Likewise.\n+\t(notype_declarator_intern): Likewise.\n+\t(absdcl_intern): Likewise.\n+\t(named_parm): Likewise.\n+\t* pt.c (most_specialized_class): Likewise.\n+\t* repo.c (temporary_obstack): Make it a structure, not a pointer.\n+\t(init_repo): Initialize it.\n+\t* search.c (current_obstack): Remove.\n+\t* typeck2.c (add_exception_specifier): Don't call build_decl_list.\n+\t\n 2000-10-09  Richard Henderson  <rth@cygnus.com>\n \n \t* Make-lang.in (CXX_EXTRA_HEADERS): Remove."}, {"sha": "d8f653d241ec09ecad9f7298e93539393981c799", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -1155,8 +1155,6 @@ add_virtual_function (new_virtuals_p, overridden_virtuals_p,\n     }\n }\n \f\n-extern struct obstack *current_obstack;\n-\n /* Add method METHOD to class TYPE.  If ERROR_P is true, we are adding\n    the method after the class has already been defined because a\n    declaration for it was seen.  (Even though that is erroneous, we"}, {"sha": "ba99c3bd5026e77d0ffca0290c77c46bddeca958", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -50,10 +50,6 @@ extern tree global_namespace;\n \n extern int (*valid_lang_attribute) PARAMS ((tree, tree, tree, tree));\n \n-/* Use garbage collection.  */\n-\n-int ggc_p = 1;\n-\n #ifndef BOOL_TYPE_SIZE\n #ifdef SLOW_BYTE_ACCESS\n /* In the new ABI, `bool' has size and alignment `1', on all\n@@ -7150,8 +7146,8 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n   /* This should only be done once on the top most decl.  */\n   if (have_extern_spec && !used_extern_spec)\n     {\n-      declspecs = decl_tree_cons (NULL_TREE, get_identifier (\"extern\"),\n-\t\t\t\t  declspecs);\n+      declspecs = tree_cons (NULL_TREE, get_identifier (\"extern\"),\n+\t\t\t     declspecs);\n       used_extern_spec = 1;\n     }\n \n@@ -11043,7 +11039,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n       else if (attrlist)\n \tTREE_VALUE (attrlist) = chainon (inner_attrs, TREE_VALUE (attrlist));\n       else\n-\tattrlist = build_decl_list (NULL_TREE, inner_attrs);\n+\tattrlist = build_tree_list (NULL_TREE, inner_attrs);\n     }\n \n   /* Now TYPE has the actual type.  */\n@@ -13530,7 +13526,7 @@ start_function (declspecs, declarator, attrs, flags)\n   /* This should only be done once on the top most decl.  */\n   if (have_extern_spec && !used_extern_spec)\n     {\n-      declspecs = decl_tree_cons (NULL_TREE, get_identifier (\"extern\"), declspecs);\n+      declspecs = tree_cons (NULL_TREE, get_identifier (\"extern\"), declspecs);\n       used_extern_spec = 1;\n     }\n \n@@ -14285,15 +14281,10 @@ finish_function (flags)\n \n   /* Clean up.  */\n   if (! nested)\n-    {\n-      /* Let the error reporting routines know that we're outside a\n-         function.  For a nested function, this value is used in\n-         pop_cp_function_context and then reset via pop_function_context.  */\n-      current_function_decl = NULL_TREE;\n-      /* We don't really care about obstacks, but the middle-end\n-\t sometimes cares on what obstck things are located.  */\n-      permanent_allocation (1);\n-    }\n+    /* Let the error reporting routines know that we're outside a\n+       function.  For a nested function, this value is used in\n+       pop_cp_function_context and then reset via pop_function_context.  */\n+    current_function_decl = NULL_TREE;\n \n   return fndecl;\n }"}, {"sha": "93c1be4b13d4e4fc75b75aa2a287f4ef70bf951b", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -926,7 +926,7 @@ grok_x_components (specs)\n   specs = strip_attrs (specs);\n \n   check_tag_decl (specs);\n-  t = groktypename (build_decl_list (specs, NULL_TREE)); \n+  t = groktypename (build_tree_list (specs, NULL_TREE)); \n \n   /* The only case where we need to do anything additional here is an\n      anonymous union field, e.g.: `struct S { union { int i; }; };'.  */"}, {"sha": "cf6a9e33f191a4ba22813e097bff465a8cbab2d9", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -200,7 +200,7 @@ make_call_declarator (target, parms, cv_qualifiers, exception_specification)\n      tree target, parms, cv_qualifiers, exception_specification;\n {\n   target = build_parse_node (CALL_EXPR, target, \n-\t\t\t     decl_tree_cons (parms, cv_qualifiers, NULL_TREE),\n+\t\t\t     tree_cons (parms, cv_qualifiers, NULL_TREE),\n \t\t\t     /* The third operand is really RTL.  We\n \t\t\t\tshouldn't put anything there.  */\n \t\t\t     NULL_TREE);"}, {"sha": "c3897482b01a45e512298d84832ed231565856ea", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -2609,7 +2609,7 @@ implicitly_declare_fn (kind, type, const_p)\n \n     case sfk_assignment_operator:\n       retref = 1;\n-      declspecs = build_decl_list (NULL_TREE, type);\n+      declspecs = build_tree_list (NULL_TREE, type);\n \n       if (const_p)\n \ttype = build_qualified_type (type, TYPE_QUAL_CONST);"}, {"sha": "27075e84df2e9f6202fb8ad4359415ef828c7586", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -120,12 +120,12 @@ frob_specs (specs_attrs, lookups)\n   split_specs_attrs (specs_attrs, &current_declspecs, &prefix_attributes);\n   if (current_declspecs\n       && TREE_CODE (current_declspecs) != TREE_LIST)\n-    current_declspecs = build_decl_list (NULL_TREE, current_declspecs);\n+    current_declspecs = build_tree_list (NULL_TREE, current_declspecs);\n   if (have_extern_spec && !used_extern_spec)\n     {\n-      current_declspecs = decl_tree_cons (NULL_TREE, \n-\t\t\t\t\t  get_identifier (\"extern\"), \n-\t\t\t\t\t  current_declspecs);\n+      current_declspecs = tree_cons (NULL_TREE, \n+\t\t\t\t     get_identifier (\"extern\"), \n+\t\t\t\t     current_declspecs);\n       used_extern_spec = 1;\n     }\n }\n@@ -1472,7 +1472,7 @@ expr_or_declarator_intern:\n \t\t{\n \t\t  /* Provide support for '(' attributes '*' declarator ')'\n \t\t     etc */\n-\t\t  $$ = decl_tree_cons ($1, $2, NULL_TREE);\n+\t\t  $$ = tree_cons ($1, $2, NULL_TREE);\n \t\t}\n \t;\n \n@@ -1571,7 +1571,7 @@ primary:\n \t\t  tree type;\n \n \t\t  type = hash_tree_cons (NULL_TREE, $1, NULL_TREE);\n-\t\t  type = groktypename (build_decl_list (type, NULL_TREE));\n+\t\t  type = groktypename (build_tree_list (type, NULL_TREE));\n \t\t  $$ = build_functional_cast (type, $3);\n \t\t}\n \t| functional_cast\n@@ -1776,20 +1776,20 @@ fcast_or_absdcl:\n /* ISO type-id (8.1) */\n type_id:\n \t  typed_typespecs absdcl\n-\t\t{ $$.t = build_decl_list ($1.t, $2); \n+\t\t{ $$.t = build_tree_list ($1.t, $2); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| nonempty_cv_qualifiers absdcl\n-\t\t{ $$.t = build_decl_list ($1.t, $2); \n+\t\t{ $$.t = build_tree_list ($1.t, $2); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| typespec absdcl\n-\t\t{ $$.t = build_decl_list (build_decl_list (NULL_TREE, $1.t),\n+\t\t{ $$.t = build_tree_list (build_tree_list (NULL_TREE, $1.t),\n \t\t\t\t\t  $2); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| typed_typespecs  %prec EMPTY\n-\t\t{ $$.t = build_decl_list ($1.t, NULL_TREE);\n+\t\t{ $$.t = build_tree_list ($1.t, NULL_TREE);\n \t\t  $$.new_type_flag = $1.new_type_flag;  }\n \t| nonempty_cv_qualifiers  %prec EMPTY\n-\t\t{ $$.t = build_decl_list ($1.t, NULL_TREE); \n+\t\t{ $$.t = build_tree_list ($1.t, NULL_TREE); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t;\n \n@@ -1807,23 +1807,23 @@ typed_declspecs:\n \n typed_declspecs1:\n \t  declmods typespec\n-\t\t{ $$.t = decl_tree_cons (NULL_TREE, $2.t, $1.t); \n+\t\t{ $$.t = tree_cons (NULL_TREE, $2.t, $1.t); \n \t\t  $$.new_type_flag = $2.new_type_flag; }\n \t| typespec reserved_declspecs  %prec HYPERUNARY\n-\t\t{ $$.t = decl_tree_cons (NULL_TREE, $1.t, $2); \n+\t\t{ $$.t = tree_cons (NULL_TREE, $1.t, $2); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| typespec reserved_typespecquals reserved_declspecs\n-\t\t{ $$.t = decl_tree_cons (NULL_TREE, $1.t, chainon ($2, $3)); \n+\t\t{ $$.t = tree_cons (NULL_TREE, $1.t, chainon ($2, $3)); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| declmods typespec reserved_declspecs\n-\t\t{ $$.t = decl_tree_cons (NULL_TREE, $2.t, chainon ($3, $1.t)); \n+\t\t{ $$.t = tree_cons (NULL_TREE, $2.t, chainon ($3, $1.t)); \n \t\t  $$.new_type_flag = $2.new_type_flag; }\n \t| declmods typespec reserved_typespecquals\n-\t\t{ $$.t = decl_tree_cons (NULL_TREE, $2.t, chainon ($3, $1.t)); \n+\t\t{ $$.t = tree_cons (NULL_TREE, $2.t, chainon ($3, $1.t)); \n \t\t  $$.new_type_flag = $2.new_type_flag; }\n \t| declmods typespec reserved_typespecquals reserved_declspecs\n-\t\t{ $$.t = decl_tree_cons (NULL_TREE, $2.t,\n-\t\t\t\t\t chainon ($3, chainon ($4, $1.t))); \n+\t\t{ $$.t = tree_cons (NULL_TREE, $2.t,\n+\t\t\t\t    chainon ($3, chainon ($4, $1.t))); \n \t\t  $$.new_type_flag = $2.new_type_flag; }\n \t;\n \n@@ -1832,18 +1832,18 @@ reserved_declspecs:\n \t\t{ if (extra_warnings)\n \t\t    warning (\"`%s' is not at beginning of declaration\",\n \t\t\t     IDENTIFIER_POINTER ($$));\n-\t\t  $$ = build_decl_list (NULL_TREE, $$); }\n+\t\t  $$ = build_tree_list (NULL_TREE, $$); }\n \t| reserved_declspecs typespecqual_reserved\n-\t\t{ $$ = decl_tree_cons (NULL_TREE, $2.t, $$); }\n+\t\t{ $$ = tree_cons (NULL_TREE, $2.t, $$); }\n \t| reserved_declspecs SCSPEC\n \t\t{ if (extra_warnings)\n \t\t    warning (\"`%s' is not at beginning of declaration\",\n \t\t\t     IDENTIFIER_POINTER ($2));\n-\t\t  $$ = decl_tree_cons (NULL_TREE, $2, $$); }\n+\t\t  $$ = tree_cons (NULL_TREE, $2, $$); }\n \t| reserved_declspecs attributes\n-\t\t{ $$ = decl_tree_cons ($2, NULL_TREE, $1); }\n+\t\t{ $$ = tree_cons ($2, NULL_TREE, $1); }\n \t| attributes\n-\t\t{ $$ = decl_tree_cons ($1, NULL_TREE, NULL_TREE); }\n+\t\t{ $$ = tree_cons ($1, NULL_TREE, NULL_TREE); }\n \t;\n \n /* List of just storage classes and type modifiers.\n@@ -1898,24 +1898,24 @@ declmods:\n \n typed_typespecs:\n \t  typespec  %prec EMPTY\n-\t\t{ $$.t = build_decl_list (NULL_TREE, $1.t); \n+\t\t{ $$.t = build_tree_list (NULL_TREE, $1.t); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| nonempty_cv_qualifiers typespec\n-\t\t{ $$.t = decl_tree_cons (NULL_TREE, $2.t, $1.t); \n+\t\t{ $$.t = tree_cons (NULL_TREE, $2.t, $1.t); \n \t\t  $$.new_type_flag = $2.new_type_flag; }\n \t| typespec reserved_typespecquals\n-\t\t{ $$.t = decl_tree_cons (NULL_TREE, $1.t, $2); \n+\t\t{ $$.t = tree_cons (NULL_TREE, $1.t, $2); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| nonempty_cv_qualifiers typespec reserved_typespecquals\n-\t\t{ $$.t = decl_tree_cons (NULL_TREE, $2.t, chainon ($3, $1.t)); \n+\t\t{ $$.t = tree_cons (NULL_TREE, $2.t, chainon ($3, $1.t)); \n \t\t  $$.new_type_flag = $2.new_type_flag; }\n \t;\n \n reserved_typespecquals:\n \t  typespecqual_reserved\n-\t\t{ $$ = build_decl_list (NULL_TREE, $1.t); }\n+\t\t{ $$ = build_tree_list (NULL_TREE, $1.t); }\n \t| reserved_typespecquals typespecqual_reserved\n-\t\t{ $$ = decl_tree_cons (NULL_TREE, $2.t, $1); }\n+\t\t{ $$ = tree_cons (NULL_TREE, $2.t, $1); }\n \t;\n \n /* A typespec (but not a type qualifier).\n@@ -2304,7 +2304,7 @@ aggr:\n \t| aggr AGGR\n \t\t{ error (\"no body nor ';' separates two class, struct or union declarations\"); }\n \t| aggr attributes\n-\t\t{ $$ = build_decl_list ($2, $1); }\n+\t\t{ $$ = build_tree_list ($2, $1); }\n \t;\n \n named_class_head_sans_basetype:\n@@ -2734,10 +2734,10 @@ enumerator:\n /* ISO new-type-id (5.3.4) */\n new_type_id:\n \t  type_specifier_seq new_declarator\n-\t\t{ $$.t = build_decl_list ($1.t, $2); \n+\t\t{ $$.t = build_tree_list ($1.t, $2); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| type_specifier_seq  %prec EMPTY\n-\t\t{ $$.t = build_decl_list ($1.t, NULL_TREE); \n+\t\t{ $$.t = build_tree_list ($1.t, NULL_TREE); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t/* GNU extension to allow arrays of arbitrary types with\n \t   non-constant dimension.  */\n@@ -2746,7 +2746,7 @@ new_type_id:\n \t\t  if (pedantic)\n \t\t    pedwarn (\"ISO C++ forbids array dimensions with parenthesized type in new\");\n \t\t  $$.t = build_parse_node (ARRAY_REF, TREE_VALUE ($2.t), $5);\n-\t\t  $$.t = build_decl_list (TREE_PURPOSE ($2.t), $$.t);\n+\t\t  $$.t = build_tree_list (TREE_PURPOSE ($2.t), $$.t);\n \t\t  $$.new_type_flag = $2.new_type_flag;\n \t\t}\n \t;\n@@ -2755,7 +2755,7 @@ cv_qualifiers:\n \t  /* empty */  %prec EMPTY\n \t\t{ $$ = NULL_TREE; }\n \t| cv_qualifiers CV_QUALIFIER\n-\t\t{ $$ = decl_tree_cons (NULL_TREE, $2, $$); }\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $$); }\n \t;\n \n nonempty_cv_qualifiers:\n@@ -2790,7 +2790,7 @@ after_type_declarator_intern:\n                 {\n \t\t  /* Provide support for '(' attributes '*' declarator ')'\n \t\t     etc */\n-\t\t  $$ = decl_tree_cons ($1, $2, NULL_TREE);\n+\t\t  $$ = tree_cons ($1, $2, NULL_TREE);\n \t\t}\n \t;\n \n@@ -2869,7 +2869,7 @@ notype_declarator_intern:\n                 {\n \t\t  /* Provide support for '(' attributes '*' declarator ')'\n \t\t     etc */\n-\t\t  $$ = decl_tree_cons ($1, $2, NULL_TREE);\n+\t\t  $$ = tree_cons ($1, $2, NULL_TREE);\n \t\t}\n \t;\n \t\n@@ -3170,7 +3170,7 @@ absdcl_intern:\n                 {\n \t\t  /* Provide support for '(' attributes '*' declarator ')'\n \t\t     etc */\n-\t\t  $$ = decl_tree_cons ($1, $2, NULL_TREE);\n+\t\t  $$ = tree_cons ($1, $2, NULL_TREE);\n \t\t}\n \t;\n \t\n@@ -3653,7 +3653,7 @@ named_parm:\n \t\t{ $$.t = build_tree_list ($1.t, $2); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| typespec declarator\n-\t\t{ $$.t = build_tree_list (build_decl_list (NULL_TREE, $1.t),\n+\t\t{ $$.t = build_tree_list (build_tree_list (NULL_TREE, $1.t),\n \t\t\t\t\t  $2); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| typed_declspecs1 absdcl"}, {"sha": "f7e27ce5d020dd7319c3f083717dc255a3799c5d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -9070,7 +9070,7 @@ most_specialized_class (tmpl, args)\n \t= get_class_bindings (TREE_VALUE (t), TREE_PURPOSE (t), args);\n       if (spec_args)\n \t{\n-\t  list = decl_tree_cons (TREE_PURPOSE (t), TREE_VALUE (t), list);\n+\t  list = tree_cons (TREE_PURPOSE (t), TREE_VALUE (t), list);\n \t  TREE_TYPE (list) = TREE_TYPE (t);\n \t}\n     }"}, {"sha": "32812ec7584985b0fe1a477a473625e1003dbb8d", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -49,7 +49,7 @@ static FILE *repo_file;\n static char *old_args, *old_dir, *old_main;\n \n extern int flag_use_repository;\n-extern struct obstack temporary_obstack;\n+static struct obstack temporary_obstack;\n extern struct obstack permanent_obstack;\n \n #define IDENTIFIER_REPO_USED(NODE)   (TREE_LANG_FLAG_3 (NODE))\n@@ -335,6 +335,7 @@ init_repo (filename)\n \n   ggc_add_tree_root (&pending_repo, 1);\n   ggc_add_tree_root (&original_repo, 1);\n+  gcc_obstack_init (&temporary_obstack);\n \n   open_repo_file (filename);\n "}, {"sha": "67f16fb1918178b6c009c98b2dec38f64bb50be3", "filename": "gcc/cp/search.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -36,8 +36,6 @@ Boston, MA 02111-1307, USA.  */\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-extern struct obstack *current_obstack;\n-\n #include \"stack.h\"\n \n /* Obstack used for remembering decision points of breadth-first.  */"}, {"sha": "a17ae249cdd418a0e0590f47d8ac2e57940c06a1", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -1266,7 +1266,7 @@ add_exception_specifier (list, spec, complain)\n           break;\n       if (!probe)\n         {\n-          spec = build_decl_list (NULL_TREE, spec);\n+          spec = build_tree_list (NULL_TREE, spec);\n           TREE_CHAIN (spec) = list;\n           list = spec;\n         }"}, {"sha": "ac9ae6be46cefcb1fedbb493565b98c3175ff9a5", "filename": "gcc/cse.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -1591,7 +1591,7 @@ insert (x, classp, hash, mode)\n   else\n     {\n       n_elements_made++;\n-      elt = (struct table_elt *) oballoc (sizeof (struct table_elt));\n+      elt = (struct table_elt *) xmalloc (sizeof (struct table_elt));\n     }\n \n   elt->exp = x;\n@@ -7017,10 +7017,8 @@ cse_main (f, nregs, after_loop, file)\n   memory_extend_rtx = gen_rtx_ZERO_EXTEND (VOIDmode, NULL_RTX);\n #endif\n \n-  /* Discard all the free elements of the previous function\n-     since they are allocated in the temporarily obstack.  */\n-  bzero ((char *) table, sizeof table);\n-  free_element_chain = 0;\n+  /* Reset the counter indicating how many elements have been made\n+     thus far.  */\n   n_elements_made = 0;\n \n   /* Find the largest uid.  */\n@@ -7075,8 +7073,7 @@ cse_main (f, nregs, after_loop, file)\n \t|| global_regs[i])\n       SET_HARD_REG_BIT (regs_invalidated_by_call, i);\n \n-  if (ggc_p)\n-    ggc_push_context ();\n+  ggc_push_context ();\n \n   /* Loop over basic blocks.\n      Compute the maximum number of qty's needed for each basic block\n@@ -7135,16 +7132,15 @@ cse_main (f, nregs, after_loop, file)\n \t  cse_jumps_altered |= old_cse_jumps_altered;\n \t}\n \n-      if (ggc_p && cse_altered)\n+      if (cse_altered)\n \tggc_collect ();\n \n #ifdef USE_C_ALLOCA\n       alloca (0);\n #endif\n     }\n \n-  if (ggc_p)\n-    ggc_pop_context ();\n+  ggc_pop_context ();\n \n   if (max_elements_made < n_elements_made)\n     max_elements_made = n_elements_made;"}, {"sha": "017cc6254060326184a34078911abbfa08c80c4d", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -3606,15 +3606,7 @@ static rtx\n save_rtx (orig)\n      register rtx orig;\n {\n-  if (ggc_p)\n-    VARRAY_PUSH_RTX (used_rtx_varray, orig);\n-  else\n-    {\n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n-      orig = copy_rtx (orig);\n-      pop_obstacks ();\n-    }\n+  VARRAY_PUSH_RTX (used_rtx_varray, orig);\n \n   return orig;\n }\n@@ -10854,11 +10846,8 @@ dwarf2out_init (asm_out_file, main_input_filename)\n      invoked when the given (base) source file was compiled.  */\n   comp_unit_die = gen_compile_unit_die (main_input_filename);\n \n-  if (ggc_p)\n-    {\n-      VARRAY_RTX_INIT (used_rtx_varray, 32, \"used_rtx_varray\");\n-      ggc_add_rtx_varray_root (&used_rtx_varray, 1);\n-    }\n+  VARRAY_RTX_INIT (used_rtx_varray, 32, \"used_rtx_varray\");\n+  ggc_add_rtx_varray_root (&used_rtx_varray, 1);\n \n   ASM_GENERATE_INTERNAL_LABEL (text_end_label, TEXT_END_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (abbrev_section_label, ABBREV_SECTION_LABEL, 0);"}, {"sha": "66b1f7e93a925d0e79124cc000ffedb9cbddb069", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 6, "deletions": 63, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -171,9 +171,6 @@ static rtx free_insn;\n #define last_filename (cfun->emit->x_last_filename)\n #define first_label_num (cfun->emit->x_first_label_num)\n \n-/* This is where the pointer to the obstack being used for RTL is stored.  */\n-extern struct obstack *rtl_obstack;\n-\n static rtx make_jump_insn_raw\t\tPARAMS ((rtx));\n static rtx make_call_insn_raw\t\tPARAMS ((rtx));\n static rtx find_line_note\t\tPARAMS ((rtx));\n@@ -254,17 +251,7 @@ gen_rtx_CONST_INT (mode, arg)\n   slot = htab_find_slot_with_hash (const_int_htab, &arg,\n \t\t\t\t   (hashval_t) arg, INSERT);\n   if (*slot == 0)\n-    {\n-      if (!ggc_p)\n-\t{\n-\t  push_obstacks_nochange ();\n-\t  end_temporary_allocation ();\n-\t  *slot = gen_rtx_raw_CONST_INT (VOIDmode, arg);\n-\t  pop_obstacks ();\n-\t}\n-      else\n-\t*slot = gen_rtx_raw_CONST_INT (VOIDmode, arg);\n-    }\n+    *slot = gen_rtx_raw_CONST_INT (VOIDmode, arg);\n \n   return (rtx) *slot;\n }\n@@ -2492,15 +2479,7 @@ make_insn_raw (pattern)\n {\n   register rtx insn;\n \n-  /* If in RTL generation phase, see if FREE_INSN can be used.  */\n-  if (!ggc_p && free_insn != 0 && rtx_equal_function_value_matters)\n-    {\n-      insn = free_insn;\n-      free_insn = NEXT_INSN (free_insn);\n-      PUT_CODE (insn, INSN);\n-    }\n-  else\n-    insn = rtx_alloc (INSN);\n+  insn = rtx_alloc (INSN);\n \n   INSN_UID (insn) = cur_insn_uid++;\n   PATTERN (insn) = pattern;\n@@ -2927,8 +2906,6 @@ emit_insn_before (pattern, before)\n \t  insn = XVECEXP (pattern, 0, i);\n \t  add_insn_before (insn, before);\n \t}\n-      if (!ggc_p && XVECLEN (pattern, 0) < SEQUENCE_RESULT_SIZE)\n-\tsequence_result[XVECLEN (pattern, 0)] = pattern;\n     }\n   else\n     {\n@@ -3061,8 +3038,6 @@ emit_insn_after (pattern, after)\n \t  add_insn_after (insn, after);\n \t  after = insn;\n \t}\n-      if (!ggc_p && XVECLEN (pattern, 0) < SEQUENCE_RESULT_SIZE)\n-\tsequence_result[XVECLEN (pattern, 0)] = pattern;\n     }\n   else\n     {\n@@ -3222,8 +3197,6 @@ emit_insn (pattern)\n \t  insn = XVECEXP (pattern, 0, i);\n \t  add_insn (insn);\n \t}\n-      if (!ggc_p && XVECLEN (pattern, 0) < SEQUENCE_RESULT_SIZE)\n-\tsequence_result[XVECLEN (pattern, 0)] = pattern;\n     }\n   else\n     {\n@@ -3711,29 +3684,9 @@ gen_sequence ()\n       && GET_CODE (first_insn) == INSN\n       /* Don't throw away any reg notes. */\n       && REG_NOTES (first_insn) == 0)\n-    {\n-      if (!ggc_p)\n-\t{\n-\t  NEXT_INSN (first_insn) = free_insn;\n-\t  free_insn = first_insn;\n-\t}\n-      return PATTERN (first_insn);\n-    }\n+    return PATTERN (first_insn);\n \n-  /* Put them in a vector.  See if we already have a SEQUENCE of the\n-     appropriate length around.  */\n-  if (!ggc_p && len < SEQUENCE_RESULT_SIZE \n-      && (result = sequence_result[len]) != 0)\n-    sequence_result[len] = 0;\n-  else\n-    {\n-      /* Ensure that this rtl goes in saveable_obstack, since we may\n-\t cache it.  */\n-      push_obstacks_nochange ();\n-      rtl_in_saveable_obstack ();\n-      result = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (len));\n-      pop_obstacks ();\n-    }\n+  result = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (len));\n \n   for (i = 0, tem = first_insn; tem; tem = NEXT_INSN (tem), i++)\n     XVECEXP (result, 0, i) = tem;\n@@ -3887,14 +3840,6 @@ copy_insn_1 (orig)\n \t    }\n \t  break;\n \n-\tcase 'b':\n-\t  {\n-\t    bitmap new_bits = BITMAP_OBSTACK_ALLOC (rtl_obstack);\n-\t    bitmap_copy (new_bits, XBITMAP (orig, i));\n-\t    XBITMAP (copy, i) = new_bits;\n-\t    break;\n-\t  }\n-\n \tcase 't':\n \tcase 'w':\n \tcase 'i':\n@@ -4117,8 +4062,7 @@ init_emit_once (line_numbers)\n   virtual_cfa_rtx = gen_rtx_raw_REG (Pmode, VIRTUAL_CFA_REGNUM);\n \n   /* These rtx must be roots if GC is enabled.  */\n-  if (ggc_p)\n-    ggc_add_rtx_root (global_rtl, GR_MAX);\n+  ggc_add_rtx_root (global_rtl, GR_MAX);\n \n #ifdef INIT_EXPANDERS\n   /* This is to initialize save_machine_status and restore_machine_status before\n@@ -4135,8 +4079,7 @@ init_emit_once (line_numbers)\n   for (i = - MAX_SAVED_CONST_INT; i <= MAX_SAVED_CONST_INT; i++)\n     const_int_rtx[i + MAX_SAVED_CONST_INT] = \n       gen_rtx_raw_CONST_INT (VOIDmode, i);\n-  if (ggc_p)\n-    ggc_add_rtx_root (const_int_rtx, 2 * MAX_SAVED_CONST_INT + 1);\n+  ggc_add_rtx_root (const_int_rtx, 2 * MAX_SAVED_CONST_INT + 1);\n \n   if (STORE_FLAG_VALUE >= - MAX_SAVED_CONST_INT\n       && STORE_FLAG_VALUE <= MAX_SAVED_CONST_INT)"}, {"sha": "d3a0a3ca509de5c4051cef32288d1d113693ea3b", "filename": "gcc/except.c", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -503,15 +503,11 @@ create_rethrow_ref (region_num)\n   char *ptr;\n   char buf[60];\n \n-  push_obstacks_nochange ();\n-  end_temporary_allocation ();\n-\n   ASM_GENERATE_INTERNAL_LABEL (buf, \"LRTH\", region_num);\n   ptr = ggc_alloc_string (buf, -1);\n   def = gen_rtx_SYMBOL_REF (Pmode, ptr);\n   SYMBOL_REF_NEED_ADJUST (def) = 1;\n \n-  pop_obstacks ();\n   return def;\n }\n \n@@ -1104,10 +1100,6 @@ add_partial_entry (handler)\n {\n   expand_eh_region_start ();\n \n-  /* Make sure the entry is on the correct obstack.  */\n-  push_obstacks_nochange ();\n-  resume_temporary_allocation ();\n-\n   /* Because this is a cleanup action, we may have to protect the handler\n      with __terminate.  */\n   handler = protect_with_terminate (handler);\n@@ -1121,7 +1113,6 @@ add_partial_entry (handler)\n   /* Add this entry to the front of the list.  */\n   TREE_VALUE (protect_list) \n     = tree_cons (NULL_TREE, handler, TREE_VALUE (protect_list));\n-  pop_obstacks ();\n }\n \n /* Emit code to get EH context to current function.  */\n@@ -1136,8 +1127,6 @@ call_get_eh_context ()\n     {\n       tree fntype;\n       fn = get_identifier (\"__get_eh_context\");\n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n       fntype = build_pointer_type (build_pointer_type\n \t\t\t\t   (build_pointer_type (void_type_node)));\n       fntype = build_function_type (fntype, NULL_TREE);\n@@ -1148,7 +1137,6 @@ call_get_eh_context ()\n       TREE_READONLY (fn) = 1;\n       make_decl_rtl (fn, NULL_PTR, 1);\n       assemble_external (fn);\n-      pop_obstacks ();\n \n       ggc_add_tree_root (&fn, 1);\n     }\n@@ -2043,15 +2031,8 @@ expand_rethrow (label)\n void\n begin_protect_partials ()\n {\n-  /* Put the entry on the function obstack.  */\n-  push_obstacks_nochange ();\n-  resume_temporary_allocation ();\n-\n   /* Push room for a new list.  */\n   protect_list = tree_cons (NULL_TREE, NULL_TREE, protect_list);\n-\n-  /* We're done with the function obstack now.  */\n-  pop_obstacks ();\n }\n \n /* End all the pending exception regions on protect_list. The handlers\n@@ -2091,10 +2072,6 @@ protect_with_terminate (e)\n     {\n       tree handler, result;\n \n-      /* All cleanups must be on the function_obstack.  */\n-      push_obstacks_nochange ();\n-      resume_temporary_allocation ();\n-\n       handler = make_node (RTL_EXPR);\n       TREE_TYPE (handler) = void_type_node;\n       RTL_EXPR_RTL (handler) = const0_rtx;\n@@ -2112,8 +2089,6 @@ protect_with_terminate (e)\n       TREE_THIS_VOLATILE (result) = TREE_THIS_VOLATILE (e);\n       TREE_READONLY (result) = TREE_READONLY (e);\n \n-      pop_obstacks ();\n-\n       e = result;\n     }\n "}, {"sha": "92de3418cfb7994b5ad52060367b702f37e7c3e3", "filename": "gcc/explow.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -129,15 +129,10 @@ plus_constant_wide (x, c)\n       if (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n \t  && CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))\n \t{\n-\t  /* Any rtl we create here must go in a saveable obstack, since\n-\t     we might have been called from within combine.  */\n-\t  push_obstacks_nochange ();\n-\t  rtl_in_saveable_obstack ();\n \t  tem\n \t    = force_const_mem (GET_MODE (x),\n \t\t\t       plus_constant (get_pool_constant (XEXP (x, 0)),\n \t\t\t\t\t      c));\n-\t  pop_obstacks ();\n \t  if (memory_address_p (GET_MODE (tem), XEXP (tem, 0)))\n \t    return tem;\n \t}"}, {"sha": "2115a471ae98403c1de088a6590efb518a0126c8", "filename": "gcc/expr.c", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -238,15 +238,9 @@ init_expr_once ()\n   enum machine_mode mode;\n   int num_clobbers;\n   rtx mem, mem1;\n-  char *free_point;\n \n   start_sequence ();\n \n-  /* Since we are on the permanent obstack, we must be sure we save this\n-     spot AFTER we call start_sequence, since it will reuse the rtl it\n-     makes.  */\n-  free_point = (char *) oballoc (0);\n-\n   /* Try indexing by frame ptr and try by stack ptr.\n      It is known that on the Convex the stack ptr isn't a valid index.\n      With luck, one or the other is valid on any machine.  */\n@@ -302,7 +296,6 @@ init_expr_once ()\n     }\n \n   end_sequence ();\n-  obfree (free_point);\n }\n \n /* This is run at the start of compiling a function.  */\n@@ -1757,8 +1750,6 @@ emit_block_move (x, y, size, align)\n \t  /* This was copied from except.c, I don't know if all this is\n \t     necessary in this context or not.  */\n \t  fn = get_identifier (\"memcpy\");\n-\t  push_obstacks_nochange ();\n-\t  end_temporary_allocation ();\n \t  fntype = build_pointer_type (void_type_node);\n \t  fntype = build_function_type (fntype, NULL_TREE);\n \t  fn = build_decl (FUNCTION_DECL, fn, fntype);\n@@ -1768,7 +1759,6 @@ emit_block_move (x, y, size, align)\n \t  DECL_ARTIFICIAL (fn) = 1;\n \t  make_decl_rtl (fn, NULL_PTR, 1);\n \t  assemble_external (fn);\n-\t  pop_obstacks ();\n \t}\n \n       /* We need to make an argument list for the function call.\n@@ -2525,8 +2515,6 @@ clear_storage (object, size, align)\n \t      /* This was copied from except.c, I don't know if all this is\n \t\t necessary in this context or not.  */\n \t      fn = get_identifier (\"memset\");\n-\t      push_obstacks_nochange ();\n-\t      end_temporary_allocation ();\n \t      fntype = build_pointer_type (void_type_node);\n \t      fntype = build_function_type (fntype, NULL_TREE);\n \t      fn = build_decl (FUNCTION_DECL, fn, fntype);\n@@ -2536,7 +2524,6 @@ clear_storage (object, size, align)\n \t      DECL_ARTIFICIAL (fn) = 1;\n \t      make_decl_rtl (fn, NULL_PTR, 1);\n \t      assemble_external (fn);\n-\t      pop_obstacks ();\n \t    }\n \n \t  /* We need to make an argument list for the function call.\n@@ -5966,15 +5953,9 @@ expand_expr (exp, target, tmode, modifier)\n \t    && function != inline_function_decl && function != 0)\n \t  {\n \t    struct function *p = find_function_data (function);\n-\t    /* Allocate in the memory associated with the function\n-\t       that the label is in.  */\n-\t    push_obstacks (p->function_obstack,\n-\t\t\t   p->function_maybepermanent_obstack);\n-\n \t    p->expr->x_forced_labels\n \t      = gen_rtx_EXPR_LIST (VOIDmode, label_rtx (exp),\n \t\t\t\t   p->expr->x_forced_labels);\n-\t    pop_obstacks ();\n \t  }\n \telse\n \t  {\n@@ -6007,11 +5988,8 @@ expand_expr (exp, target, tmode, modifier)\n       if (DECL_SIZE (exp) == 0 && COMPLETE_TYPE_P (TREE_TYPE (exp))\n \t  && (TREE_STATIC (exp) || DECL_EXTERNAL (exp)))\n \t{\n-\t  push_obstacks_nochange ();\n-\t  end_temporary_allocation ();\n \t  layout_decl (exp, 0);\n \t  PUT_MODE (DECL_RTL (exp), DECL_MODE (exp));\n-\t  pop_obstacks ();\n \t}\n \n       /* Although static-storage variables start off initialized, according to"}, {"sha": "0ffe42ea258f9a4ecaafe8cabcec647db6ae0731", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -1,3 +1,43 @@\n+Thu Oct 12 22:28:51 2000  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* com.c (ffecom_do_entry_): Don't mess with obstacks.\n+\t(ffecom_finish_global_): Likewise.\n+\t(ffecom_finish_symbol_transform_): Likewise.\n+\t(ffecom_gen_sfuncdef_): Likewise.\n+\t(ffecom_init_zero_): Likewise.\n+\t(ffecom_start_progunit_): Likewise.\n+\t(ffecom_sym_transform_): Likewise.\n+\t(ffecom_sym_transform_assign_): Likewise.\n+\t(ffecom_transform_equiv_): Likewise.\n+\t(ffecom_transform_namelist_): Likewise.\n+\t(ffecom_vardesc_): Likewise.\n+\t(ffecom_vardesc_array_): Likewise.\n+\t(ffecom_vardesc_dims_): Likewise.\n+\t(ffecom_end_transition): Likewise.\n+\t(ffecom_make_tempvar): Likewise.\n+\t(bison_rule_pushlevel_): Likewise.\n+\t(bison_rule_compstmt_): Likewise.\n+\t(finish_decl): Likewise.\n+\t(finish_function): Likewise.\n+\t(push_parm_decl): Likewise.\n+\t(start_decl): Likewise.\n+\t(start_function): Likewise.\n+\t(ggc_p): Don't define.\n+\t* std.c (ffestd_stmt_pass_): Likewise.\n+\t* ste.c (ffeste_end_block_): Likewise.\n+\t(ffeste_end_stmt_): Likewise.\n+\t(ffeste_begin_iterdo_): Likewise.\n+\t(ffeste_io_ialist_): Likewise.\n+\t(ffeste_io_cilist_): Likewise.\n+\t(ffeste_io_inlist_): Likewise.\n+\t(ffeste_io_olist_): Likewise.\n+\t(ffeste_R810): Likewise.\n+\t(ffeste_R838): Likewise.\n+\t(ffeste_R839): Likewise.\n+\t(ffeste_R842): Likewise.\n+\t(ffeste_R843): Likewise.\n+\t(ffeste_R1001): Likewise.\n+\t\n 2000-10-05  Richard Henderson  <rth@cygnus.com>\n \n \t* com.c (finish_function): Don't init can_reach_end."}, {"sha": "495f168e056c4312c3d517da8f327e4530014158", "filename": "gcc/f/com.c", "status": "modified", "additions": 2, "deletions": 212, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -54,8 +54,6 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    when it comes to building decls:\n \n    Internal Function (one we define, not just declare as extern):\n-   int yes;\n-   yes = suspend_momentary ();\n    if (is_nested) push_f_function_context ();\n    start_function (get_identifier (\"function_name\"), function_type,\n \t\t   is_nested, is_public);\n@@ -66,21 +64,17 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    ffecom_end_compstmt ();\n    finish_function (is_nested);\n    if (is_nested) pop_f_function_context ();\n-   if (is_nested) resume_momentary (yes);\n \n    Everything Else:\n-   int yes;\n    tree d;\n    tree init;\n-   yes = suspend_momentary ();\n    // fill in external, public, static, &c for decl, and\n    // set DECL_INITIAL to error_mark_node if going to initialize\n    // set is_top_level TRUE only if not at top level and decl\n    // must go in top level (i.e. not within current function decl context)\n    d = start_decl (decl, is_top_level);\n    init = ...;\t// if have initializer\n    finish_decl (d, init, is_top_level);\n-   resume_momentary (yes);\n \n */\n \n@@ -2698,23 +2692,12 @@ ffecom_do_entry_ (ffesymbol fn, int entrynum)\n   bool cmplxfunc;\t\t/* Use f2c way of returning COMPLEX. */\n   bool multi;\t\t\t/* Master fn has multiple return types. */\n   bool altreturning = FALSE;\t/* This entry point has alternate returns. */\n-  int yes;\n   int old_lineno = lineno;\n   const char *old_input_filename = input_filename;\n \n   input_filename = ffesymbol_where_filename (fn);\n   lineno = ffesymbol_where_filelinenum (fn);\n \n-  /* c-parse.y indeed does call suspend_momentary and not only ignores the\n-     return value, but also never calls resume_momentary, when starting an\n-     outer function (see \"fndef:\", \"setspecs:\", and so on).  So g77 does the\n-     same thing.  It shouldn't be a problem since start_function calls\n-     temporary_allocation, but it might be necessary.  If it causes a problem\n-     here, then maybe there's a bug lurking in gcc.  NOTE: This identical\n-     comment appears twice in thist file.  */\n-\n-  suspend_momentary ();\n-\n   ffecom_doing_entry_ = TRUE;\t/* Don't bother with array dimensions. */\n \n   switch (ffecom_primary_entry_kind_)\n@@ -2835,8 +2818,6 @@ ffecom_do_entry_ (ffesymbol fn, int entrynum)\n \n   /* Build dummy arg list for this entry point. */\n \n-  yes = suspend_momentary ();\n-\n   if (charfunc || cmplxfunc)\n     {\t\t\t\t/* Prepend arg for where result goes. */\n       tree type;\n@@ -2873,8 +2854,6 @@ ffecom_do_entry_ (ffesymbol fn, int entrynum)\n \n   ffecom_push_dummy_decls_ (ffesymbol_dummyargs (fn), FALSE);\n \n-  resume_momentary (yes);\n-\n   store_parm_decls (0);\n \n   ffecom_start_compstmt ();\n@@ -2885,16 +2864,12 @@ ffecom_do_entry_ (ffesymbol fn, int entrynum)\n \n   if (multi)\n     {\n-      yes = suspend_momentary ();\n-\n       multi_retval = ffecom_get_invented_identifier (\"__g77_%s\",\n \t\t\t\t\t\t     \"multi_retval\");\n       multi_retval = build_decl (VAR_DECL, multi_retval,\n \t\t\t\t ffecom_multi_type_node_);\n       multi_retval = start_decl (multi_retval, FALSE);\n       finish_decl (multi_retval, NULL_TREE, FALSE);\n-\n-      resume_momentary (yes);\n     }\n   else\n     multi_retval = NULL_TREE;\t/* Not actually ref'd if !multi. */\n@@ -3045,8 +3020,6 @@ ffecom_do_entry_ (ffesymbol fn, int entrynum)\n \t\t\t\t\t call));\n \texpand_return (result);\n       }\n-\n-    clear_momentary ();\n   }\n \n   ffecom_end_compstmt ();\n@@ -6112,8 +6085,6 @@ ffecom_finish_global_ (ffeglobal global)\n       || !ffeglobal_common_have_size (global))\n     return global;\t\t/* No need to make common, never ref'd. */\n \n-  suspend_momentary ();\n-\n   DECL_EXTERNAL (cbt) = 0;\n \n   /* Give the array a size now.  */\n@@ -6172,8 +6143,6 @@ ffecom_finish_symbol_transform_ (ffesymbol s)\n   if ((ffesymbol_where (s) == FFEINFO_whereCOMMON)\n       && (ffesymbol_hook (s).decl_tree != error_mark_node))\n     {\n-      int yes = suspend_momentary ();\n-\n       /* This isn't working, at least for dbxout.  The .s file looks\n \t okay to me (burley), but in gdb 4.9 at least, the variables\n \t appear to reside somewhere outside of the common area, so\n@@ -6182,8 +6151,6 @@ ffecom_finish_symbol_transform_ (ffesymbol s)\n \t with EQUIVALENCE, sadly...see similar #if later.  */\n       ffecom_member_phase2_ (ffesymbol_storage (ffesymbol_common (s)),\n \t\t\t     ffesymbol_storage (s));\n-\n-      resume_momentary (yes);\n     }\n \n   return s;\n@@ -6297,7 +6264,6 @@ ffecom_gen_sfuncdef_ (ffesymbol s, ffeinfoBasictype bt, ffeinfoKindtype kt)\n   tree result;\n   bool charfunc = (bt == FFEINFO_basictypeCHARACTER);\n   static bool recurse = FALSE;\n-  int yes;\n   int old_lineno = lineno;\n   const char *old_input_filename = input_filename;\n \n@@ -6326,8 +6292,6 @@ ffecom_gen_sfuncdef_ (ffesymbol s, ffeinfoBasictype bt, ffeinfoKindtype kt)\n   assert (!recurse);\n   recurse = TRUE;\n \n-  yes = suspend_momentary ();\n-\n   push_f_function_context ();\n \n   if (charfunc)\n@@ -6349,8 +6313,6 @@ ffecom_gen_sfuncdef_ (ffesymbol s, ffeinfoBasictype bt, ffeinfoKindtype kt)\n      entirely internal to our code, and gcc has the ability to return COMPLEX\n      directly as a value.  */\n \n-  yes = suspend_momentary ();\n-\n   if (charfunc)\n     {\t\t\t\t/* Prepend arg for where result goes. */\n       tree type;\n@@ -6371,8 +6333,6 @@ ffecom_gen_sfuncdef_ (ffesymbol s, ffeinfoBasictype bt, ffeinfoKindtype kt)\n \n   ffecom_push_dummy_decls_ (ffesymbol_dummyargs (s), TRUE);\n \n-  resume_momentary (yes);\n-\n   store_parm_decls (0);\n \n   ffecom_start_compstmt ();\n@@ -6404,8 +6364,6 @@ ffecom_gen_sfuncdef_ (ffesymbol s, ffeinfoBasictype bt, ffeinfoKindtype kt)\n \t\t\t\t\tDECL_RESULT (current_function_decl),\n \t\t\t\t\tffecom_expr (expr)));\n \t}\n-\n-      clear_momentary ();\n     }\n \n   ffecom_end_compstmt ();\n@@ -6415,8 +6373,6 @@ ffecom_gen_sfuncdef_ (ffesymbol s, ffeinfoBasictype bt, ffeinfoKindtype kt)\n \n   pop_f_function_context ();\n \n-  resume_momentary (yes);\n-\n   recurse = FALSE;\n \n   lineno = old_lineno;\n@@ -6515,35 +6471,23 @@ ffecom_init_zero_ (tree decl)\n       assemble_variable (decl, TREE_PUBLIC (decl) ? 1 : 0, 0, 1);\n     }\n \n-  push_momentary ();\n-\n   if ((TREE_CODE (type) != ARRAY_TYPE)\n       && (TREE_CODE (type) != RECORD_TYPE)\n       && (TREE_CODE (type) != UNION_TYPE)\n       && !incremental)\n     init = convert (type, integer_zero_node);\n   else if (!incremental)\n     {\n-      int momentary = suspend_momentary ();\n-\n       init = build (CONSTRUCTOR, type, NULL_TREE, NULL_TREE);\n       TREE_CONSTANT (init) = 1;\n       TREE_STATIC (init) = 1;\n-\n-      resume_momentary (momentary);\n     }\n   else\n     {\n-      int momentary = suspend_momentary ();\n-\n       assemble_zeros (int_size_in_bytes (type));\n       init = error_mark_node;\n-\n-      resume_momentary (momentary);\n     }\n \n-  pop_momentary_nofree ();\n-\n   return init;\n }\n \n@@ -7339,24 +7283,13 @@ ffecom_start_progunit_ ()\n   bool main_program = FALSE;\n   int old_lineno = lineno;\n   const char *old_input_filename = input_filename;\n-  int yes;\n \n   assert (fn != NULL);\n   assert (ffesymbol_hook (fn).decl_tree == NULL_TREE);\n \n   input_filename = ffesymbol_where_filename (fn);\n   lineno = ffesymbol_where_filelinenum (fn);\n \n-  /* c-parse.y indeed does call suspend_momentary and not only ignores the\n-     return value, but also never calls resume_momentary, when starting an\n-     outer function (see \"fndef:\", \"setspecs:\", and so on).  So g77 does the\n-     same thing.  It shouldn't be a problem since start_function calls\n-     temporary_allocation, but it might be necessary.  If it causes a problem\n-     here, then maybe there's a bug lurking in gcc.  NOTE: This identical\n-     comment appears twice in thist file.  */\n-\n-  suspend_momentary ();\n-\n   switch (ffecom_primary_entry_kind_)\n     {\n     case FFEINFO_kindPROGRAM:\n@@ -7468,8 +7401,6 @@ ffecom_start_progunit_ ()\n       ffeglobal_set_hook (g, current_function_decl);\n     }\n \n-  yes = suspend_momentary ();\n-\n   /* Arg handling needs exec-transitioned ffesymbols to work with.  But\n      exec-transitioning needs current_function_decl to be filled in.  So we\n      do these things in two phases. */\n@@ -7532,8 +7463,6 @@ ffecom_start_progunit_ ()\n       ffecom_push_dummy_decls_ (arglist, FALSE);\n     }\n \n-  resume_momentary (yes);\n-\n   if (TREE_CODE (current_function_decl) != ERROR_MARK)\n     store_parm_decls (main_program ? 1 : 0);\n \n@@ -7572,7 +7501,6 @@ ffecom_sym_transform_ (ffesymbol s)\n   ffeinfoBasictype bt;\n   ffeinfoKindtype kt;\n   ffeglobal g;\n-  int yes;\n   int old_lineno = lineno;\n   const char *old_input_filename = input_filename;\n \n@@ -7698,9 +7626,7 @@ ffecom_sym_transform_ (ffesymbol s)\n \t\tbreak;\n \t      }\n \n-\t    yes = suspend_momentary ();\n \t    type = ffecom_type_localvar_ (s, bt, kt);\n-\t    resume_momentary (yes);\n \n \t    if (type == error_mark_node)\n \t      {\n@@ -7713,7 +7639,6 @@ ffecom_sym_transform_ (ffesymbol s)\n \t      {\t\t\t/* Child of EQUIVALENCE parent. */\n \t\tffestorag est;\n \t\ttree et;\n-\t\tint yes;\n \t\tffetargetOffset offset;\n \n \t\test = ffestorag_parent (st);\n@@ -7725,8 +7650,6 @@ ffecom_sym_transform_ (ffesymbol s)\n \t\tif (! TREE_STATIC (et))\n \t\t  put_var_into_stack (et);\n \n-\t\tyes = suspend_momentary ();\n-\n \t\toffset = ffestorag_modulo (est)\n \t\t  + ffestorag_offset (ffesymbol_storage (s))\n \t\t  - ffestorag_offset (est);\n@@ -7747,16 +7670,12 @@ ffecom_sym_transform_ (ffesymbol s)\n \t\tTREE_CONSTANT (t) = staticp (et);\n \n \t\taddr = TRUE;\n-\n-\t\tresume_momentary (yes);\n \t      }\n \t    else\n \t      {\n \t\ttree initexpr;\n \t\tbool init = ffesymbol_is_init (s);\n \n-\t\tyes = suspend_momentary ();\n-\n \t\tt = build_decl (VAR_DECL,\n \t\t\t\tffecom_get_identifier_ (ffesymbol_text (s)),\n \t\t\t\ttype);\n@@ -7805,8 +7724,6 @@ ffecom_sym_transform_ (ffesymbol s)\n \t\t    assert (0 == compare_tree_int (DECL_SIZE_UNIT (t),\n \t\t\t\t\t\t   ffestorag_size (st)));\n \t\t  }\n-\n-\t\tresume_momentary (yes);\n \t      }\n \t  }\n \t  break;\n@@ -7839,20 +7756,15 @@ ffecom_sym_transform_ (ffesymbol s)\n \t  if ((ffecom_num_entrypoints_ != 0)\n \t      && (ffecom_master_bt_ == FFEINFO_basictypeNONE))\n \t    {\n-\t      yes = suspend_momentary ();\n-\n \t      assert (ffecom_multi_retval_ != NULL_TREE);\n \t      t = ffecom_1 (INDIRECT_REF, ffecom_multi_type_node_,\n \t\t\t    ffecom_multi_retval_);\n \t      t = ffecom_2 (COMPONENT_REF, ffecom_tree_type[bt][kt],\n \t\t\t    t, ffecom_multi_fields_[bt][kt]);\n \n-\t      resume_momentary (yes);\n \t      break;\n \t    }\n \n-\t  yes = suspend_momentary ();\n-\n \t  t = build_decl (VAR_DECL,\n \t\t\t  ffecom_get_identifier_ (ffesymbol_text (s)),\n \t\t\t  ffecom_tree_type[bt][kt]);\n@@ -7862,7 +7774,6 @@ ffecom_sym_transform_ (ffesymbol s)\n \n \t  ffecom_func_result_ = t;\n \n-\t  resume_momentary (yes);\n \t  break;\n \n \tcase FFEINFO_whereDUMMY:\n@@ -8208,7 +8119,6 @@ ffecom_sym_transform_ (ffesymbol s)\n \t    tree ct;\n \t    ffestorag st = ffesymbol_storage (s);\n \t    tree type;\n-\t    int yes;\n \n \t    cs = ffesymbol_common (s);\t/* The COMMON area itself.  */\n \t    if (st != NULL)\t/* Else not laid out. */\n@@ -8217,8 +8127,6 @@ ffecom_sym_transform_ (ffesymbol s)\n \t\tst = ffesymbol_storage (s);\n \t      }\n \n-\t    yes = suspend_momentary ();\n-\n \t    type = ffecom_type_localvar_ (s, bt, kt);\n \n \t    cg = ffesymbol_global (cs);\t/* The global COMMON info.  */\n@@ -8261,8 +8169,6 @@ ffecom_sym_transform_ (ffesymbol s)\n \n \t\taddr = TRUE;\n \t      }\n-\n-\t    resume_momentary (yes);\n \t  }\n \t  break;\n \n@@ -8619,7 +8525,6 @@ static ffesymbol\n ffecom_sym_transform_assign_ (ffesymbol s)\n {\n   tree t;\t\t\t/* Transformed thingy. */\n-  int yes;\n   int old_lineno = lineno;\n   const char *old_input_filename = input_filename;\n \n@@ -8638,8 +8543,6 @@ ffecom_sym_transform_assign_ (ffesymbol s)\n \n   assert (!ffecom_transform_only_dummies_);\n \n-  yes = suspend_momentary ();\n-\n   t = build_decl (VAR_DECL,\n \t\t  ffecom_get_invented_identifier (\"__g77_ASSIGN_%s\",\n \t\t\t\t\t\t   ffesymbol_text (s)),\n@@ -8683,8 +8586,6 @@ ffecom_sym_transform_assign_ (ffesymbol s)\n   t = start_decl (t, FALSE);\n   finish_decl (t, NULL_TREE, FALSE);\n \n-  resume_momentary (yes);\n-\n   ffesymbol_hook (s).assign_tree = t;\n \n   lineno = old_lineno;\n@@ -8886,7 +8787,6 @@ ffecom_transform_equiv_ (ffestorag eqst)\n   tree init;\n   tree high;\n   bool is_init = ffestorag_is_init (eqst);\n-  int yes;\n \n   assert (eqst != NULL);\n \n@@ -8941,8 +8841,6 @@ ffecom_transform_equiv_ (ffestorag eqst)\n \t\t   &ffecom_member_phase1_,\n \t\t   eqst);\n \n-  yes = suspend_momentary ();\n-\n   high = build_int_2 ((ffestorag_size (eqst)\n \t\t       + ffestorag_modulo (eqst)) - 1, 0);\n   TREE_TYPE (high) = ffecom_integer_type_node;\n@@ -9008,8 +8906,6 @@ ffecom_transform_equiv_ (ffestorag eqst)\n   ffestorag_drive (ffestorag_list_equivs (eqst),\n \t\t   &ffecom_member_phase2_,\n \t\t   eqst);\n-\n-  resume_momentary (yes);\n }\n \n #endif\n@@ -9027,12 +8923,9 @@ ffecom_transform_namelist_ (ffesymbol s)\n   tree nvarsinit;\n   tree field;\n   tree high;\n-  int yes;\n   int i;\n   static int mynumber = 0;\n \n-  yes = suspend_momentary ();\n-\n   nmlt = build_decl (VAR_DECL,\n \t\t     ffecom_get_invented_identifier (\"__g77_namelist_%d\",\n \t\t\t\t\t\t     mynumber++),\n@@ -9095,8 +8988,6 @@ ffecom_transform_namelist_ (ffesymbol s)\n \n   nmlt = ffecom_1 (ADDR_EXPR, build_pointer_type (nmltype), nmlt);\n \n-  resume_momentary (yes);\n-\n   return nmlt;\n }\n \n@@ -9590,11 +9481,8 @@ ffecom_vardesc_ (ffebld expr)\n       tree typeinit;\n       tree field;\n       tree varinits;\n-      int yes;\n       static int mynumber = 0;\n \n-      yes = suspend_momentary ();\n-\n       var = build_decl (VAR_DECL,\n \t\t\tffecom_get_invented_identifier (\"__g77_vardesc_%d\",\n \t\t\t\t\t\t\tmynumber++),\n@@ -9656,8 +9544,6 @@ ffecom_vardesc_ (ffebld expr)\n \n       var = ffecom_1 (ADDR_EXPR, build_pointer_type (vardesctype), var);\n \n-      resume_momentary (yes);\n-\n       ffesymbol_hook (s).vardesc_tree = var;\n     }\n \n@@ -9674,7 +9560,6 @@ ffecom_vardesc_array_ (ffesymbol s)\n   tree item = NULL_TREE;\n   tree var;\n   int i;\n-  int yes;\n   static int mynumber = 0;\n \n   for (i = 0, list = NULL_TREE, b = ffesymbol_namelist (s);\n@@ -9694,8 +9579,6 @@ ffecom_vardesc_array_ (ffesymbol s)\n \t}\n     }\n \n-  yes = suspend_momentary ();\n-\n   item = build_array_type (build_pointer_type (ffecom_type_vardesc_ ()),\n \t\t\t   build_range_type (integer_type_node,\n \t\t\t\t\t     integer_one_node,\n@@ -9711,8 +9594,6 @@ ffecom_vardesc_array_ (ffesymbol s)\n   var = start_decl (var, FALSE);\n   finish_decl (var, list, FALSE);\n \n-  resume_momentary (yes);\n-\n   return var;\n }\n \n@@ -9732,7 +9613,6 @@ ffecom_vardesc_dims_ (ffesymbol s)\n     tree backlist;\n     tree item = NULL_TREE;\n     tree var;\n-    int yes;\n     tree numdim;\n     tree numelem;\n     tree baseoff = NULL_TREE;\n@@ -9805,8 +9685,6 @@ ffecom_vardesc_dims_ (ffesymbol s)\n     numdim = build_tree_list (NULL_TREE, numdim);\n     TREE_CHAIN (numdim) = numelem;\n \n-    yes = suspend_momentary ();\n-\n     item = build_array_type (ffecom_f2c_ftnlen_type_node,\n \t\t\t     build_range_type (integer_type_node,\n \t\t\t\t\t       integer_zero_node,\n@@ -9826,8 +9704,6 @@ ffecom_vardesc_dims_ (ffesymbol s)\n \n     var = ffecom_1 (ADDR_EXPR, build_pointer_type (item), var);\n \n-    resume_momentary (yes);\n-\n     return var;\n   }\n }\n@@ -11126,7 +11002,6 @@ ffecom_end_transition ()\n       tree dt;\n       tree t;\n       tree var;\n-      int yes;\n       static int number = 0;\n \n       callee = ffebld_head (item);\n@@ -11138,8 +11013,6 @@ ffecom_end_transition ()\n \t  t = ffesymbol_hook (s).decl_tree;\n \t}\n \n-      yes = suspend_momentary ();\n-\n       dt = build_pointer_type (TREE_TYPE (t));\n \n       var = build_decl (VAR_DECL,\n@@ -11157,8 +11030,6 @@ ffecom_end_transition ()\n       t = ffecom_1 (ADDR_EXPR, dt, t);\n \n       finish_decl (var, t, FALSE);\n-\n-      resume_momentary (yes);\n     }\n \n   /* This handles any COMMON areas that weren't referenced but have, for\n@@ -12817,7 +12688,6 @@ tree\n ffecom_make_tempvar (const char *commentary, tree type,\n \t\t     ffetargetCharacterSize size, int elements)\n {\n-  int yes;\n   tree t;\n   static int mynumber;\n \n@@ -12826,8 +12696,6 @@ ffecom_make_tempvar (const char *commentary, tree type,\n   if (type == error_mark_node)\n     return error_mark_node;\n \n-  yes = suspend_momentary ();\n-\n   if (size != FFETARGET_charactersizeNONE)\n     type = build_array_type (type,\n \t\t\t     build_range_type (ffecom_f2c_ftnlen_type_node,\n@@ -12848,8 +12716,6 @@ ffecom_make_tempvar (const char *commentary, tree type,\n   t = start_decl (t, FALSE);\n   finish_decl (t, NULL_TREE, FALSE);\n \n-  resume_momentary (yes);\n-\n   return t;\n }\n #endif\n@@ -13670,7 +13536,6 @@ bison_rule_pushlevel_ ()\n   emit_line_note (input_filename, lineno);\n   pushlevel (0);\n   clear_last_expr ();\n-  push_momentary ();\n   expand_start_bindings (0);\n }\n \n@@ -13687,7 +13552,6 @@ bison_rule_compstmt_ ()\n   emit_line_note (input_filename, lineno);\n   expand_end_bindings (getdecls (), keep, 0);\n   t = poplevel (keep, 1, 0);\n-  pop_momentary ();\n \n   return t;\n }\n@@ -13988,7 +13852,6 @@ finish_decl (tree decl, tree init, bool is_top_level)\n {\n   register tree type = TREE_TYPE (decl);\n   int was_incomplete = (DECL_SIZE (decl) == 0);\n-  int temporary = allocation_temporary_p ();\n   bool at_top_level = (current_binding_level == global_binding_level);\n   bool top_level = is_top_level || at_top_level;\n \n@@ -14017,11 +13880,6 @@ finish_decl (tree decl, tree init, bool is_top_level)\n \t}\n     }\n \n-  /* Pop back to the obstack that is current for this binding level. This is\n-     because MAXINDEX, rtl, etc. to be made below must go in the permanent\n-     obstack.  But don't discard the temporary data yet.  */\n-  pop_obstacks ();\n-\n   /* Deduce size of array from initialization, if not already known */\n \n   if (TREE_CODE (type) == ARRAY_TYPE\n@@ -14101,46 +13959,6 @@ finish_decl (tree decl, tree init, bool is_top_level)\n \t\t\t\t0);\n     }\n \n-  if (!(TREE_CODE (decl) == FUNCTION_DECL && DECL_INLINE (decl))\n-      && temporary\n-  /* DECL_INITIAL is not defined in PARM_DECLs, since it shares space with\n-     DECL_ARG_TYPE.  */\n-      && TREE_CODE (decl) != PARM_DECL)\n-    {\n-      /* We need to remember that this array HAD an initialization, but\n-\t discard the actual temporary nodes, since we can't have a permanent\n-\t node keep pointing to them.  */\n-      /* We make an exception for inline functions, since it's normal for a\n-\t local extern redeclaration of an inline function to have a copy of\n-\t the top-level decl's DECL_INLINE.  */\n-      if ((DECL_INITIAL (decl) != 0)\n-\t  && (DECL_INITIAL (decl) != error_mark_node))\n-\t{\n-\t  /* If this is a const variable, then preserve the\n-\t     initializer instead of discarding it so that we can optimize\n-\t     references to it.  */\n-\t  /* This test used to include TREE_STATIC, but this won't be set\n-\t     for function level initializers.  */\n-\t  if (TREE_READONLY (decl))\n-\t    {\n-\t      preserve_initializer ();\n-\n-\t      /* The initializer and DECL must have the same (or equivalent\n-\t\t types), but if the initializer is a STRING_CST, its type\n-\t\t might not be on the right obstack, so copy the type\n-\t\t of DECL.  */\n-\t      TREE_TYPE (DECL_INITIAL (decl)) = type;\n-\t    }\n-\t  else\n-\t    DECL_INITIAL (decl) = error_mark_node;\n-\t}\n-    }\n-\n-  /* If we have gone back from temporary to permanent allocation, actually\n-     free the temporary space that we no longer need.  */\n-  if (temporary && !allocation_temporary_p ())\n-    permanent_allocation (0);\n-\n   /* At the end of a declaration, throw away any variable type sizes of types\n      defined inside that declaration.  There is no use computing them in the\n      following function definition.  */\n@@ -14190,23 +14008,17 @@ finish_function (int nested)\n \n       /* If this is a nested function, protect the local variables in the stack\n \t above us from being collected while we're compiling this function.  */\n-      if (ggc_p && nested)\n+      if (nested)\n \tggc_push_context ();\n \n       /* Run the optimizers and output the assembler code for this function.  */\n       rest_of_compilation (fndecl);\n \n       /* Undo the GC context switch.  */\n-      if (ggc_p && nested)\n+      if (nested)\n \tggc_pop_context ();\n     }\n \n-  /* Free all the tree nodes making up this function.  */\n-  /* Switch back to allocating nodes permanently until we start another\n-     function.  */\n-  if (!nested)\n-    permanent_allocation (1);\n-\n   if (TREE_CODE (fndecl) != ERROR_MARK\n       && !nested\n       && DECL_SAVED_INSNS (fndecl) == 0)\n@@ -14435,8 +14247,6 @@ push_parm_decl (tree parm)\n \n   immediate_size_expand = 0;\n \n-  push_obstacks_nochange ();\n-\n   /* Fill in arg stuff.  */\n \n   DECL_ARG_TYPE (parm) = TREE_TYPE (parm);\n@@ -14517,9 +14327,6 @@ start_decl (tree decl, bool is_top_level)\n      level anyway.  */\n   assert (!is_top_level || !at_top_level);\n \n-  /* The corresponding pop_obstacks is in finish_decl.  */\n-  push_obstacks_nochange ();\n-\n   if (DECL_INITIAL (decl) != NULL_TREE)\n     {\n       assert (DECL_INITIAL (decl) == error_mark_node);\n@@ -14551,14 +14358,6 @@ start_decl (tree decl, bool is_top_level)\n \texpand_decl (tem);\n     }\n \n-  if (DECL_INITIAL (tem) != NULL_TREE)\n-    {\n-      /* When parsing and digesting the initializer, use temporary storage.\n-\t Do this even if we will ignore the value.  */\n-      if (at_top_level)\n-\ttemporary_allocation ();\n-    }\n-\n   return tem;\n }\n \n@@ -14640,11 +14439,6 @@ start_function (tree name, tree type, int nested, int public)\n \t= build_decl (RESULT_DECL, NULL_TREE, restype);\n     }\n \n-  if (!nested)\n-    /* Allocate further tree nodes temporarily during compilation of this\n-       function only.  */\n-    temporary_allocation ();\n-\n   if (!nested && (TREE_CODE (current_function_decl) != ERROR_MARK))\n     TREE_ADDRESSABLE (current_function_decl) = 1;\n \n@@ -15802,10 +15596,6 @@ unsigned_type (type)\n   return type;\n }\n \n-/* Callback routines for garbage collection.  */\n-\n-int ggc_p = 1;\n-\n void \n lang_mark_tree (t)\n      union tree_node *t ATTRIBUTE_UNUSED;"}, {"sha": "425744cb0d64dfb19e5a496e33b3d43572e6327e", "filename": "gcc/f/std.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Ff%2Fstd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Ff%2Fstd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstd.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -1,5 +1,5 @@\n /* std.c -- Implementation File (module.c template V1.0)\n-   Copyright (C) 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1996, 2000 Free Software Foundation, Inc.\n    Contributed by James Craig Burley.\n \n This file is part of GNU Fortran.\n@@ -687,7 +687,6 @@ ffestd_stmt_pass_ ()\n       tree duplicate;\n \n       expand_start_case (0, which, TREE_TYPE (which), \"entrypoint dispatch\");\n-      push_momentary ();\n \n       stmt = ffestd_stmt_list_.first;\n       do\n@@ -709,17 +708,14 @@ ffestd_stmt_pass_ ()\n \t      label = ffecom_temp_label ();\n \t      TREE_USED (label) = 1;\n \t      expand_goto (label);\n-\t      clear_momentary ();\n \n \t      ffesymbol_hook (stmt->u.R1226.entry).length_tree = label;\n \t    }\n \t  stmt = stmt->next;\n \t}\n       while (--ents != 0);\n \n-      pop_momentary ();\n       expand_end_case (which);\n-      clear_momentary ();\n     }\n #endif\n "}, {"sha": "5b4c68eb2d19e9686358eacbd22bb5af6e079a6b", "filename": "gcc/f/ste.c", "status": "modified", "additions": 2, "deletions": 59, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Ff%2Fste.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Ff%2Fste.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fste.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -440,8 +440,6 @@ ffeste_end_block_ (ffestw block)\n \n   free (b);\n \n-  clear_momentary ();\n-\n   ffecom_end_compstmt ();\n }\n \n@@ -482,8 +480,6 @@ ffeste_end_stmt_(void)\n \n   free (b);\n \n-  clear_momentary ();\n-\n   ffecom_end_compstmt ();\n }\n \n@@ -493,18 +489,15 @@ ffeste_end_stmt_(void)\n #define ffeste_end_block_(b)\t\\\n   do\t\t\t\t\\\n     {\t\t\t\t\\\n-      clear_momentary ();\t\\\n       ffecom_end_compstmt ();\t\\\n     } while(0)\n #define ffeste_start_stmt_() ffeste_start_block_(NULL)\n #define ffeste_end_stmt_() ffeste_end_block_(NULL)\n \n #endif  /* ! defined (ENABLE_CHECKING) */\n \n-/* Begin an iterative DO loop.  Pass the block to start if applicable.\n-\n-   NOTE: Does _two_ push_momentary () calls, which the caller must\n-   undo (by calling ffeste_end_iterdo_).  */\n+/* Begin an iterative DO loop.  Pass the block to start if\n+   applicable.  */\n \n #if FFECOM_targetCURRENT == FFECOM_targetGCC\n static void\n@@ -573,8 +566,6 @@ ffeste_begin_iterdo_ (ffestw block, tree *xtvar, tree *xtincr,\n \n   tincr_saved = ffecom_save_tree (tincr);\n \n-  preserve_momentary ();\n-\n   /* Want to have tstart, tend for just this statement. */\n \n   ffeste_start_stmt_ ();\n@@ -1210,7 +1201,6 @@ ffeste_io_ialist_ (bool have_err,\n   static tree f2c_alist_struct = NULL_TREE;\n   tree t;\n   tree ttype;\n-  int yes;\n   tree field;\n   tree inits, initn;\n   bool constantp = TRUE;\n@@ -1277,8 +1267,6 @@ ffeste_io_ialist_ (bool have_err,\n   TREE_CONSTANT (inits) = constantp ? 1 : 0;\n   TREE_STATIC (inits) = 1;\n \n-  yes = suspend_momentary ();\n-\n   t = build_decl (VAR_DECL,\n \t\t  ffecom_get_invented_identifier (\"__g77_alist_%d\",\n \t\t\t\t\t\t  mynumber++),\n@@ -1287,8 +1275,6 @@ ffeste_io_ialist_ (bool have_err,\n   t = ffecom_start_decl (t, 1);\n   ffecom_finish_decl (t, inits, 0);\n \n-  resume_momentary (yes);\n-\n   /* Prepare run-time expressions.  */\n \n   if (! unitexp)\n@@ -1343,7 +1329,6 @@ ffeste_io_cilist_ (bool have_err,\n   static tree f2c_cilist_struct = NULL_TREE;\n   tree t;\n   tree ttype;\n-  int yes;\n   tree field;\n   tree inits, initn;\n   bool constantp = TRUE;\n@@ -1489,8 +1474,6 @@ ffeste_io_cilist_ (bool have_err,\n   TREE_CONSTANT (inits) = constantp ? 1 : 0;\n   TREE_STATIC (inits) = 1;\n \n-  yes = suspend_momentary ();\n-\n   t = build_decl (VAR_DECL,\n \t\t  ffecom_get_invented_identifier (\"__g77_cilist_%d\",\n \t\t\t\t\t\t  mynumber++),\n@@ -1499,8 +1482,6 @@ ffeste_io_cilist_ (bool have_err,\n   t = ffecom_start_decl (t, 1);\n   ffecom_finish_decl (t, inits, 0);\n \n-  resume_momentary (yes);\n-\n   /* Prepare run-time expressions.  */\n \n   if (! unitexp)\n@@ -1569,7 +1550,6 @@ ffeste_io_cllist_ (bool have_err,\n   static tree f2c_close_struct = NULL_TREE;\n   tree t;\n   tree ttype;\n-  int yes;\n   tree field;\n   tree inits, initn;\n   tree ignore;\t\t\t/* Ignore length info for certain fields. */\n@@ -1625,8 +1605,6 @@ ffeste_io_cllist_ (bool have_err,\n   TREE_CONSTANT (inits) = constantp ? 1 : 0;\n   TREE_STATIC (inits) = 1;\n \n-  yes = suspend_momentary ();\n-\n   t = build_decl (VAR_DECL,\n \t\t  ffecom_get_invented_identifier (\"__g77_cllist_%d\",\n \t\t\t\t\t\t  mynumber++),\n@@ -1635,8 +1613,6 @@ ffeste_io_cllist_ (bool have_err,\n   t = ffecom_start_decl (t, 1);\n   ffecom_finish_decl (t, inits, 0);\n \n-  resume_momentary (yes);\n-\n   /* Prepare run-time expressions.  */\n \n   if (! unitexp)\n@@ -1692,7 +1668,6 @@ ffeste_io_icilist_ (bool have_err,\n   static tree f2c_icilist_struct = NULL_TREE;\n   tree t;\n   tree ttype;\n-  int yes;\n   tree field;\n   tree inits, initn;\n   bool constantp = TRUE;\n@@ -1839,8 +1814,6 @@ ffeste_io_icilist_ (bool have_err,\n   TREE_CONSTANT (inits) = constantp ? 1 : 0;\n   TREE_STATIC (inits) = 1;\n \n-  yes = suspend_momentary ();\n-\n   t = build_decl (VAR_DECL,\n \t\t  ffecom_get_invented_identifier (\"__g77_icilist_%d\",\n \t\t\t\t\t\t  mynumber++),\n@@ -1849,8 +1822,6 @@ ffeste_io_icilist_ (bool have_err,\n   t = ffecom_start_decl (t, 1);\n   ffecom_finish_decl (t, inits, 0);\n \n-  resume_momentary (yes);\n-\n   /* Prepare run-time expressions.  */\n \n   if (! unitexp)\n@@ -1940,7 +1911,6 @@ ffeste_io_inlist_ (bool have_err,\n   static tree f2c_inquire_struct = NULL_TREE;\n   tree t;\n   tree ttype;\n-  int yes;\n   tree field;\n   tree inits, initn;\n   bool constantp = TRUE;\n@@ -2095,8 +2065,6 @@ ffeste_io_inlist_ (bool have_err,\n   TREE_CONSTANT (inits) = constantp ? 1 : 0;\n   TREE_STATIC (inits) = 1;\n \n-  yes = suspend_momentary ();\n-\n   t = build_decl (VAR_DECL,\n \t\t  ffecom_get_invented_identifier (\"__g77_inlist_%d\",\n \t\t\t\t\t\t  mynumber++),\n@@ -2105,8 +2073,6 @@ ffeste_io_inlist_ (bool have_err,\n   t = ffecom_start_decl (t, 1);\n   ffecom_finish_decl (t, inits, 0);\n \n-  resume_momentary (yes);\n-\n   /* Prepare run-time expressions.  */\n \n   ffeste_f2c_prepare_int_ (unit_spec, unitexp);\n@@ -2196,7 +2162,6 @@ ffeste_io_olist_ (bool have_err,\n   static tree f2c_open_struct = NULL_TREE;\n   tree t;\n   tree ttype;\n-  int yes;\n   tree field;\n   tree inits, initn;\n   tree ignore;\t\t\t/* Ignore length info for certain fields. */\n@@ -2280,8 +2245,6 @@ ffeste_io_olist_ (bool have_err,\n   TREE_CONSTANT (inits) = constantp ? 1 : 0;\n   TREE_STATIC (inits) = 1;\n \n-  yes = suspend_momentary ();\n-\n   t = build_decl (VAR_DECL,\n \t\t  ffecom_get_invented_identifier (\"__g77_olist_%d\",\n \t\t\t\t\t\t  mynumber++),\n@@ -2290,8 +2253,6 @@ ffeste_io_olist_ (bool have_err,\n   t = ffecom_start_decl (t, 1);\n   ffecom_finish_decl (t, inits, 0);\n \n-  resume_momentary (yes);\n-\n   /* Prepare run-time expressions.  */\n \n   if (! unitexp)\n@@ -2974,8 +2935,6 @@ ffeste_R810 (ffestw block, unsigned long casenum)\n \t  c->previous_stmt = c->previous_stmt->previous_stmt;\n \t}\n       while ((c != (ffestwCase) &s->first_rel) && (casenum == c->casenum));\n-\n-    clear_momentary ();\n   }\n #else\n #error\n@@ -3305,8 +3264,6 @@ ffeste_R838 (ffelab label, ffebld target)\n \t\t\t\t   target_tree,\n \t\t\t\t   label_tree);\n \texpand_expr_stmt (expr_tree);\n-\n-\tclear_momentary ();\n       }\n   }\n #else\n@@ -3340,8 +3297,6 @@ ffeste_R839 (ffebld target)\n       error (\"ASSIGNed GOTO target variable is too small\");\n \n     expand_computed_goto (convert (TREE_TYPE (null_pointer_node), t));\n-\n-    clear_momentary ();\n   }\n #else\n #error\n@@ -3556,8 +3511,6 @@ ffeste_R842 (ffebld expr)\n     TREE_SIDE_EFFECTS (callit) = 1;\n \n     expand_expr_stmt (callit);\n-\n-    clear_momentary ();\n   }\n #else\n #error\n@@ -3641,8 +3594,6 @@ ffeste_R843 (ffebld expr)\n     TREE_SIDE_EFFECTS (callit) = 1;\n \n     expand_expr_stmt (callit);\n-\n-    clear_momentary ();\n   }\n #if 0\t\t\t\t/* Old approach for phantom g77 run-time\n \t\t\t\t   library. */\n@@ -3668,8 +3619,6 @@ ffeste_R843 (ffebld expr)\n     TREE_SIDE_EFFECTS (callit) = 1;\n \n     expand_expr_stmt (callit);\n-\n-    clear_momentary ();\n   }\n #endif\n #else\n@@ -4998,9 +4947,6 @@ ffeste_R1001 (ffests s)\n     TREE_CONSTANT (t) = 1;\n     TREE_STATIC (t) = 1;\n \n-    push_obstacks_nochange ();\n-    end_temporary_allocation ();\n-\n     var = ffecom_lookup_label (ffeste_label_formatdef_);\n     if ((var != NULL_TREE)\n \t&& (TREE_CODE (var) == VAR_DECL))\n@@ -5019,9 +4965,6 @@ ffeste_R1001 (ffests s)\n \texpand_decl_init (var);\n       }\n \n-    resume_temporary_allocation ();\n-    pop_obstacks ();\n-\n     ffeste_label_formatdef_ = NULL;\n   }\n #else"}, {"sha": "2f56e91dde8be2e3da29906fdc1728782e831d7d", "filename": "gcc/flow.c", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -168,12 +168,10 @@ Boston, MA 02111-1307, USA.  */\n #define EPILOGUE_USES(REGNO)  0\n #endif\n \n-/* The contents of the current function definition are allocated\n-   in this obstack, and all are freed at the end of the function.\n-   For top-level functions, this is temporary_obstack.\n-   Separate obstacks are made for nested functions.  */\n+/* The obstack on which the flow graph components are allocated.  */\n \n-extern struct obstack *function_obstack;\n+struct obstack flow_obstack;\n+static char *flow_firstobj;\n \n /* Number of basic blocks in the current function.  */\n \n@@ -439,6 +437,7 @@ static void flow_loop_tree_node_add\tPARAMS ((struct loop *, struct loop *));\n static void flow_loops_tree_build\tPARAMS ((struct loops *));\n static int flow_loop_level_compute\tPARAMS ((struct loop *, int));\n static int flow_loops_level_compute\tPARAMS ((struct loops *));\n+static void allocate_bb_life_data\tPARAMS ((void));\n \f\n /* Find basic blocks of the current function.\n    F is the first insn of the function and NREGS the number of register\n@@ -942,7 +941,7 @@ create_basic_block (index, head, end, bb_note)\n \t the same lifetime by allocating it off the function obstack\n \t rather than using malloc.  */\n \n-      bb = (basic_block) obstack_alloc (function_obstack, sizeof (*bb));\n+      bb = (basic_block) obstack_alloc (&flow_obstack, sizeof (*bb));\n       memset (bb, 0, sizeof (*bb));\n \n       if (GET_CODE (head) == CODE_LABEL)\n@@ -1479,7 +1478,7 @@ split_block (bb, insn)\n     return 0;\n \n   /* Create the new structures.  */\n-  new_bb = (basic_block) obstack_alloc (function_obstack, sizeof (*new_bb));\n+  new_bb = (basic_block) obstack_alloc (&flow_obstack, sizeof (*new_bb));\n   new_edge = (edge) xcalloc (1, sizeof (*new_edge));\n   n_edges++;\n \n@@ -1532,8 +1531,8 @@ split_block (bb, insn)\n \n   if (bb->global_live_at_start)\n     {\n-      new_bb->global_live_at_start = OBSTACK_ALLOC_REG_SET (function_obstack);\n-      new_bb->global_live_at_end = OBSTACK_ALLOC_REG_SET (function_obstack);\n+      new_bb->global_live_at_start = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n+      new_bb->global_live_at_end = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n       COPY_REG_SET (new_bb->global_live_at_end, bb->global_live_at_end);\n \n       /* We now have to calculate which registers are live at the end\n@@ -1584,7 +1583,7 @@ split_edge (edge_in)\n   }\n \n   /* Create the new structures.  */\n-  bb = (basic_block) obstack_alloc (function_obstack, sizeof (*bb));\n+  bb = (basic_block) obstack_alloc (&flow_obstack, sizeof (*bb));\n   edge_out = (edge) xcalloc (1, sizeof (*edge_out));\n   n_edges++;\n \n@@ -1593,8 +1592,8 @@ split_edge (edge_in)\n   /* ??? This info is likely going to be out of date very soon.  */\n   if (old_succ->global_live_at_start)\n     {\n-      bb->global_live_at_start = OBSTACK_ALLOC_REG_SET (function_obstack);\n-      bb->global_live_at_end = OBSTACK_ALLOC_REG_SET (function_obstack);\n+      bb->global_live_at_start = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n+      bb->global_live_at_end = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n       COPY_REG_SET (bb->global_live_at_start, old_succ->global_live_at_start);\n       COPY_REG_SET (bb->global_live_at_end, old_succ->global_live_at_start);\n     }\n@@ -3356,7 +3355,7 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n \n       if (bb->local_set == NULL)\n \t{\n-\t  bb->local_set = OBSTACK_ALLOC_REG_SET (function_obstack);\n+\t  bb->local_set = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n \t  rescan = 1;\n \t}\n       else\n@@ -3465,7 +3464,7 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n /* Allocate the permanent data structures that represent the results\n    of life analysis.  Not static since used also for stupid life analysis.  */\n \n-void\n+static void\n allocate_bb_life_data ()\n {\n   register int i;\n@@ -3474,16 +3473,16 @@ allocate_bb_life_data ()\n     {\n       basic_block bb = BASIC_BLOCK (i);\n \n-      bb->global_live_at_start = OBSTACK_ALLOC_REG_SET (function_obstack);\n-      bb->global_live_at_end = OBSTACK_ALLOC_REG_SET (function_obstack);\n+      bb->global_live_at_start = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n+      bb->global_live_at_end = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n     }\n \n   ENTRY_BLOCK_PTR->global_live_at_end\n-    = OBSTACK_ALLOC_REG_SET (function_obstack);\n+    = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n   EXIT_BLOCK_PTR->global_live_at_start\n-    = OBSTACK_ALLOC_REG_SET (function_obstack);\n+    = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n \n-  regs_live_at_setjmp = OBSTACK_ALLOC_REG_SET (function_obstack);\n+  regs_live_at_setjmp = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n }\n \n void\n@@ -8363,3 +8362,23 @@ reg_set_to_hard_reg_set (to, from)\n        SET_HARD_REG_BIT (*to, i);\n      });\n }\n+\n+/* Called once at intialization time.  */\n+\n+void\n+init_flow ()\n+{\n+  static int initialized;\n+\n+  if (!initialized)\n+    {\n+      gcc_obstack_init (&flow_obstack);\n+      flow_firstobj = (char *) obstack_alloc (&flow_obstack, 0);\n+      initialized = 1;\n+    }\n+  else\n+    {\n+      obstack_free (&flow_obstack, flow_firstobj);\n+      flow_firstobj = (char *) obstack_alloc (&flow_obstack, 0);\n+    }\n+}"}, {"sha": "c8b0fd2486dbe80e45127e742c54b4dbcc02bee1", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -1860,7 +1860,7 @@ size_int_type_wide (number, type)\n   static int init_p = 0;\n   tree t;\n \n-  if (ggc_p && ! init_p)\n+  if (! init_p)\n     {\n       ggc_add_tree_root ((tree *) size_table,\n \t\t\t sizeof size_table / sizeof (tree));\n@@ -1877,21 +1877,11 @@ size_int_type_wide (number, type)\n \t  if (TREE_TYPE (t) == type)\n \t    return t;\n \n-      if (! ggc_p)\n-\t{\n-\t  /* Make this a permanent node.  */\n-\t  push_obstacks_nochange ();\n-\t  end_temporary_allocation ();\n-\t}\n-\n       t = build_int_2 (number, 0);\n       TREE_TYPE (t) = type;\n       TREE_CHAIN (t) = size_table[number];\n       size_table[number] = t;\n \n-      if (! ggc_p)\n-\tpop_obstacks ();\n-\n       return t;\n     }\n "}, {"sha": "4cf71195a1f7569f47d4273427e73c5346e28d6c", "filename": "gcc/function.c", "status": "modified", "additions": 8, "deletions": 45, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -360,7 +360,6 @@ push_function_context_to (context)\n   outer_function_chain = p;\n   p->fixup_var_refs_queue = 0;\n \n-  save_tree_status (p);\n   if (save_lang_status)\n     (*save_lang_status) (p);\n   if (save_machine_status)\n@@ -392,7 +391,6 @@ pop_function_context_from (context)\n   current_function_decl = p->decl;\n   reg_renumber = 0;\n \n-  restore_tree_status (p);\n   restore_emit_status (p);\n \n   if (restore_machine_status)\n@@ -547,12 +545,6 @@ assign_stack_local_1 (mode, size, align, function)\n   int bigend_correction = 0;\n   int alignment;\n \n-  /* Allocate in the memory associated with the function in whose frame\n-     we are assigning.  */\n-  if (function != cfun)\n-    push_obstacks (function->function_obstack,\n-\t\t   function->function_maybepermanent_obstack);\n-\n   if (align == 0)\n     {\n       tree type;\n@@ -624,9 +616,6 @@ assign_stack_local_1 (mode, size, align, function)\n   function->x_stack_slot_list\n     = gen_rtx_EXPR_LIST (VOIDmode, x, function->x_stack_slot_list);\n \n-  if (function != cfun)\n-    pop_obstacks ();\n-\n   return x;\n }\n \n@@ -1637,7 +1626,7 @@ find_fixup_replacement (replacements, x)\n \n   if (p == 0)\n     {\n-      p = (struct fixup_replacement *) oballoc (sizeof (struct fixup_replacement));\n+      p = (struct fixup_replacement *) xmalloc (sizeof (struct fixup_replacement));\n       p->old = x;\n       p->new = 0;\n       p->next = *replacements;\n@@ -1800,6 +1789,8 @@ fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel, ht)\n \n \t      while (replacements)\n \t\t{\n+\t\t  struct fixup_replacement *next;\n+\n \t\t  if (GET_CODE (replacements->new) == REG)\n \t\t    {\n \t\t      rtx insert_before;\n@@ -1835,7 +1826,9 @@ fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel, ht)\n \t\t      emit_insn_before (seq, insert_before);\n \t\t    }\n \n-\t\t  replacements = replacements->next;\n+\t\t  next = replacements->next;\n+\t\t  free (replacements);\n+\t\t  replacements = next;\n \t\t}\n \t    }\n \n@@ -3306,15 +3299,8 @@ insns_for_mem_walk (r, data)\n \t we process the INSNs in order, we know that if we have\n \t recorded it it must be at the front of the list.  */\n       if (ifme && (!ifme->insns || XEXP (ifme->insns, 0) != ifmwi->insn))\n-\t{\n-\t  /* We do the allocation on the same obstack as is used for\n-\t     the hash table since this memory will not be used once\n-\t     the hash table is deallocated.  */\n-\t  push_obstacks (&ifmwi->ht->memory, &ifmwi->ht->memory);\n-\t  ifme->insns = gen_rtx_EXPR_LIST (VOIDmode, ifmwi->insn,\n-\t\t\t\t\t   ifme->insns);\n-\t  pop_obstacks ();\n-\t}\n+\tifme->insns = gen_rtx_EXPR_LIST (VOIDmode, ifmwi->insn,\n+\t\t\t\t\t ifme->insns);\n     }\n \n   return 0;\n@@ -3556,13 +3542,6 @@ instantiate_decls (fndecl, valid_only)\n {\n   tree decl;\n \n-  if (DECL_SAVED_INSNS (fndecl))\n-    /* When compiling an inline function, the obstack used for\n-       rtl allocation is the maybepermanent_obstack.  Calling\n-       `resume_temporary_allocation' switches us back to that\n-       obstack while we process this function's parameters.  */\n-    resume_temporary_allocation ();\n-\n   /* Process all parameters of the function.  */\n   for (decl = DECL_ARGUMENTS (fndecl); decl; decl = TREE_CHAIN (decl))\n     {\n@@ -3579,15 +3558,6 @@ instantiate_decls (fndecl, valid_only)\n \n   /* Now process all variables defined in the function or its subblocks.  */\n   instantiate_decls_1 (DECL_INITIAL (fndecl), valid_only);\n-\n-  if (DECL_INLINE (fndecl) || DECL_DEFER_OUTPUT (fndecl))\n-    {\n-      /* Save all rtl allocated for this function by raising the\n-\t high-water mark on the maybepermanent_obstack.  */\n-      preserve_data ();\n-      /* All further rtl allocation is now done in the current_obstack.  */\n-      rtl_in_current_obstack ();\n-    }\n }\n \n /* Subroutine of instantiate_decls: Process all decls in the given\n@@ -5587,21 +5557,16 @@ trampoline_address (function)\n      by expand_function_end.  */\n   if (fp != 0)\n     {\n-      push_obstacks (fp->function_maybepermanent_obstack,\n-\t\t     fp->function_maybepermanent_obstack);\n       rtlexp = make_node (RTL_EXPR);\n       RTL_EXPR_RTL (rtlexp) = tramp;\n       fp->x_trampoline_list = tree_cons (function, rtlexp,\n \t\t\t\t\t fp->x_trampoline_list);\n-      pop_obstacks ();\n     }\n   else\n     {\n       /* Make the RTL_EXPR node temporary, not momentary, so that the\n \t trampoline_list doesn't become garbage.  */\n-      int momentary = suspend_momentary ();\n       rtlexp = make_node (RTL_EXPR);\n-      resume_momentary (momentary);\n \n       RTL_EXPR_RTL (rtlexp) = tramp;\n       trampoline_list = tree_cons (function, rtlexp, trampoline_list);\n@@ -6554,10 +6519,8 @@ expand_function_end (filename, line, end_bindings)\n \t initializing trampolines.  */\n       if (initial_trampoline == 0)\n \t{\n-\t  end_temporary_allocation ();\n \t  initial_trampoline\n \t    = gen_rtx_MEM (BLKmode, assemble_trampoline_template ());\n-\t  resume_temporary_allocation ();\n \n \t  ggc_add_rtx_root (&initial_trampoline, 1);\n \t}"}, {"sha": "3ea4c838d43fa8701b9e8445e1b2ab420cf6f818", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -433,20 +433,6 @@ struct function\n      during the nested function.  */\n   struct var_refs_queue *fixup_var_refs_queue;\n \n-  /* For tree.c.  */\n-  int all_types_permanent;\n-  struct momentary_level *momentary_stack;\n-  char *maybepermanent_firstobj;\n-  char *temporary_firstobj;\n-  char *momentary_firstobj;\n-  char *momentary_function_firstobj;\n-  struct obstack *current_obstack;\n-  struct obstack *function_obstack;\n-  struct obstack *function_maybepermanent_obstack;\n-  struct obstack *expression_obstack;\n-  struct obstack *saveable_obstack;\n-  struct obstack *rtl_obstack;\n-\n   /* For integrate.c.  */\n   int inlinable;\n   int no_debugging_symbols;\n@@ -590,8 +576,6 @@ extern void (*restore_lang_status)\tPARAMS ((struct function *));\n extern void (*free_lang_status)         PARAMS ((struct function *));\n \n /* Save and restore status information for a nested function.  */\n-extern void save_tree_status\t\tPARAMS ((struct function *));\n-extern void restore_tree_status\t\tPARAMS ((struct function *));\n extern void restore_emit_status\t\tPARAMS ((struct function *));\n extern void free_after_parsing\t\tPARAMS ((struct function *));\n extern void free_after_compilation\tPARAMS ((struct function *));"}, {"sha": "36ca4033f9322fdb0b0e3d988bc635a4ae593532", "filename": "gcc/gcse.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -817,8 +817,6 @@ compute_can_copy ()\n #ifndef AVOID_CCMODE_COPIES\n   rtx reg,insn;\n #endif\n-  char *free_point = (char *) oballoc (1);\n-\n   bzero (can_copy_p, NUM_MACHINE_MODES);\n \n   start_sequence ();\n@@ -838,9 +836,6 @@ compute_can_copy ()\n       can_copy_p[i] = 1;\n \n   end_sequence ();\n-\n-  /* Free the objects we just allocated.  */\n-  obfree (free_point);\n }\n \f\n /* Cover function to xmalloc to record bytes allocated.  */"}, {"sha": "0796a1b39dd45e265acb3381f90749adb3894319", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 12, "deletions": 75, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -1784,20 +1784,7 @@ operate_exp (op, left, right)\n \t  /* If the resulting cond is trivial (all alternatives\n \t     give the same value), optimize it away.  */\n \t  if (allsame)\n-\t    {\n-\t      if (!ggc_p)\n-\t\tobstack_free (rtl_obstack, newexp);\n-\t      return operate_exp (op, left, XEXP (right, 1));\n-\t    }\n-\n-\t  /* If the result is the same as the RIGHT operand,\n-\t     just use that.  */\n-\t  if (rtx_equal_p (newexp, right))\n-\t    {\n-\t      if (!ggc_p)\n-\t\tobstack_free (rtl_obstack, newexp);\n-\t      return right;\n-\t    }\n+\t    return operate_exp (op, left, XEXP (right, 1));\n \n \t  return newexp;\n \t}\n@@ -1843,20 +1830,12 @@ operate_exp (op, left, right)\n       /* If the cond is trivial (all alternatives give the same value),\n \t optimize it away.  */\n       if (allsame)\n-\t{\n-\t  if (!ggc_p)\n-\t    obstack_free (rtl_obstack, newexp);\n-\t  return operate_exp (op, XEXP (left, 1), right);\n-\t}\n+\treturn operate_exp (op, XEXP (left, 1), right);\n \n       /* If the result is the same as the LEFT operand,\n \t just use that.  */\n       if (rtx_equal_p (newexp, left))\n-\t{\n-\t  if (!ggc_p)\n-\t    obstack_free (rtl_obstack, newexp);\n-\t  return left;\n-\t}\n+\treturn left;\n \n       return newexp;\n     }\n@@ -2675,18 +2654,12 @@ simplify_cond (exp, insn_code, insn_index)\n \n   if (len == 0)\n     {\n-      if (!ggc_p)\n-\tobstack_free (rtl_obstack, first_spacer);\n       if (GET_CODE (defval) == COND)\n \treturn simplify_cond (defval, insn_code, insn_index);\n       return defval;\n     }\n   else if (allsame)\n-    {\n-      if (!ggc_p)\n-\tobstack_free (rtl_obstack, first_spacer);\n-      return exp;\n-    }\n+    return exp;\n   else\n     {\n       rtx newexp = rtx_alloc (COND);\n@@ -3200,7 +3173,6 @@ simplify_test_exp (exp, insn_code, insn_index)\n   struct insn_ent *ie;\n   int i;\n   rtx newexp = exp;\n-  char *spacer = (char *) obstack_finish (rtl_obstack);\n \n   /* Don't re-simplify something we already simplified.  */\n   if (RTX_UNCHANGING_P (exp) || MEM_IN_STRUCT_P (exp))\n@@ -3212,19 +3184,11 @@ simplify_test_exp (exp, insn_code, insn_index)\n       left = SIMPLIFY_TEST_EXP (XEXP (exp, 0), insn_code, insn_index);\n       SIMPLIFY_ALTERNATIVE (left);\n       if (left == false_rtx)\n-\t{\n-\t  if (!ggc_p)\n-\t    obstack_free (rtl_obstack, spacer);\n-\t  return false_rtx;\n-\t}\n+\treturn false_rtx;\n       right = SIMPLIFY_TEST_EXP (XEXP (exp, 1), insn_code, insn_index);\n       SIMPLIFY_ALTERNATIVE (right);\n       if (left == false_rtx)\n-\t{\n-\t  if (!ggc_p)\n-\t    obstack_free (rtl_obstack, spacer);\n-\t  return false_rtx;\n-\t}\n+\treturn false_rtx;\n \n       /* If either side is an IOR and we have (eq_attr \"alternative\" ..\")\n \t present on both sides, apply the distributive law since this will\n@@ -3253,11 +3217,7 @@ simplify_test_exp (exp, insn_code, insn_index)\n \tleft = simplify_and_tree (left, &right, insn_code, insn_index);\n \n       if (left == false_rtx || right == false_rtx)\n-\t{\n-\t  if (!ggc_p)\n-\t    obstack_free (rtl_obstack, spacer);\n-\t  return false_rtx;\n-\t}\n+\treturn false_rtx;\n       else if (left == true_rtx)\n \t{\n \t  return right;\n@@ -3313,30 +3273,18 @@ simplify_test_exp (exp, insn_code, insn_index)\n       left = SIMPLIFY_TEST_EXP (XEXP (exp, 0), insn_code, insn_index);\n       SIMPLIFY_ALTERNATIVE (left);\n       if (left == true_rtx)\n-\t{\n-\t  if (!ggc_p)\n-\t    obstack_free (rtl_obstack, spacer);\n-\t  return true_rtx;\n-\t}\n+\treturn true_rtx;\n       right = SIMPLIFY_TEST_EXP (XEXP (exp, 1), insn_code, insn_index);\n       SIMPLIFY_ALTERNATIVE (right);\n       if (right == true_rtx)\n-\t{\n-\t  if (!ggc_p)\n-\t    obstack_free (rtl_obstack, spacer);\n-\t  return true_rtx;\n-\t}\n+\treturn true_rtx;\n \n       right = simplify_or_tree (right, &left, insn_code, insn_index);\n       if (left == XEXP (exp, 0) && right == XEXP (exp, 1))\n \tleft = simplify_or_tree (left, &right, insn_code, insn_index);\n \n       if (right == true_rtx || left == true_rtx)\n-\t{\n-\t  if (!ggc_p)\n-\t    obstack_free (rtl_obstack, spacer);\n-\t  return true_rtx;\n-\t}\n+\treturn true_rtx;\n       else if (left == false_rtx)\n \t{\n \t  return right;\n@@ -3420,17 +3368,9 @@ simplify_test_exp (exp, insn_code, insn_index)\n \treturn XEXP (left, 0);\n \n       if (left == false_rtx)\n-\t{\n-\t  if (!ggc_p)\n-\t    obstack_free (rtl_obstack, spacer);\n-\t  return true_rtx;\n-\t}\n+\treturn true_rtx;\n       else if (left == true_rtx)\n-\t{\n-\t  if (!ggc_p)\n-\t    obstack_free (rtl_obstack, spacer);\n-\t  return false_rtx;\n-\t}\n+\treturn false_rtx;\n \n       /* Try to apply De`Morgan's laws.  */\n       else if (GET_CODE (left) == IOR)\n@@ -3564,7 +3504,6 @@ optimize_attrs ()\n \t  for (iv = insn_code_values[i]; iv; iv = iv->next)\n \t    {\n \t      struct obstack *old = rtl_obstack;\n-\t      char *spacer = (char *) obstack_finish (temp_obstack);\n \n \t      attr = iv->attr;\n \t      av = iv->av;\n@@ -3593,8 +3532,6 @@ optimize_attrs ()\n \t\t  insert_insn_ent (av, ie);\n \t\t  something_changed = 1;\n \t\t}\n-\t      if (!ggc_p)\n-\t\tobstack_free (temp_obstack, spacer);\n \t    }\n \t}\n     }"}, {"sha": "707173f904b9726d70eef3570622081782016fd5", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -321,10 +321,7 @@ gendef (format)\n      the memory and initializes it.  */\n   puts (\"{\");\n   puts (\"  rtx rt;\");\n-  puts (\"  if (ggc_p)\");\n-  printf (\"    rt = ggc_alloc_rtx (%d);\\n\", (int) strlen (format));\n-  puts (\"  else\");\n-  printf (\"    rt = obstack_alloc_rtx (%d);\\n\", (int) strlen (format));\n+  printf (\"  rt = ggc_alloc_rtx (%d);\\n\", (int) strlen (format));\n \n   puts (\"  memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));\\n\");\n   puts (\"  PUT_CODE (rt, code);\");"}, {"sha": "f637581ca94d7a7b3b59ff5c92c36c53eb1a3567", "filename": "gcc/ggc-callbacks.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fggc-callbacks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fggc-callbacks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-callbacks.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -25,8 +25,6 @@\n #include \"tm_p.h\"\n #include \"ggc.h\"\n \n-int ggc_p = 0;\n-\n void ATTRIBUTE_NORETURN\n lang_mark_tree (t)\n      union tree_node *t ATTRIBUTE_UNUSED;"}, {"sha": "e75ff4a687d0592e77077a085039bba6e87bf976", "filename": "gcc/ggc-none.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fggc-none.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fggc-none.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-none.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -1,5 +1,5 @@\n /* Null garbage collection for the GNU compiler.\n-   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n \n    This file is part of GNU CC.\n \n@@ -32,9 +32,6 @@\n #include \"tm_p.h\"\n #include \"ggc.h\"\n \n-/* For now, keep using the old obstack scheme in the gen* programs.  */\n-int ggc_p = 0;\n-\n void *\n ggc_alloc (size)\n      size_t size;"}, {"sha": "373026ce464bf18f813d20ba9e008f5f762ee4d0", "filename": "gcc/ggc.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -24,10 +24,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Symbols are marked with `ggc' for `gcc gc' so as not to interfere with\n    an external gc library that might be linked in.  */\n \n-/* Language-specific code defines this variable to be either one (if\n-   it wants garbage collection), or zero (if it does not).  */\n-extern int ggc_p;\n-\n /* These structures are defined in various headers throughout the\n    compiler.  However, rather than force everyone who includes this\n    header to include all the headers in which they are declared, we"}, {"sha": "3438790792900173231af0cdbaefa8b55fb87999", "filename": "gcc/integrate.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -444,12 +444,6 @@ save_for_inline (fndecl)\n   in_nonparm_insns = 0;\n   save_parm_insns (insn, first_nonparm_insn);\n \n-  /* We have now allocated all that needs to be allocated permanently\n-     on the rtx obstack.  Set our high-water mark, so that we\n-     can free the rest of this when the time comes.  */\n-\n-  preserve_data ();\n-\n   cfun->inl_max_label_num = max_label_num ();\n   cfun->inl_last_parm_insn = cfun->x_last_parm_insn;\n   cfun->original_arg_vector = argvec;\n@@ -1666,10 +1660,7 @@ integrate_decl_tree (let, map)\n     {\n       tree d;\n \n-      push_obstacks_nochange ();\n-      saveable_allocation ();\n       d = copy_decl_for_inlining (t, map->fndecl, current_function_decl);\n-      pop_obstacks ();\n \n       if (DECL_RTL (t) != 0)\n \t{\n@@ -2779,10 +2770,6 @@ output_inline_function (fndecl)\n   current_function_decl = fndecl;\n   clear_emit_caches ();\n \n-  /* Things we allocate from here on are part of this function, not\n-     permanent.  */\n-  temporary_allocation ();\n-\n   set_new_last_label_num (f->inl_max_label_num);\n \n   /* We're not deferring this any longer.  */"}, {"sha": "aa9bb2bb5468bfe28225810a0ab2efb39b54a3a6", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -1,3 +1,75 @@\n+2000-10-12  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c (temporary_obstack): Remove.\n+\t(make_class): Don't mess with obstascks.\n+\t(push_class): Likewise.\n+\t(set_super_info): Likewise.\n+\t(add_method_1): Likewise.\n+\t(add_method): Likewise.\n+\t(add_field): Likewise.\n+\t(build_utf8_ref): Likewise.\n+\t(build_class_ref): Likewise.\n+\t(build_static_field_ref): Likewise.\n+\t(finish_class): Likewise.\n+\t(push_super_field): Likewise.\n+\t(layout_class): Likewise.\n+\t(layout_class_methods): Likewise.\n+\t(init_class_processing): Likewise.\n+\t* constants.c (get_tag_node): Likewise.\n+\t(build_constant_data_ref): Likewise.\n+\t* decl.c (ggc_p): Remove.\n+\t(copy_lang_decl): Use ggc_alloc.\n+\t(complete_start_java_method): Don't mess with obstacks.\n+\t(start_java_method): Likewise.\n+\t(end_java_method): Likewise.\n+\t* except.c (link_handler): Use xmalloc.\n+\t(free_eh_ranges): New function.\n+\t(method_init_exceptions): Use it.\n+\t(add_handler): Use xmalloc.\n+\t(expand_start_java_handler): Don't mess with obstacks.\n+\t(prepare_eh_table_type): Likewise.\n+\t(expand_end_java_handler): Likewise.\n+\t* expr.c (push_value): Likewise.\n+\t(create_label_decl): Likewise.\n+\t(build_jni_stub): Likewise.\n+\t(java_lang_expand_expr): Likewise.\n+\t(note_instructions): Use xrealloc.\n+\t(java_push_constant_from_pool): Don't mess with obstacks.\n+\t(process_jvm_instruction): Likewise.\n+\t* java-tree.h (cyclic_inheritance_report): Remove duplicate\n+\tdeclaration.\n+\t* jcf-parse.c (get_constant): Don't mess with obstacks.\n+\t(read_class): Likewise.\n+\t(jcf_parse): Likewise.\n+\t* lex.c (expresion_obstack): Remove.\n+\t(java_lex): Don't use obstack_free.\n+\t* parse.h (exit_java_complete_class): Don't mess with obstacks.\n+\t(MANGLE_OUTER_LOCAL_VARIABLE_NAME): Adjust.\n+\t(MANGLE_ALIAS_INITIALIZER_PARAMETER_NAME_ID): Likewise.\n+\t(MANGLE_ALIAS_INITIALIZER_PARAMETER_NAME_STRING): Likewise.\n+\t* parse.y (gaol): Add more GC roots.\n+\t(add_inner_class_fields): Adjust calls to MANGLE_* macros.\n+\t(lookup_field_wrapper): Likewise.\n+\t(obtain_incomplete_type): Don't mess with obstacks.\n+\t(build_alias_initializer_paramter_list): Adjust calls to MANGLE_*\n+\tmacros.\n+\t(craft_constructor): Don't mess with obstacks.\n+\t(safe_layout_class): Likewise.\n+\t(java_complete_class): Likewise.\n+\t(source_end_java_method): Likewise.\n+\t(build_outer_field_access_methods): Likewise.\n+\t(build_outer_method_access_method): Likewise.\n+\t(maybe_build_thisn_access_method): Likewise.\n+\t(build_dot_class_method_invocation): Likewise.\n+\t(java_complete_tree): Likewise.\n+\t(java_complete_lhs): Likewise.\n+\t(do_merge_string_cste): Likewise.\n+\t(patch_string_cst): Likewise.\n+\t(array_constructor_check_entry): Likewise.\n+\t* typeck.c (build_java_array_type): Likewise.\n+\t(parse_signature_string): Likewise.\n+\t(build_java_signature): Likewise.\n+\t\n 2000-10-12  Tom Tromey  <tromey@cygnus.com>\n \n \tFix for PR gcj/356:"}, {"sha": "1b184975dfa8f92862f02096d6914f14dd5e273e", "filename": "gcc/java/class.c", "status": "modified", "additions": 6, "deletions": 31, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -59,7 +59,7 @@ static tree mangle_field PARAMS ((tree, tree));\n static rtx registerClass_libfunc;\n \n extern struct obstack permanent_obstack;\n-extern struct obstack temporary_obstack;\n+struct obstack temporary_obstack;\n \n /* The compiler generates different code depending on whether or not\n    it can assume certain classes have been compiled down to native\n@@ -272,7 +272,6 @@ tree\n make_class ()\n {\n   tree type;\n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n   type = make_node (RECORD_TYPE);\n #ifdef JAVA_USE_HANDLES\n   tree field1 = build_decl (FIELD_DECL, get_identifier (\"obj\"),\n@@ -290,7 +289,6 @@ make_class ()\n   TYPE_BINFO (type) = make_tree_vec (6);\n #endif\n   MAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC (type);\n-  pop_obstacks ();\n \n   return type;\n }\n@@ -327,7 +325,6 @@ push_class (class_type, class_name)\n   const char *save_input_filename = input_filename;\n   int save_lineno = lineno;\n   tree source_name = identifier_subst (class_name, \"\", '.', '/', \".java\");\n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n   CLASS_P (class_type) = 1;\n   input_filename = IDENTIFIER_POINTER (source_name);\n   lineno = 0;\n@@ -353,7 +350,6 @@ push_class (class_type, class_name)\n   }\n #endif\n \n-  pop_obstacks ();\n   return decl;\n }\n \n@@ -384,7 +380,6 @@ set_super_info (access_flags, this_class, super_class, interfaces_count)\n   if (super_class)\n     total_supers++;\n \n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n   TYPE_BINFO_BASETYPES (this_class) = make_tree_vec (total_supers);\n   if (super_class)\n     {\n@@ -396,7 +391,6 @@ set_super_info (access_flags, this_class, super_class, interfaces_count)\n \t= super_binfo;\n       CLASS_HAS_SUPER (this_class) = 1;\n     }\n-  pop_obstacks ();\n \n   if (access_flags & ACC_PUBLIC)    CLASS_PUBLIC (class_decl) = 1;\n   if (access_flags & ACC_FINAL)     CLASS_FINAL (class_decl) = 1;\n@@ -649,7 +643,6 @@ add_method_1 (handle_class, access_flags, name, function_type)\n      tree function_type;\n {\n   tree method_type, fndecl;\n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n \n   method_type = build_java_method_type (function_type,\n \t\t\t\t\thandle_class, access_flags);\n@@ -667,7 +660,6 @@ add_method_1 (handle_class, access_flags, name, function_type)\n \n   TREE_CHAIN (fndecl) = TYPE_METHODS (handle_class);\n   TYPE_METHODS (handle_class) = fndecl;\n-  pop_obstacks ();\n \n   if (access_flags & ACC_PUBLIC) METHOD_PUBLIC (fndecl) = 1;\n   if (access_flags & ACC_PROTECTED) METHOD_PROTECTED (fndecl) = 1;\n@@ -702,13 +694,11 @@ add_method (this_class, access_flags, name, method_sig)\n   tree handle_class = CLASS_TO_HANDLE_TYPE (this_class);\n   tree function_type, fndecl;\n   const unsigned char *sig = (const unsigned char*)IDENTIFIER_POINTER (method_sig);\n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n   if (sig[0] != '(')\n     fatal (\"bad method signature\");\n   function_type = get_type_from_signature (method_sig);\n   fndecl = add_method_1 (handle_class, access_flags, name, function_type);\n   set_java_signature (TREE_TYPE (fndecl), method_sig);\n-  pop_obstacks ();\n   return fndecl;\n }\n \n@@ -721,10 +711,7 @@ add_field (class, name, field_type, flags)\n {\n   int is_static = (flags & ACC_STATIC) != 0;\n   tree field;\n-  /* Push the obstack of field_type ? FIXME */\n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n   field = build_decl (is_static ? VAR_DECL : FIELD_DECL, name, field_type);\n-  pop_obstacks ();\n   TREE_CHAIN (field) = TYPE_FIELDS (class);\n   TYPE_FIELDS (class) = field;\n   DECL_CONTEXT (field) = class;\n@@ -820,7 +807,6 @@ build_utf8_ref (name)\n   if (ref != NULL_TREE)\n     return ref;\n \n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n   ctype = make_node (RECORD_TYPE);\n   str_type = build_prim_array_type (unsigned_byte_type_node,\n \t\t\t\t    name_len + 1); /* Allow for final '\\0'. */\n@@ -872,7 +858,6 @@ build_utf8_ref (name)\n   make_decl_rtl (decl, (char*) 0, 1);\n   ref = build1 (ADDR_EXPR, utf8const_ptr_type, decl);\n   IDENTIFIER_UTF8_REF (name) = ref;\n-  pop_obstacks ();\n   return ref;\n }\n \n@@ -898,7 +883,6 @@ build_class_ref (type)\n \t  decl = IDENTIFIER_GLOBAL_VALUE (decl_name);\n \t  if (decl == NULL_TREE)\n \t    {\n-\t      push_obstacks (&permanent_obstack, &permanent_obstack);\n \t      decl = build_decl (VAR_DECL, decl_name, class_type_node);\n \t      DECL_SIZE (decl) = TYPE_SIZE (class_type_node);\n \t      DECL_SIZE_UNIT (decl) = TYPE_SIZE_UNIT (class_type_node);\n@@ -911,7 +895,6 @@ build_class_ref (type)\n \t      pushdecl_top_level (decl);\n \t      if (is_compiled == 1)\n \t\tDECL_EXTERNAL (decl) = 1;\n-\t      pop_obstacks ();\n \t    }\n \t}\n       else\n@@ -957,15 +940,13 @@ build_class_ref (type)\n \t  decl = IDENTIFIER_GLOBAL_VALUE (decl_name);\n \t  if (decl == NULL_TREE)\n \t    {\n-\t      push_obstacks (&permanent_obstack, &permanent_obstack);\n \t      decl = build_decl (VAR_DECL, decl_name, class_type_node);\n \t      TREE_STATIC (decl) = 1;\n \t      TREE_PUBLIC (decl) = 1;\n \t      make_decl_rtl (decl, NULL, 1);\n \t      pushdecl_top_level (decl);\n \t      if (is_compiled == 1)\n \t\tDECL_EXTERNAL (decl) = 1;\n-\t      pop_obstacks ();\n \t    }\n \t}\n \n@@ -976,11 +957,9 @@ build_class_ref (type)\n     {\n       int index;\n       tree cl;\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n       index = alloc_class_constant (type);\n       cl = build_ref_from_constant_pool (index); \n       TREE_TYPE (cl) = promote_type (class_ptr_type);\n-      pop_obstacks ();\n       return cl;\n     }\n }\n@@ -995,9 +974,7 @@ build_static_field_ref (fdecl)\n     {\n       if (DECL_RTL (fdecl) == 0)\n \t{\n-\t  push_obstacks (&permanent_obstack, &permanent_obstack);\n \t  make_decl_rtl (fdecl, NULL, 1);\n-\t  pop_obstacks ();\n \t  if (is_compiled == 1)\n \t    DECL_EXTERNAL (fdecl) = 1;\n \t}\n@@ -1502,9 +1479,7 @@ finish_class ()\n \t      || ! METHOD_PRIVATE (method)\n \t      || saw_native_method)\n \t    {\n-\t      temporary_allocation ();\n \t      output_inline_function (method);\n-\t      permanent_allocation (1);\n \t      /* Scan the list again to see if there are any earlier\n                  methods to emit. */\n \t      method = type_methods;\n@@ -1749,9 +1724,7 @@ push_super_field (this_class, super_class)\n   /* Don't insert the field if we're just re-laying the class out. */ \n   if (TYPE_FIELDS (this_class) && !DECL_NAME (TYPE_FIELDS (this_class)))\n     return;\n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n   base_decl = build_decl (FIELD_DECL, NULL_TREE, super_class);\n-  pop_obstacks ();\n   DECL_IGNORED_P (base_decl) = 1;\n   TREE_CHAIN (base_decl) = TYPE_FIELDS (this_class);\n   TYPE_FIELDS (this_class) = base_decl;\n@@ -1814,6 +1787,7 @@ layout_class (this_class)\n   if (CLASS_BEING_LAIDOUT (this_class))\n     {\n       char buffer [1024];\n+      char *report;\n       tree current;\n       \n       sprintf (buffer, \" with `%s'\",\n@@ -1831,7 +1805,9 @@ layout_class (this_class)\n \t  obstack_grow (&temporary_obstack, buffer, strlen (buffer));\n \t}\n       obstack_1grow (&temporary_obstack, '\\0');\n-      cyclic_inheritance_report = obstack_finish (&temporary_obstack);\n+      report = obstack_finish (&temporary_obstack);\n+      cyclic_inheritance_report = ggc_strdup (report);\n+      obstack_free (&temporary_obstack, report);\n       TYPE_SIZE (this_class) = error_mark_node;\n       return;\n     }\n@@ -1883,7 +1859,6 @@ layout_class_methods (this_class)\n   if (TYPE_NVIRTUALS (this_class))\n     return;\n \n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n   super_class = CLASSTYPE_SUPER (this_class);\n   handle_type = CLASS_TO_HANDLE_TYPE (this_class);\n \n@@ -1909,7 +1884,6 @@ layout_class_methods (this_class)\n #ifdef JAVA_USE_HANDLES\n   layout_type (handle_type);\n #endif\n-  pop_obstacks ();\n }\n \n /* A sorted list of all C++ keywords.  */\n@@ -2230,4 +2204,5 @@ init_class_processing ()\n   registerClass_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"_Jv_RegisterClass\");\n   ggc_add_tree_root (&registered_class, 1);\n   ggc_add_rtx_root (&registerClass_libfunc, 1);\n+  gcc_obstack_init (&temporary_obstack);\n }"}, {"sha": "ad2ed21f21330141ff39314d2467cba449fe44ea", "filename": "gcc/java/constants.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -335,11 +335,7 @@ get_tag_node (tag)\n     }\n \n   if (tag_nodes[tag] == NULL_TREE)\n-    {\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n-      tag_nodes[tag] = build_int_2 (tag, 0);\n-      pop_obstacks ();\n-    }\n+    tag_nodes[tag] = build_int_2 (tag, 0);\n   return tag_nodes[tag];\n }\n \n@@ -402,13 +398,11 @@ build_constant_data_ref ()\n     {\n       tree decl;\n       tree decl_name = mangled_classname (\"_CD_\", current_class);\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n       decl = build_decl (VAR_DECL, decl_name,\n \t\t\t build_array_type (ptr_type_node,\n \t\t\t\t\t   one_elt_array_domain_type));\n       TREE_STATIC (decl) = 1;\n       make_decl_rtl (decl, NULL, 1);\n-      pop_obstacks ();\n       TYPE_CPOOL_DATA_REF (current_class) = current_constant_pool_data_ref\n \t= build1 (ADDR_EXPR, ptr_type_node, decl);\n     }"}, {"sha": "7d5c165f5e2d865e1d24edbd953747611c2a0518", "filename": "gcc/java/decl.c", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -57,10 +57,6 @@ static tree check_local_unnamed_variable PARAMS ((tree, tree, tree));\n    before static field references.  */\n extern int always_initialize_class_p;\n \n-/* Use garbage collection.  */\n-\n-int ggc_p = 1;\n-\n /* The DECL_MAP is a mapping from (index, type) to a decl node.\n    If index < max_locals, it is the index of a local variable.\n    if index >= max_locals, then index-max_locals is a stack slot.\n@@ -1558,7 +1554,7 @@ copy_lang_decl (node)\n   int lang_decl_size\n     = TREE_CODE (node) == VAR_DECL ? sizeof (struct lang_decl_var)\n     : sizeof (struct lang_decl);\n-  struct lang_decl *x = (struct lang_decl *) oballoc (lang_decl_size);\n+  struct lang_decl *x = (struct lang_decl *) ggc_alloc (lang_decl_size);\n   bcopy ((PTR) DECL_LANG_SPECIFIC (node), (PTR) x, lang_decl_size);\n   DECL_LANG_SPECIFIC (node) = x;\n }\n@@ -1733,10 +1729,6 @@ complete_start_java_method (fndecl)\n \t\t       emit_init_test_initialization, 0);\n     }\n \n-  /* Allocate further tree nodes temporarily during compilation\n-     of this function only.  */\n-  temporary_allocation ();\n-\n #if 0\n       /* If this fcn was already referenced via a block-scope `extern' decl (or\n          an implicit decl), propagate certain information about the usage. */\n@@ -1812,7 +1804,7 @@ start_java_method (fndecl)\n \n   i = DECL_MAX_LOCALS(fndecl) + DECL_MAX_STACK(fndecl);\n   decl_map = make_tree_vec (i);\n-  type_map = (tree *) oballoc (i * sizeof (tree));\n+  type_map = (tree *) xrealloc (type_map, i * sizeof (tree));\n \n #if defined(DEBUG_JAVA_BINDING_LEVELS)\n   fprintf (stderr, \"%s:\\n\", (*decl_printable_name) (fndecl, 2));\n@@ -1891,7 +1883,6 @@ end_java_method ()\n   rest_of_compilation (fndecl);\n \n   current_function_decl = NULL_TREE;\n-  permanent_allocation (1);\n   asynchronous_exceptions = flag_asynchronous_exceptions;\n }\n "}, {"sha": "258bbc0b2a15ed9100c7a94d3b5fb08dfecae0e1", "filename": "gcc/java/except.c", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexcept.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -43,6 +43,7 @@ static struct eh_range *find_handler_in_range PARAMS ((int, struct eh_range *,\n \t\t\t\t\t\t      struct eh_range *));\n static void link_handler PARAMS ((struct eh_range *, struct eh_range *));\n static void check_start_handlers PARAMS ((struct eh_range *, int));\n+static void free_eh_ranges PARAMS ((struct eh_range *range));\n \n extern struct obstack permanent_obstack;\n \n@@ -156,7 +157,7 @@ link_handler (range, outer)\n   if (range->start_pc < outer->start_pc || range->end_pc > outer->end_pc)\n     {\n       struct eh_range *h\n-\t= (struct eh_range *) oballoc (sizeof (struct eh_range));\n+\t= (struct eh_range *) xmalloc (sizeof (struct eh_range));\n       if (range->start_pc < outer->start_pc)\n \t{\n \t  h->start_pc = range->start_pc;\n@@ -221,12 +222,27 @@ handle_nested_ranges ()\n     }\n }\n \n+/* Free RANGE as well as its children and siblings.  */\n+\n+static void\n+free_eh_ranges (range)\n+     struct eh_range *range;\n+{\n+  while (range) \n+    {\n+      struct eh_range *next = range->next_sibling;\n+      free_eh_ranges (range->first_child);\n+      free (range);\n+      range = next;\n+    }\n+}\n \n /* Called to re-initialize the exception machinery for a new method. */\n \n void\n method_init_exceptions ()\n {\n+  free_eh_ranges (&whole_range);\n   whole_range.start_pc = 0;\n   whole_range.end_pc = DECL_CODE_LENGTH (current_function_decl) + 1;\n   whole_range.outer = NULL;\n@@ -279,7 +295,7 @@ add_handler (start_pc, end_pc, handler, type)\n       prev = ptr;\n     }\n \n-  h = (struct eh_range *) oballoc (sizeof (struct eh_range));\n+  h = (struct eh_range *) xmalloc (sizeof (struct eh_range));\n   h->start_pc = start_pc;\n   h->end_pc = end_pc;\n   h->first_child = NULL;\n@@ -306,9 +322,7 @@ expand_start_java_handler (range)\n \t   current_pc, range->end_pc);\n #endif /* defined(DEBUG_JAVA_BINDING_LEVELS) */\n   range->expanded = 1;\n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n   expand_eh_region_start ();\n-  pop_obstacks ();\n }\n \n tree\n@@ -323,7 +337,6 @@ prepare_eh_table_type (type)\n    * c) a pointer to the Utf8Const name of the class, plus one\n    * (which yields a value with low-order bit 1). */\n \n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n   if (type == NULL_TREE)\n     exp = CATCH_ALL_TYPE;\n   else if (is_compiled_class (type))\n@@ -333,7 +346,6 @@ prepare_eh_table_type (type)\n \t\t(PLUS_EXPR, ptr_type_node,\n \t\t build_utf8_ref (build_internal_class_name (type)),\n \t\t size_one_node));\n-  pop_obstacks ();\n   return exp;\n }\n \n@@ -345,9 +357,7 @@ expand_end_java_handler (range)\n {  \n   tree handler = range->handlers;\n   force_poplevels (range->start_pc);\n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n   expand_start_all_catch ();\n-  pop_obstacks ();\n   for ( ; handler != NULL_TREE; handler = TREE_CHAIN (handler))\n     {\n       start_catch_handler (prepare_eh_table_type (TREE_PURPOSE (handler)));"}, {"sha": "6dc5184ad5aeeed345479fa3b84f85f597643258", "filename": "gcc/java/expr.c", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -281,7 +281,7 @@ push_value (value)\n     }\n   push_type (type);\n   if (tree_list_free_list == NULL_TREE)\n-    quick_stack = perm_tree_cons (NULL_TREE, value, quick_stack);\n+    quick_stack = tree_cons (NULL_TREE, value, quick_stack);\n   else\n     {\n       tree node = tree_list_free_list;\n@@ -1463,10 +1463,8 @@ create_label_decl (name)\n      tree name;\n {\n   tree decl;\n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n   decl = build_decl (LABEL_DECL, name, \n \t\t     TREE_TYPE (return_address_type_node));\n-  pop_obstacks ();\n   DECL_CONTEXT (decl) = current_function_decl;\n   DECL_IGNORED_P (decl) = 1;\n   return decl;\n@@ -1985,14 +1983,12 @@ build_jni_stub (method)\n       TREE_CHAIN (env_var) = res_var;\n     }\n \n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n   meth_var = build_decl (VAR_DECL, get_identifier (\"meth\"), ptr_type_node);\n   TREE_STATIC (meth_var) = 1;\n   TREE_PUBLIC (meth_var) = 0;\n   DECL_EXTERNAL (meth_var) = 0;\n   make_decl_rtl (meth_var, NULL, 0);\n   meth_var = pushdecl_top_level (meth_var);\n-  pop_obstacks ();\n \n   /* One strange way that the front ends are different is that they\n      store arguments differently.  */\n@@ -2334,7 +2330,6 @@ java_lang_expand_expr (exp, target, tmode, modifier)\n \t  {\n \t    tree temp, value, init_decl;\n \t    struct rtx_def *r;\n-\t    push_obstacks (&permanent_obstack, &permanent_obstack);\n \t    START_RECORD_CONSTRUCTOR (temp, object_type_node);\n \t    PUSH_FIELD_VALUE (temp, \"vtable\",\n \t\t\t      get_primitive_array_vtable (element_type));\n@@ -2358,7 +2353,6 @@ java_lang_expand_expr (exp, target, tmode, modifier)\n \t    make_decl_rtl (init_decl, NULL, 1);\n \t    init = build1 (ADDR_EXPR, TREE_TYPE (exp), init_decl);\n \t    r = expand_expr (init, target, tmode, modifier);\n-\t    pop_obstacks ();\n \t    return r;\n \t  }\n \n@@ -2371,7 +2365,6 @@ java_lang_expand_expr (exp, target, tmode, modifier)\n \t    && ilength >= 10 && JPRIMITIVE_TYPE_P (element_type))\n \t  {\n \t    tree init_decl;\n-\t    push_obstacks (&permanent_obstack, &permanent_obstack);\n \t    init_decl = build_decl (VAR_DECL, generate_name (),\n \t\t\t\t    TREE_TYPE (init));\n \t    pushdecl_top_level (init_decl);\n@@ -2381,7 +2374,6 @@ java_lang_expand_expr (exp, target, tmode, modifier)\n \t    TREE_READONLY (init_decl) = 1;\n \t    TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (init_decl)) = 1;\n \t    make_decl_rtl (init_decl, NULL, 1);\n-\t    pop_obstacks ();\n \t    init = init_decl;\n \t  }\n \texpand_assignment (build (COMPONENT_REF, TREE_TYPE (data_fld),\n@@ -2449,13 +2441,9 @@ java_lang_expand_expr (exp, target, tmode, modifier)\n       /* We expand a try[-catch] block */\n \n       /* Expand the try block */\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n       expand_eh_region_start ();\n-      pop_obstacks ();\n       expand_expr_stmt (TREE_OPERAND (exp, 0));\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n       expand_start_all_catch ();\n-      pop_obstacks ();\n \n       /* Expand all catch clauses (EH handlers) */\n       for (current = TREE_OPERAND (exp, 1); current; \n@@ -2517,7 +2505,7 @@ note_instructions (jcf, method)\n \n   JCF_SEEK (jcf, DECL_CODE_OFFSET (method));\n   byte_ops = jcf->read_ptr;\n-  instruction_bits = oballoc (length + 1);\n+  instruction_bits = xrealloc (instruction_bits, length + 1);\n   bzero (instruction_bits, length + 1);\n \n   /* This pass figures out which PC can be the targets of jumps. */\n@@ -2748,12 +2736,10 @@ java_push_constant_from_pool (jcf, index)\n   if (JPOOL_TAG (jcf, index) == CONSTANT_String)\n     {\n       tree name;\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n       name = get_name_constant (jcf, JPOOL_USHORT1 (jcf, index));\n       index = alloc_name_constant (CONSTANT_String, name);\n       c = build_ref_from_constant_pool (index);\n       TREE_TYPE (c) = promote_type (string_type_node);\n-      pop_obstacks ();\n     }\n   else\n     c = get_constant (jcf, index);\n@@ -2881,7 +2867,6 @@ process_jvm_instruction (PC, byte_ops, length)\n     tree type = TREE_TYPE (selector); \\\n     flush_quick_stack (); \\\n     expand_start_case (0, selector, type, \"switch statement\");\\\n-    push_momentary (); \\\n     while (--npairs >= 0) \\\n       { \\\n \tjint match = IMMEDIATE_s4; jint offset = IMMEDIATE_s4; \\\n@@ -2894,7 +2879,6 @@ process_jvm_instruction (PC, byte_ops, length)\n     label =  build_decl (LABEL_DECL, NULL_TREE, NULL_TREE); \\\n     pushcase (NULL_TREE, 0, label, &duplicate); \\\n     expand_java_goto (oldpc + default_offset); \\\n-    pop_momentary (); \\\n     expand_end_case (selector); \\\n   }\n \n@@ -2906,7 +2890,6 @@ process_jvm_instruction (PC, byte_ops, length)\n     tree type = TREE_TYPE (selector); \\\n     flush_quick_stack (); \\\n     expand_start_case (0, selector, type, \"switch statement\");\\\n-    push_momentary (); \\\n     for (; low <= high; low++) \\\n       { \\\n         jint offset = IMMEDIATE_s4; \\\n@@ -2919,7 +2902,6 @@ process_jvm_instruction (PC, byte_ops, length)\n     label =  build_decl (LABEL_DECL, NULL_TREE, NULL_TREE); \\\n     pushcase (NULL_TREE, 0, label, &duplicate); \\\n     expand_java_goto (oldpc + default_offset); \\\n-    pop_momentary (); \\\n     expand_end_case (selector); \\\n   }\n "}, {"sha": "f1f205427fc6d527c085c7dc60d5b9ba318d36ff", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -602,8 +602,6 @@ extern struct CPool *outgoing_cpool;\n \n extern char *cyclic_inheritance_report;\n \n-extern char *cyclic_inheritance_report;\n-\n struct lang_identifier\n {\n   struct tree_identifier ignore;"}, {"sha": "b11d949a9e3adff18666e98fdb2b5b62803c8b0d", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -255,7 +255,6 @@ get_constant (jcf, index)\n   tag = JPOOL_TAG (jcf, index);\n   if ((tag & CONSTANT_ResolvedFlag) || tag == CONSTANT_Utf8)\n     return (tree) jcf->cpool.data[index];\n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n   switch (tag)\n     {\n     case CONSTANT_Integer:\n@@ -327,7 +326,6 @@ get_constant (jcf, index)\n #endif /* TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT */\n     case CONSTANT_String:\n       {\n-\textern struct obstack *expression_obstack;\n \ttree name = get_name_constant (jcf, JPOOL_USHORT1 (jcf, index));\n \tconst char *utf8_ptr = IDENTIFIER_POINTER (name);\n \tunsigned char *str_ptr;\n@@ -350,8 +348,7 @@ get_constant (jcf, index)\n \tvalue = make_node (STRING_CST);\n \tTREE_TYPE (value) = build_pointer_type (string_type_node);\n \tTREE_STRING_LENGTH (value) = 2 * str_len;\n-\tTREE_STRING_POINTER (value)\n-\t  = obstack_alloc (expression_obstack, 2 * str_len);\n+\tTREE_STRING_POINTER (value) = ggc_alloc (2 * str_len);\n \tstr_ptr = (unsigned char *) TREE_STRING_POINTER (value);\n \tstr = (const unsigned char *)utf8_ptr;\n \tfor (i = 0; i < str_len; i++)\n@@ -391,7 +388,6 @@ get_constant (jcf, index)\n     default:\n       goto bad;\n     }\n-  pop_obstacks ();\n   JPOOL_TAG(jcf, index) = tag | CONSTANT_ResolvedFlag;\n   jcf->cpool.data [index] = (jword) value;\n   return value;\n@@ -486,17 +482,12 @@ read_class (name)\n   if (current_jcf->read_state)\n     saved_pos = ftell (current_jcf->read_state);\n \n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n-\n   /* Search in current zip first.  */\n   if (find_in_current_zip (IDENTIFIER_POINTER (name), &jcf) == 0)\n     {\n       if (find_class (IDENTIFIER_POINTER (name), IDENTIFIER_LENGTH (name),\n \t\t      &this_jcf, 1) == 0)\n-\t{\n-\t  pop_obstacks ();\t/* FIXME: one pop_obstack() per function */\n-\t  return 0;\n-\t}\n+\treturn 0;\n       else\n \t{\n \t  this_jcf.seen_in_zip = 0;\n@@ -519,7 +510,6 @@ read_class (name)\n \n   if (!current_jcf->seen_in_zip)\n     JCF_FINISH (current_jcf);\n-  pop_obstacks ();\n \n   current_class = save_current_class;\n   input_filename = save_input_filename;\n@@ -639,7 +629,6 @@ jcf_parse (jcf)\n   if (current_class != class_type_node && current_class != object_type_node)\n     TYPE_FIELDS (current_class) = nreverse (TYPE_FIELDS (current_class));\n \n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n   layout_class (current_class);\n   if (current_class == object_type_node)\n     layout_class_methods (object_type_node);\n@@ -651,8 +640,6 @@ jcf_parse (jcf)\n   for (current = DECL_INNER_CLASS_LIST (TYPE_NAME (current_class)); current;\n        current = TREE_CHAIN (current))\n     load_class (DECL_NAME (TREE_PURPOSE (current)), 1);\n-\n-  pop_obstacks ();\n }\n \n void"}, {"sha": "1775441d329d07196704c34741b0f61809fe407c", "filename": "gcc/java/lex.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -36,10 +36,6 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n \n #include \"keyword.h\"\n \n-#ifndef JC1_LITE\n-extern struct obstack *expression_obstack;\n-#endif\n-\n /* Function declaration  */\n static int java_lineterminator PARAMS ((unicode_t));\n static char *java_sprint_unicode PARAMS ((struct java_line *, int));\n@@ -1104,6 +1100,7 @@ java_lex (java_lval)\n       else\n \tjava_lval->node = build_string (strlen (string), string);\n #endif\n+      obstack_free (&temporary_obstack, string);\n       return STRING_LIT_TK;\n     }\n "}, {"sha": "40fad4aef2deab9e13ae59699ec4a457a7e35533", "filename": "gcc/java/parse.h", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -111,7 +111,6 @@ extern tree stabilize_reference PARAMS ((tree));\n /* Misc. */\n #define exit_java_complete_class()\t\t\\\n   {\t\t\t\t\t\t\\\n-    pop_obstacks ();\t\t\t\t\\\n     return;\t\t\t\t\t\\\n   }\n \n@@ -229,31 +228,40 @@ extern tree stabilize_reference PARAMS ((tree));\n    scope local variables.  */\n #define MANGLE_OUTER_LOCAL_VARIABLE_NAME(N, O)\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n+    char *mangled_name;\t\t\t\t\t\t\t\\\n     obstack_grow (&temporary_obstack, \"val$\", 4);\t\t\t\\\n-    obstack_grow (&temporary_obstack, \t\t\t\t\t\\\n+    obstack_grow (&temporary_obstack,\t\t\t\t\t\\\n \t\t  IDENTIFIER_POINTER ((O)), IDENTIFIER_LENGTH ((O)));\t\\\n     obstack_1grow (&temporary_obstack, '\\0');\t\t\t\t\\\n-    (N) = obstack_finish (&temporary_obstack);  \t\t\t\\\n+    mangled_name = obstack_finish (&temporary_obstack);\t\t\t\\\n+    (N) = get_identifier (mangled_name);\t\t\t\t\\\n+    obstack_free (&temporary_obstack, mangled_name);\t\t\t\\\n   }\n \n /* Build the string parm$<O> and store in into the identifier N. This\n    is used to contruct the name of hidden parameters used to\n    initialize outer scope aliases.  */\n #define MANGLE_ALIAS_INITIALIZER_PARAMETER_NAME_ID(N, O)\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n+    char *mangled_name;\t\t\t\t\t\t\t\\\n     obstack_grow (&temporary_obstack, \"parm$\", 5);\t\t\t\\\n     obstack_grow (&temporary_obstack, \t\t\t\t\t\\\n \t\t  IDENTIFIER_POINTER ((O)), IDENTIFIER_LENGTH ((O)));\t\\\n     obstack_1grow (&temporary_obstack, '\\0');\t\t\t\t\\\n-    (N) = obstack_finish (&temporary_obstack);  \t\t\t\\\n+    mangled_name = obstack_finish (&temporary_obstack);\t\t\t\\\n+    (N) = get_identifier (mangled_name);\t\t\t\t\\\n+    obstack_free (&temporary_obstack, mangled_name);\t\t\t\\\n   }\n \n #define MANGLE_ALIAS_INITIALIZER_PARAMETER_NAME_STR(N, S)\t\\\n   {\t\t\t\t\t\t\t\t\\\n+    char *mangled_name;\t\t\t\t\t\t\t\\\n     obstack_grow (&temporary_obstack, \"parm$\", 5);\t\t\\\n     obstack_grow (&temporary_obstack, (S), strlen ((S)));\t\\\n     obstack_1grow (&temporary_obstack, '\\0');\t\t\t\\\n-    (N) = obstack_finish (&temporary_obstack);\t\t\t\\\n+    mangled_name = obstack_finish (&temporary_obstack);\t\t\t\\\n+    (N) = get_identifier (mangled_name);\t\t\t\t\\\n+    obstack_free (&temporary_obstack, mangled_name);\t\t\t\\\n   }\n \n /* Skip THIS and artificial parameters found in function decl M and"}, {"sha": "e9fe4b3bb575e822172154eda30eb98406c78c6c", "filename": "gcc/java/parse.y", "status": "modified", "additions": 17, "deletions": 53, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -598,6 +598,7 @@ goal:\n \t\t  ggc_add_tree_root (&package_list, 1);\n \t\t  ggc_add_tree_root (&current_this, 1);\n \t\t  ggc_add_tree_root (&currently_caught_type_list, 1);\n+\t\t  ggc_add_string_root (&cyclic_inheritance_report, 1);\n \t\t  ggc_add_root (&ctxp, 1, \n \t\t\t\tsizeof (struct parser_ctxt *),\n \t\t\t\tmark_parser_ctxt);\n@@ -3938,7 +3939,7 @@ add_inner_class_fields (class_decl, fct_decl)\n       tree decl;\n       for (decl = BLOCK_EXPR_DECLS (block); decl; decl = TREE_CHAIN (decl))\n \t{\n-\t  char *name, *pname;\n+\t  tree name, pname;\n \t  tree wfl, init, list;\n \t  \n \t  /* Avoid non final arguments. */\n@@ -3947,8 +3948,8 @@ add_inner_class_fields (class_decl, fct_decl)\n \t  \n \t  MANGLE_OUTER_LOCAL_VARIABLE_NAME (name, DECL_NAME (decl));\n \t  MANGLE_ALIAS_INITIALIZER_PARAMETER_NAME_ID (pname, DECL_NAME (decl));\n-\t  wfl = build_wfl_node (get_identifier (name));\n-\t  init = build_wfl_node (get_identifier (pname));\n+\t  wfl = build_wfl_node (name);\n+\t  init = build_wfl_node (pname);\n \t  /* Build an initialization for the field: it will be\n \t     initialized by a parameter added to finit$, bearing a\n \t     mangled name of the field itself (param$<n>.) The\n@@ -4036,10 +4037,8 @@ lookup_field_wrapper (class, name)\n      context. We try to look for it now. */\n   if (INNER_CLASS_TYPE_P (class))\n     {\n-      char *alias_buffer;\n       tree new_name;\n-      MANGLE_OUTER_LOCAL_VARIABLE_NAME (alias_buffer, name);\n-      new_name = get_identifier (alias_buffer);\n+      MANGLE_OUTER_LOCAL_VARIABLE_NAME (new_name, name);\n       decl = lookup_field (&type, new_name);\n       if (decl && decl != error_mark_node)\n \tFIELD_LOCAL_ALIAS_USED (decl) = 1;\n@@ -4959,10 +4958,8 @@ obtain_incomplete_type (type_name)\n \n   if (!ptr)\n     {\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n       BUILD_PTR_FROM_NAME (ptr, name);\n       layout_type (ptr);\n-      pop_obstacks ();\n       TREE_CHAIN (ptr) = ctxp->incomplete_class;\n       ctxp->incomplete_class = ptr;\n     }\n@@ -5060,34 +5057,37 @@ build_alias_initializer_parameter_list (mode, class_type, parm, artificial)\n       {\n \tconst char *buffer = IDENTIFIER_POINTER (DECL_NAME (field));\n \ttree purpose = NULL_TREE, value = NULL_TREE, name = NULL_TREE;\n+\ttree mangled_id;\n \n \tswitch (mode)\n \t  {\n \t  case AIPL_FUNCTION_DECLARATION:\n-\t    MANGLE_ALIAS_INITIALIZER_PARAMETER_NAME_STR (buffer, &buffer [4]);\n-\t    purpose = build_wfl_node (get_identifier (buffer));\n+\t    MANGLE_ALIAS_INITIALIZER_PARAMETER_NAME_STR (mangled_id, \n+\t\t\t\t\t\t\t &buffer [4]);\n+\t    purpose = build_wfl_node (mangled_id);\n \t    if (TREE_CODE (TREE_TYPE (field)) == POINTER_TYPE)\n \t      value = build_wfl_node (TYPE_NAME (TREE_TYPE (field)));\n \t    else\n \t      value = TREE_TYPE (field);\n \t    break;\n \n \t  case AIPL_FUNCTION_CREATION:\n-\t    MANGLE_ALIAS_INITIALIZER_PARAMETER_NAME_STR (buffer, &buffer [4]);\n-\t    purpose = get_identifier (buffer);\n+\t    MANGLE_ALIAS_INITIALIZER_PARAMETER_NAME_STR (purpose,\n+\t\t\t\t\t\t\t &buffer [4]);\n \t    value = TREE_TYPE (field);\n \t    break;\n \n \t  case AIPL_FUNCTION_FINIT_INVOCATION:\n-\t    MANGLE_ALIAS_INITIALIZER_PARAMETER_NAME_STR (buffer, &buffer [4]);\n+\t    MANGLE_ALIAS_INITIALIZER_PARAMETER_NAME_STR (mangled_id, \n+\t\t\t\t\t\t\t &buffer [4]);\n \t    /* Now, this is wrong. purpose should always be the NAME\n \t       of something and value its matching value (decl, type,\n \t       etc...) FIXME -- but there is a lot to fix. */\n \n \t    /* When invoked for this kind of operation, we already\n \t       know whether a field is used or not. */\n \t    purpose = TREE_TYPE (field);\n-\t    value = build_wfl_node (get_identifier (buffer));\n+\t    value = build_wfl_node (mangled_id);\n \t    break;\n \n \t  case AIPL_FUNCTION_CTOR_INVOCATION:\n@@ -5136,8 +5136,6 @@ craft_constructor (class_decl, args)\n   tree decl, ctor_name;\n   char buffer [80];\n   \n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n-\n   /* The constructor name is <init> unless we're dealing with an\n      anonymous class, in which case the name will be fixed after having\n      be expanded. */\n@@ -5174,8 +5172,6 @@ craft_constructor (class_decl, args)\n   fix_method_argument_names (parm, decl);\n   /* Now, mark the artificial parameters. */\n   DECL_FUNCTION_NAP (decl) = artificial;\n-\n-  pop_obstacks ();\n   DECL_CONSTRUCTOR_P (decl) = 1;\n }\n \n@@ -5227,10 +5223,7 @@ safe_layout_class (class)\n   const char *save_input_filename = input_filename;\n   int save_lineno = lineno;\n \n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n-\n   layout_class (class);\n-  pop_obstacks ();\n \n   current_class = save_current_class;\n   input_filename = save_input_filename;\n@@ -5270,8 +5263,6 @@ java_complete_class ()\n   int error_found;\n   tree type;\n \n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n-\n   /* Process imports */\n   process_imports ();\n \n@@ -5306,10 +5297,8 @@ java_complete_class ()\n \t\t/* We do part of the job done in add_field */\n \t\ttree field_decl = JDEP_DECL (dep);\n \t\ttree field_type = TREE_TYPE (decl);\n-\t\tpush_obstacks (&permanent_obstack, &permanent_obstack);\n \t\tif (TREE_CODE (field_type) == RECORD_TYPE)\n \t\t  field_type = promote_type (field_type);\n-\t\tpop_obstacks ();\n \t\tTREE_TYPE (field_decl) = field_type;\n \t\tDECL_ALIGN (field_decl) = 0;\n \t\tDECL_USER_ALIGN (field_decl) = 0;\n@@ -5350,7 +5339,6 @@ java_complete_class ()\n \t      if (!error_found)\n \t\t{\n \t\t  tree mdecl = JDEP_DECL (dep), signature;\n-\t\t  push_obstacks (&permanent_obstack, &permanent_obstack);\n \t\t  /* Recompute and reset the signature, check first that\n \t\t     all types are now defined. If they're not,\n \t\t     dont build the signature. */\n@@ -5359,7 +5347,6 @@ java_complete_class ()\n \t\t      signature = build_java_signature (TREE_TYPE (mdecl));\n \t\t      set_java_signature (TREE_TYPE (mdecl), signature);\n \t\t    }\n-\t\t  pop_obstacks ();\n \t\t}\n \t      else\n \t\tcontinue;\n@@ -5404,7 +5391,6 @@ java_complete_class ()\n \t    }\n \t}\n     }\n-  pop_obstacks ();\n   return;\n }\n \n@@ -7245,7 +7231,6 @@ source_end_java_method ()\n     }\n \n   current_function_decl = NULL_TREE;\n-  permanent_allocation (1);\n   java_parser_context_restore_global ();\n   asynchronous_exceptions = flag_asynchronous_exceptions;\n }\n@@ -8005,8 +7990,6 @@ build_outer_field_access_methods (decl)\n   if (FIELD_INNER_ACCESS (decl))\n     return FIELD_INNER_ACCESS (decl);\n \n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n-\n   /* Create the identifier and a function named after it. */\n   id = build_new_access_id ();\n \n@@ -8036,7 +8019,6 @@ build_outer_field_access_methods (decl)\n   mdecl = build_outer_field_access_method (DECL_CONTEXT (decl), \n \t\t\t\t\t   TREE_TYPE (decl), id, args, stmt);\n   DECL_FUNCTION_ACCESS_DECL (mdecl) = decl;\n-  pop_obstacks ();\n \n   /* Return the access name */\n   return FIELD_INNER_ACCESS (decl) = id;\n@@ -8093,8 +8075,6 @@ build_outer_method_access_method (decl)\n   id = build_new_access_id ();\n   OUTER_FIELD_ACCESS_IDENTIFIER_P (id) = 1;\n \n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n-\n   carg = TYPE_ARG_TYPES (TREE_TYPE (decl));\n   /* Create the arguments, as much as the original */\n   for (; carg && carg != end_params_node; \n@@ -8141,7 +8121,6 @@ build_outer_method_access_method (decl)\n   java_method_add_stmt (mdecl,body);\n   end_artificial_method_body (mdecl);\n   current_function_decl = saved_current_function_decl;\n-  pop_obstacks ();\n \n   /* Back tag the access function so it know what it accesses */\n   DECL_FUNCTION_ACCESS_DECL (decl) = mdecl;\n@@ -8212,7 +8191,6 @@ maybe_build_thisn_access_method (type)\n   /* We generate the method. The method looks like:\n      static <outer_of_type> access$0 (<type> inst$) { return inst$.this$<n>; }\n   */\n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n   args = build_tree_list (inst_id, build_pointer_type (type));\n   TREE_CHAIN (args) = end_params_node;\n   rtype = build_pointer_type (TREE_TYPE (DECL_CONTEXT (TYPE_NAME (type))));\n@@ -8230,7 +8208,6 @@ maybe_build_thisn_access_method (type)\n   java_method_add_stmt (mdecl, stmt);\n   end_artificial_method_body (mdecl);\n   current_function_decl = saved_current_function_decl;\n-  pop_obstacks ();\n \n   CLASS_ACCESS0_GENERATED_P (type) = 1;\n \n@@ -8432,11 +8409,8 @@ build_dot_class_method_invocation (type)\n   else\n     sig_id = DECL_NAME (TYPE_NAME (type));\n \n-  s = make_node (STRING_CST);\n-  TREE_STRING_LENGTH (s) = IDENTIFIER_LENGTH (sig_id);\n-  TREE_STRING_POINTER (s) = obstack_alloc (expression_obstack,\n-\t\t\t\t\t   TREE_STRING_LENGTH (s)+1);\n-  strcpy (TREE_STRING_POINTER (s), IDENTIFIER_POINTER (sig_id));\n+  s = build_string (IDENTIFIER_LENGTH (sig_id), \n+\t\t    IDENTIFIER_POINTER (sig_id));\n   return build_method_invocation (build_wfl_node (get_identifier (\"class$\")),\n \t\t\t\t  build_tree_list (NULL_TREE, s));\n }\n@@ -10899,9 +10873,7 @@ java_complete_tree (node)\n     {\n       tree value = DECL_INITIAL (node);\n       DECL_INITIAL (node) = NULL_TREE;\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n       value = fold_constant_for_init (value, node);\n-      pop_obstacks ();\n       DECL_INITIAL (node) = value;\n       if (value != NULL_TREE)\n \t{\n@@ -11114,10 +11086,8 @@ java_complete_lhs (node)\n \t  && FIELD_FINAL (TREE_OPERAND (cn, 1))\n \t  && DECL_INITIAL (TREE_OPERAND (cn, 1)))\n \t{\n-\t  push_obstacks (&permanent_obstack, &permanent_obstack);\n \t  cn = fold_constant_for_init (DECL_INITIAL (TREE_OPERAND (cn, 1)),\n \t\t\t\t       TREE_OPERAND (cn, 1));\n-\t  pop_obstacks ();\n \t}\n \n       if (!TREE_CONSTANT (cn) && !flag_emit_xref)\n@@ -11395,9 +11365,7 @@ java_complete_lhs (node)\n \t{\n \t  tree value;\n \t  \n-\t  push_obstacks (&permanent_obstack, &permanent_obstack);\n \t  value = fold_constant_for_init (nn, nn);\n-\t  pop_obstacks ();\n \n \t  if (value != NULL_TREE)\n \t    {\n@@ -13029,7 +12997,7 @@ do_merge_string_cste (cste, string, string_len, after)\n   \n   cste = make_node (STRING_CST);\n   TREE_STRING_LENGTH (cste) = len;\n-  new = TREE_STRING_POINTER (cste) = obstack_alloc (expression_obstack, len+1);\n+  new = TREE_STRING_POINTER (cste) = ggc_alloc (len+1);\n \n   if (after)\n     {\n@@ -13234,11 +13202,9 @@ patch_string_cst (node)\n   int location;\n   if (! flag_emit_class_files)\n     {\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n       node = get_identifier (TREE_STRING_POINTER (node));\n       location = alloc_name_constant (CONSTANT_String, node);\n       node = build_ref_from_constant_pool (location);\n-      pop_obstacks ();\n     }\n   TREE_TYPE (node) = string_ptr_type_node;\n   TREE_CONSTANT (node) = 1;\n@@ -13972,7 +13938,6 @@ array_constructor_check_entry (type, entry)\n   new_value = NULL_TREE;\n   wfl_value = TREE_VALUE (entry);\n \n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n   value = java_complete_tree (TREE_VALUE (entry));\n   /* patch_string return error_mark_node if arg is error_mark_node */\n   if ((patched = patch_string (value)))\n@@ -13989,7 +13954,6 @@ array_constructor_check_entry (type, entry)\n   if (!new_value && (new_value = try_reference_assignconv (type, value)))\n     type_value = promote_type (type);\n \n-  pop_obstacks ();\n   /* Check and report errors */\n   if (!new_value)\n     {"}, {"sha": "ad78ffbf6216409b04ed7890bf2531abb756ffa7", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -407,7 +407,6 @@ build_java_array_type (element_type, length)\n   TYPE_ARRAY_ELEMENT (t) = element_type;\n \n   /* Add length pseudo-field. */\n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n   fld = build_decl (FIELD_DECL, get_identifier (\"length\"), int_type_node);\n   TYPE_FIELDS (t) = fld;\n   DECL_CONTEXT (fld) = t;\n@@ -447,7 +446,6 @@ build_java_array_type (element_type, length)\n #endif\n       TYPE_ALIGN (t) = desired_align;\n     }\n-  pop_obstacks ();\n \n   /* We could layout_class, but that loads java.lang.Object prematurely.\n    * This is called by the parser, and it is a bad idea to do load_class\n@@ -552,7 +550,6 @@ parse_signature_string (sig_string, sig_length)\n   const unsigned char *str = sig_string;\n   const unsigned char *limit = str + sig_length;\n \n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n   if (str < limit && str[0] == '(')\n     {\n       tree argtype_list = NULL_TREE;\n@@ -572,7 +569,6 @@ parse_signature_string (sig_string, sig_length)\n     result_type = parse_signature_type (&str, limit);\n   if (str != limit)\n     error (\"junk at end of signature string\");\n-  pop_obstacks ();\n   return result_type;\n }\n \n@@ -633,7 +629,6 @@ build_java_signature (type)\n      tree type;\n {\n   tree sig, t;\n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n   while (TREE_CODE (type) == POINTER_TYPE)\n     type = TREE_TYPE (type);\n   MAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC (type);\n@@ -705,7 +700,6 @@ build_java_signature (type)\n \t}\n       TYPE_SIGNATURE (type) = sig;\n     }\n-  pop_obstacks ();\n   return sig;\n }\n "}, {"sha": "b13d171414a9225e80c2aced4a505bd6118fa339", "filename": "gcc/lists.c", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Flists.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Flists.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flists.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -121,21 +121,11 @@ zap_lists (dummy)\n void \n init_EXPR_INSN_LIST_cache ()\n {\n-  if (ggc_p)\n+  static int initialized;\n+  if (!initialized)\n     {\n-      static int initialized;\n-      if (!initialized)\n-        {\n-          initialized = 1;\n-          ggc_add_root (&unused_expr_list, 1, 1, zap_lists);\n-        }\n-\n-      /* No need to squish the lists across functions with GC enabled.  */\n-    }\n-  else\n-    {\n-      unused_expr_list = NULL;\n-      unused_insn_list = NULL;\n+      initialized = 1;\n+      ggc_add_root (&unused_expr_list, 1, 1, zap_lists);\n     }\n }\n "}, {"sha": "977bbd262797c378dc6c962b05cdb15cdb84d419", "filename": "gcc/loop.c", "status": "modified", "additions": 28, "deletions": 38, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -85,17 +85,6 @@ unsigned int max_reg_before_loop;\n /* The value to pass to the next call of reg_scan_update.  */\n static int loop_max_reg;\n \n-/* This obstack is used in product_cheap_p to allocate its rtl.  It\n-   may call gen_reg_rtx which, in turn, may reallocate regno_reg_rtx.\n-   If we used the same obstack that it did, we would be deallocating\n-   that array.  */\n-\n-static struct obstack temp_obstack;\n-\n-/* This is where the pointer to the obstack being used for RTL is stored.  */\n-\n-extern struct obstack *rtl_obstack;\n-\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \f\n@@ -288,18 +277,11 @@ static int reg_address_cost;\n void\n init_loop ()\n {\n-  char *free_point = (char *) oballoc (1);\n   rtx reg = gen_rtx_REG (word_mode, LAST_VIRTUAL_REGISTER + 1);\n \n   reg_address_cost = address_cost (reg, SImode);\n \n   copy_cost = COSTS_N_INSNS (1);\n-\n-  /* Free the objects we just allocated.  */\n-  obfree (free_point);\n-\n-  /* Initialize the obstack used for rtl in product_cheap_p.  */\n-  gcc_obstack_init (&temp_obstack);\n }\n \f\n /* Compute the mapping from uids to luids.\n@@ -4420,6 +4402,29 @@ strength_reduce (loop, insn_count, flags)\n   VARRAY_FREE (ivs->reg_iv_type);\n   VARRAY_FREE (ivs->reg_iv_info);\n   free (ivs->reg_biv_class);\n+  {\n+    struct iv_class *iv = ivs->loop_iv_list;\n+\n+    while (iv) {\n+      struct iv_class *next = iv->next;\n+      struct induction *induction;\n+      struct induction *next_induction;\n+\n+      for (induction = iv->biv; induction; induction = next_induction)\n+\t{\n+\t  next_induction = induction->next_iv;\n+\t  free (induction);\n+\t}\n+      for (induction = iv->giv; induction; induction = next_induction)\n+\t{\n+\t  next_induction = induction->next_iv;\n+\t  free (induction);\n+\t}\n+\n+      free (iv);\n+      iv = next;\n+    }\n+  }\n   if (reg_map)\n     free (reg_map);\n }\n@@ -4457,7 +4462,7 @@ check_insn_for_bivs (loop, p, not_every_iteration, maybe_multiple)\n \t         Create and initialize an induction structure for it.  */\n \n \t      struct induction *v\n-\t\t= (struct induction *) oballoc (sizeof (struct induction));\n+\t\t= (struct induction *) xmalloc (sizeof (struct induction));\n \n \t      record_biv (loop, v, p, dest_reg, inc_val, mult_val, location,\n \t\t\t  not_every_iteration, maybe_multiple);\n@@ -4524,7 +4529,7 @@ check_insn_for_givs (loop, p, not_every_iteration, maybe_multiple)\n \t\t\t\t\t     &last_consec_insn))))\n \t{\n \t  struct induction *v\n-\t    = (struct induction *) oballoc (sizeof (struct induction));\n+\t    = (struct induction *) xmalloc (sizeof (struct induction));\n \n \t  /* If this is a library call, increase benefit.  */\n \t  if (find_reg_note (p, REG_RETVAL, NULL_RTX))\n@@ -4653,7 +4658,7 @@ find_mem_givs (loop, x, insn, not_every_iteration, maybe_multiple)\n \t  {\n \t    /* Found one; record it.  */\n \t    struct induction *v\n-\t      = (struct induction *) oballoc (sizeof (struct induction));\n+\t      = (struct induction *) xmalloc (sizeof (struct induction));\n \n \t    record_giv (loop, v, insn, src_reg, addr_placeholder, mult_val,\n \t\t\tadd_val, ext_val, benefit, DEST_ADDR,\n@@ -4733,7 +4738,7 @@ record_biv (loop, v, insn, dest_reg, inc_val, mult_val, location,\n     {\n       /* Create and initialize new iv_class.  */\n \n-      bl = (struct iv_class *) oballoc (sizeof (struct iv_class));\n+      bl = (struct iv_class *) xmalloc (sizeof (struct iv_class));\n \n       bl->regno = REGNO (dest_reg);\n       bl->biv = 0;\n@@ -5538,23 +5543,16 @@ general_induction_var (loop, x, src_reg, add_val, mult_val, ext_val,\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n   rtx orig_x = x;\n-  char *storage;\n \n   /* If this is an invariant, forget it, it isn't a giv.  */\n   if (loop_invariant_p (loop, x) == 1)\n     return 0;\n \n-  /* See if the expression could be a giv and get its form.\n-     Mark our place on the obstack in case we don't find a giv.  */\n-  storage = (char *) oballoc (0);\n   *pbenefit = 0;\n   *ext_val = NULL_RTX;\n   x = simplify_giv_expr (loop, x, ext_val, pbenefit);\n   if (x == 0)\n-    {\n-      obfree (storage);\n-      return 0;\n-    }\n+    return 0;\n \n   switch (GET_CODE (x))\n     {\n@@ -6944,8 +6942,6 @@ product_cheap_p (a, b)\n {\n   int i;\n   rtx tmp;\n-  struct obstack *old_rtl_obstack = rtl_obstack;\n-  char *storage = (char *) obstack_alloc (&temp_obstack, 0);\n   int win = 1;\n \n   /* If only one is constant, make it B.  */\n@@ -6964,7 +6960,6 @@ product_cheap_p (a, b)\n      code for the multiply and see if a call or multiply, or long sequence\n      of insns is generated.  */\n \n-  rtl_obstack = &temp_obstack;\n   start_sequence ();\n   expand_mult (GET_MODE (a), a, b, NULL_RTX, 0);\n   tmp = gen_sequence ();\n@@ -7001,11 +6996,6 @@ product_cheap_p (a, b)\n \t   && GET_CODE (SET_SRC (XVECEXP (tmp, 0, 0))) == MULT)\n     win = 0;\n \n-  /* Free any storage we obtained in generating this multiply and restore rtl\n-     allocation to its normal obstack.  */\n-  obstack_free (&temp_obstack, storage);\n-  rtl_obstack = old_rtl_obstack;\n-\n   return win;\n }\n \f"}, {"sha": "5dbbcaa9ee95e04391996905c773be25f7b72d06", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -4471,8 +4471,7 @@ rtx\n init_one_libfunc (name)\n      register const char *name;\n {\n-  if (ggc_p)\n-    name = ggc_alloc_string (name, -1);\n+  name = ggc_strdup (name);\n \n   return gen_rtx_SYMBOL_REF (Pmode, name);\n }"}, {"sha": "ddc18695be4ed1bf40069bc629b92af2efd6473e", "filename": "gcc/print-tree.c", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -46,13 +46,10 @@ void\n debug_tree (node)\n      tree node;\n {\n-  char *object = (char *) oballoc (0);\n-\n-  table = (struct bucket **) oballoc (HASH_SIZE * sizeof (struct bucket *));\n+  table = (struct bucket **) permalloc (HASH_SIZE * sizeof (struct bucket *));\n   bzero ((char *) table, HASH_SIZE * sizeof (struct bucket *));\n   print_node (stderr, \"\", node, 0);\n   table = 0;\n-  obfree (object);\n   fprintf (stderr, \"\\n\");\n }\n \n@@ -224,7 +221,7 @@ print_node (file, prefix, node, indent)\n       }\n \n   /* Add this node to the table.  */\n-  b = (struct bucket *) oballoc (sizeof (struct bucket));\n+  b = (struct bucket *) permalloc (sizeof (struct bucket));\n   b->node = node;\n   b->next = table[hash];\n   table[hash] = b;\n@@ -267,22 +264,6 @@ print_node (file, prefix, node, indent)\n       print_node (file, \"type\", TREE_TYPE (node), indent + 4);\n       if (TREE_TYPE (node))\n \tindent_to (file, indent + 3);\n-\n-      if (!ggc_p)\n-\t{\n-\t  print_obstack_name ((char *) node, file, \"\");\n-\t  indent_to (file, indent + 3);\n-\t}\n-    }\n-\n-  /* If a permanent object is in the wrong obstack, or the reverse, warn.  */\n-  if (!ggc_p && object_permanent_p (node) != TREE_PERMANENT (node))\n-    {\n-      if (TREE_PERMANENT (node))\n-\tfputs (\" !!permanent object in non-permanent obstack!!\", file);\n-      else\n-\tfputs (\" !!non-permanent object in permanent obstack!!\", file);\n-      indent_to (file, indent + 3);\n     }\n \n   if (TREE_SIDE_EFFECTS (node))\n@@ -303,8 +284,6 @@ print_node (file, prefix, node, indent)\n     fputs (\" used\", file);\n   if (TREE_NOTHROW (node))\n     fputs (\" nothrow\", file);\n-  if (!ggc_p && TREE_PERMANENT (node))\n-    fputs (\" permanent\", file);\n   if (TREE_PUBLIC (node))\n     fputs (\" public\", file);\n   if (TREE_PRIVATE (node))"}, {"sha": "b52b35257be00686e8ecf7be4142d21710eec25f", "filename": "gcc/profile.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -1115,7 +1115,6 @@ output_func_start_profiler ()\n   announce_function (fndecl);\n   current_function_decl = fndecl;\n   DECL_INITIAL (fndecl) = error_mark_node;\n-  temporary_allocation ();\n   make_function_rtl (fndecl);\n   init_function_start (fndecl, input_filename, lineno);\n   pushlevel (0);"}, {"sha": "5a919c4ee15bf4091fc89504a456b24d4372f273", "filename": "gcc/reload1.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -2845,9 +2845,6 @@ eliminate_regs_in_insn (insn, replace)\n       abort ();\n     }\n \n-  if (! replace)\n-    push_obstacks (&reload_obstack, &reload_obstack);\n-\n   if (old_set != 0 && GET_CODE (SET_DEST (old_set)) == REG\n       && REGNO (SET_DEST (old_set)) < FIRST_PSEUDO_REGISTER)\n     {\n@@ -3148,9 +3145,6 @@ eliminate_regs_in_insn (insn, replace)\n   if (val && REG_NOTES (insn) != 0)\n     REG_NOTES (insn) = eliminate_regs (REG_NOTES (insn), 0, REG_NOTES (insn));\n \n-  if (! replace)\n-    pop_obstacks ();\n-\n   return val;\n }\n "}, {"sha": "4faaedf9a81f928bc6b8e084001fa25ef890bb43", "filename": "gcc/resource.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -923,7 +923,7 @@ mark_target_live_regs (insns, target, res)\n \t{\n \t  /* Allocate a place to put our results and chain it into the \n \t     hash table.  */\n-\t  tinfo = (struct target_info *) oballoc (sizeof (struct target_info));\n+\t  tinfo = (struct target_info *) xmalloc (sizeof (struct target_info));\n \t  tinfo->uid = INSN_UID (target);\n \t  tinfo->block = b;\n \t  tinfo->next = target_hash_table[INSN_UID (target) % TARGET_HASH_PRIME];\n@@ -1223,6 +1223,20 @@ free_resource_info ()\n {\n   if (target_hash_table != NULL)\n     {\n+      int i;\n+      \n+      for (i = 0; i < TARGET_HASH_PRIME; ++i) \n+\t{\n+\t  struct target_info *ti = target_hash_table[i];\n+\n+\t  while (ti) \n+\t    {\n+\t      struct target_info *next = ti->next;\n+\t      free (ti);\n+\t      ti = next;\n+\t    }\n+\t}\n+\n       free (target_hash_table);\n       target_hash_table = NULL;\n     }"}, {"sha": "e4b2c48ad337c2963c5d778c62f33637833c0b84", "filename": "gcc/rtl.c", "status": "modified", "additions": 17, "deletions": 40, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -32,13 +32,6 @@ Boston, MA 02111-1307, USA.  */\n #define\tobstack_chunk_alloc\txmalloc\n #define\tobstack_chunk_free\tfree\n \n-/* Obstack used for allocating RTL objects.\n-   Between functions, this is the permanent_obstack.\n-   While parsing and expanding a function, this is maybepermanent_obstack\n-   so we can save it if it is an inline function.\n-   During optimization and output, this is function_obstack.  */\n-\n-extern struct obstack *rtl_obstack;\n \f\n /* Calculate the format for CONST_DOUBLE.  This depends on the relative\n    widths of HOST_WIDE_INT and REAL_VALUE_TYPE.\n@@ -312,12 +305,7 @@ rtvec_alloc (n)\n {\n   rtvec rt;\n \n-  if (ggc_p)\n-    rt = ggc_alloc_rtvec (n);\n-  else\n-    rt = (rtvec) obstack_alloc (rtl_obstack,\n-\t\t\t\tsizeof (struct rtvec_def)\n-\t\t\t\t+ ((n - 1) * sizeof (rtx)));\n+  rt = ggc_alloc_rtvec (n);\n   /* clear out the vector */\n   memset (&rt->elem[0], 0, n * sizeof (rtx));\n \n@@ -335,12 +323,7 @@ rtx_alloc (code)\n   rtx rt;\n   int n = GET_RTX_LENGTH (code);\n \n-  if (ggc_p)\n-    rt = ggc_alloc_rtx (n);\n-  else\n-    rt = (rtx) obstack_alloc (rtl_obstack,\n-\t\t\t      sizeof (struct rtx_def)\n-\t\t\t      + ((n - 1) * sizeof (rtunion)));\n+  rt = ggc_alloc_rtx (n);\n \n   /* We want to clear everything up to the FLD array.  Normally, this\n      is one int, but we don't want to assume that and it isn't very\n@@ -351,15 +334,6 @@ rtx_alloc (code)\n   return rt;\n }\n \n-/* Free the rtx X and all RTL allocated since X.  */\n-\n-void\n-rtx_free (x)\n-     rtx x;\n-{\n-  if (!ggc_p)\n-    obstack_free (rtl_obstack, x);\n-}\n \f\n /* Create a new copy of an rtx.\n    Recursively copies the operands of the rtx,\n@@ -449,14 +423,6 @@ copy_rtx (orig)\n \t    }\n \t  break;\n \n-\tcase 'b':\n-\t  {\n-\t    bitmap new_bits = BITMAP_OBSTACK_ALLOC (rtl_obstack);\n-\t    bitmap_copy (new_bits, XBITMAP (orig, i));\n-\t    XBITMAP (copy, i) = new_bits;\n-\t    break;\n-\t  }\n-\n \tcase 't':\n \tcase 'w':\n \tcase 'i':\n@@ -923,13 +889,24 @@ read_rtx (infile)\n   int tmp_int;\n   HOST_WIDE_INT tmp_wide;\n \n+  /* Obstack used for allocating RTL objects.  */\n+  static struct obstack rtl_obstack;\n+  static int initialized;\n+\n   /* Linked list structure for making RTXs: */\n   struct rtx_list\n     {\n       struct rtx_list *next;\n       rtx value;\t\t/* Value of this node.  */\n     };\n \n+  if (!initialized) {\n+    _obstack_begin (&rtl_obstack,0, 0,\n+\t\t    (void *(*) PARAMS ((long))) xmalloc,\n+\t\t    (void (*) PARAMS ((void *))) free);\n+    initialized = 1;\n+  }\n+\n   c = read_skip_spaces (infile); /* Should be open paren.  */\n   if (c != '(')\n     fatal_expected_char (infile, '(', c);\n@@ -1083,7 +1060,7 @@ read_rtx (infile)\n \t\t     newline and tab.  */\n \t\t  if (c == ';')\n \t\t    {\n-\t\t      obstack_grow (rtl_obstack, \"\\\\n\\\\t\", 4);\n+\t\t      obstack_grow (&rtl_obstack, \"\\\\n\\\\t\", 4);\n \t\t      continue;\n \t\t    }\n \t\t  if (c == '\\n')\n@@ -1092,11 +1069,11 @@ read_rtx (infile)\n \t      else if (c == '\"')\n \t\tbreak;\n \n-\t      obstack_1grow (rtl_obstack, c);\n+\t      obstack_1grow (&rtl_obstack, c);\n \t    }\n \n-\t  obstack_1grow (rtl_obstack, 0);\n-\t  stringbuf = (char *) obstack_finish (rtl_obstack);\n+\t  obstack_1grow (&rtl_obstack, 0);\n+\t  stringbuf = (char *) obstack_finish (&rtl_obstack);\n \n \t  if (saw_paren)\n \t    {"}, {"sha": "674a5a1722aaf47e6606dd964089b851fa87f17f", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -1145,7 +1145,6 @@ extern rtx gen_rtx\t\t\tPARAMS ((enum rtx_code,\n extern rtvec gen_rtvec\t\t\tPARAMS ((int, ...));\n \n /* In other files */\n-extern char *oballoc\t\t\tPARAMS ((int));\n extern char *permalloc\t\t\tPARAMS ((int));\n extern rtx rtx_alloc\t\t\tPARAMS ((RTX_CODE));\n extern rtvec rtvec_alloc\t\tPARAMS ((int));\n@@ -1631,12 +1630,9 @@ extern int no_new_pseudos;\n extern int rtx_to_tree_code\tPARAMS ((enum rtx_code));\n \n /* In tree.c */\n-extern void obfree\t\t\tPARAMS ((char *));\n struct obstack;\n extern void gcc_obstack_init\t\tPARAMS ((struct obstack *));\n-extern void pop_obstacks\t\tPARAMS ((void));\n-extern void push_obstacks\t\tPARAMS ((struct obstack *,\n-\t\t\t\t\t\tstruct obstack *));\n+\n /* In cse.c */\n struct cse_basic_block_data;\n \n@@ -1801,8 +1797,6 @@ extern void move_by_pieces\t\tPARAMS ((rtx, rtx,\n \t\t\t\t\t\t unsigned int));\n \n /* In flow.c */\n-extern void allocate_bb_life_data\tPARAMS ((void));\n-extern void allocate_reg_life_data\tPARAMS ((void));\n extern void recompute_reg_usage\t\tPARAMS ((rtx, int));\n #ifdef BUFSIZ\n extern void print_rtl_with_bb\t\tPARAMS ((FILE *, rtx));\n@@ -1947,7 +1941,6 @@ extern void init_varasm_once\t\tPARAMS ((void));\n \n /* In rtl.c */\n extern void init_rtl\t\t\tPARAMS ((void));\n-extern void rtx_free\t\t\tPARAMS ((rtx));\n \n #ifdef BUFSIZ\n extern int read_skip_spaces\t\tPARAMS ((FILE *));"}, {"sha": "863a2a0793114d9d6ce2d61bc332ced43930f264", "filename": "gcc/sdbout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -994,7 +994,7 @@ static void\n sdbout_queue_anonymous_type (type)\n      tree type;\n {\n-  anonymous_types = saveable_tree_cons (NULL_TREE, type, anonymous_types);\n+  anonymous_types = tree_cons (NULL_TREE, type, anonymous_types);\n }\n \n static void"}, {"sha": "85ce605abbf881d9d61ec458ade2c978cb69e79e", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -3274,14 +3274,10 @@ cselib_init ()\n   /* These are only created once.  */\n   if (! callmem)\n     {\n-      extern struct obstack permanent_obstack;\n-\n       gcc_obstack_init (&cselib_obstack);\n       cselib_startobj = obstack_alloc (&cselib_obstack, 0);\n \n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n       callmem = gen_rtx_MEM (BLKmode, const0_rtx);\n-      pop_obstacks ();\n       ggc_add_rtx_root (&callmem, 1);\n     }\n "}, {"sha": "927748178247df9a8a435843b3c82da3c4d06fd7", "filename": "gcc/stmt.c", "status": "modified", "additions": 28, "deletions": 31, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -426,7 +426,7 @@ static void mark_block_nesting          PARAMS ((struct nesting *));\n static void mark_case_nesting           PARAMS ((struct nesting *));\n static void mark_case_node\t\tPARAMS ((struct case_node *));\n static void mark_goto_fixup             PARAMS ((struct goto_fixup *));\n-\n+static void free_case_nodes             PARAMS ((case_node_ptr));\n \f\n void\n using_eh_for_cleanups ()\n@@ -485,8 +485,11 @@ mark_block_nesting (n)\n       ggc_mark_tree (n->data.block.cleanups);\n       ggc_mark_tree (n->data.block.outer_cleanups);\n \n-      for (l = n->data.block.label_chain; l != NULL; l = l->next)\n-\tggc_mark_tree (l->label);\n+      for (l = n->data.block.label_chain; l != NULL; l = l->next) \n+\t{\n+\t  ggc_mark (l);\n+\t  ggc_mark_tree (l->label);\n+\t}\n \n       ggc_mark_rtx (n->data.block.last_unconditional_cleanup);\n \n@@ -748,7 +751,7 @@ expand_label (label)\n \n   if (stack_block_stack != 0)\n     {\n-      p = (struct label_chain *) oballoc (sizeof (struct label_chain));\n+      p = (struct label_chain *) ggc_alloc (sizeof (struct label_chain));\n       p->next = stack_block_stack->data.block.label_chain;\n       stack_block_stack->data.block.label_chain = p;\n       p->label = label;\n@@ -2093,14 +2096,11 @@ clear_last_expr ()\n tree\n expand_start_stmt_expr ()\n {\n-  int momentary;\n   tree t;\n \n   /* Make the RTL_EXPR node temporary, not momentary,\n      so that rtl_expr_chain doesn't become garbage.  */\n-  momentary = suspend_momentary ();\n   t = make_node (RTL_EXPR);\n-  resume_momentary (momentary);\n   do_pending_stack_adjust ();\n   start_sequence_for_rtl_expr (t);\n   NO_DEFER_POP;\n@@ -3998,10 +3998,6 @@ expand_decl_cleanup (decl, cleanup)\n \n \t  emit_move_insn (flag, const1_rtx);\n \n-\t  /* All cleanups must be on the function_obstack.  */\n-\t  push_obstacks_nochange ();\n-\t  resume_temporary_allocation ();\n-\n \t  cond = build_decl (VAR_DECL, NULL_TREE, type_for_mode (word_mode, 1));\n \t  DECL_RTL (cond) = flag;\n \n@@ -4011,18 +4007,12 @@ expand_decl_cleanup (decl, cleanup)\n \t\t\t   cleanup, integer_zero_node);\n \t  cleanup = fold (cleanup);\n \n-\t  pop_obstacks ();\n-\n \t  cleanups = thisblock->data.block.cleanup_ptr;\n \t}\n \n-      /* All cleanups must be on the function_obstack.  */\n-      push_obstacks_nochange ();\n-      resume_temporary_allocation ();\n       cleanup = unsave_expr (cleanup);\n-      pop_obstacks ();\n \n-      t = *cleanups = temp_tree_cons (decl, cleanup, *cleanups);\n+      t = *cleanups = tree_cons (decl, cleanup, *cleanups);\n \n       if (! cond_context)\n \t/* If this block has a cleanup, it belongs in stack_block_stack.  */\n@@ -4114,15 +4104,11 @@ expand_dcc_cleanup (decl)\n \n   /* Record the cleanup for the dynamic handler chain.  */\n \n-  /* All cleanups must be on the function_obstack.  */\n-  push_obstacks_nochange ();\n-  resume_temporary_allocation ();\n   cleanup = make_node (POPDCC_EXPR);\n-  pop_obstacks ();\n \n   /* Add the cleanup in a manner similar to expand_decl_cleanup.  */\n   thisblock->data.block.cleanups\n-    = temp_tree_cons (decl, cleanup, thisblock->data.block.cleanups);\n+    = tree_cons (decl, cleanup, thisblock->data.block.cleanups);\n \n   /* If this block has a cleanup, it belongs in stack_block_stack.  */\n   stack_block_stack = thisblock;\n@@ -4156,15 +4142,11 @@ expand_dhc_cleanup (decl)\n \n   /* Record the cleanup for the dynamic handler chain.  */\n \n-  /* All cleanups must be on the function_obstack.  */\n-  push_obstacks_nochange ();\n-  resume_temporary_allocation ();\n   cleanup = make_node (POPDHC_EXPR);\n-  pop_obstacks ();\n \n   /* Add the cleanup in a manner similar to expand_decl_cleanup.  */\n   thisblock->data.block.cleanups\n-    = temp_tree_cons (decl, cleanup, thisblock->data.block.cleanups);\n+    = tree_cons (decl, cleanup, thisblock->data.block.cleanups);\n \n   /* If this block has a cleanup, it belongs in stack_block_stack.  */\n   stack_block_stack = thisblock;\n@@ -4239,8 +4221,8 @@ expand_anon_union_decl (decl, cleanup, decl_elts)\n \n       if (cleanup != 0)\n \tthisblock->data.block.cleanups\n-\t  = temp_tree_cons (decl_elt, cleanup_elt,\n-\t\t\t    thisblock->data.block.cleanups);\n+\t  = tree_cons (decl_elt, cleanup_elt,\n+\t\t       thisblock->data.block.cleanups);\n     }\n }\n \f\n@@ -4713,7 +4695,7 @@ add_case_node (low, high, label, duplicate)\n      Copy LOW, HIGH so they are on temporary rather than momentary\n      obstack and will thus survive till the end of the case statement.  */\n \n-  r = (struct case_node *) oballoc (sizeof (struct case_node));\n+  r = (struct case_node *) xmalloc (sizeof (struct case_node));\n   r->low = copy_node (low);\n \n   /* If the bounds are equal, turn this into the one-value case.  */\n@@ -5247,6 +5229,20 @@ check_for_full_enumeration_handling (type)\n #endif /* 0 */\n }\n \n+/* Free CN, and its children.  */\n+\n+static void \n+free_case_nodes (cn)\n+     case_node_ptr cn;\n+{\n+  if (cn) \n+    {\n+      free_case_nodes (cn->left);\n+      free_case_nodes (cn->right);\n+      free (cn);\n+    }\n+}\n+\n \f\n /* Terminate a case (Pascal) or switch (C) statement\n    in which ORIG_INDEX is the expression to be tested.\n@@ -5634,6 +5630,7 @@ expand_end_case (orig_index)\n   if (thiscase->exit_label)\n     emit_label (thiscase->exit_label);\n \n+  free_case_nodes (case_stack->data.case_stmt.case_list);\n   POPSTACK (case_stack);\n \n   free_temp_slots ();"}, {"sha": "095780a6d45cb8e4bedf8c60fa86a2b0f107f25b", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -1230,25 +1230,13 @@ void\n layout_type (type)\n      tree type;\n {\n-  int old;\n-\n   if (type == 0)\n     abort ();\n \n   /* Do nothing if type has been laid out before.  */\n   if (TYPE_SIZE (type))\n     return;\n \n-  /* Make sure all nodes we allocate are not momentary; they must last\n-     past the current statement.  */\n-  old = suspend_momentary ();\n-\n-  /* Put all our nodes into the same obstack as the type.  Also,\n-     make expressions saveable (this is a no-op for permanent types).  */\n-\n-  push_obstacks (TYPE_OBSTACK (type), TYPE_OBSTACK (type));\n-  saveable_allocation ();\n-\n   switch (TREE_CODE (type))\n     {\n     case LANG_TYPE:\n@@ -1536,9 +1524,6 @@ layout_type (type)\n       && TREE_CODE (type) != QUAL_UNION_TYPE)\n     finalize_type_size (type);\n \n-  pop_obstacks ();\n-  resume_momentary (old);\n-\n   /* If this type is created before sizetype has been permanently set,\n      record it so set_sizetype can fix it up.  */\n   if (! sizetype_set)"}, {"sha": "15e1f65dc62c086bd22918542d6c747df0fb3cd4", "filename": "gcc/toplev.c", "status": "modified", "additions": 24, "deletions": 58, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -1956,9 +1956,7 @@ wrapup_global_declarations (vec, len)\n \t\t  || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))\n \t    {\n \t      reconsider = 1;\n-\t      temporary_allocation ();\n \t      output_inline_function (decl);\n-\t      permanent_allocation (1);\n \t    }\n \t}\n \n@@ -2218,7 +2216,7 @@ compile_file (name)\n            _IOFBF, IO_BUFFER_SIZE);\n #endif\n \n-  if (ggc_p && name != 0)\n+  if (name != 0)\n     name = ggc_alloc_string (name, strlen (name));\n \n   input_filename = name;\n@@ -2715,6 +2713,8 @@ rest_of_compilation (decl)\n   if (cfun->x_whole_function_mode_p)\n     reorder_blocks ();\n \n+  init_flow ();\n+\n   /* If we are reconsidering an inline function\n      at the end of compilation, skip the stuff for making it inline.  */\n \n@@ -2838,8 +2838,7 @@ rest_of_compilation (decl)\n \n   init_EXPR_INSN_LIST_cache ();\n \n-  if (ggc_p)\n-    ggc_collect ();\n+  ggc_collect ();\n \n   /* Initialize some variables used by the optimizers.  */\n   init_function_for_compilation ();\n@@ -2884,14 +2883,6 @@ rest_of_compilation (decl)\n     FINALIZE_PIC;\n #endif\n \n-  /* From now on, allocate rtl in current_obstack, not in saveable_obstack.\n-     The call to resume_temporary_allocation near the end of this function\n-     goes back to the usual state of affairs.  This must be done after\n-     we've built up any unwinders for exception handling, and done\n-     the FINALIZE_PIC work, if necessary.  */\n-\n-  rtl_in_current_obstack ();\n-\n   insns = get_insns ();\n \n   /* Copy any shared structure that should not be shared.  */\n@@ -2963,8 +2954,7 @@ rest_of_compilation (decl)\n \n   close_dump_file (DFI_jump, print_rtl, insns);\n \n-  if (ggc_p)\n-    ggc_collect ();\n+  ggc_collect ();\n \n   /* Perform common subexpression elimination.\n      Nonzero value from `cse_main' means that jumps were simplified\n@@ -3030,8 +3020,7 @@ rest_of_compilation (decl)\n \n   close_dump_file (DFI_addressof, print_rtl, insns);\n \n-  if (ggc_p)\n-    ggc_collect ();\n+  ggc_collect ();\n \n   if (optimize > 0 && flag_ssa)\n     {\n@@ -3082,8 +3071,7 @@ rest_of_compilation (decl)\n       close_dump_file (DFI_ussa, print_rtl_with_bb, insns);\n       timevar_pop (TV_FROM_SSA);\n \n-      if (ggc_p)\n-\tggc_collect ();\n+      ggc_collect ();\n     }\n \n   /* Perform global cse.  */\n@@ -3110,8 +3098,7 @@ rest_of_compilation (decl)\n       close_dump_file (DFI_gcse, print_rtl, insns);\n       timevar_pop (TV_GCSE);\n \n-      if (ggc_p)\n-\tggc_collect ();\n+      ggc_collect ();\n     }\n \n   /* Move constant computations out of loops.  */\n@@ -3143,8 +3130,7 @@ rest_of_compilation (decl)\n       close_dump_file (DFI_loop, print_rtl, insns);\n       timevar_pop (TV_LOOP);\n \n-      if (ggc_p)\n-\tggc_collect ();\n+      ggc_collect ();\n     }\n \n   if (optimize > 0)\n@@ -3200,8 +3186,7 @@ rest_of_compilation (decl)\n       close_dump_file (DFI_cse2, print_rtl, insns);\n       timevar_pop (TV_CSE2);\n \n-      if (ggc_p)\n-\tggc_collect ();\n+      ggc_collect ();\n     }\n \n   cse_not_expected = 1;\n@@ -3264,8 +3249,7 @@ rest_of_compilation (decl)\n \n   close_dump_file (DFI_life, print_rtl_with_bb, insns);\n \n-  if (ggc_p)\n-    ggc_collect ();\n+  ggc_collect ();\n \n   /* If -opt, try combining insns through substitution.  */\n \n@@ -3307,8 +3291,7 @@ rest_of_compilation (decl)\n       close_dump_file (DFI_combine, print_rtl_with_bb, insns);\n       timevar_pop (TV_COMBINE);\n \n-      if (ggc_p)\n-\tggc_collect ();\n+      ggc_collect ();\n     }\n \n   /* Rerun if-conversion, as combine may have simplified things enough to\n@@ -3338,8 +3321,7 @@ rest_of_compilation (decl)\n       close_dump_file (DFI_regmove, print_rtl_with_bb, insns);\n       timevar_pop (TV_REGMOVE);\n \n-      if (ggc_p)\n-\tggc_collect ();\n+      ggc_collect ();\n     }\n \n   /* Any of the several passes since flow1 will have munged register\n@@ -3381,8 +3363,7 @@ rest_of_compilation (decl)\n       close_dump_file (DFI_sched, print_rtl_with_bb, insns);\n       timevar_pop (TV_SCHED);\n \n-      if (ggc_p)\n-\tggc_collect ();\n+      ggc_collect ();\n \n       /* Register lifetime information was updated as part of verifying\n \t the schedule.  */\n@@ -3421,8 +3402,7 @@ rest_of_compilation (decl)\n       timevar_pop (TV_DUMP);\n     }\n \n-  if (ggc_p)\n-    ggc_collect ();\n+  ggc_collect ();\n \n   timevar_push (TV_GLOBAL_ALLOC);\n   open_dump_file (DFI_greg, decl);\n@@ -3443,8 +3423,7 @@ rest_of_compilation (decl)\n   if (failure)\n     goto exit_rest_of_compilation;\n \n-  if (ggc_p)\n-    ggc_collect ();\n+  ggc_collect ();\n \n   /* Do a very simple CSE pass over just the hard registers.  */\n   if (optimize > 0)\n@@ -3514,8 +3493,7 @@ rest_of_compilation (decl)\n #endif\n \tcombine_stack_adjustments ();\n \n-      if (ggc_p)\n-\tggc_collect ();\n+      ggc_collect ();\n     }\n \n   flow2_completed = 1;\n@@ -3572,8 +3550,7 @@ rest_of_compilation (decl)\n       close_dump_file (DFI_sched2, print_rtl_with_bb, insns);\n       timevar_pop (TV_SCHED2);\n \n-      if (ggc_p)\n-\tggc_collect ();\n+      ggc_collect ();\n     }\n #endif\n \n@@ -3618,8 +3595,7 @@ rest_of_compilation (decl)\n \n   close_dump_file (DFI_mach, print_rtl_with_bb, insns);\n \n-  if (ggc_p)\n-    ggc_collect ();\n+  ggc_collect ();\n #endif\n \n   /* If a scheduling pass for delayed branches is to be done,\n@@ -3636,8 +3612,7 @@ rest_of_compilation (decl)\n       close_dump_file (DFI_dbr, print_rtl_with_bb, insns);\n       timevar_pop (TV_DBR_SCHED);\n \n-      if (ggc_p)\n-\tggc_collect ();\n+      ggc_collect ();\n     }\n #endif\n \n@@ -3658,8 +3633,7 @@ rest_of_compilation (decl)\n   close_dump_file (DFI_stack, print_rtl_with_bb, insns);\n   timevar_pop (TV_REG_STACK);\n \n-  if (ggc_p)\n-    ggc_collect ();\n+  ggc_collect ();\n #endif\n \n   current_function_nothrow = nothrow_function_p ();\n@@ -3702,8 +3676,7 @@ rest_of_compilation (decl)\n   }\n   timevar_pop (TV_FINAL);\n \n-  if (ggc_p)\n-    ggc_collect ();\n+  ggc_collect ();\n \n   /* Write DBX symbols if requested.  */\n \n@@ -3756,9 +3729,6 @@ rest_of_compilation (decl)\n      it runs through become garbage.  */\n   clear_const_double_mem ();\n \n-  /* Cancel the effect of rtl_in_current_obstack.  */\n-  resume_temporary_allocation ();\n-\n   /* Show no temporary slots allocated.  */\n   init_temp_slots ();\n \n@@ -3783,8 +3753,7 @@ rest_of_compilation (decl)\n     free_after_compilation (cfun);\n   cfun = 0;\n \n-  if (ggc_p)\n-    ggc_collect ();\n+  ggc_collect ();\n \n   timevar_pop (TV_REST_OF_COMPILATION);\n }\n@@ -4094,10 +4063,7 @@ decode_f_option (arg)\n \t    = skip_leading_substring (arg, \"stack-limit-symbol=\")))\n     {\n       char *nm;\n-      if (ggc_p)\n-\tnm = ggc_alloc_string (option_value, strlen (option_value));\n-      else\n-\tnm = xstrdup (option_value);\n+      nm = ggc_strdup (option_value);\n       stack_limit_rtx = gen_rtx_SYMBOL_REF (Pmode, nm);\n     }\n   else if ((option_value"}, {"sha": "7bd7a41309fdf16e5493a024bf81bf429b1ed0bb", "filename": "gcc/tree.c", "status": "modified", "additions": 10, "deletions": 796, "changes": 806, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -53,112 +53,10 @@ extern int _obstack_allocated_p PARAMS ((struct obstack *h, PTR obj));\n \n static void unsave_expr_now_r PARAMS ((tree));\n \n-/* Tree nodes of permanent duration are allocated in this obstack.\n-   They are the identifier nodes, and everything outside of\n-   the bodies and parameters of function definitions.  */\n+/* Objects allocated on this obstack last forever.  */\n \n struct obstack permanent_obstack;\n \n-/* The initial RTL, and all ..._TYPE nodes, in a function\n-   are allocated in this obstack.  Usually they are freed at the\n-   end of the function, but if the function is inline they are saved.\n-   For top-level functions, this is maybepermanent_obstack.\n-   Separate obstacks are made for nested functions.  */\n-\n-struct obstack *function_maybepermanent_obstack;\n-\n-/* This is the function_maybepermanent_obstack for top-level functions.  */\n-\n-struct obstack maybepermanent_obstack;\n-\n-/* The contents of the current function definition are allocated\n-   in this obstack, and all are freed at the end of the function.\n-   For top-level functions, this is temporary_obstack.\n-   Separate obstacks are made for nested functions.  */\n-\n-struct obstack *function_obstack;\n-\n-/* This is used for reading initializers of global variables.  */\n-\n-struct obstack temporary_obstack;\n-\n-/* The tree nodes of an expression are allocated\n-   in this obstack, and all are freed at the end of the expression.  */\n-\n-struct obstack momentary_obstack;\n-\n-/* The tree nodes of a declarator are allocated\n-   in this obstack, and all are freed when the declarator\n-   has been parsed.  */\n-\n-static struct obstack temp_decl_obstack;\n-\n-/* This points at either permanent_obstack\n-   or the current function_maybepermanent_obstack.  */\n-\n-struct obstack *saveable_obstack;\n-\n-/* This is same as saveable_obstack during parse and expansion phase;\n-   it points to the current function's obstack during optimization.\n-   This is the obstack to be used for creating rtl objects.  */\n-\n-struct obstack *rtl_obstack;\n-\n-/* This points at either permanent_obstack or the current function_obstack.  */\n-\n-struct obstack *current_obstack;\n-\n-/* This points at either permanent_obstack or the current function_obstack\n-   or momentary_obstack.  */\n-\n-struct obstack *expression_obstack;\n-\n-/* Stack of obstack selections for push_obstacks and pop_obstacks.  */\n-\n-struct obstack_stack\n-{\n-  struct obstack_stack *next;\n-  struct obstack *current;\n-  struct obstack *saveable;\n-  struct obstack *expression;\n-  struct obstack *rtl;\n-};\n-\n-struct obstack_stack *obstack_stack;\n-\n-/* Obstack for allocating struct obstack_stack entries.  */\n-\n-static struct obstack obstack_stack_obstack;\n-\n-/* Addresses of first objects in some obstacks.\n-   This is for freeing their entire contents.  */\n-char *maybepermanent_firstobj;\n-char *temporary_firstobj;\n-char *momentary_firstobj;\n-char *temp_decl_firstobj;\n-\n-/* This is used to preserve objects (mainly array initializers) that need to\n-   live until the end of the current function, but no further.  */\n-char *momentary_function_firstobj;\n-\n-/* Nonzero means all ..._TYPE nodes should be allocated permanently.  */\n-\n-int all_types_permanent;\n-\n-/* Stack of places to restore the momentary obstack back to.  */\n-\n-struct momentary_level\n-{\n-  /* Pointer back to previous such level.  */\n-  struct momentary_level *prev;\n-  /* First object allocated within this level.  */\n-  char *base;\n-  /* Value of expression_obstack saved at entry to this level.  */\n-  struct obstack *obstack;\n-};\n-\n-struct momentary_level *momentary_stack;\n-\n /* Table indexed by tree code giving a string containing a character\n    classifying the tree code.  Possibilities are\n    t, d, s, c, r, <, 1, 2 and e.  See tree.def for details.  */\n@@ -304,26 +202,8 @@ tree integer_types[itk_none];\n void\n init_obstacks ()\n {\n-  gcc_obstack_init (&obstack_stack_obstack);\n   gcc_obstack_init (&permanent_obstack);\n \n-  gcc_obstack_init (&temporary_obstack);\n-  temporary_firstobj = (char *) obstack_alloc (&temporary_obstack, 0);\n-  gcc_obstack_init (&momentary_obstack);\n-  momentary_firstobj = (char *) obstack_alloc (&momentary_obstack, 0);\n-  momentary_function_firstobj = momentary_firstobj;\n-  gcc_obstack_init (&maybepermanent_obstack);\n-  maybepermanent_firstobj\n-    = (char *) obstack_alloc (&maybepermanent_obstack, 0);\n-  gcc_obstack_init (&temp_decl_obstack);\n-  temp_decl_firstobj = (char *) obstack_alloc (&temp_decl_obstack, 0);\n-\n-  function_obstack = &temporary_obstack;\n-  function_maybepermanent_obstack = &maybepermanent_obstack;\n-  current_obstack = &permanent_obstack;\n-  expression_obstack = &permanent_obstack;\n-  rtl_obstack = saveable_obstack = &permanent_obstack;\n-\n   /* Init the hash table of identifiers.  */\n   bzero ((char *) hash_table, sizeof hash_table);\n   ggc_add_tree_root (hash_table, sizeof hash_table / sizeof (tree));\n@@ -356,309 +236,7 @@ gcc_obstack_init (obstack)\n \t\t  (void (*) PARAMS ((void *))) OBSTACK_CHUNK_FREE);\n }\n \n-/* Save all variables describing the current status into the structure\n-   *P.  This function is called whenever we start compiling one\n-   function in the midst of compiling another.  For example, when\n-   compiling a nested function, or, in C++, a template instantiation\n-   that is required by the function we are currently compiling.\n-\n-   CONTEXT is the decl_function_context for the function we're about to\n-   compile; if it isn't current_function_decl, we have to play some games.  */\n-\n-void\n-save_tree_status (p)\n-     struct function *p;\n-{\n-  p->all_types_permanent = all_types_permanent;\n-  p->momentary_stack = momentary_stack;\n-  p->maybepermanent_firstobj = maybepermanent_firstobj;\n-  p->temporary_firstobj = temporary_firstobj;\n-  p->momentary_firstobj = momentary_firstobj;\n-  p->momentary_function_firstobj = momentary_function_firstobj;\n-  p->function_obstack = function_obstack;\n-  p->function_maybepermanent_obstack = function_maybepermanent_obstack;\n-  p->current_obstack = current_obstack;\n-  p->expression_obstack = expression_obstack;\n-  p->saveable_obstack = saveable_obstack;\n-  p->rtl_obstack = rtl_obstack;\n-\n-  function_maybepermanent_obstack\n-    = (struct obstack *) xmalloc (sizeof (struct obstack));\n-  gcc_obstack_init (function_maybepermanent_obstack);\n-  maybepermanent_firstobj\n-    = (char *) obstack_finish (function_maybepermanent_obstack);\n-\n-  function_obstack = (struct obstack *) xmalloc (sizeof (struct obstack));\n-  gcc_obstack_init (function_obstack);\n-\n-  current_obstack = &permanent_obstack;\n-  expression_obstack = &permanent_obstack;\n-  rtl_obstack = saveable_obstack = &permanent_obstack;\n-\n-  temporary_firstobj = (char *) obstack_alloc (&temporary_obstack, 0);\n-  momentary_firstobj = (char *) obstack_finish (&momentary_obstack);\n-  momentary_function_firstobj = momentary_firstobj;\n-}\n-\n-/* Restore all variables describing the current status from the structure *P.\n-   This is used after a nested function.  */\n-\n-void\n-restore_tree_status (p)\n-     struct function *p;\n-{\n-  all_types_permanent = p->all_types_permanent;\n-  momentary_stack = p->momentary_stack;\n-\n-  obstack_free (&momentary_obstack, momentary_function_firstobj);\n-\n-  /* Free saveable storage used by the function just compiled and not\n-     saved.  */\n-  obstack_free (function_maybepermanent_obstack, maybepermanent_firstobj);\n-  if (obstack_empty_p (function_maybepermanent_obstack))\n-    {\n-      obstack_free (function_maybepermanent_obstack, NULL);\n-      free (function_maybepermanent_obstack);\n-    }\n-\n-  obstack_free (&temporary_obstack, temporary_firstobj);\n-  obstack_free (&momentary_obstack, momentary_function_firstobj);\n-\n-  obstack_free (function_obstack, NULL);\n-  free (function_obstack);\n-\n-  temporary_firstobj = p->temporary_firstobj;\n-  momentary_firstobj = p->momentary_firstobj;\n-  momentary_function_firstobj = p->momentary_function_firstobj;\n-  maybepermanent_firstobj = p->maybepermanent_firstobj;\n-  function_obstack = p->function_obstack;\n-  function_maybepermanent_obstack = p->function_maybepermanent_obstack;\n-  current_obstack = p->current_obstack;\n-  expression_obstack = p->expression_obstack;\n-  saveable_obstack = p->saveable_obstack;\n-  rtl_obstack = p->rtl_obstack;\n-}\n \f\n-/* Start allocating on the temporary (per function) obstack.\n-   This is done in start_function before parsing the function body,\n-   and before each initialization at top level, and to go back\n-   to temporary allocation after doing permanent_allocation.  */\n-\n-void\n-temporary_allocation ()\n-{\n-  /* Note that function_obstack at top level points to temporary_obstack.\n-     But within a nested function context, it is a separate obstack.  */\n-  current_obstack = function_obstack;\n-  expression_obstack = function_obstack;\n-  rtl_obstack = saveable_obstack = function_maybepermanent_obstack;\n-  momentary_stack = 0;\n-}\n-\n-/* Start allocating on the permanent obstack but don't\n-   free the temporary data.  After calling this, call\n-   `permanent_allocation' to fully resume permanent allocation status.  */\n-\n-void\n-end_temporary_allocation ()\n-{\n-  current_obstack = &permanent_obstack;\n-  expression_obstack = &permanent_obstack;\n-  rtl_obstack = saveable_obstack = &permanent_obstack;\n-}\n-\n-/* Resume allocating on the temporary obstack, undoing\n-   effects of `end_temporary_allocation'.  */\n-\n-void\n-resume_temporary_allocation ()\n-{\n-  current_obstack = function_obstack;\n-  expression_obstack = function_obstack;\n-  rtl_obstack = saveable_obstack = function_maybepermanent_obstack;\n-}\n-\n-/* While doing temporary allocation, switch to allocating in such a\n-   way as to save all nodes if the function is inlined.  Call\n-   resume_temporary_allocation to go back to ordinary temporary\n-   allocation.  */\n-\n-void\n-saveable_allocation ()\n-{\n-  /* Note that function_obstack at top level points to temporary_obstack.\n-     But within a nested function context, it is a separate obstack.  */\n-  expression_obstack = current_obstack = saveable_obstack;\n-}\n-\n-/* Switch to current obstack CURRENT and maybepermanent obstack SAVEABLE,\n-   recording the previously current obstacks on a stack.\n-   This does not free any storage in any obstack.  */\n-\n-void\n-push_obstacks (current, saveable)\n-     struct obstack *current, *saveable;\n-{\n-  struct obstack_stack *p;\n-\n-  p = (struct obstack_stack *) obstack_alloc (&obstack_stack_obstack,\n-\t\t\t\t\t      (sizeof (struct obstack_stack)));\n-\n-  p->current = current_obstack;\n-  p->saveable = saveable_obstack;\n-  p->expression = expression_obstack;\n-  p->rtl = rtl_obstack;\n-  p->next = obstack_stack;\n-  obstack_stack = p;\n-\n-  current_obstack = current;\n-  expression_obstack = current;\n-  rtl_obstack = saveable_obstack = saveable;\n-}\n-\n-/* Save the current set of obstacks, but don't change them.  */\n-\n-void\n-push_obstacks_nochange ()\n-{\n-  struct obstack_stack *p;\n-\n-  p = (struct obstack_stack *) obstack_alloc (&obstack_stack_obstack,\n-\t\t\t\t\t      (sizeof (struct obstack_stack)));\n-\n-  p->current = current_obstack;\n-  p->saveable = saveable_obstack;\n-  p->expression = expression_obstack;\n-  p->rtl = rtl_obstack;\n-  p->next = obstack_stack;\n-  obstack_stack = p;\n-}\n-\n-/* Pop the obstack selection stack.  */\n-\n-void\n-pop_obstacks ()\n-{\n-  struct obstack_stack *p;\n-\n-  p = obstack_stack;\n-  obstack_stack = p->next;\n-\n-  current_obstack = p->current;\n-  saveable_obstack = p->saveable;\n-  expression_obstack = p->expression;\n-  rtl_obstack = p->rtl;\n-\n-  obstack_free (&obstack_stack_obstack, p);\n-}\n-\n-/* Nonzero if temporary allocation is currently in effect.\n-   Zero if currently doing permanent allocation.  */\n-\n-int\n-allocation_temporary_p ()\n-{\n-  return current_obstack != &permanent_obstack;\n-}\n-\n-/* Go back to allocating on the permanent obstack\n-   and free everything in the temporary obstack.\n-\n-   FUNCTION_END is true only if we have just finished compiling a function.\n-   In that case, we also free preserved initial values on the momentary\n-   obstack.  */\n-\n-void\n-permanent_allocation (function_end)\n-     int function_end;\n-{\n-  /* Free up previous temporary obstack data */\n-  obstack_free (&temporary_obstack, temporary_firstobj);\n-  if (function_end)\n-    {\n-      obstack_free (&momentary_obstack, momentary_function_firstobj);\n-      momentary_firstobj = momentary_function_firstobj;\n-    }\n-  else\n-    obstack_free (&momentary_obstack, momentary_firstobj);\n-\n-  obstack_free (function_maybepermanent_obstack, maybepermanent_firstobj);\n-  obstack_free (&temp_decl_obstack, temp_decl_firstobj);\n-\n-  current_obstack = &permanent_obstack;\n-  expression_obstack = &permanent_obstack;\n-  rtl_obstack = saveable_obstack = &permanent_obstack;\n-}\n-\n-/* Save permanently everything on the maybepermanent_obstack.  */\n-\n-void\n-preserve_data ()\n-{\n-  maybepermanent_firstobj\n-    = (char *) obstack_alloc (function_maybepermanent_obstack, 0);\n-}\n-\n-void\n-preserve_initializer ()\n-{\n-  struct momentary_level *tem;\n-  char *old_momentary;\n-\n-  temporary_firstobj\n-    = (char *) obstack_alloc (&temporary_obstack, 0);\n-  maybepermanent_firstobj\n-    = (char *) obstack_alloc (function_maybepermanent_obstack, 0);\n-\n-  old_momentary = momentary_firstobj;\n-  momentary_firstobj\n-    = (char *) obstack_alloc (&momentary_obstack, 0);\n-  if (momentary_firstobj != old_momentary)\n-    for (tem = momentary_stack; tem; tem = tem->prev)\n-      tem->base = momentary_firstobj;\n-}\n-\n-/* Start allocating new rtl in current_obstack.\n-   Use resume_temporary_allocation\n-   to go back to allocating rtl in saveable_obstack.  */\n-\n-void\n-rtl_in_current_obstack ()\n-{\n-  rtl_obstack = current_obstack;\n-}\n-\n-/* Start allocating rtl from saveable_obstack.  Intended to be used after\n-   a call to push_obstacks_nochange.  */\n-\n-void\n-rtl_in_saveable_obstack ()\n-{\n-  rtl_obstack = saveable_obstack;\n-}\n-\f\n-/* Allocate SIZE bytes in the current obstack\n-   and return a pointer to them.\n-   In practice the current obstack is always the temporary one.  */\n-\n-char *\n-oballoc (size)\n-     int size;\n-{\n-  return (char *) obstack_alloc (current_obstack, size);\n-}\n-\n-/* Free the object PTR in the current obstack\n-   as well as everything allocated since PTR.\n-   In practice the current obstack is always the temporary one.  */\n-\n-void\n-obfree (ptr)\n-     char *ptr;\n-{\n-  obstack_free (current_obstack, ptr);\n-}\n-\n /* Allocate SIZE bytes in the permanent obstack\n    and return a pointer to them.  */\n \n@@ -683,204 +261,6 @@ perm_calloc (nelem, size)\n   return rval;\n }\n \n-/* Allocate SIZE bytes in the saveable obstack\n-   and return a pointer to them.  */\n-\n-char *\n-savealloc (size)\n-     int size;\n-{\n-  return (char *) obstack_alloc (saveable_obstack, size);\n-}\n-\n-/* Allocate SIZE bytes in the expression obstack\n-   and return a pointer to them.  */\n-\n-char *\n-expralloc (size)\n-     int size;\n-{\n-  return (char *) obstack_alloc (expression_obstack, size);\n-}\n-\f\n-/* Print out which obstack an object is in.  */\n-\n-void\n-print_obstack_name (object, file, prefix)\n-     char *object;\n-     FILE *file;\n-     const char *prefix;\n-{\n-  struct obstack *obstack = NULL;\n-  const char *obstack_name = NULL;\n-  struct function *p;\n-\n-  for (p = outer_function_chain; p; p = p->next)\n-    {\n-      if (_obstack_allocated_p (p->function_obstack, object))\n-\t{\n-\t  obstack = p->function_obstack;\n-\t  obstack_name = \"containing function obstack\";\n-\t}\n-      if (_obstack_allocated_p (p->function_maybepermanent_obstack, object))\n-\t{\n-\t  obstack = p->function_maybepermanent_obstack;\n-\t  obstack_name = \"containing function maybepermanent obstack\";\n-\t}\n-    }\n-\n-  if (_obstack_allocated_p (&obstack_stack_obstack, object))\n-    {\n-      obstack = &obstack_stack_obstack;\n-      obstack_name = \"obstack_stack_obstack\";\n-    }\n-  else if (_obstack_allocated_p (function_obstack, object))\n-    {\n-      obstack = function_obstack;\n-      obstack_name = \"function obstack\";\n-    }\n-  else if (_obstack_allocated_p (&permanent_obstack, object))\n-    {\n-      obstack = &permanent_obstack;\n-      obstack_name = \"permanent_obstack\";\n-    }\n-  else if (_obstack_allocated_p (&momentary_obstack, object))\n-    {\n-      obstack = &momentary_obstack;\n-      obstack_name = \"momentary_obstack\";\n-    }\n-  else if (_obstack_allocated_p (function_maybepermanent_obstack, object))\n-    {\n-      obstack = function_maybepermanent_obstack;\n-      obstack_name = \"function maybepermanent obstack\";\n-    }\n-  else if (_obstack_allocated_p (&temp_decl_obstack, object))\n-    {\n-      obstack = &temp_decl_obstack;\n-      obstack_name = \"temp_decl_obstack\";\n-    }\n-\n-  /* Check to see if the object is in the free area of the obstack.  */\n-  if (obstack != NULL)\n-    {\n-      if (object >= obstack->next_free\n-\t  && object < obstack->chunk_limit)\n-\tfprintf (file, \"%s in free portion of obstack %s\",\n-\t\t prefix, obstack_name);\n-      else\n-\tfprintf (file, \"%s allocated from %s\", prefix, obstack_name);\n-    }\n-  else\n-    fprintf (file, \"%s not allocated from any obstack\", prefix);\n-}\n-\n-void\n-debug_obstack (object)\n-     char *object;\n-{\n-  print_obstack_name (object, stderr, \"object\");\n-  fprintf (stderr, \".\\n\");\n-}\n-\n-/* Return 1 if OBJ is in the permanent obstack.\n-   This is slow, and should be used only for debugging.\n-   Use TREE_PERMANENT for other purposes.  */\n-\n-int\n-object_permanent_p (obj)\n-     tree obj;\n-{\n-  return _obstack_allocated_p (&permanent_obstack, obj);\n-}\n-\f\n-/* Start a level of momentary allocation.\n-   In C, each compound statement has its own level\n-   and that level is freed at the end of each statement.\n-   All expression nodes are allocated in the momentary allocation level.  */\n-\n-void\n-push_momentary ()\n-{\n-  struct momentary_level *tem\n-    = (struct momentary_level *) obstack_alloc (&momentary_obstack,\n-\t\t\t\t\t\tsizeof (struct momentary_level));\n-  tem->prev = momentary_stack;\n-  tem->base = (char *) obstack_base (&momentary_obstack);\n-  tem->obstack = expression_obstack;\n-  momentary_stack = tem;\n-  expression_obstack = &momentary_obstack;\n-}\n-\n-/* Set things up so the next clear_momentary will only clear memory\n-   past our present position in momentary_obstack.  */\n-\n-void\n-preserve_momentary ()\n-{\n-  momentary_stack->base = (char *) obstack_base (&momentary_obstack);\n-}\n-\n-/* Free all the storage in the current momentary-allocation level.\n-   In C, this happens at the end of each statement.  */\n-\n-void\n-clear_momentary ()\n-{\n-  obstack_free (&momentary_obstack, momentary_stack->base);\n-}\n-\n-/* Discard a level of momentary allocation.\n-   In C, this happens at the end of each compound statement.\n-   Restore the status of expression node allocation\n-   that was in effect before this level was created.  */\n-\n-void\n-pop_momentary ()\n-{\n-  struct momentary_level *tem = momentary_stack;\n-  momentary_stack = tem->prev;\n-  expression_obstack = tem->obstack;\n-  /* We can't free TEM from the momentary_obstack, because there might\n-     be objects above it which have been saved.  We can free back to the\n-     stack of the level we are popping off though.  */\n-  obstack_free (&momentary_obstack, tem->base);\n-}\n-\n-/* Pop back to the previous level of momentary allocation,\n-   but don't free any momentary data just yet.  */\n-\n-void\n-pop_momentary_nofree ()\n-{\n-  struct momentary_level *tem = momentary_stack;\n-  momentary_stack = tem->prev;\n-  expression_obstack = tem->obstack;\n-}\n-\n-/* Call when starting to parse a declaration:\n-   make expressions in the declaration last the length of the function.\n-   Returns an argument that should be passed to resume_momentary later.  */\n-\n-int\n-suspend_momentary ()\n-{\n-  register int tem = expression_obstack == &momentary_obstack;\n-  expression_obstack = saveable_obstack;\n-  return tem;\n-}\n-\n-/* Call when finished parsing a declaration:\n-   restore the treatment of node-allocation that was\n-   in effect before the suspension.\n-   YES should be the value previously returned by suspend_momentary.  */\n-\n-void\n-resume_momentary (yes)\n-     int yes;\n-{\n-  if (yes)\n-    expression_obstack = &momentary_obstack;\n-}\n \f\n /* Init the tables indexed by tree code.\n    Note that languages can add to these tables to define their own codes.  */\n@@ -951,9 +331,6 @@ tree_size (node)\n }\n \n /* Return a newly allocated node of code CODE.\n-   Initialize the node's unique id and its TREE_PERMANENT flag.\n-   Note that if garbage collection is in use, TREE_PERMANENT will\n-   always be zero - we want to eliminate use of TREE_PERMANENT.\n    For decl and type nodes, some other fields are initialized.\n    The rest of the node is initialized to zero.\n \n@@ -1037,7 +414,6 @@ make_node (code)\n   memset ((PTR) t, 0, length);\n \n   TREE_SET_CODE (t, code);\n-  TREE_SET_PERMANENT (t);\n \n   switch (type)\n     {\n@@ -1133,10 +509,7 @@ copy_node (node)\n   register size_t length;\n \n   length = tree_size (node);\n-  if (ggc_p)\n-    t = ggc_alloc_tree (length);\n-  else\n-    t = (tree) obstack_alloc (current_obstack, length);\n+  t = ggc_alloc_tree (length);\n   memcpy (t, node, length);\n \n   TREE_CHAIN (t) = 0;\n@@ -1147,8 +520,6 @@ copy_node (node)\n   else if (TREE_CODE_CLASS (code) == 't')\n     {\n       TYPE_UID (t) = next_type_uid++;\n-      TYPE_OBSTACK (t) = current_obstack;\n-\n       /* The following is so that the debug code for\n \t the copy is different from the original type.\n \t The two statements usually duplicate each other\n@@ -1158,8 +529,6 @@ copy_node (node)\n       TYPE_SYMTAB_ADDRESS (t) = 0;\n     }\n \n-  TREE_SET_PERMANENT (t);\n-\n   return t;\n }\n \n@@ -1246,10 +615,7 @@ get_identifier (text)\n   id_string_size += len;\n #endif\n \n-  if (ggc_p)\n-    IDENTIFIER_POINTER (idp) = ggc_alloc_string (text, len);\n-  else\n-    IDENTIFIER_POINTER (idp) = obstack_copy0 (&permanent_obstack, text, len);\n+  IDENTIFIER_POINTER (idp) = ggc_alloc_string (text, len);\n \n   TREE_CHAIN (idp) = hash_table[hi];\n   hash_table[hi] = idp;\n@@ -1492,17 +858,10 @@ build_string (len, str)\n      int len;\n      const char *str;\n {\n-  /* Put the string in saveable_obstack since it will be placed in the RTL\n-     for an \"asm\" statement and will also be kept around a while if\n-     deferring constant output in varasm.c.  */\n-\n   register tree s = make_node (STRING_CST);\n \n   TREE_STRING_LENGTH (s) = len;\n-  if (ggc_p)\n-    TREE_STRING_POINTER (s) = ggc_alloc_string (str, len);\n-  else\n-    TREE_STRING_POINTER (s) = obstack_copy0 (saveable_obstack, str, len);\n+  TREE_STRING_POINTER (s) = ggc_alloc_string (str, len);\n \n   return s;\n }\n@@ -1536,22 +895,17 @@ make_tree_vec (len)\n {\n   register tree t;\n   register int length = (len-1) * sizeof (tree) + sizeof (struct tree_vec);\n-  register struct obstack *obstack = current_obstack;\n \n #ifdef GATHER_STATISTICS\n   tree_node_counts[(int)vec_kind]++;\n   tree_node_sizes[(int)vec_kind] += length;\n #endif\n \n-  if (ggc_p)\n-    t = ggc_alloc_tree (length);\n-  else\n-    t = (tree) obstack_alloc (obstack, length);\n+  t = ggc_alloc_tree (length);\n \n   memset ((PTR) t, 0, length);\n   TREE_SET_CODE (t, TREE_VEC);\n   TREE_VEC_LENGTH (t) = len;\n-  TREE_SET_PERMANENT (t);\n \n   return t;\n }\n@@ -2062,36 +1416,6 @@ build_tree_list (parm, value)\n   return t;\n }\n \n-/* Similar, but build on the temp_decl_obstack.  */\n-\n-tree\n-build_decl_list (parm, value)\n-     tree parm, value;\n-{\n-  register tree node;\n-  register struct obstack *ambient_obstack = current_obstack;\n-\n-  current_obstack = &temp_decl_obstack;\n-  node = build_tree_list (parm, value);\n-  current_obstack = ambient_obstack;\n-  return node;\n-}\n-\n-/* Similar, but build on the expression_obstack.  */\n-\n-tree\n-build_expr_list (parm, value)\n-     tree parm, value;\n-{\n-  register tree node;\n-  register struct obstack *ambient_obstack = current_obstack;\n-\n-  current_obstack = expression_obstack;\n-  node = build_tree_list (parm, value);\n-  current_obstack = ambient_obstack;\n-  return node;\n-}\n-\n /* Return a newly created TREE_LIST node whose\n    purpose and value fields are PARM and VALUE\n    and whose TREE_CHAIN is CHAIN.  */\n@@ -2102,10 +1426,7 @@ tree_cons (purpose, value, chain)\n {\n   register tree node;\n \n-  if (ggc_p)\n-    node = ggc_alloc_tree (sizeof (struct tree_list));\n-  else\n-    node = (tree) obstack_alloc (current_obstack, sizeof (struct tree_list));\n+  node = ggc_alloc_tree (sizeof (struct tree_list));\n \n   memset (node, 0, sizeof (struct tree_common));\n \n@@ -2115,88 +1436,12 @@ tree_cons (purpose, value, chain)\n #endif\n \n   TREE_SET_CODE (node, TREE_LIST);\n-  TREE_SET_PERMANENT (node);\n-\n   TREE_CHAIN (node) = chain;\n   TREE_PURPOSE (node) = purpose;\n   TREE_VALUE (node) = value;\n   return node;\n }\n \n-/* Similar, but build on the temp_decl_obstack.  */\n-\n-tree\n-decl_tree_cons (purpose, value, chain)\n-     tree purpose, value, chain;\n-{\n-  register tree node;\n-  register struct obstack *ambient_obstack = current_obstack;\n-\n-  current_obstack = &temp_decl_obstack;\n-  node = tree_cons (purpose, value, chain);\n-  current_obstack = ambient_obstack;\n-  return node;\n-}\n-\n-/* Similar, but build on the expression_obstack.  */\n-\n-tree\n-expr_tree_cons (purpose, value, chain)\n-     tree purpose, value, chain;\n-{\n-  register tree node;\n-  register struct obstack *ambient_obstack = current_obstack;\n-\n-  current_obstack = expression_obstack;\n-  node = tree_cons (purpose, value, chain);\n-  current_obstack = ambient_obstack;\n-  return node;\n-}\n-\n-/* Same as `tree_cons' but make a permanent object.  */\n-\n-tree\n-perm_tree_cons (purpose, value, chain)\n-     tree purpose, value, chain;\n-{\n-  register tree node;\n-  register struct obstack *ambient_obstack = current_obstack;\n-\n-  current_obstack = &permanent_obstack;\n-  node = tree_cons (purpose, value, chain);\n-  current_obstack = ambient_obstack;\n-  return node;\n-}\n-\n-/* Same as `tree_cons', but make this node temporary, regardless.  */\n-\n-tree\n-temp_tree_cons (purpose, value, chain)\n-     tree purpose, value, chain;\n-{\n-  register tree node;\n-  register struct obstack *ambient_obstack = current_obstack;\n-\n-  current_obstack = &temporary_obstack;\n-  node = tree_cons (purpose, value, chain);\n-  current_obstack = ambient_obstack;\n-  return node;\n-}\n-\n-/* Same as `tree_cons', but save this node if the function's RTL is saved.  */\n-\n-tree\n-saveable_tree_cons (purpose, value, chain)\n-     tree purpose, value, chain;\n-{\n-  register tree node;\n-  register struct obstack *ambient_obstack = current_obstack;\n-\n-  current_obstack = saveable_obstack;\n-  node = tree_cons (purpose, value, chain);\n-  current_obstack = ambient_obstack;\n-  return node;\n-}\n \f\n /* Return the size nominally occupied by an object of type TYPE\n    when it resides in memory.  The value is measured in units of bytes,\n@@ -3308,7 +2553,6 @@ build1 (code, type, node)\n      tree type;\n      tree node;\n {\n-  register struct obstack *obstack = expression_obstack;\n   register int length;\n #ifdef GATHER_STATISTICS\n   register tree_node_kind kind;\n@@ -3324,10 +2568,7 @@ build1 (code, type, node)\n \n   length = sizeof (struct tree_exp);\n \n-  if (ggc_p)\n-    t = ggc_alloc_tree (length);\n-  else\n-    t = (tree) obstack_alloc (obstack, length);\n+  t = ggc_alloc_tree (length);\n \n   memset ((PTR) t, 0, sizeof (struct tree_common));\n \n@@ -3337,8 +2578,6 @@ build1 (code, type, node)\n #endif\n \n   TREE_SET_CODE (t, code);\n-  TREE_SET_PERMANENT (t);\n-\n   TREE_TYPE (t) = type;\n   TREE_COMPLEXITY (t) = 0;\n   TREE_OPERAND (t, 0) = node;\n@@ -3408,7 +2647,6 @@ build_parse_node VPARAMS ((enum tree_code code, ...))\n #ifndef ANSI_PROTOTYPES\n   enum tree_code code;\n #endif\n-  register struct obstack *ambient_obstack = expression_obstack;\n   va_list p;\n   register tree t;\n   register int length;\n@@ -3420,16 +2658,13 @@ build_parse_node VPARAMS ((enum tree_code code, ...))\n   code = va_arg (p, enum tree_code);\n #endif\n \n-  expression_obstack = &temp_decl_obstack;\n-\n   t = make_node (code);\n   length = TREE_CODE_LENGTH (code);\n \n   for (i = 0; i < length; i++)\n     TREE_OPERAND (t, i) = va_arg (p, tree);\n \n   va_end (p);\n-  expression_obstack = ambient_obstack;\n   return t;\n }\n \n@@ -3554,7 +2789,6 @@ build_type_attribute_variant (ttype, attribute)\n       unsigned int hashcode;\n       tree ntype;\n \n-      push_obstacks (TYPE_OBSTACK (ttype), TYPE_OBSTACK (ttype));\n       ntype = copy_node (ttype);\n \n       TYPE_POINTER_TO (ntype) = 0;\n@@ -3590,7 +2824,6 @@ build_type_attribute_variant (ttype, attribute)\n \n       ntype = type_hash_canon (hashcode, ntype);\n       ttype = build_qualified_type (ntype, TYPE_QUALS (ttype));\n-      pop_obstacks ();\n     }\n \n   return ttype;\n@@ -3906,11 +3139,8 @@ build_type_copy (type)\n      tree type;\n {\n   register tree t, m = TYPE_MAIN_VARIANT (type);\n-  register struct obstack *ambient_obstack = current_obstack;\n \n-  current_obstack = TYPE_OBSTACK (type);\n   t = copy_node (type);\n-  current_obstack = ambient_obstack;\n \n   TYPE_POINTER_TO (t) = 0;\n   TYPE_REFERENCE_TO (t) = 0;\n@@ -4053,9 +3283,6 @@ type_hash_canon (hashcode, type)\n   t1 = type_hash_lookup (hashcode, type);\n   if (t1 != 0)\n     {\n-      if (!ggc_p)\n-\tobstack_free (TYPE_OBSTACK (type), type);\n-\n #ifdef GATHER_STATISTICS\n       tree_node_counts[(int) t_kind]--;\n       tree_node_sizes[(int) t_kind] -= sizeof (struct tree_type);\n@@ -4064,8 +3291,7 @@ type_hash_canon (hashcode, type)\n     }\n \n   /* If this is a permanent type, record it for later reuse.  */\n-  if (ggc_p || TREE_PERMANENT (type))\n-    type_hash_add (hashcode, type);\n+  type_hash_add (hashcode, type);\n \n   return type;\n }\n@@ -4520,10 +3746,8 @@ build_pointer_type (to_type)\n   if (t != 0)\n     return t;\n \n-  /* We need a new one.  Put this in the same obstack as TO_TYPE.   */\n-  push_obstacks (TYPE_OBSTACK (to_type), TYPE_OBSTACK (to_type));\n+  /* We need a new one.  */\n   t = make_node (POINTER_TYPE);\n-  pop_obstacks ();\n \n   TREE_TYPE (t) = to_type;\n \n@@ -4551,10 +3775,8 @@ build_reference_type (to_type)\n   if (t)\n     return t;\n \n-  /* We need a new one.  Put this in the same obstack as TO_TYPE.   */\n-  push_obstacks (TYPE_OBSTACK (to_type), TYPE_OBSTACK (to_type));\n+  /* We need a new one.  */\n   t = make_node (REFERENCE_TYPE);\n-  pop_obstacks ();\n \n   TREE_TYPE (t) = to_type;\n \n@@ -4585,9 +3807,7 @@ build_index_type (maxval)\n   TYPE_PRECISION (itype) = TYPE_PRECISION (sizetype);\n   TYPE_MIN_VALUE (itype) = size_zero_node;\n \n-  push_obstacks (TYPE_OBSTACK (itype), TYPE_OBSTACK (itype));\n   TYPE_MAX_VALUE (itype) = convert (sizetype, maxval);\n-  pop_obstacks ();\n \n   TYPE_MODE (itype) = TYPE_MODE (sizetype);\n   TYPE_SIZE (itype) = TYPE_SIZE (sizetype);\n@@ -4616,10 +3836,8 @@ build_range_type (type, lowval, highval)\n   if (type == NULL_TREE)\n     type = sizetype;\n \n-  push_obstacks (TYPE_OBSTACK (itype), TYPE_OBSTACK (itype));\n   TYPE_MIN_VALUE (itype) = convert (type, lowval);\n   TYPE_MAX_VALUE (itype) = highval ? convert (type, highval) : NULL;\n-  pop_obstacks ();\n \n   TYPE_PRECISION (itype) = TYPE_PRECISION (type);\n   TYPE_MODE (itype) = TYPE_MODE (type);\n@@ -5281,10 +4499,6 @@ dump_tree_statistics ()\n   fprintf (stderr, \"(No per-node statistics)\\n\");\n #endif\n   print_obstack_statistics (\"permanent_obstack\", &permanent_obstack);\n-  print_obstack_statistics (\"maybepermanent_obstack\", &maybepermanent_obstack);\n-  print_obstack_statistics (\"temporary_obstack\", &temporary_obstack);\n-  print_obstack_statistics (\"momentary_obstack\", &momentary_obstack);\n-  print_obstack_statistics (\"temp_decl_obstack\", &temp_decl_obstack);\n   print_type_hash_statistics ();\n   print_lang_statistics ();\n }"}, {"sha": "80a3282a237c96bcfb2792af64ee98f35fa229b5", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 62, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -133,7 +133,6 @@ struct tree_common\n   ENUM_BITFIELD(tree_code) code : 8;\n   unsigned side_effects_flag : 1;\n   unsigned constant_flag : 1;\n-  unsigned permanent_flag : 1;\n   unsigned addressable_flag : 1;\n   unsigned volatile_flag : 1;\n   unsigned readonly_flag : 1;\n@@ -155,6 +154,10 @@ struct tree_common\n   unsigned lang_flag_4 : 1;\n   unsigned lang_flag_5 : 1;\n   unsigned lang_flag_6 : 1;\n+  /* This flag is presently unused.  However, language front-ends\n+     should not make use of this flag; it is reserved for future\n+     expansion.  */\n+  unsigned dummy : 1;\n };\n \n /* The following table lists the uses of each of the above flags and\n@@ -230,8 +233,6 @@ struct tree_common\n        TREE_CONSTANT in\n            all expressions\n \n-   permanent_flag: TREE_PERMANENT in all nodes\n-\n    unsigned_flag:\n \n        TREE_UNSIGNED in\n@@ -568,17 +569,6 @@ extern void tree_class_check_failed PARAMS ((const tree, int,\n    if the value is constant.  */\n #define TREE_CONSTANT(NODE) ((NODE)->common.constant_flag)\n \n-/* Nonzero means permanent node;\n-   node will continue to exist for the entire compiler run.\n-   Otherwise it will be recycled at the end of the function.\n-   This flag is always zero if garbage collection is in use.\n-   Try not to use this.  Only set it with TREE_SET_PERMANENT.  */\n-#define TREE_PERMANENT(NODE) ((NODE)->common.permanent_flag)\n-#define TREE_SET_PERMANENT(NODE) do { \\\n-  if (!ggc_p && current_obstack == &permanent_obstack) \\\n-    TREE_PERMANENT(NODE) = 1; \\\n-} while (0) \n-\n /* In INTEGER_TYPE or ENUMERAL_TYPE nodes, means an unsigned type.\n    In FIELD_DECL nodes, means an unsigned bit field.\n    The same bit is used in functions as DECL_BUILT_IN_NONANSI.  */\n@@ -890,7 +880,6 @@ struct tree_block\n #define TYPE_MAIN_VARIANT(NODE) (TYPE_CHECK (NODE)->type.main_variant)\n #define TYPE_NONCOPIED_PARTS(NODE) (TYPE_CHECK (NODE)->type.noncopied_parts)\n #define TYPE_CONTEXT(NODE) (TYPE_CHECK (NODE)->type.context)\n-#define TYPE_OBSTACK(NODE) (TYPE_CHECK (NODE)->type.obstack)\n #define TYPE_LANG_SPECIFIC(NODE) (TYPE_CHECK (NODE)->type.lang_specific)\n \n /* For a VECTOR_TYPE node, this describes a different type which is emitted\n@@ -1152,7 +1141,6 @@ struct tree_type\n   union tree_node *binfo;\n   union tree_node *noncopied_parts;\n   union tree_node *context;\n-  struct obstack *obstack;\n   HOST_WIDE_INT alias_set;\n   /* Points to a structure whose details depend on the language in use.  */\n   struct lang_type *lang_specific;\n@@ -1858,9 +1846,7 @@ extern tree integer_types[itk_none];\n extern int exact_log2_wide             PARAMS ((unsigned HOST_WIDE_INT));\n extern int floor_log2_wide             PARAMS ((unsigned HOST_WIDE_INT));\n \n-extern char *oballoc\t\t\tPARAMS ((int));\n extern char *permalloc\t\t\tPARAMS ((int));\n-extern char *savealloc\t\t\tPARAMS ((int));\n extern char *expralloc\t\t\tPARAMS ((int));\n \n /* Compute the number of bytes occupied by 'node'.  This routine only\n@@ -1917,8 +1903,6 @@ extern tree build_complex\t\tPARAMS ((tree, tree, tree));\n extern tree build_string\t\tPARAMS ((int, const char *));\n extern tree build1\t\t\tPARAMS ((enum tree_code, tree, tree));\n extern tree build_tree_list\t\tPARAMS ((tree, tree));\n-extern tree build_decl_list\t\tPARAMS ((tree, tree));\n-extern tree build_expr_list\t\tPARAMS ((tree, tree));\n extern tree build_decl\t\t\tPARAMS ((enum tree_code, tree, tree));\n extern tree build_block\t\t\tPARAMS ((tree, tree, tree, tree, tree));\n extern tree build_expr_wfl              PARAMS ((tree, const char *, int, int));\n@@ -2177,11 +2161,6 @@ extern tree chainon\t\t\tPARAMS ((tree, tree));\n /* Make a new TREE_LIST node from specified PURPOSE, VALUE and CHAIN.  */\n \n extern tree tree_cons\t\t\tPARAMS ((tree, tree, tree));\n-extern tree perm_tree_cons\t\tPARAMS ((tree, tree, tree));\n-extern tree temp_tree_cons\t\tPARAMS ((tree, tree, tree));\n-extern tree saveable_tree_cons\t\tPARAMS ((tree, tree, tree));\n-extern tree decl_tree_cons\t\tPARAMS ((tree, tree, tree));\n-extern tree expr_tree_cons\t\tPARAMS ((tree, tree, tree));\n \n /* Return the last tree node in a chain.  */\n \n@@ -2620,34 +2599,9 @@ extern tree gettags\t\t\t\tPARAMS ((void));\n \n extern tree build_range_type PARAMS ((tree, tree, tree));\n \n-/* Call when starting to parse a declaration:\n-   make expressions in the declaration last the length of the function.\n-   Returns an argument that should be passed to resume_momentary later.  */\n-extern int suspend_momentary PARAMS ((void));\n-\n-extern int allocation_temporary_p PARAMS ((void));\n-\n-/* Call when finished parsing a declaration:\n-   restore the treatment of node-allocation that was\n-   in effect before the suspension.\n-   YES should be the value previously returned by suspend_momentary.  */\n-extern void resume_momentary PARAMS ((int));\n-\n /* Called after finishing a record, union or enumeral type.  */\n extern void rest_of_type_compilation PARAMS ((tree, int));\n \n-/* Save the current set of obstacks, but don't change them.  */\n-extern void push_obstacks_nochange PARAMS ((void));\n-\n-extern void permanent_allocation PARAMS ((int));\n-extern void push_momentary PARAMS ((void));\n-extern void clear_momentary PARAMS ((void));\n-extern void pop_momentary PARAMS ((void));\n-extern void end_temporary_allocation PARAMS ((void));\n-\n-/* Pop the obstack selection stack.  */\n-extern void pop_obstacks PARAMS ((void));\n-\n /* In alias.c */\n extern void record_component_aliases\t\tPARAMS ((tree));\n extern HOST_WIDE_INT get_alias_set\t\tPARAMS ((tree));\n@@ -2657,18 +2611,10 @@ extern HOST_WIDE_INT lang_get_alias_set\t\tPARAMS ((tree));\n \n /* In tree.c */\n extern int really_constant_p\t\tPARAMS ((tree));\n-extern void push_obstacks\t\tPARAMS ((struct obstack *,\n-\t\t\t\t\t\tstruct obstack *));\n-extern void pop_momentary_nofree\tPARAMS ((void));\n-extern void preserve_momentary\t\tPARAMS ((void));\n-extern void saveable_allocation\t\tPARAMS ((void));\n-extern void temporary_allocation\tPARAMS ((void));\n-extern void resume_temporary_allocation\tPARAMS ((void));\n extern void set_identifier_size\t\tPARAMS ((int));\n extern int int_fits_type_p\t\tPARAMS ((tree, tree));\n extern int tree_log2\t\t\tPARAMS ((tree));\n extern int tree_floor_log2\t\tPARAMS ((tree));\n-extern void preserve_initializer\tPARAMS ((void));\n extern void preserve_data\t\tPARAMS ((void));\n extern int object_permanent_p\t\tPARAMS ((tree));\n extern int type_precision\t\tPARAMS ((tree));\n@@ -2683,9 +2629,6 @@ extern tree type_hash_lookup\t\tPARAMS ((unsigned int, tree));\n extern void type_hash_add\t\tPARAMS ((unsigned int, tree));\n extern unsigned int type_hash_list\tPARAMS ((tree));\n extern int simple_cst_list_equal\tPARAMS ((tree, tree));\n-extern void debug_obstack\t\tPARAMS ((char *));\n-extern void rtl_in_current_obstack\tPARAMS ((void));\n-extern void rtl_in_saveable_obstack\tPARAMS ((void));\n extern void init_tree_codes\t\tPARAMS ((void));\n extern void dump_tree_statistics\tPARAMS ((void));\n extern void print_obstack_statistics\tPARAMS ((const char *,\n@@ -2702,7 +2645,6 @@ extern int real_twop\t\t\tPARAMS ((tree));\n extern void start_identifier_warnings\tPARAMS ((void));\n extern void gcc_obstack_init\t\tPARAMS ((struct obstack *));\n extern void init_obstacks\t\tPARAMS ((void));\n-extern void obfree\t\t\tPARAMS ((char *));\n extern void build_common_tree_nodes\tPARAMS ((int));\n extern void build_common_tree_nodes_2\tPARAMS ((int));\n "}, {"sha": "497931f128fbfa974738bdf2b904af1bb918dcd9", "filename": "gcc/varasm.c", "status": "modified", "additions": 54, "deletions": 101, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=1f8f4a0b31c687ce9cfb7fb76c0f1e02460a8ded", "patch": "@@ -80,9 +80,6 @@ extern FILE *asm_out_file;\n const char *first_global_object_name;\n const char *weak_global_object_name;\n \n-extern struct obstack *current_obstack;\n-extern struct obstack *saveable_obstack;\n-extern struct obstack *rtl_obstack;\n extern struct obstack permanent_obstack;\n #define obstack_chunk_alloc xmalloc\n \n@@ -2110,18 +2107,8 @@ immed_double_const (i0, i1, mode)\n \t  && GET_MODE (r) == mode)\n \treturn r;\n \n-  /* No; make a new one and add it to the chain.\n-\n-     We may be called by an optimizer which may be discarding any memory\n-     allocated during its processing (such as combine and loop).  However,\n-     we will be leaving this constant on the chain, so we cannot tolerate\n-     freed memory.  So switch to saveable_obstack for this allocation\n-     and then switch back if we were in current_obstack.  */\n-\n-  push_obstacks_nochange ();\n-  rtl_in_saveable_obstack ();\n+  /* No; make a new one and add it to the chain.  */\n   r = gen_rtx_CONST_DOUBLE (mode, const0_rtx, i0, i1);\n-  pop_obstacks ();\n \n   /* Don't touch const_double_chain if not inside any function.  */\n   if (current_function_decl != 0)\n@@ -2186,12 +2173,8 @@ immed_real_const_1 (d, mode)\n      We may be called by an optimizer which may be discarding any memory\n      allocated during its processing (such as combine and loop).  However,\n      we will be leaving this constant on the chain, so we cannot tolerate\n-     freed memory.  So switch to saveable_obstack for this allocation\n-     and then switch back if we were in current_obstack.  */\n-  push_obstacks_nochange ();\n-  rtl_in_saveable_obstack ();\n+     freed memory.  */\n   r = rtx_alloc (CONST_DOUBLE);\n-  pop_obstacks ();\n   PUT_MODE (r, mode);\n   bcopy ((char *) &u, (char *) &CONST_DOUBLE_LOW (r), sizeof u);\n \n@@ -2314,6 +2297,22 @@ decode_addr_const (exp, value)\n   value->offset = offset;\n }\n \f\n+struct rtx_const\n+{\n+#ifdef ONLY_INT_FIELDS\n+  unsigned int kind : 16;\n+  unsigned int mode : 16;\n+#else\n+  enum kind kind : 16;\n+  enum machine_mode mode : 16;\n+#endif\n+  union {\n+    union real_extract du;\n+    struct addr_const addr;\n+    struct {HOST_WIDE_INT high, low;} di;\n+  } un;\n+};\n+\n /* Uniquize all constants that appear in memory.\n    Each constant in memory thus far output is recorded\n    in `const_hash_table' with a `struct constant_descriptor'\n@@ -3095,21 +3094,12 @@ output_constant_def (exp)\n       desc->label = ggc_alloc_string (label, -1);\n       const_hash_table[hash] = desc;\n   \n-      /* We have a symbol name; construct the SYMBOL_REF and the MEM\n-\t in the permanent obstack.  We could also construct this in the\n-\t obstack of EXP and put it into TREE_CST_RTL, but we have no way\n-\t of knowing what obstack it is (e.g., it might be in a function\n-\t obstack of a function we are nested inside).  */\n-\n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n-\n+      /* We have a symbol name; construct the SYMBOL_REF and the MEM.  */\n       desc->rtl\n \t= gen_rtx_MEM (TYPE_MODE (TREE_TYPE (exp)),\n \t\t       gen_rtx_SYMBOL_REF (Pmode, desc->label));\n \n       set_mem_attributes (desc->rtl, exp, 1);\n-      pop_obstacks ();\n \n       found = 0;\n     }\n@@ -3140,10 +3130,7 @@ output_constant_def (exp)\n \t  struct deferred_constant *p;\n \t  p = (struct deferred_constant *) xmalloc (sizeof (struct deferred_constant));\n \n-\t  push_obstacks_nochange ();\n-\t  suspend_momentary ();\n \t  p->exp = copy_constant (exp);\n-\t  pop_obstacks ();\n \t  p->reloc = reloc;\n \t  p->labelno = const_labelno++;\n \t  if (after_function)\n@@ -3260,14 +3247,10 @@ init_varasm_status (f)\n   f->varasm = p;\n   p->x_const_rtx_hash_table\n     = ((struct constant_descriptor **)\n-       xmalloc (MAX_RTX_HASH_TABLE * sizeof (struct constant_descriptor *)));\n+       xcalloc (MAX_RTX_HASH_TABLE, sizeof (struct constant_descriptor *)));\n   p->x_const_rtx_sym_hash_table\n     = ((struct pool_sym **)\n-       xmalloc (MAX_RTX_HASH_TABLE * sizeof (struct pool_sym *)));\n-  bzero ((char *) p->x_const_rtx_hash_table,\n-\t MAX_RTX_HASH_TABLE * sizeof (struct constant_descriptor *));\n-  bzero ((char *) p->x_const_rtx_sym_hash_table,\n-\t MAX_RTX_HASH_TABLE * sizeof (struct pool_sym *));\n+       xcalloc (MAX_RTX_HASH_TABLE, sizeof (struct pool_sym *)));\n \n   p->x_first_pool = p->x_last_pool = 0;\n   p->x_pool_offset = 0;\n@@ -3282,6 +3265,7 @@ mark_pool_constant (pc)\n {\n   while (pc)\n     {\n+      ggc_mark (pc);\n       ggc_mark_rtx (pc->constant);\n       pc = pc->next;\n     }\n@@ -3324,8 +3308,31 @@ free_varasm_status (f)\n      struct function *f;\n {\n   struct varasm_status *p;\n+  int i;\n \n   p = f->varasm;\n+\n+  /* Clear out the hash tables.  */\n+  for (i = 0; i < MAX_RTX_HASH_TABLE; ++i)\n+    {\n+      struct constant_descriptor* cd;\n+      struct pool_sym *ps;\n+\n+      cd = p->x_const_rtx_hash_table[i];\n+      while (cd) {\n+\tstruct constant_descriptor* next = cd->next;\n+\tfree (cd);\n+\tcd = next;\n+      }\n+\n+      ps = p->x_const_rtx_sym_hash_table[i];\n+      while (ps) {\n+\tstruct pool_sym *next = ps->next;\n+\tfree (ps);\n+\tps = next;\n+      }\n+    }\n+\n   free (p->x_const_rtx_hash_table);\n   free (p->x_const_rtx_sym_hash_table);\n   free (p);\n@@ -3334,22 +3341,6 @@ free_varasm_status (f)\n \f\n enum kind { RTX_DOUBLE, RTX_INT };\n \n-struct rtx_const\n-{\n-#ifdef ONLY_INT_FIELDS\n-  unsigned int kind : 16;\n-  unsigned int mode : 16;\n-#else\n-  enum kind kind : 16;\n-  enum machine_mode mode : 16;\n-#endif\n-  union {\n-    union real_extract du;\n-    struct addr_const addr;\n-    struct {HOST_WIDE_INT high, low;} di;\n-  } un;\n-};\n-\n /* Express an rtx for a constant integer (perhaps symbolic)\n    as the sum of a symbol or label plus an explicit integer.\n    They are stored into VALUE.  */\n@@ -3361,13 +3352,7 @@ decode_rtx_const (mode, x, value)\n      struct rtx_const *value;\n {\n   /* Clear the whole structure, including any gaps.  */\n-\n-  {\n-    int *p = (int *) value;\n-    int *end = (int *) (value + 1);\n-    while (p < end)\n-      *p++ = 0;\n-  }\n+  bzero (value, sizeof (struct rtx_const));\n \n   value->kind = RTX_INT;\t/* Most usual kind.  */\n   value->mode = mode;\n@@ -3516,23 +3501,14 @@ record_constant_rtx (mode, x)\n      rtx x;\n {\n   struct constant_descriptor *ptr;\n-  char *label;\n-  rtx rtl;\n-  struct rtx_const value;\n-\n-  decode_rtx_const (mode, x, &value);\n-\n-  /* Put these things in the saveable obstack so we can ensure it won't\n-     be freed if we are called from combine or some other phase that discards\n-     memory allocated from function_obstack (current_obstack).  */\n-  obstack_grow (saveable_obstack, &ptr, sizeof ptr);\n-  obstack_grow (saveable_obstack, &label, sizeof label);\n-  obstack_grow (saveable_obstack, &rtl, sizeof rtl);\n \n-  /* Record constant contents.  */\n-  obstack_grow (saveable_obstack, &value, sizeof value);\n+  ptr = ((struct constant_descriptor *) \n+\t xcalloc (1, \n+\t\t  (sizeof (struct constant_descriptor) \n+\t\t   + sizeof (struct rtx_const) - 1)));\n+  decode_rtx_const (mode, x, (struct rtx_const *) ptr->contents);\n \n-  return (struct constant_descriptor *) obstack_finish (saveable_obstack);\n+  return ptr;\n }\n \f\n /* Given a constant rtx X, make (or find) a memory constant for its value\n@@ -3602,32 +3578,9 @@ force_const_mem (mode, x)\n       pool_offset += align - 1;\n       pool_offset &= ~ (align - 1);\n \n-      /* If RTL is not being placed into the saveable obstack, make a\n-\t copy of X that is in the saveable obstack in case we are\n-\t being called from combine or some other phase that discards\n-\t memory it allocates.  We used to only do this if it is a\n-\t CONST; however, reload can allocate a CONST_INT when\n-\t eliminating registers.  */\n-      if (rtl_obstack != saveable_obstack\n-\t  && (GET_CODE (x) == CONST || GET_CODE (x) == CONST_INT))\n-\t{\n-\t  push_obstacks_nochange ();\n-\t  rtl_in_saveable_obstack ();\n-\n-\t  if (GET_CODE (x) == CONST)\n-\t    x = gen_rtx_CONST (GET_MODE (x), \n-\t\t\t       gen_rtx_PLUS (GET_MODE (x), \n-\t\t\t\t\t     XEXP (XEXP (x, 0), 0),\n-\t\t\t\t\t     XEXP (XEXP (x, 0), 1)));\n-\t  else\n-\t    x = GEN_INT (INTVAL (x));\n-\n-\t  pop_obstacks ();\n-\t}\n-\n       /* Allocate a pool constant descriptor, fill it in, and chain it in.  */\n \n-      pool = (struct pool_constant *) savealloc (sizeof (struct pool_constant));\n+      pool = (struct pool_constant *) ggc_alloc (sizeof (struct pool_constant));\n       pool->desc = desc;\n       pool->constant = x;\n       pool->mode = mode;\n@@ -3654,7 +3607,7 @@ force_const_mem (mode, x)\n \n       /* Add label to symbol hash table.  */\n       hash = SYMHASH (found);\n-      sym = (struct pool_sym *) savealloc (sizeof (struct pool_sym));\n+      sym = (struct pool_sym *) xmalloc (sizeof (struct pool_sym));\n       sym->label = found;\n       sym->pool = pool;\n       sym->next = const_rtx_sym_hash_table[hash];"}]}