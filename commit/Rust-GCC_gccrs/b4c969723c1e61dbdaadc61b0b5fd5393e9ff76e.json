{"sha": "b4c969723c1e61dbdaadc61b0b5fd5393e9ff76e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRjOTY5NzIzYzFlNjFkYmRhYWRjNjFiMGI1ZmQ1MzkzZTlmZjc2ZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-06T11:07:53Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-06T11:07:53Z"}, "message": "Tighten LRA cycling check\n\nLRA has code to try to prevent cycling, by avoiding reloads that\nlook too similar to the instruction being reloaded.  E.g. if we\nhave a R<-C move for some constant C, reloading the source with\nanother R<-C move is unlikely to be a good idea.\n\nHowever, this safeguard unnecessarily triggered in tests like\nthe one in the patch.  We started with instructions like:\n\n(insn 12 9 13 5 (set (reg:DI 0 x0)\n        (reg/f:DI 459)) \"reg-alloc-1.c\":18 47 {*movdi_aarch64}\n     (expr_list:REG_EQUAL (symbol_ref:DI (\"x00\") [flags 0xc0]  <var_decl 0x7f3c03c1f510 x00>)\n        (nil)))\n\nwhere r459 didn't get allocated a register and is equivalent to\nconstant x00.  LRA would then handle it like this:\n\nChanging pseudo 459 in operand 1 of insn 12 on equiv `x00'\n            1 Non-pseudo reload: reject+=2\n            1 Non input pseudo reload: reject++\n------->    Cycle danger: overall += LRA_MAX_REJECT\n          alt=0,overall=609,losers=1,rld_nregs=1\n[...]\n          alt=13,overall=9,losers=1,rld_nregs=1\n[...]\n         Choosing alt 13 in insn 12:  (0) r  (1) w {*movdi_aarch64}\n\nIn other words, to avoid loading the constant x00 into another GPR,\nLRA decided instead to move it into a floating-point register,\nthen move that floating-point register into x0:\n\n      Creating newreg=630, assigning class FP_REGS to r630\n      Set class ALL_REGS for r631\n   12: x0:DI=r630:DI\n      REG_EQUAL `x00'\n    Inserting insn reload before:\n  815: r631:DI=high(`x00')\n  816: r630:DI=r631:DI+low(`x00')\n      REG_EQUAL `x00'\n\nThat's inefficient and doesn't really help to resolve a cycling\nproblem, since the r630 destination of 816 needs to be reloaded into\na GPR anyway.\n\nThe cycling check already had an exception for source values that are\nthe result of an elimination.  This patch extends it to include the\nresult of equivalence substitution.\n\n2018-01-06  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* lra-constraints.c (process_alt_operands): Test for the equivalence\n\tsubstitutions when detecting a possible reload cycle.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/reg-alloc-1.c: New test.\n\nFrom-SVN: r256312", "tree": {"sha": "19735df08600785a6e4ce432650c0ad8b1093509", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19735df08600785a6e4ce432650c0ad8b1093509"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4c969723c1e61dbdaadc61b0b5fd5393e9ff76e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4c969723c1e61dbdaadc61b0b5fd5393e9ff76e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4c969723c1e61dbdaadc61b0b5fd5393e9ff76e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4c969723c1e61dbdaadc61b0b5fd5393e9ff76e/comments", "author": null, "committer": null, "parents": [{"sha": "b081a3764277fc23dc06ac6bbd2ba35fcf6fcc06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b081a3764277fc23dc06ac6bbd2ba35fcf6fcc06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b081a3764277fc23dc06ac6bbd2ba35fcf6fcc06"}], "stats": {"total": 42, "additions": 41, "deletions": 1}, "files": [{"sha": "767d7458bb324afe4948935c6248eae4b4910c12", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c969723c1e61dbdaadc61b0b5fd5393e9ff76e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c969723c1e61dbdaadc61b0b5fd5393e9ff76e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4c969723c1e61dbdaadc61b0b5fd5393e9ff76e", "patch": "@@ -1,3 +1,8 @@\n+2018-01-06  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* lra-constraints.c (process_alt_operands): Test for the equivalence\n+\tsubstitutions when detecting a possible reload cycle.\n+\n 2018-01-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/83480"}, {"sha": "3af31999ad8edbfec19a7f009d7134955fbb254d", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c969723c1e61dbdaadc61b0b5fd5393e9ff76e/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c969723c1e61dbdaadc61b0b5fd5393e9ff76e/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=b4c969723c1e61dbdaadc61b0b5fd5393e9ff76e", "patch": "@@ -2866,7 +2866,12 @@ process_alt_operands (int only_alternative)\n \t\t  /* If it is a result of recent elimination in move\n \t\t     insn we can transform it into an add still by\n \t\t     using this alternative.  */\n-\t\t  && GET_CODE (no_subreg_reg_operand[1]) != PLUS)))\n+\t\t  && GET_CODE (no_subreg_reg_operand[1]) != PLUS\n+\t\t  /* Likewise if the source has been replaced with an\n+\t\t     equivalent value.  This only happens once -- the reload\n+\t\t     will use the equivalent value instead of the register it\n+\t\t     replaces -- so there should be no danger of cycling.  */\n+\t\t  && !equiv_substition_p[1])))\n \t{\n \t  /* We have a move insn and a new reload insn will be similar\n \t     to the current insn.  We should avoid such situation as"}, {"sha": "2b9d7aeec2d0222adf5bb1e1271a3dd0150fd000", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c969723c1e61dbdaadc61b0b5fd5393e9ff76e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c969723c1e61dbdaadc61b0b5fd5393e9ff76e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b4c969723c1e61dbdaadc61b0b5fd5393e9ff76e", "patch": "@@ -1,3 +1,7 @@\n+2018-01-06  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gcc.target/aarch64/reg-alloc-1.c: New test.\n+\n 2018-01-06  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR fortran/50892"}, {"sha": "28a2a99db439e9ae22088f880586554bb9eda90b", "filename": "gcc/testsuite/gcc.target/aarch64/reg-alloc-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c969723c1e61dbdaadc61b0b5fd5393e9ff76e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Freg-alloc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c969723c1e61dbdaadc61b0b5fd5393e9ff76e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Freg-alloc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Freg-alloc-1.c?ref=b4c969723c1e61dbdaadc61b0b5fd5393e9ff76e", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-rtl-reload-details\" } */\n+\n+#define R1(X, Y) X (Y##0) X (Y##1) X (Y##2) X (Y##3) \\\n+                 X (Y##4) X (Y##5) X (Y##6) X (Y##7)\n+#define R2(X) R1 (X, 0) R1 (X, 1) R1 (X, 2) R1 (X, 3)\n+\n+#define DEFINE(N) extern int x##N;\n+R2 (DEFINE)\n+\n+void b1 (int *);\n+\n+void\n+foo (int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+#define CALL(N) b1 (&x##N);\n+      R2 (CALL);\n+      R2 (CALL);\n+    }\n+#define INC(N) x##N += 1;\n+  R2 (INC);\n+}\n+\n+/* { dg-final { scan-rtl-dump-not \"DI 32 v0\" \"reload\" } } */"}]}