{"sha": "e2bc581fca97845eb2a36578468739273442794d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJiYzU4MWZjYTk3ODQ1ZWIyYTM2NTc4NDY4NzM5MjczNDQyNzk0ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-07-13T18:46:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-07-13T18:46:40Z"}, "message": "tree-ssa-alias.c (component_ref_to_zero_sized_trailing_array_p): Break out from ...\n\n\t* tree-ssa-alias.c (component_ref_to_zero_sized_trailing_array_p):\n\tBreak out from ...\n\t(aliasing_component_refs_walk): Break out from ...\n\t(aliasing_component_refs_p): ... here.\n\nFrom-SVN: r273469", "tree": {"sha": "0a0b6685bd4fd7ccaa5cffa6dda6ec5600a36d73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a0b6685bd4fd7ccaa5cffa6dda6ec5600a36d73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2bc581fca97845eb2a36578468739273442794d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2bc581fca97845eb2a36578468739273442794d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2bc581fca97845eb2a36578468739273442794d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2bc581fca97845eb2a36578468739273442794d/comments", "author": null, "committer": null, "parents": [{"sha": "5c695c29de8d1507aab62a66e4e678bee92c9339", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c695c29de8d1507aab62a66e4e678bee92c9339", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c695c29de8d1507aab62a66e4e678bee92c9339"}], "stats": {"total": 212, "additions": 114, "deletions": 98}, "files": [{"sha": "fc43ac227af51bbe9888d9250c53da0a228452fd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bc581fca97845eb2a36578468739273442794d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bc581fca97845eb2a36578468739273442794d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e2bc581fca97845eb2a36578468739273442794d", "patch": "@@ -1,3 +1,10 @@\n+2019-07-13  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree-ssa-alias.c (component_ref_to_zero_sized_trailing_array_p):\n+\tBreak out from ...\n+\t(aliasing_component_refs_walk): Break out from ...\n+\t(aliasing_component_refs_p): ... here.\n+\n 2019-07-13  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR target/91148"}, {"sha": "d6e3976036ff33f9cafb1ec8e30af7ba6f803264", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 107, "deletions": 98, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bc581fca97845eb2a36578468739273442794d/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bc581fca97845eb2a36578468739273442794d/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=e2bc581fca97845eb2a36578468739273442794d", "patch": "@@ -895,6 +895,97 @@ aliasing_matching_component_refs_p (tree match1, tree ref1,\n   return true;\n }\n \n+/* Return true if REF is reference to zero sized trailing array. I.e.\n+   struct foo {int bar; int array[0];} *fooptr;\n+   fooptr->array.  */\n+\n+static bool\n+component_ref_to_zero_sized_trailing_array_p (tree ref)\n+{\n+  return (TREE_CODE (ref) == COMPONENT_REF\n+\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (ref, 1))) == ARRAY_TYPE\n+\t  && (!TYPE_SIZE (TREE_TYPE (TREE_OPERAND (ref, 1)))\n+\t      || integer_zerop (TYPE_SIZE (TREE_TYPE (TREE_OPERAND (ref, 1)))))\n+\t  && array_at_struct_end_p (ref));\n+}\n+\n+/* Worker for aliasing_component_refs_p. Most parameters match parameters of\n+   aliasing_component_refs_p.\n+\n+   Walk access path REF2 and try to find type matching TYPE1\n+   (which is a start of possibly aliasing access path REF1).\n+   If match is found, try to disambiguate.\n+\n+   Return 0 for sucessful disambiguation.\n+   Return 1 if match was found but disambiguation failed\n+   Return -1 if there is no match.\n+   In this case MAYBE_MATCH is set to 0 if there is no type matching TYPE1\n+   in access patch REF2 and -1 if we are not sure.  */\n+\n+static int\n+aliasing_component_refs_walk (tree ref1, tree type1, tree base1,\n+\t\t\t      poly_int64 offset1, poly_int64 max_size1,\n+\t\t\t      tree end_struct_ref1,\n+\t\t\t      tree ref2, tree base2,\n+\t\t\t      poly_int64 offset2, poly_int64 max_size2,\n+\t\t\t      bool *maybe_match)\n+{\n+  tree ref = ref2;\n+  int same_p;\n+\n+  while (true)\n+    {\n+      /* We walk from inner type to the outer types. If type we see is\n+\t already too large to be part of type1, terminate the search.  */\n+      int cmp = compare_type_sizes (type1, TREE_TYPE (ref));\n+\n+      if (cmp < 0\n+\t  && (!end_struct_ref1\n+\t      || compare_type_sizes (TREE_TYPE (end_struct_ref1),\n+\t\t\t\t     TREE_TYPE (ref)) < 0))\n+\tbreak;\n+      /* If types may be of same size, see if we can decide about their\n+\t equality.  */\n+      if (cmp == 0)\n+\t{\n+\t  same_p = same_type_for_tbaa (TREE_TYPE (ref), type1);\n+\t  if (same_p == 1)\n+\t    break;\n+\t  /* In case we can't decide whether types are same try to\n+\t     continue looking for the exact match.\n+\t     Remember however that we possibly saw a match\n+\t     to bypass the access path continuations tests we do later.  */\n+\t  if (same_p == -1)\n+\t    *maybe_match = true;\n+\t}\n+      if (!handled_component_p (ref))\n+\tbreak;\n+      ref = TREE_OPERAND (ref, 0);\n+    }\n+  if (same_p == 1)\n+    {\n+      /* We assume that arrays can overlap by multiple of their elements\n+\t size as tested in gcc.dg/torture/alias-2.c.\n+\t This partial overlap happen only when both arrays are bases of\n+\t the access and not contained within another component ref.\n+\t To be safe we also assume partial overlap for VLAs. */\n+      if (TREE_CODE (TREE_TYPE (base1)) == ARRAY_TYPE\n+\t  && (!TYPE_SIZE (TREE_TYPE (base1))\n+\t      || TREE_CODE (TYPE_SIZE (TREE_TYPE (base1))) != INTEGER_CST\n+\t      || ref == base2))\n+\t/* Setting maybe_match to true triggers\n+\t   nonoverlapping_component_refs_p test later that still may do\n+\t   useful disambiguation.  */\n+\t*maybe_match = true;\n+      else\n+\treturn aliasing_matching_component_refs_p (base1, ref1,\n+\t\t\t\t\t\t   offset1, max_size1,\n+\t\t\t\t\t\t   ref, ref2,\n+\t\t\t\t\t\t   offset2, max_size2);\n+    }\n+  return -1;\n+}\n+\n /* Determine if the two component references REF1 and REF2 which are\n    based on access types TYPE1 and TYPE2 and of which at least one is based\n    on an indirect reference may alias.  \n@@ -919,7 +1010,6 @@ aliasing_component_refs_p (tree ref1,\n      disambiguating q->i and p->a.j.  */\n   tree base1, base2;\n   tree type1, type2;\n-  int same_p1 = 0, same_p2 = 0;\n   bool maybe_match = false;\n   tree end_struct_ref1 = NULL, end_struct_ref2 = NULL;\n \n@@ -938,11 +1028,7 @@ aliasing_component_refs_p (tree ref1,\n \n \t Because we compare sizes of arrays just by sizes of their elements,\n \t we only need to care about zero sized array fields here.  */\n-      if (TREE_CODE (base1) == COMPONENT_REF\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (base1, 1))) == ARRAY_TYPE\n-\t  && (!TYPE_SIZE (TREE_TYPE (TREE_OPERAND (base1, 1)))\n-\t      || integer_zerop (TYPE_SIZE (TREE_TYPE (TREE_OPERAND (base1, 1)))))\n-\t  && array_at_struct_end_p (base1))\n+      if (component_ref_to_zero_sized_trailing_array_p (base1))\n \t{\n \t  gcc_checking_assert (!end_struct_ref1);\n           end_struct_ref1 = base1;\n@@ -956,11 +1042,7 @@ aliasing_component_refs_p (tree ref1,\n   base2 = ref2;\n   while (handled_component_p (base2))\n     {\n-      if (TREE_CODE (base2) == COMPONENT_REF\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (base2, 1))) == ARRAY_TYPE\n-\t  && (!TYPE_SIZE (TREE_TYPE (TREE_OPERAND (base2, 1)))\n-\t      || integer_zerop (TYPE_SIZE (TREE_TYPE (TREE_OPERAND (base2, 1)))))\n-\t  && array_at_struct_end_p (base2))\n+      if (component_ref_to_zero_sized_trailing_array_p (base2))\n \t{\n \t  gcc_checking_assert (!end_struct_ref2);\n \t  end_struct_ref2 = base2;\n@@ -984,100 +1066,27 @@ aliasing_component_refs_p (tree ref1,\n       || (end_struct_ref2\n \t  && compare_type_sizes (TREE_TYPE (end_struct_ref2), type1) >= 0))\n     {\n-      tree ref = ref2;\n-      while (true)\n-\t{\n-\t  /* We walk from inner type to the outer types. If type we see is\n-\t     already too large to be part of type1, terminate the search.  */\n-\t  int cmp = compare_type_sizes (type1, TREE_TYPE (ref));\n-\n-\t  if (cmp < 0\n-\t      && (!end_struct_ref1\n-\t\t  || compare_type_sizes (TREE_TYPE (end_struct_ref1),\n-\t\t\t\t\t TREE_TYPE (ref)) < 0))\n-\t    break;\n-\t  /* If types may be of same size, see if we can decide about their\n-\t     equality.  */\n-\t  if (cmp == 0)\n-\t    {\n-\t      same_p2 = same_type_for_tbaa (TREE_TYPE (ref), type1);\n-\t      if (same_p2 == 1)\n-\t\tbreak;\n-\t      /* In case we can't decide whether types are same try to\n-\t\t continue looking for the exact match.\n-\t\t Remember however that we possibly saw a match\n-\t\t to bypass the access path continuations tests we do later.  */\n-\t      if (same_p2 == -1)\n-\t\tmaybe_match = true;\n-\t    }\n-\t  if (!handled_component_p (ref))\n-\t    break;\n-\t  ref = TREE_OPERAND (ref, 0);\n-\t}\n-      if (same_p2 == 1)\n-\t{\n-\t  /* We assume that arrays can overlap by multiple of their elements\n-\t     size as tested in gcc.dg/torture/alias-2.c.\n-\t     This partial overlap happen only when both arrays are bases of\n-\t     the access and not contained within another component ref.\n-\t     To be safe we also assume partial overlap for VLAs. */\n-\t  if (TREE_CODE (TREE_TYPE (base1)) == ARRAY_TYPE\n-\t      && (!TYPE_SIZE (TREE_TYPE (base1))\n-\t\t  || TREE_CODE (TYPE_SIZE (TREE_TYPE (base1))) != INTEGER_CST\n-\t\t  || ref == base2))\n-\t    /* Setting maybe_match to true triggers\n-\t       nonoverlapping_component_refs_p test later that still may do\n-\t       useful disambiguation.  */\n-\t    maybe_match = true;\n-\t  else\n-\t    return aliasing_matching_component_refs_p (base1, ref1,\n-\t\t\t\t\t\t       offset1, max_size1,\n-\t\t\t\t\t\t       ref, ref2,\n-\t\t\t\t\t\t       offset2, max_size2);\n-\t}\n+      int res = aliasing_component_refs_walk (ref1, type1, base1,\n+\t\t\t\t\t      offset1, max_size1,\n+\t\t\t\t\t      end_struct_ref1,\n+\t\t\t\t\t      ref2, base2, offset2, max_size2,\n+\t\t\t\t\t      &maybe_match);\n+      if (res != -1)\n+\treturn res;\n     }\n \n   /* If we didn't find a common base, try the other way around.  */\n   if (cmp_outer <= 0 \n       || (end_struct_ref1\n \t  && compare_type_sizes (TREE_TYPE (end_struct_ref1), type1) <= 0))\n     {\n-      tree ref = ref1;\n-      while (true)\n-\t{\n-\t  int cmp = compare_type_sizes (type2, TREE_TYPE (ref));\n-\t  if (cmp < 0\n-\t      && (!end_struct_ref2\n-\t\t  || compare_type_sizes (TREE_TYPE (end_struct_ref2),\n-\t\t\t\t\t TREE_TYPE (ref)) < 0))\n-\t    break;\n-\t  /* If types may be of same size, see if we can decide about their\n-\t     equality.  */\n-\t  if (cmp == 0)\n-\t    {\n-\t      same_p1 = same_type_for_tbaa (TREE_TYPE (ref), type2);\n-\t      if (same_p1 == 1)\n-\t\tbreak;\n-\t      if (same_p1 == -1)\n-\t\tmaybe_match = true;\n-\t    }\n-\t  if (!handled_component_p (ref))\n-\t    break;\n-\t  ref = TREE_OPERAND (ref, 0);\n-\t}\n-      if (same_p1 == 1)\n-\t{\n-\t  if (TREE_CODE (TREE_TYPE (base2)) == ARRAY_TYPE\n-\t      && (!TYPE_SIZE (TREE_TYPE (base2))\n-\t\t  || TREE_CODE (TYPE_SIZE (TREE_TYPE (base2))) != INTEGER_CST\n-\t\t  || ref == base1))\n-\t    maybe_match = true;\n-\t  else\n-\t    return aliasing_matching_component_refs_p (ref, ref1,\n-\t\t\t\t\t\t       offset1, max_size1,\n-\t\t\t\t\t\t       base2, ref2,\n-\t\t\t\t\t\t       offset2, max_size2);\n-\t}\n+      int res = aliasing_component_refs_walk (ref2, type2, base2,\n+\t\t\t\t\t      offset2, max_size2,\n+\t\t\t\t\t      end_struct_ref2,\n+\t\t\t\t\t      ref1, base1, offset1, max_size1,\n+\t\t\t\t\t      &maybe_match);\n+      if (res != -1)\n+\treturn res;\n     }\n \n   /* In the following code we make an assumption that the types in access"}]}