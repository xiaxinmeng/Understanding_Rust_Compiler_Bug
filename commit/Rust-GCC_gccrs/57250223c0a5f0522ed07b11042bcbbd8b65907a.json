{"sha": "57250223c0a5f0522ed07b11042bcbbd8b65907a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTcyNTAyMjNjMGE1ZjA1MjJlZDA3YjExMDQyYmNiYmQ4YjY1OTA3YQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2006-11-23T03:37:56Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2006-11-23T03:37:56Z"}, "message": "tree-ssa-structalias.c: Remove edge weights in favor of just processing them as complex constraints.\n\n2006-11-22  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* tree-ssa-structalias.c: Remove edge weights in favor of just\n\tprocessing them as complex constraints.\n\t(struct constraint_graph): Remove weighted succs and preds. Rename\n\tnonweighted succs and preds.\n\t(constraint_edge): Removed.\n\t(constraint_edge_t): Ditto.\n\t(constraint_edge_pool): Ditto.\n\t(new_constraint_edge): Ditto.\n\t(constraint_edge_equal): Ditto.\n\t(constraint_edge_less): Ditto.\n\t(constraint_edge_vec_find): Ditto.\n\t(erase_self_graph_edge): Ditto.\n\t(add_graph_edge): Removed.\n\t(get_graph_weights): Ditto.\n\t(allocate_graph_weights): Ditto.\t(\n\t(valid_weighted_graph_edge): Ditto\n\t(bitmap_other_than_zero_bit_set): Ditto.\n\t(int_add_graph_edge): Renamed to add_graph_edge.\n\t(clear_edges_for_node): Remove support for weighted edges.\n\t(merge_graph_nodes): Ditto.\n\t(valid_graph_edge): Ditto.\n\t(build_constraint_graph): Ditto.\n\t(scc_visit): Ditto.\n\t(collapse_nodes): Ditto.\n\t(process_unification_queue): Ditto.\n\t(topo_visit): Ditto.\n\t(do_ds_constraint): Ditto.\n\t(perform_var_subsitution): Ditto.\n\t(solve_graph): Ditto.\n\t(init_alias_vars): Ditto.\n\t(delete_points_to_sets): Ditto.\n\t(do_complex_constraint): Support offsetted copies here.\n\nFrom-SVN: r119114", "tree": {"sha": "3bc6f798bb97b171b7b7f5d76cf39520e28c8d90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bc6f798bb97b171b7b7f5d76cf39520e28c8d90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57250223c0a5f0522ed07b11042bcbbd8b65907a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57250223c0a5f0522ed07b11042bcbbd8b65907a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57250223c0a5f0522ed07b11042bcbbd8b65907a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57250223c0a5f0522ed07b11042bcbbd8b65907a/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f71ef09df3b1dcbbb5521ce9488894e1db9c6246", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f71ef09df3b1dcbbb5521ce9488894e1db9c6246", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f71ef09df3b1dcbbb5521ce9488894e1db9c6246"}], "stats": {"total": 693, "additions": 149, "deletions": 544}, "files": [{"sha": "b045a0d0ce4a4661560be91de91637b6c693045a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57250223c0a5f0522ed07b11042bcbbd8b65907a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57250223c0a5f0522ed07b11042bcbbd8b65907a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=57250223c0a5f0522ed07b11042bcbbd8b65907a", "patch": "@@ -1,3 +1,38 @@\n+2006-11-22  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* tree-ssa-structalias.c: Remove edge weights in favor of just\n+\tprocessing them as complex constraints.\n+\t(struct constraint_graph): Remove weighted succs and preds. Rename\n+\tnonweighted succs and preds.\n+\t(constraint_edge): Removed.\n+\t(constraint_edge_t): Ditto.\n+\t(constraint_edge_pool): Ditto.\n+\t(new_constraint_edge): Ditto.\n+\t(constraint_edge_equal): Ditto.\n+\t(constraint_edge_less): Ditto.\n+\t(constraint_edge_vec_find): Ditto.\n+\t(erase_self_graph_edge): Ditto.\n+\t(add_graph_edge): Removed.\n+\t(get_graph_weights): Ditto.\n+\t(allocate_graph_weights): Ditto.\t(\n+\t(valid_weighted_graph_edge): Ditto\n+\t(bitmap_other_than_zero_bit_set): Ditto.\n+\t(int_add_graph_edge): Renamed to add_graph_edge.\n+\t(clear_edges_for_node): Remove support for weighted edges.\n+\t(merge_graph_nodes): Ditto.\n+\t(valid_graph_edge): Ditto.\n+\t(build_constraint_graph): Ditto.\n+\t(scc_visit): Ditto.\n+\t(collapse_nodes): Ditto.\n+\t(process_unification_queue): Ditto.\n+\t(topo_visit): Ditto.\n+\t(do_ds_constraint): Ditto.\n+\t(perform_var_subsitution): Ditto.\n+\t(solve_graph): Ditto.\n+\t(init_alias_vars): Ditto.\n+\t(delete_points_to_sets): Ditto.\n+\t(do_complex_constraint): Support offsetted copies here.\n+\n 2006-11-23  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/spu/spu_intrinsics.h (SPU_RdEventStatMask): Rename to"}, {"sha": "828481c56802d7b4397a83db53d4527ff0e8a7e9", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 114, "deletions": 544, "changes": 658, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57250223c0a5f0522ed07b11042bcbbd8b65907a/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57250223c0a5f0522ed07b11042bcbbd8b65907a/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=57250223c0a5f0522ed07b11042bcbbd8b65907a", "patch": "@@ -434,53 +434,14 @@ struct constraint\n static VEC(constraint_t,heap) *constraints;\n static alloc_pool constraint_pool;\n \n-/* An edge in the weighted constraint graph.   The edges are weighted,\n-   with a bit set in weights meaning their is an edge with that\n-   weight. \n-   We don't keep the src in the edge, because we always know what it\n-   is. */\n \n-struct constraint_edge\n-{\n-  unsigned int dest;\n-  bitmap weights;\n-};\n-\n-typedef struct constraint_edge *constraint_edge_t;\n-static alloc_pool constraint_edge_pool;\n-\n-/* Return a new constraint edge from SRC to DEST.  */\n-\n-static constraint_edge_t\n-new_constraint_edge (unsigned int dest)\n-{\n-  constraint_edge_t ret = pool_alloc (constraint_edge_pool);\n-  ret->dest = dest;\n-  ret->weights = NULL;\n-  return ret;\n-}\n-\n-DEF_VEC_P(constraint_edge_t);\n-DEF_VEC_ALLOC_P(constraint_edge_t,heap);\n-\n-\n-/* The constraint graph is represented internally in two different\n-   ways.  The overwhelming majority of edges in the constraint graph\n-   are zero weigh edges, and thus, using a vector of contrainst_edge_t\n-   is a waste of time and memory, since they have no weights.  We\n-   simply use a bitmap to store the preds and succs for each node.\n-   The weighted edges are stored as a set of adjacency vectors, one\n-   per variable. succs[x] is the vector of successors for variable x,\n-   and preds[x] is the vector of predecessors for variable x.  IOW,\n-   all edges are \"forward\" edges, which is not like our CFG.  So\n-   remember that preds[x]->src == x, and succs[x]->src == x.  */\n+/* The constraint graph is represented as an array of bitmaps\n+   containing successor nodes.  */\n \n struct constraint_graph\n {\n-  bitmap *zero_weight_succs;\n-  bitmap *zero_weight_preds;\n-  VEC(constraint_edge_t,heap) **succs;\n-  VEC(constraint_edge_t,heap) **preds;\n+  bitmap *succs;\n+  bitmap *preds;\n };\n \n typedef struct constraint_graph *constraint_graph_t;\n@@ -739,44 +700,6 @@ insert_into_complex (unsigned int var, constraint_t c)\n }\n \n \n-/* Compare two constraint edges A and B, return true if they are equal.  */\n-\n-static bool\n-constraint_edge_equal (struct constraint_edge a, struct constraint_edge b)\n-{\n-  return a.dest == b.dest;\n-}\n-\n-/* Compare two constraint edges, return true if A is less than B */\n-\n-static bool\n-constraint_edge_less (const constraint_edge_t a, const constraint_edge_t b)\n-{\n-  if (a->dest < b->dest)\n-    return true;\n-  return false;\n-}\n-\n-/* Find the constraint edge that matches LOOKFOR, in VEC.\n-   Return the edge, if found, NULL otherwise.  */\n-\n-static constraint_edge_t \n-constraint_edge_vec_find (VEC(constraint_edge_t,heap) *vec, \n-\t\t\t  struct constraint_edge lookfor)\n-{\n-  unsigned int place;  \n-  constraint_edge_t edge = NULL;\n-\n-  place = VEC_lower_bound (constraint_edge_t, vec, &lookfor, \n-\t\t\t   constraint_edge_less);\n-  if (place >= VEC_length (constraint_edge_t, vec))\n-    return NULL;\n-  edge = VEC_index (constraint_edge_t, vec, place);\n-  if (!constraint_edge_equal (*edge, lookfor))\n-    return NULL;\n-  return edge;\n-}\n-\n /* Condense two variable nodes into a single variable node, by moving\n    all associated info from SRC to TO.  */\n \n@@ -815,351 +738,116 @@ condense_varmap_nodes (unsigned int to, unsigned int src)\n   srcvi->complex = NULL;\n }\n \n-/* Erase an edge from SRC to SRC from GRAPH.  This routine only\n-   handles self-edges (e.g. an edge from a to a).  */\n-\n-static void\n-erase_graph_self_edge (constraint_graph_t graph, unsigned int src)\n-{\n-  VEC(constraint_edge_t,heap) *predvec = graph->preds[src];\n-  VEC(constraint_edge_t,heap) *succvec = graph->succs[src];\n-  struct constraint_edge edge;\n-  unsigned int place;\n-\n-  edge.dest = src;\n-\n-  /* Remove from the successors.  */\n-  place = VEC_lower_bound (constraint_edge_t, succvec, &edge, \n-\t\t\t   constraint_edge_less);\n-  \n-  /* Make sure we found the edge.  */\n-#ifdef ENABLE_CHECKING\n-  {\n-    constraint_edge_t tmp = VEC_index (constraint_edge_t, succvec, place);\n-    gcc_assert (constraint_edge_equal (*tmp, edge));\n-  }\n-#endif\n-  VEC_ordered_remove (constraint_edge_t, succvec, place);\n-\n-  /* Remove from the predecessors.  */\n-  place = VEC_lower_bound (constraint_edge_t, predvec, &edge,\n-\t\t\t   constraint_edge_less);\n-\n-  /* Make sure we found the edge.  */\n-#ifdef ENABLE_CHECKING\n-  {\n-    constraint_edge_t tmp = VEC_index (constraint_edge_t, predvec, place);\n-    gcc_assert (constraint_edge_equal (*tmp, edge));\n-  }\n-#endif\n-  VEC_ordered_remove (constraint_edge_t, predvec, place);\n-}\n \n /* Remove edges involving NODE from GRAPH.  */\n \n static void\n clear_edges_for_node (constraint_graph_t graph, unsigned int node)\n {\n-  VEC(constraint_edge_t,heap) *succvec = graph->succs[node];\n-  VEC(constraint_edge_t,heap) *predvec = graph->preds[node];\n   bitmap_iterator bi;\n   unsigned int j;\n-  constraint_edge_t c = NULL;\n-  int i;\n \n   /* Walk the successors, erase the associated preds.  */\n   \n-  EXECUTE_IF_IN_NONNULL_BITMAP (graph->zero_weight_succs[node], 0, j, bi)\n+  EXECUTE_IF_IN_NONNULL_BITMAP (graph->succs[node], 0, j, bi)\n     if (j != node)\n-      bitmap_clear_bit (graph->zero_weight_preds[j], node);\n+      bitmap_clear_bit (graph->preds[j], node);\n   \n-  for (i = 0; VEC_iterate (constraint_edge_t, succvec, i, c); i++)\n-    if (c->dest != node)\n-      {\n-\tunsigned int place;\n-\tstruct constraint_edge lookfor;\n-\tconstraint_edge_t result;\n-\n-\tlookfor.dest = node;\n-\tplace = VEC_lower_bound (constraint_edge_t, graph->preds[c->dest], \n-\t\t\t\t &lookfor, constraint_edge_less);\n-\tresult = VEC_ordered_remove (constraint_edge_t, \n-\t\t\t\t     graph->preds[c->dest], place);\n-\tpool_free (constraint_edge_pool, result);\n-      }\n \n   /* Walk the preds, erase the associated succs.  */\n \n-  EXECUTE_IF_IN_NONNULL_BITMAP (graph->zero_weight_preds[node], 0, j, bi)\n+  EXECUTE_IF_IN_NONNULL_BITMAP (graph->preds[node], 0, j, bi)\n     if (j != node)\n-      bitmap_clear_bit (graph->zero_weight_succs[j], node);\n+      bitmap_clear_bit (graph->succs[j], node);\n   \n-  for (i =0; VEC_iterate (constraint_edge_t, predvec, i, c); i++)\n-    if (c->dest != node)\n-      {\n-\tunsigned int place;\n-\tstruct constraint_edge lookfor;\n-\tconstraint_edge_t result;\n-\n-\tlookfor.dest = node;\n-\tplace = VEC_lower_bound (constraint_edge_t, graph->succs[c->dest],\n-\t\t\t\t &lookfor, constraint_edge_less);\n-\tresult = VEC_ordered_remove (constraint_edge_t, \n-\t\t\t\t     graph->succs[c->dest], place);\n-\tpool_free (constraint_edge_pool, result);\n \n-      }    \n-\n-  if (graph->zero_weight_preds[node])\n+  if (graph->preds[node])\n     {\n-      BITMAP_FREE (graph->zero_weight_preds[node]);\n-      graph->zero_weight_preds[node] = NULL;\n+      BITMAP_FREE (graph->preds[node]);\n+      graph->preds[node] = NULL;\n     } \n \n-  if (graph->zero_weight_succs[node])\n-    {\n-      BITMAP_FREE (graph->zero_weight_succs[node]);\n-      graph->zero_weight_succs[node] = NULL;\n-    } \n-\n-  VEC_free (constraint_edge_t, heap, graph->preds[node]);\n-  VEC_free (constraint_edge_t, heap, graph->succs[node]);\n-  graph->preds[node] = NULL;\n-  graph->succs[node] = NULL;\n-}\n-\n-static bool edge_added = false;\n-  \n-/* Add edge (src, dest) to the graph.  */\n-\n-static bool\n-add_graph_edge (constraint_graph_t graph, unsigned int src, unsigned int dest)\n-{\n-  unsigned int place;\n-  VEC(constraint_edge_t,heap) *vec;\n-  struct constraint_edge newe;\n-  newe.dest = dest;\n-\n-  vec = graph->preds[src];\n-  place = VEC_lower_bound (constraint_edge_t, vec, &newe, \n-\t\t\t   constraint_edge_less);\n-  if (place == VEC_length (constraint_edge_t, vec)\n-      || VEC_index (constraint_edge_t, vec, place)->dest != dest)\n+  if (graph->succs[node])\n     {\n-      constraint_edge_t edge = new_constraint_edge (dest);\n-\n-      VEC_safe_insert (constraint_edge_t, heap, graph->preds[src], \n-\t\t       place, edge);\n-      edge = new_constraint_edge (src);\n-\n-      place = VEC_lower_bound (constraint_edge_t, graph->succs[dest],\n-\t\t\t       edge, constraint_edge_less);\n-      VEC_safe_insert (constraint_edge_t, heap, graph->succs[dest], \n-\t\t       place, edge);\n-      edge_added = true;\n-      stats.num_edges++;\n-      return true;\n+      BITMAP_FREE (graph->succs[node]);\n+      graph->succs[node] = NULL;\n     }\n-  else\n-    return false;\n-}\n-\n-\n-/* Return the bitmap representing the weights of edge (SRC, DEST).  */\n-\n-static bitmap *\n-get_graph_weights (constraint_graph_t graph, unsigned int src,\n-\t\t   unsigned int dest)\n-{\n-  constraint_edge_t edge;\n-  VEC(constraint_edge_t,heap) *vec;\n-  struct constraint_edge lookfor;\n-\n-  lookfor.dest = dest;\n-\n-  vec = graph->preds[src];\n-  edge = constraint_edge_vec_find (vec, lookfor);\n-  gcc_assert (edge != NULL);\n-  return &edge->weights;\n-}\n-\n-/* Allocate graph weight bitmap for the edges associated with SRC and\n-   DEST in GRAPH.  Both the pred and the succ edges share a single\n-   bitmap, so we need to set both edges to that bitmap.  */\n-\n-static bitmap\n-allocate_graph_weights (constraint_graph_t graph, unsigned int src, \n-\t\t\tunsigned int dest)\n-{\n-  bitmap result;\n-  constraint_edge_t edge;\n-  VEC(constraint_edge_t,heap) *vec;\n-  struct constraint_edge lookfor;\n-  \n-  result = BITMAP_ALLOC (&ptabitmap_obstack);\n-\n-  /* Set the pred weight.  */\n-  lookfor.dest = dest;\n-  vec = graph->preds[src];\n-  edge = constraint_edge_vec_find (vec, lookfor);\n-  gcc_assert (edge != NULL);\n-  edge->weights = result;\n-\n-  /* Set the succ weight.  */  \n-  lookfor.dest = src;\n-  vec = graph->succs[dest];\n-  edge = constraint_edge_vec_find (vec, lookfor);\n-  gcc_assert (edge != NULL);\n-  edge->weights = result;\n-  \n-  return result;  \n }\n \n+static bool edge_added = false;\n \n /* Merge GRAPH nodes FROM and TO into node TO.  */\n \n static void\n merge_graph_nodes (constraint_graph_t graph, unsigned int to, \n \t\t   unsigned int from)\n {\n-  VEC(constraint_edge_t,heap) *succvec = graph->succs[from];\n-  VEC(constraint_edge_t,heap) *predvec = graph->preds[from];\n-  int i;\n-  constraint_edge_t c;\n   unsigned int j;\n   bitmap_iterator bi;\n \n-  /* Merge all the zero weighted predecessor edges.  */\n-  if (graph->zero_weight_preds[from])\n+  /* Merge all the predecessor edges.  */\n+  if (graph->preds[from])\n     {\n-      if (!graph->zero_weight_preds[to])\n-\tgraph->zero_weight_preds[to] = BITMAP_ALLOC (&predbitmap_obstack);\n+      if (!graph->preds[to])\n+\tgraph->preds[to] = BITMAP_ALLOC (&predbitmap_obstack);\n       \n-      EXECUTE_IF_SET_IN_BITMAP (graph->zero_weight_preds[from], 0, j, bi)\n+      EXECUTE_IF_SET_IN_BITMAP (graph->preds[from], 0, j, bi)\n \t{\n \t  if (j != to)\n \t    {\n-\t      bitmap_clear_bit (graph->zero_weight_succs[j], from);\n-\t      bitmap_set_bit (graph->zero_weight_succs[j], to);\n+\t      bitmap_clear_bit (graph->succs[j], from);\n+\t      bitmap_set_bit (graph->succs[j], to);\n \t    }\n \t}\n-      bitmap_ior_into (graph->zero_weight_preds[to], \n-\t\t       graph->zero_weight_preds[from]);\n+      bitmap_ior_into (graph->preds[to], \n+\t\t       graph->preds[from]);\n     }\n \n-  /* Merge all the zero weighted successor edges.  */\n-  if (graph->zero_weight_succs[from])\n+  /* Merge all the successor edges.  */\n+  if (graph->succs[from])\n     {\n-      if (!graph->zero_weight_succs[to])\n-\tgraph->zero_weight_succs[to] = BITMAP_ALLOC (&ptabitmap_obstack);\n-      EXECUTE_IF_SET_IN_BITMAP (graph->zero_weight_succs[from], 0, j, bi)\n-\t{\n-\t  bitmap_clear_bit (graph->zero_weight_preds[j], from);\n-\t  bitmap_set_bit (graph->zero_weight_preds[j], to);\n-\t}\n-      bitmap_ior_into (graph->zero_weight_succs[to], \n-\t\t       graph->zero_weight_succs[from]);\n-    }\n-\n-  /* Merge all the nonzero weighted predecessor edges.  */\n-  for (i = 0; VEC_iterate (constraint_edge_t, predvec, i, c); i++)\n-    {\n-      unsigned int d = c->dest;\n-      bitmap temp;\n-      bitmap *weights;\n-\n-      if (c->dest == from)\n-\td = to;\n-\n-      add_graph_edge (graph, to, d);\n-\n-      temp = *(get_graph_weights (graph, from, c->dest));      \n-      if (temp)\n+      if (!graph->succs[to])\n+\tgraph->succs[to] = BITMAP_ALLOC (&ptabitmap_obstack);\n+      EXECUTE_IF_SET_IN_BITMAP (graph->succs[from], 0, j, bi)\n \t{\n-\t  weights = get_graph_weights (graph, to, d);\n-\t  if (!*weights)\n-\t    *weights = allocate_graph_weights (graph, to, d);\n-\t  \n-\t  bitmap_ior_into (*weights, temp);\n+\t  bitmap_clear_bit (graph->preds[j], from);\n+\t  bitmap_set_bit (graph->preds[j], to);\n \t}\n-      \n+      bitmap_ior_into (graph->succs[to], \n+\t\t       graph->succs[from]);\n     }\n-  \n-  /* Merge all the nonzero weighted successor edges.  */\n-  for (i = 0; VEC_iterate (constraint_edge_t, succvec, i, c); i++)\n-    {\n-      unsigned int d = c->dest;\n-      bitmap temp;\n-      bitmap *weights;\n-\n-      if (c->dest == from)\n-\td = to;\n \n-      add_graph_edge (graph, d, to);\n-\n-      temp = *(get_graph_weights (graph, c->dest, from));\n-      if (temp)\n-\t{\n-\t  weights = get_graph_weights (graph, d, to);\n-\t  if (!*weights)\n-\t    *weights = allocate_graph_weights (graph, d, to);\n-\t  bitmap_ior_into (*weights, temp);\n-\t}\n-    }\n   clear_edges_for_node (graph, from);\n }\n \n-/* Add a graph edge to GRAPH, going from TO to FROM, with WEIGHT, if\n+/* Add a graph edge to GRAPH, going from TO to FROM if\n    it doesn't exist in the graph already.\n    Return false if the edge already existed, true otherwise.  */\n \n static bool\n-int_add_graph_edge (constraint_graph_t graph, unsigned int to, \n-\t\t    unsigned int from, unsigned HOST_WIDE_INT weight)\n+add_graph_edge (constraint_graph_t graph, unsigned int to,\n+\t\tunsigned int from)\n {\n-  if (to == from && weight == 0)\n+  if (to == from)\n     {\n       return false;\n     }\n   else\n     {\n       bool r = false;\n-\n-      if (weight == 0)\n-\t{\n-          if (!graph->zero_weight_preds[to])\n-\t    graph->zero_weight_preds[to] = BITMAP_ALLOC (&predbitmap_obstack);\n-          if (!graph->zero_weight_succs[from])\n-\t    graph->zero_weight_succs[from] = BITMAP_ALLOC (&ptabitmap_obstack);\n-\t  if (!bitmap_bit_p (graph->zero_weight_succs[from], to))\n-\t    {\n-\t      edge_added = true;\n-\t      r = true;\n-\t      stats.num_edges++;\n-\t      bitmap_set_bit (graph->zero_weight_preds[to], from);\n-\t      bitmap_set_bit (graph->zero_weight_succs[from], to);\n-\t    }\n-\t}\n-      else\n+      \n+      if (!graph->preds[to])\n+\tgraph->preds[to] = BITMAP_ALLOC (&predbitmap_obstack);\n+      if (!graph->succs[from])\n+\tgraph->succs[from] = BITMAP_ALLOC (&ptabitmap_obstack);\n+      if (!bitmap_bit_p (graph->succs[from], to))\n \t{\n-\t  bitmap *weights;\n-\n-\t  r = add_graph_edge (graph, to, from);\n-\t  weights = get_graph_weights (graph, to, from);\n-\n-\t  if (!*weights)\n-\t    {\n-\t      r = true;\n-\t      *weights = allocate_graph_weights (graph, to, from);\n-\t      bitmap_set_bit (*weights, weight);\n-\t    }\n-\t  else\n-\t    {\n-\t      r |= !bitmap_bit_p (*weights, weight);\n-\t      bitmap_set_bit (*weights, weight);\n-\t    }\n+\t  edge_added = true;\n+\t  r = true;\n+\t  stats.num_edges++;\n+\t  bitmap_set_bit (graph->preds[to], from);\n+\t  bitmap_set_bit (graph->succs[from], to);\n \t}\n-      \n       return r;\n     }\n }\n@@ -1171,28 +859,10 @@ static bool\n valid_graph_edge (constraint_graph_t graph, unsigned int src, \n \t\t  unsigned int dest)\n {\n-  struct constraint_edge lookfor;\n-  lookfor.dest = src;\n-  \n-  return (graph->zero_weight_succs[dest] \n-      && bitmap_bit_p (graph->zero_weight_succs[dest], src)) \n-    || constraint_edge_vec_find (graph->succs[dest], lookfor) != NULL;\n+  return (graph->succs[dest] \n+\t  && bitmap_bit_p (graph->succs[dest], src));\n }\n \n-/* Return true if {DEST, SRC} is an existing weighted graph edge (IE has\n-   a weight other than 0) in GRAPH.  */\n-static bool\n-valid_weighted_graph_edge (constraint_graph_t graph, unsigned int src, \n-\t\t\t   unsigned int dest)\n-{\n-  struct constraint_edge lookfor;\n-  lookfor.dest = src;\n-  \n-  return graph->preds[src] \n-    && constraint_edge_vec_find (graph->succs[dest], lookfor) != NULL;\n-}\n-\n-\n /* Build the constraint graph.  */\n \n static void\n@@ -1203,10 +873,8 @@ build_constraint_graph (void)\n \n   graph = XNEW (struct constraint_graph);\n   graph_size = VEC_length (varinfo_t, varmap) + 1;\n-  graph->succs = XCNEWVEC (VEC(constraint_edge_t,heap) *, graph_size);\n-  graph->preds = XCNEWVEC (VEC(constraint_edge_t,heap) *, graph_size);\n-  graph->zero_weight_succs = XCNEWVEC (bitmap, graph_size);\n-  graph->zero_weight_preds = XCNEWVEC (bitmap, graph_size);\n+  graph->succs = XCNEWVEC (bitmap, graph_size);\n+  graph->preds = XCNEWVEC (bitmap, graph_size);\n \n   for (i = 0; VEC_iterate (constraint_t, constraints, i, c); i++)\n     {\n@@ -1234,12 +902,14 @@ build_constraint_graph (void)\n \t}\n       else if (lhsvar > anything_id)\n \t{\n-\t  /* Ignore 0 weighted self edges, as they can't possibly contribute\n+\t  /* Ignore self edges, as they can't possibly contribute\n \t     anything */\n \t  if (lhsvar != rhsvar || rhs.offset != 0 || lhs.offset != 0)\n \t    {\n-\t      /* x = y (simple) */\n-\t      int_add_graph_edge (graph, lhs.var, rhs.var, rhs.offset);\n+\t      if (rhs.offset != 0 || lhs.offset != 0)\n+\t\tinsert_into_complex (lhsvar, c);\n+\t      else\n+\t\tadd_graph_edge (graph, lhs.var, rhs.var);\n \t    }\n \t  \n \t}\n@@ -1291,7 +961,7 @@ scc_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n   si->visited_index[n] = si->current_index ++;\n   \n   /* Visit all the successors.  */\n-  EXECUTE_IF_IN_NONNULL_BITMAP (graph->zero_weight_succs[n], 0, i, bi)\n+  EXECUTE_IF_IN_NONNULL_BITMAP (graph->succs[n], 0, i, bi)\n     {\n       unsigned int w = i;\n       if (!TEST_BIT (si->visited, w))\n@@ -1340,16 +1010,10 @@ collapse_nodes (constraint_graph_t graph, unsigned int to, unsigned int from)\n \n   if (valid_graph_edge (graph, to, to))\n     {\n-      if (graph->zero_weight_preds[to])\n-\t{\n-\t  bitmap_clear_bit (graph->zero_weight_preds[to], to);\n-\t  bitmap_clear_bit (graph->zero_weight_succs[to], to);\n-\t}\n-      if (valid_weighted_graph_edge (graph, to, to))\n+      if (graph->preds[to])\n \t{\n-\t  bitmap weights = *(get_graph_weights (graph, to, to));\n-\t  if (!weights || bitmap_empty_p (weights))\n-\t    erase_graph_self_edge (graph, to);\n+\t  bitmap_clear_bit (graph->preds[to], to);\n+\t  bitmap_clear_bit (graph->succs[to], to);\n \t}\n     }\n   BITMAP_FREE (fromsol);\n@@ -1394,7 +1058,7 @@ process_unification_queue (constraint_graph_t graph, struct scc_info *si,\n \tMerge tmp into solution for rep, marking rep changed if this\n \tchanged rep's solution.\n \t\n-\tDelete any 0 weighted self-edges we now have for rep.  */\n+\tDelete any self-edges we now have for rep.  */\n   while (i != VEC_length (unsigned, si->unification_queue))\n     {\n       unsigned int tounify = VEC_index (unsigned, si->unification_queue, i);\n@@ -1447,17 +1111,11 @@ process_unification_queue (constraint_graph_t graph, struct scc_info *si,\n \n \t  if (valid_graph_edge (graph, n, n))\n \t    {\n-\t      if (graph->zero_weight_succs[n])\n+\t      if (graph->succs[n])\n \t\t{\n-\t\t  if (graph->zero_weight_preds[n])\n-\t\t    bitmap_clear_bit (graph->zero_weight_preds[n], n);\n-\t\t  bitmap_clear_bit (graph->zero_weight_succs[n], n);\n-\t\t}\n-\t      if (valid_weighted_graph_edge (graph, n, n))\n-\t\t{\n-\t\t  bitmap weights = *(get_graph_weights (graph, n, n));\n-\t\t  if (!weights || bitmap_empty_p (weights))\n-\t\t    erase_graph_self_edge (graph, n);\n+\t\t  if (graph->preds[n])\n+\t\t    bitmap_clear_bit (graph->preds[n], n);\n+\t\t  bitmap_clear_bit (graph->succs[n], n);\n \t\t}\n \t    }\n \t}\n@@ -1509,24 +1167,12 @@ static void\n topo_visit (constraint_graph_t graph, struct topo_info *ti,\n \t    unsigned int n)\n {\n-  VEC(constraint_edge_t,heap) *succs = graph->succs[n];\n   bitmap temp;\n   bitmap_iterator bi;\n-  constraint_edge_t c;\n-  int i;\n   unsigned int j;\n \n   SET_BIT (ti->visited, n);\n-  if (VEC_length (constraint_edge_t, succs) != 0)\n-    {\n-      temp = BITMAP_ALLOC (&iteration_obstack);\n-      if (graph->zero_weight_succs[n])\n-\tbitmap_ior_into (temp, graph->zero_weight_succs[n]);\n-      for (i = 0; VEC_iterate (constraint_edge_t, succs, i, c); i++)\n-\tbitmap_set_bit (temp, c->dest);\n-    }\n-  else \n-    temp = graph->zero_weight_succs[n];\n+  temp = graph->succs[n];\n \n   if (temp) \n     EXECUTE_IF_SET_IN_BITMAP (temp, 0, j, bi)\n@@ -1640,7 +1286,7 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n \t     They don't have sets that can change.  */\n \t  if (get_varinfo (t) ->is_special_var)\n \t    flag |= bitmap_ior_into (sol, get_varinfo (t)->solution);\n-\t  else if (int_add_graph_edge (graph, lhs, t, 0))\n+\t  else if (add_graph_edge (graph, lhs, t))\n \t    flag |= bitmap_ior_into (sol, get_varinfo (t)->solution);\n \t}\n       else if (0 && dump_file && !(get_varinfo (j)->is_special_var))\n@@ -1664,7 +1310,7 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n /* Process a constraint C that represents *x = y.  */\n \n static void\n-do_ds_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n+do_ds_constraint (constraint_t c, bitmap delta)\n {\n   unsigned int rhs = get_varinfo (c->rhs.var)->node;\n   unsigned HOST_WIDE_INT roff = c->rhs.offset;\n@@ -1710,27 +1356,26 @@ do_ds_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n \t  varinfo_t v;\n \t  unsigned int t;\n \t  unsigned HOST_WIDE_INT fieldoffset = get_varinfo (j)->offset + loff;\n-\n+\t  bitmap tmp;\n+\t  \n \t  v = first_vi_for_offset (get_varinfo (j), fieldoffset);\n \t  if (!v)\n \t    continue;\n \t  t = v->node;\n-\t  if (int_add_graph_edge (graph, t, rhs, roff))\n+\t  tmp = get_varinfo (t)->solution;\n+\n+\t  if (set_union_with_increment (tmp, sol, roff))\n \t    {\n-\t      bitmap tmp = get_varinfo (t)->solution;\n-\t      if (set_union_with_increment (tmp, sol, roff))\n+\t      get_varinfo (t)->solution = tmp;\n+\t      if (t == rhs)\n+\t\tsol = get_varinfo (rhs)->solution;\n+\t      if (!TEST_BIT (changed, t))\n \t\t{\n-\t\t  get_varinfo (t)->solution = tmp;\n-\t\t  if (t == rhs)\n-\t\t    sol = get_varinfo (rhs)->solution;\n-\t\t  if (!TEST_BIT (changed, t))\n-\t\t    {\n-\t\t      SET_BIT (changed, t);\n-\t\t      changed_count++;\n-\t\t    }\n+\t\t  SET_BIT (changed, t);\n+\t\t  changed_count++;\n \t\t}\n \t    }\n-\t}    \n+\t}\n       else if (0 && dump_file && !(get_varinfo (j)->is_special_var))\n \tfprintf (dump_file, \"Untypesafe usage in do_ds_constraint\\n\");\n     }\n@@ -1752,15 +1397,40 @@ do_complex_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n       else\n \t{\n \t  /* *x = y */\n-\t  do_ds_constraint (graph, c, delta);\n+\t  do_ds_constraint (c, delta);\n \t}\n     }\n-  else\n+  else if (c->rhs.type == DEREF)\n     {\n       /* x = *y */\n       if (!(get_varinfo (c->lhs.var)->is_special_var))\n \tdo_sd_constraint (graph, c, delta);\n     }\n+  else \n+    {\n+      bitmap tmp; \n+      bitmap solution;\n+      bool flag = false;\n+      unsigned int t;\n+\n+      gcc_assert(c->rhs.type == SCALAR && c->lhs.type == SCALAR);\n+      t = get_varinfo (c->rhs.var)->node;\n+      solution = get_varinfo (t)->solution;\n+      t = get_varinfo (c->lhs.var)->node;\n+      tmp = get_varinfo (t)->solution;\n+\n+      flag = set_union_with_increment (tmp, solution, c->rhs.offset);\n+      \n+      if (flag)\n+\t{\n+\t  get_varinfo (t)->solution = tmp;\n+\t  if (!TEST_BIT (changed, c->lhs.var))\n+\t    {\n+\t      SET_BIT (changed, c->lhs.var);\n+\t      changed_count++;\n+\t    }\n+\t}\n+    }\n }\n \n /* Initialize and return a new SCC info structure.  */\n@@ -1831,21 +1501,6 @@ compute_topo_order (constraint_graph_t graph,\n       topo_visit (graph, ti, i);\n }\n \n-/* Return true if bitmap B is empty, or a bitmap other than bit 0 is set. */\n-\n-static bool\n-bitmap_other_than_zero_bit_set (bitmap b)\n-{\n-  unsigned int i;\n-  bitmap_iterator bi;\n-\n-  if (bitmap_empty_p (b))\n-    return false;\n-  EXECUTE_IF_SET_IN_BITMAP (b, 1, i, bi)\n-    return true;\n-  return false;\n-}\n-\n /* Perform offline variable substitution.\n    \n    This is a linear time way of identifying variables that must have\n@@ -1869,12 +1524,9 @@ perform_var_substitution (constraint_graph_t graph)\n   while (VEC_length (unsigned, ti->topo_order) != 0)\n     {\n       unsigned int i = VEC_pop (unsigned, ti->topo_order);\n-      unsigned int pred;\n       varinfo_t vi = get_varinfo (i);\n       bool okay_to_elim = false;\n       unsigned int root = VEC_length (varinfo_t, varmap);\n-      VEC(constraint_edge_t,heap) *predvec = graph->preds[i];\n-      constraint_edge_t ce = NULL;\n       bitmap tmp;\n       unsigned int k;\n       bitmap_iterator bi;\n@@ -1885,7 +1537,7 @@ perform_var_substitution (constraint_graph_t graph)\n \tcontinue;\n \n       /* See if all predecessors of I are ripe for elimination */\n-      EXECUTE_IF_IN_NONNULL_BITMAP (graph->zero_weight_preds[i], 0, k, bi)\n+      EXECUTE_IF_IN_NONNULL_BITMAP (graph->preds[i], 0, k, bi)\n \t  {\n \t    unsigned int w;\n \t    w = get_varinfo (k)->node;\n@@ -1921,55 +1573,6 @@ perform_var_substitution (constraint_graph_t graph)\n \t    BITMAP_FREE (tmp);\n \t  }\n \n-      if (okay_to_elim)\n-\tfor (pred = 0; \n-\t     VEC_iterate (constraint_edge_t, predvec, pred, ce); \n-\t     pred++)\n-\t  {\n-\t    bitmap weight;\n-\t    unsigned int w;\n-\t    weight = *(get_graph_weights (graph, i, ce->dest));\n-\n-\t    /* We can't eliminate variables that have nonzero weighted\n-\t       edges between them.  */\n-\t    if (weight && bitmap_other_than_zero_bit_set (weight))\n-\t      {\n-\t\tokay_to_elim = false;\n-\t\tbreak;\n-\t      }\n-\t    w = get_varinfo (ce->dest)->node;\n-\n-\t    /* We can't eliminate the node if one of the predecessors is\n-\t       part of a different strongly connected component.  */\n-\t    if (!okay_to_elim)\n-\t      {\n-\t\troot = w;\n-\t\tokay_to_elim = true;\n-\t      }\n-\t    else if (w != root)\n-\t      {\n-\t\tokay_to_elim = false;\n-\t\tbreak;\n-\t      }\n-\n-\t    /* Theorem 4 in Rountev and Chandra: If i is a direct node,\n-\t       then Solution(i) is a subset of Solution (w), where w is a\n-\t       predecessor in the graph.  \n-\t       Corollary: If all predecessors of i have the same\n-\t       points-to set, then i has that same points-to set as\n-\t       those predecessors.  */\n-\t    tmp = BITMAP_ALLOC (NULL);\n-\t    bitmap_and_compl (tmp, get_varinfo (i)->solution,\n-\t\t\t      get_varinfo (w)->solution);\n-\t    if (!bitmap_empty_p (tmp))\n-\t      {\n-\t\tokay_to_elim = false;\n-\t\tBITMAP_FREE (tmp);\n-\t\tbreak;\n-\t      }\n-\t    BITMAP_FREE (tmp);\n-\t  }\n-\n       /* See if the root is different than the original node. \n \t If so, we've found an equivalence.  */\n       if (root != get_varinfo (i)->node && okay_to_elim)\n@@ -2044,11 +1647,9 @@ solve_graph (constraint_graph_t graph)\n \t    {\n \t      unsigned int j;\n \t      constraint_t c;\n-\t      constraint_edge_t e = NULL;\n \t      bitmap solution;\n \t      bitmap_iterator bi;\n \t      VEC(constraint_t,heap) *complex = get_varinfo (i)->complex;\n-\t      VEC(constraint_edge_t,heap) *succs;\n \t      bool solution_empty;\n \n \t      RESET_BIT (changed, i);\n@@ -2073,14 +1674,14 @@ solve_graph (constraint_graph_t graph)\n \t      if (!solution_empty)\n \t\t{\n \t\t  /* Propagate solution to all successors.  */\n-\t\t  succs = graph->succs[i];\n-\t\t  \n-\t\t  EXECUTE_IF_IN_NONNULL_BITMAP (graph->zero_weight_succs[i], \n+\t\t  EXECUTE_IF_IN_NONNULL_BITMAP (graph->succs[i], \n \t\t\t\t\t\t0, j, bi)\n \t\t    {\n \t\t      bitmap tmp = get_varinfo (j)->solution;\n \t\t      bool flag = false;\n \t\t  \n+\t\t      gcc_assert (get_varinfo (j)->node == j);\n+\t\t      \n \t\t      flag = set_union_with_increment (tmp, solution, 0);\n \t\t  \n \t\t      if (flag)\n@@ -2093,35 +1694,13 @@ solve_graph (constraint_graph_t graph)\n \t\t\t    }\n \t\t\t}\n \t\t    }\n-\t\t  for (j = 0; VEC_iterate (constraint_edge_t, succs, j, e); j++)\n-\t\t    {\n-\t\t      bitmap tmp = get_varinfo (e->dest)->solution;\n-\t\t      bool flag = false;\n-\t\t      unsigned int k;\n-\t\t      bitmap weights = e->weights;\n-\t\t      bitmap_iterator bi;\n-\n-\t\t      gcc_assert (weights && !bitmap_empty_p (weights));\n-\t\t      EXECUTE_IF_SET_IN_BITMAP (weights, 0, k, bi)\n-\t\t\tflag |= set_union_with_increment (tmp, solution, k);\n-\n-\t\t      if (flag)\n-\t\t\t{\n-\t\t\t  get_varinfo (e->dest)->solution = tmp;\n-\t\t\t  if (!TEST_BIT (changed, e->dest))\n-\t\t\t    {\n-\t\t\t      SET_BIT (changed, e->dest);\n-\t\t\t      changed_count++;\n-\t\t\t    }\n-\t\t\t}\n-\t\t    }\n \t\t}\n \t    }\n \t}\n       free_topo_info (ti);\n       bitmap_obstack_release (&iteration_obstack);\n     }\n-\n+  \n   sbitmap_free (changed);\n }\n \n@@ -4667,9 +4246,6 @@ init_alias_vars (void)\n \t\t\t\t       sizeof (struct constraint), 30);\n   variable_info_pool = create_alloc_pool (\"Variable info pool\",\n \t\t\t\t\t  sizeof (struct variable_info), 30);\n-  constraint_edge_pool = create_alloc_pool (\"Constraint edges\",\n-\t\t\t\t\t    sizeof (struct constraint_edge), 30);\n-  \n   constraints = VEC_alloc (constraint_t, heap, 8);\n   varmap = VEC_alloc (varinfo_t, heap, 8);\n   id_for_tree = htab_create (10, tree_id_hash, tree_id_eq, free);\n@@ -4873,21 +4449,15 @@ delete_points_to_sets (void)\n       if (i >= graph_size)\n \tbreak;\n \n-      VEC_free (constraint_edge_t, heap, graph->succs[i]);\n-      VEC_free (constraint_edge_t, heap, graph->preds[i]);\n       VEC_free (constraint_t, heap, v->complex);\n     }\n-  free (graph->zero_weight_preds);\n-  free (graph->zero_weight_succs);\n-  free (graph->succs);\n   free (graph->preds);\n+  free (graph->succs);\n   free (graph);\n \n   VEC_free (varinfo_t, heap, varmap);\n   free_alloc_pool (variable_info_pool);\n   free_alloc_pool (constraint_pool); \n-  free_alloc_pool (constraint_edge_pool);\n-\n   have_alias_info = false;\n }\n "}]}