{"sha": "d7da5cc85cdef4207d10e8b79dce79ed12353fb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdkYTVjYzg1Y2RlZjQyMDdkMTBlOGI3OWRjZTc5ZWQxMjM1M2ZiOQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2011-09-02T15:37:38Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2011-09-02T15:37:38Z"}, "message": "ipa-prop.h (ipa_node_params): Removed fields called_with_var_arguments and node_versionable.\n\n2011-09-02  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.h (ipa_node_params): Removed fields\n\tcalled_with_var_arguments and node_versionable.\n\t(ipa_set_called_with_variable_arg): Removed.\n\t(ipa_is_called_with_var_arguments): Likewise.\n\t* ipa-cp.c (ipa_get_lattice): Fixed index check in an assert.\n\t(determine_versionability): Do not check for type attributes and va\n\tbuiltins.  Record versionability into inline summary.\n\t(initialize_node_lattices): Do not check\n\tipa_is_called_with_var_arguments.\n\t(propagate_constants_accross_call): Likewise, ignore arguments we do\n\tnot have PARM_DECLs for, set variable flag for parameters that were\n\tnot passed a value.\n\t(create_specialized_node): Dump info that we cannot change signature.\n\t* ipa-prop.c (ipa_compute_jump_functions): Do not care about variable\n\tnumber of arguments.\n\t(ipa_make_edge_direct_to_target): Likewise.\n\t(ipa_update_after_lto_read): Likewise.\n\t(ipa_node_duplication_hook): Do not copy called_with_var_arguments flag.\n\t* tree-inline.c (copy_arguments_for_versioning): Copy PARM_DECLs if\n\tthey were remapped.\n\n\t* testsuite/gcc.dg/ipa/ipcp-3.c: New test.\n\nFrom-SVN: r178485", "tree": {"sha": "c5080ee359d717b439069963cb722bd18f086222", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5080ee359d717b439069963cb722bd18f086222"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7da5cc85cdef4207d10e8b79dce79ed12353fb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7da5cc85cdef4207d10e8b79dce79ed12353fb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7da5cc85cdef4207d10e8b79dce79ed12353fb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7da5cc85cdef4207d10e8b79dce79ed12353fb9/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e9e1d143b5ea00f99191cd0e65c09ee972ebcedb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9e1d143b5ea00f99191cd0e65c09ee972ebcedb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9e1d143b5ea00f99191cd0e65c09ee972ebcedb"}], "stats": {"total": 199, "additions": 119, "deletions": 80}, "files": [{"sha": "959a4a623b0c539ecd3567d505640919cde347ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7da5cc85cdef4207d10e8b79dce79ed12353fb9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7da5cc85cdef4207d10e8b79dce79ed12353fb9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d7da5cc85cdef4207d10e8b79dce79ed12353fb9", "patch": "@@ -1,3 +1,26 @@\n+2011-09-02  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-prop.h (ipa_node_params): Removed fields\n+\tcalled_with_var_arguments and node_versionable.\n+\t(ipa_set_called_with_variable_arg): Removed.\n+\t(ipa_is_called_with_var_arguments): Likewise.\n+\t* ipa-cp.c (ipa_get_lattice): Fixed index check in an assert.\n+\t(determine_versionability): Do not check for type attributes and va\n+\tbuiltins.  Record versionability into inline summary.\n+\t(initialize_node_lattices): Do not check\n+\tipa_is_called_with_var_arguments.\n+\t(propagate_constants_accross_call): Likewise, ignore arguments we do\n+\tnot have PARM_DECLs for, set variable flag for parameters that were\n+\tnot passed a value.\n+\t(create_specialized_node): Dump info that we cannot change signature.\n+\t* ipa-prop.c (ipa_compute_jump_functions): Do not care about variable\n+\tnumber of arguments.\n+\t(ipa_make_edge_direct_to_target): Likewise.\n+\t(ipa_update_after_lto_read): Likewise.\n+\t(ipa_node_duplication_hook): Do not copy called_with_var_arguments flag.\n+\t* tree-inline.c (copy_arguments_for_versioning): Copy PARM_DECLs if\n+\tthey were remapped.\n+\n 2011-09-02  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/27460"}, {"sha": "e751899f1311d0446fe4ab466fa49a1f751c614b", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 17, "deletions": 31, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7da5cc85cdef4207d10e8b79dce79ed12353fb9/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7da5cc85cdef4207d10e8b79dce79ed12353fb9/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=d7da5cc85cdef4207d10e8b79dce79ed12353fb9", "patch": "@@ -221,7 +221,7 @@ static struct ipcp_value *values_topo;\n static inline struct ipcp_lattice *\n ipa_get_lattice (struct ipa_node_params *info, int i)\n {\n-  gcc_assert (i >= 0 && i <= ipa_get_param_count (info));\n+  gcc_assert (i >= 0 && i < ipa_get_param_count (info));\n   gcc_checking_assert (!info->ipcp_orig_node);\n   gcc_checking_assert (info->lattices);\n   return &(info->lattices[i]);\n@@ -360,7 +360,6 @@ print_all_lattices (FILE * f, bool dump_sources, bool dump_benefits)\n static void\n determine_versionability (struct cgraph_node *node)\n {\n-  struct cgraph_edge *edge;\n   const char *reason = NULL;\n \n   /* There are a number of generic reasons functions cannot be versioned.  We\n@@ -369,32 +368,15 @@ determine_versionability (struct cgraph_node *node)\n   if (node->alias || node->thunk.thunk_p)\n     reason = \"alias or thunk\";\n   else if (!inline_summary (node)->versionable)\n-    reason = \"inliner claims it is so\";\n-  else if (TYPE_ATTRIBUTES (TREE_TYPE (node->decl)))\n-    reason = \"there are type attributes\";\n+    reason = \"not a tree_versionable_function\";\n   else if (cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n     reason = \"insufficient body availability\";\n-  else\n-    /* Removing arguments doesn't work if the function takes varargs\n-       or use __builtin_apply_args.\n-       FIXME: handle this together with can_change_signature flag.  */\n-    for (edge = node->callees; edge; edge = edge->next_callee)\n-      {\n-\ttree t = edge->callee->decl;\n-\tif (DECL_BUILT_IN_CLASS (t) == BUILT_IN_NORMAL\n-\t    && (DECL_FUNCTION_CODE (t) == BUILT_IN_APPLY_ARGS\n-\t\t|| DECL_FUNCTION_CODE (t) == BUILT_IN_VA_START))\n-\t  {\n-\t    reason = \"prohibitive builtins called\";\n-\t    break;\n-\t  };\n-      }\n \n   if (reason && dump_file && !node->alias && !node->thunk.thunk_p)\n     fprintf (dump_file, \"Function %s/%i is not versionable, reason: %s.\\n\",\n \t     cgraph_node_name (node), node->uid, reason);\n \n-  IPA_NODE_REF (node)->node_versionable = (reason == NULL);\n+  inline_summary (node)->versionable = (reason == NULL);\n }\n \n /* Return true if it is at all technically possible to create clones of a\n@@ -403,7 +385,7 @@ determine_versionability (struct cgraph_node *node)\n static bool\n ipcp_versionable_function_p (struct cgraph_node *node)\n {\n-  return IPA_NODE_REF (node)->node_versionable;\n+  return inline_summary (node)->versionable;\n }\n \n /* Structure holding accumulated information about callers of a node.  */\n@@ -610,9 +592,7 @@ initialize_node_lattices (struct cgraph_node *node)\n   int i;\n \n   gcc_checking_assert (cgraph_function_with_gimple_body_p (node));\n-  if (ipa_is_called_with_var_arguments (info))\n-    disable = true;\n-  else if (!node->local.local)\n+  if (!node->local.local)\n     {\n       /* When cloning is allowed, we can assume that externally visible\n \t functions are not called.  We will compensate this by cloning\n@@ -1068,18 +1048,17 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n   struct cgraph_node *callee, *alias_or_thunk;\n   struct ipa_edge_args *args;\n   bool ret = false;\n-  int i, count;\n+  int i, args_count, parms_count;\n \n   callee = cgraph_function_node (cs->callee, &availability);\n   if (!callee->analyzed)\n     return false;\n   gcc_checking_assert (cgraph_function_with_gimple_body_p (callee));\n   callee_info = IPA_NODE_REF (callee);\n-  if (ipa_is_called_with_var_arguments (callee_info))\n-    return false;\n \n   args = IPA_EDGE_REF (cs);\n-  count = ipa_get_cs_argument_count (args);\n+  args_count = ipa_get_cs_argument_count (args);\n+  parms_count = ipa_get_param_count (callee_info);\n \n   /* If this call goes through a thunk we must not propagate to the first (0th)\n      parameter.  However, we might need to uncover a thunk from below a series\n@@ -1095,7 +1074,7 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n   else\n     i = 0;\n \n-  for (; i < count; i++)\n+  for (; (i < args_count) && (i < parms_count); i++)\n     {\n       struct ipa_jump_func *jump_func = ipa_get_ith_jump_func (args, i);\n       struct ipcp_lattice *dest_lat = ipa_get_lattice (callee_info, i);\n@@ -1105,6 +1084,9 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n       else\n \tret |= propagate_accross_jump_function (cs, jump_func, dest_lat);\n     }\n+  for (; i < parms_count; i++)\n+    ret |= set_lattice_contains_variable (ipa_get_lattice (callee_info, i));\n+\n   return ret;\n }\n \n@@ -2004,7 +1986,11 @@ create_specialized_node (struct cgraph_node *node,\n \t}\n     }\n   else\n-    args_to_skip = NULL;\n+    {\n+      args_to_skip = NULL;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"      cannot change function signature\\n\");\n+    }\n \n   for (i = 0; i < count ; i++)\n     {"}, {"sha": "5c0bd90c16b56f01a474c9c5a7a8e2d95f96f2b9", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 3, "deletions": 28, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7da5cc85cdef4207d10e8b79dce79ed12353fb9/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7da5cc85cdef4207d10e8b79dce79ed12353fb9/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=d7da5cc85cdef4207d10e8b79dce79ed12353fb9", "patch": "@@ -1032,19 +1032,13 @@ ipa_compute_jump_functions (struct cgraph_node *node,\n \n   for (cs = node->callees; cs; cs = cs->next_callee)\n     {\n-      struct cgraph_node *callee = cgraph_function_or_thunk_node (cs->callee, NULL);\n+      struct cgraph_node *callee = cgraph_function_or_thunk_node (cs->callee,\n+\t\t\t\t\t\t\t\t  NULL);\n       /* We do not need to bother analyzing calls to unknown\n \t functions unless they may become known during lto/whopr.  */\n-      if (!cs->callee->analyzed && !flag_lto)\n+      if (!callee->analyzed && !flag_lto)\n \tcontinue;\n       ipa_count_arguments (cs);\n-      /* If the descriptor of the callee is not initialized yet, we have to do\n-\t it now. */\n-      if (callee->analyzed)\n-\tipa_initialize_node_params (callee);\n-      if (ipa_get_cs_argument_count (IPA_EDGE_REF (cs))\n-\t  != ipa_get_param_count (IPA_NODE_REF (callee)))\n-\tipa_set_called_with_variable_arg (IPA_NODE_REF (callee));\n       ipa_compute_jump_functions_for_edge (parms_info, cs);\n     }\n \n@@ -1649,10 +1643,6 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n     }\n   callee = cgraph_function_or_thunk_node (callee, NULL);\n \n-  if (ipa_get_cs_argument_count (IPA_EDGE_REF (ie))\n-      != ipa_get_param_count (IPA_NODE_REF (callee)))\n-    ipa_set_called_with_variable_arg (IPA_NODE_REF (callee));\n-\n   return ie;\n }\n \n@@ -1964,7 +1954,6 @@ ipa_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n   new_info->lattices = NULL;\n   new_info->ipcp_orig_node = old_info->ipcp_orig_node;\n \n-  new_info->called_with_var_arguments = old_info->called_with_var_arguments;\n   new_info->uses_analysis_done = old_info->uses_analysis_done;\n   new_info->node_enqueued = old_info->node_enqueued;\n }\n@@ -2949,25 +2938,11 @@ void\n ipa_update_after_lto_read (void)\n {\n   struct cgraph_node *node;\n-  struct cgraph_edge *cs;\n \n   ipa_check_create_node_params ();\n   ipa_check_create_edge_args ();\n \n   for (node = cgraph_nodes; node; node = node->next)\n     if (node->analyzed)\n       ipa_initialize_node_params (node);\n-\n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed)\n-      for (cs = node->callees; cs; cs = cs->next_callee)\n-\t{\n-\t  struct cgraph_node *callee;\n-\n-\t  callee = cgraph_function_or_thunk_node (cs->callee, NULL);\n-\t  if (ipa_get_cs_argument_count (IPA_EDGE_REF (cs))\n-\t      != ipa_get_param_count (IPA_NODE_REF (callee)))\n-\t    ipa_set_called_with_variable_arg (IPA_NODE_REF (callee));\n-\t}\n }\n-"}, {"sha": "618b5a0b9cda9d8756e3877cfdb727f1fee9b1e6", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7da5cc85cdef4207d10e8b79dce79ed12353fb9/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7da5cc85cdef4207d10e8b79dce79ed12353fb9/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=d7da5cc85cdef4207d10e8b79dce79ed12353fb9", "patch": "@@ -168,11 +168,6 @@ struct ipa_node_params\n   /* If this node is an ipa-cp clone, these are the known values that describe\n      what it has been specialized for.  */\n   VEC (tree, heap) *known_vals;\n-  /* Whether this function is called with variable number of actual\n-     arguments.  */\n-  unsigned called_with_var_arguments : 1;\n-  /* Set when it is possible to create specialized versions of this node.  */\n-  unsigned node_versionable : 1;\n   /* Whether the param uses analysis has already been performed.  */\n   unsigned uses_analysis_done : 1;\n   /* Whether the function is enqueued in ipa-cp propagation stack.  */\n@@ -224,22 +219,6 @@ ipa_is_param_used (struct ipa_node_params *info, int i)\n   return VEC_index (ipa_param_descriptor_t, info->descriptors, i)->used;\n }\n \n-/* Flag this node as having callers with variable number of arguments.  */\n-\n-static inline void\n-ipa_set_called_with_variable_arg (struct ipa_node_params *info)\n-{\n-  info->called_with_var_arguments = 1;\n-}\n-\n-/* Have we detected this node was called with variable number of arguments? */\n-\n-static inline bool\n-ipa_is_called_with_var_arguments (struct ipa_node_params *info)\n-{\n-  return info->called_with_var_arguments;\n-}\n-\n /* ipa_edge_args stores information related to a callsite and particularly its\n    arguments.  It can be accessed by the IPA_EDGE_REF macro.  */\n typedef struct GTY(()) ipa_edge_args"}, {"sha": "d779df33487932fa198fe052ed21951e853ed792", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7da5cc85cdef4207d10e8b79dce79ed12353fb9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7da5cc85cdef4207d10e8b79dce79ed12353fb9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d7da5cc85cdef4207d10e8b79dce79ed12353fb9", "patch": "@@ -1,3 +1,7 @@\n+2011-09-02  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* gcc.dg/ipa/ipcp-3.c: New test.\n+\n 2011-09-02  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/27460"}, {"sha": "1443b73ebcdcbc4a511046acd09758b55ab224bd", "filename": "gcc/testsuite/gcc.dg/ipa/ipcp-3.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7da5cc85cdef4207d10e8b79dce79ed12353fb9/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7da5cc85cdef4207d10e8b79dce79ed12353fb9/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-3.c?ref=d7da5cc85cdef4207d10e8b79dce79ed12353fb9", "patch": "@@ -0,0 +1,70 @@\n+/* Verify that IPA-CP can clone mark_cell without miscompiling it despite its\n+   type_attributes.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fdump-ipa-cp\" } */\n+\n+\n+struct PMC {\n+    unsigned flags;\n+};\n+\n+typedef struct Pcc_cell\n+{\n+    struct PMC *p;\n+    long bla;\n+    long type;\n+} Pcc_cell;\n+\n+int gi;\n+\n+extern void abort ();\n+extern void never_ever(int * interp, struct PMC *pmc)\n+     __attribute__((noinline));\n+\n+void never_ever (int * interp, struct PMC *pmc)\n+{\n+  abort ();\n+}\n+\n+static void mark_cell(int * interp, Pcc_cell *c)\n+        __attribute__((__nonnull__(1)))\n+        __attribute__((noinline));\n+\n+static void\n+mark_cell(int * interp, Pcc_cell *c)\n+{\n+  if (c && c->type == 4 && c->p\n+      && !(c->p->flags & (1<<18)))\n+    never_ever(interp, c->p);\n+}\n+\n+static void foo(int * interp, Pcc_cell *c)\n+  __attribute__((noinline));\n+\n+static void\n+foo(int * interp, Pcc_cell *c)\n+{\n+  mark_cell(interp, c);\n+}\n+\n+static struct Pcc_cell *\n+__attribute__((noinline,noclone))\n+getnull(void)\n+{\n+  return (struct Pcc_cell *) 0;\n+}\n+\n+\n+int main()\n+{\n+  int i;\n+\n+  for (i = 0; i < 100; i++)\n+    foo (&gi, getnull ());\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-ipa-dump \"Creating a specialized node of mark_cell\" \"cp\" } } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */\n+"}, {"sha": "3610289dc35ad7b56aa5a257b49c6ff1fe12ae0d", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7da5cc85cdef4207d10e8b79dce79ed12353fb9/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7da5cc85cdef4207d10e8b79dce79ed12353fb9/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=d7da5cc85cdef4207d10e8b79dce79ed12353fb9", "patch": "@@ -4840,6 +4840,8 @@ copy_arguments_for_versioning (tree orig_parm, copy_body_data * id,\n     if (!args_to_skip || !bitmap_bit_p (args_to_skip, i))\n       {\n         tree new_tree = remap_decl (arg, id);\n+\tif (TREE_CODE (new_tree) != PARM_DECL)\n+\t  new_tree = id->copy_decl (arg, id);\n         lang_hooks.dup_lang_specific_decl (new_tree);\n         *parg = new_tree;\n \tparg = &DECL_CHAIN (new_tree);"}]}