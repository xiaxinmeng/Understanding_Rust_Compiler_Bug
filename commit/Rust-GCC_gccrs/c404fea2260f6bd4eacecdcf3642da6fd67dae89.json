{"sha": "c404fea2260f6bd4eacecdcf3642da6fd67dae89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQwNGZlYTIyNjBmNmJkNGVhY2VjZGNmMzY0MmRhNmZkNjdkYWU4OQ==", "commit": {"author": {"name": "Teemu Torma", "email": "tot@trema.com", "date": "1997-12-12T04:54:37Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-12-12T04:54:37Z"}, "message": "Thread-safe EH support for pthreads, DCE threads and Solaris threads.\n\nThu Dec 11 20:42:18 1997  Teemu Torma  <tot@trema.com>\n\n\tThread-safe EH support for pthreads, DCE threads and Solaris threads.\n\n\t* integrate.c (expand_inline_function): If the inline fn uses eh\n\tcontext, make sure that the current fn has one.\n\t* toplev.c (rest_of_compilation): Call emit_eh_context.\n\t* except.c (use_eh_context): New fn.\n\t(get_eh_context_once): New fn.\n\t(call_get_eh_context): New fn.\n\t(emit_eh_context): New fn.\n\t(get_eh_context): Call either get_eh_context_once or\n\tcall_get_eh_context, depending on what we have.\n\t(get_dynamic_handler_chain): Call get_eh_context_once.\n\t* except.h: Prototypes for fns above.\n\t* optabs.c (get_eh_context_libfunc): Removed.\n\t(init_optabs): Don't initialize it.\n\t* expr.h (get_eh_context_libfunc): Removed.\n\t* rtl.h, rtl.c: New reg_note REG_EH_CONTEXT.\n\t* config/pa/pa.h (CPP_SPEC): Support for -threads.\n\t* config/pa/pa-hpux10.h (LIB_SPEC): Ditto.\n\t* config/pa/t-pa (MULTILIB_OPTIONS, MULTILIB_DIRNAMES):\n\tNew multilib for -threads.\n\t* config/sparc/t-sol2: Added multilibs for -threads and\n\tmade -pthreads alias to it.\n\t* config/sparc/sol2.h (CPP_SPEC, LIB_SPEC):\n\tAdded -threads and -pthreads options.\n\t* libgcc-thr.h: New file.\n\t* libgcc2.c: (__get_cpp_eh_context): Removed.\n\t(struct cpp_eh_context): Removed.\n\t(struct eh_context): Replaced cpp_eh_context with generic language\n\tspecific pointer.\n\t(__get_eh_info): New function.\n\t(__throw): Check eh_context::info.\n\t(__sjthrow): Ditto.\n\t* libgcc2.c: Include libgcc-thr.h.\n\t(new_eh_context, __get_eh_context,\n\teh_pthread_initialize, eh_context_initialize, eh_context_static,\n\teh_context_specific, eh_context_free): New functions.\n\t(get_eh_context, eh_context_key): New variables.\n\t(__sjthrow, __sjpopnthrow, __eh_pcnthrow, __throw): Use\n\tget_eh_context to get the context.\n\t(longjmp): Move the declaration inside\n\t#ifdef DONT_USE_BUILTIN_SETJMP.\n\t* frame.c: Include libgcc-thr.h.\n\t(object_mutex): Mutex to protect the object list.\n\t(find_fde, __register_frame, __register_frame_table,\n\t__deregister_frame): Hold the lock while accessing objects.\n\t* except.h (get_eh_context): Declare.\n\t* except.c (current_function_ehc): Define.\n\t(current_function_dhc, current_function_dcc): Removed.\n\t(get_eh_context): New function.\n\t(get_dynamic_handler_chain): Use get_eh_context.\n\t(get_saved_pc_ref): Ditto.\n\t(get_dynamic_cleanup_chain): Removed references to\n\tcurrent_function_dcc.\n\t(save_eh_status, restore_eh_status): Save and restore\n\tcurrent_function_ehc instead.\n\t* optabs.c (get_eh_context_libfunc): New variable.\n\t(init_optabs): Initialize it.\n\t* expr.h: Declare get_eh_context_libfunc.\n\t* function.h (struct function): Replaced dhc and dcc with ehc.\n\t* except.c (get_saved_pc_ref): New functions.\n\t(eh_saved_pc_rtx, eh_saved_pc): Deleted.\n\t(expand_internal_throw_indirect): Use get_saved_pc_ref() instead\n\tof eh_saved_pc.\n\t(end_eh_unwinder): Likewise.\n\t(init_eh): Remove initialization of eh_saved_pc.\n\t* optabs.c (get_saved_pc_libfunc): New variable.\n\t(init_optabs): Initialize it.\n\t* expr.h: Declare get_saved_pc_libfunc.\n\t* except.h (eh_saved_pc_rtx): Deleted.\n\t(get_saved_pc_ref): Declared.\n\n\tFrom Scott Snyder <snyder@d0sgif.fnal.gov>:\n\t* libgcc2.c (__get_saved_pc): New.\n\t(__eh_type, __eh_pc): Deleted.\n\t(__eh_pcnthrow): Use __get_saved_pc() instead of __eh_pc.\n\t(__get_dynamic_handler_chain): Move __dynamic_handler_chain inside\n\tthis fcn.\n\nFrom-SVN: r17053", "tree": {"sha": "3d41c7d18ad68bd0236748bcef4b9e2752de7ca0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d41c7d18ad68bd0236748bcef4b9e2752de7ca0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c404fea2260f6bd4eacecdcf3642da6fd67dae89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c404fea2260f6bd4eacecdcf3642da6fd67dae89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c404fea2260f6bd4eacecdcf3642da6fd67dae89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c404fea2260f6bd4eacecdcf3642da6fd67dae89/comments", "author": null, "committer": null, "parents": [{"sha": "154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/154bba13a4a3d494a12622c489ba9d7bd1f76a8b"}], "stats": {"total": 321, "additions": 321, "deletions": 0}, "files": [{"sha": "53813c5c7899ca11653d251f00375ab7840450e4", "filename": "gcc/libgcc-thr.h", "status": "added", "additions": 321, "deletions": 0, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c404fea2260f6bd4eacecdcf3642da6fd67dae89/gcc%2Flibgcc-thr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c404fea2260f6bd4eacecdcf3642da6fd67dae89/gcc%2Flibgcc-thr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc-thr.h?ref=c404fea2260f6bd4eacecdcf3642da6fd67dae89", "patch": "@@ -0,0 +1,321 @@\n+/* Threads compatibily routines for libgcc2.  */\n+/* Compile this one with gcc.  */\n+/* Copyright (C) 1997 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with other files,\n+   some of which are compiled with GCC, to produce an executable,\n+   this library does not by itself cause the resulting executable\n+   to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#ifndef __libgcc_thr_h\n+#define __libgcc_thr_h\n+\n+/* If this file is compiled with threads support, it must\n+       #define __GTHREADS 1\n+   to indicate that threads support is present.\n+   \n+   The threads interface must define the following types:\n+     __gthread_key_t\n+     __gthread_once_t\n+     __gthread_mutex_t\n+\n+   The threads interface must define the following macros:\n+\n+     __GTHREAD_ONCE_INIT\n+     \t\tto initialize __gthread_once_t\n+     __GTHREAD_MUTEX_INIT\n+     \t\tto initialize __gthread_mutex_t to get a fast\n+\t\tnon-recursive mutex.\n+\n+   The threads interface must define the following static functions:\n+\n+     int __gthread_once (__gthread_once_t *once, void (*func) ())\n+\n+     int __gthread_key_create (__gthread_key_t *keyp, void (*dtor) (void *))\n+     int __gthread_key_delete (__gthread_key_t key)\n+\n+     void *__gthread_getspecific (__gthread_key_t key)\n+     int __gthread_setspecific (__gthread_key_t key, const void *ptr)\n+\n+     int __gthread_mutex_lock (__gthread_mutex_t *mutex);\n+     int __gthread_mutex_trylock (__gthread_mutex_t *mutex);\n+     int __gthread_mutex_unlock (__gthread_mutex_t *mutex);\n+\n+   All functions returning int should return 0 on success, -1 on error.\n+\n+   Currently supported threads packages are\n+     POSIX threads with -D_PTHREADS\n+     DCE threads with -D_DCE_THREADS\n+     Solaris/UI threads with -D_SOLARIS_THREADS\n+*/\n+\n+#if _PTHREADS\n+/* POSIX threads specific definitions.\n+   Easy, since the interface is just one-to-one mapping. */\n+\n+#define __GTHREADS 1\n+\n+#include <pthread.h>\n+\n+typedef pthread_key_t __gthread_key_t;\n+typedef pthread_once_t __gthread_once_t;\n+typedef pthread_mutex_t __gthread_mutex_t;\n+\n+#define __GTHREAD_MUTEX_INIT PTHREAD_MUTEX_INITIALIZER\n+#define __GTHREAD_ONCE_INIT PTHREAD_ONCE_INIT\n+\n+static inline int\n+__gthread_once (__gthread_once_t *once, void (*func) ())\n+{\n+  return pthread_once (once, func);\n+}\n+\n+static inline int\n+__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n+{\n+  return pthread_key_create (key, dtor);\n+}\n+\n+static inline int\n+__gthread_key_delete (__gthread_key_t key)\n+{\n+  return pthread_key_delete (key);\n+}\n+\n+static inline void *\n+__gthread_getspecific (__gthread_key_t key)\n+{\n+  return pthread_getspecific (key);\n+}\n+\n+static inline int\n+__gthread_setspecific (__gthread_key_t key, const void *ptr)\n+{\n+  return pthread_setspecific (key, ptr);\n+}\n+\n+static inline int\n+__gthread_mutex_lock (__gthread_mutex_t *mutex)\n+{\n+  return pthread_mutex_lock (mutex);\n+}\n+\n+static inline int\n+__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n+{\n+  return pthread_mutex_trylock (mutex);\n+}\n+\n+static inline int\n+__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n+{\n+  return pthread_mutex_unlock (mutex);\n+}\n+\n+#elif _DCE_THREADS\n+/* DCE threads interface.\n+   DCE threads are based on POSIX threads draft 4, and many things\n+   have changed since then. */\n+\n+#define __GTHREADS 1\n+\n+#include <pthread.h>\n+\n+typedef pthread_key_t __gthread_key_t;\n+typedef pthread_once_t __gthread_once_t;\n+typedef pthread_mutex_t __gthread_mutex_t;\n+\n+#define __GTHREAD_ONCE_INIT pthread_once_init\n+/* Howto define __GTHREAD_MUTEX_INIT? */\n+\n+static inline int\n+__gthread_once (__gthread_once_t *once, void (*func) ())\n+{\n+  return pthread_once (once, func);\n+}\n+\n+static inline int\n+__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n+{\n+  return pthread_keycreate (key, dtor);\n+}\n+\n+static inline int\n+__gthread_key_delete (__gthread_key_t key)\n+{\n+  return pthread_key_delete (key);\n+}\n+\n+static inline void *\n+__gthread_getspecific (__gthread_key_t key)\n+{\n+  void *ptr;\n+  if (pthread_getspecific (key, &ptr) == 0)\n+    return ptr;\n+  else\n+    return 0;\n+}\n+\n+static inline int\n+__gthread_setspecific (__gthread_key_t key, const void *ptr)\n+{\n+  return pthread_setspecific (key, (void *) ptr);\n+}\n+\n+static inline int\n+__gthread_mutex_lock (__gthread_mutex_t *mutex)\n+{\n+  return pthread_mutex_lock (mutex);\n+}\n+\n+static inline int\n+__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n+{\n+  return pthread_mutex_trylock (mutex);\n+}\n+\n+static inline int\n+__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n+{\n+  return pthread_mutex_unlock (mutex);\n+}\n+\n+#elif _SOLARIS_THREADS\n+/* Solaris threads as found in Solaris 2.[456].\n+   Actually these are Unix International (UI) threads, but I don't\n+   know if anyone else implements these. */\n+\n+#define __GTHREADS 1\n+\n+#include <thread.h>\n+#include <errno.h>\n+\n+typedef thread_key_t __gthread_key_t;\n+typedef struct\n+{\n+  mutex_t mutex;\n+  int once;\n+} __gthread_once_t;\n+typedef mutex_t __gthread_mutex_t;\n+\n+#define __GTHREAD_ONCE_INIT { DEFAULTMUTEX, 0 }\n+#define __GTHREAD_MUTEX_INIT DEFAULTMUTEX\n+\n+static inline int\n+__gthread_once (__gthread_once_t *once, void (*func) ())\n+{\n+  if (once == 0 || func == 0)\n+    {\n+      errno = EINVAL;\n+      return -1;\n+    }\n+\n+  if (once->once == 0)\n+    {\n+      if (mutex_lock (&once->mutex) != 0)\n+\treturn -1;\n+      if (once->once == 0)\n+\t{\n+\t  (*func) ();\n+\t  once->once ++;\n+\t}\n+      mutex_unlock (&once->mutex);\n+    }\n+  return 0;\n+}\n+\n+static inline int\n+__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n+{\n+  return thr_keycreate (key, dtor);\n+}\n+\n+static inline int\n+__gthread_key_delete (__gthread_key_t key)\n+{\n+  /* Not possible. */\n+  return -1;\n+}\n+\n+static inline void *\n+__gthread_getspecific (__gthread_key_t key)\n+{\n+  void *ptr;\n+  if (thr_getspecific (key, &ptr) == 0)\n+    return ptr;\n+  else\n+    return 0;\n+}\n+\n+static inline int\n+__gthread_setspecific (__gthread_key_t key, const void *ptr)\n+{\n+  return thr_setspecific (key, (void *) ptr);\n+}\n+\n+static inline int\n+__gthread_mutex_lock (__gthread_mutex_t *mutex)\n+{\n+  return mutex_lock (mutex);\n+}\n+\n+static inline int\n+__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n+{\n+  return mutex_trylock (mutex);\n+}\n+\n+static inline int\n+__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n+{\n+  return mutex_unlock (mutex);\n+}\n+\n+#else /* no threads */\n+\n+/* Just provide compatibility for mutex handling. */\n+\n+typedef int __gthread_mutex_t;\n+\n+#define __GTHREAD_MUTEX_INIT 0\n+\n+static inline int\n+__gthread_mutex_lock (__gthread_mutex_t *mutex)\n+{\n+  return 0;\n+}\n+\n+static inline int\n+__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n+{\n+  return 0;\n+}\n+\n+static inline int\n+__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n+{\n+  return 0;\n+}\n+\n+#endif /* no threads */\n+\n+#endif /* not __libgcc_thr_h */"}]}