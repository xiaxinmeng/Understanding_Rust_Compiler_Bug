{"sha": "77aff459558ec67ceafc407420e014433828f7a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzdhZmY0NTk1NThlYzY3Y2VhZmM0MDc0MjBlMDE0NDMzODI4ZjdhNQ==", "commit": {"author": {"name": "Mumit Khan", "email": "khan@xraylith.wisc.edu", "date": "1998-01-17T21:30:39Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-01-17T21:30:39Z"}, "message": "Add mingw32 support.\n\n        * pexecute.c (pexecute): New function for mingw32. Supports pipes.\n        (pwait): New function for mingw32.\n        * config.table (i[3456]86-*-mingw32*): Support for i386-mingw32.\n        * config/mt-mingw32: New file.\n        * xmalloc.c (first_break): Not used for mingw32.\n        (xmalloc_set_program_name): Don't use sbrk on mingw32.\n        (xmalloc): Likewise.\n        (xrealloc): Likewise.\n\nCo-Authored-By: J.J. VanderHeijden <J.J.vanderHeijden@student.utwente.nl>\n\nFrom-SVN: r17395", "tree": {"sha": "3fb1bcc713bf0b50a9443986aa474ff823b51ca8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fb1bcc713bf0b50a9443986aa474ff823b51ca8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77aff459558ec67ceafc407420e014433828f7a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77aff459558ec67ceafc407420e014433828f7a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77aff459558ec67ceafc407420e014433828f7a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77aff459558ec67ceafc407420e014433828f7a5/comments", "author": null, "committer": null, "parents": [{"sha": "84f79fea91fa299022c62cd3e7a9b42910d974b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84f79fea91fa299022c62cd3e7a9b42910d974b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84f79fea91fa299022c62cd3e7a9b42910d974b2"}], "stats": {"total": 219, "additions": 211, "deletions": 8}, "files": [{"sha": "567f53461ac6203e2edc592cde921d01a907f44b", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77aff459558ec67ceafc407420e014433828f7a5/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77aff459558ec67ceafc407420e014433828f7a5/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=77aff459558ec67ceafc407420e014433828f7a5", "patch": "@@ -1,3 +1,17 @@\n+Sat Jan 17 22:32:38 1998  Mumit Khan  <khan@xraylith.wisc.edu>\n+                          J.J. VanderHeijden <J.J.vanderHeijden@student.utwente.nl>\n+\n+        Add mingw32 support.\n+        * pexecute.c (pexecute): New function for mingw32. Supports pipes.\n+        (pwait): New function for mingw32.\n+\n+        * config.table (i[3456]86-*-mingw32*): Support for i386-mingw32.\n+        * config/mt-mingw32: New file.\n+        * xmalloc.c (first_break): Not used for mingw32.\n+        (xmalloc_set_program_name): Don't use sbrk on mingw32.\n+        (xmalloc): Likewise.\n+        (xrealloc): Likewise.\n+\n Sat Jan 17 22:25:53 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* choose-temp.c: Sync with gcc version."}, {"sha": "555dfac68a9ccb70f956db3d6bbc118512cb7d4d", "filename": "libiberty/config.table", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77aff459558ec67ceafc407420e014433828f7a5/libiberty%2Fconfig.table", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77aff459558ec67ceafc407420e014433828f7a5/libiberty%2Fconfig.table", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfig.table?ref=77aff459558ec67ceafc407420e014433828f7a5", "patch": "@@ -29,6 +29,13 @@ case \"${host}\" in\n     # autoconfiguration scheme does not work.\n     frag=mt-vxworks5\n     ;;\n+\n+  i[3456]86-*-mingw32*)\n+    # Mingw32 does not require strerror.o from REQUIRED_OFILES.\n+    # Worse: it will not compile it because of an incompatible sys_errlist\n+    # definition.\n+    frag=mt-mingw32\n+    ;;\n esac\n \n # Try to handle funky case of solaris 2 -> sun 4."}, {"sha": "2fb17d783d0380922d8e859783923d0cace273e5", "filename": "libiberty/config/mt-mingw32", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77aff459558ec67ceafc407420e014433828f7a5/libiberty%2Fconfig%2Fmt-mingw32", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77aff459558ec67ceafc407420e014433828f7a5/libiberty%2Fconfig%2Fmt-mingw32", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfig%2Fmt-mingw32?ref=77aff459558ec67ceafc407420e014433828f7a5", "patch": "@@ -0,0 +1,27 @@\n+# Mingw32 target Makefile fragment.\n+# The autoconfiguration fails for a Mingw32 target, because of an\n+# incompatible definition of sys_errlist, which is imported from a DLL.\n+# Therefore, we compute the dependencies by hand.\n+\n+HDEFINES = -DNO_SYS_PARAM_H -DNO_SYS_FILE_H\n+CONFIG_H = mgconfig.h\n+NEEDED_LIST = mgneeded-list\n+\n+mgconfig.h: Makefile\n+\tif [ -f ../newlib/Makefile ]; then \\\n+\t  $(MAKE) $(FLAGS_TO_PASS) xconfig.h; \\\n+\t  cp xconfig.h mgconfig.h; \\\n+\telse \\\n+\t  echo \"#define NEED_sys_siglist 1\" >>mgconfig.h; \\\n+\t  echo \"#define NEED_strsignal 1\" >>mgconfig.h; \\\n+\t  echo \"#define NEED_psignal 1\" >>mgconfig.h; \\\n+\t  echo \"#define NEED_basename 1\" >>mgconfig.h; \\\n+\tfi\n+\n+mgneeded-list: Makefile\n+\tif [ -f ../newlib/Makefile ]; then \\\n+\t  $(MAKE) $(FLAGS_TO_PASS) xneeded-list; \\\n+\t  cp xneeded-list mgneeded-list; \\\n+\telse \\\n+\t  echo getopt.o vasprintf.o >mgneeded-list; \\\n+\tfi"}, {"sha": "fbbea409147cb386d0cbabcbbd6370c5e4a5e101", "filename": "libiberty/pexecute.c", "status": "modified", "additions": 142, "deletions": 7, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77aff459558ec67ceafc407420e014433828f7a5/libiberty%2Fpexecute.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77aff459558ec67ceafc407420e014433828f7a5/libiberty%2Fpexecute.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpexecute.c?ref=77aff459558ec67ceafc407420e014433828f7a5", "patch": "@@ -223,14 +223,50 @@ pwait (pid, status, flags)\n #if defined (_WIN32)\n \n #include <process.h>\n-extern int _spawnv ();\n-extern int _spawnvp ();\n \n #ifdef __CYGWIN32__\n \n #define fix_argv(argvec) (argvec)\n \n-#else\n+extern int _spawnv ();\n+extern int _spawnvp ();\n+\n+int\n+pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n+     const char *program;\n+     char * const *argv;\n+     const char *this_pname;\n+     const char *temp_base;\n+     char **errmsg_fmt, **errmsg_arg;\n+     int flags;\n+{\n+  int pid;\n+\n+  if ((flags & PEXECUTE_ONE) != PEXECUTE_ONE)\n+    abort ();\n+  pid = (flags & PEXECUTE_SEARCH ? _spawnvp : _spawnv)\n+    (_P_NOWAIT, program, fix_argv(argv));\n+  if (pid == -1)\n+    {\n+      *errmsg_fmt = install_error_msg;\n+      *errmsg_arg = program;\n+      return -1;\n+    }\n+  return pid;\n+}\n+\n+int\n+pwait (pid, status, flags)\n+     int pid;\n+     int *status;\n+     int flags;\n+{\n+  /* ??? Here's an opportunity to canonicalize the values in STATUS.\n+     Needed?  */\n+  return cwait (status, pid, WAIT_CHILD);\n+}\n+\n+#else /* ! __CYGWIN32__ */\n \n /* This is a kludge to get around the Microsoft C spawn functions' propensity\n    to remove the outermost set of double quotes from all arguments.  */\n@@ -269,8 +305,24 @@ fix_argv (argvec)\n   return (const char * const *) argvec;\n }\n \n-#endif /* ! defined (__CYGWIN32__) */\n+#include <io.h>\n+#include <fcntl.h>\n+#include <signal.h>\n+\n+/* mingw32 headers may not define the following.  */\n+\n+#ifndef _P_WAIT\n+#  define _P_WAIT\t0\n+#  define _P_NOWAIT\t1\n+#  define _P_OVERLAY\t2\n+#  define _P_NOWAITO\t3\n+#  define _P_DETACH\t4\n+\n+#  define WAIT_CHILD\t0\n+#  define WAIT_GRANDCHILD\t1\n+#endif\n \n+/* Win32 supports pipes */\n int\n pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n      const char *program;\n@@ -281,31 +333,114 @@ pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n      int flags;\n {\n   int pid;\n+  int pdes[2], org_stdin, org_stdout;\n+  int input_desc, output_desc;\n+  int retries, sleep_interval;\n+\n+  /* Pipe waiting from last process, to be used as input for the next one.\n+     Value is STDIN_FILE_NO if no pipe is waiting\n+     (i.e. the next command is the first of a group).  */\n+  static int last_pipe_input;\n+\n+  /* If this is the first process, initialize.  */\n+  if (flags & PEXECUTE_FIRST)\n+    last_pipe_input = STDIN_FILE_NO;\n+\n+  input_desc = last_pipe_input;\n+\n+  /* If this isn't the last process, make a pipe for its output,\n+     and record it as waiting to be the input to the next process.  */\n+  if (! (flags & PEXECUTE_LAST))\n+    {\n+      if (_pipe (pdes, 256, O_BINARY) < 0)\n+\t{\n+\t  *errmsg_fmt = \"pipe\";\n+\t  *errmsg_arg = NULL;\n+\t  return -1;\n+\t}\n+      output_desc = pdes[WRITE_PORT];\n+      last_pipe_input = pdes[READ_PORT];\n+    }\n+  else\n+    {\n+      /* Last process.  */\n+      output_desc = STDOUT_FILE_NO;\n+      last_pipe_input = STDIN_FILE_NO;\n+    }\n+\n+  if (input_desc != STDIN_FILE_NO)\n+    {\n+      org_stdin = dup (STDIN_FILE_NO);\n+      dup2 (input_desc, STDIN_FILE_NO);\n+      close (input_desc); \n+    }\n+\n+  if (output_desc != STDOUT_FILE_NO)\n+    {\n+      org_stdout = dup (STDOUT_FILE_NO);\n+      dup2 (output_desc, STDOUT_FILE_NO);\n+      close (output_desc);\n+    }\n \n-  if ((flags & PEXECUTE_ONE) != PEXECUTE_ONE)\n-    abort ();\n   pid = (flags & PEXECUTE_SEARCH ? _spawnvp : _spawnv)\n     (_P_NOWAIT, program, fix_argv(argv));\n+\n+  if (input_desc != STDIN_FILE_NO)\n+    {\n+      dup2 (org_stdin, STDIN_FILE_NO);\n+      close (org_stdin);\n+    }\n+\n+  if (output_desc != STDOUT_FILE_NO)\n+    {\n+      dup2 (org_stdout, STDOUT_FILE_NO);\n+      close (org_stdout);\n+    }\n+\n   if (pid == -1)\n     {\n       *errmsg_fmt = install_error_msg;\n       *errmsg_arg = program;\n       return -1;\n     }\n+\n   return pid;\n }\n \n+/* MS CRTDLL doesn't return enough information in status to decide if the\n+   child exited due to a signal or not, rather it simply returns an\n+   integer with the exit code of the child; eg., if the child exited with \n+   an abort() call and didn't have a handler for SIGABRT, it simply returns\n+   with status = 3. We fix the status code to conform to the usual WIF*\n+   macros. Note that WIFSIGNALED will never be true under CRTDLL. */\n+\n int\n pwait (pid, status, flags)\n      int pid;\n      int *status;\n      int flags;\n {\n+  int termstat;\n+\n+  pid = _cwait (&termstat, pid, WAIT_CHILD);\n+\n   /* ??? Here's an opportunity to canonicalize the values in STATUS.\n      Needed?  */\n-  return _cwait (status, pid, WAIT_CHILD);\n+\n+  /* cwait returns the child process exit code in termstat.\n+     A value of 3 indicates that the child caught a signal, but not\n+     which one.  Since only SIGABRT, SIGFPE and SIGINT do anything, we\n+     report SIGABRT.  */\n+  if (termstat == 3)\n+    *status = SIGABRT;\n+  else\n+    *status = (((termstat) & 0xff) << 8);\n+\n+  return pid;\n }\n \n+#endif /* ! defined (__CYGWIN32__) */\n+\n #endif /* _WIN32 */\n \n #ifdef OS2"}, {"sha": "b88105a9b74a069958a5e6b3c4187ac8bf244963", "filename": "libiberty/xmalloc.c", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77aff459558ec67ceafc407420e014433828f7a5/libiberty%2Fxmalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77aff459558ec67ceafc407420e014433828f7a5/libiberty%2Fxmalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fxmalloc.c?ref=77aff459558ec67ceafc407420e014433828f7a5", "patch": "@@ -42,16 +42,22 @@ PTR sbrk PARAMS ((ptrdiff_t));\n /* The program name if set.  */\n static const char *name = \"\";\n \n-/* The initial sbrk, set when the program name is set.  */\n+#if ! defined (_WIN32) || defined (__CYGWIN32__)\n+/* The initial sbrk, set when the program name is set. Not used for win32\n+   ports other than cygwin32.  */\n static char *first_break = NULL;\n+#endif\n \n void\n xmalloc_set_program_name (s)\n      const char *s;\n {\n   name = s;\n+#if ! defined (_WIN32) || defined (__CYGWIN32__)\n+  /* Win32 ports other than cygwin32 don't have brk() */\n   if (first_break == NULL)\n     first_break = (char *) sbrk (0);\n+#endif /* ! _WIN32 || __CYGWIN32 __ */\n }\n \n PTR\n@@ -65,6 +71,7 @@ xmalloc (size)\n   newmem = malloc (size);\n   if (!newmem)\n     {\n+#if ! defined (_WIN32) || defined (__CYGWIN32__)\n       extern char **environ;\n       size_t allocated;\n \n@@ -76,6 +83,12 @@ xmalloc (size)\n \t       \"\\n%s%sCan not allocate %lu bytes after allocating %lu bytes\\n\",\n \t       name, *name ? \": \" : \"\",\n \t       (unsigned long) size, (unsigned long) allocated);\n+#else\n+      fprintf (stderr,\n+              \"\\n%s%sCan not allocate %lu bytes\\n\",\n+              name, *name ? \": \" : \"\",\n+              (unsigned long) size);\n+#endif /* ! _WIN32 || __CYGWIN32 __ */\n       xexit (1);\n     }\n   return (newmem);\n@@ -96,6 +109,7 @@ xrealloc (oldmem, size)\n     newmem = realloc (oldmem, size);\n   if (!newmem)\n     {\n+#ifndef __MINGW32__\n       extern char **environ;\n       size_t allocated;\n \n@@ -107,6 +121,12 @@ xrealloc (oldmem, size)\n \t       \"\\n%s%sCan not reallocate %lu bytes after allocating %lu bytes\\n\",\n \t       name, *name ? \": \" : \"\",\n \t       (unsigned long) size, (unsigned long) allocated);\n+#else\n+      fprintf (stderr,\n+              \"\\n%s%sCan not reallocate %lu bytes\\n\",\n+              name, *name ? \": \" : \"\",\n+              (unsigned long) size);\n+#endif /* __MINGW32__ */\n       xexit (1);\n     }\n   return (newmem);"}]}