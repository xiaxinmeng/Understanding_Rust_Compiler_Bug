{"sha": "b372168cef8e4b8707cc5b1ed6fecb2a36ccc264", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM3MjE2OGNlZjhlNGI4NzA3Y2M1YjFlZDZmZWNiMmEzNmNjYzI2NA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-03-20T22:24:48Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-03-20T22:24:48Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r540", "tree": {"sha": "5e8f2cf10d159af0ad19d49c1fec8402ba0db59d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e8f2cf10d159af0ad19d49c1fec8402ba0db59d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b372168cef8e4b8707cc5b1ed6fecb2a36ccc264", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b372168cef8e4b8707cc5b1ed6fecb2a36ccc264", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b372168cef8e4b8707cc5b1ed6fecb2a36ccc264", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b372168cef8e4b8707cc5b1ed6fecb2a36ccc264/comments", "author": null, "committer": null, "parents": [{"sha": "2e494f7040442b498ff3089c8ae76171d966d578", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e494f7040442b498ff3089c8ae76171d966d578", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e494f7040442b498ff3089c8ae76171d966d578"}], "stats": {"total": 193, "additions": 99, "deletions": 94}, "files": [{"sha": "44e55b222cccd3ec14229e56f1e8d34819955987", "filename": "gcc/dbxout.c", "status": "modified", "additions": 99, "deletions": 94, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b372168cef8e4b8707cc5b1ed6fecb2a36ccc264/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b372168cef8e4b8707cc5b1ed6fecb2a36ccc264/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=b372168cef8e4b8707cc5b1ed6fecb2a36ccc264", "patch": "@@ -68,7 +68,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n /* Include these first, because they may define MIN and MAX.  */\n #include <stdio.h>\n-#include <sys/param.h>\n #include <errno.h>\n \n #include \"config.h\"\n@@ -83,6 +82,10 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n extern int errno;\n #endif\n \n+#ifdef XCOFF_DEBUGGING_INFO\n+#include \"xcoff.h\"\n+#endif\n+\n #ifndef ASM_STABS_OP\n #define ASM_STABS_OP \".stabs\"\n #endif\n@@ -91,6 +94,22 @@ extern int errno;\n #define ASM_STABN_OP \".stabn\"\n #endif\n \n+#ifndef DBX_DECL_STABS_CODE\n+#define DBX_DECL_STABS_CODE N_LSYM\n+#endif\n+\n+#ifndef DBX_STATIC_CONST_VAR_CODE\n+#define DBX_STATIC_CONST_VAR_CODE N_FUN\n+#endif\n+\n+#ifndef DBX_REGPARM_STABS_CODE\n+#define DBX_REGPARM_STABS_CODE N_RSYM\n+#endif\n+\n+#ifndef DBX_REGPARM_STABS_LETTER\n+#define DBX_REGPARM_STABS_LETTER 'P'\n+#endif\n+\n /* Nonzero means if the type has methods, only output debugging\n    information if methods are actually written to the asm file.  */\n \n@@ -103,32 +122,20 @@ static int flag_minimal_debug = 1;\n \n static int have_used_extensions = 0;\n \n-/* Virtually every UN*X system now in common use (except for pre-4.3-tahoe\n-   BSD systems) now provides getcwd as called for by POSIX.  Allow for\n-   the few exceptions to the general rule here.  */\n-\n-#if !(defined (USG) || defined (VMS))\n-extern char *getwd ();\n-#define getcwd(buf,len) getwd(buf)\n-#define GUESSPATHLEN (MAXPATHLEN + 1)\n-#else /* (defined (USG) || defined (VMS)) */\n-extern char *getcwd ();\n-/* We actually use this as a starting point, not a limit.  */\n-#define GUESSPATHLEN 100\n-#endif /* (defined (USG) || defined (VMS)) */\n+char *getpwd ();\n \n /* Typical USG systems don't have stab.h, and they also have\n    no use for DBX-format debugging info.  */\n \n-#ifdef DBX_DEBUGGING_INFO\n+#if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n \n #ifdef DEBUG_SYMS_TEXT\n #define FORCE_TEXT text_section ();\n #else\n #define FORCE_TEXT\n #endif\n \n-#ifdef USG\n+#if defined (USG) || defined (MIPS)\n #include \"gstab.h\"  /* If doing DBX on sysV, use our own stab.h.  */\n #else\n #include <stab.h>  /* On BSD, use the system's stab.h.  */\n@@ -174,7 +181,6 @@ static char *lastfile;\n /* Current working directory.  */\n \n static char *cwd;\n-static enum {not_gotten, gotten, error_getting} cwd_status = not_gotten;\n \n enum typestatus {TYPE_UNSEEN, TYPE_XREF, TYPE_DEFINED};\n \n@@ -280,7 +286,7 @@ abspath (rel_filename)\n   char *outp, *inp;\n   char *value;\n \n-  /* Copy the  filename (possibly preceeded by the current working\n+  /* Copy the filename (possibly preceded by the current working\n      directory name) into the absolutization buffer.  */\n \n   {\n@@ -298,7 +304,6 @@ abspath (rel_filename)\n       continue;\n     if (endp[-1] == '/')\n       *endp = '\\0';\n-  }\n \n   /* Now make a copy of abs_buffer into abs_buffer, shortening the\n      filename (by taking out slashes and dots) as we go.  */\n@@ -385,41 +390,21 @@ dbxout_init (asm_file, input_file_name, syms)\n   ASM_GENERATE_INTERNAL_LABEL (ltext_label_name, \"Ltext\", 0);\n \n   /* Put the current working directory in an N_SO symbol.  */\n-  {\n-    int size;\n-\n-    if (cwd_status == not_gotten)\n-      {\n-\tchar *value;\n-\n-\t/* Read the working directory, avoiding arbitrary limit.  */\n-\tsize = GUESSPATHLEN;\n-\twhile (1)\n-\t  {\n-\t    cwd = (char *) xmalloc (size);\n-\t    value = getcwd (cwd, size);\n-\t    if (value != 0 || errno != ERANGE)\n-\t      break;\n-\t    free (cwd);\n-\t    size *= 2;\n-\t  }\n-\n-\tif (value != 0)\n-\t  cwd_status = gotten;\n-\telse\n-\t  cwd_status = error_getting;\n-      }\n-\n-    if (cwd_status == gotten)\n-      {\n+#ifndef DBX_WORKING_DIRECTORY /* Only some versions of DBX want this,\n+\t\t\t\t but GDB always does.  */\n+  if (use_gdb_dbx_extensions)\n+#endif\n+    {\n+      if (cwd || (cwd = getpwd ()))\n+\t{\n #ifdef DBX_OUTPUT_MAIN_SOURCE_DIRECTORY\n-\tDBX_OUTPUT_MAIN_SOURCE_DIRECTORY (asmfile, cwd);\n+\t  DBX_OUTPUT_MAIN_SOURCE_DIRECTORY (asmfile, cwd);\n #else /* no DBX_OUTPUT_MAIN_SOURCE_DIRECTORY */\n-\tfprintf (asmfile, \"%s \\\"%s/\\\",%d,0,0,%s\\n\", ASM_STABS_OP,\n-\t\t cwd, N_SO, &ltext_label_name[1]);\n+\t  fprintf (asmfile, \"%s \\\"%s/\\\",%d,0,0,%s\\n\", ASM_STABS_OP,\n+\t\t   cwd, N_SO, &ltext_label_name[1]);\n #endif /* no DBX_OUTPUT_MAIN_SOURCE_DIRECTORY */\n-      }\n-  }\n+\t}\n+    }\n \n #ifdef DBX_OUTPUT_MAIN_SOURCE_FILENAME\n   /* This should NOT be DBX_OUTPUT_SOURCE_FILENAME. That\n@@ -879,6 +864,11 @@ dbxout_type (type, full)\n   fprintf (asmfile, \"%d\", TYPE_SYMTAB_ADDRESS (type));\n   CHARS (3);\n \n+#ifdef DBX_TYPE_DEFINED\n+  if (DBX_TYPE_DEFINED (type))\n+    return;\n+#endif\n+\n   /* If this type's definition has been output or is now being output,\n      that is all.  */\n \n@@ -996,7 +986,10 @@ dbxout_type (type, full)\n \t  n_baseclasses = TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (type));\n \n \t/* Output a structure type.  */\n-\tif ((TYPE_NAME (type) != 0 && !full)\n+\tif ((TYPE_NAME (type) != 0\n+\t     && ! (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+\t\t   && DECL_IGNORED_P (TYPE_NAME (type)))\n+\t     && !full)\n \t    || TYPE_SIZE (type) == 0)\n \t  {\n \t    /* If the type is just a cross reference, output one\n@@ -1076,7 +1069,7 @@ dbxout_type (type, full)\n \n       /* Write out the field declarations.  */\n       dbxout_type_fields (type);\n-      if (use_gdb_dbx_extensions)\n+      if (use_gdb_dbx_extensions && TYPE_METHODS (type) != NULL_TREE)\n \t{\n \t  have_used_extensions = 1;\n \t  dbxout_type_methods (type);\n@@ -1384,12 +1377,12 @@ dbxout_symbol (decl, local)\n \t      && (TREE_CODE (type) == RECORD_TYPE\n \t\t  || TREE_CODE (type) == UNION_TYPE)\n \t      && (TYPE_NAME (type) == decl))\n-\t\t{\n-\t\t  putc ('T', asmfile);\n-\t\t  TREE_ASM_WRITTEN (TYPE_NAME (type)) = 1;\n-\t        }\n+\t    {\n+\t      putc ('T', asmfile);\n+\t      TREE_ASM_WRITTEN (TYPE_NAME (type)) = 1;\n+\t    }\n \t  putc ('t', asmfile);\n-\t  current_sym_code = N_LSYM;\n+\t  current_sym_code = DBX_DECL_STABS_CODE;\n \n \t  dbxout_type (type, 1);\n \t  dbxout_finish_symbol (decl);\n@@ -1404,7 +1397,7 @@ dbxout_symbol (decl, local)\n \t  if (TREE_CODE (name) == TYPE_DECL)\n \t    name = DECL_NAME (name);\n \n-\t  current_sym_code = N_LSYM;\n+\t  current_sym_code = DBX_DECL_STABS_CODE;\n \t  current_sym_value = 0;\n \t  current_sym_addr = 0;\n \t  current_sym_nchars = 2 + IDENTIFIER_LENGTH (name);\n@@ -1538,7 +1531,7 @@ dbxout_symbol (decl, local)\n \t      else if (TREE_READONLY (decl) && ! TREE_THIS_VOLATILE (decl))\n \t\t/* This is not quite right, but it's the closest\n \t\t   of all the codes that Unix defines.  */\n-\t\tcurrent_sym_code = N_FUN;\n+\t\tcurrent_sym_code = DBX_STATIC_CONST_VAR_CODE;\n \t      else\n \t\t{\n /* Ultrix `as' seems to need this.  */\n@@ -1616,6 +1609,24 @@ dbxout_symbol (decl, local)\n \t     We want the value of that CONST_INT.  */\n \t  current_sym_value = DEBUGGER_AUTO_OFFSET (XEXP (DECL_RTL (decl), 0));\n \t}\n+      else if (GET_CODE (DECL_RTL (decl)) == MEM\n+\t       && GET_CODE (XEXP (DECL_RTL (decl), 0)) == CONST)\n+\t{\n+\t  /* Handle an obscure case which can arise when optimizing and\n+\t     when there are few available registers.  (This is *always*\n+\t     the case for i386/i486 targets).  The DECL_RTL looks like\n+\t     (MEM (CONST ...)) even though this variable is a local `auto'\n+\t     or a local `register' variable.  In effect, what has happened\n+\t     is that the reload pass has seen that all assignments and\n+\t     references for one such a local variable can be replaced by\n+\t     equivalent assignments and references to some static storage\n+\t     variable, thereby avoiding the need for a register.  In such\n+\t     cases we're forced to lie to debuggers and tell them that\n+\t     this variable was itself `static'.  */\n+\t  current_sym_code = N_LCSYM;\n+\t  letter = 'V';\n+\t  current_sym_addr = XEXP (XEXP (DECL_RTL (decl), 0), 0);\n+\t}\n       else\n \t/* Address might be a MEM, when DECL is a variable-sized object.\n \t   Or it might be const0_rtx, meaning previous passes\n@@ -1624,6 +1635,11 @@ dbxout_symbol (decl, local)\n \n       /* Ok, start a symtab entry and output the variable name.  */\n       FORCE_TEXT;\n+\n+#ifdef DBX_STATIC_BLOCK_START\n+      DBX_STATIC_BLOCK_START (asmfile, current_sym_code);\n+#endif\n+\n       /* One slight hitch: if this is a VAR_DECL which is a static\n \t class member, we must put out the mangled name instead of the\n \t DECL_NAME.  */\n@@ -1635,10 +1651,12 @@ dbxout_symbol (decl, local)\n \t  {\n \t    name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n \n+#if 0 /* Tiemann says get rid of this.  */\n \t    /* Adding 1 here only works on systems\n \t       which flush an initial underscore.  */\n \t    if (name[0] == '_')\n \t      name += 1;\n+#endif\n \t  }\n \telse\n \t  name = IDENTIFIER_POINTER (DECL_NAME (decl));\n@@ -1647,6 +1665,10 @@ dbxout_symbol (decl, local)\n       if (letter) putc (letter, asmfile);\n       dbxout_type (type, 0);\n       dbxout_finish_symbol (decl);\n+\n+#ifdef DBX_STATIC_BLOCK_END\n+      DBX_STATIC_BLOCK_END (asmfile, current_sym_code);\n+#endif\n       break;\n     }\n }\n@@ -1666,22 +1688,27 @@ static void\n dbxout_finish_symbol (sym)\n      tree sym;\n {\n+#ifdef DBX_FINISH_SYMBOL\n+  DBX_FINISH_SYMBOL (sym);\n+#else\n   int line = 0;\n #ifdef WINNING_GDB\n   if (sym != 0)\n     line = DECL_SOURCE_LINE (sym);\n #endif\n+\n   fprintf (asmfile, \"\\\",%d,0,%d,\", current_sym_code, line);\n   if (current_sym_addr)\n     output_addr_const (asmfile, current_sym_addr);\n   else\n     fprintf (asmfile, \"%d\", current_sym_value);\n   putc ('\\n', asmfile);\n+#endif\n }\n \n /* Output definitions of all the decls in a chain.  */\n \n-static void\n+void\n dbxout_syms (syms)\n      tree syms;\n {\n@@ -1704,7 +1731,7 @@ dbxout_syms (syms)\n /* Output definitions, referring to storage in the parmlist,\n    of all the parms in PARMS, which is a chain of PARM_DECL nodes.  */\n \n-static void\n+void\n dbxout_parms (parms)\n      tree parms;\n {\n@@ -1794,9 +1821,11 @@ dbxout_parms (parms)\n \telse if (GET_CODE (DECL_RTL (parms)) == REG)\n \t  {\n \t    rtx best_rtl;\n+\t    char regparm_letter;\n \t    /* Parm passed in registers and lives in registers or nowhere.  */\n \n-\t    current_sym_code = N_RSYM;\n+\t    current_sym_code = DBX_REGPARM_STABS_CODE;\n+\t    regparm_letter = DBX_REGPARM_STABS_LETTER;\n \t    current_sym_addr = 0;\n \n \t    /* If parm lives in a register, use that register;\n@@ -1816,13 +1845,15 @@ dbxout_parms (parms)\n \t    if (DECL_NAME (parms))\n \t      {\n \t\tcurrent_sym_nchars = 2 + IDENTIFIER_LENGTH (DECL_NAME (parms));\n-\t\tfprintf (asmfile, \"%s \\\"%s:P\", ASM_STABS_OP,\n-\t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)));\n+\t\tfprintf (asmfile, \"%s \\\"%s:%c\", ASM_STABS_OP,\n+\t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)),\n+\t\t\t regparm_letter);\n \t      }\n \t    else\n \t      {\n \t\tcurrent_sym_nchars = 8;\n-\t\tfprintf (asmfile, \"%s \\\"(anon):P\", ASM_STABS_OP);\n+\t\tfprintf (asmfile, \"%s \\\"(anon):%c\", ASM_STABS_OP,\n+\t\t\t regparm_letter);\n \t      }\n \n \t    dbxout_type (DECL_ARG_TYPE (parms), 0);\n@@ -1879,7 +1910,7 @@ dbxout_parms (parms)\n \n    PARMS is a chain of PARM_DECL nodes.  */\n \n-static void\n+void\n dbxout_reg_parms (parms)\n      tree parms;\n {\n@@ -2045,8 +2076,7 @@ dbxout_block (block, depth, args)\n #ifdef DBX_OUTPUT_CATCH\n \t\t      DBX_OUTPUT_CATCH (asmfile, decl, buf);\n #else\n-\t\t      fprintf (asmfile, \"%s \\\"%s:C1\\\",%d,0,0,\",\n-\t\t\t       ASM_STABS_OP,\n+\t\t      fprintf (asmfile, \"%s \\\"%s:C1\\\",%d,0,0,\", ASM_STABS_OP,\n \t\t\t       IDENTIFIER_POINTER (DECL_NAME (decl)), N_CATCH);\n \t\t      assemble_name (asmfile, buf);\n \t\t      fprintf (asmfile, \"\\n\");\n@@ -2132,29 +2162,4 @@ dbxout_function (decl)\n   DBX_OUTPUT_FUNCTION_END (asmfile, decl);\n #endif\n }\n-\f\n-#else /* not DBX_DEBUGGING_INFO */\n-\n-void\n-dbxout_init (asm_file, input_file_name)\n-     FILE *asm_file;\n-     char *input_file_name;\n-{}\n-\n-void\n-dbxout_symbol (decl, local)\n-     tree decl;\n-     int local;\n-{}\n-\n-void\n-dbxout_types (types)\n-     register tree types;\n-{}\n-\n-void\n-dbxout_function (decl)\n-     tree decl;\n-{}\n-\n #endif /* DBX_DEBUGGING_INFO */"}]}