{"sha": "dae22b53397e8fd26c4f059e25f1664a909eb7d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFlMjJiNTMzOTdlOGZkMjZjNGYwNTllMjVmMTY2NGE5MDllYjdkMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:14:59Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:14:59Z"}, "message": "s-taprop-vms.adb, [...] (Timed_Delay, [...]): Register the base time when entering this routine to detect a backward clock...\n\n2007-04-20  Arnaud Charlet  <charlet@adacore.com>\n\n\t* s-taprop-vms.adb, s-taprop-hpux-dce.adb, s-taprop-vxworks.adb, \n\ts-osprim-posix.adb, s-taprop-posix.adb, s-osprim-vxworks.adb, \n\ts-taprop-solaris.adb, s-osprim-solaris.adb, s-taprop-dummy.adb, \n\ts-osprim-unix.adb, s-osinte-freebsd.adb, s-osinte-freebsd.ads, \n\ts-osinte-lynxos.adb, s-osinte-lynxos.ads, s-taprop-tru64.adb, \n\ts-taprop-lynxos.adb, s-taprop-irix.adb, s-osinte-tru64.adb, \n\ts-osinte-tru64.ads, s-taprop-linux.adb, s-parame.ads, \n\ts-parame-vms-alpha.ads, s-parame-vms-ia64.ads, s-parame-hpux.ads, \n\ts-parame-vms-restrict.ads, s-parame-ae653.ads, s-parame-vxworks.ads, \n\ts-taprop-mingw.adb, s-osinte-lynxos-3.ads, s-osinte-lynxos-3.adb,\n        s-osprim-mingw.adb (Timed_Delay, Timed_Sleep): Register the base\n\ttime when entering this routine to detect a backward clock setting\n\t(manual setting or DST adjustment), to avoid waiting for a longer delay\n\tthan needed.\n\t(Time_Duration, To_Timeval, struct_timeval): Removed when not relevant.\n\tRemove handling of deferred priority change, and replace by setting the\n\ttask priority directly, as required by AI-188.\n\tUpdate comments.\n\t(Max_Task_Image_Length): New constant.\n\tReplace Warnings (Off) by Unreferenced pragma, cleaner.\n\t(Dynamic_Priority_Support): Removed, no longer needed.\n\t(Poll_Base_Priority_Change): Ditto.\n\t(Set_Ceiling): Add this procedure to change the ceiling priority\n\tassociated to a lock. This is a dummy implementation because dynamic\n\tpriority ceilings are not supported by the underlying system.\n\n\t* a-dynpri.adb (Set_Priority): Take into account case where Target is\n\taccepting a RV with its priority boosted.\n\tRemove handling of deferred priority change, and replace by setting the\n\ttask priority directly, as required by AI-188.\n\n\t* s-taenca.adb (Try_To_Cancel_Entry_Call): Remove special case for\n\tSucceeded = True.\n\tRemove handling of deferred priority change, and replace by setting the\n\ttask priority directly, as required by AI-188.\n\t(Wait_For_Completion, Wait_For_Call, Timed_Selective_Wait): Change state\n\tof Self_Id earlier.\n\n\t* s-tasini.ads, s-tasini.adb (Wakeup_Entry_Caller): Relax assertion.\n\t(Poll_Base_Priority_Change): Removed.\n\tCode clean up: use SSL.Current_Target_Exception.\n\n\t* s-tasren.adb (Task_Count): Call Yield to let a chance to other tasks\n\tto run as this is a potentially dispatching point.\n\t(Call_Synchronous): Use Local_Defer_Abort.\n\t(Callable): Relax assertion.\n\t(Selective_Wait): Relax assertion in case abort is not allowed.\n\tRemove handling of deferred priority change, and replace by setting the\n\ttask priority directly, as required by AI-188.\n\n\t* s-tasuti.adb (Make_Passive): Adjust assertions.\n\tRemove handling of deferred priority change, and replace by setting the\n\ttask priority directly, as required by AI-188.\n\nFrom-SVN: r125364", "tree": {"sha": "033a7e7bb81d1b4e3f0b917dd2668339fdc676b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/033a7e7bb81d1b4e3f0b917dd2668339fdc676b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dae22b53397e8fd26c4f059e25f1664a909eb7d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dae22b53397e8fd26c4f059e25f1664a909eb7d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dae22b53397e8fd26c4f059e25f1664a909eb7d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dae22b53397e8fd26c4f059e25f1664a909eb7d3/comments", "author": null, "committer": null, "parents": [{"sha": "984d7dd399e6f4c29e73dee445ef149e70245459", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/984d7dd399e6f4c29e73dee445ef149e70245459", "html_url": "https://github.com/Rust-GCC/gccrs/commit/984d7dd399e6f4c29e73dee445ef149e70245459"}], "stats": {"total": 2841, "additions": 1455, "deletions": 1386}, "files": [{"sha": "982c17f99b7cd064ff939c0a5b97440376f10b6a", "filename": "gcc/ada/a-dynpri.adb", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fa-dynpri.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fa-dynpri.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-dynpri.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -48,7 +48,7 @@ with System.Soft_Links;\n --  use for Abort_Defer\n --          Abort_Undefer\n \n-with Unchecked_Conversion;\n+with Ada.Unchecked_Conversion;\n \n package body Ada.Dynamic_Priorities is\n \n@@ -59,7 +59,7 @@ package body Ada.Dynamic_Priorities is\n    use System.Tasking;\n \n    function Convert_Ids is new\n-     Unchecked_Conversion\n+     Ada.Unchecked_Conversion\n        (Task_Identification.Task_Id, System.Tasking.Task_Id);\n \n    ------------------\n@@ -98,9 +98,9 @@ package body Ada.Dynamic_Priorities is\n       T        : Ada.Task_Identification.Task_Id :=\n                    Ada.Task_Identification.Current_Task)\n    is\n-      Target  : constant Task_Id := Convert_Ids (T);\n-      Self_ID : constant Task_Id := STPO.Self;\n+      Target        : constant Task_Id := Convert_Ids (T);\n       Error_Message : constant String := \"Trying to set the priority of a \";\n+      Yield_Needed  : Boolean;\n \n    begin\n       if Target = Convert_Ids (Ada.Task_Identification.Null_Task_Id) then\n@@ -119,41 +119,53 @@ package body Ada.Dynamic_Priorities is\n \n       STPO.Write_Lock (Target);\n \n-      if Self_ID = Target then\n-         Target.Common.Base_Priority := Priority;\n-         STPO.Set_Priority (Target, Priority);\n+      Target.Common.Base_Priority := Priority;\n+\n+      if Target.Common.Call /= null\n+        and then\n+          Target.Common.Call.Acceptor_Prev_Priority /= Priority_Not_Boosted\n+      then\n+         --  Target is within a rendezvous, so ensure the correct priority\n+         --  will be reset when finishing the rendezvous, and only change the\n+         --  priority immediately if the new priority is greater than the\n+         --  current (inherited) priority.\n \n-         STPO.Unlock (Target);\n+         Target.Common.Call.Acceptor_Prev_Priority := Priority;\n \n-         if Single_Lock then\n-            STPO.Unlock_RTS;\n+         if Priority >= Target.Common.Current_Priority then\n+            Yield_Needed := True;\n+            STPO.Set_Priority (Target, Priority);\n+         else\n+            Yield_Needed := False;\n          end if;\n \n-         --  Yield is needed to enforce FIFO task dispatching\n+      else\n+         Yield_Needed := True;\n+         STPO.Set_Priority (Target, Priority);\n \n-         --  LL Set_Priority is made while holding the RTS lock so that it\n-         --  is inheriting high priority until it release all the RTS locks.\n+         if Target.Common.State = Entry_Caller_Sleep then\n+            Target.Pending_Priority_Change := True;\n+            STPO.Wakeup (Target, Target.Common.State);\n+         end if;\n+      end if;\n \n-         --  If this is used in a system where Ceiling Locking is\n-         --  not enforced we may end up getting two Yield effects.\n+      STPO.Unlock (Target);\n \n-         STPO.Yield;\n+      if Single_Lock then\n+         STPO.Unlock_RTS;\n+      end if;\n \n-      else\n-         Target.New_Base_Priority := Priority;\n-         Target.Pending_Priority_Change := True;\n-         Target.Pending_Action := True;\n+      if STPO.Self = Target and then Yield_Needed then\n \n-         STPO.Wakeup (Target, Target.Common.State);\n+         --  Yield is needed to enforce FIFO task dispatching\n \n-         --  If the task is suspended, wake it up to perform the change.\n-         --  check for ceiling violations ???\n+         --  LL Set_Priority is made while holding the RTS lock so that it is\n+         --  inheriting high priority until it release all the RTS locks.\n \n-         STPO.Unlock (Target);\n+         --  If this is used in a system where Ceiling Locking is not enforced\n+         --  we may end up getting two Yield effects.\n \n-         if Single_Lock then\n-            STPO.Unlock_RTS;\n-         end if;\n+         STPO.Yield;\n       end if;\n \n       SSL.Abort_Undefer.all;"}, {"sha": "33daa45482a128a793e77428d2c575318977ec1f", "filename": "gcc/ada/s-osinte-freebsd.adb", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osinte-freebsd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osinte-freebsd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-freebsd.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                   B o d y                                --\n --                                                                          --\n---          Copyright (C) 1991-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1991-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -96,23 +96,4 @@ package body System.OS_Interface is\n         ts_nsec => long (Long_Long_Integer (F * 10#1#E9)));\n    end To_Timespec;\n \n-   function To_Duration (TV : struct_timeval) return Duration is\n-   begin\n-      return Duration (TV.tv_sec) + Duration (TV.tv_usec) / 10#1#E6;\n-   end To_Duration;\n-\n-   function To_Timeval (D : Duration) return struct_timeval is\n-      S : long;\n-      F : Duration;\n-   begin\n-      S := long (Long_Long_Integer (D));\n-      F := D - Duration (S);\n-\n-      --  If F has negative value due to a round-up, adjust for positive F\n-      --  value.\n-      if F < 0.0 then S := S - 1; F := F + 1.0; end if;\n-      return struct_timeval'(tv_sec => S,\n-        tv_usec => long (Long_Long_Integer (F * 10#1#E6)));\n-   end To_Timeval;\n-\n end System.OS_Interface;"}, {"sha": "8b3530c2b4965a53edf7151dd167890aab05a527", "filename": "gcc/ada/s-osinte-freebsd.ads", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osinte-freebsd.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osinte-freebsd.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-freebsd.ads?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -7,7 +7,7 @@\n --                                   S p e c                                --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2006, Free Software Foundation, Inc.      --\n+--             Copyright (C) 1995-2007, Free Software Foundation, Inc.      --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,7 +42,7 @@\n --  Preelaborate. This package is designed to be a bottom-level (leaf) package.\n \n with Interfaces.C;\n-with Unchecked_Conversion;\n+with Ada.Unchecked_Conversion;\n \n package System.OS_Interface is\n    pragma Preelaborate;\n@@ -221,20 +221,6 @@ package System.OS_Interface is\n       tz_dsttime     : int;\n    end record;\n    pragma Convention (C, struct_timezone);\n-   type struct_timeval is private;\n-   --  This is needed on systems that do not have clock_gettime()\n-   --  but do have gettimeofday().\n-\n-   function To_Duration (TV : struct_timeval) return Duration;\n-   pragma Inline (To_Duration);\n-\n-   function To_Timeval (D : Duration) return struct_timeval;\n-   pragma Inline (To_Timeval);\n-\n-   function gettimeofday\n-     (tv : access struct_timeval;\n-      tz : System.Address) return int;\n-   pragma Import (C, gettimeofday, \"gettimeofday\");\n \n    procedure usleep (useconds : unsigned_long);\n    pragma Import (C, usleep, \"usleep\");\n@@ -283,7 +269,7 @@ package System.OS_Interface is\n      function (arg : System.Address) return System.Address;\n \n    function Thread_Body_Access is new\n-     Unchecked_Conversion (System.Address, Thread_Body);\n+     Ada.Unchecked_Conversion (System.Address, Thread_Body);\n \n    type pthread_t           is private;\n    subtype Thread_Id        is pthread_t;\n@@ -635,12 +621,6 @@ private\n    type clockid_t is new int;\n    CLOCK_REALTIME : constant clockid_t := 0;\n \n-   type struct_timeval is record\n-      tv_sec  : long;\n-      tv_usec : long;\n-   end record;\n-   pragma Convention (C, struct_timeval);\n-\n    type pthread_t           is new System.Address;\n    type pthread_attr_t      is new System.Address;\n    type pthread_mutex_t     is new System.Address;"}, {"sha": "01524c89251be47383d2888683b4f7b8857a1de4", "filename": "gcc/ada/s-osinte-lynxos-3.adb", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osinte-lynxos-3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osinte-lynxos-3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-lynxos-3.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1999-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1999-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -73,11 +73,6 @@ package body System.OS_Interface is\n       return Duration (TS.tv_sec) + Duration (TS.tv_nsec) / 10#1#E9;\n    end To_Duration;\n \n-   function To_Duration (TV : struct_timeval) return Duration is\n-   begin\n-      return Duration (TV.tv_sec) + Duration (TV.tv_usec) / 10#1#E6;\n-   end To_Duration;\n-\n    ------------------------\n    -- To_Target_Priority --\n    ------------------------\n@@ -113,30 +108,6 @@ package body System.OS_Interface is\n         tv_nsec => long (Long_Long_Integer (F * 10#1#E9)));\n    end To_Timespec;\n \n-   ----------------\n-   -- To_Timeval --\n-   ----------------\n-\n-   function To_Timeval (D : Duration) return struct_timeval is\n-      S : time_t;\n-      F : Duration;\n-\n-   begin\n-      S := time_t (Long_Long_Integer (D));\n-      F := D - Duration (S);\n-\n-      --  If F has negative value due to a round-up, adjust for positive F\n-      --  value.\n-\n-      if F < 0.0 then\n-         S := S - 1;\n-         F := F + 1.0;\n-      end if;\n-\n-      return struct_timeval'(tv_sec => S,\n-        tv_usec => time_t (Long_Long_Integer (F * 10#1#E6)));\n-   end To_Timeval;\n-\n    -------------------------\n    -- POSIX.1c  Section 3 --\n    -------------------------"}, {"sha": "60fcd418a8932b54b703d3edc3d6b5f834557fdd", "filename": "gcc/ada/s-osinte-lynxos-3.ads", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osinte-lynxos-3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osinte-lynxos-3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-lynxos-3.ads?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -7,7 +7,7 @@\n --                                  S p e c                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---          Copyright (C) 1995-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1995-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -41,7 +41,7 @@\n --  Preelaborate. This package is designed to be a bottom-level (leaf) package.\n \n with Interfaces.C;\n-with Unchecked_Conversion;\n+with Ada.Unchecked_Conversion;\n \n package System.OS_Interface is\n    pragma Preelaborate;\n@@ -201,16 +201,6 @@ package System.OS_Interface is\n    pragma Convention (C, struct_timezone);\n    type struct_timezone_ptr is access all struct_timezone;\n \n-   type struct_timeval is private;\n-   --  This is needed on systems that do not have clock_gettime()\n-   --  but do have gettimeofday().\n-\n-   function To_Duration (TV : struct_timeval) return Duration;\n-   pragma Inline (To_Duration);\n-\n-   function To_Timeval (D : Duration) return struct_timeval;\n-   pragma Inline (To_Timeval);\n-\n    -------------------------\n    -- Priority Scheduling --\n    -------------------------\n@@ -253,7 +243,7 @@ package System.OS_Interface is\n      function (arg : System.Address) return System.Address;\n \n    function Thread_Body_Access is new\n-     Unchecked_Conversion (System.Address, Thread_Body);\n+     Ada.Unchecked_Conversion (System.Address, Thread_Body);\n \n    type pthread_t           is private;\n    subtype Thread_Id        is pthread_t;\n@@ -525,12 +515,6 @@ private\n    type clockid_t is new unsigned_char;\n    CLOCK_REALTIME : constant clockid_t := 0;\n \n-   type struct_timeval is record\n-      tv_sec  : time_t;\n-      tv_usec : time_t;\n-   end record;\n-   pragma Convention (C, struct_timeval);\n-\n    type st_t is record\n       stksize      : int;\n       prio         : int;"}, {"sha": "a0f48c033c66d6ce37bd97ba5222ed47e2ab6089", "filename": "gcc/ada/s-osinte-lynxos.adb", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osinte-lynxos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osinte-lynxos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-lynxos.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                     Copyright (C) 2001-2006, AdaCore                     --\n+--                     Copyright (C) 2001-2007, AdaCore                     --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -50,11 +50,6 @@ package body System.OS_Interface is\n       return Duration (TS.tv_sec) + Duration (TS.tv_nsec) / 10#1#E9;\n    end To_Duration;\n \n-   function To_Duration (TV : struct_timeval) return Duration is\n-   begin\n-      return Duration (TV.tv_sec) + Duration (TV.tv_usec) / 10#1#E6;\n-   end To_Duration;\n-\n    -----------------\n    -- To_Timespec --\n    -----------------\n@@ -79,32 +74,6 @@ package body System.OS_Interface is\n                        tv_nsec => long (Long_Long_Integer (F * 10#1#E9)));\n    end To_Timespec;\n \n-   ----------------\n-   -- To_Timeval --\n-   ----------------\n-\n-   function To_Timeval (D : Duration) return struct_timeval is\n-      S : time_t;\n-      F : Duration;\n-\n-   begin\n-      S := time_t (Long_Long_Integer (D));\n-      F := D - Duration (S);\n-\n-      --  If F has negative value due to a round-up, adjust for positive F\n-      --  value.\n-\n-      if F < 0.0 then\n-         S := S - 1;\n-         F := F + 1.0;\n-      end if;\n-\n-      return\n-        struct_timeval'\n-          (tv_sec => S,\n-           tv_usec => time_t (Long_Long_Integer (F * 10#1#E6)));\n-   end To_Timeval;\n-\n    -------------\n    -- sigwait --\n    -------------"}, {"sha": "d092586642b22f2402fab210f18893f3b759d415", "filename": "gcc/ada/s-osinte-lynxos.ads", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osinte-lynxos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osinte-lynxos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-lynxos.ads?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -7,7 +7,7 @@\n --                                  S p e c                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2006, Free Software Foundation, Inc.      --\n+--             Copyright (C) 1995-2007, Free Software Foundation, Inc.      --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -41,7 +41,7 @@\n --  Preelaborate. This package is designed to be a bottom-level (leaf) package.\n \n with Interfaces.C;\n-with Unchecked_Conversion;\n+with Ada.Unchecked_Conversion;\n \n package System.OS_Interface is\n    pragma Preelaborate;\n@@ -220,16 +220,6 @@ package System.OS_Interface is\n    pragma Convention (C, struct_timezone);\n    type struct_timezone_ptr is access all struct_timezone;\n \n-   type struct_timeval is private;\n-   --  This is needed on systems that do not have clock_gettime()\n-   --  but do have gettimeofday().\n-\n-   function To_Duration (TV : struct_timeval) return Duration;\n-   pragma Inline (To_Duration);\n-\n-   function To_Timeval (D : Duration) return struct_timeval;\n-   pragma Inline (To_Timeval);\n-\n    -------------------------\n    -- Priority Scheduling --\n    -------------------------\n@@ -265,7 +255,7 @@ package System.OS_Interface is\n      function (arg : System.Address) return System.Address;\n \n    function Thread_Body_Access is new\n-     Unchecked_Conversion (System.Address, Thread_Body);\n+     Ada.Unchecked_Conversion (System.Address, Thread_Body);\n \n    type pthread_t           is private;\n    subtype Thread_Id        is pthread_t;\n@@ -520,12 +510,6 @@ private\n    type clockid_t is new unsigned_char;\n    CLOCK_REALTIME : constant clockid_t := 0;\n \n-   type struct_timeval is record\n-      tv_sec  : time_t;\n-      tv_usec : time_t;\n-   end record;\n-   pragma Convention (C, struct_timeval);\n-\n    type st_attr_t is record\n       stksize      : int;\n       prio         : int;"}, {"sha": "3599c33495df7a8d0045f29cbdf560d84c899dff", "filename": "gcc/ada/s-osinte-tru64.adb", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osinte-tru64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osinte-tru64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-tru64.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1998-2006, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1998-2007, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -114,11 +114,6 @@ package body System.OS_Interface is\n       return Duration (TS.tv_sec) + Duration (TS.tv_nsec) / 10#1#E9;\n    end To_Duration;\n \n-   function To_Duration (TV : struct_timeval) return Duration is\n-   begin\n-      return Duration (TV.tv_sec) + Duration (TV.tv_usec) / 10#1#E6;\n-   end To_Duration;\n-\n    -----------------\n    -- To_Timespec --\n    -----------------\n@@ -143,30 +138,4 @@ package body System.OS_Interface is\n                        tv_nsec => long (Long_Long_Integer (F * 10#1#E9)));\n    end To_Timespec;\n \n-   ----------------\n-   -- To_Timeval --\n-   ----------------\n-\n-   function To_Timeval (D : Duration) return struct_timeval is\n-      S : time_t;\n-      F : Duration;\n-\n-   begin\n-      S := time_t (Long_Long_Integer (D));\n-      F := D - Duration (S);\n-\n-      --  If F has negative value due to a round-up, adjust for positive F\n-      --  value.\n-\n-      if F < 0.0 then\n-         S := S - 1;\n-         F := F + 1.0;\n-      end if;\n-\n-      return\n-        struct_timeval'\n-          (tv_sec => S,\n-           tv_usec => time_t (Long_Long_Integer (F * 10#1#E6)));\n-   end To_Timeval;\n-\n end System.OS_Interface;"}, {"sha": "5fe84b2e733ac0405999696a7ed9bd7ad6106eec", "filename": "gcc/ada/s-osinte-tru64.ads", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osinte-tru64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osinte-tru64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-tru64.ads?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -7,7 +7,7 @@\n --                                  S p e c                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2006, Free Software Foundation, Inc.      --\n+--             Copyright (C) 1995-2007, Free Software Foundation, Inc.      --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -41,7 +41,7 @@\n --  Preelaborate. This package is designed to be a bottom-level (leaf) package.\n \n with Interfaces.C;\n-with Unchecked_Conversion;\n+with Ada.Unchecked_Conversion;\n \n package System.OS_Interface is\n    pragma Preelaborate;\n@@ -211,15 +211,6 @@ package System.OS_Interface is\n       tz_dsttime     : int;\n    end record;\n    pragma Convention (C, struct_timezone);\n-   type struct_timeval is private;\n-   --  This is needed on systems that do not have clock_gettime()\n-   --  but do have gettimeofday().\n-\n-   function To_Duration (TV : struct_timeval) return Duration;\n-   pragma Inline (To_Duration);\n-\n-   function To_Timeval (D : Duration) return struct_timeval;\n-   pragma Inline (To_Timeval);\n \n    -------------------------\n    -- Priority Scheduling --\n@@ -258,7 +249,7 @@ package System.OS_Interface is\n      function (arg : System.Address) return System.Address;\n \n    function Thread_Body_Access is new\n-     Unchecked_Conversion (System.Address, Thread_Body);\n+     Ada.Unchecked_Conversion (System.Address, Thread_Body);\n \n    type pthread_t           is private;\n    subtype Thread_Id        is pthread_t;\n@@ -514,12 +505,6 @@ private\n    type clockid_t is new int;\n    CLOCK_REALTIME : constant clockid_t := 1;\n \n-   type struct_timeval is record\n-      tv_sec  : time_t;\n-      tv_usec : time_t;\n-   end record;\n-   pragma Convention (C, struct_timeval);\n-\n    type unsigned_long_array is array (Natural range <>) of unsigned_long;\n \n    type pthread_t is new System.Address;"}, {"sha": "8807efffcbe915cb9a8c07bca558b145615a8695", "filename": "gcc/ada/s-osprim-mingw.adb", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osprim-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osprim-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osprim-mingw.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1998-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -79,7 +79,7 @@ package body System.OS_Primitives is\n    --  GNU/Linker will fail to auto-import those variables when building\n    --  libgnarl.dll. The indirection level introduced here has no measurable\n    --  penalties.\n-   --\n+\n    --  Note that access variables below must not be declared as constant\n    --  otherwise the compiler optimization will remove this indirect access.\n \n@@ -179,15 +179,16 @@ package body System.OS_Primitives is\n    -------------------\n \n    procedure Get_Base_Time is\n+\n       --  The resolution for GetSystemTime is 1 millisecond.\n \n       --  The time to get both base times should take less than 1 millisecond.\n       --  Therefore, the elapsed time reported by GetSystemTime between both\n       --  actions should be null.\n \n-      Max_Elapsed    : constant := 0;\n+      Max_Elapsed : constant := 0;\n \n-      Test_Now       : aliased Long_Long_Integer;\n+      Test_Now : aliased Long_Long_Integer;\n \n       epoch_1970     : constant := 16#19D_B1DE_D53E_8000#; -- win32 UTC epoch\n       system_time_ns : constant := 100;                    -- 100 ns per tick\n@@ -225,6 +226,7 @@ package body System.OS_Primitives is\n    function Monotonic_Clock return Duration is\n       Current_Ticks  : aliased LARGE_INTEGER;\n       Elap_Secs_Tick : Duration;\n+\n    begin\n       if not QueryPerformanceCounter (Current_Ticks'Access) then\n          return 0.0;\n@@ -262,9 +264,17 @@ package body System.OS_Primitives is\n          end case;\n       end Mode_Clock;\n \n+      --  Local Variables\n+\n+      Base_Time : constant Duration := Mode_Clock;\n+      --  Base_Time is used to detect clock set backward, in this case we\n+      --  cannot ensure the delay accuracy.\n+\n       Rel_Time   : Duration;\n       Abs_Time   : Duration;\n-      Check_Time : Duration := Mode_Clock;\n+      Check_Time : Duration := Base_Time;\n+\n+   --  Start of processing for Timed Delay\n \n    begin\n       if Mode = Relative then\n@@ -280,7 +290,7 @@ package body System.OS_Primitives is\n             Sleep (DWORD (Rel_Time * 1000.0));\n             Check_Time := Mode_Clock;\n \n-            exit when Abs_Time <= Check_Time;\n+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n \n             Rel_Time := Abs_Time - Check_Time;\n          end loop;"}, {"sha": "dbbf839fed4e45845d5bea94074b126a5c44abd8", "filename": "gcc/ada/s-osprim-posix.adb", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osprim-posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osprim-posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osprim-posix.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1998-2006 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1998-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -125,11 +125,12 @@ package body System.OS_Primitives is\n      (Time : Duration;\n       Mode : Integer)\n    is\n-      Request : aliased timespec;\n-      Remaind : aliased timespec;\n-      Rel_Time : Duration;\n-      Abs_Time : Duration;\n-      Check_Time : Duration := Clock;\n+      Request    : aliased timespec;\n+      Remaind    : aliased timespec;\n+      Rel_Time   : Duration;\n+      Abs_Time   : Duration;\n+      Base_Time  : constant Duration := Clock;\n+      Check_Time : Duration := Base_Time;\n \n       Result : Integer;\n       pragma Unreferenced (Result);\n@@ -149,7 +150,7 @@ package body System.OS_Primitives is\n             Result := nanosleep (Request'Access, Remaind'Access);\n             Check_Time := Clock;\n \n-            exit when Abs_Time <= Check_Time;\n+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n \n             Rel_Time := Abs_Time - Check_Time;\n          end loop;"}, {"sha": "24faae2865ac7ad4b02143309ae1b7d223f91e92", "filename": "gcc/ada/s-osprim-solaris.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osprim-solaris.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osprim-solaris.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osprim-solaris.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1998-2006 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1998-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -88,7 +88,8 @@ package body System.OS_Primitives is\n    is\n       Rel_Time   : Duration;\n       Abs_Time   : Duration;\n-      Check_Time : Duration := Clock;\n+      Base_Time  : constant Duration := Clock;\n+      Check_Time : Duration := Base_Time;\n       timeval    : aliased struct_timeval;\n \n    begin\n@@ -114,7 +115,7 @@ package body System.OS_Primitives is\n             C_select (timeout => timeval'Unchecked_Access);\n             Check_Time := Clock;\n \n-            exit when Abs_Time <= Check_Time;\n+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n \n             Rel_Time := Abs_Time - Check_Time;\n          end loop;"}, {"sha": "c4f7f3dcfd95cb6a4ab5209daa51143961e61426", "filename": "gcc/ada/s-osprim-unix.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osprim-unix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osprim-unix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osprim-unix.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1998-2006 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1998-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -88,7 +88,8 @@ package body System.OS_Primitives is\n    is\n       Rel_Time   : Duration;\n       Abs_Time   : Duration;\n-      Check_Time : Duration := Clock;\n+      Base_Time  : constant Duration := Clock;\n+      Check_Time : Duration := Base_Time;\n       timeval    : aliased struct_timeval;\n \n    begin\n@@ -114,7 +115,7 @@ package body System.OS_Primitives is\n             C_select (timeout => timeval'Unchecked_Access);\n             Check_Time := Clock;\n \n-            exit when Abs_Time <= Check_Time;\n+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n \n             Rel_Time := Abs_Time - Check_Time;\n          end loop;"}, {"sha": "6f1b50a63c7bdd1421aef5153ba9127ce5549100", "filename": "gcc/ada/s-osprim-vxworks.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osprim-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-osprim-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osprim-vxworks.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1998-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1998-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -121,7 +121,8 @@ package body System.OS_Primitives is\n    is\n       Rel_Time   : Duration;\n       Abs_Time   : Duration;\n-      Check_Time : Duration := Clock;\n+      Base_Time  : constant Duration := Clock;\n+      Check_Time : Duration := Base_Time;\n       Ticks      : int;\n \n       Result     : int;\n@@ -151,7 +152,7 @@ package body System.OS_Primitives is\n             Result := taskDelay (Ticks);\n             Check_Time := Clock;\n \n-            exit when Abs_Time <= Check_Time;\n+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n \n             Rel_Time := Abs_Time - Check_Time;\n          end loop;"}, {"sha": "d4a561caab8c581867cd7dcd0252a6a12c71a3a5", "filename": "gcc/ada/s-parame-ae653.ads", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-parame-ae653.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-parame-ae653.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-parame-ae653.ads?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -171,18 +171,6 @@ package System.Parameters is\n    --  pragma Restrictions (No_Abort_Statements);\n    --  pragma Restrictions (Max_Asynchronous_Select_Nesting => 0);\n \n-   ----------------------\n-   -- Dynamic Priority --\n-   ----------------------\n-\n-   Dynamic_Priority_Support : constant Boolean := True;\n-   --  This constant indicates whether dynamic changes of task priorities\n-   --  are allowed (True means normal RM mode in which such changes are\n-   --  allowed). In particular, if this is False, then we do not need to\n-   --  poll for pending base priority changes at every abort completion\n-   --  point. A value of False for Dynamic_Priority_Support corresponds\n-   --  to pragma Restrictions (No_Dynamic_Priorities);\n-\n    ---------------------\n    -- Task Attributes --\n    ---------------------\n@@ -200,6 +188,13 @@ package System.Parameters is\n    --  predefined output or not (True means that traces are output).\n    --  See System.Traces for more details.\n \n+   -----------------------\n+   -- Task Image Length --\n+   -----------------------\n+\n+   Max_Task_Image_Length : constant := 32;\n+   --  This constant specifies the maximum length of a task's image.\n+\n    ------------------------------\n    -- Exception Message Length --\n    ------------------------------"}, {"sha": "2bda354c18f35f904ea3855e1aa46df9080ca6a5", "filename": "gcc/ada/s-parame-hpux.ads", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-parame-hpux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-parame-hpux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-parame-hpux.ads?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2007 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -169,18 +169,6 @@ package System.Parameters is\n    --  pragma Restrictions (No_Abort_Statements);\n    --  pragma Restrictions (Max_Asynchronous_Select_Nesting => 0);\n \n-   ----------------------\n-   -- Dynamic Priority --\n-   ----------------------\n-\n-   Dynamic_Priority_Support : constant Boolean := True;\n-   --  This constant indicates whether dynamic changes of task priorities\n-   --  are allowed (True means normal RM mode in which such changes are\n-   --  allowed). In particular, if this is False, then we do not need to\n-   --  poll for pending base priority changes at every abort completion\n-   --  point. A value of False for Dynamic_Priority_Support corresponds\n-   --  to pragma Restrictions (No_Dynamic_Priorities);\n-\n    ---------------------\n    -- Task Attributes --\n    ---------------------\n@@ -198,6 +186,13 @@ package System.Parameters is\n    --  predefined output or not (True means that traces are output).\n    --  See System.Traces for more details.\n \n+   -----------------------\n+   -- Task Image Length --\n+   -----------------------\n+\n+   Max_Task_Image_Length : constant := 256;\n+   --  This constant specifies the maximum length of a task's image.\n+\n    ------------------------------\n    -- Exception Message Length --\n    ------------------------------"}, {"sha": "ee1297e2eb7962098714949b00a9e946dc26888d", "filename": "gcc/ada/s-parame-vms-alpha.ads", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-parame-vms-alpha.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-parame-vms-alpha.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-parame-vms-alpha.ads?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2007 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -169,18 +169,6 @@ package System.Parameters is\n    --  pragma Restrictions (No_Abort_Statements);\n    --  pragma Restrictions (Max_Asynchronous_Select_Nesting => 0);\n \n-   ----------------------\n-   -- Dynamic Priority --\n-   ----------------------\n-\n-   Dynamic_Priority_Support : constant Boolean := True;\n-   --  This constant indicates whether dynamic changes of task priorities\n-   --  are allowed (True means normal RM mode in which such changes are\n-   --  allowed). In particular, if this is False, then we do not need to\n-   --  poll for pending base priority changes at every abort completion\n-   --  point. A value of False for Dynamic_Priority_Support corresponds\n-   --  to pragma Restrictions (No_Dynamic_Priorities);\n-\n    ---------------------\n    -- Task Attributes --\n    ---------------------\n@@ -198,6 +186,13 @@ package System.Parameters is\n    --  predefined output or not (True means that traces are output).\n    --  See System.Traces for more details.\n \n+   -----------------------\n+   -- Task Image Length --\n+   -----------------------\n+\n+   Max_Task_Image_Length : constant := 256;\n+   --  This constant specifies the maximum length of a task's image.\n+\n    ------------------------------\n    -- Exception Message Length --\n    ------------------------------"}, {"sha": "55c228d1ab0f285f446a010dee34cdd91d268966", "filename": "gcc/ada/s-parame-vms-ia64.ads", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-parame-vms-ia64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-parame-vms-ia64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-parame-vms-ia64.ads?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2007 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -169,18 +169,6 @@ package System.Parameters is\n    --  pragma Restrictions (No_Abort_Statements);\n    --  pragma Restrictions (Max_Asynchronous_Select_Nesting => 0);\n \n-   ----------------------\n-   -- Dynamic Priority --\n-   ----------------------\n-\n-   Dynamic_Priority_Support : constant Boolean := True;\n-   --  This constant indicates whether dynamic changes of task priorities\n-   --  are allowed (True means normal RM mode in which such changes are\n-   --  allowed). In particular, if this is False, then we do not need to\n-   --  poll for pending base priority changes at every abort completion\n-   --  point. A value of False for Dynamic_Priority_Support corresponds\n-   --  to pragma Restrictions (No_Dynamic_Priorities);\n-\n    ---------------------\n    -- Task Attributes --\n    ---------------------\n@@ -198,6 +186,13 @@ package System.Parameters is\n    --  predefined output or not (True means that traces are output).\n    --  See System.Traces for more details.\n \n+   -----------------------\n+   -- Task Image Length --\n+   -----------------------\n+\n+   Max_Task_Image_Length : constant := 256;\n+   --  This constant specifies the maximum length of a task's image.\n+\n    ------------------------------\n    -- Exception Message Length --\n    ------------------------------"}, {"sha": "62ccb67944de4a2839daaf725ba37e43374e516c", "filename": "gcc/ada/s-parame-vms-restrict.ads", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-parame-vms-restrict.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-parame-vms-restrict.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-parame-vms-restrict.ads?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2007 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -169,18 +169,6 @@ package System.Parameters is\n    --  pragma Restrictions (No_Abort_Statements);\n    --  pragma Restrictions (Max_Asynchronous_Select_Nesting => 0);\n \n-   ----------------------\n-   -- Dynamic Priority --\n-   ----------------------\n-\n-   Dynamic_Priority_Support : constant Boolean := False;\n-   --  This constant indicates whether dynamic changes of task priorities\n-   --  are allowed (True means normal RM mode in which such changes are\n-   --  allowed). In particular, if this is False, then we do not need to\n-   --  poll for pending base priority changes at every abort completion\n-   --  point. A value of False for Dynamic_Priority_Support corresponds\n-   --  to pragma Restrictions (No_Dynamic_Priorities);\n-\n    ---------------------\n    -- Task Attributes --\n    ---------------------\n@@ -198,6 +186,13 @@ package System.Parameters is\n    --  predefined output or not (True means that traces are output).\n    --  See System.Traces for more details.\n \n+   -----------------------\n+   -- Task Image Length --\n+   -----------------------\n+\n+   Max_Task_Image_Length : constant := 256;\n+   --  This constant specifies the maximum length of a task's image.\n+\n    ------------------------------\n    -- Exception Message Length --\n    ------------------------------"}, {"sha": "b1505328904e48aab0ce4176b046d81976222602", "filename": "gcc/ada/s-parame-vxworks.ads", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-parame-vxworks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-parame-vxworks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-parame-vxworks.ads?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2007 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -171,18 +171,6 @@ package System.Parameters is\n    --  pragma Restrictions (No_Abort_Statements);\n    --  pragma Restrictions (Max_Asynchronous_Select_Nesting => 0);\n \n-   ----------------------\n-   -- Dynamic Priority --\n-   ----------------------\n-\n-   Dynamic_Priority_Support : constant Boolean := True;\n-   --  This constant indicates whether dynamic changes of task priorities\n-   --  are allowed (True means normal RM mode in which such changes are\n-   --  allowed). In particular, if this is False, then we do not need to\n-   --  poll for pending base priority changes at every abort completion\n-   --  point. A value of False for Dynamic_Priority_Support corresponds\n-   --  to pragma Restrictions (No_Dynamic_Priorities);\n-\n    ---------------------\n    -- Task Attributes --\n    ---------------------\n@@ -200,6 +188,13 @@ package System.Parameters is\n    --  predefined output or not (True means that traces are output).\n    --  See System.Traces for more details.\n \n+   -----------------------\n+   -- Task Image Length --\n+   -----------------------\n+\n+   Max_Task_Image_Length : constant := 32;\n+   --  This constant specifies the maximum length of a task's image.\n+\n    ------------------------------\n    -- Exception Message Length --\n    ------------------------------"}, {"sha": "bbe0b9bde1b764ec786f5ee91cff8271f3328262", "filename": "gcc/ada/s-parame.ads", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-parame.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-parame.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-parame.ads?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2007 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -169,18 +169,6 @@ package System.Parameters is\n    --  pragma Restrictions (No_Abort_Statements);\n    --  pragma Restrictions (Max_Asynchronous_Select_Nesting => 0);\n \n-   ----------------------\n-   -- Dynamic Priority --\n-   ----------------------\n-\n-   Dynamic_Priority_Support : constant Boolean := True;\n-   --  This constant indicates whether dynamic changes of task priorities\n-   --  are allowed (True means normal RM mode in which such changes are\n-   --  allowed). In particular, if this is False, then we do not need to\n-   --  poll for pending base priority changes at every abort completion\n-   --  point. A value of False for Dynamic_Priority_Support corresponds\n-   --  to pragma Restrictions (No_Dynamic_Priorities);\n-\n    ---------------------\n    -- Task Attributes --\n    ---------------------\n@@ -198,6 +186,13 @@ package System.Parameters is\n    --  predefined output or not (True means that traces are output).\n    --  See System.Traces for more details.\n \n+   -----------------------\n+   -- Task Image Length --\n+   -----------------------\n+\n+   Max_Task_Image_Length : constant := 256;\n+   --  This constant specifies the maximum length of a task's image.\n+\n    ------------------------------\n    -- Exception Message Length --\n    ------------------------------"}, {"sha": "3da82bf60bad99ec8ce1014f5734523207002084", "filename": "gcc/ada/s-taenca.adb", "status": "modified", "additions": 67, "deletions": 107, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taenca.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taenca.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taenca.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2005, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2007, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -40,7 +40,6 @@ with System.Task_Primitives.Operations;\n \n with System.Tasking.Initialization;\n --  used for Change_Base_Priority\n---           Dynamic_Priority_Support\n --           Defer_Abort/Undefer_Abort\n \n with System.Tasking.Protected_Objects.Entries;\n@@ -84,24 +83,23 @@ package body System.Tasking.Entry_Calls is\n    -----------------------\n \n    procedure Lock_Server (Entry_Call : Entry_Call_Link);\n-   --  This locks the server targeted by Entry_Call.\n+\n+   --  This locks the server targeted by Entry_Call\n    --\n-   --  This may be a task or a protected object,\n-   --  depending on the target of the original call or any subsequent\n-   --  requeues.\n+   --  This may be a task or a protected object, depending on the target of the\n+   --  original call or any subsequent requeues.\n    --\n-   --  This routine is needed because the field specifying the server\n-   --  for this call must be protected by the server's mutex. If it were\n-   --  protected by the caller's mutex, accessing the server's queues would\n-   --  require locking the caller to get the server, locking the server,\n-   --  and then accessing the queues. This involves holding two ATCB\n-   --  locks at once, something which we can guarantee that it will always\n-   --  be done in the same order, or locking a protected object while we\n-   --  hold an ATCB lock, something which is not permitted. Since\n-   --  the server cannot be obtained reliably, it must be obtained unreliably\n-   --  and then checked again once it has been locked.\n+   --  This routine is needed because the field specifying the server for this\n+   --  call must be protected by the server's mutex. If it were protected by\n+   --  the caller's mutex, accessing the server's queues would require locking\n+   --  the caller to get the server, locking the server, and then accessing the\n+   --  queues. This involves holding two ATCB locks at once, something which we\n+   --  can guarantee that it will always be done in the same order, or locking\n+   --  a protected object while we hold an ATCB lock, something which is not\n+   --  permitted. Since the server cannot be obtained reliably, it must be\n+   --  obtained unreliably and then checked again once it has been locked.\n    --\n-   --  If Single_Lock and server is a PO, release RTS_Lock.\n+   --  If Single_Lock and server is a PO, release RTS_Lock\n    --\n    --  This should only be called by the Entry_Call.Self.\n    --  It should be holding no other ATCB locks at the time.\n@@ -123,23 +121,22 @@ package body System.Tasking.Entry_Calls is\n    procedure Check_Pending_Actions_For_Entry_Call\n      (Self_ID    : Task_Id;\n       Entry_Call : Entry_Call_Link);\n-   --  This procedure performs priority change of a queued call and\n-   --  dequeuing of an entry call when the call is cancelled.\n-   --  If the call is dequeued the state should be set to Cancelled.\n-   --  Call only with abort deferred and holding lock of Self_ID. This\n-   --  is a bit of common code for all entry calls. The effect is to do\n-   --  any deferred base priority change operation, in case some other\n-   --  task called STPO.Set_Priority while the current task had abort deferred,\n-   --  and to dequeue the call if the call has been aborted.\n+   --  This procedure performs priority change of a queued call and dequeuing\n+   --  of an entry call when the call is cancelled. If the call is dequeued the\n+   --  state should be set to Cancelled. Call only with abort deferred and\n+   --  holding lock of Self_ID. This is a bit of common code for all entry\n+   --  calls. The effect is to do any deferred base priority change operation,\n+   --  in case some other task called STPO.Set_Priority while the current task\n+   --  had abort deferred, and to dequeue the call if the call has been\n+   --  aborted.\n \n    procedure Poll_Base_Priority_Change_At_Entry_Call\n      (Self_ID    : Task_Id;\n       Entry_Call : Entry_Call_Link);\n    pragma Inline (Poll_Base_Priority_Change_At_Entry_Call);\n-   --  A specialized version of Poll_Base_Priority_Change,\n-   --  that does the optional entry queue reordering.\n-   --  Has to be called with the Self_ID's ATCB write-locked.\n-   --  May temporariliy release the lock.\n+   --  A specialized version of Poll_Base_Priority_Change, that does the\n+   --  optional entry queue reordering. Has to be called with the Self_ID's\n+   --  ATCB write-locked. May temporariliy release the lock.\n \n    ---------------------\n    -- Check_Exception --\n@@ -160,6 +157,7 @@ package body System.Tasking.Entry_Calls is\n             Entry_Call.Exception_To_Raise;\n    begin\n       --  pragma Assert (Self_ID.Deferral_Level = 0);\n+\n       --  The above may be useful for debugging, but the Florist packages\n       --  contain critical sections that defer abort and then do entry calls,\n       --  which causes the above Assert to trip.\n@@ -175,7 +173,8 @@ package body System.Tasking.Entry_Calls is\n \n    procedure Check_Pending_Actions_For_Entry_Call\n      (Self_ID    : Task_Id;\n-      Entry_Call : Entry_Call_Link) is\n+      Entry_Call : Entry_Call_Link)\n+   is\n    begin\n       pragma Assert (Self_ID = Entry_Call.Self);\n \n@@ -224,8 +223,8 @@ package body System.Tasking.Entry_Calls is\n       loop\n          if Test_Task = null then\n \n-            --  Entry_Call was queued on a protected object,\n-            --  or in transition, when we last fetched Test_Task.\n+            --  Entry_Call was queued on a protected object, or in transition,\n+            --  when we last fetched Test_Task.\n \n             Test_PO := To_Protection (Entry_Call.Called_PO);\n \n@@ -249,12 +248,12 @@ package body System.Tasking.Entry_Calls is\n \n                Lock_Entries (Test_PO, Ceiling_Violation);\n \n-               --  ????\n-               --  The following code allows Lock_Server to be called\n-               --  when cancelling a call, to allow for the possibility\n-               --  that the priority of the caller has been raised\n-               --  beyond that of the protected entry call by\n-               --  Ada.Dynamic_Priorities.Set_Priority.\n+               --  ???\n+\n+               --  The following code allows Lock_Server to be called when\n+               --  cancelling a call, to allow for the possibility that the\n+               --  priority of the caller has been raised beyond that of the\n+               --  protected entry call by Ada.Dynamic_Priorities.Set_Priority.\n \n                --  If the current task has a higher priority than the ceiling\n                --  of the protected object, temporarily lower it. It will\n@@ -316,52 +315,18 @@ package body System.Tasking.Entry_Calls is\n \n    procedure Poll_Base_Priority_Change_At_Entry_Call\n      (Self_ID    : Task_Id;\n-      Entry_Call : Entry_Call_Link) is\n+      Entry_Call : Entry_Call_Link)\n+   is\n    begin\n-      if Dynamic_Priority_Support and then Self_ID.Pending_Priority_Change then\n+      if Self_ID.Pending_Priority_Change then\n+\n          --  Check for ceiling violations ???\n \n          Self_ID.Pending_Priority_Change := False;\n \n-         if Self_ID.Common.Base_Priority = Self_ID.New_Base_Priority then\n-            if Single_Lock then\n-               STPO.Unlock_RTS;\n-               STPO.Yield;\n-               STPO.Lock_RTS;\n-            else\n-               STPO.Unlock (Self_ID);\n-               STPO.Yield;\n-               STPO.Write_Lock (Self_ID);\n-            end if;\n-\n-         else\n-            if Self_ID.Common.Base_Priority < Self_ID.New_Base_Priority then\n-               --  Raising priority\n-\n-               Self_ID.Common.Base_Priority := Self_ID.New_Base_Priority;\n-               STPO.Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n-\n-            else\n-               --  Lowering priority\n-\n-               Self_ID.Common.Base_Priority := Self_ID.New_Base_Priority;\n-               STPO.Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n-\n-               if Single_Lock then\n-                  STPO.Unlock_RTS;\n-                  STPO.Yield;\n-                  STPO.Lock_RTS;\n-               else\n-                  STPO.Unlock (Self_ID);\n-                  STPO.Yield;\n-                  STPO.Write_Lock (Self_ID);\n-               end if;\n-            end if;\n-         end if;\n-\n-         --  Requeue the entry call at the new priority.\n-         --  We need to requeue even if the new priority is the same than\n-         --  the previous (see ACVC cxd4006).\n+         --  Requeue the entry call at the new priority. We need to requeue\n+         --  even if the new priority is the same than the previous (see ACATS\n+         --  test cxd4006).\n \n          STPO.Unlock (Self_ID);\n          Lock_Server (Entry_Call);\n@@ -378,7 +343,8 @@ package body System.Tasking.Entry_Calls is\n \n    procedure Reset_Priority\n      (Acceptor               : Task_Id;\n-      Acceptor_Prev_Priority : Rendezvous_Priority) is\n+      Acceptor_Prev_Priority : Rendezvous_Priority)\n+   is\n    begin\n       pragma Assert (Acceptor = STPO.Self);\n \n@@ -431,26 +397,19 @@ package body System.Tasking.Entry_Calls is\n \n       Succeeded := Entry_Call.State = Cancelled;\n \n-      if Succeeded then\n-         Initialization.Undefer_Abort_Nestable (Self_ID);\n-      else\n-         --  ???\n-\n-         Initialization.Undefer_Abort_Nestable (Self_ID);\n+      Initialization.Undefer_Abort_Nestable (Self_ID);\n \n-         --  Ideally, abort should no longer be deferred at this\n-         --  point, so we should be able to call Check_Exception.\n-         --  The loop below should be considered temporary,\n-         --  to work around the possiblility that abort may be deferred\n-         --  more than one level deep.\n+      --  Ideally, abort should no longer be deferred at this point, so we\n+      --  should be able to call Check_Exception. The loop below should be\n+      --  considered temporary, to work around the possibility that abort\n+      --  may be deferred more than one level deep ???\n \n-         if Entry_Call.Exception_To_Raise /= Ada.Exceptions.Null_Id then\n-            while Self_ID.Deferral_Level > 0 loop\n-               System.Tasking.Initialization.Undefer_Abort_Nestable (Self_ID);\n-            end loop;\n+      if Entry_Call.Exception_To_Raise /= Ada.Exceptions.Null_Id then\n+         while Self_ID.Deferral_Level > 0 loop\n+            System.Tasking.Initialization.Undefer_Abort_Nestable (Self_ID);\n+         end loop;\n \n-            Entry_Calls.Check_Exception (Self_ID, Entry_Call);\n-         end if;\n+         Entry_Calls.Check_Exception (Self_ID, Entry_Call);\n       end if;\n    end Try_To_Cancel_Entry_Call;\n \n@@ -544,6 +503,7 @@ package body System.Tasking.Entry_Calls is\n \n    procedure Wait_For_Completion (Entry_Call : Entry_Call_Link) is\n       Self_Id : constant Task_Id := Entry_Call.Self;\n+\n    begin\n       --  If this is a conditional call, it should be cancelled when it\n       --  becomes abortable. This is checked in the loop below.\n@@ -552,9 +512,11 @@ package body System.Tasking.Entry_Calls is\n          Send_Trace_Info (W_Completion);\n       end if;\n \n+      Self_Id.Common.State := Entry_Caller_Sleep;\n+\n       --  Try to remove calls to Sleep in the loop below by letting the caller\n       --  a chance of getting ready immediately, using Unlock & Yield.\n-      --  See similar action in Wait_For_Call & Selective_Wait.\n+      --  See similar action in Wait_For_Call & Timed_Selective_Wait.\n \n       if Single_Lock then\n          STPO.Unlock_RTS;\n@@ -572,8 +534,6 @@ package body System.Tasking.Entry_Calls is\n          STPO.Write_Lock (Self_Id);\n       end if;\n \n-      Self_Id.Common.State := Entry_Caller_Sleep;\n-\n       loop\n          Check_Pending_Actions_For_Entry_Call (Self_Id, Entry_Call);\n \n@@ -633,12 +593,11 @@ package body System.Tasking.Entry_Calls is\n       Yielded := False;\n       Self_Id.Common.State := Entry_Caller_Sleep;\n \n-      --  Looping is necessary in case the task wakes up early from the\n-      --  timed sleep, due to a \"spurious wakeup\". Spurious wakeups are\n-      --  a weakness of POSIX condition variables. A thread waiting for\n-      --  a condition variable is allowed to wake up at any time, not just\n-      --  when the condition is signaled. See the same loop in the\n-      --  ordinary Wait_For_Completion, above.\n+      --  Looping is necessary in case the task wakes up early from the timed\n+      --  sleep, due to a \"spurious wakeup\". Spurious wakeups are a weakness of\n+      --  POSIX condition variables. A thread waiting for a condition variable\n+      --  is allowed to wake up at any time, not just when the condition is\n+      --  signaled. See same loop in the ordinary Wait_For_Completion, above.\n \n       if Parameters.Runtime_Traces then\n          Send_Trace_Info (WT_Completion, Wakeup_Time);\n@@ -700,7 +659,8 @@ package body System.Tasking.Entry_Calls is\n \n    procedure Wait_Until_Abortable\n      (Self_ID : Task_Id;\n-      Call    : Entry_Call_Link) is\n+      Call    : Entry_Call_Link)\n+   is\n    begin\n       pragma Assert (Self_ID.ATC_Nesting_Level > 0);\n       pragma Assert (Call.Mode = Asynchronous_Call);"}, {"sha": "ccd1c00cd863c2c5b2bd55b86a3da6c7b29565b2", "filename": "gcc/ada/s-taprop-dummy.adb", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taprop-dummy.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taprop-dummy.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-dummy.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -64,8 +64,6 @@ package body System.Task_Primitives.Operations is\n    -- Check_Exit --\n    ----------------\n \n-   --  Dummy version\n-\n    function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n    begin\n       return True;\n@@ -266,7 +264,9 @@ package body System.Task_Primitives.Operations is\n    ---------------\n \n    procedure Read_Lock\n-     (L : not null access Lock; Ceiling_Violation : out Boolean) is\n+     (L                 : not null access Lock;\n+      Ceiling_Violation : out Boolean)\n+   is\n    begin\n       Ceiling_Violation := False;\n    end Read_Lock;\n@@ -310,6 +310,18 @@ package body System.Task_Primitives.Operations is\n       return Null_Task;\n    end Self;\n \n+   -----------------\n+   -- Set_Ceiling --\n+   -----------------\n+\n+   procedure Set_Ceiling\n+     (L    : not null access Lock;\n+      Prio : System.Any_Priority)\n+   is\n+   begin\n+      null;\n+   end Set_Ceiling;\n+\n    ---------------\n    -- Set_False --\n    ---------------\n@@ -420,7 +432,9 @@ package body System.Task_Primitives.Operations is\n    end Unlock;\n \n    procedure Unlock\n-     (L : not null access RTS_Lock; Global_Lock : Boolean := False) is\n+     (L           : not null access RTS_Lock;\n+      Global_Lock : Boolean := False)\n+   is\n    begin\n       null;\n    end Unlock;\n@@ -452,7 +466,9 @@ package body System.Task_Primitives.Operations is\n    ----------------\n \n    procedure Write_Lock\n-     (L : not null access Lock; Ceiling_Violation : out Boolean) is\n+     (L                 : not null access Lock;\n+      Ceiling_Violation : out Boolean)\n+   is\n    begin\n       Ceiling_Violation := False;\n    end Write_Lock;"}, {"sha": "416a36f6df7ccd49895eaf99bcecfe8cd96dfa6e", "filename": "gcc/ada/s-taprop-hpux-dce.adb", "status": "modified", "additions": 103, "deletions": 71, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taprop-hpux-dce.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taprop-hpux-dce.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-hpux-dce.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2006, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2007, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -74,8 +74,8 @@ with System.Soft_Links;\n --  For example when using the restricted run time, it is replaced by\n --  System.Tasking.Restricted.Stages.\n \n-with Unchecked_Conversion;\n-with Unchecked_Deallocation;\n+with Ada.Unchecked_Conversion;\n+with Ada.Unchecked_Deallocation;\n \n package body System.Task_Primitives.Operations is\n \n@@ -167,7 +167,8 @@ package body System.Task_Primitives.Operations is\n \n    procedure Abort_Handler (Sig : Signal);\n \n-   function To_Address is new Unchecked_Conversion (Task_Id, System.Address);\n+   function To_Address is\n+     new Ada.Unchecked_Conversion (Task_Id, System.Address);\n \n    -------------------\n    -- Abort_Handler --\n@@ -182,15 +183,18 @@ package body System.Task_Primitives.Operations is\n \n    begin\n       if Self_Id.Deferral_Level = 0\n-        and then Self_Id.Pending_ATC_Level < Self_Id.ATC_Nesting_Level and then\n-        not Self_Id.Aborting\n+        and then Self_Id.Pending_ATC_Level < Self_Id.ATC_Nesting_Level\n+        and then not Self_Id.Aborting\n       then\n          Self_Id.Aborting := True;\n \n          --  Make sure signals used for RTS internal purpose are unmasked\n \n-         Result := pthread_sigmask (SIG_UNBLOCK,\n-           Unblocked_Signal_Mask'Unchecked_Access, Old_Set'Unchecked_Access);\n+         Result :=\n+           pthread_sigmask\n+             (SIG_UNBLOCK,\n+              Unblocked_Signal_Mask'Unchecked_Access,\n+              Old_Set'Unchecked_Access);\n          pragma Assert (Result = 0);\n \n          raise Standard'Abort_Signal;\n@@ -201,8 +205,8 @@ package body System.Task_Primitives.Operations is\n    -- Stack_Guard --\n    -----------------\n \n-   --  The underlying thread system sets a guard page at the\n-   --  bottom of a thread stack, so nothing is needed.\n+   --  The underlying thread system sets a guard page at the bottom of a thread\n+   --  stack, so nothing is needed.\n    --  ??? Check the comment above\n \n    procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n@@ -230,12 +234,11 @@ package body System.Task_Primitives.Operations is\n    -- Initialize_Lock --\n    ---------------------\n \n-   --  Note: mutexes and cond_variables needed per-task basis are\n-   --        initialized in Initialize_TCB and the Storage_Error is\n-   --        handled. Other mutexes (such as RTS_Lock, Memory_Lock...)\n-   --        used in RTS is initialized before any status change of RTS.\n-   --        Therefore rasing Storage_Error in the following routines\n-   --        should be able to be handled safely.\n+   --  Note: mutexes and cond_variables needed per-task basis are initialized\n+   --  in Initialize_TCB and the Storage_Error is handled. Other mutexes (such\n+   --  as RTS_Lock, Memory_Lock...) used in RTS is initialized before any\n+   --  status change of RTS. Therefore rasing Storage_Error in the following\n+   --  routines should be able to be handled safely.\n \n    procedure Initialize_Lock\n      (Prio : System.Any_Priority;\n@@ -266,7 +269,9 @@ package body System.Task_Primitives.Operations is\n    end Initialize_Lock;\n \n    procedure Initialize_Lock\n-     (L : not null access RTS_Lock; Level : Lock_Level) is\n+     (L     : not null access RTS_Lock;\n+      Level : Lock_Level)\n+   is\n       pragma Unreferenced (Level);\n \n       Attributes : aliased pthread_mutexattr_t;\n@@ -315,7 +320,8 @@ package body System.Task_Primitives.Operations is\n    ----------------\n \n    procedure Write_Lock\n-     (L : not null access Lock; Ceiling_Violation : out Boolean)\n+     (L                 : not null access Lock;\n+      Ceiling_Violation : out Boolean)\n    is\n       Result : Interfaces.C.int;\n \n@@ -333,7 +339,8 @@ package body System.Task_Primitives.Operations is\n    end Write_Lock;\n \n    procedure Write_Lock\n-     (L : not null access RTS_Lock; Global_Lock : Boolean := False)\n+     (L           : not null access RTS_Lock;\n+      Global_Lock : Boolean := False)\n    is\n       Result : Interfaces.C.int;\n    begin\n@@ -357,7 +364,9 @@ package body System.Task_Primitives.Operations is\n    ---------------\n \n    procedure Read_Lock\n-     (L : not null access Lock; Ceiling_Violation : out Boolean) is\n+     (L                 : not null access Lock;\n+      Ceiling_Violation : out Boolean)\n+   is\n    begin\n       Write_Lock (L, Ceiling_Violation);\n    end Read_Lock;\n@@ -374,7 +383,8 @@ package body System.Task_Primitives.Operations is\n    end Unlock;\n \n    procedure Unlock\n-     (L : not null access RTS_Lock; Global_Lock : Boolean := False)\n+     (L           : not null access RTS_Lock;\n+      Global_Lock : Boolean := False)\n    is\n       Result : Interfaces.C.int;\n    begin\n@@ -393,6 +403,21 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n+   -----------------\n+   -- Set_Ceiling --\n+   -----------------\n+\n+   --  Dynamic priority ceilings are not supported by the underlying system\n+\n+   procedure Set_Ceiling\n+     (L    : not null access Lock;\n+      Prio : System.Any_Priority)\n+   is\n+      pragma Unreferenced (L, Prio);\n+   begin\n+      null;\n+   end Set_Ceiling;\n+\n    -----------\n    -- Sleep --\n    -----------\n@@ -406,11 +431,13 @@ package body System.Task_Primitives.Operations is\n       Result : Interfaces.C.int;\n    begin\n       if Single_Lock then\n-         Result := pthread_cond_wait\n-           (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n+         Result :=\n+           pthread_cond_wait\n+             (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n       else\n-         Result := pthread_cond_wait\n-           (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n+         Result :=\n+           pthread_cond_wait\n+             (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n       end if;\n \n       --  EINTR is not considered a failure\n@@ -451,18 +478,21 @@ package body System.Task_Primitives.Operations is\n          Request := To_Timespec (Abs_Time);\n \n          loop\n-            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n-              or else Self_ID.Pending_Priority_Change;\n+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n             if Single_Lock then\n-               Result := pthread_cond_timedwait\n-                 (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access,\n-                  Request'Access);\n+               Result :=\n+                 pthread_cond_timedwait\n+                   (Self_ID.Common.LL.CV'Access,\n+                    Single_RTS_Lock'Access,\n+                    Request'Access);\n \n             else\n-               Result := pthread_cond_timedwait\n-                 (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access,\n-                  Request'Access);\n+               Result :=\n+                 pthread_cond_timedwait\n+                   (Self_ID.Common.LL.CV'Access,\n+                    Self_ID.Common.LL.L'Access,\n+                    Request'Access);\n             end if;\n \n             exit when Abs_Time <= Monotonic_Clock;\n@@ -514,24 +544,20 @@ package body System.Task_Primitives.Operations is\n          Self_ID.Common.State := Delay_Sleep;\n \n          loop\n-            if Self_ID.Pending_Priority_Change then\n-               Self_ID.Pending_Priority_Change := False;\n-               Self_ID.Common.Base_Priority := Self_ID.New_Base_Priority;\n-               Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n-            end if;\n-\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n             if Single_Lock then\n-               Result := pthread_cond_timedwait\n-                           (Self_ID.Common.LL.CV'Access,\n-                            Single_RTS_Lock'Access,\n-                            Request'Access);\n+               Result :=\n+                 pthread_cond_timedwait\n+                   (Self_ID.Common.LL.CV'Access,\n+                    Single_RTS_Lock'Access,\n+                    Request'Access);\n             else\n-               Result := pthread_cond_timedwait\n-                          (Self_ID.Common.LL.CV'Access,\n-                           Self_ID.Common.LL.L'Access,\n-                           Request'Access);\n+               Result :=\n+                 pthread_cond_timedwait\n+                   (Self_ID.Common.LL.CV'Access,\n+                    Self_ID.Common.LL.L'Access,\n+                    Request'Access);\n             end if;\n \n             exit when Abs_Time <= Monotonic_Clock;\n@@ -581,9 +607,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Wakeup (T : Task_Id; Reason : System.Tasking.Task_States) is\n       pragma Unreferenced (Reason);\n-\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_cond_signal (T.Common.LL.CV'Access);\n       pragma Assert (Result = 0);\n@@ -613,8 +637,7 @@ package body System.Task_Primitives.Operations is\n    --  Global array containing the id of the currently running task for\n    --  each priority.\n    --\n-   --  Note: we assume that we are on a single processor with run-til-blocked\n-   --  scheduling.\n+   --  Note: assume we are on single processor with run-til-blocked scheduling\n \n    procedure Set_Priority\n      (T                   : Task_Id;\n@@ -640,19 +663,22 @@ package body System.Task_Primitives.Operations is\n         or else Priority_Specific_Policy = 'R'\n         or else Time_Slice_Val > 0\n       then\n-         Result := pthread_setschedparam\n-           (T.Common.LL.Thread, SCHED_RR, Param'Access);\n+         Result :=\n+           pthread_setschedparam\n+             (T.Common.LL.Thread, SCHED_RR, Param'Access);\n \n       elsif Dispatching_Policy = 'F'\n         or else Priority_Specific_Policy = 'F'\n         or else Time_Slice_Val = 0\n       then\n-         Result := pthread_setschedparam\n-           (T.Common.LL.Thread, SCHED_FIFO, Param'Access);\n+         Result :=\n+           pthread_setschedparam\n+             (T.Common.LL.Thread, SCHED_FIFO, Param'Access);\n \n       else\n-         Result := pthread_setschedparam\n-           (T.Common.LL.Thread, SCHED_OTHER, Param'Access);\n+         Result :=\n+           pthread_setschedparam\n+             (T.Common.LL.Thread, SCHED_OTHER, Param'Access);\n       end if;\n \n       pragma Assert (Result = 0);\n@@ -763,8 +789,9 @@ package body System.Task_Primitives.Operations is\n          pragma Assert (Result = 0 or else Result = ENOMEM);\n \n          if Result = 0 then\n-            Result := pthread_mutex_init (Self_ID.Common.LL.L'Access,\n-              Mutex_Attr'Access);\n+            Result :=\n+              pthread_mutex_init\n+                (Self_ID.Common.LL.L'Access, Mutex_Attr'Access);\n             pragma Assert (Result = 0 or else Result = ENOMEM);\n          end if;\n \n@@ -781,8 +808,10 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Result = 0 or else Result = ENOMEM);\n \n       if Result = 0 then\n-         Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n-           Cond_Attr'Access);\n+         Result :=\n+           pthread_cond_init\n+             (Self_ID.Common.LL.CV'Access,\n+              Cond_Attr'Access);\n          pragma Assert (Result = 0 or else Result = ENOMEM);\n       end if;\n \n@@ -816,7 +845,7 @@ package body System.Task_Primitives.Operations is\n       Result     : Interfaces.C.int;\n \n       function Thread_Body_Access is new\n-        Unchecked_Conversion (System.Address, Thread_Body);\n+        Ada.Unchecked_Conversion (System.Address, Thread_Body);\n \n    begin\n       Result := pthread_attr_init (Attributes'Access);\n@@ -865,7 +894,7 @@ package body System.Task_Primitives.Operations is\n       Is_Self : constant Boolean := T = Self;\n \n       procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n+        Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n    begin\n       if not Single_Lock then\n@@ -902,9 +931,8 @@ package body System.Task_Primitives.Operations is\n \n    procedure Abort_Task (T : Task_Id) is\n    begin\n-      --\n       --  Interrupt Server_Tasks may be waiting on an \"event\" flag (signal)\n-      --\n+\n       if T.Common.State = Interrupt_Server_Blocked_On_Event_Flag then\n          System.Interrupt_Management.Operations.Interrupt_Self_Process\n            (System.Interrupt_Management.Interrupt_ID\n@@ -921,8 +949,7 @@ package body System.Task_Primitives.Operations is\n       Cond_Attr  : aliased pthread_condattr_t;\n       Result     : Interfaces.C.int;\n    begin\n-      --  Initialize internal state. It is always initialized to False (ARM\n-      --  D.10 par. 6).\n+      --  Initialize internal state (always to False (ARM D.10(6)))\n \n       S.State := False;\n       S.Waiting := False;\n@@ -957,6 +984,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Finalize (S : in out Suspension_Object) is\n       Result  : Interfaces.C.int;\n+\n    begin\n       --  Destroy internal mutex\n \n@@ -987,6 +1015,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Set_False (S : in out Suspension_Object) is\n       Result  : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n@@ -1007,6 +1036,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Set_True (S : in out Suspension_Object) is\n       Result : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n@@ -1024,6 +1054,7 @@ package body System.Task_Primitives.Operations is\n \n          Result := pthread_cond_signal (S.CV'Access);\n          pragma Assert (Result = 0);\n+\n       else\n          S.State := True;\n       end if;\n@@ -1040,6 +1071,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Suspend_Until_True (S : in out Suspension_Object) is\n       Result : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n@@ -1158,10 +1190,10 @@ package body System.Task_Primitives.Operations is\n    ----------------\n \n    procedure Initialize (Environment_Task : Task_Id) is\n-      act       : aliased struct_sigaction;\n-      old_act   : aliased struct_sigaction;\n-      Tmp_Set   : aliased sigset_t;\n-      Result    : Interfaces.C.int;\n+      act     : aliased struct_sigaction;\n+      old_act : aliased struct_sigaction;\n+      Tmp_Set : aliased sigset_t;\n+      Result  : Interfaces.C.int;\n \n       function State\n         (Int : System.Interrupt_Management.Interrupt_ID) return Character;"}, {"sha": "e18320d90fa692426509caad33e5c8d0579adfb5", "filename": "gcc/ada/s-taprop-irix.adb", "status": "modified", "additions": 138, "deletions": 96, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taprop-irix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taprop-irix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-irix.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2006, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2007, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -68,8 +68,8 @@ with System.Soft_Links;\n --  For example when using the restricted run time, it is replaced by\n --  System.Tasking.Restricted.Stages.\n \n-with Unchecked_Conversion;\n-with Unchecked_Deallocation;\n+with Ada.Unchecked_Conversion;\n+with Ada.Unchecked_Deallocation;\n \n package body System.Task_Primitives.Operations is\n \n@@ -157,7 +157,8 @@ package body System.Task_Primitives.Operations is\n    -- Local Subprograms --\n    -----------------------\n \n-   function To_Address is new Unchecked_Conversion (Task_Id, System.Address);\n+   function To_Address is\n+     new Ada.Unchecked_Conversion (Task_Id, System.Address);\n \n    procedure Abort_Handler (Sig : Signal);\n    --  Signal handler used to implement asynchronous abort\n@@ -229,12 +230,11 @@ package body System.Task_Primitives.Operations is\n    -- Initialize_Lock --\n    ---------------------\n \n-   --  Note: mutexes and cond_variables needed per-task basis are\n-   --        initialized in Initialize_TCB and the Storage_Error is\n-   --        handled. Other mutexes (such as RTS_Lock, Memory_Lock...)\n-   --        used in RTS is initialized before any status change of RTS.\n-   --        Therefore rasing Storage_Error in the following routines\n-   --        should be able to be handled safely.\n+   --  Note: mutexes and cond_variables needed per-task basis are initialized\n+   --  in Initialize_TCB and the Storage_Error is handled. Other mutexes (such\n+   --  as RTS_Lock, Memory_Lock...) used in RTS is initialized before any\n+   --  status change of RTS. Therefore rasing Storage_Error in the following\n+   --  routines should be able to be handled safely.\n \n    procedure Initialize_Lock\n      (Prio : System.Any_Priority;\n@@ -252,12 +252,14 @@ package body System.Task_Primitives.Operations is\n       end if;\n \n       if Locking_Policy = 'C' then\n-         Result := pthread_mutexattr_setprotocol\n-           (Attributes'Access, PTHREAD_PRIO_PROTECT);\n+         Result :=\n+           pthread_mutexattr_setprotocol\n+             (Attributes'Access, PTHREAD_PRIO_PROTECT);\n          pragma Assert (Result = 0);\n \n-         Result := pthread_mutexattr_setprioceiling\n-            (Attributes'Access, Interfaces.C.int (Prio));\n+         Result :=\n+           pthread_mutexattr_setprioceiling\n+             (Attributes'Access, Interfaces.C.int (Prio));\n          pragma Assert (Result = 0);\n       end if;\n \n@@ -274,7 +276,8 @@ package body System.Task_Primitives.Operations is\n    end Initialize_Lock;\n \n    procedure Initialize_Lock\n-     (L : not null access RTS_Lock; Level : Lock_Level)\n+     (L     : not null access RTS_Lock;\n+      Level : Lock_Level)\n    is\n       pragma Unreferenced (Level);\n \n@@ -338,6 +341,7 @@ package body System.Task_Primitives.Operations is\n      (L : not null access Lock; Ceiling_Violation : out Boolean)\n    is\n       Result : Interfaces.C.int;\n+\n    begin\n       Result := pthread_mutex_lock (L);\n       Ceiling_Violation := Result = EINVAL;\n@@ -390,10 +394,10 @@ package body System.Task_Primitives.Operations is\n    end Unlock;\n \n    procedure Unlock\n-     (L : not null access RTS_Lock; Global_Lock : Boolean := False)\n+     (L           : not null access RTS_Lock;\n+      Global_Lock : Boolean := False)\n    is\n       Result : Interfaces.C.int;\n-\n    begin\n       if not Single_Lock or else Global_Lock then\n          Result := pthread_mutex_unlock (L);\n@@ -403,14 +407,28 @@ package body System.Task_Primitives.Operations is\n \n    procedure Unlock (T : Task_Id) is\n       Result : Interfaces.C.int;\n-\n    begin\n       if not Single_Lock then\n          Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n          pragma Assert (Result = 0);\n       end if;\n    end Unlock;\n \n+   -----------------\n+   -- Set_Ceiling --\n+   -----------------\n+\n+   --  Dynamic priority ceilings are not supported by the underlying system\n+\n+   procedure Set_Ceiling\n+     (L    : not null access Lock;\n+      Prio : System.Any_Priority)\n+   is\n+      pragma Unreferenced (L, Prio);\n+   begin\n+      null;\n+   end Set_Ceiling;\n+\n    -----------\n    -- Sleep --\n    -----------\n@@ -420,16 +438,17 @@ package body System.Task_Primitives.Operations is\n       Reason  : System.Tasking.Task_States)\n    is\n       pragma Unreferenced (Reason);\n-\n       Result : Interfaces.C.int;\n \n    begin\n       if Single_Lock then\n-         Result := pthread_cond_wait\n-           (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n+         Result :=\n+           pthread_cond_wait\n+             (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n       else\n-         Result := pthread_cond_wait\n-           (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n+         Result :=\n+           pthread_cond_wait\n+             (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n       end if;\n \n       --  EINTR is not considered a failure\n@@ -451,7 +470,8 @@ package body System.Task_Primitives.Operations is\n    is\n       pragma Unreferenced (Reason);\n \n-      Check_Time : constant Duration := Monotonic_Clock;\n+      Base_Time  : constant Duration := Monotonic_Clock;\n+      Check_Time : Duration := Base_Time;\n       Abs_Time   : Duration;\n       Request    : aliased timespec;\n       Result     : Interfaces.C.int;\n@@ -470,21 +490,23 @@ package body System.Task_Primitives.Operations is\n          Request := To_Timespec (Abs_Time);\n \n          loop\n-            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n-              or else Self_ID.Pending_Priority_Change;\n+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n             if Single_Lock then\n-               Result := pthread_cond_timedwait\n-                 (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access,\n-                  Request'Access);\n+               Result :=\n+                 pthread_cond_timedwait\n+                   (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access,\n+                    Request'Access);\n \n             else\n-               Result := pthread_cond_timedwait\n-                 (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access,\n-                  Request'Access);\n+               Result :=\n+                 pthread_cond_timedwait\n+                   (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access,\n+                    Request'Access);\n             end if;\n \n-            exit when Abs_Time <= Monotonic_Clock;\n+            Check_Time := Monotonic_Clock;\n+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n \n             if Result = 0 or else errno = EINTR then\n                Timedout := False;\n@@ -506,7 +528,8 @@ package body System.Task_Primitives.Operations is\n       Time    : Duration;\n       Mode    : ST.Delay_Modes)\n    is\n-      Check_Time : constant Duration := Monotonic_Clock;\n+      Base_Time  : constant Duration := Monotonic_Clock;\n+      Check_Time : Duration := Base_Time;\n       Abs_Time   : Duration;\n       Request    : aliased timespec;\n       Result     : Interfaces.C.int;\n@@ -529,17 +552,22 @@ package body System.Task_Primitives.Operations is\n          Self_ID.Common.State := Delay_Sleep;\n \n          loop\n-            if Self_ID.Pending_Priority_Change then\n-               Self_ID.Pending_Priority_Change := False;\n-               Self_ID.Common.Base_Priority := Self_ID.New_Base_Priority;\n-               Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n-            end if;\n-\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n-            Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n-              Self_ID.Common.LL.L'Access, Request'Access);\n-            exit when Abs_Time <= Monotonic_Clock;\n+            if Single_Lock then\n+               Result := pthread_cond_timedwait\n+                           (Self_ID.Common.LL.CV'Access,\n+                            Single_RTS_Lock'Access,\n+                            Request'Access);\n+            else\n+               Result := pthread_cond_timedwait\n+                           (Self_ID.Common.LL.CV'Access,\n+                            Self_ID.Common.LL.L'Access,\n+                            Request'Access);\n+            end if;\n+\n+            Check_Time := Monotonic_Clock;\n+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n \n             pragma Assert (Result = 0\n               or else Result = ETIMEDOUT\n@@ -631,7 +659,7 @@ package body System.Task_Primitives.Operations is\n \n       use type System.Task_Info.Task_Info_Type;\n \n-      function To_Int is new Unchecked_Conversion\n+      function To_Int is new Ada.Unchecked_Conversion\n         (System.Task_Info.Thread_Scheduling_Policy, Interfaces.C.int);\n \n       function Get_Policy (Prio : System.Any_Priority) return Character;\n@@ -680,7 +708,7 @@ package body System.Task_Primitives.Operations is\n    procedure Enter_Task (Self_ID : Task_Id) is\n       Result : Interfaces.C.int;\n \n-      function To_Int is new Unchecked_Conversion\n+      function To_Int is new Ada.Unchecked_Conversion\n         (System.Task_Info.CPU_Number, Interfaces.C.int);\n \n       use System.Task_Info;\n@@ -756,8 +784,8 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Result = 0 or else Result = ENOMEM);\n \n       if Result = 0 then\n-         Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n-           Cond_Attr'Access);\n+         Result :=\n+           pthread_cond_init (Self_ID.Common.LL.CV'Access, Cond_Attr'Access);\n          pragma Assert (Result = 0 or else Result = ENOMEM);\n       end if;\n \n@@ -794,13 +822,12 @@ package body System.Task_Primitives.Operations is\n       Result      : Interfaces.C.int;\n \n       function Thread_Body_Access is new\n-        Unchecked_Conversion (System.Address, Thread_Body);\n-\n-      function To_Int is new Unchecked_Conversion\n+        Ada.Unchecked_Conversion (System.Address, Thread_Body);\n+      function To_Int is new Ada.Unchecked_Conversion\n         (System.Task_Info.Thread_Scheduling_Scope, Interfaces.C.int);\n-      function To_Int is new Unchecked_Conversion\n+      function To_Int is new Ada.Unchecked_Conversion\n         (System.Task_Info.Thread_Scheduling_Inheritance, Interfaces.C.int);\n-      function To_Int is new Unchecked_Conversion\n+      function To_Int is new Ada.Unchecked_Conversion\n         (System.Task_Info.Thread_Scheduling_Policy, Interfaces.C.int);\n \n    begin\n@@ -812,32 +839,38 @@ package body System.Task_Primitives.Operations is\n          return;\n       end if;\n \n-      Result := pthread_attr_setdetachstate\n-        (Attributes'Access, PTHREAD_CREATE_DETACHED);\n+      Result :=\n+        pthread_attr_setdetachstate\n+          (Attributes'Access, PTHREAD_CREATE_DETACHED);\n       pragma Assert (Result = 0);\n \n-      Result := pthread_attr_setstacksize\n-        (Attributes'Access, Interfaces.C.size_t (Stack_Size));\n+      Result :=\n+        pthread_attr_setstacksize\n+          (Attributes'Access, Interfaces.C.size_t (Stack_Size));\n       pragma Assert (Result = 0);\n \n       if T.Common.Task_Info /= null then\n-         Result := pthread_attr_setscope\n-           (Attributes'Access, To_Int (T.Common.Task_Info.Scope));\n+         Result :=\n+           pthread_attr_setscope\n+             (Attributes'Access, To_Int (T.Common.Task_Info.Scope));\n          pragma Assert (Result = 0);\n \n-         Result := pthread_attr_setinheritsched\n-           (Attributes'Access, To_Int (T.Common.Task_Info.Inheritance));\n+         Result :=\n+           pthread_attr_setinheritsched\n+             (Attributes'Access, To_Int (T.Common.Task_Info.Inheritance));\n          pragma Assert (Result = 0);\n \n-         Result := pthread_attr_setschedpolicy\n-           (Attributes'Access, To_Int (T.Common.Task_Info.Policy));\n+         Result :=\n+           pthread_attr_setschedpolicy\n+             (Attributes'Access, To_Int (T.Common.Task_Info.Policy));\n          pragma Assert (Result = 0);\n \n          Sched_Param.sched_priority :=\n            Interfaces.C.int (T.Common.Task_Info.Priority);\n \n-         Result := pthread_attr_setschedparam\n-           (Attributes'Access, Sched_Param'Access);\n+         Result :=\n+           pthread_attr_setschedparam\n+             (Attributes'Access, Sched_Param'Access);\n          pragma Assert (Result = 0);\n       end if;\n \n@@ -846,21 +879,21 @@ package body System.Task_Primitives.Operations is\n       --  do not need to manipulate caller's signal mask at this point.\n       --  All tasks in RTS will have All_Tasks_Mask initially.\n \n-      Result := pthread_create\n-        (T.Common.LL.Thread'Access,\n-         Attributes'Access,\n-         Thread_Body_Access (Wrapper),\n-         To_Address (T));\n+      Result :=\n+        pthread_create\n+          (T.Common.LL.Thread'Access,\n+           Attributes'Access,\n+           Thread_Body_Access (Wrapper),\n+           To_Address (T));\n \n       if Result /= 0\n         and then T.Common.Task_Info /= null\n         and then T.Common.Task_Info.Scope = PTHREAD_SCOPE_SYSTEM\n       then\n-         --  The pthread_create call may have failed because we\n-         --  asked for a system scope pthread and none were\n-         --  available (probably because the program was not executed\n-         --  by the superuser). Let's try for a process scope pthread\n-         --  instead of raising Tasking_Error.\n+         --  The pthread_create call may have failed because we asked for a\n+         --  system scope pthread and none were available (probably because\n+         --  the program was not executed by the superuser). Let's try for\n+         --  a process scope pthread instead of raising Tasking_Error.\n \n          System.IO.Put_Line\n            (\"Request for PTHREAD_SCOPE_SYSTEM in Task_Info pragma for task\");\n@@ -870,15 +903,17 @@ package body System.Task_Primitives.Operations is\n          System.IO.Put_Line (\"Scope changed to PTHREAD_SCOPE_PROCESS\");\n \n          T.Common.Task_Info.Scope := PTHREAD_SCOPE_PROCESS;\n-         Result := pthread_attr_setscope\n-           (Attributes'Access, To_Int (T.Common.Task_Info.Scope));\n+         Result :=\n+           pthread_attr_setscope\n+             (Attributes'Access, To_Int (T.Common.Task_Info.Scope));\n          pragma Assert (Result = 0);\n \n-         Result := pthread_create\n-           (T.Common.LL.Thread'Access,\n-            Attributes'Access,\n-            Thread_Body_Access (Wrapper),\n-            To_Address (T));\n+         Result :=\n+           pthread_create\n+             (T.Common.LL.Thread'Access,\n+              Attributes'Access,\n+              Thread_Body_Access (Wrapper),\n+              To_Address (T));\n       end if;\n \n       pragma Assert (Result = 0 or else Result = EAGAIN);\n@@ -908,7 +943,7 @@ package body System.Task_Primitives.Operations is\n       Is_Self : constant Boolean := T = Self;\n \n       procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n+        Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n    begin\n       if not Single_Lock then\n@@ -946,8 +981,10 @@ package body System.Task_Primitives.Operations is\n    procedure Abort_Task (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n-      Result := pthread_kill (T.Common.LL.Thread,\n-        Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n+      Result :=\n+        pthread_kill\n+          (T.Common.LL.Thread,\n+           Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n       pragma Assert (Result = 0);\n    end Abort_Task;\n \n@@ -959,9 +996,9 @@ package body System.Task_Primitives.Operations is\n       Mutex_Attr : aliased pthread_mutexattr_t;\n       Cond_Attr  : aliased pthread_condattr_t;\n       Result     : Interfaces.C.int;\n+\n    begin\n-      --  Initialize internal state. It is always initialized to False (ARM\n-      --  D.10 par. 6).\n+      --  Initialize internal state (always to False (RM D.10(6))\n \n       S.State := False;\n       S.Waiting := False;\n@@ -1012,7 +1049,6 @@ package body System.Task_Primitives.Operations is\n          if Result = ENOMEM then\n             Result := pthread_condattr_destroy (Cond_Attr'Access);\n             pragma Assert (Result = 0);\n-\n             raise Storage_Error;\n          end if;\n       end if;\n@@ -1026,7 +1062,8 @@ package body System.Task_Primitives.Operations is\n    --------------\n \n    procedure Finalize (S : in out Suspension_Object) is\n-      Result  : Interfaces.C.int;\n+      Result : Interfaces.C.int;\n+\n    begin\n       --  Destroy internal mutex\n \n@@ -1056,7 +1093,8 @@ package body System.Task_Primitives.Operations is\n    ---------------\n \n    procedure Set_False (S : in out Suspension_Object) is\n-      Result  : Interfaces.C.int;\n+      Result : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n@@ -1077,6 +1115,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Set_True (S : in out Suspension_Object) is\n       Result : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n@@ -1094,6 +1133,7 @@ package body System.Task_Primitives.Operations is\n \n          Result := pthread_cond_signal (S.CV'Access);\n          pragma Assert (Result = 0);\n+\n       else\n          S.State := True;\n       end if;\n@@ -1110,16 +1150,18 @@ package body System.Task_Primitives.Operations is\n \n    procedure Suspend_Until_True (S : in out Suspension_Object) is\n       Result : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n       Result := pthread_mutex_lock (S.L'Access);\n       pragma Assert (Result = 0);\n \n       if S.Waiting then\n+\n          --  Program_Error must be raised upon calling Suspend_Until_True\n          --  if another task is already waiting on that suspension object\n-         --  (ARM D.10 par. 10).\n+         --  (RM D.10(10)).\n \n          Result := pthread_mutex_unlock (S.L'Access);\n          pragma Assert (Result = 0);\n@@ -1273,8 +1315,8 @@ package body System.Task_Primitives.Operations is\n \n       --  Install the abort-signal handler\n \n-      if State (System.Interrupt_Management.Abort_Task_Interrupt)\n-        /= Default\n+      if State\n+          (System.Interrupt_Management.Abort_Task_Interrupt) /= Default\n       then\n          act.sa_flags := 0;\n          act.sa_handler := Abort_Handler'Address;\n@@ -1284,10 +1326,10 @@ package body System.Task_Primitives.Operations is\n          act.sa_mask := Tmp_Set;\n \n          Result :=\n-           sigaction (\n-             Signal (System.Interrupt_Management.Abort_Task_Interrupt),\n-             act'Unchecked_Access,\n-             old_act'Unchecked_Access);\n+           sigaction\n+             (Signal (System.Interrupt_Management.Abort_Task_Interrupt),\n+              act'Unchecked_Access,\n+              old_act'Unchecked_Access);\n          pragma Assert (Result = 0);\n       end if;\n    end Initialize;"}, {"sha": "8d149590fbc62c95c25a0eb50961859d2bb467bb", "filename": "gcc/ada/s-taprop-linux.adb", "status": "modified", "additions": 99, "deletions": 60, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taprop-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taprop-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-linux.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2006, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2007, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -71,8 +71,8 @@ with Ada.Exceptions;\n --           Raise_From_Signal_Handler\n --           Exception_Id\n \n-with Unchecked_Conversion;\n-with Unchecked_Deallocation;\n+with Ada.Unchecked_Conversion;\n+with Ada.Unchecked_Deallocation;\n \n package body System.Task_Primitives.Operations is\n \n@@ -110,17 +110,16 @@ package body System.Task_Primitives.Operations is\n    --  The followings are internal configuration constants needed\n \n    Next_Serial_Number : Task_Serial_Number := 100;\n-   --  We start at 100, to reserve some special values for\n-   --  using in error checking.\n+   --  We start at 100 (reserve some special values for using in error checks)\n \n    Time_Slice_Val : Integer;\n    pragma Import (C, Time_Slice_Val, \"__gl_time_slice_val\");\n \n    Dispatching_Policy : Character;\n    pragma Import (C, Dispatching_Policy, \"__gl_task_dispatching_policy\");\n \n-   --  The following are effectively constants, but they need to\n-   --  be initialized by calling a pthread_ function.\n+   --  The following are effectively constants, but they need to be initialized\n+   --  by calling a pthread_ function.\n \n    Mutex_Attr   : aliased pthread_mutexattr_t;\n    Cond_Attr    : aliased pthread_condattr_t;\n@@ -173,7 +172,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Abort_Handler (signo : Signal);\n \n-   function To_pthread_t is new Unchecked_Conversion\n+   function To_pthread_t is new Ada.Unchecked_Conversion\n      (unsigned_long, System.OS_Interface.pthread_t);\n \n    -------------------\n@@ -200,8 +199,11 @@ package body System.Task_Primitives.Operations is\n \n          --  Make sure signals used for RTS internal purpose are unmasked\n \n-         Result := pthread_sigmask (SIG_UNBLOCK,\n-           Unblocked_Signal_Mask'Unchecked_Access, Old_Set'Unchecked_Access);\n+         Result :=\n+           pthread_sigmask\n+             (SIG_UNBLOCK,\n+              Unblocked_Signal_Mask'Unchecked_Access,\n+              Old_Set'Unchecked_Access);\n          pragma Assert (Result = 0);\n \n          raise Standard'Abort_Signal;\n@@ -272,6 +274,7 @@ package body System.Task_Primitives.Operations is\n       pragma Unreferenced (Prio);\n \n       Result : Interfaces.C.int;\n+\n    begin\n       Result := pthread_mutex_init (L, Mutex_Attr'Access);\n \n@@ -284,7 +287,8 @@ package body System.Task_Primitives.Operations is\n    end Initialize_Lock;\n \n    procedure Initialize_Lock\n-     (L : not null access RTS_Lock; Level : Lock_Level)\n+     (L     : not null access RTS_Lock;\n+      Level : Lock_Level)\n    is\n       pragma Unreferenced (Level);\n \n@@ -323,7 +327,8 @@ package body System.Task_Primitives.Operations is\n    ----------------\n \n    procedure Write_Lock\n-     (L : not null access Lock; Ceiling_Violation : out Boolean)\n+     (L                 : not null access Lock;\n+      Ceiling_Violation : out Boolean)\n    is\n       Result : Interfaces.C.int;\n    begin\n@@ -361,7 +366,9 @@ package body System.Task_Primitives.Operations is\n    ---------------\n \n    procedure Read_Lock\n-     (L : not null access Lock; Ceiling_Violation : out Boolean) is\n+     (L                 : not null access Lock;\n+      Ceiling_Violation : out Boolean)\n+   is\n    begin\n       Write_Lock (L, Ceiling_Violation);\n    end Read_Lock;\n@@ -378,7 +385,8 @@ package body System.Task_Primitives.Operations is\n    end Unlock;\n \n    procedure Unlock\n-     (L : not null access RTS_Lock; Global_Lock : Boolean := False)\n+     (L           : not null access RTS_Lock;\n+      Global_Lock : Boolean := False)\n    is\n       Result : Interfaces.C.int;\n    begin\n@@ -397,6 +405,21 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n+   -----------------\n+   -- Set_Ceiling --\n+   -----------------\n+\n+   --  Dynamic priority ceilings are not supported by the underlying system\n+\n+   procedure Set_Ceiling\n+     (L    : not null access Lock;\n+      Prio : System.Any_Priority)\n+   is\n+      pragma Unreferenced (L, Prio);\n+   begin\n+      null;\n+   end Set_Ceiling;\n+\n    -----------\n    -- Sleep --\n    -----------\n@@ -413,11 +436,13 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Self_ID = Self);\n \n       if Single_Lock then\n-         Result := pthread_cond_wait\n-           (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n+         Result :=\n+           pthread_cond_wait\n+             (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n       else\n-         Result := pthread_cond_wait\n-           (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n+         Result :=\n+           pthread_cond_wait\n+             (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n       end if;\n \n       --  EINTR is not considered a failure\n@@ -443,7 +468,8 @@ package body System.Task_Primitives.Operations is\n    is\n       pragma Unreferenced (Reason);\n \n-      Check_Time : constant Duration := Monotonic_Clock;\n+      Base_Time  : constant Duration := Monotonic_Clock;\n+      Check_Time : Duration := Base_Time;\n       Abs_Time   : Duration;\n       Request    : aliased timespec;\n       Result     : Interfaces.C.int;\n@@ -462,24 +488,30 @@ package body System.Task_Primitives.Operations is\n          Request := To_Timespec (Abs_Time);\n \n          loop\n-            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n-              or else Self_ID.Pending_Priority_Change;\n+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n             if Single_Lock then\n-               Result := pthread_cond_timedwait\n-                 (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access,\n-                  Request'Access);\n+               Result :=\n+                 pthread_cond_timedwait\n+                   (Self_ID.Common.LL.CV'Access,\n+                    Single_RTS_Lock'Access,\n+                    Request'Access);\n \n             else\n-               Result := pthread_cond_timedwait\n-                 (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access,\n-                  Request'Access);\n+               Result :=\n+                 pthread_cond_timedwait\n+                   (Self_ID.Common.LL.CV'Access,\n+                    Self_ID.Common.LL.L'Access,\n+                    Request'Access);\n             end if;\n \n-            exit when Abs_Time <= Monotonic_Clock;\n+            Check_Time := Monotonic_Clock;\n+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n+\n+            if Result = 0 or else Result = EINTR then\n+\n+               --  Somebody may have called Wakeup for us\n \n-            if Result = 0 or Result = EINTR then\n-               --  somebody may have called Wakeup for us\n                Timedout := False;\n                exit;\n             end if;\n@@ -493,16 +525,16 @@ package body System.Task_Primitives.Operations is\n    -- Timed_Delay --\n    -----------------\n \n-   --  This is for use in implementing delay statements, so\n-   --  we assume the caller is abort-deferred but is holding\n-   --  no locks.\n+   --  This is for use in implementing delay statements, so we assume the\n+   --  caller is abort-deferred but is holding no locks.\n \n    procedure Timed_Delay\n      (Self_ID : Task_Id;\n       Time    : Duration;\n       Mode    : ST.Delay_Modes)\n    is\n-      Check_Time : constant Duration := Monotonic_Clock;\n+      Base_Time  : constant Duration := Monotonic_Clock;\n+      Check_Time : Duration := Base_Time;\n       Abs_Time   : Duration;\n       Request    : aliased timespec;\n \n@@ -527,12 +559,6 @@ package body System.Task_Primitives.Operations is\n          Self_ID.Common.State := Delay_Sleep;\n \n          loop\n-            if Self_ID.Pending_Priority_Change then\n-               Self_ID.Pending_Priority_Change := False;\n-               Self_ID.Common.Base_Priority := Self_ID.New_Base_Priority;\n-               Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n-            end if;\n-\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n             if Single_Lock then\n@@ -547,7 +573,8 @@ package body System.Task_Primitives.Operations is\n                             Request'Access);\n             end if;\n \n-            exit when Abs_Time <= Monotonic_Clock;\n+            Check_Time := Monotonic_Clock;\n+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n \n             pragma Assert (Result = 0 or else\n               Result = ETIMEDOUT or else\n@@ -638,29 +665,32 @@ package body System.Task_Primitives.Operations is\n    begin\n       T.Common.Current_Priority := Prio;\n \n-      --  Priorities are in range 1 .. 99 on GNU/Linux, so we map\n-      --  map 0 .. 98 to 1 .. 99\n+      --  Priorities are 1 .. 99 on GNU/Linux, so we map 0 .. 98 to 1 .. 99\n \n       Param.sched_priority := Interfaces.C.int (Prio) + 1;\n \n       if Dispatching_Policy = 'R'\n         or else Priority_Specific_Policy = 'R'\n         or else Time_Slice_Val > 0\n       then\n-         Result := pthread_setschedparam\n-           (T.Common.LL.Thread, SCHED_RR, Param'Access);\n+         Result :=\n+           pthread_setschedparam\n+             (T.Common.LL.Thread, SCHED_RR, Param'Access);\n \n       elsif Dispatching_Policy = 'F'\n         or else Priority_Specific_Policy = 'F'\n         or else Time_Slice_Val = 0\n       then\n-         Result := pthread_setschedparam\n-           (T.Common.LL.Thread, SCHED_FIFO, Param'Access);\n+         Result :=\n+           pthread_setschedparam\n+             (T.Common.LL.Thread, SCHED_FIFO, Param'Access);\n \n       else\n          Param.sched_priority := 0;\n-         Result := pthread_setschedparam\n-           (T.Common.LL.Thread, SCHED_OTHER, Param'Access);\n+         Result :=\n+           pthread_setschedparam\n+             (T.Common.LL.Thread,\n+              SCHED_OTHER, Param'Access);\n       end if;\n \n       pragma Assert (Result = 0 or else Result = EPERM);\n@@ -832,7 +862,7 @@ package body System.Task_Primitives.Operations is\n       Is_Self : constant Boolean := T = Self;\n \n       procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n+        Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n    begin\n       if not Single_Lock then\n@@ -870,8 +900,10 @@ package body System.Task_Primitives.Operations is\n    procedure Abort_Task (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n-      Result := pthread_kill (T.Common.LL.Thread,\n-        Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n+      Result :=\n+        pthread_kill\n+          (T.Common.LL.Thread,\n+           Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n       pragma Assert (Result = 0);\n    end Abort_Task;\n \n@@ -881,9 +913,9 @@ package body System.Task_Primitives.Operations is\n \n    procedure Initialize (S : in out Suspension_Object) is\n       Result : Interfaces.C.int;\n+\n    begin\n-      --  Initialize internal state. It is always initialized to False (ARM\n-      --  D.10 par. 6).\n+      --  Initialize internal state (always to False (RM D.10(6)))\n \n       S.State := False;\n       S.Waiting := False;\n@@ -919,7 +951,8 @@ package body System.Task_Primitives.Operations is\n    --------------\n \n    procedure Finalize (S : in out Suspension_Object) is\n-      Result  : Interfaces.C.int;\n+      Result : Interfaces.C.int;\n+\n    begin\n       --  Destroy internal mutex\n \n@@ -949,7 +982,8 @@ package body System.Task_Primitives.Operations is\n    ---------------\n \n    procedure Set_False (S : in out Suspension_Object) is\n-      Result  : Interfaces.C.int;\n+      Result : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n@@ -970,6 +1004,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Set_True (S : in out Suspension_Object) is\n       Result : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n@@ -987,6 +1022,7 @@ package body System.Task_Primitives.Operations is\n \n          Result := pthread_cond_signal (S.CV'Access);\n          pragma Assert (Result = 0);\n+\n       else\n          S.State := True;\n       end if;\n@@ -1003,16 +1039,18 @@ package body System.Task_Primitives.Operations is\n \n    procedure Suspend_Until_True (S : in out Suspension_Object) is\n       Result : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n       Result := pthread_mutex_lock (S.L'Access);\n       pragma Assert (Result = 0);\n \n       if S.Waiting then\n+\n          --  Program_Error must be raised upon calling Suspend_Until_True\n          --  if another task is already waiting on that suspension object\n-         --  (ARM D.10 par. 10).\n+         --  (RM D.10(10)).\n \n          Result := pthread_mutex_unlock (S.L'Access);\n          pragma Assert (Result = 0);\n@@ -1036,7 +1074,8 @@ package body System.Task_Primitives.Operations is\n          pragma Assert (Result = 0);\n \n          SSL.Abort_Undefer.all;\n-      end if;\n+      end\n+      if;\n    end Suspend_Until_True;\n \n    ----------------\n@@ -1159,8 +1198,8 @@ package body System.Task_Primitives.Operations is\n \n       --  Install the abort-signal handler\n \n-      if State (System.Interrupt_Management.Abort_Task_Interrupt)\n-        /= Default\n+      if State\n+          (System.Interrupt_Management.Abort_Task_Interrupt) /= Default\n       then\n          act.sa_flags := 0;\n          act.sa_handler := Abort_Handler'Address;"}, {"sha": "361d6fa67fb5bf9cf6add5a967aed1f3958e0a46", "filename": "gcc/ada/s-taprop-lynxos.adb", "status": "modified", "additions": 138, "deletions": 97, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taprop-lynxos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taprop-lynxos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-lynxos.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2006, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2007, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -67,7 +67,7 @@ with System.Soft_Links;\n --  For example when using the restricted run time, it is replaced by\n --  System.Tasking.Restricted.Stages.\n \n-with Unchecked_Deallocation;\n+with Ada.Unchecked_Deallocation;\n \n package body System.Task_Primitives.Operations is\n \n@@ -190,17 +190,18 @@ package body System.Task_Primitives.Operations is\n       end if;\n \n       if T.Deferral_Level = 0\n-        and then T.Pending_ATC_Level < T.ATC_Nesting_Level and then\n-        not T.Aborting\n+        and then T.Pending_ATC_Level < T.ATC_Nesting_Level\n+        and then not T.Aborting\n       then\n          T.Aborting := True;\n \n          --  Make sure signals used for RTS internal purpose are unmasked\n \n          Result :=\n-           pthread_sigmask (SIG_UNBLOCK,\n-                            Unblocked_Signal_Mask'Unchecked_Access,\n-                            Old_Set'Unchecked_Access);\n+           pthread_sigmask\n+             (SIG_UNBLOCK,\n+              Unblocked_Signal_Mask'Unchecked_Access,\n+              Old_Set'Unchecked_Access);\n          pragma Assert (Result = 0);\n \n          raise Standard'Abort_Signal;\n@@ -285,12 +286,13 @@ package body System.Task_Primitives.Operations is\n    end Initialize_Lock;\n \n    procedure Initialize_Lock\n-     (L : not null access RTS_Lock; Level : Lock_Level)\n+     (L     : not null access RTS_Lock;\n+      Level : Lock_Level)\n    is\n       pragma Unreferenced (Level);\n \n       Attributes : aliased pthread_mutexattr_t;\n-      Result : Interfaces.C.int;\n+      Result     : Interfaces.C.int;\n \n    begin\n       Result := pthread_mutexattr_init (Attributes'Access);\n@@ -335,10 +337,11 @@ package body System.Task_Primitives.Operations is\n    ----------------\n \n    procedure Write_Lock\n-     (L : not null access Lock; Ceiling_Violation : out Boolean)\n+     (L                 : not null access Lock;\n+      Ceiling_Violation : out Boolean)\n    is\n       Result : Interfaces.C.int;\n-      T : constant Task_Id := Self;\n+      T      : constant Task_Id := Self;\n \n    begin\n       if Locking_Policy = 'C' then\n@@ -365,7 +368,8 @@ package body System.Task_Primitives.Operations is\n    --  No tricks on RTS_Locks\n \n    procedure Write_Lock\n-     (L : not null access RTS_Lock; Global_Lock : Boolean := False)\n+     (L           : not null access RTS_Lock;\n+      Global_Lock : Boolean := False)\n    is\n       Result : Interfaces.C.int;\n    begin\n@@ -389,7 +393,9 @@ package body System.Task_Primitives.Operations is\n    ---------------\n \n    procedure Read_Lock\n-     (L : not null access Lock; Ceiling_Violation : out Boolean) is\n+     (L                 : not null access Lock;\n+      Ceiling_Violation : out Boolean)\n+   is\n    begin\n       Write_Lock (L, Ceiling_Violation);\n    end Read_Lock;\n@@ -400,7 +406,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Unlock (L : not null access Lock) is\n       Result : Interfaces.C.int;\n-      T : constant Task_Id := Self;\n+      T      : constant Task_Id := Self;\n \n    begin\n       Result := pthread_mutex_unlock (L.Mutex'Access);\n@@ -414,7 +420,8 @@ package body System.Task_Primitives.Operations is\n    end Unlock;\n \n    procedure Unlock\n-     (L : not null access RTS_Lock; Global_Lock : Boolean := False)\n+     (L           : not null access RTS_Lock;\n+      Global_Lock : Boolean := False)\n    is\n       Result : Interfaces.C.int;\n    begin\n@@ -433,6 +440,21 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n+   -----------------\n+   -- Set_Ceiling --\n+   -----------------\n+\n+   --  Dynamic priority ceilings are not supported by the underlying system\n+\n+   procedure Set_Ceiling\n+     (L    : not null access Lock;\n+      Prio : System.Any_Priority)\n+   is\n+      pragma Unreferenced (L, Prio);\n+   begin\n+      null;\n+   end Set_Ceiling;\n+\n    -----------\n    -- Sleep --\n    -----------\n@@ -446,11 +468,13 @@ package body System.Task_Primitives.Operations is\n \n    begin\n       if Single_Lock then\n-         Result := pthread_cond_wait\n-           (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n+         Result :=\n+           pthread_cond_wait\n+             (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n       else\n-         Result := pthread_cond_wait\n-           (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n+         Result :=\n+           pthread_cond_wait\n+             (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n       end if;\n \n       --  EINTR is not considered a failure\n@@ -476,7 +500,8 @@ package body System.Task_Primitives.Operations is\n    is\n       pragma Unreferenced (Reason);\n \n-      Check_Time : constant Duration := Monotonic_Clock;\n+      Base_Time  : constant Duration := Monotonic_Clock;\n+      Check_Time : Duration := Base_Time;\n       Rel_Time   : Duration;\n       Abs_Time   : Duration;\n       Request    : aliased timespec;\n@@ -509,21 +534,23 @@ package body System.Task_Primitives.Operations is\n          end if;\n \n          loop\n-            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n-              or else Self_ID.Pending_Priority_Change;\n+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n             if Single_Lock then\n-               Result := pthread_cond_timedwait\n-                 (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access,\n-                  Request'Access);\n+               Result :=\n+                 pthread_cond_timedwait\n+                   (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access,\n+                    Request'Access);\n \n             else\n-               Result := pthread_cond_timedwait\n-                 (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access,\n-                  Request'Access);\n+               Result :=\n+                 pthread_cond_timedwait\n+                   (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access,\n+                    Request'Access);\n             end if;\n \n-            exit when Abs_Time <= Monotonic_Clock;\n+            Check_Time := Monotonic_Clock;\n+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n \n             if Result = 0 or Result = EINTR then\n \n@@ -550,7 +577,8 @@ package body System.Task_Primitives.Operations is\n       Time    : Duration;\n       Mode    : ST.Delay_Modes)\n    is\n-      Check_Time : constant Duration := Monotonic_Clock;\n+      Base_Time  : constant Duration := Monotonic_Clock;\n+      Check_Time : Duration := Base_Time;\n       Abs_Time   : Duration;\n       Rel_Time   : Duration;\n       Request    : aliased timespec;\n@@ -592,31 +620,28 @@ package body System.Task_Primitives.Operations is\n          Self_ID.Common.State := Delay_Sleep;\n \n          loop\n-            if Self_ID.Pending_Priority_Change then\n-               Self_ID.Pending_Priority_Change := False;\n-               Self_ID.Common.Base_Priority := Self_ID.New_Base_Priority;\n-               Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n-            end if;\n-\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n             if Single_Lock then\n-               Result := pthread_cond_timedwait\n-                           (Self_ID.Common.LL.CV'Access,\n-                            Single_RTS_Lock'Access,\n-                            Request'Access);\n+               Result :=\n+                 pthread_cond_timedwait\n+                   (Self_ID.Common.LL.CV'Access,\n+                    Single_RTS_Lock'Access,\n+                    Request'Access);\n             else\n-               Result := pthread_cond_timedwait\n-                           (Self_ID.Common.LL.CV'Access,\n-                            Self_ID.Common.LL.L'Access,\n-                            Request'Access);\n+               Result :=\n+                 pthread_cond_timedwait\n+                   (Self_ID.Common.LL.CV'Access,\n+                    Self_ID.Common.LL.L'Access,\n+                    Request'Access);\n             end if;\n \n-            exit when Abs_Time <= Monotonic_Clock;\n+            Check_Time := Monotonic_Clock;\n+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n \n-            pragma Assert (Result = 0\n-                             or else Result = ETIMEDOUT\n-                             or else Result = EINTR);\n+            pragma Assert (Result = 0         or else\n+                           Result = ETIMEDOUT or else\n+                           Result = EINTR);\n          end loop;\n \n          Self_ID.Common.State := Runnable;\n@@ -639,8 +664,9 @@ package body System.Task_Primitives.Operations is\n       TS     : aliased timespec;\n       Result : Interfaces.C.int;\n    begin\n-      Result := clock_gettime\n-        (clock_id => CLOCK_REALTIME, tp => TS'Unchecked_Access);\n+      Result :=\n+        clock_gettime\n+          (clock_id => CLOCK_REALTIME, tp => TS'Unchecked_Access);\n       pragma Assert (Result = 0);\n       return To_Duration (TS);\n    end Monotonic_Clock;\n@@ -653,8 +679,9 @@ package body System.Task_Primitives.Operations is\n       Res    : aliased timespec;\n       Result : Interfaces.C.int;\n    begin\n-      Result := clock_getres\n-        (clock_id => CLOCK_REALTIME, Res => Res'Unchecked_Access);\n+      Result :=\n+        clock_getres\n+          (clock_id => CLOCK_REALTIME, Res => Res'Unchecked_Access);\n       pragma Assert (Result = 0);\n       return To_Duration (Res);\n    end RT_Resolution;\n@@ -705,22 +732,25 @@ package body System.Task_Primitives.Operations is\n \n       if Time_Slice_Supported\n         and then (Dispatching_Policy = 'R'\n-                  or else Priority_Specific_Policy = 'R'\n-                  or else Time_Slice_Val > 0)\n+                   or else Priority_Specific_Policy = 'R'\n+                   or else Time_Slice_Val > 0)\n       then\n-         Result := pthread_setschedparam\n-           (T.Common.LL.Thread, SCHED_RR, Param'Access);\n+         Result :=\n+           pthread_setschedparam\n+             (T.Common.LL.Thread, SCHED_RR, Param'Access);\n \n       elsif Dispatching_Policy = 'F'\n         or else Priority_Specific_Policy = 'F'\n         or else Time_Slice_Val = 0\n       then\n-         Result := pthread_setschedparam\n-           (T.Common.LL.Thread, SCHED_FIFO, Param'Access);\n+         Result :=\n+           pthread_setschedparam\n+             (T.Common.LL.Thread, SCHED_FIFO, Param'Access);\n \n       else\n-         Result := pthread_setschedparam\n-           (T.Common.LL.Thread, SCHED_OTHER, Param'Access);\n+         Result :=\n+           pthread_setschedparam\n+             (T.Common.LL.Thread, SCHED_OTHER, Param'Access);\n       end if;\n \n       pragma Assert (Result = 0);\n@@ -742,9 +772,9 @@ package body System.Task_Primitives.Operations is\n       Set_OS_Priority (T, Prio);\n \n       if Locking_Policy = 'C' then\n-         --  Annex D requirements: loss of inheritance puts task at the\n-         --  beginning of the queue for that prio; copied from 5ztaprop\n-         --  (VxWorks)\n+\n+         --  Annex D requirements: loss of inheritance puts task at the start\n+         --  of the queue for that prio; copied from 5ztaprop (VxWorks).\n \n          if Loss_Of_Inheritance\n            and then Prio < T.Common.Current_Priority then\n@@ -848,8 +878,9 @@ package body System.Task_Primitives.Operations is\n          pragma Assert (Result = 0 or else Result = ENOMEM);\n \n          if Result = 0 then\n-            Result := pthread_mutex_init (Self_ID.Common.LL.L'Access,\n-              Mutex_Attr'Access);\n+            Result :=\n+              pthread_mutex_init\n+                (Self_ID.Common.LL.L'Access, Mutex_Attr'Access);\n             pragma Assert (Result = 0 or else Result = ENOMEM);\n          end if;\n \n@@ -866,8 +897,8 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Result = 0 or else Result = ENOMEM);\n \n       if Result = 0 then\n-         Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n-           Cond_Attr'Access);\n+         Result :=\n+           pthread_cond_init (Self_ID.Common.LL.CV'Access, Cond_Attr'Access);\n          pragma Assert (Result = 0 or else Result = ENOMEM);\n       end if;\n \n@@ -909,7 +940,7 @@ package body System.Task_Primitives.Operations is\n       if Stack_Base_Available then\n \n          --  If Stack Checking is supported then allocate 2 additional pages:\n-         --\n+\n          --  In the worst case, stack is allocated at something like\n          --  N * Get_Page_Size - epsilon, we need to add the size for 2 pages\n          --  to be sure the effective stack size is greater than what\n@@ -926,21 +957,24 @@ package body System.Task_Primitives.Operations is\n          return;\n       end if;\n \n-      Result := pthread_attr_setdetachstate\n-        (Attributes'Access, PTHREAD_CREATE_DETACHED);\n+      Result :=\n+        pthread_attr_setdetachstate\n+          (Attributes'Access, PTHREAD_CREATE_DETACHED);\n       pragma Assert (Result = 0);\n \n-      Result := pthread_attr_setstacksize\n-        (Attributes'Access, Adjusted_Stack_Size);\n+      Result :=\n+        pthread_attr_setstacksize\n+          (Attributes'Access, Adjusted_Stack_Size);\n       pragma Assert (Result = 0);\n \n       if T.Common.Task_Info /= Default_Scope then\n \n          --  We are assuming that Scope_Type has the same values than the\n          --  corresponding C macros\n \n-         Result := pthread_attr_setscope\n-           (Attributes'Access, Task_Info_Type'Pos (T.Common.Task_Info));\n+         Result :=\n+           pthread_attr_setscope\n+             (Attributes'Access, Task_Info_Type'Pos (T.Common.Task_Info));\n          pragma Assert (Result = 0);\n       end if;\n \n@@ -949,11 +983,12 @@ package body System.Task_Primitives.Operations is\n       --  do not need to manipulate caller's signal mask at this point.\n       --  All tasks in RTS will have All_Tasks_Mask initially.\n \n-      Result := pthread_create\n-        (T.Common.LL.Thread'Access,\n-         Attributes'Access,\n-         Thread_Body_Access (Wrapper),\n-         To_Address (T));\n+      Result :=\n+        pthread_create\n+          (T.Common.LL.Thread'Access,\n+           Attributes'Access,\n+           Thread_Body_Access (Wrapper),\n+           To_Address (T));\n       pragma Assert (Result = 0 or else Result = EAGAIN);\n \n       Succeeded := Result = 0;\n@@ -974,7 +1009,7 @@ package body System.Task_Primitives.Operations is\n       Is_Self : constant Boolean := T = Self;\n \n       procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n+        Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n    begin\n       if not Single_Lock then\n@@ -995,7 +1030,6 @@ package body System.Task_Primitives.Operations is\n          Result := st_setspecific (ATCB_Key, System.Null_Address);\n          pragma Assert (Result = 0);\n       end if;\n-\n    end Finalize_TCB;\n \n    ---------------\n@@ -1014,8 +1048,10 @@ package body System.Task_Primitives.Operations is\n    procedure Abort_Task (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n-      Result := pthread_kill (T.Common.LL.Thread,\n-         Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n+      Result :=\n+        pthread_kill\n+          (T.Common.LL.Thread,\n+           Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n       pragma Assert (Result = 0);\n    end Abort_Task;\n \n@@ -1029,8 +1065,7 @@ package body System.Task_Primitives.Operations is\n       Result     : Interfaces.C.int;\n \n    begin\n-      --  Initialize internal state. It is always initialized to False (ARM\n-      --  D.10 par. 6).\n+      --  Initialize internal state (always to False (RM D.10(6)))\n \n       S.State := False;\n       S.Waiting := False;\n@@ -1095,7 +1130,8 @@ package body System.Task_Primitives.Operations is\n    --------------\n \n    procedure Finalize (S : in out Suspension_Object) is\n-      Result  : Interfaces.C.int;\n+      Result : Interfaces.C.int;\n+\n    begin\n       --  Destroy internal mutex\n \n@@ -1125,7 +1161,8 @@ package body System.Task_Primitives.Operations is\n    ---------------\n \n    procedure Set_False (S : in out Suspension_Object) is\n-      Result  : Interfaces.C.int;\n+      Result : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n@@ -1146,6 +1183,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Set_True (S : in out Suspension_Object) is\n       Result : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n@@ -1154,15 +1192,15 @@ package body System.Task_Primitives.Operations is\n \n       --  If there is already a task waiting on this suspension object then\n       --  we resume it, leaving the state of the suspension object to False,\n-      --  as it is specified in ARM D.10 par. 9. Otherwise, it just leaves\n-      --  the state to True.\n+      --  as specified in (RM D.10(9)). Otherwise, just leave state set True.\n \n       if S.Waiting then\n          S.Waiting := False;\n          S.State := False;\n \n          Result := pthread_cond_signal (S.CV'Access);\n          pragma Assert (Result = 0);\n+\n       else\n          S.State := True;\n       end if;\n@@ -1179,27 +1217,30 @@ package body System.Task_Primitives.Operations is\n \n    procedure Suspend_Until_True (S : in out Suspension_Object) is\n       Result : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n       Result := pthread_mutex_lock (S.L'Access);\n       pragma Assert (Result = 0);\n \n       if S.Waiting then\n+\n          --  Program_Error must be raised upon calling Suspend_Until_True\n          --  if another task is already waiting on that suspension object\n-         --  (ARM D.10 par. 10).\n+         --  (RM D.10 (10)).\n \n          Result := pthread_mutex_unlock (S.L'Access);\n          pragma Assert (Result = 0);\n \n          SSL.Abort_Undefer.all;\n \n          raise Program_Error;\n+\n       else\n          --  Suspend the task if the state is False. Otherwise, the task\n          --  continues its execution, and the state of the suspension object\n-         --  is set to False (ARM D.10 par. 9).\n+         --  is set to False (RM D.10(9)).\n \n          if S.State then\n             S.State := False;\n@@ -1219,7 +1260,7 @@ package body System.Task_Primitives.Operations is\n    -- Check_Exit --\n    ----------------\n \n-   --  Dummy versions\n+   --  Dummy version\n \n    function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n       pragma Unreferenced (Self_ID);\n@@ -1343,8 +1384,8 @@ package body System.Task_Primitives.Operations is\n \n       --  Install the abort-signal handler\n \n-      if State (System.Interrupt_Management.Abort_Task_Interrupt)\n-        /= Default\n+      if State\n+          (System.Interrupt_Management.Abort_Task_Interrupt) /= Default\n       then\n          act.sa_flags := 0;\n          act.sa_handler := Abort_Handler'Address;\n@@ -1355,9 +1396,9 @@ package body System.Task_Primitives.Operations is\n \n          Result :=\n            sigaction\n-           (Signal (System.Interrupt_Management.Abort_Task_Interrupt),\n-            act'Unchecked_Access,\n-            old_act'Unchecked_Access);\n+             (Signal (System.Interrupt_Management.Abort_Task_Interrupt),\n+              act'Unchecked_Access,\n+              old_act'Unchecked_Access);\n \n          pragma Assert (Result = 0);\n       end if;"}, {"sha": "1c979355b20f4f8435c9286a0e0046a31443dfe9", "filename": "gcc/ada/s-taprop-mingw.adb", "status": "modified", "additions": 79, "deletions": 64, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taprop-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taprop-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-mingw.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2006, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2007, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -62,12 +62,12 @@ with System.Interrupt_Management;\n with System.Soft_Links;\n --  used for Abort_Defer/Undefer\n \n---  We use System.Soft_Links instead of System.Tasking.Initialization\n---  because the later is a higher level package that we shouldn't depend on.\n---  For example when using the restricted run time, it is replaced by\n+--  We use System.Soft_Links instead of System.Tasking.Initialization because\n+--  the later is a higher level package that we shouldn't depend on. For\n+--  example when using the restricted run time, it is replaced by\n --  System.Tasking.Restricted.Stages.\n \n-with Unchecked_Deallocation;\n+with Ada.Unchecked_Deallocation;\n \n package body System.Task_Primitives.Operations is\n \n@@ -113,6 +113,9 @@ package body System.Task_Primitives.Operations is\n    Foreign_Task_Elaborated : aliased Boolean := True;\n    --  Used to identified fake tasks (i.e., non-Ada Threads)\n \n+   Annex_D : Boolean := False;\n+   --  Set to True if running with Annex-D semantics\n+\n    ------------------------------------\n    -- The thread local storage index --\n    ------------------------------------\n@@ -200,7 +203,6 @@ package body System.Task_Primitives.Operations is\n \n    procedure Initialize_Cond (Cond : not null access Condition_Variable) is\n       hEvent : HANDLE;\n-\n    begin\n       hEvent := CreateEvent (null, True, False, Null_Ptr);\n       pragma Assert (hEvent /= 0);\n@@ -236,10 +238,10 @@ package body System.Task_Primitives.Operations is\n    -- Cond_Wait --\n    ---------------\n \n-   --  Pre-assertion: Cond is posted\n+   --  Pre-condition: Cond is posted\n    --                 L is locked.\n \n-   --  Post-assertion: Cond is posted\n+   --  Post-condition: Cond is posted\n    --                  L is locked.\n \n    procedure Cond_Wait\n@@ -254,25 +256,25 @@ package body System.Task_Primitives.Operations is\n \n       Result_Bool := ResetEvent (HANDLE (Cond.all));\n       pragma Assert (Result_Bool = True);\n-      Unlock (L);\n+      Unlock (L, Global_Lock => True);\n \n       --  No problem if we are interrupted here: if the condition is signaled,\n       --  WaitForSingleObject will simply not block\n \n       Result := WaitForSingleObject (HANDLE (Cond.all), Wait_Infinite);\n       pragma Assert (Result = 0);\n \n-      Write_Lock (L);\n+      Write_Lock (L, Global_Lock => True);\n    end Cond_Wait;\n \n    ---------------------\n    -- Cond_Timed_Wait --\n    ---------------------\n \n-   --  Pre-assertion: Cond is posted\n+   --  Pre-condition: Cond is posted\n    --                 L is locked.\n \n-   --  Post-assertion: Cond is posted\n+   --  Post-condition: Cond is posted\n    --                  L is locked.\n \n    procedure Cond_Timed_Wait\n@@ -283,19 +285,18 @@ package body System.Task_Primitives.Operations is\n       Status    : out Integer)\n    is\n       Time_Out_Max : constant DWORD := 16#FFFF0000#;\n-      --  NT 4 cannot handle timeout values that are too large,\n-      --  e.g. DWORD'Last - 1\n+      --  NT 4 can't handle excessive timeout values (e.g. DWORD'Last - 1)\n \n-      Time_Out     : DWORD;\n-      Result       : BOOL;\n-      Wait_Result  : DWORD;\n+      Time_Out    : DWORD;\n+      Result      : BOOL;\n+      Wait_Result : DWORD;\n \n    begin\n       --  Must reset Cond BEFORE L is unlocked\n \n       Result := ResetEvent (HANDLE (Cond.all));\n       pragma Assert (Result = True);\n-      Unlock (L);\n+      Unlock (L, Global_Lock => True);\n \n       --  No problem if we are interrupted here: if the condition is signaled,\n       --  WaitForSingleObject will simply not block\n@@ -321,7 +322,7 @@ package body System.Task_Primitives.Operations is\n          end if;\n       end if;\n \n-      Write_Lock (L);\n+      Write_Lock (L, Global_Lock => True);\n \n       --  Ensure post-condition\n \n@@ -337,14 +338,12 @@ package body System.Task_Primitives.Operations is\n    -- Stack_Guard  --\n    ------------------\n \n-   --  The underlying thread system sets a guard page at the\n-   --  bottom of a thread stack, so nothing is needed.\n+   --  The underlying thread system sets a guard page at the bottom of a thread\n+   --  stack, so nothing is needed.\n    --  ??? Check the comment above\n \n    procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n-      pragma Warnings (Off, T);\n-      pragma Warnings (Off, On);\n-\n+      pragma Unreferenced (T, On);\n    begin\n       null;\n    end Stack_Guard;\n@@ -376,12 +375,11 @@ package body System.Task_Primitives.Operations is\n    -- Initialize_Lock --\n    ---------------------\n \n-   --  Note: mutexes and cond_variables needed per-task basis are\n-   --  initialized in Intialize_TCB and the Storage_Error is handled.\n-   --  Other mutexes (such as RTS_Lock, Memory_Lock...) used in\n-   --  the RTS is initialized before any status change of RTS.\n-   --  Therefore raising Storage_Error in the following routines\n-   --  should be able to be handled safely.\n+   --  Note: mutexes and cond_variables needed per-task basis are initialized\n+   --  in Intialize_TCB and the Storage_Error is handled. Other mutexes (such\n+   --  as RTS_Lock, Memory_Lock...) used in the RTS is initialized before any\n+   --  status change of RTS. Therefore raising Storage_Error in the following\n+   --  routines should be able to be handled safely.\n \n    procedure Initialize_Lock\n      (Prio : System.Any_Priority;\n@@ -487,6 +485,21 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n+   -----------------\n+   -- Set_Ceiling --\n+   -----------------\n+\n+   --  Dynamic priority ceilings are not supported by the underlying system\n+\n+   procedure Set_Ceiling\n+     (L    : not null access Lock;\n+      Prio : System.Any_Priority)\n+   is\n+      pragma Unreferenced (L, Prio);\n+   begin\n+      null;\n+   end Set_Ceiling;\n+\n    -----------\n    -- Sleep --\n    -----------\n@@ -518,9 +531,8 @@ package body System.Task_Primitives.Operations is\n    -- Timed_Sleep --\n    -----------------\n \n-   --  This is for use within the run-time system, so abort is\n-   --  assumed to be already deferred, and the caller should be\n-   --  holding its own ATCB lock.\n+   --  This is for use within the run-time system, so abort is assumed to be\n+   --  already deferred, and the caller should be holding its own ATCB lock.\n \n    procedure Timed_Sleep\n      (Self_ID  : Task_Id;\n@@ -552,15 +564,18 @@ package body System.Task_Primitives.Operations is\n \n       if Rel_Time > 0.0 then\n          loop\n-            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n-              or else Self_ID.Pending_Priority_Change;\n+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n             if Single_Lock then\n-               Cond_Timed_Wait (Self_ID.Common.LL.CV'Access,\n-                 Single_RTS_Lock'Access, Rel_Time, Local_Timedout, Result);\n+               Cond_Timed_Wait\n+                 (Self_ID.Common.LL.CV'Access,\n+                  Single_RTS_Lock'Access,\n+                  Rel_Time, Local_Timedout, Result);\n             else\n-               Cond_Timed_Wait (Self_ID.Common.LL.CV'Access,\n-                 Self_ID.Common.LL.L'Access, Rel_Time, Local_Timedout, Result);\n+               Cond_Timed_Wait\n+                 (Self_ID.Common.LL.CV'Access,\n+                  Self_ID.Common.LL.L'Access,\n+                  Rel_Time, Local_Timedout, Result);\n             end if;\n \n             Check_Time := Monotonic_Clock;\n@@ -615,22 +630,18 @@ package body System.Task_Primitives.Operations is\n          Self_ID.Common.State := Delay_Sleep;\n \n          loop\n-            if Self_ID.Pending_Priority_Change then\n-               Self_ID.Pending_Priority_Change := False;\n-               Self_ID.Common.Base_Priority := Self_ID.New_Base_Priority;\n-               Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n-            end if;\n-\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n             if Single_Lock then\n-               Cond_Timed_Wait (Self_ID.Common.LL.CV'Access,\n-                                Single_RTS_Lock'Access,\n-                                Rel_Time, Timedout, Result);\n+               Cond_Timed_Wait\n+                 (Self_ID.Common.LL.CV'Access,\n+                  Single_RTS_Lock'Access,\n+                  Rel_Time, Timedout, Result);\n             else\n-               Cond_Timed_Wait (Self_ID.Common.LL.CV'Access,\n-                                Self_ID.Common.LL.L'Access,\n-                                Rel_Time, Timedout, Result);\n+               Cond_Timed_Wait\n+                 (Self_ID.Common.LL.CV'Access,\n+                  Self_ID.Common.LL.L'Access,\n+                  Rel_Time, Timedout, Result);\n             end if;\n \n             Check_Time := Monotonic_Clock;\n@@ -668,7 +679,17 @@ package body System.Task_Primitives.Operations is\n    procedure Yield (Do_Yield : Boolean := True) is\n    begin\n       if Do_Yield then\n-         Sleep (0);\n+         SwitchToThread;\n+\n+      elsif Annex_D then\n+         --  If running with Annex-D semantics we need a delay\n+         --  above 0 milliseconds here otherwise processes give\n+         --  enough time to the other tasks to have a chance to\n+         --  run.\n+         --\n+         --  This makes cxd8002 ACATS pass on Windows.\n+\n+         Sleep (1);\n       end if;\n    end Yield;\n \n@@ -748,7 +769,7 @@ package body System.Task_Primitives.Operations is\n    --  1) from System.Task_Primitives.Operations.Initialize\n    --  2) from System.Tasking.Stages.Task_Wrapper\n \n-   --  The thread initialisation has to be done only for the first case.\n+   --  The thread initialisation has to be done only for the first case\n \n    --  This is because the GetCurrentThread NT call does not return the real\n    --  thread handler but only a \"pseudo\" one. It is not possible to release\n@@ -923,7 +944,7 @@ package body System.Task_Primitives.Operations is\n       Is_Self   : constant Boolean := T = Self;\n \n       procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n+        Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n    begin\n       if not Single_Lock then\n@@ -1014,19 +1035,13 @@ package body System.Task_Primitives.Operations is\n       Interrupt_Management.Initialize;\n \n       if Time_Slice_Val = 0 or else Dispatching_Policy = 'F' then\n-\n          --  Here we need Annex D semantics, switch the current process to the\n-         --  High_Priority_Class.\n+         --  Realtime_Priority_Class.\n \n-         Discard :=\n-           OS_Interface.SetPriorityClass\n-             (GetCurrentProcess, High_Priority_Class);\n+         Discard := OS_Interface.SetPriorityClass\n+                      (GetCurrentProcess, Realtime_Priority_Class);\n \n-         --  ??? In theory it should be possible to use the priority class\n-         --  Realtime_Priority_Class but we suspect a bug in the NT scheduler\n-         --  which prevents (in some obscure cases) a thread to get on top of\n-         --  the running queue by another thread of lower priority. For\n-         --  example cxd8002 ACATS test freeze.\n+         Annex_D := True;\n       end if;\n \n       TlsIndex := TlsAlloc;"}, {"sha": "b7a4383e76f79a4264eaffd1eaf391b41d705e93", "filename": "gcc/ada/s-taprop-posix.adb", "status": "modified", "additions": 124, "deletions": 96, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taprop-posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taprop-posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-posix.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -72,8 +72,8 @@ with System.Soft_Links;\n --  For example when using the restricted run time, it is replaced by\n --  System.Tasking.Restricted.Stages.\n \n-with Unchecked_Conversion;\n-with Unchecked_Deallocation;\n+with Ada.Unchecked_Conversion;\n+with Ada.Unchecked_Deallocation;\n \n package body System.Task_Primitives.Operations is\n \n@@ -174,34 +174,34 @@ package body System.Task_Primitives.Operations is\n    --  Signal handler used to implement asynchronous abort.\n    --  See also comment before body, below.\n \n-   function To_Address is new Unchecked_Conversion (Task_Id, System.Address);\n+   function To_Address is\n+     new Ada.Unchecked_Conversion (Task_Id, System.Address);\n \n    -------------------\n    -- Abort_Handler --\n    -------------------\n \n-   --  Target-dependent binding of inter-thread Abort signal to\n-   --  the raising of the Abort_Signal exception.\n+   --  Target-dependent binding of inter-thread Abort signal to the raising of\n+   --  the Abort_Signal exception.\n \n-   --  The technical issues and alternatives here are essentially\n-   --  the same as for raising exceptions in response to other\n-   --  signals (e.g. Storage_Error). See code and comments in\n-   --  the package body System.Interrupt_Management.\n+   --  The technical issues and alternatives here are essentially the\n+   --  same as for raising exceptions in response to other signals\n+   --  (e.g. Storage_Error). See code and comments in the package body\n+   --  System.Interrupt_Management.\n \n-   --  Some implementations may not allow an exception to be propagated\n-   --  out of a handler, and others might leave the signal or\n-   --  interrupt that invoked this handler masked after the exceptional\n-   --  return to the application code.\n+   --  Some implementations may not allow an exception to be propagated out of\n+   --  a handler, and others might leave the signal or interrupt that invoked\n+   --  this handler masked after the exceptional return to the application\n+   --  code.\n \n-   --  GNAT exceptions are originally implemented using setjmp()/longjmp().\n-   --  On most UNIX systems, this will allow transfer out of a signal handler,\n+   --  GNAT exceptions are originally implemented using setjmp()/longjmp(). On\n+   --  most UNIX systems, this will allow transfer out of a signal handler,\n    --  which is usually the only mechanism available for implementing\n-   --  asynchronous handlers of this kind. However, some\n-   --  systems do not restore the signal mask on longjmp(), leaving the\n-   --  abort signal masked.\n+   --  asynchronous handlers of this kind. However, some systems do not\n+   --  restore the signal mask on longjmp(), leaving the abort signal masked.\n \n    procedure Abort_Handler (Sig : Signal) is\n-      pragma Warnings (Off, Sig);\n+      pragma Unreferenced (Sig);\n \n       T       : constant Task_Id := Self;\n       Result  : Interfaces.C.int;\n@@ -330,7 +330,7 @@ package body System.Task_Primitives.Operations is\n    procedure Initialize_Lock\n      (L : not null access RTS_Lock; Level : Lock_Level)\n    is\n-      pragma Warnings (Off, Level);\n+      pragma Unreferenced (Level);\n \n       Attributes : aliased pthread_mutexattr_t;\n       Result     : Interfaces.C.int;\n@@ -376,15 +376,13 @@ package body System.Task_Primitives.Operations is\n \n    procedure Finalize_Lock (L : not null access Lock) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_mutex_destroy (L);\n       pragma Assert (Result = 0);\n    end Finalize_Lock;\n \n    procedure Finalize_Lock (L : not null access RTS_Lock) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_mutex_destroy (L);\n       pragma Assert (Result = 0);\n@@ -413,7 +411,6 @@ package body System.Task_Primitives.Operations is\n       Global_Lock : Boolean := False)\n    is\n       Result : Interfaces.C.int;\n-\n    begin\n       if not Single_Lock or else Global_Lock then\n          Result := pthread_mutex_lock (L);\n@@ -423,7 +420,6 @@ package body System.Task_Primitives.Operations is\n \n    procedure Write_Lock (T : Task_Id) is\n       Result : Interfaces.C.int;\n-\n    begin\n       if not Single_Lock then\n          Result := pthread_mutex_lock (T.Common.LL.L'Access);\n@@ -447,7 +443,6 @@ package body System.Task_Primitives.Operations is\n \n    procedure Unlock (L : not null access Lock) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_mutex_unlock (L);\n       pragma Assert (Result = 0);\n@@ -457,7 +452,6 @@ package body System.Task_Primitives.Operations is\n      (L : not null access RTS_Lock; Global_Lock : Boolean := False)\n    is\n       Result : Interfaces.C.int;\n-\n    begin\n       if not Single_Lock or else Global_Lock then\n          Result := pthread_mutex_unlock (L);\n@@ -467,14 +461,28 @@ package body System.Task_Primitives.Operations is\n \n    procedure Unlock (T : Task_Id) is\n       Result : Interfaces.C.int;\n-\n    begin\n       if not Single_Lock then\n          Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n          pragma Assert (Result = 0);\n       end if;\n    end Unlock;\n \n+   -----------------\n+   -- Set_Ceiling --\n+   -----------------\n+\n+   --  Dynamic priority ceilings are not supported by the underlying system\n+\n+   procedure Set_Ceiling\n+     (L    : not null access Lock;\n+      Prio : System.Any_Priority)\n+   is\n+      pragma Unreferenced (L, Prio);\n+   begin\n+      null;\n+   end Set_Ceiling;\n+\n    -----------\n    -- Sleep --\n    -----------\n@@ -483,17 +491,19 @@ package body System.Task_Primitives.Operations is\n      (Self_ID : Task_Id;\n       Reason  : System.Tasking.Task_States)\n    is\n-      pragma Warnings (Off, Reason);\n+      pragma Unreferenced (Reason);\n \n       Result : Interfaces.C.int;\n \n    begin\n       if Single_Lock then\n-         Result := pthread_cond_wait\n-           (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n+         Result :=\n+           pthread_cond_wait\n+             (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n       else\n-         Result := pthread_cond_wait\n-           (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n+         Result :=\n+           pthread_cond_wait\n+             (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n       end if;\n \n       --  EINTR is not considered a failure\n@@ -517,9 +527,10 @@ package body System.Task_Primitives.Operations is\n       Timedout : out Boolean;\n       Yielded  : out Boolean)\n    is\n-      pragma Warnings (Off, Reason);\n+      pragma Unreferenced (Reason);\n \n-      Check_Time : constant Duration := Monotonic_Clock;\n+      Base_Time  : constant Duration := Monotonic_Clock;\n+      Check_Time : Duration := Base_Time;\n       Rel_Time   : Duration;\n       Abs_Time   : Duration;\n       Request    : aliased timespec;\n@@ -552,21 +563,23 @@ package body System.Task_Primitives.Operations is\n          end if;\n \n          loop\n-            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n-              or else Self_ID.Pending_Priority_Change;\n+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n             if Single_Lock then\n-               Result := pthread_cond_timedwait\n-                 (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access,\n-                  Request'Access);\n+               Result :=\n+                 pthread_cond_timedwait\n+                   (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access,\n+                    Request'Access);\n \n             else\n-               Result := pthread_cond_timedwait\n-                 (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access,\n-                  Request'Access);\n+               Result :=\n+                 pthread_cond_timedwait\n+                   (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access,\n+                    Request'Access);\n             end if;\n \n-            exit when Abs_Time <= Monotonic_Clock;\n+            Check_Time := Monotonic_Clock;\n+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n \n             if Result = 0 or Result = EINTR then\n \n@@ -593,7 +606,8 @@ package body System.Task_Primitives.Operations is\n       Time    : Duration;\n       Mode    : ST.Delay_Modes)\n    is\n-      Check_Time : constant Duration := Monotonic_Clock;\n+      Base_Time  : constant Duration := Monotonic_Clock;\n+      Check_Time : Duration := Base_Time;\n       Abs_Time   : Duration;\n       Rel_Time   : Duration;\n       Request    : aliased timespec;\n@@ -633,12 +647,6 @@ package body System.Task_Primitives.Operations is\n          Self_ID.Common.State := Delay_Sleep;\n \n          loop\n-            if Self_ID.Pending_Priority_Change then\n-               Self_ID.Pending_Priority_Change := False;\n-               Self_ID.Common.Base_Priority := Self_ID.New_Base_Priority;\n-               Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n-            end if;\n-\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n             if Single_Lock then\n@@ -653,7 +661,8 @@ package body System.Task_Primitives.Operations is\n                             Request'Access);\n             end if;\n \n-            exit when Abs_Time <= Monotonic_Clock;\n+            Check_Time := Monotonic_Clock;\n+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n \n             pragma Assert (Result = 0\n                              or else Result = ETIMEDOUT\n@@ -700,7 +709,7 @@ package body System.Task_Primitives.Operations is\n    ------------\n \n    procedure Wakeup (T : Task_Id; Reason : System.Tasking.Task_States) is\n-      pragma Warnings (Off, Reason);\n+      pragma Unreferenced (Reason);\n       Result : Interfaces.C.int;\n    begin\n       Result := pthread_cond_signal (T.Common.LL.CV'Access);\n@@ -729,7 +738,7 @@ package body System.Task_Primitives.Operations is\n       Prio                : System.Any_Priority;\n       Loss_Of_Inheritance : Boolean := False)\n    is\n-      pragma Warnings (Off, Loss_Of_Inheritance);\n+      pragma Unreferenced (Loss_Of_Inheritance);\n \n       Result : Interfaces.C.int;\n       Param  : aliased struct_sched_param;\n@@ -852,23 +861,30 @@ package body System.Task_Primitives.Operations is\n \n          if Result = 0 then\n             if Locking_Policy = 'C' then\n-               Result := pthread_mutexattr_setprotocol\n-                 (Mutex_Attr'Access, PTHREAD_PRIO_PROTECT);\n+               Result :=\n+                 pthread_mutexattr_setprotocol\n+                   (Mutex_Attr'Access,\n+                    PTHREAD_PRIO_PROTECT);\n                pragma Assert (Result = 0);\n \n-               Result := pthread_mutexattr_setprioceiling\n-                  (Mutex_Attr'Access,\n-                   Interfaces.C.int (System.Any_Priority'Last));\n+               Result :=\n+                 pthread_mutexattr_setprioceiling\n+                   (Mutex_Attr'Access,\n+                    Interfaces.C.int (System.Any_Priority'Last));\n                pragma Assert (Result = 0);\n \n             elsif Locking_Policy = 'I' then\n-               Result := pthread_mutexattr_setprotocol\n-                 (Mutex_Attr'Access, PTHREAD_PRIO_INHERIT);\n+               Result :=\n+                 pthread_mutexattr_setprotocol\n+                   (Mutex_Attr'Access,\n+                    PTHREAD_PRIO_INHERIT);\n                pragma Assert (Result = 0);\n             end if;\n \n-            Result := pthread_mutex_init (Self_ID.Common.LL.L'Access,\n-              Mutex_Attr'Access);\n+            Result :=\n+              pthread_mutex_init\n+                (Self_ID.Common.LL.L'Access,\n+                 Mutex_Attr'Access);\n             pragma Assert (Result = 0 or else Result = ENOMEM);\n          end if;\n \n@@ -885,8 +901,9 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Result = 0 or else Result = ENOMEM);\n \n       if Result = 0 then\n-         Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n-           Cond_Attr'Access);\n+         Result :=\n+           pthread_cond_init\n+             (Self_ID.Common.LL.CV'Access, Cond_Attr'Access);\n          pragma Assert (Result = 0 or else Result = ENOMEM);\n       end if;\n \n@@ -921,16 +938,17 @@ package body System.Task_Primitives.Operations is\n       Result              : Interfaces.C.int;\n \n       function Thread_Body_Access is new\n-        Unchecked_Conversion (System.Address, Thread_Body);\n+        Ada.Unchecked_Conversion (System.Address, Thread_Body);\n \n       use System.Task_Info;\n \n    begin\n       Adjusted_Stack_Size := Interfaces.C.size_t (Stack_Size);\n \n       if Stack_Base_Available then\n+\n          --  If Stack Checking is supported then allocate 2 additional pages:\n-         --\n+\n          --  In the worst case, stack is allocated at something like\n          --  N * Get_Page_Size - epsilon, we need to add the size for 2 pages\n          --  to be sure the effective stack size is greater than what\n@@ -947,23 +965,27 @@ package body System.Task_Primitives.Operations is\n          return;\n       end if;\n \n-      Result := pthread_attr_setdetachstate\n-        (Attributes'Access, PTHREAD_CREATE_DETACHED);\n+      Result :=\n+        pthread_attr_setdetachstate\n+          (Attributes'Access, PTHREAD_CREATE_DETACHED);\n       pragma Assert (Result = 0);\n \n-      Result := pthread_attr_setstacksize\n-        (Attributes'Access, Adjusted_Stack_Size);\n+      Result :=\n+        pthread_attr_setstacksize\n+          (Attributes'Access, Adjusted_Stack_Size);\n       pragma Assert (Result = 0);\n \n       if T.Common.Task_Info /= Default_Scope then\n          case T.Common.Task_Info is\n             when System.Task_Info.Process_Scope =>\n-               Result := pthread_attr_setscope\n-                           (Attributes'Access, PTHREAD_SCOPE_PROCESS);\n+               Result :=\n+                 pthread_attr_setscope\n+                   (Attributes'Access, PTHREAD_SCOPE_PROCESS);\n \n             when System.Task_Info.System_Scope =>\n-               Result := pthread_attr_setscope\n-                           (Attributes'Access, PTHREAD_SCOPE_SYSTEM);\n+               Result :=\n+                 pthread_attr_setscope\n+                   (Attributes'Access, PTHREAD_SCOPE_SYSTEM);\n \n             when System.Task_Info.Default_Scope =>\n                Result := 0;\n@@ -1002,7 +1024,7 @@ package body System.Task_Primitives.Operations is\n       Is_Self : constant Boolean := T = Self;\n \n       procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n+        Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n    begin\n       if not Single_Lock then\n@@ -1043,8 +1065,10 @@ package body System.Task_Primitives.Operations is\n    procedure Abort_Task (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n-      Result := pthread_kill (T.Common.LL.Thread,\n-        Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n+      Result :=\n+        pthread_kill\n+          (T.Common.LL.Thread,\n+           Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n       pragma Assert (Result = 0);\n    end Abort_Task;\n \n@@ -1056,9 +1080,9 @@ package body System.Task_Primitives.Operations is\n       Mutex_Attr : aliased pthread_mutexattr_t;\n       Cond_Attr  : aliased pthread_condattr_t;\n       Result     : Interfaces.C.int;\n+\n    begin\n-      --  Initialize internal state. It is always initialized to False (ARM\n-      --  D.10 par. 6).\n+      --  Initialize internal state (always to False (RM D.10 (6)))\n \n       S.State := False;\n       S.Waiting := False;\n@@ -1109,7 +1133,6 @@ package body System.Task_Primitives.Operations is\n          if Result = ENOMEM then\n             Result := pthread_condattr_destroy (Cond_Attr'Access);\n             pragma Assert (Result = 0);\n-\n             raise Storage_Error;\n          end if;\n       end if;\n@@ -1123,7 +1146,8 @@ package body System.Task_Primitives.Operations is\n    --------------\n \n    procedure Finalize (S : in out Suspension_Object) is\n-      Result  : Interfaces.C.int;\n+      Result : Interfaces.C.int;\n+\n    begin\n       --  Destroy internal mutex\n \n@@ -1153,7 +1177,8 @@ package body System.Task_Primitives.Operations is\n    ---------------\n \n    procedure Set_False (S : in out Suspension_Object) is\n-      Result  : Interfaces.C.int;\n+      Result : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n@@ -1174,6 +1199,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Set_True (S : in out Suspension_Object) is\n       Result : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n@@ -1182,7 +1208,7 @@ package body System.Task_Primitives.Operations is\n \n       --  If there is already a task waiting on this suspension object then\n       --  we resume it, leaving the state of the suspension object to False,\n-      --  as it is specified in ARM D.10 par. 9. Otherwise, it just leaves\n+      --  as it is specified in (RM D.10(9)). Otherwise, it just leaves\n       --  the state to True.\n \n       if S.Waiting then\n@@ -1191,6 +1217,7 @@ package body System.Task_Primitives.Operations is\n \n          Result := pthread_cond_signal (S.CV'Access);\n          pragma Assert (Result = 0);\n+\n       else\n          S.State := True;\n       end if;\n@@ -1207,23 +1234,26 @@ package body System.Task_Primitives.Operations is\n \n    procedure Suspend_Until_True (S : in out Suspension_Object) is\n       Result : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n       Result := pthread_mutex_lock (S.L'Access);\n       pragma Assert (Result = 0);\n \n       if S.Waiting then\n+\n          --  Program_Error must be raised upon calling Suspend_Until_True\n          --  if another task is already waiting on that suspension object\n-         --  (ARM D.10 par. 10).\n+         --  (RM D.10(10)).\n \n          Result := pthread_mutex_unlock (S.L'Access);\n          pragma Assert (Result = 0);\n \n          SSL.Abort_Undefer.all;\n \n          raise Program_Error;\n+\n       else\n          --  Suspend the task if the state is False. Otherwise, the task\n          --  continues its execution, and the state of the suspension object\n@@ -1250,7 +1280,7 @@ package body System.Task_Primitives.Operations is\n    --  Dummy version\n \n    function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n-      pragma Warnings (Off, Self_ID);\n+      pragma Unreferenced (Self_ID);\n    begin\n       return True;\n    end Check_Exit;\n@@ -1260,7 +1290,7 @@ package body System.Task_Primitives.Operations is\n    --------------------\n \n    function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean is\n-      pragma Warnings (Off, Self_ID);\n+      pragma Unreferenced (Self_ID);\n    begin\n       return True;\n    end Check_No_Locks;\n@@ -1300,8 +1330,7 @@ package body System.Task_Primitives.Operations is\n      (T           : ST.Task_Id;\n       Thread_Self : Thread_Id) return Boolean\n    is\n-      pragma Warnings (Off, T);\n-      pragma Warnings (Off, Thread_Self);\n+      pragma Unreferenced (T, Thread_Self);\n    begin\n       return False;\n    end Suspend_Task;\n@@ -1314,8 +1343,7 @@ package body System.Task_Primitives.Operations is\n      (T           : ST.Task_Id;\n       Thread_Self : Thread_Id) return Boolean\n    is\n-      pragma Warnings (Off, T);\n-      pragma Warnings (Off, Thread_Self);\n+      pragma Unreferenced (T, Thread_Self);\n    begin\n       return False;\n    end Resume_Task;\n@@ -1371,8 +1399,8 @@ package body System.Task_Primitives.Operations is\n \n       --  Install the abort-signal handler\n \n-      if State (System.Interrupt_Management.Abort_Task_Interrupt)\n-        /= Default\n+      if State\n+          (System.Interrupt_Management.Abort_Task_Interrupt) /= Default\n       then\n          act.sa_flags := 0;\n          act.sa_handler := Abort_Handler'Address;\n@@ -1383,9 +1411,9 @@ package body System.Task_Primitives.Operations is\n \n          Result :=\n            sigaction\n-           (Signal (System.Interrupt_Management.Abort_Task_Interrupt),\n-            act'Unchecked_Access,\n-            old_act'Unchecked_Access);\n+             (Signal (System.Interrupt_Management.Abort_Task_Interrupt),\n+              act'Unchecked_Access,\n+              old_act'Unchecked_Access);\n          pragma Assert (Result = 0);\n       end if;\n    end Initialize;"}, {"sha": "3cf44f747563db1af41bc236c3db32611c731d14", "filename": "gcc/ada/s-taprop-solaris.adb", "status": "modified", "additions": 138, "deletions": 109, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taprop-solaris.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taprop-solaris.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-solaris.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2006, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2007, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -52,7 +52,7 @@ with System.OS_Primitives;\n --  used for Delay_Modes\n \n pragma Warnings (Off);\n-with GNAT.OS_Lib;\n+with System.OS_Lib;\n --  used for String_Access, Getenv\n \n pragma Warnings (On);\n@@ -72,7 +72,7 @@ with System.Soft_Links;\n --  For example when using the restricted run time, it is replaced by\n --  System.Tasking.Restricted.Stages.\n \n-with Unchecked_Deallocation;\n+with Ada.Unchecked_Deallocation;\n \n package body System.Task_Primitives.Operations is\n \n@@ -287,8 +287,11 @@ package body System.Task_Primitives.Operations is\n \n          --  Make sure signals used for RTS internal purpose are unmasked\n \n-         Result := thr_sigsetmask (SIG_UNBLOCK,\n-           Unblocked_Signal_Mask'Unchecked_Access, Old_Set'Unchecked_Access);\n+         Result :=\n+           thr_sigsetmask\n+             (SIG_UNBLOCK,\n+              Unblocked_Signal_Mask'Unchecked_Access,\n+              Old_Set'Unchecked_Access);\n          pragma Assert (Result = 0);\n \n          raise Standard'Abort_Signal;\n@@ -346,8 +349,8 @@ package body System.Task_Primitives.Operations is\n       --  _SC_NPROCESSORS_CONF, minus one.\n \n       procedure Configure_Processors is\n-         Proc_Acc  : constant GNAT.OS_Lib.String_Access :=\n-                       GNAT.OS_Lib.Getenv (\"GNAT_PROCESSOR\");\n+         Proc_Acc  : constant System.OS_Lib.String_Access :=\n+                       System.OS_Lib.Getenv (\"GNAT_PROCESSOR\");\n          Proc      : aliased processorid_t;  --  User processor #\n          Last_Proc : processorid_t;          --  Last processor #\n \n@@ -362,13 +365,16 @@ package body System.Task_Primitives.Operations is\n                Proc := processorid_t'Value (Proc_Acc.all);\n \n                if Proc <= -2  or else Proc > Last_Proc then\n+\n                   --  Use the default configuration\n+\n                   null;\n+\n                elsif Proc = -1 then\n+\n                   --  Choose a processor\n \n                   Result := 0;\n-\n                   while Proc < Last_Proc loop\n                      Proc := Proc + 1;\n                      Result := p_online (Proc, PR_STATUS);\n@@ -440,8 +446,7 @@ package body System.Task_Primitives.Operations is\n \n             if Time_Slice_Val > 0 then\n \n-               --  Convert Time_Slice_Val (microseconds) into seconds and\n-               --  nanoseconds\n+               --  Convert Time_Slice_Val (microseconds) to seconds/nanosecs\n \n                Secs := Interfaces.C.long (Time_Slice_Val / 1_000_000);\n                Nsecs :=\n@@ -470,8 +475,9 @@ package body System.Task_Primitives.Operations is\n             Prio_Param.rt_tqsecs := Secs;\n             Prio_Param.rt_tqnsecs := Nsecs;\n \n-            Result := priocntl (PC_VERSION, P_LWPID, P_MYID, PC_SETPARMS,\n-              Prio_Param'Address);\n+            Result :=\n+              priocntl\n+                (PC_VERSION, P_LWPID, P_MYID, PC_SETPARMS, Prio_Param'Address);\n \n             Using_Real_Time_Class := Result /= -1;\n          end;\n@@ -493,8 +499,8 @@ package body System.Task_Primitives.Operations is\n \n       --  Install the abort-signal handler\n \n-      if State (System.Interrupt_Management.Abort_Task_Interrupt)\n-        /= Default\n+      if State\n+          (System.Interrupt_Management.Abort_Task_Interrupt) /= Default\n       then\n          --  Set sa_flags to SA_NODEFER so that during the handler execution\n          --  we do not change the Signal_Mask to be masked for the Abort_Signal\n@@ -512,10 +518,10 @@ package body System.Task_Primitives.Operations is\n          act.sa_mask := Tmp_Set;\n \n          Result :=\n-           sigaction (\n-             Signal (System.Interrupt_Management.Abort_Task_Interrupt),\n-             act'Unchecked_Access,\n-             old_act'Unchecked_Access);\n+           sigaction\n+             (Signal (System.Interrupt_Management.Abort_Task_Interrupt),\n+              act'Unchecked_Access,\n+              old_act'Unchecked_Access);\n          pragma Assert (Result = 0);\n       end if;\n \n@@ -526,12 +532,11 @@ package body System.Task_Primitives.Operations is\n    -- Initialize_Lock --\n    ---------------------\n \n-   --  Note: mutexes and cond_variables needed per-task basis are\n-   --        initialized in Initialize_TCB and the Storage_Error is\n-   --        handled. Other mutexes (such as RTS_Lock, Memory_Lock...)\n-   --        used in RTS is initialized before any status change of RTS.\n-   --        Therefore rasing Storage_Error in the following routines\n-   --        should be able to be handled safely.\n+   --  Note: mutexes and cond_variables needed per-task basis are initialized\n+   --  in Initialize_TCB and the Storage_Error is handled. Other mutexes (such\n+   --  as RTS_Lock, Memory_Lock...) used in RTS is initialized before any\n+   --  status change of RTS. Therefore rasing Storage_Error in the following\n+   --  routines should be able to be handled safely.\n \n    procedure Initialize_Lock\n      (Prio : System.Any_Priority;\n@@ -561,8 +566,8 @@ package body System.Task_Primitives.Operations is\n       Result : Interfaces.C.int;\n \n    begin\n-      pragma Assert (Check_Initialize_Lock\n-        (To_Lock_Ptr (RTS_Lock_Ptr (L)), Level));\n+      pragma Assert\n+        (Check_Initialize_Lock (To_Lock_Ptr (RTS_Lock_Ptr (L)), Level));\n       Result := mutex_init (L.L'Access, USYNC_THREAD, System.Null_Address);\n       pragma Assert (Result = 0 or else Result = ENOMEM);\n \n@@ -577,7 +582,6 @@ package body System.Task_Primitives.Operations is\n \n    procedure Finalize_Lock (L : not null access Lock) is\n       Result : Interfaces.C.int;\n-\n    begin\n       pragma Assert (Check_Finalize_Lock (Lock_Ptr (L)));\n       Result := mutex_destroy (L.L'Access);\n@@ -586,7 +590,6 @@ package body System.Task_Primitives.Operations is\n \n    procedure Finalize_Lock (L : not null access RTS_Lock) is\n       Result : Interfaces.C.int;\n-\n    begin\n       pragma Assert (Check_Finalize_Lock (To_Lock_Ptr (RTS_Lock_Ptr (L))));\n       Result := mutex_destroy (L.L'Access);\n@@ -598,7 +601,8 @@ package body System.Task_Primitives.Operations is\n    ----------------\n \n    procedure Write_Lock\n-     (L : not null access Lock; Ceiling_Violation : out Boolean)\n+     (L                 : not null access Lock;\n+      Ceiling_Violation : out Boolean)\n    is\n       Result : Interfaces.C.int;\n \n@@ -643,7 +647,6 @@ package body System.Task_Primitives.Operations is\n      Global_Lock : Boolean := False)\n    is\n       Result : Interfaces.C.int;\n-\n    begin\n       if not Single_Lock or else Global_Lock then\n          pragma Assert (Check_Lock (To_Lock_Ptr (RTS_Lock_Ptr (L))));\n@@ -655,7 +658,6 @@ package body System.Task_Primitives.Operations is\n \n    procedure Write_Lock (T : Task_Id) is\n       Result : Interfaces.C.int;\n-\n    begin\n       if not Single_Lock then\n          pragma Assert (Check_Lock (To_Lock_Ptr (T.Common.LL.L'Access)));\n@@ -670,7 +672,8 @@ package body System.Task_Primitives.Operations is\n    ---------------\n \n    procedure Read_Lock\n-     (L : not null access Lock; Ceiling_Violation : out Boolean) is\n+     (L                 : not null access Lock;\n+      Ceiling_Violation : out Boolean) is\n    begin\n       Write_Lock (L, Ceiling_Violation);\n    end Read_Lock;\n@@ -680,7 +683,7 @@ package body System.Task_Primitives.Operations is\n    ------------\n \n    procedure Unlock (L : not null access Lock) is\n-      Result  : Interfaces.C.int;\n+      Result : Interfaces.C.int;\n \n    begin\n       pragma Assert (Check_Unlock (Lock_Ptr (L)));\n@@ -704,7 +707,8 @@ package body System.Task_Primitives.Operations is\n    end Unlock;\n \n    procedure Unlock\n-     (L : not null access RTS_Lock; Global_Lock : Boolean := False)\n+     (L           : not null access RTS_Lock;\n+      Global_Lock : Boolean := False)\n    is\n       Result : Interfaces.C.int;\n    begin\n@@ -725,6 +729,21 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n+   -----------------\n+   -- Set_Ceiling --\n+   -----------------\n+\n+   --  Dynamic priority ceilings are not supported by the underlying system\n+\n+   procedure Set_Ceiling\n+     (L    : not null access Lock;\n+      Prio : System.Any_Priority)\n+   is\n+      pragma Unreferenced (L, Prio);\n+   begin\n+      null;\n+   end Set_Ceiling;\n+\n    --  For the time delay implementation, we need to make sure we\n    --  achieve following criteria:\n \n@@ -795,7 +814,7 @@ package body System.Task_Primitives.Operations is\n       Result : Interfaces.C.int;\n       pragma Unreferenced (Result);\n \n-      Param   : aliased struct_pcparms;\n+      Param : aliased struct_pcparms;\n \n       use Task_Info;\n \n@@ -867,7 +886,6 @@ package body System.Task_Primitives.Operations is\n             if Self_ID.Common.Task_Info.CPU = ANY_CPU then\n                Result := 0;\n                Proc := 0;\n-\n                while Proc < Last_Proc loop\n                   Result := p_online (Proc, PR_STATUS);\n                   exit when Result = PR_ONLINE;\n@@ -886,8 +904,9 @@ package body System.Task_Primitives.Operations is\n                   raise Invalid_CPU_Number;\n                end if;\n \n-               Result := processor_bind\n-                 (P_LWPID, P_MYID, Self_ID.Common.Task_Info.CPU, null);\n+               Result :=\n+                 processor_bind\n+                   (P_LWPID, P_MYID, Self_ID.Common.Task_Info.CPU, null);\n                pragma Assert (Result = 0);\n             end if;\n          end if;\n@@ -956,8 +975,9 @@ package body System.Task_Primitives.Operations is\n       Self_ID.Common.LL.Thread := To_thread_t (-1);\n \n       if not Single_Lock then\n-         Result := mutex_init\n-           (Self_ID.Common.LL.L.L'Access, USYNC_THREAD, System.Null_Address);\n+         Result :=\n+           mutex_init\n+             (Self_ID.Common.LL.L.L'Access, USYNC_THREAD, System.Null_Address);\n          Self_ID.Common.LL.L.Level :=\n            Private_Task_Serial_Number (Self_ID.Serial_Number);\n          pragma Assert (Result = 0 or else Result = ENOMEM);\n@@ -1027,13 +1047,14 @@ package body System.Task_Primitives.Operations is\n          Opts := THR_DETACHED + THR_BOUND;\n       end if;\n \n-      Result := thr_create\n-        (System.Null_Address,\n-         Adjusted_Stack_Size,\n-         Thread_Body_Access (Wrapper),\n-         To_Address (T),\n-         Opts,\n-         T.Common.LL.Thread'Access);\n+      Result :=\n+        thr_create\n+          (System.Null_Address,\n+           Adjusted_Stack_Size,\n+           Thread_Body_Access (Wrapper),\n+           To_Address (T),\n+           Opts,\n+           T.Common.LL.Thread'Access);\n \n       Succeeded := Result = 0;\n       pragma Assert\n@@ -1047,12 +1068,12 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Finalize_TCB (T : Task_Id) is\n-      Result : Interfaces.C.int;\n-      Tmp    : Task_Id := T;\n+      Result  : Interfaces.C.int;\n+      Tmp     : Task_Id := T;\n       Is_Self : constant Boolean := T = Self;\n \n       procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n+        Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n    begin\n       T.Common.LL.Thread := To_thread_t (0);\n@@ -1080,9 +1101,9 @@ package body System.Task_Primitives.Operations is\n    -- Exit_Task --\n    ---------------\n \n-   --  This procedure must be called with abort deferred.\n-   --  It can no longer call Self or access\n-   --  the current task's ATCB, since the ATCB has been deallocated.\n+   --  This procedure must be called with abort deferred. It can no longer\n+   --  call Self or access the current task's ATCB, since the ATCB has been\n+   --  deallocated.\n \n    procedure Exit_Task is\n    begin\n@@ -1097,9 +1118,10 @@ package body System.Task_Primitives.Operations is\n       Result : Interfaces.C.int;\n    begin\n       pragma Assert (T /= Self);\n-\n-      Result := thr_kill (T.Common.LL.Thread,\n-        Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n+      Result :=\n+        thr_kill\n+          (T.Common.LL.Thread,\n+           Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n       pragma Assert (Result = 0);\n    end Abort_Task;\n \n@@ -1116,24 +1138,18 @@ package body System.Task_Primitives.Operations is\n    begin\n       pragma Assert (Check_Sleep (Reason));\n \n-      if Dynamic_Priority_Support\n-        and then Self_ID.Pending_Priority_Change\n-      then\n-         Self_ID.Pending_Priority_Change := False;\n-         Self_ID.Common.Base_Priority := Self_ID.New_Base_Priority;\n-         Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n-      end if;\n-\n       if Single_Lock then\n-         Result := cond_wait\n-           (Self_ID.Common.LL.CV'Access, Single_RTS_Lock.L'Access);\n+         Result :=\n+           cond_wait\n+             (Self_ID.Common.LL.CV'Access, Single_RTS_Lock.L'Access);\n       else\n-         Result := cond_wait\n-           (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L.L'Access);\n+         Result :=\n+           cond_wait\n+             (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L.L'Access);\n       end if;\n \n-      pragma Assert (Record_Wakeup\n-        (To_Lock_Ptr (Self_ID.Common.LL.L'Access), Reason));\n+      pragma Assert\n+        (Record_Wakeup (To_Lock_Ptr (Self_ID.Common.LL.L'Access), Reason));\n       pragma Assert (Result = 0 or else Result = EINTR);\n    end Sleep;\n \n@@ -1214,7 +1230,8 @@ package body System.Task_Primitives.Operations is\n       Timedout : out Boolean;\n       Yielded  : out Boolean)\n    is\n-      Check_Time : constant Duration := Monotonic_Clock;\n+      Base_Time  : constant Duration := Monotonic_Clock;\n+      Check_Time : Duration := Base_Time;\n       Abs_Time   : Duration;\n       Request    : aliased timespec;\n       Result     : Interfaces.C.int;\n@@ -1234,21 +1251,24 @@ package body System.Task_Primitives.Operations is\n          Request := To_Timespec (Abs_Time);\n \n          loop\n-            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n-              or else (Dynamic_Priority_Support and then\n-                Self_ID.Pending_Priority_Change);\n+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n             if Single_Lock then\n-               Result := cond_timedwait (Self_ID.Common.LL.CV'Access,\n-                 Single_RTS_Lock.L'Access, Request'Access);\n+               Result :=\n+                 cond_timedwait\n+                   (Self_ID.Common.LL.CV'Access,\n+                    Single_RTS_Lock.L'Access, Request'Access);\n             else\n-               Result := cond_timedwait (Self_ID.Common.LL.CV'Access,\n-                 Self_ID.Common.LL.L.L'Access, Request'Access);\n+               Result :=\n+                 cond_timedwait\n+                   (Self_ID.Common.LL.CV'Access,\n+                    Self_ID.Common.LL.L.L'Access, Request'Access);\n             end if;\n \n             Yielded := True;\n \n-            exit when Abs_Time <= Monotonic_Clock;\n+            Check_Time := Monotonic_Clock;\n+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n \n             if Result = 0 or Result = EINTR then\n \n@@ -1262,8 +1282,8 @@ package body System.Task_Primitives.Operations is\n          end loop;\n       end if;\n \n-      pragma Assert (Record_Wakeup\n-        (To_Lock_Ptr (Self_ID.Common.LL.L'Access), Reason));\n+      pragma Assert\n+        (Record_Wakeup (To_Lock_Ptr (Self_ID.Common.LL.L'Access), Reason));\n    end Timed_Sleep;\n \n    -----------------\n@@ -1275,7 +1295,8 @@ package body System.Task_Primitives.Operations is\n       Time    : Duration;\n       Mode    : ST.Delay_Modes)\n    is\n-      Check_Time : constant Duration := Monotonic_Clock;\n+      Base_Time  : constant Duration := Monotonic_Clock;\n+      Check_Time : Duration := Base_Time;\n       Abs_Time   : Duration;\n       Request    : aliased timespec;\n       Result     : Interfaces.C.int;\n@@ -1301,38 +1322,36 @@ package body System.Task_Primitives.Operations is\n          pragma Assert (Check_Sleep (Delay_Sleep));\n \n          loop\n-            if Dynamic_Priority_Support and then\n-              Self_ID.Pending_Priority_Change then\n-               Self_ID.Pending_Priority_Change := False;\n-               Self_ID.Common.Base_Priority := Self_ID.New_Base_Priority;\n-               Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n-            end if;\n-\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n             if Single_Lock then\n-               Result := cond_timedwait\n-                           (Self_ID.Common.LL.CV'Access,\n-                            Single_RTS_Lock.L'Access,\n-                            Request'Access);\n+               Result :=\n+                 cond_timedwait\n+                   (Self_ID.Common.LL.CV'Access,\n+                    Single_RTS_Lock.L'Access,\n+                    Request'Access);\n             else\n-               Result := cond_timedwait\n-                           (Self_ID.Common.LL.CV'Access,\n-                            Self_ID.Common.LL.L.L'Access,\n-                            Request'Access);\n+               Result :=\n+                 cond_timedwait\n+                   (Self_ID.Common.LL.CV'Access,\n+                    Self_ID.Common.LL.L.L'Access,\n+                    Request'Access);\n             end if;\n \n             Yielded := True;\n \n-            exit when Abs_Time <= Monotonic_Clock;\n+            Check_Time := Monotonic_Clock;\n+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n \n-            pragma Assert (Result = 0 or else\n-              Result = ETIME or else\n-              Result = EINTR);\n+            pragma Assert\n+              (Result = 0     or else\n+               Result = ETIME or else\n+               Result = EINTR);\n          end loop;\n \n-         pragma Assert (Record_Wakeup\n-           (To_Lock_Ptr (Self_ID.Common.LL.L'Access), Delay_Sleep));\n+         pragma Assert\n+           (Record_Wakeup\n+              (To_Lock_Ptr (Self_ID.Common.LL.L'Access), Delay_Sleep));\n \n          Self_ID.Common.State := Runnable;\n       end if;\n@@ -1357,7 +1376,6 @@ package body System.Task_Primitives.Operations is\n       Reason : Task_States)\n    is\n       Result : Interfaces.C.int;\n-\n    begin\n       pragma Assert (Check_Wakeup (T, Reason));\n       Result := cond_signal (T.Common.LL.CV'Access);\n@@ -1368,8 +1386,8 @@ package body System.Task_Primitives.Operations is\n    -- Check_Initialize_Lock --\n    ---------------------------\n \n-   --  The following code is intended to check some of the invariant\n-   --  assertions related to lock usage, on which we depend.\n+   --  The following code is intended to check some of the invariant assertions\n+   --  related to lock usage, on which we depend.\n \n    function Check_Initialize_Lock\n      (L     : Lock_Ptr;\n@@ -1605,10 +1623,14 @@ package body System.Task_Primitives.Operations is\n          return False;\n       end if;\n \n+      --  Magic constant 4???\n+\n       if L.Level = 4 then\n          Check_Count := Unlock_Count;\n       end if;\n \n+      --  Magic constant 1000???\n+\n       if Unlock_Count - Check_Count > 1000 then\n          Check_Count := Unlock_Count;\n       end if;\n@@ -1664,9 +1686,9 @@ package body System.Task_Primitives.Operations is\n \n    procedure Initialize (S : in out Suspension_Object) is\n       Result : Interfaces.C.int;\n+\n    begin\n-      --  Initialize internal state. It is always initialized to False (ARM\n-      --  D.10 par. 6).\n+      --  Initialize internal state (always to zero (RM D.10(6)))\n \n       S.State := False;\n       S.Waiting := False;\n@@ -1701,6 +1723,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Finalize (S : in out Suspension_Object) is\n       Result  : Interfaces.C.int;\n+\n    begin\n       --  Destroy internal mutex\n \n@@ -1731,6 +1754,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Set_False (S : in out Suspension_Object) is\n       Result  : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n@@ -1751,6 +1775,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Set_True (S : in out Suspension_Object) is\n       Result : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n@@ -1768,6 +1793,7 @@ package body System.Task_Primitives.Operations is\n \n          Result := cond_signal (S.CV'Access);\n          pragma Assert (Result = 0);\n+\n       else\n          S.State := True;\n       end if;\n@@ -1784,23 +1810,26 @@ package body System.Task_Primitives.Operations is\n \n    procedure Suspend_Until_True (S : in out Suspension_Object) is\n       Result : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n       Result := mutex_lock (S.L'Access);\n       pragma Assert (Result = 0);\n \n       if S.Waiting then\n+\n          --  Program_Error must be raised upon calling Suspend_Until_True\n          --  if another task is already waiting on that suspension object\n-         --  (ARM D.10 par. 10).\n+         --  (RM D.10(10)).\n \n          Result := mutex_unlock (S.L'Access);\n          pragma Assert (Result = 0);\n \n          SSL.Abort_Undefer.all;\n \n          raise Program_Error;\n+\n       else\n          --  Suspend the task if the state is False. Otherwise, the task\n          --  continues its execution, and the state of the suspension object"}, {"sha": "c778b992b0d27a8ca1ea599eaa3e90a03062fa8e", "filename": "gcc/ada/s-taprop-tru64.adb", "status": "modified", "additions": 166, "deletions": 118, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taprop-tru64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taprop-tru64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-tru64.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2006, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2007, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -69,7 +69,7 @@ with System.Soft_Links;\n --  For example when using the restricted run time, it is replaced by\n --  System.Tasking.Restricted.Stages.\n \n-with Unchecked_Deallocation;\n+with Ada.Unchecked_Deallocation;\n \n package body System.Task_Primitives.Operations is\n \n@@ -185,15 +185,18 @@ package body System.Task_Primitives.Operations is\n       end if;\n \n       if T.Deferral_Level = 0\n-        and then T.Pending_ATC_Level < T.ATC_Nesting_Level and then\n-        not T.Aborting\n+        and then T.Pending_ATC_Level < T.ATC_Nesting_Level\n+        and then not T.Aborting\n       then\n          T.Aborting := True;\n \n          --  Make sure signals used for RTS internal purpose are unmasked\n \n-         Result := pthread_sigmask (SIG_UNBLOCK,\n-           Unblocked_Signal_Mask'Unchecked_Access, Old_Set'Unchecked_Access);\n+         Result :=\n+           pthread_sigmask\n+             (SIG_UNBLOCK,\n+              Unblocked_Signal_Mask'Unchecked_Access,\n+              Old_Set'Unchecked_Access);\n          pragma Assert (Result = 0);\n \n          raise Standard'Abort_Signal;\n@@ -204,8 +207,8 @@ package body System.Task_Primitives.Operations is\n    -- Stack_Guard  --\n    ------------------\n \n-   --  The underlying thread system sets a guard page at the\n-   --  bottom of a thread stack, so nothing is needed.\n+   --  The underlying thread system sets a guard page at the bottom of a thread\n+   --  stack, so nothing is needed.\n \n    procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n       pragma Unreferenced (T);\n@@ -233,12 +236,11 @@ package body System.Task_Primitives.Operations is\n    -- Initialize_Lock --\n    ---------------------\n \n-   --  Note: mutexes and cond_variables needed per-task basis are\n-   --        initialized in Initialize_TCB and the Storage_Error is\n-   --        handled. Other mutexes (such as RTS_Lock, Memory_Lock...)\n-   --        used in RTS is initialized before any status change of RTS.\n-   --        Therefore rasing Storage_Error in the following routines\n-   --        should be able to be handled safely.\n+   --  Note: mutexes and cond_variables needed per-task basis are initialized\n+   --  in Initialize_TCB and the Storage_Error is handled. Other mutexes (such\n+   --  as RTS_Lock, Memory_Lock...) used in RTS is initialized before any\n+   --  status change of RTS. Therefore rasing Storage_Error in the following\n+   --  routines should be able to be handled safely.\n \n    procedure Initialize_Lock\n      (Prio : System.Any_Priority;\n@@ -272,7 +274,8 @@ package body System.Task_Primitives.Operations is\n    end Initialize_Lock;\n \n    procedure Initialize_Lock\n-     (L : not null access RTS_Lock; Level : Lock_Level)\n+     (L     : not null access RTS_Lock;\n+      Level : Lock_Level)\n    is\n       pragma Unreferenced (Level);\n \n@@ -322,7 +325,8 @@ package body System.Task_Primitives.Operations is\n    ----------------\n \n    procedure Write_Lock\n-     (L : not null access Lock; Ceiling_Violation : out Boolean)\n+     (L                 : not null access Lock;\n+      Ceiling_Violation : out Boolean)\n    is\n       Result         : Interfaces.C.int;\n       Self_ID        : Task_Id;\n@@ -354,7 +358,8 @@ package body System.Task_Primitives.Operations is\n    end Write_Lock;\n \n    procedure Write_Lock\n-     (L : not null access RTS_Lock; Global_Lock : Boolean := False)\n+     (L           : not null access RTS_Lock;\n+      Global_Lock : Boolean := False)\n    is\n       Result : Interfaces.C.int;\n    begin\n@@ -378,7 +383,9 @@ package body System.Task_Primitives.Operations is\n    ---------------\n \n    procedure Read_Lock\n-     (L : not null access Lock; Ceiling_Violation : out Boolean) is\n+     (L                 : not null access Lock;\n+      Ceiling_Violation : out Boolean)\n+   is\n    begin\n       Write_Lock (L, Ceiling_Violation);\n    end Read_Lock;\n@@ -395,7 +402,8 @@ package body System.Task_Primitives.Operations is\n    end Unlock;\n \n    procedure Unlock\n-     (L : not null access RTS_Lock; Global_Lock : Boolean := False)\n+     (L           : not null access RTS_Lock;\n+      Global_Lock : Boolean := False)\n    is\n       Result : Interfaces.C.int;\n    begin\n@@ -414,6 +422,21 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n+   -----------------\n+   -- Set_Ceiling --\n+   -----------------\n+\n+   --  Dynamic priority ceilings are not supported by the underlying system\n+\n+   procedure Set_Ceiling\n+     (L    : not null access Lock;\n+      Prio : System.Any_Priority)\n+   is\n+      pragma Unreferenced (L, Prio);\n+   begin\n+      null;\n+   end Set_Ceiling;\n+\n    -----------\n    -- Sleep --\n    -----------\n@@ -428,11 +451,13 @@ package body System.Task_Primitives.Operations is\n \n    begin\n       if Single_Lock then\n-         Result := pthread_cond_wait\n-                     (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n+         Result :=\n+           pthread_cond_wait\n+             (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n       else\n-         Result := pthread_cond_wait\n-                     (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n+         Result :=\n+           pthread_cond_wait\n+             (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n       end if;\n \n       --  EINTR is not considered a failure\n@@ -444,9 +469,8 @@ package body System.Task_Primitives.Operations is\n    -- Timed_Sleep --\n    -----------------\n \n-   --  This is for use within the run-time system, so abort is\n-   --  assumed to be already deferred, and the caller should be\n-   --  holding its own ATCB lock.\n+   --  This is for use within the run-time system, so abort is assumed to be\n+   --  already deferred, and the caller should be holding its own ATCB lock.\n \n    procedure Timed_Sleep\n      (Self_ID  : Task_Id;\n@@ -458,7 +482,8 @@ package body System.Task_Primitives.Operations is\n    is\n       pragma Unreferenced (Reason);\n \n-      Check_Time : constant Duration := Monotonic_Clock;\n+      Base_Time  : constant Duration := Monotonic_Clock;\n+      Check_Time : Duration := Base_Time;\n       Abs_Time   : Duration;\n       Request    : aliased timespec;\n       Result     : Interfaces.C.int;\n@@ -477,23 +502,25 @@ package body System.Task_Primitives.Operations is\n          Request := To_Timespec (Abs_Time);\n \n          loop\n-            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n-              or else Self_ID.Pending_Priority_Change;\n+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n             if Single_Lock then\n-               Result := pthread_cond_timedwait\n-                           (Self_ID.Common.LL.CV'Access,\n-                            Single_RTS_Lock'Access,\n-                            Request'Access);\n+               Result :=\n+                 pthread_cond_timedwait\n+                   (Self_ID.Common.LL.CV'Access,\n+                    Single_RTS_Lock'Access,\n+                    Request'Access);\n \n             else\n-               Result := pthread_cond_timedwait\n-                           (Self_ID.Common.LL.CV'Access,\n-                            Self_ID.Common.LL.L'Access,\n-                            Request'Access);\n+               Result :=\n+                 pthread_cond_timedwait\n+                   (Self_ID.Common.LL.CV'Access,\n+                    Self_ID.Common.LL.L'Access,\n+                    Request'Access);\n             end if;\n \n-            exit when Abs_Time <= Monotonic_Clock;\n+            Check_Time := Monotonic_Clock;\n+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n \n             if Result = 0 or Result = EINTR then\n \n@@ -512,16 +539,16 @@ package body System.Task_Primitives.Operations is\n    -- Timed_Delay --\n    -----------------\n \n-   --  This is for use in implementing delay statements, so\n-   --  we assume the caller is abort-deferred but is holding\n-   --  no locks.\n+   --  This is for use in implementing delay statements, so we assume the\n+   --  caller is abort-deferred but is holding no locks.\n \n    procedure Timed_Delay\n      (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes)\n    is\n-      Check_Time : constant Duration := Monotonic_Clock;\n+      Base_Time  : constant Duration := Monotonic_Clock;\n+      Check_Time : Duration := Base_Time;\n       Abs_Time   : Duration;\n       Request    : aliased timespec;\n       Result     : Interfaces.C.int;\n@@ -544,29 +571,28 @@ package body System.Task_Primitives.Operations is\n          Self_ID.Common.State := Delay_Sleep;\n \n          loop\n-            if Self_ID.Pending_Priority_Change then\n-               Self_ID.Pending_Priority_Change := False;\n-               Self_ID.Common.Base_Priority := Self_ID.New_Base_Priority;\n-               Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n-            end if;\n-\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n             if Single_Lock then\n-               Result := pthread_cond_timedwait\n-                           (Self_ID.Common.LL.CV'Access,\n-                            Single_RTS_Lock'Access,\n-                            Request'Access);\n+               Result :=\n+                 pthread_cond_timedwait\n+                   (Self_ID.Common.LL.CV'Access,\n+                    Single_RTS_Lock'Access,\n+                    Request'Access);\n             else\n-               Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n-                 Self_ID.Common.LL.L'Access, Request'Access);\n+               Result :=\n+                 pthread_cond_timedwait\n+                   (Self_ID.Common.LL.CV'Access,\n+                    Self_ID.Common.LL.L'Access,\n+                    Request'Access);\n             end if;\n \n-            exit when Abs_Time <= Monotonic_Clock;\n+            Check_Time := Monotonic_Clock;\n+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n \n-            pragma Assert (Result = 0 or else\n-              Result = ETIMEDOUT or else\n-              Result = EINTR);\n+            pragma Assert (Result = 0         or else\n+                           Result = ETIMEDOUT or else\n+                           Result = EINTR);\n          end loop;\n \n          Self_ID.Common.State := Runnable;\n@@ -658,19 +684,22 @@ package body System.Task_Primitives.Operations is\n         or else Priority_Specific_Policy = 'R'\n         or else Time_Slice_Val > 0\n       then\n-         Result := pthread_setschedparam\n-                     (T.Common.LL.Thread, SCHED_RR, Param'Access);\n+         Result :=\n+           pthread_setschedparam\n+             (T.Common.LL.Thread, SCHED_RR, Param'Access);\n \n       elsif Dispatching_Policy = 'F'\n         or else Priority_Specific_Policy = 'F'\n         or else Time_Slice_Val = 0\n       then\n-         Result := pthread_setschedparam\n-                     (T.Common.LL.Thread, SCHED_FIFO, Param'Access);\n+         Result :=\n+           pthread_setschedparam\n+             (T.Common.LL.Thread, SCHED_FIFO, Param'Access);\n \n       else\n-         Result := pthread_setschedparam\n-                     (T.Common.LL.Thread, SCHED_OTHER, Param'Access);\n+         Result :=\n+           pthread_setschedparam\n+             (T.Common.LL.Thread, SCHED_OTHER, Param'Access);\n       end if;\n \n       pragma Assert (Result = 0);\n@@ -751,8 +780,9 @@ package body System.Task_Primitives.Operations is\n          pragma Assert (Result = 0 or else Result = ENOMEM);\n \n          if Result = 0 then\n-            Result := pthread_mutex_init\n-                        (Self_ID.Common.LL.L'Access, Mutex_Attr'Access);\n+            Result :=\n+              pthread_mutex_init\n+                (Self_ID.Common.LL.L'Access, Mutex_Attr'Access);\n             pragma Assert (Result = 0 or else Result = ENOMEM);\n          end if;\n \n@@ -769,8 +799,9 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Result = 0 or else Result = ENOMEM);\n \n       if Result = 0 then\n-         Result := pthread_cond_init\n-                     (Self_ID.Common.LL.CV'Access, Cond_Attr'Access);\n+         Result :=\n+           pthread_cond_init\n+             (Self_ID.Common.LL.CV'Access, Cond_Attr'Access);\n          pragma Assert (Result = 0 or else Result = ENOMEM);\n       end if;\n \n@@ -826,60 +857,69 @@ package body System.Task_Primitives.Operations is\n          return;\n       end if;\n \n-      Result := pthread_attr_setdetachstate\n-                  (Attributes'Access, PTHREAD_CREATE_DETACHED);\n+      Result :=\n+        pthread_attr_setdetachstate\n+          (Attributes'Access, PTHREAD_CREATE_DETACHED);\n       pragma Assert (Result = 0);\n \n-      Result := pthread_attr_setstacksize\n-                  (Attributes'Access, Adjusted_Stack_Size);\n+      Result :=\n+        pthread_attr_setstacksize\n+          (Attributes'Access, Adjusted_Stack_Size);\n       pragma Assert (Result = 0);\n \n       Param.sched_priority :=\n         Interfaces.C.int (Underlying_Priorities (Priority));\n-      Result := pthread_attr_setschedparam\n-                  (Attributes'Access, Param'Access);\n+      Result :=\n+        pthread_attr_setschedparam\n+          (Attributes'Access, Param'Access);\n       pragma Assert (Result = 0);\n \n       if Dispatching_Policy = 'R'\n         or else Priority_Specific_Policy = 'R'\n         or else Time_Slice_Val > 0\n       then\n-         Result := pthread_attr_setschedpolicy\n-                     (Attributes'Access, System.OS_Interface.SCHED_RR);\n+         Result :=\n+           pthread_attr_setschedpolicy\n+             (Attributes'Access, System.OS_Interface.SCHED_RR);\n \n       elsif Dispatching_Policy = 'F'\n         or else Priority_Specific_Policy = 'F'\n         or else Time_Slice_Val = 0\n       then\n-         Result := pthread_attr_setschedpolicy\n-                     (Attributes'Access, System.OS_Interface.SCHED_FIFO);\n+         Result :=\n+           pthread_attr_setschedpolicy\n+             (Attributes'Access, System.OS_Interface.SCHED_FIFO);\n \n       else\n-         Result := pthread_attr_setschedpolicy\n-                     (Attributes'Access, System.OS_Interface.SCHED_OTHER);\n+         Result :=\n+           pthread_attr_setschedpolicy\n+             (Attributes'Access, System.OS_Interface.SCHED_OTHER);\n       end if;\n \n       pragma Assert (Result = 0);\n \n-      --  Set the scheduling parameters explicitly, since this is the\n-      --  only way to force the OS to take e.g. the sched policy and scope\n-      --  attributes into account.\n+      --  Set the scheduling parameters explicitly, since this is the only way\n+      --  to force the OS to take e.g. the sched policy and scope attributes\n+      --  into account.\n \n-      Result := pthread_attr_setinheritsched\n-                  (Attributes'Access, PTHREAD_EXPLICIT_SCHED);\n+      Result :=\n+        pthread_attr_setinheritsched\n+          (Attributes'Access, PTHREAD_EXPLICIT_SCHED);\n       pragma Assert (Result = 0);\n \n       T.Common.Current_Priority := Priority;\n \n       if T.Common.Task_Info /= null then\n          case T.Common.Task_Info.Contention_Scope is\n             when System.Task_Info.Process_Scope =>\n-               Result := pthread_attr_setscope\n-                           (Attributes'Access, PTHREAD_SCOPE_PROCESS);\n+               Result :=\n+                 pthread_attr_setscope\n+                   (Attributes'Access, PTHREAD_SCOPE_PROCESS);\n \n             when System.Task_Info.System_Scope =>\n-               Result := pthread_attr_setscope\n-                           (Attributes'Access, PTHREAD_SCOPE_SYSTEM);\n+               Result :=\n+                 pthread_attr_setscope\n+                   (Attributes'Access, PTHREAD_SCOPE_SYSTEM);\n \n             when System.Task_Info.Default_Scope =>\n                Result := 0;\n@@ -893,11 +933,12 @@ package body System.Task_Primitives.Operations is\n       --  do not need to manipulate caller's signal mask at this point.\n       --  All tasks in RTS will have All_Tasks_Mask initially.\n \n-      Result := pthread_create\n-                  (T.Common.LL.Thread'Access,\n-                   Attributes'Access,\n-                   Thread_Body_Access (Wrapper),\n-                   To_Address (T));\n+      Result :=\n+        pthread_create\n+          (T.Common.LL.Thread'Access,\n+           Attributes'Access,\n+           Thread_Body_Access (Wrapper),\n+           To_Address (T));\n       pragma Assert (Result = 0 or else Result = EAGAIN);\n \n       Succeeded := Result = 0;\n@@ -906,18 +947,21 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Result = 0);\n \n       if T.Common.Task_Info /= null then\n+\n          --  ??? We're using a process-wide function to implement a task\n          --  specific characteristic.\n \n          if T.Common.Task_Info.Bind_To_Cpu_Number = 0 then\n             Result := bind_to_cpu (Curpid, 0);\n+\n          elsif T.Common.Task_Info.Bind_To_Cpu_Number > 0 then\n-            Result := bind_to_cpu\n-              (Curpid,\n-               Interfaces.C.unsigned_long (\n-                 Interfaces.Shift_Left\n-                   (Interfaces.Unsigned_64'(1),\n-                    T.Common.Task_Info.Bind_To_Cpu_Number - 1)));\n+            Result :=\n+              bind_to_cpu\n+                (Curpid,\n+                 Interfaces.C.unsigned_long (\n+                   Interfaces.Shift_Left\n+                     (Interfaces.Unsigned_64'(1),\n+                      T.Common.Task_Info.Bind_To_Cpu_Number - 1)));\n             pragma Assert (Result = 0);\n          end if;\n       end if;\n@@ -933,7 +977,7 @@ package body System.Task_Primitives.Operations is\n       Is_Self : constant Boolean := T = Self;\n \n       procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n+        Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n    begin\n       if not Single_Lock then\n@@ -984,9 +1028,9 @@ package body System.Task_Primitives.Operations is\n       Mutex_Attr : aliased pthread_mutexattr_t;\n       Cond_Attr  : aliased pthread_condattr_t;\n       Result     : Interfaces.C.int;\n+\n    begin\n-      --  Initialize internal state. It is always initialized to False (ARM\n-      --  D.10 par. 6).\n+      --  Initialize internal state (always to False (RM D.10(6)))\n \n       S.State := False;\n       S.Waiting := False;\n@@ -1036,6 +1080,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Finalize (S : in out Suspension_Object) is\n       Result  : Interfaces.C.int;\n+\n    begin\n       --  Destroy internal mutex\n \n@@ -1066,6 +1111,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Set_False (S : in out Suspension_Object) is\n       Result  : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n@@ -1086,23 +1132,24 @@ package body System.Task_Primitives.Operations is\n \n    procedure Set_True (S : in out Suspension_Object) is\n       Result : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n       Result := pthread_mutex_lock (S.L'Access);\n       pragma Assert (Result = 0);\n \n-      --  If there is already a task waiting on this suspension object then\n-      --  we resume it, leaving the state of the suspension object to False,\n-      --  as it is specified in ARM D.10 par. 9. Otherwise, it just leaves\n-      --  the state to True.\n+      --  If there is already a task waiting on this suspension object then we\n+      --  resume it, leaving the state of the suspension object to False, as\n+      --  specified in (RM D.10(9)). Otherwise, leave the state set to True.\n \n       if S.Waiting then\n          S.Waiting := False;\n          S.State := False;\n \n          Result := pthread_cond_signal (S.CV'Access);\n          pragma Assert (Result = 0);\n+\n       else\n          S.State := True;\n       end if;\n@@ -1119,27 +1166,30 @@ package body System.Task_Primitives.Operations is\n \n    procedure Suspend_Until_True (S : in out Suspension_Object) is\n       Result : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n       Result := pthread_mutex_lock (S.L'Access);\n       pragma Assert (Result = 0);\n \n       if S.Waiting then\n+\n          --  Program_Error must be raised upon calling Suspend_Until_True\n          --  if another task is already waiting on that suspension object\n-         --  (ARM D.10 par. 10).\n+         --  (AM D.10(10)).\n \n          Result := pthread_mutex_unlock (S.L'Access);\n          pragma Assert (Result = 0);\n \n          SSL.Abort_Undefer.all;\n \n          raise Program_Error;\n+\n       else\n          --  Suspend the task if the state is False. Otherwise, the task\n          --  continues its execution, and the state of the suspension object\n-         --  is set to False (ARM D.10 par. 9).\n+         --  is set to False (RM D.10(9)).\n \n          if S.State then\n             S.State := False;\n@@ -1212,8 +1262,7 @@ package body System.Task_Primitives.Operations is\n      (T           : ST.Task_Id;\n       Thread_Self : Thread_Id) return Boolean\n    is\n-      pragma Warnings (Off, T);\n-      pragma Warnings (Off, Thread_Self);\n+      pragma Unreferenced (T, Thread_Self);\n    begin\n       return False;\n    end Suspend_Task;\n@@ -1226,8 +1275,7 @@ package body System.Task_Primitives.Operations is\n      (T           : ST.Task_Id;\n       Thread_Self : Thread_Id) return Boolean\n    is\n-      pragma Warnings (Off, T);\n-      pragma Warnings (Off, Thread_Self);\n+      pragma Unreferenced (T, Thread_Self);\n    begin\n       return False;\n    end Resume_Task;\n@@ -1284,8 +1332,8 @@ package body System.Task_Primitives.Operations is\n \n       --  Install the abort-signal handler\n \n-      if State (System.Interrupt_Management.Abort_Task_Interrupt)\n-        /= Default\n+      if State\n+          (System.Interrupt_Management.Abort_Task_Interrupt) /= Default\n       then\n          act.sa_flags := 0;\n          act.sa_handler := Abort_Handler'Address;\n@@ -1296,9 +1344,9 @@ package body System.Task_Primitives.Operations is\n \n          Result :=\n            sigaction\n-           (Signal (System.Interrupt_Management.Abort_Task_Interrupt),\n-            act'Unchecked_Access,\n-            old_act'Unchecked_Access);\n+             (Signal (System.Interrupt_Management.Abort_Task_Interrupt),\n+              act'Unchecked_Access,\n+              old_act'Unchecked_Access);\n          pragma Assert (Result = 0);\n       end if;\n    end Initialize;"}, {"sha": "5cade02b2775f26521fa000c5826ce9cc79ea1e2", "filename": "gcc/ada/s-taprop-vms.adb", "status": "modified", "additions": 106, "deletions": 71, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taprop-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taprop-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vms.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2006, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2007, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -54,8 +54,8 @@ with System.Soft_Links;\n --  used for Get_Exc_Stack_Addr\n --           Abort_Defer/Undefer\n \n-with Unchecked_Conversion;\n-with Unchecked_Deallocation;\n+with Ada.Unchecked_Conversion;\n+with Ada.Unchecked_Deallocation;\n \n package body System.Task_Primitives.Operations is\n \n@@ -85,7 +85,7 @@ package body System.Task_Primitives.Operations is\n    --  Key used to find the Ada Task_Id associated with a thread\n \n    Environment_Task_Id : Task_Id;\n-   --  A variable to hold Task_Id for the environment task.\n+   --  A variable to hold Task_Id for the environment task\n \n    Time_Slice_Val : Integer;\n    pragma Import (C, Time_Slice_Val, \"__gl_time_slice_val\");\n@@ -94,7 +94,7 @@ package body System.Task_Primitives.Operations is\n    pragma Import (C, Dispatching_Policy, \"__gl_task_dispatching_policy\");\n \n    Foreign_Task_Elaborated : aliased Boolean := True;\n-   --  Used to identified fake tasks (i.e., non-Ada Threads).\n+   --  Used to identified fake tasks (i.e., non-Ada Threads)\n \n    --------------------\n    -- Local Packages --\n@@ -104,7 +104,7 @@ package body System.Task_Primitives.Operations is\n \n       procedure Initialize (Environment_Task : Task_Id);\n       pragma Inline (Initialize);\n-      --  Initialize various data needed by this package.\n+      --  Initialize various data needed by this package\n \n       function Is_Valid_Task return Boolean;\n       pragma Inline (Is_Valid_Task);\n@@ -121,7 +121,7 @@ package body System.Task_Primitives.Operations is\n    end Specific;\n \n    package body Specific is separate;\n-   --  The body of this package is target specific.\n+   --  The body of this package is target specific\n \n    ---------------------------------\n    -- Support for foreign threads --\n@@ -137,15 +137,17 @@ package body System.Task_Primitives.Operations is\n    -- Local Subprograms --\n    -----------------------\n \n-   function To_Task_Id is new Unchecked_Conversion (System.Address, Task_Id);\n+   function To_Task_Id is\n+     new Ada.Unchecked_Conversion (System.Address, Task_Id);\n \n-   function To_Address is new Unchecked_Conversion (Task_Id, System.Address);\n+   function To_Address is\n+     new Ada.Unchecked_Conversion (Task_Id, System.Address);\n \n    function Get_Exc_Stack_Addr return Address;\n    --  Replace System.Soft_Links.Get_Exc_Stack_Addr_NT\n \n    procedure Timer_Sleep_AST (ID : Address);\n-   --  Signal the condition variable when AST fires.\n+   --  Signal the condition variable when AST fires\n \n    procedure Timer_Sleep_AST (ID : Address) is\n       Result  : Interfaces.C.int;\n@@ -160,8 +162,8 @@ package body System.Task_Primitives.Operations is\n    -- Stack_Guard --\n    -----------------\n \n-   --  The underlying thread system sets a guard page at the\n-   --  bottom of a thread stack, so nothing is needed.\n+   --  The underlying thread system sets a guard page at the bottom of a thread\n+   --  stack, so nothing is needed.\n    --  ??? Check the comment above\n \n    procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n@@ -190,15 +192,15 @@ package body System.Task_Primitives.Operations is\n    -- Initialize_Lock --\n    ---------------------\n \n-   --  Note: mutexes and cond_variables needed per-task basis are\n-   --  initialized in Initialize_TCB and the Storage_Error is\n-   --  handled. Other mutexes (such as RTS_Lock, Memory_Lock...)\n-   --  used in RTS is initialized before any status change of RTS.\n-   --  Therefore rasing Storage_Error in the following routines\n-   --  should be able to be handled safely.\n+   --  Note: mutexes and cond_variables needed per-task basis are initialized\n+   --  in Initialize_TCB and the Storage_Error is handled. Other mutexes (such\n+   --  as RTS_Lock, Memory_Lock...) used in RTS is initialized before any\n+   --  status change of RTS. Therefore rasing Storage_Error in the following\n+   --  routines should be able to be handled safely.\n \n    procedure Initialize_Lock\n-     (Prio : System.Any_Priority; L : not null access Lock)\n+     (Prio : System.Any_Priority;\n+      L    : not null access Lock)\n    is\n       Attributes : aliased pthread_mutexattr_t;\n       Result     : Interfaces.C.int;\n@@ -226,7 +228,8 @@ package body System.Task_Primitives.Operations is\n    end Initialize_Lock;\n \n    procedure Initialize_Lock\n-     (L : not null access RTS_Lock; Level : Lock_Level)\n+     (L     : not null access RTS_Lock;\n+      Level : Lock_Level)\n    is\n       pragma Unreferenced (Level);\n \n@@ -289,7 +292,8 @@ package body System.Task_Primitives.Operations is\n    ----------------\n \n    procedure Write_Lock\n-     (L : not null access Lock; Ceiling_Violation : out Boolean)\n+     (L                 : not null access Lock;\n+      Ceiling_Violation : out Boolean)\n    is\n       Self_ID        : constant Task_Id := Self;\n       All_Tasks_Link : constant Task_Id := Self.Common.All_Tasks_Link;\n@@ -343,7 +347,9 @@ package body System.Task_Primitives.Operations is\n    ---------------\n \n    procedure Read_Lock\n-     (L : not null access Lock; Ceiling_Violation : out Boolean) is\n+     (L                 : not null access Lock;\n+      Ceiling_Violation : out Boolean)\n+   is\n    begin\n       Write_Lock (L, Ceiling_Violation);\n    end Read_Lock;\n@@ -360,7 +366,8 @@ package body System.Task_Primitives.Operations is\n    end Unlock;\n \n    procedure Unlock\n-     (L : not null access RTS_Lock; Global_Lock : Boolean := False)\n+     (L           : not null access RTS_Lock;\n+      Global_Lock : Boolean := False)\n    is\n       Result : Interfaces.C.int;\n    begin\n@@ -379,6 +386,21 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n+   -----------------\n+   -- Set_Ceiling --\n+   -----------------\n+\n+   --  Dynamic priority ceilings are not supported by the underlying system\n+\n+   procedure Set_Ceiling\n+     (L    : not null access Lock;\n+      Prio : System.Any_Priority)\n+   is\n+      pragma Unreferenced (L, Prio);\n+   begin\n+      null;\n+   end Set_Ceiling;\n+\n    -----------\n    -- Sleep --\n    -----------\n@@ -392,11 +414,13 @@ package body System.Task_Primitives.Operations is\n \n    begin\n       if Single_Lock then\n-         Result := pthread_cond_wait\n-           (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n+         Result :=\n+           pthread_cond_wait\n+             (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n       else\n-         Result := pthread_cond_wait\n-           (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n+         Result :=\n+           pthread_cond_wait\n+             (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n       end if;\n \n       --  EINTR is not considered a failure\n@@ -437,9 +461,7 @@ package body System.Task_Primitives.Operations is\n \n       Sleep_Time := To_OS_Time (Time, Mode);\n \n-      if Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n-        or else Self_ID.Pending_Priority_Change\n-      then\n+      if Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level then\n          return;\n       end if;\n \n@@ -454,13 +476,15 @@ package body System.Task_Primitives.Operations is\n       end if;\n \n       if Single_Lock then\n-         Result := pthread_cond_wait\n-           (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n+         Result :=\n+           pthread_cond_wait\n+             (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n          pragma Assert (Result = 0);\n \n       else\n-         Result := pthread_cond_wait\n-           (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n+         Result :=\n+           pthread_cond_wait\n+             (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n          pragma Assert (Result = 0);\n       end if;\n \n@@ -508,30 +532,30 @@ package body System.Task_Primitives.Operations is\n              (Status, 0, Sleep_Time,\n               Timer_Sleep_AST'Access, To_Address (Self_ID), 0);\n \n+            --  Comment following test\n+\n             if (Status and 1) /= 1 then\n                raise Storage_Error;\n             end if;\n \n             loop\n-               if Self_ID.Pending_Priority_Change then\n-                  Self_ID.Pending_Priority_Change := False;\n-                  Self_ID.Common.Base_Priority := Self_ID.New_Base_Priority;\n-                  Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n-               end if;\n-\n                if Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level then\n                   Sys_Cantim (Status, To_Address (Self_ID), 0);\n                   pragma Assert ((Status and 1) = 1);\n                   exit;\n                end if;\n \n                if Single_Lock then\n-                  Result := pthread_cond_wait\n-                    (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n+                  Result :=\n+                    pthread_cond_wait\n+                      (Self_ID.Common.LL.CV'Access,\n+                       Single_RTS_Lock'Access);\n                   pragma Assert (Result = 0);\n                else\n-                  Result := pthread_cond_wait\n-                    (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n+                  Result :=\n+                    pthread_cond_wait\n+                      (Self_ID.Common.LL.CV'Access,\n+                       Self_ID.Common.LL.L'Access);\n                   pragma Assert (Result = 0);\n                end if;\n \n@@ -569,6 +593,7 @@ package body System.Task_Primitives.Operations is\n \n    function RT_Resolution return Duration is\n    begin\n+      --  Document origin of this magic constant ???\n       return 10#1.0#E-3;\n    end RT_Resolution;\n \n@@ -627,24 +652,27 @@ package body System.Task_Primitives.Operations is\n         or else Priority_Specific_Policy = 'R'\n         or else Time_Slice_Val > 0\n       then\n-         Result := pthread_setschedparam\n-           (T.Common.LL.Thread, SCHED_RR, Param'Access);\n+         Result :=\n+           pthread_setschedparam\n+             (T.Common.LL.Thread, SCHED_RR, Param'Access);\n \n       elsif Dispatching_Policy = 'F'\n         or else Priority_Specific_Policy = 'F'\n         or else Time_Slice_Val = 0\n       then\n-         Result := pthread_setschedparam\n-           (T.Common.LL.Thread, SCHED_FIFO, Param'Access);\n+         Result :=\n+           pthread_setschedparam\n+             (T.Common.LL.Thread, SCHED_FIFO, Param'Access);\n \n       else\n          --  SCHED_OTHER priorities are restricted to the range 8 - 15.\n          --  Since the translation from Underlying priorities results\n          --  in a range of 16 - 31, dividing by 2 gives the correct result.\n \n          Param.sched_priority := Param.sched_priority / 2;\n-         Result := pthread_setschedparam\n-           (T.Common.LL.Thread, SCHED_OTHER, Param'Access);\n+         Result :=\n+           pthread_setschedparam\n+             (T.Common.LL.Thread, SCHED_OTHER, Param'Access);\n       end if;\n \n       pragma Assert (Result = 0);\n@@ -727,8 +755,9 @@ package body System.Task_Primitives.Operations is\n          pragma Assert (Result = 0 or else Result = ENOMEM);\n \n          if Result = 0 then\n-            Result := pthread_mutex_init (Self_ID.Common.LL.L'Access,\n-              Mutex_Attr'Access);\n+            Result :=\n+              pthread_mutex_init\n+                (Self_ID.Common.LL.L'Access, Mutex_Attr'Access);\n             pragma Assert (Result = 0 or else Result = ENOMEM);\n          end if;\n \n@@ -745,8 +774,9 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Result = 0 or else Result = ENOMEM);\n \n       if Result = 0 then\n-         Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n-           Cond_Attr'Access);\n+         Result :=\n+           pthread_cond_init\n+             (Self_ID.Common.LL.CV'Access, Cond_Attr'Access);\n          pragma Assert (Result = 0 or else Result = ENOMEM);\n       end if;\n \n@@ -791,7 +821,7 @@ package body System.Task_Primitives.Operations is\n       Result     : Interfaces.C.int;\n \n       function Thread_Body_Access is new\n-        Unchecked_Conversion (System.Address, Thread_Body);\n+        Ada.Unchecked_Conversion (System.Address, Thread_Body);\n \n    begin\n       --  Since the initial signal mask of a thread is inherited from the\n@@ -822,13 +852,14 @@ package body System.Task_Primitives.Operations is\n           (Attributes'Access, PTHREAD_EXPLICIT_SCHED);\n       pragma Assert (Result = 0);\n \n-      Result := pthread_create\n-        (T.Common.LL.Thread'Access,\n-         Attributes'Access,\n-         Thread_Body_Access (Wrapper),\n-         To_Address (T));\n+      Result :=\n+        pthread_create\n+          (T.Common.LL.Thread'Access,\n+           Attributes'Access,\n+           Thread_Body_Access (Wrapper),\n+           To_Address (T));\n \n-      --  ENOMEM is a valid run-time error.  Don't shut down.\n+      --  ENOMEM is a valid run-time error -- do not shut down\n \n       pragma Assert (Result = 0\n         or else Result = EAGAIN or else Result = ENOMEM);\n@@ -853,9 +884,9 @@ package body System.Task_Primitives.Operations is\n       Is_Self : constant Boolean := T = Self;\n \n       procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n+        Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n-      procedure Free is new Unchecked_Deallocation\n+      procedure Free is new Ada.Unchecked_Deallocation\n        (Exc_Stack_T, Exc_Stack_Ptr_T);\n \n    begin\n@@ -872,7 +903,6 @@ package body System.Task_Primitives.Operations is\n       end if;\n \n       Free (T.Common.LL.Exc_Stack_Ptr);\n-\n       Free (Tmp);\n \n       if Is_Self then\n@@ -911,8 +941,7 @@ package body System.Task_Primitives.Operations is\n       Cond_Attr  : aliased pthread_condattr_t;\n       Result     : Interfaces.C.int;\n    begin\n-      --  Initialize internal state. It is always initialized to False (ARM\n-      --  D.10 par. 6).\n+      --  Initialize internal state (always to False (D.10 (6)))\n \n       S.State := False;\n       S.Waiting := False;\n@@ -977,7 +1006,8 @@ package body System.Task_Primitives.Operations is\n    --------------\n \n    procedure Finalize (S : in out Suspension_Object) is\n-      Result  : Interfaces.C.int;\n+      Result : Interfaces.C.int;\n+\n    begin\n       --  Destroy internal mutex\n \n@@ -1007,7 +1037,8 @@ package body System.Task_Primitives.Operations is\n    ---------------\n \n    procedure Set_False (S : in out Suspension_Object) is\n-      Result  : Interfaces.C.int;\n+      Result : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n@@ -1028,6 +1059,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Set_True (S : in out Suspension_Object) is\n       Result : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n@@ -1036,15 +1068,15 @@ package body System.Task_Primitives.Operations is\n \n       --  If there is already a task waiting on this suspension object then\n       --  we resume it, leaving the state of the suspension object to False,\n-      --  as it is specified in ARM D.10 par. 9. Otherwise, it just leaves\n-      --  the state to True.\n+      --  as specified in (RM D.10(9)), otherwise leave state set to True.\n \n       if S.Waiting then\n          S.Waiting := False;\n          S.State := False;\n \n          Result := pthread_cond_signal (S.CV'Access);\n          pragma Assert (Result = 0);\n+\n       else\n          S.State := True;\n       end if;\n@@ -1061,23 +1093,26 @@ package body System.Task_Primitives.Operations is\n \n    procedure Suspend_Until_True (S : in out Suspension_Object) is\n       Result : Interfaces.C.int;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n       Result := pthread_mutex_lock (S.L'Access);\n       pragma Assert (Result = 0);\n \n       if S.Waiting then\n+\n          --  Program_Error must be raised upon calling Suspend_Until_True\n          --  if another task is already waiting on that suspension object\n-         --  (ARM D.10 par. 10).\n+         --  (RM D.10(10)).\n \n          Result := pthread_mutex_unlock (S.L'Access);\n          pragma Assert (Result = 0);\n \n          SSL.Abort_Undefer.all;\n \n          raise Program_Error;\n+\n       else\n          --  Suspend the task if the state is False. Otherwise, the task\n          --  continues its execution, and the state of the suspension object"}, {"sha": "b0974a634863246111b6b745fb18e776050e1222", "filename": "gcc/ada/s-taprop-vxworks.adb", "status": "modified", "additions": 71, "deletions": 38, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taprop-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-taprop-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vxworks.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2006, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2007, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -45,7 +45,7 @@ with System.Tasking.Debug;\n \n with System.Interrupt_Management;\n --  used for Keep_Unmasked\n---           Abort_Task_Signal\n+--           Abort_Task_Interrupt\n --           Signal_ID\n --           Initialize_Interrupts\n \n@@ -59,8 +59,8 @@ with System.Soft_Links;\n --  For example when using the restricted run time, it is replaced by\n --  System.Tasking.Restricted.Stages.\n \n-with Unchecked_Conversion;\n-with Unchecked_Deallocation;\n+with Ada.Unchecked_Conversion;\n+with Ada.Unchecked_Deallocation;\n \n package body System.Task_Primitives.Operations is\n \n@@ -165,7 +165,8 @@ package body System.Task_Primitives.Operations is\n    procedure Install_Signal_Handlers;\n    --  Install the default signal handlers for the current task\n \n-   function To_Address is new Unchecked_Conversion (Task_Id, System.Address);\n+   function To_Address is\n+     new Ada.Unchecked_Conversion (Task_Id, System.Address);\n \n    -------------------\n    -- Abort_Handler --\n@@ -194,8 +195,11 @@ package body System.Task_Primitives.Operations is\n \n          --  Make sure signals used for RTS internal purpose are unmasked\n \n-         Result := pthread_sigmask (SIG_UNBLOCK,\n-           Unblocked_Signal_Mask'Unchecked_Access, Old_Set'Unchecked_Access);\n+         Result :=\n+           pthread_sigmask\n+             (SIG_UNBLOCK,\n+              Unblocked_Signal_Mask'Unchecked_Access,\n+              Old_Set'Unchecked_Access);\n          pragma Assert (Result = 0);\n \n          raise Standard'Abort_Signal;\n@@ -251,7 +255,7 @@ package body System.Task_Primitives.Operations is\n \n       Result :=\n         sigaction\n-          (Signal (Interrupt_Management.Abort_Task_Signal),\n+          (Signal (Interrupt_Management.Abort_Task_Interrupt),\n            act'Unchecked_Access,\n            old_act'Unchecked_Access);\n       pragma Assert (Result = 0);\n@@ -264,7 +268,9 @@ package body System.Task_Primitives.Operations is\n    ---------------------\n \n    procedure Initialize_Lock\n-     (Prio : System.Any_Priority; L : not null access Lock) is\n+     (Prio : System.Any_Priority;\n+      L    : not null access Lock)\n+   is\n    begin\n       L.Mutex := semMCreate (SEM_Q_PRIORITY + SEM_INVERSION_SAFE);\n       L.Prio_Ceiling := int (Prio);\n@@ -273,10 +279,10 @@ package body System.Task_Primitives.Operations is\n    end Initialize_Lock;\n \n    procedure Initialize_Lock\n-     (L : not null access RTS_Lock; Level : Lock_Level)\n+     (L     : not null access RTS_Lock;\n+      Level : Lock_Level)\n    is\n       pragma Unreferenced (Level);\n-\n    begin\n       L.Mutex := semMCreate (SEM_Q_PRIORITY + SEM_INVERSION_SAFE);\n       L.Prio_Ceiling := int (System.Any_Priority'Last);\n@@ -307,9 +313,11 @@ package body System.Task_Primitives.Operations is\n    ----------------\n \n    procedure Write_Lock\n-     (L : not null access Lock; Ceiling_Violation : out Boolean)\n+     (L                 : not null access Lock;\n+      Ceiling_Violation : out Boolean)\n    is\n       Result : int;\n+\n    begin\n       if L.Protocol = Prio_Protect\n         and then int (Self.Common.Current_Priority) > L.Prio_Ceiling\n@@ -350,7 +358,9 @@ package body System.Task_Primitives.Operations is\n    ---------------\n \n    procedure Read_Lock\n-     (L : not null access Lock; Ceiling_Violation : out Boolean) is\n+     (L                 : not null access Lock;\n+      Ceiling_Violation : out Boolean)\n+   is\n    begin\n       Write_Lock (L, Ceiling_Violation);\n    end Read_Lock;\n@@ -367,7 +377,8 @@ package body System.Task_Primitives.Operations is\n    end Unlock;\n \n    procedure Unlock\n-     (L : not null access RTS_Lock; Global_Lock : Boolean := False)\n+     (L           : not null access RTS_Lock;\n+      Global_Lock : Boolean := False)\n    is\n       Result : int;\n    begin\n@@ -386,6 +397,21 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n+   -----------------\n+   -- Set_Ceiling --\n+   -----------------\n+\n+   --  Dynamic priority ceilings are not supported by the underlying system\n+\n+   procedure Set_Ceiling\n+     (L    : not null access Lock;\n+      Prio : System.Any_Priority)\n+   is\n+      pragma Unreferenced (L, Prio);\n+   begin\n+      null;\n+   end Set_Ceiling;\n+\n    -----------\n    -- Sleep --\n    -----------\n@@ -508,6 +534,7 @@ package body System.Task_Primitives.Operations is\n \n                   if Ticks /= int'Last then\n                      Timedout := True;\n+\n                   else\n                      Ticks := To_Clock_Ticks (Absolute - Monotonic_Clock);\n \n@@ -590,7 +617,7 @@ package body System.Task_Primitives.Operations is\n \n       if Ticks > 0 then\n \n-         --  Modifying State and Pending_Priority_Change, locking the TCB\n+         --  Modifying State, locking the TCB\n \n          if Single_Lock then\n             Result := semTake (Single_RTS_Lock.Mutex, WAIT_FOREVER);\n@@ -604,12 +631,6 @@ package body System.Task_Primitives.Operations is\n          Timedout := False;\n \n          loop\n-            if Self_ID.Pending_Priority_Change then\n-               Self_ID.Pending_Priority_Change := False;\n-               Self_ID.Common.Base_Priority    := Self_ID.New_Base_Priority;\n-               Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n-            end if;\n-\n             Aborted := Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n             --  Release the TCB before sleeping\n@@ -745,7 +766,7 @@ package body System.Task_Primitives.Operations is\n         and then Loss_Of_Inheritance\n         and then Prio < T.Common.Current_Priority\n       then\n-         --  Annex D requirement [RM D.2.2 par. 9]:\n+         --  Annex D requirement (RM D.2.2(9))\n \n          --    If the task drops its priority due to the loss of inherited\n          --    priority, it is added at the head of the ready queue for its\n@@ -861,6 +882,7 @@ package body System.Task_Primitives.Operations is\n \n       if Self_ID.Common.LL.CV = 0 then\n          Succeeded := False;\n+\n       else\n          Succeeded := True;\n \n@@ -934,13 +956,14 @@ package body System.Task_Primitives.Operations is\n \n          --  Now spawn the VxWorks task for real\n \n-         T.Common.LL.Thread := taskSpawn\n-           (Name_Address,\n-            To_VxWorks_Priority (int (Priority)),\n-            Get_Task_Options,\n-            Adjusted_Stack_Size,\n-            Wrapper,\n-            To_Address (T));\n+         T.Common.LL.Thread :=\n+           taskSpawn\n+             (Name_Address,\n+              To_VxWorks_Priority (int (Priority)),\n+              Get_Task_Options,\n+              Adjusted_Stack_Size,\n+              Wrapper,\n+              To_Address (T));\n       end;\n \n       if T.Common.LL.Thread = -1 then\n@@ -963,7 +986,7 @@ package body System.Task_Primitives.Operations is\n       Is_Self : constant Boolean := (T = Self);\n \n       procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n+        Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n    begin\n       if not Single_Lock then\n@@ -1003,8 +1026,10 @@ package body System.Task_Primitives.Operations is\n    procedure Abort_Task (T : Task_Id) is\n       Result : int;\n    begin\n-      Result := kill (T.Common.LL.Thread,\n-                      Signal (Interrupt_Management.Abort_Task_Signal));\n+      Result :=\n+        kill\n+          (T.Common.LL.Thread,\n+           Signal (Interrupt_Management.Abort_Task_Interrupt));\n       pragma Assert (Result = 0);\n    end Abort_Task;\n \n@@ -1014,8 +1039,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Initialize (S : in out Suspension_Object) is\n    begin\n-      --  Initialize internal state. It is always initialized to False (ARM\n-      --  D.10 par. 6).\n+      --  Initialize internal state (always to False (RM D.10(6)))\n \n       S.State := False;\n       S.Waiting := False;\n@@ -1039,6 +1063,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Finalize (S : in out Suspension_Object) is\n       Result : STATUS;\n+\n    begin\n       --  Destroy internal mutex\n \n@@ -1068,7 +1093,8 @@ package body System.Task_Primitives.Operations is\n    ---------------\n \n    procedure Set_False (S : in out Suspension_Object) is\n-      Result  : STATUS;\n+      Result : STATUS;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n@@ -1089,6 +1115,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Set_True (S : in out Suspension_Object) is\n       Result : STATUS;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n@@ -1122,12 +1149,14 @@ package body System.Task_Primitives.Operations is\n \n    procedure Suspend_Until_True (S : in out Suspension_Object) is\n       Result : STATUS;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n       Result := semTake (S.L, WAIT_FOREVER);\n \n       if S.Waiting then\n+\n          --  Program_Error must be raised upon calling Suspend_Until_True\n          --  if another task is already waiting on that suspension object\n          --  (ARM D.10 par. 10).\n@@ -1138,6 +1167,7 @@ package body System.Task_Primitives.Operations is\n          SSL.Abort_Undefer.all;\n \n          raise Program_Error;\n+\n       else\n          --  Suspend the task if the state is False. Otherwise, the task\n          --  continues its execution, and the state of the suspension object\n@@ -1150,6 +1180,7 @@ package body System.Task_Primitives.Operations is\n             pragma Assert (Result = 0);\n \n             SSL.Abort_Undefer.all;\n+\n          else\n             S.Waiting := True;\n \n@@ -1257,6 +1288,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Initialize (Environment_Task : Task_Id) is\n       Result : int;\n+\n    begin\n       Environment_Task_Id := Environment_Task;\n \n@@ -1272,9 +1304,10 @@ package body System.Task_Primitives.Operations is\n       end if;\n \n       if Time_Slice_Val > 0 then\n-         Result := Set_Time_Slice\n-           (To_Clock_Ticks\n-              (Duration (Time_Slice_Val) / Duration (1_000_000.0)));\n+         Result :=\n+           Set_Time_Slice\n+             (To_Clock_Ticks\n+                (Duration (Time_Slice_Val) / Duration (1_000_000.0)));\n \n       elsif Dispatching_Policy = 'R' then\n          Result := Set_Time_Slice (To_Clock_Ticks (0.01));"}, {"sha": "b22a1b5794d0e11cc7db8ebf0406bb365cce728e", "filename": "gcc/ada/s-tasini.adb", "status": "modified", "additions": 27, "deletions": 88, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-tasini.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-tasini.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasini.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2005, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2007, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -81,11 +81,6 @@ package body System.Tasking.Initialization is\n    --  from all other tasks. It is only used by Task_Lock,\n    --  Task_Unlock, and Final_Task_Unlock.\n \n-   function Current_Target_Exception return AE.Exception_Occurrence;\n-   pragma Import\n-     (Ada, Current_Target_Exception, \"__gnat_current_target_exception\");\n-   --  Import this subprogram from the private part of Ada.Exceptions\n-\n    ----------------------------------------------------------------------\n    -- Tasking versions of some services needed by non-tasking programs --\n    ----------------------------------------------------------------------\n@@ -112,8 +107,11 @@ package body System.Tasking.Initialization is\n    function Get_Stack_Info return Stack_Checking.Stack_Access;\n    --  Get access to the current task's Stack_Info\n \n+   function Get_Current_Excep return SSL.EOA;\n+   --  Task-safe version of SSL.Get_Current_Excep\n+\n    procedure Update_Exception\n-     (X : AE.Exception_Occurrence := Current_Target_Exception);\n+     (X : AE.Exception_Occurrence := SSL.Current_Target_Exception);\n    --  Handle exception setting and check for pending actions\n \n    function Task_Name return String;\n@@ -170,7 +168,7 @@ package body System.Tasking.Initialization is\n \n    procedure Defer_Abort (Self_ID : Task_Id) is\n    begin\n-      if No_Abort and then not Dynamic_Priority_Support then\n+      if No_Abort then\n          return;\n       end if;\n \n@@ -211,7 +209,7 @@ package body System.Tasking.Initialization is\n \n    procedure Defer_Abort_Nestable (Self_ID : Task_Id) is\n    begin\n-      if No_Abort and then not Dynamic_Priority_Support then\n+      if No_Abort then\n          return;\n       end if;\n \n@@ -232,14 +230,23 @@ package body System.Tasking.Initialization is\n    procedure Abort_Defer is\n       Self_ID : Task_Id;\n    begin\n-      if No_Abort and then not Dynamic_Priority_Support then\n+      if No_Abort then\n          return;\n       end if;\n \n       Self_ID := STPO.Self;\n       Self_ID.Deferral_Level := Self_ID.Deferral_Level + 1;\n    end Abort_Defer;\n \n+   -----------------------\n+   -- Get_Current_Excep --\n+   -----------------------\n+\n+   function Get_Current_Excep return SSL.EOA is\n+   begin\n+      return STPO.Self.Common.Compiler_Data.Current_Excep'Access;\n+   end Get_Current_Excep;\n+\n    -----------------------\n    -- Do_Pending_Action --\n    -----------------------\n@@ -266,7 +273,6 @@ package body System.Tasking.Initialization is\n \n          Write_Lock (Self_ID);\n          Self_ID.Pending_Action := False;\n-         Poll_Base_Priority_Change (Self_ID);\n          Unlock (Self_ID);\n \n          if Single_Lock then\n@@ -368,17 +374,18 @@ package body System.Tasking.Initialization is\n       --  Notify that the tasking run time has been elaborated so that\n       --  the tasking version of the soft links can be used.\n \n-      if not No_Abort or else Dynamic_Priority_Support then\n+      if not No_Abort then\n          SSL.Abort_Defer   := Abort_Defer'Access;\n          SSL.Abort_Undefer := Abort_Undefer'Access;\n       end if;\n \n-      SSL.Update_Exception   := Update_Exception'Access;\n       SSL.Lock_Task          := Task_Lock'Access;\n       SSL.Unlock_Task        := Task_Unlock'Access;\n       SSL.Check_Abort_Status := Check_Abort_Status'Access;\n       SSL.Get_Stack_Info     := Get_Stack_Info'Access;\n       SSL.Task_Name          := Task_Name'Access;\n+      SSL.Update_Exception   := Update_Exception'Access;\n+      SSL.Get_Current_Excep  := Get_Current_Excep'Access;\n \n       --  Initialize the tasking soft links (if not done yet) that are common\n       --  to the full and the restricted run times.\n@@ -522,68 +529,6 @@ package body System.Tasking.Initialization is\n       end if;\n    end Locked_Abort_To_Level;\n \n-   -------------------------------\n-   -- Poll_Base_Priority_Change --\n-   -------------------------------\n-\n-   --  Poll for pending base priority change and for held tasks.\n-   --  This should always be called with (only) Self_ID locked.\n-   --  It may temporarily release Self_ID's lock.\n-\n-   --  The call to Yield is to force enqueuing at the\n-   --  tail of the dispatching queue.\n-\n-   --  We must unlock Self_ID for this to take effect,\n-   --  since we are inheriting high active priority from the lock.\n-\n-   --  See also Poll_Base_Priority_Change_At_Entry_Call,\n-   --  in package System.Tasking.Entry_Calls.\n-\n-   --  In this version, we check if the task is held too because\n-   --  doing this only in Do_Pending_Action is not enough.\n-\n-   procedure Poll_Base_Priority_Change (Self_ID : Task_Id) is\n-   begin\n-      if Dynamic_Priority_Support and then Self_ID.Pending_Priority_Change then\n-\n-         --  Check for ceiling violations ???\n-\n-         Self_ID.Pending_Priority_Change := False;\n-\n-         if Self_ID.Common.Base_Priority = Self_ID.New_Base_Priority then\n-            if Single_Lock then\n-               Unlock_RTS;\n-               Yield;\n-               Lock_RTS;\n-            else\n-               Unlock (Self_ID);\n-               Yield;\n-               Write_Lock (Self_ID);\n-            end if;\n-\n-         elsif Self_ID.Common.Base_Priority < Self_ID.New_Base_Priority then\n-            Self_ID.Common.Base_Priority := Self_ID.New_Base_Priority;\n-            Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n-\n-         else\n-            --  Lowering priority\n-\n-            Self_ID.Common.Base_Priority := Self_ID.New_Base_Priority;\n-            Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n-\n-            if Single_Lock then\n-               Unlock_RTS;\n-               Yield;\n-               Lock_RTS;\n-            else\n-               Unlock (Self_ID);\n-               Yield;\n-               Write_Lock (Self_ID);\n-            end if;\n-         end if;\n-      end if;\n-   end Poll_Base_Priority_Change;\n-\n    --------------------------------\n    -- Remove_From_All_Tasks_List --\n    --------------------------------\n@@ -685,7 +630,7 @@ package body System.Tasking.Initialization is\n \n    procedure Undefer_Abort (Self_ID : Task_Id) is\n    begin\n-      if No_Abort and then not Dynamic_Priority_Support then\n+      if No_Abort then\n          return;\n       end if;\n \n@@ -721,7 +666,7 @@ package body System.Tasking.Initialization is\n \n    procedure Undefer_Abort_Nestable (Self_ID : Task_Id) is\n    begin\n-      if No_Abort and then not Dynamic_Priority_Support then\n+      if No_Abort then\n          return;\n       end if;\n \n@@ -746,7 +691,7 @@ package body System.Tasking.Initialization is\n    procedure Abort_Undefer is\n       Self_ID : Task_Id;\n    begin\n-      if No_Abort and then not Dynamic_Priority_Support then\n+      if No_Abort then\n          return;\n       end if;\n \n@@ -787,7 +732,7 @@ package body System.Tasking.Initialization is\n    --  Call only when holding no locks\n \n    procedure Update_Exception\n-     (X : AE.Exception_Occurrence := Current_Target_Exception)\n+     (X : AE.Exception_Occurrence := SSL.Current_Target_Exception)\n    is\n       Self_Id : constant Task_Id := Self;\n       use Ada.Exceptions;\n@@ -806,7 +751,6 @@ package body System.Tasking.Initialization is\n \n             Write_Lock (Self_Id);\n             Self_Id.Pending_Action := False;\n-            Poll_Base_Priority_Change (Self_Id);\n             Unlock (Self_Id);\n \n             if Single_Lock then\n@@ -856,15 +800,12 @@ package body System.Tasking.Initialization is\n       New_State  : Entry_Call_State)\n    is\n       Caller : constant Task_Id := Entry_Call.Self;\n-\n    begin\n       pragma Debug (Debug.Trace\n         (Self_ID, \"Wakeup_Entry_Caller\", 'E', Caller));\n       pragma Assert (New_State = Done or else New_State = Cancelled);\n \n-      pragma Assert\n-        (Caller.Common.State /= Terminated\n-          and then Caller.Common.State /= Unactivated);\n+      pragma Assert (Caller.Common.State /= Unactivated);\n \n       Entry_Call.State := New_State;\n \n@@ -901,15 +842,13 @@ package body System.Tasking.Initialization is\n    --  the subprogram body where the real subprogram is declared.\n \n    procedure Finalize_Attributes (T : Task_Id) is\n-      pragma Warnings (Off, T);\n-\n+      pragma Unreferenced (T);\n    begin\n       null;\n    end Finalize_Attributes;\n \n    procedure Initialize_Attributes (T : Task_Id) is\n-      pragma Warnings (Off, T);\n-\n+      pragma Unreferenced (T);\n    begin\n       null;\n    end Initialize_Attributes;"}, {"sha": "41dbc218fb29830f64e78bf9d1301a38b9583735", "filename": "gcc/ada/s-tasini.ads", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-tasini.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-tasini.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasini.ads?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -139,11 +139,6 @@ package System.Tasking.Initialization is\n    --  Change the base priority of T. Has to be called with the affected\n    --  task's ATCB write-locked. May temporariliy release the lock.\n \n-   procedure Poll_Base_Priority_Change (Self_ID : Task_Id);\n-   --  Has to be called with Self_ID's ATCB write-locked.\n-   --  May temporariliy release the lock.\n-   pragma Inline (Poll_Base_Priority_Change);\n-\n    ----------------------\n    -- Task Lock/Unlock --\n    ----------------------"}, {"sha": "d448b82de262e1bfd44e787c0a4a0babfe1873cb", "filename": "gcc/ada/s-tasren.adb", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-tasren.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-tasren.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasren.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---         Copyright (C) 1992-2006, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2007, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -48,7 +48,6 @@ with System.Tasking.Entry_Calls;\n with System.Tasking.Initialization;\n --  used for Defer_Abort\n --           Undefer_Abort\n---           Poll_Base_Priority_Change\n --           Do_Pending_Action\n \n with System.Tasking.Queuing;\n@@ -71,6 +70,9 @@ with System.Tasking.Protected_Objects.Operations;\n with System.Tasking.Debug;\n --  used for Trace\n \n+with System.Restrictions;\n+--  used for Abort_Allowed\n+\n with System.Parameters;\n --  used for Single_Lock\n --           Runtime_Traces\n@@ -476,7 +478,7 @@ package body System.Tasking.Rendezvous is\n             Send_Trace_Info (E_Missed, Acceptor);\n          end if;\n \n-         Initialization.Undefer_Abort (Self_Id);\n+         Local_Undefer_Abort (Self_Id);\n          raise Tasking_Error;\n       end if;\n \n@@ -506,7 +508,7 @@ package body System.Tasking.Rendezvous is\n       Self_Id : constant Task_Id := STPO.Self;\n \n    begin\n-      Initialization.Defer_Abort (Self_Id);\n+      Initialization.Defer_Abort_Nestable (Self_Id);\n \n       if Single_Lock then\n          Lock_RTS;\n@@ -520,7 +522,7 @@ package body System.Tasking.Rendezvous is\n          Unlock_RTS;\n       end if;\n \n-      Initialization.Undefer_Abort (Self_Id);\n+      Initialization.Undefer_Abort_Nestable (Self_Id);\n       return Result;\n    end Callable;\n \n@@ -923,7 +925,11 @@ package body System.Tasking.Rendezvous is\n             then\n                Uninterpreted_Data := Self_Id.Common.Call.Uninterpreted_Data;\n \n-               pragma Assert (Self_Id.Deferral_Level = 1);\n+               pragma Assert\n+                 (Self_Id.Deferral_Level = 1\n+                   or else\n+                     (Self_Id.Deferral_Level = 0\n+                       and then not Restrictions.Abort_Allowed));\n \n                Initialization.Defer_Abort_Nestable (Self_Id);\n \n@@ -1019,7 +1025,6 @@ package body System.Tasking.Rendezvous is\n                Self_Id.Common.State := Delay_Sleep;\n \n                loop\n-                  Initialization.Poll_Base_Priority_Change (Self_Id);\n                   exit when\n                     Self_Id.Pending_ATC_Level < Self_Id.ATC_Nesting_Level;\n                   Sleep (Self_Id, Delay_Sleep);\n@@ -1097,6 +1102,11 @@ package body System.Tasking.Rendezvous is\n          Unlock_RTS;\n       end if;\n \n+      --  Call Yield to let other tasks get a chance to run as this is a\n+      --  potential dispatching point.\n+\n+      Yield (Do_Yield => False);\n+\n       Initialization.Undefer_Abort (Self_Id);\n       return Return_Count;\n    end Task_Count;\n@@ -1111,15 +1121,16 @@ package body System.Tasking.Rendezvous is\n       With_Abort : Boolean) return Boolean\n    is\n       E             : constant Task_Entry_Index :=\n-        Task_Entry_Index (Entry_Call.E);\n+                        Task_Entry_Index (Entry_Call.E);\n       Old_State     : constant Entry_Call_State := Entry_Call.State;\n       Acceptor      : constant Task_Id := Entry_Call.Called_Task;\n       Parent        : constant Task_Id := Acceptor.Common.Parent;\n       Parent_Locked : Boolean := False;\n       Null_Body     : Boolean;\n \n    begin\n-      --  Find out whether Entry_Call can be accepted immediately.\n+      --  Find out whether Entry_Call can be accepted immediately\n+\n       --  If the Acceptor is not callable, return False.\n       --  If the rendezvous can start, initiate it.\n       --  If the accept-body is trivial, also complete the rendezvous.\n@@ -1562,6 +1573,8 @@ package body System.Tasking.Rendezvous is\n             --  Wait for a normal call and a pending action until the\n             --  Wakeup_Time is reached.\n \n+            Self_Id.Common.State := Acceptor_Sleep;\n+\n             --  Try to remove calls to Sleep in the loop below by letting the\n             --  caller a chance of getting ready immediately, using Unlock\n             --  Yield. See similar action in Wait_For_Completion/Wait_For_Call.\n@@ -1588,10 +1601,7 @@ package body System.Tasking.Rendezvous is\n                Self_Id.Open_Accepts := null;\n             end if;\n \n-            Self_Id.Common.State := Acceptor_Sleep;\n-\n             loop\n-               Initialization.Poll_Base_Priority_Change (Self_Id);\n                exit when Self_Id.Open_Accepts = null;\n \n                if Timedout then\n@@ -1653,8 +1663,6 @@ package body System.Tasking.Rendezvous is\n             Self_Id.Open_Accepts := null;\n             Self_Id.Common.State := Acceptor_Sleep;\n \n-            Initialization.Poll_Base_Priority_Change (Self_Id);\n-\n             STPO.Timed_Sleep (Self_Id, Timeout, Mode, Acceptor_Sleep,\n               Timedout, Yielded);\n \n@@ -1799,9 +1807,11 @@ package body System.Tasking.Rendezvous is\n \n    procedure Wait_For_Call (Self_Id : Task_Id) is\n    begin\n+      Self_Id.Common.State := Acceptor_Sleep;\n+\n       --  Try to remove calls to Sleep in the loop below by letting the caller\n       --  a chance of getting ready immediately, using Unlock & Yield.\n-      --  See similar action in Wait_For_Completion & Selective_Wait.\n+      --  See similar action in Wait_For_Completion & Timed_Selective_Wait.\n \n       if Single_Lock then\n          Unlock_RTS;\n@@ -1825,13 +1835,8 @@ package body System.Tasking.Rendezvous is\n          Self_Id.Open_Accepts := null;\n       end if;\n \n-      Self_Id.Common.State := Acceptor_Sleep;\n-\n       loop\n-         Initialization.Poll_Base_Priority_Change (Self_Id);\n-\n          exit when Self_Id.Open_Accepts = null;\n-\n          Sleep (Self_Id, Acceptor_Sleep);\n       end loop;\n "}, {"sha": "6767f29c9e530528189ca2b6fd428712040f5d0a", "filename": "gcc/ada/s-tasuti.adb", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-tasuti.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae22b53397e8fd26c4f059e25f1664a909eb7d3/gcc%2Fada%2Fs-tasuti.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasuti.adb?ref=dae22b53397e8fd26c4f059e25f1664a909eb7d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2006, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2007, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -43,7 +43,6 @@ with System.Tasking.Debug;\n \n with System.Task_Primitives.Operations;\n --  used for Write_Lock\n---           Set_Priority\n --           Wakeup\n --           Unlock\n --           Sleep\n@@ -382,7 +381,7 @@ package body System.Tasking.Utilities is\n             --  Our parent should wait in Phase 1 of Complete_Master.\n \n             Master_Completion_Phase := 1;\n-            pragma Assert (Self_ID.Awake_Count = 1);\n+            pragma Assert (Self_ID.Awake_Count >= 1);\n          end if;\n \n       --  We are accepting with a terminate alternative\n@@ -454,8 +453,6 @@ package body System.Tasking.Utilities is\n             Write_Lock (C);\n          end loop;\n \n-         pragma Assert (P.Awake_Count /= 0);\n-\n          if P.Common.State = Master_Phase_2_Sleep\n            and then C.Master_of_Task = P.Master_Within\n          then\n@@ -478,7 +475,6 @@ package body System.Tasking.Utilities is\n       C.Awake_Count := C.Awake_Count - 1;\n \n       if Task_Completed then\n-         pragma Assert (Self_ID.Awake_Count = 0);\n          C.Alive_Count := C.Alive_Count - 1;\n       end if;\n \n@@ -499,7 +495,9 @@ package body System.Tasking.Utilities is\n       loop\n          --  Notify P that C has gone passive\n \n-         P.Awake_Count := P.Awake_Count - 1;\n+         if P.Awake_Count > 0 then\n+            P.Awake_Count := P.Awake_Count - 1;\n+         end if;\n \n          if Task_Completed and then C.Alive_Count = 0 then\n             P.Alive_Count := P.Alive_Count - 1;"}]}