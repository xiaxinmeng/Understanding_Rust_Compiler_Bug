{"sha": "fba05d9e9a0321c812ddbda7b4caa3977e1db4ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJhMDVkOWU5YTAzMjFjODEyZGRiZGE3YjRjYWEzOTc3ZTFkYjRlZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T07:13:57Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T07:13:57Z"}, "message": "match.pd handling of three-constant bitops\n\nnatch.pd tries to reassociate two bit operations if both of them have\nconstant operands.  However, with the polynomial integers added later,\nthere's no guarantee that a bit operation on two integers can be folded\nat compile time.  This means that the pattern can trigger for operations\non three constants, and as things stood could endlessly oscillate\nbetween the two associations.\n\nThis patch keeps the existing pattern for the normal case of a\nnon-constant first operand.  When all three operands are constant it\ntries to find a pair of constants that do fold.  If none do, it keeps\nthe original expression as-was.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* match.pd: Handle bit operations involving three constants\n\tand try to fold one pair.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256125", "tree": {"sha": "fcb44ccf099df984033df19505fd84e7a39d4e7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fcb44ccf099df984033df19505fd84e7a39d4e7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fba05d9e9a0321c812ddbda7b4caa3977e1db4ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fba05d9e9a0321c812ddbda7b4caa3977e1db4ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fba05d9e9a0321c812ddbda7b4caa3977e1db4ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fba05d9e9a0321c812ddbda7b4caa3977e1db4ef/comments", "author": null, "committer": null, "parents": [{"sha": "0f26839a0a779caa6c81d9fb3c31699f6ca86790", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f26839a0a779caa6c81d9fb3c31699f6ca86790", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f26839a0a779caa6c81d9fb3c31699f6ca86790"}], "stats": {"total": 26, "additions": 25, "deletions": 1}, "files": [{"sha": "d3d6fff62e92c385e27ba37223347be00f5a277d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba05d9e9a0321c812ddbda7b4caa3977e1db4ef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba05d9e9a0321c812ddbda7b4caa3977e1db4ef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fba05d9e9a0321c812ddbda7b4caa3977e1db4ef", "patch": "@@ -1,3 +1,10 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* match.pd: Handle bit operations involving three constants\n+\tand try to fold one pair.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* tree-vect-loop-manip.c: Include gimple-fold.h."}, {"sha": "06af2a72213316b8fe31d7a1ea8c0d658ef96e84", "filename": "gcc/match.pd", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba05d9e9a0321c812ddbda7b4caa3977e1db4ef/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba05d9e9a0321c812ddbda7b4caa3977e1db4ef/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=fba05d9e9a0321c812ddbda7b4caa3977e1db4ef", "patch": "@@ -1111,7 +1111,24 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n (for bitop (bit_and bit_ior bit_xor)\n  (simplify\n   (bitop (bitop @0 CONSTANT_CLASS_P@1) CONSTANT_CLASS_P@2)\n-  (bitop @0 (bitop @1 @2))))\n+  (if (!CONSTANT_CLASS_P (@0))\n+   /* This is the canonical form regardless of whether (bitop @1 @2) can be\n+      folded to a constant.  */\n+   (bitop @0 (bitop @1 @2))\n+   /* In this case we have three constants and (bitop @0 @1) doesn't fold\n+      to a constant.  This can happen if @0 or @1 is a POLY_INT_CST and if\n+      the values involved are such that the operation can't be decided at\n+      compile time.  Try folding one of @0 or @1 with @2 to see whether\n+      that combination can be decided at compile time.\n+\n+      Keep the existing form if both folds fail, to avoid endless\n+      oscillation.  */\n+   (with { tree cst1 = const_binop (bitop, type, @0, @2); }\n+    (if (cst1)\n+     (bitop @1 { cst1; })\n+     (with { tree cst2 = const_binop (bitop, type, @1, @2); }\n+      (if (cst2)\n+       (bitop @0 { cst2; }))))))))\n \n /* Try simple folding for X op !X, and X op X with the help\n    of the truth_valued_p and logical_inverted_value predicates.  */"}]}