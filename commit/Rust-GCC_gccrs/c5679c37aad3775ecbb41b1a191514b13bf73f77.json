{"sha": "c5679c37aad3775ecbb41b1a191514b13bf73f77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU2NzljMzdhYWQzNzc1ZWNiYjQxYjFhMTkxNTE0YjEzYmY3M2Y3Nw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-02-22T08:28:42Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-02-22T08:28:42Z"}, "message": "re PR tree-optimization/84503 (store-merging miscompilation on powerpc64 with -O3 since r241789)\n\n\tPR tree-optimization/84503\n\t* gimple-ssa-store-merging.c (merged_store_group::merge_into): Compute\n\twidth as info->bitpos + info->bitsize - start.\n\t(merged_store_group::merge_overlapping): Simplify width computation.\n\t(check_no_overlap): New function.\n\t(imm_store_chain_info::try_coalesce_bswap): Compute expected\n\tstart + width and last_order of the group, fail if check_no_overlap\n\tfails.\n\t(imm_store_chain_info::coalesce_immediate_stores): Don't merge info\n\tto group if check_no_overlap fails.\n\n\t* gcc.dg/pr84503-1.c: New test.\n\t* gcc.dg/pr84503-2.c: New test.\n\nFrom-SVN: r257891", "tree": {"sha": "38ab37d523c307e1c49bcda952b3c3b0814ed074", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38ab37d523c307e1c49bcda952b3c3b0814ed074"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5679c37aad3775ecbb41b1a191514b13bf73f77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5679c37aad3775ecbb41b1a191514b13bf73f77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5679c37aad3775ecbb41b1a191514b13bf73f77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5679c37aad3775ecbb41b1a191514b13bf73f77/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ad18eed284cc7a461f2030a7c0996f69048a9e92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad18eed284cc7a461f2030a7c0996f69048a9e92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad18eed284cc7a461f2030a7c0996f69048a9e92"}], "stats": {"total": 190, "additions": 169, "deletions": 21}, "files": [{"sha": "914d6cba248879039b330a223a7a0b0b871d8f9e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5679c37aad3775ecbb41b1a191514b13bf73f77/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5679c37aad3775ecbb41b1a191514b13bf73f77/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5679c37aad3775ecbb41b1a191514b13bf73f77", "patch": "@@ -1,3 +1,16 @@\n+2018-02-22  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/84503\n+\t* gimple-ssa-store-merging.c (merged_store_group::merge_into): Compute\n+\twidth as info->bitpos + info->bitsize - start.\n+\t(merged_store_group::merge_overlapping): Simplify width computation.\n+\t(check_no_overlap): New function.\n+\t(imm_store_chain_info::try_coalesce_bswap): Compute expected\n+\tstart + width and last_order of the group, fail if check_no_overlap\n+\tfails.\n+\t(imm_store_chain_info::coalesce_immediate_stores): Don't merge info\n+\tto group if check_no_overlap fails.\n+\n 2018-02-21  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* config/rs6000/altivec.md: Delete contraint arguments to"}, {"sha": "7b56031fd4790e8e68581d87b83e1c4aaa627a04", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 77, "deletions": 21, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5679c37aad3775ecbb41b1a191514b13bf73f77/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5679c37aad3775ecbb41b1a191514b13bf73f77/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=c5679c37aad3775ecbb41b1a191514b13bf73f77", "patch": "@@ -1891,12 +1891,11 @@ merged_store_group::do_merge (store_immediate_info *info)\n void\n merged_store_group::merge_into (store_immediate_info *info)\n {\n-  unsigned HOST_WIDE_INT wid = info->bitsize;\n   /* Make sure we're inserting in the position we think we're inserting.  */\n   gcc_assert (info->bitpos >= start + width\n \t      && info->bitregion_start <= bitregion_end);\n \n-  width += wid;\n+  width = info->bitpos + info->bitsize - start;\n   do_merge (info);\n }\n \n@@ -1909,7 +1908,7 @@ merged_store_group::merge_overlapping (store_immediate_info *info)\n {\n   /* If the store extends the size of the group, extend the width.  */\n   if (info->bitpos + info->bitsize > start + width)\n-    width += info->bitpos + info->bitsize - (start + width);\n+    width = info->bitpos + info->bitsize - start;\n \n   do_merge (info);\n }\n@@ -2304,6 +2303,55 @@ gather_bswap_load_refs (vec<tree> *refs, tree val)\n     }\n }\n \n+/* Check if there are any stores in M_STORE_INFO after index I\n+   (where M_STORE_INFO must be sorted by sort_by_bitpos) that overlap\n+   a potential group ending with END that have their order\n+   smaller than LAST_ORDER.  RHS_CODE is the kind of store in the\n+   group.  Return true if there are no such stores.\n+   Consider:\n+     MEM[(long long int *)p_28] = 0;\n+     MEM[(long long int *)p_28 + 8B] = 0;\n+     MEM[(long long int *)p_28 + 16B] = 0;\n+     MEM[(long long int *)p_28 + 24B] = 0;\n+     _129 = (int) _130;\n+     MEM[(int *)p_28 + 8B] = _129;\n+     MEM[(int *)p_28].a = -1;\n+   We already have\n+     MEM[(long long int *)p_28] = 0;\n+     MEM[(int *)p_28].a = -1;\n+   stmts in the current group and need to consider if it is safe to\n+   add MEM[(long long int *)p_28 + 8B] = 0; store into the same group.\n+   There is an overlap between that store and the MEM[(int *)p_28 + 8B] = _129;\n+   store though, so if we add the MEM[(long long int *)p_28 + 8B] = 0;\n+   into the group and merging of those 3 stores is successful, merged\n+   stmts will be emitted at the latest store from that group, i.e.\n+   LAST_ORDER, which is the MEM[(int *)p_28].a = -1; store.\n+   The MEM[(int *)p_28 + 8B] = _129; store that originally follows\n+   the MEM[(long long int *)p_28 + 8B] = 0; would now be before it,\n+   so we need to refuse merging MEM[(long long int *)p_28 + 8B] = 0;\n+   into the group.  That way it will be its own store group and will\n+   not be touched.  If RHS_CODE is INTEGER_CST and there are overlapping\n+   INTEGER_CST stores, those are mergeable using merge_overlapping,\n+   so don't return false for those.  */\n+\n+static bool\n+check_no_overlap (vec<store_immediate_info *> m_store_info, unsigned int i,\n+\t\t  enum tree_code rhs_code, unsigned int last_order,\n+\t\t  unsigned HOST_WIDE_INT end)\n+{\n+  unsigned int len = m_store_info.length ();\n+  for (++i; i < len; ++i)\n+    {\n+      store_immediate_info *info = m_store_info[i];\n+      if (info->bitpos >= end)\n+\tbreak;\n+      if (info->order < last_order\n+\t  && (rhs_code != INTEGER_CST || info->rhs_code != INTEGER_CST))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n /* Return true if m_store_info[first] and at least one following store\n    form a group which store try_size bitsize value which is byte swapped\n    from a memory load or some value, or identity from some value.\n@@ -2375,6 +2423,7 @@ imm_store_chain_info::try_coalesce_bswap (merged_store_group *merged_store,\n   unsigned int last_order = merged_store->last_order;\n   gimple *first_stmt = merged_store->first_stmt;\n   gimple *last_stmt = merged_store->last_stmt;\n+  unsigned HOST_WIDE_INT end = merged_store->start + merged_store->width;\n   store_immediate_info *infof = m_store_info[first];\n \n   for (unsigned int i = first; i <= last; ++i)\n@@ -2413,25 +2462,23 @@ imm_store_chain_info::try_coalesce_bswap (merged_store_group *merged_store,\n \t}\n       else\n \t{\n-\t  if (n.base_addr)\n+\t  if (n.base_addr && n.vuse != this_n.vuse)\n \t    {\n-\t      if (n.vuse != this_n.vuse)\n-\t\t{\n-\t\t  if (vuse_store == 0)\n-\t\t    return false;\n-\t\t  vuse_store = 1;\n-\t\t}\n-\t      if (info->order > last_order)\n-\t\t{\n-\t\t  last_order = info->order;\n-\t\t  last_stmt = info->stmt;\n-\t\t}\n-\t      else if (info->order < first_order)\n-\t\t{\n-\t\t  first_order = info->order;\n-\t\t  first_stmt = info->stmt;\n-\t\t}\n+\t      if (vuse_store == 0)\n+\t\treturn false;\n+\t      vuse_store = 1;\n \t    }\n+\t  if (info->order > last_order)\n+\t    {\n+\t      last_order = info->order;\n+\t      last_stmt = info->stmt;\n+\t    }\n+\t  else if (info->order < first_order)\n+\t    {\n+\t      first_order = info->order;\n+\t      first_stmt = info->stmt;\n+\t    }\n+\t  end = MAX (end, info->bitpos + info->bitsize);\n \n \t  ins_stmt = perform_symbolic_merge (ins_stmt, &n, info->ins_stmt,\n \t\t\t\t\t     &this_n, &n);\n@@ -2452,6 +2499,9 @@ imm_store_chain_info::try_coalesce_bswap (merged_store_group *merged_store,\n   if (n.base_addr == NULL_TREE && !is_gimple_val (n.src))\n     return false;\n \n+  if (!check_no_overlap (m_store_info, last, LROTATE_EXPR, last_order, end))\n+    return false;\n+\n   /* Don't handle memory copy this way if normal non-bswap processing\n      would handle it too.  */\n   if (n.n == cmpnop && (unsigned) n.n_ops == last - first + 1)\n@@ -2633,7 +2683,13 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \t       : !info->ops[0].base_addr)\n \t      && (infof->ops[1].base_addr\n \t\t  ? compatible_load_p (merged_store, info, base_addr, 1)\n-\t\t  : !info->ops[1].base_addr))\n+\t\t  : !info->ops[1].base_addr)\n+\t      && check_no_overlap (m_store_info, i, info->rhs_code,\n+\t\t\t\t   MAX (merged_store->last_order,\n+\t\t\t\t\tinfo->order),\n+\t\t\t\t   MAX (merged_store->start\n+\t\t\t\t\t+ merged_store->width,\n+\t\t\t\t\tinfo->bitpos + info->bitsize)))\n \t    {\n \t      merged_store->merge_into (info);\n \t      continue;"}, {"sha": "19b85bb350c812908c89c5d2c229b220e298d616", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5679c37aad3775ecbb41b1a191514b13bf73f77/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5679c37aad3775ecbb41b1a191514b13bf73f77/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c5679c37aad3775ecbb41b1a191514b13bf73f77", "patch": "@@ -1,3 +1,9 @@\n+2018-02-22  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/84503\n+\t* gcc.dg/pr84503-1.c: New test.\n+\t* gcc.dg/pr84503-2.c: New test.\n+\n 2018-02-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/84478"}, {"sha": "03fb2fbd9a522c7c11da7d2dcad60d6484e36c89", "filename": "gcc/testsuite/gcc.dg/pr84503-1.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5679c37aad3775ecbb41b1a191514b13bf73f77/gcc%2Ftestsuite%2Fgcc.dg%2Fpr84503-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5679c37aad3775ecbb41b1a191514b13bf73f77/gcc%2Ftestsuite%2Fgcc.dg%2Fpr84503-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr84503-1.c?ref=c5679c37aad3775ecbb41b1a191514b13bf73f77", "patch": "@@ -0,0 +1,68 @@\n+/* PR tree-optimization/84503 */\n+/* { dg-do run } */\n+/* { dg-options \"-O3\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+typedef __UINTPTR_TYPE__ uintptr_t;\n+\n+struct S { int a; unsigned short b; int c, d, e; long f, g, h; int i, j; };\n+static struct S *k;\n+static size_t l = 0;\n+int m;\n+\n+static int\n+bar (void)\n+{\n+  unsigned i;\n+  int j;\n+  if (k[0].c == 0)\n+    {\n+      ++m;\n+      size_t n = l * 2;\n+      struct S *o;\n+      o = (struct S *) __builtin_realloc (k, sizeof (struct S) * n);\n+      if (!o)\n+\t__builtin_exit (0);\n+      k = o;\n+      for (i = l; i < n; i++)\n+\t{\n+\t  void *p = (void *) &k[i];\n+\t  int q = 0;\n+\t  size_t r = sizeof (struct S);\n+\t  if ((((uintptr_t) p) % __alignof__ (long)) == 0\n+\t      && r % sizeof (long) == 0)\n+\t    {\n+\t      long __attribute__ ((may_alias)) *s = (long *) p;\n+\t      long *t = (long *) ((char *) s + r);\n+\t      while (s < t)\n+\t\t*s++ = 0;\n+\t    }\n+\t  else\n+\t    __builtin_memset (p, q, r);\n+\t  k[i].c = i + 1;\n+\t  k[i].a = -1;\n+\t}\n+      k[n - 1].c = 0;\n+      k[0].c = l;\n+      l = n;\n+    }\n+  j = k[0].c;\n+  k[0].c = k[j].c;\n+  return j;\n+}\n+\n+int\n+main ()\n+{\n+  k = (struct S *) __builtin_malloc (sizeof (struct S));\n+  if (!k)\n+    __builtin_exit (0);\n+  __builtin_memset (k, '\\0', sizeof (struct S));\n+  k->a = -1;\n+  l = 1;\n+  for (int i = 0; i < 15; ++i)\n+    bar ();\n+  if (m != 4)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "76701f07938f89e620a3397fdd35b806a7cb1ba4", "filename": "gcc/testsuite/gcc.dg/pr84503-2.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5679c37aad3775ecbb41b1a191514b13bf73f77/gcc%2Ftestsuite%2Fgcc.dg%2Fpr84503-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5679c37aad3775ecbb41b1a191514b13bf73f77/gcc%2Ftestsuite%2Fgcc.dg%2Fpr84503-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr84503-2.c?ref=c5679c37aad3775ecbb41b1a191514b13bf73f77", "patch": "@@ -0,0 +1,5 @@\n+/* PR tree-optimization/84503 */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fno-tree-vectorize -fno-ivopts\" } */\n+\n+#include \"pr84503-1.c\""}]}