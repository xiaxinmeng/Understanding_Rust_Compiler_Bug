{"sha": "a295d3317e3675c09de2b101e88f08eba04f26c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI5NWQzMzE3ZTM2NzVjMDlkZTJiMTAxZTg4ZjA4ZWJhMDRmMjZjNQ==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1995-12-17T16:41:09Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1995-12-17T16:41:09Z"}, "message": "(expand_mult_highpart): When doing widening multiply,\n\nput constant in a register.\n(expand_mult_highpart): When mode is word_mode use gen_highpart\ninstead of right shift by size.\n\nFrom-SVN: r10789", "tree": {"sha": "dfc0501c8c3289e36915d365c7c21566acbff48e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfc0501c8c3289e36915d365c7c21566acbff48e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a295d3317e3675c09de2b101e88f08eba04f26c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a295d3317e3675c09de2b101e88f08eba04f26c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a295d3317e3675c09de2b101e88f08eba04f26c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a295d3317e3675c09de2b101e88f08eba04f26c5/comments", "author": null, "committer": null, "parents": [{"sha": "b10af0c8206f7ff2aefd13b3d7d20accf4c9a33c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b10af0c8206f7ff2aefd13b3d7d20accf4c9a33c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b10af0c8206f7ff2aefd13b3d7d20accf4c9a33c"}], "stats": {"total": 28, "additions": 21, "deletions": 7}, "files": [{"sha": "384ede443f0b7747f01913ab1620427d1d1aeb00", "filename": "gcc/expmed.c", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a295d3317e3675c09de2b101e88f08eba04f26c5/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a295d3317e3675c09de2b101e88f08eba04f26c5/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=a295d3317e3675c09de2b101e88f08eba04f26c5", "patch": "@@ -2610,21 +2610,28 @@ expand_mult_highpart (mode, op0, cnst1, target, unsignedp, max_cost)\n   moptab = unsignedp ? umul_widen_optab : smul_widen_optab;\n   if (moptab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing\n       && mul_widen_cost[(int) wider_mode] < max_cost)\n-    goto try;\n+    {\n+      op1 = force_reg (mode, op1);\n+      goto try;\n+    } \n \n   /* Try widening the mode and perform a non-widening multiplication.  */\n   moptab = smul_optab;\n   if (smul_optab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing\n       && mul_cost[(int) wider_mode] + shift_cost[size-1] < max_cost)\n-    goto try;\n+    {\n+      op1 = wide_op1;\n+      goto try;\n+    }\n \n   /* Try widening multiplication of opposite signedness, and adjust.  */\n   moptab = unsignedp ? smul_widen_optab : umul_widen_optab;\n   if (moptab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing\n       && (mul_widen_cost[(int) wider_mode]\n \t  + 2 * shift_cost[size-1] + 4 * add_cost < max_cost))\n     {\n-      tem = expand_binop (wider_mode, moptab, op0, wide_op1,\n+      rtx regop1 = force_reg (mode, op1);\n+      tem = expand_binop (wider_mode, moptab, op0, regop1,\n \t\t\t  NULL_RTX, ! unsignedp, OPTAB_WIDEN);\n       if (tem != 0)\n \t{\n@@ -2642,15 +2649,22 @@ expand_mult_highpart (mode, op0, cnst1, target, unsignedp, max_cost)\n \n  try:\n   /* Pass NULL_RTX as target since TARGET has wrong mode.  */\n-  tem = expand_binop (wider_mode, moptab, op0, wide_op1,\n+  tem = expand_binop (wider_mode, moptab, op0, op1,\n \t\t      NULL_RTX, unsignedp, OPTAB_WIDEN);\n   if (tem == 0)\n     return 0;\n \n   /* Extract the high half of the just generated product.  */\n-  tem = expand_shift (RSHIFT_EXPR, wider_mode, tem,\n-\t\t      build_int_2 (size, 0), NULL_RTX, 1);\n-  return convert_modes (mode, wider_mode, tem, unsignedp);\n+  if (mode == word_mode)\n+    {\n+      return gen_highpart (mode, tem);\n+    }\n+  else\n+    {\n+      tem = expand_shift (RSHIFT_EXPR, wider_mode, tem,\n+\t\t\t  build_int_2 (size, 0), NULL_RTX, 1);\n+      return convert_modes (mode, wider_mode, tem, unsignedp);\n+    }\n }\n \f\n /* Emit the code to divide OP0 by OP1, putting the result in TARGET"}]}