{"sha": "a3b11faf7e1920d972eb98b86dc826b107f979a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNiMTFmYWY3ZTE5MjBkOTcyZWI5OGI4NmRjODI2YjEwN2Y5NzlhMA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2018-01-17T23:16:03Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2018-01-17T23:16:03Z"}, "message": "rs6000.c (rs6000_emit_move): If we load or store a long double type...\n\n[gcc]\n2018-01-17  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_emit_move): If we load or store a\n\tlong double type, set the flags for noting the default long double\n\ttype, even if we don't pass or return a long double type.\n\n[gcc/testsuite]\n2018-01-17  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/gnuattr1.c: New test to make sure we set the\n\tappropriate .gnu_attribute for the long double type, if we use the\n\tlong double type, but do not generate any calls.\n\t* gcc.target/powerpc/gnuattr2.c: Likewise.\n\t* gcc.target/powerpc/gnuattr3.c: Likewise.\n\nFrom-SVN: r256822", "tree": {"sha": "4de4f82bacc49399d88181969b4c547efd8df8e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4de4f82bacc49399d88181969b4c547efd8df8e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3b11faf7e1920d972eb98b86dc826b107f979a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3b11faf7e1920d972eb98b86dc826b107f979a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3b11faf7e1920d972eb98b86dc826b107f979a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3b11faf7e1920d972eb98b86dc826b107f979a0/comments", "author": null, "committer": null, "parents": [{"sha": "a533fc76359bf0dfedc15be83f0bfd886712a4b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a533fc76359bf0dfedc15be83f0bfd886712a4b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a533fc76359bf0dfedc15be83f0bfd886712a4b3"}], "stats": {"total": 78, "additions": 78, "deletions": 0}, "files": [{"sha": "e01194cf720afb87c3e5a218cd72650af67b5562", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b11faf7e1920d972eb98b86dc826b107f979a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b11faf7e1920d972eb98b86dc826b107f979a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a3b11faf7e1920d972eb98b86dc826b107f979a0", "patch": "@@ -1,3 +1,9 @@\n+2018-01-17  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_emit_move): If we load or store a\n+\tlong double type, set the flags for noting the default long double\n+\ttype, even if we don't pass or return a long double type.\n+\n 2018-01-17  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/83051"}, {"sha": "93432f6d5271d5313d6dadb0536c87dbbdfbab75", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b11faf7e1920d972eb98b86dc826b107f979a0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b11faf7e1920d972eb98b86dc826b107f979a0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a3b11faf7e1920d972eb98b86dc826b107f979a0", "patch": "@@ -10494,6 +10494,23 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n       gcc_unreachable ();\n     }\n \n+#ifdef HAVE_AS_GNU_ATTRIBUTE\n+  /* If we use a long double type, set the flags in .gnu_attribute that say\n+     what the long double type is.  This is to allow the linker's warning\n+     message for the wrong long double to be useful, even if the function does\n+     not do a call (for example, doing a 128-bit add on power9 if the long\n+     double type is IEEE 128-bit.  Do not set this if __ibm128 or __floa128 are\n+     used if they aren't the default long dobule type.  */\n+  if (rs6000_gnu_attr && (HAVE_LD_PPC_GNU_ATTR_LONG_DOUBLE || TARGET_64BIT))\n+    {\n+      if (TARGET_LONG_DOUBLE_128 && (mode == TFmode || mode == TCmode))\n+\trs6000_passes_float = rs6000_passes_long_double = true;\n+\n+      else if (!TARGET_LONG_DOUBLE_128 && (mode == DFmode || mode == DCmode))\n+\trs6000_passes_float = rs6000_passes_long_double = true;\n+    }\n+#endif\n+\n   /* See if we need to special case SImode/SFmode SUBREG moves.  */\n   if ((mode == SImode || mode == SFmode) && SUBREG_P (source)\n       && rs6000_emit_move_si_sf_subreg (dest, source, mode))"}, {"sha": "ad23ad741ef8c805b65a47cef92953569415272b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b11faf7e1920d972eb98b86dc826b107f979a0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b11faf7e1920d972eb98b86dc826b107f979a0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a3b11faf7e1920d972eb98b86dc826b107f979a0", "patch": "@@ -1,3 +1,11 @@\n+2018-01-17  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/gnuattr1.c: New test to make sure we set the\n+\tappropriate .gnu_attribute for the long double type, if we use the\n+\tlong double type, but do not generate any calls.\n+\t* gcc.target/powerpc/gnuattr2.c: Likewise.\n+\t* gcc.target/powerpc/gnuattr3.c: Likewise.\n+\n 2018-01-17  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/78344"}, {"sha": "cf46777849a213523665555f092d3ef269607820", "filename": "gcc/testsuite/gcc.target/powerpc/gnuattr1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b11faf7e1920d972eb98b86dc826b107f979a0/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fgnuattr1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b11faf7e1920d972eb98b86dc826b107f979a0/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fgnuattr1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fgnuattr1.c?ref=a3b11faf7e1920d972eb98b86dc826b107f979a0", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile { target { powerpc*-linux-* } } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O2 -mvsx -mlong-double-64\" } */\n+/* { dg-final { scan-assembler \"gnu_attribute 4, 9\" } } */\n+\n+/* Check that if we can do the long double operation without doing an emulator\n+   call, such as with 64-bit long double support, that we still set the\n+   appropriate .gnu_attribute.  */\n+\n+long double a;\n+\n+void add1 (void)\n+{\n+  a++;\n+}"}, {"sha": "32a4ba255a8b0c7541e2e0e31f3369fad7144f32", "filename": "gcc/testsuite/gcc.target/powerpc/gnuattr2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b11faf7e1920d972eb98b86dc826b107f979a0/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fgnuattr2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b11faf7e1920d972eb98b86dc826b107f979a0/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fgnuattr2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fgnuattr2.c?ref=a3b11faf7e1920d972eb98b86dc826b107f979a0", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile { target { powerpc*-linux-* && lp64 } } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-O2 -mpower9-vector -mabi=ieeelongdouble -Wno-psabi\" } */\n+/* { dg-final { scan-assembler \"gnu_attribute 4, 13\" } } */\n+\n+/* Check that if we can do the long double operation without doing an emulator\n+   call, such as with IEEE 128-bit hardware support on power9, that we still\n+   set the appropriate .gnu_attribute.  The && lp64 is needed, because we can't\n+   enable the IEEE 128-bit hardware instructions on ISA 3.0 (power9) in 32-bit,\n+   because we don't have a TImode available.  */\n+\n+long double a;\n+\n+void add1 (void)\n+{\n+  a++;\n+}"}, {"sha": "bd5a64fe33052c16ca8a9496a8af05f094a4254e", "filename": "gcc/testsuite/gcc.target/powerpc/gnuattr3.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b11faf7e1920d972eb98b86dc826b107f979a0/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fgnuattr3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b11faf7e1920d972eb98b86dc826b107f979a0/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fgnuattr3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fgnuattr3.c?ref=a3b11faf7e1920d972eb98b86dc826b107f979a0", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile { target { powerpc*-linux-* } } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O2 -mvsx -mabi=ibmlongdouble -Wno-psabi\" } */\n+/* { dg-final { scan-assembler \"gnu_attribute 4, 5\" } } */\n+\n+/* Check that if we can do the long double operation without doing an emulator\n+   call, such as with copysign, that we still set the appropriate\n+   .gnu_attribute.  */\n+\n+long double a, b, c;\n+\n+void cs (void)\n+{\n+  a = __builtin_copysignl (b, c);\n+}"}]}