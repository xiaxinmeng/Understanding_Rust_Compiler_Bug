{"sha": "f0f3a77740016ecd1168ce689bbc36d705ddff49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBmM2E3Nzc0MDAxNmVjZDExNjhjZTY4OWJiYzM2ZDcwNWRkZmY0OQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "2000-08-08T03:33:36Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-08-08T03:33:36Z"}, "message": "2000-08-07  Alexandre Petit-Bianco  <apbianco@cygnus.com\n\n\t* parse.y (build_dot_class_method_invocation): Changed parameter\n\tname to `type.' Build signature from `type' and convert it to a\n\tSTRING_CST if it's an array.\n\t(patch_incomplete_class_ref): `build_dot_class_method_invocation'\n\tto use `ref_type' directly.\n\n2000-08-01  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* parse.y (maybe_yank_clinit): When generating bytecode: non empty\n\tmethod bodies not to rule out discarding `<clinit>'; don't use\n\t<clinit> to initialize static fields with constant initializers.\n\n2000-08-01  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* gjavah.c (print_method_info): Added `synth' parameter. Skip\n\tsynthetic methods.\n\t(method_synthetic): New global.\n\t(HANDLE_METHOD): Recognize synthetic method and tell\n\t`print_method_info' about it.\n\t(HANDLE_END_METHOD): Do not issue an additional `;\\n' if we're\n\tprocessing a synthetic method.\n\t* jcf-reader.c (skip_attribute): New function.\n\t( skip_attribute): Likewise.\n\n2000-08-01  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* parse.y (build_outer_field_access): Fixed comments.\n\t(fix_constructors): Emit the initialization of this$<n> before\n\tcalling $finit$.\n\t(resolve_qualified_expression_name): Build an access to `decl' if\n\tnecessary.\n\n2000-07-31  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* parse-scan.y (curent_class): Non longer const.\n\t(inner_qualifier, inner_qualifier_length): Deleted.\n\t(current_class_length): New global.\n\t(bracket_count): Fixed typo in leading comment.\n\t(anonymous_count): New global.\n\t(class_instance_creation_expression:): Handle anonymous classes.\n\t(anonymous_class_creation:): New rule.\n\t(push_class_context): Rewritten.\n\t(pop_class_context): Likewise.\n\t(INNER_QUALIFIER): Macro deleted.\n\t(report_class_declaration): call `push_class_context' when\n\tentering the function. `fprintf' format modified not to use\n\tINNER_QUALIFIER.\n\t(report_class_declaration): Assign `package_name' and\n\t`current_class' to NULL separatly.\n\n2000-07-31  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* expr.c (build_invokeinterface): Call layout_class_methods on\n\ttarget interface.\n\n(http://gcc.gnu.org/ml/gcc-patches/2000-08/msg00339.html)\n\nFrom-SVN: r35560", "tree": {"sha": "3231a690fb29e8d59f05640bc2d73c4114d8b28e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3231a690fb29e8d59f05640bc2d73c4114d8b28e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0f3a77740016ecd1168ce689bbc36d705ddff49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0f3a77740016ecd1168ce689bbc36d705ddff49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0f3a77740016ecd1168ce689bbc36d705ddff49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0f3a77740016ecd1168ce689bbc36d705ddff49/comments", "author": null, "committer": null, "parents": [{"sha": "0da9afa6d6ac1ca516bc62d97ef1b8e727ea96b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0da9afa6d6ac1ca516bc62d97ef1b8e727ea96b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0da9afa6d6ac1ca516bc62d97ef1b8e727ea96b7"}], "stats": {"total": 370, "additions": 291, "deletions": 79}, "files": [{"sha": "f8c3803841d54580d7ca9990ad34ebedaa836a8e", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f3a77740016ecd1168ce689bbc36d705ddff49/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f3a77740016ecd1168ce689bbc36d705ddff49/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=f0f3a77740016ecd1168ce689bbc36d705ddff49", "patch": "@@ -1,3 +1,11 @@\n+2000-08-07  Alexandre Petit-Bianco  <apbianco@cygnus.com\n+\n+\t* parse.y (build_dot_class_method_invocation): Changed parameter\n+\tname to `type.' Build signature from `type' and convert it to a\n+\tSTRING_CST if it's an array.\n+\t(patch_incomplete_class_ref): `build_dot_class_method_invocation'\n+\tto use `ref_type' directly.\n+\n Sun Aug  6 00:47:24 2000  Ovidiu Predescu  <ovidiu@cup.hp.com>\n \n \t* lang-options.h: Added a comma after the last element to avoid\n@@ -17,6 +25,55 @@ Sun Aug  6 00:47:24 2000  Ovidiu Predescu  <ovidiu@cup.hp.com>\n \n \t* class.c (build_dtable_decl): Initialize dummy.\n \n+2000-08-01  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (maybe_yank_clinit): When generating bytecode: non empty\n+\tmethod bodies not to rule out discarding `<clinit>'; don't use\n+\t<clinit> to initialize static fields with constant initializers.\n+\n+2000-08-01  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* gjavah.c (print_method_info): Added `synth' parameter. Skip\n+\tsynthetic methods.\n+\t(method_synthetic): New global.\n+\t(HANDLE_METHOD): Recognize synthetic method and tell\n+\t`print_method_info' about it.\n+\t(HANDLE_END_METHOD): Do not issue an additional `;\\n' if we're\n+\tprocessing a synthetic method.\n+\t* jcf-reader.c (skip_attribute): New function.\n+\t( skip_attribute): Likewise.\n+\n+2000-08-01  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (build_outer_field_access): Fixed comments.\n+\t(fix_constructors): Emit the initialization of this$<n> before\n+\tcalling $finit$.\n+\t(resolve_qualified_expression_name): Build an access to `decl' if\n+\tnecessary.\n+\n+2000-07-31  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse-scan.y (curent_class): Non longer const.\n+\t(inner_qualifier, inner_qualifier_length): Deleted.\n+\t(current_class_length): New global.\n+\t(bracket_count): Fixed typo in leading comment.\n+\t(anonymous_count): New global.\n+\t(class_instance_creation_expression:): Handle anonymous classes.\n+\t(anonymous_class_creation:): New rule.\n+\t(push_class_context): Rewritten.\n+\t(pop_class_context): Likewise.\n+\t(INNER_QUALIFIER): Macro deleted.\n+\t(report_class_declaration): call `push_class_context' when\n+\tentering the function. `fprintf' format modified not to use\n+\tINNER_QUALIFIER.\n+\t(report_class_declaration): Assign `package_name' and\n+\t`current_class' to NULL separatly.\n+\n+2000-07-31  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* expr.c (build_invokeinterface): Call layout_class_methods on\n+\ttarget interface.\n+\n 2000-07-27  Tom Tromey  <tromey@cygnus.com>\n             Anthony Green  <green@cygnus.com>\n \t    Alexandre Petit-Bianco  <apbianco@cygnus.com>"}, {"sha": "af59e63ba98f95ab38043d9ff62aaf2dc49eb9e4", "filename": "gcc/java/expr.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f3a77740016ecd1168ce689bbc36d705ddff49/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f3a77740016ecd1168ce689bbc36d705ddff49/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=f0f3a77740016ecd1168ce689bbc36d705ddff49", "patch": "@@ -1783,6 +1783,7 @@ build_invokeinterface (dtable, method)\n \t\t  lookup_field (&dtable_type, class_ident));\n \n   interface = DECL_CONTEXT (method);\n+  layout_class_methods (interface);\n   \n   i = 1;\n   for (meth = TYPE_METHODS (interface); ; meth = TREE_CHAIN (meth), i++)"}, {"sha": "bca748a1ad202e01c7cce69d578de720a797a1a2", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 47, "deletions": 23, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f3a77740016ecd1168ce689bbc36d705ddff49/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f3a77740016ecd1168ce689bbc36d705ddff49/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=f0f3a77740016ecd1168ce689bbc36d705ddff49", "patch": "@@ -116,7 +116,7 @@ static struct method_name *method_name_list;\n static void print_field_info PARAMS ((FILE*, JCF*, int, int, JCF_u2));\n static void print_mangled_classname PARAMS ((FILE*, JCF*, const char*, int));\n static int  print_cxx_classname PARAMS ((FILE*, const char*, JCF*, int));\n-static void print_method_info PARAMS ((FILE*, JCF*, int, int, JCF_u2));\n+static void print_method_info PARAMS ((FILE*, JCF*, int, int, JCF_u2, int));\n static void print_c_decl PARAMS ((FILE*, JCF*, int, int, int, const char *,\n \t\t\t\t  int));\n static void print_stub_or_jni PARAMS ((FILE*, JCF*, int, int, int,\n@@ -182,26 +182,45 @@ static int method_pass;\n static int method_declared = 0;\n static int method_access = 0;\n static int method_printed = 0;\n-#define HANDLE_METHOD(ACCESS_FLAGS, NAME, SIGNATURE, ATTRIBUTE_COUNT)\t      \\\n-  if (method_pass)\t\t\t\t\t\t\t      \\\n-    {\t\t\t\t\t\t\t\t\t      \\\n-      decompiled = 0; method_printed = 0;\t\t\t\t      \\\n-      if (out)\t\t\t\t\t\t\t\t      \\\n-        print_method_info (out, jcf, NAME, SIGNATURE, ACCESS_FLAGS);\t      \\\n-    }\t\t\t\t\t\t\t\t\t      \\\n-  else                                                                       \\\n-    {                                                                        \\\n-      print_method_info (NULL, jcf, NAME, SIGNATURE, ACCESS_FLAGS);          \\\n-      if (! stubs && ! flag_jni)                                             \\\n-       add_class_decl (out, jcf, SIGNATURE);                                 \\\n-    }\n-\n-#define HANDLE_CODE_ATTRIBUTE(MAX_STACK, MAX_LOCALS, CODE_LENGTH) \\\n+static int method_synthetic = 0;\n+#define HANDLE_METHOD(ACCESS_FLAGS, NAME, SIGNATURE, ATTRIBUTE_COUNT)\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    method_synthetic = 0;\t\t\t\t\t\t\\\n+    if (ATTRIBUTE_COUNT)\t\t\t\t\t\t\\\n+      method_synthetic = peek_attribute (jcf, ATTRIBUTE_COUNT,\t\t\\\n+\t\t\t\t  (const char *)\"Synthetic\", 9);\t\\\n+    /* If a synthetic methods have been declared, its attribute aren't\t\\\n+       worth reading (and triggering side-effects). We skip them an\t\\\n+       set ATTRIBUTE_COUNT to zero so that they'll be skipped in\t\\\n+       jcf_parse_one_method.  */\t\t\t\t\t\\\n+    if (method_synthetic)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tskip_attribute (jcf, ATTRIBUTE_COUNT);\t\t\t\t\\\n+\tATTRIBUTE_COUNT = 0;\t\t\t\t\t\t\\\n+      } \t\t\t\t\t\t\t\t\\\n+    if (method_pass && !method_synthetic)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tdecompiled = 0; method_printed = 0;\t\t\t\t\\\n+\tif (out)\t\t\t\t\t\t\t\\\n+\t  print_method_info (out, jcf, NAME, SIGNATURE,\t\t\t\\\n+\t\t\t     ACCESS_FLAGS, method_synthetic);\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else if (!method_synthetic)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tprint_method_info (NULL, jcf, NAME, SIGNATURE,\t\t\t\\\n+\t\t\t   ACCESS_FLAGS, method_synthetic);\t\t\\\n+\tif (! stubs && ! flag_jni)\t\t\t\t\t\\\n+\t  add_class_decl (out, jcf, SIGNATURE);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define HANDLE_CODE_ATTRIBUTE(MAX_STACK, MAX_LOCALS, CODE_LENGTH)\t\\\n   if (out && method_declared) decompile_method (out, jcf, CODE_LENGTH);\n \n static int decompiled = 0;\n-#define HANDLE_END_METHOD() \\\n-  if (out && method_printed) fputs (decompiled || stubs ? \"\\n\" : \";\\n\", out);\n+#define HANDLE_END_METHOD()\t\t\t\t\\\n+  if (out && method_printed && !method_synthetic) \t\\\n+    fputs (decompiled || stubs ? \"\\n\" : \";\\n\", out);\n \n #include \"jcf-reader.c\"\n \n@@ -670,9 +689,9 @@ DEFUN(print_field_info, (stream, jcf, name_index, sig_index, flags),\n \n \n static void\n-DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags),\n+DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags, synth),\n       FILE *stream AND JCF* jcf\n-      AND int name_index AND int sig_index AND JCF_u2 flags)\n+      AND int name_index AND int sig_index AND JCF_u2 flags AND int synth)\n {\n   const unsigned char *str;\n   int length, is_init = 0;\n@@ -684,10 +703,15 @@ DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags),\n     fprintf (stream, \"<not a UTF8 constant>\");\n   str = JPOOL_UTF_DATA (jcf, name_index);\n   length = JPOOL_UTF_LENGTH (jcf, name_index);\n-  if (str[0] == '<' || str[0] == '$')\n+\n+  /* Ignore synthetic methods. */\n+  if (synth)\n+    return;\n+\n+  if (str[0] == '<')\n     {\n-      /* Ignore internally generated methods like <clinit> and\n-\t $finit$.  However, treat <init> as a constructor.  */\n+      /* Ignore the internally generated method <clinit>. However,\n+         treat <init> as a constructor.  */\n       if (! utf8_cmp (str, length, \"<init>\"))\n \tis_init = 1;\n       else if (! METHOD_IS_FINAL (jcf->access_flags, flags)"}, {"sha": "1b081e54fbebea828c582c406dcd764c47f88e2e", "filename": "gcc/java/jcf-reader.c", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f3a77740016ecd1168ce689bbc36d705ddff49/gcc%2Fjava%2Fjcf-reader.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f3a77740016ecd1168ce689bbc36d705ddff49/gcc%2Fjava%2Fjcf-reader.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-reader.c?ref=f0f3a77740016ecd1168ce689bbc36d705ddff49", "patch": "@@ -27,6 +27,8 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"zipfile.h\"\n \n static int get_attribute PARAMS ((JCF *));\n+static int peek_attribute PARAMS ((JCF *, int, const char *, int));\n+static void skip_attribute PARAMS ((JCF *, int));\n static int jcf_parse_preamble PARAMS ((JCF *));\n static int jcf_parse_constant_pool PARAMS ((JCF *));\n static void jcf_parse_class PARAMS ((JCF *));\n@@ -35,6 +37,64 @@ static int jcf_parse_one_method PARAMS ((JCF *));\n static int jcf_parse_methods PARAMS ((JCF *));\n static int jcf_parse_final_attributes PARAMS ((JCF *));\n \n+/* Go through all available attribute (ATTRIBUTE_NUMER) and try to\n+   identify PEEKED_NAME.  Return 1 if PEEKED_NAME was found, 0\n+   otherwise. JCF is restored to its initial position before\n+   returning.  */\n+\n+static int\n+peek_attribute (jcf, attribute_number, peeked_name, peeked_name_length)\n+      JCF *jcf;\n+      int attribute_number;\n+      const char *peeked_name;\n+      int peeked_name_length;\n+{\n+  int to_return = 0;\n+  long absolute_offset = (long)JCF_TELL (jcf);\n+  int i;\n+\n+  for (i = 0; !to_return && i < attribute_number; i++)\n+    {\n+      uint16 attribute_name = (JCF_FILL (jcf, 6), JCF_readu2 (jcf));\n+      uint32 attribute_length = JCF_readu4 (jcf);\n+      int name_length;\n+      const unsigned char *name_data; \n+\n+      JCF_FILL (jcf, (long) attribute_length);\n+      if (attribute_name <= 0 || attribute_name >= JPOOL_SIZE(jcf)\n+\t  || JPOOL_TAG (jcf, attribute_name) != CONSTANT_Utf8)\n+\tcontinue;\n+\n+      name_length = JPOOL_UTF_LENGTH (jcf, attribute_name);\n+      name_data = JPOOL_UTF_DATA (jcf, attribute_name);\n+\n+      if (name_length == peeked_name_length \n+\t  && ! memcmp (name_data, peeked_name, peeked_name_length)) \n+\t{\n+\t  to_return = 1; \n+\t  break;\n+\t}\n+      \n+      JCF_SKIP (jcf, attribute_length);\n+    }\n+\n+  JCF_SEEK (jcf, absolute_offset);\n+  return to_return;\n+}\n+\n+static void\n+skip_attribute (jcf, number_of_attribute)\n+     JCF *jcf;\n+     int number_of_attribute;\n+{\n+  while (number_of_attribute--)\n+    {\n+      JCF_FILL (jcf, 6);\n+      (void) JCF_readu2 (jcf);\n+      JCF_SKIP (jcf, JCF_readu4 (jcf));\n+    }\n+}\n+\n static int\n DEFUN(get_attribute, (jcf),\n       JCF *jcf)"}, {"sha": "2b8b78d75bc59436468584749c19b0a90508daf8", "filename": "gcc/java/parse-scan.y", "status": "modified", "additions": 67, "deletions": 32, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f3a77740016ecd1168ce689bbc36d705ddff49/gcc%2Fjava%2Fparse-scan.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f3a77740016ecd1168ce689bbc36d705ddff49/gcc%2Fjava%2Fparse-scan.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse-scan.y?ref=f0f3a77740016ecd1168ce689bbc36d705ddff49", "patch": "@@ -63,23 +63,25 @@ static int absorber;\n #define USE_ABSORBER absorber = 0\n \n /* Keep track of the current class name and package name.  */\n-static const char *current_class;\n+static char *current_class;\n static const char *package_name;\n \n /* Keep track of the current inner class qualifier. */\n-static char *inner_qualifier;\n-static int   inner_qualifier_length;\n+static int current_class_length;\n \n /* Keep track of whether things have be listed before.  */\n static int previous_output;\n \n /* Record modifier uses  */\n static int modifier_value;\n \n-/* Keep track of number of bracket pairs after a variable declarator\n+/* Keeps track of number of bracket pairs after a variable declarator\n    id.  */\n static int bracket_count; \n \n+/* Numbers anonymous classes */\n+static int anonymous_count;\n+\n /* Record a method declaration  */\n struct method_declarator {\n   const char *method_name;\n@@ -897,20 +899,22 @@ primary_no_new_array:\n class_instance_creation_expression:\n \tNEW_TK class_type OP_TK argument_list CP_TK\n |\tNEW_TK class_type OP_TK CP_TK\n-        /* Added, JDK1.1 inner classes but modified to use\n-           'class_type' instead of 'TypeName' (type_name) mentionned\n-           in the documentation but doesn't exist. */\n-|\tNEW_TK class_type OP_TK argument_list CP_TK class_body\n-|\tNEW_TK class_type OP_TK CP_TK class_body         \n-        /* Added, JDK1.1 inner classes, modified to use name or\n-\t   primary instead of primary solely which couldn't work in\n-\t   all situations.  */\n+|\tanonymous_class_creation\n |\tsomething_dot_new identifier OP_TK CP_TK\n |\tsomething_dot_new identifier OP_TK CP_TK class_body\n |\tsomething_dot_new identifier OP_TK argument_list CP_TK\n |\tsomething_dot_new identifier OP_TK argument_list CP_TK class_body\n ;\n \n+anonymous_class_creation:\n+\tNEW_TK class_type OP_TK CP_TK\n+\t\t{ report_class_declaration (NULL); }\n+\tclass_body         \n+|\tNEW_TK class_type OP_TK argument_list CP_TK\n+\t\t{ report_class_declaration (NULL); }\n+\tclass_body\n+;\n+\n something_dot_new:\t\t/* Added, not part of the specs. */\n \tname DOT_TK NEW_TK\n \t\t{ USE_ABSORBER; }\n@@ -1128,36 +1132,69 @@ static void\n push_class_context (name)\n     const char *name;\n {\n-  size_t name_length = strlen (name);\n-  inner_qualifier = xrealloc (inner_qualifier, \n-                             inner_qualifier_length + name_length+2);\n-  memcpy (inner_qualifier+inner_qualifier_length, name, name_length);\n-  inner_qualifier_length += name_length;\n-  inner_qualifier [inner_qualifier_length] = '$';\n-  inner_qualifier [++inner_qualifier_length] = '\\0';\n+  /* If we already have CURRENT_CLASS set, we're in an inter\n+     class. Mangle its name. */\n+  if (current_class)\n+    {\n+      const char *p;\n+      char anonymous [3];\n+      int additional_length;\n+      \n+      /* NAME set to NULL indicates an anonymous class, which are named by\n+\t numbering them. */\n+      if (!name)\n+\t{\n+\t  sprintf (anonymous, \"%d\", ++anonymous_count);\n+\t  p = anonymous;\n+\t}\n+      else\n+\tp = name;\n+      \n+      additional_length = strlen (p)+1; /* +1 for `$' */\n+      current_class = xrealloc (current_class, \n+\t\t\t\tcurrent_class_length + additional_length + 1);\n+      current_class [current_class_length] = '$';\n+      strcpy (&current_class [current_class_length+1], p);\n+      current_class_length += additional_length;\n+    }\n+  else\n+    {\n+      if (!name)\n+\treturn;\n+      current_class_length = strlen (name);\n+      current_class = xmalloc (current_class_length+1);\n+      strcpy (current_class, name);\n+    }\n }\n \n static void\n pop_class_context ()\n {\n-  while (--inner_qualifier_length > 0\n-        && inner_qualifier [inner_qualifier_length-1] != '$')\n+  /* Go back to the last `$' and cut. */\n+  while (--current_class_length > 0\n+        && current_class [current_class_length] != '$')\n     ;\n-  inner_qualifier = xrealloc (inner_qualifier, inner_qualifier_length+1);\n-  if (inner_qualifier_length == -1)\n-    inner_qualifier_length = 0;\n-  inner_qualifier [inner_qualifier_length] = '\\0';\n+  if (current_class_length)\n+    {\n+      current_class = xrealloc (current_class, current_class_length+1);\n+      current_class [current_class_length] = '\\0';\n+    }\n+  else\n+    {\n+      current_class = NULL;\n+      anonymous_count = 0;\n+    }\n }\n \n /* Actions defined here */\n-#define INNER_QUALIFIER (inner_qualifier ? inner_qualifier : \"\")\n \n static void\n report_class_declaration (name)\n      const char * name;\n {\n   extern int flag_dump_class, flag_list_filename;\n \n+  push_class_context (name);\n   if (flag_dump_class)\n     {\n       if (!previous_output)\n@@ -1168,13 +1205,10 @@ report_class_declaration (name)\n \t}\n \t\n       if (package_name)\n-\tfprintf (out, \"%s.%s%s \", package_name, INNER_QUALIFIER, name);\n+\tfprintf (out, \"%s.%s \", package_name, current_class);\n       else\n-\tfprintf (out, \"%s%s \", INNER_QUALIFIER, name);\n+\tfprintf (out, \"%s \", current_class);\n     }\n-\n-  push_class_context (name);\n-  current_class = name;\n }\n \n static void\n@@ -1208,7 +1242,8 @@ report_main_declaration (declarator)\n void reset_report ()\n {\n   previous_output = 0;\n-  current_class = package_name = NULL;\n+  package_name = NULL;\n+  current_class = NULL;\n }\n \n void"}, {"sha": "684297962ec4c74353d2db0d782bbe71cc164bfa", "filename": "gcc/java/parse.y", "status": "modified", "additions": 59, "deletions": 24, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f3a77740016ecd1168ce689bbc36d705ddff49/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f3a77740016ecd1168ce689bbc36d705ddff49/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=f0f3a77740016ecd1168ce689bbc36d705ddff49", "patch": "@@ -7523,22 +7523,49 @@ maybe_yank_clinit (mdecl)\n   \n   if (!DECL_CLINIT_P (mdecl))\n     return 0;\n-  \n-  /* If the body isn't empty, then we keep <clinit> */\n+\n+  /* If the body isn't empty, then we keep <clinit>. Note that if\n+     we're emitting classfiles, this isn't enough not to rule it\n+     out. */\n   fbody = DECL_FUNCTION_BODY (mdecl);\n   if ((bbody = BLOCK_EXPR_BODY (fbody)))\n     bbody = BLOCK_EXPR_BODY (bbody);\n-  if (bbody && bbody != empty_stmt_node)\n+  if (bbody && ! flag_emit_class_files && bbody != empty_stmt_node)\n     return 0;\n   \n   type = DECL_CONTEXT (mdecl);\n   current = TYPE_FIELDS (type);\n \n   for (current = (current ? TREE_CHAIN (current) : current); \n        current; current = TREE_CHAIN (current))\n-    if (!(FIELD_STATIC (current) && FIELD_FINAL (current)\n-\t  && DECL_INITIAL (current) && TREE_CONSTANT (DECL_INITIAL (current))))\n-      break;\n+    {\n+      tree f_init;\n+\n+      /* We're not interested in non static field */\n+      if (!FIELD_STATIC (current))\n+\tcontinue;\n+\n+      /* Anything that isn't String or a basic type is ruled out -- or\n+\t if we now how to deal with it (when doing things natively) we\n+\t should generated an empty <clinit> so that SUID are computed\n+\t correctly. */\n+      if (! JSTRING_TYPE_P (TREE_TYPE (current))\n+\t  && ! JNUMERIC_TYPE_P (TREE_TYPE (current)))\n+\tbreak;\n+\t  \n+      f_init = DECL_INITIAL (current);\n+      /* If we're emitting native code, we want static final fields to\n+\t have constant initializers. If we don't meet these\n+\t conditions, we keep <clinit> */\n+      if (!flag_emit_class_files\n+\t  && !(FIELD_FINAL (current) && f_init && TREE_CONSTANT (f_init)))\n+\tbreak;\n+      /* If we're emitting bytecode, we want static fields to have\n+\t constant initializers or no initializer. If we don't meet\n+\t these conditions, we keep <clinit> */\n+      if (flag_emit_class_files && f_init && !TREE_CONSTANT (f_init))\n+\tbreak;\n+    }\n \n   if (current)\n     return 0;\n@@ -7661,7 +7688,7 @@ build_outer_field_access (id, decl)\n   tree ctx = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (current_class)));\n \n   /* If decl's class is the direct outer class of the current_class,\n-     build the access as `this$<n>.<field>'. Not that we will break\n+     build the access as `this$<n>.<field>'. Note that we will break\n      the `private' barrier if we're not emitting bytecodes. */\n   if (ctx == DECL_CONTEXT (decl) \n       && (!FIELD_PRIVATE (decl) || !flag_emit_class_files ))\n@@ -7677,7 +7704,7 @@ build_outer_field_access (id, decl)\n       int lc = EXPR_WFL_LINECOL (id);\n \n       /* Now we chain the required number of calls to the access$0 to\n-\t get a hold to the enclosing instance we need, and the we\n+\t get a hold to the enclosing instance we need, and then we\n \t build the field access. */\n       access = build_access_to_thisn (ctx, DECL_CONTEXT (decl), lc);\n \n@@ -8269,14 +8296,21 @@ build_dot_class_method (class)\n }\n \n static tree\n-build_dot_class_method_invocation (name)\n-     tree name;\n+build_dot_class_method_invocation (type)\n+     tree type;\n {\n-  tree s = make_node (STRING_CST);\n-  TREE_STRING_LENGTH (s) = IDENTIFIER_LENGTH (name);\n+  tree sig_id, s;\n+\n+  if (TYPE_ARRAY_P (type))\n+    sig_id = build_java_signature (type);\n+  else\n+    sig_id = DECL_NAME (TYPE_NAME (type));\n+\n+  s = make_node (STRING_CST);\n+  TREE_STRING_LENGTH (s) = IDENTIFIER_LENGTH (sig_id);\n   TREE_STRING_POINTER (s) = obstack_alloc (expression_obstack,\n \t\t\t\t\t   TREE_STRING_LENGTH (s)+1);\n-  strcpy (TREE_STRING_POINTER (s), IDENTIFIER_POINTER (name));\n+  strcpy (TREE_STRING_POINTER (s), IDENTIFIER_POINTER (sig_id));\n   return build_method_invocation (build_wfl_node (get_identifier (\"class$\")),\n \t\t\t\t  build_tree_list (NULL_TREE, s));\n }\n@@ -8318,6 +8352,11 @@ fix_constructors (mdecl)\n \t CLASSNAME() constructor */\n       start_artificial_method_body (mdecl);\n       \n+      /* Insert an assignment to the this$<n> hidden field, if\n+         necessary */\n+      if ((thisn_assign = build_thisn_assign ()))\n+\tjava_method_add_stmt (mdecl, thisn_assign);\n+\n       /* We don't generate a super constructor invocation if we're\n \t compiling java.lang.Object. build_super_invocation takes care\n \t of that. */\n@@ -8327,11 +8366,6 @@ fix_constructors (mdecl)\n          super invocation. */\n       add_instance_initializer (mdecl);\n \n-      /* Insert an assignment to the this$<n> hidden field, if\n-         necessary */\n-      if ((thisn_assign = build_thisn_assign ()))\n-\tjava_method_add_stmt (mdecl, thisn_assign);\n-\n       end_artificial_method_body (mdecl);\n     }\n   /* Search for an explicit constructor invocation */\n@@ -8363,14 +8397,14 @@ fix_constructors (mdecl)\n \tcompound = add_stmt_to_compound (compound, NULL_TREE,\n                                          build_super_invocation (mdecl));\n       \n-      /* Insert the instance initializer block right here, after the\n-         super invocation. */\n-      add_instance_initializer (mdecl);\n-\n       /* Generate the assignment to this$<n>, if necessary */\n       if ((thisn_assign = build_thisn_assign ()))\n         compound = add_stmt_to_compound (compound, NULL_TREE, thisn_assign);\n \n+      /* Insert the instance initializer block right here, after the\n+         super invocation. */\n+      add_instance_initializer (mdecl);\n+\n       /* Fix the constructor main block if we're adding extra stmts */\n       if (compound)\n \t{\n@@ -9170,6 +9204,8 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t\t\t\t\t  current_class);\n \t\t\t  return 1;\n \t\t\t}\n+                      if (outer_field_access_p (current_class, decl))\n+                        decl = build_outer_field_access (qual_wfl, decl);\n \t\t    }\n \t\t  else\n \t\t    {\n@@ -13114,8 +13150,7 @@ patch_incomplete_class_ref (node)\n      synthetic static method `class$'. */\n   if (!TYPE_DOT_CLASS (current_class))\n       build_dot_class_method (current_class);\n-  ref_type = \n-    build_dot_class_method_invocation (DECL_NAME (TYPE_NAME (ref_type)));\n+  ref_type = build_dot_class_method_invocation (ref_type);\n   return java_complete_tree (ref_type);\n }\n "}]}