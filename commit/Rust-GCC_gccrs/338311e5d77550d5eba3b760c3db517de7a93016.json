{"sha": "338311e5d77550d5eba3b760c3db517de7a93016", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM4MzExZTVkNzc1NTBkNWViYTNiNzYwYzNkYjUxN2RlN2E5MzAxNg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2009-11-05T14:06:13Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2009-11-05T14:06:13Z"}, "message": "multiway_merge.h: Simple formatting and uglification fixes.\n\n2009-11-05  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* include/parallel/multiway_merge.h: Simple formatting and\n\tuglification fixes.\n\t* include/parallel/losertree.h: Likewise.\n\t* include/parallel/base.h: Likewise.\n\t* include/parallel/par_loop.h: Likewise.\n\t* include/parallel/omp_loop_static.h: Likewise.\n\t* include/parallel/multiway_mergesort.h: Likewise.\n\t* include/parallel/partial_sum.h: Likewise.\n\t* include/parallel/omp_loop.h: Likewise.\n\nFrom-SVN: r153939", "tree": {"sha": "0184fef88c6c0ad06f8bbbe30c7eb876d0a8d394", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0184fef88c6c0ad06f8bbbe30c7eb876d0a8d394"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/338311e5d77550d5eba3b760c3db517de7a93016", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/338311e5d77550d5eba3b760c3db517de7a93016", "html_url": "https://github.com/Rust-GCC/gccrs/commit/338311e5d77550d5eba3b760c3db517de7a93016", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/338311e5d77550d5eba3b760c3db517de7a93016/comments", "author": null, "committer": null, "parents": [{"sha": "94086ef69ccc24abf3f741461e6a7d3b3fa693cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94086ef69ccc24abf3f741461e6a7d3b3fa693cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94086ef69ccc24abf3f741461e6a7d3b3fa693cb"}], "stats": {"total": 2389, "additions": 1169, "deletions": 1220}, "files": [{"sha": "58bd89ff26d602db237ad8f13c9a3942e41a3249", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338311e5d77550d5eba3b760c3db517de7a93016/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338311e5d77550d5eba3b760c3db517de7a93016/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=338311e5d77550d5eba3b760c3db517de7a93016", "patch": "@@ -1,3 +1,15 @@\n+2009-11-05  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* include/parallel/multiway_merge.h: Simple formatting and\n+\tuglification fixes.\n+\t* include/parallel/losertree.h: Likewise.\n+\t* include/parallel/base.h: Likewise.\n+\t* include/parallel/par_loop.h: Likewise.\n+\t* include/parallel/omp_loop_static.h: Likewise.\n+\t* include/parallel/multiway_mergesort.h: Likewise.\n+\t* include/parallel/partial_sum.h: Likewise.\n+\t* include/parallel/omp_loop.h: Likewise.\n+\n 2009-11-04  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* testsuite/25_algorithms/fill/5.cc: Move..."}, {"sha": "eee88bd2ce1dc681b7d8694002a244324536ffb8", "filename": "libstdc++-v3/include/parallel/base.h", "status": "modified", "additions": 323, "deletions": 327, "changes": 650, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338311e5d77550d5eba3b760c3db517de7a93016/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338311e5d77550d5eba3b760c3db517de7a93016/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h?ref=338311e5d77550d5eba3b760c3db517de7a93016", "patch": "@@ -93,370 +93,366 @@ namespace __gnu_parallel\n   __is_parallel(const _Parallelism __p) { return __p != sequential; }\n \n \n-/** @brief Calculates the rounded-down logarithm of @__c __n for base 2.\n-  *  @param __n Argument.\n-  *  @return Returns 0 for any argument <1.\n-  */\n-template<typename _Size>\n-  inline _Size\n-  __rd_log2(_Size __n)\n+  /** @brief Calculates the rounded-down logarithm of @__c __n for base 2.\n+   *  @param __n Argument.\n+   *  @return Returns 0 for any argument <1.\n+   */\n+  template<typename _Size>\n+    inline _Size\n+    __rd_log2(_Size __n)\n     {\n       _Size __k;\n       for (__k = 0; __n > 1; __n >>= 1)\n         ++__k;\n       return __k;\n     }\n \n-/** @brief Encode two integers into one gnu_parallel::_CASable.\n-  *  @param __a First integer, to be encoded in the most-significant @__c\n-  *  _CASable_bits/2 bits.\n-  *  @param __b Second integer, to be encoded in the least-significant\n-  *  @__c _CASable_bits/2 bits.\n-  *  @return value encoding @__c __a and @__c __b.\n-  *  @see decode2\n-  */\n-inline _CASable\n-__encode2(int __a, int __b)     //must all be non-negative, actually\n-{\n-  return (((_CASable)__a) << (_CASable_bits / 2)) | (((_CASable)__b) << 0);\n-}\n-\n-/** @brief Decode two integers from one gnu_parallel::_CASable.\n-  *  @param __x __gnu_parallel::_CASable to decode integers from.\n-  *  @param __a First integer, to be decoded from the most-significant\n-  *  @__c _CASable_bits/2 bits of @__c __x.\n-  *  @param __b Second integer, to be encoded in the least-significant\n-  *  @__c _CASable_bits/2 bits of @__c __x.\n-  *  @see __encode2\n-  */\n-inline void\n-decode2(_CASable __x, int& __a, int& __b)\n-{\n-  __a = (int)((__x >> (_CASable_bits / 2)) & _CASable_mask);\n-  __b = (int)((__x >>               0 ) & _CASable_mask);\n-}\n-\n-//needed for parallel \"numeric\", even if \"algorithm\" not included\n-\n-/** @brief Equivalent to std::min. */\n-template<typename _Tp>\n-  const _Tp&\n-  min(const _Tp& __a, const _Tp& __b)\n-  { return (__a < __b) ? __a : __b; }\n-\n-/** @brief Equivalent to std::max. */\n-template<typename _Tp>\n-  const _Tp&\n-  max(const _Tp& __a, const _Tp& __b)\n-  { return (__a > __b) ? __a : __b; }\n-\n-/** @brief Constructs predicate for equality from strict weak\n-  *  ordering predicate\n-  */\n-template<typename _T1, typename _T2, typename _Compare>\n-  class _EqualFromLess : public std::binary_function<_T1, _T2, bool>\n+  /** @brief Encode two integers into one gnu_parallel::_CASable.\n+   *  @param __a First integer, to be encoded in the most-significant @__c\n+   *  _CASable_bits/2 bits.\n+   *  @param __b Second integer, to be encoded in the least-significant\n+   *  @__c _CASable_bits/2 bits.\n+   *  @return value encoding @__c __a and @__c __b.\n+   *  @see decode2\n+   */\n+  inline _CASable\n+  __encode2(int __a, int __b)     //must all be non-negative, actually\n   {\n-  private:\n-    _Compare& _M_comp;\n+    return (((_CASable)__a) << (_CASable_bits / 2)) | (((_CASable)__b) << 0);\n+  }\n \n-  public:\n-    _EqualFromLess(_Compare& __comp) : _M_comp(__comp) { }\n+  /** @brief Decode two integers from one gnu_parallel::_CASable.\n+   *  @param __x __gnu_parallel::_CASable to decode integers from.\n+   *  @param __a First integer, to be decoded from the most-significant\n+   *  @__c _CASable_bits/2 bits of @__c __x.\n+   *  @param __b Second integer, to be encoded in the least-significant\n+   *  @__c _CASable_bits/2 bits of @__c __x.\n+   *  @see __encode2\n+   */\n+  inline void\n+  decode2(_CASable __x, int& __a, int& __b)\n+  {\n+    __a = (int)((__x >> (_CASable_bits / 2)) & _CASable_mask);\n+    __b = (int)((__x >>               0 ) & _CASable_mask);\n+  }\n \n-    bool operator()(const _T1& __a, const _T2& __b)\n-    {\n-      return !_M_comp(__a, __b) && !_M_comp(__b, __a);\n-    }\n-  };\n+  //needed for parallel \"numeric\", even if \"algorithm\" not included\n \n+  /** @brief Equivalent to std::min. */\n+  template<typename _Tp>\n+    const _Tp&\n+    min(const _Tp& __a, const _Tp& __b)\n+    { return (__a < __b) ? __a : __b; }\n \n-/** @brief Similar to std::binder1st,\n-  *  but giving the argument types explicitly. */\n-template<typename _Predicate, typename argument_type>\n-  class __unary_negate\n-  : public std::unary_function<argument_type, bool>\n-  {\n-  protected:\n-    _Predicate _M_pred;\n-\n-  public:\n-    explicit\n-    __unary_negate(const _Predicate& __x) : _M_pred(__x) { }\n-\n-    bool\n-    operator()(const argument_type& __x)\n-    { return !_M_pred(__x); }\n-  };\n-\n-/** @brief Similar to std::binder1st,\n-  *  but giving the argument types explicitly. */\n-template<typename _Operation, typename _FirstArgumentType,\n-         typename _SecondArgumentType, typename _ResultType>\n-  class __binder1st\n-  : public std::unary_function<_SecondArgumentType, _ResultType>\n-  {\n-  protected:\n-    _Operation _M_op;\n-    _FirstArgumentType _M_value;\n-\n-  public:\n-    __binder1st(const _Operation& __x,\n-              const _FirstArgumentType& __y)\n-    : _M_op(__x), _M_value(__y) { }\n-\n-    _ResultType\n-    operator()(const _SecondArgumentType& __x)\n-    { return _M_op(_M_value, __x); }\n-\n-    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-    // 109.  Missing binders for non-const sequence elements\n-    _ResultType\n-    operator()(_SecondArgumentType& __x) const\n-    { return _M_op(_M_value, __x); }\n-  };\n+  /** @brief Equivalent to std::max. */\n+  template<typename _Tp>\n+    const _Tp&\n+    max(const _Tp& __a, const _Tp& __b)\n+    { return (__a > __b) ? __a : __b; }\n+\n+  /** @brief Constructs predicate for equality from strict weak\n+   *  ordering predicate\n+   */\n+  template<typename _T1, typename _T2, typename _Compare>\n+    class _EqualFromLess : public std::binary_function<_T1, _T2, bool>\n+    {\n+    private:\n+      _Compare& _M_comp;\n \n-/**\n-  *  @brief Similar to std::binder2nd, but giving the argument types\n-  *  explicitly.\n-  */\n-template<typename _Operation, typename _FirstArgumentType,\n-         typename _SecondArgumentType, typename _ResultType>\n-  class binder2nd\n-  : public std::unary_function<_FirstArgumentType, _ResultType>\n-  {\n-  protected:\n-    _Operation _M_op;\n-    _SecondArgumentType _M_value;\n-\n-  public:\n-    binder2nd(const _Operation& __x,\n-              const _SecondArgumentType& __y)\n-    : _M_op(__x), _M_value(__y) { }\n-\n-    _ResultType\n-    operator()(const _FirstArgumentType& __x) const\n-    { return _M_op(__x, _M_value); }\n-\n-    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-    // 109.  Missing binders for non-const sequence elements\n-    _ResultType\n-    operator()(_FirstArgumentType& __x)\n-    { return _M_op(__x, _M_value); }\n-  };\n-\n-/** @brief Similar to std::equal_to, but allows two different types. */\n-template<typename _T1, typename _T2>\n-  struct _EqualTo : std::binary_function<_T1, _T2, bool>\n-  {\n-    bool operator()(const _T1& __t1, const _T2& __t2) const\n-    { return __t1 == __t2; }\n-  };\n+    public:\n+      _EqualFromLess(_Compare& __comp) : _M_comp(__comp) { }\n \n-/** @brief Similar to std::less, but allows two different types. */\n-template<typename _T1, typename _T2>\n-  struct _Less : std::binary_function<_T1, _T2, bool>\n-  {\n-    bool\n-    operator()(const _T1& __t1, const _T2& __t2) const\n-    { return __t1 < __t2; }\n-\n-    bool\n-    operator()(const _T2& __t2, const _T1& __t1) const\n-    { return __t2 < __t1; }\n-  };\n-\n-// Partial specialization for one type. Same as std::less.\n-template<typename _Tp>\n-struct _Less<_Tp, _Tp> : public std::binary_function<_Tp, _Tp, bool>\n-  {\n-    bool\n-    operator()(const _Tp& __x, const _Tp& __y) const\n-    { return __x < __y; }\n-  };\n+      bool operator()(const _T1& __a, const _T2& __b)\n+      { return !_M_comp(__a, __b) && !_M_comp(__b, __a); }\n+    };\n \n \n-  /** @brief Similar to std::plus, but allows two different types. */\n-template<typename _Tp1, typename _Tp2>\n-  struct _Plus : public std::binary_function<_Tp1, _Tp2, _Tp1>\n-  {\n-    typedef __typeof__(*static_cast<_Tp1*>(NULL)\n-                       + *static_cast<_Tp2*>(NULL)) __result;\n+  /** @brief Similar to std::binder1st,\n+   *  but giving the argument types explicitly. */\n+  template<typename _Predicate, typename argument_type>\n+    class __unary_negate\n+    : public std::unary_function<argument_type, bool>\n+    {\n+    protected:\n+      _Predicate _M_pred;\n+\n+    public:\n+      explicit\n+      __unary_negate(const _Predicate& __x) : _M_pred(__x) { }\n+\n+      bool\n+      operator()(const argument_type& __x)\n+      { return !_M_pred(__x); }\n+    };\n+\n+  /** @brief Similar to std::binder1st,\n+   *  but giving the argument types explicitly. */\n+  template<typename _Operation, typename _FirstArgumentType,\n+\t   typename _SecondArgumentType, typename _ResultType>\n+    class __binder1st\n+    : public std::unary_function<_SecondArgumentType, _ResultType>\n+    {\n+    protected:\n+      _Operation _M_op;\n+      _FirstArgumentType _M_value;\n+\n+    public:\n+      __binder1st(const _Operation& __x, const _FirstArgumentType& __y)\n+      : _M_op(__x), _M_value(__y) { }\n+\n+      _ResultType\n+      operator()(const _SecondArgumentType& __x)\n+      { return _M_op(_M_value, __x); }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 109.  Missing binders for non-const sequence elements\n+      _ResultType\n+      operator()(_SecondArgumentType& __x) const\n+      { return _M_op(_M_value, __x); }\n+    };\n+\n+  /**\n+   *  @brief Similar to std::binder2nd, but giving the argument types\n+   *  explicitly.\n+   */\n+  template<typename _Operation, typename _FirstArgumentType,\n+\t   typename _SecondArgumentType, typename _ResultType>\n+    class binder2nd\n+    : public std::unary_function<_FirstArgumentType, _ResultType>\n+    {\n+    protected:\n+      _Operation _M_op;\n+      _SecondArgumentType _M_value;\n+\n+    public:\n+      binder2nd(const _Operation& __x, const _SecondArgumentType& __y)\n+      : _M_op(__x), _M_value(__y) { }\n+\n+      _ResultType\n+      operator()(const _FirstArgumentType& __x) const\n+      { return _M_op(__x, _M_value); }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 109.  Missing binders for non-const sequence elements\n+      _ResultType\n+      operator()(_FirstArgumentType& __x)\n+      { return _M_op(__x, _M_value); }\n+    };\n+\n+  /** @brief Similar to std::equal_to, but allows two different types. */\n+  template<typename _T1, typename _T2>\n+    struct _EqualTo : std::binary_function<_T1, _T2, bool>\n+    {\n+      bool operator()(const _T1& __t1, const _T2& __t2) const\n+      { return __t1 == __t2; }\n+    };\n \n-    __result\n-    operator()(const _Tp1& __x, const _Tp2& __y) const\n-    { return __x + __y; }\n-  };\n+  /** @brief Similar to std::less, but allows two different types. */\n+  template<typename _T1, typename _T2>\n+    struct _Less : std::binary_function<_T1, _T2, bool>\n+    {\n+      bool\n+      operator()(const _T1& __t1, const _T2& __t2) const\n+      { return __t1 < __t2; }\n+\n+      bool\n+      operator()(const _T2& __t2, const _T1& __t1) const\n+      { return __t2 < __t1; }\n+    };\n+\n+  // Partial specialization for one type. Same as std::less.\n+  template<typename _Tp>\n+    struct _Less<_Tp, _Tp> : public std::binary_function<_Tp, _Tp, bool>\n+    {\n+      bool\n+      operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x < __y; }\n+    };\n \n-// Partial specialization for one type. Same as std::plus.\n-template<typename _Tp>\n-  struct _Plus<_Tp, _Tp> : public std::binary_function<_Tp, _Tp, _Tp>\n-  {\n-    typedef __typeof__(*static_cast<_Tp*>(NULL)\n-                       + *static_cast<_Tp*>(NULL)) __result;\n \n-    __result\n-    operator()(const _Tp& __x, const _Tp& __y) const\n-    { return __x + __y; }\n-  };\n+  /** @brief Similar to std::plus, but allows two different types. */\n+  template<typename _Tp1, typename _Tp2>\n+    struct _Plus : public std::binary_function<_Tp1, _Tp2, _Tp1>\n+    {\n+      typedef __typeof__(*static_cast<_Tp1*>(NULL)\n+\t\t\t + *static_cast<_Tp2*>(NULL)) __result;\n \n+      __result\n+      operator()(const _Tp1& __x, const _Tp2& __y) const\n+      { return __x + __y; }\n+    };\n \n-/** @brief Similar to std::multiplies, but allows two different types. */\n-template<typename _Tp1, typename _Tp2>\n-  struct _Multiplies : public std::binary_function<_Tp1, _Tp2, _Tp1>\n-  {\n-    typedef __typeof__(*static_cast<_Tp1*>(NULL)\n-                       * *static_cast<_Tp2*>(NULL)) __result;\n+  // Partial specialization for one type. Same as std::plus.\n+  template<typename _Tp>\n+    struct _Plus<_Tp, _Tp> : public std::binary_function<_Tp, _Tp, _Tp>\n+    {\n+      typedef __typeof__(*static_cast<_Tp*>(NULL)\n+\t\t\t + *static_cast<_Tp*>(NULL)) __result;\n \n-    __result\n-    operator()(const _Tp1& __x, const _Tp2& __y) const\n-    { return __x * __y; }\n-  };\n+      __result\n+      operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x + __y; }\n+    };\n \n-// Partial specialization for one type. Same as std::multiplies.\n-template<typename _Tp>\n-  struct _Multiplies<_Tp, _Tp> : public std::binary_function<_Tp, _Tp, _Tp>\n-  {\n-    typedef __typeof__(*static_cast<_Tp*>(NULL)\n-                       * *static_cast<_Tp*>(NULL)) __result;\n \n-    __result\n-    operator()(const _Tp& __x, const _Tp& __y) const\n-    { return __x * __y; }\n-  };\n+  /** @brief Similar to std::multiplies, but allows two different types. */\n+  template<typename _Tp1, typename _Tp2>\n+    struct _Multiplies : public std::binary_function<_Tp1, _Tp2, _Tp1>\n+    {\n+      typedef __typeof__(*static_cast<_Tp1*>(NULL)\n+\t\t\t * *static_cast<_Tp2*>(NULL)) __result;\n \n+      __result\n+      operator()(const _Tp1& __x, const _Tp2& __y) const\n+      { return __x * __y; }\n+    };\n \n-template<typename _Tp, typename _DifferenceTp>\n-  class _PseudoSequence;\n+  // Partial specialization for one type. Same as std::multiplies.\n+  template<typename _Tp>\n+    struct _Multiplies<_Tp, _Tp> : public std::binary_function<_Tp, _Tp, _Tp>\n+    {\n+      typedef __typeof__(*static_cast<_Tp*>(NULL)\n+\t\t\t * *static_cast<_Tp*>(NULL)) __result;\n \n-/** @brief _Iterator associated with __gnu_parallel::_PseudoSequence.\n-  *  If features the usual random-access iterator functionality.\n-  *  @param _Tp Sequence _M_value type.\n-  *  @param _DifferenceType Sequence difference type.\n-  */\n-template<typename _Tp, typename _DifferenceTp>\n-  class _PseudoSequenceIterator\n-  {\n-  public:\n-    typedef _DifferenceTp _DifferenceType;\n+      __result\n+      operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x * __y; }\n+    };\n \n-  private:\n-    const _Tp& _M_val;\n-    _DifferenceType _M_pos;\n \n-  public:\n-    _PseudoSequenceIterator(const _Tp& _M_val, _DifferenceType _M_pos)\n-    : _M_val(_M_val), _M_pos(_M_pos) { }\n+  template<typename _Tp, typename _DifferenceTp>\n+    class _PseudoSequence;\n \n-    // Pre-increment operator.\n-    _PseudoSequenceIterator&\n-    operator++()\n+  /** @brief _Iterator associated with __gnu_parallel::_PseudoSequence.\n+   *  If features the usual random-access iterator functionality.\n+   *  @param _Tp Sequence _M_value type.\n+   *  @param _DifferenceType Sequence difference type.\n+   */\n+  template<typename _Tp, typename _DifferenceTp>\n+    class _PseudoSequenceIterator\n     {\n-      ++_M_pos;\n-      return *this;\n-    }\n+    public:\n+      typedef _DifferenceTp _DifferenceType;\n \n-    // Post-increment operator.\n-    const _PseudoSequenceIterator\n-    operator++(int)\n-    { return _PseudoSequenceIterator(_M_pos++); }\n+    private:\n+      const _Tp& _M_val;\n+      _DifferenceType _M_pos;\n \n-    const _Tp&\n-    operator*() const\n-    { return _M_val; }\n+    public:\n+      _PseudoSequenceIterator(const _Tp& __val, _DifferenceType __pos)\n+      : _M_val(__val), _M_pos(__pos) { }\n \n-    const _Tp&\n-    operator[](_DifferenceType) const\n-    { return _M_val; }\n-\n-    bool\n-    operator==(const _PseudoSequenceIterator& __i2)\n-    { return _M_pos == __i2._M_pos; }\n-\n-    _DifferenceType\n-    operator!=(const _PseudoSequenceIterator& __i2)\n-    { return _M_pos != __i2._M_pos; }\n-\n-    _DifferenceType\n-    operator-(const _PseudoSequenceIterator& __i2)\n-    { return _M_pos - __i2._M_pos; }\n-  };\n-\n-/** @brief Sequence that conceptually consists of multiple copies of\n-    the same element.\n-  *  The copies are not stored explicitly, of course.\n-  *  @param _Tp Sequence _M_value type.\n-  *  @param _DifferenceType Sequence difference type.\n-  */\n-template<typename _Tp, typename _DifferenceTp>\n-  class _PseudoSequence\n-  {\n-  public:\n-    typedef _DifferenceTp _DifferenceType;\n-\n-    // Better cast down to uint64_t, than up to _DifferenceTp.\n-    typedef _PseudoSequenceIterator<_Tp, uint64_t> iterator;\n+      // Pre-increment operator.\n+      _PseudoSequenceIterator&\n+      operator++()\n+      {\n+\t++_M_pos;\n+\treturn *this;\n+      }\n \n-    /** @brief Constructor.\n-      *  @param _M_val Element of the sequence.\n-      *  @param __count Number of (virtual) copies.\n+      // Post-increment operator.\n+      const _PseudoSequenceIterator\n+      operator++(int)\n+      { return _PseudoSequenceIterator(_M_pos++); }\n+\n+      const _Tp&\n+      operator*() const\n+      { return _M_val; }\n+\n+      const _Tp&\n+      operator[](_DifferenceType) const\n+      { return _M_val; }\n+\n+      bool\n+      operator==(const _PseudoSequenceIterator& __i2)\n+      { return _M_pos == __i2._M_pos; }\n+\n+      _DifferenceType\n+      operator!=(const _PseudoSequenceIterator& __i2)\n+      { return _M_pos != __i2._M_pos; }\n+\n+      _DifferenceType\n+      operator-(const _PseudoSequenceIterator& __i2)\n+      { return _M_pos - __i2._M_pos; }\n+    };\n+\n+  /** @brief Sequence that conceptually consists of multiple copies of\n+      the same element.\n+      *  The copies are not stored explicitly, of course.\n+      *  @param _Tp Sequence _M_value type.\n+      *  @param _DifferenceType Sequence difference type.\n       */\n-    _PseudoSequence(const _Tp& _M_val, _DifferenceType __count)\n-    : _M_val(_M_val), __count(__count)  { }\n-\n-    /** @brief Begin iterator. */\n-    iterator\n-    begin() const\n-    { return iterator(_M_val, 0); }\n-\n-    /** @brief End iterator. */\n-    iterator\n-    end() const\n-    { return iterator(_M_val, __count); }\n-\n-  private:\n-    const _Tp& _M_val;\n-    _DifferenceType __count;\n-  };\n-\n-/** @brief Functor that does nothing */\n-template<typename _ValueTp>\n-  class _VoidFunctor\n-  {\n-    inline void\n-    operator()(const _ValueTp& __v) const { }\n-  };\n-\n-/** @brief Compute the median of three referenced elements,\n-    according to @__c __comp.\n-  *  @param __a First iterator.\n-  *  @param __b Second iterator.\n-  *  @param __c Third iterator.\n-  *  @param __comp Comparator.\n-  */\n-template<typename _RAIter, typename _Compare>\n-  _RAIter\n-  __median_of_three_iterators(_RAIter __a, _RAIter __b,\n-                            _RAIter __c, _Compare& __comp)\n-  {\n-    if (__comp(*__a, *__b))\n-      if (__comp(*__b, *__c))\n-        return __b;\n+  template<typename _Tp, typename _DifferenceTp>\n+    class _PseudoSequence\n+    {\n+    public:\n+      typedef _DifferenceTp _DifferenceType;\n+\n+      // Better cast down to uint64_t, than up to _DifferenceTp.\n+      typedef _PseudoSequenceIterator<_Tp, uint64_t> iterator;\n+\n+      /** @brief Constructor.\n+       *  @param _M_val Element of the sequence.\n+       *  @param __count Number of (virtual) copies.\n+       */\n+      _PseudoSequence(const _Tp& __val, _DifferenceType __count)\n+      : _M_val(__val), _M_count(__count)  { }\n+\n+      /** @brief Begin iterator. */\n+      iterator\n+      begin() const\n+      { return iterator(_M_val, 0); }\n+\n+      /** @brief End iterator. */\n+      iterator\n+      end() const\n+      { return iterator(_M_val, _M_count); }\n+\n+    private:\n+      const _Tp& _M_val;\n+      _DifferenceType _M_count;\n+    };\n+\n+  /** @brief Functor that does nothing */\n+  template<typename _ValueTp>\n+    class _VoidFunctor\n+    {\n+      inline void\n+      operator()(const _ValueTp& __v) const { }\n+    };\n+\n+  /** @brief Compute the median of three referenced elements,\n+      according to @__c __comp.\n+      *  @param __a First iterator.\n+      *  @param __b Second iterator.\n+      *  @param __c Third iterator.\n+      *  @param __comp Comparator.\n+      */\n+  template<typename _RAIter, typename _Compare>\n+    _RAIter\n+    __median_of_three_iterators(_RAIter __a, _RAIter __b,\n+\t\t\t\t_RAIter __c, _Compare& __comp)\n+    {\n+      if (__comp(*__a, *__b))\n+\tif (__comp(*__b, *__c))\n+\t  return __b;\n+\telse\n+\t  if (__comp(*__a, *__c))\n+\t    return __c;\n+\t  else\n+\t    return __a;\n       else\n-        if (__comp(*__a, *__c))\n-          return __c;\n-        else\n-          return __a;\n-    else\n-      {\n-        // Just swap __a and __b.\n-        if (__comp(*__a, *__c))\n-          return __a;\n-        else\n-          if (__comp(*__b, *__c))\n-            return __c;\n-          else\n-            return __b;\n-      }\n-  }\n+\t{\n+\t  // Just swap __a and __b.\n+\t  if (__comp(*__a, *__c))\n+\t    return __a;\n+\t  else\n+\t    if (__comp(*__b, *__c))\n+\t      return __c;\n+\t    else\n+\t      return __b;\n+\t}\n+    }\n \n #define _GLIBCXX_PARALLEL_ASSERT(_Condition) __glibcxx_assert(_Condition)\n "}, {"sha": "9b9914ff1f0ec6101574b221c4946d80b5e33c73", "filename": "libstdc++-v3/include/parallel/losertree.h", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338311e5d77550d5eba3b760c3db517de7a93016/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338311e5d77550d5eba3b760c3db517de7a93016/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h?ref=338311e5d77550d5eba3b760c3db517de7a93016", "patch": "@@ -163,7 +163,8 @@ template<typename _Tp, typename _Compare>\n    */\n template<bool __stable/* default == true */, typename _Tp,\n \t typename _Compare>\n-  class _LoserTree : public _LoserTreeBase<_Tp, _Compare>\n+  class _LoserTree\n+  : public _LoserTreeBase<_Tp, _Compare>\n   {\n     typedef _LoserTreeBase<_Tp, _Compare> _Base;\n     using _Base::_M_k;\n@@ -797,7 +798,7 @@ template<typename _Tp, typename _Compare>\n *  run empty.  This is a very fast variant.\n */\n template<typename _Tp, typename _Compare>\n-  class LoserTreePointerUnguardedBase\n+  class _LoserTreePointerUnguardedBase\n   {\n   protected:\n     struct _Loser\n@@ -812,8 +813,8 @@ template<typename _Tp, typename _Compare>\n \n   public:\n \n-    LoserTreePointerUnguardedBase(unsigned int __k, const _Tp& _sentinel,\n-\t\t\t\t  _Compare __comp = std::less<_Tp>())\n+    _LoserTreePointerUnguardedBase(unsigned int __k, const _Tp& _sentinel,\n+\t\t\t\t   _Compare __comp = std::less<_Tp>())\n     : _M_comp(__comp)\n     {\n       _M_ik = __k;\n@@ -831,7 +832,7 @@ template<typename _Tp, typename _Compare>\n \t}\n     }\n \n-    ~LoserTreePointerUnguardedBase()\n+    ~_LoserTreePointerUnguardedBase()\n     { delete[] _M_losers; }\n \n     int\n@@ -861,16 +862,16 @@ template<typename _Tp, typename _Compare>\n  */\n template<bool __stable/* default == true */, typename _Tp, typename _Compare>\n   class _LoserTreePointerUnguarded\n-  : public LoserTreePointerUnguardedBase<_Tp, _Compare>\n+  : public _LoserTreePointerUnguardedBase<_Tp, _Compare>\n   {\n-    typedef LoserTreePointerUnguardedBase<_Tp, _Compare> _Base;\n+    typedef _LoserTreePointerUnguardedBase<_Tp, _Compare> _Base;\n     using _Base::_M_k;\n     using _Base::_M_losers;\n \n   public:\n     _LoserTreePointerUnguarded(unsigned int __k, const _Tp& _sentinel,\n \t\t\t       _Compare __comp = std::less<_Tp>())\n-    : _Base::LoserTreePointerUnguardedBase(__k, _sentinel, __comp)\n+    : _Base::_LoserTreePointerUnguardedBase(__k, _sentinel, __comp)\n     { }\n \n     unsigned int\n@@ -945,16 +946,16 @@ template<bool __stable/* default == true */, typename _Tp, typename _Compare>\n  */\n template<typename _Tp, typename _Compare>\n   class _LoserTreePointerUnguarded</* __stable == */false, _Tp, _Compare>\n-  : public LoserTreePointerUnguardedBase<_Tp, _Compare>\n+  : public _LoserTreePointerUnguardedBase<_Tp, _Compare>\n   {\n-    typedef LoserTreePointerUnguardedBase<_Tp, _Compare> _Base;\n+    typedef _LoserTreePointerUnguardedBase<_Tp, _Compare> _Base;\n     using _Base::_M_k;\n     using _Base::_M_losers;\n \n public:\n     _LoserTreePointerUnguarded(unsigned int __k, const _Tp& _sentinel,\n \t\t\t       _Compare __comp = std::less<_Tp>())\n-    : _Base::LoserTreePointerUnguardedBase(__k, _sentinel, __comp)\n+    : _Base::_LoserTreePointerUnguardedBase(__k, _sentinel, __comp)\n     { }\n \n     unsigned int"}, {"sha": "a5bb2d74adcaba5df65cd4b6586a3e35150ed579", "filename": "libstdc++-v3/include/parallel/multiway_merge.h", "status": "modified", "additions": 157, "deletions": 209, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338311e5d77550d5eba3b760c3db517de7a93016/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338311e5d77550d5eba3b760c3db517de7a93016/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h?ref=338311e5d77550d5eba3b760c3db517de7a93016", "patch": "@@ -54,24 +54,6 @@\n \n namespace __gnu_parallel\n {\n-\n-// Announce guarded and unguarded iterator.\n-\n-template<typename _RAIter, typename _Compare>\n-  class _GuardedIterator;\n-\n-// Making the arguments const references seems to dangerous,\n-// the user-defined comparator might not be const.\n-template<typename _RAIter, typename _Compare>\n-  inline bool\n-  operator<(_GuardedIterator<_RAIter, _Compare>& __bi1,\n-             _GuardedIterator<_RAIter, _Compare>& __bi2);\n-\n-template<typename _RAIter, typename _Compare>\n-  inline bool\n-  operator<=(_GuardedIterator<_RAIter, _Compare>& __bi1,\n-              _GuardedIterator<_RAIter, _Compare>& __bi2);\n-\n /** @brief _Iterator wrapper supporting an implicit supremum at the end\n  *         of the sequence, dominating all comparisons.\n  *\n@@ -96,12 +78,11 @@ template<typename _RAIter, typename _Compare>\n   public:\n     /** @brief Constructor. Sets iterator to beginning of sequence.\n     *  @param __begin Begin iterator of sequence.\n-    *  @param _M_end End iterator of sequence.\n+    *  @param __end End iterator of sequence.\n     *  @param __comp Comparator provided for associated overloaded\n     *  compare operators. */\n-    _GuardedIterator(_RAIter __begin,\n-                     _RAIter _M_end, _Compare& __comp)\n-    : _M_current(__begin), _M_end(_M_end), __comp(__comp)\n+    _GuardedIterator(_RAIter __begin, _RAIter __end, _Compare& __comp)\n+    : _M_current(__begin), _M_end(__end), __comp(__comp)\n     { }\n \n     /** @brief Pre-increment operator.\n@@ -124,62 +105,37 @@ template<typename _RAIter, typename _Compare>\n     operator _RAIter()\n     { return _M_current; }\n \n+    /** @brief Compare two elements referenced by guarded iterators.\n+     *  @param __bi1 First iterator.\n+     *  @param __bi2 Second iterator.\n+     *  @return @__c true if less. */\n     friend bool\n-    operator< <_RAIter, _Compare>(\n-      _GuardedIterator<_RAIter, _Compare>& __bi1,\n-      _GuardedIterator<_RAIter, _Compare>& __bi2);\n+    operator<(_GuardedIterator<_RAIter, _Compare>& __bi1,\n+\t      _GuardedIterator<_RAIter, _Compare>& __bi2)\n+    {\n+      if (__bi1._M_current == __bi1._M_end)       //__bi1 is sup\n+\treturn __bi2._M_current == __bi2._M_end;  //__bi2 is not sup\n+      if (__bi2._M_current == __bi2._M_end)       //__bi2 is sup\n+\treturn true;\n+      return (__bi1.__comp)(*__bi1, *__bi2);      //normal compare\n+    }\n \n+    /** @brief Compare two elements referenced by guarded iterators.\n+     *  @param __bi1 First iterator.\n+     *  @param __bi2 Second iterator.\n+     *  @return @__c True if less equal. */\n     friend bool\n-    operator<= <_RAIter, _Compare>(\n-      _GuardedIterator<_RAIter, _Compare>& __bi1,\n-      _GuardedIterator<_RAIter, _Compare>& __bi2);\n+    operator<=(_GuardedIterator<_RAIter, _Compare>& __bi1,\n+\t       _GuardedIterator<_RAIter, _Compare>& __bi2)\n+    {\n+      if (__bi2._M_current == __bi2._M_end)       //__bi1 is sup\n+\treturn __bi1._M_current != __bi1._M_end;  //__bi2 is not sup\n+      if (__bi1._M_current == __bi1._M_end)       //__bi2 is sup\n+\treturn false;\n+      return !(__bi1.__comp)(*__bi2, *__bi1);     //normal compare\n+    } \n   };\n \n-/** @brief Compare two elements referenced by guarded iterators.\n- *  @param __bi1 First iterator.\n- *  @param __bi2 Second iterator.\n- *  @return @__c true if less. */\n-template<typename _RAIter, typename _Compare>\n-  inline bool\n-  operator<(_GuardedIterator<_RAIter, _Compare>& __bi1,\n-            _GuardedIterator<_RAIter, _Compare>& __bi2)\n-  {\n-    if (__bi1._M_current == __bi1._M_end)       //__bi1 is sup\n-      return __bi2._M_current == __bi2._M_end;  //__bi2 is not sup\n-    if (__bi2._M_current == __bi2._M_end)       //__bi2 is sup\n-      return true;\n-    return (__bi1.__comp)(*__bi1, *__bi2);      //normal compare\n-  }\n-\n-/** @brief Compare two elements referenced by guarded iterators.\n- *  @param __bi1 First iterator.\n- *  @param __bi2 Second iterator.\n- *  @return @__c True if less equal. */\n-template<typename _RAIter, typename _Compare>\n-  inline bool\n-  operator<=(_GuardedIterator<_RAIter, _Compare>& __bi1,\n-               _GuardedIterator<_RAIter, _Compare>& __bi2)\n-  {\n-    if (__bi2._M_current == __bi2._M_end)       //__bi1 is sup\n-      return __bi1._M_current != __bi1._M_end;  //__bi2 is not sup\n-    if (__bi1._M_current == __bi1._M_end)       //__bi2 is sup\n-      return false;\n-    return !(__bi1.__comp)(*__bi2, *__bi1);     //normal compare\n-  }\n-\n-template<typename _RAIter, typename _Compare>\n-  class _UnguardedIterator;\n-\n-template<typename _RAIter, typename _Compare>\n-  inline bool\n-  operator<(_UnguardedIterator<_RAIter, _Compare>& __bi1,\n-            _UnguardedIterator<_RAIter, _Compare>& __bi2);\n-\n-template<typename _RAIter, typename _Compare>\n-  inline bool\n-  operator<=(_UnguardedIterator<_RAIter, _Compare>& __bi1,\n-             _UnguardedIterator<_RAIter, _Compare>& __bi2);\n-\n template<typename _RAIter, typename _Compare>\n   class _UnguardedIterator\n   {\n@@ -192,10 +148,10 @@ template<typename _RAIter, typename _Compare>\n   public:\n     /** @brief Constructor. Sets iterator to beginning of sequence.\n     *  @param __begin Begin iterator of sequence.\n-    *  @param _M_end Unused, only for compatibility.\n+    *  @param __end Unused, only for compatibility.\n     *  @param __comp Unused, only for compatibility. */\n     _UnguardedIterator(_RAIter __begin,\n-                       _RAIter _M_end, _Compare& __comp)\n+                       _RAIter /* __end */, _Compare& __comp)\n     : _M_current(__begin), __comp(__comp)\n     { }\n \n@@ -219,43 +175,31 @@ template<typename _RAIter, typename _Compare>\n     operator _RAIter()\n     { return _M_current; }\n \n+    /** @brief Compare two elements referenced by unguarded iterators.\n+     *  @param __bi1 First iterator.\n+     *  @param __bi2 Second iterator.\n+     *  @return @__c true if less. */\n     friend bool\n-    operator< <_RAIter, _Compare>(\n-      _UnguardedIterator<_RAIter, _Compare>& __bi1,\n-      _UnguardedIterator<_RAIter, _Compare>& __bi2);\n+    operator<(_UnguardedIterator<_RAIter, _Compare>& __bi1,\n+\t      _UnguardedIterator<_RAIter, _Compare>& __bi2)\n+    {\n+      // Normal compare.\n+      return (__bi1.__comp)(*__bi1, *__bi2);\n+    }\n \n+    /** @brief Compare two elements referenced by unguarded iterators.\n+     *  @param __bi1 First iterator.\n+     *  @param __bi2 Second iterator.\n+     *  @return @__c True if less equal. */\n     friend bool\n-    operator<= <_RAIter, _Compare>(\n-      _UnguardedIterator<_RAIter, _Compare>& __bi1,\n-      _UnguardedIterator<_RAIter, _Compare>& __bi2);\n+    operator<=(_UnguardedIterator<_RAIter, _Compare>& __bi1,\n+\t       _UnguardedIterator<_RAIter, _Compare>& __bi2)\n+    {\n+      // Normal compare.\n+      return !(__bi1.__comp)(*__bi2, *__bi1);\n+    }\n   };\n \n-/** @brief Compare two elements referenced by unguarded iterators.\n- *  @param __bi1 First iterator.\n- *  @param __bi2 Second iterator.\n- *  @return @__c true if less. */\n-template<typename _RAIter, typename _Compare>\n-  inline bool\n-  operator<(_UnguardedIterator<_RAIter, _Compare>& __bi1,\n-            _UnguardedIterator<_RAIter, _Compare>& __bi2)\n-  {\n-    // Normal compare.\n-    return (__bi1.__comp)(*__bi1, *__bi2);\n-  }\n-\n-/** @brief Compare two elements referenced by unguarded iterators.\n- *  @param __bi1 First iterator.\n- *  @param __bi2 Second iterator.\n- *  @return @__c True if less equal. */\n-template<typename _RAIter, typename _Compare>\n-  inline bool\n-  operator<=(_UnguardedIterator<_RAIter, _Compare>& __bi1,\n-            _UnguardedIterator<_RAIter, _Compare>& __bi2)\n-  {\n-    // Normal compare.\n-    return !(__bi1.__comp)(*__bi2, *__bi1);\n-  }\n-\n /** @brief Highly efficient 3-way merging procedure.\n  *\n  * Merging is done with the algorithm implementation described by Peter\n@@ -287,11 +231,10 @@ template<template<typename RAI, typename C> class iterator,\n          typename _DifferenceTp,\n          typename _Compare>\n   _RAIter3\n-  multiway_merge_3_variant(\n-      _RAIterIterator __seqs_begin,\n-      _RAIterIterator __seqs_end,\n-      _RAIter3 __target,\n-      _DifferenceTp __length, _Compare __comp)\n+  multiway_merge_3_variant(_RAIterIterator __seqs_begin,\n+\t\t\t   _RAIterIterator __seqs_end,\n+\t\t\t   _RAIter3 __target,\n+\t\t\t   _DifferenceTp __length, _Compare __comp)\n   {\n     _GLIBCXX_CALL(__length);\n \n@@ -612,15 +555,14 @@ template<typename _LT,\n \t typename _RAIter3,\n \t typename _DifferenceTp, typename _Compare>\n   _RAIter3\n-  multiway_merge_loser_tree_unguarded(\n-    _RAIterIterator __seqs_begin,\n-    _RAIterIterator __seqs_end,\n-    _RAIter3 __target,\n-    const typename std::iterator_traits<typename std::iterator_traits<\n-      _RAIterIterator>::value_type::first_type>::value_type&\n-        __sentinel,\n-    _DifferenceTp __length,\n-    _Compare __comp)\n+  multiway_merge_loser_tree_unguarded(_RAIterIterator __seqs_begin,\n+\t\t\t\t      _RAIterIterator __seqs_end,\n+\t\t\t\t      _RAIter3 __target,\n+     const typename std::iterator_traits<typename std::iterator_traits<\n+\t_RAIterIterator>::value_type::first_type>::value_type&\n+\t\t\t\t      __sentinel,\n+\t\t\t\t      _DifferenceTp __length,\n+\t\t\t\t      _Compare __comp)\n   {\n     _GLIBCXX_CALL(__length)\n     typedef _DifferenceTp _DifferenceType;\n@@ -702,15 +644,14 @@ template<typename UnguardedLoserTree,\n \t typename _DifferenceTp,\n \t typename _Compare>\n   _RAIter3\n-  multiway_merge_loser_tree_sentinel(\n-    _RAIterIterator __seqs_begin,\n-    _RAIterIterator __seqs_end,\n-    _RAIter3 __target,\n+  multiway_merge_loser_tree_sentinel(_RAIterIterator __seqs_begin,\n+\t\t\t\t     _RAIterIterator __seqs_end,\n+\t\t\t\t     _RAIter3 __target,\n     const typename std::iterator_traits<typename std::iterator_traits<\n       _RAIterIterator>::value_type::first_type>::value_type&\n-        __sentinel,\n-    _DifferenceTp __length,\n-    _Compare __comp)\n+\t\t\t\t     __sentinel,\n+\t\t\t\t     _DifferenceTp __length,\n+\t\t\t\t     _Compare __comp)\n   {\n     _GLIBCXX_CALL(__length)\n \n@@ -773,16 +714,16 @@ template<typename UnguardedLoserTree,\n  * @param _Tp type to give the loser tree traits for.\n  */\n template <typename _Tp>\n-struct _LoserTreeTraits\n-{\n-  /**\n-   * @brief True iff to use pointers instead of values in loser trees.\n-   *\n-   * The default behavior is to use pointers if the data type is four\n-   * times as big as the pointer to it.\n-   */\n-  static const bool _M_use_pointer = (sizeof(_Tp) > 4 * sizeof(_Tp*));\n-};\n+  struct _LoserTreeTraits\n+  {\n+    /**\n+     * @brief True iff to use pointers instead of values in loser trees.\n+     *\n+     * The default behavior is to use pointers if the data type is four\n+     * times as big as the pointer to it.\n+     */\n+    static const bool _M_use_pointer = (sizeof(_Tp) > 4 * sizeof(_Tp*));\n+  };\n \n /**\n  * @brief Switch for 3-way merging with __sentinels turned off.\n@@ -796,10 +737,11 @@ template<bool __sentinels /*default == false*/,\n \t typename _Compare>\n   struct __multiway_merge_3_variant_sentinel_switch\n   {\n-    _RAIter3 operator()(_RAIterIterator __seqs_begin,\n-\t\t\t_RAIterIterator __seqs_end,\n-\t\t\t_RAIter3 __target,\n-\t\t\t_DifferenceTp __length, _Compare __comp)\n+    _RAIter3\n+    operator()(_RAIterIterator __seqs_begin,\n+\t       _RAIterIterator __seqs_end,\n+\t       _RAIter3 __target,\n+\t       _DifferenceTp __length, _Compare __comp)\n     {\n       return multiway_merge_3_variant<_GuardedIterator>\n \t(__seqs_begin, __seqs_end, __target, __length, __comp);\n@@ -815,13 +757,15 @@ template<typename _RAIterIterator,\n \t typename _RAIter3,\n \t typename _DifferenceTp,\n \t typename _Compare>\n-  struct __multiway_merge_3_variant_sentinel_switch\n-         <true, _RAIterIterator, _RAIter3, _DifferenceTp, _Compare>\n+  struct __multiway_merge_3_variant_sentinel_switch<true, _RAIterIterator,\n+\t\t\t\t\t\t    _RAIter3, _DifferenceTp,\n+\t\t\t\t\t\t    _Compare>\n   {\n-    _RAIter3 operator()(_RAIterIterator __seqs_begin,\n-\t\t\t_RAIterIterator __seqs_end,\n-\t\t\t_RAIter3 __target,\n-\t\t\t_DifferenceTp __length, _Compare __comp)\n+    _RAIter3\n+    operator()(_RAIterIterator __seqs_begin,\n+\t       _RAIterIterator __seqs_end,\n+\t       _RAIter3 __target,\n+\t       _DifferenceTp __length, _Compare __comp)\n     {\n       return multiway_merge_3_variant<_UnguardedIterator>\n \t(__seqs_begin, __seqs_end, __target, __length, __comp);\n@@ -840,10 +784,11 @@ template<bool __sentinels /*default == false*/,\n \t typename _Compare>\n   struct __multiway_merge_4_variant_sentinel_switch\n   {\n-    _RAIter3 operator()(_RAIterIterator __seqs_begin,\n-\t\t\t_RAIterIterator __seqs_end,\n-\t\t\t_RAIter3 __target,\n-\t\t\t_DifferenceTp __length, _Compare __comp)\n+    _RAIter3\n+    operator()(_RAIterIterator __seqs_begin,\n+\t       _RAIterIterator __seqs_end,\n+\t       _RAIter3 __target,\n+\t       _DifferenceTp __length, _Compare __comp)\n     {\n       return multiway_merge_4_variant<_GuardedIterator>\n \t(__seqs_begin, __seqs_end, __target, __length, __comp);\n@@ -859,13 +804,15 @@ template<typename _RAIterIterator,\n \t typename _RAIter3,\n \t typename _DifferenceTp,\n \t typename _Compare>\n-  struct __multiway_merge_4_variant_sentinel_switch\n-    <true, _RAIterIterator, _RAIter3, _DifferenceTp, _Compare>\n+  struct __multiway_merge_4_variant_sentinel_switch<true, _RAIterIterator,\n+\t\t\t\t\t\t    _RAIter3, _DifferenceTp,\n+\t\t\t\t\t\t    _Compare>\n   {\n-    _RAIter3 operator()(_RAIterIterator __seqs_begin,\n-\t\t\t_RAIterIterator __seqs_end,\n-\t\t\t_RAIter3 __target,\n-\t\t\t_DifferenceTp __length, _Compare __comp)\n+    _RAIter3\n+    operator()(_RAIterIterator __seqs_begin,\n+\t       _RAIterIterator __seqs_end,\n+\t       _RAIter3 __target,\n+\t       _DifferenceTp __length, _Compare __comp)\n     {\n       return multiway_merge_4_variant<_UnguardedIterator>\n \t(__seqs_begin, __seqs_end, __target, __length, __comp);\n@@ -882,30 +829,30 @@ template<bool __sentinels,\n \t typename _DifferenceTp,\n \t typename _Compare>\n   struct __multiway_merge_k_variant_sentinel_switch\n-   {\n-     _RAIter3 operator()\n-     (_RAIterIterator __seqs_begin,\n-      _RAIterIterator __seqs_end,\n-      _RAIter3 __target,\n-      const typename std::iterator_traits<typename std::iterator_traits<\n-      _RAIterIterator>::value_type::first_type>::value_type&\n-      __sentinel,\n-      _DifferenceTp __length, _Compare __comp)\n-     {\n-       typedef typename std::iterator_traits<_RAIterIterator>\n-\t ::value_type::first_type\n-\t _RAIter1;\n-       typedef typename std::iterator_traits<_RAIter1>::value_type\n-\t _ValueType;\n-\n-       return multiway_merge_loser_tree_sentinel<\n-       typename __gnu_cxx::__conditional_type<\n-       _LoserTreeTraits<_ValueType>::_M_use_pointer,\n-\t _LoserTreePointerUnguarded<__stable, _ValueType, _Compare>,\n-\t _LoserTreeUnguarded<__stable, _ValueType, _Compare>\n-        >::__type>(\n-            __seqs_begin, __seqs_end, __target, __sentinel, __length, __comp);\n-     }\n+  {\n+    _RAIter3\n+    operator()(_RAIterIterator __seqs_begin,\n+\t       _RAIterIterator __seqs_end,\n+\t       _RAIter3 __target,\n+    const typename std::iterator_traits<typename std::iterator_traits<\n+    _RAIterIterator>::value_type::first_type>::value_type&\n+\t       __sentinel,\n+\t       _DifferenceTp __length, _Compare __comp)\n+    {\n+      typedef typename std::iterator_traits<_RAIterIterator>\n+\t::value_type::first_type\n+\t_RAIter1;\n+      typedef typename std::iterator_traits<_RAIter1>::value_type\n+\t_ValueType;\n+\n+      return multiway_merge_loser_tree_sentinel<\n+      typename __gnu_cxx::__conditional_type<\n+      _LoserTreeTraits<_ValueType>::_M_use_pointer,\n+\t_LoserTreePointerUnguarded<__stable, _ValueType, _Compare>,\n+\t_LoserTreeUnguarded<__stable, _ValueType, _Compare>\n+        >::__type>\n+\t(__seqs_begin, __seqs_end, __target, __sentinel, __length, __comp);\n+    }\n   };\n \n /**\n@@ -916,17 +863,18 @@ template<bool __stable,\n \t typename _RAIter3,\n \t typename _DifferenceTp,\n \t typename _Compare>\n-  struct __multiway_merge_k_variant_sentinel_switch\n-         <false, __stable, _RAIterIterator, _RAIter3, _DifferenceTp, _Compare>\n+  struct __multiway_merge_k_variant_sentinel_switch<false, __stable,\n+\t\t\t\t\t\t    _RAIterIterator, _RAIter3,\n+\t\t\t\t\t\t    _DifferenceTp, _Compare>\n   {\n-    _RAIter3 operator()\n-    (_RAIterIterator __seqs_begin,\n-     _RAIterIterator __seqs_end,\n-     _RAIter3 __target,\n+    _RAIter3\n+    operator()(_RAIterIterator __seqs_begin,\n+\t       _RAIterIterator __seqs_end,\n+\t       _RAIter3 __target,\n      const typename std::iterator_traits<typename std::iterator_traits<\n      _RAIterIterator>::value_type::first_type>::value_type&\n-     __sentinel,\n-     _DifferenceTp __length, _Compare __comp)\n+\t       __sentinel,\n+\t       _DifferenceTp __length, _Compare __comp)\n     {\n       typedef typename std::iterator_traits<_RAIterIterator>\n \t::value_type::first_type\n@@ -963,14 +911,13 @@ template<bool __stable,\n \t typename _DifferenceTp,\n \t typename _Compare>\n   _RAIter3\n-  __sequential_multiway_merge(\n-    _RAIterIterator __seqs_begin,\n-    _RAIterIterator __seqs_end,\n-    _RAIter3 __target,\n+  __sequential_multiway_merge(_RAIterIterator __seqs_begin,\n+\t\t\t      _RAIterIterator __seqs_end,\n+\t\t\t      _RAIter3 __target,\n     const typename std::iterator_traits<typename std::iterator_traits<\n       _RAIterIterator>::value_type::first_type>::value_type&\n-        __sentinel,\n-    _DifferenceTp __length, _Compare __comp)\n+\t\t\t      __sentinel,\n+\t\t\t      _DifferenceTp __length, _Compare __comp)\n   {\n     _GLIBCXX_CALL(__length)\n \n@@ -1061,8 +1008,8 @@ template<bool __stable,\n template<bool __stable, class _RAIter, class _StrictWeakOrdering>\n   struct _SamplingSorter\n   {\n-    void operator()(_RAIter __first, _RAIter __last,\n-\t\t    _StrictWeakOrdering __comp)\n+    void\n+    operator()(_RAIter __first, _RAIter __last, _StrictWeakOrdering __comp)\n     { __gnu_sequential::stable_sort(__first, __last, __comp); }\n   };\n \n@@ -1074,8 +1021,8 @@ template<bool __stable, class _RAIter, class _StrictWeakOrdering>\n template<class _RAIter, class _StrictWeakOrdering>\n   struct _SamplingSorter<false, _RAIter, _StrictWeakOrdering>\n   {\n-    void operator()(_RAIter __first, _RAIter __last,\n-\t\t    _StrictWeakOrdering __comp)\n+    void\n+    operator()(_RAIter __first, _RAIter __last, _StrictWeakOrdering __comp)\n     { __gnu_sequential::sort(__first, __last, __comp); }\n   };\n \n@@ -1087,10 +1034,11 @@ template<bool __stable,\n \t typename _Compare,\n \t typename _DifferenceType>\n   void\n-  multiway_merge_sampling_splitting\n-  (_RAIterIterator __seqs_begin,\n-   _RAIterIterator __seqs_end,\n-   _DifferenceType __length, _DifferenceType __total_length, _Compare __comp,\n+  multiway_merge_sampling_splitting(_RAIterIterator __seqs_begin,\n+\t\t\t\t    _RAIterIterator __seqs_end,\n+\t\t\t\t    _DifferenceType __length,\n+\t\t\t\t    _DifferenceType __total_length,\n+\t\t\t\t    _Compare __comp,\n    std::vector<std::pair<_DifferenceType, _DifferenceType> > *__pieces)\n   {\n     typedef typename std::iterator_traits<_RAIterIterator>\n@@ -1168,11 +1116,11 @@ template<bool __stable,\n \t typename _Compare,\n \t typename _DifferenceType>\n   void\n-  multiway_merge_exact_splitting\n-    (_RAIterIterator __seqs_begin,\n-     _RAIterIterator __seqs_end,\n-     _DifferenceType __length, _DifferenceType __total_length,\n-     _Compare __comp,\n+  multiway_merge_exact_splitting(_RAIterIterator __seqs_begin,\n+\t\t\t\t _RAIterIterator __seqs_end,\n+\t\t\t\t _DifferenceType __length,\n+\t\t\t\t _DifferenceType __total_length,\n+\t\t\t\t _Compare __comp,\n      std::vector<std::pair<_DifferenceType, _DifferenceType> > *__pieces)\n   {\n     typedef typename std::iterator_traits<_RAIterIterator>"}, {"sha": "3b047b40815a9a8b1cb84d6995b6ee2f5caa5720", "filename": "libstdc++-v3/include/parallel/multiway_mergesort.h", "status": "modified", "additions": 362, "deletions": 369, "changes": 731, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338311e5d77550d5eba3b760c3db517de7a93016/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338311e5d77550d5eba3b760c3db517de7a93016/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h?ref=338311e5d77550d5eba3b760c3db517de7a93016", "patch": "@@ -41,451 +41,444 @@\n \n namespace __gnu_parallel\n {\n+  /** @brief Subsequence description. */\n+  template<typename _DifferenceTp>\n+    struct _Piece\n+    {\n+      typedef _DifferenceTp _DifferenceType;\n \n-/** @brief Subsequence description. */\n-template<typename _DifferenceTp>\n-  struct _Piece\n-  {\n-    typedef _DifferenceTp _DifferenceType;\n+      /** @brief Begin of subsequence. */\n+      _DifferenceType _M_begin;\n \n-    /** @brief Begin of subsequence. */\n-    _DifferenceType _M_begin;\n+      /** @brief End of subsequence. */\n+      _DifferenceType _M_end;\n+    };\n \n-    /** @brief End of subsequence. */\n-    _DifferenceType _M_end;\n-  };\n+  /** @brief Data accessed by all threads.\n+   *\n+   *  PMWMS = parallel multiway mergesort */\n+  template<typename _RAIter>\n+    struct _PMWMSSortingData\n+    {\n+      typedef std::iterator_traits<_RAIter> _TraitsType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n \n-/** @brief Data accessed by all threads.\n-  *\n-  *  PMWMS = parallel multiway mergesort */\n-template<typename _RAIter>\n-  struct _PMWMSSortingData\n-  {\n-    typedef std::iterator_traits<_RAIter> _TraitsType;\n-    typedef typename _TraitsType::value_type _ValueType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-\n-    /** @brief Number of threads involved. */\n-    _ThreadIndex _M_num_threads;\n-\n-    /** @brief Input __begin. */\n-    _RAIter _M_source;\n-\n-    /** @brief Start indices, per thread. */\n-    _DifferenceType* _M_starts;\n-\n-    /** @brief Storage in which to sort. */\n-    _ValueType** _M_temporary;\n-\n-    /** @brief Samples. */\n-    _ValueType* _M_samples;\n-\n-    /** @brief Offsets to add to the found positions. */\n-    _DifferenceType* _M_offsets;\n-\n-    /** @brief Pieces of data to merge @__c [thread][__sequence] */\n-    std::vector<_Piece<_DifferenceType> >* _M_pieces;\n-};\n-\n-/**\n-  *  @brief Select _M_samples from a sequence.\n-  *  @param __sd Pointer to algorithm data. _Result will be placed in\n-  *  @__c __sd->_M_samples.\n-  *  @param __num_samples Number of _M_samples to select.\n-  */\n-template<typename _RAIter, typename _DifferenceTp>\n-  void \n-  __determine_samples(_PMWMSSortingData<_RAIter>* __sd,\n-                    _DifferenceTp __num_samples)\n-  {\n-    typedef std::iterator_traits<_RAIter> _TraitsType;\n-    typedef typename _TraitsType::value_type _ValueType;\n-    typedef _DifferenceTp _DifferenceType;\n-\n-    _ThreadIndex __iam = omp_get_thread_num();\n-\n-    _DifferenceType* __es = new _DifferenceType[__num_samples + 2];\n-\n-    equally_split(__sd->_M_starts[__iam + 1] - __sd->_M_starts[__iam], \n-                  __num_samples + 1, __es);\n-\n-    for (_DifferenceType __i = 0; __i < __num_samples; ++__i)\n-      ::new(&(__sd->_M_samples[__iam * __num_samples + __i]))\n-          _ValueType(__sd->_M_source[__sd->_M_starts[__iam] + __es[__i + 1]]);\n-\n-    delete[] __es;\n-  }\n-\n-/** @brief Split consistently. */\n-template<bool __exact, typename _RAIter,\n-          typename _Compare, typename _SortingPlacesIterator>\n-  struct _SplitConsistently\n-  {\n-  };\n+      /** @brief Number of threads involved. */\n+      _ThreadIndex _M_num_threads;\n \n-/** @brief Split by exact splitting. */\n-template<typename _RAIter, typename _Compare,\n-          typename _SortingPlacesIterator>\n-  struct _SplitConsistently\n-    <true, _RAIter, _Compare, _SortingPlacesIterator>\n-  {\n-    void operator()(\n-      const _ThreadIndex __iam,\n-      _PMWMSSortingData<_RAIter>* __sd,\n-      _Compare& __comp,\n-      const typename\n-        std::iterator_traits<_RAIter>::difference_type\n-          __num_samples)\n-      const\n-  {\n-#   pragma omp barrier\n-\n-    std::vector<std::pair<_SortingPlacesIterator, _SortingPlacesIterator> >\n-        seqs(__sd->_M_num_threads);\n-    for (_ThreadIndex __s = 0; __s < __sd->_M_num_threads; __s++)\n-      seqs[__s] = std::make_pair(__sd->_M_temporary[__s],\n-                                 __sd->_M_temporary[__s]\n-                                 + (__sd->_M_starts[__s + 1]\n-                                 - __sd->_M_starts[__s]));\n-\n-    std::vector<_SortingPlacesIterator> _M_offsets(__sd->_M_num_threads);\n-\n-    // if not last thread\n-    if (__iam < __sd->_M_num_threads - 1)\n-      multiseq_partition(seqs.begin(), seqs.end(),\n-                         __sd->_M_starts[__iam + 1], _M_offsets.begin(),\n-                         __comp);\n-\n-    for (int __seq = 0; __seq < __sd->_M_num_threads; __seq++)\n-      {\n-        // for each sequence\n-        if (__iam < (__sd->_M_num_threads - 1))\n-          __sd->_M_pieces[__iam][__seq]._M_end\n-            = _M_offsets[__seq] - seqs[__seq].first;\n-        else\n-          // very end of this sequence\n-          __sd->_M_pieces[__iam][__seq]._M_end =\n-            __sd->_M_starts[__seq + 1] - __sd->_M_starts[__seq];\n-      }\n+      /** @brief Input __begin. */\n+      _RAIter _M_source;\n \n-#   pragma omp barrier\n+      /** @brief Start indices, per thread. */\n+      _DifferenceType* _M_starts;\n \n-    for (_ThreadIndex __seq = 0; __seq < __sd->_M_num_threads; __seq++)\n-      {\n-        // For each sequence.\n-        if (__iam > 0)\n-          __sd->_M_pieces[__iam][__seq]._M_begin =\n-            __sd->_M_pieces[__iam - 1][__seq]._M_end;\n-        else\n-          // Absolute beginning.\n-          __sd->_M_pieces[__iam][__seq]._M_begin = 0;\n-      }\n-  }   \n+      /** @brief Storage in which to sort. */\n+      _ValueType** _M_temporary;\n+\n+      /** @brief Samples. */\n+      _ValueType* _M_samples;\n+\n+      /** @brief Offsets to add to the found positions. */\n+      _DifferenceType* _M_offsets;\n+\n+      /** @brief Pieces of data to merge @__c [thread][__sequence] */\n+      std::vector<_Piece<_DifferenceType> >* _M_pieces;\n   };\n \n-/** @brief Split by sampling. */ \n-template<typename _RAIter, typename _Compare,\n-          typename _SortingPlacesIterator>\n-  struct _SplitConsistently<false, _RAIter, _Compare,\n-                             _SortingPlacesIterator>\n-  {\n-    void operator()(\n-        const _ThreadIndex __iam,\n-        _PMWMSSortingData<_RAIter>* __sd,\n-        _Compare& __comp,\n-        const typename\n-          std::iterator_traits<_RAIter>::difference_type\n-            __num_samples)\n-        const\n+  /**\n+   *  @brief Select _M_samples from a sequence.\n+   *  @param __sd Pointer to algorithm data. _Result will be placed in\n+   *  @__c __sd->_M_samples.\n+   *  @param __num_samples Number of _M_samples to select.\n+   */\n+  template<typename _RAIter, typename _DifferenceTp>\n+    void\n+    __determine_samples(_PMWMSSortingData<_RAIter>* __sd,\n+\t\t\t_DifferenceTp __num_samples)\n     {\n       typedef std::iterator_traits<_RAIter> _TraitsType;\n       typedef typename _TraitsType::value_type _ValueType;\n-      typedef typename _TraitsType::difference_type _DifferenceType;\n+      typedef _DifferenceTp _DifferenceType;\n \n-      __determine_samples(__sd, __num_samples);\n+      _ThreadIndex __iam = omp_get_thread_num();\n \n-#     pragma omp barrier\n+      _DifferenceType* __es = new _DifferenceType[__num_samples + 2];\n \n-#     pragma omp single\n-      __gnu_sequential::sort(__sd->_M_samples,\n-                             __sd->_M_samples\n-                                + (__num_samples * __sd->_M_num_threads),\n-                             __comp);\n+      equally_split(__sd->_M_starts[__iam + 1] - __sd->_M_starts[__iam], \n+\t\t    __num_samples + 1, __es);\n \n-#     pragma omp barrier\n+      for (_DifferenceType __i = 0; __i < __num_samples; ++__i)\n+\t::new(&(__sd->_M_samples[__iam * __num_samples + __i]))\n+\t    _ValueType(__sd->_M_source[__sd->_M_starts[__iam]\n+\t\t\t\t       + __es[__i + 1]]);\n+\n+      delete[] __es;\n+    }\n \n-      for (_ThreadIndex __s = 0; __s < __sd->_M_num_threads; ++__s)\n-        {\n-          // For each sequence.\n-          if (__num_samples * __iam > 0)\n-            __sd->_M_pieces[__iam][__s]._M_begin =\n+  /** @brief Split consistently. */\n+  template<bool __exact, typename _RAIter,\n+\t   typename _Compare, typename _SortingPlacesIterator>\n+    struct _SplitConsistently\n+    { };\n+\n+  /** @brief Split by exact splitting. */\n+  template<typename _RAIter, typename _Compare,\n+\t   typename _SortingPlacesIterator>\n+    struct _SplitConsistently<true, _RAIter,\n+\t\t\t      _Compare, _SortingPlacesIterator>\n+    {\n+      void\n+      operator()(const _ThreadIndex __iam,\n+\t\t _PMWMSSortingData<_RAIter>* __sd,\n+\t\t _Compare& __comp,\n+\t\t const typename\n+\t\t std::iterator_traits<_RAIter>::difference_type\n+\t\t __num_samples) const\n+      {\n+#       pragma omp barrier\n+\n+\tstd::vector<std::pair<_SortingPlacesIterator,\n+\t                      _SortingPlacesIterator> >\n+\t  seqs(__sd->_M_num_threads);\n+\tfor (_ThreadIndex __s = 0; __s < __sd->_M_num_threads; __s++)\n+\t  seqs[__s] = std::make_pair(__sd->_M_temporary[__s],\n+\t\t\t\t     __sd->_M_temporary[__s]\n+\t\t\t\t     + (__sd->_M_starts[__s + 1]\n+\t\t\t\t\t- __sd->_M_starts[__s]));\n+\n+\tstd::vector<_SortingPlacesIterator> _M_offsets(__sd->_M_num_threads);\n+\n+\t// if not last thread\n+\tif (__iam < __sd->_M_num_threads - 1)\n+\t  multiseq_partition(seqs.begin(), seqs.end(),\n+\t\t\t     __sd->_M_starts[__iam + 1], _M_offsets.begin(),\n+\t\t\t     __comp);\n+\n+\tfor (int __seq = 0; __seq < __sd->_M_num_threads; __seq++)\n+\t  {\n+\t    // for each sequence\n+\t    if (__iam < (__sd->_M_num_threads - 1))\n+\t      __sd->_M_pieces[__iam][__seq]._M_end\n+\t\t= _M_offsets[__seq] - seqs[__seq].first;\n+\t    else\n+\t      // very end of this sequence\n+\t      __sd->_M_pieces[__iam][__seq]._M_end =\n+\t\t__sd->_M_starts[__seq + 1] - __sd->_M_starts[__seq];\n+\t  }\n+\n+#       pragma omp barrier\n+\n+\tfor (_ThreadIndex __seq = 0; __seq < __sd->_M_num_threads; __seq++)\n+\t  {\n+\t    // For each sequence.\n+\t    if (__iam > 0)\n+\t      __sd->_M_pieces[__iam][__seq]._M_begin =\n+\t\t__sd->_M_pieces[__iam - 1][__seq]._M_end;\n+\t    else\n+\t      // Absolute beginning.\n+\t      __sd->_M_pieces[__iam][__seq]._M_begin = 0;\n+\t  }\n+      }\n+  };\n+\n+  /** @brief Split by sampling. */ \n+  template<typename _RAIter, typename _Compare,\n+\t   typename _SortingPlacesIterator>\n+    struct _SplitConsistently<false, _RAIter, _Compare,\n+\t\t\t      _SortingPlacesIterator>\n+    {\n+      void\n+      operator()(const _ThreadIndex __iam,\n+\t\t _PMWMSSortingData<_RAIter>* __sd,\n+\t\t _Compare& __comp,\n+\t\t const typename\n+\t\t std::iterator_traits<_RAIter>::difference_type\n+\t\t __num_samples) const\n+      {\n+\ttypedef std::iterator_traits<_RAIter> _TraitsType;\n+\ttypedef typename _TraitsType::value_type _ValueType;\n+\ttypedef typename _TraitsType::difference_type _DifferenceType;\n+\n+\t__determine_samples(__sd, __num_samples);\n+\n+#       pragma omp barrier\n+\n+#       pragma omp single\n+\t__gnu_sequential::sort(__sd->_M_samples,\n+\t\t\t       __sd->_M_samples\n+\t\t\t       + (__num_samples * __sd->_M_num_threads),\n+\t\t\t       __comp);\n+\n+#       pragma omp barrier\n+\n+\tfor (_ThreadIndex __s = 0; __s < __sd->_M_num_threads; ++__s)\n+\t  {\n+\t    // For each sequence.\n+\t    if (__num_samples * __iam > 0)\n+\t      __sd->_M_pieces[__iam][__s]._M_begin =\n                 std::lower_bound(__sd->_M_temporary[__s],\n-                    __sd->_M_temporary[__s]\n-                        + (__sd->_M_starts[__s + 1] - __sd->_M_starts[__s]),\n-                    __sd->_M_samples[__num_samples * __iam],\n-                    __comp)\n+\t\t\t\t __sd->_M_temporary[__s]\n+\t\t\t\t + (__sd->_M_starts[__s + 1]\n+\t\t\t\t    - __sd->_M_starts[__s]),\n+\t\t\t\t __sd->_M_samples[__num_samples * __iam],\n+\t\t\t\t __comp)\n                 - __sd->_M_temporary[__s];\n-          else\n-            // Absolute beginning.\n-            __sd->_M_pieces[__iam][__s]._M_begin = 0;\n+\t    else\n+\t      // Absolute beginning.\n+\t      __sd->_M_pieces[__iam][__s]._M_begin = 0;\n \n-          if ((__num_samples * (__iam + 1)) <\n-                         (__num_samples * __sd->_M_num_threads))\n-            __sd->_M_pieces[__iam][__s]._M_end =\n+\t    if ((__num_samples * (__iam + 1)) <\n+\t\t(__num_samples * __sd->_M_num_threads))\n+\t      __sd->_M_pieces[__iam][__s]._M_end =\n                 std::lower_bound(__sd->_M_temporary[__s],\n-                        __sd->_M_temporary[__s]\n-                          + (__sd->_M_starts[__s + 1] - __sd->_M_starts[__s]),\n-                        __sd->_M_samples[__num_samples * (__iam + 1)],\n-                        __comp)\n+\t\t\t\t __sd->_M_temporary[__s]\n+\t\t\t\t + (__sd->_M_starts[__s + 1]\n+\t\t\t\t    - __sd->_M_starts[__s]),\n+\t\t\t\t __sd->_M_samples[__num_samples * (__iam + 1)],\n+\t\t\t\t __comp)\n                 - __sd->_M_temporary[__s];\n-          else\n-            // Absolute end.\n-            __sd->_M_pieces[__iam][__s]._M_end = __sd->_M_starts[__s + 1]\n-                                                 - __sd->_M_starts[__s];\n-        }\n-    }\n+\t    else\n+\t      // Absolute end.\n+\t      __sd->_M_pieces[__iam][__s]._M_end = (__sd->_M_starts[__s + 1]\n+\t\t\t\t\t\t    - __sd->_M_starts[__s]);\n+\t  }\n+      }\n   };\n   \n-template<bool __stable, typename _RAIter, typename _Compare>\n-  struct __possibly_stable_sort\n-  {\n-  };\n+  template<bool __stable, typename _RAIter, typename _Compare>\n+    struct __possibly_stable_sort\n+    { };\n \n-template<typename _RAIter, typename _Compare>\n-  struct __possibly_stable_sort<true, _RAIter, _Compare>\n-  {\n-    void operator()(const _RAIter& __begin,\n-                     const _RAIter& __end, _Compare& __comp) const\n+  template<typename _RAIter, typename _Compare>\n+    struct __possibly_stable_sort<true, _RAIter, _Compare>\n     {\n-      __gnu_sequential::stable_sort(__begin, __end, __comp); \n-    }\n-  };\n+      void operator()(const _RAIter& __begin,\n+\t\t      const _RAIter& __end, _Compare& __comp) const\n+      { __gnu_sequential::stable_sort(__begin, __end, __comp); }\n+    };\n \n-template<typename _RAIter, typename _Compare>\n-  struct __possibly_stable_sort<false, _RAIter, _Compare>\n-  {\n-    void operator()(const _RAIter __begin,\n-                     const _RAIter __end, _Compare& __comp) const\n+  template<typename _RAIter, typename _Compare>\n+    struct __possibly_stable_sort<false, _RAIter, _Compare>\n     {\n-      __gnu_sequential::sort(__begin, __end, __comp); \n-    }\n-  };\n-\n-template<bool __stable, typename Seq_RAIter,\n-          typename _RAIter, typename _Compare,\n-          typename DiffType>\n-  struct __possibly_stable_multiway_merge\n-  {\n-  };\n-\n-template<typename Seq_RAIter, typename _RAIter,\n-          typename _Compare, typename DiffType>\n-  struct __possibly_stable_multiway_merge\n-    <true, Seq_RAIter, _RAIter, _Compare,\n-    DiffType>\n-  {\n-    void operator()(const Seq_RAIter& __seqs_begin,\n-                      const Seq_RAIter& __seqs_end,\n-                      const _RAIter& __target,\n-                      _Compare& __comp,\n-                      DiffType __length_am) const\n+      void operator()(const _RAIter __begin,\n+\t\t      const _RAIter __end, _Compare& __comp) const\n+      { __gnu_sequential::sort(__begin, __end, __comp); }\n+    };\n+\n+  template<bool __stable, typename Seq_RAIter,\n+\t   typename _RAIter, typename _Compare,\n+\t   typename DiffType>\n+    struct __possibly_stable_multiway_merge\n+    { };\n+\n+  template<typename Seq_RAIter, typename _RAIter,\n+\t   typename _Compare, typename _DiffType>\n+    struct __possibly_stable_multiway_merge<true, Seq_RAIter,\n+\t\t\t\t\t    _RAIter, _Compare, _DiffType>\n     {\n-      stable_multiway_merge(__seqs_begin, __seqs_end, __target, __length_am,\n-                            __comp, sequential_tag());\n-    }\n-  };\n+      void operator()(const Seq_RAIter& __seqs_begin,\n+\t\t      const Seq_RAIter& __seqs_end,\n+\t\t      const _RAIter& __target,\n+\t\t      _Compare& __comp,\n+\t\t      _DiffType __length_am) const\n+      {\n+\tstable_multiway_merge(__seqs_begin, __seqs_end, __target, __length_am,\n+\t\t\t      __comp, sequential_tag());\n+      }\n+    };\n \n-template<typename Seq_RAIter, typename _RAIter,\n-          typename _Compare, typename DiffType>\n-  struct __possibly_stable_multiway_merge\n-    <false, Seq_RAIter, _RAIter, _Compare,\n-    DiffType>\n-  {\n-    void operator()(const Seq_RAIter& __seqs_begin,\n+  template<typename Seq_RAIter, typename _RAIter,\n+\t   typename _Compare, typename _DiffType>\n+    struct __possibly_stable_multiway_merge<false, Seq_RAIter,\n+\t\t\t\t\t    _RAIter, _Compare, _DiffType>\n+    {\n+      void operator()(const Seq_RAIter& __seqs_begin,\n                       const Seq_RAIter& __seqs_end,\n                       const _RAIter& __target,\n                       _Compare& __comp,\n-                      DiffType __length_am) const\n-    {\n-      multiway_merge(__seqs_begin, __seqs_end, __target, __length_am, __comp,\n+                      _DiffType __length_am) const\n+      {\n+\tmultiway_merge(__seqs_begin, __seqs_end, __target, __length_am, __comp,\n                        sequential_tag());\n-    }\n-  };\n+      }\n+    };\n+\n+  /** @brief PMWMS code executed by each thread.\n+   *  @param __sd Pointer to algorithm data.\n+   *  @param __comp Comparator.\n+   */\n+  template<bool __stable, bool __exact, typename _RAIter,\n+\t   typename _Compare>\n+    void\n+    parallel_sort_mwms_pu(_PMWMSSortingData<_RAIter>* __sd,\n+\t\t\t  _Compare& __comp)\n+    {\n+      typedef std::iterator_traits<_RAIter> _TraitsType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n \n-/** @brief PMWMS code executed by each thread.\n-  *  @param __sd Pointer to algorithm data.\n-  *  @param __comp Comparator.\n-  */\n-template<bool __stable, bool __exact, typename _RAIter,\n-          typename _Compare>\n-  void \n-  parallel_sort_mwms_pu(_PMWMSSortingData<_RAIter>* __sd,\n-                        _Compare& __comp)\n-  {\n-    typedef std::iterator_traits<_RAIter> _TraitsType;\n-    typedef typename _TraitsType::value_type _ValueType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-\n-    _ThreadIndex __iam = omp_get_thread_num();\n-\n-    // Length of this thread's chunk, before merging.\n-    _DifferenceType __length_local\n-                        = __sd->_M_starts[__iam + 1] - __sd->_M_starts[__iam];\n-\n-    // Sort in temporary storage, leave space for sentinel.\n-\n-    typedef _ValueType* _SortingPlacesIterator;\n-\n-    __sd->_M_temporary[__iam] =\n-        static_cast<_ValueType*>(\n-        ::operator new(sizeof(_ValueType) * (__length_local + 1)));\n-\n-    // Copy there.\n-    std::uninitialized_copy(\n-                __sd->_M_source + __sd->_M_starts[__iam],\n-                __sd->_M_source + __sd->_M_starts[__iam] + __length_local,\n-                __sd->_M_temporary[__iam]);\n-\n-    __possibly_stable_sort<__stable, _SortingPlacesIterator, _Compare>()\n+      _ThreadIndex __iam = omp_get_thread_num();\n+\n+      // Length of this thread's chunk, before merging.\n+      _DifferenceType __length_local\n+\t= __sd->_M_starts[__iam + 1] - __sd->_M_starts[__iam];\n+\n+      // Sort in temporary storage, leave space for sentinel.\n+\n+      typedef _ValueType* _SortingPlacesIterator;\n+\n+      __sd->_M_temporary[__iam] =\n+        static_cast<_ValueType*>(::operator new(sizeof(_ValueType)\n+\t\t\t\t\t\t* (__length_local + 1)));\n+\n+      // Copy there.\n+      std::uninitialized_copy(__sd->_M_source + __sd->_M_starts[__iam],\n+\t\t\t      __sd->_M_source + __sd->_M_starts[__iam]\n+\t\t\t      + __length_local,\n+\t\t\t      __sd->_M_temporary[__iam]);\n+\n+      __possibly_stable_sort<__stable, _SortingPlacesIterator, _Compare>()\n         (__sd->_M_temporary[__iam],\n-         __sd->_M_temporary[__iam] + __length_local,\n+\t __sd->_M_temporary[__iam] + __length_local,\n          __comp);\n \n-    // Invariant: locally sorted subsequence in sd->_M_temporary[__iam],\n-    // __sd->_M_temporary[__iam] + __length_local.\n+      // Invariant: locally sorted subsequence in sd->_M_temporary[__iam],\n+      // __sd->_M_temporary[__iam] + __length_local.\n \n-    // No barrier here: Synchronization is done by the splitting routine.\n+      // No barrier here: Synchronization is done by the splitting routine.\n \n-    _DifferenceType __num_samples =\n+      _DifferenceType __num_samples =\n         _Settings::get().sort_mwms_oversampling * __sd->_M_num_threads - 1;\n-    _SplitConsistently\n-      <__exact, _RAIter, _Compare, _SortingPlacesIterator>()\n+      _SplitConsistently\n+\t<__exact, _RAIter, _Compare, _SortingPlacesIterator>()\n         (__iam, __sd, __comp, __num_samples);\n \n-    // Offset from __target __begin, __length after merging.\n-    _DifferenceType __offset = 0, __length_am = 0;\n-    for (_ThreadIndex __s = 0; __s < __sd->_M_num_threads; __s++)\n-      {\n-        __length_am += __sd->_M_pieces[__iam][__s]._M_end\n-                       - __sd->_M_pieces[__iam][__s]._M_begin;\n-        __offset += __sd->_M_pieces[__iam][__s]._M_begin;\n-      }\n+      // Offset from __target __begin, __length after merging.\n+      _DifferenceType __offset = 0, __length_am = 0;\n+      for (_ThreadIndex __s = 0; __s < __sd->_M_num_threads; __s++)\n+\t{\n+\t  __length_am += (__sd->_M_pieces[__iam][__s]._M_end\n+\t\t\t  - __sd->_M_pieces[__iam][__s]._M_begin);\n+\t  __offset += __sd->_M_pieces[__iam][__s]._M_begin;\n+\t}\n \n-    typedef std::vector<\n+      typedef std::vector<\n       std::pair<_SortingPlacesIterator, _SortingPlacesIterator> >\n         _SeqVector;\n-    _SeqVector seqs(__sd->_M_num_threads);\n+      _SeqVector seqs(__sd->_M_num_threads);\n \n-    for (int __s = 0; __s < __sd->_M_num_threads; ++__s)\n-      {\n-        seqs[__s] =\n-          std::make_pair(\n-            __sd->_M_temporary[__s] + __sd->_M_pieces[__iam][__s]._M_begin,\n-            __sd->_M_temporary[__s] + __sd->_M_pieces[__iam][__s]._M_end);\n-      }\n+      for (int __s = 0; __s < __sd->_M_num_threads; ++__s)\n+\t{\n+\t  seqs[__s] =\n+\t    std::make_pair\n+\t    (__sd->_M_temporary[__s] + __sd->_M_pieces[__iam][__s]._M_begin,\n+\t     __sd->_M_temporary[__s] + __sd->_M_pieces[__iam][__s]._M_end);\n+\t}\n \n-    __possibly_stable_multiway_merge<\n+      __possibly_stable_multiway_merge<\n         __stable,\n         typename _SeqVector::iterator,\n         _RAIter,\n         _Compare, _DifferenceType>()\n           (seqs.begin(), seqs.end(),\n-           __sd->_M_source + __offset, __comp,\n+\t   __sd->_M_source + __offset, __comp,\n            __length_am);\n \n-#   pragma omp barrier\n+#     pragma omp barrier\n \n-    ::operator delete(__sd->_M_temporary[__iam]);\n-  }\n+      ::operator delete(__sd->_M_temporary[__iam]);\n+    }\n \n-/** @brief PMWMS main call.\n-  *  @param __begin Begin iterator of sequence.\n-  *  @param __end End iterator of sequence.\n-  *  @param __comp Comparator.\n-  *  @param __n Length of sequence.\n-  *  @param __num_threads Number of threads to use.\n-  */\n-template<bool __stable, bool __exact, typename _RAIter,\n+  /** @brief PMWMS main call.\n+   *  @param __begin Begin iterator of sequence.\n+   *  @param __end End iterator of sequence.\n+   *  @param __comp Comparator.\n+   *  @param __n Length of sequence.\n+   *  @param __num_threads Number of threads to use.\n+   */\n+  template<bool __stable, bool __exact, typename _RAIter,\n            typename _Compare>\n-  void\n-  parallel_sort_mwms(_RAIter __begin, _RAIter __end,\n-                     _Compare __comp,\n-                     _ThreadIndex __num_threads)\n-  {\n-    _GLIBCXX_CALL(__end - __begin)\n+    void\n+    parallel_sort_mwms(_RAIter __begin, _RAIter __end,\n+\t\t       _Compare __comp,\n+\t\t       _ThreadIndex __num_threads)\n+    {\n+      _GLIBCXX_CALL(__end - __begin)\n \n-    typedef std::iterator_traits<_RAIter> _TraitsType;\n-    typedef typename _TraitsType::value_type _ValueType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n+      typedef std::iterator_traits<_RAIter> _TraitsType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n \n-    _DifferenceType __n = __end - __begin;\n+      _DifferenceType __n = __end - __begin;\n \n-    if (__n <= 1)\n-      return;\n+      if (__n <= 1)\n+\treturn;\n \n-    // at least one element per thread\n-    if (__num_threads > __n)\n-      __num_threads = static_cast<_ThreadIndex>(__n);\n+      // at least one element per thread\n+      if (__num_threads > __n)\n+\t__num_threads = static_cast<_ThreadIndex>(__n);\n \n-    // shared variables\n-    _PMWMSSortingData<_RAIter> __sd;\n-    _DifferenceType* _M_starts;\n+      // shared variables\n+      _PMWMSSortingData<_RAIter> __sd;\n+      _DifferenceType* _M_starts;\n \n-#   pragma omp parallel num_threads(__num_threads)\n+#     pragma omp parallel num_threads(__num_threads)\n       {\n         __num_threads = omp_get_num_threads(); //no more threads than requested\n \n #       pragma omp single\n-          {\n-            __sd._M_num_threads = __num_threads;\n-            __sd._M_source = __begin;\n-\n-            __sd._M_temporary = new _ValueType*[__num_threads];\n-\n-            if (!__exact)\n-              {\n-                _DifferenceType __size =\n-                  (_Settings::get().sort_mwms_oversampling * __num_threads - 1)\n-                        * __num_threads;\n-                __sd._M_samples = static_cast<_ValueType*>(\n-                              ::operator new(__size * sizeof(_ValueType)));\n-              }\n-            else\n-              __sd._M_samples = NULL;\n-\n-            __sd._M_offsets = new _DifferenceType[__num_threads - 1];\n-            __sd._M_pieces\n-                = new std::vector<_Piece<_DifferenceType> >[__num_threads];\n-            for (int __s = 0; __s < __num_threads; ++__s)\n-              __sd._M_pieces[__s].resize(__num_threads);\n-            _M_starts = __sd._M_starts\n-                = new _DifferenceType[__num_threads + 1];\n-\n-            _DifferenceType __chunk_length = __n / __num_threads;\n-            _DifferenceType __split = __n % __num_threads;\n-            _DifferenceType __pos = 0;\n-            for (int __i = 0; __i < __num_threads; ++__i)\n-              {\n-                _M_starts[__i] = __pos;\n-                __pos += (__i < __split)\n-                         ? (__chunk_length + 1) : __chunk_length;\n-              }\n-            _M_starts[__num_threads] = __pos;\n-          } //single\n+\t{\n+\t  __sd._M_num_threads = __num_threads;\n+\t  __sd._M_source = __begin;\n+\t  \n+\t  __sd._M_temporary = new _ValueType*[__num_threads];\n+\n+\t  if (!__exact)\n+\t    {\n+\t      _DifferenceType __size =\n+\t\t(_Settings::get().sort_mwms_oversampling * __num_threads - 1)\n+\t\t* __num_threads;\n+\t      __sd._M_samples = static_cast<_ValueType*>\n+\t\t(::operator new(__size * sizeof(_ValueType)));\n+\t    }\n+\t  else\n+\t    __sd._M_samples = NULL;\n+\n+\t  __sd._M_offsets = new _DifferenceType[__num_threads - 1];\n+\t  __sd._M_pieces\n+\t    = new std::vector<_Piece<_DifferenceType> >[__num_threads];\n+\t  for (int __s = 0; __s < __num_threads; ++__s)\n+\t    __sd._M_pieces[__s].resize(__num_threads);\n+\t  _M_starts = __sd._M_starts\n+\t    = new _DifferenceType[__num_threads + 1];\n+\n+\t  _DifferenceType __chunk_length = __n / __num_threads;\n+\t  _DifferenceType __split = __n % __num_threads;\n+\t  _DifferenceType __pos = 0;\n+\t  for (int __i = 0; __i < __num_threads; ++__i)\n+\t    {\n+\t      _M_starts[__i] = __pos;\n+\t      __pos += (__i < __split)\n+\t\t? (__chunk_length + 1) : __chunk_length;\n+\t    }\n+\t  _M_starts[__num_threads] = __pos;\n+\t} //single\n \n         // Now sort in parallel.\n         parallel_sort_mwms_pu<__stable, __exact>(&__sd, __comp);\n       } //parallel\n \n-    delete[] _M_starts;\n-    delete[] __sd._M_temporary;\n+      delete[] _M_starts;\n+      delete[] __sd._M_temporary;\n \n-    if (!__exact)\n+      if (!__exact)\n       ::operator delete(__sd._M_samples);\n \n-    delete[] __sd._M_offsets;\n-    delete[] __sd._M_pieces;\n-  }\n+      delete[] __sd._M_offsets;\n+      delete[] __sd._M_pieces;\n+    }\n+\n } //namespace __gnu_parallel\n \n #endif /* _GLIBCXX_PARALLEL_MULTIWAY_MERGESORT_H */"}, {"sha": "136b5c8cbefe75655eb8e40b38954f68e9459e45", "filename": "libstdc++-v3/include/parallel/omp_loop.h", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338311e5d77550d5eba3b760c3db517de7a93016/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338311e5d77550d5eba3b760c3db517de7a93016/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h?ref=338311e5d77550d5eba3b760c3db517de7a93016", "patch": "@@ -41,74 +41,74 @@\n \n namespace __gnu_parallel\n {\n-/** @brief Embarrassingly parallel algorithm for random access\n-  * iterators, using an OpenMP for loop.\n-  *\n-  *  @param __begin Begin iterator of element sequence.\n-  *  @param __end End iterator of element sequence.\n-  *  @param __o User-supplied functor (comparator, predicate, adding\n-  *  functor, etc.).\n-  *  @param __f Functor to \"process\" an element with __op (depends on\n-  *  desired functionality, e. g. for std::for_each(), ...).\n-  *  @param __r Functor to \"add\" a single __result to the already\n-  *  processed elements (depends on functionality).\n-  *  @param __base Base value for reduction.\n-  *  @param __output Pointer to position where final result is written to\n-  *  @param __bound Maximum number of elements processed (e. g. for\n-  *  std::count_n()).\n-  *  @return User-supplied functor (that may contain a part of the result).\n-  */\n-template<typename _RAIter,\n-         typename _Op,\n-         typename _Fu,\n-         typename _Red,\n-         typename _Result>\n-  _Op\n-  __for_each_template_random_access_omp_loop(\n-    _RAIter __begin, _RAIter __end, _Op __o, _Fu& __f, _Red __r,\n-    _Result __base, _Result& __output,\n-    typename std::iterator_traits<_RAIter>::difference_type __bound)\n-  {\n-    typedef typename\n-        std::iterator_traits<_RAIter>::difference_type\n+  /** @brief Embarrassingly parallel algorithm for random access\n+   * iterators, using an OpenMP for loop.\n+   *\n+   *  @param __begin Begin iterator of element sequence.\n+   *  @param __end End iterator of element sequence.\n+   *  @param __o User-supplied functor (comparator, predicate, adding\n+   *  functor, etc.).\n+   *  @param __f Functor to \"process\" an element with __op (depends on\n+   *  desired functionality, e. g. for std::for_each(), ...).\n+   *  @param __r Functor to \"add\" a single __result to the already\n+   *  processed elements (depends on functionality).\n+   *  @param __base Base value for reduction.\n+   *  @param __output Pointer to position where final result is written to\n+   *  @param __bound Maximum number of elements processed (e. g. for\n+   *  std::count_n()).\n+   *  @return User-supplied functor (that may contain a part of the result).\n+   */\n+  template<typename _RAIter,\n+\t   typename _Op,\n+\t   typename _Fu,\n+\t   typename _Red,\n+\t   typename _Result>\n+    _Op\n+    __for_each_template_random_access_omp_loop(_RAIter __begin, _RAIter __end,\n+\t\t\t\t\t       _Op __o, _Fu& __f, _Red __r,\n+\t\t\t\t\t       _Result __base,\n+\t\t\t\t\t       _Result& __output,\n+      typename std::iterator_traits<_RAIter>::difference_type __bound)\n+    {\n+      typedef typename std::iterator_traits<_RAIter>::difference_type\n         _DifferenceType;\n \n-    _DifferenceType __length = __end - __begin;\n-    _ThreadIndex __num_threads =\n-      __gnu_parallel::min<_DifferenceType>(__get_max_threads(), __length);\n+      _DifferenceType __length = __end - __begin;\n+      _ThreadIndex __num_threads =\n+\t__gnu_parallel::min<_DifferenceType>(__get_max_threads(), __length);\n \n-    _Result *__thread_results;\n+      _Result *__thread_results;\n \n-#   pragma omp parallel num_threads(__num_threads)\n+#     pragma omp parallel num_threads(__num_threads)\n       {\n #       pragma omp single\n-          {\n-            __num_threads = omp_get_num_threads();\n-            __thread_results = new _Result[__num_threads];\n+\t{\n+\t  __num_threads = omp_get_num_threads();\n+\t  __thread_results = new _Result[__num_threads];\n \n-            for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)\n-              __thread_results[__i] = _Result();\n-          }\n+\t  for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)\n+\t    __thread_results[__i] = _Result();\n+\t}\n \n         _ThreadIndex __iam = omp_get_thread_num();\n \n #pragma omp for schedule(dynamic, _Settings::get().workstealing_chunk_size)\n         for (_DifferenceType __pos = 0; __pos < __length; ++__pos)\n           __thread_results[__iam] =\n-              __r(__thread_results[__iam], __f(__o, __begin+__pos));\n+\t    __r(__thread_results[__iam], __f(__o, __begin+__pos));\n       } //parallel\n \n-    for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)\n+      for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)\n         __output = __r(__output, __thread_results[__i]);\n \n-    delete [] __thread_results;\n+      delete [] __thread_results;\n \n-    // Points to last element processed (needed as return value for\n-    // some algorithms like transform).\n-    __f._M_finish_iterator = __begin + __length;\n+      // Points to last element processed (needed as return value for\n+      // some algorithms like transform).\n+      __f._M_finish_iterator = __begin + __length;\n \n-    return __o;\n-  }\n+      return __o;\n+    }\n \n } // end namespace\n "}, {"sha": "e7ca267c92ca39f29724f3d01c9b7535815d2db8", "filename": "libstdc++-v3/include/parallel/omp_loop_static.h", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338311e5d77550d5eba3b760c3db517de7a93016/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338311e5d77550d5eba3b760c3db517de7a93016/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h?ref=338311e5d77550d5eba3b760c3db517de7a93016", "patch": "@@ -40,7 +40,6 @@\n \n namespace __gnu_parallel\n {\n-\n   /** @brief Embarrassingly parallel algorithm for random access\n    * iterators, using an OpenMP for loop with static scheduling.\n    *\n@@ -58,37 +57,38 @@ namespace __gnu_parallel\n    *  std::count_n()).\n    *  @return User-supplied functor (that may contain a part of the result).\n    */\n-template<typename _RAIter,\n-         typename _Op,\n-         typename _Fu,\n-         typename _Red,\n-         typename _Result>\n-  _Op\n-  __for_each_template_random_access_omp_loop_static(\n-    _RAIter __begin, _RAIter __end, _Op __o, _Fu& __f, _Red __r,\n-    _Result __base, _Result& __output,\n-    typename std::iterator_traits<_RAIter>::difference_type __bound)\n-  {\n-    typedef typename\n-      std::iterator_traits<_RAIter>::difference_type\n-      _DifferenceType;\n-\n-    _DifferenceType __length = __end - __begin;\n-    _ThreadIndex __num_threads =\n-      std::min<_DifferenceType>(__get_max_threads(), __length);\n-\n-    _Result *__thread_results;\n-\n-#   pragma omp parallel num_threads(__num_threads)\n+  template<typename _RAIter,\n+\t   typename _Op,\n+\t   typename _Fu,\n+\t   typename _Red,\n+\t   typename _Result>\n+    _Op\n+    __for_each_template_random_access_omp_loop_static(_RAIter __begin,\n+\t\t\t\t\t\t      _RAIter __end, _Op __o,\n+\t\t\t\t\t\t      _Fu& __f, _Red __r,\n+\t\t\t\t\t\t      _Result __base,\n+\t\t\t\t\t\t      _Result& __output,\n+      typename std::iterator_traits<_RAIter>::difference_type __bound)\n+    {\n+      typedef typename std::iterator_traits<_RAIter>::difference_type\n+\t_DifferenceType;\n+\n+      _DifferenceType __length = __end - __begin;\n+      _ThreadIndex __num_threads =\n+\tstd::min<_DifferenceType>(__get_max_threads(), __length);\n+\n+      _Result *__thread_results;\n+\n+#     pragma omp parallel num_threads(__num_threads)\n       {\n #       pragma omp single\n-          {\n-            __num_threads = omp_get_num_threads();\n-            __thread_results = new _Result[__num_threads];\n+\t{\n+\t  __num_threads = omp_get_num_threads();\n+\t  __thread_results = new _Result[__num_threads];\n \n-            for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)\n-              __thread_results[__i] = _Result();\n-          }\n+\t  for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)\n+\t    __thread_results[__i] = _Result();\n+\t}\n \n         _ThreadIndex __iam = omp_get_thread_num();\n \n@@ -98,17 +98,17 @@ template<typename _RAIter,\n                                         __f(__o, __begin+__pos));\n       } //parallel\n \n-    for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)\n-      __output = __r(__output, __thread_results[__i]);\n+      for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)\n+\t__output = __r(__output, __thread_results[__i]);\n \n-    delete [] __thread_results;\n+      delete [] __thread_results;\n \n-    // Points to last element processed (needed as return value for\n-    // some algorithms like transform).\n-    __f.finish_iterator = __begin + __length;\n+      // Points to last element processed (needed as return value for\n+      // some algorithms like transform).\n+      __f.finish_iterator = __begin + __length;\n \n-    return __o;\n-  }\n+      return __o;\n+    }\n \n } // end namespace\n "}, {"sha": "f0a463ebba5ade1f9b4dacbb77ae61c4cbd0d35d", "filename": "libstdc++-v3/include/parallel/par_loop.h", "status": "modified", "additions": 80, "deletions": 81, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338311e5d77550d5eba3b760c3db517de7a93016/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338311e5d77550d5eba3b760c3db517de7a93016/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h?ref=338311e5d77550d5eba3b760c3db517de7a93016", "patch": "@@ -40,94 +40,93 @@\n \n namespace __gnu_parallel\n {\n-\n-/** @brief Embarrassingly parallel algorithm for random access\n-  * iterators, using hand-crafted parallelization by equal splitting\n-  * the work.\n-  *\n-  *  @param __begin Begin iterator of element sequence.\n-  *  @param __end End iterator of element sequence.\n-  *  @param __o User-supplied functor (comparator, predicate, adding\n-  *  functor, ...)\n-  *  @param __f Functor to \"process\" an element with __op (depends on\n-  *  desired functionality, e. g. for std::for_each(), ...).\n-  *  @param __r Functor to \"add\" a single __result to the already\n-  *  processed elements (depends on functionality).\n-  *  @param __base Base value for reduction.\n-  *  @param __output Pointer to position where final result is written to\n-  *  @param __bound Maximum number of elements processed (e. g. for\n-  *  std::count_n()).\n-  *  @return User-supplied functor (that may contain a part of the result).\n-  */\n-template<typename _RAIter,\n-         typename _Op,\n-         typename _Fu,\n-         typename _Red,\n-         typename _Result>\n-  _Op\n-  __for_each_template_random_access_ed(\n-    _RAIter __begin, _RAIter __end, _Op __o, _Fu& __f, _Red __r,\n-    _Result __base, _Result& __output,\n-    typename std::iterator_traits<_RAIter>::difference_type __bound)\n-  {\n-    typedef std::iterator_traits<_RAIter> _TraitsType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-    const _DifferenceType __length = __end - __begin;\n-    _Result *__thread_results;\n-    bool* __constructed;\n-\n-    _ThreadIndex __num_threads =\n-      __gnu_parallel::min<_DifferenceType>(__get_max_threads(), __length);\n-\n-#   pragma omp parallel num_threads(__num_threads)\n+  /** @brief Embarrassingly parallel algorithm for random access\n+   * iterators, using hand-crafted parallelization by equal splitting\n+   * the work.\n+   *\n+   *  @param __begin Begin iterator of element sequence.\n+   *  @param __end End iterator of element sequence.\n+   *  @param __o User-supplied functor (comparator, predicate, adding\n+   *  functor, ...)\n+   *  @param __f Functor to \"process\" an element with __op (depends on\n+   *  desired functionality, e. g. for std::for_each(), ...).\n+   *  @param __r Functor to \"add\" a single __result to the already\n+   *  processed elements (depends on functionality).\n+   *  @param __base Base value for reduction.\n+   *  @param __output Pointer to position where final result is written to\n+   *  @param __bound Maximum number of elements processed (e. g. for\n+   *  std::count_n()).\n+   *  @return User-supplied functor (that may contain a part of the result).\n+   */\n+  template<typename _RAIter,\n+\t   typename _Op,\n+\t   typename _Fu,\n+\t   typename _Red,\n+\t   typename _Result>\n+    _Op\n+    __for_each_template_random_access_ed(_RAIter __begin, _RAIter __end,\n+\t\t\t\t\t _Op __o, _Fu& __f, _Red __r,\n+\t\t\t\t\t _Result __base, _Result& __output,\n+      typename std::iterator_traits<_RAIter>::difference_type __bound)\n+    {\n+      typedef std::iterator_traits<_RAIter> _TraitsType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n+      const _DifferenceType __length = __end - __begin;\n+      _Result *__thread_results;\n+      bool* __constructed;\n+\n+      _ThreadIndex __num_threads =\n+\t__gnu_parallel::min<_DifferenceType>(__get_max_threads(), __length);\n+\n+#     pragma omp parallel num_threads(__num_threads)\n       {\n #       pragma omp single\n-          {\n-            __num_threads = omp_get_num_threads();\n-            __thread_results =\n-              static_cast<_Result*>(\n-                            ::operator new(__num_threads * sizeof(_Result)));\n-            __constructed = new bool[__num_threads];\n-          }\n-\n-        _ThreadIndex __iam = omp_get_thread_num();\n-\n-        // Neutral element.\n-        _Result* __reduct =\n-                   static_cast<_Result*>(::operator new(sizeof(_Result)));\n-\n-        _DifferenceType\n-            __start = equally_split_point(__length, __num_threads, __iam),\n-            __stop = equally_split_point(__length, __num_threads, __iam + 1);\n-\n-        if (__start < __stop)\n-          {\n-            new(__reduct) _Result(__f(__o, __begin + __start));\n-            ++__start;\n-            __constructed[__iam] = true;\n-          }\n-        else\n-          __constructed[__iam] = false;\n-\n-        for (; __start < __stop; ++__start)\n-          *__reduct = __r(*__reduct, __f(__o, __begin + __start));\n-\n-        __thread_results[__iam] = *__reduct;\n+\t{\n+\t  __num_threads = omp_get_num_threads();\n+\t  __thread_results =\n+\t    static_cast<_Result*>(::operator new(__num_threads\n+\t\t\t\t\t\t * sizeof(_Result)));\n+\t  __constructed = new bool[__num_threads];\n+\t}\n+\n+\t_ThreadIndex __iam = omp_get_thread_num();\n+\n+\t// Neutral element.\n+\t_Result* __reduct =\n+\t  static_cast<_Result*>(::operator new(sizeof(_Result)));\n+\n+\t_DifferenceType\n+\t  __start = equally_split_point(__length, __num_threads, __iam),\n+\t  __stop = equally_split_point(__length, __num_threads, __iam + 1);\n+\n+\tif (__start < __stop)\n+\t  {\n+\t    new(__reduct) _Result(__f(__o, __begin + __start));\n+\t    ++__start;\n+\t    __constructed[__iam] = true;\n+\t  }\n+\telse\n+\t  __constructed[__iam] = false;\n+\n+\tfor (; __start < __stop; ++__start)\n+\t  *__reduct = __r(*__reduct, __f(__o, __begin + __start));\n+\n+\t__thread_results[__iam] = *__reduct;\n       } //parallel\n \n-    for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)\n-        if (__constructed[__i])\n-            __output = __r(__output, __thread_results[__i]);\n+      for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)\n+\tif (__constructed[__i])\n+\t  __output = __r(__output, __thread_results[__i]);\n \n-    // Points to last element processed (needed as return value for\n-    // some algorithms like transform).\n-    __f._M_finish_iterator = __begin + __length;\n+      // Points to last element processed (needed as return value for\n+      // some algorithms like transform).\n+      __f._M_finish_iterator = __begin + __length;\n \n-    delete[] __thread_results;\n-    delete[] __constructed;\n+      delete[] __thread_results;\n+      delete[] __constructed;\n \n-    return __o;\n-  }\n+      return __o;\n+    }\n \n } // end namespace\n "}, {"sha": "10673af04ba6b634f06d3d01db34fb859dbae2b7", "filename": "libstdc++-v3/include/parallel/partial_sum.h", "status": "modified", "additions": 137, "deletions": 137, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338311e5d77550d5eba3b760c3db517de7a93016/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338311e5d77550d5eba3b760c3db517de7a93016/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h?ref=338311e5d77550d5eba3b760c3db517de7a93016", "patch": "@@ -43,106 +43,107 @@ namespace __gnu_parallel\n {\n   // Problem: there is no 0-element given.\n \n-/** @brief Base case prefix sum routine.\n-  *  @param __begin Begin iterator of input sequence.\n-  *  @param __end End iterator of input sequence.\n-  *  @param __result Begin iterator of output sequence.\n-  *  @param __bin_op Associative binary function.\n-  *  @param __value Start value. Must be passed since the neutral\n-  *  element is unknown in general.\n-  *  @return End iterator of output sequence. */\n-template<typename _IIter,\n-         typename _OutputIterator,\n-         typename _BinaryOperation>\n-  _OutputIterator\n-  __parallel_partial_sum_basecase(\n-    _IIter __begin, _IIter __end, _OutputIterator __result,\n-    _BinaryOperation __bin_op,\n-    typename std::iterator_traits <_IIter>::value_type __value)\n-  {\n-    if (__begin == __end)\n+  /** @brief Base case prefix sum routine.\n+   *  @param __begin Begin iterator of input sequence.\n+   *  @param __end End iterator of input sequence.\n+   *  @param __result Begin iterator of output sequence.\n+   *  @param __bin_op Associative binary function.\n+   *  @param __value Start value. Must be passed since the neutral\n+   *  element is unknown in general.\n+   *  @return End iterator of output sequence. */\n+  template<typename _IIter,\n+\t   typename _OutputIterator,\n+\t   typename _BinaryOperation>\n+    _OutputIterator\n+    __parallel_partial_sum_basecase(_IIter __begin, _IIter __end,\n+\t\t\t\t    _OutputIterator __result,\n+\t\t\t\t    _BinaryOperation __bin_op,\n+      typename std::iterator_traits <_IIter>::value_type __value)\n+    {\n+      if (__begin == __end)\n+\treturn __result;\n+\n+      while (__begin != __end)\n+\t{\n+\t  __value = __bin_op(__value, *__begin);\n+\t  *__result = __value;\n+\t  ++__result;\n+\t  ++__begin;\n+\t}\n       return __result;\n-\n-    while (__begin != __end)\n-      {\n-        __value = __bin_op(__value, *__begin);\n-        *__result = __value;\n-        ++__result;\n-        ++__begin;\n-      }\n-    return __result;\n-  }\n-\n-/** @brief Parallel partial sum implementation, two-phase approach,\n-    no recursion.\n-    *  @param __begin Begin iterator of input sequence.\n-    *  @param __end End iterator of input sequence.\n-    *  @param __result Begin iterator of output sequence.\n-    *  @param __bin_op Associative binary function.\n-    *  @param __n Length of sequence.\n-    *  @param __num_threads Number of threads to use.\n-    *  @return End iterator of output sequence.\n-    */\n-template<typename _IIter,\n-         typename _OutputIterator,\n-         typename _BinaryOperation>\n-  _OutputIterator\n-  __parallel_partial_sum_linear(\n-        _IIter __begin, _IIter __end, _OutputIterator __result,\n-        _BinaryOperation __bin_op,\n-        typename std::iterator_traits<_IIter>::difference_type __n)\n-  {\n-    typedef std::iterator_traits<_IIter> _TraitsType;\n-    typedef typename _TraitsType::value_type _ValueType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-\n-    if (__begin == __end)\n-      return __result;\n-\n-    _ThreadIndex __num_threads =\n+    }\n+\n+  /** @brief Parallel partial sum implementation, two-phase approach,\n+      no recursion.\n+      *  @param __begin Begin iterator of input sequence.\n+      *  @param __end End iterator of input sequence.\n+      *  @param __result Begin iterator of output sequence.\n+      *  @param __bin_op Associative binary function.\n+      *  @param __n Length of sequence.\n+      *  @param __num_threads Number of threads to use.\n+      *  @return End iterator of output sequence.\n+      */\n+  template<typename _IIter,\n+\t   typename _OutputIterator,\n+\t   typename _BinaryOperation>\n+    _OutputIterator\n+    __parallel_partial_sum_linear(_IIter __begin, _IIter __end,\n+\t\t\t\t  _OutputIterator __result,\n+\t\t\t\t  _BinaryOperation __bin_op,\n+      typename std::iterator_traits<_IIter>::difference_type __n)\n+    {\n+      typedef std::iterator_traits<_IIter> _TraitsType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n+\n+      if (__begin == __end)\n+\treturn __result;\n+\n+      _ThreadIndex __num_threads =\n         std::min<_DifferenceType>(__get_max_threads(), __n - 1);\n \n-    if (__num_threads < 2)\n-      {\n-        *__result = *__begin;\n-        return __parallel_partial_sum_basecase(\n-            __begin + 1, __end, __result + 1, __bin_op, *__begin);\n-      }\n+      if (__num_threads < 2)\n+\t{\n+\t  *__result = *__begin;\n+\t  return __parallel_partial_sum_basecase(__begin + 1, __end,\n+\t\t\t\t\t\t __result + 1, __bin_op,\n+\t\t\t\t\t\t *__begin);\n+\t}\n \n-    _DifferenceType* __borders;\n-    _ValueType* __sums;\n+      _DifferenceType* __borders;\n+      _ValueType* __sums;\n \n-    const _Settings& __s = _Settings::get();\n+      const _Settings& __s = _Settings::get();\n \n-#   pragma omp parallel num_threads(__num_threads)\n+#     pragma omp parallel num_threads(__num_threads)\n       {\n #       pragma omp single\n-          {\n-            __num_threads = omp_get_num_threads();\n-\n-            __borders = new _DifferenceType[__num_threads + 2];\n-\n-            if (__s.partial_sum_dilation == 1.0f)\n-              equally_split(__n, __num_threads + 1, __borders);\n-            else\n-              {\n-                _DifferenceType __chunk_length =\n-                    ((double)__n\n-                     / ((double)__num_threads + __s.partial_sum_dilation)),\n-                  __borderstart = __n - __num_threads * __chunk_length;\n-                __borders[0] = 0;\n-                for (int __i = 1; __i < (__num_threads + 1); ++__i)\n-                  {\n-                    __borders[__i] = __borderstart;\n-                    __borderstart += __chunk_length;\n-                  }\n-                __borders[__num_threads + 1] = __n;\n-              }\n-\n-            __sums = static_cast<_ValueType*>(::operator new(sizeof(_ValueType)\n+\t{\n+\t  __num_threads = omp_get_num_threads();\n+\t    \n+\t  __borders = new _DifferenceType[__num_threads + 2];\n+\n+\t  if (__s.partial_sum_dilation == 1.0f)\n+\t    equally_split(__n, __num_threads + 1, __borders);\n+\t  else\n+\t    {\n+\t      _DifferenceType __chunk_length =\n+\t\t((double)__n\n+\t\t / ((double)__num_threads + __s.partial_sum_dilation)),\n+\t\t__borderstart = __n - __num_threads * __chunk_length;\n+\t      __borders[0] = 0;\n+\t      for (int __i = 1; __i < (__num_threads + 1); ++__i)\n+\t\t{\n+\t\t  __borders[__i] = __borderstart;\n+\t\t  __borderstart += __chunk_length;\n+\t\t}\n+\t      __borders[__num_threads + 1] = __n;\n+\t    }\n+\n+\t  __sums = static_cast<_ValueType*>(::operator new(sizeof(_ValueType)\n                                                            * __num_threads));\n-            _OutputIterator __target_end;\n-          } //single\n+\t  _OutputIterator __target_end;\n+\t} //single\n \n         _ThreadIndex __iam = omp_get_thread_num();\n         if (__iam == 0)\n@@ -166,58 +167,57 @@ template<typename _IIter,\n #       pragma omp barrier\n \n #       pragma omp single\n-          __parallel_partial_sum_basecase(__sums + 1, __sums + __num_threads,\n+\t__parallel_partial_sum_basecase(__sums + 1, __sums + __num_threads,\n                                           __sums + 1, __bin_op, __sums[0]);\n \n #       pragma omp barrier\n \n-        // Still same team.\n-        __parallel_partial_sum_basecase(\n-                __begin + __borders[__iam + 1],\n-                __begin + __borders[__iam + 2],\n-                __result + __borders[__iam + 1],\n-                __bin_op, __sums[__iam]);\n+\t// Still same team.\n+        __parallel_partial_sum_basecase(__begin + __borders[__iam + 1],\n+\t\t\t\t\t__begin + __borders[__iam + 2],\n+\t\t\t\t\t__result + __borders[__iam + 1],\n+\t\t\t\t\t__bin_op, __sums[__iam]);\n       } //parallel\n \n-    ::operator delete(__sums);\n-    delete[] __borders;\n-\n-    return __result + __n;\n-  }\n-\n-/** @brief Parallel partial sum front-__end.\n-  *  @param __begin Begin iterator of input sequence.\n-  *  @param __end End iterator of input sequence.\n-  *  @param __result Begin iterator of output sequence.\n-  *  @param __bin_op Associative binary function.\n-  *  @return End iterator of output sequence. */\n-template<typename _IIter,\n-         typename _OutputIterator,\n-         typename _BinaryOperation>\n-  _OutputIterator\n-  __parallel_partial_sum(_IIter __begin, _IIter __end,\n-                       _OutputIterator __result, _BinaryOperation __bin_op)\n-  {\n-    _GLIBCXX_CALL(__begin - __end)\n-\n-    typedef std::iterator_traits<_IIter> _TraitsType;\n-    typedef typename _TraitsType::value_type _ValueType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-\n-    _DifferenceType __n = __end - __begin;\n-\n-    switch (_Settings::get().partial_sum_algorithm)\n-      {\n-      case LINEAR:\n-        // Need an initial offset.\n-        return __parallel_partial_sum_linear(\n-                 __begin, __end, __result, __bin_op, __n);\n-      default:\n-    // Partial_sum algorithm not implemented.\n-        _GLIBCXX_PARALLEL_ASSERT(0);\n-        return __result + __n;\n-      }\n-  }\n+      ::operator delete(__sums);\n+      delete[] __borders;\n+\n+      return __result + __n;\n+    }\n+\n+  /** @brief Parallel partial sum front-__end.\n+   *  @param __begin Begin iterator of input sequence.\n+   *  @param __end End iterator of input sequence.\n+   *  @param __result Begin iterator of output sequence.\n+   *  @param __bin_op Associative binary function.\n+   *  @return End iterator of output sequence. */\n+  template<typename _IIter,\n+\t   typename _OutputIterator,\n+\t   typename _BinaryOperation>\n+    _OutputIterator\n+    __parallel_partial_sum(_IIter __begin, _IIter __end,\n+\t\t\t   _OutputIterator __result, _BinaryOperation __bin_op)\n+    {\n+      _GLIBCXX_CALL(__begin - __end)\n+\n+      typedef std::iterator_traits<_IIter> _TraitsType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n+\n+      _DifferenceType __n = __end - __begin;\n+\n+      switch (_Settings::get().partial_sum_algorithm)\n+\t{\n+\tcase LINEAR:\n+\t  // Need an initial offset.\n+\t  return __parallel_partial_sum_linear(__begin, __end, __result,\n+\t\t\t\t\t       __bin_op, __n);\n+\tdefault:\n+\t  // Partial_sum algorithm not implemented.\n+\t  _GLIBCXX_PARALLEL_ASSERT(0);\n+\t  return __result + __n;\n+\t}\n+    }\n }\n \n #endif /* _GLIBCXX_PARALLEL_PARTIAL_SUM_H */"}]}