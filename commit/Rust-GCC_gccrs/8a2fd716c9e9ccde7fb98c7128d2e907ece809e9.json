{"sha": "8a2fd716c9e9ccde7fb98c7128d2e907ece809e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGEyZmQ3MTZjOWU5Y2NkZTdmYjk4YzcxMjhkMmU5MDdlY2U4MDllOQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-11-06T12:20:51Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-11-06T12:20:51Z"}, "message": "ipa-modref: Fix comment typos\n\n2020-11-06  Jakub Jelinek  <jakub@redhat.com>\n\n\t* ipa-modref-tree.h: Fix comment typos.\n\t* ipa-modref.c: Likewise.", "tree": {"sha": "5b8ef892a0e9f98c622c95c326db61addffb1f94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b8ef892a0e9f98c622c95c326db61addffb1f94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a2fd716c9e9ccde7fb98c7128d2e907ece809e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a2fd716c9e9ccde7fb98c7128d2e907ece809e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a2fd716c9e9ccde7fb98c7128d2e907ece809e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a2fd716c9e9ccde7fb98c7128d2e907ece809e9/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b92e4be3a61fcdf85ea12b393716b47d6ac9477f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b92e4be3a61fcdf85ea12b393716b47d6ac9477f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b92e4be3a61fcdf85ea12b393716b47d6ac9477f"}], "stats": {"total": 38, "additions": 19, "deletions": 19}, "files": [{"sha": "7d5acb1194f01e5a6a5afe2604cbfe00c00032ab", "filename": "gcc/ipa-modref-tree.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a2fd716c9e9ccde7fb98c7128d2e907ece809e9/gcc%2Fipa-modref-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a2fd716c9e9ccde7fb98c7128d2e907ece809e9/gcc%2Fipa-modref-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.h?ref=8a2fd716c9e9ccde7fb98c7128d2e907ece809e9", "patch": "@@ -23,17 +23,17 @@ along with GCC; see the file COPYING3.  If not see\n    call.  For every function we collect two trees, one for loads and other\n    for stores.  Tree consist of following levels:\n \n-   1) Base: this level represent base alias set of the acecess and refers\n+   1) Base: this level represent base alias set of the access and refers\n       to sons (ref nodes). Flag all_refs means that all possible references\n       are aliasing.\n \n-      Because for LTO streaming we need to stream types rahter than alias sets\n+      Because for LTO streaming we need to stream types rather than alias sets\n       modref_base_node is implemented as a template.\n-   2) Ref: this level represent ref alias set and links to acesses unless\n-      all_refs flag is et.\n+   2) Ref: this level represent ref alias set and links to accesses unless\n+      all_refs flag is set.\n       Again ref is an template to allow LTO streaming.\n    3) Access: this level represent info about individual accesses.  Presently\n-      we record whether access is trhough a dereference of a function parameter\n+      we record whether access is through a dereference of a function parameter\n */\n \n #ifndef GCC_MODREF_TREE_H\n@@ -50,7 +50,7 @@ struct GTY(()) modref_access_node\n   poly_int64 size;\n   poly_int64 max_size;\n \n-  /* Offset from parmeter pointer to the base of the access (in bytes).  */\n+  /* Offset from parameter pointer to the base of the access (in bytes).  */\n   poly_int64 parm_offset;\n \n   /* Index of parameter which specifies the base of access. -1 if base is not\n@@ -240,7 +240,7 @@ struct modref_parm_map\n {\n   /* Index of parameter we translate to.\n      -1 indicates that parameter is unknown\n-     -2 indicates that parmaeter points to local memory and access can be\n+     -2 indicates that parameter points to local memory and access can be\n \tdiscarded.  */\n   int parm_index;\n   bool parm_offset_known;\n@@ -333,7 +333,7 @@ struct GTY((user)) modref_tree\n     /* If we failed to insert ref, just see if there is a cleanup possible.  */\n     if (!ref_node)\n       {\n-\t/* No useful ref information and no useful base; collapse everyting.  */\n+\t/* No useful ref information and no useful base; collapse everything.  */\n \tif (!base && base_node->every_ref)\n \t  {\n \t    collapse ();\n@@ -367,7 +367,7 @@ struct GTY((user)) modref_tree\n     return changed;\n   }\n \n- /* Remove tree branches that are not useful (i.e. they will allways pass).  */\n+ /* Remove tree branches that are not useful (i.e. they will always pass).  */\n \n  void cleanup ()\n  {"}, {"sha": "3f46bebed3ccf510842f2612ea4b595f6be493b1", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a2fd716c9e9ccde7fb98c7128d2e907ece809e9/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a2fd716c9e9ccde7fb98c7128d2e907ece809e9/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=8a2fd716c9e9ccde7fb98c7128d2e907ece809e9", "patch": "@@ -24,7 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n    described in ipa-modref-tree.h.\n \n    This file contains a tree pass and an IPA pass.  Both performs the same\n-   analys however tree pass is executed during early and late optimization\n+   analysis however tree pass is executed during early and late optimization\n    passes to propagate info downwards in the compilation order.  IPA pass\n    propagates across the callgraph and is able to handle recursion and works on\n    whole program during link-time analysis.\n@@ -152,7 +152,7 @@ class GTY((user)) modref_summaries_lto\n static GTY(()) fast_function_summary <modref_summary *, va_gc>\n \t *summaries;\n \n-/* Global variable holding all modref optimizaiton summaries\n+/* Global variable holding all modref optimization summaries\n    (from IPA propagation time or used by local optimization pass).  */\n \n static GTY(()) fast_function_summary <modref_summary *, va_gc>\n@@ -924,7 +924,7 @@ analyze_call (modref_summary *cur_summary, modref_summary_lto *cur_summary_lto,\n   return true;\n }\n \n-/* Support analyzis in non-lto and lto mode in parallel.  */\n+/* Support analysis in non-lto and lto mode in parallel.  */\n \n struct summary_ptrs\n {\n@@ -995,10 +995,10 @@ static bool\n analyze_stmt (modref_summary *summary, modref_summary_lto *summary_lto,\n \t      gimple *stmt, bool ipa, vec <gimple *> *recursive_calls)\n {\n-  /* In general we can not ignore clobbers because they are barries for code\n-     motion, however after inlining it is safe to do becuase local optimization\n+  /* In general we can not ignore clobbers because they are barriers for code\n+     motion, however after inlining it is safe to do because local optimization\n      passes do not consider clobbers from other functions.\n-     Similar logic is in ipa-pure-consts.  */\n+     Similar logic is in ipa-pure-const.c.  */\n   if ((ipa || cfun->after_inlining) && gimple_clobber_p (stmt))\n     return true;\n \n@@ -1121,7 +1121,7 @@ analyze_function (function *f, bool ipa)\n       summary = optimization_summaries->get_create (cgraph_node::get (f->decl));\n       gcc_checking_assert (nolto && !lto);\n     }\n-  /* In IPA mode we analyze every function precisely once.  Asser that.  */\n+  /* In IPA mode we analyze every function precisely once.  Assert that.  */\n   else\n     {\n       if (nolto)\n@@ -1309,7 +1309,7 @@ modref_summaries::duplicate (cgraph_node *, cgraph_node *dst,\n \t\t\t     modref_summary *src_data,\n \t\t\t     modref_summary *dst_data)\n {\n-  /* Do not duplicte optimization summaries; we do not handle parameter\n+  /* Do not duplicate optimization summaries; we do not handle parameter\n      transforms on them.  */\n   if (this == optimization_summaries)\n     {\n@@ -1336,7 +1336,7 @@ modref_summaries_lto::duplicate (cgraph_node *, cgraph_node *,\n \t\t\t\t modref_summary_lto *src_data,\n \t\t\t\t modref_summary_lto *dst_data)\n {\n-  /* Be sure that no furhter cloning happens after ipa-modref.  If it does\n+  /* Be sure that no further cloning happens after ipa-modref.  If it does\n      we will need to update signatures for possible param changes.  */\n   gcc_checking_assert (!((modref_summaries_lto *)summaries_lto)->propagated);\n   dst_data->stores = modref_records_lto::create_ggc\n@@ -1934,7 +1934,7 @@ ignore_edge (struct cgraph_edge *e)\n \t     & (ECF_CONST | ECF_NOVOPS));\n }\n \n-/* Compute parm_map for CALLE_EDGE.  */\n+/* Compute parm_map for CALLEE_EDGE.  */\n \n static bool\n compute_parm_map (cgraph_edge *callee_edge, vec<modref_parm_map> *parm_map)"}]}