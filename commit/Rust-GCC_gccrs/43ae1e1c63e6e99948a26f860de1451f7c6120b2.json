{"sha": "43ae1e1c63e6e99948a26f860de1451f7c6120b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNhZTFlMWM2M2U2ZTk5OTQ4YTI2Zjg2MGRlMTQ1MWY3YzYxMjBiMg==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2005-04-09T12:07:44Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2005-04-09T12:07:44Z"}, "message": "tree-ssa.texi: Add immediate use documentation.\n\n\n\n2005-04-09  Andrew MacLeod  <amacleod@redhat.com>\n\n\t* doc/tree-ssa.texi: Add immediate use documentation.\n\nFrom-SVN: r97895", "tree": {"sha": "8b8e9940344cdc30d8181db22d4a8aaf3a1a7878", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b8e9940344cdc30d8181db22d4a8aaf3a1a7878"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43ae1e1c63e6e99948a26f860de1451f7c6120b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43ae1e1c63e6e99948a26f860de1451f7c6120b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43ae1e1c63e6e99948a26f860de1451f7c6120b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43ae1e1c63e6e99948a26f860de1451f7c6120b2/comments", "author": null, "committer": null, "parents": [{"sha": "abac3b49c23d0c17ce227d4ae69d2fbd30535d5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abac3b49c23d0c17ce227d4ae69d2fbd30535d5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abac3b49c23d0c17ce227d4ae69d2fbd30535d5a"}], "stats": {"total": 104, "additions": 95, "deletions": 9}, "files": [{"sha": "4075d9b5a1e2f082d74fc1dcf8d6a2cdc627c128", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ae1e1c63e6e99948a26f860de1451f7c6120b2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ae1e1c63e6e99948a26f860de1451f7c6120b2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=43ae1e1c63e6e99948a26f860de1451f7c6120b2", "patch": "@@ -1,3 +1,7 @@\n+2005-04-09  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* doc/tree-ssa.texi: Add immediate use documentation.\n+\n 2005-04-09  Richard Earnshaw <richard.earnshaw@arm.com>\n \n \t* arm.c (FL_WBUF): Define."}, {"sha": "c449a8f2362d1c333d179d341ee32b82e94287a7", "filename": "gcc/doc/tree-ssa.texi", "status": "modified", "additions": 91, "deletions": 9, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ae1e1c63e6e99948a26f860de1451f7c6120b2/gcc%2Fdoc%2Ftree-ssa.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ae1e1c63e6e99948a26f860de1451f7c6120b2/gcc%2Fdoc%2Ftree-ssa.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftree-ssa.texi?ref=43ae1e1c63e6e99948a26f860de1451f7c6120b2", "patch": "@@ -699,8 +699,7 @@ Annotations are defined and documented in @file{tree-flow.h}.\n @cindex operands\n @cindex virtual operands\n @cindex real operands\n-@findex get_stmt_operands\n-@findex modify_stmt\n+@findex update_stmt\n \n Almost every GIMPLE statement will contain a reference to a variable\n or memory location.  Since statements come in different shapes and\n@@ -860,7 +859,6 @@ print_ops (tree stmt)\n   stmt_ann_t ann;\n   size_t i;\n \n-  get_stmt_operands (stmt);\n   ann = stmt_ann (stmt);\n \n   defs = DEF_OPS (ann);\n@@ -888,11 +886,15 @@ print_ops (tree stmt)\n @}\n @end smallexample\n \n-To collect the operands, you first need to call\n-@code{get_stmt_operands}.  Since that is a potentially expensive\n-operation, statements are only scanned if they have been marked\n-modified by a call to @code{modify_stmt}.  So, if your pass replaces\n-operands in a statement, make sure to call @code{modify_stmt}.\n+Operands use to be updated lazily via calls to @code{get_stmt_operands}.  \n+This function is now deprecated and operands are updated as soon as the stmt is\n+finished via a call to @code{update_stmt}.  If statement elements are\n+changed via @code{SET_USE} or @code{SET_DEF}, no further action need be \n+taken (ie, those macros take care of whatever updating is required).  If\n+changes are made by manipulating the statement's tree directly, then a call \n+must be made to @code{update_stmt} when complete.  Calling one of the \n+@code{bsi_insert} routines or @code{bsi_replace} performs an implicit call\n+to @code{update_stmt}.\n \n @subsection Operand Iterators\n @cindex Operand Iterators\n@@ -909,7 +911,6 @@ print_ops (tree stmt)\n   ssa_op_iter;\n   tree var;\n \n-  get_stmt_operands (stmt);\n   FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_OPERANDS)\n     print_generic_expr (stderr, var, 0);\n @}\n@@ -1024,6 +1025,87 @@ There are many examples in the code as well, as well as the\n documentation in @file{tree-ssa-operands.h}.\n \n \n+@subsection Immediate Uses\n+@cindex Immediate Uses\n+\n+Immediate use information is now always available.  Using the immediate use \n+iterators, you may examine every use of any @code{SSA_NAME}. For instance,\n+to change each use of @code{ssa_var} to @code{ssa_var2}:\n+\n+@smallexample\n+  FOR_EACH_IMM_USE_SAFE (imm_use_p, iterator, ssa_var)\n+    SET_USE (imm_use_p, ssa_var_2);\n+@end smallexample\n+\n+There are 2 iterators which can be used. @code{FOR_EACH_IMM_USE_FAST} is used \n+when the immediate uses are not changed, ie. you are looking at the uses, but \n+not setting them.  \n+\n+If they do get changed, then care must be taken that things are not changed \n+under the iterators, so use the @code{FOR_EACH_IMM_USE_SAFE} iterator.  It \n+attempts to preserve the sanity of the use list by moving an iterator element\n+through the use list, preventing insertions and deletions in the list from\n+resulting in invalid pointers.  This is a little slower since it adds a\n+placeholder element and moves it through the list.  This element must be \n+also be removed if the loop is terminated early.  A macro \n+(@code{BREAK_FROM SAFE_IMM_USE} is provided for this:\n+\n+@smallexample\n+  FOR_EACH_IMM_USE_SAFE (use_p, iter, var)\n+    @{\n+      if (var == last_var)\n+        BREAK_FROM_SAFE_IMM_USE (iter);\n+      else\n+        SET_USE (use_p, var2);\n+    @}\n+@end smallexample\n+\n+There are checks in @code{verify_ssa} which verify that the immediate use list\n+is up to date, as well as checking that an optimization didn't break from the \n+loop without using this macro.  It is safe to simply 'break'; from a \n+@code{FOR_EACH_IMM_USE_FAST} traverse.\n+\n+Some useful functions and macros:\n+@enumerate\n+@item  @code{has_zero_uses (ssa_var)} : Returns true if there are no uses of\n+@code{ssa_var}.\n+@item   @code{has_single_use (ssa_var)} : Returns true if there is only a \n+single use of @code{ssa_var}.\n+@item   @code{single_imm_use (ssa_var, use_operand_p *ptr, tree *stmt)} :\n+Returns true if there is only a single use of @code{ssa_var}, and also returns\n+the use pointer and stmt it occurs in in the second and third parameters.\n+@item   @code{num_imm_uses (ssa_var)} : Returns the number of immediate uses of\n+@code{ssa_var}. Its better not to use this if possible since it simply\n+utilizes a loop to count the uses.\n+@item  @code{PHI_ARG_INDEX_FROM_USE (use_p)} : Given a use within a @code{PHI}\n+node, return the index number for the use.  An assert is triggered if the use\n+isn't located in a @code{PHI} node.\n+@item  @code{USE_STMT (use_p)} : Return the stmt a use occurs in.\n+@end enumerate\n+\n+Note that uses are not put into an immediate use list until their statement is\n+actually inserted into the instruction stream via a @code{bsi_*} routine.  \n+\n+It is also still possible to utilize lazy updating of stmts, but this should be used only when absolutely required.  Both alias analysis and the dominator \n+optimizations currently do this.  \n+\n+When lazy updating is being used, the immediate use information is out of date \n+and cannot be used reliably.  Lazy updating is acheived by simply marking stmts \n+modified via calls to @code{mark_stmt_modified} instead of @code{update_stmt}.\n+When lazy updating is no longer required, all the modified stmts must have \n+@code{update_stmt} called in order to bring them up to date.  This must be done before the optimization is finished, or @code{verify_ssa} will trigger an abort.\n+\n+This is done with a simple loop over the instruction stream:\n+@smallexample\n+  block_stmt_iterator bsi;\n+  basic_block bb;\n+  FOR_EACH_BB (bb)\n+    @{\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+        update_stmt_if_modified (bsi_stmt (bsi));\n+    @}\n+@end smallexample\n+\n @node SSA\n @section Static Single Assignment\n @cindex SSA"}]}