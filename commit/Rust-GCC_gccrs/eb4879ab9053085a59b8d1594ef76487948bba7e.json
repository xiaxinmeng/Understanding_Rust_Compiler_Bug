{"sha": "eb4879ab9053085a59b8d1594ef76487948bba7e", "node_id": "C_kwDOANBUbNoAKGViNDg3OWFiOTA1MzA4NWE1OWI4ZDE1OTRlZjc2NDg3OTQ4YmJhN2U", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-08-26T07:24:56Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-08-26T07:27:39Z"}, "message": "c++: Implement C++23 P2071R2 - Named universal character escapes [PR106648]\n\nThe following patch implements the\nC++23 P2071R2 - Named universal character escapes\npaper to support \\N{LATIN SMALL LETTER E} etc.\nI've used Unicode 14.0, there are 144803 character name properties\n(including the ones generated by Unicode NR1 and NR2 rules)\nand correction/control/alternate aliases, together with zero terminators\nthat would be 3884745 bytes, which is clearly unacceptable for libcpp.\nThis patch instead contains a generator which from the UnicodeData.txt\nand NameAliases.txt files emits a space optimized radix tree (208765\nbytes long for 14.0), a single string literal dictionary (59418 bytes),\nmaximum name length (currently 88 chars) and two small helper arrays\nfor the NR1/NR2 name generation.\nThe radix tree needs 2 to 9 bytes per node, the exact format is\ndescribed in the generator program.  There could be ways to shrink\nthe dictionary size somewhat at the expense of slightly slower lookups.\n\nCurrently the patch implements strict matching (that is what is needed\nto actually implement it on valid code) and Unicode UAX44-LM2 algorithm\nloose matching to provide hints (that algorithm essentially ignores\nhyphens in between two alphanumeric characters, spaces and underscores\n(with one exception for hyphen) and does case insensitive matching).\nIn the attachment is a WIP patch that shows how to implement also\nspellcheck.{h,cc} style discovery of misspellings, but I'll need to talk\nto David Malcolm about it, as spellcheck.{h,cc} is in gcc/ subdir\n(so the WIP incremental patch instead prints all the names to stderr).\n\n2022-08-26  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/106648\nlibcpp/\n\t* charset.cc: Implement C++23 P2071R2 - Named universal character\n\tescapes.  Include uname2c.h.\n\t(hangul_syllables, hangul_count): New variables.\n\t(struct uname2c_data): New type.\n\t(_cpp_uname2c, _cpp_uname2c_uax44_lm2): New functions.\n\t(_cpp_valid_ucn): Use them.  Handle named universal character escapes.\n\t(convert_ucn): Adjust comment.\n\t(convert_escape): Call convert_ucn even for \\N.\n\t(_cpp_interpret_identifier): Handle named universal character escapes.\n\t* lex.cc (get_bidi_ucn): Fix up function comment formatting.\n\t(get_bidi_named): New function.\n\t(forms_identifier_p, lex_string): Handle named universal character\n\tescapes.\n\t* makeuname2c.cc: New file.  Small parts copied from makeucnid.cc.\n\t* uname2c.h: New generated file.\ngcc/c-family/\n\t* c-cppbuiltin.cc (c_cpp_builtins): Predefine\n\t__cpp_named_character_escapes to 202207L.\ngcc/testsuite/\n\t* c-c++-common/cpp/named-universal-char-escape-1.c: New test.\n\t* c-c++-common/cpp/named-universal-char-escape-2.c: New test.\n\t* c-c++-common/cpp/named-universal-char-escape-3.c: New test.\n\t* c-c++-common/cpp/named-universal-char-escape-4.c: New test.\n\t* c-c++-common/Wbidi-chars-25.c: New test.\n\t* gcc.dg/cpp/named-universal-char-escape-1.c: New test.\n\t* gcc.dg/cpp/named-universal-char-escape-2.c: New test.\n\t* g++.dg/cpp/named-universal-char-escape-1.C: New test.\n\t* g++.dg/cpp/named-universal-char-escape-2.C: New test.\n\t* g++.dg/cpp23/feat-cxx2b.C: Test __cpp_named_character_escapes.", "tree": {"sha": "ea5328515c81dd4505284ce2cd0aa37ebaa56b40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea5328515c81dd4505284ce2cd0aa37ebaa56b40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb4879ab9053085a59b8d1594ef76487948bba7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb4879ab9053085a59b8d1594ef76487948bba7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb4879ab9053085a59b8d1594ef76487948bba7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb4879ab9053085a59b8d1594ef76487948bba7e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "670961f051aedbac21bc769c21c5b28b338b6003", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/670961f051aedbac21bc769c21c5b28b338b6003", "html_url": "https://github.com/Rust-GCC/gccrs/commit/670961f051aedbac21bc769c21c5b28b338b6003"}], "stats": {"total": 19996, "additions": 19939, "deletions": 57}, "files": [{"sha": "a1557eb23d5886b8f8612a7883bdb2e2a2ea4c18", "filename": "gcc/c-family/c-cppbuiltin.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4879ab9053085a59b8d1594ef76487948bba7e/gcc%2Fc-family%2Fc-cppbuiltin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4879ab9053085a59b8d1594ef76487948bba7e/gcc%2Fc-family%2Fc-cppbuiltin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.cc?ref=eb4879ab9053085a59b8d1594ef76487948bba7e", "patch": "@@ -1080,6 +1080,7 @@ c_cpp_builtins (cpp_reader *pfile)\n \t  cpp_define (pfile, \"__cpp_if_consteval=202106L\");\n \t  cpp_define (pfile, \"__cpp_constexpr=202110L\");\n \t  cpp_define (pfile, \"__cpp_multidimensional_subscript=202110L\");\n+\t  cpp_define (pfile, \"__cpp_named_character_escapes=202207L\");\n \t}\n       if (flag_concepts)\n         {"}, {"sha": "58d6a29c0634e836b04147d2baab4f72311af2f7", "filename": "gcc/testsuite/c-c++-common/Wbidi-chars-25.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4879ab9053085a59b8d1594ef76487948bba7e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWbidi-chars-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4879ab9053085a59b8d1594ef76487948bba7e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWbidi-chars-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWbidi-chars-25.c?ref=eb4879ab9053085a59b8d1594ef76487948bba7e", "patch": "@@ -0,0 +1,28 @@\n+/* PR preprocessor/103026 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wbidi-chars=ucn,unpaired\" } */\n+/* Test nesting of bidi chars in various contexts.  */\n+\n+void\n+g1 ()\n+{\n+  const char *s1 = \"a b c LRE\\N{LEFT-TO-RIGHT EMBEDDING} 1 2 3 PDI\\N{POP DIRECTIONAL ISOLATE} x y z\";\n+/* { dg-warning \"unpaired\" \"\" { target *-*-* } .-1 } */\n+  const char *s2 = \"a b c RLE\\N{RIGHT-TO-LEFT EMBEDDING} 1 2 3 PDI\\N{POP DIRECTIONAL ISOLATE} x y z\";\n+/* { dg-warning \"unpaired\" \"\" { target *-*-* } .-1 } */\n+  const char *s3 = \"a b c LRO\\N{LEFT-TO-RIGHT OVERRIDE} 1 2 3 PDI\\N{POP DIRECTIONAL ISOLATE} x y z\";\n+/* { dg-warning \"unpaired\" \"\" { target *-*-* } .-1 } */\n+  const char *s4 = \"a b c RLO\\N{RIGHT-TO-LEFT OVERRIDE} 1 2 3 PDI\\N{POP DIRECTIONAL ISOLATE} x y z\";\n+/* { dg-warning \"unpaired\" \"\" { target *-*-* } .-1 } */\n+  const char *s5 = \"a b c LRI\\N{LEFT-TO-RIGHT ISOLATE} 1 2 3 PDF\\N{POP DIRECTIONAL FORMATTING} x y z\";\n+/* { dg-warning \"unpaired\" \"\" { target *-*-* } .-1 } */\n+  const char *s6 = \"a b c RLI\\N{RIGHT-TO-LEFT ISOLATE} 1 2 3 PDF\\N{POP DIRECTIONAL FORMATTING} x y z\";\n+/* { dg-warning \"unpaired\" \"\" { target *-*-* } .-1 } */\n+  const char *s7 = \"a b c FSI\\N{FIRST STRONG ISOLATE} 1 2 3 PDF\\N{POP DIRECTIONAL FORMATTING} x y z\";\n+/* { dg-warning \"unpaired\" \"\" { target *-*-* } .-1 } */\n+}\n+\n+int A\\N{LEFT-TO-RIGHT EMBEDDING}B\\N{POP DIRECTIONAL ISOLATE}C;\n+/* { dg-warning \"unpaired\" \"\" { target *-*-* } .-1 } */\n+int a\\N{RIGHT-TO-LEFT EMBEDDING}B\\N{POP DIRECTIONAL ISOLATE}c;\n+/* { dg-warning \"unpaired\" \"\" { target *-*-* } .-1 } */"}, {"sha": "3c692f45923ae2fb1973b744750fd23a08b04c28", "filename": "gcc/testsuite/c-c++-common/cpp/named-universal-char-escape-1.c", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4879ab9053085a59b8d1594ef76487948bba7e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fnamed-universal-char-escape-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4879ab9053085a59b8d1594ef76487948bba7e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fnamed-universal-char-escape-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fnamed-universal-char-escape-1.c?ref=eb4879ab9053085a59b8d1594ef76487948bba7e", "patch": "@@ -0,0 +1,174 @@\n+/* P2071R2 - Named universal character escapes */\n+/* { dg-do run } */\n+/* { dg-require-effective-target wchar } */\n+/* { dg-options \"-std=gnu99 -Wno-c++-compat\" { target c } } */\n+/* { dg-options \"-std=c++23\" { target c++ } } */\n+\n+#ifndef __cplusplus\n+#include <wchar.h>\n+typedef __CHAR16_TYPE__ char16_t;\n+typedef __CHAR32_TYPE__ char32_t;\n+#endif\n+\n+#ifdef __cplusplus\n+#if U'\\u0000' != U'\\N{NULL}' \\\n+    || U'\\u0001' != U'\\N{START OF HEADING}' \\\n+    || U'\\u0002' != U'\\N{START OF TEXT}' \\\n+    || U'\\u0003' != U'\\N{END OF TEXT}' \\\n+    || U'\\u0004' != U'\\N{END OF TRANSMISSION}' \\\n+    || U'\\u0005' != U'\\N{ENQUIRY}' \\\n+    || U'\\u0006' != U'\\N{ACKNOWLEDGE}' \\\n+    || U'\\u0007' != U'\\N{ALERT}' \\\n+    || U'\\u0008' != U'\\N{BACKSPACE}' \\\n+    || U'\\u0009' != U'\\N{CHARACTER TABULATION}' \\\n+    || U'\\u0009' != U'\\N{HORIZONTAL TABULATION}' \\\n+    || U'\\u000A' != U'\\N{LINE FEED}' \\\n+    || U'\\u000A' != U'\\N{NEW LINE}' \\\n+    || U'\\u000A' != U'\\N{END OF LINE}' \\\n+    || U'\\u000B' != U'\\N{LINE TABULATION}' \\\n+    || U'\\u000B' != U'\\N{VERTICAL TABULATION}' \\\n+    || U'\\u000C' != U'\\N{FORM FEED}' \\\n+    || U'\\u000D' != U'\\N{CARRIAGE RETURN}' \\\n+    || U'\\u000E' != U'\\N{SHIFT OUT}' \\\n+    || U'\\u000E' != U'\\N{LOCKING-SHIFT ONE}' \\\n+    || U'\\u000F' != U'\\N{SHIFT IN}' \\\n+    || U'\\u000F' != U'\\N{LOCKING-SHIFT ZERO}' \\\n+    || U'\\u0010' != U'\\N{DATA LINK ESCAPE}' \\\n+    || U'\\u0011' != U'\\N{DEVICE CONTROL ONE}' \\\n+    || U'\\u0012' != U'\\N{DEVICE CONTROL TWO}' \\\n+    || U'\\u0013' != U'\\N{DEVICE CONTROL THREE}' \\\n+    || U'\\u0014' != U'\\N{DEVICE CONTROL FOUR}' \\\n+    || U'\\u0015' != U'\\N{NEGATIVE ACKNOWLEDGE}' \\\n+    || U'\\u0016' != U'\\N{SYNCHRONOUS IDLE}' \\\n+    || U'\\u0017' != U'\\N{END OF TRANSMISSION BLOCK}' \\\n+    || U'\\u0018' != U'\\N{CANCEL}' \\\n+    || U'\\u0019' != U'\\N{END OF MEDIUM}' \\\n+    || U'\\u001A' != U'\\N{SUBSTITUTE}' \\\n+    || U'\\u001B' != U'\\N{ESCAPE}' \\\n+    || U'\\u001C' != U'\\N{INFORMATION SEPARATOR FOUR}' \\\n+    || U'\\u001C' != U'\\N{FILE SEPARATOR}' \\\n+    || U'\\u001D' != U'\\N{INFORMATION SEPARATOR THREE}' \\\n+    || U'\\u001D' != U'\\N{GROUP SEPARATOR}' \\\n+    || U'\\u001E' != U'\\N{INFORMATION SEPARATOR TWO}' \\\n+    || U'\\u001E' != U'\\N{RECORD SEPARATOR}' \\\n+    || U'\\u001F' != U'\\N{INFORMATION SEPARATOR ONE}' \\\n+    || U'\\u001F' != U'\\N{UNIT SEPARATOR}' \\\n+    || U'\\u007F' != U'\\N{DELETE}' \\\n+    || U'\\u0082' != U'\\N{BREAK PERMITTED HERE}' \\\n+    || U'\\u0083' != U'\\N{NO BREAK HERE}' \\\n+    || U'\\u0084' != U'\\N{INDEX}' \\\n+    || U'\\u0085' != U'\\N{NEXT LINE}' \\\n+    || U'\\u0086' != U'\\N{START OF SELECTED AREA}' \\\n+    || U'\\u0087' != U'\\N{END OF SELECTED AREA}' \\\n+    || U'\\u0088' != U'\\N{CHARACTER TABULATION SET}' \\\n+    || U'\\u0088' != U'\\N{HORIZONTAL TABULATION SET}' \\\n+    || U'\\u0089' != U'\\N{CHARACTER TABULATION WITH JUSTIFICATION}' \\\n+    || U'\\u0089' != U'\\N{HORIZONTAL TABULATION WITH JUSTIFICATION}' \\\n+    || U'\\u008A' != U'\\N{LINE TABULATION SET}' \\\n+    || U'\\u008A' != U'\\N{VERTICAL TABULATION SET}' \\\n+    || U'\\u008B' != U'\\N{PARTIAL LINE FORWARD}' \\\n+    || U'\\u008B' != U'\\N{PARTIAL LINE DOWN}' \\\n+    || U'\\u008C' != U'\\N{PARTIAL LINE BACKWARD}' \\\n+    || U'\\u008C' != U'\\N{PARTIAL LINE UP}' \\\n+    || U'\\u008D' != U'\\N{REVERSE LINE FEED}' \\\n+    || U'\\u008D' != U'\\N{REVERSE INDEX}' \\\n+    || U'\\u008E' != U'\\N{SINGLE SHIFT TWO}' \\\n+    || U'\\u008E' != U'\\N{SINGLE-SHIFT-2}' \\\n+    || U'\\u008F' != U'\\N{SINGLE SHIFT THREE}' \\\n+    || U'\\u008F' != U'\\N{SINGLE-SHIFT-3}' \\\n+    || U'\\u0090' != U'\\N{DEVICE CONTROL STRING}' \\\n+    || U'\\u0091' != U'\\N{PRIVATE USE ONE}' \\\n+    || U'\\u0091' != U'\\N{PRIVATE USE-1}' \\\n+    || U'\\u0092' != U'\\N{PRIVATE USE TWO}' \\\n+    || U'\\u0092' != U'\\N{PRIVATE USE-2}' \\\n+    || U'\\u0093' != U'\\N{SET TRANSMIT STATE}' \\\n+    || U'\\u0094' != U'\\N{CANCEL CHARACTER}' \\\n+    || U'\\u0095' != U'\\N{MESSAGE WAITING}' \\\n+    || U'\\u0096' != U'\\N{START OF GUARDED AREA}' \\\n+    || U'\\u0096' != U'\\N{START OF PROTECTED AREA}' \\\n+    || U'\\u0097' != U'\\N{END OF GUARDED AREA}' \\\n+    || U'\\u0097' != U'\\N{END OF PROTECTED AREA}' \\\n+    || U'\\u0098' != U'\\N{START OF STRING}' \\\n+    || U'\\u009A' != U'\\N{SINGLE CHARACTER INTRODUCER}' \\\n+    || U'\\u009B' != U'\\N{CONTROL SEQUENCE INTRODUCER}' \\\n+    || U'\\u009C' != U'\\N{STRING TERMINATOR}' \\\n+    || U'\\u009D' != U'\\N{OPERATING SYSTEM COMMAND}' \\\n+    || U'\\u009E' != U'\\N{PRIVACY MESSAGE}' \\\n+    || U'\\u009F' != U'\\N{APPLICATION PROGRAM COMMAND}' \\\n+    || U'\\u0020' != U'\\N{SPACE}' \\\n+    || U'\\u0030' != U'\\N{DIGIT ZERO}' \\\n+    || U'\\u0053' != U'\\N{LATIN CAPITAL LETTER S}'\n+#error Bad\n+#endif\n+#endif\n+#if U'\\U0001F402' != U'\\N{OX}' \\\n+    || U'\\U0001FBA9' != U'\\N{BOX DRAWINGS LIGHT DIAGONAL UPPER CENTRE TO MIDDLE RIGHT AND MIDDLE LEFT TO LOWER CENTRE}' \\\n+    || U'\\u01FD' != U'\\N{LATIN SMALL LETTER AE WITH ACUTE}' \\\n+    || U'\\u2118' != U'\\N{WEIERSTRASS ELLIPTIC FUNCTION}' \\\n+    || U'\\u2118' != U'\\N{SCRIPT CAPITAL P}' \\\n+    || U'\\uFEFF' != U'\\N{BYTE ORDER MARK}' \\\n+    || U'\\uFEFF' != U'\\N{ZERO WIDTH NO-BREAK SPACE}' \\\n+    || U'\\u116C' != U'\\N{HANGUL JUNGSEONG OE}' \\\n+    || U'\\u1180' != U'\\N{HANGUL JUNGSEONG O-E}' \\\n+    || U'\\u0F60' != U'\\N{TIBETAN LETTER -A}' \\\n+    || U'\\u0F68' != U'\\N{TIBETAN LETTER A}' \\\n+    || U'\\u0F0A' != U'\\N{TIBETAN MARK BKA- SHOG YIG MGO}' \\\n+    || U'\\u0FD0' != U'\\N{TIBETAN MARK BKA- SHOG GI MGO RGYAN}' \\\n+    || U'\\u0FD0' != U'\\N{TIBETAN MARK BSKA- SHOG GI MGO RGYAN}' \\\n+    || U'\\uFE18' != U'\\N{PRESENTATION FORM FOR VERTICAL RIGHT WHITE LENTICULAR BRAKCET}' \\\n+    || U'\\uFE18' != U'\\N{PRESENTATION FORM FOR VERTICAL RIGHT WHITE LENTICULAR BRACKET}' \\\n+    || U'\\uAC00' != U'\\N{HANGUL SYLLABLE GA}' \\\n+    || U'\\uAC02' != U'\\N{HANGUL SYLLABLE GAGG}' \\\n+    || U'\\uAD8D' != U'\\N{HANGUL SYLLABLE GWEONJ}' \\\n+    || U'\\uAE4D' != U'\\N{HANGUL SYLLABLE GGAG}' \\\n+    || U'\\uAE4E' != U'\\N{HANGUL SYLLABLE GGAGG}' \\\n+    || U'\\uC544' != U'\\N{HANGUL SYLLABLE A}' \\\n+    || U'\\uC55F' != U'\\N{HANGUL SYLLABLE AH}' \\\n+    || U'\\uC560' != U'\\N{HANGUL SYLLABLE AE}' \\\n+    || U'\\uD7A3' != U'\\N{HANGUL SYLLABLE HIH}' \\\n+    || U'\\u3400' != U'\\N{CJK UNIFIED IDEOGRAPH-3400}' \\\n+    || U'\\u4DBF' != U'\\N{CJK UNIFIED IDEOGRAPH-4DBF}' \\\n+    || U'\\u4E00' != U'\\N{CJK UNIFIED IDEOGRAPH-4E00}' \\\n+    || U'\\u9FFC' != U'\\N{CJK UNIFIED IDEOGRAPH-9FFC}' \\\n+    || U'\\U00020000' != U'\\N{CJK UNIFIED IDEOGRAPH-20000}' \\\n+    || U'\\U0002A6DD' != U'\\N{CJK UNIFIED IDEOGRAPH-2A6DD}' \\\n+    || U'\\U00020700' != U'\\N{CJK UNIFIED IDEOGRAPH-20700}' \\\n+    || U'\\U0002B734' != U'\\N{CJK UNIFIED IDEOGRAPH-2B734}' \\\n+    || U'\\U0002B740' != U'\\N{CJK UNIFIED IDEOGRAPH-2B740}' \\\n+    || U'\\U0002B81D' != U'\\N{CJK UNIFIED IDEOGRAPH-2B81D}' \\\n+    || U'\\U0002B820' != U'\\N{CJK UNIFIED IDEOGRAPH-2B820}' \\\n+    || U'\\U0002CEA1' != U'\\N{CJK UNIFIED IDEOGRAPH-2CEA1}' \\\n+    || U'\\U0002CEB0' != U'\\N{CJK UNIFIED IDEOGRAPH-2CEB0}' \\\n+    || U'\\U0002EBE0' != U'\\N{CJK UNIFIED IDEOGRAPH-2EBE0}' \\\n+    || U'\\U00030000' != U'\\N{CJK UNIFIED IDEOGRAPH-30000}' \\\n+    || U'\\U0003134A' != U'\\N{CJK UNIFIED IDEOGRAPH-3134A}' \\\n+    || U'\\U00017000' != U'\\N{TANGUT IDEOGRAPH-17000}' \\\n+    || U'\\U000187F7' != U'\\N{TANGUT IDEOGRAPH-187F7}' \\\n+    || U'\\U00018D00' != U'\\N{TANGUT IDEOGRAPH-18D00}' \\\n+    || U'\\U00018D08' != U'\\N{TANGUT IDEOGRAPH-18D08}' \\\n+    || U'\\U00018B00' != U'\\N{KHITAN SMALL SCRIPT CHARACTER-18B00}' \\\n+    || U'\\U00018CD5' != U'\\N{KHITAN SMALL SCRIPT CHARACTER-18CD5}' \\\n+    || U'\\U0001B170' != U'\\N{NUSHU CHARACTER-1B170}' \\\n+    || U'\\U0001B2FB' != U'\\N{NUSHU CHARACTER-1B2FB}' \\\n+    || U'\\uF900' != U'\\N{CJK COMPATIBILITY IDEOGRAPH-F900}' \\\n+    || U'\\uFA6D' != U'\\N{CJK COMPATIBILITY IDEOGRAPH-FA6D}' \\\n+    || U'\\uFA70' != U'\\N{CJK COMPATIBILITY IDEOGRAPH-FA70}' \\\n+    || U'\\uFAD9' != U'\\N{CJK COMPATIBILITY IDEOGRAPH-FAD9}' \\\n+    || U'\\U0002F800' != U'\\N{CJK COMPATIBILITY IDEOGRAPH-2F800}' \\\n+    || U'\\U0002FA1D' != U'\\N{CJK COMPATIBILITY IDEOGRAPH-2FA1D}'\n+#error Bad\n+#endif\n+\n+const char32_t *a = U\"\\N{HEBREW LETTER KAF}\\N{HEBREW LETTER FINAL NUN}\";\n+const char32_t *b = U\"\\N{OX}\\N{BOX DRAWINGS LIGHT DIAGONAL UPPER CENTRE TO MIDDLE RIGHT AND MIDDLE LEFT TO LOWER CENTRE}\";\n+\n+#define b\\N{LATIN SMALL LETTER O WITH ACUTE}x U'\\U0001FBA9'\n+\n+int\n+main ()\n+{\n+  if (a[0] != U'\\u05DB' || a[1] != U'\\U000005DF' || a[2]\n+      || b[0] != U'\\U0001F402' || b[1] != b\\u{f3}x || b[2])\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "4b1af844a3de02edbfee0c52f8ca7ef076dd8241", "filename": "gcc/testsuite/c-c++-common/cpp/named-universal-char-escape-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4879ab9053085a59b8d1594ef76487948bba7e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fnamed-universal-char-escape-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4879ab9053085a59b8d1594ef76487948bba7e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fnamed-universal-char-escape-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fnamed-universal-char-escape-2.c?ref=eb4879ab9053085a59b8d1594ef76487948bba7e", "patch": "@@ -0,0 +1,18 @@\n+/* P2071R2 - Named universal character escapes */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99 -Wno-c++-compat\" { target c } } */\n+/* { dg-options \"-std=c++23\" { target c++ } } */\n+\n+int jalape\\N{LATIN SMALL LETTER N WITH TILDE}o = 42;\n+\n+int\n+caf\\N{LATIN SMALL LETTER E WITH ACUTE} (void)\n+{\n+  return jalape\\u00F1o;\n+}\n+\n+int\n+test (void)\n+{\n+  return caf\\u00e9 ();\n+}"}, {"sha": "5985c0376ddf9a7b8e19c05715f67a1d3ffb6862", "filename": "gcc/testsuite/c-c++-common/cpp/named-universal-char-escape-3.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4879ab9053085a59b8d1594ef76487948bba7e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fnamed-universal-char-escape-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4879ab9053085a59b8d1594ef76487948bba7e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fnamed-universal-char-escape-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fnamed-universal-char-escape-3.c?ref=eb4879ab9053085a59b8d1594ef76487948bba7e", "patch": "@@ -0,0 +1,22 @@\n+/* P2071R2 - Named universal character escapes */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target wchar } */\n+/* { dg-options \"-std=gnu99 -Wno-c++-compat\" { target c } } */\n+/* { dg-options \"-std=c++23\" { target c++ } } */\n+\n+#ifndef __cplusplus\n+typedef __CHAR32_TYPE__ char32_t;\n+#endif\n+\n+const char32_t *a = U\"\\N{}\";\t\t\t\t/* { dg-error \"empty named universal character escape sequence\" } */\n+const char32_t *b = U\"\\N{NU\" \"LL}\";\t\t\t/* { dg-error \"'\\\\\\\\N\\\\{' not terminated with '\\\\}' after\" } */\n+\t\t\t\t\t\t\t/* { dg-error \"is not a valid universal character\" \"\" { target c } .-1 } */\n+const char32_t *c = U\"\\N{ I've just made it up }\";\t/* { dg-error \"'\\\\\\\\N\\\\{' not terminated with '\\\\}' after\" } */\n+\t\t\t\t\t\t\t/* { dg-error \"is not a valid universal character\" \"\" { target c } .-1 } */\n+const char32_t *d = U\"\\N{_________    _______}\";\t/* { dg-error \"is not a valid universal character\" } */\n+const char32_t *e = U\"\\N{O.X}\";\t\t\t\t/* { dg-error \"'\\\\\\\\N\\\\{' not terminated with '\\\\}' after\" } */\n+\t\t\t\t\t\t\t/* { dg-error \"is not a valid universal character\" \"\" { target c } .-1 } */\n+const char32_t *f = U\"\\N{.}\";\t\t\t\t/* { dg-error \"'\\\\\\\\N\\\\{' not terminated with '\\\\}' after\" } */\n+\t\t\t\t\t\t\t/* { dg-error \"is not a valid universal character\" \"\" { target c } .-1 } */\n+const char32_t *g = U\"\\N{BOM}\";\t\t\t\t/* { dg-error \"is not a valid universal character\" } */\n+const char32_t *h = U\"\\N{ZWNBSP}\";\t\t\t/* { dg-error \"is not a valid universal character\" } */"}, {"sha": "75fdeff5937679686fdc696bec81eb573233807e", "filename": "gcc/testsuite/c-c++-common/cpp/named-universal-char-escape-4.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4879ab9053085a59b8d1594ef76487948bba7e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fnamed-universal-char-escape-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4879ab9053085a59b8d1594ef76487948bba7e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fnamed-universal-char-escape-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fnamed-universal-char-escape-4.c?ref=eb4879ab9053085a59b8d1594ef76487948bba7e", "patch": "@@ -0,0 +1,60 @@\n+/* P2071R2 - Named universal character escapes */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target wchar } */\n+/* { dg-options \"-std=gnu99 -Wno-c++-compat\" { target c } } */\n+/* { dg-options \"-std=c++23\" { target c++ } } */\n+\n+#ifndef __cplusplus\n+typedef __CHAR32_TYPE__ char32_t;\n+#endif\n+\n+const char32_t *a = U\"\\N{ZERO WIDTH NO BREAK SPACE}\";\t\t/* { dg-error \"is not a valid universal character\" } */\n+\t\t\t\t\t\t\t\t/* { dg-message \"did you mean \\\\\\\\N\\\\{ZERO WIDTH NO-BREAK SPACE\\\\}\\\\?\" \"\" { target *-*-* } .-1 } */\n+const char32_t *b = U\"\\N{giraffe face}\";\t\t\t/* { dg-error \"is not a valid universal character\" } */\n+\t\t\t\t\t\t\t\t/* { dg-message \"did you mean \\\\\\\\N\\\\{GIRAFFE FACE\\\\}\\\\?\" \"\" { target *-*-* } .-1 } */\n+const char32_t *c = U\"\\N{Giraffe Face}\";\t\t\t/* { dg-error \"is not a valid universal character\" } */\n+\t\t\t\t\t\t\t\t/* { dg-message \"did you mean \\\\\\\\N\\\\{GIRAFFE FACE\\\\}\\\\?\" \"\" { target *-*-* } .-1 } */\n+const char32_t *d = U\"\\N{   GiRaFfE_fAcE__ ___}\";\t\t/* { dg-error \"is not a valid universal character\" } */\n+\t\t\t\t\t\t\t\t/* { dg-message \"did you mean \\\\\\\\N\\\\{GIRAFFE FACE\\\\}\\\\?\" \"\" { target *-*-* } .-1 } */\n+const char32_t *e = U\"\\N{GIRAFFE}\";\t\t\t\t/* { dg-error \"is not a valid universal character\" } */\n+const char32_t *f = U\"\\N{Hangul_Syllable_gAgg_}\";\t\t/* { dg-error \"is not a valid universal character\" } */\n+\t\t\t\t\t\t\t\t/* { dg-message \"did you mean \\\\\\\\N\\\\{HANGUL SYLLABLE GAGG\\\\}\\\\?\" \"\" { target *-*-* } .-1 } */\n+const char32_t *g = U\"\\N{HANGUL SYLLABLE gagg}\";\t\t/* { dg-error \"is not a valid universal character\" } */\n+\t\t\t\t\t\t\t\t/* { dg-message \"did you mean \\\\\\\\N\\\\{HANGUL SYLLABLE GAGG\\\\}\\\\?\" \"\" { target *-*-* } .-1 } */\n+const char32_t *h = U\"\\N{HANGULSYLLABLEGAGG}\";\t\t\t/* { dg-error \"is not a valid universal character\" } */\n+\t\t\t\t\t\t\t\t/* { dg-message \"did you mean \\\\\\\\N\\\\{HANGUL SYLLABLE GAGG\\\\}\\\\?\" \"\" { target *-*-* } .-1 } */\n+const char32_t *i = U\"\\N{HANGUL_SYLLABLE_GAGG}\";\t\t/* { dg-error \"is not a valid universal character\" } */\n+\t\t\t\t\t\t\t\t/* { dg-message \"did you mean \\\\\\\\N\\\\{HANGUL SYLLABLE GAGG\\\\}\\\\?\" \"\" { target *-*-* } .-1 } */\n+const char32_t *j = U\"\\N{HANGUL SYLLABLE }\";\t\t\t/* { dg-error \"is not a valid universal character\" } */\n+const char32_t *k = U\"\\N{CJK-COMPATIBILITY-IDEOGRAPH-2F801}\";\t/* { dg-error \"is not a valid universal character\" } */\n+\t\t\t\t\t\t\t\t/* { dg-message \"did you mean \\\\\\\\N\\\\{CJK COMPATIBILITY IDEOGRAPH-2F801\\\\}\\\\?\" \"\" { target *-*-* } .-1 } */\n+const char32_t *l = U\"\\N{CjK_COMPATIBILITY IDEOGRAPH 2f801}\";\t/* { dg-error \"is not a valid universal character\" } */\n+\t\t\t\t\t\t\t\t/* { dg-message \"did you mean \\\\\\\\N\\\\{CJK COMPATIBILITY IDEOGRAPH-2F801\\\\}\\\\?\" \"\" { target *-*-* } .-1 } */\n+const char32_t *m = U\"\\N{CjK_COMPATIBILITY IDEOGRAPH 2f80}\";\t/* { dg-error \"is not a valid universal character\" } */\n+const char32_t *n = U\"\\N{CJK COMPATIBILITY IDEOGRAPH-}\";\t/* { dg-error \"is not a valid universal character\" } */\n+const char32_t *o = U\"\\N{CJK COMPATIBILITY IDEOGRAPH-X}\";\t/* { dg-error \"is not a valid universal character\" } */\n+const char32_t *p = U\"\\N{Tibetan Letter A}\";\t\t\t/* { dg-error \"is not a valid universal character\" } */\n+\t\t\t\t\t\t\t\t/* { dg-message \"did you mean \\\\\\\\N\\\\{TIBETAN LETTER A\\\\}\\\\?\" \"\" { target *-*-* } .-1 } */\n+const char32_t *q = U\"\\N{Tibetan LetterA}\";\t\t\t/* { dg-error \"is not a valid universal character\" } */\n+\t\t\t\t\t\t\t\t/* { dg-message \"did you mean \\\\\\\\N\\\\{TIBETAN LETTER A\\\\}\\\\?\" \"\" { target *-*-* } .-1 } */\n+const char32_t *r = U\"\\N{Tibetan Letter-A}\";\t\t\t/* { dg-error \"is not a valid universal character\" } */\n+\t\t\t\t\t\t\t\t/* { dg-message \"did you mean \\\\\\\\N\\\\{TIBETAN LETTER A\\\\}\\\\?\" \"\" { target *-*-* } .-1 } */\n+const char32_t *s = U\"\\N{Tibetan Letter -A}\";\t\t\t/* { dg-error \"is not a valid universal character\" } */\n+\t\t\t\t\t\t\t\t/* { dg-message \"did you mean \\\\\\\\N\\\\{TIBETAN LETTER -A\\\\}\\\\?\" \"\" { target *-*-* } .-1 } */\n+const char32_t *t = U\"\\N{TibetanLetter  -A}\";\t\t\t/* { dg-error \"is not a valid universal character\" } */\n+\t\t\t\t\t\t\t\t/* { dg-message \"did you mean \\\\\\\\N\\\\{TIBETAN LETTER -A\\\\}\\\\?\" \"\" { target *-*-* } .-1 } */\n+const char32_t *u = U\"\\N{Hangul Jungseong oe}\";\t\t\t/* { dg-error \"is not a valid universal character\" } */\n+\t\t\t\t\t\t\t\t/* { dg-message \"did you mean \\\\\\\\N\\\\{HANGUL JUNGSEONG OE\\\\}\\\\?\" \"\" { target *-*-* } .-1 } */\n+const char32_t *v = U\"\\N{Hangul Jungseong o- e}\";\t\t/* { dg-error \"is not a valid universal character\" } */\n+\t\t\t\t\t\t\t\t/* { dg-message \"did you mean \\\\\\\\N\\\\{HANGUL JUNGSEONG O-E\\\\}\\\\?\" \"\" { target *-*-* } .-1 } */\n+const char32_t *w = U\"\\N{HangulJungseongo-e}\";\t\t\t/* { dg-error \"is not a valid universal character\" } */\n+\t\t\t\t\t\t\t\t/* { dg-message \"did you mean \\\\\\\\N\\\\{HANGUL JUNGSEONG O-E\\\\}\\\\?\" \"\" { target *-*-* } .-1 } */\n+const char32_t *x = U\"\\N{Hangul Jungseong oe          __   }\";\t/* { dg-error \"is not a valid universal character\" } */\n+\t\t\t\t\t\t\t\t/* { dg-message \"did you mean \\\\\\\\N\\\\{HANGUL JUNGSEONG OE\\\\}\\\\?\" \"\" { target *-*-* } .-1 } */\n+const char32_t *y = U\"\\N{Hangul Jungseong o- e     __      }\";\t/* { dg-error \"is not a valid universal character\" } */\n+\t\t\t\t\t\t\t\t/* { dg-message \"did you mean \\\\\\\\N\\\\{HANGUL JUNGSEONG O-E\\\\}\\\\?\" \"\" { target *-*-* } .-1 } */\n+const char32_t *z = U\"\\N{Hangul Jungseong o -e}\";\t\t/* { dg-error \"is not a valid universal character\" } */\n+\t\t\t\t\t\t\t\t/* { dg-message \"did you mean \\\\\\\\N\\\\{HANGUL JUNGSEONG O-E\\\\}\\\\?\" \"\" { target *-*-* } .-1 } */\n+const char32_t *A = U\"\\N{Hangul Jungseong o -e     __      }\";\t/* { dg-error \"is not a valid universal character\" } */\n+\t\t\t\t\t\t\t\t/* { dg-message \"did you mean \\\\\\\\N\\\\{HANGUL JUNGSEONG O-E\\\\}\\\\?\" \"\" { target *-*-* } .-1 } */\n+const char32_t *B = U\"\\N{O}\";\t\t\t\t\t/* { dg-error \"is not a valid universal character\" } */"}, {"sha": "d33fd531e7f89a52a789e7eaeb0d262d70cbf552", "filename": "gcc/testsuite/g++.dg/cpp/named-universal-char-escape-1.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4879ab9053085a59b8d1594ef76487948bba7e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fnamed-universal-char-escape-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4879ab9053085a59b8d1594ef76487948bba7e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fnamed-universal-char-escape-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fnamed-universal-char-escape-1.C?ref=eb4879ab9053085a59b8d1594ef76487948bba7e", "patch": "@@ -0,0 +1,6 @@\n+// P2071R2 - Named universal character escapes\n+// { dg-do compile { target c++11 } }\n+// { dg-require-effective-target wchar }\n+// { dg-options \"-pedantic\" }\n+\n+const char32_t *a = U\"\\N{ETHIOPIC SYLLABLE SEE}\";\t// { dg-warning \"named universal character escapes are only valid in\" \"\" { target c++20_down } }"}, {"sha": "b98a29d10fa67ed23e3b2bb3ec98ec9de15ef4b4", "filename": "gcc/testsuite/g++.dg/cpp/named-universal-char-escape-2.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4879ab9053085a59b8d1594ef76487948bba7e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fnamed-universal-char-escape-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4879ab9053085a59b8d1594ef76487948bba7e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fnamed-universal-char-escape-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fnamed-universal-char-escape-2.C?ref=eb4879ab9053085a59b8d1594ef76487948bba7e", "patch": "@@ -0,0 +1,6 @@\n+// P2071R2 - Named universal character escapes\n+// { dg-do compile { target c++11 } }\n+// { dg-require-effective-target wchar }\n+// { dg-options \"-pedantic-errors\" }\n+\n+const char32_t *a = U\"\\N{ETHIOPIC SYLLABLE SEE}\";\t// { dg-error \"named universal character escapes are only valid in\" \"\" { target c++20_down } }"}, {"sha": "d3e40724085a672d9d870a7809368a3f408524a0", "filename": "gcc/testsuite/g++.dg/cpp23/feat-cxx2b.C", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4879ab9053085a59b8d1594ef76487948bba7e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Ffeat-cxx2b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4879ab9053085a59b8d1594ef76487948bba7e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Ffeat-cxx2b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Ffeat-cxx2b.C?ref=eb4879ab9053085a59b8d1594ef76487948bba7e", "patch": "@@ -557,3 +557,9 @@\n #elif __cpp_multidimensional_subscript != 202110\n #  error \"__cpp_multidimensional_subscript != 202110\"\n #endif\n+\n+#ifndef __cpp_named_character_escapes\n+#  error \"__cpp_named_character_escapes\"\n+#elif __cpp_named_character_escapes != 202207\n+#  error \"__cpp_named_character_escapes != 202207\"\n+#endif"}, {"sha": "45193ac5b2288bfcdcc97f2ed3c3e93f87a2e1eb", "filename": "gcc/testsuite/gcc.dg/cpp/named-universal-char-escape-1.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4879ab9053085a59b8d1594ef76487948bba7e/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fnamed-universal-char-escape-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4879ab9053085a59b8d1594ef76487948bba7e/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fnamed-universal-char-escape-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fnamed-universal-char-escape-1.c?ref=eb4879ab9053085a59b8d1594ef76487948bba7e", "patch": "@@ -0,0 +1,8 @@\n+/* P2071R2 - Named universal character escapes */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target wchar } */\n+/* { dg-options \"-std=gnu99 -Wno-c++-compat -pedantic\" } */\n+\n+typedef __CHAR32_TYPE__ char32_t;\n+\n+const char32_t *a = U\"\\N{ETHIOPIC SYLLABLE SEE}\";\t/* { dg-warning \"named universal character escapes are only valid in\" } */"}, {"sha": "253620a8d6f4208465f941dd6a6db4f73b98fab1", "filename": "gcc/testsuite/gcc.dg/cpp/named-universal-char-escape-2.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4879ab9053085a59b8d1594ef76487948bba7e/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fnamed-universal-char-escape-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4879ab9053085a59b8d1594ef76487948bba7e/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fnamed-universal-char-escape-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fnamed-universal-char-escape-2.c?ref=eb4879ab9053085a59b8d1594ef76487948bba7e", "patch": "@@ -0,0 +1,8 @@\n+/* P2071R2 - Named universal character escapes */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target wchar } */\n+/* { dg-options \"-std=gnu99 -Wno-c++-compat -pedantic-errors\" } */\n+\n+typedef __CHAR32_TYPE__ char32_t;\n+\n+const char32_t *a = U\"\\N{ETHIOPIC SYLLABLE SEE}\";\t/* { dg-error \"named universal character escapes are only valid in\" } */"}, {"sha": "47a36d8b01e1ad2ee553ea9fa2c7efdf1d9d9924", "filename": "libcpp/charset.cc", "status": "modified", "additions": 487, "deletions": 48, "changes": 535, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4879ab9053085a59b8d1594ef76487948bba7e/libcpp%2Fcharset.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4879ab9053085a59b8d1594ef76487948bba7e/libcpp%2Fcharset.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fcharset.cc?ref=eb4879ab9053085a59b8d1594ef76487948bba7e", "patch": "@@ -921,6 +921,342 @@ struct ucnrange {\n /* ISO 10646 defines the UCS codespace as the range 0-0x10FFFF inclusive.  */\n #define UCS_LIMIT 0x10FFFF\n \n+#include \"uname2c.h\"\n+\n+static const char hangul_syllables[][4] = {\n+  /* L */\n+  \"G\", \"GG\", \"N\", \"D\", \"DD\", \"R\", \"M\", \"B\", \"BB\", \"S\", \"SS\", \"\",\n+  \"J\", \"JJ\", \"C\", \"K\", \"T\", \"P\", \"H\",\n+  /* V */\n+  \"A\", \"AE\", \"YA\", \"YAE\", \"EO\", \"E\", \"YEO\", \"YE\", \"O\", \"WA\", \"WAE\",\n+  \"OE\", \"YO\", \"U\", \"WEO\", \"WE\", \"WI\", \"YU\", \"EU\", \"YI\", \"I\",\n+  /* T */\n+  \"\", \"G\", \"GG\", \"GS\", \"N\", \"NJ\", \"NH\", \"D\", \"L\", \"LG\", \"LM\", \"LB\",\n+  \"LS\", \"LT\", \"LP\", \"LH\", \"M\", \"B\", \"BS\", \"S\", \"SS\", \"NG\", \"J\", \"C\",\n+  \"K\", \"T\", \"P\", \"H\"\n+};\n+\n+static const short hangul_count[6] = { 19, 21, 28 };\n+\n+/* Used for Unicode loose matching rule UAX44-LM2 matching.  */\n+\n+struct uname2c_data\n+{\n+  char *canon_name;\n+  char prev_char;\n+};\n+\n+/* Map NAME, a Unicode character name or correction/control/alternate\n+   alias, to a Unicode codepoint, or return (cppchar_t) -1 if\n+   not found.  This uses a space optimized radix tree precomputed\n+   by the makeuname2c utility, with binary format documented in its\n+   source makeuname2c.cc.  */\n+\n+static cppchar_t\n+_cpp_uname2c (const char *name, size_t len, const unsigned char *n,\n+\t      struct uname2c_data *data)\n+{\n+  do\n+    {\n+      char k;\n+      const char *key;\n+      size_t key_len, len_adj;\n+      bool has_value = *n & 0x40;\n+      bool has_children, no_sibling = false;\n+      cppchar_t codepoint = -1;\n+      const unsigned char *child = NULL;\n+      int ret;\n+\n+      if (*n & 0x80)\n+\t{\n+\t  k = ' ' + (*n++ & 0x3f);\n+\t  key = &k;\n+\t  key_len = 1;\n+\t}\n+      else\n+\t{\n+\t  key_len = *n++ & 0x3f;\n+\t  key = &uname2c_dict[*n++];\n+\t  key += (*n++ << 8);\n+\t}\n+      if (has_value)\n+\t{\n+\t  codepoint = *n + (n[1] << 8) + ((n[2] & 0x1f) << 16);\n+\t  has_children = n[2] & 0x80;\n+\t  no_sibling = n[2] & 0x40;\n+\t  n += 3;\n+\t}\n+      else\n+\thas_children = true;\n+      if (has_children)\n+\t{\n+\t  unsigned int shift = 0;\n+\t  size_t child_off = 0;\n+\n+\t  do\n+\t    {\n+\t      child_off |= (*n & 0x7f) << shift;\n+\t      shift += 7;\n+\t    }\n+\t  while ((*n++ & 0x80) != 0);\n+\t  child = n + child_off;\n+\t}\n+      if (__builtin_expect (data == NULL, 1))\n+\t{\n+\t  ret = memcmp (name, key, len > key_len ? key_len : len);\n+\t  len_adj = key_len;\n+\t}\n+      else\n+\t{\n+\t  const char *p = name, *q = key;\n+\n+\t  while (1)\n+\t    {\n+\t      if ((size_t) (p - name) == len || (size_t) (q - key) == key_len)\n+\t\tbreak;\n+\t      if (*q == ' ')\n+\t\t{\n+\t\t  ++q;\n+\t\t  continue;\n+\t\t}\n+\t      if (*q == '-')\n+\t\t{\n+\t\t  /* This is the hard case.  Only medial hyphens\n+\t\t     should be removed, where medial means preceded\n+\t\t     and followed by alnum.  */\n+\t\t  if (ISALNUM (q == key ? data->prev_char : q[-1]))\n+\t\t    {\n+\t\t      if (q + 1 == key + key_len)\n+\t\t\t{\n+\t\t\t  /* We don't know what the next letter will be.\n+\t\t\t     It could be ISALNUM, then we are supposed\n+\t\t\t     to omit it, or it could be a space and then\n+\t\t\t     we should not omit it and need to compare it.\n+\t\t\t     Fortunately the only 3 names with hyphen\n+\t\t\t     followed by non-letter are\n+\t\t\t     U+0F0A TIBETAN MARK BKA- SHOG YIG MGO\n+\t\t\t     U+0FD0 TIBETAN MARK BKA- SHOG GI MGO RGYAN\n+\t\t\t     U+0FD0 TIBETAN MARK BSKA- SHOG GI MGO RGYAN\n+\t\t\t     Furthermore, prefixes of NR2 generated\n+\t\t\t     ranges all end with a hyphen, but the generated\n+\t\t\t     part is then followed by alpha-numeric.\n+\t\t\t     So, let's just assume that - at the end of\n+\t\t\t     key is always followed by alphanumeric and\n+\t\t\t     so should be omitted.\n+\t\t\t     makeuname2c.cc verifies that this is true.  */\n+\t\t\t  ++q;\n+\t\t\t  continue;\n+\t\t\t}\n+\t\t      else if (ISALNUM (q[1]))\n+\t\t\t{\n+\t\t\t  ++q;\n+\t\t\t  continue;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      if (*p != *q)\n+\t\tbreak;\n+\t      ++p;\n+\t      ++q;\n+\t    }\n+\t  len_adj = p - name;\n+\t  /* If we don't consume the whole key, signal a mismatch,\n+\t     but always with ret = 1, so that we keep looking through\n+\t     siblings.  */\n+\t  ret = q < key + key_len;\n+\t}\n+      if (ret < 0)\n+\treturn -1;\n+      else if (ret == 0)\n+\t{\n+\t  if (len < len_adj)\n+\t    return -1;\n+\t  else if (codepoint >= 0xd800\n+\t\t   && codepoint < 0xd800 + ARRAY_SIZE (uname2c_generated))\n+\t    {\n+\t      name += len_adj;\n+\t      len -= len_adj;\n+\t      if (codepoint == 0xd800)\n+\t\t{\n+\t\t  /* NR1 - Hangul syllables.  */\n+\t\t  size_t start = 0, end, i, j;\n+\t\t  int this_len, max_len;\n+\t\t  char winner[3];\n+\n+\t\t  for (i = 0; i < 3; ++i)\n+\t\t    {\n+\t\t      end = start + hangul_count[i];\n+\t\t      max_len = -1;\n+\t\t      winner[i] = -1;\n+\t\t      for (j = start; j < end; j++)\n+\t\t\t{\n+\t\t\t  this_len = strlen (hangul_syllables[j]);\n+\t\t\t  if (len >= (size_t) this_len\n+\t\t\t      && this_len > max_len\n+\t\t\t      && memcmp (name, hangul_syllables[j],\n+\t\t\t\t\t this_len) == 0)\n+\t\t\t    {\n+\t\t\t      max_len = this_len;\n+\t\t\t      winner[i] = j - start;\n+\t\t\t    }\n+\t\t\t}\n+\t\t      if (max_len == -1)\n+\t\t\treturn -1;\n+\t\t      name += max_len;\n+\t\t      len -= max_len;\n+\t\t      start = end;\n+\t\t    }\n+\t\t  if (__builtin_expect (data != NULL, 0))\n+\t\t    {\n+\t\t      memcpy (data->canon_name, key, key_len);\n+\t\t      data->canon_name[key_len] = '\\0';\n+\t\t      for (i = 0, start = 0; i < 3; ++i)\n+\t\t\t{\n+\t\t\t  strcat (data->canon_name,\n+\t\t\t\t  hangul_syllables[start + winner[i]]);\n+\t\t\t  start += hangul_count[i];\n+\t\t\t}\n+\t\t    }\n+\t\t  return (0xac00 + 21 * 28 * winner[0]\n+\t\t\t  + 28 * winner[1] + winner[2]);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* NR2 - prefix followed by hexadecimal codepoint.  */\n+\t\t  const cppchar_t *p;\n+\t\t  size_t i;\n+\n+\t\t  if (len < 4 || len > 5)\n+\t\t    return -1;\n+\t\t  p = uname2c_pairs + uname2c_generated[codepoint - 0xd800];\n+\t\t  codepoint = 0;\n+\t\t  for (i = 0; i < len; ++i)\n+\t\t    {\n+\t\t      codepoint <<= 4;\n+\t\t      if (!ISXDIGIT (name[i]))\n+\t\t\treturn -1;\n+\t\t      codepoint += hex_value (name[i]);\n+\t\t    }\n+\t\t  for (; *p; p += 2)\n+\t\t    if (codepoint < *p)\n+\t\t      return -1;\n+\t\t    else if (codepoint <= p[1])\n+\t\t      {\n+\t\t\tif (__builtin_expect (data != NULL, 0))\n+\t\t\t  {\n+\t\t\t    memcpy (data->canon_name, key, key_len);\n+\t\t\t    memcpy (data->canon_name + key_len, name, len);\n+\t\t\t    data->canon_name[key_len + len] = '\\0';\n+\t\t\t  }\n+\t\t\treturn codepoint;\n+\t\t      }\n+\t\t  return -1;\n+\t\t}\n+\t    }\n+\t  else if (__builtin_expect (data != NULL, 0))\n+\t    {\n+\t      if (len == len_adj)\n+\t\t{\n+\t\t  memcpy (data->canon_name, key, key_len);\n+\t\t  data->canon_name[key_len] = '\\0';\n+\t\t  return codepoint;\n+\t\t}\n+\t      if (has_children)\n+\t\t{\n+\t\t  struct uname2c_data save = *data;\n+\t\t  memcpy (data->canon_name, key, key_len);\n+\t\t  data->canon_name += key_len;\n+\t\t  data->prev_char = key[key_len - 1];\n+\t\t  codepoint = _cpp_uname2c (name + len_adj, len - len_adj,\n+\t\t\t\t\t    child, data);\n+\t\t  if (codepoint != (cppchar_t) -1)\n+\t\t    return codepoint;\n+\t\t  *data = save;\n+\t\t}\n+\t    }\n+\t  else if (len == len_adj)\n+\t    return codepoint;\n+\t  else if (!has_children)\n+\t    return -1;\n+\t  else\n+\t    {\n+\t      name += len_adj;\n+\t      len -= len_adj;\n+\t      n = child;\n+\t      continue;\n+\t    }\n+\t}\n+      if (no_sibling || (!has_value && *n == 0xff))\n+\tbreak;\n+    }\n+  while (1);\n+  return -1;\n+}\n+\n+/* Try to do a loose name lookup according to Unicode loose matching rule\n+   UAX44-LM2.  First ignore medial hyphens, whitespace, underscore\n+   characters and convert to upper case.  */\n+\n+static cppchar_t\n+_cpp_uname2c_uax44_lm2 (const char *name, size_t len, char *canon_name)\n+{\n+  char name_after_uax44_lm2[uname2c_max_name_len];\n+  char *q = name_after_uax44_lm2;\n+  const char *p;\n+\n+  for (p = name; p < name + len; p++)\n+    if (*p == '_' || *p == ' ')\n+      continue;\n+    else if (*p == '-' && p != name && ISALNUM (p[-1]) && ISALNUM (p[1]))\n+      continue;\n+    else if (q == name_after_uax44_lm2 + uname2c_max_name_len)\n+      return -1;\n+    else if (ISLOWER (*p))\n+      *q++ = TOUPPER (*p);\n+    else\n+      *q++ = *p;\n+\n+  struct uname2c_data data;\n+  data.canon_name = canon_name;\n+  data.prev_char = ' ';\n+  /* Hangul Jungseong O- E after UAX44-LM2 should be HANGULJUNGSEONGO-E\n+     and so should match U+1180.  */\n+  if (q - name_after_uax44_lm2 == sizeof (\"HANGULJUNGSEONGO-E\") - 1\n+      && memcmp (name_after_uax44_lm2, \"HANGULJUNGSEONGO-E\",\n+\t\t sizeof (\"HANGULJUNGSEONGO-E\") - 1) == 0)\n+    {\n+      name_after_uax44_lm2[sizeof (\"HANGULJUNGSEONGO\") - 1] = 'E';\n+      --q;\n+    }\n+  cppchar_t result\n+    = _cpp_uname2c (name_after_uax44_lm2, q - name_after_uax44_lm2,\n+\t\t    uname2c_tree, &data);\n+\n+  /* Unicode UAX44-LM2 exception:\n+     U+116C HANGUL JUNGSEONG OE\n+     U+1180 HANGUL JUNGSEONG O-E\n+     We remove all medial hyphens when we shouldn't remote the U+1180 one.\n+     The U+1180 entry sorts before U+116C lexicographilly, so we get U+1180\n+     in both cases.  Thus, if result is U+1180, check if user's name doesn't\n+     have a hyphen there and adjust.  */\n+  if (result == 0x1180)\n+    {\n+      while (p[-1] == ' ' || p[-1] == '_')\n+\t--p;\n+      gcc_assert (TOUPPER (p[-1]) == 'E');\n+      --p;\n+      while (p[-1] == ' ' || p[-1] == '_')\n+\t--p;\n+      if (p[-1] != '-')\n+\t{\n+\t  result = 0x116c;\n+\t  memcpy (canon_name + sizeof (\"HANGUL JUNGSEONG O\") - 1, \"E\", 2);\n+\t}\n+    }\n+  return result;\n+}\n+\n+\n /* Returns 1 if C is valid in an identifier, 2 if C is valid except at\n    the start of an identifier, and 0 if C is not valid in an\n    identifier.  We assume C has already gone through the checks of\n@@ -1094,7 +1430,7 @@ _cpp_valid_ucn (cpp_reader *pfile, const uchar **pstr,\n   unsigned int length;\n   const uchar *str = *pstr;\n   const uchar *base = str - 2;\n-  bool delimited = false;\n+  bool delimited = false, named = false;\n \n   if (!CPP_OPTION (pfile, cplusplus) && !CPP_OPTION (pfile, c99))\n     cpp_error (pfile, CPP_DL_WARNING,\n@@ -1108,6 +1444,7 @@ _cpp_valid_ucn (cpp_reader *pfile, const uchar **pstr,\n \t         \"the meaning of '\\\\%c' is different in traditional C\",\n \t         (int) str[-1]);\n \n+  result = 0;\n   if (str[-1] == 'u')\n     {\n       length = 4;\n@@ -1122,44 +1459,130 @@ _cpp_valid_ucn (cpp_reader *pfile, const uchar **pstr,\n     }\n   else if (str[-1] == 'U')\n     length = 8;\n-  else\n+  else if (str[-1] == 'N')\n     {\n-      cpp_error (pfile, CPP_DL_ICE, \"In _cpp_valid_ucn but not a UCN\");\n       length = 4;\n-    }\n-\n-  result = 0;\n-  do\n-    {\n-      if (str == limit)\n-\tbreak;\n-      c = *str;\n-      if (!ISXDIGIT (c))\n-\tbreak;\n-      str++;\n-      extend_char_range (char_range, loc_reader);\n-      if (delimited)\n+      if (str == limit || *str != '{')\n+\tcpp_error (pfile, CPP_DL_ERROR, \"'\\\\N' not followed by '{'\");\n+      else\n \t{\n-\t  if (!result)\n-\t    /* Accept arbitrary number of leading zeros.\n-\t       16 is another magic value, smaller than 32 above\n-\t       and bigger than 8, so that upon encountering first\n-\t       non-zero digit we can count 8 digits and after that\n-\t       or in overflow bit and ensure length doesn't decrease\n-\t       to 0, as delimited escape sequence doesn't have upper\n-\t       bound on the number of hex digits.  */\n-\t    length = 16;\n-\t  else if (length == 16 - 8)\n+\t  str++;\n+\t  named = true;\n+\t  extend_char_range (char_range, loc_reader);\n+\t  length = 0;\n+\t  const uchar *name = str;\n+\t  bool strict = true;\n+\n+\t  do\n \t    {\n-\t      /* Make sure we detect overflows.  */\n-\t      result |= 0x8000000;\n-\t      ++length;\n+\t      if (str == limit)\n+\t\tbreak;\n+\t      c = *str;\n+\t      if (!ISIDNUM (c) && c != ' ' && c != '-')\n+\t\tbreak;\n+\t      if (ISLOWER (c) || c == '_')\n+\t\tstrict = false;\n+\t      str++;\n+\t      extend_char_range (char_range, loc_reader);\n \t    }\n-\t}\n+\t  while (1);\n \n-      result = (result << 4) + hex_value (c);\n+\t  if (str < limit && *str == '}')\n+\t    {\n+\t      if (name == str && identifier_pos)\n+\t\t{\n+\t\t  *cp = 0;\n+\t\t  return false;\n+\t\t}\n+\t      if (name == str)\n+\t\tcpp_error (pfile, CPP_DL_ERROR,\n+\t\t\t   \"empty named universal character escape sequence\");\n+\t      else if (!CPP_OPTION (pfile, delimited_escape_seqs)\n+\t\t       && CPP_OPTION (pfile, cpp_pedantic))\n+\t\tcpp_error (pfile, CPP_DL_PEDWARN,\n+\t\t\t   \"named universal character escapes are only valid \"\n+\t\t\t   \"in C++23\");\n+\t      if (name == str)\n+\t\tresult = 0x40;\n+\t      else\n+\t\t{\n+\t\t  /* If the name is longer than maximum length of a Unicode\n+\t\t     name, it can't be strictly valid.  */\n+\t\t  if ((size_t) (str - name) > uname2c_max_name_len || !strict)\n+\t\t    result = -1;\n+\t\t  else\n+\t\t    result = _cpp_uname2c ((const char *) name, str - name,\n+\t\t\t\t\t   uname2c_tree, NULL);\n+\t\t  if (result == (cppchar_t) -1)\n+\t\t    {\n+\t\t      cpp_error (pfile, CPP_DL_ERROR,\n+\t\t\t\t \"\\\\N{%.*s} is not a valid universal \"\n+\t\t\t\t \"character\", (int) (str - name), name);\n+\n+\t\t      /* Try to do a loose name lookup according to\n+\t\t\t Unicode loose matching rule UAX44-LM2.  */\n+\t\t      char canon_name[uname2c_max_name_len + 1];\n+\t\t      result = _cpp_uname2c_uax44_lm2 ((const char *) name,\n+\t\t\t\t\t\t       str - name, canon_name);\n+\t\t      if (result != (cppchar_t) -1)\n+\t\t\tcpp_error (pfile, CPP_DL_NOTE,\n+\t\t\t\t   \"did you mean \\\\N{%s}?\", canon_name);\n+\t\t      else\n+\t\t\tresult = 0x40;\n+\t\t    }\n+\t\t}\n+\t      str++;\n+\t      extend_char_range (char_range, loc_reader);\n+\t    }\n+\t  else if (identifier_pos)\n+\t    length = 1;\n+\t  else\n+\t    {\n+\t      cpp_error (pfile, CPP_DL_ERROR,\n+\t\t\t \"'\\\\N{' not terminated with '}' after %.*s\",\n+\t\t\t (int) (str - base), base);\n+\t      result = 1;\n+\t    }\n+\t}\n     }\n-  while (--length);\n+  else\n+    {\n+      cpp_error (pfile, CPP_DL_ICE, \"In _cpp_valid_ucn but not a UCN\");\n+      length = 4;\n+    }\n+\n+  if (!named)\n+    do\n+      {\n+\tif (str == limit)\n+\t  break;\n+\tc = *str;\n+\tif (!ISXDIGIT (c))\n+\t  break;\n+\tstr++;\n+\textend_char_range (char_range, loc_reader);\n+\tif (delimited)\n+\t  {\n+\t    if (!result)\n+\t      /* Accept arbitrary number of leading zeros.\n+\t\t 16 is another magic value, smaller than 32 above\n+\t\t and bigger than 8, so that upon encountering first\n+\t\t non-zero digit we can count 8 digits and after that\n+\t\t or in overflow bit and ensure length doesn't decrease\n+\t\t to 0, as delimited escape sequence doesn't have upper\n+\t\t bound on the number of hex digits.  */\n+\t      length = 16;\n+\t    else if (length == 16 - 8)\n+\t      {\n+\t\t/* Make sure we detect overflows.  */\n+\t\tresult |= 0x8000000;\n+\t\t++length;\n+\t      }\n+\t  }\n+\n+\tresult = (result << 4) + hex_value (c);\n+      }\n+    while (--length);\n \n   if (delimited\n       && str < limit\n@@ -1274,7 +1697,7 @@ convert_ucn (cpp_reader *pfile, const uchar *from, const uchar *limit,\n   /* loc_reader and ranges must either be both NULL, or both be non-NULL.  */\n   gcc_assert ((loc_reader != NULL) == (ranges != NULL));\n \n-  from++;  /* Skip u/U.  */\n+  from++;  /* Skip u/U/N.  */\n \n   /* The u/U is part of the spelling of this character.  */\n   extend_char_range (&char_range, loc_reader);\n@@ -1665,7 +2088,7 @@ convert_escape (cpp_reader *pfile, const uchar *from, const uchar *limit,\n   switch (c)\n     {\n       /* UCNs, hex escapes, and octal escapes are processed separately.  */\n-    case 'u': case 'U':\n+    case 'u': case 'U': case 'N':\n       return convert_ucn (pfile, from, limit, tbuf, cvt,\n \t\t\t  char_range, loc_reader, ranges);\n \n@@ -2256,31 +2679,47 @@ _cpp_interpret_identifier (cpp_reader *pfile, const uchar *id, size_t len)\n       *bufp++ = id[idp];\n     else\n       {\n-\tunsigned length = id[idp+1] == 'u' ? 4 : 8;\n+\tunsigned length = id[idp + 1] == 'u' ? 4 : 8;\n \tcppchar_t value = 0;\n \tsize_t bufleft = len - (bufp - buf);\n \tint rval;\n \tbool delimited = false;\n \n \tidp += 2;\n-\tif (length == 4 && id[idp] == '{')\n+\tif (id[idp - 1] == 'N' && id[idp] == '{')\n \t  {\n-\t    delimited = true;\n \t    idp++;\n+\t    const uchar *name = &id[idp];\n+\t    while (idp < len\n+\t\t   && (ISIDNUM (id[idp]) || id[idp] == ' ' || id[idp] == '-'))\n+\t      idp++;\n+\t    if (id[idp] == '}')\n+\t      {\n+\t\tvalue = _cpp_uname2c ((const char *) name, &id[idp] - name,\n+\t\t\t\t      uname2c_tree, NULL);\n+\t\tif (value == (cppchar_t) -1)\n+\t\t  value = 1;\n+\t      }\n+\t    else\n+\t      idp--;\n \t  }\n-\twhile (length && idp < len && ISXDIGIT (id[idp]))\n+\telse\n \t  {\n-\t    value = (value << 4) + hex_value (id[idp]);\n-\t    idp++;\n-\t    if (!delimited)\n-\t      length--;\n+\t    if (length == 4 && id[idp] == '{')\n+\t      {\n+\t\tdelimited = true;\n+\t\tidp++;\n+\t      }\n+\t    while (length && idp < len && ISXDIGIT (id[idp]))\n+\t      {\n+\t\tvalue = (value << 4) + hex_value (id[idp]);\n+\t\tidp++;\n+\t\tif (!delimited)\n+\t\t  length--;\n+\t      }\n+\t    if (!delimited || id[idp] != '}')\n+\t      idp--;\n \t  }\n-\tif (!delimited)\n-\t  idp--;\n-\t/* else\n-\t     assert (id[idp] == '}');\n-\t   As the caller ensures it is a valid identifier, if it is\n-\t   delimited escape sequence, it must be terminated by }.  */\n \n \t/* Special case for EBCDIC: if the identifier contains\n \t   a '$' specified using a UCN, translate it to EBCDIC.  */"}, {"sha": "528d598aeb990655bb8cb0b1e4e8bc9c9711abe9", "filename": "libcpp/lex.cc", "status": "modified", "additions": 66, "deletions": 9, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4879ab9053085a59b8d1594ef76487948bba7e/libcpp%2Flex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4879ab9053085a59b8d1594ef76487948bba7e/libcpp%2Flex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.cc?ref=eb4879ab9053085a59b8d1594ef76487948bba7e", "patch": "@@ -1512,7 +1512,7 @@ get_bidi_ucn_1 (const unsigned char *p, bool is_U, const unsigned char **end)\n }\n \n /* Parse a UCN where P points just past \\u or \\U and return its bidi code.\n-   If the kind is not NONE, write the location to *OUT.*/\n+   If the kind is not NONE, write the location to *OUT.  */\n \n static bidi::kind\n get_bidi_ucn (cpp_reader *pfile, const unsigned char *p, bool is_U,\n@@ -1529,6 +1529,56 @@ get_bidi_ucn (cpp_reader *pfile, const unsigned char *p, bool is_U,\n   return result;\n }\n \n+/* Parse a named universal character escape where P points just past \\N and\n+   return its bidi code.  If the kind is not NONE, write the location to\n+   *OUT.  */\n+\n+static bidi::kind\n+get_bidi_named (cpp_reader *pfile, const unsigned char *p, location_t *out)\n+{\n+  bidi::kind result = bidi::kind::NONE;\n+  if (*p != '{')\n+    return bidi::kind::NONE;\n+  if (strncmp ((const char *) (p + 1), \"LEFT-TO-RIGHT \", 14) == 0)\n+    {\n+      if (strncmp ((const char *) (p + 15), \"MARK}\", 5) == 0)\n+\tresult = bidi::kind::LTR;\n+      else if (strncmp ((const char *) (p + 15), \"EMBEDDING}\", 10) == 0)\n+\tresult = bidi::kind::LRE;\n+      else if (strncmp ((const char *) (p + 15), \"OVERRIDE}\", 9) == 0)\n+\tresult = bidi::kind::LRO;\n+      else if (strncmp ((const char *) (p + 15), \"ISOLATE}\", 8) == 0)\n+\tresult = bidi::kind::LRI;\n+    }\n+  else if (strncmp ((const char *) (p + 1), \"RIGHT-TO-LEFT \", 14) == 0)\n+    {\n+      if (strncmp ((const char *) (p + 15), \"MARK}\", 5) == 0)\n+\tresult = bidi::kind::RTL;\n+      else if (strncmp ((const char *) (p + 15), \"EMBEDDING}\", 10) == 0)\n+\tresult = bidi::kind::RLE;\n+      else if (strncmp ((const char *) (p + 15), \"OVERRIDE}\", 9) == 0)\n+\tresult = bidi::kind::RLO;\n+      else if (strncmp ((const char *) (p + 15), \"ISOLATE}\", 8) == 0)\n+\tresult = bidi::kind::RLI;\n+    }\n+  else if (strncmp ((const char *) (p + 1), \"POP DIRECTIONAL \", 16) == 0)\n+    {\n+      if (strncmp ((const char *) (p + 16), \"FORMATTING}\", 11) == 0)\n+\tresult = bidi::kind::PDF;\n+      else if (strncmp ((const char *) (p + 16), \"ISOLATE}\", 8) == 0)\n+\tresult = bidi::kind::PDI;\n+    }\n+  else if (strncmp ((const char *) (p + 1), \"FIRST STRONG ISOLATE}\", 21) == 0)\n+    result = bidi::kind::FSI;\n+  if (result != bidi::kind::NONE)\n+    *out = get_location_for_byte_range_in_cur_line (pfile, p - 2,\n+\t\t\t\t\t\t    (strchr ((const char *)\n+\t\t\t\t\t\t\t     (p + 1), '}')\n+\t\t\t\t\t\t     - (const char *) p)\n+\t\t\t\t\t\t    + 3);\n+  return result;\n+}\n+\n /* Subclass of rich_location for reporting on unpaired UTF-8\n    bidirectional control character(s).\n    Escape the source lines on output, and show all unclosed\n@@ -1914,16 +1964,20 @@ forms_identifier_p (cpp_reader *pfile, int first,\n \t    return true;\n \t}\n       else if (*buffer->cur == '\\\\'\n-\t       && (buffer->cur[1] == 'u' || buffer->cur[1] == 'U'))\n+\t       && (buffer->cur[1] == 'u'\n+\t\t   || buffer->cur[1] == 'U'\n+\t\t   || buffer->cur[1] == 'N'))\n \t{\n \t  buffer->cur += 2;\n \t  if (warn_bidi_p)\n \t    {\n \t      location_t loc;\n-\t      bidi::kind kind = get_bidi_ucn (pfile,\n-\t\t\t\t\t      buffer->cur,\n-\t\t\t\t\t      buffer->cur[-1] == 'U',\n-\t\t\t\t\t      &loc);\n+\t      bidi::kind kind;\n+\t      if (buffer->cur[-1] == 'N')\n+\t\tkind = get_bidi_named (pfile, buffer->cur, &loc);\n+\t      else\n+\t\tkind = get_bidi_ucn (pfile, buffer->cur,\n+\t\t\t\t     buffer->cur[-1] == 'U', &loc);\n \t      maybe_warn_bidi_on_char (pfile, kind, /*ucn_p=*/true, loc);\n \t    }\n \t  if (_cpp_valid_ucn (pfile, &buffer->cur, buffer->rlimit, 1 + !first,\n@@ -2657,11 +2711,14 @@ lex_string (cpp_reader *pfile, cpp_token *token, const uchar *base)\n       /* In #include-style directives, terminators are not escapable.  */\n       if (c == '\\\\' && !pfile->state.angled_headers && *cur != '\\n')\n \t{\n-\t  if ((cur[0] == 'u' || cur[0] == 'U') && warn_bidi_p)\n+\t  if ((cur[0] == 'u' || cur[0] == 'U' || cur[0] == 'N') && warn_bidi_p)\n \t    {\n \t      location_t loc;\n-\t      bidi::kind kind = get_bidi_ucn (pfile, cur + 1, cur[0] == 'U',\n-\t\t\t\t\t      &loc);\n+\t      bidi::kind kind;\n+\t      if (cur[0] == 'N')\n+\t\tkind = get_bidi_named (pfile, cur + 1, &loc);\n+\t      else\n+\t\tkind = get_bidi_ucn (pfile, cur + 1, cur[0] == 'U', &loc);\n \t      maybe_warn_bidi_on_char (pfile, kind, /*ucn_p=*/true, loc);\n \t    }\n \t  cur++;"}, {"sha": "f27e010dc6e5d4134e9758060fe3bc7136ace767", "filename": "libcpp/makeuname2c.cc", "status": "added", "additions": 793, "deletions": 0, "changes": 793, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4879ab9053085a59b8d1594ef76487948bba7e/libcpp%2Fmakeuname2c.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4879ab9053085a59b8d1594ef76487948bba7e/libcpp%2Fmakeuname2c.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmakeuname2c.cc?ref=eb4879ab9053085a59b8d1594ef76487948bba7e", "patch": "@@ -0,0 +1,793 @@\n+/* Make uname2c.h from various sources.\n+   Copyright (C) 2005-2022 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Run this program as\n+   ./makeuname2c UnicodeData.txt NameAliases.txt > uname2c.h\n+\n+   This program generates 2 big arrays and 2 small ones.\n+   The large ones are uname2c_dict, initialized by string literal\n+   representing dictionary, and uname2c_tree, which is a space optimized\n+   radix tree.\n+   The format of the radix tree is:\n+   byte 0\teither 0x80 + (key[0] - ' ')\t(if key_len == 1)\n+\t\tor key_len\t\t\t(otherwise)\n+\t\teither of them ored with 0x40 if it has a codepoint\n+   byte 1\tLSB of offset into uname2c_dict for key\t(only if key_len > 1)\n+   byte 2\tMSB of offset into uname2c_dict for key\t(only if key_len > 1)\n+\t\tif key_len == 1, the above 2 bytes are omitted\n+   byte 3\tLSB of codepoint (only if it has a codepoint)\n+   byte 4\tmiddle byte of codepoint (ditto)\n+   byte 5\tMSB of codepoint (ditto), ored with 0x80 if node has children\n+\t\t\t\t   ored with 0x40 if it doesn't have siblings\n+\t\tif it doesn't have a codepoint, the above 3 bytes are omitted\n+\t\tand we assume that the node has children\n+   byte 6, 7, 8\tuleb128 encoded offset to first child relative to the end\n+\t\tof the uleb128 (only if node has children)\n+   byte 9\t0xff (only if node doesn't have a codepoint and doesn't\n+\t\t      have siblings)\n+\n+   For prefixes of Unicode NR1 or NR2 rule generated names, on a node\n+   representing end of the prefix codepoint is 0xd800 + index into\n+   uname2c_generated array with indexes into uname2c_pairs array of\n+   code points (low, high) of the ranges terminated by single 0.\n+   0xd800 is NR1 rule (Hangul syllables), rest are NR2 rules.\n+*/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <stdint.h>\n+#include <ctype.h>\n+#include <limits.h>\n+#include <stdarg.h>\n+#include <stdbool.h>\n+#include <stdlib.h>\n+\n+#define ARRAY_SIZE(a) (sizeof (a) / sizeof ((a)[0]))\n+\n+#define NUM_CODE_POINTS 0x110000\n+#define MAX_CODE_POINT 0x10ffff\n+#define NO_VALUE 0xdc00\n+#define GENERATED 0xd800\n+\n+struct entry { const char *name; unsigned long codepoint; };\n+static struct entry *entries;\n+static unsigned long num_allocated, num_entries;\n+\n+/* Unicode 14 Table 4-8.  */\n+struct generated {\n+  const char *prefix;\n+  /* max_high is a workaround for UnicodeData.txt inconsistencies\n+     on a few CJK UNIFIED IDEOGRAPH- ranges where the \"*, Last>\"\n+     entry is a few code points above the end of the range.  */\n+  unsigned long low, high, max_high;\n+  int idx, ok;\n+};\n+static struct generated generated_ranges[] =\n+{ { \"HANGUL SYLLABLE \", 0xac00, 0xd7a3, 0, 0, 0 }, /* NR1 rule */\n+  { \"CJK UNIFIED IDEOGRAPH-\", 0x3400, 0x4dbf, 0, 1, 0 }, /* NR2 rules */\n+  { \"CJK UNIFIED IDEOGRAPH-\", 0x4e00, 0x9ffc, 0x9fff, 1, 0 },\n+  { \"CJK UNIFIED IDEOGRAPH-\", 0x20000, 0x2a6dd, 0x2a6df, 1, 0 },\n+  { \"CJK UNIFIED IDEOGRAPH-\", 0x2a700, 0x2b734, 0x2b738, 1, 0 },\n+  { \"CJK UNIFIED IDEOGRAPH-\", 0x2b740, 0x2b81d, 0, 1, 0 },\n+  { \"CJK UNIFIED IDEOGRAPH-\", 0x2b820, 0x2cea1, 0, 1, 0 },\n+  { \"CJK UNIFIED IDEOGRAPH-\", 0x2ceb0, 0x2ebe0, 0, 1, 0 },\n+  { \"CJK UNIFIED IDEOGRAPH-\", 0x30000, 0x3134a, 0, 1, 0 },\n+  { \"TANGUT IDEOGRAPH-\", 0x17000, 0x187f7, 0, 2, 0 },\n+  { \"TANGUT IDEOGRAPH-\", 0x18d00, 0x18d08, 0, 2, 0 },\n+  { \"KHITAN SMALL SCRIPT CHARACTER-\", 0x18b00, 0x18cd5, 0, 3, 0 },\n+  { \"NUSHU CHARACTER-\", 0x1b170, 0x1b2fb, 0, 4, 0 },\n+  { \"CJK COMPATIBILITY IDEOGRAPH-\", 0xf900, 0xfa6d, 0, 5, 0 },\n+  { \"CJK COMPATIBILITY IDEOGRAPH-\", 0xfa70, 0xfad9, 0, 5, 0 },\n+  { \"CJK COMPATIBILITY IDEOGRAPH-\", 0x2f800, 0x2fa1d, 0, 5, 0 }\n+};\n+\n+struct node {\n+  struct node *sibling, *child;\n+  const char *key;\n+  size_t key_len, key_idx, node_size, size_sum, child_off;\n+  unsigned long codepoint;\n+  bool in_dict;\n+};\n+static struct node *root, **nodes;\n+static unsigned long num_nodes;\n+static size_t dict_size, tree_size, max_entry_len;\n+static char *dict;\n+static unsigned char *tree;\n+\n+/* Die!  */\n+\n+static void\n+fail (const char *s, ...)\n+{\n+  va_list ap;\n+\n+  va_start (ap, s);\n+  vfprintf (stderr, s, ap);\n+  va_end (ap);\n+  fputc ('\\n', stderr);\n+  exit (1);\n+}\n+\n+static void *\n+xmalloc (size_t size)\n+{\n+  void *ret = malloc (size);\n+\n+  if (ret == NULL)\n+    fail (\"failed to allocate %ld bytes\", (long) size);\n+  return ret;\n+}\n+\n+static void *\n+xrealloc (void *p, size_t size)\n+{\n+  void *ret = p ? realloc (p, size) : malloc (size);\n+\n+  if (ret == NULL)\n+    fail (\"failed to allocate %ld bytes\", (long) size);\n+  return ret;\n+}\n+\n+static int\n+entrycmp (const void *p1, const void *p2)\n+{\n+  const struct entry *e1 = (const struct entry *) p1;\n+  const struct entry *e2 = (const struct entry *) p2;\n+  int ret = strcmp (e1->name, e2->name);\n+\n+  if (ret != 0)\n+    return ret;\n+  if (e1->codepoint < e2->codepoint)\n+    return -1;\n+  if (e1->codepoint > e2->codepoint)\n+    return 1;\n+  return 0;\n+}\n+\n+static int\n+nodecmp (const void *p1, const void *p2)\n+{\n+  const struct node *n1 = *(const struct node *const *) p1;\n+  const struct node *n2 = *(const struct node *const *) p2;\n+  if (n1->key_len > n2->key_len)\n+    return -1;\n+  if (n1->key_len < n2->key_len)\n+    return 1;\n+  return memcmp (n1->key, n2->key, n1->key_len);\n+}\n+\n+/* Read UnicodeData.txt and fill in the 'decomp' table to be the\n+   decompositions of characters for which both the character\n+   decomposed and all the code points in the decomposition are valid\n+   for some supported language version, and the 'all_decomp' table to\n+   be the decompositions of all characters without those\n+   constraints.  */\n+\n+static void\n+read_table (char *fname, bool aliases_p)\n+{\n+  FILE *f = fopen (fname, \"r\");\n+  const char *sname = aliases_p ? \"NameAliases.txt\" : \"UnicodeData.txt\";\n+\n+  if (!f)\n+    fail (\"opening %s\", sname);\n+  for (;;)\n+    {\n+      char line[256];\n+      unsigned long codepoint;\n+      const char *name, *aname;\n+      char *l;\n+      size_t i;\n+\n+      if (!fgets (line, sizeof (line), f))\n+\tbreak;\n+      codepoint = strtoul (line, &l, 16);\n+      if (l == line && aliases_p)\n+\t{\n+\t  /* NameAliased.txt can contain comments and empty lines.  */\n+\t  if (*line == '#' || *line == '\\n')\n+\t    continue;\n+\t}\n+      if (l == line || *l != ';')\n+\tfail (\"parsing %s, reading code point\", sname);\n+      if (codepoint > MAX_CODE_POINT)\n+\tfail (\"parsing %s, code point too large\", sname);\n+\n+      name = l + 1;\n+      do {\n+\t++l;\n+      } while (*l != ';');\n+\n+      aname = NULL;\n+      if (aliases_p)\n+\t{\n+\t  /* Ignore figment and abbreviation aliases.  */\n+\t  if (strcmp (l + 1, \"correction\\n\") != 0\n+\t      && strcmp (l + 1, \"control\\n\") != 0\n+\t      && strcmp (l + 1, \"alternate\\n\") != 0)\n+\t    continue;\n+\t  i = ARRAY_SIZE (generated_ranges);\n+\t}\n+      else\n+\t{\n+\t  for (i = 0; i < ARRAY_SIZE (generated_ranges); ++i)\n+\t    if (codepoint >= generated_ranges[i].low\n+\t\t&& codepoint <= generated_ranges[i].max_high)\n+\t      break;\n+\t  if (i != ARRAY_SIZE (generated_ranges))\n+\t    {\n+\t      if (*name == '<' && l[-1] == '>')\n+\t\t{\n+\t\t  if (codepoint == generated_ranges[i].low\n+\t\t      && l - name >= 9\n+\t\t      && memcmp (l - 8, \", First>\", 8) == 0\n+\t\t      && generated_ranges[i].ok == 0)\n+\t\t    {\n+\t\t      generated_ranges[i].ok = INT_MAX - 1;\n+\t\t      aname = generated_ranges[i].prefix;\n+\t\t      codepoint = GENERATED + generated_ranges[i].idx;\n+\t\t    }\n+\t\t  /* Unfortunately, UnicodeData.txt isn't consistent\n+\t\t     with the Table 4-8 range endpoints in 3 cases,\n+\t\t     the ranges are longer there by a few codepoints.\n+\t\t     So use the max_high hack to avoid verification\n+\t\t     failures.  */\n+\t\t  else if (codepoint == generated_ranges[i].max_high\n+\t\t\t   && l - name >= 8\n+\t\t\t   && memcmp (l - 7, \", Last>\", 7) == 0\n+\t\t\t   && generated_ranges[i].ok == INT_MAX - 1)\n+\t\t    {\n+\t\t      generated_ranges[i].ok = INT_MAX;\n+\t\t      continue;\n+\t\t    }\n+\t\t  else\n+\t\t    fail (\"unexpected generated entry %lx %.*s\",\n+\t\t\t  codepoint, (int) (l - name), name);\n+\t\t}\n+\t      else if (codepoint\n+\t\t       == generated_ranges[i].low + generated_ranges[i].ok\n+\t\t       && l - name == (strlen (generated_ranges[i].prefix)\n+\t\t\t\t       + (name - 1 - line))\n+\t\t       && memcmp (name, generated_ranges[i].prefix,\n+\t\t\t\t  strlen (generated_ranges[i].prefix)) == 0\n+\t\t       && memcmp (name + strlen (generated_ranges[i].prefix),\n+\t\t\t\t  line, name - 1 - line) == 0)\n+\t\t{\n+\t\t  ++generated_ranges[i].ok;\n+\t\t  if (codepoint != generated_ranges[i].low)\n+\t\t    continue;\n+\t\t  aname = generated_ranges[i].prefix;\n+\t\t  codepoint = GENERATED + generated_ranges[i].idx;\n+\t\t}\n+\t      else\n+\t\tfail (\"unexpected generated entry %lx %.*s\",\n+\t\t      codepoint, (int) (l - name), name);\n+\t      if (aname == generated_ranges[i].prefix)\n+\t\t{\n+\t\t  size_t j;\n+\n+\t\t  /* Don't add an entry for a generated range where the\n+\t\t     same prefix has been added already.  */\n+\t\t  for (j = 0; j < i; ++j)\n+\t\t    if (generated_ranges[j].idx == generated_ranges[i].idx\n+\t\t\t&& generated_ranges[j].ok != 0)\n+\t\t      break;\n+\t\t  if (j < i)\n+\t\t    continue;\n+\t\t}\n+\t    }\n+\t  else if (*name == '<' && l[-1] == '>')\n+\t    continue;\n+\t}\n+\n+      if (num_entries == num_allocated)\n+\t{\n+\t  num_allocated = num_allocated ? 2 * num_allocated : 65536;\n+\t  entries = (struct entry *) xrealloc (entries, num_allocated\n+\t\t\t\t\t\t\t* sizeof (entries[0]));\n+\t}\n+\n+      if (aname == NULL)\n+\t{\n+\t  char *a = (char *) xmalloc (l + 1 - name);\n+\t  if (l - name > max_entry_len)\n+\t    max_entry_len = l - name;\n+\t  memcpy (a, name, l - name);\n+\t  a[l - name] = '\\0';\n+\t  aname = a;\n+\t}\n+      entries[num_entries].name = aname;\n+      entries[num_entries++].codepoint = codepoint;\n+    }\n+  if (ferror (f))\n+    fail (\"reading %s\", sname);\n+  fclose (f);\n+}\n+\n+/* Assumes nodes are added from sorted array, so we never\n+   add any node before existing one, only after it.  */\n+\n+static void\n+node_add (struct node **p, const char *key, size_t key_len,\n+\t  unsigned long codepoint)\n+{\n+  struct node *n;\n+  size_t i;\n+\n+  do\n+    {\n+      if (*p == NULL)\n+\t{\n+\t  *p = n = (struct node *) xmalloc (sizeof (struct node));\n+\t  ++num_nodes;\n+\t  assert (key_len);\n+\t  n->sibling = NULL;\n+\t  n->child = NULL;\n+\t  n->key = key;\n+\t  n->key_len = key_len;\n+\t  n->codepoint = codepoint;\n+\t  return;\n+\t}\n+      n = *p;\n+      for (i = 0; i < n->key_len && i < key_len; ++i)\n+\tif (n->key[i] != key[i])\n+\t  break;\n+      if (i == 0)\n+\t{\n+\t  p = &n->sibling;\n+\t  continue;\n+\t}\n+      if (i == n->key_len)\n+\t{\n+\t  assert (key_len > n->key_len);\n+\t  p = &n->child;\n+\t  key += n->key_len;\n+\t  key_len -= n->key_len;\n+\t  continue;\n+\t}\n+      /* Need to split the node.  */\n+      assert (i < key_len);\n+      n = (struct node *) xmalloc (sizeof (struct node));\n+      ++num_nodes;\n+      n->sibling = NULL;\n+      n->child = (*p)->child;\n+      n->key = (*p)->key + i;\n+      n->key_len = (*p)->key_len - i;\n+      n->codepoint = (*p)->codepoint;\n+      (*p)->child = n;\n+      (*p)->key_len = i;\n+      (*p)->codepoint = NO_VALUE;\n+      key += i;\n+      key_len -= i;\n+      p = &n->sibling;\n+    }\n+  while (1);\n+}\n+\n+static void\n+append_nodes (struct node *n)\n+{\n+  for (; n; n = n->sibling)\n+    {\n+      nodes[num_nodes++] = n;\n+      append_nodes (n->child);\n+    }\n+}\n+\n+static size_t\n+sizeof_uleb128 (size_t val)\n+{\n+  size_t sz = 0;\n+  do\n+    {\n+      val >>= 7;\n+      sz += 1;\n+    }\n+  while (val != 0);\n+  return sz;\n+}\n+\n+static void\n+size_nodes (struct node *n)\n+{\n+  if (n->child)\n+    size_nodes (n->child);\n+  if (n->sibling)\n+    size_nodes (n->sibling);\n+  n->node_size = 1 + (n->key_len > 1) * 2;\n+  if (n->codepoint != NO_VALUE)\n+    n->node_size += 3;\n+  else if (n->sibling == NULL)\n+    ++n->node_size;\n+  n->size_sum = 0;\n+  n->child_off = 0;\n+  if (n->sibling)\n+    n->size_sum += n->sibling->size_sum;\n+  if (n->child)\n+    {\n+      n->child_off = n->size_sum + (n->codepoint == NO_VALUE\n+\t\t\t\t    && n->sibling == NULL);\n+      n->node_size += sizeof_uleb128 (n->child_off);\n+    }\n+  n->size_sum += n->node_size;\n+  if (n->child)\n+    n->size_sum += n->child->size_sum;\n+  tree_size += n->node_size;\n+}\n+\n+static void\n+write_uleb128 (unsigned char *p, size_t val)\n+{\n+  unsigned char c;\n+  do\n+    {\n+      c = val & 0x7f;\n+      val >>= 7;\n+      if (val)\n+\tc |= 0x80;\n+      *p++ = c;\n+    }\n+  while (val);\n+}\n+\n+static void\n+write_nodes (struct node *n, size_t off)\n+{\n+  for (; n; n = n->sibling)\n+    {\n+      assert (tree[off] == 0 && off < tree_size);\n+      if (n->key_len > 1)\n+\t{\n+\t  assert (n->key_len < 64);\n+\t  tree[off] = n->key_len;\n+\t}\n+      else\n+\ttree[off] = (n->key[0] - ' ') | 0x80;\n+      assert ((tree[off] & 0x40) == 0);\n+      if (n->codepoint != NO_VALUE)\n+\ttree[off] |= 0x40;\n+      off++;\n+      if (n->key_len > 1)\n+\t{\n+\t  tree[off++] = n->key_idx & 0xff;\n+\t  tree[off++] = (n->key_idx >> 8) & 0xff;\n+\t}\n+      if (n->codepoint != NO_VALUE)\n+\t{\n+\t  assert (n->codepoint < (1L << 21));\n+\t  tree[off++] = n->codepoint & 0xff;\n+\t  tree[off++] = (n->codepoint >> 8) & 0xff;\n+\t  tree[off] = (n->codepoint >> 16) & 0xff;\n+\t  if (n->child)\n+\t    tree[off] |= 0x80;\n+\t  if (!n->sibling)\n+\t    tree[off] |= 0x40;\n+\t  off++;\n+\t}\n+      if (n->child)\n+\t{\n+\t  write_uleb128 (&tree[off], n->child_off);\n+\t  off += sizeof_uleb128 (n->child_off);\n+\t  write_nodes (n->child, off + n->child_off);\n+\t}\n+      if (n->codepoint == NO_VALUE\n+\t  && n->sibling == NULL)\n+\ttree[off++] = 0xff;\n+    }\n+  assert (off <= tree_size);\n+}\n+\n+static void\n+build_radix_tree (void)\n+{\n+  size_t i, j, k, key_idx;\n+\n+  for (i = 0; i < ARRAY_SIZE (generated_ranges); ++i)\n+    if (generated_ranges[i].ok == INT_MAX)\n+      {\n+\tif (generated_ranges[i].max_high - generated_ranges[i].high > 15UL)\n+\t  break;\n+      }\n+    else if (generated_ranges[i].ok == (generated_ranges[i].high\n+\t\t\t\t\t- generated_ranges[i].low + 1))\n+      {\n+\tif (generated_ranges[i].max_high != generated_ranges[i].high)\n+\t  break;\n+      }\n+    else\n+      break;\n+  if (i < ARRAY_SIZE (generated_ranges))\n+    fail (\"uncovered generated range %s %lx %lx\",\n+\t  generated_ranges[i].prefix, generated_ranges[i].low,\n+\t  generated_ranges[i].high);\n+  /* Sort entries alphabetically, node_add relies on that.  */\n+  qsort (entries, num_entries, sizeof (struct entry), entrycmp);\n+  for (i = 1; i < num_entries; ++i)\n+    if (i && strcmp (entries[i].name, entries[i - 1].name) == 0)\n+      fail (\"multiple entries for name %s\", entries[i].name);\n+\n+  for (i = 0; i < num_entries; ++i)\n+    node_add (&root, entries[i].name, strlen (entries[i].name),\n+\t      entries[i].codepoint);\n+\n+  nodes = (struct node **) xmalloc (num_nodes * sizeof (struct node *));\n+  i = num_nodes;\n+  num_nodes = 0;\n+  append_nodes (root);\n+  assert (num_nodes == i);\n+  /* Sort node pointers by decreasing string length to handle substrings\n+     right.  */\n+  qsort (nodes, num_nodes, sizeof (struct node *), nodecmp);\n+  if (nodes[0]->key_len >= 64)\n+    /* We could actually encode even 64 and 65, as key_len 0 and 1 will\n+       never appear in the multiple letter key encodings, so could subtract\n+       2.  */\n+    fail (\"can't encode key length %d >= 64, so need to split some radix \"\n+\t  \"tree nodes to ensure length fits\", nodes[0]->key_len);\n+\n+  /* Verify a property charset.cc UAX44-LM2 matching relies on:\n+     if - is at the end of key of some node, then all its siblings\n+     start with alphanumeric characters.\n+     Only 2 character names and 1 alias have - followed by space:\n+     U+0F0A TIBETAN MARK BKA- SHOG YIG MGO\n+     U+0FD0 TIBETAN MARK BKA- SHOG GI MGO RGYAN\n+     U+0FD0 TIBETAN MARK BSKA- SHOG GI MGO RGYAN\n+     so the KA- in there will always be followed at least by SHOG\n+     in the same node.\n+     If this changes, charset.cc needs to change.  */\n+  for (i = 0; i < num_nodes; ++i)\n+    if (nodes[i]->key[nodes[i]->key_len - 1] == '-'\n+\t&& nodes[i]->child)\n+      {\n+\tstruct node *n;\n+\n+\tfor (n = nodes[i]->child; n; n = n->sibling)\n+\t  if (n->key[0] == ' ')\n+\t    fail (\"node with key %.*s followed by node with key %.*s\",\n+\t\t  (int) nodes[i]->key_len, nodes[i]->key,\n+\t\t  (int) n->key_len, n->key);\n+      }\n+\n+  /* This is expensive, O(num_nodes * num_nodes * nodes[0]->key_len), but\n+     fortunately num_nodes is < 64K and key_len < 64.  */\n+  key_idx = 0;\n+  for (i = 0; i < num_nodes; ++i)\n+    {\n+      nodes[i]->key_idx = SIZE_MAX;\n+      nodes[i]->in_dict = false;\n+      if (nodes[i]->key_len > 1)\n+\t{\n+\t  for (j = 0; j < i; ++j)\n+\t    /* Can't rely on memmem unfortunately.  */\n+\t    if (nodes[j]->in_dict)\n+\t      {\n+\t\tfor (k = 0; k <= nodes[j]->key_len - nodes[i]->key_len; ++k)\n+\t\t  if (nodes[j]->key[k] == nodes[i]->key[0]\n+\t\t      && memcmp (nodes[j]->key + k + 1, nodes[i]->key + 1,\n+\t\t\t\t nodes[i]->key_len - 1) == 0)\n+\t\t    {\n+\t\t      nodes[i]->key_idx = nodes[j]->key_idx + k;\n+\t\t      j = i;\n+\t\t      break;\n+\t\t    }\n+\t\tif (j == i)\n+\t\t  break;\n+\t\tfor (; k < nodes[j]->key_len; ++k)\n+\t\t  if (nodes[j]->key[k] == nodes[i]->key[0]\n+\t\t      && memcmp (nodes[j]->key + k + 1, nodes[i]->key + 1,\n+\t\t\t\t nodes[j]->key_len - 1 - k) == 0)\n+\t\t    {\n+\t\t      size_t l;\n+\n+\t\t      for (l = j + 1; l < i; ++l)\n+\t\t\tif (nodes[l]->in_dict)\n+\t\t\t  break;\n+\t\t      if (l < i\n+\t\t\t  && memcmp (nodes[l]->key,\n+\t\t\t\t     nodes[i]->key + (nodes[j]->key_len - k),\n+\t\t\t\t     nodes[i]->key_len\n+\t\t\t\t     - (nodes[j]->key_len - k)) == 0)\n+\t\t\t{\n+\t\t\t  nodes[i]->key_idx = nodes[j]->key_idx + k;\n+\t\t\t  j = i;\n+\t\t\t}\n+\t\t      else\n+\t\t\tj = l - 1;\n+\t\t      break;\n+\t\t    }\n+\t      }\n+\t  if (nodes[i]->key_idx == SIZE_MAX)\n+\t    {\n+\t      nodes[i]->key_idx = key_idx;\n+\t      nodes[i]->in_dict = true;\n+\t      key_idx += nodes[i]->key_len;\n+\t    }\n+\t}\n+    }\n+  if (key_idx >= 65536)\n+    /* We only use 2 bytes for offsets into the dictionary.\n+       If it grows more, there is e.g. a possibility to replace\n+       most often seen words or substrings in the dictionary\n+       with characters other than [A-Z0-9 -] (say LETTER occurs\n+       in the dictionary almost 197 times and so by using a\n+       instead of LETTER we could save (6 - 1) * 197 bytes,\n+       with some on the side table mapping 'a' to \"LETTER\".  */\n+    fail (\"too large dictionary %ld\", (long) key_idx);\n+  dict_size = key_idx;\n+\n+  size_nodes (root);\n+\n+  dict = (char *) xmalloc (dict_size + 1);\n+  for (i = 0; i < num_nodes; ++i)\n+    if (nodes[i]->in_dict)\n+      memcpy (dict + nodes[i]->key_idx, nodes[i]->key, nodes[i]->key_len);\n+  dict[dict_size] = '\\0';\n+\n+  tree = (unsigned char *) xmalloc (tree_size);\n+  memset (tree, 0, tree_size);\n+  write_nodes (root, 0);\n+}\n+\n+/* Print out the huge copyright notice.  */\n+\n+static void\n+write_copyright (void)\n+{\n+  static const char copyright[] = \"\\\n+/* Unicode name to codepoint.\\n\\\n+   Copyright (C) 2005-2022 Free Software Foundation, Inc.\\n\\\n+\\n\\\n+   This program is free software; you can redistribute it and/or modify it\\n\\\n+   under the terms of the GNU General Public License as published by the\\n\\\n+   Free Software Foundation; either version 3, or (at your option) any\\n\\\n+   later version.\\n\\\n+\\n\\\n+   This program is distributed in the hope that it will be useful,\\n\\\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\\\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\\\n+   GNU General Public License for more details.\\n\\\n+\\n\\\n+   You should have received a copy of the GNU General Public License\\n\\\n+   along with this program; see the file COPYING3.  If not see\\n\\\n+   <http://www.gnu.org/licenses/>.\\n\\\n+\\n\\\n+\\n\\\n+   Copyright (C) 1991-2021 Unicode, Inc.  All rights reserved.\\n\\\n+   Distributed under the Terms of Use in\\n\\\n+   http://www.unicode.org/copyright.html.\\n\\\n+\\n\\\n+   Permission is hereby granted, free of charge, to any person\\n\\\n+   obtaining a copy of the Unicode data files and any associated\\n\\\n+   documentation (the \\\"Data Files\\\") or Unicode software and any\\n\\\n+   associated documentation (the \\\"Software\\\") to deal in the Data Files\\n\\\n+   or Software without restriction, including without limitation the\\n\\\n+   rights to use, copy, modify, merge, publish, distribute, and/or\\n\\\n+   sell copies of the Data Files or Software, and to permit persons to\\n\\\n+   whom the Data Files or Software are furnished to do so, provided\\n\\\n+   that (a) the above copyright notice(s) and this permission notice\\n\\\n+   appear with all copies of the Data Files or Software, (b) both the\\n\\\n+   above copyright notice(s) and this permission notice appear in\\n\\\n+   associated documentation, and (c) there is clear notice in each\\n\\\n+   modified Data File or in the Software as well as in the\\n\\\n+   documentation associated with the Data File(s) or Software that the\\n\\\n+   data or software has been modified.\\n\\\n+\\n\\\n+   THE DATA FILES AND SOFTWARE ARE PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY\\n\\\n+   OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\\n\\\n+   WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\\n\\\n+   NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE\\n\\\n+   COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR\\n\\\n+   ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY\\n\\\n+   DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\\n\\\n+   WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS\\n\\\n+   ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE\\n\\\n+   OF THE DATA FILES OR SOFTWARE.\\n\\\n+\\n\\\n+   Except as contained in this notice, the name of a copyright holder\\n\\\n+   shall not be used in advertising or otherwise to promote the sale,\\n\\\n+   use or other dealings in these Data Files or Software without prior\\n\\\n+   written authorization of the copyright holder.  */\\n\";\n+\n+   puts (copyright);\n+}\n+\n+static void\n+write_dict (void)\n+{\n+  size_t i;\n+\n+  printf (\"static const char uname2c_dict[%ld] =\\n\", (long) (dict_size + 1));\n+  for (i = 0; i < dict_size; i += 77)\n+    printf (\"\\\"%.77s\\\"%s\\n\", dict + i, i + 76 > dict_size ? \";\" : \"\");\n+  puts (\"\");\n+}\n+\n+static void\n+write_tree (void)\n+{\n+  size_t i, j;\n+\n+  printf (\"static const unsigned char uname2c_tree[%ld] = {\\n\",\n+\t  (long) tree_size);\n+  for (i = 0, j = 0; i < tree_size; ++i)\n+    {\n+      printf (\"%s0x%02x%s\", j == 0 ? \"  \" : \"\", tree[i],\n+\t      i == tree_size - 1 ? \" };\\n\\n\" : j == 11 ? \",\\n\" : \", \");\n+      if (j == 11)\n+\tj = 0;\n+      else\n+\t++j;\n+    }\n+}\n+\n+static void\n+write_generated (void)\n+{\n+  size_t i, j;\n+\n+  puts (\"static const cppchar_t uname2c_pairs[] = {\");\n+  for (i = 0; i < ARRAY_SIZE (generated_ranges); ++i)\n+    {\n+      if (i == 0)\n+\t;\n+      else if (generated_ranges[i - 1].idx != generated_ranges[i].idx)\n+\tputs (\", 0,\");\n+      else\n+\tputs (\",\");\n+      printf (\"  0x%lx, 0x%lx /* %s */\",\n+\t      generated_ranges[i].low,\n+\t      generated_ranges[i].high,\n+\t      generated_ranges[i].prefix);\n+    }\n+  puts (\", 0 };\\n\");\n+\n+  puts (\"static const unsigned char uname2c_generated[] = {\");\n+  for (i = 0, j = -1; i < ARRAY_SIZE (generated_ranges); ++i)\n+    {\n+      if (i == 0 || generated_ranges[i - 1].idx != generated_ranges[i].idx)\n+\tprintf (\"%s  %d /* %s */\", i ? \",\\n\" : \"\",\n+\t\t++j, generated_ranges[i].prefix);\n+      j += 2;\n+    }\n+  puts (\" };\\n\");\n+}\n+\n+/* Main program.  */\n+\n+int\n+main (int argc, char **argv)\n+{\n+  size_t i;\n+\n+  if (argc != 3)\n+    fail (\"too few arguments to makeradixtree\");\n+  for (i = 0; i < ARRAY_SIZE (generated_ranges); ++i)\n+    if (!generated_ranges[i].max_high)\n+      generated_ranges[i].max_high = generated_ranges[i].high;\n+  read_table (argv[1], false);\n+  read_table (argv[2], true);\n+  build_radix_tree ();\n+\n+  write_copyright ();\n+  write_dict ();\n+  write_tree ();\n+  write_generated ();\n+  printf (\"static const unsigned int uname2c_max_name_len = %ld;\\n\\n\", max_entry_len);\n+  return 0;\n+}"}, {"sha": "43a305eccee98415576599fa7747b9c734aef8e5", "filename": "libcpp/uname2c.h", "status": "added", "additions": 18256, "deletions": 0, "changes": 18256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4879ab9053085a59b8d1594ef76487948bba7e/libcpp%2Funame2c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4879ab9053085a59b8d1594ef76487948bba7e/libcpp%2Funame2c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Funame2c.h?ref=eb4879ab9053085a59b8d1594ef76487948bba7e"}]}