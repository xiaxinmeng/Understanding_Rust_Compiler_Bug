{"sha": "7e576d70b6a1065bf31c37380a8e39354d961cd6", "node_id": "C_kwDOANBUbNoAKDdlNTc2ZDcwYjZhMTA2NWJmMzFjMzczODBhOGUzOTM1NGQ5NjFjZDY", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-04-29T13:37:44Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-04-30T12:31:12Z"}, "message": "Support recursive coercion sites\n\nOur code for coercion sites are handled in two places once where we do the\ntype-checking portion and one where we do the code-generation. This makes\nthe code-generation piece recursive so that we apply the behaviours\nconsistantly when types need checked or converted.\n\nFixes #1146", "tree": {"sha": "ff98b21d8e1560e37661a91ddd286001cb13a44c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff98b21d8e1560e37661a91ddd286001cb13a44c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e576d70b6a1065bf31c37380a8e39354d961cd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e576d70b6a1065bf31c37380a8e39354d961cd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e576d70b6a1065bf31c37380a8e39354d961cd6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e576d70b6a1065bf31c37380a8e39354d961cd6/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44c058c30dd1d36f87c36f2c487355a5736d0afc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44c058c30dd1d36f87c36f2c487355a5736d0afc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44c058c30dd1d36f87c36f2c487355a5736d0afc"}], "stats": {"total": 179, "additions": 101, "deletions": 78}, "files": [{"sha": "422526321b47e8b25b2abb6ac2cdb81c13e13caa", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e576d70b6a1065bf31c37380a8e39354d961cd6/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e576d70b6a1065bf31c37380a8e39354d961cd6/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=7e576d70b6a1065bf31c37380a8e39354d961cd6", "patch": "@@ -677,17 +677,6 @@ CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n     = ctx->get_backend ()->convert_expression (expected_fntype,\n \t\t\t\t\t       fn_vtable_access, expr_locus);\n \n-  fncontext fnctx = ctx->peek_fn ();\n-  tree enclosing_scope = ctx->peek_enclosing_scope ();\n-  bool is_address_taken = false;\n-  tree ret_var_stmt = NULL_TREE;\n-  Bvariable *fn_convert_expr_tmp\n-    = ctx->get_backend ()->temporary_variable (fnctx.fndecl, enclosing_scope,\n-\t\t\t\t\t       expected_fntype, fn_convert_expr,\n-\t\t\t\t\t       is_address_taken, expr_locus,\n-\t\t\t\t\t       &ret_var_stmt);\n-  ctx->add_statement (ret_var_stmt);\n-\n   std::vector<tree> args;\n   args.push_back (self_argument);\n   for (auto &argument : arguments)\n@@ -696,10 +685,7 @@ CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n       args.push_back (compiled_expr);\n     }\n \n-  tree fn_expr\n-    = ctx->get_backend ()->var_expression (fn_convert_expr_tmp, expr_locus);\n-\n-  return ctx->get_backend ()->call_expression (fn_expr, args, nullptr,\n+  return ctx->get_backend ()->call_expression (fn_convert_expr, args, nullptr,\n \t\t\t\t\t       expr_locus);\n }\n "}, {"sha": "5c9bbf90e66ac03f59b0f7589609d9451967a13b", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 100, "deletions": 63, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e576d70b6a1065bf31c37380a8e39354d961cd6/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e576d70b6a1065bf31c37380a8e39354d961cd6/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=7e576d70b6a1065bf31c37380a8e39354d961cd6", "patch": "@@ -202,27 +202,104 @@ HIRCompileBase::coercion_site (tree rvalue, TyTy::BaseType *actual,\n \t\t\t       TyTy::BaseType *expected, Location lvalue_locus,\n \t\t\t       Location rvalue_locus)\n {\n-  auto root_actual_kind = actual->get_root ()->get_kind ();\n-  auto root_expected_kind = expected->get_root ()->get_kind ();\n+  if (rvalue == error_mark_node)\n+    return error_mark_node;\n \n-  if (root_expected_kind == TyTy::TypeKind::ARRAY\n-      && root_actual_kind == TyTy::TypeKind::ARRAY)\n+  if (expected->get_kind () == TyTy::TypeKind::REF)\n     {\n-      tree tree_rval_type\n-\t= TyTyResolveCompile::compile (ctx, actual->get_root ());\n-      tree tree_lval_type\n-\t= TyTyResolveCompile::compile (ctx, expected->get_root ());\n+      // bad coercion... of something to a reference\n+      if (actual->get_kind () != TyTy::TypeKind::REF)\n+\treturn error_mark_node;\n+\n+      TyTy::ReferenceType *exp = static_cast<TyTy::ReferenceType *> (expected);\n+      TyTy::ReferenceType *act = static_cast<TyTy::ReferenceType *> (actual);\n+\n+      tree expected_type = TyTyResolveCompile::compile (ctx, act->get_base ());\n+      tree deref_rvalue\n+\t= ctx->get_backend ()->indirect_expression (expected_type, rvalue,\n+\t\t\t\t\t\t    false /*known_valid*/,\n+\t\t\t\t\t\t    rvalue_locus);\n+      tree coerced\n+\t= coercion_site (deref_rvalue, act->get_base (), exp->get_base (),\n+\t\t\t lvalue_locus, rvalue_locus);\n+\n+      return address_expression (coerced,\n+\t\t\t\t build_reference_type (TREE_TYPE (coerced)),\n+\t\t\t\t rvalue_locus);\n+    }\n+  else if (expected->get_kind () == TyTy::TypeKind::POINTER)\n+    {\n+      // bad coercion... of something to a reference\n+      bool valid_coercion = actual->get_kind () == TyTy::TypeKind::REF\n+\t\t\t    || actual->get_kind () == TyTy::TypeKind::POINTER;\n+      if (!valid_coercion)\n+\treturn error_mark_node;\n+\n+      TyTy::ReferenceType *exp = static_cast<TyTy::ReferenceType *> (expected);\n+\n+      TyTy::BaseType *actual_base = nullptr;\n+      tree expected_type = error_mark_node;\n+      if (actual->get_kind () == TyTy::TypeKind::REF)\n+\t{\n+\t  TyTy::ReferenceType *act\n+\t    = static_cast<TyTy::ReferenceType *> (actual);\n+\t  actual_base = act->get_base ();\n+\t  expected_type = TyTyResolveCompile::compile (ctx, act->get_base ());\n+\t}\n+      else if (actual->get_kind () == TyTy::TypeKind::POINTER)\n+\t{\n+\t  TyTy::PointerType *act = static_cast<TyTy::PointerType *> (actual);\n+\t  actual_base = act->get_base ();\n+\t  expected_type = TyTyResolveCompile::compile (ctx, act->get_base ());\n+\t}\n+      rust_assert (actual_base != nullptr);\n+\n+      tree deref_rvalue\n+\t= ctx->get_backend ()->indirect_expression (expected_type, rvalue,\n+\t\t\t\t\t\t    false /*known_valid*/,\n+\t\t\t\t\t\t    rvalue_locus);\n+      tree coerced = coercion_site (deref_rvalue, actual_base, exp->get_base (),\n+\t\t\t\t    lvalue_locus, rvalue_locus);\n+\n+      return address_expression (coerced,\n+\t\t\t\t build_pointer_type (TREE_TYPE (coerced)),\n+\t\t\t\t rvalue_locus);\n+    }\n+  else if (expected->get_kind () == TyTy::TypeKind::ARRAY)\n+    {\n+      if (actual->get_kind () != TyTy::TypeKind::ARRAY)\n+\treturn error_mark_node;\n+\n+      tree tree_rval_type = TyTyResolveCompile::compile (ctx, actual);\n+      tree tree_lval_type = TyTyResolveCompile::compile (ctx, expected);\n       if (!verify_array_capacities (tree_lval_type, tree_rval_type,\n \t\t\t\t    lvalue_locus, rvalue_locus))\n \treturn error_mark_node;\n     }\n-  else if (root_expected_kind == TyTy::TypeKind::DYNAMIC\n-\t   && root_actual_kind != TyTy::TypeKind::DYNAMIC)\n+  else if (expected->get_kind () == TyTy::TypeKind::DYNAMIC\n+\t   && actual->get_kind () != TyTy::TypeKind::DYNAMIC)\n     {\n       const TyTy::DynamicObjectType *dyn\n-\t= static_cast<const TyTy::DynamicObjectType *> (expected->get_root ());\n+\t= static_cast<const TyTy::DynamicObjectType *> (expected);\n       return coerce_to_dyn_object (rvalue, actual, expected, dyn, rvalue_locus);\n     }\n+  else if (expected->get_kind () == TyTy::TypeKind::SLICE)\n+    {\n+      // bad coercion\n+      bool valid_coercion = actual->get_kind () == TyTy::TypeKind::SLICE\n+\t\t\t    || actual->get_kind () == TyTy::TypeKind::ARRAY;\n+      if (!valid_coercion)\n+\treturn error_mark_node;\n+\n+      // nothing to do here\n+      if (actual->get_kind () == TyTy::TypeKind::SLICE)\n+\treturn rvalue;\n+\n+      // return an unsized coercion\n+      Resolver::Adjustment unsize_adj (\n+\tResolver::Adjustment::AdjustmentType::UNSIZE, expected);\n+      return resolve_unsized_adjustment (unsize_adj, rvalue, rvalue_locus);\n+    }\n \n   return rvalue;\n }\n@@ -240,70 +317,30 @@ HIRCompileBase::coerce_to_dyn_object (tree compiled_ref,\n   // __trait_object_ptr\n   // [list of function ptrs]\n \n-  auto root = actual->get_root ();\n   std::vector<std::pair<Resolver::TraitReference *, HIR::ImplBlock *>>\n-    probed_bounds_for_receiver = Resolver::TypeBoundsProbe::Probe (root);\n-\n+    probed_bounds_for_receiver = Resolver::TypeBoundsProbe::Probe (actual);\n+\n+  tree address_of_compiled_ref = null_pointer_node;\n+  if (!actual->is_unit ())\n+    address_of_compiled_ref\n+      = address_expression (compiled_ref,\n+\t\t\t    build_pointer_type (TREE_TYPE (compiled_ref)),\n+\t\t\t    locus);\n   std::vector<tree> vals;\n-  vals.push_back (compiled_ref);\n+  vals.push_back (address_of_compiled_ref);\n   for (auto &bound : ty->get_object_items ())\n     {\n       const Resolver::TraitItemReference *item = bound.first;\n       const TyTy::TypeBoundPredicate *predicate = bound.second;\n \n       auto address = compute_address_for_trait_item (item, predicate,\n \t\t\t\t\t\t     probed_bounds_for_receiver,\n-\t\t\t\t\t\t     actual, root, locus);\n+\t\t\t\t\t\t     actual, actual, locus);\n       vals.push_back (address);\n     }\n \n-  tree constructed_trait_object\n-    = ctx->get_backend ()->constructor_expression (dynamic_object, false, vals,\n-\t\t\t\t\t\t   -1, locus);\n-\n-  fncontext fnctx = ctx->peek_fn ();\n-  tree enclosing_scope = ctx->peek_enclosing_scope ();\n-  bool is_address_taken = false;\n-  tree ret_var_stmt = NULL_TREE;\n-\n-  Bvariable *dyn_tmp = ctx->get_backend ()->temporary_variable (\n-    fnctx.fndecl, enclosing_scope, dynamic_object, constructed_trait_object,\n-    is_address_taken, locus, &ret_var_stmt);\n-  ctx->add_statement (ret_var_stmt);\n-\n-  // FIXME this needs to be more generic to apply any covariance\n-\n-  auto e = expected;\n-  std::vector<Resolver::Adjustment> adjustments;\n-  while (e->get_kind () == TyTy::TypeKind::REF)\n-    {\n-      auto r = static_cast<const TyTy::ReferenceType *> (e);\n-      e = r->get_base ();\n-\n-      if (r->is_mutable ())\n-\tadjustments.push_back (\n-\t  Resolver::Adjustment (Resolver::Adjustment::AdjustmentType::MUT_REF,\n-\t\t\t\te));\n-      else\n-\tadjustments.push_back (\n-\t  Resolver::Adjustment (Resolver::Adjustment::AdjustmentType::IMM_REF,\n-\t\t\t\te));\n-    }\n-\n-  auto resulting_dyn_object_ref\n-    = ctx->get_backend ()->var_expression (dyn_tmp, locus);\n-  for (auto it = adjustments.rbegin (); it != adjustments.rend (); it++)\n-    {\n-      bool ok\n-\t= it->get_type () == Resolver::Adjustment::AdjustmentType::IMM_REF\n-\t  || it->get_type () == Resolver::Adjustment::AdjustmentType::MUT_REF;\n-      rust_assert (ok);\n-\n-      resulting_dyn_object_ref = address_expression (\n-\tresulting_dyn_object_ref,\n-\tbuild_reference_type (TREE_TYPE (resulting_dyn_object_ref)), locus);\n-    }\n-  return resulting_dyn_object_ref;\n+  return ctx->get_backend ()->constructor_expression (dynamic_object, false,\n+\t\t\t\t\t\t      vals, -1, locus);\n }\n \n tree"}]}