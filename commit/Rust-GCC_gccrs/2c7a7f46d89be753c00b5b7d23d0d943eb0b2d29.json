{"sha": "2c7a7f46d89be753c00b5b7d23d0d943eb0b2d29", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM3YTdmNDZkODliZTc1M2MwMGI1YjdkMjNkMGQ5NDNlYjBiMmQyOQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2008-10-15T16:24:15Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2008-10-15T16:24:15Z"}, "message": "[multiple changes]\n\n2008-10-15  Jan Sjodin  <jan.sjodin@amd.com>\n    \t    Harsha Jagasia  <harsha.jagasia@amd.com>\n\n\tPR tree-optimization/37485\n\t* graphite.c (gmp_cst_to_tree): Moved.\n\t(iv_stack_entry_is_constant): New.\n\t(iv_stack_entry_is_iv): New.\n\t(loop_iv_stack_push): Renamed to loop_iv_stack_push_iv.\n\t(loop_iv_stack_insert_constant): New.\n\t(loop_iv_stack_pop): Use new datatpype.\n\t(loop_iv_stack_get_iv): Same.\n\t(loop_iv_stack_get_iv_from_name): Same.\n\t(loop_iv_stack_debug): Renamed to debug_loop_iv_stack.\n\t(loop_iv_stack_patch_for_consts): New.\n\t(loop_iv_stack_remove_constants): New.\n\t(graphite_create_new_loop): Use loop_iv_stack_push_iv.\n\t(translate_clast): Call loop_iv_stack_patch_for_consts and\n\tloop_iv_stack_remove_constants.\n\t(gloog): Use new datatype.  Redirect construction edge to end\n\tblock to avoid accidental deletion.\n\t* graphite.h (enum iv_stack_entry_kind): New.  Tag for data in\n\tiv stack entry.\n\t(union iv_stack_entry_data): New.  Data in iv stack entry.\n\t(struct iv_stack_entry): New.  Datatype for iv stack entries.\n\n2008-10-15  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* tree-data-ref.c (stmt_simple_memref_p): Fix memleak.\n\t* graphite.c (free_scop): Same.\n\t(build_scops): Same.\n\t(free_scattering): New.\n\t(build_cloog_prog): Call free_scattering.\n\t(patch_phis_for_virtual_defs): Fix memleak.\n\t(graphite_trans_bb_strip_mine): Same.\n\t(limit_scops): Same.\n\nFrom-SVN: r141143", "tree": {"sha": "330d6f9c765630d4d31dbcd29bd050c5cd5fa243", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/330d6f9c765630d4d31dbcd29bd050c5cd5fa243"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c7a7f46d89be753c00b5b7d23d0d943eb0b2d29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c7a7f46d89be753c00b5b7d23d0d943eb0b2d29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c7a7f46d89be753c00b5b7d23d0d943eb0b2d29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c7a7f46d89be753c00b5b7d23d0d943eb0b2d29/comments", "author": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "575da9be0d5aea2f99b4b86ad20e10d4391aae39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/575da9be0d5aea2f99b4b86ad20e10d4391aae39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/575da9be0d5aea2f99b4b86ad20e10d4391aae39"}], "stats": {"total": 365, "additions": 308, "deletions": 57}, "files": [{"sha": "7983e984915a460c738983a9dccfa863e6535b39", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7a7f46d89be753c00b5b7d23d0d943eb0b2d29/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7a7f46d89be753c00b5b7d23d0d943eb0b2d29/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c7a7f46d89be753c00b5b7d23d0d943eb0b2d29", "patch": "@@ -1,3 +1,39 @@\n+2008-10-15  Jan Sjodin  <jan.sjodin@amd.com>\n+    \t    Harsha Jagasia  <harsha.jagasia@amd.com>\n+\n+\tPR tree-optimization/37485\n+\t* graphite.c (gmp_cst_to_tree): Moved.\n+\t(iv_stack_entry_is_constant): New.\n+\t(iv_stack_entry_is_iv): New.\n+\t(loop_iv_stack_push): Renamed to loop_iv_stack_push_iv.\n+\t(loop_iv_stack_insert_constant): New.\n+\t(loop_iv_stack_pop): Use new datatpype.\n+\t(loop_iv_stack_get_iv): Same.\n+\t(loop_iv_stack_get_iv_from_name): Same.\n+\t(loop_iv_stack_debug): Renamed to debug_loop_iv_stack.\n+\t(loop_iv_stack_patch_for_consts): New.\n+\t(loop_iv_stack_remove_constants): New.\n+\t(graphite_create_new_loop): Use loop_iv_stack_push_iv.\n+\t(translate_clast): Call loop_iv_stack_patch_for_consts and\n+\tloop_iv_stack_remove_constants.\n+\t(gloog): Use new datatype.  Redirect construction edge to end\n+\tblock to avoid accidental deletion.\n+\t* graphite.h (enum iv_stack_entry_kind): New.  Tag for data in\n+\tiv stack entry.\n+\t(union iv_stack_entry_data): New.  Data in iv stack entry.\n+\t(struct iv_stack_entry): New.  Datatype for iv stack entries.\n+\n+2008-10-15  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* tree-data-ref.c (stmt_simple_memref_p): Fix memleak.\n+\t* graphite.c (free_scop): Same.\n+\t(build_scops): Same.\n+\t(free_scattering): New.\n+\t(build_cloog_prog): Call free_scattering.\n+\t(patch_phis_for_virtual_defs): Fix memleak.\n+\t(graphite_trans_bb_strip_mine): Same.\n+\t(limit_scops): Same.\n+\n 2008-10-15  Sebastian Pop  <sebastian.pop@amd.com>\n     \t    Harsha Jagasia  <harsha.jagasia@amd.com>\n "}, {"sha": "18174eecd91fcca8dbeb14a66cc086503d973e62", "filename": "gcc/graphite.c", "status": "modified", "additions": 203, "deletions": 52, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7a7f46d89be753c00b5b7d23d0d943eb0b2d29/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7a7f46d89be753c00b5b7d23d0d943eb0b2d29/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=2c7a7f46d89be753c00b5b7d23d0d943eb0b2d29", "patch": "@@ -60,6 +60,14 @@ along with GCC; see the file COPYING3.  If not see\n \n static VEC (scop_p, heap) *current_scops;\n \n+/* Converts a GMP constant V to a tree and returns it.  */\n+\n+static tree\n+gmp_cst_to_tree (Value v)\n+{\n+  return build_int_cst (integer_type_node, value_get_si (v));\n+}\n+\n /* Debug the list of old induction variables for this SCOP.  */\n \n void\n@@ -95,34 +103,77 @@ debug_loop_vec (graphite_bb_p gb)\n   fprintf (stderr, \"\\n\");\n }\n \n+/* Returns true if stack ENTRY is a constant.  */\n+\n+static bool\n+iv_stack_entry_is_constant (iv_stack_entry *entry)\n+{\n+  return entry->kind == iv_stack_entry_const;\n+}\n+\n+/* Returns true if stack ENTRY is an induction variable.  */\n+\n+static bool\n+iv_stack_entry_is_iv (iv_stack_entry *entry)\n+{\n+  return entry->kind == iv_stack_entry_iv;\n+}\n+\n /* Push (IV, NAME) on STACK.  */\n \n static void \n-loop_iv_stack_push (loop_iv_stack stack, tree iv, const char *name)\n+loop_iv_stack_push_iv (loop_iv_stack stack, tree iv, const char *name)\n {\n+  iv_stack_entry *entry = XNEW (iv_stack_entry);\n   name_tree named_iv = XNEW (struct name_tree);\n \n   named_iv->t = iv;\n   named_iv->name = name;\n-  VEC_safe_push (name_tree, heap, *stack, named_iv);\n+\n+  entry->kind = iv_stack_entry_iv;\n+  entry->data.iv = named_iv;\n+\n+  VEC_safe_push (iv_stack_entry_p, heap, *stack, entry);\n+}\n+\n+/* Inserts a CONSTANT in STACK at INDEX.  */\n+\n+static void\n+loop_iv_stack_insert_constant (loop_iv_stack stack, int index,\n+\t\t\t       tree constant)\n+{\n+  iv_stack_entry *entry = XNEW (iv_stack_entry);\n+  \n+  entry->kind = iv_stack_entry_const;\n+  entry->data.constant = constant;\n+\n+  VEC_safe_insert (iv_stack_entry_p, heap, *stack, index, entry);\n }\n \n-/* Pops an element out of STACK.  */\n+/* Pops and frees an element out of STACK.  */\n \n static void\n loop_iv_stack_pop (loop_iv_stack stack)\n {\n-  VEC_pop (name_tree, *stack);\n+  iv_stack_entry_p entry = VEC_pop (iv_stack_entry_p, *stack);\n+\n+  free (entry->data.iv);\n+  free (entry);\n }\n \n /* Get the IV at INDEX in STACK.  */\n \n static tree\n loop_iv_stack_get_iv (loop_iv_stack stack, int index)\n {\n-  name_tree named_iv = VEC_index (name_tree, *stack, index);\n+  iv_stack_entry_p entry = VEC_index (iv_stack_entry_p, *stack, index);\n+\n+  tree result = NULL;\n+\n+  if (entry->kind != iv_stack_entry_const)\n+    result = entry->data.iv->t;\n \n-  return named_iv->t;\n+  return result;\n }\n \n /* Get the IV from its NAME in STACK.  */\n@@ -131,39 +182,117 @@ static tree\n loop_iv_stack_get_iv_from_name (loop_iv_stack stack, const char* name)\n {\n   int i;\n-  name_tree iv;\n+  iv_stack_entry_p entry;\n \n-  for (i = 0; VEC_iterate (name_tree, *stack, i, iv); i++)\n-    if (!strcmp (name, iv->name))\n-      return iv->t;\n+  for (i = 0; VEC_iterate (iv_stack_entry_p, *stack, i, entry); i++)\n+    {\n+      name_tree iv = entry->data.iv;\n+      if (!strcmp (name, iv->name))\n+\treturn iv->t;\n+    }\n \n   return NULL;\n }\n \n /* Prints on stderr the contents of STACK.  */\n \n void\n-loop_iv_stack_debug (loop_iv_stack stack)\n+debug_loop_iv_stack (loop_iv_stack stack)\n {\n   int i;\n-  name_tree iv;\n+  iv_stack_entry_p entry;\n   bool first = true;\n \n   fprintf (stderr, \"(\");\n \n-  for (i = 0; VEC_iterate (name_tree, *stack, i, iv); i++)\n+  for (i = 0; VEC_iterate (iv_stack_entry_p, *stack, i, entry); i++)\n     {\n       if (first) \n \tfirst = false;\n       else\n \tfprintf (stderr, \" \");\n-      fprintf (stderr, \"%s:\", iv->name);\n-      print_generic_expr (stderr, iv->t, 0);\n+\n+      if (iv_stack_entry_is_iv (entry))\n+\t{\n+\t  name_tree iv = entry->data.iv;\n+\t  fprintf (stderr, \"%s:\", iv->name);\n+\t  print_generic_expr (stderr, iv->t, 0);\n+\t}\n+      else \n+\t{\n+\t  tree constant = entry->data.constant;\n+\t  print_generic_expr (stderr, constant, 0);\n+\t  fprintf (stderr, \":\");\n+\t  print_generic_expr (stderr, constant, 0);\n+\t}\n     }\n \n   fprintf (stderr, \")\\n\");\n }\n \n+/* Frees STACK.  */\n+\n+static void\n+free_loop_iv_stack (loop_iv_stack stack)\n+{\n+  int i;\n+  iv_stack_entry_p entry;\n+\n+  for (i = 0; VEC_iterate (iv_stack_entry_p, *stack, i, entry); i++)\n+    {\n+      free (entry->data.iv);\n+      free (entry);\n+    }\n+\n+  VEC_free (iv_stack_entry_p, heap, *stack);\n+}\n+\n+/* Inserts constants derived from the USER_STMT argument list into the\n+   STACK.  This is needed to map old ivs to constants when loops have\n+   been eliminated.  */\n+\n+static void \n+loop_iv_stack_patch_for_consts (loop_iv_stack stack,\n+\t\t\t\tstruct clast_user_stmt *user_stmt)\n+{\n+  struct clast_stmt *t;\n+  int index = 0;\n+  for (t = user_stmt->substitutions; t; t = t->next) \n+    {\n+      struct clast_term *term = (struct clast_term*) \n+\t((struct clast_assignment *)t)->RHS;\n+\n+      /* FIXME: What should be done with expr_bin, expr_red?  */\n+      if (((struct clast_assignment *)t)->RHS->type == expr_term\n+\t  && !term->var)\n+\t{\n+\t  tree value = gmp_cst_to_tree (term->val);\n+\t  loop_iv_stack_insert_constant (stack, index, value);\n+\t}\n+      index = index + 1;\n+    }\n+}\n+\n+/* Removes all constants in the iv STACK.  */\n+\n+static void\n+loop_iv_stack_remove_constants (loop_iv_stack stack)\n+{\n+  int i;\n+  iv_stack_entry *entry;\n+  \n+  for (i = 0; VEC_iterate (iv_stack_entry_p, *stack, i, entry);)\n+    {\n+      if (iv_stack_entry_is_constant (entry))\n+\t{\n+\t  free (VEC_index (iv_stack_entry_p, *stack, i));\n+\t  VEC_ordered_remove (iv_stack_entry_p, *stack, i);\n+\t}\n+      else\n+\ti++;\n+    }\n+}\n+\n /* In SCOP, get the induction variable from NAME.  OLD is the original\n    loop that contained the definition of NAME.  */\n \n@@ -939,6 +1068,7 @@ free_scop (scop_p scop)\n   int i;\n   name_tree p;\n   struct graphite_bb *gb;\n+  name_tree iv;\n \n   for (i = 0; VEC_iterate (graphite_bb_p, SCOP_BBS (scop), i, gb); i++)\n     free_graphite_bb (gb);\n@@ -947,6 +1077,9 @@ free_scop (scop_p scop)\n   BITMAP_FREE (SCOP_BBS_B (scop));\n   BITMAP_FREE (SCOP_LOOPS (scop));\n   VEC_free (loop_p, heap, SCOP_LOOP_NEST (scop));\n+\n+  for (i = 0; VEC_iterate (name_tree, SCOP_OLDIVS (scop), i, iv); i++)\n+    free (iv);\n   VEC_free (name_tree, heap, SCOP_OLDIVS (scop));\n   \n   for (i = 0; VEC_iterate (name_tree, SCOP_PARAMS (scop), i, p); i++)\n@@ -1688,6 +1821,7 @@ build_scops (void)\n   build_scops_1 (single_succ (ENTRY_BLOCK_PTR), &tmp_scops, loop);\n   create_sese_edges (tmp_scops);\n   build_graphite_scops (tmp_scops);\n+  VEC_free (sd_region, heap, tmp_scops);\n }\n \n /* Gather the basic blocks belonging to the SCOP.  */\n@@ -2433,7 +2567,7 @@ build_loop_iteration_domains (scop_p scop, struct loop *loop,\n         value_assign (cstr->p[i][j], outer_cstr->p[i][j]);\n \n       /* Leave an empty column in CSTR for the current loop, and then\n-        copy the parameter columns.  */\n+\t copy the parameter columns.  */\n       for (j = loop_col; j < outer_cstr->NbColumns; j++)\n         value_assign (cstr->p[i][j + 1], outer_cstr->p[i][j]);\n     }\n@@ -2861,10 +2995,10 @@ build_scop_iteration_domain (scop_p scop)\n            -first column: eq/ineq boolean\n            -last column: a constant\n            -scop_nb_params columns for the parameters used in the scop.  */\n-       outer_cstr = cloog_matrix_alloc (0, scop_nb_params (scop) + 2);\n-       build_loop_iteration_domains (scop, loop, outer_cstr, 0);\n-       cloog_matrix_free (outer_cstr);\n-     }\n+\touter_cstr = cloog_matrix_alloc (0, scop_nb_params (scop) + 2);\n+\tbuild_loop_iteration_domains (scop, loop, outer_cstr, 0);\n+\tcloog_matrix_free (outer_cstr);\n+      }\n \n   return (i != 0);\n }\n@@ -2988,14 +3122,6 @@ build_scop_data_accesses (scop_p scop)\n     }\n }\n \n-/* Converts a GMP constant value to a tree and returns it.  */\n-\n-static tree\n-gmp_cst_to_tree (Value v)\n-{\n-  return build_int_cst (integer_type_node, value_get_si (v));\n-}\n-\n /* Returns the tree variable from the name NAME that was given in\n    Cloog representation.  All the parameters are stored in PARAMS, and\n    all the loop induction variables are stored in IVSTACK.\n@@ -3250,7 +3376,7 @@ graphite_create_new_loop (scop_p scop, edge entry_edge,\n \t\t\t\t    &iv_before, outer ? outer\n \t\t\t\t    : entry_edge->src->loop_father);\n \n-  loop_iv_stack_push (ivstack, iv_before, stmt->iterator);\n+  loop_iv_stack_push_iv (ivstack, iv_before, stmt->iterator);\n \n   return loop;\n }\n@@ -3347,9 +3473,10 @@ expand_scalar_variables_expr (tree type, tree op0, enum tree_code code,\n \t\t\t      tree op1, graphite_bb_p gbb, scop_p scop, \n \t\t\t      loop_p old_loop_father, loop_iv_stack ivstack)\n {\n-  if (TREE_CODE_CLASS (code) == tcc_constant\n-      && code == INTEGER_CST)\n-      return op0;\n+  if ((TREE_CODE_CLASS (code) == tcc_constant\n+       && code == INTEGER_CST)\n+      || TREE_CODE_CLASS (code) == tcc_reference)\n+    return op0;\n \n   if (TREE_CODE_CLASS (code) == tcc_unary)\n     {\n@@ -3596,8 +3723,11 @@ translate_clast (scop_p scop, struct loop *context_loop,\n       mark_virtual_ops_in_bb (bb);\n       next_e = make_edge (bb,\n \t\t\t  context_loop ? context_loop->latch : EXIT_BLOCK_PTR,\n-\t\t\t  EDGE_FALLTHRU);;\n+\t\t\t  EDGE_FALLTHRU);\n+      loop_iv_stack_patch_for_consts (ivstack,\n+\t\t\t\t      (struct clast_user_stmt *) stmt);\n       graphite_rename_ivs (gbb, scop, old_loop_father, ivstack);\n+      loop_iv_stack_remove_constants (ivstack);\n       return translate_clast (scop, context_loop, stmt->next, next_e, ivstack);\n     }\n \n@@ -3643,6 +3773,22 @@ translate_clast (scop_p scop, struct loop *context_loop,\n   gcc_unreachable ();\n }\n \n+/* Free the SCATTERING domain list.  */\n+\n+static void\n+free_scattering (CloogDomainList *scattering)\n+{\n+  while (scattering)\n+    {\n+      CloogDomain *dom = cloog_domain (scattering);\n+      CloogDomainList *next = cloog_next_domain (scattering);\n+\n+      cloog_domain_free (dom);\n+      free (scattering);\n+      scattering = next;\n+    }\n+}\n+\n /* Build cloog program for SCoP.  */\n \n static void\n@@ -3725,6 +3871,7 @@ build_cloog_prog (scop_p scop)\n \n   /* Apply scattering.  */\n   cloog_program_scatter (prog, scattering);\n+  free_scattering (scattering);\n \n   /* Iterators corresponding to scalar dimensions have to be extracted.  */\n   cloog_names_scalarize (cloog_program_names (prog), nbs,\n@@ -3806,7 +3953,6 @@ debug_clast_stmt (struct clast_stmt *stmt)\n static struct clast_stmt *\n find_transform (scop_p scop)\n {\n-  CloogProgram *prog;\n   struct clast_stmt *stmt;\n   CloogOptions *options = set_cloog_options ();\n \n@@ -3820,14 +3966,14 @@ find_transform (scop_p scop)\n       fprintf (dump_file, \"]\\n\");\n     }\n \n-  prog = cloog_program_generate (SCOP_PROG (scop), options);\n-  stmt = cloog_clast_create (prog, options);\n+  SCOP_PROG (scop) = cloog_program_generate (SCOP_PROG (scop), options);\n+  stmt = cloog_clast_create (SCOP_PROG (scop), options);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Cloog Output[\\n\");\n       pprint (dump_file, stmt, 0, options);\n-      cloog_program_dump_cloog (dump_file, prog);\n+      cloog_program_dump_cloog (dump_file, SCOP_PROG (scop));\n       fprintf (dump_file, \"]\\n\");\n     }\n \n@@ -3964,6 +4110,8 @@ patch_phis_for_virtual_defs (void)\n       gsi = gsi_for_stmt (phi);\n       remove_phi_node (&gsi, false);\n     }\n+\n+  VEC_free (gimple, heap, virtual_phis);\n }\n \n /* Mark the original loops of SCOP for removal, replacing their header\n@@ -4132,9 +4280,10 @@ gloog (scop_p scop, struct clast_stmt *stmt)\n {\n   edge new_scop_exit_edge = NULL;\n   basic_block scop_exit = SCOP_EXIT (scop);\n-  VEC (tree, heap)* phi_args = \n+  VEC (tree, heap) *phi_args =\n     collect_scop_exit_phi_args (SESE_EXIT (SCOP_REGION (scop)));\n-  VEC (name_tree, heap) *ivstack = VEC_alloc (name_tree, heap, 10);\n+  VEC (iv_stack_entry_p, heap) *ivstack = \n+    VEC_alloc (iv_stack_entry_p, heap, 10);\n   edge construction_edge = SESE_ENTRY (SCOP_REGION (scop));\n   basic_block old_scop_exit_idom = get_immediate_dominator (CDI_DOMINATORS,\n \t\t\t\t\t\t\t    scop_exit);\n@@ -4145,10 +4294,13 @@ gloog (scop_p scop, struct clast_stmt *stmt)\n       return;\n     }\n \n+  redirect_edge_succ_nodup (construction_edge, EXIT_BLOCK_PTR);\n   new_scop_exit_edge = translate_clast (scop, \n \t\t\t\t\tconstruction_edge->src->loop_father,\n \t\t\t\t\tstmt, construction_edge, &ivstack);\n+  free_loop_iv_stack (&ivstack);\n   redirect_edge_succ (new_scop_exit_edge, scop_exit);\n+\n   if (!old_scop_exit_idom\n       || !dominated_by_p (CDI_DOMINATORS, SCOP_ENTRY (scop),\n \t\t\t  old_scop_exit_idom)\n@@ -4165,6 +4317,7 @@ gloog (scop_p scop, struct clast_stmt *stmt)\n   delete_unreachable_blocks ();\n   patch_phis_for_virtual_defs ();\n   patch_scop_exit_phi_args (new_scop_exit_edge, phi_args);\n+  VEC_free (tree, heap, phi_args);\n   mark_old_loops (scop);\n   remove_dead_loops ();\n   rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa); \n@@ -4416,7 +4569,6 @@ static void\n get_lower_bound (CloogMatrix *domain, int loop, Value lower_bound_result)\n {\n   int lower_bound_row = get_lower_bound_row (domain, loop);\n-  value_init (lower_bound_result);\n   value_assign (lower_bound_result,\n \t\tdomain->p[lower_bound_row][const_column_index(domain)]);\n }\n@@ -4427,7 +4579,6 @@ static void\n get_upper_bound (CloogMatrix *domain, int loop, Value upper_bound_result)\n {\n   int upper_bound_row = get_upper_bound_row (domain, loop);\n-  value_init (upper_bound_result);\n   value_assign (upper_bound_result,\n \t\tdomain->p[upper_bound_row][const_column_index(domain)]);\n }\n@@ -4450,7 +4601,6 @@ graphite_trans_bb_strip_mine (graphite_bb_p gb, int loop_depth, int stride)\n   Value old_lower_bound;\n   Value old_upper_bound;\n \n-\n   gcc_assert (loop_depth <= gbb_nb_loops (gb) - 1);\n \n   VEC_safe_insert (loop_p, heap, GBB_LOOPS (gb), loop_depth, NULL);\n@@ -4470,13 +4620,9 @@ graphite_trans_bb_strip_mine (graphite_bb_p gb, int loop_depth, int stride)\n   for (row = 0; row < domain->NbRows; row++)\n     for (col = 0; col < domain->NbColumns; col++)\n       if (col <= loop_depth)\n-        {\n-          value_assign (new_domain->p[row][col], domain->p[row][col]);\n-        }\n+\tvalue_assign (new_domain->p[row][col], domain->p[row][col]);\n       else\n-        {\n-          value_assign (new_domain->p[row][col + 1], domain->p[row][col]);\n-        }\n+\tvalue_assign (new_domain->p[row][col + 1], domain->p[row][col]);\n \n \n   /*\n@@ -4495,7 +4641,8 @@ graphite_trans_bb_strip_mine (graphite_bb_p gb, int loop_depth, int stride)\n   row = domain->NbRows;\n \n   /* Add outer loop.  */\n-\n+  value_init (old_lower_bound);\n+  value_init (old_upper_bound);\n   get_lower_bound (new_domain, col_loop_old, old_lower_bound);\n   get_upper_bound (new_domain, col_loop_old, old_upper_bound);\n \n@@ -4504,6 +4651,7 @@ graphite_trans_bb_strip_mine (graphite_bb_p gb, int loop_depth, int stride)\n   value_set_si (new_domain->p[row][col_loop_strip], 1);\n   value_assign (new_domain->p[row][const_column_index (new_domain)],\n \t\told_lower_bound);\n+  value_clear (old_lower_bound);\n   row++;\n \n \n@@ -4524,19 +4672,21 @@ graphite_trans_bb_strip_mine (graphite_bb_p gb, int loop_depth, int stride)\n     Value strip_size_value;\n \n     value_init (new_upper_bound);\n-\n     value_init (strip_size_value);\n     value_set_si (strip_size_value, (int) stride);\n \n-  \n-    value_pdivision(new_upper_bound,old_upper_bound,strip_size_value);\n+    value_pdivision (new_upper_bound, old_upper_bound, strip_size_value);\n     value_add_int (new_upper_bound, new_upper_bound, 1);\n \n     /* Set Upper Bound */\n     value_set_si (new_domain->p[row][0], 1);\n     value_set_si (new_domain->p[row][col_loop_strip], -1);\n     value_assign (new_domain->p[row][const_column_index (new_domain)],\n \t\t  new_upper_bound);\n+\n+    value_clear (strip_size_value);\n+    value_clear (old_upper_bound);\n+    value_clear (new_upper_bound);\n     row++;\n   }\n   /*\n@@ -4983,6 +5133,7 @@ limit_scops (void)\n \n   create_sese_edges (tmp_scops);\n   build_graphite_scops (tmp_scops);\n+  VEC_free (sd_region, heap, tmp_scops);\n }\n \n /* Perform a set of linear transforms on the loops of the current"}, {"sha": "2e2904a6abf9c9976dc56402299eef28e7efd2a1", "filename": "gcc/graphite.h", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7a7f46d89be753c00b5b7d23d0d943eb0b2d29/gcc%2Fgraphite.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7a7f46d89be753c00b5b7d23d0d943eb0b2d29/gcc%2Fgraphite.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.h?ref=2c7a7f46d89be753c00b5b7d23d0d943eb0b2d29", "patch": "@@ -260,7 +260,7 @@ typedef struct name_tree\n {\n   tree t;\n   const char *name;\n-  struct loop* loop;\n+  struct loop *loop;\n } *name_tree;\n \n DEF_VEC_P(name_tree);\n@@ -340,8 +340,34 @@ extern void debug_clast_stmt (struct clast_stmt *);\n extern void debug_loop_vec (graphite_bb_p gb);\n extern void debug_oldivs (scop_p);\n \n-typedef VEC(name_tree, heap) **loop_iv_stack;\n-extern void loop_iv_stack_debug (loop_iv_stack);\n+/* Describes the type of an iv stack entry.  */\n+typedef enum {\n+  iv_stack_entry_unknown = 0,\n+  iv_stack_entry_iv,\n+  iv_stack_entry_const\n+} iv_stack_entry_kind;\n+\n+/* Data contained in an iv stack entry.  */\n+typedef union iv_stack_entry_data_union\n+{\n+  name_tree iv;\n+  tree constant;\n+} iv_stack_entry_data;\n+\n+/* Datatype for loop iv stack entry.  */\n+typedef struct iv_stack_entry_struct\n+{\n+  iv_stack_entry_kind kind;\n+  iv_stack_entry_data data;\n+} iv_stack_entry;\n+\n+typedef iv_stack_entry *iv_stack_entry_p;\n+\n+DEF_VEC_P(iv_stack_entry_p);\n+DEF_VEC_ALLOC_P(iv_stack_entry_p,heap);\n+\n+typedef VEC(iv_stack_entry_p, heap) **loop_iv_stack;\n+extern void debug_loop_iv_stack (loop_iv_stack);\n \n \n /* Return the number of gimple loops contained in SCOP.  */"}, {"sha": "2647c9551086a091405afdeef7fe47c9c13df33b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7a7f46d89be753c00b5b7d23d0d943eb0b2d29/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7a7f46d89be753c00b5b7d23d0d943eb0b2d29/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2c7a7f46d89be753c00b5b7d23d0d943eb0b2d29", "patch": "@@ -1,3 +1,9 @@\n+2008-10-15  Jan Sjodin  <jan.sjodin@amd.com>\n+    \t    Harsha Jagasia  <harsha.jagasia@amd.com>\n+\n+\tPR tree-optimization/37485\n+\t* gcc.dg/graphite/pr37485.c: New.\n+\n 2008-10-15  Sebastian Pop  <sebastian.pop@amd.com>\n     \t    Harsha Jagasia  <harsha.jagasia@amd.com>\n "}, {"sha": "67661910ba2de7c6dd26d562e27b0a66ac4f54e8", "filename": "gcc/testsuite/gcc.dg/graphite/pr37485.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7a7f46d89be753c00b5b7d23d0d943eb0b2d29/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37485.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7a7f46d89be753c00b5b7d23d0d943eb0b2d29/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37485.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37485.c?ref=2c7a7f46d89be753c00b5b7d23d0d943eb0b2d29", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-options \"-O2 -floop-block -fdump-tree-graphite-all\" } */\n+\n+typedef unsigned char   UChar;\n+typedef int             Int32;\n+typedef unsigned int    UInt32;\n+\n+void fallbackSort ( UInt32* fmap, \n+                    UInt32* eclass, \n+                    Int32   nblock,\n+                    Int32   verb )\n+{\n+   Int32 ftab[257];\n+   Int32 ftabCopy[256];\n+   Int32 H, i, j, k, l, r, cc, cc1;\n+   Int32 nNotDone;\n+   Int32 nBhtab;\n+   UChar* eclass8 = (UChar*)eclass;\n+\n+   if (verb >= 4)\n+      VPrintf0 ( \"        bucket sorting ...\\n\" );\n+   for (i = 0; i < 257;    i++) ftab[i] = 0;\n+   for (i = 0; i < nblock; i++) ftab[eclass8[i]]++;\n+   for (i = 0; i < 256;    i++) ftabCopy[i] = ftab[i];\n+   for (i = 1; i < 257;    i++) ftab[i] += ftab[i-1];\n+\n+   for (i = 0; i < nblock; i++) {\n+      j = eclass8[i] + ftab [i];\n+   }\n+   AssertH ( j < 256, 1005 );\n+}\n+/* { dg-final { scan-tree-dump-times \"Loop blocked\" 1 \"graphite\" { xfail *-*-* }} } */"}, {"sha": "94124141a2562a806a98db96668b1cc8386b9afa", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7a7f46d89be753c00b5b7d23d0d943eb0b2d29/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7a7f46d89be753c00b5b7d23d0d943eb0b2d29/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=2c7a7f46d89be753c00b5b7d23d0d943eb0b2d29", "patch": "@@ -3311,13 +3311,14 @@ bool\n stmt_simple_memref_p (struct loop *loop, gimple stmt, tree op)\n {\n   data_reference_p dr;\n+  bool res = true;\n \n   dr = create_data_ref (loop, op, stmt, true);\n   if (!access_functions_are_affine_or_constant_p (dr, loop))\n-    return false;\n+    res = false;\n \n   free_data_ref (dr);\n-  return true;\n+  return res;\n }\n \n /* Initializes an equation for an OMEGA problem using the information"}]}