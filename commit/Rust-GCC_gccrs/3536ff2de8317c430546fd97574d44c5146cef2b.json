{"sha": "3536ff2de8317c430546fd97574d44c5146cef2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzUzNmZmMmRlODMxN2M0MzA1NDZmZDk3NTc0ZDQ0YzUxNDZjZWYyYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-09-03T10:51:01Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-09-03T10:51:01Z"}, "message": "lto: Cache location_ts including BLOCKs in GIMPLE streaming [PR94311]\n\nAs mentioned in the PR, when compiling valgrind even on fairly small\ntestcase where in one larger function the location keeps oscillating\nbetween a small line number and 8000-ish line number in the same file\nwe very quickly run out of all possible location_t numbers and because of\nthat emit non-sensical line numbers in .debug_line.\nThere are ways how to decrease speed of depleting location_t numbers\nin libcpp, but the main reason of this is that we use\nstream_input_location_now for streaming in location_t for gimple_location\nand phi arg locations.  libcpp strongly prefers that the locations\nit is given are sorted by the different files and by line numbers in\nascending order, otherwise it depletes quickly no matter what and is much\nmore costly (many extra file changes etc.).\nThe reason for not caching those were the BLOCKs that were streamed\nimmediately after the location and encoded into the locations (and for PHIs\nwe failed to stream the BLOCKs altogether).\nThis patch enhances the location cache to handle also BLOCKs (but not for\neverything, only for the spots we care about the BLOCKs) and also optimizes\nthe size of the LTO stream by emitting a single bit into a pack whether the\nBLOCK changed from last case and only streaming the BLOCK tree if it\nchanged.\n\n2020-09-03  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR lto/94311\n\t* gimple.h (gimple_location_ptr, gimple_phi_arg_location_ptr): New\n\tfunctions.\n\t* streamer-hooks.h (struct streamer_hooks): Add\n\toutput_location_and_block callback.  Fix up formatting for\n\toutput_location.\n\t(stream_output_location_and_block): Define.\n\t* lto-streamer.h (class lto_location_cache): Fix comment typo.  Add\n\tcurrent_block member.\n\t(lto_location_cache::input_location_and_block): New method.\n\t(lto_location_cache::lto_location_cache): Initialize current_block.\n\t(lto_location_cache::cached_location): Add block member.\n\t(struct output_block): Add current_block member.\n\t(lto_output_location): Formatting fix.\n\t(lto_output_location_and_block): Declare.\n\t* lto-streamer.c (lto_streamer_hooks_init): Initialize\n\tstreamer_hooks.output_location_and_block.\n\t* lto-streamer-in.c (lto_location_cache::cmp_loc): Also compare\n\tblock members.\n\t(lto_location_cache::apply_location_cache): Handle blocks.\n\t(lto_location_cache::accept_location_cache,\n\tlto_location_cache::revert_location_cache): Fix up function comments.\n\t(lto_location_cache::input_location_and_block): New method.\n\t(lto_location_cache::input_location): Implement using\n\tinput_location_and_block.\n\t(input_function): Invoke apply_location_cache after streaming in all\n\tbbs.\n\t* lto-streamer-out.c (clear_line_info): Set current_block.\n\t(lto_output_location_1): New function, moved from lto_output_location,\n\tadded block handling.\n\t(lto_output_location): Implement using lto_output_location_1.\n\t(lto_output_location_and_block): New function.\n\t* gimple-streamer-in.c (input_phi): Use input_location_and_block\n\tto input and cache both location and block.\n\t(input_gimple_stmt): Likewise.\n\t* gimple-streamer-out.c (output_phi): Use\n\tstream_output_location_and_block.\n\t(output_gimple_stmt): Likewise.", "tree": {"sha": "8e204242f7a42d218ac77d9cf7503df54dd379a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e204242f7a42d218ac77d9cf7503df54dd379a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3536ff2de8317c430546fd97574d44c5146cef2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3536ff2de8317c430546fd97574d44c5146cef2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3536ff2de8317c430546fd97574d44c5146cef2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3536ff2de8317c430546fd97574d44c5146cef2b/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b246f5272eb7242a9cefe5b4e7220be9d86ea512", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b246f5272eb7242a9cefe5b4e7220be9d86ea512", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b246f5272eb7242a9cefe5b4e7220be9d86ea512"}], "stats": {"total": 269, "additions": 200, "deletions": 69}, "files": [{"sha": "3bd4a86b156bd4221826e574b26c03c7864c4c68", "filename": "gcc/gimple-streamer-in.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3536ff2de8317c430546fd97574d44c5146cef2b/gcc%2Fgimple-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3536ff2de8317c430546fd97574d44c5146cef2b/gcc%2Fgimple-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-in.c?ref=3536ff2de8317c430546fd97574d44c5146cef2b", "patch": "@@ -57,11 +57,7 @@ input_phi (class lto_input_block *ib, basic_block bb, class data_in *data_in,\n       tree def = stream_read_tree (ib, data_in);\n       int src_index = streamer_read_uhwi (ib);\n       bitpack_d bp = streamer_read_bitpack (ib);\n-      /* Do not cache a location - we do not have API to get pointer to the\n-\t location in PHI statement and we may trigger reallocation.  */\n-      location_t arg_loc = stream_input_location_now (&bp, data_in);\n       basic_block sbb = BASIC_BLOCK_FOR_FN (fn, src_index);\n-\n       edge e = NULL;\n       int j;\n \n@@ -72,7 +68,11 @@ input_phi (class lto_input_block *ib, basic_block bb, class data_in *data_in,\n \t    break;\n \t  }\n \n-      add_phi_arg (result, def, e, arg_loc);\n+      add_phi_arg (result, def, e, UNKNOWN_LOCATION);\n+      /* Read location and lexical block information.  */\n+      location_t *arg_locp = gimple_phi_arg_location_ptr (result, e->dest_idx);\n+      data_in->location_cache.input_location_and_block (arg_locp, &bp, ib,\n+\t\t\t\t\t\t\tdata_in);\n     }\n \n   return result;\n@@ -106,12 +106,9 @@ input_gimple_stmt (class lto_input_block *ib, class data_in *data_in,\n   has_hist = bp_unpack_value (&bp, 1);\n   stmt->subcode = bp_unpack_var_len_unsigned (&bp);\n \n-  /* Read location information.  Caching here makes no sense until streamer\n-     cache can handle the following gimple_set_block.  */\n-  gimple_set_location (stmt, stream_input_location_now (&bp, data_in));\n-\n-  /* Read lexical block reference.  */\n-  gimple_set_block (stmt, stream_read_tree (ib, data_in));\n+  /* Read location and lexical block information.  */\n+  data_in->location_cache.input_location_and_block (gimple_location_ptr (stmt),\n+\t\t\t\t\t\t    &bp, ib, data_in);\n \n   /* Read in all the operands.  */\n   switch (code)"}, {"sha": "2e55c5f3d1e78dbed7c1e5e13a2393af5187f0eb", "filename": "gcc/gimple-streamer-out.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3536ff2de8317c430546fd97574d44c5146cef2b/gcc%2Fgimple-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3536ff2de8317c430546fd97574d44c5146cef2b/gcc%2Fgimple-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-out.c?ref=3536ff2de8317c430546fd97574d44c5146cef2b", "patch": "@@ -48,8 +48,8 @@ output_phi (struct output_block *ob, gphi *phi)\n       stream_write_tree (ob, gimple_phi_arg_def (phi, i), true);\n       streamer_write_uhwi (ob, gimple_phi_arg_edge (phi, i)->src->index);\n       bitpack_d bp = bitpack_create (ob->main_stream);\n-      stream_output_location (ob, &bp, gimple_phi_arg_location (phi, i));\n-      streamer_write_bitpack (&bp);\n+      location_t loc = gimple_phi_arg_location (phi, i);\n+      stream_output_location_and_block (ob, &bp, loc);\n     }\n }\n \n@@ -84,12 +84,8 @@ output_gimple_stmt (struct output_block *ob, struct function *fn, gimple *stmt)\n   bp_pack_value (&bp, hist != NULL, 1);\n   bp_pack_var_len_unsigned (&bp, stmt->subcode);\n \n-  /* Emit location information for the statement.  */\n-  stream_output_location (ob, &bp, LOCATION_LOCUS (gimple_location (stmt)));\n-  streamer_write_bitpack (&bp);\n-\n-  /* Emit the lexical block holding STMT.  */\n-  stream_write_tree (ob, gimple_block (stmt), true);\n+  /* Emit location information for the statement, including gimple_block.  */\n+  stream_output_location_and_block (ob, &bp, gimple_location (stmt));\n \n   /* Emit the operands.  */\n   switch (gimple_code (stmt))"}, {"sha": "6cc7e66059d817d2f517f8482ff5a333ae575e85", "filename": "gcc/gimple.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3536ff2de8317c430546fd97574d44c5146cef2b/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3536ff2de8317c430546fd97574d44c5146cef2b/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=3536ff2de8317c430546fd97574d44c5146cef2b", "patch": "@@ -1879,6 +1879,14 @@ gimple_set_location (gimple *g, location_t location)\n   g->location = location;\n }\n \n+/* Return address of the location information for statement G.  */\n+\n+static inline location_t *\n+gimple_location_ptr (gimple *g)\n+{\n+  return &g->location;\n+}\n+\n \n /* Return true if G contains location information.  */\n \n@@ -4581,6 +4589,14 @@ gimple_phi_arg_set_location (gphi *phi, size_t i, location_t loc)\n   gimple_phi_arg (phi, i)->locus = loc;\n }\n \n+/* Return address of source location of gimple argument I of phi node PHI.  */\n+\n+static inline location_t *\n+gimple_phi_arg_location_ptr (gphi *phi, size_t i)\n+{\n+  return &gimple_phi_arg (phi, i)->locus;\n+}\n+\n /* Return TRUE if argument I of phi node PHI has a location record.  */\n \n static inline bool"}, {"sha": "478125aed19ff7d69551470477bc573a11cd5ade", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 88, "deletions": 23, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3536ff2de8317c430546fd97574d44c5146cef2b/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3536ff2de8317c430546fd97574d44c5146cef2b/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=3536ff2de8317c430546fd97574d44c5146cef2b", "patch": "@@ -156,7 +156,18 @@ lto_location_cache::cmp_loc (const void *pa, const void *pb)\n     return a->sysp ? 1 : -1;\n   if (a->line != b->line)\n     return a->line - b->line;\n-  return a->col - b->col;\n+  if (a->col != b->col)\n+    return a->col - b->col;\n+  if ((a->block == NULL_TREE) != (b->block == NULL_TREE))\n+    return a->block ? 1 : -1;\n+  if (a->block)\n+    {\n+      if (BLOCK_NUMBER (a->block) < BLOCK_NUMBER (b->block))\n+\treturn -1;\n+      if (BLOCK_NUMBER (a->block) > BLOCK_NUMBER (b->block))\n+\treturn 1;\n+    }\n+  return 0;\n }\n \n /* Apply all changes in location cache.  Add locations into linemap and patch\n@@ -191,22 +202,33 @@ lto_location_cache::apply_location_cache ()\n \t  linemap_line_start (line_table, loc.line, max + 1);\n \t}\n       gcc_assert (*loc.loc == BUILTINS_LOCATION + 1);\n-      if (current_file == loc.file && current_line == loc.line\n-\t  && current_col == loc.col)\n-\t*loc.loc = current_loc;\n-      else\n-        current_loc = *loc.loc = linemap_position_for_column (line_table,\n-\t\t\t\t\t\t\t      loc.col);\n+      if (current_file != loc.file\n+\t  || current_line != loc.line\n+\t  || current_col != loc.col)\n+\t{\n+\t  current_loc = linemap_position_for_column (line_table, loc.col);\n+\t  if (loc.block)\n+\t    current_loc = set_block (current_loc, loc.block);\n+\t}\n+      else if (current_block != loc.block)\n+\t{\n+\t  if (loc.block)\n+\t    current_loc = set_block (current_loc, loc.block);\n+\t  else\n+\t    current_loc = LOCATION_LOCUS (current_loc);\n+\t}\n+      *loc.loc = current_loc;\n       current_line = loc.line;\n       prev_file = current_file = loc.file;\n       current_col = loc.col;\n+      current_block = loc.block;\n     }\n   loc_cache.truncate (0);\n   accepted_length = 0;\n   return true;\n }\n \n-/* Tree merging did not suceed; mark all changes in the cache as accepted.  */\n+/* Tree merging did not succeed; mark all changes in the cache as accepted.  */\n \n void\n lto_location_cache::accept_location_cache ()\n@@ -215,41 +237,54 @@ lto_location_cache::accept_location_cache ()\n   accepted_length = loc_cache.length ();\n }\n \n-/* Tree merging did suceed; throw away recent changes.  */\n+/* Tree merging did succeed; throw away recent changes.  */\n \n void\n lto_location_cache::revert_location_cache ()\n {\n   loc_cache.truncate (accepted_length);\n }\n \n-/* Read a location bitpack from input block IB and either update *LOC directly\n-   or add it to the location cache.\n+/* Read a location bitpack from bit pack BP and either update *LOC directly\n+   or add it to the location cache.  If IB is non-NULL, stream in a block\n+   afterwards.\n    It is neccesary to call apply_location_cache to get *LOC updated.  */\n \n void\n-lto_location_cache::input_location (location_t *loc, struct bitpack_d *bp,\n-\t\t\t\t    class data_in *data_in)\n+lto_location_cache::input_location_and_block (location_t *loc,\n+\t\t\t\t\t      struct bitpack_d *bp,\n+\t\t\t\t\t      class lto_input_block *ib,\n+\t\t\t\t\t      class data_in *data_in)\n {\n   static const char *stream_file;\n   static int stream_line;\n   static int stream_col;\n   static bool stream_sysp;\n-  bool file_change, line_change, column_change;\n+  static tree stream_block;\n \n   gcc_assert (current_cache == this);\n \n   *loc = bp_unpack_int_in_range (bp, \"location\", 0, RESERVED_LOCATION_COUNT);\n \n   if (*loc < RESERVED_LOCATION_COUNT)\n-    return;\n+    {\n+      if (ib)\n+\t{\n+\t  bool block_change = bp_unpack_value (bp, 1);\n+\t  if (block_change)\n+\t    stream_block = stream_read_tree (ib, data_in);\n+\t  if (stream_block)\n+\t    *loc = set_block (*loc, stream_block);\n+\t}\n+      return;\n+    }\n \n   /* Keep value RESERVED_LOCATION_COUNT in *loc as linemap lookups will\n      ICE on it.  */\n \n-  file_change = bp_unpack_value (bp, 1);\n-  line_change = bp_unpack_value (bp, 1);\n-  column_change = bp_unpack_value (bp, 1);\n+  bool file_change = bp_unpack_value (bp, 1);\n+  bool line_change = bp_unpack_value (bp, 1);\n+  bool column_change = bp_unpack_value (bp, 1);\n \n   if (file_change)\n     {\n@@ -263,21 +298,48 @@ lto_location_cache::input_location (location_t *loc, struct bitpack_d *bp,\n   if (column_change)\n     stream_col = bp_unpack_var_len_unsigned (bp);\n \n-  /* This optimization saves location cache operations druing gimple\n+  tree block = NULL_TREE;\n+  if (ib)\n+    {\n+      bool block_change = bp_unpack_value (bp, 1);\n+      if (block_change)\n+\tstream_block = stream_read_tree (ib, data_in);\n+      block = stream_block;\n+    }\n+\n+  /* This optimization saves location cache operations during gimple\n      streaming.  */\n      \n-  if (current_file == stream_file && current_line == stream_line\n-      && current_col == stream_col && current_sysp == stream_sysp)\n+  if (current_file == stream_file\n+      && current_line == stream_line\n+      && current_col == stream_col\n+      && current_sysp == stream_sysp)\n     {\n-      *loc = current_loc;\n+      if (current_block == block)\n+\t*loc = current_loc;\n+      else if (block)\n+\t*loc = set_block (current_loc, block);\n+      else\n+\t*loc = LOCATION_LOCUS (current_loc);\n       return;\n     }\n \n   struct cached_location entry\n-    = {stream_file, loc, stream_line, stream_col, stream_sysp};\n+    = {stream_file, loc, stream_line, stream_col, stream_sysp, block};\n   loc_cache.safe_push (entry);\n }\n \n+/* Read a location bitpack from bit pack BP and either update *LOC directly\n+   or add it to the location cache.\n+   It is neccesary to call apply_location_cache to get *LOC updated.  */\n+\n+void\n+lto_location_cache::input_location (location_t *loc, struct bitpack_d *bp,\n+\t\t\t\t    class data_in *data_in)\n+{\n+  return input_location_and_block (loc, bp, NULL, data_in);\n+}\n+\n /* Read a location bitpack from input block IB and either update *LOC directly\n    or add it to the location cache.\n    It is neccesary to call apply_location_cache to get *LOC updated.  */\n@@ -1101,6 +1163,9 @@ input_function (tree fn_decl, class data_in *data_in,\n       tag = streamer_read_record_start (ib);\n     }\n \n+  /* Finalize gimple_location/gimple_block of stmts and phis.  */\n+  data_in->location_cache.apply_location_cache ();\n+\n   /* Fix up the call statements that are mentioned in the callgraph\n      edges.  */\n   set_gimple_stmt_max_uid (cfun, 0);"}, {"sha": "914d5eb70b09e9fb145f130e0c630d65bbc15110", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 58, "deletions": 22, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3536ff2de8317c430546fd97574d44c5146cef2b/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3536ff2de8317c430546fd97574d44c5146cef2b/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=3536ff2de8317c430546fd97574d44c5146cef2b", "patch": "@@ -60,6 +60,10 @@ clear_line_info (struct output_block *ob)\n   ob->current_line = 0;\n   ob->current_col = 0;\n   ob->current_sysp = false;\n+  /* Initialize to something that will never appear as block,\n+     so that the first location with block in a function etc.\n+     always streams a change_block bit and the first block.  */\n+  ob->current_block = void_node;\n }\n \n \n@@ -178,40 +182,72 @@ tree_is_indexable (tree t)\n    After outputting bitpack, lto_output_location_data has\n    to be done to output actual data.  */\n \n-void\n-lto_output_location (struct output_block *ob, struct bitpack_d *bp,\n-\t\t     location_t loc)\n+static void\n+lto_output_location_1 (struct output_block *ob, struct bitpack_d *bp,\n+\t\t       location_t orig_loc, bool block_p)\n {\n-  expanded_location xloc;\n+  location_t loc = LOCATION_LOCUS (orig_loc);\n \n-  loc = LOCATION_LOCUS (loc);\n   bp_pack_int_in_range (bp, 0, RESERVED_LOCATION_COUNT,\n \t\t        loc < RESERVED_LOCATION_COUNT\n \t\t\t? loc : RESERVED_LOCATION_COUNT);\n-  if (loc < RESERVED_LOCATION_COUNT)\n-    return;\n+  if (loc >= RESERVED_LOCATION_COUNT)\n+    {\n+      expanded_location xloc = expand_location (loc);\n \n-  xloc = expand_location (loc);\n+      bp_pack_value (bp, ob->current_file != xloc.file, 1);\n+      bp_pack_value (bp, ob->current_line != xloc.line, 1);\n+      bp_pack_value (bp, ob->current_col != xloc.column, 1);\n \n-  bp_pack_value (bp, ob->current_file != xloc.file, 1);\n-  bp_pack_value (bp, ob->current_line != xloc.line, 1);\n-  bp_pack_value (bp, ob->current_col != xloc.column, 1);\n+      if (ob->current_file != xloc.file)\n+\t{\n+\t  bp_pack_string (ob, bp, remap_debug_filename (xloc.file), true);\n+\t  bp_pack_value (bp, xloc.sysp, 1);\n+\t}\n+      ob->current_file = xloc.file;\n+      ob->current_sysp = xloc.sysp;\n+\n+      if (ob->current_line != xloc.line)\n+\tbp_pack_var_len_unsigned (bp, xloc.line);\n+      ob->current_line = xloc.line;\n+\n+      if (ob->current_col != xloc.column)\n+\tbp_pack_var_len_unsigned (bp, xloc.column);\n+      ob->current_col = xloc.column;\n+    }\n \n-  if (ob->current_file != xloc.file)\n+  if (block_p)\n     {\n-      bp_pack_string (ob, bp, remap_debug_filename (xloc.file), true);\n-      bp_pack_value (bp, xloc.sysp, 1);\n+      tree block = LOCATION_BLOCK (orig_loc);\n+      bp_pack_value (bp, ob->current_block != block, 1);\n+      streamer_write_bitpack (bp);\n+      if (ob->current_block != block)\n+\tlto_output_tree (ob, block, true, true);\n+      ob->current_block = block;\n     }\n-  ob->current_file = xloc.file;\n-  ob->current_sysp = xloc.sysp;\n+}\n+\n+/* Output info about new location into bitpack BP.\n+   After outputting bitpack, lto_output_location_data has\n+   to be done to output actual data.  */\n \n-  if (ob->current_line != xloc.line)\n-    bp_pack_var_len_unsigned (bp, xloc.line);\n-  ob->current_line = xloc.line;\n+void\n+lto_output_location (struct output_block *ob, struct bitpack_d *bp,\n+\t\t     location_t loc)\n+{\n+  lto_output_location_1 (ob, bp, loc, false);\n+}\n+\n+/* Output info about new location into bitpack BP.\n+   After outputting bitpack, lto_output_location_data has\n+   to be done to output actual data.  Like lto_output_location, but\n+   additionally output LOCATION_BLOCK info too and write the BP bitpack.  */\n \n-  if (ob->current_col != xloc.column)\n-    bp_pack_var_len_unsigned (bp, xloc.column);\n-  ob->current_col = xloc.column;\n+void\n+lto_output_location_and_block (struct output_block *ob, struct bitpack_d *bp,\n+\t\t\t       location_t loc)\n+{\n+  lto_output_location_1 (ob, bp, loc, true);\n }\n \n "}, {"sha": "9d12d47d9094378ada83eb4970fd67292dde825f", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3536ff2de8317c430546fd97574d44c5146cef2b/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3536ff2de8317c430546fd97574d44c5146cef2b/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=3536ff2de8317c430546fd97574d44c5146cef2b", "patch": "@@ -272,4 +272,5 @@ lto_streamer_hooks_init (void)\n   streamer_hooks.read_tree = lto_input_tree;\n   streamer_hooks.input_location = lto_input_location;\n   streamer_hooks.output_location = lto_output_location;\n+  streamer_hooks.output_location_and_block = lto_output_location_and_block;\n }"}, {"sha": "938298459ebf01a0b6a0350b47d5c4468ff30baa", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3536ff2de8317c430546fd97574d44c5146cef2b/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3536ff2de8317c430546fd97574d44c5146cef2b/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=3536ff2de8317c430546fd97574d44c5146cef2b", "patch": "@@ -262,7 +262,7 @@ typedef void (lto_free_section_data_f) (struct lto_file_decl_data *,\n \n /* The location cache holds expanded locations for streamed in trees.\n    This is done to reduce memory usage of libcpp linemap that strongly prefers\n-   locations to be inserted in the soruce order.  */\n+   locations to be inserted in the source order.  */\n \n class lto_location_cache\n {\n@@ -276,9 +276,13 @@ class lto_location_cache\n   void revert_location_cache ();\n   void input_location (location_t *loc, struct bitpack_d *bp,\n \t\t       class data_in *data_in);\n+  void input_location_and_block (location_t *loc, struct bitpack_d *bp,\n+\t\t\t\t class lto_input_block *ib,\n+\t\t\t\t class data_in *data_in);\n   lto_location_cache ()\n      : loc_cache (), accepted_length (0), current_file (NULL), current_line (0),\n-       current_col (0), current_sysp (false), current_loc (UNKNOWN_LOCATION)\n+       current_col (0), current_sysp (false), current_loc (UNKNOWN_LOCATION),\n+       current_block (NULL_TREE)\n   {\n     gcc_assert (!current_cache);\n     current_cache = this;\n@@ -304,6 +308,7 @@ class lto_location_cache\n     location_t *loc;\n     int line, col;\n     bool sysp;\n+    tree block;\n   };\n \n   /* The location cache.  */\n@@ -325,6 +330,7 @@ class lto_location_cache\n   int current_col;\n   bool current_sysp;\n   location_t current_loc;\n+  tree current_block;\n };\n \n /* Structure used as buffer for reading an LTO file.  */\n@@ -711,6 +717,7 @@ struct output_block\n   int current_line;\n   int current_col;\n   bool current_sysp;\n+  tree current_block;\n \n   /* Cache of nodes written in this section.  */\n   struct streamer_tree_cache_d *writer_cache;\n@@ -881,7 +888,10 @@ void lto_output_decl_state_streams (struct output_block *,\n void lto_output_decl_state_refs (struct output_block *,\n \t\t\t         struct lto_output_stream *,\n \t\t\t         struct lto_out_decl_state *);\n-void lto_output_location (struct output_block *, struct bitpack_d *, location_t);\n+void lto_output_location (struct output_block *, struct bitpack_d *,\n+\t\t\t  location_t);\n+void lto_output_location_and_block (struct output_block *, struct bitpack_d *,\n+\t\t\t\t    location_t);\n void lto_output_init_mode_table (void);\n void lto_prepare_function_for_streaming (cgraph_node *);\n "}, {"sha": "4085bf4ba3da862243afb872f0e6073b50b7fdaf", "filename": "gcc/streamer-hooks.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3536ff2de8317c430546fd97574d44c5146cef2b/gcc%2Fstreamer-hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3536ff2de8317c430546fd97574d44c5146cef2b/gcc%2Fstreamer-hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstreamer-hooks.h?ref=3536ff2de8317c430546fd97574d44c5146cef2b", "patch": "@@ -54,8 +54,15 @@ struct streamer_hooks {\n   /* [REQ] Called by every streaming routine that needs to read a location.  */\n   void (*input_location) (location_t *, struct bitpack_d *, class data_in *);\n \n-  /* [REQ] Called by every streaming routine that needs to write a location.  */\n-  void (*output_location) (struct output_block *, struct bitpack_d *, location_t);\n+  /* [REQ] Called by every streaming routine that needs to write a\n+     location.  */\n+  void (*output_location) (struct output_block *, struct bitpack_d *,\n+\t\t\t   location_t);\n+\n+  /* [REQ] Called by every streaming routine that needs to write a\n+     location, both LOCATION_LOCUS and LOCATION_BLOCK.  */\n+  void (*output_location_and_block) (struct output_block *, struct bitpack_d *,\n+\t\t\t\t     location_t);\n };\n \n #define stream_write_tree(OB, EXPR, REF_P) \\\n@@ -73,6 +80,9 @@ struct streamer_hooks {\n #define stream_output_location(OB, BP, LOC) \\\n     streamer_hooks.output_location (OB, BP, LOC)\n \n+#define stream_output_location_and_block(OB, BP, LOC) \\\n+    streamer_hooks.output_location_and_block (OB, BP, LOC)\n+\n /* Streamer hooks.  */\n extern struct streamer_hooks streamer_hooks;\n "}]}