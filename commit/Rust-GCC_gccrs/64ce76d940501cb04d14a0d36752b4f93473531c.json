{"sha": "64ce76d940501cb04d14a0d36752b4f93473531c", "node_id": "C_kwDOANBUbNoAKDY0Y2U3NmQ5NDA1MDFjYjA0ZDE0YTBkMzY3NTJiNGY5MzQ3MzUzMWM", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2022-08-03T09:01:51Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2022-08-03T09:07:15Z"}, "message": "cselib: add function to check if SET is redundant [PR106187]\n\nA SET operation that writes memory may have the same value as an\nearlier store but if the alias sets of the new and earlier store do\nnot conflict then the set is not truly redundant.  This can happen,\nfor example, if objects of different types share a stack slot.\n\nTo fix this we define a new function in cselib that first checks for\nequality and if that is successful then finds the earlier store in the\nvalue history and checks the alias sets.\n\nThe routine is used in two places elsewhere in the compiler:\ncfgcleanup and postreload.\n\ngcc/ChangeLog:\n\n\tPR rtl-optimization/106187\n\t* alias.h (mems_same_for_tbaa_p): Declare.\n\t* alias.cc (mems_same_for_tbaa_p): New function.\n\t* dse.cc (record_store): Use it instead of open-coding\n\talias check.\n\t* cselib.h (cselib_redundant_set_p): Declare.\n\t* cselib.cc: Include alias.h\n\t(cselib_redundant_set_p): New function.\n\t* cfgcleanup.cc: (mark_effect): Use cselib_redundant_set_p instead\n\tof rtx_equal_for_cselib_p.\n\t* postreload.cc (reload_cse_simplify): Use cselib_redundant_set_p.\n\t(reload_cse_noop_set_p): Delete.", "tree": {"sha": "1c7cb524db411f7625a6a08bad592e476dc1c28d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c7cb524db411f7625a6a08bad592e476dc1c28d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64ce76d940501cb04d14a0d36752b4f93473531c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64ce76d940501cb04d14a0d36752b4f93473531c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64ce76d940501cb04d14a0d36752b4f93473531c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64ce76d940501cb04d14a0d36752b4f93473531c/comments", "author": null, "committer": null, "parents": [{"sha": "a6b7fff06c5b27c4ffacf4c84ea1189254b9ad84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6b7fff06c5b27c4ffacf4c84ea1189254b9ad84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6b7fff06c5b27c4ffacf4c84ea1189254b9ad84"}], "stats": {"total": 110, "additions": 90, "deletions": 20}, "files": [{"sha": "d54feb1526876386716a7f54225abe9467db30eb", "filename": "gcc/alias.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64ce76d940501cb04d14a0d36752b4f93473531c/gcc%2Falias.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64ce76d940501cb04d14a0d36752b4f93473531c/gcc%2Falias.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.cc?ref=64ce76d940501cb04d14a0d36752b4f93473531c", "patch": "@@ -389,6 +389,20 @@ refs_same_for_tbaa_p (tree earlier, tree later)\n \t  || alias_set_subset_of (later_base_set, earlier_base_set));\n }\n \n+/* Similar to refs_same_for_tbaa_p() but for use on MEM rtxs.  */\n+bool\n+mems_same_for_tbaa_p (rtx earlier, rtx later)\n+{\n+  gcc_assert (MEM_P (earlier));\n+  gcc_assert (MEM_P (later));\n+\n+  return ((MEM_ALIAS_SET (earlier) == MEM_ALIAS_SET (later)\n+\t   || alias_set_subset_of (MEM_ALIAS_SET (later),\n+\t\t\t\t   MEM_ALIAS_SET (earlier)))\n+\t  && (!MEM_EXPR (earlier)\n+\t      || refs_same_for_tbaa_p (MEM_EXPR (earlier), MEM_EXPR (later))));\n+}\n+\n /* Returns a pointer to the alias set entry for ALIAS_SET, if there is\n    such an entry, or NULL otherwise.  */\n "}, {"sha": "ee3db46676309d8d130d2cd2abf0f4415ef0fae3", "filename": "gcc/alias.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64ce76d940501cb04d14a0d36752b4f93473531c/gcc%2Falias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64ce76d940501cb04d14a0d36752b4f93473531c/gcc%2Falias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.h?ref=64ce76d940501cb04d14a0d36752b4f93473531c", "patch": "@@ -40,6 +40,7 @@ tree reference_alias_ptr_type_1 (tree *);\n bool alias_ptr_types_compatible_p (tree, tree);\n int compare_base_decls (tree, tree);\n bool refs_same_for_tbaa_p (tree, tree);\n+bool mems_same_for_tbaa_p (rtx, rtx);\n \n /* This alias set can be used to force a memory to conflict with all\n    other memories, creating a barrier across which no memory reference"}, {"sha": "a8b0139bb4dcfcfbc0ac7fb11e2020af8a9de45f", "filename": "gcc/cfgcleanup.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64ce76d940501cb04d14a0d36752b4f93473531c/gcc%2Fcfgcleanup.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64ce76d940501cb04d14a0d36752b4f93473531c/gcc%2Fcfgcleanup.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.cc?ref=64ce76d940501cb04d14a0d36752b4f93473531c", "patch": "@@ -208,7 +208,7 @@ mark_effect (rtx exp, regset nonequal)\n       return false;\n \n     case SET:\n-      if (rtx_equal_for_cselib_p (SET_DEST (exp), SET_SRC (exp)))\n+      if (cselib_redundant_set_p (exp))\n \treturn false;\n       dest = SET_DEST (exp);\n       if (dest == pc_rtx)"}, {"sha": "6a5609786fa6cda48297be9402c78bb8df4ae8a9", "filename": "gcc/cselib.cc", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64ce76d940501cb04d14a0d36752b4f93473531c/gcc%2Fcselib.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64ce76d940501cb04d14a0d36752b4f93473531c/gcc%2Fcselib.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.cc?ref=64ce76d940501cb04d14a0d36752b4f93473531c", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dumpfile.h\"\n #include \"cselib.h\"\n #include \"function-abi.h\"\n+#include \"alias.h\"\n \n /* A list of cselib_val structures.  */\n struct elt_list\n@@ -1157,6 +1158,75 @@ rtx_equal_for_cselib_1 (rtx x, rtx y, machine_mode memmode, int depth)\n   return 1;\n }\n \n+/* Wrapper for rtx_equal_for_cselib_p to determine whether a SET is\n+   truly redundant, taking into account aliasing information.  */\n+bool\n+cselib_redundant_set_p (rtx set)\n+{\n+  gcc_assert (GET_CODE (set) == SET);\n+  rtx dest = SET_DEST (set);\n+  if (cselib_reg_set_mode (dest) != GET_MODE (dest))\n+    return false;\n+\n+  if (!rtx_equal_for_cselib_p (dest, SET_SRC (set)))\n+    return false;\n+\n+  while (GET_CODE (dest) == SUBREG\n+\t || GET_CODE (dest) == ZERO_EXTRACT\n+\t || GET_CODE (dest) == STRICT_LOW_PART)\n+    dest = XEXP (dest, 0);\n+\n+  if (!flag_strict_aliasing || !MEM_P (dest))\n+    return true;\n+\n+  /* For a store we need to check that suppressing it will not change\n+     the effective alias set.  */\n+  rtx dest_addr = XEXP (dest, 0);\n+\n+  /* Lookup the equivalents to the original dest (rather than just the\n+     MEM).  */\n+  cselib_val *src_val = cselib_lookup (SET_DEST (set),\n+\t\t\t\t       GET_MODE (SET_DEST (set)),\n+\t\t\t\t       0, VOIDmode);\n+\n+  if (src_val)\n+    {\n+      /* Walk the list of source equivalents to find the MEM accessing\n+\t the same location.  */\n+      for (elt_loc_list *l = src_val->locs; l; l = l->next)\n+\t{\n+\t  rtx src_equiv = l->loc;\n+\t  while (GET_CODE (src_equiv) == SUBREG\n+\t\t || GET_CODE (src_equiv) == ZERO_EXTRACT\n+\t\t || GET_CODE (src_equiv) == STRICT_LOW_PART)\n+\t    src_equiv = XEXP (src_equiv, 0);\n+\n+\t  if (MEM_P (src_equiv))\n+\t    {\n+\t      /* Match the MEMs by comparing the addresses.  We can\n+\t\t only remove the later store if the earlier aliases at\n+\t\t least all the accesses of the later one.  */\n+\t      if (rtx_equal_for_cselib_1 (dest_addr, XEXP (src_equiv, 0),\n+\t\t\t\t\t  GET_MODE (dest), 0))\n+\t\treturn mems_same_for_tbaa_p (src_equiv, dest);\n+\t    }\n+\t}\n+    }\n+\n+  /* We failed to find a recorded value in the cselib history, so try\n+     the source of this set; this catches cases such as *p = *q when p\n+     and q have the same value.  */\n+  rtx src = SET_SRC (set);\n+  while (GET_CODE (src) == SUBREG)\n+    src = XEXP (src, 0);\n+\n+  if (MEM_P (src)\n+      && rtx_equal_for_cselib_1 (dest_addr, XEXP (src, 0), GET_MODE (dest), 0))\n+    return mems_same_for_tbaa_p (src, dest);\n+\n+  return false;\n+}\n+\n /* Helper function for cselib_hash_rtx.  Arguments like for cselib_hash_rtx,\n    except that it hashes (plus:P x c).  */\n "}, {"sha": "b0905053ea581910aff047fb220537235270d116", "filename": "gcc/cselib.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64ce76d940501cb04d14a0d36752b4f93473531c/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64ce76d940501cb04d14a0d36752b4f93473531c/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=64ce76d940501cb04d14a0d36752b4f93473531c", "patch": "@@ -83,6 +83,7 @@ extern void cselib_process_insn (rtx_insn *);\n extern bool fp_setter_insn (rtx_insn *);\n extern machine_mode cselib_reg_set_mode (const_rtx);\n extern int rtx_equal_for_cselib_1 (rtx, rtx, machine_mode, int);\n+extern bool cselib_redundant_set_p (rtx);\n extern int references_value_p (const_rtx, int);\n extern rtx cselib_expand_value_rtx (rtx, bitmap, int);\n typedef rtx (*cselib_expand_callback)(rtx, bitmap, int, void *);"}, {"sha": "0f7b0fb9796769e7ff09c57d4a3c947cae7a337f", "filename": "gcc/dse.cc", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64ce76d940501cb04d14a0d36752b4f93473531c/gcc%2Fdse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64ce76d940501cb04d14a0d36752b4f93473531c/gcc%2Fdse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.cc?ref=64ce76d940501cb04d14a0d36752b4f93473531c", "patch": "@@ -1570,12 +1570,7 @@ record_store (rtx body, bb_info_t bb_info)\n \t\t\t\t\t width)\n \t      /* We can only remove the later store if the earlier aliases\n \t\t at least all accesses the later one.  */\n-\t      && ((MEM_ALIAS_SET (mem) == MEM_ALIAS_SET (s_info->mem)\n-\t\t   || alias_set_subset_of (MEM_ALIAS_SET (mem),\n-\t\t\t\t\t   MEM_ALIAS_SET (s_info->mem)))\n-\t\t  && (!MEM_EXPR (s_info->mem)\n-\t\t      || refs_same_for_tbaa_p (MEM_EXPR (s_info->mem),\n-\t\t\t\t\t       MEM_EXPR (mem)))))\n+\t      && mems_same_for_tbaa_p (s_info->mem, mem))\n \t    {\n \t      if (GET_MODE (mem) == BLKmode)\n \t\t{"}, {"sha": "41f61d3264825b1f2b53e64c7eb022b1ad3de950", "filename": "gcc/postreload.cc", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64ce76d940501cb04d14a0d36752b4f93473531c/gcc%2Fpostreload.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64ce76d940501cb04d14a0d36752b4f93473531c/gcc%2Fpostreload.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.cc?ref=64ce76d940501cb04d14a0d36752b4f93473531c", "patch": "@@ -43,7 +43,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"function-abi.h\"\n #include \"rtl-iter.h\"\n \n-static int reload_cse_noop_set_p (rtx);\n static bool reload_cse_simplify (rtx_insn *, rtx);\n static void reload_cse_regs_1 (void);\n static int reload_cse_simplify_set (rtx, rtx_insn *);\n@@ -74,16 +73,6 @@ reload_cse_regs (rtx_insn *first ATTRIBUTE_UNUSED)\n     }\n }\n \n-/* See whether a single set SET is a noop.  */\n-static int\n-reload_cse_noop_set_p (rtx set)\n-{\n-  if (cselib_reg_set_mode (SET_DEST (set)) != GET_MODE (SET_DEST (set)))\n-    return 0;\n-\n-  return rtx_equal_for_cselib_p (SET_DEST (set), SET_SRC (set));\n-}\n-\n /* Try to simplify INSN.  Return true if the CFG may have changed.  */\n static bool\n reload_cse_simplify (rtx_insn *insn, rtx testreg)\n@@ -118,7 +107,7 @@ reload_cse_simplify (rtx_insn *insn, rtx testreg)\n          this out, so it's safer to simplify before we delete.  */\n       count += reload_cse_simplify_set (body, insn);\n \n-      if (!count && reload_cse_noop_set_p (body))\n+      if (!count && cselib_redundant_set_p (body))\n \t{\n \t  if (check_for_inc_dec (insn))\n \t    delete_insn_and_edges (insn);\n@@ -157,7 +146,7 @@ reload_cse_simplify (rtx_insn *insn, rtx testreg)\n \t  rtx part = XVECEXP (body, 0, i);\n \t  if (GET_CODE (part) == SET)\n \t    {\n-\t      if (! reload_cse_noop_set_p (part))\n+\t      if (! cselib_redundant_set_p (part))\n \t\tbreak;\n \t      if (REG_P (SET_DEST (part))\n \t\t  && REG_FUNCTION_VALUE_P (SET_DEST (part)))"}]}