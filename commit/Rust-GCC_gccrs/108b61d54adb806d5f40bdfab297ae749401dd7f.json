{"sha": "108b61d54adb806d5f40bdfab297ae749401dd7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA4YjYxZDU0YWRiODA2ZDVmNDBiZGZhYjI5N2FlNzQ5NDAxZGQ3Zg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-11-04T22:13:32Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-11-04T22:13:32Z"}, "message": "mips-protos.h (mips_global_pic_constant_p): Delete.\n\n\t* config/mips/mips-protos.h (mips_global_pic_constant_p): Delete.\n\t(mips_delegitimize_address): Delete.\n\t(mips_gotoff_global, mips_load_got_page): Declare.\n\t(mips_load_got_global, mips_rewrite_small_data): Declare.\n\n\t* config/mips/mips.h (FIND_BASE_TERM): Remove definition.\n\t(DANGEROUS_FOR_LA25_P): Use global_got_operand.\n\t(PREDICATE_CODES): Add global_got_operand, local_got_operand and\n\tsmall_data_pattern.  Remove CONST from const_arith_operand's entry.\n\n\t* config/mips/mips.c (UNSPEC_ADDRESS_P, CONST_GP_P): New macros.\n\t(UNSPEC_ADDRESS, UNSPEC_ADDRESS_TYPE): Likewise.\n\t(mips_constant_type): Delete.\n\t(mips_symbol_type): Add SYMBOL_GOTOFF_PAGE, SYMBOL_GOTOFF_GLOBAL,\n\tSYMBOL_GOTOFF_CALL and SYMBOL_GOTOFF_LOADGP.\n\t(NUM_SYMBOL_TYPES): New macro.\n\t(mips_address_type): Remove ADDRESS_INVALID.\n\t(machine_function): Add has_gp_insn_p.\n\t(mips_constant_info): Delete.\n\t(mips_address_info): Add the address type as an extra field.  Replace\n\tthe c field with symbol_type.\n\t(mips_split_p, mips_lo_relocs, mips_hi_relocs): New arrays.\n\t(TARGET_DELEGITIMIZE_ADDRESS): Remove definition.\n\t(mips_reloc_offset_ok_p, mips_classify_constant): Delete.\n\t(mips_split_const, mips_symbolic_constant_p): New functions.\n\t(mips_symbolic_address_p): Take the symbol type and mode as arguments.\n\t(mips_classify_address): Return true if the address is valid, storing\n\tits type in INFO.  Use mips_symbolic_constant_p.  Use mips_lo_relocs[]\n\tto test whether a LO_SUM address is allowed.\n\t(mips_symbol_insns): Return 0 for general mips16 symbols.\n\tReorder SYMBOL_GOT_GLOBAL case to match mips_symbol_type definition.\n\tHandle the new SYMBOL_GOTOFF_*s.\n\t(mips_address_insns): Update call to mips_classify_address.\n\t(mips_const_insns): Be more fussy about HIGH constants.  Remove use\n\tof mips_classify_constant.  Be more accurate about CONSTs.\n\t(mips_global_pic_constant_p): Delete.\n\t(const_arith_operand): Only accept CONST_INTs.\n\t(call_insn_operand): Remove call to mips_classify_constant.\n\tLet mips_symbolic_constant_p check for invalid offsets.\n\t(move_operand): Check for general_operands first.  Only accept symbolic\n\tconstants if they satisfy mips_symbolic_constant_p and cannot be split.\n\t(symbolic_constant): Use mips_symbolic_constant_p.\n\t(global_got_operand, local_got_operand): New predicates.\n\t(stack_operand): Update call to mips_classify_address.\n\t(mips_legitimate_address_p): Likewise.\n\t(mips_reloc, mips_lui_reloc): Delete.\n\t(mips_force_temporary): Only use the given temporary if no_new_pseudos.\n\tUse emit_move_insn.\n\t(mips_split_symbol, mips_unspec_address): New functions.\n\t(mips_unspec_offset_high): New function.\n\t(mips_load_got): Replace reloc argument with a symbol_type.\n\tUse mips_unspec_address to create the address and put it in a\n\tLO_SUM with the base register.\n\t(mips_load_got16, mips_load_got32): Delete.\n\t(mips_emit_high, mips_legitimize_symbol): Delete.\n\t(mips_gotoff_global): New function.\n\t(mips_load_got_page, mips_load_got_global): New functions.\n\t(mips_legitimize_symbol): Inline handling of LO_SUM splits.\n\t(mips_legitimize_const_move): Likewise.  Remove HIGH handling.\n\tInline code to handle constants plus invalid offsets.  Use\n\tmips_split_symbol to legitimize constant pool addresses.\n\t(mips_delegitimize_address): Delete.\n\t(mips_rtx_costs): Give legitimate symbolic constants and CONST_DOUBLEs\n\ta cost of 1 insn.  Give the rest a cost of CONSTANT_POOL_ADDRESS.\n\t(mips_subword): Pass memrefs through mips_rewrite_small_data.\n\t(mips_output_move): Remove use of mips_classify_constant.\n\t(mips_expand_call): Use mips_unspec_offset_high to calculate the\n\thigh part of the GOT address for calls to global functions.\n\t(override_options): Initialize mips_split_p[], mips_lo_relocs[]\n\tand mips_hi_relocs[].\n\t(print_operand): Use print_operand_reloc to handle '%h' and '%R'.\n\tRemove use of mips_classify_constant.\n\t(mips_reloc_string): Delete.\n\t(print_operand_reloc): New function.\n\t(print_operand_address): Update call to mips_classify_address.\n\t(mips_rewrite_small_data_p, small_data_pattern_1): New functions.\n\t(small_data_pattern): New predicate.\n\t(mips_rewrite_small_data_1, mips_rewrite_small_data): New functions.\n\t(mips_function_has_gp_insn): New function.\n\t(mips_global_pointer): Use it.\n\t(mips_gp_insn): Delete.\n\t(mips_expand_prologue): When compiling for n32/n64 abicalls, use a\n\tsingle loadgp pattern to initialize $gp.  Pass it the offset of _gp\n\tfrom the start of the current function.\n\t(mips16_gp_pseudo_reg): Revert last patch.\n\n\t* config/mips/mips.md (RELOC_*): Delete.\n\t(UNSPEC_LOADGP, UNSPEC_FIRST_ADDRESS): New constants.\n\t(got): New insn attribute.\n\t(type): Set to \"load\" if got == load.\n\t(length): Set to 4 if got == load, 8 if got == xgot_high.\n\t(lui[sd]i): Delete.\n\t(*xgot_hi[sd]i, *xgot_lo[sd]i): New patterns.\n\t(*got_disp[sd]i, *got_page[sd]i): Likewise.\n\t(*low[sd]i): Change constraints to \"d\".  Add a new define_split to\n\trewrite small data constants into LO_SUMs.\n\t(loadgp): New insns.\n\nFrom-SVN: r73259", "tree": {"sha": "15a0d9d45d92ef7f40bcfb859c576e7e74db3065", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15a0d9d45d92ef7f40bcfb859c576e7e74db3065"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/108b61d54adb806d5f40bdfab297ae749401dd7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/108b61d54adb806d5f40bdfab297ae749401dd7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/108b61d54adb806d5f40bdfab297ae749401dd7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/108b61d54adb806d5f40bdfab297ae749401dd7f/comments", "author": null, "committer": null, "parents": [{"sha": "487e9fff78364cac72cf1cd6db3bb92df86b1ac1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/487e9fff78364cac72cf1cd6db3bb92df86b1ac1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/487e9fff78364cac72cf1cd6db3bb92df86b1ac1"}], "stats": {"total": 1648, "additions": 921, "deletions": 727}, "files": [{"sha": "6ec6477300858b270766da36676ad3bc4d2a4136", "filename": "gcc/ChangeLog", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108b61d54adb806d5f40bdfab297ae749401dd7f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108b61d54adb806d5f40bdfab297ae749401dd7f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=108b61d54adb806d5f40bdfab297ae749401dd7f", "patch": "@@ -1,3 +1,103 @@\n+2003-11-04  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips-protos.h (mips_global_pic_constant_p): Delete.\n+\t(mips_delegitimize_address): Delete.\n+\t(mips_gotoff_global, mips_load_got_page): Declare.\n+\t(mips_load_got_global, mips_rewrite_small_data): Declare.\n+\n+\t* config/mips/mips.h (FIND_BASE_TERM): Remove definition.\n+\t(DANGEROUS_FOR_LA25_P): Use global_got_operand.\n+\t(PREDICATE_CODES): Add global_got_operand, local_got_operand and\n+\tsmall_data_pattern.  Remove CONST from const_arith_operand's entry.\n+\n+\t* config/mips/mips.c (UNSPEC_ADDRESS_P, CONST_GP_P): New macros.\n+\t(UNSPEC_ADDRESS, UNSPEC_ADDRESS_TYPE): Likewise.\n+\t(mips_constant_type): Delete.\n+\t(mips_symbol_type): Add SYMBOL_GOTOFF_PAGE, SYMBOL_GOTOFF_GLOBAL,\n+\tSYMBOL_GOTOFF_CALL and SYMBOL_GOTOFF_LOADGP.\n+\t(NUM_SYMBOL_TYPES): New macro.\n+\t(mips_address_type): Remove ADDRESS_INVALID.\n+\t(machine_function): Add has_gp_insn_p.\n+\t(mips_constant_info): Delete.\n+\t(mips_address_info): Add the address type as an extra field.  Replace\n+\tthe c field with symbol_type.\n+\t(mips_split_p, mips_lo_relocs, mips_hi_relocs): New arrays.\n+\t(TARGET_DELEGITIMIZE_ADDRESS): Remove definition.\n+\t(mips_reloc_offset_ok_p, mips_classify_constant): Delete.\n+\t(mips_split_const, mips_symbolic_constant_p): New functions.\n+\t(mips_symbolic_address_p): Take the symbol type and mode as arguments.\n+\t(mips_classify_address): Return true if the address is valid, storing\n+\tits type in INFO.  Use mips_symbolic_constant_p.  Use mips_lo_relocs[]\n+\tto test whether a LO_SUM address is allowed.\n+\t(mips_symbol_insns): Return 0 for general mips16 symbols.\n+\tReorder SYMBOL_GOT_GLOBAL case to match mips_symbol_type definition.\n+\tHandle the new SYMBOL_GOTOFF_*s.\n+\t(mips_address_insns): Update call to mips_classify_address.\n+\t(mips_const_insns): Be more fussy about HIGH constants.  Remove use\n+\tof mips_classify_constant.  Be more accurate about CONSTs.\n+\t(mips_global_pic_constant_p): Delete.\n+\t(const_arith_operand): Only accept CONST_INTs.\n+\t(call_insn_operand): Remove call to mips_classify_constant.\n+\tLet mips_symbolic_constant_p check for invalid offsets.\n+\t(move_operand): Check for general_operands first.  Only accept symbolic\n+\tconstants if they satisfy mips_symbolic_constant_p and cannot be split.\n+\t(symbolic_constant): Use mips_symbolic_constant_p.\n+\t(global_got_operand, local_got_operand): New predicates.\n+\t(stack_operand): Update call to mips_classify_address.\n+\t(mips_legitimate_address_p): Likewise.\n+\t(mips_reloc, mips_lui_reloc): Delete.\n+\t(mips_force_temporary): Only use the given temporary if no_new_pseudos.\n+\tUse emit_move_insn.\n+\t(mips_split_symbol, mips_unspec_address): New functions.\n+\t(mips_unspec_offset_high): New function.\n+\t(mips_load_got): Replace reloc argument with a symbol_type.\n+\tUse mips_unspec_address to create the address and put it in a\n+\tLO_SUM with the base register.\n+\t(mips_load_got16, mips_load_got32): Delete.\n+\t(mips_emit_high, mips_legitimize_symbol): Delete.\n+\t(mips_gotoff_global): New function.\n+\t(mips_load_got_page, mips_load_got_global): New functions.\n+\t(mips_legitimize_symbol): Inline handling of LO_SUM splits.\n+\t(mips_legitimize_const_move): Likewise.  Remove HIGH handling.\n+\tInline code to handle constants plus invalid offsets.  Use\n+\tmips_split_symbol to legitimize constant pool addresses.\n+\t(mips_delegitimize_address): Delete.\n+\t(mips_rtx_costs): Give legitimate symbolic constants and CONST_DOUBLEs\n+\ta cost of 1 insn.  Give the rest a cost of CONSTANT_POOL_ADDRESS.\n+\t(mips_subword): Pass memrefs through mips_rewrite_small_data.\n+\t(mips_output_move): Remove use of mips_classify_constant.\n+\t(mips_expand_call): Use mips_unspec_offset_high to calculate the\n+\thigh part of the GOT address for calls to global functions.\n+\t(override_options): Initialize mips_split_p[], mips_lo_relocs[]\n+\tand mips_hi_relocs[].\n+\t(print_operand): Use print_operand_reloc to handle '%h' and '%R'.\n+\tRemove use of mips_classify_constant.\n+\t(mips_reloc_string): Delete.\n+\t(print_operand_reloc): New function.\n+\t(print_operand_address): Update call to mips_classify_address.\n+\t(mips_rewrite_small_data_p, small_data_pattern_1): New functions.\n+\t(small_data_pattern): New predicate.\n+\t(mips_rewrite_small_data_1, mips_rewrite_small_data): New functions.\n+\t(mips_function_has_gp_insn): New function.\n+\t(mips_global_pointer): Use it.\n+\t(mips_gp_insn): Delete.\n+\t(mips_expand_prologue): When compiling for n32/n64 abicalls, use a\n+\tsingle loadgp pattern to initialize $gp.  Pass it the offset of _gp\n+\tfrom the start of the current function.\n+\t(mips16_gp_pseudo_reg): Revert last patch.\n+\n+\t* config/mips/mips.md (RELOC_*): Delete.\n+\t(UNSPEC_LOADGP, UNSPEC_FIRST_ADDRESS): New constants.\n+\t(got): New insn attribute.\n+\t(type): Set to \"load\" if got == load.\n+\t(length): Set to 4 if got == load, 8 if got == xgot_high.\n+\t(lui[sd]i): Delete.\n+\t(*xgot_hi[sd]i, *xgot_lo[sd]i): New patterns.\n+\t(*got_disp[sd]i, *got_page[sd]i): Likewise.\n+\t(*low[sd]i): Change constraints to \"d\".  Add a new define_split to\n+\trewrite small data constants into LO_SUMs.\n+\t(loadgp): New insns.\n+\n 2003-11-04  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* config/mips/_tilib.c: Use _ABI* in _MIPS_SIM tests."}, {"sha": "a4c1cffb45316701c851b2e84e48e76577ddd380", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108b61d54adb806d5f40bdfab297ae749401dd7f/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108b61d54adb806d5f40bdfab297ae749401dd7f/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=108b61d54adb806d5f40bdfab297ae749401dd7f", "patch": "@@ -30,11 +30,12 @@ extern int mips_reg_mode_ok_for_base_p (rtx, enum machine_mode, int);\n extern int mips_address_insns (rtx, enum machine_mode);\n extern int mips_const_insns (rtx);\n extern int mips_fetch_insns (rtx);\n-extern bool mips_global_pic_constant_p (rtx);\n extern bool mips_legitimate_address_p (enum machine_mode, rtx, int);\n extern bool mips_legitimize_address (rtx *, enum machine_mode);\n+extern rtx mips_gotoff_global (rtx);\n+extern rtx mips_load_got_page (rtx);\n+extern rtx mips_load_got_global (rtx, rtx);\n extern bool mips_legitimize_move (enum machine_mode, rtx, rtx);\n-extern rtx mips_delegitimize_address (rtx);\n \n extern int m16_uimm3_b (rtx, enum machine_mode);\n extern int m16_simm4_1 (rtx, enum machine_mode);\n@@ -110,6 +111,7 @@ extern void mips_declare_object (FILE *, const char *, const char *,\n extern void mips_declare_object_name (FILE *, const char *, tree);\n extern void mips_finish_declare_object (FILE *, tree, int, int);\n \n+extern rtx mips_rewrite_small_data (rtx);\n extern HOST_WIDE_INT compute_frame_size (HOST_WIDE_INT);\n extern int mips_initial_elimination_offset (int, int);\n extern rtx mips_return_addr (int, rtx);"}, {"sha": "11188d07612e3c9c37e51bd27f7119f0425065ca", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 681, "deletions": 687, "changes": 1368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108b61d54adb806d5f40bdfab297ae749401dd7f/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108b61d54adb806d5f40bdfab297ae749401dd7f/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=108b61d54adb806d5f40bdfab297ae749401dd7f", "patch": "@@ -80,6 +80,25 @@ enum internal_test {\n #define INTERNAL_SYMBOL_P(SYM) \\\n   (XSTR (SYM, 0)[0] == '*' && XSTR (SYM, 0)[1] == LOCAL_LABEL_PREFIX[0])\n \n+/* True if X is an unspec wrapper around a SYMBOL_REF or LABEL_REF.  */\n+#define UNSPEC_ADDRESS_P(X)\t\t\t\t\t\\\n+  (GET_CODE (X) == UNSPEC\t\t\t\t\t\\\n+   && XINT (X, 1) >= UNSPEC_ADDRESS_FIRST\t\t\t\\\n+   && XINT (X, 1) < UNSPEC_ADDRESS_FIRST + NUM_SYMBOL_TYPES)\n+\n+/* Extract the symbol or label from UNSPEC wrapper X.  */\n+#define UNSPEC_ADDRESS(X) \\\n+  XVECEXP (X, 0, 0)\n+\n+/* Extract the symbol type from UNSPEC wrapper X.  */\n+#define UNSPEC_ADDRESS_TYPE(X) \\\n+  ((enum mips_symbol_type) (XINT (X, 1) - UNSPEC_ADDRESS_FIRST))\n+\n+/* True if X is (const $gp).  This is used to initialize the mips16\n+   gp pseudo register.  */\n+#define CONST_GP_P(X) \\\n+  (GET_CODE (X) == CONST && XEXP (X, 0) == pic_offset_table_rtx)\n+\n /* The maximum distance between the top of the stack frame and the\n    value $sp has when we save & restore registers.\n \n@@ -93,40 +112,7 @@ enum internal_test {\n    multi-instruction addu sequence.  Use 0x7fe0 to work around this.  */\n #define MIPS_MAX_FIRST_STACK_STEP (TARGET_MIPS16 ? 0x100 : 0x7fe0)\n \n-/* Classifies a non-literal integer constant.\n-\n-   CONSTANT_NONE\n-       Not one of the constants below.\n-\n-   CONSTANT_GP\n-       The global pointer, treated as a constant when TARGET_MIPS16.\n-       The rtx has the form:\n-\n-\t   (const (reg $gp)).\n-\n-   CONSTANT_RELOC\n-       A signed 16-bit relocation against either a symbol\n-       or a symbol plus an offset.  The relocation has the form:\n-\n-\t   (unspec [(SYMBOL) ...] RELOC)\n-\n-       Any offset is added outside the unspec, such as:\n-\n-\t   (plus (unspec [(SYMBOL) ...] RELOC) (const_int OFFSET))\n-\n-       In either case, the whole expression is wrapped in a (const ...).\n-\n-   CONSTANT_SYMBOLIC\n-       A reference to a symbol, possibly with an offset.  */\n-enum mips_constant_type {\n-  CONSTANT_NONE,\n-  CONSTANT_GP,\n-  CONSTANT_RELOC,\n-  CONSTANT_SYMBOLIC\n-};\n-\n-\n-/* Classifies a SYMBOL_REF or LABEL_REF.\n+/* Classifies a SYMBOL_REF, LABEL_REF or UNSPEC address.\n \n    SYMBOL_GENERAL\n        Used when none of the below apply.\n@@ -142,21 +128,40 @@ enum mips_constant_type {\n        the global offset table.\n \n    SYMBOL_GOT_GLOBAL\n-       Likewise non-local data.  */\n+       Likewise non-local data.\n+\n+   SYMBOL_GOTOFF_PAGE\n+       An UNSPEC wrapper around a SYMBOL_GOT_LOCAL.  It represents the\n+       offset from _gp of a GOT page entry.\n+\n+   SYMBOL_GOTOFF_GLOBAL\n+       An UNSPEC wrapper around a SYMBOL_GOT_GLOBAL.  It represents the\n+       the offset from _gp of the symbol's GOT entry.\n+\n+   SYMBOL_GOTOFF_CALL\n+       Like SYMBOL_GOTOFF_GLOBAL, but used when calling a global function.\n+       The GOT entry is allowed to point to a stub rather than to the\n+       function itself.\n+\n+   SYMBOL_GOTOFF_LOADGP\n+       An UNSPEC wrapper around a function's address.  It represents the\n+       offset of _gp from the start of the function.  */\n enum mips_symbol_type {\n   SYMBOL_GENERAL,\n   SYMBOL_SMALL_DATA,\n   SYMBOL_CONSTANT_POOL,\n   SYMBOL_GOT_LOCAL,\n-  SYMBOL_GOT_GLOBAL\n+  SYMBOL_GOT_GLOBAL,\n+  SYMBOL_GOTOFF_PAGE,\n+  SYMBOL_GOTOFF_GLOBAL,\n+  SYMBOL_GOTOFF_CALL,\n+  SYMBOL_GOTOFF_LOADGP\n };\n+#define NUM_SYMBOL_TYPES (SYMBOL_GOTOFF_LOADGP + 1)\n \n \n /* Classifies an address.\n \n-   ADDRESS_INVALID\n-       The address should be rejected as invalid.\n-\n    ADDRESS_REG\n        A natural register + offset address.  The register satisfies\n        mips_valid_base_register_p and the offset is a const_arith_operand.\n@@ -171,7 +176,6 @@ enum mips_symbol_type {\n    ADDRESS_SYMBOLIC:\n        A constant symbolic address (equivalent to CONSTANT_SYMBOLIC).  */\n enum mips_address_type {\n-  ADDRESS_INVALID,\n   ADDRESS_REG,\n   ADDRESS_LO_SUM,\n   ADDRESS_CONST_INT,\n@@ -184,32 +188,24 @@ typedef void (*mips_save_restore_fn) (rtx, rtx);\n \n struct constant;\n struct mips_arg_info;\n-struct mips_constant_info;\n struct mips_address_info;\n struct mips_integer_op;\n \n-static bool mips_reloc_offset_ok_p (int, HOST_WIDE_INT);\n-static enum mips_constant_type\n-  mips_classify_constant (struct mips_constant_info *, rtx);\n static enum mips_symbol_type mips_classify_symbol (rtx);\n+static void mips_split_const (rtx, rtx *, HOST_WIDE_INT *);\n+static bool mips_symbolic_constant_p (rtx, enum mips_symbol_type *);\n static bool mips_valid_base_register_p (rtx, enum machine_mode, int);\n-static bool mips_symbolic_address_p (rtx, HOST_WIDE_INT,\n-\t\t\t\t     enum machine_mode, int);\n-static enum mips_address_type\n-  mips_classify_address (struct mips_address_info *, rtx,\n-\t\t\t enum machine_mode, int, int);\n-static bool mips_splittable_symbol_p (enum mips_symbol_type, HOST_WIDE_INT);\n+static bool mips_symbolic_address_p (enum mips_symbol_type, enum machine_mode);\n+static bool mips_classify_address (struct mips_address_info *, rtx,\n+\t\t\t\t   enum machine_mode, int);\n static int mips_symbol_insns (enum mips_symbol_type);\n static bool mips16_unextended_reference_p (enum machine_mode mode, rtx, rtx);\n-static rtx mips_reloc (rtx, int);\n-static rtx mips_lui_reloc (rtx, int);\n static rtx mips_force_temporary (rtx, rtx);\n+static rtx mips_split_symbol (rtx, rtx);\n+static rtx mips_unspec_address (rtx, enum mips_symbol_type);\n+static rtx mips_unspec_offset_high (rtx, rtx, enum mips_symbol_type);\n+static rtx mips_load_got (rtx, rtx, enum mips_symbol_type);\n static rtx mips_add_offset (rtx, HOST_WIDE_INT);\n-static rtx mips_load_got (rtx, rtx, int);\n-static rtx mips_load_got16 (rtx, int);\n-static rtx mips_load_got32 (rtx, rtx, int, int);\n-static rtx mips_emit_high (rtx, rtx);\n-static bool mips_legitimize_symbol (rtx, rtx *, int);\n static unsigned int mips_build_shift (struct mips_integer_op *, HOST_WIDE_INT);\n static unsigned int mips_build_lower (struct mips_integer_op *,\n \t\t\t\t      unsigned HOST_WIDE_INT);\n@@ -233,10 +229,14 @@ static bool mips_get_unaligned_mem (rtx *, unsigned int, int, rtx *, rtx *);\n static void mips_set_architecture (const struct mips_cpu_info *);\n static void mips_set_tune (const struct mips_cpu_info *);\n static struct machine_function *mips_init_machine_status (void);\n-static const char *mips_reloc_string (int);\n+static void print_operand_reloc (FILE *, rtx, const char **);\n static bool mips_assemble_integer (rtx, unsigned int, int);\n static void mips_file_start (void);\n static void mips_file_end (void);\n+static bool mips_rewrite_small_data_p (rtx);\n+static int small_data_pattern_1 (rtx *, void *);\n+static int mips_rewrite_small_data_1 (rtx *, void *);\n+static bool mips_function_has_gp_insn (void);\n static unsigned int mips_global_pointer\t(void);\n static bool mips_save_reg_p (unsigned int);\n static void mips_save_restore_reg (enum machine_mode, int, HOST_WIDE_INT,\n@@ -246,7 +246,6 @@ static void mips_output_function_prologue (FILE *, HOST_WIDE_INT);\n static void mips_set_frame_expr (rtx);\n static rtx mips_frame_set (rtx, rtx);\n static void mips_save_reg (rtx, rtx);\n-static void mips_gp_insn (rtx, rtx);\n static void mips_output_function_epilogue (FILE *, HOST_WIDE_INT);\n static void mips_restore_reg (rtx, rtx);\n static int symbolic_expression_p (rtx);\n@@ -256,7 +255,7 @@ static void mips_select_section (tree, int, unsigned HOST_WIDE_INT)\n \t\t\t\t  ATTRIBUTE_UNUSED;\n static bool mips_in_small_data_p (tree);\n static void mips_encode_section_info (tree, rtx, int);\n-static rtx mips_sdata_pointer (void);\n+static rtx mips16_gp_pseudo_reg (void);\n static void mips16_fp_args (FILE *, int, int);\n static void build_mips16_function_stub (FILE *);\n static void mips16_optimize_gp (void);\n@@ -337,6 +336,9 @@ struct machine_function GTY(()) {\n   /* True if the whole function is suitable for .set noreorder and\n      .set nomacro.  */\n   bool all_noreorder_p;\n+\n+  /* True if the function is known to have an instruction that needs $gp.  */\n+  bool has_gp_insn_p;\n };\n \n /* Information about a single argument.  */\n@@ -366,30 +368,8 @@ struct mips_arg_info\n };\n \n \n-/* Struct for recording constants.  The meaning of the fields depends\n-   on a mips_constant_type:\n-\n-   CONSTANT_NONE\n-   CONSTANT_GP\n-       No fields are valid.\n-\n-   CONSTANT_SYMBOLIC\n-       SYMBOL is the referenced symbol and OFFSET is the constant offset.\n-\n-   CONSTANT_RELOC\n-       SYMBOL and OFFSET are the same as for CONSTANT_SYMBOLIC.  RELOC is\n-       the relocation number.  */\n-struct mips_constant_info\n-{\n-  int reloc;\n-  rtx symbol;\n-  HOST_WIDE_INT offset;\n-};\n-\n-\n /* Information about an address described by mips_address_type.\n \n-   ADDRESS_INVALID\n    ADDRESS_CONST_INT\n        No fields are used.\n \n@@ -398,16 +378,18 @@ struct mips_constant_info\n \n    ADDRESS_LO_SUM\n        REG is the register that contains the high part of the address,\n-       OFFSET is the symbolic address being referenced, and C contains\n-       the individual components of the symbolic address.\n+       OFFSET is the symbolic address being referenced and SYMBOL_TYPE\n+       is the type of OFFSET's symbol.\n \n    ADDRESS_SYMBOLIC\n-       C contains the symbol and offset.  */\n+       SYMBOL_TYPE is the type of symbol being referenced.  */\n+\n struct mips_address_info\n {\n+  enum mips_address_type type;\n   rtx reg;\n   rtx offset;\n-  struct mips_constant_info c;\n+  enum mips_symbol_type symbol_type;\n };\n \n \n@@ -556,6 +538,18 @@ static int mips_flag_delayed_branch;\n \n static GTY (()) int mips_output_filename_first_time = 1;\n \n+/* mips_split_p[X] is true if symbols of type X can be split by\n+   mips_split_symbol().  */\n+static bool mips_split_p[NUM_SYMBOL_TYPES];\n+\n+/* mips_lo_relocs[X] is the relocation to use when a symbol of type X\n+   appears in a LO_SUM.  It can be null if such LO_SUMs aren't valid or\n+   if they are matched by a special .md file pattern.  */\n+static const char *mips_lo_relocs[NUM_SYMBOL_TYPES];\n+\n+/* Likewise for HIGHs.  */\n+static const char *mips_hi_relocs[NUM_SYMBOL_TYPES];\n+\n /* Hardware names for the registers.  If -mrnames is used, this\n    will be overwritten with mips_sw_reg_names.  */\n \n@@ -762,8 +756,6 @@ const struct mips_cpu_info mips_cpu_info_table[] = {\n #define TARGET_RTX_COSTS mips_rtx_costs\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST mips_address_cost\n-#undef TARGET_DELEGITIMIZE_ADDRESS\n-#define TARGET_DELEGITIMIZE_ADDRESS mips_delegitimize_address\n \n #undef TARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO mips_encode_section_info\n@@ -798,83 +790,6 @@ const struct mips_cpu_info mips_cpu_info_table[] = {\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n-/* Return true if RELOC is a valid relocation number and OFFSET can be\n-   added to the relocation symbol.\n-\n-   Note that OFFSET might not refer to part of the object.   For example,\n-   in an expression like x[i - 0x12345], we might try to take the address\n-   of \"x - 0x12345\".  */\n-\n-static bool\n-mips_reloc_offset_ok_p (int reloc, HOST_WIDE_INT offset)\n-{\n-  switch (reloc)\n-    {\n-    case RELOC_GOT_PAGE:\n-      /* The linker should provide enough page entries to cope with\n-\t 16-bit offsets from a valid segment address.  */\n-      return SMALL_OPERAND (offset);\n-\n-    case RELOC_GOT_HI:\n-    case RELOC_GOT_LO:\n-    case RELOC_GOT_DISP:\n-    case RELOC_CALL16:\n-    case RELOC_CALL_HI:\n-    case RELOC_CALL_LO:\n-    case RELOC_LOADGP_HI:\n-    case RELOC_LOADGP_LO:\n-      /* These relocations should be applied to bare symbols only.  */\n-      return offset == 0;\n-\n-    default:\n-      return false;\n-    }\n-}\n-\n-\n-/* If X is one of the constants described by mips_constant_type,\n-   store its components in INFO and return its type.  */\n-\n-static enum mips_constant_type\n-mips_classify_constant (struct mips_constant_info *info, rtx x)\n-{\n-  enum mips_constant_type type;\n-\n-  type = CONSTANT_SYMBOLIC;\n-  info->offset = 0;\n-\n-  if (GET_CODE (x) == CONST)\n-    {\n-      x = XEXP (x, 0);\n-\n-      if (x == pic_offset_table_rtx)\n-\treturn CONSTANT_GP;\n-\n-      while (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\t{\n-\t  info->offset += INTVAL (XEXP (x, 1));\n-\t  x = XEXP (x, 0);\n-\t}\n-\n-      if (TARGET_EXPLICIT_RELOCS\n-\t  && GET_CODE (x) == UNSPEC\n-\t  && mips_reloc_offset_ok_p (XINT (x, 1), info->offset))\n-\t{\n-\t  info->reloc = XINT (x, 1);\n-\t  x = XVECEXP (x, 0, 0);\n-\t  type = CONSTANT_RELOC;\n-\t}\n-    }\n-\n-  if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)\n-    {\n-      info->symbol = x;\n-      return type;\n-    }\n-  return CONSTANT_NONE;\n-}\n-\n-\n /* Classify symbol X, which must be a SYMBOL_REF or a LABEL_REF.  */\n \n static enum mips_symbol_type\n@@ -922,6 +837,83 @@ mips_classify_symbol (rtx x)\n }\n \n \n+/* Split X into a base and a constant offset, storing them in *BASE\n+   and *OFFSET respectively.  */\n+\n+static void\n+mips_split_const (rtx x, rtx *base, HOST_WIDE_INT *offset)\n+{\n+  *offset = 0;\n+\n+  if (GET_CODE (x) == CONST)\n+    x = XEXP (x, 0);\n+\n+  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    {\n+      *offset += INTVAL (XEXP (x, 1));\n+      x = XEXP (x, 0);\n+    }\n+  *base = x;\n+}\n+\n+\n+/* Return true if X is a symbolic constant that can be calculated in\n+   the same way as a bare symbol.  If it is, store the type of the\n+   symbol in *SYMBOL_TYPE.  */\n+\n+static bool\n+mips_symbolic_constant_p (rtx x, enum mips_symbol_type *symbol_type)\n+{\n+  HOST_WIDE_INT offset;\n+\n+  mips_split_const (x, &x, &offset);\n+  if (UNSPEC_ADDRESS_P (x))\n+    *symbol_type = UNSPEC_ADDRESS_TYPE (x);\n+  else if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)\n+    *symbol_type = mips_classify_symbol (x);\n+  else\n+    return false;\n+\n+  if (offset == 0)\n+    return true;\n+\n+  /* Check whether a nonzero offset is valid for the underlying\n+     relocations.  */\n+  switch (*symbol_type)\n+    {\n+    case SYMBOL_GENERAL:\n+      /* %hi() and %lo() can handle anything.  */\n+      return true;\n+\n+    case SYMBOL_SMALL_DATA:\n+      /* Make sure that the offset refers to something within the\n+\t -G limit.  If the offset is allowed to grow too much,\n+\t it could overflow the range of %gp_rel().  */\n+      return (offset > 0 && offset < mips_section_threshold);\n+\n+    case SYMBOL_CONSTANT_POOL:\n+      /* Similarly check the range of offsets for mips16 constant\n+\t pool entries.  */\n+      return (CONSTANT_POOL_ADDRESS_P (x)\n+\t      && offset > 0\n+\t      && offset < (int) GET_MODE_SIZE (get_pool_mode (x)));\n+\n+    case SYMBOL_GOT_LOCAL:\n+    case SYMBOL_GOTOFF_PAGE:\n+      /* The linker should provide enough local GOT entries for a\n+\t 16-bit offset.  Larger offsets may lead to GOT overflow.  */\n+      return SMALL_OPERAND (offset);\n+\n+    case SYMBOL_GOT_GLOBAL:\n+    case SYMBOL_GOTOFF_GLOBAL:\n+    case SYMBOL_GOTOFF_CALL:\n+    case SYMBOL_GOTOFF_LOADGP:\n+      return false;\n+    }\n+  abort ();\n+}\n+\n+\n /* This function is used to implement REG_MODE_OK_FOR_BASE_P.  */\n \n int\n@@ -947,155 +939,94 @@ mips_valid_base_register_p (rtx x, enum machine_mode mode, int strict)\n }\n \n \n-/* Return true if SYMBOL + OFFSET should be considered a legitimate\n-   address.  LEA_P is true and MODE is word_mode if the address\n-   will be used in an LA or DLA macro.  Otherwise MODE is the\n-   mode of the value being accessed.\n-\n-   Some guiding principles:\n-\n-   - Allow a nonzero offset when it takes no additional instructions.\n-     Ask for other offsets to be added separately.\n-\n-   - Only allow multi-instruction load or store macros when MODE is\n-     word-sized or smaller.  For other modes (including BLKmode)\n-     it is better to move the address into a register first.  */\n+/* Return true if symbols of type SYMBOL_TYPE can directly address a value\n+   with mode MODE.  This is used for both symbolic and LO_SUM addresses.  */\n \n static bool\n-mips_symbolic_address_p (rtx symbol, HOST_WIDE_INT offset,\n-\t\t\t enum machine_mode mode, int lea_p)\n+mips_symbolic_address_p (enum mips_symbol_type symbol_type,\n+\t\t\t enum machine_mode mode)\n {\n-  if (TARGET_EXPLICIT_RELOCS)\n-    return false;\n-\n-  switch (mips_classify_symbol (symbol))\n+  switch (symbol_type)\n     {\n     case SYMBOL_GENERAL:\n-      /* General symbols aren't valid addresses in mips16 code:\n-\t they have to go into the constant pool.  */\n-      return (!TARGET_MIPS16\n-\t      && !mips_split_addresses\n-\t      && SINGLE_WORD_MODE_P (mode));\n+      return !TARGET_MIPS16;\n \n     case SYMBOL_SMALL_DATA:\n-      /* Small data references are normally OK for any address.\n-\t But for mips16 code, we need to use a pseudo register\n-\t instead of $gp as the base register.  */\n-      return !TARGET_MIPS16;\n+      return true;\n \n     case SYMBOL_CONSTANT_POOL:\n-      /* PC-relative addressing is only available for lw, sw, ld and sd.\n-\t There's also a PC-relative add instruction.  */\n-      return lea_p || GET_MODE_SIZE (mode) == 4 || GET_MODE_SIZE (mode) == 8;\n+      /* PC-relative addressing is only available for lw, sw, ld and sd.  */\n+      return GET_MODE_SIZE (mode) == 4 || GET_MODE_SIZE (mode) == 8;\n+\n+    case SYMBOL_GOT_LOCAL:\n+      return true;\n \n     case SYMBOL_GOT_GLOBAL:\n-      /* The address of the symbol is stored in the GOT.  We can load\n-\t it using an LA or DLA instruction, but any offset is added\n-\t afterwards.  */\n-      return lea_p && offset == 0;\n+      /* The address will have to be loaded from the GOT first.  */\n+      return false;\n \n-    case SYMBOL_GOT_LOCAL:\n-      /* The symbol is part of a block of local memory.  We fetch the\n-\t address of the local memory from the GOT and then add the\n-\t offset for this symbol.  This addition can take the form of an\n-\t offset(base) address, so the symbol is a legitimate address.  */\n-      return SINGLE_WORD_MODE_P (mode);\n+    case SYMBOL_GOTOFF_PAGE:\n+    case SYMBOL_GOTOFF_GLOBAL:\n+    case SYMBOL_GOTOFF_CALL:\n+    case SYMBOL_GOTOFF_LOADGP:\n+      return true;\n     }\n   abort ();\n }\n \n \n-/* If X is a valid address, describe it in INFO and return its type.\n-   STRICT says to only allow hard registers.  MODE and LEA_P are\n-   the same as for mips_symbolic_address_p.  */\n+/* Return true if X is a valid address for machine mode MODE.  If it is,\n+   fill in INFO appropriately.  STRICT is true if we should only accept\n+   hard base registers.  */\n \n-static enum mips_address_type\n+static bool\n mips_classify_address (struct mips_address_info *info, rtx x,\n-\t\t       enum machine_mode mode, int strict, int lea_p)\n+\t\t       enum machine_mode mode, int strict)\n {\n   switch (GET_CODE (x))\n     {\n     case REG:\n     case SUBREG:\n-      if (mips_valid_base_register_p (x, mode, strict))\n-\t{\n-\t  info->reg = x;\n-\t  info->offset = const0_rtx;\n-\t  return ADDRESS_REG;\n-\t}\n-      return ADDRESS_INVALID;\n+      info->type = ADDRESS_REG;\n+      info->reg = x;\n+      info->offset = const0_rtx;\n+      return mips_valid_base_register_p (info->reg, mode, strict);\n \n     case PLUS:\n-      if (mips_valid_base_register_p (XEXP (x, 0), mode, strict)\n-\t  && const_arith_operand (XEXP (x, 1), VOIDmode))\n-\t{\n-\t  info->reg = XEXP (x, 0);\n-\t  info->offset = XEXP (x, 1);\n-\t  return ADDRESS_REG;\n-\t}\n-      return ADDRESS_INVALID;\n+      info->type = ADDRESS_REG;\n+      info->reg = XEXP (x, 0);\n+      info->offset = XEXP (x, 1);\n+      return (mips_valid_base_register_p (info->reg, mode, strict)\n+\t      && const_arith_operand (info->offset, VOIDmode));\n \n     case LO_SUM:\n-      if (SINGLE_WORD_MODE_P (mode)\n-\t  && mips_valid_base_register_p (XEXP (x, 0), mode, strict)\n-\t  && (mips_classify_constant (&info->c, XEXP (x, 1))\n-\t      == CONSTANT_SYMBOLIC)\n-\t  && mips_splittable_symbol_p (mips_classify_symbol (info->c.symbol),\n-\t\t\t\t       info->c.offset))\n-\t{\n-\t  info->reg = XEXP (x, 0);\n-\t  info->offset = XEXP (x, 1);\n-\t  return ADDRESS_LO_SUM;\n-\t}\n-      return ADDRESS_INVALID;\n+      info->type = ADDRESS_LO_SUM;\n+      info->reg = XEXP (x, 0);\n+      info->offset = XEXP (x, 1);\n+      return (mips_valid_base_register_p (info->reg, mode, strict)\n+\t      && mips_symbolic_constant_p (info->offset, &info->symbol_type)\n+\t      && mips_symbolic_address_p (info->symbol_type, mode)\n+\t      && mips_lo_relocs[info->symbol_type] != 0);\n \n     case CONST_INT:\n       /* Small-integer addresses don't occur very often, but they\n \t are legitimate if $0 is a valid base register.  */\n-      if (!TARGET_MIPS16 && SMALL_INT (x))\n-\treturn ADDRESS_CONST_INT;\n-      return ADDRESS_INVALID;\n+      info->type = ADDRESS_CONST_INT;\n+      return !TARGET_MIPS16 && SMALL_INT (x);\n \n     case CONST:\n     case LABEL_REF:\n     case SYMBOL_REF:\n-      if (mips_classify_constant (&info->c, x) == CONSTANT_SYMBOLIC\n-\t  && mips_symbolic_address_p (info->c.symbol, info->c.offset,\n-\t\t\t\t      mode, lea_p))\n-\treturn ADDRESS_SYMBOLIC;\n-      return ADDRESS_INVALID;\n-\n-    default:\n-      return ADDRESS_INVALID;\n-    }\n-}\n-\f\n-/* Return true if symbols of the given type can be split into a\n-   high part and a LO_SUM.  In the case of small data symbols,\n-   the high part will be $gp.  */\n-\n-static bool\n-mips_splittable_symbol_p (enum mips_symbol_type type, HOST_WIDE_INT offset)\n-{\n-  switch (type)\n-    {\n-    case SYMBOL_GENERAL:\n-      return TARGET_EXPLICIT_RELOCS || mips_split_addresses;\n-\n-    case SYMBOL_GOT_LOCAL:\n-      return TARGET_EXPLICIT_RELOCS && SMALL_OPERAND (offset);\n-\n-    case SYMBOL_SMALL_DATA:\n-      return ((TARGET_EXPLICIT_RELOCS || TARGET_MIPS16)\n-\t      && (offset == 0\n-\t\t  || (offset > 0 && offset <= mips_section_threshold)));\n+      info->type = ADDRESS_SYMBOLIC;\n+      return (mips_symbolic_constant_p (x, &info->symbol_type)\n+\t      && mips_symbolic_address_p (info->symbol_type, mode)\n+\t      && !mips_split_p[info->symbol_type]);\n \n     default:\n       return false;\n     }\n }\n-\n-\n+\f\n /* Return the number of instructions needed to load a symbol of the\n    given type into a register.  If valid in an address, the same number\n    of instructions are needed for loads and stores.  Treat extended\n@@ -1107,6 +1038,11 @@ mips_symbol_insns (enum mips_symbol_type type)\n   switch (type)\n     {\n     case SYMBOL_GENERAL:\n+      /* In mips16 code, general symbols must be fetched from the\n+\t constant pool.  */\n+      if (TARGET_MIPS16)\n+\treturn 0;\n+\n       /* When using 64-bit symbols, we need 5 preparatory instructions,\n \t such as:\n \n@@ -1128,17 +1064,6 @@ mips_symbol_insns (enum mips_symbol_type type)\n \t extended instruction.  */\n       return 2;\n \n-    case SYMBOL_GOT_GLOBAL:\n-      /* When using a small GOT, we just fetch the address using\n-\t a gp-relative load.   For a big GOT, we need a sequence\n-\t such as:\n-\n-\t      lui     $at,%got_hi(symbol)\n-\t      daddu   $at,$at,$gp\n-\n-\t and the final address is $at + %got_lo(symbol).  */\n-      return (TARGET_XGOT ? 3 : 1);\n-\n     case SYMBOL_GOT_LOCAL:\n       /* For o32 and o64, the sequence is:\n \n@@ -1150,6 +1075,24 @@ mips_symbol_insns (enum mips_symbol_type type)\n \t of GAS insert a nop in the n32/n64 sequences too so, for\n \t simplicity, use the worst case of 3 instructions.  */\n       return 3;\n+\n+    case SYMBOL_GOT_GLOBAL:\n+      /* When using a small GOT, we just fetch the address using\n+\t a gp-relative load.   For a big GOT, we need a sequence\n+\t such as:\n+\n+\t      lui     $at,%got_hi(symbol)\n+\t      daddu   $at,$at,$gp\n+\n+\t and the final address is $at + %got_lo(symbol).  */\n+      return (TARGET_XGOT ? 3 : 1);\n+\n+    case SYMBOL_GOTOFF_PAGE:\n+    case SYMBOL_GOTOFF_GLOBAL:\n+    case SYMBOL_GOTOFF_CALL:\n+    case SYMBOL_GOTOFF_LOADGP:\n+      /* Check whether the offset is a 16- or 32-bit value.  */\n+      return mips_split_p[type] ? 2 : 1;\n     }\n   abort ();\n }\n@@ -1193,27 +1136,25 @@ mips_address_insns (rtx x, enum machine_mode mode)\n \n   /* Each word of a multi-word value will be accessed individually.  */\n   factor = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-  switch (mips_classify_address (&addr, x, mode, 0, 0))\n-    {\n-    case ADDRESS_INVALID:\n-      return 0;\n-\n-    case ADDRESS_REG:\n-      if (TARGET_MIPS16\n-\t  && !mips16_unextended_reference_p (mode, addr.reg, addr.offset))\n-\treturn factor * 2;\n-      return factor;\n+  if (mips_classify_address (&addr, x, mode, false))\n+    switch (addr.type)\n+      {\n+      case ADDRESS_REG:\n+\tif (TARGET_MIPS16\n+\t    && !mips16_unextended_reference_p (mode, addr.reg, addr.offset))\n+\t  return factor * 2;\n+\treturn factor;\n \n-    case ADDRESS_LO_SUM:\n-      return (TARGET_MIPS16 ? factor * 2 : factor);\n+      case ADDRESS_LO_SUM:\n+\treturn (TARGET_MIPS16 ? factor * 2 : factor);\n \n-    case ADDRESS_CONST_INT:\n-      return factor;\n+      case ADDRESS_CONST_INT:\n+\treturn factor;\n \n-    case ADDRESS_SYMBOLIC:\n-      return factor * mips_symbol_insns (mips_classify_symbol (addr.c.symbol));\n-    }\n-  abort ();\n+      case ADDRESS_SYMBOLIC:\n+\treturn factor * mips_symbol_insns (addr.symbol_type);\n+      }\n+  return 0;\n }\n \n \n@@ -1222,13 +1163,21 @@ mips_address_insns (rtx x, enum machine_mode mode)\n int\n mips_const_insns (rtx x)\n {\n-  struct mips_constant_info c;\n   struct mips_integer_op codes[MIPS_MAX_INTEGER_OPS];\n+  enum mips_symbol_type symbol_type;\n+  HOST_WIDE_INT offset;\n \n   switch (GET_CODE (x))\n     {\n     case CONSTANT_P_RTX:\n+      return 1;\n+\n     case HIGH:\n+      if (TARGET_MIPS16\n+\t  || !mips_symbolic_constant_p (XEXP (x, 0), &symbol_type)\n+\t  || !mips_split_p[symbol_type])\n+\treturn 0;\n+\n       return 1;\n \n     case CONST_INT:\n@@ -1248,20 +1197,37 @@ mips_const_insns (rtx x)\n     case CONST_DOUBLE:\n       return (!TARGET_MIPS16 && x == CONST0_RTX (GET_MODE (x)) ? 1 : 0);\n \n-    default:\n-      switch (mips_classify_constant (&c, x))\n+    case CONST:\n+      if (CONST_GP_P (x))\n+\treturn 1;\n+\n+      /* See if we can refer to X directly.  */\n+      if (mips_symbolic_constant_p (x, &symbol_type))\n+\treturn mips_symbol_insns (symbol_type);\n+\n+      /* Otherwise try splitting the constant into a base and offset.\n+\t 16-bit offsets can be added using an extra addiu.  Larger offsets\n+\t must be calculated separately and then added to the base.  */\n+      mips_split_const (x, &x, &offset);\n+      if (offset != 0)\n \t{\n-\tcase CONSTANT_NONE:\n-\t  return 0;\n+\t  int n = mips_const_insns (x);\n+\t  if (n != 0)\n+\t    {\n+\t      if (SMALL_OPERAND (offset))\n+\t\treturn n + 1;\n+\t      else\n+\t\treturn n + 1 + mips_build_integer (codes, offset);\n+\t    }\n+\t}\n+      return 0;\n \n-\tcase CONSTANT_GP:\n-\tcase CONSTANT_RELOC:\n-\t  return 1;\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return mips_symbol_insns (mips_classify_symbol (x));\n \n-\tcase CONSTANT_SYMBOLIC:\n-\t  return mips_symbol_insns (mips_classify_symbol (c.symbol));\n-\t}\n-      abort ();\n+    default:\n+      return 0;\n     }\n }\n \n@@ -1279,19 +1245,6 @@ mips_fetch_insns (rtx x)\n }\n \n \n-/* Return true if OP is a symbolic constant that refers to a\n-   global PIC symbol.  */\n-\n-bool\n-mips_global_pic_constant_p (rtx op)\n-{\n-  struct mips_constant_info c;\n-\n-  return (mips_classify_constant (&c, op) == CONSTANT_SYMBOLIC\n-\t  && mips_classify_symbol (c.symbol) == SYMBOL_GOT_GLOBAL);\n-}\n-\n-\n /* Return truth value of whether OP can be used as an operands\n    where a register or 16 bit unsigned integer is needed.  */\n \n@@ -1310,10 +1263,7 @@ uns_arith_operand (rtx op, enum machine_mode mode)\n int\n const_arith_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n-  struct mips_constant_info c;\n-\n-  return ((GET_CODE (op) == CONST_INT && SMALL_INT (op))\n-\t  || mips_classify_constant (&c, op) == CONSTANT_RELOC);\n+  return GET_CODE (op) == CONST_INT && SMALL_INT (op);\n }\n \n \n@@ -1481,10 +1431,10 @@ pc_or_label_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n int\n call_insn_operand (rtx op, enum machine_mode mode)\n {\n-  struct mips_constant_info c;\n+  enum mips_symbol_type symbol_type;\n \n-  if (mips_classify_constant (&c, op) == CONSTANT_SYMBOLIC)\n-    switch (mips_classify_symbol (c.symbol))\n+  if (mips_symbolic_constant_p (op, &symbol_type))\n+    switch (symbol_type)\n       {\n       case SYMBOL_GENERAL:\n \t/* If -mlong-calls, force all calls to use register addressing.  */\n@@ -1496,7 +1446,7 @@ call_insn_operand (rtx op, enum machine_mode mode)\n \t   Using \"la $25,foo; jal $25\" would prevent the lazy binding\n \t   of \"foo\", so keep the address of global symbols with the\n \t   jal macro.  */\n-\treturn c.offset == 0 && !TARGET_EXPLICIT_RELOCS;\n+\treturn !TARGET_EXPLICIT_RELOCS;\n \n       default:\n \treturn false;\n@@ -1511,15 +1461,35 @@ call_insn_operand (rtx op, enum machine_mode mode)\n int\n move_operand (rtx op, enum machine_mode mode)\n {\n-  struct mips_constant_info c;\n+  enum mips_symbol_type symbol_type;\n \n-  if (GET_CODE (op) == HIGH && TARGET_ABICALLS)\n+  if (!general_operand (op, mode))\n     return false;\n-  if (GET_CODE (op) == CONST_INT && !TARGET_MIPS16)\n-    return (SMALL_INT (op) || SMALL_INT_UNSIGNED (op) || LUI_INT (op));\n-  if (mips_classify_constant (&c, op) == CONSTANT_SYMBOLIC)\n-    return mips_symbolic_address_p (c.symbol, c.offset, word_mode, 1);\n-  return general_operand (op, mode);\n+\n+  switch (GET_CODE (op))\n+    {\n+    case CONST_INT:\n+      /* When generating mips16 code, LEGITIMATE_CONSTANT_P rejects\n+\t CONST_INTs that can't be loaded using simple insns.  */\n+      if (TARGET_MIPS16)\n+\treturn true;\n+\n+      /* Otherwise check whether the constant can be loaded in a single\n+\t instruction.  */\n+      return LUI_INT (op) || SMALL_INT (op) || SMALL_INT_UNSIGNED (op);\n+\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      if (CONST_GP_P (op))\n+\treturn true;\n+\n+      return (mips_symbolic_constant_p (op, &symbol_type)\n+\t      && !mips_split_p[symbol_type]);\n+\n+    default:\n+      return true;\n+    }\n }\n \n \n@@ -1540,9 +1510,35 @@ consttable_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n int\n symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n-  struct mips_constant_info c;\n+  enum mips_symbol_type symbol_type;\n+\n+  return mips_symbolic_constant_p (op, &symbol_type);\n+}\n+\n+\n+/* Return true if we're generating PIC and OP is a global symbol.  */\n+\n+int\n+global_got_operand (rtx op, enum machine_mode mode)\n+{\n+  enum mips_symbol_type symbol_type;\n+\n+  return ((mode == VOIDmode || mode == GET_MODE (op))\n+\t  && mips_symbolic_constant_p (op, &symbol_type)\n+\t  && symbol_type == SYMBOL_GOT_GLOBAL);\n+}\n+\n+\n+/* Likewise for local symbols.  */\n+\n+int\n+local_got_operand (rtx op, enum machine_mode mode)\n+{\n+  enum mips_symbol_type symbol_type;\n \n-  return mips_classify_constant (&c, op) == CONSTANT_SYMBOLIC;\n+  return ((mode == VOIDmode || mode == GET_MODE (op))\n+\t  && mips_symbolic_constant_p (op, &symbol_type)\n+\t  && symbol_type == SYMBOL_GOT_LOCAL);\n }\n \n \n@@ -1556,8 +1552,8 @@ stack_operand (rtx op, enum machine_mode mode)\n \n   return ((mode == VOIDmode || mode == GET_MODE (op))\n \t  && GET_CODE (op) == MEM\n-\t  && mips_classify_address (&addr, XEXP (op, 0),\n-\t\t\t\t    GET_MODE (op), false, true) == ADDRESS_REG\n+\t  && mips_classify_address (&addr, XEXP (op, 0), GET_MODE (op), false)\n+\t  && addr.type == ADDRESS_REG\n \t  && addr.reg == stack_pointer_rtx);\n }\n \n@@ -1572,199 +1568,142 @@ mips_legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n {\n   struct mips_address_info addr;\n \n-  return mips_classify_address (&addr, x, mode, strict, 0) != ADDRESS_INVALID;\n+  return mips_classify_address (&addr, x, mode, strict);\n }\n \n \n-/* Return an rtx that represents the effect of applying relocation\n-   RELOC to symbolic address ADDR.  */\n+/* Copy VALUE to a register and return that register.  If new psuedos\n+   are allowed, copy it into a new register, otherwise use DEST.  */\n \n static rtx\n-mips_reloc (rtx addr, int reloc)\n+mips_force_temporary (rtx dest, rtx value)\n {\n-  struct mips_constant_info c;\n-  rtx x;\n-\n-  if (mips_classify_constant (&c, addr) != CONSTANT_SYMBOLIC)\n-    abort ();\n-\n-  x = gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, c.symbol), reloc);\n-  return plus_constant (gen_rtx_CONST (VOIDmode, x), c.offset);\n+  if (!no_new_pseudos)\n+    return force_reg (Pmode, value);\n+  else\n+    {\n+      emit_move_insn (copy_rtx (dest), value);\n+      return dest;\n+    }\n }\n \n \n-/* Likewise, but shift the result left 16 bits.  The expression can be\n-   used as the right hand side of an LUISI or LUIDI pattern.  */\n+/* Return a LO_SUM expression for ADDR.  TEMP is as for mips_force_temporary\n+   and is used to load the high part into a register.  */\n \n static rtx\n-mips_lui_reloc (rtx addr, int reloc)\n+mips_split_symbol (rtx temp, rtx addr)\n {\n-  return gen_rtx_UNSPEC (Pmode,\n-\t\t\t gen_rtvec (1, mips_reloc (addr, reloc)),\n-\t\t\t UNSPEC_HIGH);\n+  rtx high;\n+\n+  if (TARGET_MIPS16)\n+    high = mips16_gp_pseudo_reg ();\n+  else\n+    high = mips_force_temporary (temp, gen_rtx_HIGH (Pmode, copy_rtx (addr)));\n+  return gen_rtx_LO_SUM (Pmode, high, addr);\n }\n \n-/* Copy VALUE to a register and return that register.  Use DEST as the\n-   register if non-null, otherwise create a new one.\n \n-   VALUE must be valid on the right hand side of a simple SET pattern.\n-   The operation happens in Pmode.  */\n+/* Return an UNSPEC address with underlying address ADDRESS and symbol\n+   type SYMBOL_TYPE.  */\n \n static rtx\n-mips_force_temporary (rtx dest, rtx value)\n+mips_unspec_address (rtx address, enum mips_symbol_type symbol_type)\n {\n-  if (dest == 0)\n-    return force_reg (Pmode, value);\n-  else\n-    {\n-      if (!rtx_equal_p (dest, value))\n-\temit_insn (gen_rtx_SET (VOIDmode, copy_rtx (dest), value));\n-      return dest;\n-    }\n+  rtx base;\n+  HOST_WIDE_INT offset;\n+\n+  mips_split_const (address, &base, &offset);\n+  base = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, base),\n+\t\t\t UNSPEC_ADDRESS_FIRST + symbol_type);\n+  return plus_constant (gen_rtx_CONST (Pmode, base), offset);\n }\n \n \n-/* Return a legitimate address for REG + OFFSET.  This function will\n-   create a temporary register if OFFSET is not a SMALL_OPERAND.  */\n+/* If mips_unspec_address (ADDR, SYMBOL_TYPE) is a 32-bit value, add the\n+   high part to BASE and return the result.  Just return BASE otherwise.\n+\n+   The returned expression can be used as the first operand to a LO_SUM.  */\n \n static rtx\n-mips_add_offset (rtx reg, HOST_WIDE_INT offset)\n+mips_unspec_offset_high (rtx base, rtx addr, enum mips_symbol_type symbol_type)\n {\n-  if (!SMALL_OPERAND (offset))\n-    reg = expand_simple_binop (GET_MODE (reg), PLUS,\n-\t\t\t       GEN_INT (CONST_HIGH_PART (offset)),\n-\t\t\t       reg, NULL, 0, OPTAB_WIDEN);\n-\n-  return plus_constant (reg, CONST_LOW_PART (offset));\n+  if (mips_split_p[symbol_type])\n+    {\n+      addr = gen_rtx_HIGH (Pmode, mips_unspec_address (addr, symbol_type));\n+      base = force_reg (Pmode, expand_simple_binop (Pmode, PLUS, base, addr,\n+\t\t\t\t\t\t    NULL, 0, OPTAB_WIDEN));\n+    }\n+  return base;\n }\n \n \n-/* Return the GOT entry whose address is given by %RELOC(ADDR)(BASE).\n-   BASE is a base register (such as $gp), ADDR is addresses being\n-   sought and RELOC is the relocation that should be used.  */\n+/* Return a memory reference for the GOT slot whose offset is given by\n+   mips_unspec_address (ADDR, SYMBOL_TYPE).  Register BASE contains the\n+   high part of the offset plus $gp.  */\n \n static rtx\n-mips_load_got (rtx base, rtx addr, int reloc)\n+mips_load_got (rtx base, rtx addr, enum mips_symbol_type symbol_type)\n {\n-  rtx mem;\n+  rtx mem, offset;\n \n-  mem = gen_rtx_MEM (ptr_mode,\n-\t\t     gen_rtx_PLUS (Pmode, base, mips_reloc (addr, reloc)));\n+  offset = mips_unspec_address (addr, symbol_type);\n+  mem = gen_rtx_MEM (ptr_mode, gen_rtx_LO_SUM (Pmode, base, offset));\n   set_mem_alias_set (mem, mips_got_alias_set);\n \n   /* GOT references can't trap.  */\n   MEM_NOTRAP_P (mem) = 1;\n \n   /* If we allow a function's address to be lazily bound, its entry\n      may change after the first call.  Other entries are constant.  */\n-  if (reloc != RELOC_CALL16 && reloc != RELOC_CALL_LO)\n+  if (symbol_type != SYMBOL_GOTOFF_CALL)\n     RTX_UNCHANGING_P (mem) = 1;\n \n   return mem;\n }\n \n \n-/* Obtain the address of ADDR from the GOT using relocation RELOC.\n-   The returned address may be used on the right hand side of a SET.  */\n+/* Return the offset of ADDR's GOT entry from _gp.  ADDR is a\n+   global_got_operand.  */\n \n-static rtx\n-mips_load_got16 (rtx addr, int reloc)\n+rtx\n+mips_gotoff_global (rtx addr)\n {\n-  return mips_load_got (pic_offset_table_rtx, addr, reloc);\n+  return mips_unspec_address (addr, SYMBOL_GOTOFF_GLOBAL);\n }\n \n \n-/* Like mips_load_got16, but for 32-bit offsets.  HIGH_RELOC is the\n-   relocation that gives the high 16 bits of the offset and LOW_RELOC is\n-   the relocation that gives the low 16 bits.  TEMP is a Pmode register\n-   to use a temporary, or null if new registers can be created at will.  */\n+/* Fetch the high part of local_got_operand ADDR from the GOT.  */\n \n-static rtx\n-mips_load_got32 (rtx temp, rtx addr, int high_reloc, int low_reloc)\n+rtx\n+mips_load_got_page (rtx addr)\n {\n-  rtx x;\n-\n-  x = mips_force_temporary (temp, mips_lui_reloc (addr, high_reloc));\n-  x = mips_force_temporary (temp,\n-\t\t\t    gen_rtx_PLUS (Pmode, pic_offset_table_rtx, x));\n-  return mips_load_got (x, addr, low_reloc);\n+  return mips_load_got (pic_offset_table_rtx, addr, SYMBOL_GOTOFF_PAGE);\n }\n \n \n-/* Copy the high part of ADDR into a register and return the register.\n-   Use DEST as the register if non-null.  */\n+/* Fetch the address of global_got_operand ADDR from the GOT.  BASE is a\n+   register that holds the address _gp + %got_hi(ADDR).  */\n \n-static rtx\n-mips_emit_high (rtx dest, rtx addr)\n+rtx\n+mips_load_got_global (rtx base, rtx addr)\n {\n-  rtx high, x;\n-\n-  high = gen_rtx_HIGH (Pmode, addr);\n-  if (TARGET_ABICALLS)\n-    {\n-      x = mips_load_got16 (copy_rtx (addr), RELOC_GOT_PAGE);\n-      x = mips_force_temporary (dest, x);\n-      set_unique_reg_note (get_last_insn (), REG_EQUAL, high);\n-    }\n-  else\n-    x = mips_force_temporary (dest, high);\n-\n-  return x;\n+  return mips_load_got (base, addr, SYMBOL_GOTOFF_GLOBAL);\n }\n \n \n-/* See if *XLOC is a symbolic constant that can be reduced in some way.\n-   If it is, set *XLOC to the reduced expression and return true.\n-   The new expression will be both a legitimate address and a legitimate\n-   source operand for a mips.md SET pattern.  If OFFSETABLE_P, the\n-   address will be offsetable.\n-\n-   DEST is a register to use a temporary, or null if new registers\n-   can be created at will.  */\n+/* Return a legitimate address for REG + OFFSET.  This function will\n+   create a temporary register if OFFSET is not a SMALL_OPERAND.  */\n \n-static bool\n-mips_legitimize_symbol (rtx dest, rtx *xloc, int offsetable_p)\n+static rtx\n+mips_add_offset (rtx reg, HOST_WIDE_INT offset)\n {\n-  struct mips_constant_info c;\n-  enum mips_symbol_type symbol_type;\n-  rtx x;\n-\n-  if (mips_classify_constant (&c, *xloc) != CONSTANT_SYMBOLIC)\n-    return false;\n-\n-  symbol_type = mips_classify_symbol (c.symbol);\n-\n-  /* If a non-offsetable address is OK, try splitting it into a\n-     high part and a LO_SUM.  */\n-  if (!offsetable_p && mips_splittable_symbol_p (symbol_type, c.offset))\n-    {\n-      if (symbol_type == SYMBOL_SMALL_DATA)\n-\tx = mips_sdata_pointer ();\n-      else\n-\tx = mips_emit_high (dest, *xloc);\n-      if (x != 0)\n-\t{\n-\t  *xloc = gen_rtx_LO_SUM (Pmode, x, copy_rtx (*xloc));\n-\t  return true;\n-\t}\n-    }\n-\n-  /* If the offset is nonzero, move the symbol into a register (always valid)\n-     and add the constant in afterwards.  This requires an extra temporary if\n-     the offset isn't a signed 16-bit number.\n-\n-     For mips16, it's better to force the constant into memory instead.  */\n-  if (!TARGET_MIPS16\n-      && c.offset != 0\n-      && (SMALL_OPERAND (c.offset) || dest == 0))\n-    {\n-      x = (dest == 0 ? gen_reg_rtx (Pmode) : dest);\n-      emit_move_insn (copy_rtx (x), c.symbol);\n-      *xloc = mips_add_offset (x, c.offset);\n-      return true;\n-    }\n+  if (!SMALL_OPERAND (offset))\n+    reg = expand_simple_binop (GET_MODE (reg), PLUS,\n+\t\t\t       GEN_INT (CONST_HIGH_PART (offset)),\n+\t\t\t       reg, NULL, 0, OPTAB_WIDEN);\n \n-  return false;\n+  return plus_constant (reg, CONST_LOW_PART (offset));\n }\n \n \n@@ -1776,8 +1715,16 @@ mips_legitimize_symbol (rtx dest, rtx *xloc, int offsetable_p)\n bool\n mips_legitimize_address (rtx *xloc, enum machine_mode mode)\n {\n-  if (mips_legitimize_symbol (0, xloc, !SINGLE_WORD_MODE_P (mode)))\n-    return true;\n+  enum mips_symbol_type symbol_type;\n+\n+  /* See if the address can split into a high part and a LO_SUM.  */\n+  if (mips_symbolic_constant_p (*xloc, &symbol_type)\n+      && mips_symbolic_address_p (symbol_type, mode)\n+      && mips_split_p[symbol_type])\n+    {\n+      *xloc = mips_split_symbol (0, *xloc);\n+      return true;\n+    }\n \n   if (GET_CODE (*xloc) == PLUS && GET_CODE (XEXP (*xloc, 1)) == CONST_INT)\n     {\n@@ -1933,54 +1880,48 @@ mips_move_integer (rtx dest, unsigned HOST_WIDE_INT value)\n static void\n mips_legitimize_const_move (enum machine_mode mode, rtx dest, rtx src)\n {\n-  rtx temp;\n-\n-  temp = no_new_pseudos ? dest : 0;\n-\n-  /* If generating PIC, the high part of an address is loaded from the GOT.  */\n-  if (GET_CODE (src) == HIGH)\n-    {\n-      mips_emit_high (dest, XEXP (src, 0));\n-      return;\n-    }\n+  rtx base;\n+  HOST_WIDE_INT offset;\n+  enum mips_symbol_type symbol_type;\n \n+  /* Split moves of big integers into smaller pieces.  In mips16 code,\n+     it's better to force the constant into memory instead.  */\n   if (GET_CODE (src) == CONST_INT && !TARGET_MIPS16)\n     {\n       mips_move_integer (dest, INTVAL (src));\n       return;\n     }\n \n-  /* Fetch global symbols from the GOT.  */\n-  if (TARGET_EXPLICIT_RELOCS\n-      && GET_CODE (src) == SYMBOL_REF\n-      && mips_classify_symbol (src) == SYMBOL_GOT_GLOBAL)\n+  /* See if the symbol can be split.  For mips16, this is often worse than\n+     forcing it in the constant pool since it needs the single-register form\n+     of addiu or daddiu.  */\n+  if (!TARGET_MIPS16\n+      && mips_symbolic_constant_p (src, &symbol_type)\n+      && mips_split_p[symbol_type])\n     {\n-      if (TARGET_XGOT)\n-\tsrc = mips_load_got32 (temp, src, RELOC_GOT_HI, RELOC_GOT_LO);\n-      else\n-\tsrc = mips_load_got16 (src, RELOC_GOT_DISP);\n-      emit_insn (gen_rtx_SET (VOIDmode, dest, src));\n+      emit_move_insn (dest, mips_split_symbol (dest, src));\n       return;\n     }\n \n-  /* Try handling the source operand as a symbolic address.  */\n-  if (mips_legitimize_symbol (temp, &src, false))\n+  /* If we have (const (plus symbol offset)), load the symbol first\n+     and then add in the offset.  This is usually better than forcing\n+     the constant into memory, at least in non-mips16 code.  */\n+  mips_split_const (src, &base, &offset);\n+  if (!TARGET_MIPS16\n+      && offset != 0\n+      && (!no_new_pseudos || SMALL_OPERAND (offset)))\n     {\n-      emit_insn (gen_rtx_SET (VOIDmode, dest, src));\n+      base = mips_force_temporary (dest, base);\n+      emit_move_insn (dest, mips_add_offset (base, offset));\n       return;\n     }\n \n   src = force_const_mem (mode, src);\n \n   /* When using explicit relocs, constant pool references are sometimes\n-     not legitimate addresses.  mips_legitimize_symbol must be able to\n-     deal with all such cases.  */\n-  if (GET_CODE (src) == MEM && !memory_operand (src, VOIDmode))\n-    {\n-      src = copy_rtx (src);\n-      if (!mips_legitimize_symbol (temp, &XEXP (src, 0), false))\n-\tabort ();\n-    }\n+     not legitimate addresses.  */\n+  if (!memory_operand (src, VOIDmode))\n+    src = replace_equiv_address (src, mips_split_symbol (dest, XEXP (src, 0)));\n   emit_move_insn (dest, src);\n }\n \n@@ -2011,30 +1952,6 @@ mips_legitimize_move (enum machine_mode mode, rtx dest, rtx src)\n     }\n   return false;\n }\n-\n-\n-/* Convert GOT and GP-relative accesses back into their original form.\n-   Used by both TARGET_DELEGITIMIZE_ADDRESS and FIND_BASE_TERM.  */\n-\n-rtx\n-mips_delegitimize_address (rtx x)\n-{\n-  struct mips_constant_info c;\n-\n-  if (GET_CODE (x) == MEM\n-      && GET_CODE (XEXP (x, 0)) == PLUS\n-      && mips_classify_constant (&c, XEXP (XEXP (x, 0), 1)) == CONSTANT_RELOC\n-      && mips_classify_symbol (c.symbol) == SYMBOL_GOT_GLOBAL)\n-    return c.symbol;\n-\n-  if (GET_CODE (x) == LO_SUM\n-      && XEXP (x, 0) == (TARGET_MIPS16\n-\t\t\t ? cfun->machine->mips16_gp_pseudo_rtx\n-\t\t\t : pic_offset_table_rtx))\n-    return XEXP (x, 1);\n-\n-  return x;\n-}\n \f\n /* We need a lot of little routines to check constant values on the\n    mips16.  These are used to figure out how long the instruction will\n@@ -2261,17 +2178,17 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n     case SYMBOL_REF:\n     case LABEL_REF:\n     case CONST_DOUBLE:\n-      if (((outer_code) == PLUS || (outer_code) == MINUS)\n-          && const_arith_operand (x, VOIDmode))\n-        {\n-          *total = 0;\n-          return true;\n-        }\n+      if (LEGITIMATE_CONSTANT_P (x))\n+\t{\n+\t  *total = COSTS_N_INSNS (1);\n+\t  return true;\n+\t}\n       else\n-        {\n-          int n = mips_const_insns (x);\n-          return (n == 0 ? CONSTANT_POOL_COST : COSTS_N_INSNS (n));\n-        }\n+\t{\n+\t  /* The value will need to be fetched from the constant pool.  */\n+\t  *total = CONSTANT_POOL_COST;\n+\t  return true;\n+\t}\n \n     case MEM:\n       {\n@@ -2558,7 +2475,7 @@ mips_subword (rtx op, int high_p)\n     }\n \n   if (GET_CODE (op) == MEM)\n-    return adjust_address (op, word_mode, byte);\n+    return mips_rewrite_small_data (adjust_address (op, word_mode, byte));\n \n   return simplify_gen_subreg (word_mode, op, mode, byte);\n }\n@@ -2648,7 +2565,6 @@ const char *\n mips_output_move (rtx dest, rtx src)\n {\n   enum rtx_code dest_code, src_code;\n-  struct mips_constant_info c;\n   bool dbl_p;\n \n   dest_code = GET_CODE (dest);\n@@ -2725,20 +2641,11 @@ mips_output_move (rtx dest, rtx src)\n       if (src_code == HIGH)\n \treturn \"lui\\t%0,%h1\";\n \n-      switch (mips_classify_constant (&c, src))\n-\t{\n-\tcase CONSTANT_NONE:\n-\t  break;\n-\n-\tcase CONSTANT_GP:\n-\t  return \"move\\t%0,%1\";\n-\n-\tcase CONSTANT_RELOC:\n-\t  return \"li\\t%0,%1\";\n+      if (CONST_GP_P (src))\n+\treturn \"move\\t%0,%1\";\n \n-\tcase CONSTANT_SYMBOLIC:\n-\t  return (dbl_p ? \"dla\\t%0,%a1\" : \"la\\t%0,%a1\");\n-\t}\n+      if (symbolic_operand (src, VOIDmode))\n+\treturn (dbl_p ? \"dla\\t%0,%1\" : \"la\\t%0,%1\");\n     }\n   if (src_code == REG && FP_REG_P (REGNO (src)))\n     {\n@@ -3277,16 +3184,11 @@ mips_expand_call (rtx result, rtx addr, rtx args_size, rtx aux, int sibcall_p)\n {\n   if (!call_insn_operand (addr, VOIDmode))\n     {\n-      /* When generating PIC, try to allow global functions to be\n-\t lazily bound.  */\n-      if (TARGET_EXPLICIT_RELOCS\n-\t  && GET_CODE (addr) == SYMBOL_REF\n-\t  && mips_classify_symbol (addr) == SYMBOL_GOT_GLOBAL)\n+      if (TARGET_EXPLICIT_RELOCS && global_got_operand (addr, VOIDmode))\n \t{\n-\t  if (TARGET_XGOT)\n-\t    addr = mips_load_got32 (0, addr, RELOC_CALL_HI, RELOC_CALL_LO);\n-\t  else\n-\t    addr = mips_load_got16 (addr, RELOC_CALL16);\n+\t  rtx high = mips_unspec_offset_high (pic_offset_table_rtx,\n+\t\t\t\t\t      addr, SYMBOL_GOTOFF_CALL);\n+\t  addr = mips_load_got (high, addr, SYMBOL_GOTOFF_CALL);\n \t}\n       addr = force_reg (Pmode, addr);\n     }\n@@ -5035,6 +4937,68 @@ override_options (void)\n \n   /* Create a unique alias set for GOT references.  */\n   mips_got_alias_set = new_alias_set ();\n+\n+  if (TARGET_EXPLICIT_RELOCS || mips_split_addresses)\n+    {\n+      mips_split_p[SYMBOL_GENERAL] = true;\n+      mips_hi_relocs[SYMBOL_GENERAL] = \"%hi(\";\n+      mips_lo_relocs[SYMBOL_GENERAL] = \"%lo(\";\n+    }\n+\n+  if (TARGET_MIPS16)\n+    {\n+      /* The high part is provided by a pseudo copy of $gp.  */\n+      mips_split_p[SYMBOL_SMALL_DATA] = true;\n+      mips_lo_relocs[SYMBOL_SMALL_DATA] = \"%gprel(\";\n+    }\n+\n+  if (TARGET_EXPLICIT_RELOCS)\n+    {\n+      /* Small data constants are kept whole until after reload,\n+\t then lowered by mips_rewrite_small_data.  */\n+      mips_lo_relocs[SYMBOL_SMALL_DATA] = \"%gp_rel(\";\n+\n+      mips_split_p[SYMBOL_GOT_LOCAL] = true;\n+      if (TARGET_NEWABI)\n+\t{\n+\t  mips_lo_relocs[SYMBOL_GOTOFF_PAGE] = \"%got_page(\";\n+\t  mips_lo_relocs[SYMBOL_GOT_LOCAL] = \"%got_ofst(\";\n+\t}\n+      else\n+\t{\n+\t  mips_lo_relocs[SYMBOL_GOTOFF_PAGE] = \"%got(\";\n+\t  mips_lo_relocs[SYMBOL_GOT_LOCAL] = \"%lo(\";\n+\t}\n+\n+      if (TARGET_XGOT)\n+\t{\n+\t  /* The HIGH and LO_SUM are matched by special .md patterns.  */\n+\t  mips_split_p[SYMBOL_GOT_GLOBAL] = true;\n+\n+\t  mips_split_p[SYMBOL_GOTOFF_GLOBAL] = true;\n+\t  mips_hi_relocs[SYMBOL_GOTOFF_GLOBAL] = \"%got_hi(\";\n+\t  mips_lo_relocs[SYMBOL_GOTOFF_GLOBAL] = \"%got_lo(\";\n+\n+\t  mips_split_p[SYMBOL_GOTOFF_CALL] = true;\n+\t  mips_hi_relocs[SYMBOL_GOTOFF_CALL] = \"%call_hi(\";\n+\t  mips_lo_relocs[SYMBOL_GOTOFF_CALL] = \"%call_lo(\";\n+\t}\n+      else\n+\t{\n+\t  if (TARGET_NEWABI)\n+\t    mips_lo_relocs[SYMBOL_GOTOFF_GLOBAL] = \"%got_disp(\";\n+\t  else\n+\t    mips_lo_relocs[SYMBOL_GOTOFF_GLOBAL] = \"%got(\";\n+\t  mips_lo_relocs[SYMBOL_GOTOFF_CALL] = \"%call16(\";\n+\t}\n+    }\n+\n+  if (TARGET_NEWABI)\n+    {\n+      mips_split_p[SYMBOL_GOTOFF_LOADGP] = true;\n+      mips_hi_relocs[SYMBOL_GOTOFF_LOADGP] = \"%hi(%neg(%gp_rel(\";\n+      mips_lo_relocs[SYMBOL_GOTOFF_LOADGP] = \"%lo(%neg(%gp_rel(\";\n+    }\n }\n \n /* Implement CONDITIONAL_REGISTER_USAGE.  */\n@@ -5215,8 +5179,6 @@ void\n print_operand (FILE *file, rtx op, int letter)\n {\n   register enum rtx_code code;\n-  struct mips_constant_info c;\n-  const char *reloc;\n \n   if (PRINT_OPERAND_PUNCT_VALID_P (letter))\n     {\n@@ -5357,16 +5319,7 @@ print_operand (FILE *file, rtx op, int letter)\n \n   code = GET_CODE (op);\n \n-  if (letter == 'h')\n-    {\n-      if (GET_CODE (op) != HIGH)\n-\tabort ();\n-      fputs (\"%hi(\", file);\n-      output_addr_const (file, XEXP (op, 0));\n-      fputc (')', file);\n-    }\n-\n-  else if (letter == 'C')\n+  if (letter == 'C')\n     switch (code)\n       {\n       case EQ:\tfputs (\"eq\",  file); break;\n@@ -5418,6 +5371,17 @@ print_operand (FILE *file, rtx op, int letter)\n \tfatal_insn (\"PRINT_OPERAND, invalid insn for %%W\", op);\n       }\n \n+  else if (letter == 'h')\n+    {\n+      if (GET_CODE (op) == HIGH)\n+\top = XEXP (op, 0);\n+\n+      print_operand_reloc (file, op, mips_hi_relocs);\n+    }\n+\n+  else if (letter == 'R')\n+    print_operand_reloc (file, op, mips_lo_relocs);\n+\n   else if (letter == 'S')\n     {\n       char buffer[100];\n@@ -5490,89 +5454,65 @@ print_operand (FILE *file, rtx op, int letter)\n   else if (letter == 't')\n     fputs (code == EQ ? \"t\" : \"f\", file);\n \n-  else\n-    switch (mips_classify_constant (&c, op))\n-      {\n-      case CONSTANT_SYMBOLIC:\n-\tif (letter == 'R')\n-\t  {\n-\t    if (mips_classify_symbol (c.symbol) == SYMBOL_SMALL_DATA)\n-\t      fputs (TARGET_MIPS16 ? \"%gprel(\" : \"%gp_rel(\", file);\n-\t    else if (TARGET_ABICALLS && TARGET_NEWABI)\n-\t      fputs (\"%got_ofst(\", file);\n-\t    else\n-\t      fputs (\"%lo(\", file);\n-\t    output_addr_const (file, op);\n-\t    fputc (')', file);\n-\t    break;\n-\t  }\n-\t/* ... fall through ... */\n+  else if (CONST_GP_P (op))\n+    print_operand (file, XEXP (op, 0), letter);\n \n-      case CONSTANT_NONE:\n-\toutput_addr_const (file, op);\n-\tbreak;\n+  else\n+    output_addr_const (file, op);\n+}\n \n-      case CONSTANT_GP:\n-\tfputs (reg_names[PIC_OFFSET_TABLE_REGNUM], file);\n-\tbreak;\n \n-      case CONSTANT_RELOC:\n-\treloc = mips_reloc_string (c.reloc);\n-\tfputs (reloc, file);\n-\toutput_addr_const (file, plus_constant (c.symbol, c.offset));\n-\twhile (*reloc != 0)\n-\t  if (*reloc++ == '(')\n-\t    fputc (')', file);\n-      }\n-}\n-\f\n-/* Return the assembly operator used for the given type of relocation.  */\n+/* Print symbolic operand OP, which is part of a HIGH or LO_SUM.\n+   RELOCS is the array of relocations to use.  */\n \n-static const char *\n-mips_reloc_string (int reloc)\n+static void\n+print_operand_reloc (FILE *file, rtx op, const char **relocs)\n {\n-  switch (reloc)\n-    {\n-    case RELOC_GOT_HI:\t  return \"%got_hi(\";\n-    case RELOC_GOT_LO:\t  return \"%got_lo(\";\n-    case RELOC_GOT_PAGE:  return (TARGET_NEWABI ? \"%got_page(\" : \"%got(\");\n-    case RELOC_GOT_DISP:  return (TARGET_NEWABI ? \"%got_disp(\" : \"%got(\");\n-    case RELOC_CALL16:\t  return \"%call16(\";\n-    case RELOC_CALL_HI:\t  return \"%call_hi(\";\n-    case RELOC_CALL_LO:\t  return \"%call_lo(\";\n-    case RELOC_LOADGP_HI: return \"%hi(%neg(%gp_rel(\";\n-    case RELOC_LOADGP_LO: return \"%lo(%neg(%gp_rel(\";\n-    }\n-  abort ();\n-}\n+  enum mips_symbol_type symbol_type;\n+  const char *p;\n+  rtx base;\n+  HOST_WIDE_INT offset;\n+\n+  if (!mips_symbolic_constant_p (op, &symbol_type) || relocs[symbol_type] == 0)\n+    fatal_insn (\"PRINT_OPERAND, invalid operand for relocation\", op);\n \n+  /* If OP uses an UNSPEC address, we want to print the inner symbol.  */\n+  mips_split_const (op, &base, &offset);\n+  if (UNSPEC_ADDRESS_P (base))\n+    op = plus_constant (UNSPEC_ADDRESS (base), offset);\n+\n+  fputs (relocs[symbol_type], file);\n+  output_addr_const (file, op);\n+  for (p = relocs[symbol_type]; *p != 0; p++)\n+    if (*p == '(')\n+      fputc (')', file);\n+}\n+\f\n /* Output address operand X to FILE.   */\n \n void\n print_operand_address (FILE *file, rtx x)\n {\n   struct mips_address_info addr;\n \n-  switch (mips_classify_address (&addr, x, word_mode, 1, 1))\n-    {\n-    case ADDRESS_INVALID:\n-      abort ();\n-\n-    case ADDRESS_REG:\n-      print_operand (file, addr.offset, 0);\n-      fprintf (file, \"(%s)\", reg_names[REGNO (addr.reg)]);\n-      return;\n+  if (mips_classify_address (&addr, x, word_mode, true))\n+    switch (addr.type)\n+      {\n+      case ADDRESS_REG:\n+\tprint_operand (file, addr.offset, 0);\n+\tfprintf (file, \"(%s)\", reg_names[REGNO (addr.reg)]);\n+\treturn;\n \n-    case ADDRESS_LO_SUM:\n-      print_operand (file, addr.offset, 'R');\n-      fprintf (file, \"(%s)\", reg_names[REGNO (addr.reg)]);\n-      return;\n+      case ADDRESS_LO_SUM:\n+\tprint_operand (file, addr.offset, 'R');\n+\tfprintf (file, \"(%s)\", reg_names[REGNO (addr.reg)]);\n+\treturn;\n \n-    case ADDRESS_CONST_INT:\n-    case ADDRESS_SYMBOLIC:\n-      output_addr_const (file, x);\n-      return;\n-    }\n+      case ADDRESS_CONST_INT:\n+      case ADDRESS_SYMBOLIC:\n+\toutput_addr_const (file, x);\n+\treturn;\n+      }\n   abort ();\n }\n \f\n@@ -5994,6 +5934,93 @@ mips_finish_declare_object (FILE *stream, tree decl, int top_level, int at_end)\n }\n #endif\n \f\n+/* Return true if X is a small data address that can be rewritten\n+   as a LO_SUM.  */\n+\n+static bool\n+mips_rewrite_small_data_p (rtx x)\n+{\n+  enum mips_symbol_type symbol_type;\n+\n+  return (TARGET_EXPLICIT_RELOCS\n+\t  && mips_symbolic_constant_p (x, &symbol_type)\n+\t  && symbol_type == SYMBOL_SMALL_DATA);\n+}\n+\n+\n+/* A for_each_rtx callback for small_data_pattern.  */\n+\n+static int\n+small_data_pattern_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n+{\n+  if (GET_CODE (*loc) == LO_SUM)\n+    return -1;\n+\n+  return mips_rewrite_small_data_p (*loc);\n+}\n+\n+/* Return true if OP refers to small data symbols directly, not through\n+   a LO_SUM.  */\n+\n+int\n+small_data_pattern (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return (GET_CODE (op) != SEQUENCE\n+\t  && for_each_rtx (&op, small_data_pattern_1, 0));\n+}\n+\f\n+/* A for_each_rtx callback, used by mips_rewrite_small_data.  */\n+\n+static int\n+mips_rewrite_small_data_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n+{\n+  if (mips_rewrite_small_data_p (*loc))\n+    *loc = gen_rtx_LO_SUM (Pmode, pic_offset_table_rtx, *loc);\n+\n+  if (GET_CODE (*loc) == LO_SUM)\n+    return -1;\n+\n+  return 0;\n+}\n+\n+/* If possible, rewrite OP so that it refers to small data using\n+   explicit relocations.  */\n+\n+rtx\n+mips_rewrite_small_data (rtx op)\n+{\n+  op = copy_insn (op);\n+  for_each_rtx (&op, mips_rewrite_small_data_1, 0);\n+  return op;\n+}\n+\f\n+/* Return true if the current function has an insn that implicitly\n+   refers to $gp.  */\n+\n+static bool\n+mips_function_has_gp_insn (void)\n+{\n+  /* Don't bother rechecking if we found one last time.  */\n+  if (!cfun->machine->has_gp_insn_p)\n+    {\n+      rtx insn;\n+\n+      push_topmost_sequence ();\n+      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+\tif (INSN_P (insn)\n+\t    && GET_CODE (PATTERN (insn)) != USE\n+\t    && GET_CODE (PATTERN (insn)) != CLOBBER\n+\t    && (get_attr_got (insn) != GOT_UNSET\n+\t\t|| small_data_pattern (PATTERN (insn), VOIDmode)))\n+\t  break;\n+      pop_topmost_sequence ();\n+\n+      cfun->machine->has_gp_insn_p = (insn != 0);\n+    }\n+  return cfun->machine->has_gp_insn_p;\n+}\n+\n+\n /* Return the register that should be used as the global pointer\n    within this function.  Return 0 if the function doesn't need\n    a global pointer.  */\n@@ -6030,7 +6057,8 @@ mips_global_pointer (void)\n      In cases like these, reload will have added the constant to the pool\n      but no instruction will yet refer to it.  */\n   if (!regs_ever_live[GLOBAL_POINTER_REGNUM]\n-      && !current_function_uses_const_pool)\n+      && !current_function_uses_const_pool\n+      && !mips_function_has_gp_insn ())\n     return 0;\n \n   /* We need a global pointer, but perhaps we can use a call-clobbered\n@@ -6530,26 +6558,6 @@ mips_save_reg (rtx reg, rtx mem)\n }\n \n \n-/* Emit an instruction to move SRC into DEST.  When generating\n-   explicit reloc code, mark the instruction as potentially dead.  */\n-\n-static void\n-mips_gp_insn (rtx dest, rtx src)\n-{\n-  rtx insn;\n-\n-  insn = emit_insn (gen_rtx_SET (VOIDmode, dest, src));\n-  if (TARGET_EXPLICIT_RELOCS)\n-    {\n-      /* compute_frame_size assumes that any function which uses the\n-\t constant pool will need a gp.  However, all constant\n-\t pool references could be eliminated, in which case\n-\t it is OK for flow to delete the gp load as well.  */\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx,\n-\t\t\t\t\t    REG_NOTES (insn));\n-    }\n-}\n-\n /* Expand the prologue into a bunch of separate insns.  */\n \n void\n@@ -6640,19 +6648,11 @@ mips_expand_prologue (void)\n   /* If generating n32/n64 abicalls, emit the instructions to load $gp.  */\n   if (TARGET_ABICALLS && TARGET_NEWABI && cfun->machine->global_pointer > 0)\n     {\n-      rtx fnsymbol, fnaddr;\n-\n-      fnsymbol = XEXP (DECL_RTL (current_function_decl), 0);\n-      fnaddr = gen_rtx_REG (Pmode, PIC_FUNCTION_ADDR_REGNUM);\n-\n-      mips_gp_insn (MIPS_PROLOGUE_TEMP (Pmode),\n-\t\t    mips_lui_reloc (fnsymbol, RELOC_LOADGP_HI));\n-      mips_gp_insn (MIPS_PROLOGUE_TEMP (Pmode),\n-\t\t    gen_rtx_PLUS (Pmode, MIPS_PROLOGUE_TEMP (Pmode), fnaddr));\n-      mips_gp_insn (pic_offset_table_rtx,\n-\t\t    gen_rtx_PLUS (Pmode, MIPS_PROLOGUE_TEMP (Pmode),\n-\t\t\t\t  mips_reloc (fnsymbol, RELOC_LOADGP_LO)));\n+      rtx addr, offset;\n \n+      addr = XEXP (DECL_RTL (current_function_decl), 0);\n+      offset = mips_unspec_address (addr, SYMBOL_GOTOFF_LOADGP);\n+      emit_insn (gen_loadgp (offset));\n       if (!TARGET_EXPLICIT_RELOCS)\n \temit_insn (gen_loadgp_blockage ());\n     }\n@@ -7433,14 +7433,8 @@ mips_valid_pointer_mode (enum machine_mode mode)\n    hold the $gp value.  */\n \n static rtx\n-mips_sdata_pointer (void)\n+mips16_gp_pseudo_reg (void)\n {\n-  if (TARGET_EXPLICIT_RELOCS)\n-    return pic_offset_table_rtx;\n-\n-  if (!TARGET_MIPS16 || no_new_pseudos)\n-    return 0;\n-\n   if (cfun->machine->mips16_gp_pseudo_rtx == NULL_RTX)\n     {\n       rtx const_gp;"}, {"sha": "d03e6d1fab23892e58ffb97ebfc4ab26c43d0c00", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108b61d54adb806d5f40bdfab297ae749401dd7f/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108b61d54adb806d5f40bdfab297ae749401dd7f/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=108b61d54adb806d5f40bdfab297ae749401dd7f", "patch": "@@ -1244,8 +1244,6 @@ extern const struct mips_cpu_info *mips_tune_info;\n    SFmode register saves.  */\n #define DWARF_CIE_DATA_ALIGNMENT 4\n \n-#define FIND_BASE_TERM(X) mips_delegitimize_address (X)\n-\n /* Correct the offset of automatic variables and arguments.  Note that\n    the MIPS debug format wants all automatic variables and arguments\n    to be in terms of the virtual frame pointer (stack pointer before\n@@ -2028,9 +2026,7 @@ extern enum reg_class mips_char_to_class[256];\n    part of a call sequence and allow a global 'foo' to be lazily bound.  */\n \n #define DANGEROUS_FOR_LA25_P(OP)\t\t\t\t\t\\\n-  (TARGET_ABICALLS\t\t\t\t\t\t\t\\\n-   && !TARGET_EXPLICIT_RELOCS\t\t\t\t\t\t\\\n-   && mips_global_pic_constant_p (OP))\n+  (!TARGET_EXPLICIT_RELOCS && global_got_operand (OP, VOIDmode))\n \n /* Letters in the range `Q' through `U' may be defined in a\n    machine-dependent fashion to stand for arbitrary operand types.\n@@ -2798,7 +2794,11 @@ typedef struct mips_args {\n #define PREDICATE_CODES\t\t\t\t\t\t\t\\\n   {\"uns_arith_operand\",\t\t{ REG, CONST_INT, SUBREG, ADDRESSOF }},\t\\\n   {\"symbolic_operand\",\t\t{ CONST, SYMBOL_REF, LABEL_REF }},\t\\\n-  {\"const_arith_operand\",\t{ CONST, CONST_INT }},\t\t\t\\\n+  {\"global_got_operand\",\t{ CONST, SYMBOL_REF, LABEL_REF }},\t\\\n+  {\"local_got_operand\",\t\t{ CONST, SYMBOL_REF, LABEL_REF }},\t\\\n+  {\"const_arith_operand\",\t{ CONST_INT }},\t\t\t\t\\\n+  {\"small_data_pattern\",\t{ SET, PARALLEL, UNSPEC,\t\t\\\n+\t\t\t\t  UNSPEC_VOLATILE }},\t\t\t\\\n   {\"arith_operand\",\t\t{ REG, CONST_INT, CONST, SUBREG, ADDRESSOF }},\t\\\n   {\"reg_or_0_operand\",\t\t{ REG, CONST_INT, CONST_DOUBLE, SUBREG, ADDRESSOF }}, \\\n   {\"small_int\",\t\t\t{ CONST_INT }},\t\t\t\t\\"}, {"sha": "ebe4beb80d84a4eb6eae98a5a6a996c7100a60dd", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 130, "deletions": 32, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108b61d54adb806d5f40bdfab297ae749401dd7f/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108b61d54adb806d5f40bdfab297ae749401dd7f/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=108b61d54adb806d5f40bdfab297ae749401dd7f", "patch": "@@ -53,27 +53,19 @@\n    (UNSPEC_LDR\t\t\t23)\n    (UNSPEC_SDL\t\t\t24)\n    (UNSPEC_SDR\t\t\t25)\n+   (UNSPEC_LOADGP\t\t26)\n \n-   ;; Constants used in relocation unspecs.  RELOC_GOT_PAGE and RELOC_GOT_DISP\n-   ;; are really only available for n32 and n64.  However, it is convenient\n-   ;; to reuse them for SVR4 PIC, where they represent the local and global\n-   ;; forms of R_MIPS_GOT16.\n-   (RELOC_GOT_HI\t\t100)\n-   (RELOC_GOT_LO\t\t101)\n-   (RELOC_GOT_PAGE\t\t102)\n-   (RELOC_GOT_DISP\t\t103)\n-   (RELOC_CALL16\t\t104)\n-   (RELOC_CALL_HI\t\t105)\n-   (RELOC_CALL_LO\t\t106)\n-   (RELOC_LOADGP_HI\t\t107)\n-   (RELOC_LOADGP_LO\t\t108)])\n+   (UNSPEC_ADDRESS_FIRST\t100)])\n \f\n ;; ....................\n ;;\n ;;\tAttributes\n ;;\n ;; ....................\n \n+(define_attr \"got\" \"unset,xgot_high,load\"\n+  (const_string \"unset\"))\n+\n ;; For jal instructions, this attribute is DIRECT when the target address\n ;; is symbolic and INDIRECT when it is a register.\n (define_attr \"jal\" \"unset,direct,indirect\"\n@@ -125,8 +117,8 @@\n ;; nop\t\tno operation\n (define_attr \"type\"\n   \"unknown,branch,jump,call,load,store,prefetch,prefetchx,move,condmove,xfer,hilo,const,arith,darith,imul,imadd,idiv,icmp,fadd,fmul,fmadd,fdiv,fabs,fneg,fcmp,fcvt,fsqrt,frsqrt,multi,nop\"\n-  (cond [(eq_attr \"jal\" \"!unset\")\n-\t (const_string \"call\")]\n+  (cond [(eq_attr \"jal\" \"!unset\") (const_string \"call\")\n+\t (eq_attr \"got\" \"load\") (const_string \"load\")]\n \t(const_string \"unknown\")))\n \n ;; Main data type used by the insn\n@@ -179,6 +171,11 @@\n \t\t (const_int 24)\n \t\t ] (const_int 12))\n \n+\t  (eq_attr \"got\" \"load\")\n+\t  (const_int 4)\n+\t  (eq_attr \"got\" \"xgot_high\")\n+\t  (const_int 8)\n+\n \t  (eq_attr \"type\" \"const\")\n \t  (symbol_ref \"mips_const_insns (operands[1]) * 4\")\n \t  (eq_attr \"type\" \"load\")\n@@ -4147,40 +4144,118 @@ dsrl\\t%3,%3,1\\n\\\n   [(set_attr \"type\" \"store\")\n    (set_attr \"mode\" \"DI\")])\n \n+;; Insns to fetch a global symbol from a big GOT.\n \n-;; Instructions for loading a relocation expression using \"lui\".\n+(define_insn_and_split \"*xgot_hisi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(high:SI (match_operand:SI 1 \"global_got_operand\" \"\")))]\n+  \"TARGET_EXPLICIT_RELOCS && TARGET_XGOT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (high:SI (match_dup 2)))\n+   (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 3)))]\n+{\n+  operands[2] = mips_gotoff_global (operands[1]);\n+  operands[3] = pic_offset_table_rtx;\n+}\n+  [(set_attr \"got\" \"xgot_high\")])\n \n-(define_insn \"luisi\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(unspec:SI [(match_operand 1 \"const_arith_operand\" \"\")] UNSPEC_HIGH))]\n-  \"\"\n-  \"lui\\t%0,%1\"\n-  [(set_attr \"type\" \"arith\")])\n+(define_insn_and_split \"*xgot_losi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t   (match_operand:SI 2 \"global_got_operand\" \"\")))]\n+  \"TARGET_EXPLICIT_RELOCS && TARGET_XGOT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (match_dup 3))]\n+  { operands[3] = mips_load_got_global (operands[1], operands[2]); }\n+  [(set_attr \"got\" \"load\")])\n \n-(define_insn \"luidi\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(unspec:DI [(match_operand 1 \"const_arith_operand\" \"\")] UNSPEC_HIGH))]\n-  \"TARGET_64BIT\"\n-  \"lui\\t%0,%1\"\n-  [(set_attr \"type\" \"arith\")])\n+(define_insn_and_split \"*xgot_hidi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(high:DI (match_operand:DI 1 \"global_got_operand\" \"\")))]\n+  \"TARGET_EXPLICIT_RELOCS && TARGET_XGOT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (high:DI (match_dup 2)))\n+   (set (match_dup 0) (plus:DI (match_dup 0) (match_dup 3)))]\n+{\n+  operands[2] = mips_gotoff_global (operands[1]);\n+  operands[3] = pic_offset_table_rtx;\n+}\n+  [(set_attr \"got\" \"xgot_high\")])\n+\n+(define_insn_and_split \"*xgot_lodi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(lo_sum:DI (match_operand:DI 1 \"register_operand\" \"d\")\n+\t\t   (match_operand:DI 2 \"global_got_operand\" \"\")))]\n+  \"TARGET_EXPLICIT_RELOCS && TARGET_XGOT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (match_dup 3))]\n+  { operands[3] = mips_load_got_global (operands[1], operands[2]); }\n+  [(set_attr \"got\" \"load\")])\n \n+;; Insns to fetch a global symbol from a normal GOT.\n+\n+(define_insn_and_split \"*got_dispsi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(match_operand:SI 1 \"global_got_operand\" \"\"))]\n+  \"TARGET_EXPLICIT_RELOCS && !TARGET_XGOT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (match_dup 2))]\n+  { operands[2] = mips_load_got_global (pic_offset_table_rtx, operands[1]); }\n+  [(set_attr \"got\" \"load\")])\n+\n+(define_insn_and_split \"*got_dispdi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(match_operand:DI 1 \"global_got_operand\" \"\"))]\n+  \"TARGET_EXPLICIT_RELOCS && !TARGET_XGOT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (match_dup 2))]\n+  { operands[2] = mips_load_got_global (pic_offset_table_rtx, operands[1]); }\n+  [(set_attr \"got\" \"load\")])\n+\n+;; Insns for loading the high part of a local symbol.\n+\n+(define_insn_and_split \"*got_pagesi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(high:SI (match_operand:SI 1 \"local_got_operand\" \"\")))]\n+  \"TARGET_EXPLICIT_RELOCS\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (match_dup 2))]\n+  { operands[2] = mips_load_got_page (operands[1]); }\n+  [(set_attr \"got\" \"load\")])\n+\n+(define_insn_and_split \"*got_pagedi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(high:DI (match_operand:DI 1 \"local_got_operand\" \"\")))]\n+  \"TARGET_EXPLICIT_RELOCS\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (match_dup 2))]\n+  { operands[2] = mips_load_got_page (operands[1]); }\n+  [(set_attr \"got\" \"load\")])\n \n ;; Instructions for adding the low 16 bits of an address to a register.\n ;; Operand 2 is the address: print_operand works out which relocation\n ;; should be applied.\n \n (define_insn \"*lowsi\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t   (match_operand:SI 2 \"immediate_operand\" \"\")))]\n   \"!TARGET_MIPS16\"\n   \"addiu\\t%0,%1,%R2\"\n   [(set_attr \"type\"\t\"arith\")\n    (set_attr \"mode\"\t\"SI\")])\n \n (define_insn \"*lowdi\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(lo_sum:DI (match_operand:DI 1 \"register_operand\" \"d\")\n \t\t   (match_operand:DI 2 \"immediate_operand\" \"\")))]\n   \"!TARGET_MIPS16 && TARGET_64BIT\"\n   \"daddiu\\t%0,%1,%R2\"\n@@ -5048,6 +5123,23 @@ dsrl\\t%3,%3,1\\n\\\n    (set_attr \"mode\"\t\"SF\")\n    (set_attr \"length\"\t\"4\")])\n \n+(define_insn_and_split \"loadgp\"\n+  [(unspec_volatile [(match_operand 0 \"\" \"\")] UNSPEC_LOADGP)]\n+  \"TARGET_ABICALLS && TARGET_NEWABI\"\n+  \"#\"\n+  \"\"\n+  [(set (match_dup 1) (match_dup 2))\n+   (set (match_dup 1) (match_dup 3))\n+   (set (match_dup 1) (match_dup 4))]\n+{\n+  operands[1] = pic_offset_table_rtx;\n+  operands[2] = gen_rtx_HIGH (Pmode, operands[0]);\n+  operands[3] = gen_rtx_PLUS (Pmode, operands[1],\n+\t\t\t      gen_rtx_REG (Pmode, PIC_FUNCTION_ADDR_REGNUM));\n+  operands[4] = gen_rtx_LO_SUM (Pmode, operands[1], operands[0]);\n+}\n+  [(set_attr \"length\" \"12\")])\n+\n ;; The use of gp is hidden when not using explicit relocations.\n ;; This blockage instruction prevents the gp load from being\n ;; scheduled after an implicit use of gp.  It also prevents\n@@ -9038,3 +9130,9 @@ ld\\t%2,%1-%S1(%2)\\;daddu\\t%2,%2,$31\\;%*j\\t%2%/\"\n   [(set_attr \"type\"\t\"branch\")\n    (set_attr \"mode\"\t\"none\")\n    (set_attr \"length\"\t\"8\")])\n+\n+(define_split\n+  [(match_operand 0 \"small_data_pattern\" \"\")]\n+  \"reload_completed\"\n+  [(match_dup 0)]\n+  { operands[0] = mips_rewrite_small_data (operands[0]); })"}]}