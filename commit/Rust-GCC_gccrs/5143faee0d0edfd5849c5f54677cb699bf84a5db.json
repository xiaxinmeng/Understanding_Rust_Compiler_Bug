{"sha": "5143faee0d0edfd5849c5f54677cb699bf84a5db", "node_id": "C_kwDOANBUbNoAKDUxNDNmYWVlMGQwZWRmZDU4NDljNWY1NDY3N2NiNjk5YmY4NGE1ZGI", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@arm.com", "date": "2022-05-05T08:25:14Z"}, "committer": {"name": "Christophe Lyon", "email": "christophe.lyon@arm.com", "date": "2022-05-20T07:36:08Z"}, "message": "libgcc: use __builtin_clz and __builtin_ctz in libbid\n\nThis patch replaces libbid's implementations of clz and ctz for 32 and\n64 bits inputs which used several masks, and switches to the\ncorresponding builtins. This will provide a better implementation,\nespecially on targets with clz/ctz instructions.\n\n2022-05-06  Christophe Lyon  <christophe.lyon@arm.com>\n\nlibgcc/config/libbid/ChangeLog:\n\n\t* bid_binarydecimal.c (CLZ32_MASK16): Delete.\n\t(CLZ32_MASK8): Delete.\n\t(CLZ32_MASK4): Delete.\n\t(CLZ32_MASK2): Delete.\n\t(CLZ32_MASK1): Delete.\n\t(clz32_nz): Use __builtin_clz.\n\t(ctz32_1bit): Delete.\n\t(ctz32): Use __builtin_ctz.\n\t(CLZ64_MASK32): Delete.\n\t(CLZ64_MASK16): Delete.\n\t(CLZ64_MASK8): Delete.\n\t(CLZ64_MASK4): Delete.\n\t(CLZ64_MASK2): Delete.\n\t(CLZ64_MASK1): Delete.\n\t(clz64_nz): Use __builtin_clzl.\n\t(ctz64_1bit): Delete.\n\t(ctz64): Use __builtin_ctzl.", "tree": {"sha": "0e7320dd418f7453706f304bc137eff57ff7eb50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e7320dd418f7453706f304bc137eff57ff7eb50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5143faee0d0edfd5849c5f54677cb699bf84a5db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5143faee0d0edfd5849c5f54677cb699bf84a5db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5143faee0d0edfd5849c5f54677cb699bf84a5db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5143faee0d0edfd5849c5f54677cb699bf84a5db/comments", "author": null, "committer": null, "parents": [{"sha": "308a0af4f913243023ee52332f7cc513745c9203", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/308a0af4f913243023ee52332f7cc513745c9203", "html_url": "https://github.com/Rust-GCC/gccrs/commit/308a0af4f913243023ee52332f7cc513745c9203"}], "stats": {"total": 51, "additions": 4, "deletions": 47}, "files": [{"sha": "5413acceeaf6c9f51cb925102f283477feee90a8", "filename": "libgcc/config/libbid/bid_binarydecimal.c", "status": "modified", "additions": 4, "deletions": 47, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5143faee0d0edfd5849c5f54677cb699bf84a5db/libgcc%2Fconfig%2Flibbid%2Fbid_binarydecimal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5143faee0d0edfd5849c5f54677cb699bf84a5db/libgcc%2Fconfig%2Flibbid%2Fbid_binarydecimal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_binarydecimal.c?ref=5143faee0d0edfd5849c5f54677cb699bf84a5db", "patch": "@@ -26,65 +26,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n // Counting leading zeros in an unsigned 32-bit word\n // The \"_nz\" version will return the wrong answer (31) for zero inputs\n \n-#define CLZ32_MASK16 0xFFFF0000ul\n-#define CLZ32_MASK8  0xFF00FF00ul\n-#define CLZ32_MASK4  0xF0F0F0F0ul\n-#define CLZ32_MASK2  0xCCCCCCCCul\n-#define CLZ32_MASK1  0xAAAAAAAAul\n-\n-#define clz32_nz(n)                                             \\\n- (((((n) & CLZ32_MASK16) <= ((n) & ~CLZ32_MASK16)) ? 16 : 0) +  \\\n-  ((((n) & CLZ32_MASK8) <= ((n) & ~CLZ32_MASK8)) ? 8 : 0) +     \\\n-  ((((n) & CLZ32_MASK4) <= ((n) & ~CLZ32_MASK4)) ? 4 : 0) +     \\\n-  ((((n) & CLZ32_MASK2) <= ((n) & ~CLZ32_MASK2)) ? 2 : 0) +     \\\n-  ((((n) & CLZ32_MASK1) <= ((n) & ~CLZ32_MASK1)) ? 1 : 0))\n-\n+#define clz32_nz(n) (__builtin_clz (n))\n #define clz32(n) (((n)==0) ? 32 : clz32_nz(n))\n \n // Counting trailing zeros in an unsigned 32-bit word\n-// The ctz32_1bit version is for a single bit\n-\n-#define ctz32_1bit(n)                                           \\\n- ((((n) & ~CLZ32_MASK16) ? 0 : 16) +                            \\\n-  (((n) & ~CLZ32_MASK8) ? 0 : 8) +                              \\\n-  (((n) & ~CLZ32_MASK4) ? 0 : 4) +                              \\\n-  (((n) & ~CLZ32_MASK2) ? 0 : 2) +                              \\\n-  (((n) & ~CLZ32_MASK1) ? 0 : 1))\n+#define ctz32(n) (__builtin_ctz (n))\n \n-#define ctz32(n) (((n) == 0) ? 32 : ctz32_1bit((n) & -(n)))\n \n // Counting leading zeros in an unsigned 64-bit word\n // The \"_nz\" version will return the wrong answer (63) for zero inputs\n \n-#define CLZ64_MASK32 0xFFFFFFFF00000000ull\n-#define CLZ64_MASK16 0xFFFF0000FFFF0000ull\n-#define CLZ64_MASK8  0xFF00FF00FF00FF00ull\n-#define CLZ64_MASK4  0xF0F0F0F0F0F0F0F0ull\n-#define CLZ64_MASK2  0xCCCCCCCCCCCCCCCCull\n-#define CLZ64_MASK1  0xAAAAAAAAAAAAAAAAull\n-\n-#define clz64_nz(n)                                             \\\n- (((((n) & CLZ64_MASK32) <= ((n) & ~CLZ64_MASK32)) ? 32 : 0) +  \\\n-  ((((n) & CLZ64_MASK16) <= ((n) & ~CLZ64_MASK16)) ? 16 : 0) +  \\\n-  ((((n) & CLZ64_MASK8) <= ((n) & ~CLZ64_MASK8)) ? 8 : 0) +     \\\n-  ((((n) & CLZ64_MASK4) <= ((n) & ~CLZ64_MASK4)) ? 4 : 0) +     \\\n-  ((((n) & CLZ64_MASK2) <= ((n) & ~CLZ64_MASK2)) ? 2 : 0) +     \\\n-  ((((n) & CLZ64_MASK1) <= ((n) & ~CLZ64_MASK1)) ? 1 : 0))      \\\n-\n+#define clz64_nz(n) ( (__SIZEOF_LONG__ == 8) ?__builtin_clzl(n) : __builtin_clzll(n) )\n #define clz64(n) (((n)==0) ? 64 : clz64_nz(n))\n \n // Counting trailing zeros in an unsigned 64-bit word\n-// The ctz64_1bit version is for a single bit\n-\n-#define ctz64_1bit(n)                                           \\\n- ((((n) & ~CLZ64_MASK32) ? 0 : 32) +                            \\\n-  (((n) & ~CLZ64_MASK16) ? 0 : 16) +                            \\\n-  (((n) & ~CLZ64_MASK8) ? 0 : 8) +                              \\\n-  (((n) & ~CLZ64_MASK4) ? 0 : 4) +                              \\\n-  (((n) & ~CLZ64_MASK2) ? 0 : 2) +                              \\\n-  (((n) & ~CLZ64_MASK1) ? 0 : 1))\n+#define ctz64(n) ( (__SIZEOF_LONG__ == 8) ?__builtin_ctzl(n) : __builtin_ctzll(n) )\n \n-#define ctz64(n) (((n) == 0) ? 64 : ctz64_1bit((n) & -(n)))\n \n // Counting leading zeros in an unsigned 2-part 128-bit word\n "}]}