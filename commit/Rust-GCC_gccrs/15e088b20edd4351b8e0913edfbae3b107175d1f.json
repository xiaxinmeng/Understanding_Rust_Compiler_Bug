{"sha": "15e088b20edd4351b8e0913edfbae3b107175d1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVlMDg4YjIwZWRkNDM1MWI4ZTA5MTNlZGZiYWUzYjEwNzE3NWQxZg==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-01-20T02:02:20Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-01-20T02:02:20Z"}, "message": "flow.c (invalidate_from_autoinc): New function.\n\n        * flow.c (invalidate_from_autoinc): New function.\n        (mark_set_1, mark_used_regs): Use it.\n\nFrom-SVN: r24781", "tree": {"sha": "238318861fb0a59405140b5f2132eb1f53a25c21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/238318861fb0a59405140b5f2132eb1f53a25c21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15e088b20edd4351b8e0913edfbae3b107175d1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e088b20edd4351b8e0913edfbae3b107175d1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15e088b20edd4351b8e0913edfbae3b107175d1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e088b20edd4351b8e0913edfbae3b107175d1f/comments", "author": null, "committer": null, "parents": [{"sha": "42e04d6bdc804c9f9be60e6367b6cb556868019f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42e04d6bdc804c9f9be60e6367b6cb556868019f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42e04d6bdc804c9f9be60e6367b6cb556868019f"}], "stats": {"total": 51, "additions": 50, "deletions": 1}, "files": [{"sha": "6326ec07598d1683ec8e99aedf7485328e1e17c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e088b20edd4351b8e0913edfbae3b107175d1f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e088b20edd4351b8e0913edfbae3b107175d1f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15e088b20edd4351b8e0913edfbae3b107175d1f", "patch": "@@ -30,6 +30,9 @@ Tue Jan 19 16:37:36 1999  Richard Henderson  <rth@cygnus.com>\n \n Tue Jan 19 15:00:10 1999  Jeffrey A Law  (law@cygnus.com)\n \n+\t* flow.c (invalidate_from_autoinc): New function.\n+\t(mark_set_1, mark_used_regs): Use it.\n+\n \t* Makefile.in (protoize.o, unprotoize.o): Depend on Makefile.\n \n 1999-01-19  Vladimir N. Makarov  <vmakarov@cygnus.com>"}, {"sha": "cd5de3844422fb7e3b33ee0cb9b6c68a99dddd77", "filename": "gcc/flow.c", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e088b20edd4351b8e0913edfbae3b107175d1f/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e088b20edd4351b8e0913edfbae3b107175d1f/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=15e088b20edd4351b8e0913edfbae3b107175d1f", "patch": "@@ -295,6 +295,7 @@ static void count_reg_sets_1\t\tPROTO ((rtx));\n static void count_reg_sets\t\tPROTO ((rtx));\n static void count_reg_references\tPROTO ((rtx));\n static void notice_stack_pointer_modification PROTO ((rtx, rtx));\n+static void invalidate_mems_from_autoinc\tPROTO ((rtx));\n \f\n /* Find basic blocks of the current function.\n    F is the first insn of the function and NREGS the number of register numbers\n@@ -2225,6 +2226,39 @@ regno_clobbered_at_setjmp (regno)\n \t  && REGNO_REG_SET_P (regs_live_at_setjmp, regno));\n }\n \f\n+/* INSN references memory, possibly using autoincrement addressing modes.\n+   Find any entries on the mem_set_list that need to be invalidated due\n+   to an address change.  */\n+static void\n+invalidate_mems_from_autoinc (insn)\n+     rtx insn;\n+{\n+  rtx note = REG_NOTES (insn);\n+  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+    {\n+      if (REG_NOTE_KIND (note) == REG_INC)\n+        {\n+          rtx temp = mem_set_list;\n+          rtx prev = NULL_RTX;\n+\n+          while (temp)\n+\t    {\n+\t      if (reg_overlap_mentioned_p (XEXP (note, 0), XEXP (temp, 0)))\n+\t        {\n+\t          /* Splice temp out of list.  */\n+\t          if (prev)\n+\t            XEXP (prev, 1) = XEXP (temp, 1);\n+\t          else\n+\t            mem_set_list = XEXP (temp, 1);\n+\t        }\n+\t      else\n+\t        prev = temp;\n+              temp = XEXP (temp, 1);\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Process the registers that are set within X.\n    Their bits are set to 1 in the regset DEAD,\n    because they are dead prior to this insn.\n@@ -2327,7 +2361,13 @@ mark_set_1 (needed, dead, x, insn, significant)\n \t  temp = XEXP (temp, 1);\n \t}\n     }\n-    \n+\n+  /* If the memory reference had embedded side effects (autoincrement\n+     address modes.  Then we may need to kill some entries on the\n+     memory set list.  */\n+  if (insn && GET_CODE (reg) == MEM)\n+    invalidate_mems_from_autoinc (insn);\n+\n   if (GET_CODE (reg) == MEM && ! side_effects_p (reg)\n       /* There are no REG_INC notes for SP, so we can't assume we'll see \n \t everything that invalidates it.  To be safe, don't eliminate any\n@@ -2750,6 +2790,12 @@ mark_used_regs (needed, live, x, final, insn)\n \t    }\n \t}\n \n+      /* If the memory reference had embedded side effects (autoincrement\n+\t address modes.  Then we may need to kill some entries on the\n+\t memory set list.  */\n+      if (insn)\n+\tinvalidate_mems_from_autoinc (insn);\n+\n #ifdef AUTO_INC_DEC\n       if (final)\n \tfind_auto_inc (needed, x, insn);"}]}