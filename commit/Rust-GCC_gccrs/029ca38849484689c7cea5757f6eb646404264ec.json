{"sha": "029ca38849484689c7cea5757f6eb646404264ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI5Y2EzODg0OTQ4NDY4OWM3Y2VhNTc1N2Y2ZWI2NDY0MDQyNjRlYw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-07-30T12:13:01Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-07-30T12:13:01Z"}, "message": "re PR tree-optimization/91257 (Compile-time and memory-hog hog)\n\n2019-07-30  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/91257\n\t* bitmap.h (bitmap_ior_into_and_free): Declare.\n\t* bitmap.c (bitmap_list_unlink_element): Add defaulted param\n\twhether to add the unliked element to the freelist.\n\t(bitmap_list_insert_element_after): Add defaulted param for\n\tan already allocated element.\n\t(bitmap_ior_into_and_free): New function.\n\t* tree-ssa-structalias.c (condense_visit): Reduce the\n\tponts-to and edge bitmaps of the SCC members in a\n\tlogarithmic fashion rather than all to one.\n\nFrom-SVN: r273907", "tree": {"sha": "3c7bc0b1c1505b914d58c1536b246f7b13179c1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c7bc0b1c1505b914d58c1536b246f7b13179c1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/029ca38849484689c7cea5757f6eb646404264ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/029ca38849484689c7cea5757f6eb646404264ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/029ca38849484689c7cea5757f6eb646404264ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/029ca38849484689c7cea5757f6eb646404264ec/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1da8ab97a129ded60471ffcc2595ddce67336cd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1da8ab97a129ded60471ffcc2595ddce67336cd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1da8ab97a129ded60471ffcc2595ddce67336cd8"}], "stats": {"total": 169, "additions": 137, "deletions": 32}, "files": [{"sha": "0b64fa815823ceccf3d1361c714a5a37211d3e7a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/029ca38849484689c7cea5757f6eb646404264ec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/029ca38849484689c7cea5757f6eb646404264ec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=029ca38849484689c7cea5757f6eb646404264ec", "patch": "@@ -1,3 +1,16 @@\n+2019-07-30  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/91257\n+\t* bitmap.h (bitmap_ior_into_and_free): Declare.\n+\t* bitmap.c (bitmap_list_unlink_element): Add defaulted param\n+\twhether to add the unliked element to the freelist.\n+\t(bitmap_list_insert_element_after): Add defaulted param for\n+\tan already allocated element.\n+\t(bitmap_ior_into_and_free): New function.\n+\t* tree-ssa-structalias.c (condense_visit): Reduce the\n+\tponts-to and edge bitmaps of the SCC members in a\n+\tlogarithmic fashion rather than all to one.\n+\n 2019-07-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-ssa-math-opts.c (convert_mult_to_fma): Add a mul_cond"}, {"sha": "838a31da238b23ee1085c17912900d58461d6ff4", "filename": "gcc/bitmap.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/029ca38849484689c7cea5757f6eb646404264ec/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/029ca38849484689c7cea5757f6eb646404264ec/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=029ca38849484689c7cea5757f6eb646404264ec", "patch": "@@ -267,7 +267,8 @@ bitmap_list_link_element (bitmap head, bitmap_element *element)\n    and return it to the freelist.  */\n \n static inline void\n-bitmap_list_unlink_element (bitmap head, bitmap_element *element)\n+bitmap_list_unlink_element (bitmap head, bitmap_element *element,\n+\t\t\t    bool to_freelist = true)\n {\n   bitmap_element *next = element->next;\n   bitmap_element *prev = element->prev;\n@@ -294,18 +295,21 @@ bitmap_list_unlink_element (bitmap head, bitmap_element *element)\n \thead->indx = 0;\n     }\n \n-  bitmap_elem_to_freelist (head, element);\n+  if (to_freelist)\n+    bitmap_elem_to_freelist (head, element);\n }\n \n-/* Insert a new uninitialized element into bitmap HEAD after element\n-   ELT.  If ELT is NULL, insert the element at the start.  Return the\n-   new element.  */\n+/* Insert a new uninitialized element (or NODE if not NULL) into bitmap\n+   HEAD after element ELT.  If ELT is NULL, insert the element at the start.\n+   Return the new element.  */\n \n static bitmap_element *\n bitmap_list_insert_element_after (bitmap head,\n-\t\t\t\t  bitmap_element *elt, unsigned int indx)\n+\t\t\t\t  bitmap_element *elt, unsigned int indx,\n+\t\t\t\t  bitmap_element *node = NULL)\n {\n-  bitmap_element *node = bitmap_element_allocate (head);\n+  if (!node)\n+    node = bitmap_element_allocate (head);\n   node->indx = indx;\n \n   gcc_checking_assert (!head->tree_form);\n@@ -2026,6 +2030,56 @@ bitmap_ior_into (bitmap a, const_bitmap b)\n   return changed;\n }\n \n+/* A |= B.  Return true if A changes.  Free B (re-using its storage\n+   for the result).  */\n+\n+bool\n+bitmap_ior_into_and_free (bitmap a, bitmap *b_)\n+{\n+  bitmap b = *b_;\n+  bitmap_element *a_elt = a->first;\n+  bitmap_element *b_elt = b->first;\n+  bitmap_element *a_prev = NULL;\n+  bitmap_element **a_prev_pnext = &a->first;\n+  bool changed = false;\n+\n+  gcc_checking_assert (!a->tree_form && !b->tree_form);\n+  gcc_assert (a->obstack == b->obstack);\n+  if (a == b)\n+    return false;\n+\n+  while (b_elt)\n+    {\n+      /* If A lags behind B, just advance it.  */\n+      if (!a_elt || a_elt->indx == b_elt->indx)\n+\t{\n+\t  changed = bitmap_elt_ior (a, a_elt, a_prev, a_elt, b_elt, changed);\n+\t  b_elt = b_elt->next;\n+\t}\n+      else if (a_elt->indx > b_elt->indx)\n+\t{\n+\t  bitmap_element *b_elt_next = b_elt->next;\n+\t  bitmap_list_unlink_element (b, b_elt, false);\n+\t  bitmap_list_insert_element_after (a, a_prev, b_elt->indx, b_elt);\n+\t  b_elt = b_elt_next;\n+\t}\n+\n+      a_prev = *a_prev_pnext;\n+      a_prev_pnext = &a_prev->next;\n+      a_elt = *a_prev_pnext;\n+    }\n+\n+  gcc_checking_assert (!a->current == !a->first);\n+  if (a->current)\n+    a->indx = a->current->indx;\n+\n+  if (b->obstack)\n+    BITMAP_FREE (*b_);\n+  else\n+    bitmap_clear (b);\n+  return changed;\n+}\n+\n /* DST = A ^ B  */\n \n void"}, {"sha": "5e080afd457a1303e07a21f85fcdc9c07ea22211", "filename": "gcc/bitmap.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/029ca38849484689c7cea5757f6eb646404264ec/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/029ca38849484689c7cea5757f6eb646404264ec/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=029ca38849484689c7cea5757f6eb646404264ec", "patch": "@@ -415,6 +415,7 @@ extern void bitmap_clear_range (bitmap, unsigned int, unsigned int);\n extern void bitmap_set_range (bitmap, unsigned int, unsigned int);\n extern bool bitmap_ior (bitmap, const_bitmap, const_bitmap);\n extern bool bitmap_ior_into (bitmap, const_bitmap);\n+extern bool bitmap_ior_into_and_free (bitmap, bitmap *);\n extern void bitmap_xor (bitmap, const_bitmap, const_bitmap);\n extern void bitmap_xor_into (bitmap, const_bitmap);\n "}, {"sha": "974b639f2fe0e7b74f85337f8a554e8b6d715405", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 62, "deletions": 25, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/029ca38849484689c7cea5757f6eb646404264ec/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/029ca38849484689c7cea5757f6eb646404264ec/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=029ca38849484689c7cea5757f6eb646404264ec", "patch": "@@ -2071,36 +2071,73 @@ condense_visit (constraint_graph_t graph, class scc_info *si, unsigned int n)\n   /* See if any components have been identified.  */\n   if (si->dfs[n] == my_dfs)\n     {\n-      while (si->scc_stack.length () != 0\n-\t     && si->dfs[si->scc_stack.last ()] >= my_dfs)\n+      if (si->scc_stack.length () != 0\n+\t  && si->dfs[si->scc_stack.last ()] >= my_dfs)\n \t{\n-\t  unsigned int w = si->scc_stack.pop ();\n-\t  si->node_mapping[w] = n;\n-\n-\t  if (!bitmap_bit_p (graph->direct_nodes, w))\n-\t    bitmap_clear_bit (graph->direct_nodes, n);\n-\n-\t  /* Unify our nodes.  */\n-\t  if (graph->preds[w])\n-\t    {\n-\t      if (!graph->preds[n])\n-\t\tgraph->preds[n] = BITMAP_ALLOC (&predbitmap_obstack);\n-\t      bitmap_ior_into (graph->preds[n], graph->preds[w]);\n-\t    }\n-\t  if (graph->implicit_preds[w])\n+\t  /* Find the first node of the SCC and do non-bitmap work.  */\n+\t  bool direct_p = true;\n+\t  unsigned first = si->scc_stack.length ();\n+\t  do\n \t    {\n-\t      if (!graph->implicit_preds[n])\n-\t\tgraph->implicit_preds[n] = BITMAP_ALLOC (&predbitmap_obstack);\n-\t      bitmap_ior_into (graph->implicit_preds[n],\n-\t\t\t       graph->implicit_preds[w]);\n+\t      --first;\n+\t      unsigned int w = si->scc_stack[first];\n+\t      si->node_mapping[w] = n;\n+\t      if (!bitmap_bit_p (graph->direct_nodes, w))\n+\t\tdirect_p = false;\n \t    }\n-\t  if (graph->points_to[w])\n+\t  while (first > 0\n+\t\t && si->dfs[si->scc_stack[first - 1]] >= my_dfs);\n+\t  if (!direct_p)\n+\t    bitmap_clear_bit (graph->direct_nodes, n);\n+\n+\t  /* Want to reduce to node n, push that first.  */\n+\t  si->scc_stack.reserve (1);\n+\t  si->scc_stack.quick_push (si->scc_stack[first]);\n+\t  si->scc_stack[first] = n;\n+\n+\t  unsigned scc_size = si->scc_stack.length () - first;\n+\t  unsigned split = scc_size / 2;\n+\t  unsigned carry = scc_size - split * 2;\n+\t  while (split > 0)\n \t    {\n-\t      if (!graph->points_to[n])\n-\t\tgraph->points_to[n] = BITMAP_ALLOC (&predbitmap_obstack);\n-\t      bitmap_ior_into (graph->points_to[n],\n-\t\t\t       graph->points_to[w]);\n+\t      for (unsigned i = 0; i < split; ++i)\n+\t\t{\n+\t\t  unsigned a = si->scc_stack[first + i];\n+\t\t  unsigned b = si->scc_stack[first + split + carry + i];\n+\n+\t\t  /* Unify our nodes.  */\n+\t\t  if (graph->preds[b])\n+\t\t    {\n+\t\t      if (!graph->preds[a])\n+\t\t\tstd::swap (graph->preds[a], graph->preds[b]);\n+\t\t      else\n+\t\t\tbitmap_ior_into_and_free (graph->preds[a],\n+\t\t\t\t\t\t  &graph->preds[b]);\n+\t\t    }\n+\t\t  if (graph->implicit_preds[b])\n+\t\t    {\n+\t\t      if (!graph->implicit_preds[a])\n+\t\t\tstd::swap (graph->implicit_preds[a],\n+\t\t\t\t   graph->implicit_preds[b]);\n+\t\t      else\n+\t\t\tbitmap_ior_into_and_free (graph->implicit_preds[a],\n+\t\t\t\t\t\t  &graph->implicit_preds[b]);\n+\t\t    }\n+\t\t  if (graph->points_to[b])\n+\t\t    {\n+\t\t      if (!graph->points_to[a])\n+\t\t\tstd::swap (graph->points_to[a], graph->points_to[b]);\n+\t\t      else\n+\t\t\tbitmap_ior_into_and_free (graph->points_to[a],\n+\t\t\t\t\t\t  &graph->points_to[b]);\n+\t\t    }\n+\t\t}\n+\t      unsigned remain = split + carry;\n+\t      split = remain / 2;\n+\t      carry = remain - split * 2;\n \t    }\n+\t  /* Actually pop the SCC.  */\n+\t  si->scc_stack.truncate (first);\n \t}\n       bitmap_set_bit (si->deleted, n);\n     }"}]}