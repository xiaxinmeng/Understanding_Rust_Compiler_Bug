{"sha": "f07178ca3c1e5dff799fb5016bb3767571db3165", "node_id": "C_kwDOANBUbNoAKGYwNzE3OGNhM2MxZTVkZmY3OTlmYjUwMTZiYjM3Njc1NzFkYjMxNjU", "commit": {"author": {"name": "Tom de Vries", "email": "tdevries@suse.de", "date": "2022-03-08T09:15:45Z"}, "committer": {"name": "Tom de Vries", "email": "tdevries@suse.de", "date": "2022-03-10T11:20:44Z"}, "message": "[nvptx] Disable warp sync in simt region\n\nI ran into a hang for this code:\n...\n  #pragma omp target map(tofrom: counter_N0)\n  #pragma omp simd\n  for (int i = 0 ; i < 1 ; i++ )\n    {\n      #pragma omp atomic update\n      counter_N0 = counter_N0 + 1 ;\n    }\n...\n\nThis has to do with the nature of -muniform-simt.  It has two modes of\noperation: inside and outside an SIMT region.\n\nOutside an SIMT region, a warp pretends to execute a single thread, but\nactually executes in all threads, to keep the local registers in all threads\nconsistent.  This approach works unless the insn that is executed is a syscall\nor an atomic insn.  In that case, the insn is predicated, such that it\nexecutes in only one thread.  If the predicated insn writes a result to a\nregister, then that register is propagated to the other threads, after which\nthe local registers in all threads are consistent again.\n\nInside an SIMT region, a warp executes in all threads.  However, the\npredication and propagation for syscalls and atomic insns is also present\nhere, because nvptx_reorg_uniform_simt works on all code.  Care has been taken\nthough to ensure that the predication and propagation is a nop.  That is,\ninside an SIMT region:\n- the predicate evalutes to true for each thread, and\n- the propagation insn copies a register from each thread to the same thread.\n\nThat works fine, until we use -mptx=6.0, and instead of using the deprecated\nwarp propagation insn shfl, we start using shfl.sync:\n...\n  @%r33 atom.add.u32\t\t_, [%r29], 1;\n\tshfl.sync.idx.b32\t%r30, %r30, %r32, 31, 0xffffffff;\n...\n\nThe shfl.sync specifies a member mask indicating all threads, but given that\nthe loop only has a single iteration, only thread 0 will execute the insn,\nwhere it will hang waiting for the other threads.\n\nFix this by predicating the shfl.sync (and likewise, bar.warp.sync and the\nuniform warp check) such that it only executes outside the SIMT region.\n\nTested on x86_64 with nvptx accelerator.\n\ngcc/ChangeLog:\n\n2022-03-08  Tom de Vries  <tdevries@suse.de>\n\n\tPR target/104783\n\t* config/nvptx/nvptx.cc (nvptx_init_unisimt_predicate)\n\t(nvptx_output_unisimt_switch): Handle unisimt_outside_simt_predicate.\n\t(nvptx_get_unisimt_outside_simt_predicate): New function.\n\t(predicate_insn): New function, factored out of ...\n\t(nvptx_reorg_uniform_simt): ... here.  Predicate all emitted insns.\n\t* config/nvptx/nvptx.h (struct machine_function): Add\n\tunisimt_outside_simt_predicate field.\n\t* config/nvptx/nvptx.md (define_insn \"nvptx_warpsync\")\n\t(define_insn \"nvptx_uniform_warp_check\"): Make predicable.\n\nlibgomp/ChangeLog:\n\n2022-03-10  Tom de Vries  <tdevries@suse.de>\n\n\t* testsuite/libgomp.c/pr104783.c: New test.", "tree": {"sha": "3d4fd974e83ccbbf41ea3ada9f29fce875d0faf3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d4fd974e83ccbbf41ea3ada9f29fce875d0faf3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f07178ca3c1e5dff799fb5016bb3767571db3165", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f07178ca3c1e5dff799fb5016bb3767571db3165", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f07178ca3c1e5dff799fb5016bb3767571db3165", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f07178ca3c1e5dff799fb5016bb3767571db3165/comments", "author": {"login": "vries", "id": 4057235, "node_id": "MDQ6VXNlcjQwNTcyMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vries", "html_url": "https://github.com/vries", "followers_url": "https://api.github.com/users/vries/followers", "following_url": "https://api.github.com/users/vries/following{/other_user}", "gists_url": "https://api.github.com/users/vries/gists{/gist_id}", "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vries/subscriptions", "organizations_url": "https://api.github.com/users/vries/orgs", "repos_url": "https://api.github.com/users/vries/repos", "events_url": "https://api.github.com/users/vries/events{/privacy}", "received_events_url": "https://api.github.com/users/vries/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vries", "id": 4057235, "node_id": "MDQ6VXNlcjQwNTcyMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vries", "html_url": "https://github.com/vries", "followers_url": "https://api.github.com/users/vries/followers", "following_url": "https://api.github.com/users/vries/following{/other_user}", "gists_url": "https://api.github.com/users/vries/gists{/gist_id}", "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vries/subscriptions", "organizations_url": "https://api.github.com/users/vries/orgs", "repos_url": "https://api.github.com/users/vries/repos", "events_url": "https://api.github.com/users/vries/events{/privacy}", "received_events_url": "https://api.github.com/users/vries/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e743d654b3598d54b3c2eb837a48baeac00a543", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e743d654b3598d54b3c2eb837a48baeac00a543", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e743d654b3598d54b3c2eb837a48baeac00a543"}], "stats": {"total": 93, "additions": 76, "deletions": 17}, "files": [{"sha": "3a7be63c290ee063815dfd61897a46723f5aa537", "filename": "gcc/config/nvptx/nvptx.cc", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f07178ca3c1e5dff799fb5016bb3767571db3165/gcc%2Fconfig%2Fnvptx%2Fnvptx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f07178ca3c1e5dff799fb5016bb3767571db3165/gcc%2Fconfig%2Fnvptx%2Fnvptx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.cc?ref=f07178ca3c1e5dff799fb5016bb3767571db3165", "patch": "@@ -1364,6 +1364,13 @@ nvptx_init_unisimt_predicate (FILE *file)\n       int master = REGNO (cfun->machine->unisimt_master);\n       int pred = REGNO (cfun->machine->unisimt_predicate);\n       fprintf (file, \"\\t\\tld.shared.u32 %%r%d, [%%r%d];\\n\", master, loc);\n+      if (cfun->machine->unisimt_outside_simt_predicate)\n+\t{\n+\t  int pred_outside_simt\n+\t    = REGNO (cfun->machine->unisimt_outside_simt_predicate);\n+\t  fprintf (file, \"\\t\\tsetp.eq.u32 %%r%d, %%r%d, 0;\\n\",\n+\t\t   pred_outside_simt, master);\n+\t}\n       fprintf (file, \"\\t\\tmov.u32 %%ustmp0, %%laneid;\\n\");\n       /* Compute 'master lane index' as 'laneid & __nvptx_uni[tid.y]'.  */\n       fprintf (file, \"\\t\\tand.b32 %%r%d, %%r%d, %%ustmp0;\\n\", master, master);\n@@ -1589,6 +1596,13 @@ nvptx_output_unisimt_switch (FILE *file, bool entering)\n   fprintf (file, \"\\t{\\n\");\n   fprintf (file, \"\\t\\t.reg.u32 %%ustmp2;\\n\");\n   fprintf (file, \"\\t\\tmov.u32 %%ustmp2, %d;\\n\", entering ? -1 : 0);\n+  if (cfun->machine->unisimt_outside_simt_predicate)\n+    {\n+      int pred_outside_simt\n+\t= REGNO (cfun->machine->unisimt_outside_simt_predicate);\n+      fprintf (file, \"\\t\\tmov.pred %%r%d, %d;\\n\", pred_outside_simt,\n+\t       entering ? 0 : 1);\n+    }\n   if (!crtl->is_leaf)\n     {\n       int loc = REGNO (cfun->machine->unisimt_location);\n@@ -3242,6 +3256,13 @@ nvptx_get_unisimt_predicate ()\n   return pred ? pred : pred = gen_reg_rtx (BImode);\n }\n \n+static rtx\n+nvptx_get_unisimt_outside_simt_predicate ()\n+{\n+  rtx &pred = cfun->machine->unisimt_outside_simt_predicate;\n+  return pred ? pred : pred = gen_reg_rtx (BImode);\n+}\n+\n /* Return true if given call insn references one of the functions provided by\n    the CUDA runtime: malloc, free, vprintf.  */\n \n@@ -3286,6 +3307,16 @@ nvptx_unisimt_handle_set (rtx set, rtx_insn *insn, rtx master)\n   return false;\n }\n \n+static void\n+predicate_insn (rtx_insn *insn, rtx pred)\n+{\n+  rtx pat = PATTERN (insn);\n+  pred = gen_rtx_NE (BImode, pred, const0_rtx);\n+  pat = gen_rtx_COND_EXEC (VOIDmode, pred, pat);\n+  bool changed_p = validate_change (insn, &PATTERN (insn), pat, false);\n+  gcc_assert (changed_p);\n+}\n+\n /* Adjust code for uniform-simt code generation variant by making atomics and\n    \"syscalls\" conditionally executed, and inserting shuffle-based propagation\n    for registers being set.  */\n@@ -3352,10 +3383,16 @@ nvptx_reorg_uniform_simt ()\n \t}\n \n       rtx pred = nvptx_get_unisimt_predicate ();\n-      pred = gen_rtx_NE (BImode, pred, const0_rtx);\n-      pat = gen_rtx_COND_EXEC (VOIDmode, pred, pat);\n-      bool changed_p = validate_change (insn, &PATTERN (insn), pat, false);\n-      gcc_assert (changed_p);\n+      predicate_insn (insn, pred);\n+\n+      pred = NULL_RTX;\n+      for (rtx_insn *post = NEXT_INSN (insn); post != next;\n+\t   post = NEXT_INSN (post))\n+\t{\n+\t  if (pred == NULL_RTX)\n+\t    pred = nvptx_get_unisimt_outside_simt_predicate ();\n+\t  predicate_insn (post, pred);\n+\t}\n     }\n }\n "}, {"sha": "b55ade65cc580353ec19431754eb131c6ce7069a", "filename": "gcc/config/nvptx/nvptx.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f07178ca3c1e5dff799fb5016bb3767571db3165/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f07178ca3c1e5dff799fb5016bb3767571db3165/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.h?ref=f07178ca3c1e5dff799fb5016bb3767571db3165", "patch": "@@ -226,6 +226,7 @@ struct GTY(()) machine_function\n   rtx sync_bar; /* Synchronization barrier ID for vectors.  */\n   rtx unisimt_master; /* 'Master lane index' for -muniform-simt.  */\n   rtx unisimt_predicate; /* Predicate for -muniform-simt.  */\n+  rtx unisimt_outside_simt_predicate; /* Predicate for -muniform-simt.  */\n   rtx unisimt_location; /* Mask location for -muniform-simt.  */\n   /* The following two fields hold the maximum size resp. alignment required\n      for per-lane storage in OpenMP SIMD regions.  */"}, {"sha": "1ccb0f11e4cb71d67cc4282aa53f3f1beeab08ab", "filename": "gcc/config/nvptx/nvptx.md", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f07178ca3c1e5dff799fb5016bb3767571db3165/gcc%2Fconfig%2Fnvptx%2Fnvptx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f07178ca3c1e5dff799fb5016bb3767571db3165/gcc%2Fconfig%2Fnvptx%2Fnvptx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.md?ref=f07178ca3c1e5dff799fb5016bb3767571db3165", "patch": "@@ -2268,25 +2268,28 @@\n (define_insn \"nvptx_warpsync\"\n   [(unspec_volatile [(const_int 0)] UNSPECV_WARPSYNC)]\n   \"TARGET_PTX_6_0\"\n-  \"\\\\tbar.warp.sync\\\\t0xffffffff;\"\n-  [(set_attr \"predicable\" \"false\")])\n+  \"%.\\\\tbar.warp.sync\\\\t0xffffffff;\")\n \n (define_insn \"nvptx_uniform_warp_check\"\n   [(unspec_volatile [(const_int 0)] UNSPECV_UNIFORM_WARP_CHECK)]\n   \"\"\n   {\n-    output_asm_insn (\"{\", NULL);\n-    output_asm_insn (\"\\\\t\"\t \".reg.b32\"\t   \"\\\\t\" \"act;\", NULL);\n-    output_asm_insn (\"\\\\t\"\t \"vote.ballot.b32\" \"\\\\t\" \"act,1;\", NULL);\n-    output_asm_insn (\"\\\\t\"\t \".reg.pred\"\t   \"\\\\t\" \"uni;\", NULL);\n-    output_asm_insn (\"\\\\t\"\t \"setp.eq.b32\"\t   \"\\\\t\" \"uni,act,0xffffffff;\",\n-\t\t     NULL);\n-    output_asm_insn (\"@ !uni\\\\t\" \"trap;\", NULL);\n-    output_asm_insn (\"@ !uni\\\\t\" \"exit;\", NULL);\n-    output_asm_insn (\"}\", NULL);\n+    const char *insns[] = {\n+      \"{\",\n+      \"\\\\t\"\t      \".reg.b32\"\t\"\\\\t\" \"act;\",\n+      \"%.\\\\t\"\t      \"vote.ballot.b32\" \"\\\\t\" \"act,1;\",\n+      \"\\\\t\"\t      \".reg.pred\"\t\"\\\\t\" \"do_abort;\",\n+      \"\\\\t\"\t      \"mov.pred\"\t\"\\\\t\" \"do_abort,0;\",\n+      \"%.\\\\t\"\t      \"setp.ne.b32\"\t\"\\\\t\" \"do_abort,act,0xffffffff;\",\n+      \"@ do_abort\\\\t\" \"trap;\",\n+      \"@ do_abort\\\\t\" \"exit;\",\n+      \"}\",\n+      NULL\n+    };\n+    for (const char **p = &insns[0]; *p != NULL; p++)\n+      output_asm_insn (*p, NULL);\n     return \"\";\n-  }\n-  [(set_attr \"predicable\" \"false\")])\n+  })\n \n (define_expand \"memory_barrier\"\n   [(set (match_dup 0)"}, {"sha": "05a93cd6bc166a29fc3c871ed28a8ab42e9a1bce", "filename": "libgomp/testsuite/libgomp.c/pr104783.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f07178ca3c1e5dff799fb5016bb3767571db3165/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr104783.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f07178ca3c1e5dff799fb5016bb3767571db3165/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr104783.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr104783.c?ref=f07178ca3c1e5dff799fb5016bb3767571db3165", "patch": "@@ -0,0 +1,18 @@\n+int\n+main (void)\n+{\n+  unsigned val = 0;\n+\n+#pragma omp target map(tofrom: val)\n+#pragma omp simd\n+  for (int i = 0 ; i < 1 ; i++)\n+    {\n+#pragma omp atomic update\n+      val = val + 1;\n+    }\n+\n+  if (val != 1)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}]}