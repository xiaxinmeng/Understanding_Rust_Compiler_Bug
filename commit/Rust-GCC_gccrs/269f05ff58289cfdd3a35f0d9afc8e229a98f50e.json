{"sha": "269f05ff58289cfdd3a35f0d9afc8e229a98f50e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY5ZjA1ZmY1ODI4OWNmZGQzYTM1ZjBkOWFmYzhlMjI5YTk4ZjUwZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-06-06T00:44:01Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-06-06T00:44:01Z"}, "message": "compiler: make use of specialized fast map routines\n    \n    In the runtime there are specialized fast map routines for\n    certain kep types. This CL lets the compiler make use of these\n    functions, instead of always using the generic ones.\n    \n    As we now generate multiple versions of map delete calls, to make\n    things easier we delay the expansion of the built-in delete\n    function to flatten phase.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/180858\n\nFrom-SVN: r271983", "tree": {"sha": "5375b70ffa2d9dda8fe739d2ee1a4a412d7d5c96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5375b70ffa2d9dda8fe739d2ee1a4a412d7d5c96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/269f05ff58289cfdd3a35f0d9afc8e229a98f50e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/269f05ff58289cfdd3a35f0d9afc8e229a98f50e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/269f05ff58289cfdd3a35f0d9afc8e229a98f50e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/269f05ff58289cfdd3a35f0d9afc8e229a98f50e/comments", "author": null, "committer": null, "parents": [{"sha": "91bd9240f918e758b75e362847f4fc3de8f99a12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91bd9240f918e758b75e362847f4fc3de8f99a12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91bd9240f918e758b75e362847f4fc3de8f99a12"}], "stats": {"total": 549, "additions": 435, "deletions": 114}, "files": [{"sha": "2b7525548f2f65e1ad08be158b912927fa24f164", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269f05ff58289cfdd3a35f0d9afc8e229a98f50e/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269f05ff58289cfdd3a35f0d9afc8e229a98f50e/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=269f05ff58289cfdd3a35f0d9afc8e229a98f50e", "patch": "@@ -1,4 +1,4 @@\n-2609f9b8420e2341fbbe40d7cf6af42b0fba7293\n+bc7374913367fba9b10dc284af87eb539fb6c5b2\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "2957c0d1e507bae29ea76beb12e8d673137128ba", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269f05ff58289cfdd3a35f0d9afc8e229a98f50e/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269f05ff58289cfdd3a35f0d9afc8e229a98f50e/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=269f05ff58289cfdd3a35f0d9afc8e229a98f50e", "patch": "@@ -1622,6 +1622,16 @@ Escape_analysis_assign::expression(Expression** pexpr)\n                 }\n                 break;\n \n+              case Runtime::MAPASSIGN_FAST32PTR:\n+              case Runtime::MAPASSIGN_FAST64PTR:\n+              case Runtime::MAPASSIGN_FASTSTR:\n+                {\n+                  // Map key escapes. The last argument is the key.\n+                  Node* key_node = Node::make_node(call->args()->back());\n+                  this->assign(this->context_->sink(), key_node);\n+                }\n+                break;\n+\n               case Runtime::IFACEE2T2:\n               case Runtime::IFACEI2T2:\n                 {"}, {"sha": "061db5aa8b9f8c1261278dccf4fe1b067821ef39", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 170, "deletions": 67, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269f05ff58289cfdd3a35f0d9afc8e229a98f50e/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269f05ff58289cfdd3a35f0d9afc8e229a98f50e/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=269f05ff58289cfdd3a35f0d9afc8e229a98f50e", "patch": "@@ -7843,63 +7843,33 @@ Builtin_call_expression::do_lower(Gogo*, Named_object* function,\n \n     case BUILTIN_DELETE:\n       {\n-\t// Lower to a runtime function call.\n-\tconst Expression_list* args = this->args();\n-\tif (args == NULL || args->size() < 2)\n-\t  this->report_error(_(\"not enough arguments\"));\n-\telse if (args->size() > 2)\n-\t  this->report_error(_(\"too many arguments\"));\n-\telse if (args->front()->type()->map_type() == NULL)\n-\t  this->report_error(_(\"argument 1 must be a map\"));\n-\telse\n-\t  {\n-\t    // Since this function returns no value it must appear in\n-\t    // a statement by itself, so we don't have to worry about\n-\t    // order of evaluation of values around it.  Evaluate the\n-\t    // map first to get order of evaluation right.\n-\t    Map_type* mt = args->front()->type()->map_type();\n-\t    Temporary_statement* map_temp =\n-\t      Statement::make_temporary(mt, args->front(), loc);\n-\t    inserter->insert(map_temp);\n-\n-\t    Temporary_statement* key_temp =\n-\t      Statement::make_temporary(mt->key_type(), args->back(), loc);\n-\t    inserter->insert(key_temp);\n-\n-\t    Expression* e1 = Expression::make_type_descriptor(mt, loc);\n-\t    Expression* e2 = Expression::make_temporary_reference(map_temp,\n-\t\t\t\t\t\t\t\t  loc);\n-\t    Expression* e3 = Expression::make_temporary_reference(key_temp,\n-\t\t\t\t\t\t\t\t  loc);\n-\n-\t    // If the call to delete is deferred, and is in a loop,\n-\t    // then the loop will only have a single instance of the\n-\t    // temporary variable.  Passing the address of the\n-\t    // temporary variable here means that the deferred call\n-\t    // will see the last value in the loop, not the current\n-\t    // value.  So for this unusual case copy the value into\n-\t    // the heap.\n-\t    if (!this->is_deferred())\n-\t      e3 = Expression::make_unary(OPERATOR_AND, e3, loc);\n-\t    else\n-\t      {\n-\t\tExpression* a = Expression::make_allocation(mt->key_type(),\n-\t\t\t\t\t\t\t    loc);\n-\t\tTemporary_statement* atemp =\n-\t\t  Statement::make_temporary(NULL, a, loc);\n-\t\tinserter->insert(atemp);\n-\n-\t\ta = Expression::make_temporary_reference(atemp, loc);\n-\t\ta = Expression::make_dereference(a, NIL_CHECK_NOT_NEEDED, loc);\n-\t\tStatement* s = Statement::make_assignment(a, e3, loc);\n-\t\tinserter->insert(s);\n-\n-\t\te3 = Expression::make_temporary_reference(atemp, loc);\n-\t      }\n-\n-\t    return Runtime::make_call(Runtime::MAPDELETE, this->location(),\n-\t\t\t\t      3, e1, e2, e3);\n-\t  }\n+        const Expression_list* args = this->args();\n+        if (args == NULL || args->size() < 2)\n+          this->report_error(_(\"not enough arguments\"));\n+        else if (args->size() > 2)\n+          this->report_error(_(\"too many arguments\"));\n+        else if (args->front()->type()->map_type() == NULL)\n+          this->report_error(_(\"argument 1 must be a map\"));\n+        else\n+          {\n+            Type* key_type =\n+              args->front()->type()->map_type()->key_type();\n+            Expression_list::iterator pa = this->args()->begin();\n+            pa++;\n+            Type* arg_type = (*pa)->type();\n+            std::string reason;\n+            if (!Type::are_assignable(key_type, arg_type, &reason))\n+              {\n+                if (reason.empty())\n+                  go_error_at(loc, \"argument 2 has incompatible type\");\n+                else\n+                  go_error_at(loc, \"argument 2 has incompatible type (%s)\",\n+                              reason.c_str());\n+                this->set_is_error();\n+              }\n+            else if (!Type::are_identical(key_type, arg_type, 0, NULL))\n+              *pa = Expression::make_cast(key_type, *pa, loc);\n+          }\n       }\n       break;\n \n@@ -7935,6 +7905,12 @@ Expression*\n Builtin_call_expression::do_flatten(Gogo* gogo, Named_object* function,\n                                     Statement_inserter* inserter)\n {\n+  if (this->is_error_expression())\n+    {\n+      go_assert(saw_errors());\n+      return this;\n+    }\n+\n   Location loc = this->location();\n \n   switch (this->code_)\n@@ -8078,6 +8054,96 @@ Builtin_call_expression::do_flatten(Gogo* gogo, Named_object* function,\n \t  }\n       }\n       break;\n+\n+    case BUILTIN_DELETE:\n+      {\n+        // Lower to a runtime function call.\n+        const Expression_list* args = this->args();\n+\n+        // Since this function returns no value it must appear in\n+        // a statement by itself, so we don't have to worry about\n+        // order of evaluation of values around it.  Evaluate the\n+        // map first to get order of evaluation right.\n+        Map_type* mt = args->front()->type()->map_type();\n+        Temporary_statement* map_temp =\n+          Statement::make_temporary(mt, args->front(), loc);\n+        inserter->insert(map_temp);\n+\n+        Temporary_statement* key_temp =\n+          Statement::make_temporary(mt->key_type(), args->back(), loc);\n+        inserter->insert(key_temp);\n+\n+        Expression* e1 = Expression::make_type_descriptor(mt, loc);\n+        Expression* e2 = Expression::make_temporary_reference(map_temp,\n+                                                              loc);\n+        Expression* e3 = Expression::make_temporary_reference(key_temp,\n+                                                              loc);\n+\n+        Runtime::Function code;\n+        switch (mt->algorithm(gogo))\n+          {\n+            case Map_type::MAP_ALG_FAST32:\n+            case Map_type::MAP_ALG_FAST32PTR:\n+              {\n+                code = Runtime::MAPDELETE_FAST32;\n+                Type* uint32_type = Type::lookup_integer_type(\"uint32\");\n+                Type* uint32_ptr_type = Type::make_pointer_type(uint32_type);\n+                e3 = Expression::make_unary(OPERATOR_AND, e3, loc);\n+                e3 = Expression::make_unsafe_cast(uint32_ptr_type, e3,\n+                                                  loc);\n+                e3 = Expression::make_dereference(e3,\n+                                                  Expression::NIL_CHECK_NOT_NEEDED,\n+                                                  loc);\n+                break;\n+              }\n+            case Map_type::MAP_ALG_FAST64:\n+            case Map_type::MAP_ALG_FAST64PTR:\n+              {\n+                code = Runtime::MAPDELETE_FAST64;\n+                Type* uint64_type = Type::lookup_integer_type(\"uint64\");\n+                Type* uint64_ptr_type = Type::make_pointer_type(uint64_type);\n+                e3 = Expression::make_unary(OPERATOR_AND, e3, loc);\n+                e3 = Expression::make_unsafe_cast(uint64_ptr_type, e3,\n+                                                  loc);\n+                e3 = Expression::make_dereference(e3,\n+                                                  Expression::NIL_CHECK_NOT_NEEDED,\n+                                                  loc);\n+                break;\n+              }\n+            case Map_type::MAP_ALG_FASTSTR:\n+              code = Runtime::MAPDELETE_FASTSTR;\n+              break;\n+            default:\n+              code = Runtime::MAPDELETE;\n+\n+              // If the call to delete is deferred, and is in a loop,\n+              // then the loop will only have a single instance of the\n+              // temporary variable.  Passing the address of the\n+              // temporary variable here means that the deferred call\n+              // will see the last value in the loop, not the current\n+              // value.  So for this unusual case copy the value into\n+              // the heap.\n+              if (!this->is_deferred())\n+                e3 = Expression::make_unary(OPERATOR_AND, e3, loc);\n+              else\n+                {\n+                  Expression* a = Expression::make_allocation(mt->key_type(),\n+                                                              loc);\n+                  Temporary_statement* atemp =\n+                    Statement::make_temporary(NULL, a, loc);\n+                  inserter->insert(atemp);\n+\n+                  a = Expression::make_temporary_reference(atemp, loc);\n+                  a = Expression::make_dereference(a, NIL_CHECK_NOT_NEEDED, loc);\n+                  Statement* s = Statement::make_assignment(a, e3, loc);\n+                  inserter->insert(s);\n+\n+                  e3 = Expression::make_temporary_reference(atemp, loc);\n+                }\n+          }\n+\n+        return Runtime::make_call(code, loc, 3, e1, e2, e3);\n+      }\n     }\n \n   return this;\n@@ -10159,6 +10225,9 @@ Builtin_call_expression::do_export(Export_function_body* efb) const\n \tcase BUILTIN_CAP:\n \t  s = \"cap\";\n \t  break;\n+\tcase BUILTIN_DELETE:\n+\t  s = \"delete\";\n+\t  break;\n \tcase BUILTIN_PRINT:\n \t  s = \"print\";\n \t  break;\n@@ -13031,20 +13100,54 @@ Map_index_expression::get_value_pointer(Gogo* gogo)\n \t\t\t\t\t\t     this->index_,\n                                                      loc);\n \n+      Expression* type_expr = Expression::make_type_descriptor(type, loc);\n       Expression* zero = type->fat_zero_value(gogo);\n-\n       Expression* map_index;\n-\n       if (zero == NULL)\n-\tmap_index =\n-          Runtime::make_call(Runtime::MAPACCESS1, loc, 3,\n-\t\t\t     Expression::make_type_descriptor(type, loc),\n-                             map_ref, index_ptr);\n+        {\n+          Runtime::Function code;\n+          Expression* key;\n+          switch (type->algorithm(gogo))\n+            {\n+              case Map_type::MAP_ALG_FAST32:\n+              case Map_type::MAP_ALG_FAST32PTR:\n+                {\n+                  Type* uint32_type = Type::lookup_integer_type(\"uint32\");\n+                  Type* uint32_ptr_type = Type::make_pointer_type(uint32_type);\n+                  key = Expression::make_unsafe_cast(uint32_ptr_type, index_ptr,\n+                                                     loc);\n+                  key = Expression::make_dereference(key, NIL_CHECK_NOT_NEEDED,\n+                                                     loc);\n+                  code = Runtime::MAPACCESS1_FAST32;\n+                  break;\n+                }\n+              case Map_type::MAP_ALG_FAST64:\n+              case Map_type::MAP_ALG_FAST64PTR:\n+                {\n+                  Type* uint64_type = Type::lookup_integer_type(\"uint64\");\n+                  Type* uint64_ptr_type = Type::make_pointer_type(uint64_type);\n+                  key = Expression::make_unsafe_cast(uint64_ptr_type, index_ptr,\n+                                                     loc);\n+                  key = Expression::make_dereference(key, NIL_CHECK_NOT_NEEDED,\n+                                                     loc);\n+                  code = Runtime::MAPACCESS1_FAST64;\n+                  break;\n+                }\n+              case Map_type::MAP_ALG_FASTSTR:\n+                key = this->index_;\n+                code = Runtime::MAPACCESS1_FASTSTR;\n+                break;\n+              default:\n+                key = index_ptr;\n+                code = Runtime::MAPACCESS1;\n+                break;\n+            }\n+          map_index = Runtime::make_call(code, loc, 3,\n+                                         type_expr, map_ref, key);\n+        }\n       else\n-\tmap_index =\n-\t  Runtime::make_call(Runtime::MAPACCESS1_FAT, loc, 4,\n-\t\t\t     Expression::make_type_descriptor(type, loc),\n-\t\t\t     map_ref, index_ptr, zero);\n+        map_index = Runtime::make_call(Runtime::MAPACCESS1_FAT, loc, 4,\n+                                       type_expr, map_ref, index_ptr, zero);\n \n       Type* val_type = type->val_type();\n       this->value_pointer_ ="}, {"sha": "34c86e8aafcdd51a9b236eaac2e0688089ab0d64", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269f05ff58289cfdd3a35f0d9afc8e229a98f50e/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269f05ff58289cfdd3a35f0d9afc8e229a98f50e/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=269f05ff58289cfdd3a35f0d9afc8e229a98f50e", "patch": "@@ -109,6 +109,18 @@ DEF_GO_RUNTIME(CONSTRUCT_MAP, \"__go_construct_map\",\n DEF_GO_RUNTIME(MAPACCESS1, \"runtime.mapaccess1\", P3(TYPE, MAP, POINTER),\n \t       R1(POINTER))\n \n+// Look up a uint32 key in a map.\n+DEF_GO_RUNTIME(MAPACCESS1_FAST32, \"runtime.mapaccess1_fast32\",\n+               P3(TYPE, MAP, UINT32), R1(POINTER))\n+\n+// Look up a uint64 key in a map.\n+DEF_GO_RUNTIME(MAPACCESS1_FAST64, \"runtime.mapaccess1_fast64\",\n+               P3(TYPE, MAP, UINT64), R1(POINTER))\n+\n+// Look up a string key in a map.\n+DEF_GO_RUNTIME(MAPACCESS1_FASTSTR, \"runtime.mapaccess1_faststr\",\n+               P3(TYPE, MAP, STRING), R1(POINTER))\n+\n // Look up a key in a map when the value is large.\n DEF_GO_RUNTIME(MAPACCESS1_FAT, \"runtime.mapaccess1_fat\",\n \t       P4(TYPE, MAP, POINTER, POINTER), R1(POINTER))\n@@ -118,6 +130,21 @@ DEF_GO_RUNTIME(MAPACCESS1_FAT, \"runtime.mapaccess1_fat\",\n DEF_GO_RUNTIME(MAPACCESS2, \"runtime.mapaccess2\", P3(TYPE, MAP, POINTER),\n \t       R2(POINTER, BOOL))\n \n+// Look up a uint32 key in a map returning the value and whether\n+// it is present.\n+DEF_GO_RUNTIME(MAPACCESS2_FAST32, \"runtime.mapaccess2_fast32\",\n+               P3(TYPE, MAP, UINT32), R2(POINTER, BOOL))\n+\n+// Look up a uint64 key in a map returning the value and whether\n+// it is present.\n+DEF_GO_RUNTIME(MAPACCESS2_FAST64, \"runtime.mapaccess2_fast64\",\n+               P3(TYPE, MAP, UINT64), R2(POINTER, BOOL))\n+\n+// Look up a string key in a map returning the value and whether\n+// it is present.\n+DEF_GO_RUNTIME(MAPACCESS2_FASTSTR, \"runtime.mapaccess2_faststr\",\n+               P3(TYPE, MAP, STRING), R2(POINTER, BOOL))\n+\n // Look up a key in a map, returning the value and whether it is\n // present, when the value is large.\n DEF_GO_RUNTIME(MAPACCESS2_FAT, \"runtime.mapaccess2_fat\",\n@@ -127,9 +154,41 @@ DEF_GO_RUNTIME(MAPACCESS2_FAT, \"runtime.mapaccess2_fat\",\n DEF_GO_RUNTIME(MAPASSIGN, \"runtime.mapassign\", P3(TYPE, MAP, POINTER),\n \t       R1(POINTER))\n \n+// Assignment to a uint32 key in a map.\n+DEF_GO_RUNTIME(MAPASSIGN_FAST32, \"runtime.mapassign_fast32\",\n+               P3(TYPE, MAP, UINT32), R1(POINTER))\n+\n+// Assignment to a uint64 key in a map.\n+DEF_GO_RUNTIME(MAPASSIGN_FAST64, \"runtime.mapassign_fast64\",\n+               P3(TYPE, MAP, UINT64), R1(POINTER))\n+\n+// Assignment to a 32-bit pointer key in a map.\n+DEF_GO_RUNTIME(MAPASSIGN_FAST32PTR, \"runtime.mapassign_fast32ptr\",\n+               P3(TYPE, MAP, POINTER), R1(POINTER))\n+\n+// Assignment to a 64-bit pointer key in a map.\n+DEF_GO_RUNTIME(MAPASSIGN_FAST64PTR, \"runtime.mapassign_fast64ptr\",\n+               P3(TYPE, MAP, POINTER), R1(POINTER))\n+\n+// Assignment to a string key in a map.\n+DEF_GO_RUNTIME(MAPASSIGN_FASTSTR, \"runtime.mapassign_faststr\",\n+               P3(TYPE, MAP, STRING), R1(POINTER))\n+\n // Delete a key from a map.\n DEF_GO_RUNTIME(MAPDELETE, \"runtime.mapdelete\", P3(TYPE, MAP, POINTER), R0())\n \n+// Delete a uint32 key from a map.\n+DEF_GO_RUNTIME(MAPDELETE_FAST32, \"runtime.mapdelete_fast32\",\n+               P3(TYPE, MAP, UINT32), R0())\n+\n+// Delete a uint64 key from a map.\n+DEF_GO_RUNTIME(MAPDELETE_FAST64, \"runtime.mapdelete_fast64\",\n+               P3(TYPE, MAP, UINT64), R0())\n+\n+// Delete a string key from a map.\n+DEF_GO_RUNTIME(MAPDELETE_FASTSTR, \"runtime.mapdelete_faststr\",\n+               P3(TYPE, MAP, STRING), R0())\n+\n // Begin a range over a map.\n DEF_GO_RUNTIME(MAPITERINIT, \"runtime.mapiterinit\", P3(TYPE, MAP, POINTER),\n \t       R0())"}, {"sha": "8368c5b72bbe93455ef21eda80baf446be957a48", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 105, "deletions": 40, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269f05ff58289cfdd3a35f0d9afc8e229a98f50e/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269f05ff58289cfdd3a35f0d9afc8e229a98f50e/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=269f05ff58289cfdd3a35f0d9afc8e229a98f50e", "patch": "@@ -816,7 +816,7 @@ Assignment_statement::do_traverse_assignments(Traverse_assignments* tassign)\n // call.  Mark some slice assignments as not requiring a write barrier.\n \n Statement*\n-Assignment_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n+Assignment_statement::do_lower(Gogo* gogo, Named_object*, Block* enclosing,\n \t\t\t       Statement_inserter*)\n {\n   Map_index_expression* mie = this->lhs_->map_index_expression();\n@@ -864,7 +864,59 @@ Assignment_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n       Temporary_reference_expression* ref =\n \tExpression::make_temporary_reference(key_temp, loc);\n       Expression* a3 = Expression::make_unary(OPERATOR_AND, ref, loc);\n-      Expression* call = Runtime::make_call(Runtime::MAPASSIGN, loc, 3,\n+      Runtime::Function code;\n+      Map_type::Map_alg alg = mt->algorithm(gogo);\n+      switch (alg)\n+        {\n+          case Map_type::MAP_ALG_FAST32:\n+            {\n+              code = Runtime::MAPASSIGN_FAST32;\n+              Type* uint32_type = Type::lookup_integer_type(\"uint32\");\n+              Type* uint32_ptr_type = Type::make_pointer_type(uint32_type);\n+              a3 = Expression::make_unsafe_cast(uint32_ptr_type, a3,\n+                                                loc);\n+              a3 = Expression::make_dereference(a3,\n+                                                Expression::NIL_CHECK_NOT_NEEDED,\n+                                                loc);\n+              break;\n+            }\n+          case Map_type::MAP_ALG_FAST64:\n+            {\n+              code = Runtime::MAPASSIGN_FAST64;\n+              Type* uint64_type = Type::lookup_integer_type(\"uint64\");\n+              Type* uint64_ptr_type = Type::make_pointer_type(uint64_type);\n+              a3 = Expression::make_unsafe_cast(uint64_ptr_type, a3,\n+                                                loc);\n+              a3 = Expression::make_dereference(a3,\n+                                                Expression::NIL_CHECK_NOT_NEEDED,\n+                                                loc);\n+              break;\n+            }\n+          case Map_type::MAP_ALG_FAST32PTR:\n+          case Map_type::MAP_ALG_FAST64PTR:\n+            {\n+              code = (alg == Map_type::MAP_ALG_FAST32PTR\n+                      ? Runtime::MAPASSIGN_FAST32PTR\n+                      : Runtime::MAPASSIGN_FAST64PTR);\n+              Type* ptr_type =\n+                Type::make_pointer_type(Type::make_void_type());\n+              Type* ptr_ptr_type = Type::make_pointer_type(ptr_type);\n+              a3 = Expression::make_unsafe_cast(ptr_ptr_type, a3,\n+                                                loc);\n+              a3 = Expression::make_dereference(a3,\n+                                                Expression::NIL_CHECK_NOT_NEEDED,\n+                                                loc);\n+              break;\n+            }\n+          case Map_type::MAP_ALG_FASTSTR:\n+            code = Runtime::MAPASSIGN_FASTSTR;\n+            a3 = ref;\n+            break;\n+          default:\n+            code = Runtime::MAPASSIGN;\n+            break;\n+        }\n+      Expression* call = Runtime::make_call(code, loc, 3,\n \t\t\t\t\t    a1, a2, a3);\n       Type* ptrval_type = Type::make_pointer_type(mt->val_type());\n       call = Expression::make_cast(ptrval_type, call, loc);\n@@ -1451,7 +1503,47 @@ Tuple_map_assignment_statement::do_lower(Gogo* gogo, Named_object*,\n   Expression* a4 = map_type->fat_zero_value(gogo);\n   Call_expression* call;\n   if (a4 == NULL)\n-    call = Runtime::make_call(Runtime::MAPACCESS2, loc, 3, a1, a2, a3);\n+    {\n+      Runtime::Function code;\n+      Map_type::Map_alg alg = map_type->algorithm(gogo);\n+      switch (alg)\n+        {\n+          case Map_type::MAP_ALG_FAST32:\n+          case Map_type::MAP_ALG_FAST32PTR:\n+            {\n+              code = Runtime::MAPACCESS2_FAST32;\n+              Type* uint32_type = Type::lookup_integer_type(\"uint32\");\n+              Type* uint32_ptr_type = Type::make_pointer_type(uint32_type);\n+              a3 = Expression::make_unsafe_cast(uint32_ptr_type, a3,\n+                                                loc);\n+              a3 = Expression::make_dereference(a3,\n+                                                Expression::NIL_CHECK_NOT_NEEDED,\n+                                                loc);\n+              break;\n+            }\n+          case Map_type::MAP_ALG_FAST64:\n+          case Map_type::MAP_ALG_FAST64PTR:\n+            {\n+              code = Runtime::MAPACCESS2_FAST64;\n+              Type* uint64_type = Type::lookup_integer_type(\"uint64\");\n+              Type* uint64_ptr_type = Type::make_pointer_type(uint64_type);\n+              a3 = Expression::make_unsafe_cast(uint64_ptr_type, a3,\n+                                                loc);\n+              a3 = Expression::make_dereference(a3,\n+                                                Expression::NIL_CHECK_NOT_NEEDED,\n+                                                loc);\n+              break;\n+            }\n+          case Map_type::MAP_ALG_FASTSTR:\n+            code = Runtime::MAPACCESS2_FASTSTR;\n+            a3 = ref;\n+            break;\n+          default:\n+            code = Runtime::MAPACCESS2;\n+            break;\n+        }\n+      call = Runtime::make_call(code, loc, 3, a1, a2, a3);\n+    }\n   else\n     call = Runtime::make_call(Runtime::MAPACCESS2_FAT, loc, 4, a1, a2, a3, a4);\n   ref = Expression::make_temporary_reference(val_ptr_temp, loc);\n@@ -6325,47 +6417,20 @@ For_range_statement::lower_map_range_clear(Type* map_type,\n   if (enclosing->bindings()->lookup_local(index_no->name()) != index_no)\n     return NULL;\n \n-  // Match the body.  When lowering the builtin delete function, we have\n-  // inserted temporaries, so we actually match for\n-  //\n-  //   tmp1 = m\n-  //   tmp2 = k\n-  //   runtime.mapdelete(TYPE, tmp1, &tmp2)\n-\n+  // Match the body, a single call statement delete(m, k).\n   const std::vector<Statement*>* statements = this->statements_->statements();\n-  if (statements->size() != 3)\n-    return NULL;\n-\n-  Temporary_statement* ts1 = statements->at(0)->temporary_statement();\n-  Temporary_statement* ts2 = statements->at(1)->temporary_statement();\n-  Expression_statement* es3 = statements->at(2)->expression_statement();\n-  if (ts1 == NULL || ts2 == NULL || es3 == NULL\n-      || !Expression::is_same_variable(orig_range_expr, ts1->init())\n-      || !Expression::is_same_variable(this->index_var_, ts2->init()))\n-    return NULL;\n-  Call_expression* call = es3->expr()->call_expression();\n-  if (call == NULL)\n-    return NULL;\n-  Func_expression* fe = call->fn()->func_expression();\n-  if (fe == NULL || !fe->is_runtime_function()\n-      || fe->runtime_code() != Runtime::MAPDELETE)\n+  if (statements->size() != 1)\n     return NULL;\n-  Expression* a1 = call->args()->at(1);\n-  a1 = (a1->unsafe_conversion_expression() != NULL\n-        ? a1->unsafe_conversion_expression()->expr()\n-        : a1);\n-  Temporary_reference_expression* tre = a1->temporary_reference_expression();\n-  if (tre == NULL || tre->statement() != ts1)\n+  Expression_statement* es = statements->at(0)->expression_statement();\n+  if (es == NULL)\n     return NULL;\n-  Expression* a2 = call->args()->at(2);\n-  a2 = (a2->conversion_expression() != NULL\n-        ? a2->conversion_expression()->expr()\n-        : a2);\n-  Unary_expression* ue = a2->unary_expression();\n-  if (ue == NULL || ue->op() != OPERATOR_AND)\n+  Call_expression* call = es->expr()->call_expression();\n+  if (call == NULL || !call->is_builtin()\n+      || call->builtin_call_expression()->code()\n+         != Builtin_call_expression::BUILTIN_DELETE)\n     return NULL;\n-  tre = ue->operand()->temporary_reference_expression();\n-  if (tre == NULL || tre->statement() != ts2)\n+  if (!Expression::is_same_variable(call->args()->at(0), orig_range_expr)\n+      || !Expression::is_same_variable(call->args()->at(1), this->index_var_))\n     return NULL;\n \n   // Everything matches. Rewrite to mapclear(TYPE, MAP)."}, {"sha": "cc65bd8d749e905239dd3f337889b620e0a29eba", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269f05ff58289cfdd3a35f0d9afc8e229a98f50e/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269f05ff58289cfdd3a35f0d9afc8e229a98f50e/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=269f05ff58289cfdd3a35f0d9afc8e229a98f50e", "patch": "@@ -7890,7 +7890,7 @@ int64_t Map_type::zero_value_align;\n // pass as the zero value to those functions.  Otherwise, in the\n // normal case, return NULL.  The map requires the \"fat\" functions if\n // the value size is larger than max_zero_size bytes.  max_zero_size\n-// must match maxZero in libgo/go/runtime/hashmap.go.\n+// must match maxZero in libgo/go/runtime/map.go.\n \n Expression*\n Map_type::fat_zero_value(Gogo* gogo)\n@@ -7938,6 +7938,43 @@ Map_type::fat_zero_value(Gogo* gogo)\n   return z;\n }\n \n+// Map algorithm to use for this map type.\n+\n+Map_type::Map_alg\n+Map_type::algorithm(Gogo* gogo)\n+{\n+  int64_t size;\n+  bool ok = this->val_type_->backend_type_size(gogo, &size);\n+  if (!ok || size > Map_type::max_val_size)\n+    return MAP_ALG_SLOW;\n+\n+  Type* key_type = this->key_type_;\n+  if (key_type->is_string_type())\n+    return MAP_ALG_FASTSTR;\n+  if (!key_type->compare_is_identity(gogo))\n+    return MAP_ALG_SLOW;\n+\n+  ok = key_type->backend_type_size(gogo, &size);\n+  if (!ok)\n+    return MAP_ALG_SLOW;\n+  if (size == 4)\n+    return (key_type->has_pointer()\n+            ? MAP_ALG_FAST32PTR\n+            : MAP_ALG_FAST32);\n+  if (size == 8)\n+    {\n+      if (!key_type->has_pointer())\n+        return MAP_ALG_FAST64;\n+      Type* ptr_type = Type::make_pointer_type(Type::make_void_type());\n+      ok = ptr_type->backend_type_size(gogo, &size);\n+      if (ok && size == 8)\n+        return MAP_ALG_FAST64PTR;\n+      // Key contains pointer but is not a single pointer.\n+      // Use slow version.\n+    }\n+  return MAP_ALG_SLOW;\n+}\n+\n // Return whether VAR is the map zero value.\n \n bool\n@@ -8027,7 +8064,7 @@ Map_type::do_hash_for_method(Gogo* gogo, int flags) const\n \n // Get the backend representation for a map type.  A map type is\n // represented as a pointer to a struct.  The struct is hmap in\n-// runtime/hashmap.go.\n+// runtime/map.go.\n \n Btype*\n Map_type::do_get_backend(Gogo* gogo)\n@@ -8233,7 +8270,7 @@ Map_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n }\n \n // Return the bucket type to use for a map type.  This must correspond\n-// to libgo/go/runtime/hashmap.go.\n+// to libgo/go/runtime/map.go.\n \n Type*\n Map_type::bucket_type(Gogo* gogo, int64_t keysize, int64_t valsize)\n@@ -8265,7 +8302,7 @@ Map_type::bucket_type(Gogo* gogo, int64_t keysize, int64_t valsize)\n   // be marked as having no pointers.  Arrange for the bucket to have\n   // no pointers by changing the type of the overflow field to uintptr\n   // in this case.  See comment on the hmap.overflow field in\n-  // libgo/go/runtime/hashmap.go.\n+  // libgo/go/runtime/map.go.\n   Type* overflow_type;\n   if (!key_type->has_pointer() && !val_type->has_pointer())\n     overflow_type = Type::lookup_integer_type(\"uintptr\");"}, {"sha": "375f7112742ea1047e0b29c030b8cf52de1b77bb", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269f05ff58289cfdd3a35f0d9afc8e229a98f50e/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269f05ff58289cfdd3a35f0d9afc8e229a98f50e/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=269f05ff58289cfdd3a35f0d9afc8e229a98f50e", "patch": "@@ -2912,6 +2912,27 @@ class Map_type : public Type\n   Expression*\n   fat_zero_value(Gogo*);\n \n+  // Map algorithm to use for this map type.  We may use specialized\n+  // fast map routines for certain key types.\n+  enum Map_alg\n+    {\n+      // 32-bit key.\n+      MAP_ALG_FAST32,\n+      // 32-bit pointer key.\n+      MAP_ALG_FAST32PTR,\n+      // 64-bit key.\n+      MAP_ALG_FAST64,\n+      // 64-bit pointer key.\n+      MAP_ALG_FAST64PTR,\n+      // String key.\n+      MAP_ALG_FASTSTR,\n+      // Anything else.\n+      MAP_ALG_SLOW,\n+    };\n+\n+  Map_alg\n+  algorithm(Gogo*);\n+\n   // Return whether VAR is the map zero value.\n   static bool\n   is_zero_value(Variable* var);\n@@ -2931,7 +2952,7 @@ class Map_type : public Type\n   static Type*\n   make_map_type_descriptor_type();\n \n-  // This must be in  sync with libgo/go/runtime/hashmap.go.\n+  // This must be in  sync with libgo/go/runtime/map.go.\n   static const int bucket_size = 8;\n \n  protected:\n@@ -2974,7 +2995,7 @@ class Map_type : public Type\n   do_export(Export*) const;\n \n  private:\n-  // These must be in sync with libgo/go/runtime/hashmap.go.\n+  // These must be in sync with libgo/go/runtime/map.go.\n   static const int max_key_size = 128;\n   static const int max_val_size = 128;\n   static const int max_zero_size = 1024;"}, {"sha": "07a35e18fc6d867bbe3c77f285ad4758185e279c", "filename": "libgo/go/runtime/map_fast32.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269f05ff58289cfdd3a35f0d9afc8e229a98f50e/libgo%2Fgo%2Fruntime%2Fmap_fast32.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269f05ff58289cfdd3a35f0d9afc8e229a98f50e/libgo%2Fgo%2Fruntime%2Fmap_fast32.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmap_fast32.go?ref=269f05ff58289cfdd3a35f0d9afc8e229a98f50e", "patch": "@@ -9,6 +9,15 @@ import (\n \t\"unsafe\"\n )\n \n+// For gccgo, use go:linkname to rename compiler-called functions to\n+// themselves, so that the compiler will export them.\n+//\n+//go:linkname mapaccess1_fast32 runtime.mapaccess1_fast32\n+//go:linkname mapaccess2_fast32 runtime.mapaccess2_fast32\n+//go:linkname mapassign_fast32 runtime.mapassign_fast32\n+//go:linkname mapassign_fast32ptr runtime.mapassign_fast32ptr\n+//go:linkname mapdelete_fast32 runtime.mapdelete_fast32\n+\n func mapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer {\n \tif raceenabled && h != nil {\n \t\tcallerpc := getcallerpc()"}, {"sha": "d21bf06634352306bf3747d7342e083e2b45b0dc", "filename": "libgo/go/runtime/map_fast64.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269f05ff58289cfdd3a35f0d9afc8e229a98f50e/libgo%2Fgo%2Fruntime%2Fmap_fast64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269f05ff58289cfdd3a35f0d9afc8e229a98f50e/libgo%2Fgo%2Fruntime%2Fmap_fast64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmap_fast64.go?ref=269f05ff58289cfdd3a35f0d9afc8e229a98f50e", "patch": "@@ -9,6 +9,15 @@ import (\n \t\"unsafe\"\n )\n \n+// For gccgo, use go:linkname to rename compiler-called functions to\n+// themselves, so that the compiler will export them.\n+//\n+//go:linkname mapaccess1_fast64 runtime.mapaccess1_fast64\n+//go:linkname mapaccess2_fast64 runtime.mapaccess2_fast64\n+//go:linkname mapassign_fast64 runtime.mapassign_fast64\n+//go:linkname mapassign_fast64ptr runtime.mapassign_fast64ptr\n+//go:linkname mapdelete_fast64 runtime.mapdelete_fast64\n+\n func mapaccess1_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer {\n \tif raceenabled && h != nil {\n \t\tcallerpc := getcallerpc()"}, {"sha": "083980fac4543a0af8aec8a649bac7e6357280e7", "filename": "libgo/go/runtime/map_faststr.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269f05ff58289cfdd3a35f0d9afc8e229a98f50e/libgo%2Fgo%2Fruntime%2Fmap_faststr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269f05ff58289cfdd3a35f0d9afc8e229a98f50e/libgo%2Fgo%2Fruntime%2Fmap_faststr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmap_faststr.go?ref=269f05ff58289cfdd3a35f0d9afc8e229a98f50e", "patch": "@@ -9,6 +9,14 @@ import (\n \t\"unsafe\"\n )\n \n+// For gccgo, use go:linkname to rename compiler-called functions to\n+// themselves, so that the compiler will export them.\n+//\n+//go:linkname mapaccess1_faststr runtime.mapaccess1_faststr\n+//go:linkname mapaccess2_faststr runtime.mapaccess2_faststr\n+//go:linkname mapassign_faststr runtime.mapassign_faststr\n+//go:linkname mapdelete_faststr runtime.mapdelete_faststr\n+\n func mapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer {\n \tif raceenabled && h != nil {\n \t\tcallerpc := getcallerpc()"}]}