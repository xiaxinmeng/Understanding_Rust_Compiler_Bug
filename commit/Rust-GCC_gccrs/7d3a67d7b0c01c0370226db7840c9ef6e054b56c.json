{"sha": "7d3a67d7b0c01c0370226db7840c9ef6e054b56c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2QzYTY3ZDdiMGMwMWMwMzcwMjI2ZGI3ODQwYzllZjZlMDU0YjU2Yw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2018-11-07T14:12:20Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-11-07T14:12:20Z"}, "message": "ipa-devirt.c (odr_types_equivalent_p): Expect constants than const decls in TREE_VALUE of enum.\n\n\n\t* ipa-devirt.c (odr_types_equivalent_p): Expect constants\n\tthan const decls in TREE_VALUE of enum.\n\t(dump_type_inheritance_graph): Improve duplicate dumping.\n\t(free_enum_values): New.\n\t(build_type_inheritance_graph): Use it.\n\t* tree.c (free_lang_data_in_type): Free TYPE_VALUES of enums\n\twhich are not main variants or not ODR types.\n\t(verify_type_variant): Expect variants to have no TYPE_VALUES.\n\nFrom-SVN: r265875", "tree": {"sha": "675a9609516280881e63e2682b1801765bd6fe6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/675a9609516280881e63e2682b1801765bd6fe6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d3a67d7b0c01c0370226db7840c9ef6e054b56c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d3a67d7b0c01c0370226db7840c9ef6e054b56c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d3a67d7b0c01c0370226db7840c9ef6e054b56c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d3a67d7b0c01c0370226db7840c9ef6e054b56c/comments", "author": null, "committer": null, "parents": [{"sha": "667b3ec15d86a3d9c22a7469c4353cd9432b4c76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/667b3ec15d86a3d9c22a7469c4353cd9432b4c76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/667b3ec15d86a3d9c22a7469c4353cd9432b4c76"}], "stats": {"total": 113, "additions": 93, "deletions": 20}, "files": [{"sha": "c893ee253bfd35aff9502eef21141d8888ba6afd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d3a67d7b0c01c0370226db7840c9ef6e054b56c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d3a67d7b0c01c0370226db7840c9ef6e054b56c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d3a67d7b0c01c0370226db7840c9ef6e054b56c", "patch": "@@ -1,3 +1,14 @@\n+2018-11-07  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-devirt.c (odr_types_equivalent_p): Expect constants\n+\tthan const decls in TREE_VALUE of enum.\n+\t(dump_type_inheritance_graph): Improve duplicate dumping.\n+\t(free_enum_values): New.\n+\t(build_type_inheritance_graph): Use it.\n+\t* tree.c (free_lang_data_in_type): Free TYPE_VALUES of enums\n+\twhich are not main variants or not ODR types.\n+\t(verify_type_variant): Expect variants to have no TYPE_VALUES.\n+\n 2018-11-07  Richard Biener  <rguenther@suse.de>\n \n \t* ipa-inline.c (want_inline_small_function_p): Compute"}, {"sha": "4676bdbdf93806a30cb28472fe050df312a5373d", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 66, "deletions": 19, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d3a67d7b0c01c0370226db7840c9ef6e054b56c/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d3a67d7b0c01c0370226db7840c9ef6e054b56c/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=7d3a67d7b0c01c0370226db7840c9ef6e054b56c", "patch": "@@ -1328,9 +1328,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t\t\t   \" is defined in another translation unit\"));\n \t      return false;\n \t    }\n-\t  if (TREE_VALUE (v1) != TREE_VALUE (v2)\n-\t      && !operand_equal_p (DECL_INITIAL (TREE_VALUE (v1)),\n-\t\t\t\t   DECL_INITIAL (TREE_VALUE (v2)), 0))\n+\t  if (TREE_VALUE (v1) != TREE_VALUE (v2))\n \t    {\n \t      warn_odr (t1, t2, NULL, NULL, warn, warned,\n \t\t\tG_(\"an enum with different values is defined\"\n@@ -2191,6 +2189,7 @@ static void\n dump_type_inheritance_graph (FILE *f)\n {\n   unsigned int i;\n+  unsigned int num_all_types = 0, num_types = 0, num_duplicates = 0;\n   if (!odr_types_ptr)\n     return;\n   fprintf (f, \"\\n\\nType inheritance graph:\\n\");\n@@ -2201,26 +2200,70 @@ dump_type_inheritance_graph (FILE *f)\n     }\n   for (i = 0; i < odr_types.length (); i++)\n     {\n-      if (odr_types[i] && odr_types[i]->types && odr_types[i]->types->length ())\n+      if (!odr_types[i])\n+\tcontinue;\n+\n+      num_all_types++;\n+      if (!odr_types[i]->types || !odr_types[i]->types->length ())\n+\tcontinue;\n+\n+      /* To aid ODR warnings we also mangle integer constants but do\n+\t not consinder duplicates there.  */\n+      if (TREE_CODE (odr_types[i]->type) == INTEGER_TYPE)\n+\tcontinue;\n+\n+      /* It is normal to have one duplicate and one normal variant.  */\n+      if (odr_types[i]->types->length () == 1\n+\t  && COMPLETE_TYPE_P (odr_types[i]->type)\n+\t  && !COMPLETE_TYPE_P ((*odr_types[i]->types)[0]))\n+\tcontinue;\n+\n+      num_types ++;\n+\n+      unsigned int j;\n+      fprintf (f, \"Duplicate tree types for odr type %i\\n\", i);\n+      print_node (f, \"\", odr_types[i]->type, 0);\n+      print_node (f, \"\", TYPE_NAME (odr_types[i]->type), 0);\n+      putc ('\\n',f);\n+      for (j = 0; j < odr_types[i]->types->length (); j++)\n \t{\n-\t  unsigned int j;\n-\t  fprintf (f, \"Duplicate tree types for odr type %i\\n\", i);\n-\t  print_node (f, \"\", odr_types[i]->type, 0);\n-\t  for (j = 0; j < odr_types[i]->types->length (); j++)\n+\t  tree t;\n+\t  num_duplicates ++;\n+\t  fprintf (f, \"duplicate #%i\\n\", j);\n+\t  print_node (f, \"\", (*odr_types[i]->types)[j], 0);\n+\t  t = (*odr_types[i]->types)[j];\n+\t  while (TYPE_P (t) && TYPE_CONTEXT (t))\n \t    {\n-\t      tree t;\n-\t      fprintf (f, \"duplicate #%i\\n\", j);\n-\t      print_node (f, \"\", (*odr_types[i]->types)[j], 0);\n-\t      t = (*odr_types[i]->types)[j];\n-\t      while (TYPE_P (t) && TYPE_CONTEXT (t))\n-\t\t{\n-\t\t  t = TYPE_CONTEXT (t);\n-\t          print_node (f, \"\", t, 0);\n-\t\t}\n-\t      putc ('\\n',f);\n+\t      t = TYPE_CONTEXT (t);\n+\t      print_node (f, \"\", t, 0);\n \t    }\n+\t  print_node (f, \"\", TYPE_NAME ((*odr_types[i]->types)[j]), 0);\n+\t  putc ('\\n',f);\n \t}\n     }\n+  fprintf (f, \"Out of %i types there are %i types with duplicates; \"\n+\t   \"%i duplicates overall\\n\", num_all_types, num_types, num_duplicates);\n+}\n+\n+/* Save some WPA->ltrans streaming by freeing enum values.  */\n+\n+static void\n+free_enum_values ()\n+{\n+  static bool enum_values_freed = false;\n+  if (enum_values_freed || !flag_wpa || !odr_types_ptr)\n+    return;\n+  enum_values_freed = true;\n+  unsigned int i;\n+  for (i = 0; i < odr_types.length (); i++)\n+    if (odr_types[i] && TREE_CODE (odr_types[i]->type) == ENUMERAL_TYPE)\n+      {\n+\tTYPE_VALUES (odr_types[i]->type) = NULL;\n+\tif (odr_types[i]->types)\n+          for (unsigned int j = 0; j < odr_types[i]->types->length (); j++)\n+\t    TYPE_VALUES ((*odr_types[i]->types)[j]) = NULL;\n+      }\n+  enum_values_freed = true;\n }\n \n /* Initialize IPA devirt and build inheritance tree graph.  */\n@@ -2233,7 +2276,10 @@ build_type_inheritance_graph (void)\n   dump_flags_t flags;\n \n   if (odr_hash)\n-    return;\n+    {\n+      free_enum_values ();\n+      return;\n+    }\n   timevar_push (TV_IPA_INHERITANCE);\n   inheritance_dump_file = dump_begin (TDI_inheritance, &flags);\n   odr_hash = new odr_hash_type (23);\n@@ -2278,6 +2324,7 @@ build_type_inheritance_graph (void)\n       dump_type_inheritance_graph (inheritance_dump_file);\n       dump_end (TDI_inheritance, inheritance_dump_file);\n     }\n+  free_enum_values ();\n   timevar_pop (TV_IPA_INHERITANCE);\n }\n "}, {"sha": "11c05359d9e84a511dfb2cd9d12d0902ad0d7f1b", "filename": "gcc/tree.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d3a67d7b0c01c0370226db7840c9ef6e054b56c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d3a67d7b0c01c0370226db7840c9ef6e054b56c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=7d3a67d7b0c01c0370226db7840c9ef6e054b56c", "patch": "@@ -5345,6 +5345,20 @@ free_lang_data_in_type (tree type, struct free_lang_data_d *fld)\n \t   || SCALAR_FLOAT_TYPE_P (type)\n \t   || FIXED_POINT_TYPE_P (type))\n     {\n+      if (TREE_CODE (type) == ENUMERAL_TYPE)\n+\t{\n+\t  /* Type values are used only for C++ ODR checking.  Drop them\n+\t     for all type variants and non-ODR types.  */\n+\t  if (TYPE_MAIN_VARIANT (type) != type\n+\t      || !type_with_linkage_p (type))\n+\t    TYPE_VALUES (type) = NULL;\n+\t  else\n+\t  /* Simplify representation by recording only values rather\n+\t     than const decls.  */\n+\t    for (tree e = TYPE_VALUES (type); e; e = TREE_CHAIN (e))\n+\t      if (TREE_CODE (TREE_VALUE (e)) == CONST_DECL)\n+\t\tTREE_VALUE (e) = DECL_INITIAL (TREE_VALUE (e));\n+\t}\n       free_lang_data_in_one_sizepos (&TYPE_MIN_VALUE (type));\n       free_lang_data_in_one_sizepos (&TYPE_MAX_VALUE (type));\n     }\n@@ -13525,7 +13539,8 @@ verify_type_variant (const_tree t, tree tv)\n     }\n \n   /* Check various uses of TYPE_VALUES_RAW.  */\n-  if (TREE_CODE (t) == ENUMERAL_TYPE)\n+  if (TREE_CODE (t) == ENUMERAL_TYPE\n+      && TYPE_VALUES (t))\n     verify_variant_match (TYPE_VALUES);\n   else if (TREE_CODE (t) == ARRAY_TYPE)\n     verify_variant_match (TYPE_DOMAIN);"}]}