{"sha": "a918bfbf3c5b686362f3f97314c2b4bf142d2f82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTkxOGJmYmYzYzViNjg2MzYyZjNmOTczMTRjMmI0YmYxNDJkMmY4Mg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2016-10-14T12:08:27Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2016-10-14T12:08:27Z"}, "message": "Fold __builtin_str{n}{case}cmp functions\n\n\t* builtins.c (fold_builtin_strcmp): Remove function.\n\t(fold_builtin_strncmp): Likewise.\n\t(fold_builtin_2): Remove call of the function.\n\t(fold_builtin_3): Likewise.\n\t* fold-const-call.c (fold_const_call): Add constant folding\n\tfor CFN_BUILT_IN_STRCASECMP and CFN_BUILT_IN_STRNCASECMP.\n\t* fold-const-call.h (build_cmp_result): Declare the function.\n\t* gimple-fold.c (gimple_load_first_char): New function.\n\t(gimple_fold_builtin_string_compare): Likewise.\n\t(gimple_fold_builtin): Call the function.\n\nFrom-SVN: r241159", "tree": {"sha": "c896ce6d1d5d5cec3b0369bdda9ddacf3ad4f63f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c896ce6d1d5d5cec3b0369bdda9ddacf3ad4f63f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a918bfbf3c5b686362f3f97314c2b4bf142d2f82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a918bfbf3c5b686362f3f97314c2b4bf142d2f82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a918bfbf3c5b686362f3f97314c2b4bf142d2f82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a918bfbf3c5b686362f3f97314c2b4bf142d2f82/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ace4c2f060160bd3ef9032cc151e36b84e4ba3e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ace4c2f060160bd3ef9032cc151e36b84e4ba3e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ace4c2f060160bd3ef9032cc151e36b84e4ba3e8"}], "stats": {"total": 386, "additions": 239, "deletions": 147}, "files": [{"sha": "ed51c32fc3aaca1de8abfa687a58e7574d0c2739", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a918bfbf3c5b686362f3f97314c2b4bf142d2f82/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a918bfbf3c5b686362f3f97314c2b4bf142d2f82/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a918bfbf3c5b686362f3f97314c2b4bf142d2f82", "patch": "@@ -1,3 +1,16 @@\n+2016-10-14  Martin Liska  <mliska@suse.cz>\n+\n+\t* builtins.c (fold_builtin_strcmp): Remove function.\n+\t(fold_builtin_strncmp): Likewise.\n+\t(fold_builtin_2): Remove call of the function.\n+\t(fold_builtin_3): Likewise.\n+\t* fold-const-call.c (fold_const_call): Add constant folding\n+\tfor CFN_BUILT_IN_STRCASECMP and CFN_BUILT_IN_STRNCASECMP.\n+\t* fold-const-call.h (build_cmp_result): Declare the function.\n+\t* gimple-fold.c (gimple_load_first_char): New function.\n+\t(gimple_fold_builtin_string_compare): Likewise.\n+\t(gimple_fold_builtin): Call the function.\n+\n 2016-10-14  Nathan Sidwell  <nathan@acm.org>\n \n \t* gcov-io.c (gcov_open): Deconstify 'mode'."}, {"sha": "ed5a6359b02812b8bdf9790c171bbd06da3438f4", "filename": "gcc/builtins.c", "status": "modified", "additions": 0, "deletions": 138, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a918bfbf3c5b686362f3f97314c2b4bf142d2f82/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a918bfbf3c5b686362f3f97314c2b4bf142d2f82/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=a918bfbf3c5b686362f3f97314c2b4bf142d2f82", "patch": "@@ -150,8 +150,6 @@ static rtx expand_builtin_fabs (tree, rtx, rtx);\n static rtx expand_builtin_signbit (tree, rtx);\n static tree fold_builtin_memchr (location_t, tree, tree, tree, tree);\n static tree fold_builtin_memcmp (location_t, tree, tree, tree);\n-static tree fold_builtin_strcmp (location_t, tree, tree);\n-static tree fold_builtin_strncmp (location_t, tree, tree, tree);\n static tree fold_builtin_isascii (location_t, tree);\n static tree fold_builtin_toascii (location_t, tree);\n static tree fold_builtin_isdigit (location_t, tree);\n@@ -7331,136 +7329,6 @@ fold_builtin_memcmp (location_t loc, tree arg1, tree arg2, tree len)\n   return NULL_TREE;\n }\n \n-/* Fold function call to builtin strcmp with arguments ARG1 and ARG2.\n-   Return NULL_TREE if no simplification can be made.  */\n-\n-static tree\n-fold_builtin_strcmp (location_t loc, tree arg1, tree arg2)\n-{\n-  if (!validate_arg (arg1, POINTER_TYPE)\n-      || !validate_arg (arg2, POINTER_TYPE))\n-    return NULL_TREE;\n-\n-  /* If ARG1 and ARG2 are the same (and not volatile), return zero.  */\n-  if (operand_equal_p (arg1, arg2, 0))\n-    return integer_zero_node;\n-\n-  /* If the second arg is \"\", return *(const unsigned char*)arg1.  */\n-  const char *p2 = c_getstr (arg2);\n-  if (p2 && *p2 == '\\0')\n-    {\n-      tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n-      tree cst_uchar_ptr_node\n-\t= build_pointer_type_for_mode (cst_uchar_node, ptr_mode, true);\n-\n-      return fold_convert_loc (loc, integer_type_node,\n-\t\t\t       build1 (INDIRECT_REF, cst_uchar_node,\n-\t\t\t\t       fold_convert_loc (loc,\n-\t\t\t\t\t\t\t cst_uchar_ptr_node,\n-\t\t\t\t\t\t\t arg1)));\n-    }\n-\n-  /* If the first arg is \"\", return -*(const unsigned char*)arg2.  */\n-  const char *p1 = c_getstr (arg1);\n-  if (p1 && *p1 == '\\0')\n-    {\n-      tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n-      tree cst_uchar_ptr_node\n-\t= build_pointer_type_for_mode (cst_uchar_node, ptr_mode, true);\n-\n-      tree temp\n-\t= fold_convert_loc (loc, integer_type_node,\n-\t\t\t    build1 (INDIRECT_REF, cst_uchar_node,\n-\t\t\t\t    fold_convert_loc (loc,\n-\t\t\t\t\t\t      cst_uchar_ptr_node,\n-\t\t\t\t\t\t      arg2)));\n-      return fold_build1_loc (loc, NEGATE_EXPR, integer_type_node, temp);\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Fold function call to builtin strncmp with arguments ARG1, ARG2, and LEN.\n-   Return NULL_TREE if no simplification can be made.  */\n-\n-static tree\n-fold_builtin_strncmp (location_t loc, tree arg1, tree arg2, tree len)\n-{\n-  if (!validate_arg (arg1, POINTER_TYPE)\n-      || !validate_arg (arg2, POINTER_TYPE)\n-      || !validate_arg (len, INTEGER_TYPE))\n-    return NULL_TREE;\n-\n-  /* If the LEN parameter is zero, return zero.  */\n-  if (integer_zerop (len))\n-    return omit_two_operands_loc (loc, integer_type_node, integer_zero_node,\n-\t\t\t      arg1, arg2);\n-\n-  /* If ARG1 and ARG2 are the same (and not volatile), return zero.  */\n-  if (operand_equal_p (arg1, arg2, 0))\n-    return omit_one_operand_loc (loc, integer_type_node, integer_zero_node, len);\n-\n-  /* If the second arg is \"\", and the length is greater than zero,\n-     return *(const unsigned char*)arg1.  */\n-  const char *p2 = c_getstr (arg2);\n-  if (p2 && *p2 == '\\0'\n-      && TREE_CODE (len) == INTEGER_CST\n-      && tree_int_cst_sgn (len) == 1)\n-    {\n-      tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n-      tree cst_uchar_ptr_node\n-\t= build_pointer_type_for_mode (cst_uchar_node, ptr_mode, true);\n-\n-      return fold_convert_loc (loc, integer_type_node,\n-\t\t\t       build1 (INDIRECT_REF, cst_uchar_node,\n-\t\t\t\t       fold_convert_loc (loc,\n-\t\t\t\t\t\t\t cst_uchar_ptr_node,\n-\t\t\t\t\t\t\t arg1)));\n-    }\n-\n-  /* If the first arg is \"\", and the length is greater than zero,\n-     return -*(const unsigned char*)arg2.  */\n-  const char *p1 = c_getstr (arg1);\n-  if (p1 && *p1 == '\\0'\n-      && TREE_CODE (len) == INTEGER_CST\n-      && tree_int_cst_sgn (len) == 1)\n-    {\n-      tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n-      tree cst_uchar_ptr_node\n-\t= build_pointer_type_for_mode (cst_uchar_node, ptr_mode, true);\n-\n-      tree temp = fold_convert_loc (loc, integer_type_node,\n-\t\t\t\t    build1 (INDIRECT_REF, cst_uchar_node,\n-\t\t\t\t\t    fold_convert_loc (loc,\n-\t\t\t\t\t\t\t      cst_uchar_ptr_node,\n-\t\t\t\t\t\t\t      arg2)));\n-      return fold_build1_loc (loc, NEGATE_EXPR, integer_type_node, temp);\n-    }\n-\n-  /* If len parameter is one, return an expression corresponding to\n-     (*(const unsigned char*)arg1 - (const unsigned char*)arg2).  */\n-  if (tree_fits_uhwi_p (len) && tree_to_uhwi (len) == 1)\n-    {\n-      tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n-      tree cst_uchar_ptr_node\n-\t= build_pointer_type_for_mode (cst_uchar_node, ptr_mode, true);\n-\n-      tree ind1 = fold_convert_loc (loc, integer_type_node,\n-\t\t\t\t    build1 (INDIRECT_REF, cst_uchar_node,\n-\t\t\t\t\t    fold_convert_loc (loc,\n-\t\t\t\t\t\t\t      cst_uchar_ptr_node,\n-\t\t\t\t\t\t\t      arg1)));\n-      tree ind2 = fold_convert_loc (loc, integer_type_node,\n-\t\t\t\t    build1 (INDIRECT_REF, cst_uchar_node,\n-\t\t\t\t\t    fold_convert_loc (loc,\n-\t\t\t\t\t\t\t      cst_uchar_ptr_node,\n-\t\t\t\t\t\t\t      arg2)));\n-      return fold_build2_loc (loc, MINUS_EXPR, integer_type_node, ind1, ind2);\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n /* Fold a call to builtin isascii with argument ARG.  */\n \n static tree\n@@ -8389,9 +8257,6 @@ fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1)\n     case BUILT_IN_STRCSPN:\n       return fold_builtin_strcspn (loc, arg0, arg1);\n \n-    case BUILT_IN_STRCMP:\n-      return fold_builtin_strcmp (loc, arg0, arg1);\n-\n     case BUILT_IN_STRPBRK:\n       return fold_builtin_strpbrk (loc, arg0, arg1, type);\n \n@@ -8473,9 +8338,6 @@ fold_builtin_3 (location_t loc, tree fndecl,\n \treturn do_mpfr_remquo (arg0, arg1, arg2);\n     break;\n \n-    case BUILT_IN_STRNCMP:\n-      return fold_builtin_strncmp (loc, arg0, arg1, arg2);\n-\n     case BUILT_IN_MEMCHR:\n       return fold_builtin_memchr (loc, arg0, arg1, arg2, type);\n "}, {"sha": "f67b245876c6f1aa6a1a02ff698770b683e8234e", "filename": "gcc/fold-const-call.c", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a918bfbf3c5b686362f3f97314c2b4bf142d2f82/gcc%2Ffold-const-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a918bfbf3c5b686362f3f97314c2b4bf142d2f82/gcc%2Ffold-const-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const-call.c?ref=a918bfbf3c5b686362f3f97314c2b4bf142d2f82", "patch": "@@ -69,7 +69,7 @@ host_size_t_cst_p (tree t, size_t *size_out)\n    \"equal\" and > 0 means \"more\".  Canonicalize it to -1, 0 or 1 and\n    return it in type TYPE.  */\n \n-static inline tree\n+tree\n build_cmp_result (tree type, int res)\n {\n   return build_int_cst (type, res < 0 ? -1 : res > 0 ? 1 : 0);\n@@ -1397,6 +1397,15 @@ fold_const_call (combined_fn fn, tree type, tree arg0, tree arg1)\n \treturn build_cmp_result (type, strcmp (p0, p1));\n       return NULL_TREE;\n \n+    case CFN_BUILT_IN_STRCASECMP:\n+      if ((p0 = c_getstr (arg0)) && (p1 = c_getstr (arg1)))\n+\t{\n+\t  int r = strcmp (p0, p1);\n+\t  if (r == 0)\n+\t    return build_cmp_result (type, r);\n+\t}\n+      return NULL_TREE;\n+\n     default:\n       return fold_const_call_1 (fn, type, arg0, arg1);\n     }\n@@ -1464,16 +1473,36 @@ tree\n fold_const_call (combined_fn fn, tree type, tree arg0, tree arg1, tree arg2)\n {\n   const char *p0, *p1;\n-  size_t s2;\n+  size_t s2 = 0;\n   switch (fn)\n     {\n     case CFN_BUILT_IN_STRNCMP:\n-      if ((p0 = c_getstr (arg0))\n-\t  && (p1 = c_getstr (arg1))\n-\t  && host_size_t_cst_p (arg2, &s2))\n-\treturn build_int_cst (type, strncmp (p0, p1, s2));\n-      return NULL_TREE;\n-\n+      {\n+\tbool const_size_p = host_size_t_cst_p (arg2, &s2);\n+\tif (const_size_p && s2 == 0\n+\t    && !TREE_SIDE_EFFECTS (arg0)\n+\t    && !TREE_SIDE_EFFECTS (arg1))\n+\t  return build_int_cst (type, 0);\n+\telse if (const_size_p\n+\t\t && (p0 = c_getstr (arg0))\n+\t\t && (p1 = c_getstr (arg1)))\n+\t  return build_int_cst (type, strncmp (p0, p1, s2));\n+\treturn NULL_TREE;\n+      }\n+    case CFN_BUILT_IN_STRNCASECMP:\n+      {\n+\tbool const_size_p = host_size_t_cst_p (arg2, &s2);\n+\tif (const_size_p && s2 == 0\n+\t    && !TREE_SIDE_EFFECTS (arg0)\n+\t    && !TREE_SIDE_EFFECTS (arg1))\n+\t  return build_int_cst (type, 0);\n+\telse if (const_size_p\n+\t\t && (p0 = c_getstr (arg0))\n+\t\t && (p1 = c_getstr (arg1))\n+\t\t && strncmp (p0, p1, s2) == 0)\n+\t  return build_int_cst (type, 0);\n+\treturn NULL_TREE;\n+      }\n     case CFN_BUILT_IN_BCMP:\n     case CFN_BUILT_IN_MEMCMP:\n       if ((p0 = c_getstr (arg0))"}, {"sha": "7f61f2e08cbbccb9fb4040cd79be920a9572de14", "filename": "gcc/fold-const-call.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a918bfbf3c5b686362f3f97314c2b4bf142d2f82/gcc%2Ffold-const-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a918bfbf3c5b686362f3f97314c2b4bf142d2f82/gcc%2Ffold-const-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const-call.h?ref=a918bfbf3c5b686362f3f97314c2b4bf142d2f82", "patch": "@@ -24,5 +24,6 @@ tree fold_const_call (combined_fn, tree, tree);\n tree fold_const_call (combined_fn, tree, tree, tree);\n tree fold_const_call (combined_fn, tree, tree, tree, tree);\n tree fold_fma (location_t, tree, tree, tree, tree);\n+tree build_cmp_result (tree type, int res);\n \n #endif"}, {"sha": "f349472a18a3d77139d39221f4ab72cb056437f2", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 188, "deletions": 1, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a918bfbf3c5b686362f3f97314c2b4bf142d2f82/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a918bfbf3c5b686362f3f97314c2b4bf142d2f82/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=a918bfbf3c5b686362f3f97314c2b4bf142d2f82", "patch": "@@ -55,7 +55,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"omp-low.h\"\n #include \"ipa-chkp.h\"\n #include \"tree-cfg.h\"\n-\n+#include \"fold-const-call.h\"\n \n /* Return true if T is a constant and the value cast to a target char\n    can be represented by a host char.\n@@ -1786,6 +1786,188 @@ gimple_fold_builtin_strncat_chk (gimple_stmt_iterator *gsi)\n   return true;\n }\n \n+/* Build and append gimple statements to STMTS that would load a first\n+   character of a memory location identified by STR.  LOC is location\n+   of the statement.  */\n+\n+static tree\n+gimple_load_first_char (location_t loc, tree str, gimple_seq *stmts)\n+{\n+  tree var;\n+\n+  tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n+  tree cst_uchar_ptr_node\n+    = build_pointer_type_for_mode (cst_uchar_node, ptr_mode, true);\n+  tree off0 = build_int_cst (cst_uchar_ptr_node, 0);\n+\n+  tree temp = fold_build2_loc (loc, MEM_REF, cst_uchar_node, str, off0);\n+  gassign *stmt = gimple_build_assign (NULL_TREE, temp);\n+  var = create_tmp_reg_or_ssa_name (cst_uchar_node, stmt);\n+\n+  gimple_assign_set_lhs (stmt, var);\n+  gimple_seq_add_stmt_without_update (stmts, stmt);\n+\n+  return var;\n+}\n+\n+/* Fold a call to the str{n}{case}cmp builtin pointed by GSI iterator.\n+   FCODE is the name of the builtin.  */\n+\n+static bool\n+gimple_fold_builtin_string_compare (gimple_stmt_iterator *gsi)\n+{\n+  gimple *stmt = gsi_stmt (*gsi);\n+  tree callee = gimple_call_fndecl (stmt);\n+  enum built_in_function fcode = DECL_FUNCTION_CODE (callee);\n+\n+  tree type = integer_type_node;\n+  tree str1 = gimple_call_arg (stmt, 0);\n+  tree str2 = gimple_call_arg (stmt, 1);\n+  tree lhs = gimple_call_lhs (stmt);\n+  HOST_WIDE_INT length = -1;\n+\n+  /* Handle strncmp and strncasecmp functions.  */\n+  if (gimple_call_num_args (stmt) == 3)\n+    {\n+      tree len = gimple_call_arg (stmt, 2);\n+      if (tree_fits_uhwi_p (len))\n+\tlength = tree_to_uhwi (len);\n+    }\n+\n+  /* If the LEN parameter is zero, return zero.  */\n+  if (length == 0)\n+    {\n+      replace_call_with_value (gsi, integer_zero_node);\n+      return true;\n+    }\n+\n+  /* If ARG1 and ARG2 are the same (and not volatile), return zero.  */\n+  if (operand_equal_p (str1, str2, 0))\n+    {\n+      replace_call_with_value (gsi, integer_zero_node);\n+      return true;\n+    }\n+\n+  const char *p1 = c_getstr (str1);\n+  const char *p2 = c_getstr (str2);\n+\n+  /* For known strings, return an immediate value.  */\n+  if (p1 && p2)\n+    {\n+      int r = 0;\n+      bool known_result = false;\n+\n+      switch (fcode)\n+\t{\n+\tcase BUILT_IN_STRCMP:\n+\t  {\n+\t    r = strcmp (p1, p2);\n+\t    known_result = true;\n+\t    break;\n+\t  }\n+\tcase BUILT_IN_STRNCMP:\n+\t  {\n+\t    if (length == -1)\n+\t      break;\n+\t    r = strncmp (p1, p2, length);\n+\t    known_result = true;\n+\t    break;\n+\t  }\n+\t/* Only handleable situation is where the string are equal (result 0),\n+\t   which is already handled by operand_equal_p case.  */\n+\tcase BUILT_IN_STRCASECMP:\n+\t  break;\n+\tcase BUILT_IN_STRNCASECMP:\n+\t  {\n+\t    if (length == -1)\n+\t      break;\n+\t    r = strncmp (p1, p2, length);\n+\t    if (r == 0)\n+\t      known_result = true;\n+\t    break;;\n+\t  }\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      if (known_result)\n+\t{\n+\t  replace_call_with_value (gsi, build_cmp_result (type, r));\n+\t  return true;\n+\t}\n+    }\n+\n+  bool nonzero_length = length >= 1\n+    || fcode == BUILT_IN_STRCMP\n+    || fcode == BUILT_IN_STRCASECMP;\n+\n+  location_t loc = gimple_location (stmt);\n+\n+  /* If the second arg is \"\", return *(const unsigned char*)arg1.  */\n+  if (p2 && *p2 == '\\0' && nonzero_length)\n+    {\n+      gimple_seq stmts = NULL;\n+      tree var = gimple_load_first_char (loc, str1, &stmts);\n+      if (lhs)\n+\t{\n+\t  stmt = gimple_build_assign (lhs, NOP_EXPR, var);\n+\t  gimple_seq_add_stmt_without_update (&stmts, stmt);\n+\t}\n+\n+      gsi_replace_with_seq_vops (gsi, stmts);\n+      return true;\n+    }\n+\n+  /* If the first arg is \"\", return -*(const unsigned char*)arg2.  */\n+  if (p1 && *p1 == '\\0' && nonzero_length)\n+    {\n+      gimple_seq stmts = NULL;\n+      tree var = gimple_load_first_char (loc, str2, &stmts);\n+\n+      if (lhs)\n+\t{\n+\t  tree c = create_tmp_reg_or_ssa_name (integer_type_node);\n+\t  stmt = gimple_build_assign (c, NOP_EXPR, var);\n+\t  gimple_seq_add_stmt_without_update (&stmts, stmt);\n+\n+\t  stmt = gimple_build_assign (lhs, NEGATE_EXPR, c);\n+\t  gimple_seq_add_stmt_without_update (&stmts, stmt);\n+\t}\n+\n+      gsi_replace_with_seq_vops (gsi, stmts);\n+      return true;\n+    }\n+\n+  /* If len parameter is one, return an expression corresponding to\n+     (*(const unsigned char*)arg2 - *(const unsigned char*)arg1).  */\n+  if (fcode == BUILT_IN_STRNCMP && length == 1)\n+    {\n+      gimple_seq stmts = NULL;\n+      tree temp1 = gimple_load_first_char (loc, str1, &stmts);\n+      tree temp2 = gimple_load_first_char (loc, str2, &stmts);\n+\n+      if (lhs)\n+\t{\n+\t  tree c1 = create_tmp_reg_or_ssa_name (integer_type_node);\n+\t  gassign *convert1 = gimple_build_assign (c1, NOP_EXPR, temp1);\n+\t  gimple_seq_add_stmt_without_update (&stmts, convert1);\n+\n+\t  tree c2 = create_tmp_reg_or_ssa_name (integer_type_node);\n+\t  gassign *convert2 = gimple_build_assign (c2, NOP_EXPR, temp2);\n+\t  gimple_seq_add_stmt_without_update (&stmts, convert2);\n+\n+\t  stmt = gimple_build_assign (lhs, MINUS_EXPR, c1, c2);\n+\t  gimple_seq_add_stmt_without_update (&stmts, stmt);\n+\t}\n+\n+      gsi_replace_with_seq_vops (gsi, stmts);\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+\n /* Fold a call to the fputs builtin.  ARG0 and ARG1 are the arguments\n    to the call.  IGNORE is true if the value returned\n    by the builtin will be ignored.  UNLOCKED is true is true if this\n@@ -3007,6 +3189,11 @@ gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case BUILT_IN_RINDEX:\n     case BUILT_IN_STRRCHR:\n       return gimple_fold_builtin_strchr (gsi, true);\n+    case BUILT_IN_STRCMP:\n+    case BUILT_IN_STRCASECMP:\n+    case BUILT_IN_STRNCMP:\n+    case BUILT_IN_STRNCASECMP:\n+      return gimple_fold_builtin_string_compare (gsi);\n     case BUILT_IN_FPUTS:\n       return gimple_fold_builtin_fputs (gsi, gimple_call_arg (stmt, 0),\n \t\t\t\t\tgimple_call_arg (stmt, 1), false);"}]}