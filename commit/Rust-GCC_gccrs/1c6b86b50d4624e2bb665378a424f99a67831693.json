{"sha": "1c6b86b50d4624e2bb665378a424f99a67831693", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWM2Yjg2YjUwZDQ2MjRlMmJiNjY1Mzc4YTQyNGY5OWE2NzgzMTY5Mw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-11T16:26:27Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-11T16:28:19Z"}, "message": "c++: module test harness\n\nHere is the module test harness -- but no tests.\n\n\tgcc/testsuite/\n\t* g++.dg/modules/modules.exp: New.", "tree": {"sha": "75795d26e1965bb18dfa67e707e2938edef6687c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75795d26e1965bb18dfa67e707e2938edef6687c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c6b86b50d4624e2bb665378a424f99a67831693", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c6b86b50d4624e2bb665378a424f99a67831693", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c6b86b50d4624e2bb665378a424f99a67831693", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c6b86b50d4624e2bb665378a424f99a67831693/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "059da609fa8b3a08d1d6618f9d90dc3cfbcd05bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/059da609fa8b3a08d1d6618f9d90dc3cfbcd05bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/059da609fa8b3a08d1d6618f9d90dc3cfbcd05bc"}], "stats": {"total": 376, "additions": 376, "deletions": 0}, "files": [{"sha": "e2fd2a7fdd0409f655109631d9350b7eb2c9c92f", "filename": "gcc/testsuite/g++.dg/modules/modules.exp", "status": "added", "additions": 376, "deletions": 0, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6b86b50d4624e2bb665378a424f99a67831693/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fmodules.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6b86b50d4624e2bb665378a424f99a67831693/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fmodules.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fmodules.exp?ref=1c6b86b50d4624e2bb665378a424f99a67831693", "patch": "@@ -0,0 +1,376 @@\n+# Copyright (C) 2017, 2018 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+#\n+# Contributed by Nathan Sidwell <nathan@acm.org> while at Facebook\n+\n+\n+# Test C++ modules, which requires multiple TUs\n+#\n+# A test case might consist of multiple source files, each is compiled\n+# separately, in a well-defined order.  The resulting object files might\n+# be optionally linked and optionally executed.  Grouping is indicated by\n+# naming files '*_[a-z].[CH]'\n+\n+# { dg-module-cmi \"[!]module-name\" } # an interface file is (not) expected\n+# { dg-module-do [link|run] [xfail] [options] } # link [and run]\n+\n+load_lib g++-dg.exp\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CXXFLAGS\n+if ![info exists DEFAULT_CXXFLAGS] then {\n+    set DEFAULT_CXXFLAGS \" -pedantic-errors -Wno-long-long\"\n+}\n+set DEFAULT_MODFLAGS $DEFAULT_CXXFLAGS\n+set MOD_STD_LIST { 17 2a }\n+\n+setenv CXX_MODULE_PATH \"$srcdir/$subdir\"\n+dg-init\n+\n+global module_do\n+global module_cmis\n+global module_headers\n+\n+set DEFAULT_REPO \"gcm.cache\"\n+\n+# Register the module name this produces.\n+# dg-module-cmi !?=?NAME WHEN?\n+# dg-module-cmi !?{} - header unit\n+proc dg-module-cmi { args } {\n+    if { [llength $args] > 3 } {\n+\terror \"[lindex $args 0]: too many arguments\"\n+\treturn\n+    }\n+    set spec [lindex $args 1]\n+    if { [llength $args] > 2 } {\n+\tset when [lindex $args 2]\n+    } else {\n+\tset when {}\n+    }\n+\n+    if { [string index $spec 0] == \"!\" } {\n+\tset name [string range $spec 1 end]\n+\tset not 1\n+    } else {\n+\tset name $spec\n+\tset not 0\n+    }\n+\n+    if { [string index $name 0] == \"=\" } {\n+\tset cmi [string range $name 1 end]\n+    } else {\n+\tif { $name == \"\" } {\n+\t    # get the source file name.  ick!\n+\t    upvar prog srcname\n+\t    set cmi \"$srcname.gcm\"\n+\t    if { [string index $cmi 0] == \"/\" } {\n+\t\tset cmi [string range $cmi 1 end]\n+\t    } else {\n+\t\tset cmi \",/$cmi\"\n+\t    }\n+\t    set path [file split $cmi]\n+\t    # subst /../ -> /,,/\n+\t    # sadly tcl 8.5 does not have lmap\n+\t    set rplac {}\n+\t    foreach elt $path {lappend rplac [expr {$elt == \"..\" ? \",,\" : $elt}]}\n+\t    set cmi [file join {*}$rplac]\n+\t} else {\n+\t    set cmi \"[regsub : $name -].gcm\"\n+\t}\n+\tglobal DEFAULT_REPO\n+\tset cmi \"$DEFAULT_REPO/$cmi\"\n+    }\n+\n+    # delete file, so we don't get confused by a stale one.\n+    file_on_host delete \"$cmi\"\n+\n+    global module_cmis\n+    lappend module_cmis [list $spec $when $not $cmi]\n+}\n+\n+# check the expected module files exist (or not)\n+# return list to delete\n+proc module_cmi_p { src ifs } {\n+    set res {}\n+    foreach if_arg $ifs {\n+\tset spec [lindex $if_arg 0]\n+\tset when [lindex $if_arg 1]\n+\tif { $when != \"\" } {\n+\t    switch [dg-process-target $when] {\n+\t\t\"S\" { }\n+\t\t\"N\" { continue }\n+\t\t\"F\" { setup_xfail \"*-*-*\" }\n+\t\t\"P\" { }\n+\t    }\n+\t}\n+\tset not [lindex $if_arg 2]\n+\tset cmi [lindex $if_arg 3]\n+\tif { $not != [file_on_host exists $cmi] } {\n+\t    pass \"$src module-cmi $spec ($cmi)\"\n+\t} else {\n+\t    fail \"$src module-cmi $spec ($cmi)\"\n+\t    set not [expr ! $not ]\n+\t}\n+\tif { ! $not } {\n+\t    lappend res $cmi\n+\t}\n+    }\n+    return $res\n+}\n+\n+# Append required header unit names to module_headers var\n+proc dg-module-headers { args } {\n+    if { [llength $args] != 3 } {\n+\terror \"[lindex $args 0]: wrong number of arguments\"\n+\treturn\n+    }\n+}\n+\n+proc do_module_headers { srcdir subdir std flags} {\n+    global module_headers\n+    foreach header $module_headers {\n+\tset kind [lindex $header 0]\n+\tset hdr [lindex $header 1]\n+\tverbose \"Header $hdr $std\" 1\n+\tswitch $kind {\n+\t    test {\n+\t\tglobal module_cmis\n+\t\tset module_cmis {}\n+\t\tdg-test -keep-output $srcdir/$subdir/$hdr \"$std\" $flags\n+\t\tglobal mod_files\n+\t\tlappend mod_files [module_cmi_p $subdir/$hdr $module_cmis]\n+\t    }\n+\t    system -\n+\t    user {\n+\t\t# FIXME\n+\t    }\n+\t    default {\n+\t\terror \"$kind unknown header\"\n+\t    }\n+\t}\n+    }\n+}\n+\n+# link and maybe run a set of object files\n+# dg-module-do WHAT WHEN\n+proc dg-module-do { args } {\n+    if { [llength $args] > 3 } {\n+\terror \"[lindex $args 0]: too many arguments\"\n+\treturn\n+    }\n+\n+    set do_what [lindex $args 1]\n+    set expected \"P\"\n+    if { [llength $args] > 2 } {\n+\tset expected [dg-process-target [lindex $args 2]]\n+    }\n+\n+    global module_do\n+    set module_do [list $do_what $expected]\n+}\n+\n+proc module_do_it { do_what testcase std asm_list } {\n+    global tool\n+\n+    set run 0\n+    switch [lindex $do_what 0] {\n+\t\"compile\" { return 1 }\n+\t\"link\" { }\n+\t\"run\" { set run 1 }\n+\tdefault { error \"unknown module-do action [lindex $do_what 0]\" }\n+    }\n+\n+    set xfail {}\n+    switch [lindex $do_what 1] {\n+\t\"S\" { }\n+\t\"N\" { return 1 }\n+\t\"F\" { set xfail {setup_xfail \"*-*-*\"} }\n+\t\"P\" { }\n+    }\n+\n+    set ok 1\n+    # make sure all asms are around\n+    foreach asm $asm_list {\n+\tif { ! [file_on_host exists $asm] } {\n+\t    set ok 0\n+\t}\n+    }\n+\n+    set options { }\n+    if { $std != \"\" } {\n+\tlappend options \"additional_flags=$std\"\n+    }\n+    if { [llength $do_what] > 3 } {\n+\tlappend options \"additional_flags=[lindex $do_what 3]\"\n+    }\n+\n+    set execname \"./[file tail $testcase].exe\"\n+\n+    # link it\n+    verbose \"Linking $asm_list\" 1\n+    if { !$ok } {\n+\tunresolved \"$testcase link\"\n+    } else {\n+\tset out [${tool}_target_compile $asm_list \\\n+\t\t     $execname executable $options]\n+\teval $xfail\n+\tif { $out == \"\" } {\n+\t    pass \"$testcase link\"\n+\t} else {\n+\t    fail \"$testcase link\"\n+\t    set ok 0\n+\t}\n+    }\n+\n+    # run it?\n+    if { !$run } {\n+    } elseif { !$ok } {\n+\tunresolved \"$testcase execute\"\n+    } else {\n+\tset out [${tool}_load $execname \"\" \"\"]\n+\tset status [lindex $out 0]\n+\teval $xfail\n+\t$status \"$testcase execute\"\n+\tif { $status != \"pass\" } {\n+\t    set $ok 0\n+\t}\n+    }\n+\n+    if { $ok } {\n+\tfile_on_host delete $execname\n+    }\n+\n+    return $ok\n+}\n+\n+# delete the specified set of module files\n+proc cleanup_module_files { files } {\n+    foreach file $files {\n+\tfile_on_host delete $file\n+    }\n+}\n+\n+global testdir\n+set testdir $srcdir/$subdir\n+proc srcdir {} {\n+    global testdir\n+    return $testdir\n+}\n+\n+# Return set of std options to iterate over, taken from g++-dg.exp & compat.exp\n+proc module-init { src } {\n+    set tmp [dg-get-options $src]\n+    set option_list {}\n+    global module_headers\n+    set module_headers {}\n+    set have_std 0\n+    set std_prefix \"-std=c++\"\n+\n+    foreach op $tmp {\n+\tswitch [lindex $op 0] {\n+\t    \"dg-options\" {\n+\t\tset std_prefix \"-std=gnu++\"\n+\t\tif { [string match \"*-std=*\" [lindex $op 2]] } {\n+\t\t    set have_std 1\n+\t\t}\n+\t    }\n+\t    \"dg-additional-options\" {\n+\t\tif { [string match \"*-std=*\" [lindex $op 2]] } {\n+\t\t    set have_std 1\n+\t\t}\n+\t    }\n+\t    \"dg-module-headers\" {\n+\t\tset kind [lindex $op 2]\n+\t\tforeach header [lindex $op 3] {\n+\t\t    lappend module_headers [list $kind $header]\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+    if { !$have_std } {\n+\tglobal MOD_STD_LIST\n+\tforeach x $MOD_STD_LIST {\n+\t    lappend option_list \"${std_prefix}$x\"\n+\t}\n+    } else {\n+\tlappend option_list \"\"\n+    }\n+\n+    return $option_list\n+}\n+\n+# not grouped tests, sadly tcl doesn't have negated glob\n+foreach test [prune [lsort [find $srcdir/$subdir {*.[CH]}]] \\\n+\t\t  \"$srcdir/$subdir/*_?.\\[CH\\]\"] {\n+    if [runtest_file_p $runtests $test] {\n+\tset nshort [file tail [file dirname $test]]/[file tail $test]\n+\n+\tset std_list [module-init $test]\n+\tforeach std $std_list {\n+\t    do_module_headers $srcdir $subdir $std $DEFAULT_MODFLAGS\n+\t    set module_cmis {}\n+\t    verbose \"Testing $nshort $std\" 1\n+\t    dg-test $test \"$std\" $DEFAULT_MODFLAGS\n+\t    set testcase [string range $test [string length \"$srcdir/\"] end]\n+\t    cleanup_module_files [module_cmi_p $testcase $module_cmis]\n+\t}\n+    }\n+}\n+\n+# grouped tests\n+foreach src [lsort [find $srcdir/$subdir {*_a.[CH}]] {\n+    # use the FOO_a.C name as the parallelization key\n+    if [runtest_file_p $runtests $src] {\n+\tset tests [lsort [find [file dirname $src] \\\n+\t\t\t      [regsub {_a.[CH]$} [file tail $src] {_[a-z].[CH]}]]]\n+\n+\tset std_list [module-init $src]\n+\tforeach std $std_list {\n+\t    set mod_files {}\n+\t    global module_do\n+\t    set module_do {\"compile\" \"P\"}\n+\t    set asm_list {}\n+\t    do_module_headers $srcdir $subdir $std $DEFAULT_MODFLAGS\n+\t    foreach test $tests {\n+\t\tif { [lindex $module_do 1] != \"N\" } {\n+\t\t    set module_cmis {}\n+\t\t    set nshort [file tail [file dirname $test]]/[file tail $test]\n+\t\t    verbose \"Testing $nshort $std\" 1\n+\t\t    if { [file extension $test] == \".C\" } {\n+\t\t\tlappend asm_list [file rootname [file tail $test]].s\n+\t\t    }\n+\t\t    dg-test -keep-output $test \"$std\" $DEFAULT_MODFLAGS\n+\t\t    set testcase [string range $test [string length \"$srcdir/\"] end]\n+\t\t    lappend mod_files [module_cmi_p $testcase $module_cmis]\n+\t\t}\n+\t    }\n+\t    set ok 1\n+\t    set testcase [regsub {_a.[CH]} $src {}]\n+\t    set testcase \\\n+\t\t[string range $testcase [string length \"$srcdir/\"] end]\n+\t    set ok [module_do_it $module_do $testcase $std $asm_list]\n+\t    if { $ok } {\n+\t\tforeach asm $asm_list {\n+\t\t    file_on_host delete $asm\n+\t\t}\n+\t\tcleanup_module_files $mod_files\n+\t    }\n+\t}\n+    }\n+}\n+\n+dg-finish"}]}