{"sha": "108bc19009355ab635eb01262cb9e66a8f3e29c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA4YmMxOTAwOTM1NWFiNjM1ZWIwMTI2MmNiOWU2NmE4ZjNlMjljNA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2007-12-13T19:35:09Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2007-12-13T19:35:09Z"}, "message": "re PR libfortran/34370 (file positioning after nonadvancing i/o)\n\n2007-12-13  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/34370\n\tPR libfortran/34323\n\tPR libfortran/34405\n\t* io/io.h:  Add previous_nonadvancing_write to gfc_unit.\n\tAdd prototype for finish_last_advance_record.\n\t* io/file_pos.c (st_backspace):  Generate error if backspace is\n\tattempted for direct access or unformatted stream.\n\tIf there are bytes left from a previous ADVANCE=\"no\", write\n\tthem out before performing the backspace.\n\t(st_endfile):  Generate error if endfile is attempted for\n\tdirect access.\n\tIf there are bytes left from a previous ADVANCE=\"no\", write\n\tthem out before performing the endfile.\n\t(st_rewind):  Generate error if rewind is attempted for\n\tdirect access.\n\t* unit.c (close_unit_1):  Move functionality to write\n\tpreviously written bytes to...\n\t(finish_last_advance_record):  ... here.\n\t* transfer.c (data_transfer_init):  If reading, reset\n\tprevious_nonadvancing_write.\n\t(finalize_transfer):  Set the previous_noadvancing_write\n\tflag if we are writing and ADVANCE=\"no\" was specified.\n\tOnly call next_record() if advance=\"no\" wasn't specified.\n\n2007-12-13  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/34370\n\tPR libfortran/34323\n\tPR libfortran/34405\n\t* gfortran.dg/advance_6.f90:  New test case.\n\t* gfortran.dg/direct_io_7.f90:  New test case.\n\t* gfortran.dg/streamio_13.f90:  New test case.\n\nFrom-SVN: r130912", "tree": {"sha": "7ee9f3011890308864977fc29d3c36da9d6ab850", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ee9f3011890308864977fc29d3c36da9d6ab850"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/108bc19009355ab635eb01262cb9e66a8f3e29c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/108bc19009355ab635eb01262cb9e66a8f3e29c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/108bc19009355ab635eb01262cb9e66a8f3e29c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/108bc19009355ab635eb01262cb9e66a8f3e29c4/comments", "author": null, "committer": null, "parents": [{"sha": "a2b3eb5c97d0b35a55de39878e8fe2231b03de53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2b3eb5c97d0b35a55de39878e8fe2231b03de53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2b3eb5c97d0b35a55de39878e8fe2231b03de53"}], "stats": {"total": 273, "additions": 245, "deletions": 28}, "files": [{"sha": "da2f7a573a4f349e89851f2e78498eb97eeea43b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108bc19009355ab635eb01262cb9e66a8f3e29c4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108bc19009355ab635eb01262cb9e66a8f3e29c4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=108bc19009355ab635eb01262cb9e66a8f3e29c4", "patch": "@@ -1,3 +1,12 @@\n+2007-12-13  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/34370\n+\tPR libfortran/34323\n+\tPR libfortran/34405\n+\t* gfortran.dg/advance_6.f90:  New test case.\n+\t* gfortran.dg/direct_io_7.f90:  New test case.\n+\t* gfortran.dg/streamio_13.f90:  New test case.\n+\n 2007-12-13  Douglas Gregor  <doug.gregor@gmail.com>\n \n \t* g++.dg/cpp0x/__func__.C: New."}, {"sha": "f1967b014baffb9697dd46709fe7551fa99203c4", "filename": "gcc/testsuite/gfortran.dg/advance_6.f90", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108bc19009355ab635eb01262cb9e66a8f3e29c4/gcc%2Ftestsuite%2Fgfortran.dg%2Fadvance_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108bc19009355ab635eb01262cb9e66a8f3e29c4/gcc%2Ftestsuite%2Fgfortran.dg%2Fadvance_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fadvance_6.f90?ref=108bc19009355ab635eb01262cb9e66a8f3e29c4", "patch": "@@ -0,0 +1,76 @@\n+! { dg-do run }\n+! PR 34370 - file positioning after non-advancing I/O didn't add\n+! a record marker.\n+\n+program main\n+  implicit none\n+  character(len=3) :: c\n+  character(len=80), parameter :: fname = \"advance_backspace_1.dat\"\n+\n+  call write_file\n+  close (95)\n+  call check_end_record\n+\n+  call write_file\n+  backspace 95\n+  c = 'xxx'\n+  read (95,'(A)') c\n+  if (c /= 'ab ') call abort\n+  close (95)\n+  call check_end_record\n+  \n+  call write_file\n+  backspace 95\n+  close (95)\n+  call check_end_record\n+\n+  call write_file\n+  endfile 95\n+  close (95)\n+  call check_end_record\n+\n+  call write_file\n+  endfile 95\n+  rewind 95\n+  c = 'xxx'\n+  read (95,'(A)') c\n+  if (c /= 'ab ') call abort\n+  close (95)\n+  call check_end_record\n+\n+  call write_file\n+  rewind 95\n+  c = 'xxx'\n+  read (95,'(A)') c\n+  if (c /= 'ab ') call abort\n+  close (95)\n+  call check_end_record\n+\n+contains\n+\n+  subroutine write_file\n+    open(95, file=fname, status=\"replace\", form=\"formatted\")\n+    write (95, '(A)', advance=\"no\") 'a'\n+    write (95, '(A)', advance=\"no\") 'b'\n+  end subroutine write_file\n+\n+! Checks for correct end record, then deletes the file.\n+\n+  subroutine check_end_record\n+    character(len=1) :: x\n+    open(2003, file=fname, status=\"old\", access=\"stream\", form=\"unformatted\")\n+    read(2003) x\n+    if (x /= 'a') call abort\n+    read(2003) x\n+    if (x /= 'b') call abort\n+    read(2003) x\n+    if (x /= achar(10)) then\n+       read(2003) x\n+       if (x /= achar(13)) then\n+       else\n+          call abort\n+       end if\n+    end if\n+    close(2003,status=\"delete\")\n+  end subroutine check_end_record\n+end program main"}, {"sha": "ff116b0a109e98d16c2c8c4340ef9064a11b0c5b", "filename": "gcc/testsuite/gfortran.dg/direct_io_7.f90", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108bc19009355ab635eb01262cb9e66a8f3e29c4/gcc%2Ftestsuite%2Fgfortran.dg%2Fdirect_io_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108bc19009355ab635eb01262cb9e66a8f3e29c4/gcc%2Ftestsuite%2Fgfortran.dg%2Fdirect_io_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdirect_io_7.f90?ref=108bc19009355ab635eb01262cb9e66a8f3e29c4", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do run }\n+! PR 34405 - direct access prohibits ENDFILE, BACKSPACE and REWIND\n+program test\n+  implicit none\n+  integer :: ios\n+  character(len=80) :: msg\n+  open (95, access=\"direct\", recl=4, status=\"scratch\")\n+  write (95,rec=1) 'abcd'\n+\n+  ios = 0\n+  msg = \" \"\n+  backspace (95,iostat=ios,iomsg=msg)\n+  if (ios == 0 .or. &\n+       msg /= \"Cannot BACKSPACE a file opened for DIRECT access\") call abort\n+\n+  ios = 0\n+  msg = \" \"\n+  endfile (95,iostat=ios,iomsg=msg)\n+  if (ios == 0 .or. &\n+       msg /= \"Cannot perform ENDFILE on a file opened for DIRECT access\") &\n+       call abort\n+\n+  ios = 0\n+  msg = \" \"\n+  rewind (95,iostat=ios,iomsg=msg)\n+  if (ios == 0 .or. &\n+       msg /= \"Cannot REWIND a file opened for DIRECT access \") call abort\n+\n+  close (95)\n+end program test\n+"}, {"sha": "e37535b7b6b12b892de944fe3edb537614f2f9f3", "filename": "gcc/testsuite/gfortran.dg/streamio_13.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108bc19009355ab635eb01262cb9e66a8f3e29c4/gcc%2Ftestsuite%2Fgfortran.dg%2Fstreamio_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108bc19009355ab635eb01262cb9e66a8f3e29c4/gcc%2Ftestsuite%2Fgfortran.dg%2Fstreamio_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstreamio_13.f90?ref=108bc19009355ab635eb01262cb9e66a8f3e29c4", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do run }\n+! PR 34405 - BACKSPACE for unformatted stream files is prohibited.\n+program main\n+  implicit none\n+  integer :: ios\n+  character(len=80) :: msg\n+  open(2003,form=\"unformatted\",access=\"stream\",status=\"scratch\")\n+  write (2003) 1\n+  write (2003) 2\n+  ios = 0\n+  msg = ' '\n+  backspace (2003,iostat=ios,iomsg=msg)\n+  if (ios == 0 .or. msg /=\"Cannot BACKSPACE an unformatted stream file\") &\n+       call abort\n+end program main"}, {"sha": "d9706df3ab198fd5fadfc07da2cefdc33d08482d", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108bc19009355ab635eb01262cb9e66a8f3e29c4/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108bc19009355ab635eb01262cb9e66a8f3e29c4/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=108bc19009355ab635eb01262cb9e66a8f3e29c4", "patch": "@@ -1,3 +1,29 @@\n+2007-12-13  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/34370\n+\tPR libfortran/34323\n+\tPR libfortran/34405\n+\t* io/io.h:  Add previous_nonadvancing_write to gfc_unit.\n+\tAdd prototype for finish_last_advance_record.\n+\t* io/file_pos.c (st_backspace):  Generate error if backspace is\n+\tattempted for direct access or unformatted stream.\n+\tIf there are bytes left from a previous ADVANCE=\"no\", write\n+\tthem out before performing the backspace.\n+\t(st_endfile):  Generate error if endfile is attempted for\n+\tdirect access.\n+\tIf there are bytes left from a previous ADVANCE=\"no\", write\n+\tthem out before performing the endfile.\n+\t(st_rewind):  Generate error if rewind is attempted for\n+\tdirect access.\n+\t* unit.c (close_unit_1):  Move functionality to write\n+\tpreviously written bytes to...\n+\t(finish_last_advance_record):  ... here.\n+\t* transfer.c (data_transfer_init):  If reading, reset\n+\tprevious_nonadvancing_write.\n+\t(finalize_transfer):  Set the previous_noadvancing_write\n+\tflag if we are writing and ADVANCE=\"no\" was specified.\n+\tOnly call next_record() if advance=\"no\" wasn't specified.\n+\n 2007-12-13  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/34427"}, {"sha": "94e29899fb13e2364b880decd674ed74dbb368ed", "filename": "libgfortran/io/file_pos.c", "status": "modified", "additions": 49, "deletions": 5, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108bc19009355ab635eb01262cb9e66a8f3e29c4/libgfortran%2Fio%2Ffile_pos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108bc19009355ab635eb01262cb9e66a8f3e29c4/libgfortran%2Fio%2Ffile_pos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ffile_pos.c?ref=108bc19009355ab635eb01262cb9e66a8f3e29c4", "patch": "@@ -199,12 +199,22 @@ st_backspace (st_parameter_filepos *fpp)\n       goto done;\n     }\n \n-  /* Ignore direct access.  Non-advancing I/O is only allowed for formatted\n-     sequential I/O and the next direct access transfer repositions the file \n-     anyway.  */\n+  /* Direct access is prohibited, and so is unformatted stream access.  */\n \n-  if (u->flags.access == ACCESS_DIRECT || u->flags.access == ACCESS_STREAM)\n-    goto done;\n+\n+  if (u->flags.access == ACCESS_DIRECT)\n+    {\n+      generate_error (&fpp->common, LIBERROR_OPTION_CONFLICT,\n+\t\t      \"Cannot BACKSPACE a file opened for DIRECT access\");\n+      goto done;\n+    }\n+\n+    if (u->flags.access == ACCESS_STREAM && u->flags.form == FORM_UNFORMATTED)\n+      {\n+\tgenerate_error (&fpp->common, LIBERROR_OPTION_CONFLICT,\n+\t\t\t\"Cannot BACKSPACE an unformatted stream file\");\n+\tgoto done;\n+      }\n \n   /* Check for special cases involving the ENDFILE record first.  */\n \n@@ -224,6 +234,15 @@ st_backspace (st_parameter_filepos *fpp)\n \n       if (u->mode == WRITING)\n \t{\n+\t  /* If there are previously written bytes from a write with\n+\t     ADVANCE=\"no\", add a record marker before performing the\n+\t     BACKSPACE.  */\n+\n+\t  if (u->previous_nonadvancing_write)\n+\t    finish_last_advance_record (u);\n+\n+\t  u->previous_nonadvancing_write = 0;\n+\n \t  flush (u->s);\n \t  struncate (u->s);\n \t  u->mode = READING;\n@@ -261,6 +280,22 @@ st_endfile (st_parameter_filepos *fpp)\n   u = find_unit (fpp->common.unit);\n   if (u != NULL)\n     {\n+      if (u->flags.access == ACCESS_DIRECT)\n+\t{\n+\t  generate_error (&fpp->common, LIBERROR_OPTION_CONFLICT,\n+\t\t\t  \"Cannot perform ENDFILE on a file opened\"\n+\t\t\t  \" for DIRECT access\");\n+\t  goto done;\n+\t}\n+\n+      /* If there are previously written bytes from a write with ADVANCE=\"no\",\n+\t add a record marker before performing the ENDFILE.  */\n+\n+      if (u->previous_nonadvancing_write)\n+\tfinish_last_advance_record (u);\n+\n+      u->previous_nonadvancing_write = 0;\n+\n       if (u->current_record)\n \t{\n \t  st_parameter_dt dtp;\n@@ -274,6 +309,7 @@ st_endfile (st_parameter_filepos *fpp)\n       struncate (u->s);\n       u->endfile = AFTER_ENDFILE;\n       update_position (u);\n+    done:\n       unlock_unit (u);\n     }\n \n@@ -299,6 +335,14 @@ st_rewind (st_parameter_filepos *fpp)\n \t\t\t\"Cannot REWIND a file opened for DIRECT access\");\n       else\n \t{\n+\t  /* If there are previously written bytes from a write with ADVANCE=\"no\",\n+\t     add a record marker before performing the ENDFILE.  */\n+\n+\t  if (u->previous_nonadvancing_write)\n+\t    finish_last_advance_record (u);\n+\n+\t  u->previous_nonadvancing_write = 0;\n+\n \t  /* Flush the buffers.  If we have been writing to the file, the last\n \t       written record is the last record in the file, so truncate the\n \t       file now.  Reset to read mode so two consecutive rewind"}, {"sha": "688a9cbbdc88794a0eeb5b97eab34160bf44f2db", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108bc19009355ab635eb01262cb9e66a8f3e29c4/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108bc19009355ab635eb01262cb9e66a8f3e29c4/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=108bc19009355ab635eb01262cb9e66a8f3e29c4", "patch": "@@ -451,7 +451,8 @@ typedef struct gfc_unit\n   struct gfc_unit *left, *right;\n   int priority;\n \n-  int read_bad, current_record, saved_pos;\n+  int read_bad, current_record, saved_pos, previous_nonadvancing_write;\n+\n   enum\n   { NO_ENDFILE, AT_ENDFILE, AFTER_ENDFILE }\n   endfile;\n@@ -692,6 +693,9 @@ internal_proto(unlock_unit);\n extern void update_position (gfc_unit *);\n internal_proto(update_position);\n \n+extern void finish_last_advance_record (gfc_unit *u);\n+internal_proto (finish_last_advance_record);\n+\n /* open.c */\n \n extern gfc_unit *new_unit (st_parameter_open *, gfc_unit *, unit_flags *);"}, {"sha": "5dddcd31481c28d984a5462761b23bd80bbacf25", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108bc19009355ab635eb01262cb9e66a8f3e29c4/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108bc19009355ab635eb01262cb9e66a8f3e29c4/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=108bc19009355ab635eb01262cb9e66a8f3e29c4", "patch": "@@ -1891,6 +1891,8 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \n   if (read_flag)\n     {\n+      dtp->u.p.current_unit->previous_nonadvancing_write = 0;\n+\n       if ((cf & IOPARM_EOR) != 0 && dtp->u.p.advance_status != ADVANCE_NO)\n \t{\n \t  generate_error (&dtp->common, LIBERROR_MISSING_OPTION,\n@@ -2644,9 +2646,14 @@ finalize_transfer (st_parameter_dt *dtp)\n       return;\n     }\n \n+  if (dtp->u.p.mode == WRITING)\n+    dtp->u.p.current_unit->previous_nonadvancing_write\n+      = dtp->u.p.advance_status == ADVANCE_NO;\n+\n   if (is_stream_io (dtp))\n     {\n-      if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED)\n+      if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED\n+\t  && dtp->u.p.advance_status != ADVANCE_NO)\n \tnext_record (dtp, 1);\n \n       if (dtp->u.p.current_unit->flags.form == FORM_UNFORMATTED"}, {"sha": "b81f4cce4d830d06a191e1624e2a1996e7b10136", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108bc19009355ab635eb01262cb9e66a8f3e29c4/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108bc19009355ab635eb01262cb9e66a8f3e29c4/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=108bc19009355ab635eb01262cb9e66a8f3e29c4", "patch": "@@ -581,27 +581,8 @@ close_unit_1 (gfc_unit *u, int locked)\n \n   /* If there are previously written bytes from a write with ADVANCE=\"no\"\n      Reposition the buffer before closing.  */\n-  if (u->saved_pos > 0)\n-    {\n-      char *p;\n-\n-      p = salloc_w (u->s, &u->saved_pos);\n-\n-      if (!(u->unit_number == options.stdout_unit\n-\t    || u->unit_number == options.stderr_unit))\n-\t{\n-\t  size_t len;\n-\n-\t  const char crlf[] = \"\\r\\n\";\n-#ifdef HAVE_CRLF\n-\t  len = 2;\n-#else\n-\t  len = 1;\n-#endif\n-\t  if (swrite (u->s, &crlf[2-len], &len) != 0)\n-\t    os_error (\"Close after ADVANCE_NO failed\");\n-\t}\n-    }\n+  if (u->previous_nonadvancing_write)\n+    finish_last_advance_record (u);\n \n   rc = (u->s == NULL) ? 0 : sclose (u->s) == FAILURE;\n \n@@ -718,3 +699,27 @@ filename_from_unit (int n)\n     return (char *) NULL;\n }\n \n+void\n+finish_last_advance_record (gfc_unit *u)\n+{\n+  char *p;\n+\n+  if (u->saved_pos > 0)\n+    p = salloc_w (u->s, &u->saved_pos);\n+\n+  if (!(u->unit_number == options.stdout_unit\n+\t|| u->unit_number == options.stderr_unit))\n+    {\n+      size_t len;\n+\n+      const char crlf[] = \"\\r\\n\";\n+#ifdef HAVE_CRLF\n+      len = 2;\n+#else\n+      len = 1;\n+#endif\n+      if (swrite (u->s, &crlf[2-len], &len) != 0)\n+\tos_error (\"Completing record after ADVANCE_NO failed\");\n+    }\n+}\n+"}]}