{"sha": "a2ca17fa85bce1ba96853420c712d92f369237fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJjYTE3ZmE4NWJjZTFiYTk2ODUzNDIwYzcxMmQ5MmYzNjkyMzdmYg==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-08-27T20:51:39Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-08-27T20:51:39Z"}, "message": "\ufffd\nMigrate from devo/gcc/ch.\n\nFrom-SVN: r22035", "tree": {"sha": "e7371d33662176eb19cb0b601f9d934d68606c0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7371d33662176eb19cb0b601f9d934d68606c0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2ca17fa85bce1ba96853420c712d92f369237fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2ca17fa85bce1ba96853420c712d92f369237fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2ca17fa85bce1ba96853420c712d92f369237fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2ca17fa85bce1ba96853420c712d92f369237fb/comments", "author": null, "committer": null, "parents": [{"sha": "80a093b29e752ac54172945174c7cd59cec1fd05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80a093b29e752ac54172945174c7cd59cec1fd05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80a093b29e752ac54172945174c7cd59cec1fd05"}], "stats": {"total": 18292, "additions": 18292, "deletions": 0}, "files": [{"sha": "9c930f5fd69ab8e7bde6362c35c30261825f0839", "filename": "gcc/ch/ChangeLog", "status": "added", "additions": 11130, "deletions": 0, "changes": 11130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FChangeLog?ref=a2ca17fa85bce1ba96853420c712d92f369237fb"}, {"sha": "44301edff92658efa8134d262979b2a5ba3948c2", "filename": "gcc/ch/chill.brochure", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fchill.brochure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fchill.brochure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fchill.brochure?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,252 @@\n+              GNU CHILL: A Complete CHILL Implementation\n+\n+CHILL (the CCITT High Level Language) is a strongly-typed, block\n+structured language designed primarily for the implementation of large\n+and complex embedded systems.  Tens of millions of lines of CHILL code\n+exist, and about 15,000 programmers world-wide use CHILL.  Many\n+central-office telephone switching systems use CHILL for their control\n+software.\n+\n+CHILL was designed to\n+\n+  - enhance reliability and run time efficiency by means of extensive\n+    compile time checking;\n+  - provide sufficient flexibility and power to encompass the required \n+    range of applications and to exploit a variety of hardware;\n+  _ provide facilities that encourage piecewise and modular development\n+    of large systems;\n+  - cater to real-time implementations by providing built-in concurrency\n+    and time supervision primitives;\n+  - permit the generation of highly efficient object code;\n+  - facilitate ease of use and a short learning curve.\n+\n+CHILL is specified in the \"Blue Book\":\n+\tCCITT High Level Language (CHILL) Recommendation Z.200\n+\tISO/IEC 9496, Geneva 1989           ISBN 92-61-03801-8\n+\n+Cygnus Support has completed the first level implementation of the \n+GNU CHILL compiler.  Our compiler now supports the core features of\n+the CHILL language.  Our goal is a fully retargetable, complete\n+implementation of the Z.200 specification.  The next phase of\n+implementation will include:\n+\n+\t. a minimal real-time kernel for demonstration use\n+\t. more rigorous type checking\n+\t. retargetable input/output\n+\t. interprocess communications\n+\t. fully compliant exception handling.\n+\n+The State of the Implementation\n+\n+The GNU CHILL compiler is in early beta state, performing correct\n+compilation and execution of correctly coded programs.  Like most\n+CHILL compilers, the GNU compiler implements a large subset of the\n+language (as described below).\n+\n+Since it uses the same compiler back-ends as the GNU C and C++\n+compilers, GNU CHILL is almost instantly available on all\n+platforms supported by GNU C, including the following:\n+\n+\tm680xx, i960, i80x86, AMD29K, R3000, R4000, SPARClite,\n+\tHitachi H8 and SH families, Z8001/2\n+\n+It has been specifically tested under SunOS on SPARCs and under\n+SCO Unix on 80386s.\n+\n+All of the GCC optimizations apply to CHILL as well, including \n+function inlining, dead code elimination, jump-to-jump elimination, \n+cross-jumping (tail-merging), constant propagation, common \n+subexpression elimination, loop-invariant code motion, strength \n+reduction, loop unrolling, induction variable elimination, flow\n+analysis (copy propagation, dead store elimination and elimination\n+of unreachable code), dataflow-driven instruction scheduling, and\n+many others.\n+\n+I/O statements are parsed. The anticipated timeframe for I/O code\n+generation is Q1 1994.\n+\n+What's Next\n+\n+The multi-tasking functions require a small real time kernel.\n+A free implementation of such a kernel is not yet available.\n+We plan to offer a productized P-threads interface in Q2 1994.\n+Other runtime functions involving strings and powersets are \n+working.\n+\n+GDB, the GNU Debugger, has been modified to provide simple CHILL\n+support.  Some CHILL expressions are not yet recognized.\n+\f\n+For those who aren't familiar with CHILL, here's a small but\n+useful example program:\n+\n+--\n+-- Convert binary integers to decimal-coded ASCII string\n+--\n+vary1: MODULE\n+\n+  -- include declarations so we can output the test results\n+  <> USE_SEIZE_FILE 'chprintf.grt' <>\n+  SEIZE chprintf;\n+\n+  -- create a new name for the CHAR array mode\n+  SYNMODE dec_string = CHAR (6) VARYING;\n+\n+  int_to_dec_char: PROC (decimal_num INT IN)\n+                   RETURNS (dec_string);\n+\n+    DCL neg_num BOOL := FALSE;        -- save sign of parameter\n+    DCL out_string dec_string;\n+\n+    IF decimal_num < 0 THEN           -- positive numbers are easier\n+      decimal_num := -decimal_num;\n+      neg_num := TRUE;\n+    FI\n+\n+    IF decimal_num = 0 THEN\n+      out_string := '0';                 /* handle zero */\n+    ELSE\n+      out_string := '';\n+      DO WHILE decimal_num /= 0;         -- loop until number is zero\n+\t-- concatenate a new digit in front of the output string\n+        out_string := CHAR (ABS (decimal_num REM D'10) + H'30) \n+\t\t      // out_string;\n+        decimal_num := decimal_num / D'10;\n+      OD;\n+      IF neg_num THEN\n+\t-- prepend a hyphen for numbers < zero\n+        out_string := '-' // out_string;   -- restore sign\n+      FI;\n+    FI;\n+    RESULT out_string;               -- remember result\n+\n+    decimal_num := 0;                -- reset for next call\n+    neg_num := FALSE;\n+    out_string := '      ';\n+\n+  END int_to_dec_char;\n+\n+  /* Try some test cases */\n+  chprintf (int_to_dec_char (123456), 0);\n+  chprintf (\"^J\", 0);\n+\n+  chprintf (int_to_dec_char (-654321), 0);\n+  chprintf (\"^J\", 0);\n+\n+  chprintf (int_to_dec_char (0), 0);\n+  chprintf (\"^J\", 0);\n+\n+END vary1;\n+\f\n+Completeness\n+\n+GNU CHILL currently supports the following features.  This outline\n+generally follows the structure of the Blue Book specification:\n+\n+\tCCITT High Level Language (CHILL) Recommendation Z.200\n+\tISO/IEC 9496, Geneva 1989           ISBN 92-61-03801-8\n+\n+\n+  Modes (types)\n+\tno DYNAMIC modes yet\n+\tdiscrete modes\n+\t\tinteger, boolean, character, real\n+\t\tmultiple integer/real precisions (an extension)\n+\tset modes, range modes\n+\tpowersets\n+\treferences\n+\t  (no ROW modes)\t\n+\tprocedure modes\n+\tinstance modes\n+\tevent modes\n+\tbuffer modes\n+\t(no input/output modes yet)\n+\t(no timing modes yet)\n+\tcomposite modes\n+\t  strings\n+\t  arrays\n+\t  structures\n+\tVARYING string/array modes\n+\t(type-checking is not fully rigorous yet)\n+\tforward references\n+\n+  Expressions\n+\tliterals\n+\ttuples\n+\tslices, ranges\n+\tthe standard operators\n+\n+  Actions (statements)\n+\tassignments\n+\tif .. then .. else .. fi\n+\tcases\n+\tdo action\n+\tdo .. with\n+\texits\n+\tcalls\n+\tresults/returns\n+\tgotos\n+\tassertions\n+\tcause exception\n+\tstart/stop/continue process\n+\n+  Input/Output\n+\t(not yet)\n+\n+  Exception handling\n+\tfully compiled, but exceptions aren't\n+\tgenerated in all of the required situations\n+\n+  Time Supervision\n+\t(syntax only)\n+\n+  Inter-process communications\n+\tdelay/delay case actions\n+\tsend signal/receive case actions\n+\tsend buffer/receive case actions\n+\n+  Multi-module programming\n+\tSeize/grant processing\n+\tmultiple modules per source file\n+\n+\n+Bibliography\n+\n+This list is included as an invitation.  We'd appreciate hearing \n+of CHILL-related documents (with ISBN if possible) which aren't\n+described here.  We're particularly interested in getting copies\n+of other conference Proceedings.\n+\n+\tCCITT High Level Language (CHILL) Recommendation Z.200\n+\tISO/IEC 9496, Geneva 1989                ISBN 92-61-03801-8\n+\t(The \"blue book\". The formal language definition; mostly a\n+\t language-lawyer's document, but more readable than most.)\n+\n+\tStudy Group X - Report R 34\n+\tThis is the May 1992 revision of Z.200.\n+\n+\tAn Analytic Description of CHILL, the CCITT high-level\n+\tlanguage, Branquart, Louis & Wodon, Springer-Verlag 1981\n+                                                 ISBN 3-540-11196-4\n+\n+\tCHILL User's Manual\n+\tCCITT, Geneva 1986                       ISBN 92-61-02601-X\n+\t(Most readable, but doesn't cover the whole language).  \n+\n+\tIntroduction to CHILL\n+\tCCITT, Geneva 1983                       ISBN 92-61-017771-1\n+\n+\tCHILL CCITT High Level Language\n+\tProceedings of the 5th CHILL Conference\n+\tNorth-Holland, 1991                      ISBN 0 444 88904 3\n+\n+\tIntroduction to the CHILL programming Language\n+\tTELEBRAS, Campinas, Brazil 1990\n+\n+\tCHILL: A Self-Instruction Manual\n+\tTelecommunication Institute - PITTC\n+\tAvailable from KVATRO A/S, N-7005 Trondheim, Norway\n+\tPhone: +47 7 52 00 90\n+\t(Great discussion of novelty.)\n+\n+Some of these documents are available from Global Engineering\n+Documents, in Irvine, CA, USA.  +1 714 261 1455."}, {"sha": "92d689107e2966570869525eb6d19de70e35319b", "filename": "gcc/ch/chill.texi", "status": "added", "additions": 1231, "deletions": 0, "changes": 1231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fchill.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fchill.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fchill.texi?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,1231 @@\n+@\\input texinfo @c -*-texinfo-*-\n+@setfilename chill.info\n+@settitle Guide to GNU Chill\n+\n+\n+@ifinfo\n+@format\n+START-INFO-DIR-ENTRY\n+* Chill::                       Chill compiler\n+END-INFO-DIR-ENTRY\n+@end format\n+@end ifinfo\n+\n+@titlepage\n+@title GNU Chill\n+@author William Cox, Per Bothner, Wilfried Moser\n+@end titlepage\n+\n+@ifinfo\n+@node Top\n+@top\n+\n+@menu\n+* Options::               Compiler options\n+* Missing::               Unimplemented parts of the Chill language\n+* Enhancements::          GNU-specific enhancements to the Chill language\n+* Conversions::           Value and location conversions\n+* Separate compilation::  Separate compilation\n+* Differences::           Differences between GNUCHILL and Z.200/1988\n+* Directives::            Implemented Compiler Directives\n+* References::            Language definition references\n+@end menu\n+\n+@end ifinfo\n+\n+@node Options\n+@chapter Compiler options\n+\n+Invoking the compiler:\n+\n+The @sc{gnu} CHILL compiler supports several new command line options, and\n+brings a new use to another:\n+\n+@table @code\n+@item -lang-chill\n+This option instructs gcc that the following file is a CHILL source file,\n+even though its extension is not the default `.ch'.\n+\n+@item -flocal-loop-counter\n+The CHILL compiler makes a separate reach, or scope,\n+for each DO FOR loop.  If @code{-flocal-loop-counter} is\n+specified, the loop counter of value enumeration and location\n+enumeration is automatically declared inside that reach.\n+This is the default behavior, required by Z.200.\n+\n+@item -fno-local-loop-counter\n+When this option is specified, the above automatic declaration\n+is not performed, and the user must declare all loop counters \n+explicitly.\n+\n+@item -fignore-case\n+When this option is specified, the compiler ignores case. All \n+identifiers are converted to lower case. This enables the usage\n+of C runtime libraries.\n+\n+@item -fno-ignore-case\n+Ignoring the case of identifiers is turned off.\n+\n+@item -fruntime-checking\n+The CHILL compiler normally generates code to check \n+the validity of expressions assigned to variables or\n+expressions passed as parameters to procedures and processes,\n+if those expressions cannot be checked at compile time.\n+This is the default behavior, required by Z.200.\n+This option allows you to re-enable the default behavior\n+after disabling it with the @code{-fno-runtime-checking}\n+option.\n+\n+@item -fno-runtime-checking\n+The CHILL compiler normally generates code to check \n+the validity of expressions assigned to variables, or\n+expressions passed as parameters to procedures and processes.\n+This option allows you to disable that code generation.\n+This might be done to reduce the size of a program's\n+generated code, or to increase its speed of execution.\n+Compile time range-checking is still performed.\n+\n+@item -fgrant-only\n+@itemx -fchill-grant-only\n+This option causes the compiler to stop successfully\n+after creating the grant file specified by the source\n+file (see modular programming in CHILL).  No code is\n+generated, and many categories of errors are not reported.\n+\n+@item -fold-string\n+Implement the semantics of Chill 1984 with respect to strings:\n+String indexing yields a slice of length one;  CHAR is similar\n+to CHAR(1) (or CHARS(1)); and BOOL is similar to BIT(1) (or BOOLS(1)).\n+\n+@item -fno-old-string\n+Don't implement 1984 Chill string semantics.  This is the default.\n+\n+@item -I@var{seize_path}\n+This directive adds the specified seize path to the compiler's\n+list of paths to search for seize files.  When processing a \n+USE_SEIZE_FILE directive, the compiler normally searches for\n+the specified seize file only in the current directory.  When\n+one or more seize paths are specified, the compiler also \n+searches in those directories, in the order of their\n+specification on the command line, for the seize file.\n+\n+@item -c\n+This C-related switch, which normally prevents gcc from \n+attempting to link, is *not* yet implemented by the @code{chill} command,\n+but you can use the @code{gcc} command with this flag.\n+@end table\n+\n+@node Missing\n+@chapter Implemented and missing parts of the Chill language\n+\n+The numbers in parentheses are Z.200(1988) section numbers.\n+\n+@itemize @bullet\n+@item The FORBID keyword in a GRANT statement is currently ignored.\n+\n+@item A CASE action or expression allows only a single expression\n+in a case selector list (5.3.2, 6.4).\n+\n+@item ROW modes are not implemented (3.6.3, 3.13.4).\n+\n+@item Due to the absence of ROW modes, DYNAMIC has no meaning in\n+connection with access and text modes.\n+\n+@item Array and structure layout (PACK, POS, NOPACK, \n+STEP keywords) is ignored (3.12.6).\n+\n+@item Bit-string slices are not implemented.\n+\n+@item The support for synchronization modes and concurrent execution\n+is slightly non-standard.\n+\n+@item Exception handling is implemented, but exceptions are not\n+generated in all of the required situations.\n+\n+@item Dynamic modes are not implemented (though string slices should work).\n+\n+@item Reach-bound initializations are not implemented (4.1.2).\n+\n+@end itemize\n+\n+@node Enhancements\n+@chapter GNU-specific enhancements to the Chill language\n+\n+@itemize @bullet\n+@item Grantfiles.  See @xref{Separate compilation}.\n+@item Precisions.  Multiple integer and real precisions are supported,\n+as well as signed and unsigned variants of the integer modes.\n+@item DESCR built-in. The new built-in function \n+DESCR ( <descriptor argument> ) returns a pointer to \n+STRUCT( addr PTR, length ULONG ) where <descriptor argument> can be\n+anything the compiler can handle but at least a location of any mode\n+(except synchronizing modes) and any character string or powerset value.\n+(A temporary location within the current stack frame may be allocated\n+if an expression is used.)\n+\n+CHILL does not permit the writing of procedures with parameters of\n+any type. Yet some interfaces---in particular those to system \n+calls---require\n+the handling of a wide range of modes, e.g. any string mode, any structure\n+mode, or any powerset mode. This could be handled by specifying two\n+parameters (PTR, INT for the length) but this is error-prone (no guarantee\n+the same location is used after in ADDR and LENGTH), and it will not be\n+possible for expressions.\n+\n+Caveats: This feature permits the programmer to obtain the address of\n+a literal (if the compiler takes this shortcut---see 1st example below).\n+If hardware features protect constant parts of the program, erronous\n+abuse will be detected.\n+\n+    Examples:\n+       OFFER_HANDLER( descr(\"dbs\"), ->dbs);\n+\n+       SYNMODE m_els = SET( ela, elb, elc );\n+       SYNMODE m_elsel = POWERSET m_els;\n+       DCL user_buf STRUCT( a mx, b my, c mz);\n+       DCL select POWERSET m_elsel;\n+\n+       select := m_elsel[LOWER(m_els) : UPPER(m_els)];\n+\n+       GET_RECORD( relation, recno, descr(user_buf), descr(select) );\n+\n+       PUT_RECORD( relation, recno, descr(user_buf.b), descr(m_elsel[elb]) );\n+\n+@item LENGTH built-in on left-hand-side.       The LENGTH built-in may be\n+used on the left-hand-side of an assignment, where its argument is a VARYING\n+character string.\n+@end itemize\n+\n+@node Conversions\n+@chapter Value and location conversions\n+\n+Value and location conversions are highly dependent on the target machine.\n+They are also very loosely specified in the 1988 standard.\n+(The 1992 standard seems an improvement.)\n+\n+The GNU Chill compiler interprets @code{@var{mode}(@var{exp})} as follows:\n+\n+@itemize @bullet\n+@item\n+If @var{exp} is a referable location,\n+and the size of (the mode of) @var{exp} is the same as the size of @var{mode},\n+a location conversion is used.\n+It is implemented exactly as:  @code{(@var{refmode}(-> @var{exp}))->},\n+where @var{refmode} is a synmode for @code{REF @var{mode}}.\n+\n+The programmer is responsible for making sure that alignment\n+restrictions on machine addresses are not violated.\n+\n+If both @var{mode} and the mode of @var{exp} are discrete modes,\n+alignment should not be a problem, and we get the same conversion\n+as a standard value conversion.\n+\n+@item\n+If @var{exp} is a constant,\n+and the size of (the mode of) @var{exp} is the same as the size of @var{mode},\n+then a value conversion is performed.  This conversion is done\n+at compile time, and it has not been implemented for all types.\n+Specifically, converting to or from a floating-point type is not implemented.\n+\n+@item\n+If both @var{mode} and the mode of @var{exp} are discrete modes,\n+then a value conversion is performed, as described in Z.200.\n+\n+@item\n+If both @var{mode} and the mode of @var{exp} are reference modes,\n+then a value conversion is allowed.\n+The same is true is one mode is a reference mode, and the other\n+is an integral mode of the same size.\n+\n+@end itemize\n+\n+@node Separate compilation\n+@chapter Separate compilation\n+\n+The GNU CHILL compiler supports modular programming.  It\n+allows the user to control the visibility of variables\n+and modes, outside of a MODULE, by the use of GRANT\n+and SEIZE directives.  Any location or mode may be made\n+visible to another MODULE by GRANTing it in the MODULE\n+where it is defined, and SEIZEing it in another MODULE\n+which needs to refer to it.\n+\n+When variables are GRANTed in one or more modules of a\n+CHILL source file, the compiler outputs a grant file,\n+with the original source file name as the base name,\n+and the extension `.grt'.  All of the variables and modes\n+defined in the source file are written to the grant file,\n+together with any use_seize_file directives, and the\n+GRANT directives.  A grant file is created for every such\n+source file, except if an identical grant file already \n+exists.  This prevents unnecessary makefile activity.\n+\n+The referencing source file must:\n+\n+@enumerate\n+@item specify the grant file in a use_seize_file directive, and\n+@item SEIZE each variable or mode definition that it needs.\n+@end enumerate\n+\n+An attempt to SEIZE a variable or mode which is not\n+GRANTed in some seize file is an error.\n+\n+An attempt to refer to a variable which is defined in\n+some seize file, but not explicitly granted, is an\n+error.\n+\n+An attempt to GRANT a variable or mode which is not\n+defined in the current MODULE is an error.\n+\n+Note that the GNU CHILL compiler will *not* write out a\n+grant file if:\n+\n+@itemize @bullet\n+@item there are no GRANT directives in the source file, or\n+@item the entire grant file already exists, and is\n+     identical to the file which the compiler has just built.\n+(This latter ``feature'' may be removed at some point.)\n+@end itemize\n+\n+Otherwise, a grant file is an automatic, unsuppressable\n+result of a successful CHILL compilation.\n+\n+A future release will also support using remote spec modules\n+in a similar (but more Blue Book-conforming) manner.\n+\n+@node Differences\n+@chapter Differences to Z.200/1988\n+\n+This chapter lists the differences and extensions between GNUCHILL \n+and the CCITT recommendation Z.200 in its 1988 version (reffered to\n+as Z.200/1988).\n+\n+@itemize @bullet\n+\n+@item 2.2 Vocabulary@*\n+The definition of @i{<simple name string>} is changed to:\n+\n+@example\n+@i{<simple name string> ::=}\n+@example\n+@i{@{<letter> | _ @} @{ <letter> | <digit | _ @}}\n+@end example\n+@end example\n+\n+@item 2.6 Compiler Directives@*\n+Only one directive is allowed between the compiler directive delimiters\n+`<>' and `<>' or the end-of-line, i.e.\n+@example\n+<> USE_SEIZE_FILE \"foo.grt\" <>\n+<> ALL_STATIC_OFF\n+@end example\n+\n+@item 3.3 Modes and Classes@*\n+The syntax of @i{<mode>} is changed to:\n+\n+@example\n+@i{<mode> ::=}\n+@example\n+  [@b{READ}] @i{<non-composite-mode>}\n+| [@b{READ}] @i{composite-mode>}\n+@end example\n+\n+@i{<non-composite-mode> ::=}\n+@example\n+  @i{<discrete mode>}\n+| @i{<real modes>}\n+| @i{<powerset modes>}\n+| @i{<reference mode>}\n+| @i{<procedure mode>}\n+| @i{<instance mode>}\n+| @i{<synchronization mode>}\n+| @i{<timing mode>}\n+@end example\n+@end example\n+\n+@item 3.4 Discrete Modes@*\n+The list of discrete modes is enhanced by the following modes:\n+\n+@example\n+BYTE         8-bit signed integer\n+UBYTE        8-bit unsigned integer\n+UINT         16-bit unsigned integer\n+LONG         32-bit signed integer\n+ULONG        32-bit unsigned integer\n+@end example\n+\n+@strong{Please note} that INT is implemented as 16-bit signed integer.\n+\n+@item 3.4.6 Range Modes@*\n+The mode BIN(n) is not implemented. Using INT(0 : 2 ** n - 1) instead of\n+BIN(n) makes this mode unneccessary.\n+\n+@item 3.X Real Modes@*\n+Note: This is an extension to Z.200/1988, however, it is defined in\n+Z.200/1992.\n+\n+@b{syntax:}\n+\n+@example\n+@i{<real mode> ::=}\n+@example\n+@i{<floating point mode>}\n+@end example\n+@end example\n+\n+@b{semantics:}\n+\n+@example\n+A real mode specifies a set of numerical values which approximate a\n+contiguous range of real numbers.\n+@end example\n+\n+@item 3.X.1 Floating point modes@*\n+\n+@b{syntax:}\n+\n+@example\n+@i{<floating point mode> ::=}\n+@example\n+@i{<floating point mode name}\n+@end example\n+@end example\n+\n+@b{predefined names:}\n+\n+The names @i{REAL} and @i{LONG_REAL} are predefined as @b{floating\n+point mode} names.\n+\n+@b{semantics:}\n+\n+A floating point mode defines a set of numeric approximations to a \n+range of real values, together with their minimum relative accuracy, \n+between implementation defined bounds, over which the usual ordering \n+and arithmetic operations are defined. This set contains only the \n+values which can be represented by the implementation.\n+\n+@b{examples:}\n+\n+@example\n+@i{REAL}\n+@i{LONG_REAL}\n+@end example\n+\n+@item 3.6 Reference Modes@*\n+Row modes are not implemeted at all.\n+\n+@item 3.7 Procedure Mode@*\n+The syntax for procedure modes is changed to:\n+\n+@example\n+@i{<procedure mode> ::=}\n+@example\n+  @b{PROC} @i{([<parameter list>]) [ <result spec> ]}\n+  @i{[}@b{EXCEPTIONS}@i{(<exception list>)] [}@b{RECURSIVE}@i{]}\n+| @i{<procedure mode name>}\n+@end example\n+\n+@i{<parameter list> ::=}\n+@example\n+@i{<parameter spec> @{, <parameter spec> @} *}\n+@end example\n+\n+@i{<parameter spec> ::=}\n+@example\n+@i{<mode> [ <parameter attribute> ]}\n+@end example\n+\n+@i{<parameter attribute> ::=}\n+@example\n+@b{IN} | @b{OUT} | @b{INOUT} | @b{LOC}\n+@end example\n+\n+@i{<result spec> ::=}\n+@example\n+@b{RETURNS} @i{( <mode> [}@b{LOC}@i{])}\n+@end example\n+\n+@i{<exception list> ::=}\n+@example\n+@i{<exception name> @{, <exception name> @} *}\n+@end example\n+@end example\n+\n+\n+@item 3.10 Input-Output Modes@*\n+Due to the absence of row modes, DYNAMIC has no meaning in an access\n+or text mode definition.\n+\n+\n+@item 3.12.2 String Modes@*\n+As @i{<string modes>} were defined differently in Z.200/1984, the syntax\n+of @i{<string mode>} is changed to:\n+\n+@example\n+@i{<string mode> ::=}\n+@example\n+  @i{<string type> ( <string length> ) [} @b{VARYING} @i{]}\n+| @i{<parametrized string mode>}\n+| @i{<string mode name>}\n+@end example\n+\n+@i{<parameterized string mode> ::=}\n+@example\n+  @i{<origin string mode name> ( <string length> )}\n+| @i{<parameterized string mode name>}\n+@end example\n+\n+@i{<origin string mode name> ::=}\n+@example\n+@i{<string mode name>}\n+@end example\n+\n+@i{string type}\n+@example\n+  @b{BOOLS}\n+| @b{BIT}\n+| @b{CHARS}\n+| @b{CHAR}\n+@end example\n+\n+@i{<string length> ::=}\n+@example\n+@i{<integer literal expression>}\n+@end example\n+@end example\n+\n+@b{VARYING} is not implemented for @i{<string type>} @b{BIT}\n+and @b{BOOL}.\n+\n+@item 3.11.1 Duration Modes@*\n+The predefined mode @i{DURATION} is implemented as a NEWMODE ULONG and\n+holds the duration value in miliseconds. This gives a maximum duration\n+of\n+\n+@example\n+MILLISECS (UPPER (ULONG)),\n+SECS (4294967),\n+MINUTES (71582),\n+HOURS (1193), and\n+DAYS (49).\n+@end example\n+\n+@item 3.11.2 Absolute Time Modes@*\n+The predefined mode @i{TIME} is implemented as a NEWMODE ULONG and\n+holds the absolute time in seconds since Jan. 1st, 1970. This is\n+equivalent to the mode `time_t' defined on different systems.\n+\n+@item 3.12.4 Structure Modes@*\n+Variant fields are allowed, but the CASE-construct may define only one\n+tag field (one dimensional CASE). OF course, several variant fields may\n+be specified in one STRUCT mode. The tag field will (both at compile-\n+and runtime) not be interpreted in any way, however, it must be\n+interpreted by a debugger. As a consequence, there are no parameterized \n+STRUCT modes.\n+\n+@item 3.12.5 Layout description for array and structure modes@*\n+STEP and POS is not implemeted at all, therefore the syntax of\n+@i{<element layout} and @i{field layout} is changed to:\n+\n+@example\n+@i{<element layout> ::=}\n+@example\n+@b{PACK} | @b{NOPACK}\n+@end example\n+\n+@i{<field layout> ::=}\n+@example\n+@b{PACK} | @b{NOPACK}\n+@end example\n+@end example\n+\n+@item 3.13.4 Dynamic parameterised structure modes@*\n+Dynamic parameterised structure modes are not implemented.\n+\n+@item 4.1.2 Location declaration@*\n+The keyword STATIC is allowed, but has no effect at module level, because\n+all locations declared there are assumed to be `static' by default. Each\n+granted location will become `public'. A `static' declaration inside a\n+block, procedure, etc. places the variable in the data section instead of\n+the stack section.\n+\n+@item 4.1.4 Based decleration@*\n+The based declaration was taken from Z.200/1984 and has the following\n+syntax:\n+\n+@b{syntax:}\n+\n+@example\n+@i{<based declaration> ::=}\n+@example\n+@i{<defining occerrence list> <mode>} @b{BASED}\n+@i{( <free reference location name> )}\n+@end example\n+@end example\n+\n+@b{semantics:}\n+\n+A based declaration with @i{<free reference location name>} specifies\n+as many access names as are defining occerrences in the @i{defining\n+occurrence list}. Names declared in a base declaration serve as an\n+alternative way accessing a location by dereferencing a reference \n+value. This reference value is contained in the location specified by \n+the @i{free reference location name}. This dereferencing operation is \n+made each time and only when an access is made via a declared @b{based} \n+name.\n+\n+@b{static properties:}\n+\n+A defining occurrence in a @i{based declaration} with @i{free reference\n+location name} defines a @b{based} name. The mode attached to a\n+@b{based} name is the @i{mode} specified in the @i{based declaration}. A\n+@b{based} name is @b{referable}.\n+\n+@item 4.2.2 Access names@*\n+The syntax of access names is changed to:\n+\n+@example\n+@i{<access name> ::=}\n+@example\n+  @i{<location name>}\n+| @i{<loc-identity name>}\n+| @i{<based name>}\n+| @i{<location enumeration name>}\n+| @i{<location do-with name>}\n+@end example\n+@end example\n+\n+The semantics, static properties and dynamic conditions remain\n+unchanged except that they are enhanced by @i{base name}.\n+\n+@item 5.2.4.1 Literals General@*\n+The syntax of @i{<literal>} is change to:\n+\n+@example\n+@i{<literal> ::=}\n+@example\n+  @i{<integer literal>}\n+| @i{<boolean literal>}\n+| @i{<charater literal>}\n+| @i{<set literal>}\n+| @i{<emptiness literal>}\n+| @i{<character string literal>}\n+| @i{<bit string literal>}\n+| @i{<floating point literal>}\n+@end example\n+@end example\n+\n+Note: The @i{<floating point literal>} is an extension to Z.200/1988 and\n+will be described later on.\n+\n+@item 5.2.4.2 Integer literals@*\n+The @i{<decimal integer literal>} is changed to:\n+\n+@example\n+@i{<decimal integer literal> ::=}\n+@example\n+  @i{@{ D | d @} ' @{ <digit> | _ @} +}\n+| @i{<digit> @{ <digit> | _ @} *}\n+@end example\n+@end example\n+\n+@item 5.2.4.4 Character literals@*\n+A character literal, e.g. 'M', may serve as a charater string literal of\n+length 1.\n+\n+@item 5.2.4.7 Character string literals@*\n+The syntax of a character string literal is:\n+\n+@example\n+@i{<character string literal> ::=}\n+@example\n+  @i{'@{ <non-reserved character> | <single quote> |}\n+  @i{<control sequence> @} * '}\n+| @i{'@{ <non-reserved character> | <double quote> |}\n+  @i{<control sequence> @} * '}\n+@end example\n+\n+@i{<single quote> ::=}\n+@example\n+@i{''}\n+@end example\n+\n+@i{<double quote> ::=}\n+@example\n+@i{\"\"}\n+@end example\n+@end example\n+\n+A character string litaral of length 1, enclosed in apostrophes\n+(e.g. 'M') may also serve as a charater literal.\n+\n+@item 5.2.4.9 Floating point literal@*\n+Note: This is an extension to Z.200/1988 ans was taken from Z.200/1992.\n+\n+@b{syntax:}\n+\n+@example\n+@i{<floating point literal> ::=}\n+@example\n+  @i{<unsigned floating point literal>}\n+| @i{<signed floating point literal>}\n+@end example\n+\n+@i{<unsigned floating point literal> ::=}\n+@example\n+  @i{<digit sequence> . [ <digit sequence> ] [ <exponent> ]}\n+| @i{[ <digit sequence> ] . <digit sequence> [ <exponent> ]}\n+@end example\n+\n+@i{<signed floating point literal> ::=}\n+@example\n+@i{- <unsigned floating point literal>}\n+@end example\n+\n+@i{<digit sequence> ::=}\n+@example\n+@i{<digit> @{ <digit> | _ @} *}\n+@end example\n+\n+@i{<exponent> ::=}\n+@example\n+  @i{[ E | D | e | d ] <digit sequence>}\n+| @i{[ E | D | e | d ] - <digit sequence>}\n+@end example\n+@end example\n+\n+@item 5.2.14 Start Expression@*\n+The START expression is not implemented.\n+\n+@item 5.3 Values and Expressions@*\n+The undefined value, denoted by `*', is not implemented.\n+\n+@item 5.3.8 Operand-5@*\n+The @i{<string repetition operator>} is defined as:\n+\n+@example\n+@i{<string repetition operator> ::=}\n+@example\n+@i{(<integer expression>)}\n+@end example\n+@end example\n+\n+@item 6.4 Case Action@*\n+There may be only one case selector specified. The optional range list\n+must not be specified.\n+\n+@item 6.5 Do Action@*\n+A Do-Action without control part is not implemented. Grouping of\n+statements can be achieved via BEGIN and END. A location enumeration is not\n+allowed for BIT strings, only for (varying) CHAR strings and ARRAYs.\n+\n+The expression list in a DO WITH must consist of locations only.\n+\n+@item 6.13 Start Action@*\n+The syntax of the START action is changed to:\n+\n+@example\n+@i{<start action> ::=}\n+@example\n+@b{START} @i{<process name> (<copy number> [, <actual parameter list>])}\n+@i{[} @b{SET} @i{<instance location> ]}\n+@end example\n+\n+@i{<copy number> ::=}\n+@example\n+@i{<integer expression>}\n+@end example\n+@end example\n+\n+@item 6.16 Delay Action@*\n+The optional PRIORITY specification need not be a constant.\n+\n+@item 6.17 Delay Case Action@*\n+The optional SET branch and the, also optional, PRIORITY branch must be\n+seperated by `;'.\n+\n+@item 6.18 Send Action@*\n+The send action must define a destination instance (via the TO branch),\n+since undirected signals are not supported. The optional PRIORITY\n+specification need not be a constant. Additional to the data\n+transported by the signal, there will be a user defined argument.\n+\n+The syntax of the @i{<send signal action>} is therefore:\n+\n+@example\n+@i{<send signal action> ::=}\n+@example\n+@b{SEND} @i{<signal name> [ ( <value> @{, <value> @} * ) ]}\n+@i{[} @b{WITH} @i{<expression> ]}\n+@b{TO} @i{<instance primitive value> [ <priority> ]}\n+@end example\n+@end example\n+\n+The default priority can be specified by the compiler directive\n+SEND_SIGNAL_DEFAULT_PRIORITY. If this also is omitted, the default\n+priority is 0.\n+\n+@item 6.20.3 CHILL value built-in calls@*\n+The CHILL value buit-in calls are enhanced by some calls, and other calls\n+will have different arguments as described in Z.200/1988. Any call not\n+mentioned here is the same as described in Z.200/1988.\n+\n+@b{syntax:}\n+\n+@example\n+@i{CHILL value built-in routine call> ::=}\n+@example\n+  @i{ADDR (<location>)}\n+| @i{PRED (<pred succ argument>)}\n+| @i{SUCC (<pred succ argument>)}\n+| @i{ABS (<numeric expression>)}\n+| @i{LENGTH (<length argument>)}\n+| @i{SIN (<floating point expression>)}\n+| @i{COS (<floating point expression>)}\n+| @i{TAN (<floating point expression>)}\n+| @i{ARCSIN (<floating point expression>)}\n+| @i{ARCCOS (<floating point expression>)}\n+| @i{ARCTAN (<floating point expression>)}\n+| @i{EXP (<floating point expression>)}\n+| @i{LN (<floating point expression>)}\n+| @i{LOG (<floating point expression>)}\n+| @i{SQRT (<floating point expression>)}\n+| @i{QUEUE_LENGTH (<buffer location> | <event location>)}\n+| @i{GEN_INST (<integer expression> | <process name> ,}\n+               @i{<integer expression>)}\n+| @i{COPY_NUMBER (<instance expression>)}\n+| @i{GEN_PTYE (<process name>)}\n+| @i{PROC_TYPE (<instance expression>)}\n+| @i{GEN_CODE (<process name> | <signal name>)}\n+| @i{DESCR (<location>)}\n+@end example\n+\n+@i{<pred succ argument> ::=}\n+@example\n+  @i{<discrete expression>}\n+| @i{<bound reference expression>}\n+@end example\n+\n+@i{<numeric expression> ::=}\n+@example\n+  @i{<integer expression>}\n+| @i{floating point expression>}\n+@end example\n+\n+@i{<length argument> ::=}\n+@example\n+  @i{<string location>}\n+| @i{<string expression>}\n+| @i{<string mode name>}\n+| @i{<event location>}\n+| @i{<event mode name>}\n+| @i{<buffer location>}\n+| @i{<buffer mode name>}\n+| @i{<text location>}\n+| @i{<text mode name>}\n+@end example\n+@end example\n+\n+@b{semantics:}\n+\n+@i{ADDR} is derived syntax for -> @i{<location>}.\n+\n+@i{PRED} and @i{SUCC} delivers respectively, in case of a @i{discrete\n+expression}, the next lower or higher discrete value of their argument,\n+in case of @i{bound reference expression} these built-in calls deliver a\n+pointer to the previous or next element.\n+\n+@i{ABS} is defined on numeric values, i.e. integer values and floating\n+point values, delivering the corresponding absolute value.\n+\n+@i{LENGTH} is defined on\n+\n+@itemize @bullet\n+\n+@item string and text locations and string expressions, delivering the\n+length of them;\n+\n+@item event locations, delivering the @b{event length} of the mode of the\n+location;\n+\n+@item buffer locations, delivering the @b{buffer length} of the mode of\n+the location;\n+\n+@item string mode names, delivering the @b{string length} of the mode;\n+\n+@item text mode names, delivering the @b{text length} of the mode;\n+\n+@item buffer mode names, delivering the @b{buffer length} of the mode;\n+\n+@item event mode names, delivering the @b{event length} of the mode;\n+\n+@item Additionally, @i{LENGTH} also may be used on the left hand\n+side of an assignment to set a new length of a @i{varying character\n+string location}. However, to avoid undefined elements in the varying\n+string, the new length may only be less or equal to the current length.\n+Otherwise a @b{RANGEFAIL} exception will be generated.\n+@end itemize\n+\n+@i{SIN} delivers the sine of its argument (interpreted in radians).\n+\n+@i{COS} delivers the cosine of its argument (interpreted in radians).\n+\n+@i{TAN} delivers the tangent of its argument (interpreted in radians).\n+\n+@i{ARCSIN} delivers the sin -1 function of its argument.\n+\n+@i{ARCCOS} delivers the cos -1 function of its argument.\n+\n+@i{ARCTAN} delivers the tan -1 function of its argument.\n+\n+@i{EXP} delivers the exponential function, where x is the argument.\n+\n+@i{LN} delivers the natural logarithm of its argument.\n+\n+@i{LOG} delivers the base 10 logarithm of its argument.\n+\n+@i{SQRT} delivers the sqare root of its argument.\n+\n+@i{QUEUE_LENGTH} delivers either the number of sending delayed processes\n+plus the number of messages in a buffer queue (if the argument is a\n+@i{buffer location}), or the number of delayed processes (if the\n+argument specifies an @i{event location}) as @i{integer expression}.\n+\n+@i{GEN_INST} delivers an @i{instance expression} constructed from the\n+arguments. Both arguments must have the @i{&INT}-derived class.\n+\n+@i{COPY_NUMBER} delivers as @i{&INT}-derived class the copy number of an\n+@i{instance location}.\n+\n+@i{GEN_PTYPE} delivers as @i{&INT}-derived class the associated number\n+of the @i{process name}.\n+\n+@i{PROC_TYPE} delivers as @i{&INT}-derived class the process type of an\n+@i{instance expression}.\n+\n+@i{GEN_CODE} delivers as @i{&INT}-derived class the associated number of\n+the @i{process name} or @i{signal name}.\n+\n+@i{DESCR} delivers a @i{free reference expression} pointing to a\n+structure with the following layout describing the @i{location} argument.\n+\n+@example\n+SYNMODE __tmp_descr = STRUCT (p PTR, l ULONG);\n+@end example\n+\n+\n+@item 7.4.2 Associating an outside world object@*\n+The syntax of the associate built-in routine call is defined as:\n+\n+@example\n+@i{<associate built-in routine call> ::=}\n+@example\n+@i{ASSOCIATE ( <association location>, <string expression>,} [@i{, <string expression>} ] @i{)}\n+@end example\n+@end example\n+\n+The ASSOCIATE call has two parameters besides the association location:\n+a pathname and an optional mode string.\n+\n+The value of the first string expression must be a pathname according to\n+the rules of the underlying operating system. (Note that a relative pathname \n+implies a name relative to the working directory of the process.)\n+\n+The mode string may contain the value \"VARIABLE\", which requests\n+an external representation of records consisting of an UINT record\n+length followed by as many bytes of data as indicated by the length field.\n+Such a file with variable records is not indexable.\n+\n+A file with variable records can be written using any record mode. If the \n+record mode is CHARS(n) VARYING, the record length is equal to the actual \n+length of the value written.  (Different record may have differing lengths.)\n+With all other record modes, all records written using the same access mode\n+will have the same length, but will still be prefixed with the length field.\n+(Note that by re-connecting with different access modes, the external\n+representation may ultimately contain records with differing lengths.)\n+\n+A file with variable records can only be read by using a record mode of\n+CHARS(n) VARYING.\n+\n+\n+@item 7.4.2 Accessing association attributes@*\n+The value of the READABLE and WRITEABLE attributes is determined using \n+the file status call provided by the operating system.  The result will\n+depend on the device being accessed, or on the file mode.\n+\n+The INDEXABLE attribute has the value false for files with variable records,\n+and for files associated with devices not supporting random positioning\n+(character devices, FIFO special files, etc.).\n+\n+The variable attribute is true for files associated with the mode sting\n+\"VARIABLE\", and false otherwise.\n+\n+\n+@item 7.4.5 Modifying association attributes@*\n+The syntax of the MODIFY built-in routine call is defined as:\n+\n+@example\n+@i{<modify built-in call> ::=}\n+@example\n+@i{MODIFY ( <association location>, <string expression> )}\n+@end example\n+@end example\n+\n+At present, MODIFY accepts a character string containing a pathname\n+in addition to the association location, which will cause a renaming \n+of the associated file.\n+\n+\n+@item 7.4.9 Data transfer operations@*\n+READRECORD will fail (causing READFAIL) if the number of bytes from the\n+current position in the file to the end of the file is greater than zero\n+but less than the size of the record mode, and no data will be transferred.\n+(If the number of bytes is zero, no error occurs and OUTOFFILE will\n+return TRUE.)\n+\n+The number of bytes transferred by READRECORD and WRITERECORD is equal to\n+the size of the record mode of the access location. Note that the\n+internal representation of this mode may vary depending on the\n+record mode being packed or not.\n+\n+\n+@item 7.5 Text Input Output@*\n+Sequential text files will be represented so as to be compatible\n+with the standard representation of texts on the underlying operating\n+system, where control characters are used to delimit text records on files\n+as well as to control the movement of a cursor or printing head on a device.\n+\n+For indexed text files, records of a uniform length (i.e. the size of the\n+text record, including the length field) are written.  All i/o codes cause \n+an i/o transfer without any carriage control  characters being added to the\n+record, which will be expanded with spaces.\n+\n+An indexed text file is therefore not compatible with the standard\n+text representation of the underlying operating system. \n+\n+\n+\n+@item 7.5.3 Text transfer operations@*\n+The syntax of @i{<text argument>} is changed to:\n+\n+@example\n+@i{<text argument> ::=}\n+@example\n+  @i{<text location>}\n+| @i{<predefined text location>}\n+| @i{<varying string location>}\n+@end example\n+\n+@i{<predefined text location> ::=}\n+@example\n+  STDIN\n+| STDOUT\n+| STDERR\n+@end example\n+@end example\n+\n+NOTE: The identifiers STDIN, STDOUT, and STDERR are predefined.\n+Association and connection with files or devices is done according to\n+operating system rules.\n+\n+The effect of using READTEXT or WRITETEXT with a character string location\n+as a text argument (i.e. the first parameter) where the same location also\n+appears in the i/o list is undefined.\n+\n+The current implementation of formatting assumes run-to-completion semantics\n+of CHILL tasks within an image.\n+\n+\n+\n+@item 7.5.5 Conversion@*\n+Due to the implementation of @i{<floating point modes>} the syntax\n+is changed to:\n+\n+@example\n+@i{<conversion clause> ::=}\n+@example\n+@i{<conversion code> @{ <conversion qualifier @} *}\n+@i{[ <clause width> ]}\n+@end example\n+\n+@i{<conversion code> ::=}\n+@example\n+@i{B} | @i{O} | @i{H} | @i{C} | @i{F}\n+@end example\n+\n+@i{<conversion qualifier> ::=}\n+@example\n+@i{L} | @i{E} | @i{P<character>}\n+@end example\n+\n+@i{<clause width> ::=}\n+@example\n+  @i{@{ <digit> @} +} | @i{V}\n+| @i{<real clause width>}\n+@end example\n+\n+@i{<real clause width> ::=}\n+@example\n+@i{@{ @{ <digit> + | V @} : @{ @{ <digit> @} + | V @}}\n+@end example\n+@end example\n+\n+Note: The @i{<real clause width>} is only valid for @i{<conversion\n+code>} `C' or `F'.\n+\n+\n+@item 7.5.7 I/O control@*\n+To achieve compatibility of text files written with CHILL i/o with\n+the standard representation of text on the underlying operating system\n+the interpretation of the i/o control clause of the format \n+deviates from Z.200. The following table shows the i/o codes together\n+with the control characters written before and after the text record, \n+to achieve the indicated function:\n+@table @samp\n+@item /\n+Write next record (record, line feed)\n+\n+@item +\n+Write record on next page (form feed, record, line feed)\n+\n+@item -\n+Write record on current line (record, carriage return)\n+\n+@item ?\n+Write record as a prompt (carriage return, record)\n+\n+@item !\n+Emit record (record).\n+\n+@item =\n+Force new page for the next line: The control character written before\n+the next record will be form feed, irrespective of the i/o control used for\n+transferring the record.\n+@end table\n+\n+When reading a text file containing control characters other than line feed,\n+these characters have to be reckoned with by the format used to read the\n+text records.\n+\n+\n+\n+\n+@item 11.2.2 Regionality@*\n+Regionality is not implemented at all, so there is no difference in the\n+generated code when REGION is substituted by MODULE in a GNUCHILL\n+compilation unit.\n+\n+@item 11.5 Signal definition statement@*\n+The @i{<signal definition statement>} may only occur at module level.\n+\n+@item 12.3 Case Selection@*\n+The syntax of @i{<case label specification>} is changed to:\n+\n+@example\n+@i{<case label specification> ::=}\n+@example\n+@i{( <case label> @{, <case label> @} * )}\n+@end example\n+\n+@i{<case label> ::=}\n+@example\n+  @i{<discrete literal expression>}\n+| @i{<literal range>}\n+| @i{<discrete mode name>}\n+| @b{ELSE}\n+@end example\n+@end example\n+\n+@end itemize\n+\n+@node Directives\n+@chapter Compiler Directives\n+\n+@itemize @bullet\n+\n+@item ALL_STATIC_ON, ALL_STATIC_OFF@*\n+These directives control where procedure local variables are\n+allocated. ALL_STATIC_ON turns allocation of procedure local variables\n+in the data space ON, regardless of the keyword STATIC being used or not.\n+ALL_STATIC_OFF places procedure local variables in the stack space.\n+The default is ALL_STATIC_OFF.\n+\n+@item RANGE_ON, RANGE_OFF@*\n+Turns generation of rangecheck code ON and OFF.\n+\n+@item USE_SEIZE_FILE <character string literal>@*\n+Specify the filename (as a character string literal) where \n+subsequent SEIZE statements are related to. This directive \n+and the subsequent SEIZEs are written\n+to a possibly generated grant file for this module.\n+\n+@example\n+<> USE_SEIZE_FILE \"foo.grt\" <>\n+SEIZE bar;\n+@end example\n+\n+@item USE_SEIZE_FILE_RESTRICTED \"filename\"@*\n+Same as USE_SEIZE_FILE. The difference is that this directive\n+and subsequent SEIZEs are *not* written to a possibly generated\n+grant file. \n+\n+@item PROCESS_TYPE = <integer expression>@*\n+Set start value for all PROCESS delclarations. This value automatically\n+gets incremented after each PROCESS declaration and may be changed with\n+a new PROCESS_TYPE compiler directive.\n+\n+@item SIGNAL_CODE = <integer expression>@*\n+Set start value for all SIGNAL definitions. This value automatically\n+gets incremented after each SIGNAL definition and may be changed with a\n+new SIGNAL_CODE compiler directive.\n+\n+@item SEND_SIGNAL_DEFAULT_PRIORITY = <integer expression>@*\n+Set default priority for send signal action.\n+\n+@item SEND_BUFFER_DEFAULT_PRIORITY = <integer expression>@*\n+Set default priority for send buffer action.\n+\n+Note: Every <integer expression> in the above mentioned compiler\n+directives may also be specified by a SYNONYM of an integer type.\n+\n+@example\n+SYN first_signal_code = 10;\n+<> SIGNAL_CODE = first_signal_code <>\n+SIGNAL s1;\n+@end example\n+\n+@end itemize\n+\n+@node References\n+@chapter Language Definition References\n+\n+@itemize @bullet\n+@item\tCCITT High Level Language (CHILL) Recommendation Z.200\n+\tISO/IEC 9496, Geneva 1989                ISBN 92-61-03801-8\n+\n+@item\tAn Analytic Description of CHILL, the CCITT high-level\n+\tlanguage, Branquart, Louis & Wodon, Springer-Verlag 1981\n+                                                 ISBN 3-540-11196-4\n+\n+@item\tCHILL User's Manual\n+\tCCITT, Geneva 1986                       ISBN 92-61-02601-X\n+\n+@item\tIntroduction to CHILL\n+\tCCITT, Geneva 1983                       ISBN 92-61-017771-1\n+\n+@item\tCHILL CCITT High Level Language\n+\tProceedings of the 5th CHILL Conference\n+\tNorth-Holland, 1991                      ISBN 0 444 88904 3\n+\n+@item\tIntroduction to the CHILL programming Language\n+\tTELEBRAS, Campinas, Brazil 1990\n+\n+@end itemize\n+\n+Z.200 is mostly a language-lawyer's document, but more readable\n+than most.  The User's Guide is more readable by far, but doesn't\n+cover the whole language.  Our copies of these documents came through\n+Global Engineering Documents, in Irvine, CA, USA. (714)261-1455.\n+\n+@contents\n+@bye"}, {"sha": "a499a32498f90f053145f2bf73862aa58b2581ad", "filename": "gcc/ch/gperf", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fgperf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fgperf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fgperf?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,158 @@\n+struct resword {\n+  char        *name;\n+  short        token;\n+  enum rid     rid;\n+  enum toktype { RESERVED, DIRECTIVE, PREDEF } flags;\n+};\n+extern tree ridpointers [];\n+%%\n+access,\t\t\tACCESS,\t\t\tNORID,\tRESERVED\n+after,\t\t\tAFTER,\t\t\tNORID,\tRESERVED\n+all,\t\t\tALL,\t\t\tNORID,\tRESERVED\n+all_static_off,\t\tALL_STATIC_OFF,\t\tNORID,  DIRECTIVE\n+all_static_on,\t\tALL_STATIC_ON,\t\tNORID,\tDIRECTIVE\n+and,\t\t\tAND,\t\t\tNORID,\tRESERVED\n+andif,\t\t\tANDIF,\t\t\tNORID,\tRESERVED\n+array,\t\t\tARRAY,\t\t\tNORID,\tRESERVED\n+asm,\t\t\tASM_KEYWORD,\t\tNORID,\tRESERVED\n+assert,\t\t\tASSERT,\t\t\tNORID,\tRESERVED\n+at,\t\t\tAT,\t\t\tNORID,\tRESERVED\n+based,\t\t\tBASED,\t\t\tNORID,\tRESERVED\n+begin,\t\t\tBEGINTOKEN,\t\tNORID,\tRESERVED\n+bin,\t\t\tBIN,\t\t\tNORID,\tRESERVED\n+bit,\t\t\tBOOLS,\t\t\tRID_BOOLS,\tPREDEF\n+body,\t\t\tBODY,\t\t\tNORID,\tRESERVED\n+bools,\t\t\tBOOLS,\t\t\tRID_BOOLS,\tRESERVED\n+buffer,\t\t\tBUFFER,\t\t\tNORID,\tRESERVED\n+buffer_code,\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+by,\t\t\tBY,\t\t\tNORID,\tRESERVED\n+call,\t\t\tCALL,\t\t\tNORID,\tRESERVED\n+case,\t\t\tCASE,\t\t\tNORID,\tRESERVED\n+cause,\t\t\tCAUSE,\t\t\tNORID,\tRESERVED\n+ccitt_os,\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+chars,\t\t\tCHARS,\t\t\tNORID,\tRESERVED\n+context,\t\tCONTEXT,\t\tNORID,\tRESERVED\n+continue,\t\tCONTINUE,\t\tNORID,\tRESERVED\n+cycle,\t\t\tCYCLE,\t\t\tNORID,\tRESERVED\n+dcl,\t\t\tDCL,\t\t\tNORID,\tRESERVED\n+debug_lines,\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+debug_symbols,\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+debug_types,\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+delay,\t\t\tDELAY,\t\t\tNORID,\tRESERVED\n+do,\t\t\tDO,\t\t\tNORID,\tRESERVED\n+down,\t\t\tDOWN,\t\t\tNORID,\tRESERVED\n+dynamic,\t\tDYNAMIC,\t\tRID_DYNAMIC,\tRESERVED\n+else,\t\t\tELSE,\t\t\tNORID,\tRESERVED\n+elsif,\t\t\tELSIF,\t\t\tNORID,\tRESERVED\n+empty_off,\t\tEMPTY_OFF,\t\tNORID,\tDIRECTIVE\n+empty_on,\t\tEMPTY_ON,\t\tNORID,\tDIRECTIVE\n+end,\t\t\tEND,\t\t\tNORID,\tRESERVED\n+esac,\t\t\tESAC,\t\t\tNORID,\tRESERVED\n+even,\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+event,\t\t\tEVENT,\t\t\tNORID,\tRESERVED\n+event_code,\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+ever,\t\t\tEVER,\t\t\tNORID,\tRESERVED\n+exceptions,\t\tEXCEPTIONS,\t\tNORID,\tRESERVED\n+exit,\t\t\tEXIT,\t\t\tNORID,\tRESERVED\n+extra_const_seg,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+far,\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+fi,\t\t\tFI,\t\t\tNORID,\tRESERVED\n+for,\t\t\tFOR,\t\t\tNORID,\tRESERVED\n+forbid,\t\t\tFORBID,\t\t\tNORID,\tRESERVED\n+general,\t\tGENERAL,\t\tNORID,\tRESERVED\n+generate_all_set_names,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+generate_set_names,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+goto,\t\t\tGOTO,\t\t\tNORID,\tRESERVED\n+grant,\t\t\tGRANT,\t\t\tNORID,\tRESERVED\n+grant_file_size,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+if,\t\t\tIF,\t\t\tNORID,\tRESERVED\n+in,\t\t\tIN,\t\t\tRID_IN,\tRESERVED\n+init,\t\t\tINIT,\t\t\tNORID,\tRESERVED\n+inline,\t\t\tINLINE,\t\t\tRID_INLINE,\tRESERVED\n+inout,\t\t\tPARAMATTR,\t\tRID_INOUT,\tRESERVED\n+large,\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+list,\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+loc,\t\t\tLOC,\t\t\tNORID,\tRESERVED\n+make_publics_for_discrete_syns,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+medium,\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+mod,\t\t\tMOD,\t\t\tNORID,\tRESERVED\n+module,\t\t\tMODULE,\t\t\tNORID,\tRESERVED\n+multiple_const_segs,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+multiple_data_segs,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+newmode,\t\tNEWMODE,\t\tNORID,\tRESERVED\n+nolist,\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+no_overlap_check,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+nonref,\t\t\tNONREF,\t\t\tNORID,\tRESERVED\n+nopack,\t\t\tNOPACK,\t\t\tNORID,\tRESERVED\n+not,\t\t\tNOT,\t\t\tNORID,\tRESERVED\n+od,\t\t\tOD,\t\t\tNORID,\tRESERVED\n+of,\t\t\tOF,\t\t\tNORID,\tRESERVED\n+on,\t\t\tON,\t\t\tNORID,\tRESERVED\n+only_for_simulation,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+only_for_target,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+optimize,\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+optimize_runtime,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+optimization_window,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+or,\t\t\tOR,\t\t\tNORID,\tRESERVED\n+orif,\t\t\tORIF,\t\t\tNORID,\tRESERVED\n+out,\t\t\tPARAMATTR,\t\tRID_OUT,\tRESERVED\n+pack,\t\t\tPACK,\t\t\tNORID,\tRESERVED\n+page,\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+pos,\t\t\tPOS,\t\t\tNORID,\tRESERVED\n+powerset,\t\tPOWERSET,\t\tNORID,\tRESERVED\n+prefixed,\t\tPREFIXED,\t\tNORID,\tRESERVED\n+print_o_code,\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+print_symbol_table,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+priority,\t\tPRIORITY,\t\tNORID,\tRESERVED\n+proc,\t\t\tPROC,\t\t\tNORID,\tRESERVED\n+process,\t\tPROCESS,\t\tNORID,\tRESERVED\n+process_type,\t\tPROCESS_TYPE_TOKEN,\tNORID,\tDIRECTIVE\n+range,\t\t\tRANGE,\t\t\tNORID,\tRESERVED\n+range_off,\t\tRANGE_OFF,\t\tNORID,\tDIRECTIVE\n+range_on,\t\tRANGE_ON,\t\tNORID,\tDIRECTIVE\n+read,\t\t\tREAD,\t\t\tRID_READ,\tRESERVED\n+receive,\t\tRECEIVE,\t\tNORID,\tRESERVED\n+recursive,\t\tRECURSIVE,\t\tNORID,\tRESERVED\n+reentrant,\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+reentrant_all,\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+ref,\t\t\tREF,\t\t\tNORID,\tRESERVED\n+region,\t\t\tREGION,\t\t\tNORID,\tRESERVED\n+rem,\t\t\tREM,\t\t\tNORID,\tRESERVED\n+remote,\t\t\tREMOTE,\t\t\tNORID,\tRESERVED\n+result,\t\t\tRESULT,\t\t\tNORID,\tRESERVED\n+return,\t\t\tRETURN,\t\t\tNORID,\tRESERVED\n+returns,\t\tRETURNS,\t\tNORID,\tRESERVED\n+row,\t\t\tROW,\t\t\tNORID,\tRESERVED\n+seize,\t\t\tSEIZE,\t\t\tNORID,\tRESERVED\n+send,\t\t\tSEND,\t\t\tNORID,\tRESERVED\n+send_buffer_default_priority,\tSEND_BUFFER_DEFAULT_PRIORITY,\tNORID,\tDIRECTIVE\n+send_signal_default_priority,\tSEND_SIGNAL_DEFAULT_PRIORITY,\tNORID,\tDIRECTIVE\n+set,\t\t\tSET,\t\t\tNORID,\tRESERVED\n+short_pred_succ,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+signal,\t\t\tSIGNAL,\t\t\tNORID,\tRESERVED\n+signal_code,\t\tSIGNAL_CODE,\t\tNORID,\tDIRECTIVE\n+signal_max_length,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+simple,\t\t\tSIMPLE,\t\t\tNORID,\tRESERVED\n+small,\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+spec,\t\t\tSPEC,\t\t\tNORID,\tRESERVED\n+start,\t\t\tSTART,\t\t\tNORID,\tRESERVED\n+state_routine,\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+static,\t\t\tSTATIC,\t\t\tNORID,\tRESERVED\n+step,\t\t\tSTEP,\t\t\tNORID,\tRESERVED\n+stop,\t\t\tSTOP,\t\t\tNORID,\tRESERVED\n+struct,\t\t\tSTRUCT,\t\t\tNORID,\tRESERVED\n+support_causing_address,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n+syn,\t\t\tSYN,\t\t\tNORID,\tRESERVED\n+synmode,\t\tSYNMODE,\t\tNORID,\tRESERVED\n+text,\t\t\tTEXT,\t\t\tNORID,\tRESERVED\n+then,\t\t\tTHEN,\t\t\tNORID,\tRESERVED\n+this,\t\t\tTHIS,\t\t\tNORID,\tRESERVED\n+timeout,\t\tTIMEOUT,\t\tNORID,\tRESERVED\n+to,\t\t\tTO,\t\t\tNORID,\tRESERVED\n+up,\t\t\tUP,\t\t\tNORID,\tRESERVED\n+use_seize_file,\t\tUSE_SEIZE_FILE,\t\tNORID,\tDIRECTIVE\n+use_seize_file_restricted,\tUSE_SEIZE_FILE_RESTRICTED,\tNORID,\tDIRECTIVE\n+varying,\t\tVARYING,\t\tNORID,\tRESERVED\n+while,\t\t\tWHILE,\t\t\tNORID,\tRESERVED\n+with,\t\t\tWITH,\t\t\tNORID,\tRESERVED\n+xor,\t\t\tXOR,\t\t\tNORID,\tRESERVED"}, {"sha": "c3fff861ade2a7dc30bc0355c5eef32d092e6043", "filename": "gcc/ch/hash.h", "status": "added", "additions": 1059, "deletions": 0, "changes": 1059, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fhash.h?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,1059 @@\n+/* C code produced by gperf version 2.5 (GNU C++ version) */\n+/* Command-line: gperf -D -E -S1 -p -j1 -i 1 -g -o -t -k* gperf.tmp  */\n+struct resword {\n+  char        *name;\n+  short        token;\n+  enum rid     rid;\n+  enum toktype { RESERVED, DIRECTIVE, PREDEF } flags;\n+};\n+extern tree ridpointers [];\n+/* maximum key range = 2815, duplicates = 6 */\n+\n+#ifdef __GNUC__\n+inline\n+#endif\n+static unsigned int\n+hash (str, len)\n+     register char *str;\n+     register int unsigned len;\n+{\n+  static unsigned short asso_values[] =\n+    {\n+     2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n+     2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n+     2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n+     2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n+     2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n+     2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n+     2822, 2822, 2822, 2822, 2822,    4,   61,   80,   12,  350,\n+       91,   39,    3,    2, 2822,    4,  129,  155,   64,   46,\n+       65, 2822,   96,   13,    1,  135,    7,    2,    8,  124,\n+        7, 2822, 2822, 2822, 2822,    1, 2822,   94,   40,  127,\n+       21,    1,   81,    1,    1,    7, 2822,    3,   23,   74,\n+      255,  203,   70, 2822,  218,    1,   88,  124,    1,    6,\n+       10,   56,   40, 2822, 2822, 2822, 2822, 2822,\n+    };\n+  register int hval = len;\n+\n+  switch (hval)\n+    {\n+      default:\n+      case 30:\n+        hval += asso_values[str[29]];\n+      case 29:\n+        hval += asso_values[str[28]];\n+      case 28:\n+        hval += asso_values[str[27]];\n+      case 27:\n+        hval += asso_values[str[26]];\n+      case 26:\n+        hval += asso_values[str[25]];\n+      case 25:\n+        hval += asso_values[str[24]];\n+      case 24:\n+        hval += asso_values[str[23]];\n+      case 23:\n+        hval += asso_values[str[22]];\n+      case 22:\n+        hval += asso_values[str[21]];\n+      case 21:\n+        hval += asso_values[str[20]];\n+      case 20:\n+        hval += asso_values[str[19]];\n+      case 19:\n+        hval += asso_values[str[18]];\n+      case 18:\n+        hval += asso_values[str[17]];\n+      case 17:\n+        hval += asso_values[str[16]];\n+      case 16:\n+        hval += asso_values[str[15]];\n+      case 15:\n+        hval += asso_values[str[14]];\n+      case 14:\n+        hval += asso_values[str[13]];\n+      case 13:\n+        hval += asso_values[str[12]];\n+      case 12:\n+        hval += asso_values[str[11]];\n+      case 11:\n+        hval += asso_values[str[10]];\n+      case 10:\n+        hval += asso_values[str[9]];\n+      case 9:\n+        hval += asso_values[str[8]];\n+      case 8:\n+        hval += asso_values[str[7]];\n+      case 7:\n+        hval += asso_values[str[6]];\n+      case 6:\n+        hval += asso_values[str[5]];\n+      case 5:\n+        hval += asso_values[str[4]];\n+      case 4:\n+        hval += asso_values[str[3]];\n+      case 3:\n+        hval += asso_values[str[2]];\n+      case 2:\n+        hval += asso_values[str[1]];\n+      case 1:\n+        hval += asso_values[str[0]];\n+    }\n+  return hval;\n+}\n+\n+#ifdef __GNUC__\n+inline\n+#endif\n+struct resword *\n+in_word_set (str, len)\n+     register char *str;\n+     register unsigned int len;\n+{\n+  enum\n+    {\n+      TOTAL_KEYWORDS = 300,\n+      MIN_WORD_LENGTH = 2,\n+      MAX_WORD_LENGTH = 30,\n+      MIN_HASH_VALUE = 7,\n+      MAX_HASH_VALUE = 2821,\n+    };\n+\n+  static struct resword wordlist[] =\n+    {\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"AT\", \t\t\tAT,\t\t\tNORID,\tRESERVED},\n+      {\"WITH\", \t\t\tWITH,\t\t\tNORID,\tRESERVED},\n+      {\"THIS\", \t\t\tTHIS,\t\t\tNORID,\tRESERVED},\n+      {\"else\", \t\t\tELSE,\t\t\tNORID,\tRESERVED},\n+      {\"while\", \t\t\tWHILE,\t\t\tNORID,\tRESERVED},\n+      {\"TO\", \t\t\tTO,\t\t\tNORID,\tRESERVED},\n+      {\"seize\", \t\t\tSEIZE,\t\t\tNORID,\tRESERVED},\n+      {\"DO\", \t\t\tDO,\t\t\tNORID,\tRESERVED},\n+      {\"OD\", \t\t\tOD,\t\t\tNORID,\tRESERVED},\n+      {\"BIT\", \t\t\tBOOLS,\t\t\tRID_BOOLS,\tPREDEF},\n+      {\"IN\", \t\t\tIN,\t\t\tRID_IN,\tRESERVED},\n+      {\"INIT\", \t\t\tINIT,\t\t\tNORID,\tRESERVED},\n+      {\"AND\", \t\t\tAND,\t\t\tNORID,\tRESERVED},\n+      {\"fi\", \t\t\tFI,\t\t\tNORID,\tRESERVED},\n+      {\"if\", \t\t\tIF,\t\t\tNORID,\tRESERVED},\n+      {\"set\", \t\t\tSET,\t\t\tNORID,\tRESERVED},\n+      {\"FI\", \t\t\tFI,\t\t\tNORID,\tRESERVED},\n+      {\"IF\", \t\t\tIF,\t\t\tNORID,\tRESERVED},\n+      {\"by\", \t\t\tBY,\t\t\tNORID,\tRESERVED},\n+      {\"this\", \t\t\tTHIS,\t\t\tNORID,\tRESERVED},\n+      {\"with\", \t\t\tWITH,\t\t\tNORID,\tRESERVED},\n+      {\"STATIC\", \t\t\tSTATIC,\t\t\tNORID,\tRESERVED},\n+      {\"exit\", \t\t\tEXIT,\t\t\tNORID,\tRESERVED},\n+      {\"ON\", \t\t\tON,\t\t\tNORID,\tRESERVED},\n+      {\"NOT\", \t\t\tNOT,\t\t\tNORID,\tRESERVED},\n+      {\"elsif\", \t\t\tELSIF,\t\t\tNORID,\tRESERVED},\n+      {\"START\", \t\t\tSTART,\t\t\tNORID,\tRESERVED},\n+      {\"list\", \t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"POS\", \t\t\tPOS,\t\t\tNORID,\tRESERVED},\n+      {\"DOWN\", \t\t\tDOWN,\t\t\tNORID,\tRESERVED},\n+      {\"STOP\", \t\t\tSTOP,\t\t\tNORID,\tRESERVED},\n+      {\"BIN\", \t\t\tBIN,\t\t\tNORID,\tRESERVED},\n+      {\"GOTO\", \t\t\tGOTO,\t\t\tNORID,\tRESERVED},\n+      {\"bit\", \t\t\tBOOLS,\t\t\tRID_BOOLS,\tPREDEF},\n+      {\"OF\", \t\t\tOF,\t\t\tNORID,\tRESERVED},\n+      {\"all\", \t\t\tALL,\t\t\tNORID,\tRESERVED},\n+      {\"OR\", \t\t\tOR,\t\t\tNORID,\tRESERVED},\n+      {\"ROW\", \t\t\tROW,\t\t\tNORID,\tRESERVED},\n+      {\"LIST\", \t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"XOR\", \t\t\tXOR,\t\t\tNORID,\tRESERVED},\n+      {\"PACK\", \t\t\tPACK,\t\t\tNORID,\tRESERVED},\n+      {\"based\", \t\t\tBASED,\t\t\tNORID,\tRESERVED},\n+      {\"step\", \t\t\tSTEP,\t\t\tNORID,\tRESERVED},\n+      {\"page\", \t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"asm\", \t\t\tASM_KEYWORD,\t\tNORID,\tRESERVED},\n+      {\"dcl\", \t\t\tDCL,\t\t\tNORID,\tRESERVED},\n+      {\"ASM\", \t\t\tASM_KEYWORD,\t\tNORID,\tRESERVED},\n+      {\"ANDIF\", \t\t\tANDIF,\t\t\tNORID,\tRESERVED},\n+      {\"simple\", \t\t\tSIMPLE,\t\t\tNORID,\tRESERVED},\n+      {\"at\", \t\t\tAT,\t\t\tNORID,\tRESERVED},\n+      {\"OUT\", \t\t\tPARAMATTR,\t\tRID_OUT,\tRESERVED},\n+      {\"BY\", \t\t\tBY,\t\t\tNORID,\tRESERVED},\n+      {\"text\", \t\t\tTEXT,\t\t\tNORID,\tRESERVED},\n+      {\"FAR\", \t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"up\", \t\t\tUP,\t\t\tNORID,\tRESERVED},\n+      {\"delay\", \t\t\tDELAY,\t\t\tNORID,\tRESERVED},\n+      {\"CHARS\", \t\t\tCHARS,\t\t\tNORID,\tRESERVED},\n+      {\"UP\", \t\t\tUP,\t\t\tNORID,\tRESERVED},\n+      {\"spec\", \t\t\tSPEC,\t\t\tNORID,\tRESERVED},\n+      {\"SYN\", \t\t\tSYN,\t\t\tNORID,\tRESERVED},\n+      {\"GRANT\", \t\t\tGRANT,\t\t\tNORID,\tRESERVED},\n+      {\"MOD\", \t\t\tMOD,\t\t\tNORID,\tRESERVED},\n+      {\"small\", \t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"DCL\", \t\t\tDCL,\t\t\tNORID,\tRESERVED},\n+      {\"ever\", \t\t\tEVER,\t\t\tNORID,\tRESERVED},\n+      {\"do\", \t\t\tDO,\t\t\tNORID,\tRESERVED},\n+      {\"od\", \t\t\tOD,\t\t\tNORID,\tRESERVED},\n+      {\"case\", \t\t\tCASE,\t\t\tNORID,\tRESERVED},\n+      {\"esac\", \t\t\tESAC,\t\t\tNORID,\tRESERVED},\n+      {\"CCITT_OS\", \t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"FOR\", \t\t\tFOR,\t\t\tNORID,\tRESERVED},\n+      {\"ORIF\", \t\t\tORIF,\t\t\tNORID,\tRESERVED},\n+      {\"BODY\", \t\t\tBODY,\t\t\tNORID,\tRESERVED},\n+      {\"INOUT\", \t\t\tPARAMATTR,\t\tRID_INOUT,\tRESERVED},\n+      {\"SIGNAL\", \t\t\tSIGNAL,\t\t\tNORID,\tRESERVED},\n+      {\"LOC\", \t\t\tLOC,\t\t\tNORID,\tRESERVED},\n+      {\"NOLIST\", \t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"even\", \t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"in\", \t\t\tIN,\t\t\tRID_IN,\tRESERVED},\n+      {\"ALL\", \t\t\tALL,\t\t\tNORID,\tRESERVED},\n+      {\"NOPACK\", \t\t\tNOPACK,\t\t\tNORID,\tRESERVED},\n+      {\"call\", \t\t\tCALL,\t\t\tNORID,\tRESERVED},\n+      {\"pos\", \t\t\tPOS,\t\t\tNORID,\tRESERVED},\n+      {\"end\", \t\t\tEND,\t\t\tNORID,\tRESERVED},\n+      {\"send\", \t\t\tSEND,\t\t\tNORID,\tRESERVED},\n+      {\"of\", \t\t\tOF,\t\t\tNORID,\tRESERVED},\n+      {\"PROC\", \t\t\tPROC,\t\t\tNORID,\tRESERVED},\n+      {\"to\", \t\t\tTO,\t\t\tNORID,\tRESERVED},\n+      {\"rem\", \t\t\tREM,\t\t\tNORID,\tRESERVED},\n+      {\"pack\", \t\t\tPACK,\t\t\tNORID,\tRESERVED},\n+      {\"BOOLS\", \t\t\tBOOLS,\t\t\tRID_BOOLS,\tRESERVED},\n+      {\"mod\", \t\t\tMOD,\t\t\tNORID,\tRESERVED},\n+      {\"ref\", \t\t\tREF,\t\t\tNORID,\tRESERVED},\n+      {\"use_seize_file\", \t\tUSE_SEIZE_FILE,\t\tNORID,\tDIRECTIVE},\n+      {\"bin\", \t\t\tBIN,\t\t\tNORID,\tRESERVED},\n+      {\"medium\", \t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"begin\", \t\t\tBEGINTOKEN,\t\tNORID,\tRESERVED},\n+      {\"FORBID\", \t\t\tFORBID,\t\t\tNORID,\tRESERVED},\n+      {\"syn\", \t\t\tSYN,\t\t\tNORID,\tRESERVED},\n+      {\"body\", \t\t\tBODY,\t\t\tNORID,\tRESERVED},\n+      {\"ARRAY\", \t\t\tARRAY,\t\t\tNORID,\tRESERVED},\n+      {\"STRUCT\", \t\t\tSTRUCT,\t\t\tNORID,\tRESERVED},\n+      {\"read\", \t\t\tREAD,\t\t\tRID_READ,\tRESERVED},\n+      {\"cycle\", \t\t\tCYCLE,\t\t\tNORID,\tRESERVED},\n+      {\"large\", \t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"VARYING\", \t\tVARYING,\t\tNORID,\tRESERVED},\n+      {\"CALL\", \t\t\tCALL,\t\t\tNORID,\tRESERVED},\n+      {\"then\", \t\t\tTHEN,\t\t\tNORID,\tRESERVED},\n+      {\"event\", \t\t\tEVENT,\t\t\tNORID,\tRESERVED},\n+      {\"cause\", \t\t\tCAUSE,\t\t\tNORID,\tRESERVED},\n+      {\"loc\", \t\t\tLOC,\t\t\tNORID,\tRESERVED},\n+      {\"access\", \t\t\tACCESS,\t\t\tNORID,\tRESERVED},\n+      {\"init\", \t\t\tINIT,\t\t\tNORID,\tRESERVED},\n+      {\"receive\", \t\tRECEIVE,\t\tNORID,\tRESERVED},\n+      {\"TEXT\", \t\t\tTEXT,\t\t\tNORID,\tRESERVED},\n+      {\"EXIT\", \t\t\tEXIT,\t\t\tNORID,\tRESERVED},\n+      {\"stop\", \t\t\tSTOP,\t\t\tNORID,\tRESERVED},\n+      {\"SET\", \t\t\tSET,\t\t\tNORID,\tRESERVED},\n+      {\"and\", \t\t\tAND,\t\t\tNORID,\tRESERVED},\n+      {\"signal\", \t\t\tSIGNAL,\t\t\tNORID,\tRESERVED},\n+      {\"far\", \t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"assert\", \t\t\tASSERT,\t\t\tNORID,\tRESERVED},\n+      {\"static\", \t\t\tSTATIC,\t\t\tNORID,\tRESERVED},\n+      {\"debug_types\", \t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"prefixed\", \t\tPREFIXED,\t\tNORID,\tRESERVED},\n+      {\"out\", \t\t\tPARAMATTR,\t\tRID_OUT,\tRESERVED},\n+      {\"THEN\", \t\t\tTHEN,\t\t\tNORID,\tRESERVED},\n+      {\"or\", \t\t\tOR,\t\t\tNORID,\tRESERVED},\n+      {\"END\", \t\t\tEND,\t\t\tNORID,\tRESERVED},\n+      {\"row\", \t\t\tROW,\t\t\tNORID,\tRESERVED},\n+      {\"STEP\", \t\t\tSTEP,\t\t\tNORID,\tRESERVED},\n+      {\"xor\", \t\t\tXOR,\t\t\tNORID,\tRESERVED},\n+      {\"SMALL\", \t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"PRIORITY\", \t\tPRIORITY,\t\tNORID,\tRESERVED},\n+      {\"SEND\", \t\t\tSEND,\t\t\tNORID,\tRESERVED},\n+      {\"BASED\", \t\t\tBASED,\t\t\tNORID,\tRESERVED},\n+      {\"chars\", \t\t\tCHARS,\t\t\tNORID,\tRESERVED},\n+      {\"DYNAMIC\", \t\tDYNAMIC,\t\tRID_DYNAMIC,\tRESERVED},\n+      {\"CASE\", \t\t\tCASE,\t\t\tNORID,\tRESERVED},\n+      {\"ESAC\", \t\t\tESAC,\t\t\tNORID,\tRESERVED},\n+      {\"module\", \t\t\tMODULE,\t\t\tNORID,\tRESERVED},\n+      {\"on\", \t\t\tON,\t\t\tNORID,\tRESERVED},\n+      {\"result\", \t\t\tRESULT,\t\t\tNORID,\tRESERVED},\n+      {\"PAGE\", \t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"andif\", \t\t\tANDIF,\t\t\tNORID,\tRESERVED},\n+      {\"READ\", \t\t\tREAD,\t\t\tRID_READ,\tRESERVED},\n+      {\"bools\", \t\t\tBOOLS,\t\t\tRID_BOOLS,\tRESERVED},\n+      {\"ASSERT\", \t\t\tASSERT,\t\t\tNORID,\tRESERVED},\n+      {\"debug_lines\", \t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"after\", \t\t\tAFTER,\t\t\tNORID,\tRESERVED},\n+      {\"ALL_STATIC_ON\", \t\tALL_STATIC_ON,\t\tNORID,\tDIRECTIVE},\n+      {\"down\", \t\t\tDOWN,\t\t\tNORID,\tRESERVED},\n+      {\"WHILE\", \t\t\tWHILE,\t\t\tNORID,\tRESERVED},\n+      {\"start\", \t\t\tSTART,\t\t\tNORID,\tRESERVED},\n+      {\"optimize\", \t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"goto\", \t\t\tGOTO,\t\t\tNORID,\tRESERVED},\n+      {\"for\", \t\t\tFOR,\t\t\tNORID,\tRESERVED},\n+      {\"SPEC\", \t\t\tSPEC,\t\t\tNORID,\tRESERVED},\n+      {\"orif\", \t\t\tORIF,\t\t\tNORID,\tRESERVED},\n+      {\"BEGIN\", \t\t\tBEGINTOKEN,\t\tNORID,\tRESERVED},\n+      {\"REF\", \t\t\tREF,\t\t\tNORID,\tRESERVED},\n+      {\"OPTIMIZATION_WINDOW\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"ACCESS\", \t\t\tACCESS,\t\t\tNORID,\tRESERVED},\n+      {\"AFTER\", \t\t\tAFTER,\t\t\tNORID,\tRESERVED},\n+      {\"not\", \t\t\tNOT,\t\t\tNORID,\tRESERVED},\n+      {\"buffer\", \t\t\tBUFFER,\t\t\tNORID,\tRESERVED},\n+      {\"inline\", \t\t\tINLINE,\t\t\tRID_INLINE,\tRESERVED},\n+      {\"CONTEXT\", \t\tCONTEXT,\t\tNORID,\tRESERVED},\n+      {\"RANGE\", \t\t\tRANGE,\t\t\tNORID,\tRESERVED},\n+      {\"newmode\", \t\tNEWMODE,\t\tNORID,\tRESERVED},\n+      {\"range\", \t\t\tRANGE,\t\t\tNORID,\tRESERVED},\n+      {\"forbid\", \t\t\tFORBID,\t\t\tNORID,\tRESERVED},\n+      {\"nolist\", \t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"CAUSE\", \t\t\tCAUSE,\t\t\tNORID,\tRESERVED},\n+      {\"ELSIF\", \t\t\tELSIF,\t\t\tNORID,\tRESERVED},\n+      {\"remote\", \t\t\tREMOTE,\t\t\tNORID,\tRESERVED},\n+      {\"timeout\", \t\tTIMEOUT,\t\tNORID,\tRESERVED},\n+      {\"powerset\", \t\tPOWERSET,\t\tNORID,\tRESERVED},\n+      {\"debug_symbols\", \t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"general\", \t\tGENERAL,\t\tNORID,\tRESERVED},\n+      {\"REGION\", \t\t\tREGION,\t\t\tNORID,\tRESERVED},\n+      {\"REM\", \t\t\tREM,\t\t\tNORID,\tRESERVED},\n+      {\"ALL_STATIC_OFF\", \t\tALL_STATIC_OFF,\t\tNORID,  DIRECTIVE},\n+      {\"INLINE\", \t\t\tINLINE,\t\t\tRID_INLINE,\tRESERVED},\n+      {\"synmode\", \t\tSYNMODE,\t\tNORID,\tRESERVED},\n+      {\"proc\", \t\t\tPROC,\t\t\tNORID,\tRESERVED},\n+      {\"LARGE\", \t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"DELAY\", \t\t\tDELAY,\t\t\tNORID,\tRESERVED},\n+      {\"process\", \t\tPROCESS,\t\tNORID,\tRESERVED},\n+      {\"OPTIMIZE\", \t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"varying\", \t\tVARYING,\t\tNORID,\tRESERVED},\n+      {\"dynamic\", \t\tDYNAMIC,\t\tRID_DYNAMIC,\tRESERVED},\n+      {\"ccitt_os\", \t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"struct\", \t\t\tSTRUCT,\t\t\tNORID,\tRESERVED},\n+      {\"grant\", \t\t\tGRANT,\t\t\tNORID,\tRESERVED},\n+      {\"empty_off\", \t\tEMPTY_OFF,\t\tNORID,\tDIRECTIVE},\n+      {\"PROCESS\", \t\tPROCESS,\t\tNORID,\tRESERVED},\n+      {\"RANGE_ON\", \t\tRANGE_ON,\t\tNORID,\tDIRECTIVE},\n+      {\"inout\", \t\t\tPARAMATTR,\t\tRID_INOUT,\tRESERVED},\n+      {\"array\", \t\t\tARRAY,\t\t\tNORID,\tRESERVED},\n+      {\"region\", \t\t\tREGION,\t\t\tNORID,\tRESERVED},\n+      {\"TIMEOUT\", \t\tTIMEOUT,\t\tNORID,\tRESERVED},\n+      {\"recursive\", \t\tRECURSIVE,\t\tNORID,\tRESERVED},\n+      {\"event_code\", \t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"NONREF\", \t\t\tNONREF,\t\t\tNORID,\tRESERVED},\n+      {\"SIMPLE\", \t\t\tSIMPLE,\t\t\tNORID,\tRESERVED},\n+      {\"SEIZE\", \t\t\tSEIZE,\t\t\tNORID,\tRESERVED},\n+      {\"RESULT\", \t\t\tRESULT,\t\t\tNORID,\tRESERVED},\n+      {\"multiple_data_segs\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"signal_code\", \t\tSIGNAL_CODE,\t\tNORID,\tDIRECTIVE},\n+      {\"RETURN\", \t\t\tRETURN,\t\t\tNORID,\tRESERVED},\n+      {\"CONTINUE\", \t\tCONTINUE,\t\tNORID,\tRESERVED},\n+      {\"SIGNAL_CODE\", \t\tSIGNAL_CODE,\t\tNORID,\tDIRECTIVE},\n+      {\"empty_on\", \t\tEMPTY_ON,\t\tNORID,\tDIRECTIVE},\n+      {\"nopack\", \t\t\tNOPACK,\t\t\tNORID,\tRESERVED},\n+      {\"RETURNS\", \t\tRETURNS,\t\tNORID,\tRESERVED},\n+      {\"CYCLE\", \t\t\tCYCLE,\t\t\tNORID,\tRESERVED},\n+      {\"SYNMODE\", \t\tSYNMODE,\t\tNORID,\tRESERVED},\n+      {\"exceptions\", \t\tEXCEPTIONS,\t\tNORID,\tRESERVED},\n+      {\"EVEN\", \t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"PRINT_O_CODE\", \t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"EVENT\", \t\t\tEVENT,\t\t\tNORID,\tRESERVED},\n+      {\"context\", \t\tCONTEXT,\t\tNORID,\tRESERVED},\n+      {\"RANGE_OFF\", \t\tRANGE_OFF,\t\tNORID,\tDIRECTIVE},\n+      {\"EVER\", \t\t\tEVER,\t\t\tNORID,\tRESERVED},\n+      {\"EMPTY_ON\", \t\tEMPTY_ON,\t\tNORID,\tDIRECTIVE},\n+      {\"MEDIUM\", \t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"BUFFER\", \t\t\tBUFFER,\t\t\tNORID,\tRESERVED},\n+      {\"MODULE\", \t\t\tMODULE,\t\t\tNORID,\tRESERVED},\n+      {\"grant_file_size\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"ELSE\", \t\t\tELSE,\t\t\tNORID,\tRESERVED},\n+      {\"process_type\", \t\tPROCESS_TYPE_TOKEN,\tNORID,\tDIRECTIVE},\n+      {\"priority\", \t\tPRIORITY,\t\tNORID,\tRESERVED},\n+      {\"buffer_code\", \t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"return\", \t\t\tRETURN,\t\t\tNORID,\tRESERVED},\n+      {\"returns\", \t\tRETURNS,\t\tNORID,\tRESERVED},\n+      {\"all_static_off\", \t\tALL_STATIC_OFF,\t\tNORID,  DIRECTIVE},\n+      {\"POWERSET\", \t\tPOWERSET,\t\tNORID,\tRESERVED},\n+      {\"EMPTY_OFF\", \t\tEMPTY_OFF,\t\tNORID,\tDIRECTIVE},\n+      {\"range_off\", \t\tRANGE_OFF,\t\tNORID,\tDIRECTIVE},\n+      {\"signal_max_length\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"PREFIXED\", \t\tPREFIXED,\t\tNORID,\tRESERVED},\n+      {\"NEWMODE\", \t\tNEWMODE,\t\tNORID,\tRESERVED},\n+      {\"EXCEPTIONS\", \t\tEXCEPTIONS,\t\tNORID,\tRESERVED},\n+      {\"REMOTE\", \t\t\tREMOTE,\t\t\tNORID,\tRESERVED},\n+      {\"SHORT_PRED_SUCC\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"all_static_on\", \t\tALL_STATIC_ON,\t\tNORID,\tDIRECTIVE},\n+      {\"nonref\", \t\t\tNONREF,\t\t\tNORID,\tRESERVED},\n+      {\"SIGNAL_MAX_LENGTH\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"REENTRANT\", \t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"range_on\", \t\tRANGE_ON,\t\tNORID,\tDIRECTIVE},\n+      {\"GENERAL\", \t\tGENERAL,\t\tNORID,\tRESERVED},\n+      {\"continue\", \t\tCONTINUE,\t\tNORID,\tRESERVED},\n+      {\"STATE_ROUTINE\", \t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"EXTRA_CONST_SEG\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"use_seize_file_restricted\", \tUSE_SEIZE_FILE_RESTRICTED,\tNORID,\tDIRECTIVE},\n+      {\"ONLY_FOR_TARGET\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"extra_const_seg\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"multiple_const_segs\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"RECURSIVE\", \t\tRECURSIVE,\t\tNORID,\tRESERVED},\n+      {\"DEBUG_SYMBOLS\", \t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"DEBUG_TYPES\", \t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"GRANT_FILE_SIZE\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"DEBUG_LINES\", \t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"ONLY_FOR_SIMULATION\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"state_routine\", \t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"generate_set_names\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"print_o_code\", \t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"PROCESS_TYPE\", \t\tPROCESS_TYPE_TOKEN,\tNORID,\tDIRECTIVE},\n+      {\"short_pred_succ\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"reentrant\", \t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"RECEIVE\", \t\tRECEIVE,\t\tNORID,\tRESERVED},\n+      {\"EVENT_CODE\", \t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"optimize_runtime\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"SUPPORT_CAUSING_ADDRESS\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"print_symbol_table\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"REENTRANT_ALL\", \t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"PRINT_SYMBOL_TABLE\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"BUFFER_CODE\", \t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"generate_all_set_names\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"NO_OVERLAP_CHECK\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"no_overlap_check\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"reentrant_all\", \t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"MULTIPLE_DATA_SEGS\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"OPTIMIZE_RUNTIME\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"only_for_target\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"MULTIPLE_CONST_SEGS\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"optimization_window\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"support_causing_address\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"USE_SEIZE_FILE\", \t\tUSE_SEIZE_FILE,\t\tNORID,\tDIRECTIVE},\n+      {\"SEND_SIGNAL_DEFAULT_PRIORITY\", \tSEND_SIGNAL_DEFAULT_PRIORITY,\tNORID,\tDIRECTIVE},\n+      {\"make_publics_for_discrete_syns\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"only_for_simulation\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"send_signal_default_priority\", \tSEND_SIGNAL_DEFAULT_PRIORITY,\tNORID,\tDIRECTIVE},\n+      {\"send_buffer_default_priority\", \tSEND_BUFFER_DEFAULT_PRIORITY,\tNORID,\tDIRECTIVE},\n+      {\"GENERATE_SET_NAMES\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"MAKE_PUBLICS_FOR_DISCRETE_SYNS\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"SEND_BUFFER_DEFAULT_PRIORITY\", \tSEND_BUFFER_DEFAULT_PRIORITY,\tNORID,\tDIRECTIVE},\n+      {\"GENERATE_ALL_SET_NAMES\", \tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n+      {\"USE_SEIZE_FILE_RESTRICTED\", \tUSE_SEIZE_FILE_RESTRICTED,\tNORID,\tDIRECTIVE},\n+    };\n+\n+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n+    {\n+      register int key = hash (str, len);\n+\n+      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)\n+        {\n+            {\n+              struct resword  *resword; \n+\n+              switch (key)\n+                {\n+                case     7:\n+                  resword = &wordlist[7]; break;\n+                case    12:\n+                  resword = &wordlist[8]; break;\n+                case    23:\n+                  resword = &wordlist[9]; break;\n+                case    30:\n+                  resword = &wordlist[10]; break;\n+                case    43:\n+                  resword = &wordlist[11]; break;\n+                case    49:\n+                  resword = &wordlist[12]; break;\n+                case    55:\n+                  resword = &wordlist[13]; break;\n+                case    60:\n+                  resword = &wordlist[14];\n+                  if (*str == *resword->name && !strcmp (str + 1, resword->name + 1)) return resword;\n+                  resword = &wordlist[15];\n+                  if (*str == *resword->name && !strcmp (str + 1, resword->name + 1)) return resword;\n+                  return 0;\n+                case    67:\n+                  resword = &wordlist[16]; break;\n+                case    68:\n+                  resword = &wordlist[17]; break;\n+                case    73:\n+                  resword = &wordlist[18]; break;\n+                case    83:\n+                  resword = &wordlist[19]; break;\n+                case    90:\n+                  resword = &wordlist[20];\n+                  if (*str == *resword->name && !strcmp (str + 1, resword->name + 1)) return resword;\n+                  resword = &wordlist[21];\n+                  if (*str == *resword->name && !strcmp (str + 1, resword->name + 1)) return resword;\n+                  return 0;\n+                case    93:\n+                  resword = &wordlist[22]; break;\n+                case    95:\n+                  resword = &wordlist[23];\n+                  if (*str == *resword->name && !strcmp (str + 1, resword->name + 1)) return resword;\n+                  resword = &wordlist[24];\n+                  if (*str == *resword->name && !strcmp (str + 1, resword->name + 1)) return resword;\n+                  return 0;\n+                case    98:\n+                  resword = &wordlist[25]; break;\n+                case   101:\n+                  resword = &wordlist[26]; break;\n+                case   106:\n+                  resword = &wordlist[27]; break;\n+                case   107:\n+                  resword = &wordlist[28]; break;\n+                case   110:\n+                  resword = &wordlist[29]; break;\n+                case   112:\n+                  resword = &wordlist[30]; break;\n+                case   114:\n+                  resword = &wordlist[31]; break;\n+                case   118:\n+                  resword = &wordlist[32]; break;\n+                case   120:\n+                  resword = &wordlist[33]; break;\n+                case   123:\n+                  resword = &wordlist[34]; break;\n+                case   127:\n+                  resword = &wordlist[35]; break;\n+                case   128:\n+                  resword = &wordlist[36]; break;\n+                case   129:\n+                  resword = &wordlist[37]; break;\n+                case   130:\n+                  resword = &wordlist[38]; break;\n+                case   136:\n+                  resword = &wordlist[39]; break;\n+                case   138:\n+                  resword = &wordlist[40]; break;\n+                case   139:\n+                  resword = &wordlist[41]; break;\n+                case   143:\n+                  resword = &wordlist[42]; break;\n+                case   144:\n+                  resword = &wordlist[43]; break;\n+                case   147:\n+                  resword = &wordlist[44]; break;\n+                case   149:\n+                  resword = &wordlist[45]; break;\n+                case   153:\n+                  resword = &wordlist[46]; break;\n+                case   157:\n+                  resword = &wordlist[47]; break;\n+                case   162:\n+                  resword = &wordlist[48]; break;\n+                case   164:\n+                  resword = &wordlist[49]; break;\n+                case   170:\n+                  resword = &wordlist[50]; break;\n+                case   172:\n+                  resword = &wordlist[51]; break;\n+                case   174:\n+                  resword = &wordlist[52]; break;\n+                case   175:\n+                  resword = &wordlist[53]; break;\n+                case   178:\n+                  resword = &wordlist[54]; break;\n+                case   182:\n+                  resword = &wordlist[55]; break;\n+                case   184:\n+                  resword = &wordlist[56]; break;\n+                case   185:\n+                  resword = &wordlist[57]; break;\n+                case   187:\n+                  resword = &wordlist[58]; break;\n+                case   191:\n+                  resword = &wordlist[59]; break;\n+                case   194:\n+                  resword = &wordlist[60]; break;\n+                case   196:\n+                  resword = &wordlist[61]; break;\n+                case   200:\n+                  resword = &wordlist[62]; break;\n+                case   201:\n+                  resword = &wordlist[63]; break;\n+                case   202:\n+                  resword = &wordlist[64]; break;\n+                case   203:\n+                  resword = &wordlist[65]; break;\n+                case   204:\n+                  resword = &wordlist[66]; break;\n+                case   209:\n+                  resword = &wordlist[67]; break;\n+                case   216:\n+                  resword = &wordlist[68]; break;\n+                case   220:\n+                  resword = &wordlist[69]; break;\n+                case   224:\n+                  resword = &wordlist[70]; break;\n+                case   225:\n+                  resword = &wordlist[71]; break;\n+                case   226:\n+                  resword = &wordlist[72];\n+                  if (*str == *resword->name && !strcmp (str + 1, resword->name + 1)) return resword;\n+                  resword = &wordlist[73];\n+                  if (*str == *resword->name && !strcmp (str + 1, resword->name + 1)) return resword;\n+                  return 0;\n+                case   227:\n+                  resword = &wordlist[74];\n+                  if (*str == *resword->name && !strcmp (str + 1, resword->name + 1)) return resword;\n+                  resword = &wordlist[75];\n+                  if (*str == *resword->name && !strcmp (str + 1, resword->name + 1)) return resword;\n+                  return 0;\n+                case   232:\n+                  resword = &wordlist[76]; break;\n+                case   236:\n+                  resword = &wordlist[77]; break;\n+                case   239:\n+                  resword = &wordlist[78]; break;\n+                case   247:\n+                  resword = &wordlist[79]; break;\n+                case   253:\n+                  resword = &wordlist[80]; break;\n+                case   257:\n+                  resword = &wordlist[81]; break;\n+                case   258:\n+                  resword = &wordlist[82]; break;\n+                case   261:\n+                  resword = &wordlist[83]; break;\n+                case   262:\n+                  resword = &wordlist[84]; break;\n+                case   264:\n+                  resword = &wordlist[85]; break;\n+                case   265:\n+                  resword = &wordlist[86]; break;\n+                case   269:\n+                  resword = &wordlist[87]; break;\n+                case   271:\n+                  resword = &wordlist[88]; break;\n+                case   277:\n+                  resword = &wordlist[89]; break;\n+                case   280:\n+                  resword = &wordlist[90]; break;\n+                case   282:\n+                  resword = &wordlist[91]; break;\n+                case   286:\n+                  resword = &wordlist[92]; break;\n+                case   291:\n+                  resword = &wordlist[93]; break;\n+                case   293:\n+                  resword = &wordlist[94]; break;\n+                case   296:\n+                  resword = &wordlist[95]; break;\n+                case   298:\n+                  resword = &wordlist[96]; break;\n+                case   300:\n+                  resword = &wordlist[97]; break;\n+                case   301:\n+                  resword = &wordlist[98]; break;\n+                case   303:\n+                  resword = &wordlist[99]; break;\n+                case   304:\n+                  resword = &wordlist[100]; break;\n+                case   305:\n+                  resword = &wordlist[101]; break;\n+                case   307:\n+                  resword = &wordlist[102]; break;\n+                case   309:\n+                  resword = &wordlist[103]; break;\n+                case   314:\n+                  resword = &wordlist[104]; break;\n+                case   315:\n+                  resword = &wordlist[105]; break;\n+                case   324:\n+                  resword = &wordlist[106]; break;\n+                case   329:\n+                  resword = &wordlist[107]; break;\n+                case   332:\n+                  resword = &wordlist[108]; break;\n+                case   338:\n+                  resword = &wordlist[109]; break;\n+                case   339:\n+                  resword = &wordlist[110]; break;\n+                case   342:\n+                  resword = &wordlist[111]; break;\n+                case   343:\n+                  resword = &wordlist[112]; break;\n+                case   346:\n+                  resword = &wordlist[113]; break;\n+                case   349:\n+                  resword = &wordlist[114]; break;\n+                case   351:\n+                  resword = &wordlist[115]; break;\n+                case   352:\n+                  resword = &wordlist[116]; break;\n+                case   356:\n+                  resword = &wordlist[117]; break;\n+                case   357:\n+                  resword = &wordlist[118]; break;\n+                case   361:\n+                  resword = &wordlist[119]; break;\n+                case   363:\n+                  resword = &wordlist[120]; break;\n+                case   364:\n+                  resword = &wordlist[121]; break;\n+                case   365:\n+                  resword = &wordlist[122]; break;\n+                case   366:\n+                  resword = &wordlist[123]; break;\n+                case   367:\n+                  resword = &wordlist[124]; break;\n+                case   373:\n+                  resword = &wordlist[125]; break;\n+                case   387:\n+                  resword = &wordlist[126]; break;\n+                case   396:\n+                  resword = &wordlist[127]; break;\n+                case   409:\n+                  resword = &wordlist[128]; break;\n+                case   411:\n+                  resword = &wordlist[129]; break;\n+                case   415:\n+                  resword = &wordlist[130]; break;\n+                case   417:\n+                  resword = &wordlist[131]; break;\n+                case   418:\n+                  resword = &wordlist[132]; break;\n+                case   422:\n+                  resword = &wordlist[133]; break;\n+                case   423:\n+                  resword = &wordlist[134]; break;\n+                case   429:\n+                  resword = &wordlist[135]; break;\n+                case   430:\n+                  resword = &wordlist[136]; break;\n+                case   433:\n+                  resword = &wordlist[137]; break;\n+                case   434:\n+                  resword = &wordlist[138]; break;\n+                case   435:\n+                  resword = &wordlist[139]; break;\n+                case   440:\n+                  resword = &wordlist[140]; break;\n+                case   443:\n+                  resword = &wordlist[141]; break;\n+                case   445:\n+                  resword = &wordlist[142]; break;\n+                case   446:\n+                  resword = &wordlist[143]; break;\n+                case   448:\n+                  resword = &wordlist[144]; break;\n+                case   451:\n+                  resword = &wordlist[145];\n+                  if (*str == *resword->name && !strcmp (str + 1, resword->name + 1)) return resword;\n+                  resword = &wordlist[146];\n+                  if (*str == *resword->name && !strcmp (str + 1, resword->name + 1)) return resword;\n+                  return 0;\n+                case   452:\n+                  resword = &wordlist[147]; break;\n+                case   460:\n+                  resword = &wordlist[148]; break;\n+                case   461:\n+                  resword = &wordlist[149]; break;\n+                case   462:\n+                  resword = &wordlist[150]; break;\n+                case   463:\n+                  resword = &wordlist[151]; break;\n+                case   466:\n+                  resword = &wordlist[152]; break;\n+                case   475:\n+                  resword = &wordlist[153]; break;\n+                case   483:\n+                  resword = &wordlist[154]; break;\n+                case   486:\n+                  resword = &wordlist[155]; break;\n+                case   487:\n+                  resword = &wordlist[156]; break;\n+                case   488:\n+                  resword = &wordlist[157]; break;\n+                case   489:\n+                  resword = &wordlist[158]; break;\n+                case   491:\n+                  resword = &wordlist[159]; break;\n+                case   494:\n+                  resword = &wordlist[160]; break;\n+                case   498:\n+                  resword = &wordlist[161]; break;\n+                case   499:\n+                  resword = &wordlist[162]; break;\n+                case   505:\n+                  resword = &wordlist[163]; break;\n+                case   512:\n+                  resword = &wordlist[164]; break;\n+                case   513:\n+                  resword = &wordlist[165]; break;\n+                case   521:\n+                  resword = &wordlist[166]; break;\n+                case   540:\n+                  resword = &wordlist[167]; break;\n+                case   543:\n+                  resword = &wordlist[168]; break;\n+                case   546:\n+                  resword = &wordlist[169]; break;\n+                case   547:\n+                  resword = &wordlist[170]; break;\n+                case   549:\n+                  resword = &wordlist[171]; break;\n+                case   551:\n+                  resword = &wordlist[172]; break;\n+                case   554:\n+                  resword = &wordlist[173]; break;\n+                case   557:\n+                  resword = &wordlist[174]; break;\n+                case   558:\n+                  resword = &wordlist[175]; break;\n+                case   568:\n+                  resword = &wordlist[176]; break;\n+                case   574:\n+                  resword = &wordlist[177]; break;\n+                case   576:\n+                  resword = &wordlist[178]; break;\n+                case   583:\n+                  resword = &wordlist[179]; break;\n+                case   587:\n+                  resword = &wordlist[180]; break;\n+                case   590:\n+                  resword = &wordlist[181]; break;\n+                case   591:\n+                  resword = &wordlist[182]; break;\n+                case   592:\n+                  resword = &wordlist[183]; break;\n+                case   596:\n+                  resword = &wordlist[184]; break;\n+                case   599:\n+                  resword = &wordlist[185]; break;\n+                case   600:\n+                  resword = &wordlist[186]; break;\n+                case   603:\n+                  resword = &wordlist[187]; break;\n+                case   604:\n+                  resword = &wordlist[188]; break;\n+                case   607:\n+                  resword = &wordlist[189]; break;\n+                case   617:\n+                  resword = &wordlist[190]; break;\n+                case   618:\n+                  resword = &wordlist[191]; break;\n+                case   622:\n+                  resword = &wordlist[192]; break;\n+                case   623:\n+                  resword = &wordlist[193]; break;\n+                case   624:\n+                  resword = &wordlist[194]; break;\n+                case   628:\n+                  resword = &wordlist[195]; break;\n+                case   636:\n+                  resword = &wordlist[196]; break;\n+                case   639:\n+                  resword = &wordlist[197]; break;\n+                case   641:\n+                  resword = &wordlist[198]; break;\n+                case   650:\n+                  resword = &wordlist[199]; break;\n+                case   652:\n+                  resword = &wordlist[200]; break;\n+                case   661:\n+                  resword = &wordlist[201]; break;\n+                case   664:\n+                  resword = &wordlist[202]; break;\n+                case   670:\n+                  resword = &wordlist[203]; break;\n+                case   672:\n+                  resword = &wordlist[204]; break;\n+                case   682:\n+                  resword = &wordlist[205]; break;\n+                case   685:\n+                  resword = &wordlist[206]; break;\n+                case   691:\n+                  resword = &wordlist[207]; break;\n+                case   697:\n+                  resword = &wordlist[208]; break;\n+                case   707:\n+                  resword = &wordlist[209]; break;\n+                case   709:\n+                  resword = &wordlist[210]; break;\n+                case   717:\n+                  resword = &wordlist[211]; break;\n+                case   720:\n+                  resword = &wordlist[212]; break;\n+                case   727:\n+                  resword = &wordlist[213]; break;\n+                case   730:\n+                  resword = &wordlist[214]; break;\n+                case   731:\n+                  resword = &wordlist[215]; break;\n+                case   745:\n+                  resword = &wordlist[216]; break;\n+                case   748:\n+                  resword = &wordlist[217]; break;\n+                case   750:\n+                  resword = &wordlist[218]; break;\n+                case   751:\n+                  resword = &wordlist[219]; break;\n+                case   756:\n+                  resword = &wordlist[220]; break;\n+                case   758:\n+                  resword = &wordlist[221]; break;\n+                case   762:\n+                  resword = &wordlist[222]; break;\n+                case   768:\n+                  resword = &wordlist[223]; break;\n+                case   771:\n+                  resword = &wordlist[224]; break;\n+                case   773:\n+                  resword = &wordlist[225]; break;\n+                case   775:\n+                  resword = &wordlist[226]; break;\n+                case   776:\n+                  resword = &wordlist[227]; break;\n+                case   777:\n+                  resword = &wordlist[228]; break;\n+                case   779:\n+                  resword = &wordlist[229]; break;\n+                case   791:\n+                  resword = &wordlist[230]; break;\n+                case   807:\n+                  resword = &wordlist[231]; break;\n+                case   814:\n+                  resword = &wordlist[232]; break;\n+                case   815:\n+                  resword = &wordlist[233]; break;\n+                case   830:\n+                  resword = &wordlist[234]; break;\n+                case   833:\n+                  resword = &wordlist[235]; break;\n+                case   834:\n+                  resword = &wordlist[236]; break;\n+                case   846:\n+                  resword = &wordlist[237]; break;\n+                case   849:\n+                  resword = &wordlist[238]; break;\n+                case   875:\n+                  resword = &wordlist[239]; break;\n+                case   909:\n+                  resword = &wordlist[240]; break;\n+                case   910:\n+                  resword = &wordlist[241]; break;\n+                case   912:\n+                  resword = &wordlist[242]; break;\n+                case   926:\n+                  resword = &wordlist[243]; break;\n+                case   931:\n+                  resword = &wordlist[244]; break;\n+                case   933:\n+                  resword = &wordlist[245]; break;\n+                case   944:\n+                  resword = &wordlist[246]; break;\n+                case   947:\n+                  resword = &wordlist[247]; break;\n+                case   982:\n+                  resword = &wordlist[248]; break;\n+                case   986:\n+                  resword = &wordlist[249]; break;\n+                case   989:\n+                  resword = &wordlist[250]; break;\n+                case  1004:\n+                  resword = &wordlist[251]; break;\n+                case  1007:\n+                  resword = &wordlist[252]; break;\n+                case  1018:\n+                  resword = &wordlist[253]; break;\n+                case  1019:\n+                  resword = &wordlist[254]; break;\n+                case  1023:\n+                  resword = &wordlist[255]; break;\n+                case  1035:\n+                  resword = &wordlist[256]; break;\n+                case  1036:\n+                  resword = &wordlist[257]; break;\n+                case  1039:\n+                  resword = &wordlist[258]; break;\n+                case  1068:\n+                  resword = &wordlist[259]; break;\n+                case  1077:\n+                  resword = &wordlist[260]; break;\n+                case  1082:\n+                  resword = &wordlist[261]; break;\n+                case  1086:\n+                  resword = &wordlist[262]; break;\n+                case  1104:\n+                  resword = &wordlist[263]; break;\n+                case  1105:\n+                  resword = &wordlist[264]; break;\n+                case  1109:\n+                  resword = &wordlist[265]; break;\n+                case  1138:\n+                  resword = &wordlist[266]; break;\n+                case  1152:\n+                  resword = &wordlist[267]; break;\n+                case  1162:\n+                  resword = &wordlist[268]; break;\n+                case  1165:\n+                  resword = &wordlist[269]; break;\n+                case  1167:\n+                  resword = &wordlist[270]; break;\n+                case  1168:\n+                  resword = &wordlist[271]; break;\n+                case  1182:\n+                  resword = &wordlist[272]; break;\n+                case  1194:\n+                  resword = &wordlist[273]; break;\n+                case  1207:\n+                  resword = &wordlist[274]; break;\n+                case  1216:\n+                  resword = &wordlist[275]; break;\n+                case  1217:\n+                  resword = &wordlist[276]; break;\n+                case  1227:\n+                  resword = &wordlist[277]; break;\n+                case  1242:\n+                  resword = &wordlist[278]; break;\n+                case  1271:\n+                  resword = &wordlist[279]; break;\n+                case  1274:\n+                  resword = &wordlist[280]; break;\n+                case  1283:\n+                  resword = &wordlist[281]; break;\n+                case  1301:\n+                  resword = &wordlist[282]; break;\n+                case  1302:\n+                  resword = &wordlist[283]; break;\n+                case  1321:\n+                  resword = &wordlist[284]; break;\n+                case  1324:\n+                  resword = &wordlist[285]; break;\n+                case  1339:\n+                  resword = &wordlist[286]; break;\n+                case  1342:\n+                  resword = &wordlist[287]; break;\n+                case  1345:\n+                  resword = &wordlist[288]; break;\n+                case  1372:\n+                  resword = &wordlist[289]; break;\n+                case  1422:\n+                  resword = &wordlist[290]; break;\n+                case  1448:\n+                  resword = &wordlist[291]; break;\n+                case  1546:\n+                  resword = &wordlist[292]; break;\n+                case  1606:\n+                  resword = &wordlist[293]; break;\n+                case  1654:\n+                  resword = &wordlist[294]; break;\n+                case  1765:\n+                  resword = &wordlist[295]; break;\n+                case  1808:\n+                  resword = &wordlist[296]; break;\n+                case  1875:\n+                  resword = &wordlist[297]; break;\n+                case  1877:\n+                  resword = &wordlist[298]; break;\n+                case  1936:\n+                  resword = &wordlist[299]; break;\n+                case  1989:\n+                  resword = &wordlist[300]; break;\n+                case  2153:\n+                  resword = &wordlist[301]; break;\n+                case  2224:\n+                  resword = &wordlist[302]; break;\n+                case  2383:\n+                  resword = &wordlist[303]; break;\n+                case  2448:\n+                  resword = &wordlist[304]; break;\n+                case  2491:\n+                  resword = &wordlist[305]; break;\n+                case  2821:\n+                  resword = &wordlist[306]; break;\n+                default: return 0;\n+                }\n+              if (*str == *resword->name && !strcmp (str + 1, resword->name + 1))\n+                return resword;\n+              return 0;\n+            }\n+         }\n+    }\n+  return 0;\n+}"}, {"sha": "984892bf6deb060467c700f5b2216ce49c41b914", "filename": "gcc/ch/lang-options.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Flang-options.h?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,42 @@\n+/* Definitions for switches for GNU CHILL.\n+   Copyright (C) 1995, 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* This is the contribution to the `lang_options' array in gcc.c for\n+   CHILL.  */\n+\n+/* CYGNUS LOCAL - the format of this file has been changed to\n+   allow cc1 to implement --help.  nickc/--help */\n+\n+DEFINE_LANG_NAME (\"Chill\")\n+     \n+  { \"-lang-chill\", \"\" },\n+  { \"-flocal-loop-counter\", \"\" },\n+  { \"-fno-local-loop-counter\", \"Do not make seperate scopes for every 'for' loop\"},\n+  { \"-fgrant-only\", \"Stop after successfully generating a grant file\" },\n+  { \"-fchill-grant-only\", \"\" },\n+  { \"-fold-strings\", \"Implement the 1984 Chill string semantics\" },\n+  { \"-fno-old-strings\", \"\" },\n+  { \"-fignore-case\", \"convert all idenitifers to lower case\" },\n+  { \"-fno-ignore-case\", \"\" },\n+  { \"-fpack\", \"Pack structures into available space\"},\n+  { \"-fno-pack\", \"\" },\n+  { \"-fspecial_UC\", \"Make special words be in uppercase\" },\n+  { \"-fspecial_LC\", \"\" },\n+  { \"-fruntime-checking\", \"\" },\n+  { \"-fno-runtime-checking\", \"Disable runtime checking of parameters\" },"}, {"sha": "61c46b79a01a0f9ad8fb87e5b0409c3ea66a2132", "filename": "gcc/ch/lex.h", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Flex.h?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,98 @@\n+/* Define constants for communication with the CHILL parser.\n+   Copyright (C) 1992, 93, 1994 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+\n+enum rid\n+{\n+  RID_UNUSED,  /* keep this one first, please */\n+  RID_ALL,\n+  RID_ASSERTFAIL,\n+  RID_ASSOCIATION,\n+  RID_BIN,\n+  RID_BIT,\n+  RID_BOOL,\n+  RID_BOOLS,\n+  RID_BYTE,\n+  RID_CHAR,\n+  RID_CHARS,\n+  RID_DOUBLE,\n+  RID_DURATION,\n+  RID_DYNAMIC,\n+  RID_ELSE,\n+  RID_EMPTY,\n+  RID_FALSE,\n+  RID_FLOAT,\n+  RID_GENERAL,\n+  RID_IN,\n+  RID_INLINE,\n+  RID_INOUT,\n+  RID_INSTANCE,\n+  RID_INT,\n+  RID_LOC,\n+  RID_LONG,\n+  RID_LONG_REAL,\n+  RID_NULL,\n+  RID_OUT,\n+  RID_OVERFLOW,\n+  RID_PTR,\n+  RID_RANGE,\n+  RID_RANGEFAIL,\n+  RID_READ,\n+  RID_REAL,\n+  RID_RECURSIVE,\n+  RID_SHORT,\n+  RID_SIMPLE,\n+  RID_TIME,\n+  RID_TRUE,\n+  RID_UBYTE,\n+  RID_UINT,\n+  RID_ULONG,\n+  RID_UNSIGNED,\n+  RID_USHORT,\n+  RID_VOID,\n+  RID_MAX /* Last element */\n+};\n+\n+#define NORID RID_UNUSED\n+\n+#define RID_FIRST_MODIFIER RID_UNSIGNED\n+\n+/* The elements of `ridpointers' are identifier nodes\n+   for the reserved type names and storage classes.\n+   It is indexed by a RID_... value.  */\n+extern tree ridpointers[(int) RID_MAX];\n+\n+extern char *token_buffer;\t/* Pointer to token buffer.  */\n+\n+extern tree make_pointer_declarator PROTO((tree, tree));\n+extern void reinit_parse_for_function PROTO((void));\n+extern int yylex PROTO((void));\n+\n+extern tree default_grant_file;\n+extern tree current_grant_file;\n+\n+extern tree current_seize_file;\n+\n+extern int chill_at_module_level;\n+extern tree chill_initializer_name;\n+\n+extern void finish_chill_seizes ();\n+\n+extern void prepare_paren_colon PROTO((void));"}, {"sha": "261241d78c18f8929922014e0d75273c01315e50", "filename": "gcc/ch/runtime/cardps.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fcardps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fcardps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fcardps.c?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,99 @@\n+/* Implement POWERSET runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"powerset.h\"\n+\n+\n+/*\n+ * function __cardpowerset\n+ *\n+ * parameters:\n+ *\tps\t\tpowerset\n+ *\tbitlength\tlength of powerset\n+ *\n+ * returns:\n+ *\tlong\t\tnumber of set bits\n+ *\n+ * exceptions:\n+ *  none\n+ *\n+ * abstract:\n+ *  returns the number of set bit's in a powerset\n+ *\n+ */\n+\n+/* bit_count[I] is number of '1' bits in I. */\n+static\n+const unsigned char __four_bit_count[16] = {\n+    0, 1, 1, 2,\n+    1, 2, 2, 3,\n+    1, 2, 2, 3,\n+    2, 3, 3, 4 };\n+\n+long\n+__cardpowerset (ps, bitlength)\n+     SET_WORD      *ps;\n+     unsigned long  bitlength;\n+{\n+  unsigned long\tcount = 0;\n+  if (bitlength <= SET_CHAR_SIZE)\n+    {\n+      register SET_CHAR\tc = *((SET_CHAR *)ps);\n+      /* count 4 bits at a time. */\n+      while (c > 0)\n+\t{\n+\t  count += __four_bit_count[c & 15];\n+\t  c >>= 4;\n+\t}\n+      return count;\n+    }\n+  else if (bitlength <= SET_SHORT_SIZE)\n+    {\n+      register SET_SHORT c = *((SET_SHORT *)ps);\n+      /* count 4 bits at a time. */\n+      while (c > 0)\n+\t{\n+\t  count += __four_bit_count[c & 15];\n+\t  c >>= 4;\n+\t}\n+      return count;\n+    }\n+  else\n+    {\n+      register SET_WORD\t*p = ps;\n+      SET_WORD *endp = p + BITS_TO_WORDS(bitlength);\n+    \n+      while (p < endp)\n+\t{\n+\t  register SET_WORD c = *p++;\n+\t  /* count 4 bits at a time. */\n+\t  while (c > 0)\n+\t    {\n+\t      count += __four_bit_count[c & 15];\n+\t      c >>= 4;\n+\t    }\n+\t}\n+      return (count);\n+    }\n+}"}, {"sha": "22db5343d673979b96f7f9330538c92cd869376b", "filename": "gcc/ch/runtime/delaycase.c", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fdelaycase.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fdelaycase.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fdelaycase.c?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,220 @@\n+/* Implement tasking-related runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"rtltypes.h\"\n+#include \"rts.h\"\n+\n+extern void __cause_ex1 (char *ex, char *file, int lineno);\n+\n+EXCEPTION (delayfail);\n+#define CAUSE_DELAYFAIL     __cause_ex1 (\"delayfail\", filename, lineno)\n+\n+EXCEPTION (notyetimplemented);\n+#define CAUSE_NOTIMPLEMENTED   __cause_ex1 (\"notyetimplemeyed\", filename, lineno)\n+\n+/*\n+ * function __delay_event\n+ *\n+ * parameters:\n+ *     ev_got      pointer to location where to write the event got.\n+ *     nevents     number of events in list\n+ *     evptrs      array of event descriptors\n+ *     priority    specified priority\n+ *     insloc      pointer to resulting instance location\n+ *     to          timeout value\n+ *     filename    filename of caller\n+ *     lineno      linenumber of caller\n+ *\n+ * returns:\n+ *     int         0 .. success\n+ *                 1 .. timed out\n+ *\n+ * exceptions:\n+ *     delayfail\n+ *\n+ * abstract:\n+ *     implement the CHILL DELAY and DELAY CASE actions.\n+ *\n+ */\n+\n+int\n+__delay_event (ev_got, nevents, evptrs, priority, to, insloc, filename, lineno)\n+     void         **ev_got;\n+     int            nevents;\n+     Event_Descr   *evptrs;\n+     int            priority;\n+     void          *to;\n+     INSTANCE      *insloc;\n+     char          *filename;\n+     int            lineno;\n+{\n+  int             i, already_done = 0;\n+  Event_Queue    *start_list = 0;\n+  Event_Queue   **retval = 0;\n+  Event_Queue    *wrk;\n+  int\t\t  timed_out = 0;\n+  \n+  /* check if all specified event queues have enough space left\n+     to perform the delay */\n+  for (i = 0; i < nevents; i++)\n+    {\n+      Event_Queue  *e;\n+      unsigned long cnt = 0;\n+      int j, have_done = 0;\n+\n+      if (evptrs[i].maxqueuelength == 0)\n+\tCAUSE_DELAYFAIL;\n+      else if (evptrs[i].maxqueuelength == (unsigned long)-1L)\n+\t/* infinite length */\n+\tcontinue;\n+\n+      /* check if we already have processed this one, that means, this\n+         event is mentioned more then once */\n+      for (j = 0; j < i; j++)\n+        {\n+          if (evptrs[i].ev == evptrs[j].ev)\n+\t    {\n+              have_done = 1;\n+              break;\n+\t    }\n+        }\n+      if (have_done)\n+\tcontinue;\n+      \n+      memcpy (&e, evptrs[i].ev, sizeof (Event_Queue *));\n+      while (e)\n+\t{\n+\t  cnt++;\n+\t  e = e->forward;\n+\t}\n+      if (cnt >= evptrs[i].maxqueuelength)\n+\tCAUSE_DELAYFAIL;\n+    }\n+\n+  for (i = 0; i < nevents; i++)\n+    {\n+      /* queue that stuff on each event */\n+      Event_Queue      *wrk;\n+      Event_Queue      *ev;\n+      Event_Queue      *prev_queue_entry = 0;\n+      Event_Queue      *prev_list_entry;\n+      int               j, have_done = 0;\n+      \n+      /* check for this event already processed */\n+      for (j = 0; j < i; j++)\n+\t{\n+          if (evptrs[i].ev == evptrs[j].ev)\n+\t    {\n+              have_done = 1;\n+              break;\n+\t    }\n+\t}\n+      if (have_done)\n+\tcontinue;\n+\n+      memcpy (&ev, &evptrs[i].ev, sizeof (Event_Queue *));\n+      MALLOC (wrk, sizeof (Event_Queue));\n+      memset (wrk, 0, sizeof (Event_Queue));\n+\n+      wrk->priority = priority;\n+      wrk->this = THIS;\n+      wrk->listhead = evptrs[i].ev;\n+\n+      /* search for the place to queue this entry in */\n+      while (ev->forward != 0 && ev->priority >= priority)\n+\t{\n+\t  prev_queue_entry = ev;\n+\t  ev = ev->forward;\n+\t}\n+\n+      /* ready to put entry into queue */\n+      if (ev->forward == 0 || prev_queue_entry == 0)\n+\t{\n+\t  /* beginning or end of the list */\n+\t  wrk->forward = ev->forward;\n+\t  ev->forward = wrk;\n+\t}\n+      else\n+\t{\n+\t  /* this is somewhere in the middle */\n+\t  wrk->forward = prev_queue_entry->forward;\n+\t  prev_queue_entry->forward = wrk;\n+\t}\n+\n+      /* queue it into list */\n+      wrk->startlist = start_list;\n+      if (! start_list)\n+\t{\n+\t  /* we are the first in the list */\n+\t  start_list = wrk;\n+\t  prev_list_entry = wrk;\n+\t  wrk->startlist = start_list;\n+\t}\n+      else\n+\t{\n+\t  prev_list_entry->chain = wrk;\n+\t  prev_list_entry = wrk;\n+\t}\n+    }\n+\n+  /* tell runtime system to delay that process */\n+  timed_out = __delay_this (wait_event_delay, to, filename, lineno);\n+  if (timed_out)\n+    {\n+      /* we have to remove the entries from the queue's */\n+      wrk = start_list;\n+      while (wrk)\n+        {\n+\t  Event_Queue *tmp = (Event_Queue *)wrk->listhead;\n+\t  \n+\t  while (tmp->forward != wrk)\n+\t    tmp = tmp->forward;\n+\t  tmp->forward = wrk->forward;\n+\t  wrk = wrk->chain;\n+        }\n+    }\n+  \n+  wrk = start_list;\n+  while (wrk)\n+    {\n+      Event_Queue  *tmp;\n+\n+      if (wrk->is_continued && ! already_done)\n+\t{\n+\t  already_done = 1;\n+\t  retval = wrk->listhead;\n+\t  if (insloc && !timed_out)\n+\t    {\n+\t      insloc->ptype = wrk->who_continued.ptype;\n+\t      insloc->pcopy = wrk->who_continued.pcopy;\n+\t    }\n+\t}\n+      tmp = wrk->chain;\n+      FREE (wrk);\n+      wrk = tmp;\n+    }\n+  if (!timed_out && ev_got)\n+    *ev_got = (void *)retval;\n+  return timed_out;\n+}\n+\n+/* force function print_event to be linked */\n+extern void __print_event ();\n+static EntryPoint pev = __print_event;"}, {"sha": "60bb0f0648114f8b30392ffd2d1c4050addfc7af", "filename": "gcc/ch/runtime/eoln.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Feoln.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Feoln.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Feoln.c?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,30 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"fileio.h\"\n+\n+Boolean\n+__eoln( Text_Mode* the_text, char* file, int line )\n+{\n+  if( !the_text )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_TEXT );\n+\n+  return the_text->actual_index == the_text->access_sub->reclength - 2;\n+}"}, {"sha": "0b946654358dd11e82e702e6b91cc3cf25c830b0", "filename": "gcc/ch/runtime/eqstr.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Feqstr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Feqstr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Feqstr.c?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,54 @@\n+/* Implement string-related runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Bill Cox\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+extern void cause_exception (char *exname, char *file, int lineno);\n+\n+/*\n+ * function __eqstring\n+ *\n+ * parameters:\n+ *     S1 - pointer to left string\n+ *     LEN1 - length of left string\n+ *     S2 - pointer to right string\n+ *     LEN2 - length of right string\n+ *\n+ * returns:\n+ *     1 if strings equal, 0 if not\n+ *\n+ * exceptions:\n+ *     none\n+ *\n+ * abstract:\n+ *     compares two character strings for equality\n+ *\n+ */\n+\n+int\n+__eqstring (s1, len1, s2, len2)\n+     char *s1;\n+     int len1;\n+     char *s2;\n+     int len2;\n+{\n+  if (len1 != len2)\n+    return 0;\n+\n+  return ! memcmp (s1, s2, len1);\n+}"}, {"sha": "93d9eb543cdb8f01f7fdccb6d898c9a1a8254fb9", "filename": "gcc/ch/runtime/existing.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fexisting.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fexisting.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fexisting.c?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,31 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"fileio.h\"\n+\n+Boolean\n+__existing( Association_Mode* the_assoc, char* file, int line )\n+{\n+  if( !the_assoc )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_ASSOCIATION );\n+  if( !TEST_FLAG(the_assoc, IO_ISASSOCIATED) )\n+    CHILLEXCEPTION( file, line, NOTASSOCIATED, IS_NOT_ASSOCIATED );\n+  return TEST_FLAG(the_assoc, IO_EXISTING ) ? True : False;\n+}"}, {"sha": "b0d70af4460c6aa22abaf673bffe6a396d1acc43", "filename": "gcc/ch/runtime/format.c", "status": "added", "additions": 2186, "deletions": 0, "changes": 2186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fformat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fformat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fformat.c?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,2186 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <limits.h>\n+#include <string.h>\n+#include <ctype.h>\n+#include <setjmp.h>\n+#include <float.h>\n+#include <math.h>\n+#include <stdlib.h>\n+#if _TEXTIO_DEBUG_\n+#include <stdio.h>\n+#endif\n+\n+#include \"bitstring.h\"\n+#include \"auxtypes.h\"\n+#include \"iomodes.h\"\n+#include \"format.h\"\n+#include \"fileio.h\"\n+#include \"ioerror.h\"\n+\n+#define CH_BYTE_MIN   0xffffff80L\n+#define CH_BYTE_MAX   0x0000007fL\n+#define CH_UBYTE_MAX  0x000000ffUL\n+#define CH_INT_MIN    0xffff8000L\n+#define CH_INT_MAX    0x00007fffL\n+#define CH_UINT_MAX   0x0000ffffUL\n+#define CH_LONG_MIN   0x80000000L\n+#define CH_LONG_MAX   0x7fffffffL\n+#define CH_ULONG_MAX  0xffffffffUL\n+\n+#ifndef M_LN2\n+#define M_LN2   0.69314718055994530942\n+#endif\n+#ifndef M_LN10\n+#define M_LN10          2.30258509299404568402\n+#endif\n+\n+#define DMANTDIGS  (1 + (int)(DBL_MANT_DIG * M_LN2 / M_LN10))\n+#define FMANTDIGS  (1 + (int)(FLT_MANT_DIG * M_LN2 / M_LN10))\n+\n+/* float register length */\n+#define MAXPREC 40\n+\n+#define LET 0x0001\n+#define BIN 0x0002\n+#define DEC 0x0004\n+#define OCT 0x0008\n+#define HEX 0x0010\n+#define USC 0x0020\n+#define BIL 0x0040\n+#define SPC 0x0080\n+#define SCS 0x0100\n+#define IOC 0x0200\n+#define EDC 0x0400\n+#define CVC 0x0800\n+\n+#define isDEC(c)  ( chartab[(c)] & DEC )\n+#define isCVC(c)  ( chartab[(c)] & CVC )\n+#define isEDC(c)  ( chartab[(c)] & EDC )\n+#define isIOC(c)  ( chartab[(c)] & IOC )\n+#define isUSC(c)\n+#define isXXX(c,XXX)  ( chartab[(c)] & XXX )\n+\n+/*\n+ *  local definitions\n+ */\n+\n+static\n+short int chartab[256] = {\n+  0, 0, 0, 0, 0, 0, 0, 0, \n+  0, SPC, SPC, SPC, SPC, SPC, 0, 0, \n+\n+  0, 0, 0, 0, 0, 0, 0, 0, \n+  0, 0, 0, 0, 0, 0, 0, 0, \n+\n+  SPC, IOC, 0, 0, 0, 0, 0, 0, \n+  SCS, SCS, SCS, SCS+IOC, SCS, SCS+IOC, SCS, SCS+IOC, \n+  BIN+OCT+DEC+HEX, BIN+OCT+DEC+HEX, OCT+DEC+HEX, OCT+DEC+HEX, OCT+DEC+HEX,\n+     OCT+DEC+HEX, OCT+DEC+HEX, OCT+DEC+HEX, \n+  DEC+HEX, DEC+HEX, SCS, SCS, SCS+EDC, SCS+IOC, SCS+EDC, IOC, \n+\n+  0, LET+HEX+BIL, LET+HEX+BIL+CVC, LET+HEX+BIL+CVC, LET+HEX+BIL, LET+HEX, \n+     LET+HEX+CVC, LET, \n+  LET+BIL+CVC, LET, LET, LET, LET, LET, LET, LET+CVC, \n+\n+  LET, LET, LET, LET, LET+EDC, LET, LET, LET,\n+  LET+EDC, LET, LET, SCS, 0, SCS, 0, USC, \n+\n+  0, LET+HEX, LET+HEX, LET+HEX, LET+HEX, LET+HEX, LET+HEX, LET, \n+  LET, LET, LET, LET, LET, LET, LET, LET, \n+\n+  LET, LET, LET, LET, LET, LET, LET, LET,\n+  LET, LET, LET, 0, 0, 0, 0, 0 \n+};\n+\n+typedef enum {\n+  FormatText, FirstPercent, RepFact, ConvClause, EditClause, ClauseEnd,\n+  AfterWidth, FractWidth, FractWidthCont, ExpoWidth, ExpoWidthCont, \n+  ClauseWidth, CatchPadding, LastPercent\n+} fcsstate_t;\n+\n+#define CONVERSIONCODES \"CHOBF\"\n+typedef enum {\n+  DefaultConv, HexConv, OctalConv, BinaryConv, ScientConv\n+} convcode_t;\n+\n+static\n+short int base[4] = { 10, 16, 8, 2 };\n+\n+static\n+short int dset[4] = { DEC, HEX, OCT, BIN };\n+\n+#define EDITCODES \"X<>T\"\n+typedef enum {\n+  SpaceSkip, SkipLeft, SkipRight, Tabulation\n+} editcode_t;\n+\n+#define IOCODES \"/+-?!=\"\n+typedef enum {\n+  NextRecord, NextPage, CurrentLine, Prompt, Emit, EndPage\n+} iocode_t;\n+\n+typedef enum { \n+  ConvAct, EditAct, IOAct\n+} acttype_t;\n+\n+typedef enum {\n+  NormalEnd, EndAtParen, TextFailEnd \n+} formatexit_t;\n+\n+static\n+double ep_1[10] = {\n+  1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9 };\n+static\n+double ep_10[10] = {\n+  1e0, 1e10, 1e20, 1e30, 1e40, 1e50, 1e60, 1e70, 1e80, 1e90 };\n+static\n+double ep_100 = 1e100;\n+\n+/* float register */\n+static\n+unsigned char floatdig[MAXPREC];\n+\n+/*\n+ *  global io variables\n+ */\n+\n+static Text_Mode*      textptr = NULL;\n+static VarString*      textrecptr;\n+\n+static int             actual_index;\n+static int             maximum_index;\n+static int             iolist_index;\n+\n+static __tmp_IO_list*  iolistptr;\n+static int             iolistlen;\n+static char*           iostrptr;\n+static int             iostrlen;\n+\n+\n+static convcode_t     convcode;\n+static editcode_t     editcode;\n+static iocode_t       iocode;\n+static unsigned long  repetition;\n+static Boolean        leftadjust;\n+static Boolean        overflowev;\n+static Boolean        dynamicwid;\n+static Boolean        paddingdef;\n+static char           paddingchar;\n+static Boolean        fractiondef;\n+static unsigned long  fractionwidth;\n+static Boolean        exponentdef;\n+static unsigned long  exponentwidth;\n+static unsigned long  clausewidth;\n+static signed long    textindex;\n+  \n+static\n+__tmp_IO_enum_table_type bool_tab[] = \n+   { { 0, \"FALSE\" }, \n+     { 1, \"TRUE\"  },\n+     { 0 , NULL   }  };\n+\n+/*\n+ * case insensitive compare: s1 is zero delimited, s2 has n chars\n+ */\n+static\n+int casncmp( const char* s1, const char* s2, int n )\n+{\n+  int res = 0;\n+  while( n-- )\n+  {\n+    if( (res = toupper(*s1++) - toupper(*s2++)) ) \n+      return res;\n+  }\n+  return *s1;\n+}\n+\n+/*\n+ * skip spaces with blank equal to tab\n+ */\n+static\n+int skip_space( int limit )\n+{\n+  int skipped = 0;\n+  while( actual_index < limit &&\n+         (iostrptr[actual_index] == ' ' || iostrptr[actual_index] == '\\t' ) )\n+  {\n+    actual_index++;\n+    skipped++;\n+  }\n+  return skipped;\n+}\n+\n+/*\n+ * skip leading pad characters\n+ */\n+static\n+int skip_pad( int limit )\n+{\n+  int skipped = 0;\n+  while( actual_index < limit && iostrptr[actual_index] == paddingchar )\n+  {\n+    actual_index++;\n+    skipped++;\n+  }\n+#if _TEXTIO_DEBUG_\n+  printf( \"skipping '%c' until %d: %d\\n\", paddingchar, limit, skipped );\n+#endif\n+  return skipped;\n+}\n+\n+/*\n+ * backup trailing pad characters\n+ */\n+static\n+int piks_pad( int start, int limit )\n+{\n+  int skipped = 0;\n+  while( start >/***=*/ limit && iostrptr[--start] == paddingchar )\n+  {\n+    skipped++;\n+  }\n+#if _TEXTIO_DEBUG_\n+  printf( \"piksing '%c' from %d until %d: %d\\n\", \n+          paddingchar, start, limit, skipped );\n+#endif\n+  return skipped;\n+}\n+\n+/*\n+ * parse an integer\n+ */\n+static\n+int parse_int( int limit, int SET, int base, \n+               unsigned long* valptr, int* signptr )\n+{\n+  int           parsed = actual_index;\n+  Boolean       digits = False;\n+  unsigned long value  = 0;\n+  char          curr;\n+  int           dig;\n+\n+  if( actual_index >= limit )\n+    IOEXCEPTION( TEXTFAIL, NO_CHARS_FOR_INT );\n+  *signptr = +1;\n+  if( iostrptr[actual_index] == '+' )\n+    actual_index++;\n+  else\n+    if( iostrptr[actual_index] == '-' )\n+    {  *signptr = -1;\n+       actual_index++;\n+    }\n+\n+  for( ; actual_index < limit; actual_index++ )\n+  {\n+    curr = iostrptr[actual_index];\n+    if( curr == '_' ) continue;\n+    if( isXXX(curr,SET) )\n+    {\n+      digits = True;\n+      dig = curr <= '9' ? curr - '0' : toupper(curr) - 'A' + 10;\n+      if( value > (ULONG_MAX - dig)/base )\n+        IOEXCEPTION( TEXTFAIL, INT_VAL_OVERFLOW );\n+      value = value*base + dig;\n+      continue;\n+    }\n+    break;\n+  }\n+  if( !digits )\n+    IOEXCEPTION( TEXTFAIL, NO_DIGITS_FOR_INT );\n+\n+  *valptr = value;\n+#if _TEXTIO_DEBUG_\n+  printf( \"parsing for int until %d, base %d: %u\\n\", limit, base, value );\n+#endif\n+  return actual_index - parsed;\n+}\n+\n+static\n+double\n+make_float( int dexp, int sign )\n+{\n+  double value = atof( floatdig );\n+#if _TEXTIO_DEBUG_\n+  printf( \" value = %25.20e, dexp = %d\\n\", value, dexp );\n+#endif\n+  while( dexp >= 100 )\n+    value *= ep_100, dexp -= 100;\n+  if( dexp >= 10 )\n+    value *= ep_10[dexp/10], dexp %= 10;\n+  if( dexp > 0 )\n+    value *= ep_1[dexp];\n+\n+  while( dexp <= -100 )\n+    value /= ep_100, dexp += 100;\n+  if( dexp <= -10 )\n+    value /= ep_10[-dexp/10], dexp %= 10;\n+  if( dexp < 0 )\n+    value /= ep_1[-dexp];\n+\n+  return  sign ? -value : value;\n+}\n+\n+/* %C -> fixed point   [+|-]<digit>+[.<digit>*]  */\n+static\n+int parse_fixedpoint( int limit, double* valptr )\n+{\n+  int           parsed = actual_index;\n+  Boolean       digits = False;\n+  int           sdig = 0;\n+  double        value;\n+  char          curr;\n+  int           sign = False;\n+  int           expo = 0;\n+\n+  if( actual_index >= limit )\n+    IOEXCEPTION( TEXTFAIL, NO_CHARS_FOR_FLOAT );\n+  if( iostrptr[actual_index] == '+' )\n+    actual_index++;\n+  else\n+    if( iostrptr[actual_index] == '-' )\n+    {\n+       sign = True;\n+       actual_index++;\n+    }\n+\n+  floatdig[0] = '.';\n+  for( ; actual_index < limit; actual_index++ )\n+  {\n+    curr = iostrptr[actual_index];\n+    if( ! isDEC(curr) )\n+      break;\n+    digits = True;\n+    if( sdig < MAXPREC - 1 )\n+    {\n+      if( sdig || curr != '0' )\n+      {\n+        floatdig[++sdig] = curr;\n+        expo++;\n+      }\n+    }\n+    else\n+      if( sdig )\n+        expo++;\n+  }\n+  if( digits && curr == '.' )\n+  { \n+    actual_index++;\n+    for( ; actual_index < limit; actual_index++ )\n+    {\n+      curr = iostrptr[actual_index];\n+      if( !isDEC(curr) )\n+        break;\n+      if( sdig < MAXPREC - 1 )\n+      {\n+        if( sdig || curr != '0' )\n+          floatdig[++sdig] = curr;\n+        else\n+          expo--;\n+      }\n+    }\n+  }\n+  floatdig[++sdig] = '\\0';\n+\n+  if( !digits )\n+    IOEXCEPTION( TEXTFAIL, NO_DIGITS_FOR_FLOAT );\n+\n+  *valptr = make_float( expo, sign);\n+  return actual_index - parsed;\n+}\n+\n+\n+typedef enum {\n+  s_sign, s_dig, s_period, s_fraca, s_fracb, s_expo, s_exposign, \n+  s_expoa, s_expob }\n+scient_t;\n+\n+/* %C -> scientific   [+|-]<digit>[.<digit>*]E[=|-]<digit>+  */\n+static\n+int parse_scientific( int limit, double* valptr, double dmin, double dmax )\n+{\n+  int           parsed = actual_index;\n+  int           sdig = 0;\n+  char          curr;\n+  double        value;\n+  int           sign = False;\n+  int           expo = 0;           \n+  int           expo_sign = +1;\n+\n+  scient_t      state = s_sign;  \n+\n+  if( actual_index >= limit )\n+    IOEXCEPTION( TEXTFAIL, NO_CHARS_FOR_FLOAT );\n+\n+  floatdig[0] = '.';\n+  for( ; actual_index < limit; actual_index++ )\n+  {\n+    curr = iostrptr[actual_index];\n+    switch( state )\n+    {\n+    case s_sign:\n+      if( iostrptr[actual_index] == '+' )\n+      {\n+        state = s_dig;\n+        break;\n+      }\n+      if( iostrptr[actual_index] == '-' )\n+      {\n+        sign = True;\n+        state = s_dig;\n+        break;\n+      }\n+      /* fall through - no break */\n+    case s_dig:\n+      if( isDEC(curr) && curr > '0' )\n+      {\n+        floatdig[++sdig] = curr;\n+        state = s_period;\n+        break;\n+      }\n+      IOEXCEPTION( TEXTFAIL, NO_DIGITS_FOR_FLOAT );\n+    case s_period:\n+      if( curr == '.' )\n+      {\n+        state = s_fraca;\n+        break;\n+      }\n+      if( curr == 'E' )\n+      {\n+        state = s_exposign;\n+        break;\n+      }\n+      IOEXCEPTION( TEXTFAIL, NO_EXPONENT );\n+    case s_fraca:\n+      if( isDEC(curr) )\n+      {\n+        floatdig[++sdig] = curr;\n+        state = s_fracb;\n+        break;\n+      }\n+      IOEXCEPTION( TEXTFAIL, NO_DIGITS_FOR_FLOAT );\n+    case s_fracb:\n+      if( isDEC(curr) )\n+      {\n+        if( sdig < MAXPREC - 1 )\n+          floatdig[++sdig] = curr;\n+        break;\n+      }\n+      if( curr == 'E' )\n+      {\n+        state = s_exposign;\n+        break;\n+      }\n+      IOEXCEPTION( TEXTFAIL, NO_EXPONENT );\n+    case s_exposign:\n+      if( iostrptr[actual_index] == '+' )\n+      {\n+        state = s_expoa;\n+        break;\n+      }\n+      if( iostrptr[actual_index] == '-' )\n+      {\n+        expo_sign = -1;\n+        state = s_expoa;\n+        break;\n+      }\n+    case s_expoa:\n+      if( isDEC(curr) )\n+      {\n+        expo = curr - '0';\n+        state = s_expob;\n+        break;\n+      }\n+      IOEXCEPTION( TEXTFAIL, NO_EXPONENT );\n+    case s_expob:\n+      expo = expo*10 + (curr - '0');\n+      if( expo > 1000 )\n+        IOEXCEPTION( TEXTFAIL, REAL_OVERFLOW );\n+    }\n+  }\n+  if( state != s_expob ) \n+    IOEXCEPTION( TEXTFAIL, NO_EXPONENT );\n+\n+  expo *= expo_sign;\n+  expo++;\n+\n+  floatdig[++sdig] = '\\0';\n+\n+  *valptr = make_float( expo, sign );\n+  return actual_index - parsed;\n+}\n+\n+\n+static\n+int parse_set( int limit, __tmp_IO_enum_table_type* tabptr, \n+               unsigned long* valptr )\n+{\n+  int    parsed = actual_index;\n+  char   curr;\n+  __tmp_IO_enum_table_type* etptr;\n+\n+  if( actual_index >= limit )\n+    IOEXCEPTION( TEXTFAIL, NO_CHARS_FOR_SET );\n+\n+  curr = iostrptr[actual_index];\n+  if( isXXX(curr,LET+USC) )\n+    actual_index++;\n+  else\n+    IOEXCEPTION( TEXTFAIL, NO_CHARS_FOR_SET );\n+\n+  for( ; actual_index < limit; actual_index++ )\n+  {    \n+    if( ! isXXX(iostrptr[actual_index],LET+DEC+USC) )\n+      break;\n+  }\n+\n+  if( tabptr )\n+     while( tabptr->name )\n+     {\n+       if( !casncmp( tabptr->name, &iostrptr[parsed], actual_index-parsed ) )\n+       {\n+         *valptr = tabptr->value;\n+#if _TEXTIO_DEBUG_\n+         printf( \"parsing set value until %d: %u\\n\", limit, tabptr->value );\n+#endif\n+         return actual_index - parsed;         \n+       }\n+       tabptr++;\n+     }\n+  IOEXCEPTION( TEXTFAIL, SET_CONVERSION_ERROR ); \n+}\n+\n+static\n+int parse_bit( int limit, char* bitptr )\n+{\n+  int parsed = actual_index;\n+  int i = 0;\n+  char curr;\n+\n+  if( actual_index >= limit )\n+    IOEXCEPTION( TEXTFAIL, NO_CHARS_FOR_BOOLS );\n+\n+  for( ; actual_index < limit; actual_index++ )\n+  {\n+    curr = iostrptr[actual_index] - '0';\n+    if( curr == 0 || curr == 1 )\n+      /* __setbitinset( i++, bitptr, limit, curr ); */\n+      __setbitpowerset (bitptr, limit, 0, i++, curr, __FILE__, __LINE__);\n+    else\n+      break;\n+  }\n+  return actual_index - parsed;\n+}\n+\n+static\n+char* myultoa( unsigned long ul, char* buf, int base )\n+{\n+  char*         res = buf;\n+  unsigned long h = ul/base;\n+  unsigned long q = 1;\n+\n+  while( h >= q ) q *= base;\n+  while( q > 0 )\n+  {\n+    *buf++ = \"0123456789ABCDEF\"[ul/q];\n+    ul %= q;\n+    q /= base;\n+  }\n+  *buf++ = '\\0';\n+  return res;\n+}\n+\n+/*\n+ *  convert a bit string from src, bit offset up to len\n+ */\n+static\n+char* bitput( char* dst, char* src, int offset, int len )\n+{\n+  char* res = dst;\n+  int i;\n+  for( i = offset; i < len; i++ )\n+  {\n+    *dst++ = __inpowerset( i, src, len, 0 ) ? '1' : '0';\n+  }\n+  return res;\n+}\n+\n+/*\n+ * dround: round decimal register *digptr starting at digit mdigs,\n+ *         on carry advance begin of digit sequence and bump exponent\n+ */ \n+static\n+char*\n+dround( char* digptr, int mdigs, int* deptr )\n+{\n+  int carry;\n+#if _TEXTIO_DEBUG_\n+  printf( \"Rounding from %d\\n\", mdigs );\n+#endif\n+  if( digptr[mdigs] >= 5 )\n+  {\n+    carry = 1;\n+    while( carry )\n+    {\n+      digptr[--mdigs]++;\n+      if( digptr[mdigs] >= 10 )\n+        digptr[mdigs] = 0;\n+      else\n+        carry = 0;\n+    }\n+  }\n+  if( mdigs < 0 )\n+  {\n+    digptr[--mdigs] = 1;\n+    (*deptr)++;\n+    return digptr - 1;\n+  }\n+  else\n+    return digptr;\n+}\n+\n+/*\n+ * mydtoa: convert val with a precision of mantdigs to a decimal fraction\n+ *         first digit is at **fstdiptr, decimal exponent is at *deptr\n+ */\n+static\n+char*\n+mydtoa( double val, int mantdigs, int* deptr, int* sgnptr )\n+{\n+  double m;\n+  int be;\n+  int de = -1;\n+  int fstdig = 0;\n+  int idig; \n+  char* digptr = floatdig+2;\n+\n+  floatdig[0] = floatdig[1] = 0;\n+\n+  if( val < 0 ) \n+    *sgnptr = -1, val = fabs( val );\n+  else\n+    *sgnptr = +1;\n+\n+  /* split the value */\n+  m = frexp( val, &be ) * 10.0;\n+\n+  /* 5.0 <= m < 10.0 */\n+  while( be > 0 )\n+  {\n+    de++; be--; m /= 5.0;\n+    if( m < 1.0 )\n+      m *= 10.0, de--;\n+  }\n+  while( be < 0 )\n+  {\n+    de--; be++; m *= 5.0;\n+    if( m >= 10.0 )\n+      m /= 10.0, de++;\n+  }\n+\n+  for( idig = 0; idig < mantdigs; idig++ )\n+  {\n+    digptr[idig] = (int)m;\n+    m = (m - digptr[idig])*10.0;\n+  }\n+  digptr[idig] = (int)m;\n+\n+  *deptr = de;\n+  return dround( digptr, mantdigs, deptr );\n+}\n+\n+#define PUT(c) \\\n+  { if( ifst <= ++iprt && iprt <= ilst ) *dst++ = c; }\n+\n+static\n+char*\n+fixput( char* dst, char* src, \n+        int ifst, int ilst, \n+        int sign, int fst, int lst, \n+        int nid, int nfd )\n+{\n+  char* dstsav = dst;\n+  int idig;\n+  int iprt = 0;\n+\n+  if( sign < 0 )\n+    PUT( '-' );\n+  for( idig = nid; idig >= -nfd; idig-- )\n+  {\n+    if (idig == -1)\n+      PUT( '.' );\n+    PUT( idig > fst || lst >= idig ? '0': '0' + *src++ );\n+  }\n+  return dstsav;\n+}\n+\n+static\n+char*\n+sciput( char* dst, char* src, char* expbeg,\n+        int ifst, int ilst, \n+        int sign, int de, int expwid )\n+{\n+  char* dstsav = dst;\n+  int iprt = 0;\n+  int nfd = fractionwidth;\n+  int explen = strlen( expbeg );\n+\n+  if( sign < 0 )\n+    PUT( '-' );\n+  PUT( '0' + *src++ );\n+  PUT( '.' );\n+\n+  while( nfd-- )\n+    PUT( '0' + *src++ );\n+  PUT( 'E' );\n+  PUT( de >= 0 ? '+' : '-' );\n+  while( expwid > explen )\n+  {\n+    PUT( '0' );\n+    expwid--;\n+  }\n+  while( explen-- )\n+    PUT( *expbeg++ );\n+  return dstsav;\n+}\n+\n+/*\n+ *  handle dynamic field width\n+ */ \n+static\n+get_field_width( void )\n+{\n+  unsigned long  width;\n+  unsigned long  ulongval;\n+           long  longval;\n+  __tmp_IO_list  io;\n+   \n+\n+  if( ++iolist_index > iolistlen )\n+    IOEXCEPTION( TEXTFAIL, IOLIST_EXHAUSTED );  \n+\n+  io = *iolistptr++;\n+\n+  /* must be integer, >= 0 */\n+  switch( io.__descr )\n+  {\n+  case __IO_ByteVal:\n+    longval = io.__t.__valbyte; \n+    goto signed_fieldwidth;\n+  case __IO_UByteVal:\n+    width = io.__t.__valubyte; \n+    goto unsigned_fieldwidth;\n+  case __IO_IntVal:\n+    longval = io.__t.__valint; \n+    goto signed_fieldwidth;\n+  case __IO_UIntVal:\n+    width = io.__t.__valuint; \n+    goto unsigned_fieldwidth;\n+  case __IO_LongVal:\n+    longval = io.__t.__vallong; \n+    goto signed_fieldwidth;\n+  case __IO_ULongVal:\n+    width = io.__t.__valulong; \n+    goto unsigned_fieldwidth;\n+  case __IO_ByteLoc:\n+    longval = *(signed char*)io.__t.__locint; \n+    goto signed_fieldwidth;\n+  case __IO_UByteLoc:\n+    width = *(unsigned char*)io.__t.__locint; \n+    goto unsigned_fieldwidth;\n+  case __IO_IntLoc:\n+    longval = *(signed short*)io.__t.__locint; \n+    goto signed_fieldwidth;\n+  case __IO_UIntLoc:\n+    width = *(unsigned short*)io.__t.__locint; \n+    goto unsigned_fieldwidth;\n+  case __IO_LongLoc:\n+    longval = *(signed long*) io.__t.__locint; \n+    goto signed_fieldwidth;\n+  case __IO_ULongLoc:\n+    width = *(unsigned long*)io.__t.__locint; \n+    goto unsigned_fieldwidth;\n+  default:\n+    IOEXCEPTION( TEXTFAIL, NON_INT_FIELD_WIDTH );\n+  }\n+\n+signed_fieldwidth: ;\n+  if( longval < 0 )\n+    IOEXCEPTION( TEXTFAIL, NEGATIVE_FIELD_WIDTH );\n+  width = longval;\n+\n+unsigned_fieldwidth: ;\n+  return width;\n+}\n+\n+\n+static\n+void inpconv( void )\n+{\n+  __tmp_IO_list  io;\n+  int            width;\n+  int            limit;\n+  int            skiplim;\n+  int            skipped;\n+  int            bypass;\n+  int            parsed;\n+  Boolean        fixedchars;\n+  int            fixedlen;\n+  unsigned char  curr;\n+  double         dval;\n+  float          fval;\n+\n+  __tmp_IO_long  lval;\n+  int            sign;\n+  unsigned long  umin;\n+  unsigned long  umax;\n+    signed long  smin;\n+    signed long  smax;\n+  int            ilen;\n+  short unsigned slen;\n+  __tmp_IO_enum_table_type* settabptr; \n+\n+  while( repetition-- )\n+  {\n+    if( ++iolist_index > iolistlen )\n+      IOEXCEPTION( TEXTFAIL, IOLIST_EXHAUSTED );  \n+\n+    io = *iolistptr++;\n+\n+    if( dynamicwid )\n+      width = get_field_width();\n+    else\n+      width = clausewidth;\n+\n+    bypass = skipped = 0;\n+    if( width )\n+    {\n+      if( actual_index + width > iostrlen )\n+        IOEXCEPTION( TEXTFAIL, NOT_ENOUGH_CHARS );\n+\n+      switch(io.__descr)\n+      {\n+      case __IO_CharLoc:\n+      case __IO_CharRangeLoc:\n+        fixedchars = True;\n+        fixedlen = 1;\n+        break;\n+      case __IO_CharStrLoc:\n+        fixedchars = True;\n+        fixedlen = io.__t.__loccharstring.string_length;\n+        break;\n+      default:\n+        fixedchars = False;\n+        break;\n+      }\n+         \n+      if( leftadjust )\n+      {\n+        skiplim = fixedchars ? actual_index + fixedlen\n+                             : actual_index;\n+        bypass = skipped = piks_pad( actual_index + width, skiplim );\n+      }\n+      else\n+      {\n+        skiplim = fixedchars ? actual_index + width - fixedlen\n+                             : actual_index + width;\n+        skipped = skip_pad( skiplim );\n+      }\n+      width -= skipped;\n+      limit = actual_index + width;\n+    }\n+    else\n+    { /* free format */\n+      if( paddingdef || !( io.__descr == __IO_CharLoc ||\n+                           io.__descr == __IO_CharRangeLoc || \n+                           io.__descr == __IO_CharStrLoc ||\n+                           io.__descr == __IO_CharVaryingLoc ) )\n+        if( paddingchar == ' ' || paddingchar == '\\t' )\n+          skip_space( iostrlen );\n+        else\n+          skip_pad( iostrlen );\n+      limit = iostrlen;\n+    }\n+\n+    switch( io.__descr )\n+    {\n+    case __IO_ByteLoc:\n+      ilen = 1;\n+      smin = CH_BYTE_MIN;\n+      smax = CH_BYTE_MAX;\n+      goto parse_signed_int;\n+    case __IO_UByteLoc:\n+      ilen = 1;\n+      umin = 0;\n+      umax = CH_UBYTE_MAX;\n+      goto parse_unsigned_int;\n+    case __IO_IntLoc:\n+      ilen = 2;\n+      smin = CH_INT_MIN;\n+      smax = CH_INT_MAX;\n+      goto parse_signed_int;\n+    case __IO_UIntLoc:\n+      ilen = 2;\n+      umin = 0;\n+      umax = CH_UINT_MAX;\n+      goto parse_unsigned_int;\n+    case __IO_LongLoc:\n+      ilen = 4;\n+      smin = CH_LONG_MIN;\n+      smax = CH_LONG_MAX;\n+      goto parse_signed_int;\n+    case __IO_ULongLoc:\n+      ilen = 4;\n+      umin = 0;\n+      umax = CH_ULONG_MAX;\n+      goto parse_unsigned_int;\n+\n+    case __IO_ByteRangeLoc:\n+      ilen = 1;\n+      smin = io.__t.__locintrange.lower.slong;\n+      smax = io.__t.__locintrange.upper.slong;\n+      goto parse_signed_int;\n+    case __IO_UByteRangeLoc:\n+      ilen = 1;\n+      umin = io.__t.__locintrange.lower.ulong;\n+      umax = io.__t.__locintrange.upper.ulong;\n+      goto parse_unsigned_int;\n+    case __IO_IntRangeLoc:\n+      ilen = 2;\n+      smin = io.__t.__locintrange.lower.slong;\n+      smax = io.__t.__locintrange.upper.slong;\n+      goto parse_signed_int;\n+    case __IO_UIntRangeLoc:\n+      ilen = 2;\n+      umin = io.__t.__locintrange.lower.ulong;\n+      umax = io.__t.__locintrange.upper.ulong;\n+      goto parse_unsigned_int;\n+    case __IO_LongRangeLoc:\n+      ilen = 4;\n+      smin = io.__t.__locintrange.lower.slong;\n+      smax = io.__t.__locintrange.upper.slong;\n+      goto parse_signed_int;\n+    case __IO_ULongRangeLoc:\n+      ilen = 4;\n+      umin = io.__t.__locintrange.lower.ulong;\n+      umax = io.__t.__locintrange.upper.ulong;\n+      goto parse_unsigned_int;\n+\n+    case __IO_BoolLoc:\n+      ilen = 1;\n+      umin = 0;\n+      umax = 1;\n+      settabptr = bool_tab;\n+      goto parse_set;\n+    case __IO_BoolRangeLoc:\n+      ilen = 1;\n+      umin = io.__t.__locboolrange.lower;\n+      umax = io.__t.__locboolrange.upper;\n+      settabptr = bool_tab;\n+      goto parse_set;\n+\n+    case __IO_SetLoc:\n+      ilen = io.__t.__locsetrange.length;\n+      settabptr = io.__t.__locsetrange.name_table;\n+      umin = 0;\n+      umax = CH_ULONG_MAX;\n+      goto parse_set;\n+    case __IO_SetRangeLoc:\n+      ilen = io.__t.__locsetrange.length;\n+      settabptr = io.__t.__locsetrange.name_table;\n+      umin = io.__t.__locsetrange.lower;\n+      umax = io.__t.__locsetrange.upper;\n+      goto parse_set;\n+\n+    case __IO_CharLoc:\n+      umin = 0;\n+      umax = 0xff;\n+      goto parse_char;\n+    case __IO_CharRangeLoc:\n+      umin = io.__t.__loccharrange.lower;\n+      umax = io.__t.__loccharrange.upper;\n+      goto parse_char;\n+\n+    case __IO_CharVaryingLoc:\n+      if( convcode != DefaultConv )\n+        IOEXCEPTION( TEXTFAIL, CONVCODE_MODE_MISFIT );\n+      slen = io.__t.__loccharstring.string_length;\n+      if( (parsed = limit - actual_index) < slen )\n+        slen = parsed;\n+      else\n+        parsed = slen;  \n+      memcpy( io.__t.__loccharstring.string + 2, \n+              &iostrptr[actual_index], parsed );\n+      MOV2(io.__t.__loccharstring.string,&slen);\n+      actual_index += parsed;\n+      goto check_field_complete;\n+\n+\n+    case __IO_CharStrLoc:\n+      if( convcode != DefaultConv )\n+        IOEXCEPTION( TEXTFAIL, CONVCODE_MODE_MISFIT );\n+      if( actual_index + io.__t.__loccharstring.string_length > limit )\n+        IOEXCEPTION( TEXTFAIL, NO_CHARS_FOR_CHARS );\n+      memcpy( io.__t.__loccharstring.string,\n+              &iostrptr[actual_index],\n+              parsed = io.__t.__loccharstring.string_length );\n+      actual_index += parsed;\n+      goto check_field_complete;\n+\n+    case __IO_BitStrLoc:\n+      if( convcode != DefaultConv )\n+        IOEXCEPTION( TEXTFAIL, CONVCODE_MODE_MISFIT );\n+      parsed = parse_bit( limit, io.__t.__loccharstring.string );\n+      if( parsed < io.__t.__loccharstring.string_length )\n+        IOEXCEPTION( TEXTFAIL, NO_CHARS_FOR_BOOLS );\n+      goto check_field_complete;\n+\n+    case __IO_LongRealLoc:\n+    case __IO_RealLoc:\n+      switch( convcode )\n+      {\n+      case ScientConv:\n+        parse_scientific( limit, &dval, DBL_MIN, DBL_MAX );\n+        break;\n+      case DefaultConv:\n+        parse_fixedpoint( limit, &dval );\n+        break;\n+      default:\n+        IOEXCEPTION( TEXTFAIL, CONVCODE_MODE_MISFIT );\n+      }\n+      if( io.__descr == __IO_LongRealLoc )\n+        memcpy( io.__t.__loclongreal, &dval, sizeof(double) );\n+      else\n+      {\n+        fval = (float)dval;\n+        MOV4(io.__t.__locreal,&fval);\n+      }\n+      goto check_field_complete;\n+    default:\n+      IOEXCEPTION( TEXTFAIL, INVALID_IO_LIST );\n+    }\n+\n+\n+parse_signed_int: ;\n+    if( convcode == ScientConv )\n+      IOEXCEPTION( TEXTFAIL, CONVCODE_MODE_MISFIT );\n+    parsed = parse_int( limit, dset[convcode], base[convcode], \n+                        &lval.ulong, &sign );\n+    if( sign < 0 )\n+    {\n+      if( lval.ulong > (unsigned long)CH_LONG_MIN )\n+        IOEXCEPTION( TEXTFAIL, INTEGER_RANGE_ERROR );\n+      lval.slong = -lval.ulong;\n+    }\n+    else\n+    {\n+      /* not needed: lval.slong = lval.ulong; */\n+      /* Hack: sign extension for bin/oct/dec if no sign present */\n+      if( convcode != DefaultConv && lval.ulong & (1 << (ilen*8-1)) )\n+      {\n+        if( ilen < 4 )\n+          lval.ulong |= 0xFFFFFFFF << ilen*8;\n+      }\n+      else\n+        if( lval.ulong > (unsigned long)CH_LONG_MAX )\n+          IOEXCEPTION( TEXTFAIL, INTEGER_RANGE_ERROR );\n+    }\n+    if( lval.slong < smin || smax < lval.slong )\n+      IOEXCEPTION( TEXTFAIL, INTEGER_RANGE_ERROR );\n+    goto store_int;\n+\n+parse_unsigned_int: ;\n+    if( convcode == ScientConv )\n+      IOEXCEPTION( TEXTFAIL, CONVCODE_MODE_MISFIT );\n+    parsed = parse_int( limit, dset[convcode], base[convcode],\n+                        &lval.ulong, &sign );\n+    if( sign < 0 ||  lval.ulong < umin || umax < lval.ulong )\n+      IOEXCEPTION( TEXTFAIL, INTEGER_RANGE_ERROR );\n+    goto store_int;\n+\n+parse_set: ;\n+    if( convcode != DefaultConv )\n+      IOEXCEPTION( TEXTFAIL, CONVCODE_MODE_MISFIT );\n+    parsed = parse_set( limit, settabptr, &lval.ulong );\n+    if( lval.ulong < umin || umax < lval.ulong )\n+      IOEXCEPTION( TEXTFAIL, SET_RANGE_ERROR );\n+    goto store_int;\n+\n+store_int: ;\n+    switch( ilen )\n+    {\n+    case 1:\n+      *(unsigned char*)io.__t.__locint = lval.ulong;\n+      break;\n+    case 2:\n+      slen = lval.ulong;\n+      MOV2(io.__t.__locint,&slen);\n+      break;\n+    case 4:\n+      MOV4(io.__t.__locint,&lval.ulong);\n+      break;\n+    default:\n+      IOEXCEPTION( TEXTFAIL, INTERNAL_ERROR );\n+    }\n+    goto check_field_complete;\n+\n+parse_char: ;\n+    if( convcode != DefaultConv )\n+      IOEXCEPTION( TEXTFAIL, CONVCODE_MODE_MISFIT );\n+    if( actual_index >= limit )\n+      IOEXCEPTION( TEXTFAIL, NO_CHARS_FOR_CHARS );\n+    curr = iostrptr[actual_index++];\n+    parsed = 1;\n+    if( curr < umin || umax < curr )\n+      IOEXCEPTION( TEXTFAIL, CHAR_RANGE_ERROR );\n+    *io.__t.__locchar = curr;\n+    goto check_field_complete;\n+\n+check_field_complete: ;\n+    actual_index += bypass;    \n+    if( width > parsed )\n+      IOEXCEPTION( TEXTFAIL, INVALID_CHAR );\n+  }\n+}\n+\n+static\n+void inpedit( void )\n+{\n+  int           nchars;\n+\n+  if( dynamicwid ) \n+    clausewidth = get_field_width();\n+\n+  switch( editcode )\n+  { \n+  case SpaceSkip:\n+    nchars = repetition*clausewidth;\n+    if( actual_index + nchars > iostrlen )\n+      IOEXCEPTION( TEXTFAIL, NO_CHARS_FOR_EDIT );\n+    for( ; nchars ; nchars-- )\n+      if( iostrptr[actual_index++] != ' ' )\n+        IOEXCEPTION( TEXTFAIL, NO_SPACE_TO_SKIP );\n+    break; \n+\n+  case SkipLeft:\n+    nchars = repetition*clausewidth;\n+    if( (actual_index -= nchars) < 0 )\n+      IOEXCEPTION( TEXTFAIL, NO_CHARS_FOR_EDIT );\n+    break;\n+\n+  case SkipRight:\n+    nchars = repetition*clausewidth;\n+    if( (actual_index += nchars) > iostrlen )\n+      IOEXCEPTION( TEXTFAIL, NO_CHARS_FOR_EDIT );\n+    break;\n+  \n+  case Tabulation:\n+    if( (actual_index = clausewidth) > iostrlen )\n+      IOEXCEPTION( TEXTFAIL, TEXT_LOC_OVERFLOW );\n+    break;\n+  }\n+}\n+\n+static\n+void outconv( void )\n+{\n+  unsigned long             width;\n+  char                      itembuf[33]; \n+  unsigned long             ulongval;\n+           long             longval;\n+  __tmp_IO_list             io;\n+  __tmp_IO_enum_table_type* etptr;\n+  char*                     itembeg;\n+  unsigned long             itemlen;\n+  double                    doubleval;\n+  int                       de;\n+  int                       sign;\n+  int                       mantdigs;\n+  int                       nid;\n+  int                       nfd;\n+  char*                     expbeg;\n+  int                       explen;\n+  unsigned int              expwid;\n+\n+  while( repetition-- )\n+  {\n+    if( ++iolist_index > iolistlen )\n+      IOEXCEPTION( TEXTFAIL, IOLIST_EXHAUSTED );  \n+\n+    io = *iolistptr++;\n+    width =  dynamicwid ? get_field_width() : clausewidth;\n+\n+    switch( convcode )\n+    {\n+    case DefaultConv:\n+      switch( io.__descr )\n+      {\n+      case __IO_ByteVal:\n+        longval = io.__t.__valbyte; \n+        goto signed_conversion;\n+      case __IO_UByteVal:\n+        ulongval = io.__t.__valubyte; \n+        goto unsigned_conversion;\n+      case __IO_IntVal:\n+        longval = io.__t.__valint; \n+        goto signed_conversion;\n+      case __IO_UIntVal:\n+        ulongval = io.__t.__valuint; \n+        goto unsigned_conversion;\n+      case __IO_LongVal:\n+        longval = io.__t.__vallong; \n+        goto signed_conversion;\n+      case __IO_ULongVal:\n+        ulongval = io.__t.__valulong; \n+        goto unsigned_conversion;\n+\n+      case __IO_BoolVal:\n+        switch( io.__t.__valbool )\n+        {\n+        case 0:\n+          itembeg = \"FALSE\";\n+          itemlen = 5;\n+          goto move_item;\n+        case 1:\n+          itembeg = \"TRUE\";\n+          itemlen = 4;\n+          goto move_item;\n+        default:\n+          IOEXCEPTION( TEXTFAIL, BOOL_CONVERSION_ERROR );\n+        }\n+ \n+      case __IO_CharVal:\n+        itembeg = &io.__t.__valchar;\n+        itemlen = 1;\n+        goto move_item;\n+  \n+      case __IO_SetVal:\n+        /* locate name string using set mode name table */\n+        itembeg = 0;\n+        \n+        if( (etptr = io.__t.__valset.name_table) )\n+          while( etptr->name )\n+\t  {\n+            if( etptr->value == io.__t.__valset.value )\n+\t    {\n+              itembeg = etptr->name;\n+              itemlen = strlen( itembeg );\n+              goto move_item;\n+            }\n+            etptr++;\n+          }\n+       IOEXCEPTION( TEXTFAIL, SET_CONVERSION_ERROR ); \n+\n+      case __IO_CharVaryingLoc:\n+        {\n+          unsigned short l;\n+          itembeg = (char*)io.__t.__loccharstring.string;\n+          MOV2(&l,itembeg);\n+          itembeg += 2;\n+          itemlen = l;\n+          goto move_item;\n+        }\n+\n+      case __IO_CharStrLoc:\n+        itembeg = io.__t.__loccharstring.string;\n+        itemlen = io.__t.__loccharstring.string_length;\n+        goto move_item;\n+\n+      case __IO_BitStrLoc:\n+        itemlen = io.__t.__loccharstring.string_length;\n+        itembeg = io.__t.__loccharstring.string;\n+\n+        if( !width )\n+          width = itemlen;\n+\n+        /* check remaining space */\n+        if( actual_index + width > iostrlen )\n+          IOEXCEPTION( TEXTFAIL, TEXT_LOC_OVERFLOW );\n+\n+        if( itemlen == width )\n+          bitput( iostrptr + actual_index, itembeg, 0, itemlen );\n+        else\n+          if( itemlen < width )\n+            if( leftadjust )\n+              memset( bitput( iostrptr + actual_index, itembeg, 0, itemlen )\n+                      + itemlen,\n+                      paddingchar, width - itemlen );\n+            else\n+              bitput( memset( iostrptr + actual_index, \n+                              paddingchar, width - itemlen )\n+                      + width - itemlen,\n+                      itembeg, itemlen - width, itemlen );\n+          else\n+            if( overflowev )\n+              memset( iostrptr + actual_index, '*', width );\n+            else\n+              if( leftadjust )\n+                bitput( iostrptr + actual_index, itembeg, 0, width );\n+              else\n+                bitput( iostrptr + actual_index, itembeg, \n+                        itemlen - width, itemlen );\n+        goto adjust_index;\n+\n+      case __IO_RealVal:\n+        doubleval = io.__t.__valreal;\n+        mantdigs = FMANTDIGS;\n+        goto fixed_point_conversion;\n+      case __IO_LongRealVal:\n+        doubleval = io.__t.__vallongreal;\n+        mantdigs = DBL_DIG;\n+        goto fixed_point_conversion;\n+        break;\n+\n+      default:\n+        IOEXCEPTION( TEXTFAIL, INVALID_IO_LIST );\n+      }\n+\n+    case HexConv:\n+    case OctalConv:\n+    case BinaryConv:\n+      switch( io.__descr )\n+      {\n+      case __IO_ByteVal:\n+      case __IO_UByteVal:\n+        ulongval = io.__t.__valubyte; \n+        break;\n+      case __IO_IntVal:\n+      case __IO_UIntVal:\n+        ulongval = io.__t.__valuint; \n+        break;\n+      case __IO_LongVal:\n+      case __IO_ULongVal:\n+        ulongval = io.__t.__valulong; \n+        break;\n+      default:\n+        IOEXCEPTION( TEXTFAIL, CONVCODE_MODE_MISFIT );\n+      }\n+      itembeg = myultoa( ulongval, itembuf, base[convcode] );\n+      itemlen = strlen( itembeg );\n+      goto move_item;\n+  \n+    case ScientConv:\n+      switch( io.__descr )\n+      {\n+      case __IO_RealVal:\n+        doubleval = io.__t.__valreal;\n+        mantdigs = FMANTDIGS;\n+        if( !fractiondef )\n+          fractionwidth = FMANTDIGS - 1;\n+        goto scientific_conversion;\n+      case __IO_LongRealVal:\n+        doubleval = io.__t.__vallongreal;\n+        mantdigs = DBL_DIG;\n+        if( !fractiondef )\n+          fractionwidth = DBL_DIG - 1;\n+        goto scientific_conversion;\n+        break;\n+      default:\n+        IOEXCEPTION( TEXTFAIL, CONVCODE_MODE_MISFIT );\n+      }\n+    }\n+\n+fixed_point_conversion: ;\n+    itembeg = mydtoa( doubleval, mantdigs, &de, &sign );\n+    if( fractiondef && de >= -fractionwidth - 1\n+        && -fractionwidth > de - mantdigs )\n+      itembeg = dround( itembeg, de + fractionwidth + 1, &de );\n+\n+    nid = de >= 0 ? de : 0;\n+    nfd = fractiondef ? fractionwidth \n+                      : ( de + 1 - mantdigs > 0 ? 0 : mantdigs - de - 1 );\n+    itemlen = ( sign < 0 ? 1 : 0 ) + 2 + nid + nfd;\n+#if _TEXTIO_DEBUG_\n+printf( \"fixed item length %d\\n\", itemlen );\n+#endif\n+    if( !width )\n+      width = itemlen;\n+#if _TEXTIO_DEBUG_\n+printf( \"fixed item width %d\\n\", width );\n+#endif\n+    /* check remaining space */\n+    if( actual_index + width > iostrlen )\n+      IOEXCEPTION( TEXTFAIL, TEXT_LOC_OVERFLOW );\n+\n+    if( itemlen == width )\n+      fixput( iostrptr + actual_index, itembeg, \n+              1, itemlen, sign, de, de - mantdigs, nid, nfd );\n+    else\n+      if( itemlen < width )\n+        if( leftadjust )\n+          memset( fixput( iostrptr + actual_index, itembeg, \n+                          1, itemlen, sign, de, de - mantdigs, nid, nfd )\n+                  + itemlen,\n+                  paddingchar, width - itemlen );\n+        else\n+          fixput( memset( iostrptr + actual_index, \n+                          paddingchar, width - itemlen )\n+                  + width - itemlen,\n+                  itembeg, 1, itemlen, sign, de, de - mantdigs, nid, nfd );\n+      else\n+        if( overflowev )\n+          memset( iostrptr + actual_index, '*', width );\n+        else\n+          if( leftadjust )\n+            fixput( iostrptr + actual_index, itembeg, \n+                    1, width, sign, de, de - mantdigs, nid, nfd );\n+          else\n+            fixput( iostrptr + actual_index, itembeg, \n+                    itemlen - width + 1, itemlen,\n+                    sign, de, de - mantdigs, nid, nfd );\n+    goto adjust_index;\n+\n+scientific_conversion: ;\n+    itembeg = mydtoa( doubleval, mantdigs, &de, &sign );\n+\n+    if( fractiondef && fractionwidth < mantdigs )\n+      itembeg = dround( itembeg, fractionwidth + 1, &de );\n+\n+    expbeg = myultoa( abs(de), itembuf, 10 );\n+    explen = strlen( expbeg );\n+\n+    expwid = explen > exponentwidth ? explen : exponentwidth;\n+    itemlen = ( sign < 0 ? 1 : 0 ) + 2 + fractionwidth + 2 + expwid;\n+#if _TEXTIO_DEBUG_\n+printf( \"floating item length %d, fraction %d, exponent %d\\n\", \n+        itemlen, fractionwidth, expwid );\n+#endif\n+    if( width == 0 )\n+      width = itemlen;\n+#if _TEXTIO_DEBUG_\n+printf( \"floating item width %d\\n\", width );\n+#endif\n+    /* check remaining space */\n+    if( actual_index + width > iostrlen )\n+      IOEXCEPTION( TEXTFAIL, TEXT_LOC_OVERFLOW );\n+\n+    if( itemlen == width )\n+      sciput( iostrptr + actual_index, itembeg, expbeg, \n+              1, itemlen, sign, de, expwid );\n+    else\n+      if( itemlen < width )\n+        if( leftadjust )\n+          memset( sciput( iostrptr + actual_index, itembeg, expbeg,\n+                          1, itemlen, sign, de, expwid )\n+                  + itemlen,\n+                  paddingchar, width - itemlen );\n+        else\n+          sciput( memset( iostrptr + actual_index, \n+                          paddingchar, width - itemlen )\n+                  + width - itemlen,\n+                  itembeg, expbeg, 1, itemlen, sign, de, expwid );\n+      else\n+        if( overflowev )\n+          memset( iostrptr + actual_index, '*', width );\n+        else\n+          if( leftadjust )\n+            sciput( iostrptr + actual_index, itembeg, expbeg,\n+                    1, width, sign, de, expwid );\n+          else\n+            sciput( iostrptr + actual_index, itembeg, expbeg,\n+                    itemlen - width + 1, itemlen,\n+                    sign, de, expwid );\n+    goto adjust_index;\n+\n+signed_conversion: ;   \n+    if( longval >= 0 )\n+      itembeg = myultoa( longval, itembuf, 10 );\n+    else\n+    {\n+      itembuf[0] = '-';\n+      myultoa( -longval, itembuf+1, 10 );\n+      itembeg = itembuf;\n+    }  \n+    itemlen = strlen( itembeg );\n+    goto move_item;\n+\n+unsigned_conversion: ;\n+    itembeg = myultoa( ulongval, itembuf, 10 );\n+    itemlen = strlen( itembeg );\n+    goto move_item;\n+\n+move_item: ;\n+    if( !width )\n+      width = itemlen;\n+\n+    /* check remaining space */\n+    if( actual_index + width > iostrlen )\n+      IOEXCEPTION( TEXTFAIL, TEXT_LOC_OVERFLOW );\n+\n+    /* move item, filling or truncating or overflow-evidencing */\n+    if( itemlen == width )\n+      memcpy( iostrptr + actual_index, itembeg, itemlen );\n+    else\n+      if( itemlen < width )\n+        if( leftadjust )\n+          memset( memcpy( iostrptr + actual_index, itembeg, itemlen )\n+                  + itemlen,\n+                  paddingchar, width - itemlen );\n+        else\n+          memcpy( memset( iostrptr + actual_index, \n+                          paddingchar, width - itemlen )\n+                  + width - itemlen,\n+                  itembeg, itemlen );\n+      else\n+        if( overflowev )\n+          memset( iostrptr + actual_index, '*', width );\n+        else\n+          if( leftadjust )\n+            memcpy( iostrptr + actual_index, itembeg, width );\n+          else\n+            memcpy( iostrptr + actual_index, \n+                    itembeg + itemlen - width, width );\n+\n+  /*\n+   *  adjust.\n+   */\n+adjust_index: ;\n+  actual_index += width;\n+  if( actual_index > maximum_index )\n+    maximum_index = actual_index;\n+  }\n+}\n+\n+static\n+void outedit( void )\n+{\n+  int nchars;\n+\n+  if( dynamicwid )\n+    clausewidth = get_field_width();\n+  switch( editcode )\n+  { \n+  case SpaceSkip:\n+    nchars = repetition*clausewidth;\n+    if( actual_index + nchars > iostrlen )\n+      IOEXCEPTION( TEXTFAIL, TEXT_LOC_OVERFLOW );\n+    memset( iostrptr + actual_index, ' ', nchars );\n+    actual_index += nchars;\n+    if( actual_index > maximum_index )\n+      maximum_index = actual_index;\n+    break;\n+\n+  case SkipLeft:\n+    nchars = repetition*clausewidth;\n+    if(  actual_index - nchars < 0 )\n+      IOEXCEPTION( TEXTFAIL, TEXT_LOC_OVERFLOW );\n+    actual_index -= nchars;\n+    break;\n+\n+  case SkipRight:\n+    nchars = repetition*clausewidth;\n+    if( actual_index + nchars > iostrlen )\n+      IOEXCEPTION( TEXTFAIL, TEXT_LOC_OVERFLOW );\n+    actual_index += nchars;\n+    if( actual_index > maximum_index )\n+    {\n+      memset( iostrptr + maximum_index, ' ', actual_index - maximum_index );\n+      maximum_index = actual_index;\n+    }\n+    break;\n+  \n+  case Tabulation:\n+    if( clausewidth >= iostrlen )\n+      IOEXCEPTION( TEXTFAIL, TEXT_LOC_OVERFLOW );\n+    actual_index = clausewidth;\n+    if( actual_index > maximum_index )\n+    {\n+      memset( iostrptr + maximum_index, ' ', actual_index - maximum_index );\n+      maximum_index = actual_index;\n+    }  \n+    break;\n+  }\n+}\n+\n+\n+static\n+void inpioctrl( void )\n+{\n+  unsigned short hlen;\n+  if( !textptr )\n+    IOEXCEPTION( TEXTFAIL, IO_CONTROL_NOT_VALID );\n+  if( iocode != EndPage )\n+  {\n+    jmp_buf ioerror;\n+    unsigned long info;\n+\n+    if (textptr->access_sub->association)\n+      {\n+\tif( (info = setjmp( ioerror )) )\n+\t  IOEXCEPTION( info>>16, info & 0xffff );    \n+\twhile( repetition-- )\n+\t  {\n+\t    __readrecord( textptr->access_sub, textindex,\n+\t\t\t (char*)textptr->text_record, \n+\t\t\t __FILE__, __LINE__ );\n+\t    actual_index = 0;\n+\t    MOV2(&hlen,&textptr->text_record->len);\n+\t    iostrlen = hlen;\n+\t  }\n+      }\n+    else\n+      IOEXCEPTION (NOTCONNECTED, IS_NOT_CONNECTED);\n+  }\n+}\n+\n+/* specify pre/post in the order \"/+-?!\" */\n+static\n+char* pre_char =  \"\\0\\f\\0\\r\\0\"; /* Z.200: \"\\n\\f\\0\\n\\0\" */\n+static\n+char* post_char = \"\\n\\n\\r\\0\\0\"; /* Z.200: \"\\r\\r\\r\\0\\0\" */\n+\n+static\n+void outioctrl( void )\n+{\n+  Association_Mode* assoc;\n+  unsigned short hlen;\n+  if( !textptr )\n+    IOEXCEPTION( TEXTFAIL, IO_CONTROL_NOT_VALID );\n+  if( (assoc = textptr->access_sub->association) )\n+  {\n+    jmp_buf ioerror;\n+    unsigned long info;\n+    if( (info = setjmp( ioerror )) )\n+      IOEXCEPTION( info>>16, info & 0xffff );    \n+\n+    while( repetition-- )\n+    {\n+      if( iocode != EndPage )\n+      {\n+        if( TEST_FLAG( assoc, IO_FIRSTLINE ) )\n+        {\n+          CLR_FLAG( assoc, IO_FIRSTLINE );\n+          assoc->ctl_pre = '\\0';\n+        }\n+        else\n+        {\n+          if( TEST_FLAG( assoc, IO_FORCE_PAGE ) )\n+          {\n+            CLR_FLAG( assoc, IO_FORCE_PAGE );\n+            assoc->ctl_pre = '\\f';\n+\t  }\n+          else\n+            assoc->ctl_pre = pre_char[iocode];\n+        }\n+        assoc->ctl_post = post_char[iocode];\n+        hlen = actual_index;\n+        MOV2(&textptr->text_record->len,&hlen);\n+        __writerecord( textptr->access_sub, textindex,\n+                       (char*)textptr->text_record,\n+                       textptr->text_record->len,\n+                       __FILE__, __LINE__ );\n+        hlen = actual_index = 0;\n+        MOV2(&textptr->text_record->len,&hlen);\n+      }\n+      else if( !TEST_FLAG( textptr, IO_FIRSTLINE ) )\n+\tSET_FLAG( textptr, IO_FORCE_PAGE );\n+      assoc->ctl_pre = assoc->ctl_post = '\\0';\n+    }\n+  }\n+  else\n+    IOEXCEPTION (NOTCONNECTED, IS_NOT_CONNECTED);\n+}\n+\n+static\n+void (**actionptr)( void );\n+static\n+void (*readactions[])( void ) = { inpconv, inpedit, inpioctrl };\n+static\n+void (*writeactions[])( void ) = { outconv, outedit, outioctrl };\n+\n+\n+static\n+void emitstr( char* begtxt, char* endtxt )\n+{  \n+  char c;\n+  int  nchars = endtxt - begtxt;\n+  if( actual_index + nchars > iostrlen )\n+      IOEXCEPTION( TEXTFAIL, TEXT_LOC_OVERFLOW );\n+  memcpy( iostrptr + actual_index, begtxt, nchars );\n+  actual_index += nchars;\n+  if( actual_index > maximum_index )\n+    maximum_index = actual_index;\n+}\n+\n+static\n+void scanstr( char* begtxt, char* endtxt )\n+{  \n+  int  nchars = endtxt - begtxt;\n+  if( actual_index + nchars > iostrlen )\n+    IOEXCEPTION( TEXTFAIL, NO_CHARS_FOR_TEXT );\n+  if( strncmp( iostrptr + actual_index, begtxt, nchars ) )\n+    IOEXCEPTION( TEXTFAIL, FORMAT_TEXT_MISMATCH );\n+  actual_index += nchars;\n+}\n+\n+void (*ftextptr) ( char*, char* );\n+\n+static\n+formatexit_t scanformcont( char* fcs, int len,\n+                           char** fcsptr, int* lenptr )\n+{\n+  char          curr; \n+  fcsstate_t    state  = FormatText;\n+  unsigned long buf;\n+  int           dig;\n+  acttype_t     action;\n+  char*         begtxt = fcs;\n+\n+  while( len-- )\n+  {\n+    curr = *fcs++;\n+    switch( state )\n+    {\n+    case FormatText: \n+      if( curr == '%' )\n+      {\n+        ftextptr( begtxt, fcs-1 );\n+        state = FirstPercent;\n+      }\n+      break;\n+\n+after_first_percent: ;\n+    case FirstPercent: \n+      if( curr == '%' )\n+      {\n+        state = FormatText;\n+        begtxt = fcs - 1;\n+        break;\n+      }\n+      if( curr == ')' )\n+      {\n+        *lenptr = len;\n+        *fcsptr = fcs;\n+        return EndAtParen;\n+      }\n+      if( isDEC(curr) )\n+      {\n+        state = RepFact;\n+        repetition = curr - '0';\n+        break;\n+      }\n+\n+      repetition = 1; \n+\n+test_for_control_codes: ;\n+      if( isCVC(curr) )\n+      {\n+        state = ConvClause;\n+        action = ConvAct;\n+        convcode = strchr( CONVERSIONCODES, curr ) - CONVERSIONCODES;\n+        leftadjust = False;\n+        overflowev = False;\n+        dynamicwid = False;\n+        paddingdef = False;\n+        paddingchar = ' ';\n+        fractiondef = False;\n+        /* fractionwidth = 0; default depends on mode ! */\n+        exponentdef = False;\n+        exponentwidth = 3;\n+        clausewidth = 0;        \n+        break;        \n+      }\n+      if( isEDC(curr) )\n+      {\n+        state = EditClause;\n+        action = EditAct;\n+        editcode = strchr( EDITCODES, curr ) - EDITCODES;\n+        dynamicwid = False;\n+        clausewidth = editcode == Tabulation ? 0 : 1;        \n+        break;        \n+      }\n+      if( isIOC(curr) )\n+      {\n+        state = ClauseEnd;\n+        action = IOAct;\n+        iocode = strchr( IOCODES, curr ) - IOCODES;\n+        break;        \n+      }\n+      if( curr == '(' )\n+      {\n+        unsigned long times = repetition;\n+        int  cntlen;\n+        char* cntfcs;         \n+        while( times-- )\n+        {        \n+          if( scanformcont( fcs, len, &cntfcs, &cntlen ) != EndAtParen )\n+            IOEXCEPTION( TEXTFAIL, UNMATCHED_OPENING_PAREN );\n+        }\n+        fcs = cntfcs;\n+        len = cntlen;\n+        state  = FormatText;\n+        begtxt = fcs;\n+        break;\n+      }\n+      IOEXCEPTION( TEXTFAIL, BAD_FORMAT_SPEC_CHAR );\n+\n+    case RepFact:\n+      if( isDEC(curr) )\n+      {\n+        dig = curr - '0';\n+        if( repetition > (ULONG_MAX - dig)/10 )\n+          IOEXCEPTION( TEXTFAIL, REPFAC_OVERFLOW );\n+        repetition = repetition*10 + dig;\n+        break;\n+      }\n+      goto test_for_control_codes;\n+\n+    case ConvClause:\n+      if( isDEC(curr) )\n+      {\n+        state = ClauseWidth;\n+        clausewidth = curr - '0';\n+        break;\n+      }\n+      if( curr == 'L' )  \n+      {\n+        if( leftadjust ) \n+          IOEXCEPTION( TEXTFAIL, DUPLICATE_QUALIFIER );\n+        leftadjust = True;\n+        break;\n+      }\n+      if( curr == 'E' )\n+      {\n+        if( overflowev ) \n+          IOEXCEPTION( TEXTFAIL, DUPLICATE_QUALIFIER );\n+        overflowev = True;\n+        break;\n+      }\n+      if( curr == 'P' )\n+      {\n+        if( paddingdef ) \n+          IOEXCEPTION( TEXTFAIL, DUPLICATE_QUALIFIER );\n+        paddingdef = True;\n+        state = CatchPadding;\n+        break;\n+      }\n+\n+test_for_variable_width: ;\n+      if( curr == 'V' )\n+      {\n+        dynamicwid = True;\n+        state = AfterWidth;\n+        break;\n+      }\n+      goto test_for_fraction_width;\n+\n+    case ClauseWidth:\n+      if( isDEC(curr) )\n+      {\n+        dig = curr - '0';\n+        if( clausewidth > (ULONG_MAX - dig)/10 )\n+          IOEXCEPTION( TEXTFAIL, CLAUSE_WIDTH_OVERFLOW );\n+        clausewidth = clausewidth*10 + dig;\n+        break;\n+      }\n+      /* fall through */\n+\n+test_for_fraction_width: ;\n+    case AfterWidth:\n+      if( curr == '.' )\n+      {\n+        if( convcode != DefaultConv && convcode != ScientConv )\n+          IOEXCEPTION( TEXTFAIL, NO_FRACTION );\n+        fractiondef = True;\n+        state = FractWidth;\n+        break;\n+      }\n+      goto test_for_exponent_width;\n+\n+    case FractWidth:\n+      if( isDEC( curr ) )\n+      {\n+        state = FractWidthCont;\n+        fractionwidth = curr - '0';\n+        break;\n+      }\n+      else\n+        IOEXCEPTION( TEXTFAIL, NO_FRACTION_WIDTH );\n+\n+    case FractWidthCont:\n+      if( isDEC( curr ) )\n+      {\n+        dig = curr - '0';\n+        if( fractionwidth > (ULONG_MAX - dig)/10 )\n+          IOEXCEPTION( TEXTFAIL, FRACTION_WIDTH_OVERFLOW );\n+        fractionwidth = fractionwidth*10 + dig;\n+        break;\n+      }\n+             \n+test_for_exponent_width: ;\n+      if( curr == ':' )\n+      {\n+        if( convcode != ScientConv )\n+          IOEXCEPTION( TEXTFAIL, NO_EXPONENT );\n+        exponentdef = True;\n+        state = ExpoWidth;\n+        break;\n+      }\n+      goto test_for_final_percent;\n+\n+    case ExpoWidth:\n+      if( isDEC( curr ) )\n+      {\n+        state = ExpoWidthCont;\n+        exponentwidth = curr - '0';\n+        break;\n+      }\n+      else\n+        IOEXCEPTION( TEXTFAIL, NO_EXPONENT_WIDTH );\n+\n+    case ExpoWidthCont:\n+      if( isDEC( curr ) )\n+      {\n+        dig = curr - '0';\n+        if( exponentwidth > (ULONG_MAX - dig)/10 )\n+          IOEXCEPTION( TEXTFAIL, EXPONENT_WIDTH_OVERFLOW );\n+        exponentwidth = exponentwidth*10 + dig;\n+        break;\n+      }\n+      /* fall through  */\n+\n+test_for_final_percent: ;\n+    case ClauseEnd:\n+      if( curr == '%' )\n+      {\n+        state = LastPercent;\n+        break;\n+      }\n+ \n+  do_the_action: ;\n+      actionptr[action]();\n+      state = FormatText;\n+      begtxt = fcs - 1;\n+      break;\n+\n+    case CatchPadding:\n+      paddingchar = curr;\n+      state = ConvClause;\n+      break;\n+\n+    case EditClause:\n+      if( isDEC(curr) )\n+      {\n+        state = ClauseWidth;\n+        clausewidth = curr - '0';\n+        break;\n+      }\n+      goto test_for_variable_width; \n+\n+    case LastPercent:\n+      actionptr[action]();\n+      if( curr == '.' )\n+      {\n+        state = FormatText;\n+        begtxt = fcs;\n+        break;\n+      }\n+      goto after_first_percent;\n+\n+    default:\n+      IOEXCEPTION( TEXTFAIL, INTERNAL_ERROR );\n+    }\n+  }\n+  switch( state )\n+  {\n+  case FormatText:\n+    ftextptr( begtxt, fcs );\n+    break;\n+  case FirstPercent: \n+  case LastPercent:\n+  case RepFact:\n+  case FractWidth:\n+  case ExpoWidth:\n+    IOEXCEPTION( TEXTFAIL, BAD_FORMAT_SPEC_CHAR );\n+  case CatchPadding:\n+    IOEXCEPTION( TEXTFAIL, NO_PAD_CHAR );\n+  default:\n+    actionptr[action]();\n+  }\n+\n+  *lenptr = len;\n+  *fcsptr = fcs;\n+  return NormalEnd;\n+}\n+\n+static\n+void\n+__read_format (char*           fmtptr,\n+               int             fmtlen,\n+               __tmp_IO_list*  ioptr,\n+               int             iolen,\n+               void*           inpptr,\n+               int             inplen )\n+{\n+  formatexit_t res;\n+  unsigned short l;\n+\n+  iostrptr = (char*)inpptr;\n+  iostrlen = inplen;\n+\n+  /* initialisation */\n+  iolist_index = 0;\n+  iolistptr    = ioptr; \n+  iolistlen    = iolen;\n+  \n+  actionptr = readactions;\n+  ftextptr = scanstr;\n+     \n+  if( (res = scanformcont( fmtptr, fmtlen, &fmtptr, &fmtlen )) == EndAtParen )\n+    IOEXCEPTION( TEXTFAIL, UNMATCHED_CLOSING_PAREN );\n+\n+  if( iolist_index != iolen )\n+    IOEXCEPTION( TEXTFAIL, EXCESS_IOLIST_ELEMENTS );\n+\n+  return;\n+}\n+\n+void\n+__readtext_f( Text_Mode*      the_text_loc,\n+              signed long     the_index,\n+              char*           fmtptr,\n+              int             fmtlen,\n+              __tmp_IO_list*  ioptr,\n+              int             iolen,\n+              char*           file,\n+              int             line )\n+{\n+  unsigned long info;\n+\n+  if( (info = setjmp( __io_exception )) )\n+    CHILLEXCEPTION( file, line, info>>16, info & 0xffff );\n+\n+  textptr       = the_text_loc;\n+  textrecptr    = textptr->text_record;\n+  actual_index  = textptr->actual_index;\n+  textindex     = the_index;\n+\n+  __read_format ( fmtptr, fmtlen, ioptr, iolen,\n+                  (char*)textrecptr + 2, textptr->text_record->len );\n+  textptr->actual_index = actual_index;\n+}\n+\n+void\n+__readtext_s( void*           string_ptr,\n+              int             string_len,\n+              char*           fmtptr,\n+              int             fmtlen,\n+              __tmp_IO_list*  ioptr,\n+              int             iolen,\n+              char*           file,\n+              int             line )\n+{\n+  int info;\n+\n+  if( (info = setjmp( __io_exception )) )\n+    CHILLEXCEPTION( file, line, info>>16, info & 0xffff );\n+\n+  textptr      = NULL;\n+  actual_index = 0;\n+\n+  __read_format ( fmtptr, fmtlen,  ioptr, iolen, string_ptr, string_len );\n+}\n+\n+static\n+void\n+__write_format (char*           fmtptr,\n+                int             fmtlen,\n+                __tmp_IO_list*  ioptr,\n+                int             iolen,\n+                void*           outptr,\n+                int             outlen )\n+{\n+  formatexit_t res;\n+  unsigned short l;\n+\n+  /* initialisation */\n+  maximum_index = actual_index;\n+  iolist_index = 0;\n+  \n+  actionptr = writeactions;\n+  ftextptr  = emitstr;\n+  iolistptr = ioptr; \n+  iolistlen = iolen;\n+  iostrptr  = (char *)outptr + 2;\n+  iostrlen  = outlen;\n+\n+  if( (res = scanformcont( fmtptr, fmtlen, &fmtptr, &fmtlen )) == EndAtParen )\n+    IOEXCEPTION( TEXTFAIL, UNMATCHED_CLOSING_PAREN );\n+\n+  if( iolist_index != iolen )\n+    IOEXCEPTION( TEXTFAIL, EXCESS_IOLIST_ELEMENTS );\n+\n+  /* set length of output string */\n+#if _TEXTIO_DEBUG_\n+  printf( \"maximum index = %d\\n\", maximum_index );\n+#endif\n+  l = maximum_index;\n+  MOV2(outptr,&l);\n+  return;\n+}\n+\n+void\n+__writetext_f( Text_Mode*      the_text_loc,\n+               signed long     the_index,\n+               char*           fmtptr,\n+               int             fmtlen,\n+               __tmp_IO_list*  ioptr,\n+               int             iolen,\n+               char*           file,\n+               int             line )\n+{\n+  int info;\n+\n+  if( (info = setjmp( __io_exception )) )\n+    CHILLEXCEPTION( file, line, info>>16, info & 0xffff );\n+\n+  textptr       = the_text_loc;\n+  textrecptr    = the_text_loc->text_record;\n+  textindex     = the_index;\n+  iolistptr     = ioptr; \n+  iolistlen     = iolen;\n+\n+  actual_index = textptr->actual_index;\n+  __write_format ( fmtptr, fmtlen, ioptr, iolen,\n+                   textrecptr, textptr->access_sub->reclength - 2 );\n+  textptr->actual_index = actual_index;\n+}\n+\n+void\n+__writetext_s( void*           string_ptr,\n+               int             string_len,\n+               char*           fmtptr,\n+               int             fmtlen,\n+               __tmp_IO_list*  ioptr,\n+               int             iolen,\n+               char*           file,\n+               int             line )\n+{\n+  int info;\n+\n+  if( (info = setjmp( __io_exception )) )\n+    CHILLEXCEPTION( file, line, info>>16, info & 0xffff );\n+\n+  textptr      = NULL;\n+  actual_index = 0;\n+\n+  __write_format ( fmtptr, fmtlen, ioptr, iolen, string_ptr, string_len );\n+}"}, {"sha": "60fa703a7d207ed36ece4a51dccf6d717a611a52", "filename": "gcc/ch/runtime/gettextindex.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fgettextindex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fgettextindex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fgettextindex.c?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,30 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"fileio.h\"\n+\n+unsigned long\n+__gettextindex( Text_Mode* the_text, char* file, int line )\n+{\n+  if( !the_text )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_TEXT );\n+\n+  return the_text->actual_index;\n+}"}, {"sha": "a3a4d4996105899e9bbf47c6808f171190f116b1", "filename": "gcc/ch/runtime/isassociated.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fisassociated.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fisassociated.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fisassociated.c?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,29 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"fileio.h\"\n+\n+Boolean\n+__isassociated( Association_Mode* the_assoc, char* file, int line )\n+{\n+  if( !the_assoc )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_ASSOCIATION );\n+  return TEST_FLAG(the_assoc, IO_ISASSOCIATED) ? True : False;\n+}"}, {"sha": "220577d764260f37dd06c95de558ad0efba59174", "filename": "gcc/ch/runtime/neps.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fneps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fneps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fneps.c?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,52 @@\n+/* Implement POWERSET runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"powerset.h\"\n+\n+/*\n+ * function __nepowerset\n+ *\n+ * parameters:\n+ *\tleft\t\tleft powerset\n+ *\tright\t\tright powerset\n+ *\tbitlength\tlength of powerset in bits\n+ *\n+ * returns:\n+ *    1 if powersets are not equal, bit for bit\n+ *\n+ * exceptions:\n+ *  none\n+ *\n+ * abstract:\n+ *  compares two powersets for inequality\n+ *\n+ */\n+int\n+__nepowerset (left, right, bitlength)\n+     SET_WORD *left;\n+     SET_WORD *right;\n+     unsigned long bitlength;\n+{\n+  return ! __eqpowerset (left, right, bitlength);\n+}"}, {"sha": "dd683edea4e2136558bd98228c23d6b4572af673", "filename": "gcc/ch/runtime/notps.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fnotps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fnotps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fnotps.c?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,81 @@\n+/* Implement POWERSET runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"powerset.h\"\n+\n+/*\n+ * function __notpowerset\n+ *\n+ * parameters:\n+ *\tout\t\toutput powerset\n+ *\tleft\t\tinput powerset\n+ *\tbitlength\tlength of powerset in bits\n+ *\n+ * returns:\n+ *\tvoid\n+ *\n+ * exceptions:\n+ *  none\n+ *\n+ * abstract:\n+ *\n+ */\n+\n+void\n+__notpowerset (out, left, bitlength)\n+     SET_WORD      *out;\n+     SET_WORD      *left;\n+     unsigned long  bitlength;\n+{\n+  if (bitlength <= SET_CHAR_SIZE)\n+    {\n+      *((SET_CHAR *)out) = ~ (*((SET_CHAR *)left));\n+#if 0\n+      SET_CHAR tmp;\n+      tmp = *((SET_CHAR *)left);\n+      tmp = ~ tmp;\n+      *((SET_CHAR *)out) = tmp;\n+\n+      MASK_UNUSED_CHAR_BITS((SET_CHAR *)out, bitlength);\n+      *((SET_CHAR *)out) = ~ *((SET_CHAR *)left);\n+      MASK_UNUSED_CHAR_BITS((SET_CHAR *)out, bitlength);\n+      *((SET_CHAR *)out) = (~(0)) ^  (*((SET_CHAR *)left));\n+      MASK_UNUSED_CHAR_BITS((SET_CHAR *)out, bitlength);\n+#endif\n+    }\n+  else if (bitlength <= SET_SHORT_SIZE)\n+    {\n+      *((SET_SHORT *)out) = ~  (*((SET_SHORT *)left));\n+      MASK_UNUSED_SHORT_BITS((SET_SHORT *)out, bitlength);\n+    }\n+  else\n+    {\n+      unsigned long len = BITS_TO_WORDS(bitlength);\n+      register unsigned long i;\n+    \n+      for (i = 0; i < len; i++)\n+\tout[i] = ~ left[i];\n+      MASK_UNUSED_WORD_BITS((out + len - 1), bitlength % SET_WORD_SIZE);\n+    }\n+}"}, {"sha": "9dd9617de19479a95da86aea3ae962ea0d1ae787", "filename": "gcc/ch/runtime/printbuffer.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fprintbuffer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fprintbuffer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fprintbuffer.c?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,116 @@\n+/* Implement tasking-related runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include \"rtltypes.h\"\n+#include \"rts.h\"\n+\n+typedef char *(*fetch_names) (int number);\n+extern fetch_names\t__RTS_FETCH_NAMES__;\n+\n+/*\n+ * function print_instance\n+ *\n+ */\n+\n+static char *print_instance (ins)\n+     INSTANCE ins;\n+{\n+  static char  buf[256];\n+  char *f;\n+\n+  if (!__RTS_FETCH_NAMES__)\n+    f = 0;\n+  else\n+    f = (*__RTS_FETCH_NAMES__) (ins.ptype);\n+  if (!f)\n+    sprintf (buf, \"[%u;%u]\", ins.ptype, ins.pcopy);\n+  else\n+    sprintf (buf, \"[%s;%u]\", f, ins.pcopy);\n+  return buf;\n+}\n+\n+/*\n+ * function __print_buffer\n+ *\n+ * parameters:\n+ *     buffer      buffer location\n+ *\n+ * returns:\n+ *     void\n+ *\n+ * exceptions:\n+ *     none\n+ *\n+ * abstract:\n+ *     Function is used for debugging purposes only to print a\n+ *     buffer queue\n+ */\n+\n+void\n+__print_buffer (buffer, name)\n+     Buffer_Queue   **buffer;\n+     char            *name;\n+{\n+  Buffer_Queue      *bq;\n+  int                bsqcnt = 0, bwqcnt = 0;\n+  Buffer_Send_Queue *bsq;\n+  Buffer_Wait_Queue *bwq;\n+\n+  if (name)\n+    printf (\"Buffer %s:\\n\", name);\n+  else\n+    printf (\"Buffer at address H'%X:\\n\", buffer);\n+\n+  memcpy (&bq, buffer, sizeof (Buffer_Queue *));\n+  if (bq == 0)\n+    {\n+      printf (\"EMPTY\\n\");\n+      return;\n+    }\n+\n+  bsq = bq->sendqueue;\n+  if (bsq != 0)\n+      printf (\"Send Queue:\\n\");\n+  while (bsq)\n+    {\n+      printf (\" %3d: \", ++bsqcnt);\n+      printf (\"Process %s, \", print_instance (bsq->this));\n+      printf (\"Priority %d\", bsq->priority);\n+      if (bsq->is_delayed)\n+\tprintf (\", Delayed\");\n+      printf (\"\\n\");\n+      bsq = bsq->forward;\n+    }\n+  bwq = bq->waitqueue;\n+  if (bwq != 0)\n+      printf (\"Wait Queue:\\n\");\n+  while (bwq)\n+    {\n+      printf (\" %3d: \", ++bwqcnt);\n+      printf (\"Process %s, \", print_instance (bwq->this));\n+      if (bwq->is_sent)\n+\tprintf (\", Send by %s\", print_instance (bwq->who_sent));\n+      printf (\"\\n\");\n+      bwq = bwq->forward;\n+    }\n+  if (bsqcnt == 0 && bwqcnt == 0)\n+    printf (\"EMPTY\\n\");\n+}"}, {"sha": "c491a2c781d2fa21aaac6cc469d50ed66d3792c1", "filename": "gcc/ch/runtime/printevent.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fprintevent.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fprintevent.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fprintevent.c?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,93 @@\n+/* Implement tasking-related runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include \"rtltypes.h\"\n+#include \"rts.h\"\n+\n+typedef char *(*fetch_names) (int number);\n+extern fetch_names\t__RTS_FETCH_NAMES__;\n+\n+/*\n+ * function print_instance\n+ *\n+ */\n+\n+static char *print_instance (ins)\n+     INSTANCE ins;\n+{\n+  static char  buf[256];\n+  char *f;\n+\n+  if (!__RTS_FETCH_NAMES__)\n+    f = 0;\n+  else\n+    f = (*__RTS_FETCH_NAMES__) (ins.ptype);\n+  if (!f)\n+    sprintf (buf, \"[%u;%u]\", ins.ptype, ins.pcopy);\n+  else\n+    sprintf (buf, \"[%s;%u]\", f, ins.pcopy);\n+  return buf;\n+}\n+\n+/*\n+ * function __print_event\n+ *\n+ * parameters:\n+ *     event      event location\n+ *\n+ * returns:\n+ *     void\n+ *\n+ * exceptions:\n+ *     none\n+ *\n+ * abstract:\n+ *     Function is used for debugging purposes only to print an\n+ *     event queue\n+ */\n+\n+void\n+__print_event (evaddr, name)\n+     Event_Queue   **evaddr;\n+     char           *name;\n+{\n+  Event_Queue    *ev;\n+  int            cnt = 0;\n+\n+  if (name)\n+    printf (\"Event %s:\\n\", name);\n+  else\n+    printf (\"Event at address H'%X:\\n\", evaddr);\n+\n+  memcpy (&ev, evaddr, sizeof (Event_Queue *));\n+  while (ev)\n+    {\n+      printf (\" %3d: \", ++cnt);\n+      printf (\"Process %s, \", print_instance (ev->this));\n+      printf (\"Priority %d\", ev->priority);\n+      if (ev->is_continued)\n+\tprintf (\" ,Continued by %s\", print_instance (ev->who_continued));\n+      printf (\"\\n\");\n+      ev = ev->forward;\n+    }\n+  if (!cnt)\n+    printf (\"EMPTY\\n\");\n+}"}, {"sha": "a17ef7b5822df10517e60bea89634835a6f6cce0", "filename": "gcc/ch/runtime/retmem.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fretmem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fretmem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fretmem.c?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,52 @@\n+/* Implement runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+\n+/*\n+ * function _return_memory\n+ *\n+ * parameter:\n+ *  ptr\t\t\tpointer to memory to free\n+ *  filename            source file which issued the call\n+ *  linenumber          line number of the call within that file\n+ *\n+ * returns:\n+ *  void\n+ *\n+ * exceptions:\n+ *  none\n+ *\n+ * abstract:\n+ *  free memory previously allocated by _allocate_(global_)memory\n+ *\n+*/\n+\n+void\n+_return_memory (ptr, filename, linenumber)\n+     void *ptr;\n+     char *filename;\n+     int linenumber;\n+{\n+    free (ptr);\n+}"}, {"sha": "ed994f33ccbc1bb87650968dcbdff7b9d80c33e9", "filename": "gcc/ch/runtime/rtltypes.h", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Frtltypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Frtltypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Frtltypes.h?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,61 @@\n+#ifndef __rtltypes_h__\n+#define __rtltypes_h__\n+\n+#include <setjmp.h>\n+\n+/* Add prototype support.  */\n+#ifndef PROTO\n+#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)\n+#define PROTO(ARGS) ARGS\n+#else\n+#define PROTO(ARGS) ()\n+#endif\n+#endif\n+\n+/* argc, argv */\n+typedef struct\n+{\n+    unsigned short\tlen;\n+    char\t\tbody[0];\n+} TVaryingCharType;\n+\n+#ifndef __CHILL_LIB__\n+extern TVaryingCharType\t**chill_argv;\n+extern int\t\tchill_argc;\n+#endif\n+\n+/* definitions for exceptions */\n+typedef struct\n+{\n+    char\t*exname;\n+    short\texnumber;\n+} TExceptionDefinition;\n+\n+#if 1\n+typedef char *__ch_exception;\n+#define EX_EQ(e1, e2) (strcmp(e1, e2)==0)\n+#else\n+typedef void *__ch_exception;\n+#define EX_EQ(e1, e2) (e1 == e2)\n+#endif\n+#define __ch_else_except ((__ch_exception)0)\n+\n+struct __ch_handled_excepts\n+{\n+  /* List is ended by a code==0, or ex==__ch_else_except (ELSE handler). */\n+  __ch_exception ex;\n+  int code; /* Positive number indicating ordinal in handler list. */\n+};\n+\n+/* definitions for exception handlers */\n+typedef struct  __ch_handler\n+{\n+  struct __ch_handler *prev;\n+  struct __ch_handled_excepts *handlers;\n+  jmp_buf jbuf;\n+} TExceptionHandlerStack;\n+\n+/* exceptions */\n+#define EXCEPTION(x)\t/* nothing */\n+\n+#endif /* __rtltypes_h__ */"}, {"sha": "b7602e970cce44a2b8d17eaba82ec3d8c61665e4", "filename": "gcc/ch/runtime/rts.c", "status": "added", "additions": 655, "deletions": 0, "changes": 655, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Frts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Frts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Frts.c?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,655 @@\n+/* GNU CHILL compiler regression test file\n+ Copyright (C) 1992, 1993 Free Software Foundation, Inc.\n+ \n+ This file is part of GNU CC.\n+\n+ GNU CC is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU CC is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU CC; see the file COPYING.  If not, write to\n+ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <stdlib.h>\n+#include <setjmp.h>\n+#include <signal.h>\n+\n+#include \"rts.h\"\n+\n+\n+/* some allocation/reallocation functions */\n+\n+static void *\n+xmalloc (size)\n+     int size;\n+{\n+  void *tmp = malloc (size);\n+\n+  if (!tmp)\n+    {\n+      fprintf (stderr, \"Out of heap space.\\n\");\n+      exit (1);\n+    }\n+  return (tmp);\n+}\n+\n+static void *\n+xrealloc (ptr, size)\n+     void *ptr;\n+     int size;\n+{\n+  void *tmp = realloc (ptr, size);\n+\n+  if (!tmp)\n+    {\n+      fprintf (stderr, \"Out of heap space.\\n\");\n+      exit (1);\n+    }\n+  return (tmp);\n+}\n+\n+/* the necessary data */\n+#define MAX_NUMBER 100\n+typedef char UsedValues[MAX_NUMBER];\n+\n+#define MAX_COPIES 100\n+\n+#define MAX_PER_ITEM 20\n+typedef struct TASKINGSTRUCTLIST\n+{\n+  struct TASKINGSTRUCTLIST *forward;\n+  int    num;\n+  TaskingStruct *data[MAX_PER_ITEM];\n+  char copies[MAX_COPIES];\n+  jmp_buf where;\n+} TaskingStructList;\n+\n+static TaskingStructList *task_array[LAST_AND_UNUSED];\n+static UsedValues used_values[LAST_AND_UNUSED];\n+\n+static short\n+get_next_free_number (vals)\n+     UsedValues vals;\n+{\n+  short  i;\n+  for (i = 1; i < MAX_NUMBER; i++)\n+    {\n+      if (!vals[i])\n+\t{\n+\t  vals[i] = 1;\n+\t  return (i);\n+\t}\n+    }\n+  fprintf (stderr, \"There are no more free numbers.\\n\");\n+  exit (1);\n+}\n+\n+/* function search for the next available copy number */\n+static short\n+get_next_copy_number (p)\n+     TaskingStructList *p;\n+{\n+  short i;\n+\n+  for (i = 0; i < MAX_COPIES; i++)\n+    {\n+      if (!p->copies[i])\n+\t{\n+\t  p->copies[i] = 1;\n+\t  return (i);\n+\t}\n+    }\n+  fprintf (stderr, \"No more copies available for \\\"%s\\\".\\n\",\n+\t   p->data[0]->name);\n+  exit (1);\n+}\n+\n+/* function registers a tasking entry from a module and assign\n+   a value to the type */\n+\n+void\n+__register_tasking (t)\n+     TaskingStruct *t;\n+{\n+  TaskingStructList *p;\n+\n+  /* check first if a value was provided and if it is in range */\n+  if (t->value_defined && *t->value >= MAX_NUMBER)\n+    {\n+      fprintf (stderr, \"Value %d out of range.\\n\", *t->value);\n+      exit (1);\n+    }\n+\n+  /* look for item defined */\n+  p = task_array[t->type];\n+  while (p)\n+    {\n+      if (!strcmp (p->data[0]->name, t->name))\n+\t/* have found it */\n+\tbreak;\n+      p = p->forward;\n+    }\n+\n+  if (!p)\n+    {\n+      TaskingStructList *wrk = (TaskingStructList *)&task_array[t->type];\n+\n+      /* this is a new one -- allocate space */\n+      p = xmalloc (sizeof (TaskingStructList));\n+      memset (p->copies, 0, sizeof (p->copies));\n+      p->forward = 0;\n+      p->num = 1;\n+      p->data[0] = t;\n+\n+      /* queue it in */\n+      while (wrk->forward)\n+\twrk = wrk->forward;\n+      wrk->forward = p;\n+    }\n+  else\n+    {\n+      if (p->num >= MAX_PER_ITEM)\n+\t{\n+\t  fprintf (stderr, \"Too many registrations of \\\"%s\\\".\\n\", t->name);\n+\t  exit (1);\n+\t}\n+      p->data[p->num++] = t;\n+    }\n+}\n+\f\n+/* define all the entries for the runtime system. They will be\n+   needed by chillrt0.o */\n+\n+typedef char *(*fetch_names) ();\n+typedef int (*fetch_numbers) ();\n+\n+static char tmp_for_fetch_name[100];\n+\n+char *\n+__fetch_name (number)\n+     int number;\n+{\n+  TaskingStructList *p = task_array[Process];\n+\n+  while (p)\n+    {\n+      if (*(p->data[0]->value) == number)\n+\treturn (p->data[0]->name);\n+      p = p->forward;\n+    }\n+  sprintf (tmp_for_fetch_name, \"%d\", number);\n+  return (tmp_for_fetch_name);\n+}\n+fetch_names\t__RTS_FETCH_NAMES__ = __fetch_name;\n+\n+static int \n+__fetch_number (name)\n+     char *name;\n+{\n+  TaskingStructList *p = task_array[Process];\n+\n+  while (p)\n+    {\n+      if (!strcmp (p->data[0]->name, name))\n+\treturn (*(p->data[0]->value));\n+      p = p->forward;\n+    }\n+  return (-1);\n+}\n+fetch_numbers\t__RTS_FETCH_NUMBERS__ = __fetch_number;\n+\n+\n+/* here we go to check all registered items */\n+static void\n+ __rts_init ()\n+{\n+  int i;\n+  TaskingStructList *p;\n+\n+  for (i = Process; i <= Event; i++)\n+    {\n+      p = task_array[i];\n+      while (p)\n+\t{\n+\t  TaskingStruct *t = 0;\n+\t  int j;\n+\t  short val;\n+\n+\t  for (j = 0; j < p->num; j++)\n+\t    {\n+\t      if (p->data[j]->value_defined)\n+\t\t{\n+\t\t  if (t)\n+\t\t    {\n+\t\t      if (*(t->value) != *(p->data[j]->value))\n+\t\t\t{\n+\t\t\t  fprintf (stderr, \"Different values (%d & %d) for \\\"%s\\\".\",\n+\t\t\t\t   *(t->value), *(p->data[j]->value), t->name);\n+\t\t\t  exit (1);\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    t = p->data[j];\n+\t\t}\n+\t    }\n+\n+\t  if (t)\n+\t    {\n+\n+\t      val = *(t->value);\n+\n+\t      if (used_values[t->type][val])\n+\t\t{\n+\t\t  fprintf (stderr, \"Value %d for \\\"%s\\\" is already used.\\n\",\n+\t\t\t   val, t->name);\n+\t\t  exit (1);\n+\t        }\n+\t      used_values[t->type][val] = 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* we have to create a new value */\n+\t      val = get_next_free_number (used_values[p->data[0]->type]);\n+\t    }\n+\t      \n+\t  for (j = 0; j < p->num; j++)\n+\t    {\n+\t      p->data[j]->value_defined = 1;\n+\t      *(p->data[j]->value) = val;\n+\t    }\n+\n+\t  p = p->forward;\n+\t}\n+    }\n+}\n+EntryPoint\t__RTS_INIT__ = __rts_init;\n+\f\n+/* define the start process queue */\n+typedef struct STARTENTRY\n+{\n+  struct STARTENTRY *forward;\n+  INSTANCE whoami;\n+  EntryPoint entry;\n+  void *data;\n+  int datalen;\n+} StartEntry;\n+\n+static StartEntry *start_queue = 0;\n+static StartEntry *current_process = 0;\n+\n+/* the jump buffer for the main loop */\n+static jmp_buf jump_buffer;\n+static int jump_buffer_initialized = 0;\n+\n+/* look for entries in start_queue and start the process */\n+static void\n+__rts_main_loop ()\n+{\n+  StartEntry *s;\n+\n+  while (1)\n+    {\n+      if (setjmp (jump_buffer) == 0)\n+\t{\n+\t  jump_buffer_initialized = 1;\n+\t  s = start_queue;\n+\t  while (s)\n+\t    {\n+\t      current_process = s;\n+\t      start_queue = s->forward;\n+\t      \n+\t      /* call the process */\n+\t      (*s->entry) (s->data);\n+\t      s = start_queue;\n+\t    }\n+\t  /* when queue empty we have finished */\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  /* stop executed */\n+\t  if (current_process->data)\n+\t    free (current_process->data);\n+\t  free (current_process);\n+\t  current_process = 0;\n+\t}\n+    }\n+}\n+EntryPoint\t__RTS_MAIN_LOOP__ = __rts_main_loop;\n+\n+\n+void\n+__start_process (ptype, pcopy, arg_size, args, ins)\n+     short ptype;\n+     short pcopy;\n+     int arg_size;\n+     void *args;\n+     INSTANCE *ins;\n+{\n+  TaskingStructList *p = task_array[Process];\n+  EntryPoint pc = 0;\n+  int i;\n+  short this_copy = pcopy;\n+  StartEntry *s, *wrk;\n+\n+  /* search for the process */\n+  while (p)\n+    {\n+      if (*(p->data[0]->value) == ptype)\n+\tbreak;\n+      p = p->forward;\n+    }\n+  if (!p)\n+    {\n+      fprintf (stderr, \"Cannot find a process with type %d.\\n\", ptype);\n+      exit (1);\n+    }\n+  \n+  /* search for the entry point */\n+  for (i = 0; i < p->num; i++)\n+    {\n+      if (p->data[i]->entry)\n+\t{\n+\t  pc = p->data[i]->entry;\n+\t  break;\n+\t}\n+    }\n+  if (!pc)\n+    {\n+      fprintf (stderr, \"Process \\\"%s\\\" doesn't have an entry point.\\n\",\n+\t       p->data[0]->name);\n+      exit (1);\n+    }\n+\n+  /* check the copy */\n+  if (pcopy >= MAX_COPIES)\n+    {\n+      fprintf (stderr, \"Copy number (%d) out of range.\\n\", pcopy);\n+      exit (1);\n+    }\n+  if (pcopy == -1)\n+    {\n+      /* search for a copy number */\n+      this_copy = get_next_copy_number (p);\n+    }\n+  else\n+    {\n+      if (p->copies[pcopy])\n+\t{\n+\t  /* FIXME: should be exception 'startfail' */\n+\t  fprintf (stderr, \"Copy number %d already in use for \\\"%s\\\".\\n\",\n+\t\t   pcopy, p->data[0]->name);\n+\t  exit (1);\n+\t}\n+      p->copies[this_copy = pcopy] = 1;\n+    }\n+\n+  /* ready to build start_queue entry */\n+  s = xmalloc (sizeof (StartEntry));\n+  s->forward = 0;\n+  s->whoami.pcopy = this_copy;\n+  s->whoami.ptype = ptype;\n+  s->entry = pc;\n+  s->datalen = arg_size;\n+  if (args)\n+    {\n+      s->data = xmalloc (arg_size);\n+      memcpy (s->data, args, arg_size);\n+    }\n+  else\n+    s->data = 0;\n+\n+  /* queue that stuff in */\n+  wrk = (StartEntry *)&start_queue;\n+  while (wrk->forward)\n+    wrk = wrk->forward;\n+  wrk->forward = s;\n+\n+  /* if we have a pointer to ins -- set it */\n+  if (ins)\n+    {\n+      ins->ptype = ptype;\n+      ins->pcopy = this_copy;\n+    }\n+}\n+\f\n+void\n+__stop_process ()\n+{\n+  if (!jump_buffer_initialized)\n+    {\n+      fprintf (stderr, \"STOP called before START.\\n\");\n+      exit (1);\n+    }\n+  longjmp (jump_buffer, 1);\n+}\n+\n+\n+/* function returns INSTANCE of current process */\n+INSTANCE\n+__whoami ()\n+{\n+  INSTANCE whoami;\n+  if (current_process)\n+    whoami = current_process->whoami;\n+  else\n+    {\n+      whoami.ptype = 0;\n+      whoami.pcopy = 0;\n+    }\n+  return (whoami);\n+}\n+\n+typedef struct\n+{\n+  short *sc;\n+  int    data_len;\n+  void  *data;\n+} SignalDescr;\n+\n+typedef struct SIGNALQUEUE\n+{\n+  struct SIGNALQUEUE *forward;\n+  short    sc;\n+  int      data_len;\n+  void    *data;\n+  INSTANCE to;\n+  INSTANCE from;\n+} SignalQueue;\n+\n+/* define the signal queue */\n+static SignalQueue *msg_queue = 0;\n+\f\n+/* send a signal */\n+void\n+__send_signal (s, to, prio, with_len, with)\n+     SignalDescr *s;\n+     INSTANCE     to;\n+     int          prio;\n+     int          with_len;\n+     void        *with;\n+{\n+  SignalQueue *wrk = (SignalQueue *)&msg_queue;\n+  SignalQueue *p;\n+  TaskingStructList *t = task_array[Process];\n+\n+  /* search for process is defined and running */\n+  while (t)\n+    {\n+      if (*(t->data[0]->value) == to.ptype)\n+\tbreak;\n+      t = t->forward;\n+    }\n+  if (!t || !t->copies[to.pcopy])\n+    {\n+      fprintf (stderr, \"Can't find instance [%d,%d].\\n\",\n+\t       to.ptype, to.pcopy);\n+      exit (1);\n+    }\n+\n+  /* go to the end of the msg_queue */\n+  while (wrk->forward)\n+    wrk = wrk->forward;\n+\n+  p = xmalloc (sizeof (SignalQueue));\n+  p->sc = *(s->sc);\n+  if (p->data_len = s->data_len)\n+    {\n+      p->data = xmalloc (s->data_len);\n+      memcpy (p->data, s->data, s->data_len);\n+    }\n+  else\n+    p->data = 0;\n+  p->to = to;\n+  p->from = __whoami ();\n+  p->forward = 0;\n+  wrk->forward = p;\n+}\n+\f\n+void\n+start_signal_timeout (i, s, j)\n+     int i;\n+     SignalDescr *s;\n+     int j;\n+{\n+  __send_signal (s, __whoami (), 0, 0, 0);\n+}\n+\n+\n+/* receive a signal */\n+int\n+__wait_signal_timed (sig_got, nsigs, sigptr, datap,\n+\t\t     datalen, ins, else_branche,\n+\t\t     to, filename, lineno)\n+     short    *sig_got;\n+     int       nsigs;\n+     short    *sigptr[];\n+     void     *datap;\n+     int       datalen;\n+     INSTANCE *ins;\n+     int       else_branche;\n+     void     *to; \n+     char     *filename;\n+     int       lineno; \n+{\n+  INSTANCE me = __whoami ();\n+  SignalQueue *wrk, *p = msg_queue;\n+  int i;\n+  short sc;\n+\n+  /* search for a signal to `me' */\n+  wrk = (SignalQueue *)&msg_queue;\n+\n+  while (p)\n+    {\n+      if (p->to.ptype == me.ptype\n+\t  && p->to.pcopy == me.pcopy)\n+\tbreak;\n+      wrk = p;\n+      p = p->forward;\n+    }\n+\n+  if (!p)\n+    {\n+      fprintf (stderr, \"No signal for [%d,%d].\\n\",\n+\t       me.ptype, me.pcopy);\n+      exit (1);\n+    }\n+\n+  /* queue the message out */\n+  wrk->forward = p->forward;\n+\n+  /* now look for signal in list */\n+  for (i = 0; i < nsigs; i++)\n+    if (*(sigptr[i]) == p->sc)\n+      break;\n+\n+  if (i >= nsigs && ! else_branche)\n+    /* signal not in list and no ELSE in code */\n+    __cause_exception (\"signalfail\", __FILE__, __LINE__);\n+\n+  if (i >= nsigs)\n+    {\n+      /* signal not in list */\n+      sc = p->sc;\n+      if (ins)\n+\t*ins = p->from;\n+      if (p->data)\n+\tfree (p->data);\n+      free (p);\n+      *sig_got = sc;\n+      return (0);\n+    }\n+\n+  /* we have found a signal in the list */\n+  if (p->data_len)\n+    {\n+      if (datalen >= p->data_len\n+\t  && datap)\n+\tmemcpy (datap, p->data, p->data_len);\n+      else\n+\t__cause_exception (\"spacefail\", __FILE__, __LINE__);\n+    }\n+\n+  sc = p->sc;\n+  if (ins)\n+    *ins = p->from;\n+  if (p->data)\n+    free (p->data);\n+  free (p);\n+  *sig_got = sc;\n+  return (0);\n+}\n+\f\n+/* wait a certain amount of seconds */\n+int\n+__sleep_till (abstime, reltime, fname, lineno)\n+     time_t abstime;\n+     int    reltime;\n+     char  *fname;\n+     int    lineno;\n+{\n+  sleep (reltime);\n+  return 0;\n+}\n+\f\n+/* set up an alarm */\n+static int timeout_flag = 0;\n+\n+static void alarm_handler ()\n+{\n+  timeout_flag = 1;\n+}\n+\n+int *\n+__define_timeout (howlong, filename, lineno)\n+     unsigned long howlong;  /* comes in millisecs */\n+     char         *filename;\n+     int           lineno;\n+{\n+  unsigned int  prev_alarm_value;\n+\n+  signal (SIGALRM, alarm_handler);\n+  prev_alarm_value = alarm ((unsigned int)(howlong / 1000));\n+  return &timeout_flag;\n+}\n+\f\n+/* wait till timeout expires */\n+void\n+__wait_timeout (toid, filename, lineno)\n+     volatile int    *toid;\n+     char   *filename;\n+     int     lineno;\n+{\n+  while (! *toid) ;\n+  *toid = 0;\n+}"}, {"sha": "ea2044eb0666b428d346cae442508087dc1e81ec", "filename": "gcc/ch/runtime/terminate.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fterminate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fterminate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fterminate.c?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,60 @@\n+/* Implement runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include \"rtltypes.h\"\n+\n+extern void __cause_ex1 (char *exname, char *file, int lineno);\n+\n+/* define needed exceptions */\n+EXCEPTION (empty)\n+\n+/*\n+ * function __terminate\n+ *\n+ * parameter:\n+ *  ptr\t\t\tpointer to memory to free\n+ *  filename            source file which issued the call\n+ *  linenumber          line number of the call within that file\n+ *\n+ * returns:\n+ *  void\n+ *\n+ * exceptions:\n+ *  empty\n+ *\n+ * abstract:\n+ *  free memory previously allocated by __allocate.\n+ *\n+*/\n+\n+void\n+__terminate (ptr, filename, linenumber)\n+     void *ptr;\n+     char *filename;\n+     int linenumber;\n+{\n+  if (! ptr)\n+    __cause_ex1 (\"empty\", filename, linenumber);\n+  free (ptr);\n+}"}, {"sha": "7e88322bd55dc44580187056af17ff86b1716e81", "filename": "gcc/ch/runtime/writerecord.c", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fwriterecord.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fwriterecord.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fwriterecord.c?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,133 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <setjmp.h>\n+#include <errno.h>\n+#include <string.h>\n+#include <unistd.h>\n+#include <sys/types.h>\n+\n+#include \"fileio.h\"\n+\n+static\n+void\n+doWrite( Access_Mode* the_access, void* buf, size_t nbyte )\n+{\n+  size_t nwrit;\n+\n+  nwrit = write( the_access->association->handle, buf, nbyte );\n+\n+  if( nwrit < nbyte )\n+  {\n+    the_access->association->syserrno = errno;\n+    RWEXCEPTION( WRITEFAIL, OS_IO_ERROR );\n+  }\n+}\n+\n+\n+void\n+__writerecord( Access_Mode*  the_access,\n+               signed long   the_index,\n+               char*         the_val_addr,\n+               unsigned long the_val_len,\n+               char*         file,\n+               int           line )\n+\n+{\n+  Association_Mode* the_assoc;\n+  unsigned long  info;\n+  char*          actaddr;\n+  unsigned short actlen;\n+  off_t          filepos;\n+\n+  if( !the_access )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_ACCESS );\n+\n+  if( !(the_assoc = the_access->association) )\n+    CHILLEXCEPTION( file, line, NOTCONNECTED, IS_NOT_CONNECTED );\n+\n+  /* Usage must no be ReadOnly */\n+  if( the_assoc->usage == ReadOnly )\n+    CHILLEXCEPTION( file, line, WRITEFAIL, BAD_USAGE );\n+\n+  /*\n+   *  Positioning\n+   */\n+  if( TEST_FLAG( the_access, IO_INDEXED ) )\n+  {\n+    /* index expression must be within bounds of index mode */\n+    if( the_index < the_access->lowindex\n+        || the_access->highindex < the_index )\n+      CHILLEXCEPTION( file, line, RANGEFAIL, BAD_INDEX );\n+    filepos = the_access->base + \n+              (the_index - the_access->lowindex) * the_access->reclength;\n+\n+    if( lseek( the_assoc->handle, filepos, SEEK_SET ) == -1L )\n+      CHILLEXCEPTION( file, line, WRITEFAIL, LSEEK_FAILS );\n+  }\n+\n+  if( (info = setjmp( __rw_exception )) )\n+    CHILLEXCEPTION( file, line, info>>16, info & 0xffff );\n+\n+  if( TEST_FLAG( the_access, IO_TEXTIO ) )\n+  {\n+    if( TEST_FLAG( the_access, IO_INDEXED ) )\n+    {\n+      int nspace = the_access->reclength - the_val_len;\n+      memset( the_val_addr + 2 + the_val_len, ' ', nspace );\n+      actlen = the_access->reclength - 2;\n+      MOV2(the_val_addr,&actlen);\n+      doWrite( the_access, the_val_addr, the_access->reclength );\n+    }\n+    else\n+    { \n+      if( the_assoc->ctl_pre )\n+\twrite( the_assoc->handle, &the_assoc->ctl_pre, 1 );\n+      MOV2(&actlen,the_val_addr);\n+      write( the_assoc->handle, the_val_addr + 2, actlen );\n+      if( the_assoc->ctl_post )\n+\twrite( the_assoc->handle, &the_assoc->ctl_post, 1 );\n+      the_assoc->ctl_pre  = '\\0';\n+      the_assoc->ctl_post = '\\n';\n+    }\n+  }\n+  else\n+  {\n+    switch( the_access->rectype )\n+    {\n+    case Fixed:\n+      if( TEST_FLAG( the_assoc, IO_VARIABLE ) )\n+      {\n+        actlen = the_access->reclength;\n+        doWrite( the_access, &actlen, sizeof(actlen) );\n+      }\n+      doWrite( the_access, the_val_addr, the_val_len );\n+      break;\n+    case VaryingChars:\n+      MOV2(&actlen,the_val_addr);\n+      if( actlen > the_access->reclength - 2 )\n+        CHILLEXCEPTION( file, line, RANGEFAIL, RECORD_TOO_LONG );\n+      actlen = TEST_FLAG( the_access, IO_INDEXED ) \n+               ? the_access->reclength : actlen + 2;\n+      doWrite( the_access, the_val_addr, actlen );\n+      break;\n+    }\n+  }\n+}"}, {"sha": "ddf0012ab6229749cbe67c0ec21f5b758b7f3784", "filename": "gcc/ch/runtime/xorps.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fxorps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fruntime%2Fxorps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fxorps.c?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,76 @@\n+/* Implement POWERSET runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"powerset.h\"\n+\n+/*\n+ * function __xorpowerset\n+ *\n+ * parameters:\n+ *\tout\t\treturn from __xorpowerset\n+ *\tleft\t\tleft powerset\n+ *\tright\t\tright powerset\n+ *\tbitlength\tlength of powerset in bits\n+ *\n+ * returns:\n+ *\tvoid\n+ *\n+ * exceptions:\n+ *  none\n+ *\n+ * abstract:\n+ *  xor's 2 powersets\n+ *\n+ */\n+\n+void\n+__xorpowerset (out, left, right, bitlength)\n+     SET_WORD      *out;\n+     SET_WORD      *left;\n+     SET_WORD      *right;\n+     unsigned long  bitlength;\n+{\n+  if (bitlength <= SET_CHAR_SIZE)\n+    {\n+      *((SET_CHAR *)out) = *((SET_CHAR *)left) ^\n+                           *((SET_CHAR *)right);\n+      MASK_UNUSED_CHAR_BITS((SET_CHAR *)out, bitlength);\n+    }\n+  else if (bitlength <= SET_SHORT_SIZE)\n+    {\n+      *((SET_SHORT *)out) = *((SET_SHORT *)left) ^\n+                            *((SET_SHORT *)right);\n+      MASK_UNUSED_SHORT_BITS((SET_SHORT *)out, bitlength);\n+    }\n+  else\n+    {\n+      unsigned long len = BITS_TO_WORDS(bitlength);\n+      register unsigned long i;\n+\n+      for (i = 0; i < len; i++)\n+\tout[i] = left[i] ^ right[i];\n+      MASK_UNUSED_WORD_BITS ((out + len - 1), \n+\t\t\t     bitlength % SET_WORD_SIZE);\n+    }\n+}"}, {"sha": "2946b2310299afbe267d9ab752a2e936df1ec0b7", "filename": "gcc/ch/xtypeck.c", "status": "added", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fxtypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ca17fa85bce1ba96853420c712d92f369237fb/gcc%2Fch%2Fxtypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fxtypeck.c?ref=a2ca17fa85bce1ba96853420c712d92f369237fb", "patch": "@@ -0,0 +1,264 @@\n+\n+#if 0\n+tree\n+build_component_ref (datum, field_name)\n+  tree datum, field_name;\n+{\n+  return build_chill_component_ref (datum, field_name);\n+}\n+\n+/* Mark EXP saying that we need to be able to take the\n+   address of it; it should not be allocated in a register.\n+   Value is 1 if successful.  */\n+\n+int\n+mark_addressable (exp)\n+     tree exp;\n+{\n+  register tree x = exp;\n+  while (1)\n+    switch (TREE_CODE (x))\n+      {\n+      case ADDR_EXPR:\n+      case COMPONENT_REF:\n+      case ARRAY_REF:\n+      case REALPART_EXPR:\n+      case IMAGPART_EXPR:\n+/* start-sanitize-chill */\n+      case TRUTH_ANDIF_EXPR:\n+      case TRUTH_ORIF_EXPR:\n+      case COMPOUND_EXPR:\n+/* end-sanitize-chill */\n+\tx = TREE_OPERAND (x, 0);\n+\tbreak;\n+/* start-sanitize-chill */\n+\n+      case COND_EXPR:\n+\treturn mark_addressable (TREE_OPERAND (x, 1))\n+\t  & mark_addressable (TREE_OPERAND (x, 2));\n+/* end-sanitize-chill */\n+\n+      case CONSTRUCTOR:\n+\tTREE_ADDRESSABLE (x) = 1;\n+\treturn 1;\n+\n+      case VAR_DECL:\n+      case CONST_DECL:\n+      case PARM_DECL:\n+      case RESULT_DECL:\n+\tif (DECL_REGISTER (x) && !TREE_ADDRESSABLE (x)\n+\t    && DECL_NONLOCAL (x))\n+\t  {\n+\t    if (TREE_PUBLIC (x))\n+\t      {\n+\t\terror (\"global register variable `%s' used in nested function\",\n+\t\t       IDENTIFIER_POINTER (DECL_NAME (x)));\n+\t\treturn 0;\n+\t      }\n+\t    pedwarn (\"register variable `%s' used in nested function\",\n+\t\t     IDENTIFIER_POINTER (DECL_NAME (x)));\n+\t  }\n+\telse if (DECL_REGISTER (x) && !TREE_ADDRESSABLE (x))\n+\t  {\n+\t    if (TREE_PUBLIC (x))\n+\t      {\n+\t\terror (\"address of global register variable `%s' requested\",\n+\t\t       IDENTIFIER_POINTER (DECL_NAME (x)));\n+\t\treturn 0;\n+\t      }\n+\n+\t    /* If we are making this addressable due to its having\n+\t       volatile components, give a different error message.  Also\n+\t       handle the case of an unnamed parameter by not trying\n+\t       to give the name.  */\n+\n+\t    else if (C_TYPE_FIELDS_VOLATILE (TREE_TYPE (x)))\n+\t      {\n+\t\terror (\"cannot put object with volatile field into register\");\n+\t\treturn 0;\n+\t      }\n+\n+\t    pedwarn (\"address of register variable `%s' requested\",\n+\t\t     IDENTIFIER_POINTER (DECL_NAME (x)));\n+\t  }\n+\tput_var_into_stack (x);\n+\n+\t/* drops in */\n+      case FUNCTION_DECL:\n+\tTREE_ADDRESSABLE (x) = 1;\n+#if 0  /* poplevel deals with this now.  */\n+\tif (DECL_CONTEXT (x) == 0)\n+\t  TREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (x)) = 1;\n+#endif\n+\n+      default:\n+\treturn 1;\n+    }\n+}\n+\n+/* Return an unsigned type the same as TYPE in other respects.  */\n+\n+tree\n+unsigned_type (type)\n+     tree type;\n+{\n+  tree type1 = TYPE_MAIN_VARIANT (type);\n+  if (type1 == signed_char_type_node || type1 == char_type_node)\n+    return unsigned_char_type_node;\n+  if (type1 == integer_type_node)\n+    return unsigned_type_node;\n+  if (type1 == short_integer_type_node)\n+    return short_unsigned_type_node;\n+  if (type1 == long_integer_type_node)\n+    return long_unsigned_type_node;\n+  if (type1 == long_long_integer_type_node)\n+    return long_long_unsigned_type_node;\n+  return type;\n+}\n+\n+/* Return a signed type the same as TYPE in other respects.  */\n+\n+tree\n+signed_type (type)\n+     tree type;\n+{\n+  tree type1 = TYPE_MAIN_VARIANT (type);\n+  if (type1 == unsigned_char_type_node || type1 == char_type_node)\n+    return signed_char_type_node;\n+  if (type1 == unsigned_type_node)\n+    return integer_type_node;\n+  if (type1 == short_unsigned_type_node)\n+    return short_integer_type_node;\n+  if (type1 == long_unsigned_type_node)\n+    return long_integer_type_node;\n+  if (type1 == long_long_unsigned_type_node)\n+    return long_long_integer_type_node;\n+  return type;\n+}\n+\n+/* Return a type the same as TYPE except unsigned or\n+   signed according to UNSIGNEDP.  */\n+\n+tree\n+signed_or_unsigned_type (unsignedp, type)\n+     int unsignedp;\n+     tree type;\n+{\n+  if (! INTEGRAL_TYPE_P (type))\n+    return type;\n+  if (TYPE_PRECISION (type) == TYPE_PRECISION (signed_char_type_node))\n+    return unsignedp ? unsigned_char_type_node : signed_char_type_node;\n+  if (TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node)) \n+    return unsignedp ? unsigned_type_node : integer_type_node;\n+  if (TYPE_PRECISION (type) == TYPE_PRECISION (short_integer_type_node)) \n+    return unsignedp ? short_unsigned_type_node : short_integer_type_node;\n+  if (TYPE_PRECISION (type) == TYPE_PRECISION (long_integer_type_node)) \n+    return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n+  if (TYPE_PRECISION (type) == TYPE_PRECISION (long_long_integer_type_node)) \n+    return (unsignedp ? long_long_unsigned_type_node\n+\t    : long_long_integer_type_node);\n+  return type;\n+}\n+\n+extern tree intHI_type_node;\n+extern tree intSI_type_node;\n+extern tree intDI_type_node;\n+\n+extern tree unsigned_intHI_type_node;\n+extern tree unsigned_intSI_type_node;\n+extern tree unsigned_intDI_type_node;\n+\n+/* Return an integer type with BITS bits of precision,\n+   that is unsigned if UNSIGNEDP is nonzero, otherwise signed.  */\n+\n+tree\n+type_for_size (bits, unsignedp)\n+     unsigned bits;\n+     int unsignedp;\n+{\n+  if (bits == TYPE_PRECISION (signed_char_type_node))\n+    return unsignedp ? unsigned_char_type_node : signed_char_type_node;\n+\n+  if (bits == TYPE_PRECISION (short_integer_type_node))\n+    return unsignedp ? short_unsigned_type_node : short_integer_type_node;\n+\n+  if (bits == TYPE_PRECISION (integer_type_node))\n+    return unsignedp ? unsigned_type_node : integer_type_node;\n+\n+  if (bits == TYPE_PRECISION (long_integer_type_node))\n+    return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n+\n+  if (bits == TYPE_PRECISION (long_long_integer_type_node))\n+    return (unsignedp ? long_long_unsigned_type_node\n+\t    : long_long_integer_type_node);\n+\n+  if (bits <= TYPE_PRECISION (intHI_type_node))\n+    return unsignedp ? unsigned_intHI_type_node : intHI_type_node;\n+\n+  if (bits <= TYPE_PRECISION (intSI_type_node))\n+    return unsignedp ? unsigned_intSI_type_node : intSI_type_node;\n+\n+  if (bits <= TYPE_PRECISION (intDI_type_node))\n+    return unsignedp ? unsigned_intDI_type_node : intDI_type_node;\n+\n+  return 0;\n+}\n+\n+/* Return a data type that has machine mode MODE.\n+   If the mode is an integer,\n+   then UNSIGNEDP selects between signed and unsigned types.  */\n+\n+tree\n+type_for_mode (mode, unsignedp)\n+     enum machine_mode mode;\n+     int unsignedp;\n+{\n+  if (mode == TYPE_MODE (signed_char_type_node))\n+    return unsignedp ? unsigned_char_type_node : signed_char_type_node;\n+\n+  if (mode == TYPE_MODE (short_integer_type_node))\n+    return unsignedp ? short_unsigned_type_node : short_integer_type_node;\n+\n+  if (mode == TYPE_MODE (integer_type_node))\n+    return unsignedp ? unsigned_type_node : integer_type_node;\n+\n+  if (mode == TYPE_MODE (long_integer_type_node))\n+    return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n+\n+  if (mode == TYPE_MODE (long_long_integer_type_node))\n+    return unsignedp ? long_long_unsigned_type_node : long_long_integer_type_node;\n+\n+  if (mode == TYPE_MODE (intHI_type_node))\n+    return unsignedp ? unsigned_intHI_type_node : intHI_type_node;\n+\n+  if (mode == TYPE_MODE (intSI_type_node))\n+    return unsignedp ? unsigned_intSI_type_node : intSI_type_node;\n+\n+  if (mode == TYPE_MODE (intDI_type_node))\n+    return unsignedp ? unsigned_intDI_type_node : intDI_type_node;\n+\n+  if (mode == TYPE_MODE (float_type_node))\n+    return float_type_node;\n+\n+  if (mode == TYPE_MODE (double_type_node))\n+    return double_type_node;\n+\n+  if (mode == TYPE_MODE (long_double_type_node))\n+    return long_double_type_node;\n+\n+  if (mode == TYPE_MODE (build_pointer_type (char_type_node)))\n+    return build_pointer_type (char_type_node);\n+\n+  if (mode == TYPE_MODE (build_pointer_type (integer_type_node)))\n+    return build_pointer_type (integer_type_node);\n+\n+  return 0;\n+}\n+\n+tree\n+truthvalue_conversion (expr)\n+     tree expr;\n+{\n+  return chill_truthvalue_conversion (expr);\n+}\n+#endif"}]}