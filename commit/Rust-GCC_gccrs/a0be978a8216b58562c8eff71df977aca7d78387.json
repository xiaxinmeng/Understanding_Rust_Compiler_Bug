{"sha": "a0be978a8216b58562c8eff71df977aca7d78387", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBiZTk3OGE4MjE2YjU4NTYyYzhlZmY3MWRmOTc3YWNhN2Q3ODM4Nw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2019-08-28T18:43:37Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2019-08-28T18:43:37Z"}, "message": "[Preprocessor] small cleanups\n\nhttps://gcc.gnu.org/ml/gcc-patches/2019-08/msg01904.html\n\t* directives-only.c (_cpp_preprocess_dir_only): Use false, not\n\tzero for _cpp_handle_directive call.\n\t* directives.c (_cpp_handle_directive): Indented is bool.\n\t* files.c (struct _cpp_file): Make bools 1 bit bitfields.\n\t* internal.h (enum include_type): Reformat and comment.\n\t(struct cpp_buffer): Make flags 1 bit bitfields.\n\t(_cpp_handle_directive): Indented is bool.\n\nFrom-SVN: r274999", "tree": {"sha": "434fe4e0a9b38aaa633dacf3381e0bd4c8049022", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/434fe4e0a9b38aaa633dacf3381e0bd4c8049022"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0be978a8216b58562c8eff71df977aca7d78387", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0be978a8216b58562c8eff71df977aca7d78387", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0be978a8216b58562c8eff71df977aca7d78387", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0be978a8216b58562c8eff71df977aca7d78387/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fc4f90f0c8eca75fb90c736476360584f68d7ef9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc4f90f0c8eca75fb90c736476360584f68d7ef9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc4f90f0c8eca75fb90c736476360584f68d7ef9"}], "stats": {"total": 52, "additions": 36, "deletions": 16}, "files": [{"sha": "61d91acb2d78fc54bf1fd964ee39cbf5da9abec5", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0be978a8216b58562c8eff71df977aca7d78387/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0be978a8216b58562c8eff71df977aca7d78387/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=a0be978a8216b58562c8eff71df977aca7d78387", "patch": "@@ -1,3 +1,13 @@\n+2019-08-28  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* directives-only.c (_cpp_preprocess_dir_only): Use false, not\n+\tzero for _cpp_handle_directive call.\n+\t* directives.c (_cpp_handle_directive): Indented is bool.\n+\t* files.c (struct _cpp_file): Make bools 1 bit bitfields.\n+\t* internal.h (enum include_type): Reformat and comment.\n+\t(struct cpp_buffer): Make flags 1 bit bitfields.\n+\t(_cpp_handle_directive): Indented is bool.\n+\n 2019-07-09  Martin Sebor  <msebor@redhat.com>\n \n \t* include/line-map.h: Change class-key from class to struct and vice"}, {"sha": "fae3b5b4ba499345f5c30727fbba4b9ddffe136c", "filename": "libcpp/directives-only.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0be978a8216b58562c8eff71df977aca7d78387/libcpp%2Fdirectives-only.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0be978a8216b58562c8eff71df977aca7d78387/libcpp%2Fdirectives-only.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives-only.c?ref=a0be978a8216b58562c8eff71df977aca7d78387", "patch": "@@ -101,7 +101,7 @@ _cpp_preprocess_dir_only (cpp_reader *pfile,\n \t    /* Ensure proper column numbering for generated error messages. */\n \t    buffer->line_base -= col - 1;\n \n-\t    _cpp_handle_directive (pfile, 0 /* ignore indented */);\n+\t    _cpp_handle_directive (pfile, false /* ignore indented */);\n \n \t    /* Sanitize the line settings.  Duplicate #include's can mess\n \t       things up. */"}, {"sha": "48271e1700ecf2d9fb89457b8ceb9fdd187ced5f", "filename": "libcpp/directives.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0be978a8216b58562c8eff71df977aca7d78387/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0be978a8216b58562c8eff71df977aca7d78387/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=a0be978a8216b58562c8eff71df977aca7d78387", "patch": "@@ -406,13 +406,13 @@ directive_diagnostics (cpp_reader *pfile, const directive *dir, int indented)\n     }\n }\n \n-/* Check if we have a known directive.  INDENTED is nonzero if the\n+/* Check if we have a known directive.  INDENTED is true if the\n    '#' of the directive was indented.  This function is in this file\n    to save unnecessarily exporting dtable etc. to lex.c.  Returns\n    nonzero if the line of tokens has been handled, zero if we should\n    continue processing the line.  */\n int\n-_cpp_handle_directive (cpp_reader *pfile, int indented)\n+_cpp_handle_directive (cpp_reader *pfile, bool indented)\n {\n   const directive *dir = 0;\n   const cpp_token *dname;"}, {"sha": "30c0cf255194b79cad3660049a751d9361a1f068", "filename": "libcpp/files.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0be978a8216b58562c8eff71df977aca7d78387/libcpp%2Ffiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0be978a8216b58562c8eff71df977aca7d78387/libcpp%2Ffiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ffiles.c?ref=a0be978a8216b58562c8eff71df977aca7d78387", "patch": "@@ -98,19 +98,19 @@ struct _cpp_file\n   unsigned short stack_count;\n \n   /* If opened with #import or contains #pragma once.  */\n-  bool once_only;\n+  bool once_only : 1;\n \n   /* If read() failed before.  */\n-  bool dont_read;\n+  bool dont_read : 1;\n \n   /* If this file is the main file.  */\n-  bool main_file;\n+  bool main_file : 1;\n \n   /* If BUFFER above contains the true contents of the file.  */\n-  bool buffer_valid;\n+  bool buffer_valid : 1;\n \n   /* If this file is implicitly preincluded.  */\n-  bool implicit_preinclude;\n+  bool implicit_preinclude : 1;\n };\n \n /* A singly-linked list for all searches for a given file name, with"}, {"sha": "a86b58785e9d4c490933dee6d192b13203fec038", "filename": "libcpp/internal.h", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0be978a8216b58562c8eff71df977aca7d78387/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0be978a8216b58562c8eff71df977aca7d78387/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=a0be978a8216b58562c8eff71df977aca7d78387", "patch": "@@ -113,7 +113,17 @@ extern unsigned char *_cpp_unaligned_alloc (cpp_reader *, size_t);\n #define BUFF_LIMIT(BUFF) ((BUFF)->limit)\n \n /* #include types.  */\n-enum include_type {IT_INCLUDE, IT_INCLUDE_NEXT, IT_IMPORT, IT_CMDLINE, IT_DEFAULT};\n+enum include_type\n+  {\n+   /* Directive-based including mechanisms.  */\n+   IT_INCLUDE,  /* #include */\n+   IT_INCLUDE_NEXT,  /* #include_next */\n+   IT_IMPORT,   /* #import  */\n+\n+   /* Non-directive including mechanisms.  */\n+   IT_CMDLINE,  /* -include */\n+   IT_DEFAULT,  /* forced header  */\n+  };\n \n union utoken\n {\n@@ -327,23 +337,23 @@ struct cpp_buffer\n   struct if_stack *if_stack;\n \n   /* True if we need to get the next clean line.  */\n-  bool need_line;\n+  bool need_line : 1;\n \n   /* True if we have already warned about C++ comments in this file.\n      The warning happens only for C89 extended mode with -pedantic on,\n      or for -Wtraditional, and only once per file (otherwise it would\n      be far too noisy).  */\n-  unsigned int warned_cplusplus_comments : 1;\n+  bool warned_cplusplus_comments : 1;\n \n   /* True if we don't process trigraphs and escaped newlines.  True\n      for preprocessed input, command line directives, and _Pragma\n      buffers.  */\n-  unsigned int from_stage3 : 1;\n+  bool from_stage3 : 1;\n \n   /* At EOF, a buffer is automatically popped.  If RETURN_AT_EOF is\n      true, a CPP_EOF token is then returned.  Otherwise, the next\n      token from the enclosing buffer is returned.  */\n-  unsigned int return_at_eof : 1;\n+  bool return_at_eof : 1;\n \n   /* One for a system header, two for a C system header file that therefore\n      needs to be extern \"C\" protected in C++, and zero otherwise.  */\n@@ -419,13 +429,13 @@ struct cpp_reader\n \n   /* This is the node representing the macro being expanded at\n      top-level.  The value of this data member is valid iff\n-     in_macro_expansion_p() returns TRUE.  */\n+     cpp_in_macro_expansion_p() returns TRUE.  */\n   cpp_hashnode *top_most_macro_node;\n \n   /* Nonzero if we are about to expand a macro.  Note that if we are\n      really expanding a macro, the function macro_of_context returns\n      the macro being expanded and this flag is set to false.  Client\n-     code should use the function in_macro_expansion_p to know if we\n+     code should use the function cpp_in_macro_expansion_p to know if we\n      are either about to expand a macro, or are actually expanding\n      one.  */\n   bool about_to_expand_macro_p;\n@@ -711,7 +721,7 @@ extern const char *cpp_named_operator2name (enum cpp_ttype type);\n \n /* In directives.c */\n extern int _cpp_test_assertion (cpp_reader *, unsigned int *);\n-extern int _cpp_handle_directive (cpp_reader *, int);\n+extern int _cpp_handle_directive (cpp_reader *, bool);\n extern void _cpp_define_builtin (cpp_reader *, const char *);\n extern char ** _cpp_save_pragma_names (cpp_reader *);\n extern void _cpp_restore_pragma_names (cpp_reader *, char **);"}]}