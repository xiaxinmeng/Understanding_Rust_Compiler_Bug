{"sha": "7ef67393c7454bb93a070d0290b4196c06a93ce8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VmNjczOTNjNzQ1NGJiOTNhMDcwZDAyOTBiNDE5NmMwNmE5M2NlOA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2005-11-09T20:57:30Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2005-11-09T20:57:30Z"}, "message": "re PR other/4372 (#pragma weak pthread* inclusion causes applications to crash without a linker error when one forgets to link with -lpthread)\n\ngcc/ChangeLog:\nPR other/4372\n* gthr-dce.h, gthr-posix.h, gthr-posix95.h, gthr-solaris.h,\ngthr-tpf.h: Define __gthrw.  For all identifiers that might\nbe weak, introduce weakrefs or non-weak aliases with __gthrw,\nand prefix all uses with __ghtrw.\nlibobjc/ChangeLog:\nPR other/4372\n* thr-objc.c (_XOPEN_SOURCE): Define.\n\nFrom-SVN: r106704", "tree": {"sha": "cd8a160cfd714773ba11358612d806445395a4c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd8a160cfd714773ba11358612d806445395a4c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ef67393c7454bb93a070d0290b4196c06a93ce8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ef67393c7454bb93a070d0290b4196c06a93ce8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ef67393c7454bb93a070d0290b4196c06a93ce8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ef67393c7454bb93a070d0290b4196c06a93ce8/comments", "author": null, "committer": null, "parents": [{"sha": "a0203ca711308b96d33acb895d4f7d254594287c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0203ca711308b96d33acb895d4f7d254594287c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0203ca711308b96d33acb895d4f7d254594287c"}], "stats": {"total": 628, "additions": 349, "deletions": 279}, "files": [{"sha": "e97e5a38f88bedc1985affbaf8daf94575cee5f7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ef67393c7454bb93a070d0290b4196c06a93ce8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ef67393c7454bb93a070d0290b4196c06a93ce8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ef67393c7454bb93a070d0290b4196c06a93ce8", "patch": "@@ -1,3 +1,11 @@\n+2005-11-09  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR other/4372\n+\t* gthr-dce.h, gthr-posix.h, gthr-posix95.h, gthr-solaris.h,\n+\tgthr-tpf.h: Define __gthrw.  For all identifiers that might\n+\tbe weak, introduce weakrefs or non-weak aliases with __gthrw,\n+\tand prefix all uses with __ghtrw.\n+\n 2005-11-09  Alexandre Oliva  <aoliva@redhat.com>\n \n \tPR other/4372"}, {"sha": "517f5a3044369354e196462a0b231870d51f3b89", "filename": "gcc/gthr-dce.h", "status": "modified", "additions": 67, "deletions": 55, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ef67393c7454bb93a070d0290b4196c06a93ce8/gcc%2Fgthr-dce.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ef67393c7454bb93a070d0290b4196c06a93ce8/gcc%2Fgthr-dce.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-dce.h?ref=7ef67393c7454bb93a070d0290b4196c06a93ce8", "patch": "@@ -1,6 +1,7 @@\n /* Threads compatibility routines for libgcc2 and libobjc.  */\n /* Compile this one with gcc.  */\n-/* Copyright (C) 1997, 1999, 2000, 2001, 2004 Free Software Foundation, Inc.\n+/* Copyright (C) 1997, 1999, 2000, 2001, 2004, 2005\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -54,48 +55,59 @@ typedef pthread_once_t __gthread_once_t;\n typedef pthread_mutex_t __gthread_mutex_t;\n typedef pthread_mutex_t __gthread_recursive_mutex_t;\n \n-#define __GTHREAD_ONCE_INIT pthread_once_init\n+#define __GTHREAD_ONCE_INIT __gthrw_pthread_once_init\n \n #define __GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function\n #define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function\n \n-#define __GTHREAD_MUTEX_INIT_DEFAULT pthread_once_init\n+#define __GTHREAD_MUTEX_INIT_DEFAULT __gthrw_pthread_once_init\n \n #if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n+# define __gthrw(name) \\\n+  extern __typeof(name) __gthrw_ ## name __attribute__ ((__weakref__(#name)))\n+#else\n+# define __gthrw_asmname(cname) __gthrw_asmnamep (__USER_LABEL_PREFIX__, cname)\n+# define __gthrw_asmnamep(prefix, cname) __gthrw_string (prefix) cname\n+# define __gthrw_string(x) #x\n+# define __gthrw(name) \\\n+  extern __typeof(name) __gthrw_ ## name __asm (__gthrw_asmname (#name))\n+#endif\n \n-#pragma weak pthread_once\n-#pragma weak pthread_once_init\n-#pragma weak pthread_keycreate\n-#pragma weak pthread_key_delete\n-#pragma weak pthread_getspecific\n-#pragma weak pthread_setspecific\n-#pragma weak pthread_create\n-#pragma weak pthread_mutex_init\n-#pragma weak pthread_mutex_lock\n-#pragma weak pthread_mutex_trylock\n-#pragma weak pthread_mutex_unlock\n-#pragma weak pthread_mutexattr_create\n-#pragma weak pthread_mutexattr_setkind_np\n-#pragma weak pthread_mutexattr_delete\n+__gthrw(pthread_once);\n+__gthrw(pthread_once_init);\n+__gthrw(pthread_keycreate);\n+__gthrw(pthread_key_delete);\n+__gthrw(pthread_getspecific);\n+__gthrw(pthread_setspecific);\n+__gthrw(pthread_create);\n+__gthrw(pthread_mutex_init);\n+__gthrw(pthread_mutex_lock);\n+__gthrw(pthread_mutex_trylock);\n+__gthrw(pthread_mutex_unlock);\n+__gthrw(pthread_mutexattr_create);\n+__gthrw(pthread_mutexattr_setkind_np);\n+__gthrw(pthread_mutexattr_delete);\n \n #ifdef _LIBOBJC\n /* Objective-C.  */\n-#pragma weak pthread_cond_broadcast\n-#pragma weak pthread_cond_destroy\n-#pragma weak pthread_cond_init\n-#pragma weak pthread_cond_signal\n-#pragma weak pthread_cond_wait\n-#pragma weak pthread_exit\n-#pragma weak pthread_getunique_np\n-#pragma weak pthread_mutex_destroy\n-#pragma weak pthread_self\n-#pragma weak pthread_yield\n+__gthrw(pthread_cond_broadcast);\n+__gthrw(pthread_cond_destroy);\n+__gthrw(pthread_cond_init);\n+__gthrw(pthread_cond_signal);\n+__gthrw(pthread_cond_wait);\n+__gthrw(pthread_exit);\n+__gthrw(pthread_getunique_np);\n+__gthrw(pthread_mutex_destroy);\n+__gthrw(pthread_self);\n+__gthrw(pthread_yield);\n #endif\n \n+#if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n+\n static inline int\n __gthread_active_p (void)\n {\n-  static void *const __gthread_active_ptr = (void *) &pthread_create;\n+  static void *const __gthread_active_ptr = (void *) &__gthrw_pthread_create;\n   return __gthread_active_ptr != 0;\n }\n \n@@ -125,7 +137,7 @@ __gthread_objc_init_thread_system (void)\n {\n   if (__gthread_active_p ())\n     /* Initialize the thread storage key.  */\n-    return pthread_keycreate (&_objc_thread_storage, NULL);\n+    return __gthrw_pthread_keycreate (&_objc_thread_storage, NULL);\n   else\n     return -1;\n }\n@@ -152,7 +164,7 @@ __gthread_objc_thread_detach (void (*func)(void *), void *arg)\n   if (!__gthread_active_p ())\n     return NULL;\n \n-  if (!(pthread_create (&new_thread_handle, pthread_attr_default,\n+  if (!(__gthrw_pthread_create (&new_thread_handle, pthread_attr_default,\n \t\t\t(void *) func, arg)))\n     {\n       /* ??? May not work! (64bit) */\n@@ -189,7 +201,7 @@ __gthread_objc_thread_set_priority (int priority)\n     }\n \n   /* Change the priority.  */\n-  if (pthread_setprio (pthread_self (), sys_priority) >= 0)\n+  if (pthread_setprio (__gthrw_pthread_self (), sys_priority) >= 0)\n     return 0;\n   else\n     /* Failed */\n@@ -204,7 +216,7 @@ __gthread_objc_thread_get_priority (void)\n \n   if (__gthread_active_p ())\n     {\n-      if ((sys_priority = pthread_getprio (pthread_self ())) >= 0)\n+      if ((sys_priority = pthread_getprio (__gthrw_pthread_self ())) >= 0)\n \t{\n \t  if (sys_priority >= PRI_FG_MIN_NP\n \t      && sys_priority <= PRI_FG_MAX_NP)\n@@ -227,7 +239,7 @@ static inline void\n __gthread_objc_thread_yield (void)\n {\n   if (__gthread_active_p ())\n-    pthread_yield ();\n+    __gthrw_pthread_yield ();\n }\n \n /* Terminate the current thread.  */\n@@ -236,7 +248,7 @@ __gthread_objc_thread_exit (void)\n {\n   if (__gthread_active_p ())\n     /* exit the thread */\n-    pthread_exit (&__objc_thread_exit_status);\n+    __gthrw_pthread_exit (&__objc_thread_exit_status);\n \n   /* Failed if we reached here */\n   return -1;\n@@ -248,9 +260,9 @@ __gthread_objc_thread_id (void)\n {\n   if (__gthread_active_p ())\n     {\n-      pthread_t self = pthread_self ();\n+      pthread_t self = __gthrw_pthread_self ();\n \n-      return (objc_thread_t) pthread_getunique_np (&self);\n+      return (objc_thread_t) __gthrw_pthread_getunique_np (&self);\n     }\n   else\n     return (objc_thread_t) 1;\n@@ -261,7 +273,7 @@ static inline int\n __gthread_objc_thread_set_data (void *value)\n {\n   if (__gthread_active_p ())\n-    return pthread_setspecific (_objc_thread_storage, value);\n+    return __gthrw_pthread_setspecific (_objc_thread_storage, value);\n   else\n     {\n       thread_local_storage = value;\n@@ -277,7 +289,7 @@ __gthread_objc_thread_get_data (void)\n \n   if (__gthread_active_p ())\n     {\n-      if (!(pthread_getspecific (_objc_thread_storage, &value)))\n+      if (!(__gthrw_pthread_getspecific (_objc_thread_storage, &value)))\n \treturn value;\n \n       return NULL;\n@@ -296,7 +308,7 @@ __gthread_objc_mutex_allocate (objc_mutex_t mutex)\n     {\n       mutex->backend = objc_malloc (sizeof (pthread_mutex_t));\n \n-      if (pthread_mutex_init ((pthread_mutex_t *) mutex->backend,\n+      if (__gthrw_pthread_mutex_init ((pthread_mutex_t *) mutex->backend,\n \t\t\t      pthread_mutexattr_default))\n \t{\n \t  objc_free (mutex->backend);\n@@ -314,7 +326,7 @@ __gthread_objc_mutex_deallocate (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      if (pthread_mutex_destroy ((pthread_mutex_t *) mutex->backend))\n+      if (__gthrw_pthread_mutex_destroy ((pthread_mutex_t *) mutex->backend))\n \treturn -1;\n \n       objc_free (mutex->backend);\n@@ -329,7 +341,7 @@ static inline int\n __gthread_objc_mutex_lock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ())\n-    return pthread_mutex_lock ((pthread_mutex_t *) mutex->backend);\n+    return __gthrw_pthread_mutex_lock ((pthread_mutex_t *) mutex->backend);\n   else\n     return 0;\n }\n@@ -339,7 +351,7 @@ static inline int\n __gthread_objc_mutex_trylock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && pthread_mutex_trylock ((pthread_mutex_t *) mutex->backend) != 1)\n+      && __gthrw_pthread_mutex_trylock ((pthread_mutex_t *) mutex->backend) != 1)\n     return -1;\n \n   return 0;\n@@ -350,7 +362,7 @@ static inline int\n __gthread_objc_mutex_unlock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ())\n-    return pthread_mutex_unlock ((pthread_mutex_t *) mutex->backend);\n+    return __gthrw_pthread_mutex_unlock ((pthread_mutex_t *) mutex->backend);\n   else\n     return 0;\n }\n@@ -418,15 +430,15 @@ static inline int\n __gthread_once (__gthread_once_t *once, void (*func) (void))\n {\n   if (__gthread_active_p ())\n-    return pthread_once (once, func);\n+    return __gthrw_pthread_once (once, func);\n   else\n     return -1;\n }\n \n static inline int\n __gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n {\n-  return pthread_keycreate (key, dtor);\n+  return __gthrw_pthread_keycreate (key, dtor);\n }\n \n static inline int\n@@ -440,7 +452,7 @@ static inline void *\n __gthread_getspecific (__gthread_key_t key)\n {\n   void *ptr;\n-  if (pthread_getspecific (key, &ptr) == 0)\n+  if (__gthrw_pthread_getspecific (key, &ptr) == 0)\n     return ptr;\n   else\n     return 0;\n@@ -449,21 +461,21 @@ __gthread_getspecific (__gthread_key_t key)\n static inline int\n __gthread_setspecific (__gthread_key_t key, const void *ptr)\n {\n-  return pthread_setspecific (key, (void *) ptr);\n+  return __gthrw_pthread_setspecific (key, (void *) ptr);\n }\n \n static inline void\n __gthread_mutex_init_function (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    pthread_mutex_init (mutex, pthread_mutexattr_default);\n+    __gthrw_pthread_mutex_init (mutex, pthread_mutexattr_default);\n }\n \n static inline int\n __gthread_mutex_lock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return pthread_mutex_lock (mutex);\n+    return __gthrw_pthread_mutex_lock (mutex);\n   else\n     return 0;\n }\n@@ -472,7 +484,7 @@ static inline int\n __gthread_mutex_trylock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return pthread_mutex_trylock (mutex);\n+    return __gthrw_pthread_mutex_trylock (mutex);\n   else\n     return 0;\n }\n@@ -481,7 +493,7 @@ static inline int\n __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return pthread_mutex_unlock (mutex);\n+    return __gthrw_pthread_mutex_unlock (mutex);\n   else\n     return 0;\n }\n@@ -494,13 +506,13 @@ __gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n       pthread_mutexattr_t attr;\n       int r;\n \n-      r = pthread_mutexattr_create (&attr);\n+      r = __gthrw_pthread_mutexattr_create (&attr);\n       if (!r)\n-\tr = pthread_mutexattr_setkind_np (&attr, MUTEX_RECURSIVE_NP);\n+\tr = __gthrw_pthread_mutexattr_setkind_np (&attr, MUTEX_RECURSIVE_NP);\n       if (!r)\n-\tr = pthread_mutex_init (mutex, attr);\n+\tr = __gthrw_pthread_mutex_init (mutex, attr);\n       if (!r)\n-\tr = pthread_mutexattr_delete (&attr);\n+\tr = __gthrw_pthread_mutexattr_delete (&attr);\n       return r;\n     }\n }"}, {"sha": "d022c9f1b79395a6034b188102373289fa79a4ea", "filename": "gcc/gthr-posix.h", "status": "modified", "additions": 83, "deletions": 72, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ef67393c7454bb93a070d0290b4196c06a93ce8/gcc%2Fgthr-posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ef67393c7454bb93a070d0290b4196c06a93ce8/gcc%2Fgthr-posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-posix.h?ref=7ef67393c7454bb93a070d0290b4196c06a93ce8", "patch": "@@ -59,55 +59,66 @@ typedef pthread_mutex_t __gthread_recursive_mutex_t;\n #endif\n \n #if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n+# define __gthrw(name) \\\n+  extern __typeof(name) __gthrw_ ## name __attribute__ ((__weakref__(#name)))\n+#else\n+# define __gthrw_asmname(cname) __gthrw_asmnamep (__USER_LABEL_PREFIX__, cname)\n+# define __gthrw_asmnamep(prefix, cname) __gthrw_string (prefix) cname\n+# define __gthrw_string(x) #x\n+# define __gthrw(name) \\\n+  extern __typeof(name) __gthrw_ ## name __asm (__gthrw_asmname (#name))\n+#endif\n \n-#pragma weak pthread_once\n-#pragma weak pthread_key_create\n-#pragma weak pthread_key_delete\n-#pragma weak pthread_getspecific\n-#pragma weak pthread_setspecific\n-#pragma weak pthread_create\n-#pragma weak pthread_cancel\n+__gthrw(pthread_once);\n+__gthrw(pthread_key_create);\n+__gthrw(pthread_key_delete);\n+__gthrw(pthread_getspecific);\n+__gthrw(pthread_setspecific);\n+__gthrw(pthread_create);\n+__gthrw(pthread_cancel);\n \n-#pragma weak pthread_mutex_lock\n-#pragma weak pthread_mutex_trylock\n-#pragma weak pthread_mutex_unlock\n-#pragma weak pthread_mutexattr_init\n-#pragma weak pthread_mutexattr_settype\n-#pragma weak pthread_mutexattr_destroy\n+__gthrw(pthread_mutex_lock);\n+__gthrw(pthread_mutex_trylock);\n+__gthrw(pthread_mutex_unlock);\n+__gthrw(pthread_mutexattr_init);\n+__gthrw(pthread_mutexattr_settype);\n+__gthrw(pthread_mutexattr_destroy);\n \n-#pragma weak pthread_mutex_init\n+__gthrw(pthread_mutex_init);\n \n #if defined(_LIBOBJC) || defined(_LIBOBJC_WEAK)\n /* Objective-C.  */\n-#pragma weak pthread_cond_broadcast\n-#pragma weak pthread_cond_destroy\n-#pragma weak pthread_cond_init\n-#pragma weak pthread_cond_signal\n-#pragma weak pthread_cond_wait\n-#pragma weak pthread_exit\n-#pragma weak pthread_mutex_destroy\n-#pragma weak pthread_self\n+__gthrw(pthread_cond_broadcast);\n+__gthrw(pthread_cond_destroy);\n+__gthrw(pthread_cond_init);\n+__gthrw(pthread_cond_signal);\n+__gthrw(pthread_cond_wait);\n+__gthrw(pthread_exit);\n+__gthrw(pthread_mutex_destroy);\n+__gthrw(pthread_self);\n #ifdef _POSIX_PRIORITY_SCHEDULING\n #ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n-#pragma weak sched_get_priority_max\n-#pragma weak sched_get_priority_min\n+__gthrw(sched_get_priority_max);\n+__gthrw(sched_get_priority_min);\n #endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n #endif /* _POSIX_PRIORITY_SCHEDULING */\n-#pragma weak sched_yield\n-#pragma weak pthread_attr_destroy\n-#pragma weak pthread_attr_init\n-#pragma weak pthread_attr_setdetachstate\n+__gthrw(sched_yield);\n+__gthrw(pthread_attr_destroy);\n+__gthrw(pthread_attr_init);\n+__gthrw(pthread_attr_setdetachstate);\n #ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n-#pragma weak pthread_getschedparam\n-#pragma weak pthread_setschedparam\n+__gthrw(pthread_getschedparam);\n+__gthrw(pthread_setschedparam);\n #endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n #endif /* _LIBOBJC || _LIBOBJC_WEAK */\n \n+#if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n+\n static inline int\n __gthread_active_p (void)\n {\n   static void *const __gthread_active_ptr \n-    = __extension__ (void *) &pthread_cancel;\n+    = __extension__ (void *) &__gthrw_pthread_cancel;\n   return __gthread_active_ptr != 0;\n }\n \n@@ -146,13 +157,13 @@ __gthread_objc_init_thread_system (void)\n   if (__gthread_active_p ())\n     {\n       /* Initialize the thread storage key.  */\n-      if (pthread_key_create (&_objc_thread_storage, NULL) == 0)\n+      if (__gthrw_pthread_key_create (&_objc_thread_storage, NULL) == 0)\n \t{\n \t  /* The normal default detach state for threads is\n \t   * PTHREAD_CREATE_JOINABLE which causes threads to not die\n \t   * when you think they should.  */\n-\t  if (pthread_attr_init (&_objc_thread_attribs) == 0\n-\t      && pthread_attr_setdetachstate (&_objc_thread_attribs,\n+\t  if (__gthrw_pthread_attr_init (&_objc_thread_attribs) == 0\n+\t      && __gthrw_pthread_attr_setdetachstate (&_objc_thread_attribs,\n \t\t\t\t\t      PTHREAD_CREATE_DETACHED) == 0)\n \t    return 0;\n \t}\n@@ -166,8 +177,8 @@ static inline int\n __gthread_objc_close_thread_system (void)\n {\n   if (__gthread_active_p ()\n-      && pthread_key_delete (_objc_thread_storage) == 0\n-      && pthread_attr_destroy (&_objc_thread_attribs) == 0)\n+      && __gthrw_pthread_key_delete (_objc_thread_storage) == 0\n+      && __gthrw_pthread_attr_destroy (&_objc_thread_attribs) == 0)\n     return 0;\n \n   return -1;\n@@ -185,7 +196,7 @@ __gthread_objc_thread_detach (void (*func)(void *), void *arg)\n   if (!__gthread_active_p ())\n     return NULL;\n \n-  if (!(pthread_create (&new_thread_handle, NULL, (void *) func, arg)))\n+  if (!(__gthrw_pthread_create (&new_thread_handle, NULL, (void *) func, arg)))\n     thread_id = (objc_thread_t) new_thread_handle;\n   else\n     thread_id = NULL;\n@@ -203,17 +214,17 @@ __gthread_objc_thread_set_priority (int priority)\n     {\n #ifdef _POSIX_PRIORITY_SCHEDULING\n #ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n-      pthread_t thread_id = pthread_self ();\n+      pthread_t thread_id = __gthrw_pthread_self ();\n       int policy;\n       struct sched_param params;\n       int priority_min, priority_max;\n \n-      if (pthread_getschedparam (thread_id, &policy, &params) == 0)\n+      if (__gthrw_pthread_getschedparam (thread_id, &policy, &params) == 0)\n \t{\n-\t  if ((priority_max = sched_get_priority_max (policy)) == -1)\n+\t  if ((priority_max = __gthrw_sched_get_priority_max (policy)) == -1)\n \t    return -1;\n \n-\t  if ((priority_min = sched_get_priority_min (policy)) == -1)\n+\t  if ((priority_min = __gthrw_sched_get_priority_min (policy)) == -1)\n \t    return -1;\n \n \t  if (priority > priority_max)\n@@ -227,7 +238,7 @@ __gthread_objc_thread_set_priority (int priority)\n \t   * this should be a pointer to policy but pthread.h is universally\n \t   * at odds with this.\n \t   */\n-\t  if (pthread_setschedparam (thread_id, policy, &params) == 0)\n+\t  if (__gthrw_pthread_setschedparam (thread_id, policy, &params) == 0)\n \t    return 0;\n \t}\n #endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n@@ -247,7 +258,7 @@ __gthread_objc_thread_get_priority (void)\n       int policy;\n       struct sched_param params;\n \n-      if (pthread_getschedparam (pthread_self (), &policy, &params) == 0)\n+      if (__gthrw_pthread_getschedparam (__gthrw_pthread_self (), &policy, &params) == 0)\n \treturn params.sched_priority;\n       else\n \treturn -1;\n@@ -263,7 +274,7 @@ static inline void\n __gthread_objc_thread_yield (void)\n {\n   if (__gthread_active_p ())\n-    sched_yield ();\n+    __gthrw_sched_yield ();\n }\n \n /* Terminate the current thread.  */\n@@ -272,7 +283,7 @@ __gthread_objc_thread_exit (void)\n {\n   if (__gthread_active_p ())\n     /* exit the thread */\n-    pthread_exit (&__objc_thread_exit_status);\n+    __gthrw_pthread_exit (&__objc_thread_exit_status);\n \n   /* Failed if we reached here */\n   return -1;\n@@ -283,7 +294,7 @@ static inline objc_thread_t\n __gthread_objc_thread_id (void)\n {\n   if (__gthread_active_p ())\n-    return (objc_thread_t) pthread_self ();\n+    return (objc_thread_t) __gthrw_pthread_self ();\n   else\n     return (objc_thread_t) 1;\n }\n@@ -293,7 +304,7 @@ static inline int\n __gthread_objc_thread_set_data (void *value)\n {\n   if (__gthread_active_p ())\n-    return pthread_setspecific (_objc_thread_storage, value);\n+    return __gthrw_pthread_setspecific (_objc_thread_storage, value);\n   else\n     {\n       thread_local_storage = value;\n@@ -306,7 +317,7 @@ static inline void *\n __gthread_objc_thread_get_data (void)\n {\n   if (__gthread_active_p ())\n-    return pthread_getspecific (_objc_thread_storage);\n+    return __gthrw_pthread_getspecific (_objc_thread_storage);\n   else\n     return thread_local_storage;\n }\n@@ -321,7 +332,7 @@ __gthread_objc_mutex_allocate (objc_mutex_t mutex)\n     {\n       mutex->backend = objc_malloc (sizeof (pthread_mutex_t));\n \n-      if (pthread_mutex_init ((pthread_mutex_t *) mutex->backend, NULL))\n+      if (__gthrw_pthread_mutex_init ((pthread_mutex_t *) mutex->backend, NULL))\n \t{\n \t  objc_free (mutex->backend);\n \t  mutex->backend = NULL;\n@@ -342,18 +353,18 @@ __gthread_objc_mutex_deallocate (objc_mutex_t mutex)\n \n       /*\n        * Posix Threads specifically require that the thread be unlocked\n-       * for pthread_mutex_destroy to work.\n+       * for __gthrw_pthread_mutex_destroy to work.\n        */\n \n       do\n \t{\n-\t  count = pthread_mutex_unlock ((pthread_mutex_t *) mutex->backend);\n+\t  count = __gthrw_pthread_mutex_unlock ((pthread_mutex_t *) mutex->backend);\n \t  if (count < 0)\n \t    return -1;\n \t}\n       while (count);\n \n-      if (pthread_mutex_destroy ((pthread_mutex_t *) mutex->backend))\n+      if (__gthrw_pthread_mutex_destroy ((pthread_mutex_t *) mutex->backend))\n \treturn -1;\n \n       objc_free (mutex->backend);\n@@ -367,7 +378,7 @@ static inline int\n __gthread_objc_mutex_lock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && pthread_mutex_lock ((pthread_mutex_t *) mutex->backend) != 0)\n+      && __gthrw_pthread_mutex_lock ((pthread_mutex_t *) mutex->backend) != 0)\n     {\n       return -1;\n     }\n@@ -380,7 +391,7 @@ static inline int\n __gthread_objc_mutex_trylock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && pthread_mutex_trylock ((pthread_mutex_t *) mutex->backend) != 0)\n+      && __gthrw_pthread_mutex_trylock ((pthread_mutex_t *) mutex->backend) != 0)\n     {\n       return -1;\n     }\n@@ -393,7 +404,7 @@ static inline int\n __gthread_objc_mutex_unlock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && pthread_mutex_unlock ((pthread_mutex_t *) mutex->backend) != 0)\n+      && __gthrw_pthread_mutex_unlock ((pthread_mutex_t *) mutex->backend) != 0)\n     {\n       return -1;\n     }\n@@ -411,7 +422,7 @@ __gthread_objc_condition_allocate (objc_condition_t condition)\n     {\n       condition->backend = objc_malloc (sizeof (pthread_cond_t));\n \n-      if (pthread_cond_init ((pthread_cond_t *) condition->backend, NULL))\n+      if (__gthrw_pthread_cond_init ((pthread_cond_t *) condition->backend, NULL))\n \t{\n \t  objc_free (condition->backend);\n \t  condition->backend = NULL;\n@@ -428,7 +439,7 @@ __gthread_objc_condition_deallocate (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n     {\n-      if (pthread_cond_destroy ((pthread_cond_t *) condition->backend))\n+      if (__gthrw_pthread_cond_destroy ((pthread_cond_t *) condition->backend))\n \treturn -1;\n \n       objc_free (condition->backend);\n@@ -442,7 +453,7 @@ static inline int\n __gthread_objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)\n {\n   if (__gthread_active_p ())\n-    return pthread_cond_wait ((pthread_cond_t *) condition->backend,\n+    return __gthrw_pthread_cond_wait ((pthread_cond_t *) condition->backend,\n \t\t\t      (pthread_mutex_t *) mutex->backend);\n   else\n     return 0;\n@@ -453,7 +464,7 @@ static inline int\n __gthread_objc_condition_broadcast (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n-    return pthread_cond_broadcast ((pthread_cond_t *) condition->backend);\n+    return __gthrw_pthread_cond_broadcast ((pthread_cond_t *) condition->backend);\n   else\n     return 0;\n }\n@@ -463,7 +474,7 @@ static inline int\n __gthread_objc_condition_signal (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n-    return pthread_cond_signal ((pthread_cond_t *) condition->backend);\n+    return __gthrw_pthread_cond_signal ((pthread_cond_t *) condition->backend);\n   else\n     return 0;\n }\n@@ -474,40 +485,40 @@ static inline int\n __gthread_once (__gthread_once_t *once, void (*func) (void))\n {\n   if (__gthread_active_p ())\n-    return pthread_once (once, func);\n+    return __gthrw_pthread_once (once, func);\n   else\n     return -1;\n }\n \n static inline int\n __gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n {\n-  return pthread_key_create (key, dtor);\n+  return __gthrw_pthread_key_create (key, dtor);\n }\n \n static inline int\n __gthread_key_delete (__gthread_key_t key)\n {\n-  return pthread_key_delete (key);\n+  return __gthrw_pthread_key_delete (key);\n }\n \n static inline void *\n __gthread_getspecific (__gthread_key_t key)\n {\n-  return pthread_getspecific (key);\n+  return __gthrw_pthread_getspecific (key);\n }\n \n static inline int\n __gthread_setspecific (__gthread_key_t key, const void *ptr)\n {\n-  return pthread_setspecific (key, ptr);\n+  return __gthrw_pthread_setspecific (key, ptr);\n }\n \n static inline int\n __gthread_mutex_lock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return pthread_mutex_lock (mutex);\n+    return __gthrw_pthread_mutex_lock (mutex);\n   else\n     return 0;\n }\n@@ -516,7 +527,7 @@ static inline int\n __gthread_mutex_trylock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return pthread_mutex_trylock (mutex);\n+    return __gthrw_pthread_mutex_trylock (mutex);\n   else\n     return 0;\n }\n@@ -525,7 +536,7 @@ static inline int\n __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return pthread_mutex_unlock (mutex);\n+    return __gthrw_pthread_mutex_unlock (mutex);\n   else\n     return 0;\n }\n@@ -539,13 +550,13 @@ __gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n       pthread_mutexattr_t attr;\n       int r;\n \n-      r = pthread_mutexattr_init (&attr);\n+      r = __gthrw_pthread_mutexattr_init (&attr);\n       if (!r)\n-\tr = pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE);\n+\tr = __gthrw_pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE);\n       if (!r)\n-\tr = pthread_mutex_init (mutex, &attr);\n+\tr = __gthrw_pthread_mutex_init (mutex, &attr);\n       if (!r)\n-\tr = pthread_mutexattr_destroy (&attr);\n+\tr = __gthrw_pthread_mutexattr_destroy (&attr);\n       return r;\n     }\n   return 0;"}, {"sha": "87da7047d87d119ecada1138f7fd9dc58d04dae3", "filename": "gcc/gthr-posix95.h", "status": "modified", "additions": 86, "deletions": 75, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ef67393c7454bb93a070d0290b4196c06a93ce8/gcc%2Fgthr-posix95.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ef67393c7454bb93a070d0290b4196c06a93ce8/gcc%2Fgthr-posix95.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-posix95.h?ref=7ef67393c7454bb93a070d0290b4196c06a93ce8", "patch": "@@ -57,56 +57,67 @@ typedef struct {\n #define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function\n \n #if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n+# define __gthrw(name) \\\n+  extern __typeof(name) __gthrw_ ## name __attribute__ ((__weakref__(#name)))\n+#else\n+# define __gthrw_asmname(cname) __gthrw_asmnamep (__USER_LABEL_PREFIX__, cname)\n+# define __gthrw_asmnamep(prefix, cname) __gthrw_string (prefix) cname\n+# define __gthrw_string(x) #x\n+# define __gthrw(name) \\\n+  extern __typeof(name) __gthrw_ ## name __asm (__gthrw_asmname (#name))\n+#endif\n \n-#pragma weak pthread_once\n-#pragma weak pthread_key_create\n-#pragma weak pthread_key_delete\n-#pragma weak pthread_getspecific\n-#pragma weak pthread_setspecific\n-#pragma weak pthread_create\n-#pragma weak pthread_cancel\n-#pragma weak pthread_self\n+__gthrw(pthread_once);\n+__gthrw(pthread_key_create);\n+__gthrw(pthread_key_delete);\n+__gthrw(pthread_getspecific);\n+__gthrw(pthread_setspecific);\n+__gthrw(pthread_create);\n+__gthrw(pthread_cancel);\n+__gthrw(pthread_self);\n \n-#pragma weak pthread_mutex_lock\n-#pragma weak pthread_mutex_trylock\n-#pragma weak pthread_mutex_unlock\n-#pragma weak pthread_mutexattr_init\n-#pragma weak pthread_mutexattr_settype\n-#pragma weak pthread_mutexattr_destroy\n+__gthrw(pthread_mutex_lock);\n+__gthrw(pthread_mutex_trylock);\n+__gthrw(pthread_mutex_unlock);\n+__gthrw(pthread_mutexattr_init);\n+__gthrw(pthread_mutexattr_settype);\n+__gthrw(pthread_mutexattr_destroy);\n \n-#pragma weak pthread_mutex_init\n+__gthrw(pthread_mutex_init);\n \n #if defined(_LIBOBJC) || defined(_LIBOBJC_WEAK)\n /* Objective-C.  */\n-#pragma weak pthread_cond_broadcast\n-#pragma weak pthread_cond_destroy\n-#pragma weak pthread_cond_init\n-#pragma weak pthread_cond_signal\n-#pragma weak pthread_cond_wait\n-#pragma weak pthread_exit\n-#pragma weak pthread_mutex_destroy\n-#pragma weak pthread_self\n+__gthrw(pthread_cond_broadcast);\n+__gthrw(pthread_cond_destroy);\n+__gthrw(pthread_cond_init);\n+__gthrw(pthread_cond_signal);\n+__gthrw(pthread_cond_wait);\n+__gthrw(pthread_exit);\n+__gthrw(pthread_mutex_destroy);\n+__gthrw(pthread_self);\n #ifdef _POSIX_PRIORITY_SCHEDULING\n #ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n-#pragma weak sched_get_priority_max\n-#pragma weak sched_get_priority_min\n+__gthrw(sched_get_priority_max);\n+__gthrw(sched_get_priority_min);\n #endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n #endif /* _POSIX_PRIORITY_SCHEDULING */\n-#pragma weak sched_yield\n-#pragma weak pthread_attr_destroy\n-#pragma weak pthread_attr_init\n-#pragma weak pthread_attr_setdetachstate\n+__gthrw(sched_yield);\n+__gthrw(pthread_attr_destroy);\n+__gthrw(pthread_attr_init);\n+__gthrw(pthread_attr_setdetachstate);\n #ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n-#pragma weak pthread_getschedparam\n-#pragma weak pthread_setschedparam\n+__gthrw(pthread_getschedparam);\n+__gthrw(pthread_setschedparam);\n #endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n #endif /* _LIBOBJC || _LIBOBJC_WEAK */\n \n+#if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n+\n static inline int\n __gthread_active_p (void)\n {\n   static void *const __gthread_active_ptr \n-    = __extension__ (void *) &pthread_cancel;\n+    = __extension__ (void *) &__gthrw_pthread_cancel;\n   return __gthread_active_ptr != 0;\n }\n \n@@ -145,13 +156,13 @@ __gthread_objc_init_thread_system (void)\n   if (__gthread_active_p ())\n     {\n       /* Initialize the thread storage key.  */\n-      if (pthread_key_create (&_objc_thread_storage, NULL) == 0)\n+      if (__gthrw_pthread_key_create (&_objc_thread_storage, NULL) == 0)\n \t{\n \t  /* The normal default detach state for threads is\n \t   * PTHREAD_CREATE_JOINABLE which causes threads to not die\n \t   * when you think they should.  */\n-\t  if (pthread_attr_init (&_objc_thread_attribs) == 0\n-\t      && pthread_attr_setdetachstate (&_objc_thread_attribs,\n+\t  if (__gthrw_pthread_attr_init (&_objc_thread_attribs) == 0\n+\t      && __gthrw_pthread_attr_setdetachstate (&_objc_thread_attribs,\n \t\t\t\t\t      PTHREAD_CREATE_DETACHED) == 0)\n \t    return 0;\n \t}\n@@ -165,8 +176,8 @@ static inline int\n __gthread_objc_close_thread_system (void)\n {\n   if (__gthread_active_p ()\n-      && pthread_key_delete (_objc_thread_storage) == 0\n-      && pthread_attr_destroy (&_objc_thread_attribs) == 0)\n+      && __gthrw_pthread_key_delete (_objc_thread_storage) == 0\n+      && __gthrw_pthread_attr_destroy (&_objc_thread_attribs) == 0)\n     return 0;\n \n   return -1;\n@@ -184,7 +195,7 @@ __gthread_objc_thread_detach (void (*func)(void *), void *arg)\n   if (!__gthread_active_p ())\n     return NULL;\n \n-  if (!(pthread_create (&new_thread_handle, NULL, (void *) func, arg)))\n+  if (!(__gthrw_pthread_create (&new_thread_handle, NULL, (void *) func, arg)))\n     thread_id = (objc_thread_t) new_thread_handle;\n   else\n     thread_id = NULL;\n@@ -202,17 +213,17 @@ __gthread_objc_thread_set_priority (int priority)\n     {\n #ifdef _POSIX_PRIORITY_SCHEDULING\n #ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n-      pthread_t thread_id = pthread_self ();\n+      pthread_t thread_id = __gthrw_pthread_self ();\n       int policy;\n       struct sched_param params;\n       int priority_min, priority_max;\n \n-      if (pthread_getschedparam (thread_id, &policy, &params) == 0)\n+      if (__gthrw_pthread_getschedparam (thread_id, &policy, &params) == 0)\n \t{\n-\t  if ((priority_max = sched_get_priority_max (policy)) == -1)\n+\t  if ((priority_max = __gthrw_sched_get_priority_max (policy)) == -1)\n \t    return -1;\n \n-\t  if ((priority_min = sched_get_priority_min (policy)) == -1)\n+\t  if ((priority_min = __gthrw_sched_get_priority_min (policy)) == -1)\n \t    return -1;\n \n \t  if (priority > priority_max)\n@@ -226,7 +237,7 @@ __gthread_objc_thread_set_priority (int priority)\n \t   * this should be a pointer to policy but pthread.h is universally\n \t   * at odds with this.\n \t   */\n-\t  if (pthread_setschedparam (thread_id, policy, &params) == 0)\n+\t  if (__gthrw_pthread_setschedparam (thread_id, policy, &params) == 0)\n \t    return 0;\n \t}\n #endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n@@ -246,7 +257,7 @@ __gthread_objc_thread_get_priority (void)\n       int policy;\n       struct sched_param params;\n \n-      if (pthread_getschedparam (pthread_self (), &policy, &params) == 0)\n+      if (__gthrw_pthread_getschedparam (__gthrw_pthread_self (), &policy, &params) == 0)\n \treturn params.sched_priority;\n       else\n \treturn -1;\n@@ -262,7 +273,7 @@ static inline void\n __gthread_objc_thread_yield (void)\n {\n   if (__gthread_active_p ())\n-    sched_yield ();\n+    __gthrw_sched_yield ();\n }\n \n /* Terminate the current thread.  */\n@@ -271,7 +282,7 @@ __gthread_objc_thread_exit (void)\n {\n   if (__gthread_active_p ())\n     /* exit the thread */\n-    pthread_exit (&__objc_thread_exit_status);\n+    __gthrw_pthread_exit (&__objc_thread_exit_status);\n \n   /* Failed if we reached here */\n   return -1;\n@@ -282,7 +293,7 @@ static inline objc_thread_t\n __gthread_objc_thread_id (void)\n {\n   if (__gthread_active_p ())\n-    return (objc_thread_t) pthread_self ();\n+    return (objc_thread_t) __gthrw_pthread_self ();\n   else\n     return (objc_thread_t) 1;\n }\n@@ -292,7 +303,7 @@ static inline int\n __gthread_objc_thread_set_data (void *value)\n {\n   if (__gthread_active_p ())\n-    return pthread_setspecific (_objc_thread_storage, value);\n+    return __gthrw_pthread_setspecific (_objc_thread_storage, value);\n   else\n     {\n       thread_local_storage = value;\n@@ -305,7 +316,7 @@ static inline void *\n __gthread_objc_thread_get_data (void)\n {\n   if (__gthread_active_p ())\n-    return pthread_getspecific (_objc_thread_storage);\n+    return __gthrw_pthread_getspecific (_objc_thread_storage);\n   else\n     return thread_local_storage;\n }\n@@ -320,7 +331,7 @@ __gthread_objc_mutex_allocate (objc_mutex_t mutex)\n     {\n       mutex->backend = objc_malloc (sizeof (pthread_mutex_t));\n \n-      if (pthread_mutex_init ((pthread_mutex_t *) mutex->backend, NULL))\n+      if (__gthrw_pthread_mutex_init ((pthread_mutex_t *) mutex->backend, NULL))\n \t{\n \t  objc_free (mutex->backend);\n \t  mutex->backend = NULL;\n@@ -341,18 +352,18 @@ __gthread_objc_mutex_deallocate (objc_mutex_t mutex)\n \n       /*\n        * Posix Threads specifically require that the thread be unlocked\n-       * for pthread_mutex_destroy to work.\n+       * for __gthrw_pthread_mutex_destroy to work.\n        */\n \n       do\n \t{\n-\t  count = pthread_mutex_unlock ((pthread_mutex_t *) mutex->backend);\n+\t  count = __gthrw_pthread_mutex_unlock ((pthread_mutex_t *) mutex->backend);\n \t  if (count < 0)\n \t    return -1;\n \t}\n       while (count);\n \n-      if (pthread_mutex_destroy ((pthread_mutex_t *) mutex->backend))\n+      if (__gthrw_pthread_mutex_destroy ((pthread_mutex_t *) mutex->backend))\n \treturn -1;\n \n       objc_free (mutex->backend);\n@@ -366,7 +377,7 @@ static inline int\n __gthread_objc_mutex_lock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && pthread_mutex_lock ((pthread_mutex_t *) mutex->backend) != 0)\n+      && __gthrw_pthread_mutex_lock ((pthread_mutex_t *) mutex->backend) != 0)\n     {\n       return -1;\n     }\n@@ -379,7 +390,7 @@ static inline int\n __gthread_objc_mutex_trylock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && pthread_mutex_trylock ((pthread_mutex_t *) mutex->backend) != 0)\n+      && __gthrw_pthread_mutex_trylock ((pthread_mutex_t *) mutex->backend) != 0)\n     {\n       return -1;\n     }\n@@ -392,7 +403,7 @@ static inline int\n __gthread_objc_mutex_unlock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && pthread_mutex_unlock ((pthread_mutex_t *) mutex->backend) != 0)\n+      && __gthrw_pthread_mutex_unlock ((pthread_mutex_t *) mutex->backend) != 0)\n     {\n       return -1;\n     }\n@@ -410,7 +421,7 @@ __gthread_objc_condition_allocate (objc_condition_t condition)\n     {\n       condition->backend = objc_malloc (sizeof (pthread_cond_t));\n \n-      if (pthread_cond_init ((pthread_cond_t *) condition->backend, NULL))\n+      if (__gthrw_pthread_cond_init ((pthread_cond_t *) condition->backend, NULL))\n \t{\n \t  objc_free (condition->backend);\n \t  condition->backend = NULL;\n@@ -427,7 +438,7 @@ __gthread_objc_condition_deallocate (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n     {\n-      if (pthread_cond_destroy ((pthread_cond_t *) condition->backend))\n+      if (__gthrw_pthread_cond_destroy ((pthread_cond_t *) condition->backend))\n \treturn -1;\n \n       objc_free (condition->backend);\n@@ -441,7 +452,7 @@ static inline int\n __gthread_objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)\n {\n   if (__gthread_active_p ())\n-    return pthread_cond_wait ((pthread_cond_t *) condition->backend,\n+    return __gthrw_pthread_cond_wait ((pthread_cond_t *) condition->backend,\n \t\t\t      (pthread_mutex_t *) mutex->backend);\n   else\n     return 0;\n@@ -452,7 +463,7 @@ static inline int\n __gthread_objc_condition_broadcast (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n-    return pthread_cond_broadcast ((pthread_cond_t *) condition->backend);\n+    return __gthrw_pthread_cond_broadcast ((pthread_cond_t *) condition->backend);\n   else\n     return 0;\n }\n@@ -462,7 +473,7 @@ static inline int\n __gthread_objc_condition_signal (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n-    return pthread_cond_signal ((pthread_cond_t *) condition->backend);\n+    return __gthrw_pthread_cond_signal ((pthread_cond_t *) condition->backend);\n   else\n     return 0;\n }\n@@ -473,40 +484,40 @@ static inline int\n __gthread_once (__gthread_once_t *once, void (*func) (void))\n {\n   if (__gthread_active_p ())\n-    return pthread_once (once, func);\n+    return __gthrw_pthread_once (once, func);\n   else\n     return -1;\n }\n \n static inline int\n __gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n {\n-  return pthread_key_create (key, dtor);\n+  return __gthrw_pthread_key_create (key, dtor);\n }\n \n static inline int\n __gthread_key_delete (__gthread_key_t key)\n {\n-  return pthread_key_delete (key);\n+  return __gthrw_pthread_key_delete (key);\n }\n \n static inline void *\n __gthread_getspecific (__gthread_key_t key)\n {\n-  return pthread_getspecific (key);\n+  return __gthrw_pthread_getspecific (key);\n }\n \n static inline int\n __gthread_setspecific (__gthread_key_t key, const void *ptr)\n {\n-  return pthread_setspecific (key, ptr);\n+  return __gthrw_pthread_setspecific (key, ptr);\n }\n \n static inline int\n __gthread_mutex_lock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return pthread_mutex_lock (mutex);\n+    return __gthrw_pthread_mutex_lock (mutex);\n   else\n     return 0;\n }\n@@ -515,7 +526,7 @@ static inline int\n __gthread_mutex_trylock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return pthread_mutex_trylock (mutex);\n+    return __gthrw_pthread_mutex_trylock (mutex);\n   else\n     return 0;\n }\n@@ -524,7 +535,7 @@ static inline int\n __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return pthread_mutex_unlock (mutex);\n+    return __gthrw_pthread_mutex_unlock (mutex);\n   else\n     return 0;\n }\n@@ -534,19 +545,19 @@ __gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n {\n   mutex->depth = 0;\n   mutex->owner = (pthread_t) 0;\n-  return pthread_mutex_init (&mutex->actual, NULL);\n+  return __gthrw_pthread_mutex_init (&mutex->actual, NULL);\n }\n \n static inline int\n __gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      pthread_t me = pthread_self ();\n+      pthread_t me = __gthrw_pthread_self ();\n \n       if (mutex->owner != me)\n \t{\n-\t  pthread_mutex_lock (&mutex->actual);\n+\t  __gthrw_pthread_mutex_lock (&mutex->actual);\n \t  mutex->owner = me;\n \t}\n \n@@ -560,11 +571,11 @@ __gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      pthread_t me = pthread_self ();\n+      pthread_t me = __gthrw_pthread_self ();\n \n       if (mutex->owner != me)\n \t{\n-\t  if (pthread_mutex_trylock (&mutex->actual))\n+\t  if (__gthrw_pthread_mutex_trylock (&mutex->actual))\n \t    return 1;\n \t  mutex->owner = me;\n \t}\n@@ -582,7 +593,7 @@ __gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n       if (--mutex->depth == 0)\n \t{\n \t   mutex->owner = (pthread_t) 0;\n-\t   pthread_mutex_unlock (&mutex->actual);\n+\t   __gthrw_pthread_mutex_unlock (&mutex->actual);\n \t}\n     }\n   return 0;"}, {"sha": "01757dc006dabdbdecbacd891dfd2a6310101be1", "filename": "gcc/gthr-solaris.h", "status": "modified", "additions": 69, "deletions": 57, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ef67393c7454bb93a070d0290b4196c06a93ce8/gcc%2Fgthr-solaris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ef67393c7454bb93a070d0290b4196c06a93ce8/gcc%2Fgthr-solaris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-solaris.h?ref=7ef67393c7454bb93a070d0290b4196c06a93ce8", "patch": "@@ -1,6 +1,7 @@\n /* Threads compatibility routines for libgcc2 and libobjc.  */\n /* Compile this one with gcc.  */\n-/* Copyright (C) 1997, 1999, 2000, 2004 Free Software Foundation, Inc.\n+/* Copyright (C) 1997, 1999, 2000, 2004, 2005\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -56,41 +57,52 @@ typedef struct {\n #define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function\n \n #if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n+# define __gthrw(name) \\\n+  extern __typeof(name) __gthrw_ ## name __attribute__ ((__weakref__(#name)))\n+#else\n+# define __gthrw_asmname(cname) __gthrw_asmnamep (__USER_LABEL_PREFIX__, cname)\n+# define __gthrw_asmnamep(prefix, cname) __gthrw_string (prefix) cname\n+# define __gthrw_string(x) #x\n+# define __gthrw(name) \\\n+  extern __typeof(name) __gthrw_ ## name __asm (__gthrw_asmname (#name))\n+#endif\n \n-#pragma weak thr_keycreate\n-#pragma weak thr_getspecific\n-#pragma weak thr_setspecific\n-#pragma weak thr_create\n+__gthrw(thr_keycreate);\n+__gthrw(thr_getspecific);\n+__gthrw(thr_setspecific);\n+__gthrw(thr_create);\n \n-#pragma weak mutex_lock\n-#pragma weak mutex_trylock\n-#pragma weak mutex_unlock\n+__gthrw(mutex_lock);\n+__gthrw(mutex_trylock);\n+__gthrw(mutex_unlock);\n \n #ifdef _LIBOBJC\n-#pragma weak thr_exit\n-#pragma weak thr_keycreate\n-#pragma weak thr_getprio\n-#pragma weak thr_self\n-#pragma weak thr_setprio\n-#pragma weak thr_yield\n-\n-#pragma weak cond_init\n-#pragma weak cond_destroy\n-#pragma weak cond_wait\n-#pragma weak cond_broadcast\n-#pragma weak cond_signal\n-\n-#pragma weak mutex_init\n-#pragma weak mutex_destroy\n+__gthrw(thr_exit);\n+__gthrw(thr_keycreate);\n+__gthrw(thr_getprio);\n+__gthrw(thr_self);\n+__gthrw(thr_setprio);\n+__gthrw(thr_yield);\n+\n+__gthrw(cond_init);\n+__gthrw(cond_destroy);\n+__gthrw(cond_wait);\n+__gthrw(cond_broadcast);\n+__gthrw(cond_signal);\n+\n+__gthrw(mutex_init);\n+__gthrw(mutex_destroy);\n #endif\n \n+#if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n+\n /* This will not actually work in Solaris 2.5, since libc contains\n    dummy symbols of all thr_* routines.  */\n \n static inline int\n __gthread_active_p (void)\n {\n-  static void *const __gthread_active_ptr = (void *) &thr_create;\n+  static void *const __gthread_active_ptr = (void *) &__gthrw_thr_create;\n   return __gthread_active_ptr != 0;\n }\n \n@@ -120,7 +132,7 @@ __gthread_objc_init_thread_system (void)\n {\n   /* Initialize the thread storage key.  */\n   if (__gthread_active_p ()\n-      && thr_keycreate (&_objc_thread_storage, NULL) == 0)\n+      && __gthrw_thr_keycreate (&_objc_thread_storage, NULL) == 0)\n     return 0;\n \n   return -1;\n@@ -148,7 +160,7 @@ __gthread_objc_thread_detach (void (*func)(void *), void *arg)\n   if (!__gthread_active_p ())\n     return NULL;\n \n-  if (thr_create (NULL, 0, (void *) func, arg,\n+  if (__gthrw_thr_create (NULL, 0, (void *) func, arg,\n \t\t  THR_DETACHED | THR_NEW_LWP,\n \t\t  &new_thread_id) == 0)\n     thread_id = *(objc_thread_t *) &new_thread_id;\n@@ -182,7 +194,7 @@ __gthread_objc_thread_set_priority (int priority)\n     }\n \n   /* Change priority */\n-  if (thr_setprio (thr_self (), sys_priority) == 0)\n+  if (__gthrw_thr_setprio (__gthrw_thr_self (), sys_priority) == 0)\n     return 0;\n   else\n     return -1;\n@@ -197,7 +209,7 @@ __gthread_objc_thread_get_priority (void)\n   if (!__gthread_active_p ())\n     return OBJC_THREAD_INTERACTIVE_PRIORITY;\n \n-  if (thr_getprio (thr_self (), &sys_priority) == 0)\n+  if (__gthrw_thr_getprio (__gthrw_thr_self (), &sys_priority) == 0)\n     {\n       if (sys_priority >= 250)\n \treturn OBJC_THREAD_INTERACTIVE_PRIORITY;\n@@ -215,7 +227,7 @@ static inline void\n __gthread_objc_thread_yield (void)\n {\n   if (__gthread_active_p ())\n-    thr_yield ();\n+    __gthrw_thr_yield ();\n }\n \n /* Terminate the current thread.  */\n@@ -224,7 +236,7 @@ __gthread_objc_thread_exit (void)\n {\n   if (__gthread_active_p ())\n     /* exit the thread */\n-    thr_exit (&__objc_thread_exit_status);\n+    __gthrw_thr_exit (&__objc_thread_exit_status);\n \n   /* Failed if we reached here */\n   return -1;\n@@ -235,7 +247,7 @@ static inline objc_thread_t\n __gthread_objc_thread_id (void)\n {\n   if (__gthread_active_p ())\n-    return (objc_thread_t) thr_self ();\n+    return (objc_thread_t) __gthrw_thr_self ();\n   else\n     return (objc_thread_t) 1;\n }\n@@ -246,7 +258,7 @@ __gthread_objc_thread_set_data (void *value)\n {\n   if (__gthread_active_p ())\n     {\n-      if (thr_setspecific (_objc_thread_storage, value) == 0)\n+      if (__gthrw_thr_setspecific (_objc_thread_storage, value) == 0)\n \treturn 0;\n       else\n \treturn -1;\n@@ -266,7 +278,7 @@ __gthread_objc_thread_get_data (void)\n \n   if (__gthread_active_p ())\n     {\n-      if (thr_getspecific (_objc_thread_storage, &value) == 0)\n+      if (__gthrw_thr_getspecific (_objc_thread_storage, &value) == 0)\n \treturn value;\n       else\n \treturn NULL;\n@@ -282,7 +294,7 @@ static inline int\n __gthread_objc_mutex_allocate (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && mutex_init ((mutex_t *) (&(mutex->backend)), USYNC_THREAD, 0))\n+      && __gthrw_mutex_init ((mutex_t *) (&(mutex->backend)), USYNC_THREAD, 0))\n     return -1;\n \n   return 0;\n@@ -293,7 +305,7 @@ static inline int\n __gthread_objc_mutex_deallocate (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ())\n-    mutex_destroy ((mutex_t *) (&(mutex->backend)));\n+    __gthrw_mutex_destroy ((mutex_t *) (&(mutex->backend)));\n \n   return 0;\n }\n@@ -303,7 +315,7 @@ static inline int\n __gthread_objc_mutex_lock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && mutex_lock ((mutex_t *) (&(mutex->backend))) != 0)\n+      && __gthrw_mutex_lock ((mutex_t *) (&(mutex->backend))) != 0)\n     return -1;\n \n   return 0;\n@@ -314,7 +326,7 @@ static inline int\n __gthread_objc_mutex_trylock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && mutex_trylock ((mutex_t *) (&(mutex->backend))) != 0)\n+      && __gthrw_mutex_trylock ((mutex_t *) (&(mutex->backend))) != 0)\n     return -1;\n \n   return 0;\n@@ -325,7 +337,7 @@ static inline int\n __gthread_objc_mutex_unlock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && mutex_unlock ((mutex_t *) (&(mutex->backend))) != 0)\n+      && __gthrw_mutex_unlock ((mutex_t *) (&(mutex->backend))) != 0)\n     return -1;\n \n   return 0;\n@@ -338,7 +350,7 @@ static inline int\n __gthread_objc_condition_allocate (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n-    return cond_init ((cond_t *) (&(condition->backend)), USYNC_THREAD,\n+    return __gthrw_cond_init ((cond_t *) (&(condition->backend)), USYNC_THREAD,\n \t\t      NULL);\n   else\n     return 0;\n@@ -349,7 +361,7 @@ static inline int\n __gthread_objc_condition_deallocate (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n-    return cond_destroy ((cond_t *) (&(condition->backend)));\n+    return __gthrw_cond_destroy ((cond_t *) (&(condition->backend)));\n   else\n     return 0;\n }\n@@ -359,7 +371,7 @@ static inline int\n __gthread_objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)\n {\n   if (__gthread_active_p ())\n-    return cond_wait ((cond_t *) (&(condition->backend)),\n+    return __gthrw_cond_wait ((cond_t *) (&(condition->backend)),\n \t\t      (mutex_t *) (&(mutex->backend)));\n   else\n     return 0;\n@@ -370,7 +382,7 @@ static inline int\n __gthread_objc_condition_broadcast (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n-    return cond_broadcast ((cond_t *) (&(condition->backend)));\n+    return __gthrw_cond_broadcast ((cond_t *) (&(condition->backend)));\n   else\n     return 0;\n }\n@@ -380,7 +392,7 @@ static inline int\n __gthread_objc_condition_signal (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n-    return cond_signal ((cond_t *) (&(condition->backend)));\n+    return __gthrw_cond_signal ((cond_t *) (&(condition->backend)));\n   else\n     return 0;\n }\n@@ -398,15 +410,15 @@ __gthread_once (__gthread_once_t *once, void (*func) (void))\n \n   if (once->once == 0)\n     {\n-      int status = mutex_lock (&once->mutex);\n+      int status = __gthrw_mutex_lock (&once->mutex);\n       if (status != 0)\n \treturn status;\n       if (once->once == 0)\n \t{\n \t  (*func) ();\n \t  once->once++;\n \t}\n-      mutex_unlock (&once->mutex);\n+      __gthrw_mutex_unlock (&once->mutex);\n     }\n   return 0;\n }\n@@ -417,7 +429,7 @@ __gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n   /* Solaris 2.5 contains thr_* routines no-op in libc, so test if we actually\n      got a reasonable key value, and if not, fail.  */\n   *key = (__gthread_key_t)-1;\n-  if (thr_keycreate (key, dtor) != 0 || *key == (__gthread_key_t)-1)\n+  if (__gthrw_thr_keycreate (key, dtor) != 0 || *key == (__gthread_key_t)-1)\n     return -1;\n   else\n     return 0;\n@@ -434,7 +446,7 @@ static inline void *\n __gthread_getspecific (__gthread_key_t key)\n {\n   void *ptr;\n-  if (thr_getspecific (key, &ptr) == 0)\n+  if (__gthrw_thr_getspecific (key, &ptr) == 0)\n     return ptr;\n   else\n     return 0;\n@@ -443,14 +455,14 @@ __gthread_getspecific (__gthread_key_t key)\n static inline int\n __gthread_setspecific (__gthread_key_t key, const void *ptr)\n {\n-  return thr_setspecific (key, (void *) ptr);\n+  return __gthrw_thr_setspecific (key, (void *) ptr);\n }\n \n static inline int\n __gthread_mutex_lock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return mutex_lock (mutex);\n+    return __gthrw_mutex_lock (mutex);\n   else\n     return 0;\n }\n@@ -459,7 +471,7 @@ static inline int\n __gthread_mutex_trylock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return mutex_trylock (mutex);\n+    return __gthrw_mutex_trylock (mutex);\n   else\n     return 0;\n }\n@@ -468,7 +480,7 @@ static inline int\n __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return mutex_unlock (mutex);\n+    return __gthrw_mutex_unlock (mutex);\n   else\n     return 0;\n }\n@@ -478,19 +490,19 @@ __gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n {\n   mutex->depth = 0;\n   mutex->owner = (thread_t) 0;\n-  return mutex_init (&mutex->actual, USYNC_THREAD, 0);\n+  return __gthrw_mutex_init (&mutex->actual, USYNC_THREAD, 0);\n }\n \n static inline int\n __gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      thread_t me = thr_self ();\n+      thread_t me = __gthrw_thr_self ();\n \n       if (mutex->owner != me)\n \t{\n-\t  mutex_lock (&mutex->actual);\n+\t  __gthrw_mutex_lock (&mutex->actual);\n \t  mutex->owner = me;\n \t}\n \n@@ -504,11 +516,11 @@ __gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      thread_t me = thr_self ();\n+      thread_t me = __gthrw_thr_self ();\n \n       if (mutex->owner != me)\n \t{\n-\t  if (mutex_trylock (&mutex->actual))\n+\t  if (__gthrw_mutex_trylock (&mutex->actual))\n \t    return 1;\n \t  mutex->owner = me;\n \t}\n@@ -526,7 +538,7 @@ __gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n       if (--mutex->depth == 0)\n \t{\n \t   mutex->owner = (thread_t) 0;\n-\t   mutex_unlock (&mutex->actual);\n+\t   __gthrw_mutex_unlock (&mutex->actual);\n \t}\n     }\n   return 0;"}, {"sha": "d54a6c801712d67a2288762c05db507c6a1e2da9", "filename": "gcc/gthr-tpf.h", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ef67393c7454bb93a070d0290b4196c06a93ce8/gcc%2Fgthr-tpf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ef67393c7454bb93a070d0290b4196c06a93ce8/gcc%2Fgthr-tpf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-tpf.h?ref=7ef67393c7454bb93a070d0290b4196c06a93ce8", "patch": "@@ -1,6 +1,6 @@\n /* Threads compatibility routines for libgcc2 and libobjc.\n    Compile this one with gcc.\n-   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -69,19 +69,26 @@ typedef pthread_mutex_t __gthread_recursive_mutex_t;\n #define __tpf_pthread_active() (CE2THRCPTR != NOTATHREAD)\n \n #if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n+# define __gthrw(name) \\\n+  extern __typeof(name) __gthrw_ ## name __attribute__ ((__weakref__(#name)))\n+#else\n+# define __gthrw_asmname(cname) __gthrw_asmnamep (__USER_LABEL_PREFIX__, cname)\n+# define __gthrw_asmnamep(prefix, cname) __gthrw_string (prefix) cname\n+# define __gthrw_string(x) #x\n+# define __gthrw(name) \\\n+  extern __typeof(name) __gthrw_ ## name __asm (__gthrw_asmname (#name))\n+#endif\n \n-#pragma weak pthread_once\n-#pragma weak pthread_key_create\n-#pragma weak pthread_key_delete\n-#pragma weak pthread_getspecific\n-#pragma weak pthread_setspecific\n-#pragma weak pthread_create\n-\n-#pragma weak pthread_mutex_lock\n-#pragma weak pthread_mutex_trylock\n-#pragma weak pthread_mutex_unlock\n+__gthrw(pthread_once);\n+__gthrw(pthread_key_create);\n+__gthrw(pthread_key_delete);\n+__gthrw(pthread_getspecific);\n+__gthrw(pthread_setspecific);\n+__gthrw(pthread_create);\n \n-#endif /* SUPPORTS_WEAK */\n+__gthrw(pthread_mutex_lock);\n+__gthrw(pthread_mutex_trylock);\n+__gthrw(pthread_mutex_unlock);\n \n static inline int\n __gthread_active_p (void)\n@@ -93,7 +100,7 @@ static inline int\n __gthread_once (__gthread_once_t *once, void (*func) (void))\n {\n   if (__tpf_pthread_active ())\n-    return pthread_once (once, func);\n+    return __gthrw_pthread_once (once, func);\n   else\n     return -1;\n }\n@@ -102,7 +109,7 @@ static inline int\n __gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n {\n   if (__tpf_pthread_active ())\n-    return pthread_key_create (key, dtor);\n+    return __gthrw_pthread_key_create (key, dtor);\n   else\n     return -1;\n }\n@@ -111,7 +118,7 @@ static inline int\n __gthread_key_delete (__gthread_key_t key)\n {\n   if (__tpf_pthread_active ())\n-    return pthread_key_delete (key);\n+    return __gthrw_pthread_key_delete (key);\n   else\n     return -1;\n }\n@@ -120,7 +127,7 @@ static inline void *\n __gthread_getspecific (__gthread_key_t key)\n {\n   if (__tpf_pthread_active ())\n-    return pthread_getspecific (key);\n+    return __gthrw_pthread_getspecific (key);\n   else\n     return NULL;\n }\n@@ -129,7 +136,7 @@ static inline int\n __gthread_setspecific (__gthread_key_t key, const void *ptr)\n {\n   if (__tpf_pthread_active ())\n-    return pthread_setspecific (key, ptr);\n+    return __gthrw_pthread_setspecific (key, ptr);\n   else\n     return -1;\n }\n@@ -138,7 +145,7 @@ static inline int\n __gthread_mutex_lock (__gthread_mutex_t *mutex)\n {\n   if (__tpf_pthread_active ())\n-    return pthread_mutex_lock (mutex);\n+    return __gthrw_pthread_mutex_lock (mutex);\n   else\n     return 0;\n }\n@@ -147,7 +154,7 @@ static inline int\n __gthread_mutex_trylock (__gthread_mutex_t *mutex)\n {\n   if (__tpf_pthread_active ())\n-    return pthread_mutex_trylock (mutex);\n+    return __gthrw_pthread_mutex_trylock (mutex);\n   else\n     return 0;\n }\n@@ -156,7 +163,7 @@ static inline int\n __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n {\n   if (__tpf_pthread_active ())\n-    return pthread_mutex_unlock (mutex);\n+    return __gthrw_pthread_mutex_unlock (mutex);\n   else\n     return 0;\n }"}, {"sha": "a6ff14f6a12797fcb8b942c3af597ee90bbc966e", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ef67393c7454bb93a070d0290b4196c06a93ce8/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ef67393c7454bb93a070d0290b4196c06a93ce8/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=7ef67393c7454bb93a070d0290b4196c06a93ce8", "patch": "@@ -1,3 +1,8 @@\n+2005-11-09  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR other/4372\n+\t* thr-objc.c (_XOPEN_SOURCE): Define.\n+\n 2005-10-07  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \tPR libobjc/23612"}, {"sha": "a859e1eb0fb58f1146219824567594e10327b9b4", "filename": "libobjc/thr-objc.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ef67393c7454bb93a070d0290b4196c06a93ce8/libobjc%2Fthr-objc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ef67393c7454bb93a070d0290b4196c06a93ce8/libobjc%2Fthr-objc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-objc.c?ref=7ef67393c7454bb93a070d0290b4196c06a93ce8", "patch": "@@ -24,6 +24,10 @@ Boston, MA 02110-1301, USA.  */\n    covered by the GNU General Public License.  */\n \n #define _LIBOBJC\n+/* The line below is needed for declarations of functions such as\n+   pthread_mutexattr_settype, without which gthr-posix.h may fail to\n+   compile within libobjc.  */\n+#define _XOPEN_SOURCE 500\n #include \"config.h\"\n #include \"tconfig.h\"\n #include \"coretypes.h\""}]}