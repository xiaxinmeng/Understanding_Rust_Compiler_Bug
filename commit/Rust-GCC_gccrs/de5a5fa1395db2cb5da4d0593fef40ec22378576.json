{"sha": "de5a5fa1395db2cb5da4d0593fef40ec22378576", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU1YTVmYTEzOTVkYjJjYjVkYTRkMDU5M2ZlZjQwZWMyMjM3ODU3Ng==", "commit": {"author": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2013-08-30T16:12:58Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2013-08-30T16:12:58Z"}, "message": "Merge ubsan into trunk.\n\nFrom-SVN: r202113", "tree": {"sha": "23d42aa647cb7a2de96792b724ecaaddee3423fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23d42aa647cb7a2de96792b724ecaaddee3423fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de5a5fa1395db2cb5da4d0593fef40ec22378576", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de5a5fa1395db2cb5da4d0593fef40ec22378576", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de5a5fa1395db2cb5da4d0593fef40ec22378576", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de5a5fa1395db2cb5da4d0593fef40ec22378576/comments", "author": null, "committer": null, "parents": [{"sha": "f07f30cfb5efe0806dedaea03b56c574da1b372c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f07f30cfb5efe0806dedaea03b56c574da1b372c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f07f30cfb5efe0806dedaea03b56c574da1b372c"}], "stats": {"total": 3977, "additions": 3883, "deletions": 94}, "files": [{"sha": "ab34cbcc224dfc6f7777b3a688771d3691056766", "filename": "config/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/config%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/config%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2FChangeLog?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -1,3 +1,7 @@\n+2013-08-30  Marek Polacek  <polacek@redhat.com>\n+\n+\t* bootstrap-ubsan.mk: New.\n+\n 2013-03-27  Kai Tietz  <ktietz@redhat.com>\n \n \t* dfp.m4: Add support for cygwin x64 target."}, {"sha": "2d21e832e217a968e6aaf2a749a18352a0fb2d28", "filename": "config/bootstrap-ubsan.mk", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/config%2Fbootstrap-ubsan.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/config%2Fbootstrap-ubsan.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fbootstrap-ubsan.mk?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,7 @@\n+# This option enables -fsanitize=undefined for stage2 and stage3.\n+\n+STAGE2_CFLAGS += -fsanitize=undefined\n+STAGE3_CFLAGS += -fsanitize=undefined\n+POSTSTAGE1_LDFLAGS += -fsanitize=undefined -static-libubsan -lpthread \\\n+\t\t      -B$$r/prev-$(TARGET_SUBDIR)/libsanitizer/ubsan/ \\\n+\t\t      -B$$r/prev-$(TARGET_SUBDIR)/libsanitizer/ubsan/.libs"}, {"sha": "787040f5dc7fd4a6c74360f33a5985e045f0b4be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -1,3 +1,79 @@\n+2013-08-30  Marek Polacek  <polacek@redhat.com>\n+\n+\t* Makefile.in (ubsan.o): Add.\n+\t(c-family/c-ubsan.o): Add.\n+\t(builtins.o): Add ubsan.h dependency.\n+\t* ubsan.h: New file.\n+\t* ubsan.c: New file.\n+\t* common.opt: Add -fsanitize=undefined option.\n+\t(flag_sanitize): Add variable.\n+\t(fsanitize=): Add option.  Add Driver.\n+\t(fsanitize=thread): Remove option.\n+\t(fsanitize=address): Likewise.\n+\t(static-libubsan): New option.\n+\t* doc/invoke.texi: Document the new flag and -static-libubsan.\n+\t* sanitizer.def (DEF_SANITIZER_BUILTIN): Define.\n+\t(BUILT_IN_UBSAN_HANDLE_BUILTIN_UNREACHABLE): Define.\n+\t* builtin-attrs.def (ATTR_COLD): Define.\n+\t(ATTR_COLD_NOTHROW_LEAF_LIST): Define.\n+\t* builtins.def (BUILT_IN_UBSAN_HANDLE_DIVREM_OVERFLOW,\n+\tBUILT_IN_UBSAN_HANDLE_SHIFT_OUT_OF_BOUNDS): Define.\n+\t* flag-types.h (sanitize_code): New enum.\n+\t* opts.c (common_handle_option): Parse command line arguments\n+\tof -fsanitize=.  Add -fsanitize=unreachable option.\n+\t* varasm.c (get_variable_section): Adjust.\n+\t(assemble_noswitch_variable): Likewise.\n+\t(assemble_variable): Likewise.\n+\t(output_constant_def_contents): Likewise.\n+\t(categorize_decl_for_section): Likewise.\n+\t(place_block_symbol): Likewise.\n+\t(output_object_block): Likewise.\n+\t* builtins.def: Likewise.\n+\t* toplev.c (compile_file): Likewise.\n+\t(process_options): Likewise.\n+\t* cppbuiltin.c: Likewise.\n+\t* tsan.c (tsan_pass): Likewise.\n+\t(tsan_gate): Likewise.\n+\t(tsan_gate_O0): Likewise.\n+\t* cfgexpand.c (partition_stack_vars): Likewise.\n+\t(expand_stack_vars): Likewise.\n+\t(defer_stack_allocation): Likewise.\n+\t(expand_used_vars): Likewise.\n+\t* cfgcleanup.c (old_insns_match_p): Likewise.\n+\t* asan.c (asan_finish_file): Likewise.\n+\t(asan_instrument): Likewise.\n+\t(gate_asan): Likewise.\n+\t(initialize_sanitizer_builtins): Build BT_FN_VOID_PTR_PTR_PTR.\n+\t(ATTR_COLD_NOTHROW_LEAF_LIST): Define.\n+\t(asan_global_struct): Use pointer_sized_int_node instead\n+\tcalling build_nonstandard_integer_type.\n+\t(initialize_sanitizer_builtins): Likewise.\n+\t(asan_finish_file): Likewise.\n+\t* gcc.c: Document %{%:function(args):X}.\n+\t(static_spec_functions): Add sanitize.\n+\t(handle_spec_function): Add retval_nonnull argument and if non-NULL,\n+\tstore funcval != NULL there.\n+\t(do_spec_1): Adjust handle_spec_function caller.\n+\t(handle_braces): Allow %:function(args) as condition.\n+\t(sanitize_spec_function): New function.\n+\t(ADD_STATIC_LIBUBSAN_LIBS): Define.\n+\t(LIBUBSAN_SPEC): Likewise.\n+\t(LIBUBSAN_EARLY_SPEC): Likewise.\n+\t(SANITIZER_SPEC): Handle libubsan.\n+\t(SANITIZER_EARLY_SPEC): Likewise.\n+\t* config/darwin.h (LINK_COMMAND_SPEC_A): Use %:sanitize(address)\n+\tinstead of fsanitize=address.\n+\t* config/arm/linux-eabi.h (ASAN_CC1_SPEC): Use %:sanitize(address)\n+\tinstead of fsanitize=address*.\n+\t* builtins.c: Include ubsan.h.\n+\t(fold_builtin_0): Instrument __builtin_unreachable.\n+\t* config/rs6000/rs6000.h (FRAME_GROWS_DOWNWARD): Use flag_sanitize\n+\tinstead of flag_asan.\n+\t* tree.h (enum tree_index): Add TI_POINTER_SIZED_TYPE.\n+\t(pointer_sized_int_node): Define.\n+\t* tree.c (build_common_tree_nodes): Initialize\n+\tpointer_sized_int_node.\n+\n 2013-08-30  Mike Stump  <mikestump@comcast.net>\n \n \t* doc/install.texi (Prerequisites): Note regression in Tcl 8.6"}, {"sha": "7396313e1bbf9eb2e5e918bd53ff8ea47e70f282", "filename": "gcc/Makefile.in", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -1154,7 +1154,7 @@ C_COMMON_OBJS = c-family/c-common.o c-family/c-cppbuiltin.o c-family/c-dump.o \\\n   c-family/c-omp.o c-family/c-opts.o c-family/c-pch.o \\\n   c-family/c-ppoutput.o c-family/c-pragma.o c-family/c-pretty-print.o \\\n   c-family/c-semantics.o c-family/c-ada-spec.o tree-mudflap.o \\\n-  c-family/array-notation-common.o\n+  c-family/array-notation-common.o c-family/c-ubsan.o\n \n # Language-independent object files.\n # We put the insn-*.o files first so that a parallel make will build\n@@ -1383,6 +1383,7 @@ OBJS = \\\n \ttree-affine.o \\\n \tasan.o \\\n \ttsan.o \\\n+\tubsan.o \\\n \ttree-call-cdce.o \\\n \ttree-cfg.o \\\n \ttree-cfgcleanup.o \\\n@@ -2028,6 +2029,10 @@ c-family/array-notation-common.o : c-family/array-notation-common.c $(TREE_H) \\\n c-family/stub-objc.o : c-family/stub-objc.c $(CONFIG_H) $(SYSTEM_H) \\\n \tcoretypes.h $(TREE_H) $(C_COMMON_H) c-family/c-objc.h\n \n+c-family/c-ubsan.o : c-family/c-ubsan.c $(CONFIG_H) $(SYSTEM_H) \\\n+\tcoretypes.h $(TREE_H) $(C_COMMON_H) c-family/c-ubsan.h \\\n+\talloc-pool.h $(CGRAPH_H) $(GIMPLE_H) $(HASH_TABLE_H) output.h \\\n+\ttoplev.h ubsan.h\n default-c.o: config/default-c.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n   $(C_TARGET_H) $(C_TARGET_DEF_H)\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) \\\n@@ -2265,8 +2270,11 @@ tsan.o : $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TREE_INLINE_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_PASS_H) $(CGRAPH_H) $(GGC_H) \\\n    $(BASIC_BLOCK_H) $(FLAGS_H) $(FUNCTION_H) \\\n    $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_CORE_H) $(GIMPLE_H) tree-iterator.h \\\n-   intl.h cfghooks.h output.h options.h c-family/c-common.h tsan.h asan.h \\\n+   intl.h cfghooks.h output.h options.h $(C_COMMON_H) tsan.h asan.h \\\n    tree-ssa-propagate.h\n+ubsan.o : ubsan.c ubsan.h $(CONFIG_H) $(SYSTEM_H) $(GIMPLE_H) \\\n+   output.h coretypes.h $(TREE_H) $(CGRAPH_H) $(HASHTAB_H) gt-ubsan.h \\\n+   toplev.h $(C_COMMON_H)\n tree-ssa-tail-merge.o: tree-ssa-tail-merge.c \\\n    $(SYSTEM_H) $(CONFIG_H) coretypes.h $(TM_H) $(BITMAP_H) \\\n    $(FLAGS_H) $(TM_P_H) $(BASIC_BLOCK_H) $(CFGLOOP_H) \\\n@@ -2836,7 +2844,7 @@ builtins.o : builtins.c builtins.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    hard-reg-set.h $(DIAGNOSTIC_CORE_H) hard-reg-set.h $(EXCEPT_H) \\\n    $(TM_P_H) $(PREDICT_H) $(LIBFUNCS_H) langhooks.h $(BASIC_BLOCK_H) \\\n    tree-mudflap.h realmpfr.h $(BUILTINS_DEF) $(MACHMODE_H) \\\n-   $(DIAGNOSTIC_CORE_H) $(TREE_FLOW_H) value-prof.h\n+   $(DIAGNOSTIC_CORE_H) $(TREE_FLOW_H) value-prof.h ubsan.h\n calls.o : calls.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) $(EXPR_H) $(OPTABS_H) langhooks.h $(TARGET_H) \\\n    $(LIBFUNCS_H) $(REGS_H) $(DIAGNOSTIC_CORE_H) output.h \\\n@@ -3830,6 +3838,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/ipa-inline.h \\\n   $(srcdir)/vtable-verify.c \\\n   $(srcdir)/asan.c \\\n+  $(srcdir)/ubsan.c \\\n   $(srcdir)/tsan.c $(srcdir)/ipa-devirt.c \\\n   @all_gtfiles@\n "}, {"sha": "e7b1f4724e25fc1608c0b11b3a30fe40cbef7eb0", "filename": "gcc/asan.c", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -1938,7 +1938,7 @@ asan_global_struct (void)\n \t= build_decl (UNKNOWN_LOCATION, FIELD_DECL,\n \t\t      get_identifier (field_names[i]),\n \t\t      (i == 0 || i == 3) ? const_ptr_type_node\n-\t\t      : build_nonstandard_integer_type (POINTER_SIZE, 1));\n+\t\t      : pointer_sized_int_node);\n       DECL_CONTEXT (fields[i]) = ret;\n       if (i)\n \tDECL_CHAIN (fields[i - 1]) = fields[i];\n@@ -2016,10 +2016,12 @@ initialize_sanitizer_builtins (void)\n   tree BT_FN_VOID = build_function_type_list (void_type_node, NULL_TREE);\n   tree BT_FN_VOID_PTR\n     = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n+  tree BT_FN_VOID_PTR_PTR_PTR\n+    = build_function_type_list (void_type_node, ptr_type_node,\n+\t\t\t\tptr_type_node, ptr_type_node, NULL_TREE);\n   tree BT_FN_VOID_PTR_PTRMODE\n     = build_function_type_list (void_type_node, ptr_type_node,\n-\t\t\t\tbuild_nonstandard_integer_type (POINTER_SIZE,\n-\t\t\t\t\t\t\t\t1), NULL_TREE);\n+\t\t\t\tpointer_sized_int_node, NULL_TREE);\n   tree BT_FN_VOID_INT\n     = build_function_type_list (void_type_node, integer_type_node, NULL_TREE);\n   tree BT_FN_BOOL_VPTR_PTR_IX_INT_INT[5];\n@@ -2081,6 +2083,12 @@ initialize_sanitizer_builtins (void)\n #undef ATTR_TMPURE_NORETURN_NOTHROW_LEAF_LIST\n #define ATTR_TMPURE_NORETURN_NOTHROW_LEAF_LIST \\\n   ECF_TM_PURE | ATTR_NORETURN_NOTHROW_LEAF_LIST\n+#undef ATTR_COLD_NOTHROW_LEAF_LIST\n+#define ATTR_COLD_NOTHROW_LEAF_LIST \\\n+  /* ECF_COLD missing */ ATTR_NOTHROW_LEAF_LIST\n+#undef ATTR_COLD_NORETURN_NOTHROW_LEAF_LIST\n+#define ATTR_COLD_NORETURN_NOTHROW_LEAF_LIST \\\n+  /* ECF_COLD missing */ ATTR_NORETURN_NOTHROW_LEAF_LIST\n #undef DEF_SANITIZER_BUILTIN\n #define DEF_SANITIZER_BUILTIN(ENUM, NAME, TYPE, ATTRS) \\\n   decl = add_builtin_function (\"__builtin_\" NAME, TYPE, ENUM,\t\t\\\n@@ -2157,7 +2165,7 @@ asan_finish_file (void)\n   /* Avoid instrumenting code in the asan ctors/dtors.\n      We don't need to insert padding after the description strings,\n      nor after .LASAN* array.  */\n-  flag_asan = 0;\n+  flag_sanitize &= ~SANITIZE_ADDRESS;\n \n   tree fn = builtin_decl_implicit (BUILT_IN_ASAN_INIT);\n   append_to_statement_list (build_call_expr (fn, 0), &asan_ctor_statements);\n@@ -2170,7 +2178,6 @@ asan_finish_file (void)\n   if (gcount)\n     {\n       tree type = asan_global_struct (), var, ctor;\n-      tree uptr = build_nonstandard_integer_type (POINTER_SIZE, 1);\n       tree dtor_statements = NULL_TREE;\n       vec<constructor_elt, va_gc> *v;\n       char buf[20];\n@@ -2199,22 +2206,23 @@ asan_finish_file (void)\n       varpool_assemble_decl (varpool_node_for_decl (var));\n \n       fn = builtin_decl_implicit (BUILT_IN_ASAN_REGISTER_GLOBALS);\n+      tree gcount_tree = build_int_cst (pointer_sized_int_node, gcount);\n       append_to_statement_list (build_call_expr (fn, 2,\n \t\t\t\t\t\t build_fold_addr_expr (var),\n-\t\t\t\t\t\t build_int_cst (uptr, gcount)),\n+\t\t\t\t\t\t gcount_tree),\n \t\t\t\t&asan_ctor_statements);\n \n       fn = builtin_decl_implicit (BUILT_IN_ASAN_UNREGISTER_GLOBALS);\n       append_to_statement_list (build_call_expr (fn, 2,\n \t\t\t\t\t\t build_fold_addr_expr (var),\n-\t\t\t\t\t\t build_int_cst (uptr, gcount)),\n+\t\t\t\t\t\t gcount_tree),\n \t\t\t\t&dtor_statements);\n       cgraph_build_static_cdtor ('D', dtor_statements,\n \t\t\t\t MAX_RESERVED_INIT_PRIORITY - 1);\n     }\n   cgraph_build_static_cdtor ('I', asan_ctor_statements,\n \t\t\t     MAX_RESERVED_INIT_PRIORITY - 1);\n-  flag_asan = 1;\n+  flag_sanitize |= SANITIZE_ADDRESS;\n }\n \n /* Instrument the current function.  */\n@@ -2231,7 +2239,7 @@ asan_instrument (void)\n static bool\n gate_asan (void)\n {\n-  return flag_asan != 0\n+  return (flag_sanitize & SANITIZE_ADDRESS) != 0\n \t  && !lookup_attribute (\"no_sanitize_address\",\n \t\t\t\tDECL_ATTRIBUTES (current_function_decl));\n }"}, {"sha": "7939727015a24131e00e0528ad14c4448e61da99", "filename": "gcc/builtin-attrs.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fbuiltin-attrs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fbuiltin-attrs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-attrs.def?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -83,6 +83,7 @@ DEF_LIST_INT_INT (5,6)\n #undef DEF_LIST_INT_INT\n \n /* Construct trees for identifiers.  */\n+DEF_ATTR_IDENT (ATTR_COLD, \"cold\")\n DEF_ATTR_IDENT (ATTR_CONST, \"const\")\n DEF_ATTR_IDENT (ATTR_FORMAT, \"format\")\n DEF_ATTR_IDENT (ATTR_FORMAT_ARG, \"format_arg\")\n@@ -130,6 +131,10 @@ DEF_ATTR_TREE_LIST (ATTR_NORETURN_NOTHROW_LIST, ATTR_NORETURN,\t\\\n \t\t\tATTR_NULL, ATTR_NOTHROW_LIST)\n DEF_ATTR_TREE_LIST (ATTR_NORETURN_NOTHROW_LEAF_LIST, ATTR_NORETURN,\\\n \t\t\tATTR_NULL, ATTR_NOTHROW_LEAF_LIST)\n+DEF_ATTR_TREE_LIST (ATTR_COLD_NOTHROW_LEAF_LIST, ATTR_COLD,\\\n+\t\t\tATTR_NULL, ATTR_NOTHROW_LEAF_LIST)\n+DEF_ATTR_TREE_LIST (ATTR_COLD_NORETURN_NOTHROW_LEAF_LIST, ATTR_COLD,\\\n+\t\t\tATTR_NULL, ATTR_NORETURN_NOTHROW_LEAF_LIST)\n DEF_ATTR_TREE_LIST (ATTR_CONST_NORETURN_NOTHROW_LEAF_LIST, ATTR_CONST,\\\n \t\t\tATTR_NULL, ATTR_NORETURN_NOTHROW_LEAF_LIST)\n DEF_ATTR_TREE_LIST (ATTR_MALLOC_NOTHROW_LIST, ATTR_MALLOC,\t\\"}, {"sha": "92aec31ab4733fb12715109f0973de061dd18070", "filename": "gcc/builtins.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"value-prof.h\"\n #include \"diagnostic-core.h\"\n #include \"builtins.h\"\n+#include \"ubsan.h\"\n \n \n #ifndef PAD_VARARGS_DOWN\n@@ -10303,6 +10304,11 @@ fold_builtin_0 (location_t loc, tree fndecl, bool ignore ATTRIBUTE_UNUSED)\n     case BUILT_IN_CLASSIFY_TYPE:\n       return fold_builtin_classify_type (NULL_TREE);\n \n+    case BUILT_IN_UNREACHABLE:\n+      if (flag_sanitize & SANITIZE_UNREACHABLE)\n+\treturn ubsan_instrument_unreachable (loc);\n+      break;\n+\n     default:\n       break;\n     }"}, {"sha": "8ccf3ae3578296b4956337d0c39d1503f3f162f5", "filename": "gcc/builtins.def", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -161,7 +161,8 @@ along with GCC; see the file COPYING3.  If not see\n #define DEF_SANITIZER_BUILTIN(ENUM, NAME, TYPE, ATTRS) \\\n   DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n \t       true, true, true, ATTRS, true, \\\n-\t       (flag_asan || flag_tsan))\n+\t      (flag_sanitize & (SANITIZE_ADDRESS | SANITIZE_THREAD \\\n+\t\t\t\t| SANITIZE_UNDEFINED)))\n \n #undef DEF_CILKPLUS_BUILTIN\n #define DEF_CILKPLUS_BUILTIN(ENUM, NAME, TYPE, ATTRS)  \\"}, {"sha": "f8ca4a9d219e2c686065bd5387841e776a0cf525", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -1,3 +1,8 @@\n+2013-08-30  Marek Polacek  <polacek@redhat.com>\n+\n+\t* c-ubsan.c: New file.\n+\t* c-ubsan.h: New file.\n+\n 2013-08-30  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* c-pretty-print.h (c_pretty_printer::declaration): Now a virtual"}, {"sha": "9f43f6d55b84084fce0dd4556b95509f371e7c69", "filename": "gcc/c-family/c-ubsan.c", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fc-family%2Fc-ubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fc-family%2Fc-ubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ubsan.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,158 @@\n+/* UndefinedBehaviorSanitizer, undefined behavior detector.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+   Contributed by Marek Polacek <polacek@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"alloc-pool.h\"\n+#include \"cgraph.h\"\n+#include \"gimple.h\"\n+#include \"hash-table.h\"\n+#include \"output.h\"\n+#include \"toplev.h\"\n+#include \"ubsan.h\"\n+#include \"c-family/c-common.h\"\n+#include \"c-family/c-ubsan.h\"\n+\n+/* Instrument division by zero and INT_MIN / -1.  If not instrumenting,\n+   return NULL_TREE.  */\n+\n+tree\n+ubsan_instrument_division (location_t loc, tree op0, tree op1)\n+{\n+  tree t, tt;\n+  tree type = TREE_TYPE (op0);\n+\n+  /* At this point both operands should have the same type,\n+     because they are already converted to RESULT_TYPE.\n+     Use TYPE_MAIN_VARIANT since typedefs can confuse us.  */\n+  gcc_assert (TYPE_MAIN_VARIANT (TREE_TYPE (op0))\n+\t      == TYPE_MAIN_VARIANT (TREE_TYPE (op1)));\n+\n+  /* TODO: REAL_TYPE is not supported yet.  */\n+  if (TREE_CODE (type) != INTEGER_TYPE)\n+    return NULL_TREE;\n+\n+  /* If we *know* that the divisor is not -1 or 0, we don't have to\n+     instrument this expression.\n+     ??? We could use decl_constant_value to cover up more cases.  */\n+  if (TREE_CODE (op1) == INTEGER_CST\n+      && integer_nonzerop (op1)\n+      && !integer_minus_onep (op1))\n+    return NULL_TREE;\n+\n+  t = fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t    op1, build_int_cst (type, 0));\n+\n+  /* We check INT_MIN / -1 only for signed types.  */\n+  if (!TYPE_UNSIGNED (type))\n+    {\n+      tree x;\n+      tt = fold_build2 (EQ_EXPR, boolean_type_node, op1,\n+\t\t\tbuild_int_cst (type, -1));\n+      x = fold_build2 (EQ_EXPR, boolean_type_node, op0,\n+\t\t       TYPE_MIN_VALUE (type));\n+      x = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, x, tt);\n+      t = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, t, x);\n+    }\n+\n+  /* In case we have a SAVE_EXPR in a conditional context, we need to\n+     make sure it gets evaluated before the condition.  */\n+  t = fold_build2 (COMPOUND_EXPR, TREE_TYPE (t), op0, t);\n+  tree data = ubsan_create_data (\"__ubsan_overflow_data\",\n+\t\t\t\t loc, ubsan_type_descriptor (type),\n+\t\t\t\t NULL_TREE);\n+  data = build_fold_addr_expr_loc (loc, data);\n+  tt = builtin_decl_explicit (BUILT_IN_UBSAN_HANDLE_DIVREM_OVERFLOW);\n+  tt = build_call_expr_loc (loc, tt, 3, data, ubsan_encode_value (op0),\n+\t\t\t    ubsan_encode_value (op1));\n+  t = fold_build3 (COND_EXPR, void_type_node, t, tt, void_zero_node);\n+\n+  return t;\n+}\n+\n+/* Instrument left and right shifts.  If not instrumenting, return\n+   NULL_TREE.  */\n+\n+tree\n+ubsan_instrument_shift (location_t loc, enum tree_code code,\n+\t\t\ttree op0, tree op1)\n+{\n+  tree t, tt = NULL_TREE;\n+  tree type0 = TREE_TYPE (op0);\n+  tree type1 = TREE_TYPE (op1);\n+  tree op1_utype = unsigned_type_for (type1);\n+  HOST_WIDE_INT op0_prec = TYPE_PRECISION (type0);\n+  tree uprecm1 = build_int_cst (op1_utype, op0_prec - 1);\n+  tree precm1 = build_int_cst (type1, op0_prec - 1);\n+\n+  t = fold_convert_loc (loc, op1_utype, op1);\n+  t = fold_build2 (GT_EXPR, boolean_type_node, t, uprecm1);\n+\n+  /* For signed x << y, in C99/C11, the following:\n+     (unsigned) x >> (precm1 - y)\n+     if non-zero, is undefined.  */\n+  if (code == LSHIFT_EXPR\n+      && !TYPE_UNSIGNED (type0)\n+      && flag_isoc99)\n+    {\n+      tree x = fold_build2 (MINUS_EXPR, integer_type_node, precm1, op1);\n+      tt = fold_convert_loc (loc, unsigned_type_for (type0), op0);\n+      tt = fold_build2 (RSHIFT_EXPR, TREE_TYPE (tt), tt, x);\n+      tt = fold_build2 (NE_EXPR, boolean_type_node, tt,\n+\t\t\tbuild_int_cst (TREE_TYPE (tt), 0));\n+    }\n+\n+  /* For signed x << y, in C++11/C++14, the following:\n+     x < 0 || ((unsigned) x >> (precm1 - y))\n+     if > 1, is undefined.  */\n+  if (code == LSHIFT_EXPR\n+      && !TYPE_UNSIGNED (TREE_TYPE (op0))\n+      && (cxx_dialect == cxx11 || cxx_dialect == cxx1y))\n+    {\n+      tree x = fold_build2 (MINUS_EXPR, integer_type_node, precm1, op1);\n+      tt = fold_convert_loc (loc, unsigned_type_for (type0), op0);\n+      tt = fold_build2 (RSHIFT_EXPR, TREE_TYPE (tt), tt, x);\n+      tt = fold_build2 (GT_EXPR, boolean_type_node, tt,\n+\t\t\tbuild_int_cst (TREE_TYPE (tt), 1));\n+      x = fold_build2 (LT_EXPR, boolean_type_node, op0,\n+\t\t       build_int_cst (type0, 0));\n+      tt = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, x, tt);\n+    }\n+\n+  /* In case we have a SAVE_EXPR in a conditional context, we need to\n+     make sure it gets evaluated before the condition.  */\n+  t = fold_build2 (COMPOUND_EXPR, TREE_TYPE (t), op0, t);\n+  tree data = ubsan_create_data (\"__ubsan_shift_data\",\n+\t\t\t\t loc, ubsan_type_descriptor (type0),\n+\t\t\t\t ubsan_type_descriptor (type1), NULL_TREE);\n+\n+  data = build_fold_addr_expr_loc (loc, data);\n+\n+  t = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, t,\n+\t\t   tt ? tt : integer_zero_node);\n+  tt = builtin_decl_explicit (BUILT_IN_UBSAN_HANDLE_SHIFT_OUT_OF_BOUNDS);\n+  tt = build_call_expr_loc (loc, tt, 3, data, ubsan_encode_value (op0),\n+\t\t\t    ubsan_encode_value (op1));\n+  t = fold_build3 (COND_EXPR, void_type_node, t, tt, void_zero_node);\n+\n+  return t;\n+}"}, {"sha": "b032b707cc3a8fb7a9ec7350952d935da9c78da7", "filename": "gcc/c-family/c-ubsan.h", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fc-family%2Fc-ubsan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fc-family%2Fc-ubsan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ubsan.h?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,27 @@\n+/* UndefinedBehaviorSanitizer, undefined behavior detector.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+   Contributed by Marek Polacek <polacek@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_C_UBSAN_H\n+#define GCC_C_UBSAN_H\n+\n+extern tree ubsan_instrument_division (location_t, tree, tree);\n+extern tree ubsan_instrument_shift (location_t, enum tree_code, tree, tree);\n+\n+#endif  /* GCC_C_UBSAN_H  */"}, {"sha": "40b8cfa8bb39ddbf36399d5a4c31f03db45a6031", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -1,3 +1,8 @@\n+2013-08-30  Marek Polacek  <polacek@redhat.com>\n+\n+\t* c-typeck.c (build_binary_op): Add division by zero and shift\n+\tinstrumentation.\n+\n 2013-08-26  Joern Rennecke  <joern.rennecke@embecosm.com>\n \t    Joseph Myers  <joseph@codesourcery.com>\n "}, {"sha": "f29ca049649a6611965ee08bae637586fb0c7abe", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple.h\"\n #include \"c-family/c-objc.h\"\n #include \"c-family/c-common.h\"\n+#include \"c-family/c-ubsan.h\"\n \n /* Possible cases of implicit bad conversions.  Used to select\n    diagnostic messages in convert_for_assignment.  */\n@@ -9541,6 +9542,15 @@ build_binary_op (location_t location, enum tree_code code,\n      operands to truth-values.  */\n   bool boolean_op = false;\n \n+  /* Remember whether we're doing / or %.  */\n+  bool doing_div_or_mod = false;\n+\n+  /* Remember whether we're doing << or >>.  */\n+  bool doing_shift = false;\n+\n+  /* Tree holding instrumentation expression.  */\n+  tree instrument_expr = NULL;\n+\n   if (location == UNKNOWN_LOCATION)\n     location = input_location;\n \n@@ -9742,6 +9752,7 @@ build_binary_op (location_t location, enum tree_code code,\n     case FLOOR_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n+      doing_div_or_mod = true;\n       warn_for_div_by_zero (location, op1);\n \n       if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE\n@@ -9789,6 +9800,7 @@ build_binary_op (location_t location, enum tree_code code,\n \n     case TRUNC_MOD_EXPR:\n     case FLOOR_MOD_EXPR:\n+      doing_div_or_mod = true;\n       warn_for_div_by_zero (location, op1);\n \n       if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE\n@@ -9887,6 +9899,7 @@ build_binary_op (location_t location, enum tree_code code,\n       else if ((code0 == INTEGER_TYPE || code0 == FIXED_POINT_TYPE)\n \t  && code1 == INTEGER_TYPE)\n \t{\n+\t  doing_shift = true;\n \t  if (TREE_CODE (op1) == INTEGER_CST)\n \t    {\n \t      if (tree_int_cst_sgn (op1) < 0)\n@@ -9939,6 +9952,7 @@ build_binary_op (location_t location, enum tree_code code,\n       else if ((code0 == INTEGER_TYPE || code0 == FIXED_POINT_TYPE)\n \t  && code1 == INTEGER_TYPE)\n \t{\n+\t  doing_shift = true;\n \t  if (TREE_CODE (op1) == INTEGER_CST)\n \t    {\n \t      if (tree_int_cst_sgn (op1) < 0)\n@@ -10483,6 +10497,21 @@ build_binary_op (location_t location, enum tree_code code,\n \treturn error_mark_node;\n     }\n \n+  if (flag_sanitize & SANITIZE_UNDEFINED\n+      && current_function_decl != 0\n+      && (doing_div_or_mod || doing_shift))\n+    {\n+      /* OP0 and/or OP1 might have side-effects.  */\n+      op0 = c_save_expr (op0);\n+      op1 = c_save_expr (op1);\n+      op0 = c_fully_fold (op0, false, NULL);\n+      op1 = c_fully_fold (op1, false, NULL);\n+      if (doing_div_or_mod)\n+\tinstrument_expr = ubsan_instrument_division (location, op0, op1);\n+      else if (doing_shift)\n+\tinstrument_expr = ubsan_instrument_shift (location, code, op0, op1);\n+    }\n+\n   /* Treat expressions in initializers specially as they can't trap.  */\n   if (int_const_or_overflow)\n     ret = (require_constant_value\n@@ -10506,6 +10535,11 @@ build_binary_op (location_t location, enum tree_code code,\n   if (semantic_result_type)\n     ret = build1 (EXCESS_PRECISION_EXPR, semantic_result_type, ret);\n   protected_set_expr_location (ret, location);\n+\n+  if ((flag_sanitize & SANITIZE_UNDEFINED) && instrument_expr != NULL)\n+    ret = fold_build2 (COMPOUND_EXPR, TREE_TYPE (ret),\n+\t\t       instrument_expr, ret);\n+\n   return ret;\n }\n "}, {"sha": "d918b4aaab0f687bcf57f82829a318acd86ba0ab", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -1137,7 +1137,7 @@ old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx i1, rtx i2)\n \n       /* For address sanitizer, never crossjump __asan_report_* builtins,\n \t otherwise errors might be reported on incorrect lines.  */\n-      if (flag_asan)\n+      if (flag_sanitize & SANITIZE_ADDRESS)\n \t{\n \t  rtx call = get_call_rtx_from (i1);\n \t  if (call && GET_CODE (XEXP (XEXP (call, 0), 0)) == SYMBOL_REF)"}, {"sha": "4da5e7ea0cf9d85a8390d1ac064df37e29595ed1", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -764,7 +764,7 @@ partition_stack_vars (void)\n \t     sizes, as the shorter vars wouldn't be adequately protected.\n \t     Don't do that for \"large\" (unsupported) alignment objects,\n \t     those aren't protected anyway.  */\n-\t  if (flag_asan && isize != jsize\n+\t  if ((flag_sanitize & SANITIZE_ADDRESS) && isize != jsize\n \t      && ialign * BITS_PER_UNIT <= MAX_SUPPORTED_STACK_ALIGNMENT)\n \t    break;\n \n@@ -940,7 +940,7 @@ expand_stack_vars (bool (*pred) (size_t), struct stack_vars_data *data)\n       alignb = stack_vars[i].alignb;\n       if (alignb * BITS_PER_UNIT <= MAX_SUPPORTED_STACK_ALIGNMENT)\n \t{\n-\t  if (flag_asan && pred)\n+\t  if ((flag_sanitize & SANITIZE_ADDRESS) && pred)\n \t    {\n \t      HOST_WIDE_INT prev_offset = frame_offset;\n \t      tree repr_decl = NULL_TREE;\n@@ -1110,7 +1110,7 @@ defer_stack_allocation (tree var, bool toplevel)\n   /* If stack protection is enabled, *all* stack variables must be deferred,\n      so that we can re-order the strings to the top of the frame.\n      Similarly for Address Sanitizer.  */\n-  if (flag_stack_protect || flag_asan)\n+  if (flag_stack_protect || (flag_sanitize & SANITIZE_ADDRESS))\n     return true;\n \n   /* We handle \"large\" alignment via dynamic allocation.  We want to handle\n@@ -1753,7 +1753,7 @@ expand_used_vars (void)\n \t    expand_stack_vars (stack_protect_decl_phase_2, &data);\n \t}\n \n-      if (flag_asan)\n+      if (flag_sanitize & SANITIZE_ADDRESS)\n \t/* Phase 3, any partitions that need asan protection\n \t   in addition to phase 1 and 2.  */\n \texpand_stack_vars (asan_decl_phase_3, &data);"}, {"sha": "caf624f51d4ae8e52452d187e507b2a72dd26200", "filename": "gcc/common.opt", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -207,6 +207,10 @@ unsigned int help_columns\n Variable\n bool flag_opts_finished\n \n+; What the sanitizer should instrument\n+Variable\n+unsigned int flag_sanitize\n+\n ###\n Driver\n \n@@ -850,13 +854,9 @@ fargument-noalias-anything\n Common Ignore\n Does nothing. Preserved for backward compatibility.\n \n-fsanitize=address\n-Common Report Var(flag_asan)\n-Enable AddressSanitizer, a memory error detector\n-\n-fsanitize=thread\n-Common Report Var(flag_tsan)\n-Enable ThreadSanitizer, a data race detector\n+fsanitize=\n+Common Driver Report Joined\n+Select what to sanitize\n \n fasynchronous-unwind-tables\n Common Report Var(flag_asynchronous_unwind_tables) Optimization\n@@ -2604,6 +2604,9 @@ Driver\n static-libtsan\n Driver\n \n+static-libubsan\n+Driver\n+\n symbolic\n Driver\n "}, {"sha": "232c38d28ffc8c74fa29985a2f38e4fdfe204090", "filename": "gcc/config/arm/linux-eabi.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fconfig%2Farm%2Flinux-eabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fconfig%2Farm%2Flinux-eabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flinux-eabi.h?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -85,7 +85,7 @@\n \t\t       LINUX_TARGET_LINK_SPEC \" \" ANDROID_LINK_SPEC)\n \n #undef  ASAN_CC1_SPEC\n-#define ASAN_CC1_SPEC \"%{fsanitize=*:-funwind-tables}\"\n+#define ASAN_CC1_SPEC \"%{%:sanitize(address):-funwind-tables}\"\n \n #undef  CC1_SPEC\n #define CC1_SPEC\t\t\t\t\t\t\t\\"}, {"sha": "9d04472d86519d5e543e90fb0314eab953d14d4d", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -178,7 +178,7 @@ extern GTY(()) int darwin_ms_struct;\n     %{L*} %(link_libgcc) %o %{fprofile-arcs|fprofile-generate*|coverage:-lgcov} \\\n     %{fopenmp|ftree-parallelize-loops=*: \\\n       %{static|static-libgcc|static-libstdc++|static-libgfortran: libgomp.a%s; : -lgomp } } \\\n-    %{fsanitize=address: -lasan } \\\n+    %{%:sanitize(address): -lasan } \\\n     %{fgnu-tm: \\\n       %{static|static-libgcc|static-libstdc++|static-libgfortran: libitm.a%s; : -litm } } \\\n     %{!nostdlib:%{!nodefaultlibs:\\"}, {"sha": "f89b20d92f369b364eec1da4adcd7e4b88b6d337", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -1498,7 +1498,8 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n \n    On the RS/6000, we grow upwards, from the area after the outgoing\n    arguments.  */\n-#define FRAME_GROWS_DOWNWARD (flag_stack_protect != 0 || flag_asan != 0)\n+#define FRAME_GROWS_DOWNWARD (flag_stack_protect != 0\t\t\t\\\n+\t\t\t      || (flag_sanitize & SANITIZE_ADDRESS) != 0)\n \n /* Size of the outgoing register save area */\n #define RS6000_REG_SAVE ((DEFAULT_ABI == ABI_AIX\t\t\t\\"}, {"sha": "433c12d174127e33c20d1bb1c4b0e1cdceda738a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -1,3 +1,9 @@\n+2013-08-30  Marek Polacek  <polacek@redhat.com>\n+\n+\t* typeck.c (cp_build_binary_op): Add division by zero and shift\n+\tinstrumentation.\n+\t* error.c (dump_expr): Special-case ubsan builtins.\n+\n 2013-08-30  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/51424"}, {"sha": "4ce1387e7ceebfb75b32bf676c032ba57be5df45", "filename": "gcc/cp/error.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pretty-print.h\"\n #include \"pointer-set.h\"\n #include \"c-family/c-objc.h\"\n+#include \"ubsan.h\"\n \n #include <new>                    // For placement-new.\n \n@@ -2007,6 +2008,12 @@ dump_expr (cxx_pretty_printer *pp, tree t, int flags)\n \t      }\n \t    skipfirst = true;\n \t  }\n+\tif (flag_sanitize & SANITIZE_UNDEFINED\n+\t    && is_ubsan_builtin_p (fn))\n+\t  {\n+\t    pp_string (cxx_pp, M_(\"<ubsan routine call>\"));\n+\t    break;\n+\t  }\n \tdump_expr (pp, fn, flags | TFF_EXPR_IN_PARENS);\n \tdump_call_expr_args (pp, t, flags, skipfirst);\n       }"}, {"sha": "b4abbc56d5e23fcf0be6c553c187b6e050cb8c7a", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 58, "deletions": 3, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"convert.h\"\n #include \"c-family/c-common.h\"\n #include \"c-family/c-objc.h\"\n+#include \"c-family/c-ubsan.h\"\n #include \"params.h\"\n \n static tree pfn_from_ptrmemfunc (tree);\n@@ -3882,6 +3883,7 @@ cp_build_binary_op (location_t location,\n   tree final_type = 0;\n \n   tree result;\n+  tree orig_type = NULL;\n \n   /* Nonzero if this is an operation like MIN or MAX which can\n      safely be computed in short if both args are promoted shorts.\n@@ -3906,6 +3908,15 @@ cp_build_binary_op (location_t location,\n   op0 = orig_op0;\n   op1 = orig_op1;\n \n+  /* Remember whether we're doing / or %.  */\n+  bool doing_div_or_mod = false;\n+\n+  /* Remember whether we're doing << or >>.  */\n+  bool doing_shift = false;\n+\n+  /* Tree holding instrumentation expression.  */\n+  tree instrument_expr = NULL;\n+\n   if (code == TRUTH_AND_EXPR || code == TRUTH_ANDIF_EXPR\n       || code == TRUTH_OR_EXPR || code == TRUTH_ORIF_EXPR\n       || code == TRUTH_XOR_EXPR)\n@@ -4086,8 +4097,12 @@ cp_build_binary_op (location_t location,\n \t{\n \t  enum tree_code tcode0 = code0, tcode1 = code1;\n \t  tree cop1 = fold_non_dependent_expr_sfinae (op1, tf_none);\n+\t  cop1 = maybe_constant_value (cop1);\n \n-\t  warn_for_div_by_zero (location, maybe_constant_value (cop1));\n+\t  if (tcode0 == INTEGER_TYPE)\n+\t    doing_div_or_mod = true;\n+\n+\t  warn_for_div_by_zero (location, cop1);\n \n \t  if (tcode0 == COMPLEX_TYPE || tcode0 == VECTOR_TYPE)\n \t    tcode0 = TREE_CODE (TREE_TYPE (TREE_TYPE (op0)));\n@@ -4125,8 +4140,11 @@ cp_build_binary_op (location_t location,\n     case FLOOR_MOD_EXPR:\n       {\n \ttree cop1 = fold_non_dependent_expr_sfinae (op1, tf_none);\n+\tcop1 = maybe_constant_value (cop1);\n \n-\twarn_for_div_by_zero (location, maybe_constant_value (cop1));\n+\tif (code0 == INTEGER_TYPE)\n+\t  doing_div_or_mod = true;\n+\twarn_for_div_by_zero (location, cop1);\n       }\n \n       if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE\n@@ -4180,6 +4198,7 @@ cp_build_binary_op (location_t location,\n \t  if (TREE_CODE (const_op1) != INTEGER_CST)\n \t    const_op1 = op1;\n \t  result_type = type0;\n+\t  doing_shift = true;\n \t  if (TREE_CODE (const_op1) == INTEGER_CST)\n \t    {\n \t      if (tree_int_cst_lt (const_op1, integer_zero_node))\n@@ -4227,6 +4246,7 @@ cp_build_binary_op (location_t location,\n \t  if (TREE_CODE (const_op1) != INTEGER_CST)\n \t    const_op1 = op1;\n \t  result_type = type0;\n+\t  doing_shift = true;\n \t  if (TREE_CODE (const_op1) == INTEGER_CST)\n \t    {\n \t      if (tree_int_cst_lt (const_op1, integer_zero_node))\n@@ -4796,8 +4816,9 @@ cp_build_binary_op (location_t location,\n \n       if (shorten && none_complex)\n \t{\n+\t  orig_type = result_type;\n \t  final_type = result_type;\n-\t  result_type = shorten_binary_op (result_type, op0, op1, \n+\t  result_type = shorten_binary_op (result_type, op0, op1,\n \t\t\t\t\t   shorten == -1);\n \t}\n \n@@ -4863,6 +4884,36 @@ cp_build_binary_op (location_t location,\n   if (build_type == NULL_TREE)\n     build_type = result_type;\n \n+  if ((flag_sanitize & SANITIZE_UNDEFINED)\n+      && !processing_template_decl\n+      && current_function_decl != 0\n+      && (doing_div_or_mod || doing_shift))\n+    {\n+      /* OP0 and/or OP1 might have side-effects.  */\n+      op0 = cp_save_expr (op0);\n+      op1 = cp_save_expr (op1);\n+      op0 = maybe_constant_value (fold_non_dependent_expr_sfinae (op0,\n+\t\t\t\t\t\t\t\t  tf_none));\n+      op1 = maybe_constant_value (fold_non_dependent_expr_sfinae (op1,\n+\t\t\t\t\t\t\t\t  tf_none));\n+      if (doing_div_or_mod)\n+\t{\n+\t  /* For diagnostics we want to use the promoted types without\n+\t     shorten_binary_op.  So convert the arguments to the\n+\t     original result_type.  */\n+\t  tree cop0 = op0;\n+\t  tree cop1 = op1;\n+\t  if (orig_type != NULL && result_type != orig_type)\n+\t    {\n+\t      cop0 = cp_convert (orig_type, op0, complain);\n+\t      cop1 = cp_convert (orig_type, op1, complain);\n+\t    }\n+\t  instrument_expr = ubsan_instrument_division (location, cop0, cop1);\n+\t}\n+      else if (doing_shift)\n+\tinstrument_expr = ubsan_instrument_shift (location, code, op0, op1);\n+    }\n+\n   result = build2 (resultcode, build_type, op0, op1);\n   result = fold_if_not_in_template (result);\n   if (final_type != 0)\n@@ -4873,6 +4924,10 @@ cp_build_binary_op (location_t location,\n       && !TREE_OVERFLOW_P (op1))\n     overflow_warning (location, result);\n \n+  if ((flag_sanitize & SANITIZE_UNDEFINED) && instrument_expr != NULL)\n+    result = fold_build2 (COMPOUND_EXPR, TREE_TYPE (result),\n+\t\t\t  instrument_expr, result);\n+\n   return result;\n }\n "}, {"sha": "2ceccdcce2be862f278e4591a80d9e2e112e0a0e", "filename": "gcc/cppbuiltin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fcppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fcppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppbuiltin.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -90,7 +90,7 @@ define_builtin_macros_for_compilation_flags (cpp_reader *pfile)\n       cpp_define_formatted (pfile, \"__PIE__=%d\", flag_pie);\n     }\n \n-  if (flag_asan)\n+  if (flag_sanitize & SANITIZE_ADDRESS)\n     cpp_define (pfile, \"__SANITIZE_ADDRESS__\");\n \n   if (optimize_size)"}, {"sha": "1365f657cac5a68153e94139371400833761be03", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -455,7 +455,7 @@ Objective-C and Objective-C++ Dialects}.\n @gccoptlist{@var{object-file-name}  -l@var{library} @gol\n -nostartfiles  -nodefaultlibs  -nostdlib -pie -rdynamic @gol\n -s  -static -static-libgcc -static-libstdc++ @gol\n--static-libasan -static-libtsan @gol\n+-static-libasan -static-libtsan -static-libubsan @gol\n -shared -shared-libgcc  -symbolic @gol\n -T @var{script}  -Wl,@var{option}  -Xlinker @var{option} @gol\n -u @var{symbol}}\n@@ -5208,6 +5208,14 @@ Memory access instructions will be instrumented to detect\n data race bugs.\n See @uref{http://code.google.com/p/data-race-test/wiki/ThreadSanitizer} for more details.\n \n+@item -fsanitize=undefined\n+Enable UndefinedBehaviorSanitizer, a fast undefined behavior detector\n+Various computations will be instrumented to detect undefined behavior\n+at runtime, e.g.@: division by zero or various overflows.\n+While @option{-ftrapv} causes traps for signed overflows to be emitted,\n+@option{-fsanitize=undefined} gives a diagnostic message.\n+This currently works only for the C family of languages.\n+\n @item -fdump-final-insns@r{[}=@var{file}@r{]}\n @opindex fdump-final-insns\n Dump the final internal representation (RTL) to @var{file}.  If the\n@@ -10160,6 +10168,15 @@ option is not used, then this links against the shared version of\n driver to link @file{libtsan} statically, without necessarily linking\n other libraries statically.\n \n+@item -static-libubsan\n+When the @option{-fsanitize=undefined} option is used to link a program,\n+the GCC driver automatically links against @option{libubsan}.  If\n+@file{libubsan} is available as a shared library, and the @option{-static}\n+option is not used, then this links against the shared version of\n+@file{libubsan}.  The @option{-static-libubsan} option directs the GCC\n+driver to link @file{libubsan} statically, without necessarily linking\n+other libraries statically.\n+\n @item -static-libstdc++\n When the @command{g++} program is used to link a C++ program, it\n normally automatically links against @option{libstdc++}.  If"}, {"sha": "45616bc74f5a7d7fcc61fbef476af4f64fb6a513", "filename": "gcc/flag-types.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -191,6 +191,19 @@ enum fp_contract_mode {\n   FP_CONTRACT_FAST = 2\n };\n \n+/* Different instrumentation modes.  */\n+enum sanitize_code {\n+  /* AddressSanitizer.  */\n+  SANITIZE_ADDRESS = 1 << 0,\n+  /* ThreadSanitizer.  */\n+  SANITIZE_THREAD = 1 << 1,\n+  /* UndefinedBehaviorSanitizer.  */\n+  SANITIZE_SHIFT = 1 << 2,\n+  SANITIZE_DIVIDE = 1 << 3,\n+  SANITIZE_UNREACHABLE = 1 << 4,\n+  SANITIZE_UNDEFINED = SANITIZE_SHIFT | SANITIZE_DIVIDE | SANITIZE_UNREACHABLE\n+};\n+\n /* flag_vtable_verify initialization levels. */\n enum vtv_priority {\n   VTV_NO_PRIORITY       = 0,  /* i.E. Do NOT do vtable verification. */"}, {"sha": "d48c4db118bf68167ab298227d1e280fa0b38f9f", "filename": "gcc/gcc.c", "status": "modified", "additions": 91, "deletions": 24, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -215,7 +215,7 @@ static inline void process_marked_switches (void);\n static const char *process_brace_body (const char *, const char *, const char *, int, int);\n static const struct spec_function *lookup_spec_function (const char *);\n static const char *eval_spec_function (const char *, const char *);\n-static const char *handle_spec_function (const char *);\n+static const char *handle_spec_function (const char *, bool *);\n static char *save_string (const char *, int);\n static void set_collect_gcc_options (void);\n static int do_spec_1 (const char *, int, const char *);\n@@ -253,6 +253,7 @@ static const char *convert_filename (const char *, int, int);\n static const char *getenv_spec_function (int, const char **);\n static const char *if_exists_spec_function (int, const char **);\n static const char *if_exists_else_spec_function (int, const char **);\n+static const char *sanitize_spec_function (int, const char **);\n static const char *replace_outfile_spec_function (int, const char **);\n static const char *remove_outfile_spec_function (int, const char **);\n static const char *version_compare_spec_function (int, const char **);\n@@ -432,6 +433,10 @@ or with constant text in a single argument.\n \t  than the OR.\n \t  If %* appears in X, all of the alternatives must be starred, and\n \t  only the first matching alternative is substituted.\n+ %{%:function(args):X}\n+\t  Call function named FUNCTION with args ARGS.  If the function\n+\t  returns non-NULL, then X is substituted, if it returns\n+\t  NULL, it isn't substituted.\n  %{S:X;   if S was given to GCC, substitutes X;\n    T:Y;   else if T was given to GCC, substitutes Y;\n     :D}   else substitutes D.  There can be as many clauses as you need.\n@@ -586,6 +591,28 @@ proper position among the other output files.  */\n #define LIBTSAN_EARLY_SPEC \"\"\n #endif\n \n+#ifndef LIBUBSAN_SPEC\n+#ifdef STATIC_LIBUBSAN_LIBS\n+#define ADD_STATIC_LIBUBSAN_LIBS \\\n+  \" %{static-libubsan:\" STATIC_LIBUBSAN_LIBS \"}\"\n+#else\n+#define ADD_STATIC_LIBUBSAN_LIBS\n+#endif\n+#ifdef LIBUBSAN_EARLY_SPEC\n+#define LIBUBSAN_SPEC ADD_STATIC_LIBUBSAN_LIBS\n+#elif defined(HAVE_LD_STATIC_DYNAMIC)\n+#define LIBUBSAN_SPEC \"%{static-libubsan:\" LD_STATIC_OPTION \\\n+\t\t     \"} -lubsan %{static-libubsan:\" LD_DYNAMIC_OPTION \"}\" \\\n+\t\t     ADD_STATIC_LIBUBSAN_LIBS\n+#else\n+#define LIBUBSAN_SPEC \"-lubsan\" ADD_STATIC_LIBUBSAN_LIBS\n+#endif\n+#endif\n+\n+#ifndef LIBUBSAN_EARLY_SPEC\n+#define LIBUBSAN_EARLY_SPEC \"\"\n+#endif\n+\n /* config.h can define LIBGCC_SPEC to override how and when libgcc.a is\n    included.  */\n #ifndef LIBGCC_SPEC\n@@ -708,18 +735,20 @@ proper position among the other output files.  */\n /* Linker command line options for -fsanitize= early on the command line.  */\n #ifndef SANITIZER_EARLY_SPEC\n #define SANITIZER_EARLY_SPEC \"\\\n-%{!nostdlib:%{!nodefaultlibs:%{fsanitize=address:\" LIBASAN_EARLY_SPEC \"} \\\n-    %{fsanitize=thread:\" LIBTSAN_EARLY_SPEC \"}}}\"\n+%{!nostdlib:%{!nodefaultlibs:%{%:sanitize(address):\" LIBASAN_EARLY_SPEC \"} \\\n+    %{%:sanitize(thread):\" LIBTSAN_EARLY_SPEC \"} \\\n+    %{%:sanitize(undefined):\" LIBUBSAN_EARLY_SPEC \"}}}\"\n #endif\n \n /* Linker command line options for -fsanitize= late on the command line.  */\n #ifndef SANITIZER_SPEC\n #define SANITIZER_SPEC \"\\\n-%{!nostdlib:%{!nodefaultlibs:%{fsanitize=address:\" LIBASAN_SPEC \"\\\n+%{!nostdlib:%{!nodefaultlibs:%{%:sanitize(address):\" LIBASAN_SPEC \"\\\n     %{static:%ecannot specify -static with -fsanitize=address}\\\n-    %{fsanitize=thread:%e-fsanitize=address is incompatible with -fsanitize=thread}}\\\n-    %{fsanitize=thread:\" LIBTSAN_SPEC \"\\\n-    %{!pie:%{!shared:%e-fsanitize=thread linking must be done with -pie or -shared}}}}}\"\n+    %{%:sanitize(thread):%e-fsanitize=address is incompatible with -fsanitize=thread}}\\\n+    %{%:sanitize(thread):\" LIBTSAN_SPEC \"\\\n+    %{!pie:%{!shared:%e-fsanitize=thread linking must be done with -pie or -shared}}}\\\n+    %{%:sanitize(undefined):\" LIBUBSAN_SPEC \"}}}\"\n #endif\n \n /*  This is the spec to use, once the code for creating the vtable\n@@ -1333,6 +1362,7 @@ static const struct spec_function static_spec_functions[] =\n   { \"getenv\",                   getenv_spec_function },\n   { \"if-exists\",\t\tif_exists_spec_function },\n   { \"if-exists-else\",\t\tif_exists_else_spec_function },\n+  { \"sanitize\",\t\t\tsanitize_spec_function },\n   { \"replace-outfile\",\t\treplace_outfile_spec_function },\n   { \"remove-outfile\",\t\tremove_outfile_spec_function },\n   { \"version-compare\",\t\tversion_compare_spec_function },\n@@ -5283,7 +5313,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t    break;\n \n \t  case ':':\n-\t    p = handle_spec_function (p);\n+\t    p = handle_spec_function (p, NULL);\n \t    if (p == 0)\n \t      return -1;\n \t    break;\n@@ -5519,10 +5549,13 @@ eval_spec_function (const char *func, const char *args)\n    ARGS is processed as a spec in a separate context and split into an\n    argument vector in the normal fashion.  The function returns a string\n    containing a spec which we then process in the caller's context, or\n-   NULL if no processing is required.  */\n+   NULL if no processing is required.\n+\n+   If RETVAL_NONNULL is not NULL, then store a bool whether function\n+   returned non-NULL.  */\n \n static const char *\n-handle_spec_function (const char *p)\n+handle_spec_function (const char *p, bool *retval_nonnull)\n {\n   char *func, *args;\n   const char *endp, *funcval;\n@@ -5568,6 +5601,8 @@ handle_spec_function (const char *p)\n   funcval = eval_spec_function (func, args);\n   if (funcval != NULL && do_spec_1 (funcval, 0, NULL) < 0)\n     p = NULL;\n+  if (retval_nonnull)\n+    *retval_nonnull = funcval != NULL;\n \n   free (func);\n   free (args);\n@@ -5711,19 +5746,28 @@ handle_braces (const char *p)\n \tp++, a_is_negated = true;\n \n       SKIP_WHITE();\n-      if (*p == '.')\n-\tp++, a_is_suffix = true;\n-      else if (*p == ',')\n-\tp++, a_is_spectype = true;\n-\n-      atom = p;\n-      while (ISIDNUM(*p) || *p == '-' || *p == '+' || *p == '='\n-\t     || *p == ',' || *p == '.' || *p == '@')\n-\tp++;\n-      end_atom = p;\n+      if (*p == '%' && p[1] == ':')\n+\t{\n+\t  atom = NULL;\n+\t  end_atom = NULL;\n+\t  p = handle_spec_function (p + 2, &a_matched);\n+\t}\n+      else\n+\t{\n+\t  if (*p == '.')\n+\t    p++, a_is_suffix = true;\n+\t  else if (*p == ',')\n+\t    p++, a_is_spectype = true;\n+\n+\t  atom = p;\n+\t  while (ISIDNUM(*p) || *p == '-' || *p == '+' || *p == '='\n+\t\t || *p == ',' || *p == '.' || *p == '@')\n+\t    p++;\n+\t  end_atom = p;\n \n-      if (*p == '*')\n-\tp++, a_is_starred = 1;\n+\t  if (*p == '*')\n+\t    p++, a_is_starred = 1;\n+\t}\n \n       SKIP_WHITE();\n       switch (*p)\n@@ -5748,7 +5792,7 @@ handle_braces (const char *p)\n \t  if (ordered_set)\n \t    goto invalid;\n \n-\t  if (atom == end_atom)\n+\t  if (atom && atom == end_atom)\n \t    {\n \t      if (!n_way_choice || disj_matched || *p == '|'\n \t\t  || a_is_negated || a_is_suffix || a_is_spectype\n@@ -5773,7 +5817,9 @@ handle_braces (const char *p)\n \t\t match.  */\n \t      if (!disj_matched && !n_way_matched)\n \t\t{\n-\t\t  if (a_is_suffix)\n+\t\t  if (atom == NULL)\n+\t\t    /* a_matched is already set by handle_spec_function.  */;\n+\t\t  else if (a_is_suffix)\n \t\t    a_matched = input_suffix_matches (atom, end_atom);\n \t\t  else if (a_is_spectype)\n \t\t    a_matched = input_spec_matches (atom, end_atom);\n@@ -8070,6 +8116,27 @@ if_exists_else_spec_function (int argc, const char **argv)\n   return argv[1];\n }\n \n+/* sanitize built-in spec function.\n+\n+   This returns non-NULL, if sanitizing address, thread or\n+   any of the undefined behavior sanitizers.  */\n+\n+static const char *\n+sanitize_spec_function (int argc, const char **argv)\n+{\n+  if (argc != 1)\n+    return NULL;\n+\n+  if (strcmp (argv[0], \"address\") == 0)\n+    return (flag_sanitize & SANITIZE_ADDRESS) ? \"\" : NULL;\n+  if (strcmp (argv[0], \"thread\") == 0)\n+    return (flag_sanitize & SANITIZE_THREAD) ? \"\" : NULL;\n+  if (strcmp (argv[0], \"undefined\") == 0)\n+    return (flag_sanitize & SANITIZE_UNDEFINED) ? \"\" : NULL;\n+\n+  return NULL;\n+}\n+\n /* replace-outfile built-in spec function.\n \n    This looks for the first argument in the outfiles array's name and"}, {"sha": "133fe0f717dd7aa27f8b17185a85225a88c8d74a", "filename": "gcc/opts.c", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -1405,6 +1405,70 @@ common_handle_option (struct gcc_options *opts,\n       opts->x_exit_after_options = true;\n       break;\n \n+    case OPT_fsanitize_:\n+      {\n+\tconst char *p = arg;\n+\twhile (*p != 0)\n+\t  {\n+\t    static const struct\n+\t    {\n+\t      const char *const name;\n+\t      unsigned int flag;\n+\t      size_t len;\n+\t    } spec[] =\n+\t    {\n+\t      { \"address\", SANITIZE_ADDRESS, sizeof \"address\" - 1 },\n+\t      { \"thread\", SANITIZE_THREAD, sizeof \"thread\" - 1 },\n+\t      { \"shift\", SANITIZE_SHIFT, sizeof \"shift\" - 1 },\n+\t      { \"integer-divide-by-zero\", SANITIZE_DIVIDE,\n+\t\tsizeof \"integer-divide-by-zero\" - 1 },\n+\t      { \"undefined\", SANITIZE_UNDEFINED, sizeof \"undefined\" - 1 },\n+\t      { \"unreachable\", SANITIZE_UNREACHABLE,\n+\t\tsizeof \"unreachable\" - 1 },\n+\t      { NULL, 0, 0 }\n+\t    };\n+\t    const char *comma;\n+\t    size_t len, i;\n+\t    bool found = false;\n+\n+\t    comma = strchr (p, ',');\n+\t    if (comma == NULL)\n+\t      len = strlen (p);\n+\t    else\n+\t      len = comma - p;\n+\t    if (len == 0)\n+\t      {\n+\t\tp = comma + 1;\n+\t\tcontinue;\n+\t      }\n+\n+\t    /* Check to see if the string matches an option class name.  */\n+\t    for (i = 0; spec[i].name != NULL; ++i)\n+\t      if (len == spec[i].len\n+\t\t  && memcmp (p, spec[i].name, len) == 0)\n+\t\t{\n+\t\t  /* Handle both -fsanitize and -fno-sanitize cases.  */\n+\t\t  if (value)\n+\t\t    flag_sanitize |= spec[i].flag;\n+\t\t  else\n+\t\t    flag_sanitize &= ~spec[i].flag;\n+\t\t  found = true;\n+\t\t  break;\n+\t\t}\n+\n+\t    if (! found)\n+\t      warning_at (loc, 0,\n+\t\t\t  \"unrecognized argument to -fsanitize= option: %q.*s\",\n+\t\t\t  (int) len, p);\n+\n+\t    if (comma == NULL)\n+\t      break;\n+\t    p = comma + 1;\n+\t  }\n+\n+\tbreak;\n+      }\n+\n     case OPT_O:\n     case OPT_Os:\n     case OPT_Ofast:"}, {"sha": "4c8a0377d8be9a10a24b92fd90cc22f71be6e0e0", "filename": "gcc/sanitizer.def", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fsanitizer.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fsanitizer.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanitizer.def?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -283,3 +283,17 @@ DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_ATOMIC_THREAD_FENCE,\n DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_ATOMIC_SIGNAL_FENCE,\n \t\t      \"__tsan_atomic_signal_fence\",\n \t\t      BT_FN_VOID_INT, ATTR_NOTHROW_LEAF_LIST)\n+\n+/* Undefined Behavior Sanitizer */\n+DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_DIVREM_OVERFLOW,\n+\t\t      \"__ubsan_handle_divrem_overflow\",\n+\t\t      BT_FN_VOID_PTR_PTR_PTR,\n+\t\t      ATTR_COLD_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_SHIFT_OUT_OF_BOUNDS,\n+\t\t      \"__ubsan_handle_shift_out_of_bounds\",\n+\t\t      BT_FN_VOID_PTR_PTR_PTR,\n+\t\t      ATTR_COLD_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_BUILTIN_UNREACHABLE,\n+\t\t      \"__ubsan_handle_builtin_unreachable\",\n+\t\t      BT_FN_VOID_PTR,\n+\t\t      ATTR_COLD_NORETURN_NOTHROW_LEAF_LIST)"}, {"sha": "4895bb8e3aae8908fafaa322baed6eb8428dda80", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -1,3 +1,34 @@\n+2013-08-30  Marek Polacek  <polacek@redhat.com>\n+\n+\t* g++.dg/ubsan/div-by-zero-1.C: New test.\n+\t* c-c++-common/ubsan/save-expr-1.c: New test.\n+\t* c-c++-common/ubsan/save-expr-2.c: New test.\n+\t* c-c++-common/ubsan/save-expr-3.c: New test.\n+\t* c-c++-common/ubsan/save-expr-4.c: New test.\n+\t* c-c++-common/ubsan/typedef-1.c: New test.\n+\t* c-c++-common/ubsan/const-char-1.c: New test.\n+\t* c-c++-common/ubsan/const-expr.c: New test.\n+\t* c-c++-common/ubsan/div-by-zero-1.c: Likewise.\n+\t* c-c++-common/ubsan/shift-1.c: Likewise.\n+\t* c-c++-common/ubsan/shift-2.c: Likewise.\n+\t* c-c++-common/ubsan/div-by-zero-2.c: Likewise.\n+\t* lib/ubsan-dg.exp: New file.\n+\t* g++.dg/dg.exp: Add ubsan tests.\n+\t* g++.dg/ubsan/ubsan.exp: New file.\n+\t* gcc.dg/ubsan/ubsan.exp: New file.\n+\t* g++.dg/ubsan/cxx11-shift-1.C: New test.\n+\t* g++.dg/ubsan/cxx11-shift-2.C: New test.\n+\t* c-c++-common/ubsan/div-by-zero-3.c: New test.\n+\t* c-c++-common/ubsan/div-by-zero-1.c: New test.\n+\t* c-c++-common/ubsan/div-by-zero-4.c: New test.\n+\t* c-c++-common/ubsan/shift-3.c: New test.\n+\t* c-c++-common/ubsan/unreachable-1.c: New test.\n+\t* c-c++-common/ubsan/shift-1.c: New test.\n+\t* c-c++-common/ubsan/shift-2.c: New test.\n+\t* c-c++-common/ubsan/div-by-zero-2.c: New test.\n+\t* gcc.dg/ubsan/c99-shift-2.c: New test.\n+\t* gcc.dg/ubsan/c99-shift-1.c: New test.\n+\n 2013-08-29  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc.dg/tree-ssa/attr-alias.c: Rename test3 to test1 to match template"}, {"sha": "6c2c3f8c3aa6d02f88f234a07cde6b3772add66d", "filename": "gcc/testsuite/c-c++-common/ubsan/const-char-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fconst-char-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fconst-char-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fconst-char-1.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fsanitize=shift\" } */\n+\n+void\n+foo (void)\n+{\n+  int y = 1 << 2;\n+  __builtin_printf (\"%d\\n\", y);\n+}"}, {"sha": "f474ec64ef5b7302c23c4a9fa9e91a82adbd29b3", "filename": "gcc/testsuite/c-c++-common/ubsan/const-expr-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fconst-expr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fconst-expr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fconst-expr-1.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fsanitize=shift -w\" } */\n+\n+enum e { A = 1 << 1, B, };\n+const int arr[] = {\n+  1 << 2,\n+  1 << 3,\n+};\n+\n+int\n+bar (int a, int b)\n+{\n+  return a >> b;\n+}\n+\n+int\n+foo (void)\n+{\n+  int i = 1;\n+  int vla[B << 3];\n+  return bar (A, (i <<= 6, i + 2));\n+}"}, {"sha": "4e2a2b92749744c7c330735967d29ddebcae45da", "filename": "gcc/testsuite/c-c++-common/ubsan/div-by-zero-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fdiv-by-zero-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fdiv-by-zero-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fdiv-by-zero-1.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=integer-divide-by-zero -Wno-div-by-zero\" } */\n+\n+int\n+main (void)\n+{\n+  volatile int a = 0;\n+  volatile long long int b = 0;\n+  volatile unsigned int c = 1;\n+\n+  a / b;\n+  0 / 0;\n+  a / 0;\n+  0 / b;\n+  2 / --c;\n+\n+  return 0;\n+}\n+\n+/* { dg-output \"division by zero(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*division by zero(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*division by zero(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*division by zero(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*division by zero(\\n|\\r\\n|\\r)\" } */"}, {"sha": "ee9673800d38908294eda16fa4da27be4dc0eac5", "filename": "gcc/testsuite/c-c++-common/ubsan/div-by-zero-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fdiv-by-zero-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fdiv-by-zero-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fdiv-by-zero-2.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=integer-divide-by-zero -Wno-div-by-zero\" } */\n+\n+int\n+main (void)\n+{\n+  volatile const unsigned long int o = 1UL;\n+  int zero = 0;\n+\n+  o / 0;\n+  1UL / 0;\n+  1UL / zero;\n+  o / zero;\n+  o / (++zero - 1);\n+\n+  return 0;\n+}\n+\n+/* { dg-output \"division by zero(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*division by zero(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*division by zero(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*division by zero(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*division by zero(\\n|\\r\\n|\\r)\" } */"}, {"sha": "719e6c986340c519d0d03eb8303050d858a605bf", "filename": "gcc/testsuite/c-c++-common/ubsan/div-by-zero-3.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fdiv-by-zero-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fdiv-by-zero-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fdiv-by-zero-3.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=integer-divide-by-zero -Wno-overflow\" } */\n+\n+#include <limits.h>\n+\n+int\n+main (void)\n+{\n+  volatile int min = INT_MIN;\n+  volatile int zero = 0;\n+\n+  INT_MIN / -1;\n+  min / -1;\n+  min / (10 * zero - (2 - 1));\n+\n+  return 0;\n+}\n+\n+/* { dg-output \"division of -2147483648 by -1 cannot be represented in type int(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*division of -2147483648 by -1 cannot be represented in type int(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*division of -2147483648 by -1 cannot be represented in type int(\\n|\\r\\n|\\r)\" } */"}, {"sha": "295f624dc34cc1aff8b438a0f2509a29f60fc3c9", "filename": "gcc/testsuite/c-c++-common/ubsan/div-by-zero-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fdiv-by-zero-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fdiv-by-zero-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fdiv-by-zero-4.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=integer-divide-by-zero -Wno-overflow\" } */\n+\n+#include <limits.h>\n+\n+int\n+main (void)\n+{\n+  /* This should not fail.  */\n+  return (unsigned int) INT_MIN / -1;\n+}"}, {"sha": "24532e807611d2a23852f07af5e04fcd9ef3b50c", "filename": "gcc/testsuite/c-c++-common/ubsan/save-expr-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fsave-expr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fsave-expr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fsave-expr-1.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fsanitize=shift -Wall -Werror -O\" } */\n+\n+static int x;\n+int\n+main (void)\n+{\n+  int o = 1;\n+  int y = x << o;\n+  return y;\n+}"}, {"sha": "14ac17def9ce962f8ed2daa5936b7ad08e64b434", "filename": "gcc/testsuite/c-c++-common/ubsan/save-expr-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fsave-expr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fsave-expr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fsave-expr-2.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fsanitize=shift -Wall -Werror -O\" } */\n+\n+int\n+foo (int i, unsigned int u)\n+{\n+  return u / i;\n+}\n+\n+int\n+bar (int i, unsigned int u)\n+{\n+  return u % i;\n+}"}, {"sha": "dd2903bd68229d666a85ef8c8ceb758f8c900ff3", "filename": "gcc/testsuite/c-c++-common/ubsan/save-expr-3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fsave-expr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fsave-expr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fsave-expr-3.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fsanitize=shift -Wall -Werror -O\" } */\n+\n+int x;\n+\n+int\n+foo (int i, int u)\n+{\n+  return (i << u) << x;\n+}\n+\n+int\n+bar (int i, int u)\n+{\n+  return (i >> u) >> x;\n+}"}, {"sha": "aa34a70ede70dd7e895cc3061bbe798a990460b1", "filename": "gcc/testsuite/c-c++-common/ubsan/save-expr-4.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fsave-expr-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fsave-expr-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fsave-expr-4.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fsanitize=shift -Wall -Werror -O\" } */\n+\n+int x;\n+\n+int\n+foo (int i, unsigned int u)\n+{\n+  return (i % u) << (x / u);\n+}\n+\n+int\n+bar (int i, unsigned int u)\n+{\n+  return (((x % u) << (u / i)) >> x);\n+}"}, {"sha": "48cf3cd7bff037766a3917512235e39aa1179389", "filename": "gcc/testsuite/c-c++-common/ubsan/shift-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fshift-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fshift-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fshift-1.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=shift -w\" } */\n+\n+typedef const unsigned long long int CULLI;\n+typedef volatile int VI;\n+struct s { signed long int a; };\n+\n+int\n+main (void)\n+{\n+  int a = 1;\n+  struct s s = { .a = 400 };\n+  CULLI culli = 42;\n+  VI vi = 370;\n+  volatile int shiftcount = 153;\n+\n+  a <<= 152;\n+  1 << shiftcount;\n+  1 << 154;\n+  culli << 524;\n+  1 << vi++;\n+  (long) 1 << (s.a + 2);\n+\n+  return 0;\n+}\n+/* { dg-output \"shift exponent 152 is too large for \\[^\\n\\r]*-bit type int(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*shift exponent 153 is too large for \\[^\\n\\r]*-bit type int(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*shift exponent 154 is too large for \\[^\\n\\r]*-bit type int(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*shift exponent 524 is too large for \\[^\\n\\r]*-bit type long long unsigned int(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*shift exponent 370 is too large for \\[^\\n\\r]*-bit type int(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*shift exponent 402 is too large for \\[^\\n\\r]*-bit type long int(\\n|\\r\\n|\\r)\" } */"}, {"sha": "68a7d136f43a09e22b4f49a99359076021fc3433", "filename": "gcc/testsuite/c-c++-common/ubsan/shift-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fshift-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fshift-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fshift-2.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=shift -w\" } */\n+\n+int\n+main (void)\n+{\n+  int a = 1;\n+  volatile int b = -5;\n+  long long int c = -6;\n+\n+  a << -3;\n+  1 << -4;\n+  1 << b;\n+  a << c;\n+  a << (b + c);\n+\n+  return 0;\n+}\n+/* { dg-output \"shift exponent -3 is negative(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*shift exponent -4 is negative(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*shift exponent -5 is negative(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*shift exponent -6 is negative(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*shift exponent -11 is negative(\\n|\\r\\n|\\r)\" } */"}, {"sha": "c639d171184977c0e5c9d32cf65b9d01e617d0d6", "filename": "gcc/testsuite/c-c++-common/ubsan/shift-3.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fshift-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fshift-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fshift-3.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=shift -w\" } */\n+\n+int\n+main (void)\n+{\n+  unsigned int a = 1;\n+  a <<= 31;\n+  a <<= 1;\n+  return 0;\n+}"}, {"sha": "8dcf451c3484cedec49f1db54637feb80fa8d397", "filename": "gcc/testsuite/c-c++-common/ubsan/typedef-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ftypedef-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ftypedef-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ftypedef-1.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fsanitize=undefined\" } */\n+\n+typedef int V;\n+int\n+foo (void)\n+{\n+  V v = 9;\n+  int a = 3;\n+  v += v % a;\n+  return v / 3;\n+}"}, {"sha": "336240c96cba6cb614911bf4ab65bb80160a5173", "filename": "gcc/testsuite/c-c++-common/ubsan/unreachable-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Funreachable-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Funreachable-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Funreachable-1.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=unreachable\" } */\n+/* { dg-shouldfail \"ubsan\" } */\n+\n+int\n+main (void)\n+{\n+  __builtin_unreachable ();\n+}\n+ /* { dg-output \"execution reached a __builtin_unreachable\\\\(\\\\) call\" } */"}, {"sha": "0528538cee7c0c5194351629375660279d7391af", "filename": "gcc/testsuite/g++.dg/dg.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -52,6 +52,7 @@ set tests [prune $tests $srcdir/$subdir/tm/*]\n set tests [prune $tests $srcdir/$subdir/guality/*]\n set tests [prune $tests $srcdir/$subdir/simulate-thread/*]\n set tests [prune $tests $srcdir/$subdir/asan/*]\n+set tests [prune $tests $srcdir/$subdir/ubsan/*]\n \n # Main loop.\n g++-dg-runtest $tests $DEFAULT_CXXFLAGS"}, {"sha": "a5c0e330ab3410574b6e906fd4681a16eaada0b1", "filename": "gcc/testsuite/g++.dg/ubsan/cxx11-shift-1.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fcxx11-shift-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fcxx11-shift-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fcxx11-shift-1.C?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=shift -w -std=c++11\" } */\n+\n+int\n+main (void)\n+{\n+  int a = 1;\n+  a <<= 31;\n+}"}, {"sha": "fbc16dfd3d8d1f27c5a128e1c4db6c7fe281d035", "filename": "gcc/testsuite/g++.dg/ubsan/cxx11-shift-2.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fcxx11-shift-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fcxx11-shift-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fcxx11-shift-2.C?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=shift -w -std=c++11\" } */\n+\n+int\n+main (void)\n+{\n+  int a = -42;\n+  a <<= 1;\n+}\n+/* { dg-output \"left shift of negative value -42\" } */"}, {"sha": "d7d2c8f1565d571a4bf43c98cd83cfdc939f4319", "filename": "gcc/testsuite/g++.dg/ubsan/div-by-zero-1.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fdiv-by-zero-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fdiv-by-zero-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fdiv-by-zero-1.C?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fsanitize=shift -w\" } */\n+\n+void\n+foo (int i)\n+{\n+  switch (i)\n+  case 0 * (1 / 0): /* { dg-error \"is not a constant expression\" } */\n+    ;\n+}"}, {"sha": "b2651a36a4374df6dd7937b4057ffbed0651d9da", "filename": "gcc/testsuite/g++.dg/ubsan/ubsan.exp", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fubsan.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fubsan.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fubsan.exp?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,34 @@\n+# Copyright (C) 2013 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Load support procs.\n+load_lib g++-dg.exp\n+load_lib ubsan-dg.exp\n+\n+# Initialize `dg'.\n+dg-init\n+if [ubsan_init] {\n+\n+# Main loop.\n+gcc-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.C $srcdir/c-c++-common/ubsan/*.c]] \"\"\n+\n+}\n+\n+# All done.\n+ubsan_finish\n+dg-finish"}, {"sha": "ff6776bf3c1fb3f14ae6e37be0f3a8f4c0b516cd", "filename": "gcc/testsuite/gcc.dg/ubsan/c99-shift-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fc99-shift-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fc99-shift-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fc99-shift-1.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=shift -w -std=c99\" } */\n+\n+int\n+main (void)\n+{\n+  int a = -42;\n+  a << 1;\n+}\n+/* { dg-output \"left shift of negative value -42\" } */"}, {"sha": "7dceb585739ae0833052484eda886c248d7d31ca", "filename": "gcc/testsuite/gcc.dg/ubsan/c99-shift-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fc99-shift-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fc99-shift-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fc99-shift-2.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=shift -w -std=c99\" } */\n+\n+int\n+main (void)\n+{\n+  int a = 1;\n+  a <<= 31;\n+}\n+/* { dg-output \"left shift of 1 by 31 places cannot be represented in type int\" } */"}, {"sha": "d077d1da8e26c504e27e2e594900dd9e7f6b6425", "filename": "gcc/testsuite/gcc.dg/ubsan/ubsan.exp", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fubsan.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fubsan.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fubsan.exp?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,36 @@\n+# Copyright (C) 2013 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+load_lib ubsan-dg.exp\n+\n+# Initialize `dg'.\n+dg-init\n+if [ubsan_init] {\n+\n+# Main loop.\n+gcc-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.c $srcdir/c-c++-common/ubsan/*.c]] \"\"\n+\n+}\n+\n+# All done.\n+ubsan_finish\n+dg-finish"}, {"sha": "4ec5fdfad67150b6689c01612a20e411dff734bc", "filename": "gcc/testsuite/lib/ubsan-dg.exp", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Flib%2Fubsan-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftestsuite%2Flib%2Fubsan-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fubsan-dg.exp?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,104 @@\n+# Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+#\n+# ubsan_link_flags -- compute library path and flags to find libubsan.\n+# (originally from g++.exp)\n+#\n+\n+proc ubsan_link_flags { paths } {\n+    global srcdir\n+    global ld_library_path\n+    global shlib_ext\n+\n+    set gccpath ${paths}\n+    set flags \"\"\n+\n+    set shlib_ext [get_shlib_extension]\n+\n+    if { $gccpath != \"\" } {\n+      if { [file exists \"${gccpath}/libsanitizer/ubsan/.libs/libubsan.a\"]\n+\t   || [file exists \"${gccpath}/libsanitizer/ubsan/.libs/libubsan.${shlib_ext}\"] } {\n+\t  append flags \" -B${gccpath}/libsanitizer/ubsan/ \"\n+\t  append flags \" -L${gccpath}/libsanitizer/ubsan/.libs\"\n+\t  append ld_library_path \":${gccpath}/libsanitizer/ubsan/.libs\"\n+      }\n+    } else {\n+      global tool_root_dir\n+\n+      set libubsan [lookfor_file ${tool_root_dir} libubsan]\n+      if { $libubsan != \"\" } {\n+\t  append flags \"-L${libubsan} \"\n+\t  append ld_library_path \":${libubsan}\"\n+      }\n+    }\n+\n+    set_ld_library_path_env_vars\n+\n+    return \"$flags\"\n+}\n+\n+#\n+# ubsan_init -- called at the start of each subdir of tests\n+#\n+\n+proc ubsan_init { args } {\n+    global TEST_ALWAYS_FLAGS\n+    global ALWAYS_CXXFLAGS\n+    global TOOL_OPTIONS\n+    global ubsan_saved_TEST_ALWAYS_FLAGS\n+\n+    set link_flags \"\"\n+    if ![is_remote host] {\n+\tif [info exists TOOL_OPTIONS] {\n+\t    set link_flags \"[ubsan_link_flags [get_multilibs ${TOOL_OPTIONS}]]\"\n+\t} else {\n+\t    set link_flags \"[ubsan_link_flags [get_multilibs]]\"\n+\t}\n+    }\n+\n+    if [info exists TEST_ALWAYS_FLAGS] {\n+\tset ubsan_saved_TEST_ALWAYS_FLAGS $TEST_ALWAYS_FLAGS\n+    }\n+    if [info exists ALWAYS_CXXFLAGS] {\n+\tset ALWAYS_CXXFLAGS [concat \"{ldflags=$link_flags}\" $ALWAYS_CXXFLAGS]\n+    } else {\n+\tif [info exists TEST_ALWAYS_FLAGS] {\n+\t    set TEST_ALWAYS_FLAGS \"$link_flags $TEST_ALWAYS_FLAGS\"\n+\t} else {\n+\t    set TEST_ALWAYS_FLAGS \"$link_flags\"\n+\t}\n+    }\n+    if { $link_flags != \"\" } {\n+\treturn 1\n+    }\n+    return 0\n+}\n+\n+#\n+# ubsan_finish -- called at the end of each subdir of tests\n+#\n+\n+proc ubsan_finish { args } {\n+    global TEST_ALWAYS_FLAGS\n+    global ubsan_saved_TEST_ALWAYS_FLAGS\n+\n+    if [info exists ubsan_saved_TEST_ALWAYS_FLAGS] {\n+\tset TEST_ALWAYS_FLAGS $ubsan_saved_TEST_ALWAYS_FLAGS\n+    } else {\n+\tunset TEST_ALWAYS_FLAGS\n+    }\n+}"}, {"sha": "4d12bc9246fe92e83e666b2bc40044513dfe71ba", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -573,10 +573,10 @@ compile_file (void)\n \tmudflap_finish_file ();\n \n       /* File-scope initialization for AddressSanitizer.  */\n-      if (flag_asan)\n+      if (flag_sanitize & SANITIZE_ADDRESS)\n         asan_finish_file ();\n \n-      if (flag_tsan)\n+      if (flag_sanitize & SANITIZE_THREAD)\n \ttsan_finish_file ();\n \n       output_shared_constant_pool ();\n@@ -1542,12 +1542,12 @@ process_options (void)\n     warn_stack_protect = 0;\n \n   /* Address Sanitizer needs porting to each target architecture.  */\n-  if (flag_asan\n+  if ((flag_sanitize & SANITIZE_ADDRESS)\n       && (targetm.asan_shadow_offset == NULL\n \t  || !FRAME_GROWS_DOWNWARD))\n     {\n       warning (0, \"-fsanitize=address not supported for this target\");\n-      flag_asan = 0;\n+      flag_sanitize &= ~SANITIZE_ADDRESS;\n     }\n \n   /* Enable -Werror=coverage-mismatch when -Werror and -Wno-error"}, {"sha": "b469b97c8672622399e69320bf447af80f9ceaea", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -9677,6 +9677,8 @@ build_common_tree_nodes (bool signed_char, bool short_double)\n     = build_pointer_type (build_type_variant (void_type_node, 1, 0));\n   fileptr_type_node = ptr_type_node;\n \n+  pointer_sized_int_node = build_nonstandard_integer_type (POINTER_SIZE, 1);\n+\n   float_type_node = make_node (REAL_TYPE);\n   TYPE_PRECISION (float_type_node) = FLOAT_TYPE_SIZE;\n   layout_type (float_type_node);"}, {"sha": "83edabaeff901c6cd36eafb16017f14a23e2bd0f", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -4288,6 +4288,7 @@ enum tree_index\n   TI_VA_LIST_FPR_COUNTER_FIELD,\n   TI_BOOLEAN_TYPE,\n   TI_FILEPTR_TYPE,\n+  TI_POINTER_SIZED_TYPE,\n \n   TI_DFLOAT32_TYPE,\n   TI_DFLOAT64_TYPE,\n@@ -4444,6 +4445,7 @@ extern GTY(()) tree global_trees[TI_MAX];\n #define va_list_fpr_counter_field\tglobal_trees[TI_VA_LIST_FPR_COUNTER_FIELD]\n /* The C type `FILE *'.  */\n #define fileptr_type_node\t\tglobal_trees[TI_FILEPTR_TYPE]\n+#define pointer_sized_int_node\t\tglobal_trees[TI_POINTER_SIZED_TYPE]\n \n #define boolean_type_node\t\tglobal_trees[TI_BOOLEAN_TYPE]\n #define boolean_false_node\t\tglobal_trees[TI_BOOLEAN_FALSE]"}, {"sha": "fb91129eb674368adc74b9ad746efdc75fe40d6d", "filename": "gcc/tsan.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Ftsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftsan.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -713,7 +713,7 @@ tsan_pass (void)\n static bool\n tsan_gate (void)\n {\n-  return flag_tsan != 0;\n+  return (flag_sanitize & SANITIZE_THREAD) != 0;\n }\n \n /* Inserts __tsan_init () into the list of CTORs.  */\n@@ -775,7 +775,7 @@ make_pass_tsan (gcc::context *ctxt)\n static bool\n tsan_gate_O0 (void)\n {\n-  return flag_tsan != 0 && !optimize;\n+  return (flag_sanitize & SANITIZE_THREAD) != 0 && !optimize;\n }\n \n namespace {"}, {"sha": "e4bdd2a3208c6b17291dbdc2f2a0d00e8c7fc3de", "filename": "gcc/ubsan.c", "status": "added", "additions": 416, "deletions": 0, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,416 @@\n+/* UndefinedBehaviorSanitizer, undefined behavior detector.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+   Contributed by Marek Polacek <polacek@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"cgraph.h\"\n+#include \"gimple.h\"\n+#include \"hashtab.h\"\n+#include \"pointer-set.h\"\n+#include \"output.h\"\n+#include \"toplev.h\"\n+#include \"ubsan.h\"\n+#include \"c-family/c-common.h\"\n+\n+/* Map from a tree to a VAR_DECL tree.  */\n+\n+struct GTY(()) tree_type_map {\n+  struct tree_map_base type;\n+  tree decl;\n+};\n+\n+#define tree_type_map_eq tree_map_base_eq\n+#define tree_type_map_hash tree_map_base_hash\n+#define tree_type_map_marked_p tree_map_base_marked_p\n+\n+static GTY ((if_marked (\"tree_type_map_marked_p\"), param_is (struct tree_type_map)))\n+     htab_t decl_tree_for_type;\n+\n+/* Lookup a VAR_DECL for TYPE, and return it if we find one.  */\n+\n+static tree\n+decl_for_type_lookup (tree type)\n+{\n+  /* If the hash table is not initialized yet, create it now.  */\n+  if (decl_tree_for_type == NULL)\n+    {\n+      decl_tree_for_type = htab_create_ggc (10, tree_type_map_hash,\n+\t\t\t\t\t    tree_type_map_eq, 0);\n+      /* That also means we don't have to bother with the lookup.  */\n+      return NULL_TREE;\n+    }\n+\n+  struct tree_type_map *h, in;\n+  in.type.from = type;\n+\n+  h = (struct tree_type_map *)\n+      htab_find_with_hash (decl_tree_for_type, &in, TYPE_UID (type));\n+  return h ? h->decl : NULL_TREE;\n+}\n+\n+/* Insert a mapping TYPE->DECL in the VAR_DECL for type hashtable.  */\n+\n+static void\n+decl_for_type_insert (tree type, tree decl)\n+{\n+  struct tree_type_map *h;\n+  void **slot;\n+\n+  h = ggc_alloc_tree_type_map ();\n+  h->type.from = type;\n+  h->decl = decl;\n+  slot = htab_find_slot_with_hash (decl_tree_for_type, h, TYPE_UID (type),\n+                                  INSERT);\n+  *(struct tree_type_map **) slot = h;\n+}\n+\n+/* Helper routine, which encodes a value in the pointer_sized_int_node.\n+   Arguments with precision <= POINTER_SIZE are passed directly,\n+   the rest is passed by reference.  T is a value we are to encode.  */\n+\n+tree\n+ubsan_encode_value (tree t)\n+{\n+  tree type = TREE_TYPE (t);\n+  switch (TREE_CODE (type))\n+    {\n+    case INTEGER_TYPE:\n+      if (TYPE_PRECISION (type) <= POINTER_SIZE)\n+\treturn fold_build1 (NOP_EXPR, pointer_sized_int_node, t);\n+      else\n+\treturn build_fold_addr_expr (t);\n+    case REAL_TYPE:\n+      {\n+\tunsigned int bitsize = GET_MODE_BITSIZE (TYPE_MODE (type));\n+\tif (bitsize <= POINTER_SIZE)\n+\t  {\n+\t    tree itype = build_nonstandard_integer_type (bitsize, true);\n+\t    t = fold_build1 (VIEW_CONVERT_EXPR, itype, t);\n+\t    return fold_convert (pointer_sized_int_node, t);\n+\t  }\n+\telse\n+\t  {\n+\t    if (!TREE_ADDRESSABLE (t))\n+\t      {\n+\t\t/* The reason for this is that we don't want to pessimize\n+\t\t   code by making vars unnecessarily addressable.  */\n+\t\ttree var = create_tmp_var (TREE_TYPE (t), NULL);\n+\t\ttree tem = build2 (MODIFY_EXPR, void_type_node, var, t);\n+\t\tt = build_fold_addr_expr (var);\n+\t\treturn build2 (COMPOUND_EXPR, TREE_TYPE (t), tem, t);\n+\t      }\n+\t    else\n+\t      return build_fold_addr_expr (t);\n+\t  }\n+      }\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Build\n+   struct __ubsan_type_descriptor\n+   {\n+     unsigned short __typekind;\n+     unsigned short __typeinfo;\n+     char __typename[];\n+   }\n+   type.  */\n+\n+static tree\n+ubsan_type_descriptor_type (void)\n+{\n+  static const char *field_names[3]\n+    = { \"__typekind\", \"__typeinfo\", \"__typename\" };\n+  tree fields[3], ret;\n+  tree itype = build_range_type (sizetype, size_zero_node, NULL_TREE);\n+  tree flex_arr_type = build_array_type (char_type_node, itype);\n+\n+  ret = make_node (RECORD_TYPE);\n+  for (int i = 0; i < 3; i++)\n+    {\n+      fields[i] = build_decl (UNKNOWN_LOCATION, FIELD_DECL,\n+\t\t\t      get_identifier (field_names[i]),\n+\t\t\t      (i == 2) ? flex_arr_type\n+\t\t\t      : short_unsigned_type_node);\n+      DECL_CONTEXT (fields[i]) = ret;\n+      if (i)\n+\tDECL_CHAIN (fields[i - 1]) = fields[i];\n+    }\n+  TYPE_FIELDS (ret) = fields[0];\n+  TYPE_NAME (ret) = get_identifier (\"__ubsan_type_descriptor\");\n+  layout_type (ret);\n+  return ret;\n+}\n+\n+/* Build\n+   struct __ubsan_source_location\n+   {\n+     const char *__filename;\n+     unsigned int __line;\n+     unsigned int __column;\n+   }\n+   type.  */\n+\n+static tree\n+ubsan_source_location_type (void)\n+{\n+  static const char *field_names[3]\n+    = { \"__filename\", \"__line\", \"__column\" };\n+  tree fields[3], ret;\n+  tree const_char_type = build_qualified_type (char_type_node,\n+\t\t\t\t\t       TYPE_QUAL_CONST);\n+\n+  ret = make_node (RECORD_TYPE);\n+  for (int i = 0; i < 3; i++)\n+    {\n+      fields[i] = build_decl (UNKNOWN_LOCATION, FIELD_DECL,\n+\t\t\t      get_identifier (field_names[i]),\n+\t\t\t      (i == 0) ? build_pointer_type (const_char_type)\n+\t\t\t      : unsigned_type_node);\n+      DECL_CONTEXT (fields[i]) = ret;\n+      if (i)\n+\tDECL_CHAIN (fields[i - 1]) = fields[i];\n+    }\n+  TYPE_FIELDS (ret) = fields[0];\n+  TYPE_NAME (ret) = get_identifier (\"__ubsan_source_location\");\n+  layout_type (ret);\n+  return ret;\n+}\n+\n+/* Helper routine that returns a CONSTRUCTOR of __ubsan_source_location\n+   type with its fields filled from a location_t LOC.  */\n+\n+static tree\n+ubsan_source_location (location_t loc)\n+{\n+  expanded_location xloc;\n+  tree type = ubsan_source_location_type ();\n+\n+  xloc = expand_location (loc);\n+\n+  /* Fill in the values from LOC.  */\n+  size_t len = strlen (xloc.file);\n+  tree str = build_string (len + 1, xloc.file);\n+  TREE_TYPE (str) = build_array_type (char_type_node,\n+\t\t\t\t      build_index_type (size_int (len)));\n+  TREE_READONLY (str) = 1;\n+  TREE_STATIC (str) = 1;\n+  str = build_fold_addr_expr_loc (loc, str);\n+  tree ctor = build_constructor_va (type, 3, NULL_TREE, str, NULL_TREE,\n+\t\t\t\t    build_int_cst (unsigned_type_node,\n+\t\t\t\t\t\t   xloc.line), NULL_TREE,\n+\t\t\t\t    build_int_cst (unsigned_type_node,\n+\t\t\t\t\t\t   xloc.column));\n+  TREE_CONSTANT (ctor) = 1;\n+  TREE_STATIC (ctor) = 1;\n+\n+  return ctor;\n+}\n+\n+/* This routine returns a magic number for TYPE.  */\n+\n+static unsigned short\n+get_ubsan_type_info_for_type (tree type)\n+{\n+  int prec = exact_log2 (TYPE_PRECISION (type));\n+  if (prec == -1)\n+    error (\"unexpected size of type %qT\", type);\n+\n+  return (prec << 1) | !TYPE_UNSIGNED (type);\n+}\n+\n+/* Helper routine that returns ADDR_EXPR of a VAR_DECL of a type\n+   descriptor.  It first looks into the pointer map; if not found,\n+   create the VAR_DECL, put it into the pointer map and return the\n+   ADDR_EXPR of it.  TYPE describes a particular type.  */\n+\n+tree\n+ubsan_type_descriptor (tree type)\n+{\n+  /* See through any typedefs.  */\n+  type = TYPE_MAIN_VARIANT (type);\n+\n+  tree decl = decl_for_type_lookup (type);\n+  if (decl != NULL_TREE)\n+    return decl;\n+\n+  tree dtype = ubsan_type_descriptor_type ();\n+  const char *tname;\n+  unsigned short tkind, tinfo;\n+\n+  /* At least for INTEGER_TYPE/REAL_TYPE/COMPLEX_TYPE, this should work.\n+     ??? For e.g. type_unsigned_for (type), the TYPE_NAME would be NULL.  */\n+  if (TYPE_NAME (type) != NULL)\n+    tname = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n+  else\n+    tname = \"<unknown>\";\n+  if (TREE_CODE (type) == INTEGER_TYPE)\n+    {\n+      /* For INTEGER_TYPE, this is 0x0000.  */\n+      tkind = 0x000;\n+      tinfo = get_ubsan_type_info_for_type (type);\n+    }\n+  else if (TREE_CODE (type) == REAL_TYPE)\n+    /* We don't have float support yet.  */\n+    gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n+\n+  /* Create a new VAR_DECL of type descriptor.  */\n+  char tmp_name[32];\n+  static unsigned int type_var_id_num;\n+  ASM_GENERATE_INTERNAL_LABEL (tmp_name, \"Lubsan_type\", type_var_id_num++);\n+  decl = build_decl (UNKNOWN_LOCATION, VAR_DECL, get_identifier (tmp_name),\n+\t\t\t  dtype);\n+  TREE_STATIC (decl) = 1;\n+  TREE_PUBLIC (decl) = 0;\n+  DECL_ARTIFICIAL (decl) = 1;\n+  DECL_IGNORED_P (decl) = 1;\n+  DECL_EXTERNAL (decl) = 0;\n+\n+  size_t len = strlen (tname);\n+  tree str = build_string (len + 1, tname);\n+  TREE_TYPE (str) = build_array_type (char_type_node,\n+\t\t\t\t      build_index_type (size_int (len)));\n+  TREE_READONLY (str) = 1;\n+  TREE_STATIC (str) = 1;\n+  tree ctor = build_constructor_va (dtype, 3, NULL_TREE,\n+\t\t\t\t    build_int_cst (short_unsigned_type_node,\n+\t\t\t\t\t\t   tkind), NULL_TREE,\n+\t\t\t\t    build_int_cst (short_unsigned_type_node,\n+\t\t\t\t\t\t   tinfo), NULL_TREE, str);\n+  TREE_CONSTANT (ctor) = 1;\n+  TREE_STATIC (ctor) = 1;\n+  DECL_INITIAL (decl) = ctor;\n+  rest_of_decl_compilation (decl, 1, 0);\n+\n+  /* Save the address of the VAR_DECL into the pointer map.  */\n+  decl = build_fold_addr_expr (decl);\n+  decl_for_type_insert (type, decl);\n+\n+  return decl;\n+}\n+\n+/* Create a structure for the ubsan library.  NAME is a name of the new\n+   structure.  The arguments in ... are of __ubsan_type_descriptor type\n+   and there are at most two of them.  */\n+\n+tree\n+ubsan_create_data (const char *name, location_t loc, ...)\n+{\n+  va_list args;\n+  tree ret, t;\n+  tree fields[3];\n+  vec<tree, va_gc> *saved_args = NULL;\n+  size_t i = 0;\n+\n+  /* Firstly, create a pointer to type descriptor type.  */\n+  tree td_type = ubsan_type_descriptor_type ();\n+  TYPE_READONLY (td_type) = 1;\n+  td_type = build_pointer_type (td_type);\n+\n+  /* Create the structure type.  */\n+  ret = make_node (RECORD_TYPE);\n+  if (loc != UNKNOWN_LOCATION)\n+    {\n+      fields[i] = build_decl (UNKNOWN_LOCATION, FIELD_DECL, NULL_TREE,\n+\t\t\t      ubsan_source_location_type ());\n+      DECL_CONTEXT (fields[i]) = ret;\n+      i++;\n+    }\n+\n+  va_start (args, loc);\n+  for (t = va_arg (args, tree); t != NULL_TREE;\n+       i++, t = va_arg (args, tree))\n+    {\n+      gcc_checking_assert (i < 3);\n+      /* Save the tree argument for later use.  */\n+      vec_safe_push (saved_args, t);\n+      fields[i] = build_decl (UNKNOWN_LOCATION, FIELD_DECL, NULL_TREE,\n+\t\t\t      td_type);\n+      DECL_CONTEXT (fields[i]) = ret;\n+      if (i)\n+\tDECL_CHAIN (fields[i - 1]) = fields[i];\n+    }\n+  TYPE_FIELDS (ret) = fields[0];\n+  TYPE_NAME (ret) = get_identifier (name);\n+  layout_type (ret);\n+  va_end (args);\n+\n+  /* Now, fill in the type.  */\n+  char tmp_name[32];\n+  static unsigned int ubsan_var_id_num;\n+  ASM_GENERATE_INTERNAL_LABEL (tmp_name, \"Lubsan_data\", ubsan_var_id_num++);\n+  tree var = build_decl (UNKNOWN_LOCATION, VAR_DECL, get_identifier (tmp_name),\n+\t\t\t ret);\n+  TREE_STATIC (var) = 1;\n+  TREE_PUBLIC (var) = 0;\n+  DECL_ARTIFICIAL (var) = 1;\n+  DECL_IGNORED_P (var) = 1;\n+  DECL_EXTERNAL (var) = 0;\n+\n+  vec<constructor_elt, va_gc> *v;\n+  vec_alloc (v, i);\n+  tree ctor = build_constructor (ret, v);\n+\n+  /* If desirable, set the __ubsan_source_location element.  */\n+  if (loc != UNKNOWN_LOCATION)\n+    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, ubsan_source_location (loc));\n+\n+  size_t nelts = vec_safe_length (saved_args);\n+  for (i = 0; i < nelts; i++)\n+    {\n+      t = (*saved_args)[i];\n+      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, t);\n+    }\n+\n+  TREE_CONSTANT (ctor) = 1;\n+  TREE_STATIC (ctor) = 1;\n+  DECL_INITIAL (var) = ctor;\n+  rest_of_decl_compilation (var, 1, 0);\n+\n+  return var;\n+}\n+\n+/* Instrument the __builtin_unreachable call.  We just call the libubsan\n+   routine instead.  */\n+\n+tree\n+ubsan_instrument_unreachable (location_t loc)\n+{\n+  tree data = ubsan_create_data (\"__ubsan_unreachable_data\", loc, NULL_TREE);\n+  tree t = builtin_decl_explicit (BUILT_IN_UBSAN_HANDLE_BUILTIN_UNREACHABLE);\n+  return build_call_expr_loc (loc, t, 1, build_fold_addr_expr_loc (loc, data));\n+}\n+\n+/* Return true if T is a call to a libubsan routine.  */\n+\n+bool\n+is_ubsan_builtin_p (tree t)\n+{\n+  gcc_checking_assert (TREE_CODE (t) == FUNCTION_DECL);\n+  return strncmp (IDENTIFIER_POINTER (DECL_NAME (t)),\n+\t\t  \"__builtin___ubsan_\", 18) == 0;\n+}\n+\n+#include \"gt-ubsan.h\""}, {"sha": "3553a6cfbc45f3f7057d576dc81c97b899d9b930", "filename": "gcc/ubsan.h", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fubsan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fubsan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.h?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,31 @@\n+/* UndefinedBehaviorSanitizer, undefined behavior detector.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+   Contributed by Marek Polacek <polacek@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_UBSAN_H\n+#define GCC_UBSAN_H\n+\n+extern tree ubsan_instrument_unreachable (location_t);\n+extern tree ubsan_create_data (const char *, location_t, ...);\n+extern tree ubsan_type_descriptor (tree);\n+extern tree ubsan_encode_value (tree);\n+extern bool is_ubsan_builtin_p (tree);\n+\n+#endif  /* GCC_UBSAN_H  */\n+"}, {"sha": "0504eeb4f392a9afd46dbd4182bd3edce63826d9", "filename": "gcc/varasm.c", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -1102,7 +1102,8 @@ get_variable_section (tree decl, bool prefer_noswitch_p)\n       && bss_initializer_p (decl))\n     {\n       if (!TREE_PUBLIC (decl)\n-\t  && !(flag_asan && asan_protect_global (decl)))\n+\t  && !((flag_sanitize & SANITIZE_ADDRESS)\n+\t       && asan_protect_global (decl)))\n \treturn lcomm_section;\n       if (bss_noswitch_section)\n \treturn bss_noswitch_section;\n@@ -1904,7 +1905,7 @@ assemble_noswitch_variable (tree decl, const char *name, section *sect,\n   size = tree_low_cst (DECL_SIZE_UNIT (decl), 1);\n   rounded = size;\n \n-  if (flag_asan && asan_protect_global (decl))\n+  if ((flag_sanitize & SANITIZE_ADDRESS) && asan_protect_global (decl))\n     size += asan_red_zone_size (size);\n \n   /* Don't allocate zero bytes of common,\n@@ -2063,7 +2064,7 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n \n   align_variable (decl, dont_output_data);\n \n-  if (flag_asan\n+  if ((flag_sanitize & SANITIZE_ADDRESS)\n       && asan_protect_global (decl))\n     {\n       asan_protected = true;\n@@ -3376,7 +3377,8 @@ output_constant_def_contents (rtx symbol)\n   /* We are no longer deferring this constant.  */\n   TREE_ASM_WRITTEN (decl) = TREE_ASM_WRITTEN (exp) = 1;\n \n-  if (flag_asan && TREE_CODE (exp) == STRING_CST\n+  if ((flag_sanitize & SANITIZE_ADDRESS)\n+      && TREE_CODE (exp) == STRING_CST\n       && asan_protect_global (exp))\n     {\n       asan_protected = true;\n@@ -6291,7 +6293,8 @@ categorize_decl_for_section (const_tree decl, int reloc)\n   else if (TREE_CODE (decl) == STRING_CST)\n     {\n       if (flag_mudflap\n-\t  || (flag_asan && asan_protect_global (CONST_CAST_TREE (decl))))\n+\t  || ((flag_sanitize & SANITIZE_ADDRESS)\n+\t      && asan_protect_global (CONST_CAST_TREE (decl))))\n       /* or !flag_merge_constants */\n         return SECCAT_RODATA;\n       else\n@@ -6317,7 +6320,8 @@ categorize_decl_for_section (const_tree decl, int reloc)\n       else if (reloc & targetm.asm_out.reloc_rw_mask ())\n \tret = reloc == 1 ? SECCAT_DATA_REL_RO_LOCAL : SECCAT_DATA_REL_RO;\n       else if (reloc || flag_merge_constants < 2 || flag_mudflap\n-\t       || (flag_asan && asan_protect_global (CONST_CAST_TREE (decl))))\n+\t       || ((flag_sanitize & SANITIZE_ADDRESS)\n+\t\t   && asan_protect_global (CONST_CAST_TREE (decl))))\n \t/* C and C++ don't allow different variables to share the same\n \t   location.  -fmerge-all-constants allows even that (at the\n \t   expense of not conforming).  */\n@@ -7075,7 +7079,7 @@ place_block_symbol (rtx symbol)\n       decl = SYMBOL_REF_DECL (symbol);\n       alignment = DECL_ALIGN (decl);\n       size = get_constant_size (DECL_INITIAL (decl));\n-      if (flag_asan\n+      if ((flag_sanitize & SANITIZE_ADDRESS)\n \t  && TREE_CODE (DECL_INITIAL (decl)) == STRING_CST\n \t  && asan_protect_global (DECL_INITIAL (decl)))\n \tsize += asan_red_zone_size (size);\n@@ -7085,7 +7089,8 @@ place_block_symbol (rtx symbol)\n       decl = SYMBOL_REF_DECL (symbol);\n       alignment = get_variable_align (decl);\n       size = tree_low_cst (DECL_SIZE_UNIT (decl), 1);\n-      if (flag_asan && asan_protect_global (decl))\n+      if ((flag_sanitize & SANITIZE_ADDRESS)\n+\t  && asan_protect_global (decl))\n \t{\n \t  size += asan_red_zone_size (size);\n \t  alignment = MAX (alignment,\n@@ -7235,7 +7240,7 @@ output_object_block (struct object_block *block)\n \t\t\t\t      DECL_ALIGN (decl));\n \t  size = get_constant_size (DECL_INITIAL (decl));\n \t  offset += size;\n-\t  if (flag_asan\n+\t  if ((flag_sanitize & SANITIZE_ADDRESS)\n \t      && TREE_CODE (DECL_INITIAL (decl)) == STRING_CST\n \t      && asan_protect_global (DECL_INITIAL (decl)))\n \t    {\n@@ -7251,7 +7256,8 @@ output_object_block (struct object_block *block)\n \t  assemble_variable_contents (decl, XSTR (symbol, 0), false);\n \t  size = tree_low_cst (DECL_SIZE_UNIT (decl), 1);\n \t  offset += size;\n-\t  if (flag_asan && asan_protect_global (decl))\n+\t  if ((flag_sanitize & SANITIZE_ADDRESS)\n+\t      && asan_protect_global (decl))\n \t    {\n \t      size = asan_red_zone_size (size);\n \t      assemble_zeros (size);"}, {"sha": "ffef18b29d9c618cb2f894646b874f5ed4ebcc06", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -1,3 +1,13 @@\n+2013-08-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* Makefile.am (SUBDIRS): Add ubsan.\n+\t* configure.ac (AC_CONFIG_FILES): Add ubsan/Makefile.\n+\t* merge.sh: Merge ubsan.\n+\t* sanitizer_common/sanitizer_report_decorator.h: Partial merge from trunk.\n+\t* sanitizer_common/sanitizer_printf.cc: Likewise.\n+\t* sanitizer_common/sanitizer_common.h: Likewise.\n+\t* ubsan: New directory. Import ubsan runtime from llvm.\n+\n 2013-06-03  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \t* sanitizer_common/sanitizer_linux.cc (MemoryMappingLayout::Next):"}, {"sha": "739c33babbeb76b772a120413b01e48cda1d66f6", "filename": "libsanitizer/Makefile.am", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMakefile.am?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -1,13 +1,13 @@\n ACLOCAL_AMFLAGS = -I .. -I ../config\n \n if TSAN_SUPPORTED\n-SUBDIRS = interception sanitizer_common asan tsan \n+SUBDIRS = interception sanitizer_common asan tsan ubsan\n else\n-SUBDIRS = interception sanitizer_common asan \n+SUBDIRS = interception sanitizer_common asan ubsan\n endif\n \n if USING_MAC_INTERPOSE\n-SUBDIRS = sanitizer_common asan\n+SUBDIRS = sanitizer_common asan ubsan\n endif\n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS"}, {"sha": "286cea611380f20fceb60061859dfcae4440a3c3", "filename": "libsanitizer/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMakefile.in?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -76,7 +76,7 @@ AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \\\n \t$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS\n ETAGS = etags\n CTAGS = ctags\n-DIST_SUBDIRS = interception sanitizer_common asan tsan\n+DIST_SUBDIRS = interception sanitizer_common asan ubsan tsan\n ACLOCAL = @ACLOCAL@\n AMTAR = @AMTAR@\n AR = @AR@\n@@ -209,9 +209,9 @@ top_build_prefix = @top_build_prefix@\n top_builddir = @top_builddir@\n top_srcdir = @top_srcdir@\n ACLOCAL_AMFLAGS = -I .. -I ../config\n-@TSAN_SUPPORTED_FALSE@SUBDIRS = interception sanitizer_common asan \n-@TSAN_SUPPORTED_TRUE@SUBDIRS = interception sanitizer_common asan tsan \n-@USING_MAC_INTERPOSE_TRUE@SUBDIRS = sanitizer_common asan\n+@TSAN_SUPPORTED_FALSE@SUBDIRS = interception sanitizer_common asan ubsan\n+@TSAN_SUPPORTED_TRUE@SUBDIRS = interception sanitizer_common asan tsan ubsan\n+@USING_MAC_INTERPOSE_TRUE@SUBDIRS = sanitizer_common asan ubsan\n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n # values defined in terms of make variables, as is the case for CC and"}, {"sha": "2cad869f458389c68a27a60ead7f172442a90d2b", "filename": "libsanitizer/configure", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfigure?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -14543,7 +14543,7 @@ fi\n ac_config_files=\"$ac_config_files Makefile\"\n \n \n-ac_config_files=\"$ac_config_files interception/Makefile sanitizer_common/Makefile asan/Makefile\"\n+ac_config_files=\"$ac_config_files interception/Makefile sanitizer_common/Makefile asan/Makefile ubsan/Makefile\"\n \n \n if test \"x$TSAN_SUPPORTED\" = \"xyes\"; then\n@@ -15674,6 +15674,7 @@ do\n     \"interception/Makefile\") CONFIG_FILES=\"$CONFIG_FILES interception/Makefile\" ;;\n     \"sanitizer_common/Makefile\") CONFIG_FILES=\"$CONFIG_FILES sanitizer_common/Makefile\" ;;\n     \"asan/Makefile\") CONFIG_FILES=\"$CONFIG_FILES asan/Makefile\" ;;\n+    \"ubsan/Makefile\") CONFIG_FILES=\"$CONFIG_FILES ubsan/Makefile\" ;;\n     \"tsan/Makefile\") CONFIG_FILES=\"$CONFIG_FILES tsan/Makefile\" ;;\n \n   *) as_fn_error \"invalid argument: \\`$ac_config_target'\" \"$LINENO\" 5;;\n@@ -17030,6 +17031,17 @@ _EOF\n  ;;\n     \"asan/Makefile\":F) cat > vpsed$$ << \\_EOF\n s!`test -f '$<' || echo '$(srcdir)/'`!!\n+_EOF\n+   sed -f vpsed$$ $ac_file > tmp$$\n+   mv tmp$$ $ac_file\n+   rm vpsed$$\n+   echo 'MULTISUBDIR =' >> $ac_file\n+   ml_norecursion=yes\n+   . ${multi_basedir}/config-ml.in\n+   { ml_norecursion=; unset ml_norecursion;}\n+ ;;\n+    \"ubsan/Makefile\":F) cat > vpsed$$ << \\_EOF\n+s!`test -f '$<' || echo '$(srcdir)/'`!!\n _EOF\n    sed -f vpsed$$ $ac_file > tmp$$\n    mv tmp$$ $ac_file"}, {"sha": "5919da613045bdc3f717ae6f19455a677ceb31c7", "filename": "libsanitizer/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfigure.ac?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -89,7 +89,7 @@ AM_CONDITIONAL(USING_MAC_INTERPOSE, $MAC_INTERPOSE)\n \n AC_CONFIG_FILES([Makefile])\n \n-AC_CONFIG_FILES(AC_FOREACH([DIR], [interception sanitizer_common asan], [DIR/Makefile ]),\n+AC_CONFIG_FILES(AC_FOREACH([DIR], [interception sanitizer_common asan ubsan], [DIR/Makefile ]),\n   [cat > vpsed$$ << \\_EOF\n s!`test -f '$<' || echo '$(srcdir)/'`!!\n _EOF"}, {"sha": "23748a701bbd706feaf6c945dc9da8ec334bb682", "filename": "libsanitizer/merge.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fmerge.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fmerge.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fmerge.sh?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -69,6 +69,7 @@ merge lib/asan asan\n merge lib/tsan/rtl tsan\n merge lib/sanitizer_common sanitizer_common\n merge lib/interception interception\n+merge lib/ubsan ubsan\n \n rm -rf upstream\n "}, {"sha": "d2782b6c9dce0d22b7e5469182c09113c34f7a66", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -15,6 +15,7 @@\n #define SANITIZER_COMMON_H\n \n #include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_mutex.h\"\n \n namespace __sanitizer {\n struct StackTrace;\n@@ -105,6 +106,8 @@ bool PrintsToTty();\n void Printf(const char *format, ...);\n void Report(const char *format, ...);\n void SetPrintfAndReportCallback(void (*callback)(const char *));\n+// Can be used to prevent mixing error reports from different sanitizers.\n+extern StaticSpinMutex CommonSanitizerReportMutex;\n \n fd_t OpenFile(const char *filename, bool write);\n // Opens the file 'file_name\" and reads up to 'max_len' bytes."}, {"sha": "8298f12bd7b85583ca8324f94c2c2cdf3ebbfc5b", "filename": "libsanitizer/sanitizer_common/sanitizer_printf.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -21,6 +21,8 @@\n \n namespace __sanitizer {\n \n+StaticSpinMutex CommonSanitizerReportMutex;\n+\n static int AppendChar(char **buff, const char *buff_end, char c) {\n   if (*buff < buff_end) {\n     **buff = c;"}, {"sha": "cabf08e6082a302d2ef008c9648d5af362d5cd85", "filename": "libsanitizer/sanitizer_common/sanitizer_report_decorator.h", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fsanitizer_common%2Fsanitizer_report_decorator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fsanitizer_common%2Fsanitizer_report_decorator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_report_decorator.h?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -12,24 +12,26 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#ifndef SANITIZER_ALLOCATOR_H\n-#define SANITIZER_ALLOCATOR_H\n+#ifndef SANITIZER_REPORT_DECORATOR_H\n+#define SANITIZER_REPORT_DECORATOR_H\n \n namespace __sanitizer {\n class AnsiColorDecorator {\n  public:\n   explicit AnsiColorDecorator(bool use_ansi_colors) : ansi_(use_ansi_colors) { }\n-  const char *Black()        { return ansi_ ? \"\\033[1m\\033[30m\" : \"\"; }\n-  const char *Red()          { return ansi_ ? \"\\033[1m\\033[31m\" : \"\"; }\n-  const char *Green()        { return ansi_ ? \"\\033[1m\\033[32m\" : \"\"; }\n-  const char *Yellow()       { return ansi_ ? \"\\033[1m\\033[33m\" : \"\"; }\n-  const char *Blue()         { return ansi_ ? \"\\033[1m\\033[34m\" : \"\"; }\n-  const char *Magenta()      { return ansi_ ? \"\\033[1m\\033[35m\" : \"\"; }\n-  const char *Cyan()         { return ansi_ ? \"\\033[1m\\033[36m\" : \"\"; }\n-  const char *White()        { return ansi_ ? \"\\033[1m\\033[37m\" : \"\"; }\n-  const char *Default()      { return ansi_ ? \"\\033[1m\\033[0m\"  : \"\"; }\n+  const char *Bold()    const { return ansi_ ? \"\\033[1m\" : \"\"; }\n+  const char *Black()   const { return ansi_ ? \"\\033[1m\\033[30m\" : \"\"; }\n+  const char *Red()     const { return ansi_ ? \"\\033[1m\\033[31m\" : \"\"; }\n+  const char *Green()   const { return ansi_ ? \"\\033[1m\\033[32m\" : \"\"; }\n+  const char *Yellow()  const { return ansi_ ? \"\\033[1m\\033[33m\" : \"\"; }\n+  const char *Blue()    const { return ansi_ ? \"\\033[1m\\033[34m\" : \"\"; }\n+  const char *Magenta() const { return ansi_ ? \"\\033[1m\\033[35m\" : \"\"; }\n+  const char *Cyan()    const { return ansi_ ? \"\\033[1m\\033[36m\" : \"\"; }\n+  const char *White()   const { return ansi_ ? \"\\033[1m\\033[37m\" : \"\"; }\n+  const char *Default() const { return ansi_ ? \"\\033[1m\\033[0m\"  : \"\"; }\n  private:\n   bool ansi_;\n };\n }  // namespace __sanitizer\n-#endif  // SANITIZER_ALLOCATOR_H\n+\n+#endif  // SANITIZER_REPORT_DECORATOR_H"}, {"sha": "0921d95aa1705cbf412687b076016fc55c3e580e", "filename": "libsanitizer/ubsan/Makefile.am", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2FMakefile.am?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,65 @@\n+AM_CPPFLAGS = -I $(top_srcdir) -I $(top_srcdir)/include\n+\n+# May be used by toolexeclibdir.\n+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n+\n+DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS \n+AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic -Wno-long-long  -fPIC -fno-builtin -fno-exceptions -fomit-frame-pointer -funwind-tables -fvisibility=hidden -Wno-variadic-macros\n+AM_CXXFLAGS += $(LIBSTDCXX_RAW_CXX_CXXFLAGS)\n+ACLOCAL_AMFLAGS = -I m4\n+\n+toolexeclib_LTLIBRARIES = libubsan.la\n+\n+ubsan_files = \\\n+\tubsan_diag.cc \\\n+\tubsan_handlers.cc \\\n+\tubsan_handlers_cxx.cc \\\n+\tubsan_type_hash.cc \\\n+\tubsan_value.cc\n+\n+libubsan_la_SOURCES = $(ubsan_files) \n+libubsan_la_LIBADD = $(top_builddir)/sanitizer_common/libsanitizer_common.la $(top_builddir)/interception/libinterception.la $(LIBSTDCXX_RAW_CXX_LDFLAGS)\n+libubsan_la_LDFLAGS = -version-info `grep -v '^\\#' $(srcdir)/libtool-version` -lpthread -ldl\n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n+\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+\t\"CFLAGS=$(CFLAGS)\" \\\n+\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n+\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+\t\"INSTALL=$(INSTALL)\" \\\n+\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+\t\"JC1FLAGS=$(JC1FLAGS)\" \\\n+\t\"LDFLAGS=$(LDFLAGS)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\"MAKE=$(MAKE)\" \\\n+\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+\t\"SHELL=$(SHELL)\" \\\n+\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+\t\"exec_prefix=$(exec_prefix)\" \\\n+\t\"infodir=$(infodir)\" \\\n+\t\"libdir=$(libdir)\" \\\n+\t\"prefix=$(prefix)\" \\\n+\t\"includedir=$(includedir)\" \\\n+\t\"AR=$(AR)\" \\\n+\t\"AS=$(AS)\" \\\n+\t\"LD=$(LD)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"NM=$(NM)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"RANLIB=$(RANLIB)\" \\\n+\t\"DESTDIR=$(DESTDIR)\"\n+\n+MAKEOVERRIDES=\n+\n+## ################################################################\n+"}, {"sha": "948c2449bf9dc2ce7d832d34633fad0bc19b7b75", "filename": "libsanitizer/ubsan/Makefile.in", "status": "added", "additions": 578, "deletions": 0, "changes": 578, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2FMakefile.in?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,578 @@\n+# Makefile.in generated by automake 1.11.1 from Makefile.am.\n+# @configure_input@\n+\n+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,\n+# Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+@SET_MAKE@\n+\n+VPATH = @srcdir@\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkglibexecdir = $(libexecdir)/@PACKAGE@\n+am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n+install_sh_DATA = $(install_sh) -c -m 644\n+install_sh_PROGRAM = $(install_sh) -c\n+install_sh_SCRIPT = $(install_sh) -c\n+INSTALL_HEADER = $(INSTALL_DATA)\n+transform = $(program_transform_name)\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_triplet = @build@\n+host_triplet = @host@\n+target_triplet = @target@\n+subdir = ubsan\n+DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am\n+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n+am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \\\n+\t$(top_srcdir)/../config/depstand.m4 \\\n+\t$(top_srcdir)/../config/lead-dot.m4 \\\n+\t$(top_srcdir)/../config/libstdc++-raw-cxx.m4 \\\n+\t$(top_srcdir)/../config/multi.m4 \\\n+\t$(top_srcdir)/../config/override.m4 \\\n+\t$(top_srcdir)/../ltoptions.m4 $(top_srcdir)/../ltsugar.m4 \\\n+\t$(top_srcdir)/../ltversion.m4 $(top_srcdir)/../lt~obsolete.m4 \\\n+\t$(top_srcdir)/acinclude.m4 $(top_srcdir)/../libtool.m4 \\\n+\t$(top_srcdir)/configure.ac\n+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n+\t$(ACLOCAL_M4)\n+mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n+CONFIG_CLEAN_FILES =\n+CONFIG_CLEAN_VPATH_FILES =\n+am__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\n+am__vpath_adj = case $$p in \\\n+    $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n+    *) f=$$p;; \\\n+  esac;\n+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;\n+am__install_max = 40\n+am__nobase_strip_setup = \\\n+  srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*|]/\\\\\\\\&/g'`\n+am__nobase_strip = \\\n+  for p in $$list; do echo \"$$p\"; done | sed -e \"s|$$srcdirstrip/||\"\n+am__nobase_list = $(am__nobase_strip_setup); \\\n+  for p in $$list; do echo \"$$p $$p\"; done | \\\n+  sed \"s| $$srcdirstrip/| |;\"' / .*\\//!s/ .*/ ./; s,\\( .*\\)/[^/]*$$,\\1,' | \\\n+  $(AWK) 'BEGIN { files[\".\"] = \"\" } { files[$$2] = files[$$2] \" \" $$1; \\\n+    if (++n[$$2] == $(am__install_max)) \\\n+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = \"\" } } \\\n+    END { for (dir in files) print dir, files[dir] }'\n+am__base_list = \\\n+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n+  sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\n+am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\"\n+LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n+am__DEPENDENCIES_1 =\n+libubsan_la_DEPENDENCIES =  \\\n+\t$(top_builddir)/sanitizer_common/libsanitizer_common.la \\\n+\t$(top_builddir)/interception/libinterception.la \\\n+\t$(am__DEPENDENCIES_1)\n+am__objects_1 = ubsan_diag.lo ubsan_handlers.lo ubsan_handlers_cxx.lo \\\n+\tubsan_type_hash.lo ubsan_value.lo\n+am_libubsan_la_OBJECTS = $(am__objects_1)\n+libubsan_la_OBJECTS = $(am_libubsan_la_OBJECTS)\n+libubsan_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \\\n+\t$(CXXFLAGS) $(libubsan_la_LDFLAGS) $(LDFLAGS) -o $@\n+DEFAULT_INCLUDES = -I.@am__isrc@\n+depcomp = $(SHELL) $(top_srcdir)/../depcomp\n+am__depfiles_maybe = depfiles\n+am__mv = mv -f\n+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+LTCXXCOMPILE = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+CXXLD = $(CXX)\n+CXXLINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n+SOURCES = $(libubsan_la_SOURCES)\n+ETAGS = etags\n+CTAGS = ctags\n+ACLOCAL = @ACLOCAL@\n+AMTAR = @AMTAR@\n+AR = @AR@\n+AUTOCONF = @AUTOCONF@\n+AUTOHEADER = @AUTOHEADER@\n+AUTOMAKE = @AUTOMAKE@\n+AWK = @AWK@\n+CC = @CC@\n+CCAS = @CCAS@\n+CCASDEPMODE = @CCASDEPMODE@\n+CCASFLAGS = @CCASFLAGS@\n+CCDEPMODE = @CCDEPMODE@\n+CFLAGS = @CFLAGS@\n+CPP = @CPP@\n+CPPFLAGS = @CPPFLAGS@\n+CXX = @CXX@\n+CXXCPP = @CXXCPP@\n+CXXDEPMODE = @CXXDEPMODE@\n+CXXFLAGS = @CXXFLAGS@\n+CYGPATH_W = @CYGPATH_W@\n+DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS \n+DEPDIR = @DEPDIR@\n+DSYMUTIL = @DSYMUTIL@\n+DUMPBIN = @DUMPBIN@\n+ECHO_C = @ECHO_C@\n+ECHO_N = @ECHO_N@\n+ECHO_T = @ECHO_T@\n+EGREP = @EGREP@\n+EXEEXT = @EXEEXT@\n+FGREP = @FGREP@\n+GREP = @GREP@\n+INSTALL = @INSTALL@\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n+LD = @LD@\n+LDFLAGS = @LDFLAGS@\n+LIBOBJS = @LIBOBJS@\n+LIBS = @LIBS@\n+LIBSTDCXX_RAW_CXX_CXXFLAGS = @LIBSTDCXX_RAW_CXX_CXXFLAGS@\n+LIBSTDCXX_RAW_CXX_LDFLAGS = @LIBSTDCXX_RAW_CXX_LDFLAGS@\n+LIBTOOL = @LIBTOOL@\n+LIPO = @LIPO@\n+LN_S = @LN_S@\n+LTLIBOBJS = @LTLIBOBJS@\n+MAINT = @MAINT@\n+MAKEINFO = @MAKEINFO@\n+MKDIR_P = @MKDIR_P@\n+NM = @NM@\n+NMEDIT = @NMEDIT@\n+OBJDUMP = @OBJDUMP@\n+OBJEXT = @OBJEXT@\n+OTOOL = @OTOOL@\n+OTOOL64 = @OTOOL64@\n+PACKAGE = @PACKAGE@\n+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n+PACKAGE_NAME = @PACKAGE_NAME@\n+PACKAGE_STRING = @PACKAGE_STRING@\n+PACKAGE_TARNAME = @PACKAGE_TARNAME@\n+PACKAGE_URL = @PACKAGE_URL@\n+PACKAGE_VERSION = @PACKAGE_VERSION@\n+PATH_SEPARATOR = @PATH_SEPARATOR@\n+RANLIB = @RANLIB@\n+SED = @SED@\n+SET_MAKE = @SET_MAKE@\n+SHELL = @SHELL@\n+STRIP = @STRIP@\n+VERSION = @VERSION@\n+abs_builddir = @abs_builddir@\n+abs_srcdir = @abs_srcdir@\n+abs_top_builddir = @abs_top_builddir@\n+abs_top_srcdir = @abs_top_srcdir@\n+ac_ct_CC = @ac_ct_CC@\n+ac_ct_CXX = @ac_ct_CXX@\n+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n+am__include = @am__include@\n+am__leading_dot = @am__leading_dot@\n+am__quote = @am__quote@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n+bindir = @bindir@\n+build = @build@\n+build_alias = @build_alias@\n+build_cpu = @build_cpu@\n+build_os = @build_os@\n+build_vendor = @build_vendor@\n+builddir = @builddir@\n+datadir = @datadir@\n+datarootdir = @datarootdir@\n+docdir = @docdir@\n+dvidir = @dvidir@\n+enable_shared = @enable_shared@\n+enable_static = @enable_static@\n+exec_prefix = @exec_prefix@\n+host = @host@\n+host_alias = @host_alias@\n+host_cpu = @host_cpu@\n+host_os = @host_os@\n+host_vendor = @host_vendor@\n+htmldir = @htmldir@\n+includedir = @includedir@\n+infodir = @infodir@\n+install_sh = @install_sh@\n+libdir = @libdir@\n+libexecdir = @libexecdir@\n+localedir = @localedir@\n+localstatedir = @localstatedir@\n+mandir = @mandir@\n+mkdir_p = @mkdir_p@\n+multi_basedir = @multi_basedir@\n+oldincludedir = @oldincludedir@\n+pdfdir = @pdfdir@\n+prefix = @prefix@\n+program_transform_name = @program_transform_name@\n+psdir = @psdir@\n+sbindir = @sbindir@\n+sharedstatedir = @sharedstatedir@\n+srcdir = @srcdir@\n+sysconfdir = @sysconfdir@\n+target = @target@\n+target_alias = @target_alias@\n+target_cpu = @target_cpu@\n+target_noncanonical = @target_noncanonical@\n+target_os = @target_os@\n+target_vendor = @target_vendor@\n+toolexecdir = @toolexecdir@\n+toolexeclibdir = @toolexeclibdir@\n+top_build_prefix = @top_build_prefix@\n+top_builddir = @top_builddir@\n+top_srcdir = @top_srcdir@\n+AM_CPPFLAGS = -I $(top_srcdir) -I $(top_srcdir)/include\n+\n+# May be used by toolexeclibdir.\n+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n+AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic \\\n+\t-Wno-long-long -fPIC -fno-builtin -fno-exceptions \\\n+\t-fomit-frame-pointer -funwind-tables -fvisibility=hidden \\\n+\t-Wno-variadic-macros $(LIBSTDCXX_RAW_CXX_CXXFLAGS)\n+ACLOCAL_AMFLAGS = -I m4\n+toolexeclib_LTLIBRARIES = libubsan.la\n+ubsan_files = \\\n+\tubsan_diag.cc \\\n+\tubsan_handlers.cc \\\n+\tubsan_handlers_cxx.cc \\\n+\tubsan_type_hash.cc \\\n+\tubsan_value.cc\n+\n+libubsan_la_SOURCES = $(ubsan_files) \n+libubsan_la_LIBADD = $(top_builddir)/sanitizer_common/libsanitizer_common.la $(top_builddir)/interception/libinterception.la $(LIBSTDCXX_RAW_CXX_LDFLAGS)\n+libubsan_la_LDFLAGS = -version-info `grep -v '^\\#' $(srcdir)/libtool-version` -lpthread -ldl\n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n+\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+\t\"CFLAGS=$(CFLAGS)\" \\\n+\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n+\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+\t\"INSTALL=$(INSTALL)\" \\\n+\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+\t\"JC1FLAGS=$(JC1FLAGS)\" \\\n+\t\"LDFLAGS=$(LDFLAGS)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\"MAKE=$(MAKE)\" \\\n+\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+\t\"SHELL=$(SHELL)\" \\\n+\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+\t\"exec_prefix=$(exec_prefix)\" \\\n+\t\"infodir=$(infodir)\" \\\n+\t\"libdir=$(libdir)\" \\\n+\t\"prefix=$(prefix)\" \\\n+\t\"includedir=$(includedir)\" \\\n+\t\"AR=$(AR)\" \\\n+\t\"AS=$(AS)\" \\\n+\t\"LD=$(LD)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"NM=$(NM)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"RANLIB=$(RANLIB)\" \\\n+\t\"DESTDIR=$(DESTDIR)\"\n+\n+MAKEOVERRIDES = \n+all: all-am\n+\n+.SUFFIXES:\n+.SUFFIXES: .cc .lo .o .obj\n+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n+\t@for dep in $?; do \\\n+\t  case '$(am__configure_deps)' in \\\n+\t    *$$dep*) \\\n+\t      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \\\n+\t        && { if test -f $@; then exit 0; else break; fi; }; \\\n+\t      exit 1;; \\\n+\t  esac; \\\n+\tdone; \\\n+\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign ubsan/Makefile'; \\\n+\t$(am__cd) $(top_srcdir) && \\\n+\t  $(AUTOMAKE) --foreign ubsan/Makefile\n+.PRECIOUS: Makefile\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\t@case '$?' in \\\n+\t  *config.status*) \\\n+\t    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \\\n+\t  *) \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \\\n+\tesac;\n+\n+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+\n+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+$(am__aclocal_m4_deps):\n+install-toolexeclibLTLIBRARIES: $(toolexeclib_LTLIBRARIES)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibdir)\"\n+\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tlist2=; for p in $$list; do \\\n+\t  if test -f $$p; then \\\n+\t    list2=\"$$list2 $$p\"; \\\n+\t  else :; fi; \\\n+\tdone; \\\n+\ttest -z \"$$list2\" || { \\\n+\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(toolexeclibdir)'\"; \\\n+\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 \"$(DESTDIR)$(toolexeclibdir)\"; \\\n+\t}\n+\n+uninstall-toolexeclibLTLIBRARIES:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  $(am__strip_dir) \\\n+\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(toolexeclibdir)/$$f'\"; \\\n+\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f \"$(DESTDIR)$(toolexeclibdir)/$$f\"; \\\n+\tdone\n+\n+clean-toolexeclibLTLIBRARIES:\n+\t-test -z \"$(toolexeclib_LTLIBRARIES)\" || rm -f $(toolexeclib_LTLIBRARIES)\n+\t@list='$(toolexeclib_LTLIBRARIES)'; for p in $$list; do \\\n+\t  dir=\"`echo $$p | sed -e 's|/[^/]*$$||'`\"; \\\n+\t  test \"$$dir\" != \"$$p\" || dir=.; \\\n+\t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n+\t  rm -f \"$${dir}/so_locations\"; \\\n+\tdone\n+libubsan.la: $(libubsan_la_OBJECTS) $(libubsan_la_DEPENDENCIES) \n+\t$(libubsan_la_LINK) -rpath $(toolexeclibdir) $(libubsan_la_OBJECTS) $(libubsan_la_LIBADD) $(LIBS)\n+\n+mostlyclean-compile:\n+\t-rm -f *.$(OBJEXT)\n+\n+distclean-compile:\n+\t-rm -f *.tab.c\n+\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ubsan_diag.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ubsan_handlers.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ubsan_handlers_cxx.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ubsan_type_hash.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ubsan_value.Plo@am__quote@\n+\n+.cc.o:\n+@am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(CXXCOMPILE) -c -o $@ $<\n+\n+.cc.obj:\n+@am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n+\n+.cc.lo:\n+@am__fastdepCXX_TRUE@\t$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LTCXXCOMPILE) -c -o $@ $<\n+\n+mostlyclean-libtool:\n+\t-rm -f *.lo\n+\n+clean-libtool:\n+\t-rm -rf .libs _libs\n+\n+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n+\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tmkid -fID $$unique\n+tags: TAGS\n+\n+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tset x; \\\n+\there=`pwd`; \\\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tshift; \\\n+\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n+\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n+\t  if test $$# -gt 0; then \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      \"$$@\" $$unique; \\\n+\t  else \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      $$unique; \\\n+\t  fi; \\\n+\tfi\n+ctags: CTAGS\n+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n+\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n+\t     $$unique\n+\n+GTAGS:\n+\there=`$(am__cd) $(top_builddir) && pwd` \\\n+\t  && $(am__cd) $(top_srcdir) \\\n+\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n+\n+distclean-tags:\n+\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n+check-am: all-am\n+check: check-am\n+all-am: Makefile $(LTLIBRARIES)\n+installdirs:\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\"; do \\\n+\t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n+\tdone\n+install: install-am\n+install-exec: install-exec-am\n+install-data: install-data-am\n+uninstall: uninstall-am\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+\n+installcheck: installcheck-am\n+install-strip:\n+\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t  `test -z '$(STRIP)' || \\\n+\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n+mostlyclean-generic:\n+\n+clean-generic:\n+\n+distclean-generic:\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n+\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n+\n+maintainer-clean-generic:\n+\t@echo \"This command is intended for maintainers to use\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+clean: clean-am\n+\n+clean-am: clean-generic clean-libtool clean-toolexeclibLTLIBRARIES \\\n+\tmostlyclean-am\n+\n+distclean: distclean-am\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+distclean-am: clean-am distclean-compile distclean-generic \\\n+\tdistclean-tags\n+\n+dvi: dvi-am\n+\n+dvi-am:\n+\n+html: html-am\n+\n+html-am:\n+\n+info: info-am\n+\n+info-am:\n+\n+install-data-am:\n+\n+install-dvi: install-dvi-am\n+\n+install-dvi-am:\n+\n+install-exec-am: install-toolexeclibLTLIBRARIES\n+\n+install-html: install-html-am\n+\n+install-html-am:\n+\n+install-info: install-info-am\n+\n+install-info-am:\n+\n+install-man:\n+\n+install-pdf: install-pdf-am\n+\n+install-pdf-am:\n+\n+install-ps: install-ps-am\n+\n+install-ps-am:\n+\n+installcheck-am:\n+\n+maintainer-clean: maintainer-clean-am\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+maintainer-clean-am: distclean-am maintainer-clean-generic\n+\n+mostlyclean: mostlyclean-am\n+\n+mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n+\tmostlyclean-libtool\n+\n+pdf: pdf-am\n+\n+pdf-am:\n+\n+ps: ps-am\n+\n+ps-am:\n+\n+uninstall-am: uninstall-toolexeclibLTLIBRARIES\n+\n+.MAKE: install-am install-strip\n+\n+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \\\n+\tclean-libtool clean-toolexeclibLTLIBRARIES ctags distclean \\\n+\tdistclean-compile distclean-generic distclean-libtool \\\n+\tdistclean-tags dvi dvi-am html html-am info info-am install \\\n+\tinstall-am install-data install-data-am install-dvi \\\n+\tinstall-dvi-am install-exec install-exec-am install-html \\\n+\tinstall-html-am install-info install-info-am install-man \\\n+\tinstall-pdf install-pdf-am install-ps install-ps-am \\\n+\tinstall-strip install-toolexeclibLTLIBRARIES installcheck \\\n+\tinstallcheck-am installdirs maintainer-clean \\\n+\tmaintainer-clean-generic mostlyclean mostlyclean-compile \\\n+\tmostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \\\n+\ttags uninstall uninstall-am uninstall-toolexeclibLTLIBRARIES\n+\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "204fdd2d8e5fe21a5a9f9e23d6a6cf17d353362a", "filename": "libsanitizer/ubsan/libtool-version", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2Flibtool-version", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2Flibtool-version", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Flibtool-version?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,6 @@\n+# This file is used to maintain libtool version info for libmudflap.  See\n+# the libtool manual to understand the meaning of the fields.  This is\n+# a separate file so that version updates don't involve re-running\n+# automake.\n+# CURRENT:REVISION:AGE\n+0:0:0"}, {"sha": "d56ef849b6fcf72bec2680129dda32547aa22eb5", "filename": "libsanitizer/ubsan/ubsan_diag.cc", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2Fubsan_diag.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2Fubsan_diag.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_diag.cc?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,261 @@\n+//===-- ubsan_diag.cc -----------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Diagnostic reporting for the UBSan runtime.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"ubsan_diag.h\"\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"sanitizer_common/sanitizer_report_decorator.h\"\n+#include \"sanitizer_common/sanitizer_stacktrace.h\"\n+#include \"sanitizer_common/sanitizer_symbolizer.h\"\n+#include <stdio.h>\n+\n+using namespace __ubsan;\n+\n+Location __ubsan::getCallerLocation(uptr CallerLoc) {\n+  if (!CallerLoc)\n+    return Location();\n+\n+  uptr Loc = StackTrace::GetPreviousInstructionPc(CallerLoc);\n+\n+  AddressInfo Info;\n+  if (!SymbolizeCode(Loc, &Info, 1) || !Info.module || !*Info.module)\n+    return Location(Loc);\n+\n+  if (!Info.file)\n+    return ModuleLocation(Info.module, Info.module_offset);\n+\n+  return SourceLocation(Info.file, Info.line, Info.column);\n+}\n+\n+Diag &Diag::operator<<(const TypeDescriptor &V) {\n+  return AddArg(V.getTypeName());\n+}\n+\n+Diag &Diag::operator<<(const Value &V) {\n+  if (V.getType().isSignedIntegerTy())\n+    AddArg(V.getSIntValue());\n+  else if (V.getType().isUnsignedIntegerTy())\n+    AddArg(V.getUIntValue());\n+  else if (V.getType().isFloatTy())\n+    AddArg(V.getFloatValue());\n+  else\n+    AddArg(\"<unknown>\");\n+  return *this;\n+}\n+\n+/// Hexadecimal printing for numbers too large for Printf to handle directly.\n+static void PrintHex(UIntMax Val) {\n+#if HAVE_INT128_T\n+  Printf(\"0x%08x%08x%08x%08x\",\n+          (unsigned int)(Val >> 96),\n+          (unsigned int)(Val >> 64),\n+          (unsigned int)(Val >> 32),\n+          (unsigned int)(Val));\n+#else\n+  UNREACHABLE(\"long long smaller than 64 bits?\");\n+#endif\n+}\n+\n+static void renderLocation(Location Loc) {\n+  switch (Loc.getKind()) {\n+  case Location::LK_Source: {\n+    SourceLocation SLoc = Loc.getSourceLocation();\n+    if (SLoc.isInvalid())\n+      Printf(\"<unknown>:\");\n+    else {\n+      Printf(\"%s:%d:\", SLoc.getFilename(), SLoc.getLine());\n+      if (SLoc.getColumn())\n+        Printf(\"%d:\", SLoc.getColumn());\n+    }\n+    break;\n+  }\n+  case Location::LK_Module:\n+    Printf(\"%s:0x%zx:\", Loc.getModuleLocation().getModuleName(),\n+           Loc.getModuleLocation().getOffset());\n+    break;\n+  case Location::LK_Memory:\n+    Printf(\"%p:\", Loc.getMemoryLocation());\n+    break;\n+  case Location::LK_Null:\n+    Printf(\"<unknown>:\");\n+    break;\n+  }\n+}\n+\n+static void renderText(const char *Message, const Diag::Arg *Args) {\n+  for (const char *Msg = Message; *Msg; ++Msg) {\n+    if (*Msg != '%') {\n+      char Buffer[64];\n+      unsigned I;\n+      for (I = 0; Msg[I] && Msg[I] != '%' && I != 63; ++I)\n+        Buffer[I] = Msg[I];\n+      Buffer[I] = '\\0';\n+      Printf(Buffer);\n+      Msg += I - 1;\n+    } else {\n+      const Diag::Arg &A = Args[*++Msg - '0'];\n+      switch (A.Kind) {\n+      case Diag::AK_String:\n+        Printf(\"%s\", A.String);\n+        break;\n+      case Diag::AK_Mangled: {\n+        Printf(\"'%s'\", Demangle(A.String));\n+        break;\n+      }\n+      case Diag::AK_SInt:\n+        // 'long long' is guaranteed to be at least 64 bits wide.\n+        if (A.SInt >= INT64_MIN && A.SInt <= INT64_MAX)\n+          Printf(\"%lld\", (long long)A.SInt);\n+        else\n+          PrintHex(A.SInt);\n+        break;\n+      case Diag::AK_UInt:\n+        if (A.UInt <= UINT64_MAX)\n+          Printf(\"%llu\", (unsigned long long)A.UInt);\n+        else\n+          PrintHex(A.UInt);\n+        break;\n+      case Diag::AK_Float: {\n+        // FIXME: Support floating-point formatting in sanitizer_common's\n+        //        printf, and stop using snprintf here.\n+        char Buffer[32];\n+        snprintf(Buffer, sizeof(Buffer), \"%Lg\", (long double)A.Float);\n+        Printf(\"%s\", Buffer);\n+        break;\n+      }\n+      case Diag::AK_Pointer:\n+        Printf(\"%p\", A.Pointer);\n+        break;\n+      }\n+    }\n+  }\n+}\n+\n+/// Find the earliest-starting range in Ranges which ends after Loc.\n+static Range *upperBound(MemoryLocation Loc, Range *Ranges,\n+                         unsigned NumRanges) {\n+  Range *Best = 0;\n+  for (unsigned I = 0; I != NumRanges; ++I)\n+    if (Ranges[I].getEnd().getMemoryLocation() > Loc &&\n+        (!Best ||\n+         Best->getStart().getMemoryLocation() >\n+         Ranges[I].getStart().getMemoryLocation()))\n+      Best = &Ranges[I];\n+  return Best;\n+}\n+\n+/// Render a snippet of the address space near a location.\n+static void renderMemorySnippet(const __sanitizer::AnsiColorDecorator &Decor,\n+                                MemoryLocation Loc,\n+                                Range *Ranges, unsigned NumRanges,\n+                                const Diag::Arg *Args) {\n+  const unsigned BytesToShow = 32;\n+  const unsigned MinBytesNearLoc = 4;\n+\n+  // Show at least the 8 bytes surrounding Loc.\n+  MemoryLocation Min = Loc - MinBytesNearLoc, Max = Loc + MinBytesNearLoc;\n+  for (unsigned I = 0; I < NumRanges; ++I) {\n+    Min = __sanitizer::Min(Ranges[I].getStart().getMemoryLocation(), Min);\n+    Max = __sanitizer::Max(Ranges[I].getEnd().getMemoryLocation(), Max);\n+  }\n+\n+  // If we have too many interesting bytes, prefer to show bytes after Loc.\n+  if (Max - Min > BytesToShow)\n+    Min = __sanitizer::Min(Max - BytesToShow, Loc - MinBytesNearLoc);\n+  Max = Min + BytesToShow;\n+\n+  // Emit data.\n+  for (uptr P = Min; P != Max; ++P) {\n+    // FIXME: Check that the address is readable before printing it.\n+    unsigned char C = *reinterpret_cast<const unsigned char*>(P);\n+    Printf(\"%s%02x\", (P % 8 == 0) ? \"  \" : \" \", C);\n+  }\n+  Printf(\"\\n\");\n+\n+  // Emit highlights.\n+  Printf(Decor.Green());\n+  Range *InRange = upperBound(Min, Ranges, NumRanges);\n+  for (uptr P = Min; P != Max; ++P) {\n+    char Pad = ' ', Byte = ' ';\n+    if (InRange && InRange->getEnd().getMemoryLocation() == P)\n+      InRange = upperBound(P, Ranges, NumRanges);\n+    if (!InRange && P > Loc)\n+      break;\n+    if (InRange && InRange->getStart().getMemoryLocation() < P)\n+      Pad = '~';\n+    if (InRange && InRange->getStart().getMemoryLocation() <= P)\n+      Byte = '~';\n+    char Buffer[] = { Pad, Pad, P == Loc ? '^' : Byte, Byte, 0 };\n+    Printf((P % 8 == 0) ? Buffer : &Buffer[1]);\n+  }\n+  Printf(\"%s\\n\", Decor.Default());\n+\n+  // Go over the line again, and print names for the ranges.\n+  InRange = 0;\n+  unsigned Spaces = 0;\n+  for (uptr P = Min; P != Max; ++P) {\n+    if (!InRange || InRange->getEnd().getMemoryLocation() == P)\n+      InRange = upperBound(P, Ranges, NumRanges);\n+    if (!InRange)\n+      break;\n+\n+    Spaces += (P % 8) == 0 ? 2 : 1;\n+\n+    if (InRange && InRange->getStart().getMemoryLocation() == P) {\n+      while (Spaces--)\n+        Printf(\" \");\n+      renderText(InRange->getText(), Args);\n+      Printf(\"\\n\");\n+      // FIXME: We only support naming one range for now!\n+      break;\n+    }\n+\n+    Spaces += 2;\n+  }\n+\n+  // FIXME: Print names for anything we can identify within the line:\n+  //\n+  //  * If we can identify the memory itself as belonging to a particular\n+  //    global, stack variable, or dynamic allocation, then do so.\n+  //\n+  //  * If we have a pointer-size, pointer-aligned range highlighted,\n+  //    determine whether the value of that range is a pointer to an\n+  //    entity which we can name, and if so, print that name.\n+  //\n+  // This needs an external symbolizer, or (preferably) ASan instrumentation.\n+}\n+\n+Diag::~Diag() {\n+  __sanitizer::AnsiColorDecorator Decor(PrintsToTty());\n+  SpinMutexLock l(&CommonSanitizerReportMutex);\n+  Printf(Decor.Bold());\n+\n+  renderLocation(Loc);\n+\n+  switch (Level) {\n+  case DL_Error:\n+    Printf(\"%s runtime error: %s%s\",\n+           Decor.Red(), Decor.Default(), Decor.Bold());\n+    break;\n+\n+  case DL_Note:\n+    Printf(\"%s note: %s\", Decor.Black(), Decor.Default());\n+    break;\n+  }\n+\n+  renderText(Message, Args);\n+\n+  Printf(\"%s\\n\", Decor.Default());\n+\n+  if (Loc.isMemoryLocation())\n+    renderMemorySnippet(Decor, Loc.getMemoryLocation(), Ranges,\n+                        NumRanges, Args);\n+}"}, {"sha": "969d51cb677b72ddb4de2402bdcc95e02b244832", "filename": "libsanitizer/ubsan/ubsan_diag.h", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2Fubsan_diag.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2Fubsan_diag.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_diag.h?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,200 @@\n+//===-- ubsan_diag.h --------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Diagnostics emission for Clang's undefined behavior sanitizer.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef UBSAN_DIAG_H\n+#define UBSAN_DIAG_H\n+\n+#include \"ubsan_value.h\"\n+\n+namespace __ubsan {\n+\n+/// \\brief A location within a loaded module in the program. These are used when\n+/// the location can't be resolved to a SourceLocation.\n+class ModuleLocation {\n+  const char *ModuleName;\n+  uptr Offset;\n+\n+public:\n+  ModuleLocation() : ModuleName(0), Offset(0) {}\n+  ModuleLocation(const char *ModuleName, uptr Offset)\n+    : ModuleName(ModuleName), Offset(Offset) {}\n+  const char *getModuleName() const { return ModuleName; }\n+  uptr getOffset() const { return Offset; }\n+};\n+\n+/// A location of some data within the program's address space.\n+typedef uptr MemoryLocation;\n+\n+/// \\brief Location at which a diagnostic can be emitted. Either a\n+/// SourceLocation, a ModuleLocation, or a MemoryLocation.\n+class Location {\n+public:\n+  enum LocationKind { LK_Null, LK_Source, LK_Module, LK_Memory };\n+\n+private:\n+  LocationKind Kind;\n+  // FIXME: In C++11, wrap these in an anonymous union.\n+  SourceLocation SourceLoc;\n+  ModuleLocation ModuleLoc;\n+  MemoryLocation MemoryLoc;\n+\n+public:\n+  Location() : Kind(LK_Null) {}\n+  Location(SourceLocation Loc) :\n+    Kind(LK_Source), SourceLoc(Loc) {}\n+  Location(ModuleLocation Loc) :\n+    Kind(LK_Module), ModuleLoc(Loc) {}\n+  Location(MemoryLocation Loc) :\n+    Kind(LK_Memory), MemoryLoc(Loc) {}\n+\n+  LocationKind getKind() const { return Kind; }\n+\n+  bool isSourceLocation() const { return Kind == LK_Source; }\n+  bool isModuleLocation() const { return Kind == LK_Module; }\n+  bool isMemoryLocation() const { return Kind == LK_Memory; }\n+\n+  SourceLocation getSourceLocation() const {\n+    CHECK(isSourceLocation());\n+    return SourceLoc;\n+  }\n+  ModuleLocation getModuleLocation() const {\n+    CHECK(isModuleLocation());\n+    return ModuleLoc;\n+  }\n+  MemoryLocation getMemoryLocation() const {\n+    CHECK(isMemoryLocation());\n+    return MemoryLoc;\n+  }\n+};\n+\n+/// Try to obtain a location for the caller. This might fail, and produce either\n+/// an invalid location or a module location for the caller.\n+Location getCallerLocation(uptr CallerLoc = GET_CALLER_PC());\n+\n+/// A diagnostic severity level.\n+enum DiagLevel {\n+  DL_Error, ///< An error.\n+  DL_Note   ///< A note, attached to a prior diagnostic.\n+};\n+\n+/// \\brief Annotation for a range of locations in a diagnostic.\n+class Range {\n+  Location Start, End;\n+  const char *Text;\n+\n+public:\n+  Range() : Start(), End(), Text() {}\n+  Range(MemoryLocation Start, MemoryLocation End, const char *Text)\n+    : Start(Start), End(End), Text(Text) {}\n+  Location getStart() const { return Start; }\n+  Location getEnd() const { return End; }\n+  const char *getText() const { return Text; }\n+};\n+\n+/// \\brief A mangled C++ name. Really just a strong typedef for 'const char*'.\n+class MangledName {\n+  const char *Name;\n+public:\n+  MangledName(const char *Name) : Name(Name) {}\n+  const char *getName() const { return Name; }\n+};\n+\n+/// \\brief Representation of an in-flight diagnostic.\n+///\n+/// Temporary \\c Diag instances are created by the handler routines to\n+/// accumulate arguments for a diagnostic. The destructor emits the diagnostic\n+/// message.\n+class Diag {\n+  /// The location at which the problem occurred.\n+  Location Loc;\n+\n+  /// The diagnostic level.\n+  DiagLevel Level;\n+\n+  /// The message which will be emitted, with %0, %1, ... placeholders for\n+  /// arguments.\n+  const char *Message;\n+\n+public:\n+  /// Kinds of arguments, corresponding to members of \\c Arg's union.\n+  enum ArgKind {\n+    AK_String, ///< A string argument, displayed as-is.\n+    AK_Mangled,///< A C++ mangled name, demangled before display.\n+    AK_UInt,   ///< An unsigned integer argument.\n+    AK_SInt,   ///< A signed integer argument.\n+    AK_Float,  ///< A floating-point argument.\n+    AK_Pointer ///< A pointer argument, displayed in hexadecimal.\n+  };\n+\n+  /// An individual diagnostic message argument.\n+  struct Arg {\n+    Arg() {}\n+    Arg(const char *String) : Kind(AK_String), String(String) {}\n+    Arg(MangledName MN) : Kind(AK_Mangled), String(MN.getName()) {}\n+    Arg(UIntMax UInt) : Kind(AK_UInt), UInt(UInt) {}\n+    Arg(SIntMax SInt) : Kind(AK_SInt), SInt(SInt) {}\n+    Arg(FloatMax Float) : Kind(AK_Float), Float(Float) {}\n+    Arg(const void *Pointer) : Kind(AK_Pointer), Pointer(Pointer) {}\n+\n+    ArgKind Kind;\n+    union {\n+      const char *String;\n+      UIntMax UInt;\n+      SIntMax SInt;\n+      FloatMax Float;\n+      const void *Pointer;\n+    };\n+  };\n+\n+private:\n+  static const unsigned MaxArgs = 5;\n+  static const unsigned MaxRanges = 1;\n+\n+  /// The arguments which have been added to this diagnostic so far.\n+  Arg Args[MaxArgs];\n+  unsigned NumArgs;\n+\n+  /// The ranges which have been added to this diagnostic so far.\n+  Range Ranges[MaxRanges];\n+  unsigned NumRanges;\n+\n+  Diag &AddArg(Arg A) {\n+    CHECK(NumArgs != MaxArgs);\n+    Args[NumArgs++] = A;\n+    return *this;\n+  }\n+\n+  Diag &AddRange(Range A) {\n+    CHECK(NumRanges != MaxRanges);\n+    Ranges[NumRanges++] = A;\n+    return *this;\n+  }\n+\n+  /// \\c Diag objects are not copyable.\n+  Diag(const Diag &); // NOT IMPLEMENTED\n+  Diag &operator=(const Diag &);\n+\n+public:\n+  Diag(Location Loc, DiagLevel Level, const char *Message)\n+    : Loc(Loc), Level(Level), Message(Message), NumArgs(0), NumRanges(0) {}\n+  ~Diag();\n+\n+  Diag &operator<<(const char *Str) { return AddArg(Str); }\n+  Diag &operator<<(MangledName MN) { return AddArg(MN); }\n+  Diag &operator<<(unsigned long long V) { return AddArg(UIntMax(V)); }\n+  Diag &operator<<(const void *V) { return AddArg(V); }\n+  Diag &operator<<(const TypeDescriptor &V);\n+  Diag &operator<<(const Value &V);\n+  Diag &operator<<(const Range &R) { return AddRange(R); }\n+};\n+\n+} // namespace __ubsan\n+\n+#endif // UBSAN_DIAG_H"}, {"sha": "5947c2a510130b85324578c9b2da18f19085dd3d", "filename": "libsanitizer/ubsan/ubsan_handlers.cc", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2Fubsan_handlers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2Fubsan_handlers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.cc?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,258 @@\n+//===-- ubsan_handlers.cc -------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Error logging entry points for the UBSan runtime.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"ubsan_handlers.h\"\n+#include \"ubsan_diag.h\"\n+\n+#include \"sanitizer_common/sanitizer_common.h\"\n+\n+using namespace __sanitizer;\n+using namespace __ubsan;\n+\n+namespace __ubsan {\n+  const char *TypeCheckKinds[] = {\n+    \"load of\", \"store to\", \"reference binding to\", \"member access within\",\n+    \"member call on\", \"constructor call on\", \"downcast of\", \"downcast of\"\n+  };\n+}\n+\n+static void handleTypeMismatchImpl(TypeMismatchData *Data, ValueHandle Pointer,\n+                                   Location FallbackLoc) {\n+  Location Loc = Data->Loc.acquire();\n+\n+  // Use the SourceLocation from Data to track deduplication, even if 'invalid'\n+  if (Loc.getSourceLocation().isDisabled())\n+    return;\n+  if (Data->Loc.isInvalid())\n+    Loc = FallbackLoc;\n+\n+  if (!Pointer)\n+    Diag(Loc, DL_Error, \"%0 null pointer of type %1\")\n+      << TypeCheckKinds[Data->TypeCheckKind] << Data->Type;\n+  else if (Data->Alignment && (Pointer & (Data->Alignment - 1)))\n+    Diag(Loc, DL_Error, \"%0 misaligned address %1 for type %3, \"\n+                        \"which requires %2 byte alignment\")\n+      << TypeCheckKinds[Data->TypeCheckKind] << (void*)Pointer\n+      << Data->Alignment << Data->Type;\n+  else\n+    Diag(Loc, DL_Error, \"%0 address %1 with insufficient space \"\n+                        \"for an object of type %2\")\n+      << TypeCheckKinds[Data->TypeCheckKind] << (void*)Pointer << Data->Type;\n+  if (Pointer)\n+    Diag(Pointer, DL_Note, \"pointer points here\");\n+}\n+void __ubsan::__ubsan_handle_type_mismatch(TypeMismatchData *Data,\n+                                           ValueHandle Pointer) {\n+  handleTypeMismatchImpl(Data, Pointer, getCallerLocation());\n+}\n+void __ubsan::__ubsan_handle_type_mismatch_abort(TypeMismatchData *Data,\n+                                                 ValueHandle Pointer) {\n+  handleTypeMismatchImpl(Data, Pointer, getCallerLocation());\n+  Die();\n+}\n+\n+/// \\brief Common diagnostic emission for various forms of integer overflow.\n+template<typename T> static void HandleIntegerOverflow(OverflowData *Data,\n+                                                       ValueHandle LHS,\n+                                                       const char *Operator,\n+                                                       T RHS) {\n+  SourceLocation Loc = Data->Loc.acquire();\n+  if (Loc.isDisabled())\n+    return;\n+\n+  Diag(Loc, DL_Error, \"%0 integer overflow: \"\n+                      \"%1 %2 %3 cannot be represented in type %4\")\n+    << (Data->Type.isSignedIntegerTy() ? \"signed\" : \"unsigned\")\n+    << Value(Data->Type, LHS) << Operator << RHS << Data->Type;\n+}\n+\n+void __ubsan::__ubsan_handle_add_overflow(OverflowData *Data,\n+                                          ValueHandle LHS, ValueHandle RHS) {\n+  HandleIntegerOverflow(Data, LHS, \"+\", Value(Data->Type, RHS));\n+}\n+void __ubsan::__ubsan_handle_add_overflow_abort(OverflowData *Data,\n+                                                 ValueHandle LHS,\n+                                                 ValueHandle RHS) {\n+  __ubsan_handle_add_overflow(Data, LHS, RHS);\n+  Die();\n+}\n+\n+void __ubsan::__ubsan_handle_sub_overflow(OverflowData *Data,\n+                                          ValueHandle LHS, ValueHandle RHS) {\n+  HandleIntegerOverflow(Data, LHS, \"-\", Value(Data->Type, RHS));\n+}\n+void __ubsan::__ubsan_handle_sub_overflow_abort(OverflowData *Data,\n+                                                 ValueHandle LHS,\n+                                                 ValueHandle RHS) {\n+  __ubsan_handle_sub_overflow(Data, LHS, RHS);\n+  Die();\n+}\n+\n+void __ubsan::__ubsan_handle_mul_overflow(OverflowData *Data,\n+                                          ValueHandle LHS, ValueHandle RHS) {\n+  HandleIntegerOverflow(Data, LHS, \"*\", Value(Data->Type, RHS));\n+}\n+void __ubsan::__ubsan_handle_mul_overflow_abort(OverflowData *Data,\n+                                                 ValueHandle LHS,\n+                                                 ValueHandle RHS) {\n+  __ubsan_handle_mul_overflow(Data, LHS, RHS);\n+  Die();\n+}\n+\n+void __ubsan::__ubsan_handle_negate_overflow(OverflowData *Data,\n+                                             ValueHandle OldVal) {\n+  SourceLocation Loc = Data->Loc.acquire();\n+  if (Loc.isDisabled())\n+    return;\n+\n+  if (Data->Type.isSignedIntegerTy())\n+    Diag(Loc, DL_Error,\n+         \"negation of %0 cannot be represented in type %1; \"\n+         \"cast to an unsigned type to negate this value to itself\")\n+      << Value(Data->Type, OldVal) << Data->Type;\n+  else\n+    Diag(Loc, DL_Error,\n+         \"negation of %0 cannot be represented in type %1\")\n+      << Value(Data->Type, OldVal) << Data->Type;\n+}\n+void __ubsan::__ubsan_handle_negate_overflow_abort(OverflowData *Data,\n+                                                    ValueHandle OldVal) {\n+  __ubsan_handle_negate_overflow(Data, OldVal);\n+  Die();\n+}\n+\n+void __ubsan::__ubsan_handle_divrem_overflow(OverflowData *Data,\n+                                             ValueHandle LHS, ValueHandle RHS) {\n+  SourceLocation Loc = Data->Loc.acquire();\n+  if (Loc.isDisabled())\n+    return;\n+\n+  Value LHSVal(Data->Type, LHS);\n+  Value RHSVal(Data->Type, RHS);\n+  if (RHSVal.isMinusOne())\n+    Diag(Loc, DL_Error,\n+         \"division of %0 by -1 cannot be represented in type %1\")\n+      << LHSVal << Data->Type;\n+  else\n+    Diag(Loc, DL_Error, \"division by zero\");\n+}\n+void __ubsan::__ubsan_handle_divrem_overflow_abort(OverflowData *Data,\n+                                                    ValueHandle LHS,\n+                                                    ValueHandle RHS) {\n+  __ubsan_handle_divrem_overflow(Data, LHS, RHS);\n+  Die();\n+}\n+\n+void __ubsan::__ubsan_handle_shift_out_of_bounds(ShiftOutOfBoundsData *Data,\n+                                                 ValueHandle LHS,\n+                                                 ValueHandle RHS) {\n+  SourceLocation Loc = Data->Loc.acquire();\n+  if (Loc.isDisabled())\n+    return;\n+\n+  Value LHSVal(Data->LHSType, LHS);\n+  Value RHSVal(Data->RHSType, RHS);\n+  if (RHSVal.isNegative())\n+    Diag(Loc, DL_Error, \"shift exponent %0 is negative\") << RHSVal;\n+  else if (RHSVal.getPositiveIntValue() >= Data->LHSType.getIntegerBitWidth())\n+    Diag(Loc, DL_Error,\n+         \"shift exponent %0 is too large for %1-bit type %2\")\n+      << RHSVal << Data->LHSType.getIntegerBitWidth() << Data->LHSType;\n+  else if (LHSVal.isNegative())\n+    Diag(Loc, DL_Error, \"left shift of negative value %0\") << LHSVal;\n+  else\n+    Diag(Loc, DL_Error,\n+         \"left shift of %0 by %1 places cannot be represented in type %2\")\n+      << LHSVal << RHSVal << Data->LHSType;\n+}\n+void __ubsan::__ubsan_handle_shift_out_of_bounds_abort(\n+                                                     ShiftOutOfBoundsData *Data,\n+                                                     ValueHandle LHS,\n+                                                     ValueHandle RHS) {\n+  __ubsan_handle_shift_out_of_bounds(Data, LHS, RHS);\n+  Die();\n+}\n+\n+void __ubsan::__ubsan_handle_out_of_bounds(OutOfBoundsData *Data,\n+                                           ValueHandle Index) {\n+  SourceLocation Loc = Data->Loc.acquire();\n+  if (Loc.isDisabled())\n+    return;\n+\n+  Value IndexVal(Data->IndexType, Index);\n+  Diag(Loc, DL_Error, \"index %0 out of bounds for type %1\")\n+    << IndexVal << Data->ArrayType;\n+}\n+void __ubsan::__ubsan_handle_out_of_bounds_abort(OutOfBoundsData *Data,\n+                                                 ValueHandle Index) {\n+  __ubsan_handle_out_of_bounds(Data, Index);\n+  Die();\n+}\n+\n+void __ubsan::__ubsan_handle_builtin_unreachable(UnreachableData *Data) {\n+  Diag(Data->Loc, DL_Error, \"execution reached a __builtin_unreachable() call\");\n+  Die();\n+}\n+\n+void __ubsan::__ubsan_handle_missing_return(UnreachableData *Data) {\n+  Diag(Data->Loc, DL_Error,\n+       \"execution reached the end of a value-returning function \"\n+       \"without returning a value\");\n+  Die();\n+}\n+\n+void __ubsan::__ubsan_handle_vla_bound_not_positive(VLABoundData *Data,\n+                                                    ValueHandle Bound) {\n+  SourceLocation Loc = Data->Loc.acquire();\n+  if (Loc.isDisabled())\n+    return;\n+\n+  Diag(Loc, DL_Error, \"variable length array bound evaluates to \"\n+                      \"non-positive value %0\")\n+    << Value(Data->Type, Bound);\n+}\n+void __ubsan::__ubsan_handle_vla_bound_not_positive_abort(VLABoundData *Data,\n+                                                           ValueHandle Bound) {\n+  __ubsan_handle_vla_bound_not_positive(Data, Bound);\n+  Die();\n+}\n+\n+\n+void __ubsan::__ubsan_handle_float_cast_overflow(FloatCastOverflowData *Data,\n+                                                 ValueHandle From) {\n+  // TODO: Add deduplication once a SourceLocation is generated for this check.\n+  Diag(getCallerLocation(), DL_Error,\n+       \"value %0 is outside the range of representable values of type %2\")\n+    << Value(Data->FromType, From) << Data->FromType << Data->ToType;\n+}\n+void __ubsan::__ubsan_handle_float_cast_overflow_abort(\n+                                                    FloatCastOverflowData *Data,\n+                                                    ValueHandle From) {\n+  Diag(getCallerLocation(), DL_Error,\n+       \"value %0 is outside the range of representable values of type %2\")\n+    << Value(Data->FromType, From) << Data->FromType << Data->ToType;\n+  Die();\n+}\n+\n+void __ubsan::__ubsan_handle_load_invalid_value(InvalidValueData *Data,\n+                                                ValueHandle Val) {\n+  // TODO: Add deduplication once a SourceLocation is generated for this check.\n+  Diag(getCallerLocation(), DL_Error,\n+       \"load of value %0, which is not a valid value for type %1\")\n+    << Value(Data->Type, Val) << Data->Type;\n+}\n+void __ubsan::__ubsan_handle_load_invalid_value_abort(InvalidValueData *Data,\n+                                                      ValueHandle Val) {\n+  Diag(getCallerLocation(), DL_Error,\n+       \"load of value %0, which is not a valid value for type %1\")\n+    << Value(Data->Type, Val) << Data->Type;\n+  Die();\n+}"}, {"sha": "034edf590216676216e85c82611dcd149102cc9f", "filename": "libsanitizer/ubsan/ubsan_handlers.h", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2Fubsan_handlers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2Fubsan_handlers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.h?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,115 @@\n+//===-- ubsan_handlers.h ----------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Entry points to the runtime library for Clang's undefined behavior sanitizer.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef UBSAN_HANDLERS_H\n+#define UBSAN_HANDLERS_H\n+\n+#include \"ubsan_value.h\"\n+\n+namespace __ubsan {\n+\n+struct TypeMismatchData {\n+  SourceLocation Loc;\n+  const TypeDescriptor &Type;\n+  uptr Alignment;\n+  unsigned char TypeCheckKind;\n+};\n+\n+#define RECOVERABLE(checkname, ...) \\\n+  extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE \\\n+    void __ubsan_handle_ ## checkname( __VA_ARGS__ ); \\\n+  extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE \\\n+    void __ubsan_handle_ ## checkname ## _abort( __VA_ARGS__ );\n+\n+/// \\brief Handle a runtime type check failure, caused by either a misaligned\n+/// pointer, a null pointer, or a pointer to insufficient storage for the\n+/// type.\n+RECOVERABLE(type_mismatch, TypeMismatchData *Data, ValueHandle Pointer)\n+\n+struct OverflowData {\n+  SourceLocation Loc;\n+  const TypeDescriptor &Type;\n+};\n+\n+/// \\brief Handle an integer addition overflow.\n+RECOVERABLE(add_overflow, OverflowData *Data, ValueHandle LHS, ValueHandle RHS)\n+\n+/// \\brief Handle an integer subtraction overflow.\n+RECOVERABLE(sub_overflow, OverflowData *Data, ValueHandle LHS, ValueHandle RHS)\n+\n+/// \\brief Handle an integer multiplication overflow.\n+RECOVERABLE(mul_overflow, OverflowData *Data, ValueHandle LHS, ValueHandle RHS)\n+\n+/// \\brief Handle a signed integer overflow for a unary negate operator.\n+RECOVERABLE(negate_overflow, OverflowData *Data, ValueHandle OldVal)\n+\n+/// \\brief Handle an INT_MIN/-1 overflow or division by zero.\n+RECOVERABLE(divrem_overflow, OverflowData *Data,\n+            ValueHandle LHS, ValueHandle RHS)\n+\n+struct ShiftOutOfBoundsData {\n+  SourceLocation Loc;\n+  const TypeDescriptor &LHSType;\n+  const TypeDescriptor &RHSType;\n+};\n+\n+/// \\brief Handle a shift where the RHS is out of bounds or a left shift where\n+/// the LHS is negative or overflows.\n+RECOVERABLE(shift_out_of_bounds, ShiftOutOfBoundsData *Data,\n+            ValueHandle LHS, ValueHandle RHS)\n+\n+struct OutOfBoundsData {\n+  SourceLocation Loc;\n+  const TypeDescriptor &ArrayType;\n+  const TypeDescriptor &IndexType;\n+};\n+\n+/// \\brief Handle an array index out of bounds error.\n+RECOVERABLE(out_of_bounds, OutOfBoundsData *Data, ValueHandle Index)\n+\n+struct UnreachableData {\n+  SourceLocation Loc;\n+};\n+\n+/// \\brief Handle a __builtin_unreachable which is reached.\n+extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\n+void __ubsan_handle_builtin_unreachable(UnreachableData *Data);\n+/// \\brief Handle reaching the end of a value-returning function.\n+extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\n+void __ubsan_handle_missing_return(UnreachableData *Data);\n+\n+struct VLABoundData {\n+  SourceLocation Loc;\n+  const TypeDescriptor &Type;\n+};\n+\n+/// \\brief Handle a VLA with a non-positive bound.\n+RECOVERABLE(vla_bound_not_positive, VLABoundData *Data, ValueHandle Bound)\n+\n+struct FloatCastOverflowData {\n+  // FIXME: SourceLocation Loc;\n+  const TypeDescriptor &FromType;\n+  const TypeDescriptor &ToType;\n+};\n+\n+/// \\brief Handle overflow in a conversion to or from a floating-point type.\n+RECOVERABLE(float_cast_overflow, FloatCastOverflowData *Data, ValueHandle From)\n+\n+struct InvalidValueData {\n+  // FIXME: SourceLocation Loc;\n+  const TypeDescriptor &Type;\n+};\n+\n+/// \\brief Handle a load of an invalid value for the type.\n+RECOVERABLE(load_invalid_value, InvalidValueData *Data, ValueHandle Val)\n+\n+}\n+\n+#endif // UBSAN_HANDLERS_H"}, {"sha": "bb43cc75cfc69feff4055b8bbf951f28e71ffb44", "filename": "libsanitizer/ubsan/ubsan_handlers_cxx.cc", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.cc?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,72 @@\n+//===-- ubsan_handlers_cxx.cc ---------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Error logging entry points for the UBSan runtime, which are only used for C++\n+// compilations. This file is permitted to use language features which require\n+// linking against a C++ ABI library.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"ubsan_handlers_cxx.h\"\n+#include \"ubsan_diag.h\"\n+#include \"ubsan_type_hash.h\"\n+\n+#include \"sanitizer_common/sanitizer_common.h\"\n+\n+using namespace __sanitizer;\n+using namespace __ubsan;\n+\n+namespace __ubsan {\n+  extern const char *TypeCheckKinds[];\n+}\n+\n+static void HandleDynamicTypeCacheMiss(\n+    DynamicTypeCacheMissData *Data, ValueHandle Pointer, ValueHandle Hash,\n+    bool Abort) {\n+  if (checkDynamicType((void*)Pointer, Data->TypeInfo, Hash))\n+    // Just a cache miss. The type matches after all.\n+    return;\n+\n+  SourceLocation Loc = Data->Loc.acquire();\n+  if (Loc.isDisabled())\n+    return;\n+\n+  Diag(Loc, DL_Error,\n+       \"%0 address %1 which does not point to an object of type %2\")\n+    << TypeCheckKinds[Data->TypeCheckKind] << (void*)Pointer << Data->Type;\n+\n+  // If possible, say what type it actually points to.\n+  DynamicTypeInfo DTI = getDynamicTypeInfo((void*)Pointer);\n+  if (!DTI.isValid())\n+    Diag(Pointer, DL_Note, \"object has invalid vptr\")\n+      << MangledName(DTI.getMostDerivedTypeName())\n+      << Range(Pointer, Pointer + sizeof(uptr), \"invalid vptr\");\n+  else if (!DTI.getOffset())\n+    Diag(Pointer, DL_Note, \"object is of type %0\")\n+      << MangledName(DTI.getMostDerivedTypeName())\n+      << Range(Pointer, Pointer + sizeof(uptr), \"vptr for %0\");\n+  else\n+    // FIXME: Find the type at the specified offset, and include that\n+    //        in the note.\n+    Diag(Pointer - DTI.getOffset(), DL_Note,\n+         \"object is base class subobject at offset %0 within object of type %1\")\n+      << DTI.getOffset() << MangledName(DTI.getMostDerivedTypeName())\n+      << MangledName(DTI.getSubobjectTypeName())\n+      << Range(Pointer, Pointer + sizeof(uptr), \"vptr for %2 base class of %1\");\n+\n+  if (Abort)\n+    Die();\n+}\n+\n+void __ubsan::__ubsan_handle_dynamic_type_cache_miss(\n+    DynamicTypeCacheMissData *Data, ValueHandle Pointer, ValueHandle Hash) {\n+  HandleDynamicTypeCacheMiss(Data, Pointer, Hash, false);\n+}\n+void __ubsan::__ubsan_handle_dynamic_type_cache_miss_abort(\n+    DynamicTypeCacheMissData *Data, ValueHandle Pointer, ValueHandle Hash) {\n+  HandleDynamicTypeCacheMiss(Data, Pointer, Hash, true);\n+}"}, {"sha": "3419744e390f06b703571ca9d8e99474a960513b", "filename": "libsanitizer/ubsan/ubsan_handlers_cxx.h", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.h?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,38 @@\n+//===-- ubsan_handlers_cxx.h ------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Entry points to the runtime library for Clang's undefined behavior sanitizer,\n+// for C++-specific checks. This code is not linked into C binaries.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef UBSAN_HANDLERS_CXX_H\n+#define UBSAN_HANDLERS_CXX_H\n+\n+#include \"ubsan_value.h\"\n+\n+namespace __ubsan {\n+\n+struct DynamicTypeCacheMissData {\n+  SourceLocation Loc;\n+  const TypeDescriptor &Type;\n+  void *TypeInfo;\n+  unsigned char TypeCheckKind;\n+};\n+\n+/// \\brief Handle a runtime type check failure, caused by an incorrect vptr.\n+/// When this handler is called, all we know is that the type was not in the\n+/// cache; this does not necessarily imply the existence of a bug.\n+extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\n+void __ubsan_handle_dynamic_type_cache_miss(\n+  DynamicTypeCacheMissData *Data, ValueHandle Pointer, ValueHandle Hash);\n+extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\n+void __ubsan_handle_dynamic_type_cache_miss_abort(\n+  DynamicTypeCacheMissData *Data, ValueHandle Pointer, ValueHandle Hash);\n+\n+}\n+\n+#endif // UBSAN_HANDLERS_H"}, {"sha": "440d3ad89c63544728d412d87daca7364853fc4a", "filename": "libsanitizer/ubsan/ubsan_type_hash.cc", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2Fubsan_type_hash.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2Fubsan_type_hash.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_type_hash.cc?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,246 @@\n+//===-- ubsan_type_hash.cc ------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Implementation of a hash table for fast checking of inheritance\n+// relationships. This file is only linked into C++ compilations, and is\n+// permitted to use language features which require a C++ ABI library.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"ubsan_type_hash.h\"\n+\n+#include \"sanitizer_common/sanitizer_common.h\"\n+\n+// The following are intended to be binary compatible with the definitions\n+// given in the Itanium ABI. We make no attempt to be ODR-compatible with\n+// those definitions, since existing ABI implementations aren't.\n+\n+namespace std {\n+  class type_info {\n+  public:\n+    virtual ~type_info();\n+\n+    const char *__type_name;\n+  };\n+}\n+\n+namespace __cxxabiv1 {\n+\n+/// Type info for classes with no bases, and base class for type info for\n+/// classes with bases.\n+class __class_type_info : public std::type_info {\n+  virtual ~__class_type_info();\n+};\n+\n+/// Type info for classes with simple single public inheritance.\n+class __si_class_type_info : public __class_type_info {\n+public:\n+  virtual ~__si_class_type_info();\n+\n+  const __class_type_info *__base_type;\n+};\n+\n+class __base_class_type_info {\n+public:\n+  const __class_type_info *__base_type;\n+  long __offset_flags;\n+\n+  enum __offset_flags_masks {\n+    __virtual_mask = 0x1,\n+    __public_mask = 0x2,\n+    __offset_shift = 8\n+  };\n+};\n+\n+/// Type info for classes with multiple, virtual, or non-public inheritance.\n+class __vmi_class_type_info : public __class_type_info {\n+public:\n+  virtual ~__vmi_class_type_info();\n+\n+  unsigned int flags;\n+  unsigned int base_count;\n+  __base_class_type_info base_info[1];\n+};\n+\n+}\n+\n+namespace abi = __cxxabiv1;\n+\n+// We implement a simple two-level cache for type-checking results. For each\n+// (vptr,type) pair, a hash is computed. This hash is assumed to be globally\n+// unique; if it collides, we will get false negatives, but:\n+//  * such a collision would have to occur on the *first* bad access,\n+//  * the probability of such a collision is low (and for a 64-bit target, is\n+//    negligible), and\n+//  * the vptr, and thus the hash, can be affected by ASLR, so multiple runs\n+//    give better coverage.\n+//\n+// The first caching layer is a small hash table with no chaining; buckets are\n+// reused as needed. The second caching layer is a large hash table with open\n+// chaining. We can freely evict from either layer since this is just a cache.\n+//\n+// FIXME: Make these hash table accesses thread-safe. The races here are benign\n+//        (worst-case, we could miss a bug or see a slowdown) but we should\n+//        avoid upsetting race detectors.\n+\n+/// Find a bucket to store the given hash value in.\n+static __ubsan::HashValue *getTypeCacheHashTableBucket(__ubsan::HashValue V) {\n+  static const unsigned HashTableSize = 65537;\n+  static __ubsan::HashValue __ubsan_vptr_hash_set[HashTableSize] = { 1 };\n+\n+  unsigned Probe = V & 65535;\n+  for (int Tries = 5; Tries; --Tries) {\n+    if (!__ubsan_vptr_hash_set[Probe] || __ubsan_vptr_hash_set[Probe] == V)\n+      return &__ubsan_vptr_hash_set[Probe];\n+    Probe += ((V >> 16) & 65535) + 1;\n+    if (Probe >= HashTableSize)\n+      Probe -= HashTableSize;\n+  }\n+  // FIXME: Pick a random entry from the probe sequence to evict rather than\n+  //        just taking the first.\n+  return &__ubsan_vptr_hash_set[V];\n+}\n+\n+/// A cache of recently-checked hashes. Mini hash table with \"random\" evictions.\n+__ubsan::HashValue\n+__ubsan::__ubsan_vptr_type_cache[__ubsan::VptrTypeCacheSize] = { 1 };\n+\n+/// \\brief Determine whether \\p Derived has a \\p Base base class subobject at\n+/// offset \\p Offset.\n+static bool isDerivedFromAtOffset(const abi::__class_type_info *Derived,\n+                                  const abi::__class_type_info *Base,\n+                                  sptr Offset) {\n+  if (Derived->__type_name == Base->__type_name)\n+    return Offset == 0;\n+\n+  if (const abi::__si_class_type_info *SI =\n+        dynamic_cast<const abi::__si_class_type_info*>(Derived))\n+    return isDerivedFromAtOffset(SI->__base_type, Base, Offset);\n+\n+  const abi::__vmi_class_type_info *VTI =\n+    dynamic_cast<const abi::__vmi_class_type_info*>(Derived);\n+  if (!VTI)\n+    // No base class subobjects.\n+    return false;\n+\n+  // Look for a base class which is derived from \\p Base at the right offset.\n+  for (unsigned int base = 0; base != VTI->base_count; ++base) {\n+    // FIXME: Curtail the recursion if this base can't possibly contain the\n+    //        given offset.\n+    sptr OffsetHere = VTI->base_info[base].__offset_flags >>\n+                      abi::__base_class_type_info::__offset_shift;\n+    if (VTI->base_info[base].__offset_flags &\n+          abi::__base_class_type_info::__virtual_mask)\n+      // For now, just punt on virtual bases and say 'yes'.\n+      // FIXME: OffsetHere is the offset in the vtable of the virtual base\n+      //        offset. Read the vbase offset out of the vtable and use it.\n+      return true;\n+    if (isDerivedFromAtOffset(VTI->base_info[base].__base_type,\n+                              Base, Offset - OffsetHere))\n+      return true;\n+  }\n+\n+  return false;\n+}\n+\n+/// \\brief Find the derived-most dynamic base class of \\p Derived at offset\n+/// \\p Offset.\n+static const abi::__class_type_info *findBaseAtOffset(\n+    const abi::__class_type_info *Derived, sptr Offset) {\n+  if (!Offset)\n+    return Derived;\n+\n+  if (const abi::__si_class_type_info *SI =\n+        dynamic_cast<const abi::__si_class_type_info*>(Derived))\n+    return findBaseAtOffset(SI->__base_type, Offset);\n+\n+  const abi::__vmi_class_type_info *VTI =\n+    dynamic_cast<const abi::__vmi_class_type_info*>(Derived);\n+  if (!VTI)\n+    // No base class subobjects.\n+    return 0;\n+\n+  for (unsigned int base = 0; base != VTI->base_count; ++base) {\n+    sptr OffsetHere = VTI->base_info[base].__offset_flags >>\n+                      abi::__base_class_type_info::__offset_shift;\n+    if (VTI->base_info[base].__offset_flags &\n+          abi::__base_class_type_info::__virtual_mask)\n+      // FIXME: Can't handle virtual bases yet.\n+      continue;\n+    if (const abi::__class_type_info *Base =\n+          findBaseAtOffset(VTI->base_info[base].__base_type,\n+                           Offset - OffsetHere))\n+      return Base;\n+  }\n+\n+  return 0;\n+}\n+\n+namespace {\n+\n+struct VtablePrefix {\n+  /// The offset from the vptr to the start of the most-derived object.\n+  /// This should never be greater than zero, and will usually be exactly\n+  /// zero.\n+  sptr Offset;\n+  /// The type_info object describing the most-derived class type.\n+  std::type_info *TypeInfo;\n+};\n+VtablePrefix *getVtablePrefix(void *Object) {\n+  VtablePrefix **VptrPtr = reinterpret_cast<VtablePrefix**>(Object);\n+  if (!*VptrPtr)\n+    return 0;\n+  VtablePrefix *Prefix = *VptrPtr - 1;\n+  if (Prefix->Offset > 0 || !Prefix->TypeInfo)\n+    // This can't possibly be a valid vtable.\n+    return 0;\n+  return Prefix;\n+}\n+\n+}\n+\n+bool __ubsan::checkDynamicType(void *Object, void *Type, HashValue Hash) {\n+  // A crash anywhere within this function probably means the vptr is corrupted.\n+  // FIXME: Perform these checks more cautiously.\n+\n+  // Check whether this is something we've evicted from the cache.\n+  HashValue *Bucket = getTypeCacheHashTableBucket(Hash);\n+  if (*Bucket == Hash) {\n+    __ubsan_vptr_type_cache[Hash % VptrTypeCacheSize] = Hash;\n+    return true;\n+  }\n+\n+  VtablePrefix *Vtable = getVtablePrefix(Object);\n+  if (!Vtable)\n+    return false;\n+\n+  // Check that this is actually a type_info object for a class type.\n+  abi::__class_type_info *Derived =\n+    dynamic_cast<abi::__class_type_info*>(Vtable->TypeInfo);\n+  if (!Derived)\n+    return false;\n+\n+  abi::__class_type_info *Base = (abi::__class_type_info*)Type;\n+  if (!isDerivedFromAtOffset(Derived, Base, -Vtable->Offset))\n+    return false;\n+\n+  // Success. Cache this result.\n+  __ubsan_vptr_type_cache[Hash % VptrTypeCacheSize] = Hash;\n+  *Bucket = Hash;\n+  return true;\n+}\n+\n+__ubsan::DynamicTypeInfo __ubsan::getDynamicTypeInfo(void *Object) {\n+  VtablePrefix *Vtable = getVtablePrefix(Object);\n+  if (!Vtable)\n+    return DynamicTypeInfo(0, 0, 0);\n+  const abi::__class_type_info *ObjectType = findBaseAtOffset(\n+    static_cast<const abi::__class_type_info*>(Vtable->TypeInfo),\n+    -Vtable->Offset);\n+  return DynamicTypeInfo(Vtable->TypeInfo->__type_name, -Vtable->Offset,\n+                         ObjectType ? ObjectType->__type_name : \"<unknown>\");\n+}"}, {"sha": "138559f204dd0c1f3efff970e8872b9d9bff3175", "filename": "libsanitizer/ubsan/ubsan_type_hash.h", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2Fubsan_type_hash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2Fubsan_type_hash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_type_hash.h?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,61 @@\n+//===-- ubsan_type_hash.h ---------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Hashing of types for Clang's undefined behavior checker.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef UBSAN_TYPE_HASH_H\n+#define UBSAN_TYPE_HASH_H\n+\n+#include \"sanitizer_common/sanitizer_common.h\"\n+\n+namespace __ubsan {\n+\n+typedef uptr HashValue;\n+\n+/// \\brief Information about the dynamic type of an object (extracted from its\n+/// vptr).\n+class DynamicTypeInfo {\n+  const char *MostDerivedTypeName;\n+  sptr Offset;\n+  const char *SubobjectTypeName;\n+\n+public:\n+  DynamicTypeInfo(const char *MDTN, sptr Offset, const char *STN)\n+    : MostDerivedTypeName(MDTN), Offset(Offset), SubobjectTypeName(STN) {}\n+\n+  /// Determine whether the object had a valid dynamic type.\n+  bool isValid() const { return MostDerivedTypeName; }\n+  /// Get the name of the most-derived type of the object.\n+  const char *getMostDerivedTypeName() const { return MostDerivedTypeName; }\n+  /// Get the offset from the most-derived type to this base class.\n+  sptr getOffset() const { return Offset; }\n+  /// Get the name of the most-derived type at the specified offset.\n+  const char *getSubobjectTypeName() const { return SubobjectTypeName; }\n+};\n+\n+/// \\brief Get information about the dynamic type of an object.\n+DynamicTypeInfo getDynamicTypeInfo(void *Object);\n+\n+/// \\brief Check whether the dynamic type of \\p Object has a \\p Type subobject\n+/// at offset 0.\n+/// \\return \\c true if the type matches, \\c false if not.\n+bool checkDynamicType(void *Object, void *Type, HashValue Hash);\n+\n+const unsigned VptrTypeCacheSize = 128;\n+\n+/// \\brief A cache of the results of checkDynamicType. \\c checkDynamicType would\n+/// return \\c true (modulo hash collisions) if\n+/// \\code\n+///   __ubsan_vptr_type_cache[Hash % VptrTypeCacheSize] == Hash\n+/// \\endcode\n+extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\n+HashValue __ubsan_vptr_type_cache[VptrTypeCacheSize];\n+\n+} // namespace __ubsan\n+\n+#endif // UBSAN_TYPE_HASH_H"}, {"sha": "141e8b53504ef1662389dde195ecf1d369550e6c", "filename": "libsanitizer/ubsan/ubsan_value.cc", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2Fubsan_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2Fubsan_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_value.cc?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,99 @@\n+//===-- ubsan_value.cc ----------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Representation of a runtime value, as marshaled from the generated code to\n+// the ubsan runtime.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"ubsan_value.h\"\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+\n+using namespace __ubsan;\n+\n+SIntMax Value::getSIntValue() const {\n+  CHECK(getType().isSignedIntegerTy());\n+  if (isInlineInt()) {\n+    // Val was zero-extended to ValueHandle. Sign-extend from original width\n+    // to SIntMax.\n+    const unsigned ExtraBits =\n+      sizeof(SIntMax) * 8 - getType().getIntegerBitWidth();\n+    return SIntMax(Val) << ExtraBits >> ExtraBits;\n+  }\n+  if (getType().getIntegerBitWidth() == 64)\n+    return *reinterpret_cast<s64*>(Val);\n+#if HAVE_INT128_T\n+  if (getType().getIntegerBitWidth() == 128)\n+    return *reinterpret_cast<s128*>(Val);\n+#else\n+  if (getType().getIntegerBitWidth() == 128)\n+    UNREACHABLE(\"libclang_rt.ubsan was built without __int128 support\");\n+#endif\n+  UNREACHABLE(\"unexpected bit width\");\n+}\n+\n+UIntMax Value::getUIntValue() const {\n+  CHECK(getType().isUnsignedIntegerTy());\n+  if (isInlineInt())\n+    return Val;\n+  if (getType().getIntegerBitWidth() == 64)\n+    return *reinterpret_cast<u64*>(Val);\n+#if HAVE_INT128_T\n+  if (getType().getIntegerBitWidth() == 128)\n+    return *reinterpret_cast<u128*>(Val);\n+#else\n+  if (getType().getIntegerBitWidth() == 128)\n+    UNREACHABLE(\"libclang_rt.ubsan was built without __int128 support\");\n+#endif\n+  UNREACHABLE(\"unexpected bit width\");\n+}\n+\n+UIntMax Value::getPositiveIntValue() const {\n+  if (getType().isUnsignedIntegerTy())\n+    return getUIntValue();\n+  SIntMax Val = getSIntValue();\n+  CHECK(Val >= 0);\n+  return Val;\n+}\n+\n+/// Get the floating-point value of this object, extended to a long double.\n+/// These are always passed by address (our calling convention doesn't allow\n+/// them to be passed in floating-point registers, so this has little cost).\n+FloatMax Value::getFloatValue() const {\n+  CHECK(getType().isFloatTy());\n+  if (isInlineFloat()) {\n+    switch (getType().getFloatBitWidth()) {\n+#if 0\n+      // FIXME: OpenCL / NEON 'half' type. LLVM can't lower the conversion\n+      //        from '__fp16' to 'long double'.\n+      case 16: {\n+        __fp16 Value;\n+        internal_memcpy(&Value, &Val, 4);\n+        return Value;\n+      }\n+#endif\n+      case 32: {\n+        float Value;\n+        internal_memcpy(&Value, &Val, 4);\n+        return Value;\n+      }\n+      case 64: {\n+        double Value;\n+        internal_memcpy(&Value, &Val, 8);\n+        return Value;\n+      }\n+    }\n+  } else {\n+    switch (getType().getFloatBitWidth()) {\n+    case 64: return *reinterpret_cast<double*>(Val);\n+    case 80: return *reinterpret_cast<long double*>(Val);\n+    case 128: return *reinterpret_cast<long double*>(Val);\n+    }\n+  }\n+  UNREACHABLE(\"unexpected floating point bit width\");\n+}"}, {"sha": "6ca0f56c99d01d95a9e6d67e38321d0cb4c59ee8", "filename": "libsanitizer/ubsan/ubsan_value.h", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2Fubsan_value.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5a5fa1395db2cb5da4d0593fef40ec22378576/libsanitizer%2Fubsan%2Fubsan_value.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_value.h?ref=de5a5fa1395db2cb5da4d0593fef40ec22378576", "patch": "@@ -0,0 +1,202 @@\n+//===-- ubsan_value.h -------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Representation of data which is passed from the compiler-generated calls into\n+// the ubsan runtime.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef UBSAN_VALUE_H\n+#define UBSAN_VALUE_H\n+\n+// For now, only support linux and darwin. Other platforms should be easy to\n+// add, and probably work as-is.\n+#if !defined(__linux__) && !defined(__APPLE__)\n+#error \"UBSan not supported for this platform!\"\n+#endif\n+\n+#include \"sanitizer_common/sanitizer_atomic.h\"\n+#include \"sanitizer_common/sanitizer_common.h\"\n+\n+// FIXME: Move this out to a config header.\n+#if __SIZEOF_INT128__\n+__extension__ typedef __int128 s128;\n+__extension__ typedef unsigned __int128 u128;\n+#define HAVE_INT128_T 1\n+#else\n+#define HAVE_INT128_T 0\n+#endif\n+\n+\n+namespace __ubsan {\n+\n+/// \\brief Largest integer types we support.\n+#if HAVE_INT128_T\n+typedef s128 SIntMax;\n+typedef u128 UIntMax;\n+#else\n+typedef s64 SIntMax;\n+typedef u64 UIntMax;\n+#endif\n+\n+/// \\brief Largest floating-point type we support.\n+typedef long double FloatMax;\n+\n+/// \\brief A description of a source location. This corresponds to Clang's\n+/// \\c PresumedLoc type.\n+class SourceLocation {\n+  const char *Filename;\n+  u32 Line;\n+  u32 Column;\n+\n+public:\n+  SourceLocation() : Filename(), Line(), Column() {}\n+  SourceLocation(const char *Filename, unsigned Line, unsigned Column)\n+    : Filename(Filename), Line(Line), Column(Column) {}\n+\n+  /// \\brief Determine whether the source location is known.\n+  bool isInvalid() const { return !Filename; }\n+\n+  /// \\brief Atomically acquire a copy, disabling original in-place.\n+  /// Exactly one call to acquire() returns a copy that isn't disabled.\n+  SourceLocation acquire() {\n+    u32 OldColumn = __sanitizer::atomic_exchange(\n+                        (__sanitizer::atomic_uint32_t *)&Column, ~u32(0),\n+                        __sanitizer::memory_order_relaxed);\n+    return SourceLocation(Filename, Line, OldColumn);\n+  }\n+\n+  /// \\brief Determine if this Location has been disabled.\n+  /// Disabled SourceLocations are invalid to use.\n+  bool isDisabled() {\n+    return Column == ~u32(0);\n+  }\n+\n+  /// \\brief Get the presumed filename for the source location.\n+  const char *getFilename() const { return Filename; }\n+  /// \\brief Get the presumed line number.\n+  unsigned getLine() const { return Line; }\n+  /// \\brief Get the column within the presumed line.\n+  unsigned getColumn() const { return Column; }\n+};\n+\n+\n+/// \\brief A description of a type.\n+class TypeDescriptor {\n+  /// A value from the \\c Kind enumeration, specifying what flavor of type we\n+  /// have.\n+  u16 TypeKind;\n+\n+  /// A \\c Type-specific value providing information which allows us to\n+  /// interpret the meaning of a ValueHandle of this type.\n+  u16 TypeInfo;\n+\n+  /// The name of the type follows, in a format suitable for including in\n+  /// diagnostics.\n+  char TypeName[1];\n+\n+public:\n+  enum Kind {\n+    /// An integer type. Lowest bit is 1 for a signed value, 0 for an unsigned\n+    /// value. Remaining bits are log_2(bit width). The value representation is\n+    /// the integer itself if it fits into a ValueHandle, and a pointer to the\n+    /// integer otherwise.\n+    TK_Integer = 0x0000,\n+    /// A floating-point type. Low 16 bits are bit width. The value\n+    /// representation is that of bitcasting the floating-point value to an\n+    /// integer type.\n+    TK_Float = 0x0001,\n+    /// Any other type. The value representation is unspecified.\n+    TK_Unknown = 0xffff\n+  };\n+\n+  const char *getTypeName() const { return TypeName; }\n+\n+  Kind getKind() const {\n+    return static_cast<Kind>(TypeKind);\n+  }\n+\n+  bool isIntegerTy() const { return getKind() == TK_Integer; }\n+  bool isSignedIntegerTy() const {\n+    return isIntegerTy() && (TypeInfo & 1);\n+  }\n+  bool isUnsignedIntegerTy() const {\n+    return isIntegerTy() && !(TypeInfo & 1);\n+  }\n+  unsigned getIntegerBitWidth() const {\n+    CHECK(isIntegerTy());\n+    return 1 << (TypeInfo >> 1);\n+  }\n+\n+  bool isFloatTy() const { return getKind() == TK_Float; }\n+  unsigned getFloatBitWidth() const {\n+    CHECK(isFloatTy());\n+    return TypeInfo;\n+  }\n+};\n+\n+/// \\brief An opaque handle to a value.\n+typedef uptr ValueHandle;\n+\n+\n+/// \\brief Representation of an operand value provided by the instrumented code.\n+///\n+/// This is a combination of a TypeDescriptor (which is emitted as constant data\n+/// as an operand to a handler function) and a ValueHandle (which is passed at\n+/// runtime when a check failure occurs).\n+class Value {\n+  /// The type of the value.\n+  const TypeDescriptor &Type;\n+  /// The encoded value itself.\n+  ValueHandle Val;\n+\n+  /// Is \\c Val a (zero-extended) integer?\n+  bool isInlineInt() const {\n+    CHECK(getType().isIntegerTy());\n+    const unsigned InlineBits = sizeof(ValueHandle) * 8;\n+    const unsigned Bits = getType().getIntegerBitWidth();\n+    return Bits <= InlineBits;\n+  }\n+\n+  /// Is \\c Val a (zero-extended) integer representation of a float?\n+  bool isInlineFloat() const {\n+    CHECK(getType().isFloatTy());\n+    const unsigned InlineBits = sizeof(ValueHandle) * 8;\n+    const unsigned Bits = getType().getFloatBitWidth();\n+    return Bits <= InlineBits;\n+  }\n+\n+public:\n+  Value(const TypeDescriptor &Type, ValueHandle Val) : Type(Type), Val(Val) {}\n+\n+  const TypeDescriptor &getType() const { return Type; }\n+\n+  /// \\brief Get this value as a signed integer.\n+  SIntMax getSIntValue() const;\n+\n+  /// \\brief Get this value as an unsigned integer.\n+  UIntMax getUIntValue() const;\n+\n+  /// \\brief Decode this value, which must be a positive or unsigned integer.\n+  UIntMax getPositiveIntValue() const;\n+\n+  /// Is this an integer with value -1?\n+  bool isMinusOne() const {\n+    return getType().isSignedIntegerTy() && getSIntValue() == -1;\n+  }\n+\n+  /// Is this a negative integer?\n+  bool isNegative() const {\n+    return getType().isSignedIntegerTy() && getSIntValue() < 0;\n+  }\n+\n+  /// \\brief Get this value as a floating-point quantity.\n+  FloatMax getFloatValue() const;\n+};\n+\n+} // namespace __ubsan\n+\n+#endif // UBSAN_VALUE_H"}]}