{"sha": "3987b9db30f95cd055f68d302da8e9c474b6feea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk4N2I5ZGIzMGY5NWNkMDU1ZjY4ZDMwMmRhOGU5YzQ3NGI2ZmVlYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-01-10T10:21:30Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-01-10T10:21:30Z"}, "message": "optabs.c (expand_fix): Look for wider integer modes first.\n\n\t* optabs.c (expand_fix): Look for wider integer modes first.\n\n\t* i386.md (mov?f): Avoid the fake const double trick for medium\n\tmemory model.\n\t(min?f*/max?f*): Prohibit memory operands for i387 variant.\n\t(fop_df_4): Disable for SSE compilation.\n\nFrom-SVN: r48721", "tree": {"sha": "e5b6a50b27b2f10f3b1d39f0ed1204c4e8bbd21d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5b6a50b27b2f10f3b1d39f0ed1204c4e8bbd21d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3987b9db30f95cd055f68d302da8e9c474b6feea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3987b9db30f95cd055f68d302da8e9c474b6feea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3987b9db30f95cd055f68d302da8e9c474b6feea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3987b9db30f95cd055f68d302da8e9c474b6feea/comments", "author": null, "committer": null, "parents": [{"sha": "bccd793e46f58b737cb7592f22e2d21c6543b0d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bccd793e46f58b737cb7592f22e2d21c6543b0d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bccd793e46f58b737cb7592f22e2d21c6543b0d8"}], "stats": {"total": 36, "additions": 25, "deletions": 11}, "files": [{"sha": "ec68f0e86afde65aacf4e51a3fb4b5b2163e5f48", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3987b9db30f95cd055f68d302da8e9c474b6feea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3987b9db30f95cd055f68d302da8e9c474b6feea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3987b9db30f95cd055f68d302da8e9c474b6feea", "patch": "@@ -1,3 +1,12 @@\n+Thu Jan 10 11:19:18 CET 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* optabs.c (expand_fix): Look for wider integer modes first.\n+\n+\t* i386.md (mov?f): Avoid the fake const double trick for medium\n+\tmemory model.\n+\t(min?f*/max?f*): Prohibit memory operands for i387 variant.\n+\t(fop_df_4): Disable for SSE compilation.\n+\n 2002-01-20  Graham Stott  <grahams@redhat.com>\n \n \t* dwarf2out.c (indirect_string_alloc, output_indirect_string):"}, {"sha": "ec38dece3ea441142698d5d254177ea1c022ca9b", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3987b9db30f95cd055f68d302da8e9c474b6feea/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3987b9db30f95cd055f68d302da8e9c474b6feea/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=3987b9db30f95cd055f68d302da8e9c474b6feea", "patch": "@@ -2718,6 +2718,7 @@\n \t(match_operand:SF 1 \"general_operand\" \"fm#rx,f#rx,G,rmF#fx,Fr#fx,H,x,xm#rf,x#rf\"))]\n   \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n    && (reload_in_progress || reload_completed\n+       || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n        || GET_CODE (operands[1]) != CONST_DOUBLE\n        || memory_operand (operands[0], SFmode))\" \n {\n@@ -2893,6 +2894,7 @@\n   \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n    && (optimize_size || !TARGET_INTEGER_DFMODE_MOVES)\n    && (reload_in_progress || reload_completed\n+       || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n        || GET_CODE (operands[1]) != CONST_DOUBLE\n        || memory_operand (operands[0], DFmode))\" \n {\n@@ -2950,6 +2952,7 @@\n   \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n    && !optimize_size && TARGET_INTEGER_DFMODE_MOVES\n    && (reload_in_progress || reload_completed\n+       || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n        || GET_CODE (operands[1]) != CONST_DOUBLE\n        || memory_operand (operands[0], DFmode))\" \n {\n@@ -3253,6 +3256,7 @@\n    && optimize_size\n    && (reload_in_progress || reload_completed\n        || GET_CODE (operands[1]) != CONST_DOUBLE\n+       || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n        || memory_operand (operands[0], TFmode))\" \n {\n   switch (which_alternative)\n@@ -3346,6 +3350,7 @@\n    && !optimize_size\n    && (reload_in_progress || reload_completed\n        || GET_CODE (operands[1]) != CONST_DOUBLE\n+       || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n        || memory_operand (operands[0], TFmode))\" \n {\n   switch (which_alternative)\n@@ -14132,7 +14137,7 @@\n \t(match_operator:DF 3 \"binary_fp_operator\"\n \t   [(float_extend:DF (match_operand:SF 1 \"nonimmediate_operand\" \"fm,0\"))\n \t    (match_operand:DF 2 \"register_operand\" \"0,f\")]))]\n-  \"TARGET_80387\n+  \"TARGET_80387 && (!TARGET_SSE2 || !TARGET_SSE_MATH)\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n@@ -15962,7 +15967,7 @@\n (define_insn \"*minsf_nonieee\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=x#f,f#x\")\n \t(if_then_else:SF (lt (match_operand:SF 1 \"register_operand\" \"%0,0\")\n-\t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"xm#f,fm#x\"))\n+\t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"xm#f,f#x\"))\n \t\t\t (match_dup 1)\n \t\t\t (match_dup 2)))\n    (clobber (reg:CC 17))]\n@@ -16044,7 +16049,7 @@\n (define_insn \"*mindf_nonieee\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=Y#f,f#Y\")\n \t(if_then_else:DF (lt (match_operand:DF 1 \"register_operand\" \"%0,0\")\n-\t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"Ym#f,fm#Y\"))\n+\t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"Ym#f,f#Y\"))\n \t\t\t (match_dup 1)\n \t\t\t (match_dup 2)))\n    (clobber (reg:CC 17))]\n@@ -16115,7 +16120,7 @@\n (define_insn \"*maxsf\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=x#f,f#x,f#x\")\n \t(if_then_else:SF (gt (match_operand:SF 1 \"register_operand\" \"0,0,f#x\")\n-\t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"xm#f,fm#x,0\"))\n+\t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"xm#f,f#x,0\"))\n \t\t\t (match_dup 1)\n \t\t\t (match_dup 2)))\n    (clobber (reg:CC 17))]\n@@ -16125,7 +16130,7 @@\n (define_insn \"*maxsf_nonieee\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=x#f,f#x\")\n \t(if_then_else:SF (gt (match_operand:SF 1 \"register_operand\" \"%0,0\")\n-\t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"xm#f,fm#x\"))\n+\t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"xm#f,f#x\"))\n \t\t\t (match_dup 1)\n \t\t\t (match_dup 2)))\n    (clobber (reg:CC 17))]\n@@ -16195,7 +16200,7 @@\n (define_insn \"*maxdf\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=Y#f,f#Y,f#Y\")\n \t(if_then_else:DF (gt (match_operand:DF 1 \"register_operand\" \"0,0,f#Y\")\n-\t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"Ym#f,fm#Y,0\"))\n+\t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"Ym#f,f#Y,0\"))\n \t\t\t (match_dup 1)\n \t\t\t (match_dup 2)))\n    (clobber (reg:CC 17))]\n@@ -16205,7 +16210,7 @@\n (define_insn \"*maxdf_nonieee\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=Y#f,f#Y\")\n \t(if_then_else:DF (gt (match_operand:DF 1 \"register_operand\" \"%0,0\")\n-\t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"Ym#f,fm#Y\"))\n+\t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"Ym#f,f#Y\"))\n \t\t\t (match_dup 1)\n \t\t\t (match_dup 2)))\n    (clobber (reg:CC 17))]"}, {"sha": "9e26e7f78c86aabe0663d501ceacef98e66147be", "filename": "gcc/optabs.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3987b9db30f95cd055f68d302da8e9c474b6feea/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3987b9db30f95cd055f68d302da8e9c474b6feea/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=3987b9db30f95cd055f68d302da8e9c474b6feea", "patch": "@@ -4349,10 +4349,10 @@ expand_fix (to, from, unsignedp)\n      this conversion.  If the integer mode is wider than the mode of TO,\n      we can do the conversion either signed or unsigned.  */\n \n-  for (imode = GET_MODE (to); imode != VOIDmode;\n-       imode = GET_MODE_WIDER_MODE (imode))\n-    for (fmode = GET_MODE (from); fmode != VOIDmode;\n-\t fmode = GET_MODE_WIDER_MODE (fmode))\n+  for (fmode = GET_MODE (from); fmode != VOIDmode;\n+       fmode = GET_MODE_WIDER_MODE (fmode))\n+    for (imode = GET_MODE (to); imode != VOIDmode;\n+\t imode = GET_MODE_WIDER_MODE (imode))\n       {\n \tint doing_unsigned = unsignedp;\n "}]}