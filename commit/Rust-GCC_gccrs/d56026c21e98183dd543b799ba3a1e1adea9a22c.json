{"sha": "d56026c21e98183dd543b799ba3a1e1adea9a22c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU2MDI2YzIxZTk4MTgzZGQ1NDNiNzk5YmEzYTFlMWFkZWE5YTIyYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-05-30T12:19:15Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-05-30T12:19:15Z"}, "message": "cgraph.h (cgraph_node_cannot_return, [...]): New functions.\n\n\t* cgraph.h (cgraph_node_cannot_return,\n\tcgraph_edge_cannot_lead_to_return): New functions.\n\t* cgraph.c (cgraph_node_cannot_return,\n\tcgraph_edge_cannot_lead_to_return): Use them.\n\t* ipa-pure-const.c (pure_const_names): New static var.\n\t(check_call): Handle calls not leading to return.\n\t(pure_const_read_summary): Dump info read.\n\t(propagate): Dump info about propagation process; ignore side\n\teffects of functions not leading to exit; fix handling of\n\tpure functions.\n\nFrom-SVN: r160051", "tree": {"sha": "95c8141edd637bb1eaf3d0b8672e60d8c734e72b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95c8141edd637bb1eaf3d0b8672e60d8c734e72b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d56026c21e98183dd543b799ba3a1e1adea9a22c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d56026c21e98183dd543b799ba3a1e1adea9a22c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d56026c21e98183dd543b799ba3a1e1adea9a22c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d56026c21e98183dd543b799ba3a1e1adea9a22c/comments", "author": null, "committer": null, "parents": [{"sha": "17f01631e1b9191081968fdeb7b2b06951342a01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17f01631e1b9191081968fdeb7b2b06951342a01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17f01631e1b9191081968fdeb7b2b06951342a01"}], "stats": {"total": 182, "additions": 170, "deletions": 12}, "files": [{"sha": "b31797b19b1dc38ba3fc505781ee91fb4d33a63a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d56026c21e98183dd543b799ba3a1e1adea9a22c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d56026c21e98183dd543b799ba3a1e1adea9a22c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d56026c21e98183dd543b799ba3a1e1adea9a22c", "patch": "@@ -1,3 +1,16 @@\n+2010-05-30  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (cgraph_node_cannot_return,\n+\tcgraph_edge_cannot_lead_to_return): New functions.\n+\t* cgraph.c (cgraph_node_cannot_return,\n+\tcgraph_edge_cannot_lead_to_return): Use them.\n+\t* ipa-pure-const.c (pure_const_names): New static var.\n+\t(check_call): Handle calls not leading to return.\n+\t(pure_const_read_summary): Dump info read.\n+\t(propagate): Dump info about propagation process; ignore side\n+\teffects of functions not leading to exit; fix handling of\n+\tpure functions.\n+\n 2010-05-30  Jan Hubicka  <jh@suse.cz>\n \n \t* config/i386/i386.c (pro_epilogue_adjust_stack): Use EBP"}, {"sha": "0c2441fcf6f2697309f16368a7df964b67a770e6", "filename": "gcc/cgraph.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d56026c21e98183dd543b799ba3a1e1adea9a22c/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d56026c21e98183dd543b799ba3a1e1adea9a22c/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=d56026c21e98183dd543b799ba3a1e1adea9a22c", "patch": "@@ -2584,4 +2584,39 @@ cgraph_propagate_frequency (struct cgraph_node *node)\n    return false;\n }\n \n+/* Return true when NODE can not return or throw and thus\n+   it is safe to ignore its side effects for IPA analysis.  */\n+\n+bool\n+cgraph_node_cannot_return (struct cgraph_node *node)\n+{\n+  int flags = flags_from_decl_or_type (node->decl);\n+  if (!flag_exceptions)\n+    return (flags & ECF_NORETURN) != 0;\n+  else\n+    return ((flags & (ECF_NORETURN | ECF_NOTHROW))\n+\t     == (ECF_NORETURN | ECF_NOTHROW));\n+}\n+\n+/* Return true when call of E can not lead to return from caller\n+   and thus it is safe to ignore its side effects for IPA analysis\n+   when computing side effects of the caller.\n+   FIXME: We could actually mark all edges that have no reaching\n+   patch to EXIT_BLOCK_PTR or throw to get better results.  */\n+bool\n+cgraph_edge_cannot_lead_to_return (struct cgraph_edge *e)\n+{\n+  if (e->indirect_unknown_callee)\n+    {\n+      int flags = e->indirect_info->ecf_flags;\n+      if (!flag_exceptions)\n+\treturn (flags & ECF_NORETURN) != 0;\n+      else\n+\treturn ((flags & (ECF_NORETURN | ECF_NOTHROW))\n+\t\t == (ECF_NORETURN | ECF_NOTHROW));\n+    }\n+  else\n+    return cgraph_node_cannot_return (e->callee);\n+}\n+\n #include \"gt-cgraph.h\""}, {"sha": "8e2be0862c42828ac4a84071d4f033ba9a186b63", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d56026c21e98183dd543b799ba3a1e1adea9a22c/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d56026c21e98183dd543b799ba3a1e1adea9a22c/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=d56026c21e98183dd543b799ba3a1e1adea9a22c", "patch": "@@ -594,6 +594,8 @@ void cgraph_set_readonly_flag (struct cgraph_node *, bool);\n void cgraph_set_pure_flag (struct cgraph_node *, bool);\n void cgraph_set_looping_const_or_pure_flag (struct cgraph_node *, bool);\n tree clone_function_name (tree decl, const char *);\n+bool cgraph_node_cannot_return (struct cgraph_node *);\n+bool cgraph_edge_cannot_lead_to_return (struct cgraph_edge *);\n \n /* In cgraphunit.c  */\n void cgraph_finalize_function (tree, bool);"}, {"sha": "864e49dc8a9e271a3ce481e5aabb0e8cfbb6ffa3", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 120, "deletions": 12, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d56026c21e98183dd543b799ba3a1e1adea9a22c/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d56026c21e98183dd543b799ba3a1e1adea9a22c/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=d56026c21e98183dd543b799ba3a1e1adea9a22c", "patch": "@@ -72,6 +72,8 @@ enum pure_const_state_e\n   IPA_NEITHER\n };\n \n+const char *pure_const_names[3] = {\"const\", \"pure\", \"neither\"};\n+\n /* Holder for the const_state.  There is one of these per function\n    decl.  */\n struct funct_state_d\n@@ -445,6 +447,16 @@ check_call (funct_state local, gimple call, bool ipa)\n \t  if (local->pure_const_state == IPA_CONST)\n \t    local->pure_const_state = IPA_PURE;\n \t}\n+      else if ((flags & (ECF_NORETURN | ECF_NOTHROW))\n+\t       == (ECF_NORETURN | ECF_NOTHROW)\n+\t       || (!flag_exceptions && (flags & ECF_NORETURN)))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"    noreturn nothrow call is looping pure\\n\");\n+\t  if (local->pure_const_state == IPA_CONST)\n+\t    local->pure_const_state = IPA_PURE;\n+          local->looping = true;\n+\t}\n       else\n \t{\n \t  if (dump_file)\n@@ -872,6 +884,29 @@ pure_const_read_summary (void)\n \t      fs->looping_previously_known = bp_unpack_value (bp, 1);\n \t      fs->looping = bp_unpack_value (bp, 1);\n \t      fs->can_throw = bp_unpack_value (bp, 1);\n+\t      if (dump_file)\n+\t\t{\n+\t\t  int flags = flags_from_decl_or_type (node->decl);\n+\t\t  fprintf (dump_file, \"Read info for %s/%i \",\n+\t\t\t   cgraph_node_name (node),\n+\t\t\t   node->uid);\n+\t\t  if (flags & ECF_CONST)\n+\t\t    fprintf (dump_file, \" const\");\n+\t\t  if (flags & ECF_PURE)\n+\t\t    fprintf (dump_file, \" pure\");\n+\t\t  if (flags & ECF_NOTHROW)\n+\t\t    fprintf (dump_file, \" nothrow\");\n+\t\t  fprintf (dump_file, \"\\n  pure const state: %s\\n\",\n+\t\t\t   pure_const_names[fs->pure_const_state]);\n+\t\t  fprintf (dump_file, \"  previously known state: %s\\n\",\n+\t\t\t   pure_const_names[fs->looping_previously_known]);\n+\t\t  if (fs->looping)\n+\t\t    fprintf (dump_file,\"  function is locally looping\\n\");\n+\t\t  if (fs->looping_previously_known)\n+\t\t    fprintf (dump_file,\"  function is previously known looping\\n\");\n+\t\t  if (fs->can_throw)\n+\t\t    fprintf (dump_file,\"  function is locally throwing\\n\");\n+\t\t}\n \t      bitpack_delete (bp);\n \t    }\n \n@@ -938,12 +973,21 @@ propagate (void)\n       int count = 0;\n       node = order[i];\n \n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Starting cycle\\n\");\n+\n       /* Find the worst state for any node in the cycle.  */\n       w = node;\n       while (w)\n \t{\n \t  struct cgraph_edge *e;\n \t  funct_state w_l = get_function_state (w);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"  Visiting %s/%i state:%s looping %i\\n\",\n+\t\t     cgraph_node_name (w),\n+\t\t     w->uid,\n+\t\t     pure_const_names[w_l->pure_const_state],\n+\t\t     w_l->looping);\n \t  if (pure_const_state < w_l->pure_const_state)\n \t    pure_const_state = w_l->pure_const_state;\n \n@@ -954,6 +998,13 @@ propagate (void)\n \t      looping |= w_l->looping_previously_known;\n \t      if (pure_const_state < w_l->state_previously_known)\n \t        pure_const_state = w_l->state_previously_known;\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file,\n+\t\t\t   \"    Overwritable. state %s looping %i\\n\",\n+\t\t\t   pure_const_names[w_l->state_previously_known],\n+\t\t\t   w_l->looping_previously_known);\n+\t\t}\n \t    }\n \n \t  if (pure_const_state == IPA_NEITHER)\n@@ -967,35 +1018,92 @@ propagate (void)\n \t  for (e = w->callees; e; e = e->next_callee)\n \t    {\n \t      struct cgraph_node *y = e->callee;\n+\t      enum pure_const_state_e edge_state = IPA_CONST;\n+\t      bool edge_looping = false;\n \n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file,\n+\t\t\t   \"    Call to %s/%i\",\n+\t\t\t   cgraph_node_name (e->callee),\n+\t\t\t   e->callee->uid);\n+\t\t}\n \t      if (cgraph_function_body_availability (y) > AVAIL_OVERWRITABLE)\n \t\t{\n \t\t  funct_state y_l = get_function_state (y);\n-\t\t  if (pure_const_state < y_l->pure_const_state)\n-\t\t    pure_const_state = y_l->pure_const_state;\n-\t\t  if (pure_const_state == IPA_NEITHER)\n-\t\t    break;\n-\t\t  if (y_l->looping)\n-\t\t    looping = true;\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    {\n+\t\t      fprintf (dump_file,\n+\t\t\t       \" state:%s looping:%i\\n\",\n+\t\t\t       pure_const_names[y_l->pure_const_state],\n+\t\t\t       y_l->looping);\n+\t\t    }\n+\t\t  else if (y_l->pure_const_state > ECF_PURE\n+\t\t\t   && cgraph_edge_cannot_lead_to_return (e))\n+\t\t    {\n+\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t\t{\t\n+\t\t\t  fprintf (dump_file,\n+\t\t\t\t   \"        Ignoring side effects -> pure, looping\\n\");\n+\t\t\t}\n+\t\t      edge_state = IPA_PURE;\n+\t\t      edge_looping = true;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      edge_state = y_l->pure_const_state;\n+\t\t      edge_looping = y_l->looping;\n+\t\t    }\n \t\t}\n \t      else\n \t        {\n \t\t  int flags = flags_from_decl_or_type (y->decl);\n \n \t\t  if (flags & ECF_LOOPING_CONST_OR_PURE)\n-\t\t    looping = true;\n+\t\t    {\n+\t\t      edge_looping = true;\n+\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t\tfprintf (dump_file, \" unavailable looping\");\n+\t\t    }\n \t\t  if (flags & ECF_CONST)\n-\t\t    ;\n-\t\t  else if ((flags & ECF_PURE) && pure_const_state == IPA_CONST)\n-\t\t    pure_const_state = IPA_PURE;\n+\t\t    {\n+\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t        fprintf (dump_file, \" const\\n\");\n+\t\t    }\n+\t\t  else if (flags & ECF_PURE)\n+\t\t    {\n+\t\t      edge_state = IPA_PURE;\n+\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t        fprintf (dump_file, \" pure\\n\");\n+\t\t    }\n+\t\t  else if (cgraph_edge_cannot_lead_to_return (e))\n+\t\t    {\n+\t\t      edge_state = IPA_PURE;\n+\t\t      edge_looping = true;\n+\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t        fprintf (dump_file, \" ignoring side effects->pure looping\\n\");\n+\t\t    }\n \t\t  else\n-\t\t    pure_const_state = IPA_NEITHER, looping = true;\n-\n+\t\t    {\n+\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t        fprintf (dump_file, \" neihter\\n\");\n+\t\t      edge_state = IPA_NEITHER;\n+\t\t      edge_looping = true;\n+\t\t    }\n \t\t}\n+\t      pure_const_state = MAX (pure_const_state, MIN (edge_state,\n+\t\t\t\t      w_l->state_previously_known));\n+\t      looping = MAX (looping, MIN (edge_looping, edge_state));\n+\t      if (pure_const_state == IPA_NEITHER)\n+\t        break;\n \t    }\n \t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  w = w_info->next_cycle;\n \t}\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Result %s looping %i\\n\",\n+\t\t pure_const_names [pure_const_state],\n+\t\t looping);\n \n       /* Copy back the region's pure_const_state which is shared by\n \t all nodes in the region.  */"}]}