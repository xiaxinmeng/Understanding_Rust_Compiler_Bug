{"sha": "d770e88d122c56f9ec952817ced18ecdc3e39d31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc3MGU4OGQxMjJjNTZmOWVjOTUyODE3Y2VkMThlY2RjM2UzOWQzMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-11-08T12:17:51Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-11-08T12:17:51Z"}, "message": "decl.c (make_packable_type): Fix oversight.\n\n\t* gcc-interface/decl.c (make_packable_type): Fix oversight.\n\t(gnat_to_gnu_field): Do not attempt to change the form of the type\n\tif the field requires strict alignment.  Always change the form of\n\tthe type if the specified size is smaller than its size.\n\nFrom-SVN: r154009", "tree": {"sha": "6273f80f4dea4defb342293bca2ca508b0b3571e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6273f80f4dea4defb342293bca2ca508b0b3571e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d770e88d122c56f9ec952817ced18ecdc3e39d31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d770e88d122c56f9ec952817ced18ecdc3e39d31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d770e88d122c56f9ec952817ced18ecdc3e39d31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d770e88d122c56f9ec952817ced18ecdc3e39d31/comments", "author": null, "committer": null, "parents": [{"sha": "eb1494409bcbb256db054db188c386d3e3cf0b55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb1494409bcbb256db054db188c386d3e3cf0b55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb1494409bcbb256db054db188c386d3e3cf0b55"}], "stats": {"total": 115, "additions": 69, "deletions": 46}, "files": [{"sha": "41a0d07c3c14a5be925be75ae5aac2939d611b8a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d770e88d122c56f9ec952817ced18ecdc3e39d31/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d770e88d122c56f9ec952817ced18ecdc3e39d31/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d770e88d122c56f9ec952817ced18ecdc3e39d31", "patch": "@@ -1,3 +1,10 @@\n+2009-11-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (make_packable_type): Fix oversight.\n+\t(gnat_to_gnu_field): Do not attempt to change the form of the type\n+\tif the field requires strict alignment.  Always change the form of\n+\tthe type if the specified size is smaller than its size.\n+\n 2009-11-05  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/utils.c (gnat_type_for_mode): Handle vector modes."}, {"sha": "9e643a3108b1b001edb18c6d18352adb375cacdf", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 24, "deletions": 46, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d770e88d122c56f9ec952817ced18ecdc3e39d31/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d770e88d122c56f9ec952817ced18ecdc3e39d31/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=d770e88d122c56f9ec952817ced18ecdc3e39d31", "patch": "@@ -6052,6 +6052,7 @@ make_packable_type (tree type, bool in_record)\n     {\n       TYPE_SIZE (new_type) = TYPE_SIZE (type);\n       TYPE_SIZE_UNIT (new_type) = TYPE_SIZE_UNIT (type);\n+      new_size = size;\n     }\n   else\n     {\n@@ -6449,67 +6450,44 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n   else\n     gnu_size = NULL_TREE;\n \n-  /* If we have a specified size that's smaller than that of the field type,\n-     or a position is specified, and the field type is a record, see if we can\n-     get either an integral mode form of the type or a smaller form.  If we\n-     can, show a size was specified for the field if there wasn't one already,\n-     so we know to make this a bitfield and avoid making things wider.\n+  /* If we have a specified size that is smaller than that of the field's type,\n+     or a position is specified, and the field's type is a record that doesn't\n+     require strict alignment, see if we can get either an integral mode form\n+     of the type or a smaller form.  If we can, show a size was specified for\n+     the field if there wasn't one already, so we know to make this a bitfield\n+     and avoid making things wider.\n \n-     Doing this is first useful if the record is packed because we may then\n-     place the field at a non-byte-aligned position and so achieve tighter\n-     packing.\n+     Changing to an integral mode form is useful when the record is packed as\n+     we can then place the field at a non-byte-aligned position and so achieve\n+     tighter packing.  This is in addition required if the field shares a byte\n+     with another field and the front-end lets the back-end handle the access\n+     to the field, because GCC cannot handle non-byte-aligned BLKmode fields.\n \n-     This is in addition *required* if the field shares a byte with another\n-     field and the front-end lets the back-end handle the references, because\n-     GCC does not handle BLKmode bitfields properly.\n+     Changing to a smaller form is required if the specified size is smaller\n+     than that of the field's type and the type contains sub-fields that are\n+     padded, in order to avoid generating accesses to these sub-fields that\n+     are wider than the field.\n \n      We avoid the transformation if it is not required or potentially useful,\n      as it might entail an increase of the field's alignment and have ripple\n      effects on the outer record type.  A typical case is a field known to be\n-     byte aligned and not to share a byte with another field.\n-\n-     Besides, we don't even look the possibility of a transformation in cases\n-     known to be in error already, for instance when an invalid size results\n-     from a component clause.  */\n-\n-  if (TREE_CODE (gnu_field_type) == RECORD_TYPE\n+     byte-aligned and not to share a byte with another field.  */\n+  if (!needs_strict_alignment\n+      && TREE_CODE (gnu_field_type) == RECORD_TYPE\n       && !TYPE_FAT_POINTER_P (gnu_field_type)\n       && host_integerp (TYPE_SIZE (gnu_field_type), 1)\n       && (packed == 1\n \t  || (gnu_size\n \t      && (tree_int_cst_lt (gnu_size, TYPE_SIZE (gnu_field_type))\n-\t\t  || Present (Component_Clause (gnat_field))))))\n+\t\t  || (Present (Component_Clause (gnat_field))\n+\t\t      && !(UI_To_Int (Component_Bit_Offset (gnat_field))\n+\t\t\t   % BITS_PER_UNIT == 0\n+\t\t\t   && value_factor_p (gnu_size, BITS_PER_UNIT)))))))\n     {\n-      /* See what the alternate type and size would be.  */\n       tree gnu_packable_type = make_packable_type (gnu_field_type, true);\n-\n-      bool has_byte_aligned_clause\n-\t= Present (Component_Clause (gnat_field))\n-\t  && (UI_To_Int (Component_Bit_Offset (gnat_field))\n-\t      % BITS_PER_UNIT == 0);\n-\n-      /* Compute whether we should avoid the substitution.  */\n-      bool reject\n-\t/* There is no point substituting if there is no change...  */\n-\t= (gnu_packable_type == gnu_field_type)\n-\t /* ... nor when the field is known to be byte aligned and not to\n-\t    share a byte with another field.  */\n-\t  || (has_byte_aligned_clause\n-\t      && value_factor_p (gnu_size, BITS_PER_UNIT))\n-\t /* The size of an aliased field must be an exact multiple of the\n-\t    type's alignment, which the substitution might increase.  Reject\n-\t    substitutions that would so invalidate a component clause when the\n-\t    specified position is byte aligned, as the change would have no\n-\t    real benefit from the packing standpoint anyway.  */\n-\t  || (Is_Aliased (gnat_field)\n-\t      && has_byte_aligned_clause\n-\t      && !value_factor_p (gnu_size, TYPE_ALIGN (gnu_packable_type)));\n-\n-      /* Substitute unless told otherwise.  */\n-      if (!reject)\n+      if (gnu_packable_type != gnu_field_type)\n \t{\n \t  gnu_field_type = gnu_packable_type;\n-\n \t  if (!gnu_size)\n \t    gnu_size = rm_size (gnu_field_type);\n \t}"}, {"sha": "73021d0e21b17275df768fbc8622e4394b8d29ce", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d770e88d122c56f9ec952817ced18ecdc3e39d31/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d770e88d122c56f9ec952817ced18ecdc3e39d31/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d770e88d122c56f9ec952817ced18ecdc3e39d31", "patch": "@@ -1,3 +1,7 @@\n+2009-11-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/rep_clause4.adb: New test.\n+\n 2009-11-08  Richard Guenther  <rguenther@suse.de>\n \n \tPR rtl-optimization/41928"}, {"sha": "76bb15284a501d268ccb320e46d4705257f021dc", "filename": "gcc/testsuite/gnat.dg/rep_clause4.adb", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d770e88d122c56f9ec952817ced18ecdc3e39d31/gcc%2Ftestsuite%2Fgnat.dg%2Frep_clause4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d770e88d122c56f9ec952817ced18ecdc3e39d31/gcc%2Ftestsuite%2Fgnat.dg%2Frep_clause4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Frep_clause4.adb?ref=d770e88d122c56f9ec952817ced18ecdc3e39d31", "patch": "@@ -0,0 +1,34 @@\n+-- { dg-do run }\n+\n+procedure Rep_Clause4 is\n+\n+  type U32 is mod 2 ** 32;\n+\n+  type Key is record\n+    Value : U32;\n+    Valid : Boolean;\n+  end record;\n+\n+  type Key_Buffer is record\n+    Current, Latch : Key;\n+  end record;\n+\n+  type Block is record\n+    Keys  : Key_Buffer;\n+    Stamp : U32;\n+  end record;\n+  for Block use record\n+    Keys  at  0 range 0 .. 103;\n+    Stamp at 13 range 0 .. 31;\n+  end record;\n+\n+  My_Block : Block;\n+  My_Stamp : constant := 16#01234567#;\n+\n+begin\n+  My_Block.Stamp := My_Stamp;\n+  My_Block.Keys.Latch := My_Block.Keys.Current;\n+  if My_Block.Stamp /= My_Stamp then\n+    raise Program_Error;\n+  end if;\n+end;"}]}