{"sha": "9dec91d433ffb66758a7927576c2e8071e28d9f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRlYzkxZDQzM2ZmYjY2NzU4YTc5Mjc1NzZjMmU4MDcxZTI4ZDlmMA==", "commit": {"author": {"name": "Steve Ellcey", "email": "sje@cup.hp.com", "date": "2004-09-03T17:52:08Z"}, "committer": {"name": "Steve Ellcey", "email": "sje@gcc.gnu.org", "date": "2004-09-03T17:52:08Z"}, "message": "ia64.c (ia64_function_arg): Use PARALLEL even if there is only one reg.\n\n\t* config/ia64/ia64.c (ia64_function_arg): Use PARALLEL even if there\n\tis only one reg.\n\t(ia64_function_value): Ditto.\n\nFrom-SVN: r87038", "tree": {"sha": "a0b805a52b3c01789ea7708c46732e19775e6d43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0b805a52b3c01789ea7708c46732e19775e6d43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9dec91d433ffb66758a7927576c2e8071e28d9f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dec91d433ffb66758a7927576c2e8071e28d9f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dec91d433ffb66758a7927576c2e8071e28d9f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dec91d433ffb66758a7927576c2e8071e28d9f0/comments", "author": null, "committer": null, "parents": [{"sha": "467cecf3b892c8b74cf0aafe0d6974c9ee66700a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/467cecf3b892c8b74cf0aafe0d6974c9ee66700a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/467cecf3b892c8b74cf0aafe0d6974c9ee66700a"}], "stats": {"total": 24, "additions": 8, "deletions": 16}, "files": [{"sha": "23735e6d0fc17feb0b0408d23f81da639e8bbfc9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dec91d433ffb66758a7927576c2e8071e28d9f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dec91d433ffb66758a7927576c2e8071e28d9f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9dec91d433ffb66758a7927576c2e8071e28d9f0", "patch": "@@ -1,3 +1,9 @@\n+2004-09-03  Steve Ellcey  <sje@cup.hp.com>\n+\n+\t* config/ia64/ia64.c (ia64_function_arg): Use PARALLEL even if there\n+\tis only one reg.\n+\t(ia64_function_value): Ditto.\n+\n 2004-09-03  Jan Beulich  <jbeulich@novell.com>\n \n \tPR c/7054"}, {"sha": "8921a8a7e92642d47abb012a69578fddf66370ee", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dec91d433ffb66758a7927576c2e8071e28d9f0/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dec91d433ffb66758a7927576c2e8071e28d9f0/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=9dec91d433ffb66758a7927576c2e8071e28d9f0", "patch": "@@ -3169,17 +3169,7 @@ ia64_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n \t  else if (gr_size > UNITS_PER_WORD)\n \t    int_regs += gr_size / UNITS_PER_WORD;\n \t}\n-\n-      /* If we ended up using just one location, just return that one loc, but\n-\t change the mode back to the argument mode.  However, we can't do this\n-\t when hfa_mode is XFmode and mode is TImode.  In that case, we would\n-\t return a TImode reference to an FP reg, but FP regs can't hold TImode.\n-\t We need the PARALLEL to make this work.  This can happen for a union\n-\t containing a single __float80 member.  */\n-      if (i == 1 && ! (hfa_mode == XFmode && mode == TImode))\n-\treturn gen_rtx_REG (mode, REGNO (XEXP (loc[0], 0)));\n-      else\n-\treturn gen_rtx_PARALLEL (mode, gen_rtvec_v (i, loc));\n+      return gen_rtx_PARALLEL (mode, gen_rtvec_v (i, loc));\n     }\n \n   /* Integral and aggregates go in general registers.  If we have run out of\n@@ -3477,11 +3467,7 @@ ia64_function_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n \t\t\t\t      GEN_INT (offset));\n \t  offset += hfa_size;\n \t}\n-\n-      if (i == 1)\n-\treturn XEXP (loc[0], 0);\n-      else\n-\treturn gen_rtx_PARALLEL (mode, gen_rtvec_v (i, loc));\n+      return gen_rtx_PARALLEL (mode, gen_rtvec_v (i, loc));\n     }\n   else if (FLOAT_TYPE_P (valtype) && mode != TFmode && mode != TCmode)\n     return gen_rtx_REG (mode, FR_ARG_FIRST);"}]}