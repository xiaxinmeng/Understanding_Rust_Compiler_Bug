{"sha": "b4f3232d6979022a36b4055d7d3aaba693a39938", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRmMzIzMmQ2OTc5MDIyYTM2YjQwNTVkN2QzYWFiYTY5M2EzOTkzOA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-03-09T18:23:27Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-03-09T18:23:27Z"}, "message": "PR c++/70105: prevent nonsensical underline spew for macro expansions\n\ndiagnostic_show_locus can sometimes do the wrong thing when handling\nexpressions built up from macros.\n\nPR c++/70105 (currently marked as a P3 regression) has an example of\na diagnostic where over 500 lines of irrelevant source are printed,\nand underlined, giving >1000 lines of useless spew to stderr.\n\nThis patch adds extra sanitization to diagnostic-show-locus.c, so that\nwe only attempt to print underlines and secondary locations if such\nlocations are \"sufficiently sane\" relative to the primary location\nof a diagnostic.\n\nThis \"sufficiently sane\" condition is implemented by a new helper\nfunction compatible_locations_p, which requires such locations to\nhave the same macro expansion hierarchy as the primary location,\nusing linemap_macro_map_loc_unwind_toward_spelling, effectively\nmimicing the expansion performed by LRK_SPELLING_LOCATION.\n\nThis may be too strong a condition, but it effectively fixes\nPR c++/70105, without removing any underlines in my testing.\n\nSuccessfully bootstrapped&regrtested in combination with the previous\npatch on x86_64-pc-linux-gnu; adds 15 new PASS results to g++.sum\nand 4 new PASS results to gcc.sum.\n\ngcc/ChangeLog:\n\tPR c/68473\n\tPR c++/70105\n\t* diagnostic-show-locus.c (compatible_locations_p): New function.\n\t(layout::layout): Sanitize ranges using compatible_locations_p.\n\ngcc/testsuite/ChangeLog:\n\tPR c/68473\n\tPR c++/70105\n\t* g++.dg/diagnostic/pr70105.C: New test.\n\t* gcc.dg/plugin/diagnostic-test-expressions-1.c (foo): New decl.\n\t(test_multiple_ordinary_maps): New test function.\n\nlibcpp/ChangeLog:\n\tPR c/68473\n\tPR c++/70105\n\t* line-map.c (linemap_macro_map_loc_unwind_toward_spelling): Move\n\tdecl...\n\t* include/line-map.h\n\t(linemap_macro_map_loc_unwind_toward_spelling): ...here,\n\tconverting from static to extern.\n\nFrom-SVN: r234088", "tree": {"sha": "f2d383b45fd79fc7ab53b2857eb71e9b4a498cb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2d383b45fd79fc7ab53b2857eb71e9b4a498cb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4f3232d6979022a36b4055d7d3aaba693a39938", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4f3232d6979022a36b4055d7d3aaba693a39938", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4f3232d6979022a36b4055d7d3aaba693a39938", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4f3232d6979022a36b4055d7d3aaba693a39938/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "40499f81a6a65d903a8b6469797c58c52eaf8008", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40499f81a6a65d903a8b6469797c58c52eaf8008", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40499f81a6a65d903a8b6469797c58c52eaf8008"}], "stats": {"total": 203, "additions": 199, "deletions": 4}, "files": [{"sha": "d3323a62a8a51cf113c54493cb4a49fd4c2bf8a8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f3232d6979022a36b4055d7d3aaba693a39938/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f3232d6979022a36b4055d7d3aaba693a39938/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4f3232d6979022a36b4055d7d3aaba693a39938", "patch": "@@ -1,3 +1,10 @@\n+2016-03-09  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c/68473\n+\tPR c++/70105\n+\t* diagnostic-show-locus.c (compatible_locations_p): New function.\n+\t(layout::layout): Sanitize ranges using compatible_locations_p.\n+\n 2016-03-09  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c/68473"}, {"sha": "f10ade5591cf6f2253ba2ec993ddbcba6fdc677a", "filename": "gcc/diagnostic-show-locus.c", "status": "modified", "additions": 87, "deletions": 2, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f3232d6979022a36b4055d7d3aaba693a39938/gcc%2Fdiagnostic-show-locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f3232d6979022a36b4055d7d3aaba693a39938/gcc%2Fdiagnostic-show-locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-show-locus.c?ref=b4f3232d6979022a36b4055d7d3aaba693a39938", "patch": "@@ -463,6 +463,76 @@ get_line_width_without_trailing_whitespace (const char *line, int line_width)\n   return result;\n }\n \n+/* Helper function for layout's ctor, for sanitizing locations relative\n+   to the primary location within a diagnostic.\n+\n+   Compare LOC_A and LOC_B to see if it makes sense to print underlines\n+   connecting their expanded locations.  Doing so is only guaranteed to\n+   make sense if the locations share the same macro expansion \"history\"\n+   i.e. they can be traced through the same macro expansions, eventually\n+   reaching an ordinary map.\n+\n+   This may be too strong a condition, but it effectively sanitizes\n+   PR c++/70105, which has an example of printing an expression where the\n+   final location of the expression is in a different macro, which\n+   erroneously was leading to hundreds of lines of irrelevant source\n+   being printed.  */\n+\n+static bool\n+compatible_locations_p (location_t loc_a, location_t loc_b)\n+{\n+  if (IS_ADHOC_LOC (loc_a))\n+    loc_a = get_location_from_adhoc_loc (line_table, loc_a);\n+  if (IS_ADHOC_LOC (loc_b))\n+    loc_b = get_location_from_adhoc_loc (line_table, loc_b);\n+\n+  const line_map *map_a = linemap_lookup (line_table, loc_a);\n+  linemap_assert (map_a);\n+\n+  const line_map *map_b = linemap_lookup (line_table, loc_b);\n+  linemap_assert (map_b);\n+\n+  /* Are they within the same map?  */\n+  if (map_a == map_b)\n+    {\n+      /* Are both within the same macro expansion?  */\n+      if (linemap_macro_expansion_map_p (map_a))\n+\t{\n+\t  /* Expand each location towards the spelling location, and\n+\t     recurse.  */\n+\t  const line_map_macro *macro_map = linemap_check_macro (map_a);\n+\t  source_location loc_a_toward_spelling\n+\t    = linemap_macro_map_loc_unwind_toward_spelling (line_table,\n+\t\t\t\t\t\t\t    macro_map,\n+\t\t\t\t\t\t\t    loc_a);\n+\t  source_location loc_b_toward_spelling\n+\t    = linemap_macro_map_loc_unwind_toward_spelling (line_table,\n+\t\t\t\t\t\t\t    macro_map,\n+\t\t\t\t\t\t\t    loc_b);\n+\t  return compatible_locations_p (loc_a_toward_spelling,\n+\t\t\t\t\t loc_b_toward_spelling);\n+\t}\n+\n+      /* Otherwise they are within the same ordinary map.  */\n+      return true;\n+    }\n+  else\n+    {\n+      /* Within different maps.  */\n+\n+      /* If either is within a macro expansion, they are incompatible.  */\n+      if (linemap_macro_expansion_map_p (map_a)\n+\t  || linemap_macro_expansion_map_p (map_b))\n+\treturn false;\n+\n+      /* Within two different ordinary maps; they are compatible iff they\n+\t are in the same file.  */\n+      const line_map_ordinary *ord_map_a = linemap_check_ordinary (map_a);\n+      const line_map_ordinary *ord_map_b = linemap_check_ordinary (map_b);\n+      return ord_map_a->to_file == ord_map_b->to_file;\n+    }\n+}\n+\n /* Implementation of class layout.  */\n \n /* Constructor for class layout.\n@@ -487,6 +557,8 @@ layout::layout (diagnostic_context * context,\n   m_x_offset (0)\n {\n   rich_location *richloc = diagnostic->richloc;\n+  source_location primary_loc = richloc->get_range (0)->m_loc;\n+\n   for (unsigned int idx = 0; idx < richloc->get_num_locations (); idx++)\n     {\n       /* This diagnostic printer can only cope with \"sufficiently sane\" ranges.\n@@ -514,15 +586,28 @@ layout::layout (diagnostic_context * context,\n \tif (caret.file != m_exploc.file)\n \t  continue;\n \n+      /* Sanitize the caret location for non-primary ranges.  */\n+      if (m_layout_ranges.length () > 0)\n+\tif (loc_range->m_show_caret_p)\n+\t  if (!compatible_locations_p (loc_range->m_loc, primary_loc))\n+\t    /* Discard any non-primary ranges that can't be printed\n+\t       sanely relative to the primary location.  */\n+\t    continue;\n+\n       /* Everything is now known to be in the correct source file,\n \t but it may require further sanitization.  */\n       layout_range ri (&start, &finish, loc_range->m_show_caret_p, &caret);\n \n       /* If we have a range that finishes before it starts (perhaps\n \t from something built via macro expansion), printing the\n \t range is likely to be nonsensical.  Also, attempting to do so\n-\t breaks assumptions within the printing code  (PR c/68473).  */\n-      if (start.line > finish.line)\n+\t breaks assumptions within the printing code  (PR c/68473).\n+\t Similarly, don't attempt to print ranges if one or both ends\n+\t of the range aren't sane to print relative to the\n+\t primary location (PR c++/70105).  */\n+      if (start.line > finish.line\n+\t  || !compatible_locations_p (src_range.m_start, primary_loc)\n+\t  || !compatible_locations_p (src_range.m_finish, primary_loc))\n \t{\n \t  /* Is this the primary location?  */\n \t  if (m_layout_ranges.length () == 0)"}, {"sha": "14a2f67c2faff68f24d0b5e5e0652a4b3c1ba568", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f3232d6979022a36b4055d7d3aaba693a39938/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f3232d6979022a36b4055d7d3aaba693a39938/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b4f3232d6979022a36b4055d7d3aaba693a39938", "patch": "@@ -1,3 +1,11 @@\n+2016-03-09  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c/68473\n+\tPR c++/70105\n+\t* g++.dg/diagnostic/pr70105.C: New test.\n+\t* gcc.dg/plugin/diagnostic-test-expressions-1.c (foo): New decl.\n+\t(test_multiple_ordinary_maps): New test function.\n+\n 2016-03-09  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c/68473"}, {"sha": "9c9b02c77f4101558729d8b3223cfb18e5ea2010", "filename": "gcc/testsuite/g++.dg/diagnostic/pr70105.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f3232d6979022a36b4055d7d3aaba693a39938/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fpr70105.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f3232d6979022a36b4055d7d3aaba693a39938/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fpr70105.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fpr70105.C?ref=b4f3232d6979022a36b4055d7d3aaba693a39938", "patch": "@@ -0,0 +1,43 @@\n+// { dg-options \"-Wsequence-point -fdiagnostics-show-caret\" }\n+\n+void *libiberty_concat_ptr;\n+extern unsigned long concat_length (const char *, ...);\n+extern char *concat_copy2 (const char *, ...);\n+\n+#define ACONCAT(ACONCAT_PARAMS) \\\n+  (libiberty_concat_ptr = (char *) ALLOCA (concat_length ACONCAT_PARAMS + 1), /* { dg-warning \"may be undefined\" } */ \\\n+   concat_copy2 ACONCAT_PARAMS)\n+\n+/* Arbitrary content here.\n+   In PR c++/70105, this was >500 lines of source.\n+   This should not be printed.  */\n+\n+# define ALLOCA(x) __builtin_alloca(x)\n+\n+int strlen (const char *);\n+void *get_identifier (const char *);\n+void *get_identifier_with_length (const char *, int);\n+\n+#define GET_IDENTIFIER(STR) \\\n+  (__builtin_constant_p (STR)\t\t\t\t\\\n+    ? get_identifier_with_length ((STR), strlen (STR))  \\\n+    : get_identifier (STR))\n+\n+void *test(void)\n+{\n+  int *i;\n+  return GET_IDENTIFIER (ACONCAT ((\"foo\")));\n+}\n+\n+/* { dg-begin-multiline-output \"\" }\n+   (libiberty_concat_ptr = (char *) ALLOCA (concat_length ACONCAT_PARAMS + 1),\n+                         ^\n+   { dg-end-multiline-output \"\" } */\n+/* { dg-begin-multiline-output \"\" }\n+     ? get_identifier_with_length ((STR), strlen (STR))  \\\n+                                                  ^~~\n+   { dg-end-multiline-output \"\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   return GET_IDENTIFIER (ACONCAT ((\"foo\")));\n+                          ^~~~~~~\n+   { dg-end-multiline-output \"\" } */"}, {"sha": "170060f9a2123bcb99c1383ac19c5b60f4775529", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-test-expressions-1.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f3232d6979022a36b4055d7d3aaba693a39938/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-expressions-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f3232d6979022a36b4055d7d3aaba693a39938/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-expressions-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-expressions-1.c?ref=b4f3232d6979022a36b4055d7d3aaba693a39938", "patch": "@@ -635,3 +635,39 @@ void test_macro (long double xl)\n                        ^~~~\n    { dg-end-multiline-output \"\" } */\n }\n+\n+/* Verify that we can underline expressions that span multiple\n+   ordinary maps.  */\n+\n+extern int foo (int, ...);\n+\n+void test_multiple_ordinary_maps (void)\n+{\n+  /* The expression\n+        foo (0, \"very long string...\")\n+     below contains a transition between ordinary maps due to a very long\n+     line (>127 \"columns\", treating tab characters as 1 column).  */\n+  __emit_expression_range (0, foo (0, /* { dg-warning \"range\" } */\n+\t\t\t\t   \"0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\"));\n+\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, foo (0,\n+                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+        \"0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\"));\n+        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  /* Another expression that transitions between ordinary maps; this\n+     one due to an ordinary map for a very long line transitioning back to\n+     one for a very short line.  The policy in linemap_line_start\n+     means that we need a transition from >10 bits of column\n+     (i.e. 2048 columns) to a line with <= 80 columns.  */\n+  __emit_expression_range (0, foo (0, \"01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\", /* { dg-warning \"range\" } */\n+\t\t\t\t   0));\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, foo (0, \"01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\",\n+                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+        0));\n+        ~~                      \n+   { dg-end-multiline-output \"\" } */\n+}"}, {"sha": "19b9310bb8647feec1098bf94069979cadbc3ebc", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f3232d6979022a36b4055d7d3aaba693a39938/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f3232d6979022a36b4055d7d3aaba693a39938/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=b4f3232d6979022a36b4055d7d3aaba693a39938", "patch": "@@ -1,3 +1,13 @@\n+2016-03-09  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c/68473\n+\tPR c++/70105\n+\t* line-map.c (linemap_macro_map_loc_unwind_toward_spelling): Move\n+\tdecl...\n+\t* include/line-map.h\n+\t(linemap_macro_map_loc_unwind_toward_spelling): ...here,\n+\tconverting from static to extern.\n+\n 2016-03-09  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c/68473"}, {"sha": "292abce3ec913d57f7fff1ec92b1baf196001272", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f3232d6979022a36b4055d7d3aaba693a39938/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f3232d6979022a36b4055d7d3aaba693a39938/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=b4f3232d6979022a36b4055d7d3aaba693a39938", "patch": "@@ -1066,6 +1066,14 @@ int linemap_location_in_system_header_p (struct line_maps *,\n bool linemap_location_from_macro_expansion_p (const struct line_maps *,\n \t\t\t\t\t      source_location);\n \n+/* With the precondition that LOCATION is the locus of a token that is\n+   an argument of a function-like macro MACRO_MAP and appears in the\n+   expansion of MACRO_MAP, return the locus of that argument in the\n+   context of the caller of MACRO_MAP.  */\n+\n+extern source_location linemap_macro_map_loc_unwind_toward_spelling\n+  (line_maps *set, const line_map_macro *macro_map, source_location location);\n+\n /* source_location values from 0 to RESERVED_LOCATION_COUNT-1 will\n    be reserved for libcpp user as special values, no token from libcpp\n    will contain any of those locations.  */"}, {"sha": "1fb634af5bf3d1805a9c2f7c6264ee686c847e9a", "filename": "libcpp/line-map.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f3232d6979022a36b4055d7d3aaba693a39938/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f3232d6979022a36b4055d7d3aaba693a39938/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=b4f3232d6979022a36b4055d7d3aaba693a39938", "patch": "@@ -54,8 +54,6 @@ static const line_map_macro* linemap_macro_map_lookup (struct line_maps *,\n \t\t\t\t\t\t       source_location);\n static source_location linemap_macro_map_loc_to_def_point\n (const line_map_macro *, source_location);\n-static source_location linemap_macro_map_loc_unwind_toward_spelling\n-(line_maps *set, const line_map_macro *, source_location);\n static source_location linemap_macro_map_loc_to_exp_point\n (const line_map_macro *, source_location);\n static source_location linemap_macro_loc_to_spelling_point"}]}