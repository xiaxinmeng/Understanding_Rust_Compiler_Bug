{"sha": "833cd70a0c91517672ae309a95519bb2f409d304", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODMzY2Q3MGEwYzkxNTE3NjcyYWUzMDlhOTU1MTliYjJmNDA5ZDMwNA==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2007-03-29T06:58:42Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2007-03-29T06:58:42Z"}, "message": "s390.c (s390_secondary_input_reload_class, [...]): Functions removed.\n\n2007-03-29  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* config/s390/s390.c (s390_secondary_input_reload_class,\n\ts390_secondary_output_reload_class): Functions removed.\n\t(s390_secondary_reload): New function.\n\t(TARGET_SECONDARY_RELOAD): Target macro defined.\n\t* config/s390/s390.h (SECONDARY_INPUT_RELOAD_CLASS,\n\tSECONDARY_OUTPUT_RELOAD_CLASS): Macro definitions removed.\n\t* config/s390/s390.md (\"reload_outti\", \"reload_outdi\",\n\t\"reload_indi\", \"reload_insi\", \"reload_out<mode>\", \"reload_in<mode>\",\n\t\"reload_out<mode>\"): Expanders removed.\n\t(\"reload<mode>_plus\", \"reload<mode>_nonoffmem_in\",\n\t\"reload<mode>_nonoffmem_out\"): Expanders added.\n\nFrom-SVN: r123324", "tree": {"sha": "0eb02ea1d47ff33d3568fbef2b041a2c2dd70d61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0eb02ea1d47ff33d3568fbef2b041a2c2dd70d61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/833cd70a0c91517672ae309a95519bb2f409d304", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/833cd70a0c91517672ae309a95519bb2f409d304", "html_url": "https://github.com/Rust-GCC/gccrs/commit/833cd70a0c91517672ae309a95519bb2f409d304", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/833cd70a0c91517672ae309a95519bb2f409d304/comments", "author": null, "committer": null, "parents": [{"sha": "040f69ebaac3cb2fe8b26ff736d5885db4f16f6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/040f69ebaac3cb2fe8b26ff736d5885db4f16f6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/040f69ebaac3cb2fe8b26ff736d5885db4f16f6b"}], "stats": {"total": 245, "additions": 99, "deletions": 146}, "files": [{"sha": "8dacb718f623a2b6519cb42f4ce3ee38cebaa747", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/833cd70a0c91517672ae309a95519bb2f409d304/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/833cd70a0c91517672ae309a95519bb2f409d304/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=833cd70a0c91517672ae309a95519bb2f409d304", "patch": "@@ -1,3 +1,17 @@\n+2007-03-29  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* config/s390/s390.c (s390_secondary_input_reload_class,\n+\ts390_secondary_output_reload_class): Functions removed.\n+\t(s390_secondary_reload): New function.\n+\t(TARGET_SECONDARY_RELOAD): Target macro defined.\n+\t* config/s390/s390.h (SECONDARY_INPUT_RELOAD_CLASS,\n+\tSECONDARY_OUTPUT_RELOAD_CLASS): Macro definitions removed.\n+\t* config/s390/s390.md (\"reload_outti\", \"reload_outdi\",\n+\t\"reload_indi\", \"reload_insi\", \"reload_out<mode>\", \"reload_in<mode>\",\n+\t\"reload_out<mode>\"): Expanders removed.\n+\t(\"reload<mode>_plus\", \"reload<mode>_nonoffmem_in\",\n+\t\"reload<mode>_nonoffmem_out\"): Expanders added.\n+\n 2007-03-29  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \t* regmove.c (optimize_reg_copy_1): Don't perform DEST->SRC repair action if"}, {"sha": "e0e3115cd37e1c473d0ee0ee94e5498c3c8b16dc", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 48, "deletions": 55, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/833cd70a0c91517672ae309a95519bb2f409d304/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/833cd70a0c91517672ae309a95519bb2f409d304/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=833cd70a0c91517672ae309a95519bb2f409d304", "patch": "@@ -2638,67 +2638,57 @@ s390_preferred_reload_class (rtx op, enum reg_class class)\n   return class;\n }\n \n-/* Return the register class of a scratch register needed to\n-   load IN into a register of class CLASS in MODE.\n-\n-   We need a temporary when loading a PLUS expression which\n-   is not a legitimate operand of the LOAD ADDRESS instruction.  */\n-\n-enum reg_class\n-s390_secondary_input_reload_class (enum reg_class class,\n-\t\t\t\t   enum machine_mode mode, rtx in)\n-{\n-  if (s390_plus_operand (in, mode))\n-    return ADDR_REGS;\n-\n-  if (reg_classes_intersect_p (FP_REGS, class)\n-      && mode == TFmode\n-      && GET_CODE (in) == MEM\n-      && GET_CODE (XEXP (in, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (in, 0), 1)) == CONST_INT\n-      && !DISP_IN_RANGE (INTVAL (XEXP (XEXP (in, 0), 1))\n-\t\t\t + GET_MODE_SIZE (mode) - 1))\n-    return ADDR_REGS;\n+/* Inform reload about cases where moving X with a mode MODE to a register in\n+   CLASS requires an extra scratch or immediate register.  Return the class\n+   needed for the immediate register.  */\n \n+static enum reg_class\n+s390_secondary_reload (bool in_p, rtx x, enum reg_class class,\n+\t\t       enum machine_mode mode, secondary_reload_info *sri)\n+{\n+  /* Intermediate register needed.  */\n   if (reg_classes_intersect_p (CC_REGS, class))\n     return GENERAL_REGS;\n \n-  return NO_REGS;\n-}\n-\n-/* Return the register class of a scratch register needed to\n-   store a register of class CLASS in MODE into OUT:\n-\n-   We need a temporary when storing a double-word to a\n-   non-offsettable memory address.  */\n-\n-enum reg_class\n-s390_secondary_output_reload_class (enum reg_class class,\n-\t\t\t\t    enum machine_mode mode, rtx out)\n-{\n-  if ((TARGET_64BIT ? (mode == TImode || mode == TFmode)\n-                    : (mode == DImode || mode == DFmode))\n-      && reg_classes_intersect_p (GENERAL_REGS, class)\n-      && GET_CODE (out) == MEM\n-      && GET_CODE (XEXP (out, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (out, 0), 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (out, 0), 1)) == CONST_INT\n-      && !DISP_IN_RANGE (INTVAL (XEXP (XEXP (out, 0), 1))\n+  /* We need a scratch register when loading a PLUS expression which\n+     is not a legitimate operand of the LOAD ADDRESS instruction.  */\n+  if (in_p && s390_plus_operand (x, mode))\n+    sri->icode = (TARGET_64BIT ?\n+\t\t  CODE_FOR_reloaddi_plus : CODE_FOR_reloadsi_plus);\n+\n+  /* Peforming a multiword move from or to memory we have to make sure the\n+     second chunk in memory is addressable without causing a displacement\n+     overflow.  If that would be the case we calculate the address in\n+     a scratch register.  */\n+  if (MEM_P (x)\n+      && GET_CODE (XEXP (x, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+      && !DISP_IN_RANGE (INTVAL (XEXP (XEXP (x, 0), 1))\n \t\t\t + GET_MODE_SIZE (mode) - 1))\n-    return ADDR_REGS;\n-\n-  if (reg_classes_intersect_p (FP_REGS, class)\n-      && mode == TFmode\n-      && GET_CODE (out) == MEM\n-      && GET_CODE (XEXP (out, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (out, 0), 1)) == CONST_INT\n-      && !DISP_IN_RANGE (INTVAL (XEXP (XEXP (out, 0), 1))\n-\t\t\t + GET_MODE_SIZE (mode) - 1))\n-    return ADDR_REGS;\n-\n-  if (reg_classes_intersect_p (CC_REGS, class))\n-    return GENERAL_REGS;\n+    {\n+      /* For GENERAL_REGS a displacement overflow is no problem if occuring\n+\t in a s_operand address since we may fallback to lm/stm.  So we only\n+\t have to care about overflows in the b+i+d case.  */\n+      if ((reg_classes_intersect_p (GENERAL_REGS, class)\n+\t   && s390_class_max_nregs (GENERAL_REGS, mode) > 1\n+\t   && GET_CODE (XEXP (XEXP (x, 0), 0)) == PLUS)\n+\t  /* For FP_REGS no lm/stm is available so this check is triggered\n+\t     for displacement overflows in b+i+d and b+d like addresses.  */\n+\t  || (reg_classes_intersect_p (FP_REGS, class)\n+\t      && s390_class_max_nregs (FP_REGS, mode) > 1))\n+\t{\n+\t  if (in_p)\n+\t    sri->icode = (TARGET_64BIT ?\n+\t\t\t  CODE_FOR_reloaddi_nonoffmem_in :\n+\t\t\t  CODE_FOR_reloadsi_nonoffmem_in);\n+\t  else\n+\t    sri->icode = (TARGET_64BIT ?\n+\t\t\t  CODE_FOR_reloaddi_nonoffmem_out :\n+\t\t\t  CODE_FOR_reloadsi_nonoffmem_out);\n+\t}\n+    }\n \n+  /* Either scratch or no register needed.  */\n   return NO_REGS;\n }\n \n@@ -9364,6 +9354,9 @@ s390_reorg (void)\n #undef TARGET_SCALAR_MODE_SUPPORTED_P\n #define TARGET_SCALAR_MODE_SUPPORTED_P s390_scalar_mode_supported_p\n \n+#undef TARGET_SECONDARY_RELOAD\n+#define TARGET_SECONDARY_RELOAD s390_secondary_reload\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-s390.h\""}, {"sha": "a495bc75834cff5cf03b01677a386975a2b94378", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/833cd70a0c91517672ae309a95519bb2f409d304/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/833cd70a0c91517672ae309a95519bb2f409d304/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=833cd70a0c91517672ae309a95519bb2f409d304", "patch": "@@ -464,16 +464,6 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n #define PREFERRED_RELOAD_CLASS(X, CLASS)\t\\\n   s390_preferred_reload_class ((X), (CLASS))\n \n-/* We need a secondary reload when loading a PLUS which is\n-   not a valid operand for LOAD ADDRESS.  */\n-#define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, IN)\t\\\n-  s390_secondary_input_reload_class ((CLASS), (MODE), (IN))\n-\n-/* We need a secondary reload when storing a double-word\n-   to a non-offsettable memory address.  */\n-#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, OUT)\t\\\n-  s390_secondary_output_reload_class ((CLASS), (MODE), (OUT))\n-\n /* We need secondary memory to move data between GPRs and FPRs.  */\n #define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) \\\n  ((CLASS1) != (CLASS2)                                \\"}, {"sha": "bfbb59820e0153847942369f8dd30337ee9bd4f8", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 37, "deletions": 81, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/833cd70a0c91517672ae309a95519bb2f409d304/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/833cd70a0c91517672ae309a95519bb2f409d304/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=833cd70a0c91517672ae309a95519bb2f409d304", "patch": "@@ -893,11 +893,43 @@\n   operands[1] = replace_equiv_address (operands[1], addr);\n })\n \n-(define_expand \"reload_outti\"\n-  [(parallel [(match_operand:TI 0 \"\" \"\")\n-              (match_operand:TI 1 \"register_operand\" \"d\")\n-              (match_operand:DI 2 \"register_operand\" \"=&a\")])]\n-  \"TARGET_64BIT\"\n+\n+;\n+; Patterns used for secondary reloads\n+;\n+\n+; Handles loading a PLUS (load address) expression\n+\n+(define_expand \"reload<mode>_plus\"\n+  [(parallel [(match_operand:P 0 \"register_operand\"  \"=a\")\n+              (match_operand:P 1 \"s390_plus_operand\" \"\")\n+              (match_operand:P 2 \"register_operand\"  \"=&a\")])]\n+  \"\"\n+{\n+  s390_expand_plus_operand (operands[0], operands[1], operands[2]);\n+  DONE;\n+})\n+\n+; Handles assessing a non-offsetable memory address\n+\n+(define_expand \"reload<mode>_nonoffmem_in\"\n+  [(parallel [(match_operand 0   \"register_operand\" \"\")\n+              (match_operand 1   \"\" \"\")\n+              (match_operand:P 2 \"register_operand\" \"=&a\")])]\n+  \"\"\n+{\n+  gcc_assert (MEM_P (operands[1]));\n+  s390_load_address (operands[2], find_replacement (&XEXP (operands[1], 0)));\n+  operands[1] = replace_equiv_address (operands[1], operands[2]);\n+  emit_move_insn (operands[0], operands[1]);\n+  DONE;\n+})\n+\n+(define_expand \"reload<mode>_nonoffmem_out\"\n+  [(parallel [(match_operand   0 \"\" \"\")\n+              (match_operand   1 \"register_operand\" \"\")\n+              (match_operand:P 2 \"register_operand\" \"=&a\")])]\n+  \"\"\n {\n   gcc_assert (MEM_P (operands[0]));\n   s390_load_address (operands[2], find_replacement (&XEXP (operands[0], 0)));\n@@ -1130,19 +1162,6 @@\n   operands[1] = replace_equiv_address (operands[1], addr);\n })\n \n-(define_expand \"reload_outdi\"\n-  [(parallel [(match_operand:DI 0 \"\" \"\")\n-              (match_operand:DI 1 \"register_operand\" \"d\")\n-              (match_operand:SI 2 \"register_operand\" \"=&a\")])]\n-  \"!TARGET_64BIT\"\n-{\n-  gcc_assert (MEM_P (operands[0]));\n-  s390_load_address (operands[2], find_replacement (&XEXP (operands[0], 0)));\n-  operands[0] = replace_equiv_address (operands[0], operands[2]);\n-  emit_move_insn (operands[0], operands[1]);\n-  DONE;\n-})\n-\n (define_peephole2\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n         (mem:DI (match_operand 1 \"address_operand\" \"\")))]\n@@ -1189,16 +1208,6 @@\n   [(set (match_dup 0) (plus:DI (match_dup 1) (match_dup 2)))]\n   \"\")\n \n-(define_expand \"reload_indi\"\n-  [(parallel [(match_operand:DI 0 \"register_operand\" \"=a\")\n-              (match_operand:DI 1 \"s390_plus_operand\" \"\")\n-              (match_operand:DI 2 \"register_operand\" \"=&a\")])]\n-  \"TARGET_64BIT\"\n-{\n-  s390_expand_plus_operand (operands[0], operands[1], operands[2]);\n-  DONE;\n-})\n-\n ;\n ; movsi instruction pattern(s).\n ;\n@@ -1359,16 +1368,6 @@\n   [(set_attr \"op_type\"  \"RX\")\n    (set_attr \"type\"     \"la\")])\n \n-(define_expand \"reload_insi\"\n-  [(parallel [(match_operand:SI 0 \"register_operand\" \"=a\")\n-              (match_operand:SI 1 \"s390_plus_operand\" \"\")\n-              (match_operand:SI 2 \"register_operand\" \"=&a\")])]\n-  \"!TARGET_64BIT\"\n-{\n-  s390_expand_plus_operand (operands[0], operands[1], operands[2]);\n-  DONE;\n-})\n-\n ;\n ; movhi instruction pattern(s).\n ;\n@@ -1625,36 +1624,6 @@\n                                      <MODE>mode, 8);\n })\n \n-(define_expand \"reload_out<mode>\"\n-  [(parallel [(match_operand:TD_TF 0 \"\" \"\")\n-              (match_operand:TD_TF 1 \"register_operand\" \"f\")\n-              (match_operand:SI 2    \"register_operand\" \"=&a\")])]\n-  \"\"\n-{\n-  rtx addr = gen_lowpart (Pmode, operands[2]);\n-\n-  gcc_assert (MEM_P (operands[0]));\n-  s390_load_address (addr, find_replacement (&XEXP (operands[0], 0)));\n-  operands[0] = replace_equiv_address (operands[0], addr);\n-  emit_move_insn (operands[0], operands[1]);\n-  DONE;\n-})\n-\n-(define_expand \"reload_in<mode>\"\n-  [(parallel [(match_operand:TD_TF 0 \"register_operand\" \"=f\")\n-              (match_operand:TD_TF 1 \"\" \"\")\n-              (match_operand:SI 2    \"register_operand\" \"=&a\")])]\n-  \"\"\n-{\n-  rtx addr = gen_lowpart (Pmode, operands[2]);\n- \n-  gcc_assert (MEM_P (operands[1]));\n-  s390_load_address (addr, find_replacement (&XEXP (operands[1], 0)));\n-  operands[1] = replace_equiv_address (operands[1], addr);\n-  emit_move_insn (operands[0], operands[1]);\n-  DONE;\n-})\n-\n ;\n ; mov(df|dd) instruction pattern(s).\n ;\n@@ -1772,19 +1741,6 @@\n   operands[1] = replace_equiv_address (operands[1], addr);\n })\n \n-(define_expand \"reload_out<mode>\"\n-  [(parallel [(match_operand:DD_DF 0 \"\" \"\")\n-              (match_operand:DD_DF 1 \"register_operand\" \"d\")\n-              (match_operand:SI 2    \"register_operand\" \"=&a\")])]\n-  \"!TARGET_64BIT\"\n-{\n-  gcc_assert (MEM_P (operands[0]));\n-  s390_load_address (operands[2], find_replacement (&XEXP (operands[0], 0)));\n-  operands[0] = replace_equiv_address (operands[0], operands[2]);\n-  emit_move_insn (operands[0], operands[1]);\n-  DONE;\n-})\n-\n ;\n ; mov(sf|sd) instruction pattern(s).\n ;"}]}